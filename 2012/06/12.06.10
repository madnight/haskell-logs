00:04:30 <anicake> hello everyone... im a newbie
00:04:41 <anicake> i have two books for learning haskell
00:04:58 <anicake> 1. learn you a haskell for great good
00:04:59 <anicake> and
00:05:06 <anicake> 2. real world haskell
00:05:06 <rlpowell> RWH?  :)
00:05:12 <shachaf> anicake: Channel consensus is that you should read LYAH first and then RWH.
00:05:22 <shachaf> I haven't read either very thoroughly so I don't really know.
00:05:26 <anicake> thanks all!
00:05:37 <rlpowell> I would add to that that for myself, I switched books when LYAH got super abstract.
00:05:50 <rlpowell> But I'm hardly an examplar of Haskell awesomeness.
00:06:13 <rlpowell> Honestly, I think there's a great book waiting in the combination of those two books, trying to get out.  -__
00:06:35 <rlpowell> Each has chapters that are fantastic (for my learning style) and others that ... not so much.
00:06:46 <zxc12> Are you averse to other books as well? I personally found Hutton's book to easier than either when I first started.
00:06:55 <anicake> i happen to be in the same dilemma
00:07:16 <anicake> hutton? i shall google that... thanks
00:07:35 <zxc12> Plus there's some nice lectures to go along with it given by Meijer on Channel 9.
00:08:06 <anicake> channel 9 is a youtube-like website i presume?!
00:08:19 <rlpowell> zxc12: Are any parts of that book available online?
00:08:31 <rlpowell> (doesn't seem like, but thought I'd ask)
00:08:42 <rlpowell> When a book costs $40, I kind of like to try before I buy.  -_-
00:08:49 <rlpowell> Since this is very much a hobby.
00:08:54 <anicake> very true
00:09:11 <zxc12> There was a draft edition floating around before the final edition was finalized.
00:09:12 <Cale> anicake: also, ask lots of questions here
00:09:29 <anicake> yes... this is the first time im logging in here
00:09:38 <anicake> this is extremely friendly
00:09:42 <anicake> thank you very much
00:10:08 <zxc12> It would likely pop up in a google search, though it's good enough that you should buy it even if you find it. Alternatively you could look at the slides from the Meijer lectures as they're composed of content from the book.
00:12:12 <anicake> Question: should a person try to find his way around the library and how to use it on his own after LYAHFGG? or is RWH a must to read... its <700 pages
00:12:38 <anicake> >660 pages
00:13:21 <anicake> quite a long read that one... therefore should it be used a reference? or is it like the absolutely-necessary-if-you-want-to-be-good-at-haskell?
00:13:37 <Cale> I've never really read either of those completely, primarily because I already knew Haskell pretty well before either of them existed. But probably it's worth looking at and seeing if you're interested in the stuff in each chapter
00:13:49 <rlpowell> So I seem to have found a dependency problem in a library; I've downloaded the source and gotten it working with the tweaked dependency list.  How do I put the fixed version where my cabal-dev can see it?
00:14:05 <anicake> @Cale thanks
00:14:05 <lambdabot> Unknown command, try @list
00:14:52 <rlpowell> anicake: THings reccomended to me after I got the basics figured out: http://www.haskell.org/haskellwiki/Typeclassopedia , http://www.haskell.org/haskellwiki/All_About_Monads
00:14:53 <Cale> anicake: At some point you might just read the Report, or at least parts of it -- as far as language specs go, it's not too bad a read, though obviously fairly dry.
00:14:54 <anicake> new to IRC too.. wont annoy you the next time... will come prepared with IRC convention... thanks for the help... bye!
00:15:04 <Cale> heh
00:15:08 <Cale> anicake: see you around!
00:15:30 <anicake> ripowell.. thanks to you too
00:15:32 <anicake> bye
00:23:31 <rlpowell> 10-00:13 < rlpowell> So I seem to have found a dependency problem in a library; I've downloaded the source and gotten it working with the tweaked dependency list.  How do I put the fixed version where my cabal-dev can see it? -- NM; the cabal-dev docs answer that.
00:46:53 <Franciman> hi all
00:47:23 <Franciman> I have got some questions about  UI toolkits:
00:47:51 <Franciman> first, is it better to use a high-level library (like fruits) or a lower level one like hsGtk ?
00:50:36 * hackagebot postgresql-simple 0.1.4 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.1.4 (LeonSmith)
01:03:17 <basti_> hi all
01:03:42 <boo> how do you clear the haskell terminal ?
01:03:43 <boo> clear ?
01:03:45 <boo> system clear ?
01:04:23 <basti_> uhm
01:04:51 <basti_> ctrl-L does well
01:05:14 <basti_> if that doesn't help, ctrl-Z, $ reset", $ fg
01:05:18 <basti_> -"
01:05:34 <basti_> boo: does that help?
01:05:40 <boo> aah cool.. just opened a tutorial :)
01:05:43 <boo> yep works
01:15:39 * hackagebot data-hash 0.2.0.0 - Combinators for building fast hashing functions.  http://hackage.haskell.org/package/data-hash-0.2.0.0 (DanielGorin)
01:22:29 <zzing> Does haskell have the same offside rule as miranda?
01:25:26 <basti_> zzing: what is the exact rule in miranda?
01:26:27 <zzing> from the manual "This  requires  that every token of the object lie either directly below or to the right of its first token"
01:26:55 <machisuji> Haskell newbie here. I wondered, why is it that a Map in Haskell is implemented as a (balanced) binary tree and not in terms of a hash table? I mean is there a reason specific to Haskell/functional programming?
01:27:03 <zzing> So if I have  f x = \n    m  \n where m =    the where has to be under the m or to the right
01:27:53 <basti_> zzing: why don't you just try?
01:28:00 <machisuji> I would have thought that ~constant time insertion and lookup would be preferrable.
01:28:18 <basti_> machisuji: i do not think that every Map is implemented like that
01:29:04 <basti_> machisuji: and then, balanced trees are time-logarithmic in their depth, with a rather large basis, thats about the same as "~constant" ;)
01:29:21 <machisuji> ^^
01:30:12 <machisuji> basti_: how many different maps are there then? I'm only looking at Data.Map. In OOP languages I would look at the subclasses. But that's not working here for some reason. ;)
01:30:36 <rlpowell> machisuji: http://book.realworldhaskell.org/read/barcode-recognition.html -- see the section in there "Life without arrays or hash tables"
01:30:45 <rlpowell> 10-01:29 < machisuji> basti_: how many different maps are there then?  -- IIUC, *lots*.
01:30:58 <machisuji> rlpowell: thank you
01:30:58 <basti_> machisuji: http://hackage.haskell.org/packages/archive/hashmap/1.0.0.2/doc/html/Data-HashMap.html
01:31:02 <basti_> eg.
01:32:52 <machisuji> ah another book I can look into. I'm going through "Learn you a haskell" right now. Didn't know there was another free book online.
01:33:39 <machisuji> real world haskell at least sounds tantalizing
01:33:51 <basti_> haskell is very real world
01:33:51 <rlpowell> Heh.  We were just talking earlier about how you kind of need both of them if you're starting from scratch.
01:34:04 <rlpowell> Warning: the first dozen chapters or so are *not* real world.  -_-
01:34:19 <basti_> if you ever see how a ui callback works in haskell you don't want it any other way anymore.
01:34:19 <rlpowell> In particular, the first parsing library example is *ugh*, but you'll learn a lot from it if you try.
01:35:33 <amatsu> rlpowell: just a side note, do you know of a good introduction to Parsec?
01:35:50 <machisuji> It seems you will always need several books. Way back then when I learned Java as my first language I needed way more than 2 books. :D
01:36:31 <rlpowell> It would be an interesting exercise to describe how the two books interleave for my learning style; how I think you should read them together, in what order.  Like http://www.nomachetejuggling.com/2011/11/11/the-star-wars-saga-suggested-viewing-order/
01:36:38 <rlpowell> amatsu: RWH has a whole parsec section; I haven't read it yet.
01:37:10 <rlpowell> machisuji: Someone here earlier also suggested http://www.cs.nott.ac.uk/~gmh/book.html
01:37:46 <amatsu> rlpowell: ok, will look into it, seems promising.
01:38:28 <machisuji> rlpowell: thanks now I should have enough to really get going with Haskell
01:40:20 <machisuji> I'm kind of disappointed with the haskell platform. I had haskell installed before (probably through brew) but got the platform to get cabal and stuff. Now my ghci segfaults regularly. :/
01:40:34 <rlpowell> Can I have an import statment like "import everything from here except wibble"?
01:41:16 <morel> no
01:41:32 <rlpowell> Oh, I just found http://www.haskell.org/haskellwiki/Import that says to use "hiding"?
01:41:42 <morel> oh wait.
01:41:49 <morel> i misunderstood you.
01:41:53 <rlpowell> :)
01:42:08 <morel> i though you want to import all modules in the current directory except wibble…
01:42:17 <morel> rlpowell: yup, use hiding then =)
01:42:40 <rlpowell> Thanks.
01:47:11 <shachaf> zxc12: Right, Hutton's book is quite good.
01:47:30 <shachaf> zxc12: But I assumed that anicake already had physical copies of these two.
01:51:16 <chaotic_good_> I have huttons book and it seems designed for beginners, but its annoying he uses symbols not on keyboard and you must translate using lil table at back of book.
01:51:48 <chaotic_good_> I am also unsure if it is academically designed and thus really for selling to students or for me the unix admin wishing to learn coding on my own.
01:51:50 <shachaf> He uses a combined character that looks like ">>=" instead of ">>=".
01:52:13 <chaotic_good_> yes I am not sure how even the book had it typeset symbol is strange
01:52:19 <shachaf> It's not as if he makes up crazy symbols.
01:52:33 <chaotic_good_> are they mathematical or simply haskell creatures?
01:53:09 <rlpowell> 10-01:51 < shachaf> He uses a combined character that looks like ">>=" instead of ">>=". -- That's pretty awful, IMO.
01:53:49 <shachaf> I didn't mind it.
01:57:52 <zzing> Are there any template solutions for HTML stuff that can take an existing HTML file and fill in spots? I am having trouble finding something like this, as I don't want to encode too much in a DSL meant for this.
01:59:59 <chaotic_good_> yesod snap happstack etc are web frameworks
02:01:35 <morel> zzing: blaze-html has a nice converter.
02:02:17 <morel> zzing: http://hackage.haskell.org/package/blaze-from-html
02:02:38 <morel> this program converts html to haskell code which uses blaze-html.
02:03:16 <zzing> morel, I am using the happstack-lite tutorial right now that uses blaze-html, so with this I would make my template and run it through this tool and integrate it?
02:03:41 <chaotic_good_> dunno
02:03:58 <morel> zzing: yup
02:04:18 <zzing> morel, not quite what I was hoping for, but I will take what I can get for now. Unless there are other things I should consider.
02:04:49 <morel> zzing: there are also ways to write HTML directly into Haskell code.
02:04:53 <morel> using TemplateHaskell.
02:04:57 <zzing> This using haskell has a webapp server tickles my programmer bone, but worries my netadmin bones :P
02:05:04 <zzing> morel, packages that exist right now?
02:05:05 <morel> zzing: read the happstack-crashcourse for more info.
02:05:09 <morel> zzing: yup
02:05:12 <morel> wait…
02:05:39 <morel> zzing: http://www.happstack.com/docs/crashcourse/Templates.html#hello-hsp
02:05:49 <morel> do you see that html-code? great, huh?
02:05:55 <zzing> hsp… waiting for it to load
02:06:00 <zzing> reminds my of asp
02:06:09 <morel> zzing: also join #happs
02:06:14 <zzing> already there
02:06:16 <zzing> nobody exists
02:06:17 <ocharles> morel: there is also heist, that's quite nice
02:06:20 <zzing> or answering
02:06:23 <morel> :D
02:06:23 <zzing> ok, it loaded
02:06:35 <zzing> OMG
02:06:41 <zzing> I love this
02:07:05 <morel> ocharles: does heist also allow inline-html?
02:07:42 <bitonic> morel: in heist the templates are htmlish files loaded dynamically
02:07:52 <bitonic> tbh hsp is kinda dirty, but still fun
02:07:56 <morel> nice
02:08:19 <zzing> bitonic, is it dirty but still 'clean' for a production app?
02:08:45 <morel> zzing: it's fine… it's not haskell though… it's haskell+TemplateHaskell. ;)
02:08:52 <zzing> Which is quite fine
02:08:54 <morel> e.g. it doesn't run on ARM machines, AFAIK.
02:09:03 <zzing> That won't be a problem
02:09:43 <morel> zzing: anyway, it'd be probably better to use heist if there's no problem with it…
02:10:14 <zzing> morel, do you have a magic url that shows that stuff like you amazed me with this magic?
02:11:11 <zzing> I am going to have to learn this template haskell.
02:11:29 <ocharles> morel: i don't think hsp is template haskell
02:11:36 <zzing> Q: In theory, could template haskell be used to integrate objective C calls inside of haskell code?
02:11:41 <morel> zzing: go sleeping. and then wake up and read the happstack-lite tutorial and then the happstack-crashcourse. you'll be a pro afterwards.
02:11:43 <morel> @time zzing
02:11:44 <lambdabot> Local time for zzing is Sunday, 10 June, 2012 5:11:22 AM Eastern Daylight Time
02:11:49 <morel> ocharles: i do.
02:11:59 <ocharles> morel: there is TemplateHaskell language pragma on that page
02:12:08 <zzing> morel, half down then :P
02:12:13 <zzing> thank you all
02:12:14 <zzing> Peace.
02:12:28 <morel> ocharles: there is? or not?
02:12:33 <ocharles> morel: there is not*
02:12:37 <morel> zzing: good night.
02:13:03 <morel> ocharles: hmm… how does it work then?
02:14:50 <morel> ocharles: i can't imagine it's pure haskell…
02:16:56 <bitonic> morel: it runs a preprocessor on the file
02:17:11 <bitonic> you can tell ghc to do that with a flag
02:17:39 <morel> aaah!
02:18:18 <bitonic> as I said, quite dirty.
02:18:34 <ocharles> I think I find a preprocesser even more dirty :)
02:20:17 <bitonic> ocharles: ...that's what I'm saying
02:23:53 * morel . o O ( there should be a C with haskell syntax… )
02:45:47 * hackagebot Elm 0.2.0 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.2.0 (EvanCzaplicki)
02:45:49 * hackagebot elm-server 0.2.0 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.2.0 (EvanCzaplicki)
02:53:58 <rlpowell> I'm trying to turn Text into Int, and I seem to be missing something.
02:54:10 <rlpowell> I've got like: read (unpack [stuff]) :: Int
02:54:36 <rlpowell> and the unpack step is giving me:     Couldn't match expected type `Char'                 with actual type `GHC.Word.Word8'
02:54:54 <shachaf> Are you sure that's Text?
02:55:01 <shachaf> Where's "unpack" coming from?
02:55:16 <shachaf> And why are you giving it a list argument rather than a Text argument? What's the type of "stuff"?
02:55:40 <rlpowell> Ahhh, I see, it's the wrong unpack.
02:55:51 <rlpowell> Sorry, [stuff] was supposed to be a placeholder for arbitrary crap.
02:56:01 <rlpowell> I'm only imperting Text from Text.  Whoops.
02:56:09 <shachaf> import qualified Text as T
03:30:06 <basti_> how do modules relate to "main"?
03:30:19 <basti_> am i supposed to write a "global" main function that calls a module?
03:31:01 <benmachine> basti_: main is just a thing that you define in the Main module
03:31:23 <benmachine> then when you compile it, it becomes your entry point
03:31:39 <benmachine> so the Main module imports all the other modules it needs
03:32:12 <basti_> okay.
03:35:41 <basti_> benmachine: thanks :) that works.
03:54:16 <amatsu> Is main a reserved keyword?
03:55:58 <shachaf> No.
03:56:28 * shachaf >>= sleep
04:02:45 <ion> Drawing *what* out of shachaf, sleep it?
04:09:16 <amatsu> The shachaf monad...?
04:11:06 * hackagebot postgresql-simple 0.1.4.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.1.4.1 (LeonSmith)
04:13:25 <shirt> does the standard deriving (Show) ever put unicode characters in the output, or is it safe to assume ascii?
04:14:06 <benmachine> well, it will call show on subcomponents of your structure
04:14:12 <benmachine> which need not use the standard deriving
04:15:19 <benmachine> also, your data constructors are permitted to contain unicode
04:15:41 <benmachine> so no, it's not safe, unless you control the data declaration in question
04:16:47 <bitonic> benmachine: the deriving mechanism alone is enough to generate unicode, I think, with UnicodeSyntax
04:17:06 <benmachine> bitonic: or without UnicodeSyntax!
04:17:14 <bitonic> If you have constructors with unicode in them
04:17:15 <shirt> hm.... ok. but the regular String show will never contain unicode, right?
04:17:16 <benmachine> UnicodeSyntax only affects things like using → for functions
04:17:24 <benmachine> you can just put unicode in constructors all you like
04:17:35 <benmachine> shirt: I do wonder what's so hard about just supporting unicode :P
04:17:46 <benmachine> shirt: but I think String's show escapes everything
04:17:57 <bitonic> benmachine: oh, right.
04:18:07 <fmap> > show "α"
04:18:08 <lambdabot>   "\"\\945\""
04:18:42 <shirt> benmachine: hm... i guess it shouldn't be so hard. doesn't basic hPutStrLn now support utf8 encoding?
04:18:51 <benmachine> shirt: yeah
04:19:04 <benmachine> give it a unicode string, it will output it
04:19:11 <benmachine> if the handle is in text mode
04:20:43 <shirt> awesome
04:21:36 <fmap> i'd guess derived show will escape (show Δ) in data Δ = Δ too
04:21:52 <benmachine> fmap: nope
04:22:15 <benmachine> you get show Δ = "Δ"
04:22:23 <benmachine> anything else would be outright wrong
04:22:29 <fmap> hm
04:22:38 <fmap> my ghci says "\916"
04:22:51 <benmachine> yeah, that's equal to "Δ"
04:22:58 <fmap> ah, sure
04:23:00 <fmap> nvm
04:23:06 <benmachine> it's converting the data to a string, and then showing the string
04:23:18 <benmachine> it's the latter that does the escaping
04:23:24 <shirt> > show "Δ"
04:23:25 <lambdabot>   "\"\\916\""
04:36:10 * hackagebot postgresql-simple 0.1.4.2 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.1.4.2 (LeonSmith)
04:50:51 <Franciman> hi, where can I find a tutorial to use Grapefruit, or any other graphical toolkit you may want to suggest me?
05:16:20 * hackagebot graphics-drawingcombinators 1.4.3 - A functional interface to 2D drawing in OpenGL  http://hackage.haskell.org/package/graphics-drawingcombinators-1.4.3 (EyalLotem)
05:16:49 <applicative> Franciman: Maybe they are at a lower level than you were thinking, but the main big packages wxhaskell  and gtk2hs include fairly extensive graded examples folders
05:17:44 <applicative> https://github.com/jodonoghue/wxHaskell/tree/master/samples
05:17:54 <Franciman> applicative, ok thanks. I wanted to use something like grapefruit because I wanted to learn FRP
05:18:23 <Franciman> btw, great, thanks :)
05:18:53 <applicative> Franciman: I was wondering if that was your purpose
05:19:21 <applicative> I dont follow it enough to know what the going frp scheme is
05:20:35 <applicative> someone knowledgeable was praising sodium to me not long ago.   I think if you happen by at the right moment youll get a million opinions
05:21:07 <Franciman> :)
05:21:53 <applicative> https://github.com/the-real-blackh/sodium   -- the example will offend dog lovers
05:22:45 <Franciman> lol, thanks again
05:26:12 <applicative> oh i forgot, reactive-banana has an extensive examples folder for wx  https://github.com/HeinrichApfelmus/reactive-banana/tree/master/reactive-banana-wx/src
05:41:53 <applicative> Franciman: oh, it does have a decent looking tutorial http://www.haskell.org/haskellwiki/FRP_explanation_using_reactive-banana and elsewhere on the wiki
05:44:59 <Franciman> applicative, thanks again :D
05:45:37 <applicative> hm this just in http://www.reddit.com/r/haskell/comments/uuarz/what_is_rhaskells_favorite_frp_library/
05:46:43 <shirt> data X = A{a::Int} | B{b::String}
05:46:50 <shirt> how do i check if an X is an A or a B?
05:47:24 <byorgey> shirt: pattern-match.
05:47:42 <byorgey> isA (A _) = True; isA (B _) = False
05:47:44 <shirt> byorgey: how can i pattern match without having to count the number of fields?
05:47:56 <byorgey> isA (A {}) = True; isA (B {}) = False
05:48:13 <byorgey> the {} notation will work no matter how many fields there are
05:48:27 <shirt> awesome, thanks. did not know that
05:48:46 <basti_> yay :)
05:48:50 <basti_> i fixed that memory leak
05:52:49 <mentus> hello
05:53:02 <byorgey> hi mentus
05:53:11 <mentus> hi
05:53:43 <mentus> i have a question regarding Maybe type
05:53:44 <byorgey> mentus: trying haskell? =)
05:53:49 <mentus> yes
05:53:51 <byorgey> great, ask away
05:54:02 <mentus> trying to traslate one CL exercise solution to haskell
05:54:35 <mentus> can i paste here a code snippet?
05:54:45 <byorgey> mentus: use hpaste.org
05:54:55 <mentus> ok
05:55:36 <hpaste_> mentus pasted “Maybe Node” at http://hpaste.org/69771
05:55:59 <mentus>     Not in scope: `name'
05:56:15 <mentus> this is the error i am getting if i try to compile it
05:56:37 <applicative> you need to wrap the right hand side
05:57:09 <james-ubc> heyyy
05:57:13 <james-ubc> im having trouble installing yi
05:57:27 <mentus> how should i wrap it?
05:57:40 <hpaste_> byorgey annotated “Maybe Node” with “Maybe Node (annotation)” at http://hpaste.org/69771#a69772
05:57:49 <byorgey> mentus: ^^^ here's what I would do.
05:58:02 <hpaste_> applicative annotated “Maybe Node” with “Maybe Node (annotation)” at http://hpaste.org/69771#a69773
05:58:11 <james-ubc> Loading package terminfo-0.3.2.3 ... <command line>: can't load .so/.DLL for: ncursesw (/lib64/libncursesw.so: file too short)
05:58:12 <james-ubc> cabal: Error: some packages failed to install:
05:58:12 <james-ubc> yi-0.6.5.0 failed during the building phase. The exception was:
05:58:12 <james-ubc> ExitFailure 1
05:58:14 <applicative> haha
05:58:18 <byorgey> mentus: what you had before is not a valid way to declare a type.  It has to be just a list of constructors with fields.
05:58:36 <mentus> ok
05:58:51 <byorgey> or you can do what applicative did, which is to basically inline the definition of Maybe
05:59:03 <byorgey> but that means you can't use all the existing machinery for working with Maybe
05:59:03 <mentus> thanks for your solution. i was actually thinking of doing the same, but i though the former way has to be possible somehow
05:59:58 <byorgey> james-ubc: looks like there is some problem with your ncurses installation
06:00:27 <applicative> byorgey's method is the right one.  His extractors are nice total functions.
06:00:42 <byorgey> oh, that too
06:00:51 <mentus> applicative: thanks. that was actually my very first solution, but thought that it would be more elegant to use something which is already there in haskell -> Maybe
06:01:39 <byorgey> mentus: you had the right idea, it is more elegant.  You just can't combine declaring the type and wrapping with Maybe into the same declaration
06:02:42 <mentus> byorgey: ok, clear. thanks for help.
06:02:51 <mentus> talk to you some other time
06:03:52 <applicative> mentus: it depends on the case whether that is best.  The two types are a little different, or am I in a typical muddle.  Mine can have null or full leaves
06:04:00 <james-ubc> byorgey: so uh how could tha be fixed? it appears
06:04:23 <james-ubc> fine O.o
06:04:49 <byorgey> james-ubc: unfortunately, I have no idea
06:04:52 <mentus> applicative: yes, that's also right...
06:05:09 <byorgey> oh, silly me, I didn't really pay attention to the fact that it is recursive o.O
06:05:23 <byorgey> applicative is right of course, they are different.
06:05:47 <byorgey> mine is either nothing, or an infinite tree =P
06:05:55 <byorgey> which is probably not what you wanted.
06:06:12 <applicative> mentus: this is because the original question was basically syntactic
06:06:30 * hackagebot Elm 0.2.0.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.2.0.1 (EvanCzaplicki)
06:07:07 <byorgey> mentus: ok, well, there ARE ways to reuse Maybe, but they are much more complicated and probably not worth it.
06:07:36 <byorgey> s/probably/definitely/
06:07:58 <byorgey> sorry for the confusion!
06:08:03 <mentus> byorgey: ok, i understand. thanks
06:12:16 <hpaste_> applicative annotated “Maybe Node” with “Maybe Node (annotation) (annotation)” at http://hpaste.org/69771#a69775
06:12:16 <mentus> bye guys, i am leaving
06:12:19 <applicative> mentus I think for a tree  type recycling maybe isn't going to be so great .  Here's another variant
06:12:48 <james-ubc> :(
06:13:22 <james-ubc> i guess ill just wait til they fix it then
06:13:54 <mentus> applicative: i still haven't learned about newtype,
06:14:13 <applicative> mentus: its the same as if I had used data
06:14:34 <applicative> it has an advantage where there is just one field on the right hand side
06:14:38 <benmachine> james-ubc: oh wait, I know your problem
06:14:41 <benmachine> I think
06:15:03 <applicative> I considered writing data
06:15:17 <hpaste_> bungley pasted “multiline in ghci fail” at http://hpaste.org/69776
06:15:30 <bungley> ^^ anyone care to tell me how i should be doing that?
06:15:51 <benmachine> james-ubc: I think what you have is that /lib64/libncursesw.so is an ld linker script
06:16:08 <benmachine> james-ubc: tell me what 'file /lib64/libncursesw.so' in a shell makes of it
06:17:25 <james-ubc> benmachine: ascii text
06:17:26 <HairyDude> Does ghc support armel? if so how well?
06:18:10 <benmachine> james-ubc: yeah, okay. this next bit I'm a bit vague on: do you have a /usr/local/lib? do you have an LD_LIBRARY_PATH?
06:19:19 <pooya72> so it's kind of annoying that none of the libraries install on haskell-platform-2012: http://pastebin.com/Prn6JLus
06:19:25 <mauke> The paste Prn6JLus has been copied to http://hpaste.org/69777
06:19:38 <bungley> is it not possible to write epressions like that at the interactive prompt? :(
06:20:02 <applicative> bungley: I  cant do guards either. A little surprising.
06:20:03 <benmachine> pooya72: hmm. what does it say will be reinstalled?
06:20:17 <Peaker> bungley, you need a "let"
06:20:22 <Peaker> (I think)
06:20:31 <bungley> applicative: thanks for trying
06:20:36 <benmachine> bungley: it's possible, but it's not very pleasant; using a file is much better
06:20:37 <bungley> Peaker: i'll give it a go, thanks
06:20:47 <james-ubc> benmachine: err how do i check that?
06:21:17 <james-ubc> im on f17 if that helps
06:21:21 <Peaker> Guards work for me with a "let"
06:21:33 <gienah> pooya72: cabal-dev needs a patch: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/cabal-dev/files/cabal-dev-0.9.1-tf-0.3.patch
06:21:36 <benmachine> james-ubc: have a look in /usr/local/lib and see if it exists/contains anything interesting
06:21:47 <james-ubc> benmachine: it's empty
06:21:53 <benmachine> james-ubc: okay, cool
06:22:28 <benmachine> hmm, is there a /usr/local/lib64?
06:22:42 <benmachine> (if anyone's listening who knows what they're doing, it would be great if you could take over :P)
06:23:07 <benmachine> (I promise not to break anything but I don't promise I can fix anything)
06:23:20 <applicative> Peaker: bungley: yes  it works with a let, somehow the  fancy multiline machinery makes you forget it
06:23:40 <Peaker> james-ubc, what platform are you on?
06:23:56 <pooya72> benmachine: here's the full message: http://hpaste.org/69778
06:24:08 <james-ubc> Peaker:  fedora 17
06:24:09 <Peaker> applicative, yeah, suddenly it looks like a file, so you expect it to behave like a file too
06:24:20 <applicative> yes
06:24:23 <pooya72> gienah: yeah, it's just a couple simple dependencies that need to be updated.
06:24:56 <Peaker> james-ubc, what does "file /lib64/libncursesw.so" say?
06:25:07 <benmachine> Peaker: ascii text
06:25:10 <benmachine> I asked that already :P
06:25:13 <Peaker> oh, sorry
06:25:38 <Peaker> what is in that text?
06:26:02 <pooya72> gienah: It's just annoying that there not updated already. Here's the pull request for cabal-dev https://github.com/creswick/cabal-dev/pull/55
06:26:30 <benmachine> bungley: I think all :{ and :} do is join together all the text on the lines in between and execute it as one command
06:26:38 <pooya72> So is everybody running haskell-platform 2011 or have people just moved on beyond haskell platform?
06:26:48 <benmachine> bungley: so if you want to do multiline defs, you need explicit { ; }
06:27:06 <benmachine> pooya72: I think not everyone has updated yet
06:27:22 <benmachine> something like snap, you have a million dependencies, it can be a little slow for them all to get updated
06:27:31 <gienah> pooya72: me runs the latest stuff
06:27:55 <james-ubc> Peaker:  INPUT(libncursesw.so.5 -ltinfo)
06:27:57 <benmachine> I don't use the platform at all, but it's considered good form to be compatible with it, if you're releasing a library
06:28:54 <applicative> pooya72: after a new haskell platform comes out there is usually a brief of chaos.  you shouldn't be so cutting edge...
06:29:08 <applicative> brief PERIOD of chaos
06:29:52 <Peaker> james-ubc, is /lib64/libncursesw.so.5 a real library or also a text file?
06:30:06 <pooya72> applicative: yeah, I thought the release cycles were different. Like there's first haskell-platform-2012 -dev which all the developers use to update the libraries, then it's released to everyone else.
06:30:17 <HairyDude> Anyone have experience with ghc on debian armel?
06:30:29 <benmachine> pooya72: everything that is in the platform existed before the platform was released
06:30:37 <benmachine> pooya72: the platform just collects it together
06:30:41 <benmachine> so developers already have a little time
06:30:51 <pooya72> applicative: sometimes it's not about choice. if you do brew install haskell-platform you're going to get 2012.
06:30:51 <applicative> pooya72: that too
06:31:12 <fragamus> So I want to clear up a question.  Using the State monad I can still write pure code.  I can call runState or whatever and extract the results, and it can be called from a pure function right?
06:31:13 <benmachine> pooya72: fyi, it looks like heist is the problem, it depends on mtl 2.0.* so isn't compatible with 2.1
06:31:26 <ski> fragamus : yes
06:31:32 <benmachine> pooya72: well, it's at least *a* problem, at any rate (with installing snap, that is)
06:31:34 <applicative> ah, benmachine found it.
06:31:47 <benmachine> fragamus: State *is* pure
06:31:50 <pooya72> so should I just go back to 2011 wait a couple months then go to 2012
06:31:52 <fragamus> now this is not posseble with the IO monad right?
06:31:56 <benmachine> right
06:32:01 <ski> fragamus : using `State' is "just" a way to hide the state-passing
06:32:02 <HairyDude> fragamus: State is just a way to make pure code look not pure.
06:32:05 <Peaker> fragamus, yeah, the "State" monad is an example that "purity" is a nuanced concept
06:32:12 <pooya72> benmachine: or should I brave it and change the the snap.cabal :)
06:32:27 <gienah> pooya72: for heist we sed the cabal file and patch it for blaze-html-0.5: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/heist/heist-0.8.0-r2.ebuild https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/heist/files/heist-0.8.0-blaze-html-0.5.patch
06:32:35 <benmachine> pooya72: you'd have to change heist.cabal, unfortunately, so it's a bit of a mess
06:32:43 <james-ubc> Peaker: it's a link to libncursew.so.5.9
06:32:45 <benmachine> I think cabal-dev was invented to deal with this but I don't use it myself, so I can't help
06:32:51 <james-ubc> and doing file on that one results in /lib64/libncursesw.so.5.9: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=0x87401bdbcebbd3b26a5c35d5e269af9e4103eef9, stripped
06:33:22 <ski> fragamus : in a language with uniqueness types like in Clean, it might be possible to do something similar with an `IO' type -- but in Haskell, `IO' is an abstract type
06:33:28 <Peaker> james-ubc, great, so basically you want to tell cabal/ghc to use -ltinfo with libncursesw.so.5 to build terminfo
06:33:36 <fragamus> ok and the reason that it is not possible with the IO monad is that no runner is exported that doesn't return something in the IO monad right?
06:33:57 <ski> fragamus : yes, that's the immediate reason
06:34:04 <fragamus> k
06:34:08 <fragamus> i get it
06:34:23 <ski> fragamus : then there's underlying reasons for why there is no such runner exported ..
06:34:27 <james-ubc> Peaker:  o.o okay, how do i do that? O.o
06:34:35 <fragamus> yes i get that
06:34:52 <Peaker> james-ubc, terminfo is the package that fails to build, right?
06:34:58 <pooya72> out of all the libraries, yesod worked the best out of the box with platform 2012
06:35:34 <james-ubc> Peaker:  yeah
06:35:47 <Peaker> did you cabal unpack terminfo into its own directory somewhere you can test on?
06:36:10 <Peaker> james-ubc, if not, use "cabal unpack terminfo && cd terminfo*"
06:37:04 <Peaker> not sure how to tell -l which .so.X to use
06:37:50 <james-ubc> Peaker:  done
06:37:55 <Peaker> james-ubc, "cabal configure" in that directory
06:38:06 <benmachine> pooya72: fwiw, it looks like the heist source repository is already updated, just hasn't been released yet
06:38:11 <Peaker> james-ubc, then you should get a "terminfo.buildinfo" file in there
06:38:23 <Peaker> james-ubc, you can try to edit it manually
06:38:31 <pooya72> benmachine: i c...
06:39:37 <Peaker> james-ubc, try setting the extra-libraries: to libncursesw.so.5 tinfo   and if that doesn't work, the full path of the .so.5 filename
06:40:01 <benmachine> pooya72: you could do something devious, like, git clone https://github.com/snapframework/heist.git then go and edit heist.cabal to set the version to 0.8.0.0.20120610 then 'cabal install' in that directory
06:40:36 <benmachine> pooya72: that probably comes with no warranty though, given that it's unreleased code
06:40:58 <pooya72> benmachine: yeah, i think patience is a virtue. :)
06:41:09 <benmachine> pooya72: fair enough :)
06:41:49 <benmachine> but you could e-mail snap@snapframework.com to say "hey guys, I've just been bitten by this thing, if you could release a new version that'd be great, love, pooya72"
06:42:08 <applicative> i was about to recommend https://github.com/snapframework/heist/blob/master/heist.cabal before  i got cut off
06:42:13 <pooya72> benmachine: yeah i was going to open an issue on github
06:42:34 <james-ubc> Peaker:  tinfo?
06:42:40 <benmachine> pooya72: that would be kind of weird given that it's already fixed on github, but I guess that could work
06:42:41 <applicative> pooya, the patch was made two months ago, i suspect they just forgot to upload a revision then
06:43:00 <benmachine> yeah actually they already released snap-0.8.1, kinda surprised heist-0.8.1 isn't released too
06:43:21 <pooya72> benmachine: yeah i was going to open an issue on snap
06:43:31 <pooya72> https://github.com/snapframework/snap/issues
06:44:06 <gienah> pooya72: fixed 2 months ago: https://github.com/snapframework/heist/pull/20
06:44:07 <benmachine> pooya72: alternatively, there's #snapframework
06:44:28 <pooya72> benmachine: will try there first
06:45:51 <HairyDude> weird. debian armel seems to have yesod -doc packages but not yesod itself
06:46:47 <Peaker> james-ubc, I think every field in there gets a "-l" added
06:46:52 <Peaker> james-ubc, and -ltinfo is what your text lib said
06:46:58 <Peaker> james-ubc, It's basically just trial and error
06:49:41 <james-ubc> Peaker:  tried it with the libncursesw.so.5 -ltinfo and tinfo and -l and the same with /lib64/libncursew.so.5
06:49:51 <james-ubc> still dosnt wan to work :(
06:50:12 <Peaker> james-ubc, what errors?
06:50:35 <james-ubc> Loading package terminfo-0.3.2.3 ... <command line>: can't load .so/.DLL for: ncursesw (/lib64/libncursesw.so: file too short)
06:50:35 <james-ubc> cabal: Error: some packages failed to install:
06:50:35 <james-ubc> yi-0.6.5.0 failed during the building phase. The exception was:
06:50:35 <james-ubc> ExitFailure 1
06:51:26 <Peaker> james-ubc, remove "ncursesw" from extra-libraries?
06:51:31 <Peaker> james-ubc, what do you currently have in extra-libraries?
06:51:50 <Peaker> james-ubc, replace "ncursesw" with the full path of the .so file
06:52:02 <pooya72> benmachine: thanks :)
06:52:10 <benmachine> pooya72: np
06:52:18 <james-ubc> Peaker: /lib64/libncursesw.so.5
06:53:02 <Peaker> james-ubc, oh, you're probably still running "cabal install terminfo" ?
06:53:08 <Peaker> james-ubc, that installs from hackage, the unchanged package
06:53:20 <Peaker> james-ubc, try "cabal install" with no arguments inside the terminfo dir where you did the changes
06:55:26 <james-ubc> Peaker:  it completes
06:56:15 <james-ubc> Peaker:  but yi stull bumps into the same erro O.o
06:56:18 <james-ubc> *error
06:57:08 <gienah> cabal configure --verbose=3 and/or ldd -r /path/libsomething.so might give hints on linking to C/C++ libs
06:57:09 <Peaker> james-ubc, it's pretty annoying that they changed the format of .so files...
06:57:29 <Peaker> james-ubc, yi reports that the file is too short?
06:57:39 <Peaker> james-ubc, the build of "yi"?
06:57:46 <Peaker> or execution of "yi"?
06:58:33 <james-ubc> yeh
06:58:43 <james-ubc> i assume biuld
06:58:57 <james-ubc> because im just tryingto install it atm
07:03:17 <Peaker> james-ubc, do the same unpack & change in yi
07:03:36 <Peaker> "cabal install" in yi's directory
07:06:33 <james-ubc> Peaker:  there's no .biuldinfo file
07:06:45 <james-ubc> Peaker:  atleast i dont see it after configure
07:09:40 <Peaker> james-ubc, try: cabal install yi -fvty
07:10:25 <james-ubc> noooooope
07:10:26 <james-ubc> didnt work
07:10:35 <Peaker> please don't say "didn't work" :) paste an error instead
07:10:44 <james-ubc> same thing
07:10:55 <james-ubc> exactly the same thing o.o
07:10:57 <Peaker> hmm.. I wonder why it chooses ncurses for you and not vty
07:11:04 <Peaker> does "cabal install vty" work?
07:11:40 * hackagebot hakyll 3.3.0.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.3.0.1 (JasperVanDerJeugt)
07:11:44 <james-ubc> it says already installed
07:12:45 <applicative> should he be doing 'cabal  clean' between these attempts
07:14:19 <james-ubc> tried with clean, still nothin :(
07:14:25 <james-ubc> same ol error message
07:16:05 <Peaker> james-ubc, let's try to figure out who's bringing ncurses into the picture
07:16:22 <Peaker> try: cabal install yi --constraint "terminfo < 0"
07:16:34 <Peaker> (to disallow terminfo package, and see who is the culprit forcing it in)
07:17:35 <james-ubc> cabal: There is no available version of terminfo that satisfies <0
07:18:31 <Peaker> james-ubc, add "-v3" to get some more verbose info
07:18:36 <Peaker> who wants terminfo to go in there?
07:20:45 <james-ubc> hrm? so cabal install yi -v3 ?
07:20:57 <Peaker> and --constraint "terminfo < 0"
07:21:20 <Peaker> the idea is that by making it impossible to install terminfo, you should make cabal expose the culprit who is bringing it in
07:21:30 <applicative> vty requires terminfo
07:22:49 <james-ubc> wit hte constarint it jsut returns the no availble verison of terminfo that satisfyies <0
07:24:16 <HairyDude> src/Distribution/Dev/CabalInstall.hs:1:1:
07:24:16 <HairyDude>     Can't do a top-level splice; need a bootstrapped compiler
07:24:16 <james-ubc> [ 17 of 128] Compiling Yi.Buffer.Basic is what it was doing
07:24:30 <james-ubc> before it runs int othe error
07:24:40 <james-ubc> without the --constraint argument
07:25:26 <applicative> james-ubc: what was that error like.  Is it that vty is somehow wrongly  installed?
07:25:33 <applicative> oh
07:25:43 <applicative> HairyDude: how did this happen?
07:25:54 <HairyDude> applicative: trying to install cabal-dev on debian armel
07:26:30 <james-ubc> it deletes some temp files
07:26:41 * hackagebot temporal-music-notation-demo 0.2.1 - generates midi from score notation.  http://hackage.haskell.org/package/temporal-music-notation-demo-0.2.1 (AntonKholomiov)
07:26:52 <HairyDude> this is the ghc 7.0.4 that's in wheezy
07:26:56 <james-ubc> Warning: deleting non-existent /tmp/ghc12814_0/ghc12814_0.s
07:26:57 <james-ubc> *** Deleting temp dirs:
07:26:57 <james-ubc> Deleting: /tmp/ghc12814_0
07:26:57 <james-ubc> <command line>: can't load .so/.DLL for: ncursesw (/lib64/libncursesw.so: file too short)
07:26:57 <james-ubc> /usr/bin/ghc returned ExitFailure 1
07:28:13 <applicative> HairyDude: yipe, template haskell is involved https://github.com/creswick/cabal-dev/blob/master/src/Distribution/Dev/CabalInstall.hs
07:28:41 <ski> > [(n,q) | n <- [0..] , (q,0) <- [(2^n - 1) `divMod` (n + 1)]]
07:28:42 <lambdabot>   [(0,0),(2,1),(4,3),(6,9),(10,93),(12,315),(16,3855),(18,13797),(22,182361),...
07:29:49 <HairyDude> what does the comment about "bootstrapped compiler" mean? does the armel ghc not build itself?
07:29:51 <james-ubc> applicative:  nope just the same :/
07:30:17 <HairyDude> or does it not support TH?
07:30:45 <applicative> HairyDude: it just makes it harder to figure out the problem.
07:31:20 <ski> > [(n,q) | n <- [0..] , (q,0) <- [(2^(n + 1) - 2) `divMod` (n + 1)]]
07:31:21 <lambdabot>   [(0,0),(1,1),(2,2),(4,6),(6,18),(10,186),(12,630),(16,7710),(18,27594),(22,...
07:32:02 <applicative> HairyDude: what ghc do you have?
07:32:24 <shirt> can ghci load .hsc files?
07:32:27 <HairyDude> applicative: as I said, 7.0.4 as packaged for debian wheezy
07:32:40 <applicative> ah
07:33:39 <applicative> HairyDude: have you installed most packages with your package manager?
07:33:47 <HairyDude> applicative: yes
07:33:53 <james-ubc>  btw is anybody still working on porting ghc to arm?
07:33:59 <HairyDude> applicative: I just did aptitude install haskell-platform
07:34:14 <HairyDude> james-ubc: it exists, I'm trying to use it :)
07:35:40 <ski> > [n | n <- [1..] , (q,0) <- [(2^n - 2) `divMod` n]]
07:35:41 <lambdabot>   [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,1...
07:37:34 <james-ubc> whoa nice jsut found it :D
07:37:56 <james-ubc> man dis yi
07:38:06 <ski> (`dis' ?)
07:38:23 <james-ubc> this
07:38:24 <james-ubc> lol
07:38:41 <Urchin> I just installed it yesterday
07:38:52 <james-ubc> never spent 3 hours installing a text editor before
07:38:58 <Urchin> it's really not ready for prime-time use as it looks now
07:39:00 * ski was thinking about getting a manual page explaining the disassembly of `yi'
07:39:05 <james-ubc> and come up with nothing O.o
07:39:13 <Urchin> I've done it in 2
07:39:14 <HairyDude> applicative: is there a problem with that? should I do cabal upgrade or something?
07:39:35 <HairyDude> ah, disabled, nm
07:39:36 <roconnor> preflex: seen edwardk
07:39:37 <preflex>  edwardk was last seen on #haskell 14 hours, 37 minutes and 50 seconds ago, saying: OI doesn't work very well, stick to IO ;)
07:40:36 <ski> (roconnor_ : i assume you're aware of connection problems)
07:43:38 <applicative> HairyDude: this is seeming pretty hard.
07:44:10 <applicative> HairyDude: I mean for the like of me.
07:44:23 <Rotaerk> ..
07:44:31 <HairyDude> applicative: what do you mean?
07:45:23 <applicative> HairyDude: It's just that the error is of a kind I dont get.  It comes from here fwiw (don't look) http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-7.4.1/src/TcRnDriver.html
07:45:44 <fragamus> Here's my analogy: A monad is like a tune with evenly spaced doors as you go along. There's a guard at each door. The rules enforced by the guards vary from one type of tunnel to another.
07:45:52 <fragamus> tunnel
07:45:55 <fragamus> not tune
07:45:56 <applicative> ski, what do you mean, the disassembly of yi?
07:46:02 * ski read "tune" as "tuna" ..
07:46:09 <fragamus> lol
07:46:14 <ski> applicative : possibly
07:46:21 <fragamus> tunnel
07:47:20 <ski> fragamus : if it works for you, cheers. just don't assume it'll work for everyone else :)
07:47:59 <ski> (what, you wanted feedback on it ?)
07:48:04 <HairyDude> applicative: I could ask haskell-cafe I guess
07:48:06 <Peaker> james-ubc, btw, what ghc are you on?
07:49:25 <james-ubc> Peaker: 7.0.4
07:49:53 <james-ubc> came prepackaged
07:50:06 <Peaker> james-ubc, it's worth a try to try and upgrade to ghc 7.4.1 (or the newest HP)
07:50:09 <Peaker> maybe they support the new text .so files
07:50:53 <applicative> HairyDude: that might be good.  I notice I cant build cabal-dev at the moment for another reason, it requires an old version of mtl.
07:51:05 <ski> fragamus : .. i assume you've read about burritos, yes ?
07:51:16 <fragamus> no
07:51:28 <HairyDude> applicative: a patch for that was posted here several times
07:51:39 <HairyDude> https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/cabal-dev/files/cabal-dev-0.9.1-tf-0.3.patch
07:52:14 <ski> @where burrito
07:52:14 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
07:52:20 <ski> fragamus ^
07:52:34 <applicative> HairyDude: yeah theres a version on github, its obvious anyway, I was just taking it as a sign its not entirely up to date, but this isn't like the problem youre having
07:53:14 <james-ubc> Peaker:  is there a command for that or is it just install the thing from the site
07:53:17 <hpc> a monad is like a monad in the 2-category of categories
07:53:50 <applicative> fragamus: for byorgey's tutorial you need the associated lambdacat
07:54:05 <Peaker> james-ubc, if it is packaged, maybe you can upgrade. if not, you can just install from site
07:54:07 <applicative> for byorgey's anti-tutorial rather
07:54:55 <applicative> fragamus: http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg/1288212148_5KLHJ3V#!i=1288212148&k=5KLHJ3V&lb=1&s=A
07:57:39 <ski> fragamus : also see <http://blog.plover.com/prog/burritos.html>,<http://chrisdone.com/posts/2012-01-06-monads-are-burritos.html>
07:57:41 <HairyDude> ah. It seems TH doesn't work if GHCi is unavailable
07:57:53 <HairyDude> which is true for arm
07:58:26 <applicative> HairyDude: that's what i was inferring too but i didn't know it wasn't on arm
07:58:37 <HairyDude> ah, right
07:58:44 <applicative> HairyDude: cabal dev includes swank ways of calling ghci
07:59:12 <james-ubc> Peaker:  noooooope
07:59:16 <parcs`> > runWriter (tell (+1) >> tell (*2)) 2
07:59:17 <lambdabot>   Couldn't match expected type `t1 -> t'
07:59:17 <james-ubc> Peaker:  same thing -_-
07:59:17 <lambdabot>         against inferred type `((), ...
07:59:41 <james-ubc> looks like yi hates me
07:59:42 <parcs`> > let Endo f = execWriter (tell (+1) >> tell (*2)) in f 2
07:59:42 <HairyDude> ah, then maybe a version of cabal-dev could be made that doesn't include features that it can't support
07:59:43 <lambdabot>   Couldn't match expected type `a -> a'
07:59:43 <lambdabot>         against inferred type `Data.M...
08:00:58 <applicative> HairyDude: there are the other packages that compete cabal-dev, maybe  one would work better?
08:05:51 <Peaker> james-ubc, so "terminfo" installed successfully, but "yi" is failing to link with an ncurses problem?
08:06:15 <Peaker> james-ubc, did "terminfo" fail to install before we made all the changes to its buildinfo file?
08:06:59 <HairyDude> applicative: considering that I'm trying to use yesod or snap which use TH, lack of support for the latter makes this project a non-starter.
08:07:15 <HairyDude> just have to wait for ghci support on arm :(
08:08:43 <james-ubc> Peaker: yeahp
08:09:30 <whald> huh, could it be ghc got quite memory hungry recently? just upgraded to 7.4.1 and as it seems 8GB are not enough for my toy project. had no problems with earlier versions...
08:09:39 <HairyDude> oh well, back to using windows as a development platform for now
08:10:14 <Peaker> james-ubc, not sure how to control cabal's ghc flags when building "yi", maybe someone else can help with that. and replace the "-l" of the text so with the direct .so
08:10:32 <Peaker> james-ubc, another possibility is replacing the text file with the .so it refers to, and try to add the -ltinfo as a flag as well
08:10:43 <Peaker> james-ubc, (though that has system-wide implications, if those matter)
08:11:37 <james-ubc> yeah i woauld stay away from touch sys files :P
08:11:47 <james-ubc> aight well i guess i'll try again in a few months
08:11:56 <james-ubc> thx for all the help :)
08:16:47 * hackagebot librandomorg 0.0.1.0 - Wrapper to Random.org API  http://hackage.haskell.org/package/librandomorg-0.0.1.0 (MatveyAksenov)
08:29:42 <HairyDude> ah, 7.4.2 has ghci support in ARM, apparently
08:35:46 <shirt> how do i find out the type of an exception? Write now i'm catching it as SomeException and i'd like to know exactly what type it is
08:37:09 <hpc> @hoogle handle
08:37:09 <lambdabot> System.IO data Handle
08:37:09 <lambdabot> GHC.IO.Handle data Handle
08:37:09 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
08:37:15 <hpc> @hoogle handles
08:37:15 <lambdabot> Network.StreamSocket handleSocketError :: Socket -> IOException -> IO (Result a)
08:37:15 <lambdabot> Network.TCP data HandleStream a
08:37:15 <lambdabot> Network.HTTP.HandleStream module Network.HTTP.HandleStream
08:37:19 <hpc> hmm
08:37:31 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html#v:catches
08:37:34 <hpc> that
08:38:25 <monochrom> that is to say, you guess several types, and see which one fits
08:39:23 <shirt> i've been trying to guess, and i can't seem to guess right :(
08:39:50 <solirc> shirt: case SomeException e of (show . typeOf) e
08:39:54 <hpc> how is the exception thrown?
08:40:02 <shirt> solirc: i tried that. it just says "SomeException"
08:40:22 <solirc> shirt: no, this will give you the type of the inner exception
08:40:27 <solirc> shirt: try again!
08:40:40 <solirc> shirt: But there is no way to give you the precise type.
08:40:54 <shirt> hpc: it's being thrown from within GHC api, in the function parseDynamicFlags
08:40:55 <hpc> solirc: that doesn't even parse
08:41:13 <solirc> hpc: insert -> as appropriate
08:41:26 <solirc> argh
08:41:43 <hpc> oh, i see
08:41:47 <solirc> shirt: case e of SomeException ie -> (show . typeOf) ie
08:41:53 <hpc> yeah that
08:42:05 <hpc> that's much easier than what i was thinking of
08:42:07 <shirt> solirc: hm... thanks i'll try that
08:42:45 <solirc> shirt: but exceptions can be a hierarchy, and there is no way (or at least I do not know any way) to show you the type of the leave.
08:42:59 <solirc> shirt: You have to manually unwrap it, one constructor at a time
08:43:49 <solirc> shirt: this is one reason why I consider our "Dynamically-Typed Hierarchy of Exceptions" broken.
08:44:14 <solirc> shirt: if you want more reasons, just ask.
08:44:43 <hpc> an exception GADT would work
08:44:57 <hpc> or maybe a data family if you felt like making it open (i wouldn't)
08:44:58 <solirc> hpc: any pointers?
08:45:09 <shirt> solirc: isn't the current exception design a major overhaul of a previous version?
08:45:25 <geekosaur> yes
08:45:32 <hpc> the previous version was even worse
08:45:34 <hpc> and even more dynamic
08:45:37 <geekosaur> exceptions in haskell are something of a tradeoff; the... that
08:46:26 <solirc> I think, just deriving the show instance would help a lot.
08:46:31 <hpc> honestly, all exceptions could be replaced with Either
08:46:37 <hpc> and we would all be better off
08:46:57 <solirc> hpc: division by zero?
08:47:02 <solirc> not sure, maybe
08:47:11 <shirt> hpc: do we really want to return Either from putStrLn ?
08:47:17 <HairyDude> floating point exceptions...
08:47:20 <hpc> heh, true
08:47:27 <Peaker> hpc, hmm.. composing Eithers of different exception types could become a problem.. sounds like it might be doable
08:47:46 <hpc> some of that stuff i figure, if you ever hit an exception there, death is the best option
08:47:54 <hpc> division by zero is one
08:47:54 <HairyDude> putStrLn :: String -> IO (Either IOException ())
08:48:23 <HairyDude> or ErrorT IOException IO ()
08:49:01 <solirc> anyone interested in Cucumber for Haskell?
08:49:22 <hpc> better example, with an action that could throw reasonable exceptions:
08:49:32 <solirc> The only idea I can come up with is using Template Haskell.
08:49:40 <hpc> (Right handle) <- openFile "/etc/passwd" -- ignore errors, this will always work because we are root
08:49:44 <hpc> or
08:49:51 <hpc> do error handling if you really care
08:49:57 <hpc> or ErrorT it
08:50:17 <hpc> but at least now it's visible that there's an error state we aren't handling
08:50:21 <solirc> Would be awesome, though, if we could use some type trickery instead.  Here is my sketch: https://github.com/sol/cucumber-haskell#readme
08:51:57 <hpc> that looks truly terrifying
08:52:22 <solirc> hpc: how you mean?
08:52:40 <copumpkin> I'm not a fan of cucumber
08:52:56 <hpc> the TH to make that work must be insane
08:53:06 <ocharles> +1
08:53:12 <ocharles> (on not a fan of cocumber)
08:53:18 <solirc> hpc: Don't think so, it's basically just currying.
08:53:24 <copumpkin> and I say that as a member of the cucurbitaceae
08:53:38 <solirc> copumpkin: what is that?
08:53:58 <copumpkin> pumpkins are in the same family as cucumbers :)
08:54:02 <benmachine> hpc: how can you tell that IO isn't an ErrorT-like monad?
08:54:03 * HairyDude attempts to build ghc 7.4.2
08:54:29 <benmachine> hpc: except inasmuch as the analogy doesn't work with threads, but I think that's an argument against getting rid of exceptions :)
08:54:47 <solirc> copumpkin: I'd indeed prefer an EDSL, my only requirement is that I can refer to arbitrary terms by some string, and then apply them.
08:55:08 <copumpkin> why by string?
08:55:24 <solirc> because this allows you to write nice specs.
08:55:30 * copumpkin shrugs
08:55:35 <hpc> i think there's definitely demand for making haskell a language where large programs can be obviously crash-free
08:57:08 <solirc> hpc: I think as soon as you do any IO, it is pretty hard to do so.
08:57:30 <navaati> that means finding an alternative to the exception system… or having some sort of proof/requirement that you handle all exceptions, as in java
08:57:59 <solirc> navaati: As in Java catch .. {}
08:58:45 <navaati> well i was more refering to the fact that in Java, the exceptions a procedure can yield are in its type
09:00:53 <HairyDude> except the default ones, like NullPointerException...
09:01:08 <ski> hpc : you know you can say `Right handle <- ...', yes ?
09:01:39 <monochrom> you can't eliminate exceptions. you can only call it different names. but I agree it is better to explicate which exceptions won't happen so you know you have covered all those that may happen
09:01:52 <HairyDude> C doesn't have exceptions :D
09:02:00 <stepcut> HairyDude: not sure what you are doing exactly, but happstack builds on ARM out of the box
09:02:19 <monochrom> in C you hand-code your own exception system
09:02:35 <monochrom> for example, in the unix API, it is called errno
09:03:04 * ski . o O ( `longjmp' )
09:03:15 <HairyDude> ick :)
09:03:33 <monochrom> you can't eliminate exceptions. you can only call it different names, and move it to other programmers
09:03:41 <HairyDude> stepcut: well, I kind of like having ghci anyway...
09:03:56 <stepcut> HairyDude: yeah, ghci is nice :)
09:04:09 <benmachine> hpc: it depends what you mean by "crash-free" – what about e.g. out-of-memory conditions?
09:04:32 <HairyDude> disk full
09:04:38 <benmachine> hpc: I totally agree it would be great to have a total subset of haskell, and an exception-free subset of haskell
09:05:03 <HairyDude> I wonder if agda will ever become a practical programming language
09:05:10 <benmachine> or explicit exceptions, those are cool too
09:05:35 <hiptobecubic> HairyDude, right after haskell ;)
09:05:46 <HairyDude> so, yesterday :P
09:06:42 <HairyDude> agda is nice, but it's just so damn hard to write proofs
09:07:03 <ski> hpc : death to the entire OS ?
09:07:07 <ski> solirc : ask
09:07:31 <solirc> ski: did I miss something?
09:07:53 <monochrom> @type ask
09:07:54 <ski> <solirc> shirt: if you want more reasons, just ask.
09:07:54 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
09:08:04 <monochrom> oh hahaha
09:08:09 <solirc> ski: ah
09:09:24 <solirc> ski: (2) if you catch SomeException, you can't get it's type (assuming we have hierarchy)
09:09:27 <ski> "I think as soon as you do any IO, it is pretty hard to do so." -- which is one reason to try to disentangle useful concepts out of the clutches of the `IO' kitchen sink ..
09:09:42 <solirc> luckily our hierarchy is currently flat
09:10:23 <solirc> ski: oh, that was (1)
09:10:23 <ski> it's not clear to me whether we want open exceptions
09:10:48 <ski> i suspect we want more or less that, in some form, though
09:10:54 <Peaker> HairyDude, what could make it easier?
09:10:54 <solirc> ski: (2) If you see the type of an exception, e.g. ErrorCall, you can't tell where it sits in the hierarchy
09:11:01 <solirc> you have to look at the implementation
09:11:09 <monochrom> use topology to obtain clopen exceptions :)
09:11:26 <ski> solirc : can't one look at the API ?
09:11:28 <upio_> I want to play with MutableByteArray#'s in GHC.Prim, but how do I use State#? Do I have to wrap my calls into IO/ST, and then run that monad?
09:11:33 <solirc> ski: (3) well, no source locations, but maybe it's not fare to blame the exceptions for that.
09:11:38 <solirc> ski: no
09:11:44 <solirc> ski: I don't think so
09:11:47 <solirc> ski: or, can you?
09:11:49 * monochrom imagines a Hitler outrage at "why can exceptions be both open and close!"
09:12:01 <solirc> ski: I think you have to look at the code.
09:12:03 <HairyDude> Peaker: an automatic theorem prover that works in all cases :)
09:12:04 <ski> oh, by `ErrorCall' i thought you meant some random exception a library is throwing
09:12:12 <HairyDude> (i.e. nothing)
09:12:15 <upio_> I don't think it is possible to construct a State# type.
09:12:34 <Peaker> HairyDude, I am hoping that a good, interactive structural editor with background heuristic searches of proofs could be of great help
09:12:42 <Peaker> HairyDude, but I've not really done any Agda :)
09:12:44 <solirc> ski: I mean ErrorCall is an exception, it sits right under SomeException in the tree
09:12:55 <ski> monochrom : hm, i'm not seeing how clopeness fits in ..
09:12:56 <HairyDude> yes, after I said that, I thought of coq and its "auto"
09:13:00 <solirc> but you can't tell without looking at the implementation.
09:13:31 <monochrom> I'm just joking. but perhaps it gets lucky and inspires something
09:13:38 <ski> @hoogle ErrorCall
09:13:38 <lambdabot> Control.Exception.Base ErrorCall :: String -> ErrorCall
09:13:38 <lambdabot> Control.Exception ErrorCall :: String -> ErrorCall
09:13:39 <lambdabot> Control.OldException ErrorCall :: String -> Exception
09:13:43 * ski nods
09:13:53 <solirc> ski: there is a (4), can't remember it right now
09:14:16 <ski> monochrom : yeah, i know :) i was just wondering if there was any half-baked idea behind referring to clopeness :)
09:14:55 <ski> resumable "exceptions" could be useful in some circumstances, i think
09:15:09 <solirc> ski: ah yes (4) we have a hierarchy of exceptions, but the user can't extend the tree at a leaf
09:15:44 <solirc> ski: I wonder if this hierarchy is of any use?
09:16:04 <ski> solirc : i'm not sure
09:16:37 <solirc> ski: And if dropping the idea of an "hierarchy" would give us better design alternatives.
09:16:41 <ski> i assume the point of having a hierarchy is mainly to be able to redirect entire subclasses of exceptions at the same time ?
09:17:20 <ski> in the MLs, there an open type `exn' which you can declare new constructors of at any time (even dynamically, inside a function)
09:17:27 <solirc> ski: anyway, are there any exceptions that do not sit directly under SomeExcetpion?
09:17:44 * ski doesn't know
09:18:46 <hpc> a handler for SomeException can handle any other exception
09:18:50 <hpc> @src SomeException
09:18:50 <lambdabot> Source not found. :(
09:19:15 <hpc> data SomeException = SomeException forall e. Exception e => e
09:19:59 <solirc> hpc: yes, you are right, we make use of the hierarchy
09:20:02 <ski> i'm not sure if it's good that `SomeException' is an instance of `Exception'
09:20:34 <ski> (hpc : transpose the data constructor a few words to the right)
09:20:54 <hpc> oh, yes
09:21:07 <ski> as a consequence of that, we can get `SomeException (SomeException (SomeException (FooException blah)))'
09:21:07 <hpc> i think under the current system, SomeException makes sense
09:21:41 <ski> it would seem to me that it would be nice if we could avoid this nesting of the data constructor `SomeException'
09:22:01 <hpc> ah, it would
09:22:02 <ski> but maybe there's a use for this which eludes me
09:22:31 <hpc> how about using smart constructors to "join" SomeExceptions
09:22:38 <solirc> ski: and here, again, you can't see the nesting from the outside
09:22:42 <ski> if `SomeException' was not in `Exception', then we'd need to explicitly unpack it to throw (possibly with a helper doing that)
09:23:03 <ski> and we'd need variants for catching, which catches any exception into a `SomeException'
09:23:28 <ski> but apart from this, i don't see any ill effects of not having `SomeException' an instance of `Exception'
09:24:06 <ski> (and the good effects would be that the nesting above would be impossible)
09:24:13 <HairyDude> gcc: internal compiler error: Killed (program cc1)
09:24:56 <solirc> ski: You almost never want to catch all exceptions.
09:25:02 <solirc> ski: This brings us to (5)
09:25:24 <ski> hpc : smart constructors would work, except that we'd have to get people to use them, and not miss it somewhere
09:25:27 <solirc> ski: (5) AsyncException sit in the exception tree.
09:25:38 <ski> solirc : you could still have a boolean condition on `SomeCondition'
09:25:56 <ski> @hoogle catchJust
09:25:56 <lambdabot> Control.OldException catchJust :: (Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a
09:25:56 <lambdabot> Control.Exception.Base catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
09:25:56 <lambdabot> Control.Exception catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
09:25:57 <solirc> ^ Under the same node as other "harmless" exceptions
09:26:34 <ski>   catchJustSome :: (SomeException -> Maybe b) -> IO a -> (b -> IO a) -> IO a  -- would be conceivable
09:26:40 <solirc> ski: Yes, that is correct, anyway, I fixed "the ctrl-c bug in more than one place"
09:27:08 <solirc> e.g. in HUnit
09:27:43 <solirc> this indicates to me, that it is at least not obvious how to use it in the correct way.
09:27:59 <ski> solirc : "You almost never want to catch all exceptions." -- yes, but sometimes you want to wrap in some way (also `finally' of course)
09:29:06 <solirc> Java solves it by putting that stuff, that you normally do not want to catch into a separate subtree.
09:29:27 <ski> i.e. if you spawn a computation to execute in another thread, which is supposed to store its result in some location, then if the computation fails with an exception, you want to store a thunk raising that exception in the location
09:30:24 <ski> or you might have an untrusted sub-system, and want to reraise `exn' as `ExnInSubSystemFoo exn'
09:31:30 <solirc> ski: I agree that there are situations, where it is useful to catch everything.
09:32:03 <ski> but i also think it would be useful to consider whether we could incorporate restarts into the system in some way
09:32:54 <ski> i.e. in the sense of handling a condition in condition systems in the lisps, like in MIT/GNU Scheme <http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Error-System.html>
09:33:22 <Neil__> hello /
09:35:59 <ski> see also "Condition Handling in the Lisp Language Family" by Kent M. Pitman in 2001 at <http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html>
09:36:53 <ski> also "Restarting conditions" by Taylor Campbell in 2005 at <http://mumble.net/~campbell/proposals/restart.text> is relevant
09:37:05 <ski> hi there Neil__
09:37:19 * solirc goes back in hacking mode
09:38:35 <ski> @hackage MonadPrompt
09:38:35 <lambdabot> http://hackage.haskell.org/package/MonadPrompt
09:38:44 <ski> seems to be related
09:39:46 <Neil__> Hey Ski
10:01:55 * hackagebot github 0.3.0 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.3.0 (MikeBurns)
10:10:19 <hilhil> Can I switch on profiling by putting something in  the .cabal file, rather than having to specify the --enable-executable-profiling argument to configure every time?
10:10:41 <Peaker> hilhil, executable-profiling: True
10:10:46 <hilhil> thanks!!
10:13:26 <hilhil> One more question, please... do I have to manually specify -auto-all , or is that only an older versions of Haskell ? (I'm using GHC 7.0.3)
10:19:01 <elliott> hilhil: -auto-all still does something, yes.
10:19:07 <elliott> Sometimes you don't want to use it.
10:19:19 <elliott> hilhil: But Cabal will take care of it if you use executable-profiling: True, I *think*.
10:19:19 <elliott> Not sure.
10:19:22 <elliott> Use cabal -v3 to find out.
10:19:55 <Enigmagic> hilhil: you can put it in the ghc-prof-options part of your cabal file
10:22:53 <hilhil> thanks.
10:24:58 <shapr> Goood morning #haskell!
10:25:04 <elliott> hi
10:25:16 <luite> hello
10:25:22 <shapr> hoi luite!
10:25:24 <shapr> Hi elliott!
10:25:29 * shapr bounces cheerfully
10:25:50 <luite> how's married life?
10:26:00 <shapr> Totally awesome!
10:26:35 <shapr> and I still get to code!
10:26:49 <hilhil> I'm getting >Warning: [...]\postparse.cabal: Unknown fields:executable-profiling (line 26)
10:26:58 <elliott> I can only conclude that shapr is IRCing from a trampoline.
10:27:22 <hilhil> >using version 1.10.1.0 of the Cabal library
10:27:56 <elliott> hilhil: Perhaps you need a newer Cabal? (That would mean you want to upgrade GHC, generally. What GHC version are you using?)
10:28:00 <elliott> (Enigmagic probably knows more than me.)
10:28:03 <Enigmagic> hilhil: executable-profiling goes into ~/.cabal/config
10:28:19 <hilhil> ah -- thanks.
10:28:31 <elliott> ah
10:28:50 <hilhil> In that case, does it switch profiling on for all my projects?
10:29:22 <Enigmagic> hilhil: yes, that will switch it on for all projects. i don't think there is a way to do it within a .cabal project other than adding the -prof flags manually and ignoring warnings
10:29:52 <elliott> hilhil: you need profiling versions of your dependencies anyway
10:30:39 <hilhil> When I first tried profiling, I got an error about Parsec not being built with profiling, so I used cabal --reinstall --enable-library-profiling  (I think)
10:30:56 <hilhil> And after that I haven't got any complaints, so I assumed the other libraries were built with profiling options in
10:31:02 <hilhil> Is that not right?
10:31:38 <Enigmagic> if your executable builds with profiling enabled then all the libraries it depends on also have profiling available
10:32:01 <hilhil> The real headache I'm having is that I can't build from the command line -- it just crashes. (According to Cale, it may be a Windows/Unicode issue). So I'm compiling from  leksah, and specifying flags is tricky.
10:32:07 <elliott> hilhil: sounds like you have library-profiling on in your ~/.cabal/config, then
10:32:41 <elliott> hilhil: strange crash
10:32:45 <hilhil> Well, I'm getting some profiling data out -- it's just not useful: http://hpaste.org/69782
10:32:47 <elliott> if it's related to cmd.exe, you could perhaps download Cygwin and use an xterm/rxvt terminal to run the compiler
10:33:08 <elliott> looks to me like you aren't passing -auto-all
10:33:11 <elliott> and so have no SCCs
10:33:31 <hilhil> Tried both     ghc-options: -auto-all
10:33:34 <hilhil> And then     ghc-prof-options: -auto-all
10:33:39 <hilhil> Neither change anything
10:33:52 <Enigmagic> is it actually doing a build?
10:33:55 <hilhil> yes
10:34:26 <hilhil> Its building and then accepting the  +RTS -p -RTS   option and producing the output I linked to
10:34:53 <hilhil> (The build is really slow, so I'm sure it's happening)
10:35:20 <Enigmagic> hilhil: you might check that the .o files have a new timestamp after adding -auto-all
10:35:40 <Enigmagic> older GHC's weren't as good about forcing rebuilds when compile options change
10:36:20 <hilhil> I'm pretty sure I used 'clean'... but I'm trying it again.
10:37:44 <elliott> hilhil: -fforce-recomp may help
10:39:21 <hilhil> I watched to make sure all of the intermediate files were actually being deleted
10:39:40 <hilhil> And I'm still getting unhelpful profiling results -- 96.8% of time in main, negligible amount of time in anything else.
10:41:08 <hilhil> Would you mind having a look at my cabal file?  http://hpaste.org/69784
10:41:21 <Enigmagic> hilhil: is there any way to get verbose output out of leksah's build? -v2 or -v3 should say if -auto-all is being applied
10:42:00 <Enigmagic> hilhil: if you're adding -prof to ghc-options you also need to add -auto-all (and maybe -caf-all) to ghc-options as well
10:42:55 <Enigmagic> or remove -prof from ghc-options and use the executable-profiling cabal flag (which leksah may ignore?)
10:43:15 <edwardk> preflex: xseen lispy
10:43:15 <preflex>  lispy was last seen on freenode/#haskell 25 days, 18 hours, 5 minutes and 48 seconds ago, saying: Anyone here have real-life connections with ross?
10:43:23 <hilhil> I can't get the verbose output out of leksah, but I can run cabal from the cmd line -- it only crashes at the linking stage
10:44:08 <hilhil> Configuring that way displays
10:44:09 <hilhil> Warning: 'ghc-options: -prof' is not necessary and will lead to problems when
10:44:09 <hilhil> used on a library. Use the configure flag --enable-library-profiling and/or
10:44:09 <hilhil> --enable-executable-profiling.
10:45:05 <roconnor_> ski: I'm unaware of connection problems
10:45:06 <orzo> I want to right a lookup-table based algorithm where I have a set of points in 2d space (Float,Float) and I want to record annotations on the points with O(1) lookup and modification.  My first impulse is Data.HashTable, but there seems to be a lot of options.  Anybody have a recommendation?
10:45:12 <orzo> s/right/write/
10:45:51 <hilhil> I'm just trying -auto-all and -caf-all...
10:46:09 <hiptobecubic> hilhil build the library with '-p'
10:46:31 <hilhil> hiptobecubic: which library? I'm profiling an executable...
10:46:39 <roconnor_> edwardk: how do the strict operators ^!= and ^!%= work?
10:46:54 <edwardk> i don't remember
10:47:35 <hiptobecubic> hilhil, that's what that complaint is. you have to build the libraries with profiling code enabled if you want to profile
10:47:40 <Enigmagic> hilhil: just try it with '-prof -auto-all -caf-all' in the ghc-options. i don't know how leksah drives cabal.
10:47:59 <Enigmagic> hiptobecubic: the libraries are profiling enabled already. he's having issues with an executable
10:48:21 <Enigmagic> and leksah may not pick up the executable-profiling cabal/config flag
10:48:28 <hiptobecubic> ohhh, sorry. carry on
10:49:23 <hilhil> @Enigmagic: that works! Or at least, I get out a bucketload of data. Thank you very much -- I would never have sorted that out on my own.
10:49:23 <lambdabot> Unknown command, try @list
10:50:04 <Enigmagic> hilhil: sweet :)
10:53:24 <elliott> hilhil: (For what it's worth, I always do profiling by specifying it in the ghc-options.)
10:53:35 <elliott> (The automatic stuff is just another thing about Cabal that doesn't seem to work at all.)
10:54:24 <hilhil> thanks -- that's worth knowing.
10:55:03 <elliott> I do it with --ghc-options on the command line, though, since I don't like turning on profiling all the time.
10:55:32 <hilhil> I've read through the documentation chapter on profiling, and I can't find any pointers to tools for analysing the (6000 line) .prof file. Do I just open it up in a text editor/spreadsheet and wade through ?
10:55:47 <irene-knapp1> yes
10:55:51 <irene-knapp1> sorry :)
10:55:58 <hilhil> ouch. thanks anyway!
10:56:05 <irene-knapp1> it's sorted, if that helps
10:56:11 <Enigmagic> the stuff on top is more important
10:57:00 <hilhil> The biggest headache is that the columns aren't quite lined up
10:57:35 <irene-knapp1> yeah, agreed
10:58:05 <Enigmagic> yep... some of that is improved in 7.4.1 with the new profiler
10:59:18 <elliott> hilhil: 6000 lines?
10:59:27 <elliott> You might want to assign your own SCCs and the like, rather than relying on the automatic stuff.
11:00:21 <irene-knapp1> of profiling output, he means
11:00:23 <irene-knapp1> not of input source
11:00:51 <elliott> irene-knapp1: I know.
11:01:08 <elliott> I'm saying that if you have that much profiling output to wade through, maybe it'd be best to assign SCCs to pertinent parts of your program rather than relying on the automatic stuff.
11:01:10 <elliott> So it'll be smaller.
11:01:25 <irene-knapp1> oh, yeah
11:02:39 <hilhil> It's not actually too bad, now I've opened it in a spreadsheet
11:03:01 <hilhil> There is nothing significant after about 500 lines
11:03:35 <phao> Is it correct to say that functional programming is programming by writing procedures that only compute functions? Or programming by only computing functions.
11:04:00 <shapr> What's the definition of a procedure and of a function?
11:04:39 <phao> shapr, function as in math, and procedure is just an algorithm here...
11:05:28 <benmachine> phao: a haskell program is sort of functions that compute procedures
11:05:28 <shapr> In that case, I'd say that Haskell has real mathematical functions.
11:06:03 <phao> benmachine, isn't it the opposite?
11:06:13 <phao> bunch of procedures that compute functions.
11:06:26 <shapr> No, I think it's the other way around.
11:06:58 <benmachine> phao: I think of 'main' as a procedure; there are a few primitive procedures, and primitive ways of gluing together procedures
11:07:12 <elliott> phao: Haskell's functions are pure, mathematical functions.
11:07:21 <benmachine> phao: then there are data types and functions, and between them they compute your 'main' procedure
11:07:25 <elliott> phao: It has types to represent imperative "procedures" that can have side-effects, like input and output.
11:07:37 <elliott> And lets you glue them together using the tools of pure functions.
11:07:59 <phao> Btw... my question wasn't so much about haskell
11:07:59 <elliott> Which is how you write actual programs in it that need to have side effects :)
11:08:05 <phao> but about fp in general
11:08:17 <benmachine> phao: there are several definitions of FP, I think
11:08:21 <bxc_> is this style of output in profiling new?
11:08:22 <bxc_>                 interpret.\.\                  Main                               466     6365619    7.8    8.8    15.1   14.4
11:08:26 <bxc_> with the .\
11:08:30 <elliott> phao: Nobody agrees on what FP means, really.
11:08:38 <phao> benmachine, I thought that too
11:08:42 <Enigmagic> bxc_: yes that is new in 7.4
11:08:44 <benmachine> phao: some people will say that any language that allows manipulating callable code as a value is a functional programming language
11:08:47 <elliott> Some people consider Common Lisp functional. Some people consider Python functional.
11:08:59 <elliott> Some people consider C functional, because it has function pointers! (Well, I think so.)
11:09:06 <elliott> (I think I recall someone saying that once.)
11:09:10 <benmachine> heh
11:09:18 <phao> it has function pointers
11:09:20 <benmachine> conal wrote a post on how C is purely functional
11:09:27 <benmachine> but it was heavy with irony
11:09:32 <elliott> And some people don't consider Haskell functional, because a lot of Haskell code is in an imperative style, because of the embedded languages for handling IO and so on.
11:09:35 <phao> I am reading a ML book that says that if you take fp as meaning that you can pass functions around as return values or arguments
11:09:36 <elliott> (Purely functional, that is.)
11:09:41 <elliott> (Haskell is inarguably functional.)
11:09:47 <phao> then C allows for fp
11:09:51 <zhulikas> I think that's why we have a term multi-paradigm
11:09:58 <elliott> benmachine: right, that post is an example of considering Haskell not purely functional
11:10:14 <benmachine> elliott: yes, I suppose so
11:10:23 <Saizan> function pointers fall very short of having first-class functions
11:10:23 <phao> I guess fp is a misused term, like OOP
11:10:31 <Saizan> because you've to do closures by hand
11:10:33 <benmachine> phao: I don't think C allows for FP inasmuch as it has no way to construct functions at runtime
11:10:37 <elliott> I think "multi-paradigm" can be a misleading term. Haskell doesn't have functional bits and imperative bits and OOP bits glued together, it's just that with its functional design, you can model imperative things, and lots of things look quite like a refined form of OOP. But it's still all "functional" (for some definition of "functional programming").
11:10:42 <benmachine> yeah, what Saizan said
11:11:00 <elliott> benmachine: struct closure { void *(*func)(void *closure, void *param); void *closure; }
11:11:09 <elliott> Close enough :P
11:11:38 <phao> well, yeah.. you could pre-code all the functions you will generate statically
11:11:46 <benmachine> elliott: if you ever use that in an actual program blood will start to leak from your USB ports
11:11:49 <elliott> phao: Not really.
11:11:52 <phao> and keep those "closure" types to keep track of what "bindings"changes
11:11:59 <elliott> Well, yes.
11:12:03 <phao> elliott, it'd work, actually
11:12:09 <elliott> But you do need the closure type, or some variation on it, because you can't pregenerate a billion functions reasonably.
11:12:10 <phao> it'd be just clumsy
11:12:24 <benmachine> it's manifestly possible to write functional programs in C in a sense, because you can implement Haskell in C
11:12:28 <elliott> And if you ignore the fact that C doesn't really allow for infinite data due to arcane restrictions, it could be fully impossible.
11:12:36 <elliott> <benmachine> elliott: if you ever use that in an actual program blood will start to leak from your USB ports
11:12:42 <elliott> benmachine: I've done it. Well, something similar, at least.
11:12:50 <elliott> benmachine: It is actually not as bad as it sounds
11:12:57 <benmachine> but there will still be a difference between the "functions" you construct and bona-fide genuine C functions
11:13:05 <benmachine> elliott: yeah, fair enough, I've seen similar things too
11:13:16 <benmachine> it's entirely possible to write OO C
11:13:19 <benmachine> for example
11:13:20 <benmachine> but
11:13:28 <elliott> For what it's worth, you could remove (->) from Haskell's definition, and define a (->#) that is a function without a closure.
11:13:30 <elliott> Then:
11:13:44 <elliott> data a -> b = forall s. Close (s, (s, a) -># b)
11:13:57 <elliott> And that's just like struct closure.
11:14:58 <elliott> And I don't think that would make Haskell any less functional, even though it wouldn't have proper closure-y functions built in.
11:16:16 <edwardk> elliott: it just make it a pain in the ass to program in =P
11:16:17 <benmachine> elliott: I think it would
11:16:32 <benmachine> but I'm going to go have dinner instead of argue about it :P
11:16:42 <elliott> edwardk: Not if (\x -> y) desugared to the appropriate Close.
11:17:07 <elliott> edwardk: (Admittedly that's a lot more than C gives you.)
11:17:46 <elliott> benozol: I'm not really arguing, just musing :p
11:23:23 <jfischoff> So I am doing a bunch of tree traversals on mutually recursive types, and I am trying to gauge if it is worth the investment of learning multiplate. Anyone taken the plunge themselves? Was it worth it?
11:24:05 <parcs`> multiplate is really accessible
11:24:11 <parcs`> or was that uniplate
11:24:17 <jfischoff> uniplate is easy
11:24:34 <otters> does haskell have memoization?
11:24:57 <jfischoff> multiplate seems harder to grasp, but maybe once you start using it its easy too
11:25:13 <jfischoff> otters: not built in but there are libraries
11:25:28 <otters> okay
11:27:26 <navaati> hum… maybe an important property of FP is having a good (FSVO good…) type system : yeah, C have first class functions and you can make closures with a struct, bit it will be all (void*)
11:28:52 <elliott> navaati: So Scheme isn't FP? (Well, it's more imperative than you might like, but I don't think a type system is required at all.)
11:29:02 <elliott> Or... the untyped lambda calculus isn't FP?
11:29:11 <elliott> (OK, Scheme has a type system. But it's not static.)
11:30:15 <otters> Network.TLS is pissing me off
11:32:10 <otters> it is not possible to predict what recvData will return
11:37:33 <otters> the contents of webpages are randomly garbled
11:37:42 <otters> anybody know of any alternatives to Network.TLS that aren't shit?
11:39:51 <copumpkin> well, http-enumerator uses TLS in a way that's worked for me in the past
11:40:00 <copumpkin> not sure if they've deprecated that in favor of conduit (I hope not)
11:41:43 <kizzo> What is the syntax for exporting a data constructor?  I'm getting "Not in scope: data constructor `Game'"
11:41:59 <bitonic> otters: tls is used in a lot of important packages, as copumpkin mentioned ( http://hackage.factisresearch.com/package/tls-0.9.5/reverse ). I doubt it's broken, and if it is you should tell people :P
11:42:01 <geekosaur> you have to include the type name
11:42:16 <geekosaur> Foo(Game) or Foo(..) to export all of type Foo's data constructors
11:42:19 <kizzo> At the top of the importing file reads "import TheGame.Util (Game)"
11:55:49 <netogallo> Hi, I'm trying to nest IO actions in other monads. Basically I need to know how can I get the IO action to be executed in a expression like this: return (putStrLn "Hi") >>= \x -> return (x >>= \y-> return y)
11:57:41 <parcs`> netogallo: x >>= id
11:58:11 <elliott> (aka join x)
11:58:13 <parcs`> :t return (putStrLn "Hi") >>= id
11:58:14 <lambdabot> IO ()
12:02:00 <netogallo> So you can't do that if the monad isn't an instance of IO Monad, right?
12:02:55 <HairyDude> :t liftIO
12:02:56 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
12:05:30 <mmcdermo>  I'm getting a compile error using an example from the persistent section of the yesod book http://hpaste.org/69785
12:05:39 <mmcdermo> It seems as if something isn't importing correctly; I tried to explicitly import Database.Persistent.Store but the methods still couldn't be found
12:07:03 * hackagebot scrobble 0.1.0.0 - Scrobbling server.  http://hackage.haskell.org/package/scrobble-0.1.0.0 (ChrisDone)
12:07:05 * hackagebot unix 2.5.1.1 - POSIX functionality  http://hackage.haskell.org/package/unix-2.5.1.1 (PaoloCapriotti)
12:07:07 * hackagebot base 4.5.1.0 - Basic libraries  http://hackage.haskell.org/package/base-4.5.1.0 (PaoloCapriotti)
12:07:09 * hackagebot yesod-auth-fb 1.0.3 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.0.3 (FelipeLessa)
12:07:54 <elliott> hm, new maintainer for base?
12:09:29 <copumpkin> elliott: new uploader
12:09:34 <copumpkin> maintainer is still libraries
12:09:39 <elliott> pah, same thing :)
12:09:45 <copumpkin> pcapriotti: !!!
12:09:53 <elliott> what's changed in 4.5.1.0?
12:10:01 <geekosaur> liftIO works if the outer monad is an instance of MonadIO; if it isn't, you can use Control.Monad.Trans.lift (the difference is you have to lift past multiple levels, whereas if every level instances MonadIO then liftIO will lift as much as needed to find the IO)
12:10:11 <copumpkin> elliott: it's now 10 times the burning point of paper
12:10:21 <elliott> copumpkin: Excellent.
12:10:27 <elliott> copumpkin: Sounds like Haskell is ready for the enterprise.
12:10:30 <copumpkin> damn right
12:11:33 <HairyDude> the spaceship or the aircraft carrier?
12:11:45 <copumpkin> both
12:12:26 <elliott> "The" spaceship? There's, like, fifty Enterprises.
12:12:33 <elliott> Anyway I meant the boat, obviously.
12:12:52 <elliott> (There's also like fifty boats called Enterprise.)
12:13:00 <elliott> (Enterprise: kind of an overused name for vessels?)
12:13:07 <HairyDude> only a high profile one
12:13:19 <geekosaur> obviously "enterprise" means it's an EJB
12:13:21 <geekosaur> :p
12:13:22 <elliott> A high-profile what?
12:13:38 <HairyDude> name
12:13:56 <HairyDude> I'm sure there are other names that are much used
12:13:58 <elliott> Ah.
12:14:27 <HairyDude> http://en.wikipedia.org/wiki/HMS_Invincible
12:14:40 <joeyh> I need something like QSemN, but waitQSemN should remove any excess that's present when it's called. Any library provide that?
12:14:43 <elliott> Enterprise has that beat: http://en.wikipedia.org/wiki/HMS_Enterprise
12:14:47 <netogallo> thanks geekosaur for the lift funciton
12:14:49 <elliott> And more: http://en.wikipedia.org/wiki/Enterprise#Vessels
12:15:03 <netogallo> im getting started mixing monads
12:17:05 * hackagebot scrobble 0.1.0.1 - Scrobbling server.  http://hackage.haskell.org/package/scrobble-0.1.0.1 (ChrisDone)
12:30:54 <parcs`> yay ghc 7.4.2
12:31:41 <elliott> yay
12:31:42 <elliott> what's new
12:31:54 <shachaf> The version number.
12:32:36 <parcs`> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/release-7-4-2.html
12:33:25 <elliott> When using -fwarn-unsafe, GHC now reports unsafe language extensions.
12:33:34 <elliott> Being off by default will ensure that only people who don't need it use it...
12:33:40 <elliott> Nice release, though.
12:34:32 <Sqeo> I assume OverlappingInstances is one of the unsafe ones?
12:35:10 <Minoru> > A performance bug causing functions to lose the tail-recursive property after optimization
12:35:11 <lambdabot>   Not in scope: data constructor `A'Not in scope: `performance'Not in scope: ...
12:35:32 <Minoru> it's scary to read a list of bugs fixed; it turns out GHC can screw your code so much!
12:35:59 <shachaf> That's just, like, performance, man.
12:36:21 <c_wraith> Minoru: many of those bugs are reported against HEAD, rather than release versions
12:36:23 <shachaf> It's not as if people in here care, as long as the semantics are the same.
12:36:33 <shachaf> "Haskell programmers know the value of everything and the cost of nothing"
12:36:57 <Minoru> shachaf: hehe. But hey, FP programmers rely on tail recursion so much that bugs with that stuff isn't funny
12:36:59 <shapr> luite: Is this the best channel to ask javascript questions that are somewhat related to Haskell? :-)
12:37:06 * hackagebot cblrepo 0.6.1 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.6.1 (MagnusTherning)
12:37:13 <shachaf> Minoru: Tail recursion is different in Haskell anyway.
12:37:21 <luite> shapr: dunno, maybe -blah
12:37:21 <bitonic> shachaf: the denotative semantics
12:37:25 <shapr> k
12:37:35 <Kaidelong> tail recursion is useful where it can work still
12:37:48 <elliott> Minoru: Haskell does not really rely on tail recursion much.
12:37:52 <elliott> Except when it does.
12:38:06 <luite> shapr: #javascript is usually also relatively helpful, as long as you don't mention jquery ;)
12:38:17 <orzo> I need to vew a HashTable as an array
12:38:23 <shapr> haha
12:38:23 <orzo> an array of pairs
12:39:32 <Kaidelong> what did we rely on instead elliot
12:39:43 <utdemir> Hi. Noob question, again... What is wrong with that statement: (\ n i -> n `mod` (sqrt i)) 3 2 ? It looks like some kind of type error.
12:39:44 <Kaidelong> I cannot for the life of me remember all of a sudden
12:40:16 <orzo> does HashTable.toList use unsafeInterleaveIO ?
12:40:16 <Saizan> ?ty sqrt
12:40:17 <lambdabot> forall a. (Floating a) => a -> a
12:40:30 <geekosaur> :t mod
12:40:31 <lambdabot> forall a. (Integral a) => a -> a -> a
12:40:32 <Kaidelong> I think it had something to do with the compiler figuring out where it didn't have to generate intermediate data structures
12:41:47 <nand`> hpc: I've went ahead and made a gentoo .ebuild for your ghc-man-completion thing that installs it to /usr/share/bash-completion and all :)
12:41:52 <geekosaur> utdemir: ^^ see types above.  there is no type that is both Floating and Integral; you need to convert somewhere along the line
12:42:23 <bitonic> Kaidelong: well, there are two things: lazyness, and the fact that haskell does not rely that much on the stack anyway, iirc
12:42:43 <utdemir> geekosaur, thanks. i just need to learn how to typecast... floor function, maybe?
12:42:45 <elliott> <Kaidelong> what did we rely on instead elliot
12:42:49 <elliott> Non-strictness, usually.
12:43:13 <bitonic> Kaidelong: the lazyness part prevents you from being tail recursive. the fact that functions probably won't use a stack frame renders tco useless in those cases.
12:43:25 <Kaidelong> there was a lovely example of a common thing where haskell does something better if you do not rewrite it to be tail recursive but I can't for the life of me remember what it was
12:44:01 <nand`> shachaf: “Haskell programmers know the value of everything, except when they don't”
12:44:09 <Kaidelong> oh, it might have been sort
12:44:33 <geekosaur> truncate, floor, round, and ceiling exist; study all of them and decide which is most appropriate for what you are doing
12:44:40 <nand`> like “hmm, will this calculation terminate before the heat death of the universe?”
12:45:25 <utdemir> geekosaur, floor is logically correct there, but making it floor.sqrt gives me a lot of errors.
12:47:58 <geekosaur> "floor . sqrt i" won't do what you think, no; that expects "sqrt i" to produce a function.  "(floor . sqrt)" i, or various other ways or writting the same thing; clearest si probably "floor (sqrt i)"
12:48:54 <geekosaur> (function application binds tighter than everything else)
12:49:21 <c_wraith> .. no, it binds tighter than infix operators. It does not bind tighter than *anything* else. :)
12:49:57 <nand`> if I'm not mistaken, record stuff binds more tightly than function application, foo bar { bat = baz} is equal to foo $ bar { bat = baz}   -- correct?
12:50:00 <shachaf> c_wraith: It does bind tighter than *anything* else; but not tighter than *everything* else. :-)
12:50:13 <c_wraith> nand`: that was my point
12:50:23 * elliott thinks that's bad, by the way.
12:51:03 <nand`> I tend to use the latter style just for clarity
12:52:00 <Liskni_si> leaving out the space before { seems to do enough for clarity as far as I'm concerned :-)
12:52:02 <shachaf> c_wraith: There are two different things that bind tighter than application.
12:52:10 <nand`> Liskni_si: I like my spaces though
12:52:18 <shachaf> But they're both record syntax.
12:53:14 <kizzo> I'm still having trouble with Spacer/Network.hs:44:5: Not in scope: data constructor `Game2'
12:53:39 <kizzo> Game2 is defined like "data Game2 = Game2 String deriving (Show)"
12:54:10 <kizzo> And is exported like "module Lover (Game2(..)) where"
12:54:12 <vincenzo> ciao
12:54:16 <vincenzo> list!
12:54:45 <shachaf> kizzo: But is it imported?
12:55:22 <kizzo> Yes, imported like "import Lover (Game2)"
12:55:44 <Minoru> kizzo: you imported dtaa type but not its constructor
12:56:02 <Minoru> import Lover (Game2(..)) would do what you need
12:56:06 <Minoru> s/dtaa/data/
12:56:12 <kizzo> Minoru: You're right, dang.  That worked.
13:02:04 <Siod> how do you do something like `myFunction (_:xs) && isUppercase xs = ...`
13:02:16 <Minoru> Siod: guards
13:02:31 <Siod> Minoru: can you show me the syntaxx -- i can't find it
13:02:32 <Minoru> Siod: myFunction (_:xs) | isUppercase xs =
13:02:36 <Minoru> ;)
13:02:38 <Siod> thanks
13:02:56 <utdemir> Hmm. How can I make this to return [Integer]: takeWhile (flip (<=) (sqrt 169)) [3,5..] ?
13:03:20 <Enigmagic> :t sqrt
13:03:21 <lambdabot> forall a. (Floating a) => a -> a
13:03:22 <HairyDude> strange use of flip
13:03:29 <c_wraith> what would that integer even mean?
13:03:38 <bxc_> i've got lots of memory used by lists, [], : according to profiling - is there a way to get ghc profiling to tell me what type of lists those are?
13:03:39 <HairyDude> just do (<= sqrt 169)
13:03:40 <c_wraith> <= returns a bool, after all
13:04:22 <Enigmagic> > takeWhile (<= floor (sqrt 169)) [3,5..]
13:04:24 <lambdabot>   [3,5,7,9,11,13]
13:04:39 <utdemir> I thought the first parameter of takeWhile is only a function returning bool. How can it change the return type?
13:04:57 <c_wraith> oh
13:05:01 <c_wraith> right.
13:05:01 <Enigmagic> utdemir: sqrt doesn't work on Integers
13:06:29 <HairyDude> (btw, the section syntax (<= wibble) desugars to a use of flip, but it looks nicer :)
13:07:26 <orzo> i'm a little frustrated with the hashtable options
13:07:46 <elliott> HairyDude: it actually desugars to a lambda
13:07:46 <utdemir> Enigmagic, and..? sorry, I'm coming on python background, i'm thinking the comprehensions as [f(i) for i in range iterable if condition ]. The condition doesn't change f(i)'s return type. What is going on in haskell, it casts my numeric list to floating because he sees sqrt there?
13:07:56 <elliott> utdemir: 1 is not an integer
13:07:59 <elliott> 1 can have any numeric type
13:08:04 <orzo> i want something where i can iterate over the key/value pairs while making modifications to them
13:08:04 <elliott> 1 can be an Integer, Double, Float, Rational, whatever
13:08:12 <elliott> if you want an integer specifically, say (1 :: Integer)
13:08:15 <elliott> or perhaps (1 :: Int)
13:08:28 <HairyDude> elliott: well, I expect flip would inline to the same code anyway :)
13:08:29 <elliott> orzo: you probably don't want to use a hash table
13:08:32 <elliott> check out unordered-containers
13:08:36 <elliott> HairyDude: indeed
13:09:20 <HairyDude> I usually reach for Data.Map when I want something hashtable-y
13:09:21 <orzo> elliott: okay, i do want O(1) lookups and updates, from keys to values...
13:09:43 <HairyDude> ... ok, Data.Map doesn't fit that.
13:09:46 <elliott> orzo: You probably don't really need O(1).
13:09:49 <elliott> orzo: In fact, hash tables aren't O(1).
13:09:52 <Minoru> IArray, then, orzo
13:09:56 <elliott> (Because they have to expand eventually, and so on.)
13:10:14 <elliott> orzo: You *can* use a mutable hashtable e.g. from the hashtables package, but it's not very Haskelly at all, and I'm doubtful you actually need O(1).
13:10:26 <elliott> HashMap is the standard hashing associative map container.
13:10:32 <orzo> gawd
13:10:49 <elliott> The alternative is spending all your program in IO or ST, more or less, which isn't particularly pleasant.
13:10:58 <elliott> And you lose the benefits of immutable structures.
13:11:10 <Enigmagic> utdemir: it's not casting, haskell doesn't have implicit casts. by using sqrt you're saying the numbers must be a floating point number.
13:11:25 <HairyDude> hm, can you derive Hashable?
13:11:43 <elliott> orzo: (Note that "Many operations have a average-case complexity of O(log n). The implementation uses a large base (i.e. 16) so in practice these operations are constant time." from the doc)
13:13:01 <orzo> which package are you quoting?  the one you sent me to? unordered-containers?
13:13:48 <elliott> Yeah.
13:18:45 --- mode: ChanServ set +o copumpkin
13:19:01 --- mode: copumpkin set -o copumpkin
13:19:29 <orzo> Minoru: if i use IArray, then I will have the problem that my hash function must either be perfect or I'll have to basically implement a hashtable myself taking care wtih hash conflicts
13:21:00 <Minoru> orzo: oh, sorry, I didn't notice that you need "growable" structure. But array is the only thing with O(1) lookup time, right?
13:21:34 <elliott> orzo: just use the hashtables package if you really really want mutable hashtables
13:21:39 <elliott> but I strongly urge you to try HashMap
13:22:10 * hackagebot hub 1.1.0 - For multiplexing GHC installations and providing  development sandboxes  http://hackage.haskell.org/package/hub-1.1.0 (ChrisDornan)
13:23:54 <orzo> elliott: looking at the documenatoin for Hashmap i see lookup is reported O(log n).  This i understand.  I see "The implementation uses a large base (i.e. 16) so in practice these operations are constant time. " and that I don't understand and I'm not sure it's worht the effort to try
13:24:35 <elliott> orzo: well, hashes are a finite size
13:24:46 <elliott> (of course collisions matter etc.)
13:25:04 <elliott> orzo: hash array mapped tries are very cool stuff, I suggest not assuming they're too slow for your purposes without seeing profiling data
13:25:19 <elliott> http://en.wikipedia.org/wiki/Hash_array_mapped_trie may be helpful if you want to understand the inner details
13:27:00 <Minoru> orzo: the larger the base of logarithm the slower it grows. Was it the thing you didn't understand?
13:32:21 <monochrom> there seems to be some oxymoron in "growable immutable array"
13:32:46 <jfischoff> hey shapr is your still having trouble getting your raspberry pi ghc going, you might want to checkout http://www.haskell.org/pipermail/haskell-cafe/2012-June/101704.html
13:33:35 <HairyDude> I saw that, tried to install llvm and found his patch adding ghc codegen was stale :(
13:33:47 <shapr> jfischoff: I sent it off to Caleb Kraft at Hackaday so it wouldn't distract me from my GSoC project :-)
13:34:05 <jfischoff> shapr: :)
13:34:06 <HairyDude> wish I was still a student so I could do something for GSoC
13:34:29 <jfischoff> HairyDude: maybe you need a specific version of llvm?
13:34:52 <shapr> HairyDude: I'm a forty year old undergrad, it's never too late :-)
13:35:07 <shapr> jfischoff: This is good info, thanks!
13:35:32 <HairyDude> shapr: I already have two degrees, I got sick of academia
13:35:53 <shapr> Ah, I'm still working on my first.
13:38:19 <guest_> I have, foo :: A () -> (), if I do, foo (undefined :: A a), it type checks, but why? foo expects (A ()) not (A a)
13:38:52 <orzo> elliott: I have a cloud of points in 2d space and i'm dividing their bounding box into 40000 grid cells and the mapping of a point (Float,Float) to the number id of its surounding cell is my hash function.  I expect 3 or 4 points to a cell tops.  Is this stratagy appropriate for HashMap?
13:39:52 <elliott> orzo: that sounds reasonable enough, although you will need to define your own point type to give it its own Hashable instance
13:40:10 <elliott> (and if you need the Hashable instance to depend on some external data like the division of cells, you'll need to use something like the reflection package, but maybe you don't)
13:40:42 <Ralith> guest_: I imagine that a unifies with ()
13:42:05 <orzo> my current plan was to use the hash table to map the points to Data.Set which will grow to sizes of probably less than 10 and ultimately all reduce to singltons
13:42:39 <elliott> guest_: undefined :: a means that undefined can take on any type.
13:42:41 <zzing> Is there any module that can take markdown text and convert it to something that blaze can use?
13:42:42 <HairyDude> :t let foo :: A () -> (); foo = undefined in foo (undefined :: A a)
13:42:43 <lambdabot> Not in scope: type constructor or class `A'
13:42:43 <lambdabot> Not in scope: type constructor or class `A'
13:42:58 <HairyDude> :t let foo :: Maybe () -> (); foo = undefined in foo (undefined :: Maybe a)
13:42:59 <elliott> orzo: Just treat the HashMap like it's a hash table is my advice.
13:42:59 <lambdabot> ()
13:43:04 <elliott> If that doesn't work, then I dunno :)
13:43:07 <HairyDude> :t let foo :: Maybe () -> (); foo = undefined in foo (undefined :: forall a. Maybe a)
13:43:08 <lambdabot> ()
13:44:51 <guest_> k, its clear thanks.
13:51:21 * Baughn learns the difference between "let a = x :: y" and "let a :: y; a = x"
13:51:33 <Baughn> That was an annoying waste of half an hour.
13:52:04 <Baughn> ..more to the point, shouldn't using NoMonomorphismRestriction mean I don't /get/ this? Never mind that a is a function?
13:52:09 <EEVIAC>  whats the difference
13:52:20 <zzing> monomorphism…
13:52:22 <zzing> RUN
13:52:32 <HairyDude> Baughn: didn't Haskell 2010 nuke that once and for all?
13:52:39 <Saizan> Baughn: depends on y
13:52:40 <Baughn> With the former version, GHC feels free to narrow the type of a down from what I just said x is
13:53:03 <Baughn> Saizan: y is 'ReaderT Anidb IO a -> IO a'
13:53:16 <Baughn> x, then, is flip runReaderT Connection{..}
13:53:29 <Baughn> ..and s/Anidb/Connection/
13:53:46 <Saizan> and what do you get with the former?
13:54:05 <elliott> HairyDude: No.
13:54:12 <luca__> wondering, what is the best way of decorating an AST with types in haskell?
13:54:28 <luca__> aka, not modifying AST declarations so that everything carries a Maybe Type field
13:54:35 <HairyDude> I am surprised, I thought it was one thing everyone agreed on that should go away
13:54:50 <Baughn> Saizan: "Couldn't match type 'a' with '()'", but only if I attempt to use a (run, properly) with both an Anidb a and an Anidb ()
13:54:55 <Baughn> Saizan: So yeah, the usual story.
13:55:06 <Baughn> Obviously I'm surprised it happened in this case.
13:56:05 <orzo> elliott: I sort of need to access the hash table/map as an array (implementation-defined ordering) so that I can get-the-next-not-eliminated item when i run out of items in another process that is marking them eliminated as it goes
13:56:35 <elliott> orzo: If you want to iterate through it in internal order, you can use toList.
13:56:54 <HairyDude> oh, hrm. you DO need mingw to install network
13:56:56 * HairyDude grumbles
13:57:23 <Baughn> Saizan: And as usualy, my list of language extensions has reached four lines for this one module. >_>
13:57:37 <orzo> elliott: if i use toList, then when i make a modification to the table, marking something eliminated, my list will still refer to the old version of the table, wont it?
13:57:59 <orzo> using hashmap
13:58:17 <elliott> orzo: well, yes, since values are immutable... I guess you would need access to the constructors to do that
13:58:22 <Saizan> Baughn: oh, are you using GADTs? that turns on MonoLocalBinds
13:58:23 <elliott> orzo: it seems like a strange design, though.
13:58:23 <orzo> using HashTable, it will simply be a strict toList which will give me the elmeents as they were when i made the call right?
13:58:38 <elliott> There is more than one HashTable.
13:58:45 <elliott> Which one do you mean?
13:58:46 <HairyDude> does ghc still have -fglasgow-exts ?
13:58:48 <elliott> The one in base, or the one in hashtables?
13:58:50 <orzo> Data.HashTable
13:58:52 <elliott> HairyDude: strongly deprecated
13:59:00 <elliott> orzo: don't use that one
13:59:02 <HairyDude> makes sense :)
13:59:05 <orzo> none of the hashtables will give me an interleave-io version of toList will they?
13:59:07 <elliott> hashtables is better, in API and implementation
13:59:32 <elliott> orzo: well frankly if you really want to do what you want to do you are probably going to have to roll your own on top of a mutable array
13:59:44 <elliott> but I'd suggest rethinking your design so it doesn't depend on implementation details of the hashed container
14:02:24 <mvj4_> has anyone been able to use GHC 7.4 with qemu? (apt-get install..) complains about unsupported instruction (syscall 257).
14:02:26 <orzo> my design is simple, i'm kind of surprised its so much trouble
14:03:06 <mvj4_> (I'm running debian sid ARM)
14:04:11 <HairyDude> quite a few people trying to use ghc on arm today...
14:04:16 <orzo> i've been thinking enough about design that i wan to quit and move on.  everything else i've come up with is more complicated to describe and worse on time, or hard to say on time
14:04:17 <elliott> orzo: well, I don't think you could achieve it with, e.g. Python's dictionaries, either, it's not that common to expose such implementation details in a flexible manner
14:04:45 <elliott> you can do the whole mutable array thing if you want, but frankly I don't think you'll get much of Haskell's benefits from it
14:06:03 <orzo> afk
14:06:11 <orzo> thanks, elliott
14:06:31 <elliott> no problem, sorry my advice amounts mainly to "don't do that" :)
14:09:30 <HairyDude> where the hell is the mingw root directory located?
14:09:53 <tgeeky> under GHC somewhere
14:10:00 <tgeeky> program files \ Haskell Platform \ ...
14:10:11 <HairyDude> I installed it separately
14:10:32 <tgeeky> oh, C:\mingw maybe?
14:10:34 <tgeeky> by default?
14:11:29 <HairyDude> there's no home subdirectory there
14:11:43 <Siod> is there a way of doing this -> http://ideone.com/Ow1EH <- without having translateArg return a wrapped up type. ie. i'd like it to just return a char,bool,int, ect rathr than ATChar ect
14:12:05 <HairyDude> there seems to be some magic involved with its paths though, cos /c refers to c: even though there's no directory entry called that in /
14:12:18 <strager> Siod: How would the caller match against the appropriate type?
14:12:27 <tgeeky> HairyDude: yep, that's cygwin-style magic but that's not what's at issue here
14:12:40 <Siod> strager: the caller tells it what type it should be with ArgDef
14:12:56 <tgeeky> HairyDude: check the scripts/launchers/whatever to see where your homedir is coming from. It may be putting you somewhere in share or something.
14:13:25 <tgeeky> It's been a while since I installed mingw/msys from scratch
14:13:43 <strager> Siod: You may want GADT's then, if you want the type safety.
14:13:46 <HairyDude> ohhh, it's under the msys hierarchy
14:14:15 <strager> e.g. String -> ArgDef a -> a
14:14:26 <Siod> strager: alright, i'll look into that. thanks
14:14:49 <HairyDude> thanks
14:15:07 <HairyDude> should have thought to look at the shortcut that launches the shell -_-
14:15:10 <tgeeky> HairyDude: yep. I install mine to C:\msg, with C:\msg\home\tg being my homedir
14:15:26 <tgeeky> HairyDude: and I also strip out all of the stuff in PATH that windows sticks in
14:16:32 * HairyDude shrugs
14:16:34 <HairyDude> they don't bother me
14:16:44 <tgeeky> HairyDude: https://github.com/technogeeky/.files-msysgit/blob/master/etc/bash_profile
14:17:04 <HairyDude> yeah, I copied some dotfiles from my cygwin homedir
14:17:13 <HairyDude> (which I stopped using cos it seemed to break stuff)
14:19:35 <HairyDude> and finally network installs! \o/
14:20:29 <strager> tgeeky: You have two aliases named 'gc'; a bit odd =]?
14:20:55 <tgeeky> strager: how about that.
14:21:00 <tgeeky> shows you that I never use those shortcuts :o
14:21:16 <strager> =D
14:21:26 <strager> I have similar shortcuts set up in Vim
14:21:41 <strager> https://github.com/strager/dotfiles/blob/master/vim/vimrc#L169
14:28:40 <HairyDude> weird. javascript requires happy, but instead of installing it, it just fails.
14:28:54 <elliott> HairyDude: Because it's not a dependency of the code, but a required build tool.
14:29:00 <HairyDude> ah
14:29:07 <elliott> Imagine if happy was written in C++ rather than Haskell; it'd still work for the purpose.
14:29:25 <elliott> (Apparently there's work into installing some build tools automatically when they're written in Haskell, but who knows if that will ever see the light of day.)
14:29:32 <elliott> HairyDude: "cabal install happy" should work, anyway.
14:29:39 <HairyDude> it doesn't :(
14:29:55 <Minoru> it should! What does it complain about?
14:30:23 <Minoru> (I have the same troubles with happy all the time; thanks for the explanation of that, elliott)
14:30:31 <HairyDude> cabal.exe: The program happy version >=1.18.5 is required but it could not be found.
14:30:59 <Minoru> did you `cabal update`?
14:31:17 <elliott> HairyDude: So did "cabal install happy" succeed?
14:31:25 <elliott> If so, the problem is that cabal is installing executables in a place that isn't on your %PATH%.
14:31:30 <elliott> So cabal can't find happy.
14:31:31 <elliott> So... you gotta fix that.
14:31:32 <HairyDude> ah
14:31:41 <elliott> Eitehr that, or "cabal install happy" actually failed.
14:31:59 <HairyDude> ah, the cabal binaries directory isn't in $PATH
14:32:55 <HairyDude> there we go, that fixed it
14:34:42 <elliott> \o/
14:46:49 <HairyDude> and I have Yesod "Hello World" running :D
14:47:03 <statusfa1led> What's programming Haskell on Windows like?
14:47:08 <statusfa1led> in terms of what works
14:48:26 <stepcut> statusfa1led: the main GHC developers use Windows. But most libraries on hackage are developed by linux people. Though, unless the packages depend on the 'unix' package, they tend to be pretty portable
14:48:58 <statusfa1led> stepcut: Cool, that's good to hear :)
14:49:02 <c_wraith> do they?  I'm sure simon marlow uses linux
14:49:05 <statusfa1led> I didn't realise the GHC devs used windows
14:49:07 <elliott> statusfa1led: Less pleasant than programming Haskell on Linux. But probably not too bad.
14:49:20 <elliott> I think spj uses Windows, but I don't know about Marlow.
14:49:31 <HairyDude> aren't they both MS employees?
14:49:35 <c_wraith> Hmm.  Maybe SPJ does.  that'd make some sense.
14:49:42 <elliott> I would be kind of surprised if they both used Windows, because that would be pretty unbearable for me, with a really large project like GHC.
14:49:43 <stepcut> I know SPJ uses Windows and Comic Sans, not sure about Marlow either
14:49:45 <statusfailed> SPJ is microsoft research
14:49:45 <c_wraith> They're MS Research employees.  Not quite the same thing
14:49:46 <elliott> HairyDude: MS Research.
14:49:49 <statusfailed> hahaha comic sans
14:49:59 <elliott> I don't think MS Research really cares if you use Linux.
14:50:18 <HairyDude> SPJ definitely uses comic sans in powerpoint presentations :)
14:50:20 <elliott> I know someone who worked at MS Research and hates Windows. He just used Cygwin for everything.
14:50:29 <statusfailed> HairyDude: oh, I thought that was a joke, hahah
14:50:29 <Cale> MSR : MS :: Xerox PARC : Xerox
14:50:39 <Yarou> haha
14:50:48 <nobdraisentone> elliott: how do you know that?
14:50:53 <HairyDude> maybe not all powerpoint presentations, but at least "Wearing the Hair Shirt"
14:51:04 <elliott> nobdraisentone: He... told me?
14:51:24 <shirt> eh?
14:51:27 <nobdraisentone> elliott: how is it ever possible?
14:51:38 <elliott> nobdraisentone: Wait, what?
14:51:56 <Cale> "This is the annex of the company where we pay researchers to invent the future and then foolishly ignore most of their work."
14:52:03 <stepcut> I have never seen SPJ use anything besides comic sans outside of LaTeX
14:52:07 <elliott> nobdraisentone: I'm really confused.
14:52:16 <edwardk> cale: isn't that every company?
14:52:23 * hackagebot xtc 1.0.1 - eXtended & Typed Controls for wxHaskell.  http://hackage.haskell.org/package/xtc-1.0.1 (AlanZimmerman)
14:52:27 <edwardk> at least every company with an r&d department
14:52:38 <HairyDude> somehow SPJ manages to be likeable enough that you can forgive his bad taste in typography
14:52:59 <sipa> there's nothing wrong with comic sans
14:53:04 * elliott would like SPJ's slides less if they weren't so gaudy.
14:53:09 <Ralith> haha
14:53:10 <sipa> unless you want to be taken.serioisly :p
14:53:17 <statusfailed> aaaaaaand there's the punchline
14:53:17 <sipa> seriously
14:53:18 <shachaf> What's wrong with Comic Sans?
14:53:28 <Siod> i don't understand why i'm getting the following error with GADTs: http://ideone.com/awZ9C
14:53:36 <HairyDude> mostly, it's overused, epecially where it's totally inappropriate
14:53:55 <c_wraith> like on funeral announcements?
14:53:56 <Cale> When you're SPJ, you can use Comic Sans and still be taken seriously.
14:54:01 <statusfailed> Siod: I think you're about to be told to use hpaste~
14:54:07 <HairyDude> what Cale said
14:54:29 <Siod> statusfailed: why not just ask?
14:54:36 <elliott> mauke: Aww, does your script not do ideone?
14:54:44 <elliott> ideone isn't that bad, anyway.
14:54:49 <shachaf> Cale: If I used Comic Sans, would you not take me seriously?
14:54:53 <elliott> At least it isn't borderline-unusable like pastebin.com's interface.
14:55:06 <Cale> Siod: your datatype is using GADT syntax, but isn't actually a GADT
14:55:07 <c_wraith> Siod: I'm not sure why that's a GADT.  You're not using any GADT features.
14:55:08 <elliott> Siod: Because
14:55:09 <elliott>   ArgBool     :: Bool -> ArgDef a
14:55:09 <hpaste_> Siod pasted “GADTs” at http://hpaste.org/69788
14:55:13 <elliott> That means that
14:55:16 <elliott> ArgBool True :: ArgDef a
14:55:17 <elliott> And thus
14:55:23 <elliott> translateArg "foo" (ArgBool True) must :: a
14:55:25 <elliott> Perhaps you mean:
14:55:27 <elliott>   ArgBool     :: Bool -> ArgDef Bool
14:56:00 <edwardk> shachaf: basically it is a silly font designed for use in comic book caption bubbles for microsoft bob, that wound up being abused in places where it seriously affects legibility. It winds up on the signs for bus routes, on warning signs, etc. anywhere someone is trying to lighten up the message inappropriately
14:56:37 <Siod> elliott: yeah, ArgDef Bool is what i needed
14:56:50 * Cale imagines a pink stop sign with "Stop?" rendered in Comic Sans MS
14:56:55 <Siod> i don't know why though
14:57:07 <elliott> Cale: "Stop !! :)"
14:57:40 <elliott> Siod: Well, the whole point is that you want ArgBool True to be of type ArgDef Bool, right?
14:57:48 <elliott> Because you use that information to determine the result type of translateArg.
14:57:56 <elliott> So if it wants to return a Bool, it has to be given an ArgDef Bool.
14:58:05 <elliott> So you have to define ArgBool as returning an ArgDef Bool, not an ArgDef a.
14:58:09 <HairyDude> I think Microsoft Bob was BillG's wife's idea wasn't it? so we can blame her for Comic Sans ;)
14:58:59 <Cale> That reminds me... http://www.kibo.com/photos/bad_sign_lettering_2/stop.jpg
14:59:23 <Siod> oh, i see. i confused this example i was looking at on gadts
14:59:57 <Ralith> Is there a name for a kind of graph having N collections of vertices such that vertices within any particular collection are only incident to edges going to either 1 or 2 other collections?
15:00:15 <Ralith> (a bijection is a trivial example of this)
15:01:07 <etpace_> a bipartite graph perhaps?
15:01:49 <statusfailed> etpace_: isn't that what was meant by "bijection"?
15:01:57 <HairyDude> bipartite is N=2
15:02:21 <Ralith> yes
15:02:38 <statusfailed> Ralith: out of interest, what kind of data is that?
15:02:46 <HairyDude> (I was trying to remember that word and failed until etpace_ mentioned it)
15:02:47 <kkyqqp> I seem to recall something about a parallel focused haskell book that just came out or was coming out, was that a different language or does anybody recall any details about it?
15:03:00 <statusfailed> Ralith: It's not collaborative filtering by any chance?
15:03:04 <Cale> A homomorphism G -> P_N where P_N is a simple path of N vertices.
15:03:26 <Ralith> statusfailed: I'm trying to grok arrows, and the metaphor that's currently winning in my head is that monads:sequences::arrows:thatkindofgraph
15:03:37 <statusfailed> oh :)
15:03:42 <elliott> kkyqqp: There is such a book. I forget anything more than that, though.
15:04:31 <HairyDude> arrows are just categories with binary products and some other things
15:04:53 <HairyDude> I forget the details
15:05:09 <Ralith> HairyDude: and monads are just monoids in the category of endofunctors :P
15:05:16 <HairyDude> Ralith: precisely :P
15:05:27 <statusfailed> Awww, out-typed
15:05:30 <Ralith> ^^
15:06:13 <Cale> Arrows *ought* to be vaguely symmetric monoidal categories, but they aren't actually defined that way, and are missing some axioms.
15:06:35 <Ralith> the point being, if I could deeply grok the significance of that definition, I'd already understand them.
15:06:42 <Cale> which is what lets them generalise monads, but it's actually not very helpful
15:07:08 <HairyDude> Cale: which axioms are missing?
15:07:14 <shapr> Howdy Cale! How's life?
15:07:26 <Ralith> all I know is that the examples of arrows I've seen in FRP are very compelling
15:07:27 <Cale> (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
15:07:31 <Cale> shapr: Pretty good :)
15:08:06 <HairyDude> that doesn't hold for arrows? really?
15:08:12 <HairyDude> it certainly should
15:08:32 <Cale> In particular, it doesn't hold for the Kleisli arrow for a non-commutative monad.
15:08:39 <HairyDude> ah.
15:09:05 <Cale> and when it doesn't hold, it *ruins* the ability to draw those pretty diagrams you always see
15:09:40 <Cale> You have to specify exactly how the diagram is composed from the combinators, because it affects the order in which effects occur in a way which potentially matters if that law doesn't hold./
15:09:49 <Cale> dinnertime, bbbiab
15:10:45 <HairyDude> > ((putStrLn . (++" 1) *** putStrLn (++" 2")) >>> (putStrLn (++" 3") *** putStrLn (++" 4"))) "wibble"
15:10:46 <lambdabot>   <no location info>:
15:10:46 <lambdabot>      lexical error in string/character literal at end o...
15:10:57 <HairyDude> oops...
15:12:17 <HairyDude> > ((putStrLn . (++" 1) *** putStrLn . (++" 2")) >>> (putStrLn . (++" 3") *** putStrLn . (++" 4"))) "wibble"
15:12:19 <lambdabot>   <no location info>:
15:12:19 <lambdabot>      lexical error in string/character literal at end o...
15:12:20 <Siod> is it possible to have a list of gadts. eg: [B 5, I 2] where `data Expr a where ; I :: Int -> Expr Int ; B :: Bool -> Expr Bool`
15:13:13 <HairyDude> > ((putStrLn . (++" 1") *** putStrLn . (++" 2")) >>> (putStrLn . (++" 3") *** putStrLn . (++" 4"))) "wibble"
15:13:14 <lambdabot>   Couldn't match expected type `GHC.Types.IO ()'
15:13:14 <lambdabot>         against inferred typ...
15:13:29 * HairyDude tries in a proper ghci
15:13:34 <ClaudiusMaximus> > let f x = Kleisli . tell . (x:": " ++) in runWriter . runKleisli $ ((f 'a' *** f 'b') >>> (f 'c' *** f 'd')) ("left", "right")   -- probably something wrong here too
15:13:35 <lambdabot>   The operator `L.++' [infixr 5] of a section
15:13:35 <lambdabot>      must have lower precedence...
15:13:53 <ClaudiusMaximus> > let f x = Kleisli . tell . ([x]++": " ++) in runWriter . runKleisli $ ((f 'a' *** f 'b') >>> (f 'c' *** f 'd')) ("left", "right")   -- probably something wrong here too
15:13:54 <lambdabot>   The operator `L.++' [infixr 5] of a section
15:13:54 <lambdabot>      must have lower precedence...
15:13:57 <HairyDude> oh, idiot, I forgot the Kleisli constructor
15:14:01 <statusfailed> Siod: yes if I understood correctly
15:14:10 <Ralith> so nobody knows is that kind of graph has a name?
15:14:16 <Ralith> also, if it's a good metaphor?
15:14:24 <statusfailed> Ralith: not I, try #math?
15:14:24 <nand`> https://en.wikipedia.org/wiki/List_of_lists_of_lists <- contains itself. Wikipedia is subject to the Russel's paradox
15:14:49 <Ralith> fair enough
15:14:49 <hpaste_> Siod pasted “GADTs list” at http://hpaste.org/69789
15:15:08 <Siod> statusfailed: how? that pasted code doesn't work: Couldn't match expected type `Bool' with actual type `Int'
15:15:25 <statusfailed> Siod: Expr Bool is a different type to Expr Int
15:15:32 <statusfailed> I think :D
15:15:45 <Siod> yeah, but is it possible to create such a list?
15:16:04 <elliott> nand`: That is not what Russell's paradox is.
15:17:22 <shachaf> This IRC channel is now being viewed in Glorious Comic Sans MS.
15:17:32 <statusfailed> shachaf: you're a terrible person
15:17:37 <Siod> i want to send argument definitions to another function -- parseArgs <words to parse> <list of gadts defining how those words should look>
15:17:38 <statusfailed> Siod: I'm not sure, but I think not?
15:17:38 <hiptobecubic> shachaf, go papyrus
15:18:02 <nand`> elliott: not quite but it means a list of lists can contain itself, so it's equally possible to craft a list of lists that don't contain themselves, no?
15:18:18 <Siod> eg. ArgInt 5 0 10 <- that word should be between 0 and 10, and if that word doesn't exist it defaults to 5
15:18:19 <elliott> Not necessarily.
15:18:43 <elliott> For a start, Wikipedia has consistency-checking mechanisms called "administrators" that would defeat such a list before it could corrupt the fabric of Wikipedia itself.
15:18:46 <elliott> :p
15:19:15 <statusfailed> elliott: Such corruption would cause a total factual collapse, and result in an edit-war singularity!
15:19:45 <nand`> elliott: you mean the restriction is not whether or not lists can contain themselves, but whether or not the property of “not containing itself” is a valid content page?
15:20:05 <elliott> nand`: You can make a set theory which allows one but not the other quite trivially, really.
15:20:17 <statusfailed> Siod: oh, it looks like you can do that with "Existential types"
15:20:27 <statusfailed> Siod: i'm guessing you're reading the Wikibooks/Haskell/GADT page?
15:20:31 <ClaudiusMaximus> > let f x = Kleisli (\i -> tell ([x]++": "++ i ++ "; ") >> return i) in execWriter $ runKleisli ((f 'a' *** f 'b') >>> (f 'c' *** f 'd')) ("L", "R")
15:20:34 <lambdabot>   "a: L; b: R; c: L; d: R; "
15:20:45 <Siod> statusfailed: im on the haskell wiki; someone recommended i use gadts earlier
15:21:08 <ClaudiusMaximus> > let f x = Kleisli (\i -> tell ([x]++": "++ i ++ "; ") >> return i) in execWriter $ runKleisli ((f 'a' >>> f 'c') *** (f 'b' >>> f 'd')) ("L", "R")
15:21:11 <lambdabot>   "a: L; c: L; b: R; d: R; "
15:21:22 <coppro> why is there no facility for module-local instances?
15:22:03 <elliott> coppro: would break open world assumption
15:22:10 <coppro> elliott: stupid open world assumption
15:22:15 <statusfailed> Siod: i'm reading this page: http://en.wikibooks.org/wiki/Haskell/GADT
15:22:19 <elliott> coppro: it's very important
15:22:24 <coppro> I want IsString Data.ByteString but I have to assume there's a good reason it doesn't already exist
15:22:44 <elliott> it's in Data.ByteString.Char8 if you really want it. the reason it doesn't exist is because it is wrong, and evil.
15:23:07 <elliott> ByteStrings are not strings, so using string literals for them is misleading
15:23:13 <elliott> better to use Text, if you're dealing with Unicode
15:23:23 <elliott> .Char8 is sometimes OK if you're dealing with a protocol that uses a lot of ASCII punning for legibility
15:23:28 <shirt> what's a big haskell package that doesn't have any nonstandard dependencies?
15:23:29 <elliott> but usually people misuse it
15:23:46 <shachaf> You can also get a quasiquoter to do it!
15:23:52 <HairyDude> the "Char = Char8" meme is really annoying
15:23:57 <shachaf> [b|blah blah blah|]
15:24:13 <elliott> HairyDude: Eh?
15:24:23 <coppro> I'm not acting on text; I just want to use a string literal since it looks slightly better
15:24:33 <HairyDude> I mean assuming that 8 bits are all you need for a character of text
15:24:36 <elliott> Right.
15:24:47 <elliott> coppro: Well, import it. But what's the specific use-case?
15:27:03 <coppro> elliott: trying to preprocess data that is for my purposes byte data but includes "\r\n" as a delimeter.
15:27:20 <elliott> coppro: OK. I'd just use B.pack [10, 13], personally.
15:27:27 <elliott> Or even cr = 10; lf = 13
15:27:32 <elliott> (Then B.pack [cr, lf].)
15:27:33 <elliott> Or is it 13, 10?
15:27:40 <coppro> 13, 10 ;)
15:27:49 <elliott> coppro: Just import Data.ByteString.Char8 () if you really want it.
15:27:50 <coppro> I rest my case :P
15:27:52 <elliott> () because you only want the instances.
15:28:06 <elliott> (But I'll still be a bit sad.)
15:28:21 <coppro> ok
15:28:27 <elliott> What we really need is a module with definitions for various pertinent ASCII Word8s.
15:28:30 <coppro> elliott :: SadPanda
15:28:33 <elliott> So you can say ASCII.cr :: Word8 or whatever.
15:29:19 <shachaf> Don't do it!
15:29:23 <luca__> :t concatM
15:29:24 <lambdabot> Not in scope: `concatM'
15:29:28 <luca__> :t liftM concat
15:29:29 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
15:29:34 <elliott> shachaf: Don't do what?
15:29:38 <shachaf> The import.
15:29:44 <shachaf> Is a few more characters so much trouble to type?
15:29:57 <elliott> coppro: I think shachaf has polymorphed into a sad panda, too.
15:30:43 <shachaf> coppro: Is «foo "ASCII literal"» too much typing?
15:30:57 <luca__> :t maybeToList
15:30:58 <lambdabot> forall a. Maybe a -> [a]
15:31:00 <elliott> shachaf: What would foo be?
15:31:01 <elliott> B8.pack?
15:31:17 <luca__> @pl \xs ys -> (maybeToList xs) ++ (maybeToList ys)
15:31:18 <lambdabot> (. maybeToList) . (++) . maybeToList
15:31:46 <Siod> how do i modify http://hpaste.org/69789 so that i can use a heterogeneous list
15:32:07 <elliott> You probably need to use an existential type there.
15:32:10 <Siod> http://en.wikibooks.org/wiki/Haskell/GADT#Existential_types isn't so clear
15:32:14 <elliott> data SomeExpr = forall a. SomeExpr (Expr a)
15:32:18 <elliott> Or, in GADT notation:
15:32:24 <elliott> data SomeExpr where SomeExpr :: Expr a -> SomeExpr
15:32:25 <shachaf> elliott: Sure.
15:32:32 <elliott> You have to wrap all the list elements in SomeExpr, though.
15:32:38 <bitonic> ahhh new GHC.
15:32:42 <shachaf> Alternatively: [b|ASCII literal|]
15:32:52 <elliott> coppro: (FWIW, I agree that B8.pack "\r\n" is better than "\r\n", even if you have the instance available.)
15:32:56 <statusfailed> Siod: this page _might_ help, I'm still trying to understand it as well :P http://www.haskell.org/haskellwiki/Heterogenous_collections
15:33:56 <teneen> notFollowedBy in Parsec succeeds if the argument parser succeeds with an empty output, is this correct?
15:36:54 <byorgey> teneen: what does the documentation say?
15:36:55 <bitonic> teneen: what do you mean "empty output"? Right ()?
15:37:10 <coppro> is there an efficient function to get (init l, last l)?
15:37:31 <bitonic> coppro: the most efficient function is (init l, last l)
15:37:38 <bitonic> actually wait
15:37:41 <byorgey> http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Combinator.html#v:notFollowedBy    -- teneen
15:37:44 <bitonic> what's init again? all but last?
15:37:47 <coppro> yes
15:37:51 <teneen> bitonic: for example succeeds with an empty string
15:38:13 <Siod> elliott: shouldn't the return type be a list?rather than just SomeExpr?
15:38:22 <bitonic> coppro: ah. then no. you can drop them all and leave the last at the end
15:38:30 <Siod> (for gadt style)
15:38:30 <pacci> !list
15:38:38 <elliott> Siod: No. You wrap each list element.
15:38:39 <elliott> Not the whole list.
15:38:43 <geekosaur> teneen, no, failure is not success with empty output.
15:38:45 <elliott> Then the list has type :: [SomeExpr].
15:39:16 <elliott> coppro: (init l, last l) is not necessarily inefficient.
15:39:22 <elliott> Well, I guess it is.
15:39:24 <elliott> But it's not so bad.
15:39:28 <bitonic> coppro: but that's not better than (init l, last l), in terms of complexity
15:39:30 <elliott> The trouble with fusing the two is that you need to maintain laziness.
15:39:38 <bitonic> coppro: I wouldn't worry about it
15:40:12 <Siod> elliott: you're saying `data SomeExpr where SomeExpr :: Expr a -> SomeExpr` while the wiki is saying `MkTG2 :: Show b => [b] -> TG2`
15:40:22 <elliott> Siod: The wiki says that?
15:40:26 <Siod> yeah
15:40:26 <elliott> Well, the wiki is wrong.
15:40:30 <elliott> Or at least wrong for your current usage.
15:40:37 <elliott> coppro: But initLast' [x] = ([], x); initLast' (x:xs) = let ~(xs', y) = initLast' xs in (x:xs', y) should work.
15:40:39 <elliott> But I'd just use init and last.
15:40:50 <teneen> parseTest (char 'f' *> notFollowedBy (many $ char 'a') *> many anyChar) "fkes" ... succeeds! why? geekosaur
15:40:51 <Siod> can you modify the example -- i'm really confused and there isn't much information on this
15:41:29 <elliott> Siod: print $ [SomeExpr (B 3), SomeExpr (I 3)]
15:41:45 <elliott> (Note that you'll need a Show instance for SomeExpr. If you use the StandaloneDeriving extension, you can just write:)
15:41:51 <elliott> (deriving instance Show SomeExpr)
15:41:55 <geekosaur> teneen, why wouldn't it?
15:41:57 <elliott> (assuming you have a Show instance for Expr (which you can derive in the same way).)
15:42:41 <geekosaur> "many $ char a" does not succeed, therefore "notFollowedBy" succeeds (and consumes nothing), then "many anyChar" succeeds
15:42:43 <Siod> elliott: `data Expr a where ; SomeExpr :: Expr a -> SomeExpr` is right?
15:42:44 <pacci> !list
15:42:44 <teneen> geekosaur: because (many $ char 'a') succeeds on input "kes" and returns ""
15:42:51 <elliott> Siod: No.
15:42:53 <elliott> SomeExpr is another type.
15:42:57 <elliott> You define it separately to Expr.
15:43:04 <teneen> geekosaur: and notFollowedBy should only succeed if it's argument fails
15:43:08 <elliott> It contains an (Expr a) (for some a that you don't know about when taking it out, basically.)
15:43:11 <geekosaur> hm, I'm confusing many with a different combinaror
15:43:19 <HairyDude> when you run cabal fetch in windows, where does it put the packages?
15:43:44 <elliott> HairyDude: Wherever the config file is, I think.
15:43:48 <fmap> efficient as in "faster than O(n)"?
15:43:50 <elliott> ~/.cabal/config on Linux, but...
15:43:56 <fmap> misschan
15:44:03 <teneen> byorgey: did you follow my example?
15:44:06 <elliott> pacci: This is a channel about the Haskell programming language.
15:47:03 <HairyDude> seems it installs packages in %APPDATA%\cabal, but I don't see the "cabal fetch"'d packages there
15:47:12 <pacci> ciao
15:47:24 <pacci> :list
15:48:22 <HairyDude> ah, found it
15:48:30 <HairyDude> it's in %APPDATA%\cabal\packages... easy to overlook
15:50:12 <geekosaur> teneen, I *think* that in practice you are correct but it's not guaranteed; that is, the behavior of notFollowedBy when the parser can match nothing is not defined
15:52:32 <teneen> geekosaur: is it meant to be this way, or is it a bug or something?
15:52:46 <geekosaur> undefined behavior is undefined
15:53:10 <geekosaur> I'm checking something else, I am not as familiar with Applicative as I probably should be...
15:54:15 <geekosaur> teneen, looks like you have the bug.  (*>) discards the result of the thing on the left, *including its failure*
15:54:41 <geekosaur> I think
15:54:54 <geekosaur> I may still be confused
15:55:25 <hpaste_> a annotated “GADTs list” with “GADTs list (annotation)” at http://hpaste.org/69789#a69791
15:55:32 <teneen> parseTest (char 'f' *> notFollowedBy (many $ char 'a')) "fa" ... see the error message which comes, geekosaur
15:55:37 <geekosaur> no, I'm wrong
15:55:47 <Minoru> where can I find (brief) description of how does GHCi work (or runhaskell, to that matter)? Is there a paper on that or something?
15:55:53 <geekosaur> teneen, suggest you ask someone who's more familiar with Applicative then
15:56:29 <teneen> geekosaur, okay thanks for your help :)
15:57:58 <HairyDude> there, cabal-dev successfully patched, compiled and installedsrc\Distribution\Dev\CabalInstall.hs:1:1:
15:57:58 <HairyDude>     Exception when trying to run compile-time code:
15:57:58 <HairyDude>       user error
15:57:58 <HairyDude>       Code: deriveCabalCommands
15:58:20 <HairyDude> ignore the part where I said cabal-dev successfulls installed o\
15:59:25 <teneen> geekosaur: without applicative the same problem exists ... parseTest (notFollowedBy eof) "" ... obviously eof succeeds on ""
16:00:47 <geekosaur> then I have ot fall back on what I said earlier... notFollowedBy is not meaningful when the parser successfully matches nothing.  It can't even sanely check for that without a lot of overhead (if at all)... you're doing something that is not really rational
16:02:15 <teneen> geekosaur, "notFollowedBy eof" does not seem irrational to me
16:02:35 <teneen> geekosaur, although it maybe equivalent to "many1 anyChar"...but still it's not irrational
16:03:39 * geekosaur is tryoing to figure out how to formulate the response to that but fears it comes down to "do you know whats going on in there?"
16:04:25 <teneen> geekosaur: is "many1 anyChar" irrational?
16:04:32 <mrkronecker> Would anyone happen to be familiar with some Haskell library which will allow me to colour terminal output?
16:05:27 <HairyDude> there is a port of ncurses
16:06:59 <parcs`> ansi-terminal
16:07:43 <mrkronecker> Ah! Here we go. Thanks!
16:20:13 <parcs`> i don't know what incremental io abstraction to use anymore :(
16:20:52 <illissius> is there anything reasonable you can call the two type parameters of a lens? for functions something like 'input' and 'output' works, but for lenses that doesn't feel right
16:20:59 <byorgey> parcs`: you should use my new one, sluices
16:21:19 <illissius> I'm thinking of things like 'part' and 'whole', or 'field' and 'record', but both of those over-constrain the meaning :\
16:24:39 <parcs`> why not a b ?
16:26:48 <illissius> parcs`: I'm trying to be descriptive :) besides, even if I use a and b for the types, I still might want to talk about them in the documentation.
16:27:39 <illissius> going for field/record for now.
16:28:52 <parcs`> yeah that sounds good
16:30:17 <otters> what's an example of what existential types are good for?
16:36:11 <illissius> otters: the classic example is data Foo = forall a. SomeClass a => Foo a, which can hold values of any type as long as they implement SomeClass, and the only thing you can do with the contained value are the things the class allows. this lets you store lists of heterogenous types that all implement the same class, for example.
16:36:32 <illissius> (but most of the time, using records of functions instead is just as good for that case.)
16:38:42 <geekosaur> teneen: ok, I think Ive sorted out what I was trying to say, although I don't know if I can convey it.  I was inaccurate in pointing to "successfully matches nothing", that is necessary but not sufficient.  The real point is "always succeeds"
16:40:47 <geekosaur> "notFollowedBy alwaysSucceeds" is an error.  It is not an error that Parsec can detect for you, because doing so requires solving the halting problem (literally); the only way Parsec could do this is force you to not use anything but its own "safe" combinators, and that would severely reduce its usefulness and expressiveness.  (Neither Monad nor Applicative would know to pass on the extra proof that a given parser always succeeds.)
16:43:35 <otters> illissius: I see
16:45:36 <geekosaur> And even if it did do so, you would then need to provide such a proof in any new combinators you wrote; which pushes solving the halting problem onto you.
16:46:07 <HairyDude> "trust me, this is halting"
16:47:55 <geekosaur> And when you're doing this to avoid a weird corner case in a combinator whose primary use is in defining the "eof" parser, it seems not worth any of it
16:51:46 <elliott> geekosaur: Technically, I think you could modify Applicative/Monad to do it fairly easily.
16:51:49 <elliott> But it'd be awkward.
16:52:44 <geekosaur> Seems to me it'd put a fair amount of awkwardness on non-parser uses of them, which is damning the many to make a small corner case easier
16:55:42 <elliott> geekosaur: Yeah.
16:55:46 <elliott> Not advocating it.
17:02:09 <statusfailed> Is the Haskell "Functor" basically identical to the Functor in mathematics?
17:02:32 <DrSyzygy> statusfailed: BAsically; with one or two additional pobservations
17:02:51 <DrSyzygy> the core one being that a functor action on objects is captured by a higher kind type rather than in the functor typeclass
17:03:11 <DrSyzygy> statusfailed: So the category here has objects = types, morphisms = Haskell functions
17:03:22 <DrSyzygy> Now, if you have a type of _kind_ * -> *, it'll take a type and give you a new type
17:03:44 <DrSyzygy> so any type of kind * -> * could be used as a abasis for a functor -- it'll map objects to objects.
17:03:54 <DrSyzygy> The remainding part is that you need to map morphisms to morphisms.
17:04:08 <DrSyzygy> And that's what the Functor typeclass in Haskell does -- it provides you with a function, called fmap
17:04:11 <DrSyzygy> :t fmap
17:04:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:04:19 <statusfailed> "it'll map objects to objects", shouldn't that be "types to other types"?
17:04:24 <DrSyzygy> And fmap takes a function, and gives you a function back.
17:04:30 <DrSyzygy> Sure. Remember objects = types.
17:04:38 <statusfailed> oh sorry, hehe
17:04:48 <statusfailed> oh! got it
17:04:56 <statusfailed> Awesome! thanks very much
17:04:59 <DrSyzygy> :-)
17:05:00 <statusfailed> i'm going to copy-paste and save this :)
17:05:13 <statusfailed> that was a brilliant explanation
17:07:28 <DrSyzygy> I'm glad it helped
17:15:12 <Baughn> @hoogle isDirectory
17:15:13 <lambdabot> System.Posix.Files isDirectory :: FileStatus -> Bool
17:20:04 <tazjin> I propose that in GHC 7.6's Prelude a definition for (£) = ($) should be added, considering the origin of GHC.
17:21:14 <irene-knapp1> amusement
17:23:53 <edwardk> tazjin: it should be ($) with the opposite fixity, since they drive on the opposite side of the road
17:24:16 <edwardk> that way you can actually use chains of £ usefully in factoring code
17:24:37 <tazjin> Glorious idea!
17:24:44 <elliott> Ah, so £ would be better than $.
17:24:46 <elliott> Just like in real life.
17:25:11 <edwardk> foo $ bar $ baz $ quux quaffle (blah blarg) = foo . bar . baz $ quux quaffle (blah blarg) but you can't factor the ()' into a combinator
17:25:29 <edwardk> but foo . bar . baz £ quux quaffle £ blah blarg gets rid of all of the parens
17:25:44 <mapreduce> It wouldn't work, you'd have to explain that pound doesn't mean # constantly at conferences.
17:25:59 <tazjin> that's why you refer to it as "pound sterling"
17:26:01 <edwardk> just get used to saying 'GBP' really fast
17:26:05 <edwardk> oh even better
17:26:14 <illissius> tazjin, I assume you've seen the joke about PHP?
17:26:25 <edwardk> i'd assume there is more than one
17:26:37 <illissius> well, the one involving pound sterling. :)
17:26:38 <tazjin> illissius: No, I don't dabble in PHPish areas of the web
17:26:48 <illissius> tazjin: http://www.addedbytes.com/blog/if-php-were-british/
17:27:30 <tazjin> Ohh, that reminds me of http://morecss.org/
17:28:59 <Igloo> Someone needs to find a good definition for perchance, and make a library proposal
17:29:08 <hpc> nand`: just got back; neat
17:29:18 <mapreduce> I like on_the_off_chance.
17:30:14 <nand`> http://pastebin.com/Ld7CYtpg <- remind me why people use C++
17:30:16 <mauke> The paste Ld7CYtpg has been copied to http://hpaste.org/69792
17:30:59 <tazjin> nand`: Because of OOP and the nice syntax and … oh wait.
17:31:33 <illissius> nand`: That's not entirely fair -- you're comparing C++'s type level with Haskell's value level.
17:31:46 <nand`> illissius: yeah true
17:32:04 <illissius> not that it would win if it were apples to apples, but it would be less dramatic
17:32:24 <nand`> I just didn't bother comparing the value level, since isn't the template system the only thing that's exciting about C++, what with compile time monads and pattern matching and all
17:33:23 <mapreduce> You're the reason my C++ never finishes compiling, aren't you?
17:34:41 <copumpkin> @free undefined :: a
17:34:42 <lambdabot> f undefined = undefined
17:36:14 <hello_> hi~
17:36:42 <nand`> what's the haskell compiler that produces javascript again?
17:37:01 <tazjin> UHC, I think
17:37:23 <byorgey> hi hello_
17:37:23 <nand`> tazjin: oh right, thanks
17:37:28 <hpaste_> Cale annotated “pastebin.com/Ld7CYtpg” with “pastebin.com/Ld7CYtpg (annotation)” at http://hpaste.org/69792#a69793
17:37:29 <nand`> I was thinking JHC (JavaScript Haskell Compiler.. hehe)
17:37:37 <Cale> ^^ better comparison?
17:37:58 <nand`> Cale: amazing thing is Haskell still has much, much less boilerplate and more readable code
17:38:15 <Cale> We could do better still now with some of the newer extensions
17:38:34 <nand`> for example?
17:39:17 <illissius> nand`: anyway, the reason people use C++ is that it's very fast and compatible with C and C++
17:41:08 <nand`> illissius: I was joking :)
17:41:27 <Cale> nand`: Well, we could make it kind-safe using DataKinds
17:42:20 <nand`> Cale: yeah, doesn't that automatically lift the type constructors as well allowing us to write data Nat = Zero | Suc Nat
17:46:24 <Cale> yes
17:49:15 <hpaste_> Cale annotated “pastebin.com/Ld7CYtpg” with “kindsafety” at http://hpaste.org/69792#a69794
17:53:29 <hpaste_> Cale annotated “pastebin.com/Ld7CYtpg” with “Let's try it!” at http://hpaste.org/69792#a69795
17:55:06 <illissius> Cale: I thought you only had to write 'These in case of ambiguity?
17:56:11 <Cale> Oh, possibly
17:56:19 <nand`> yeah I'm pretty sure
17:56:28 <Cale> yeah, seems like it
18:02:40 * hackagebot Hach 0.1.0 - Simple chat  http://hackage.haskell.org/package/Hach-0.1.0 (DmitryMalikov)
18:04:05 <nand`> Cale: for bonus points, write the equivalent C++ program
18:04:31 <Cale> heh
18:09:13 <nand`> Is there a table of Haskell extensions and which compilers support them?
18:10:02 <tazjin> nand`: http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
18:11:33 <nand`> tazjin: thanks
18:13:49 <nand`> seems a bit outdated
18:14:01 <nand`> for example “DataKinds” is listed as “False” for GHC
18:17:11 <tazjin> Yeah, true
18:17:12 <tazjin> hmm
18:17:18 <tazjin> I don't know if there's a more up to date list
18:19:09 <nand`> fair enough
18:20:53 <edwardk> i think it mostly that DataKinds isn't fully supported yet
18:21:07 <edwardk> its most of the way to usable though
18:22:05 <nand`> edwardk: btw, what's the relationship between Pointed/Copointed and return/extract?
18:22:19 <edwardk> in theory they should coincide if both can be define for a type
18:22:48 <edwardk> I dont _like_ Pointed/Copointed, so i mostly maintain 'pointed' to keep some people happy ;)
18:22:49 <nand`> I was wondering why Comonad isn't class (Extend f, Copointed f) => Comonad f
18:24:21 <nand`> (for that matter, we should have class Bind m where bind :: (a -> m b) -> m a -> m b; join :: m (m a) -> m a
18:24:37 <nand`> perhaps “class Contract m” to dualize with “class Extend w”
18:26:52 <nand`> edwardk: you said you don't ‘like’ Pointed/Copointed, why? Is this because there aren't many sensible instances that aren't instances of the less general versions?
18:27:23 <tgeeky> nand`: because it's not as useful as it might seem
18:27:25 <tgeeky> that's the reason I read
18:28:39 <edwardk> i don't like them because most of the scenarios in which i find them used are incorrect. for instance if I have a function fromList :: (Pointed a, Monoid (f a)) => [a] -> f a -- for say, building up Sets built out of say fromList = foldMap point  -- it relies on the interaction between Pointed and some completely unrelated typeclass that has no law to tie it together
18:29:03 <edwardk> you have to reason about each usecase in a completely ad hoc manner
18:29:28 <edwardk> nand`: i have Bind in semigroupoids
18:29:29 <nand`> did you mean “Pointed f”?
18:29:35 <edwardk> nand: yes
18:29:36 <edwardk> sorry
18:29:43 <nand`> ok, just making sure
18:29:57 <tgeeky> it's rather well defined when you get all the way to Applicative
18:30:26 <nand`> I see what you're getting at
18:30:28 <edwardk> tgeeky: sure, but you _can_ make a nice hierarchy without passing through Pointed by building up just the Apply combinator from Applicative
18:30:38 <edwardk> there you get an associativity law, which lets you put stuff together
18:30:47 <tgeeky> edwardk: yep. Though there is a weaker version of applicative out there, that isn't being used anywhere
18:30:56 <tgeeky> (according to Hinze)
18:31:05 <edwardk> you can reason about the static functor composition for your type as a semigroupoid if not a category
18:31:12 <edwardk> which one?
18:31:17 <edwardk> i have Apply in semigroupoids
18:32:15 <tgeeky> the version of idiom without k combinators (without k = pure K), but with I combinators (with i = pure id, b = pure (.), c = pure (flip), and s = ... something?)
18:32:51 <tgeeky> edwardk: http://www.cs.ox.ac.uk/ralf.hinze/Lifting.pdf page 16, at the top
18:33:07 <edwardk> oh that
18:33:17 <tgeeky> he mentions the Set idiom (which nobody has defined in the haskelliverse as far as I know)
18:33:21 <tgeeky> has c combinators
18:33:49 <tgeeky> edwardk: but I suppose this isn't relevant, since we started talking about Pointed and this doesn't have pure
18:34:16 <tgeeky> edwardk: what I really want to know, is if it makes sense to have multiple Pointed instances for the same class (or several different pure functions)
18:34:52 <edwardk> thats the problem. Pointed is underdefined to the point of uselessness. its only defined up to 'if you can make an Applicative, this should be compatible with it'
18:35:10 <edwardk> now, Apply has the same problem, but there are lots of ways to productively employ the result
18:36:28 <tgeeky> edwardk: do you know what he means with "There is also a need for a linear version of the lifting lemma"?
18:36:45 <tgeeky> he says that right after "The set idiom possess a c combinator" (which is pure (flip))
18:36:56 <tgeeky> I'm not sure how I understand how that could be related to the concept of linear anything
18:37:28 <edwardk> haven't read through the paper yet, just threw it on a pile
18:38:09 <tgeeky> i figured. I was just asking for a haphazard guess. I suppose I could e-mail the dude.
19:09:51 <yayMe> Any tips on fixing this expression? It's complaining of ambiguous type:
19:09:53 <yayMe> let set =  replicate 20 (randomRIO, (1 , 10))
19:10:48 <yayMe>     Ambiguous type variable `a0' in the constraints: (Num a0) arising from the literal `10' at src\Main.hs:25:46-47
19:11:56 <yayMe> I'm just learning
19:12:12 <rlpowell> As something of a newb myself, I'd just put " :: Int" after the 10 and call it good.
19:12:34 <yayMe> tried that, but I'll try it a few different ways I suppose
19:12:35 <shachaf> @ty randomRIO
19:12:36 <lambdabot> forall a. (Random a) => (a, a) -> IO a
19:12:42 <shachaf> yayMe: What's that expression supposed to be?
19:12:49 <yayMe> oh it worked
19:13:07 <yayMe> I tried Num not Int
19:13:10 <shachaf> Are you sequence_ . zipWith id ing it or something?
19:13:17 <shachaf> s/_//
19:13:21 <yayMe> Int worked, I guess I need to learn what the different types are a little better
19:13:31 <shachaf> yayMe: Num isn't a type.
19:13:44 <yayMe> But Int is?
19:14:27 <yayMe> also, why doesn't it complain the 1 is ambiguous, only the 10
19:15:42 <rlpowell> yayMe: It depends what you're doing with the output.
19:15:50 <rlpowell> Something later may be constraining the types.
19:16:24 <yayMe> aye, but from my read of the randomRIO definition they both have the same type
19:16:32 <yayMe> does it infer from one of them what the definition of the other is perhaps?
19:16:45 <rlpowell> 10-19:16 < yayMe> aye, but from my read of the randomRIO definition they both have the same type -- You don't have anything in randomRIO.
19:16:51 <rlpowell> 10-19:09 < yayMe> let set =  replicate 20 (randomRIO, (1 , 10)) -- note the comma.
19:17:13 <robossliu> hello
19:17:23 <rlpowell> (randomRIO, (1 , 10))  => "a tuple with the function randomRIO, and another tuple; the latter has 1 and 10"
19:17:27 <robossliu> [42, 13, 22]
19:17:59 <rlpowell> yayMe: If you meant to call it, you want (randomRIO (1 , 10))
19:18:13 <yayMe> No I didn't mean to
19:18:29 <yayMe> unless I'm mistaken I can't call it that easily, I need to bind it no?
19:18:59 <rlpowell> Well, putting it in a tuple isn't binding it either.
19:19:22 <rlpowell> I've never used that funciton, so Idon't actually know.
19:19:25 <yayMe> I'm trying to construct a list for later binding with fst x $ snd x or something
19:20:41 <nand`> Isn't Num a type with kind :: * -> Constraint ?
19:20:43 <rlpowell> Do you want each element to be a new random call?
19:20:52 <rlpowell> Beacuse replicate won't do that.
19:20:53 <yayMe> yes
19:20:56 <yayMe> no
19:21:02 <yayMe> rlpowell, I want that later
19:21:27 <yayMe> I want a list of executable things, I'll execute each element of the list with fst x $ snd x (I think that will work)
19:21:58 <rlpowell> Haskell is lazy; you always get that whether you want it or not.
19:22:08 <rlpowell> (sort of; there's a function to force evaluation)
19:22:12 <shachaf> nand`: No, it's not a type.
19:22:22 <shachaf> rlpowell: I'm not sure what you mean here?
19:22:43 <rlpowell> shachaf: Just that haskell never evaluates anything until it has to.
19:23:07 <rlpowell> let foo = replicate 20 (+ 10 5) -- doesn't actually evaluate any additions.
19:23:08 <shachaf> Evaluation has nothing to do with selecting a random number, though.
19:23:14 <shachaf> Oh, I think I see yayMe's confusion.
19:23:18 <rfw> hi #haskell, just a quick math and probably not all that haskell-related question: what does |= mean?
19:23:19 <rlpowell> shachaf: I was responding to "10-19:21 < yayMe> I want a list of executable things, I'll execute each element of the list with fst x $ snd x (I think that will work)"
19:23:39 <shachaf> @hoogle (|=)
19:23:39 <lambdabot> No results found
19:23:46 <shachaf> rfw: It's an operator defined by some library you're using.
19:23:49 <yayMe> rlpowell: It won't complain if it's not in an IO() function?
19:23:52 <shachaf> So who knows!
19:23:56 <rfw> shachaf: in the context of math, not haskell :p
19:24:05 <shachaf> yayMe: I think you're confusing evaluation and execution here.
19:24:10 <shachaf> rfw: Oh.
19:24:17 <shachaf> rfw: Context is still relevant!
19:24:52 <rfw> it seems to be talking about set theory, and Σ |= X → Y
19:25:29 <rlpowell> yayMe: You might want to look at http://www.haskell.org/haskellwiki/Examples/Random_list
19:25:34 <shachaf> yayMe: The list [randomRIO (1,1), randomRIO (1,1)] is just as good (or better) for your purposes as the list [(randomRIO, (1,1)), (randomRIO, (1,1))]
19:25:53 <yayMe> shachaf: But will the first one work if it's not in a function IO() ?
19:26:02 <shachaf> I don't know what that means.
19:26:16 <yayMe> not in main
19:26:17 <shachaf> I have the feeling you should read about how IO works in Haskell, though. :-)
19:26:24 <rlpowell> shachaf: He wants to use the random results in pure code.
19:26:29 <rlpowell> Agreed.
19:26:40 <rlpowell> RWH and LYAH both cover it well, IMO.
19:26:48 <yayMe> no, I don't, I want to define random execution in pure code
19:26:55 <yayMe> then execute it in main
19:26:57 <yayMe> is that possible?
19:27:03 <shachaf> yayMe: Yes, it is.
19:27:06 <rlpowell> Sure.
19:27:14 <shachaf> But the list I mentioned works just fine for it.
19:27:23 <yayMe> ok cool
19:27:30 <shachaf> Applying randomRIO to (1,1) doesn't do any random-number generation.
19:27:43 <yayMe> only binding it does?
19:27:54 <shachaf> I just gives you an action that you can execute somewhere else (like main) in order to do the generation.
19:28:03 <shachaf> I would say that "executing it" does.
19:28:31 <yayMe> Ok, I guess I need to read more learn you a haskell
19:29:21 <shachaf> yayMe: The FAQ has some good links on this topic:
19:29:23 <shachaf> @where faq
19:29:23 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
19:29:30 <shachaf> In particular "Introduction to IO"
19:29:50 <shachaf> @google introduction to io haskell
19:29:52 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
19:29:52 <lambdabot> Title: Introduction to IO - HaskellWiki
19:33:27 * nand` is having fun with UHC's -tjs
19:33:29 <nand`> this is awesome
19:36:29 <Cale> yayMe: if you want to do pseudorandom number generation from inside pure code, you'll have to pass PRNG states (like StdGen) around by hand
19:36:38 <Cale> :t randomR
19:36:39 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
19:36:46 <Cale> :t mkStdGen 42
19:36:47 <lambdabot> StdGen
19:37:04 <Cale> > randomR (1,10) (mkStdGen 42)
19:37:05 <lambdabot>   (2,1720602 40692)
19:37:24 <Cale> So we got our first pseudorandom number, 2, and a new PRNG state
19:37:30 <Cale> (to be used to get another one)
19:38:06 <shachaf> I think an unsafeInterleavedIO list of IO-generated random numbers is probably a lesser evil than most cases of lazy I/O.
19:38:12 <Cale> Typically you might use newStdGen :: IO StdGen to get your first generator state at the top level, and then pass that into your pure code.
19:38:29 <Cale> But yeah, you could also just get an infinite list of pseudorandom numbers and pass that in
19:38:41 <Cale> In fact, you don't even need unsafeInterleaveIO
19:38:45 <Cale> just randoms
19:38:52 <shachaf> Cale: If you want a PRNG, yes.
19:38:57 <nand`> or use a (RandomGen g, Random a) => State g a
19:39:02 <Cale> shachaf: nope!
19:39:09 <Cale> :t randoms
19:39:10 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
19:39:12 <Cale> :t randomRs
19:39:12 <shachaf> Cale: I mean: What you said is correct if you want a PRNG.
19:39:13 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
19:39:16 <Cale> oh
19:39:19 <shachaf> Cale: But if you want /dev/randoms-style random numbers...
19:39:25 <shachaf> s/ms/m/
19:39:25 <Cale> right, in that case
19:40:33 <nand`> foo <$> readFile "/dev/random"
19:40:36 <nand`> done
19:40:37 * nand` hides
19:47:18 <NemesisD> hi all. im starting to get the impression that its a very bad thing to depend on both base and haskell98, is this accurate?
19:48:01 <luite> yes
19:49:45 <geekosaur> it was dubious but allowed back when base and haskell98 agreed about how things behave, but haskell2010 changed some types so now you have to pick which one's types you want (h98, h2010, base)
19:50:16 <NemesisD> yeesh
19:51:45 <geekosaur> besides, the flat namespace should have died years ago; that was accepted as an annex to the h98 standard, even
20:36:22 * ksf wants a typeclass foo :: f a -> f a; foo' :: a -> f a
20:40:54 <ksf> that *has* to be possible.
20:52:09 <copumpkin> ksf: perhaps if you elaborated on it :P
20:55:22 <favonia> does anyone know how to make lambdabot join a channel? my friends and I are creating #haskell.tw
20:58:46 <ksf> copumpkin, suppose I have 23 and [42]. Now I want a function that can take both types as argument.
20:59:06 <ksf> ...by automagically lifting 23 to [23]
21:06:14 <favonia> oh I think I know how to make lambdabot join a channel now, except that I don't have enough privileges :)
21:06:31 <mauke> preflex: seen Cale
21:06:32 <preflex>  Cale was last seen on #haskell 1 hour, 27 minutes and 7 seconds ago, saying: right, in that case
21:07:54 * hackagebot campfire 0.2.1 - Haskell implementation of the Campfire API  http://hackage.haskell.org/package/campfire-0.2.1 (MichaelXavier)
21:16:35 <ksf> @hoogle (a -> f b) -> (a -> f c) -> a -> f (b,c)
21:16:35 <lambdabot> No results found
21:17:13 <ksf> aaah.
21:18:44 <favonia> @hoogle f a b -> f a c -> f a (b,c)
21:18:45 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
21:20:19 <favonia> @hoogle Kleisli
21:20:19 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
21:20:19 <lambdabot> Control.Arrow newtype Kleisli m a b
21:20:19 <lambdabot> package Kleislify
21:21:00 <Eduard_Munteanu> favonia: you don't AFAIK, you just ask Cale :)
21:21:40 <favonia> Eduard_Munteanu: mauke: thanks.
21:26:35 <unlink> Is there a function like this? concurrentlyMapM_ :: Int -> [IO ()] -> IO ()
21:27:29 <ksf> unlink, http://hackage.haskell.org/packages/archive/parallel/2.2.0.1/doc/html/Control-Parallel-Strategies.html
21:27:30 <ksf> parMap
21:27:49 <ksf> oh, *IO*
21:27:58 <ksf> what's the Int for?
21:28:14 <unlink> how many of them to run concurrently.
21:28:49 <unlink> I guess Int -> [IO a] -> IO () is probably closer.
21:28:59 <shachaf> unlink: Control.Concurrent.Spawn has something similar.
21:29:17 <shachaf> You can make it out of two of the functions there: pool and parMapIO_
21:29:42 <shachaf> pool :: Int -> IO (IO a -> IO a)
21:29:59 <unlink> Cool. I'll give that a try. Thanks.
21:30:11 <shachaf> -- | Given n, produces a function to wrap 'IO' actions. No more than n wrapped actions will be in progress at one time.
21:30:20 <shachaf> parMapIO_ :: (a -> IO b) -> [a] -> IO ()
21:30:32 <shachaf> However, using these primitives on their own might cause GHC to spawn a lot more threads than necessary.
21:30:45 <LineW> Hii.. I'm beginner with haskell. I wonder how the function (.)
21:30:47 <shachaf> In theory it should cope fine with that? I've had some problems with it but I didn't try very ahrd.
21:31:08 <ksf> @src (.)
21:31:08 <lambdabot> (f . g) x = f (g x)
21:31:08 <lambdabot> NB: In lambdabot,  (.) = fmap
21:33:56 <ksf> bloody knot-tying
21:34:15 <ksf> everything's constantly on the wrong side of the lambda to bind it.
21:34:17 <LineW> ksf ,, thanks
21:43:37 <mikeplus64> what practical advantages are there of using a TChan over just a Chan?
21:46:28 <shachaf> Composability with other STM operations?
21:48:57 <luite> isEmptyChan that actually works...
21:55:46 <zzo38> edwardk: Actually there is a use for the left Yoneda!
21:55:53 <edwardk> ?
21:55:57 <edwardk> there are a few
21:56:02 <edwardk> whats yours?
21:56:51 <zzo38> edwardk:  Free (CoYoneda f)  where f is a GADT representing what actions can be performed with the monad
21:57:31 <edwardk> hrmm
21:58:14 <edwardk> cute
21:58:51 <djahandarie> What does that do?
22:00:13 <edwardk> its another way to fuse together tha maps used by free
22:00:34 <edwardk> data Coyoneda f a = forall b. Coyoneda (b -> a) f b
22:00:49 <edwardk> fused into the free monad you get
22:01:38 <edwardk> data Free f a = forall b. Free (b -> Free f a) (f b) | Pure a
22:02:01 <edwardk> which is precisely the 'operational' monad form used by apfelmus, and which we use in scalaz
22:02:23 <edwardk> hadn't spotted the connection as Free (Coyoneda f) though
22:02:30 <edwardk> thats a great observation
22:03:17 <edwardk> what it exploits is that fmaps on Coyoneda'd functors get fused together for you
22:03:47 <edwardk> also, its interesting because that free monad doesn't need the functoriality of f until you go to extract from it
22:04:20 <edwardk> we actually exploit this in the free monad we use here in some reporting code we have, but i completely missed the connection
22:04:59 <djahandarie> How does this compare to applying Codensity to it?
22:05:01 <zzo38> edwardk: Well, now you didn't miss it anymore.
22:05:13 <edwardk> Codensity makes a type thats 'too big'
22:05:25 <edwardk> i blogged about that
22:05:48 <edwardk> http://comonad.com/reader/2011/free-monads-for-less/
22:05:52 <edwardk> and the followup post
22:06:05 <edwardk> zzo38: thanks =)
22:06:23 <edwardk> note the Church-free monad i defined has the same properties
22:06:34 <edwardk> and you can probably convert between the two representations quite easily
22:07:06 <zzo38> edwardk: OK
22:07:10 <edwardk> but its a lot easier to see the isomorphism between Free f a and Free (Coyoneda f) a
22:13:12 <zzo38> edwardk: Well, it is if f is a Functor, then f and Yoneda f and Coyoneda f are all equivalent, as you said yourself
22:13:40 <edwardk> they are at least isomorphic, aside from the extra bottom in Coyoneda
22:13:44 <zzo38> But they all differ if f is not a Functor
22:13:55 <zzo38> edwardk: Yes, isomorphic, that is how I meant
23:05:19 <augur> Peaker: g <: (x,s) :- t
23:05:24 <augur> << psygnisfive
23:05:59 <augur> or maybe even g <: x ::: t :- t
23:06:05 <augur> just to be maximally abusive
23:06:11 <augur> er, x ::: s
23:06:35 <zzo38> augur: What are you making?
23:07:01 <augur> nothing, im just trying to show Peaker that it's not the unicode in "e : Γ , x ∶ σ ⊢ τ" that he has trouble with
23:07:04 <augur> its the parsing
23:08:18 <augur> actually you cant do <: can you, whatever
23:08:18 <augur> :<
23:16:31 <augur> i just find it incredibly perplexing when someone says they don't understand what Γ is for but they're perfectly happy with g
23:16:37 <augur> its a variable, what more is there to say
23:21:33 <zzo38> Well, it isn't ASCII.
23:22:02 <augur> yeah, which seems to be some sort of magical hangup
23:22:14 <augur> ascii? obvious. unicode? no fucking clue.
23:22:32 <augur> apparently variable-ness magically vanishes when you start using anything other than latin letters
23:23:03 <shachaf> augur: I don't like it when people use Greek letters whose names I don't know how to pronounce.
23:23:08 <zzo38> I don't think so. Perhaps they don't know Greek so well
23:23:10 <shachaf> I happen to know Gamma but not a lot of the other ones.
23:23:12 <augur> shachaf: :)
23:23:31 <shachaf> What's that supposed to mean?
23:23:45 <augur> zzo38: who needs to know greek, tho? it's a symbol.
23:24:00 <augur> shachaf: nothing, just that that's a silly justification
23:24:09 <shachaf> augur: Would you like to me use variables like ג?
23:24:16 <augur> sure why not
23:24:33 <shachaf> Perhaps you care about how variables are pronounced less than other people!
23:24:47 <augur> i pronounce that "drink lambda"
23:24:52 <augur> drunk*
23:25:13 <zzo38> In a mathematical formula you can use whatever symbols you want but in a computer program I expect ASCII
23:25:40 <augur> well i dont expect ascii!
23:25:40 <zzo38> It is what ASCII is designed for
23:25:52 <augur> ascii was designed for teletype machines
23:28:02 <augur> last time i checked we're not typing on teletype machines, nor reading off them
23:42:43 <AfC> yeah, those 30-odd control symbols in the first few octets really come in handy when programming.
23:43:31 <AfC> especially the ever popular 0x10 "device control reserved for data link escape"
23:44:45 <augur> :x
23:46:05 <zzo38> AfC: Are you sure those things? They become useful when you want to add linefeeds, or if you want to overstrike symbols over each other, etc
23:46:45 <shachaf> AfC: That's why I use CP437 instead of ASCII.
23:47:38 <augur> i prefer using C3P0
23:55:02 <Peaker> from Haskell's logs at the web: "23:07:01 <augur> nothing, im just trying to show Peaker that it's not the unicode in "e : Γ , x ∶ σ ⊢ τ" that he has trouble with" <-- another reason to avoid Unicode
23:55:39 <augur> we should just get right of symbols entirely, after all, newbies dont understand those
23:55:44 <augur> lets just program in english
23:58:26 <aleator_> Lets say that I've got an arbitrary haskell expression that happens to evaluate to a show instance. In which cases does prepending "show $" to the said expression result in an invalid expression?
23:59:00 <shachaf> Syntactically?
23:59:19 <shachaf> Well, if you have "foo :: Int", then "show $foo :: Int" would be invalid.
23:59:31 <aleator_> Ah. True.
23:59:34 <shachaf> But if you mean at a slightly higher level I can't think of a case when it wouldn't work.
23:59:56 <shachaf> If you have an actual specific question you should ask that instead of having people guess what's wrong based on a weird description. :-)
