00:05:02 * hackagebot http-conduit 1.4.1.9 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.4.1.9 (MichaelSnoyman)
00:45:03 * hackagebot data-default 0.5.0 - A class for types with a default value  http://hackage.haskell.org/package/data-default-0.5.0 (LukasMai)
00:45:58 <hpaste> yantayga pasted “kmeans” at http://hpaste.org/70097
00:48:26 <hpaste> yt annotated “kmeans” with “kmeans (annotation)” at http://hpaste.org/70097#a70098
00:48:44 <hpaste> yantayga pasted “kmeans” at http://hpaste.org/70099
01:12:15 <boo> is there a command to list available modules  ?
01:12:24 <shachaf> @list available modules
01:12:25 <lambdabot> No module "available modules" loaded
01:12:32 <shachaf> Oh, you mean Haskell modules.
01:12:43 <shachaf> Tab-completion in ghci will do it...
01:13:16 <boo> yep. thanks shachaf
01:13:28 <mgsloan> this might be helpful too: http://www.fremissant.net/portackage/
01:17:36 <boo> mgsloan are those packaged by default ?
01:17:41 <mgsloan> nope
01:17:41 <boo> or more like a repository ?
01:17:46 <boo> ah i see
01:17:49 <mgsloan> I think that's all of hackage
01:18:52 <boo> btw. tab completion doesn't show me complete list of available modules
01:19:01 <boo> for example System.Directory is not there
01:19:09 <boo> it is only some Prelude.*
01:19:13 <mgsloan> You can use tab completion on ":m + Sys"
01:19:16 <mgsloan> etc
01:20:21 <boo> yeah. that works !
01:27:19 <nand``> Is it common to use "Semigroupoid" instead of "Semicategory"?
01:27:53 <nand``> (Or even valid, for that matter)
01:33:38 <bitonic> nand``: well, one is a set-theoretic notion while the other is CT-like, no?
01:33:59 <bitonic> so I'd say that semicategory is a more general term
01:34:16 <shachaf> You ascend to the status of demicategory...
01:36:26 <mikeplus64> @pl (\a -> [a,a])
01:36:27 <lambdabot> ap (:) return
01:37:05 <bitonic> mikeplus64: you gain length while losing readability!
01:37:22 <mikeplus64> @pf (\a -> [a, a])
01:37:22 <lambdabot> Maybe you meant: bf pl
01:37:28 <mikeplus64> @bf pl (\a -> [a, a])
01:37:28 <lambdabot>  Done.
01:37:32 <mikeplus64> wat
01:37:37 <mikeplus64> bitonic: yep :)
01:53:08 <nand``> bitonic: Iunno, I know them from the same context
01:54:03 <nand``> (abstract algebra)
01:55:05 * hackagebot HaXml 1.23.1 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.23.1 (MalcolmWallace)
02:02:19 <bitonic> nand``: well that was my guess. I had actually never heard the word "semicategory" before. Which tells you that you should never listen to me :D
02:02:34 <nand``> noted :P
02:02:41 <nand``> I just saw that term on wikipedia
02:02:49 <nand``> no idea if it's used in literature or not but it sounds logical
02:03:01 <nand``> they both sound logical
02:03:10 <bitonic> nand``: the first google hit for semicategory says I'm right
02:03:15 <bitonic> @google semicategory
02:03:17 <lambdabot> Plugin `search' failed with: connect: does not exist (No route to host)
02:03:21 <bitonic> ahhh.
02:03:38 <bitonic> ncatlab.org/nlab/show/semicategory this.
02:04:40 <nand``> won't let me connect :(
02:05:15 <bitonic> nand``: you can get the google cache
02:05:26 <bitonic> "The definition of semicategory or category without units is like that of category but omitting the requirement of identity-morphisms. This generalizes the notions of semigroup, semiring, etc:"
02:05:55 <nand``> right
02:06:32 <nand``> Meanwhile, a semigroupoid is a semigroup without the totality requirement, which is pretty much the same thing :P
02:17:19 <mikeplus64> how does lambdabot's :t work?
02:17:21 <mikeplus64> :t ap
02:17:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:18:01 <kallisti> mikeplus64: it uses the GHC API to get the information.
02:18:08 <mikeplus64> ah
02:18:14 <kallisti> through hint, I'm guessing?
02:18:17 <kallisti> @hackage hint
02:18:18 <lambdabot> http://hackage.haskell.org/package/hint
02:18:29 <kallisti> maybe not
02:18:38 <mikeplus64> hint can definitely infer types
02:19:01 <kallisti> right I just don't know if exports that part of the API
02:19:06 <kallisti> *if it
02:19:42 <kallisti> ah yes
02:19:48 <kallisti> typeOf :: MonadInterpreter m => String -> m StringSource
02:19:49 <kallisti> Returns a string representation of the type of the expression.
02:19:52 <mikeplus64> yeah
02:22:31 <kallisti> mikeplus64: the mueval package is basically a standalone version of lambdabots interpreter code.
02:22:50 <mikeplus64> yeah
02:23:37 <HugoDaniel> :)
02:24:23 <Lemon> how can I make GHCi print its inferred types with forall?
02:24:38 <Lemon> I tried :set -XExplicitForall but it doesn't work
02:24:56 <Lemon> neither does RankNTypes
02:46:07 <joeytwiddle> Lemon: bit out of my depth.  would it help to implement your own foreach and check his types instead?
02:48:37 <merijn> When I set a value for DYLD_LIBRARY_PATH (on OSX) GHC magically stops finding some dynamic libraries, any clues what might be going wrong?
03:03:54 <adimit> ok, so this is a long shot. cabal-dev generates a package config for its sandbox. I need to hide a package in that config in order for ghc-mod to behave. But ghc-pkg bails on that cache with Prelude: no parse. What's wrong?
03:04:10 <adimit> % ghc-pkg -f packages-7.4.1.conf/package.cache hide monads-tf-0.1.0.0
03:04:29 <adimit> ghc-pkg: error while parsing cabal-dev/packages-7.4.1.conf/package.cache: "Prelude.read: no parse"
03:06:01 <adimit> And the package file looks just like my global one in ~/.ghc/arch-linux-ghcver/package.conf.d/package.cache
03:08:07 <adimit> HA. nevermind. ghc-pkg wants a *directory* not the package.cache file. That's actually super-confusing, since the documentation says -f FILE        --package-conf=FILE     use the specified package config file (where it should read *directory*)
03:08:17 <adimit> (monologue is over.)
03:12:52 <Saizan> adimit: it was a file in earlier versions, you should probably file a ticket
03:21:30 <adimit> Saizan: good idea :-)
03:22:32 <hpaste> merijn pasted “dynamic linker error” at http://hpaste.org/70105
03:23:05 <merijn> This occurs once I set DYLD_LIBRARY_PATH in my environment, but when I don't set it things just work. Why would that happen?
03:26:08 <adimit> Saizan: hackage.haskell.org/trac/ghc/ would be the bug tracker to report this kind of stuff to, no?
03:26:19 <Saizan> ?bug
03:26:19 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
03:26:25 <Saizan> yep
03:26:29 <adimit> good, thanks again.
03:28:34 <hpaste> stj pasted “can this monad transfomers be made prettier?” at http://hpaste.org/70106
03:28:39 <stj> I wrote a very short dice-rolling game that displays the current sum, and would like to make it prettier
03:28:56 <stj> with monad transformers for remembering state this is really horribled
03:29:48 <stj> I know StateT is not really necessary at all, but what if I want to make this a bit more complicated... :/
03:30:09 <stj> any suggestions on what I can do with this?
03:30:37 <kallisti> stj: best advice I can think of would be to identify the state-interacting computations and define them as functions/computations
03:30:56 <kallisti> which should alleviate a lot of the get/put/modify plumbing.
03:31:34 <stj> I see... and what about these ugly lifts?
03:31:50 <sipa> you can lift them all at once
03:32:00 <sipa> lift $ do putStrLn $ show r ++ ", sum = " ++ show (s+r)
03:32:11 <kallisti> typically for IO lifting you want to use liftIO. in this case it's the same but in more complex transformers the lift . lift nonsense is bad.
03:32:22 <kallisti> ah, yes.
03:33:50 <kallisti> stj: perhaps I'm just used to the monad transformer style, but I don't really find explicit liftIO's all that ugly.
03:33:53 <stj> I don't have experience with this, but what happens if the program gets very big and complex... do all these lifting, wrapping, unwrapping and pain with monad transformers become a big problem?
03:34:05 <kallisti> not in my experience.
03:34:36 <kallisti> well, it can be a pain if you attempt to reinvent the wheel. for example, I was trying to figure out how to lift exception handling
03:34:47 <kallisti> but that's already been done for me via the lifted-base package.
03:37:56 <kallisti> http://hackage.haskell.org/package/webdriver  not sure if this counts as a big complex program, but here's most of my (publically visible) experience with monad transformers and lifting. 1769 lines of code according to cloc.
03:39:07 <kallisti> the trick is just identifying patterns and then creating an abtraction that hides the ugliness.
03:41:51 <bitonic> kallisti: 2k lines is mid-sized, definitely not big and complex
03:41:57 <bitonic> well, it can be complex.
03:42:03 <bitonic> but not too big :P
03:51:55 <kallisti> bitonic: it's not particularly complex either. :P
03:58:12 <TEttinger> I am trying to install a Haskell application, BNFC, via cabal.  "cabal install bnfc" failed because of a duplicate Prelude import from haskell98 and from base, but when I took out the haskell98 dependency in the cabal file, it can't find Char.
03:58:34 <bitonic> kallisti: well, then it might not be a good candidate to answer that question - a very valid question imo. Composability is a big problem with monads.
03:58:44 <TEttinger> I don't know if I can remove base as a dependency and replace it with haskell98...?
03:59:22 <bitonic> TEttinger: remove base instead?
04:00:05 <TEttinger> tried that just now, can't find Data.List
04:00:42 <bitonic> TEttinger: uhm. then you might have a problem, he's using old and new namespaces at the same time. I'd just change Char to Data.Char.
04:01:08 <TEttinger> ah.  ok
04:02:50 <TEttinger> now it cannot find module System
04:03:09 <TEttinger> (after removing haskell98 and changing Char to Data.Char)
04:03:31 <siml1> hi. is it possible to import submodules using wildcards? havent found something yet...
04:04:14 <bitonic> TEttinger: remove that and see what function he's using, and re-import the correct modules
04:05:08 <gienah> I installed sabayon, but unfortunately the old notbook broke as soon as I installed it. Sabayon is a binary gentoo based distro with a friendly installer.
04:05:18 <gienah> oops wrong channel sorry
04:10:15 * hackagebot websockets-snap 0.6.0.2 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.6.0.2 (JasperVanDerJeugt)
04:12:10 <TEttinger> bitonic, yep, thanks.  I did that, turns out it didn't use System, but a bunch of other files (64) used import Char instead of Data.Char.  so I changed those, then List to Data.List, then Array, now Directory... and I don't know what the corresponding new module is
04:15:13 <bitonic> TEttinger: uhm, maybe there is a nicer way... what's the conflicting prelude import?
04:16:07 <TEttinger> you want the error, bitonic?
04:16:46 <bitonic> TEttinger: yeah, hpaste it
04:16:47 <TEttinger> the cabal file has Build-Depends: haskell98, base>=4 && <5, mtl, directory, array, process
04:18:06 <hpaste> notostraca pasted “BNFC compilation error” at http://hpaste.org/70112
04:18:36 <TEttinger> oh I use TEttinger on freenode, right
04:19:06 <bitonic> TEttinger: so the error comes up without explicitly importing prelude right?
04:19:19 <TEttinger> let me check
04:19:46 <TEttinger> yes.
04:20:23 <hpaste> srhb pasted “cabal-dev dependencies” at http://hpaste.org/70113
04:20:38 <srhb> Can someone help me decipher those errors? I am not sure what it's trying to tell me.
04:20:38 <lambdabot> srhb: You have 1 new message. '/msg lambdabot @messages' to read it.
04:20:44 <bitonic> TEttinger: then I'm not sure. base and haskell98 have conflicting namespaces... I'm not aware of a way of resolving that that doesn't involvee choosing one of the two
04:21:06 <ibid> i made a patch to bnfc to fix all that nonsense recently
04:21:18 <ibid> sent to upstream but theey haven't released a new version yet
04:21:25 <ibid> it's in the debian package
04:22:05 <TEttinger> ibid, so if I get BNFC from SVN... I will have acronym overload?
04:22:07 <ibid> see http://patch-tracker.debian.org/patch/series/view/bnfc/2.4.2.0-2/remove-haskell98.patch
04:22:21 <ibid> TEttinger: i don't know bnfc's SVN
04:23:07 <ibid> see also http://patch-tracker.debian.org/package/bnfc/2.4.2.0-2
04:23:21 <ibid> there are some other patches there that may be relevant
04:24:29 <ibid> took me a week's worth of free time to get that done :)
04:24:35 <TEttinger> ibid: is it a good project for me to work with?
04:24:54 <ibid> but what can you do when there's an FTBFS bug open against the package :-)
04:25:38 <ibid> TEttinger: bnfc upstream? they release slowly and so far as i know do not publish a version control repo.  so that's a downside.  however, they are receptive to ideas and patches
04:26:12 <TEttinger> http://bnfc.digitalgrammars.com/#repo
04:26:36 <ibid> ah. add another point against: they don't communicate very well :)
04:26:51 <ibid> never told me about that, even though ive been i contact with them occasionally
04:26:57 <ibid> (most recently about that patch series)
04:27:09 <TEttinger> they added the repo a month ago
04:28:23 <TEttinger> yes! it works!  and they included your patch I think!
04:31:33 <ibid> cool :)
04:31:49 <ibid> they never told me about the list
04:32:11 <TEttinger> ibid, so I am still not quite clear on what BNFC does
04:32:11 <ibid> at the time i was working on packaging the current version, their web site was down and there was no indcation of a new one
04:32:26 <ibid> TEttinger: it's a parser generator, sort of
04:32:28 <TEttinger> I wanted to play with it, obviously harder than I thought
04:34:11 <ibid> TEttinger: you give it a grammar in its idiosyncratic notation (based on BNF)
04:34:20 <ibid> TEttinger: it then generates a number of things:
04:34:49 <ibid> TEttinger: a parser description for a more conventional parser generator, equipped to build an AST of the parsed input
04:35:16 <ibid> TEttinger: a pretty printer that converts such an AST back to the original language
04:35:30 <ibid> TEttinger: and support code, including skeletons for processing the AST
04:35:56 <TEttinger> wow, sounds handy
04:36:47 <ibid> TEttinger: you can choose the target language (several variants of haskell, C++, Java and at least one for C and C#, and i think there's also O'Caml support)
04:42:19 <ibid> but yeah, mailing list and a public version control system are a major improvement :)
04:42:54 <Lemon> how big is too big for a Haskell module?
04:43:02 <Lemon> I'm at around 400 lines
04:43:13 <Lemon> with like
04:43:17 <Lemon> several dozen functions
04:43:31 <ibid> i don't think there's a lines-of-code limit
04:44:00 <ibid> it's too big when it's so large as to be hard to take in and understand as an API
04:44:08 <ibid> IMO
05:17:23 <srhb> http://hpaste.org/70113 <-- does anyone know how to fix this? I'm not sure which package it is really complaining about.
05:25:34 <KSkrzet> srhb: from what I see the http-conduit is fixed on newer version of attoparsec than newest yesod-platform
05:26:10 <KSkrzet> srhb: I would try fixing that by creating new local version of yesod-platform with bumped requirements on attoparsec
05:26:40 <KSkrzet> srhb: or by simply rejecting yesod-platform dependcy altogether, as I dont think it buys you anything
05:26:50 <srhb> How do I go about that?
05:27:03 <KSkrzet> srhb: which part?
05:27:21 <srhb> Either really. How do I reject the yesod-platform dependency? Just in my yesod test app's cabal file?
05:27:41 <KSkrzet> Yeah, by reject i mean remove it from your app's .cabal file
05:27:49 <srhb> Alright, I'll have a go at that. Thanks.
05:30:50 <jaxtr> ahh it's a wonderful day
05:31:54 <Snyp> both in #math and #haskell
05:54:18 <MagneticDuck> yo there everyone
05:54:36 <MagneticDuck> is there any function like "words" but that splits on any element of a list instead of just ' '?
05:55:07 <KSkrzet> see split library
05:55:11 <KSkrzet> http://hackage.haskell.org/package/split
05:55:58 <fmap> > map (:[]) "words words"
05:56:00 <lambdabot>   ["w","o","r","d","s"," ","w","o","r","d","s"]
05:57:00 <MagneticDuck> no, I mean that "split" works like: split 5 [1, 2, 3, 4, 5, 6, 7, 8] == [[1, 2, 3, 4], [6, 7, 8]]
05:57:23 <srhb> splitEvery?
05:57:46 <srhb> > splitEvery 3 "Foobarbaz"
05:57:47 <lambdabot>   Not in scope: `splitEvery'
05:57:49 <srhb> Baw
05:58:10 <srhb> MagneticDuck: It's in the package KSkrzet linked.
05:58:11 <MagneticDuck> splitOn
05:58:20 <MagneticDuck> I installed it and tested it
05:58:23 <MagneticDuck> all working
05:58:23 <MagneticDuck> yt
05:58:25 <MagneticDuck> *ty
06:01:36 <nand`> fmap: technically it would be const []
06:01:45 <nand`> > word "                      "
06:01:46 <lambdabot>   Not in scope: `word'
06:01:47 <nand`> > words "                      "
06:01:48 <lambdabot>   []
06:03:01 <fmap> nand`: do you mean map (const [])?
06:03:18 <nand`> no
06:03:31 <srhb> Aren't they exactly equivalent?
06:03:58 <nand`> “like words but splits on any element” -> words . fmap (const ' ') = const []
06:04:08 <srhb> oh.
06:05:26 * hackagebot QuickCheck 2.5 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.5 (NickSmallbone)
06:05:48 <fmap> don't get it. for me "split on any element" is either `map (:[])' or `map (const []'
06:06:09 <fmap> but i guess MagneticDuck meant something different entirely
06:06:13 <nand`> yeah
06:06:25 <nand`> the thing is just that words gets rid of the separators
06:06:28 <LambdaDusk> Can someone quickly tell me what the ~ in pattern matching does?
06:06:33 <nand`> so if any element is the separator, you end up with an empty list
06:06:40 <fmap> ah, sure
06:07:05 <bitonic> LambdaDusk: it always matches, and actually forces the constructor when needed
06:07:16 <bitonic> also called "lazy pattern matching"
06:07:19 <nand`> it's a bit silly since const [] is most definitely not what MagneticDuck wanted either way :P
06:07:25 <LambdaDusk> bitonic: Always matches?
06:07:52 <nand`> the terminology is “irrefutable pattern match”
06:08:37 <nand`> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
06:08:39 <bitonic> LambdaDusk: yeah, always matches
06:08:57 <nand`> LambdaDusk: the match always succeeds, but using the value may be problematic
06:09:01 <bitonic> in function cases
06:09:17 <LambdaDusk> Sounds... dangerous, why would anyone want that?
06:09:23 <nand`> laziness
06:09:26 <ppseafield> LambdaDusk: http://www.haskell.org/tutorial/patterns.html - 4.4 Lazy Patterns
06:10:23 <bitonic> LambdaDusk: you usually use it when you only have one constructor anyway - e.g. tuples.
06:10:34 <nand`> I think it goes something like this: you want to match a type that has only one constructor (like (,)), but you may not need the value in the function body
06:10:58 <nand`> but if that argument is _|_, the entire pattern match is still _|_ as a result since you have to evaluate the constructor
06:10:59 <nand`> something like that
06:11:29 <LambdaDusk> Oh so like "neg (x,y) = (-x,-y)" and I can put a ~ in front so the x and y stay unevaluated?
06:11:42 <nand`> > let ((x, _), (_, _)) = ((1, 2), undefined) in x
06:11:43 <lambdabot>   *Exception: Prelude.undefined
06:11:44 <nand`> > let ((x, _), ~(_, _)) = ((1, 2), undefined) in x
06:11:45 <lambdabot>   1
06:11:47 <bitonic> LambdaDusk: the x and y would stay unavaluated anyway
06:11:49 <linduxed> hey guys, i've got this ugly piece of code, and i'd like to ask you guys how i could make it cleaner https://gist.github.com/2948280
06:12:04 <bitonic> LambdaDusk: but the constructor wouldn't
06:12:21 <linduxed> most importantly, i'd like to fix the TODO online 76
06:12:26 <linduxed> but i don't know how
06:12:30 <LambdaDusk> uh ok...
06:12:57 <bitonic> @where whnf
06:12:58 <lambdabot> I know nothing about whnf.
06:13:04 <bitonic> @google whnf haskell wiki
06:13:07 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Laziness
06:13:07 <lambdabot> Title: Haskell/Laziness - Wikibooks, open books for an open world
06:13:20 <bitonic> @google weak head normal form haskell wiki
06:13:23 <lambdabot> http://www.haskell.org/haskellwiki/Weak_head_normal_form
06:13:23 <lambdabot> Title: Weak head normal form - HaskellWiki
06:13:47 <LambdaDusk> ah
06:13:53 <bitonic> LambdaDusk: when matching, haskell only forces what's necessary - that is, the constructor
06:14:04 <ehamberg> linduxed: hlint is a good start. it won't help to restructure your logic though. :)
06:14:11 <LambdaDusk> and when does that make an actual difference...?
06:14:38 <bitonic> > (\(_,_) -> 1) (undefined, undefined)
06:14:39 <lambdabot>   1
06:14:44 <bitonic> > (\(_,_) -> 1) undefined
06:14:46 <lambdabot>   *Exception: Prelude.undefined
06:15:16 <linduxed> ehamberg: well, it's the logic that's my main problem
06:15:29 <bitonic> LambdaDusk: `seq' evaluates the constructor only too. If a value is evaluated up to the constructor, that's called "weak head normal form"
06:15:50 <nand`> > (\((x, y), ~(z, _) -> if x > 0 then y else z) ((1, 2), undefined)
06:15:51 <lambdabot>   <no location info>: Parse error in pattern
06:15:57 <nand`> > (\((x, y), ~(z, _)) -> if x > 0 then y else z) ((1, 2), undefined)
06:15:58 <lambdabot>   2
06:16:04 <nand`> > (\((x, y), ~(z, _)) -> if x > 0 then y else z) ((-1, 2), undefined)
06:16:04 <linduxed> ehamberg: i have no idea how to do what i intend to without a loop, doing the same thing as every other loop, for each returned variable
06:16:04 <lambdabot>   *Exception: Prelude.undefined
06:16:22 <LambdaDusk> nand`, bitonic: Many thanks, now I get it.
06:17:15 <nand`> > (\(Left e) -> e) (Right 3)
06:17:16 <lambdabot>   *Exception: <interactive>:3:1-14: Non-exhaustive patterns in lambda
06:17:22 <nand`> > (\~(Left e) -> e) (Right 3)
06:17:23 <lambdabot>   <no location info>: parse error on input `->'
06:17:27 <nand`> hmm
06:18:28 <srhb> > (\(~(Left e)) -> e) (Right 3)
06:18:29 <lambdabot>   *Exception: <interactive>:3:1-17: Irrefutable pattern failed for pattern (D...
06:18:35 <srhb> Quirky syntax.
06:18:39 <nand`> ah
06:18:42 <bitonic> > (\ ~(Left e) -> e) (Right 3)
06:18:44 <lambdabot>   *Exception: <interactive>:3:1-16: Irrefutable pattern failed for pattern (D...
06:18:44 <nand`> also, let bindings are irrefutable by default
06:18:49 <srhb> Ah
06:18:51 <nand`> > let Left e = Right 3 in e
06:18:52 <lambdabot>   *Exception: <interactive>:3:4-19: Irrefutable pattern failed for pattern Da...
06:18:57 <nand`> > let Left e = Right 3 in 4
06:18:58 <lambdabot>   4
06:19:28 <LambdaDusk> Haskell - the language for intellectuals
06:19:40 <nand`> Haskell - the language for programmers
06:19:42 <bitonic> LambdaDusk: nah
06:19:48 <bitonic> I hate that reputation
06:20:09 <nand`> Haskell isn't designed for intellectuals. Intellectuals just use it because it's good :P
06:20:24 <nand`> “Haskell was designed for human beings” (-Not an actual quote)
06:20:27 * hackagebot HaXml 1.23.2 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.23.2 (MalcolmWallace)
06:20:29 <bitonic> Haskell: the language where things kind of make sense
06:20:36 <LambdaDusk> "Haskell - your CS degree won't help you!"
06:20:52 <nand`> I think that goes for all languages except Java
06:21:01 <srhb> What, CS will help with Java?
06:21:10 <nand`> isn't that what CS students do all day long?
06:21:15 <bitonic> LambdaDusk: I was thought Haskell on the first day of uni
06:21:15 <nand`> learn OOP and UML
06:21:22 <srhb> Ew, no.. <_<
06:21:27 <LambdaDusk> You can easily identify Java programmers by the desk edge imprinted on their foreheads
06:21:29 <bitonic> nand`: luckily no
06:21:36 <srhb> First course = Standard ML.
06:21:40 <Saizan> i can attest to the existence of "Java Schools"
06:21:45 <srhb> Everyone hates the one OO course and shun it henceforth.
06:21:50 <nand`> nice
06:22:04 <nand`> OOP is silly :(
06:22:04 <tzxn3> I really still don't understand how anyone could write useful software in Hasekll
06:22:07 <tzxn3> :P
06:22:10 <tzxn3> *Hakell
06:22:10 <tzxn3> *Haskell
06:22:15 <srhb> Yeah, OOP doesn't really do what it promises.
06:22:17 <nand`> I really still don't understand how anyone could write useful software in languages other than Haskell
06:22:17 <LambdaDusk> we had Java first, then Prolog, then Haskell
06:22:25 <LambdaDusk> It was like someone pulled me out of hell
06:22:26 <bitonic> srhb: agreed. and the "software engineering methodology" course or whatever is the only mandatory one in 3rd year, lol
06:22:31 <nand`> I mean, nothing makes sense
06:22:38 <ocharles> nand`: +1
06:22:40 <bitonic> I hate the Java bashing too. It's not that bad
06:22:52 <tzxn3> I don't like the lack of mutable data structures at all
06:22:52 <LambdaDusk> Scala is Java the right way
06:22:53 * t7 tries to think of something useful written in haskell... (excluding ghc)
06:22:55 <srhb> bitonic: Yes, that one I liked even though there was a lot of UML and "stuffing things into OOP boxes"
06:22:59 <ocharles> it's not awful, but there is accidental complexity you just don't have in Haskell
06:23:01 <bitonic> nand`: that's naive. most useful software is not in Haskell
06:23:13 <ocharles> bitonic: I have a feeling nand` was not being literal
06:23:28 <nand`> Haskell was not my first language either; it just looks so strange looking back
06:23:31 <tzxn3> and there aren't any good examples of how to do things that use mutable data structures well in Haskell
06:23:37 <bitonic> ocharles: well then I don't know what he meant
06:24:04 <nand`> bitonic: like, I go back to impure/OOP/impertive languages now and wonder how I was ever able to use them
06:24:11 <t7> tzxn3: use the state monad. next!
06:24:28 <bitonic> nand`: really? I never felt like that
06:24:35 <nand`> tzxn3: easy, you just encapsulate all of the mutation inside the IO monad an-- wait, why are you pulling out bats?
06:24:45 <t7> nand`: as someone who is implementing the lambda calculus in C++ i agree 100%
06:25:09 <t7> abstract class for terms :(
06:25:11 <bitonic> I could agree on the OOP, but impurity and imperativeness certainly have their places in my brain
06:25:13 <nand`> bitonic: maybe it has something to do with the fact that I'm less of a “right tool for the job” and more like a “stark raving mad fanboy” type of guy
06:25:16 <t7> 200 LOC
06:25:21 <ocharles> tzxn3: decide what you want to write, there is usually good enough examples that you can learn from
06:25:43 <srhb> nand`: No I'm sure that has _nothing_ to do with it.
06:25:44 <srhb> :-)
06:25:48 <ocharles> yes, it's a large paradigm shift, but I think haskell is out and about in the real world enough now for there to be good examples to learn from
06:25:51 <bitonic> nand`: mah I'm pretty ideological as well, but I can see where I'd like to use C/C++, or Erlang, or scheme
06:26:01 <bitonic> (note the C/C++)
06:26:08 <bitonic> to throw some nonsense in.
06:26:11 <ocharles> command line apps like hledger, xmonad, various snap/yesod applications for web stuff, etc
06:26:14 <LambdaDusk> but we can all agree that PHP is a horrid abomination that deserves to be ended, right?
06:26:19 <bitonic> Java/JavaScript
06:26:27 <tzxn3> most code I try to read is just over my head
06:26:30 <nand`> bitonic: I can see where I'd use the state monad and imperative-style algorithms too. It's just very remote from C/C++/friends for me
06:26:52 <tzxn3> I don't understand it at all
06:27:07 <srhb> tzxn3: It gets better :-)
06:27:12 <bitonic> nand`: the State monad is not "imperative" at all, it's sugar for `s -> (s, a)'
06:27:19 <nand`> it's like all of the *benefits* of imperative coding are now encapsulated inside pure methodologies, so the only advantages the “ye olde” imperative languages have compared to that is, well, the ability to shoot yourself in the foot
06:27:25 <Saizan> tzxn3: tried going through RWH? it has a bunch of worked examples that should help with learning to read haskell
06:27:30 <nand`> bitonic: the state monad can be used for imperative algorithms
06:27:32 <tzxn3> I'm going to do all the exercises in SICP over the next few months
06:28:21 <merijn> nand`: Sure, but true imperative-ness is more like being in IO and using IORef's for everything :p
06:28:24 <bitonic> nand`: mah. purity is great, absolutely great, don't get me wrong. but I've enjoyed writing clean code in a lot of impure langs :P
06:28:29 <nand`> ignoring exceptions and concurrency, that's essentially what every line of imperative code does: modify an environment, potentially bind a value
06:28:41 <bitonic> nand`: ...IO?
06:29:27 <LambdaDusk> bitonic: I once read that the IO monad should be "split" so you can have more control...
06:29:29 <nand`> bitonic: I was mainly talking about imperative algorithms, not necessarily ones that perform IO. Even so, StateT s IO
06:29:40 <bitonic> I really would not call the State monad "imperative". I'm more with merijn on this
06:30:03 <bitonic> nand`: whatever, it's just terminology anyway
06:30:05 <nand`> merijn: true imperative-ness is https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs :P
06:30:08 <nand`> bitonic: yeah
06:30:27 <nand`> I could try being more concrete: for example, a physical simulation that uses a state monad containing a collection of particles that get simulated in time
06:30:36 <nand`> (not saying it's very efficient, but it's doable)
06:30:54 <bitonic> nand`: but there are certain things that you can't emulate so easily, e.g. getting some memory and addressing it, which impacts performance considerably
06:31:05 <Saizan> it's all about which abstraction you have in mind when you use any particular API
06:31:11 <nand`> absolutely. I see the appeal of C where you need better memory management
06:31:18 <nand`> not my domain :P
06:32:10 <bitonic> but you can and we have built abstraction over those things too. but an aweful lot of Haskell programs would not be possible without `unsafePerformIO' somewhere
06:32:20 <bitonic> see ByteString, for example
06:34:00 <Saizan> btw, i can't understand how people can write code which isn't also its own correctness proof
06:34:21 <nand`> proofs in Haskell are not entirely non-trivial, due to the presence of ⊥
06:34:56 <nand`> or did you mean in general?
06:35:02 <nand`> (not necessarily via curry-howard)
06:35:05 <Saizan> yeah, i haven't been writing much haskell lately :)
06:35:07 <bitonic> I hope he was joking
06:35:14 <bitonic> but he's Saizan so :)
06:35:17 <nand`> you never know
06:35:29 <Saizan> half and half :P
06:36:45 <bitonic> I got to the point I actually can write programs in Agda but then I ran out of things to do. My usual learning programs are too impractical in Agda. which sucks
06:36:56 <nand`> I got to the point where I can actually input Agda syntax
06:37:39 <bitonic> nand`: that's something :)
06:37:55 <nand`> yes :)
06:38:20 <nand`> on the plus side, I now have ∀ etc. on my keyboard which is useful for more than just Agda
06:39:36 <Botje> spotting idiots who complain that your A is upside down? :)
06:39:53 <nand`> I try not to use it out of context
06:40:04 <nand`> ie. with people who will know what it means
06:40:21 <bitonic> politically correct functional programmer
06:40:32 <nand`> absolutely
06:40:44 <nand`> on the other hand, it makes me want to try out -XUnicodeSyntax
06:41:00 <bitonic> I stopped using unicode when I disabled antialiasing globally
06:41:04 <bitonic> what a great day that was
06:41:13 <nand`> I have anti-aliasing disabled as well
06:41:20 <bitonic> nand`: what font do you use?
06:41:27 <nand`> bitonic: mixture of terminus and unifont
06:41:35 <nand`> it's all pixel fonts
06:41:40 <bitonic> wait let's move it to blah
06:51:11 <geoid> greetz
06:51:17 <byorgey> hi geoid
06:55:49 <ehamberg> nand`: using the compose key?
06:56:39 <ehamberg> using a compose key is great :-) ∀ ∃ ≠ ≡ ⇒ → ∷
06:56:54 <nand`> ehamberg: nah, I have them all mapped
07:03:13 <KSkrzet> haddock chokes on my quasi quotes... any way to workaround that issue?
07:05:33 <bas_> is there a way to write (if x then apply f to) y -- so that if x is False, y is returned unaltered?
07:05:35 <hpaste> MagneticDuck pasted “monad twoble!” at http://hpaste.org/70117
07:05:43 <MagneticDuck> yo guys... I'm having a bit of trouble
07:05:58 <MagneticDuck> I'm copying the error
07:06:11 <flux> :t const
07:06:12 <lambdabot> forall a b. a -> b -> a
07:06:15 <bas_> instead of having to write something like if x then f y else y
07:06:22 <flux> actually no
07:06:28 <flux> :t identity
07:06:29 <lambdabot> Not in scope: `identity'
07:06:36 <flux> oh, it must've have a name..
07:06:37 <hpaste> MagneticDuck annotated “monad twoble!” with “monad twoble! (annotation)” at http://hpaste.org/70117#a70118
07:06:39 <bas_> :t id
07:06:41 <lambdabot> forall a. a -> a
07:07:10 <bas_> but somehow there must be a way to write "if x then f y else y" more elegantly :[]
07:07:20 <linduxed> i was wondering if there's a way to avoid using multiples of pretty much the same loop in the function that starts on line 78 here https://gist.github.com/2948280
07:07:31 <rwbarton> so you can write (if x then f else id) y
07:07:37 <rwbarton> I don't know whether this is an improvement
07:07:44 <MagneticDuck> okay so here's the basic problem: I have a result in IO and I need to use that value to make a "Net" monad...
07:07:45 <bas_> seems less clear
07:07:46 <flux> bas_, (if x then apply f to else id) y ?
07:07:47 <MagneticDuck> I'm fairly new
07:08:03 <linduxed> basically i've got multiples of the same loop because the top one needs to cons together a list of Pot
07:08:14 <bas_> you're probably right that id is the only way to not have to write it
07:08:18 <linduxed> the other loops basically end up with a single value
07:08:36 <flux> bas_, I don't think that the situation doesn't come up as often you think it does ;)
07:08:45 <flux> oops, double negation. time to go home perhaps.
07:09:04 <linduxed> so i don't know how i could do it all in one loop (since they get different return values, get a result at different times...)
07:09:16 <bas_> flux you're probably right
07:09:29 <bas_> and it might be an indication of some other flaw in my program's structure
07:09:49 <flux> bas_, if it does appear often in your program, maybe you can write your own function for that
07:09:51 <linduxed> i'm just concerned about the fact that it looks like the main work in the program is done four time more
07:09:59 <linduxed> *times
07:10:12 <bas_> yeah flux, cheers
07:10:21 <MagneticDuck> here's my problem: I have a function that returns "IO a" and I need to use that value a to make another monad. I have a function "a -> M". I'm probably a tad tired or something, and I'm also new to haskell. Help anyone?
07:10:40 <fmap> liftIO?
07:10:50 <MagneticDuck> ..hm..
07:10:52 <rwbarton> liftM?
07:10:55 <MagneticDuck> M contains IO of course
07:10:59 <MagneticDuck> hm
07:11:14 <rwbarton> (>>=)??
07:11:21 <MagneticDuck> ..no
07:11:42 <rwbarton> Your question is pretty hard to understand.
07:11:50 <fmap> @hoogle IO a -> m a
07:11:51 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
07:11:51 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
07:11:51 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
07:11:58 <MagneticDuck> because I have "IO a" and "a -> M" where M in a reader monad that contains IO, and I want to get M
07:12:15 <MagneticDuck> Okay I'll fool around with liftIO
07:12:21 <MagneticDuck> sorry if my question was malformed
07:12:31 <MagneticDuck> I'm fairly new especially to this part of haskell
07:12:41 <Botje> MagneticDuck: it takes a while for your brain to settle, don't worry :)
07:12:52 <fmap> maybe second function if f :: a -> M b
07:12:53 <fmap> ?
07:12:56 <fmap> is*
07:13:16 <MagneticDuck> look at the code if you're having trouble understanding my malformed ramblings
07:13:25 <MagneticDuck> I hpasted it a little bit back
07:13:27 <MagneticDuck> with the error
07:14:06 <fmap> i don't see types neither for `netAction' not 'findAction'
07:14:10 <fmap> nor*
07:14:31 <MagneticDuck> netAction is defined in the let
07:14:54 <MagneticDuck> and findAction :: FilePath -> String -> IO BotAction
07:15:01 <MagneticDuck> I'll get the type for BotAction
07:15:02 <zzing> I want to make a utility that would operate with commands passed to it like "user add [name] [uid]" which would probably use something like parsec to parse the command line and be able to provide error reporting if it expected a number and got something else. Can anyone think of a small program that already does something like this to get me started?
07:15:26 <MagneticDuck> data BotAction = Speaks String | Silence | Quits
07:15:29 <bitonic> zzing: you can use cmdargs
07:15:40 <srhb> MagneticDuck: So the type of eval is a lie..
07:15:43 <bitonic> @hoogle CmdArgs
07:15:43 <lambdabot> package cmdargs
07:15:50 <rwbarton> so it looks like you want to liftIO (findAction "personality.txt" str) and then use (>>=)
07:15:55 <bitonic> @hackage CmdArgs
07:15:55 <lambdabot> http://hackage.haskell.org/package/CmdArgs
07:15:56 <fmap> then probably liftIO (findAction ...) >>= netAction
07:15:58 <MagneticDuck> basically I have a personality file, a string the user says, and then a type that defines what the bot does
07:16:22 <rwbarton> alternatively, do-notation would be more straightforward
07:16:36 <rwbarton> do { botAction <- liftIO (findAction ...); case botAction of { ... } }
07:16:50 <MagneticDuck> srhb: I just want to call netAction with what's in the IO of findAction!!!!
07:16:59 <MagneticDuck> oh
07:17:35 <zzing> bitonic, that looks like something more in the realm of -h or --help style arguments is that correct? I am doing something closer to what diskutil does on the mac.
07:18:31 <Botje> zzing: you probably want a basic tokenizer plus some validation functions
07:18:32 <bitonic> zzing: yes, it is something like that. I don't know what diskutil is
07:19:16 <zzing> eg: diskutil eraseDisk format name [[APM]Format|[MBR]Format|[GPT]Format] MountPoint|DiskIdentifier|DeviceNode
07:19:27 <Botje> zzing: once you split your input into words, you can implement the commands like ...
07:19:28 <zzing> It looks more like you are giving instruction in english rather than crypticness
07:19:49 <Botje> processCommand ("user":"add":args) = case args of ...;
07:20:12 <zzing> Would it mak sense to use parsec?
07:20:50 <Botje> are you going to processing something more difficult than words?
07:20:54 <Botje> quoted expressions and the like?
07:21:13 <zzing> It is likely I will have numbers, strings, and quoted stuff yes
07:21:25 <Botje> then go wild with parsec
07:21:29 <bitonic> Botje: quoted expression will be handled by getArgs
07:21:33 <bitonic> well. by the shell
07:21:51 <Botje> bitonic: I understood that zzing wanted an interactive shell
07:21:58 <geoid> I'm a complete n00b to Haskell. Just got here via tryhaskell.org
07:22:07 <zzing> Botje, I am actually going for both
07:22:33 <zenzike> geoid: welcome :-)
07:22:33 <bitonic> geoid: that's the first step to world domination
07:22:37 <geoid> I'm wondering why I would want to use Haskell? What is it better at than other languages? I mean in practical terms, not theoretical terms.
07:22:59 <zzing> geoid, it is a tool in your toolbox.
07:23:29 <bitonic> geoid: you have much stronger guarantees about your programs. concurrency is much simpler. one of the best compilers on the market. very active and friendly community. will teach you things that no other language will.
07:23:30 <geoid> I notice it has an efficient syntax.. but I can't think of a use for this tool, other than preventing my toolbox from closing :p
07:23:36 <Botje> zzing: then you probably want to normalize your input into split words first
07:23:43 <Eduard_Munteanu> Hah.
07:24:19 <Botje> geoid: learn haskell and you'll wonder how you ever got by with for loops and Java-like type systems.
07:24:46 <zzing> geoid, I am writing a website and system management tool both in haskell. I want the static guarantees that are provided.
07:24:54 <geoid> So, it's a compiled language?
07:24:56 <zzing> Laziness can be a problem if you are not used to it
07:24:58 <zzing> Very much so
07:25:05 <zzing> geoid, what other tools are in your toolbox?
07:25:12 <bitonic> geoid: you have both compilers and interpreters available
07:25:30 <bitonic> geoid: no language is inherently compiled/interpreted :)
07:25:39 <shapr> Goood morning #haskell !
07:25:49 <zzing> bitonic, C++ - find an interpreted version of that
07:25:51 <bitonic> shapr: morning
07:25:53 <geoid> I'm coming from PHP and Javascript - the web world. I've done a touch of .net via Unity both in UnityScript and C# flavours.
07:26:02 <shapr> howdy bitonic !
07:26:04 <bitonic> zzing: nothing prevents you from doing that
07:26:15 <zzing> The two biggest tools in my toolbox are C++ and Haskell. I believe them to be the best languages for doing most things.
07:26:16 <bitonic> @time shapr
07:26:17 <lambdabot> Local time for shapr is Mon Jun 18 09:25:56 2012
07:26:30 <Tinned_Tuna> zzing: Just because no one's done it, doesn't make it impossible ;-)
07:26:33 <zzing> geoid, Have you ever had a program crash due to types?
07:26:49 <Eduard_Munteanu> @remember geoid <geoid> I'm wondering why I would want to use Haskell? [...]  <zzing> geoid, it is a tool in your toolbox.  <geoid> I notice it has an efficient syntax.. but I can't think of a use for this tool, other than preventing my toolbox from closing :p
07:26:50 <lambdabot> It is forever etched in my memory.
07:27:01 <zzing> Expecting an integer, but you passed in a string
07:27:01 <bitonic> zzing: you mean due to type errors?
07:27:04 <geoid> @zzing no. I've had it not compile due to types in C#
07:27:04 <lambdabot> pong
07:27:17 <rwbarton> lambdabot: Pong to you too.
07:27:27 <zzing> geoid, static compiling saved you a lot of trouble in that instance
07:27:32 <zzing> bitonic, yep
07:27:44 <zzing> Eduard_Munteanu, I am immortal now?
07:27:50 <geoid> yes true.. although it caused my fingers to bleed from all the non DRY code I had to type :D
07:27:51 * zzing takes out his sword.
07:27:51 <Eduard_Munteanu> Yes :P
07:27:53 <bitonic> @quote zzing
07:27:54 <lambdabot> geoid says: <geoid> I'm wondering why I would want to use Haskell? [...]  <zzing> geoid, it is a tool in your toolbox.  <geoid> I notice it has an efficient syntax.. but I can't think of a use for
07:27:54 <lambdabot> this tool, other than preventing my toolbox from closing :p
07:27:58 <zzing> There can be only one.
07:28:03 <bitonic> @quote bitonic
07:28:03 <lambdabot> No quotes match. :(
07:28:06 <bitonic> :(
07:28:11 <bitonic> @quote rostayob
07:28:12 <lambdabot> rostayob says: I was a type constructor, then I took an arrow in the kind
07:28:14 <Eduard_Munteanu> @karma bitonic
07:28:15 <lambdabot> bitonic has a karma of 1
07:28:18 <Eduard_Munteanu> There you go :)
07:28:18 <bitonic> lol.
07:28:21 <Tinned_Tuna> oh god.
07:28:28 <zzing> geoid, what is this DRY thing?
07:28:42 <geoid> Dont Repeat Yourself = DRY
07:28:59 <zzing> That isn't C# - that is Microsoft's APIs
07:29:05 <zzing> Haskell is a king at that
07:29:25 <zzing> (avoiding it)
07:29:52 <flux> zzing, btw, c++ interpreter does exist: CINT. also, there's geordi, which is cheating the same way as lambdabot is.
07:30:15 <geoid> so what in the web-world could I do with Haskell that would make me go "Oooo!"?
07:30:26 <Tinned_Tuna> geoid: that's a SOLID acronym right there.
07:30:46 <Eduard_Munteanu> Why bother with a C++ interpreter? :/
07:30:51 <shapr> geoid: http://clckwrks.com/ ?
07:31:01 <Eduard_Munteanu> It's not like the language is suitable for a REPL or such stuff.
07:31:09 <Eduard_Munteanu> Or maybe it is, I don't know.
07:31:17 <Nimatek> Lazy programming is great for mathematicians. You prove that the required program can be written, but leave the actual programming to someone else.
07:31:19 <flux> eduard_munteanu, I suppose it could be nice for one-off tests of code or something. like in haskell or ocaml.
07:31:19 <zzing> Eduard_Munteanu, it looks like it only does '85%' of C++, which I bet is much smaller with the new standard :P
07:31:30 <rwbarton> "In addition to being a language interpreter, it offers certain bash-like shell features such as history and tab-completion."
07:31:46 <rwbarton> So I guess it has a REPL
07:32:05 <Eduard_Munteanu> I use gdb as a C repl :P{
07:33:16 <Eduard_Munteanu> > print foo(2,3)    :)
07:33:18 <lambdabot>   <no location info>: parse error on input `)'
07:33:59 <bitonic> doesn't LLVM give some facility to write interpreters? then you could probably build an interpreter via clang
07:34:29 <ski> bitonic : .. i would call the `State s' monad "imperative" :)
07:34:43 <flux> I suppose it does facilitate it, given you are probably able to modify the list of global types, variables and functions on the fly
07:34:56 <Eduard_Munteanu> Even gcc might, though gcc is notoriously weird to interface to.
07:35:32 <rwbarton> geoid: you might be interested in http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem
07:35:49 <Eduard_Munteanu> (Actually, that's one thing LLVM's got an upper hand on gcc)
07:35:59 <bitonic> ski: gravedigger!
07:36:32 <bitonic> ski: or is it somewhat related to the current discussion?
07:36:45 <ski> nah, just looking over scrollback
07:36:57 <Eduard_Munteanu> Or necromancer :D
07:37:06 <Eduard_Munteanu> IIRC, that's an SO thing.
07:37:10 <bitonic> ski: in that case, you're wrong :)
07:37:20 <ski> why ?
07:37:52 <ski> you need an "imperative mindset" when using `State s', i.e. you need to think about the "current state" at at which time in the computation you access and modify the state
07:38:05 <bitonic> no, I'm joking. but I think it's a pretty sterile argument on what "imperative" means
07:38:40 <ski> yes, there's more to imperative, e.g. jumps, exceptions
07:38:50 <ski> but state is an important part of it
07:39:33 <ski> (whether the state is implemented by update-in-place or not is irrelevant)
07:39:38 <bitonic> ski: well but that's a very functional state. it's just sugar to help you thread a parameter in your functions
07:40:14 <bitonic> I'd think more about ST when talking about imperative state
07:41:21 <ski> yes, but this sugar is a large part of the essence of imperative state
07:41:43 <ski> the traditional imperative languages are "just" an efficient implementation of it
07:41:57 <ski> the point is that you have to employ the same kind of mindset to program in it
07:42:00 <bitonic> ski: uhm. again, to me imperative = IO, mutable references, exceptions, stuff like that.
07:42:20 <geoid> Thanks for the input guys. I've read the links and get the picture. I think it's all a bit advanced for me @ the mo.
07:42:34 <ski> (but yes, in `State s' you have a single (possibly composite) piece of state of type `s', while in `ST s' you can dynamically allocate new pieces of states of whatever type you like)
07:42:45 <Botje> geoid: eh, just dive in with 'learn you a haskell'
07:42:48 <rwbarton> if I write a BASIC interpreter in a pure functional language (without even using the m-word) and then I write a BASIC program in a string literal in that program, does that mean my BASIC program is suddenly "not imperative"
07:43:16 <ski> bitonic : yes, so then `Either MyException' should be imperative for you
07:43:19 <Eduard_Munteanu> Normally you should be able to do everything on top on Cont, no?
07:43:44 <bitonic> ski: no, not those exceptions. for me imperative is more about the "how" then about the "what"
07:43:44 <ski> (bitonic : or at least, some *uses* of it would be imperative to you)
07:44:21 <bitonic> ski: so instead using functions and datatype, you use IO exceptions, arrays, etc.
07:44:32 <ciaranm> if it's ugly, it's imperative. if it's incomprehensible, it's functional.
07:44:50 <ski> why do you care that much about the implementation ? -- the same mindset is used in any case, giving the same problems for reading, reasoning about and refactoring code
07:44:51 <silver> lol
07:45:09 <ski> @remember ciaranm if it's ugly, it's imperative. if it's incomprehensible, it's functional.
07:45:09 <lambdabot> Good to know.
07:45:24 <bitonic> ski: it does matter, because for example a stateful thing written with State will be much more composable then something in ST
07:46:00 <bitonic> and usually the code will be much clearer as well
07:46:28 <ski> bitonic : i suspect that to do that, you have to use `runState'
07:46:50 <bitonic> ski: well not if `State s a = s -> (s, a)'. but yes
07:47:16 <bitonic> ski: with ST there can't be a runST with similar type, if you want ST behaviour
07:47:18 <ski> (so i wonder how this comparision would fare if you used a unique state there, as in Clean or Mercury)
07:48:02 <ski> otherwise it seems to me `ST s' might be more composable in some cases, since you can compose two computations using different states easily
07:48:32 <bitonic> ski: well it's composable with other ST computations
07:49:15 <ski> (for clarity, i consider using `runState' above as a (possible) deviation from the imperative mindset i was talking about re `State s')
07:50:08 <bitonic> ski: in this discussion I was referring specifically `State s a = s -> (s, a)'
07:52:46 <rwbarton> sure, State s looks functional from "outside the monad" (like any monad except possibly IO) and imperative from "inside the monad"
07:53:21 <rwbarton> if you only ever look from outside the monad, you are missing one of the main points of monads IMO
07:54:15 <bitonic> rwbarton: I wasn't talking about monads in general, just about State
07:57:02 <Itkovian> shapr: would you be interested in porting this thing?
07:57:26 <Itkovian> it involves a lot of shell commands for building and installing stuff
07:58:12 <shapr> Itkovian: Probably not, but I wouldn't mind looking at the github repo.
07:58:29 <shapr> Itkovian: Could you link me?
07:58:40 <Itkovian> sure
07:59:00 <Itkovian> https://github.com/hpcugent/easybuild
08:00:31 * hackagebot xmlhtml 0.2.0.2 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.2.0.2 (DougBeardsley)
08:00:33 * hackagebot heist 0.8.1.1 - An (x)html templating system  http://hackage.haskell.org/package/heist-0.8.1.1 (DougBeardsley)
08:03:01 <shapr> Itkovian: That's not very complicated actually.
08:03:15 <Itkovian> I never said it was
08:03:28 <Itkovian> It's just that we need something everybody on the team knows
08:03:35 <Itkovian> and Haskell is not fitting that
08:03:37 <Itkovian> sadly
08:03:43 <shapr> That's too bad :-(
08:04:03 <Itkovian> Well, Python seems to be a step forward from Perl, so I'm not too unhappy
08:05:31 * hackagebot snap 0.9.0.1 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.9.0.1 (DougBeardsley)
08:05:37 <ski> bitonic : ok. i was really talking about what rwbarton was calling "looking at it from the inside of the `State s' monad"
08:06:10 <shapr> Itkovian: Porting EasyBuild to Haskell wouldn't be a huge PITA, I think the tools dir would be the most exciting part.
08:08:47 <shapr> Itkovian: How large is your team?
08:09:19 <Itkovian> 7 for maintaining 6 clusters and setting up a new one (#118 on the new top-500 list)
08:09:33 <shapr> wow!
08:09:41 <Itkovian> and we're still cleaning up from back when the lead was like the only guy
08:09:52 <Itkovian> so he did things fast to get it to work
08:10:02 <Itkovian> but not always as shiny as he'd want
08:10:09 <shapr> Eh, make it work first
08:10:14 <shapr> THEN make it pretty :-)
08:10:15 <nand`> anybody attempted to write a terminal emulator before using Graphics.UI.Gtk.Vte?
08:10:16 <Itkovian> idd
08:10:32 <Itkovian> so yeah, we have a ot of legacy that needs to be cleaned up
08:10:49 <Itkovian> the easybuild on githhub only has like a few libraries
08:10:54 <Itkovian> in total, we have 250+
08:10:59 <shapr> wow
08:11:10 <Itkovian> that need to be ported to the new version after boegel cleaned it up
08:12:15 <shapr> Itkovian: needs software tests :-)
08:12:30 <Itkovian> we have a pretty large regression suite
08:12:36 <shapr> Oh, separate repo?
08:12:44 <Itkovian> still in the old one afaik
08:12:51 <Itkovian> I just joined the team three months back
08:13:01 <Itkovian> and easybuild is not high on my to learn list
08:13:27 <Itkovian> I'm going to do the new machine support, scheduling policies, user support and such
08:13:33 <shapr> That's neat.
08:13:50 <shapr> Itkovian: Sound like a fun job
08:13:54 <Itkovian> it is
08:14:01 <Itkovian> a lot of new stuff for me too
08:14:45 <shapr> That's the best kind of job. My job is getting my Goole Summer of Code project finished!
08:14:55 <Itkovian> heh
08:15:03 <tac-tics> shapr: What's your project?
08:15:05 <Itkovian> sounds cool too, what was the subject?
08:15:38 <shapr> My project is an in-browser hpaste+ghci, with built-in chat.
08:16:23 <shapr> So it's a multi-user code editing component that loads into a multi-user ghci in another pane.
08:16:37 <tac-tics> shapr: for edumacational porpoises?
08:16:45 <tac-tics> neat idea
08:16:51 <shapr> The question was "What would make it easier to teach/debug code for people who just joined #haskell?"
08:16:59 <Itkovian> nice
08:17:12 <Itkovian> we used to have people just talk to lamdabot here
08:17:15 <shapr> So I figured, "mash up hpaste, lambdabot's mu-eval, ghci, and IRC".
08:17:35 <shapr> Itkovian: Right! But that's only good for one line at a time, you can't load files, and you can limit it to just a subset of the users.
08:17:45 <Itkovian> true
08:17:59 <Itkovian> but in those ten years the talk here has become quite advanced
08:18:08 <Itkovian> so another tool can really be useful
08:18:25 <shapr> So chrisdone wrote tryhaskell.org, and it sends code to the server to get eval'd and the result is returned.
08:18:40 <shapr> Itkovian: Yah, I think it will work out well.
08:19:02 <Itkovian> do you have some prototype?
08:19:05 <shapr> At the same time, shooting for ONLY an in-browser shared ghci is too wimpy.
08:19:43 <Itkovian> ah OpenMP … another no static check thingie
08:19:45 <shapr> I want to at least have basic support for returning browser-supported media like SVG. And I'd like to make it easy for someone else to add sound, video, or whatever.
08:20:00 <Itkovian> sounds like you have a lot on your plate
08:20:20 <shapr> Itkovian: Oh sure, I have several ugly prototypes, see the README on the front page: https://github.com/shapr/ghclive
08:21:53 <akosch> does using flymake (emacs) with Haskell make sense? the screenshots look neat, but is it fast enough? (that perl-voodoo on the emacs-wiki is making me avoid it, especially on windows)
08:22:32 <bitonic> akosch: it works very well, with ghc-mod at least
08:22:38 <bitonic> no perl voodoo.
08:23:44 <shapr> Apfelmus named this GSoC project "HyperHaskell - a Strongly Hyped Haskell Interpreter".
08:23:50 <MagneticDuck> doing more work on my "roboduck". I have a little question...
08:23:50 <akosch> bitonic: ghc-mod? I'm a bit new to emacs, how does ghc-mod relate to haskell-mode?
08:24:03 <srhb> shapr: ++ for that :P
08:24:14 <MagneticDuck> Is there any faster way to write this: (f a b = (g a) == (g b))
08:24:17 <shapr> apfelmus++ for that name :-)
08:24:23 <MagneticDuck> @type on
08:24:24 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:24:30 <shapr> game on!
08:24:55 <Botje> MagneticDuck: (==) `on` g
08:25:02 <Botje> or equating g, iirc
08:25:02 <MagneticDuck> aahh
08:25:20 <bitonic> akosch: it's a program that talks to the ghc-api to get nicer interaction with emacs. amongst the other thing it provides nice flymake for haskell. you use it with haskell mode
08:25:23 <Botje> not equating :[
08:25:50 <MagneticDuck> @src on
08:25:50 <lambdabot> (*) `on` f = \x y -> f x * f y
08:26:01 <MagneticDuck> ah okay
08:26:21 <MagneticDuck> I imagine the b is usually a monoid
08:26:39 <MagneticDuck> it's like mapping to a list where : is (*)
08:26:43 <MagneticDuck> ...kind of
08:26:53 <MagneticDuck> except that it gets evaluated of course
08:28:13 <akosch> bitonic: thanks, definitely checking it out. If I get this right I need to install ghc-mod from hackage, then the emacs frontend from github, right?
08:28:31 <bitonic> MagneticDuck: you mean ++, not :
08:28:51 <bitonic> akosch: the hackage package gets you the emacs files as well
08:29:01 <MagneticDuck> bitonic: Yeah that's right.
08:29:18 <bitonic> MagneticDuck: also, I don't see why you would restrict yourself to monoids :)
08:29:41 <bitonic> the type sig is more general
08:30:03 <bitonic> (`b -> b -> c' and not `b -> b -> b')
08:30:16 <MagneticDuck> sig?
08:30:20 <bitonic> signature
08:30:24 <MagneticDuck> oh
08:30:32 * hackagebot DataTreeView 0.1.1 - A GTK widget for displaying arbitrary Data.Data.Data instances  http://hackage.haskell.org/package/DataTreeView-0.1.1 (DanielSchuessler)
08:30:33 <MagneticDuck> well yeah
08:30:44 <MagneticDuck> I said "usually a monoid"
08:30:47 <akosch> bitonic: thanks, I just found the installation guide on this "adorable" site (mew.org)
08:31:02 <MagneticDuck> aaaww
08:31:07 <MagneticDuck> makes me want to use emacs
08:31:24 <MagneticDuck> I'm a vimmer
08:31:25 <bitonic> akosch: ehe. there's even an email client  named like that
08:32:05 <bitonic> in the great tradition of japanese emacs email clients.
08:32:08 <akosch> bitonic: I guess it's the same guy doing both :)
08:32:16 <bitonic> JEEC for short.
08:32:21 <bitonic> akosch: yep
08:35:33 * hackagebot HaXml 1.23.3 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.23.3 (MalcolmWallace)
09:00:34 * hackagebot yesod-vend 0.1 - Simple CRUD classes for easy view creation for Yesod  http://hackage.haskell.org/package/yesod-vend-0.1 (KrzysztofSkrzetnicki)
09:04:22 <importantshock> Perhaps someone wiser than me can shed light on this: when creating a newtype for a monad transformer, is it preferred to enable GeneralizedNewtypeDeriving and use the deriving clause to implement the required instances (MonadTrans, MonadReader, etc.), or to implement them manually?
09:04:40 <importantshock> (I am trying to create a monad transformer stack on top of conduit's ResourceT. The types are making me woozy.)
09:04:43 <ski> importantshock : the former, if possible
09:05:57 <ski> there's little point in attempting to define correct instances for `Monad',`MonadTrans',`MonadReader' (and mayhaps botching it up, introducing a bug) when you can get it for free with `GeneralizedNewtypeDeriving'
09:06:18 <ski> however, if you want to be portable, that's a valid reason for not using `GeneralizedNewtypeDeriving'
09:09:01 <xcvd> is a multi variable function truly functional?
09:09:42 <ski> what do you mean by "multi variable function" ?
09:09:57 <HugoDaniel> argghh
09:10:07 <HugoDaniel> how can i use Text as FilePath without unpacking strings ?
09:10:08 <HugoDaniel> :/
09:11:13 <fmap> there is Data.Text.IO
09:11:28 <xcvd> a function with more than one argument
09:12:00 <geekosaur> note that Text as FilePath is only reliable on Windows.  on POSIX systems there are potential issues
09:12:19 <HugoDaniel> oh ok
09:12:38 <barrucadu> xcvd: All functions only have one argument
09:12:40 <HugoDaniel> ill unpack then :(
09:13:06 <HugoDaniel> i thinking if it would be better to just call a bash script instead
09:13:22 <HugoDaniel> since text unpacking is involved in this
09:13:25 <ski> xcvd : if you type `myFunction x y = x*10 + y', then `myFunction' is really a function that takes an argument `x', and returns a new function which takes an argument `y' and returns `x*10 + y'
09:14:07 <hpaste> savask pasted “Read of different types” at http://hpaste.org/70120
09:14:20 <ski> xcvd : usually we gloss over this, and just say that `myFunction' is a function taking two arguments, `x' and `y', and returning `x*10 + y' -- but really, every Haskell function takes exactly one argument
09:15:01 <xcvd> yes
09:15:04 <xcvd> I know
09:15:33 <savask> Hello. One function accepts a list of any type ([a]), and I read input for that function from program arguments. How can I make it read _different_ types of arguments like strings, list of integers and so on? Here is my test code: http://hpaste.org/70120
09:15:35 <geekosaur> savask, your problem there isn't with read, it's with lists.  you can't mix types in a list.
09:15:39 <xcvd> but is that an attribute to functional programming/mathematical functions in general
09:15:56 <ski> xcvd : one could also say instead `myVariantFunction (x,y) = x*10 + y', which would define `myVariantFunction' to take a single argument `(x,y)' -- usually we say that `myFunction' takes two arguments in a curried fashion, while `myVariantFunction' takes two arguments in a tupled fashion (you can think of `(x,y)' as an "argument list", if you like)
09:15:58 <savask> geekosaur: Telepathy o_O
09:16:10 <ski> xcvd : "that" referring to ?
09:16:12 <geekosaur> no, you told hpaste to announce the paste :)
09:16:42 <geekosaur> [18 16:13] <hpaste> savask pasted “Read of different types” at http://hpaste.org/70120
09:16:45 <xcvd> the fact that there is only one argument per function
09:16:54 <savask> geekosaur: Yes, yes, I saw it.
09:17:15 <ski> xcvd : depends on how you concieve of functions, mathematically
09:17:27 <savask> geekosaur: What do you mean by "mix types"?
09:17:28 <ski> xcvd : but it's common to view functions in this way, for uniformity, yes
09:17:42 <geekosaur> so anyway, line 7 maps read over a list; the list items have to all be the same type
09:17:56 <xcvd> yes ok thats the answer I was looking for
09:18:19 <savask> geekosaur: Aaah, cause of one read>
09:18:24 <ski> xcvd : e.g. in math, if you have `f(x,y) = 10*x + y', we commonly say `f : |R^2 >---> |R', where `|R^2' is the set of pairs of real numbers, so this `f' "really" then takes a single argument in that set, which is a pair of two real numbers
09:18:26 <savask> One read - one type for it.
09:18:57 <xcvd> or you can approach it from a curried point of view?
09:19:21 <savask> geekosaur: So I can't make "read" read different things in one program?
09:19:36 <geekosaur> you can, you just can't do it the way you are trying to
09:19:43 <savask> How?
09:19:48 <geekosaur> ns and ls are in the same list, they must have the same type
09:19:55 <savask> Yes, I see know.
09:19:58 <savask> *now
09:20:52 <geekosaur> if you want different types you need to read them separately (and may need to specify the type of ls; right now it's forced to Int)
09:21:13 <barrucadu> xcvd: You can look at it from the cartesian product (function taking a single tuple as its argument) or the currying perspective. In my experience the tuple way is more common in maths and the currying method more common in CS, but both work.
09:21:23 <ski> xcvd : however, in e.g. matrix/vector/linear algebra, it's common to talk about "multi-linear" functions, meaning a function `f' such that `f(a,b,...,h,i_0 + i_1,j,...,z) = f(a,b,...,h,i_0,j,...,z) + f(a,b,...,h,i_1,j,...,z)' and `f(a,b,...,h,scalar * i,j,...,z) = scalar * f(a,b,...,h,i,j,...,z)' .. and we might write `f : A,B,...,Z >---> SomeVectorSpace' -- here `f' is conceived of as a "multiple-argument function"
09:22:13 <savask> geekosaur: Okay. It will be trickier than I thought.
09:22:34 * MagneticDuck is away: I'll be back to finish work on the first release of RoboDuck. The version that's on right now is still waaaay beta. :P I'll be back at the next full hour..
09:23:28 <srhb> savask: If you know what types you will have in your list, you can just wrap them in a type that can hold all of them. Depending on what you're doing this may or may not be the right approach.
09:23:42 <ski> xcvd : then, it turns out we can define a vector space `A (x) B (x) ... (x) Z' such that we can have a "single-argument function" `g : A (x) B (x) ... (x) Z' with `g((a,b,...,z)) = f(a,b,...,z)'
09:24:24 <ski> xcvd : if you don't understand the last two things i said, you can safely ignore them -- it was just meant as an analogy, if you know some linear algebra
09:25:06 <ski> (sorry, should be `g : A (x) B (x) ... (x) Z >---> SomeVectorSpace')
09:25:33 <ski> xcvd : "or you can approach it from a curried point of view?" -- what do you mean ?
09:25:58 <xcvd> i don't know to be honest
09:26:09 <xcvd> can currying be applied in a mathematical sense?
09:26:10 <ski> well, what did you mean by "it" there ?
09:26:10 <tac-tics> Can anyone give me a not-overly-clever-but-still-useful, Non-Integer example of when the Ix class would be useful?
09:26:59 <ski> xcvd : yes, if you define `f(x)(y) = x*10 + y' (which you also could write as `f(x) = g where g(y) = x*10 + y'), then `f' is a curried function
09:27:59 <ski> xcvd : so we can, instead of the previous `f : |R^2 >---> |R', say `f : |R >---> |R^|R', where `B^A' is the set of all functions from `A' to `B'
09:28:51 <ski> xcvd : other notations for this is `f : |R >---> (|R -> |R)' or `f : |R >---> (|R => |R)' -- which is are closer to the Haskell `f :: Double -> (Double -> Double)'
09:29:00 <ski> (s/are //)
09:29:56 <ski> (xcvd : if you're wondering about the difference between `>--->' and `->'/`=>' is here, it doesn't matter in our case)
09:31:35 <xcvd> well thankyou very much for your help
09:32:22 <savask> srhb: You mean like: "data MList = SList [String] | IList [Int] | ..."?
09:32:35 <ski> xcvd : when Alonzo Church wrote "The Calculi of Lambda-Conversion" in 1941, he more or less invented the idea of using curried functions to represent functions taking multiple arguments -- and that was the start of the lambda calculus
09:33:11 <ski> (apparently <http://www.jfsowa.com/logic/alonzo.htm> contains the first three pages of that book, if you're curious)
09:33:28 <xcvd> it does indeed
09:33:32 <xcvd> so am I right in saying that a function never really has multiple arguments? the argument is either a set or the function can be curried
09:33:56 <barrucadu> Tuple, not set (sets are unordered)
09:34:16 <ski> by "the argument is either a set" did you mean "the *type* of the argument is either a (single) set" ?
09:35:35 <ski> xcvd : in any case, re "so am I right in saying that a function never really has multiple arguments?", it depends on your conception of functions
09:36:25 <ski> xcvd : it is *possible* to conceive of functions as always taking a single argument, and in that case either represent "multiple-argument" functions by passing them in a tuple, or passing them curriedly (or some mixture of the two)
09:36:58 <ski> xcvd : however, it is also *possible* to conceive of functions as inherently being able to take multiple arguments
09:37:01 <akosch> I just tried ghc-mod with emacs, but it keeps saving my buffers automatically: can I stop it from doing this and only run ghc-mod, when I save manually?
09:37:19 <shapr> akosch: keep everything in darcs?
09:37:51 <ski> xcvd : this is a bit similar to that it being possible to regard functions as functional relations; but on the other hand, it is alternatively possible to regard relations as being functions returning a truth-value
09:37:52 <akosch> shapr: my issue is that I'm running from a laptop and every time emacs saves the buffer my hard-drive spins up
09:38:17 <shapr> ohh, increase your writeback time?
09:38:26 <shapr> oh wait, it probably calls sync somewhere?
09:38:44 <shapr> akosch: Do you use powertop?
09:38:49 <akosch> shapr: I guess, but I would still go with disabling autosave if possible
09:38:51 <ski> xcvd : taking the "all functions take a single argument" position (as Haskell does) simplifies things, compared to the "functions may take multiple arguments" position
09:38:55 <shapr> That's true
09:39:02 <akosch> shapr: yeah, I have it on my system
09:39:23 <ski> xcvd : however, there may be cases (like multi-linear functions in linear algebra) where it can be natural to take the other position
09:39:26 <xcvd> simplifies in what sense?
09:39:30 <HugoDaniel> i find this Text, FilePath, system-filepath thing really awkward :/
09:41:28 <ski> xcvd : well, explaining `(\x -> ..x..)(X)' seems simpler than explaining `(\(a,b,...,z) -> ..a..b...z..)(A,B,...,Z)'
09:42:30 <t7> https://trello.com/card/learn-you-a-haskell/4fa1850bbfe5ffc01563efbf/20 vote?
09:43:07 <ski> xcvd : e.g. in the lisps, where procedures inherently take a list of arguments, you have to use something like `apply' if you want to pass on a whole argument list to another function : (define nand (lambda arguments (not (apply and arguments))))
09:44:04 <ski> having to reify the arguments passed to `nand' as a single value (a list), and then having to use `apply' to pass the elements of this list as the argument list to `and' is a consequence of having multiple-argument procedures
09:44:09 <ski> (btw, that above is Scheme)
09:45:05 <ski> in Haskell, we'd just pass a list of booleans (a single argument, not an argument list) : nand booleanList = not (and booleanList)
09:45:06 * nand` is quite fond of one-parameter one-result; since that's what deterministic functions ought to be
09:45:52 <nand`> or nand = not . and -- even more straight to the point
09:46:09 <ski> (also, in several lisps, procedures can actually also return multiple results, but in most cases only a single result is expected, so you have to introduce special ways to "catch" the multiple results)
09:46:10 <ocharles> or... straight to the pointless
09:46:12 <ocharles> hahahahahahaha
09:46:13 * ocharles leaves
09:46:17 <nand`> ocharles: haha
09:46:20 <ski> ocharles :)
09:47:02 <nand`> speaking of which, isn't it ironic that it's called “pointless” since composition is . in Haskell, and lambdas are ->?
09:47:16 <ocharles> nand`: composition is only . if you don't have UnicodeSyntax
09:47:25 <ski> well, in `\x. ..x..', the "point" is really `x', not `.'
09:47:29 <nand`> ∘ :)
09:47:39 <nand`> ski: oh
09:47:54 <nand`> does -XUnicodeSyntax allow λ for \ ?
09:48:22 <geekosaur> no, because λ is syntactically a letter
09:48:27 <geekosaur> (per unicode standard)
09:50:26 <parcs`> what's the best way to retrieve n random elements from a Map?
09:51:02 <ocharles> n distinct elements?
09:51:58 <parcs`> yeah
09:53:14 <parcs`> or equivalently, to shuffle a list
09:53:15 * ski thinks `UnicodeSyntax' ought to allow `\x ↦ ..x..' instead of (or at least in addition to) `\x → ..x..'
09:53:28 <ski> (also in `case' syntax)
09:54:35 <akosch> shapr: I think I'll just disable flymake-mode and bind flymake-start-syntax-check to C-c C-c
09:54:42 <ski> parcs` : <http://okmij.org/ftp/Haskell/perfect-shuffle.txt> ?
09:54:59 <shapr> akosch: That might work. I just bought a 120gb mushkin SSD for $85 from newegg
09:55:40 <akosch> shapr: yeah, throwing money at the problem usually works as well ;)
09:56:45 <shapr> akosch: My lenovo X61t had an extremely sensitive accelerometer, everytime I breathed hard it would lock the drive, so this SSD is a great improvement.
09:57:58 <parcs`> ski: thanks
09:58:48 <akosch> shapr: I understand. I'm quite happy with my HDD, but maybe the time for upgrades comes sooner than I thought.
10:00:16 <akosch> shapr: also we don't have newegg in eastern europe ;)
10:00:34 <shapr> Aw, that's sad!
10:02:59 <codolio> newegg has a 120GB OCZ ssd for $70 today.
10:03:02 <codolio> You bought too early. :)
10:03:38 <parcs`> ocz ssds are the worst
10:03:55 <codolio> Yeah?
10:04:57 <TheRedMood> Hey all
10:05:23 <TheRedMood> Is it worth learning vi?
10:05:35 <TheRedMood> or should i just go for something like notepad++
10:05:38 <TheRedMood> or textmate
10:05:48 <ion> mu
10:05:48 <TheRedMood> Depending on if im using the virtual osx or windows
10:06:55 <importantshock> hmmm, maybe resource-simple-0.1 is what I should be using here…
10:07:06 <importantshock> Control.Monad.Resource.Trans is quite the bear.
10:07:31 <dwierenga> TheRedMood: vi(m) is always worth learning IMO
10:07:41 <TheRedMood> Because?
10:08:01 <codolio> The knowledge transfers to nethack.
10:08:04 <TheRedMood> x3
10:08:12 <TheRedMood> Well thats almost enough to make me learn it
10:08:18 <stj> what would be the short version of (\x -> x - 1) ?
10:08:18 <ion> After learning vi(m) navigating in text in every other editor feels annoyingly slow. And vi is available on pretty much every unixish box.
10:08:20 <TheRedMood> But i don't play nethack that much
10:08:37 <ion> stj: subtract 1
10:08:44 <ion> stj: pred
10:08:58 <shachaf> (-1+)
10:09:01 <stj> cool, thanks
10:09:13 <stj> shachaf: exactly what I was looking for :)
10:09:23 <ion> pred shouldn’t apply to non-integers (but sadly it does).
10:09:24 <dwierenga> TheRedMood:  because you can use vim through an ssh connection and what ion said
10:09:28 <ion> non-integrals
10:09:30 <shachaf> ion: pred is the devil.
10:10:01 <TheRedMood> okey
10:11:00 <TheRedMood> Um
10:11:07 <TheRedMood> What do you guys think about python?
10:11:09 <codolio> If you're not convinced by those arguments, you could also look at sublime text. Lots of people seem to like it, and it's available on the three major platforms.
10:11:14 <TheRedMood> Like objectivly
10:11:27 <TheRedMood> yeah, it looks really slick
10:11:36 <TheRedMood> But is it open source?
10:11:50 <codolio> I don't think so.
10:11:56 <codolio> Is notepad++?
10:11:58 <importantshock> nope, sublime text is proprietary
10:12:05 <TheRedMood> I think notepad--
10:12:06 <importantshock> nodepad++ is oss ISTR
10:12:06 <TheRedMood> is
10:12:15 <TheRedMood> But im not sure
10:12:23 <TheRedMood> But i don't really care when im on windows
10:12:32 <TheRedMood> because that system is made for copyright
10:12:36 <DMcGill> can you derive instances for a data type defined in a different module?
10:12:42 <TheRedMood> its more for linux
10:12:51 <sickfault> are lisp-macros anything to have?
10:13:02 <dwierenga> TheRedMood: vim works fine on windows too :D
10:13:06 <Saizan> DMcGill: with StandaloneDeriving
10:13:13 <sickfault> all your types belong to us
10:13:17 <ski> TheRedMood : fyi, you can use Emacs behind an ssh connection as well ..
10:13:26 <DMcGill> cheers
10:13:27 <TheRedMood> I've tried emacs
10:13:33 <TheRedMood> Its pretty good
10:13:40 <TheRedMood> But i don't think i will be using any of it
10:13:53 <TheRedMood> since what i want is to open and edit text files
10:13:55 <ski> TheRedMood : btw, i use emacs on windows as well :)
10:14:11 <TheRedMood> i feel like vim and emacs are taking away my focus on actully learning the diffrent laungishes
10:14:23 * ski thought emacs was for editing text files ?
10:14:27 <TheRedMood> I know
10:14:28 <sickfault> emacs can program for you
10:14:32 <TheRedMood> X3
10:14:34 <TheRedMood> I know!
10:14:41 <TheRedMood> I'm not saying anything like that
10:14:50 <TheRedMood> im saying that simple programs like notepad++
10:14:51 <ski> (but maybe the argument is that emacs is a relatively good OS, but a bad text editor ?)
10:14:53 <TheRedMood> and textmate
10:15:05 <TheRedMood> is more for me right now
10:15:14 <TheRedMood> since i don't need to be super fast right now
10:15:23 <TheRedMood> but to concentrate on my coding
10:15:25 <dwierenga> TheRedMood: i feel ya.  i learned vim and perl at the same time. i can't program perl without using vim now, they became irreparably linked in my brain
10:15:34 <TheRedMood> x3
10:15:44 <sickfault> i prefer eclipse for java and visual studio for C but for anything that doesnt have a good IDE emacs is pretty good once you get the hang of it
10:15:47 <TheRedMood> Can you use python with haskell
10:15:50 <ski> TheRedMood : use whatever you're most confortable with atm. then later you can try to get into e.g. emacs or vim, if you'd like
10:16:01 <TheRedMood> hmm
10:16:11 <TheRedMood> I want to use the one text editor everyone hates x3
10:16:16 <tac-tics> @faq Can you use python with haskell
10:16:16 <lambdabot> The answer is: Yes! Haskell can do that.
10:16:29 <TheRedMood> good :D
10:16:32 <parcs`> how do you CPSencode Either?
10:16:36 <ski> TheRedMood : why do you want to use a text editor you hate ?
10:16:54 <barrucadu> @faq ∀x, can haskell x?
10:16:55 <lambdabot> The answer is: Yes! Haskell can do that.
10:16:55 <TheRedMood> Because i can be the one guy
10:17:13 <Peaker> ski, for me, it is because I don't have a practical editor I don't hate yet :)
10:17:21 <TheRedMood> when people start to argue over vi and emacs
10:17:22 <TheRedMood> i can say
10:17:33 <TheRedMood> "hey! I use X and i really like it!"
10:17:39 <TheRedMood> And everyone goes really silent
10:17:44 <ski> TheRedMood : maybe try using `ex' <http://en.wikipedia.org/wiki/Ex_(text_editor)> ?
10:17:45 <TheRedMood> and then im kicked from the irc room
10:17:52 <dwierenga> oh, for that, just stick with MS Word
10:18:01 <parcs`> (a -> Either e r) -> Either e r or (a -> r) -> (e -> r) -> r ?
10:18:05 <dwierenga> you can get near-universal hate directed at you
10:18:06 <TheRedMood> No
10:18:10 <TheRedMood> Because that actully works
10:18:15 <TheRedMood> I need something like sed or ed
10:18:19 <barrucadu> "What do you use to program Haskell?" "Well, I tried a few editors but I just keep coming back to Word."
10:18:25 <TheRedMood> x3
10:18:33 <TheRedMood> That made my day
10:18:48 <codolio> parcs`: The latter.
10:21:37 <TheRedMood> THere
10:21:44 <TheRedMood> Done making the terminal look like the one from fallout
10:22:08 * barrucadu looks up the fallout terminal on google images
10:22:20 <barrucadu> That… doesn't look nice to use
10:22:45 <TheRedMood> !faq ax, can haskell google that for him?
10:22:50 <TheRedMood> no
10:22:52 <TheRedMood> no reqpons
10:23:11 <TheRedMood> @faq ax, can haskell google that for me?
10:23:12 <lambdabot> The answer is: Yes! Haskell can do that.
10:23:15 <TheRedMood> X3
10:23:24 <shapr> JavaScript Monads?! http://shop.oreilly.com/product/0636920023890.do
10:23:26 <donri> @google fallout terminal
10:23:28 <lambdabot> http://fallout.wikia.com/wiki/Terminal
10:23:28 <lambdabot> Title: Terminal - The Fallout wiki - Fallout: New Vegas and more
10:23:32 <sickfault> i prefer eclipse for java and visual studio for C but for anything that doesnt have a good IDE emacs is pretty good once you get the hang of it
10:23:35 <donri> and lambdabot is written in haskell, so, proof!
10:23:42 <sickfault> are lisp-macros anything to have?
10:23:46 <TheRedMood> @approved
10:23:46 <barrucadu> Monads, in *my* JavaScript?
10:23:46 <lambdabot> Unknown command, try @list
10:23:48 <S11001001> shapr: "jQuery, for instance, is probably the most widely-used monad in the world"
10:23:55 <S11001001> well, except for that one
10:24:16 <ski> sickfault : yes, preferably hygienic
10:25:18 <S11001001> and that other one
10:25:40 <Cale> The existence of that book scares me. The chance of someone doing a bad job of representing the monad abstraction in Javascript is a lot higher than the chances that they actually got it right.
10:25:52 <TheRedMood> um
10:26:08 <TheRedMood> Is there any really good lightweight browsers for mac?
10:26:15 <TheRedMood> I just started running a virtual one
10:26:19 <TheRedMood> so just installing all the otols
10:26:25 <TheRedMood> tools*
10:26:40 <shapr> TheRedMood: Are you sure you've got the right channel?
10:26:47 <Cale> TheRedMood: What do you mean browsers? Is this a Haskell question?
10:26:52 <srhb> Where is the user ghc-pkg packages registered?
10:27:18 <shapr> srhb: somewhere in ~/.ghc/ I think
10:27:20 <TheRedMood> @faq can haskell do browsers?
10:27:20 <lambdabot> The answer is: Yes! Haskell can do that.
10:27:23 <TheRedMood> okey
10:27:27 <TheRedMood> im in the right channel
10:27:29 <t7> lies
10:27:31 <shapr> Oh! You want Manatee browser?
10:27:40 --- mode: ChanServ set +o Cale
10:27:43 <TheRedMood> If its in haskell then yes
10:27:43 <shapr> @hackage manatee-browser
10:27:43 <lambdabot> http://hackage.haskell.org/package/manatee-browser
10:27:47 <shapr> TheRedMood: ok then!
10:28:01 <shapr> TheRedMood: Try that one
10:28:29 <srhb> shapr: Yep, thanks!
10:28:42 <Cale> Of course, it doesn't render the HTML itself, it just uses the webkit binding.
10:28:44 * ski . o O ( maybe we ought to capture this Zachary Kessin, and subject him to an inquisitory cross-examination ? )
10:28:51 <Cale> ski: yes
10:28:57 <shapr> ski: I agree
10:29:03 <shapr> I will invite him to show up here.
10:30:29 <ski> preflex: xseen ManateeLazyCat
10:30:30 <preflex>  ManateeLazyCat was last seen on freenode/#haskell 97 days, 2 hours, 56 minutes and 4 seconds ago, saying: applicative: Gnome-Shell lies to on powerful with gjs, it use JavaScript, make desktop environment not stable enough, it use clutter library, make it can't running on ATI driver, i hate it.
10:31:06 <srhb> :< Sounds like it may have been followed by prompt suicide.
10:31:29 <shapr> ski: Ok, I asked him on twitter, I'll tell you what he says.
10:31:47 <geekosaur> thought he was busy thesing or something
10:31:50 <shapr> srhb: ManateeLazyCat has always had unusual habits.
10:32:30 * ski doesn't think suicide would be an easy habit to have
10:32:40 <ski> (jesting)
10:32:46 <xcvd> "Could not find module `Data.Number.Dif'" :( why am I getting this
10:33:29 <MagneticDuck> > (isInfixOf `on` words) "apple is a perfect" "apple is a perfect example of an OS"
10:33:30 <lambdabot>   True
10:33:30 <Cale> xcvd: Do you have the numbers package installed?
10:33:41 <xcvd> nope
10:34:12 <Cale> xcvd: Then that's probably why.
10:34:24 <Cale> http://hackage.haskell.org/package/numbers
10:34:35 <ski> shapr : i suspect Cale is mostly worried about (a) delineating the monad concept from other "add-on" parts (cf. LINQ in C#); (b) the monad laws; (c) possibly confusing a specific monad with the general concept, or confusing a monadic action with a monad
10:34:49 <xcvd> thanks
10:35:01 <k0ral> are there yi maintainers here ?
10:35:23 <Cale> A lot of people who implement "monads" in other languages make the mistake of implementing particular monads like Maybe or whatever, and implement their bind and return, but don't actually implement the abstraction.
10:35:44 <Cale> If you can't write code which works in all monads, then you haven't got it right.
10:36:20 <importantshock> Is hayoo down?
10:37:09 <srhb> importantshock: http://holumbus.fh-wedel.de/hayoo/api.html
10:37:10 <Cale> Unfortunately, in most OO languages, this also makes it annoying to use, because you end up doing something like explicitly passing the typeclass dictionary around.
10:37:11 <srhb> importantshock: No.
10:37:20 <tazjin> importantshock: http://www.isup.me/http://hayoo.info/hayoo.html - yes, it's down
10:37:37 <cschneid> I am working on learning real world haskell - can anybody recommend a good list of Kata type problems to work through? Ideally that point toward the "hard" parts to learn in haskell
10:38:16 <srhb> What are kata type problems?
10:38:29 * ski str the Typeclassopedia has some typeful problems
10:38:31 <cschneid> kata == short, focused problem, designed to showcase some form or idea
10:38:38 <shapr> srhb: Exercises like martial arts katas
10:38:43 <ski> @where Typeclassopedia
10:38:44 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
10:38:44 <Cale> As opposed to ana type problems?
10:38:47 <Cale> ;)
10:38:51 <srhb> I see.
10:39:17 <shapr> srhb: http://blog.moertel.com/articles/2006/10/31/introductory-haskell-solving-the-sorting-it-out-kata
10:39:36 <cschneid> might just go pick up the generic ones I see
10:39:46 <cschneid> it's interesting coming from Ruby to Haskell.  Totally different :)
10:39:58 <srhb> cschneid: Oh yeah. :P
10:40:08 <ski> cschneid : did you look at Typeclasopedia above ?
10:40:20 <cschneid> cool.
10:40:45 <cschneid> ski, srhb - well, apparently being dragged to lunch by coworkers. I'll be around and bothering you guys as I run into issues
10:40:48 <cschneid> thanks :)
10:40:53 <srhb> cschneid: :)
10:41:02 <ski> sure, yw :)
10:42:39 <sickfault> how do u become a channel operator?
10:42:51 <ben> You make your own channel :)
10:43:01 <barrucadu> By another op in the channel considering you worthy, I guess
10:44:31 <ski> (btw, asking about wanting to become an operator is commonly a good way to not become one :)
10:44:57 <c_wraith> This channel doesn't really need more ops. There are probably 50 or so people who chanserv can op if there's a problem.
10:45:13 --- mode: ChanServ set +o c_wraith
10:45:18 <c_wraith> nooo
10:45:31 --- mode: c_wraith set -o c_wraith
10:45:40 * shapr snickers
10:46:20 --- mode: Cale set -o Cale
10:46:21 <c_wraith> Interesting that chanserv tells you who did it, on this network.  Handy, I guess.
10:46:22 * ski plays "Snickers" by Drax/Vibrants
10:48:44 <ski> (c_wraith : not if you use `/msg ChanServ [de]op #foo bar', iirc .. same with `[un]quiet')
10:51:43 <nand`> What would be the most idiomatic way to implement hexColor :: String -> (Word16, Word16, Word16); giving eg. hexColor "#FF0000" = (65535, 0, 0)
10:53:22 <jedai> nand`: The most idiomatic I don't know, but you could at least use the functions in Numeric
10:54:53 <sickfault> are lisp-macros anything to have?
10:55:05 <jedai> nand`: I would probably just go to the simple and ugly hexColor ['#',a,b,c,d,e,f] = (read...
10:55:11 <hpaste> “Jonathan Fischoff” pasted “To Color” at http://hpaste.org/70125
10:55:28 <sickfault> what would be a good thing to code in haskell to see its strengths? say 1k-2k LOC
10:55:29 <jfischoff> nand`: its not pretty
10:57:20 <S11001001> sickfault: a client for a complex wire protocol
10:57:36 <sickfault> complex wire protocol?
10:57:39 <piyanik> hey guys, my question is about `rem` function...in the  haskell explanation of `rem` i see also prority :7 ...what is that mean or how should i understand ?
10:58:07 <nand`> jfischoff: I should be able to work with that, was not aware of hexDigit
10:58:21 <S11001001> piyanik: that's its precedence when used as an infix operator
10:58:29 <JuanDaugherty> is there a "best" d6 node as a block module?
10:58:39 <nand`> oh, it's a Parser Char, I see what it does now
10:59:12 <piyanik> S11001001: Er, can you give me an example , maybe ?
10:59:16 <piyanik> _D
10:59:38 <ion> > let hexColor ('#':cs) = listToMaybe [ (component 0xff 16 n, component 0xff 8 n, component 0xff 0 n) | (n,"") <- readHex cs ]; component a b n = (n `shiftR` b) .&. a in hexColor "#ff0000" :: Maybe (Integer, Integer, Integer)
10:59:40 <lambdabot>   Just (255,0,0)
10:59:52 <S11001001> piyanik: infixl 7 means it's left-associative, associates freely with other infixl 7 operators, has higher precedence than <=6 fixities, lower precedence than >=8 fixities
11:00:38 * hackagebot HarmTrace 2.0 - Harmony Analysis and Retrieval of Music  http://hackage.haskell.org/package/HarmTrace-2.0 (JosePedroMagalhaes)
11:00:46 <Iceland_jack> > let hexcolor ['#',a,b,c,d,e,f] = (hex $ a:b:[], hex $ c:d:[], hex $ e:f:[]) where { hex xs = read ("0x" ++ xs) :: Int }
11:00:48 <lambdabot>   not an expression: `let hexcolor ['#',a,b,c,d,e,f] = (hex $ a:b:[], hex $ c...
11:00:51 <Iceland_jack> :Þ
11:01:30 <piyanik> S11001001: thx , now its clearer ))
11:01:51 <S11001001> > 5 * 3 `rem` 8 * 100 -- piyanik, (*) is also infixl 7, so this just applies from left-to-right
11:01:52 <lambdabot>   700
11:02:40 <piyanik> S11001001: thank you ))
11:05:39 * hackagebot biostockholm 0.3.2 - Parsing and rendering of Stockholm files (used by Pfam, Rfam and Infernal).  http://hackage.haskell.org/package/biostockholm-0.3.2 (FelipeLessa)
11:07:02 <nand`> Hmm. I suspect this API may be bugged. The underlying C function expects an array of values, but the Haskell version only lets me pass a single value
11:07:27 <nand`> Is this a bug, and if so, how do I fix it? I need to pass lots of values
11:08:15 <c_wraith> nand`: well..  what api?
11:08:23 <shachaf> c_wraith: That would be too easy.
11:08:45 <c_wraith> In that case, it's a not a bug, and I recommend fixing it by modifying some code.
11:09:06 <nand`> http://code.haskell.org/vte/Graphics/UI/Gtk/Vte/Vte.chs c_wraith: in function “terminalSetColors”
11:09:30 <nand`> also, the original C code has special conditions for when the first two arguments are NULL, I imagine those should rightfully be Maybe Color in the Haskell API?
11:09:39 <nand`> see http://developer.gnome.org/vte/unstable/VteTerminal.html#vte-terminal-set-colors for the original documentation
11:10:16 <c_wraith> nand`: you're specifically looking at the palette argument?
11:10:44 <nand`> c_wraith: yes, that's the one I care about
11:10:58 <geekosaur> that looks wrong
11:11:09 <geekosaur> and likely coredump-inducing
11:12:01 <c_wraith> It certainly looks wrong, but I'd like to see what Color is actually defined as
11:13:37 <nand`> c_wraith: Color Word16 Word16 Word16 -- more or less, let me look it up
11:14:05 <nand`> http://hackage.haskell.org/packages/archive/gtk/0.12.3.1/doc/html/Graphics-UI-Gtk-Gdk-GC.html#t:Color
11:15:34 <nand`> since I don't know how to do any of this C/FFI stuff myself, I would appreciate it if somebody patched that function for me
11:15:47 <nand`> I'm trying to write a usable terminal :P
11:16:20 <c_wraith> yeah, that looks near-certain to crash
11:17:07 <c_wraith> unless you pass 1 as the size
11:17:17 <nand`> I'm passing 0 right now
11:17:39 <c_wraith> well, 0 would also work
11:17:43 <c_wraith> in the not-crash sense
11:18:28 <c_wraith> huh.  that's an ugly api for using no matter the language
11:18:57 <c_wraith> since the input array has to be one of a specific set of sizes
11:19:00 * geekosaur has seen worse.  (in Xlib... which possibly makes it a given)
11:19:18 <c_wraith> I'm sure there are worse, yes :)
11:20:10 <geekosaur> come to think of it, Xlib might be part of why this api sucks, although gdk is *supposed* to abstract such things
11:20:42 <c_wraith> nand`: that binding needs a complete rewrite. If I was actually using it, I'd take a stab at it - but without a quick way to test it, it wouldn't be pleasant for me to try.
11:20:52 <nand`> I see
11:21:15 <nand`> I think it's the only API for vte, unfortunately
11:21:16 <geekosaur> my guess is it's generated with c2hsgtk2hs from the C API
11:21:28 <nand`> and I'm not about to implement an entire terminal from scratch :P
11:21:56 <c_wraith> hmm.  that's a worrying thought, geekosaur.  But it would explain it.
11:23:53 <ski> is Vte a specific terminal, or a generic gnome interface to terminals ?
11:24:57 <nand`> the latter, it's a library for terminals
11:26:12 <startling> is there a typeclass for indexable things? specifically I want to get the first item of a thing
11:26:45 <startling> I'm using list atm, but it seems like a thing that could be further generalized
11:27:08 <geekosaur> yes and no.  arrays use an Ix class, but other indexables mostly don't
11:27:55 <startling> isn't Ix a type for indices?
11:28:12 <ski> it's a type class for (array) indices
11:28:19 <ski> @src Ix
11:28:19 <geekosaur> they kinda go together, no?
11:28:19 <lambdabot> class (Ord a) => Ix a where
11:28:20 <lambdabot>     range           :: (a,a) -> [a]
11:28:20 <lambdabot>     index           :: (a,a) -> a -> Int
11:28:20 <lambdabot>     inRange         :: (a,a) -> a -> Bool
11:28:20 <lambdabot>     rangeSize       :: (a,a) -> Int
11:28:31 <ski> @type array
11:28:32 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
11:28:34 <ski> @type listArray
11:28:35 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
11:28:38 <S11001001> startling: do you want your getter to be a total function?
11:28:51 <startling> S11001001, oh, it can't really, can it
11:29:01 <ski> @type Data.Array.MArray.newArray
11:29:03 <lambdabot> forall i e (m :: * -> *) (a :: * -> * -> *). (Data.Array.Base.MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
11:29:05 <S11001001> startling: head is total on NonEmptys (in semigroups)
11:29:50 <startling> S11001001: alright
11:30:38 <fmap> there is a typeclass for list-like things
11:31:02 <S11001001> yes, but foldable doesn't give you head totality
11:31:23 <startling> fmap, oh?
11:31:23 <ski> nand` : it seems strange of it to say `If foreground is @Nothing@', given that it's `Color' and not `Maybe Color'
11:31:30 <nand`> ski: yes
11:31:42 <nand`> ski: in the original documentation it's “If foreground is NULL”, maybe that was automatically parsed?
11:31:45 <jfischoff> what's an easy what to call an external process?
11:31:47 <ski> it looks like it's (a broken) translation from the C docs
11:31:52 <LambdaDusk> Is there anyone knowing reactive-banana? I am looking for a function like "(a -> a) -> Event t a -> Event t a"
11:32:35 <startling> LambdaDusk, are Events monads? if so, liftM
11:32:39 <ski> (of course, it would be hard to know for it how to rewrite the documentation if one decided not to map to `Maybe Color' -- but it ought to generate a warning or something in that case)
11:32:48 <LambdaDusk> startling: No, functors
11:32:49 <startling> doesn't answer your question exactly, though
11:32:50 <ladr0n> what is the <+> thing called, so I can google it?
11:32:54 <ski> LambdaDusk : then `fmap'
11:33:07 <ski> @index (<+>)
11:33:08 <lambdabot> Control.Arrow, Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
11:33:11 <ski> @hoogle (<+>)
11:33:11 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
11:33:11 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
11:33:11 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
11:33:16 <ski> @hoogle+
11:33:16 <lambdabot> Text.PrettyPrint (<+>) :: Doc -> Doc -> Doc
11:33:26 <ski> ladr0n : any of those ^ ?
11:33:27 <geekosaur> ladr0n, there is no standard <+>, many libraries define one with different meanings in each
11:33:46 <geekosaur> xmonad also has one (as a synonym for mappend)
11:34:10 <ski> @where hoogle
11:34:11 <lambdabot> http://haskell.org/hoogle
11:34:13 <ski> @where hayoo
11:34:13 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
11:34:15 <ladr0n> okay, the xmonad one is what I'm looking for, thanks.
11:34:22 <ski> ladr0n : you could also try those ^ two sites
11:34:38 <conal> startling: yes. representable functors. edward kmett has a package.
11:34:42 <ocharles> is there still a ton of bikeshedding on the ml about <+> being mappend in the standard libraries?
11:34:53 <startling> conal, I was just asking to help LambdaDusk
11:34:53 <conal> startling: see also memoization packages.
11:35:05 <conal> startling: ah.
11:35:05 <startling> oh, you mean the other thing
11:35:13 <startling> ?
11:35:25 <conal> LambdaDusk: ^^
11:35:42 <ladr0n> ski: thanks. er what's the difference between hoogle and hayoo anyway, they seem very similar to me
11:35:55 <geekosaur> ocharles, <> was finally accepted into the standard libraries in lace of <+>, because <+> is used by ghc internally as well as by some libraries in the Platform already
11:35:55 <ladr0n> at first glance, at least. i haven't used hayoo extensively.
11:36:04 <ski> ladr0n : i don't recall exactly :/
11:36:11 <geekosaur> with meanings incompatible with both mappend and each other
11:36:15 <ocharles> geekosaur: oh cool, at least something made it!
11:36:15 <ladr0n> ski: fair enough
11:36:46 <ski> ladr0n : anyway, i think the hoogle (and probably the hayoo) site sees more libraries than the `hoogle' command in lambdabot
11:37:03 <ski> ladr0n : possibly `hayoo' was improved in some way, wrt to `hoogle'
11:37:04 <geekosaur> hoogle has picked up some of the features of hayoo, but in general hoogle is search by type and hayoo is search by name
11:37:11 <ski> ok
11:37:41 <geekosaur> the sites use hackagwe, lambdabot uses a small pregenerated (and incomplete; mostly bootlibs) local database
11:39:10 <geekosaur> you can do some of both with either but the focus of each one is a bit different, which makes each work better for different things
11:39:46 <ladr0n> what about the hoogle package in hackage? does that search all of hackage also?
11:40:32 <startling> does anyone use trifecta? any opinions?
11:40:43 <ski> nand` : a proper direct translation appears to be `terminalSetColors :: TerminalClass self => self -> Maybe Color -> Maybe Color -> [Color] -> IO ()' ..
11:41:08 <MostAwesomeDude> startling: I have used it. It's pretty sweet although I wish the author would do more docs.
11:42:58 <applicative> startling: I dimly remember a back and forth between edwardk and I think dylukes, who was using it.
11:43:18 <dylukes> About what?
11:43:21 <dylukes> trifecta?
11:43:32 <dylukes> Yeah, I've used it quite a lot. edwardk is the author.
11:43:43 <geekosaur> ladr0n, it's the engine behind them.  searching hackage is done by using a database which I think is generated by/on the hackage server, but you'd have to ask someone more knowledgeable about hackage
11:43:58 <dylukes> I personally really like it a lot. If you have any questions or confusions, feel free to ask. It does a few things differently, and it's certainly sprawling at the moment :P.
11:44:16 <startling> MostAwesomeDude, dylukes: thanks! I'll check it out
11:44:34 <geekosaur> (I would expect it to be generated/updated as part of docs building, since that's how cabal-install does it)
11:44:35 <dylukes> The docs are lacking here and there, but if you have questions, ask myself or edwardk.
11:48:53 <shapr[> preflex: seen chrisdone
11:48:53 <preflex>  chrisdone was last seen on #haskell 23 hours, 38 minutes and 43 seconds ago, saying: ah i found it __GLASGOW_HASKELL__ is a number
11:49:00 <shapr[> Wat? I missed him?!
11:49:04 <shapr[> dang
11:49:09 <cschneid> If I want to make a simple network server (listen to connection, read input, spit back output), what library do I need to do the binding to the socket and handle the related IO?
11:49:32 <MostAwesomeDude> cschneid: It's builtin; lemme find docs.
11:49:55 <cschneid> MostAwesomeDude: cool. I think I'm going to write a (very bad) reimplementation of redis as my learn-some-haskell project.
11:50:05 <cschneid> seems to touch a fair number of interesting things
11:50:13 <MostAwesomeDude> cschneid: Well, as long as it's not an IRC bot. >:3
11:50:19 <parcs`> what would be Big O of a function 'Ord k => Map k a -> Set k -> Map k a' where the result map contains indices that exist in both the original map and the set?
11:50:41 <parcs`> a naive implementation would have O(n log n) but it seems that could be lowered to O(n) with a custom implementation
11:51:15 <MostAwesomeDude> cschneid: http://hackage.haskell.org/package/network/ has a fair amount of documentation.
11:51:32 <ocharles> shapr[: he's quite active on twitter, you could ping him there
11:52:00 <shapr[> ocharles: I know, we chat lots there, I just prefer IRC
11:52:22 <ocharles> cschneid: look into either conduits, pipes, iteratees or enumerators too
11:52:35 <parcs`> unfortunately neither Map's nor Set's constructors are exported :/
11:52:38 <ocharles> (in my order of preference, which doesn't mean much)
11:52:47 <ocharles> conduits and pipes have great documentation, the other 2 are a bit thicker to get into
11:53:16 <ocharles> shapr[: ah, ok :)
11:53:35 <cschneid> I'm brand new to haskell. So I'm going to assume that I have a fair bit to do before getting to parallelization :) (that sounds like what those are for?)
11:53:54 <ocharles> cschneid: they are for efficient memory usage
11:54:18 <MostAwesomeDude> cschneid: forkIO is sufficient for basic concurrency; GHC uses m:n threading.
11:54:28 <shapr[> cschneid: Feel free to skip ahead and read later chapters :-)
11:55:20 <cschneid> well, I have some Ruby to write to keep me employed. I'll play with some of this later tonight.  And then report back with more questions.
11:56:30 <shapr[> Golly this is awesome: http://www.reddit.com/r/haskell/comments/v8gvc/hackage_comments_a_simple_user_script/
11:57:08 <shapr[> If you've ever wanted to leave a comment on hackage, NOW YOU CAN!
11:57:30 <kallisti> "this function sux I hope you die!!11!"
11:58:08 <shapr[> kallisti: I hope not :-)
12:04:56 <nand`> ski: I'll change it to .. -> Maybe Color -> Maybe Color -> [Color] -> IO (); I'm expected to pass (fromIntegral $ length palette) manual, yes?
12:16:44 <nand`> oh, never mind
12:16:46 <nand`> there's withArrayLen
12:17:09 <palpatine> hola
12:17:19 <palpatine> hi
12:18:25 <palpatine> this is a chat about haskell?
12:18:46 <palpatine> programming language?
12:19:05 <koala_man> yes, it is!
12:19:16 <koala_man> did the topic tip you off?
12:20:03 <edwardk> preflex: xseen alpounet
12:20:04 <preflex>  alpounet was last seen on freenode/#haskell 2 days, 4 hours, 40 minutes and 27 seconds ago, saying: loxs, there's a blog post about that on mightybyte's blog
12:20:29 <alpounet> edwardk, i'm around
12:20:43 * hackagebot hbro 0.9.1.0 - Minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-0.9.1.0 (koral)
12:20:45 * hackagebot hbro-contrib 0.9.1.0 - Third-party extensions to hbro.  http://hackage.haskell.org/package/hbro-contrib-0.9.1.0 (koral)
12:22:51 <shapr[> palpatine: Are you learning Haskell?
12:23:05 <asperge> edwardk: I've added a new commit to the pull request
12:23:15 <asperge> don't know if you've seen it
12:23:23 <edwardk> asperge: i'll go look now
12:23:30 <nand`> wow, that took much less time than I had anticipated
12:23:34 <nand`> my terminal is complete :)
12:23:34 <asperge> thanks :)
12:23:53 <edwardk> nice
12:23:59 <shapr[> nand`: pix? hackage upload?
12:24:02 <edwardk> ok, that i'll merge =)
12:24:11 <asperge> =)
12:24:14 <hpaste> nand` pasted “vte-based terminal” at http://hpaste.org/70129
12:24:21 <nand`> shapr[: not worth it :P
12:24:32 <nand`> it's just a trivial vte term with my own color palette
12:25:21 <shapr[> nand`: looks neat to me
12:27:23 <nand`> had to fix a bug in haskell-vte
12:27:28 <nand`> mirrored at https://github.com/nandykins/haskell-vte now
12:27:50 <nand`> one thing I'm really, really lacking: urgentOnBell :(
12:28:21 <nand`> I might as well fix the silly module name while I'm at it
12:29:11 <shapr[> Which is simpler, blaze-svg or diagrams-svg?
12:29:28 <luite> uh, they're quite different
12:29:40 <luite> diagrams-svg is a backend to convert diagrams to svg
12:29:58 <luite> and blaze-svg is like blaze-html a combinator lib to build svg (xml) documents
12:30:28 <shapr[> luite: I'm starting on my "show svg in jquery-console" prototype today, looking for the simplest way to get SVG output from Haskell.
12:30:35 <shapr[> So, I should start with blaze-svg then.
12:30:42 <luite> blaze-svg was actually built by the author of diagrams-svg
12:30:50 <luite> no i think you should use diagrams-svg
12:30:56 <james-ubc> dayum
12:31:09 <shapr[> luite: whyso?
12:31:30 <james-ubc> ghc just ate up 15 gigs of ram @_@
12:31:33 <shapr[> luite: not disagreeing, just curious
12:31:56 <luite> shapr[: it's only a few lines to convert a diagram to svg with the svg backend, and you can use the high level diagrams lib to do nice declarative drawing
12:32:01 <shapr[> oh, ok ten
12:33:55 <kqr_> do type aliases (type A = B) type match against each other?
12:35:24 <_Vi> Should only stable and verified packages be uploaded to HackageDB or anything that can be useful?
12:35:51 <asperge> kqr_: yeah
12:35:54 <Clint> how do you verify a package?
12:36:01 <kqr_> asperge, why? wouldn't it make more sense if they didn't?
12:36:06 <shapr[> _Vi: I haven't seen any sort of guidelines, so if you think it's useful and interesting, I'd say upload it.
12:36:17 <asperge> nope, because they are *aliases*
12:36:32 <asperge> but you can use newtype for example if you want them not to match
12:36:36 <kqr_> asperge, so aliasing types is merely a documentation thing?
12:36:37 <kqr_> oh
12:36:42 <asperge> like newtype A = A B or something
12:36:44 <unlink> Is there a builtin like `uncurry . on (,)'?
12:36:49 <asperge> yes kqr_, mostly
12:36:53 <asperge> but not only
12:36:55 * shapr[ reads diagrams-svg examples
12:36:56 <unlink> :t uncurry . on (,)
12:36:57 <lambdabot> forall b b1. (b -> b1) -> (b, b) -> (b1, b1)
12:37:03 <asperge> it can be useful to make long types shorter
12:37:08 <rwbarton> more than documentation, it is actually an error to use A in place of B there
12:37:09 <ski> nand` : i think so, yes
12:37:18 <kqr_> asperge, how does newtype differ from data?
12:37:20 <rwbarton> oh sorry
12:37:23 <ski> nand` : oh, ok (`withArrayLen')
12:37:26 <rwbarton> you were asking about "type A = B"?
12:37:30 <kqr_> rwbarton, yeah
12:37:33 <asperge> kqr_: you can only have one field in a newtype kqr_
12:37:48 <asperge> I think the difference lies in how they're compiled
12:37:56 <Cale> Also semantics
12:38:03 <asperge> I guess newtypes take a bit less space than the equivalent data version
12:38:14 <Cale> Pattern matching against a newtype constructor does no evaluation
12:38:26 <asperge> oh, I didn't know that
12:38:34 <kqr_> asperge, what i'd like is newtype without the constructor
12:38:44 <Cale> If you have  newtype N = N Int  and  data D = D Int
12:38:47 <Cale> and you write
12:38:49 <kqr_> asperge, for additional type safety without having to bother with constructors when the type can only have one kind of value
12:38:49 <asperge> yes, I think most of us would like that kqr_
12:38:55 <asperge> but that's quite complicated
12:38:55 <geekosaur> how is it supposed to know it's being used, then?
12:38:56 <Cale> case N undefined of N x -> 0
12:38:56 <kallisti> I wouldn't
12:39:07 <Cale> er
12:39:10 <Cale> case undefined of N x -> 0
12:39:10 <asperge> I think the newtype package from Hackage might be useful in this case
12:39:15 <Cale> that'll evaluate to 0
12:39:16 * shapr[ reads diagrams documentation
12:39:23 <Cale> but  case undefined of D x -> 0
12:39:27 <Cale> will be undefined
12:39:48 <asperge> kallisti: I mean, nobody likes the constructor-boilerplate with newtype
12:39:49 <ski> kqr_ : saying `type A = B' means that `A' is a different name (a shorthand, if you will) for the type `B' -- they are equal types
12:39:58 <kqr_> a related question then: if you have a type and a constructor with the same name, and you export the name, do you export both?
12:40:05 <kqr_> ski, oh, alright, that makes sense
12:40:26 <kallisti> asperge: I don't particularly mind it.
12:40:28 <startling> kqr_, you need to export "MyType (..)"
12:40:49 <asperge> well, when tyou have lots of newtypes it can be annoying
12:41:02 <kqr_> startling, oh, so it's MyType(Constructor1, Constructor2) etc in the exports list?
12:41:02 <asperge> without being completely unbearable, though
12:41:50 <ski> kqr_ : "what i'd like is newtype without the constructor" -- like "The Hugs 98 User Manual - 7 An overview of Hugs extensions - 7.3.5 Restricted type synonyms" in Hugs at <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> ?
12:42:07 <Cale> kqr_: you can literally write MyType(..) though, which exports them all
12:42:11 <kqr_> Cale, oh, cool
12:42:16 <Cale> kqr_: but yes, you can list them too
12:42:43 <ski> hm, iirc, saying just `MyType' will export both, though
12:43:01 <kqr_> ski, just like that, yeah
12:43:14 <ski> (so name them differently, like `MyType' and `MkMyType', alternatively say `MyType()' to only export the type constructor)
12:43:56 <kqr_> according to slides from SPJ, MyType only exports the type, and no constructors
12:44:04 <kqr_> (no idea what year, though)
12:44:21 <kqr_> (from his a taste of haskell talk)
12:44:23 <ski> maybe what i recall is Hugs behaviour, not sure
12:45:17 <startling> ski: pretty sure it doesn't
12:45:29 <ski> (it being ? hugs ?)
12:45:58 <startling> ski, oh, reading the scrollback. I was responding to "hm, iirc, saying just `MyType' will export both, though"
12:46:20 <parcs`> why are newtypes tagged anyway?
12:46:45 <ski> in typical implementations, they aren't
12:47:19 <parcs`> i see why they should be tagged if they are recursive, but it seems like it should be ok to have untagged non-recursive newtypes
12:47:43 <ski> if you're really wondering why we have to have an explicit constructor for them : it's because we need to have some way of distinguishing the "abstract" type from the "representation" type
12:48:04 <ski> but see "restricted type synonyms" above in hugs, for another way to do it
12:48:23 * kallisti prefers the explicitness of newtypes.
12:48:47 * ski would like restricted type synonyms, as an option, in ghc
12:49:16 <ski> (or possibly, what is mostly the same thing, being able to export a type synonym abstractly (like in SML and O'Caml))
12:49:25 <parcs`> cool
12:53:17 <parcs`> wow, hugs even has extensible records
12:55:20 <geekosaur> Trex is kinda unfortunate though
12:55:52 <parcs`> what do you mean?
12:56:08 <ciaranm> sill parcs`, trex is for kids
12:56:27 <parcs`> looks like a grown up feature to me :(
12:59:27 <geekosaur> hm, I thought there was an extensible records page on haskellwiki describing the problems with TRex; I know it's been discussed on -cafe and I thought they'd been collected together
13:05:09 <hpaste> nand` annotated “vte-based terminal” with “vte-based terminal (annotation)” at http://hpaste.org/70129#a70130
13:05:30 <nand`> finally I have a usable terminal
13:05:57 <nand`> mostly-usable anyhow, still needs urgentOnHint
13:07:14 <augur> is anyone at NASSLLI?
13:07:28 <fmap> nice palette
13:11:06 <nand`> -XUnicodeSyntax should allow × for tuples :)
13:11:12 <nand`> A×B → (A,B)
13:12:24 <rwbarton> type (×) = (,)
13:12:33 <shachaf> rwbarton: :×
13:12:36 <rwbarton> oh yeah
13:13:05 <rwbarton> didn't some rules about that change recently in a ghc extension though
13:13:21 <shachaf> -XWhateverSyntax
13:13:32 <shachaf> I haven't heard of that.
13:14:01 <rwbarton> I thought it was associated to DataKinds somehow but I didn't understand how it could possibly work so perhaps I made the whole thing up
13:14:53 <nand`> rwbarton: well, A×B×C should be (A,B,C) :D
13:15:04 <nand`> A × B × C  rather
13:15:12 <shachaf> _|_ is the devil.
13:17:24 <nand`> ah
13:17:30 <shachaf> Hah, you can do: let foo :: forall (×). ((×) ~ (,)) => Int × Char; foo = (1,'a')
13:17:52 <nand`> I managed to add urgentOnHint, it was a one line change (god bless haskell): on vte beep (windowSetUrgencyHint window True)
13:19:08 <shachaf> God Bless Haskell. It's not like any other languages let you bind pre-written events to pre-written actions.
13:19:26 <nand`> shachaf: yeah, but I'd probably need an ugly lambda or at least a { } around it
13:20:25 <shachaf> vte.on_beep { window.set_urgent(true) } # disgusting!
13:21:23 <nand`> :)
13:21:26 <rwbarton> vte.setOnBeepListener(new OnBeepListener() { @Override public void onBeep(Beep b) { ... } })
13:21:59 <nand`> @Override <- is that from some real language or just made up?
13:22:00 <lambdabot> Unknown command, try @list
13:22:16 <rwbarton> It is from a quite real language.
13:22:20 <shachaf> All too real.
13:22:54 <nand`> (I know “override” from C# which means it's presumably also Java, but I've never seen the ‘@’ and capital ‘O’ like that before)
13:23:04 <Minoru> is there some library that would enable me to both create and manipulate SQL database? HDBC is kind of too low-level (I have to specify DB structure twice, once for CREATE TABLE and once in INSERTs; I also get no type-checking), HaskellDB seem to have only "manipulate" part
13:23:49 <rwbarton> (I am not a Java user let alone a Java language lawyer but basically as I understand it @Override is a recent addition to Java which somehow explains the odd syntax)
13:24:21 <rwbarton> It's like a pragma that is now standardized or effectively standardized.
13:24:32 <geekosaur> trying to avoid breaking existing progrms by stealing formerly legal variable names
13:24:49 <armlesshobo> rwbarton, nand`: i believe it's for "abstract"ed functions
13:24:53 <nand`> I see, that would explain it. I would have guessed Objective C or something since I heard that uses ‘@’ to abundance as well. Have they added default parameters yet or do you still need to write 10 boilerplate overloads?
13:24:59 <armlesshobo> to provide a class specific definition
13:25:09 <rwbarton> I know more or less what it does, I just don't know why it starts with @ :)
13:25:11 <armlesshobo> so you need to @Override the function definition
13:25:13 <nand`> armlesshobo: I'm fairly sure that's what the normal “override” keyword does
13:25:19 <nand`> or is that @Override in Java?
13:25:26 <armlesshobo> nand`: @Override in Java
13:25:37 <armlesshobo> i don't know what semantics override has in C#
13:25:45 <nand`> presumably the same as in Java
13:26:06 <nand`> just instantiating an abstract/virtual method. Though it's been a while, it could be that “override” in C# is only needed for virtual
13:26:15 <shapr[> Is there some easy way to figure out which of many imports got a particular name in scope?
13:26:16 <nand`> not worth wasting time talking about at any rate
13:26:28 <ski> nand` : `urgentOnBell',`urgentOnHint' ?
13:26:30 <nand`> shapr[: yeah, by redefining it and looking at the GHC error message
13:26:35 <armlesshobo> abstract is to java as virtual is C++
13:26:37 <armlesshobo> right?
13:26:38 <armlesshobo> lol
13:26:43 <shapr[> nand`: or I could load the module into ghci and do :i name
13:26:47 <armlesshobo> does C# have virtual too?
13:27:15 <c_wraith> armlesshobo: not exactly. abstract means "I don't have an implementation in this class". virtual means "I can be overridden"
13:27:19 <nand`> armlesshobo: C# has virtual too, which is a method that can be overridden but has a default implementation too; sort of like a haskell class function with a default body.
13:27:51 <nand`> shapr[: that works too
13:28:01 <nand`> ski: ?
13:28:19 <nand`> ski: oh, I said “urgentOnHint” earlier, I meant “urgentOnBell”
13:28:21 <armlesshobo> c_wraith: but abstract means I can have a definition, but you might want to roll your own for this child class if the one specified isn't appropriate for it, so then you'd @Override it
13:28:27 <armlesshobo> right?
13:28:39 <c_wraith> armlesshobo: no. In java, abstract means it *doesn't* have an implementation
13:28:46 <nand`> ditto for C#
13:28:49 <armlesshobo> I see
13:29:09 <armlesshobo> c_wraith: then, is there a virtual in Java?
13:29:12 <c_wraith> no
13:29:21 <c_wraith> there's final, though, which is the opposite
13:29:28 <ski> nand` : yeah in the MLs, `(A,B,C)' is the (imo nicer) `a * b * c'
13:29:41 <ski> nand` : ok, just wondering what those does ..
13:30:22 <nand`> ski: if the terminal renders a bell character (\a), instead of beeping or flashing or doing other fancy things it sets a NETWM_URGENT flag which usually has the effect of your window manager doing something nice, in my case highlighting the workspace if it's in the background
13:30:37 <armlesshobo> c_wraith: so, what's the difference between interface and abstract?
13:30:40 <nand`> that way I know if somebody highlights me over IRC while I'm not looking
13:31:20 <c_wraith> armlesshobo: an interface can't have any implementation. an abstract class can implement some (or even all) of the methods in it - it just can't be instanciated directly.
13:31:21 <ski> * uniquenick is now known as unicque
13:31:23 <nand`> armlesshobo: (In C#, grain of salt) interfaces can't contain variables (just mutators/accessors) but abstract classes can, also you can multiply inherit interfaces
13:31:38 <nand`> oh, I meant abstract classes with only abstract methods
13:31:47 <c_wraith> *instantiated
13:32:01 <ski> nand` : i see
13:33:18 <nand`> How frowned upon is -XUnicodeSyntax either way?
13:34:34 <armlesshobo> c_wraith: but can't a parent class be abstract, with implemented abstract functions, and then the child class overrides the implementation in the parent class?
13:35:49 <c_wraith> armlesshobo: you need to distinguish between abstract as applied to classes and abstract as applied to methods.  an abstract method *cannot* have an implementation.  It's a syntax error.  An abstract class can have all kinds of implementation in it - it just can't be instantiated directly.
13:36:08 <armlesshobo> ahhhh gotcha...
13:37:43 <shirt> interestingly, in C++ a pure virtual function(abstract) can actually have an implementation
13:38:03 <Minoru> so no advice on the question regarding databases? No way to define schema once and then both create and manipulate DB enjoying type safety?
13:38:31 <shapr[> Wow, diagrams works for ANY vector-space? Why haven't we seen 3D projections of 4D diagrams?
13:39:07 <c_wraith> Minoru: there might be things that can do that, but if ActiveRecord has taught us anything, it's that the pattern you describe is exceptionally fragile.
13:39:23 <shapr[> Minoru: HaskellDB
13:39:30 <cschneid> as a rubyist, I beg you never to reinvent AR.
13:39:39 <armlesshobo> shirt: that's what was throwing me off. you can specify a sort of default implementation of a virtual function, but then redefine it in the successive generations of classes.
13:39:52 <shapr[> I don't know ActiveRecord, but HaskellDB is a lot like using LINQ in C# 3.5+
13:39:58 <shapr[> or was it 3.0 that had LINQ?
13:40:10 <Minoru> shapr[: didn't find anything to create table out of Haskell description. Can you point to it?
13:40:32 <shapr[> HaskellDB can either create a table from a description, or it can create a description from an existing table.
13:40:36 <Minoru> shapr[: AFAIK, both LINQ and HaskellDB is about querying and changing, not creating
13:41:32 <Minoru> really? I must have overlooked that, shapr[. Still, can you point where that functionality resides?
13:42:22 <shapr[> Minoru: I don't remember, and I'm deep in some other code at the moment, but I have done both of those.
13:42:36 <nand`> :t (f . g) x :: Expr -- How do I get this one to not error?
13:42:37 <lambdabot>     Ambiguous type variable `a' in the constraints:
13:42:37 <lambdabot>       `SimpleReflect.FromExpr a'
13:42:37 <lambdabot>         arising from a use of `g' at <interactive>:1:5
13:42:38 <byorgey> shapr[: just because no one has written a backend for them yet.
13:42:40 <nand`> or rather
13:42:42 <nand`> > (f . g) x :: Expr -- How do I get this one to not error?
13:42:43 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:42:43 <lambdabot>    `SimpleReflect.FromExpr ...
13:42:55 <nand`> > f (g x :: Expr) :: Expr -- this one works
13:42:56 <lambdabot>   f (g x)
13:42:59 <Minoru> well, thanks anyway, shapr[; I'll look for it again, then.
13:43:09 <byorgey> shapr[: there is actually a very prototype POVRay backend for 3D diagrams, but it only does spheres so far
13:43:13 <shapr[> Minoru: If you don't find it, ask me again in a few hours, I'll have time then.
13:43:18 <rwbarton> > f (g x)
13:43:19 <lambdabot>   Ambiguous type variable `t' in the constraints:
13:43:19 <lambdabot>    `GHC.Show.Show t'
13:43:19 <lambdabot>      a...
13:43:31 <shapr[> byorgey: diagrams is stretching my brain :-)
13:43:37 <byorgey> shapr[: =)
13:43:44 <rwbarton> > let _ = [f,g] in f (g x)
13:43:45 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:43:45 <lambdabot>    `SimpleReflect.FromExpr t...
13:44:08 <byorgey> shapr[: whatcha doing with diagrams?
13:44:22 <rwbarton> > foldr (.) id [f,g] x
13:44:24 <lambdabot>   f (g x)
13:44:37 <armlesshobo> >
13:44:48 <shapr[> byorgey: Trying to get raw SVG out of diagrams-svg.. chrisdone's jquery-console should be able to handle that output, I think.
13:45:10 <nand`> > let [a,b] = [f,g] in f (g x)
13:45:11 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:45:11 <lambdabot>    `SimpleReflect.FromExpr t...
13:45:12 <nand`> err
13:45:14 <shapr[> jquery-console can handle a raw DOM node, according to line 450 orso...
13:45:15 <nand`> > let [a,b] = [f,g] in a (b x)
13:45:16 <lambdabot>   f (g x)
13:45:28 <nand`> > let [f',g'] = [f,g] in (f' . g') x
13:45:29 <rwbarton> cute
13:45:30 <lambdabot>   f (g x)
13:45:40 <rwbarton> > let [a,b] = [f,g] in f (g x)
13:45:41 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:45:41 <lambdabot>    `SimpleReflect.FromExpr t...
13:45:45 <rwbarton> oh right
13:46:01 <rwbarton> different uses of g can be at different types, of course
13:46:36 <shirt> armlesshobo: only in c++ though. in c# an abstract method cannot have a "default" implementation
13:46:45 <armlesshobo> shirt: so it seems :)
13:47:15 <armlesshobo> interface in Java is strange to me. is there some sort of RL purpose for it?
13:47:25 <nand`> armlesshobo: multiple inheritence?
13:47:34 <nand`> or do you mean as in real-world real-world
13:47:46 <armlesshobo> lol
13:47:58 <c_wraith> Yeah, the point of interfaces is to allow multiple inheritance without creating the diamond dependency problem.
13:48:14 <hughfdjackson> surely it goes beyond that
13:48:20 <nand`> interfaces are surprisingly reminiscent of Haskell classes
13:48:30 <hughfdjackson> that is, beyond just multiple inheritance
13:49:05 <hughfdjackson> sometimes you want to specify API w/o specifying *any* behaviour; to leave a blank space for whatever functionality you want
13:49:16 <nand`> ie. you can write a method that is polymorphic over all types T that implement interface I
13:49:24 <nand`> not unlike :: forall t. I t =>
13:49:29 <hughfdjackson> it's a more formal way of achieving what you do by ducktyping in dynamic libraries, i'd imagine
13:49:41 <armlesshobo> i see
13:49:43 <hughfdjackson> ofc, it gets around with diamond problem too
13:49:52 <monochrom> the point of interfaces is we need interfaces
13:49:52 <Minoru> shapr[: Database.HaskellDB.DBSpec.DBSpecToDatabase.dbSpecToDatabase does the trick, if I understand correctly. Thanks!
13:49:59 <hughfdjackson> but i'd never have thought of that as the intent of them
13:50:13 <shirt> Minoru: that looks scary
13:50:26 <hughfdjackson> (not that listening to me when it comes to java is a good idea)
13:50:31 <shapr[> Minoru: yay!
13:50:48 <shapr[> Minoru: I started with an existing database and used the "existing db to spec" to learn how specs work.
13:51:00 <nand`> thing is, if you have general purpose multiple inheritence you can just use abstract classes with only abstract members as makeshift “interfaces”; so what they themselves bring to the table is just that
13:51:21 <armlesshobo> but wouldn't abstract classes take care of that issue, too?
13:52:08 <nand`> I can't answer, I'm not quite sure what a diamond dependency issue is or how interfaces solve them. All I know is that that's their purpose
13:52:45 <c_wraith> Interfaces solve them by making diamond dependency impossible
13:53:03 <c_wraith> since you can only inherit from one implementation
13:53:52 <c_wraith> You can inherit from multiple interfaces though, giving you subtyping with implementation inheritance.
13:54:24 <c_wraith> err, *without* implementation inheritance
13:54:28 <Cale> hughfdjackson: Well, I think the central problem with Java and many other typed OO languages is that they tie method implementations to the types -- you implement methods in the class definition, not in the objects. So you have to make classes which aren't abstract at some point.
13:54:46 <kallisti> c_wraith: you can emulate specific types of inheriance pretty well.
13:55:03 <kallisti> for example implementing different behavior over the same underlying set of members can be done via phantom typing.
13:55:43 <tac-tics> Cale: Sounds like a mathematician's thinking... the notion that you could run code without a concrete implementation.
13:55:45 <tac-tics> :)
13:56:17 <Cale> tac-tics: I'm not asking for the concrete implementation to go away, I'm saying it shouldn't be part of the class definition.
13:56:17 <kallisti> I don't think that's what he meant, exactly. :P
13:56:52 <Cale> The implementations of the methods are value-level things, not type level things, and should be part of the *objects* belonging to that class.
13:57:12 <Cale> But a lot of OO programmers don't think that way, because they're not used to having first class procedures.
13:57:26 <tac-tics> yeah
13:58:04 <tac-tics> Cale, by that do you mean that Interfaces ought to be the main feature of OO languages, rather than classes?
13:58:12 <tac-tics> or something analogous
13:58:27 <hpaste> nand` pasted “vte terminal” at http://hpaste.org/70133
13:58:33 <hughfdjackson> that's my reading of what you're saying too, Cale ^^
13:58:36 <tac-tics> ... I guess where objects extend interfaces rather than classes
13:58:47 <Nimatek> I think an OO language should have functions first class as well.
13:58:54 <hughfdjackson> Nimatek: everything should :p
13:59:01 <hughfdjackson> once you've got it, it's too sweet to give up
13:59:22 <kallisti> Cale: that could be interesting. essentially you could use a mix of traditional static OO with prototyping.
13:59:35 <lolcathost> Nimatek: Heh, my main complaint about OO languages is that they glorify one argument in every function call... which seems ridiculous.
13:59:40 <Nimatek> Indeed, And soething like function objects or anonymous classes as sort-of-lambdas is just hideous.
14:00:06 <kallisti> Cale: in fact if all data is immutable then the prototyping would occur implicitly.
14:00:15 <Cale> tac-tics: more or less, yeah
14:00:20 <lolcathost> Nimatek: Also, I designed one text that shows why Haskell's type classes are superior to OO's inheritance/interfaces.
14:00:24 <lolcathost> test*
14:00:27 <monochrom> thought they are imperative programmers, the prospect of "mutable methods" is too much for their normally mutable minds. unlike us who eat "data R = R { method :: IORef (Int -> IO Int) }" for breakfast!
14:00:34 <monochrom> s/thought/though/
14:00:39 <lolcathost> Nimatek: It is a sort of man-boy test for type systems.
14:00:43 <Nimatek> lolcathost: Which test?
14:00:55 * Nimatek is interested.
14:01:04 <lolcathost> Nimatek: Doing this without singletons - http://ideone.com/ubq5a
14:01:07 <Cale> The whole point of OO is that objects are values whose meaning is determined by their responses to messages.
14:01:34 <nand`> Java's type system doesn't even let you define monads because you can't abstract over type parameters of a kind other than *
14:01:35 <tac-tics> Cale: That's an interesting thought.
14:01:39 <nand`> why bother comparing them :P
14:02:00 <tac-tics> nand`: Java's generics is like the story of the bear riding the motorcycle at the circus.
14:02:09 <unlink> is there a way to express this applicatively without join?    join $ encodeM4A dest <$> readMetadata src <*> decodeOgg src
14:02:10 <Cale> Inflexibly requiring all objects of the same class to have the same implementation of method handlers results in annoyingly fine class hierarchies where the methods are all the same, but the implementations are different.
14:02:19 <lolcathost> Nimatek: Because declaring a class with no data members / informational content only to get around a limitation of the type system seems ridiculous.
14:02:28 <tac-tics> Pay not mind to how well the bear rides the motorcycle. What's amazing is he can ride it at all.
14:02:49 <nand`> tac-tics: hehe
14:02:58 * kallisti didn't interpret "mutable methods" out of any of this.
14:03:19 <Cale> unlink: probably not
14:03:33 <tac-tics> nand`: Moreover, I would think Java's type system is broken enough to coerce *->* to  *
14:04:18 <nand`> unlink: the RHS is already applicatively given, so the only difference is the added “join $”. Applicatives don't have join, join is what separates them from monads
14:04:34 <Nimatek> lolcathost: Yes, that sort of stuff would again be hideous in something like Java.
14:04:37 <lolcathost> tac-tics: Also, it has no higher-kinded type classes.
14:05:21 <tonyk> <plug> if any of you peeps need to upload a file use this: http://pile.io </plug>
14:05:40 <lolcathost> Nimatek: You would have to declare an abstract generic singleton corresponding to the CanMate<A,B>, and concrete singletons derived from it corresponding to the instances.
14:06:24 <lolcathost> But singletons are horrible. As I said, these singletons would have absolutely no informational content, so why make them types?
14:14:25 <unlink> I have a function of type `Metadata -> Handle -> IO ()'. How can I phrase the application of an `IO Metadata' and `IO Handle' using just (>>=)? Or do I need fmap/join?
14:16:19 <navaati> unlink:
14:16:20 <navaati> :t liftA2
14:16:21 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
14:16:48 <navaati> hum, err, actually no
14:16:57 <kqr_> is there any function along the lines of `Maybe (Maybe a, Maybe b) -> Maybe (a, b)'? i couldn't find one on hoogle
14:17:25 <kqr_> (if there isn't, i'll just make my own)
14:18:04 <navaati> :t app
14:18:05 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
14:18:22 <unlink> navaati: Yes, but that gives me   IO Metadata -> IO Handle -> IO (IO ())  thus requiring me to use `join' (or `>>= id').
14:18:41 <navaati> unlink: yeah, yeah, sorry, that was an error x)
14:18:52 <fmap> @type join . liftM (uncurry (liftA2 (,)))
14:18:53 <lambdabot> forall a b (f :: * -> *). (Monad f, Applicative f) => f (f a, f b) -> f (a, b)
14:19:00 <ocharles> that is magic.
14:19:17 <navaati> :t Kleisli join
14:19:18 <lambdabot> forall (m :: * -> *) b. (Monad m) => Kleisli m (m (m b)) b
14:19:34 <joeyh> I'm trying to call the FreeBSD kevent() via the FFI, but my calls to it always seem to be interrupted by a SIGALRM.
14:19:45 <ocharles> :t liftA2 (,)
14:19:46 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
14:20:03 <joeyh> if anyone knows FFI, I could really use a hand
14:21:18 <Clint> joeyh: what's your foreign import line?
14:22:46 <joeyh> foreign import ccall unsafe "libkqueue.h waitchange_kqueue" c_waitchange_kqueue :: Fd -> IO Fd
14:22:46 <byorgey> unlink: io_metadata >>= \m -> io_handle >>= \h -> f m h
14:23:06 <joeyh> this library has the same problem: https://github.com/hesselink/kqueue/
14:24:56 <unlink> byorgey: right, pointfully. ok, thanks.
14:25:40 <byorgey> @pl io_metadata >>= \m -> io_handle >>= \h -> f m h
14:25:40 <lambdabot> (io_handle >>=) . f =<< io_metadata
14:25:46 <byorgey> ugh
14:25:54 <unlink> hahaha
14:27:26 <t7> i wonder if github for windows will go open source, considering how much OSS they built it with....
14:28:59 <shapr[> w00t! prototype is working! http://www.scannedinavian.com/~shae/svgdemo.png
14:29:15 <t7> what is it?
14:29:57 <shapr[> t7: It's a hint interpreter returning an SVG diagram via jquery-console
14:30:23 * t7 googles jquery-console
14:31:24 * armlesshobo queries t7's cached search results
14:31:31 <nand`> :t \n c -> null . dropWhile ((<2) . realPart . abs) . take n $ iterate ((c+) . (^2)) 0
14:31:32 <lambdabot> forall a. (RealFloat a) => Int -> Complex a -> Bool
14:31:35 <nand`> Mandelbrot :D
14:31:52 <nand`> ..I hope
14:32:14 <t7> so like server side interpreter sending output to the client?
14:32:18 <geekosaur> joeyh, +RTS -V0 should work around it (you may need to compile with -rtsopts)
14:33:19 <shapr[> t7: right
14:33:25 <shapr[> t7: https://github.com/shapr/ghclive/
14:33:46 <shapr[> t7: working jquery-console example under prototypes/jqueryconsole
14:33:51 <t7> is it rendering that on the browser?
14:34:21 <HairyDude> right, I have a module Foo that imports and exports Data.Monoid, and another module Bar that imports Foo
14:34:33 <HairyDude> I'm using GHC 7.4.2, so Data.Monoid contains (<>)
14:34:45 <HairyDude> but Bar is reporting that (<>) isn't in scope
14:35:00 <HairyDude> I'm not hiding it
14:35:01 <shapr[> t7: yup, I'm actually using diagrams-svg to get a Text result, and then wrapping that in Aeson...
14:35:06 <shapr[> man, I'm using MANY libraries.
14:35:40 <Peaker> HairyDude, Foo has "import Data.Monoid" and in export list "module Data.Monoid"?
14:35:42 <t7> you should send javascript back
14:35:47 <Peaker> HairyDude, and Bar has "import Foo" ?
14:35:50 <t7> save the server load :)
14:36:43 <HairyDude> ... oh, I see. Yesod.Import doesn't actually import (<>) if you have GHC >=7.0.4...
14:37:07 <HairyDude> ... and it defines its own (<>), but only if you have GHC <7.0.4...
14:37:27 <armlesshobo> anyone ever use clckwrk?
14:37:37 <HairyDude> that is, it doesn't import (<>) at all, and only defines it if you have old GHC
14:38:04 <Peaker> HairyDude, I dislike re-exports of exposed modules... Why not have people import stuff from its canonical place?
14:38:13 <luite> t7: the javascript codegens are still not good enough to run diagrams with reasonable performance on the client
14:38:30 <luite> t7: it does work though
14:38:35 <kallisti> Peaker: some libraries are built on top of others in such a way that the re-exported functions are essential to using it.
14:38:55 <luite> t7: if you're prepared to wait half a minute for a relatively simple diagram that is
14:39:14 <Peaker> kallisti, sure, so all users will have another import.. I think that's better than having to guess whether the operator is actually the same or just named identically
14:39:15 <t7> maybe me but not joe bloggs
14:39:20 <t7> joe c# coder
14:39:27 <joeyh> geekosaur: thanks, trying.. is this a known problem?
14:39:35 <kallisti> Peaker: I just wait for GHC to yell at me. :P
14:39:42 <geekosaur> I'm not sure it's a problem per se
14:39:44 <joeyh> geekosaur: hmm, no luck :/
14:40:14 <Peaker> kallisti, The problem is it might yell at your user, rather than at you, when someone does some innocent change like add another exported name somewhere or decide to export a different (<>)
14:40:17 <joeyh> whoops, typoed, retying
14:41:13 <luite> t7: i guess two things can work then, either the javascript code generators can be improved, or you convince byorgey to remove all polymorphism from diagrams
14:41:14 <geekosaur> in any case, if it's that sensitive to interrupts, you might want to write a C wrapper which blocks SIGALRM, makes the call, and unblocks it.  or declare it as safe instead of unsafe, but that might not work with a threaded program
14:41:18 <joeyh> geekosaur: ok, you were right. so, what's going on here?
14:41:50 <joeyh> hmm, so the SIGALARM is to do with threading? Unfortunatly, I will be using this in a threaded code (not -threaded runtime tho)
14:42:26 <shapr[> armlesshobo: clckwrk hasn't been out for very long, has it?
14:42:30 <shapr[> armlesshobo: I do know the author though.
14:42:38 <shapr[> stepcut: What do you think of clckwrk?
14:43:20 <geekosaur> yes, it has to do with the runtime's context switching and garbage collection.  with -V0 it uses a less efficient mechanism to do it.
14:43:46 <geekosaur> it occurs to me the correct way to fix it is a wrapper function which retries it if it returns -1 with errno == EINTR
14:44:21 <joeyh> possibly, unless it keeps getting alarm after alarm
14:44:26 <joeyh> let me try that, good idea
14:44:39 <geekosaur> it will get them regularly
14:45:01 <geekosaur> this is expected; the runtime does it to interrupt its internal select()/poll() call for that reason
14:45:22 <joeyh> well, regularly yes, constantly is my concern :)
14:45:37 <geekosaur> proper POSIX programs should always expect to retry syscalls on -1/EINTR
14:46:14 * joeyh does seem to remember something about that :)
14:46:18 <Peaker> I really would appreciate a warning from GHC that my specified types are not as general as possible
14:46:28 <joeyh> even reads() .. funny how nothing does
14:46:45 <Peaker> joeyh, event loops do retry on reads properly
14:47:49 <geekosaur> yeh, lots of people are lazy, because glibc implements much of the retry looping internally for most syscalls.  but (a) there are exceptions and (b) gibc doesn't help *BSD, Solaris, OS X, etc.
14:48:19 <joeyh> yeah, and for extra bonus fun, I'm developing on a system with a glibc userland, and freebsd kernel
14:48:23 * shapr[ lazily evaluates his code.
14:48:31 <geekosaur> actually I think the BSDs restart many syscalls also, but polling-type functions are a specific exception
14:48:56 <joeyh> quite possibly Debian's kevent() wrapper omits some restarting that is normally done..
14:49:16 <geekosaur> because they are usually what you want to interrupt in that case, and the most common reaction is just to iterate your polling loop
14:49:33 <joeyh> yay, works with manual restart
14:51:07 <daniel_-> should i split this function up? http://paste.ofcode.org/DWgHM5xznLBkuw2LdZVa6p
14:51:26 <Peaker> btw, this syscall restarting business is exactly the example used by the "worse is better" paper
14:52:11 <shachaf> id `all` is usually called and
14:52:46 <joeyh> Peaker: lol
14:52:59 <shachaf> You might just say isUnique [] = True; isUnique (x:xs) = all (/=x) xs && isUnique xs or something like that.
14:53:20 <monochrom> isUnique xs = all (`elem` xs) xs
14:53:26 <joeyh> if someone has a real BSD system (or perhaps OSX), I'd be curious if you're seeing this kevent thing on it
14:53:36 <joeyh> (I have a simple testcase you could run)
14:53:40 <monochrom> err, logic error :)
14:53:58 <geekosaur> joeyh, I have been trying to explain that it is normal and expected behavior
14:54:01 <monochrom> isUnique xs = all (\x -> not (x `elem` xs)) xs
14:54:11 <shachaf> monochrom: That won't really work...
14:54:18 <geekosaur> select() and poll() behave the same way
14:54:25 <joeyh> geekosaur: agreed, except as noted it could me normally masked by libc
14:54:34 <shachaf> isUnique [] = True; isUnique (x:xs) = x `notElem` xs && isUnique xs -- or something
14:54:41 <ocharles> monochrom: that doesn't exclude the item your searching for, does it?
14:54:46 <ocharles> so elem is always True
14:54:56 <shachaf> elem is always a function.
14:55:05 <Peaker> more efficient:  isUnique = null . filter (not . null . drop 1) . group . sort
14:55:16 <monochrom> right, I need to re-think
14:55:22 <ocharles> x `elem` xs then is always true, if you want to be pedantic
14:55:25 <shachaf> Peaker: Or something with Set.
14:55:36 <shachaf> Peaker: I was trying to keep the function basically the same. :-)
14:55:43 <geekosaur> not for these functions it won't be.  I guess my explanations have been failing to make sense to you
14:55:45 <Peaker> can use Set.fromList and compare lengths, yeah
14:55:58 <Peaker> > let isUnique = null . filter (not . null . drop 1) . group . sort in map isUnique ["abc", "aba"]
14:56:00 <lambdabot>   [True,False]
14:56:03 <ocharles> Set.fromList would require Ord a
14:56:27 <ocharles> just use isUnique xs = nub xs == xs and optimize it later
14:56:32 <Peaker> ocharles, Yeah, but it uses it for extra bonus efficiency
14:57:07 <monochrom> well, I was just rewriting the given code
14:57:08 <shachaf> The (not . null . drop 1) sort of pattern sort of annoys me.
14:57:10 <shachaf> (Sort of.)
14:57:39 <ocharles> > let isUnique xs = nub xs == xs in map isUnique ["abc", "aba"]
14:57:40 <lambdabot>   [True,False]
14:57:51 <daniel_-> i will use the function for my mastermind game so the user cant submit two of the same colors :)
14:58:04 <joeyh> geekosaur: the reason I'm unsure is there's a kqueue library in hackage, and it seems to trivially have the problem.. I'd have thought the author would have noticed it if it affected real BSD systems
14:58:10 <shachaf> @src nub
14:58:10 <lambdabot> nub = nubBy (==)
14:58:13 <shachaf> @src nubBy
14:58:14 <lambdabot> nubBy eq []             =  []
14:58:14 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:58:35 <geekosaur> they wouldn't have because the timer tick is newish in ghc (7.2+, I think)
14:58:35 <shachaf> Hmm, maybe that actually turns out to be as good as the other list-based one.
14:58:47 <ocharles> that's why you start simple and profile :)
14:59:00 <joeyh> ah, ok
14:59:03 <geekosaur> it's been affecting other programs that don't retry their operations on EINTR as well, there just aren't many such programs
14:59:05 <shachaf> ocharles: That's not how IRC works, man.
14:59:07 <ocharles> haha
14:59:22 <ocharles> @pl isUnique xs = nub xs == xs
14:59:23 <lambdabot> isUnique = (==) =<< nub
14:59:25 <ocharles> that's how irc works!
14:59:50 <Peaker> @type [(=<<), (<*>)]
14:59:51 <lambdabot> forall a b. [(a -> a -> b) -> (a -> a) -> a -> b]
15:00:12 <geekosaur> most programs delegate that to GHC's runtime, which transparently handles them.  if you do your own blocking I/O via the FFI, you will see the problem; this is not something you're "supposed" to do with GHC, but is unavoidable in some cases (e.g. the ghc runtime wouldn't know what to do with a kqueue)
15:00:26 <Peaker> (==) <*> nub    is somewhat readable :)
15:01:07 * joeyh pulls the source to hinotify to see how they dealt with it there
15:01:13 <geekosaur> xmonad sees it on blocking X11 event polling calls, for example (I think it could be redesigned to hand that off to the ghc runtime, but it hasn't been done)
15:01:16 <ocharles> > let isUnique = (==) <*> nub in map isUnique ["abc", "aba"]
15:01:17 <lambdabot>   [True,False]
15:01:21 <ocharles> magic
15:01:30 <ocharles> i still prefer the pointy format
15:01:32 <luite> in which ghc version was (<>) = mappend added?
15:01:36 <geekosaur> 7.2.1
15:01:48 <joeyh> ah, uses hWaitForInput so avoids it, ok
15:01:53 <ocharles> is the (<>) mappend alias in prelude?
15:02:01 <luite> geekosaur: tnx
15:02:03 <ocharles> excuse my absolute lack of google there
15:02:30 <Peaker> TH macros ruining forward-references is really annoying. Most TH macros don't need to reify everything..
15:03:17 <ocharles> > let isUnique xs = any (\x -> length (filter (== x) xs) > 1) xs  in map isUnique ["abc", "aba"]
15:03:19 <lambdabot>   [False,True]
15:03:23 <ocharles> oops :)
15:03:26 <kqr_> when you use record syntax on constructors, can you choose to export only a few of the functions?
15:03:28 <ocharles> > let isUnique xs = not $ any (\x -> length (filter (== x) xs) > 1) xs  in map isUnique ["abc", "aba"]
15:03:29 <lambdabot>   [True,False]
15:03:49 <ocharles> @pl isUnique xs = not $ any (\x -> length (filter (== x) xs) > 1) xs
15:03:49 <lambdabot> isUnique = not . (any =<< flip flip 1 . (((>) . length) .) . flip (filter . (==)))
15:03:58 <ocharles> now that's the irc answer i was expecting
15:04:07 <geekosaur> kqr_, name them.  Foo(A,B) is a perfectly good export spec for the A and B data contructors of the Foo type
15:04:22 <geekosaur> if that's what you meant
15:05:04 <nand`> geekosaur: I think he meant the accessors
15:05:05 <geekosaur> if you meant in patterns, I'm not sure what you meant exactly.
15:05:11 <kqr_> geekosaur, in this case, I have the type `data A = B { oneThing :: Int, anotherThing :: String }' and I want to *only* export `A' and `anotherThing'
15:05:47 <geekosaur> I think you just export the accessor as a function, and not export any constructors
15:05:54 <kqr_> okay, thanks
15:05:55 <kqr_> i'll try that
15:07:22 <hughfdjackson> :/ is it unusual to find the way rwh does the JSON chapter a sticking point?
15:08:16 <tac-tics> hughfdjackson: what part don't you like about it?
15:08:19 <hughfdjackson> you have to go through a lot of unexecutable code before they finally even start fleshing out the data type of which the chapter hangs.. so if you want to test things in ghci, it seems you're out of luck almost entirely
15:08:23 <hughfdjackson> that ^
15:10:05 <hughfdjackson> :/ it's possible i'm just doing something wrong somewhere/mis-read them
15:11:18 <fmap> json chapter in rwh is horrible
15:11:59 <hughfdjackson> fmap: for the reason mentioned, or another one?
15:14:24 <fmap> hughfdjackson: yes, i was discouraged by small useless pieces of strange code all over the chapter when was trying to understand it
15:15:18 <hughfdjackson> ^^ yay, at least it's not just me
15:15:51 <tac-tics> fmap: That seems to be a common theme in lots of haskell blogs, papers, and tutorials
15:17:58 <hpc> fmap: that's one thing i try to avoid when i write about haskell
15:18:26 <hughfdjackson>  
15:18:27 <hpc> when i include "demonstrative" code in a post, i make it obviously incomplete
15:18:47 <hughfdjackson> *i'm just going to skip this chapter and see how i get on
15:18:49 <hpc> when i include "here's how it works" code, i make sure it will compile, and include a message to put it in a file yourself before continuing
15:18:56 <armlesshobo> has anyone ever successfully built/install Gtk as a shared lib with cabal?
15:19:14 <hpc> armlesshobo: cabal install gtk2hs-buildtools --global
15:19:34 <hpc> followed by cabal install gtk --whatever-flags-you-need
15:20:02 <hpc> armlesshobo: that will at the very least get it to building
15:20:21 <armlesshobo> hpc: it's built, but I want to be able to dynamically link
15:20:31 <hpc> ah
15:20:35 <hpc> uh
15:21:06 <armlesshobo> so, I tried reinstalling Gtk with the --enable-share flag, but it complained about Pango's dynamic lib not being found
15:21:43 <hpc> hmm
15:22:05 <armlesshobo> so, before I went to play around with (read: potentially destroy) anything, I'd ask here first :)
15:22:38 <hpc> hmm
15:22:40 <kqr_> geekosaur, if you're curious, Type(..) will export the accessors too. if you don't export everything, you can export the accessors as functions separately. if you do both, ghc will issue a warnin
15:22:45 <kqr_> geekosaur, g
15:29:10 <hughfdjackson> i hope this isn't a silly mistake
15:29:42 <hughfdjackson> is `isEqual = not . isntEqual` equivilent to `isEqual a b = not $ isntEqual a b`?
15:29:52 <shachaf> No.
15:30:02 <shachaf> Just expand the definition of (.) yourself to see that.
15:32:28 <hpc> hughfdjackson: for extra credit, expand "isEqual = not .: isn'tEqual" with (.:) = fmap fmap fmap
15:32:43 <hpc> also, "'" is a legal character, use contractions right ;)
15:33:11 <Peaker> hughfdjackson, not . isntEqual  means you apply "not" to the *direct* result of "isntEqual".   If    isntEqual :: a -> (a -> ...)        then the "not" applies to the (a -> )
15:33:45 <Peaker> hughfdjackson, basically you want to apply a function to the result of the result of isntEqual, that's the "..." part (which is Bool, of course)
15:34:14 <Peaker> To apply a function f to the result of the result of x, you can use SEC notation:    (result . result) f x
15:34:24 <Peaker> much nicer than :. or "fmap fmap fmap" IMO
15:34:40 <hughfdjackson> so composition would try to pass a partially applied version of isEqual through not?
15:34:50 <Peaker> hughfdjackson, yeah
15:35:07 <hpaste> listofoptions pasted “evaluations.midori” at http://hpaste.org/70137
15:35:10 <hughfdjackson> :3 here i was thinking that it was auto-currying that'd let me get away with it
15:35:19 <ion> curry (not . uncurry isntEqual) :-P
15:35:30 <hughfdjackson> thanks for clarifying (nearly typed currifying) that for me :D
15:36:20 <hughfdjackson> hpc: :D cheers for the isn'tEqual tip too
15:36:36 <hughfdjackson> i'm so used to not being at liberty to use that
15:36:42 <hpc> same
15:37:21 <ion> ' is a kluge that approximates at least ’, ‘ and ′, and in Haskell names its almost always the last one.
15:38:07 <hughfdjackson> as in foldl'?
15:38:31 <MostAwesomeDude> I can't read ion's Unicode (stupid weechat), but yes, as in "foldl prime".
15:38:53 <hpc> clearly we should be using (d/dx)foldl
15:39:13 <hpc> MostAwesomeDude: not unicode
15:39:13 <ion> mostawesomedude: I’m using WeeChat, it has no problems with Unicode (except with combining characters).
15:39:37 <MostAwesomeDude> hpc: I see " ' is a kluge that approximates at least ?, ? and ? "
15:39:53 <parcs`> there should be a 'Set k -> Map k ()' function in containers
15:40:13 <MostAwesomeDude> parcs`: I would imagine that patches are welcome.
15:40:13 <hpc> MostAwesomeDude: oh, they're smartquotes, i think then
15:40:21 <shachaf> MostAwesomeDude: So your IRC client's Unicode support is broken. Good to know.
15:40:26 <shachaf> hpc: Huh?
15:40:33 <parcs`> MostAwesomeDude: but, i don't want to patch, i just want to complain!
15:40:41 <MostAwesomeDude> shachaf: Yeah, it's pretty broken. Dunno why, but I can't bring myself to fix it.
15:40:51 <shachaf> MostAwesomeDude: I think that makes you racist or something.
15:40:52 <hpc> they look like plain old quotes to me, but my font doesn't try to make every unicode char uniquely rendered
15:41:09 <ion> mostawesomedude: Your locale settings are probably wrong.
15:41:14 <MostAwesomeDude> shachaf: Probably. :c
15:41:16 <MostAwesomeDude> ion: Probably! :c
15:41:21 <_Vi> Is it OK to export additional functions from module just because of they need to be tested with HUnit?
15:41:53 <shachaf> _Vi: I think it's common to make a .Internal module and re-export the relevant functions from the non-.Internal module.
15:42:52 <_Vi> The implementation in "Something.Internal" thing and only proxies in  "Something" itself?
15:43:18 <shachaf> _Vi: Right.
15:43:21 <Peaker> in C world there's a common "trick" of #include'ing the implementation in unit tests to gain access to its unexported functions
15:43:26 <shachaf> _Vi: See e.g. Data.ByteString.
15:44:06 <hpc> Peaker: oh wow, clever
15:45:24 * Peaker sends a ".... you" to nvidia too
15:46:00 <Peaker> they keep automatically changing their "PowerMizer" settings to "Adaptive power profile" which lowers the performance just below 60fps so I get 30fps and icky animations
15:46:10 <Peaker> and I keep having to set it back
15:53:18 <Peaker> mapReaderT seems to be inconsistent with mapStateT/mapWriterT -- it does not give you the entire content of the ReaderT, just the action
16:02:32 * hackagebot couchdb-conduit 0.8.2 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.8.2 (AlexanderDorofeev)
16:06:41 <_Vi> How to make string literal of "\x10A" where "A" is separate letter, not continuation of "\x10"?
16:07:04 <geekosaur> "\x10\&A"
16:07:24 <geekosaur> > "\x10\&A"
16:07:25 <lambdabot>   "\DLEA"
16:07:35 <hpc> > length "\&"
16:07:36 <lambdabot>   0
16:07:40 <geekosaur> bot not smart enough to produce it on output...
16:07:54 <rwbarton> I never thought that would be the answer to a legitimate question on #haskell.
16:07:58 <rwbarton> > "\SO\&H"
16:07:59 <lambdabot>   "\SO\&H"
16:08:01 <geekosaur> (I think that's actualy showList :: Char that is failing though)
16:08:24 <wrm> Learning haskell and have a problem.  Readig the Wikibook and there is an implementation of scanr that goes like this: scanr3 step zero xs = foldr step' [zero] xs where step' x xs = (step x (head xs)):xs
16:08:44 <hpc> rwbarton: wait what
16:08:50 <rwbarton> (Everyone knows that \DLE is an escape sequence but \DLEA is not, right?)
16:08:51 <wrm> what I find odd is that step' calls step with x which is the list [zero]
16:09:10 <rwbarton> hpc: what what
16:09:17 <rwbarton> > length "\SOH"
16:09:18 <lambdabot>   1
16:09:26 <rwbarton> so it can hardly produce "\SOH"
16:09:26 <hpc> > "\SO\&H"
16:09:28 <lambdabot>   "\SO\&H"
16:09:28 <geekosaur> I guess.  is kinda horrid
16:09:40 <hpc> why is it outputting \&?
16:09:47 <rwbarton> What else should it output?
16:10:02 <hpc> nothing?
16:10:02 <rwbarton> \SOH is also an escape sequence.
16:10:10 <rwbarton> > "\SOH" == "\SO\&H"
16:10:11 <lambdabot>   False
16:10:11 <hpc> wait... oh
16:10:13 <hpc> oh i see
16:10:21 <hpc> it's "escaping" again on output
16:10:24 <hpc> to dodge ambiguity
16:10:26 <rwbarton> Yeah
16:10:29 <geekosaur> the old ASCII control names are all fixed, so it knows that \DLEA can't be an escape sequence
16:10:31 <hpc> veeeeeery clever
16:10:51 <geekosaur> but it adds it in that case, where \SO and \SOA are both valid escapes
16:13:32 <wrm> Hi anyone got some patience for a newbie ?
16:13:51 <hpc> hello
16:13:58 <hpc> ah, scanr
16:14:00 <c_wraith> wrm: probably. just ask your questions.
16:14:04 <wrm> I'm learning Haskell and have a problem.  Reading the Wikibook, there is an implementation of scanr that goes like this: scanr3 step zero xs = foldr step' [zero] xs where step' x xs = (step x (head xs)):xs
16:14:08 <tac-tics> wrm: all #haskell has infinite patience
16:14:13 <wrm> :-)
16:14:19 <wrm> What I find odd is that step' calls step with x which is the list [zero].  So if I call scanr (+) 0 [1,2,3] then (+) will receive a list. Why does this work?
16:14:56 * hpc gets his head around scanr, after last using it never ago :P
16:15:03 <hpc> > scanr (+) z [1,2,3]
16:15:04 <lambdabot>   [1 + (2 + (3 + z)),2 + (3 + z),3 + z,z]
16:15:22 <HairyDude> @src scanr
16:15:22 <lambdabot> scanr _ q0 []     =  [q0]
16:15:22 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
16:15:22 <lambdabot>     where qs@(q:_) = scanr f q0 xs
16:15:33 <hpc> ah, here we go
16:15:37 <rwbarton> xs would be [zero], not x
16:15:45 <mustelo> wrm, it doesn't call it on the list, x is the head of the list
16:16:06 <hpc> wrm: are you comfortable with foldr?
16:16:13 <rwbarton> (I mean "step'"'s xs)
16:16:38 <wrm> just learning about folds
16:17:08 <hpc> wrm: okay, quick explanation of foldr
16:17:19 <hpc> you have your list, [1,2,3]
16:17:28 <wrm> ok
16:17:30 <hpc> which is sugar for (1:(2:(3:[])))
16:17:52 <hpc> now, foldr takes a function, a value, and a list
16:17:59 <hpc> or more interestingly, it takes a function and a value
16:18:06 <hpc> and returns a computation that replaces (:) with the function
16:18:10 <hpc> and [] with the value
16:18:36 <hpc> foldr (<+>) z (1:(2:(3:[])))
16:18:37 <hpc> =
16:18:38 <wrm> ok
16:18:51 <hpc> 1 <+> (2 <+> (3 <+> z))
16:19:17 <rwbarton> right, so note here that z will appear as the second argument to <+>
16:19:59 <wrm> ok
16:20:01 <hpc> now look at this again and spot the folds
16:20:10 <hpc> > scanr (+) z (1:(2:(3:[])))
16:20:11 <lambdabot>   [1 + (2 + (3 + z)),2 + (3 + z),3 + z,z]
16:21:13 <hpc> the first element is just the result of foldr with the same arguments
16:21:28 <hpc> the second element is the same fold, only applied to (2:(3:[]))
16:21:37 <hpc> next element is the same fold applied to (3:[])
16:21:45 <hpc> last element is the fold applied to []
16:22:11 <hpc> so what the result looks like is
16:22:29 <hpc> (a:(b:(c:(zero:[]))))
16:22:32 <hpc> or something like that
16:23:05 <hpc> so when we reach the end of the list we scan over, the result we get is zero
16:23:13 <hpc> but we need to end the list with (zero:[])
16:23:14 <hpc> or
16:23:16 <hpc> [zero]
16:24:04 <hpc> don't worry if that didn't make sense; copy it to a text file along with the source of scanr and foldr
16:24:09 <hpc> and pour through it yourself
16:24:14 <hpc> it took me a while to get too
16:24:19 <wrm> ok, good suggestion
16:24:33 <wrm> where is the real source for scanr/flodr
16:24:47 <rwbarton> @where hoogle
16:24:48 <lambdabot> http://haskell.org/hoogle
16:24:49 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#foldr
16:24:52 <rwbarton> go here
16:24:56 <rwbarton> type in scanr
16:25:02 <rwbarton> and click on the Source link on the right
16:25:05 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#scanr
16:25:06 <wrm> ah, ok
16:25:27 <wrm> thanks all, I will need some time to think about that :-)
16:25:29 <rwbarton> (click on the result for scanr first)
16:25:54 <nobdraisentone> How can I get value c from these runSTArray function? http://hpaste.org/70139
16:26:26 <nobdraisentone> I'm trying to return (arr,c), but there is a problem with runSTArray
16:26:49 <mustelo> wrm, if you haven't seen the pictures on http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29 , they are pretty and may help
16:27:04 <hpc> nobdraisentone: you don't want to return STArrays from ST actions
16:27:09 <hpc> er
16:27:17 <hpc> you don't want to runST actions that contain those arrays
16:27:23 <hpc> er, return
16:27:30 <hpc> lemme start over
16:27:38 <hpc> "mutable references cannot escape ST"
16:27:54 <hpc> and when you try, it manifests as a type error
16:28:03 <rwbarton> his program is using runSTArray
16:28:08 <rwbarton> I presume it works, just it does not return c
16:28:23 <hpc> well i feel stupid
16:28:41 <nobdraisentone> rwbarton: that's right
16:29:02 <rwbarton> you should use, uh ... freezeArray or unsafeFreezeArray or something like that
16:29:30 <hpc> freezeArray copies, unsafeFreezeArray doesn't
16:29:38 <rwbarton> right
16:29:47 <rwbarton> runSTArray is basically just unsafeFreezeArray plus runST
16:30:14 <hpc> i don't see how runSTArray is safe
16:30:37 <rwbarton> because it knows the unsafeFreezeArray is at the end of the computation
16:30:41 <rwbarton> the array cannot change any more
16:30:55 <hpc> oh duh
16:31:09 <rwbarton> apparently it's actually just called 'freeze'/'unsafeFreeze'
16:32:11 <rwbarton> http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-MArray.html#v:unsafeFreeze
16:32:18 <rwbarton> "Note that because the array is possibly not copied, any subsequent modifications made to the mutable version of the array may be shared with the immutable version. It is safe to use, therefore, if the mutable version is never modified after the freeze operation."
16:33:25 <rwbarton> so you can replace line 5 by the two lines "arr' <- unsafeFreeze arr; return (arr', c)" and runSTArray by runST (and fix the type signature)
16:35:50 <ski> hm, using `unsafeInterleaveST' with `runSTArray' would be unsafe
16:38:54 <Peaker> what is unsafeInterleaveST for?
16:39:15 <Peaker> I understand the "usefulness" of the IO one for lazy I/O
16:42:03 <hpc> Peaker: for when you need the performance bonus of predictable evaluation strategies, and the rigorous semantics of IO
16:47:35 * hackagebot couchdb-conduit 0.8.3 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.8.3 (AlexanderDorofeev)
16:48:16 <rwbarton> maybe for generating an infinite list of random numbers with an RNG whose state is in ST?
16:49:38 <hpc> ooh, that makes sense
16:49:52 <Peaker> why? Just use randoms?
16:49:53 <hpc> and even sounds like a smart idea
16:50:10 <lolcathost> @type get
16:50:12 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
16:50:26 <hpc> Peaker: implement your own RNG with mutation and mutation and a pure interface in haskell :P
16:50:51 <lolcathost> @type runState
16:50:52 <lambdabot> forall s a. State s a -> s -> (a, s)
16:51:26 <Eduard_Munteanu> Maybe you forgot a "P"? :P
16:51:47 <hpc> the "P" is implied, imo
16:52:07 <hpc> unless they go out of their way to say otherwise
16:52:39 <Eduard_Munteanu> Admittedly you might get some entropy out of unsafe functions :P
16:54:13 <ski> Peaker : let's say you're computing a tree in `ST s', and that the computation generating the left sub-tree and the one generating the right sub-tree uses disjoint states. then you can safely use `unsafeInterleaveST' on one of these, to decouple the two sub-compuations from each other (basically you split your state thread into two disjoint sub-threads)
16:54:52 <Peaker> ski, why not runST on each of them separately then?
16:55:00 <Peaker> (if they're truly decoupled?)
16:55:43 <ski> Peaker : hm, i suppose both may read from state which you promise will never change more
16:55:59 <ski> (s/more/anymore/)
16:56:01 <Peaker> ski, might as well freeze it then?
16:56:31 <ski> might be hard to do if the state is scattered in small parts, e.g. some being hidden inside closures
16:56:54 <ski> (s/some/references to some/)
16:57:13 <ski> possibly there is a better example of its use ..
16:58:33 <Phlogistique> anyone knows how to do comments in Pandoc Markdown?
16:59:05 <Phlogistique> (Markdown converted to LaTeX with Pandoc)
16:59:13 <Phlogistique> (the % get escaped :()
17:00:03 <bitonic> @google markdown comments
17:00:05 <lambdabot> http://stackoverflow.com/questions/4823468/store-comments-in-markdown-syntax
17:00:05 <lambdabot> Title: Store comments in Markdown syntax - Stack Overflow
17:00:30 <bitonic> Phlogistique: I'd try that.
17:02:09 <bitonic> Phlogistique: also, https://github.com/jgm/pandoc/issues/254
17:03:11 <Phlogistique> bitonic: oh, I didn't know it would remove the comment in the LaTeX output
17:03:13 <Phlogistique> thanks
17:04:22 <ski> hm, the example in the paper is reading a file
17:05:45 <rwbarton> of unsafeInterleaveST?
17:09:53 <smtshskcs> Hi guys i have a typsynoyme question, i wrote the function in my notepad...but i cant implement it in my cmd...can you look to at plz ?
17:09:54 <smtshskcs> http://pastebin.com/uB1x5qm1
17:09:56 <mauke> The paste uB1x5qm1 has been copied to http://hpaste.org/70140
17:11:04 <smtshskcs> i tried  getBookAuthors (_, "Tittle")  but it didnt work
17:11:40 <adu> smtshskcs: _ is a pattern, not an expression
17:12:13 <adu> smtshskcs: try getBookAuthors ("foo", ["bar", "baz"])
17:14:24 <smtshskcs> adu: well yeah , it worked...i thoought that _ means that i dont care what i write
17:14:27 <smtshskcs> adu: :D
17:15:02 <sipa> smtshskcs: that's correct *in patterns*
17:15:20 <sipa> you can use undefined in expressions
17:15:32 <smtshskcs> sipa: got it, thank you very much ))
17:15:40 <smtshskcs> adu: thx
17:17:48 <adu> smtshskcs: no, it means I don't care what I read
17:18:23 <smtshskcs> adu: hmm, ok !
17:19:29 <monochrom> use two-player thinking. caller and callee. the _ pattern means that the callee doesn't care. the caller still has to provide something.
17:20:33 <smtshskcs> thx for the example
17:20:47 <monochrom> two-player thinking will become even more important when you later reason about polymorphic types such as "a->a"
17:21:33 <sipa> the caller can decide not to pass any useful value (undefined), but that means an error will occur if the callee tries to use it
17:21:33 <adu> does two player thinking help with monad transformers?
17:21:57 <monochrom> "Hi I wrote f :: a -> a, f 0 = 1, and I get a type error. doesn't a->a mean I can use any time I want?"  is an example of lack of caller-callee two-player thinking.
17:22:00 <adu> > undefined
17:22:01 <lambdabot>   *Exception: Prelude.undefined
17:22:14 <adu> > snd (undefined, "hello")
17:22:15 <lambdabot>   "hello"
17:22:40 <smtshskcs> oh yeah, i  was also reading this morning about polymorphic functions...this example was very from you guys
17:23:01 <monochrom> s/time/type/
17:25:56 <lolcathost> @pl f x = forM_ ns $ exists >=> x
17:25:57 <lambdabot> f = forM_ ns . (exists >=>)
17:27:00 <lolcathost> @pl f ns x = forM_ ns $ exists >=> x
17:27:01 <lambdabot> f = (. (exists >=>)) . forM_
17:27:12 <Peaker> yay. The partial type inference and type checking has no known bugs now :-)
17:27:21 <lolcathost> Peaker, ?
17:27:48 <Peaker> lolcathost, Writing a structural interactive editor for a Haskell-like language, it does type-inference as you edit/on-the-fly
17:27:58 <Peaker> and shows type errors as conflicting types whereever they conflict
17:28:21 <lolcathost> Oh, that is what you meant.
17:28:23 <lolcathost> :P
17:28:38 <Peaker> I can't wait to use this instead of a text editor :)  Just to work on this we've had to debug type errors by staring at code and figuring out the sub-expression types, manually, by wasting a lot of effort/brain cycles
17:28:58 <Peaker> the editor gives you type information even on an incomplete/type-b0rked program! which is so nice
17:29:13 <mgsloan> Peaker: Yeah, I've experienced that while working on my type information thing
17:29:23 <mgsloan> it's kinda a feedback loop of motivation
17:30:13 <Peaker> Staring at type errors is also de-motivating in a sense..  You have a temptation to say "fuck it, let's go to the way it worked before"
17:30:36 <Peaker> and the reason we end up staring at type errors is simply because of the dead/non-interactive process
17:31:05 <Peaker> mgsloan, btw, did you run bottle recently? :)
17:34:06 <lolcathost> @pl undoable action = do { s <- get ; result <- runError action ; case result of { Left _ -> put s ; Right _ -> return () } ; return result }
17:34:07 <lambdabot> (line 1, column 22):
17:34:07 <lambdabot> unexpected "{"
17:34:07 <lambdabot> expecting variable, "(", operator or end of input
17:35:31 <lolcathost> Anyone more or less understands what I am trying to do?
17:36:04 <lolcathost> @pl undoable action = do { s <- get ; result <- runErrorT action ; case result of { Left _ -> put s ; Right _ -> return () } ; return result }
17:36:05 <lambdabot> (line 1, column 22):
17:36:05 <lambdabot> unexpected "{"
17:36:05 <lambdabot> expecting variable, "(", operator or end of input
17:38:00 * hackagebot js-good-parts 0.0.1 - Javascript: The Good Parts -- AST & Pretty Printer  http://hackage.haskell.org/package/js-good-parts-0.0.1 (SeanSeefried)
17:39:23 <ski> Peaker : do you use type error slicing ideas to display the exact locations (among the ones which are determined) which contributes to the type error ?
17:39:38 <lolcathost> @pl undoable action = get >>= \s -> runErrorT action >>= \result -> (case result of { Left _ -> put s ; Right _ -> return () }) >> return ()
17:39:39 <lambdabot> (line 1, column 17):
17:39:39 <lambdabot> unexpected "="
17:39:39 <lambdabot> expecting variable, "(", operator or end of input
17:39:48 <Peaker> ski, not yet, but it shouldn't be hard.. we use a union-find, and can rather easily keep track of the source of each unify call
17:41:15 <HairyDude> haskell-src-exts is taking forever to compile...
17:41:45 <Peaker> ski, should be able to have a bunch of icon shortcuts in each inferred type that you can use to jump to a contributor of that type
17:42:26 <Peaker> lolcathost, "case" is not supported in @pl, I think. You can use the "either" function
17:42:32 <lolcathost> Oh.
17:42:38 <HairyDude> I really need to get more memory for building stuff
17:42:39 <Peaker> lolcathost, your last "return ()" seems redundant
17:42:52 <lolcathost> Peaker: The last one is return result
17:42:57 <lolcathost> Peaker: Not return ()
17:43:16 <ski> (Peaker : i assume you've seen <http://www.macs.hw.ac.uk/ultra/skalpel/> before, yes ?)
17:43:23 <lolcathost> well
17:43:24 <lolcathost> dinner time
17:43:26 <lolcathost> thanks by the way
17:43:52 <Peaker> @pl undoable action = get >>= \s -> runErrorT action >>= \result -> (either (const (put s)) (const (return ())) result) >> return result
17:43:52 <lambdabot> undoable = (get >>=) . (. flip (ap . ((>>) .) . flip either (const (return ())) . const . put) return) . (>>=) . runErrorT
17:44:22 <Peaker> ski, I think so.. we use a very different approach..
17:45:18 <Peaker> ski, we don't have HM types, but SystemF types.  We do have outside-in inference and not just inside-out inference as usual in type-checking, but all the type variables are explicit
17:46:03 <ski> Peaker : btw, re nice language-aware editor idea, you might want to steal the idea from DrScheme^WDrRacket of being able to hover over an identifier, and get an arrow which points from it to it's binding location, in case you're hovering over the binding location, you get arrows pointing to all references of it (and you can make the arrows persistent so you don't have to hover)
17:47:04 <Peaker> ski, well, we're very keyboard-oriented, at least at first.. if you press <return> on anything, it jumps to its binding (including a param)
17:47:05 <ski> Peaker : if you have macros, then this should ideally work for macros that introduce bindings as well
17:47:16 <Peaker> and we do intend to have something that shows all uses of a currently-selected definition/param
17:47:31 <ski> Peaker : yeah, the nice thing with the arrows is that you can get pointers to each use
17:47:44 <ski> (and an export from a module should count as a use, as well)
17:47:53 <Peaker> pointers to each use? What do you mean?
17:48:24 <ski> if you hover over the first `x' in `(lambda (x) (+ x x)' you see two arrows pointing from it to the two latter `x's
17:48:41 <ski> (s/x\)/x\)\)/)
17:49:26 <shachaf> ski: What, (lambda (x)) (+ x x))?
17:49:40 <shachaf> Oh, you didn't use /g.
17:49:44 <shachaf> Still broken. :-(
17:49:46 <ski> hehe, you're supposed to use angelic nondeterminism :)
17:50:14 * shachaf hasn't heard of that one before.
17:50:25 <ski> (ftr, i meant `(lambda (x) (+ x x))')
17:50:28 <Peaker> ski, arrows that actually go all the way? It sounds like it might be cluttered? why not just highlight?
17:50:53 * applicative cant seem to build this bottle; darn BerkeleyDB
17:50:58 <ski> shachaf : angelic nondeterminism is when there's nondeterminism, you get the choice (or choices) which "work out in the end for you", if any
17:51:11 <Peaker> applicative, You need to have a specific version of the c library installed (I think 4.7/4.8)
17:51:29 <ski> shachaf : demonic nondeterminism is when the "system" arbitrarily chooses an alternative for you, and you have to cope with what's served
17:52:53 <applicative> Peaker, ah
17:52:54 <ski> shachaf : backtracking in Prolog and the list monad implement angelic nondeterminism -- demonic nondeterminism is generated by (non-declarative) concurrency (race conditions),randomness,partial specifications ("undefined behaviour")
17:53:35 <Peaker> ski, it's like universal vs. existential?
17:53:44 <shachaf> ski: Wiktionary has a more strict definition: (computing) A notional ability always to choose the most favorable option, in constant time.
17:53:47 <shachaf> With angelic non-determinism, any problem in NP would be solvable in polynomial time.
17:54:25 <ski> angelic / all-solutions nondeterminism is described by the Hoare powerdomain preorder, while demonic / committed-choice nondeterminsm is described by the Smyth powerdomain preorder
17:55:09 <shachaf> ski: Isn't "demonic" the kind that chooses the worst possible alternative?
17:55:53 <ski> shachaf : those may be stronger interpretations -- in practice you "assume the worst may happen" with demonic nondeterminism
17:56:10 <ski> (even if in practice you might not commonly get the worst alternative)
17:56:14 <shachaf> I think what you called "demonic" I'd think of as "plain old nondeterminism".
17:56:28 <shachaf> You assume the worst may happen if you want to write correct code.
17:56:43 <ski> Peaker : yes, consider a preorder `A', now we want to define a preorder on the powerset of `A'
17:58:13 <ski> Peaker : in the Hoare/angelic case, we say `S =< T  <=>  forall x \in S. exists y \in T. x =< y' -- meaning that if we go from `S' to `T' we may both add elements to `S', and we may replace elements of  `S' with greater elements
17:58:57 <ski> Peaker : while in the Smyth/demonic case, we say `S =< T  <=>  forall y \in T. exists x \in S. x =< y' -- meaning that if we go from `S' to `T' we may both *remove* elements from `S', and we may replace elements of `S' with greater elements
18:00:07 <ski> let's say the preorder on `A' is the definedness ordering
18:00:23 <RosePerry_> testing 1-2-3. can anyone read this?
18:00:32 <otters> nope
18:00:35 <otters> sorry
18:00:53 <RosePerry_> ha thanks. Any idea why I can't connect to the c++ irc?
18:01:23 <RosePerry_> The error I get is "Can't send to room "##c++" on "irc.freenode.net"."
18:02:06 <rwbarton> I think maybe you have to register your nick to send to ##c++.
18:02:17 <Miko_> need help
18:02:17 <Draconx> RosePerry_, for help with the freenode network, try #freenode.
18:02:25 <RosePerry_> Draconx: Thanks!
18:04:39 <ski> then in the Hoare case, if we want to claim that a given set, when it's fully computed, will contain an element satisfying property `P', then all we need to do is find an element in the current approximation of the set which satisfies `P'
18:05:36 <ski> but in the Smyth case, if we want to claim that a given set, when it's fully computed, will contain an element satisfying property `P', then we need to check *every* element of the current approximation, since we don't know which of them will be present at the end
18:05:59 <ski> (in the Smyth case, this is presuming that we never remove all elements, which is a common restriction)
18:06:13 <lolcathost> :O ?
18:06:48 <ski> shachaf : yes, but what happens in Prolog is also commonly known as "nondeterminism"
18:13:02 * hackagebot copilot-sbv 0.6 - A compiler for CoPilot targeting SBV.  http://hackage.haskell.org/package/copilot-sbv-0.6 (LeePike)
18:13:04 * hackagebot sifflet-lib 1.2.5.1 - Library of modules shared by sifflet and its  tests and its exporters.  http://hackage.haskell.org/package/sifflet-lib-1.2.5.1 (GregoryWeber)
18:18:06 * hackagebot sifflet 1.2.5.1 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-1.2.5.1 (GregoryWeber)
18:18:21 <applicative> Peaker, well I have defined 'square x = x * x'
18:19:40 <applicative> Peaker: this editor will take a little study :)
18:23:02 * hackagebot bioace 0.0.1 - Library for reading ace assembly files  http://hackage.haskell.org/package/bioace-0.0.1 (DanFornika)
18:28:03 * hackagebot biophd 0.0.1 - Library for reading phd sequence files  http://hackage.haskell.org/package/biophd-0.0.1 (DanFornika)
18:28:05 * hackagebot bioalign 0.0.5 - Data structures and helper functions for calculating alignments  http://hackage.haskell.org/package/bioalign-0.0.5 (DanFornika)
18:56:25 <Shou-> Is it possible to use guards in a case of statement? This seems to say so http://www.haskell.org/haskellwiki/Case#Guards but I may be misunderstanding the syntax, since it doesn't seem to be working for me.
18:56:27 <yulys> edwardk is around?
18:56:47 <shachaf> Shou-: Yes, it is. But you still need to match something.
18:56:51 <yulys> edwardk: reflection?
18:56:51 <geekosaur> Shou-, pastebin what you're trying?
18:56:57 <shachaf> case () of _ | ... -> ... | ... -> ...
18:59:55 <Shou-> geekosaur: http://hpaste.org/70141
19:00:29 <parcs`> Shou-: is that a parse error?
19:00:30 <geekosaur> and?  what is the issue, then?
19:00:34 <Shou-> Yeah
19:00:52 <geekosaur> oh, I get it
19:00:58 <parcs`> Shou-: you have to indent the | a little more
19:01:02 <geekosaur> | needs to be indented relative to the _
19:01:24 <geekosaur> we usually set it up a little differently to minimize the indentation
19:02:07 <hpaste> geekosaur annotated “case of guards” with “case of guards (annotation)” at http://hpaste.org/70141#a70142
19:03:08 <geekosaur> basically if the | is indented less than or equal to the _ then a semicolon is inserted
19:03:50 <Shou-> Oh, alright. Thanks!
19:07:33 <geekosaur> you could say that indentation / layout has strict but easy to understand rules; instead of trying to guess at whether you're contnuing an expression or not, you have to be explicit about it by indenting farther for continuations.  (and yes, the _ | ... | ...  is one large expression as far as the compiler is concerned, and could be combined onto a single line))
19:09:14 <shachaf> > case case()of()|()==()->()of()|()==()->()
19:09:15 <lambdabot>   ()
19:12:45 <applicative> > ["haskell","python","php"] >>= \lang -> case () of  _ | lang == "haskell" ->  "Yeah!" | otherwise -> "No!"
19:12:46 <lambdabot>   "Yeah!No!No!"
19:12:55 <parcs`> disappointing lack of view patterns
19:14:06 <applicative> > ["haskell","python","php"] >>= \lang -> case () of  _ | lang == "haskell" -> lang ++ ":   Yeah!" | otherwise -> lang ++ ":  No!  "
19:14:08 <lambdabot>   "haskell:   Yeah!python:  No!  php:  No!  "
19:14:43 * applicative 's Shou- imitation could use some work
19:15:20 <parcs`> > case()of(case()of_->0->0)->()
19:15:22 <lambdabot>   <no location info>: parse error on input `->'
19:15:38 <parcs`> > case()of((case()of_->0)->0)->()
19:15:39 <lambdabot>   <no location info>: parse error on input `->'
19:16:14 <applicative> the second case there isn't a pattern
19:17:15 <parcs`> > let f((let_=()in0)->0) = 0
19:17:16 <lambdabot>   <no location info>: parse error on input `='
19:17:30 <parcs`> looks like you can't have arbitrary expressions inside view patterns
19:17:40 <parcs`> how unregular
19:18:33 <parcs`> > let f ((let _ = () in 0) -> 0) = 0 in ()
19:18:34 <lambdabot>   ()
19:19:06 <applicative> > let f((let _ = () in 0) ->0) = 0
19:19:07 <lambdabot>   not an expression: `let f((let _ = () in 0) ->0) = 0'
19:19:25 <parcs`> > case()of((case()of()->0)->0)->()
19:19:26 <lambdabot>   ()
19:19:27 <applicative> grr
19:19:34 <parcs`> how regular
19:24:56 <monochrom> > let one_large_pat | 1==0 = "not this" | 2<1 = "not this" | 3>2 = "yes this" | 4>=5 = "not this" in one_large_pat
19:24:57 <lambdabot>   "yes this"
19:28:06 * hackagebot vector-clock 0.1.1 - Vector clocks for versioning message flows  http://hackage.haskell.org/package/vector-clock-0.1.1 (AlexandruScvortov)
19:44:38 <james-ubc> uggh i realy wish lyah had a comment section
19:48:39 <Refried__> if I have a list of writers over bool, and I want to return a new writer that appends everything that was written, and returns the logical conjunction over all those booleans, is there a oneliner? :-)
19:51:14 <parcs`> :t fmap all . sequence
19:51:15 <lambdabot>     Couldn't match expected type `a -> Bool'
19:51:15 <lambdabot>            against inferred type `[a1]'
19:51:15 <lambdabot>       Expected type: [f a1] -> f (a -> Bool)
19:51:30 <parcs`> :t fmap and . sequence
19:51:31 <lambdabot> forall (f :: * -> *). (Functor f, Monad f) => [f Bool] -> f Bool
19:51:34 <parcs`> yay!
19:51:44 <Refried__> thanks!
19:53:20 <ski> note that this will append *everything* written by the sub-actions, not doing any short-circuiting based on the booleans
19:53:38 <Refried__> ski: thanks -- that is what i wanted in this case
19:53:38 <ski> (you seemed to want this here, just making sure)
19:54:25 <ski> Refried__ : .. it might be a good idea to add a comment to the code that this is what you actually want to do (if it's not apparent from the context)
19:54:39 <Refried__> ski: good idea
19:55:26 <Refried__> pretty much nothing its going to be apparent from the context; i'm actually writing this in scalaz and hoping none of my coworkers murders me
19:55:40 <ski> s/scalaz/Scala/ ?
19:56:02 <Refried__> ski: scalaz is a haskell-inspired library for scala
19:56:07 <ski> ok, i see
19:56:50 <Refried__> sometimes i think it's safer to ask questions here, and then scratch my head and figure out how to port them to scalaz, than ask the same question in #scalaz and get yelled at for my ignorance :-\
20:00:16 * ski thinks #haskell ususally manages to provide a helpful&friendly atmosphere conducive to learning
20:00:50 * Ralith wonders why this is
20:02:56 <dmwit> eh, f Bool is not the right type for a Writer All foo...
20:03:13 <dmwit> If that's what you have, then you just want sequence (or perhaps sequence_).
20:04:03 <dmwit> (@Refried__)
20:04:41 <Refried__> hmm let me try to understand that
20:05:09 <ski> suggestion : try to treat newbies in other channels in the same way we commonly treat them here : with patience, willingness to try to see things from the perspective of them (being overwhealmed by all the new concepts) and willingness to explain "basic things", assuming the best intensions (if not given evidence to the contratry), explaining "why" and not just "what" (e.g. why this is usually a bad thing to do), &c.
20:06:10 <blackdog> ski: i think a big part is haskell's gentle but unbounded learning curve
20:06:12 <ski> (though, too much hand-holding isn't always good either -- they have to show a willingness to learn, instead of just having it all served)
20:06:35 <blackdog> there are far fewer people here who think that they're gods of haskell. almost everyone has a significant amount to learn - it keeps you humble.
20:06:35 <ski> i think it also helps that we mix simple and complicated, practical and theoretical topics in here
20:06:54 <ski> blackdog : point
20:06:56 <Refried__> I've been reading Learn You a Haskell; I think the atmosphere in here is similar
20:07:07 <Refried__> "haskell is fun and cool"
20:08:38 <milk_> +1 :)
20:09:06 <Refried__> in #scalaz the atmosphere is often "everything is self-evident from the types and source; if discussion is still necessary, you are incapable of learning";  it gets demotivating after a while
20:09:12 <ski> preflex: xseen BONUS
20:09:12 <preflex>  BONUS was last seen on freenode/#haskell 1 year, 50 days, 7 hours, 41 minutes and 14 seconds ago, saying: yeah i think that's better as well
20:09:22 <Refried__> even though it's essentially the same ideas, just different syntax
20:09:22 <ski> (BONUS is the author of LYAH)
20:09:28 <dmwit> xseen?
20:09:41 <dmwit> preflex: xseen BONUS_
20:09:42 <preflex>  BONUS_ was last seen on freenode/#haskell 2 years, 193 days, 13 hours, 24 minutes and 52 seconds ago, saying: osaunders_: usually i think it's defined as a function that uses only the stuff it takes as parameters and function application
20:10:01 <ski> dmwit : variant of `seen' which checks all the networks `preflex' is on
20:10:20 <Refried__> ski: *nod* on the LYAH page it says he hangs out here as BONUS, but I guess it's out of date :-)
20:10:21 <blackdog> Refried__: I've just got back from a railscamp, and a bunch of people there had just gone through LYAH in a study group
20:10:30 <Refried__> Yeah?
20:10:47 <blackdog> i think a lot of them hadn't seen haskell at all, so they didn't know that monads & functors & applicatives were big scary complicated concepts
20:10:51 <blackdog> so they just learned them and had fun:)
20:11:06 <Refried__> yes -- and awesome
20:11:06 <dmwit> > sequence_ [tell (All True), tell (All False), tell (All True)] :: Writer All () -- Refried__
20:11:07 <lambdabot>   No instance for (GHC.Show.Show
20:11:07 <lambdabot>                     (Control.Monad.Trans.Wri...
20:11:08 <Refried__> that's great
20:11:12 <dmwit> eh
20:11:26 <dmwit> > runWriter (sequence_ [tell (All True), tell (All False), tell (All True)])
20:11:27 <lambdabot>   ((),All {getAll = False})
20:11:44 <Refried__> > :t All
20:11:44 <rwbarton> > runWriter (sequence_ [tell (All True), tell (All False), tell (All undefined)])
20:11:45 <lambdabot>   ((),All {getAll = False})
20:11:46 <lambdabot>   can't find file: L.hs
20:11:52 <rwbarton> nifty
20:11:59 <rwbarton> oh
20:12:09 <rwbarton> > execWriter (sequence_ [tell (All True), tell (All False), undefined])
20:12:10 <lambdabot>   All {getAll = False}
20:12:13 <rwbarton> nifty
20:12:28 <dmwit> It still runs all the actions. Just the monoid bit is lazy.
20:12:45 <ski> dmwit : oh -- i interpreted Refried__ as having a list of actions which writes something and returns `Bool's -- but you have actions which writes `Bool's (well `All's) there
20:13:28 <Refried__> yes, list of actions which write something and return bool
20:13:55 <ski> @type All
20:13:56 <lambdabot> Bool -> All
20:14:00 <ski> @type getAll
20:14:02 <lambdabot> All -> Bool
20:14:12 <dmwit> ?src All
20:14:13 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:14:21 <dmwit> newtype All = All { getAll :: Bool }
20:15:11 <dmwit> There's also newtype Any = Any { getAny :: Bool } with the other obvious Monoid instance.
20:15:42 <ski> Refried__ : `data All = All {getAll :: Bool}',`data Any = Any {getAny :: Bool}' with `instance Monoid All where mempty = All True; mappend (All b0) (All b1) = b0 && b1' and  `instance Monoid Any where mempty = Any False; mappend (Any b0) (Any b1) = b0 || b1'
20:16:30 <ski> (er, with `... = All (b0 && b1)' resp. `... = Any (b0 || b1)', i.e.)
20:16:56 <dmwit> Hey, neat: sets with union/intersection are representable as (a -> Any)/(a -> All).
20:18:06 <dmwit> ?src (>>) Writer
20:18:07 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:18:07 * hackagebot js-good-parts 0.0.2 - Javascript: The Good Parts -- AST & Pretty Printer  http://hackage.haskell.org/package/js-good-parts-0.0.2 (SeanSeefried)
20:18:09 * hackagebot postgresql-simple 0.2 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.2 (LeonSmith)
20:18:22 <dmwit> rwbarton: Actually, I'm really surprised that last one is defined. What just happened?
20:18:59 <dmwit> Shouldn't asking whether undefined matches the pattern (a, m) result in _|_?
20:19:05 <rwbarton> something about strict Writer vs. lazy Writer
20:19:16 <dmwit> oh, ~(a, m) is better maybe
20:19:17 <rwbarton> lazy Writer has a let-bound (a, m)
20:19:32 <dmwit> Okay, makes sense, then.
20:19:37 <dmwit> agreed, nifty =)
20:19:40 <JoeyA> Tip for programming in Haskell: code really fast, or just wait for that to happen.  ^
20:20:17 <ski> @let forAll :: Data.Foldable.Foldable t => t a -> Cont Bool a; forAll = cont . flip Data.Foldable.all
20:20:19 <lambdabot>  Defined.
20:20:26 <ski> @let forAny :: Data.Foldable.Foldable t => t a -> Cont Bool a; forAny = cont . flip Data.Foldable.any
20:20:28 <lambdabot>  Defined.
20:20:33 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id)
20:20:34 <lambdabot>  Defined.
20:20:35 <ski> @let evalContT :: Monad m => ContT o m o -> m o; evalContT = (`runContT` return)
20:20:37 <lambdabot>  Defined.
20:20:46 <ski> > evalCont $ do x <- forAll [2,3,5]; return (x < 10)
20:20:48 <lambdabot>   True
20:20:49 <ski> > evalCont $ do x <- forAll [2,3,5]; return (x < 4)
20:20:51 <lambdabot>   False
20:21:34 <ski> > evalCont $ do x <- forAll [2,3,5,7]; y <- forAny [0,1,4,9]; return (x < y)
20:21:36 <lambdabot>   True
20:21:50 <ski> > evalCont $ do y <- forAny [0,1,4,9]; x <- forAll [2,3,5,7]; return (x < y)
20:21:52 <lambdabot>   True
20:22:11 <ski> > evalCont $ do y <- forAll [0,1,4,9]; x <- forAny [2,3,5,7]; return (x < y)
20:22:13 <lambdabot>   False
20:22:30 * ski likes these `forAll' and `forAny', for some reason
20:24:22 <ski> > runWriter (sequence_ [tell (All True), tell (All False), undefined])
20:24:23 <lambdabot>   ((),All {getAll = False})
20:24:39 <ski> > runWriter (sequence [tell (All True), tell (All False), undefined])
20:24:40 <lambdabot>   ([(),(),*Exception: Prelude.undefined
20:24:45 <ski> dmwit ^
20:25:50 <ski> the point is that `Writer w' is lazy in the sense that e.g. executing `repeatM act' is productive
20:26:17 <ski> > ((snd &&& fst) . runWriter . sequence) [tell (All True), tell (All False), undefined]
20:26:19 <lambdabot>   (All {getAll = False},[(),(),*Exception: Prelude.undefined
20:27:13 <ski> > ((snd &&& fst) . runWriter . mapM (tell . (: []))) [0 ..]
20:27:15 <lambdabot>   ([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
20:28:45 <parcs`> > runWriter (fmap and (sequence [tell True, tell False, undefined]))
20:28:46 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:28:46 <lambdabot>         against inferred type ...
20:28:59 <parcs`> > runWriter (fmap and $sequence [tell True, tell False, undefined])
20:29:00 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:29:00 <lambdabot>         against inferred type ...
20:29:06 <ski> no `Monoid Bool' instance
20:29:38 <ski> > (runWriter . mapM (tell . (: []))) [0 ..]
20:29:40 <lambdabot>   ([(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(...
20:30:19 <parcs`> > runWriter (fmap and $ sequence [return True, return False, undefined])
20:30:22 <lambdabot>   (False,())
20:30:26 <parcs`> yay
20:30:35 <ski> > ((snd &&& fst) . (`runState` 0) . mapM (\n -> get >>= \acc -> put (acc + n) >> return acc)) [0 ..]
20:30:40 <lambdabot>   mueval: ExitFailure 1
20:30:41 <lambdabot>  mueval: Prelude.undefined
20:30:57 <ski> hrm
20:31:00 <ski> > ((snd &&& fst) . (`runState` 0) . mapM (\n -> get >>= \acc -> put (acc + n) >> return acc)) [0 ..]
20:31:04 <lambdabot>   mueval-core: Time limit exceeded
20:31:07 * ski nods
20:31:09 <ski> > ((`runState` 0) . mapM (\n -> get >>= \acc -> put (acc + n) >> return acc)) [0 ..]
20:31:11 <lambdabot>   ([0,0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,2...
20:31:47 <ski> so in this case, the value yielded by executing the action is defined, but the final state isn't (quite naturally)
20:31:54 <ski> so `State s' is also lazy in this sense
20:33:52 <monochrom> as usual, "___ is lazy" is grossly inadequate and misleading. lazy in which component?
20:34:13 <ski> > ((`runReader` 0) . foldr (\n act -> ask >>= \env -> local (+ n) (act >>= \envs -> return (env : envs))) (error "never reached")) [0 ..]
20:34:15 <lambdabot>   [0,0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,25...
20:34:24 <ski> and `Reader r' as well
20:34:33 <ski> monochrom : *nod*
20:36:09 * ski isn't quite sure how to formalize the concept he has in mind here in a uniform way
20:37:33 <yulys> hi guys, I was trying to run the example of reflection : https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
20:37:55 <yulys> but I got this error message: julita@yulys:~$ gedit Monoid.hs
20:37:57 <yulys> julita@yulys:~$ runhaskell Monoid.hs
20:38:01 <yulys> Monoid.hs:3:8:
20:38:03 <yulys>     Could not find module `Data.Proxy':
20:38:05 <yulys>       Use -v to see a list of the files searched for.
20:38:07 <yulys> julita@yulys:~$
20:38:09 <yulys> any help?
20:38:36 <ski> > ((snd &&& fst) . (`runState` 0) . (>>= \accs -> put 42 >> return accs) . mapM (\n -> get >>= \acc -> put (acc + n) >> return acc)) [0 ..]
20:38:39 <lambdabot>   (42,[0,0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,23...
20:39:44 <ski> yulys : have you installed the package `tagged' ?
20:39:50 <ski> @hackage tagged
20:39:50 <lambdabot> http://hackage.haskell.org/package/tagged
20:48:38 <james-ubc> > (+) <$> (*2) <*> (+10)
20:48:39 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
20:48:40 <lambdabot>    arising from a use of `...
20:53:33 <james-ubc> christ
20:53:46 <ski> > ((+) <$> (*2) <*> (+10)) 100
20:53:47 <james-ubc> does anything on lyah actually work!?!
20:53:48 <lambdabot>   310
20:54:06 <james-ubc> > (+) (<$> (*2) <*> (+10)) 1
20:54:08 <lambdabot>   The operator `Data.Functor.<$>' [infixl 4] of a section
20:54:08 <lambdabot>      must have lowe...
20:54:32 <james-ubc> > ((+) <$> (*2) <*> (+10)) 1
20:54:33 <lambdabot>   13
20:54:34 <ski> > ($ 100) $ (+) <$> (*2) <*> (+10)
20:54:36 <lambdabot>   310
20:55:01 <ski> `(+) <$> (*2) <*> (+10)' itself is a function, and as such, can't be printed
20:55:32 <ski> (does LYAH claim otherwise ?)
20:55:44 <james-ubc> let f = (*3)  y = ( + 10) in (f y ) 10
20:55:50 <james-ubc> > let f = (*3)  y = ( + 10) in (f y ) 10
20:55:52 <lambdabot>   <no location info>: parse error on input `='
20:56:05 <james-ubc> > let f = (*3);  y = ( + 10) in (f y ) 10
20:56:06 <lambdabot>   60
20:56:53 <james-ubc> wtf
20:56:58 <james-ubc> why does it work here and not in ghci
20:57:47 <ski> because lambdabot has `instance Num a => Num (rho -> a) where fromInteger n = \_ -> n; f + g = \n -> f n + g n; ...' in it
20:58:05 <ski> @where L.hs
20:58:06 <lambdabot> What lambdabot has in scope is at <http://code.haskell.org/lambdabot/State/L.hs>
20:58:25 <ski> i think it's `Data.NumInstances' in there which brings this instance into scope
20:59:16 <shachaf> james-ubc: Just use (.).
20:59:19 <shapr> ski: JavaScript Monads is on hold until next year :-(
20:59:23 <shachaf> Even if it works you shouldn't do it.
21:00:00 <james-ubc> it's on the lyah site
21:00:11 <shachaf> What is?
21:00:18 <james-ubc> ski:  did not understand a single word of that
21:00:29 <james-ubc> sortof but still not really
21:00:37 <ski> this instance isn't normally in scope for mostly the same reason that `instance Monad (rho ->)' and `instance Monad (w ,)' aren't in scope : enabling these would convert type errors caused by typo / forgotten or extra argument into well-typed code (probably not doing what you intended)
21:01:10 <james-ubc> the stuff i just entered was from learn you a haskell for great good chapter "for a few monads more"
21:01:29 <ski> james-ubc : basically, lambdabot has an instance which makes any function which returns a number into a "number"
21:01:52 <ski> > (sin + cos) (pi / 8)
21:01:53 <lambdabot>   1.3065629648763766
21:01:57 <ski> > (sin^2 + cos^2) (pi / 8)
21:01:59 <lambdabot>   1.0
21:02:26 <ski> > sin (pi / 8) + cos (pi / 8)
21:02:27 <yulys> ski: do you mean proxy?
21:02:28 <lambdabot>   1.3065629648763766
21:02:33 <ski> > sin (pi / 8) ^ 2 + cos (pi / 8) ^ 2
21:02:35 <lambdabot>   1.0
21:03:03 <yulys> ski: data.proxy?
21:04:20 <ski> yulys : your error was "Could not find module `Data.Proxy':", and <https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs> says `import Data.Proxy      -- from tagged' which suggests `tagged' is the relevant package
21:04:40 <ski> yulys : and indeed, <http://hackage.haskell.org/package/tagged> lists a `Data.Proxy' (hopefully the intended module)
21:06:31 <james-ubc> ski:  uh so what would i have to do to make it work in ghci?
21:07:00 <james-ubc> just to follow through with the chapter
21:10:10 <yulys> I will try ski!!! thank you so much! :)
21:18:11 <ski> james-ubc : hm, try `cabal update && cabal install NumInstances'
21:22:32 <james-ubc> hrm
21:22:37 <james-ubc> syas it's already installed O.o
21:23:19 <ski> ok, try `:m + Data.NumInstances' in GHCi
21:23:41 <ski> (if that doesn't work, try `:s -package NumInstances' first, then retry)
21:24:23 <ski> if you're writing code in a file, you can write `import Data.NumInstances' in it
21:27:33 <ski> @let equating :: Eq a => (b -> a) -> (b -> b -> Bool); equating f = (==) `on` f
21:27:35 <lambdabot>  Defined.
21:27:36 <ski> @type comparing
21:27:41 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
21:28:11 <ski> > equating (map toLower) "nalssi" "NASSLLI"
21:28:13 <lambdabot>   False
21:28:38 <ski> james-ubc : any luck ?
21:28:39 <nalssi> :)
21:28:59 <ski> (.. re "<augur> is anyone at NASSLLI?")
21:29:34 <yulys> sorry guys
21:29:54 <ski> yulys : worked ?
21:33:10 * hackagebot js-good-parts 0.0.3 - Javascript: The Good Parts -- AST & Pretty Printer  http://hackage.haskell.org/package/js-good-parts-0.0.3 (SeanSeefried)
21:33:20 <yulys> how can I do the import of tagged?
21:33:22 <yulys> hmmm
21:33:24 <yulys> julita@yulys:~$ apt-get install tagged
21:33:26 <yulys> E: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)
21:33:28 <yulys> E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?
21:33:30 <yulys> julita@yulys:~$ sudo apt-get install tagged
21:33:32 <yulys> [sudo] password for julita:
21:33:34 <yulys> Reading package lists... Done
21:33:36 <yulys> Building dependency tree
21:33:38 <yulys> Reading state information... Done
21:33:40 <yulys> E: Unable to locate package tagged
21:33:42 <yulys> julita@yulys:~$
21:33:52 <ski> yulys : `tagged' is a Cabal package, not an APT package
21:34:09 <geekosaur> also, please don't paste things more than a couple lines into the channel like that
21:34:09 <mauke> yulys: please use a pastebin instead of flooding the channel
21:34:11 <ski> yulys : try using `cabal update && cabal install tagged'
21:35:18 <mm_freak> i'm still trying to find a paper on the STG machine…  so far my intuitive understanding is that the difference is that a "thunk" as used by GHC contains a function pointer for evaluation instead of a tag…  that also makes the spine unnecessary and basically replaces it by an ordinary call stack…  is that precise?
21:35:21 <geekosaur> if it's in apt at all, the name would be something like libghc6-tagged-dev.  but not a whle lot of hackage is in debian's repos and what is is old
21:35:37 <mm_freak> (the difference to the regular G machine that is)
21:35:50 <james-ubc> ski:  nope
21:38:14 <ski> james-ubc : what is the reply when you try ?
21:38:48 <mzero> mm_freak: on this page: http://research.microsoft.com/apps/pubs/default.aspx?id=67083  -- the file icon is a .tar.gz of the paper
21:40:07 <ski> james-ubc,yulys : btw, for more on Cabal, <http://www.haskell.org/haskellwiki/Cabal-Install> and <http://www.vex.net/~trebla/haskell/sicp.xhtml> might be helpful
21:41:17 <yulys> ski: I got problems ' denied message
21:41:47 <hpaste> yulys pasted “cabal” at http://hpaste.org/70145
21:42:00 <yulys> http://hpaste.org/70145
21:43:13 <mm_freak> mzero: thanks a lot!
21:43:16 <mzero> why are you running that sudo?
21:43:28 <mzero> welcome, mm_freak
21:43:38 <mzero> it's a good paper - well worth the read
21:44:30 <mzero> people will probably freak out about it - but reading that paper helped me greatly understand Haskell evaluation as a Haskell programmer
21:45:39 <ski> yulys : sorry, when you use `cabal', you usually doesn't need to (and shouldn't) do it as superuser
21:46:24 <hpaste> edwardk pasted “golf scorecard” at http://hpaste.org/70146
21:46:31 <yulys> ski: I did it without sudo, but I got the same error message
21:47:12 <mzero> is there perhaps something wrong with the permissions on .cabal?
21:47:16 <hpaste> yulys pasted “caba without sudo” at http://hpaste.org/70147
21:47:17 <mm_freak> mzero: well, it's not actually to understand haskell evaluation…  i'm implementing a small functional language and i've implemented two evaluation machines so far:  SKI machine and G machine
21:47:33 <mm_freak> now i'd like to see how the STG machine is better
21:47:46 <james-ubc> ski  No instance for (Num (a0 -> a0))
21:47:47 <james-ubc>       arising from a use of `+
21:48:21 <geekosaur> so, the sudo cabal update created ~/.cabal as root, now nothing else can create directories
21:48:33 <geekosaur> sudo chown -R $USER ~/.cabal
21:48:35 <ski> yulys : hm, try first `sudo rm -r /home/julita/.cabal/share/doc/tagged-0.4.2.1 /home/julita/.cabal/logs/build.log' to remove the files which `sudo cabal update' added as superuser, then try again ?
21:48:49 <ski> yulys : well, or what geekosaur said :)
21:49:11 <mzero> probably   sudo chown -R $USER:$USER ~/.cabal
21:50:08 <ski> yulys : next time, annotate the original paste (here <http://hpaste.org/70145>) with updates, instead of making a completely new paste
21:50:11 <mzero> you needn't run cabal as sudo - when it needs sudo privledges it will ask you, and only for the final steps that need it - it will do all the pulling, unpacking, and compiling non-superuser - only using root to move into place at the end
21:50:23 <mzero> which, BTW, is one of the things I love about cabal
21:51:03 <james-ubc> lol cabal still wont let me install yi
21:51:41 <ski> james-ubc : you get that error when trying what ?
21:53:10 * hackagebot bson 0.2.1 - BSON documents are JSON-like objects with a standard binary  encoding.  http://hackage.haskell.org/package/bson-0.2.1 (FedorGogolev)
21:54:28 <james-ubc> ski:   ((+) <$> (*2) <*> (+10)  10 )and the let f = (*5); g = (+2)  (fmap f g ) 8
21:54:59 <ski> james-ubc : `((+) <$> (*2) <*> (+10)  10 )' ought to be `((+) <$> (*2) <*> (+10)) 10'
21:55:43 <ski> james-ubc : `let f = (*5); g = (+2)  (fmap f g ) 8' ought to be `let f = (*5); g = (+2) in (fmap f g) 8', i think
21:56:01 <ski> james-ubc : do you still get an error, with those modifications ?
21:56:27 <yulys> ski: I got this message:   rm: cannot remove `/home/julita/.cabal/share/doc/tagged-0.4.2.1': No such file or directory
21:56:31 <ski> james-ubc : also, which part of LYAH was this again ?
21:56:37 <ski> (do you have a link to the section ?)
21:57:21 <ski> yulys : did you try the `sudo chown ...' which geekosaur and mzero suggested ?
21:58:40 <james-ubc> ski:  same thing with modifications
21:58:57 <yulys> ski: I am a little afraid with permissions, but I will do that
21:59:17 <james-ubc> ski: it's from the second last chapter of lyah
21:59:19 <ski> james-ubc : and you did `:m + Data.NumInstances' or wrote `import Data.NumInstances' in your file ?
21:59:35 <pharaun> maybe i am missing something but when i try to readFile (with ByteString.Char8) and then unpack and/or try to print i get an empty string, but if i use prelude i get the data
21:59:35 <james-ubc> ski:  in ghci yeah
22:01:22 <yulys> mzero, ski: julita@yulys:~$ sudo chown -R $julita@yulys ~/.cabal
22:01:24 <yulys> chown: invalid user: `@yulys'
22:01:26 <yulys> julita@yulys:~$
22:01:42 <mzero> ?
22:01:44 <yulys> hmmmm maybe I expected tomates on my face
22:01:49 <yulys> sorry
22:02:03 <mzero> do ls -l ~
22:02:11 <mzero> look at the account and group name for most files listed
22:02:29 <mzero> If your account name were julita then probably it is   julita and julita
22:02:47 <yulys> yes! you are right!
22:02:52 <mzero> okay
22:02:57 <mzero> so the command you want is
22:03:09 <mzero> sudo chown -R julita:julita ~/.cabal
22:03:34 <mzero> menaing, please change the owner and group of all files recursively under ~/.cabal to julita and julita
22:03:49 <yulys> done ! julita@yulys:~$ sudo chown -R julita:julita ~/.cabal
22:03:51 <yulys> julita@yulys:~$
22:04:06 <mzero> this will correct the mistake of running sudo cabal, which caused cabal to create files, as root, under ~
22:04:08 <yulys> now I will install it again?
22:04:14 <mzero> without the sudo
22:04:17 <yulys> ok
22:04:25 <mzero> cabal update
22:04:28 <mzero> then
22:04:37 <mzero> cabal install foobar  (or whatever it was)
22:04:41 <yulys> cabal install tagged
22:04:46 <yulys> cool
22:05:08 <mzero> you only need to do the    cabal update every few weeks or so - or if you are trying to install something "bleeding edge"
22:09:14 <hpaste> yulys pasted “tagged” at http://hpaste.org/70148
22:09:38 <yulys> sorry ski, I tried to do the update, but I could not
22:09:48 <yulys> mzero: S
22:10:18 <mzero> oh crikey
22:10:34 <yulys> crikey?
22:10:39 <mzero> we forgot       sudo chown -R julita:julita ~/.ghc
22:11:27 <mzero> http://www.urbandictionary.com/define.php?term=Crikey
22:11:27 <ski> james-ubc : hum, sorry, you also need to import `Control.Monad.Instances' and `Data.Applicative' and `Control.Monad.Reader.Class' for the `Functor (rho ->)',`Monad (rho ->)' and `Applicative (rho ->)' and `MonadReader rho (rho ->)' instances
22:12:23 <yulys> mzero: crikey!
22:12:49 <mzero> it worked?
22:13:04 <yulys> it is downloading,....
22:13:14 <ski> james-ubc : you need the applicative one for `(<$>)' and `(<*>)' and the functor one for `fmap' -- and then the monad one for `return',`(>>=)',`join', and the monad reader one for `ask',`asks',`local'
22:13:33 <yulys> mzero: yay!
22:13:38 <mzero> :-)
22:13:54 <yulys> mzero, ski: I will try running the program
22:14:18 <yulys> julita@yulys:~$ runhaskell Monoid.hs
22:14:20 <yulys> Monoid.hs:1:8:
22:14:22 <yulys>     Could not find module `Data.Reflection':
22:14:24 <yulys>       Use -v to see a list of the files searched for.
22:14:42 <yulys> I will do the same for tagged to reflection, is that OK?
22:14:48 <ski> yulys : please try to remember to *annotate* the original existing paste when you want to paste an update or some related information, using the "Annotate" button at the top, instead of creating a new paste :)
22:15:10 <yulys> oh OK,...I wont happen again
22:15:17 <ski> yulys : yes (but without `sudo' this time :)
22:15:23 <yulys> xD
22:15:34 <james-ubc> ski: @_@
22:15:41 <ski> james-ubc : it works ?
22:16:01 <mzero> ? yulys what are you trying to do? I missed the antecedant of this situation
22:16:21 <ski> mzero : trying to load <https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs>, afaiu
22:17:19 * mzero blinks several times
22:19:29 <edwardk> yulys: did you mangle your permissions on your .ghc folder at some point?
22:20:05 * mzero hopes yulys has plenty of Haskell experience before tackling stuff like that
22:21:39 <edwardk> yulys: if you unmanaged the damage done by using sudo to install local packages, then cabal install reflection should work transitively for all of its dependencies
22:21:45 <edwardk> er unmangled
22:22:23 <james-ubc> ski:  yeah
22:22:25 <mzero> right - only yulys only did "cabal install tagged" after unmangling
22:23:29 <ski> james-ubc : i was completely forgetting that you weren't just adding,subtracting,&c. your functions ..
22:24:26 <james-ubc> ski if i import control.monad do i still need to import control.monad.reader ?
22:24:40 <ski> edwardk : yes, `sudo cabal update && cabal install tagged'
22:25:06 <edwardk> ski: that'd do it
22:26:30 <ski> james-ubc : you need `Control.Monad.Instances' to use `fmap',`return',`(>>=)',`join' (and `do'-notation) on functions. you need `Control.Monad.Reader.Class' for `ask',`asks',`local'
22:27:10 <ski> (edwardk : yulys was first trying `sudo apt-get install tagged' ..)
22:27:38 <hpaste> yulys annotated “tagged” with “tagged (annotation)” at http://hpaste.org/70148#a70149
22:28:59 <edwardk> yulys: is your copy of Monoid.hs missing the {-# LANGUAGE line at the top?
22:29:00 <ski> yulys : did you do `sudo chown -R julita:julita ~/.ghc' yet, as mzero suggested ?
22:29:55 <yulys> yes
22:30:22 <yulys> edwardk: I will check it :)
22:30:36 <ski> then i wonder why `cabal: ghc-pkg: /home/julita/.ghc/x86_64-linux-7.0.3/package.conf.d/:' says `openBinaryTempFile: permission denied (Permission denied)'
22:31:31 <ski> yulys : are you sure you did it on `~/.ghc' as well as `~/.cabal' ?
22:32:05 <yulys> julita@yulys:~$ runhaskell Monoid.hs
22:32:05 <james-ubc> what's with the cake thing?
22:32:09 <yulys> <interactive>:1:33: Not in scope: `main'
22:32:11 <yulys> julita@yulys:~$
22:32:34 <yulys> ski: yes, I will copy all in my hpaste
22:33:17 <ski> yulys : that `Monoid.hs' doesn't define a `main', try `ghci Monoid.hs' instead
22:33:44 <hpaste> yulys annotated “caba without sudo” with “Monoid.hs” at http://hpaste.org/70147#a70150
22:34:20 <edwardk> yulys: i didn't put a main in it, just start it with ghci
22:35:43 <hpaste> yulys annotated “caba without sudo” with “ghci Monoid.hs” at http://hpaste.org/70147#a70151
22:36:52 <edwardk> :m + Data.Reflection
22:37:05 <edwardk> (er yulys:, type that in then try)
22:37:59 <yulys> Prelude> :m + Data.Reflection
22:38:01 <yulys> Prelude Data.Reflection> reify 4 reflect :: Int
22:38:03 <yulys> Loading package tagged-0.4.2.1 ... linking ... done.
22:38:05 <yulys> Loading package reflection-1.1.6 ... linking ... done.
22:38:07 <yulys> 4
22:38:09 <yulys> Prelude Data.Reflection>
22:38:20 <edwardk> $ ghci Monoid.hs  \n  withMonoid (+) 0 $ mempty <> M 2 \n : + Data.Reflection \n reify 4 reflect :: Int
22:38:30 <yulys> mzero, ski, edwardk: thanks guys!
22:38:46 <edwardk> er :m + Data.Reflection not : +
22:38:56 <yulys> but now it is so difficult to understand what the code is about :p
22:39:01 <edwardk> ah
22:39:04 <yulys> I will try to do alone
22:39:06 <yulys> n.n
22:39:07 <edwardk> the code itself is pretty tricky =)
22:39:12 <yulys> hmmm
22:39:27 <yulys> kind of cryptic,,, :p
22:39:31 <edwardk> in fact i dare say the code that makes reflection work is probably the most blatantly illegal in spirit code on hackage
22:39:38 <yulys> jajajaja
22:39:38 <mzero> for what it's worth - I've been reading through it while sitting here and it makes my head spin
22:40:35 <edwardk> mzero: basically we cast a function from (forall s. Reifies s a => Proxy s -> a)   into a function from (Proxy s -> a) -> Proxy s -> a and then pass it arguments
22:40:54 <edwardk> this relies on the fact that the dictionary for Reifies s a and 'const a' have the same representation ;)
22:41:15 <mzero> ew!
22:41:22 <edwardk> but before that it had a more principled argument for how it could pass the dictionary as a type
22:41:35 <edwardk> where it'd use the fact that you can represent a number as a type
22:41:56 <edwardk> and that can also represent lists of types as a type (a la hlists)
22:42:02 <edwardk> so you can represent anything storable as a type
22:42:07 <edwardk> (by converting it to a list of numbers)
22:42:14 <edwardk> and that stableptrs are storable
22:42:14 <mzero> but all for what - so someone can avoid passing around an options type?  ;-P
22:42:23 <edwardk> mzero: its a bigger deal than that
22:42:31 <edwardk> lets try it that way
22:42:33 <edwardk> one sec
22:43:05 <edwardk> data Monoid_ a = Monoid_ { mempty_ :: a, mappend_ :: a -> a -> a }; newtype M a = M (Monoid_ a -> a)
22:43:10 <edwardk> great
22:43:15 <edwardk> i packaged up my 'options' type, right?
22:43:26 <edwardk> and then made a monoid so you can pass it in to me
22:43:32 <edwardk> we can clearly make a monoid for M
22:43:56 <yulys> I was trying to do comparison of reflection Java vs Reflection Haskell code in specific program... I hope this Monoid.hs can be a good example...
22:44:17 <edwardk> but the problem is that if you use the same leaf 'value' twice you have to recompute it
22:44:23 <edwardk> yulys: they are completely unrelated concepts
22:44:49 <edwardk> well technically they are related but only in the root etymology of reification and reflection
22:45:35 <edwardk> yulys: you may find http://stackoverflow.com/questions/5314884/what-reify-and-reification-means-in-the-context-of-functional-programming/5316014#5316014 to be enlightening
22:45:55 <edwardk> in that i write up the definition of reification and reflection and how the different uses of the terminology across different domains are interrelated
22:46:08 <yulys> waaa
22:46:10 <edwardk> the closest thing haskell has to java reflection is 'Dynamic' and Data.Typeable
22:46:17 <yulys> :O
22:46:29 <yulys> another day...
22:46:51 <edwardk> mzero: anyways, can you see the fact that you can't share any answers if you use the configuration passing style?
22:46:58 <edwardk> mzero: you wind up sharing functions
22:47:11 <edwardk> mzero: on the other hand, if you use reflection, the dictionaries float out over lambdas!
22:47:19 <edwardk> and you can share the resulting 'a's
22:47:27 <edwardk> because we have confluence to let us know this is safe
22:48:00 <edwardk> the difference is huge
22:48:23 <edwardk> in the naive configuration passing style you build up an enormous function that knows how to evaluate to the answer
22:49:06 <edwardk> and it has to be by name, whereas with the reflection library it can be by need, asymptotically improving the code
22:49:19 <mzero> I admit I didn't follow that one bit
22:50:23 <edwardk> well, you have two options you can plumb a configuration value through your code, bolt it into every leaf level thing you want to make a class constraint for but if you do so, all your leaf level values are actually functions from the configuration to their answer
22:50:27 <edwardk> they aren't actual values
22:50:47 <mzero> ah
22:50:57 <edwardk> newtype Mod = Mod (Int -> Int) -- works fine
22:51:01 <mzero> (getting this -- barely)
22:51:03 <edwardk> now exponentiate
22:51:12 <edwardk> using the algorithm used by ^
22:51:13 <edwardk> ;)
22:51:38 <edwardk> raise it to ^60 or so, i'll do the same using reflection
22:51:41 <edwardk> ;)
22:52:29 <edwardk> newtype Mod s = Mod Int; instance Reifies s Int => Num (Mod s)   -- yields something where the numeric instance is on values
22:52:47 <edwardk> the newtype Mod (Int -> Int) version has to lookup the modulus (just in case you changed it!) every time
22:53:18 <edwardk> with a dictionary, i know if i gave you a dictionary for Foo [Int]  once, and go to get it again, its safe for me to assume the one i used last time is still good
22:53:31 <edwardk> so we can float constraints out over lambdas
22:53:53 <edwardk> so we get strictly better sharing in the resulting code
22:55:25 <mzero> okay - I get it
22:55:45 <edwardk> =)
22:55:58 <edwardk> reflection is subtle but very powerful
22:56:23 <mzero> but other than somehow reifying the modulus in cryptographic code - I can't imagine I do enough operations on these kinds of values to make this an issue
22:57:23 <yulys> edwardk: do you think this is a good example of haskell reflection? the reflection example I want: http://www.defmacro.org/ramblings/haskell-web.html
22:58:13 <edwardk> yulys: that is 'generic programming' in haskell parlance, which is used for much the same purpose as java reflection
22:58:30 <ski> yulys : yw
22:58:34 <edwardk> that is using the old Data.Data library. the modern approach is GHC.Generics
22:58:51 <edwardk> mzero: i wind up making monoids out of some scarily complicated structures
22:59:05 <edwardk> mzero: a good example for me is tabulating a regular expression
22:59:13 <mzero> edwardk: you do a lot of scary things with Haskell!  :-)
22:59:20 <edwardk> say you have a regular expression you've compiled into a DFA
22:59:31 <edwardk> its just a graph now, right?
22:59:48 <edwardk> say you have 50 nodes in the graph and a bunch of edges labeled with what inputs cause them to be taken
23:00:32 <edwardk> you can make a notion of tabulation for this graph where you have arrays that have 50 elements in them and they just store what state you wind up in after applying a given input.
23:00:43 <edwardk> so you wind up with a function from State -> State, but tabulated in array form
23:01:03 <edwardk> and its only states for a particular DFA. the number of states would disagree between different DFAs
23:01:25 <edwardk> so we can tabulate each possible input, and we can define the composition of these tabulations
23:01:42 <edwardk> by chasing the tabulated functions like you do with usual function composition
23:02:05 <yulys> hmmm but generic programming is for implementing algorithms with any type and reflection is for safety if the program running show different data, right?
23:02:24 <yulys> I will follow this, the documentation of haskell:  http://hackage.haskell.org/trac/ghc/wiki/PolymorphicDynamic
23:02:31 <edwardk> but the result is a monoid, so you can now start parsing input anywhere, and glom together the answers, then just look at what the destination state is from the start state
23:03:32 <mzero> yulys - I'm not sure what you are trying to compare - some use of reflection in Java - but the equivalent in problem in Haskell *may* using nothing than the normal language features
23:03:34 <ski> ("glom" ?)
23:04:00 <edwardk> yulys: that is a proposal to add polymorphic instances to the existing dynamic type code. Haskell dynamics are a generic programming mechanism built on Data.Typeable. Data.Typeable and Data.Data form the old generic programming API
23:04:03 <mzero> ski: the operation in a Glomoid
23:04:22 <edwardk> ski: put together, http://www.thefreedictionary.com/glom
23:04:26 * ski . o O ( why so glom ? )
23:05:16 <edwardk> because its shorter than conglomerate ;)
23:05:16 <yulys> I am doing a homework of the university, they asked me to test Haskell, and why is Java more popular if both languages have the same age... I have to compare features: generic programming and reflection
23:06:16 <edwardk> yulys: i think the problem is the name of my 'reflection' library is misleading, because it has nothing to do with the notion of reflection you are comparing with from java
23:06:16 * ski thought Sun hyped Java a lot ..
23:06:34 <mzero> seems like it would be more valid to compare how those languages support different use cases, rather than trying to compare language features directly
23:06:43 <mzero> especailly given how different they are
23:06:44 <programmer> hi
23:07:07 <ski> hello programmer^WGuest13802
23:07:43 <edwardk> now, there are things i can express easily in java, lots of ad hoc attribute access via reflection, i can compare objects for equality using some ill defined semantics, i'm supposed to be able to magically hash everything
23:08:06 <edwardk> there are some things that i can easily express in haskell that have no equivalent in java (try writing the Monad class in java, i'll wait)
23:09:20 <edwardk> each has different strengths. the jvm is pretty accessible, it does do a decent job of running everywhere, and it has evolved a complex reflection interface in large part _as a way to work around the limitations of its type system_
23:09:56 <edwardk> haskell has fewer such type system limitations, and has a correspondingly reduced need to lean upon such an overarching reflection system to get things done
23:10:02 <Guest13802> Learn haskell, have the following problem:
23:10:58 <edwardk> we frankly give you no run time introspection tools at all unless you explicitly pass them around (like Typeable, Data, or the new GHC.Generics)
23:11:06 <edwardk> this is both a strength and a weakness
23:11:09 <Guest13802> data BinaryFormat = BinaryFormat !ByteString
23:11:13 <mzero> "Learn Haskell, have the following problem: Can't stand to go back to day job and code in Java."  ? !!!
23:11:27 <edwardk> its a weakness in that you don't get them everywhere. its a strength in that the code can run faster and can provide stronger guarantees
23:11:28 <Guest13802> data R200Fromat = R200Format BinaryFormat
23:11:40 <Guest13802> instance
23:11:52 <mzero> Guest13802: if this is more than 3 lines please use hpaste
23:11:52 <dmwit> edwardk: Java gives you no run time introspection tools at all unless you explicitly pass them around, either. It's just that Java makes every class explicitly pass them around.
23:11:53 <ski> mzero : curiously similar to "will I hate every other language after learning scheme?" recently uttered in #scheme :)
23:12:06 <edwardk> dmwit: yes, that was also where i was going =)
23:12:22 <Ralith> ski: what really sucks is when you know both haskell and scheme.
23:12:25 <Enigmagic> "will I hate scheme after learning scheme?"
23:12:28 <edwardk> java makes you pay a performance penalty to support these features even if you don't want them
23:12:31 * mzero has learned both and know which one he doesn't want to code in.... 
23:13:01 <edwardk> and even when they decrease the ability to reason about the correctness of your code.
23:13:11 <ski> @where hpaste
23:13:11 <lambdabot> http://hpaste.org/
23:13:16 <ski> Guest13802 ^
23:13:24 <edwardk> with parametricity i can reason that nobody can ever access something, but with reflection that can come along say 'screw that' and access it anyways
23:13:35 <dmwit> That last one (losing the ability to reason) is a killer I hadn't even considered.
23:13:36 <Guest13802> fromInteger :: Integer -> R200Format
23:13:38 <Guest13802> fromInteger 0 = pack [0, 0] <-- ERROR
23:13:38 <dmwit> nasty
23:13:54 <edwardk> i've 'monkey patched' sharepoint by hacking internal undocumented arrays that are stored in system libraries, because that was the only way to solve a problem
23:13:59 <edwardk> i can't even try that in haskell
23:14:22 <ski> Ralith : i sometimes want (hygienic) macros in Haskell ..
23:14:25 <Enigmagic> you can do it in C
23:14:33 <mzero> Guest13802: please paste that code, and the full error message into a hpaste buffer - then we'll be happy to help figure it out
23:14:43 <Ralith> ski: and I'd quite like to have sexprs!
23:14:50 <ski> @where liskell
23:14:51 <lambdabot> http://clemens.endorphin.org/liskell
23:15:11 <ski> preflex: xseen therp
23:15:11 <dmwit> Guest13802: Well, what did you expect? You asked the compiler to complain when you used a ByteString instead of a BinaryFormat, and when you used a BinaryFormat instead of an R200Format, but you don't want it to complain when you use a ByteString instead of an R200Format...?
23:15:11 <preflex>  therp was last seen on freenode/#xmonad 329 days, 15 hours, 17 minutes and 41 seconds ago, saying: nicoo: well, I can trick xmonad, by echo '#!/bin/bash; if [ -e "triggerFileForFvwm]; then fvwm; else /usr/bin/xmonad "$*"; fi'  > bin/xmonad
23:15:15 <edwardk> dmwit: wasn't washburn there under stephanie weirich for a time doing his dissertation on the topic?
23:15:15 <Ralith> hacks need not apply :P
23:15:23 <edwardk> found it
23:15:24 <edwardk> http://repository.upenn.edu/dissertations/AAI3292086/
23:15:33 <dmwit> Guest13802: If you want pack to have a polymorphic type, write yourself a typeclass and be done with it.
23:15:38 <Ralith> especially unmaintained ones
23:16:28 <Guest13802> I'm sorry I do not really think quickly in English :)
23:16:52 <mzero> Guest13802: fromInteger 0 = R2000Format $ BinaryFormat $ pack [0, 0]
23:17:15 <mzero> you need to use the constructors to get the type you are after
23:17:16 <ski> dmwit : yes, the power of a language is measured both in (a) the expressiveness, how much you can (composably) do; but also (b) the "reasonability", what you can rely one when reading, writing and refactoring code
23:17:29 <edwardk> Guest13802: you can always serialize the TypeRep for your type up front to get more safety
23:17:31 <ski> dmwit : increases in (a) often tend to decrease (b) and vice versa
23:17:53 <Guest13802> How to define a common data type for multiple types? Who would have contained a ByteString?
23:17:54 <mzero> edwardk: c'mon, that wasn't helpful
23:18:15 <edwardk> mzero: how not? its an honest fix
23:18:15 <dmwit> Guest13802: class OverloadedByteString a where pack :: [Word8] -> a
23:18:29 <edwardk> if you try to deserialize a bytestring in the wrong type it'll fail
23:18:44 <Guest13802> Like this:
23:18:58 <mzero> isn't Guest13802's error simply forgetting to call the constructors?
23:19:12 <dmwit> instance OBS ByteString where pack = Data.ByteString.pack; instance OBS BinaryFormat where pack = BinaryFormat . pack; instance OBS R200Format where pack = R200Format . pack -- etc
23:19:19 <edwardk> ok, i was getting ahead of where he's at and fixing another problem ;)
23:19:20 <mzero> I suppose you are all guessing at what Guest13802 is trying to achieve
23:19:30 <edwardk> mzero: we're kind of forced to
23:19:38 <Guest13802> data BinaryFormat = BinaryFormat !ByteString                        data R200Format = R200Format BinaryFormat
23:19:47 <mzero> exactly - I guessed the other end of the spectrum from your guess, I think   :-)
23:20:07 <edwardk> Ralith: i miss hygienic macros in haskell. i'd be sorely tempted to trade in template haskell for syntax-rules ;)
23:20:13 <mzero> Guest13802: please- paste  a larger chunk of your code into hpaste so we can get a sense of what you are after
23:20:39 <mzero> @where hpaste
23:20:39 <lambdabot> http://hpaste.org/
23:21:34 <Guest13802> mzero: 1 min...
23:22:37 <ski> edwardk : well, one of the programmatic (non-cbn) (hygienic) macro systems would be better -- aka <http://okmij.org/ftp/Scheme/macros.html>
23:24:23 <edwardk> ski: you know, for me it just comes down to the fact that syntax-rules are pretty and mostly easy to reason about. for 80% of the use cases i prefer them to everything else. when you start olegging them into cps form to work around their limitations and chain them? then i start liking other systems
23:25:23 <ski> hm, apparently <http://www.liskell.org/> is also broken : <http://web.archive.org/web/20101009020847/http://www.liskell.org/>
23:25:57 <Guest13802> -- | Module:    BinaryFormat
23:25:57 <Guest13802> module BinaryCodedNumber
23:25:58 <Guest13802>     ( )
23:25:58 <Guest13802> where
23:25:58 <Guest13802> import qualified Prelude as P
23:25:58 <ski> edwardk : yes, not saying that `syntax-rules' is bad for simple macros
23:26:00 <Guest13802> import Prelude hiding (reverse,head,tail,last,init,null
23:26:02 <Guest13802>                       ,length,map,lines,foldl,foldr,unlines
23:26:05 <Guest13802>                       ,concat,any,take,drop,splitAt,takeWhile
23:26:07 <Guest13802>                       ,dropWhile,span,break,elem,filter,maximum
23:26:08 * ski sighs
23:26:10 <mzero> please stop
23:26:10 <Guest13802>                       ,minimum,all,concatMap,foldl1,foldr1
23:26:12 <Guest13802>                       ,scanl,scanl1,scanr,scanr1
23:26:14 <edwardk> Guest13802: stop
23:26:15 <mzero> don't paste it here
23:26:19 <mzero> paste it in hpaste
23:26:19 <edwardk> @hpaste
23:26:19 <lambdabot> Haskell pastebin: http://hpaste.org/
23:26:21 <edwardk> paste there
23:26:41 <Guest13802> import Data.Word ( Word8 )
23:26:41 <Guest13802> import Data.ByteString
23:26:41 <Guest13802> data BinaryFormat = BinaryFormat !ByteString
23:26:41 <Guest13802> data R200Format = R200Format BinaryFormat
23:26:41 <Guest13802> --
23:26:43 <Guest13802> -- fromInteger
23:26:45 --- mode: ChanServ set +o mauke
23:26:46 --- kick: Guest13802 was kicked by mauke (Guest13802)
23:29:24 <yulys> edwardk: is this a good example of reflection in Haskell, like Java has? : https://github.com/orbitz/petrosino/blob/726ce88a8a4f8ef27a52422e960ca547182e6e39/src/Petrosino/Rule.hs
23:29:35 --- mode: mauke set -o mauke
23:30:22 <Sergey_> ok
23:30:31 <Sergey_> hello everybody
23:30:37 <ski> hello Sergey_
23:32:01 <dmwit> programm1r: Welcome back. Please check out http://hpaste.org and try again.
23:32:12 <yulys> sorry to bother with this, I just want an example of Haskell using reflection and the I can do it in Java..
23:32:15 <programm1r> thrown while copying ...
23:32:29 <dmwit> programm1r: Yes, please don't copy directly into the channel.
23:32:37 <programm1r> ok
23:32:39 <dmwit> programm1r: As several people told you, use hpaste.org instead.
23:32:47 <shachaf> Abort, Retry, Fail?
23:33:08 <Sergey_> What can I do on Haskell?
23:33:15 * hackagebot digestive-functors 0.5.0.0 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.5.0.0 (JasperVanDerJeugt)
23:33:29 <Sergey_> Can I rebuild a world?
23:33:33 <mauke> huh?
23:34:17 <dmwit> ?faq Can I rebuild a world?
23:34:17 <lambdabot> The answer is: Yes! Haskell can do that.
23:34:31 <Sergey_> ok
23:35:19 <mzero> yulys: I don't think you can compare Haskell to Java like that
23:35:56 <mzero> I don't think I'd every use any form of reflection in Haskell for the things I can think to use reflection for in Java
23:36:46 <hpaste> programm1r pasted “Data with ByteString” at http://hpaste.org/70152
23:36:55 <yulys> mzero: hmmm, I read many people say that, there is no reflection in Haskell. but I am still confused
23:37:04 <mzero> a more fruitful question would be to point us at some thing in Java done with reflection and ask how we'd do that in Hsakell
23:37:49 <dmwit> programm1r: The simplest fix (as mzero said half an hour ago or so) is fromInteger 0 = R200Format . BinaryFormat $ pack [0, 0]
23:38:17 * hackagebot digestive-functors-snap 0.5.0.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.5.0.0 (JasperVanDerJeugt)
23:38:17 <hpaste> mauke annotated “Data with ByteString” with “Data with ByteString (annotation)” at http://hpaste.org/70152#a70153
23:38:19 * hackagebot digestive-functors-blaze 0.5.0.0 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.5.0.0 (JasperVanDerJeugt)
23:38:20 <Sam___> I am learning Haskell. As an exercise, I have tried to redefine function nub (in Data.List), which deletes all duplicate elements in a list. I have written the following but it does not work and I do not know why.
23:38:21 * hackagebot digestive-functors-heist 0.5.0.0 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.5.0.0 (JasperVanDerJeugt)
23:38:23 * hackagebot digestive-functors-happstack 0.5.0.0 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.5.0.0 (JasperVanDerJeugt)
23:38:26 <Sam___> nub' [] = [] nub' [x:xs] 	| elem x xs == False	= x:[nub' xs] 	| otherwise 	= nub' [xs]
23:38:26 <yulys> ok, I know in Java you have a class a and his reflection class a1 and the reflection class check all the fields and the methods of class a
23:38:56 <mauke> Sam___: that's almost unreadable. http://hpaste.org/?
23:38:56 <Sam___> As you can see, I am a noob. I would like to have feedback. Thanks a lot.
23:38:59 <dmwit> programm1r: You probably also need to put this in an "instance Num R200Format" block.
23:39:20 <Sam___> How do you do that?
23:39:25 <dmwit> Sam___: You probably just meant "nub' (x:xs)" instead of "nub' [x:xs]".
23:39:28 <mzero> though, programm1r - I can't tell if you think you are defining a new function fromInteger, or if you are trying to define a Num instance for R200Format
23:39:53 <dmwit> Sam___: ...and probably also "x:nub' xs" instead of "x:[nub' xs]".
23:40:21 <mauke> Sam___: you put your code in the field labeled "Paste:" and click Submit
23:40:26 <Sam___> Maybe. I shall try. Thank you anyway.
23:40:34 <dmwit> Sam___: yikes, and also "nub' xs" instead of "nub' [xs]".
23:40:46 <Sam___> OK
23:40:53 <dmwit> Sam___: It seems like you think all lists must always be wrapped in [] everywhere.
23:41:09 <yulys> mzero, edwardk: ok, I know in Java you have a class a and his reflection class a1 and the reflection class check all the fields and the methods of class a
23:41:09 <dmwit> Sam___: That is not so: [] takes a value and turns it into a list; if it's already a list, you don't need to add additional brackets.
23:41:26 <Sam___> Ah, good to know.
23:41:44 <programm1r> dmwit: Not in scope: data constructor `BinaryFormat'
23:41:49 <mzero> yulys: I don't know what you mean by "and the reflection class check all the fields and the methods of class a"
23:42:12 <mzero> the reflection class doesn't "check" anything - it lets you at run time ask questions about the structure of the class
23:42:30 <dmwit> programm1r: hpaste the exact code you're trying to compile.
23:42:53 <programm1r> dmwit: 1 min
23:43:45 <yulys> hmmm
23:43:50 <mzero> and, please, programm1r: are you trying to make R200Format a Num instance .... or did you just pick the name 'frominteger' not knowing that it already had some other use
23:44:13 <Sam___> My goal is to be able to do Natural Language Processing and web development using Haskell. Are some of you involved in this kind of things.
23:44:39 <mzero> Sam___: there is plenty of web development being done in Haskell here
23:45:11 <Sam___> For example, if I want to use Yesod to make a web app in Haskell, how proficient do I have to be in Haskell ?
23:45:19 <yulys> mzero: I've read that you can ask about the class, but in that case if there is another information, you can modify or send a mail like trigger?
23:45:49 <blackdog> Sam___: yesod's an interesting example. it's really safe, but sometimes the errors you get out of it when it's not type-correct are a bit impenetrable.
23:46:04 <mzero> yulys: what? that makes no sense
23:46:08 <blackdog> i found it easier to use something like scotty, especially for small projects.
23:46:13 <blackdog> Sam___: what's your background?
23:46:41 <Sam___> I am a linguist. I know some Python but not a lot. I heard Yesod is really fast.
23:46:41 <hpaste> programm1r pasted “Data with ByteString 2” at http://hpaste.org/70154
23:46:56 <mzero> There are good hand holding tutorials for Yesod, and a book (free on-line) that take you through it
23:47:05 <yulys> mzero: http://java.sun.com/developer/technicalArticles/ALT/Reflection/index.html
23:47:19 <mauke> programm1r: what is RadixNumber?
23:47:27 <mzero> yulys - mail doesn't appear in that article
23:47:40 <programm1r> How to pack one type to another.
23:47:45 <yulys> it was an example
23:47:49 <yulys> hmm
23:48:07 <mauke> programm1r: what is RadixNumber?
23:48:10 <programm1r> This is the number in different number system
23:48:15 <Sam___> My goal is to have a website from which I can teach French online and be paid by adds. The learners would not pay anything. Maybe I would rather take any PHP or Python CMS for that but I want something which can scale...
23:48:25 <mzero> yulys: I'm familiar with Java reflection -
23:49:08 <blackdog> Sam___: putting my startup hat on, i'd be inclined to do it whatever language you already know. if it works, you can rewrite in something that scales, or just throw more hardware at it.
23:49:13 <yulys> mzero: http://www.javahispano.org/storage/contenidos/reflection.pdf
23:49:19 <yulys> here is the mail example
23:49:21 <sopvop> Can I do something like applicative but with monad like functions?. Sort of   f :: a -> b -> f c and f <*> a <*> b? Applicative would allow only f :: a-> b, and monads can't compose :(
23:49:29 <programm1r> There are many different binary formats, including numbers in different number systems. I'm still trying just to understand - as a stick inside the ByteString type.
23:49:46 <blackdog> it's probably heresy to recommend something other than haskell here, and i do like yesod a lot, but i think it has a steep learning curve still.
23:49:50 <edwardk> sopvop: sure they can compose, just not in general ;)
23:49:51 <dmwit> programm1r: You haven't defined RadixNumber or BinaryCodedNumber anywhere. What were you expecting to happen?
23:51:00 <dmwit> programm1r: (Indeed, in the case of RadixNumber, you haven't defined either a type RadixNumber or a constructor RadixNumber, but you tried to use both.)
23:51:29 <hpaste> programm1r pasted “Data with ByteString 3” at http://hpaste.org/70155
23:51:54 <mzero> I think email was just the example class being introspected in that example
23:52:35 <dmwit> programm1r: Right, like that.
23:52:39 <yulys> uhum
23:53:05 <sopvop> So, maybe I can somehow beautifully combine monad bind and applicative <*> to apply (f :: a -> b -> m c) in one line? like f `something` a <*> b ?
23:53:10 <yulys> reflection is introspection, I understand that
23:53:17 <programm1r> If I defined data type: BinaryFormat = BinaryFormat! ByteString, how do I apply to ByteString?
23:53:23 <edwardk> if you support bind, you're back to being a monad =P
23:53:43 <dmwit> :t (<*>)
23:53:44 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:54:12 <dmwit> sopvop: :t a? :t b?
23:54:17 <mzero> programm1r: your data type defines a constructor - which acts like a function to take the data contained in the data type to a value of the type
23:54:26 <yulys> mzero: If you know about reflection in Java, can you tell me if there is some way to compare solution for any situation using Haskell as an alternative of Java?
23:54:28 <mzero> so        BinaryFormat is the constructor you defined
23:55:01 <mzero> yulys - not for reflection as facility - there is no equivalent in Haskell
23:55:09 <dmwit> programm1r: I don't understand the question. What do you want to apply to a ByteString?
23:55:19 <edwardk> yulys: in http://hpaste.org/69758 i use haskell's generic programming (what java would call reflection) facilities to search infinite structures in finite time
23:55:20 <Taneb> -XNoImplicitPrelude doesn't work with GHCi
23:55:26 <mzero> we can only look at use cases for reflection in Java and say for that use case, how one would approach it in Haskell
23:55:31 <sopvop> dmwit: Does not matter, I wan't one liner for bunch of  f a, f b, f c, f d, and on the left a function taking a b c d but returning 'f e'
23:55:53 <dmwit> Taneb: annoying
23:55:58 <edwardk> yulys: however, that uses things where haskell's 'reflection' abilities are actually stronger than java's
23:56:16 <edwardk> but mostly to talk about things that java doesn't have
23:56:18 <mzero> but edwardk, that isn't comparable, as that isn't something you would (or could) do in Java using Java's reflection
23:56:32 <dmwit> sopvop: join $ return f `ap` a `ap` b `ap` c `ap` d
23:57:18 <edwardk> mzero: i've used java reflection for some generic programming traversals in the past. i probably wouldn't use Hilbert's epsilon in java, because it doesn't have the vocabulary for laziness, but thats not the reflection facilities' fault
23:57:21 <yulys> edwardk: but I am still quite confused about generic and reflection, generic is for programming an algorithm no matter the type of the data and reflection is introspection of the class in the runnig type
23:57:31 <yulys> "time
23:57:31 <dmwit> sopvop: In most cases, just (join $ liftM4 f a b c d) or similar.
23:57:39 <edwardk> yulys: we don't have a 'class'
23:57:53 <edwardk> yulys: if you have a data type in haskell its dumb data. it has some values and thats it
23:57:58 <yulys> well a structure
23:58:08 <sopvop> :t ap
23:58:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:58:13 <edwardk> we have classes, but classes aren't bolted onto data types like that are in java/c++
23:58:19 <Taneb> sopvop, liftM4?
23:58:36 <programm1r> I want in the ByteString to store pieces of binary data, and I need a common data type for the following types of file formats (there will be many). How to define a data type that contains a limited subset of type ByteString?
23:58:42 <dmwit> Taneb: needs a join, too, I think
23:58:45 <Taneb> Yeah
23:58:47 <Taneb> For the m
23:58:49 <dmwit> Taneb: (as I suggested above =)
23:58:51 <edwardk> if you know the notion of a vtable from c++, you can think of a class in haskell like a vtable that isn't just carried around as a field in the object, but which is plumbed by other means
23:59:04 <edwardk> so it makes no sense in this universe to be able to reflect methods for an object. they just aren't there
23:59:09 <sopvop> thats m (a -> b) and I need (a -> m b), or rather (a -> b -> c -> m d)
23:59:11 <Taneb> dmwit, I thought before looking
23:59:25 <edwardk> however, we can have member fields of a data type. and those are visible. but they are visible to our 'generic programming' mechanism
23:59:36 <edwardk> GHC.Generics gives you access to record fields
23:59:45 <edwardk> this is the closest analogue you wil find to java's reflection
23:59:45 <dmwit> sopvop: Read my suggestion more carefully.
23:59:54 <edwardk> because that is the only way a haskell data type 'has methods'
