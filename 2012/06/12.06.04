00:09:11 * hackagebot ghc-mod 1.10.16 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.10.16 (KazuYamamoto)
00:17:11 <Saizan> easiest to use http client lib?
00:17:35 <Saizan> i need to get at the headers and body of a page
00:17:55 <Axman6> system ("curl " ++ url)? :P
00:17:56 <Saizan> simple GET request
00:17:57 <mikeplus64> curl probably
00:18:00 <mikeplus64> yeah
00:18:04 <dmwit> wget
00:18:06 <dmwit> or curl
00:18:13 <Axman6> this is sad :(
00:19:04 <Saizan> is that the easiest to use within Haskell? i'm surprised
00:19:40 <dmwit> Actually, I don't know. HTTP's Browser thing is pretty easy to use, too.
00:20:23 <dmwit> Oh, then again, my decision to use that also included a requirement for cookies, which you may not have.
00:20:24 <Saizan> wget' does exactly what i want, so i'll try that
00:20:25 <Lemmih> Saizan: libcurl is decent once you get used to the bad design.
00:21:06 <JoeyA> What about http-conduit?
00:21:14 <mikeplus64> Saizan: you can use getHeaders from Network.HTTP.Headers
00:27:48 <Dtgr> Network.HTTP is simple to use
00:33:31 <mikeplus64> Saizan: ok: fmap (fmap getHeaders) (simpleHTTP (getRequest "http://somewhere.com"))
00:34:32 <Saizan> mikeplus64: yeah, i had figured that out, thanks
00:35:32 <yitz> preflex: xseen dcoutts
00:35:32 <preflex>  dcoutts was last seen on freenode/#haskell 18 days, 15 hours, 59 minutes and 38 seconds ago, saying: * dcoutts seconds shapr's ++
00:35:40 <dcoutts_> yitz: hia
00:35:46 <yitz> ah hi :)
00:36:45 <dcoutts_> @arr!
00:36:45 <lambdabot> Shiver me timbers!
00:36:53 * cizra needs some help setting up Emacs with haskell-mode. I'm an Emacs newbie. I tried adding the code from http://www.haskell.org/haskellwiki/Emacs/Installing_haskell-mode to my .emacs (adjusting paths). I get _something_, but not the keybindings described in http://www.haskell.org/haskellwiki/Emacs/Keybindings_and_simple_usage
00:44:14 * hackagebot msgpack 0.7.1.5 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.7.1.5 (HideyukiTanaka)
00:50:54 <hpaste> yitz pasted “cizra: some lines from my .emacs” at http://hpaste.org/69484
00:51:46 <yitz> cizra: which keybinding are you missing?
00:51:50 <yitz> s
00:52:22 <cizra> C-c C-=, for instance
00:52:34 <yitz> hm works for me
01:01:01 <solarus> cizra: C-c C-= seems to be defined in haskell-indent-mode
01:01:29 <solarus> probably need to load that mode instead of haskell-indentation-mode
01:24:18 * hackagebot regex-pderiv 0.1.2 - Replaces/Enhances Text.Regex. Implementing regular expression matching using Antimirov's partial derivatives. The svn source also shipped with two other referential implementations, e.g. Thomspon NFA and Glushkov NFA. For more detail please...  http://hackage.haskell.org/package/regex-pderiv-0.1.2 (KennyLu)
01:29:18 * hackagebot regex-pderiv 0.1.3 - Replaces/Enhances Text.Regex. Implementing regular expression matching using Antimirov's partial derivatives.  http://hackage.haskell.org/package/regex-pderiv-0.1.3 (KennyLu)
01:42:41 <mekeor> why does hackagebot send those notifications as a description of itself?
01:43:08 <Botje> so they're easier to ignore, i presume.
01:45:19 <mekeor> ah, hm.
01:49:20 * hackagebot digestive-functors 0.4.1.0 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.4.1.0 (JasperVanDerJeugt)
01:54:35 <ibid> they should probably be notices instead
02:04:00 <zhulikas> isnt channel notice more invasive?
02:04:37 <zhulikas> and I think according to irc client implementation it might not necessarily go to channel window
02:04:45 <zhulikas> it may go to active window instead
02:04:49 <zhulikas> or server window
02:07:35 <arnsholt> Is there a standard idiom for things along the lines of: for x in [0..a] { p = someComputation; for y in [0..a] { collect (x,y,p+someMoreComputation); } } ?
02:09:09 <arnsholt> Right now I've got `map transformationC . concatMap (map transformationB) . map transformationA $ input' which strikes me as sub-optimal
02:09:24 <ibid> zhulikas: maybe but notices are the way bots are supposed to talk.  i know most of them don't and there's probably good reasons apart from not knowing the protocol :)
02:10:24 <ibid> zhulikas: irssi, i think, handles channel notices correctly.  but they do stand out...
02:10:57 <ibid> arnsholt: i'm not sure how your two versions are related.  what's someComputation vs transformationX?
02:11:12 <danr> arnsholt: use a list comprehension?
02:12:28 <arnsholt> ibid: transformation is a bad choice of name I suppose
02:12:50 <ibid> i agree with danr, it looks like something comprehensions are good for
02:13:09 <arnsholt> Yeah, I think judicious list comprehensions might be the way to go
02:13:39 <arnsholt> It's not possible to get the concatMap behaviour with comprehensions, is it?
02:13:54 <ibid> transformation is a good name, i just couldn't undertand someComputation (sounds like monadic stuff but perhaps you just left out some parameters?)
02:14:35 <arnsholt> Yeah, I left out some parameters
02:14:58 <ibid> in that case, yeah, list comprehensions are the key
02:15:19 <arnsholt> The first computation is dependent only on x, so it should be precomputed but there's more to compute for the ys
02:16:16 <arnsholt> (And there's a fair bit of stuff to compute, so precomputing makes a difference)
02:16:26 <ibid> it is probably possible to do it in a single comprehension, as it can do nested loops
02:16:46 <ibid> the compiler may be able to lift out stuff that has no data dependency on the inner loop
02:17:22 <arnsholt> Good point
02:21:15 <arnsholt> Yeah, there we go. List comprehension is lots more readable
02:24:22 * hackagebot font-opengl-basic4x6 0.0.3 - Basic4x6 font for OpenGL  http://hackage.haskell.org/package/font-opengl-basic4x6-0.0.3 (BrianLewis)
02:27:35 <arnsholt> While I'm asking questions: Is there a standard way to do parallelization?
02:29:24 * hackagebot boomslang 0.0.4 - Boomshine clone  http://hackage.haskell.org/package/boomslang-0.0.4 (BrianLewis)
02:29:32 <arnsholt> My problem is just som over a map doing an expensive transform, so it's not a very weird problem
02:30:13 <mekeor> arnsholt: "The first thing to start with parallel programming in Haskell is the use of par/pseq from the parallel library." – http://www.haskell.org/haskellwiki/Parallelism
02:30:30 <fmap> @hackage parallel
02:30:30 <lambdabot> http://hackage.haskell.org/package/parallel
02:30:52 <mekeor> arnsholt: also, http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html which is also mentioned on that wiki-page.
02:31:16 <arnsholt> Spiffy. Thanks!
02:31:19 <absence> after upgrading to the latest haskell platform my program dies with "Prelude.undefined". is there a way to make it tell me what source file, line, etc. causes this?
02:32:03 <mekeor> absence: i'd just grep your source files for "undefined"…
02:32:10 <bitonic> absence: yes, there is some option, wait
02:32:30 <absence> mekeor:  my source doesn't contain undefined, otherwise it would be easy :)
02:32:43 <mekeor> absence: ah, okay. hm, strange…
02:33:08 <mikeplus64> absence: hpaste it
02:33:11 * mekeor is excitedly waiting for bitconic…
02:33:21 <absence> mikeplus64: what, the entire program?
02:33:28 <fmap> absence: http://stackoverflow.com/questions/10838785
02:34:01 <mikeplus64> absence: unless it's huge , guess so, but wait for bitonic to come up with this magical option
02:34:40 <bitonic> absence: ok, you have to compile with profiling enabled and use -xc
02:34:59 <bitonic> but if it's in library code it's a problem, I *think*. it's worth a try.
02:35:46 <absence> bitonic: i guess it has to be in a library since there's no undefined in my own code, or can it occur for some other reason?
02:35:49 <bitonic> i'm not sure wether it installs a version of the libraries with profiling enabled as well
02:36:14 <bitonic> absence: no, that exception means that somebody is using "undefined"
02:37:54 <bitonic> absence: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html search for "-xc"
02:39:03 <bitonic> absence: so compile with -fprof-auto and then run with +RTS -xc -RTS
02:42:34 <absence> mikeplus64: http://hpaste.org/69486
02:43:31 <absence> bitonic: thanks, i'll see if i can figure out how to do it (i'm just using leksah, haven't invoked the compiler manually)
02:44:40 <burbul> is there a 'or' fn of type (a->Bool) -> (a->Bool) -> a->Bool  ?
02:44:46 <burbul> @hoogle (a->Bool) -> (a->Bool) -> a->Bool
02:44:46 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
02:44:46 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
02:44:46 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
02:45:09 <bitonic> absence: it will definitely tell you wich function call provoked that, I'm not sure it'll tell you which external function did
02:45:55 <mekeor> burbul: did you mean: (a->Bool) -> (a->Bool) -> Bool
02:45:57 <bitonic> @djinn (a->Bool) -> (a->Bool) -> a->Bool
02:45:58 <lambdabot> f a b c =
02:45:58 <lambdabot>     case b c of
02:45:58 <lambdabot>     False -> a c
02:45:58 <lambdabot>     True -> False
02:46:01 <bitonic> mekeor: no
02:46:19 <burbul> no i didnt
02:46:22 <mekeor> what should that function do?
02:46:24 <bitonic> mekeor: I don't know how you can define the function you proposed
02:46:31 <bitonic> mekeor: see the djinn output
02:46:50 <burbul> thanks
02:47:02 <absence> bitonic: -fprof-auto didn't work, the runtime complains that i have to compile with -prof to use -xc. if i do that, ghc complains about not finding profiling libraries for this and that package
02:47:07 <bitonic> burbul: I'd write differently
02:47:14 <burbul> I want to write something like
02:47:15 <Botje> @pl \x -> f x || g x
02:47:15 <lambdabot> liftM2 (||) f g
02:47:16 <burbul> (isAlphaNum || (`elem` "'"))
02:47:18 <bitonic> absence: damn, right
02:47:50 <burbul> i ca define my own ptwise or fn, but
02:47:59 <bitonic> absence: did you install your packages with cabal? cabal should install them iirc. did you install them with some third party package manager?
02:48:17 <burbul> I thought I should be able to lift (||) using something
02:48:24 <Botje> burbul: see the @pl output above
02:48:26 <mekeor> ah! i think i got the purpose of that function now. nice.
02:48:38 <burbul> thanks!
02:48:51 <burbul> What monad is that in?
02:48:56 <mekeor> (->) ?
02:49:00 <absence> bitonic: just "cabal install packagename"
02:49:07 <burbul> I didn't even realise that was a monad!
02:49:21 <burbul> Thank you very much.
02:49:27 <mekeor> burbul: well, ((->) r) is a monad.
02:49:35 <bitonic> absence: yes, and enable library-profiling in ~/.cabal/config
02:50:00 <burbul> Return is the const function, or something like that
02:50:02 <burbul> ?
02:50:21 <bitonic> burbul: yes
02:50:29 <bitonic> @src return ((->) a)
02:50:29 <lambdabot> Source not found. You speak an infinite deal of nothing
02:50:32 <burbul> What is that monad called? I want to read about it...
02:50:39 <burbul> Obviously googling -> isn't very helpful
02:50:41 <bitonic> burbul: reader monad
02:50:41 <mekeor> @src ((-> r) return
02:50:41 <lambdabot> Source not found.
02:50:47 <bitonic> @src return ((->) a)
02:50:48 <lambdabot> Source not found. Sorry.
02:50:49 <burbul> Thank you.
02:50:58 <mekeor> @src ((->) r) return  -- wasn't the syntax like that?
02:50:58 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
02:51:03 <mekeor> =)
02:51:07 <bitonic> @src [] return
02:51:07 <lambdabot> return x    = [x]
02:51:10 <bitonic> yes
02:51:10 <mekeor> ah, ok
02:51:20 <bitonic> @src (a ->) return
02:51:20 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
02:51:27 <bitonic> fine, FINE.
02:52:28 <absence> bitonic: and then cabal install --reinstall packagename?
02:53:10 <bitonic> absence: yes
02:53:57 <absence> bitonic: oh dear. doing that makes it complain about lacking profiling version of all the dependencies :p
02:54:15 <absence> can i force it to understand what i want? heh
02:55:17 <bitonic> absence: not sure... I'd probably hack some shell script or whatever.
02:55:32 <bitonic> or you can always wipe and reinstall the world :P
02:56:35 <burbul> So in that monad, >>= has type
02:56:54 <burbul> (a -> r) -> (a -> (b -> r)) -> b -> r
02:57:00 <absence> cabal: The following packages are likely to be broken by the reinstalls:
02:57:01 <absence> haskell-platform-2012.2.0.0
02:57:04 <absence> awesome :D
02:57:31 <burbul> @djinn (a -> r) -> (a -> (b -> r)) -> b -> r
02:57:32 <lambdabot> -- f cannot be realized.
02:57:45 <bitonic> burbul: no, (a -> r) -> (r -> (a -> c)) -> (a -> c)
02:58:36 <burbul> Wait... surely the middle thing is meant to be a -> m c, not m (a -> c)
02:58:47 <bitonic> @djinn (a -> r) -> (r -> (a -> c)) -> (a -> c)
02:58:47 <lambdabot> f a b c = b (a c) c
02:59:30 <bitonic> burbul: `m a -> (a -> m b) -> m b' substitute `m' with `x ->'
02:59:38 <burbul> Ahhhhh.... I thought
03:00:10 <burbul> ((->) r) meant functions to r, because I misread it as ( -> r) , and it didn't make any sense. (also didn't seem to be reader)
03:00:13 <bitonic> burbul: you got confused because of the `a's :P
03:00:20 <bitonic> ah, ok.
03:00:23 <burbul> I got confused because of brackets
03:00:25 <burbul> Thanks
03:00:36 <bitonic> @src Reader
03:00:36 <lambdabot> Source not found. You type like i drive.
03:01:10 <burbul> It makes perfect sense now -- thank you.
03:01:20 <bitonic> burbul: coolio.
03:01:33 <fmap> @src (->) return
03:01:34 <lambdabot> return = const
03:01:35 <fmap> @src (->) (>>=)
03:01:36 <lambdabot> f >>= k = \ r -> k (f r) r
03:02:17 <bitonic> oh, damn you lambdabot
03:03:17 <mekeor> oh omg -.-
03:03:24 <bitonic> absence: did you make it? I'm curious on how this ends. -xc is not well known enough
03:05:36 <stu002> Has anyone installed cairo/gtk etc with platform 2012.2.0.0 on OS/X?
03:06:05 <stu002> I'm getting /usr/local/Cellar/glib/2.32.3/include/glib-2.0/glib/gthread.h:28:2:
03:06:06 <stu002>      error: #error "Only <glib.h> can be included directly."
03:06:27 <stu002> Which may be a Homebrew error or ghtk2hs problem--not sure
03:07:33 <absence> bitonic: no, i realised that in order to rebuild world, i will have to patch vec again, which i did manually by hitting the pause key after cabal has extracted the source files to a temp dir, and then edited the files before letting cabal go on ... not somethink i'm very keen on doing again :)
03:08:25 <bitonic> absence: patch vec? also, you can do that simply by downloading the tarball, editing and then issuing `cabal install' in the dir
03:10:10 <absence> bitonic: vec doesn't compile on ghc 7.4. thanks for the install from dir tip :)
03:10:34 <otters> omg
03:10:44 <otters> any kind of declaration now allowed in ghci
03:10:46 <bitonic> absence: do it! i'm curious now
03:12:25 <bitonic> otters: life is good
03:12:30 <otters> and I see TraditionalRecordSyntax is now an extension
03:12:37 <otters> why would you want to turn that off?
03:15:12 <bitonic> otters: who knows
03:16:25 <bitonic> otters: http://hackage.haskell.org/trac/ghc/ticket/3356
03:16:46 <bitonic> it still does not explain why.
03:17:14 <bitonic> well, it does, but no use case
03:17:40 <otters> huh
03:17:54 <otters> I rather like haskell98 records, especially the update syntax
03:17:57 <otters> but whatever
03:19:26 <lasse_> Hi. Quick newbie question. I have a list [0..1000] and I want to filter the list. The returning list should be the numbers where remainder = 0 for at least one of the elements when dividing by a second list [3,5,10].
03:20:31 <otters> lasse_: use any
03:20:34 <otters> :t any
03:20:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:23:01 <fmap> smells euler
03:23:59 <fmap> lasse_: btw 10 in second list seems redundant
03:25:12 <lasse_> fmap: Sure it is :) I want to generalize my solution to take an arbitrary list of divisors.
03:27:25 <fmap> lasse_: well, \x -> any (\y -> x `mod` y) [3,5,10] will check if x is divisible by any of 3, 5 and 10
03:29:35 <lasse_> fmap: Thanks a lot.
03:33:41 <otters> @src lookup
03:33:41 <lambdabot> lookup _key []          =  Nothing
03:33:41 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
03:33:42 <lambdabot>                         | otherwise = lookup key xys
03:34:18 <absence> bitonic: http://hpaste.org/69487
03:34:33 <otters> there isn't a reverse lookup, is there
03:34:41 <otters> i.e. a -> [(b,a)] -> Maybe b
03:34:44 <otters> guess not
03:35:02 <absence> bitonic: that doesn't tell me much, but at least it worked ;)
03:35:48 <bitonic> absence: well that sucks.
03:39:09 <absence> does anyone understand what that hpaste means?
03:39:18 <fmap> otters: you can easy define it yourself
03:39:24 <fmap> @type lookup ?a . map (\(x,y) -> (y,x))
03:39:25 <lambdabot> forall a b. (?a::a, Eq a) => [(b, a)] -> Maybe b
03:47:13 <alex-shpilkin> @type flip lookup
03:47:14 <lambdabot> forall a b. (Eq a) => [(a, b)] -> a -> Maybe b
03:47:26 <alex-shpilkin> whoops
03:48:44 <alex-shpilkin> @let swap (x, y) = (y, x)
03:48:44 <lambdabot>  Defined.
03:48:52 <alex-shpilkin> @type fmap swap lookup
03:48:52 <otters> @src guard
03:48:53 <lambdabot>     Couldn't match expected type `(t, t1)'
03:48:53 <lambdabot>            against inferred type `[(a, b)] -> Maybe b'
03:48:53 <lambdabot>     Probable cause: `lookup' is applied to too few arguments
03:48:53 <lambdabot> guard True  =  return ()
03:48:53 <lambdabot> guard False =  mzero
03:49:14 <alex-shpilkin> @type fmap (map swap) lookup
03:49:15 <lambdabot>     Couldn't match expected type `[(t, t1)]'
03:49:15 <lambdabot>            against inferred type `[(a, b)] -> Maybe b'
03:49:15 <lambdabot>     Probable cause: `lookup' is applied to too few arguments
03:50:04 <merijn> How about
03:50:20 <merijn> :t \x -> lookup x . map swap
03:50:21 <lambdabot> forall a b. (Eq a) => a -> [(b, a)] -> Maybe b
03:51:15 <merijn> (Also, why is swap not in the Prelude. I need that thing all the time...)
03:51:46 <Botje> merijn: it was suggested and bikeshedded to death
03:52:10 <Botje> ah, no
03:52:13 <Botje> it was revived
03:52:17 <Botje> and it's supposedly in Data.Tuple now
03:52:25 <Botje> @hoogle swap
03:52:25 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
03:52:25 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
03:52:25 <lambdabot> Graphics.UI.GLUT.Window swapBuffers :: IO ()
03:52:29 <Botje> lookit that :)
03:54:35 * hackagebot bkr 0.1.0 - Backup utility for backing up to cloud storage services (S3 only right now)  http://hackage.haskell.org/package/bkr-0.1.0 (MichaelSmietana)
03:57:12 <absence> is it possible to get more details about a runtime error than this? hpaste.org/69487
03:58:55 <Botje> absence: it looks like you have a top-level definition that evaluates to undefined
03:59:31 <absence> Botje: is it possible to find out which module causes it? it's not in my code
03:59:42 <absence> Botje: (or at least, i have no "undefined" in it)
04:00:14 <Botje> there's a module called system.system
04:00:17 <Botje> might it be that?
04:01:26 <absence> Botje: googling for '"system.system" haskell' doesn't result in much
04:02:29 <merijn> absence: Try inserting some prints for binary search debugging and figure out where it goes wrong?
04:02:35 <absence> Botje: and the only System dir in my cabal dir contains a subdir called Timeout
04:03:20 <kallisti_> it baffles me when base libraries use Int when they mean Word.
04:04:10 <absence> merijn: it happens in glut's mainLoop
04:05:01 <merijn> Some undefined callback then?
04:05:05 <Botje> absence: can you show code?
04:06:05 <absence> Botje: sure, http://hpaste.org/69486
04:06:38 <absence> merijn: hmm, maybe that's it. it worked in the previous version of haskell platform though
04:08:14 <Botje> yeah, nothing CAF-y that stands out :/
04:10:10 <absence> Botje: what's CAF?
04:10:33 <kallisti_> so Chan's allowInterrupts?
04:10:36 <kallisti_> er
04:10:38 <kallisti_> s/so/do/
04:11:18 <kallisti_> I mean, when you're blocking on a MVar or a Chan within a mask, will exceptions be masked during that block?
04:11:23 <merijn> WordX is unsigned and guaranteed to wrap-around on overflow, right?
04:11:33 <kallisti_> yes.
04:11:56 <merijn> ok, thanks
04:13:00 <Botje> absence: "constant applicative form"
04:13:17 <Botje> absence: basically something that can be hoisted to the top level
04:13:38 <Botje> absence: if you feel up to it you could inspect the core and see if there's anything suspicious there..
04:13:44 <Botje> I think the CAFs are explicitly marked as such
04:16:06 <absence> Botje: i haven't learned core yet, unfortunately
04:16:13 <absence> i think that for now i'll just downgrade
04:16:45 <Botje> core is haskell, just uglier ;)
04:16:45 <kallisti_> writeChan will never block, right?
04:17:35 <merijn> kallisti_: Not for long
04:18:01 <merijn> kallisti_: It can conceivably be blocked for a few microseconds if someone else is writing concurrently (due to the mutual exclusion)
04:18:18 <otters> @pl \x -> isAlpha x || isDigit x
04:18:18 <lambdabot> liftM2 (||) isAlpha isDigit
04:18:21 <merijn> But no long term blocking should happen. afaik
04:20:05 <absence> Botje: can i make ghc output core for the entire program then, not just my code?
04:21:25 <Botje> no clue .. I think core output is per-module :(
04:22:27 <HugoDaniel> i was reading up this http://www.haskell.org/haskellwiki/Smart_constructors
04:22:42 <HugoDaniel> and i was wondering if using the error function is a good approach
04:22:47 <HugoDaniel> it throws an exception :/
04:22:54 <HugoDaniel> shouldn't it be better to use Either instead ?
04:23:15 <HugoDaniel> when is it preferable to use error instead of Either ? or vice-versa
04:23:25 <hpc> in theory (and usually in practice as well), error isn't possible to catch
04:23:44 <hpc> it throws an exception in non-IO code, which makes it hard to pin down when exactly the error will get thrown
04:23:51 <hpc> it might never, if you don't evaluate it
04:24:08 <HugoDaniel> yeah
04:24:08 <merijn> HugoDaniel: The later part deals with compile time constraint checking, no?
04:24:16 <HugoDaniel> yes
04:24:19 <hpc> in any event, it makes it very hard to figure out what part of your code needs to catch it
04:24:21 <merijn> HugoDaniel: It also depends on your desired failure mode
04:24:38 <hpc> so if you ever want a failure to do anything but terminate the program, don't use error
04:24:40 * hackagebot fixplate 0.1.4 - Uniplate-style generic traversals for optionally annotated fixed-point types.  http://hackage.haskell.org/package/fixplate-0.1.4 (BalazsKomuves)
04:24:40 <kallisti_> merijn: I'm wondering if I should uninterruptibleMask_ when write to the chan.
04:25:07 <kallisti_> merijn: I write to a chan and increment an IORef afterwards. I want the IORef to always increment if the write goes through
04:25:09 <merijn> I often write code in the Go failure model (which maps fairly trivially to haskell exceptions). Which is "attempt complicated block X and discard any errors after reporting"
04:25:31 <kallisti_> merijn: actually I guess the exception will be thrown before the write happens, not after.
04:25:33 <merijn> kallisti_: Use TChan and STM?
04:25:34 <kallisti_> in a masked state.
04:25:51 <merijn> I don't think you can atomically write and update the IORef otherwise?
04:25:55 <kallisti_> well, I'm specifically trying to rewrite an existing IO-based library. but yeah I could rewrite everything into STM
04:25:57 <HugoDaniel> ok
04:26:06 <HugoDaniel> thanks
04:26:53 <kallisti_> merijn: the only purpose for the IORef is to test emptiness/fullness of the channel  (I'm attempting to rewrite BoundedChan so that isEmpty doesn't block)
04:27:04 <merijn> hpc: Well, "do X if failed then report error" can also be useful failure model for simple programs/server type things
04:27:08 <otters> isEmpty blocks?
04:27:09 <otters> that seems silly
04:27:20 <kallisti_> it blocks if there's an existing blocking reader.
04:27:24 <kallisti_> which is often I would imagine.
04:27:47 <merijn> otters: It does? Where does it say that?
04:27:53 <otters> ask kallisti_
04:28:03 <kallisti_> in the documentation of the latest version
04:28:51 <kallisti_> I may just rewrite it in STM. but then I'd have to rewrite QSem too, since that's what I want to use to implement it.
04:28:57 <merijn> Oh, that's only for BoundedChan
04:29:06 <merijn> Well, it sorta makes sense
04:29:16 <merijn> I guess?
04:29:39 <merijn> If there's already a blocked reader you might end up getting blocked reading a non-empty channel
04:30:08 <kallisti_> the MVar index, specifically.
04:30:29 <kallisti_> so I'm reimplementing the logic using a regular Chan and a QSemN
04:30:40 <kallisti_> and then using an IORef seperately to handle the isEmpty test.
04:30:42 <kallisti_> which won't block ever.
04:31:09 * kallisti_ might be better off with STM.
04:33:13 <kallisti_> another nice thing about using QSem is that you can change the bounds of the queue.
04:35:09 <kallisti_> I think just using mask_ will ensure that exceptions don't leave the IORef in an inaccurate state.
04:35:17 <cizra> solarus: (add-hook 'haskell-mode-hook 'turn-on-haskell-indent) is in my .emacs. Looks correct?
04:35:48 <kallisti_> I'm not looking for atomicity here, just consistency in the event that an exception is thrown in the middle of the read/write
04:38:36 <kallisti_> oh nevermind someone already made an STM quantity semaphore
04:39:04 <merijn> Style question: "when cond $ print $ foo ++ bar" or "when cond . print $ foo ++ bar"?
04:39:50 <merijn> (Or the bonus option "neither"?)
04:44:18 <mcstar> yay, i resisted giving advice!
04:44:18 <lambdabot> mcstar: You have 1 new message. '/msg lambdabot @messages' to read it.
04:44:30 <mcstar> wth, ive got message?
04:45:43 <earthy> it's possible
04:46:34 <mcstar> claudius finished his fractal video
04:49:14 <siracusa> merijn: In that case I prefer the former
04:49:24 <Cheery> hi
04:50:12 <mcstar> btw, i have proof that haskell is wrong
04:51:14 <Cheery> show it
04:51:30 <kallisti_> merijn: the f . g $ x  is à la mode, for what it's worth.
04:51:34 <mcstar> i was just wondering about the behavior of fmap wrt functions
04:51:41 <ziman> @faq can Haskell deceive you into thinking that it's wrong?
04:51:41 <lambdabot> The answer is: Yes! Haskell can do that.
04:51:58 <int-e> @type fix id
04:51:59 <lambdabot> forall a. a
04:52:01 <mcstar> why would fmap = (.) for (->) a ?
04:52:14 <int-e> mcstar: are you thinking of something like that?
04:52:41 <mcstar> i was thinking about how fmap behaves wrt other things
04:52:54 <mcstar> seems to be not consistent when projected to functions
04:53:04 <merijn> mcstar: fmap = (.) in Caleskell/lambdabot
04:53:05 <Botje> mcstar: why not?
04:53:37 <merijn> I'm not sure it is fo' real? Although, now that I look it might be
04:53:42 <mcstar> fmap f (Just x) = Just (f x)
04:53:51 <mcstar> thats where i start
04:53:58 <mcstar> now, change Just for g
04:54:05 <mcstar> fmap f (g x) = g (f x)
04:54:19 <mcstar> g is a function, which is a sort of like a Just context
04:54:22 <merijn> "fmap :: (a -> b) -> f a -> f b" and "(.) :: (b -> c) -> (a -> b) -> a -> c", now let's substitute by hand
04:54:40 <mcstar> so id argue, that:
04:54:52 <mcstar> fmap f g = \x -> g (f x) should be right
04:55:23 <Botje> isn't that a type error?
04:55:24 <merijn> For functions. the f in fmap becomes "(->) d", turning it into "fmap :: (a -> b) -> ((->) d a) -> ((->) d b)"
04:55:54 <kallisti_> merijn: well, (.) = fmap in lambdabot. ;)
04:56:01 <merijn> Let's simplify once further: "fmap :: (a -> b) -> (d -> a) -> (d -> b)" == the type signature for (.)
04:56:58 <merijn> mcstar: I think you have f and g reversed in your version?
04:57:05 * kallisti_ is uncertain that there's any sane way to gracefully handle errors with this attempted BoundedChan fix.
04:57:06 <mcstar> the difference between Just and 'g' is that g can do something with its argument, while Just cant, Just x is a WHNF(?) but (g x) can result in anything
04:57:11 <merijn> You apply f to the result of g, not reverse
04:57:31 <mcstar> merijn: thats what i argue about, it would make more sense to me if it was reversed
04:57:40 <merijn> Why?
04:57:49 <merijn> Look at the type signature substitution I just did
04:59:00 <mcstar> merijn: so you are saying that "fmap f g = \x -> g (f x)" wouldnt typecheck?
04:59:33 <merijn> Yes
04:59:36 <mcstar> (or couldnt be made an instance of Functor)
04:59:46 <kallisti_> the problem here, I believe, is that I can't really differentiate between errors that occur during the readChan block, and the ones that occur immediately after but before my other code.
04:59:50 <kallisti_> maybe with some clever use of bracket..
05:00:28 <merijn> :t \f g -> (\x -> g (f x))
05:00:29 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t2) -> t -> t2
05:00:35 <merijn> :t fmap
05:00:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:00:45 <merijn> :t (.)
05:00:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:00:50 <merijn> oh, doh
05:00:54 <merijn> :t (Prelude..)
05:00:55 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:01:10 <merijn> Compare (.) and fmap and then compare those to your suggestion
05:02:00 <kallisti_> this would be easier if I could get at the number stored in the QSem..
05:29:02 <kallisti_> merijn: actually it looks like Chan has the same problem with isEmptychan
05:33:20 <mekeor> mikeplus64: does ghc 7.4 work fine with most packages on hackage?
05:33:38 <mikeplus64> definitely
05:34:09 <mekeor> is it easy to install ghc manually? the binary, i mean. i dont wanna compile!
05:34:26 <Peaker> mekeor, yes
05:34:27 <mikeplus64> the HP now ships with 7.4.1, so there is that
05:34:28 <Eduard_Munteanu> mekeor: Linux?
05:34:30 <mekeor> should i install HP or GHC?
05:34:33 <mekeor> Eduard_Munteanu: yea
05:34:44 <Eduard_Munteanu> Maybe your distro already provides a package.
05:34:47 <Peaker> mekeor, e.g: http://www.haskell.org/ghc/download_ghc_7_4_1#binaries
05:34:59 <mekeor> Eduard_Munteanu: debian testing provides ghc 7.0.4
05:35:03 <Peaker> mekeor, you basically run "configure --prefix=/usr/local && sudo make install"
05:35:15 <Peaker> mekeor, the commands are like those on source, but on the binary
05:35:33 <mekeor> Peaker: does it compile? no, it's binary, of course..
05:35:40 <Eduard_Munteanu> mekeor: maybe you can check unstable? IIRC Debian had some support for mixing branches
05:35:53 <Peaker> mekeor, they just copy binaries
05:35:57 <mekeor> Eduard_Munteanu: nah. don't want to do that…
05:36:05 <mekeor> Peaker: nice.
05:36:11 <mekeor> i'll do that, thanks, Peaker
05:36:32 <mekeor> thank you too, Eduard_Munteanu and mikeplus64
05:36:57 <chenxing> hello
05:37:04 <chenxing> I am new here
05:37:15 <mekeor> i'm still considering NixOS because it has 7.4 in its repo and you can really easily install multiple versions simultaniously.
05:37:24 <mekeor> chenxing: welcome :)
05:38:23 <aristid> mekeor: you can use nix without nixos :)
05:38:43 <aristid> mekeor: that's how i've installed my haskell (and most haskell libraries)
05:38:49 <aristid> -haskell+ghc
05:38:54 <mekeor> aristidisn't that ugly? or does it work nice? i dont think so…
05:39:02 <aristid> works nice
05:39:08 <mekeor> hm.
05:39:40 * mekeor is looking forward to be able to define types in GHCI =)
05:39:47 <aristid> you do need root access to your computer though, because binary packages need things to be in /nix
05:40:01 <aristid> (it works without access to /nix, but needs to compile from source then)
05:40:51 <lpsmith> JoeyA:  I would not be opposed to such a patch
05:41:24 <Phlogistique> wrt nix without nixOS: is that a good way to get a recent GHC on an old Ubuntu?
05:41:31 <Eduard_Munteanu> Damn, why can't package managers work on "local" prefixes out of the box?
05:41:40 <Eduard_Munteanu> User-local, that is.
05:41:47 <lpsmith> I'm certainly not particularly attached to PCRE
05:42:26 <mikeplus64> Eduard_Munteanu: (please don't hurt me for saying cabal is a package manager) cabal works fine as a local thingo "out of the box"
05:43:13 <Eduard_Munteanu> Yeah, that does it. I mean stuff like distro package managers.
05:43:33 <Eduard_Munteanu> IIRC, only stuff like Gobo does that.
05:43:42 <mekeor> is "cabal upgrade" a *missing* feature or is the lack of that feature intended?
05:44:41 <mikeplus64> Eduard_Munteanu: well, you can specify with pacman the -r flag to say where root is
05:45:05 <fmap> mekeor: cabal upgrade is removed feature
05:45:09 <mekeor> Peaker: i can now access to ghc-7.4.1 with "ghc-7.4.1" but "ghc" is still ghc-7.0.4. how do i change that?
05:45:11 <mekeor> fmap: why?
05:45:19 <Eduard_Munteanu> mikeplus64: well, does it handle user-local stuff, and track packages separately? :)
05:45:32 <Peaker> mekeor, ls -l `which ghc` ?
05:45:41 <Phlogistique> mekeor: it breaks everything
05:45:43 <Eduard_Munteanu> Portage, for example, can be used with a different root too, but it doesn't really work like cabal does.
05:46:03 <fmap> mekeor: I'd guess because upgrading to latest version often leads to broken packages.
05:46:43 <mekeor> hm ok
05:46:57 <mekeor> Peaker: so i have to manually change the symlink? -.-
05:47:26 <Peaker> mekeor, I am not sure what/who maintains that symlink normally
05:47:35 <Peaker> apparently ghc installer doesn't :)
05:47:42 <mekeor> :)
05:47:46 <mekeor> oh wait
05:47:58 <mekeor> /usr/local/bin/ghc -> ghc-7.4.1
05:48:07 <mekeor> but when i type ghc --version i get 7.0.4
05:48:13 <mekeor> probably have to restart shell
05:48:38 <mekeor> yea, works now. lol. thanks Peaker :)
05:48:56 <mekeor> now i should base, right? cabal install base
05:49:21 <Peaker> mekeor, no
05:49:26 <mekeor> Peaker: why not?
05:49:30 <Peaker> mekeor, the ghc installer installs a bunch of global packages including base
05:49:34 <mekeor> ah nice
05:49:36 <Peaker> mekeor, Use ghc-pkg list
05:49:54 <mekeor> what does that do?
05:50:07 <Peaker> mekeor, shows you the database of installed packages
05:50:31 <Peaker> mekeor, basically you should avoid reinstalling packages that came with ghc..   ghc-pkg list shows the "global" packages and "user" packages.  Most install only into the "user" part, and avoid "shadowing" packages in the global part
05:50:34 <mekeor> OK, fine. i now have base-4.5. YAY!
05:51:05 <Peaker> so if you have a "Cabal" package in the global part of "ghc-pkg list", don't "cabal install Cabal"
05:52:00 <mekeor> OK.
05:54:49 <Elemir____> @pl \f g x -> f x $ g x
05:54:49 <lambdabot> ap
05:55:13 <Elemir____> Hem
05:55:17 <Igloo> Does anyone know how to make ctrl-q activate a quit menu in gtk2hs? I've tried things like http://paste.debian.net/172797/ but I'm getting nowhere
05:55:26 <Elemir____> lol
05:58:22 <kallisti_> merijn: do you ever get that feeling that you're probably doing something horribly wrong? http://sprunge.us/CEEG?haskell
05:59:54 <Peaker> In transformers, operations that are contravariant or invariant on the transformed-monad action cannot be lifted.. Are you supposed to implement these operations manually with knowledge of the entire monad stack?
06:00:10 <Peaker> For example, you can't "liftToReader (local (+1))"
06:00:34 <Peaker> lifters have type :: m a -> t m a        but operations like "local" don't have type "m a", but "m a -> m a" or such
06:01:25 <kallisti_> Peaker: is liftToReader just regular lift?
06:01:39 <Peaker> kallisti_, yeah, that reaches the Reader layer
06:01:48 <kallisti_> right
06:01:53 <Peaker> (e.g: it might be: liftToReader = lift . lift . lift)
06:02:23 <kallisti_> I was going to say "why not use local" but then that would be mtl and not transformers.
06:03:30 <kallisti_> Peaker: lift . local (+1)  ??
06:04:11 <Peaker> @type Control.Monad.Trans.Reader.local
06:04:12 <lambdabot> forall r (m :: * -> *) a. (Monad m) => (r -> r) -> ReaderT r m a -> ReaderT r m a
06:04:20 <Peaker> @type Control.Monad.Trans.Class.lift
06:04:20 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
06:04:37 <Peaker> @type Control.Monad.Trans.Class.lift . Control.Monad.Trans.Reader.local (+1)
06:04:38 <lambdabot> forall a (t :: (* -> *) -> * -> *) a1 (m :: * -> *). (MonadTrans t, Monad m, Num a1) => ReaderT a1 m a -> t (ReaderT a1 m) a
06:04:50 <Peaker> that's not quite it...
06:04:59 <kallisti_> I must have misunderstood then
06:05:09 <Peaker> kallisti_, the problem is that "lift" takes an "m a", and "local" is "m a -> m a"
06:05:29 <Peaker> the types don't match
06:06:33 <kallisti_> oh you want to transform local (+1) into t (ReaderT a1 m) a -> t (ReaderT a1 m) a
06:06:57 <Peaker> yeah, but lift is covariant only
06:07:14 <Peaker> you need "unlift" for the contravariant side
06:07:19 * kallisti_ is not very good with the precise meaning of the *variant terms.
06:07:28 <kallisti_> but yeah I understand.
06:07:30 <tgeeky> kallisti_: something about counting the number of (->)
06:08:36 <mekeor> mikeplus64: is SDL a nice library for things like Level0?
06:08:53 <mikeplus64> yeah, although my usage of it was really just abusing fillRect
06:08:56 <Peaker> basically, types are covariant until they are on the left side of (->)
06:09:06 <Peaker> the left part of (->) is contravariant
06:09:25 <Peaker> but inside the contravariant part, you also have (->)'s, so the left-side of those (->)'s is covariant again
06:09:49 * hackagebot Paraiso 0.3.0.0 - a code generator for partial differential equations solvers.  http://hackage.haskell.org/package/Paraiso-0.3.0.0 (TakayukiMuranushi)
06:10:01 <Peaker> so ((a -> b) -> (c -> d))   a is in a covariant pos, b is in a contravariant pos, c is in a contravariant pos, d is in a covariant pos
06:10:19 <Peaker> a is in a covariant pos because it is behind an even number of (->)'s left side
06:10:44 <Peaker> if the same type variable appears in both covariant and contravariant positions, it becomes "invariant"
06:10:52 <tgeeky> kallisti_: Peaker: from the "Bananas in Space: Extending Fold and Unfold to Exponential Types" in S3.3 it says:  "An occurrence of a type variable in a type expression is said to be *contra* if it occurs to the *left* of an *odd* number of nested arrows (->), and covariant otherwise."
06:11:50 <Peaker> if a type (T :: * -> *) has its type variable appear in both covariant and contravariant positions, then "T" is said to be invariant w.r.t its type parameter
06:12:10 <Peaker> and if and only if T is covariant to its type variable, then (Functor T) instance can be implemented
06:12:18 <tgeeky> i was gonna say
06:12:32 <tgeeky> that looks like all of the functors the category theorirsts always talk about
06:12:53 * kallisti_ scratches his head.
06:12:53 <kallisti_> it
06:13:15 <kallisti_> might be a bad time to learn theoretical computer science / category theory at 9 AM with no sleep from the night before.
06:13:39 <Peaker> anyway,  If I have  "m a -> t m a"   I can modify  "<something covariant on "m a">" to "<something covariant on "t m a">"    but I can't modify something invariant on "m a"  (like   (m a -> m a))
06:13:44 <Peaker> kallisti_, oh
06:15:24 * tgeeky always remembers this in tensor notation as: co = low = on the bottom
06:15:59 <kallisti_> I want to say that transformers-base has stuff for doing this kind "unlifting" stuff.
06:16:07 <kallisti_> but I'll be damned if I can actually understand how it works.
06:16:45 <kallisti_> the author of that package really likes Greek letters..
06:21:15 <aristid> @hackage transformers-base
06:21:15 <lambdabot> http://hackage.haskell.org/package/transformers-base
06:22:01 <tgeeky> kallisti_: ah, yes. Bas van Dijk. he loves him some greek (and roman) letters.
06:22:04 <Peaker> kallisti_, I think it only does "lift all the way up to base", not "unlifting"
06:22:21 <tgeeky> kallisti_: he and his brother/cousin/something have lots of cool and interesting packages
06:22:48 <kallisti_> Peaker: ah I was looking at an older version
06:22:53 <kallisti_> that feature has been moved to monad-control
06:25:50 <Peaker> I see what monad-control does
06:25:50 <kallisti_> liftBaseOp_ (local (+1))   perhaps
06:26:08 <Peaker> anything with the word "Base" in it is related to "lifting all the way up"
06:26:13 <Gurragchaa> are there any online tutorials a la `tryhaskell.org` that go further into teaching Haskell?
06:26:31 <luite> not yet
06:26:55 <kallisti_> Peaker: I'm only familiar with monad-control in that I've used lifted-base and had to write MonadBaseControl instances
06:27:06 <kallisti_> which largely involved my satisfying types more so than actually understand what was going on.
06:34:55 <kallisti_> oh I see how monad-control works
06:35:10 <kallisti_> it encodes the transformer into the result of the inner monad. that's very clever.
06:36:38 <kallisti_> Peaker: so liftBaseOp_ (local (+1)) won't work because the ReaderT being passed to local isn't over a Num instance
06:37:11 <luite> kallisti_: yes but it has some limitations, read for example the description of the exception handling functions
06:37:19 <merijn> Gurragchaa: Not in the interactive sense, but there are some nice free books online
06:37:32 <merijn> Gurragchaa: And then you can just use ghci to play around with the examples
06:37:36 <kallisti_> the function passed to liftBaseOp_ can't be concerned with the result types of the monad.
06:38:11 <Peaker> kallisti_, I think it has to be more like:     liftWith f     where  f unlift = unlift . doStuff . lift       (f takes an inner monad action, doStuff can manipulate the (t m a -> t m a) after lifting, and then it can "unlift" it back to "m a")
06:38:31 <merijn> Gurragchaa: Specifically "Learn You a Haskell for Great Good" is excellent, and if you've finished tryhaskell then installing haskell shouldn't be such a huge hurdle
06:38:37 <Peaker> but my monad transformer stack is not itself a monad transformer, and my ReaderT is the outermost layer, so I don't have much to gain from MonadTransControl
06:38:42 <merijn> @where lyah
06:38:42 <lambdabot> http://www.learnyouahaskell.com/
06:39:19 <hughfdjackson> for the record, i've found that lyah is really well written, but real-world haskell helps to motivate you more
06:39:22 <Peaker> I finally see some value in the mtl-style classes.... MonadReader class is not a trivial lifter
06:39:36 <hughfdjackson> about chapter 8 of lyah, I felt like I didn't know how close i was to anything useful at all
06:39:48 <hughfdjackson> but by chapter 2 and chapter 4 of real-world haskell, i'm in no doubt :D
06:39:52 <hughfdjackson> @where real-world haskell
06:39:52 <lambdabot> I know nothing about real-world.
06:39:55 <hughfdjackson> damnit
06:40:02 <merijn> @where rwh
06:40:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:40:07 <hughfdjackson> :) thanks
06:40:18 <merijn> hughfdjackson: I started with RWH, but I got lost on some details they glossed over at first
06:40:33 <merijn> I usually recommend RWH is a second book after LYAH
06:40:36 <hughfdjackson> it almost seems like the combo is more powerful
06:40:36 <Gurragchaa> okay
06:40:38 <Peaker> I guess that's why transformers modules exports a bunch of liftLocal and such functions
06:40:49 <hughfdjackson> i mean.. side by side reading, perhaps better than sequential
06:40:53 <hughfdjackson> :D depending who you are
06:41:16 <merijn> Although I guess the start of LYAH might be a bit to easy after tryhaskell, but I'm not sure at which chapter you'd have to start
06:41:31 <merijn> On the other hand, in my experience some repetition of the basics doesn't hurt :p
06:41:44 <hughfdjackson> so long as it's accompanied by a sense of hope :D
06:42:15 <Peaker> The problem with going over the basics is that it is demotivating
06:42:35 <Peaker> you get lots of hype about Haskell and then for hours and hours all you see in Haskell are boring basics
06:42:35 <merijn> True
06:42:59 <Peaker> and you don't see anything you couldn't as well in your $favorite_language
06:43:05 * kallisti_ wasn't terribly hyped-up when he was learning Haskell.
06:43:11 <Peaker> unfortunately, you have to go through them to get to the interesting stuff, and that may be one of the main obstacles
06:43:21 <Peaker> kallisti_, then why learn it?
06:43:26 <Peaker> It's a significant time/effort investment
06:43:41 <merijn> Peaker: Because my python was becoming very functional and it wasn't very suited to that style?
06:43:48 <kallisti_> well at the time I was working on esoteric programming languages. So basically any excuse to learn a language will do.
06:44:38 * kallisti_ is not opposed to learning completely "useless" languages.
06:45:10 <HugoDaniel> is there a recomended haskell heap implementation ?
06:45:20 <aristid> kallisti_: but still you wanted more interesting languages than brainfuck, right? :D
06:45:33 <nobdraisentone> Haskell is not useless?
06:45:34 <HugoDaniel> i need a priority queue
06:45:46 <kallisti_> nobdraisentone: you forgot the scare quotes.
06:45:59 <merijn> HugoDaniel: I thought there was a priority queue on hackage already?
06:46:00 <kallisti_> HugoDaniel: I believe there's actually just a priority queue implementation out there.
06:46:13 <Peaker> merijn, there are many functional languages with easier learning curves
06:46:41 <kallisti_> aristid: yes. a language with more complexity was appealing. But I probably had different expectations than most from the start.
06:46:54 <merijn> I hated ocaml's syntax from my bachelor, haskell was prettier
06:46:58 <Peaker> I think Haskell's learning curve is not inherent, by the way
06:47:13 * aristid thinks being disgruntled with c++ is an excellent motivation to learn haskell :)
06:47:22 <merijn> I'm not really aware of many other well-known functional languages other than those
06:47:38 <merijn> SML and F# I guess, but F# wasn't really there yet and neither was Scala
06:47:56 <merijn> Or at least they weren't popular enough to have mindshare when I was looking
06:48:14 <HugoDaniel> hmm
06:48:45 <Peaker> merijn, Lisp is advocated as a functional language (though I don't think it is) and is easier to learn
06:49:00 <Peaker> merijn, Clojure is probably functional, Scala, ...
06:49:18 <ben> how about opa?~
06:49:19 <merijn> Peaker: Clojure and Scala as I mentioned are fairly recent in their gain of mindshare
06:49:32 <merijn> So I wasn't aware of their existence
06:50:09 <merijn> As for Lisp, while conceptually pretty it wasn't more conducive to my functional code and certainly not prettier in actual syntax
06:50:30 <Peaker> Common Lisp is much like a slightly-less-dynamic Python
06:50:53 <Peaker> I find it funny to call the former functional, nobody calls Python "functional"
06:50:53 <unnali> ..
06:50:57 <kallisti_> except that it actually supports functional programming.
06:51:02 <kallisti_> as opposed to Python
06:51:03 <Peaker> kallisti_, how so?
06:51:12 <Peaker> Common Lisp is as imperative as Python
06:51:18 <companion_cube> it has higher order functions, anonymous functions, lists
06:51:23 <Peaker> companion_cube, so does Python
06:51:33 <kallisti_> I'm thinking TCO, sensible lambdas, libraries that are built using higher-order functions instead of imperative/OO.
06:51:37 <companion_cube> no, python does not really have anonymous functions nor lists
06:51:38 <unnali> what about conditions/restarts, reader macros, blah blah ..
06:51:46 <arnsholt> Well, there are some design choices in Python that are intended to discourage more functional-style programming
06:51:47 <merijn> Python has higher order functions, no anonymous functions, but you can trivially fake those using closures and lsts
06:51:49 <companion_cube> python's "lists" are arrays
06:51:55 <companion_cube> python's lambdas suck
06:51:56 <arnsholt> Like lambda only taking a single expression
06:52:12 <Peaker> kallisti_, if "sensible lambdas" are the problem, then do you think Javascript is a functional language like CL?
06:52:20 <kallisti_> the fact that Python doesn't support tail call elimination whereas any sane Lisp implementation should is telling.
06:52:29 <kallisti_> Peaker: no.
06:52:40 <kallisti_> sensible lambdas are necessary but not sufficient. :P
06:52:40 <Peaker> companion_cube, Python: class Cons: def __init__(self, car, cdr): self.car = car ; self.cdr = cdr
06:53:27 <Peaker> kallisti_, Javascript+TCO has all of what you attributed to Lisp
06:53:30 <Peaker> to CL, that is
06:54:19 <kallisti_> Peaker: well, Javascript /does/ support a functional style.
06:54:35 <Peaker> kallisti_, So would you agree CL isn't any more functional than Javascript?
06:54:40 <kallisti_> sure.
06:54:46 <Peaker> both are imperative languages and support a "functional style"
06:54:55 <companion_cube> Peaker: yeah, but it's awfully slow and not integrated with the standard lib
06:55:00 <Peaker> yet one of them is referred to as "functional" whereas the other isn't
06:55:08 <kallisti_> Peaker: both are mixed paradigm. I find it odd that mixed paradigm immediately excludes functional somehow.
06:55:15 <Peaker> and the "functional style" supported by either is pretty weak, IMO
06:55:29 <kallisti_> I'm sure you could find someone who would called Javascript functional. :P
06:55:37 <Adeon> historically lisp may have been more "functional" than other languages at the time
06:55:40 <Adeon> maybe it stuck
06:56:08 <Peaker> Also, when I looked at random Lisp code out there, it is mostly very imperative
06:56:11 <kallisti_> yeah I think that has a lot to do with it.
06:56:16 <Peaker> looks like Python-with-ugly-syntax :P
06:56:21 <Adeon> I make a distinction between a functional language and being able to write in a functional style
06:56:40 <Peaker> http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf  makes a good critique of Lisp
06:56:42 * kallisti_ makes a distinction between functional and purely functional.
06:56:59 <kallisti_> multi-paradigm shouldn't exclude functional.
06:57:14 <merijn> kallisti_: But it should exclude purely functional?
06:57:20 <merijn> If so, how would you describe haskell?
06:57:23 <Adeon> erlang is not purely functional but I'd consider it a functional language where I wouldn't consider lisp one
06:57:24 <Peaker> Haskell is multi-paradigm
06:57:38 <kallisti_> Haskell is the least multi-paradigm language I know of.
06:57:51 <kallisti_> if by "multi-paradigm" you mean "assimilate all else in to our borg hivemind" then yes I agree
06:57:56 <kallisti_> it is very multi-paradigm
06:57:57 <merijn> kallisti_: Hah! Say that to my 2k LOC of extremely imperative haskell
06:58:41 <Peaker> you can transliterate programs from other languages into Haskell by converting mutable refs to IORefs and statement lists to "do" in IO very straight-forwardly.. That means Haskell supports the paradigms
06:58:57 <Peaker> merijn, why are you writing "extremely imperative Haskell"? :)
06:59:21 <merijn> Peaker: Because my problem is a very stateful simulation
06:59:41 <Peaker> merijn, are you in the IO monad? Or in some State monad transformer?
06:59:45 <merijn> So most of my code is just StateT + lenses to access it
06:59:49 <kallisti_> merijn: it's not as straight-forward as it sounds, but yes you could do that.
07:00:31 <merijn> StateT over IO, because I'm printing logging information and using Chan/MVar, but the state itself isn't inherently IO
07:00:48 <merijn> I could easily move the Chan/MVar out, but that's a bit of work for no real gain
07:02:05 <merijn> It's amazing how well things work (after I fix all compile errors), even after major refactoring
07:02:32 <merijn> Peaker: Also, because I wanted to finally write some non-trivial Haskell and this was the first "from scratch" project to cross my path :p
07:02:33 <Peaker> merijn, there's some gain to be had from restricting your monad out of IO
07:03:12 <Peaker> And a WriterT Log ...  can do logging (where Log can hide (IO ()) inside it)
07:03:18 <merijn> I know
07:03:27 <merijn> But I had already written the code when I thought of it
07:03:45 <merijn> And can't be arsed to restructure everything
07:04:04 <unnali> restructuring is so much fun with such a strong type system :3
07:04:07 <merijn> And it's a one of simulation anyway
07:04:53 * hackagebot hquantlib 0.0.2.3 - HQuantLib is a port of essencial parts of QuantLib to Haskell  http://hackage.haskell.org/package/hquantlib-0.0.2.3 (PavelRyzhov)
07:06:30 <Peaker> merijn, I've restructured base types/architecture all the time in my project.. Haskell's type system does make it a joy
07:06:35 <mcstar> merijn: yes, you are right
07:06:42 <Peaker> in 1 hour or so I can make a major change and it all works, without any UT :-)
07:06:58 <mcstar> fmap for (->) r really must be (.)
07:07:29 <kallisti_> merijn: re: paradigms. I don't think the simple possibility of emulating a paradigm makes that paradigm part of the language core.
07:07:57 <kallisti_> the idea of a paradigm is that it's the "natural" way to express solutions in the language.
07:08:23 <Peaker> kallisti_, then Lisp doesn't really support the functional paradigm :-)
07:08:30 <Peaker> it's pretty cumbersome to write "foldr" in Lisp
07:08:52 <kallisti_> well you would want to use foldl anyway, no?
07:09:27 <kallisti_> (which is called reduce in CL)
07:09:30 <Peaker> even so, without pattern-matching, it is cumbersome.. it is easier to (setf ..) in-place
07:09:42 <companion_cube> reduce is a less specific version of fold, isn't it?
07:09:44 <merijn> mcstar: Enlightenment achieved :)
07:09:55 <mcstar> ~
07:10:05 <Peaker> reduce=foldl, and there is no foldr
07:10:15 <merijn> Peaker: Sure, but at some point their is a productivity trade-off and I don't think the advantage outweighs time spent
07:11:05 <merijn> kallisti_: I'm really digging Haskell's first class IO actions though. They must be one of the least celebrated awesome haskell features. I wouldn't call them emulation or unnatural at all
07:11:16 <Peaker> merijn, I find that the restrictive(a.k.a specific) types help productivity immensely.. they add so much safety, encourage code that is composeable in more ways, etc.
07:11:31 <Peaker> merijn, they're just like "first-class functions" in imperative languages
07:11:51 <merijn> Peaker: I thought reduce was used for both foldl/foldr (i.e. no specification about associativity)
07:12:08 <kallisti_> looking at the docs it's foldl by default and foldr with an optional argument.
07:12:19 <Peaker> merijn, I'm not sure
07:12:41 <kallisti_> The reduction is left-associative, unless from-end is true in which case it is right-associative.
07:12:43 <merijn> Peaker: Sure, but this is some stand alone simulation code to generate some rough numbers to make a design decision. Safety and composeability are way down on my list of things to care about :p
07:13:00 <merijn> kallisti_: In python, yes. I was meaning in general
07:13:17 <kallisti_> merijn: I was talking about CL specifically. >_>
07:13:26 <merijn> Peaker: In fact, as long as it runs succesfully once I'm happy (yay, academic quality software!)
07:13:35 <merijn> kallisti_: Oh, in that case in both languages ;)
07:14:48 <Peaker> merijn, safety should always be up on the priority list.. lack of safety has lots of very very bad consequences, many of which you may only discover too late...
07:15:06 <Peaker> merijn, how do you know if it ever ran successfully? maybe it gave wrong results?
07:15:59 <merijn> Peaker: Yes, but considering my only use of IO reading from Chan/MVar and printing logging refactoring said events out doesn't really change the correctness
07:16:40 <untitled> how do I run a function 10 times and store each run's return value in a variable?
07:16:46 <merijn> In other words the simulation might be wrong regardless. Which is were my expert opinion comes in and I argue fro authority that it is correct :p
07:16:48 <untitled> like for loop
07:17:26 <merijn> untitled: Do you want to run it on the same argument every time? Or different ones?
07:17:45 <untitled> merijn: well, the return value is actually a modifies parameter
07:17:59 <untitled> I store it to new version of itself every time
07:18:08 <merijn> I think you want iterate?
07:18:10 <merijn> :t iterate
07:18:10 <untitled> modified*
07:18:11 <lambdabot> forall a. (a -> a) -> a -> [a]
07:18:33 <Peaker> > take 10 $ iterate (*2) 1
07:18:34 <lambdabot>   [1,2,4,8,16,32,64,128,256,512]
07:18:42 <Peaker> untitled, is that what you want?
07:18:49 <Peaker> untitled, what is the type of your function?
07:20:27 <untitled> foo :: [Obj1] -> [Obj2] -> [Obj1], Obj1 and 2 are custom types
07:20:51 <merijn> oh
07:21:17 <merijn> And you have a function "Obj1 -> Obj2 -> Obj1"?
07:21:39 <untitled> that is my function, that I want to run, say, 10 times
07:22:12 <untitled> and store return value in [Obj1]
07:22:25 <srhb> untitled: It's not clear what you want to do, though it sounds "Wrong" and "mutable"
07:22:26 <merijn> :t \f xs ys -> map (uncurry f) $ zip xs ys
07:22:27 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
07:22:54 <merijn> untitled: I don't understand what you want to run 10 times and with what inputs?
07:23:01 <srhb> untitled: hpaste your function somewhere.
07:23:09 <untitled> 17:20   untitled >> foo :: [Obj1] -> [Obj2] -> [Obj1], Obj1 and 2 are custom types
07:23:11 <Peaker> untitled, can you give the type of your existing function, and the type of the function you want from it?
07:23:24 <untitled> here is the type
07:23:48 <srhb> untitled: Okay, so do you want to call it with the same [Obj2] each time?
07:23:48 <endojelly> untitled, so... [Obj2] is fixed?
07:23:58 <untitled> yes
07:24:05 <merijn> oh!
07:24:06 <hpaste> tgeeky pasted “confusion about K combinator / pure / const” at http://hpaste.org/69492
07:24:09 <srhb> flip . somefun ...
07:24:10 <untitled> srhb: and yes)
07:24:19 <endojelly> untitled, ah. then it's actually [Obj1] -> [Obj1]. after flipping and currying.
07:24:30 <endojelly> untitled, er, after flipping and partial application.
07:24:55 <tgeeky_> byorgey: http://hpaste.org/69492 question for you, if you please
07:24:59 <merijn> Sounds like a fold of "f :: Obj1 -> Obj2 -> Obj1" over the [Obj2]?
07:25:12 <srhb> It's still just iterate.
07:25:14 <merijn> And then mapping that fold over [Obj1]
07:25:23 <kallisti_> it could be literally anything at this point. His question has been phrased completely in imperative terminology.
07:25:25 <srhb> (but with flipped args)
07:25:43 <untitled> emm, no, there is no fold, I just get some params from [Obj2]
07:25:51 <srhb> untitled: Paste your function.
07:26:34 <untitled> why? can't I just run my function 10 times without knowing what's going on inside?
07:26:57 <srhb> right now it's something like take 10 $ flip yourfunction $ obj2list obj1initiallist
07:27:09 <kallisti_> untitled: the details of the function isn't important
07:27:10 <untitled> ok, I'll try that
07:27:12 <kallisti_> how are you providing inputs?
07:27:13 <srhb> oops, forgot iterate
07:27:28 <kallisti_> untitled: are both inputs fixed?
07:27:33 <kallisti_> and you just want to repeat it N times?
07:27:36 <kallisti_> because that would be replicate
07:27:37 <merijn> untitled: Running a function 10 times will just return the same result 10 times, unless you give different inputs
07:27:52 <kallisti_> > replicate 5 1
07:27:53 <merijn> untitled: And if you want to give different inputs then you need to tell use where they come from
07:27:53 <lambdabot>   [1,1,1,1,1]
07:28:07 <merijn> (they being the inputs)
07:28:41 <srhb> take 10 $ iterate (flip yourFunction obj2list) obj1initiallist -- isn't that right?
07:28:57 <untitled> as I said, I want to store a modified array into new array every time, the type is: foo :: [Obj1] -> [Obj2] -> [Obj1], so I pass 2 arrays, modify one of them and want to assign this returned array to new array on every iteration
07:29:00 <srhb> Pretty sure it is.
07:29:09 <srhb> untitled: Those are not arrays, those are immutable lists.
07:29:17 <srhb> untitled: You never modify them.
07:30:03 <untitled> well, I don't really modify the array, but records inside it
07:30:07 <untitled> update records
07:30:10 <kallisti_> you want iterate then
07:30:15 <untitled> ok
07:30:28 <kallisti_> untitled: and it's a list, not an array.
07:30:35 <untitled> sure :)
07:30:51 <srhb> untitled: You also do not modify the values in a list. You generate a new list every time.
07:31:45 <kallisti_> untitled: as in it's a singly linked list, not a fixed-size contiguous block of memory with constant time random access.
07:32:00 <kallisti_> it's not a pedantic terminology thing.
07:32:56 <kallisti_> tgeeky_: how do sets have K combinators?
07:33:05 <kallisti_> I'm only familiar with K combinators as they relate to, well, SKI.
07:33:22 <kallisti_> the idea of "some type" having them is a bit foreign.
07:34:05 <tgeeky_> kallisti_: they don't, that's what he's saying
07:34:15 <tgeeky_> kallisti_: but I don't see how Pointeds don't have K combinators
07:34:19 <tgeeky_> that's *all* they have?
07:34:41 <tgeeky_> maybe there is a dinstinction between having pure and being a pure
07:34:44 <merijn> On unrelated note: I seriously want to murder the person that decided that Prelude.round should use banker's rounding
07:36:26 <tgeeky_> merijn: I can't wait to see the Murder Mysterys special on you. "They thought they would be safe. They thought they were doing good. But when merijn saw that they used banker's rounding, he just snapped. He flew to Cambridge. Massacre. Then to Glasgow. Destruction!"
07:36:47 <srhb> Isn't there a builtin \n f x -> last $ take n $ iterate f x ? Not a problem, but seems like a thing you'd use relatively often..
07:36:52 <srhb> (Thought perhaps not)
07:36:53 <shapr> kallisti_: I'm STILL being quiet! But now that's all over!
07:37:10 <codolio> srhb: There isn't.
07:37:14 <kallisti_> shapr: say what?
07:37:17 <srhb> Alright.
07:37:27 <codolio> It'd be the fold for natural numbers, though, if it did exist.
07:37:35 <srhb> Yes.
07:37:37 <codolio> Although, n there isn't a natural.
07:37:54 <srhb> Well, not a problem to actually just do it as a fold anyway.
07:37:57 <srhb> :)
07:38:06 <merijn> tgeeky_: Srsly, what the hell kind of insane rounding algorithm is that to use in a programming language stdlib?!?! (You can tell how irate I am from the amount of punctuation)
07:38:41 <kallisti_> merijn: one that cares a lot about bankers
07:39:08 <ciaranm> i've got an input parse function (Blah g) => String -> g, and an algorithm (Blah g) => g -> [Int], where Blah can be implemented with various data structures. what's the best way to explicitly fix a Blah without using scoped type variables?
07:39:13 <codolio> srhb: Although, I think 'head . drop n $ iterate f x' is what you want.
07:39:14 <Peaker> @hoogle Eq a => a -> [(a, b)] -> [(a, b)]
07:39:15 <lambdabot> Data.Graph.Inductive.Graph lpre :: Graph gr => gr a b -> Node -> [(Node, b)]
07:39:15 <lambdabot> Data.Graph.Inductive.Graph lsuc :: Graph gr => gr a b -> Node -> [(Node, b)]
07:39:15 <lambdabot> Data.Graph.Inductive.Monad delNodeM :: GraphM m gr => Node -> m (gr a b) -> m (gr a b)
07:39:21 <codolio> Unless you want it to blow up on 0.
07:39:48 <srhb> codolio: Is that better than last?
07:39:53 <srhb> @src last
07:39:54 <lambdabot> last [x]    = x
07:39:54 <lambdabot> last (_:xs) = last xs
07:39:54 <lambdabot> last []     = undefined
07:40:16 <codolio> The one with last is also less efficient.
07:40:22 <srhb> I see.
07:40:28 <arnsholt> merijn: What's the problem with using banker's rounding, OOC?
07:40:29 <srhb> Well, I don't, but I take your word for it. :-)
07:41:36 <codolio> srhb: last . take n sort of rebuilds the list and then walks down it again. Although due to laziness, that's not really what happens, but the same sort of work is done.
07:42:06 <srhb> Due to laziness I thought they were exactly the same.
07:42:12 <srhb> But ok :)
07:42:19 <merijn> arnsholt: Unexpected behaviour, I don't know a single person that expects banker's rounding when calling round
07:42:46 <merijn> arnsholt: And it thus results in invariants not holding for my code, so I end up having to write my own round function...
07:43:11 <kallisti_> srhb: assuming that you're fully evaluating the structure, laziness only really rearranges /when/ the operations occur relative to other operations, not the amount.
07:43:17 <fmap> merijn: isn't banker's algorithm the default in IEEE754
07:43:18 <fmap> ?
07:44:48 <arnsholt> man round on OS X rounds away from 0 according to the docs
07:44:54 <fmap> > round 4.5
07:44:54 <lambdabot>   4
07:44:55 <fmap> > printf "%.0f" 4.5 :: String
07:44:56 <lambdabot>   "5"
07:45:02 <merijn> fmap: Google suggest IEEE754 mentions four different rounding methods
07:45:18 <arnsholt> Er, modulo my sentence beginning and starting with different thoughts
07:45:23 <ziman> wikipedia says it's the default
07:46:02 <merijn> ziman: I revise my statement to murdering the responsible IEEE754 engineers then
07:46:40 <kallisti_> merijn: yeah those useful statistical properties suck.
07:47:08 <merijn> arnsholt: It rounds to nearest integral with .5 rounded away from zero (i.e. what I expect)
07:48:01 <kallisti_> merijn: that's because capitalist pigs have brainwashed you
07:48:08 <kallisti_> they want you to pay 50 extra cents on every transaction
07:48:11 <merijn> kallisti_: I'm not saying there shouldn't be a bankers rounding, I'm just saying it shouldn't be the de facto default round
07:48:22 <kallisti_> and owe 50 extra cents when borrowing money.
07:48:30 <merijn> Because any human I know expects .5 to round away from 0
07:49:49 <codolio> Why do they expect that?
07:50:06 <kallisti_> merijn: is that something that a computer programming language should be concerned about?
07:50:35 <merijn> codolio: Because that's how its taught in math and science classes?
07:50:40 <kallisti_> or should it be concerned about whether rounding errors introduce a positive or negative bias?
07:50:40 <merijn> kallisti_: Yes, POLA
07:50:52 <codolio> No, I don't think so.
07:51:00 <merijn> We're not talking about language implementation, we're talking about library functions
07:51:26 <byorgey> Can't we all just get along?  Where by "get along" I mean "use only integers"
07:51:34 <merijn> codolio: Here it certainly is and I am (well, was?) fairly confident the same applied to the US
07:52:38 <untitled> take 10 $ iterate (flip yourFunction obj2list) obj1initiallist     <- this returns a list of lists, while my function just returns list
07:52:49 <srhb> untitled: Correct. You want the last list of lists.
07:53:10 <untitled> I try tail, it's still [[Obj1]]
07:53:17 <srhb> untitled: you want last
07:53:20 <srhb> untitled: Not tail
07:53:25 <untitled> oh, sure, thanks
07:54:45 <srhb> untitled: Or, as it was pointed out, drop 9 $ head..
07:55:06 <srhb> Er, the other way around of course.
07:55:53 <untitled> mm
07:55:54 * kallisti_ isn't sure that libraries designed for use by software engineers and mathematicians should choose the naive rounding method taught in school over the one that reduces rounding bases and preserves statistical distribution.
07:56:02 <kallisti_> *biases
07:57:31 <codolio> Obviously truncate (r + 0.5) is correct, because that's the most obvious C implementation.
07:57:45 <codolio> Taught in computer science classes all over.
07:58:40 <SplinterOfChaos> How can i parse a string, "(3,4)" into a tupple?
07:58:52 <barrucadu> :t read
07:58:53 <lambdabot> forall a. (Read a) => String -> a
07:58:55 <kallisti_> if you don't mind runtime errors:  read "(3,4)"
07:59:20 <kallisti_> otherwise you should use reads
07:59:58 <codolio> > reads "(3,4)" :: [((Int,Int),String)]
07:59:59 <lambdabot>   [((3,4),"")]
08:00:20 <SplinterOfChaos> Ah.
08:01:23 <kallisti_> merijn: http://hackage.haskell.org/packages/archive/rounding/0.0.1/doc/html/Numeric-Rounding.html
08:02:04 <srhb> > reads "(3,4" [((Int,Int),String)] -- note how pattern matching will save your ass in case it does not parse
08:02:05 <lambdabot>   Not in scope: data constructor `Int'Not in scope: data constructor `Int'Not...
08:02:11 <srhb> Wat.
08:02:28 * srhb needs her ass saved
08:02:39 <kallisti_> needs moar ::
08:02:49 <untitled> srhb: hm.. it still doesn't return 10 times modified list, this 'one-liner' modifies the list only one, because I use 'let' to assign the result to new list: let newObj1List = take 10 $ iterate (flip yourFunction obj2list) obj1initiallist
08:02:51 <srhb> > reads "(3,4" :: [((Int,Int),String)] -- note how I fail
08:02:52 <lambdabot>   []
08:02:55 <srhb> Hurrah!
08:03:07 <untitled> once*
08:03:29 <kallisti_> untitled: it modifies the list ten times before returning it
08:03:31 <srhb> untitled: I did not understand one word of that.
08:03:45 <kallisti_> > take 10 $ iterate (2:) []
08:03:46 <lambdabot>   [[],[2],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[...
08:03:54 <kallisti_> I've "modified" this empty list 10 times, by "pushing" a 2 onto it.
08:04:16 <untitled> yes, but I don't modify the list, I modify records inside it
08:04:25 <srhb> untitled: What you're saying is nonsense.
08:04:26 <untitled> and I need to return it every time, I guess
08:04:35 <kallisti_> okay
08:04:36 <srhb> untitled: You need to really understand how lists work. :) They are not arrays.
08:04:56 <kallisti_> > take 10 $ iterate (map (+1)) [1,1,1]
08:04:57 <lambdabot>   [[1,1,1],[2,2,2],[3,3,3],[4,4,4],[5,5,5],[6,6,6],[7,7,7],[8,8,8],[9,9,9],[1...
08:05:04 <kallisti_> untitled: now I'm modifying the records 10 times
08:05:18 <untitled> strange, my code doesn't work like that
08:05:26 <kallisti_> because it uses different functions
08:05:31 <srhb> untitled: Perhaps your function is the identity function for your obj1list for some value?
08:06:18 <kallisti_> untitled: iterate takes a function and applies it to a value infinitely, accumulating a list of each step.
08:06:35 <kallisti_> if your function takes a list and modifies every record in it
08:06:39 <merijn> untitled: You cannot modify the items in a list, you can only generate a new list that has values based on those in the old list
08:06:49 <kallisti_> then passing it to iterate and then taking the first 10 elements will modify the records in the list 10 times.
08:07:17 <merijn> kallisti_: Your usage of modify in that sentence is confusing
08:07:33 <merijn> It implies in-place update
08:07:36 * kallisti_ doesn't see any reason why "modify" should connotate mutability.
08:07:50 <srhb> Because, like.. modify. :P
08:08:09 <kallisti_> :t update
08:08:10 <lambdabot> Not in scope: `update'
08:08:15 <kallisti_> :t M.update
08:08:16 <lambdabot> forall a k. (Ord k) => (a -> Maybe a) -> k -> M.Map k a -> M.Map k a
08:08:41 <kallisti_> :t M.insert
08:08:42 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
08:09:09 <kallisti_> :t modify
08:09:10 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
08:09:13 <kallisti_> @hoogle modL
08:09:13 <lambdabot> No results found
08:09:17 <kallisti_> aw
08:09:25 <srhb> "You can never modify or update in Haskell, so we name the functions thusly because it is understood that you can't.."
08:09:44 <srhb> I mean, in the context of an explanation. You could argue that all of those functions should be copyAnd...
08:10:00 <kallisti_> srhb: yes. it's understood that Haskell uses immutable data structures.
08:10:14 <kallisti_> untitled: by the way, Haskell uses immutable data structures.
08:10:19 <srhb> kallisti_: But in this case it is not understood (by untitled) therefore modify is a poor choice of words. :-)
08:10:38 <srhb> But nevermind.
08:10:59 <merijn> kallisti_: The explanation in the past hour exhibits untitled clearly hasn't fully understood immutability/its implications, hence confusing in this discussion
08:10:59 <Nisani> is it possible to use applicatives to make elements of a list? I basically want to turn [1,2,3] and [4,5,6] and potentially an infinite amount of arrays and combine the elements to make something like [[1,4],[1,5]...[2,4],[2,5]], etfc
08:11:30 <kallisti_> you can make lists of tuples
08:11:39 <kallisti_> > zip [1,2,3] [4,5,6]
08:11:40 <lambdabot>   [(1,4),(2,5),(3,6)]
08:11:43 <Nisani> no
08:11:51 <Nisani> becuse i it might be more than 2 lists
08:11:52 <WraithM> applicatives
08:11:59 <Nisani> and because i need it to get all possibilities
08:12:12 <kallisti_> Nisani: you can't decie this at runtime
08:12:14 <kallisti_> *decide
08:12:21 <kallisti_> using zip, anyway.
08:12:27 <Nisani> i don't want to use zip or tuples
08:12:30 <kallisti_> or even ZipList, I think.
08:12:37 <Nisani> i shouldn't be using tuples for this
08:13:25 <kallisti_> > transpose [[1,2,3],[4,5,6]]
08:13:26 <lambdabot>   [[1,4],[2,5],[3,6]]
08:13:37 <kallisti_> so like that?
08:13:45 <Nisani> well i also need combinations like [1,5]
08:14:01 <Nisani> but not combinations inside each list, so I don't want [1,3] anywhere
08:14:06 <kallisti_> > sequence [[1,2,3],[4,5,6]]
08:14:07 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
08:14:21 <Nisani> I think that's exactly what i'm looking for
08:14:25 <Nisani> is that in Data.List ?
08:14:30 <kallisti_> Control.Monad
08:14:33 <Nisani> oh
08:14:35 <Nisani> thank you
08:14:36 <merijn> :t sequence
08:14:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:15:13 <kallisti_> no problem. :)  sequence is awesome.
08:15:36 <kallisti_> > (`replicateM` "abc") =<< [1..]
08:15:37 <lambdabot>   ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac"...
08:15:55 <srhb> > [ x | x <- [[1,2,3],[4,5,6]] ] -- is this the same? hmm
08:15:56 <lambdabot>   [[1,2,3],[4,5,6]]
08:15:58 <srhb> nope..
08:16:57 <kallisti_> > foldr (liftM2 (:)) (return []) [[1,2,3],[4,5,6]]
08:16:58 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
08:17:26 <srhb> Wow, that is brainwracking..
08:18:30 <kallisti_> > liftM2 (:) 'a' "bc"
08:18:31 <lambdabot>   Couldn't match expected type `m a1'
08:18:32 <lambdabot>         against inferred type `GHC.Type...
08:18:35 <kallisti_> er
08:19:01 <kallisti_> > liftM2 (:) "abc" ["123", "456"]
08:19:01 <lambdabot>   ["a123","a456","b123","b456","c123","c456"]
08:19:44 <kallisti_> it helps to think of the list monad as a single value that represents many possibilities
08:20:09 <WraithM> Is it possible to take an infinite list and turn that into a list of lists where you've split the infinite list into lists of a certain length? I didn't explain that well. Here's an example of what I mean: Say that certain length is 3. Then I want to turn [1..] into [[1,2,3],[4,5,6],[7,8,9]...]
08:20:35 <kallisti_> yeah you can use splitAt
08:20:41 <kallisti_> there's also Data.List.Split which has a splitEvery function
08:20:45 <kallisti_> :t splitEvery
08:20:46 <lambdabot> Not in scope: `splitEvery'
08:20:46 <untitled> aww, how much nicer it would be if I just could do: for[1..10] let newList2 = foo list1 list2
08:21:04 <kallisti_> untitled: yes. you already know how to do that; it wouldn't require any learning.
08:21:07 <WraithM> Thanks!
08:21:21 <srhb> untitled: You can, use vectors or something.
08:22:05 <fmap> > map (take 3) $ iterate (drop 3) [1..]
08:22:06 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
08:23:06 <younder> I know Haskell function have only a fixed number of parameters. Howvere I would (for windows procedures) like to simulate variable parameters and default values and key value pairs. Any references?
08:23:28 <kallisti_> younder: there are several different approaches depending on the situation.
08:23:40 <kallisti_> for key-value pairs with heterogeneous types you can use records.
08:23:59 <kallisti_> this is a pretty common idiom for libraries, which will have a "configuration" record that you pass to a function, usually with some default record.
08:24:26 <WraithM> fmap: Thank you :) That's awesome
08:24:58 <kallisti_> younder: for homogeneous types of course you can just use lists for varargs and maps for key-value pairs
08:25:45 <younder> kallisti_, yes, you are right, that is probably what I want.
08:25:47 <kallisti_> and then there's also typeclass magic, which is used to implement the printf function in Text.Printf. Might be worth a look.
08:25:58 <kallisti_> but that's the least safe way to do it.
08:26:28 <younder> I'll look into it
08:26:58 <JakobekS> Hello. Links to Arch Linux from here http://hackage.haskell.org/platform//linux.html goes nowhere. Do any of you know when there will be package for Haskell Platform?
08:28:29 <kallisti_> JakobekS: based on bits of conversation I heard earlier, I believe they actually dropped the Haskell Platform. I'm not certain of that in any way...
08:28:34 <applicative> JakobekS: there was discussion just a sec
08:28:48 * kallisti_ is basically a goldfish.
08:29:10 <applicative> JakobekS: http://www.reddit.com/r/haskell/comments/uipvz/haskell_platform_2012200_released/c4vqlb7
08:30:24 <JakobekS> Oh, ok, thanks for links.
08:32:19 <applicative> I'm not sure it's that great an idea; it's true that the Haskell Platform is most of all essential on the demotic oses OSX & Windows, but it's also sort of lingua franca for new usersz
08:33:42 <WraithM> Another question: Say I have an infinite list that I've applied some function to. I want to apply takeWhile to that. Haskell has been hanging on me when I try to do it. Example: takeWhile (> 0) $ f inflist, where inflist is my infinite list (in my particular case I'm interested in, a list of random numbers), and f is the function I've applied to that list.
08:34:26 <Nimatek> WraithM: It sounds like you're applying the function to the whole infinite list.
08:34:29 <applicative> yeah takeWhile is not too good an idea there
08:34:41 <WraithM> I am
08:34:51 <kallisti_> > takeWhile (>0) [1..]
08:34:52 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:34:52 <WraithM> Yeah, it's a fold. Maybe I should have specified that
08:34:57 <Nimatek> So naturally the function can not be applied until the infinite list is computed, which doesn't work.
08:35:04 <WraithM> Right
08:35:17 <WraithM> Is there a way to make that sort of idea work?
08:35:27 <applicative> left fold?
08:35:29 <WraithM> Yes
08:35:38 * applicative isn't quite seeing it yet
08:35:46 <WraithM> Let me explain what I'm doing
08:36:06 <WraithM> I'm making a simulation of a stochastic differential equation
08:36:19 <srhb> applicative: takeWhile is not a problem as long as you don't force evaluation of every element beforehand
08:36:39 <WraithM> Is there a way to make it not force evaluation?
08:37:05 <applicative> no, srhb, i was taking that back,  I responded with the spinal column,  thinking of a different sort of case
08:37:13 <srhb> applicative: Sorry. :-)
08:37:30 <srhb> WraithM: By not using the values "to the right" beforehand.
08:37:55 <WraithM> Ah :/
08:37:58 <WraithM> Hm
08:38:43 <Nimatek> Are you sure your problem cannot be done in the form of "takeWhile pred $ map f inflist" ?
08:39:27 <WraithM> No, I don't think so.
08:40:03 <applicative> WraithM: what do the lists of lists of numbers represent
08:40:36 <WraithM> From my first question?
08:40:52 <WraithM> That's sorta unrelated to this question.
08:41:08 <applicative> oh, i was thinking they came from the same.  i meant to be thinking of the second
08:41:19 <WraithM> :) all good
08:41:24 <applicative> the stochastic differential eq one
08:41:37 <applicative> how do lists of Integer fit in
08:41:38 <Nimatek> If the list is your stochastic sample, you might have to limit it. An infinite sample where you have to actually compute every value is.. problematic.
08:41:55 <WraithM> Yes :/
08:42:15 <WraithM> Yeah, that's the thing, I'm trying not to limit it
08:42:54 <WraithM> I'm doing a brownian excursion
08:43:32 <WraithM> http://en.wikipedia.org/wiki/Brownian_excursion
08:43:39 <WraithM> Basically, a brownian bridge that's positive
08:44:16 <WraithM> But I don't want to limit the length
08:44:53 <jfischoff> @hpaste
08:44:54 <lambdabot> Haskell pastebin: http://hpaste.org/
08:45:15 <hpaste> “Jonathan Fischoff” pasted “readline issue” at http://hpaste.org/69497
08:45:40 <Nimatek> I don't really know anything about it, but a glance at that wiki link shows that the formulas themselves are dealing in approximations..
08:45:46 <jfischoff> ^ having trouble using readline on OSX Lion any ideas?
08:46:11 <WraithM> Here, I'll paste some code.
08:47:46 <hpaste> WraithM pasted “sqrt multiplicative noise” at http://hpaste.org/69498
08:48:45 <geekosaur> jfischoff, OS X has a libreadline that isn't actually resline (it's BSD editline); you need to install a real readline library from somewhere, and make sure that the Haskell readline binding can find it, without replacing Apple's version and breaking all their stuff
08:49:07 <geekosaur> er.  "isn't actually readline"
08:49:33 <WraithM> blah, that code, I made a mistake posting it. eulermaruyama should be named itosim
08:50:41 <jfischoff> geekosaur: I tried to do that. I found a bug in GHC track that might be at the heart of the problem. Basically the readline cabal package ignores the extra libs flag or something similar. I suppose it could be a versioning issue.
08:51:40 <srhb> WraithM: So you're calling randomwalk with infrandlist as the second argument? Then you must eliminate the 'last' from foldlist and make it a right fold.
08:52:01 <srhb> No, wait, that wouldn't cut it
08:54:00 <WraithM> Yeah
08:54:25 <squidz> what are the chances of haskell becoming a regular player in enterprise languages?
08:55:01 <shapr> It already is in many places.
08:55:18 <shapr> Intel and Xilinx use it for hardware design, that's srsly enterprisey.
08:56:13 <applicative> jfischoff: do you have homebrew readline?
08:56:25 <jfischoff> applicative: yeah 6.2.2
08:56:30 <WraithM> I'm trying to do: takeWhile (> 0) $ randomwalk init infrandlist
08:56:30 <WraithM> init is the initial value of the simulation
08:56:31 <WraithM> Because there's a sqrt in that itosim function (called eulermaruyama in the hpaste). So, this simulation must be positive. I want it to end when it comes back to zero, basically.
08:57:00 <mcstar> People say that theres a 50/50 chance of Haskell becoming an enterprise language, though there's only a 10 percent chance of that.
08:57:32 <jfischoff> squidz: I use it as my primary language at work, but I don't it will be more popular then whatever language Microsoft, Apple, Google, etc want you to use for the foreseeable future.
08:57:35 <applicative> jfischoff: i can't remember but doesn't homebrew sort of hide it, giving you instructions about how to link?
08:59:08 <jfischoff> applicative: that would make sense, so it doesn't conflict
08:59:57 <hpaste> applicative annotated “readline issue” with “readline issue (annotation)” at http://hpaste.org/69497#a69499
09:00:13 <applicative> i have the statement ^^^
09:01:09 <Nimatek> WraithM: you pass infrandlist as init?
09:01:11 <jfischoff> applicative: thanks. I'll try that.
09:01:17 <applicative> i guess that is covered by giving cabal the --extra-lib/include-dirs though
09:01:29 <applicative> but youd need the other location
09:01:51 <jfischoff> applicative: the other location?
09:02:07 <applicative> the one where homebrew puts it
09:02:50 <applicative> wierd cant type the path /usr/local/Cellar/readline/6.2.2/lib
09:02:58 <jfischoff> right
09:03:41 <applicative> oh not wierd, irc thought I was using the familiar /usr/local/Cellar/readline/6.2.2/lib irc command
09:03:59 <jfischoff> hehe
09:05:19 <Nimatek> WraithM: If you're trying to generate a list from an initial value, you might want to look at unfoldr
09:05:44 <WraithM> Oh?
09:05:48 <WraithM> Okay
09:05:48 <Nimatek> Where you pass a function a -> Maybe a. Make it so it returns Nothing when the result is 0.
09:06:00 <WraithM> Oh, yeah, good idea
09:06:25 <WraithM> I'm new to Haskell. :)
09:06:46 <jfischoff> applicative: do have readline working?
09:06:48 <Nimatek> Don't worry, I'm not particularly experienced either :)
09:06:56 <jfischoff> s /do / do you
09:07:07 <Nimatek> Besides, some people would say everyone is new to haskell, except for Oleg.
09:07:22 <jfischoff> @quote Oleg
09:07:22 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
09:07:32 <jfischoff> @quote Oleg
09:07:32 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
09:09:24 <applicative> jfischoff: i just tried with the --extra-lib-dirs business, the verbose cabal installation says readline not found, so this package cannot be built
09:09:47 <squidz> If I work through "Learn You a haskell" will it be enough for my Programming and Datamodelling class. Normally the class uses ML to teach. I think working through the haskell book will be much more enjoyable. What do yall think?
09:10:01 <jfischoff> applicative: try this cabal install readline --configure-option=--with-readline-libraries="/usr/local/Cellar/readline/6.2.2/lib" --configure-option=--with-readline-includes="/usr/local/Cellar/readline/6.2.2/include"
09:10:33 <WraithM> Nimatek: Yeah, unfoldr is exactly what I'm looking for.
09:10:37 <WraithM> Nimatek: Thanks!
09:10:42 <jfischoff> applicative: I can build it. Its just failing in ghci, and maybe when compiled (haven't tried yet)
09:10:46 <Nimatek> WraithM: Awesome, you're welcome :)
09:11:19 <applicative> its compiling, at least
09:12:27 <hpaste> “Ertugrul Söylemez” pasted “Fast, elegant FizzBuzz” at http://hpaste.org/69501
09:12:29 <mcstar> squidz: did you see my anwer to your first question?
09:12:38 <squidz> mcstar: no
09:12:46 <mcstar> squidz: People say that theres a 50/50 chance of Haskell becoming an enterprise language, though there's only a 10 percent chance of that.
09:13:04 <squidz> mcstar: haha, funny
09:13:22 <Nimatek> WraithM: And yeah it's a -> Maybe (b,a), not just a -> Maybe a, sorry.
09:13:38 <Nimatek> But the essential concept is the same.
09:13:53 <applicative> jfischoff: I can import it in ghci, I'm trying to think what to use...
09:14:17 <jfischoff> probably LambdaShell
09:15:21 <applicative> jfischoff: there it is, the same error we began with unknown symbol `_rl_message'
09:15:49 <jfischoff> applicative: I saw a blog post where someone got it to work with 6.0
09:15:55 <jfischoff> going to try that
09:16:37 <WraithM> Nimatek: Yep :) I just hoogled it. It's still exactly what I want.
09:16:39 <applicative> well good luck... readline and editline and even haskeline are all a bit difficult
09:17:14 <jfischoff> applicative: so i've heard … and learned. Thanks for verifying.
09:18:49 <applicative> installing haskeline is a little trouble, its like readline, it needs the brew libiconv kept separate from mac's
09:19:20 <monochrom> > 50/50
09:19:21 <lambdabot>   1.0
09:19:41 <Clint> oh, the trials and tribulations of the demotic OSes
09:19:55 <jfischoff> applicative if this fails I might try editline or haskelline
09:20:52 <applicative> jfischoff: I think ghci uses haskeline or some version of it, cant be bad...
09:21:15 <jfischoff> applicative: yeah I didn't realize good to know
09:21:58 <applicative> jfischoff: yeah, here i see it in the ghc-head directory
09:28:20 <jfischoff> applicative: no dice. Going to check if it is ghci only.
09:29:57 <applicative> jfischoff: I'm not following
09:30:21 <jfischoff> applicative: using readline 6.0 didn't fix the issue
09:30:51 <applicative> jfischoff: I see, whether a compiled program would fail similarly
09:31:01 <jfischoff> yeah
09:34:29 <applicative> jfischoff: well, one of the things with the hs- readline depency, the scripture memorization tool memscript, seems to work
09:35:55 <applicative> so maybe calling readline inside ghci just gets all the links mixed up
09:40:21 <byorgey> tgeeky_: an idiom "with K-combinators" is a technical term defined on page 8.  It is not the same thing as the remark on page 3.
09:41:03 <byorgey> tgeeky_: however I can't give a very good answer until I read the paper more carefully.  But I might not have time to do that for a few weeks.
09:41:06 <byorgey> but I'd like to.
09:44:43 <hpaste> sap pasted “ByteStrings in TUNTAP package” at http://hpaste.org/69502
09:45:15 <sap> this use of bytestrings in the tuntap package looks strange to me
09:46:22 <sap> the author probably meant to promote the pointer if the offset in the bytestring is >0?
09:46:38 <sap> (last 2 lines of snippet)
09:47:15 <squidz> If I work through "Learn You a haskell" will it be enough for my Programming and Datamodelling class. Normally the class uses ML to teach. I think working through the haskell book will be much more enjoyable. What do yall think?
09:48:01 <barrucadu> Without knowing the syllabus of your class, that question is impossible to answer.
09:48:06 <ion> @tell mzero Your Tech Talk about Haskell was very nice.
09:48:07 <lambdabot> Consider it noted.
09:49:35 <squidz> barrucadu: description: The module provides an introduction to basic principles of programming and data modeling with a functional programming language. Covers issues such as data types, functions and recursion, evaluation and termination of programs. An emphasis is placed on conceptual clarity and precise mathematical foundations of formal methods of value. The programming examples are formulated in the programming language Standard ML (SML short).
09:50:18 <luca> @tell lambdabot he's sexy
09:50:18 <lambdabot> Nice try ;)
09:50:32 <byorgey> squidz: sure, sounds like LYAH is appropriate, although you may want to also supplement it with something like Hutton's book "Programming in Haskell"
09:50:48 <byorgey> which seems like it would correspond more precisely to your class
09:50:48 <otters> > mappend (++) intersect [1..5] [2..6]
09:50:50 <lambdabot>   [1,2,3,4,5,2,3,4,5,6,2,3,4,5]
09:51:19 <squidz> byorgey: thanks, Ill work through LYAH and then supplement it afterwards with whatever I need. I kind of suspected that should be the plan
09:56:58 <tgeeky_> byorgey: thanks! I suspect I know what I was missing before, but I'm not totally sure. It's obvious the answer to my question is should be "because Pointed isn't an idiom, silly"
09:57:15 <tgeeky_> byorgey: but there is something else subtle in this paper. I should go through it and implement all the things
09:57:30 <byorgey> and now I will implement ALL THE THINGS
09:57:33 <byorgey> =)
09:58:01 <tgeeky_> hehe
09:58:50 <tgeeky_> plus, the same section (8) describes why set doesn't count, but I *hate* proofs by counterxample.
09:59:35 <tgeeky_> the paper I am currently working on reproducing (generalising and dualising the third list homomorphism) even uses a proof by example. Shame! :o
10:00:37 <tgeeky_> also, I am quite certain that the third-list-homomoprhism-theorem (TLH Theorem) should be renamed to HLH (half list homorphism) because the "third" part is because it was the third thing written down somewhere, but HLH makes more sense because you're actually splitting the list into two halves.
10:02:07 <tgeeky_> that is, it requires nonempty (so you can split it into two) lists. You could write a real TLH that requires non-empty (non-empty) lists, and split it into three parts
10:03:00 <tgeeky_> byorgey: also, https://github.com/technogeeky/icfp12-paper-links/blob/master/README.md#submitted-but-not-accepted <-- Hinze submitted a functional pearl about functors which I think didn't get accepted.
10:23:17 <shapr> Has anyone gotten GHC on their Raspberry Pi?
10:25:23 <Nafai> shapr: do they have an ARM processor in them, or what?
10:25:41 <jfischoff> shapr: I haven't but are you running out of ram? There was a thread on haskell-cafe (I'm pretty sure) where someone was compiling on low resource arm of some sort and that appeared to be the problem.
10:26:41 <shapr> jfischoff: Do you have a link to that thread? There's a way to change the divide between video memory and 'main' memory.
10:28:43 <shapr> jfischoff: Can be increased to 224MB of ram and 32MB to the GPU - http://elinux.org/RPi_Advanced_Setup#Additional_files_supplied_by_the_foundation
10:28:53 <jfischoff> shapr: I don't, I'm looking
10:29:29 <shapr> Nafai: Yes, ARMv6 I think
10:30:19 <shapr> Nafai: ARM11 using the ARMv6 arch - http://en.wikipedia.org/wiki/Raspberry_Pi#Specifications
10:30:36 <jfischoff> shapr: I have been cross-compiling with ghc for arm7 iOS. Its unlikely I can help but what is the problem?
10:30:55 <shapr> I wish it had used one of the Cortex chips in ARMv7, but I guess that was too expensive.
10:31:21 <shapr> jfischoff: I haven't tried to build ghc yet, I was hoping someone already had a binary for either the debian or redhat images for the RPi
10:31:30 <jfischoff> ah
10:32:21 <younder> building ghc goes like a dream
10:32:28 <younder> no wories
10:32:49 <strager> Build GHC on a Raspberry Pi.
10:32:54 <strager> Swap to disk.
10:33:02 <armlesshobo> lol
10:33:14 <shapr> strager: I do have a 32gb sdhc card, I could easily repartition to increase the swap file.
10:34:08 <younder> shapr, Re-partitioning the swap area is far from easy.
10:34:20 <taylorgb> Once ran ghc on a laptop with no swap and only 1GB of ram, couldn't compile any haskell libraries with say more than 37 files in one interation.
10:34:28 <taylorgb> er iteration
10:35:15 * hackagebot ltk 0.12.1.0 - Leksah tool kit  http://hackage.haskell.org/package/ltk-0.12.1.0 (JuergenNicklischFranken)
10:35:17 * hackagebot leksah-server 0.12.1.0 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.12.1.0 (JuergenNicklischFranken)
10:35:19 * hackagebot sort-by-pinyin 2012.6.5 - Sort simplified Chinese by PinYin  http://hackage.haskell.org/package/sort-by-pinyin-2012.6.5 (JinjingWang)
10:35:54 <strager> younder: Hmm?  I've never had problems making more swap space
10:36:00 <strager> at least on a non-live system
10:36:58 <younder> You know yesterday I fond myself clearing the 64 first sectorrs of the bootsecto, then reinstalling grub and the reinstalling the partion table without rebooting.. Totally nerve-racking
10:37:41 <younder> A Net.. Had installide itself tere urgh
10:39:19 <younder> Never thought I'd use dd in anger again
10:40:16 * hackagebot leksah 0.12.1.0 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.12.1.0 (JuergenNicklischFranken)
10:40:57 <jkff> Hi folks. Has there been any work on multipass stream processing? E.g. I wish to write nice code for things like "divide the stream by its average" in a transparent way.
10:41:47 <jfischoff> jkff: maybe this https://github.com/ekmett/multipass/blob/master/examples/Pass.hs
10:42:03 <roconnor_bot> jkff: in haskell you can dived a stream by its average in one pass
10:42:46 <jkff> jfischoff: Holy cow, thanks. Is there anything @ekmett has not done?
10:42:53 <jkff> roconnor_bot: what do you mean?
10:42:56 <younder> How do you force strictness when processing a stream?
10:43:23 <jkff> roconnor_bot: I need something for a case where the stream is extremely large (too large for main memory) but finite.
10:44:02 <roconnor_bot> jkff: oh ... then you don't want to do it the usual way :D
10:44:27 <jkff> roconnor_bot: Yeah, I guess that's when I have to do it the ekmett way :)
10:45:09 <roconnor_bot> there's a right way, and a wrong way, and then there is the ekmett way.
10:45:11 <younder> sequential?
10:45:16 * hackagebot fb 0.9.3 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.9.3 (FelipeLessa)
10:45:41 <jfischoff> @remember roconnor: there's a right way, and a wrong way, and then there is the ekmett way.
10:45:41 <lambdabot> I will never forget.
10:46:27 <younder> This lambda bot of yours is creepy
10:46:56 <jfischoff> younder: where you asking about making infinite stream processing strict?
10:47:05 <younder> anyone have a manual?
10:47:08 <jkff> calc :: (Eval k, Typeable b, Binary b, Monoid b) => t k a b -> Calc k a b
10:47:13 <jkff> Understanding this will take some time.
10:47:16 <younder> jfischoff, yes
10:47:44 <jfischoff> younder: my understanding is you don't want to do that
10:48:05 <younder> Probably not
10:48:32 <younder> I am just probing, trying to learn Haskell
10:48:43 <tertl3> de monoid ?
10:48:44 <jfischoff> younder: I think you would need all the data before your function would return, so it wouldn't
10:49:10 <tertl3> younder learn you a haskell
10:49:27 <armlesshobo> younder: LYAH
10:49:34 <armlesshobo> younder: Real World Haskell, too
10:49:49 <younder> I know how to implement curry, in scheme it works
10:50:22 <jfischoff> in scheme what works?
10:50:45 <armlesshobo> :|
10:50:46 <younder> I have real world Haskell right in front of me..
10:50:51 <armlesshobo> younder: good
10:50:55 <armlesshobo> it's a great book :)
10:51:27 <jfischoff> @where faq
10:51:28 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
10:51:28 <armlesshobo> one thing I'm struggling with is (un)learning different coding styles
10:51:40 <armlesshobo> I guess that gets resolved over time
10:51:48 <armlesshobo> the more I apply it, as it does with any other language
10:52:57 <younder> Functional coding style is a noop, monads take some getting used to.. Well for me
10:55:25 <younder> Ive studied it mathematically and in Haskell for four moths and I still feel like a total idiot
10:55:51 <jfischoff> younder: monads?
10:56:49 <younder> Well the IO monad is simple. Desighing your own I can get. But the other libraries I have yet to master
10:57:39 <c_wraith> Eh. Monads aren't anything special. You're really saying "I don't know every single instance of Monad". But you don't know every single instance of any other type class, either
10:57:53 <younder> Call it a transitional problem
11:00:42 <jfischoff> what c_wraith says and monads importance seems to be overstated to many beginners. If you can write your own, I would not stress about it.
11:02:00 <younder> jfischoff, thanks for the reassurance
11:02:05 <jfischoff> :)
11:03:32 <MiWe> hi! i got into a - for me - very strange problem. Since i upgraded ubuntu to the current version, i can't run my haskell programs anymore, which i wrote in leksah. When leksah starts i also get
11:03:32 <MiWe> HTTP request sent, awaiting response... 404 Not Found
11:03:32 <MiWe> 2012-06-04 19:51:23 ERROR 404: Not Found.
11:03:32 <MiWe> Now loading metadata ...
11:03:32 <MiWe> packageInfo not found for bin-package-db-0.0.0.0
11:03:36 <MiWe> packageInfo not found for ghc-paths-0.1.0.8
11:03:38 <MiWe> ....
11:03:40 <MiWe> i would be very happy for help and any hints, which would guide me to a solution.
11:03:42 <MiWe> greetings,
11:03:44 <MiWe> micha
11:05:42 <MiWe> if i might add: in leksah itself i get "cabal: At least the following dependencies are missing: QuickCheck -any"
11:07:23 <jfischoff> MiWe: try `ghc-pkg dump | grep QuickCheck`
11:10:18 * hackagebot timeplot 1.0.11 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.11 (EugeneKirpichov)
11:13:30 <MiWe> jfischoff, thank you! i typed  `ghc-pkg dump | grep QuickCheck` into the terminal, but got nothing back. ghc-pkg dump gave me a lot of info, but there is nothing with QuickCheck in it.
11:14:36 <strager> parcs`: -split-objs broke the incremental build progress =]  The GHC docs say not to use it unless you know what you're doing, and I clearly don't.
11:14:56 <parcs`> strager: hah
11:15:21 <jfischoff> MiWe: which means you don't have quickcheck installed, or at least your package database doesn't think so. So somehow, your system got modified … I guess. It might be easiest to just reinstall the packages
11:16:22 <strager> Got a bunch of 'undefined symbol' linker errors
11:20:18 <younder> strager, you forgot a lib
11:21:23 <MiWe> jfischoff, thank you. i'll go through synaptics and re-install all haskell packages.
11:21:39 <jfischoff> MiWe: np
11:23:55 <gdoteof> how do i get 123.45 from let foo :: Double = 123.483948
11:24:21 <gdoteof> er.  123.5, rather from it
11:24:42 <gdoteof> ie; rounding to a certian number of digits
11:24:55 <jfischoff> > 123.483948
11:24:56 <lambdabot>   123.483948
11:25:21 <fmap> > read $ printf "%.1f" 123.483948 :: Double
11:25:23 <lambdabot>   123.5
11:25:33 <younder> round is so overrated.. either floor it or ceil it
11:25:44 <aristid> @hoogle round
11:25:44 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
11:25:44 <lambdabot> package rounding
11:25:45 <lambdabot> package roundtrip
11:26:02 <aristid> > round (123.5*10) / 10
11:26:03 <lambdabot>   Ambiguous type variable `b' in the constraints:
11:26:03 <lambdabot>    `GHC.Real.Integral b'
11:26:03 <lambdabot>   ...
11:26:08 <aristid> > round (123.5*10) / 10 :: Double
11:26:09 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
11:26:09 <lambdabot>    arising from a use ...
11:26:17 <vraid> > 0.01 * round (100 * 123.483948)
11:26:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:26:18 <lambdabot>    `GHC.Real.Fractional a'
11:26:18 <lambdabot> ...
11:26:22 <aristid> > round (123.5*10) `div` 10
11:26:23 <lambdabot>   123
11:26:27 <aristid> gngn
11:33:02 <grw7> hey :) ive just started haskell and im just wondering about something why does [1,2,3]:[] or [1,2,3]:[[1]] work but not [1,2,3]:[1]
11:33:49 <tromp_> needs types a:[a]
11:33:59 <pqmodn> :t (:)
11:34:00 <lambdabot> forall a. a -> [a] -> [a]
11:34:16 <JamesRustle> @src []
11:34:16 <lambdabot> data [] a = [] | a : [a]
11:34:34 <ben> [] can be any list type, [[1]] is the right list type and [1] is the wrong list type
11:34:41 <pqmodn> "give me an 'a', a list of 'a's, and i'll return a list of 'a's"
11:34:51 <grw7> ahh so thats just the way it is
11:34:54 <tromp_> u'r confusing : with ++
11:34:56 <JamesRustle> "a list of 'a's is either [] or a (:) containing an 'a' and a list of 'a's"
11:35:04 <TheLemonMan> hello there, i'm having a problem with this code http://hpaste.org/69506 the problem is at line 23, the map definition is (a -> b) -> Map k a -> Map k b but ghc keeps bitching about the return type
11:35:10 <JamesRustle> > 1 : (2 : (3 : []))
11:35:11 <lambdabot>   [1,2,3]
11:35:54 <JamesRustle> TheLemonMan: less "keeps bitching", more actual error messages
11:36:08 <grw7> thanks :p
11:36:20 <grw7> this is going to be a long interesting experience haha
11:36:26 <strager> younder: It compiled fine without -split-objs.
11:36:30 <TheLemonMan> JamesRustle, it expects 'System.Posix.Types.FileOffset' but the return is 'Int'
11:36:44 <TheLemonMan> which should be perfectly fine from the Map definition
11:37:21 <JamesRustle> TheLemonMan: why does the Map definition matter?
11:37:37 <JamesRustle> you're doing div (x * 10) size
11:37:44 <JamesRustle> x is an Int
11:37:49 <JamesRustle> size is a FileOffset
11:38:43 <TheLemonMan> oh, the error message wasn't really clear about where the error was
11:39:06 <JamesRustle> TheLemonMan: what was the actual error message?
11:40:15 <TheLemonMan> http://pastebin.com/mZFuFcBd
11:40:20 <JamesRustle> The paste mZFuFcBd has been copied to http://hpaste.org/69507
11:40:46 <JamesRustle> ok, so it complains about m
11:41:36 <JamesRustle> which makes sense, since map (\x -> div (x * 10) size) by itself is perfectly fine and has the type Map Word8 FileOffset -> Map Word8 FileOffset
11:42:01 <TheLemonMan> a clang-like way of pointing out errors would be definitely appreciated
11:42:25 <JamesRustle> the compiler doesn't know what you meant
11:42:30 <JamesRustle> it only sees that the types don't match
11:42:56 <jfischoff> you probably need fromIntegral
11:42:56 <JamesRustle> in cases where you don't understand what's going on, it can be helpful to add type annotations
11:43:26 <JamesRustle> TheLemonMan: btw, your 'otherwise' in line 32 is wrong
11:43:43 <TheLemonMan> yep, i should have used _
11:45:06 <JamesRustle> anyway, I'm a big fan of adding type signatures until it becomes obvious where the fault is
11:45:46 <TheLemonMan> I did that for function definitions
11:46:51 <JamesRustle> > ["hello", 1]
11:46:52 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
11:46:52 <lambdabot>    arising from the literal ...
11:46:57 <JamesRustle> > ["hello" :: String, 1 :: Int]
11:46:58 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:46:58 <lambdabot>         against inferred ty...
11:47:12 <JamesRustle> > [1 :: Int, "hello" :: String]
11:47:13 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:47:13 <lambdabot>         against inferred type ...
11:50:05 <JamesRustle> TheLemonMan: fromIntegral may not solve the problem because FileOffset is a 64 bit type but Int may not be
11:51:00 <TheLemonMan> 64bit here. Anyway isn't Int handled by GMP ?
11:51:12 <jfischoff> Interger is not Int
11:52:28 <jfischoff> s /Interger / Interger
11:52:33 <c_wraith> Wow.  This Repa 3 paper is fascinating.
11:52:49 <jfischoff> :p
11:52:53 <mekeor> > 2^100 :: Int
11:52:54 <lambdabot>   0
11:52:55 <ion> c_wraith: URL?
11:52:57 <mekeor> > 2^100 :: Integer
11:52:58 <lambdabot>   1267650600228229401496703205376
11:53:02 <c_wraith> http://www.cse.unsw.edu.au/~chak/papers/repa3.pdf
11:53:08 <ion> c_wraith: Thanks
11:53:09 <mekeor> TheLemonMan: ↑
11:53:32 <c_wraith> They moved a ton of stuff tot he type system, making it easier for the compiler and the programmer
11:53:48 <whittle> Is there a way to use lambdabot to leave messages for people in this channel?
11:53:49 <MiWe> jfischoff, thank you! you helped me out! it works now! and i get step by step familiar with haskell/leksah
11:54:04 <jfischoff> MiWe: great!
11:54:18 <parcs`> @tell whittle hi
11:54:18 <lambdabot> Consider it noted.
11:54:51 <whittle> Thanks, parcs`!
11:54:51 <lambdabot> whittle: You have 1 new message. '/msg lambdabot @messages' to read it.
11:54:55 <TheLemonMan> oh i see, i should take a note that Int != Integer
12:00:44 <mekeor> TheLemonMan: unfortunately, most Prelude-functions use Int =(
12:01:08 <tgeeky_> can someone explain in a few sentences why djinn can't / doesn't do lists?
12:02:01 <whittle> @tell hpc I took your advice about the FuzzyDate type I was working on and made it `type FuzzyDate = Range Day`. Fortunately the Ranged-sets package works great for this. Thanks!
12:02:01 <lambdabot> Consider it noted.
12:03:05 <jfischoff> tgeeky_: can you add polymorphic datatypes?
12:03:07 <rwbarton> I guess because djinn produces nonrecursive definitions, also logically the proposition corresponding to [a] is just "true"
12:03:24 <rwbarton> but I don't think the latter stops it from trying to do things with Maybe
12:03:31 <tgeeky_> @djinn-names
12:03:31 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Monad Eq Bool
12:03:31 <rwbarton> @djinn (a -> b) -> Maybe a -> Maybe b
12:03:32 <lambdabot> f a b =
12:03:32 <lambdabot>     case b of
12:03:32 <lambdabot>     Nothing -> Nothing
12:03:32 <lambdabot>     Just c -> Just (a c)
12:03:54 <rwbarton> for me the second reason is sufficient, but i think the actual reason is the first one
12:03:54 <tgeeky_> my real question is about things like:
12:04:11 <tgeeky_> rwbarton: is [[a]] also true?
12:04:15 <rwbarton> sure
12:04:20 <rwbarton> since [a] is a special case of a ...
12:04:35 <tgeeky_> rwbarton: and what about non-empty lists (say, lists of at least length 3)
12:04:46 <rwbarton> if you are given a value of type [a], it might just be [], in which you can do nothing with it
12:04:59 <rwbarton> and if you need to produce a value of type [a], you can always just produce []
12:05:04 <tgeeky_> jfischoff: I think so, as long as they aren't recursive
12:05:14 <rwbarton> NonEmptyList a is logically equivalent to a
12:05:25 <rwbarton> or ListOfLengthAtLeastN a for any N > 0
12:06:17 <whittle> When cabal-install tells me to “See `config.log' for more details.” where do I find config.log?
12:07:12 <jfischoff> tgeeky_: you might this blog post informative. http://www.polyomino.f2s.com/david/haskell/programsfromproofs.html it goes into more detail about the logical system djinn uses
12:07:49 <mekeor> s/might/might find/
12:07:53 <mcstar> slip of mind, how can we omit important words?
12:08:21 <mcstar> i regularly omit verbs that convey the prime meaning of a sentence...
12:08:31 <rwbarton> djinn has some heuristics that cause it not to produce "f a b = Nothing" for(a -> b) -> Maybe a -> Maybe b, but that is also a valid total inhabitant of the type
12:09:19 <roconnor_> @djinn bool
12:09:19 <lambdabot> -- f cannot be realized.
12:09:24 <roconnor_> @djinn Bool
12:09:24 <lambdabot> f = False
12:10:21 <mekeor> whittle: i don't know but you might want to take a look at ~/.cabal/config and ~/.cabal/logs/build.log
12:10:27 <nyingen> what is the 'fixity' of ::, in expressions? Does it indicate the type of the entire expression, or just a particular term?
12:10:57 <JamesRustle> nyingen: it's most of the expression
12:11:09 <JamesRustle> IIRC \ -> is lower than ::
12:11:42 <otters> @djinn (a,b) -> (b,a)
12:11:42 <lambdabot> f (a, b) = (b, a)
12:11:58 <nyingen> is there a way to indicate the types of individual terms in an expression, without factoring them out into separate let bindings?
12:12:31 <mekeor> nyingen: parantheses (like :: This).
12:12:50 <mekeor> nyingen: i hope i understood your question correctly…
12:13:07 <nyingen> ok, so without the parens, it would indicate the type of "most of the expression"
12:13:21 <nyingen> I would like to know exactly what "most" means there, if there's a good summary of the rules somewhere
12:13:39 <rwbarton> http://www.haskell.org/onlinereport/exps.html
12:14:38 <mekeor> rwbarton: so, does :: have a certain fixity or not??
12:14:58 <rwbarton> see the first line, it is the possible expansion of "exp", so it will scope over anywhere you see "exp", like the body of a lambda abstraction, the parts of an if expression, etc.
12:15:06 <nyingen> I see
12:15:30 <nyingen> so \x -> x + 1 :: Int, and (\x -> x + 1) :: Int -> Int for example?
12:16:13 <rwbarton> yes, though the latter might require parentheses in a larger context
12:16:18 <rwbarton> iterate ((\x -> x + 1) :: Int -> Int)
12:16:24 <nyingen> got it
12:16:36 <rwbarton> that is aexp -> ( exp ) -- (parenthesized expression)
12:17:55 <mekeor> i have: f [] = []; f (x:xs) = x : f (g e es); -- is this a fold? foldr/foldl?
12:18:35 <byorgey> what are e and es?
12:18:38 <mekeor> sorry, i meant g (x xs)
12:18:42 <mekeor> i have: f [] = []; f (x:xs) = x : f (g x xs); -- is this a fold? foldr/foldl?
12:19:14 <byorgey> it depends on what g is.
12:19:14 <mekeor> i suppose that it's not a foldr… but is it a foldl?
12:19:34 <mcstar> looks like a foldl
12:19:35 <mekeor> byorgey: rly?
12:20:00 <byorgey> yes, rly
12:20:08 <hpaste> mekeor pasted “the code” at http://hpaste.org/69508
12:20:12 <byorgey> what if  g x xs = [1,2,3]
12:20:13 <mekeor> byorgey: ↑
12:20:20 <byorgey> then it is not a fold at all.
12:20:46 <mekeor> hm ok.
12:20:47 <mcstar> i assumed it is a fold at least
12:20:47 <whittle> mekeor: Thanks fot the advice. The build.log just says “install-outcome: ConfigureFailed” and I can’t find anything in the config file about where packages get unpacked to when they’re getting built.
12:20:49 <mekeor> mcstar: :P
12:21:42 <mcstar> ah, ok, you asked if its a fold too
12:21:43 <byorgey> ok, g is something involving map, now we are getting somewhere. =)
12:21:57 <mekeor> does @pl use Data.Function.on actually?
12:22:31 <mekeor> @pl \x y -> x * 5 + y * 5
12:22:32 <lambdabot> (. (5 *)) . (+) . (5 *)
12:22:37 <mekeor> no. -.- bummer.
12:23:03 <rwbarton> > let f [] = []; f (x:xs) = x : f (map (h x) xs) in f [a,b,c]
12:23:04 <lambdabot>   [a,h a b,h (h a b) (h a c)]
12:23:09 <rwbarton> > let f [] = []; f (x:xs) = x : f (map (h x) xs) in f [a,b,c,d]
12:23:10 <lambdabot>   [a,h a b,h (h a b) (h a c),h (h (h a b) (h a c)) (h (h a b) (h a d))]
12:23:34 <tgeeky_> well that's certainly not reducing anything
12:23:37 <tgeeky_> it might be an unfold :o
12:23:46 <byorgey> hmm, it's structured kind of like a right fold, but I don't think it is because it actually requires the first element to process the remainder of the list
12:23:49 <mcstar> rwbarton: what would it take to use unassigedn labels in ghci?
12:24:05 <tgeeky_> mcstar: implicitparamters?
12:24:14 <mcstar> in this symbolic way, lambdabot does
12:24:20 <rwbarton> oh
12:24:25 <rwbarton> import whatever lamdbabot imports
12:24:26 <rwbarton> @type a
12:24:27 <lambdabot> Expr
12:24:29 <mekeor> byorgey: ok.
12:24:30 <byorgey> oh, it's using length too!
12:24:31 <mekeor> thanks
12:24:37 <mekeor> byorgey: yea
12:24:37 <tgeeky_> mcstar: oh, reflection
12:24:47 <byorgey> it's probably a parahistomorphism or something like that =P
12:24:48 <rwbarton> http://hackage.haskell.org/package/simple-reflect
12:24:52 <mekeor> byorgey: oh shit. oh right… oh dear. oops.
12:24:59 <mekeor> byorgey: WTF
12:25:05 <byorgey> (I made that up)
12:25:07 <mcstar> thx
12:25:42 <byorgey> mekeor: I mean, it's not necessarily horrible that it's using length, that's just one more reason it is definitely not a fold
12:26:09 <tgeeky_> that also rules out unfolds, I think
12:26:31 <byorgey> hmm, not necessarily
12:27:02 <rwbarton> you could probably arrange to use a zip [0..] sort of thing to do this
12:27:25 <byorgey> yeah
12:27:32 <tgeeky_> > let f [] = []; f (x:xs) = x : f (map (h x) xs) in f [a,b,c]
12:27:33 <lambdabot>   [a,h a b,h (h a b) (h a c)]
12:27:53 <tgeeky_> > let f [] = []; f (x:xs) = x : f (map (?h x) xs) in f [a,b,c]
12:27:54 <lambdabot>   mueval-core: internal error: PAP object entered!
12:27:54 <lambdabot>      (GHC version 6.12.3 f...
12:29:12 <mcstar> but why not use arrays?
12:30:23 <tgeeky_> h is a -> a -> a
12:31:32 <byorgey> > let f [] = []; f (x:xs) = x : f (map (h (length (x:xs)) x) xs) in f [a,b,c]
12:31:33 <lambdabot>   [a,h 3 a b,h 2 (h 3 a b) (h 3 a c)]
12:31:49 <byorgey> > let f [] = []; f (x:xs) = x : f (map (h (length (x:xs)) x) xs) in f [a,b,c,d]
12:31:51 <lambdabot>   [a,h 4 a b,h 3 (h 4 a b) (h 4 a c),h 2 (h 3 (h 4 a b) (h 4 a c)) (h 3 (h 4 ...
12:32:04 <tgeeky_> weird
12:32:04 <whittle> mekeor: Thanks for your help. The file I was looking for was getting unlinked as part of the installer clean-up process. Increasing the verbosity of cabal-install gave me the info I was looking for.
12:33:01 <tgeeky_> ah. elim is Int -> a -> a -> a
12:33:26 <tgeeky_> it's inferred as that, at least
12:37:48 <tgeeky_> mekeor: did you figure out what you wanted to know?
12:41:06 <spreadsheet> ghci keeps segfaulting on me
12:41:13 <spreadsheet> It seems random
12:41:21 <spreadsheet> After a while it becomes normal
12:45:08 <mcstar> what is a normal segfault?
12:46:15 <akosch> I'm playing around with parsec: what's the best way to match until a matching paren (ignoring the nested parentheses)? probably I have to keep track of the level of nesting somehow...
12:46:40 <tgeeky> how can you ignore nesting but match the intended paren?
12:47:20 <akosch> tgeeky: yeah, I can't ignore it. I was thinking of something built-in for this task :)
12:52:25 <joeyh> A user reported a build failure on OSX when using the 32 bit haskell platform. My package has a C library, and it's built for 64 bit and then fails to link into my haskell program. Anyone know how I can detect whether ghc is targeting 32 or 64 bit?
12:53:51 <geekosaur> pyanfar:10044 Z$ ghc -e 'print System.Info.arch'
12:53:51 <geekosaur> "x86_64"
12:54:13 <Clint> can't you make some kind of magical fat .dylib with both 32- and 64-bit objects?
12:56:41 <joeyh> Maybe.. my OSX build experience is nil
12:56:46 <adnauseam> .join #math
12:56:48 <adnauseam> err srry
12:57:05 <joeyh> System.Info.arch seems like a good enough approach
12:58:50 <joeyh> geekosaur: is that on an OSX box?
12:59:15 <geekosaur> joeyh, lipo can combine 32- and 64-bit dylibs or executables; or the Apple compilers take multiple -arch options and will build all the specified arches into a fat binary
12:59:18 <geekosaur> yes
12:59:28 <geekosaur> 10.6.8 though
13:00:34 <joeyh> hmm, seems like cabal might just do the right thing. Bug reporter was using my Makefile, which is there just because I use it during development
13:01:50 <joeyh> Since I have the library in C-Sources in my cabal file
13:05:52 <aekition> newbie here: how do you write a .hs file
13:06:30 <aekition> is it just in notepad?
13:06:38 <strager> Any text editor.
13:06:41 <mcstar> if all else segfaults, yes
13:06:53 <strager> Notepad, GEdit, Vim, Emacs, Leksah
13:07:03 <strager> If you're used to IDE's, you should try either Leksah or Eclipse FP.
13:07:11 <mekeor> aekition: open notepad. create a new file named "Foo.hs".
13:07:15 <strager> Or learn how to really program and learn Emacs or Vim.
13:07:15 <Azel> Yes, even if people usually use other editors...at least with syntactic coloration
13:07:47 <aekition> i have leksah
13:07:52 <mekeor> aekition: AH!
13:08:03 <aekition> so leksah is just a notepad
13:08:11 <aekition> sorry
13:08:11 <mcstar> ide
13:08:19 <aekition> ide but only with text editor?
13:08:36 <mcstar> the right unification, a haskell source is just a text file
13:09:01 <aekition> what about encoding does it matter? ansi utf8 etc..
13:09:19 <deadrabbit> vim ok for haskell, the indentation if not perfect...
13:09:39 <strager> What's problematic with indentation deadrabbit?
13:09:51 <strager> I've only had problems aligning things, then I decided aligning things is silly anyway.
13:09:57 <aekition> i mean i just started learnin haskell and i wana start well
13:10:05 <mekeor> deadrabbit: are you using vim's haskell-mode? you should, i suppose. Cale doesn't though…
13:10:09 <Philippa> aekition: have you programmed in anything else before?
13:10:17 <Phlogistique> aekition: use UTF-8
13:10:26 <deadrabbit> i do use haskell mode.
13:10:30 <mekeor> OK.
13:10:36 <Philippa> (but really: pick a text editor that has syntax highlighting and have a console available to mess with ghci from, that's the basics covered)
13:10:41 <aekition> philippa not that much just jus matlab ... css html and that
13:10:46 <deadrabbit> strager: yeah, the aligning was what i was talking about
13:11:01 <mcstar> an .m file is just a text file, somwhat uglier than a haskell one
13:11:05 <aekition> i will use notepad ++
13:11:05 <strager> deadrabbit: Fix your style.  Anyone editing your code will have the same issues, most likely.
13:11:28 <deadrabbit> nobody edits my haskell code, its just for me ;)
13:11:41 <Cale> I don't have anything against vim's haskell-mode, I just don't really use many features in my editor
13:11:41 <deadrabbit> but what do you mean 'fix my style'?
13:11:50 <aekition> so encoding doesnt matter at all with haskell?
13:12:12 <Cale> Give me anything which can convert tabs to spaces and can do a little bit of syntax colouring and I'll be fine :)
13:12:36 <Phlogistique> aekition: always use UTF-8 without BOM. Everywhere. (but no, it doesn't really matter)
13:12:51 <mekeor> Cale: ah, yea :D
13:12:53 <aekition> whats bom?
13:13:00 <Phlogistique> aekition: mostly any text editor will do. Notepad is the worst one you will get
13:13:04 <mekeor> Cale: emacs isn't meant for you then ;)
13:13:18 <Phlogistique> aekition: You don't really care. It means byte-order mark.
13:13:23 <adamt> aekition: A way of telling whether it's big- or little-endian coded.
13:13:44 <aekition> ok.... got the point now....need to check my notepad++ settings then
13:13:55 <aekition> hope it doesnt do that by default
13:14:02 <Cale> mekeor: I've used it in the past too, but the difference between emacs and gedit for me was pretty much the load time.
13:14:38 <Cale> also the fact that the fancy indentation mode was annoying and I had to disable it :P
13:14:41 <mcstar> run emacs in daemon mode
13:14:45 <mcstar> everyone does that
13:14:48 <Phlogistique> To me, using Emacs is always a terribly demanding and stressful experience
13:15:35 <aekition> can anyone explain to me when i compile an exe for windows the command prompt has to stay open?
13:16:11 <Phlogistique> aekition: can you restate your question? I do not understand.
13:16:17 <mcstar> same here
13:16:25 <Cale> I use the arrow keys in vim. This apparently annoys some vim users, but I adamantly disagree with the proposition that hjkl are better. :)
13:16:57 <ben> oh god
13:17:00 <aekition> i mean i build an exe ...when i run it the command prompt shows in windows 7 and has to remain open for my app to work
13:17:26 <Cale> I also use visual mode extensively rather than counting lines/characters to number a command :P
13:18:13 <mcstar> Cale: ive couldnt live wo emacs cyclic indentation
13:18:18 <Cale> aekition: I would help you, but I haven't used windows in over 10 years :P
13:18:30 <mcstar> -ve
13:18:35 <aekition> cale u are missing much!
13:18:38 <ski> Cale : do you often leave the editor while in interactive mode (if that's the right term) ?
13:18:45 <Cale> mcstar: I can't stand having to type the start of a line and then hit tab after in order for the indentation to do something sensible
13:19:28 <Cale> ski: er... not sure?
13:19:34 <Phlogistique> aekition: open a command prompt
13:19:36 <mcstar> i thought it was weird, for a short time, after that i got to like it
13:19:45 <Phlogistique> aekition: and run your program from there
13:19:50 <Cale> ski: I have to drop to command mode to save the file, so I guess not
13:19:53 <Phlogistique> don't double-click it
13:20:18 <aekition> i dont want to run the command prompt... the whole point is to distribute my app to others... i want it easy and neat
13:20:41 <adamt> aekition: Then make a non-console application.
13:20:43 <Cale> aekition: right, that shouldn't be in any way necessary
13:20:47 <mcstar> aekition: you want a gui app?
13:20:59 <ski> Cale : i've read somewhere that the "normal" way to operate vi is to think of interactive mode as a short excursion from command mode, so when you're taking a pause, you "should" escape back to command mode
13:21:22 <Cale> ski: Yeah, I tend to stay in insert mode longer than most vim users, I think
13:21:28 <geekosaur> ghc does not currently have the ability to choose a separate main for non-console apps, I think.  no idea if the haskell in industry folks are addressing that
13:21:55 <aekition> yes mcstar
13:22:12 <mcstar> aekition: then dont write a console app as adamt suggested
13:22:33 <aekition> thanks
13:22:48 <Cale> ski: I'll typically stay in insert mode until I'm done writing whatever thing I'm writing, and I'll use arrows etc. to get around during that time.
13:22:51 <mcstar> aekition: the situation is the same as in an other language
13:23:04 <mcstar> any*
13:23:50 <aekition> as i am a newbie could someone explain to me about compilers.... when the file compiles to exe does it translate the haskell to machine code?
13:23:59 <ski> Cale : i typically use arrow keys much in emacs as well. i'm attempting to learn to use `C-p' and `C-n' more, to see whether that would be nicer
13:24:07 <ski> aekition : yes
13:24:32 <aekition> but in windows it is build to use windows runtime?
13:25:10 <adamt> Well it's build to run on Windows :-)
13:25:17 <Cale> ski: I can't see why it would be :P
13:25:29 <aekition> im tryin to understand how the whole thing works....
13:26:07 <mekeor> i get the same error as http://www.haskell.org/pipermail/haskell-cafe/2012-March/100079.html when i try to build leksah. when i try to install cabal-install, i get
13:26:08 <hpaste> mekeor pasted “cabal-fashism” at http://hpaste.org/69510
13:26:21 <mekeor> that ↑. can you help me, pls?
13:26:23 <ski> Cale : well, the reason i've heard is that you wouldn't need to reach as far
13:26:33 <mcstar> aekition: windows has a windows specific gui library, you have to use that to write GUI apps, or use some other GUI toolkit that your language has binding for
13:27:22 <ski> (Cale : e.g. if you have carpal or something, it would be easier on your hands)
13:27:38 <mcstar> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/Win32-2.2.0.1/Graphics-Win32.html
13:27:41 <hpaste> mekeor annotated “cabal-fashism” with “cabal-fashism -- added the error when trying to install leksah” at http://hpaste.org/69510#a69511
13:28:23 <geekosaur> mcstar, Graphics.Win32 is part of the bootlibs.  but using that still doens;t give your prpgram a proper WinMain that prevents the console from being autocreated
13:28:26 <aekition> thanks
13:28:40 <aekition> does haskel have a drag n drop ide?
13:29:16 <Cale> ski: Given that I remove my hands from the keyboard or just stop typing pretty frequently, I can't see it making much of a difference time-wise. One thing which I do think makes a difference with respect to RSI for me is that I've learned to type with my wrists straight (i.e. my hands are at an angle with respect to the keyboard)
13:30:06 <geekosaur> mekeor, did you cabal update?  there should be a version of the unix package that works with the base in 7.4.1, since the HP was updated
13:30:31 <mekeor> geekosaur: i think i did. i'll make it sure.
13:30:51 <mcstar> geekosaur: what, are you telling me, if i write a simple C app, with a usual main, it will open a console when i run it?
13:31:07 <geekosaur> because those things about base-* are really saying "I can't find a version compatible with this GHC"
13:31:25 <mcstar> geekosaur: wait, that wouldnt work, in msvc there is no simple main, only in gcc+cygwin
13:31:39 <ski> Cale : you mean that you have your wrists in the air, above the keyboard/table, instead of resting at the nearer end of the keyboard, yes ?
13:31:59 <mekeor> geekosaur: cabal updated. still same error.
13:32:28 <geekosaur> mcstar, it's a bit more complex than that, but the setup used by msys behaves like that and hides what's really going on
13:33:06 <whittle> I’m looking at the example code at http://hackage.haskell.org/packages/archive/hoauth/0.3.4/doc/html/Network-OAuth-Consumer.html, and I’m confused by the use of { ... ; ... } syntax. Does it have a name?
13:33:08 <geekosaur> mekeor, ugh, I have no idea then.  your cabal is insisting that there is no ghc 7.4.1-compatible version of the unix package, I do not know how to fix it
13:33:14 <geekosaur> if cabal update didn;t work
13:34:43 <aekition> does haskel have a drag n drop ide? to build windows apps?
13:35:00 <mcstar> again, that has nothing to do with haskell
13:35:14 <mcstar> you want an interface editor?
13:35:32 * hackagebot pqc 0.5.1 - Parallel batch driver for QuickCheck  http://hackage.haskell.org/package/pqc-0.5.1 (KidoTakahiro)
13:36:01 <aekition> yes
13:36:20 <mekeor> aekition: you can use glade for gtk.
13:36:27 <mcstar> aekition: first choose a gui toolkit
13:36:30 <aekition> leksah does not do that?
13:36:49 <mekeor> aekition: Haskell /= Visual-C++
13:38:01 <aekition> so glade is the only gui for haskell? or is it jus the best
13:38:23 <Phlogistique> mcstar: there is no well-known Haskell IDE featuring a graphical GUI editor
13:38:38 <Phlogistique> oops
13:38:42 <mekeor> aekition: glade is a interface-editor for GTK-applications.
13:38:42 <Phlogistique> aekition: ^
13:38:52 <mcstar> Phlogistique: i think of you too all the time
13:38:54 <ski> Cale : hm, btw, didn't you have some monad stuff in Scheme, which passed a record of the methods to generic actions ?
13:39:09 <aekition> yes i know its an interface editor im lookin for...
13:39:36 <Phlogistique> aekition: One of the toolkits you can use in Haskell, namely Gtk2Hs, may use interfaces produced with a tool named "Glade"
13:40:10 <mcstar> i personally dont use these celebrated interface editors
13:40:11 <Phlogistique> aekition: if you want Haskell _and_ drag-n-drop GUI creation, that's prolly the best you'll do
13:40:30 <Cale> ski: I mean that my arm and fingers aren't usually at an angle to one another, they're just straight. Usually my wrists are floating and my arms rest on the edge of my desk near my elbows.
13:40:39 <Cale> ski: not my stuff
13:41:00 <Phlogistique> but given your level of expertise, it's prolly not the best idea. What are you seeking to do? Why did you choose Haskell to do it?
13:41:26 <aekition> some guy recommended haskell as my first programmin language
13:41:32 <ski> Cale : up-to-down angle, or left-to-right angle ?
13:42:05 <ski> (Cale : ok, it might have been edwardk, i suppose)
13:42:18 <mcstar> aekition: was he sarcastic when he said it?
13:42:33 <Cale> ski: I have discussed how it might be done in the past, but I've never bothered to actually write code, since it sounds awkward in any case :)
13:42:46 <aekition> have no idea mcstar
13:42:51 <dcoutts_> mcstar: Haskell is a fine first programming language, we used it that way at my university
13:42:55 <aekition> but its kind of intersting anw
13:42:57 <tgeeky> can someone who is on the latest haskell platform please make sure that:  import Data.Time   getCurrentTime >>= print   works?
13:43:35 <mcstar> aekition: it just can be a lot to get to know haskell and a gui toolkit at the same time
13:43:58 <mcstar> id suggest learn the language, and stay away from the gui for a bit
13:44:04 <aekition> ok dont worry bout the gui... i will jus stick to coding
13:44:04 <Cale> ski: My arms make an ~60 degree angle with the horizontal edge of the desk, and my wrists are straight in all directions.
13:44:20 <dcoutts_> aekition: I'd second that advice to start with tasks simpler than GUI programming
13:44:42 <ski> Cale : ok, i see (ty)
13:45:49 <Cale> I don't have any scientific evidence that this is actually better, but it seems more comfortable to me.
13:50:41 <mcstar> Cale: uhm, isnt that the standard way?
13:51:04 <mekeor> Cale: i think we (mefisto (from #leksah) and i) figured out the problem now: (the latest) cabal-install depends on unix-2.4.2.0 which depends on base<4.4 which i can't install, of course.
13:51:32 <mcstar> hm, maybe 75 degrees for me
13:51:41 <byorgey> the latest cabal-install does not depend on unix-2.4.
13:51:52 <byorgey> however, note that if you want the latest cabal-install you must specifically request the latest version
13:51:56 <byorgey> otherwise you get an older one.
13:52:03 <byorgey> cabal install cabal-install-0.14.0
13:52:10 <mekeor> ah.
13:52:28 <Cale> mcstar: The usual way that they teach people to type puts a bend in your wrists.
13:52:30 <mekeor> i meant that version which cabal-install wants to install when i type cabal install cabal-install.
13:52:42 <Cale> (with the whole home row thing)
13:52:52 <mekeor> byorgey: do you have any idea how i can fix this annoying issue?
13:52:59 <mekeor> i want to install leksah.
13:53:05 <byorgey> mekeor: why not install cabal-install-0.14.0?
13:53:08 <byorgey> does it not work with leksah?
13:53:09 <mcstar> Cale: when im on home row, my hand are a bit lifted, but mainly straight with my arm
13:53:19 <mekeor> byorgey: idk. let's try.
13:53:28 <byorgey> Cale: that has more to do with the design of keyboards than with the method of typing, doesn't it?
13:53:47 <Cale> byorgey: Sure, but I type on a straight keyboard with unbent wrists.
13:53:54 <mcstar> i just hate that my right little finger has soo much to do
13:53:56 <byorgey> ah, fair enough.
13:54:11 <Cale> specifically this keyboard :D http://www.daskeyboard.com/model-s-ultimate/
13:54:12 <mcstar> ebter, backsoace, p []{}'\;
13:54:27 <byorgey> oooh, shiny =)
13:54:33 <tgeeky> HERMIT -- Stability: vaporware
13:55:07 <byorgey> hehe
13:55:24 <byorgey> andyjgill++
13:55:38 <tgeeky> byorgey: does one have to do something special to be able to reply to haskell-cafe threads?
13:55:54 <byorgey> one must be subscribed to haskell-cafe
13:56:01 <tgeeky> one is
13:56:08 <byorgey> and put your reply in an email addressed to haskell-cafe
13:56:26 <tgeeky> yep. I think it's because I am not using the exact same e-mail address in response.
13:56:27 <byorgey> and make the appropriate sacrifices to the Mailman Gods
13:56:53 * DanBurton refuses to sacrifice his laziness
13:57:14 <byorgey> if the address your email appears to be coming from is not exactly the same as the one that is subscribed, that will indeed not work.
13:57:19 <acowley> Sacrifice laziness? Maybe later.
13:57:31 <hpaste> mekeor pasted “byorgey: error while "cabal install cabal-install-0.14.0"” at http://hpaste.org/69512
13:57:33 <andyjgill> tgeeky: HERMIT *was* vaporware on Aug 2 2011
13:58:04 <mekeor> how do i solve recursive dependencies? -.-
13:58:04 <tgeeky> andyjgill: oh crap. I thought I was getting the new shiny good stuff from hackge.
13:58:15 <mekeor> package-managment is annoying.
13:58:31 <mekeor> *management
13:59:15 <tgeeky> byorgey: I thought I'd be cute and use technogeeky+haskellcafe ... to filter my mail.
13:59:22 <byorgey> mekeor: eek, your package DB looks screwed up
13:59:24 <DanBurton> we should appoint a Haskell dictator that just decides the One and Only version for all packages so that they will all play nice
13:59:32 <mekeor> byorgey: -.-
14:00:01 <DanBurton> tgeeky: or you could just filter by to:haskellcafe
14:00:31 <andyjgill> tgeeky: we were hackage domain squatting (the name hermit was explicitly mentioned in the proposal)
14:00:34 <tgeeky> DanBurton: yes. well I usually rely on this to find out who is spamming me, since evidently spammers aren't clever enough to s/+(.*)//
14:00:51 <mekeor> fuck you, fuck me, fuck cabal, fuck any package-management.
14:00:54 <tgeeky> adamt: oh. but I don't see a link to get the HERMIT software. It sounded like it was available.
14:00:56 <mekeor> i needed to say that, sorry.
14:01:07 <shirt> Is every Monad also a Functor?
14:01:11 <tgeeky> shirt: yes
14:01:14 <mekeor> shirt: in theory.
14:01:35 <mekeor> shirt: in haskell, not necesessarily, though.
14:01:43 <mekeor> necessarily?
14:01:56 <shirt> In "Real World Haskell" they define: newtype HandleIO a = HandleIO { runHandleIO :: IO a } deriving (Monad)
14:02:02 <andyjgill> tgeeky: The paper is there, the software is local to KU right now.
14:02:06 <shirt> is HandleIO also a Functor? Is it automatic?
14:02:12 <mekeor> shirt: no.
14:02:21 <tgeeky> andyjgill: awh. I wanted to equationally reason!
14:02:41 <andyjgill> tgeeky: We all do.
14:02:50 <mekeor> unfortunately, Monad is not defined as "class Functor f => Monad f where …" but as "class Monad f where …".
14:02:54 <mekeor> shirt: ı
14:02:59 <mekeor> s/ı/↑/
14:03:04 <tgeeky> andyjgill: oh. this is true. But I'm terrible at it. So I was going to enslave your hermit.
14:03:40 <mekeor> byorgey: so… what? what can i do?
14:03:53 * mekeor is very desperate.
14:04:04 <shirt> i guess my question is: Should HandleIO be a Functor?
14:04:23 <mekeor> shirt: yes
14:04:26 <tgeeky> shirt: it should behave like one, yes. But it probably shouldn't have a Functor superclass
14:04:30 <mekeor> shirt: all monads should be a functor.
14:04:32 <tgeeky> @src Monad
14:04:32 <lambdabot> class  Monad m  where
14:04:32 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:04:32 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:04:32 <lambdabot>     return      :: a -> m a
14:04:32 <lambdabot>     fail        :: String -> m a
14:04:56 <tgeeky> shirt: notice, no class (Functor m) => Monad m where ...
14:05:13 <mekeor> tgeeky: i already said that :P
14:05:26 <shirt> so i should just stick "Functor" also inside the "deriving" together with "Monad" ?
14:05:43 <mekeor> shirt: if it works, yes.
14:05:59 <tgeeky> mkaito: one definition is worth a thousand explanations
14:06:00 <tgeeky> err
14:06:01 <mekeor> i'm not sure whether you will need a lang-ext.
14:06:04 <akosch> is there a parser in parsec which doesn't consume input even if it succeeds?
14:06:06 <tgeeky> mekeor: one definition is worth a thousand explanations
14:06:17 <tgeeky> akosch: the empty parser?
14:06:57 <shirt> mekeor: seems to work :) what else whould i stick in ther? Applicative?
14:07:11 <mekeor> shirt: yep *nod*
14:07:27 <akosch> tgeeky: I'm looking for something like try, but instead of only consuming input if the parser succeeds, it should never consume anything
14:07:32 <Phlogistique> shirt: I read that as s/ther/her/ :(
14:07:57 <mekeor> shirt: do you actually need language-extensions to be able to derive Functor and Monad etc?
14:08:24 <shirt> mekeor: i'm using GeneralizedNewtypeDeriving
14:08:32 <mekeor> ah, okay. nice.
14:09:10 <tgeeky> akosch: hm. I can imagine that working, but I don't have much to guide you.
14:11:13 <byorgey> akosch: I think there is something called 'lookAhead' or something like that
14:11:17 <akosch> tgeeky: yeah, maybe there is a better solution: I'm using manyTill to consume everything until I encounter an opening / closing token. But I don't why it stopped: because of the opening token or the closing one :/
14:12:25 <byorgey> mekeor: you can try deleting ~/.ghc/<the-version-of-ghc-you-are-using> and starting over.  Other than that I really don't know =(
14:12:31 <akosch> byorgey: thanks, I'll check it out.
14:13:01 <byorgey> akosch: http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Prim.html#v:lookAhead
14:13:27 <byorgey> in particular  try (lookAhead foo)  if you want it to never consume any input
14:14:13 <akosch> byorgey: yeah, I was thinking I'd need to combine it with try
14:14:38 <mekeor> byorgey: what exactly do you mean by starting over? where should i begin again then?
14:14:52 <byorgey> mekeor: I mean try doing  'cabal install whatever'  again
14:15:09 <mekeor> ah
14:15:13 <byorgey> removing that directory just removes your local package DB
14:15:24 <mekeor> that is, all packages?
14:15:31 <byorgey> so you have to reinstall any cabal packages you had installed
14:15:36 <byorgey> only the local ones, not the global ones
14:15:50 <mekeor> yea ok… hmm…
14:31:58 <akosch> what is ParserState good for in parsec? could someone give me an example using it?
14:33:26 <mm_freak> i'm very wary to use CPS nowadays because i know i'm going to lose feedback (MonadFix/ArrowLoop)…  is anyone experiencing the same neurosis?
14:35:03 <Botje> akosch: keeping track of the current scope, for example.
14:35:24 <Peaker> I don't use MonadFix/Arrows at all...
14:35:30 <Botje> akosch: or building a symbol table as you go.
14:35:38 <Peaker> though I don't use much CPS either
14:35:40 <Botje> (if you're writing something compiler-like)
14:36:00 <Botje> akosch: or you could keep track of the current tagstack if you're parsing xml/html, in order to do smart corrections.
14:36:20 <Botje> (ie. <div><b>foo</div> is probably <div><b>foo</b></div>)
14:40:19 <akosch> Botje: thanks, this exactly what I need. How does it work?
14:42:11 <Botje> don't know, never used it :)
14:42:22 <Botje> presumably you start by adding in the parameter in your Parsec type
14:42:30 <Botje> and when do you runParser
14:43:27 <Botje> ah
14:43:41 <Botje> and ParsecT (the underlying type for Parsec) is an instance of MonadState
14:44:02 <Botje> so you can just use get and put like you would in the State monad
14:45:31 <akosch> Botje: ok, I'll try it... thanks again!
15:06:37 <Luke> does anyone know how to get the "haskell-process-generate-tags" emacs function installed?
15:08:17 <Luke> i did a 'cabal install hasktags' already
15:08:22 <Luke> no luck
15:15:51 * hackagebot spatial-math 0.1.0.0 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.1.0.0 (GregHorn)
15:20:51 * hackagebot samtools 0.2.1.1 - Binding to the C samtools library  http://hackage.haskell.org/package/samtools-0.2.1.1 (NicholasIngolia)
15:37:32 <ciaranm> is there an easy way of figuring out whether or not ghc is tail-calling out recursion in a particular function?
15:38:15 <c_wraith> the answer is probably "it's using a tail call, but that doesn't mean what you think it does in a non-strict language"
15:38:26 <ciaranm> hrm, possibly
15:38:35 * ciaranm is getting stack overflows and shouldn't be
15:39:17 <fmap> paste code
15:39:39 <c_wraith> usually stack overflows in GHC are caused by laziness problems. The accumulator isn't forced until a giant chain of thunks has been created.
15:40:11 <hpaste> ciaranm pasted “stack overflow” at http://hpaste.org/69522
15:40:17 <ciaranm> i think degreePrune is the problem
15:42:04 <monochrom> my http://www.vex.net/~trebla/haskell/lazy.xhtml explains tail-call and stack overflow. look for "case study: foldl"
15:43:06 <c_wraith> it's a little hard to tell because the code isn't complete
15:43:20 <c_wraith> But it certainly does look like a recursive loop with an accumulator that isn't being forced
15:43:50 <ciaranm> unfortunately the "run the code" harness involves a horrible nasty parser for some standard format benchmarks...
15:44:15 <c_wraith> well, I meant more the graph-related code which is all non-present
15:44:28 <c_wraith> like subgraphDegreeList
15:44:43 <ciaranm> if i pasted the current way that that lot's implemented, you'd all try to kill me...
15:44:59 <c_wraith> heh.
15:45:09 <c_wraith> well, I think you're right that it's a problem.
15:45:12 <monochrom> exterminate all humans
15:45:16 <c_wraith> expand could be a problem, too
15:45:21 <c_wraith> look at monochrom's link
15:45:31 <c_wraith> It explains the underlying cause
15:45:45 <c_wraith> When you understand that, you'll start to see how to improve it.
15:45:51 <ciaranm> i'm supposed to be making this code look plausibly similar to the things in the original papers where the variations on the algorithms are presented, which means some of it is decidedly fugly...
15:45:57 <ciaranm> yeah, i'm reading monochrom's thing now
15:46:22 <ciaranm> shoving !s on everything isn't enough to help, unfortunately
15:46:33 <c_wraith> no, because your accumulators aren't flat data types
15:46:43 <c_wraith> You'll need to be more careful
15:46:46 <ski> sometimes you need to force parts of data, not just the whole data things
15:47:12 <ski> (and sometimes you need to *not* force the whole data thing)
15:48:08 <ciaranm> the problem with degreePrune is that if i write it the way i want to write it, i won't be able to just trivially swap in the other variations
15:48:48 <c_wraith> http://book.realworldhaskell.org/read/profiling-and-optimization.html
15:49:10 <c_wraith> That discusses optimizing a function with a stack overflow (eventually)
15:49:21 <c_wraith> and in quite a lot of detail
15:51:00 <ciaranm> hrm. expand shouldn't be a problem. it's expected to go n deep anyway, since it's doing a binomial tree thingie.
15:51:31 <ciaranm> maybe my input data is just too big and 2n stack frames don't fit...
16:00:55 * hackagebot spatial-math 0.1.1 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.1.1 (GregHorn)
16:22:26 <Siod> anyone know a project that uses plugins?
16:22:30 <Siod> open source
16:24:58 <edwardk> lambdabot
16:27:24 <Siod> any others
16:38:45 <edwardk> preflex: xseen jkff
16:38:45 <preflex>  jkff was last seen on freenode/#haskell 5 hours, 51 minutes and 32 seconds ago, saying: Understanding this will take some time.
16:45:47 <augur> is there a standard function like   lex :: ([a] -> Maybe ([a], [a])) -> [a] -> [[a]]   that lexes based on a reading function?
17:06:38 <Peaker> augur, does that recursively apply on each of the results?
17:07:01 <augur> Peaker: yeah. the idea is that it would lex a string, basically
17:07:11 <augur> or, any list of a's
17:07:20 <augur> or at least break it into words defined according to the predicate
17:08:01 * ski . o O ( `lexBy :: ReadS a -> String -> [] [a]' )
17:08:19 <augur> ski!
17:08:23 <augur> interesting.
17:08:30 <augur> thank you
17:08:35 <ski>   type ReadS a = String -> [(a,String)]
17:08:44 <ski> replace `String' with `[t]' if you prefer
17:09:40 <augur> hmm
17:10:08 <ski> this is similar to `repeatSR :: Monad m => StateT sr m a -> ReaderT sr m [a]', except that in your case you want to terminate the list when you reach an "empty" state
17:11:01 <ski> though i suppose there might be better names than `lexBy', since presumably(?) `lexBy' itself wouldn't do any lexing, only the argument function would ?
17:17:36 <ski> @let repeatM :: Monad m => m a -> m [a]; repeatM = liftM2 (:) `ap` repeatM
17:17:37 <lambdabot>  Defined.
17:17:40 <ski> @let repeatSR :: Monad m => StateT sr m a -> ReaderT sr m [a]; repeatSR sma = ReaderT loop where loop sr = do (a,sr) <- sma `runStateT` sr; liftM (a :) (loop sr)
17:17:41 <lambdabot>  Defined.
17:23:51 <Iceland_jack> Hey what would be the best way to run some function for each element of a list, producing a list of results: (???) (+1) [1,2,3] = [[2,2,3],[1,3,3],[1,2,4]]
17:32:43 <shachaf> > zipWith (zipWith id) (iterate (id:) ((+1) : repeat id)) $ zipWith const (repeat [1,2,3]) [1,2,3]
17:32:44 <lambdabot>   [[2,2,3],[1,3,3],[1,2,4]]
17:33:06 <Iceland_jack> ah thanks a bunch shachaf!
17:33:09 <shachaf> That's kind of a hilarious way of doing it.
17:33:13 <shachaf> Iceland_jack: Don't do that!
17:33:31 <Iceland_jack> Well it's either that or making a specialized function to do that
17:33:40 <shachaf> Or expressing it in a nicer way.
17:34:25 <Iceland_jack> I normally wouldn't ask but I was at a loss expressing it ‘functionally’
17:34:42 <shachaf> My way is not a good way of expressing it.
17:34:57 <shachaf> > let foo f [] = []; foo f (x:xs) = (f x : xs) : map (x:) (foo f xs) in foo (+1) [1,2,3]
17:34:58 <lambdabot>   [[2,2,3],[1,3,3],[1,2,4]]
17:36:04 <Iceland_jack> hm thank you :) that looks far nicer
17:38:32 <tgeeky> shachaf: almost that same function was being talked about earlier
17:38:46 <tgeeky> maybe not, that's more polymorphic
17:39:22 <shachaf> That's a relatively common pattern, I think.
17:39:56 <tgeeky> shachaf:
17:39:57 <tgeeky> > let f [] = []; f (x:xs) = x : f (map (h (length (x:xs)) x) xs) in f [a,b,c]
17:39:58 <lambdabot>   [a,h 3 a b,h 2 (h 3 a b) (h 3 a c)]
17:40:14 <shachaf> @let iaep e [] = [[e]]; iaep e (x:xs) = (e:x:xs) : map (x:) (iaep e xs)
17:40:15 <lambdabot>  Defined.
17:40:28 <shachaf> Ew, length.
17:40:32 <tgeeky> shachaf: yeah
17:40:41 <tgeeky> shachaf: the question was, is it a fold (no), an unfold (maybe?)
17:41:01 <shachaf> tgeeky: Sure it's a fold.
17:41:07 <shachaf> Every function on lists is a fold. :-)
17:41:12 <shachaf> And every function that builds a list is an unfold.
17:41:18 <tgeeky> well, it's neither a foldr nor a foldl :O
17:41:29 <tgeeky> the original function he was asking about was a little different
17:41:51 <tgeeky> it's not a reducer, that's for sure :O
17:42:44 <ski> @quote admitting
17:42:45 <lambdabot> Cale says: Computing lengths is admitting defeat
17:45:41 <newsham> Warning: -fglasgow-exts is deprecated: Use individual extensions instead
17:45:52 <shachaf> @ghc
17:45:52 <lambdabot> ghc says: PArse error (possibly incorrect indentation)
17:45:54 <newsham> but http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/primitives.html#unboxed-tuples doesnt list an extension for unboxed tuples
17:46:04 <newsham> is there an extension flag for that now?
17:46:36 <shachaf> MagicHash?
17:46:46 <ski> `-XUnboxedTuples' ?
17:46:58 <shachaf> ...Or that.
17:47:42 <newsham> ty
17:53:05 <ski> @type let someElement :: [a] -> [(a,a -> [a])]; someElement [      ] = []; someElement (a0:as0) = (a0,\a1 -> a1:as0) : [(a,\a -> a0:a_as a) | (a,a_as) <- someElement as0] in \f -> map (\(a,a_as) -> a_as (f a)) . someElement
17:53:06 <lambdabot> forall t. (t -> t) -> [t] -> [[t]]
17:53:14 <ski> > let someElement :: [a] -> [(a,a -> [a])]; someElement [      ] = []; someElement (a0:as0) = (a0,\a1 -> a1:as0) : [(a,\a -> a0:a_as a) | (a,a_as) <- someElement as0] in (\f -> map (\(a,a_as) -> a_as (f a)) . someElement) (100 +) [0,1,2,3]
17:53:16 <lambdabot>   [[100,1,2,3],[0,101,2,3],[0,1,102,3],[0,1,2,103]]
17:53:57 <dmwit> So here's something I'm not sure I understand yet. If some unbound threads are running along on a particular worker OS thread, and one of them makes a safe FFI call, what happens? Is the safe call evacuated to a fresh OS thread (or possibly one from a pool, I suppose), or are the other unbound threads evacuated to other worker OS threads?
17:55:26 <geekosaur> the former, is how I understand the documentation; and it specifically mentions retaining such threads in a pool afterward
17:56:06 <dmwit> Where can I find this documentation? =)
17:56:20 <whittle> Hi, ski! I was just re-reading some things you explained to me about types and kinds and I was able to make it through the statement “so then `(*)' would be a type function which converts a two-tuple of types to the tuple type which has values which are two-tuples” without my head spinning. Thank you again.
17:56:58 <ski> whittle : yw ;)
17:56:59 <dmwit> Phew, that sentence seems purposely designed to make your head spin. =D
17:57:55 <ski>   (*) : ConcreteType * ConcreteType -> ConcreteType  -- referring to this
17:58:09 <geekosaur> http://www.haskell.org/ghc/docs/7.0.4/html/libraries/base-4.3.1.0/Control-Concurrent.html#g:10
17:58:20 <dmwit> geekosaur: thanks again
17:58:55 <ski> (where the kind `*' has been renamed into `ConcreteType', and infix operators are supposed to take arguments tuples, instead of curried, and where the tuple tuple/kind of `A' and `B' is written as `A * B' instead of `(A,B)')
18:00:36 <ski> (er, tuple type/kind ..)
18:01:44 <dmwit> geekosaur: Hm... I interpret this documentation the other way. =P
18:01:55 <dmwit> "a thread making a safe foreign call will not block the other threads in the system; another OS thread will take over running Haskell threads until the original call returns"
18:02:14 <dmwit> sounds like the safe call continues in the OS thread it started in, and the other unbound threads that were on that OS thread move
18:03:07 <rwbarton> I was wondering about this subject also.
18:03:31 <rwbarton> If I have enough Haskell threads making safe FFI calls, can they use up the whole pool of OS threads? Or will the RTS make more OS threads?
18:03:52 <dmwit> Well, that one at least should be easy to test.
18:03:59 <rwbarton> Yes, I suppose so :)
18:03:59 <dmwit> Let's test it right now! =)
18:06:24 <dmwit> rwbarton: It makes as many OS threads as it needs.
18:06:39 <rwbarton> neat
18:06:41 <rwbarton> Thanks
18:07:06 <shachaf> Do the extra threads get killed later?
18:07:35 <rwbarton> (The initial number of OS threads is the +RTS -N<n> value, right?)
18:07:43 <shachaf> It's vaguely worrying if you can run with +RTS -N2 and not use forkIO and still use an unbounded number of threads.
18:07:44 <dmwit> rwbarton: No, actually.
18:07:50 <rwbarton> oh?
18:07:53 <dmwit> shachaf: Eh, what?
18:07:55 <shachaf> (Not to be confused with unbound threads!)
18:07:58 <dmwit> shachaf: You must use forkIO to make a thread.
18:08:00 <shachaf> dmwit: Maybe I just misread what you said.
18:08:03 <shachaf> dmwit: I mean OS threads.
18:08:17 <dmwit> shachaf: So do I.
18:08:27 <shachaf> Right.
18:08:39 <shachaf> So if you forkIO a hundred times and do a hundred FFI calls, it'll spawn a hundred OS threads?
18:08:49 <dmwit> rwbarton: -N<n> controls how many OS threads there are for executing unbound Haskell threads.
18:09:14 <dmwit> rwbarton: But there's always at least one more thread for main, plus as many threads as you ask for with forkOS, plus as many threads as necessary to execute all the safe calls that are going concurrently.
18:09:33 <dmwit> ...and possibly more, I'm not 100% sure exactly how everything works yet. =)
18:09:36 <rwbarton> one more thread for main! huh.
18:09:47 <dmwit> Yep, main is a bound thread according to the Concurrent Haskell spec.
18:09:50 <rwbarton> i see
18:10:06 <dmwit> Which is super important for Windows apps, because the Win32 API uses thread-local state.
18:10:17 <dmwit> shachaf: right
18:10:27 <shachaf> dmwit: So that's the bit that's vaguely worrying.
18:10:38 <rwbarton> shachaf: But how is that "run[ning] with +RTS -N2 and not us[ing] forkIO"
18:10:47 <rwbarton> did you mean forkOS?
18:10:53 <shachaf> rwbarton: Er.
18:10:56 <shachaf> I did mean forkOS!
18:11:00 <dmwit> Ah!
18:11:02 <shachaf> That explains everyone's confusion.
18:11:05 <dmwit> That explains your complaint. =)
18:11:06 <rwbarton> yep
18:11:18 * ski . o O ( `forkIOS' )
18:11:28 <dmwit> I think it's probably (?) pretty unusual to have a lot of outstanding FFI calls, though.
18:11:29 <shachaf> ski: I think Apple wouldn't like that.
18:11:47 <shachaf> dmwit: Maybe. But that's not an excuse, on its own. :-)
18:11:49 <ski> hehe
18:11:52 <copumpkin> fork iOS? http://craziestgadgets.com/wp-content/uploads/2010/03/fork-and-spoon-iphone-stand-375x500.jpg
18:12:00 <shachaf> In one sense "safe" calls are less safe than "unsafe" calls in this case.
18:12:23 * ski isn't sure the "safe" terminology here is very sane
18:12:25 <dmwit> shachaf: To answer your other question, I suspect (but did not test) that OS threads are never deleted by GHC.
18:12:35 <dmwit> ski: Yeah, I have a mini-section in the blog post I'm writing about that.
18:12:38 <rwbarton> the ffi "safe" terminology, or the shachaf "safe" terminology?
18:12:44 <shachaf> dmwit: That's even more worrying, then.
18:12:51 <ski> dmwit : do tell the link when you're done
18:13:03 <dmwit> will do
18:13:05 <ski> the ffi one
18:13:40 <shachaf> dmwit: Add me to the update list!
18:13:45 <ski> (rwbarton : you forgot to ask whether i maybe meant my own "sane" terminology ;)
18:13:59 <rwbarton> :)
18:14:05 <dmwit> I'll post it on reddit -- do you both follow the Haskell sub?
18:15:16 <shachaf> Sometimes.
18:16:59 <newsham> when using "new exceptions", how do you make a catch that catches both ErrorCall exceptions and IOError exceptions, and does someting differently for both?
18:17:04 <newsham> do you need nested catches?
18:17:23 <c_wraith> those are probably easier to understand
18:17:24 * ski doesn't follow
18:17:35 <c_wraith> but you can also explicitly do a bunch of casting yourself
18:17:41 <Peaker> ok, enough with the ad-hoc type-inference rules-as-I-go-along :) Time to implement a real inference algorithm...
18:17:43 <c_wraith> you know, implementing the same mechanism catch does
18:18:36 <Peaker> http://en.wikipedia.org/wiki/Type_inference says "Increasingly, just-in-time compilation renders the distinction between run time and compile time moot.", heh
18:18:57 <hughfdjackson> :/ something strikes me as odd in haskell
18:19:08 <hughfdjackson> isn't allowing for fatal errors a breakage of purity?
18:19:14 <ski> bah, even if you interleave compile-time and run-time, they're still conceptually distinct
18:19:45 <ski> hughfdjackson : yes, but a very mild such (allowing for nontermination is similar)
18:20:04 <hughfdjackson> ^^ makes sense
18:20:08 <ski> hughfdjackson : the consequence is that we have to keep track of partial elements of types
18:20:26 <stephenjudkins> ski: doesn't seem that mild to me
18:20:39 <newsham> I guess if i use catch as an infix word, nesting catches is pretty easy
18:20:44 <c_wraith> newsham: you can catch SomeException, then use fromException to attempt to convert it to each type you care about handling.  Doing so is essentially re-implementing what catch does
18:20:54 <stephenjudkins> there are a lot of things that throw exceptions in pretty obvious places
18:20:55 <ski> stephenjudkins : it's still idempotent, and commutative (assuming you treat all abortions as semantically equal)
18:20:56 <stephenjudkins> ! head []
18:21:12 <parcs`> newsham: use 'catches' :)
18:21:47 <c_wraith> oh, right.  catches implements that internally.  yeah, that.
18:22:21 <ski> stephenjudkins : so, what you lose is affinity (aka "discardability". idempotency is also more or less the same as "copyability")
18:22:38 <stephenjudkins> ski: agreed
18:23:05 <hughfdjackson> ski: commutative in the sense that, no matter where you put it, it's going to break everything?
18:23:12 <hughfdjackson> or not, depending on how you handle it
18:23:28 <ski> hughfdjackson : in the sense of forcing `a' and then forcing `b', is the same as doing it the other way around
18:24:05 <ski> hughfdjackson : so, yes (iiuc what you mean)
18:24:13 <newsham> parcs: danke
18:24:31 <hughfdjackson> ski: :D gotcha
18:25:34 <newsham> parcs: do the handlers have to be total?
18:25:41 <acowley> Creative notation in papers has got to be one of the worst things otherwise good authors do
18:25:50 <newsham> if i give it a partial func for a handler will it not catch?  or do i need to do some fancy "just" thing for that?
18:26:05 <ski> acowley : such as ?
18:26:55 <acowley> ski: Whinging rules: any paper whose every equation isn't immediately readable to me :P
18:27:12 <ski> hehe
18:27:21 <acowley> ski: I'm fighting (and losing) with some Conor McBride things at the moment.
18:27:24 <Peaker> Does Algorithm W or other type inference algorithms use UnionFind structures?
18:28:46 <ski> ah, McBride :)
18:28:58 <ski> acowley : ooi, which paper ?
18:29:12 <acowley> ski: the various datatype differentiation papers
18:29:13 * ski can't recall what `UnionFind' is
18:29:30 <acowley> union find is often used for agglomerative clustering
18:30:32 <Gracenotes> so, tomorrow at 8
18:30:37 <Gracenotes> things gonna get disrupted
18:30:48 <c_wraith> union-find is the data structure that supports two operations: asking "what group is this element in?", and saying "merge these two groups together"
18:31:01 <edwardk> peaker: it can, path compression can actually help the asymptotics of it
18:31:10 <c_wraith> it's also one of the few known data structures that appears to require mutation for optimal asymptotics
18:31:20 <Peaker> edwardk, interesting... finally a real use-case for that thing :)
18:31:24 <edwardk> peaker: unification-fd has a mode that does path compression
18:31:33 <edwardk> i pushed koninkje_away to add it ;)
18:31:40 <edwardk> it doesn't pay off for most problem sizes
18:32:01 <acowley> He must have been thrilled :P
18:32:10 <Peaker> a friend of mine published a paper about a simplified union find delete algorithm (same asymptotics as the best known, but significantly simpler)
18:32:31 <Peaker> though there's no delete needed here :)
18:32:52 <Gracenotes> anyway, this is a PSA for World IPv6 launch day. yup.
18:32:59 <Gracenotes> coming soon to an internet near you
18:33:28 <c_wraith> IPv6?  On my internets?  That doesn't seem too likely, to me.
18:33:29 <edwardk> peaker: nice. did you see my lca slides from the other day? (speaking of algorithms usually implemented with disjoint set forests)
18:33:39 <acowley> Gracenotes: so you're saying this is the last night of the internet?
18:33:52 <acowley> I better reddit harder than normal
18:34:12 <edwardk> peaker: https://docs.google.com/open?id=0ByK3AAy5ubqaZE1lblpwNjF0VlU
18:34:18 <edwardk> video should be going up shortly
18:34:23 <edwardk> i just need to get a new cable for my camera
18:35:30 <acowley> ski: as per my whinging, http://strictlypositive.org/diff.pdf is only variously successful at using super and subscripts to group terms
18:35:36 <Peaker> edwardk, oh man, that same friend would talk so much about lca :)
18:35:43 <Peaker> edwardk, I think I need to send this to him
18:36:02 <edwardk>  basically i improved the naive algorithm to give a nice persistent online lca algorithm with logarithmic lookup without preprocessing
18:36:21 <edwardk> which makes the wikipedia page lie about the asymptotic complexity of the general case ;)
18:37:16 <edwardk> i needed it for the revision control monad
18:37:20 <Peaker> edwardk, :-)
18:37:40 <Peaker> edwardk, I also do LCA in my (partial) revision control implementation
18:37:56 <Peaker> I do it naively (scan up until same depth, then scan up until they meet)
18:38:06 <Peaker> (I keep depth in each node)
18:38:07 <edwardk> yeah, thats the naive algorithm.
18:38:13 <edwardk> check the 'lca' package
18:38:17 <Peaker> what's the "revision control monad"?
18:39:21 <edwardk> if you store the list in a skew binary random access list, you can drop the initial elements in log time, and you can walk the spine which is logarithmic length in log time, then walk the complete tree before the first match in log time
18:39:21 <edwardk> so the overall algorithm becomes logarithmic rather than linear
18:39:26 <edwardk> and cons onto a skew binary random access list is O(1) so there is no overhead
18:39:43 <ski> acowley : on a quick scan, didn't find any strange indices notation ..
18:40:09 <ski> ("LCA" ?)
18:40:12 <edwardk> basically the idea is you get version controlled variables, where you specify a 3 way merge strategy on variable creation, fork, join, and read/write operations for the variables, when you join, if both branches have performed an edit on a variable the merge strategy is applied
18:40:17 <edwardk> ski: lowest common ancestor
18:40:27 <Peaker> edwardk, what do you use it for?
18:41:11 <edwardk> peaker: well, fork sparks the second computation, so its an opportunistic parallelism model when applied naively, which can give you a couple times speedup on 8 cores, but the fork/join graph is also useful for incremental recomputation
18:41:31 <edwardk> we can add a metaphor breaking record :: Rev s a -> Rev s (a, Rev s a) operation
18:42:02 <edwardk> which records what computations were done in the tree, and when replaying the computation checks to see if their dependencies have changed or not, permitting you to directly reuse the answer from different branches
18:42:24 <edwardk> so you can write pretty naively imperative code, and then compute something, record it, and mutate the world, and play back the tape
18:42:38 <edwardk> and you get to recycle the answers or parts of answers that didn't change
18:43:23 <Peaker> edwardk, what's the concrete use case you've been using it for?
18:43:42 <edwardk> for something simple like, say, calculating css layout, you can get a couple x speed up just using the parallelization on 8 cores, but for typical edits to the world, you get ~27x speedup from frame to frame since you can recycle most of the previous frames calculation
18:43:49 <edwardk> my main use case is for type error slicing
18:44:00 <edwardk> you run a type checker where you limit access to parts of the source file
18:44:11 <edwardk> and then refine the limits, trying to get the same error with a smaller input set
18:44:11 <Peaker> also, why do the parallel threads compute things that need to be merged rather than independent things?
18:44:34 <edwardk> if they can compute independent answers all the better, but the general idea is to 'roll forward' rather than 'roll back'
18:44:53 <ski> type error slicing, yay !
18:45:20 <edwardk> with the type error slicer the revision control monad lets me recycle most of the previous type checking pass, taking most of the refinements down to practically constant time
18:45:29 <edwardk> or really logarithmic
18:45:52 <edwardk> the goal being a type error slicer written without an explicit constraint system
18:45:56 * ski . o ( Type Error Slicer for SML <http://www.macs.hw.ac.uk/ultra/skalpel/> )
18:45:58 <Peaker> edwardk, I can't say I understood all of that, but it sounds great :)
18:46:01 <edwardk> so you can use it to adapt a regular type checker
18:46:10 <edwardk> the skalpel link ski gave is good
18:46:17 * hackagebot murder 1.0 - MUtually Recursive Definitions Explicitly Represented  http://hackage.haskell.org/package/murder-1.0 (MarcosViera)
18:46:17 <edwardk> look in vincent rahli's thesis part 3
18:46:22 <edwardk> the first 2 parts are completely unrelated
18:46:31 <edwardk> he has nice pictures of the highlights you get
18:46:51 <edwardk> the old preprint that was on their site is gone, which was a nice overview of just this technique so you're stuck with the huge thesis link
18:47:40 <edwardk> as a side-effect of how i have implemented it in haskell, it also works with my speculation library
18:47:58 <edwardk> so you can get a lot of parallelism out of difficult to parallelize problems
18:49:11 <edwardk> http://research.microsoft.com/en-us/people/daan/ gives a few links you may want to check.
18:49:23 <edwardk> http://research.microsoft.com/apps/pubs/default.aspx?id=150180 is the paper that introduced the record primitive
18:49:57 <edwardk> http://research.microsoft.com/apps/pubs/default.aspx?id=151805 provided the original haskell implementation of a revision control monad
18:50:20 <edwardk> but their approach is very very IO-centric, so it reads a lot like Haskell written 10 years ago. I decided to turn things inside out and build a version on sparks
18:50:24 <tgeeky> 37x speedup... jesus
18:50:30 <edwardk> and thats what github.com/ekmett/revisions is
18:50:37 <edwardk> yep
18:50:42 <edwardk> not bad for 8 cores ;)
18:50:51 <tgeeky> "while requiring comparable effort by the programmer"
18:50:58 <tgeeky> so this isn't parallelism for a little work, but it's a lot for a lot
18:51:24 <ski> edwardk : yeah, i was looking for the preprint (and code) the other day, couldn't find it :/
18:51:29 <edwardk> its not much work really
18:51:43 <ski> (the old code associated with it, i.e.)
18:52:02 <edwardk> just sprinkle the forks/joins where you can, and try to think of invariants to get the merge strategy to be sound
18:52:18 <edwardk> the main issue with the approach is trying to get an intuition for the right 'grain size' to use
18:52:40 <edwardk> also both their approach and mine leak more memory than they strictly need to
18:53:45 <edwardk> mainly because i don't have a way to gc the long history tails in my current implementation, so they just keep growing
18:54:09 <Peaker> edwardk, the package seems small & sweet
18:54:21 <edwardk> Peaker: yeah, i still need to get record into it
18:54:48 <Peaker> isn't IVar in GHC now?
18:55:06 <edwardk> Peaker: i factored out the history code into 'lca', i just need to put together a version of the Data.LCA.Online data type that uses a monoidal value type
18:55:13 <Peaker> https://github.com/ekmett/revisions/blob/master/Control/Concurrent/Revision/Record.hs <-- isn't this record?
18:55:14 <edwardk> then i can shrink the revisions code a lot
18:55:32 <edwardk> notice i never implemented it for Rev s ;)
18:56:08 <edwardk> that was part of an experiment in how to adapt it to support monad transformers
18:56:11 <ishkabibl> So I'm looking hand writing a parser and lexer in Haskell but there is a bit of code I keep writting that I feel has a better solution
18:56:19 <ski> @hackage data-ivar
18:56:19 <lambdabot> http://hackage.haskell.org/package/data-ivar
18:56:21 <edwardk> not entirely sure i like the more generic approach
18:56:22 <ski> @hackage ivar-simple
18:56:23 <lambdabot> http://hackage.haskell.org/package/ivar-simple
18:56:24 <ski> which ?
18:56:47 <edwardk> ski: i have a copy of Data.IVar.Simple in there i think
18:56:55 <edwardk> i needed access to something it didn't expose
18:57:08 <ishkabibl> I keep wrriting the [Input] -> (Result, [Input]) kinda code where you take a list of input and return a tuple of the result and remaining input. is there a better idiom for this kinda thing?
18:59:41 <ski> edwardk : hm, i was pondering something a bit similar to `ivar-simple', where you allocate nodes which serve as identities so you can notice when you loop back, in graphs, but without the ability to delay the binding to the value ..
19:00:30 <ski> ishkabibl : `State [Input] Result'
19:01:13 <edwardk> ski: i wonder if you couldn't just do that with intern or something
19:01:25 <edwardk> at least for digraphs
19:01:32 <ishkabibl> ski this: http://www.haskell.org/haskellwiki/State_Monad?
19:01:37 <ski> ishkabibl : yes
19:02:21 <Peaker> I hate how state monads put the result state in the wrong side of the tuple :)
19:02:22 <rwbarton> @src State
19:02:22 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:02:35 <ski> edwardk : well, ideally i want something where i can naturally express e.g. computing live variables in a control flow graph
19:02:39 <Peaker> s -> (s, a)   so that:  fmap = fmap . fmap ; liftA2 = liftA2 . liftA2 ; ...
19:02:57 <Peaker> and as a bonus, you see the "s -> (s" part more clearly
19:02:59 <ski> Peaker : yeah :(
19:03:06 <rwbarton> that liftA2 isn't right
19:03:28 * ski finds he constantly (well, often, at least) need to litter such code with explicit `swap' calls
19:03:30 <Peaker> rwbarton, and the fmap, need to go into the constructors
19:03:38 <rwbarton> well yeah, but the liftA2 one is just wrong
19:03:53 <ski> Peaker : the same goes for the output monads ..
19:04:15 <rwbarton> @type runWriter
19:04:16 <lambdabot> forall w a. Writer w a -> (a, w)
19:04:23 <Peaker> ski, yeah
19:04:39 <rwbarton> this one is clearly backwards
19:04:47 <ski> @type mapAccumL
19:04:48 <ski> @type mapAccumR
19:04:48 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
19:04:49 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
19:04:55 <ski> these are not backwards
19:05:05 <ski> @type random
19:05:06 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
19:05:10 <ski> that one is, though
19:05:18 <tgeeky> edwardk: do you know what (if anything) goes wrong when you imagine a type class to have two seperate Pointed's? (or pure's) Similarly, is BiApplicative or TriApplicative nonsensical for an obvious reason?
19:05:41 <ski> (and `reads' is backwards, of course)
19:06:25 * ski . o O ( `Triplicative' )
19:06:28 <rwbarton> State s b = s -> (b, s) I actually prefer
19:06:36 <ski> why ?
19:06:36 <rwbarton> so that Kleisli (State s) a b = a -> s -> (b, s)
19:06:58 <ski> ok
19:07:06 <Peaker> why not: a -> s -> (s, b) ?
19:07:12 <rwbarton> which via (un)curry is (a, s) -> (b, s), and composition in this kleisli category is just composition
19:07:29 <rwbarton> i don't consider the arguments for either order terribly compelling though
19:07:30 <ski> (well, `a -> b -> c' really ought to correspond to `(b,a) -> c' ..)
19:07:36 <rwbarton> oh no, this again :)
19:07:38 <Peaker> interesting :)
19:07:50 * ski grins
19:07:50 <Peaker> ski, why?
19:07:55 <Peaker> it would solve this :)
19:07:58 <Peaker> but what else?
19:09:01 <ski>   Gamma |- a -> b -> c  <=>  a,Gamma |- b -> c  <=>  b,a,Gamma |- c  <=>  b /\ c,Gamma |- c  <=>  Gamma |- b /\ a -> c
19:09:45 <Catnaroek> Given the following definition: "fibs = map fst $ iterate next (0,1) where next (a,b) = (a+b,a)", why does the type system infer the type "fibs :: [Integer]". I understand the monomorphism restriction exists, but why does it pick Integer specifically?
19:10:18 <Cale> Because of numeric defaulting
19:10:21 <rwbarton> if you're going to distinguish (a,b) from (b,a), you should also distinguish left and right exponentials, no?
19:11:20 <ski> and `a,Gamma |- b  <=>  Gamma |- a -> b' is right because then you can do `a,Gamma |- a,a -> b |- b' -- i hope i don't have to explain why `a /\ (a -> b) |- b' is more natural than `(a -> b) /\ a |- b' ..
19:11:21 <Cale> By *ahem* default, it'll try to default to the first type in (Integer, Double) which satisfies the typeclass constraints, provided that all those constraints are Prelude classes, and the type otherwise would have been ambiguous.
19:11:28 <rwbarton> (more precisely, if b x - and - x b are nonisomorphic, so too will be their right adjoints)
19:11:35 <ski> rwbarton : yes, `a -> b' is a left exponential, of course
19:11:41 <Cale> You can change this list of types to try using the default keyword/declaration.
19:11:45 <Catnaroek> Cale: Is that default hardcoded?
19:12:25 <Catnaroek> Oh.
19:12:31 * ski points to the `default' keyword
19:12:45 <Cale> http://www.haskell.org/onlinereport/decls.html#sect4.3.4
19:12:50 <rwbarton> the default default is hardcoded
19:13:48 <Catnaroek> Well, what happens if I run into the monomorphism restriction when using a non-Num type?
19:13:56 <applicative> Catnaroek: as between Int and Integer, it's the only rational default, or rather the only rational default default as rwbarton puts it
19:14:00 <Catnaroek> e.g., using my own type classes and instances
19:14:00 <Cale> You get an error
19:14:21 <Cale> about ambiguous types
19:14:22 <Catnaroek> Oh, so that would require an explicit type annotation, right?
19:14:26 <Cale> yeah
19:14:46 <rwbarton> what actually happens is that you will get a confusing error message like "No instance for Num a0"
19:14:53 <Catnaroek> This is ridiculously arbitrary.
19:14:54 <Cale> Or just turn off the monomorphism restriction
19:14:57 <Cale> because it's derpy
19:15:01 <rwbarton> or rather MyClass a0
19:15:06 <Catnaroek> Cale: Yeah, I will be doing exactly that.
19:15:28 <Catnaroek> Now I have two defaults to override: MultiParamTypeClasses and NoMonomorphismRestriction.
19:15:38 <rwbarton> since it decides the only way to work around the monomorphism restriction is if it can choose a single instance that is polymorphic over all possible types
19:15:57 <applicative> Catnaroek: note, as regards your example, that fib n quickly outgrows maxBound :: Int
19:16:02 * ski thought `Rational' wasn't the default
19:16:32 <Catnaroek> applicative: Yeah, I was just like... "Integer is indeed the best choice, but how does the compiler *derive* that fact?"
19:17:25 <rwbarton> > show (read "")
19:17:26 <lambdabot>   "*Exception: Prelude.read: no parse
19:17:34 <rwbarton> argh
19:17:35 <applicative> Catnaroek: oh i see; yeah, it isnt so  smart
19:18:14 <Catnaroek> @type show (read "1")
19:18:15 <lambdabot> String
19:18:26 <rwbarton> wait, why does that still type check when I :set -XNoExtendedDefaultRules in ghci?
19:23:34 <applicative> how can we detect what ghci is interpreting read "1" to be in show (read "1")
19:23:55 <JamesRustle> ()
19:23:57 <applicative> i mean before it says it cant parse "1"
19:24:34 <rwbarton> replace "1" by various strings until the parse succeeds :)
19:24:40 <applicative> JamesRustle: Is that with -XExtendedDefaultRules ?
19:24:53 <applicative> rwbarton: ah indeed
19:24:53 <rwbarton> or you could look at the ghc core i guess
19:25:24 <ski> > show (read "()")
19:25:25 <lambdabot>   "()"
19:25:33 <applicative> either way it is happy to parse "()"
19:25:35 <ski> > show (read "(())")
19:25:36 <lambdabot>   "()"
19:25:41 <ski> > show (read "( )")
19:25:42 <lambdabot>   "()"
19:27:07 <ski> > read "0 : []" :: [Integer]
19:27:08 <lambdabot>   *Exception: Prelude.read: no parse
19:27:30 <MaskRay> why is it happy to parse "(())" :: ()
19:27:39 <ski> > read "(((0),(1)))" :: (Integer,Integer)
19:27:40 <lambdabot>   (0,1)
19:27:42 <applicative> > ((('a')))
19:27:43 <lambdabot>   'a'
19:28:27 <MaskRay> so the outer () is just ignored
19:28:52 <applicative> its parentheses, not part of unit's name
19:29:47 <ski>   showParen :: Bool -> ShowS -> ShowS
19:29:58 <ski>   readParen :: Bool -> ReadS a -> ReadS a
19:30:10 <parcs`> > read "(True)" :: Bool
19:30:11 <lambdabot>   True
19:30:39 <ski> > (readsPrec 0 :: ReadS Integer) "0"
19:30:40 <lambdabot>   [(0,"")]
19:30:43 <ski> > (readsPrec 0 :: ReadS Integer) "(0)"
19:30:44 <lambdabot>   [(0,"")]
19:31:03 <ski> hm
19:31:12 <ski> > (readsPrec 0 :: ReadS Rational) "0 :% 1"
19:31:13 <lambdabot>   []
19:31:16 <ski> > (readsPrec 0 :: ReadS Rational) "(0 :% 1)"
19:31:17 <lambdabot>   []
19:31:38 <ski> oh, right
19:31:41 <ski> > (readsPrec 0 :: ReadS Rational) "0 % 1"
19:31:42 <lambdabot>   [(0 % 1,"")]
19:31:55 <ski> > (readsPrec 0 :: ReadS Rational) "(0 % 1)"
19:31:56 <lambdabot>   [(0 % 1,"")]
19:31:58 <ski> > (readsPrec 10 :: ReadS Rational) "0 % 1"
19:31:59 <lambdabot>   []
19:32:01 <ski> > (readsPrec 10 :: ReadS Rational) "(0 % 1)"
19:32:02 <lambdabot>   [(0 % 1,"")]
19:33:15 <ski>   readsPrec p = readParen (p >= 7) $ \s0 -> ...
19:33:22 <ski> (for the `Ratio' case)
19:36:26 * hackagebot shelly 0.9.6 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.9.6 (GregWeber)
19:38:30 <ishkabibl> Are functions that use Type classes implmented using dynamic polymorhpism(like Java's generics) or a new function for each like C++ templates?
19:38:56 <Peaker> ishkabibl, depends on what the compiler decides.. it does both
19:39:07 <Peaker> ishkabibl, dynamic by default, but it supports specialization
19:39:11 <Peaker> (which is like C++ templates)
19:39:43 <ishkabibl> how do you invoke specialization and what exactly is it?
19:40:16 <ishkabibl> you wou create a speclization like you would a C++ speclization?
19:40:21 <Peaker> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/pragmas.html#specialize-pragma
19:40:27 <rwbarton> you write something like {-# SPECIALIZE foo :: Int -> Int #-}
19:40:39 <Peaker> ishkabibl, it basically copies the function for multiple types to make it more optimized for those types
19:40:44 <rwbarton> and then it will create a copy of foo with the Int dictionary inlined as appropriate, and hopefully call it when foo is used at type Int
19:41:22 <ishkabibl> ya; that's basicly like C++ specilzation
19:41:38 <ishkabibl> is it in the standard or is it an extension?
19:42:00 <dmwit> It is an extension.
19:42:39 <rwbarton> I would have thought it is more like how C++ templates just work in general, but maybe I don't know what "specialization" means in the context of C++
19:42:51 <ishkabibl> if they add to the standard I would like to see a syntax like (+) :: Num Int => Int -> Int -> Int
19:43:41 <rwbarton> in C++ you can give a different implementation for a specific type, right? that's not what this Haskell specialization is about
19:43:49 <Peaker> rwbarton, in C++ you can specialize templates with whatever values/types you want explicitly -- sort of ad-hoc overloading
19:43:51 <ishkabibl> rwbarton: in C++ you can write generic forms and the compiler genrates new code for each form of the generic template. you can then create a speciailzation to give you diffrent code that is better suited
19:43:58 <rwbarton> right
19:44:01 <rwbarton> that's totally different
19:44:07 <ishkabibl> no, not totally
19:44:27 <rwbarton> {-# SPECIALIZE #-} is just an optimization that the compiler takes care of for you
19:44:27 <JamesRustle> in ghc it's purely an optimization thing
19:44:39 <ishkabibl> ya
19:44:47 <rwbarton> in C++ I can make the specialized function do something different than the unspecialized version
19:44:49 <ishkabibl> in C++ it actully has major functionality
19:44:59 <ishkabibl> yep
19:45:10 <JamesRustle> in C++ I can specialize things that don't exist
19:45:17 <ishkabibl> you can add new methods and functions that only work for the specilzation
19:45:18 <rwbarton> that functionality in Haskell is more like just using type classes with default member definitions or whatever
19:45:28 <JamesRustle> template<typename T> struct Foo;
19:45:31 <tgeeky> JamesRustle: hell, I specialize in things that don't exist. You don't impress me!
19:45:36 <JamesRustle> template<> struct Foo<int> { int x; };
19:45:53 <ishkabibl> yup; you can do that
19:46:32 <ishkabibl> you can actully implment classes in C++ of which the genrlized form inherits from the speclized form o_O
19:46:39 <ishkabibl> I actully just did that the other day
19:46:55 <rwbarton> my point is when you call a templated function in C++, it effectively does the same thing as {-# SPECIALIZE #-}
19:47:10 <rwbarton> or at least that is the only implementation of templates I have heard of
19:47:13 <ishkabibl> rwbarton...sorta but the compiler does the work for you
19:47:16 <ski> ishkabibl : hm, you mean like in Simula ?
19:47:28 <JamesRustle> ishkabibl: same as with SPECIALIZE
19:47:31 <ishkabibl> ski: I don't know Simula
19:48:04 <rwbarton> oh, btw--you could also use RULES to emulate what you call specialization of templates in C++
19:48:34 <ski> ishkabibl : where you can say in a method something like `...; sub; ...' where `sub' is where the code provided in the corresponding method in the subclass will be run
19:49:03 <JamesRustle> ski: ... wait, what?
19:49:09 <ishkabibl> ski: which of my comments is this in refrence to? I'm not really understanding you
19:50:29 <ishkabibl> O, I totally missunderstood SPECIALISE in haskell; yes it is very much like template initialization in C++
19:50:53 <ishkabibl> I thought you had to reimplment it like in C++ specialzation
19:51:26 <hpaste> shergill pasted “exception handling” at http://hpaste.org/69525
19:51:50 <ishkabibl> ski: I'm still intrested in what you were talking about
19:52:10 <shergill> can anyone help me decipher that compilation error?
19:53:01 <rwbarton> shergill, it doesn't know at what type 'e' to instantiate h in the call to E.handle
19:53:02 <JamesRustle> shergill: the compiler doesn't know which exceptions you're trying to catch
19:53:12 <ishkabibl> FUCK I have to get up at 7:00
19:53:14 <rwbarton> did you mean to catch all exceptions?
19:53:16 <JamesRustle> @time ishkabibl
19:53:17 <ski> ishkabibl,JamesRustle : iirc, instead of calling `super.f(...)' somewhere in the method, the method in the superclass explicitly marks where your code in the corresponding method in the subclass will be called
19:53:22 <shergill> JamesRustle: i'd like it to catch all exceptions
19:53:24 <shergill> rwbarton: yes
19:53:33 <geekosaur> isn't that the old exceptions mechanism?  should use SomeException?
19:53:34 <JamesRustle> shergill: change it to catch SomeException
19:53:36 <rwbarton> replace "forall e. (Exception e) => e" by "SomeException"
19:53:49 <shergill> oh
19:54:01 <ski> `forall e. Exception e => e' isn't that useful ..
19:54:03 <JamesRustle> E.handle (\SomeException{} -> return d) (f x)
19:54:23 <rwbarton> "forall e. (Exception e) => e" was not a constituent of a program, just a convenient string of text :)
19:54:45 <JamesRustle> now you're thinking with regexes!
19:54:51 <ishkabibl> ski: not exactly what I meant; I'll show you what I meant
19:55:24 <shergill> ok so that works, but i'm trying to understand how i should've/could've figured this out by myself. i guess this is mentioned in the docs?
19:55:24 <ski> ishkabibl : the "you can actully implment classes in C++ of which the genrlized form inherits from the speclized form o_O" one
19:55:40 <ishkabibl> ya; I'm writting an example now to show you what I mean
19:56:13 <dmwit> shergill: The error message says exactly what's wrong and how to fix it.
19:56:43 <dmwit> shergill: Just read that "Probably fix:" line and weep. =P
19:57:15 <shergill> dmwit: i understood the error message, but couldn't figure out the 'SomeException' solution without asking. i'm wondering how i could've inferred that i needed SomeException
19:57:26 <JamesRustle> template<typename T> struct Foo : Foo<int> { ... };
19:57:31 <dmwit> aha
19:57:37 <JamesRustle> I don't find that particularly mind bending, though
19:58:00 <JamesRustle> struct Foo : Bar<Foo> { ... }; is worse
19:58:23 <dmwit> shergill: Yes, the documentation for the Exception typeclass is quite good: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception-Base.html#t:Exception
19:58:39 <dmwit> In particular, you'd look through the instances to find out what monomorphic type to fix your variable to.
19:59:21 <shergill> dmwit: yeah i'm going through it :)
19:59:32 <shergill> thanks
19:59:38 <dmwit> Good luck. =)
20:01:15 <ishkabibl> ski: what I was talking about http://pastebin.com/kR6DZgW8
20:01:20 <JamesRustle> The paste kR6DZgW8 has been copied to http://hpaste.org/69527
20:01:34 <ishkabibl> that is actully the same basic code I wrote the other day
20:02:39 <ishkabibl> I wanted a struct that I could control the size of but also optionally not have anything but just the integer. static arrays of 0 are not allowed in C++ so this is the work around
20:03:00 <ishkabibl> and conceptully it's preety strange
20:04:28 <JamesRustle> it's not that strange once you realize that templates are essentially a preprocessor feature
20:04:45 <JamesRustle> as far as the compiler is concerned, Foo<X> and Foo<Y> are unrelated
20:04:51 <ishkabibl> exactly
20:05:37 <ishkabibl> well not exactly becuase templates are a compile time feture not a pre-compile time feture
20:05:48 <ishkabibl> but that's just a techcality of wording
20:06:06 <dmwit> You just have a preprocessor built into your compiler.
20:06:10 <dmwit> That's okay, we do too.
20:06:40 <JamesRustle> ishkabibl: what's the difference?
20:07:06 <JamesRustle> the C (and C++) "preprocessor" is actually the lexer
20:07:14 <ishkabibl> no
20:07:37 <JamesRustle> yes
20:07:39 <ishkabibl> the preprocessor runs indpently of the lexer and parser; you can actully run it on ANY file
20:07:51 <ishkabibl> you could run it on an image file if you wanted to
20:07:52 <JamesRustle> that depends on how it's implemented
20:08:04 <JamesRustle> image files tend to cause lexing errors
20:08:11 <ishkabibl> nope
20:08:13 <JamesRustle> yes
20:08:22 <JamesRustle> all you need is one misplaced " or ' or /*
20:08:30 <applicative> you're both right
20:08:34 <ishkabibl> lol
20:08:54 <JamesRustle> applicative: no
20:08:59 <JamesRustle> hah!
20:09:15 <ishkabibl> the preprocessor has nothing to do with lexing; it is self contained
20:09:15 <applicative> you're right.
20:09:19 <shergill> JamesRustle: the \SomeException{} syntax you used is pretty clean. how is that equivalent to \(_ :: SomeException). i've never seen curly braces used like that before
20:09:35 <JamesRustle> shergill: it isn't
20:09:44 <JamesRustle> ishkabibl: that is obviously wrong
20:09:58 <shergill> JamesRustle: oh. hmm so what's it doing?
20:10:14 <JamesRustle> shergill: it's pattern matching
20:10:23 <JamesRustle> > (\Just{} -> 42) (Just "hello")
20:10:25 <lambdabot>   42
20:10:30 <JamesRustle> > (\Just{} -> 42) Nothing
20:10:31 <lambdabot>   *Exception: <interactive>:3:1-13: Non-exhaustive patterns in lambda
20:10:49 <ishkabibl> Jakes: how so? the preprocessor deals in chunks of text and macro names
20:10:53 <JamesRustle> shergill: it just so happens that the type SomeException only has one constructor, also called SomeException
20:10:55 <ishkabibl> James*:
20:11:02 <JamesRustle> ishkabibl: no, it doesn't
20:11:08 <coppro> How does {} work there?
20:11:13 <applicative> > (\(Just _) -> 42) (Just "hello")
20:11:14 <lambdabot>   42
20:11:18 <JamesRustle> coppro: pretty well :-)
20:11:23 <JamesRustle> it's actually record syntax
20:11:30 <JamesRustle> but the empty record works with all constructors
20:11:31 <geekosaur> all ADTs are actually record and record syntax can be used with them in pattern matching
20:11:33 <coppro> ah
20:11:37 <coppro> clever
20:11:40 <shergill> oh nice
20:11:46 <ishkabibl> james: ya it does; you could run GCC pre-proc on haskell code
20:11:56 <JamesRustle> ishkabibl: that proves nothing
20:11:57 <applicative> it's  the record version of  the more familiar one I wrote, coppro -- as I understand
20:12:21 <JamesRustle> ishkabibl: also, running gcc -E on haskell code tends to cause lexer errors
20:12:21 <geekosaur> ishkabibl, that's actually a heavily deprecated legacy feature from pre-ANSI C
20:12:59 <JamesRustle> ishkabibl: due to all the foo' identifiers
20:13:07 <geekosaur> it used to be used in all sorts of places where the pre-ANSI one *usually* worked because it was much dumber; the ANSI one is smarter and therefore more prone to mistakenly mangle what it thinks is C syntac
20:13:47 <JamesRustle> the C standard simply describes several preprocessing phases
20:13:56 <JamesRustle> it doesn't require the "preprocessor" to be a separate program
20:14:11 <JamesRustle> and if you look at those phases, they include tokenizing the input
20:14:17 <geekosaur> biut even the pre-ANSI one produced confusing results if used on source which contained what it misrecognized as comments, (char) constants, or strings
20:14:26 <ishkabibl> *breaking out standard to see if I'm wrong
20:14:43 <geekosaur> the standard *allows* what you say, for legacy reasons
20:14:49 <geekosaur> it does not *requre* it
20:14:57 <ishkabibl> yes!
20:15:01 <ishkabibl> that's my point
20:15:25 <ishkabibl> it dosn't demand that lexical anylisis be itertwind with the pre-proc
20:15:30 <JamesRustle> yes, it does
20:15:33 <geekosaur> but, that means what you say is not guaranteed to work reliably; it's just permissible for it to do so, and also permissable for it to die a falming death while trying
20:16:08 <geekosaur> the intertwining part is there but not in so many words; it's the semantics of token pasting and similar that make it effectively necessary
20:16:24 <geekosaur> and literal string concatenation
20:16:28 <JamesRustle> Lisp macros work on syntax trees; C macros work on a stream of tokens; Perl source filters work on a flat string
20:16:36 <JamesRustle> geekosaur: and recognizing macro names in the first place
20:16:44 <JamesRustle> geekosaur: and recognizing preprocessor directives
20:16:48 <JamesRustle> geekosaur: and removing comments
20:17:02 <geekosaur> all of those worked fine when it was a compltely separate pass, oddly enough
20:17:17 <geekosaur> it's only the newer ANSI features that really made it necessary to link things more tightly together
20:17:27 <JamesRustle> I wouldn't be surprised if string concatenation was a preprocessor feature
20:18:00 <ishkabibl> fuck me...I was wrong
20:18:17 <ishkabibl> the standard defines the preprecessor in terms of tokens
20:18:24 <ishkabibl> not flat text
20:18:38 <ishkabibl> section 2.4
20:18:51 <JamesRustle> #define FOO(X) ((X) + 1)
20:18:59 <JamesRustle> FOO((((((((0))))))))
20:19:17 <JamesRustle> it has to recognize parens and count them
20:19:24 <mietek> I'm reading the article about mighttpd in The Monad Reader 19.  The author says the new IO manager (in GHC 7) is single-threaded.  Is that so?
20:19:26 <JamesRustle> and skip over string literals, and remove comments
20:20:31 <geekosaur> there is also, btw, a key bit of semantics that may confuse things a bit:  nothing says the tokens used in the preprocessor are the exact same ones used by the compiler.  old /lib/cpp tokenized (a simpler tokenizer than the compiler) to identify strings/char constants, comments, macro names, etc. but did not pass that token stream on, it passed on the original text (possibly with modifications, but *not* completely reconstructed from the token
20:20:32 <geekosaur> stream)
20:20:33 <ishkabibl> ok, here is only of the compelling examples that requires lexical anylisis to be intertwined(it was mentioned eariler I belive)
20:20:53 <ishkabibl> say you have somthing like #define TEST ("did it work")
20:21:05 <geekosaur> mietek, I seem to recall the original I/O manager needed a separate thread even in single-threaded mode; the ghc7 one does not
20:21:26 <ishkabibl> then you declare a varible std::string myTEST; the lexical anyliser sees that myTEST and dosn't replace TEST with the define
20:21:38 <ishkabibl> so if you try to print myTEST you will print nothing
20:21:49 <mietek> "Since the new IO manager is single-threaded, Haskell network programs cannot realize the potential of a multi-core processor even if the +RTS -Nx command line option is specified.
20:21:50 <ishkabibl> so James is right
20:21:53 <mietek> "For our benchmark, the performance of Mighttpd 2 with the -N3 option is 15,082 queries per second, which is slower than that with -N1 (21,601). Moreover, forkProcess and +RTS -Nx cannot be used together.
20:22:01 <mietek> "This means that we cannot daemonize the network programs if +RTS -Nx is specified.
20:22:04 <ishkabibl> and I...god this hurts...am wrong
20:22:25 <JamesRustle> ishkabibl: also consider #define FOO(X) X
20:22:36 <JamesRustle> ishkabibl: FOO /* ... */ (hello world)
20:22:52 <JamesRustle> it has to macroexpand FOO there
20:23:01 <ishkabibl> yerm; that could e done by removing comments first
20:23:09 <JamesRustle> which requires lexing
20:23:47 <JamesRustle> also you'd have to remember the original locations of all tokens to expand __LINE__ correctly
20:23:51 <ishkabibl> ya and the pre-prec requires a degree of lexing
20:24:08 <JamesRustle> it's surprisingly complicated
20:24:21 <mietek> I don't understand the author's argument.  Maybe it's a translation issue.
20:24:29 <ishkabibl> yes: for somthing that's not turing complete it sure is a pain in the ass
20:24:30 <tgeeky> ls
20:24:33 <tgeeky> *sigh*
20:24:51 <tgeeky> (Windows focus change rules, sorry)
20:26:02 <ishkabibl> O in the C++11 standarrd it's in section 2.5 BTW
20:26:31 <mietek> geekosaur: again, same author, presentation about mighttpd, http://www.mew.org/~kazu/material/2011-mighttpd.pdf, page 28
20:26:39 <mietek> "New IO manager is a single kernel thread +RTS -Nx does not help to scale on multi cores +RTS -Nx is not friendly to forkProcess
20:27:43 <dmwit> Yes, Concurrent Haskell is about convenience, not performance.
20:28:25 <dmwit> When the threaded runtime was introduced, there was still a single global heap lock -- meaning only one Haskell thread could run at any given time.
20:28:34 <dmwit> I think that's been relaxed somewhat now.
20:29:16 <dmwit> But I wouldn't be surprised to hear that the IO manager still uses a single thread to do the management.
20:29:41 <mietek> dmwit: the new IO manager paper mentions thousands of threads running.
20:29:42 <dmwit> I also vaguely recall that the IO manager has recently undergone a serious revamping, so you might want to find out whether that was before or after the mighttpd benchmarks.
20:30:23 <mietek> dmwit: yes, we're talking about the revamped IO manager, introduced in GHC 7.
20:30:29 <dmwit> mietek: Don't confuse concurrency with parallelism.
20:31:09 <dmwit> Just because thousands of threads are being tracked doesn't mean thousands of threads are running in parallel.
20:31:41 <mietek> Technically, nothing is ever running in parallel. Not sure if that's where you're going.
20:31:47 <dmwit> Not true!
20:31:52 <dmwit> I have four cores.
20:32:03 <tgeeky> mike2: Concurrency is like weaving your car skillfully through a road network.  Parallelism is like weaving 8 cars through a highway.
20:32:06 <dmwit> It's certainly possible to have up to four threads really, truly running in parallel.
20:32:18 <mietek> dmwit: fair point.
20:33:02 <tgeeky> mietek: If that were true (nothing is ever parallel), then Haskell would be a totally unacceptable solution for scientific work. And that's not true.
20:33:19 <mietek> Never mind that, I was thinking about a single core.
20:33:35 <mietek> I'm trying to understand what limitations were found by the author of mighttpd.
20:34:11 <geekosaur> that forkProcess and threads don't mix well is not a surprise; the same is true of POSIX threads in C
20:34:20 <geekosaur> you need to be very careful when mixing the two
20:34:33 <dmwit> I suspect that the limitation you stated above is literally true: that at most one thread can be doing IO at any given time.
20:34:35 <mietek> But he says the solution to these limitation is to use pre-forking.
20:35:04 <mietek> (The Monad Reader 19, page 9)
20:35:43 <hpaste> ill_logic pasted “Yesod scope issue” at http://hpaste.org/69530
20:36:20 <geekosaur> ideally there would be a lock per Handle; there may still currently be a single big IO lock.  I don't know, but that would certainly cause issues for heavy-IO uses.
20:36:23 <ill_logic> Hi all. For the hpaste I just gave, I get the error: Not in scope: `b'
20:36:40 <ill_logic> If I remove the share followed by the quaziquote, the error goes away.
20:36:50 <geekosaur> separately forked children would have independent IO managers without cross-locking issues
20:36:53 <ill_logic> Other quaziquotes in Yesod seem to have no problem. What's going on here? Is there a bug in Yesod's Template Haskell code?
20:37:22 <dmwit> You could try -ddump-splices to see what it's inserting there.
20:37:32 <ill_logic> (though interestingly, it does notice that main is there, it complains if I remove it)
20:38:47 <ill_logic> Hmm, where does it dump to?
20:38:52 <ill_logic> Sorry I'll just look that one up.
20:38:55 <dmwit> stderr, probably
20:41:44 <ill_logic> Yeah I see it now; it actually had to compile first, so I had to remove b
20:58:03 <ill_logic> Interesting, it has nothing to do with Yesod.
20:58:48 <unnali> ill_logic: I was having a similar issue trying to use some TH the other day, and couldn't work it out.
20:58:49 <hpaste> ill_logic pasted “quaziquote error” at http://hpaste.org/69531
20:58:49 <applicative> ill_logic: isn't it just the usual template haskell regulations about separating modules?
20:58:53 <ill_logic> This does the same thing.
20:59:10 <unnali> applicative: I'm not familiar. What are those?
20:59:27 <ill_logic> I guess I'm unaware of said regulations. (Perhaps Yesod could point them out since they're targeting beginners)
21:00:08 <fragamus> hey what does this mean in RWH:        MonadSupply(..)
21:00:41 <ill_logic> And sadly I have to vacate this cafe.
21:00:52 <fragamus> i don't get what the (..) means
21:00:53 <ill_logic> back later
21:00:58 <applicative> unnali: http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/template-haskell.html but the second paste is strange
21:00:59 <unnali> fragamus: more context is required, but likely it means to import all the data constructors for the MonadSupply type
21:01:04 <unnali> applicative: ta.
21:01:08 <fragamus> oh ok
21:01:11 <Clint> or export
21:01:43 <unnali> fragamus: yes, or an export, as Clint says. we'd need more context!
21:02:23 <unnali> applicative: I was getting something similar trying to use fclabels, but that could well have been my own silliness. Nothing past the first splice was being considered.
21:02:42 <fragamus> well I thought it meant that but I am just continuously surprised by the syntax and I never seem to have it under control
21:05:44 <dmwit> Well, read the Report. There's no completer reference. =)
21:07:14 <unnali> fragamus: it might take a bit for you to get into the habit, like any habit.
21:08:32 <fragamus> I'm just afraid of the report.  I read a gentle introduction and it was not gentle
21:08:58 <fragamus> but i shall give it a go
21:09:10 <applicative> fragamus: in that case MonadSupply is a typeclass, MonadSupply(..), means : import the class itself together with the associated operations
21:10:59 <applicative> fragamus, if a type class has several 'methods' a, b c, you can keep one out, writing Blahclass (a,b) or whatever, (..) just means: import them all
21:11:33 * hackagebot yaml 0.7.0.3 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.7.0.3 (MichaelSnoyman)
21:11:35 * hackagebot http-conduit 1.4.1.8 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.4.1.8 (MichaelSnoyman)
21:12:02 <fragamus> yup i get it   i am reading the report now    Im scared
21:12:57 <applicative> fragamus: if you want to see *really*  complicated case, check out the rules for type families associated types etc http://www.haskell.org/haskellwiki/GHC/Type_families#Import_and_export
21:13:33 <applicative> fragamus, but the kind of case you are considering is simple
21:14:23 <applicative> fragamus: do you know that if you just import the modules (assuming they dont conflict) then do ghc -ddump-minimal-imports a.hs, it will write them out for you
21:14:41 <fragamus> oh wow
21:14:58 <applicative> this might help give you an idea of what is going on
21:15:06 <fragamus> cool
21:15:15 <applicative> they  go into a file with the ending .imports
21:25:52 <otters> @pl \x -> x == '@' || x == '!'
21:25:52 <lambdabot> liftM2 (||) ('@' ==) ('!' ==)
21:40:38 <copumpkin> :t (`elem` "@!")
21:40:39 <lambdabot> Char -> Bool
21:40:47 <copumpkin> otters: ^
21:42:08 <newsham> anyone familiar with ipv6 programming in haskell?
21:42:31 <newsham> #1) is there a simple constructor for ipv6 addr with in6addr_any?
21:42:42 <newsham> #2) is there a way to set the IPV6_IPV6ONLY socketoption?
21:43:02 <newsham> for #1 I'm doing   "SockAddrInet6 (fromIntegral 3333) 0 iN6ADDR_ANY 0"
21:43:18 <newsham> which seems a little more convoluted than it should be perhaps?
21:53:50 <newsham> ok.. so the latest "network" pkg has the option but the one I have doesnt.
22:03:34 <namoamitabuddha> let-binding can appear in (let ... in) or list-comprehension. Are they same?
22:08:31 <sayuke> Is all IO done in lockstep even if multi threading is enabled. For example, if I am reading from a large file in one thread, and spitting out to stdout from another thread, should i expect to see a performance decrease?
22:09:27 <sayuke> should specify that im using ghc
22:10:04 <dmwit> We were discussing this earlier.
22:10:15 <dmwit> I believe the IO manager only wakes up one (Haskell) thread at a time.
22:10:20 <dmwit> On Linux.
22:10:55 <sayuke> dmwit: hmmm, poopey
22:11:20 <dmwit> On Windows I think each thread that does IO makes a safe FFI call (so gets its own OS thread), and the OS does the scheduling.
22:11:55 * dmwit suddenly wonders how the IO manager and bound threads get along
22:12:12 <dmwit> ...actually, the same way the IO manager and unbound threads get along, probably.
22:12:38 <kfish> ie. the IO manager handles the blocking?
22:12:57 <dmwit> right
22:13:25 <sayuke> dmwit: hmmm maybe ill see what happens if I make my IO bound threads OS threads
22:13:29 <dmwit> That's actually kind of a shame, if true.
22:13:42 <dmwit> Since bound threads are already on a dedicated OS thread, they might as well use the OS wakeups instead of the IO manager ones.
22:15:19 <sayuke> still 25% slower with 2 threads running
22:15:32 <sayuke> 2 heavily IO bound threads mind you
22:17:58 <dmwit> sayuke: Right, as I said above, I believe the current IO manager on Linux only wakes up one thread at a time.
22:18:13 <dmwit> If you're up for it, you might look into allowing bound threads to skip the IO manager.
22:18:27 <dmwit> Dunno how hard it would be, what it would involve, what dangerous interactions that might have, etc.
22:18:33 <dmwit> Alternately, use multiple processes.
22:19:11 <sayuke> dmwit: not in the mood to work out how haskell considers shared memory right now
22:20:08 <chx> hi. i know this is kinda impossible to answer but i try :), i read an excellent article quite recently on lambda it was extremely long , very old fashioned website (no design) it was talking first operators and then how lambda is just another operator.  Rings a bell for anyone?
22:22:58 <dmwit> sayuke: What does shared memory have to do with it?
22:25:07 <Cale> chx: Sounds of questionable correctness :)
22:25:54 <Cale> (lambda binds variables, so it's kinda hard to say that it behaves quite like other operators)
22:26:31 <Cale> But I didn't read the article, so I don't know, maybe it's looking at it from another direction
22:28:27 <isson> i want to write a game in haskell . is not a good idea using haskell to write a game ?
22:29:09 <c_wraith> It's tough..  library support isn't especially good, for game-like uses.
22:31:22 <Cale> Well, depending on what sort of game you want to write, it might not be so bad.
22:33:17 <Cale> Games can be a lot of work in any language
22:34:35 <Cale> ahaha, the patch notes for this game I've been playing "Made the Fetid Pool somewhat more fetid."
22:34:37 <yitz> Cale: play is a lot of work
22:36:04 <mgsloan> right, games are a lot of work in any language.  But huge efforts have been undertaken to make for more convenient construction of games - game engines and their associated toolchains - and usually there is language specificity.
22:36:41 * hackagebot factual-api 0.3.0 - A driver for the Factual API  http://hackage.haskell.org/package/factual-api-0.3.0 (RudigerLippert)
22:36:57 <mgsloan> there are a few bindings to these game engines, though, particularly to "Ogre" I think
22:37:02 <Cale> Yeah, so if you were hoping to use the Source engine, you're probably going to have a hard time.
22:37:41 <Cale> Then again, probably making FFI bindings would be the least difficult part of the development effort for a big game of that sort.
22:38:27 <mietek> TIL: XRecordWildcards
22:38:42 <hpaste> tgeeky pasted “applicative with 2D visual combinators” at http://hpaste.org/69533
22:54:39 <dmwit> tgeeky_: I'm not sure how I feel about operators with comment dashes in them.
22:55:13 <dmwit> Though I will admit that this paste is particularly amusing.
22:56:11 <tgeeky> dmwit: I was wondering how close you can get to really making these two inter-defined :o
22:59:14 <tgeeky> it's technically correct, too, the best kind of correct
22:59:23 <tgeeky> re: the dashes not being commenty dashes
23:00:24 <tgeeky> hm. is it possible to have a typeclass which exports a function definition which can't be overridden?
23:00:45 <unnali> tgeeky: overridden by an instance?
23:00:56 <tgeeky> unnali: yes, I think that's what I'm asking.
23:01:22 <unnali> I'm guessing not. what's the use case?
23:01:47 <tgeeky> well, if the thing that you're putting in is something like -- the functions needed to test and run QuickCheck or something...
23:02:14 <tgeeky> and then you do something like --enable-tests by default
23:02:55 <tgeeky> you would have typeclasses which provide little axiom checkers attached?
23:03:00 <tgeeky> I am surely missing something here.
23:03:23 <kallisti_> tgeeky: you could hide the typeclass method but export a regular function that's equivalent.
23:06:08 <tgeeky> kallisti_: using newtype? at what cost?
23:06:22 <Cale> What paste are you talking about?
23:06:53 <Cale> "applicative with 2D visual combinators" ?
23:07:03 <dmwit> I don't think we're talking about that any more.
23:07:10 <tgeeky> Cale: oh. Not the paste I pasted already. Yeah.
23:07:24 <tgeeky> i mean, that was the origin (the silly identity law expressed two different ways at the bottom)
23:07:31 <tgeeky> but I haven't written the typeclasses in this way
23:18:53 <augur> hrmph
23:19:22 <augur> i have a module but when i import it, i get an error:   File name does not match module name: Saw: `Main' Expected: `CodeSegmenting'
23:19:56 <augur> oh i see
23:20:02 <augur> i should import after the module name
23:20:06 <augur> heh
23:20:40 <tgeeky> dmwit: also, only having access to infix functions for a typeclass seems to behave differently than I'm used to.w
23:25:02 <dmwit> tgeeky: Infix operators should be no different.
23:25:08 <dmwit> Even prefix functions are infix operators.
23:25:16 <dmwit> Or: what's different?
23:26:13 <tgeeky> dmwit: it forces you to put the operators in ( ), when normally would not think to do that
23:26:16 <tgeeky> or I wouldn't
23:27:15 <tgeeky> dmwit: see liftA, idiom_id
23:32:38 <tgeeky> dmwit: namely: this liftA l r = |\/| l |--|>| r
23:33:02 <tgeeky> is invalid, but this:
23:33:02 <tgeeky> liftA l r = (|\/|)  l |--|>| r
23:33:05 <tgeeky> works fine
23:40:04 <isson> is it diffiult writing FFI to C language ? lisp is so easy , i like it. haskell is difficult?
23:41:29 <geekosaur> hsc2hs can be a bit intricate when dealing with structs, but c2hs can deal with much of that if you prefer (especially the fork used by gtk2hs)
23:41:46 * hackagebot spatial-math 0.1.2 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.1.2 (GregHorn)
23:41:48 * hackagebot Paraiso 0.3.1.0 - a code generator for partial differential equations solvers.  http://hackage.haskell.org/package/Paraiso-0.3.1.0 (TakayukiMuranushi)
23:41:50 * hackagebot not-gloss 0.1.0 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.1.0 (GregHorn)
23:41:58 <tgeeky> lol
23:42:15 <tgeeky> is that a new one? defining your package name by negating someone else's?
23:43:45 <isson> thanks geeksosaur
23:43:46 <geekosaur> if you don;t need to deal with structs or struct pointers (or if you can make the latter opaque) it's fairly easy; just use the Haskell versions of the appropriate C types
23:44:43 <isson> hmm..~
23:45:11 <isson> thanks a ton , geeksosaur
23:45:46 <dmwit> tgeeky: That has nothing to do with typeclasses.
23:46:27 <dmwit> The former would be wrong and the latter fine if they were plain old non-typeclass functions, too.
23:46:35 <dmwit> (assuming they had the same names =)
23:46:49 <tgeeky> yes, I know, but Applicative gives you pure (not infix) and you only get an infix pure here
23:46:53 <tgeeky> (by default)
23:47:12 <tgeeky> I know it has nothing to do with typeclasses
23:47:17 <dmwit> oh, ok
23:48:09 <tgeeky> other than in the typeclasses-used-as-social-convention-builders sense
