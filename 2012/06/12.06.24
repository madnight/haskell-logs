00:03:04 <wagle> wow, thats a new one for me..  I thought I had a list of Integers when I had a list of strings..  all the operations worked the same: <, sort, etc, but I blew the first try on the test because of the difference..
00:03:16 * wagle blame haskell
00:08:15 <enko> > [(x,y) | x <- [3..1], y <- [1..3]]
00:08:16 <lambdabot>   []
00:08:33 <wagle> > "9" < "12"
00:08:34 <lambdabot>   False
00:08:39 <wagle> oops
00:09:07 <enko> > [(x,y) | x <- [1,2], y <- [1..3]]
00:09:08 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
00:09:24 <enko> > [(x,y) | x <- [1,2,3], y <- [1..3]]
00:09:25 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
00:10:00 <dmwit> > [(x,y) | x <- [1..3], y <- "abc"]
00:10:01 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
00:10:05 <yongliang> > do { x <- [1,2] ; y <- [1,2,3] ; return (x,y) }
00:10:07 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
00:10:22 <dmwit> > sequence [[1,2], [1,2,3]]
00:10:23 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3]]
00:10:45 <dmwit> > liftM2 (,) [1,2] [1,2,3]
00:10:46 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
00:11:07 <yongliang> @src liftM2
00:11:07 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:11:18 <dmwit> Look familiar? =)
00:11:22 <yongliang> Of course! :D
00:11:33 <shachaf> dmwit: Given that enko has spent the last half hour trying to look up the meaning of "<-", I expect that won't be very helpful at this point.
00:12:12 <enko> another useful contribution from shachaf
00:12:20 <yongliang> Sometimes I wish "," were just another infix data constructor.
00:12:22 <dmwit> As soon as he asks a question, I'll try to be helpful. Until then, I'll play around. =)
00:12:23 <enko> thanks for sharing
00:12:34 <dmwit> yongliang: Isn't it?
00:12:44 <shachaf> dmwit: Nope. :-(
00:12:45 <shachaf> > 1, 2
00:12:47 <lambdabot>   <no location info>: parse error on input `,'
00:12:52 <dmwit> Oh, you mean because of the extra parentheses thing?
00:12:53 <dmwit> okay
00:13:13 <dmwit> enko: Be nice.
00:14:15 <yongliang> dmwit: If "," were a regular infix data constructor, then (1,2,3) would be either (1,(2,3)) or ((1,2),3), depending on whether it is left or right associative.
00:14:22 <enko> i am, i genuinely appreciate when people try to help, without massaging their egos
00:14:36 <yongliang> enko: What exactly do you need?
00:14:44 <enko> nothing right now
00:14:48 <yongliang> Okay. :)
00:15:08 <dmwit> yongliang: Yes, I've wished that triples didn't exist before, too. =P
00:15:34 <dmwit> And 2-tuples ought to be () terminated. =)
00:15:42 <dmwit> > (1,(2,()))
00:15:43 <lambdabot>   (1,(2,()))
00:15:49 <shachaf> dmwit: And _|_ ought not to exist!
00:15:52 <yongliang> Why ()-terminated? :O
00:15:55 <dmwit> Yes!
00:16:01 <dmwit> yongliang: It's more uniform!
00:16:06 <enko> > [(x,y) | x <- [1.1..1.2], y <- [1..3]]
00:16:07 <lambdabot>   [(1.1,1),(1.1,2),(1.1,3)]
00:16:08 <shachaf> And I ought to have a pony.
00:16:09 <shachaf> In a uniform.
00:16:20 <dmwit> yongliang: You have 0-tuples, 1-tuples, 2-tuples, etc. following this pattern:
00:16:26 <shachaf> dmwit: If you want HList you know where to find it.
00:16:32 <dmwit> () (1,()) (2,(1,()))
00:16:43 <yongliang> Oh, I see.
00:16:51 <yongliang> shachaf: I see nothing wrong with _|_ as long as nontermination is the only form of bottom. But "error", "undefined" and "fail" really bug me.
00:16:57 <dmwit> yongliang: and (,) takes a value and an n-tuple and turns it into an n+1-tuple, for all non-negative n
00:16:58 <shachaf> yongliang: It's like a list except you know the length of the list and the type of each element at compile-time.
00:17:02 <shachaf> yongliang: They
00:17:07 <shachaf> 're more convenient forms of nontermination.
00:17:16 <shachaf> yongliang: fail isn't _|_ at all.
00:17:23 <dmwit> shachaf: Yes, I know. I have yet to use HList, though... usually I find a better data structure than tuples anyway. =P
00:17:31 <shachaf> yongliang: Anyway, nontermination bugs me *way* more than the others.
00:17:34 <yongliang> dmwit: Oh, makes sense.
00:17:38 <shachaf> If we could just do away with that...
00:18:02 <dmwit> shachaf: There are languages out there for you...
00:18:13 <ethercrow> does anyone use snippets in yi?
00:18:18 * hackagebot siphash 1.0.0 - siphash: a fast short input PRF  http://hackage.haskell.org/package/siphash-1.0.0 (VincentHanquez)
00:18:18 <ethercrow> assuming yi users exist
00:18:18 <shachaf> dmwit: Also I want it to be useful.
00:18:20 * hackagebot siphash 1.0.1 - siphash: a fast short input PRF  http://hackage.haskell.org/package/siphash-1.0.1 (VincentHanquez)
00:18:32 <enko> sequence [[1.1..2.1], [1,2,3]]
00:18:37 <enko> > sequence [[1.1..2.1], [1,2,3]]
00:18:38 <lambdabot>   [[1.1,1.0],[1.1,2.0],[1.1,3.0],[2.1,1.0],[2.1,2.0],[2.1,3.0]]
00:18:42 <dmwit> shachaf: Define useful. Is an FFI to Haskell enoug?
00:18:49 <shachaf> No.
00:19:09 <shachaf> I'd like the sort of language that say things like "define useful" all the time.
00:19:52 <dmwit> I don't get it. =/
00:20:01 <yongliang> enko: Sequence treats the inner lists as being lists of the same type. This is why you see the elements of [1,2,3] being "upcasted" to [1.0,2.0,3.0]. (See fromInteger)
00:20:02 <shachaf> I don't either.
00:20:07 <yongliang> s/Seq/seq/
00:20:13 <dmwit> no casts here
00:20:24 <dmwit> 1 just has the type Double (and other types, too)
00:20:31 <yongliang> dmwit: Hence "upcasted" being between quotes.
00:20:43 <shachaf> I think yongliang just "murdered" dmwit.
00:20:55 <yongliang> lolwat
00:20:56 <dmwit> ?localtime shachaf
00:20:58 <lambdabot> Local time for shachaf is Sun Jun 24 00:20:35 2012
00:21:28 <dmwit> These sound like the sort of things I say when I haven't had enough sleep. =)
00:22:45 <maybefbi> why is it ok to type newtype EitherLeft b a = EitherLeft (Either a b) ? shouldn't newtype have one field constructor?
00:23:19 <enko> thx yongliang
00:23:19 <Lemon> maybefbi, (Either a b) is one field
00:23:26 <dmwit> Yes, and it does have one field constructor.
00:23:46 <maybefbi> hmm yeah
00:23:53 <Lemon> maybefbi, newtypes are allowed to have more than one type parameter
00:24:02 <Gracenotes> not sure what you mean by field constructor? it has one "constructor" which always wraps Left or Right
00:24:16 <Gracenotes> (never bottom, which can be a useful property)
00:24:17 <dmwit> I guess he probably meant it should have a one-field  constructor.
00:24:24 <enko> i was more curious if range is created for floating points
00:24:27 <enko> guess not
00:24:34 <dmwit> enko: Sure it is.
00:24:42 <enko> > sequence [[1.1..2.1], [1,2,3]]
00:24:43 <lambdabot>   [[1.1,1.0],[1.1,2.0],[1.1,3.0],[2.1,1.0],[2.1,2.0],[2.1,3.0]]
00:24:52 <dmwit> > [1.1 .. 2.1]
00:24:53 <lambdabot>   [1.1,2.1]
00:24:59 <dmwit> > [1.1 .. 3.1]
00:25:00 <lambdabot>   [1.1,2.1,3.1]
00:25:04 <enko> ah
00:25:07 <dmwit> > [1.1, 1.2 .. 2.1]
00:25:08 <lambdabot>   [1.1,1.2,1.2999999999999998,1.3999999999999997,1.4999999999999996,1.5999999...
00:25:43 <dmwit> Although there are some fun gotchas. =)
00:26:30 <enko> precision is same in other languages
00:27:11 <dmwit> > [1.5 .. 2] -- I wasn't talking about precision.
00:27:12 <lambdabot>   [1.5,2.5]
00:27:35 <enko> !
00:28:07 <danr> > [1,3..2]
00:28:09 <lambdabot>   [1]
00:28:10 <danr> :S
00:28:14 <shachaf> > [1,3..10] :: [Double]
00:28:15 <lambdabot>   [1.0,3.0,5.0,7.0,9.0,11.0]
00:28:28 <dmwit> another good example =)
00:28:33 <danr> > [1,3..10] :: [Int]
00:28:34 <lambdabot>   [1,3,5,7,9]
00:28:36 <danr> why?! :(
00:28:42 <dmwit> > [1,3..2.0]
00:28:43 <lambdabot>   [1.0,3.0]
00:28:51 <shachaf> danr: Look at the definition of [..] in the report.
00:29:00 <dmwit> danr: It goes until it's more than halfway past the terminating value.
00:29:16 <dmwit> This choice was purportedly made to handle rounding issues.
00:29:34 <geekosaur> and equality is unreliable for floating point anyway, so it fudges
00:29:46 <shachaf> > [1,3..4.0]
00:29:48 <lambdabot>   [1.0,3.0,5.0]
00:30:30 <enko> > [1.0..3.3]
00:30:31 <lambdabot>   [1.0,2.0,3.0]
00:30:38 <enko> > [1.0..3.5]
00:30:39 <lambdabot>   [1.0,2.0,3.0,4.0]
00:30:42 <yongliang> Mmm... Using ".." in lists of floating point values is a questionable practice.
00:30:47 <enko> > [1.0..3.49]
00:30:48 <lambdabot>   [1.0,2.0,3.0]
00:30:50 <dmwit> yongliang: correct
00:31:18 <wagle> [1.1..3.9]
00:31:35 <dmwit> Best practice is to create an [Integer] and use fromInteger and division/multiplication.
00:31:38 <mparodi> or to make it more interesting:    foo = show $ fst bar;   bar = do l1 <- getLine; l2 <- getLine; return (length X, reverse X) where X = l1++l2
00:32:22 <dmwit> mparodi: That code looks buggy in a few different ways, and also unrelated to our current discussion.
00:32:28 <dmwit> Was it a mispaste or something?
00:32:50 <wagle> > [1.1..3.9]
00:32:51 <lambdabot>   [1.1,2.1,3.1,4.1]
00:32:59 <shachaf> dmwit: I can think of a way to make it compile!
00:33:05 <mparodi> dmwit, what discussion (I wasn't reading)? I know it doesn't work, as I say, but *I* need something like that
00:33:08 <yongliang> > [1.1..100.1]
00:33:09 <lambdabot>   [1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1,10.1,11.1,12.1,13.1,14.1,15.1,16.1,17....
00:33:23 <yongliang> > length [1.1..100.1]
00:33:24 <lambdabot>   100
00:33:36 <yongliang> > length [1.1..1000000.1]
00:33:37 <lambdabot>   1000000
00:33:39 <shachaf> This scrollback is about half lambdabot at this point.
00:33:47 <shachaf> Y'all know about /msg, right?
00:33:50 <dmwit> mparodi: Tough. Once you claim you're doing IO, you can't take it back.
00:33:53 <yongliang> shachaf: Oh. Sorry. :)
00:34:21 <mparodi> but it must be possible to read 2 lines and to do something with the concatenation of them!
00:34:27 <dmwit> Absolutely.
00:34:41 <shachaf> Sorry, that feature is going to be available in Haskell 2013. Preorder today!
00:34:50 <dmwit> bar = do l1 <- getLine; l2 <- getLine; let x = l1 ++ l2 in return (length x, reverse x)
00:34:50 <wagle> what's the shortest haskell program?
00:34:58 <dmwit> But that won't make foo work. =)
00:35:22 <yongliang> wagle: Maybe... main = return () :: IO ()
00:35:22 <mparodi> so you can't use whatever you return from "outside"?
00:35:25 <dmwit> wagle: main=mzero, maybe
00:35:39 <wagle> main = main
00:35:40 <dmwit> no, main=main
00:35:59 <shachaf> I think it's just an empty file, FSVO "program"
00:36:00 <dmwit> mparodi: You can't use things computed by doing IO outside of IO, no.
00:36:19 <mparodi> ok, suppose that foo is of type IO (...) as well
00:36:22 <mparodi> does it change anything?
00:36:28 <dmwit> shachaf: My value of Haskell program is at least "ghc should have exit code 0 when run on the file".
00:36:35 <shachaf> dmwit: ghci does!
00:36:36 <edwardk> dmwit: the polymorphic van laarhoven trick generalizes to other lens types
00:36:39 <dmwit> mparodi: main=foo is one character shorter than main=main =)
00:36:56 <wagle> not admitted
00:36:58 <shachaf> mparodi: You should really read an introduction to IO.
00:36:58 <yongliang> dmwit: Does it compile?
00:37:00 <shachaf> @google introduction to io
00:37:03 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
00:37:03 <lambdabot> Title: Introduction to IO - HaskellWiki
00:37:09 <mparodi> yeah, I think I should
00:37:12 <mparodi> I will now, thanks
00:37:22 <shachaf> mparodi: See also the FAQ on the wiki.
00:37:32 <shachaf> dmwit: main=main is obviously an error.
00:37:34 <dmwit> wagle: Oh, I mixed up you and mparodi. Sorry.
00:37:38 <shachaf> You trust the typecheker too much.
00:37:39 <mparodi> actually I read that part on the book The Craft of Functional Programming
00:37:43 <mparodi> but I didn't like it
00:37:50 <mparodi> I mean, it's not well explained in my opinion
00:37:54 <wagle> main = main is bottom
00:37:58 <dmwit> edwardk: Can you expand that sentence a bit?
00:38:09 <edwardk> dmwit: a -> (b, c -> d)
00:38:16 <mroman> dmwit: No @main=main
00:38:22 <dmwit> edwardk: cool
00:38:31 <dmwit> edwardk: So we can have efficient polymorphic lenses?
00:38:32 <edwardk> now make a polymorphic fstLens ;)
00:38:34 <mroman> m@main=m is shorter.
00:38:36 <edwardk> yeah
00:38:44 <edwardk> though you really want polykinds/datakinds for that
00:38:49 <edwardk> so you can make it a category
00:39:06 <wagle> mroman: nice..  i was wondering if someone could shorten it
00:39:35 <dmwit> mroman: sneaky
00:39:40 <edwardk> newtype PLens p q = PLens (Fst p -> (Fst q, Snd q -> Snd p))
00:39:48 <mroman> Every golfer knows that ;)
00:39:55 * dmwit is not a golfer
00:40:17 * dmwit -> bed
00:40:32 <maybefbi> Since Either derives Functor, does fmap apply on Left or Right or both?
00:40:32 <wagle> do bed <- dmwit
00:40:33 <edwardk> that said
00:40:40 <edwardk> i think the van laarhoven lenses work better
00:40:51 <edwardk> because you can make 'get-only' and 'set-only properties with them
00:41:04 <edwardk> where attempts to use the missing functionality fails to typecheck
00:41:36 <dmwit> maybefbi: Just look at the type and you'll know the answer.
00:41:42 <maybefbi> ok
00:41:57 <edwardk> and where you can compose getters with other lenses using only . and no conversions
00:42:48 <wagle> darn, watching edward on youtube is close to the top of my watching list
00:42:59 <wagle> dunnoo what lenses are yet
00:43:15 <maybefbi> dmwit, docs say Functor (Either a). This means fmap applies on Right instances only and does not apply to Left, correct?
00:44:29 <wagle> is there a short pithy definition of lens?  or do i need to read/watch something
00:45:13 <MostAwesomeDude> wagle: A lens is an object which provides a getter/setter for another object.
00:45:25 <MostAwesomeDude> I'm sure there's better definitions.
00:46:16 <edwardk> wagle: lenses are ways to make functional 'getters and setters'
00:46:31 <edwardk> wagle: consider get: a -> b, and set: a -> b -> a
00:46:39 <edwardk> wagle now package them up in a data type together
00:46:59 <edwardk> and you can then compose them, so you can set a field of an object pointed to by a field of an object
00:47:04 <edwardk> or get it
00:47:25 <MostAwesomeDude> You could also make modify :: (b -> b) -> a -> a
00:47:34 <MostAwesomeDude> And so forth.
00:47:47 <edwardk> maybefbi: yes
00:47:51 <wagle> ok
00:48:11 <wagle> pithy enough for me, thanks
00:48:57 <edwardk> for that matter Functor f => (b ->  f b) -> a -> f a
00:48:59 <wagle> what's pierces deal with boomerang?
00:49:04 <edwardk> which is how we get the van laarhoven lenses
00:49:08 <edwardk> largely unrelated
00:49:18 <wagle> ok
00:49:19 <edwardk> the lenses he uses there are a different beast
00:49:34 <edwardk> they neither subsume nor are subsumed by the notion of functional lens we're talking about here
00:49:42 <wagle> ahhh
00:49:49 <wagle> now it makes sense
00:49:49 <maybefbi> edwardk, thanks. sorry for this silly questions.
00:49:50 <edwardk> dmwit can go on at length about the merits of his approach
00:50:01 <maybefbi> > fmap even (Right 2)
00:50:02 <lambdabot>   Right True
00:50:06 <edwardk> but its more about 'restoring in'
00:50:25 <yongliang> > fmap even (Left "not a number")
00:50:27 <lambdabot>   Left "not a number"
00:50:28 <edwardk> the Functor for a given type is uniquely determined by the functor laws and the type signature
00:50:36 <edwardk> so there isn't anything else that fmap could do there ;)
00:50:37 <maybefbi> yongliang, thanks
00:50:43 <yongliang> :)
00:50:59 <yongliang> An Either e is very much like a Maybe, except Nothing has an attached value.
00:51:09 <yongliang> That is how I think about it, at least.
00:51:09 <maybefbi> haha true
00:51:19 <maybefbi> yeah that is one perspective
00:51:37 <edwardk> note that fail for Maybe can safely return Nothing, but fail for Either doesn't know what value to pick
00:51:42 <edwardk> so it can't fail gracefully
00:52:02 <MostAwesomeDude> But fail isn't all that fun anyway.
00:52:08 <edwardk> but then again, fail isn't really a part of what makes a monad a monad, so thats okay
00:52:16 <yongliang> maybefbi: Just as in a Maybe monad Nothing propagates, well, nothing; in an Either e monad, Left x propagates x.
00:52:25 <edwardk> but just wanted to point out there is at least one thing Maybe is better at than Either ;)
00:52:37 <wagle> fail for Either can only choose bottom..  8-p
00:52:38 <MostAwesomeDude> Maybe is a *great* monad.
00:52:44 <maybefbi> yeah to all
00:52:51 <maybefbi> thanks guys
00:53:01 <edwardk> wagle: well, i campaigned for fail s = Left (error s)
00:53:24 <shachaf> Hah.
00:53:24 <wagle> hmmm
00:53:28 <edwardk> then the [ s | Right s <- xs ] trick would work
00:53:51 <wagle> better than my flip idea
00:53:52 <shachaf> edwardk: Were you also the person who proposed data Maybe a = Nothing (forall b. b) | Just a?
00:53:58 <edwardk> no
00:54:08 <yongliang> wth is that?
00:54:11 <MostAwesomeDude> shachaf: Wait, what.
00:54:19 <edwardk> that's crazy talk, rank 2 types are a whole week or so worth of work to add to writing a compiler ;)
00:54:31 <shachaf> Fine, Nothing Void | Just a
00:54:39 <edwardk> thats not Maybe
00:54:51 <yongliang> That is an Either Void. (?)
00:54:53 <shachaf> Indeed.
00:54:57 <edwardk> (forall b. b) should be logically uninhabited
00:55:00 <shachaf> Yep.
00:55:25 <yongliang> Or maybe only inhabited by bottom.
00:55:27 * yongliang ducks.
00:55:28 <shachaf> Maybe it should be () instead.
00:55:40 <edwardk> yongliang: yes, i said logically uninhabited, not practically ;)
00:55:48 <edwardk> shachaf: the () is sound but stupid at least ;)
00:55:59 <wagle> where are existential (?) types described formally?  i got "Basic SImple Type Theory", and they avoid just that
00:56:15 <shachaf> edwardk: The idea was that you can stuff an operationally-distinguishable error into the Nothing.
00:56:30 <edwardk> shachaf: yes at the expense of every Nothing now taking up space
00:56:58 <edwardk> why not cram one into [] while you're at it =)
00:56:58 <wagle> isnt Nothing a concrete value in the heap?
00:57:00 <yongliang> Just use an Either in that case?
00:57:03 <edwardk> wagle: yes
00:57:07 <shachaf> edwardk: Sure!
00:57:13 <shachaf> wagle: Well, you only need one.
00:57:23 <wagle> ohhhhhh, right
00:57:28 <shachaf> edwardk: (I don't think this was ever brought up as a serious idea.)
00:57:36 <liyang> Like a time-travellers' convention.
00:57:43 * wagle is very rusty
00:59:58 * wagle is still wondering how to learn the type theory behind existential types etc (that forall b. b, etc)
01:00:14 <shachaf> That's not an existential type.
01:00:39 <wagle> aha..  i suspected, hence my question mark
01:00:53 <liyang> It's just a way of encoding an existential.
01:01:31 <shachaf> liyang: It's not really that either.
01:01:51 <wagle> what do i go read?
01:02:09 <shachaf> liyang: forall b. Nothing b would be.
01:02:22 <shachaf> wagle: I wish there was a good answer to that question. :-(
01:02:34 <shachaf> I think kmc wrote a nice introduction to it once?
01:02:39 <shachaf> @google mainisusuallyafunction forall
01:02:41 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
01:02:44 <shachaf> Maybe that.
01:04:24 <wagle> cool, thanks
01:05:24 <Lemon> @hoogle [a -> f a] -> f a
01:05:25 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
01:05:25 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
01:05:25 <lambdabot> Control.Monad.Trans.Cont runContT :: ContT r m a -> (a -> m r) -> m r
01:05:56 <Lemon> I'm looking for a combination of foldl and sequence
01:05:59 <wagle> oh, duhhh..  Pierce TAPL ch 24..  didnt have that book last time i wondered, i guess
01:06:06 <srhb> Oh, there's an mfix. That sounds like fun.
01:06:07 <Lemon> :t foldlM
01:06:09 <lambdabot> Not in scope: `foldlM'
01:06:19 <shachaf> @ty foldM
01:06:21 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
01:06:47 <Lemon> gah, screw it
01:07:09 <srhb> Lemon: But... It's right there. :-)
01:07:11 <Lemon> just gonna zip and curry my way through this
01:07:23 <Lemon> srhb, it's not what I'm looking for
01:07:40 <shachaf> Lemon: What's [a -> f a] -> f a supposed to be?
01:07:52 <Lemon> @hoogle (a -> b -> c -> M c) -> [a] -> [b] -> c -> M c
01:07:53 <lambdabot> Warning: Unknown type M
01:07:53 <lambdabot> No results found
01:08:02 <Lemon> @hoogle (a -> b -> c -> m c) -> [a] -> [b] -> c -> m c
01:08:03 <lambdabot> No results found
01:08:12 <shachaf> Lemon: Typing things like that into Hoogle won't get you far.
01:08:18 <shachaf> What are you actually trying to do?
01:08:26 <Lemon> well
01:08:34 <Lemon> that type should be p. explanatory for what I'm trying to do
01:09:08 <shachaf> What, [a -> f a] -> f a?
01:09:17 <Lemon> no, the last one I hoogled
01:09:30 <MostAwesomeDude> I sense zipWith.
01:09:36 <MostAwesomeDude> :t zipWithM
01:09:37 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
01:09:45 <MostAwesomeDude> :t zipWith3M
01:09:46 <shachaf> That one looks complicated enough that you might just write it yourself.
01:09:46 <lambdabot> Not in scope: `zipWith3M'
01:09:50 <MostAwesomeDude> Aw, there isn't one.
01:10:02 <shachaf> MostAwesomeDude: And if there was it wouldn't be Lemon's type.
01:10:03 <srhb> It also looks silly, becaue it does not seem like the final value depends on the lists..
01:10:21 <MostAwesomeDude> shachaf: Not quite, no.
01:10:33 <shachaf> In fact I'm still not sure how Lemon's type is supposed to be inhabited.
01:10:38 <shachaf> Well, in an interesting way.
01:11:10 <MostAwesomeDude> Yeah, I'm trying to find out where all of the c go.
01:11:21 <MostAwesomeDude> Like, did you want your result to be m [c] maybe?
01:11:29 <srhb> No, he did say fold..
01:12:09 <Lemon> zipWith f list1 list2 :: [c -> m c]
01:12:23 <b__> :t zipWithM3
01:12:24 <lambdabot> Not in scope: `zipWithM3'
01:12:29 <MostAwesomeDude> b__: There isn't one.
01:12:32 <Lemon> then, I want to "run" that list, kind of
01:12:46 <MostAwesomeDude> Well, mapM would help you with that.
01:12:49 <MostAwesomeDude> :t mapM
01:12:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:12:59 <shachaf> MostAwesomeDude: No, not really.
01:13:00 <MostAwesomeDude> Er, no, wait. Am I thinking of sequence?
01:13:09 <MostAwesomeDude> It's past my bedtime. :cx
01:13:10 <b__> zipWithM3 is in Control.Monad.ListM
01:13:12 <shachaf> MostAwesomeDude: No, [c -> m c] -> m c is uninhabited.
01:13:20 <Lemon> give it an initial c, and use the result of the monad to calcuate the next c
01:13:24 <Lemon> and finally return the last c
01:13:27 <srhb> so an iterateM
01:13:29 <srhb> ish
01:13:32 <shachaf> Oh, an initial c.
01:13:33 <Lemon> yes, exactly
01:13:39 <shachaf> @ty foldr (>=>) return
01:13:40 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
01:13:52 <Lemon> whoah
01:14:02 <Lemon> you came up with that way too quickly
01:14:08 <Lemon> :i >=>
01:14:13 <srhb> Well, it's easier once the right analogy is there :-)
01:14:16 <Lemon> :t (>=>)
01:14:18 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
01:14:30 <srhb> shachaf: Can you explain what you meant by uninhabited?
01:14:34 <shachaf> It's easier once you say what you want rather than waving "kind of"s about.
01:14:38 <Lemon> :t foldl (>=>)
01:14:40 <shachaf> srhb: Empty.
01:14:40 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m c) -> [c -> m c] -> a -> m c
01:15:05 <shachaf> srhb: I was actually wrong in the case of Monad, because of fail. But who cares about that.
01:15:16 <Lemon> :t foldr
01:15:17 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
01:15:22 <wagle> a type where nothing is of that type
01:15:26 <srhb> shachaf: I'm not sure I quite understand empty in this context either.
01:15:28 <srhb> Oh!
01:15:33 <srhb> wagle: Thanks :)
01:15:45 <wagle> i might be wrong, watch out
01:15:58 <srhb> How does such a type exist though..
01:16:07 <shachaf> srhb: Write me a function of type a -> b
01:16:19 <wagle> Error
01:16:26 <wagle> :t error
01:16:28 <lambdabot> forall a. [Char] -> a
01:16:32 <srhb> shachaf: Good point.
01:16:53 * srhb almost broke her brain there.
01:16:56 <srhb> :(
01:17:33 <wagle> error is close
01:17:45 <MostAwesomeDude> :t unsafeCoerce
01:17:46 <lambdabot> Not in scope: `unsafeCoerce'
01:17:54 <wagle> awww
01:17:56 <shachaf> wagle: When we talk about "uninhabited types" we ignore _|_
01:17:57 <MostAwesomeDude> Oho, lambdabot, you're on the ball.
01:18:49 <MostAwesomeDude> unsafeCoerce has the type a -> b, but as the name implies, what this actually *does* is pretty nebulous.
01:18:57 <wagle> shachaf: ah, good point
01:19:04 <shachaf> MostAwesomeDude: undefined also has the type a -> b
01:19:22 <MostAwesomeDude> shachaf: And doesn't have "unsafe" in the name!
01:19:30 <wagle> i think its just a
01:19:35 <MostAwesomeDude> That means it's safe, right?
01:19:40 <shachaf> @ty undefined :: a -> b
01:19:41 <wagle> :t undefined
01:19:42 <lambdabot> forall a b. a -> b
01:19:42 <lambdabot> forall a. a
01:20:02 <MostAwesomeDude> :k undefined
01:20:03 <lambdabot> Not in scope: type variable `undefined'
01:20:33 <MostAwesomeDude> Huh. So I guess undefined can have any kind? Is that how you can use it anywhere?
01:20:40 <srhb> It only needs those two really
01:20:44 <sipa> no, any type
01:20:44 <shachaf> No, it can't have any kind.
01:20:47 <shachaf> It has no kind.
01:20:54 <shachaf> It can have any type, though.
01:20:59 <wagle> :t id : a -> a
01:21:01 <lambdabot> parse error on input `->'
01:21:06 <srhb> Since a may be anything..
01:21:11 <shachaf> undefined :: Int, undefined :: Maybe (Either (Char,Bool) (b,c,d))
01:21:22 <sipa> shachaf: any type of kind * ;)
01:21:35 <shachaf> 01:20 <sipa> no, any type
01:21:52 <sipa> i stand corrected
01:21:56 <wagle> :t ($)
01:21:58 <lambdabot> forall a b. (a -> b) -> a -> b
01:22:09 <shachaf> srhb: For more on inhabited and uninhabited types see the "Curry-Howard correspondence", which is one of the niftier things about Haskell-style type systems.
01:22:19 <srhb> shachaf: Thank you :)
01:22:28 <wagle> :t id :: (a->b) ->a -> b
01:22:30 <lambdabot> forall a b. (a -> b) -> a -> b
01:23:23 <Goatflakes> so what's people thoughts on n+k patterns?
01:23:31 <srhb> Goatflakes: Good riddance. :-)
01:23:38 <wagle> its in the original haskell report
01:23:59 <wagle> therefore, by the grandmother clause, ....
01:24:36 <wagle> i thought they were goofy, but didnt see why the terror of them
01:24:59 <Goatflakes> people seem to think that it's somehow weird but seems natural when using induction over naturals to do functional reasoning
01:25:23 <liyang> If only naturals were included in the Report.
01:25:25 <shachaf> Goatflakes: It's just kind of hacky because it looks like structural induction but isn't.
01:25:26 <srhb> Goatflakes: All you need is Nat
01:25:39 <Goatflakes> hmm
01:25:45 <wagle> surreal!
01:25:52 <wagle> Surreal!
01:25:56 <wagle> (oops)
01:26:10 <Goatflakes> lol sounds like a type
01:26:34 <wagle> Surreal numbers, look them up on wikipedia
01:26:59 <srhb> @index toNat
01:26:59 <lambdabot> bzzt
01:27:47 <wagle> @index fromSurreal
01:27:47 <lambdabot> bzzt
01:27:51 <wagle> darn
01:27:55 <shachaf> @ty flip replicate ()
01:27:56 <lambdabot> Int -> [()]
01:28:01 <Goatflakes> dafaq
01:28:10 <srhb> > fromIntegral 10 :: Nat
01:28:11 <lambdabot>   Not in scope: type constructor or class `Nat'
01:28:30 <srhb> Alright, where is that data type hiding...
01:28:49 <Goatflakes> well i don't see why the rage about it. functions don't have to be total in haskell
01:29:07 <MostAwesomeDude> data Nat = Zero | Succ Nat -- here it is!
01:29:14 <shachaf> Goatflakes: Yes, Haskell is Turing-complete.
01:29:17 <srhb> MostAwesomeDude: Yeah.. :P
01:29:21 <shachaf> That doesn't mean we have to like partial functions.
01:29:25 <sepp2k> Goatflakes: They don't have to be, but generally we prefer them to be.
01:29:33 <Goatflakes> sure
01:29:37 <shachaf> type Nat = Mu Maybe
01:29:56 <Catnaroek> @src Mu
01:29:57 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
01:30:03 <Goatflakes> who decided to make my irc client always on top >.<
01:30:17 <Catnaroek> Oh, that is pretty cool.
01:30:22 <srhb> Why is it called Mu?
01:30:29 <srhb> @index Mu
01:30:30 <lambdabot> bzzt
01:30:32 <shachaf> @ let toNat 0 = Nothing; toNat n = Just (In (toNat (n-1)))
01:30:41 <srhb> Clever.
01:30:42 <shachaf> @let toNat 0 = Nothing; toNat n = Just (In (toNat (n-1)))
01:30:43 <lambdabot>  Defined.
01:30:44 <shachaf> > toNat 5
01:30:46 <lambdabot>   Just (In (Just (In (Just (In (Just (In (Just (In Nothing)))))))))
01:31:03 <srhb> > toNat (-1)
01:31:05 <lambdabot>   Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just ...
01:31:12 <Goatflakes> nice lisp
01:31:12 <srhb> But I get the point.
01:31:25 <shachaf> Fine!
01:31:26 <shachaf> @undefine
01:33:00 <shachaf> @let toNat 0 = Just Nothing; toNat n | n > 0 = (Just . In) <$> toNat (n-1) | otherwise = Nothing
01:33:02 <lambdabot>  Defined.
01:33:11 <shachaf> Better?
01:33:16 <srhb> Much :-)
01:33:26 <Catnaroek> @src In
01:33:27 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
01:33:42 <shachaf> @src InR
01:33:42 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
01:33:43 <srhb> The whole dream for dependent types I guess is really about not having to make these "smart constructors"
01:33:44 <Goatflakes> From wikipedia:"The definition and construction of the surreals is due to John Horton Conway. They were introduced in Donald Knuth's 1974 book Surreal Numbers: How Two Ex-Students Turned on to Pure Mathematics and Found Total Happiness. This book is a mathematical novelette, and is notable as one of the rare cases where a new mathematical idea was first presented in a work of fiction."
01:33:46 <Goatflakes> fail
01:33:55 <shachaf> srhb: This isn't really a "smart constructor".
01:33:58 <Goatflakes> ever herd of flatland
01:34:02 <shachaf> (But yes, that's part of it.)
01:34:08 <Catnaroek> Shouldn't 0 be Nothing, rather than Just Nothing?
01:34:10 <shachaf> Goatflakes:: "first"
01:34:11 <Goatflakes> to mock a mocking bird, etc, etc
01:34:16 <srhb> Goatflakes: That did not introduce dimensions..
01:34:19 <liyang> srhb: Greek mu is the usual way to write "least fixed point".
01:34:27 <srhb> liyang: Ah, that explains.
01:34:30 <shachaf> Catnaroek: No, invalid inputs are Nothing.
01:34:32 <Goatflakes> lol don't confuse me with facts
01:34:43 <wagle> Conway wrote ONAG in about a week or somesuch
01:34:50 * Goatflakes didn't read it properly
01:34:54 <srhb> shachaf: Why is this not a smart constructor?
01:34:58 <MostAwesomeDude> Goatflakes: What's interesting is that Conway presented surreals over about three pages at the beginning of the book.
01:35:20 <srhb> Goatflakes: You could say Poe beat him to it with his foreshadowing of black holes. or was it big Bang. Either way. :-)
01:35:21 <MostAwesomeDude> And the concept is so ridiculously deep.
01:35:21 <shachaf> srhb: It's not really a constructor at all. It's a function that converts one type to another, and might possibly fail.
01:35:45 <srhb> shachaf: Right.. I thought that basically encompassed smart constructors. Time to Google. :-)
01:35:55 <wagle> people use surreals to analyze go game endgames..  8)
01:36:00 <Catnaroek> Can a Haskell implementation be hacked into a dependently typed language? I really hate Agda's syntax.
01:36:08 <shachaf> srhb: I don't think "smart constructor" is all that well-defined.
01:36:20 <Goatflakes> is there like a good meta search for haskell? cause as someone said it is kind of ungoogleable
01:36:25 <shachaf> srhb: But the idea in general is that you have a type which isn't expressive enough to express your constraint.
01:36:26 <wagle> Catnaroek: scratch that itch!
01:36:33 <shachaf> For example, you say data Nat = Nat Integer
01:36:36 <Catnaroek> :/
01:36:45 <srhb> shachaf: Yeah
01:36:52 <shachaf> And then you don't export the data constructor Nat, you just export your own version of it.
01:37:08 <shachaf> In this case, though, we have a Nat type which *is* expressed precisely in the type system.
01:37:16 <srhb> OK, yes, that is a much clearer case.
01:37:27 <Catnaroek> wagle: I want a "normal" language for most things, but for certain very specific things, like defining containers, I would like to be able to define things like "the type of all valid indices of this array" or "the type of all valid keys in this map".
01:37:30 <shachaf> We just have a function to convert Integer (which is too big) to Nat.
01:37:42 <shachaf> And of course this function can fail, so it returns Maybe.
01:37:47 <enko> is there more efficient way of reverse [1..9] ? since [9..1] returns empty list
01:37:52 <srhb> shachaf: Yep, I see the difference. Thanks. :)
01:37:56 <srhb> enko: What?
01:38:02 <liyang> Catnaroek: perhaps SHE's the one you want.
01:38:05 <enko> > [9..1]
01:38:06 <lambdabot>   []
01:38:08 <shachaf> enko: Please don't worry about "efficient"
01:38:10 <Catnaroek> liyang: SHE?
01:38:12 <srhb> > [9,8..1]
01:38:13 <lambdabot>   [9,8,7,6,5,4,3,2,1]
01:38:33 <wagle> Catnaroek: I just got agda mode to run in my emacs a day or three ago
01:38:33 <Catnaroek> liyang: Googling SHE leads me to a Taiwanese girl group. :O
01:38:35 <shachaf> You can do [9,8..1], but seriously, don't worry about efficiency because your intuition for what's efficient is probably utterly wrong. :-)
01:38:39 <shachaf> @google she haskell
01:38:43 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
01:38:59 <srhb> Or we can just wait for Haskell to get an XDependentlyTyped. :-)
01:39:09 <Goatflakes> also i have only been looking at haskell for maybe a week on and off. and anytime i look at code in any other language it looks monstrously ugly. is that a common side effect of learning haskell? lol
01:39:09 <liyang> Catnaroek: Strathclyde Haskell Enhancement.
01:39:13 <Catnaroek> Oh.
01:39:17 <liyang> What's wrong with Agda's syntax anyway?
01:39:18 <Catnaroek> :)
01:39:38 <enko> thx, i was assuming its generating then reversing
01:39:38 <Catnaroek> I cannot quite pinpoint what I dislike.
01:39:41 <Catnaroek> But it is too... baroque.
01:39:55 <Catnaroek> Too many features for a thing that should be simple, like a language's syntax.
01:40:03 <Goatflakes> reverse [1..9]
01:40:07 <Goatflakes> :3*
01:40:15 <wagle> Catnaroek: try perl  or apl for a while, then come back
01:40:18 <srhb> Goatflakes: Yep, that's quite common.
01:41:07 <Catnaroek> wagle: I like my strong typing, thanks.
01:41:37 <wagle> i dunno enough adga to have much of an opinion...
01:41:57 <shachaf> wagle: That's never stopped anyone else in this channel.
01:42:15 <Goatflakes> yeah i have writen some scripts to stuff like an ls replacement for java too search the class path, other throwaways like that. it's punctuation overkill, but lisp is my most hated on those grounds
01:42:58 <wagle> it seems interesting, hence my trying to learn it....  might have been today, except i watched algorithms videos all day instead
01:43:13 <Goatflakes> sauce?
01:43:13 <srhb> wagle: The night is still young!
01:43:16 <srhb> (depending..)
01:43:29 <wagle> almost 2am
01:43:41 <Catnaroek> I still wonder, why do Agda folks need to use non-ASCII characters?
01:43:56 <wagle> use em or lose em
01:43:57 <Goatflakes> apl has beens?
01:44:02 <Catnaroek> lol
01:44:15 <shachaf> #not-haskell for that discussion
01:44:19 <Catnaroek> ok
01:44:40 <liyang> There is #agda.
01:44:44 <Goatflakes> speaking of apl, is haskell an array language like apl?
01:44:46 <wagle> *I* think i want non-ascii..
01:45:20 <liyang> I tried to use Unicode at work but got shot down. :(
01:45:23 <Goatflakes> in that you can do dot products, etc in a natural way without writing your own stuff
01:45:44 <wagle> havent people used non-ascii with haskell?
01:45:58 <liyang> {-# LANGUAGE UnicodeSyntax #-}
01:46:00 <shachaf> liyang: Are you using Agda?
01:46:14 <shachaf> You don't need UnicodeSyntax to use non-ASCII characters in Haskell.
01:46:26 <liyang> shachaf: not for work, but yes.
01:46:35 <shachaf> I meant at work. :-)
01:47:01 <Goatflakes> who actually uses haskell for work?
01:47:04 <liyang> shachaf: no, that's Haskell.
01:47:15 <shachaf> liyang: Well, it's something!
01:47:15 <wagle> λx.xx
01:47:53 <enko> > :t 'a'
01:47:54 <lambdabot>   <no location info>: parse error on input `:'
01:48:17 <wagle> :t 'a'
01:48:18 <lambdabot> Char
01:48:37 <enko> :t 5
01:48:38 <lambdabot> forall t. (Num t) => t
01:48:47 <Goatflakes> lol does hugs and ghci actually accept λx → x + 1
01:49:19 <enko> lambdabot> forall t. (Num t) => t huh?
01:49:34 <Goatflakes> personally i don't think \x -> x+1 looks at all bad even in print and i think using special symbols obscures more than it beautifies
01:49:51 <shachaf> enko: "huh?" isn't a very useful question.
01:50:08 <enko> no it isnt
01:50:09 <mauke> Goatflakes: no, but λx is a valid variable name
01:50:10 <shachaf> enko: The questions you've been asking lead me to think that you should really read an introduction to Haskell, though.
01:50:22 <enko> guess what i am reading
01:50:28 <wagle> my ghci spits hairballs at that
01:50:28 <enko> 1 try
01:51:06 <Goatflakes> the life and times of george washington?
01:51:44 <wagle> Zen and the Art of Motorcycle Maintenance
01:51:50 <shachaf> enko: OK, so you should go to the section about numbers and types, if you've gotten that far.
01:52:07 <shachaf> If you have a specific question that you can't figure out the answer to, you can ask in here and people might help.
01:52:21 <enko> :t True
01:52:21 <lambdabot> Bool
01:52:24 <Goatflakes> what one are you reading i bought hutton it's ok but it's loosing me on the parsers i think it's trying to introduce monads without saying the dread word itself
01:52:27 <enko> :t 1
01:52:28 <lambdabot> forall t. (Num t) => t
01:52:45 <shachaf> Goatflakes: Hutton's book is good.
01:52:50 <Goatflakes> :t \x->x+1
01:52:51 <lambdabot> forall a. (Num a) => a -> a
01:52:53 <shachaf> Goatflakes: Just read the parser chapter a few more times and you will.
01:53:09 <Goatflakes> yeah i figured i need to sit down and expand the types
01:53:12 <wagle> enko 1 can be different representations of number 1 depending on the context
01:53:30 <enko> like what?
01:53:35 <wagle> Integer, Real,
01:53:37 <mauke> > 1 :: Integer
01:53:38 <lambdabot>   1
01:53:41 <mauke> > 1 :: Double
01:53:42 <lambdabot>   1.0
01:53:43 <Goatflakes> 1::Num
01:53:46 <enko> :t 1.1
01:53:46 <mauke> > 1 :: Rational
01:53:47 <lambdabot> forall t. (Fractional t) => t
01:53:47 <lambdabot>   1 % 1
01:53:51 <Goatflakes> where Num is a shitload of types
01:53:52 <mauke> > 1 :: Complex Double
01:53:53 <lambdabot>   1.0 :+ 0.0
01:54:07 <Goatflakes> oo i can haz Complex?
01:54:09 <enko> :t 1 :: Integer
01:54:10 <lambdabot> Integer
01:54:12 <enko> ok
01:54:18 <enko> that makes sense
01:54:37 <Goatflakes> :t 1
01:54:38 <lambdabot> forall t. (Num t) => t
01:54:42 <mauke> > sqrt (-2) :: Complex Double
01:54:43 <lambdabot>   (-0.0) :+ 1.4142135623730951
01:54:47 <Goatflakes> nice
01:54:49 <wagle> it can make assumptions if you dont specify
01:55:15 <enko> :t 1f
01:55:16 <lambdabot> forall t a. (Num (a -> t), SimpleReflect.FromExpr a) => t
01:55:21 <Goatflakes> :t (-0.0) :+ 1.4142135
01:55:22 <lambdabot> forall a. (RealFloat a) => Complex a
01:55:24 <mauke> enko: no
01:55:27 <enko> :t 1.0f
01:55:28 <lambdabot> forall t a. (Fractional (a -> t), SimpleReflect.FromExpr a) => t
01:55:30 <Goatflakes> weird
01:55:37 <mauke> enko: you're misunderstanding
01:55:41 <enko> i got it
01:55:50 <mauke> that is parsed as '1 f'
01:55:51 <enko> just trying to see if elements of c are there
01:55:55 <mauke> and f is a predefined variable
01:55:59 <enko> right
01:56:18 <mauke> > '\65'  -- confusing the C people
01:56:19 <lambdabot>   'A'
01:56:28 * Goatflakes is a c person
01:56:34 <enko> > 1 :: Integer + 1 :: Double
01:56:35 <lambdabot>   <no location info>: parse error on input `::'
01:56:39 <mauke> enko: parens
01:57:11 <Goatflakes> :t Complex
01:57:12 <lambdabot> Not in scope: data constructor `Complex'
01:57:16 <Goatflakes> :t Complex a
01:57:17 <lambdabot> Not in scope: data constructor `Complex'
01:57:25 <mauke> :t Int
01:57:25 <Goatflakes> doh how does i do that
01:57:26 <lambdabot> Not in scope: data constructor `Int'
01:57:33 <mauke> do what?
01:57:45 <Goatflakes> expand a type with lambdabot
01:57:50 <mauke> ... expand?
01:57:58 <Goatflakes> :expand Complex
01:57:59 <kallisti> enko: :: annotates an entire expression. you can think of it as having really low precedence.
01:58:17 <enko> > (1 :: Integer) + (1 :: Double)
01:58:18 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
01:58:18 <lambdabot>         against inf...
01:58:43 <wagle> > fromIntegral (1 :: Integer) + (1 :: Double)
01:58:44 <lambdabot>   2.0
01:58:55 <kallisti> enko: no implicit conversion of numeric types.
01:59:02 <kallisti> fromIntegral explicitly converts.
01:59:07 <enko> gotcha
01:59:12 <enko> thank you
01:59:26 <kallisti> another important thing is that / is floating point / real division
01:59:29 <kallisti> whereas div is integer division
01:59:32 <mauke> > 2 / 3
01:59:33 <lambdabot>   0.6666666666666666
01:59:36 <mauke> > 2 `div` 3
01:59:37 <lambdabot>   0
01:59:38 <monoidal> I have a three module program, attempt to use HPC but get the report only for one file. what am I doing wrong?
01:59:39 <lambdabot> monoidal: You have 3 new messages. '/msg lambdabot @messages' to read them.
02:00:44 <Goatflakes> soo can u use (div)::Integral->Integral to make it so u can just type div? with a possible renaming of div of course
02:01:02 <Goatflakes> not `div`
02:01:04 <kallisti> Integral isn't an actual type.
02:01:09 <Goatflakes> lol watch lambda choke on that
02:01:14 <kallisti> > div 5 2
02:01:15 <lambdabot>   2
02:01:18 <kallisti> Goatflakes: div is an ordinary function
02:01:19 <Goatflakes> nope it didn't >.<
02:01:22 <wagle> :t (`div`)
02:01:24 <lambdabot> parse error on input `)'
02:01:25 <kallisti> putting ` around a function makes it an infix operator
02:01:34 <enko> :t ("jazz", 1.01, 4-1.2)
02:01:35 <lambdabot> forall t t1. (Fractional t, Fractional t1) => ([Char], t, t1)
02:01:38 <wagle> :t div
02:01:39 <lambdabot> forall a. (Integral a) => a -> a -> a
02:02:02 <Goatflakes> yes i know what i am saying is can u make your on infix operators without using `` by puting sectioning parens in the definition
02:02:04 <kallisti> arguably (`div`) should be valid syntax, even though it's pretty redundant.
02:02:09 <enko> :t fromIntegral
02:02:10 <lambdabot> forall a b. (Integral a, Num b) => a -> b
02:02:13 <kallisti> Goatflakes: yes
02:02:19 <kallisti> you dont even need the section
02:02:20 <kallisti> f $ x = f x
02:02:24 <kallisti> here's a function definition in Prelude.
02:02:45 <kallisti> ($) is the name of the function.
02:03:00 <Goatflakes> k so y are se stuck with having to put `div` when they could have made it of type (Div)::Integral a=>a->a
02:03:01 <enko> lambdabot doesnt respont to :t on msg
02:03:11 <enko> so i am spamming...
02:03:16 <kallisti> enko: use @type
02:03:26 <kallisti> that's another name for :t
02:03:35 <enko> thank you
02:03:36 <Goatflakes> erm i mean something like
02:03:46 <kallisti> Goatflakes: I don't understand the question. it is div :: Integral a => a -> a -> a
02:04:14 <wagle> isnt lambdabot a odd syntax for haskell?  diffs
02:04:46 <kallisti> it's a subset of the language, specifically Haskell expressions. it also has some non-standard modules imported by default that confuse newbies.
02:04:47 <wagle> its got a different prelude or somesuch
02:04:51 <Goatflakes> (div)::Integral a=>a->a; (div) = whateverisintegerdivion
02:05:08 <Goatflakes> so u can just do x div y
02:05:17 <kallisti> Goatflakes: the definition doesn't use the backticks.
02:05:21 <kallisti> and that's not valid syntax.
02:05:23 <kallisti> >_>
02:05:37 <wagle> > div 6 3
02:05:39 <lambdabot>   2
02:05:50 <Goatflakes> i know
02:05:54 <Goatflakes> but
02:06:04 <Goatflakes> also
02:06:05 <kallisti> Goatflakes: are you asking why you can't arbitrarily define div to be infix and parse as an infix operator?
02:06:10 <Goatflakes> yes
02:06:19 <kallisti> because that would make parsing difficult, both for the parser and for human readers.
02:06:32 <kallisti> ` consistently tells you that something is an infix operator.
02:06:47 <Goatflakes> k so all other infixes are baked in?
02:06:50 <Goatflakes> brr
02:06:50 <kallisti> whereas x div y  is ambiguous and depends on how x, y, and div were defined.
02:06:59 <Goatflakes> yes
02:07:01 <kallisti> Goatflakes: none of the infix operators are "baked in"
02:07:06 <srhb> Goatflakes: Symbolic names are infix. They are not baked in
02:07:13 <srhb> Goatflakes: &^$*&(^&$(*^ is infix
02:07:18 <srhb> etc.
02:07:19 <Goatflakes> ahh i see
02:07:31 <wagle> srhb: I've seen that one!
02:07:35 <shachaf> srhb: Well, it would be if it weren't for the (s.
02:07:37 <Goatflakes> so any symbolic name (sml throwback?) are infix?
02:07:38 <kallisti> Goatflakes: like I said in the Prelude there's a function definition that looks like this:  f $ x = f x
02:07:38 <srhb> wagle: oh dear.. :P
02:07:43 <kallisti> Goatflakes: which defines an infix operator named ($)
02:07:51 <srhb> shachaf: That's what I get for banging that row. :P
02:07:52 <kallisti> Goatflakes: yep
02:07:58 <Goatflakes> k thnx
02:08:21 * hackagebot hspec-expectations 0.3.0 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.3.0 (SimonHengel)
02:09:19 <Goatflakes> also
02:09:31 <Goatflakes> >>= is mofo ugly
02:09:34 <Goatflakes> perl ugly
02:09:48 <srhb> Goatflakes: It's a cute fish. You'll learn to love it.
02:09:53 <Goatflakes> lol
02:09:59 <kallisti> Goatflakes: basically symbolic names are infix by default, alphanumeric names are prefix.  (+) forces a symbolic name to be prefix,  `div` forces an alphanumeric name to be infix.
02:10:15 <wagle> >.< is an operator
02:10:18 <Goatflakes> thanks kallisti i got it now
02:10:19 <Goatflakes> lol
02:10:32 <Goatflakes> what about :3*
02:10:36 <kallisti> >>= looks nice to me.
02:10:38 <kallisti> 3 isn't symbolic
02:10:41 <Goatflakes> or my favorite :p
02:10:44 <Goatflakes> doh
02:10:44 <liyang> The symbolic alphabet in Haskell is too small. This is why we need Unicode.
02:10:49 <Goatflakes> lol
02:11:00 <srhb> We have unicode though, don't we
02:11:22 <wagle> > 2:3*4
02:11:22 <srhb> > let a ☭ b = "MOTHERLAND"
02:11:24 <lambdabot>   No instance for (GHC.Num.Num [t])
02:11:24 <lambdabot>    arising from a use of `e_1234' at <int...
02:11:24 <lambdabot>   can't find file: L.hs
02:11:24 <kallisti> liyang: well technically the symbolic alphabet in Haskell includes all of Unicode. but yeah, it's typically limited to ASCII because that's typically where the most conveniently typed symbols are.
02:11:28 <Goatflakes> but then all chinese characters would be infix operators, which would probably be a bad thing (maybe my mandarin is almost no existent
02:11:32 <srhb> > let a ☭ b = "MOTHERLAND" in ☭
02:11:33 <lambdabot>   <no location info>: parse error on input `
02:11:35 <srhb> Aw..
02:11:38 <Goatflakes> lol nice srhb
02:12:00 <wagle> > 2:3*4:[]
02:12:01 <lambdabot>   [2,12]
02:12:07 <wagle> there
02:12:22 <pikhq_> > let a ☭ b = "MOTHERLAND" in (☭)
02:12:23 <lambdabot>   Overlapping instances for GHC.Show.Show
02:12:23 <lambdabot>                              (t -> ...
02:12:37 <liyang> Goatflakes: hence why I like how Agda doesn't even try to make a distinction between letters and symbols.
02:12:51 <kallisti> both Haskell and Perl have complex syntax, which of course makes it abusable. I don't see this as a flaw.
02:12:52 <Goatflakes> lol search for swastika in windows character map gives !
02:13:05 <wagle> i think agda went there because of unicode
02:13:31 <Goatflakes> was going to try and define the fatherland :p
02:13:51 <enko> :t ==
02:13:52 <lambdabot> parse error on input `=='
02:14:00 <kallisti> :t (==)
02:14:01 <lambdabot> forall a. (Eq a) => a -> a -> Bool
02:14:02 <enko> :t (==)
02:14:02 <lambdabot> forall a. (Eq a) => a -> a -> Bool
02:14:19 <enko> :t (\=)
02:14:20 <lambdabot> Not in scope: `\='
02:14:21 <liyang> Having full mixfix operators is of course open to abuse, but that's really up to you.
02:14:27 <b__> :t (/=)
02:14:27 <enko> :t (/=)
02:14:28 <lambdabot> forall a. (Eq a) => a -> a -> Bool
02:14:28 <lambdabot> forall a. (Eq a) => a -> a -> Bool
02:14:37 <srhb> What is the 'M' in Mvar?
02:14:39 <srhb> MVar*
02:14:57 <liyang> srhb: Mystery.
02:15:04 <Goatflakes> y can't i type
02:15:07 <Goatflakes> wait
02:15:09 <Goatflakes> i can
02:15:11 <Goatflakes> i'm a dumbass
02:15:16 <kallisti> my guess would be mutable.
02:15:18 <wagle> Burrito
02:15:20 <kallisti> but I don't actually know.
02:15:34 <Goatflakes> mutables are teh evil
02:15:37 <wagle> that M word we cant say
02:15:38 <Goatflakes> :3
02:15:40 <b__> linduxed was close: Misery
02:15:45 <Goatflakes> lol
02:15:45 <b__> liyang*
02:16:06 <kallisti> nothing wrong with MVars
02:16:09 <srhb> :P
02:16:19 <b__> I know, just trying to sound clever
02:16:53 * Goatflakes doesn't even know how to do IO yet
02:17:23 <b__> main = getLine >>= print
02:17:42 <Goatflakes> sounds cheaty\
02:17:56 <Goatflakes> where is the IO?
02:18:01 <Goatflakes> inside of magic fish?
02:18:10 <kallisti> http://sprunge.us/NhEG?haskell
02:18:12 <kallisti> like this of course
02:19:04 <b__> yes inside of magic fish
02:19:16 <Goatflakes> nope i don't get it. i keep looking for the other param and return of type IO or whatever
02:19:29 <srhb> Goatflakes: getLine returns IO String
02:19:32 <Goatflakes> i will have to keep reading i guess
02:19:43 <Goatflakes> (IO, String)?
02:19:45 <b__> you should go play with example code
02:19:49 <srhb> Goatflakes: No, IO String
02:19:55 <srhb> Goatflakes: A String living in the IO monad.
02:20:03 <Goatflakes> o rite
02:20:08 <b__> : D
02:20:18 <kallisti> Goatflakes: in order to access the result of an IO computation you have to use >>=
02:20:19 <Goatflakes> yeah like IO a where a=String
02:20:20 <srhb> Goatflakes: Magic fish lets you unwrap the String (for a while) as long as you return something in the IO Monad again
02:20:29 <srhb> Goatflakes: Yes
02:20:36 <kallisti> (>>=) :: IO a -> (a -> IO b) -> IO b
02:20:50 <Goatflakes> k i'm going to try doing some more of it
02:20:59 <Goatflakes> thanks for your help :)
02:21:03 <kallisti> the function on the right-hand side is passed the result of the IO computation, and is required to return a new IO computation
02:21:33 <enko> is Ord similar to IComparable?
02:21:46 <kallisti> it's analogous.
02:21:51 <enko> k
02:22:08 <Goatflakes> Ord is a total ordering isn't it? is there a partial ordering?
02:22:15 <kallisti> the difference is that I believe IComparable allows you to compare 2 different types
02:22:20 <kallisti> whereas Ord is restricted to one type.
02:22:29 <kallisti> it doesn't make sense to  compare integers with strings.
02:22:35 <Catnaroek> Goatflakes: I do not think anything prevents you from leaving the ordering functions undefined in some cases.
02:22:56 <Goatflakes> ^a type that does partial ordering. i was really surprised to find that it was also a Eq
02:23:11 <Goatflakes> that was expressed badly
02:23:12 <Goatflakes> lol
02:23:21 <kallisti> Goatflakes: the Prelude says that Ord is a total ordering
02:23:24 <Goatflakes> i mean Ord is a total ordering
02:23:26 <kallisti> so it's generally expected.
02:23:33 <kallisti> but not enforced in any way.
02:23:52 <Goatflakes> it is by having == defined on it i think
02:24:00 <Goatflakes> or something
02:24:05 <kallisti> not really.
02:24:28 <enko> IComparable is Object based, not sure about how it boxes unoxes value types...
02:24:48 <edwardk> preflex: xseen roconnor
02:24:49 <preflex>  roconnor was last seen on freenode/#haskell-blah 7 days, 1 hour, 7 minutes and 54 seconds ago, saying: what do we know about church-rosser holding in the presence of eta-expansion for typed lambda-calc?
02:24:50 <edwardk> preflex: xseen roconnor_
02:24:50 <preflex>  roconnor_ was last seen on freenode/#haskell 10 hours, 56 minutes and 7 seconds ago, saying: I guess things have changed in the last 5 years
02:24:56 <wagle> MVar seems to stand for mutable var, but they dont explicitly say that..  though pretty close
02:25:01 <kallisti> enko: in GHC Haskell the only things that are unboxed end with a #
02:25:12 <kallisti> enko: so Int is a boxed integer, and Int# is unboxed.
02:25:36 <enko> so by default its all on heap?
02:25:38 <kallisti> you typically don't use the unboxed types (and GHC can unbox types as an optimization, without you having to do anything)
02:26:02 <enko> k
02:26:10 <kallisti> enko: it's however the compiler decides to allocate it. I believe GHC uses a lot of stack allocation as well as heap.
02:26:45 <Goatflakes> o i know what i was trying to say. what happens when u have a partial ordering and you compare two values that aren't ordered with respect to each other
02:26:57 <liyang> "mutable var" doesn't come close to describing what an MVar is, so I prefer to leave it a mystery.
02:26:59 <kallisti> with Ord you would be forced to throw an error
02:27:05 <enko> makes sense, like register in c++ (ignored by a lot of compilers)
02:27:06 <edwardk> wagle: MVar's are actually slightly distinct from the notion of a mutable var.
02:27:10 <kallisti> a proper partial ordering typeclass should probably return a Maybe
02:27:12 <yitz> oh, i get it. >>= is the magic fish
02:27:15 <kallisti> so that an undefined ordering returns Nothing.
02:27:17 * yitz is slow, slow today
02:27:40 <Goatflakes> lol me two trying to give up caffeine and learn haskell in the same month
02:27:42 <edwardk> wagle: if you go read the original 'Concurrent Haskell' paper, they start by defining a MutVar which is a simple mutable variable, then introduce MVars as a form of synchronized mutable variable
02:27:53 <kallisti> Goatflakes: can you read algebraic data type syntax yet?
02:27:54 <yitz> Goatflakes: ha sounds like a tough combo
02:27:59 <kallisti> or, I guess I should ask, are you familiar with Maybe?
02:28:08 <Goatflakes> maybe i could if i knew what it was
02:28:27 <kallisti> data declarations.  data Bool = True | False, for example.
02:28:32 <wagle> yeah..  the issue is what M stands for, but, *shrug*
02:28:36 <Goatflakes> o yeah just like sml
02:28:36 <kallisti> *False | True
02:28:52 <kallisti> Goatflakes: Maybe is Haskell's option type.   data Maybe a = Nothing | Just a
02:29:01 <edwardk> wagle: it is a reference to the M-structures of the dataflow language Id
02:29:02 <Goatflakes> yep
02:29:14 <wagle> edwardk: h
02:29:18 <wagle> edwardk: ah
02:29:26 <kallisti> Goatflakes: so for a partial ordering typeclass you would want to return a Maybe so that you can handle the undefined case without resorting to runtime errors.
02:29:39 <edwardk> We also have IVars floating around which reference the I-structures from that language
02:29:56 <Goatflakes> ok
02:30:02 <wagle> my poor notebook was bogging down for no reason when i tried to read the paper, so I was very brief
02:30:22 <wagle> i think i remember that now
02:30:34 <Goatflakes> papers papers give me all your papers those i can't read i will wipe my arse with
02:30:38 <Goatflakes> :p
02:30:39 <edwardk> oh wow, thats the first paper i ever saw published by nikhil from bluespec
02:30:43 <enko> > read "[1,2]"
02:30:44 <lambdabot>   *Exception: Prelude.read: no parse
02:31:01 <kallisti> Goatflakes: we do have a mechanism to catch runtime exceptions, but they can only be caught in IO, so it's preferable to use Maybe (or Either, which is Haskell's sum type)
02:31:42 <kallisti> data Either a b = Left a | Right b
02:31:56 <Goatflakes> brb need a coffee my head feels liike it is going to cave in
02:32:01 <enko> > show 7
02:32:02 <lambdabot>   "7"
02:32:06 <edwardk> TIL Arvind has a last name
02:32:10 <kallisti> Goatflakes: good, good. everything is going as planned.
02:32:17 <mauke> > read "[1,2]" :: [Int]
02:32:18 <lambdabot>   [1,2]
02:32:18 <Goatflakes> lol
02:32:22 <wagle> i hate bind's asymetry wrt Either
02:32:34 <enko> thx mauke
02:32:34 <edwardk> wagle: trust me, the alternative is _FAR_ worse
02:32:39 <kallisti> wagle: do you understand the purpose of the asymmetry?
02:32:44 <wagle> not that i have an alternative
02:32:53 <edwardk> wagle: scala managed to screw up Either to the point of nigh unrecognizability
02:32:57 <enko> > read "[1..3]" :: [Int]
02:32:58 <lambdabot>   *Exception: Prelude.read: no parse
02:33:10 <edwardk> wagle: parametricity forces the asymmetry on you
02:33:31 <edwardk> wagle: this is a good thing, there is a fundamental reason for it =0
02:34:27 <wagle> well, somedy i may still try (and fail?) to fix bind, etc, but i need to learn a bit first
02:35:16 <edwardk> knock yourself out, but there isn't a "solution" to this asymmetry
02:35:38 <wagle> sure
02:36:15 <wagle> not an obvious one
02:36:37 <edwardk> well, its precluded by parametricity
02:36:55 <edwardk> re MVars, http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.3637 is the original source of the M
02:37:54 <kallisti> wagle: any solution would involve a completely different abstraction.
02:37:55 <kallisti> the idea is that Left represents a failure case, where Right represents a success case. When a failure occurs, the entire computation stops.
02:38:02 <kallisti> it's a useful asymmetry.
02:38:06 <wagle> yeah, i think i found the A4 formatted ps file
02:40:02 <edwardk> kallisti: well, you an always take the scala 'fix' to the problem and just have to use left or right to project after every bind…. *shudder*
02:40:15 <edwardk> which of course destroys your ability to work with it polymorphically
02:40:15 <kallisti> edwardk: I'm unfamiliar with the scala fix.
02:40:21 <wagle> kallisti: yeah, i understand the definition..  its just that, when first presented with monads, I saw that they overspecified the sequentialization of computation, just like continuation did (I started in SchemeLand, then moved to HaskellLand)
02:40:30 <edwardk> kallisti: the scala Either type is a mess
02:40:46 <kallisti> one of these days I'll have to pick up scala and see what it's all about.
02:41:06 <edwardk> http://www.scala-lang.org/api/current/scala/Either.html
02:41:12 <wagle> But I was in the systems group at OGI, not the proglang group, so didnt get full training
02:41:38 <kallisti> wagle: nothing is forcing you to use monads. you're free to create your own abstractions
02:41:56 <yitz> enko: ".." notation would only work for types that also have an Enum instance, so it can't be part of the Read instance for lists.
02:42:03 <wagle> kallisti: now you are putting words in my mouth
02:42:23 <edwardk> wagle: you can always switch to comonads which do almost the exact opposite and force you into parallelism ;)
02:42:31 <wagle> heheh
02:42:43 <enko> thx yitz
02:42:51 <edwardk> in all seriousness they do
02:43:19 <wagle> maybe comonads are what i want..  i'm still working on the category theory
02:43:57 <kallisti> a common question that comes up in this channel is "How do I make this type an instance of Functor; nothing I've tried seems to be working"
02:43:59 <edwardk> frankly i don't use comonads as the overall 'structuring' component of a program, but they are really nice to have lying around as things to interact with
02:44:07 <kallisti> the solution is: don't make it an instance of Functor. create your own function.
02:44:11 <edwardk> kallisti: deriving (Functor) ;)
02:44:28 <yitz> edwardk: comain :: CoIO ()
02:44:30 <edwardk> bah, almost everything worth having is a Funtor =)
02:44:35 <edwardk> yitz: not sound
02:44:42 <yitz> right
02:44:52 <kallisti> edwardk: yeah who needs those ByteStrings. :P
02:44:53 <mauke> comain, tainer ::
02:44:59 <Goatflakes> at the coca, coca cobana
02:45:00 <liyang> Half way through the Id reference manual, and I'm still no clearer as to what I and M stand for. :(
02:45:14 <edwardk> mauke: i comaintain my packages. i sit here and cowrite documentation all day.
02:45:26 <mauke> hahaha
02:45:41 <yitz> aha i always wondered about the etymology of the word "coauthor".
02:45:45 <mauke> I cowrite de
02:45:56 <edwardk> yitz: hahahahahaha
02:46:02 <wagle> edwardk: you cowrite?  what do you do with all that ink?
02:47:12 <edwardk> well, the cococobana is just the cobana
02:48:26 <edwardk> wagle: sadly many co-structures in programming are less useful than their duals, there is a fairly fundamental reason why that goes back to the asymmetry between how many tools we have for working with values vs. tools for working with continuations
02:48:41 <wagle> i had all my crazy ideas way too early..
02:48:57 <Goatflakes> kallisti: if you use a value of Either or Maybe, what happens if you use an operation on it that is not actually supported by the value?
02:49:13 <kallisti> presumably it would be a type error.
02:49:18 <kallisti> > Just 2 + Just 2
02:49:19 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
02:49:20 <lambdabot>    arising from a use of...
02:49:20 <Goatflakes> will it be caught at compile and just not let u do it
02:49:38 <edwardk> Goatflakes: yes
02:49:41 <Goatflakes> guess so
02:49:44 <Goatflakes> ta
02:49:53 <mauke> what is yellow, linear, normed and complete?
02:49:53 <edwardk> > liftM2 (+) (Just 2) (Just 2)
02:49:54 <lambdabot>   Just 4
02:50:02 <edwardk> > (+) <$> Just 2 <*> Just 2
02:50:03 <lambdabot>   Just 4
02:50:04 <Goatflakes> a twinky?
02:50:12 <mauke> a bananach space
02:50:16 <srhb> mauke: Haha!
02:50:18 <Goatflakes> lol
02:50:19 <edwardk> hah
02:50:50 <kallisti> Goatflakes: that applies to anything with the wrong type
02:50:54 <wagle> those are Applicatives?
02:50:54 <kallisti> not just Maybe and Either.
02:51:06 <srhb> (The maths revue made this tribute music video to the Banach-Tarski paradox, http://www.youtube.com/watch?v=uFvokQUHh08 )
02:51:09 <edwardk> wagle: yes
02:51:28 <wagle> ok..  very near the top of my reading list
02:51:49 <wagle> trying to get more serious about haskell
02:52:12 <Goatflakes> yeah but say u have an Either of a and b and you use something defined on a but the value is of type b, where the something is not defined
02:52:17 <mauke> I've discovered the best anagram of "Banach-Tarski"
02:52:20 <wagle> been doing c and python and perl lately..  bleh
02:52:24 <mauke> it's "Banach-Tarski Banach-Tarski"
02:52:32 <kallisti> Goatflakes: that won't happen
02:52:49 <Goatflakes> then i don't understand it like i thought i did :p
02:52:49 <kallisti> Goatflakes: unless you do a partial pattern match
02:53:10 <kallisti> > case Right 2 of Left x -> x + 2
02:53:11 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
02:53:48 <kallisti> Goatflakes: to do anything with an Either value you have to pattern match on it, or use some function that handles the pattern matching for you.
02:53:51 <kallisti> :t either
02:53:52 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
02:53:53 <kallisti> for example either
02:54:12 <yitz> > case Right 2 of Left x -> x + 2; Right _ -> error "Oh, come on kallisti"
02:54:14 <lambdabot>   *Exception: Oh, come on kallisti
02:54:24 <wagle> edwardk: but thanks for the comonad tip, i didnt expect to find what I was looking for in that direction, but I did know final coalgebras were
02:54:56 <edwardk> was it you who was asking about lenses earlier?
02:55:00 <Goatflakes> what is a coal gerbra?
02:55:08 <edwardk> lenses are just costate comonad coalgebras ;)
02:55:18 <wagle> yeah..
02:55:30 <wagle> hahah..  ok
02:55:34 <edwardk> which is a particularly obnoxious way to explain that 'get and put act like you expect'
02:55:35 <Goatflakes> woh factor teh cos already
02:55:59 <mauke> > (cos * cos * cos) 1
02:56:00 <lambdabot>   0.15772860525099347
02:56:02 <edwardk> well, store comonad coalgebras, since many of us don't like the costate word around here
02:56:06 <wagle> too late..  they already been cosined
02:56:10 <kallisti> Goatflakes: I'd need to see a specific example of what you're talking about. Specifically how you expect to "use something defined on a"
02:56:26 <mauke> > deriv (cos * cos * cos) 1
02:56:27 <lambdabot>   -0.736943244650823
02:56:30 <mauke> > deriv (cos * cos * cos) x
02:56:31 <lambdabot>   (1 * negate (sin x) * cos x + cos x * (1 * negate (sin x))) * cos x + cos x...
02:56:34 <edwardk> > cos 0.7390851332151607
02:56:35 <lambdabot>   0.7390851332151607
02:56:46 <mauke> sadly that's not the least fixed point
02:56:53 <Goatflakes> erm like u have a maybe of Bool
02:56:57 <Goatflakes> and you test it
02:57:00 <wagle> woah, it lost no bits
02:57:01 <edwardk> yeah just the first one that AD finds =)
02:57:08 <kallisti> Goatflakes: so you use a case expression to pattern match on the Either?
02:57:15 <kallisti> er
02:57:16 <kallisti> Maybe
02:57:18 <shachaf> edwardk: Does that number have any significance other than being a fixed point of cos?
02:57:23 <Goatflakes> but it's unit or whatever
02:57:24 <edwardk> shachaf: not really
02:57:28 <kallisti> case maybeBool of Just bool -> ...; Nothing -> ...
02:57:35 <shachaf> mauke: That depends on your ordering for "least"!
02:57:41 <kallisti> Goatflakes: Maybe Bool is Maybe Bool, not Bool. you can't use boolean operators on it.
02:57:46 <shachaf> edwardk: :-(
02:57:47 <mauke> shachaf: why, it's the one used by fix
02:57:47 <Goatflakes> o
02:57:50 <Goatflakes> so
02:58:04 <Goatflakes> u don't loose type safety then like i thought u did
02:58:07 <shachaf> mauke: fix is nonsense.
02:58:15 <kallisti> Goatflakes: the fact that Maybe Bool doesn't have the type Bool prevents you from accidentally using the bool without first explicitly dealing with the Nothing case in some way.
02:58:19 <edwardk> shachaf: well it is an 'attractive' fixed point in a well defined sense ;)
02:58:22 <mauke> it's unsound and unlight
02:58:25 <kallisti> Goatflakes: right, there's no implicit conversion
02:58:30 <wagle> > 3.14159265358979323 / .7390851332151607
02:58:31 <Goatflakes> cool
02:58:32 <lambdabot>   <no location info>: parse error on input `.'
02:58:35 <Goatflakes> i get it now
02:58:40 <wagle> > 3.14159265358979323 / 0.7390851332151607
02:58:41 <lambdabot>   4.250650584626522
02:58:43 <Goatflakes> and either u got to handle both right?
02:58:46 <Goatflakes> in the same way
02:58:48 <kallisti> yes
02:58:50 <wagle> meh
02:58:51 <Goatflakes> cool
02:58:55 <kallisti> we have higher-order functions to make that more convenient.
02:59:00 <mauke> well, you have to handle them in different ways
02:59:00 <kallisti> but you can also use explicit case expressions
02:59:03 <kallisti> :t maybe
02:59:04 <Goatflakes> yep figured so
02:59:04 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:59:08 <mauke> because the two branches may have different types :-)
02:59:08 <kallisti> :t fromMaybe
02:59:09 <lambdabot> forall a. a -> Maybe a -> a
02:59:21 <Goatflakes> fk
02:59:35 <Goatflakes> . is function composition right?
02:59:35 <edwardk> http://mathworld.wolfram.com/DottieNumber.html
02:59:52 <mauke> @src (.)
02:59:52 <lambdabot> (f . g) x = f (g x)
02:59:52 <lambdabot> NB: In lambdabot,  (.) = fmap
03:00:08 <edwardk> also http://oeis.org/A003957
03:00:18 <Goatflakes> @src Complex
03:00:18 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
03:00:25 <kallisti> Goatflakes: fromMaybe is similar to ?? operator in C#. fromMaybe 2 Nothing will return 2,  fromMaybe 2 (Just 4)  will return 4
03:00:36 <shachaf> "a simple nontrivial example"
03:00:54 <Goatflakes> what is all that !a :+ !a gack?
03:00:55 <edwardk> lambdabot even knows about it
03:00:58 <edwardk> @oeis 7, 3, 9, 0, 8, 5, 1, 3, 3, 2, 1, 5, 1, 6, 0, 6
03:01:07 <lambdabot>  Decimal expansion of root of cos(x) = x.
03:01:08 <lambdabot>  [7,3,9,0,8,5,1,3,3,2,1,5,1,6,0,6,4,1,6,5,5,3,1,2,0,8,7,6,7,3,8,7,3,4,0,4,0,1...
03:01:20 <kallisti> Goatflakes: : is considered an uppercase symbol. so all constructors that are infix operators must begin with :
03:01:39 <Goatflakes> nvm u lost
03:01:43 <edwardk> Goatflakes: and the !'s say that those arguments are strict
03:01:46 <wagle> maybe i found the toddie number before with the calculator..  why it looked familier
03:01:48 <Goatflakes> orite
03:01:50 <kallisti> Goatflakes: ! is a strictness annotation, which means that the fields of the constructor is strict
03:01:53 <kallisti> *are
03:02:05 <Goatflakes> k i don't know about constructors yet
03:02:09 <kallisti> Goatflakes: constructors must start with an uppercase character.
03:02:11 <kallisti> Just is a constructor
03:02:14 <kallisti> Nothing is a constructor
03:02:27 <kallisti> :t Just True
03:02:28 <lambdabot> Maybe Bool
03:02:28 <edwardk> so Complex is needlessly restricted to only hold RealFloats and both of them are forced before putting them in the constructor
03:02:39 <shachaf> @src Complex
03:02:40 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
03:02:45 * wagle wonders what a nstructor is then
03:02:48 <edwardk> a waste of a perfectly good Functor
03:02:48 <shachaf> Oh.
03:02:58 <Goatflakes> that sounds inadvisable
03:03:07 <yitz> > let stable (x:xs@(x':_)) | x==x' = x | otherwise = stable xs; newt x = x - (x - cos x) / (1 + sin x) in stable $ iterate newt 1
03:03:08 <lambdabot>   0.7390851332151607
03:03:15 <Goatflakes> what's wrong with a complex of real?
03:03:20 <shachaf> (==) on Double, eh?
03:03:24 <Goatflakes> or even of num?
03:03:29 <kallisti> it doesn't permit you to have complex integers (aka gaussian integers)
03:04:13 <edwardk> you can also use http://hackage.haskell.org/packages/archive/ad/1.5.0.2/doc/html/Numeric-AD-Newton.html#v:fixedPoint to find it faster
03:04:31 <edwardk> or http://hackage.haskell.org/packages/archive/ad/1.5.0.2/doc/html/Numeric-AD-Halley.html#v:fixedPoint to find it faster still ;)
03:04:48 <Goatflakes> anyway y i came is that i don't understand what the "in" is doing in this code fragment. it's not in the index of hutton and googling it doesn't work obviously
03:04:52 <Goatflakes> let (y,s) = g' x
03:04:52 <Goatflakes>     (z,t) = f' y in (z,s++t)
03:04:54 <edwardk> kallisti: though that is borked by the fact that abs and signum are in Num =(
03:04:56 <shachaf> Oh, that's neat.
03:05:09 <kallisti> edwardk: ah, yeah..
03:05:12 <shachaf> > let x = 5 in x + 1
03:05:13 <lambdabot>   6
03:05:22 <kallisti> Goatflakes: in is a keyword, it's part of the let expression syntax
03:05:38 <edwardk> kallisti: you can use some types in my algebra package if you want gaussian integers though
03:05:38 <wagle> let <var> = <expr> in <expr>
03:05:46 <Goatflakes> o right i'm a tard i will just look up let
03:05:47 <kallisti> you can also have lists of variables
03:05:56 <kallisti> > let x = 2; y = 2; z = 2 in x+y+z
03:05:57 <lambdabot>   6
03:06:02 <kallisti> the ; can be substituted with newlines and indentation
03:06:20 <Goatflakes> back when i am not so ignorant :p
03:06:27 <edwardk> http://hackage.haskell.org/packages/archive/algebra/2.1.1.2/doc/html/Numeric-Algebra-Complex.html
03:07:08 * wagle has know haskell longer than all the people here (prolly), just not as well
03:07:24 <edwardk> or rather you can use http://hackage.haskell.org/packages/archive/algebra/2.1.1.2/doc/html/Numeric-Coalgebra-Trigonometric.html    so that Covector Int TrigBasis is a gaussian int
03:07:31 <yitz> edwardk: not faster. you have to look up that package, read the docs, etc. my way, you just type newton into lambdabot.
03:07:34 <Goatflakes> lol i don't need to look it up i just looked at the expression and it magically become executable
03:07:40 <edwardk> yitz: =)
03:08:07 * edwardk is a relative newcomer
03:08:11 <yitz> hehe
03:08:18 * Goatflakes is a complete fkn noob
03:08:20 <edwardk> i only found haskell in 2006 or so
03:08:22 * kallisti has been programming Haskell for about 3 years now.
03:08:42 <edwardk> it rather completely changed my life though
03:09:18 <Goatflakes> i found it last week when i was reading about parsers and there was all this functional and continuation crap and i was like wut is dis?
03:09:25 <shachaf> > fst . head . dropWhile (uncurry (/=)) . (zip <*> tail) . iterate cos $ 1
03:09:27 <lambdabot>   0.7390851332151607
03:09:28 <shachaf> yitz: Even faster!
03:09:33 <edwardk> Goatflakes: haskell makes beautiful parsing libraries
03:09:46 <yitz> shachaf++
03:09:54 <Goatflakes> so i bought compiling with continuations by appel
03:10:00 <edwardk> shachaf: your golf skills are fading. i detected spaces
03:10:12 <shachaf> edwardk: I said "faster", as in to type.
03:10:18 <shachaf> I was optimizing a different function here. :-)
03:10:21 <wagle> i tried awfully darned hard to be the person who first implemented it..  it would have been in scheme, then again in haskell..  none of this c-- stuff
03:10:48 <yitz> edwardk: shachaf's space bar is well oiled, as is his thumb
03:11:08 * shachaf can't tell whether "your thumb is well oiled" is a strange kind of insult.
03:11:23 <Goatflakes> and thought sml looked fugly and strict evaluation silly so somehow i got onto haskell
03:11:31 <Goatflakes> lol shachaf
03:11:41 <yitz> no no, only praise for shachaf
03:12:17 * kallisti spoke to a C++ programming who seemed to be unaware that in f(a, b), a and b are evaluated before the code of f is executed.
03:12:22 <kallisti> I was baffled.
03:12:29 <srhb> Goatflakes: SML looks quite like Haskell, I think :P
03:12:43 <shachaf> kallisti: Well, not if f is a macro!
03:12:44 <Goatflakes> moar blood
03:12:46 <mhitza> If uncurry has type (a -> b -> c) -> (a, b) -> c while my function has a -> a -> a -> a why does uncurry work on it producing (b, b) -> b -> b -> b ?
03:13:04 <edwardk> let c = a -> a
03:13:34 <shachaf> mhitza: The first step for understanding a thing like that is renaming things so you don't use the same name twice.
03:13:35 <edwardk> (a -> b -> a -> a) -> (a, b) -> a -> a
03:13:43 <edwardk> when you let b = a, then you get the signature you gave
03:14:01 <mhitza> it's not the  signature that's confusing me
03:14:14 <Goatflakes> kallisti: that is odd how long has he been programming c++
03:14:15 <shachaf> uncurry :: (a -> b -> c) -> (a, b) -> c; yourfunction :: (d -> d -> d -> d); uncurry yourfunction :: (e, e) -> e -> e -> e
03:14:32 <mhitza> it's that fact that uncurry as first parameter has a function with 2 arguments, and yet it accepts one with more
03:14:34 <edwardk> shachaf: off by 1
03:14:36 <kallisti> Goatflakes: not sure. probably over a year.
03:14:40 <Goatflakes> oic
03:14:54 <edwardk> mhitza: a -> b -> c is a function with one argument
03:15:02 <edwardk> mhitza: it takes a and gives you back a function b -> c
03:15:06 <shachaf> edwardk: Oh, hah. I just copied what mhitza said.
03:15:25 <Goatflakes> been programming c++ on and off since 1994
03:15:26 <edwardk> :t id (+)
03:15:27 <lambdabot> forall a. (Num a) => a -> a -> a
03:15:29 * shachaf = bad unifier :-(
03:15:42 <Goatflakes> unsound and incomplete
03:16:00 <monoidal> mhitza: you can do map (+) [2,3] to get [(2+), (3+)], while map :: (a -> b) -> [a] -> [b]; (+) :: Int -> Int -> Int
03:16:01 <edwardk> > id (+) 1 2
03:16:01 <lambdabot>   3
03:16:13 <Goatflakes> l8r
03:16:14 <edwardk> there i passed id "too many arguments"
03:16:35 <shachaf> > printf "hello %d %d" 1 2 :: String
03:16:36 <lambdabot>   "hello 1 2"
03:16:41 <monoidal> mhitza: so map (+) :: [Int] -> [Int -> Int]
03:16:56 <edwardk> but if you break it down ((id (+)) 1) 2  = ((+) 1) 2 = (1 + 2) = 3
03:17:28 <kallisti> > reverse `id` "hello"
03:17:29 <lambdabot>   "olleh"
03:17:43 <edwardk> with uncurry if you pass it a function that takes 8 arguments, it'll read off the first two, and pair them and give you back the rest as 'c' in the above
03:17:45 <mhitza> yeah monoidal, that makes sense
03:17:55 <Goatflakes> :t reverse `id` "hello"
03:17:56 <lambdabot> [Char]
03:18:02 <Goatflakes> derp
03:18:06 <Goatflakes> silly me
03:18:25 <Goatflakes> :type id
03:18:32 <Goatflakes> :t id
03:18:33 <lambdabot> forall a. a -> a
03:18:35 <wagle> watch out, lambdabot gets wierd at this point
03:18:47 <kallisti> there's nothing lambdabot specific about that code.
03:18:48 <wagle> interesting weird, but weird
03:18:57 <edwardk> Goatflakes: there you are choosing a to be (b -> c)
03:19:04 <edwardk> Goatflakes: so it becomes (b -> c) -> b -> c
03:19:26 <Goatflakes> brain refuses to parse that yet
03:19:35 <edwardk> > id reverse "hello"
03:19:36 <lambdabot>   "olleh"
03:19:39 <edwardk> is probably easier on the brain
03:19:44 <wagle> done any prolog?
03:19:45 <yitz> mhitza: here's a good simple exercise: write the built-in function (,) in terms of curry and id
03:19:52 <yitz> > (,) 5 7
03:19:53 <lambdabot>   (5,7)
03:19:53 <edwardk> :t id reverse
03:19:54 <lambdabot> forall a. [a] -> [a]
03:20:01 <Goatflakes> yes i have but i was a bad studen
03:20:02 <Goatflakes> t
03:20:03 <edwardk> (id x) = x
03:20:10 <edwardk> so id reverse = reverse
03:20:16 <kallisti> and x `f` y is just f x y
03:20:20 <Codex_> hmm, how can intersection be implemented so that you can get something else than just booleans out from the operations?
03:20:31 <srhb> how come 1,2 is not valid then, if (,) 1 2 is?
03:20:34 <kallisti> Codex_: what kind of intersection are you talking about?
03:20:37 <mhitza> yitz, curry id . id
03:20:39 <kallisti> set intersection doesn't use booleans at all.
03:20:45 <Goatflakes> yeah i know that i was just wondering what the type of the function was, not the particular application
03:20:47 <wagle> not sure where else you might see unification then, sorry
03:20:50 <edwardk> srhb: , isn't an operator. it has no fixity value, its special syntax
03:20:52 <monoidal> srhb: tuples are special; (,) is not a real operator like (+)
03:21:01 <edwardk> its lower precedence than any user definable operator
03:21:01 <Goatflakes> yeah it was there
03:21:04 <srhb> edwardk, monoidal: ah.
03:21:20 <shachaf> (1,2,3) isn't ((1,2),3) or (1,(2,3))
03:21:28 <edwardk> (a,b) isn't applying the operator , its a rule in the grammar
03:21:30 <Goatflakes> i still beat piss out of most of the other guys in my class (yes there were no girls what a surprise o.o
03:21:37 <wagle> > (,,) 1 2 3
03:21:39 <lambdabot>   (1,2,3)
03:21:51 <edwardk> > (,2,,) 1 2 3
03:21:52 <lambdabot>   Illegal tuple section: use -XTupleSections
03:21:53 <Goatflakes> but i was like the worst prolog programmer ever
03:21:55 <wagle> i suppose that had to happen
03:21:55 <edwardk> aw
03:22:01 <yitz> @type curry id . id
03:22:02 <lambdabot> forall a b. a -> b -> (a, b)
03:22:06 <kallisti> edwardk: oh... I've never seen tuple sections used like that
03:22:11 <Codex_> kallisti: my category theory book has some kind of square like T->A->K and T->B->K and then some T->K would be the intersection of A and B. But dunno how to implement it?
03:22:17 <yitz> mhitza: looks good. but you can simplify that.
03:22:25 <mhitza> yitz, curry id
03:22:29 <mhitza> noticed just now :)
03:22:39 <edwardk> kallisti: i seem to recall max bolingbroke added them at some point
03:22:39 <yitz> mhitza: \o/
03:22:43 <wagle> > {- XTupleSections -}
03:22:45 <lambdabot>   not an expression: `{- XTupleSections -}'
03:22:53 <kallisti> Codex_: no clue. I have no experience with category theory.
03:23:06 <edwardk> wagle: sadly lambdabot doesn't let you turn on extensions
03:23:20 <Goatflakes> anyway really got to go now
03:23:22 <wagle> i dont know that syntax, was just hinting
03:23:22 <kallisti> but all the "intersections" I know of in Haskell are defined on collections (lists, sets, and maps)
03:23:23 <monoidal> Codex_: that sounds like pullback; unfortunately those are hard to do without dep. types
03:23:34 <Codex_> kallisti: normal intersection like x \in (A intersect B) <=> x \in A && x \in B, will only give out booleans
03:23:47 <yitz> edwardk: actually, i'm not sure that's so sad
03:23:59 * edwardk watches monoidal pull back from defining a pullback
03:24:08 <kallisti> Codex_: hm?
03:24:22 <shachaf> Sadly lambdabot doesn't let you run arbitrary commands on its host.
03:24:31 <yitz> shachaf: right
03:24:38 <kallisti> Codex_: an element test on an intersection will give out booleans, yes.
03:24:59 <kallisti> I must be missing something.
03:25:40 <mhitza> f [1..5] = [[1,2], [1,2,3], [2,3,4], [3,4,5], [4,5]] ... Can you guys hint me on how f would be?
03:25:53 <Codex_> monoidal: well, I was planning on using the intersection to implement a pullback, so...
03:26:04 <shachaf> > subsequences [1,2,3,4]
03:26:05 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
03:26:14 <kallisti> > tails [1..5]
03:26:15 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
03:26:23 <edwardk> shachaf: nice, but thats no powerslice
03:26:24 <kallisti> er not quite :P
03:26:24 <shachaf> Something similar to that, except I'm not sure what your criterion here is.
03:26:38 <shachaf> Oh, I see, it's adjacent elements.
03:26:44 <wagle> windows [1..5]
03:27:07 <shachaf> ms-dos [1..5]
03:27:24 <roconnor_> I have new set of lens laws:  (lens %= id) === id and (lens %= f) . (lens %= g) === lens %= (f . g)
03:27:49 <wagle> this a homework question?
03:27:59 <yitz> roconnor_: that sounds vaguely familiar
03:28:04 <mhitza> wagle,  are you asking me
03:28:06 <mhitza> ?
03:28:11 <wagle> sure
03:28:16 <wagle> yeah
03:28:39 <mhitza> no, I have a set of posts and this is how I want to group them for pagination, haha
03:29:07 <edwardk> > fmap (init . tails) (inits [1,2,3])
03:29:09 <lambdabot>   [[],[[1]],[[1,2],[2]],[[1,2,3],[2,3],[3]]]
03:29:09 <shachaf> roconnor_: Sounds like the functor laws.
03:29:21 <roconnor_> shachaf: hmm
03:29:33 <wagle> take 3 [1..5]
03:29:33 <edwardk> > fmap (tail . inits) (tails [1,2,3])
03:29:35 <lambdabot>   [[[1],[1,2],[1,2,3]],[[2],[2,3]],[[3]],[]]
03:29:53 <edwardk> roconnor_: heya
03:30:07 <edwardk> was playing with those van laarhoven lenses
03:30:29 <edwardk> the store ones generalize the same way
03:30:45 <wagle> > take 3 [1..5]
03:30:47 <lambdabot>   [1,2,3]
03:30:47 <roconnor_> I couldn't figure out how to make the store version into a category
03:30:59 <edwardk> polykinds/datakinds ;)
03:31:00 <wagle> drop 3 [1..5]
03:31:05 * roconnor_ sighs
03:31:05 <edwardk> use (*,*) indexes
03:31:20 <wagle> bleh..  i'm too tired
03:31:26 <edwardk> you can't make the van laarhoven ones into a category proper either, they just embed nicely into the existing category for hask
03:31:34 <roconnor_> yes
03:31:49 <roconnor_> does scala have polykinds/datakinds?
03:32:01 <edwardk> not as such, no
03:32:20 <edwardk> in fact you can't write anything remotely polykinded in scala
03:32:28 <edwardk> Any/Nothing have magic polymorphic kinds though
03:33:20 <edwardk> but the need to comply with a fixed 'Category' class in scala is also missing
03:33:38 <edwardk> there the indexed store version is better
03:34:01 <roconnor_> ah
03:34:15 <roconnor_> I figured indexed stores would appear somehow
03:34:21 <edwardk> Using: data Store c d b = Store (d -> b) c
03:34:29 <edwardk> newtype DataLens a b c d = DataLens (a -> Store c d b)
03:34:39 <roconnor_> edwardk: time to make a new lens library
03:34:44 <edwardk> lens :: PolyLens a b c d -> DataLens a b c d; lens l = DataLens (l (Store id))
03:34:55 <edwardk> lets you convert to a indexed data-lens
03:35:07 <edwardk> poly :: DataLens a b c d -> PolyLens a b c d; poly (DataLens l) f a = case l a of Store db c -> db <$> f c
03:35:12 <edwardk> lets you convert back
03:35:21 <edwardk> where type PolyLens a b c d = forall f. Functor f => (c -> f d) -> a -> f b
03:35:27 <roconnor_> yep
03:35:32 <roconnor_> needs rank-2
03:35:40 <edwardk> only to state in full generality
03:35:48 <roconnor_> oh right
03:35:50 <edwardk> you can of course limit it to just Store =)
03:35:51 <roconnor_> hmm
03:35:58 <roconnor_> convienent
03:36:04 <edwardk> but those may not compose
03:36:23 <Goatflakes> o herro
03:36:30 <roconnor_> one you have in into Store, you have it refied enough to do whatever you want with it.
03:36:36 <Goatflakes> i am back to ask more annoying questions
03:36:38 <edwardk> yep
03:36:50 <edwardk> but if you want to exploit the existing . its trickier
03:37:04 <edwardk> i was playing around with ways to try to embed law-breaking getters and setters into the mix
03:37:13 <roconnor_> boo
03:37:16 <edwardk> getters work but setters dont
03:37:26 <edwardk> rather setters work but you can only use them last
03:37:31 <Goatflakes> first of which is are all parsers written with bind or do in haskell recursive descent parsers?
03:37:48 <edwardk> Goatflakes: no, there are some that are Applicative only
03:37:58 <edwardk> Goatflakes: and some that use Arrows
03:38:47 <Goatflakes> yes but they are still recursive descent parsers technically, as opposed to LALR or other more general parsers afaik
03:39:30 <Goatflakes> omg hold that though needed again brb
03:39:39 <Goatflakes> ^hold that thought
03:39:56 <Codex_> good that I asked about the intersection question -- immediately figured out how to do it -- just need to rely on the functions throwing exception if it's not possible to do the mapping. :)
03:40:07 <edwardk> anyways, if you restrict the VL lens to Store you can't . it
03:40:09 <nand`> Have any attempts been made to compile Haskell to the JVM, sort of like how UHC can translate Haskell to JavaScript?
03:40:31 <edwardk> nand`: at work we have a language much like haskell that runs on the jvm
03:40:44 <nand`> edwardk: Scala or something entirely different?
03:41:14 <edwardk> nand`: no, its called ermine, basically haskell with row-types, polymorphic kinds, rank-n-types, and some syntactic differences
03:41:32 <samrat> vim users, what do you use for haskell(indentation and such). i've got vim-haskell and haskellmode installed but it seems inconsistent with that of LYAH
03:41:47 <shachaf> samrat: set autoindent is plenty
03:41:56 <Goatflakes> lol
03:42:05 <edwardk> nand`: it was largely written in reaction to having to code in scala all day ;)
03:42:09 <Goatflakes> the power and convienience
03:42:09 <shachaf> samrat: If you're learning Haskell you shouldn't worry about getting your editor perfectly smart about it. Just do it yourself, there'll be more interesting things to focus on.
03:42:13 <nand`> samrat: I use the following script: http://paste.lugons.org/show/2535/
03:42:24 <nand`> edwardk: is it ready for general use yet? I'm very interested in being able to code for the JVM
03:42:37 <roconnor_> edwardk: one neat thing about these van Laarhoven lenses is that you can make "read-only" field accessors by providing a value of type ((b -> Const b b') -> a -> Const b a').
03:42:38 <nand`> any links?
03:42:39 <companion_cube> edwardk: isn't there already Frege?
03:42:41 <edwardk> nand`: we're slowly working on management to let us open source the core of it
03:42:45 <nand`> oh
03:42:53 <nand`> ew
03:42:57 <Goatflakes> lol
03:42:58 <nand`> nothing worse than a proprietary language :(
03:43:05 <roconnor_> edwardk: these read only field accessors compose and automatically convert other field accessors into read-only ones
03:43:06 <srhb> How is the type ∀X. X. expressed in Haskell?
03:43:13 <nand`> forall x. x
03:43:15 <edwardk> roconnor_: that was the stuff i was talking about above when you said 'Boo"
03:43:16 <srhb> (Not sure I understand that syntax)
03:43:17 <roconnor_> srhb: data Void =
03:43:19 <srhb> Ah, that simple
03:43:28 * hackagebot sodium 0.5.0.1 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.5.0.1 (StephenBlackheath)
03:43:31 * hackagebot mmap 0.5.8 - Memory mapped files for POSIX and Windows  http://hackage.haskell.org/package/mmap-0.5.8 (GracjanPolak)
03:43:34 <nand`> you can also use ∀x. x  if you have -XUnicodeSyntax
03:43:38 <shachaf> srhb: Well, or (forall x. x)
03:43:46 <roconnor_> edwardk: oh, that's not what I think of when I think of law-breaking lenses
03:43:46 <edwardk> nand`: its a pretty good fit to our domain
03:44:08 <shachaf> srhb: "data Void" is actually not Haskell 98, but you can say "newtype Void = Void Void" instead.
03:44:09 <roconnor_> or is it just "data Void"
03:44:21 <nand`> it's just “data Void” iirc
03:44:23 <roconnor_> ah
03:44:27 <edwardk> you can even give them a more liberal type signature
03:44:33 <nand`> but you don't need data Void to express a type of forall x. x
03:44:38 <edwardk> forall r. (c -> r) -> a -> r
03:44:42 <nand`> > let foo :: forall x. x; foo = foo in ()
03:44:43 <lambdabot>   ()
03:44:45 <edwardk> and they'll still compose
03:44:52 <edwardk> but they do funny things when 'set' then
03:45:08 <edwardk> %= becomes an 'asks' like combinator
03:45:11 <roconnor_> edwardk: With my version you get a type error when used with set
03:45:15 <edwardk> yes
03:45:16 <nand`> :t fix id -- for that matter
03:45:17 <lambdabot> forall a. a
03:45:18 <edwardk> i have both versions here
03:45:29 <samrat> shachaf: I just find it convenient if it at least auto indented it.
03:45:32 <edwardk> i just thought i'd mention the overlap
03:45:38 <roconnor_> getting a type error seems reasonly when you try to write to a read-only lens
03:45:48 <shachaf> samrat: You can't autoindent Haskell because indentation is meaningfully part of the syntax.
03:46:00 <samrat> shachaf: and just `set autoindent` doesn't do the job
03:46:01 <shachaf> You can make guesses, but "set autoindent" in vim is good enough.
03:46:05 <edwardk> sadly you can't do 'write-only' lenses as well
03:46:05 <roconnor_> edwardk: Can you explain again what you other version is?
03:46:52 <edwardk> just forall r. (c -> r) -> a -> r
03:47:18 <nand`> is there any paper on what exactly lenses are, what they're useful for and how they work? all this talk about lenses has gotten me interested but I've never really looked at them before
03:47:43 <shachaf> @google stackoverflow lenses edward kmett
03:47:44 <lambdabot> http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
03:47:45 <lambdabot> Title: haskell - lenses, fclabels, data-accessor - which library for structure access a ...
03:47:53 <shachaf> That was a good introduction, I think.
03:48:07 <nand`> oh
03:48:08 <nand`> neat
03:48:16 <nand`> yeah, the type signature alone is a pretty good indicator
03:48:18 <shachaf> edwardk: In fact you should take that thing and put it on some other page!
03:48:21 <samrat> shachaf: i've been programming in python for a while, so i think i know what you mean. just wanted to configure so i don't have to worry about spaces and tabs
03:48:27 <roconnor_> edwardk: that type doesn't look compatible with ^. or %=
03:48:28 <shachaf> samrat: Oh.
03:48:31 <edwardk> i do kind of like the fact that if Lens a b and PolyLens a b c d are both type aliases then they are composable directly
03:48:39 <shachaf> samrat: set expandtab smarttab sw=4
03:48:57 <shachaf> samrat: Never use tabs anywhere. Simple rule of thumb.
03:49:21 <roconnor_> oh wait maybe
03:49:24 <edwardk> roconnor_: works fine (^.) :: a -> ((c -> Const c d) -> a -> Const c b) -> c   let r = Const c d = Const c b
03:49:40 <roconnor_> so then d = b?
03:49:43 <edwardk> yeah
03:49:52 <roconnor_> that seems weird
03:50:12 <edwardk> makes them easy to implement though
03:50:21 <roconnor_> d and b are in different categories in my head :)
03:50:37 <edwardk> was playing around with these from a completely operational perspective earlier
03:50:43 <roconnor_> :)
03:51:27 <nand`> thanks, the link cleared things up
03:51:44 <mhitza> so I've managed to write this http://hpaste.org/70370 but I'm wondering if there is a cleaner way to write it; or some combinator that I may not be aware of
03:51:55 <roconnor_> edwardk: I see
03:52:00 <roconnor_> edwardk: %= becomes composition
03:52:04 <edwardk> yep
03:52:16 <roconnor_> and ^= is const I guess
03:52:50 <roconnor_> I like the version with a type error better :D
03:52:55 <edwardk> me too
03:52:59 <edwardk> just thought it was interesting
03:53:03 <roconnor_> indeed
03:53:15 <samrat> shachaf: that takes care of turning tabs to spaces but it still doesnt autoindent
03:53:17 <edwardk> traverseL f = f id
03:53:21 <edwardk> is also a nice operator on these
03:53:31 <edwardk> can 'suck' a functor out through a polymorphic lens
03:53:42 <edwardk> try it on (fstL . fstL) or something
03:53:45 <nand`> samrat: did you check out my paste?
03:54:01 <shachaf> samrat: It'll "autoindent" to the same level as the previous line.
03:54:09 <edwardk> basically it exploits the strength-like property used by set
03:54:14 <roconnor_> edwardk: where f is a read-only lens?
03:54:22 <edwardk> no, a normal lens
03:54:30 <roconnor_> ah
03:54:36 <nand`> “read only lens” <- does this mean a lens where the setter is const?
03:54:41 <nand`> (or flip const or whatever)
03:54:45 <roconnor_> I suck at unification in my head
03:55:02 <edwardk> nand`: no, in this setting its a lens where you can only use it for getting but get a type error when you try to use the setter
03:55:04 <samrat> shachaf: what if i want it to autoindent automatically to another level, say for guards
03:55:09 <nand`> edwardk: I see
03:55:12 <roconnor_> (f a, b) -> f (a, b)
03:55:21 <samrat> nand`: I'll try that now
03:55:27 <edwardk> roconnor_: yes, but it also works on compositions of lenses =)
03:55:34 <edwardk> so it can suck it through multiple levels
03:55:53 <shachaf> samrat: Guards don't mean that you want to autoindent to another level.
03:55:55 <roconnor_> is that useful?
03:56:01 <roconnor_> ah
03:56:05 <edwardk> yes
03:56:06 <roconnor_> I see why you call it traverse
03:56:11 <edwardk> =)
03:57:07 <roconnor_> so much low hanging fruit
03:57:12 <edwardk> yeah
03:57:19 <wagle> thanks..  when i tried editing haskell earlier, i got an insane indenter in emacs
03:57:34 <roconnor_> I can beleive no one did this 15 years ago.
03:57:37 <wagle> now you prompted me to go back and try the other two
03:58:14 <samrat> shachaf: this is getting really confusing. are there any dotfiles that you'd suggest I take a look at?
03:58:39 <roconnor_> well there were a few hints with Compos
03:59:14 <shachaf> samrat: This .vimrc is more than sufficient for writing Haskell code: http://slbkbs.org/vimrc.txt
03:59:22 <roconnor_> cloudy hints
03:59:28 <edwardk> its nice
03:59:41 <edwardk> the type signatures with these will be _awful_ though
04:00:33 <wagle> any emacs haskellers out there?  what do you use?
04:00:41 <roconnor_> ya
04:01:07 <roconnor_> perhaps with enough type aliasing?
04:01:28 <edwardk> the type aliases don't really help the errors much
04:01:33 <roconnor_> :(
04:01:34 <edwardk> but they do help you reason about the code
04:01:35 <srhb> wagle: haskell-mode
04:02:02 <nand`> shachaf: can you explain what the lines after “syntax enable” do?
04:02:03 <shachaf> Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:2.0b6) Gecko/2009030814  Firefox/3.0.7 '"; AND DROP TABLE users --
04:02:04 <edwardk> hrmm while contorting my code, i broke my fstGetter
04:02:07 <edwardk> do you have it handy?
04:02:58 <roconnor_> as in fstGetter = fstLens ?
04:03:03 <edwardk> yeah
04:03:18 <edwardk> looking for a definition that can't be used as a lens
04:04:00 <roconnor_> fstGetter :: ((a -> Const a a') -> (a,b) -> Const a (a',b))
04:04:04 <roconnor_> fstGetter = fstLens
04:04:14 <nand`> roconnor_: “Const”?
04:04:18 <edwardk> well, what i mean is i was looking for a way to make the body if it do less work
04:04:22 <edwardk> i had it
04:04:25 <edwardk> then i broke it =)
04:04:29 <roconnor_> Const is the constant functor
04:04:30 <wagle> i used to have an emacs haskell mode that was close to but not perfect..  and they seem to degrade with time
04:04:37 <roconnor_> edwardk: ghc -O2 :P
04:04:40 <edwardk> =P
04:04:53 <shachaf> nand`: :help can probably explain it better than I can.
04:05:22 <wagle> this one ddemand tyou select one of three..  and two are totally insane, and one is half insane
04:05:30 <roconnor_> fstGetter f (a,b) = Const . getConst $ f a I think
04:05:46 <shachaf> Const . getConst?
04:05:55 <roconnor_> shachaf: it's a Const typecast :D
04:05:56 <shachaf> Oh, to change the type?
04:05:58 <shachaf> Right.
04:05:59 <edwardk> thats about right
04:06:48 <nand`> what's the Const functor used for? Just type juggling?
04:06:48 * wagle sees he needs to read up on lenses..  8)
04:07:07 <roconnor_> If I had the time, I feel like I could probably write several papers on this topic with Twan.
04:07:19 <roconnor_> maybe I'll have time in a few months
04:07:42 <roconnor_> nand`: did you see my blog post?
04:07:42 <edwardk> what are you getting for :t fstGetter . fstGetter
04:07:50 <edwardk> using your rep
04:08:13 <wagle> :t Const
04:08:14 <lambdabot> forall a b. a -> Const a b
04:08:15 <roconnor_> @type let fstGetter f (a,b) = Const . getConst $ f a in fstGetter Prelude.. fstGetter
04:08:16 <lambdabot> forall a t b t1 b1 t2. (t1 -> Const a b1) -> ((t1, t2), t) -> Const a b
04:08:27 <nand`> roconnor_: presumably not
04:08:36 <roconnor_> nand`: http://r6.ca/blog/20120623T104901Z.html
04:08:43 <edwardk> interesting i must have miswired something up in this pass
04:09:17 <roconnor_> nand`: we are talking about "read-only" lenses based on that.
04:09:32 <edwardk> @type let fstGetter f (a,b) = Const . getConst $ f a in fstGetter
04:09:33 <lambdabot> forall t a b t1 b1. (t -> Const a b) -> (t, t1) -> Const a b1
04:10:23 <ique> I'm trying to get a C# programmer into Haskell, does anyone have any good tips for a smallish project one can do that introduces Haskell gently? :P
04:10:37 <edwardk> ah found it
04:11:34 <srhb> ique: I'm fairly new and so far I've made a snake game and a subtitle getter plus a smallish multithreading demo.. All projects are sub-100 LOC, if that means anything.
04:12:08 <ique> srhb: snake game? with GUI and everything? what did you use for that?
04:12:38 <srhb> ique: Yes. Gloss. :) Ultra simple graphics, just a bunch of circles moving around.
04:12:53 <hpc> ique: an IRC bot is always easy
04:12:58 <edwardk> type Getter a c = forall r d b. (c -> Const r d) -> a -> Const r b
04:13:15 <wagle> i did a conway's life with streams for each cell once...  tought to get to type check
04:13:32 <aristid> @src Const
04:13:32 <lambdabot> Source not found. stty: unknown mode: doofus
04:13:35 <srhb> ique: (I have a "main loop" that runs this: (moreCheese . eat . die . move $ world) -- makes me very happy)
04:13:56 <aristid> ah, data Const a b = Const a?
04:14:06 <edwardk> aristid: yeah
04:14:15 <ique> hpc: are there any libs for handling the protocol or would you have to do the networking bits as well? could be interesting either way
04:14:24 <ique> srhb: hah, awesome
04:14:25 <edwardk> wagle: you can implement it very nicely comonadically
04:14:47 <aristid> edwardk: i'm not sure i understand the point of having those Const functors in Getter
04:15:32 <hpc> ique: there might be a library but it's pretty simple to do on your own
04:15:58 <edwardk> aristid: one sec. i'll hpaste
04:15:58 <roconnor_> aristid: it is to make it compatable with (^.) :: a -> ((b -> Const b b') -> a -> Const b a') -> b
04:16:09 <edwardk> aristid: what roconnor_  said
04:16:12 <wagle> my brain seems tired caregorically..  dunno why category theory wont stay there..  got an A in Launchbury's class..  remember nothing
04:16:19 <edwardk> aristid: thats the only combinator we want to have work on them legally
04:16:29 <edwardk> so we just restrict the type signature so only it works ;)
04:16:43 <edwardk> aristid: compare with (%=) :: ((c -> Identity d) -> a -> Identity b) -> (c -> d) -> a -> b
04:16:48 <wagle> s/tired/wired/
04:17:09 <edwardk> when your lens has the type forall f. Functor f => (c -> f d) -> a -> f b
04:17:13 <wagle> nice freud there though..  maybe i should lspeep now
04:17:14 <edwardk> you can pass it to both of those functions
04:17:27 <roconnor_> wagle: sounds like it :D
04:18:11 <wagle> hmm..  my typing is worse than usual..  for sure..  gnite
04:20:11 <mauke> haxml--
04:21:14 <kallisti> anyone know of a good PNG image manipulation library for Haskell?
04:21:17 <kallisti> I may just resort to imagemagick
04:23:37 <hpc> kallisti: imagemagick is good
04:23:48 <kallisti> right I was just hoping to avoid IPC
04:23:59 * hpc is writing an imagemagick library in compositional style for work
04:24:14 <hpc> my boss just needs to work out the license and i can open-source it
04:24:33 <kallisti> I guess I could use the C API...
04:24:35 <hpc> (warning: it's perl)
04:24:55 <hpc> oh, no need
04:24:56 <hpc> http://hackage.haskell.org/package/hsmagick
04:25:07 <kallisti> that's what I was looking for. :P
04:26:51 <edwardk> polarLens f p = uncurry mkPolar <$> f (polar p) -- gives the trivial polar coordinate transform lens
04:27:18 <edwardk> polarLens :: (RealFloat a, RealFloat b) => PolyLens (Complex a) (Complex b) (a,a) (b,b)
04:27:37 <edwardk> put it lets you change the type of the complex argument when setting it back
04:41:23 <djh_> I'm trying to build GHC on my ARM system but I'm just getting the following error during the build "collect2: ld returned 1 exit status
04:41:30 <djh_> but there's no error before
04:41:39 <djh_> is there any way I can pass a flag to make
04:41:43 <nand`> roconnor_: I had a look at the post you linked to, very interesting
04:41:45 <djh_> to post any further debug output
04:44:02 <edwardk> the only problem with the fixity of ^. is that its really awkward to use with the . you want to use to complex the VL lenses
04:44:43 <edwardk> infixl 8 would let it compose better
04:44:57 <edwardk> ghci> ((1 :+ 2),2) ^. fstLens . getMagnitude      ==> 2.23606797749979
04:45:30 <kallisti> cabal: The pkg-config package GraphicsMagick version >=1.3.3 is required but
04:45:44 <kallisti> when trying to install hsmagick
04:49:39 <bitonic> kallisti: but what?
04:50:07 <kallisti> it could not be found
04:50:56 <bitonic> kallisti: well, did you install GraphicsMagic?
04:51:11 <kallisti> I'm installing the dev package right now via apt
04:51:20 <kallisti> but it seems to be a cabal package that doesn't exist?
04:51:33 <bitonic> kallisti: no, it's a pkg-config package as the error says
04:51:52 <kallisti> oh, I'm ignorant as to what the difference is, then.
04:52:17 <bitonic> kallisti: pkg-config is to easily get metadata about C libraries
04:52:38 <bitonic> nothing to do with haskell. see man 1 pkg-config
04:52:57 <kallisti> aha
04:53:52 <kallisti> there we go.
04:55:44 <maybefbi> can we write functions without arguments in haskell?
04:55:54 <nand`> you mean constants?
04:56:06 <tdammers> (a.k.a. variables ;-)
04:56:09 <maybefbi> haha yeah
04:56:18 <nand`> > let x = 5 in x + 1
04:56:19 <lambdabot>   6
04:56:26 <nand`> x has no parameters
04:56:31 <bitonic> @faq can you assign values to symbols in Haskell?
04:56:31 <lambdabot> The answer is: Yes! Haskell can do that.
04:56:36 <maybefbi> true
04:56:41 <bitonic> Yes!
04:57:14 <bitonic> maybefbi: btw, there is exactly one alternative to taking no argument, which is taking 1 argument.
04:57:28 <nand`> yes
04:57:45 <maybefbi> so what about those functions which take 2 arguments? are they considered curried?
04:57:54 <nand`> maybefbi: yes
04:58:01 <maybefbi> :)
04:58:15 <nand`> :t let f a b = () in f
04:58:15 <lambdabot> forall t t1. t -> t1 -> ()
04:58:22 <nand`> read as t -> (t1 -> ())
04:59:07 <maybefbi> thanks
05:00:56 <bitonic> ksf: btw, if I'll have time these days I'll try to replicate Data.{Typeable,Data} completely with GHC.Generics, and then just change some code in `syb' to see if everything works with the replacements
05:19:19 <maybefbi> I am working on solving the exercises about Flurry (functor) and Misty (monad). I cannot understand the solution to ((->) t) instance of Misty. Can someone help me understand line 69 here: https://gist.github.com/1493055
05:19:46 <hiptobecubic> What the hell are you talking about?
05:19:56 <edwardk> hiptobecubic?
05:20:19 <edwardk> maybefbi: (->) is an 'infix' application of the arrow constructor from functions
05:20:25 <edwardk> a -> b can be written (->) a b
05:20:32 <edwardk> here its not being applied to its last argument
05:20:57 <edwardk> er (->) is a prefix application
05:21:32 <maybefbi> yes i understand that. i used that knowledge to calculate the Functor instance for (->)
05:21:46 <maybefbi> ((->) t)
05:21:53 <maybefbi> it is (.)
05:22:21 <maybefbi> i mean fmap of ((->) t) is (.)
05:22:47 <mauke> so if instance Fluffy ((->) t) is ok, what do you not understand about instance Misty ((->) t)?
05:23:38 <maybefbi> the solution does not make sense. what is the type of x y z
05:23:49 <mauke> there is no x y z in line 69
05:24:17 <maybefbi> i was talking about the instance
05:24:18 <edwardk> what is the type of banana?
05:24:20 <edwardk> start there
05:24:31 <edwardk> write it out here
05:24:41 <maybefbi> type of banana is: (a -> t -> b) -> (t -> a) -> t -> b
05:24:47 <edwardk> ok
05:24:52 <maybefbi> so what is x y z?
05:24:54 <edwardk> so now, x : (a -> t -> b)
05:24:54 <mauke> I think you just answered your question
05:24:57 <edwardk> y : (t -> a)
05:24:59 <edwardk> z : t
05:25:03 <mauke> edwardk: ::
05:25:03 <edwardk> and the answer has type b
05:25:05 <edwardk> yes
05:25:25 <edwardk> x y and z are the three arguments that magicaly appeared in your type ;)
05:25:42 <maybefbi> haha ok. it was my fault. i kept seeing t -> b at the end together
05:25:46 <edwardk> yep
05:25:50 <maybefbi> as (t -> b)
05:25:53 <mauke> that is correct
05:26:01 <edwardk> its a common misconception that takes time to break
05:26:02 <mauke> f x = y is equivalent to f = \x -> y
05:26:23 <hiptobecubic> edwardk?
05:26:25 <mauke> banana x y z = ... is equivalent to banana x y = \z -> ...
05:27:05 <maybefbi> yeah i need to get used to that curried thinking
05:28:14 <edwardk> @hpaste
05:28:14 <lambdabot> Haskell pastebin: http://hpaste.org/
05:28:27 <hpaste> edwardk pasted “polymorphic lenses” at http://hpaste.org/70372
05:28:54 <nand`> ‘banana’ is such a misleading name, I needed a few double takes before I realized you weren't talking about catamorphisms
05:29:06 <edwardk> yeah
05:29:20 <edwardk> who wrote up that sheet originally anyways?
05:29:23 <edwardk> i see it a lot these days
05:29:27 <edwardk> its a great exercise set
05:29:28 <nand`> Meijer
05:29:30 <HugoDaniel> :)
05:29:31 <edwardk> ah
05:29:48 <nand`> or did you mean the one maybefbi is doing?
05:29:50 <edwardk> the polymorphic lenses code in that paste is making me very happy
05:30:10 <edwardk> the one he's doing
05:30:12 <nand`> oh
05:30:14 <nand`> that I have no idea
05:30:26 <nand`> Meijer wrote the “Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire” :)
05:30:31 <edwardk> yeah
05:30:37 <mauke> nand`: that's not an exercise sheet
05:30:47 <edwardk> he actually went to hire me at one point
05:30:52 <nand`> mauke: yeah, hence my confusion
05:31:03 <nand`> I read “who wrote up that sheet” as “who wrote up that paper”
05:31:24 <Goatflakes> should i be thinking
05:31:42 <Goatflakes> f::a->b->c
05:32:04 <Goatflakes> that f takes a and b or f takes a and returns a function from b to c
05:32:06 <Goatflakes> or both
05:32:11 <edwardk> ghci> (0:+4,3)^.fstLens.getMagnitude.get signum    ==> 1.0
05:32:25 <edwardk> with 'get' you can use any function in the chain
05:32:35 <edwardk> mixing and matching it with real lenses
05:32:44 <nand`> “Just . f $ a” what a contrived way to write Just (f a)
05:32:57 <edwardk> and they compose in the order an old school imperative coder would expect
05:33:20 <edwardk> Goatflakes: both perspectives are useful
05:33:24 <mauke> Goatflakes: both
05:33:37 <maybefbi> edwardk, nand`, the problem sheet i am trying to solve came from here: http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/
05:33:42 <mauke> nand`: the advantage is that you don't have )
05:33:45 <edwardk> Goatflakes: the curry and uncurry function state that both of those ideas are largely equivalent
05:34:02 <nand`> Goatflakes: the correct answer is: you should only be seeing one option there :P
05:34:02 <edwardk> maybefbi: ah yes, it was tony, thanks
05:34:04 <Goatflakes> hmm thanks thoughtso i was trying just to do the multiple args thing but sometimes it's confusing trying to force everything into that point of view
05:34:30 <mauke> Goatflakes: try deriving the type of 'flip id'
05:34:35 <nand`> maybefbi: yeah, the URL is in the gist you linked :)
05:35:01 <Goatflakes> but it is helpful to look at it as multiple args so you don't get hopelessly confused sometimes
05:36:22 <hiptobecubic> > flip id 3 negate
05:36:24 <lambdabot>   -3
05:36:51 <shachaf> @djinn (a -> (b,c)) -> a -> (b -> c -> r) -> r
05:36:52 <lambdabot> f a b c =
05:36:52 <lambdabot>     case a b of
05:36:52 <lambdabot>     (d, e) -> c d e
05:36:56 <shachaf> @djinn (a -> (b -> c -> r) -> r) -> a -> (b,c)
05:36:56 <lambdabot> -- f cannot be realized.
05:36:58 <shachaf> :-(
05:37:18 <shachaf> I guess there's no real point to the "a" there.
05:37:38 <Goatflakes> ah
05:37:44 <Chiron_> Hi, what is the recommended why to maintain a long term Haskell installation on OSX, brew of the native Haskell OSX package from Haskell.org?
05:38:04 <Chiron_> brew or the native Haskell OSX package from Haskell.org?
05:38:31 <hpc> haskell.org ghc + cabal, with brew for C depends
05:38:37 <hpc> if OSX is anything like linux at least
05:38:56 <shachaf> hpc: It's not, for package management.
05:39:03 <shachaf> (Not that Linux has a package manager.)
05:39:16 <shachaf> Chiron_: You should probably get the Haskell Platform download.
05:39:24 <djh_> just get the haskell platform
05:39:32 <djh_> it works straight out of the box
05:39:46 <Chiron_> and it is easy to upgrade to newer releases?
05:39:57 <djh_> yeah it's no problem
05:39:57 <shachaf> It works straight out of the box, but unfortunately once you've put it in the box you can never get it out.
05:40:14 <Goatflakes> lol
05:40:16 <djh_> there's even a uninstall-hs script that will uninstall older versions of GHC
05:40:17 <Chiron_> Hmmm
05:40:18 <nand`> hmm, is there a way to unify :: Functor f => f (a -> b)  with :: a -> a  other than setting f = (->) (a -> b) ?
05:40:19 <djh_> on OSX
05:40:20 <Goatflakes> use a monad
05:40:23 <shachaf> Chiron_: Upgrading will probably be no worse than with a package manager.
05:40:52 <Chiron_> my first day with Haskell, coming from Clojure. it is going to be awesome :)
05:40:55 <hpc> :t (undefined :: Functor f => f (a -> b)) `asTypeOf` (undefined :: a -> a)
05:40:56 <lambdabot> forall a b. (a -> b) -> a -> b
05:41:00 * nand` doesn't exactly know an awful lot about unifying types with constraints
05:41:08 <mauke> (->) a a = f (a -> b)
05:41:12 <shachaf> nand`: Just get rid of the constraint.
05:41:13 <rwbarton> the constraints play no role in unification
05:41:19 <mauke> ((->) a) a = f (a -> b)
05:41:31 <mauke> therefore ((->) a) = f and a = (a -> b)
05:41:38 <mauke> oh, and those are different 'a's
05:41:52 <nand`> ah
05:42:32 <nand`> yeah, that clears it up
05:43:47 <Goatflakes> well can't u just install a buildchain chiron and compile it and pretend like you are on a unix?
05:44:17 <Goatflakes> and the just delete the folder if you want to "uninstall" it?
05:45:19 <Chiron_> my first day with Haskell, everything is new to me
05:45:23 <Goatflakes> all the world's a vax
05:46:23 <Goatflakes> well ignore what i say it will just be leading you down the garden path
05:46:26 <srhb> Chiron_: I've used both Haskell Platform and compiled GHC from source on OS X, both work fine.
05:46:47 <Goatflakes> yes sorry ghc from source
05:46:48 <nand`> wow, xmonad has nearly half as many SLOCs as dwm; did not see that coming
05:46:49 <Chiron_> Thank you all guys!
05:47:29 <mauke> nand`: yeah, it got big
05:47:39 <nand`> mauke: xmonad or dwm?
05:47:42 <Goatflakes> what's a sloc? a backwards clos? o.o
05:47:46 <nand`> Goatflakes: source line of code
05:47:54 <Goatflakes> k
05:48:12 <nand`> and wouldn't that be cols?
05:48:28 <Goatflakes> idk i have a caffiene headache
05:48:55 <Goatflakes> has anyone used the opengl thing for haskell?
05:49:08 <navaati> hi
05:49:42 <Goatflakes> i can't even imagine how that would work opengl is a huge ball of statefulness and mutableness or whatever :p
05:49:48 <Goatflakes> hi navaati
05:50:17 <srhb> Goatflakes: You're in a do block all the time and it is indeed very mutable and very imperative.
05:50:26 <srhb> Depending of course on the bindings.
05:50:28 <Goatflakes> k
05:50:47 <nand`> Goatflakes: lots of IO
05:50:53 <nand`> Goatflakes: there are high level abstractions
05:50:59 <Goatflakes> goody
05:51:06 <nand`> Goatflakes: you can do imperative, mutable and stateful programming in Haskell :)
05:51:23 <navaati> Goatflakes: if you want yummy functionnal opengl, take a look at GPipe
05:51:23 <srhb> And it's often very pretty, too. fsvo pretty.
05:51:24 <nand`> it's just referentially transparent, strong statically typed and pure :)
05:51:41 <Goatflakes> ok will do thanks
05:51:51 <nand`> you can use ‘gloss’ too which is a high level abstraction for OpenGL
05:51:55 <nand`> if all you want to do is draw nice shapes
05:51:59 <srhb> navaati: Wow! I never heard of that.
05:52:02 <Goatflakes> also u can do surgery with a spoon it's just not a good idea
05:52:14 <nand`> one thing gloss can't do is “pixel shaders”; but there's an extension that can iirc
05:52:32 <nand`> spoon surgery is always fun :)
05:52:32 <srhb> navaati: My goodness, that looks awesome.
05:52:36 <srhb> nand`: And 3d?
05:52:54 <navaati> srhb: oh yes it is :)
05:52:56 <nand`> srhb: oh, right; I don't think gloss can do that
05:53:11 <Goatflakes> lol
05:53:15 <navaati> gloss is a 2D lib, the fact that it uses opengl is not even really interesting
05:53:25 <nand`> Hmm, last time I tried using GPipe I couldn't get it to compile. Has that changed or did I just do something wrong last time?
05:53:43 <navaati> nand`: when was that last time ?
05:53:53 <nand`> I completely forgot OpenGL does 3d
05:53:58 <Goatflakes> lol
05:53:59 <nand`> navaati: a while ago, that's all I can say
05:54:26 <nand`> hmm, gloss and gpipe conflict (they pull in different versions of opengl/glut)
05:54:56 <navaati> erf… yeah i don't think gpipe is actively developed anymore
05:55:04 <srhb> Aw..
05:55:19 <Goatflakes> burn the unbeliever
05:55:33 <nand`> oh, 1.3.1 doesn't conflict
05:55:35 <nand`> I was trying 1.3
05:55:42 <Goatflakes> -.-'
05:59:24 <kallisti> so I'm wondering if the initializeMagick function in hsmagick needs to be called per program or per thread.
05:59:29 <kallisti> doesn't specify.
06:01:00 <nand`> does anybody know if vec-boolean-1.0.4 will compile using vec-0.9.9?
06:01:25 <nand`> It has =vec-0.9.8 as dependency but vec-0.9.8 doesn't compile for me, vec-0.9.9 does
06:04:49 <nand`> it appears to compile fine
06:07:20 <Goatflakes> i think navaati is stalking me :p
06:07:31 <Goatflakes> either that or it's a common handle
06:07:53 <Goatflakes> or gasp we both like haskell
06:08:23 * Goatflakes googles navaati
06:09:17 * Goatflakes shrugs
06:11:04 <Goatflakes> seems legit unlike me
06:11:08 <Goatflakes> :p
06:11:16 <Goatflakes> maybe i am stalking him
06:14:53 <Goatflakes> http://en.wikipedia.org/wiki/Combinator
06:15:00 <Goatflakes> jesus who writes this shit
06:15:17 <kallisti> math majors
06:15:33 <jmcarthur> what's wrong with it?
06:15:43 <nand`> huzzah, I got gpipe to compile
06:15:45 <Goatflakes> so much for "an introductory treatment suitable for a high school graduate"
06:15:49 <Goatflakes> yay
06:16:00 <kallisti> well the intro text is pretty easy to follow.
06:16:15 <Goatflakes> and it's all down hill from there
06:16:54 <kallisti> I'm probably biased though because I'm pretty familiar with combinatory logic already.
06:17:19 <jmcarthur> i think if a high school graduate is trying to learn such things, he'll need to be pretty good at reading such material. it's almost never actually geared toward that audience
06:17:27 <kallisti> this is actually written in a more accessible manner than many of the math articles out there.
06:17:32 <jmcarthur> i agree
06:17:44 <Goatflakes> also note i actually looked up combinators and it gave me combinatory logic then refered me to combinators in the introduction
06:17:44 <nand`> the main problem with that article I see is the inconsistent quotation style
06:17:46 <Goatflakes> fail
06:17:57 <nand`> err, referencing style
06:18:34 <jmcarthur> i don't see that reference
06:18:37 <Goatflakes> all math articles on wikipedia are terrible beyond belief. this one is not as terrible as most
06:18:50 <nand`> eg. “, see Barendregt (1984)”, which is incorrect for wikipedia, in the same paragraph as a (correct) “[1]” link
06:19:07 <nand`> s/referencing/citation/
06:19:19 <Goatflakes> heh another emacs freak
06:19:30 <nand`> Goatflakes: I use vim
06:20:00 <kallisti> I end up using join traceShow more often than traceShow itself
06:20:06 <Goatflakes> i used emacs but it was soul destroying loosing my .emacs everytime i had a brain fart and wiped my home directory
06:20:25 <kallisti> Goatflakes: my .emacs is relatively minimal so I don't have that issue
06:20:32 <kallisti> I'm not sure what I would do to make it more complex
06:20:45 <nand`> I have most of my important configuration files backed up in a git repository
06:20:47 <nand`> useful for sharing as well
06:20:56 <nand`> but I've never accidentally wiped my home dir, that would be horrible
06:21:25 <bitonic> nand`: I have, that was fun
06:21:42 <kallisti> I've forgotten what my important configuration files are. >_>
06:21:51 <Goatflakes> oh i do it atleast every few months :l i used to use vim and shunned emacs like a plagued rat then one day i snapped when i typed Q instead of :q
06:21:55 <bitonic> mkfs'ed the wrong /dev/sd*. at least it was a chance to clean up
06:22:19 <Goatflakes> so then i made emacs work like old dos edit
06:22:31 <Goatflakes> everything MUST work like that or it goes in the bin for me
06:22:50 <nand`> I type :Q all the time instead of :q; I need to alias those two together :(
06:23:00 <nand`> :W too
06:23:30 <bitonic> the problem is higher up in the pipeline: you use vim.
06:24:24 <Goatflakes> agreed
06:24:31 <mauke> nand`: com -bang -bar Quit q<bang>
06:24:40 <Goatflakes> i need something like emacs but not so retarded
06:24:41 <mauke> nand`: com -bang -bar -nargs=? -complete=file -range=% Write <line1>,<line2>w<bang> <args>
06:24:46 <mauke> put that in your .vimrc
06:25:09 <Goatflakes> maybe something that uses lua or something for configuration
06:25:19 <nand`> mauke: I.. what
06:25:24 <nand`> I want something like vim that uses haskell for configuration
06:25:34 <Goatflakes> or haskell maybe that would be nice once i can understand how parsers work
06:25:48 <Goatflakes> don't u ever get sick of modal editing?
06:26:07 <nand`> Goatflakes: nope. I'm relatively new to vim
06:26:13 <mauke> don't you ever get sick of typing escape-meta-alt-control-shift?
06:26:37 <nand`> but it was a very nice experience coming from the clumsy non-modal editors I was used to (on windows)
06:26:44 <nand`> eg. Visual Studio
06:26:48 <nand`> or Notepad++
06:27:11 <Goatflakes> constantly that's y i make it do stuff like control insert to copy and cut and paste ala CUA
06:27:27 <Goatflakes> you are joking right?
06:27:35 <nand`> I use shift+insert to paste in terminals, and p/P to paste in vim
06:27:40 <Goatflakes> what's to like appart from regular expressions?
06:27:45 <nand`> I don't think a modal terminal would work very well, mind
06:27:50 <mauke> haha, what
06:28:01 <nand`> or maybe it would, but with the default mode being insert
06:28:02 <mauke> vim's regexes may be powerful but the syntax is particularly ugly
06:28:02 <nand`> hmm
06:28:28 <nand`> the main thing that confuses me about vim is that it it has unintuitive default behavior when it comes to special characters
06:28:39 <nand`> it escapes them automatically, I had to disable this to get the behavior I was used to
06:28:44 <nand`> vim's regex
06:28:46 <nand`> *
06:29:06 <mauke> that's why I sometimes just use :perldo s///
06:30:04 <nand`> mauke: anyhow, care to explain what your ‘com’ line does? it looks scary, I don't want to try it out :(
06:30:14 <Goatflakes> isn't there like a whole family of vims that use perl or other languages for scripting?
06:30:22 <nand`> Goatflakes: I'm not sure
06:30:31 <nand`> Goatflakes: honestly I'm not sure that would be an improvement either
06:30:36 <Goatflakes> and also i am pretty sure there was a tcl one
06:30:39 <jmcarthur> there's always yi
06:30:46 <nand`> good old yi
06:30:47 <mauke> nand`: defines aliases Quit/Write for quit/write
06:30:51 <Goatflakes> so maybe u can look at them and put a haskell in it :p
06:30:56 <mauke> nand`: which makes :Q and :W just work
06:31:01 <nand`> mauke: ah, nice
06:31:08 <jmcarthur> Goatflakes: http://www.haskell.org/haskellwiki/Yi
06:31:19 <mauke> Goatflakes: no, that's all the normal vim
06:31:47 <nand`> mauke: I was somehow thinking it would overwrite the file with something, since -complete=file -range=% ‘Write’ and the references to <line> looked scary
06:32:09 <Goatflakes> well if it does perl and tcl already, couldn't u stuff a haskell interpreter in there?
06:32:30 <mauke> nand`: that's just to replicate the behavior of :1,10w foo.txt etc.
06:32:38 <nand`> I see what it does now, yes
06:32:40 <nand`> thanks
06:32:43 <jmcarthur> perl and tcl tend to be included by default on more linux systems than haskell interpreters
06:32:48 <jmcarthur> *unix
06:33:05 <Goatflakes> i mean make your own not take over the vim world
06:33:08 <mauke> yes, but vim has even scheme bindings
06:33:28 <nand`> how compatible is yi with vim? Can a vim user switch to yi and not notice the difference?
06:33:33 <nand`> (barring plugins)
06:33:58 <Goatflakes> god. Xaw3d we meet again
06:35:02 <holzensp> It's eerily on #ghc, so I figured I would give #haskell a shot at this ;)
06:35:04 <holzensp> Can anybody tell me how to use the type checker functions to see whether two TypeRep.Type things can be unified?
06:35:17 <holzensp> (The type checker functions in the GHC-API, that is)
06:37:20 <bitonic> holzensp: TypeRep.Type? I don't have that in the GHC api
06:38:00 <holzensp> are you on 7.4.1?
06:38:04 <bitonic> holzensp: yes
06:38:16 <bitonic> actually no, 7.4.2.
06:38:36 * hackagebot resourcet 0.3.3 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.3.3 (MichaelSnoyman)
06:38:47 <holzensp> bitronic: and when you start "ghci -package ghc" and type ":i TypeRep.Type"; nothing happens?
06:40:28 <bitonic> holzensp: you're right, I do have it. Strangely it's not listed here: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/index.html ?
06:40:40 <nand`> it doesn't auto-complete either
06:41:10 <holzensp> that is a bit weird, indeed
06:41:18 <holzensp> TypeRep.Type is the same thing as Type.Type
06:41:24 <holzensp> (just try ":i Type.Type")
06:41:29 <bitonic> holzensp: oh, ok.
06:41:34 <holzensp> it's just that Type.Type is only the public interface to it
06:41:49 <holzensp> regardless, though… I would really like to be able to unify two types
06:41:57 <holzensp> and get a list of variable substitutions out of it
06:42:21 <bitonic> holzensp: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/Unify.html ?
06:42:21 <holzensp> there are quite a few functions that have a suggestive type signature, but don't work for me and they have very little, if any, documentation
06:42:37 <bitonic> holzensp: I just grepped the index for unify, but maybe it's useful to you
06:42:45 <bitonic> they look promising
06:42:48 <Goatflakes> :i Type.Type
06:42:56 <bitonic> `tcMatchTy' has a nice type sig.
06:43:00 <holzensp> yeah… I came across that… If you could tell me what I should stick in the TyVarSet so taht I don't get Nothing
06:43:08 <holzensp> I only got Nothings out of that
06:43:36 * hackagebot reactive-banana-wx 0.6.0.1 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.6.0.1 (HeinrichApfelmus)
06:43:44 <bitonic> holzensp: I'd suppose that the tyvarset is the set of free variables in the types you want to unify.
06:44:08 <bitonic> oh man. the GHC api surely is messy.
06:45:08 <holzensp> bitronic: The type variables in both? Do I keep the ForAllTy constructors in the type, or do I take them out, etc.
06:46:45 <bitonic> holzensp: yes, the tyvars in both. well, it depends, you could want to unify higher ranked types but you most likely don't want the quantifications
06:47:10 <bitonic> I'd try with something really simple first, e.g. `a' and `Bool' or whatever.
06:47:23 <bitonic> or even `Bool' and `Bool' first.
06:47:47 <schlicht> i have this: data S = forall a . (Typeable a, Show a, Ord a, Substitutable a) =>S (Map a a), how do i use patter matching to get the map inside an S?
06:47:56 <holzensp> bitonic: higher ranked types presumably have the ForAllTy constructors "inside" the type (as opposed to the default of having the quantification at the outer-most level)
06:48:25 <mauke> schlicht: case x of S m ->
06:48:55 <bitonic> holzensp: yes, that's what I was referring to
06:49:19 <bitonic> but the inside won't be unified, logically
06:49:29 <schlicht> mauke, okay, never would tried that. why that way?
06:49:48 <Goatflakes> make it strict?
06:49:48 <holzensp> I'm trying it out (always a bit fidgety with all those different monads and environments)
06:49:55 <mauke> schlicht: ... what other way is there?
06:50:11 <monoidal> mauke: f (Sm) = ... but that blows the mind
06:50:28 <bitonic> holzensp: well... actually I'm not sure about that. In the "classic" HM algorithm you only unify non-quantified types. but with GHC I'm not sure if there is some subtlety.
06:50:32 <schlicht> i tried patter matching
06:50:45 <mauke> schlicht: that was pattern matching
06:50:48 <mauke> what did you do?
06:50:51 * bitonic goes to get coffee
06:51:04 <Goatflakes> what's HM?
06:51:05 <schlicht> mauke, unS (S m ) = m
06:51:11 <schlicht> monoidal, whats that? :)
06:51:30 <mauke> schlicht: that's the same thing
06:51:41 <schlicht> yeah...that doesnt work
06:51:43 <mauke> using patterns in function equations is just syntactic sugar for case/of
06:51:44 <holzensp> bitonic: tcMatchTy emptyUniqSet booltp booltp
06:51:50 <Goatflakes> seminal haskell implementation or paper?
06:51:52 <mauke> schlicht: the part that doesn't work is trying to return m
06:52:04 <holzensp> bitonic: actually gives me a (Just (TvSubst InScopeSet [] []))
06:52:43 <schlicht> mauke, because the type is unknow at compile time or why?
06:52:55 <mauke> because it's an existential type
06:54:25 <bitonic> holzensp: well, that is correct, no substitutions.
06:54:38 <bitonic> now try with a type which is just a free variable
06:55:01 <schlicht> mauke, hmm that makes working kind of hard.
06:55:10 <mauke> yes
06:55:10 <Goatflakes> isn't it because it is lazy and a type hasn't actually been instantiated?
06:55:12 <kallisti> it's apparently impossible to copypaste into firefox via M-w in emacs
06:55:27 <Goatflakes> what u do is do paste from the menu
06:55:46 <bitonic> kallisti: of course is is, see `x-select-enable-clipboard'
06:55:53 <bitonic> kallisti: also, wrong channel
06:56:09 <Goatflakes> it's another example of emacs badness the kill ring being /= clipboard
06:56:09 <schlicht> mauke, but thanks :)
06:56:18 <holzensp> bitonic: Ah, yes: let ForAllTy v vartp = undeftp in tcMatchTy (mkUniqSet [v]) vartp booltp
06:56:30 <holzensp> bitonic: gives me: Just (TvSubst InScopeSet [(agqq,a)] [(agqq,TyConApp GHC.Types.Bool [])])
06:56:38 <bitonic> Goatflakes: that depends. btw, in 24 it is the clipboard by default
06:57:02 <holzensp> bitonic: but I can't reverse vartp and booltp, so the first type has to be the more general
06:57:08 <Goatflakes> bitonic: does x-select-enable-clipboard unify the kill ring and the clipboard?
06:57:10 <bitonic> holzensp: that sounds weird.
06:57:17 <holzensp> why?
06:57:26 <bitonic> Goatflakes: `C-h v x-select-enable-clipboard' to find out
06:57:37 <bitonic> holzensp: well I'd expect to work both ways no?
06:57:52 <Goatflakes> lol i'm on my laptop which i have failed to get linux on because of nvidia retarded ness
06:58:05 <Goatflakes> so it is a windows
06:58:07 <Goatflakes> :X
06:58:10 <holzensp> bitonic: mmm….
06:58:12 <bitonic> Goatflakes: anyway, yes: "Non-nil means cutting and pasting uses the clipboard."
06:58:15 <holzensp> bitonic: yes, I guess so
06:58:20 <Goatflakes> nice thanks
06:58:22 <Goatflakes> but then
06:58:33 <Goatflakes> u can't rotate the kill buffer?
06:59:37 <bitonic> Goatflakes: I forgot what that means, you can ask #emacs anyway
06:59:52 <Goatflakes> fanks
07:00:16 <Goatflakes> and it means M-y no work
07:03:24 <bitonic> Goatflakes: it does work
07:03:53 <Goatflakes> cool thanks
07:19:19 <jjg> got kinda a weird question, I need to manage state using recursion, but would rather not explicitly pass the state around, is there a monad I can use for this?
07:19:31 <jjg> or any kind of abstraction really
07:19:32 <Taneb> The State monad?
07:19:37 <bitonic> jjg: the unimaginatively named State monad
07:20:14 <jjg> no, that will keep track of more than I'd like
07:20:56 <Taneb> What do you do with the state?
07:21:05 <jjg> imagine traversing a tree and only wanting access to the state of the branch that you are within
07:21:52 <sipa> Reader monad using local?
07:22:18 <sipa> you want a backtracking state, it seems?
07:22:25 <Philippa> or a State monad with an equivalent of local written on top of it, yeah
07:22:35 <parcs`> data-lens has a 'focus' combinator
07:22:41 <parcs`> which is like local for state
07:22:48 <Philippa> parcs`: ooh, I really /do/ need to play with data-lens at some point
07:23:06 <Philippa> (I'm a few years out on most of the really fun developments now - it's starting to show)
07:23:12 <parcs`> http://hackage.haskell.org/packages/archive/data-lens/2.10.0/doc/html/Data-Lens-Lazy.html#v:focus
07:23:37 * hackagebot silently 1.2.0.1 - Prevent or capture writing to stdout and other handles.  http://hackage.haskell.org/package/silently-1.2.0.1 (SimonHengel)
07:25:08 <jjg> reader with local looks like it might work, lens I'll have to look into more, thanks
07:25:55 <Philippa> what's the 'current' replacement for system and getArgs from the old System module?
07:26:44 <Philippa> (I 'just' upgraded to the new Platform and my Pandoc-based blogging toolchain looks like it wants a few tweaks)
07:26:59 <bitonic> @hoogle getArgs
07:26:59 <lambdabot> System.Environment getArgs :: IO [String]
07:27:00 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
07:27:04 <bitonic> Philippa: ^^^
07:27:15 <Philippa> jjg: Reader won't do updates, but if that's what you want then it's better than using State
07:27:22 <Philippa> (because it won't let you /try/ updates)
07:28:08 <jjg> Philippa: it looks like it may be exactly what I want, I'll have to give it a go and see though
07:28:11 <Saizan> Philippa: System.Process.system
07:28:21 <nand`> does anybody here use yi?
07:30:40 <donri> @hackage shqq
07:30:40 <lambdabot> http://hackage.haskell.org/package/shqq
07:30:41 <donri> Philippa: ^ ;)
07:32:47 <Philippa> okay, cba with the deprecation of catch as the new type subsumes the old one. That'll do for now
07:40:24 <nand`> hmm, I think I'll stick to vim. I can't seem to figure yi out
07:40:28 <nand`> at all
07:40:41 <hiptobecubic> yi?
07:40:48 <nand`> http://hackage.haskell.org/package/yi
07:41:00 <Taneb> You're better than I am. Text editors without a GUI terrify me for no real reason
07:41:15 <nand`> Text editors with a GUI terrify me
07:41:25 <hiptobecubic> i prefer text editors with both options :)
07:41:30 <nand`> yi can use a GUI btw
07:42:07 <nand`> so far it seems to me like yi is too confused, it attempts to appeal to both emacs users and vim users, both GUI lovers and terminal lovers etc.
07:42:19 <nand`> better to make a good clone of only one of those imo
07:42:24 <nand`> eg. a good vim clone in Haskell
07:42:28 <Taneb> At the moment I'm using gedit for little things and Eclipse for big things
07:42:44 <Taneb> Where big == more than a page
07:42:51 <nand`> also, yi is probably too beta at the moment
07:43:18 <ethercrow> nand`: i use yi as vim
07:43:38 <ethercrow> with inconsistent success
07:43:39 <nand`> ethercrow: that's what I'm trying to attempt
07:43:53 <Taneb> I can use nano if I have to
07:43:55 <Taneb> But emacs and vi both really confuse me
07:44:02 <nand`> I want an exact, 100% clone of vim as far as functionality and operation goes; but written and scriptable in Haskell
07:44:07 <nand`> that would be my perfect editor
07:44:20 <hiptobecubic> maybe not 100%
07:44:25 <ethercrow> also I've just found out that there is #yi channel
07:44:29 <hiptobecubic> there are some things that coudl use some rethinking
07:45:13 <basti__> how do i avoid breaking my ghc-pkg setup when compiling ghc mysqlf?
07:45:43 <donri> there are also benefits to having a crazy scripting language like viml, such as, the scripting language is the same as what the user uses to command and configure the editor
07:45:46 <nand`> hiptobecubic: probably; but all of the core behavior that I use on a day to day basis should be the same
07:46:02 <hiptobecubic> i would like to see a better way to interface with outside programs
07:46:10 <hiptobecubic> which i use pretty often
07:46:21 <nand`> donri: yes, the main advantage of that is that I don't have to restart my editor to play around with different settings
07:46:34 <hiptobecubic> like not freezing the entire editor while you wait for the process to finish
07:46:37 <nand`> (+ recompiling yi.hs is sloow)
07:46:40 <donri> nand`: well, we could do that in haskell too (e.g. dyre)
07:46:55 <nand`> hiptobecubic: the only thing I need is :%!stylish-haskell, which yi doesn't seem to have
07:47:13 <hiptobecubic> a formatter?
07:47:30 <donri> hiptobecubic: there are things like vimproc, might help
07:48:02 <nand`> hiptobecubic: a way to filter the buffer through external programs
07:48:05 <dispyfree> Hi
07:48:11 <nand`> a built-in formatter equivalent of stylish-haskell would be nice, mind
07:48:13 <dispyfree> I'm new to haskell and I
07:49:06 <Taneb> Keep compulsively pressing enter before finishing sentences? :P
07:49:09 <dispyfree> 'm currently doing the examples in my book. I'd like to know where you could improve my palindrome function, I think it's a bit bloated but I don't have a clue how to alleviate that. Please refrain from any libraries, though that'd be easier ;) http://pastebin.com/nicenF7K
07:49:12 <mauke> The paste nicenF7K has been copied to http://hpaste.org/70373
07:49:42 <dispyfree> yeah Taneb. I'm sometimes too passionate :)
07:49:45 <Taneb> :)
07:49:48 <donri> i want a vim with sane syntax highlighting
07:49:58 <nand`> palin x = show x == reverse (show x)
07:50:03 * nand` runs
07:50:35 <mm_freak> the way i read the code a Contravariant is a Profunctor without an "output type", is that precise in programmer terms?
07:50:36 <donri> Taneb: ' is just next to enter on some layouts (such as swe)
07:51:19 <Taneb> dispyfree, palin xs = xs ++ reverse xs
07:52:07 <Taneb> Why are all odd-length strings not palindromes?
07:52:11 <nand`> also your getList = take
07:52:24 <nand`> flip take rather
07:52:44 <Taneb> Like "bob"
07:52:54 <dispyfree> hm actually you're right
07:52:57 <nand`> and can be done simpler via pattern matching; “getList _ 0 = []” is already equivalent to “getList _ n | n == 0 = []”
07:53:51 <ion> palin' xs = xs ++ (tail . reverse) xs
07:54:02 <mm_freak> when learning haskell i found it very helpful never to use prefices like "get"
07:54:22 <nand`> ion: his behavior omits the tail
07:54:34 <mm_freak> the "get" contributes a lot to misunderstanding your own haskell code
07:54:38 <mm_freak> as in "getList"
07:54:51 <ion> Names that sound natural when used in “<name> of <parameter>” are often good.
07:54:56 <jmcarthur> on the other hand, i do like it as a convention with statemonad-ish things
07:55:08 <ion> “tail of xs” vs. “getTail of xs”
07:55:08 <nand`> I see it used for newtypes
07:55:13 <nand`> “getSum”, “getProduct”
07:55:16 <jmcarthur> or "action" things generally
07:55:16 <nand`> also run*
07:55:36 <dispyfree> hm okay nand you're right
07:55:38 <dispyfree> ;)
07:55:39 <mm_freak> yes, but you don't write state monads in your early haskell days =)
07:55:46 <nand`> I like “unSum” for stuff like that
07:55:58 <nand`> unSum . Sum = id
07:56:06 <nand`> makes total sense
07:56:09 <jmcarthur> i did. it was one of the cooler things to learn about
07:56:23 <nand`> depends on how early
07:56:31 <Taneb> Are there some contexts where data is preferable to newtype but both can be used?
07:56:31 <mm_freak> i think every haskell programmer goes through this:  first you learn the basics, then you learn about state, you try hard to understand state, you understand it and find the concept great, a few months pass, you never use State again
07:56:35 <dispyfree> @Taneb: if I want to support something like that, I'd need to do rounding? floor(num/2) ?
07:56:36 <lambdabot> Unknown command, try @list
07:56:58 <Taneb> dispyfree, Use div, and you don't need the floor
07:57:01 <mm_freak> Taneb: when you actually want the box
07:57:15 <jmcarthur> i kind of saw it basically the way i do now, which is that it's pretty great, but it's hard to justify using it from a software engineering perspective
07:57:28 <mm_freak> Taneb: if X is a newtype constructor, then 'X undefined' is undefined
07:58:12 <saep> at runtime
07:58:29 <mm_freak> Taneb: for example there might be some justification for defining the Identity monad in terms of 'data' instead of 'newtype'
07:58:34 <nand`> also, your isPalindrome is a very odd way of doing things; why not simply take the property of “x is a palindrome if it's the same read forwards and backwards” and encode that: “isPalindrome xs = xs == reverse xs”
07:58:49 <mm_freak> it makes (>>=) non-strict
07:58:55 <mm_freak> with newtype (>>=) would be strict
07:59:11 <nand`> instead of taking the first half, duplicating it with ‘palin’ and comparing that against the original
08:00:12 <nand`> dispyfree: another thing you should start doing is annotating the types of all your top-level functions
08:00:33 <dispyfree> ok
08:00:39 <dispyfree> why is this _so_ important?
08:00:54 <Taneb> mm_freak, interesting
08:01:51 <mm_freak> Taneb: data vs. newtype also plays a major role when defining instances for classes like MonadFix or ArrowLoop
08:01:56 <nand`> 1. it helps the programmer know what a function does without reading it, that includes you; 2. it helps localize type errors: if the error is in the implementation of a function, it will most likely not match the type, but if you don't annotate it explicitly it's possible that GHC infers another completely different type and you instead get a strange error why you try actually applying the function
08:02:06 <ksf> It'd be *really* helpful if haskell-src-exts would have an identity element for Expr under App
08:02:48 <rwbarton> an identity element for a data constructor?
08:03:45 <ksf> no. the constructor is not the monoid.
08:04:11 <ksf> but Expressions under App and the missing identity should be a perfectly fine monoid.
08:04:39 <dispyfree> @Taneb: that makes it somewhat easier ;)  (take halfLen xs) == (take halfLen (reverse xs))
08:04:39 <lambdabot> Unknown command, try @list
08:04:50 <ksf> dangling Apps happen all the time, and it'd be nice to just stick an mempty in there instead of refactoring the whole bloody expression.
08:05:04 <Taneb> dispyfree, also, don't start lines with @. That annoys the resident bot.
08:05:28 <dispyfree> oh sorry. who's the bot?
08:05:32 <nand`> lambdabot
08:05:34 <rwbarton> @botsnack
08:05:34 <lambdabot> :)
08:05:35 <dispyfree> k
08:06:31 <mm_freak> data VoidFunctor a  -- is there a better name for this?  monad-coroutine calls this Naught, but i think that's not a good name either
08:07:03 <nand`> maybe Void1, Void2 etc.
08:07:10 <nand`> data Void1 a; data Void2 a b;
08:07:29 <rwbarton> couldn't you define ksfApp (Just x) (Just y) = Just (App x y); ksfApp Nothing (Just y) = Just y; ksfApp (Just x) Nothing = Just x; ksfApp Nothing Nothing = Nothing
08:07:45 <mm_freak> hmm, the library i'm writing will only need the Void1 variant
08:07:51 <rwbarton> rather than add a constructor to the type for expressions that doesn't actually represent an expression
08:08:03 <mm_freak> it would be weird to write Void1 in the type signatures
08:08:08 <nand`> perhaps
08:08:23 <mm_freak> maybe i'll just call it Continuous, which is pretty application-specific
08:08:45 <ksf> rwbarton, I can't just stick a result of ksfApp into an Expr, though.
08:09:08 <ksf> and this isn't about the semantics of haskell expression, but easing the hell that is code generating a bit.
08:09:42 <ksf> there's a gazillion ways to generate invalid haskell with haskell-src-exts, one more wouldn't hurt.
08:11:29 <ksf> yay 2500 lines of type errors
08:12:01 <dispyfree> "not in scope: sort" :(
08:12:14 <nand`> import Data.List (sort)
08:12:16 <nand`> shouldn't it be Prelude?
08:12:40 <rwbarton> somehow i doubt that adding nonsemantic hacks to the Exp type will make your hell easier rather than harder
08:14:15 <Taneb> is there anything like foo :: a -> [(a -> Bool, b)] -> Maybe b anywhere
08:14:17 <Taneb> foo x = fmap snd . find (`fst` x)
08:15:20 <Catnaroek> @djinn a -> [(a -> Bool, b)] -> Maybe b
08:15:21 <lambdabot> Error: Undefined type []
08:15:53 <ksf> rwbarton, you try having folds result in non-monoids.
08:16:31 <Catnaroek> @pl foo x = fmap snd . find (`fst` x)
08:16:31 <lambdabot> foo = (fmap snd .) . find . flip fst
08:16:42 <ksf> ...I end up writing lots of explicit recursions because fold just won't do it.
08:16:57 <bitonic> what's the status of the improved haskell-mode? does it do what ghc-mod does?
08:17:38 <ksf> bitonic, it's gotten really great.
08:17:43 <rwbarton> i don't like non-monoidal folds either
08:17:49 <ion> The improved haskell-mode?
08:17:55 <rwbarton> what kind of code are you generating? more complicated than "f x1 x2 ... xn" i guess?
08:17:57 <ksf> install it with M-X-C-V-launchvim
08:18:08 <ksf> *a little bit*.
08:18:14 <MostAwesomeDude> @djinn a -> [a -> (Bool, b)] -> Maybe b
08:18:14 <lambdabot> Error: Undefined type []
08:18:16 <ksf> I'm having a go at xcb.
08:18:18 <MostAwesomeDude> Curious.
08:18:28 <nand`> djinn doesn't like recursive types afaik
08:18:49 <MostAwesomeDude> Understandable.
08:18:51 <Catnaroek> nand`: Yeah, I forgot that.
08:18:52 <rwbarton> f x ys = Nothing -- you're welcome
08:18:58 <ksf> rwbarton, http://hpaste.org/70374
08:19:01 <MostAwesomeDude> Heh.
08:19:42 <geekosaur> that should be lookupBy...
08:20:39 <rwbarton> well those huge `mappend` chains are all foldl1s aren't they
08:20:57 <nand`> geekosaur: indeed, sadly it doesn't exist
08:21:11 <ksf> yep. it gets more complex when it comes to filtering out the monadic stuff, and the range checks.
08:21:14 <geekosaur> yeh, my comment was a grump
08:21:47 <ksf> or just the compiled exField expressions vs. the nearly identical expressions in the error strings
08:21:57 <nand`> geekosaur: introduce it; save lives
08:22:02 <ksf> (those are actual expressions, the ones at hand just happen to be simple)
08:22:03 <rwbarton> i can imagine the name generation part is a pain
08:22:11 <ksf> nah, that's just a monad.
08:22:19 <rwbarton> yes
08:23:35 <ksf> a concrete example: go (FieldRef x) = varI "length" `App` (maybe (accessor x) ((accessor x `App`) . varI) mstruct)
08:24:26 <ksf> with mempty, there'd be no need for the accessor function and mentioning it twice.
08:26:22 <Taneb> @src find
08:26:22 <lambdabot> find p          = listToMaybe . filter p
08:27:00 <rwbarton> perhaps you should just write an n-ary appMany :: Expr -> [Expr] -> Expr
08:27:12 <Taneb> @pl \x -> fmap snd . listToMaybe . filter (`fst` x)
08:27:12 <lambdabot> ((fmap snd . listToMaybe) .) . filter . flip fst
08:27:28 <ksf> that sounds sensible, yes.
08:29:00 <ksf> yay the errors are down to 1000 lines missing instances.
08:37:43 <kallisti> hpc: oh...
08:37:49 <kallisti> so hsmagick is actually completely broken
08:37:56 <kallisti> it uses unsafePerformIO incorrectly.
08:38:02 <kallisti> I get corrupt memory errors when I attempt to use it.
08:49:13 <srhb> kallisti: You're not the first to realize this in recent weeks.
08:50:10 <kallisti> if the library was rewritten without the unsafePerformIO I could create a high-level interface..
08:50:39 <kallisti> srhb: wasn't someone asking if evaluate . unsafePerformIO = id  or something?
08:50:49 <kallisti> I'm now wondering I can use evaluate to ununsafePerformIO :P
08:50:52 <kallisti> +if
08:51:01 <srhb> kallisti: Um.. :P Not sure.
08:51:17 <kallisti> time to find out!!! :D :D :D
08:51:46 <srhb> Perfect pastime for a sunday :-)
08:52:00 * kallisti is working right now. :P
08:52:33 <kallisti> I imagine if that part of the library is broken then the whole thing is completely broken
08:52:42 <kallisti> it probably mutates the original image or something.
08:52:59 <srhb> Recalling the conversation from a week ago, I believe it is indeed completely broken.
08:53:23 <linduxed> you can't do the ruby style function names ending with question marks right?
08:53:28 <kallisti> bah
08:53:31 <kallisti> linduxed: nope
08:53:32 <linduxed> like "continue?"
08:53:36 <linduxed> kallisti: ok
08:53:40 <linduxed> just checking
08:53:43 <kallisti> ? is a symbolic name
08:53:49 <kallisti> so it's used in infix operators
08:54:10 <kallisti> srhb: I'm tempted to write my own imagemagick bindings. :P
08:54:44 <srhb> kallisti: We could bake you a cake and call you a hero. :-)
08:54:59 <rwbarton> > let emptyʔ = null in emptyʔ []
08:54:59 <lambdabot>   True
08:55:13 <rwbarton> looks awful in my font
08:55:18 <srhb> Same
08:56:42 <hanDerPeder>  can any one tell me what this encoding is 4\160\&294\160\&967\160\&296? was expecting 4 294 967 296.
08:57:08 <rwbarton> those are probably latin-1 nonbreaking spaces
08:57:26 <kallisti> srhb: (?????)
08:57:31 <rwbarton> or if those are unicode code points, unicode nonbreaking spaces
08:57:50 <rwbarton> > printf "%04X" 0x160 :: String
08:57:51 <lambdabot>   "0160"
08:57:52 <srhb> kallisti: I mean, if you do write new imagemagick bindings. :P
08:57:55 <nand`> technically unicode nonbreaking spaces since haskell characters are defined as unicode, right
08:57:56 <rwbarton> > printf "%04X" 0160 :: String
08:57:57 <lambdabot>   "00A0"
08:58:14 <hanDerPeder> rwbarton: thanks, any standard haskell functions that handles the conversion?
08:58:29 <rwbarton> yeah, i thought at first it was a string of bytes since hanDerPeder asked about encoding but from the \& I can see it must actually be text
08:58:35 <monochrom> yeah, looks like "4 294 967 296" where each space is U+00A0 instead
08:58:46 <rwbarton> map (\c -> if c == '\160' then ' ' else c)
08:58:54 <hanDerPeder> thanks
08:59:03 <nand`> oh, I thought there were quotations around that but yeah, \& sounds like haskell strings
08:59:19 <hanDerPeder> so the \& is a haskell thing?
08:59:26 <rwbarton> yes
08:59:31 <nand`> > text "4\160\&294\160\&967\160\&296"
08:59:32 <lambdabot>   4
08:59:35 <rwbarton> > map ord "4\160\&294\160\&967\160\&296"
08:59:36 <lambdabot>   [52,160,50,57,52,160,57,54,55,160,50,57,54]
08:59:40 <nand`> text doesn't like non-breaking spaces?
08:59:48 <hanDerPeder> aha, i see
08:59:55 <monochrom> > "4 294 967 296"
08:59:55 <rwbarton> \160\&2 is used to distinguish from \1602
08:59:55 <lambdabot>   "4\160\&294\160\&967\160\&296"
09:00:04 <rwbarton> \& means the empty string
09:00:18 <kallisti> srhb: have strongly worded emails already been sent to the author. :P
09:00:21 <hanDerPeder> ok, thanks
09:00:34 <srhb> kallisti: I'm not sure. :-)
09:00:41 <rwbarton> if you are okay with outputing nonbreaking spaces then you can just putStr the string you have
09:00:50 <\rs> how to convert Data.ByteString.Lazy.Internal.ByteString to Data.ByteString.Internal.ByteString
09:01:11 <rwbarton> i didn't check in your original question whether the spaces were normal ones :)
09:01:55 <rwbarton> the \& stuff is produced by show
09:01:58 <nand`> \rs: concat . toChunks
09:01:59 <kallisti> \rs: toChubks
09:02:17 <mauke> BS.concat . BL.toChunks
09:02:19 <nand`> (that's BS.concat and LBS.toChunks, mind)
09:02:27 <kallisti> SBS.concat . LBS.toChunks
09:02:30 <kallisti> >_>
09:03:20 <\rs> thx
09:03:20 <nand`> (the reverse is LBS.fromChunks . return, equivalently)
09:03:22 <hanDerPeder> rwbarton: thanks for the info :)
09:04:19 <\rs> the nuance of lazy/strict ones always baffles me as they bare the same names
09:05:03 <kallisti> srhb: this library apparently has test cases...
09:05:11 <kallisti> do they pass?
09:05:20 <kallisti> through what sorcery..
09:05:46 <rwbarton> \rs: if you find yourself converting lazy bytestring to strict then perhaps you should consider whether you could produce a strict bytestring in the first place
09:06:05 <kallisti> rwbarton: usually when I end up doing so it's because the libraries I'm using force me to use or the other.
09:06:13 <nand`> rwbarton: he might be interfacing different libraries that work with different versions of the ByteString
09:06:16 <rwbarton> right, but sometimes the library gives you the option
09:06:52 <rwbarton> of course people who already know how to convert lazy bytestring to strict will not pick the wrong option, but ... :)
09:07:17 <nand`> what, people who can use hoogle?
09:08:00 <hpaste> xhb annotated “xhb” with “xhb (annotation)” at http://hpaste.org/70374#a70376
09:09:46 <\rs> rwbarton: because i'm forced to use the lazy one... Filesystem.Path.CurrentOS.encode
09:10:37 <hpc> kallisti: :( (at the ping; i was afk for a while)
09:10:47 <rwbarton> that function appears to produce a strict bytestring
09:10:53 <\rs> i'm curious why it does not produce a strict one as most paths processed are rather short
09:11:06 <kallisti> for now I'm just going to use the imagemagick command line tools
09:11:08 <rwbarton> i was curious too
09:11:15 <kallisti> and then alter I'm going to write a proper imagemagick binding.
09:11:16 <rwbarton> for that reason
09:11:17 <kallisti> *after
09:11:18 <\rs> less than tens of characters
09:11:32 <rwbarton> but in fact as far as I can tell it does produce a strict one (http://hackage.haskell.org/packages/archive/system-filepath/0.4.6/doc/html/Filesystem-Path-CurrentOS.html)
09:11:57 <rwbarton> if you click the link for 'ByteString' it takes you to Data.ByteString, not Data.ByteString.Lazy
09:14:03 <dispyfree> http://pastebin.com/8u07dZAK << again quite cumbersome :X
09:14:06 <mauke> The paste 8u07dZAK has been copied to http://hpaste.org/70377
09:14:18 <dispyfree> It's really hard to wrangle with the types in the beginning ^^
09:14:32 <mauke> you do not want to call length
09:14:42 <\rs> mea culpa..
09:14:54 <rwbarton> why not match the short case with a pattern match and then get rid of the guar
09:14:57 <rwbarton> d
09:15:00 <Taneb> dispyfree, if you change (x:_) to [x] and move it up a line, you don't need the guard at all
09:15:03 <mauke> it's inefficient and flat out doesn't work on infinite lists
09:17:03 <dispyfree> @Taneb: thanks! so [x] is for a list with one element and (x:xs) for the rest?
09:17:04 <lambdabot> Unknown command, try @list
09:17:12 <dispyfree> and (x:_) works for both?
09:17:16 <Taneb> dispyfree, precisely
09:17:22 <Taneb> Also, stop it with the @s
09:17:23 <applicative> dispyfree: you dont need length, and equality tests should be avoided
09:17:26 <rwbarton> maybe hlint should warn on patterns like length (...) >= (...)
09:17:39 <dispyfree> oh shit sorry :X
09:17:51 <rwbarton> (x:xs) is the same as (x:_) except it names the rest of the list xs
09:18:06 <rwbarton> (x:xs) can have one element
09:18:09 <rwbarton> or it can have more
09:18:25 <rwbarton> (since xs could be [] or a non-empty list)
09:18:26 <applicative> dispyfree: you can also make patterns like (x:y:zs)
09:18:43 <rwbarton> but if you have a match for [x] first, then when you reach (x:xs) later it will always be a list of two or more elements
09:19:19 <holzensp> bitonic: It took a while, but I finally think I understand how tcMatchTy really works
09:19:40 <holzensp> bitonic: Both type arguments must not be quantified (higher-rank types are TODO)
09:20:02 <holzensp> bitonic: and the varset must have all the variables of the first type argument
09:20:14 <dispyfree> applicatve so the first two variables are lists of length 1 and zs comprises the rest?
09:20:18 <holzensp> bitonic: I thought I would share my findings… thanks for the tips
09:20:43 <rwbarton> http://hpaste.org/70378
09:21:00 <rwbarton> interesting it knows about "length xs == 0" but not "xs == []"
09:21:40 <holzensp> rwbarton: For "xs == []" the elements must be instances of Eq
09:21:50 <rwbarton> that's true
09:22:05 <rwbarton> however "length xs == 0" and "null xs" do not even have the same dynamic semantics ;)
09:22:23 <holzensp> no, because length doesn't necessarily terminate
09:22:32 <rwbarton> so suggesting "xs == []" with "null xs" would be good i think
09:22:34 <rwbarton> in the same way
09:22:41 <rwbarton> er, suggesting replacing
09:22:54 <Taneb> kallisti, I'm not sure how much of a need there is for this, but in Control.Conditional, could you add something like foo :: a -> [(a -> Bool, b)] -> Maybe a; foo x = fmap snd . find (`fst` x)
09:23:50 <holzensp> rwbarton: Yes, precisely because length is more dangerous than null *and* it's just not very FP to check whether a list is empty by checking whether its length is 0
09:24:18 <holzensp> rwbarton: In general, you don't want to check properties of a thing by checking properties of properties of the thing ;)
09:24:19 <rwbarton> i guess xs == [] isn't nearly as bad, yeah
09:24:46 <holzensp> well xs==[] is still a bit bad, since it adds a constraint
09:25:06 <holzensp> but at least it has the same termination behaviour and it is quite expressive
09:25:12 <kallisti> Taneb: (`fst` x) ?
09:25:16 <rwbarton> also (see annotation) hlint knows about "length xs /= 0" but not "length xs > 0"
09:25:23 <holzensp> bearing in mind that most programs are read by people more than by computers
09:25:26 <Taneb> kallisti, the implementation is correct and works
09:26:01 <Taneb> find is in Data.List and is (a -> Bool) -> [a] -> Maybe a
09:26:14 <kallisti> ah I see what (`fst` x) does
09:26:25 <kallisti> I would flip the arguments.
09:26:41 <rwbarton> probably change the name too ;)
09:27:09 <holzensp> hehehe, yes
09:27:24 <Taneb> flipping the arguments makes it harder to write half-pointlessly
09:27:27 <rwbarton> it works a bit like case i guess
09:27:36 <kallisti> Taneb: then I don't understand the purpose
09:27:50 <Taneb> But that's a silly reason to object
09:28:08 <holzensp> rwbarton: what would you say to "null (drop 3 xs)"
09:28:14 <kallisti> in my mind you're more likely to explicitly specify the condition list and select based on some other data
09:28:35 <kallisti> as opposed to applying a constant value to some changing list f type [(a -> Bool, b)]
09:28:38 <Taneb> Yeah, I just made it that way round to make it easier to write the function
09:28:47 <rwbarton> holzensp, i would be a bit annoyed that there wasn't a better to write it
09:28:55 <kallisti> Taneb: well that's what I meant by flipping the arguments.
09:28:57 <kallisti> oh I see.
09:29:03 <kallisti> you meant /writing/ it pointlessly
09:29:04 <kallisti> not using it.
09:29:25 <holzensp> myeah, also… it also matches the cases where the list has less than three elements
09:29:42 <rwbarton> yeah i don't even know what hlint could suggest for "length xs == 3"
09:29:45 <kallisti> Taneb: I believe selectM almost has the type you want here.
09:29:49 <kallisti> hm, no.
09:30:16 <holzensp> rwbarton: Ideally, it would recognise that the entire function is best replaced by pattern matching
09:30:42 <rwbarton> I think sometimes it does say things like "Consider pattern-matching"
09:31:13 <holzensp> rwbarton: or at least that t2 and t3 are equivalent (especially because of the warning it gives about line 3)
09:31:37 <holzensp> and, thus, that t2 || t4 is a tautology
09:32:24 <holzensp> although…. that being said…. it's probably because you can overload both == and /= that it can't in general
09:32:48 <holzensp> because it doesn't need to hold that == is equivalent to \a b -> not (a /= b)
09:33:33 <kallisti> Taneb: I believe condM does something similar
09:34:20 <kallisti> the difference being that it's [(a -> Bool, a -> b)] -> a -> b
09:36:04 <Taneb> Hmm
09:37:05 <kallisti> Taneb: I mean, I could add it. but I don't want too many weird specializations.
09:37:23 <Taneb> kallisti, hmm
09:37:49 <DexterLB> I want to convert the string "HH:MM:SS" to seconds. I came up with a function that works, but I'm a noob at haskell, so I'm sure I've broken quite a lot of rules
09:37:51 <hpaste> DexterLB pasted “hhmmssToInt” at http://hpaste.org/70381
09:38:10 <DexterLB> can I have some critics please? :)
09:38:50 <hpc> i wouldn't have used regexes
09:38:53 <holzensp> DexterLB: Does it need to check that the string has the right format?
09:38:58 <hpc> but if it works, you clearly know regexes better than i do
09:39:02 <DexterLB> holzensp: nope
09:39:07 <hpc> (in haskell at least)
09:39:10 <holzensp> DexterLB: Or do you know the string has the right format and you just want the seconds?
09:39:25 <nand`> I would generalized it to ... x₃:x₂:x₁ where x_n = 60 * x_(n-1)
09:39:29 <nand`> generalize*
09:39:36 <DMcGill__> so I have a newtype of Kleisli IO and am using newTypeDeiriving to get all of the Kleisli classes.
09:39:36 <DMcGill__>  However, when I remove Control.Monad.State from my imports I get an error "no instance for (MonadPlus IO)"
09:39:37 <nand`> or perhaps make 60 free
09:39:52 <DMcGill__> importing Control.Monad, Control.Monad.Fix and Control.Monad.Trans doesn't fix it
09:40:17 <DMcGill__> Control.Monad.State exports those three modules and doesn't contain MonadPlus anywhere
09:40:17 <DMcGill__> what is going on?
09:40:18 <applicative> DexterLB: somehow I think regexes are not appropriate
09:40:19 <hpc> DMcGill__: deriving ArrowPlus?
09:40:29 <DMcGill__> yes
09:40:30 <holzensp> DexterLB: because if you know that the string always has the right format "HH:MM:SS", I would just say "drop . drop 6"
09:40:34 <hpc> there's your problem
09:40:47 <holzensp> DexterLB: Sorry, typo…. "read . drop 6"
09:40:48 <hpc> DMcGill__: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Arrow.html#v:Kleisli
09:40:55 <hpc> DMcGill__: notice the instances list
09:41:10 <DMcGill__> it works just fine if I import "Control.Monad.State" though
09:41:15 <nand`> I think he's trying to convert it to the number of seconds since 00:00:00, not ignore the hour/minute part
09:41:45 <rwbarton> stringToSeconds [h1,h2,':',m1,m2,':',s1,s2] = 3600 * read [h1,h2] + 60 * read [m1,m2] + read [s1,s2]
09:41:57 <monochrom> ghci can tell you where do instances come from --- if the instance is loaded. ":info IO"
09:41:57 <DexterLB> holzensp: oh?
09:42:04 <hpc> DMcGill__: maybe some insane combination of instances combine to get MonadPlus IO
09:42:19 <nand`> ugh, why don't we have wordsBy in prelude
09:42:20 <holzensp> DexterLB: Sorry, rwbarton is right… you wanted the total number of seconds
09:42:32 <DexterLB> holzensp: ah. See what you meant there
09:42:44 <DexterLB> rwbarton: that's nice
09:42:46 <monochrom> for example ":m + Control.Monad.State" and then ":info IO". you will see "instance MonadPlus IO -- Defined in Control.Monad.Trans.Error"
09:43:11 <hpc> nand`: sepBy?
09:43:27 <hpc> er, no
09:43:40 <hpc> wow, that's annoying
09:44:14 <holzensp> DexterLB: and if you need to do some more complicated stuff in future, leave your Perl-days behind you, forget about regular expressions and look into parser combinators ;)
09:44:15 <nand`> sepBy works, how does this differ from splitOn?
09:44:31 <nand`> oh, it's from .Internals
09:44:39 <nand`> so is splitOn though
09:44:49 <holzensp> DexterLB: Parsec is quite nice http://www.haskell.org/haskellwiki/Parsec
09:46:34 <DMcGill__> I see now: Control.Monad.State exported Control.Monad.Trans which exported Trans.Error
09:46:34 <DMcGill__> thanks
09:48:09 <applicative> DexterLB: the excellent  `split` package has some nice functions that are continuous with Data.List but make slightly regexy things easy, if parsec seems to strange  or whatever
09:48:44 <applicative> DexterLB: http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
09:48:46 <nand`> hhmmssToSeconds = sum . zipWith (*) (map (60^) [0..]) . reverse . map read . sepBy ":"
09:48:48 <nand`> bonus points for being point-free
09:49:18 <nand`> oh, and my function works for mm:ss and just ss too
09:49:18 <holzensp> DexterLB: I agree with applicative
09:49:33 <DexterLB> nand`: that was epic.
09:50:36 <nand`> bonus points: use maybeRead instead of read
09:50:51 <nand`> (left as an exercise to the reader)
09:51:49 <rwbarton> what sepBy is that?
09:51:54 <monochrom> http://www.vex.net/~trebla/haskell/reads.xhtml
09:51:54 <nand`> rwbarton: Data.List.Split
09:51:58 <DexterLB> I really have to get used to that f . g . h syntax
09:52:06 <hanDerPeder> is there a migration guide from OldException to Exception?
09:52:17 <rwbarton> oh somehow i was expecting split to be in hoogle's default packages
09:52:27 <nand`> silly hoogle
09:52:49 <nand`> but really, we need splitOn/splitBy in Prelude
09:53:00 <nand`> with ‘words’ defined in terms of them
09:53:41 * hackagebot git-annex 3.20120624 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120624 (JoeyHess)
09:54:09 <timthelion> Is there a particular reason that Haskell didn't use the dot syntax(AKA foo.bar) for record selection, like in every other language?  Is it just to highlight the "functionalness" of record selection?
09:54:26 <nand`> I would guess because of conflicts with the existing .
09:54:34 <timthelion> aj
09:54:34 <timthelion> ah
09:54:46 <nand`> (then again, it seems to work fine for qualified namespaces)
09:54:55 <holzensp> nand`: http://hackage.haskell.org/trac/ghc/ticket/3671
09:55:11 <timthelion> nand`: but there you have case to destinguish the symbols.
09:55:13 <rwbarton> it's nice that you don't have to write \foo -> foo.bar
09:56:35 <nand`> oh, I was thinking you meant Type.bar
09:56:43 <nand`> yeah, foo.bar for accessing would be silly
09:56:46 <nand`> nothing is gained over “bar foo”
09:57:31 <nand`> besides, changing “foo.bar” to mean “bar foo” would break lots of golf
09:57:35 <sipa> (.bar) foo
09:57:56 <nand`> (and lots of non-golf as well)
09:57:57 <timthelion> other than consistency with every other language ever written :)  I was thinking about this last night.  Haskell is the ONLY programming language I have ever come across that I couldn't read and understand on day one.
09:58:26 <mauke> not every other language
09:58:32 <DexterLB> timthelion: tried lisp? :)
09:58:33 <mauke> perl has an infix . operator as well
09:58:34 <rwbarton> haskell has much simpler syntax than most other languages
09:58:39 <timthelion> DexterLB: of course :)
09:58:40 <mauke> zomg
09:58:46 <mauke> *lisp* has an infix . operator!
09:58:51 <sipa> extracting a value from a record is something that feels like a function, so why use anything but function syntac for it?
09:58:55 <holzensp> timthelion: Try J, whitespace, INTERCAL, etc.
09:59:11 <nand`> to me, “bar foo” makes much more sense than “foo.bar”; haskell is not object oriented - bar doesn't “belong” to foo
09:59:13 <kallisti> sipa: pattern matching on records can be pretty powerful
09:59:13 <timthelion> holzensp: J, haven't heard of that one :)
09:59:19 <nand`> that syntax is usually encountered in OOP languages
09:59:28 <holzensp> timthelion: Derived from APL… also: APL ;)
09:59:31 <rwbarton> I want f 3 = 6 and f 4 = 8 so I write "f x = 2 * x", compare to "int f(int x) { return 2 * x; }"
09:59:55 <nand`> f = (*) 2
09:59:59 <nand`> pointless bouns points
10:00:01 <nand`> never forget
10:00:03 <nand`> bonus*
10:00:10 <nand`> ..hehe.. pointless points
10:00:13 <holzensp> rwbarton: The thing is… Haskell makes programming look easy :p
10:00:14 <timthelion> nand`: pointless bogus points maybe.
10:00:41 <xpololz> when making new user-defined types in Haskell, everything before the '=' is a called a type constructor, and everything after is data constructors, right?
10:00:43 <monochrom> I think the BASIC and C "X = X + 1" is what you couldn't understand on day one
10:00:57 <holzensp> rwbarton: Also… functional syntax is so much simpler that a lot of people who are used to typing half their programs with their shift-key start depending on superfluous structure
10:01:06 <nand`> yeah, clearly all our imperative programs should be "X' = X+1"
10:01:09 <kallisti> xpololz: the uppercase word at the beginning is the type constructor
10:01:14 <kallisti> but yeah you've got the idea.
10:01:28 <nand`> line 5000 of random-C-application: X'''''''''''''''''''''''''''''''''''''' = X''''''''''''''''''''''''''''''''''''' - 50;
10:01:33 <xpololz> hmm, alright ty
10:01:59 <holzensp> monochrom: Haskell: "let x = 5 in let x' = x + 1 in let x = x' + 1...."
10:02:21 <holzensp> nand`: SSA-a-go-go
10:02:28 <timthelion> monochrom: I don't know.  I find mutability to be quite easy to understand.  Despite the risk of horrible bugs.  If I drop a mug on the ground and it breaks, I do not have a new broken mug, I have the same old mug, just broken into little peices.
10:02:41 <daniel_-> god damnit, why does random have to be so hard
10:02:51 <monochrom> mutability is quite easy to understand with "X := X + 1". see what I mean?
10:03:39 <holzensp> timthelion: The point is mostly equational reasoning. Side-effects aside (although it usually is quite a religious topic), the ability to do equational reasoning is quite important to the Haskell syntax
10:03:40 <timthelion> daniel_-: just hard code in a seed and publish it closed source, no one will know the difference...
10:04:09 <monochrom> my point is that haskell is the only language you don't understand on day *two*. you already spent day one on C.
10:04:28 <kallisti> timthelion: imagine immutability as time travel then;  you can move forward to the point where the mug is broken, but you can also reach back in time and grab the intact mug.
10:04:38 <nand`> daniel_-: what do you mean?
10:04:52 <timthelion> kallisti: I'll do that :)
10:04:57 <kallisti> that's basically what persistent data structures affords you.
10:04:57 <daniel_-> the only thing i've read of random is in the learnyouahaskell book
10:05:08 <daniel_-> i just want a random number between 1000 - 9876
10:05:20 <nand`> randomRIO (1000, 9876)
10:05:29 <nand`> is the easiest way to get one if all you want to do is hack around in ghci
10:05:35 <hiptobecubic> Is anyone here actually using yi?
10:05:42 <nand`> hiptobecubic: I tried earlier, incidentally
10:05:55 <daniel_-> well the thing is i want it to be random everytime i call it
10:06:00 <daniel_-> from my program
10:06:05 <holzensp> hiptobecubic: I tried it ages ago, but my fingers are too used to vim ;)
10:06:05 <hiptobecubic> nand`, yeah i can't figure out... well... anything
10:06:06 <srhb> daniel_-: It is, if you use randomRIO
10:06:24 <hiptobecubic> in the cabal file it notes that there are vim bindings... which are apparently broken
10:06:34 <monochrom> randomRIO (1000, 9876) works here
10:06:39 <daniel_-> okay thanks :)
10:06:54 <timthelion> > randomRIO (1,5)
10:06:56 <lambdabot>   <IO Integer>
10:06:59 <timthelion> :)
10:07:01 <srhb> daniel_-: You can also use randomIO, which updates the random generator itself, afaik
10:07:21 <srhb> (But you can't set bounds then)
10:07:25 <nand`> srhb: randomIO is the same as randomRIO except the latter accepts a range
10:07:28 <hanDerPeder> when I need to pieces of state, one read only and one modifiable, is it common to State+Reader or just lob both into State?
10:07:30 <nand`> do you mean random and randomR?
10:07:33 <holzensp> hiptobecubic: My experience (but again; a while ago) was the same as with any "just like vim" editor; "just like core-vi, maybe, but nowhere near vim"
10:07:40 <nand`> those are the ones that update a generator
10:07:44 <srhb> nand`: Ah, I thought both were differences between the two.
10:07:57 <kallisti> hanDerPeder: it largely depends on the complexity of the application. Both would be sufficient.
10:08:44 <hanDerPeder> kallisti: ok, can I interpret that as using State only would be easier (I'm very new to Haskell)
10:09:06 <timthelion> hasn't someone made a random seeded purely functional random number generator yet?  It should be pretty easy, just randomly generate seed n, and then take the n'th digit of pi, and add one to n every time you need another number...
10:09:16 <timthelion> for sufficiently large values of n
10:09:28 <kallisti> hanDerPeder: not necessarily. If you put 2 pieces of state into a record now you need different functions to conveniently access each part
10:10:03 <kallisti> hanDerPeder: say you have a read-only file Handle and a modifiable Integer. if you used ReaderT and StateT you could use ask to get the Handle and get to get the Integer
10:10:06 <monochrom> try both. see how the code looks like.
10:10:11 <nand`> ReaderT a (State b) can be easier than State (a,b) since you don't need to use “first/fst” and “second/snd” everywhere
10:10:12 <hiptobecubic> holzensp, sure it won't be vim, i just want vim bindings to move up and down at least
10:10:23 <kallisti> hanDerPeder: if you were only using State you would need to use a tuple or a record, and now your code is more complicated.
10:10:52 <nand`> the type is just a bit larger, but you can easily add a type alias for that: type RST r s m = ReaderT r (StateT s m); RS r s = RST r s Identity
10:10:54 <daniel_-> how do i unmonad a IO Integer?
10:10:58 <timthelion> hiptobecubic: it's funny, how users of vim cannot use normal computer programs, and non vim users can't use vim :)
10:11:02 <hanDerPeder> kallisti: I see, your example is pretty much exactly my use case. state+reader it is then
10:11:03 <holzensp> timthelion: Random generators are notoriously performance critical around their state; RAND and SAT are two thing where functional programming will lose out to C for a Long Time
10:11:06 <kallisti> daniel_-: you don't
10:11:16 <nand`> unsafePer---
10:11:18 * nand` hides
10:11:31 <daniel_-> so no easy way to get IO a -> a
10:11:32 <holzensp> hiptobecubic: I see your point, but I've gotten used to navigating and ranging commands using '/' *everywhere*
10:11:32 * timthelion throws a bomb at nand` 
10:11:34 <srhb> daniel_-: You use the unwrapped value after a >>= and then wrap it again with return if need be
10:11:39 <nand`> daniel_-: right
10:11:41 <srhb> daniel_-: No, that would destroy Haskell entirely
10:11:41 <holzensp> hiptobecubic: just as an example; there's more
10:11:43 <hiptobecubic> timthelion, sure we can. We just prefer to use key bindings that aren't terrible.
10:12:00 <kallisti> daniel_-: for an example of why that's a bad idea see the source code of hsmagick. :)
10:12:18 <nand`> daniel_-: the only way to work with an IO action is to lift everything else you want to do to it into the monad (eg. using bind or fmap). Then, the only way to execute the resulting action is to define main as it
10:12:19 <hiptobecubic> holzensp, yes of course. I am just assuming that there will be some other redeeming feature of yi, otherwise why would it have been written? It must do *something*
10:12:24 <hanDerPeder> nand`: thanks for the example
10:12:41 <timthelion> hiptobecubic: I don't know.  I've been using vim myself, and I find I accidently quit out of dialogs that use ESC for quit, and end up with random hjkl's every where when I type in a standard text box.
10:13:13 <holzensp> hiptobecubic: Sure… I've actually tried quite a few times to learn emacs, because it does one critical thing far better than vim, i.e. communicating with other processes
10:13:22 <timthelion> hiptobecubic: perhaps just to show that they could write it in haskell?
10:13:47 <hiptobecubic> timthelion, yes, but that's normal because vim has reasonable key bindings and everything else doesn't. It's just a question of muscle memory
10:13:51 <holzensp> hiptobecubic: unfortunately, nobody told my fingers that ;) Also, there are some vim-mode projects, but the concepts don't always translate… I caused a mess with split screens
10:13:55 <hiptobecubic> Try using even the SAME program, on windows and linux
10:14:09 <hiptobecubic> all the normal shortcuts are just totally fucked. it's hopeless
10:14:16 <nand`> timthelion: as long as you don't get into the habit of using <C^c> as <Esc>
10:14:48 <timthelion> hiptobecubic: and you can never find the preferences dialog :)
10:14:48 <hiptobecubic> Matlab is the biggest offender I can think of off the top of my head.
10:14:55 <nand`> <C-c>, even; I can never remember the vim syntax for that
10:15:04 <DexterLB> nand`: been looking into your function.. shouldn't it be sum $ zipWith instead of sum . zipWith? also [0..] instead of [1..]
10:15:48 <hiptobecubic> "Preprocessing library gtk-0.12.3.1" is a lengthy procedure....
10:16:30 <nand`> DexterLB: it is [0..] in my function; and no, it should be sum .
10:16:43 <nand`> or were you asking why it is [0..] and not [1..]?
10:16:55 <nand`> if so, because the right-most side is seconds, and to get from seconds to seconds it's *1 and 60^0 = 1
10:23:31 <hpaste> daniel_- pasted “im lost” at http://hpaste.org/70384
10:23:41 * hackagebot punycode 0.5 - Encode unicode strings to ascii forms according to RFC 3492  http://hackage.haskell.org/package/punycode-0.5 (MylesMaxfield)
10:27:06 <monochrom> why is rfs taking two string parameters? shouldn't one of them be integer?
10:27:12 <srhb> It should
10:27:19 <nand`> “r * 10 - r” again this, why not “r * 9”? :(
10:27:21 <srhb> And line 43 is weird
10:27:30 <daniel_-> well the thing is if the answer is 0935
10:27:37 <srhb> ah
10:27:39 <daniel_-> the leading zero wont be taken in account for
10:27:52 <daniel_-> line 43 is the last thing i tried
10:27:58 <daniel_-> just to see if it might have worked
10:28:03 <daniel_-> since thats where im kinda lost
10:28:03 <srhb> then 43 should be let repr = rfs (show answer) g
10:28:09 <monochrom> well the thing is Integer does not care about 0935 vs 935
10:28:43 <hiptobecubic> well yi apparently just segfaults
10:28:46 <hiptobecubic> so no points there
10:29:02 <nand`> I wonder why hlint doesn't throw up the usual “redundant do” etc. errors on that paste
10:29:10 <hpaste> srhb annotated “im lost” with “im lost (annotation)” at http://hpaste.org/70384#a70385
10:29:11 <nand`> hiptobecubic: for what?
10:29:18 <srhb> Now it type checks
10:29:21 <srhb> Whether it works, no clue
10:29:22 <srhb> :-)
10:29:42 <srhb> Woops
10:29:46 <srhb> I somehow nuked all uppercase chars
10:30:09 <monochrom> yeah, how would that typecheck? :)
10:30:12 <hpaste> srhb annotated “im lost” with “im lost (annotation) (annotation)” at http://hpaste.org/70384#a70386
10:30:25 <nand`> agh, now I can't get a diff
10:30:51 <daniel_-> shouldn't "putStrLn "PSST answer is: " ++ (show answer)"
10:30:53 <daniel_-> work?
10:31:10 <nand`> daniel_-: precedence error
10:31:17 <srhb> daniel_-: putStrLn doesn't take that many arguments
10:31:21 <nand`> putStrLn ("PSST answer is: " ++ show answer)
10:31:23 <daniel_-> oh
10:31:40 <nand`> srhb: that's not the issue here
10:31:50 <srhb> nand`: Hmm?
10:32:04 <nand`> the issue is IO () is lacking Monoid and Num constraints
10:32:05 <monochrom> haskell is not a do-what-I-mean language
10:32:17 <nand`> that would be (putStrLn "PSST answer is: ") ++ (answer)
10:32:28 <nand`> s/constraints/instances/
10:32:37 <srhb> ah, yes, answer should be show'ed anyway
10:32:46 <srhb> So that was not the only issue.
10:32:57 <nand`> oh, and it wouldn't work even if IO () had those instances since rand is IO Integer, not Num n => IO n
10:32:59 <nand`> so nvm
10:33:06 <daniel_-> well i got it kinda working as i wanted it to now :)
10:33:11 <srhb> Clearly if putStrLn :: String -> ([a] -> [a] -> [a]) -> Int -> IO () -- it would be fine
10:33:38 <nand`> srhb: but then daniel_- would have to change his code to putStrLn "PSST answer is: " (++) answer
10:33:51 <daniel_-> putStrLn $ "PSST answer is: " ++ show answer
10:33:59 <nand`> daniel_-: yes that looks right
10:34:02 <srhb> nand`: How is the IO integer an issue in that do block. It's wrapped nicely
10:34:21 * srhb thinks we have ventured onto a tangent
10:34:33 <nand`> srhb: it shouldn't be; I was just poking fun at the fact that if it was Num n => n instead of Integer then you could unify it with IO () given a Num instance for that
10:35:01 <monochrom> instance Random (IO Integer)
10:35:08 <srhb> nand`: Ah, yes. ;)
10:35:22 <hiptobecubic> This is kind of sad :/  http://functionaljobs.com/
10:35:52 <nand`> “Only $99 for a 30 day listing”
10:35:52 <srhb> "only $99 for a 30 day listing"
10:35:54 <srhb> lol
10:35:56 <srhb> gmta
10:36:47 <nand`> monochrom: you'd still need a Num instance
10:36:59 <nand`> due to the range
10:37:06 <monochrom> mine is another tangent
10:37:20 <srhb> There's an abundance of tangents in #haskell
10:37:21 <nand`> “Dream jobs for Functional Programmers” <- clearly, no dream jobs exist
10:37:31 <nand`> I wonder if “Realistic jobs for Functional Programmers” would be better off
10:37:40 <srhb> How about "jobs"
10:37:50 <nand`> that could work
10:38:12 <monochrom> worst dream jobs for functional programmers :)
10:38:27 <nand`> technically, a nightmare job is also a dream job, no?
10:38:33 <monochrom> yes!
10:38:37 <b_> I try to sneak in any Haskell I can at my job
10:39:07 <otters> bad-trip jobs for haskell programmers
10:39:12 <td123> b_: you're also creating job security :)
10:39:19 <otters> elephant pruner
10:39:27 <b_> After replacing a broken billing system in it, I am allowed to do quite a bit more in it
10:39:44 <b_> the last one was written in PHP and ate money
10:39:50 <srhb> Haha
10:40:01 <srhb> I've actually had that happen to a client of mine, too. PHP as well.
10:40:09 * srhb shakes head sadly
10:40:30 <nand`> int main() { /* sneaky code */ shell("runhaskell", " ...
10:40:33 <b_> At work they at one point decided to write webshop functionality in PHP from scratch
10:40:40 <b_> like a year ago
10:40:53 <zomg> Smart plan
10:40:57 <b_> still not finished/broken
10:41:04 <zomg> None of the existing web shops would obviously work
10:41:16 <b_> indeed, open source, baaaah
10:41:25 <nand`> PHP: Your money is now a string. Except now it's an object.
10:41:34 <zomg> lol
10:41:36 <b_> yes nand`
10:41:36 <Peaker> I want something like ugly-memo with a single most-recently-used value cache
10:41:37 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
10:41:50 <zomg> PHP pays my bills sadly
10:41:56 <irene-knapp> mine too :/
10:41:59 <b_> and your boolean is now a number, except it's a string
10:42:05 <otters> that's what PHP is for
10:42:11 <irene-knapp> haha fair enough
10:42:27 <b_> I am teaching our intern Haskell
10:42:27 <nand`> yes. 0 ⇒ "False", 1 ⇒ "True", everything else → "FILENOTFOUND"
10:42:30 <b_> spreading the word
10:42:50 <zomg> I was going to teach our Jr dev Haskell
10:42:55 <zomg> but it looks like the company might be going under
10:42:55 <zomg> :p
10:43:12 <nand`> I am spreading interest in category theory. Sadly I don't think I've convinced anybody yet
10:43:21 <monochrom> good thing to see any PHP-using company go under
10:43:29 <zomg> category theory sounds mathy
10:43:31 <zomg> =)
10:43:43 <b_> monochrom: agree, except when it's your own
10:43:53 <nand`> I figure that once people grasp the true beauty of category theory, they'll approach Haskell naturally
10:43:53 <kallisti> cabal: Couldn't read cabal file "silently/1.2/silently.cabal"
10:43:54 <kallisti> whut
10:44:05 <srhb> nand`: I think that's... backwards. :D
10:44:08 <monochrom> just ship early
10:44:12 <b_> I am a frontend dev, but had to learn our backend PHP programmers what unit testing was
10:44:15 <monochrom> err, jump ship early
10:44:19 <Philippa> nand`: I have a lot of fun explaining my informal interest in it to different people? Arts and humanities people really get the draw of "the maths of analogy", for example
10:44:19 <b_> depressing
10:44:33 <nand`> b_: as long as you don't try showing them quickcheck
10:44:38 <hpc> fleeting thought
10:44:39 <b_> I did
10:44:44 <b_> and then they were depressed
10:44:47 <hpc> :t when -- this type is really damn annoying
10:44:48 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:44:54 <hpc> it should be Bool -> m a -> m ()
10:45:15 <nand`> Philippa: I hadn't even considered that potential appeal; sadly I don't encounter many arts and humanities people
10:45:28 <kallisti> I'm so confused
10:45:42 <kallisti> cabal install http-conduit is complaining that it can't find silently.cabal
10:45:43 <Peaker> hpc, I'd rather values are ignored explicitly
10:45:54 <monochrom> good thing to spread depressing among non-haskell programmers :)
10:46:05 <zomg> Anyone wanna hire me to write haskell? I'm not a pro but I can get around in it =)
10:46:05 <monochrom> s/depressing/depression/
10:46:14 <nand`> Peaker: I think “Bool -> m a -> m ()” is pretty explicit about ignoring values
10:46:24 <b_> monochrom: the intern was ecstatic(sp?) about Haskell though
10:46:52 <b_> he's only been programming for a year
10:47:19 <b_> but groked types, pattern matching, recursion, currying etc, within 3 days
10:47:24 <Peaker> nand`, No:   when useGlfw GLFW.initialize    -- oops, <-- this is a bug
10:47:36 * nand` has a feeling he'll end up as the grumpy old guy scoffing at “those damn kids” for misusing the term ‘function’ and showing off their “useless things that have been generalized and implemented in the type system of Haskell decades ago”
10:47:36 <zomg> It would be interesting to see how someone with no programming experience would learn haskell vs someone learning say Java or whatever
10:47:37 <Peaker> nand`, because GLFW.initialize returns a Bool for indicating success/failure (lame, yes)
10:47:51 <zomg> I wonder if I could get funding for researching something like that...
10:47:52 <zomg> =)
10:48:04 <Peaker> So it is nice to get compiler feedback about that Bool that is being ignored
10:48:04 <nand`> zomg: I have been very, very curious about the same thing
10:48:07 <kallisti> uh... guys
10:48:09 <kallisti> cabal emergency
10:48:14 <kallisti> cabal: Couldn't read cabal file "silently/1.2/silently.cabal"
10:48:16 <srhb> zomg: At my CompSci dept. there are actually quite a few students that have never programmed when they start. First course is functional programming.
10:48:17 <Peaker> nand`, by "explicit", the meaning is at the call-site, not in the type
10:48:18 <kallisti> this. always.
10:48:19 <Taneb> TO THE CABALMOBILE
10:48:19 <nand`> I feel Haskell is much more natural to anybody with a mild mathematical background
10:48:24 <Philippa> nand`: so a worrying number of those I know, I basically know via OKCupid? But it's turned out to be a good thing in the long run, too
10:48:45 <nand`> Peaker: I see what you mean
10:49:04 <b_> zomg, nand` the intern I am teaching Haskell to is very bad at maths
10:49:11 <zomg> Me too
10:49:12 <zomg> :p
10:49:15 <nand`> but /me thinks that would just cause lots of ‘void’ to be thrown around eg. when useGlfw (void GLFW.initialize) -- oops, another bug
10:49:21 <Catnaroek> nand`: I have no mathematical background, and Haskell strikes me as much more natural than other languages, despite the fact it is the *last* one I learnt.
10:49:28 <zomg> Well, I'm not *bad* per-se, but I haven't ever studied any more advanced math stuff
10:49:32 <Expez> head . (drop (n - 1) xs) doesn't work, but head $ drop (n-1) xs does. Hoogling $ made it look, to me, like these two forms should be the same. What am I missing?
10:49:40 <b_> well the intern is positively bad at it
10:49:47 <monochrom> wait, why is it "silently/1.2" not "silently-1.2"?
10:49:49 <b_> like far below average
10:49:51 <daniel_-> not in scope 'forever'
10:50:00 <nand`> daniel_-: import Control.Monad (forever)
10:50:01 <zomg> Interesting
10:50:02 <srhb> Expez: (drop (n - 1) xs) is not a function that takes a list
10:50:03 <b_> but he is incredibly fast at learning Haskell
10:50:08 <zomg> They tend to generally say programming requires the sort of understanding math does
10:50:09 <kallisti> http://www.haskell.org/pipermail/haskell-cafe/2011-August/094883.html
10:50:11 <kallisti> it seems to be this bug
10:50:23 <kallisti> but with a different package
10:50:23 <srhb> Expez: (drop (n-1)) is
10:50:40 <monochrom> (head . drop (n-1)) xs
10:50:45 <nand`> srhb: or returns one, rather
10:50:53 <srhb> nand`: Er, yes.
10:50:58 <Philippa> zomg: this is technically true, but for a value of "maths" that has nothing to do with arithmetic
10:50:58 <srhb> I seem to be talking nonsense a lot today.
10:51:03 <monochrom> and I never use $. I use parentheses to show you where the parentheses are
10:51:09 <kallisti> b_: I'm currently using Haskell in my freelance work because I can.
10:51:09 <srhb> nand`: Wait, what.
10:51:12 <kallisti> it's nice.
10:51:16 <daniel_-> how do i break from a forever when the user actually wins?
10:51:18 <Philippa> in fact, it's got as much to do with the kind of linguistic manipulation that languages students are good at, just turned into a different kind of game
10:51:19 <kallisti> too bad the projects suck.
10:51:20 <srhb> :t (.)
10:51:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:51:27 <nand`> “maths” can be surprisingly hard to define
10:51:43 <nand`> I used to say “it's the study of relations”, but since then I have generalized it to “the study of sets” :)
10:51:52 <kallisti> daniel_-: the only way I can think of is to throw an exception
10:51:56 <kallisti> but it sounds like you don't actually want forever.
10:52:03 <zomg> Philippa: yeah
10:52:05 <Catnaroek> nand`: Dijkstra had a very cool definition - "the art and science of effective reasoning".
10:52:08 <nand`> daniel_-: eg. exitSuccess
10:52:11 <kallisti> daniel_-: one approach is to use fix.
10:52:21 <b_> zomg: the biggest quality that makes the intern so good at programming is his ability to hold a complicated progress in his mind
10:52:23 <Expez> srhb, monochrom thanks :)
10:52:31 <Catnaroek> nand`: "Effective" meaning that if you do it correctly, the conclusions at which you arrive simply cannot be wrong.
10:52:33 <nand`> kallisti: that's what he's doing already, if I recall his code correctly
10:52:36 <nand`> except not using the fix combinator
10:52:41 <nand`> but with explicit recursion
10:52:45 <monochrom> http://bm380.user.srcf.net/prettyparsetree.cgi shows you explicit parentheses
10:52:57 <b_> kallisti: sweet, I would like to have Haskell be a bigger part of my job
10:52:59 <kallisti> fix $ \loop -> do {x <- doStuff; unless (victoryCondition x) loop}
10:53:06 <zomg> b_: yeah that is indeed a good quality
10:53:16 <b_> now it's to write internal/sys/code gen stuff the others can't write
10:53:23 <nand`> Catnaroek: I'm not sure if I like that definition or not
10:53:39 <kallisti> daniel_-: are you actually using forever or explicit recursion?
10:53:44 <b_> which is cute, but my job is front-end dev/web designer
10:53:55 <daniel_-> i can show you what i want to do
10:53:59 <kallisti> if you're using explicit recursion, you need to communicate to your recursive loop that the victory condition has been met, somehow. and when that happens just stop the recursion.
10:54:19 <nand`> b_: easy, use uhc -tjs
10:54:21 <hpaste> daniel_- annotated “im lost” with “im lost (annotation)” at http://hpaste.org/70384#a70387
10:54:24 <Raynos> Is there a name for the pattern of applying a partial application to the partial application function? https://gist.github.com/2984095 (pseudo code)
10:54:45 <zomg> My job is the-guy-who-pretty-much-knows-everything-about-the-codebase/cto's-drop-in-replacement
10:54:48 <zomg> :P
10:55:01 <kallisti> Raynos: that doesn't look like Haskell to me
10:55:03 <nand`> Raynos: I don't get that pseudocode
10:55:16 <Raynos> its not haskell at all
10:55:19 <nand`> what does the “partialApplication” supposed to do
10:55:21 <nand`> what is*
10:55:49 <Raynos> its supposed to take a function and an argument and return the partial application of the function and the argument
10:55:58 <kallisti> daniel_-: instead of forever you can use fix
10:56:04 <kallisti> fix f = x where x = f x
10:56:15 <monochrom> just use recursion
10:56:24 <b_> zomg: I am also CTO-replacement, literaly
10:56:24 <srhb> That's almost the least informative definition ever. :P
10:56:25 <kallisti> exactly. :)
10:56:32 <kallisti> just use recursion (in the form of fix)
10:56:40 <b_> hard to juggle
10:56:41 <zomg> b_: heh.. ours quit the last time the company was in financial troubles :P I stuck around
10:56:50 <optimight> hi
10:56:53 <nand`> since partial application with curried functions is implicit; createSummer = ($) $ sum = id sum = sum
10:56:54 <b_> ours had personal troubles
10:57:02 <nand`> ergo sumOne = sum 1
10:57:04 <monochrom> to loop back, recurse. to exit, just don't recurse. plain and simple.
10:57:04 <nand`> sounds logical
10:57:06 <nand`> Raynos: call it “application”
10:57:14 <zomg> Oh well it looks good in my CV
10:57:16 <zomg> =)
10:57:19 <daniel_-> wut
10:57:32 <daniel_-> gonna have to think about this one for a while'
10:57:46 <kallisti> daniel_-: forever m = m >> forever m
10:57:55 <kallisti> forever always recurses. you want to sometimes recurse
10:58:01 <kallisti> so just remove forever, and write your own recursive function
10:58:15 <Raynos> I should have clarified I'm using a functional non-haskell language that does not curry functions by default for me. I'm using #haskell as the "people who know about functional programming" IRC room. (there may be a better room for that)
10:58:18 <monochrom> I'll show you a pseudo-code translation from while-loop to recursion. you will see.
10:58:35 <sipa> @pl \m -> fix (\r -> m >> r)
10:58:36 <lambdabot> fix . (>>)
10:58:38 <monochrom> while-loop version: while i<n { x:=x+1 }
10:58:58 <optimight> which are the perstistence mechanism suitable to haskell?
10:59:08 <daniel_-> ok sounds logical
10:59:12 <nand`> let go = do { ... ; when continue go } in go
10:59:12 <monochrom> recursive version: me = if i<n then { x:=x+1; me } else { return () }
10:59:30 <optimight> donri: hi
10:59:31 <basti_> optimight: what's the problem with persistence in haskell?
10:59:47 <optimight> I am new to haskell
11:00:06 <monochrom> the translation is so mechanical that there is nothing to understand or thinking. do not think. calculate.
11:00:17 <kallisti> daniel_-: I nice way to write recursion without explicitly naming a function is to use fix, but it might be difficult for a beginner to understand
11:00:20 <kallisti> *a
11:00:35 <kallisti> whenever I have loops like this in IO, I use fix.
11:00:44 <basti_> optimight: it might be somewhat unusual that most persistance mechanisms are only accessible through "monads", but in the end there's not a big difference to other languages
11:01:08 <optimight> basti: if we develop an application in haskell...   what are the databases suitable for persistence
11:01:30 <basti_> optimight: you can use just about any database, i think.
11:01:43 <optimight> okay
11:01:50 <monochrom> I recall that you have already written getR and it already does the recursion. you already know how to do it.
11:01:52 <srhb> optimight: Check out hdbc. :)
11:01:59 <kallisti> there's a lot of persistence/serialization libraries out there. persistent, acid-state, cereal, aeson, hdbc, postgresql-simple
11:02:05 <obk> Is there a way to convert a TypeRep to a Q Type, somehow?
11:02:06 <basti_> optimight: do you have any special needs that are worth considering here?
11:02:12 <optimight> srhb: okay
11:02:43 <srhb> hdbc, I think, is easy to understand for a newcomer.
11:02:44 <Raynos> Is there a language agnostic functional programming IRC room?
11:02:54 <basti_> eg. consistency demands or the wish to store "programs"
11:02:54 <daniel_-> im just trying to read some things about fix
11:02:56 <monochrom> there was, and it died
11:03:13 <nand`> I can't imagine that being anything other than wars about which functional language is the best
11:03:14 <kallisti> daniel_-: fix $ \loop -> ...
11:03:24 <kallisti> daniel_-: any time you refer to "loop"  the lambda block will repeat
11:03:33 <monochrom> oh, try my http://www.vex.net/~trebla/haskell/fix.xhtml
11:03:53 <optimight> basti: I am thinking of two applications - One ERP like large distributed application and second dictionary like storage and continuous and very high manipulations
11:04:18 <daniel_-> thanks monochrom will read :)
11:04:31 <monochrom> perhaps I should add an IO example
11:04:32 <basti_> optimight: that sounds like a very "normal" application so there ought not to be any problems
11:04:41 <ksf> that's it. I'm not going to refactor *that* into monadic code.
11:04:46 <ksf> implicit parameters, there you come.
11:04:52 <basti_> maybe you have write your queries in a slightly different way, but in the end the mechanism is the same
11:04:55 <kallisti> daniel_-: a lot of the reading material about fix will be pretty theoretical in nature.
11:04:55 <nand`> Raynos: what you pasted is *nearly* valid haskell, mind
11:05:14 <nand`> just change line 1 to sum(x,y) = x * y
11:05:18 <Raynos> nand`: https://gist.github.com/2984095
11:05:24 <Raynos> I tried to make it more language agnostic
11:05:26 <kallisti> > fix f
11:05:27 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:05:27 <lambdabot>    `GHC.Show.Show a'
11:05:27 <lambdabot>      a...
11:05:30 <kallisti> > fix f :: Expr
11:05:31 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
11:05:32 <nand`> and define partialApplication(f,x) = \y -> f (x,y)
11:05:52 <optimight> basti:   I am hdbc page ...  will go through it
11:06:12 <nand`> Raynos: there you go, that would be valid haskell with the correct lambda syntax :)
11:06:16 <basti_> optimight: that sounds like a good place to start
11:06:30 <optimight> basti_ : thanks
11:06:58 <monochrom> kallisti, not mine
11:07:22 <Raynos> nand`: https://gist.github.com/2984095 Is there a name for the what type of function the createrSummer function is
11:07:55 <monochrom> mine is of the nature "it's so blindly mechanical and calculational, there is nothing to understand or theorize"
11:07:56 <nand`> I wouldn't think so
11:08:13 <nand`> wait
11:08:21 <nand`> Raynos: createSummer is just a curried version of sum
11:08:25 <nand`> so you can call it a curried function
11:08:41 <kallisti> monochrom: I think you're officially banned from the church of the least fixed point.
11:08:41 <Raynos> that would be true for haskell
11:08:46 <Raynos> where functions are curried by default
11:08:58 <Raynos> it would not be true for other languages where functions are not curried by default
11:09:26 <optimight> basti_ : hdbc layer provides interface for Relational Databases ...if OODBs are used then?
11:09:27 <Raynos> I guess curried function is a good enough name and I can just not worry about the semantics
11:09:31 <nand`> Raynos: every language with first class functions can have curried functions
11:09:51 <Philippa> monochrom: understanding where the concept of fixed points comes from ends up helping a lot of people in practice though
11:09:57 <kallisti> Raynos: the semantics are:  (f x) y = f x y
11:10:14 <donri> <donri> optimight: acid-state is nice
11:10:14 <donri> <donri> but you can use more or less any database you like
11:10:21 <donri> apparently i pinged out before that got through
11:10:38 <monochrom> orthogonal to the syntactically defined combinator called "fix"
11:10:39 <basti_> optimight: as you might have noticed, "oodb"'s are nothing more than either rdbms' or key-value stores with some kind of "object management" added on top. since the concept of "object" doesn't exist in haskell in that form, the question appears not to make much sense to me.
11:10:54 <nand`> Raynos: in fact, the definition of partialApplication as providing a lambda abstraction for a lambda abstraction makes it pretty close to “curry”
11:11:18 <nand`> and your createSummer works like this: (createSummer(1))(3) = sum(1, 3)
11:11:30 <basti_> (while one could argue that "objects" exist, "classes" neither fit many databases very well, nor does "inheritance". and then, "inheritance" is quite different in haskell)
11:12:23 <Peaker> nand`, Just saw your reply (having some lag makes it hard to follow ...)
11:12:36 <nand`> Peaker: refresh my memory, reply to what?
11:12:49 <Peaker> nand`, Yeah, it is possible to throw a (void) there and cause a bug, but it is likely that the programmer would check what he's void'ing before voiding along
11:13:11 <Peaker> nand`, also, a code-review is more likely to wonder what's being void'd there
11:13:24 <nand`> Peaker: a fair point; I'm just not entirely convinced the same can't apply to ‘when’
11:14:24 <Peaker> also, even if Either-style exceptions are used, and not Bool, and the Right result is not needed, the result must not be discarded, so it is nice discards need to use "void" explicitly or "_ <-"
11:14:52 <optimight> basti_ : I got your point
11:15:21 <Peaker> nand`, `when` already does something useful, if it also ignored values, it'd be hard to notice where you just wanted the first useful things, and when you actually wanted to discard the value
11:15:54 <basti_> optimight: best you try to express what you want in sql first. then you'll see if something's amiss, and then you can try to fix that.
11:15:54 <optimight> donri : acid-state seems fine
11:16:54 <nand`> Peaker: arguably the same thing applies to (>>); and hence most of do-notation
11:17:02 <basti_> (if something's missing in sql, then most of the time you are already writing a program in a turing-complete language, which is not the point of sql at all)
11:17:18 <nand`> do { GLFW.initialize; other-stuff } -- oops, error
11:18:14 <optimight> basti_  : think of dictionay ..   every word is related to other words like synonyms, opposites etc...  Imagine I want to store such many different relations
11:19:00 <basti_> optimight: well, i would first sort the relations by "kind" (not exactly the right term)
11:19:02 <nand`> Are there any formalizations of relational databases using set theory?
11:19:08 <nand`> since it seems to me that's all they are
11:19:22 <basti_> what i mean is, there's 1:1 relations, 1:m relations, n:m relations, equivalences etc.
11:19:47 <optimight> yes
11:20:10 <basti_> as sql terminology suggests, a "table" would represent a "relation"
11:20:31 <monochrom> look for "relational algebra" and "relational calculus"
11:20:32 <basti_> one would have the choide to define several relations and have the database check them for consistency
11:20:51 <nand`> monochrom: thanks
11:21:01 <optimight> basti_  : I agree that table Foreign Key and Primary Key shows relationship
11:21:18 <basti_> optimight: the point is, you're heading towards an inner platform already
11:21:33 <basti_> sql IS "storing relations of several different kinds"
11:22:09 <optimight> basti_ : "heading towards an inner platform already" what does that mean?
11:22:16 <basti_> how you're bound to store your special relations is a question of the application, not one of the languages used
11:22:51 <basti_> optimight: "inner platform effect" is when you're using a programming language to implement another one.
11:22:56 <optimight> basti_  : relations is a question of application
11:23:26 <basti_> while this might be worthwile (compilers, interpreters, lisp-in-itself), usually it's a sign that you've taken a questionable turn
11:23:41 <optimight> basti_ :but once the application plays role ..relations must be stored for the persistence
11:23:53 <basti_> optimight: yes, and that's what sql is for. exactly.
11:24:14 <basti_> not more and not less. a database talking sql will give you a way to "store relations persistently"
11:24:29 <basti_> the question is, how do you work this out so that the user will be happy
11:24:47 <jmcarthur> i seek wisdom. i need to do some memoization. it must be the ugly kind (using a mutable data structure with unsafePerformIO) because i don't have a way to lazily generate all possible keys up front in this context. i can use whatever kind of keys i want as long as i can generate them on the fly (as unique identifiers). i guess i will probably end up with Int keys, but i don't want to overconstrain the
11:24:49 <jmcarthur>  question. what mutable data structure (or immutable one in an IORef) would be the fastest for this?
11:25:25 <optimight> basti_ : pardon me . if I am not grasping your point fast but ..where will be the permanent storage?  RDBMS , OODBMS or ORDBMS or file System or anyother ?
11:26:32 <basti_> optimight: since you already were talking about relations i would suggest you try an "rdbms". however, if you want to learn haskell and its ways, you might want to use files or any other persistance system (most of them work just like files, though)
11:27:07 <jmcarthur> oh, and i normally expect the number of keys in a memo table to be small
11:27:18 <basti_> in case of an rdbms, you will probably have to talk sql "in haskell"
11:27:35 <basti_> since this combination covers about 99% of use cases in my experience... ;)
11:27:48 <optimight>  basti_ : yes ...    with haskell ...files are more popular and might more suitable , right?
11:27:50 <jmcarthur> i think i can distill my question down to "what is the fastest map in haskell you know of, whether mutable or immutable?"
11:28:15 <basti_> optimight: files are definitely more compatible. it's somewhat hard to imagine an environment without files.
11:28:30 <basti_> a database system might be just not there.
11:28:40 <basti_> however, files can break too (disk full etc.)
11:28:52 <basti_> so in the end, the difference is only in usage (for you as a programmer)
11:29:04 <hanDerPeder> do I need a data constructor to write regexes like "\w+" using PCRE?
11:29:17 <optimight> basti_ : okay
11:29:52 <basti_> files in haskell work just like anywhere else. you got a pointer and the possibility to read and write, and they can grow just about as big as you want
11:30:20 <basti_> if you want to store data, theres "serialization" facilities which do exactly that.
11:31:04 <basti_> you can write out (most) data to disk and read it back
11:32:42 <ksf> you know what, with uniqueness types, we could get rid of the state monad.
11:32:46 <basti_> the only difference is that you need to use a special notation ("IO Monad") - but this is almost a no brainer
11:32:57 <ksf> that'd be two of three down, then.
11:33:02 <Taneb> I'm gonna sound naive, but what's a uniqueness type?
11:33:10 <ksf> the thing clean has instead of monads.
11:33:14 <optimight> basti_  : I will go through hdbc and acid-state
11:33:16 <ksf> a type that may be used only once.
11:33:17 <basti_> if something calls itself "IO x" think of it as being "a script returning x"
11:33:21 <Taneb> How do they work?
11:33:47 <basti_> there's really not much to it, except some funny terminology and a somewhat extreme type system
11:33:57 <ksf> in the IO case, you get World -> World functions, each World being forced to only be used once.
11:34:12 <basti_> optimight: just try a few things, i think you'll be able to figure it out
11:34:47 <ksf> designing into the other direction, monadic views and pattern guards would work.
11:34:57 <optimight> basti_  : I thought so..   will go through entire details
11:35:16 <ksf> but with the situation as it is, I'm going to forego that damn reader monad and use implicit parameters.
11:35:39 <ksf> I don't care about ordering in my state monad, either, so it'd be nice to make it explicit, too.
11:39:03 * ksf considers using unsafePerformIO
11:40:04 <optimight> away from my compute
11:50:53 <Philippa> ksf: ceiling cat is watching you!
11:52:52 * roconnor_ stamps out the World -> World idea
11:53:20 <Philippa> roconnor_: I still like it. Not as a "practical" model, admittedly
11:53:21 * copumpkin cheers at roconnor_ 
11:53:36 <S11001001> aw, I like IO () everywhere
11:53:44 * hackagebot silently 1.2.0.2 - Prevent or capture writing to stdout and other handles.  http://hackage.haskell.org/package/silently-1.2.0.2 (TrystanSpangler)
11:54:02 <S11001001> composability is overrated
11:54:06 <Philippa> but it's a fun thought experiment so long as you're being led through it by someone with a bit of a trickster mentality about it?
11:54:36 <Taneb> If you introduce then remove uniqueness types, you end up with alternate universes
11:54:48 <Philippa> (admittedly I'm more in the World -> (World, a) camp)
11:55:16 <Philippa> Taneb: "here, have a world where your computing substrate got hit by a meteorite" is arguably even more fun
11:55:23 <roconnor_> explaning how forever works in terms of World -> World involves so much hand wavying your arms will fall off.
11:55:37 <Philippa> roconnor_: yeah. But there's a good reason for that?
11:56:05 <Philippa> (so a clocked World is better, yeah)
11:56:18 <fuchsto> Can anyone give me a hint on how to read microphone input in haskell?
11:56:22 <ksf> Philippa, any other idea how I could get rid of the state monad?
11:56:33 <ksf> I don't care one bit how the operations are ordered.
11:56:37 <basti_> fuchsto: why don't you just open the corresponding special file?
11:56:38 <ksf> I just need a unique int.
11:56:44 <noob> cheers everyone
11:56:56 <Taneb> You could throw tuples everywehre
11:56:58 <fuchsto> So, which binding to use? ffmpeg seems to support microphone input, but i want a plain old unencoded access to an audio buffer
11:57:13 <fuchsto> basti_: Without ALSA in between? That works?
11:57:15 <basti_> fuchsto: /dev/dsp?
11:57:20 <basti_> for me, it just did
11:57:20 <Philippa> ksf: honestly? Nah, go for it
11:57:32 <fuchsto> basti_: That'd be awwsumm
11:57:32 <Philippa> just put up with the feline voyeur
11:57:44 <basti_> i think i'd have to use a bizarre syscall for it to be exactly the way i wanted to
11:57:52 <fuchsto> basti_: You don't happen to have some sample code anywherE_
11:57:53 <fuchsto> ?
11:58:06 <basti_> not in haskell
11:58:18 <Philippa> I think there's a unique name supply in the standard libs somewhere that does the filthy bits for you
11:58:27 <Philippa> though it might be GHC innards rather than actually standard
11:58:29 <ksf> and my whole model of xcb breaks down as I realise that "Window" is a xid, an enum *and* an error.
11:58:55 <ksf> errors are easy to filter out, but xid and enum is more complex.
11:59:04 <ksf> ...the enum telling me that the value 0 means "None"
11:59:05 <basti_> http://www.oreilly.de/catalog/multilinux/excerpt/ch14-05.htm
11:59:05 <fuchsto> basti_: /dev/dsp delivers PCM, if i understand the docs correctly. That'd be ... convenient.
11:59:16 <basti_> that gives some more hints
11:59:38 <basti_> how did you expect it to be? ;P
11:59:42 <fuchsto> basti_: Thanks, looks looks like a good starting point
11:59:46 <geekosaur> it's a wrapper for the wire protocol, which is kinda not very well typed
11:59:56 <ksf> fuchsto, if you want audio *input*, you want jack.
12:00:08 <ksf> as in, if you want input, you're doing pro-audio stuff.
12:00:14 <fuchsto>  ksf I stumbled upon this lib on hackage/audio
12:00:43 <fuchsto> ksf: I want to sample / fft an audio signal, so, it's a little bit 'pro'
12:01:20 <fuchsto> ksf: do you have some experience with jack?
12:01:32 <ksf> with jack, you provide a callback that gets called every couple of samples.
12:01:49 <basti_> jack does have some sort of "realtime" facility
12:02:05 <ksf> well, I once wrote a program that copied input to output...
12:02:43 <ksf> the important point of jack is that it's neigh-impossible-low-latency.
12:02:47 <fuchsto> basti_: the authors of this article you sent me do have quite a sense of humor: "Bonus question: modify the program so that it can recognize the words that are spoken."
12:03:10 <fuchsto> ksf: That is exactly what i am looking for.
12:03:26 <fuchsto> ksf: I want to render a realtime-FFT, so latency is not invited to the party.
12:03:27 <ksf> fuchsto, well... for a fixed vocabulary, that's rather easy.
12:03:36 <ksf> there's floss libraries that can do that.
12:04:18 <fuchsto> ksf: From raw PCM? Not exactly trivial. Yes, with libraries ...
12:04:22 <ksf> there's ample of fft displays for jack, though.
12:04:23 <basti_> for online musical stuff (effects and the like), "realtime" is necissary, since ears are extremely quick
12:04:34 <basti_> you can hear a delay of about 20 ms or something in some situations
12:04:37 <ksf> or a significant delay.
12:04:42 <fuchsto> basti_: Sure. I'm rendering in OpenGL
12:05:04 <basti_> most of the time, an fft/visual rendering takes more than that time
12:05:04 <ksf> more than 1s works. something like 20-400ms or so are *very* annoying.
12:05:19 <fuchsto> i'm just reading the signal and rendering its FFT, my application does not care about output
12:05:23 <basti_> audio/visual is something else
12:05:44 <otters> can you use existential types to define an array of items that are Showable
12:05:51 <ksf> otters, yes.
12:06:03 <fuchsto> the audio is forked. One output line goes to amp, the other to a laptop running my application
12:06:16 <Philippa> basti_: hell yes. Knowing that you react quicker to some sounds than the visuals matching them is, um, highly useful in certain games?
12:06:19 <ksf> data Showable = Show a => Showable a
12:06:22 <jedai> otters: but then you can just put String in your list, that's equivalent functionality with easier interface
12:06:27 <ksf> or something to that effect, not sure about the syntax.
12:06:31 <otters> yeah
12:06:34 <otters> fair point
12:06:42 <fuchsto> ksf: Thanks for pointing me to jack, it would have taken me ages to google all libraries and bindings listed in hackage/audio
12:07:18 <jedai> otters: especially given that Haskell is lazy :)
12:07:43 <otters> yeah
12:08:27 <ksf> so, API question: should I do data Window = None | RealWindow Xid, or newtype Window = Window Xid, noWindow = Window 0 ?
12:08:58 <ksf> the former would allow RealWindow 0, which is bunk.
12:09:38 <geekosaur> only if you allow RealWindow to be constructed directly
12:09:47 <ksf> yep. I probably won't.
12:10:47 <ksf> one newXid :: IsXid a -> X11 a, and then require concrete Windows in the function that take it so you don't re-use it as Pixmap or something.
12:11:01 <ksf> *=> X11 a
12:11:05 <timthelion> any news on manatee?
12:12:08 <geekosaur> ideally the only way to construct a Window value is via wrapped xcb/xhb/xlib/whatever calls
12:12:26 <ksf> OTOH, XidEnums like Drawable will take either Window or Pixmap, anyway, so I can do the same thing for Window and WindowNone: make it two types.
12:12:59 <ksf> errr, that get's a bit complicated.
12:13:27 <ksf> you don't get an xid passed back from createWindow, you pass it a virgin Xid.
12:14:47 <ksf> ...and between "server, give me a virgin xid" and "server, use this xid as a window" there's a network roundtrip via antarctica.
12:15:17 <Paprikachu> :t drop
12:15:18 <lambdabot> forall a. Int -> [a] -> [a]
12:15:35 <ksf> it's fine to wrap up into one in a higher-level library, but the pure xcb libraries ought to provide every possibility to hide latency.
12:15:49 <Taneb> ksf, why not "server, make a virgin xid but instead of giving me it, use it as a window then give me it"?
12:16:02 <Taneb> (I have no idea what you are talking about, btw)
12:16:09 <ksf> Taneb, because I'm not going to be able to redefine X11R6
12:16:16 <Taneb> Okay
12:17:14 <ksf> I *can* always keep a cache of xids ready for immideate use, of course, but that's not a guarantee, xids sometimes burn through really, really fast.
12:17:31 <parcs`> jedai: an existential Show type is not equivalent to String. you can't pass a String to a function that expects a Show a => a. (well you can, but only by coincidence)
12:17:50 <ksf> it's morally equivalent.
12:17:55 <applicative> timthelion: I think lazymanateecat isn't working on manatee much, he is buried in some linux-for-all-china project
12:17:56 <Paprikachu> :t reverse
12:17:57 <lambdabot> forall a. [a] -> [a]
12:17:58 <ksf> and equivalent up to refactoring.
12:18:50 <Paprikachu> > reverse "foo" ++ "bar"
12:18:53 <lambdabot>   "oofbar"
12:19:09 <Paprikachu> > (reverse "foo") ++ "bar"
12:19:11 <lambdabot>   "oofbar"
12:19:20 <jedai> parcs`: The _only_ (safe) thing you can do with a Showable is show it... And you then have a String, so functionally it _is_ equivalent
12:19:21 <ksf> nota bene: nothing binds tighter than ' '
12:19:45 <Paprikachu> @source reverse
12:19:45 <lambdabot> reverse not available
12:19:49 <Paprikachu> :<
12:20:00 <rwbarton> @src reverse
12:20:00 <lambdabot> reverse = foldl (flip (:)) []
12:20:07 <ksf> > foldr (:) [] "foobar"
12:20:08 <lambdabot>   "foobar"
12:20:16 <ksf> > foldl (flip (:)) [] "foobar"
12:20:18 <lambdabot>   "raboof"
12:20:27 <Paprikachu> raboof!
12:20:59 <Paprikachu> @src foldl
12:20:59 <lambdabot> foldl f z []     = z
12:20:59 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:21:14 <jedai> parcs`: There's some minor consideration about memoization and as you said you can't give a String to something that expect a Showable but it's not like there's many such functions....
12:21:22 <Taneb> This reminds me, I need to learn Parsec at some point
12:21:38 <ksf> jedai, parcs`, you can always make a newtype with the right show instance.
12:22:13 <Paprikachu> :t True
12:22:14 <lambdabot> Bool
12:22:25 <Taneb> > let x = show in (x 1, x True)
12:22:27 <lambdabot>   ("1","True")
12:22:53 <parcs`> also Show a => a is more meaningful than String
12:22:59 <jedai> ksf: If you really need to... But it's doubtful it will ever be necessary, since most function that would have taken a Show a => a don't offer anything you can't have with a String instead
12:23:28 <S11001001> if you had a Show a => [a] instead, you could do a bit more
12:23:59 <jedai> parcs`: No, it is equivalent, if you want to signify where your string came from just use a type synonym
12:24:15 <jedai> S11001001: ure but that's a completely different beast
12:24:28 <jedai> s/ure/Sure/
12:24:32 <Paprikachu> :t !!
12:24:33 <lambdabot> parse error on input `!!'
12:24:38 <Paprikachu> :t (!!)
12:24:39 <lambdabot> forall a. [a] -> Int -> a
12:25:27 <Peaker> nand`, If you use do notation it does require you to explicitly ignore
12:25:30 <Peaker> nand`, (at least with -Wall)
12:25:59 <rwbarton> and for certain values of "require"
12:27:42 <parcs`> jedai: Show isn't equivalent even if you  disregard that you can't pass a String that expects a Show a => a
12:27:45 <parcs`> @src Show
12:27:45 <lambdabot> class  Show a  where
12:27:45 <lambdabot>     showsPrec :: Int -> a -> ShowS
12:27:45 <lambdabot>     show      :: a   -> String
12:27:45 <lambdabot>     showList  :: [a] -> ShowS
12:27:53 <parcs`> you can do more than just 'show' it ;)
12:28:11 <Taneb> Is showList how string's works?
12:28:36 <rwbarton> yes
12:28:45 <rwbarton> something like instance Show [a] where show xs = showList xs ""
12:29:23 <rwbarton> showList has a default implementation that uses the [,,] syntax but the Char instance has a special implementation
12:29:31 <Taneb> > showsPrec 3 10322 ""
12:29:32 <lambdabot>   "10322"
12:30:20 <jedai> parcs`: True, I did not consider this, still probably not worth introducing an existential, in fact if you think you're likely to need the rest of Show, you can just use a list of [Int->Shows]
12:33:04 <jedai> parcs`: showList would be lost but then the most you could do with it is show a singleton since you don't now what's the real type of your existential
12:33:30 <rwbarton> nuh uh, you could also showList [x,x,x] :P
12:33:40 <rwbarton> exciting
12:34:06 <Taneb> showList [[x,x],[x,x,x]]
12:34:09 <Paprikachu> :t prepend
12:34:10 <lambdabot> Not in scope: `prepend'
12:34:11 <jedai> rwbarton: very !
12:34:15 <Paprikachu> oO
12:34:24 <Paprikachu> :t :
12:34:25 <lambdabot> parse error on input `:'
12:34:28 <Paprikachu> :t (:)
12:34:28 <Taneb> :t (:)
12:34:29 <lambdabot> forall a. a -> [a] -> [a]
12:34:30 <lambdabot> forall a. a -> [a] -> [a]
12:35:39 <Paprikachu> annotating my c++ template code with haskell code makes it much clearer :o
12:36:22 <Paprikachu> like
12:36:24 <Paprikachu> http://ideone.com/GIOFw
12:40:53 <hpaste> nand pasted “SK abstraction elimination” at http://hpaste.org/70390
12:42:02 <jmcarthur> nand`: i really hate dealing with alpha renaming
12:42:10 <jmcarthur> and free variables and such
12:42:21 <jmcarthur> combinators rock for that reason
12:43:14 <jmcarthur> i guess the conversion doesn't require much though. just detecting of whether a variable occurs free in an expression
12:43:27 <nand`> now for the actual fun part: learning how to use parsec so I can parse "\x -> y" into “Absλ 'x' (Free 'y')”
12:44:21 <nand`> hmm, I could s/Char/String/ and it would work as-is
12:44:24 <jmcarthur> i am at this moment toying around with a little evaluator
12:44:52 <nand`> oh, except for the show instances
12:46:35 <Paprikachu> > foldl (+) [] [1,2,3]
12:46:37 <lambdabot>   No instance for (GHC.Num.Num [a])
12:46:37 <lambdabot>    arising from a use of `e_1123' at <int...
12:46:41 <Paprikachu> > foldl (+) 0 [1,2,3]
12:46:42 <lambdabot>   6
12:47:32 <Paprikachu> @src foldl
12:47:32 <lambdabot> foldl f z []     = z
12:47:32 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:54:18 <Paprikachu> :t foldl
12:54:20 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:58:45 * hackagebot zlib-conduit 0.4.0.2 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/zlib-conduit-0.4.0.2 (MichaelSnoyman)
12:59:20 <jekor> Anyone know how to splice in the place of a variable in an anonymous function? [| \ $var -> $var |] <- gives a parse error (only on the \ $var, the -> $var is fine).
13:00:00 <sipa> $var? is this perl?
13:00:50 <Saizan> TemplateHaskell
13:00:51 <irene-knapp> it needs to be a pattern
13:01:01 <irene-knapp> patterns and expressions are two different AST nodes
13:01:05 <edwardk> what is the type of var?
13:01:13 <edwardk> i mean the actual outside template haskell type?
13:01:26 <fuchsto> ksf: Is there anything else for my 'reading microphone input' problem apart from jack? The haskell jack bindings either don't compile or lack any functionality.
13:01:42 <fuchsto> ksf: I didn't have much luck with portaudio, either :/
13:01:55 <jekor> Maybe I'm going about this wrong. I'm just trying to use names that aren't in use. I had it working with [| someVar -> ... |], but recursive uses throw shadow binding errors. $var is mkName "something".
13:02:02 <ksf> jack should be easy enough to bind to yourself.
13:02:13 <edwardk> you need to splice (VarP name) in the pattern and (VarE name) in the expression
13:02:19 <ksf> in general, be weary of incomplete and C-types leaking bindings.
13:02:31 <jekor> edwardk, irene, thanks. I'll try that.
13:02:45 <Paprikachu> http://ideone.com/UniIS
13:02:50 <Paprikachu> finally a bit of haskell in c++ :3
13:03:07 <ksf> jekor, newname, not mkName
13:03:11 <fuchsto> ksf: In this case there is no binding for jack, then
13:03:34 <fuchsto> ksf: And i kind of lack the experience to write a haskell binding :/
13:04:00 <jekor> OK, this is a start, but there's still a problem in that TH doesn't seem to like [| \ $(...
13:04:04 <jekor> It gives a parse error.
13:05:32 <fuchsto> ksf: Gnaah, there's -two- bindings. One called 'jack' and one called 'jack-bindings'. Looks like 'jack' would work.
13:06:02 <Paprikachu> @src reverse
13:06:02 <lambdabot> reverse = foldl (flip (:)) []
13:10:53 <hanDerPeder> there doesn't seem to be a State data constructor anymore, what do I use instead?
13:11:08 <jekor> I guess I'll work around it by rewriting the anonymous functions in point-free style.
13:11:31 <jedai> hanDerPeder: state
13:11:33 <roconnor__> @hoogle state
13:11:34 <lambdabot> Control.Monad.State module Control.Monad.State
13:11:34 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
13:11:34 <lambdabot> Graphics.UI.GLUT.State module Graphics.UI.GLUT.State
13:12:33 <roconnor__> @type state
13:12:34 <hanDerPeder> jedai: doesn't seem to have the same semantics as State, tried using it as a drop in replacement in the state exmaple from lyah. no dice
13:12:34 <lambdabot> forall s a. (s -> (a, s)) -> State s a
13:12:59 <roconnor__> hanDerPeder: link?
13:13:01 <jedai> hanDerPeder: Apart from in pattern, it should be exactly the same as State was
13:13:32 <edwardk> roconnor__: did you see my hpaste before i went to bed last night? http://hpaste.org/70372
13:13:48 <hanDerPeder> I get "No instance for (MonadState [State Stack Int] ((->) Int))"
13:14:00 <hanDerPeder> roconnor__: http://learnyouahaskell.com/for-a-few-monads-more#state
13:14:02 <roconnor__> edwardk: yep
13:14:06 <edwardk> i renamed Identity and Const so you can get somewhat more coherent error messages out of GHC when you try to set a getter
13:14:15 <rwbarton> that means you made some kind of egregious error
13:14:20 <edwardk> yeah
13:14:34 <edwardk> er i guess that was for him =)
13:14:43 <ksf> someone feed haskell.org's hamsters.
13:14:47 <hanDerPeder> roconnor__: cant get the pop function to compile
13:14:57 <edwardk> i kind of like the get and set combinators though they conflict with the existing functions
13:15:00 <ksf> ...or stop leeching from it, I want to.
13:15:10 <edwardk> getter and setter wor but is less idiomatic when used inline
13:15:14 <roconnor__> @type state $ \(x:xs) -> (x,xs)
13:15:16 <lambdabot> forall a. State [a] a
13:15:33 <rwbarton> hanDerPeder: this example is not using the State monad
13:15:39 <rwbarton> not yet, anyways
13:15:52 <rwbarton> aha
13:15:56 <rwbarton> there is a second pop
13:16:49 <hanDerPeder> rwbarton: its not?
13:16:55 <rwbarton> hanDerPeder, hpaste the code that is giving that error
13:17:07 <rwbarton> hanDerPeder, i was looking at the first definition of pop originally
13:17:18 <rwbarton> pop :: Stack -> (Int,Stack); pop (x:xs) = (x,xs)
13:17:18 <jedai> hanDerPeder: I guess you made a big erro when typing the example. As roconnor showed, it should work with state
13:17:22 <edwardk> i also think my major performance objection to these may have been moot
13:17:23 <roconnor__> edwardk: conflict?
13:17:45 <edwardk> roconnor__: well usually get is like flip (^.)
13:17:51 <edwardk> rather than the thing that makes a getter out of a function
13:18:08 <edwardk> plus the name get collides with State
13:18:16 <edwardk> and one wants to be able to use State with lenses in code easily
13:18:19 <hpaste> hanDerPeder pasted “state stuff” at http://hpaste.org/70391
13:18:39 <roconnor__> edwardk: right
13:18:41 <edwardk> so i guess i need another name for get/set
13:18:46 * hackagebot http-conduit 1.4.1.10 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.4.1.10 (MichaelSnoyman)
13:19:13 <rwbarton> hanDerPeder: that type signature is wrong
13:19:14 <jedai> hanDerPeder: The problem is the type
13:19:33 <jedai> hanDerPeder: it should be State Stack Int only, no Int ->
13:19:42 <roconnor__> edwardk: get/put is often used in the literature
13:19:45 <roconnor__> edwardk: I
13:19:47 <roconnor__> er
13:19:49 <hanDerPeder> aha, my bad when copy pasting
13:20:13 <hanDerPeder> thanks
13:20:24 <edwardk> yeah, just trying to come up with an idiomatic name that doesn't collide, since we now have 3 functions that all want to be named get ;)
13:20:28 <hanDerPeder> btw, why wont it work without a type signature?
13:20:33 <edwardk> state get, getting from a lens, and making a getter
13:20:51 <geekosaur> it's just State Stack Int
13:21:09 <jedai> hanDerPeder: It would
13:21:12 <rwbarton> hanDerPeder: because of the monomorphism restriction
13:22:00 <roconnor__> edwardk: I'm wondering if a H98 version would be usable.  I think something like "clone :: Functor f => ((b -> (Product (Const b) Identity) b') -> a -> (Product (Const b) Identity) a') -> (b -> f b') -> a -> f a'" would be need to use lenses passed as parameters.
13:22:09 <hanDerPeder> rwbarton: the compile error says nothing about the monomorphism restriction, though it did that every time if that was the case
13:22:10 <jedai> let pop = state (\(x:xs) -> x,xs)) in runState (pop) [1..5]
13:22:19 <jedai> > let pop = state (\(x:xs) -> x,xs)) in runState (pop) [1..5]
13:22:21 <lambdabot>   <no location info>: parse error on input `)'
13:22:24 <roconnor__> edwardk: though making avoiding Rank2 isn't worthwhile
13:22:28 <jedai> > let pop = state (\(x:xs) -> x,xs) in runState (pop) [1..5]
13:22:29 <lambdabot>   Not in scope: `xs'
13:22:38 <roconnor__> s/making/maybe
13:22:39 <jedai> > let pop = state (\(x:xs) -> (x,xs)) in runState (pop) [1..5]
13:22:40 <edwardk> the problem with the haskell 98 version is if i hand you a lens you have to get it separately for each use
13:22:40 <lambdabot>   (1,[2,3,4,5])
13:22:59 <edwardk> i think the rank 2 types are key to making it not suck
13:23:05 <jedai> hanDerPeder: It would work without type signature, it just don't with a wrong type signature
13:23:06 <roconnor__> edwardk: the purpose of clone is to turn make a lens polymorphic again
13:23:07 <edwardk> plus they let you get decent type aliases
13:23:31 <edwardk> re clone: you can use the Store translation
13:23:39 <edwardk> its cleaner
13:23:41 <roconnor__> foo lens = .... x ^. (close lens) ... (clone lens ^= y) ...
13:23:48 <roconnor__> sure
13:23:51 <hpaste> hanDerPeder pasted “state stuff2” at http://hpaste.org/70392
13:23:52 <roconnor__> indext store
13:23:56 <edwardk> yeah
13:24:09 <hanDerPeder> jedai: the last paste does not compile
13:24:40 <rwbarton> right because of the monomorphism restriction
13:25:31 <hanDerPeder> rwbarton: okay, thanks. so that means I can't rely on the compiler telling me everytime thats the case?
13:25:51 <hanDerPeder> anyway, thanks for the help!
13:26:02 <jedai> rwbarton: Why ? It does compile here
13:26:03 <rwbarton> well, i imagine you got an error like No instance for (MonadState m a)
13:26:36 <rwbarton> @type state
13:26:37 <lambdabot> forall s a. (s -> (a, s)) -> State s a
13:26:41 <rwbarton> oh wait
13:26:47 <edwardk> clone l f a = case l (Store id) a of Store g c -> g <$> f c
13:26:53 <rwbarton> @hoogle state
13:26:53 <hanDerPeder> rwbarton: correct
13:26:53 <lambdabot> Control.Monad.State module Control.Monad.State
13:26:53 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
13:26:53 <lambdabot> Graphics.UI.GLUT.State module Graphics.UI.GLUT.State
13:27:28 <rwbarton> so for some reason state is sometimes a class method and sometimes has a concrete type
13:27:34 <edwardk> that interestingly does let you work in haskell 98, but the conversions are kinda silly
13:27:36 <rwbarton> due to different monad libraries or whatever
13:27:49 <roconnor__> edwardk: thankfully a lot of lenses are top level; though they really get intresting when they are passes as parameters.
13:28:17 <edwardk> state is a member of MonadState in the current mtl, and its a method in all the transformer exports because the MonadState state requires MPTCs
13:28:19 <jedai> hanDerPeder: It should compile, what happen ?
13:28:29 <rwbarton> okay
13:28:30 <roconnor__> edwardk: ya, the clone noise would be irritating, but its nice that it is possible.
13:28:41 <rwbarton> edwardk: so you're just saying it is a matter of mtl version
13:28:55 <hanDerPeder> jedai: does not compile here, using ghc 7.4.2
13:29:10 <jedai> Ha okay, depends on what type is state
13:29:27 <edwardk> current transformers made state polymorphic. it witnesses the canonical state monad homomorphism from State s  to StateT s m for any Monad
13:29:42 * ksf doesn't think an object system where the constructor is polymorphic is going to work out.
13:29:57 <edwardk> then mtl followed suit by moving it into the class, this lets you implement modify without two round trips through the monad stack
13:30:00 <donri> edwardk: what is the plan with "parsers"? will it be a base for trifecta, parsec, atto?
13:30:00 <ksf> ...modulo *heavy* type-class hackery.
13:30:01 <jedai> hanDerPeder: That's effectively the monomorphism restriction since your state is a bit more complicated than it was
13:30:25 <edwardk> donri: at least for trifecta. and it'll be possible to make instances for parsec and attoparsec, so you can write code that doesn't care what combinator library you use
13:30:45 <ksf> no, you can't.
13:30:47 <ksf> due to try
13:30:52 <hanDerPeder> jedai: by 'than it was' do you mean in earlier versions of mtl?
13:30:55 <edwardk> donri: it lets trifecta focus entirely on error reporting, diagnostics, highlighting, etc. and factors out all the random parsing combinators
13:31:05 <donri> aha
13:31:08 <ksf> it's got the most broken semantics imaginable: "implementation-dependent"
13:31:41 <edwardk> then you can choose to use trifecta for debugging the grammar, or a faster parser for a first pass before retrying with more robust diagnostics, etc.
13:31:56 <Philippa> nice
13:31:59 <jedai> hanDerPeder: Right
13:32:29 <hanDerPeder> rbarraud_, jedai: thank you so much for your help, a lot clearer now :)
13:32:32 <rwbarton> hanDerPeder: that error message means it is looking for a single MonadState instance that works for *all* m and a
13:32:44 <donri> edwardk: interesting!
13:32:47 <rwbarton> which is the only kind of instance that is compatible with the monomorphism restriction
13:32:53 <edwardk> donri: most of this is posthoc justification. i just wanted to see how much of a haskell-98-like core i could extract from trifecta. the rest was justification that followed after that fact ;)
13:33:06 <rwbarton> from ghc's point of view, the error isn't caused by the monomorphism restriction, it's caused by the fact that that instance doesn't (and shouldn't) exist
13:33:37 <rwbarton> so it takes a while to learn what the error messages really mean
13:34:07 <donri> ksf: are you talking to us?
13:34:09 <edwardk> its not quite 98 though since the permutation parsers need existentials
13:34:35 <ksf> nah, merely throwing an argument in while being grumpy.
13:34:37 <hanDerPeder> rwbarton: im a c++ developer so usefull error messages would probably frighten me
13:35:42 <sipa> hanDerPeder: once you start making errors in funky typelevel stuff in Haskell, the errors soon get larger than boost's in g++
13:35:52 <ksf> ...unless, of course, someone here has some experience designing the type framework for a non-standard object system
13:36:18 <hanDerPeder> sipa: cant wait :p
13:37:18 <jedai> sipa: I'm not completely convinced :)
13:37:51 <jedai> sipa: Though thay may get as hard to understand
13:37:56 <donri> edwardk: so is "parsers" a parser combinator itself, or does it need instances to do something meaningful?
13:38:08 <edwardk> donri: right now it needs instances
13:38:21 <edwardk> donri: it contains instances for lifting your parser type over mona transformers, but thats it
13:38:41 <edwardk> that in its own right is kinda handy if i make an instantiation of it for parsec
13:38:57 <edwardk> because then you can WriterT m a Parsec parser
13:39:48 <dolio> Wow, fedora is still on GHC 7.0.4.
13:39:59 <edwardk> donri: i'm working on swapping trifecta over to it, then i need to bang out attoparsec instances and parsec instances
13:40:07 <donri> dolio: yep, my fault. you can install 7.4.1 from rawhide.
13:40:15 <Eduard_Munteanu> dolio: don't worry, Gentoo's stable version is still 6.12.3 :)
13:40:19 <dolio> :)
13:40:24 <edwardk> Eduard_Munteanu: ouch
13:40:24 <Eduard_Munteanu> Debian might even be older.
13:40:47 <dolio> I haven't installed distro packages in years, since Ubuntu started lagging.
13:41:00 <Eduard_Munteanu> Yep, 6.12.1.
13:41:06 <dolio> I'm unable to install 7.4.2 from the GHC site, though, because of complaints about libgmp.so.3.
13:41:10 <donri> sadly binary ghc releases don't work on fedora 17 due to gmp
13:41:15 <donri> yea
13:41:24 <dolio> So I was curious what the distro version was.
13:41:42 <edwardk> hrm 'pull' and 'push' aren't taken
13:41:49 <donri> dolio: yum install fedora-release-rawhide; yum --enablerepo rawhide install ghc
13:42:14 <donri> (or haskell-platform)
13:43:01 <dolio> donri: Cool, thanks.
13:44:05 <dolio> donri: Does that only install stuff from rawhide when I pass the --enablerepo on the command line?
13:44:09 <dolio> For subsequent updates.
13:44:18 <donri> yep, rawhide will be disabled by default
13:44:28 <dolio> Okay.
13:45:04 <donri> if you're worried, you can check that with yum repolist or manually in /etc/yum.repos.d/fedora-rawhide.repo
13:45:27 <donri> or graphically with gpk-prefs
13:45:32 <edwardk> hah, gerunds for the win, getting and setting
13:45:39 <edwardk> 'getting abs'
13:45:47 <edwardk> 'getting magnitude'
13:46:19 * ksf still doesn't get gerunds.
13:46:30 <ksf> they're nomifications, but not proper ones.
13:46:37 <edwardk> ghci> (1:+0, 3)^.getFst . getting magnitude     ==> 1.0
13:46:40 <ksf> *substantivations.
13:46:48 <ksf> like in nounificate.
13:47:19 <roconnor__> edwardk: why do you say your previous efficenty objections are moot?
13:47:23 <edwardk> then works with arbitrary lenses or getters
13:47:37 <ksf> you can't, eg. talk about "the going of bilbo to the dragons"
13:47:55 <edwardk> i think i've convinced myself that a concrete instantiation of a van laarhoven lens does the same thing
13:48:25 <edwardk> you can its just not very idiomatic =)
13:48:29 <roconnor> i see
13:48:30 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
13:49:27 <roconnor> edwardk: I don't understand your last comment
13:49:27 <roconnor> I can what?
13:49:37 <edwardk> roconnor: that was for ksf
13:49:41 <aristid> @quote endo
13:49:41 <lambdabot> stepcut says: endo-hylo-cata-ana-expi-ali-docious!
13:49:44 <aristid> @quote endofunctor
13:49:45 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
13:49:56 <irene-knapp> haha
13:50:30 <Killavus> Hello, can I ask for help about my rather disturbing problem? I'm trying to parse data from an external file using something like that: http://pastebin.com/rV1FQmLL. I want to have [[String]] in return, but I'm getting exception "no parse" all the time. How should I parse it painfully?
13:50:32 <mauke> The paste rV1FQmLL has been copied to http://hpaste.org/70397
13:50:45 <Killavus> not painfully*
13:50:46 <Killavus> :P
13:51:07 <rwbarton> well 'r' is not something that can be read by a derived Read instance
13:51:20 <rwbarton> um
13:51:25 <rwbarton> so you could map toUpper the whole string I guess
13:51:34 <Killavus> I've got it wrapped in sth that enforces [[String]] type (it's passed to a function with signature [[String]] -> something)
13:51:49 <edwardk> roconnor: i find it amusing that clone :: ((c -> Store c d d) -> (a -> Store c' d' b)) -> PolyLens a b c' d' uses a representation very much the kind of lens that the lenses package defines with state
13:52:03 <edwardk> er very much like
13:52:10 <donri> roconnor: so i think i'm beginning to understand why data-lens-ixset is broken, but i'm still confused about one thing; you said that it should be possible to implement fromList with the lens, but is that really the case? is that really a lens law of sorts?
13:52:22 <rwbarton> Killavus: well in order to be a [[String]], there ought to be ""s around each element
13:54:34 <Killavus> rwbarton: After mapping it toUpper I'm still getting the same exception
13:54:39 <Killavus> I'm absolutely confused
13:55:05 <rwbarton> read for [[String]] is expecting an input like [["r", "l", "r"...
13:55:16 <Paprikachu> > take 1 []
13:55:17 <lambdabot>   []
13:55:33 <roconnor> donri: you will have to remind me what context I was talking about wrt fromList
13:55:52 <rwbarton> do you really ultimately want [[String]]?
13:56:04 <roconnor> edwardk: what was lenses representation?
13:56:18 <rwbarton> and you really have this format with unquoted strings? how is it supposed to know where the strings end?
13:56:38 <edwardk> State t a -> State s a
13:56:49 <balor> suppose I have a DSL with "data Foo = A | B | C".  Is it a dumb idea to allow users to extend the definition of "Foo" at runtime (to add user specific types)?
13:57:09 <edwardk> hrmm i think i have a style of opaque lenses you can compose with but can't 'look inside'
13:57:12 <edwardk> one sec
13:57:21 <donri> roconnor: the reason the lens for ixset is broken is, as i understand it, that the updateIx function silently does nothing if there exists more than one member matching the index... so I'm thinking that the solution is to write our own updateIx that always replaces all members for an index... but then you can't replicate the fromList function
13:57:23 <Lemon> balor, to add user-specific constructors, you mean?
13:57:28 <Lemon> you want an open data type
13:57:31 <roconnor> edwardk: I don't see how that reprenstation is related
13:57:31 <balor> Lemon, exactly
13:57:50 <donri> roconnor: so if that is a hard requirement, the lens would have to work with lists instead of a Maybe, which is rarely what you actually want and not as handy
13:57:56 <Lemon> balor, this is not supported by Haskell, but you can get kind of the same thing with type classes
13:58:00 <roconnor> donri: I don't recall that being the problem with ixset
13:58:01 <edwardk> here we're working with a form of (x -> Store …)  -> (y  -> Store ...)
13:58:33 <edwardk> in clone
13:58:44 <donri> roconnor: here's the thread btw, http://www.reddit.com/r/haskell/comments/p75ko/introduction_to_using_acidstate_ixset_and/c3n6y1p
13:59:03 <edwardk> now. if you take the state monad apart you'll find the pair of the State
13:59:08 <edwardk> er if you take the store comonad apart
13:59:20 <balor> Lemon, thanks
13:59:22 <edwardk> and clone becomes very much line the use of the lenses rep
13:59:25 <roconnor> donri: as I recall the problem was that you can and do update values using the ixset lens with values that no longer satify the predicate.  Thuse when you get after set, you won't necessarily get back what you set
14:00:48 <roconnor> clone works with ( x -> (o, i -> x')) -> (y -> (o, i -> y')))
14:01:22 <roconnor> so this is State o x (i -> x') -> State o y (i -> y') ?
14:01:30 <donri> roconnor: yes, if you "set" for an index that has >1 matching entries, updateIx which ixLens uses will silently do nothing, so yes, "get" after that will yield Nothing (due to getOne)
14:01:32 <roconnor> er
14:01:37 <roconnor> oh
14:01:56 <donri> getOne: If the IxSet is a singleton it will return the one item stored in it. If IxSet is empty or has many elements this function returns Nothing.
14:02:14 <donri> updateIx: Will replace the item with index k. Only works if there is at most one item with that index in the IxSet. Will not change IxSet if you have more then 1 item with given index.
14:02:41 <roconnor> edwardk: nope, I don't see it :D
14:03:44 <edwardk> roconnor: (a -> (b, c -> d)) -> (e -> (f, g -> h))     rearrange that to be an indexed state transformation (a -> (b, _)) -> (e -> (f, _))
14:04:04 <roconnor> ah okay
14:04:06 <edwardk> just reassociate the (->) and (,) in your head
14:04:23 <donri> oh i see, even my solution with "replace all" will still be problematic for the "get" operation
14:04:53 <roconnor> donri: yes
14:05:09 <roconnor> donri: basically you cannot turn predicates into lenses
14:05:19 <donri> so the total lens would need to "get" the list of all matching entries, and "set" a list replacing all matching entries? and maybe a partial lens for faking a "primary key"
14:05:31 <roconnor> donri: it is a mistake I and others make over and over again.
14:05:37 <donri> :)
14:06:13 <edwardk> type Secret a b c d = (c -> Set d) -> a -> Set b
14:06:17 <edwardk> secret :: ((c -> d) -> a -> b) -> Secret a b c d
14:06:25 <donri> I also recently found myself wanting a headLens that actually prepends to a list, rather than replace the head... which i realize fails hard on the third lens law, and would kinda be insane... but perhaps there is a sane version of lenses for that sort of thing?
14:06:26 <edwardk> lets you compose 'map' and other operations into your lens chain
14:06:34 <edwardk> 'secret map' can then be used in a chain of setters
14:06:41 <ksf> I don't think it makes much sense to hook ixset up with lens.
14:06:52 <donri> ksf: yea, that's what i'm realizing
14:06:53 <ksf> ...an ixset isn't a record, but a bleeding database.
14:06:55 <edwardk> secret f g a = Set (f (unset . g) a)
14:07:10 <ksf> you don't make lens for maps, either.
14:07:21 <roconnor> donri: sadly lenses actually only solve a narrow range of problems
14:07:22 <donri> there is mapLens, which is what i modeled my ixLens on
14:07:39 <donri> but ixset isn't a map :p
14:07:54 <roconnor> edwardk: are you trying to make a write-only lens again?
14:08:11 <edwardk> ghci> (secret map . sndLens %= (+1)) [("hello",2),("world",3)]     => [("hello",3),("world",4)]
14:08:21 <edwardk> well i have the write only one
14:08:25 <edwardk> but i wanted a modify only one
14:08:32 <edwardk> where you can look at the contents, but can't tell anyone about it ;)
14:08:42 <edwardk> you can't get a secret
14:08:47 <edwardk> but you can manipulate it
14:08:49 <edwardk> it just remains secret
14:09:13 <roconnor> donri: in github there is code for lookupByML :: (k -> Bool) -> MultiLens [(k,v)] v
14:09:28 <edwardk> donri: there isn't a sane version of lenses for those things ;)
14:09:34 <roconnor> donri: but notice the predicate is on keys, but the lens gives you values
14:09:40 <tgeeky> edwardk: can you make a decleration a law, like
14:09:41 <edwardk> ksf: you can make a lens into a map
14:09:42 <tgeeky> enforce in:
14:09:48 <roconnor> donri: this is the best you can do with lenses
14:09:53 <edwardk> ksf: just has to extract a Maybe a
14:10:23 <tgeeky>  (secret map . ... [("hello",5),("world",5)]     => [("lol",3),("cats",4)] -- maintain the invariant that snd contains the length of fst?
14:10:24 <donri> aha, MultiLens, is that to PartialLens what lists are to maybe?
14:10:42 <roconnor> donri: more or less
14:10:44 <ksf> well, but as far as the values are concerned, it's just an fmap.
14:10:57 <edwardk> personally i still don't understand all these attempted generalizations of lenses. partial lenses i at least grok intellectually what they are for if not the impact of the laws
14:11:06 <roconnor> donri: github also has frontPL :: MultiLens a b -> PartialLens a b  and  backPL :: MultiLens a b -> PartialLens a b
14:11:07 <edwardk> but multi-lenses bother me fundamentally about what the hell the laws mean
14:11:13 <ksf> hooking up lens to specific keys isn't a good idea, I think.
14:11:28 <ksf> it'd be like python.
14:11:41 <ksf> throw another assoc table at the problem and it's going to solve itself...
14:11:44 <edwardk> ksf: we had out entire compiler built using this for a while ;)
14:11:44 <edwardk> ksf: we've since reduced our dependency on maps for state
14:11:55 <edwardk> but it was actually quite nice
14:12:10 <roconnor> edwardk: multilens is the same as uniplate
14:12:27 <edwardk> binding a name needed to do several operations on the same entry in the map, so we'd make the lens to that value, read it, write it, etc.
14:12:45 <edwardk> and it let us look back later at unbinding time at the right element in the map, etc.
14:14:02 <donri> i've found i've been trying to "lens *all* the things" when often it'd be more sane to do something using %= and ^%=
14:14:55 <edwardk> donri: kind of hoping a nice polymorphic lens library will fix my desire to lens all the things by making it easier to make getters/setters out of arbitrary functions you have lying about
14:16:43 <roconnor> I find the lens for Data.Map really elegent in the way it combines insert,delete,modify into one package.
14:16:45 <Peaker> I wonder what the disadvantages of having only newtypes, type synonyms, and anonymous sums/products, rather than having "data". (i.e: type Foo a = B | C a   vs.   data Foo a = B | C a)
14:17:06 <edwardk> yeah i was very pleased when i found that one =)
14:17:08 <roconnor> Peaker: you need to add Mu
14:17:15 <irene-knapp> that's kind of what I'm doing in Modern Data, heh
14:17:16 <edwardk> i really like the one for Set as well
14:17:24 <Peaker> roconnor, or use a newtype as a fixed point
14:17:27 <roconnor> Peaker: I've been having similar thoughts lately
14:17:33 <irene-knapp> with newtypes/synonyms/anonymous-sum/product
14:17:44 <Peaker> irene-knapp, what's "Modern Data"?
14:17:53 <edwardk> i may generalize the lens types in scalaz to be poly-lenses. they work better with variance
14:17:55 <roconnor> Peaker: oh, I forgot you can use that.
14:18:07 <irene-knapp> oh, my self-describing data library for serializing and deserializing arbitrary object graphs with parametric, dependent types
14:18:09 <edwardk> that way a Set[A] can become a Set[B] when you put something in it for a type B >: A
14:18:18 <irene-knapp> using an efficient binary encoding
14:18:21 <irene-knapp> </mouthful>
14:18:26 <Peaker> roconnor, It would probably mean the need to support polymorphic variant support as well as a structural record system, all for the better
14:18:30 <edwardk> they'll probably remain getter/setter polymorphic lenses
14:18:57 <Peaker> irene-knapp, is it a DSL for data type definitions?
14:18:57 <edwardk> (a -> c, a -> d -> b)  -- rather than store or van laarhoven lenses
14:19:12 <irene-knapp> not really a DSL, no, it's a binary format.  though it has a DSL that goes with it.
14:19:21 <tgeeky> edwardk: so, let's assume something weird and that, in homage to something "10" dimensional, that we restrict ourselves to working with lenses, but only ones which are nested: [9,10,11] levels deep
14:19:27 <roconnor> edwardk: not even factored?
14:19:32 <irene-knapp> think of it as an alternative to XML and JSON
14:19:38 <edwardk> roconnor: its not factored now. factoring in scala is _slow_
14:19:48 <edwardk> construction costs too damn much
14:19:57 <roconnor> edwardk: I thought factoring was the key to efficentcy
14:20:01 <edwardk> the setter is uncurried
14:20:04 <roconnor> oh
14:20:04 <edwardk> its a constant factor
14:20:21 <edwardk> its often a factor of 2 in haskell
14:20:25 <edwardk> but its a factor of 10 worse in scala
14:20:33 <tgeeky> edwardk: so uncurry10...
14:20:34 <edwardk> which swamps the win
14:21:02 <roconnor> edwardk: I see.  In haskell we hope to make up the difference with sharing?
14:21:28 <edwardk> we hope to make up the difference in sharing the work used to traverse down to a point in all the attempts to zip it back up
14:21:45 <edwardk> but constructing that tuple with a function in it is way expensive in scala
14:21:59 <edwardk> so its better to just retraverse there
14:22:07 <roconnor> ok
14:22:42 <roconnor> I must admit, I now finally understand the point of indexed Store comonads. :D
14:22:48 <edwardk> yay!
14:23:54 <hanDerPeder> anybody watching the match?
14:24:10 <roconnor> ocaml vs haskell?
14:24:12 <edwardk> lens :: Functor f => (a -> c) -> (a -> d -> b) -> (c -> f d) -> a -> f b; lens f g h a = g a <$> h (f a) -- gives us the getter/setter construction
14:24:19 <hanDerPeder> lol
14:24:53 <edwardk> roconnor: mind if i just package these up somewhere? i'm writing a blog post about secrets and van laarhoven lenses
14:25:01 <rbarraud_> yo
14:25:15 <roconnor> edwardk: which reminds me, you need to explain how you incorporate concurency in http://comonad.com/reader/2011/free-monads-for-less-3/#comment-61383
14:25:22 <roconnor> edwardk: fine with me
14:25:26 <edwardk> i don't think they fit in data-lens which has a nice niche in that its 98
14:25:35 <donri> so do these van laarhoven lenses mean data-lens will basically be deprecated?
14:25:35 <roconnor> edwardk: you will just make me maintainer anyways :D
14:25:39 <roconnor> oh come on ... clone!
14:25:43 <edwardk> =P
14:25:52 <roconnor> donri: I doubt it
14:25:57 <edwardk> i'll mention clone in the blog post, at least
14:26:22 <edwardk> i have to admit handing off maintainership of data-lens has put a hitch in my release pattern
14:26:34 <roconnor> hah, sorry
14:26:36 <edwardk> because now i have to stop and think when any big change straddles data-lens ;)
14:26:46 <edwardk> its a net good i think
14:26:50 <edwardk> but it does require more thought
14:27:27 <rbarraud_> i think hanDerPeder credited me for help which came from elsewhere - probably rwbarton :)
14:27:54 <edwardk> would it make sense to remove the 'Store' references from Lens in data-lens to avoid scaring folks? e.g. switch to just (b, b -> a) ?
14:28:08 <roconnor> edwardk: BTW, I'd like eeks :: Functor f => (b -> f b) -> (Store b a) -> f a
14:28:11 <roconnor> edwardk: perferablly with a better name
14:28:19 <edwardk> eeks
14:28:31 <roconnor> I'm not very good with names
14:28:38 <edwardk> i obsess about names
14:28:42 <edwardk> we make a good team ;)
14:28:46 <roconnor> good
14:28:54 <edwardk> what is the role of eeks?
14:29:20 <edwardk> its like 'experiment' form the old category-extras
14:29:59 <edwardk> experiment :: (ComonadContext s w, Functor f) => f (s -> s) -> w a -> f a
14:30:25 <edwardk> just with the s -> distributed out
14:30:46 <roconnor> edwardk: to define ^%=
14:30:53 <roconnor> edwardk: also it completely characterizes Store
14:31:12 <edwardk> oh good point
14:31:20 <roconnor> as in (Store b a) is isomorphic to forall f : Functor. (b -> f b) -> f a
14:31:22 <roconnor> as we have been talking about this whole weekend
14:31:23 <edwardk> i could put that in the ComonadStore class
14:31:38 <roconnor> ah, even better
14:31:38 <edwardk> rebranding experiment
14:32:39 <roconnor> s/^%=/^%=/
14:32:40 <roconnor> er
14:32:41 <roconnor> ah
14:32:51 <roconnor> my IRC client is removing double %'s
14:33:17 <roconnor> anyhow, I'm renaming the ^%%= monstrosity to fmodL.
14:33:29 <geekosaur> xchat?  there's a setting for that (% escapes for colors/bold/etc.)
14:33:33 <roconnor> it is far to useful to have such an obscure name.
14:33:39 <roconnor> geekosaur: konversation
14:34:16 <hpc> if you use irssi, those get delegated to ^C, ^B, ^O, ^_
14:34:41 <edwardk> hah
14:34:55 <geekosaur> ah, looks like konversation does the same thing xchat does
14:35:04 <hpaste> hanDerPeder pasted “State with map” at http://hpaste.org/70398
14:35:10 <geekosaur> dunno how to turn it off there (there are /set commands in xchat)
14:35:16 <mroman> hm
14:35:20 <mroman> state map, that reminds me.
14:35:26 <geekosaur> (but google suggests there's no way to disable in konversation)
14:35:30 <hanDerPeder> anyway to simplify the doStuff method, I'm thinking m' shouldnt be needed
14:35:40 <edwardk> roconnor: added experiment to comonad-transformers, adding it to comonads-fd
14:36:20 <hanDerPeder> s/method/function
14:36:34 <roconnor> oh you called it experiment?
14:36:46 <roconnor> I don't like that name, but it is better than eeks :)
14:36:56 <edwardk> thats what it was back in dave menendez's original
14:37:13 <edwardk> lacking better motivation, *shrug*
14:37:41 <roconnor> I thought the original had a different type
14:37:47 <roconnor> but anyhow
14:37:49 <roconnor> it is fine
14:37:50 <edwardk> f (s -> s) rather than s -> f s
14:38:01 <edwardk> the latter is more correct though
14:38:02 <roconnor> better than return :: a -> m a
14:38:49 * hackagebot comonad-transformers 2.1.2 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-2.1.2 (EdwardKmett)
14:39:55 <edwardk>   experiment f w = (`peek` w) <$> f (pos w)  ?
14:39:57 <mroman> http://codepad.org/8ApXgCLJ -- there were times where I wanted map with state but without StateMonad :)
14:40:06 <roconnor> is our experiment the same as the orignal composed with (\a b -> fmap ($b) a) :: f (s -> s) -> s -> f s
14:40:11 <edwardk> yeah
14:40:23 <edwardk> just redistributed
14:40:25 <roconnor> good enough
14:40:56 <tgeeky> roconnor: dFromR :: Functor f => (r -> f r) -> (Store r d) -> f d
14:41:26 <roconnor> tgeeky: thats even worse than eeks
14:41:57 <tgeeky> hehe
14:42:01 <roconnor> edwardk: I must admit, I feel a certain sense of comfort to have experiment back.
14:42:02 <tgeeky> just d then?
14:42:03 <edwardk> it also 'lower's nicely into other comonad transformers
14:42:16 <edwardk> i hadhonestly thought i still had it
14:42:21 <ksf> is there *any* way to resolve an ambigious type variable of some constraint by defaulting it to a concrete type?
14:43:43 <edwardk> ksf: what class constraints do you have on it?
14:43:54 <ksf> a simple one.
14:43:59 <edwardk> ksf: you can often use ExtendedDefaultRules if its only a single parameter type class
14:44:06 <edwardk> then use 'default' to set the appropriate type
14:44:41 <ksf> I have a rather vanilla type hierarchy, the thing where it gets interesting is a constructor function that is polymorphic over all objects.
14:45:03 <edwardk> as long as its a single parameter typeclass, you'll be able to abuse defaulting
14:45:28 <edwardk> patched comonads-fd
14:45:36 <edwardk> 2.1.2 should have it
14:46:53 <enko> printList :: (Show a) => [a] -> String; printList [] = ""; printList (v:t) = show v ++ printList t; -- why cant a be a Num in function definition?
14:47:10 <enko> printList :: (Num a) => [a] -> String;
14:47:33 <roconnor> edwardk: cool, thanks
14:48:31 <ksf> edwardk, but it defaults to ()!
14:48:49 * hackagebot comonads-fd 2.1.2 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-2.1.2 (EdwardKmett)
14:48:55 <edwardk> ksf: you can set defaulting rules by adding a default statement to your module
14:49:11 <edwardk> ksf: what type do you want it to default to?
14:49:36 <edwardk> default String is very useful for OverloadedStrings for instance
14:49:37 <ksf> "Window". or "Pixmap". any other concrete object.
14:49:52 <edwardk> then put default (Window) on a line in your module
14:52:56 <edwardk> ksf: keep in mind every user of the library will have to put the default rule in their own source files to get the defaulting behavior
14:53:11 <edwardk> another sane approach is to just make win :: Window -> Window
14:53:19 <ksf> http://hpaste.org/70399
14:53:19 <edwardk> and then sprinkle it through where you need to default by hand
14:53:49 * hackagebot comonad-extras 2.1.2 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-2.1.2 (EdwardKmett)
14:53:50 <ksf> ...it's not defaulting to window.
14:54:20 <edwardk> newXid can't default to window, Window isn't an instance, no?
14:54:21 <palmfrond> does haskell have the concept of return value and out-variables?
14:54:32 <Paprikachu> @src foldl
14:54:32 <lambdabot> foldl f z []     = z
14:54:32 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:54:39 <ksf> IsWindow is a superclass of IsXid
14:54:51 <edwardk> also the instance (IsWindow a) => IsXid a is totally borked
14:55:08 <Paprikachu> @src foldr
14:55:08 <lambdabot> foldr f z []     = z
14:55:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:55:13 <edwardk> that says that the only instances of IsXid are ones that are IsWindow. and overlaps with god and everything else
14:55:16 <ksf> well, I can't just list them all in newXid
14:55:24 <kr0y> \msg ashashwat
14:55:37 <ksf> hey undecidable instances are fine as long as they're unidirectional.
14:55:47 <ksf> (or otherwise unloopy, but I leave such stuff to oleg)
14:55:54 <edwardk> no, its just a terrible idea overall
14:56:15 <edwardk> just list the instances as you make each subtype
14:56:15 <rwbarton> the undecidable part is not the problem
14:56:40 <ksf> well, but then newXid can't know which newtype wrapper to apply
14:56:46 <edwardk> class IsXid a => IsWindow a; instance IsXid Window
14:56:52 <edwardk> instance IsWindow Window
14:56:54 <ksf> (provided I get the thing do tefault in the first place)
14:57:42 <edwardk> that terrible instance means you'll have a really hard time figuring out what defaulting is/should be doing
14:57:53 * ksf facepalms
14:57:57 <edwardk> i'm not surprised ghc is just looking at you funny =P
14:58:24 <ksf> still not defaulting, though.
14:59:01 <palmfrond> does haskell have the concept of return value and out-variables?
14:59:36 <ksf> http://hpaste.org/70400
15:00:49 <hpaste> nand annotated “SK abstraction elimination” with “SK abstraction elimination (annotation)” at http://hpaste.org/70390#a70401
15:01:54 <nand`> unlambda "λx.λy.λz.(x(zy))"  ==>  "``S``S`KS``S`KK``S`KS``S`KK``SKK`K``S`K`S``SKK``S`KK``SKK"
15:01:56 <nand`> hooray :D
15:02:10 <ksf> edwardk, according to the ghc docs, "extended default" merely means trying () for everything. not extending the defaulting mechanism to non-prelude classes.
15:02:17 <Paprikachu> @src foldr
15:02:18 <lambdabot> foldr f z []     = z
15:02:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:02:25 <Paprikachu> dafuq
15:02:38 <Paprikachu> why isnt it foldr f i x:xs = f (foldr f i xs) x
15:02:42 <ksf> in fact, there's http://hackage.haskell.org/trac/haskell-prime/wiki/Defaulting
15:02:47 <edwardk> no
15:03:10 <edwardk> http://www.haskell.org/ghc/docs/6.6/html/users_guide/ch03s04.html#extended-default-rules
15:03:17 <Paprikachu> @src foldr'
15:03:18 <lambdabot> Source not found. Do you think like you type?
15:03:18 <edwardk> says nothing about ()
15:03:19 <zygoloid> palmfrond: return value, yes. out variables, no (well, sort of, through things like IORef).
15:03:25 <edwardk> i've used this quite extensively before
15:03:32 <adsd> http://elikr.zeekler.com/splash/
15:03:42 <Paprikachu> ski: the world needs you
15:03:45 <edwardk> At least one of the classes Ci is numeric, or is Show, Eq, or Ord.
15:03:46 <tgeeky> yeah. not clockign that.
15:03:51 <edwardk> you need to get a constraint in there of that type
15:04:01 <rwbarton> does "default (Window)" break defaulting for things like (Num a, Show a)
15:04:09 <edwardk> by extending IsXid with a superclass constraint of that sort
15:04:18 <edwardk> rwbarton: you can put () later in the list
15:04:23 <edwardk> etc.
15:04:24 <palmfrond> zygoloid, so how do you handle a situation when you need a function to in essence 'give back' multiple return values
15:04:26 <rwbarton> and Integer and Double I guess yeah
15:04:31 <edwardk> default (Window, Integer, Double, ())
15:04:44 <rwbarton> palmfrond, return a tuple (a, b, c)
15:04:54 <rwbarton> or a list or whatever is appropriate
15:05:06 <ksf> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
15:05:17 <ksf> but then: Rule 3 above is relaxed this: At least one of the classes Ci is numeric, or is Show, Eq, or Ord.
15:05:22 <ksf> I can provide show...
15:05:26 <edwardk> @hpaste
15:05:27 <lambdabot> Haskell pastebin: http://hpaste.org/
15:05:41 <palmfrond> rwbarton, ok, because for example if i do network stuff, i like to have the return value be success/fail, then the actual value go through an out var
15:05:53 <hpaste> edwardk pasted “for ksf” at http://hpaste.org/70402
15:05:57 <edwardk> that works
15:06:01 <rwbarton> palmfrond: in Haskell you would use Maybe, or exceptions
15:06:20 <ksf> \o/
15:06:21 <edwardk> annoyingly putting the superclass Show on IsXid fails though
15:06:22 <ksf> works.
15:06:49 <solrize> if ghc -O2 gives me a 6x speedup, what is the compiler trying to tell me?
15:06:58 <edwardk> apparently the extended defaulting rules aren't smart enough to check for transitive dependency on something in their list
15:07:26 <rwbarton> solrize, the compiler is six times as smart as you? :)
15:07:31 <hpc> solrize: that's normal
15:07:37 <rwbarton> yeah
15:07:43 <jmcarthur> solrize: i daresay that's a *low* speedup for -O2
15:07:48 <hpc> generally what you do is write pretty code and hope it optimizes well
15:07:55 <rwbarton> basically you shouldn't even bother measuring the run time of your program without optimizations enabled
15:08:03 <ksf> oh... and the user of the module has to enable the extension and provide the default rule...
15:08:09 <hpc> and IMPORTANT SECOND STEP: if it doesn't optimize well, learn how ghc optimizes and refactor
15:08:56 <hpc> solrize: in the occasional case, -O2 will change the asymptotic complexity of your code
15:09:35 <solrize> my code is faster than a library function in -O2 but much slower without -O2.  does that mean the library function is optimized?  what i'm wondering is if i'm missing a seq or something that -O2 is picking up
15:10:09 <jmcarthur> solrize: even with perfect strictness annotations, -O2 can make drastic improvements
15:10:27 <jmcarthur> inlining exposes all kinds of opportunities
15:11:23 <solrize> hmm i tried hiding all the internal functions in the module, to allow more inlining... it didn't make any difference
15:11:26 <ksf> well. calling only useDrawable still defaults, to Window because it's listed first.
15:11:39 <ksf> I'd like it to complain about being ambigious, again.
15:12:02 <jmcarthur> solrize: have you checked ghc's core output? that can answer a lot of questions
15:12:14 <solrize> jmcarthur, hmm, that's a good idea i'll check it
15:12:26 <solrize> though my brain may not be big enough, this thing uses a corecursive binary tree
15:12:40 <solrize> i'm thinking of posting this code somewhere, it's kind of interesting.  it benchmarks a bunch of different memoization schemes and finds memotrie is about 2x faster than memocombinators.
15:12:52 <jmcarthur> that *is* interesting
15:13:24 <solrize> and a really simple tree i coded was about 20% slower than memotree a few revisions ago, but is now a little bit faster and i don't think i changed anything
15:15:04 <solrize> s/memotrie/memotrie/
15:15:24 <Peaker> solrize, uglymemo was faster still wasn't it?
15:15:38 <solrize> what's uglymemo?  i didn't include it
15:15:43 <Peaker> I think with a hash table rather than a Data.Map, uglymemo can be even faster
15:15:53 <solrize> i tried data.map and data.array
15:15:57 <donri> did you just substitute something for the same thing
15:16:07 <geekosaur> meant tree for the first one, I thinl
15:16:09 <solrize> array was fastest
15:16:09 <geekosaur> think
15:16:12 <donri> ;)
15:16:37 <Peaker> solarus, uglymemo is augustuss's package -- it uses unsafePerformIO to memoize into a mutable variable
15:16:46 <Peaker> instead of using the thunks approach
15:17:02 <solrize> oh, maybe that's equivalent to what i did, except i used STRef manually
15:17:18 <hpaste> solrize pasted “memoization speed test” at http://hpaste.org/70403
15:17:23 <solrize> there's the code
15:19:20 <Peaker> damn, I hit a lot of annoyances because of Monad not extending Applicative
15:19:54 <jmcarthur> i'd also be curious about how uglymemo would do if it was using the basic hashtable from the hashtables package
15:20:18 <solrize> jmcarthur, i may try adding it
15:20:43 <solrize> http://hackage.haskell.org/package/uglymemo  found it
15:20:56 <jmcarthur> unfortunately it uses Data.Map, it seems
15:21:19 <donri> Peaker: http://www.haskell.org/pipermail/haskell-prime/2011-January/003312.html
15:22:01 <solrize> probably equivalent to fibIntMap in my benchmark then
15:23:02 <luca> :t uncurry
15:23:03 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
15:23:19 <raydlor> anyone know how to include the mtl package in the language pragma?
15:24:16 <jmcarthur> raydlor: i don't understand the question
15:24:30 <jmcarthur> raydlor: the language pragma is for language extensions
15:24:39 <luca> @pl \f, (x, y) -> (f x, f y)
15:24:39 <monochrom> that seems misguided. include a package in a *.cabal file instead
15:24:39 <lambdabot> uncurry ((`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .)))
15:24:51 <Peaker> donri, oleg seems to use a strawman, and the first response shows a much better solution: fmap = liftM
15:24:59 <Peaker> donri, not to mention that he needs to write Functor and Monad instances *anyway*
15:25:17 <Peaker> donri, unless his argument is to be lazy about it and have a monad instance without a functor instance at all
15:25:32 <luca> @pl \(x,y) -> (catMaybes x, catMaybes y)
15:25:33 <lambdabot> catMaybes *** catMaybes
15:25:37 <luca> :t ***
15:25:37 <donri> Peaker: the point is, if you have a monad, it's easy to define a functor/applicative. the inverse is not true, you can't reuse much of functor/applicative in defining a monad.
15:25:38 <lambdabot> parse error on input `***'
15:25:42 <luca> :t (***)
15:25:43 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:25:44 <emias> [A[A
15:25:56 <Peaker> donri, but when you define functor and monad, you have monad anyway, even if monad subclasses functor
15:25:57 <solrize> uglymemo is a little slower than hand coded intmap
15:26:06 <solrize> and about the same as memotrie
15:26:29 <donri> Peaker: ??
15:26:29 <Peaker> donri, also, you could re-use functor/applicative when defining a monad, by allowing defining just "join" for Monad
15:26:50 <Peaker> donri, instances of the super-class are allowed to use instances of the sub-class for a specific concrete type
15:26:55 <hpaste> solrize annotated “memoization speed test” with “memoization speed test (annotation)” at http://hpaste.org/70403#a70406
15:26:56 <raydlor> jmcarthur: i'm unable to use the Control.Monad.State package even though mtl is included as an installed package in cabal
15:26:59 <jmcarthur> solrize: any chance of doing the same trick that uglymemo uses but backed by a hash table instead? :)
15:27:17 <jmcarthur> raydlor: how are you building?
15:27:54 <solrize> jmcarthur, i'll have to hack the uglymemo code i guess.  but, since the arg is an int, i already tried using an array indexed directly by the arg, is that close to hashing?
15:27:59 <donri> Peaker: but you still have to define fmap, independent of the monad
15:28:10 <Peaker> donri, you can define it to be liftM
15:28:13 <Peaker> donri, very minor duplication
15:28:17 <solrize> the array is about 2x faster than uglymemo
15:28:24 <donri> if monad requires functor, does that work?
15:28:25 <jmcarthur> solrize: the difference is that your array implementation uses laziness, but uglymemo uses explicit insertion
15:28:26 <donri> sounds circular
15:28:39 <Peaker> donri, yes, it should, let me test&paste
15:28:50 * hackagebot templatepg 0.2.2 - A PostgreSQL access library with compile-time SQL type inference  http://hackage.haskell.org/package/templatepg-0.2.2 (ChrisForno)
15:28:56 <solrize> jmcarthur, oh, hmm, ok, i can try a mutable array
15:29:08 <raydlor> jmcarthur: ghc 7.4.1 compiler on eclipse ide
15:29:08 <jmcarthur> ah i guess that would be reasonable enough
15:29:15 <donri> if that works i'm all for it, + moving join to the class and providing defaults for join and >>= based on the other
15:29:20 <jmcarthur> raydlor: just straight up ghc? no cabal?
15:29:30 <raydlor> jmcathur: and cabal, sorry
15:29:44 <jmcarthur> raydlor: right. then you need to add the package to your build-deps in the cabal file
15:29:47 <solrize> btw does anyone know what the "steps" link in hpaste does?
15:30:03 <donri> solrize: something about evaluation steps
15:30:20 <donri> of nested expressions
15:30:22 <donri> i think
15:31:45 <Peaker> donri, then you'd have to be careful - you would only get fmap/liftM for free if you implemented (>>=), not if you implemented join only :)
15:32:28 <hpaste> Peaker pasted “Monad subclasses Functor” at http://hpaste.org/70408
15:36:02 <donri> but wait, you said <Peaker> donri, also, you could re-use functor/applicative when defining a monad, by allowing defining just "join" for Monad
15:36:36 <Peaker> donri, yeah, (>>=) implements both fmap and join at the same time.. but if you have join and return, it's not enough to build fmap from that
15:36:53 <Peaker> if you have (>>=) and return you can get both join and fmap from that
15:37:01 <donri> oh wait now i follow
15:38:22 <jmcarthur> s/also/alternatively/
15:41:44 <adnauseam> is it always better to force a calculation on a recursive function ? can one then call it an iterative function ?
15:43:01 <monochrom> first question no. second question subjective.
15:43:42 <hanDerPeder> when I nest several monad transformers, do I need to lift all of the inner ones to access them?
15:44:11 <hanDerPeder> for instance a StateT inside a ReaderT, do I need to liftM $ get ?
15:44:24 <donri> liftM /= lift
15:44:33 <monochrom> depends
15:44:36 <fuchsto> Hm. I'm stumbling on my first steps with forkIO and Gtk2Hs. I'm trying to read sound samples in a thread using Sound.Pulse.Simple, writing an Array of Floats to a chan (writeChan)
15:44:39 <donri> and it depends on if you use transformers or mtl
15:44:47 <otters> I'd think it would be better to use RWST instead of Reader and State
15:44:57 <otters> together, that is
15:45:07 <donri> why, then you have a writer you're not using
15:45:31 <otters> I never thought of it that way
15:45:38 <fuchsto> then, when trying to read the samples in the main (GUI) thread using   samples <- readChan sampleChan   it crashes with "thread blocked indefinitely in an MVar operation"
15:45:44 <fuchsto> so, what am i doing wrong there?
15:46:32 <hpc> you have a deadlock
15:46:33 <donri> otters: then, if you accidentally use something that writes, it'll work without type errors, even though you're not using the writer
15:46:33 <edwardk> if i had to guess, your problem is that you are blocking indefinitely ;)
15:46:38 <Peaker> fuchsto, GC collected the only reference that could write to your channel, probably
15:47:02 <monochrom> link with -threaded first
15:47:06 <otters> donri: oh
15:47:15 <hanDerPeder> otters: RWST, had never heard of it before. thanks!
15:47:30 <hpc> monochrom: if it gives that error without threaded, it will deadlock with
15:47:38 <otters> hanDerPeder: well, like donri said, don't use it if you don't have a writer
15:47:50 <fuchsto> Peaker: The full code is   sampleThread <- forkOS $ do samples <- <read from pulse>; writeChan soundChan samples;
15:48:11 <hanDerPeder> otters: got it, but nice to know it exists
15:48:16 <otters> right
15:48:16 <fuchsto> Peaker: i'm never leaving the scope   sampleThread  is declared in
15:48:25 <hanDerPeder> not exactly production code im working o
15:49:00 <Peaker> fuchsto, your forkOS does one iteration and dies?
15:49:23 <monochrom> I am afraid to ask for the complete actual code. it is going to be 1000 lines, tl;dr
15:49:30 <fuchsto> Peaker: Exactly
15:49:33 <geekosaur> if you;re using mtl, you can:  newtype MyMonad a = ReaderT whatever (StateT whatever) a deriving (MonadReader whatever, MonadState whatever) and both Reader and State should work
15:49:38 <donri> hanDerPeder: if you use the mtl package, you can use "ask" from a state monad wrapping a reader.
15:49:50 <fuchsto> Peaker: Just discovered it right now. The first   readChan  works, on the second it crashes
15:50:10 <donri> hanDerPeder: if you use the transformers package only, you'd have to do "lift ask"
15:50:12 <monochrom> however, every problem of this sort can be reduced to 20 lines of code reproduced. however, no one is going to do that.
15:50:49 <hanDerPeder> donri: probably a stupid question, but how do I know if I'm using mtl or not?
15:51:01 <donri> hanDerPeder: depends where you're importing from
15:51:06 <fuchsto> Peaker: So, what can i do about that_
15:51:08 <donri> Control.Monad.{State,Reader} are mtl
15:51:28 <donri> Control.Monad.Trans.* is transformers
15:51:28 <hanDerPeder> okay, then I'm using mtl
15:51:45 <hanDerPeder> btw, when would you not want to use mtl?
15:51:59 <Peaker> hanDerPeder, I like defining the monad stack like:   newtype MyMonad m a = MyMonad { ContT r (WriterT w (MaybeT m)) a } deriving (Functor, Monad, ...)   and then:   liftCont = MyMonad ; liftWrite = liftCont . lift ; liftMaybe = liftWrite . lift ;    though I'd not call them liftMaybe/etc but names that relate to their function/use
15:52:17 <Peaker> fuchsto, forkOS . forever $ do    instead of   forkOS  ? as a possibility, if that makes sense
15:52:40 <fuchsto> Peaker: Yep, yep, i just facepalmed a bit
15:52:47 <fuchsto> Peaker: Didn't know about forever, thank you
15:52:59 <hanDerPeder> Peaker: that made very little sense to me, but I copied it for later reference
15:53:37 <Peaker> hanDerPeder, the idea is to give names to:  lift . lift . lift    so you don't have it appearing 555 times in your code, and then when you want to add another monad transformer to your stack, you have to fix all of them to lift . lift . lift . lift
15:53:40 <fuchsto> Peaker: From which module is 'forever' from? Control.Concurrent?
15:53:44 <donri> hanDerPeder: well, mtl is neater since you need less explicit lifting, but transformers is less confusing and make better error messages
15:53:46 <Peaker> fuchsto, Control.Monad
15:53:49 <Peaker> @index forever
15:53:49 <lambdabot> bzzt
15:53:56 <Peaker> @hoogle forever
15:53:57 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
15:54:06 <hanDerPeder> Peaker: got it, makes sense
15:54:18 <adnauseam> monochrom: when is it not better ?
15:54:38 <donri> hanDerPeder: though, mtl builds on transformers, so at least transformers code is compatible with mtl code
15:54:48 <monochrom> zeroes = 0 : zeroes. you do not want to force the recursive call.
15:54:53 <hanDerPeder> Peaker: seems inefficient from a performance standpoint though, but I know very little about how haskell code looks during runtime
15:55:29 <Peaker> hanDerPeder, giving names to things will not generally harm performance. GHC can inline
15:56:30 <monochrom> foldr (||) False (repeat True).  you do not want to replace by foldl or foldl'
15:56:55 <hanDerPeder> Peaker: but wont you have to run all those lifts?
15:57:05 <monochrom> in anti-summary, read my http://www.vex.net/~trebla/haskell/lazy.xhtml . and despair.
15:57:08 <Peaker> hanDerPeder, that you would have to do anyway, if your monad stack is deep
15:57:32 <hanDerPeder> Peaker: makes sense :)
15:58:37 <hanDerPeder> donri: got it
15:59:04 <adnauseam> monochrom: i understand - in failure or possible infinite calculations then
15:59:08 <adnauseam> possible*
15:59:32 <adnauseam> and reading
15:59:34 <adnauseam> =]
16:01:55 <monochrom> I always say there is no rule of thumb. but there is one, the only problem is that no beginner understands it. you force if you use a data structure as data structure. you don't force if you use a data structure as control structure.
16:02:27 <monochrom> non-beginners already do the right thing and do not need a rule of thumb.
16:02:52 <adnauseam> monochrom: yeah, i'm a noob =p
16:03:12 <hpc> an interesting extension would be BangKeywords
16:03:17 * adnauseam adds control structures to the list of things to read upon 
16:03:23 <hpc> which lets you write !data Foo ..., !newtype Foo ...
16:03:40 <jmcarthur> what would that do?
16:03:42 <hpc> and it does the strict/unboxing for you
16:03:51 <jmcarthur> hmm
16:03:56 <adnauseam> i've seen bangs just the other day :o thought it's a bit of afunny name
16:03:58 <monochrom> methinks newtype doesn't need a bang
16:04:00 <jmcarthur> meh. i'm fine with being explicit
16:04:07 <jmcarthur> and that
16:04:41 <jmcarthur> it would be nice, on the other hand, to be able to specify UNPACK for an entire data type instead of having to do it on each field
16:04:57 <jmcarthur> it's rare that i don't want UNPACK applied to every strict field if i want it applied to any at all
16:05:02 <monochrom> adnauseam, "forM_ [1..10] (\x -> print x)" uses the list [1..10] as control structure. we use some lists as for-loops.
16:06:29 <rtharper> could also use Nat
16:06:30 <rtharper> heh
16:12:51 <adnauseam> monochrom: hmm, so a control structure is relative to the thing that is using it ?
16:13:08 <adnauseam> as long as it acts as some sort of data skeleton ?
16:13:16 <adnauseam> or execution skeleton
16:16:14 <S11001001> adnauseam: check out the Traversable typeclass; it is cool
16:24:32 <adnauseam> S11001001: will do man
16:25:16 <hpaste> solrize annotated “memoization speed test” with “memoization speed test (annotation) (annotation) - add STArray” at http://hpaste.org/70403#a70410
16:25:33 <solrize> jmcarthur, STArray is just a little faster than IntMap
16:26:42 <hpaste> solrize annotated “memoization speed test” with “memoization speed test (annotation) (annotation) - include starray timing” at http://hpaste.org/70403#a70411
16:34:40 <jmcarthur> solrize: cool. thanks for sharing all this
16:35:14 <parcs`> you should benchmark unordered-containers too
16:47:07 <solrize> parcs` checking that
16:48:08 <solrize> parcs` do you think it can beat STArray?  i was thinking of trying Data.Vector
16:49:04 <solrize> i'm surprised STarray is so much slower than immutable lazy array
16:49:25 <solrize> although the Maybe in it probably slows it down
16:49:31 <solrize> any idea how to get rid of that?
16:49:58 <solrize> just use -1 as a sentinel or something?
16:53:52 <MostAwesomeDude> Is there a way to locally run hoogle? It'd be sweet if I could have a vim command for it.
16:54:04 <solrize> tried -1 as sentinel, that actually slowed it down
16:54:19 <parcs`> MostAwesomeDude: hoogle is a command line application
16:54:34 <MostAwesomeDude> parcs`: Really?
16:54:36 <blackdog> MostAwesomeDude: cabal install hoogle should do it
16:54:54 <blackdog> (i think you may have to run "hoogle data" or something afterwards to pull the database down)
16:54:55 <MostAwesomeDude> Nifty.
16:56:53 <MostAwesomeDude> @pl \x -> foldr ($) x y
16:56:53 <lambdabot> flip (foldr id) y
16:57:13 <MostAwesomeDude> lambdabot, the great obfuscator.
16:58:35 <YayMe> so binding question... I have bla :: Int -> Int -> R IO Int and I have 2 variables of A Int, how do I call bla with varA and varB both being type A Int
17:00:27 <YayMe> trying to use <- it complained that the type bla returned wasn't the same as the types in the <-
17:00:31 <YayMe> at least that's how I read it
17:00:37 <rwbarton> well of course you can't
17:00:40 <MostAwesomeDude> Hm. What are A and R? Are they just random types?
17:00:49 <YayMe> MostAwesomeDude: yeah
17:02:52 <rwbarton> if A is a Monad (or Applicative) you can get A (R IO Int) using liftM2/liftA2
17:03:44 <YayMe> A is maybe, is that a monad?
17:05:44 <rwbarton> yes
17:06:31 <rwbarton> now i imagine A (R IO Int) isn't the end result you want
17:06:46 <YayMe> I want R IO int
17:06:54 <parcs`> you can get R IO (A Int)
17:07:27 <parcs`> but you can't get R IO Int if A is maybe
17:08:51 <YayMe> There's no way?
17:09:02 <rwbarton> well this is a very concrete question
17:09:14 <rwbarton> if the Maybe (R IO Int) is Nothing, what R IO Int do you expect to produce
17:09:48 <YayMe> Well, I guarded against nothing already but yes it can't really guarantee the value can it
17:10:02 <YayMe> makes sense
17:10:07 <rwbarton> wait
17:10:11 <rwbarton> how did you "guard against nothing"
17:10:46 <YayMe> uhm, case or pattern match or something it's further up
17:10:47 <YayMe> wait
17:10:55 <YayMe> one sec let me look
17:11:26 <rwbarton> if you're pattern matching then you should just call bla on the Ints extracted from the Just constructors
17:11:28 <YayMe> yeah guard statement right above
17:11:37 <YayMe> How do I get them out?
17:11:44 <YayMe> with <- ?
17:11:44 <rwbarton> delete the guard and use pattern matching instead
17:11:57 <YayMe> the maybe val comes from a where
17:11:58 <rwbarton> is your guard something involving "isJust"
17:12:09 <rwbarton> okay, then you case use case
17:12:16 <rwbarton> *can use case
17:13:03 <rwbarton> maybe hpaste your code?
17:13:06 <rwbarton> @where hpaste
17:13:07 <YayMe> why not a guard? it's pretty much the same, no?
17:13:07 <lambdabot> http://hpaste.org/
17:13:14 <rwbarton> no
17:13:38 <rwbarton> a guard just checks
17:13:45 <rwbarton> a pattern match can check and extract at the same time
17:14:23 <YayMe> ah, interesting
17:14:27 <dolio> A pattern guard  can check and extract at the same time.
17:14:54 <YayMe> dolio: example or link?
17:15:12 <YayMe> ohh I get it
17:15:12 <dolio> foo x | Just y <- f x = ...
17:15:12 <rwbarton> you should learn to use pattern matching/case before learning to use pattern guards :)
17:15:21 <dolio> That's a custom extension, though.
17:15:46 <dolio> Also one I don't find myself using very often.
17:16:47 <harrison> leksah seems to work now
17:16:57 <harrison> a year or two ago it didn't
17:17:16 <donri> i read that "the new IO manager is single-threaded", does that mean you don't get the epoll stuff with -threaded?
17:17:19 <harrison> anyone here interested in graphics?
17:18:53 * hackagebot xml-types 0.3.2 - Basic types for representing XML  http://hackage.haskell.org/package/xml-types-0.3.2 (JohnMillikin)
17:19:32 <byorgey> harrison: many people here are interested in all sorts of graphics.  You'll probably get a better response if you are more specific.
17:30:19 <YayMe> Alright
17:30:29 <YayMe> the case can unpack the value for me
17:30:31 <YayMe> I got that
17:30:35 <YayMe> but remember there's 2 values
17:30:42 <YayMe> do I have to nest cases now?
17:30:45 <YayMe> Is there a shortcut?
17:30:48 <geekosaur> ?
17:30:58 <strager> Example?
17:31:31 <strager> case x of [((x, _), Just [y, z]), _] -> ...  -- You can nest constructor matches.
17:32:01 <YayMe> ah
17:32:23 <YayMe> I have to use [] ?
17:32:35 <YayMe> even though there's no relevant list to match on
17:33:23 <rwbarton> you can introduce a pair to match on
17:33:26 <rwbarton> case (x, y) of ...
17:33:46 <rwbarton> (Just a, Just b) -> ...
17:33:57 <YayMe> barton: do I have to? strager's example didn't do that
17:34:10 <rwbarton> of course you don't have to unless it is the thing that you want to do
17:35:17 <YayMe> rwbarton: but the example presented by strager would work as well? his example shows matching on a variety of values which aren't mentioned in the case
17:35:33 <kallisti> his example wasn't intended to work for your specific situation
17:35:39 <kallisti> it was an example of nesting constructors within a pattern
17:35:43 <kallisti> to show that it's possible.
17:36:20 <YayMe> makes me think that you could just case 3 of Just x
17:36:34 <rwbarton> if you like type errors :)
17:36:37 <YayMe> where x is a maybe that has nothing to do with the 3
17:36:51 <kallisti> > case 3 of Just x -> x
17:36:52 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
17:36:52 <lambdabot>    arising from a use of...
17:37:19 <YayMe> oh strager is nesting construction not matching
17:37:30 <kallisti> he is doing both
17:37:38 <kallisti> he's nesting constructors within a pattern match
17:38:01 <kallisti> with some example value named x
17:38:08 <kallisti> with a weird type.
17:38:50 <kallisti> > case [(1,2), (4,5] of [(x,y), (a,b)] in x+y+a+b
17:38:51 <lambdabot>   <no location info>: parse error on input `]'
17:38:58 <kallisti> > case [(1,2), (4,5)] of [(x,y), (a,b)] in x+y+a+b
17:38:59 <lambdabot>   <no location info>: parse error on input `in'
17:39:08 <kallisti> > case [(1,2), (4,5)] of [(x,y), (a,b)] -> x+y+a+b
17:39:09 <lambdabot>   12
17:39:24 <kallisti> hey look another example.
17:39:31 <kallisti> that is not intended to solve your specific problem.
17:40:16 <kallisti> YayMe: so to pattern match on 2 different values at the same time
17:40:19 <kallisti> you can just use a tuple
17:40:32 <kallisti> case (x, y) of (Just a, Just b) -> ...; _ -> ...
17:40:36 <kallisti> for example
17:41:09 <YayMe> yeah the tuple approach is most explicit
17:41:54 <strager> I was just taking a guess at your question =]
17:43:03 <mzero> i find the "case on a tuple" approach great - it often makes decision matricies plainly clear where in other languges there would an unsatisfying nested if
17:43:07 <YayMe> Yeah, sorry strager, I mentioned the details further up, your approach is a bit overmy head right now
17:43:36 <kallisti> YayMe: his was not an approach to your problem, as I said.
17:43:42 <YayMe> right
17:43:44 <kallisti> it was an example of the tool that you can use to solve problem
17:43:48 <kallisti> +the
17:44:18 <mzero> YayMe - what are you unpacking?
17:44:23 <YayMe> a maybe
17:44:28 <mzero> two of 'em?
17:44:47 <YayMe> yes
17:45:53 <mzero> then you can       case (thingOne, thingTwo) of   {   (Just t1, Just t2) -> t1 + t2;     (Nothing, _) -> 0;     (Just t1, Nothing)   -> t1 * 2;   }
17:45:54 <mzero> for example
17:46:00 <mzero> (with made up cases)
17:46:17 <mzero> just remember that the pattern matches are tested in order, and first one wins
17:46:20 <mzero> first match wins
17:46:33 <flebron> TIL: [a] can also be written [] a.
17:46:36 <mzero> if you turn on -Wall when you compile, then GHC will helpfully tell you when you've missed a case
17:46:46 <flebron> So [] really is the name of the Functor.
17:49:22 <nand`> note that case (a, b) of (Just a', Just b') -> f a' b'; (_, _) -> Nothing -- has a reduced form: f <$> a <*> b
17:49:50 <nand`> if that's what you're doing (I don't know what you're doing)
17:50:31 <rwbarton> one ought to learn to write the code with case first though
17:51:08 <nand`> that's arguably true for any abstraction
17:51:12 <rwbarton> yes
17:51:26 <nand`> most of them at any rate
17:52:06 <rwbarton> learn abstractions once writing the concrete version becomes too tedious
17:52:53 <nand`> depending on how loosely you define the term “abstraction” as well as what context; eg. I wouldn't claim it necessary to learn x86_64 machine code in order to use the GHC/Haskell abstraction for it
17:53:10 <flebron> In "f <$> a <*> b", should I read that as (f <$> a)  <*> b?
17:53:22 <rwbarton> flebron, yes
17:53:36 <flebron> And I should imagine that as fmap a?
17:53:44 <flebron> Err, fmap f a.
17:53:54 <nand`> fmap f a `ap` b
17:53:58 <otters> flebron: http://bm380.user.srcf.net/prettyparsetree.cgi?exp=x+
17:54:14 <nand`> or just liftM2 f a b
17:54:24 <ion> liftA2 f a b
17:55:28 <nand`> (as ion probably meant to point out; I'm juggling around with type classes here, knowing that the use case Maybe satisfies all three of them - but technically fmap f a `ap` b is less general than f <$> a <*> b)
17:56:15 <otters> fmap ($ b) (fmap f a)
17:56:55 <nand`> otters: note quite, no
17:56:58 <flebron> nand`, why is it less general? What is it assuming?
17:57:09 <otters> oh, you're right
17:57:11 <nand`> :t ap -- flebron
17:57:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:57:18 <rwbarton> ap predates Applicative
17:57:30 <flebron> Oh, but it should work fine for Applicative, shouldn't it?
17:57:32 <otters> @pl \x -> x b
17:57:33 <lambdabot> ($ b)
17:57:44 <nand`> flebron: not all applicatives are monads
17:57:49 <flebron> Right, right.
17:57:57 <nand`> hence less general
17:58:18 <flebron> But ap should be "applicative", that is, you only need to be applicative to define it. And whatever Monad definition, it should only use the Applicative aspect of the Monad.
17:58:38 <nand`> you're right in saying that ap should be Applicative
17:59:11 <nand`> but I think the purpose of ap is so you can easily provide an Applicative instance given fmap and join (ie. any Monad)
17:59:19 <nand`> and return too
18:00:26 <nand`> more Prelude whining: Monad should really have join as well, with bind and join defaulted in terms of eachother
18:00:47 <nand`> because some instances have much simpler joins than binds
18:00:58 <kallisti> but that sould require Monad to be a subclass of Functor
18:01:02 <kallisti> which is simply absurd!
18:01:17 <solrize> join = (>>=) . id
18:01:42 <nand`> really?
18:01:51 <c_wraith> err.  it's (>>= id)
18:01:53 <kallisti> no. not really.
18:01:54 <c_wraith> that's not the same
18:02:00 <solrize> hmm yeah
18:02:00 <flebron> join should be bind id
18:02:08 <solrize> join = (>>= id)
18:02:10 <ion> liftA2 f a b is defined as f <$> a <*> b, liftM2 is defined as f `liftM` a `ap` b IIRC. Any of the latter wouldn’t exist if not for the historical baggage. (Well, ap might be a convenient non-infix alias to (<*>) or vice versa.)
18:02:15 <otters> join *is* bind id
18:02:26 <flebron> and bind should be join . fmap
18:02:40 <kallisti> not quite
18:02:41 <nand`> except “bind” is not Prelude for some strange, strange reason, and we're stuck with these ugly >>= and =<< instead
18:02:43 <flebron> or something haha
18:02:57 <otters> >>= is beautiful
18:03:05 <kallisti> (join .) . flip fmap
18:03:20 <nand`> bind is join .: fmap
18:03:26 <otters> :t (.:)
18:03:27 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
18:04:02 <kallisti> so bind = (=<<)  ?
18:04:06 <nand`> yes
18:04:09 <flebron> I conceptually think of bind as joining a fmap :p
18:04:24 <nand`> flebron: that's a good way to think of it, because that's what it is :P
18:05:03 <flebron> I still haven't consolidated my practical view of the typeclassopedia with the category theoretical views of it, I hope to do that soon.
18:05:07 <nand`> bind, fmap and extend are all very related: bind :: (a -> m b) -> m a -> m b; fmap :: (a -> b) -> m a -> m b; extend :: (m a -> b) -> m a -> m b
18:05:17 <nand`> that's why I like putting the function first in their “regular” definition
18:05:34 * nand` is still stuck on adjuctions
18:05:37 <nand`> slowly, slowly
18:06:03 <flebron> Last I checked, I had computed some examples of monoid objects in monoidal categories.
18:06:49 <flebron> Oh, since I'm here. Why can (-> a) be called "reader"?
18:06:59 <flebron> Err, ((->) a), to be syntactically proper.
18:07:07 <ion> (a ->)
18:07:17 <flebron> Well I'd like that but it's a syntax error IIRC.
18:07:32 <flebron> So I'm stuck with ((->) a).
18:07:37 <ion> The a is an “environment” you can “read” at any point.
18:07:44 <nand`> flebron: the ‘a’ represents some form of shared parameter; the definition of join is basically the S combinator iirc
18:08:07 <ion> (->) a is the working syntax, yes, but (a ->) *would* be the matching section version.
18:08:11 <nand`> something like that anyhow; constructs a new Reader which passes the parameter to both of its sub-readers
18:08:26 <kallisti> flebron: look at the implementation of Reader and you'll see it's just a function from environment -> a
18:08:30 <kallisti> where a is the result of the monad
18:08:40 <flebron> Hrmph. So I can give it a type t, and it'll give me a way to read t's off the a?
18:08:47 <nand`> since the same parameter is passed to both; they all end up as the same. so Reader can be used to “read” the input at any given point in the computation
18:08:49 <nand`> unchangingly
18:09:10 <nand`> flebron: you mean a -> t?
18:09:35 <flebron> Yep.
18:09:39 <flebron> ((->) a) t.
18:10:43 <ion> Reader’s (<*>) is the S combinator. join seems to be the W combinator.
18:11:02 <donri> > (do { x <- (+4); return (x * 2); }) 3
18:11:03 <lambdabot>   14
18:11:27 <nand`> ion: isn't reader's (=<<) the S combinator? (a -> r -> b) -> (r -> a) -> r -> b
18:11:27 <ion> ((+4) * 2) 3
18:11:37 <ion> > ((+4) * 2) 3
18:11:37 <lambdabot>   14
18:11:41 <tgeeky> nand`: no?
18:11:52 <otters> huh
18:11:57 <otters> I'm getting "no instance for Num (a -> a)
18:11:59 <otters> "
18:12:16 <tgeeky> nand`: has a flip in it
18:12:20 <donri> lambdabot has some crazy instances
18:12:27 <ion> @hackage NumInstances -- otters
18:12:27 <lambdabot> http://hackage.haskell.org/package/NumInstances -- otters
18:12:28 <otters> yep
18:12:45 <nand`> :t \x y z -> x z (y z) -- s comb
18:12:46 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
18:12:51 <tgeeky> nand`: S should be: (a -> b -> c) -> (a -> b) -> a -> c
18:12:57 <tgeeky> yeah, that looks right
18:13:17 <nand`> oh
18:13:21 <tgeeky> you started with a (on the left of (a -> r -> b))
18:13:24 <tgeeky> but then took r -> a
18:13:33 <nand`> yeah, not quite the same thing
18:13:54 <donri> i read in the monad reader 19 that "the new IO manager is single-threaded", does that mean you don't get the epoll/kqueue stuff with -threaded?
18:13:55 <mparodi_> wow! it's incredible how fast it runs when you compile the code
18:14:01 <lewis1711> could you emulate dynamic typing by just making a huge variant type and having a bunch of functions with incomplete pattern matching? (not saying you should, but for arguments sake)
18:14:04 <palmfrond> in a chemical or energetic chain reaction, what's the term for the state where nothing is happening?
18:14:06 <mparodi_> (I was used to run it on ghci)
18:14:16 <ion> > (=<<) f g x
18:14:16 <tgeeky> palmfrond: equilibrium?
18:14:17 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:14:17 <lambdabot>    `GHC.Show.Show a'
18:14:17 <lambdabot>      a...
18:14:20 <palmfrond> i don't know who else to ask that's smart aside from haskell users
18:14:27 <tgeeky> palmfrond: I'm a physicist, not a chemist.
18:14:32 <ion> > (=<<) (f :: Expr -> Expr -> Expr) g x
18:14:33 <lambdabot>   f (g x) x
18:14:40 <blackdog> lewis1711: there are m]
18:14:40 <ion> > (<*>) (f :: Expr -> Expr -> Expr) g x
18:14:41 <lambdabot>   f x (g x)
18:14:48 <palmfrond> tgeeky, ok good to know. with that mind, how does "stasis" touch you?
18:14:50 <blackdog> ]]better ways of emulating dynamic typing, if that's what you really want.
18:15:01 <tgeeky> palmfrond: reminds me of star trek
18:15:35 <palmfrond> tgeeky, rofl.
18:15:43 <tgeeky> palmfrond: that sounds ore like what you were describing than equilibrium
18:15:53 <palmfrond> tgeeky, if you saw the term statis used in documentation to refer to equilibrium what would you think?
18:15:58 <tgeeky> equilibrium is when many things can happen, but their net effect is to go to equilibrium
18:16:12 <solrize> lewis1711, no i don't think that's possible, there are an infinite number of types possible and you can't match them all in a sum type
18:16:12 <lewis1711> blackdog: such as? I am not so much wondering if it's a good emulation within haskell, rather that if its a valid one
18:16:20 <palmfrond> i'm looking for a sequence point or rest period in a system, any kind
18:16:21 <solrize> look at data.dynamic
18:16:25 <nand`> data Dynamic = (Show s, Read s) => Dynamic String
18:16:36 <tgeeky> palmfrond: maybe a lull?
18:16:42 <palmfrond> where things may have potential to happen (kinetic) or may be in the process of happening, but for that moment state is stable
18:16:47 <nand`> data Dynamic s*
18:17:14 <solrize> nand` ??
18:17:18 <tgeeky> palmfrond: well, what you just described "where things have the potential to happen, but they don't"
18:17:26 <tgeeky> is almost exactly the definition of a symmetry
18:17:27 <palmfrond> but are not yet
18:17:32 <palmfrond> you said but they don't
18:17:39 <palmfrond> a snapshot in time between events
18:17:39 <tgeeky> yes, I mean that
18:17:52 <palmfrond> ok and then which term do you find most precise & appropriate?
18:18:54 <palmfrond> it's feeling kind of like punctuated equilibrium, but it seems like such pop-theory, i'd prefer to stay more rudimentary/classic
18:19:47 <tgeeky> maybe 'ground' as in, ground state?
18:19:54 <tgeeky> or stable
18:20:02 <tgeeky> i wouldn't use stasis, symmetry, or equilibrium
18:20:14 <nand`> solrize: I'm being silly; but fromDynamic (Dynamic s) = read s; toDynamic = Dynamic . show; coerceDynamic = toDynamic . fromDynamic
18:20:57 <nand`> let d5 = toDynamic 5 :: Dynamic Int; dplus a b = toDynamic (fromDynamic a + fromDynamic b) in fromDynamic (dplus d5 d5) :: Double -- works
18:22:09 <nand`> of course mixing incompatible types now ends up with “*** Exception: Prelude.read: no parse” :P
18:22:17 <palmfrond> tgeeky, actually, what about going ultra-classic with "rest" ?
18:22:26 <tgeeky> no
18:22:26 <nand`> s/Dynamic/PHP/ -- and now a sufficiently scary name to scare off sensible programmers
18:22:31 <tgeeky> :)
18:22:35 <palmfrond> explain?
18:22:44 <tgeeky> hehe. physicists don't like the term, and almost nobody ever gets it right
18:23:01 <palmfrond> no kidding? it's a special term? please explain the general sentiment toward it
18:23:22 <tgeeky> rest is only useful in the quantum physics sense: the [rest] mass of a particle is defined as the total energy when the total kinetic energy is 0.
18:23:30 <tgeeky> and in such a case, you can just drop the word 'mass'
18:23:31 <tgeeky> err
18:23:32 <tgeeky> 'rest'
18:24:43 <solrize> nand` what do you do about Dynamic sqrt?
18:24:48 <solrize> > Dynamic sqrt
18:24:49 <lambdabot>   Not in scope: data constructor `Dynamic'
18:25:05 <palmfrond> hmm
18:25:07 <S11001001> :t sqrt
18:25:08 <lambdabot> forall a. (Floating a) => a -> a
18:25:10 <palmfrond> dunno man, i'm vibing with rest
18:25:19 <S11001001> can't toDyn that sqrt
18:25:49 <S11001001> :t Data.Dynamic.toDyn sqrt
18:25:50 <lambdabot> Dynamic
18:25:55 <S11001001> well then.
18:25:57 <solrize> Prelude Data.Dynamic> let a = toDyn sqrt
18:25:57 <solrize> Prelude Data.Dynamic> a
18:25:57 <solrize> <<Double -> Double>>
18:25:57 <solrize> Prelude Data.Dynamic>
18:26:03 <S11001001> oh yeah, defaulting
18:27:46 <solrize> so does anyone use acid-state?  it sounded like a great idea but then i saw some pretty miserable benchmarks...
18:29:27 <hpc> i am using it, but i wouldn't presume to say ive benchmarked it
18:29:50 <hpc> the naive counter example in the happstack docs can do at least 100 concurrent requests on my dinky celeron craptop
18:30:04 <hpc> compared to 2 concurrent CGI scripts
18:30:22 <stepcut> solrize: which benchmarks are those?
18:48:25 <\rs> i'm processing a json file with `aeson' while encounters  Cannot decode byte '\xb3': Data.Text.Encoding.decodeUtf8: Invalid UTF-8 stream
18:49:09 <\rs> how can Data.Aeson.encode neglect the erroneous byte and process the resting bytes?
18:49:58 <\rs> my fault, i mean Data.Aeson.decode
18:59:22 <strager> \rs: Filter the input before-hand perhaps?
18:59:30 <strager> I don't think you can hook into aeson like that.
19:00:33 <solrize> stepcut, they were on some blog a while back... i didn't save a link, i'm surfing around a little for it now but not finding it
19:00:38 <\rs> strager: i see. Data.Aeson.Parser.jstring_ uses decodeUtf8
19:00:52 <harrison> byorgey et al : who wants a realtime raytraced sierpinski flythrough demo? i'd like to see how fast the algorithm can perform when ported to haskell. multicore? si, senor!
19:01:04 <stepcut> solrize: I would be quite interested in seeing them
19:01:14 <\rs> strager: what's the preferred approach to valify and rectify a utf8 encoded document?
19:01:24 <harrison> rectify lol
19:01:34 <harrison> sounds nasty
19:02:13 <stepcut> solrize: I started some benchmarks here. http://patch-tag.com/r/stepcut/acid-state-benchmarks/home, only one test so far.. but it was hundreds or thousands of times faster than sqlite.. clearly one data point is not very meaningful though :)
19:02:35 <stepcut> especially if I don't actually record the data point for future reference :)
19:03:37 <solrize> stepcut yeah the problems happen when there's high concurrency and a lot of data
19:03:45 <strager> \rs: run decodeUtf8With on the ByteString, then run encodeUtf8 on its output.
19:04:44 <stepcut> solrize: high concurrency in what sense? That benchmark I posted forks off 100,000 threads that all try to update the counter at the same time..
19:05:13 <solrize> nice :)
19:05:19 <solrize> yeah that would count as high concurrency
19:05:56 <solrize> but, what if the threads are updating different parts of the data?  still doesn't seem so bad
19:06:42 <strager> > (Data.Text.Encoding.encodeUtf8 . Data.Text.Encoding.decodeUtf8With (const $ const Nothing)) [65, 65, 0xB3]
19:06:43 <mparodi_> what's the easiest way to implement subsequence?
19:06:44 <lambdabot>   Not in scope: `Data.Text.Encoding.encodeUtf8'Not in scope: `Data.Text.Encod...
19:06:57 <mparodi_> @src subsequences
19:06:57 <lambdabot> Source not found. You untyped fool!
19:06:59 <mparodi_> @src subsequence
19:07:00 <lambdabot> Source not found. My mind is going. I can feel it.
19:07:01 <strager> \rs: ^ that, with BS.pack.
19:07:20 <strager> This skips all UTF-8 decoding erros
19:07:23 <strager> errors*
19:07:55 <mparodi_> this is the official implementation, I believe: http://paste.kde.org/507110
19:09:33 <mparodi_> nonEmptySubseq is pretty obscure
19:10:47 <syntaxfree> what's a great cookbook-type book on Haskell?
19:11:23 <syntaxfree> I'm a fan of "Computational Geometry in C++"`s style.
19:11:51 <syntaxfree> I know some Haskell, I want to start moving our code base to Haskell, but I don't have that much time or energy to develop. I still have my day job.
19:15:29 <monochrom> "real world haskell" seems to be great and cookbook
19:16:14 <monochrom> but see my http://www.vex.net/~trebla/humour/programming_books.html :)
19:16:31 <syntaxfree> oh, dons is a co-author.
19:16:39 <syntaxfree> mese a fan of dons.
19:17:09 <syntaxfree> what is that animal, though? they couldn't fit in one of shapr's unicycles?
19:17:30 <monochrom> I don't know most animals
19:17:48 <syntaxfree> what's the irc nickname of the other guys? bryan o'sullivan and goerzen? if any.
19:18:20 <monochrom> bos. dunno about goerzen
19:18:32 <Clint> goerzen is/was CosmicRay
19:18:46 <Clint> s#/was##
19:19:24 <syntaxfree> oh.
19:19:35 <monochrom> ooohhh I know how to add interactivity to my page!
19:20:07 <syntaxfree> the amazon reviews are kinda discouraging.
19:20:37 <syntaxfree> in that it supposedly teaches well the stuff I already know and starts to stutter at a JSON pretty-printer.
19:22:27 <palmfrond> lol
19:30:53 <shapr> syntaxfree: haha
19:31:38 <syntaxfree> Amazon kills me. I log in for a practical need and this is what I'm buying instead.
19:31:48 <syntaxfree> Introduction to Topology: Third Edition (Dover Books on Mathematics) - Bert Mendelson;
19:31:56 <syntaxfree> Nonlinearity, Complexity and Randomness in Economics: Towards Algorithmic Foundations for Economics (Surveys of Recent Research in Economics) - Stefano Zambelli; Paperback
19:32:04 <syntaxfree> Partial Differential Equations for Scientists and Engineers (Dover Books on Mathematics) - Stanley J. Farlow; Paperback
19:32:12 <syntaxfree> Numerical Recipes 3rd Edition: The Art of Scientific Computing - William H. Press; Hardcover
19:32:22 <syntaxfree> The Haskell Road to Logic, Maths and Programming (Texts in Computing) - Kees Doets;
19:32:28 <syntaxfree> The Cauchy-Schwarz Master Class: An Introduction to the Art of Mathematical Inequalities (Maa Problem Books Series.) - J. Michael Steele; Paperback
19:32:36 <syntaxfree> Introduction to Algorithms - Thomas H. Cormen; Hardcover
19:32:58 <syntaxfree> I don't even have the shelf space, or floor space, or box space, for moar books.
19:33:27 <syntaxfree> I'm trying to cut down that list, but I don't see how!
19:33:51 <shachaf> syntaxfree: Pick which one you're going to read first, order that one, read it.
19:34:09 <shachaf> Some of those will probably take you a few months at least.
19:34:25 <syntaxfree> there is a nonzero fixed shipping cost to Brazil.
19:34:38 <syntaxfree> so it's basically optimal to buy all the Amazon catalog.
19:34:46 <shachaf> Not really.
19:34:53 <shachaf> What's the cost?
19:35:13 <syntaxfree> I only _need_ 3 of those.
19:35:22 <syntaxfree> two of them are  really cheap.
19:35:30 <syntaxfree> two are infatuations.
19:35:55 <shachaf> The time you'll invest in these books is probably going to be way more important than the money you invest in them.
19:36:34 <syntaxfree> I know.
19:36:53 <syntaxfree> it's the physical space that worries me a bit. I'm drowning in books.
19:37:44 <syntaxfree> but the books I need the most (numerical recipes and algorithms) are the bulkiest.
19:37:57 <shachaf> Why do you need those the most?
19:39:21 <syntaxfree> I'm trying to move some code from Matlab into something more realistic. Right now, it runs in Octave on the web server. But Octave sucks.
19:40:19 <syntaxfree> it's for-theoretical-profit.
19:40:45 <Khorvo> Coming from a C-based language background, the Haskell syntax is starting to get really daunting - specifically around function declaration and function bodies... Does anyone know of a good resource that could help me achieve some syntax clarity?
19:41:04 <syntaxfree> I actually come from a Scheme/Haskell-type background.
19:41:21 <syntaxfree> I know some C++ from my Arduino experiments, but pretty simple stuff.
19:41:51 <syntaxfree> as for Matlab, one picks it up as one goes.
19:42:08 <syntaxfree> and Matlab is fast. Open source/free Matlab interpreters are the problem
19:42:49 <applicative> Khorvo, what sort of thing is seeming opaque?
19:42:57 <syntaxfree> right now we just got some angel money enough for six months of travel to meet clients and VC boards.
19:43:48 <solrize> those two books (numerical recipes, and CLRS) are really good
19:44:00 <Khorvo> applicative: stuff like functionName :: (Ord a) => (a ->a) a -> a -> a
19:44:36 <Khorvo> applicative, it's hard for me to discern what are the parameters and what is the output
19:44:41 <applicative> Khorvo: yes, class constraints are a little hard.
19:45:11 <applicative> But what about (Int -> Int) -> Int -> Int  does that seem opaque?
19:45:15 <geekosaur> everything before the last outer -> is parameter
19:45:40 <geekosaur> that said, the whole notion is fluid, which may be your real problem
19:45:49 <Khorvo> applicative, yeah, it does.
19:46:01 <Khorvo> but what geekosaur just said helps actually
19:46:26 <Khorvo> but I'm not quite getting the parentheses when you have a function that accepts another function as a parameter
19:46:31 <geekosaur> you can view applicative's example as applicative wrote it (a function from Int to Int, and an Int, to an Int) or as (function from Int to Int) to (function from Int to Int)
19:46:37 <applicative> Khorvo: it can be construed as having on parameter, a function, and returning a function - the more official construction
19:46:45 <syntaxfree> meh, I just pressed buy. As far as impulsive purchases go, one can do worse.
19:46:58 <syntaxfree> solrize: what do you mean, CLRS?
19:46:59 <geekosaur> so yes, it is kinda tricky to figure out
19:47:07 <applicative> or you can view it in  the other way geekosaur mentioned
19:48:12 <Khorvo> so the parens are actually describing the behavior of the function parameter?
19:48:34 <geekosaur> (Int -> Int) is the type of a function
19:48:51 <applicative> Khorvo: take the longer signature (Int->Int) -> Int -> Int -> Int
19:48:59 <syntaxfree> (a -> a) is a function.
19:49:00 <syntaxfree> but.
19:49:11 <applicative> we can view this as (Int->Int) -> Int -> (Int -> Int)
19:49:15 <syntaxfree> @hoogle (a->a) -> a -> a
19:49:16 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
19:49:16 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
19:49:16 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
19:49:21 <geekosaur> but there's something else rather subtle here, related to currying
19:49:40 <Khorvo> yeah that's sort of what is messing me up
19:49:42 <geekosaur> in reality, anuy multiple-argument function is really a single-argument function
19:49:48 <Khorvo> right
19:49:56 <Khorvo> it just returns the partial function
19:49:57 <syntaxfree> Khorvo: check this out:
19:50:00 <applicative> then an example would be a function that takes and Int->Int function and applies it some-Int many times
19:50:02 <geekosaur> that returns a new function which is a partially applied version of the original one
19:50:03 <Khorvo> but that's sort of under-the-hood?
19:50:10 <syntaxfree> @pl f x y z = g (x y) z
19:50:10 <lambdabot> f = (g .)
19:50:10 <geekosaur> not really, no
19:50:13 <syntaxfree> see?
19:50:18 <geekosaur> it's key to how partial application works
19:50:37 <geekosaur> and a very large part of what makes haskell a *functional* programming language
19:51:01 <geekosaur> you are constantly generating new functions on the fly by partial application, and those functions can get pretty interesting
19:51:14 <syntaxfree> s/functional/awesome
19:51:37 <geekosaur> once you figure it out, though, you'll wonder where this has been your entire programming life
19:51:40 <Khorvo> so I sort of understand guards... but "let" and "where" are messing me up too... What exactly are they meant to do?
19:52:03 <Khorvo> and where is the equivalent of the "return" statement in a function body?
19:52:15 <syntaxfree> let and where are syntactic sugar
19:52:20 <applicative> @type let church f 0 x = x; church f (n+1) x = f (church f n x) in church
19:52:21 <lambdabot> forall t t1. (Integral t1) => (t -> t) -> t1 -> t -> t
19:52:32 <rwbarton> (Int -> Int) -> Int -> Int -> Int is just Haskell's confusing notation for int (*(*(int (*)(int)))(int))(int).
19:52:41 <applicative> ^^^ Khorvo so there's you type or something like it
19:52:43 <rwbarton> Does that help? :P
19:52:48 <syntaxfree> > f x y = x*y where x = 2*y
19:52:49 <lambdabot>   <no location info>: parse error on input `='
19:53:06 <syntaxfree> or something.
19:53:28 <applicative> it can be specialized to (Int -> Int) -> Int -> (Int -> Int)
19:53:34 <applicative> @type let church f 0 x = x; church f (n+1) x = f (church f n x) in church 5
19:53:35 <lambdabot> forall t t1. (Integral t1, Num t) => t1 -> t -> t
19:53:45 <syntaxfree> > f x y = x*y = where { x = 2*y}
19:53:46 <lambdabot>   <no location info>: parse error on input `='
19:53:50 <applicative> @type let church f 0 x = x; church f (n+1) x = f (church f n x) in church (+1) 5 rather
19:53:51 <lambdabot> Not in scope: `rather'
19:54:00 <Khorvo> applicative, Okay I think i'm getting function declaration a lot better now
19:54:06 <applicative> @type let church f 0 x = x; church f (n+1) x = f (church f n x) in church (+1) 5  --rather
19:54:07 <lambdabot> forall a. (Num a) => a -> a
19:54:31 <applicative> so given a function and a number, we get a new number->number function
19:55:19 <applicative> > let church f 0 x = x; church f (n+1) x = f (church f n x) in church (+1) 5 0
19:55:21 <lambdabot>   <no location info>: Parse error in pattern
19:55:28 <applicative> man trouble
19:55:29 <Khorvo> applicative, I'm a little fuzzy on what exactly the church function is trying to tell me
19:55:46 <applicative> to iterate the function n times
19:55:50 <Khorvo> i've never seen the "@type" keyword before
19:56:13 <applicative> so church f 0 x is 'do nothing with f to x' , i.e. x
19:56:28 <applicative> Khorvo: its not a keyword its a signal to the bot
19:56:41 <Khorvo> applicative,  oh -.-
19:57:43 <liyang> You can do the same thing in ghci with :t expression.
19:58:37 <syntaxfree> @pl a b c d = a (b c) d (c a)
19:58:37 <lambdabot> a = fix (ap (flip . (liftM2 flip .) . (.)) (flip id))
19:59:06 <Khorvo> syntaxfree, okay now i'm just confused -.-
19:59:31 <Eduard_Munteanu> @help pl
19:59:31 <lambdabot> pointless <expr>. Play with pointfree code.
19:59:34 <Khorvo> so what exactly are where and let syntactic sugar for?
19:59:58 <syntaxfree> say you have a complicated function statement
20:00:06 <Khorvo> okay
20:00:27 <syntaxfree> this_is_hard = f (a * map f xs) * (b * zipWtih f xs)
20:01:17 <syntaxfree> this_is_clean = (f x1) * x2 where { x1 = a*map f xs); x2 =  b*zipWith f xs}
20:01:35 <syntaxfree> see? syntactic sugar.
20:02:55 <Khorvo> oh okay so "where" is just defining things that you've already typed out at the beginning of your expression?
20:03:16 <rwbarton> technically let/where are not really syntactic sugar for anything
20:03:27 <Khorvo> rwbarton, oh lawds
20:03:29 <syntaxfree> listen to rwbarton.
20:04:08 <rwbarton> they are just how you define identifiers within an expression or a declaration
20:04:21 <ion> (\x -> x + 1) 42
20:04:24 <ion> let x = 42 in x + 1
20:04:35 <rwbarton> let-bound variables are polymorphic though
20:04:37 <S11001001> ion: not quite
20:04:39 <S11001001> > take 5 (let x = (3:) x in x)
20:04:41 <lambdabot>   [3,3,3,3,3]
20:04:47 <Khorvo> okay that makes a lot more sense... I guess the fact that they are defined AFTER you give out your expression messed me up
20:05:00 <S11001001> ion: note the x on rhs of the let
20:05:03 <Khorvo> usually when you're using variables in other languages, you define what they are before you define what they are doing
20:05:11 <rwbarton> right
20:05:26 <rwbarton> because in most other languages, the evaluation order matters and it would be confusing for evaluation order to jump around
20:05:38 <ion> khorvo: Yeah, that order is rather illogical IMNSHO. I prefer to put the most significant stuff on the top and the lower-level definitions later.
20:05:53 <syntaxfree> @pl f x y = 1/(1+exp(-(x-y)/400))
20:05:53 <lambdabot> f = (((1 /) . (1 +) . exp . negate) .) . flip flip 400 . ((/) .) . (-)
20:06:19 <S11001001> > take 5 (let x = 3:y; y = 4:x in x)
20:06:20 <lambdabot>   [3,4,3,4,3]
20:06:43 <shachaf> rwbarton: I think "where" is sugar for "let".
20:06:50 <S11001001> lambdabot: botsnack
20:07:08 <rwbarton> probably one is sugar for the other yeah
20:07:23 <shachaf> http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-860004.4.3.2
20:07:25 <ion> shachaf: Well, maybe let+case when “where” applies to multiple guards.
20:07:27 <Khorvo> That's a pretty interesting point ion
20:07:29 <tgeeky> let is the real deal
20:07:38 <liyang> There are no where clauses in Core.
20:07:45 <applicative> let goes deeper, let and case are in core, for example
20:07:49 <shachaf> ion: Yes, but you can desugar that into "let"s and "case"s.
20:07:53 <tgeeky> liyang: ut oh!
20:07:55 <shachaf> liyang: Core is not part of the semantics of Haskell. :-)
20:07:58 <tgeeky> conflicting information :o
20:08:02 <ion> shachaf: Yes, that’s what i meant. :-)
20:08:14 <shachaf> ion: Oh, now I see. Yes.
20:08:22 <tgeeky> either way, the major difference is let can be nested and where can't, so let must be the more important one?
20:08:36 <Eduard_Munteanu> Well, then I'm not sure the semantics of Haskell talk about what's sugar for what in this case :)
20:08:44 <shachaf> tgeeky: The major difference is that "let ... in ..." is an expression, but "where" applies to a binding.
20:09:38 <Khorvo> Well thanks guys, that helped a lot
20:09:44 <Eduard_Munteanu> Unlike say, do notation.
20:10:14 <rwbarton> oh right, you can also use where in a case branch so i need to look there for the translation
20:10:30 <shachaf> > do let in do case let in on of on -> on (==) head "where" "what"
20:10:31 <lambdabot>   True
20:10:44 <Eduard_Munteanu> > buffalo buffalo buffalo
20:10:45 <lambdabot>   Not in scope: `buffalo'Not in scope: `buffalo'Not in scope: `buffalo'
20:10:49 <applicative> Khorvo: but I think 'where' is really self explanatory, i mean you should take it that way
20:11:14 <tgeeky> shachaf: well that's not fair, where in in quotes! :o
20:11:36 <shachaf> > so "what"
20:11:39 <lambdabot>   tgeeky
20:11:51 * tgeeky giggles
20:11:54 <Khorvo> applicative, Yeah it definitely works in the grammatical sense the way it's used in Haskell
20:12:41 <applicative> Khorvo: thats right it's very close.  I think Turner introduced it in Miranda or before, he seems to have had a good sense for these things
20:13:49 <applicative> like just writing "square x = x * x" in the left margin rather than using let or let rec or some complicated curly  bracket nonsense
20:14:10 <applicative> or fun of def and on and on.
20:15:39 <Eduard_Munteanu> Somebody had too much ML? :P
20:15:43 <shachaf> > do let in do case let in on of on | otherwise -> let on = off in off (==) 1 otherwise otherwise | otherwise -> otherwise where off = on
20:15:45 <lambdabot>   True
20:15:49 <rwbarton> shachaf: Where you had '"where"', "where" was also valid.
20:16:12 <shachaf> rwbarton: What? Where?
20:16:38 <rwbarton> In your first example.
20:16:43 <ion> > do do do do do do do dο
20:16:44 <lambdabot>   do do do do do do do do
20:16:47 <rwbarton> But you seem to have noticed that
20:17:00 <geekosaur> do be do be do?
20:17:00 <applicative> Khorvo: that you can introduce terms after you have 'already' used them is one of the more pleasing features of haskell.  your module is a system of definitions.
20:17:02 <shachaf> rwbarton: You mean I could s/"where"/where/ in my first line there?
20:17:02 <Eduard_Munteanu> > do let in do case let in on of on -> on (==) head where "what"
20:17:04 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:17:07 <rwbarton> no
20:17:08 <shachaf> That doesn't look right.
20:17:14 <rwbarton> the rest would need to change too.
20:17:24 <Eduard_Munteanu> > do let in do case let in on of on -> on (==) head where who = "what"
20:17:26 <lambdabot>   Overlapping instances for GHC.Show.Show
20:17:26 <lambdabot>                              ([a] -...
20:17:40 <shachaf> Oh, well, sure. If you change one part of it, and also the rest of it, you can change all of it.
20:17:42 <Eduard_Munteanu> Right.
20:17:45 <rwbarton> @undo do do do do do
20:17:45 <lambdabot>  Parse error at end of input
20:17:47 <Eduard_Munteanu> > do let in do case let in on of on -> on (==) head who where who = "what"
20:17:49 <lambdabot>   Overlapping instances for GHC.Show.Show
20:17:49 <lambdabot>                              ([GHC....
20:17:53 <rwbarton> @undo do do do doooo
20:17:54 <lambdabot> doooo
20:17:58 <shachaf> (In order to make where work, I'd need "=", I think.)
20:17:59 <applicative> that you have to introduce terms in a definite sequence give an imperative and scriptlike character to the whole thing; I find the even in agda
20:19:05 <shachaf> @let don't _ = return ()
20:19:06 <lambdabot>  Defined.
20:19:48 <\rs> how to decode a utf8-encoded json (no escapes) with aeson? i'll receive an error "Cannot decode byte '\xbc': Data.Text.Encoding.decodeUtf8: Invalid UTF-8" if i try to Data.Aeson.decode it directly
20:19:49 <tgeeky> hmm
20:19:52 <ion> I think there’s an ACME module for Perl that implements don't.
20:20:12 <rwbarton> \rs, your question was answered earlier
20:20:58 <tgeeky> @let g t = let { ?x = t } in let { ?y = ?x + (1 :: Int) } in ?x + ?y
20:20:58 <lambdabot>   Parse error: ?
20:21:14 <tgeeky> so what do you suppose 'g 5' is?
20:21:26 <ion> rs: If you try to apply Data.Text.Encoding.decodeUtf8 to the raw content of the file, do you still get the error?
20:22:10 <\rs> rwbarton: sorry but i was sleepy that time and cannot recall your answer
20:22:17 <rwbarton> it wasn't my answer
20:22:26 <geekosaur> that looks more like iso8859-1 than utf8
20:23:09 <shachaf> \xbc is a continuation byte in UTF-8
20:23:10 <rwbarton> > let {g t = let { ?x = t } in let { ?y = ?x + (1 :: Int) } in ?x + ?y} in g 5
20:23:11 <lambdabot>   11
20:23:37 <tgeeky> how did you get him to ignore implicit paramters?
20:23:39 <tgeeky> or ca you turn it on?
20:23:43 <shachaf> > let ?x = 5; ?x = ?x + 1 in ?x
20:23:44 <tgeeky> her?
20:23:45 <lambdabot>   mueval-core: internal error: PAP object entered!
20:23:45 <lambdabot>      (GHC version 6.12.3 f...
20:23:47 <shachaf> Oh, nifty!
20:24:04 * applicative continues to refuse to understand so-called implicit parameters
20:24:20 <shachaf> applicative: They're just, like, parameters which are, like, implicit, dude.
20:24:27 <shachaf> Y'know?
20:24:39 * applicative had stopped up his ears for that
20:24:41 <tgeeky> applicative: just imagine a function where you're obligated to provide a list of function definitions of known types
20:24:46 <geekosaur> the @let parser doesn't understand them.  I presume it uses haskell-src-exts and just doesn't have implicit parameter support turned on
20:24:58 <tgeeky> geekosaur: ah, ok
20:25:12 <rwbarton> I don't really understand why @let even has a parser
20:25:22 <tgeeky> blame dons?
20:25:23 <rwbarton> @let hello = () () ()
20:25:24 <lambdabot>  <local>:2:8:
20:25:24 <lambdabot>      Couldn't match expected type `() -> () -> t'
20:25:24 <lambdabot>             a...
20:25:29 <shachaf> rwbarton: So that you only stick reasonable definitions into L.hs
20:25:34 <geekosaur> so you can't screw lambdabot up by embedding invalid haskell in L.hs
20:25:40 <rwbarton> hmm
20:25:41 <shachaf> If you get unsafePerformIO into that file you can run code on that system.
20:25:52 <tgeeky> oh, L is stored as a file? cute
20:25:54 <geekosaur> or unsafe haskell, yeh
20:25:55 <tgeeky> that makes sense
20:26:05 <ion> FSVO sense
20:26:24 <geekosaur> that's also why you sometimes see errors about missing L.hs if two people try to @run at the same time; evidently there's a race condition
20:26:40 <geekosaur> (hopefully a harmless one aside from those errors)
20:26:41 <rwbarton> i guess the idea is to stop @let import System.Unsafe?
20:26:50 <shachaf> And many other harmful @lets.
20:26:55 <geekosaur> ^^
20:26:58 <rwbarton> like what
20:27:08 <shachaf> Well, unsafeCoerce or anything that lets you make unsafeCoerce.
20:27:17 <tgeeky> applicative: the "useful" case is where you use implicit paramters-as-values, and learn the type of something embedded in an expression
20:27:19 <shachaf> Various pragmas.
20:27:26 <rwbarton> what is so special about L.hs compared to what I can do with >
20:27:27 * applicative looks forward to a world where hordes of evil programmers are trying to get unsafePerformIO into the immense tide of haskell servers
20:27:34 <rwbarton> pragmas, ok, i guess
20:27:35 <shachaf> rwbarton: > also has a parser.
20:27:40 <\rs> ion: fromJSON . decodeUtf8 ?
20:27:57 <applicative> tgeeky: yes, that I noticed somewhere recently, it did make me want to know more.
20:28:02 <ion> rs: No, just decodeUtf8. Does that fail in a similar manner?
20:28:03 * shachaf is not at all confident in lambdabot's security.
20:28:14 <applicative> tgeeky: but I'm waiting for -XHoles
20:28:32 <tgeeky> applicative: yeah. obviously a better approach
20:28:36 <ion> -XAssholes
20:29:02 <applicative> I tried the somewhat related extension that suspends typechecking
20:29:15 <tgeeky> applicative: here is a nice case that I'm using implicit paramters for: k :: (?k'::b -> Cxt a, ?g::b -> (b, b)) => b -> Tree a
20:30:15 <tgeeky> so, if you have a b which can give you all of:  (Cxt a, (b,b)), you can get a Tree a
20:30:26 <\rs> ion: decodeUtf8 do not fail
20:31:05 <ion> rs: Ok. I’d look at aeson’s source and see what it does to the data before decodeUtf8 to make it fail.
20:31:54 <tgeeky> applicative: it's kind of cool to see implicit paramters 'infect' your functions
20:31:57 <\rs> ion: thx. i use fromJSON . decode . BL.fromChunks . (:[]) . B.dropWhile (/=fromIntegral (ord '{'))) `liftM` liftIO (F.withFile jsonpath F.ReadMode hGetLine)
20:33:09 <applicative> tgeeky: well, maybe I will study it.  I think its just that they're ugly at least til you get them properly
20:33:18 <tgeeky> they are very ugly
20:33:41 <ion> rs: What does “decode” do?
20:33:52 <tgeeky> and I'm not sure if they are even appropriate to use (and while they act like constraints, and can be placed where constraints go) -- they don't actually work for class definitions
20:34:01 <tgeeky> (or instance defs)
20:34:37 <ion> rs: Ah, it comes from aeson. Okay.
20:34:56 <applicative> decode = decodeUtf8
20:35:53 <applicative> Khorvo: I meant to print this link http://ccfit.nsu.ru/~ikuznecov/doc/Haskell%20Tutorial%20for%20C%20Programmers/section1.html#part1 I'm not sure how reliable it is, but he has side by side exxamples
20:37:32 <\rs> oh, it's decode . BL.fromChunks . (:[]) . B.dropWhile (/=fromIntegral (ord '{'))) `liftM` liftIO (F.withFile jsonpath F.ReadMode B.hGetLine)
20:38:03 <\rs> ion: Data.Aeson.decode :: FromJSON a => ByteString(lazy) -> Maybe a
20:38:05 <rwbarton> when you say decodeUtf8 does not fail, are you sure you are forcing evaluation of the whole result
20:39:50 <edwardk> can someone take a chance to proofread http://comonad.com/reader/2012/mirrored-lenses/ before it hits planet haskell?
20:39:52 <\rs> rwbarton: decode . BL.fromChunks . (:[]) . B.dropWhile (/=fromIntegral (ord '{'))) `liftM` liftIO (F.withFile jsonpath F.ReadMode B.hGetLine)
20:40:01 <\rs> rwbarton: sorry. ghc -e 'import Data.Text' -e 'import Data.ByteString' -e 'import Data.Text.Encoding' -e 'Data.ByteString.getLine >>= print . decodeUtf8' < json/7V2Ln
20:40:47 <\rs> rwbarton: this is the one-liner that works
20:40:49 <rwbarton> looks legit
20:42:32 <ion> λ> (Data.Aeson.decode . Data.Text.Lazy.Encoding.encodeUtf8 . Data.Text.Lazy.pack) "[\"ä\"]" :: Maybe [String]
20:42:34 <ion> Just ["\228"]
20:42:41 <ion> This seems to work at least.
20:48:20 <edwardk> these work reasonably well in scala, since i can make 4 type parameters that all can properly vary
20:48:42 <edwardk> they have some composition issues though
20:49:39 <kallisti> how do I open a named pipe in Haskell.
20:49:52 <kallisti> openFile is not doing the trick
20:50:20 <shachaf> @hoogle namedpipe
20:50:21 <lambdabot> System.Posix.Files namedPipeMode :: FileMode
20:50:21 <lambdabot> System.Posix.Files createNamedPipe :: FilePath -> FileMode -> IO ()
20:50:21 <lambdabot> System.Posix.Files isNamedPipe :: FileStatus -> Bool
20:51:53 <carter> edwardk: hey... I'm planning to do a pre pre alpha release of my dataframe work to hackage later this week,  when I do I'd really like your feedback / thoughts
20:52:09 <carter> "HasCol"
20:52:38 <edwardk> dataframe?
20:52:52 <carter> a la "pandas" or the thing they have in R
20:53:03 <carter> but using all the cleverness of haskell libs combined
20:53:08 <Goatflakes> @hoogle lalr
20:53:08 <lambdabot> No results found
20:53:11 <Goatflakes> :<
20:53:34 <carter> (its part of larger project of stuff i'm working on for a better data analysis toolkit)
20:53:53 <carter> if that makes any sense at all
20:54:42 <Goatflakes> o happy is the generalised parser framework for haskell derp
20:55:11 <Goatflakes> replace the with a
20:55:43 <carter> I've got some very very detailed plans for a better mathematical modelling / machine learning / data analysis toolkit
20:56:10 <edwardk> carter: ah
20:56:12 <carter> weaving together a bunch of ideas into one lib
20:56:28 <carter> edwardk: and the first step is getting a decent basic data frame together
20:56:39 <carter> so i can start working on the other bits
20:56:48 <carter> and I have some pre alpha stuff for that piece
20:57:05 <Goatflakes> well if yacc maps to happy then i'm guessing you use "do" or ">>=" to do the scanning?
20:57:22 <Goatflakes> soo lexx maps to >>=
20:57:29 <carter> that it totally untuned etc performance wise, but I think is a baby step for the right choice in api (modulo no engineering time spent on it overall as yet)
20:58:24 <Goatflakes> well to paraphrase knuth premature optimization is the cause of most problems in computer programming
20:58:36 <Goatflakes> a.k.a. not enough generality
20:59:08 <carter> Goatflakes: why not use parsec?
20:59:13 <Goatflakes> idk
20:59:26 <Goatflakes> i asked before no one answered ;)
20:59:31 <carter> about what?
21:00:08 <Goatflakes> i asked how one does a parser in haskell that isn't recursive descent they were like just use do i was like don't think that's going to work lol
21:00:35 <Goatflakes> thanks carter i will check it out
21:00:52 <kallisti> shachaf: none of those involving opening named pipes after creating them
21:00:57 <c_wraith> Goatflakes: I think you might be conflating how parser combinators are used with how the constructs they build work.
21:01:06 <carter> rwbarton: hello! (I don't think i've spoken to you since I was a prefrosh visiting random half a decade ago then foolishly chose a different school)
21:01:50 <edwardk> Goatflakes: if you want to avoid recursive descent your options are mostly happy and frisby
21:02:00 <Goatflakes> ta
21:02:16 <edwardk> Goatflakes: Philippa has some combinators for VPL languages and I have some unrelated GLL parsing combinators
21:02:17 <shachaf> kallisti: Oh, opening one.
21:02:22 <edwardk> er unreleased
21:02:26 <shachaf> kallisti: It *should* just be a regular open() call...
21:02:45 <ion> edwardk: The article looks interesting, but i’m so tired i’m unable to concentrate. I’ll have to play with the code in ghci in a bit less sleepy state. :-)
21:02:49 <Goatflakes> yeah i am sure do and >>= and all the other parsers written can only handle recursive descent parsers
21:03:04 <edwardk> ion: no problem. thanks for the eyeballs =)
21:03:04 <kallisti> shachaf: I'm getting "doesn't exist" errors
21:03:18 <shachaf> kallisti: I don't think this is a Haskell problem.
21:03:23 <Goatflakes> ^all the other parsers written in haskell as "example parsers"
21:03:24 <edwardk> Goatflakes: no, you can write applicative parser combinators that yield an LALR parser
21:03:25 <carter> edwardk I'll proof read too if you like
21:03:46 <Goatflakes> ah ok
21:03:53 <Goatflakes> how? o.o
21:04:03 <edwardk> Goatflakes: its not very commonly done because it requires observable sharing to recover the grammar
21:04:17 <Goatflakes> i don't know what that means
21:04:31 <kallisti> out/1: openFile: does not exist (No such device or address)
21:04:32 <edwardk> Goatflakes: basically it requires black magic to make work
21:04:36 <kallisti> shachaf: it's not
21:04:49 <kallisti> it's a "I don't understand named pipes" problem
21:05:00 <Goatflakes> so basically i have to do the whole make a stack and an FSM like writing a parser in any old language?
21:05:13 <edwardk> Goatflakes: what language are you parsing?
21:05:34 <geekosaur> the first open of a FIFO needs to be O_RDWR, or ReadWriteMode in Haskell; some Unixlike systems may permit read-only or read-write and block until the other side is opened, but Linux in particular will block non-O_RDWR opens forever if nothing else has it open
21:05:38 <edwardk> Goatflakes: most of the time the recursive descent model works beautifully in haskell, because its so nice to present the grammar that way
21:05:40 <Goatflakes> just want to know how to do it for now
21:05:49 <edwardk> the main limitations are multiple error reporting is less graceful than in LALR
21:05:56 <geekosaur> kallisti: ^^
21:06:17 <geekosaur> hm, maybe they changed it from block forever to that error
21:06:21 <edwardk> Goatflakes: have you seen a grammar expressed in parsec/trifecta?
21:06:48 <Goatflakes> no
21:06:52 <kallisti> geekosaur:             createNamedPipe path
21:06:53 <kallisti>               (ownerReadMode .|. ownerWriteMode .|. namedPipeMode)
21:06:54 <carter> edwardk: the article looks reasonable, though i'll have to mull it over to get facile with it
21:07:12 <Goatflakes> just lex and yacc, bnf that sort of thing
21:07:13 <edwardk> Goatflakes: https://github.com/DylanLukes/Winchester-STG-Compiler/blob/master/WSC/Parser.hs is a parser written with trifecta
21:07:15 <geekosaur> kallisti: "no such device or address" is kernel error speak for "I don't know what to do with your request" and on a FIFO probably means "no reader yet"
21:07:21 <Goatflakes> thanks ;)
21:07:22 <geekosaur> yes, those are filesystem modes
21:07:29 <shachaf> geekosaur: The behavior is different with O_NONBLOCK.
21:07:32 <geekosaur> what is the open getting?
21:07:32 <kallisti> geekosaur: oh, hm...
21:07:33 <edwardk> Goatflakes: thats more or less the way its often best written in haskell
21:07:39 <shachaf> Which GHC might be using, given the I/O manager and all.
21:07:42 <edwardk> carter: thanks
21:07:46 <kallisti> geekosaur: yeah there's not a reader yet. I thought I could keep a named pipe open without a reader
21:08:17 <carter> edwardk: i actually need to spend some time staring at lens', some of my thoughts for a better dataframe thing  are maybe in that direction
21:08:24 <geekosaur> it's been a while since I last traced the kernel code but Linux is generally strict about POSIX's insistence that the first open of a FIFO being O_RDWR / ReadWriteMode
21:08:52 <geekosaur> ENXDEV makes sense for the other open modes
21:09:05 <Goatflakes> WSC=window script component?
21:10:03 <edwardk> Goatflakes: no, its the 'winchester STG compiler'
21:10:10 <geekosaur> but "no such device or address" always means "I have nothing to connect this thing to", which for a FIFO would imply the initial RDWR open hasn't happened yet
21:10:18 <Goatflakes> isn't the usually idiom with pipes to open the read write then close whatever u don't need?
21:10:19 <edwardk> it was a dylan lukes 's highschool senior project or something
21:10:24 <Goatflakes> ok thanks
21:10:29 <edwardk> http://dylukes.blogspot.com/2011/10/parser-combinators-101.html is some more writing by him on how to use trifecta
21:10:41 <Goatflakes> thanks ed
21:11:01 <geekosaur> shachaf: used to be the Linux kernel code, in particular for O_NONBLOCK, explicitly blackholed initial opens that weren't O_RDWR
21:11:45 <edwardk> Goatflakes: there are also lots of good references on parsec on the internet
21:11:45 <geekosaur> sounds like they ditched that and went with ENXDEV, which makes more sense than creating dummy blackhole nodes that always return EAGAIN
21:11:55 <edwardk> Goatflakes: and almost all of that knowledge transfers to trifecta
21:12:03 <Goatflakes> thanks
21:12:36 <Goatflakes> gah need a post its program
21:12:42 <Goatflakes> what's the windows one?
21:12:53 <edwardk> (trifecta is basically parsec cleaned up, made more modern and friendlier to monad transformers and given a shiny coat of paint over the way it handles error messages and diagnostics)
21:13:21 <geekosaur> Goatflakes, with real pipes you always get both the read and write ends.  this is difficult to do with a FIFO, hence the mandatory O_RDWR initial open
21:13:25 <carter> edwardk: really? its a bit hard to tease out that punch line from the hackage docs!
21:13:39 <edwardk> carter: thats why i'm breaking out 'parsers' as a separate package
21:13:54 <edwardk> and moving most of the parser transformers into other packages
21:13:54 <carter> plus i must admit i was trying to find the monoidal parsing bit and i was a bit stumped
21:14:01 <carter> edwardk: makese sese
21:14:06 <carter> sense
21:14:11 <edwardk> carter: trifecta as it exists right now doesn't have any of my old monoidal parsing stuff in it
21:14:17 <carter> ok
21:14:22 <edwardk> its just a really nice set of parsers with good diagnostics
21:14:27 <carter> ok
21:14:35 <edwardk> i more or less just kept the name
21:14:52 <NemesisD> anyone know how to make cabal install dependencies for tests?
21:14:53 <edwardk> Delta is monoidal
21:14:59 <edwardk> but there isn't much else in there that is ;)
21:15:11 * Goatflakes blushes
21:15:18 <edwardk> NemesisD: cabal install --enable-tests doesn't do it?
21:15:40 <carter> edwardk: where's delta? my ctrl-f fu on hackage is weak
21:15:50 * Goatflakes when he realises that the sticky notes program for win7 is called sticky notes
21:16:00 <edwardk> https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Rope/Delta.hs
21:16:01 <MostAwesomeDude> Hm. Is there an integer exponentation operator? I only see the Real one.
21:16:04 <edwardk> its how i track file positions
21:16:09 <edwardk> :t (^)
21:16:11 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
21:16:14 <carter> edwardk: ahhh
21:16:14 <MostAwesomeDude> Aha.
21:16:20 <MostAwesomeDude> edwardk: TYVM.
21:16:21 <edwardk> :t (**)
21:16:23 <lambdabot> forall a. (Floating a) => a -> a -> a
21:16:26 <geekosaur> there are three
21:16:27 <edwardk> :t (^^)
21:16:28 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
21:16:49 <NemesisD> edwardk: well i don't want to install, only install dependencies so i can run tests
21:16:49 <edwardk> pick your poison ;)
21:17:17 <edwardk> NemesisD: not sure. i use surprisingly few cabal commands
21:17:25 <NemesisD> edwardk: ah, it looks like i could just do cabal-dev install --only-dependencies --enable-tests
21:17:32 <edwardk> there you go
21:17:53 <carter> edwardk: the context for my looking for it was/is  that I think there might be an interesting meta DSL for running data analysis computations / queries that has a sort fo monoidal/applicable/monadic pieces
21:18:06 <carter> so maybe reducers is a better thing to stare at
21:18:07 <edwardk> have you looked at multipass?
21:18:13 <carter> for the semigroup like stuff
21:18:17 <carter> hrm?
21:18:34 <carter> where's multipass?
21:18:43 <edwardk> carter: https://github.com/ekmett/multipass is my framework for doing multiple monoidal and l-estimator passes over arbitrary data sets
21:19:14 <carter> eeep, nope
21:19:53 <carter> edwardk: you have a LOT of libs on github :)
21:19:57 <edwardk> ghci> sequence [absdev median, stddev, sumSq, count, q3, q3 `by` HD] @! [1,2,3,4]    ==> [1.0,1.118033988749895,30.0,4.0,3.5,3.4570383309463026]
21:20:10 <carter> tricky to prophylactically look at them all
21:20:16 <carter> tthanks!
21:20:19 <carter> i'll take a look at it
21:20:57 <edwardk> that computes in 2 passes, the median absolute deviation, std deviation, sum of squares the count the third quartile using the standard quantile estimator and the harell-davis robust quantile estimate of the 3rd quartile
21:21:43 <edwardk> it takes two passes because median absolute deviation needs to compute order statistics to find the median, and then we need to run another pass over order statistics in a derived calculation from that
21:22:10 <edwardk> but in the first pass, it observes correctly that computing stddev needs count, sumSq and total and only computes those quantities once
21:22:19 <carter> edwardk: ok
21:22:20 <carter> cool
21:22:38 <carter> over what sort of data structure?
21:22:46 <edwardk> anything foldable
21:22:54 <carter> ok
21:22:55 <edwardk> so you can bake your parallelism into the folding structure
21:23:10 <edwardk> the order statistics don't get perfect parallelism right now though
21:23:13 <carter> by doing a binary tree of work splitting?
21:23:14 <carter> ok
21:23:20 <carter> cool
21:23:22 <edwardk> yeah, thats up to the container
21:23:26 <edwardk> i just provide the monoids
21:23:30 <carter> awesome
21:23:38 <Goatflakes> does ghci have lists with said parallelism baked in?
21:23:43 <edwardk> r-estimators are coming if and when i get a chance to get back  to it
21:23:58 <edwardk> Goatflakes: yes, we have 'data parallel haskell' which comes with all sorts of tools for nested data parallelism
21:24:19 <Goatflakes> :D
21:24:39 <Goatflakes> erm i meant ghc
21:24:40 <carter> R-estimators means?
21:24:51 <carter> i'm a little bit lopsided in my terminology set
21:25:07 <edwardk> familiar with spearman correlation coefficient vs. pearson correlation coefficient?
21:25:24 <carter> googling to remind myself
21:25:37 <edwardk> person is built off of the data, while spearman is built off of the 'ranks' within the data
21:25:54 <edwardk> replacing each number in the  dataset with its position in a sorted list of the data
21:26:03 <carter> ok
21:26:04 <edwardk> r-restimators are functions of the ranks of the data, not the data themselves
21:26:17 <edwardk> l-estimators are functions of the sorted data directly
21:26:40 <carter> ok
21:26:46 <carter> makes sense
21:26:46 <edwardk> median is just an l-estimator, which takes the (n/2)th element or combines the two nearest that
21:26:56 <edwardk> it doesn't care about the rest of the data
21:27:03 <carter> yup
21:27:04 <carter> :)
21:27:15 <edwardk> r-estimators and l-estimators are tools that arise in 'robust' statistics, because they are robust against outliers
21:27:17 <carter> i fully comprehend all of that and the implicity bits therein
21:27:38 <carter> :)
21:27:41 <carter> cool
21:27:44 <edwardk> so you can use things like interquartile mean are useful because they dump the highs and lows, they have higher breakdown than mean (which is the least robust statistic)
21:27:54 <edwardk> but worse breakdown than median (the most robust statistic)
21:28:11 <carter> cool
21:28:41 <edwardk> the harell davis quantile estimators i support in multipass are less robust but lower variance than the direct quantile calculation from the order statistic
21:29:01 <carter> ok
21:29:03 <edwardk> and i have lots of little goodies like that in there
21:29:11 <carter> what are some good references on that space of stats?
21:29:15 <edwardk> (along with the more traditional quantile estimators)
21:29:30 <carter> i've a stack of reading in the general area i'm working through
21:29:34 <carter> eg some boosting etc
21:29:39 <edwardk> good question. i hate most statistics. i like probability theory, and i love bayesian statistics
21:29:41 <carter> and current conference papers
21:29:45 <carter> ok
21:29:54 <carter> i'm sort of reading things from an ML perspective
21:29:55 <edwardk> well, my favorite book is gelman's
21:30:08 <edwardk> http://www.amazon.com/Bayesian-Analysis-Edition-Chapman-Statistical/dp/158488388X
21:30:14 <edwardk> its amazingly clear
21:30:19 <edwardk> and i love bayesian tools
21:30:59 <carter> edwardk: thanks! I'll be doing some book collecitng soon, i'll put that in the stack
21:31:12 <carter> so what i'm doing (and i've spoken / will speak with copumpkin further about it, along with some other folks)
21:31:12 <solrize> i thought statistics were icky until someone told me they were just observable probability distributions
21:31:13 <edwardk> a slower guide is degroot and schervish's probability and statistics. its less focused on pure bayesian techniques though
21:31:22 <edwardk> and it alternates between frequentist and bayesian tools
21:31:24 <carter> i'm a more theory more power
21:31:26 <carter> learner
21:32:42 <carter> is basically trying to do a better end to end tool chain
21:32:49 <carter> so theres less of the aggregious repeated work
21:33:09 <carter> people do in their computational experimentation and production deployments
21:33:19 <carter> and also have a tool that doesn't piss me off a ala all current ones
21:33:42 <edwardk> but for some of my favorite recent tricks you need to be comfortable with Riemann manifolds, because the Fisher information metric is actually a metric, so you can use the tensor for that metric space to do some neat automatic parameter tuning in Hamiltonian Monte Carlo based on where you are in parameter space.
21:33:51 <edwardk> and that isn't really a tool usually taught in statistics
21:34:03 <carter> paper links?
21:34:09 <edwardk> carter: for that?
21:34:20 <carter> that sort of clever parameter tuning
21:34:23 <edwardk> http://www.dcs.gla.ac.uk/inference/rmhmc/
21:34:23 <solrize> whaaa?
21:34:37 <carter> edwardk: thanks!
21:34:52 <edwardk> girolami and calderhead are the only folks really using it other than me right now
21:34:56 <solrize> wow that looks cool
21:35:14 <edwardk> there is a good talk by girolami online somewhere...
21:35:25 <carter> one of my concrete goals in the near term is have a tool chain thats par with VowPal Wabbit speed wise, but easier try new linear model / learning algs
21:35:54 <edwardk> http://research.microsoft.com/apps/video/default.aspx?id=150310
21:36:02 <edwardk> its probably a much easier introduction than the paper
21:36:09 <edwardk> and he's surprisingly easy to listen to
21:36:12 <carter> wheres the  paper?
21:36:15 <carter> though :)
21:36:19 <edwardk> that link above it
21:36:24 <edwardk> should have a pdf there somewhere
21:36:36 <edwardk> or google for riemann manifold hamiltonian monte carlo
21:36:55 <ion> Ooh, a talk video. Thanks.
21:36:57 <carter> http://onlinelibrary.wiley.com/store/10.1111/j.1467-9868.2010.00765.x/asset/j.1467-9868.2010.00765.x.pdf?v=1&t=h3v20wip&s=71a172472e073e1d975896dc16ebb8db0edbc06f
21:36:57 <edwardk> i was spending a lot of time working on that and no u-turn sampling a couple months ago
21:37:02 <carter> ah
21:37:06 <carter> i heard about no u-turn
21:37:30 <carter> am I linking to the right paper (happily not paywalled)
21:37:46 <edwardk> since no u-turn sampling gives you a smart way to set hamiltonian monte carlo simulation step counts, dual averaging lets you tune the step size, and the manifold lets you tune 'how hard you flick'
21:38:01 <kizzo> How do you resolve "ambiguous module name 'Graphics.UI.GLFW'" for the packages GLFW and GLFW-b ?
21:38:01 <edwardk> yep
21:38:06 <carter> cool
21:38:12 <carter> anywho
21:38:15 <carter> i want to hear more
21:38:23 <carter> but I also want to get some work done on this pre alpha code
21:38:25 <kizzo> http://hackage.haskell.org/package/GLFW-b-0.1.0.2
21:38:27 <carter> afore a crash! :)
21:38:28 <kizzo> http://hackage.haskell.org/package/GLFW
21:38:36 <ion> kizzo: ‘import "package" Module’ or ‘ghc-pkg hide package’ IIRC.
21:38:40 <carter> edwardk: thanks! and I want more pointers / links etc
21:38:42 <edwardk> check your /msgs ;)
21:38:42 <carter> later
21:40:14 <solrize> says it gives 3x-5x speedup over old fashioned methods
21:40:44 <solrize> so spend a few years boning up on differential geometry, or buy a faster computer... what to do, what to do.. ;)
21:41:58 <solrize> srsly it looks neat
21:42:39 <solrize> http://www.amazon.com/Causality-Reasoning-Inference-Judea-Pearl/dp/052189560X  this is supposed to be good
21:43:18 <kizzo> ion: That's setting me on track, thanks.
21:45:46 <ion> kizzo: Also, if you’re building with a cabal file, i think it should only look at the packages you have in dependencies.
21:47:45 <kizzo> ion: I tried that and it didn't work, but acknowledged though.
21:47:45 <YayMe> Anyone who would give me some criticism would be greatly appreciated: http://codereview.stackexchange.com/questions/13035/my-first-haskell-thingy
21:50:42 <solrize> ((-) artifactX $ artifactW / 2, (+) artifactY $ artifactH / 2)
21:50:46 <solrize> um why?
21:51:01 <edwardk> solrize: the main thing it wins is that you don't need to tune magic constants
21:51:18 <edwardk> solrize: i'm a big fan of tools i can just throw at a problem and which work without voodoo tuning
21:51:29 <solrize> hmm
21:51:46 <edwardk> solrize: http://www.johndcook.com/blog/2012/06/18/methods-that-get-used/
21:52:19 <solrize> edwardk, heh :)
22:03:49 <solrize> i didn't realize metropolis-hastings needed parameter tuning.  i've read about it but never used it
22:11:52 <edwardk> solrize: metropolis-hastings is pretty simple, the main 'parameter' is how to get your candidate distribution. hamiltonian metropolis hastings is a different beast. your candidate distribution is done by a physics simulation. thats harder to tune =)
22:17:58 <solrize> ic, yeah for high dimensions i can imagine having to deal with complicated methods
22:21:00 <edwardk> yeah
22:22:01 <edwardk> basically in hamiltonian monte carlo you replace the current sample with a 'frictionless puck' and then after taking the log and flipping the density function over, you 'flick' the puck with a certain amount of momentum, and run a simulation for a while
22:22:16 <edwardk> it will then skitter through valleys, oscillating side to side, etc. and wind up pretty far from where it stated
22:22:33 <edwardk> but usually downhill (uphill in the original) where it'll be accepted
22:22:50 <edwardk> so you get MUCH lower autocorrelation, and much greater independence from highly correlated dimensions
22:31:30 <tgeeky> perhaps when July 4th comes around, we'll see a nice little miracle of statistical analysis
22:31:57 <edwardk> ?
22:32:07 <tgeeky> edwardk: CERN Higgs announcement
22:32:51 <tgeeky> ( http://press.web.cern.ch/press/PressReleases/Releases2012/PR16.12E.html )
22:37:59 <solrize> the gelman book looks informative.  maybe if i get hold of it i'll have some more clue
22:38:27 <edwardk> gelman has a very good way of explaining bayesian reasoning
22:38:34 <edwardk> and provides a lot of good tools in there
22:39:12 <edwardk> im also somewhat biased because one of my buddies did a post doc there at columbia, so i have had a good resource to get questions answered ;)
22:39:29 <solrize> lol
22:40:53 <Catnaroek> I have the following identifiers: data Record = Record { field :: Type }, record :: Record, fieldRef = field. I would like to do something like updatedRecord = record { fieldRef = newValue }. Is there any way to do this?
22:41:25 <dmwit> Use lenses instead of record update syntax.
22:41:41 <Catnaroek> Oh, what are lenses?
22:41:57 <edwardk> Catnaroek: i have two writeups that may help
22:42:02 <dmwit> search for "lens [haskell]" on StackOverflow =)
22:42:04 <shachaf> @google stackoverflow kmett lenses
22:42:06 <lambdabot> http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
22:42:06 <lambdabot> Title: haskell - lenses, fclabels, data-accessor - which library for structure access a ...
22:42:08 <edwardk> http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285
22:42:22 <edwardk> and my shiny new http://comonad.com/reader/2012/mirrored-lenses/
22:42:43 <Catnaroek> :O
22:42:48 <edwardk> dmwit: i welcome feed back on the mirrored lenses article
22:42:53 <dmwit> oh dang
22:42:58 <dmwit> I'll take a look.
22:43:00 <dmwit> =)
22:43:24 <dmwit> Catnaroek: twanvl also has an excellent introduction, by the way:
22:43:32 <dmwit> ?google twan van laarhoven functional references
22:43:34 <lambdabot> http://twanvl.nl/blog/
22:43:35 <lambdabot> Title: Twan van Laarhoven's blog
22:43:38 <dmwit> hm
22:43:43 <dmwit> Well, it is on his blog. =P
22:43:46 <Catnaroek> :)
22:44:02 <Catnaroek> Thank you two, dmwit and edwardk.
22:44:02 <edwardk> the new ones are generalized van laarhoven lenses
22:44:21 <Catnaroek> Are those different?
22:44:57 <edwardk> Catnaroek: the ideas hold across all lens styles
22:45:06 <edwardk> Catnaroek: there are just several ways to code them up
22:45:16 <edwardk> i need to update my stackoverflow response to include van laarhoven lenses
23:03:31 <solrize> it took a while for me to understand the first example
23:03:44 <solrize> could you add a link to basics of lenses?
23:04:37 <crdueck> @src groupBy
23:04:38 <lambdabot> groupBy _  []       =  []
23:04:38 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
23:04:38 <lambdabot>     where (ys,zs) = span (eq x) xs
23:04:48 <pharaun> hello this is probably a dumb question but how do i move the IO from inside a tuple to the outside?
23:05:08 <mauke> pharaun: what's the exact type?
23:05:13 <pharaun> a moment
23:05:46 <hpaste> pharaun pasted “io monad” at http://hpaste.org/70415
23:06:09 <pharaun> mauke: ^ relevant chunk of the code The current type is - readMounts :: IO [(DevName, Path, IO [Integer])]
23:06:18 <mauke> ok, readMounts clearly has the wrong type for what you want
23:06:22 <pharaun> I want to move that IO [Integer] to just [Integer]
23:06:28 <pharaun> mauke: yes because its what compile right now
23:06:46 <pharaun> i want to make the type simpler to just be an IO then list of blah
23:07:44 <solrize> > let f (devname, path, xs) = do { ys <- xs; return (devname, path, ys) }
23:07:45 <lambdabot>   not an expression: `let f (devname, path, xs) = do { ys <- xs; return (devn...
23:07:56 <solrize> something like that
23:08:02 <pharaun> solrize: oh hmm
23:08:06 <pharaun> k i'll try that
23:08:26 <solrize> > f (devname, path, xs) = do { ys <- xs; return (devname, path, ys) }
23:08:27 <lambdabot>   <no location info>: parse error on input `='
23:08:28 <hpaste> mauke annotated “io monad” with “io monad (annotation)” at http://hpaste.org/70415#a70416
23:08:31 <mauke> pharaun: ^
23:09:21 <pharaun> mauke: solrize ahh i see that's the missing bit, i was just not for sure how to do the <- then i was like doh mapM
23:12:50 <pharaun> mauke: perfect thanks :)
23:13:29 <mauke> also see the hlint comments
23:13:50 <pharaun> yeah i need to start running hlint on my stuff
23:17:23 <pharaun> mauke: got any other general style recommendation, i'm still new at this
23:18:24 <mauke> oh, now I have to actually read the code
23:18:39 <pharaun> hah don't have to if you don't want to :) i was just wondering :S
23:19:00 <mauke> are those bytestrings lazy or strict?
23:19:07 * hackagebot leksah 0.12.1.3 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.12.1.3 (HamishMackenzie)
23:19:26 <pharaun> mauke: Strict, this is for a yesod app
23:19:50 <Kaidelong> is there any difference between a "tensor product" and a cartesian product
23:19:53 <mauke> pharaun: mounts <- B.readFile "/proc/mounts"
23:20:29 <pharaun> mauke: actually i think that's what i used to have in the first place
23:20:46 <pharaun> but since /proc is special file it returns 0 or some on fs size and makes readFile choke
23:20:52 <pharaun> let me find a ref on that
23:20:52 <mauke> ah
23:21:39 <mauke> that sounds like a bug in either /proc/mounts or bytestring
23:21:41 <pharaun> http://stackoverflow.com/questions/10184202/haskell-reading-from-proc-issues-with-strictness-and-laziness-process-statis
23:21:56 <pharaun> ie lazy works, strict does not
23:22:26 <pharaun> but from my understanding i should use strict so that i can open then close file asap to help with file limits with yesod
23:22:50 <mauke> yeah, definitely a bug in bytestring
23:23:54 <pharaun> i can try to file a bug report on that?
23:23:59 <Kaidelong> well what's the haskell equivalent of perl ``?
23:24:05 <otters> it doesn't have that
23:24:12 <otters> not really
23:24:22 <Kaidelong> no system calls?
23:24:23 <mauke> pharaun: that would be good
23:24:25 <Kaidelong> that's hard to believe
23:24:29 <pharaun> mauke: k i'll go ahead then
23:24:40 <otters> Kaidelong: I meant there's no notation fo rit
23:24:42 <otters> for it
23:24:47 <mauke> pharaun: because as it is, it can't read from fifos or other interesting files
23:25:00 <pharaun> oh ouch didn't think of that
23:25:01 <Kaidelong> well
23:25:01 <Axman6> Kaidelong: it would help if you explained what `` is
23:25:06 <otters> exec
23:25:06 <geekosaur> `` is not the ideal way to do them even in perl, it's a special kind of string quote just as it is in the shell.  see System.Cmd for the ways to invoke external programs
23:25:07 <Kaidelong> if he can invoke a paginator
23:25:19 <Kaidelong> and then read the output from the paginator
23:25:24 <Kaidelong> that would work around this problem
23:25:29 <Axman6> there's several ways to do that
23:25:49 <Kaidelong> err, catenator actually would be more appropriate now that I think of it
23:25:50 <Axman6> @hoogle String -> [String] -> IO (Handle, Handle, Handle)
23:25:51 <lambdabot> No results found
23:26:01 <Axman6> @hoogle IO (Handle, Handle, Handle)
23:26:01 <lambdabot> No results found
23:26:04 <Axman6> bleh
23:26:19 <geekosaur> lots of people abuse them in place of "system", which is wrong and wasteful (allocates an extra pipe and memory for output that you probably don't care about)
23:26:41 <Kaidelong> geekosaur: in this case the output is exactly what you're after
23:26:58 <Axman6> @hoogle IO (Handle, Handle)
23:26:59 <lambdabot> Control.Monad.Trans.Writer.Lazy runWriterT :: WriterT w m a -> m (a, w)
23:26:59 <lambdabot> Control.Monad.Trans.Writer.Strict runWriterT :: WriterT w m a -> m (a, w)
23:26:59 <lambdabot> Control.Monad.Writer.Lazy runWriterT :: WriterT w a -> m (a, w)
23:27:04 <Axman6> :\
23:27:07 <alpounet> hah
23:27:14 <geekosaur> ok, what you want is System.Process, then
23:27:17 <mauke> Kaidelong: what are you trying to do?
23:27:42 <geekosaur> @hoogle IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
23:27:43 <lambdabot> System.Process createProcess :: CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
23:27:54 <Kaidelong> `cat /proc/pid/stat`
23:28:09 <mauke> wat
23:28:12 <geekosaur> ...this is probably not the way to go, there are easier ways
23:28:20 <Axman6> why would you use cat? you know haskell has functions to read from files right?
23:28:25 <pharaun> Kaidelong: http://stackoverflow.com/questions/10184202/haskell-reading-from-proc-issues-with-strictness-and-laziness-process-statis
23:28:25 <Kaidelong> but
23:28:26 <Axman6> like readFile...
23:28:30 <Axman6> :t readFile
23:28:31 <lambdabot> FilePath -> IO String
23:28:31 <pharaun> this example has readFile
23:28:31 <Kaidelong> he was cmplaining about it being broken
23:28:42 <pharaun> Kaidelong: there is workaround right now, i am filing a bug now
23:28:45 <geekosaur> Axman6, scrollback indicates readFile is broken with the proc interface
23:28:49 <mauke> Kaidelong: what makes you think reading from pipes would work better?
23:29:01 <geekosaur> pipes don't have sizes
23:29:12 <pharaun> geekosaur: but you have a workaround which i'm using right now, it works
23:29:13 <geekosaur> it *does* make sense to me given the readFile issue
23:29:18 <mauke> geekosaur: strict BS.readFile is broken with anything but "normal" files
23:29:49 <pharaun> btw mauke http://hackage.haskell.org/trac/ghc/wiki/ReportABug right place to report it? that seems to be biased to GHC only?
23:29:53 <geekosaur> ...then explain that to the person who you have been confusing on the issue according to scrollback
23:30:17 <mauke> geekosaur: ... you?
23:30:24 <geekosaur> (and where I found said confusion, which oddly enough points directly not to your workaround, whatever it is, but to what e is using_
23:30:40 <geekosaur> oh ffs.  you've been BSing Kaidelong for the past how long now?
23:30:53 <geekosaur> and it took me jumping in so you could BS at me instead?
23:30:54 <mauke> what the fuck
23:31:07 <geekosaur> read scrollback.  like, y'know, I did
23:31:11 <mauke> I didn't realize Kaidelong was talking about pharaun's problem
23:31:23 <mauke> I just saw "how do I `` in Haskell?"
23:31:32 <geekosaur> possibly isn't, but it sure looks like either they are or they understood themselves to be the target
23:31:45 <mauke> which I didn't connect to the issue at and because pharaun already had a better solution when they came in and because `` wouldn't solve the problem
23:32:04 <mauke> er, *at hand
23:32:14 <geekosaur> because their discussion clearly is related to (see /proc) that one
23:32:42 <mauke> <mauke> yeah, definitely a bug in bytestring  <mauke> pharaun: because as it is, it can't read from fifos or other interesting files
23:32:58 <mauke> and I did mention the "can't read from pipes either" issue before
23:33:41 <mauke> pharaun: according to http://hackage.haskell.org/package/bytestring you should email dons00@gmail.com, duncan@community.haskell.org
23:34:23 <pharaun> mauke: oh ok i'll do that then, sorry a little new to the whole ecosys
23:34:50 <mauke> yeah, it's still a bit rough in places
23:36:35 <geekosaur> Kaidelong, did you follow enough of that to see you don't need a pipe to read it?  (nor do you in Perl for that matter:  open(my $fh, '<', "/proc/$pid/stat"))
23:38:16 <mauke> and File::Slurp::read_file doesn't have this bug
23:39:42 <Goatflakes> kallisti: did you get opening your FIFO to work?
23:39:43 <geekosaur> (and I really wish the linux devs had done the right thing and made those special /proc files cdevs instead of broken "ordinary files")
23:40:17 <solrize> that's pretty weird that strict bytestring stats the file before reading, instead of just reading til eof
23:40:20 <Goatflakes> geekosaur: yeah i always thought that would end in tears
23:40:49 <geekosaur> solrize, string preallocation
23:40:51 <pharaun> geekosaur: cdevs?
23:40:55 <pharaun> char dev?
23:40:57 <Goatflakes> character devices
23:40:59 <pharaun> oh k
23:41:04 <geekosaur> it's strict, it makes sense that it would preallocate the string it's reading the file into
23:41:11 <geekosaur> yeh, character devices
23:41:34 <solrize> chunks ;)
23:41:38 <mauke> sure, but it should handle files that don't have a size beforehand
23:41:46 <mauke> and don't trust 0 from stat
23:41:51 <pharaun> i would probably be "ok" with lazy but i want to be able to open/close the file asap cuz yeah
23:41:55 <geekosaur> ...on linux that should probably just be devices; block devices don't really exist (and aren't really needed)
23:42:23 <kallisti> Goatflakes: yep. just needed to up in ReadWriteMode
23:43:05 <geekosaur> funny, I was thinking that the 0-size not-really-files were a similar kernel thinko to the old named pipe blackholing behavior...
