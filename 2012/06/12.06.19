00:00:23 <sopvop> oh, I get it.
00:00:48 <edwardk> so yes, i keep steering you to generic programming, but that is because the java reflection machinery has no role in haskell, the only 'reflection' we offer is through Typeable  which is a class that will tell you the type of something (that falls under java's reflection purview)
00:01:06 <hpaste> Sam pasted “Exercise” at http://hpaste.org/70156
00:01:16 <dmwit> programm1r: What you have done (defining a new type) looks fine to me.
00:01:16 <edwardk> but the field/method access parts of reflection fall under generic programming through Data.Data/SYB or GHC.Generics or RepLib or one of the other random generic programming frameworks out there
00:01:31 <mauke> Sam___: same problem as before
00:01:38 <edwardk> this is why i keep trying to split hairs on terminology
00:01:54 <yulys> hmm, thanks anyway!
00:02:06 <edwardk> half of what you think of as reflection falls under our generic programming frameworks
00:02:12 <mzero> and, yulys, what you think of as generic programming - coding an algo. generically
00:02:19 <yulys> I will fail my course hehe
00:02:42 <mzero> is in Haskell, just run-of-the-mill parametric polymorphism
00:02:55 <Cale> yulys: hmm, what are you trying to do?
00:02:59 <programm1r> I need a data type that would provide an interface for working with binary data for the other (my data types).
00:03:17 <mzero> yulys: look at this slide http://www.ozonehouse.com/mark/haskell-amuse-bouche/slides.html#(36)
00:03:19 <mzero> and the next three
00:03:24 <yulys> okis
00:03:24 <edwardk> well, i don't know what to say, i gave you the actual answer in there. you are free to try to understand it or not
00:03:28 <MrFenix> hi.. does anyone know about cabal-test-quickcheck?
00:03:31 <MrFenix> http://hackage.haskell.org/packages/archive/Cabal/1.14.0/doc/html/Distribution-TestSuite.html
00:03:35 <mzero> that is how generic programming, as understood by "generics" in Java
00:03:37 <mzero> is done in Haskell
00:03:38 <Cale> programm1r: ByteString along with one of the serialisation libraries like cereal or binary?
00:04:15 <mzero> that isn't, BTW, what is called "generics" in Haskell - "generics" in Haskell are something much more powerful
00:04:17 <MrFenix> states that, there exists a package, that includes Cabal.TestSuite.Test instances for quickCheck
00:04:47 <yulys> ohhh mzero??? I mailed you before!!! xD ... I saw your video!
00:05:00 <programm1r> Cale: How to describe it?
00:05:01 <mzero> oh!
00:05:25 <mzero> well, yes, I'm that mzero
00:05:35 <programm1r> Cale:  Although the scheme is to ...
00:06:04 <yulys> thousand of sorries,.. have no idea who are taking to :( I apologized ... you are an important.. .I will read more u.u
00:06:25 <mzero> hah - no appologies needed
00:07:10 <blackdog> mzero: perhaps we need an #important-people-of-haskell channel :P
00:07:19 <edwardk> hah
00:07:28 * edwardk knights mzero lord of the realm
00:07:40 <dmwit> Sam___: compare:
00:08:09 <dmwit> > let foo [x:xs] = x; foo' (x:xs) = x in (foo [[1,2]], foo' [[1,2]])
00:08:10 <lambdabot>   (1,[1,2])
00:08:30 <mzero> lord of the MonadPlus, please
00:08:47 <Cale> Oh, you did a Google Tech Talk
00:09:02 <mzero> yes
00:09:04 <yulys> yes
00:09:07 <mzero> (I'm a googler)
00:09:11 <MrFenix> listify (mkQ (isImportant)) #haskell
00:09:22 <MrFenix> to start with generic programming ;)
00:10:26 <MrFenix> that ist mkQ False isImportant of course..
00:10:27 <dmwit> Your website claims you're a LindenLabber
00:10:46 <mauke> lindenlabrador
00:10:53 <mzero> was - it's out of date
00:11:03 <MostAwesomeDude> I'm slightly jelly.
00:19:38 <yulys> guys, there is nothing in the Web page: https://github.com/mtnviewmark/haskell-amuse-bouche
00:19:57 <edwardk> haskell doesn't amuse bouche apparently
00:20:01 <Taneb> Can someone give me an Alternative with explicit some and many?
00:20:11 <yulys> hmmm
00:20:12 <mzero> https://github.com/mzero/haskell-amuse-bouche
00:20:14 <mzero> it moved
00:20:36 <yulys> thanks Mister
00:21:00 <mzero> where did you find that link? I thought I fix all of 'em
00:21:29 <mzero> d'oh! the slide deck itself
00:22:21 <MostAwesomeDude> Man, it's too bad Haskore isn't a useful thing.
00:23:08 <kallisti> indeed
00:23:10 <yulys> mzero: slide 6 http://www.ozonehouse.com/mark/haskell-amuse-bouche/slides.html#(6)
00:23:26 <mzero> I see - thanks I'll fix it tomorrow when I'm more awake
00:23:28 <mzero> and on that note
00:23:30 <mzero> night all
00:23:31 <kallisti> MostAwesomeDude: there's a lot of potential for Haskell and computer synthesis/composition but not a lot of good software at the moment.
00:23:40 <yulys> Thank so much!
00:24:15 <yulys> mzero, ski and edwardk.. now I can do something with your help... a big hug,,,, bye
00:24:56 <MostAwesomeDude> kallisti: I am giving a talk at OSB about things I wrote, and one of the big reasons I went with Python for one project is that Haskell's library offerings weren't sufficient for my needs.
00:25:29 <MostAwesomeDude> Admittedly, it's also that some libraries are difficult to grasp or opaque and hard to customize.
00:30:28 <yitz> MostAwesomeDude: what were you missing? any specific examples?
00:33:21 <ketil> Hi.  Anybody know if Data.Vector.Unboxed Bool stores the values packed - i.e. one bit per Bool?
00:34:11 <sopvop> dmwit: ap and liftm work nicely, thanks a lot.
00:34:52 <yitz> ketil: if the type is actually spelled that way, it's hard to imagine how it could be packed
00:35:06 <dmwit> ketil: Well, UArray does, and I can't imagine Vector doing anything worse than UArray. =)
00:35:59 <MostAwesomeDude> yitz: The three libraries, specifically, are trifecta, haskore, and uniplate.
00:36:05 <dmwit> yitz: by the power of type classes =)
00:36:06 <yitz> dmwit: how could t Bool, for any t, be packed? Bool itself is not packed.
00:36:19 <MostAwesomeDude> trifecta ended up being a really great library, but the lack of docs slowed me down quite a bit.
00:36:24 <dmwit> Achievement GET: answer a question before it's asked!
00:36:32 <edwardk> trifecta is very much a work in progress
00:36:41 <MostAwesomeDude> haskore just hasn't been a thing for a while, and as a result, it's crufted over to the point where I had to just ignore it.
00:36:46 <edwardk> hence the lack of documentation
00:36:48 <MostAwesomeDude> edwardk: And I'm very grateful for it!
00:37:30 <MostAwesomeDude> uniplate doesn't expose very much control over how ASTs are handled; I had really strict requirements for ordering and semantics and uniplate just didn't care about that at all.
00:37:53 <MostAwesomeDude> It was at that point that I realized that, if I was gonna get this thing done on time, I'd have to go back to my Get Shit Done language of choice.
00:38:11 <MostAwesomeDude> I still wanna do it in Haskell someday, but not before I demo it next week.
00:43:18 * hackagebot test-shouldbe 0.2.1 - Catchy combinators for HUnit  http://hackage.haskell.org/package/test-shouldbe-0.2.1 (SimonHengel)
00:49:01 <shirt> why doesn't haddock indicate the deprecated status of functions?
00:53:39 <c_wraith> It's probably just never been implemented
00:54:21 <mysticc> I just read "List Leads Off with the Letter λ" article from TMR 17 .. Is there any performance issues with this approach of lists as compared to the original implementation ?
00:55:55 <Taneb> The change from Haskell 98 to Haskell 2010...
00:56:16 <Taneb> Is there a date for when the next change of that level will be?
00:57:07 <c_wraith> Probably sooner. Probably not 2012 - too late for that now.
00:57:30 <Taneb> So, I won't deed to wait until 2022
00:58:02 <dmwit> mysticc: Remind us: what's this approach to lists?
00:58:13 <dmwit> mysticc: Is it the DList approach (e.g. type DList = [a] -> [a])?
00:58:21 <mysticc> dmwit, Yeah
01:00:08 <dmwit> mysticc: The hidden cost of DLists is that the spine is constantly being recomputed. So it's best for ephemeral use only.
01:00:53 <dmwit> If you use intermediate versions of a DList you're probably better of with a normal list or a Sequence.
01:02:44 <gaoyc> i don't konw
01:07:46 <frerich> Hm, this talk about DLists reminds me of a question which recently came to my mind. Is there a name for this idiom of rewriting 'f a (f b (c))' as '(f a) . (f b) $ c'?
01:08:36 <frerich> 'Delaying' the evaluation even further by composing applications of 'f' instead of applying 'f' straight away.
01:09:28 <shachaf> "'Delaying' the evaluation even further"?
01:09:38 <mauke> I don't see the delay but I'd call it flattening
01:09:51 <mauke> because the goal is to get rid of )))
01:09:54 <frerich> I know delay is not the right word, hence I put it in quotes. :-)
01:14:07 <frerich> mauke: Hm, I think 'flattening' is not bad. Is there a more formal description of the use case (other than "get rid of )))" ;-)) for this? Like, something which generalizes the 'Appending to a DList is much cheaper than to a plain list'? Maybe something like "If you have a binary function and you'd like to avoid evaluating the left hand side argument, then consider flattening" or so.
01:14:50 * frerich decides to call this style "flattening" from now on
01:14:51 <mm_freak> i'd just call it function composition
01:15:09 <mm_freak> you have two functions (f a and f b) and compose them
01:15:47 <mauke> I don't think about this in terms of evaluation at all
01:16:34 <mauke> it's a purely syntactic maneuver
01:25:54 <dmwit> frerich: The magic in the DList version is changing from a ++ (b ++ c) to (a ++ b) ++ c.
01:27:23 <dmwit> err
01:27:31 <dmwit> the other way, I mean
01:31:18 <kilon> hey there i am a begineer with haskell and wanted to ask besides this -> http://learnyouahaskell.com/ what else would you recomend to a python dev like me :)
01:34:01 <ciaranm> kilon: lyah and rwh in parallel
01:34:17 <kilon> rwh ?
01:34:29 <ciaranm> @where rwh
01:34:29 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:35:16 <womb_> Hi!
01:35:55 <theadmin> womb_: Hi.
01:36:55 <womb_> recently i was playing with some stuff. It was HandsomeSoup, nice but i don't think i got correctly this IO Arrow
01:36:56 <hpaste> “Dmitry Tyurnikov” pasted “Stars (FPFP)” at http://hpaste.org/70158
01:37:16 <kilon> thank you ciaranm
01:38:13 <theadmin> How would I type-sign a function which takes a string and then passes it to system (which is defined in System.Cmd)? String -> IO ExitCode doesn't work somehow.
01:38:47 <ciaranm> "doesn't work"?
01:39:35 <theadmin> ciaranm: Not in scope: type constructor or class `ExitCode'
01:44:01 <koala_man> theadmin: import System.Exit
01:44:57 <theadmin> koala_man: Thanks.
01:45:00 <kilon> is haskell written in haskell ?
01:45:33 <theadmin> kilon: "Haskell" is not written in anything, it's a language standard -_- You should more of ask "Is GHC written in Haskell?" or something, I suppose.
01:45:46 <kilon> good point
01:45:56 <shachaf> Haskell is written in English.
01:46:09 <kilon> so is GHC written in haskell ?
01:47:02 <shachaf> @google is ghc written in haskell ?
01:47:04 <lambdabot> http://www.haskell.org/haskellwiki/Implementations
01:47:04 <lambdabot> Title: Implementations - HaskellWiki
01:48:21 * hackagebot hspec 1.1.3 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.1.3 (SimonHengel)
01:48:44 <kilon> thanks , i guess google is my friend afterall :D
01:49:42 <Taneb> How does one put Haskell' into the possessive?
01:49:48 <Taneb> "Haskell''s"?
01:50:10 <theadmin> Taneb: Guess so, or "of Haskell"
01:50:35 <Taneb> Haskell' here being Haskell Prime
01:50:49 <Taneb> I suppose I could find the actual prime symbol
01:51:36 <Taneb> I like Haskell′'s description of Incoherent Instances
01:51:46 <Taneb> http://hackage.haskell.org/trac/haskell-prime/wiki/IncoherentInstances
01:52:52 <theadmin> LOL
01:53:10 <theadmin> I wonder if that's some sort of a joke... "Pros: Pro, Pro", "Cons: Con, Con"... Like, really?
01:54:37 <bitonic> theadmin: IncoherentInstances are BAD. that's all you need to know.
01:54:41 <theadmin> Well that's a good find, gave me a laugh
01:54:53 <theadmin> bitonic: I'm not even sure what an "Incoherent" instance is.
01:54:58 <bitonic> It's clearly unfinished
01:55:24 <bitonic> theadmin: check the GHC manual
01:55:40 <theadmin> bitonic: That being the manpage or something else?
01:55:59 <bitonic> theadmin: that being this: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap
01:56:10 <theadmin> Oh.
01:56:27 <kilon> whats the best windows Haskell implementation ?
01:56:38 <bitonic> kilon: GHC
01:56:44 <kilon> GHC does not seem to be directly available for windows, only throygh wine
01:56:52 <bitonic> kilon: that's...
01:56:54 <bitonic> not true
01:56:58 <kilon> *through
01:57:08 <bitonic> kilon: where did you read that?
01:57:26 <bitonic> @where platform -- find the windows icon
01:57:27 <lambdabot> http://hackage.haskell.org/platform/
01:57:29 <mikeplus64> kilon: get GHC via the Haskell platform
01:57:53 <kilon> ok my bad seems i was clicking the wrong link
01:58:25 <bitonic> kilon: yeah but where did you read about GHC on wine? that sounds fun.
01:58:28 <kilon> i was clicking "Distribution packages" in download section of GHC
01:58:46 <theadmin> bitonic: I tried doing that (installed Haskell Platform under wine), it was working surprisingly fine
01:59:07 <kilon> bitonic: http://www.haskell.org/haskellwiki/GHC_under_WINE
01:59:11 <bitonic> theadmin: you were able to produce executables?
01:59:22 <bitonic> ahah. ok.
01:59:29 <theadmin> bitonic: The only thing I really played around with is GHCi. Well... I'll check that now xD
01:59:39 <bitonic> theadmin: apparently you can
02:00:02 <bitonic> kilon: also, wine is to run windows executables on linux, not the other way around
02:00:06 <theadmin> bitonic: Ah, I see.
02:01:28 <kilon> yeah it looked weird to me too
02:02:02 <kilon> expect a lot more weird questions coming from me in the future :D
02:02:33 <bitonic> ok, we're ready
02:03:06 <kilon> apperntly it was not windows but MinGW
02:03:14 <kilon> which kinda makes sense now
02:03:55 <kilon> sorry about that one
02:09:49 <Peaker> applicative, heh, just saw your message now
02:10:06 <Peaker> applicative, yeah, the UI is very rough yet, we're working on the fundamentals, so not polishing the UI
02:13:16 <mcstar> @djinn [a] -> a
02:13:16 <lambdabot> Error: Undefined type []
02:14:24 <mcstar> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
02:14:24 <lambdabot> Error: Undefined type Cont
02:16:26 <Peaker> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
02:16:27 <lambdabot> f a b = a (\ c _ -> b c) b
02:16:56 <mcstar> i see
02:17:06 <Peaker> it ignores the (a->r) there
02:17:10 <Taneb> @djinn f (f a -> b) -> b
02:17:11 <lambdabot> -- f cannot be realized.
02:20:20 <auastro> pl \x y -> x y
02:20:27 <dmwit> ($)
02:20:36 <auastro> @pl \x y -> x y
02:20:37 <lambdabot> id
02:20:54 <mcstar> dmwit: you need money?
02:21:14 <theadmin> @src ($)
02:21:15 <lambdabot> f $ x = f x
02:21:34 <auastro> @pl q f g x = f x . g
02:21:35 <lambdabot> q = flip . ((.) .)
02:24:03 <auastro> @pl q f g x = f x (g x)
02:24:04 <lambdabot> q = ap
02:25:25 <mcstar> > (*2) `id` 2
02:25:27 <lambdabot>   4
02:25:30 <mcstar> nice
02:25:57 <mcstar> whats the precedence of infix ops. made from prefix?
02:26:44 <Peaker> it can be specified, but is infixl 9 by default
02:27:28 <mcstar> just the opposite of $
02:44:52 <hpaste> edwardk pasted “broken pi” at http://hpaste.org/70159
02:47:24 <mcstar> > let f x = x in (f 1, f "a")
02:47:26 <lambdabot>   (1,"a")
02:47:35 <mcstar> i think im hallucinating
02:47:47 <Taneb> @src id
02:47:48 <mcstar> did this ^^ work in the past?
02:47:48 <lambdabot> id x = x
02:47:51 <Taneb> Yes
02:48:13 <mcstar> i remember something like, f got specialized in its type
02:48:28 <mcstar> so you couldnt use the same f with two different types
02:48:49 <mcstar> except, when you declared its type explicitely to be polymorphic
02:49:21 <dmwit13> > let g f = (f 1, f "a") in g id -- perhaps you're thinking of this broken code
02:49:22 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
02:49:22 <lambdabot>    arising from the literal ...
02:49:49 <mcstar> perhaps
02:49:50 <dmwit13> > let g :: (forall a. a -> a) -> (Int, String); g f = (f 1, f "a") in g id
02:49:51 <lambdabot>   (1,"a")
02:50:08 <mcstar> dmwit13: yeah, thanks that must have been it
02:50:20 <t7> system f!
02:51:16 <t7> > let f (x :: forall a. a -> a) -> (x 1, x "hi") in f id
02:51:18 <lambdabot>   <no location info>: parse error on input `->'
02:51:24 <t7> > let f (x :: forall a. a -> a) = (x 1, x "hi") in f id
02:51:26 <lambdabot>   (1,"hi")
02:51:31 <mcstar> ah i remember, it was definitely this
02:57:33 <mcstar> ah, system f
03:04:09 <mcstar> did anyone watch ERic Meijer's haskell lectures from channel 9?
03:12:52 <kilon> how easy to do live coding with Haskell ?
03:14:44 <Taneb> Easier than dead coding :P
03:15:34 <Taneb> Actually, I don't know if it's possible
03:15:43 <kilon> dead do no code :D
03:16:30 <kilon> actually i was wondering if haskell has a debugger similar to CL where it pops up with an error and allows you to dynamically change your source or even live object and just continuee execution
03:17:34 <mcstar> you mean interactive coding? or does live coding specifically mean the way CL works?
03:17:49 <Taneb> Coding during execution, I believe
03:17:55 <kilon> live coding mean to code a programm while it runs
03:18:00 <mcstar> k
03:19:32 <kilon> I assume it cant because so far I see its compiled to machine code
03:19:56 <mcstar> cl is compiled to machine code
03:20:06 <mcstar> at least in sbcl all the time
03:20:47 <fmap> how can you ensure type safety with "live coding"?
03:22:20 <kilon> i see
03:22:34 <mcstar> i think that was a constructive question
03:22:45 <mcstar> not a 'no you cant do it'
03:22:49 <Taneb> Can't you use that new magic thingy that the new version of GHC has?
03:23:14 <Taneb> And if something goes wrong...
03:23:21 <Taneb> You get egg on your face
03:23:25 <Taneb> Metaphorically
03:23:35 <Taneb> And literally if you set it up as such
03:23:43 <bitonic> Taneb: you mean the deferred type checking?
03:23:46 <Taneb> Yeah
03:24:07 <bitonic> I think you could even do better than that, if you carry on types at runtime
03:24:18 <bitonic> you could have a debug mode that does that, I suppose
03:25:05 <Taneb> What do you mean by that?
03:25:12 <kilon> i am not so sure that live coding affects type safety
03:25:35 <Taneb> kilon, it allows the opportunity to get things wrong
03:25:40 <kilon> it does
03:25:46 <bitonic> Taneb: what do I mean by what?
03:25:54 <Taneb> Carrying on types at runtime
03:26:15 <bitonic> Taneb: what part is not clear?
03:26:17 <kilon> you can certainly mess up your code if you are not careful, but not having to recompile with each minor error is a blessing
03:26:30 <kilon> and no need to restart the application
03:26:31 <mcstar> bitonic: like a symbolic differentiation example by oleg?
03:26:33 <Taneb> bitonic, the sense of carry, for a start
03:26:55 <mcstar> a -> the
03:27:26 <bitonic> Taneb: ok, types currently are erased when haskell code is run, since you know that things can't go wrong - at the type level.
03:27:38 <Taneb> Ah, I see
03:27:48 <bitonic> so if you pause the execution or whatever, you don't have an environment with typed values
03:27:52 <kilon> whats your favorite IDE / code editor for haskell ?
03:27:56 <bitonic> kilon: emacs
03:28:04 <kilon> ah great I love emacs
03:28:10 <Taneb> So, you're saying sort of internally having (TypeRef, Int) instead of Int
03:28:26 <Taneb> I use Eclipse because I'm a bit afraid of emacs for silly reasons
03:28:29 <kilon> should I assume there is slime for haskell to  ? (googling )
03:28:31 * hackagebot json-builder 0.2.5 - Data structure agnostic JSON serialization  http://hackage.haskell.org/package/json-builder-0.2.5 (LeonSmith)
03:28:39 <bitonic> Taneb: yes.
03:28:46 <bitonic> kilon: not really
03:29:07 <bitonic> kilon: there is ghc-mod
03:29:16 <bitonic> nothing at the level of slime
03:29:20 <asperge> I'd like to compute an approximation of really big Integers, how can I do that?
03:29:24 <CBro2007> I haven't done Haskell in a while, but do you guys recommend using it to write web apps?
03:29:26 <asperge> hum
03:29:32 <CBro2007> say writing a Facebook App in Haskell?
03:29:33 <kilon> bitonic: fair enough, thanks
03:29:35 <CBro2007> possible?
03:29:40 <asperge> I meant an approximation of the logarithm of really big Integers*
03:30:03 <asperge> I can't use log because it's too big for not-an-Integer
03:30:09 <CBro2007> or is it better for math s/w?
03:30:11 <Taneb> CBro2007, theoretically possible
03:30:21 <Taneb> Not sure if it's been done, but it's certainly possible
03:30:26 <CBro2007> Taneb: but practically a nightmare? :)
03:30:31 <Taneb> Not really
03:30:46 <CBro2007> Ah if its not been done, then probably there will be a lot of work
03:31:04 <Taneb> Look up Yesod, Snap, and Happstack
03:31:16 <Taneb> They're the big three for web dev in Haskell
03:31:25 <bitonic> asperge: check out GHC.Integer.Logarithms
03:31:29 <kilon> bitonic: how about yi ? you think emacs is better ?
03:31:36 <bitonic> asperge: not sure if there is a higher level interface
03:31:39 <CBro2007> ok
03:31:40 <asperge> thanks bitonic
03:31:57 <bitonic> kilon: never tried yi. emacs is the best.
03:32:06 <kilon> :)
03:32:23 <mcstar> @remember "emacs is the best."
03:32:23 <lambdabot> Done.
03:32:40 <bitonic> asperge: be careful, that's a really low level interface. I'd imagine there es a higher level one but I don't know where that is :)
03:32:56 <asperge> I'm looking for it :)
03:33:23 <Taneb> CBro2007, Facebook apps are in HTML, CSS, and Javascript
03:33:44 <CBro2007> yeah but the apps take an iframe
03:33:50 <CBro2007> so you got to generate the content
03:34:08 <Taneb> Which Yesod, Snap and Happstack help an awful lot with
03:34:39 <mcstar> bitonic: http://www.haskell.org/haskellwiki/Typeful_symbolic_differentiation and the thread from the link
03:34:59 <mcstar> that seems to me to preserve run time reflexion capabilities
03:36:31 <mcstar> oops, i meant to write reflection
03:36:33 <bitonic> mcstar: well you can have a typeclass that gets you a reified representation of the type at runtime (see Typeable)
03:36:51 <bitonic> mcstar: I'm not sure about what you linked, I don't have time to read it now
03:37:00 <mcstar> k
03:37:19 <bitonic> but those thing won't work to typecheck live code change
03:38:08 <aetoxx> Is there a DSL which compiles Haskell to sh?
03:39:09 <mcstar> sh == shell?
03:41:56 <andy_> @pl \q f g x y = f x (g y)
03:41:56 <lambdabot> (line 1, column 12):
03:41:56 <lambdabot> unexpected "="
03:41:56 <lambdabot> expecting pattern or "->"
03:42:10 <Guest86484> @pl \q f g x y -> f x (g y)
03:42:10 <lambdabot> const (flip . ((.) .))
03:43:20 <Guest86484> @pl \f g x y = f x (g y)
03:43:21 <lambdabot> (line 1, column 10):
03:43:21 <lambdabot> unexpected "="
03:43:21 <lambdabot> expecting pattern or "->"
03:43:29 <Guest86484> @pl \f g x y -> f x (g y)
03:43:29 <lambdabot> flip . ((.) .)
03:43:54 <Taneb> :t flip . ((.) .)
03:43:55 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f1 a -> f (f1 b)
03:44:08 <Taneb> :t flip . (fmap fmap)
03:44:09 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f1 a -> f (f1 b)
03:44:15 <aetoxx> mcstar, yes
03:44:34 <Taneb> Looks a bit better imo
03:48:08 <mcstar> aetoxx: im not sure about your question
03:48:34 * hackagebot hspec 1.2.0 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.2.0 (SimonHengel)
03:48:34 <mcstar> with very high probability, theres is no haskell to shell compiler
03:48:58 <mcstar> with high probability, there is a dsl, that lets you execute shell commands easily
03:50:26 <Palmik> Hmm, is it possible to add constraint to associated data types? For example if I have "class Foo tag where" with associated type like this "data AssociatedMonad tag :: * -> *", I would like to ensure, that the (AssociatedMonad tag) is infact monad for all instances of Foo class. Is that possible?
03:51:59 <fmap> aetoxx: there is a number of "easy shell scripting" libraries, namely Shelly, HSH, HsShellScript
03:52:02 <fmap> maybe others
03:52:32 <aetoxx> fmap, does that answer my question?
03:52:43 <nobdraisentone> Good question
03:53:34 * hackagebot FpMLv53 0.1 - A binding for the Financial Products Markup Language (v5.3)  http://hackage.haskell.org/package/FpMLv53-0.1 (MalcolmWallace)
03:53:37 <aetoxx> It was a rhetorical question.
03:53:42 <Palmik> Palmik, one solution would probably be to have the monad be parameter of Foo and ensure it in the class constaint (but i would ike to avoid that)
03:53:54 <mcstar> in that case, we all should not have answered, silly us
03:54:00 <KSkrzet> cabal-install used to get user/password for hackage uploads from ~/.config file. I still have mine there but now it asks for them. any reasons for that?
03:54:20 <aetoxx> fmap, you did not answer my question. Please try again.
03:54:52 <mcstar> Dave, please try again. And speak up this time, will you!
03:54:53 <KSkrzet> (i meant this file: ~/.cabal/config)
03:55:02 <nobdraisentone> What is the point to producing pseudo-sh in haskell, anyway
03:55:03 <nobdraisentone> &
03:55:05 <nobdraisentone> ?
03:55:22 <fmap> aetoxx: well, that's the best option to write scripts in haskell since compilers probably don't exist
03:55:36 <aetoxx> fmap, did I ask for the best option?
03:55:59 <aetoxx> fmap, the correct answer then was "silence or I am not aware of such things existing. "
03:56:36 <aetoxx> I thought Haskell was supposed to be a community of smart people :/
03:56:56 <bitonic> aetoxx: you can troll somewhere else
03:58:35 * hackagebot hspec-discover 0.1.0 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-0.1.0 (SimonHengel)
04:23:05 <morel> it's nice to see 851 people here :) -- what was our record by the way?
04:23:38 * hackagebot yesod-vend 0.2.0.0 - Simple CRUD classes for easy view creation for Yesod  http://hackage.haskell.org/package/yesod-vend-0.2.0.0 (KrzysztofSkrzetnicki)
04:25:35 <morel> morel: 920 was the record of the last two recent weeks. (according to http://irc.netsplit.de/channels/details.php?room=%23haskell&net=freenode)
04:25:47 <lolcathost> morel: :O Nice.
04:28:06 <MagneticDuck> > [1, 2, 3, 4] >>= (\x -> map (:[x]) [1, 2, 3, 4])
04:28:07 <lambdabot>   [[1,1],[2,1],[3,1],[4,1],[1,2],[2,2],[3,2],[4,2],[1,3],[2,3],[3,3],[4,3],[1...
04:28:15 <MagneticDuck> is there any pl way to write that..?
04:28:26 <morel> @type join
04:28:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:28:48 <MagneticDuck> ...join isn't just flatten for lists?
04:28:58 <morel> @pl \x -> map (:[x])
04:28:58 <lambdabot> map . flip (:) . return
04:29:16 <morel> MagneticDuck: i was just thinking…
04:29:19 <MagneticDuck> heh I was trying not to cheat with @pl
04:29:26 <morel> :)
04:30:00 <fmap> > sequence $ replicate 2 [1,2,3,4]
04:30:01 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2],[3,3],[3,4],[4...
04:30:08 <morel> @pl \ f x -> f x x
04:30:08 <lambdabot> join
04:30:21 <morel> ah, that's the function monad, right?
04:30:28 <morel> > join (+) 5
04:30:29 <lambdabot>   10
04:30:32 <morel> great.
04:30:40 <MagneticDuck> > (let canonical = (>>= map . flip (:) . return) in canonical [1, 2, 3, 4] [1, 2, 3, 4])
04:30:41 <lambdabot>   Couldn't match expected type `[a] -> a'
04:30:41 <lambdabot>         against inferred type `[a1]'
04:31:35 <fmap> > replicateM 2 [1,2,3,4]
04:31:36 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2],[3,3],[3,4],[4...
04:31:40 <adamt> Is it possible to get the size of a TBMChan after creation?
04:31:48 <fmap> MagneticDuck: probably what you want?
04:32:02 <fmap> in another order though
04:32:38 <MagneticDuck> ah yes
04:32:59 <MagneticDuck> but I want to take the canonical product of a few different lists
04:33:43 <MagneticDuck> wait.. that's what it's called right?
04:34:20 <MagneticDuck> [1, 2, 3, 4] (*) [2, 3] == [[1, 2], [2, 2], [3, 2], [4, 2], [1, 3], [2, 3]...]
04:34:39 <fmap> > sequence [[1,2,3,4],[5,6]]
04:34:41 <lambdabot>   [[1,5],[1,6],[2,5],[2,6],[3,5],[3,6],[4,5],[4,6]]
04:35:23 <MagneticDuck> ah, the cartesian product
04:35:24 <MagneticDuck> >_<
04:35:37 <MagneticDuck> ty
04:36:25 <morel> @time MagneticDuck -- is it late over there?
04:36:26 <lambdabot> Local time for MagneticDuck is Tue Jun 19 12:36:04
04:36:41 <MagneticDuck> heh
04:36:49 <MagneticDuck> canonical
04:36:54 <MagneticDuck> don't know where that came from
04:37:14 <morel> :)
04:40:56 <Cale> MagneticDuck: Cartesian product
04:40:58 <Cale> Though I guess it's canonical too in a way
04:41:27 <MagneticDuck> heh
04:41:30 <quicksilver> canonical, cartesian, categorical
04:41:37 <mcstar> whats the conversion between Float and GLfloat?
04:41:40 <quicksilver> all words beginning with C are synonyms anyway, right?
04:41:43 <quicksilver> mcstar: realToFrac
04:41:44 <mcstar> cat
04:41:49 <mcstar> thanks
04:42:28 <Taneb> coprophage
04:42:40 <quicksilver> realToFrac is the conversion between any two floating types.
04:42:54 <mcstar> good two know
04:43:05 <mcstar> i wonder though
04:43:06 <Taneb> Assuming the first is Real
04:43:09 <MagneticDuck> canonical, camblet, canaanitish, cannicula, callistemon, all the same thing
04:43:17 <Taneb> And the second is Fractional
04:43:19 <mcstar> this is code from yannesposito's blog
04:43:31 <Taneb> It can't convert fake types
04:43:31 <mcstar> does he test the code? it doesnt compile
04:43:40 <mcstar> it happens a lot
04:44:02 <mcstar> there is that blog, infinity something, with quite a few errors
04:46:02 <mcstar> great, working
04:58:41 * hackagebot SoOSiM 0.2.1.0 - Abstract full system simulator  http://hackage.haskell.org/package/SoOSiM-0.2.1.0 (ChristiaanBaaij)
05:00:20 <linduxed> as for comments, -- doesn't need a space after them, right?
05:00:28 <linduxed> there's no requirement of it?
05:00:57 <mikeplus64> linduxed: --> is used as an operator in some places
05:01:05 <Taneb> linduxed, unless you want a symbol after it
05:01:08 <mikeplus64> (namely xmonad)
05:01:10 <Taneb> Like --*
05:01:16 <Taneb> Or -->
05:01:16 <linduxed> hmmm
05:01:27 <Taneb> --Taneb is okay, though
05:01:52 * Taneb is a narcissist
05:01:59 <linduxed> so... -- without a space works as a comment, but there are cases where -- is the start of something like --> ?
05:02:05 <Taneb> Yeah
05:02:09 <linduxed> hmmm
05:02:14 <sopvop> how to turn [a,b,c,d] into a <*> b <*> c <*> d?
05:02:20 <linduxed> that explains it
05:02:30 <fmap> is sequence of -- is not a part of legal lexem you don't need space
05:02:35 <fmap> if*
05:05:09 <aristid> :t foldr1 (<*>)
05:05:10 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
05:05:10 <lambdabot>       Expected type: f (a -> b)
05:05:10 <lambdabot>       Inferred type: f a
05:05:15 <Taneb> aristid, I thought that too
05:05:15 <aristid> sopvop: you can't.
05:05:29 <aristid> sopvop: <*> is not a symmetric operation
05:05:49 <hpc> :t foldr (<*>)
05:05:51 <lambdabot> forall (f :: * -> *) b. (Applicative f) => f b -> [f (b -> b)] -> f b
05:06:03 <linduxed> hey
05:06:07 <linduxed> just a thing though
05:06:40 <linduxed> you mention these "signs" (i don't know what to call them) that start with --
05:06:49 <aristid> hpc: hmm ok, so it works in some cases
05:06:57 <hpc> linduxed: "lexeme"?
05:06:57 <linduxed> so far you've mentioned --* and -->
05:07:34 <aristid> linduxed: all operator characters, which is basically all punctuation and such
05:07:50 <hpc> aristid: note that it behaves more like an applicative (.) than a ($) though
05:07:55 <linduxed> i'm just wondering, for all of those (if there are more than 2), could that last character besides -- be the first character in a line?
05:08:03 <hpc> it ends up being closer to a (b (c (d))) than a b c d
05:08:26 <linduxed> i'm mainly asking due to this https://github.com/scrooloose/nerdcommenter/pull/73
05:08:40 <aristid> hpc: i might understand that when i'm awake for more than 10 minutes :)
05:08:59 <linduxed> i'm trying to fix that commenting plugin, so i deleted the space
05:09:43 <MagneticDuck> question: is there any function that returns the sublists with a certain length that are infixes of a larger list and follow a certain predicate?
05:09:58 <hpc> linduxed: look at the rules for haskell identifiers and infix symbols
05:10:13 <hpc> "--" is a valid substring of an infix symbol, but (--) itself doesn't exist
05:10:14 <linduxed> hpc: where would i find such information?
05:10:20 <hpc> @where ghc
05:10:20 <lambdabot> http://haskell.org/ghc
05:10:24 <hpc> see the user guide
05:10:27 <hpc> @where report
05:10:28 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
05:10:30 <hpc> also here
05:10:52 <hpc> anyhoo, when (--) is encountered (the lexeme, not the character sequence), it gets read as a comment start
05:10:58 <hpc> which is why --This is a comment
05:11:02 <hpc> but --> this isn't
05:11:35 <aristid> it's a bit evil that -- | is the common syntax for Haddock comments, but --| doesn't even start a comment
05:11:45 <hpc> hehe, quite
05:11:47 <linduxed> hmmm
05:11:55 <linduxed> well this makes it a bit tricky
05:12:01 * hpc comments on that pull request to clarify
05:12:06 <fmap> and <-- is (<--), not (<)--
05:12:21 <aristid> linduxed: i recommend that you generally put a space after the --
05:12:28 <linduxed> hpc: thank you, i don't think i would be able to explain it properly myself
05:12:31 <aristid> (and before it, for that matter)
05:12:38 <linduxed> aristid: well i always do!
05:12:44 <linduxed> i love spaces after comments
05:12:47 <linduxed> but
05:12:48 <aristid> haha
05:13:08 <linduxed> as you saw in the pull request, it broke the "sexy comment" functionality
05:13:31 <aristid> linduxed: oh i oversaw that link
05:13:44 <linduxed> aristid: do check it out, it's very short
05:13:58 <linduxed> and the diff is literally one char
05:14:31 <MagneticDuck> is there any function that chops lists up into sublists of a certain length?
05:14:39 <Botje> Data.List.Split.chunk
05:15:09 <aristid> linduxed: i recommend not accepting that, as it is potentially unsafe
05:15:47 <MagneticDuck> ah ty Botje
05:15:51 <hpc> hmm, the report seems to disagree with what i said
05:15:52 <aristid> linduxed: oh, you were the submitted
05:15:55 * hpc experiments a bit
05:15:55 <MagneticDuck> I'm using that Split library a lot!
05:16:26 <hpc> but ghci agrees
05:19:37 <hpc> commented
05:21:08 <Peaker> I am watching the Agda demo screencast, seeing the emacs-based IDE.. bottle (will) blow it out of the water :-)
05:22:08 <Cheery> Peaker: I came to look at you
05:22:21 <Peaker> Cheery, what do you mean?
05:22:44 <Cheery> http://www.raspberrypi.org/phpBB3/viewtopic.php?f=31&t=8155
05:22:54 <Cheery> the latest post shows where I gotten few days ago.
05:23:14 <Cheery> and I have revised my plans shortly after. trying to come up with next version today
05:23:44 <Cheery> Neil Fraser's blockly seems to be not far off, although I thought it would be.
05:23:52 <Peaker> Cheery, cool..
05:23:54 <Cheery> by closer inspection it weren't.
05:25:02 <Peaker> Cheery, it's a very different concept from bottle though, clearly
05:26:20 <Cheery> Peaker: how does bottle differ?
05:26:53 <Cheery> Peaker: actually I also thought first blockly would be very much different from my thing.
05:26:55 <Peaker> Cheery, iirc, you explained how your editor lets you edit text splices directly
05:26:56 <Cheery> but it weren't.
05:27:15 <Cheery> Peaker: I can throw the code to inspect for you now.. it's just 400 lines
05:27:24 <Peaker> is it on github?
05:27:39 <Cheery> the newest one isn't yet on github
05:27:47 <Cheery> going to be though
05:28:09 <Peaker> Cheery, are you working without source control? :P
05:28:10 <Cheery> http://bpaste.net/show/U10dj7bwAAYm1MX7ROUC/
05:28:14 <Cheery> Peaker: nope
05:28:28 <Peaker> Cheery, do you support "holes"?
05:28:51 <Cheery> Peaker: the newest system supports "holes", but they're really just empty lists that are called scratchs.
05:29:44 <Peaker> what's the casuarius lib?
05:29:49 <Peaker> Cheery, btw, did you run bottle?
05:29:56 <Cheery> Peaker: yes I did
05:30:06 <Cheery> Peaker: casuarius is a constraint solving toolkit
05:30:21 <Peaker> Cheery, cool, did you manage to play with the type inference, infinite types, etc?
05:30:36 <Cheery> did not play with it too much.
05:30:52 <Peaker> how do I install casuarius?
05:31:06 <Peaker> Cheery, what do you aspire to do with your project?
05:31:53 <Cheery> Peaker: everything
05:31:58 <Peaker> heh
05:32:20 <Cheery> Peaker: get it now - it's generic!
05:32:20 <Cheery> :)
05:32:36 <Peaker> I did, but I can't run it, it lacks casuarius ..
05:32:47 <Cheery> yes. you have to pip install it
05:33:00 <Cheery> or look up from apt repos
05:33:42 <Cheery> I remember I installed it from pip though
05:35:15 <aristid> Peaker: what's bottle?
05:35:32 <Cheery> aristid: his structural editing concept
05:35:35 <Peaker> aristid, a structural editor for functional programming
05:35:45 <Peaker> aristid, IDE actually, will include a structural revision control too
05:35:47 <aristid> Peaker: initial implementation will be for haskell?
05:35:50 <Cheery> Peaker: thank you from trying the editor. please tell me how it feels like if you get it to run
05:35:58 <Peaker> aristid, yeah, there's a cute prototype/demo
05:36:23 <aristid> Peaker: while agda's features are limited, they are also awesome and easy to miss in haskell :)
05:36:43 <aristid> -agda+agda's emacs modes'
05:36:54 <Peaker> aristid, we do want to have DT's eventually
05:37:08 <Peaker> aristid, we love what we know of Agda..
05:37:09 <aristid> Peaker: i don't mean dependent types actually
05:37:33 <aristid> Peaker: i mean the goal system, and the automatic case splitter
05:38:09 <Peaker> aristid, yeah, bottle will have that :)
05:38:15 <aristid> cool
05:38:35 <aristid> Peaker: do you have a website for it?
05:38:43 <Peaker> aristid, nope, it's preliminary
05:38:56 <Peaker> don't want to attract too much attention too early
05:39:00 <applicative> Peaker in the demo do you do your own type inference?  I mean without going to ghc or whatever?
05:39:20 <aristid> Peaker: if you don't want attention why do you mention it in one of freenode's biggest channels? :)
05:39:43 <Peaker> aristid, I do want feedback/attention, just not too much :)
05:39:48 <Peaker> applicative, yeah
05:39:56 <aristid> Peaker: is the demo a video?
05:40:04 <Peaker> aristid, no, just a prototype you can run
05:41:08 <Peaker> Cheery, where's "essence.ui" from?"
05:41:21 <Minoru> some guys already tried "not to draw too much attention" by claiming that they need to "avoid success at all costs" while developing best programming language ever, Peaker. Motto didn't help them stay in shadows much longer.
05:41:54 <aristid> Minoru: it worked for almost 20 years :)
05:42:01 <Cheery> Peaker: it's in github.com/cheery/essence/
05:42:04 <applicative> aristid, it's on github; I could use a video tutorial to figure it out...  I did manage to define a couple of things; it shows types for all the subordinate expressions.
05:42:10 <Cheery> Peaker: oh sorry about that.
05:42:26 <Cheery> Peaker: I forgot to link on that :)
05:43:03 <Peaker> Minoru, :)
05:43:12 <Peaker> applicative, Well there's the "legend" of all possible keyboard inputs
05:43:31 <Peaker> applicative, but you do have to do some trial&error to play with stuff...
05:43:36 <Peaker> (and the UI is very rough yet)
05:43:52 <applicative> Peaker yeah, thats  what I was doing last night.
05:44:16 <Peaker> applicative, soon we'll have hole-types inform them on how to do smart completions
05:44:25 <applicative> aristid: but the tiny bit I grasped had a lot of similarity  to agda with wholes only more so
05:44:30 <Peaker> applicative, and present type errors in a more concise way, and perhaps make types less intrusive in the UI
05:45:03 <Peaker> I think our type errors are already nicer than GHC errors though, easier to understand
05:45:29 <Peaker> Cheery, essence has its own editor.py?
05:46:24 <Peaker> installing Python libs is more tedious than cabal-install :P
05:49:18 <Cheery> Peaker: essence has it's own editor.py, which is the functioning editor
05:49:33 <Cheery> Peaker: the paste I gave is the next version, which is still missing parts
05:49:38 <Cheery> Peaker: going to finish it today
05:50:10 <Cheery> Peaker: the newest version has very flexible layouter and improved document structure which supports syntax enforcement
05:53:34 <Cheery> Peaker: understood what  I jjust said?
05:53:39 <Cheery> :)
05:54:18 <Cheery> Peaker: actually I'm planning very strict plugin-provided syntax enforcement into my latest.
05:54:43 <Cheery> Peaker: didn't thought about that first.. but then I wrote the interpreter
05:54:56 <Cheery> Peaker: actually it'd be good for you to look at the interpreter, it's too in the github
05:55:20 <Cheery> read the /essence/interpret.py
05:56:02 <Cheery> you can see it's bit messy
05:56:10 <Cheery> because it doesn't get exact AST
05:56:35 <Cheery> that's the thing I think the syntax enforcement in editor will fix.
05:56:51 <Cheery> Peaker: you know why it was missing from the first version? you could guess it
05:58:12 <Cheery> You are doing more editing than writing new code
05:58:42 * hackagebot snaplet-mongodb-minimalistic 0.0.6.4 - Minimalistic MongoDB Snaplet.  http://hackage.haskell.org/package/snaplet-mongodb-minimalistic-0.0.6.4 (PetrPilar)
05:58:47 <mcstar> excuse my bluntness, why are you writing something is python for haskell?
06:00:18 <Cheery> mcstar: it's generic. and I really came to see Peaker since he's working on his own structural editor
06:00:45 <Cheery> mcstar: and I know structural editing is a feat that is considered an inhuman task to design and implement by some.
06:00:46 <mcstar> just asking, sry
06:01:01 <aristid> Cheery: do you have a screenshot?
06:01:05 <Cheery> aristid: sure.
06:01:19 <Cheery> http://www.raspberrypi.org/phpBB3/viewtopic.php?f=31&t=8155
06:01:49 <Cheery> mcstar: thank you from asking.
06:02:14 <mcstar> Cheery: do you know of chris gangner's idea? maybe it is similar to what you are doing
06:02:18 <mcstar> it is called light table
06:02:26 <Cheery> mcstar: but my design is generic really.. it doesn't depend on languages except the implementation language of editor, which I think  I'll change to another about soon.
06:02:53 <Cheery> mcstar: light table is a great text editor IDE design. I've studied it bit
06:03:37 <mcstar> got more than 300K on kickstarter, they went for 200K$
06:04:01 <Cheery> mcstar: I think I might be able to implement all features in light table into the editor.
06:04:13 <Cheery> what I'm doing has lot of similarities on emacs in this sense.
06:04:32 <Cheery> it already quite extensible, flexible,
06:04:43 <Cheery> getting better by every rewrite
06:05:25 <Cheery> it's smaller than notepad right now, but really as flexible as top-notch programming editors there are.
06:05:36 <Taneb> I've just thought of a bizarre use for mfix
06:05:40 <Taneb> I'm not sure if it works
06:06:43 <nihtml> Tan/win 4
06:06:46 <nihtml> oops, sorry.
06:08:41 <Taneb> It would work if there was instance (MonadFix m, MonadTrans n) => MonadFix (n m) or something
06:09:12 <ski> doesn't work
06:09:46 <Taneb> :(
06:09:46 <ski> afaiu 'ContT o m' can't be made an instande of `MonadFix'
06:09:52 <Taneb> Yeah
06:10:06 <ski> and since `ContT o' is an instance of `MonadTrans', that gives a counter-example
06:10:28 <Taneb> I'd probably want WriterT [Integer] Maybe
06:10:53 <ski> you might be able to make a subclass of `MonadTrans', and replace `MonadTrans' above with it
06:11:25 * ski isn't sure what this subclass would offer more though -- it'd need to be something which `ContT o' can't implement
06:12:01 <Taneb> Perhaps just an honesty class
06:12:44 <Cheery> mcstar: I hope to not increase hopes though.. It's still a research project. I'm not sure how far I'll get
06:13:01 <mcstar> well, good luck
06:13:20 <Cheery> I'd have more use from careful critique and analysis
06:13:21 <Cheery> :)
06:13:27 <Cheery> but oh well.
06:13:38 <Taneb> No wait, I don't want WriterT [Integer] Maybe
06:13:41 <Taneb> Hang on
06:13:50 <Taneb> I just want Writer [Integer]
06:17:58 <Cheery> mcstar: thing is. structural editing is a concept that is much researched, but still there's no practical designs around.
06:18:48 <Cheery> mcstar: I keep thinking the practical thing would be simple and straightforward to understand, that it could be filled with plentiful of tools meant for different tasks.
06:19:09 <Cheery> possibly configurable per each project with plugins
06:19:19 <mcstar> ive been thinking of something similar too, like a graphical/visual editor, but there were attempts of those long before me, and they probably all failed
06:20:09 <Cheery> well pbj shown me couple things last time when I discussed on #lisp channel about this.
06:20:18 <mcstar> pjb
06:20:37 <Cheery> http://emacswiki.org/emacs/ParEdit
06:20:51 <bitonic> Cheery: paredit is great.
06:21:00 <bitonic> once you get the hang of it
06:21:22 <bitonic> but lisp is the perfect thing to do structural editing ok
06:21:29 <mcstar> :)
06:21:40 <mcstar> lets up the ante with haskell
06:21:43 <Cheery> http://pages.cs.wisc.edu/~fischer/papers/synthesizer.pdf
06:21:52 <Cheery> http://www.informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/sedit/index.html
06:22:23 <Cheery> http://larry.masinter.net/interlisp-ieee.pdf
06:22:54 <Cheery> oh.. and there's this one recent
06:23:01 <Cheery> http://code.google.com/p/blockly/?redir=1
06:23:27 <andares> wow,wha an old paper.
06:23:50 <mcstar> honestly, much of these look more like a distraction than being useful
06:24:03 <Cheery> most of them match yes.e
06:24:11 <Cheery> but they're interesting reading
06:24:13 <Cheery> all of them
06:24:14 <bitonic> mcstar: paredit is very useful.
06:24:30 <mcstar> maybe
06:24:34 <bitonic> I edit all my lispy code with it
06:24:49 <bitonic> well, if it is useful to someone, it is useful.
06:24:51 <Cheery> paredit behavior was something I thought of early.
06:25:00 <mcstar> bitonic: indentation tells all the things you need to understand lisp code
06:25:01 <Cheery> but there's a problem if you apply it into layouted code
06:25:12 <mcstar> except with the infamous 'loop
06:25:14 <mcstar> '
06:25:23 <Cheery> you have to be able to collapse and build nodes when editing
06:25:29 <bitonic> mcstar: eh? indentation? lisp is not indentation-dependent
06:25:55 <Cheery> but  if you collapse layouted things, the layout causes the code to go all messup.
06:26:03 <Cheery> also the program becomes invalid easily
06:26:07 <mcstar> if you idimaticcaly indent, and you have paren highlighting, i dont know what else you need
06:26:12 <mcstar> idomatically*
06:26:12 <Cheery> which means you have to take that into account with interpreter
06:26:33 <Cheery> that's why I have 'scratch' -elements in my new design.
06:26:37 <bitonic> mcstar: paredit is not about reading lisp code, it's about modifying it
06:26:55 <Cheery> whenever you get to do editing, you'll instantiate scratch block.
06:27:03 <Cheery> which catches the collapses and so on.
06:27:04 <andares> as long as we're on this discussion, are there any editors that show you a tree structure of your code block while you're editing?
06:27:10 <mcstar> bitonic: what does it do? switch between matching parens? and insert only matching parens?
06:27:28 <mcstar> and correspondingly delete them in pair
06:27:29 <andares> so you'd have kind of a graphical schematic to complement your flat text.
06:27:56 <wachmc> #go
06:28:09 <Cheery> mcstar: it removes only matching parens, and refuses to remove parens without removing matching paren.. also creates parens in pairs, and jumps out of paren with )
06:28:17 <bitonic> mcstar: you never explicitly manipulate parems
06:28:20 <bitonic> *parens
06:28:29 <bitonic> you just create and remove matching parens
06:28:39 <mcstar> ok, thats what i thought
06:28:59 <bitonic> mcstar: so, nothing to do with reading code
06:29:15 <mcstar> how so?
06:29:27 <mcstar> you have to read the code obviously
06:29:48 <bitonic> mcstar: paredit does not help you in that
06:30:00 <mcstar> it keeps parens matched all the time
06:30:13 <bitonic> ...it does not aid in reading the code
06:30:17 <andares> which seems trivial enough..
06:30:21 <bitonic> it just ensures that the code is well formed
06:30:35 <Cheery> what text does well is editing.. that's why it has stood hard.
06:30:53 <Cheery> oh.. and diff + grep is good on text too
06:31:09 <Cheery> but I think it's fail to design document structure based on diffing and searching.
06:32:02 <Cheery> because they are trivial and solved problems after all. :)
06:32:26 <Peaker> Cheery, I don't understand "syntax enforcement"
06:32:37 <Cheery> Peaker: similar how haskell enforces types
06:32:41 <Peaker> Cheery, if you're editing a structure, then the syntax is already enforced?
06:32:45 <Cheery> I think that'd work for syntax trees
06:32:45 <andares> Cheery: I mean, there are some dataflow languages like labview that are inherently graphical.
06:32:54 <andares> and those seem to have held up.
06:32:58 <Cheery> andares: well look at blockly.
06:33:06 <bitonic> and most of them suck for real work
06:33:18 <bitonic> well, for programming
06:33:25 <mcstar> bitonic: im not trying to argue with you, i just simply dont get in what way paredit helps, does it make you type faster?
06:33:26 <Cheery> in blockly, you can't connect male piece to female, and you can't connect certain pieces to others
06:33:27 <andares> awww I want to like blockly.
06:33:48 <Cheery> bitonic: that's syntax enforcing.. and yes it sucks for work
06:34:00 <Cheery> bitonic: the scratch -lists are supposed to solve that
06:34:06 <bitonic> mcstar: yeah I type lisp code much faster.
06:34:23 <bitonic> the best thing is to kill/copy blocks automatically
06:34:42 <andares> and intelligent editing through a sophisticated editor like vim or emacs.
06:35:08 <bitonic> Cheery: what's syntax enforcing?
06:35:29 <Cheery> bitonic: prevent constructing a tree that's invalid in the defined language
06:35:42 <Cheery> bitonic: like.. say you have lisp-style define.
06:35:45 <hiptobecubic> is it possible to install a new ghc with cabal?
06:35:47 <bitonic> Cheery: ok... but that does work for real work (paredit)
06:35:53 <Cheery> it contains: namestring, arguments list, program body
06:36:21 <Peaker> Cheery, the structure you edit can be invalid?
06:37:23 <Cheery> Peaker: it can, but I'll make tools into the next version to make it easy to keep it correct
06:37:56 <Cheery> Peaker: okay. I start from beginning here..
06:37:59 <bitonic> Cheery: ok, if that existed I'd use that
06:38:16 <Peaker> Cheery, what do you mean by "structural editor"?  What I mean is something that edits a valid structure, using valid structural transformations
06:38:26 <Cheery> idea is to edit trees that can be used as input code for compilers and interpreters.
06:39:04 <Cheery> if the trees are invalid, it makes burden on the interpreters to  evaluate them.
06:39:09 <Peaker> Cheery, btw, what language will you edit? You more a pythoneer than a Haskeller?
06:39:34 <Cheery> Peaker: I think it'll be something like lisp, but looks like python on the screen.
06:40:03 <Cheery> Peaker: I prefer fast development tools, dynamic language environments
06:40:16 <Cheery> javascript, python, lisp, etc.
06:40:18 <bitonic> Cheery: so wait why are you here in the first place :)?
06:40:29 <Cheery> bitonic: because I came to see at Peaker. :)
06:40:37 <bitonic> Cheery: oh well, ok.
06:40:47 <Peaker> Cheery, the editor will edit a dynamic language?
06:41:06 <Cheery> Peaker: yes, but like I said, it can be configured for about anything
06:41:17 <Peaker> Cheery, I think dynamic languages are a very bad choice for a structural editor -- much less useful things for editor to do as you edit.  Non-pure also less useful because you can't run-as-you-edit
06:41:29 <bitonic> Cheery: anyway it's doable, but with most of the languages you're going to end up being faster typing. Except with a language like lisp with no syntax
06:41:46 <mcstar> Peaker: you can test code as you write
06:41:51 <Peaker> Haskell's purity is going to make editing and debugging a joy - as you will see the result of executing the functions as you edit them
06:41:56 <mcstar> one of the selling point of lighttable
06:41:58 <Peaker> mcstar, if the code is full of IO effects?
06:42:06 <mcstar> yes
06:42:10 <Peaker> mcstar, then as you edit it, do you re-execute the IO effects after every edit?
06:42:10 <Cheery> bitonic: oh I'm not worrying about typing speed. in fact any structural editor exceeds text editors at that.
06:42:21 <Cheery> bitonic: editing speed is poor on structural editors.
06:42:25 <mcstar> Peaker: even if it doesnt make sense :)
06:42:35 <Cheery> because they attempt to keep the syntax valid.
06:42:38 <bitonic> Cheery: do you consider paredit a structural editor? that's definitely faster
06:42:40 <Cheery> I have solution on that.
06:42:44 <Peaker> mcstar, that sucks :)  a Haskell editor can safely evaluate your code as you edit it and it will always make sense
06:42:45 <Cheery> figured it out while ago.
06:43:16 <Peaker> Cheery, "editing speed is poor"? What do you mean?  Editing speed in Bottle is already somewhat fast, and when the UI is polished, will be super-fast
06:43:18 <Cheery> but only because the layout messed up annoyingly in the editor that didn't attempt to maintain layout.
06:43:34 <bitonic> @where Bottle
06:43:35 <lambdabot> I know nothing about bottle.
06:43:41 <bitonic> Peaker: what's bottle?
06:43:48 <Cheery> Peaker: that's the common annoyance perceived by earlier attempters.
06:43:58 <Cheery> Peaker: it was straight in the craft of text editing -document.
06:43:59 <Peaker> bitonic, me and yairchu's structural editor
06:44:02 <mcstar> Peaker: yeah, link please
06:44:08 <Peaker> http://github.com/Peaker/bottle
06:44:29 <Cheery> the early structural editors were fast at typing in new code.
06:44:34 <hpaste> t7 pasted “Going on the road to nowhere” at http://hpaste.org/70163
06:44:38 <Peaker> Cheery, well, most non-textual editors made grave mistakes.. from editing "flow charts" or other graphics, to not doing structural revision control
06:44:53 <bitonic> Peaker: why isn't it an emacs mode :)?
06:44:59 <Cheery> but because they tried to keep the structure, it was slow to edit.
06:45:09 <Peaker> bitonic, the idea is to get rid of text from the toolchain altogether
06:45:13 <Cheery> when editing the existing code, you have to get it in form that's invalid for a moment.
06:45:16 <Peaker> bitonic, emacs still deals with text, not structures
06:45:23 <Peaker> bitonic, also, our UI framework is far nicer than emacs :)
06:45:43 <Peaker> bitonic, also, we want to write the editor in Haskell, not elisp :)
06:46:21 <bitonic> Peaker: I think that's silly (eliminating text altogether). but good luck
06:46:28 <bitonic> and yeah elisp sucks sadly
06:46:35 <bitonic> it's a bit better in emacs24
06:46:42 <Peaker> bitonic, why do you think that's silly? Code is not text
06:46:49 <Peaker> bitonic, representing it as text is silly :)
06:47:17 <Cheery> Peaker: on getting rid of text on toolchain you're about same lines with me.
06:47:18 <bitonic> Peaker: because you're dealing with an ocean of text
06:47:27 <Peaker> bitonic, you mean legacy?
06:47:37 <Cheery> Peaker: but revision control goes to diff and grep.. I don't think it's good concern when creating the editor
06:47:39 <Peaker> we can still FFI to the textual world
06:47:49 <mcstar> FTI
06:47:56 <mcstar> foreign text interface
06:48:07 <Cheery> foreign function
06:48:08 <bitonic> yes. also, your editor is going to be quite specialized, so I'm probably going much faster in emacs anyway, because I'll never use your editor as much as I use emacs
06:48:13 <Cheery> it's not text you interact with but functions
06:48:31 <sp3ctum> bitonic, that is of course subjective
06:48:49 <bitonic> sp3ctum: what's subjective?
06:48:55 <sp3ctum> that you are faster
06:49:01 <Cheery> bitonic: I've been considering that.. yes that would happen if there were no benefits in going to structural editing
06:49:01 <Peaker> bitonic, you'll need far fewer commands in a structural editor than a text editor
06:49:08 <Peaker> bitonic, because structural edits are so much more useful than textual edits
06:49:17 <sp3ctum> i think the idea is interesting and would like to test it when possible
06:49:18 <Peaker> bitonic, so learning the new commands will be easy and each command will take you much further than in emacs
06:49:25 <Cheery> bitonic: but say refactoring would be blizzard fast with nice language specific tools
06:49:26 <Peaker> bitonic, so I think you will very quickly be quicker in it than in emacs :)
06:49:45 <bitonic> Peaker: yes but emacs is an environment that I can customise, and has an uniform interface. I type the same when typing code, email, or here on irc
06:49:54 <Cheery> sp3ctum: could you help me on testing?
06:49:54 <bitonic> that's enormously advantageous
06:50:19 <bitonic> and I can use useful functions in all this contexts. E.g. I've got spell checking on IRC for free
06:50:21 <Cheery> sp3ctum: overall I should make some contact list on testers.
06:50:37 <sp3ctum> Cheery, i'm afraid i will have quite little time, so i cannot really make a promise
06:50:49 <Peaker> bitonic, but code and email have little similarities
06:51:07 <Cheery> sp3ctum: well.. mabye later then. the prototype is hard to  get running.
06:51:20 <Peaker> bitonic, what kind of commands do you think you would miss when editing code structurally?
06:51:32 <Cheery> although it helps enormously to learn about how other people have reacted.
06:51:38 <mcstar> i'd use a structural editor, if it provided a new kind of abstraction, to keep less things in my head
06:51:49 <sp3ctum> Cheery, yeah. i read above (skimmed really) that you are using python. why talk about it in #haskell ?
06:51:58 <Cheery> sp3ctum: Peaker is here! :)
06:52:02 <Peaker> mcstar, it would save you from probably >90% of the revision control conflicts
06:52:07 <bitonic> Peaker: well, flymake, spellchecking, filling paragraphs, I use this kind of stuff in a lot of different modes for emacs
06:52:09 <Peaker> (another huge selling point, IMO)
06:52:10 <Cheery> sp3ctum: and he's doing the similar thing in haskell
06:52:19 <sp3ctum> i'm sorry if i make little sense, i'm at work and have only skimmed :)
06:52:26 <sp3ctum> ah, i see
06:52:27 <Peaker> bitonic, you get something far better than flymake out of the box :)  Spell checking on code is probably less useful and rather trivial to add...
06:52:29 <sp3ctum> thanks
06:52:37 <nand`> “Instead, the code is kept in its original, pure form. Ultimately, we hope to build a machine capable of running unmodified Haskell. Until then, we will follow another Kaballistic principle: random pieces of the code you have received will be displayed to your screen, allowing you to meditate on their meaning.”
06:52:47 <Cheery> sp3ctum: also it's interesting thing for haskell programmers isn't it?
06:52:58 <sp3ctum> Cheery, yes, of course :)
06:52:59 <ClaudiusMaximus> strict vs lazy bytestrings and when to convert between them is my tough decision of the day - any tips?  i need lazy for streaming input, but i'm guessing strict is faster/more memory compact  for other operations?
06:53:05 <bitonic> Peaker: yes but "out of the box" is useless when I step out of the designated scope
06:53:13 <bitonic> ClaudiusMaximus: toChunks
06:53:18 <ClaudiusMaximus> bitonic: when, not how :)
06:53:23 <bitonic> ah. sorry.
06:53:38 <Peaker> bitonic, what is the "designated scope"?
06:53:41 <bitonic> ClaudiusMaximus: you should give more details about what you're doing
06:53:43 <ClaudiusMaximus> bitonic: but thanks, it did take me a while to discover that funcction earlier
06:53:58 <ClaudiusMaximus> bitonic: hold on, i'll paste the bottleneck in my code...
06:54:00 <bitonic> Peaker: whatever thing you have planned for your editor
06:54:07 <Cheery> I'd love to talk with you, but I have to go doing things. :)
06:54:17 <Cheery> see you later!
06:54:22 <Cheery> afk.
06:54:22 <Peaker> bitonic, I challenge you to give an example of anything useful that will become more difficult... I can give you numerous things that become much easier
06:54:39 <bitonic> Peaker: no I mean, your editor will probably be quite specifir
06:54:42 <bitonic> *specific
06:54:50 <Cheery> bitonic: if you point out something, let me know too. that's valuable.
06:55:01 <Peaker> bitonic, sure -- all language-aware IDEs are specific.. notepad isn't specific and it is useless :)
06:55:10 <Peaker> bitonic, emacs is specific through it's "*-mode" extensions
06:55:15 <Cheery> bitonic: before that you should probably test one first though.. it helps a lot at pointing out problems
06:55:18 <bitonic> Peaker: no. emacs is not specific
06:55:23 <Peaker> bitonic, emacs is a platform for specific IDEs
06:55:28 <Peaker> but quite poor ones
06:55:32 <bitonic> Peaker: you have major and minor modes, and you can mix and match
06:55:40 <Cheery> it's in github.com/cheery/essence/  and it runs when you run editor.py
06:55:41 <quicksilver> there are *thousands* of ways in which your editor will be worse than emacs.
06:55:54 <quicksilver> people who actually understand their editor and use it worse, will miss them
06:56:03 <Cheery> but handle that casuarius dependency first
06:56:11 <Peaker> quicksilver, then name some specific ways?
06:56:19 <bitonic> Peaker: in the end, emacs is the most convenient way for me to code, email, irc, debug...
06:56:23 <quicksilver> bitonic already named some and you dismissed them
06:56:24 <Peaker> quicksilver, I think the massive set of emacs features relates to text editing, and becomes much less useful when code deiting
06:56:37 <bitonic> and a big reason is that I can share utilities
06:56:39 <hpaste> ClaudiusMaximus pasted “strict vs lazy bytestrings” at http://hpaste.org/70164
06:56:47 <Peaker> you need a massive set of features when text editing to make things bearable
06:56:57 <Cheery> afk. for real now. I'll read your arguing later. :)
06:56:59 <Peaker> bitonic, can you name some example utilities?
06:56:59 <quicksilver> search replace, documentation integration, org-mode integration, shell commands/piping
06:57:00 * nand` likes having a dedicated program for a dedicated task, instead of a jack-of-all-trades program for all tasks, eg. what web browsers have been trying to do recently
06:57:06 <sp3ctum> could it have two modes: one for structural, one for plain text + epic text featuress
06:57:18 <Peaker> quicksilver, search replace is more a bug than a feature, because it replaces text, regardless of structural integrity, scoping, etc.
06:57:23 <quicksilver> autocomplete, templates/snippets
06:57:27 <bitonic> Peaker: flymake, spellchek, bbdb, paredit
06:57:45 <bitonic> Peaker: those are in my mind now because I'm using them in this very moment
06:57:48 <Peaker> quicksilver, the various other features you mentioned are do not relate to code editing...
06:57:50 <hiptobecubic> can i install a new ghc binary with cabal?
06:57:50 <nand`> have you considered the idea of switching between structural and plaintext editing modes seamlessly, allowing the user to choose which mode he wants for which change?
06:57:51 <bitonic> 2 of them to type these messages
06:57:52 <quicksilver> rebindable commands / macros
06:58:04 <quicksilver> Peaker: but they are all useful as part of the programming process
06:58:06 <hiptobecubic> cabal install ghc fails
06:58:11 <Peaker> bitonic, you keep mentioning flymake, but flymake is a really really poor substitute for an editor that keeps things in tact and types them as you edit
06:58:27 <nand`> ie. allow me to hit a button that says “hey, let me edit the haskell source for this (and only this) function quickly”
06:58:30 <Peaker> bitonic, what part of the code do you want to spell check?  Do you actually want the spelling errors marked for the various Haskell function names?
06:58:30 <quicksilver> I don't really want to learn another sublanguage for writing macros / binding keys / executing excternal commands
06:58:30 <bitonic> Peaker: what? how is flymake a substitute for an editor?
06:58:57 <Peaker> bitonic, I worded that poorly -- flymake is a hack
06:59:15 <bitonic> Peaker: 1) I don't only type code in emacs. I also do LaTeX, email and IRC. I've mentioned this several times. 2) I spell check comments
06:59:22 <quicksilver> Peaker: I'm not really trying to be negative about your vision; it's a trade-off and you get some interesting advantages and I encourage you to impress us.
06:59:39 <quicksilver> Peaker: but you seem unwilling to accept that it's a trade-off, you want to believe it's a pure win.
06:59:52 <Peaker> bitonic, there are some useful nuggets hiding in there (e.g: spell checking comments) and they're trivial enough to add
07:00:05 <jedai> Well you seems to be arguing past each other...
07:00:06 <Peaker> quicksilver, I think it is indeed a trade-off simply because we're throwing out legacy
07:00:24 <quicksilver> Peaker: but it's annoying if you add a new way to spell-check comments
07:00:24 <bitonic> Peaker: add up all the "trivial enough to add" and you're never, ever, going to reach an environment like emacs
07:00:35 <quicksilver> (which means we have to reconfigure it to our taste)
07:00:35 <Peaker> quicksilver, and some of the legacy has useful stuff in it -- but I think in the end it will be pure win, because it is a more correct foundation for these features
07:00:47 <quicksilver> then you don't understand.
07:00:59 <quicksilver> it cannot be pure win if I'm losing the things I had before.
07:01:03 <Peaker> bitonic, iPhone threw the Nokia legacy out the window, and the various apps available for the various legacy phones
07:01:04 <nand`> a good foundation does not make a house
07:01:06 <quicksilver> it's trade-off.
07:01:10 <jedai> For instance bitonic insists that emacs is better because it allows you to do so many things (org-mode, text editing...) but Peaker only wants a very specialized piece of software
07:01:32 <Peaker> quicksilver, As I said it is *temporarily* a trade-off.   For new learners of IDE's, it is pure win
07:01:34 <bitonic> Peaker: you're comparing Symbian with emacs?
07:01:50 <quicksilver> Peaker: for new learners, emacs is also pure win. they had nothing before.
07:01:53 <Peaker> bitonic, emacs is really not that great, I use it for 15 years now :)
07:01:59 <bitonic> I'm not sure I see the parallel. btw, iPhones suck
07:01:59 <quicksilver> Peaker: for new learners, notepad++ is pure win as well.
07:02:22 <Peaker> quicksilver, Compared to emacs? Possibly.. Compared to a structural editor, for the purpose of editing code? No, it is a pure lose
07:02:38 <quicksilver> no, you said "new learners" so you must be comparing to nothing.
07:02:40 <Peaker> bitonic, iPhones suck for other reasons though -- throwing legacy out the door is possible and was done before
07:02:48 <quicksilver> all three pieces of software are better than nothing.
07:02:55 <quicksilver> so if you're comparing to that, they're pure win.
07:02:57 <copumpkin> @remember xplat when life gives you lemons, make lemonads
07:02:57 <lambdabot> Done.
07:03:11 <nand`> ^ nice
07:03:14 <hiptobecubic> And just think. Once you're finally at feature parity with emacs, you can start trying to catch up to VIM !
07:03:14 <sp3ctum> haha
07:03:20 <Peaker> quicksilver, No, what I am saying is that the trade-off involves legacy, but legacy is not relevant for everyone. If you ignore legacy, then there's no trade-off, it will simply be better than the text editors
07:03:31 <quicksilver> Peaker: no.
07:03:35 <quicksilver> Peaker: org-mode is not legacy.
07:03:40 <bitonic> Peaker: well you probably don't use it as much as extensively as me :). Which is when you really get the benefits. Anyway, as quicksilver said, I don't want to discourage you. I just think that a generic environment like emacs is going to win against the specialized IDE. Or at least it's going to win me.
07:03:52 <Peaker> quicksilver, How does org-mode relate to code editing?
07:03:52 <quicksilver> Peaker: having a unified macro language for all my different emacs modes is not legacy.
07:04:12 <quicksilver> Peaker: having your code editor being the same piece of software as your organisation tool is an important feature.
07:04:15 <quicksilver> not a legacy.
07:04:25 <Peaker> bitonic, I think that once you use the structural editor, you'll be wowed enough to abandon emacs for code editing :)
07:04:28 <quicksilver> choosing to use a *different* piece of software for your code is, therefore, a trade-off.
07:04:32 <Peaker> (not in its current preliminary state, though)
07:04:34 <nand`> quicksilver: I'm not sure how that's an important feature, personally
07:04:39 <sp3ctum> Peaker, if you want to, PM me and i'll give you my email when i get home from work. for the possible testing thing, i think i might be able of some help sometimes :)
07:04:58 <quicksilver> nand`: it is important because they are part of the same system which I can configure and automate.
07:05:12 <quicksilver> nand`: they can share a spell-checker, they can share templates, one can store links to the other
07:05:24 <quicksilver> nand`: I only have to learn how to configure keybindings and write macros and programs once.
07:05:30 <bitonic> Peaker: I'd be happy if that happens, but I really doubt it. Not because emacs editing is so great (and it's not bad), but because 80% of the time I'm looking at a screen, I'm looking at emacs. I know my way around it.
07:05:53 <quicksilver> I don't suggest it's right for everyone, or what everyone wants.
07:06:18 <quicksilver> I'm just making the point a bit stridently that there is a real trade-off to be made here.
07:06:37 <Peaker> quicksilver, The long-looong-term idea is to have the editor also be a platform/desktop environment in the same spirit of emacs..  I was comparing the code editing aspects though
07:06:42 <nand`> quicksilver: I see your point. Personally, I just think that the “middleware glue” should not be an editor-like program like emacs but say a shell scripting language + command line APIs for everything
07:06:51 <Peaker> quicksilver, I agree that having a uniform desktop environment tool is a plus
07:06:52 <bitonic> sp3ctum: it's ok, I'll try it when it's ready
07:06:52 <quicksilver> nand`: perhaps. but that system does not exist.
07:06:59 <quicksilver> nand`: (as far as I know)
07:07:27 <bitonic> Peaker: also, you make a huge mistake calling emacs "legacy". GNU Emacs is keeping up
07:07:51 <quicksilver> I don't particularly like elisp and I don't particularly like a few of emacs' design decision; but the unity of the whole compensates for the inadequacy of the parts.
07:07:52 <Peaker> bitonic, I think all we have right now is stone-age technology, so emacs is keeping up with that
07:08:16 <bitonic> Peaker: aha. Most editors coming out now are stone age compared to emacs.
07:08:24 <bitonic> Sublime Text, TextMate, whatever.
07:08:31 <Peaker> bitonic, Sublime text has some nice features that emacs doesn't
07:09:02 <Peaker> and in practice, I've seen many emacs users, almost all of them were significantly less efficient with emacs than me, and still, the efficiency benefits I have with emacs over something like Sublime Text are rather slim
07:09:07 <bitonic> Peaker: that I can probably reproduce in emacs in 2 hrs. which is the whole point.
07:09:23 <Peaker> bitonic, there's a project that attempts to reproduce those features, it's quite a lot more than 2 hours of work and it still doesn't work well
07:09:29 <Peaker> bitonic, do you know the "Turing tarpit"?
07:09:32 <nand`> quicksilver: you're absolutely right in saying that a glue needs to exist though. Alternatives are good, very good - but only as long as they're compatible. Stuffing everything into the same program like emacs or firefox to me sounds very dangerous though, like forcing you into using that one system; perhaps when better alternatives exist that are not in this “emacs world”
07:09:56 <bitonic> Peaker: to me a turing tarpit is a programming language that is turing complete but hell to program into.
07:09:59 <quicksilver> nand`: it's a fair criticism.
07:10:12 <nand`> but you're forced to use the (inferior) emacs-compatible versions since those are the only ones you can integrate. I think the glue should be as widespread / universal as possible. Like shell scripting languages, but perhaps better implemented
07:10:19 <bitonic> Peaker: so I'm not sure how it applies here
07:10:26 <Peaker> bitonic, well, I mean it in the sense that "having power" is not the same as "actually making something practical"
07:10:36 <quicksilver> nand`: but attempts at managing compatible protocols between cooperating programs have generally descended into nightmares (corba. idl. applescript.)
07:10:42 <Peaker> bitonic, writing useful editor extensions in elisp, correctly, is very hard for non-trivial extensions
07:10:51 <quicksilver> nand`: I think gnome has something but I forget the name.
07:10:58 <Peaker> bitonic, your claim that "I can do it in 2 hours" I think is preposterous
07:11:01 <nand`> quicksilver: yes, because the problem is nobody can agree on which glue to use
07:11:15 <bitonic> Peaker: that's not true. elisp is bearable. there are 60k lines programs written in elisp, that work well.
07:11:34 <Peaker> bitonic, similarly, PG's claim that Lisp is the "most powerful language of all" because of macros is similar. You don't implement HM types with Lisp macros. It won't be easier than writing your language in Haskell
07:11:43 <nand`> it's an unfortunate reality. you'll always have the “emacs crowd” and the “vim crowd” and the “HTML5/JS/browser crowd” etc. etc. no matter how hard you try to connect them
07:12:20 <bitonic> Peaker: mah, I find that these things really don't matter. If your argument is "emacs is worse because of lack of type inference", you've got a really weak argument.
07:12:21 <Peaker> bitonic, Lisp macros and elisp extensions both theoretically empower you to write your dream language/editor on the underlying platform, thus subsuming all other languages/editors.  In practice, the reality is different
07:12:35 <Peaker> bitonic, what? that's not what I'm saying at all
07:12:41 <bitonic> Peaker: lisp macros can be used very proficiently
07:12:49 <Peaker> bitonic, I am saying that Lisp macros don't make Lisp subsume Agda/Haskell
07:12:50 <bitonic> I'm not sure what you're trying to prove here
07:12:55 <nand`> quicksilver: the downside of systems like GNOME/KDE is that everything is interconnected, you can't reliably pull in a single application without pulling in the entire glue / framework, which is again why I feel it should be as universal as possible - something everybody could easily support. But at the same time, that reduces its power
07:12:56 <bitonic> that emacs is bad because of elisp?
07:13:01 <Peaker> and emacs macros don't make emacs subsume sublime text editor let alone a structural editor
07:13:23 <quicksilver> elisp is annoying btu that's surely not the reason it's hard to write powerful emacs extensions.
07:13:36 <bitonic> Peaker: I'm just talking about the fact that emacs is extensible. the fact that elisp sucks is marginal.
07:13:44 * frerich thinks your real efficiency & productivity bottleneck is between your ears anyway
07:13:45 <quicksilver> that reason is surely more to do with the emacs core having a rather ancient document model and crufty core
07:13:45 <bitonic> and it does not suck that bad
07:13:47 <Peaker> bitonic, No, I'm trying to say that the claim "Emacs is your dream editor, you just have to implement that editor yourself" is a silly one
07:14:13 <Peaker> bitonic, And I am drawing a parallel between that claim to the claim "Lisp is your dream language, you just have to implement it in Lisp"
07:14:40 <bitonic> Peaker: that's severely warping things. You don't have to re implement the editor
07:14:44 <Peaker> so great, Lisp and emacs give me a platform to write the language/editor that I would want to use.  Except they don't actually make it easier/more practical to do so than not having them in the first place.
07:15:02 <hiptobecubic> I think have a uniform user interface is really main argument
07:15:07 <bitonic> Peaker: but the huge community did that for a number of things
07:15:21 <Peaker> bitonic, Yes you do, because pretty much all of the logic embedded in emacs is not the correct logic I would want to use in my dream editor
07:15:30 <nand`> I don't place too much emphasis on a uniform user interface, because different tasks have different ideal interfaces
07:15:47 <bitonic> Peaker: well, if the editor you want is radically different from emacs, ok.
07:16:12 <Peaker> nand`, agreed
07:16:13 <hiptobecubic> nand`, sure some things don't map well, but most things are really reduced to "moving control around" and "moving things around"
07:16:27 <bitonic> anyway. tired. good luck with your editor, I mean it :). Emacs is not perfect, but if you have to win people like me you have to empower me in a similar way that emacs does.
07:16:32 <hiptobecubic> or plain typing
07:16:34 <Peaker> hiptobecubic, if all you have is a hammer...
07:16:50 <bitonic> Peaker: luckily most programmers are not like us emacs lovers :)
07:16:53 <Peaker> bitonic, great, thanks for the chat, it's great to hear the "other side" too :)
07:16:59 <nand`> hiptobecubic: a fair point, I would love it if every single application on planet earth agreed with me that hjkl is the way to go
07:17:11 <hiptobecubic> nand`, FOR EXAMPLE
07:17:22 <hiptobecubic> and yes, every app has extra things that a hammer won't do
07:17:24 <mcstar> remember, the truth is on the other side...
07:17:35 <hiptobecubic> but you can do them fine. Just leave the basics alone, dammit
07:18:10 <mcstar> if all i have is a summer
07:18:14 <mcstar> im gonna sunbathe
07:18:17 <nand`> hiptobecubic: I'm actually glad things like $EDITOR exist and (good) applications respect them, I would be so annoyed if everything eg. git decided to invoke its own editor
07:18:33 <hiptobecubic> I'm enjoying my "force everything to use vim bindings" approach a lot right now.  Not because it makes me "super efficient" in the normal bullshit way about saving fractions of a second by leaving your hands in one place
07:18:53 <nand`> hiptobecubic: I do the same, because “that's what's intuitive to me and how it feels right”
07:18:54 <hiptobecubic> but because of muscle memory and habit, i can use all my apps naturally without thinking about it
07:19:32 <nand`> though I do appreciate the ability to keep my hands on the keyboard, mouse round trips are cumbersome :(
07:19:53 <hiptobecubic> and if the app was designed with that approach in mind, a lot of operations that i have never needed before will have a predictable mapping and 'just work' without me noticing that i guessed it correctly
07:19:55 <matthiasgorgens> nand`: hjkl is the reason I switched from vi to emacs.
07:20:20 <hiptobecubic> matthiasgorgens, in both vim and emacs you can rebind the movements to whatever horrible thing you want
07:20:44 <hpaste> tgeeky pasted “what's going on here (using implicit parameters)” at http://hpaste.org/70166
07:20:57 <aetoxx> Peaker, can you tell me one reasonable thing you cannot do in Emacs right now to use it as a base for whatever you want?
07:21:00 <Peaker> hiptobecubic, in our editor, we use ordinary arrow keys most people are used to, C-x, C-v for cut/paste, and various other conventions people are used to
07:21:01 <matthiasgorgens> hiptobecubic: yes, but I wasn't very well versed in vim back then anyway, and wanted to try out emacs.  hjkl just doesn't work that well with Dvorak.
07:21:05 <tgeeky> anyone know what's going on in that hpaste? :o
07:21:05 <applicative> oh dear, looks like an editor war has broken out.
07:21:36 <matthiasgorgens> applicative: no, no.  Everybody knows that ed ist the standard editor.
07:21:42 <matthiasgorgens> oh, excuse me: ED.
07:21:46 * applicative stresses the greatness of  nano, as usual
07:21:46 <hiptobecubic> applicative, it actually wasn't vim/emacs this time
07:21:56 <Peaker> aetoxx, As I said, using emacs as a base would be really bad, because we don't have any textual aspect. Our editor edits a key/value store directly -- not text files. It saves after every edit, there's no "save" key. Our "undo buffer" is our revision control buffer. It's implemented in Haskell. These are all things you can't reasonably do with elisp as your platform
07:22:18 * applicative looks for his haskell-highlighting nanorc
07:22:19 <Peaker> aetoxx, The revision control is structural, not textual
07:22:21 <hpaste> ClaudiusMaximus annotated “strict vs lazy bytestrings” with “strict vs lazy bytestrings (annotation)” at http://hpaste.org/70164#a70167
07:22:42 <nand`> Peaker: does your editor give me the ability to use modes / hjkl / vcp for cut/paste if I like to?
07:22:43 <quicksilver> hiptobecubic: true, although the problem wiht large-scale rebinding is that then make other features non-intuitive, because other non-core features often use keybindings which match patterns found in the standard bindings...
07:22:43 <Peaker> aetoxx, our UI animates all changes that happen nicely so you don't get disoriented
07:22:47 <aetoxx> Peaker, you still need some command interpreter.
07:22:50 <nand`> or am I forced to use arrow keys / modeless editing?
07:22:50 <Peaker> aetoxx, that's another thing the emacs platform can't do
07:23:01 <Peaker> aetoxx, what do you mean by a "command interpreter"?
07:23:02 <aetoxx> Peaker, wrong
07:23:08 <ClaudiusMaximus> seems converting each line to a strict bytestring before splitting it into words makes for faster
07:23:14 <Peaker> nand`, it is very modal, but we don't want to waste 4 more keys on navigation.. maybe it's worth it though
07:23:25 <aetoxx> Peaker, anyway, you clearly made up your mind already, but be sure that you don't know Emacs.
07:23:40 <aetoxx> Peaker, how much Emacs Lisp have you written to make a judgement like that?
07:23:42 <ClaudiusMaximus> sadly the second pass runs out of memory, working on a fix...
07:23:43 <Peaker> nand`, if you're not in a rename/editing-text, then you can x/v without ctrl for cut/paste.  We can make hjkl be alternate arrows
07:23:45 * hackagebot unfoldable 0.6.0.1 - Class of data structures that can be unfolded.  http://hackage.haskell.org/package/unfoldable-0.6.0.1 (SjoerdVisscher)
07:23:52 <Peaker> aetoxx, what is it that you're claiming I can do?
07:23:57 <nand`> Peaker: I like the concepts of distinct navigation and editing modes; if I switched to your editor for writing haskell I'd like to keep all of the things that make vim nice for me
07:24:20 <Peaker> nand`, did you try bottle out?
07:24:25 <nand`> Peaker: no
07:24:36 <aetoxx> Peaker, it's possible to embed any kind of application Emacs.
07:24:42 * applicative is constantly stunned by emacs partisanship like this; its at least as irrational as latex worship
07:24:59 <hiptobecubic> What's wrong with latex? other than writing it
07:25:07 <Clint> it's too pretty
07:25:08 <quicksilver> applicative: I think if you read back you'll find plenty of *rational* actually.
07:25:10 <applicative> that it
07:25:13 <nand`> ugh, LaTeX. How do people worship that thing? I mean it's neat and better than all alternatives I've tried, but still objectively horrible
07:25:15 <aetoxx> If you want to do a multi-threaded GUI, you could even embed that in Emacs.
07:25:25 <aetoxx> Completely transparant to the user.
07:25:26 <Peaker> aetoxx, if you use emacs as a stupid graphical canvas, why use emacs?
07:25:30 <hiptobecubic> Because it's better than all the alternatives.
07:25:38 <Yarou> LaTeX is great, unless you have an allergy of course
07:25:45 <aetoxx> Peaker, because then you already have M-x blah working.
07:25:53 <aetoxx> Peaker, and a huge installed base.
07:25:53 <applicative> is an giant pile of macros built by half-wit users  built upon macros built by other users, with no way out
07:25:54 <nand`> I have an allergy to unpredictable syntax. LaTeX has put me in the hospital for weeks
07:26:06 <aetoxx> Peaker, there are lots of other advantages.
07:26:16 <Peaker> aetoxx, Good lucky implementing 60fps smooth animated GUI framework on top of an emacs canvas
07:26:17 <aetoxx> Peaker, do you really think people will care to start your little precious program?
07:26:33 <Peaker> aetoxx, these benefits aren't appealing to me. I don't find emacs to be very good, though.
07:26:34 <aetoxx> Peaker, I didn't say you had to do that.
07:26:58 <Peaker> aetoxx, I think people will want to start my precious program, when they discover that it leaves the alternatives in the dust when it comes to code editing :)
07:27:23 <aetoxx> Peaker, does it even have a line of code written for it?
07:27:39 <aetoxx> Peaker, or is this one of those 'I am building a website and it is going to be web-scale'-things?
07:27:45 <Peaker> aetoxx, what do you mean? we're working on it.. we're currently at ~6500 lines of Haskell
07:27:48 <applicative> if it manages to realize an idea of structural version control, it will be amazing
07:27:53 <Peaker> aetoxx, and a nice prototype/demo
07:28:02 <frerich> aetoxx: It's at https://github.com/Peaker/bottle
07:28:07 <quicksilver> aetoxx: I think you've strayed slightly over the line into rudeness, myself.
07:28:12 <Peaker> applicative, yeah, not having stupid conflicts due to textual representation of diffs would be awesome
07:28:43 <nand`> applicative: I'd be interested in that as well. Especially if I can use it on its own
07:29:02 <hiptobecubic> applicative, I was pretty upset for the first few times i used it. But once you get your own packages working and just never touch them ever again and don't try to share anything, then I think it stomps everything else available.
07:29:16 <nand`> I'd be more interested in automatic merging by tapping into deeper knowledge than “here are the lines”
07:29:44 <applicative> hiptobecubic: emacs? yes it's very much 'leave well enough alone'
07:29:47 <Peaker> nand`, yeah, you get much of that for free, for example since a "rename" is really a localized change, so it merges cleanly with other changes
07:29:59 <hiptobecubic> applicative, structural version control would be the game changer that could uproot the "standard" way for sure
07:30:01 <nand`> Peaker: yes, things like that
07:30:19 <hiptobecubic> applicative, i meant latex, but emacs/vim follow the same rules so sure.
07:30:30 <aetoxx> There are already systems which have structural version control.
07:30:43 <applicative> oh yes.  the same.  I use latex all the time, emacs only for agda
07:30:47 <aetoxx> Just not for Haskell.
07:31:19 <aetoxx> quicksilver, are you a member of the online gestapo?
07:32:03 <applicative> aetoxx: what fascist empire is quicksilver representing?
07:32:37 <flux> I sometimes muse about the idea of having versioned copy-paste
07:32:57 <flux> you could, for each character, learn if it has been copied and from where and when, and of course the same in reverse
07:33:00 <Peaker> nand`, hmm.. adding hjkl for navigation now, let me see how it feels
07:33:00 <quicksilver> aetoxx: no. No such membership is required to comment on another's perceived rudeness.
07:33:02 <nand`> the most important thing about a programming language after all is its semantics, not its syntax. I wouldn't be too scared of structural representations myself
07:33:38 <aetoxx> quicksilver, should I comment on the perceived stupidity of other people's comment too?
07:33:48 <Clint> probably not, given your temperament
07:35:16 <quicksilver> aetoxx: probably not; that is very hard to do without being rude.
07:35:24 <aetoxx> "Look, at me, I am God, you cannot say things which upset my little children. I will make you hurt real good, otherwise." It's mafia practices; nothing else.
07:35:52 <Clint> yes, you're being unfairly oppressed for being a jackass
07:35:55 <nand`> I think that analogy is a bit remote. It has more to do with keeping discussions civil
07:36:04 <quicksilver> this is but one channel; there are many outlets on the internet available. In this channel, we like to keep discussions civil.
07:36:31 <quicksilver> I only made a single remark in response to a couple of your comments; the conversation was in general an interesting one.
07:36:32 <nand`> the MO of a regime is “don't criticize us”, this is more of a “you can criticize us, but do so politely”
07:36:51 <applicative> who has a good 'noob' type error to interpret, maybe that will clear the air.... or a cabal install problem....
07:37:06 <bitonic> well but IRC channels (and open source projects) are usually not democracies
07:37:11 <Peaker> nand`, I added hjkl navigation
07:37:33 <nand`> Peaker: I saw
07:37:45 <nand`> applicative: No instance for (Num ()) arising from a use of `+'
07:37:47 <applicative> oh hiptobecubic no, you cant install a new ghc with cabal-install
07:38:00 <applicative> > () + ()
07:38:01 <lambdabot>   No instance for (GHC.Num.Num ())
07:38:01 <lambdabot>    arising from a use of `GHC.Num.+' at <i...
07:38:08 <nand`> applicative: be more imaginative
07:38:13 <Taneb> @pl coll 1 = return Nothing; coll n | even n = putl (n `div` 2) | odd n = putl (3 * n + 1)
07:38:13 <hiptobecubic> applicative, did you scroll back and look for something on topic?
07:38:13 <lambdabot> (line 1, column 24):
07:38:14 <lambdabot> unexpected ";"
07:38:14 <lambdabot> expecting variable, "(", operator or end of input
07:38:24 <applicative> hiptobecubic: yes
07:38:26 <Peaker> nand`, I mean I pushed it to github :)
07:38:29 <applicative> :)
07:38:29 <Taneb> :/
07:38:34 <nand`> Peaker: I see
07:38:35 <hiptobecubic> applicative, well thank you :)
07:38:39 <Taneb> @pl let coll 1 = return Nothing; coll n | even n = putl (n `div` 2) | odd n = putl (3 * n + 1) in coll
07:38:39 <lambdabot> (line 1, column 37):
07:38:40 <lambdabot> unexpected "|"
07:38:40 <lambdabot> expecting pattern or "="
07:38:40 <nand`> applicative: I was hinting at the monomorphism restriction :(
07:38:46 * hackagebot MonadRandom 0.1.7 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.1.7 (PatrickPalka)
07:39:01 <hiptobecubic> applicative, i ended up downloading a binary and doing   ./configure --prefix=/home/myuser/ghc
07:39:08 <hiptobecubic> then put it in $path
07:39:16 <hiptobecubic> we'll see how that works in the long term
07:39:39 <hiptobecubic> damnit
07:39:54 <ion> hiptobecubic: What could be the problem with that in the long term?
07:39:56 <quicksilver> should be fine; having multiple GHCs in different prefixes is quite supported
07:40:00 <nand`> speaking of GHC upgrades, how stable is ghc 7.4.2? I'm tempted to try it out
07:40:05 <quicksilver> (and various developers do it routinely)
07:40:07 <applicative> hiptobecubic: you another ghc elsewhere from your package manager or whatever?
07:40:13 <hiptobecubic> There's a great example of NOT having a uniform interface screwing me in the ass again.  <C-w>  closes a channel instead of deleting a word
07:40:31 <hiptobecubic> applicative, yes. but it's 7.0.4 and i need 7.4
07:41:11 <applicative> building ghc is an experience if you havent tried it :)
07:41:29 <ion> This is what i always do. I suppose it should work even if there’s a system version of GHC as long as the path is added to the front of $PATH. https://gist.github.com/2815423
07:42:30 <hiptobecubic> applicative, someday perhaps. Not this one though.
07:43:38 <Peaker> hiptobecubic, it's less of a big deal if you have a global undo you can trust, and make irreversible operations unlikely to be an accident
07:44:24 <hiptobecubic> Peaker, why would I need a global undo? You mean if i were planning on just letting the installer shit all over the file system?
07:44:32 <hiptobecubic> i learned that lesson years ago
07:45:29 <matthiasgorgens> Has anybody heard of the package monad-peel?  monad-control claims it does the same job as monad-peel, but I haven't found monad-peel.
07:45:43 <applicative> its on hackage
07:45:59 <applicative> http://hackage.haskell.org/package/monad-peel
07:46:08 <Peaker> hiptobecubic, I was talking about C-w behavior surprising you
07:46:27 <Peaker> hiptobecubic, "C-w", <whoops>, "C-z",  <whew>
07:46:45 <hiptobecubic> Peaker, oh. Sure. but that's more rare than vim-bindings
07:46:57 <Peaker> hiptobecubic, what do you mean?
07:47:04 <hiptobecubic> normally it's only undo for trivial garbage, nothing you'd actually want it for
07:47:27 <matthiasgorgens> applicative: yeah, found it.  I should have looked there on my own, instead of just trying search engines.
07:48:07 <Peaker> hiptobecubic, yeah, a good "undo" is sorely missing in most programs, including emacs/vim which seem to have only buffer-local undos and not global undos
07:48:38 <applicative> matthiasgorgens: cabal list peel will also give you a little info
07:48:46 * hackagebot gencheck 0.1 - A testing framework inspired by QuickCheck and SmallCheck  http://hackage.haskell.org/package/gencheck-0.1 (JacquesCarette)
07:49:28 <hiptobecubic> Peaker, indeed.
07:49:49 <hiptobecubic> can someone tell me why this happens? http://vpaste.net/6n43b   clearly cabal knew about c2hs and where to get it
07:50:04 <applicative> the new `cabal-install` even makes coffee for you
07:50:42 <hiptobecubic> ah c2hs is an app and not a lib... i guess that's why?
07:50:44 <Peaker> hiptobecubic, cabal-install doesn't track executable installs, just lib installs
07:50:48 <hiptobecubic> for some reason we only get libs
07:51:04 <hiptobecubic> that seems like a pretty stupid and artificial limitation
07:51:05 <Peaker> I think it doesn't even track lib installs, ghc tracks lib installs
07:51:07 <applicative> cabal used to be unwilling to install executables like that, I thought it was different now
07:51:28 <Peaker> there's no database of what executables were installed, I think..
07:51:55 <hiptobecubic> but it knows it wasn't there, it checked $PATH and didn't find it.
07:52:01 <applicative> clearly cabal looked for c2hs, it uses  the usual method
07:52:09 <nand`> just a thought: how about a distinction between a “content undo” and a “meta undo” (or possibly other types), so you can for example easily undo closing a window/buffer/moving something/etc with the meta undo, whereas the content undo would be strictly for undoing text/content/image/whatever-related changes
07:52:25 <Peaker> hiptobecubic, I don't know if "cabal-install" checked $PATH or whatever package you're building has a build script to do it
07:52:32 <nand`> because I can imagine having a single undo button for both would be a huge pain
07:52:40 <hiptobecubic> nand`, would be pretty difficult to do the right book keeping there if they can invalidate each other
07:53:02 <nand`> for example say you change a color, then move a window because you can see it better that way, then decide the color was not a good change; but you want to keep the new layou
07:53:15 <Peaker> nand`, well, we currently only have a "global undo", which undos closing/opening of panes (our equivalent of windows).. and not the content undo.  A local undo is probably something we'll want to add too
07:53:40 <nand`> hiptobecubic: yeah, probably. I imagine it'd be highly dependent on what type of application you're considering
07:53:53 <nand`> ie. an IRC client surely has different semantics than a raster image editor
08:01:46 <applicative> Bayes.Examples.Tutorial: Tutorial explaining how to make infereces with the library.
08:02:27 <quicksilver> nand`: I don't think I've use a system which supports "meta-undo"; I suspect users would have a poor mental model of it and it would take time to adopt.
08:02:36 <quicksilver> we're also so used to undo being within a document.
08:03:39 <nand`> I don't think it'd be that bad, personally; I'm already finding myself often wishing I had it
08:03:55 <nand`> that thought alone means it wouldn't be lost on at least somebody
08:04:22 <applicative> data Coma = Present | Absent deriving  Bounded -- well that's good
08:05:45 <quicksilver> nand`: I think it's a natural idea but in the age of never-reading-manuals and things-should-just-work people rely a lot on intuiition from one program carrying over to another.
08:05:52 <quicksilver> nand`: changing paradigm is uphill.
08:06:04 <nand`> sucks for those users I guess
08:06:57 <nand`> I don't think programs should cater to people too lazy to read manuals (or at least help texts), but that's probably just bitterness on my part
08:08:01 <quicksilver> nand`: either bitterness or, just, lack of business sense :)
08:08:02 <matthiasgorgens> undo-trees also sound useful.
08:08:14 <matthiasgorgens> (but that's closer to a version control system with branching and merging.)
08:08:29 <quicksilver> nand`: (where withing "business sense" I also include the desire of a free software author to have his program widely used even though he's not making money)
08:08:37 <nand`> matthiasgorgens: never really heard of them; is it basically where a lot of small changes depend on an over-arching change, so if you undo the entire thing the sub-changes get undo'd too?
08:08:56 <quicksilver> matthiasgorgens: I believe recent versions of photoshop have moderately powerful undo history magic, but I've never used it so I don't speak from experience.
08:09:15 <quicksilver> I think you can do things like "take this version from this branch of the undo history and recreate it as a new layer now"
08:09:47 <nand`> quicksilver: that's out of phase with my software philosophy, which is “all development happens because somebody needs the result”, and if users don't like something they can modify it themselves (or pay somebody to do it for them)
08:09:58 <matthiasgorgens> nand`: with the undo-tree, I meant that when you undo, and then do something else, you can still go back to the original action.  (so not just a linear chain of actions, like with normal undo/redo.)
08:10:10 <nand`> wanting people to use your software, to me, sounds more like something a developer of proprietary software would think
08:10:13 <matthiasgorgens> nand`: but if you follow that idea around, you'll end up with version control.
08:10:28 <nand`> matthiasgorgens: ah, I understand now
08:10:41 <matthiasgorgens> nand`: some development happens because people like the development itself.
08:10:43 <nand`> matthiasgorgens: yes, version control is just glorified undo/redo
08:11:06 <matthiasgorgens> nand`: yes, though that's only one perspective to look at version control.
08:11:26 <nand`> in fact, I think version control does in fact make undo/redo obsolete. I encapsulate all of my small changes within commits then play around with those instead if I want to undo/redo
08:11:42 <nand`> (sophisticated undo/redo, mind; I still want the ability to un-shoot myself in the foot”
08:12:14 <matthiasgorgens> nand`: version control also (in an ideal world) comes with reasons (commit messages etc) to explain why we changed.  not only the changes / snapshots on their own.
08:12:35 <nand`> yes. version control is also designed for concurrent development, whereas undo/redo is not
08:12:49 <cschneid> program design question: As a learn-haskell project, I'd like to reimplement redis.  The read/response loop is easy enough, but where does the persistent data live in the system that represents the database?
08:13:17 <nand`> cschneid: what's “redis”?
08:13:32 <Luke> nand`: key-val data store
08:13:40 <Lemmih> cschneid: Use acid-state.
08:13:41 <cschneid> nand`: a nosql database. key/value + a bunch of other stuff.  I figure it touches network, data structures, and parsing, all of which are interesting things to learn
08:13:45 <bitonic> cschneid: do you want it to be persistent as well? that complicates things a bit.
08:13:45 <nand`> as for your question; barring IO you'd have to do the plumbing yourself. There are (powerful) tools that help you do this, but that's what they reduce to in teh end
08:13:47 <nand`> the*
08:14:13 <Lemmih> cschneid: I've heard good things about it and the author is a nice guy.
08:14:25 <nand`> (I assume this is a question along the lines of “how do I keep track of and modify a state in a referentially transparent program?”
08:15:02 <cschneid> nand`: yep. How to wire that in
08:15:32 <bitonic> cschneid: if you want to have it easy, use acid-state as Lemmih said.
08:15:39 <cschneid> ok - I'll look at that, thanks
08:15:52 <bitonic> cschneid: that will give you with something much more powerful then redis. but slower
08:16:16 <applicative> cschneid: or are you looking for something more simple, like some way to represent a bunch of keys and values
08:16:30 <bitonic> well, a lot of the speed depends on you. but you're probably never going to beat redis
08:16:50 <nand`> cschneid: the “simple approach” to stateful functions is usually to have types along the lines of State -> (Value, State) -- they accept a current state, and produce both a value and a modified state
08:16:57 <nand`> not sure what you're asking here or how new to haskell you are
08:17:06 <nand`> ideally you'd want something more specialized like what acid-state appears to be
08:17:18 <quicksilver> Lemmih: hmm. That's not what I heard about the author at all...
08:17:30 <bitonic> quicksilver: Salvatore is a really nice guy
08:17:39 <bitonic> at least he was nice to me
08:17:45 <Xavier__> yeah i do agree with you
08:17:45 <quicksilver> I was joking ;)
08:17:57 <bitonic> oh, ok :)
08:18:32 <cschneid> lets face it - it's never going to be faster :)
08:18:35 <bitonic> ah wait a sec. Lemmih was talking about acid-state :)
08:18:50 * nand` scratches head
08:18:53 <bitonic> they are very nice guys as well.
08:18:59 <nand`> but it says here acid-state is uploaded by lemmih
08:19:09 <nand`> oh, just maintained
08:19:18 <bitonic> nand`: no no. he wrote the whole thing
08:19:26 <cschneid> I'm asking more of a general program-design question of how to maintain a large data structure in memory between invocations of my run loop.  One option is just recursivly calling my runloop with the current-data as an arg.
08:19:32 <cschneid> other is look at this acid-state thingy
08:19:54 <matthiasgorgens> cschneid: you could also have a look at how the xmonad guys keep their state around.
08:19:57 <bitonic> cschneid: `loop :: Data -> IO Data'
08:20:04 <nand`> cschneid: what are you hoping to achieve? a real-world program or a “proof of concept stateful application”?
08:20:14 <cschneid> nand`: using this as a learning exercise.
08:20:30 <bitonic> cschneid: `program :: Data -> IO; program data = loop data >>= program'
08:20:37 <matthiasgorgens> xmonad is `industrial strength', but still quite simple.
08:20:41 <bitonic> I meant :: Data -> IO ()'.
08:20:57 <shapr> I'm using xmonad RIGHT NOW!
08:20:57 <matthiasgorgens> bitonic: you might even use :: Data -> IO a
08:20:59 <nand`> me too
08:21:05 <bitonic> matthiasgorgens: but is it... enterprise ready? buzzword compliant?
08:21:05 <Xavier__> what are you guys talking about?
08:21:15 <shapr> bitonic: Its zippers stay zipped.
08:21:16 <nand`> how does xmonad lobby its state around? I mean they have their own monad and all, but does it use StateT or something different?
08:21:17 <cschneid> I'll grab the xmonad source - sounds like a very good thing for me to be reading :)
08:21:19 <matthiasgorgens> bitonic: I'm working in an enterprise, so it's enterprise ready. :o)
08:21:31 <bitonic> matthiasgorgens: if you want to confuse people, yes.
08:21:34 <matthiasgorgens> cschneid: also read the blog posts about "how to roll your own windowmanager".
08:21:45 <bitonic> shapr: ehe.
08:21:46 <matthiasgorgens> they explain some xmonad stuff.
08:21:52 <cschneid> matthiasgorgens: googled :)
08:21:56 <matthiasgorgens> cschneid: http://donsbot.wordpress.com/2007/05/01/roll-your-own-window-manager-part-1-defining-and-testing-a-model/
08:22:01 <matthiasgorgens> and http://donsbot.wordpress.com/2007/05/17/roll-your-own-window-manager-tracking-focus-with-a-zipper/
08:22:10 <matthiasgorgens> there might be more than those two.
08:22:35 <bitonic> cschneid: you definitely don't need to know xmonad internals to do a dumb redis clone. it might still be interesting
08:22:49 <matthiasgorgens> nand`: I don't remember, if they use StateT, but I know that they do marshall their state between recompilations of the program via the command-line.
08:22:57 <matthiasgorgens> bitonic: indeed.
08:23:24 <cschneid> bitonic: sure. I'm trying to do the simplest thing possible, and then refactor it to be faster/more interesting/more complete. But always as a learning tool, never as a 'real project'.  The actual redis does a damn good job of that :)
08:24:18 <cschneid> simplest is just passing the current state of the db between calls of my runloop it seems. Then add on from there
08:24:24 <bitonic> cschneid: then simply create you're loop by writing a "stepping" function and then running that forever with some initial value.
08:24:34 <fmap> Is there a concise way to write a function ∷ Integer → [Word8] that converts integer to a sequence of bytes representing it, where `\x → map (read . ("0x" ++)) $ splitEvery 2 $ printf "%X" x' is not concise?
08:24:35 <nand`> matthiasgorgens: yeah, with amusing results in ‘top’ or ‘ps’ :)
08:25:06 <osa1> I'm reading GADT introduction here: http://en.wikibooks.org/wiki/Haskell/GADT and I'm wondering is there a way to parse some string to AST defined with GADTs in this page. because expression parser needs to return different types depending on input (ie "1" should return Expr Int and "False" should return Expr Bool)
08:25:24 <nand`> what I really, really, really like about xmonad: its configuration file is the actual program; no need for a “scripting system” when you can just modify the program semantics directly. xmonad is not an application, it's like a sophisticated API
08:25:25 <bitonic> fmap: how about Binary + unpack?
08:25:49 <matthiasgorgens> nand`: it's a bit like emacs. :o)
08:26:02 <nand`> matthiasgorgens: no comment, never used emacs
08:26:32 <bitonic> > unpack $ encode (42 :: Integer)
08:26:34 <lambdabot>   Not in scope: `encode'
08:26:47 <bitonic> > unpack $ Binary.encode (42 :: Integer)
08:26:49 <lambdabot>   Not in scope: `Binary.encode'
08:26:54 <bitonic> @hoogle encode
08:26:55 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
08:26:56 <lambdabot> package Encode
08:26:56 <lambdabot> GHC.IO.Encoding.Types encode :: BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to)
08:27:00 <matthiasgorgens> nand`: although only in a very broad philosophical sense, in that the emacs configuration files are also written in emacs-lisp.
08:27:08 <nand`> osa1: maybe you could get away with a large coproduct type, no idea though
08:27:27 <nand`> matthiasgorgens: right; but emacs-lisp ≠ haskell :)
08:27:42 <nand`> to clarify: I like the fact that xmonad's configuration is a *Haskell* program
08:27:53 <osa1> nand`: I'm new at this stuff, what is coproduct type?
08:28:10 <nand`> osa1: “Either a b” is a coproduct of a and b if I'm not mistaken
08:28:22 <bitonic> fmap: `unpack . encode' might work, depending on what you want - it'll simply serialise the Integer to a blob (so it'll include the tag, etc.). Otherwise I'd fiddle with Data.Bits
08:28:57 <osa1> nand`: well, I have 10 types of nodes in my syntax tree
08:30:00 <matthiasgorgens> nand`: oh, yes, emacs is written in emacs-lisp, not haskell.
08:30:15 <matthiasgorgens> and yes, haskell is nicer than emacs-lisp.
08:31:33 <bitonic> nand`: why wouldn't you simply say "sum" :P?
08:31:33 <fmap> bitonic: oh, nice, I've forgot about binary package.
08:32:28 <nand`> bitonic: I wasn't sure whether ‘sum’ was product or coproduct. I confuse these things :P
08:32:38 <nand`> thinking back, it's obvious
08:33:03 <nand`> osa1: yeah, that's probably unfortunate. I don't really know of a better way to do it
08:40:59 <realitygrill> Show	how the single comprehension [(x,y) | x <- [1,2,3], y <- [4,5,6]] with two generators can be re-expressed using two comprehensions with single generators. Hint: make use of the library function concat and nest one comprehension within the other.
08:41:18 <realitygrill> I.. don't see how to do this at all, and have no idea why concat would help
08:41:39 <realitygrill> doing 'concat [[1,2,3],[4,5,6]]' seems pointless?
08:41:54 <Botje> realitygrill: the 'nest one comprehension within the other' is the better hint
08:41:55 <bitonic> realitygrill: well, check if the result is the same
08:42:27 <realitygrill> well, i know it should be (1,4),(1,5), etc - combinations
08:42:38 <realitygrill> Botje: ok, i'll try some more
08:43:01 <bitonic> realitygrill: ok, how about the `concat ...' you proposed? also, you should really experiment with ghci (or hugs).
08:43:35 <realitygrill> bitonic: yeah, it doesn't give the right result - i was going to embed that in a list comprehension and then.. re-split them
08:43:38 <realitygrill> lame
08:44:28 <bitonic> ok, so what you want to do here is get each element of the first list and pair it with each element of the second, right?
08:44:39 <realitygrill> yup
08:44:58 <realitygrill> so.. the outer comprehension must do that somehow
08:45:45 <bitonic> realitygrill: yeah, start by writing [ ... | x <- [1,2,3]] and then try to fill the hole.
08:46:15 <astropirate> Greetings all
08:46:31 <astropirate> Do people use Haskell for web dev much?
08:46:37 <shapr> yes
08:46:38 <bitonic> astropirate: increasingly, yes
08:46:59 <Botje> 100% of Haskell web developers user Haskell for web development.
08:47:02 <shapr> haha
08:47:03 <astropirate> I come from a PHP/Node.js background but am looking to learn a new language but still stay in webdev
08:47:08 <astropirate> lol
08:47:19 <shapr> astropirate: https://github.com/shapr/ghclive
08:47:31 <bitonic> @faq can Haskell teach you a new language while staying in webdev?
08:47:31 <lambdabot> The answer is: Yes! Haskell can do that.
08:47:35 <bitonic> astropirate: ^^^
08:47:40 <nand`> astropirate: there are a number of haskell web frameworks with surprising popularity
08:47:47 <bitonic> astropirate: it's your lucky day
08:48:09 <astropirate> :)
08:48:11 <sp3ctum> @faq can Haskell be used to implement this algorithm? https://en.wikipedia.org/wiki/Cox-Zucker_machine
08:48:11 <lambdabot> The answer is: Yes! Haskell can do that.
08:48:12 <realitygrill> bitonic: Botje: well, [[(x,y)| y <- [4,5,6]]|x<-[1,2,3]] worked. not that it uses concat at all.
08:48:12 <shapr> astropirate: What sort of webapps do you mostly do?
08:48:25 <Botje> realitygrill: it's also the wrong type.
08:48:32 <shapr> astropirate: you could try http://clckwrks.com/
08:48:33 <Botje> it's [[(Int, Int)]] or something.
08:48:40 <Botje> :t [[(x,y)| y <- [4,5,6]]|x<-[1,2,3]]
08:48:42 <lambdabot> forall t t1. (Num t, Num t1) => [[(t, t1)]]
08:48:49 <Botje> so not the type your original expression had :)
08:48:51 <realitygrill> oh you're right
08:48:53 <realitygrill> AHHHHHH
08:48:54 <bitonic> realitygrill: you're close
08:48:54 <nand`> sp3ctum: the correct answer is “Yes, you just don't know enough mathematics to do so”
08:49:02 <bitonic> realitygrill: you have to use the other hint now
08:49:16 <astropirate> shapr: well I have to learn haskell first :p
08:49:17 <realitygrill> lol got it
08:49:25 <sp3ctum> nand`, of course :) i'm in the group of programmers that simply chuckle at the name
08:49:28 <shapr> astropirate: Oh that's a good point!
08:49:39 <astropirate> Is there any market for freelance Haskell devs?
08:49:41 <shapr> astropirate: Will you start with one of the free online books?
08:49:50 <realitygrill> now why does it.. ah ok. i see.
08:49:55 <astropirate> i'm starting with http://learnyouahaskell.com
08:49:56 <Clint> there is, especially ones that work for free
08:50:06 <nand`> sp3ctum: unfortunately my brain turned off halfway through the second sentence of that wikipedia article :(
08:50:06 <bitonic> realitygrill: good job!
08:50:06 <shapr> astropirate: Yes, but there are more PHP and Ruby jobs at the moment.
08:50:06 <realitygrill> astropirate: it's fun
08:50:23 <bitonic> astropirate: what are jobs compared to enlightenment.
08:50:33 <astropirate> bitonic: food and dental care XD
08:50:36 <nand`> “market for freelance Haskell devs” <- I wish :(
08:50:43 <shapr> There really is
08:50:45 <bitonic> astropirate: also, people will think you're smart.
08:50:50 <astropirate> lol
08:50:56 <tac-tics> More like "Market for freelance programmers who their boss won't even know it's haskell"
08:50:59 <nand`> until they learn Haskell too
08:51:01 <nand`> then they'll think you're human
08:51:02 <shapr> nand`: You just have to convince well-typed that you are worth hiring!
08:51:07 <bitonic> astropirate: with no food you need no dental care ;)
08:51:14 <sp3ctum> lol
08:51:17 <astropirate> haha true
08:51:18 <shapr> ouch
08:51:19 <nand`> shapr: http://ro-che.info/ccc/11.html
08:51:24 <nand`> ^ why nobody hires HAskell programmers
08:51:35 <realitygrill> lol
08:51:38 <bitonic> nand`: they hire me
08:51:38 <shapr> ha
08:51:43 <realitygrill> i wish ppl hired for haskell..
08:52:00 <shapr> But they do!
08:52:04 <bitonic> realitygrill, everyone: they do, even if the job does not require Haskell
08:52:19 <astropirate> I think they will more if people do applications like Drupal, Wordpress etc in Haskell
08:52:26 <shapr> I had a real Haskell webdev job for almost two years... I got various bits of contract Haskell work when I was self-employed...
08:52:30 <quicksilver> shapr: is a beard still required do you know?
08:52:38 <shapr> and right now I'm getting paid to write Haskell webdev stuff for Google Summer of Code
08:52:50 <shapr> quicksilver: I was only able to grow a beard in the past year or so.
08:52:54 <shapr> Thus, I suspect not
08:52:59 <sp3ctum> astropirate, that is a very good book. after that i read learn you a haskell and the haskell wikibook, you might enjoy them too.
08:54:03 <astropirate> ohh man this is going to kick my butt, but I shall attempt to learn some haskell XD
08:54:14 <shapr> astropirate: It's EXCITING!
08:54:15 <nand`> re: that comic I linked, I'm not sure if I understand the joke. Is the “his strictness analyser is broken” joke referring to the fact that he didn't force Haskell knowledge before applying to the review, or the fact that he decided to learn Haskell just to answer a “yes/no” question?
08:54:33 <nand`> astropirate: it's enlightening
08:54:43 <shapr> nand`: I think the first, but the second is nerdier.
08:55:00 <bitonic> nand`: that comic is not that funny.
08:55:11 <sp3ctum> astropirate, that very decision must have been the most rewarding of my programming career/hobby. i wish you fun times :)
08:55:32 <astropirate> :) thanks all for help
08:55:34 <tac-tics> I learned haskell once. Now I hate PHP that much more.
08:55:39 * tac-tics continues doing his PHP job.
08:55:50 <astropirate> ohh no will this ruin me for other languages? :(
08:55:54 <astropirate> lol
08:56:09 <Clint> only if you're lucky
08:56:13 <Refried__> astropirate: if you stick with it yes
08:56:17 <tac-tics> Imagine sitting in the world's most comfortable chair
08:56:19 <nand`> astropirate: depends on how much you get into haskell
08:56:20 <Nimatek> You'll get better at other languages, but you'll hate it.
08:56:23 <bitonic> astropirate: also, Haskell will give you a comfortable sense of superiority towards other languages and their users.
08:56:25 <tac-tics> Then for the rest of your life, you have to sit on rocks.
08:56:33 <sp3ctum> astropirate, one more thing, perhaps after learn you a haskell, you might find these exercises rewarding: (i did) http://www.haskell.org/haskellwiki/99_Haskell_exercises
08:56:34 <bitonic> astropirate: as you can see in this channel
08:56:39 <Refried__> astropirate: for me it made me hate other languages, and i'm not even competent in this one yet
08:56:41 <tac-tics> bitonic: (that's the most important feature)
08:56:51 <nand`> astropirate: haskell's learning curve is a bit oddly shaped: http://www.haskell.org/haskellwiki/Humor/LearningCurve
08:57:15 <astropirate> LOLOLOL
08:57:26 <nand`> astropirate: it will progress from “weird” to “even more weird” to “perfect, how did anything else ever make sense”?
08:57:29 <nand`> ?”*
08:57:29 <lambdabot> Unknown command, try @list
08:57:51 <nand`> (also take anything I say with a grain of salt, I'm prone to silliness)
08:58:22 <sp3ctum> i consider that a good thing for myself (as well, i presume) :3
08:59:22 <Cheery> back.
08:59:25 <nand`> I forgot what loops are, and now if I write code in an imperative language it tends to feature lots of lambdas, tail call recursion and make-pretend “pattern matching” by method of if/switch
09:00:18 <shapr> Yah, what's up with those loop things? They're always off by one anyway.
09:00:27 <Cheery> nand`: I think the real benefit in structural editing is that it avoids the limitations in text syntax. therefore switching between representations would be pointless.. think about having five or more languages in single file.
09:00:30 <nand`> astropirate: oh, if you get into Haskell's theory you will start seeing functors, monads and friends *everywhere*. The other languages just dress them up with pretty names
09:00:47 * applicative 's folds are always off  by one
09:00:49 <tech2> nand`: I imagine that could end badly on some languages, esp. those dynamic ones with a limited call-stack? :)
09:00:57 <nand`> tech2: you bet
09:01:13 <nand`> tech2: also treating strings as lists of characters in languages where “tail” requires a reallocation
09:01:39 <matthiasgorgens> nand`: you mean like New-Lisp.
09:02:08 <tech2> nand`: I'd hate to be the guy exposed to imperative code written by you. I expect much head scratching follows.
09:02:28 <sp3ctum> i started avoiding for/foreach loops, not sure how my co-workers feel about it
09:02:32 <nand`> Cheery: the problem with “structural editing” is in how well it's implemented, re: the “requiring correctness” comment earlier. It might be cumbersome to transform a structurally presented code into what you actually want if you can't simply mangle it halfway through
09:02:57 <armlesshobo> haha for-loops
09:02:58 <nand`> eg. if your representation uses an abstract syntax tree whose values must by definition be correct
09:03:22 <nand`> tech2: yeah, you don't want to see the amount of puzzlement a Y combinator usually invokes
09:03:35 <Cheery> quicksilver: I think of structural editing as a sort of all-or-nothing -situation.
09:04:25 <astropirate> Alas I will be able to configure xmonad MUAHAHAH
09:04:47 <bitonic> astropirate: or you could simply use i3
09:04:50 * bitonic ducks
09:04:55 <Cheery> nand`: yeah. I could see that in the last version.
09:05:12 <Cheery> bitonic: and I think you're right. many of the things promised by structural editing has been done in text alreadye.
09:05:23 <Cheery> even the additional-visualizations -thing.
09:05:23 <realitygrill> ghci-live looks interesting
09:05:29 <bitonic> Cheery: oh. that was quick.
09:05:58 <Cheery> bitonic: pjb shown me some things while ago. :)
09:06:08 <Cheery> bitonic: and don't get me wrong, I'm still pursuing structural editing
09:06:19 <Cheery> there's one simple really nice benefit
09:06:48 <Cheery> having lisp-like languages without lisp-like syntax and unreadability
09:06:57 <bitonic> but for me stuff like paredit, which aids in composing text, is structural editing
09:06:59 <Cheery> and multiple languages by once.
09:07:20 <nand`> for-loops are just a glorified combination of intersperse, takeWhile and sequence
09:07:24 <Cheery> bitonic: it probably matches the definiton
09:07:27 <Cheery> *definition
09:07:34 <bitonic> Cheery: the readability "problem" in lisp is just about getting used to the unusual syntax, in my experience. but that's a completely different discussion
09:07:35 <realitygrill> i'm prob going to hate other languages
09:07:52 <Cheery> what I look for is editing programs that are encoded as trees in the system, that they are easy for computer to process.
09:07:56 <bitonic> realitygrill: that does not happen to everyone. I love a lot of languages :)
09:08:22 <realitygrill> bitonic: oh yay, which?
09:08:28 <bitonic> Cheery: well, I think that the main thing should be to aid the user, not the computer
09:08:41 <Cheery> bitonic: yeah, but say with the visualizer I'm doing, you could get the lisp look *better* than the half-assed algebraic languages we have today
09:09:07 <Cheery> bitonic: it boils into helping user in the end, by helping computer to do more things with code.
09:09:11 <bitonic> realitygrill: C, Erlang, Scheme, I am emotionally attached to Python and JavaScript too
09:09:14 <Cheery> and by helping at making tools.
09:09:17 <nand`> I'd be a huge fan of structural processors, ie. VCS, editor modes / helpers, stuff like hlint; but I'm very wary of actual structural *editors*
09:09:31 <bitonic> Cheery: ok :)
09:09:47 <applicative> do many 'structural editors' exist?
09:10:02 <nand`> I don't know, I've mainly seen proof of concept type things so far
09:10:09 <Cheery> applicative: there's been research before, and once in a while there's some results.
09:10:09 <mcstar> i tried to build this bottle, but it needs berkeleydb, which fails to install
09:10:09 <bitonic> applicative: Paredit is an emacs mode to structurally edit lisp
09:10:11 <nand`> nothing really widespread or capable of replacing vim/emacs/foo
09:10:21 <quicksilver> one of the issues with Peaker's vision - and he's making impressive progress - is that he is changing a lot of things at once.
09:10:36 <quicksilver> I can understand why because they're all interdependent, but it is rather ambitious
09:10:38 <Cheery> quicksilver: I have really same issue.. it's a huge design burden
09:10:54 <Cheery> I mean.. layouting, and document model in same is already big thing.
09:11:02 <Cheery> oh and interpreting that document model. :)
09:11:11 <quicksilver> a new edit/run/debug cycle, a new editing style, a new presentation style, a new document storage / saving paradigm, a new VCS
09:11:47 <Cheery> I somehow manage because I've got dynamic programming languages and I know how to use them to skip huge amount of work that should be actually done for production software.
09:12:18 <mcstar> http://sprunge.us/QbHb
09:12:29 <nand`> here's another thing I would find interesting: a structural file type + editor that is capable of moving around functions in your front-end; eg. you can pull up functions ‘f’ and ‘g’ side by side to edit them both; without having to do any actual text file cosmetic surgery
09:12:31 <Cheery> quicksilver: I try keep as much from vim/emacs -style in editing.. but yes. that's an another bag of worms.. and influences heavily the document and layouting design.
09:12:42 <nand`> (but the actual, isolated function blocks are still Haskell syntax)
09:12:54 <realitygrill> hmm i'm looking for an open source project to aim at contributing to
09:13:16 <realitygrill> anyone have ideas? (i'll prob try reading xmonad, but prob need something easier?)
09:13:17 <Cheery> realitygrill: the essential editor research project is GPLv3
09:13:21 <Cheery> :P
09:13:38 <Clint> realitygrill: i suggest the gitit rewrite or hledger-*
09:13:48 <bitonic> realitygrill: xmonad-contrib is actually quite nice to hack on, if you have some ideas
09:13:49 * hackagebot snap-extras 0.1.7 - A collection of useful helpers and utilities for Snap web applications.  http://hackage.haskell.org/package/snap-extras-0.1.7 (OzgunAtaman)
09:14:16 <nand`> realitygrill: there are lots of open source projects you can contribute to, is there anything that could narrow it down?
09:14:36 <nand`> I mean, you can always contribute to my school project if you like, which is open source. I wouldn't mind that :)
09:14:36 <realitygrill> nand`: not really. i guess i can just search around in hackage
09:14:54 <realitygrill> hah. what's that?
09:15:15 <nand`> proof of concept p2p chat-type application that uses an interconnected ring network
09:15:44 <Clint> what kind of ring?
09:15:53 <sp3ctum> is there an easy way to get xmonad workign in ubuntu 12.04 ? i tried for 11.xx but couldn't get it running / don't remember what
09:16:08 <bitonic> sp3ctum: cabal install xmonad?
09:16:17 <bitonic> sp3ctum: or, apt-get install xmonad.
09:16:28 <mcstar> any ideas wrt berkeleydb?
09:16:29 <nand`> Clint: not a ring in the mathematical sense, just a series of connected nodes that each have an assigned address (between 0 and 1), in sorted order
09:17:00 <sp3ctum> bitonic, i'm looking for a solution that would let me keep the gnome-panel
09:17:05 <Clint> nand`: the addresses are assigned by consensus?
09:17:24 <bitonic> sp3ctum: check gnomeConfig
09:17:34 <Clint> in xmonad-contrib
09:17:42 <merijn> Cheery: ahahaha
09:17:45 <bitonic> mcstar: "Tested with libdb4.6 " should give an hint about what to do
09:17:57 <bitonic> (from the package page)
09:18:04 <sp3ctum> thanks, i will
09:18:07 <nand`> Clint: the addresses are randomly assigned and a DHT is used to correlate peers with their addresses
09:18:12 <merijn> Cheery: Implying that production software has any sort of qualification implying extra work
09:18:15 <bitonic> assuming that that's your problem
09:18:17 <Cheery> merijn: find it funny to call it essential? ^^
09:18:33 <tgeeky> in this paper: http://takeichi.ipl-lab.org/pub/PLDI2007.pdf   -- and a few others like it (by the same authors)   --  they use psuedo-Haskell definitions like   "mps (x ++ y)" and "mps (x ++ [b])".  Is there an obvious way of pattern matching these things? Or does it imply I need to deal with a type like:  mps (Append x y)  ?
09:18:34 <Clint> nand`: cool, when's it gonna be done?
09:18:36 <Cheery> merijn: actually they do.
09:19:06 <nand`> Clint: it technically already is, just lacking an actual user interface. Also, it's probably still very buggy. I haven't tested it for more than 10 simultaneous peers either.
09:19:20 <applicative> mcstar: Peaker said it requires an older version of the Berkeley DB system.  I managed to install it on  mac by hacking the homebrew file
09:19:24 <nand`> https://github.com/nandykins/p2p-chat <- I won't be continuing development though, the school project it was for is now complete so I lost interest :(
09:19:27 <merijn> Cheery: I've done system administration for long enough to have seen a significant amount of "production software" of the "if this breaks we lose money variety". A lot of it is just depressing
09:19:27 <nand`> (warning: very ugly code)
09:19:28 <Cheery> merijn: get this: in designing something it's good to get a sort of cambrian explosion in your code
09:19:57 <Cheery> because of that the solutions used need to be quick, and can be bit sloppy
09:19:58 <merijn> Cheery: You're naive if you think production software is better quality than that initial cambrian explosion :p
09:20:04 <Cheery> XD
09:20:09 <Cheery> merijn: ah that way around
09:20:13 <Clint> nand`: thanks
09:20:48 <astropirate> Why is every example of haskell based web app being used via CGI with Apache, can one not write a http server in haskell?
09:20:56 <nand`> astropirate: huh?
09:20:59 <bitonic> astropirate: it's not
09:21:00 <mcstar> bitonic: applicative thanks
09:21:02 <nand`> I didn't know people use CGI or Apache for Haskell
09:21:09 <bitonic> @google happstack crash course
09:21:12 <lambdabot> http://happstack.com/docs/crashcourse/index.html
09:21:12 <lambdabot> Title: Crash Course in Happstack
09:21:12 <bitonic> astropirate: ^^^
09:21:20 <nand`> astropirate: all of the haskell web frameworks I know have their own servers (or other servers written in Haskell)
09:21:21 <astropirate> tnx
09:21:23 <nand`> examples snap, happstack, yesod
09:21:30 <applicative> mcstar: the one I installed was Berkeley DB 4.8.30.tar.gz,  from here http://www.oracle.com/technetwork/products/berkeleydb/downloads/index-082944.html I just hacked the brewfile...
09:21:41 <applicative> to download it instead
09:22:00 <bitonic> m
09:22:26 <bitonic> mcstar: if you use a better OS (read: linux) your distribution probably includes libdb somewhere
09:22:47 <mcstar> unfortunately im on BeOS
09:22:55 <applicative> haha
09:23:14 <bitonic> mcstar: no you're not
09:23:19 <John> Technicus:
09:23:24 <John> Please change your password
09:23:33 <stepcut> BeOS is awesome
09:23:37 <mcstar> db 5.3.21-1 thats what ive got, so its too new according to applicative
09:23:44 <stepcut> I wrote an irc-client for BeOS once
09:23:44 <jfischoff> can criterion print a memory report?
09:23:46 <mcstar> bitonic: ofc im not
09:23:53 <nand`> Clint: also keep in mind this was my first experience with concurrency, parsing or networking in Haskell, so lots of the code is of the “throwaway project full of mistakes to avoid in the future” type; the code can be prone to dead locks and race conditions
09:24:03 <nand`> I didn't want to share it :(
09:24:09 <Clint> nand`: aww
09:25:40 <John> harsh
09:28:48 <lysgaard> What would it take to let Haskell infer $ filter (<=4) [1..] == [1,2,3]
09:28:53 <lysgaard> Is this called something?
09:29:42 <fmap> takeWhile
09:29:42 <quicksilver> lysgaard: it would take a lot.
09:29:54 <nand`> no idea, but something like that could probably be done with fairly specific rewrite rules involving Enum assumptions
09:29:57 <quicksilver> lysgaard: it would need to understand that (<=) is monotonic decreasing on [1..]
09:30:08 <quicksilver> lysgaard: that is, once it becomes false it never becomes true again.
09:30:28 <teaurchin> how can I catch an exception in pure code like this: Foo 1 (throw DivideByZero), where Foo is some data constructor made by me
09:30:35 <quicksilver> which is a 'global' property of [1..]
09:30:39 <nand`> quicksilver: isn't ≤ transitive by definition?
09:30:56 <quicksilver> which is incompatible with haskell's semantics of infinite lists.
09:31:08 <quicksilver> nand`: the issue is not the properties of <=, which are fine
09:31:13 <quicksilver> nand`: it's the properties of [1..]
09:31:22 <quicksilver> (that it increases, basically)
09:31:55 <nand`> quicksilver: well, [1..] is defined in terms of ‘succ’, isn't there a law that states x ≤ succ x ?
09:32:22 <nand`> (at least I think [1..] is defined in terms of succ)
09:32:33 <quicksilver> yes.
09:32:42 <quicksilver> it is not problematic to prove this as a mathematician
09:32:45 <quicksilver> I'm sure you realise that
09:32:51 <nand`> like I said, something that involves Enum assumptions and fairly specific rewrite rules could do such a thing
09:32:52 <quicksilver> the point is the language can't *possibly* prove it
09:33:07 <quicksilver> because it violates assumptions about how infinite lists are modelled
09:33:15 <nand`> oh, I see your point - you mean proving it in general, not by using pre-programmed rewrite rules
09:33:37 <quicksilver> you can't have global properties associated with general infinite lists
09:33:50 * hackagebot random-shuffle 0.0.4 - Random shuffle implementation.  http://hackage.haskell.org/package/random-shuffle-0.0.4 (PatrickPalka)
09:34:03 <quicksilver> you can move away from a general infinite list to a more 'explicit' construction
09:34:16 <quicksilver> like data Enum = FromEnum Int Int Int
09:34:25 <quicksilver> and then you'd be able to do it in a more reasonable way within the language.
09:35:12 <nand`> here's another one to think about: even with GHC knowing that [1..] is defined in terms of ‘succ’ iteration, what about something general like fix ((1:) . map (+1))
09:35:52 <quicksilver> that is exaclty the point, nand`
09:36:02 <quicksilver> thanks for making it more clearly :)
09:36:06 <quicksilver> "fix ((1:) . map (+1))
09:36:16 <quicksilver> "fix ((1:) . map (+1))" *is* the same as [1..]
09:36:21 <quicksilver> the semantics of haskell guarantee it is the same
09:36:32 <daniel_-> @src eq
09:36:33 <lambdabot> Source not found. You speak an infinite deal of nothing
09:36:36 <quicksilver> so any sensible optimisation which worked on the second ought to work on the first
09:36:39 <quicksilver> but, as you can see, it's not possible.
09:36:43 <nand`> quicksilver: ..assuming non-broken Enum/Num instances
09:36:47 <quicksilver> right
09:36:57 <quicksilver> assuming the standard instances on Integer
09:36:58 <quicksilver> (say)
09:37:04 <nand`> hmm, I was thinking about this the other day
09:37:20 <daniel_-> what is eq?
09:37:29 <nand`> does GHC shy away from transformations that could break on, say, monad instances that don't follow the laws?
09:37:39 <nand`> daniel_-: ‘eq’ is a name, technically. You mean ‘Eq’?
09:37:47 <daniel_-> no i mean eq
09:37:51 <nand`> oh
09:38:10 <nand`> my bad; I don't have it in my Prelude. Where did you see it?
09:38:15 <nand`> :t eq
09:38:17 <lambdabot> Not in scope: `eq'
09:38:21 <quicksilver> nand`: I don't think it's ever come up.
09:38:30 <quicksilver> nand`: GHC shies away from instances that break the semantics of haskell, though
09:38:35 <lysgaard> quicksilver: I'm not shure if i followed you. What 'global properties'. Is this some assumtions that GHC can infer from a set of axims?
09:38:52 <daniel_-> yesterday i asked about finding if a list was only composed of unique things and you pros come up with the solution isUnique = (==) <*> nub
09:38:56 <daniel_-> which im trying to understand
09:39:05 <quicksilver> lysgaard: basically, to do that transformation you need to know something about "all" the elements in the list
09:39:21 <quicksilver> lysgaard: whereas all real haskell programs cannot assume what the billionth element is without calculating it
09:39:37 <daniel_-> and eq was in the source for nub in Data.List
09:39:39 <quicksilver> so no program can do something which assumes what all the elements are - because that would take forever.
09:40:23 <nand`> daniel_-: you mean nubBy? that one has ‘eq’ as local parameter
09:40:31 <daniel_-> ohhhhhhhhhhhhhhhhhhhh
09:40:39 <nand`> it's the comparison function :P
09:41:34 <lysgaard> quicksilver: True, but why can't knowledge about the generating funcion of the infinite list tell us that it monotonically increasing?
09:42:24 <lysgaard> quicksilver: Or is the ploblem rather that haskell has no way of inferring that property. It seems so simple from a naive mathematical standpoint.
09:42:25 <nand`> > [ maxBound - 2 :: Int ..]
09:42:26 <lambdabot>   [9223372036854775805,9223372036854775806,9223372036854775807]
09:42:58 <mauke> > iterate succ (maxBound :: Int)
09:43:00 <lambdabot>   [9223372036854775807,*Exception: Prelude.Enum.succ{Int}: tried to take `suc...
09:43:06 <MostAwesomeDude> lysgaard: Haskell isn't the right venue for this sort of thing; you might want to look into languages meant specifically for proving.
09:43:07 <nand`> heh
09:43:07 <mauke> > iterate (1+) (maxBound :: Int)
09:43:08 <lambdabot>   [9223372036854775807,-9223372036854775808,-9223372036854775807,-92233720368...
09:43:25 <nand`> mauke: re: “Broken Num instances”..
09:44:09 <nand`> but yeah, I hadn't even considered that one. enumFrom is not an infinite list for bounded types.
09:44:17 <nand`> [False ..]
09:44:24 <nand`> > [False ..]
09:44:25 <lambdabot>   [False,True]
09:45:27 <nand`> > takeWhile (< maxBound) . iterate succ $ maxBound - 1 :: [Int]
09:45:29 <lambdabot>   [9223372036854775806]
09:45:49 <nand`> oh, not quite the same thing
09:48:46 <teaurchin> @type Control.Exception.catch
09:48:47 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
09:48:51 * hackagebot unfoldable 0.6.0.2 - Class of data structures that can be unfolded.  http://hackage.haskell.org/package/unfoldable-0.6.0.2 (SjoerdVisscher)
09:48:59 <teaurchin> is there a version of catch where the first parameter is just 'a' ?
09:49:24 <mekeor> teaurchin: why not just use "return"?
09:49:43 <teaurchin> mekeor: I'm trying to catch an exception in pure code
09:50:19 <mekeor> teaurchin: you should use Either for such things actually…
09:50:27 <nand`> teaurchin: do you want to get rid of the ‘IO’ at the end?
09:50:28 <mekeor> @hoogle (GHC.Exception.Exception e) => a -> (e -> IO a) -> IO a
09:50:28 <lambdabot> Parse error:
09:50:28 <lambdabot>   (GHC.Exception.Exception e) => a -> (e -> IO a) -> IO a
09:50:28 <lambdabot>       ^
09:50:40 <teaurchin> nand`: no
09:50:55 <nand`> @type Control.Exception.catch . return
09:50:56 <lambdabot> forall a e. (GHC.Exception.Exception e) => a -> (e -> IO a) -> IO a
09:51:32 <nand`> then I don't see what's wrong about mekeor's suggestion
09:52:08 <mcstar> @src duct tape
09:52:09 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:53:19 <teaurchin> why is Either better than throwing exceptions?
09:53:35 <Peaker> teaurchin, what kind of exceptions?
09:53:39 <navaati> teaurchin: because exceptions are a IO thing
09:54:05 <Peaker> teaurchin, Either has simple semantics.. pure exceptions have horrible semantics. IO exceptions require IO to work with, and aren't checked..
09:54:06 <navaati> and it means your functions are partial
09:54:16 <teaurchin> so what is the point of 'throw' then? why not only have 'throwIO' ?
09:54:26 <Peaker> Control.Exception.throw ?
09:54:40 <teaurchin> yes
09:54:52 <Peaker> pure exceptions are still useful in a partial language like Haskell
09:55:10 <Peaker> so "throw" is just a more elaborate variant of "error"
09:55:11 <navaati> because sometimes some people like to throw exception from pure code, but Either should be preferred
09:55:37 <mekeor> keeping as much things as possible pure is best.
09:56:17 <teaurchin> is it possible to catch this kind of exception: (1, throw DivideByZero) ?
09:56:32 <mcstar> i read yesterday CPS can be used for exceptions
09:56:37 <mcstar> i.e. catchable ones
09:57:45 <teaurchin> I want to say something like (psuedocode):  (1, throw DivideByZero) `catch` (\_ -> print "oops!") and have oops! be printed
09:58:09 <daniel_-> would someone mind helping me understand " (==) <*> nub " i know nub deletes duplicates but how does (==) get applied to nub?
09:58:30 <parcs`> (==) <*> nub = \a -> a == nub a
09:58:36 <c_wraith> teaurchin: it's possible to catch it sure. It's more difficult to make it actually be thrown
09:58:37 <rwbarton> teaurchin: that won't raise an exception until whenever the second component of the pair gets forced
10:00:09 <teaurchin> will 'evaluate' force the second component?
10:00:16 <c_wraith> no
10:00:22 <rwbarton> evaluate only evaluates to WHNF
10:00:23 <rwbarton> like seq
10:00:29 <c_wraith> "evaluate . rnf" would, though
10:00:55 <teaurchin> is rnf part of deepseq?
10:00:57 <c_wraith> yes
10:01:37 <c_wraith> well. deepseq is implemented in terms of rnf. I can't remember if they're defined in the same package these days
10:01:41 <teaurchin> so if I had Foo instead of (,) as a constructor, I'd need an NFData instance for Foo in order for that to work?
10:01:47 <c_wraith> yes
10:02:06 <c_wraith> rnf is actually the function NFData defines
10:02:09 <teaurchin> can NFData instances be automatically derived? :)
10:02:39 <c_wraith> Sort of.  The deriving package contains template haskell that can generate an NFData instance
10:02:54 <c_wraith> But it's not built in to GHC
10:03:02 <teaurchin> ah
10:03:06 <bitonic> c_wraith: why the "sort of"? They can be easily derived
10:03:11 <rwbarton> deepseq is sort of a blunt tool
10:03:53 <rwbarton> "sort of" presumably in that they cannot be derived using, you know, the deriving mechanism
10:04:00 <c_wraith> there's also that - deepseq is rarely what you actually want.  You usually would prefer seq on a data type that's appropriately strict.
10:04:27 <c_wraith> yes, that's exactly why the "sort of" qualification.
10:04:36 <teaurchin> so it it safe to conclude that pure exceptions suck? :)
10:05:00 <c_wraith> I prefer to use them only to indicate programmer error
10:05:14 <bitonic> rwbarton: ah, ok.
10:05:16 <c_wraith> Anything that I expect to be recovered from, I use a different mechanism
10:05:37 <teaurchin> alright, that makes sense
10:06:10 <teaurchin> I littered my code with pure exceptions thinking they'd have better semantics; I'll go back and redo it
10:06:27 <daniel_-> how do you set XNoMonomorphismRestriction in file?
10:06:44 <c_wraith> daniel_-: {-# LANGUAGE NoMonomorphismRestriction #-}
10:06:49 <c_wraith> daniel_-: at the top of the file
10:06:57 <daniel_-> ty
10:07:10 <xpololz> Hey guys, new guy here :) I'm gonna learn Haskell as a vehicle to the functional programming paradigm, and in an attempt to do so it seems learning lambda calculi is recommended, does anyone have some good introduction to this particular field?
10:07:16 <teaurchin> this works as expected, which is neat:
10:07:17 <teaurchin> > (evaluate . rnf) (1, throw DivideByZero :: Int) `Control.Exception.catch` (\(e::SomeException) -> error "foo")
10:07:18 <lambdabot>   Not in scope: `evaluate'Not in scope: `rnf'Not in scope: `throw'Not in scop...
10:07:20 <teaurchin> *** Exception: foo
10:08:29 <mstrlu> Is there any predefined Arbitrary instance for Data.Text.Text somwhere? Or does one always have to define one via String and pack?
10:08:51 * hackagebot language-objc 0.4.2.1 - Analysis and generation of Objcective C code  http://hackage.haskell.org/package/language-objc-0.4.2.1 (JohnLato)
10:11:07 <Cale> xpololz: um, you shouldn't have to learn much about lambda calculi explicitly if you actually just want to understand functional programming and Haskell, but I guess it can help, as lambda calculi are like the simplest functional languages, and you can write interpreters or type checkers for them to understand how those things work better.
10:11:58 <Cale> xpololz: Do you understand how lambda works in Haskell already?
10:12:15 <realitygrill> more interestingly, how useful is learning category theory for haskell?
10:12:37 <Cale> Again something which is maybe nice to know, but mostly a distraction if you're trying to learn Haskell
10:13:00 <xpololz> Cale, well I'll have to say, no not completely :/
10:13:52 <Cale> xpololz: okay, so simple example:
10:13:57 <Cale> > (\x -> x * x) 5
10:13:58 <lambdabot>   25
10:14:01 <xpololz> well, models of computation and language theory is interesting as well
10:14:47 <Cale> (\x -> x * x) represents a function with a formal parameter x, which results in x * x when applied
10:15:34 <Peaker> what is an "informal parameter"?
10:15:35 <xpololz> that's another notion for saying "let x = x * x in 5" ?
10:16:00 <Cale> It's similar, and you can think of it as evaluating to something like that
10:16:06 <hulk1234567890> excuse me? how to get some code's runtime??
10:16:07 <Cale> errr
10:16:13 <Cale> you mean let x = 5 in x * x
10:16:18 <xpololz> heh
10:16:18 <xpololz> y
10:16:19 <xpololz> :D
10:16:36 <Cale> If you have something like: (\x y z -> x + y * z), this is syntax sugar for nested lambdas:  (\x -> (\y -> (\z -> x + y * z)))
10:16:52 <Cale> so for example...
10:17:03 <geekosaur> hulk1234567890, see the criterion package on hackage
10:17:13 <Cale> (\x y z -> x + y * z) 5 7 10
10:17:24 <Cale> = (\y z -> 5 + y * z) 7 10
10:17:27 <hulk1234567890> geekksaur: ok thanks
10:17:31 <Cale> = (\z -> 5 + 7 * z) 10
10:17:39 <Cale> = 5 + 7 * 10
10:18:19 <Cale> Which is just the usual way that we handle multiple parameter functions in Haskell -- as functions which produce other functions as their result.
10:19:32 <xpololz> hmm
10:19:47 <Cale> > map (\x -> 10 * x + x) [1..5]
10:19:49 <lambdabot>   [11,22,33,44,55]
10:20:09 <Cale> It's useful to be able to supply functions without having to name them in many cases.
10:21:31 <mcstar> is this called an irc-cast?
10:21:34 <xpololz> yeah, read that somewhere, however I'm still at the previous example
10:21:44 <aristid> @pl \x -> 10 * x + x
10:21:45 <lambdabot> (+) =<< (10 *)
10:21:45 <Cale> okay
10:21:53 <Cale> mcstar: is what?
10:22:03 <mcstar> Cale: you giving lectures over idc :)
10:22:08 <mcstar> irc*
10:22:12 <realitygrill> are class constraints still written with parentheses or is it unnecessary?
10:22:34 <Cale> realitygrill: You need the parens only if there's more than one
10:23:01 <Cale> realitygrill: (to tuple them together, bare commas aren't allowed)
10:23:07 <xpololz> I didn't ask for it, but these lessons are awesome :) where can I subscribe?
10:23:12 <realitygrill> ah, ok
10:23:27 <realitygrill> heh i'd join a lesson
10:23:28 <Cale> You can ask questions here any time, and people will answer them
10:23:34 <bitonic> Cale: cale often does that. Cale is great
10:23:48 <mcstar> im serious, why arent there irc casts?
10:24:01 <mcstar> if there are screencasts, podcasts...
10:24:07 <mcstar> webcasts
10:24:08 <Cale> I've given lectures over IRC before
10:24:21 <Cale> it can be weird when people don't necessarily have the same background
10:24:27 <mcstar> to a real class? or just informally?
10:24:36 <Cale> I prefer talking to a handful of people at a time
10:25:38 <xpololz> anyways, a function which has multiple functions as arguments can be boiled down into a function with only one function as an argument right?
10:25:43 <Cale> I did an introduction to the real numbers over IRC for a random assortment of people in #math at one point.
10:25:47 <xpololz> or did I kinda miss the point?
10:25:54 <Cale> yes, that's right
10:25:58 <Cale> errr
10:26:00 <Cale> no
10:26:03 <Cale> only one parameter
10:26:08 <Cale> and produces a function as its result
10:26:11 <xpololz> thought I had it there for a sec :)
10:26:29 <Cale> you used the word function when you should have used the word parameter
10:26:45 <aristid> Peaker: what does your bottle require BerkeleyDB for? it's a C dependency and as such can create a bit of friction for trying it out
10:26:53 <Cale> "a function which has multiple parameters can be boiled down into a function with only one parameter"
10:26:58 <nand`> in other words, every function is of the type a -> b for some a/b
10:27:02 <xpololz> ahh, right
10:27:18 <Peaker> aristid, our backend store isn't text files, it's a key/value store.. we might replace it with some other key/value store
10:28:42 <realitygrill> yeah, i've been in a few irc lectures
10:29:11 <aristid> Peaker: i think a good option would be to use a pure haskell thing by default, and if necessary allow plugging in something else
10:29:16 <nand`> does group theory focus on all magmas or just groups?
10:29:23 <rwbarton> group theory is about groups :)
10:29:25 <aristid> Peaker: just to make it easier for people to play with it
10:29:36 <rwbarton> "nobody" really studies magmas
10:29:51 <nand`> rwbarton: yeah, but things that are also magmas like monoids, groups, etc.
10:29:57 <rwbarton> but even monoids (which people do study) have a very different character from groups
10:30:12 <nand`> I formulated it that way to specifically exclude categories and groupoids
10:30:18 <Peaker> aristid, Is there a pure Haskell thing that is decent regarding commits/transactions?
10:30:21 <xpololz> well, these are just random things I picked up, and I kind of understood what you told me already Cale (I think..), but back to your earlier question - I still don't feel like I any real clue about how lambda calculi works in Haskell
10:30:42 <nand`> rwbarton: what would you call the study of all such objects though, just “abstract algebra”?
10:30:51 <rwbarton> probably "algebra" yeah
10:30:53 <Jonno_FTW> ttest
10:30:59 <xpololz> you don't need to sit here giving me lessons,  just asking for some good resources now if you have any :)
10:31:06 <aristid> Peaker: i have no idea how good it is, but there's this: http://hackage.haskell.org/package/acid-state
10:31:23 <rwbarton> effectively monoids and groups are about as different as groups and rings
10:31:45 <nand`> xpololz: well, Haskell is formally based on System Fc which is a modified version of System F which is somewhat related to the typed lambda calculus
10:31:58 <nand`> if you're looking for a connection
10:32:39 <xpololz> okay
10:33:17 <Peaker> aristid, isn't that a ram-only storage?
10:33:27 <aristid> Peaker: it persists to disk, i think
10:33:40 <bitonic> aristid, Peaker: it does
10:33:41 <Peaker> aristid, but it must be fully in ram?
10:33:46 <bitonic> Peaker: yes
10:33:53 * hackagebot click-clack 1.0.1 - Toy game (tetris on billiard board). Hipmunk in action.  http://hackage.haskell.org/package/click-clack-1.0.1 (AntonKholomiov)
10:33:55 * hackagebot gencheck 0.1.1 - A testing framework inspired by QuickCheck and SmallCheck  http://hackage.haskell.org/package/gencheck-0.1.1 (JacquesCarette)
10:34:06 <bitonic> afaik there is no on-disc, pure haskell storage
10:34:12 <Peaker> yeah, I don't want it fully in-ram
10:34:18 <aristid> Peaker: yes.
10:34:23 <aristid> Peaker: why not?
10:35:41 <raek> I'm trying to `cabal install wx-0.13.2.1`, but for some reason it tries to install wxdirect-0.90.0.1 instead of wxdirect-0.13.1.2... what can I do about this? (does my attempt make sense?)
10:35:42 <Peaker> aristid, I want it to be able to edit huge code projects in potential. It may be good enough for toying around though
10:36:49 <aristid> Peaker: well, there's virtual memory, so if you allow for some swapping, it might even work on computers with little memory but big projects (and i can't imagine a 16 GB memory to be exhausted merely with code)
10:36:57 <raek> (I cannot compile wxdirect-0.90.0.1 because it depends on a more recent version of wxwidgets than I have)
10:37:13 <rwbarton> maybe 'cabal install wx-0.13.2.1 wxdirect-0.13.1.2'?
10:37:23 <rwbarton> (haven't checked that this is indeed a sensible thing to do)
10:38:56 <newsham> when is someone gonna port shdrlu to haskell?
10:39:54 <newsham> http://hci.stanford.edu/winograd/shrdlu/code/
10:41:20 <rwbarton> oh wow
10:41:27 <rwbarton> is it possible to still run this code somehow?
10:41:30 <Peaker> aristid, the code database also includes revision control, and perhaps it will include heavy caches/results, not sure yet
10:41:36 <rwbarton> do I need a system that can only handle uppercase letters?
10:41:37 <newsham> yes, there's a "modern" version on the page
10:41:45 <newsham> see http://hci.stanford.edu/winograd/shrdlu/
10:41:51 <newsham> it runs in winders
10:42:15 <newsham> but someone should make one that runs in .js i think
10:42:27 <newsham> or .hs would be nice too
10:47:33 <raek> rwbarton: ok, thanks! I think your suggestion solved that problem. (but now I have another problem instead...)
10:51:46 <daniel_-> @hoogle Char -> String -> Int
10:51:46 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
10:51:47 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
10:51:47 <lambdabot> Foreign.C.Error throwErrnoPath :: String -> FilePath -> IO a
10:53:44 <JoeyA> If I import Prelude (), and define a Monad class with (>>=) and return, will do notation use my monad class, or is it dead-set on using the one in Prelude?
10:53:54 <newsham> > 'e' `elemIndices` "The quick brown fox jumped over the lazy dogs"
10:53:56 <lambdabot>   [2,24,29,34]
10:55:59 <shachaf> JoeyA: -XRebindableSyntax
10:56:03 <shachaf> Or -XNoImplicitPrelude
10:56:04 <shachaf> Or something.
10:59:29 <JoeyA> shachaf: Ah, neat
11:04:13 <mdmkolbe> Is there any commentary or documentation (other than the source) about how GHC implements the layout rule?
11:05:24 <nand`> hmm, the bindings for ‘vte’ are for vte 0.28.2 which is very old. How hard would it be for me, knowing nothing about C and even less about the FFI, to update it to 0.32.x?
11:05:46 <nand`> is this the type of thing where I just change some number then fix the errors as they come up?
11:05:51 <nand`> or will that set me up for runtime errors
11:06:09 <mdmkolbe> (I'm writing a paper about a new formalism for indentation sensitive languages and while I think I understand the code GHC uses for the layout rule, it would be nice to have a citeable quote.)
11:07:20 <c_wraith> GHC actually handles layout by running a first parser pass that converts all layout to explicitly using {;} for purposes of parsing.
11:08:35 <mdmkolbe> c_wraith: I've looked at the code, it is quite a bit more subtle than that
11:09:13 <mdmkolbe> c_wraith: the Haskell spec says that that is how Haskell is implemented, but the spec requires an angelic oracle in order to work right
11:10:09 <Dtgr>  /win 23
11:10:55 <rwbarton> because of the } insertion on syntax error?
11:11:03 <mdmkolbe> rwbarton: yeah
11:13:21 <mdmkolbe> Of course, you can interleave the lexer and the parser and have them share state, and make the parser detect the missing } and tell the lexer, etc.  (Which is exactly what GHC does) but for writting this paper I'd rather be quoting or citing a specific documentation that says that.
11:20:07 <tgeeky> mdmkolbe: I replied a little in #ghc
11:28:35 <nand`> oh, turns out I can't update to vte 0.32.x :(
11:29:42 <nand`> Is there a version of Gtk2Hs for Gtk+ 3.x?
11:29:56 <daniel_-> :? @pl
11:35:24 <daniel_-> anyone got any good tips for a beginner on how to make this function simpler? im making a mastermind game as my first haskell program -> http://paste.ofcode.org/nSvRjCY3ssYS4J7sLbQHf9
11:35:39 <daniel_-> i feel like i can make it more awesome in haskell
11:36:20 <JoeyA> daniel_- : Use pattern matching: points [] = ...
11:36:26 <JoeyA> instead of points xs | xs = []
11:37:07 <JoeyA> Though the next pattern will need to be xs | xs == answer
11:37:11 <tac-tics> daniel_-: Yes, use lots of pattern matching
11:37:20 <tac-tics> Guards are only useful when pattern matching isn't :)
11:37:25 <tac-tics> (the same is true of if statements)
11:38:34 <daniel_-> hmm, yea i couldnt get pattern matching to work at first
11:38:37 <daniel_-> will give it another try
11:38:45 <tac-tics> daniel_-: You might also want to use a "where" clause instead of that let clause
11:39:03 <tac-tics> where clauses sometimes make code tidier
11:39:03 <JoeyA> And yes, you can say ten | y == answer !! (e - length ys)) = 10 | otherwise = 0  :-)
11:39:52 <daniel_-> thanks :)
11:42:01 <JoeyA> The logic behind 'ten' and 'one' could be improved a little (the (ten == 0) got my attention)
11:42:48 <daniel_-> yeah im mostly trying my ways until i finally make it compile, i compile as soon as i add something
11:44:02 <JoeyA> "trying my ways until i finally make it compile"  Haskell is a good language for that style of programming ;-)
11:44:55 <daniel_-> yeah, i just want to make it compile and work correctly and then refine it :P
11:45:59 <daniel_-> im like spending more than 1h on each function in this god damn mastermind-game :P
11:48:40 <JoeyA> daniel_- : Also, see if you can get rid of that !! .  Not just because xs !! n takes O(n) time because it has to traverse the list, but you might get cleaner code structure by traversing lists in order.
11:49:04 <JoeyA> As a simple example, you could implement 'map' (apply a function to each item in a list) like this:
11:50:31 <JoeyA> > let myMap f xs = loop 0 where loop i | i < length xs = f (xs !! i) : loop (i+1)  | otherwise = []
11:50:33 <lambdabot>   not an expression: `let myMap f xs = loop 0 where loop i | i < length xs = ...
11:50:41 <JoeyA> @let myMap f xs = loop 0 where loop i | i < length xs = f (xs !! i) : loop (i+1)  | otherwise = []
11:50:43 <lambdabot>  Defined.
11:50:51 <JoeyA> > myMap (+3) [1,2,3]
11:50:54 <lambdabot>   [4,5,6]
11:51:13 <JoeyA> However, it's easy to mess up the indexing when you define functions like this.
11:51:34 <JoeyA> @let myMap_buggy f xs = loop 1 where loop i | i <= length xs = f (xs !! i) : loop (i+1)  | otherwise = []
11:51:36 <lambdabot>  Defined.
11:51:40 <JoeyA> > myMap_buggy (+3) [1,2,3]
11:51:42 <lambdabot>   [5,6,*Exception: Prelude.(!!): index too large
11:52:10 <tac-tics> Scandal!
11:52:17 <tac-tics> The !! operator is inappropriate!
11:52:26 <JoeyA> tac-tics: That's my point
11:52:28 <armlesshobo> anyone heavily use mighttpd2?
11:52:36 <JoeyA> @src map
11:52:36 <lambdabot> map _ []     = []
11:52:37 <lambdabot> map f (x:xs) = f x : map f xs
11:52:38 <tac-tics> Oh yes
11:52:45 <tac-tics> Never index. Always pattern match :)
11:53:06 <JoeyA> When you code in this style, it's hard to get it wrong.
11:54:12 <JoeyA> It's almost impossible to implement map wrong without ghc giving you warnings or errors (assuming you compile with -Wall).
11:54:54 <applicative> daniel_-: I see, they get 10 points for each color that is in the right place, 1 for each color that's right?
11:55:26 <daniel_-> correct
11:55:51 <JoeyA> That can be implemented in fewer characters than applicative used to describe it.
11:55:56 <JoeyA> (I think)
11:57:10 <mdmkolbe> daniel_-: "length . filter id . zipWith (==)" might be helpfull for implementing the ten point part
11:57:48 <daniel_-> ah a zip
11:58:01 <applicative> > let answer = [1,2,3,4] ; ten xs = filter (uncurry (==)) (zip xs answer) in ten [1,2,4,3]
11:58:02 <daniel_-> didn't think of that
11:58:02 <lambdabot>   [(1,1),(2,2)]
11:58:10 <applicative> hm
11:58:32 <applicative> > let answer = [1,2,3,4] ; ten xs = 10 * (length $ filter (uncurry (==)) (zip xs answer)) in ten [1,2,4,3]
11:58:33 <lambdabot>   20
11:58:52 <mdmkolbe> applicative: uncurry f (zip a b) === zipWith f a b
12:00:04 <mdmkolbe> applicative: nvm, I didn't see the "filter" you were using
12:01:49 <applicative> mdmkolbe yes I started with a different idea
12:03:10 <HairyDude> @hoogle Monad m => Maybe (m a) -> m (Maybe a)
12:03:10 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
12:03:11 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
12:03:11 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
12:03:22 <xpololz> Prelude> foo bar = bar * 2
12:03:27 <xpololz> Prelude> foo bar = bar * 2
12:03:35 <xpololz> <interactive>:24:9: parse error on input `='
12:03:53 <xpololz> mmmh?
12:04:00 * hackagebot base64-bytestring 0.1.2.0 - Fast base64 encoding and deconding for ByteStrings  http://hackage.haskell.org/package/base64-bytestring-0.1.2.0 (BryanOSullivan)
12:04:03 <xpololz> what's this?
12:04:06 <HairyDude> :t Data.Traversable.sequence (Just (putStrLn "Hello world"))
12:04:08 <lambdabot> IO (Maybe ())
12:04:22 <ion> ghci isn’t a Haskell file, it’s more akin to the inside of a do block. Try “let foo bar = bar * 2”.
12:04:40 <JoeyA> > let answer = [1,2,3,4]; ten xs = sum [10 | (a, b) <- zip answer xs, a == b] in ten [1,2,4,3]
12:04:41 <lambdabot>   20
12:04:56 <JoeyA> (wanted to use a parallel list comprehension, but couldn't due to scoping)
12:05:33 <daniel_-> can i do multiple where's?
12:05:50 <JoeyA> daniel_-: You can put multiple bindings under a single where block
12:06:00 <avpx> daniel_-: You can also nest wheres
12:06:04 <JoeyA> Like you can with let
12:06:11 <HairyDude> ghci is a do block where your expressions are (mostly) wrapped by an implicit show
12:06:21 <xpololz> alright, thanks :)
12:06:55 <ion> > ((*10) . length . filter id . zipWith (==) [1,2,3,4]) [1,2,4,3]
12:06:57 <JoeyA> hmm, I wonder what ghci would do if I used RebindableSyntax and an alternative definition of >>=, >>, etc. ;D
12:06:57 <lambdabot>   20
12:08:32 <tgeeky> JoeyA: work just fine
12:09:04 <daniel_-> http://paste.ofcode.org/RZzJ4YrKbpgL6rEa99iXZR
12:09:10 <daniel_-> the tens work fine
12:10:01 <JoeyA> Why are you dividing (tens / 10) right after multiplying by 10?
12:10:10 <JoeyA> (in the definition of tens)
12:10:28 <daniel_-> oh
12:10:47 <nand`> HairyDude: also “it <- ...” everywhere
12:10:57 <JoeyA> [1 | x `elem` xs] +
12:11:07 <JoeyA> Bzzt, can't add a list and a number.
12:11:08 <HairyDude> nand`: yes... I never use that though :)
12:11:11 <JoeyA> :t (+)
12:11:12 <lambdabot> forall a. (Num a) => a -> a -> a
12:11:22 <daniel_-> how do i do / without it having to be fractal?
12:11:39 <DMcGill> :t div
12:11:39 <nand`> HairyDude: I do when I want to experiment with IO-based code and have to bind the result of an IO action somewhere
12:11:40 <daniel_-> i think this might work http://paste.ofcode.org/KLwKpn3QLKh6yWG7RyuyjG
12:11:41 <lambdabot> forall a. (Integral a) => a -> a -> a
12:11:54 <daniel_-> i do ten - ((ten / 10) - ones)
12:12:07 <daniel_-> since ones does not know if it should be a ten
12:12:11 <dmwit13> daniel_-: div, as DMcGill suggested
12:12:16 <JoeyA> Ah, okay
12:12:26 <HairyDude> @hoogle divMod quotRem
12:12:26 <lambdabot> No results found
12:12:37 <DMcGill> odd
12:12:40 <HairyDude> @hoogle divMod
12:12:40 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
12:12:40 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
12:12:45 <HairyDude> @hoogle quotRem
12:12:45 <lambdabot> Prelude quotRem :: Integral a => a -> a -> (a, a)
12:12:46 <JoeyA> Why not say ten*10 - (ten - ones) instead?
12:13:11 <daniel_-> will change to that
12:13:40 <JoeyA> Division can fail or lose precision (but won't in your case).  It's also a tiny bit slower.
12:13:48 <JoeyA> (than multiplication)
12:14:24 <daniel_-> hmmm getting 18 when im supposed to get 22
12:15:21 <applicative_> > let score n x y = if x == y then Just n else Nothing ; ten = sum . catMaybes . zipWith (score 10) answer ; one = sum . catMaybes . zipWith (score 1) (sort answer) . sort ; total xs = ten xs + one xs; answer = [1,2,3,4] in total [1,2,4,3]
12:15:24 <lambdabot>   24
12:15:57 <JoeyA> daniel_- : Looks like your code says that you *lose* points for items in the right place.
12:16:15 <daniel_-> ye
12:16:26 <daniel_-> should probably be ones - tens :P
12:16:40 <daniel_-> seems like ti works :P
12:16:52 <daniel_-> yay
12:17:08 <daniel_-> http://paste.ofcode.org/ZsbBEduLmNwjJMjyThWRXJ
12:17:43 <daniel_-> do i get a B+ for that one?
12:18:03 <JoeyA> I suppose.
12:18:04 <daniel_-> or should i "simplify" it more
12:18:15 <JoeyA> You definitely should
12:18:34 <JoeyA> tens * 10 + ones (x:xs) - tens
12:18:43 <JoeyA> (removed parens that aren't needed)
12:18:57 <daniel_-> it feels like i could probably change ones for something with map or filter
12:19:01 * hackagebot cabal-debian 1.25 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-1.25 (DavidFox)
12:19:30 <JoeyA> daniel_- : You can simplify the top expression, by applying a simple rule from algebra.
12:19:45 <nand`> daniel_-: out of curiosity, what are the intended semantics of the function you're writing? I'm unfamiliar with the game
12:19:51 <JoeyA> And ones can definitely be shorter.
12:20:28 <daniel_-> they get 10 points for each color that is in the right place, 1 for each color that's right?
12:20:45 <daniel_-> not supposed to be as a question
12:21:00 <daniel_-> copied applicative_ question from above
12:21:02 <JoeyA> daniel_-: But what if the color is in the right place AND is right?
12:21:08 <nand`> daniel_-: are they cumulative? Like, say the answer is [Red, Green, Blue] and I guess [Red, Yellow, Red] -- do I get 11 points or 10?
12:21:15 <JoeyA> 10 points overall, or 11 because both criteria are met
12:21:16 <JoeyA> ?
12:21:17 <daniel_-> well in mastermind you cant have duplicates
12:21:21 <nand`> or can I not guess the same color twice
12:21:22 <nand`> oh
12:21:33 <daniel_-> unique :: (Eq a) => [a] -> Bool; unique xs = xs == nub xs
12:21:44 <applicative_> we can make the function independent of this decision...
12:22:25 <nand`> so the score is the number of items that are in the correct place * 10 + the number of items that are *not* in the correct place?
12:22:34 <daniel_-> yes
12:23:06 * nand` has a stab
12:23:11 <applicative_> the way daniel_- expressed it presumably corresponds with the way you do it in practice, count the tens, then count the matches excluding the tens ?
12:24:05 <applicative_> oh wait, i'm confused again
12:24:06 <daniel_-> yeah but in real life you correspond with a color (blacks for correct position, and whites for correct color but wrong location)
12:24:18 <JoeyA> Also, instead of f (x:xs) = ... (x:xs) ..., you can say f xs = ... xs ...
12:24:37 <daniel_-> http://en.wikipedia.org/wiki/File:Mastermind.jpg in that case they are white/red
12:24:46 <JoeyA> The difference, though, is that the latter pattern matches anything (not matched by previous patterns)
12:25:29 <JoeyA> But if you need to check the length of the list, but only need to use the whole list, you can do this: f xs@(_:_)
12:25:54 <JoeyA> _ is a "catch-all" pattern just like a variable, but the compiler won't warn you if it goes unused.
12:26:01 <daniel_-> well dont i need x:xs because ones is doing recursion?
12:26:15 <daniel_-> or will i just define a let y:ys = xs
12:26:20 <daniel_-> in that case?
12:26:53 <JoeyA> daniel_-: ones needs it because it's doing recursion on xs, but points' (x:xs) = ... (x:xs) ... can just be points' xs = ... xs ...
12:27:09 <JoeyA> I'm talking about this line: points' (x:xs) = tens * 10 + (ones (x:xs) - tens)
12:27:24 <daniel_-> oh
12:27:26 <daniel_-> i see
12:27:37 <avpx> I'd also recommend calling the arguments to ones something different than the arguments to points'
12:27:39 <JoeyA> The unconsing is redundant, *unless* there are no preceding patterns.
12:27:58 * nand` has a feeling this can be done comonadically
12:28:12 <avpx> daniel_-: points' xs = tens ... (ones xs - tens) ...
12:28:13 <nand`> actually, that would be probably more complicated than the pointful variant
12:28:18 <avpx> ones (y:ys) = ... ones ys
12:28:29 <daniel_-> yes avpx just made that change :)
12:28:35 <JoeyA> (if there are no preceding patterns, then the effect of having an (x:xs) pattern is that the function will fail if the list is empty)
12:28:38 <avpx> daniel_-: Good
12:28:49 <JoeyA> > let f (x:xs) = (x:xs) in [1,2]
12:28:50 <nand`> what I don't quite understand
12:28:50 <lambdabot>   [1,2]
12:28:53 <JoeyA> > let f (x:xs) = (x:xs) in []
12:28:55 <lambdabot>   []
12:28:59 <JoeyA> ...
12:29:07 <nand`> you're trying to avoid counting the “ones” for those that are in the correct position as well?
12:29:10 <nand`> so they don't get rewarded twice?
12:29:10 <JoeyA> oh
12:29:13 <JoeyA> > let f (x:xs) = (x:xs) in f []
12:29:15 <lambdabot>   can't find file: L.hs
12:29:25 <avpx> Err
12:29:28 <JoeyA> > 2+2
12:29:30 <lambdabot>   4
12:29:30 <nand`> why not simply change tens to 9* instead of 10*?
12:29:33 <Taneb> Is there something like class Consable t where cons :: a -> t a -> t a
12:29:34 <daniel_-> not really nand` since you can just do tens - ones
12:29:45 <daniel_-> ones does not know if they are actually a ten
12:29:56 <daniel_-> i mean ones - tens
12:30:15 <nand`> yes, but it doesn't matter does it? 1 point for each that is present in the answer, then 9 points for those that are also in the correct location
12:30:16 <nand`> sounds solid to me
12:30:22 <daniel_-> if there are 2 tens there should be >= 2 ones
12:30:25 <Taneb> instance Consable [] where cons = (:)
12:30:34 <avpx> Taneb: Sounds sort of like MonadPlus
12:30:40 <Taneb> Nah, it's different
12:30:52 <nand`> Taneb: I think there's a ListLike
12:30:53 <applicative_> nand`: this keeps being noticed, but its like your team gets a certain number of gold medals and a certain number of silver
12:30:54 <nand`> somewhere
12:30:55 <Taneb> Infinite Streams are an instance of this but not that
12:30:57 <avpx> Taneb: It's not associative, for one
12:31:05 <nand`> applicative_: and you want to distinguish?
12:31:23 <nand`> instead of just using the sum, right?
12:31:29 <JoeyA> Has Foldable and Traversable anything to do with it?
12:31:41 <applicative_> nand` somehow it precedes scoring http://en.wikipedia.org/wiki/File:Mastermind.jpg
12:31:57 <Taneb> instance Consable Seq where cons = (<|)
12:32:25 <Taneb> newtype Reverse t a = Reverse {getReverse : t a}
12:32:41 <Taneb> instance Consable (Reverse Seq) where cons = flip (|>)
12:33:20 <JoeyA> Taneb: There's Data.Monoid, which is pretty close to that (but not the same, obviously)
12:33:26 <JoeyA> Taneb: It would be nice to have a corresponding uncons as well.
12:33:36 <Taneb> JoeyA, uncons is I think just Foldable
12:34:13 <JoeyA> Combined with syntactic sugar for (x:xs) patterns, it would provide a convenient way to traverse Text and ByteString values as if they were lists.
12:34:35 <nand`> maybe you want tens :: [Color] -> (Int, [Color]) -- which drops those matches as well
12:36:01 <dmwit13> :t zipWith (==)
12:36:02 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [Bool]
12:36:09 <daniel_-> i think tens is fine
12:36:15 <Taneb> JoeyA, head = foldl1 const
12:36:15 <daniel_-> but i think i could improve ones somehow
12:36:26 <daniel_-> ones (y:ys) = (if (y `elem` answer) then 1 else 0) + ones ys
12:36:38 <Taneb> Tail's more difficult
12:38:24 <daniel_-> ones xs = length $ filter (\y -> y `elem` answer) xs
12:38:29 <daniel_-> guess it was as easy as that
12:38:58 <JoeyA> daniel_- : See if you can get rid of the pattern match and lambda.
12:39:11 <dmwit13> daniel_-: If this is mastermind, that looks wrong to me.
12:39:20 <JoeyA> Doing that is called making it point-free.
12:39:27 <dmwit13> Consider the guess (black, black, white) for the answer (blue, blue, black)
12:39:47 <dmwit13> daniel_-: you don't want to count both black's as wrongly-placed right answers
12:40:05 <JoeyA> dmwit13: I think daniel_-  said earlier that you can't have two of the same color in a guess or answer.  I may be wrong about that
12:40:16 <dmwit13> Oh, okay. That simplifies a lot of things. =)
12:40:45 <JoeyA> daniel_- : For example, if you have map (\x -> x + 1), you can write it as map (+1)
12:40:56 <JoeyA> (+1) is shorthand for (\x -> x + 1)
12:41:33 <JoeyA> This syntax is called a "section"
12:41:50 <JoeyA> You can also use `elem` in a section.
12:42:15 <JoeyA> Doing so can make your code read more nicely
12:42:21 <daniel_-> is pointfree using (.)
12:42:22 <daniel_-> ?
12:42:37 <JoeyA> Pointfree frequently does use (.)
12:43:16 <nand`> point-free generally means “no local names”, right?
12:43:26 <JoeyA> I'm pretty sure.
12:43:46 <JoeyA> daniel_- : Point-free can often make code more concise and easy to read, but not always
12:43:51 <JoeyA> @pl \a b c d e -> e d c b a
12:43:52 <lambdabot> flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))
12:44:15 <tgeeky> @. unpl pl \a b c d e -> e d c b a
12:44:16 <lambdabot> (\ b c f i l -> l i f c b)
12:44:29 <JoeyA> heh
12:44:29 <daniel_-> im so bad writing stuff with . even tough i know func = f . g == func f g x = f(g(x))
12:44:42 <S11001001> daniel_-: go with the flow
12:44:44 <daniel_-> i never get it to compile when trying to do stuff with .
12:44:46 <nand`> you could try using ∘ instead :P
12:44:52 <tgeeky> daniel_-: http://hackage.haskell.org/packages/archive/pointless-haskell/0.0.8/doc/html/src/Generics-Pointless-Combinators.html <-- that's a good library for reference
12:44:56 <S11001001> daniel_-: or <$>
12:44:56 <dmwit13> Hm, is there a bag-intersection function conveniently available?
12:44:59 <applicative_> @pl let foo xs = length $ filter (\y -> y `elem` answer) xs in foo
12:44:59 <lambdabot> length . filter (`elem` answer)
12:45:06 <dmwit13> (with type Eq a => [a] -> [a] -> [a]?)
12:45:13 <yav> Hi.  Does anyone know if cabal has a flag that would enable me to configure and build just one of the multiple executables in a Cabal file?
12:45:23 <nand`> S11001001: yeah or just (.)
12:45:27 <JoeyA> If you start using 'flip' or 'uncurry' regularly, you know you're taking it too far.
12:45:30 <tgeeky> dmwit13: http://hackage.haskell.org/packages/archive/multiset/0.2.1/doc/html/Data-MultiSet.html
12:45:39 <dmwit13> tgeeky: nice, thanks!
12:45:49 <nand`> JoeyA: I use uncurry all the time, is it that bad?
12:46:46 <daniel_-> @pl let answer = [1, 2, 3, 4]; let xs = [1,2,4,3]; let tens = length (filter id (zipWith (==) answer xs))
12:46:46 <lambdabot> (line 1, column 28):
12:46:46 <lambdabot> unexpected reserved word "let"
12:46:47 <lambdabot> expecting "()", natural or letter or digit
12:47:32 <tgeeky> daniel_-: pl won't handle let or where blocks
12:47:42 <dmwit13> tgeeky: pfft, Ord instances...
12:47:43 <daniel_-> what is pl?
12:47:44 <JoeyA> nand` : Depends
12:48:12 <S11001001> daniel_-: uh...?
12:48:16 <JoeyA> daniel_- : A lambdabot feature that rewrites code in point-free style
12:48:24 <daniel_-> okay
12:48:30 <JoeyA> It only works for certain types of expressions, though
12:48:49 <JoeyA> @pl let answer = [1, 2, 3, 4]; let xs = [1,2,4,3]; let tens = length (filter id (zipWith (==) answer xs)) in tens
12:48:50 <lambdabot> (line 1, column 28):
12:48:50 <lambdabot> unexpected reserved word "let"
12:48:50 <lambdabot> expecting "()", natural or letter or digit
12:48:54 <daniel_-> @pl let tens = length (filter id (zipWith (==) [1,2] [1,3]))
12:48:55 <lambdabot> (line 1, column 57):
12:48:55 <lambdabot> unexpected end of input
12:48:55 <lambdabot> expecting variable, "(", operator, ";" or "in"
12:49:05 <JoeyA> That's already point-free
12:49:17 <daniel_-> ah
12:49:17 <tgeeky> dmwit13: technically that comes from the key in the Data.Map map
12:49:18 <S11001001> daniel_-: give it a lambda
12:49:51 <daniel_-> forgot point free was without patterns not only using .
12:50:14 <daniel_-> or parameters w/e they are called
12:50:25 <nand`> that would be quite hard for most things, only using . :P
12:50:27 <applicative_> daniel_-: the 'points' are the values in the type, so anything that refers to them including variables is supposed to be out
12:50:30 <S11001001> @pl \x -> f x
12:50:30 <lambdabot> f
12:50:35 <nand`> :t (.).((.).(.))
12:50:37 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
12:50:40 <S11001001> @pl \x -> x x
12:50:40 <lambdabot> join id
12:50:46 <applicative_> @type uncurry id
12:50:47 <lambdabot> forall b c. (b -> c, b) -> c
12:50:53 <S11001001> @pl \x -> f (g x)
12:50:53 <lambdabot> f . g
12:51:00 <nand`> applicative_: ooh, ‘eval’
12:51:06 <tgeeky> dmwit13: I assume requiring an Eq instance is worse? http://hackage.haskell.org/packages/archive/unordered-containers/0.2.1.0/doc/html/src/Data-HashSet.html#intersection
12:51:48 <dmwit13> Eq is fine. I'm a bit skeptical I'll be able to build a HashSet with only an Eq instance, though.
12:52:38 <tgeeky> dmwit13: there is brent's bag implementation: http://hackage.haskell.org/packages/archive/multiset-comb/0.2.2/doc/html/Math-Combinatorics-Multiset.html
12:53:21 <daniel_-> ah sweden <3 its 22.00 and its brighter than 12.00 in winter
12:53:23 <tgeeky> dmwit13: it might be trivial to write intersection for that
12:53:42 <applicative> > uncurry id (even , 16)
12:53:43 <lambdabot>   True
12:55:06 <S11001001> @pl \g -> f . g . h
12:55:06 <lambdabot> (f .) . (. h)
12:55:11 <armlesshobo> i keep getting (unreachable)/: changeWorkingDirectory: does not exist (No such file or
12:55:13 <armlesshobo> directory)
12:55:27 <armlesshobo> error when I try to install a package with cabal
12:55:33 <rwbarton> sounds like your working directory was deleted
12:55:43 <rwbarton> maybe
12:55:48 <applicative> @pl  \g -> g . f . g
12:55:48 <lambdabot> ap (.) (f .)
12:56:08 <armlesshobo> rwbarton: what's the default?
12:56:10 <armlesshobo> do you know?
12:56:17 <rwbarton> ?
12:56:36 <rwbarton> try 'cd' and then try cabal install whatever again
12:56:44 <JoeyA> daniel_- : Summer solstice is in 25 hours ;-)
12:56:46 <armlesshobo> ... nvm, i just derped lol
12:57:13 <hiptobecubic> hmm  cabal install language-c-quote   is hanging indefinitely
12:57:30 <JoeyA> err, 28, I think.
13:00:47 <hiptobecubic> http://vpaste.net/ijElc
13:02:52 <realitygrill> damn i keep getting messed up by . and $
13:04:29 <hpaste> dmwit pasted “mastermind, for fun” at http://hpaste.org/70179
13:05:00 <nand`> ($) is just (.) in the identity functor, right?
13:05:16 <hiptobecubic> that will help.
13:06:46 <JoeyA> dmwit13: What's the difference between your bagIntersection and Data.List.intersect, besides the latter's use of Eq (and thus suboptimal performance) ?
13:06:55 <realitygrill> nand`: i think so
13:07:45 <dmwit13> JoeyA: this:
13:07:57 <dmwit13> > intersect ["blue", "blue", "blue", "blue"] ["blue"]
13:07:57 <lambdabot>   ["blue","blue","blue","blue"]
13:08:08 <dmwit13> bagIntersection with the same arguments will return ["blue"]
13:09:17 <realitygrill> oh. i needed to do a branched recursion
13:09:29 <realitygrill> multiple recursion, whatever
13:09:38 <dmwit13> ?let bagIntersect a b = go (sort a) (sort b) where { go (x:xs) (y:ys) = case compare x y of { LT -> go xs (y:ys); EQ -> x : go xs ys; GT -> go (x:xs) ys }; go _ _ = [] }
13:09:39 <lambdabot>  Defined.
13:09:45 <dmwit13> > bagIntersect "bbbbb" "bb"
13:09:47 <lambdabot>   "bb"
13:10:01 <JoeyA> ah
13:11:10 <dmwit13> It can be done with an Eq constraint, but this was simpler. =P
13:11:35 <realitygrill> does [_] not work for pattern matching a singleton list now?
13:12:04 <realitygrill> [x] appears to work
13:12:21 <dmwit13> [_] works fine
13:12:31 <realitygrill> ghc is telling me 'Pattern syntax in expression context: _'
13:12:42 <rwbarton> that means you're looking at an expression
13:12:49 <dmwit13> Sounds like you wrote it somewhere that wasn't a pattern.
13:14:27 <daniel_-> thanks for all the help guys and good night :)
13:14:48 <realitygrill> i'm pattern-matching 'msort [_] = [_]'
13:14:59 <nand`> _ on the RHS is illegal
13:15:03 <theadmin> realitygrill: That ain't gonna work
13:15:12 <realitygrill> ahhh. why not?
13:15:19 <theadmin> realitygrill: _ can only be used in patterns. The second [_], after the =, is no longer a pattern
13:15:30 <nand`> hey, there should be a language extension that sets _ = undefined when used in a non-expression
13:15:34 <realitygrill> hm. then how can i reference it?
13:15:42 <realitygrill> i guess i could use an as-pattern
13:15:43 <nand`> or _ = ⊥
13:15:46 <nand`> realitygrill: by not using _ ?
13:15:50 <nand`> msort [x] = [x]
13:15:53 <theadmin> realitygrill: Something along the lines of msort [x] = [x]
13:15:54 <realitygrill> ok, ok
13:15:59 <nand`> realitygrill: _ is for when you *don't* want to reference the value
13:16:04 <realitygrill> that's what I ended up doing..
13:16:04 <nand`> _ is for “ignoring” things, basically
13:16:07 <realitygrill> oh. right. hm..
13:16:29 <rwbarton> yeah you can't ignore something if you want to return it!
13:16:31 <Taneb> I remember figuring this out
13:16:33 <Taneb> :)
13:16:36 <Taneb> Good memories
13:16:37 <rwbarton> Well...
13:16:52 <rwbarton> as an aside, you could also write msort (xs@[_]) = xs
13:17:27 <dmwit13> don't even need parens
13:17:34 <rwbarton> I know :)
13:17:47 <rwbarton> There are 13 of you now?
13:18:21 <dmwit13> hah, changed my nick for more convenient code-golf comparisons
13:21:59 <cschneid> what should I look at for unit testing? (not quickcheck, but something hardercoded in terms of input/output)
13:22:22 <danr> dmwit: how did the `13' help you do code golf? has it something to do with rot-13?
13:23:03 <dmwit> danr: It made my name the same length as the other folks who were code golfing, so that it was easy to visually compare code length even in IRC clients that don't align text from nicks of different lengths.
13:23:25 <nand`> so who won?
13:23:59 <tgeeky> ok. straight up question. Is there *any* GHC extension which would make this a valid pattern match:   length (x ++ y) = length x + length y
13:24:34 * tac-tics can't imagine any would.
13:24:37 <S11001001> looks like valid haskell 98, supposing ++ isn't that one function
13:24:50 <danr> dmwit: aha, so it was mainly just a filler?
13:25:14 <danr> tgeeky: what semantics are you intending for it?
13:25:42 <rwbarton> it might be valid in Curry
13:25:59 <tgeeky> danr: the semantics the authors intend is always:  given a (nonempty) list, split it arbitrarily at some point, returning two lists
13:25:59 <rwbarton> or something like it
13:26:14 <nand`> what I'd do is use some binary tree-like constructor in place of ++, gives your data some structure to follow when splitting
13:26:17 <rwbarton> (example Curry code from wikipedia: "last l | xs++[e] =:= l = e where xs,e free")
13:26:18 <tgeeky> it's used over and over again: http://takeichi.dyndns.org/attachments/snpd030.pdf
13:26:31 <tgeeky> by these Japanese Haskellers
13:26:40 <rwbarton> are you talking about the first displayed equation?
13:26:50 <tgeeky> rwbarton: nope
13:27:01 <tgeeky> rwbarton: http://www.iis.sinica.edu.tw/~scm/pub/icfp055fp-mu.pdf
13:27:05 <tgeeky> the first equation there, yes
13:27:09 <rwbarton> ...
13:27:10 <rwbarton> okay
13:27:30 <tgeeky> rwbarton: also the definition of "h" on page 2
13:27:46 <rwbarton> isn't that the same equation (modulo slight typographical differences)
13:28:15 <tgeeky> it's the same concept, but not the same equation (it requires e,k, and f)
13:28:17 * dmwit takes a guess without looking at the paper: they're giving a "semantic" (not operational) definition of a list homomorphism
13:28:29 <dmwit> It's not intended to be working Haskell code.
13:28:30 <rwbarton> we must have different notions of "first" or "displayed equation"
13:28:43 <rwbarton> anyways, it is clearly intended as an equation rather than a definition in Haskell
13:28:51 <rwbarton> like "a + b = b + a"
13:28:59 <rwbarton> not a particularly useful definition of (+)!
13:29:05 <rwbarton> but nevertheless a true equation
13:29:19 <tgeeky> I get that, but how do I actually write h?
13:29:29 <rwbarton> what's h
13:29:49 <tgeeky> page 2, "A function h :: [a] -> b is a /list homomoprhism if ..."
13:29:54 <nand`> since the operational semantics are in terms of a ++ b, you can simply match on : instead which is the unique splitting point such that a is a singleton
13:30:07 <nand`> and you get the same result, as a less general instance of the formula given
13:30:12 <tgeeky> nand`: that works for the inverse of cons, but not the inverse of snoc
13:30:38 <tgeeky> err
13:31:13 <nand`> (I don't have the paper in front of me so I'm not sure what exactly is needed)
13:31:19 <rwbarton> for some specific e, k, f, you write it by induction with (x : xs) of course like nand` said
13:31:24 <rwbarton> or you can write it in other ways
13:32:35 <rwbarton> the point being made in the subsequent paragraph is that you have options in how to compute h
13:32:49 <rwbarton> but Haskell is not going to pick an option for you
13:32:51 <nand`> again, I would probably do this by working with a binary tree-representation of a list
13:32:53 <rwbarton> you have to pick which option you want
13:33:05 <nand`> if your intention is to be able to split in the middle and match on singletons and empty lists
13:37:54 <hpaste> tgeeky pasted “hom” at http://hpaste.org/70185
13:40:03 <realitygrill> oh, haskell 2010 doesn't have n+k patterns now
13:40:09 <tgeeky> :nope
13:40:11 <rwbarton> anyways I am sure the authors do not think "h (xs ++ ys) = f (h xs, h ys)" is working Haskell code, because (1) it isn't and (2) I don't see anything that suggests that they do (it is just part of an English sentence describing what properties the function h must have)
13:40:14 <tgeeky> the only thing that was removed
13:40:29 <tgeeky> rwbarton: they used it over and over and over again
13:40:31 <tgeeky> use*
13:40:37 <danr> what paper are we reading?
13:40:51 <tgeeky> danr: http://www.iis.sinica.edu.tw/~scm/pub/icfp055fp-mu.pdf
13:40:56 <dmwit> Well it's a darn nice property, is it not?
13:40:56 <rwbarton> I have no doubt that they used it!
13:40:57 <nand`> I don't remember references to Haskell in that paper, except maybe in passing
13:41:11 <dmwit> If I had a function with that property, I'd be proud of it, too!
13:41:14 <rwbarton> However that does not mean they thought it was part of a Haskell program!
13:41:20 <rwbarton> I am so confused.
13:41:44 <tgeeky> le sigh! I never assumed that it was syntactic haskell, I just want to know what they are generally thinking when they have a code version of this program somehwere
13:41:59 <tgeeky> I presumed that they are thinking of what nand suggested (working with an internal representation of lists as trees)
13:42:10 <rwbarton> I don't see any reason to think that either
13:42:16 <rwbarton> these are just equations, okay?
13:42:17 <tgeeky> well, because they are (in each paper)
13:42:25 <nand`> well, they certainly do generalize it to trees
13:42:26 <tgeeky> they are working with ternary trees in this paper (near the end)
13:42:36 <tgeeky> and in all of the other papers they define a treelike structure
13:43:01 <rwbarton> well okay, but on page 2 i see no reason to start reading their mind and suppose they are saying something other than what they are saying
13:43:19 <rwbarton> an equation is not a definition
13:43:33 <tgeeky> again, I know that.
13:43:37 <nand`> the whole point of the paper, if I remember correctly, is that you can effectively split anywhere you want
13:43:44 <nand`> so an internal representation would be pointless, those are not arbitrary
13:44:01 <rwbarton> (again consider "a + b = b + a", if you saw this appearing often in a book on abstract algebra do you think the authors have in mind a definition of (+) on some type that has "a + b = b + a" as part of the implementation?)
13:44:28 <tgeeky> rwbarton: abstract algebraists do not write code, as a rule. bad example.
13:44:41 <rwbarton> this paper appears to be about abstract algebra
13:44:52 <rwbarton> this whole sentence could be lifted right out of an algebra text
13:45:13 <nand`> hmm
13:45:20 <nand`> is foldl = foldr . flip and vice versa?
13:45:26 <tgeeky> nand`: no
13:45:49 <nand`> oh
13:45:51 <nand`> right
13:46:00 <tgeeky> I have this whole paper, meticulously transcribed into Haskell (where possible and obvious), with examples and working examples.
13:46:19 <tgeeky> but I don't know how to capture the essence of what they are saying using Haskell features (typeclasses, implicit parameters, ___ ?)
13:46:59 <nand`> foldr (flip f) e = foldl f e . reverse
13:47:18 <tgeeky> that looks closer
13:50:16 <tgeeky> nand`: yeah, modulo currying and bracketing, that is the type of foldlr
13:50:31 <tgeeky> @type (\f e -> foldr (flip f) e)
13:50:32 <lambdabot> forall b a. (b -> a -> b) -> b -> [a] -> b
13:50:39 <rwbarton> (in fact, arguably this whole sentence *is* found in any algebra text)
13:50:56 <rwbarton> that talks about monoids, anyways
13:51:21 <nand`> list homomorphism is basically just a monoid homomorphism from the free monoid + a fmap, yes?
13:51:26 <tgeeky> rwbarton: well, if you want to talk about the correctness of literally lifting these operators (into idioms)
13:51:32 <tgeeky> then I'm not even sure it makes sense in that light yet
13:51:47 <rwbarton> it is literally just a monoid homomorphism from the free monoid
13:51:52 <armlesshobo> wow, i feel like i need to have been through a higher level of math to really appreciate haskell
13:51:55 <armlesshobo> lol
13:52:21 <nand`> oh right, a fmap is just a monoid homomorphism from a free monoid to another free monoid
13:52:25 <rwbarton> yep
13:52:31 <rwbarton> well, a special kind of one
13:52:31 <tgeeky> nand`: that's the idiomatic part of it
13:52:40 <tgeeky> from the identity monad?
13:52:45 <tgeeky> err monoid
13:52:56 <nand`> rwbarton: yeah, point is the composition of two monoid homomorphisms is also one; as such the entire thing is just one too :P
13:53:07 <tgeeky> rwbarton: what is the equivalent statement about DLists (as opposed to lists)?
13:53:25 <rwbarton> nand`, yeah
13:53:26 <nand`> tgeeky: what's the identity monoid?
13:53:48 <tgeeky> nand`: something I just made up.
13:53:56 <tgeeky> I mean the identity environment, I think
13:54:08 * hackagebot binary-shared 0.8.2 - Sharing for the binary package  http://hackage.haskell.org/package/binary-shared-0.8.2 (JuergenNicklischFranken)
13:54:09 <nand`> not sure I follow
13:54:15 <tgeeky> the reader monad, specialized to identity
13:54:58 <nand`> Reader a a?
13:55:11 <rwbarton> and since e and f are part of the monoid structure on b, the fact that every k uniquely determines an h satisfying these conditions is exactly what makes [a] the free monoid on a
13:55:44 <rwbarton> any function k :: a -> b determines a unique monoid homomorphism h : [a] -> b
13:55:57 <rwbarton> with h . (:[]) = k
13:56:11 <tgeeky> rwbarton: hence why they say "the only possible choice for k is k x = h [x]" ?
13:56:33 <tgeeky> rwbarton: under theorem 2
13:56:48 <rwbarton> well that is just a direct consequence of the second equation for h
13:56:56 <nand`> rwbarton: sounds logical
13:57:00 <tgeeky> nand`: ok. I mean to say "the identity idiom": http://www.cs.ox.ac.uk/ralf.hinze/Lifting.pdf
13:57:17 <tgeeky> nand`: the bottom of page 9
13:57:48 <tgeeky> rwbarton: that certainly isn't how they worded it
13:58:01 <hiptobecubic> Has anyone experienced cabal hanging like this before?  It's been stuck here for a half hour. top indicates 0% cpu:  http://vpaste.net/ijElc
13:58:05 <rwbarton> what?
13:58:27 <nand`> tgeeky: I see. I can't parse that page out of context, I'll just pretend I never heard it for now and maybe come back to it when I'm less tired
13:58:39 <rwbarton> nand`, I think "idiom" just means applicative functor
13:58:51 <tgeeky> rwbarton: in the original paper, in theorem 2 (proof), it sounds like they are arguing the other way around
13:59:10 * hackagebot leksah-server 0.12.1.2 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.12.1.2 (JuergenNicklischFranken)
13:59:12 * hackagebot leksah 0.12.1.2 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.12.1.2 (JuergenNicklischFranken)
13:59:14 <rwbarton> nand`, at least from a Haskell-centric viewpoint
13:59:30 <tgeeky> rwbarton: it does, although there are 2 weaker generalizations of what Haskellers call Applicative in the lifting paper
14:00:47 <lispy> most of the mentions in here for me are really people talking about "lispy code"
14:01:04 <rwbarton> if we are supposed to find f, k such that h = hom f k e then by the second equation h [x] = k x
14:01:10 <rwbarton> so, k x = h [x]
14:01:19 <rwbarton> so we better try to use that k
14:01:21 <rwbarton> that is all they are saying
14:01:49 <lispy> hiptobecubic: I've never seen cabal hang, FWIW
14:02:05 <tgeeky> rwbarton: so I asked (perhaps a stupid) question earlier:
14:02:25 <lispy> hiptobecubic: could it be failing to timeout on a network activity that will never complete?
14:02:57 <tgeeky> they write foldlr (as opposed to foldrr) after defining snoc, and h . snoc
14:03:17 <tgeeky> rwbarton: I don't think they intended to consider DLists, but what about DLists: http://hackage.haskell.org/packages/archive/dlist/0.5/doc/html/Data-DList.html
14:03:28 <rwbarton> well DList is the name of a type in Haskell
14:03:32 <rwbarton> this paper is about math
14:03:41 <rwbarton> so what do you think the Haskell type DList is supposed to represent in math
14:04:09 * hackagebot Blobs 0.3 - Diagram editor  http://hackage.haskell.org/package/Blobs-0.3 (AlanZimmerman)
14:04:20 <rwbarton> if it's just functions of the form \xs -> something ++ xs then it is isomorphic to ordinary lists
14:04:31 <rwbarton> if it's all functions [a] -> [a] then I have no idea
14:05:02 <rwbarton> how do you even define snoc then
14:05:17 <tgeeky> rwbarton: I often hear the term "left linear trees" attributed to snoc-lists
14:05:28 <rwbarton> okay
14:05:34 <rwbarton> like a linked list where the arrows "point left"?
14:06:13 <shachaf> rwbarton: You like golfing things, right?
14:06:15 <shachaf> @where pi_10
14:06:15 <lambdabot> (!!1)<$>transpose[show$sum[(8-i.&.3*4)*div(1000^2^n)(a^i*i)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]
14:06:16 <shachaf> @where pi_11
14:06:17 <tgeeky> hm. That's not what I thought of. Like a list which is built by left-associated tupling.
14:06:17 <lambdabot> [show(sum[(8-i.&.3*4)*div(1000^2^n)(a^i*i)|i<-[1,3..9*2^n],a<-[2,3]])!!n|n<-[0..]]
14:06:18 <nand`> right folds can be implemented in terms of reverse and cons instead of snoc, too
14:06:36 <tgeeky> nand`: yep, although DList only implements r* versions
14:06:43 <rwbarton> sure, that is basically the same thing
14:06:56 <tgeeky> rwbarton: hm. I never thought of it that way.
14:07:00 <shachaf> tgeeky: That's just a reversed list right?
14:07:05 <shachaf> As in what they use for a list zipper.
14:07:11 <rwbarton> like a list where your notions of "left" and "right" are backwards
14:07:36 <shachaf> s/t r/t, r/
14:07:46 <rwbarton> like http://en.wikipedia.org/wiki/File:Singly-linked-list.svg but mirrored horizontally
14:07:58 <rwbarton> shachaf: Left.
14:08:17 <tgeeky> rwbarton: like the top of page 7 of this link: http://www.cs.ox.ac.uk/ralf.hinze/Lifting.pdf
14:08:27 <tgeeky> "Second, we turn u into a left-linear tree"
14:10:14 <rwbarton> okay
14:10:31 <shachaf> data Moral a b = Wrong a | Right b
14:10:37 <tgeeky> rwbarton: no surprise, these are the monodial laws again
14:10:43 <rwbarton> what are?
14:10:50 <tgeeky> rwbarton: the laws listed in norm2
14:10:55 <tgeeky> on page 7
14:10:59 <rwbarton> i don't really understand the context of this norm2
14:11:31 <rwbarton> but i think it is something about rewriting certain kinds of expressions involving applicative functors into a normal form
14:11:39 <tgeeky> rwbarton: it is exactly that
14:11:46 <tgeeky> rwbarton: all kinds of expressions
14:13:32 <tgeeky> rwbarton: thanks for you help and prodding
14:14:01 <rwbarton> these are really the laws for applicative right, not for a monoid
14:14:10 * hackagebot sodium 0.5.0.0 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.5.0.0 (StephenBlackheath)
14:14:17 <tgeeky> rwbarton: "The correctness of the second transformation relies on the monoidal laws."
14:14:25 <tgeeky> they are the monodial laws plus the special one
14:14:46 <tgeeky> involving Var in the right slot of :* (which is Pair)
14:15:28 <rwbarton> well in any case I'm pretty sure they are talking about the laws that appear on page 4 ...?
14:15:48 <bitonic> has anybody actually used sodium?
14:15:54 <bitonic> is it nice?
14:16:54 <armlesshobo> is there a way to build 'base' as shared?
14:16:55 <hiptobecubic> lispy, how would i know?
14:17:35 <tgeeky> rwbarton: oh, yes, that's right. Page 7 is the normalform for the symmetric form of applicative
14:18:10 <tgeeky> the distinction in the library I have (transcribing the work in this Hinze paper), is that page 7 is the GADT form, and page 4 is the "regular" form
14:20:57 <gzmask> what is the function that applies a boolean function to a list, if true, returns the value?
14:21:22 <gzmask> kind of like filter but halt on the first true return value
14:21:33 <Peaker> gzmask, head . filter p
14:21:33 <rwbarton> @hoogle (a -> Bool) -> [a] -> Maybe a
14:21:34 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
14:21:34 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
14:21:34 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
14:21:49 <rwbarton> or that
14:21:51 <Peaker> or those :)
14:21:55 <tgeeky> rwbarton: haha. it's called find. Who knew!
14:22:03 <rwbarton> I did :P
14:22:08 <tgeeky> true enough :o
14:22:11 <rwbarton> but I like to demonstrate hoogle
14:22:24 <rwbarton> (also, i wasn't 100% sure)
14:22:30 <tgeeky> hoogle is almost the awesomest thing around.
14:22:38 <gzmask> never know I can use hoogle that way...
14:22:39 <nand`> yeah, just below Haskell
14:22:40 <gzmask> thanks!
14:23:03 <shachaf> @hoogle (a -> Bool) -> [a] -> a
14:23:04 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
14:23:04 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
14:23:04 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
14:23:14 <shachaf> How clever of Hoogle.
14:23:22 <dschoepe> tgeeky: Do you know about Hayoo? :)
14:23:28 <tgeeky> I do.
14:23:43 <tgeeky> I forget which one doesn't return results for all packages unless you explicitly list them
14:23:48 <tgeeky> whichever one that is, boooo
14:24:08 <dschoepe> tgeeky: Hoogle, iirc. Hayoo searches all of Hackage.
14:24:10 <hpaste> x annotated “mastermind, for fun” with “mastermind, for fun (annotation)” at http://hpaste.org/70179#a70187
14:24:11 <tgeeky> dschoepe: those are the #1 and #2 buttons in my browser
14:24:11 <nand`> hoogle definitely does that
14:24:38 <dschoepe> (which is why I tend to prefer hayoo mostly)
14:24:42 <nand`> “!hoogle” has become so pervasive in my daily life that I often accidentally search hoogle when I meant to search the internet instead
14:25:03 <bitonic> nand`: I'd worry about that.
14:25:04 <tgeeky> newsham: hehe :)
14:25:36 <Peaker> hoogle indexes so few functions I think I already memorize the indexed part
14:25:37 <newsham> tgeeky: ?
14:25:58 <nurpax> hi! is there an easy way with mvars and control.concurent to do select-style reading of multiple sockets/chans?  I have seen an example where STM is used for this, but I would still like to avoid refactoring my code for STM
14:25:59 <tgeeky> newsham: s/newsham/nand`/
14:26:16 <c_wraith> nurpax: you can forkIO a couple new threads - one to read from the channel, one to read from the socket.  Both will write to a new channel, and you just read from that.  Not ideal, but relatively simple.  (If they want to write different types, have it be a channel of Eithers)
14:26:18 <tgeeky> nurpax: I think there's a package specifically designed around select
14:26:36 <tgeeky> nurpax: http://hackage.haskell.org/package/select
14:26:40 <mgsloan> Has anyone written / seen something that runtime shows a type, or better yet, yields a TH AST?  In other words, I want (typeShow :: TypeShow a => a -> String)  such that (typeShow (undefined :: Int) == "Int")
14:27:09 <rwbarton> > typeOf (undefined :: Int)
14:27:10 <lambdabot>   Int
14:27:14 <rwbarton> @type typeOf
14:27:15 <lambdabot> forall a. (Typeable a) => a -> TypeRep
14:27:20 <mgsloan> ahhh of course
14:27:25 <tgeeky> > typeOf (undefined: a really annoying long phrase that shouldnt be a type)
14:27:26 <lambdabot>   <no location info>: parse error on input `type'
14:27:27 <tgeeky> whoops
14:27:29 <mgsloan> thanks! Forgot about that
14:27:33 <tgeeky> > typeOf (undefined :: a really annoying long phrase that shouldnt be a type)
14:27:34 <rwbarton> I dunno what a TypeRep really is but try that
14:27:34 <lambdabot>   <no location info>: parse error on input `type'
14:28:21 <nurpax> c_wraith: thanks.  my current design is more or less like that.  just felt like these extra chans add complexity.
14:28:33 <nurpax> tgeeky: cheers, will take a peek
14:28:40 <mgsloan> it's silly, I must have sub-consciously remembered that, because I called my typeclass to do this "TypeRep"
14:28:56 <gzmask> okay... project euler question: https://gist.github.com/2956578   how to reduce my impossible-algorithm?
14:29:04 <tgeeky> Typable is changing in 7.6, I think
14:29:09 <v{}id> (.&.)
14:29:22 <v{}id> sorry
14:29:48 <tgeeky> mgsloan: what are you working on now you crafty kid?
14:29:54 <mgsloan> tgeeky: Really? Breaking changes?
14:30:15 <c_wraith> typeable already changed.
14:30:19 <mgsloan> tgeeky:  Oh, you know, just resolving the superclass defaults thing :)
14:30:34 <tgeeky> mgsloan: oh just that? You should be done by brinner!
14:31:12 <AAAAAAAAAAAa> Hey...
14:31:16 <mgsloan> Yeah, I thought it'd be quicker than it turned out - a little bit messy - but getting there!
14:31:18 <tgeeky> i smell a ban coming soon
14:31:45 <AAAAAAAAAAAa> I'm new to haskell and I have a problem
14:31:50 <hpaste> hiptobecubic pasted “hanging cabal (verbose)” at http://hpaste.org/70188
14:32:42 <hiptobecubic> I don't see anything in there that makes it any clearer, but maybe someone does
14:32:52 <AAAAAAAAAAAa> is simple, someone help me
14:33:04 <AAAAAAAAAAAa> complicated to me to read the entry.
14:33:16 <AAAAAAAAAAAa> I need to load a matrix by inputting going lines
14:33:23 <rwbarton> hiptobecubic: you said it is hanging with 0% cpu usage?
14:33:24 <AAAAAAAAAAAa> But I can not do it
14:33:35 <AAAAAAAAAAAa> It is easy but I can not even read a line
14:33:39 <hiptobecubic> rwbarton, yes
14:33:48 <AAAAAAAAAAAa> Not what I'm doing wrong
14:34:11 * hackagebot snaplet-acid-state 0.2.1 - acid-state snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-acid-state-0.2.1 (DougBeardsley)
14:34:28 <avpx> AAAAAAAAAAAa: You're spamming the channel with your enter key and haven't even told us what your problem is.
14:35:23 <mgsloan> AAAAAAAAAAAa: perhaps look into the "lines" and "words" functions?
14:35:58 <mgsloan> > map words (lines "1 2 3\n4 5 6\n7 8 9")
14:35:59 <lambdabot>   [["1","2","3"],["4","5","6"],["7","8","9"]]
14:36:54 <rwbarton> wow cabal -v3 install spews a lot of stuff
14:36:58 <hiptobecubic> > read $ map words (lines "1 2 3\n4 5 6\n7 8 9") :: [[Int]]
14:37:00 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:37:00 <lambdabot>         against inferred type...
14:37:26 <hiptobecubic> > (read $ map words (lines "1 2 3\n4 5 6\n7 8 9")) :: [[Int]]
14:37:28 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:37:28 <lambdabot>         against inferred type...
14:37:31 <hiptobecubic> oh well
14:38:04 <hiptobecubic> > (readList $ map words (lines "1 2 3\n4 5 6\n7 8 9")) :: [[Int]]
14:38:06 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:38:06 <lambdabot>         against inferred type...
14:38:08 <mgsloan> hiptobecubic: read only works on strings, and it's expecting list syntax there
14:38:12 <hiptobecubic> ah ok
14:38:23 <mgsloan> > (read $ show $ map words (lines "1 2 3\n4 5 6\n7 8 9")) :: [[Int]]
14:38:23 <AAAAAAAAAAAa> layers expese me wrong
14:38:24 <lambdabot>   *Exception: Prelude.read: no parse
14:38:27 <mgsloan> hmm
14:38:30 <AAAAAAAAAAAa> ahhhh
14:38:32 <mgsloan> ahh because of all the quotes
14:38:35 <hiptobecubic> yeah
14:39:03 <mgsloan> > (read $ filter (not . (=='"')) $ show $ map words (lines "1 2 3\n4 5 6\n7 8 9")) :: [[Int]]
14:39:05 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
14:39:13 <rwbarton> gross
14:39:15 <rwbarton> :P
14:39:17 <mgsloan1> :)
14:39:17 <hiptobecubic> seems like a pretty ugly solution
14:39:19 <tgeeky> hiptobecubic: ok, well the files that it hasn't touched yet in your log [ n of 15] are Language.C and Language.C.Quote
14:39:22 <peddie> > (map (map read) $ map words (lines "1 2 3\n4 5 6\n7 8 9")) :: [[Int]]
14:39:23 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
14:39:24 <mgsloan1> oh yeah, of course, that's awful
14:39:52 <rwbarton> though i must admit to similarly awful tricks with read in the pst
14:39:54 <rwbarton> past
14:39:58 <AAAAAAAAAAAa> I think what the problem was understood, I will try. thanks
14:40:29 <AAAAAAAAAAAa> layers expese me wrong
14:40:37 <hiptobecubic> tgeeky, Language.C.Smart seems like the issue?
14:40:42 <AAAAAAAAAAAa> I made a program that solves sudoku.
14:40:50 <AAAAAAAAAAAa> my problem is I have to load an matrix line by line by entering
14:41:03 <tgeeky> hiptobecubic: maybe. I was just noting that the ones it hasn't touched yet are the two i mentioned
14:41:09 <adnauseam> is zip [1..] "ab" in weak head normal form ?
14:41:14 <tgeeky> hiptobecubic: ie, it was trying to link before compiling those two
14:41:22 <rwbarton> like parsing commands like "cmd arg1 arg2 arg3" into an AST with a derived Read instance--after capitalizing the command name
14:41:24 <hiptobecubic> hm
14:41:39 <adnauseam> i'm somewhat confused since tht cons there doesn't have the accompanying []
14:41:51 <rwbarton> adnauseam, it's an application of a function so no
14:42:30 <rwbarton> whnf basically means it looks like the application of a data constructor
14:42:42 <cschneid> So the syntax for pattern matching   foo@(Something _) is "I want the whole foo variable in this code, but only match if it's of type Something?
14:42:59 <tgeeky> hpaste: I'll try to install and see what happens
14:43:06 <tgeeky> lol. lazy me.
14:43:08 <tgeeky> hiptobecubic: ^^
14:43:11 <rwbarton> cschneid: Something is a data constructor, not a type, otherwise yes
14:43:23 <rwbarton> match if the value was constructed with the Something data constructor
14:43:37 <cschneid> ok, great. But don't attempt to unwrap the contents of the Something data I have.
14:43:54 <cschneid> sorry for terms being wrong :) lots of them flying around.
14:43:58 <hiptobecubic> tgeeky, it worked on a different machine earlier today. completely different setup though. different distro as well
14:44:03 <rwbarton> it won't try to evaluate the field of the Something constructor
14:44:05 <hiptobecubic> same cabal/ghc though
14:44:14 <tgeeky> hiptobecubic: I'm on windows, so it's even differenter
14:44:23 <rwbarton> hiptobecubic, I tried installing it and, well, it is still going :)
14:45:25 <rwbarton> and not because it is stuck using 0% cpu while building Language.C.Smart :)
14:45:48 <rwbarton> anyways my guess would be Language.C.Smart has some template haskell (why else would it be loading Haskell packages while building it) that is misbehaving
14:46:50 <hiptobecubic> hmm
14:46:53 <hiptobecubic> what version of cabal are you using?
14:46:56 <tgeeky> hiptobecubic: I'm bowing out. I can't install the latest alex without breaking ghc
14:47:02 <rwbarton> me?
14:47:04 <hiptobecubic> fair enough
14:47:17 <tgeeky> i'm using 0.14.0
14:47:19 <rwbarton> from the looks of it i will have to go before this finishes anyways
14:47:29 <tgeeky> rwbarton: thanks for help seriously :)
14:47:46 <hiptobecubic> used 0.10.2 earlier, have 0.14.0 now
14:48:57 <adnauseam> rwbarton: even if we take the definition of it? it is defined as (a,b) : zip as bs
14:49:49 <adnauseam> sorry to second question you there, i just want to calm my doubts
14:49:52 <rwbarton> "(a,b) : zip as bs" is in weak head normal form
14:50:17 <rwbarton> being in WHNF isn't a property of a value, any non-bottom value has one
14:50:46 <monochrom> ⊥:⊥ is in WHNF too :)
14:50:48 <rwbarton> "taking the definition" is part of the process of evaluation by which we find that value
14:50:54 <adnauseam> mhm
14:51:02 <tgeeky> hiptobecubic: I'm getting that the #if !MIN_VERSION_template_haskell(2,7,0)   <-- is messed up
14:51:19 <adnauseam> monochrom: does your definition of : there come to mean that it's a complete list, or is it missing the [] there ?
14:51:22 <hiptobecubic> i think it only took twenty minutes or so to go from clean system to a working accelerate-cuda
14:51:41 <adnauseam> meaning that a list constructor, even if missing it's nil, is in WHNF ?
14:51:48 <hiptobecubic> tgeeky, with ghc-7.4.2?
14:52:03 <monochrom> ⊥:⊥ is already in WHNF. I don't need []
14:52:29 <monochrom> I don't know what is "complete" and perhaps it's beside the point
14:52:35 <tgeeky> hpaste: 7.4.1
14:52:46 <adnauseam> rwbarton: hrm, so basically if i only had zip [1..] "ab", it'd be a defacto application, but if i take the definition into account when it's given, it's in WHNF ?
14:52:51 <rwbarton> so "reducing to WHNF" means a specific amount of evaluation, often when we use this phrase we are effectively talking about GHC implementation (something in memory is actually changing, to replace a thunk by a constructor), but formally I guess being in WHNF is a property of an expression
14:52:59 <monochrom> > case (undefined : undefined) of _:_ -> "hi"
14:53:00 <lambdabot>   "hi"
14:53:11 <adnauseam> monochrom: ⊥:⊥ = [⊥,⊥] ?
14:53:15 <monochrom> that should be an illustrative example
14:53:18 <rwbarton> adnauseam, did that answer your question
14:53:39 <monochrom> no, not the same. forget the notation [x,y,z] altogether. syntax sugar.
14:53:55 <rwbarton> in Haskell we can afford to treat zip [1..] "ab" and [(1, 'a'), (2, 'b')] as being the same in most contexts
14:54:02 <monochrom> so-called [x,y,z] is really x:y:z:[]
14:54:03 <rwbarton> but not when we are talking about the process of evaluation
14:54:17 <hiptobecubic> theorbtwo, but i'm on 7.4.2, how could template-haskell be too old?
14:54:47 <adnauseam> rwbarton: i'm trying to understand your answer ;p bare with me
14:54:59 <tgeeky> hiptobecubic: oh, no, I'm suggesting that it's malformed CPP syntax or something (though it doesn't appear to be)
14:55:06 <hiptobecubic> ho
14:55:07 <hiptobecubic> oh*
14:55:08 <tgeeky> hiptobecubic: I get: Smart.hs:45:0:  error: missing binary operator before token "("
14:55:14 <tgeeky> when I try to ghci Smart.hs
14:55:25 <hiptobecubic> can you ghci template-haskell?
14:55:42 <tgeeky> yeah TH works fine for me
14:55:44 <adnauseam> yeah that's my understanding of WHNF too
14:56:20 <adnauseam> must cons be always accompanies by a nil ?
14:56:26 <adnauseam> accompanied*
14:56:29 <hiptobecubic> tgeeky, yeah... same error
14:56:30 <monochrom> no
14:56:33 <tgeeky> hiptobecubic: https://code.google.com/p/uhc/issues/detail?id=49
14:56:47 <adnauseam> monochrom: would be considered WHNF if it wasn't ?
14:56:50 <adnauseam> would it
14:57:14 <monochrom> yes, I showed an example, ⊥:⊥, a cons cell, nothing else, no nil
14:57:24 <adnauseam> now i understand \
14:57:28 <monochrom> lambdabot even accepted it
14:57:37 <adnauseam> oh did it, sorry i didn't see that
14:57:58 <monochrom> <monochrom> > case (undefined : undefined) of _:_ -> "hi"
14:57:58 <monochrom> <lambdabot>   "hi"
14:58:22 <hiptobecubic> I guessi can comment that block out, and just assume i have a high enough TH version
14:58:30 <hiptobecubic> we'll see how far it gets
14:58:35 <adnauseam> i look up case to better understand that statement
14:58:41 <hiptobecubic> also, i would have expected a more graceful death from cabal
14:59:08 <mgsloan1> hiptobecubic: TH largely works in GHCI, but some bits of it don't, as you can't run the Q monad in the prompt
14:59:13 <mgsloan1> which kinda sucks
14:59:25 <hiptobecubic> sadly, that means nothing to me
14:59:36 <tgeeky> hiptobecubic: I don't think it's relevant
14:59:40 <tgeeky> this is a CPP macro problem
14:59:40 <mgsloan1> it isn't
15:00:24 <hiptobecubic> well i commented it out and it didn't seem to solve anything
15:03:10 <tgeeky> hiptobecubic: there are more CPP errors. one sec. let me see what's going on with that specifically
15:03:17 <hiptobecubic> yeah there are a few in different files
15:04:05 <hpaste> d-snp pasted “Get Monad” at http://hpaste.org/70189
15:04:08 <quicksilver> @tell lysgaard It is rather deeper than merely haskell not being able to infer the property. It is because the generating function is not inspectable; and furthermore functions *cannot* be inspectable without violating referential transparency. (or restricting the notion of function).
15:04:09 <lambdabot> Consider it noted.
15:05:14 <d-snp> I thought I was doing ok with the get monad, but it seems I still don't really get it
15:05:45 <d-snp> why is parseGap of type Get (a,b) instead of a -> Get (b,c) ?
15:06:29 <hpc> d-snp: where's the parameter to parseGap?
15:06:38 <hpc> "let parseGap = do..."
15:07:06 <d-snp> hmmm
15:07:29 <d-snp> oohhh I'm missing runGet
15:07:39 <tgeeky> hiptobecubic: try moving the template-haskell dependency that is conditional the .cabal file, out from underneath the conditional
15:07:39 <hiptobecubic> If i <C-c> to interrupt it, the stacktrace claims  that it was doing some TH thing
15:07:53 <hiptobecubic> Language/C/Smart.hs:118:13:
15:07:53 <hiptobecubic>     Exception when trying to run compile-time code:
15:07:53 <hiptobecubic>       user interrupt
15:07:53 <hiptobecubic>       Code: Language.Haskell.TH.Quote.quoteExp cstm "$exp:e1 = $exp:e2;"
15:08:22 <d-snp> thanks hpc :)
15:09:23 <tgeeky> hiptobecubic: just to satisfy my curiosity, will you hpaste: dist/build/autogen/cabal_macros.h
15:10:45 <d-snp> hmm that's not entirely it
15:11:24 <hpaste> hiptobecubic pasted “cabal_macros.h” at http://hpaste.org/70190
15:11:31 <hiptobecubic> tgeeky, ^
15:12:15 <tgeeky> hiptobecubic: ok. that looks fine to me.
15:15:09 <hiptobecubic> I don't get it
15:16:42 <d-snp> hpc I don't get it, runGet will just execute a new parse in a new monad, how would I run the parseGap statements in the mapM?
15:17:17 <tgeeky> hiptobecubic: I really wish I were brave enough to break my entire install.
15:17:21 <tgeeky> hiptobecubic: maybe I can cabal-dev it
15:17:26 <hiptobecubic> tgeeky, me too ;)
15:18:07 <tgeeky> ah crap. I think I just broke it anyway, installing cabal-dev. We're about to find out :/
15:18:27 <hiptobecubic> my local ghc is only 7.4.1... guess it's time to throw out everything and reinstall for 7.4.2!
15:18:38 <tgeeky> heh
15:18:50 <hiptobecubic> note that this problem is on a server in outer space where i have no admin access. not my home computer
15:18:52 <tgeeky> every time I do that, they release another new version with awesome features that I convince myself I'd want
15:19:15 <tgeeky> hiptobecubic: funny, unless you work for NASA
15:19:27 <hpc> d-snp: i have no idea what the solution is, just pointing out that parseGap isn't a function because it isn't defined as one
15:19:30 <hiptobecubic> i usually don't know enough to use whatever the features are, but some library will claim to use them and so i have no choice.
15:19:35 <hpc> you aren't parameterizing over anything
15:19:36 <hiptobecubic> in this case it's accelerate-cuda that i'm after
15:19:42 <hpc> and you aren't in the (e ->) monad
15:19:54 <hpc> so it can't possibly have the type (a -> Anything)
15:20:59 <d-snp> hmm
15:22:30 <d-snp> oh shit hpc I see what I did wrong now
15:23:04 <hiptobecubic> haskell libraries always have such great names
15:23:08 <hiptobecubic> "exception-transformers"
15:24:36 <d-snp> hpc: I forgot to throw away the parameter
15:24:53 <d-snp> and ofcourse haskell calls repeat replicate, which is why I didn't find it at first
15:24:53 <hiptobecubic> 2GB ram really just isn't enough to build haskell programs
15:25:07 <hiptobecubic> you need at least 102418050GB
15:25:20 * Peaker is happily using 2GB of RAM on a rather old laptop
15:25:39 <shoerain> Peaker: you've avoided the upgrade craze! Hoorah!
15:25:58 <hiptobecubic> well i updated cabal on this laptop to 0.14.0, just like my remote server, and i just built language-c-quote without a problem
15:26:00 <shoerain> I suspect you've saved a few grand in computers alone, but also avoided setup times.
15:26:08 <hiptobecubic> with no changes to anything, ugly CPP code and all
15:26:25 <Peaker> shoerain, the truth is that my laptop is from my employer, and he doesn't want to upgrade it :P
15:26:43 <Peaker> shoerain, I could use a new battery at the very least..
15:27:03 <hiptobecubic> HP dv6700 here. it's held up surprisingly well
15:27:03 <hiptobecubic> the power adapter is a pile of garbage. replaced many times
15:27:03 <hiptobecubic> but the rest has been ok
15:27:10 <hiptobecubic> Peaker, indeed....
15:27:20 <hiptobecubic> Peaker, how long does it last?
15:27:38 <Peaker> ~50 minutes
15:27:46 <Peaker> when it was new, it lasted 2.5-3 hours I think
15:27:47 <hiptobecubic> i get ~20 minutes from 100% to "won't even try light up anymore"
15:28:02 <Peaker> but I replaced my HDD with SSD, probably less power intensive
15:29:02 <hiptobecubic> ah
15:29:10 <hiptobecubic> yeah i haven't replaced anything in this
15:29:20 <hiptobecubic> since i got it in 07
15:30:00 <hiptobecubic> I just recently ordered a new thinkpad though. It's a bittersweet upgrade
15:30:06 <hiptobecubic> This laptop and I have been through a lot.
15:30:57 <shoerain> thinkpads! there ought to be one-size-fit-all batteries so you don't get stupid laptop-specific junk
15:31:01 <d-snp> I still don't get why you would opt for a thinkpad instead of a macbook?
15:31:13 <shoerain> but thinkpads are awesome!
15:31:18 <tehgeekmeister> so i'm trying to think through whether there's an efficient way to use STM for this problem.  i want to remove (and add) items to/from a set, just get any old item back when you remove, but obviously add specific items on when you're adding.  since you can pick an element at random, you can avoid most of the retries, so STM seemed a good fit.
15:31:26 <d-snp> yes, if you like carrying a tank everywhere
15:31:29 <Peaker> d-snp, for me it is an ethical thing, I think Apple is an unethical company so I would rather not pay them
15:31:33 <hiptobecubic> because apple is still retardedly restrictive about what you can do with your hardware
15:31:43 <shoerain> the x series (sans tablet) are quite lightweight
15:31:49 <tehgeekmeister> but, i think there's a flaw in this.  if you put a Set or somesuch in a TVar, any change to the set will cause concurrent transactions to fail
15:31:50 <shoerain> and the macbook pros are rather tankish themselves
15:32:03 <hiptobecubic> I had a really difficult time decided between the x230 and t430
15:32:05 <tehgeekmeister> and if you make a set of TVars, you lose the benefit.
15:32:15 <shoerain> hiptobecubic: iunno, torvalds is using an air, so it suits him, right?
15:32:19 <tehgeekmeister> anyone know if my thinking is right?
15:32:21 <Peaker> tehgeekmeister, atomicallyModifyIORef? :)
15:32:42 <hiptobecubic> the air really doesn't have the balls that i need
15:33:11 <tehgeekmeister> Peaker: i suspect that is a joke.
15:33:27 <d-snp> shoerain: have you ever used a macbook? do you really think they're tankish?
15:33:55 <hiptobecubic> the hardware is nice
15:33:59 <Peaker> tehgeekmeister, I'm not sure what you want to do, but atomicallyModifyIORef is a pretty powerful hammer
15:34:11 <Peaker> tehgeekmeister, for fast sync'ing of a single variable amongst threads
15:34:36 <d-snp> I sort of agree with the apple being an evil company thing, but their laptop hardware is all open standard so no evil stuff going on there
15:34:37 <tehgeekmeister> Peaker: where does it live?  i tried hoogle and it didn't find it.  didn't see it in STM.
15:35:08 <hiptobecubic> d-snp, if you want to use osx then sure, it's great
15:35:19 <d-snp> nooo, it's not about osx at all
15:35:25 <d-snp> it's about that the macbooks are better laptops
15:35:37 <hiptobecubic> but i've been watching all my friends deal with "this library doesn't work on mac" for two years now
15:36:16 <hiptobecubic> and then there was some garbage about dual booting as well, you're forced through boot camp and you can't install from usb and all kinds of disgusting crap that shouldn't happen
15:36:46 <d-snp> that's not apple's fault
15:37:02 <d-snp> windows just didn't support booting from EFI
15:37:10 <Peaker> @hoogle atomicallyModifyIORef
15:37:10 <lambdabot> No results found
15:37:28 <hiptobecubic> d-snp, it's not? my hp boots from usb just fine and boots windows just fine as well.
15:37:28 <Peaker> @hoogle atomicModifyIORef
15:37:29 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
15:37:36 <tehgeekmeister> Peaker: yeah, that doesn't provide the benefits of STM.  Seems like I'd have to reimplement STM on top of it.
15:37:46 <d-snp> my macbook boots from usb just fine too
15:37:49 <Peaker> tehgeekmeister, what are you syncing between threads, besides a single Set?
15:38:16 <hiptobecubic> maybe they've fixed it then. his is a few years old now
15:38:28 <tehgeekmeister> just the Set, but if two threads pop the same item off, one of them needs to retry and get a different item
15:38:40 <tehgeekmeister> that's where STM is convenient
15:38:48 <Peaker> tehgeekmeister, you can't pop the same item off...
15:38:56 <hiptobecubic> tgeeky, do we give up on this thing or are you still breaking everything?
15:39:37 <tehgeekmeister> sure, you can't that way, but you also lock every thread on every other one
15:39:37 <hiptobecubic> i think it's a tough argument to claim that macbooks are nicer than thinkpads anyway
15:39:43 <Peaker> tehgeekmeister, if you make a pure set-pop function, it will execute atomically
15:39:48 <Peaker> tehgeekmeister, without any locks
15:39:52 <hiptobecubic> also i don't want a glass screen
15:40:08 <hpc> newer thinkpads have impossibly nice innards
15:40:34 <Peaker> say you have:  popSet :: Set a -> (Set a, Maybe a)   that pops a random/selected element and returns the new set.  You can    atomicModifyIORef popSet    and it will pop the item atomically
15:41:10 <ousado> hpc: and you can exchange broken parts
15:41:16 <Peaker> tehgeekmeister, it's a neat trick -- it utilizes laziness such that the atomicModifyIORef doesn't actually have to do the work, only replace the thunk ptr
15:41:28 <tehgeekmeister> but while that atomic operation happens, the other threads have to wait, no?
15:42:02 <hiptobecubic> how is that worse than waiting for a lock?
15:42:09 <hpc> tehgeekmeister: all it should need to do is write a pointer
15:42:10 <Peaker> tehgeekmeister, nope, it's an atomic ptr xchg, with a tight loop to handle the case where a different thread xchg'd first, and xchg again
15:42:17 <hpc> surely your other threads can wait on an 8-byte write
15:42:36 <tehgeekmeister> yes, they can
15:42:47 <tehgeekmeister> now this is a harder sell for my coworkers, though
15:42:49 <Peaker> hiptobecubic, tehgeekmeister: There's no "wait" here, just a very rare case of collisions that would cause an extra few instructions to execute
15:43:00 <tehgeekmeister> but it does sound awesome
15:43:23 <hiptobecubic> Peaker, i haven't really been following... we're discussing stm i guess?
15:43:31 <Peaker> tehgeekmeister, I think one of the Simons had a paper comparing a thread-sync'd linked list with TVars, MVar's, and atomicModifyIORef, and the last was far faster
15:43:40 <Peaker> hiptobecubic, atomicModifyIORef
15:43:56 <hiptobecubic> Peaker, is that not based on stm?
15:43:58 <Peaker> no
15:44:17 <Peaker> it's based on atomic xchg instructions of the underlying cpu
15:44:21 <hiptobecubic> How does it preserve atomicity?
15:44:37 <hiptobecubic> oh
15:44:56 <tehgeekmeister> wow, that really would be the ideal way to do this
15:45:00 <tgeeky> hiptobecubic: well, cabal-dev install didn't break everything, so now I try
15:45:20 <hiptobecubic> tgeeky, ghc-7.4.2?
15:45:30 <tgeeky> 7.4.1 right now.
15:45:37 <tgeeky> I think I have 7.4.2 installed somehwere
15:45:44 <hiptobecubic> 7.4.1 worked for me on my laptop
15:45:49 <hiptobecubic> with cabal 0.14.0
15:46:01 <hiptobecubic> the server has 7.4.2
15:46:10 <hiptobecubic> that's the only difference i can see
15:46:25 <Peaker> tehgeekmeister, http://ww2.cs.mu.oz.au/~sulzmann/publications/performance-concurrent-linked-list-haskell.pdf  <-- there it is
15:48:09 <Peaker> the CPU instruction used for atomicity is just "compare-and-swap" which may fail and then you just loop
15:49:15 * hackagebot Metrics 0.1.1 - Evaluation metrics commonly used in supervised machine learning  http://hackage.haskell.org/package/Metrics-0.1.1 (BenHamner)
15:52:30 <tehgeekmeister> Peaker: weird that CAS performs so well but the speedup of CASusingSTM is higher?
15:52:48 <Peaker> tehgeekmeister, I don't remember the TLAs
15:52:49 <Peaker> CAS?
15:53:00 <tehgeekmeister> atomicModifyIORef
15:53:07 <tehgeekmeister> (compare and swap == cas)
15:53:17 <tehgeekmeister> and CASusingSTM was a combination of stm and cas
15:54:37 <hiptobecubic> tgeeky, still building?
15:55:00 <Peaker> tehgeekmeister, how did they combine them?
15:55:16 <tehgeekmeister> Peaker: ionno, haven't read details yet.  lemme check
15:55:28 <tgeeky> hiptobecubic: just installed 7.4.2
15:55:29 <Peaker> tehgeekmeister, I read it a loong time ago
15:55:35 <Peaker> tehgeekmeister, but clearly the cas trick left an impression :)
15:56:19 <tehgeekmeister> oh, CASusingSTM is just compare and swap done in software
15:56:22 <tehgeekmeister> no wonder it's slower
15:57:03 <tehgeekmeister> oh, interesting
15:57:10 <Peaker> tehgeekmeister, but you said the speedup of CASusingSTM is higher?
15:57:13 <tehgeekmeister> i was misreading the graphs
15:57:23 <tehgeekmeister> CAS is absolutely faster
15:57:32 <tehgeekmeister> but CASusingSTM speeds up more as you add more cpus
15:57:38 <tehgeekmeister> it's just still slower overall
15:57:51 <tgeeky> hiptobecubic: starting a new build now. 7.4.2
15:58:11 <tehgeekmeister> in any case, i don't think i can sell this to my coworkers
15:58:19 <tehgeekmeister> was hoping to get to use some haskell soon
15:58:20 <tehgeekmeister> oh well
15:58:20 <hiptobecubic> tgeeky, well if it works, i won't know what to do
15:58:47 <tgeeky> what we always do, pray to the lambda gods
15:59:00 <Peaker> a friend of mine used lots of Haskell at the new company he worked for, I heard he got in trouble with the dev. boss
15:59:01 <tgeeky> for forgiveness for our Bins (and Tips)
16:00:49 <hiptobecubic> getting ready to pack it in, be back in a few minutes to see if you succeeded
16:03:30 <tgeeky> hiptobecubic: success
16:04:00 <tgeeky> hiptobecubic: I got all of the linking messages after [11 of 15] -- Language.C.Smart
16:04:17 * hackagebot Metrics 0.1.2 - Evaluation metrics commonly used in supervised machine learning  http://hackage.haskell.org/package/Metrics-0.1.2 (BenHamner)
16:12:54 <tgeeky> hiptobecubic: so now I don't know what to do :)
16:23:07 <hiptobecubic> tgeeky, ok, it works for you then
16:23:16 <hiptobecubic> so it's hopeless for me :)   thanks for your help
16:23:19 <hiptobecubic> I'll dig into again tomorrow
16:24:35 <tgeeky> hiptobecubic: for what it's worth, I installed 7.4.2 (executable), then installed cabal-dev, then installed it with cabal-dev install
16:24:40 <tgeeky> and it worked fine all the way through
16:25:03 <hiptobecubic> tgeeky, ok. i'll try that tomorrow
16:25:04 <hiptobecubic> thanks
16:39:38 <parcs`> it would be cool if you can have pattern guards in do bindings
16:39:51 <parcs`> or guards in general
16:41:24 <copumpkin> would it desugar to something using MonadPlus?
16:41:35 <copumpkin> or MonadZero, more specifically
16:43:11 <narens> can anyone point me to good uses/practical examples of the Continuation monad? Is there any use for them without callCC?
16:44:05 <parcs`> do { a | b <- ... | c <- ...; f a; } would desugar to do { a <- (case () of _ | b -> ... | c -> ... | _ -> fail "blah blah blah"); f a; } or something
16:44:36 <parcs`> now that i wrote it out it would obviously conflict with pattern guard syntax
16:46:33 <hpc> narens: yes
16:46:40 <hpc> http://hpc.dyndns-web.com:8000/blog/view.cgi?id=11
16:47:03 <hpc> warning: have gtk2hs installed and a terminal handy
16:47:22 <narens> hpc: looks promising, thanks. it was just hard to find good sites
16:48:04 <parcs`> why doesn't the containers package export any of its containers' constructors at all? is it for performance reasons or something?
16:50:25 <hpc> parcs`: for not-breaking-the-insides reasons
16:50:47 <parcs`> :/
16:50:55 <hpc> you could knock a binary tree out of ordering, for instance
16:51:14 <hpc> being able to statically know that it behaves as advertised is nice :P
16:52:28 <parcs`> you could also implement functionality that can't be implemented without the constructors in scope
16:52:43 <shergill> i wish more package maintainers would follow the Foo.Internal approach
16:53:02 <hpc> agree
16:53:09 <hpc> actually, no
16:53:22 <hpc> i wish more package maintainers would use the naming convention when something is internal
16:53:39 <hpc> instead of having a top-level module with a huge list of modules re-exported
16:53:49 <hpc> all of which are "internal"
16:53:58 <shergill> that's not mutually exclusive
16:54:25 <hpc> well if you include those into the group of "packages using Foo.Internal", you catch a rather large segment of hackage
16:54:54 <shergill> i said 'not mutually exclusive', not that they're equivalent
16:55:11 <zzing> If I do an import LDAP, will I automatically be able to use stuff in LDAP.Init or do I have to include that too?
16:58:28 <parcs`> for instance Data.Set doesn't have indexing functions (like Int -> Set a -> a) and those absolutely can't be implemented without the constructors. now i'll have to maintain my own version of 'containers' and wait an indefinite amount of time for a new version of containers to come out
16:59:30 <parcs`> hmm actually i can convert a Set k into a Map k a and use the Map-indexing functions on that for the time being..
16:59:30 <tibbe> parcs`: we could make a new release pretty quickly if we like
17:00:18 <tibbe> parcs`: the current set of indexing functions on Map are quite yucky, calling error all over the place, so we didn't add them to Set until someone wanted them, at which point we have to think about what they actually ought to look like.
17:00:44 <parcs`> i see
17:01:37 <tibbe> there was also the question whether we should guarantee an ordered implementation, which is required for indexing functions.
17:01:48 <tibbe> I'm pretty sure we have to at this point.
17:01:59 <tibbe> since Ord is in method signatures
17:02:02 <tibbe> function*
17:02:39 <tibbe> worse, efficitive indexing requires an O(1) length implementation, as you need to know the size of subtrees
17:03:03 <tibbe> this will make it hard to switch e.g. to an AVL tree (we currently use size-balanced trees, which happens to have a cheap length implementation)
17:04:18 <JoeyA> Why would y'all switch to AVL (or anything without efficient length and indexing), anyway?
17:10:10 <parcs`> tibbe: i'm neutral about error vs Maybe, but i think it would be beneficial to merge 'elemAt' and 'deleteAt' into a single function
17:10:36 <tibbe> JoeyA: it might have more efficient, lookup, delete, etc
17:10:54 <parcs`> i'm not sure how costly the balancing functions are, though
17:10:58 <tibbe> parcs`: I'll let Milan give his opinion and then we'll add something
17:11:17 <tibbe> parcs`: they are the main cost as there's a bunch of allocation
17:11:35 <tibbe> elemAt is allocation free, deleteAt is not
17:14:49 <JoeyA> Playing around with (imperative) AVL implementations, my experience has been that allocation isn't terribly expensive.  My AVL implementation using non-destructive update was about 50% as fast as one using destructive update, even though the former allocates several nodes per operation.  [citation needed]
17:15:18 <JoeyA> But for Haskell, where comparison is more likely to be inlined (?), I suppose allocation takes a larger toll.
17:17:29 <JoeyA> (by imperative, I meant C)
17:27:48 <Phlogistique>  http://sprunge.us/XjQI I think this is a bug in Pandoc; any idea how to workaround?
17:40:07 <sordina3> Hi guys. I'm trying to build haskell-src-exts-1.13.3 with a recent build of GHC and I'm running into some errors of the type [Undefined symbols for architecture x86_64:]. Does anyone know where these stem from?
17:41:11 <sordina3> This is during the linking phase.
17:41:42 <shachaf> Some more information would be helpful.
17:41:57 <shachaf> For example, which OS you're using.
17:42:05 <geekosaur> that's OS X
17:42:10 <sordina3> Sure thing shachaf. Just wanted to see if anyone was interested.
17:42:13 <geekosaur> what would be helpfiul is, which symbols are undefined
17:42:19 <geekosaur> don't ask to ask, just ask
17:42:19 <sordina3> I'll paste the error output to a pastebin.
17:42:23 <geekosaur> if someone can answer, they will
17:42:37 <augur> what are "telescopes"?
17:42:41 <shachaf> sordina3: When you ask questions in IRC you should provide as much information as possible rather than a small bait to see whether it hooks anyone. :-)
17:43:01 <shachaf> augur: Aren't they those lists where the type of each element can depend on the type of the element before it?
17:43:04 <shachaf> Or something.
17:43:15 <augur> shergill: dunno!
17:43:28 <augur> er
17:43:30 <augur> shachaf:
17:43:32 <sordina3> geekosaur: While I agree in principal, the number of times I've created a large amount of information and got no useful response is dishartening, so I usually take this approach now :)
17:44:00 <shachaf> sordina3: Unfortunately when you're asking for help in IRC things are biased against you. :-)
17:44:11 <sordina3> (Although #haskell is nearly always good in this regard)
17:44:17 <geekosaur> there are some remarkably crappy channels on IRC; thankfully, #haskell isn't one of them
17:44:19 <shachaf> If someone offers to help and then it turns out they can't, they'll feel bad.
17:44:21 * hackagebot hbcd 1.0 - Packed binary-coded decimal (BCD) serialization  http://hackage.haskell.org/package/hbcd-1.0 (AndrewKay)
17:44:27 <shachaf> And people don't like feeling bad, so they won't even offer.
17:44:47 <shachaf> Whereas if they see that they can help you, they'll probably just do it.
17:45:41 <hpaste> sordina3 pasted “cabal error” at http://hpaste.org/70192
17:45:51 <sordina3> There we are.
17:46:24 <sordina3> Now, this is with a GHC head build from last night so I fully acknowlede that this is ill advised for making things 'just work'
17:46:26 <sordina3> :D
17:47:37 <sordina3> (Sorry about the spelling)
17:48:34 <geekosaur> hrm.  that looks like HEAD is a bit bugged
17:49:21 * hackagebot webserver 0.5.0.1 - HTTP server library  http://hackage.haskell.org/package/webserver-0.5.0.1 (JohnLato)
17:49:22 <geekosaur> those are functions that are provided by the runtime and should never be visible, especially as part of an error message
17:49:56 <sordina3> It does doesn't it... I'm just trying to get a handle on where these kinds of issues might come in. I'd like to be able to understand what's going on.
17:52:37 <geekosaur> I can tell you roughly what they are, but am not really a ghc dev so can't give details (like why ghc wraps those functions).  you might want to ask in #ghc (although I never saw much activity when I hung out there) or on the ghc list
17:53:26 <geekosaur> I can tell you __hscore_ prefix marks an internal function, and that they are involved with the POSIX signals API, but that's it.
17:54:03 <geekosaur> I also can't say if the problem is that they used to be exported and aren't any more, or something weird has gone with compiling such that it's generating references to functions that no longer exist or have different names
17:58:11 <sordina3> Hmm interesting. The thing that struck me is that these issues seem to be coming up now rather than much earlier.
17:58:50 <sordina3> I managed to install quite a few packages before I encountered this, so it's strange that internal functions would be being used by some libraries.
17:59:01 <hpaste> “_riba” pasted “grammar...” at http://hpaste.org/70194
17:59:07 <geekosaur> haskell-src-exts is one that is likely to be digging around in internals
17:59:23 <_riba> so
17:59:26 <sordina3> I think you're right.
17:59:39 <_riba> i haven't written haskell in ages, and i totally suck at reading the debug messages
17:59:40 <geekosaur> and therefore might either be using internals in ways that HEAD no longer supports, or might be triggering a bug
18:00:12 <_riba> so if anyone can tell me why that really simple script won't work, i'd be really thankful
18:00:34 <geekosaur> you might annotate with the errors you're getting
18:00:42 <_riba> apparently i can't map a function Char -> String on a String, or i'm too stupid
18:01:50 <hpaste> “_riba” annotated “grammar...” with “grammar... (annotation)” at http://hpaste.org/70194#a70195
18:02:05 <geekosaur> also I would note a couple of infelicities:  (1) s ++ "" should just be s (2) you don't need guards in replace, you can do something like replace 'R' = "LRRRL"; replace 'L' = ... etc.
18:02:06 <unnali> _riba: the issue is that `map replace s' is returning [String], not String
18:02:08 <_riba> oh, now i see how that works
18:02:09 <kallisti> anyone familiar with GNU parallel?
18:02:16 <unnali> _riba: so then it can't be fed back into generate
18:02:36 <unnali> @hoogle mapConcat
18:02:37 <lambdabot> No results found
18:02:41 <unnali> @hoogle concatmap
18:02:41 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
18:02:41 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
18:02:41 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
18:02:44 <unnali> there it is.
18:02:50 <geekosaur> yeh, that
18:02:52 <unnali> _riba: so try using concatmap.
18:03:09 <_riba> thanks!
18:03:19 <geekosaur> you're replacing Char-s with String-s, so you need to join them back together into a String afte
18:03:22 <geekosaur> r
18:03:36 <_riba> i knew i had to use some other function, but i couldn't remember the name
18:03:42 <geekosaur> oh, and (replace) can just be replace
18:03:52 <unnali> _riba: you could easily have just used "concat . map" instead of "map"
18:04:00 <gwern> concatMap?
18:04:15 <_riba> yeah, the brackets just came with my desparation :D
18:04:19 <unnali> :D!
18:05:00 <_riba> as i said, i haven't done anything haskell-related for a while, but it seemed to work best for this task
18:05:13 <_riba> too bad i already forgot many things...
18:06:01 <sordina3> geekosaur: Thanks for your help.
18:07:55 <phao> is there any SMALL (plz..) haskell book or guide for people who come from other languages but have a clue on FP?
18:08:56 <gienah> @where lyah
18:08:56 <lambdabot> http://www.learnyouahaskell.com/
18:09:22 <gienah> phao: the lyah book is probably the best place to start
18:10:23 <_riba> okay, i guess it worked. thanks again :)
18:11:50 <gienah> phao: I guess maybe this tutorial might be an answer to your question: http://www.haskell.org/haskellwiki/Haskell_Tutorial_for_C_Programmers
18:12:41 <kallisti> it seems to automatically escape shell characters in stdin. How do I tell it not to do that?
18:12:51 <kallisti> (re: GNU parallel. also an off-topic question_
18:13:37 <phao> gienah, thx...
18:20:18 <sordina3> Looks like the invalid internals were only being referenced by the test files... hehe
18:21:34 <dainanaki> I've got a problem where I have an xml document that has about 50 optional pieces of data that have different types. I want to parse the various fields into their appropriate Haskell representations, but I can't use a Map to hold them since their types are very heterogenous in nature, and it seems like a real pain to have an ADT with 50 Maybe fields in it... how can I deal with such irregular data in a type-safe way?
18:24:13 <JoeyA> dainanaki: This might not be Haskell-ish advice, but I say just keep them in the raw representation (namely, an XML AST) and parse what you need.
18:24:57 <JoeyA> If you keep using data the same way over and over, then you know it's time to whip out a type class and maybe existential quantification.
18:25:06 <JoeyA> (or some other method of abstraction)
18:26:48 <JoeyA> dainanaki: Also, why would you have 50 Maybe fields?  Couldn't you factor it into sum types?
18:27:45 <JoeyA> For example, suppose you have: data Foo = Foo (Maybe Int) (Maybe String) -- invariant: one, and *only* one, of these will be present.
18:28:08 <dainanaki> Not really, all of the data is entirely independent of all other nodes.
18:29:36 <dainanaki> Essentially the signature is conceptually along these lines :: [DesiredField] -> IO XMLDocWIthDesiredFields
18:29:51 <JoeyA> Ah, so it's a huge collection of properties that may or may not be present?
18:30:09 <dainanaki> Right, and they all have fairly different XML representations.
18:30:42 <JoeyA> You could just make the internal representation a raw XML AST, and have accessors for retrieving fields.  That would be dead simple, in my opinion.
18:31:26 <JoeyA> So newtype Doc = Doc [XMLNode]
18:32:14 <JoeyA> getDisclosureReports :: Doc -> [DisclosureReport] -- may return an empty list
18:32:21 <JoeyA> getTitle :: Doc -> Maybe Text
18:32:27 <JoeyA> etc.
18:33:12 <dainanaki> Yeah, that looks like the best bet. I was kind of hoping I wouldn't have to hold on to the XML for the lifetime of the data type, but oh well.
18:33:42 <JoeyA> dainanaki: You'll end up doing that anyway unless you're careful to force evaluation of your internal structures.
18:33:49 <JoeyA> (due to laziness by default)
18:34:25 <JoeyA> An alternative would be a giant record type whose properties mirror the get methods.
18:34:51 <JoeyA> Thus, instead of Doc being raw XML, it'd be everything parsed.
18:34:58 <dainanaki> That's what I was going to do, but I gave up pretty quickly on that notion.
18:35:06 <dainanaki> I think I'll just write accessors instead.
18:35:08 <dainanaki> Thanks.
18:35:12 <JoeyA> waiit!
18:35:14 <JoeyA> You know about record syntax, right?
18:35:28 <dainanaki> Haha, yes.
18:35:34 <JoeyA> data Doc = Doc { getDrudgeReport :: Maybe Report, ... }
18:35:42 <JoeyA> Usage would be exactly the same.
18:35:54 <JoeyA> The only difference is that your parsing code would all have to be in one place.
18:36:34 <dainanaki> yeah, and that's a lot for 50 fields. I don't want to write that monolithic of a function.
18:36:40 <JoeyA> Besides, you don't have to write a parser for the *whole* document up front.  Just start with a couple fields, and add more as you need them.
18:36:51 <JoeyA> dainanaki: What are you using for XML parsing?
18:37:58 <dainanaki> xml-conduit
18:38:23 <JoeyA> dainanaki: Just make a monolithic dispatch function: parseDoc xml = Doc { getDrudgeReport = parseDrudgeReport xml, getListOThangs = parseThangs xml, ... }
18:38:43 <JoeyA> If your parsers live in a monad, you can use RecordWildCards to achieve a similar effect.
18:38:56 <JoeyA> getDrudgeReport <- parseDrudgeReport xml
18:39:01 <JoeyA> getListOThangs <- parseThangs xml
18:39:04 <JoeyA> return Doc{..}
18:39:27 <JoeyA> The .. captures things in scope that have the same names as properties in your data structure.
18:39:41 <dainanaki> Hey, that's a new one I haven't seen.
18:40:15 <JoeyA> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
18:40:38 <dainanaki> Very cool. Thanks for the help.
18:41:13 <JoeyA> no problem
18:59:00 <tgeeky> I love the visual introduction this McBride thing has: https://personal.cis.strath.ac.uk/conor.mcbride/pub/Totality.pdf
19:02:10 <bgamari> It seems like it might be useful to have a class Monad m => ParallelM m where mapMP :: (a -> m b) -> m [b]
19:02:33 <bgamari> Does anyone know of anybody who has played around with such an idea
19:02:56 <bgamari> Granted this is only possible for probably very few monads
19:03:04 <bgamari> but they definitely do exist (e.g. RVar)
19:03:47 <bgamari> ParallelM would allow you to evaluate multiple actions concurrently
19:04:02 <bgamari> for monads in which this can be safely done
19:04:46 <bgamari> it's quite frustrating to me that I lose the ability to easily parallelize my algorithm just because I need random numbers
19:26:07 <augur> so
19:26:27 <augur> interesting gossip from nasslli :x
19:27:49 <tgeeky> one does not use the words 'interesting gossip' without a follow up
19:37:01 <zzing> If I have a datatype that looks like [(String, [String])]  is there a nice facility to query the first string value (which is the key)?
19:37:22 <mauke> define "query"
19:37:44 <zzing> find something equal
19:38:00 <mauke> :t lookup
19:38:01 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
19:38:18 <mauke> but why not use a Map?
19:38:26 <zzing> mauke, this is in the LDAP module
19:38:37 <zzing> I am using it, not making it
20:18:20 <unnali> zzing: depending on how many times you query the same data, and its size, it may be cheaper for you to construct a map to query :)
20:18:43 <zzing> unnali, chances are there will only be a couple things that would be necessary
20:19:32 <zzing> Although I notice that the LDAP package I am using appears to not have been updated in 5 months, and I might need to add things - so I might consider updating that kind of stuff
20:27:10 <lolcathost> ohai ppls
20:27:17 <lolcathost> dang, wrong channel
20:27:18 <lolcathost> sorry
20:34:27 <zzing> In SHA, the sha1 function is expecting a Data.ByteString.Lazy.Internal.ByteString   but 'pack' (from  Data.ByteString.Char8) apparently gives me a ByteString.  Is there some magic function that will convert what ever the difference is?
20:35:22 <zzing> It appears I imported the wrong one, don't mind me
20:35:35 <c_wraith> toChunks/fromChunks let you convert in the general case
20:37:14 <zzing> Why does the Lazy pack not like a [Char] but the Char8 pack is fine with the [Char]?
20:38:13 <c_wraith> ... because of .Char8
20:38:25 <c_wraith> that's the entire point of those two modules
20:38:39 <zzing> I am really missing this point :-)
20:39:02 <zzing> So I have the right idea - what is the way to go from [Char] to a lazy ByteString?
20:39:16 <c_wraith> correctly, or not?
20:39:20 <mauke> there is no "the way"
20:39:25 <mauke> it depends on how you want to encode it
20:39:35 * hackagebot hmatrix-gsl-stats 0.1.3.2 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.3.2 (VivianMcPhail)
20:39:38 <zzing> I don't know what you mean exactly
20:39:57 <mauke> you have to map your list of chars to a chunk of bytes somehow
20:40:06 <mauke> and by "map" I mean "represent as"
20:40:28 <zzing> If I say they should be UTF8, does it make any difference?
20:41:04 <mauke> there's probably a module for encoding strings
20:41:14 <zzing> I would even go so far as to say that, I just want to take ascii to this :-)
20:41:19 <geekosaur> zzing:  Char holds Unicode characters; ByteString holds bytes.  Char8 truncates Unicode down to bytes; the other one takes Word8 which is more explicit about the need to convert instead of possibly silently corrupting data
20:41:42 <mauke> note that the .Char8 stuff is just wrapper functions, not separate types
20:41:57 <mauke> and if it's really just ascii, it should be fine
20:42:18 <zzing> I don't know anything about internal types
20:42:36 <mauke> there are two ByteString types
20:42:41 <mauke> strict and lazy
20:43:05 <zzing> I need the lazy for SHA
20:43:56 <zzing> ok, it looks like I found a way
20:44:09 <zzing> Lazy.Char8 pack will take it and sha1 accepts it
20:44:47 <Clint> cryptohash will take either strict or lazy
20:46:47 <zzing> cryptohash being another library I should look at?
20:47:01 <Clint> not if you're happy with SHA
20:48:02 <zzing> Clint, These types are breaking me tbh :P
20:48:29 <Clint> zzing: what exactly are you trying to do?
20:48:41 <zzing> Generate passwords for openldap
20:49:03 <Clint> so you want to sha-hash an ascii string?
20:49:13 <zzing> SSHA specifically
20:49:20 <zzing> Which I believe is salted sha1
20:49:23 <Clint> where does the password come from?
20:49:33 <zzing> Ultimately the user types it in
20:49:40 <zzing> But the function will have it
20:50:08 <Clint> why don't you just read it in as a bytestring in the first place?
20:50:18 <zzing> I am using ghci right now
20:50:35 <zzing> I have some sample code in many other languages and just fooling around with the functions
20:51:16 <zzing> I am going to try cryptohash if it installs
20:51:18 <zzing> Looks nicer
20:51:27 <zzing> But right now, I think I am going to bed
20:51:36 <Clint> oh, so you just want to do something like hashfunc (Data.ByteString.Lazy.Char8.pack "blah")
20:51:46 <zzing> basically
20:52:00 <zzing> It will be salted, so just appending something to the end I believe it is
20:52:06 <zzing> But nothing hard to figure out
20:52:35 <zzing> What is the name of a function I should look at to read in stuff into a bytestring? I haven't worked with bytestrings tbh.
20:52:58 <Clint> @hoogle getLine
20:52:59 <lambdabot> Prelude getLine :: IO String
20:52:59 <lambdabot> System.IO getLine :: IO String
20:52:59 <lambdabot> Data.ByteString getLine :: IO ByteString
20:53:35 <mauke> http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/Data-ByteString.html#g:26
20:54:17 <zzing> Is there a function that will do this, but supress the input?
20:54:21 <zzing> hide it rather
20:54:24 <zzing> like a password field
20:54:39 <zzing> I know it is alittle more consoley of question
20:54:56 <Clint> you could set the terminal to not echo
20:54:58 <mauke> @hoogle echo
20:54:59 <lambdabot> System.Posix.Terminal EchoErase :: TerminalMode
20:54:59 <lambdabot> System.Posix.Terminal EchoKill :: TerminalMode
20:54:59 <lambdabot> System.Posix.Terminal EchoLF :: TerminalMode
20:55:08 <zzing> sweet
20:55:19 <mauke> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hSetEcho
20:55:35 <zzing> Thank you all
20:55:41 <zzing> I think I have enough to try this out now
20:55:57 <shachaf> If you're reading text you should probably read it into Text or something like that.
20:56:05 <shachaf> Oh, this channel has been over this before.
20:56:23 <shachaf> ...And to no avail. :-(
20:56:25 <zzing> shachaf, what do you mean read it into Text?
20:56:35 <shachaf> ByteString is for bytes.
20:56:49 <Clint> bytes is what's wanted
20:58:24 <shachaf> Are you sure about that?
20:58:39 <zzing> shachaf, the input is just going to be hashed
20:58:44 <zzing> It isn't being used for anything else
20:58:58 <shachaf> If someone types the string "hello" you want it to hash into a different value depending on the current locale?
20:59:21 <mauke> no, but what you hash will be bytes in any case
20:59:34 <Clint> it's going to be the same with openldap
20:59:36 * hackagebot hsignal 0.2.4.2 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.2.4.2 (VivianMcPhail)
20:59:52 <zzing> shachaf, ideally the hash would be the same no matter where you were
21:00:14 <shachaf> mauke: OK, but that doesn't mean you want to read it as bytes from stdin.
21:00:35 <zzing> If there is a way for me to get a bytestring that I can get a hash out of without much trouble, then I will take it. but otherwise, I have to do it in the way I know righ tnow
21:01:07 <mauke> shachaf: meh
21:01:12 <mauke> relying on ascii is fine
21:01:26 <Clint> even if it's 8-bit, it shouldn't make a difference
21:04:11 <zzing> I like the pony package
21:04:25 * zzing sleeps
21:04:55 <hayashi> I've no idea how I've managed it, but I've somehow managed to get bogged down in boring boilerplate... in Haskell.
21:05:14 <Clint> i hear that you're supposed to scrap it
21:05:22 <hayashi> Yeah
21:05:29 <hayashi> I heard that
21:15:13 <Soultaker> hey guys. I noticed Haskell is broken when using ld.gold  instead of ld.bfd.  Is there a workaround for this?
21:15:17 <Soultaker> or phrased differently: is there a way to change the flags  passed to the compiler/linker by ghc --make?
21:15:22 <Soultaker> (I can see the settings with ghc --info, but there isn't an  obvious way to change them.)
21:18:18 <geekosaur> Soultaker, the relevant bug has been bumped to 7.4.3 so I guess the answer is "no, and none expected"
21:18:50 <ceti331__> what does >>= mean
21:19:02 <shachaf> @where faq
21:19:02 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
21:19:06 <c_wraith> it means a lot of different things, potentially
21:19:16 <shachaf> ceti331__: Read the section "The M-word" there. :-)
21:19:17 <c_wraith> :t (>>=)
21:19:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:19:28 <c_wraith> that happens to be the best short summary of >>=
21:21:23 <ceti331__> i'm a c++ coder, -> is burned into my eyes meaning pointer dereference
21:21:57 <mauke> ceti331__: be glad this isn't ocaml and !
21:22:00 <parcs`> a >>= b is sugar for a = a >> b right-shift
21:22:00 <ceti331__> i can't read that sumary
21:22:14 <ceti331__> yes parcs :)
21:22:39 <Soultaker> geekosaur: not even a hackish workaround?
21:22:55 <Soultaker> incidentally, do you have bug id/url so I can subscribe to the bug in case this ever changes?
21:23:02 <geekosaur> -> is application.  given a value whose type is m a (for some type m which accepts a type as a parameter) and a function which when given an a produces an m b, produce an m b
21:23:17 <geekosaur> Soultaker, http://hackage.haskell.org/trac/ghc/ticket/4862
21:23:21 <Soultaker> thanks!
21:23:28 <ceti331__> -> in signatures… and in function definitions?
21:24:03 <c_wraith> -> is part of the syntax of case expressions - I think that's the only place it shows up in value expressions
21:24:07 <geekosaur> a lambda (anonymous function) is of the form \ parameters -> result expression
21:24:34 <ceti331__> \ i know but my eyes dont make it jump out like that
21:24:41 <c_wraith> right.  knew I was forgetting something
21:25:10 <geekosaur> it also shows up in case expressions; the two are actually related, since function definitions can function as case expressions
21:25:38 <ceti331__> love the idea of haskell, but the syntax is just so alien…
21:26:26 <c_wraith> the syntax may be different, but it's not just for the sake of being different.  It's mostly really well-designed.  (everyone will agree records are an exception)
21:26:37 <piyanik> Hi guys, do i have a chance reduce this list [1, 1+2, 1+2+3, 1+2+3+4]
21:26:58 <c_wraith> > scanl1 (+) [1..4]
21:26:59 <lambdabot>   [1,3,6,10]
21:27:26 <c_wraith> > scanl1 (+) [1..4] :: [Expr]
21:27:28 <lambdabot>   [1,1 + 2,1 + 2 + 3,1 + 2 + 3 + 4]
21:27:36 <piyanik> oh, lots of options ha ...
21:27:54 <ceti331__> > filter (4<) [1..10]
21:27:55 <lambdabot>   [5,6,7,8,9,10]
21:28:08 <RichyB> > shiftL 1 3 :: Expr
21:28:10 <lambdabot>   No instance for (Data.Bits.Bits SimpleReflect.Expr)
21:28:10 <lambdabot>    arising from a use o...
21:28:14 <RichyB> Darn.
21:28:50 <piyanik> thx guys , that enough i think :D
21:28:55 <ceti331__> > filter (\x -> x>0 && x<10) [0..20]
21:28:56 <lambdabot>   [1,2,3,4,5,6,7,8,9]
21:29:50 <tac-tics[home]> > fix me delicious pi
21:29:51 <lambdabot>   Not in scope: `me'Not in scope: `delicious'
21:29:55 <tac-tics[home]> aww :<
21:30:00 <ceti331__> > clamp :: float -> float -> float ->float
21:30:01 <lambdabot>   Not in scope: `clamp'
21:30:16 <ceti331__> can you feed lambdabot multiline
21:30:31 <c_wraith> no
21:30:39 <c_wraith> but you can use semicolons
21:31:07 <c_wraith> > let foo :: Int -> Int -> Int ; foo = (+)  in foo 3 1900
21:31:08 <lambdabot>   1903
21:31:54 <ceti331__> clamp::float->float->float->float;clamp lo hi x = max lo (min hi x)
21:32:17 <ceti331__> map (clamp 2 5) [0..10]
21:32:31 <ceti331__> >clamp::float->float->float->float;clamp lo hi x = max lo (min hi x)
21:32:52 <ceti331__> >  clamp::float->float->float->float;clamp lo hi x = max lo (min hi x) ;   map (clamp 2 5) [0..10]
21:32:54 <lambdabot>   <no location info>: parse error on input `;'
21:33:11 <c_wraith> a few things.  The type is Float (the caps matter).  The space after the > matters.  And to be an expression, you need to use let ... in ...
21:33:28 <Refried__> Say, I know this is a longshot, considering how it's not Haskell, but could someone point me in the right direction here?  http://pastebin.com/XMcGTdRp
21:33:29 <ceti331__> is let just for this multiline case
21:33:31 <mauke> The paste XMcGTdRp has been copied to http://hpaste.org/70197
21:33:58 <Refried__> I tried to annotate it Haskelly, but I may have done it wrong -- trying to find the idiomatic way of doing this correcty
21:33:59 <ceti331__> > let clamp::Float->Float->Float->float;clamp lo hi x = max lo (min hi x) ;  map (clamp 2 5) [0..10]
21:34:00 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:34:01 <c_wraith> ceti331__: no, let is a normal haskell expression.  It's just that lambdabot only evaluates isolated expressions
21:34:05 <geekosaur> ceti331__, lambdabot does expressions, not definitions.  you have to use let to make an expression with a local definition
21:34:27 <c_wraith> > let clamp::Float->Float->Float->float;clamp lo hi x = max lo (min hi x) in map (clamp 2 5) [0..10]
21:34:28 <geekosaur> (lambdabot is not simply ghci hooked up to IRC)
21:34:28 <lambdabot>   Couldn't match expected type `float'
21:34:28 <lambdabot>         against inferred type `GHC.Typ...
21:34:33 <c_wraith> > let clamp::Float->Float->Float->Float;clamp lo hi x = max lo (min hi x) in map (clamp 2 5) [0..10]
21:34:34 <lambdabot>   [2.0,2.0,2.0,3.0,4.0,5.0,5.0,5.0,5.0,5.0,5.0]
21:34:36 <c_wraith> there
21:35:06 <Refried__> I think I hit send at a bad time :-)
21:35:13 <ceti331__> i still struggle to read a lot of haskel..
21:35:41 <c_wraith> ceti331__: that's fine.  Just keep practicing :)
21:36:19 <ceti331__> the partial application looks really neat
21:37:42 <c_wraith> yeah, and it's one of the nice consequences of haskell's syntax.  currying and partial application are really natural to use.
21:38:52 <ceti331__> does it have dot operator for accessing attributes of an object
21:39:21 <c_wraith> no
21:40:02 <ceti331__> what does one do in situations where one would have done that in other languages.
21:40:50 <ceti331__> for starters whats the most natural way to do coordinates .x .y  … array notation ?
21:41:16 <c_wraith> For things with only a couple attributes, pattern matching
21:41:25 <Refried__> oh good point
21:42:03 <c_wraith> If there are a bunch of attributes, record access becomes more common - But that's one of the weaker points of haskell's syntax overall.  The story could be better there.
21:42:03 * BMeph would guess...use a function! ;)
21:42:44 <ceti331__> i'll google, but any sumary of record syntax would be welcome
21:47:20 <Refried__> ceti331__: check out http://learnyouahaskell.com/making-our-own-types-and-typeclasses   and search the page for "record access"
21:47:36 <ceti331__> ok thats where i was thanks
21:47:45 <ceti331__> glad to know i'm reading the recomended guide..
21:47:47 <Refried__> the whole book is awesome, I'm working through it
21:48:35 <Refried__> lol at  "There must be a better way, you say! Well no, there isn't, sorry.    Just kidding, there is. Hahaha! "
21:49:35 <ceti331__> > abs -10
21:49:36 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
21:49:36 <lambdabot>    arising from a use of `...
21:49:53 <ceti331__> > abs $ 20 10
21:49:54 <lambdabot>   20
21:50:06 <ceti331__> > abs $ 20  - 10
21:50:07 <lambdabot>   10
21:50:13 <c_wraith> ceti331__: you've just hit another ugly spot in haskell's syntax...  unary minus is a pain
21:50:17 <c_wraith> > abs (-10)
21:50:17 <lambdabot>   10
21:50:41 <c_wraith> with « abs -10 », it parses as (abs) - (10)
21:50:49 <ceti331__> unary minus .. clashes with partial application?>
21:51:01 <c_wraith> clashes with operator sections...
21:51:24 <c_wraith> But operator sections are basically a form of partial application, too
21:51:44 <ceti331__> (abs $ x2 - x1) * (abs $ y2 - y1)   …. what does that mean .. $...
21:51:52 <c_wraith> :t ($)
21:51:53 <lambdabot> forall a b. (a -> b) -> a -> b
21:51:59 <c_wraith> @src $
21:51:59 <lambdabot> f $ x = f x
21:52:12 <c_wraith> $ is about the simplest possible operator
21:52:21 <c_wraith> It's defined to have the lowest-possible precedence
21:52:28 <piyanik> Guys, i am now discusting with my mate about the list [1, 1+2, 1+2+3, 1+2+3+4]... as you showed me that this list is reducable, so it cant be WHNF, but my mate tells me that its WHNF becoz of the definiton of WHNF (list constructor)
21:52:29 <piyanik> ßßß
21:52:32 <piyanik> ??
21:52:47 <c_wraith> Which makes it handy for syntactic grouping without using parentheses
21:53:11 <c_wraith> piyanik: oh, that *is* in WHNF.  "reduce" has a very specific meaning when talking about normal forms
21:53:36 <piyanik> c_wraith: ach, oh right
21:53:42 <unnali> piyanik: it's a data constructor, so it's in WHNF. only NF isn't reducable .
21:54:06 <unnali> piyanik: `3+4' isn't WHNF because it's not a data constructor or a lambda. so you reduce it and get `7'. that's a data constructor, so it's WHNF.
21:54:09 <unnali> (and happens to be NF)
21:56:06 <piyanik> thanks guys for the explanation
22:33:40 * Sgeo goes insane upon seeing the Seer monad
22:34:54 <unnali> Sgeo: damn dan burton
22:38:58 <meremortal> % ghci-7.4.1 -ignore-dot-ghci -DVERSION_integer_gmp Data/Hashable.hs ~/build/hashByteString.o ==>  Compiling Data.Hashable ==> ghc: panic! (the 'impossible' happened) (GHC version 7.4.1 for x86_64-apple-darwin): primRepToFFIType
22:39:05 <meremortal> Don't know what to do
22:40:25 <meremortal> Same with ghc 7.2.2
22:41:10 <meremortal> Tested on os x 10.8 and 10.6
22:41:44 <Refried__> dang
22:42:51 <Refried__> once the impossible happens, it's hard to be rational going forward
22:46:48 <meremortal> I'll try some irrational things then
22:47:11 <dmwit> meremortal: follow the instructions that follow that error message
22:47:23 <dmwit> 80% chance your problem will be fixed in HEAD by the end of theday tomorrow
22:47:31 <dmwit> 20% chance it will still be broken six years from now
22:47:57 <Refried__> those are pretty good odds
22:48:26 <dmwit> yeah, SPJ and SM are beastly programmers
22:48:59 <Refried__> say... do you suppose it's been long enough that it's kosher to ask a repeat question
22:49:20 <dmwit> I just got here and didn't see the question.
22:49:22 <dmwit> So shoot.
22:50:01 <shachaf> Man, remember dmwit13?
22:50:09 <shachaf> Those were the days.
22:50:17 <Refried__> Well it's a longshot anyway, considering how it's not Haskell, but I was hoping someone would point me in the right direction here:  http://pastebin.com/XMcGTdRp    I tried to annotate it Haskelly, but I may have done it wrong -- trying to find the idiomatic way of doing this correcty
22:50:17 <mauke> The paste XMcGTdRp has been copied to http://hpaste.org/70197
22:50:29 <dmwit> shachaf: Man, get on skype and live the glory days forever.
22:51:44 <dmwit> Refried__: Find the scalaz equivalent of lift.
22:51:45 <dmwit> :t lift
22:51:46 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
22:52:08 <dmwit> use it on getX and getZ
22:52:23 <dmwit> But... in the future maybe the scala channel would be a more appropriate place to ask?
22:53:05 <dmwit> OMG OMG skype happened
22:53:10 <shachaf> Wasn't edwardk going to give a talk about how you shouldn't use monads in Scala?
22:53:11 <dmwit> but I don't know how to use it
22:53:32 <applicative> Refried__: you make the monads match by adding lift to the first and third lines of the do block, but I cant think what getX and co are doing
22:53:37 <tac-tics[home]> What's wrong with monads in scala?
22:53:40 <Refried__> dmwit: heh, I agree that one would think that (#scala / #scalaz)
22:53:43 <tac-tics[home]>  /curious
22:54:25 <hpaste> Refried pasted “mismatched monads” at http://hpaste.org/70198
22:54:33 <dmwit> Whoever it was is now named "someone from #haskell? maybe shachaf?"
22:54:47 <Refried__> that is my "probably wrong for other reasons" attempt at a haskell port of the question
22:55:25 <Refried__> tac-tics[home]: what do you mean?
22:56:38 <dmwit> Refried__: Yes, that is wrong for many reasons, and probably not a helpful translation for figuring out what is wrong in the Scala code.
22:56:47 <Refried__> dmwit: drat
22:57:53 <Refried__> Ok.  But the normal thing to do is to lift into a common monad?
22:58:17 <dmwit> yes
22:58:30 <Refried__> *or* would you split them into multiple do { }  and then combine the results somehow after the fact?
22:58:56 <Refried__> It does seem ok to make my Ints into Just Ints though
23:01:37 <hpaste> applicative annotated “mismatched monads” with “mismatched monads (annotation)” at http://hpaste.org/70198#a70199
23:02:31 <Refried__> aha, thanks
23:05:03 <meremortal> dmwit: got it compiling fine by removing hashByteArray* stuff from Data.Hashable
23:07:19 <applicative> Refried__: I see this guy  t'alking about a scalaz 'lift' http://debasishg.blogspot.com/2011/07/monad-transformers-in-scala.html
23:07:20 <dmwit> meremortal: You'll have to remind me what we were talking about.
23:07:45 <meremortal> dmwit: ghc panic when compiling Data/Hashable.hs :)
23:08:16 <dmwit> oh, right
23:08:19 <dmwit> the thing from like 30s ago
23:08:22 * dmwit goldfish
23:08:58 <pdxleif> Are there "operators" like $ and . at the type level?
23:08:59 <Refried__> thanks applicative, I'll read it carefully -- he's using a newer version of scalaz than I am, but hopefully it'll still apply.  I've been poring over the scalaz 6 source, but I don't understand the organization yet
23:09:47 <Refried__> +for months
23:10:57 <ski> Refried__ : yes, with `MaybeT (Writer w)' you'll get an `w' output even if you don't get a result value
23:11:26 <opqdonut> pdxleif: no, not really. though you can define something like them
23:12:21 <opqdonut> pdxleif: see also: http://hackage.haskell.org/trac/haskell-prime/wiki/InfixTypeConstructors
23:12:56 <dmwit> pdxleif: There are packages that provide them. But they're not what you might wish for: F `O` G has one more constructor than you usually want.
23:13:03 <opqdonut> err, or actually http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons
23:13:11 <applicative> Refried__: on the matter of levels, note that runWriter getX = (2,"(getX)")   runWriter $ runMaybeT $ lift getX = (Just 2,"(getX)")
23:13:16 <dmwit> e.g. a value of this type has an explicit O constructor, where you probably only wanted constructors for F and G.
23:14:55 <pdxleif> I wanted to describe a Map of Maps as say type MapMap = Map . Map
23:15:42 <applicative> type Map a b c = Map a (Map b c) ?
23:15:48 <pdxleif> I guess writing it pointed works: type Map a = Map (Map a)
23:16:33 <pdxleif> Yeah, that.  Pointfree combinators never caught on in the type system?
23:16:39 <applicative> in that sort of position they  have to be applied
23:17:24 <pdxleif> I wasn't speaking of Map literally, but say type StringMap = Map String
23:17:36 <Refried__> ski: I think I do want that -- e.g. I can log "There was no value"
23:18:09 <Refried__> applicative: ah -- ok that makes sense
23:18:22 <ski> @unmtl MaybeT (Writer w) a
23:18:23 <lambdabot> (Maybe a, w)
23:18:26 <quicksilver> pdxleif: they are a pain because you have to explicitly unwrap
23:18:33 <quicksilver> (pointfree combinators in the type system, that is)
23:18:34 <ski> @unmtl WriterT w Maybe a
23:18:34 <lambdabot> Maybe (a, w)
23:18:35 <applicative> pdxleif: That, I thought you could do
23:18:59 <quicksilver> you can't do anything complex with 'type' - anything where you want to write instances and permute arguments requires newtype
23:19:13 <quicksilver> as such, it does "all work" but you have a lot of explicit wrapping/unwrapping to do when using it.
23:19:16 <Refried__> ski: wait what is unmtl
23:19:29 <Refried__> un- monad transformer ... l
23:19:50 <quicksilver> pdxleif: see http://www.haskell.org/haskellwiki/TypeCompose
23:19:58 <ski> Refried__ : unwrapping some common monad transformerers, so you can get a better feel for the extent of the overall possible effect of such actions
23:20:03 <ski> @help untml
23:20:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:20:05 <applicative> pdxleif: its a legitimate type synonym, but you can't do what you might hope with it as quicksilver is saying
23:20:14 <ski> @help unmtl
23:20:15 <lambdabot> unroll mtl monads
23:20:26 <Refried__> what's the l in mtl?
23:20:37 <applicative> library
23:20:41 <Refried__> ah
23:20:58 <applicative> or maybe 'looniness'
23:21:38 <Refried__> so the value of a WriterT is a Maybe pair, whereas the value of a MaybeT is a maybe / w pair
23:21:43 <Refried__> heh
23:22:04 <Refried__> so MaybeT is what I want here
23:22:17 <Refried__> because I want to log even in the absence of a value
23:22:36 <c_wraith> WriterT doesn't involve Maybe
23:22:57 <c_wraith> Oh, but are wrapping it around Maybe
23:23:42 <c_wraith> Well, do you want the content of the monoid when the computation fails?
23:24:57 <Refried__> Yeah sometimes wrapping it around maybe.  Some that are just Writer [char] a and some that are Writer [char] (Maybe a)
23:25:47 <Refried__> I don't understand the question about wanting the content of the monoid when the computation fails -- possibly due to the presence of the word monoid
23:26:08 <Refried__> or possibly due to still being awake at 2:30 am
23:43:16 <b0fh_ua> Hi all! With arrows, how can I apply function to both items in tuple?
23:46:45 <ClaudiusMaximus> > join (***) reverse ("good", "morning")
23:46:46 <lambdabot>   ("doog","gninrom")
23:51:57 <donri> > reverse *** reverse $ ("good","morning")
23:51:58 <lambdabot>   ("doog","gninrom")
23:53:08 <b0fh_ua> thanks!
23:55:19 <donri> > fmap reverse ("good","morning")
23:55:21 <lambdabot>   ("good","gninrom")
23:55:37 <donri> oh, right
