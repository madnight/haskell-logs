00:00:19 <fuchsto> and that's why i need a function that returns an incremented value on every call
00:00:38 <fuchsto> so   nextValue --> 0     nextValue --> 1    nextValue --> 2 ...
00:01:30 <fuchsto> Errm, so, how would i do that? I should avoid IO?
00:01:34 <dmwit> I don't buy it.
00:01:36 <dmwit> (yet)
00:01:57 <fuchsto> dmwit: It's due to an implementation detail of Gtk
00:01:58 <dmwit> Can you motivate for me why, e.g., map f [0..] is unsatisfactory?
00:02:34 <fuchsto> dmwit: Yes! Indeed i can: As i said, it's due to an implementation detail of Gtk. I can define a timer function that is called every n milliseconds.
00:02:44 <kallisti> something like this perhaps: sample rate f = map fst . iterate (\(y, t) -> let t' = t + 1/rate in (f t', t')) $ (f 0, 1/rate)
00:02:47 <fuchsto> dmwit: In my source, it's in Main.hs:116
00:03:02 <Sakako> If you define a timer function can you just use the timer as a call for nextValue?
00:03:04 <dmwit> fuchsto: Alright. Then, can you motivate for me why, e.g., getCurrentTime is unsatisfactory?
00:03:07 <Sakako> like nextValue = timer / n
00:03:27 <dmwit> fuchsto: Or use Gtk's own time value; I can't remember what it's called.
00:04:09 <dmwit> fuchsto: Or, store the current step number in the closure you pass to the timer function (and re-register your timer with an update closure on each run).
00:04:20 <fuchsto> dmwit: Using an IORef?
00:04:21 <dmwit> s/update/updated/
00:04:30 <dmwit> fuchsto: None of the suggestions I've made so far require an IORef.
00:04:38 <fuchsto> dmwit: and modifyIORef it in every call of the timer callback fun?
00:05:19 <fuchsto> dmwit: I just implied it from 'store the current step number'
00:05:33 <kallisti> fuchsto: he's suggesting that you can just take the initial time, then poll the current time, subtract those 2 values, and plug that into the function
00:05:38 <dmwit> fuchsto: But you skipped over the "in a closure" part.
00:05:40 <kallisti> via whatever means openGL provides to do that.
00:06:02 <fuchsto> kallisti: OpenGL? None at all
00:06:12 <kallisti> then getCurrentTime it is.
00:06:16 <dmwit> fuchsto: Something like this: callback n = {- sample at step n -} >> {- createTimer (callback (n+1)) -} >> return Don'tRunThisTimerAgain
00:06:32 <fuchsto> Emm, this wouldn't work in this case
00:07:01 <fuchsto> there is no guarantee that the timer callback function will be called exactly, or even close to the number of milliseconds i defined
00:07:10 <dmwit> Yes, I know.
00:07:24 <dmwit> But you asked for a way to get an incremented number, so you must already be making some assumption like that.
00:07:27 <fuchsto> but every time it is called, i want the 'next' signal.
00:07:38 <dmwit> If you don't want just an incremented number, you must use getCurrentTime or Gtk's own time value.
00:07:42 <Sakako> Don't Iterators do that?
00:08:10 <dmwit> (I don't recommend the latter; as I recall, it's a small enough number to be subject to overflow in a reasonable program lifetime.)
00:08:23 <dmwit> (like something on the order of only a year or two)
00:08:26 <fuchsto> dmwit: I can't, because when using getCurrentTime, the time value i pass to the generator depends on when exactly Gtk is so kind as to call my timer closure
00:08:58 <dmwit> I'm so confused. First you say you want the increment to depend on how long it takes to call the closure, and next you say you don't want it to depend on how long it takes to call the closure.
00:09:02 <dmwit> What is it you want?
00:09:22 <fuchsto> dmwit: I never said i want the increment to depend on how long it takes to call the closure!
00:09:35 <fuchsto> dmwit: But on every call (whenever it is), i want to increment the number
00:09:43 <dmwit> 03:05 < dmwit> fuchsto: Something like this: callback n = {- sample at step n -} >> {- createTimer (callback (n+1)) -} >> return Don'tRunThisTimerAgain
00:09:52 <dmwit> 03:06 < fuchsto> Emm, this wouldn't work in this case
00:09:58 <dmwit> 03:06 < fuchsto> there is no guarantee that the timer callback function will be called exactly, or even close to the number of milliseconds i defined
00:10:13 <dmwit> This is where you claim you want the incerement to depend on how long it takes to call the closure.
00:10:16 <fuchsto> Huh? Just a sec ...
00:11:00 <fuchsto> dmwit: Aaaaah! No, my response "this wouldn't work" was to what you said before
00:11:42 <fuchsto> dmwit: I totally overlooked this one message of yours! I am sorry, yes, that's a solution
00:12:16 <mauke> desync detected. abort! abort!
00:12:30 <dmwit> =)
00:12:48 <fuchsto> what i need is    get signal 0  { 3 ms }  get signal 1 { 3 ms }  get signal 2  { 10 ms but i don't care } get signal 3
00:13:01 <fuchsto> when i objected, i was referring to getCurrentTime
00:13:37 <fuchsto> Embarrasing thing is that i already solved a similar problem in effin' javascript ages ago
00:13:41 <fuchsto> it's a pattern, actually
00:13:46 <fuchsto> >_<
00:14:14 <fuchsto> dmwit: Thank you, you just saved me from implementing an IO monad instance
00:14:46 <dmwit> I'm not sure I understand what that means, but I'm glad I saved you some effort. =)
00:15:00 <fuchsto> Now i just hope Gtk allows defining timer callbacks within a timer callback, but i wouldn't know why it shoud not
00:15:21 <newsham> sounds so imperative
00:15:25 <fuchsto> dmwit: I was about to implement / use IO to define a function returning an incremented value on each call
00:15:26 <dmwit> It does.
00:15:34 <dmwit> gtk2hs is unfortunately very imperative, yes.
00:16:17 <fuchsto> i -am- sorry! I get paid for C++ and, yes, C#. Also, Gtk2hs and HOpenGL are ex-treme-ly imperative. It hinders functional thinking a lot.
00:16:58 <fuchsto> especially for a Haskell newbie :/
00:17:21 <dmwit> fuchsto: (Actually, if I were writing it, I'd probably write a second thread that really does do map f [0..]. But there are some caveats with doing threaded gtk programming; see http://dmwit.com/gtk2hs if you're interested.)
00:19:15 <fuchsto> dmwit: i am, i am
00:19:51 <fuchsto> dmwit: Ouuuh, thanks for that article
00:20:37 <fuchsto> dmwit: I wanted to get it to run first, then struggle with multithreaded gtk. I think your article will help a great deal.
00:21:41 <fuchsto> dmwit: Holy cow, it works and fluently, too
00:22:26 * fuchsto experiences signal-rendering induced arousal
00:22:42 <fuchsto> oh damn that looks SO.SEXY
00:24:08 <dmwit> =D
00:24:15 <fuchsto> dmwit: If you want to, you can clone the repository and cabal build the thing
00:24:39 <fuchsto> dmwit: You are working with gtk2hs anyways, so you should have all the deps installed already
00:25:03 <fuchsto> dmwit: I'd feel honored for further suggestions
00:26:17 <fuchsto> dmwit: the thing is performing really, really well. Downside is: The application takes about 20 seconds of "bootstrap", until the timeouts are up and running with the frequencies i defined. That's why i will switch to multi threading in any case.
00:27:22 * dmwit sighs
00:27:32 <fuchsto> dmwit: Hum?
00:28:01 <dmwit> For some reason, I have mtl-2.1 and mtl-2.1.1 installed, and half of my packages were built against the one and half against the other.
00:28:51 <fuchsto> dmwit: Whoa! Oh man, getting Cabal / cabal-install and ghc to working conditions was the hardes part about getting into Haskell to me so far
00:29:18 <fuchsto> dmwit: I soon discovered it's best to download cabal packages and build them manually
00:29:26 <dmwit> Well, by now it's no longer difficult for me to get things working. Just tedious.
00:30:21 <dmwit> The newest version of cabal-install is much better than the older versions, too.
00:31:07 <fuchsto> dmwit: I read about that a lot, i downloaded, patched and build the sources. Then, FINALLY i could install gtk2hs and hopenGL! I was a lucky fella
00:32:02 <fuchsto> dmwit: I have built the first early version of my little app on Windows, then build the exact same source on my linux machine, where i FINALLY had all aforementioned deps installed
00:32:09 <fuchsto> the build was successful!
00:32:14 <fuchsto> i launched the application!
00:32:21 <fuchsto> it segfaulted!
00:32:46 <kallisti> dmwit: I think "IO monad instance" here just refers to creating values of type IO a, or something...
00:32:50 <dmwit> haha
00:33:17 <fuchsto> so that's why i'm still coding this thing on Windows. And chatting with you on my linux laptop, which has everything to build the app, but fails to launch it.
00:33:17 <dmwit> Did you work out why it segfaulted? (Was it gtk2hs' fault? If so, I want to know.)
00:33:29 <fuchsto> dmwit: Definitely gtk2hs!
00:33:45 <fuchsto> dmwit: As soon as the callback function hooked via timeoutAddFull is called, it segfaults.
00:33:55 <dmwit> Well, if you can make a minimal segfaulting gtk2hs app, that would be very helpful.
00:34:03 <fuchsto> dmwit: And on some other functions, too, like ... what's it called again ... postSomething
00:34:16 <dmwit> postGUISync/Async?
00:34:29 <fuchsto> yes! Those segfaulted, too
00:34:53 <fuchsto> even in tiny sample apps consisting of nothing but a window and a timeoutAddFull
00:35:12 <dmwit> Can you hpaste such a tiny sample app?
00:35:17 <fuchsto> on windows, it works like a charm. I don't know which version of gtk2hs is have installed on my machines, though
00:35:37 <fuchsto> I will create a github repo for you
00:35:52 <fuchsto> You are on this channel frequently?
00:36:31 <dmwit> I am, but don't tell my boss. =)
00:36:37 <fuchsto> :)
00:36:49 <fuchsto> ah, i'll just create the repo now. Recheck it in some days, i will post some verified examples
00:37:01 <fuchsto> 'verified' as in: 'Crashes on my machine'
00:37:10 <dmwit> Or send it to the gtk2hs-users mailing list.
00:37:25 <fuchsto> oh, fun fact: Sometimes it quits with "segmentation fault", sometimes with "illegal hardware instruction". Now THAT's something.
00:39:11 <fuchsto> dmwit: URL is https://github.com/fuchsto/gtk2hs-crashes
00:39:49 <fuchsto> and my newbie project also crashes, as mentioned: https://github.com/fuchsto/drool
00:40:10 <dmwit> Your newbie project doesn't exactly seem minimal. =)
00:40:14 <dncr> what is the preferred way to make a cabal package into a ubuntu package so that it is uninstallable later
00:40:16 <fuchsto> but it has some nasty dependencies (HOpenGL, Glade) i don't need for reproducing that
00:41:01 <dmwit> You will need to remind me when you've got some code behind that repo, though, e.g. by ?tell here or by sending an email to gtk2hs-*.
00:41:57 <fuchsto> i will mail it to the mailing list and get back to you here
00:43:08 <fuchsto> for today i am a happy little boy because i haz a 3D-rendering of a sine wave with envelope. Makes me feel warm inside.
00:44:08 <dncr> i'm going to try http://hackage.haskell.org/package/cabal-debian
00:45:35 <dmwit> dncr: If you have trouble, you might want to contact the person who packages the Haskell packages for debian.
00:45:39 <fuchsto> dmwit: You don't happen to have some experience with HOpenGL?
00:45:44 <dmwit> let me see if I have his name lying around
00:46:01 <dncr> good idea.  i'll see how it goes
00:46:19 <dmwit> fuchsto: I don't have any experience with OpenGL except maybe a few hours to test whether directly writing 2d primitives was faster than using cairo (it wasn't).
00:47:36 <fuchsto> dmwit: Okay, in this case i'll keep googling some things and write a nice up-to-date tutorial. Most HOpenGL-tuts use GLUT, not gtkglext, and they are from around 2003
00:49:20 <fuchsto> dmwit: And thank you very very much for your help!
00:50:49 <sulfre> has anyone written a web browser in haskell with similar design principles as xmonad?
00:52:57 <the|forever|kid> how do you guys update stuff or do you have to download a newer version all over again?
00:53:09 <fuchsto> sulfre: I don't know, but the idea sounds great. Planning on implementing one?
00:53:15 <ion> Define stuff
00:53:23 <the|forever|kid> the platform
00:53:32 <ion> Isn’t that pretty much the definition of updating software?
00:53:37 <sulfre> fuchsto: no, I want someone else to do it :)
00:53:48 <fuchsto> sulfre: For starters, iirc gtk / gtk2hs offers webkit
00:53:51 <the|forever|kid> like some software have this thing called auto updates
00:54:42 <Sakako> the|forever|kid: are you trying to update haskell itself?
00:54:49 <the|forever|kid> that dont reinstall the entire software just edit or renew stuff
00:54:52 <Sakako> and on what operating system?
00:54:57 <fuchsto> sulfre: Aaah, c'mon, don't be lazy ;)
00:54:58 <the|forever|kid> windows
00:55:10 <Sakako> you're trying to... update windowS?
00:55:15 <the|forever|kid> noo....Haskell
00:55:22 <the|forever|kid> the platform
00:55:26 <Sakako> hmm
00:55:35 <the|forever|kid> i've got the 2011.04 version
00:55:42 <the|forever|kid> want the 2012.02
00:55:57 <Sakako> hm, I think you'll probably need to do a complete reinstall
00:56:05 <the|forever|kid> bandwith probs
00:56:05 <Sakako> which is what you'll find a lot of "auto update" software does anyway
00:56:09 <Sakako> ah
00:56:16 <the|forever|kid> not really
00:56:25 <the|forever|kid> some dont
00:56:30 <Sakako> some don't, but most do
00:56:43 <the|forever|kid> like geogebra , another pain in the arse
00:56:50 <isson> test x = 3 + sum 3 4 where sum a b = a + b
00:57:00 <isson> can i test function sum in ghci?
00:57:20 <isson> like  test.sum 3 4 ...
00:57:25 <Sakako> > x = 3 + sum 3 4 where sum a b = a + b
00:57:26 <lambdabot>   <no location info>: parse error on input `='
00:57:37 <Sakako> hmm
00:57:41 <fuchsto> let?
00:57:44 <Sakako> oh yeah
00:57:45 <the|forever|kid> this parse error happens a lot with me
00:58:00 <the|forever|kid> needs a let
00:58:03 <Cale> isson: It's only in local scope for the definition of test, so you'll have to lift the definition out.
00:58:05 <fuchsto> just guessing
00:58:14 <Sakako> > let x = 3 + sum 3 4 where sum a b = a + b
00:58:16 <lambdabot>   not an expression: `let x = 3 + sum 3 4 where sum a b = a + b'
00:58:18 <Sakako> nope
00:58:18 <Sakako> XD
00:58:19 <isson> thaks Cale.
00:58:20 <the|forever|kid> hmm
00:58:44 <isson> thanks
00:58:50 <kallisti> can anyone point me to information about open problems in FRP?
00:59:18 <shachaf> "making it work"
00:59:49 <kallisti> I was hoping for some more details..
01:00:01 <shachaf> "making it work well"
01:00:04 <kallisti> you mean making it efficient?
01:00:12 <the|forever|kid> what about the parse '=' error
01:00:22 <the|forever|kid> what does it mean
01:00:38 <kallisti> lambdabot evaluates expressions
01:00:52 <kallisti> f x = y  is not one of those.
01:00:56 <kallisti> let f x = y in f 2
01:00:57 <kallisti> is
01:01:03 <the|forever|kid> even Ghci gives the same error
01:01:06 <kallisti> (aside from y being undefined)
01:01:34 <the|forever|kid> so you got to do the `let` thing for all the assignments
01:01:42 <kallisti> in lambdabot and ghci, yes.
01:01:52 <kallisti> ghci has a special construct, where you can type:  let f x = y
01:01:53 <kallisti> by itself
01:02:05 <kallisti> and it wil define that function in your current ghci environment
01:02:43 <kallisti> but let f x = y  by itself isn't valid Haskell. unless it's within a do-block.
01:02:51 <kallisti> you need let f x = y in ...
01:03:01 <kallisti> > let f x = 2 in f "hello"
01:03:03 <lambdabot>   2
01:03:24 <kallisti> > let (x, y) = (2, "hello") in x
01:03:25 <lambdabot>   2
01:03:35 <srhb> I seem to have a unicode bug.. decompress takes a ByteString and ungzips it, but I seems to be using Unicode data along the way, probably because of the ByteString itself. How do I deal with this?
01:04:12 <kallisti> the|forever|kid: also "assignment" is a poor choice of wording, since Haskell's = doesn't correspond to assignment as you're likely familiar with it.
01:04:29 <kallisti> it's better to think of = as defining an equation.
01:05:27 <kallisti> > let x = 2; x = 3 in x
01:05:29 <lambdabot>   Conflicting definitions for `x'
01:05:29 <lambdabot>  Bound at: <interactive>:1:4
01:05:29 <lambdabot>            <in...
01:05:42 <kallisti> it doesn't modify an existing value, it creates a definition.
01:06:37 <dmwit> kallisti: vague recollection that may help your googling: it seems one common problem is space leaks, and especially when using "integrate" or a function with a similar type
01:07:24 <dmwit> However, these words are strung together from vague memories, and not from a deep understanding of the problem, so don't treat them too literally.
01:07:31 <kallisti> dmwit: ah so it's not a conceptual hurdle but an implementation hurdle (perhaps fixable through changes in concepts)
01:07:40 <dmwit> I believe so, yes.
01:08:17 <kallisti> I'll need to dive into FRP myself, I guess. read some papers. write some code.
01:08:26 <dmwit> Of course, there's also the social hurdle of adoption. =)
01:08:40 <dmwit> I think "Push-Pull FRP" is a good paper to start with.
01:09:08 * Eduard_Munteanu remembers that too
01:09:19 <Eduard_Munteanu> (as in, he should read it)
01:10:51 <kallisti> I'm mostly familiar with the reactive-banana library. Any idea what "integrate" is called there?
01:11:30 * dmwit goes to scan the reactive-banana docs
01:12:06 <the|forever|kid> what do you people use to prog in haskell (Ghci?)
01:12:12 <dmwit> accumE, I think
01:12:17 <kallisti> the|forever|kid: a text editor
01:12:25 <the|forever|kid> and then..
01:12:32 <kallisti> GHC
01:12:33 <dmwit> the|forever|kid: gvim in one window, ghci in another
01:12:35 <mornfall> the|forever|kid: type error :-P
01:12:39 <edwardk> the|forever|kid: vim
01:13:00 <kallisti> I actually don't use ghci much. typically if I'm working on a large project I'll have a cabal file set up at which point I just "cabal build"
01:13:02 <mornfall> I use brain.
01:13:15 <kallisti> but sometimes I'll use ghci.
01:13:18 <edwardk> i use brain to typecheck my haskell code
01:13:20 <the|forever|kid> for me whenever i run ghc it opens and then closes
01:13:23 <edwardk> not so much for typing it
01:13:35 <ion> edwardk: Whose brain?
01:13:37 <dmwit> Anybody know off the top of their head whether "main-is: Drool/Main.hs" will work in Windows?
01:13:38 <kallisti> the|forever|kid: yes, ghc is a compiler. if you don't specify any inputs it doesn't do anything.
01:13:44 <edwardk> as evidenced by the amount of type errors i get when compiling it ;)
01:13:57 <dmwit> (or what the cross-platform way of specifying this field is?)
01:13:58 <the|forever|kid> no i mean it doesnt run at all
01:14:06 <fuchsto> i am anxious to ask but, and don't put this out of context: what is brain?
01:14:15 <shachaf> edwardk: You use brain to typecheck your Haskell code?
01:14:17 <dmwit> fuchsto: thing between ears
01:14:19 <shachaf> Isn't that what the compiler is for?
01:14:25 <kallisti> the|forever|kid: describe how you "run" it.
01:14:30 <fuchsto> dmwit: Okay, i asked for it :)
01:14:38 <edwardk> shachaf: my code goes through long uncompileable stints between flurries of real typechecking ;)
01:14:40 <kallisti> ghc is a command-line program.
01:14:48 <the|forever|kid> double clicking the executable
01:14:57 <kallisti> yeah, that's why.
01:15:01 <kallisti> it's not a graphical application.
01:15:05 <edwardk> besides my brain is much more forgiving of 'oh i haven't typed that part in' errors than ghc
01:15:07 <fuchsto> dmwit: Thought there was some (software) tool called 'brain', something like a theorem solver perhaps
01:15:10 <the|forever|kid> cmd runs just fine
01:15:23 <dmwit> fuchsto: I know. I was just having fun with you anyway. =)
01:15:38 <dmwit> cmd is not a command-line application.
01:15:48 <dmwit> cmd is a graphical application which displays a command line.
01:15:55 <the|forever|kid> so how do you run a cmmnd line app
01:15:56 <fuchsto> dmwit: Speaking about it: I once read there was a theorem solver for haskell type classes?
01:15:59 <kallisti> the|forever|kid: http://sprunge.us/LdiD  here's the output I get from typing "ghc" into my shell of choice.
01:16:05 <the|forever|kid> BTW even .jars give me the same error
01:16:15 <dmwit> fuchsto: Hm, you may be thinking of djinn (?).
01:16:19 <dmwit> ?djinn a -> b -> a
01:16:19 <lambdabot> f a _ = a
01:16:39 <fuchsto> dmwit: google tells me i am
01:16:45 <kallisti> the|forever|kid: for doing Haskell development in Windows I recommend getting some kind of unix-like environment. Cygwin or mingw are good options.
01:17:24 <the|forever|kid> @kallisti that thng comes i guess its too fast for me to see
01:17:25 <mornfall> kallisti: Doesn't the platform come with gcc?
01:17:25 <lambdabot> Unknown command, try @list
01:17:28 <mauke> fuchsto: http://okmij.org/ftp/Haskell/types.html#de-typechecker
01:17:35 <mornfall> kallisti: What else would you need? Apart from a text editor...
01:17:39 <kallisti> but if you open up cmd and type "ghc --help" you'll see some info about how to use ghc.
01:17:41 <edwardk> my major way of doing haskell dev on windows was to run ubuntu in a VM ;)
01:17:54 <dmwit> fuchsto: Well, I finally finished compiling your application.
01:17:59 <dmwit> fuchsto: It doesn't segfault.
01:18:03 <srhb> edwardk: Seconded. :-)
01:18:11 <dmwit> fuchsto: It also doesn't take 20s to run. =P
01:18:16 <kallisti> the|forever|kid: yep. it opens up cmd, runs the program, then exits.
01:18:18 <edwardk> moving back to a mac let me ditch the vm
01:18:28 <kallisti> the|forever|kid: the simplest way to use ghc would be to do ghc file.hs
01:18:37 <kallisti> which will attempt to compile that file, and give you any type errors or whatever.
01:18:49 <the|forever|kid> and where shold ghc be located for this
01:19:00 <kallisti> where it is right now, mostly likely. if you installed it via Haskell platform.
01:19:00 <dmwit> wrong question
01:19:06 <edwardk> i do kind of miss the fact that the vm could run a tiling window manager and i could target either it or an x server on the "outside" machine to get the best of both worlds
01:19:09 <fuchsto> dmwit: Orly? Let me see which versions i have ...
01:19:22 <dmwit> The right question is "what should I do to make GHC visible" and the answer is "put GHC's install directory on your %PATH%".
01:19:33 <dmwit> the|forever|kid: (those last two lines of mine were at you)
01:19:34 <the|forever|kid> kallisti : my haskell is not in the root
01:19:37 <srhb> edwardk: On the outside? I've never managed that. That sounds really nice.
01:19:42 <the|forever|kid> dmwit : thanks
01:19:43 <fuchsto> dmwit: if you do a git pull origin master, you should see a sine wave enveloped with another sine wave.
01:19:54 <kallisti> the|forever|kid: when you type command blah blah blah  into a shell it'll look for a program named command.exe in one of the folders listed in the PATH environment variable.
01:20:16 <kallisti> which a default Haskell Platform instal should do.
01:20:18 <edwardk> srhb: workeds better for things like gimp and debuggers that don't like being launched tiled
01:20:25 <srhb> Yeah.
01:20:35 <dmwit> fuchsto: Well, I see some rotating blue-and-white stuff, but it's not really intelligible to me.
01:21:18 <edwardk> sitting here trying to figure out the best way to add names to the locally-nameless rep provided by bound
01:21:23 <fuchsto> dmwit: Hm. Does it rotate smoothly? It takes some seconds on my machine until the rotation is creamy
01:21:38 <edwardk> that way if you want to keep your variable names around you can have them
01:21:46 <dmwit> It's very smooth, yes.
01:22:06 <fuchsto> dmwit: i have glib-0.12.3 ...
01:22:33 <kallisti> moonlite: a bit of a delayed response:  it helps to have a decent development environment. Such as the one that isn't provided by Windows.
01:23:19 <fuchsto> dmwit: and gtk-0.12.3 ... gtk2hs-cast-glib-0.10.1.1 ... and gtk3hs-cast-glade-0.10.1.1
01:23:25 <kallisti> but yes, basically, you just need a compiler and a text editor.
01:23:29 <dmwit> Well, I released 0.12.3.1 a few days ago, but ($DEITY willing) that should not have behavioral changes -- it should only make the package build on more systems.
01:23:58 <fuchsto> dmwit: Ah, try pulling "Horizontal scaling" up
01:24:11 <fuchsto> dmwit: Yes, the label is bork.
01:24:26 <theadmin> kallisti: You don't "need" a text editor, you can use echo :P
01:24:28 <theadmin> Just sayin'
01:24:43 <kallisti> I suppose..
01:24:52 <srhb> theadmin: Not much fun in that though. :P
01:24:56 <theadmin> Tho yeah, that's almost on the same level as notepad
01:25:00 <dmwit> fuchsto: That is more interpretable, but still not a segfault here. =)
01:25:23 <kallisti> you need a thing that puts text in files, okay...
01:25:23 <fuchsto> dmwit: I know that a) it's vertical scaling and b) not clever to initialize it with close to 0
01:25:46 <fuchsto> dmwit: Which version of gtk / glib do you have?
01:25:59 <dmwit> tricky question
01:26:27 <fuchsto> dmwit: what's in your ~/.cabal/packages/..hackage.com../glib ?
01:26:47 <boo> why am i getting illegal operator −> ?
01:26:51 <dmwit> Oh, you want to know the versions of the Haskell bindings?
01:26:57 <dmwit> I'm using darcs version of all Haskell bindings.
01:27:04 <barrucadu> boo: That's impossible to answer without seeing the offending code
01:27:16 <fuchsto> dmwit: Hm, so the most recent ones?
01:27:31 <kallisti> barrucadu: well, we could attempt to exhaust all the possibilities.
01:27:36 <boo> secDiff :: ClockTime −> ClockTime −> Float
01:27:47 <mauke> boo: because − is not -
01:27:48 <dmwit> But the darcs repository differs only by having more bindings; the code for postGUIAsync and timeoutAddFull has been stable for years.
01:27:49 <srhb> That's not a -
01:27:50 <theadmin> boo: What's that weird sign? Use -
01:28:01 <fuchsto> dmwit: Do you recommend darcs over cabal-install?
01:28:07 <dmwit> nope
01:28:14 <boo> i just copied it from the parallel programming tutorial.. a pdf
01:28:20 <boo> so -> should work ?
01:28:22 <srhb> boo: Yes
01:28:23 <boo> let me try
01:28:36 <srhb> (Copying code from pdf is bound to go bad :-)
01:28:57 <fuchsto> dmwit: But at least you don't get segfaults with your sources from darcs.
01:29:09 <dmwit> fuchsto: If necessary, I have an install with only released version of the code lying around. So when you have a small program, I'll test with that.
01:29:20 <boo> yeah that fixes it.. thanks
01:29:53 <dmwit> fuchsto: But I don't relish trying to get all of the GL stuff installed in that environment; I hope you understand.
01:30:18 <dmwit> (I will if it's necessary to make the problem reproducible. But you claim it's not.)
01:30:35 <the|forever|kid> ?what does naked expression in top level mean
01:30:36 <lambdabot> I know nothing about does.
01:30:53 <dmwit> the|forever|kid: It's polite to post both code and exact error.
01:30:54 <dmwit> ?hpaste
01:30:54 <lambdabot> Haskell pastebin: http://hpaste.org/
01:31:11 <fuchsto> dmwit: i don't even come near the GL initialization when it crashes, so no, you don't need GL
01:31:21 <theadmin> the|forever|kid: That means you put a naked expression at the top level of your code. I don't know how to be more clear.
01:31:40 <fuchsto> dmwit: Well, would have to be a bad voodoo it you did
01:31:52 <theadmin> the|forever|kid: The top level can only contain imports, comments, function definitions, maybe something else. "print 5" is not a valid Haskell program. "main = print 5" is, though.
01:31:59 <kallisti> has anyone made an "EventT"
01:32:50 <hpaste_> “the|ever|kid” pasted “hello world 2” at http://hpaste.org/70058
01:33:06 <kallisti> it would essentially apply a kind of sequence to the event stream.
01:33:35 <theadmin> the|forever|kid: That second line has to be "main = print x"
01:33:37 <srhb> the|forever|kid: The final x is a naked expression in the top level.
01:34:41 <kallisti> the|forever|kid: a Haskell program isn't the same thing as an interactive ghci session.
01:35:18 <theadmin> kallisti: But x = ... is invalid in interactive GHC, so I don't quite see what he's trying here
01:35:32 <kallisti> a Haskell text file is a collection of top-level declarations. ghci evaluates Haskell expressions in a read-eval-print loop
01:35:58 <xil> hi everyone. I know the difference here is outrageously insignificant, but I'm just curious about this from a theoretical level. Will the evaluation to True be equally fast in both cases of the following function?
01:36:00 <hpaste_> xil pasted “Guards!” at http://hpaste.org/70059
01:36:42 <theadmin> xil: Well, I take it the "not" operator takes SOME time to do the inversion...
01:37:00 <the|forever|kid> theadmin : tried to do what you said but though there were no errors there wasnt any output
01:37:28 <xil> theadmin: right. The question is ultimately if the not operator takes as long as it would take to see that the first guard in the second version of the function evaluates to False, and test the second guard
01:37:30 <theadmin> xil: I *assume* "not" is defined as something like tthis: not Bool -> Bool; not True = False; not False = True;
01:37:41 <theadmin> @src not
01:37:42 <lambdabot> not True   =  False
01:37:42 <lambdabot> not False  =  True
01:37:46 <theadmin> Ha, knew it
01:37:54 <mauke> theadmin: note that @src is lies
01:38:01 <theadmin> mauke: Huh?
01:38:12 <srhb> the|forever|kid: Now you've probably compiled your program without errors with ghc progname.hs, right?
01:38:15 <mauke> it just reads definitions from a text file someone wrote
01:38:19 <dmwit> xil: Checking "b" will be faster than checking "not b" by a tiny bit.
01:38:22 <mauke> it's not the actual library code
01:38:22 <theadmin> mauke: Ah.
01:38:26 <srhb> the|forever|kid: If it compiled with no errors, you can now run the program.
01:38:32 <dmwit> xil: (Because "not b" is a tiny bit more computation.)
01:38:40 <mauke> what was the flag to see optimized core?
01:38:42 <ion> not = maybe True (const False) . unsafeCoerce
01:38:44 <mauke> -O2 -ddump-simpl?
01:38:51 <kallisti> theadmin: though, in this case, I believe it is the actual library code, for most implementations.
01:38:56 <xil> dmwit: but in the second case you have to also move to the second guard and evaluate it. Does that make up for the time it took thinking about "not"?
01:38:58 <kallisti> maybe with some syntactic differences.
01:38:58 <srhb> the|forever|kid: I assume the program will be called progname.exe on Windows.
01:39:21 <dmwit> xil: Ah, I misread the question.
01:39:39 <xil> dmwit: to be fair I didn't phrase it entirely clearly =P
01:40:22 <xil> basically, in which version of the function will it get to the case that returns True, fastest?
01:40:30 <dmwit> I'm not sure, actually, though I expect "otherwise" gets some special treatment by the compiler.
01:40:31 <xil> I almost want to say the second
01:40:41 <dmwit> You will have to look at GHC's core to know the real answer, though.
01:40:54 <srhb> the|forever|kid: Got it?
01:40:56 <xil> that pretty much answers it
01:40:58 <theadmin> By the way, what *is* the point of "otherwise"? Poking around in GHC, it seems that simply otherwise :: Bool; otherwise = True. But... point?
01:41:13 <theadmin> Err, in GHCi
01:41:13 <srhb> theadmin: It reads nicely as the last case in guards.
01:41:28 <ion> I’d rather have had syntax like:
01:41:32 <ion> foo | bar = baz
01:41:39 <ion>     |     = quux
01:41:57 <dmwit> theadmin: Two points: it's pretty (as srghb says) and in GHC it triggers a flag that says the pattern is "complete" and not to show a warning.
01:42:01 <srhb> ion: Ew :P
01:42:15 <dmwit> s/srgbh/srhb/
01:42:18 <dmwit> bleh
01:42:52 <ion> shrtgbhr
01:43:15 <srhb> I should change my nick. :P
01:43:58 <theadmin> dmwit: So just a readability thing then, also this doesn't trigger any warnings: http://sprunge.us/IcAD
01:44:26 <theadmin> ...just pray people don't start writing things like if a == otherwise then ...
01:44:39 <srhb> Oh they surely already are. :P
01:44:41 <fuchsto> dmwit: I pushed a crashing minimal app to http://github.com/fuchsto/gtk2hs-crashes
01:45:21 <fuchsto> dmwit: it's just opening a window and registering a timeout callback. The timeout is set to fire after 1000ms, and exactly after 1 second, the app segfaults.
01:45:26 <dmwit> theadmin: that's so
01:45:49 <boo> in +RTS -N2 option does it mean 2 cores or 2 different processors ?
01:46:50 <ion> What’s the difference from the RTS’ point of view?
01:47:01 <dmwit> xil: In my test, main = print (f False) >> print (f' False), GHC compiles both to print True. =)
01:47:18 <dmwit> boo: It means 2 capabilities.
01:47:23 <xil> dmwit: as it should
01:48:05 <boo> i am trying to run this fib and sumfibeuler example on quad core.. but the number of sparks it shows up is 0
01:48:14 <dmwit> boo: See also the "Conventions" and "Foreign Imports" section of http://dmwit.com/gtk2hs
01:48:46 <xil> dmwit: I don't know how to profile, though, so I couldn't quickly test the execution speed of each. I would learn to profile, but not for something like this. Not now
01:49:06 <dmwit> fuchsto: looking
01:50:46 <fuchsto> dmwit: You don't happen to live in Munich, Germany? I could invite you over to a beer and an bug-reproduction-session in this case.
01:50:58 <dmwit> fuchsto: How are you compiling and running? How long do you have to wait for a segfault?
01:51:11 <dmwit> I'm in America. =/
01:51:29 <fuchsto> dmwit: I build with   cabal build   and the segfault happens 1 second after launching the application
01:52:11 <fuchsto> dmwit: Or 4 seconds if i set the timeout to fire every 4000 ms
01:52:31 <fuchsto> dmwit: So it's not timeoutAddFull itself, but the event of firing the callback
01:52:35 <dmwit> okay, and you run with dist/build/Gtk2HsCrashes/Gtk2HsCrashes or something like that?
01:52:43 <fuchsto> right
01:52:45 <srhb> dmwit: Did the fix to gthread.h make it to hackage yet?
01:52:52 <dmwit> srhb: no
01:52:57 <srhb> Alright. :)
01:52:58 <dmwit> srhb: It's high on my priority list.
01:53:12 <dmwit> srhb: (Were you the one who wrote the comment on the Gtk2Hs blog post?)
01:53:13 <srhb> dmwit: No rush, just curious. And thanks. :)
01:53:24 <srhb> dmwit: No, I was not. We talked about it in here a few days ago though.
01:53:28 * fuchsto thanks his deity for having mentioned this bug to dmwit
01:53:36 <dmwit> Oh, we did?
01:53:43 <srhb> dmwit: In passing. :)
01:53:44 <dmwit> Man, I must have really been out of it, I don't even remember that.
01:53:52 <dmwit> Anyway, I agree that it's a bad oversight.
01:53:58 <srhb> You were busy. No worries.
01:56:13 <dmwit> fuchsto: Okay. I'll test this program with the 0.12.3 release. In the meantime, you might want to try doing a cabal clean and cabal install --reinstall of all your gtk2hs packages (glib, cairo, pango, gtk, gio).
01:56:23 <hpaste_> fuchsto pasted “gtk2hs crashes (cabal -v build)” at http://hpaste.org/70061
01:56:45 <fuchsto> dmwit: I just pasted the output of my   cabal -v build
01:57:12 <fuchsto> dmwit: it includes all package versions
01:57:25 <dmwit> oh, maybe I should actually try cabal building
01:57:38 <fuchsto> dmwit: Will try the reinstall. Thank you for having a look at it!
01:57:39 <srhb> Why does one use -XHaskell98?
01:57:42 <dmwit> since this is actually pulling in some stuff it doesn't need, and I had overlooked that fact
01:57:44 * srhb is curious
01:58:15 <fuchsto> srhb: cabal decided to do so
01:58:19 <srhb> Aha.
01:58:35 <fuchsto> i have ghc-7.2, so i don't know why it's using Haskell98
01:59:00 <Catnaroek> @pl let { f Nothing = [] ; f (Just x) = [x] } in f
01:59:00 <lambdabot> (line 1, column 5):
01:59:00 <lambdabot> unexpected "{"
01:59:00 <lambdabot> expecting "()", natural, identifier or "in"
01:59:24 <ion> maybeToList
01:59:31 <Catnaroek> Oh, thank you!
01:59:40 <ion> @hoogle Maybe a -> [a]
01:59:40 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
01:59:41 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
01:59:41 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
02:00:20 <Catnaroek> Oh, wow, catMaybes is what I was looking for!
02:00:21 <Catnaroek> :D
02:00:25 <fuchsto> dmwit: "The following packages are likely to be broken by the reinstalls" ... should i ignore that?
02:00:27 <Catnaroek> Thank you very much!
02:00:42 <dmwit> fuchsto: Best way to deal with that is to tell cabal-install everything you want to do
02:01:00 <dmwit> fuchsto: e.g. instead of "cabal install --reinstall glib", do "cabal install --reinstall glib cairo pango gtk gio"
02:01:40 <Catnaroek> @pl f x y = y x
02:01:40 <lambdabot> f = flip id
02:01:41 <dmwit> (To directly answer your question: no, you should not ignore that.)
02:02:11 <fuchsto> dmwit: i have ltk-0.12 and ltk-0.13 both installed? O_o
02:02:38 <dmwit> Dunno what ltk is, but GHC is perfectly capable of having many versions of a package installed.
02:02:51 <Catnaroek> Is there any function that maps a list of functions to a single value?
02:03:01 <dmwit> Someday it may even be capable of having many copies of a single version (but built against different versions of its dependencies) installed.
02:03:06 <ion> catnaroek: head
02:03:18 <dmwit> A guy can hope, right? =)
02:03:28 <Catnaroek> ion: head? didnt that retrieve the head of a list?
02:03:53 <dmwit> Catnaroek: Your specification isn't specific enough to rule out head. Say what you want this function to do.
02:04:13 <srhb> Catnaroek: foldr reduces a list with some appropriate function.. But yes, it is not clear what you want to do.
02:04:49 <srhb> > foldr (+) 0 [1,2,3]
02:04:50 <lambdabot>   6
02:05:03 <Catnaroek> @pl mapF value = map $ flip id value
02:05:03 <lambdabot> mapF = map . flip id
02:05:18 <shachaf> map $ flip id value? Really?
02:05:22 <srhb> Haha.
02:05:36 <shachaf> @ty map . Prelude.flip id
02:05:37 <lambdabot> forall b b1. b1 -> [b1 -> b] -> [b]
02:05:50 <ion> > [(+1), (+2), (+3)] <*> pure 42
02:05:50 <shachaf> @pl mapF value = map ($ value)
02:05:51 <lambdabot> mapF = map . flip id
02:05:51 <lambdabot>   [43,44,45]
02:06:10 <theadmin> shachaf: Hey, it *is* better than "map (flip (id(value)))"
02:06:28 <Catnaroek> > let mapF = map . flip id in map 7 [succ, pred]
02:06:29 <lambdabot>   Ambiguous type variable `a' in the constraint:
02:06:29 <lambdabot>    `GHC.Enum.Enum a'
02:06:29 <lambdabot>      ar...
02:06:30 <shachaf> theadmin: Given that yours isn't the same function at all, yes.
02:06:35 <Catnaroek> > let mapF = map . flip id in mapF 7 [succ, pred]
02:06:37 <lambdabot>   [8,6]
02:06:42 <Catnaroek> That is what I mean.
02:06:43 <shachaf> > sequence [succ,pred] 7
02:06:43 <fmap> > sequence [(+1), (+2), (+3)] 42
02:06:44 <lambdabot>   [8,6]
02:06:45 <lambdabot>   [43,44,45]
02:06:47 <dmwit> > sequence [succ,pred] 7
02:06:47 <lambdabot>   [8,6]
02:06:53 <Catnaroek> Oooooooooooooh.
02:06:54 <Catnaroek> Nice.
02:06:55 <dmwit> dang, the lag really killed me on that one
02:06:55 <Catnaroek> Thanks.
02:07:04 <shachaf> Catnaroek: map ($ value) is nicest, I think.
02:07:25 <theadmin> shachaf: Oops.
02:07:35 <theadmin> Woah. Huge lags here -_-
02:08:16 <Catnaroek> shachaf: I understand that, but I would have never been able to *come up with it*.
02:08:36 <srhb> Catnaroek: Sure you would, but maybe not just now. ;)
02:08:39 <shachaf> Catnaroek: Right. Which is why I told you.
02:08:57 <Catnaroek> :P
02:09:00 <Catnaroek> ty all ppls
02:09:40 <dmwit> fuchsto: Anyway, I've got to hit the sack. I've added your segfault program to my todo list.
02:09:54 <ion> terminate yourself all pupils?
02:10:56 <fuchsto> dmwit: I thought so, it's not like it's a special use case, and you can't even reproduce it :/
02:11:25 <fuchsto> dmwit: so you are using gtk-0.12.3, too?
02:11:38 <fuchsto> dmwit: Perhaps it's my glib, not the glib binding?
02:11:53 <fuchsto> dmwit: or gtk, rather
02:12:19 <fuchsto> dmwit: i'm reinstalling, and 'preprocessing library gtk' took about 3 minutes
02:12:56 <fuchsto> dmwit: Lots of warnings about 'deprecated functions' that 'will be removed in the next release', too. Don't know if that's of interest, though
02:14:10 <dmwit> Yes, I'm working on reducing the number of warnings.
02:14:37 <Catnaroek> @pl f g x = let { h Nothing = Nothing ; h (Just y) = Just (g y) } in h x
02:14:37 <lambdabot> (line 1, column 7):
02:14:38 <lambdabot> unexpected "="
02:14:38 <lambdabot> expecting variable, "(", operator or end of input
02:14:38 <fuchsto> hey, i wasn't complaining :)
02:15:04 <ion> catnaroek: fmap?
02:15:11 <fuchsto> dmwit: which version of ghc are you using, by the way? Perhaps there's issues because of 6.x vs. 7.2
02:15:19 <Catnaroek> ion: What is fmap? I have never used it. :O
02:15:33 <ion> > (fmap (+42) Nothing, fmap (+42) (Just 100))
02:15:35 <lambdabot>   (Nothing,Just 142)
02:15:41 <Catnaroek> Wait
02:15:47 <Catnaroek> Isn't that a generalized map?
02:15:49 <srhb> Catnaroek: It's a generalized map for all functors
02:15:55 <dmwit> fuchsto: My one-off tests just now were on 7.4.1, but I've noted in my todo list that you were using 7.2 and intend to use my 7.2 install to test it.
02:16:17 <Catnaroek> srhb: Why isn't the good old map generic, then?
02:16:25 <Catnaroek> grrr
02:16:25 <dmwit> Catnaroek: hysterical raisins
02:16:29 <fuchsto> dmwit: Still crashing after reinstall. Hm, wlel.
02:16:30 <srhb> Catnaroek: I don't actually know. It seems silly.
02:16:45 <Catnaroek> dmwit: :O (?)
02:16:50 <ion> catnaroek: A historical accident. Someone might have thought that would result in too confusing error messages or something.
02:17:15 <dmwit> Catnaroek: There were some... interesting decisions made to make Haskell friendlier to beginners. Monomorphing certain functions (like map) more than necessary was one of them.
02:17:22 <fuchsto> dmwit: That'd be really great. I'll see if i can get ghc-7.4 for my machine, too
02:17:42 <fuchsto> dmwit: Thank you so far. If there is any news, i'll let you know
02:17:57 <dmwit> Some of the decisions that turned out to be really irksome to professional Haskell programmers are slowly being reverted. =)
02:18:03 <Catnaroek> @hoogle fmap
02:18:04 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
02:18:04 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
02:18:04 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
02:18:08 <Catnaroek> oh its in the prelude nice
02:18:36 <dmwit> fuchsto: No problem. =)
02:27:06 <srhb> I don't think any GUI bindings for Haskell builds on an updated OS X right now. Fascinating. :P
02:28:20 <Catnaroek> Is there anything like forM_, but which takes two lists?
02:28:29 <srhb> Catnaroek: How?
02:28:43 <Catnaroek> forM_ list1 list2 $ \e1 e2 -> do ...
02:28:45 <srhb> Catnaroek: You could start by zipping the two lists.
02:28:51 <Catnaroek> Oh. Okay.
02:29:03 <Catnaroek> I guess there is no way around that. :P
02:29:20 <mekeor> @hoogle zipWithM_
02:29:21 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
02:29:49 <mekeor> Catnaroek: use this.
02:29:59 <Catnaroek> mekeor: Oh, very nice, thanks!
02:30:01 <mekeor> :)
02:33:31 <mekeor> are there also type-classes for Magma, Quasigroup, Loop, Semigroup and Group? (i only know of the Monoid type-class.)
02:34:08 <b_jonas> mekeor: there are typeclasses for some of these in some module
02:34:50 * mekeor just found Semigroup.
02:35:37 <mekeor> @package semigroups -- by edwardk
02:35:38 <lambdabot> http://hackage.haskell.org/package/semigroups -- by edwardk
02:37:37 <ion> Alas, that’s not Monoid’s superclass.
02:38:10 <Catnaroek> @src gets
02:38:11 <lambdabot> Source not found. Sorry.
02:39:11 <mekeor> ion: (1) what does "alas" mean? (2) why not?
02:39:27 * nand` can't think of much use for a Magma type class
02:39:46 <srhb> mekeor: (1) It's "but" with an "unfortunately" smacked on.
02:39:48 <ion> (1) http://dictionary.reference.com/browse/alas (2) Another historical accident that’s difficult to fix now.
02:40:02 <nand`> mekeor: (2) because Monoid was introduced before Semigroup, the latter is also not a base type
02:40:05 <ion> Just like Monad not depending on Applicative.
02:40:14 <mauke> mekeor: jedoch, allein
02:40:51 <mekeor> mauke: danke :)
02:40:53 <mekeor> ion: i see.
02:40:54 <dmwit> srhb: Did you take a look at the wiki page on building gtk2hs on Mac OS?
02:41:09 <dmwit> srhb: If the instructions there don't work, how would you feel about buying me some Mac hardware? =)
02:41:49 <srhb> dmwit: I'd feel very bad about that. :-) Honestly right now I think only the hackage version is broken, I haven't tested from darcs. I was only commenting on it because wx is also broken right now, which might comfort someone. :-)
02:42:01 <mekeor> ion: i wonder how those type-classes would be defined nicely. i mean, how would you solve this circular hierarchy?: http://upload.wikimedia.org/wikipedia/commons/d/d0/Magma_to_group2.svg
02:42:32 <dmwit> Oh, because of the wrong #include, thing?
02:42:34 <dmwit> okay
02:42:39 <srhb> dmwit: Yeah, I think so.
02:43:13 <ion> mekeor: That’s not circular.
02:43:16 <nand`> mekeor: what I'd do is put the dependencies on the right side; because I feel Semigroup/Monoid crop up more often than Quasigroup/Loop/Unital
02:43:25 <srhb> dmwit: I might try with the native GTK+ though, that might be fun and worth messing with various darcs versions.
02:43:48 <dmwit> mekeor: don't see a problem with that graph
02:44:19 <mekeor> ion: well, how would you define Group? "class Loop t => Group t where" or "class Monoid t => Group t where" would not work…
02:44:21 <dmwit> class (Loop a, Monoid a) => Group a
02:44:46 <mekeor> dmwit: well, it doesn't have to be in both. does it?
02:45:25 <shachaf> http://slbkbs.org/out.pdf -- incomplete
02:45:34 <dmwit> A group is both a monoid and a loop, yes.
02:45:55 <mekeor> dmwit: okay… right… i got it, yea. coool!
02:47:37 <srhb> dmwit: When the wiki page says "get the gtk2hs tarball from the gtk2hs website" -- which file is it talking about?
02:47:52 <dmwit> erm
02:47:55 <srhb> Yeah.
02:47:56 <srhb> :-)
02:48:15 <mekeor> shachaf: cool! thanks!
02:48:33 <mekeor> shachaf: btw, also thanks for jsgif :D
02:48:46 <dmwit> srhb: What wiki page are you looking at?
02:48:57 <dmwit> Ah, I see it.
02:49:03 <srhb> dmwit: http://www.haskell.org/haskellwiki/Gtk2Hs/Mac#GTK.2B_OS_X_Framework -- bullet point 3
02:51:48 <dmwit> srhb: One of these, probably: http://sourceforge.net/projects/gtk2hs/files/gtk2hs/
02:52:03 <dmwit> srhb: (linked at the bottom of the "downloads" page on the main gtk2hs website)
02:52:47 <srhb> dmwit: I see, okay. If I get this working I'll fix the Wiki page. So annoying when they're written with an insider angle. :-)
02:53:32 <mekeor> is there a way to define "class synonyms", just like "type synonyms"? i mean, i don't always want to write "f :: (A t, B t) => … -> t -> …" but instead, i want to define a class synonym such that i don't have to write "(A t, B t) => …" but just "C t => …".
02:53:33 <dmwit> I don't think it's written with an insider angle. It was just written before gtk2hs switched to cabal.
02:53:44 <srhb> dmwit: Ah.
02:54:05 <dmwit> mekeor: Unfortunately, no, though there are a handful of proposals.
02:54:12 <mekeor> dmwit: cool.
02:54:29 <dmwit> mekeor: Of course, you can write
02:54:41 <dmwit> class C t; instance (A t, B t) => C t
02:55:14 <mekeor> ah, true. right, cool. that's helpful, thanks!
02:55:17 <ocharles> isn't what mekeor is asking for the ConstraintKinds extension?
02:55:30 <dmwit> oh
02:55:31 <ocharles> and i thought that had been merged?
02:55:33 <dmwit> Yeah, maybe!
02:55:41 <mekeor> ?
02:55:44 <dmwit> type C t = (A t, B t) -- ?
02:55:49 * dmwit tests
02:55:53 <ocharles> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/constraint-kind.html
02:56:25 <mekeor> ocharles: yea, i'm reading it
02:56:32 <dmwit> Yep, that seems to work.
02:56:38 <mekeor> dmwit: O_O great!
02:56:39 <dmwit> Okay, I was just categorically wrong, then. =D
02:57:14 <mekeor> dmwit: so, is C really a class in "type C t = (A t, B t)" ?
02:57:42 <dmwit> C t is a constraint
02:58:08 <mekeor> "constraint" means "what is left from =>" right?
02:58:11 <dmwit> C is not a legal expression
02:58:17 <dmwit> yes
02:58:48 <shachaf> > let f :: a -> Ord a => a -> Ordering; f = compare in f 1 2
02:58:49 <lambdabot>   Could not deduce (GHC.Classes.Ord a) from the context ()
02:58:50 <lambdabot>    arising from a ...
02:59:03 <shachaf> > let f :: a -> Ord a => a -> Ordering; f x y = compare x y in f 1 2
02:59:04 <mekeor> dmwit: great. thanks, ocharles! :)
02:59:04 <lambdabot>   LT
02:59:05 <shachaf> Hah.
02:59:20 <shachaf> Is that supposed to work that way?
02:59:21 <mekeor> shachaf: wtf.
02:59:35 <mekeor> what the hell does that mean??
02:59:58 <ion> shachaf: ಠ_ಠ
03:00:12 <shachaf> ion: ಡ_ಢ
03:00:31 <ion> Ah, the “cat pooping, from behind” glyph.
03:00:40 <dmwit> Hm, I thought recent GHC's made that illegal.
03:01:11 <dmwit> apparently not
03:01:22 <mekeor> i still don't understand it. please explain it! =)
03:01:50 <mm_freak> interestingly i was waiting a long time for ConstraintKinds to become available on arch linux just to find myself not using it =)
03:02:13 <mm_freak> i do use DataKinds though
03:02:52 <ion> mm_freak: The next time you want something to “become available” in your distro, install GHC under ~ from the haskell.org binary package. ;-)
03:03:06 <mm_freak> i'd like to avoid that
03:03:26 <mm_freak> i do install haskell packages using cabal, but i prefer to install GHC and cabal-install itself using my distribution
03:03:27 <ion> It takes next to no effort.
03:03:57 <mm_freak> it does…  it takes the effort of my own auditing whether the latest GHC is really stable enough with the rest of my system =)
03:04:30 <ion> Well, you can switch back to an earlier version as easily as you can install the newest one.
03:05:27 <mm_freak> it's just not worth the extra effort, no matter how small it is
03:05:44 <mm_freak> i'm already maintaining two package repositories:  arch and hackage
03:05:50 <mm_freak> that would be a third repository to maintain
03:06:50 <nand`> so has anybody ever defined a type-safe data type for HTML; where the valid tags themselves are type constructors accepting only those types that would be allowed in, say, valid strict HTML5?
03:07:00 <Catnaroek> @type lift
03:07:01 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
03:07:35 <nand`> in other words; a type that gives you the assurance of “if a value of this type exists, it's a valid HTML tree”
03:08:30 <zenzike> I'm having odd troubles installing zlib: it thinks the c library is missing even though I have zlib1g-dev installed (ubuntu). does anybody have any suggestions?
03:08:37 <dmwit> Oh, no, it was fixed to explicitly allow that (and not panic).
03:08:44 <dmwit> http://hackage.haskell.org/trac/ghc/ticket/3272
03:08:56 * hackagebot x-dsp 0.2.3.1 - A embedded DSL for manipulating DSP languages in Haskell  http://hackage.haskell.org/package/x-dsp-0.2.3.1 (JohnLato)
03:09:09 <dmwit> mekeor: Anyway, it means the same thing as if you had put the constraint at the beginning instead.
03:09:13 <dmwit> ...roughly
03:09:37 <ion> @type undefined :: a -> Ord a => a
03:09:38 <dmwit> "constraints" are implemented as runtime parameters that are plumbed through the code for you.
03:09:39 <lambdabot> forall a. (Ord a) => a -> a
03:09:46 <ion> @type undefined :: a -> b -> Ord a => a
03:09:46 <gienah> zenzike: cabal configure --verbose=3 and looking carefully at the output might give some hints
03:09:48 <lambdabot> forall a b. (Ord a) => a -> b -> a
03:09:51 <dmwit> The => looks a lot like a function arrow because it *is* a function arrow -- just with an implicit argument.
03:10:09 <ion> @type undefined :: a -> b => c
03:10:11 <lambdabot> malformed class assertion
03:10:16 <nand`> :t let f :: a -> Ord a => a -> Ordering; f x = compare x in f id
03:10:17 <lambdabot> forall a. (Ord a) => (a -> a) -> Ordering
03:10:25 <zenzike> gienah: thanks
03:10:25 <gienah> zenzike: I've seen it complain the library is missing when it gets a linker error
03:11:08 <mekeor> dmwit: so, "f :: a -> Ord a => a -> Ordering" is the same as "(Ord a) => (a -> a) -> Ordering" ?!
03:11:20 <dmwit> nand`: Now that I don't understand. Why isn't the constraint it infers there "Ord (a -> a)"?
03:11:29 <zenzike> gienah: hmm. it's soemthing to do with --hash-size=31 being an unknown option. I'll start digging. thanks for the pointer.
03:11:40 <dmwit> mekeor: No, it should be the same as "f :: Ord a => a -> a -> Ordering".
03:11:50 <mekeor> hmmm
03:11:56 <nand`> > compare id id
03:11:57 <lambdabot>   *Exception: (==): No overloading for function
03:12:06 <dmwit> nand`: ah
03:12:09 <dmwit> lame
03:12:11 <nand`> dmwit: some weird Ord instance, I presume
03:12:17 <dmwit> right
03:12:45 <nand`> I'm actually trying to figure out a type that *doesn't* have an Ord instance, I figured functions wouldn't have one
03:12:48 <nand`> guess I was wrong
03:12:56 <nand`> (without defining my own or using something overly obscure, I mean)
03:13:33 <dmwit> > compare x y
03:13:34 <lambdabot>   LT
03:13:42 <nand`> :/
03:13:48 <nand`> I think that one does string comparison
03:13:51 <mauke> > a < z
03:13:52 <lambdabot>   True
03:14:02 <ion> nand: Nope.
03:14:04 <ion> @type a
03:14:06 <lambdabot> Expr
03:14:16 <dmwit> ion: I'm pretty sure he's right.
03:14:26 <dmwit> ion: One of the constructors for Expr has a String as its argument.
03:14:36 <ion> Ah, in that sense. I misinterpreted what he said.
03:14:52 <nand`> ah yeah, it depends; two intExprs get compared, so do doubleExprs
03:14:53 <dmwit> > var "dmwit" :: Expr
03:14:53 <Catnaroek> @type evalState
03:14:54 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
03:14:54 <lambdabot>         against inferred ...
03:14:54 <lambdabot> forall s a. State s a -> s -> a
03:14:55 <nand`> otherwise it's string comparison
03:15:04 <dmwit> :t var
03:15:05 <lambdabot> forall a. String -> Sym a
03:15:05 <nand`> but for ‘a’ ‘b’ it's certainly the latter
03:15:08 <shachaf> The Ord a thing was just a GHC 6.12 bug.
03:15:12 <shachaf> Works in 7.4
03:15:33 <shachaf> Cale: You should upgrade GHC!
03:15:51 <dmwit> shachaf: What's the bug?
03:16:42 <nand`> dmwit: is that another “var”?
03:16:50 <nand`> SimpleReflect.hs's has var :: String -> Expr
03:17:02 <mauke> @hoogle var
03:17:03 <lambdabot> Language.Haskell.TH.Syntax VarE :: Name -> Exp
03:17:03 <lambdabot> Language.Haskell.TH VarE :: Name -> Exp
03:17:03 <lambdabot> Language.Haskell.TH.Lib varE :: Name -> ExpQ
03:17:05 <dmwit> shachaf: (You mean there's some bug that is visible in \bot related to the stuff we're playing around with?)
03:17:09 <shachaf> dmwit: The a -> Ord a => a -> Ordering thing being different.
03:17:21 <shachaf> > let f :: a -> Ord a => a -> Ordering; f = compare in f 1 2
03:17:22 <lambdabot>   Could not deduce (GHC.Classes.Ord a) from the context ()
03:17:22 <lambdabot>    arising from a ...
03:17:24 <shachaf> > let f :: a -> Ord a => a -> Ordering; f x y = compare x y in f 1 2
03:17:26 <lambdabot>   LT
03:17:40 <dmwit> shachaf: The bug in 6.12 caused the former to panic, no?
03:17:53 <shachaf> dmwit: I don't know.
03:17:58 <nand`> :t compare :: a -> Ord a => a -> Ordering
03:17:59 <shachaf> I'm pretty sure lambdabot is running 6.12.
03:17:59 <lambdabot>     Could not deduce (Ord a) from the context ()
03:18:00 <lambdabot>       arising from a use of `compare' at <interactive>:1:0-6
03:18:00 <lambdabot>     Possible fix:
03:18:09 <b_jonas> uh, how does "a -> Ord a => a -> Ordering" even parenthisize?
03:18:16 <nand`> :t (\x -> compare x) :: a -> Ord a => a -> Ordering
03:18:17 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
03:18:28 <shachaf> b_jonas: (a) -> (Ord a) -> (a) -> Ordering
03:18:31 <shachaf> Er.
03:18:33 <shachaf> b_jonas: (a) -> (Ord a) => (a) -> Ordering
03:18:41 <dmwit> shachaf: http://hackage.haskell.org/trac/ghc/ticket/3272 -- not fixed until 6.12.1
03:18:47 <b_jonas> um, okay, but how does it parenthisize then?
03:18:50 <shachaf> dmwit: Maybe 6.12.1, then.
03:18:55 <nand`> I'd guess a -> (Ord a => a -> Ordering)
03:18:56 <Peaker> a -> (Ord a => (a -> Ordering)) ?
03:19:03 <dmwit> b_jonas: a -> (Ord a => (a -> Ordering))
03:19:05 <shachaf> Oh, what the other people said.
03:19:16 <mekeor> aaaaah! now i got it!
03:19:22 <b_jonas> is that type equivalent to a (Ord a) => (a -> a -> Ordering) ?
03:19:29 <nand`> b_jonas: mostly
03:19:36 <b_jonas> ok
03:19:43 <nand`> from what I figure, with the former you can partially apply the function with something that doesn't have an Ord instance
03:19:43 <mekeor> nand`: what is the difference?
03:19:46 <nand`> but you can't go further
03:19:49 <nand`> not sure if this is correct
03:19:51 <mekeor> ah, cool.
03:19:54 <Catnaroek> Hello. I have the following snippet in my program: http://hpaste.org/70065 . Is there any way to contract lines 4 and 5 into a single line? Ditto for lines 10 and 11.
03:19:54 <b_jonas> I'm not used to seeing constraints in the middle
03:19:57 <dmwit> This is not correct.
03:20:05 <nand`> okay, then forget what I said
03:20:06 <dmwit> Both can be partially applied to non-Ord types.
03:20:10 <nand`> dmwit: oh, right
03:20:11 * mekeor forgets.
03:20:20 <mekeor> dmwit: oO
03:20:22 <dmwit> The resulting type will be one which has an unsatisfied constraint.
03:20:29 <mekeor> wow.
03:20:42 <b_jonas> Catnaroek: is that even valid syntax?
03:20:54 <dmwit> Just because it's unsatisfied in your little module doesn't mean it's a dumb thing to do -- some other module may be able to satisfy the constraint. =)
03:20:57 <b_jonas> I can't parse it
03:21:06 <nand`> hmm
03:21:17 <mekeor> Catnaroek: seems you need a do-block.
03:21:19 <Catnaroek> b_jonas: Oh, I forgot a couple of dos
03:21:22 <Catnaroek> mekeor: yes
03:21:23 <Catnaroek> But
03:21:26 <Catnaroek> the main problem is not that
03:21:27 <zenzike> gienah: solved. apparently the ld in binutils-gold doesn't support the --hash-size option, removing binutils-gold fixed things up
03:21:34 <dmwit> The difference is that the constraint gets passed a bit later, so if you can actually do some (recursive) work without the dictionary, you may get a slight runtime win.
03:21:38 <Catnaroek> the main problem is that lines 4-5 look ugly
03:21:43 <gienah> zenzike: great :-)
03:21:44 <Catnaroek> they look like it could be done in one line
03:22:09 <mauke> Catnaroek: they can't
03:22:22 <Catnaroek> mauke: :( absolutely no way to do it?
03:22:30 <b_jonas> dmwit: I see
03:22:36 <shachaf> I wonder whether that bug is fixed.
03:22:45 <nand`> :t (+) "foo" :: Num String => String -> String
03:22:45 <shachaf> @ty id :: (Ord a => a) -> (Ord a => a)
03:22:46 <lambdabot>     No instance for (Num String)
03:22:46 <lambdabot>       arising from an expression type signature at <interactive>:1:0-42
03:22:47 <lambdabot>     Possible fix: add an instance declaration for (Num String)
03:22:47 <lambdabot> forall a. (Ord a) => ((Ord a) => a) -> a
03:22:48 <shachaf> Nope.
03:22:53 <dmwit> Catnaroek: With most transformers, gets = lift . gets
03:23:03 <dmwit> Catnaroek: (The obvious exception being StateT.)
03:23:03 <b_jonas> so basically type -> and type => has the same fixity?
03:23:17 <b_jonas> syntax-wise
03:23:18 <Catnaroek> dmwit: So I don't need that lgets, then, right?
03:23:22 <dmwit> right
03:23:35 <hpaste_> mekeor annotated “help” with “help (annotation) (not sure)” at http://hpaste.org/70065#a70066
03:23:40 <hpaste_> mauke annotated “help” with “help (annotation)” at http://hpaste.org/70065#a70067
03:23:47 <Catnaroek> dmwit: well at least that makes me a little happier :)
03:24:22 <hpaste_> mekeor annotated “help” with “help (annotation) (annotation)” at http://hpaste.org/70065#a70068
03:24:26 <dmwit> mauke: Now just use (>>=) to collapse them to a single line. ;-)
03:24:31 <mekeor> dmwit: done.
03:24:41 <mauke> mekeor: that looks wrong
03:24:43 <shachaf> mekeor: I don't think your thing even works.
03:24:46 <mauke> (precedence of $)
03:24:49 <mekeor> oh, right.
03:25:02 <hpaste_> mekeor annotated “help” with “help (annotation) (annotation) (annotation)” at http://hpaste.org/70065#a70069
03:25:08 <dmwit> Catnaroek: May I suggest the EitherT monad transformer?
03:25:19 <dmwit> err... ignore me
03:25:23 <b_jonas> wow, the titles of the annotations are starting to get out of hand
03:25:23 <mekeor> mauke: now?
03:25:37 <Catnaroek> dmwit: What?
03:25:39 <shachaf> I still don't think it actually helps.
03:25:40 <mauke> better :-)
03:25:41 <mekeor> > fix ("(annotation) "++)
03:25:44 <Catnaroek> dmwit: I thought ErrorT was that.
03:25:45 <lambdabot>   "(annotation) (annotation) (annotation) (annotation) (annotation) (annotati...
03:25:53 <Catnaroek> dmwit: What is EitherT? :O
03:26:02 <dmwit> Catnaroek: No, you're right. Ignore me.
03:26:14 <Catnaroek> :P
03:26:15 <b_jonas> hmm
03:26:44 <b_jonas> mekeor: no good, you want help (fix ($ annotation))
03:26:51 <nand`> I like how you can look at lift (gets $ M.lookup n) >>= maybe (throwError $ n ++ " does not exist") return -- and instantly understand what the code does
03:26:56 <nand`> <3 Haskell
03:26:59 <b_jonas> because it's help called a lot of times
03:27:07 <b_jonas> must be one of those crazy printf-like templates
03:27:26 <mauke> > fix error
03:27:28 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
03:27:44 <b_jonas> heh
03:28:13 <nand`> at the end of that chain of Exceptions should be “Exception: lambdabot is too lazy to fix errors”
03:28:46 <Catnaroek> nand`, ?
03:29:12 <Catnaroek> mauke, lol
03:29:14 <dmwit> That's some deceptive output. The value of "fix error" is not actually "*Exception: *Exception: " ++ ...
03:29:33 <b_jonas> > error "hello"
03:29:34 <lambdabot>   *Exception: hello
03:29:38 <b_jonas> > error (error "hello")
03:29:39 <lambdabot>   *Exception: hello
03:29:43 <dmwit> > error "hello" :: String
03:29:44 <lambdabot>   "*Exception: hello
03:29:51 <b_jonas> ah
03:30:02 <b_jonas> makes sense
03:30:17 <mekeor> lambdabot: you for got a " at the end.
03:30:20 <dmwit> Yes, in a demented sort of way it makes sense. =D
03:30:24 <dmwit> mekeor: nope =)
03:30:28 <mekeor> oO
03:30:40 <nand`> > error (error "hello" :: String) :: String
03:30:41 <lambdabot>   "*Exception: hello
03:30:48 <Catnaroek> @type maybe
03:30:50 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:30:51 <mekeor> oh, of course!
03:30:57 <dmwit> mekeor: sneaky, right? -D
03:30:58 <mekeor> it's lazy…
03:31:04 <mauke> @quote fix.club
03:31:05 <lambdabot> mauke says: the first rule of fix club is "the first rule of fix club is "the first rule of fix cl...
03:31:20 <Catnaroek> @hoogle maybe
03:31:20 <lambdabot> Prelude data Maybe a
03:31:20 <lambdabot> Data.Maybe data Maybe a
03:31:21 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
03:32:23 <dmwit> nand`: Hm. I would have expected slightly more exception there.
03:32:23 <mekeor> Catnaroek: btw, you can also use http://www.haskell.org/hoogle/ or /msg lambdabot @hoogle (or even http://holumbus.org/hayoo/hayoo.html) ;) =) :D :) :] =]
03:32:29 <felix__> hi
03:32:32 <nand`> dmwit: me too
03:32:34 <mekeor> hi felix__
03:32:39 <nand`> dmwit: I still don't quite get it
03:32:55 <nand`> > error (error (error (error "hello"))) :: String
03:32:56 <lambdabot>   "*Exception: hello
03:32:58 <felix__> I'm trying to use Trifecta, but I can't find a function that parses directly from a String
03:33:15 <dmwit> felix__: I'm pretty sure edwardk said there isn't one in here the other day.
03:33:19 <nand`> my intuition tells me “fix error” should be "*Exception:     followed by _|_
03:33:23 <felix__> oh ok
03:33:28 <felix__> sorry then
03:33:31 <shachaf> nand`: Yep, that's what it is.
03:33:38 <dmwit> nand`: It is, but _|_ is spelled *Exception: ...
03:33:57 <dmwit> nand`: I don't understand why your finite number of "error" calls isn't printing out nested exceptions, though.
03:34:07 <shachaf> This is misleading in lambdabot, but note that "fix error" doesn't give you a string that has the word Exception in it.
03:34:13 <dmwit> > error ("a" ++ error "b")
03:34:15 <lambdabot>   *Exception: a*Exception: b
03:34:31 <dmwit> > error ("" ++ error "b")
03:34:33 <lambdabot>   *Exception: b
03:34:37 <dmwit> ...wut
03:35:02 <dmwit> Maybe \bot checks for a finite number of exceptions and flattens them.
03:35:08 <felix__> so that means I have to write myself, by looking at the code, etc.?
03:35:15 <felix__> using starve, feed and everything?
03:35:18 <dmwit> > foldr (.) id (replicate 100 error) "a"
03:35:20 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
03:35:23 <felix__> that's a bit sad there isn't one
03:35:26 <dmwit> > foldr (.) id (replicate 50 error) "a"
03:35:28 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
03:35:33 <dmwit> > foldr (.) id (replicate 25 error) "a"
03:35:35 <felix__> it's very useful to have one
03:35:36 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
03:35:36 <mauke> s/50/1/
03:35:42 <dmwit> > foldr (.) id (replicate 2 error) "a"
03:35:44 <lambdabot>   "*Exception: *Exception: a
03:35:46 <nand`> take 100 $ fix error :: String  -- this out still prints out infinite “Exception” in ghci
03:35:47 <Codex_> hmm, what is needed for haskell to call c++ library (just few simple classes needed...)?
03:35:51 <dmwit> wut!
03:36:02 <b_jonas> Codex_: you call it through C probably
03:36:07 <mauke> Codex_: a C interface to the library
03:36:08 <dmwit> > foldr (.) id (replicate 2 f) x
03:36:10 <lambdabot>   f (f x)
03:36:11 <b_jonas> make a C interface for the library then call that
03:36:12 <nand`> > (error . error) "a"
03:36:14 <lambdabot>   *Exception: *Exception: a
03:36:21 <nand`> > error (error "a")
03:36:22 <lambdabot>   *Exception: a
03:36:26 <b_jonas> namely such a C interface that you can call through the haskell ffi
03:36:29 <dmwit> whaaaat
03:36:30 <nand`> lambdabot broke Haskell
03:36:50 <nand`> but yeah, that explains why "fix error" prints out infinite Exceptions in lambdabot
03:37:00 <nand`> I think..
03:37:07 <mauke> compare results in ghci
03:37:34 <nand`> mauke: I get the same output in ghci, with my last two inputs
03:37:36 <dmwit> \bot matches ghci
03:37:41 <Codex_> b_jonas: the C interface will work fine
03:37:43 <dmwit> So what exactly is happening?
03:37:56 <nand`> dmwit: no idea, but I think it's because error (error "a") terminates before it gets to the outer error
03:38:03 <nand`> exceptions and all
03:38:05 <Codex_> b_jonas: but might still have a problem with one Env class which should be hidden.
03:38:08 <nand`> meanwhile (error . error) "a" .. I have no idea
03:38:14 <b_jonas> nand`: I don't quite understand either
03:38:18 <b_jonas> I can understand the double quote
03:38:30 <b_jonas> but not how many "Exception: " it prints
03:38:50 <dmwit> I'm going to post to StackOverflow.
03:38:53 <nand`> > error (error "a" :: String) :: String
03:38:54 <lambdabot>   "*Exception: a
03:39:02 <shachaf> > error (error undefined)
03:39:03 <lambdabot>   *Exception: *Exception: Prelude.undefined
03:39:07 <yitz> > fix breakage
03:39:09 <lambdabot>   "No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No...
03:39:10 <shachaf> > error (error (error (error "a")))
03:39:11 <lambdabot>   *Exception: a
03:39:20 <nand`> yitz++
03:39:31 <mauke> :t breakage
03:39:32 <lambdabot> [Char] -> [Char]
03:39:37 <nand`> > error (error (error (error undefined)))
03:39:37 <lambdabot>   *Exception: *Exception: Prelude.undefined
03:39:39 <twx_haskell> second?  or sed  or scd  what is second?
03:39:48 <shachaf> @hoogle (a,b) -> b
03:39:49 <lambdabot> Prelude snd :: (a, b) -> b
03:39:49 <lambdabot> Data.Tuple snd :: (a, b) -> b
03:39:49 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
03:40:03 <nand`> > second (+1) (3, 4)
03:40:04 <lambdabot>   (3,5)
03:40:16 <b_jonas> well, `ghc -e "fix error"' hard-hangs for me in a loop so much that only a sigkill kills it
03:40:26 <twx_haskell> thank you !
03:41:09 <yitz> @hoogle second
03:41:09 <nand`> dmwit: see this is what happens when you mess with weird, unsafe functions like “error”
03:41:09 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
03:41:09 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec class SecondaryColor a
03:41:10 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec secondaryColor :: SecondaryColor a => a -> IO ()
03:41:21 <nand`> is “error” a primitive or is it implemented in terms of unsafePerformIO ?
03:41:50 <yitz> twx_haskell: never mind the crazy type. anyway, that shows that you can import second from Control.Arrow.
03:42:12 <mauke> @src error
03:42:13 <lambdabot> error s = throw (ErrorCall s)
03:42:34 <LambdaDusk> can anyone tell me why the type checker tells me `forall t. NetworkDescription t ()' and `NetworkDescription t0 ()' are entirely different types?
03:42:58 <twx_haskell> Are we have chinese friends?
03:43:06 <shachaf> LambdaDusk: Because they are.
03:43:19 <mauke> preflex: seen ManateeLazyCat
03:43:19 <preflex>  ManateeLazyCat was last seen on #haskell 95 days, 20 hours, 8 minutes and 54 seconds ago, saying: applicative: Gnome-Shell lies to on powerful with gjs, it use JavaScript, make desktop environment not stable enough, it use clutter library, make it can't running on ATI driver, i hate it.
03:43:20 <dmwit> twx_haskell: There is also snd :: (a,b) -> b
03:43:20 <yitz> anyone who needs SO karma - get ready to post first in response to dmwit's upcoming question
03:43:21 <shachaf> One of them has a free variable (t0) and the other one is universally quantified.
03:43:50 <dmwit> yitz: If somebody in here knew the answer, I bet they'd already have said it here. =D
03:43:58 <shachaf> yitz: Wait, what's the question?
03:44:02 <LambdaDusk> shachaf: I've never liked the forall
03:44:07 <dmwit> shachaf: compare:
03:44:10 <yitz> dmwit: not if they need SO points and they're thinking on their feet
03:44:11 <dmwit> > error (error "")
03:44:11 <lambdabot>   *Exception:
03:44:12 <nand`> shachaf: free variables in whole type expressions are automatically quantified though, aren't they?
03:44:15 <dmwit> > (error . error) ""
03:44:17 <lambdabot>   *Exception: *Exception:
03:44:42 <nand`> “whole type expressions” here means the RHS of a ::
03:44:43 <b_jonas> yitz: where's his question?
03:44:48 <unnali> http://stackoverflow.com/questions/11070690/how-do-exceptions-work
03:44:59 <b_jonas> thanks
03:44:59 <bitonic> nand`: GHC displays all quantifications
03:44:59 <bitonic> when printing types
03:45:02 <dmwit> http://stackoverflow.com/q/11070690/791604
03:45:13 <Saizan> dmwit: GHC never guaranteed which of the possible exceptions is the one you get
03:45:24 <bitonic> nand`: in that case they're all quantified immediately to the right of the ::, yes
03:45:33 <shachaf> Probably some transformation GHC is allowed to make.
03:45:55 <dmwit> ghci does optimizations?
03:46:08 <shachaf> Not all transformations are optimizational.
03:46:15 <dmwit> oops, gotta run
03:46:16 <nand`> re: error and unsafePerformIO; it's implemented in terms of the “raise#” primitive it seems
03:47:52 <Catnaroek> Where is if' defined?
03:47:56 <nand`> in lambdabot
03:47:56 <shachaf> Nowhere.
03:48:01 <mauke> I don't think it is
03:48:03 <Catnaroek> Oh.
03:48:05 <Catnaroek> Dang.
03:48:52 <nand`> why isn't it in Prelude, for that matter? Not like the name is very clashing, is it?
03:48:56 <nand`> and it can be useful
03:48:57 <nand`> :t liftA3 if'
03:48:58 <lambdabot> Not in scope: `if''
03:49:03 <nand`> ah, it's not even in lambdabot anymore
03:49:21 <Catnaroek> Well, it is in @pl.
03:49:30 <mekeor> @let if' a b c = if a then b else c
03:49:32 <lambdabot>  Defined.
03:49:54 <Catnaroek> I actually wish a were the last parameter.
03:50:14 <merijn> Catnaroek: Well, defining you own is trivial :p
03:50:18 <unnali> @pl aux f x y z = f y z x
03:50:18 <lambdabot> aux = flip . (flip .)
03:50:35 <unnali> and now, it can be!
03:50:40 <mekeor> @type maybe
03:50:42 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:50:46 <Catnaroek> merijn: Oh, of course, but the point in doing that is reducing boilerplate... if I have to define my own helpers, I am hardly reducing any boilerplate.
03:50:49 <mekeor> Catnaroek: you're right.
03:51:03 <Catnaroek> :O
03:51:23 <mekeor> @type either
03:51:24 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
03:51:51 <Catnaroek> Contrast exists with notExists here: http://hpaste.org/70070
03:51:54 <nand`> I would probably else it “branch”, “choose” or something else
03:51:57 <nand`> probably call it*
03:52:14 <nand`> if the Bool is the last parameter
03:52:14 <mekeor> or "bool".
03:52:23 <Catnaroek> bool would be an awesome name
03:52:26 <Catnaroek> by analogy with maybe
03:52:30 <nand`> yeah, “bool” sounds surprisingly good
03:52:36 <mekeor> Catnaroek: …and either.
03:52:41 <Catnaroek> :P
03:52:58 <Catnaroek> yeah!
03:53:23 * nand` adds it to .ghci
03:53:31 <Catnaroek> nand`, ?
03:53:40 <nand`> Catnaroek: ~/.ghci; for local usage
03:53:47 <Catnaroek> Oh!
03:53:49 <mekeor> oO
03:53:50 <Catnaroek> :D
03:54:13 <Catnaroek> Haskell really makes me feel happy. I do not exactly know why. It fills me with joy.
03:54:16 <mekeor> so, .ghci is just a haskell source code file?
03:54:58 <mekeor> which is automatically loaded by ghci?
03:55:01 <mekeor> mauke?
03:55:04 <unnali> Catnaroek: common reaction. see doctor if condition persists. (jk, it's amazing)
03:55:05 <nand`> Catnaroek: don't worry, it's like that for all of us
03:55:07 <nand`> mekeor: no
03:55:22 <nand`> mekeor: .ghci is a list of expressions that act as if you had typed them into .ghci's prompt
03:55:30 <nand`> for example you can use :set in .ghci
03:55:42 <mekeor> ah, nice.
03:55:48 <nand`> :set prompt "λ" -- one I'm quite fond of :)
03:55:48 <nand`> "λ " even
03:56:04 <nand`> so you have to define in-line like you would in ghci
03:56:09 <nand`> let f :: foo; f = ...
03:56:32 <mekeor> aah, nice!
03:57:19 <shachaf> Or you can put in .ghci in any directory: ":! rm -rf ~", and then if someone runs ghci in that directory it'll delete all their files.
03:58:20 <mekeor> hehehehe
03:58:26 <unnali> shachaf: ouch
03:58:49 <Taneb> Assuming they're on a Unix-like OS
03:58:54 <Taneb> Windows users are safer
03:59:00 * hackagebot arbb-vm 0.1.1.14 - FFI binding to the Intel Array Building Blocks (ArBB) virtual machine.  http://hackage.haskell.org/package/arbb-vm-0.1.1.14 (JoelSvensson)
03:59:01 <Catnaroek> :O
03:59:04 <derelm> i am in the process of revisiting haskell and old code i wrote. with one file i get "Could not find module `Char`  It is a member of the hidden package `haskell98-2.0.0.1'." can someone please quickly explain that message? the code in question was written around 2005 during a university course
03:59:11 <mekeor> Taneb: in this case only.
03:59:14 <unnali> derelm: try `import Data.Char' intsead.
03:59:15 <unnali> instead*
03:59:18 <bitonic> Taneb: well, "safer" in the sense that that particular command won'w work
03:59:23 <Taneb> Yeah
03:59:26 <nand`> shachaf: ouch. can I disable :! ?
03:59:32 <unnali> derelm: haskell98 didn't have the module hierarchy we have now, so it was just `Char'.
03:59:38 <derelm> unnali: so this is just to express that modules have been reorganized?
03:59:47 <derelm> unnali: i see, thanks a lot
03:59:58 <nand`> I've never seen a need for it
03:59:58 <nand`> actually nvm
03:59:58 <nand`> that won't help much
04:00:20 <nand`> .ghci could simply contain “import System.Files” followed by whatever-command-deletes-files
04:00:44 <nand`> shachaf: a better question. can I configure ghci to ignore .ghci files not in my home directory?
04:01:01 <unnali> derelm: pretty much. you could demand that haskell98 is unhidden (to get that behaviour back), but better off just adjusting your import imo.
04:01:49 <bitonic> nand`: ...it will already
04:02:04 <bitonic> nand`: unless I'm misunderstanding what you're saying
04:03:20 <nand`> bitonic: mkdir ~/foo; cd ~/foo; echo "let foo = 5" > .ghci; ghci
04:03:25 <nand`> “foo” now evaluates to 5
04:04:18 <unnali> bitonic: i.e. ghci will read .ghci from the current directory, which is a security issue because e.g. you untar a package of someone else's, run `ghci' and accidentally execute whatever code *they* put there.
04:05:02 <srhb> Is there an ls-like haskell function where I can make glob patterns?
04:05:17 <bitonic> nand`, unnali: well ghci is quite picky about permissions. and anyway, if you are not careful about what you download, you have a problem already
04:05:47 <LambdaDusk> Anyone having a little experience with reactive-banana can tell me how to make a "Quit" event that breaks the event loop?
04:06:07 <mauke> bitonic: what
04:06:09 <deggis> i'm kinda frequently summoning ghci to test or calculate something and not at all looking where i was. this was good to hear now
04:06:10 * nand` just gets into the habit of using ls -a in foreign directories before ghci
04:06:21 <bitonic> mauke: what what?
04:06:37 <mauke> bitonic: what do you mean by "quite picky about permissions"?
04:06:43 <mauke> and how does that help with anything?
04:06:59 <derelm> i am using mac + homebrew nowadays and i wonder if i need to have both installed: ghc and haskell-platform  or is the latter containing the former. maybe someone using the same tool can shed some light?
04:07:10 <unnali> derelm: the latter does require the former, yes.
04:07:25 <merijn> derelm: Haskell Platform will install ghc
04:07:26 <unnali> derelm: installing haskell-platform will automatically drag in ghc (meaning, don't remove ghc! :))
04:07:33 <bitonic> mauke: it won't pick up ghci files unless they're not writable by anyone but you. it helps because a lot of files are not like that :P
04:07:42 <merijn> oh, wait. homebrew, ignore me
04:08:17 <mauke> bitonic: doesn't help with .tar
04:08:24 <unnali> bitonic: that's true, but I still think there's a big issue with downloaded code.
04:08:32 <derelm> the thing that made me wonder was, haskell platform states that it includes happy, yet i had to install it using cabal - so thought maybe installing haskell-platform and ghc created like two separate environments
04:08:42 <twx_haskell> let  take5 =filter (==5) in map take5 [[1,5],[5],[1,1]]
04:08:45 <bitonic> mauke: no it doesn't in all cases, no.
04:08:55 <twx_haskell> i can't get what i want
04:09:04 <merijn> bitonic: In fact, it doesn't help for the most important cases
04:09:06 <mauke> > let  take5 =filter (==5) in map take5 [[1,5],[5],[1,1]]
04:09:08 <lambdabot>   [[5],[5],[]]
04:09:09 <unnali> derelm: strange. mine came with happy.
04:09:27 <unnali> twx_haskell: what /ddo/ you want? :)
04:09:28 <unnali> do*
04:09:29 <twx_haskell>    []  is what
04:09:37 <merijn> twx_haskell: Empty list
04:09:46 <twx_haskell> why
04:09:56 <twx_haskell> it == 5?
04:09:58 <mauke> because 1 is not 5 and 1 is not 5
04:09:58 <b_jonas> because there's nothing in its stomach
04:09:59 <unnali> twx_haskell: you're running take5 on each list separately (`map'), and returning each filtered list. the last list [1,1] has no 5s, so you get []
04:10:01 <merijn> Because [1,1] is just sugar for "1:1:[]"
04:10:18 <b_jonas> > filter (==5) [3,5,2,1,5,10]
04:10:19 <lambdabot>   [5,5]
04:10:21 <mauke> > filter (== 5) [1, 2, 3]
04:10:22 <lambdabot>   []
04:10:27 <b_jonas> those, yes
04:10:40 <twx_haskell> o  yes i get
04:11:40 <merijn> > let take5 = filter (==5) in filter (==[]) $ map take5 [[1,5],[5],[1,1]]
04:11:41 <lambdabot>   [[]]
04:11:44 <merijn> hmm
04:11:48 <merijn> oh, duh
04:11:55 <merijn> > let take5 = filter (==5) in filter (/=[]) $ map take5 [[1,5],[5],[1,1]]
04:11:56 <lambdabot>   [[5],[5]]
04:12:23 <mauke> (== []) considered harmful
04:12:27 <mauke> :t null
04:12:28 <lambdabot> forall a. [a] -> Bool
04:12:29 <twx_haskell> that's good   thank you   i'm a newer
04:12:32 <unnali> mauke: :D!
04:12:50 <b_jonas> mauke: doesn't matter in this context though
04:13:24 <Laguana> Could someone please help me understand how exception handling works? I'm trying to be robust to user input of regexes, and if a malformed regex is used then an exception is thrown; and I can't work out how to catch them.
04:13:26 <nand`> > filter (/= []) [[1..]]
04:13:27 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
04:13:58 <unnali> twx_haskell: btw, ，我不是中国人，可是我会一点点中文（我太太是从辽宁来的）
04:14:23 <Laguana> Most of the documentation I see is about how to not throw exceptions by changing the return value, but this isn't code that I can touch as far as I'm aware
04:14:45 <unnali> Laguana: can you give an example of the code which throws? there are a few ways code can throw exceptions iirc.
04:14:52 <shachaf> Laguana: "exceptions" can mean a lot of things.
04:15:03 <shachaf> If this uses "error" on a malformed regexp then it's evil.
04:15:15 <shachaf> "spoon" exists to deal with evil APIs like that.
04:15:22 <shachaf> @hackage spoon
04:15:22 <lambdabot> http://hackage.haskell.org/package/spoon
04:15:36 <Laguana> Well, from my side of things it is something like, matchRegexp (mkRegex "bad^[") ""
04:15:41 <b_jonas> shachaf: uh, is that a spoon you use to pry your eyes out so you don't see the code?
04:15:49 <shachaf> Keep in mind that spoon is a very -- blunt -- tool.
04:16:05 <unnali> @hoogle matchRegexp
04:16:05 <lambdabot> No results found
04:16:14 <Laguana> then from what I can see, I get the following *** Exception: user error [...]
04:16:23 <shachaf> Laguana: Yes, that's an error.
04:16:29 <shachaf> Laguana: The regexp APIs are pretty horrible.
04:16:38 <Laguana> right
04:16:50 <b_jonas> maybe write a new regex module by wrapping a C library?
04:17:03 <Laguana> I'm pretty sure that the current ones do that from what I've read
04:17:14 <nand`> yes, by using unsafePerformIO and error :P
04:17:14 <Laguana> and I'm not familiar enough with haskell to want to do it myself at this point
04:17:47 <nand`> maybe a write a pure Haskell regex implementation
04:17:47 <shachaf> Laguana: spoon might be the answer to your problems.
04:17:56 <nand`> (or look for one)
04:18:00 <hiptobecubic> Is there a 'everyone uses this' library for symbolic math in haskell (à la Sage/Sympy/Mathematica) ?  There are a million blog posts on how convenient it would be to make one
04:18:14 <shachaf> Are you people serious? Someone comes into the channel, doesn't know much about exceptions, and you tell them to write a whole new library?
04:18:50 <b_jonas> shachaf: sorry
04:18:59 <nand`> shachaf: it would be a good learning experience, wouldn't it?
04:19:23 <b_jonas> maybe just convince someone else to write one
04:19:30 <bitonic> shachaf: I wouldn't suggest to use spoon either, it could give wrong ideas about IO exceptions :P
04:19:37 <shachaf> bitonic: That's true.
04:19:50 <shachaf> Laguana: "spoon" is a sort of last resort that'll work if this library is broken beyond repair.
04:19:57 <Laguana> Yeah, I figured
04:19:59 <nand`> yeah sure, I wasn't really intending for Laguana to write the regex library he needs; I was just throwing out a suggestion to the channel in general
04:20:18 <Laguana> If you know a better regex package then I'll happily try to use that, right now I'm using regex-compat I believe
04:20:22 <shachaf> If there's another way around this issue -- like a separate "compileRegexp" function that returns a nicer return type, for example -- you should definitely use that instead.
04:20:39 <shachaf> I don't know the APIs myself.
04:20:58 <b_jonas> which package is this?
04:21:02 <Laguana> My understanding was that mkRegexp would be the compilation stage, but it only throws errors when I try to do a match, presumably because of either lazy evaluation or because compiling doesn't do anything
04:21:06 <nand`> same, I tend to avoid regexes - there are much better ways of parsing regular languages in Haskell :)
04:21:07 <b_jonas> @hoogle mkRegex
04:21:07 <lambdabot> Text.Regex mkRegex :: String -> Regex
04:21:08 <lambdabot> Text.Regex mkRegexWithOpts :: String -> Bool -> Bool -> Regex
04:21:10 <nand`> but it's unavoidable if you want user interaction
04:21:14 <nand`> (in regex form, that is)
04:21:17 <Laguana> Like I said, I believe I'm using regex-compat
04:21:27 <Laguana> Text.Regex
04:21:31 <Laguana> yeah
04:22:14 <nand`> oh
04:22:25 <nand`> @hoogle makeRegexM
04:22:26 <lambdabot> Text.Regex.Base.RegexLike makeRegexM :: (RegexMaker regex compOpt execOpt source, Monad m) => source -> m regex
04:22:28 <shachaf> Laguana: Ah, looks like there's a version with a nicer API.
04:22:32 <nand`> there's also this which you can use in the Either String or Maybe monad
04:22:34 <shachaf> Yes, makeRegexM.
04:22:39 <shachaf> "nicer" in some ways, less nice in others.
04:22:41 <nand`> it uses “fail” for errors
04:22:54 <shachaf> These type classes are a horrible mess, but at least the function is total.
04:24:59 <Laguana> I guess I'll have a look at it then, see how I go
04:25:45 <nand`> errr
04:25:53 <nand`> regex-compat imports Text.Regex.Base
04:26:01 <nand`> and just uses makeRegexOpts in the Identity monad, it seems
04:27:06 <Laguana> 'This does not provide any of the backends, just the common interface they all use.'
04:27:08 <shachaf> Laguana: You have to import a bunch of modules like Text.Regex.Base and Text.Regex.Posix, and then it's just makeRegexM "..." :: Maybe Regex
04:27:23 <derelm> unnali: is there a resource online where i can see how that package reorganization has been done (like an old -> new mapping)?
04:27:30 <Laguana> Sounds like it doesn't know what a regex looks like anyway, which is why it breaks on the match: until then it doesn't know what is acceptable
04:28:33 <shachaf> No, it should be able to figure out whether the regex is valid as soon as you make the Regex value.
04:29:09 <shachaf> But it might not force the Regex value until the match. Laziness and all. :-)
04:29:16 <shachaf> However, using Maybe takes care of that problem too.
04:29:17 <unnali> derelm: here's a start: http://www.haskell.org/ghc/docs/7.0.4/html/libraries/
04:29:34 <derelm> unnali: thanks again
04:29:52 <unnali> derelm: this is a bit more in-depth: http://www.haskell.org/haskellwiki/Hierarchical_module_names and no probs.
04:32:17 <Laguana> alright thanks shachaf, I think this'll work out for me
04:35:46 <merijn> @hoogle [Maybe a] -> [a]
04:35:47 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
04:35:47 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
04:35:47 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
04:38:42 <merijn> @pl \l k -> catMaybes $ map (flip lookup l) k
04:38:43 <lambdabot> (catMaybes .) . map . flip lookup
04:39:04 * hackagebot tensor 0.1.1 - A completely type-safe library for linear algebra  http://hackage.haskell.org/package/tensor-0.1.1 (NicolaSquartini)
04:40:03 <srhb> Where's the tool that searches hackage like Hoogle does for the base libraries?
04:40:10 <mauke> @where hayoo
04:40:11 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
04:40:21 <srhb> Thanks! Name slipped my mind.
04:40:38 <nand`> !hayoo in duckduckgo, very useful :)
04:40:43 <unnali> where's `hing'?
04:41:29 <Franciman> hi all
04:41:41 <mekeor> hi
04:41:50 <Franciman> hey guys I want to download the new haskell platform for archlinux but
04:41:50 <Franciman> http://www.archlinux.org/packages/extra/i686/haskell-platform/
04:41:57 <Franciman> gives me 404
04:42:13 <mm_freak> Franciman: on arch linux you would normally just install the packages you need
04:42:35 <Franciman> explain me, I'm new to it :P
04:42:41 <mm_freak> pacman -S ghc cabal-install
04:43:02 <mm_freak> then install the rest through cabal in your regular user account
04:43:03 <mcstar> ooops wrong window
04:43:07 <Nimatek> Franciman: "pacman -Qs haskell" to get a list of haskell related packages in the main repos.
04:43:18 <Franciman> oh great
04:43:19 <mm_freak> Nimatek: -Ss, not -Qs
04:43:19 <Nimatek> err
04:43:20 <unnali> mcstar: uh…?
04:43:22 <Franciman> thanks a lot
04:43:23 <Nimatek> -Ss yes
04:43:25 <Nimatek> Sorry.
04:43:32 <Franciman> yes yes, don't worry :)
04:43:51 <barrucadu> Franciman: IIRC, there's a haskell-platform package in the AUR
04:43:53 <b_jonas> lol "where is `hing'?"
04:43:55 <mm_freak> Franciman: ghc and cabal-install are sufficient for most things…  some packages may fail to install complaining that happy and/or alex don't exist
04:43:56 <b_jonas> I like that
04:44:03 <mm_freak> in that case:  pacman -S happy alex
04:44:11 <mm_freak> (funny name)
04:44:14 <Franciman> yeah of course
04:44:17 <Franciman> lol
04:45:28 <mm_freak> Franciman: haskell-platform is essentially just that with some additional haskell packages, but when you install something through cabal-install those packages get fetched as dependencies, which is often less problematic than installing as global arch packages
04:45:46 <Franciman> yeah got it
04:46:41 <hpc> plus you have an easier time staying up to date
04:47:30 <Franciman> that's right
04:47:43 <Franciman> brb
04:48:33 <Catnaroek> Do all the monad functions in the MTL "autolift" when necessary?
04:48:50 <mauke> most of them
04:49:06 <hpc> the ones with constraints like "MonadState" do
04:49:17 <hpc> (or other "MonadFoo")
04:49:20 <Catnaroek> Oh.
04:49:23 <Catnaroek> Does throwError autolift as well?
04:49:39 <hpc> yes
04:49:42 <Catnaroek> Awesomeness!
04:49:59 <Catnaroek> I have just realized one thing.
04:50:07 <hpc> http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Error-Class.html#v:throwError -- the relevant instances for lifting things automatically are down here
04:50:23 <hpc> er, for lifting MonadError things
04:50:45 <Catnaroek> What would happen if there were only two "normal monad" types (an Id nonad and the IO monad), the rest being monad transformers?
04:50:54 <Catnaroek> Id monad*
04:51:07 <unnali> Catnaroek: doesn't mtl basically do just that?
04:51:25 <hpc> it does
04:51:34 <hpc> but you need more than just Id and IO
04:51:47 <Catnaroek> How so?
04:51:55 <hpc> you need ST, STM, probably more
04:52:01 <hpc> which don't have transformers
04:52:23 <unnali> hpc: i.e. anything else which can't be implemented in terms of haskell itself?
04:52:28 <Catnaroek> Oh. I should have said "Id and monads that do not have transformers".
04:52:34 <hpc> there's also a free monad somewhere for functors, i think?
04:52:49 <hpc> and afaik that can't be lifted because IO and such are functors
04:52:57 <hpc> er, can't be a transformer
04:53:15 <merijn> What's the easiest way to parse commandline args?
04:53:20 * hpc needs to wake up...
04:53:44 <hpc> merijn: System.Console.GetOpt
04:53:54 <hpc> merijn: you even already have it!
04:54:08 <mm_freak> merijn: the easiest way is the cmdargs package
04:54:16 <hpc> that works too
04:54:26 <mm_freak> just define a type and annotate it…  that's about the most concise way i know
04:54:33 <merijn> getOpt doesn't seem to qualify my current needs for simple
04:55:15 <merijn> I really just want "if the first argument is a number, use that. Otherwise use this default". but writing the code for that in haskell seems to be decidely trickier than I expected
04:55:38 <mauke> that's pretty simple
04:56:35 <mcstar> a simple pattern match will suffice, i.e. case
04:56:56 <mauke> args <- getArgs; let v = case map reads args of [(n, "")] : _ -> n; _ -> whatevs
04:57:08 <hpc> parse args = maybe default $ do
04:57:12 <unnali> whatevs, heh.
04:57:15 <hpc>   guard (not . null $ args)
04:57:18 <Eduard_Munteanu> :t reads
04:57:20 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:57:38 <hpc>   listToMaybe (reads (head args))
04:57:50 <mm_freak> hpc: that's unsafe
04:58:15 <mauke> looks safe to me
04:58:20 <mauke> and maybe a type error
04:58:20 <hpc> the guard keeps it safe
04:58:26 <hpc> it is a type error though
04:58:40 <mm_freak> where is the type error?
04:58:45 <hpc> :t maybe
04:58:46 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:58:54 <mm_freak> :t listToMaybe . reads . head
04:58:56 <lambdabot> forall a. (Read a) => [String] -> Maybe (a, String)
04:58:59 <mauke> ok, two type errors
04:59:06 <mauke> :t fromMaybe
04:59:08 <lambdabot> forall a. a -> Maybe a -> a
04:59:29 <unnali> do we have to call them errors? error sounds so harsh. what about `type blunder'?
04:59:48 <hpc> "type oopsie"
04:59:57 <hpc> that'd make a great easter egg in the next ghc
04:59:58 <Eduard_Munteanu> What's this, chess? :P
05:00:07 <hpc> with a check to see if the date is april fools
05:00:19 <mcstar> type-o
05:00:24 <Eduard_Munteanu> Heh.
05:00:25 <unnali> hpc: surely someone here has the political weight to make that happen :D
05:00:38 <hpc> i hope so :D
05:00:40 <mm_freak> become a GHC developer and submit a patch
05:00:43 <Catnaroek> Is there no Id monad? :O
05:00:46 <mauke> type booboo
05:00:49 <hpc> @hoogle Identity
05:00:50 <lambdabot> Control.Monad.Identity module Control.Monad.Identity
05:00:50 <lambdabot> Control.Monad.Trans.Identity module Control.Monad.Trans.Identity
05:00:50 <lambdabot> Data.Functor.Identity module Data.Functor.Identity
05:00:52 <unnali> Catnaroek: Data....
05:00:56 <unnali> above.
05:01:01 <Catnaroek> :O Nice.
05:01:31 <twx_haskell> let (a:_:_:_)="asdfggh" in a   I get 'a'  , so _:_:_ is what exactly
05:01:33 <mcstar> lets fork GHC and make it available for children under 4
05:01:38 <Eduard_Munteanu> Catnaroek: sure there is, that's how you usually get monads from monad transformers, e.g. ReaderT r Identity a   for   Reader r a
05:01:55 <mm_freak> twx_haskell: 's', 'd' and 'f' respectively
05:01:56 <hpc> twx_haskell: (a:(_:(_:_)))
05:01:58 <unnali> twx_haskell: (x:y:z) == [x,y] ++ z
05:02:01 <mm_freak> uhm
05:02:06 <mm_freak> twx_haskell: 's', 'd' and "fggh" respectively
05:02:14 <nand`> hmm
05:02:21 <hpc> > 'a':('s':('d':"fggh"))
05:02:22 <lambdabot>   "asdfggh"
05:02:24 <nand`> clearly, Identity is defined in terms of IdentityT :P
05:02:33 <k0ral> hi, I'm getting the following compilation error: "cabal: The program alex version >=3 is required but it could not be found." while I actually did install alex 3+ with cabal just before
05:02:35 <unnali> nand`: stop right there!
05:02:36 <hpc> > let (a:b:c:d) = "asdfggh" in (a,b,c,d)
05:02:37 <lambdabot>   ('a','s','d',"fggh")
05:02:38 <Catnaroek> Eduard_Munteanu: So "plain monads" that have transformers are just sugar for the transformer stacked on top of the Identity monad?
05:02:49 <Catnaroek> that have analog transformers*
05:02:57 <Eduard_Munteanu> Catnaroek: yeah
05:03:00 <mm_freak> k0ral: do you have the cabal's installation path in your PATH?
05:03:00 <Catnaroek> that have transformer analogs*
05:03:01 <Catnaroek> Whoa.
05:03:04 <Catnaroek> Awesome.
05:03:04 <hpc> Catnaroek: not quite "sugar", but yes
05:03:12 <nand`> newtype Identity a = IdentityT Identity a
05:03:14 <mm_freak> k0ral: by default cabal installs below ~/.cabal
05:03:14 <nand`> wait what
05:03:26 <hpc> they just have the right instances and a smart constructor
05:03:26 <unnali> nand`: krrrrrrhk
05:03:27 <mm_freak> so you'll find alex in ~/.cabal/bin
05:03:39 <mauke> preflex: remember <nand`> newtype Identity a = IdentityT Identity a
05:04:00 <k0ral> mm_freak: oh, I happened to broke my environment variables so my PATH was wrong :S
05:04:02 <nand`> that isn't even a valid newtype declaration is it?
05:04:12 * nand` doesn't use newtypes much
05:04:14 <unnali> nand`: Expecting one more argument to `Identity'
05:04:14 <k0ral> happen to have broken*
05:04:24 <Eduard_Munteanu> nand`: you don't have a constructor
05:04:43 <twx_haskell> o   year   thanks
05:05:15 <nand`> newtype Identity a = Identity { runIdentity :: IdentityT Identity a }
05:05:40 <twx_haskell> mm_freak:o yeah thanks
05:05:57 <mm_freak> twx_haskell: '_' is a nameless variable
05:06:30 <mm_freak> drop 0 xs = xs; drop n (_:xs) = drop (n - 1) xs
05:06:36 <twx_haskell> mm_freak:o   yes
05:06:56 <Catnaroek> Whoa, thanks to the Identity monad, now I do not have to worry about extremely long function definitions! I just put each logical transformation in its own line! :D:D:D:D
05:06:58 <unnali> nand`: apparently that's perfectly acceptable. wuh
05:07:35 <Eduard_Munteanu> Catnaroek: how do you mean?
05:08:00 <Eduard_Munteanu> Using the Identity monad for imperative-like programming?
05:08:06 <Catnaroek> I mean, if I have a function a -> z that can be decomposed into several steps
05:08:08 <Catnaroek> a -> b
05:08:10 <Catnaroek> b ->
05:08:12 <Catnaroek> c
05:08:12 <Catnaroek> etc
05:08:20 <Catnaroek> I just put each step in its own line
05:08:39 <Catnaroek> Eduard_Munteanu: pretty much lol
05:08:48 <mm_freak> Catnaroek: you can do that without identity much easier
05:08:57 <b_jonas> Catnaroek: have you heared about the let expression ?
05:09:12 <mm_freak> Catnaroek: there is 'let', 'case' and (.)
05:09:20 <Catnaroek> b_jonas: Yes, but I really hate let outside of monads.
05:09:30 <b_jonas> uh why?
05:09:34 <Catnaroek> No idea.
05:09:37 <Catnaroek> I just...
05:09:39 <Catnaroek> ... prefer where
05:09:40 <mm_freak> Catnaroek: if you hate 'let', you have 'where' =)
05:10:01 <Eduard_Munteanu> You can't rebind names multiple times with let though
05:10:25 <mm_freak> you wouldn't want to rebind a name in the same scope anyway
05:10:26 <unnali> nand`: you have blown my mind.
05:10:29 <Eduard_Munteanu> Or do stuff like  a <- increment a
05:10:37 <mm_freak> that's usually a sign of imperative (aka wrong) thinking
05:10:42 <Eduard_Munteanu> :)
05:11:11 <mcstar> one reason ocaml in unreadable is that they keep rebinding names in nested scopes
05:11:16 <unnali> nand`: z :: Identity Int
05:11:22 <mm_freak> in fact thinking in "steps" is usually already imperative (aka wrong) thinking =)
05:11:25 <unnali> nand`: z = runIdentityT . runIdentity $ z
05:11:28 <unnali> it typechecks!
05:12:31 <nand`> “imperative (aka wrong)” <- are you sure there aren't situations in which imperative thinking can be advantageous?
05:13:19 <srhb> So.. When is Applicative clever?
05:13:20 <Eduard_Munteanu> unnali: how do you plan on extracting the value?
05:13:43 <alang> Is there currently a good workaround for this? http://trac.haskell.org/ThreadScope/ticket/6
05:14:21 <mm_freak> nand`: certainly, but not when you're (seriously) programming haskell for less than two months =)
05:14:55 <nand`> oh, agreed
05:14:56 <unnali> Eduard_Munteanu: I don't, apparently. :)
05:15:10 <nand`> if you're still learning haskell imperative thinking is bad :P
05:15:18 <mcstar> the fact that haskell's let is recursive by default makes it easier to read
05:15:25 * nand` will just leave this here: https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs
05:15:27 <b_jonas> but naming intermediate values with a let is not imperative thinking
05:15:30 <unnali> Eduard_Munteanu: for a while I kept wondering how I ended up with the same value again, and realised I was doomed to walk the corridors of the IdentityT Identity forever.
05:15:41 <nand`> b_jonas: but a <- successor a -- is
05:15:43 <Eduard_Munteanu> unnali: yep :)
05:15:44 <daniel_-> is there any recommended operator syntax practices for different types as there is with using `m` with a monad (e.g. Monad m)
05:15:58 <daniel_-> i mean with creating your own operators
05:16:03 <b_jonas> nand`: sure -- wait, do you mean the same a on both sides?
05:16:20 <Eduard_Munteanu> daniel_-: stuff like f for Functor, w for Comonad etc. seem common
05:16:23 <nand`> b_jonas: yeah, for example inside an Identity do block
05:16:39 <nand`> > runIdentity $ do { a <- return 3; a <- succ a; return a }
05:16:40 <lambdabot>   No instances for (GHC.Enum.Enum (Data.Functor.Identity.Identity a),
05:16:40 <lambdabot>        ...
05:16:43 <nand`> D:
05:17:09 <b_jonas> nand`: yes, that doesn't sound good
05:17:30 <nand`> oh
05:17:43 <unnali> nand`: fmap succ (return a) -- so ugly, how do you improve that?
05:17:43 <daniel_-> Eduard_Munteanu i mean more like creating |+| for adding two Vectors etc
05:17:58 <nand`> > runIdentity $ do { let a = 3; let a = succ a; return a }
05:17:59 <lambdabot>   <no location info>: parse error on input `}'
05:18:04 <unnali> > runIdentity $ do { a <- return 3; a <- fmap succ (return a); return a }
05:18:05 <lambdabot>   4
05:18:11 <felix__> unnali: return $ succ a ?
05:18:31 <unnali> felix__: uh, good point.
05:18:32 <unnali> i'm tired.
05:18:46 <felix__> :)
05:19:55 <nand`> now we just need sugar for “a <- return (b)”
05:20:41 <unnali> -_-
05:20:59 <nand`> a <= b
05:21:01 <nand`> :P
05:21:03 <nand`> no, wait
05:21:05 <nand`> a := b
05:21:33 <unnali> wait, is there any serious way that can differ from "let a = b" ?
05:21:39 <nand`> unnali: yes, if a is free in b
05:21:44 <Eduard_Munteanu> a <- $$ b   (if only we could define that as an operator $$_ = return)
05:21:49 <nand`> let a = a -- is recursive; a <- return a -- is not
05:22:06 <unnali> nand`: good point!
05:22:27 <nand`> I suppose ImperativeHaskell will have to make do instead of the Identity monad for now
05:22:35 <Eduard_Munteanu> unnali: a <- return b   ~   return b >>= \a -> ...
05:23:14 <hanDerPeder> is there a version of fold that keeps all its intermediate values?
05:23:16 <unnali> Eduard_Munteanu: I was more wondering if there was a monad law or something that should ensure some identity properties between b and a in that case, but I guess not.
05:23:21 <felix__> hanDerPeder: scanr ?
05:23:22 <unnali> hanDerPeder: scan!
05:23:26 <felix__> or scanl
05:23:29 <nand`> unnali: oh, also if the Monad instance is bugged
05:23:33 <hanDerPeder> thanks guys!
05:23:49 <Eduard_Munteanu> unnali: that was just how do syntax desugars
05:24:15 <unnali> nand`: by `bugged' you mean not obeying the laws? or just doing something non-obvious in bind?
05:24:17 <nand`> return b >>= c  =  c b  -- as per monad laws iirc
05:24:32 <unnali> that's kind of what I was thinking about, yeah.
05:25:13 <nand`> so return b >>= \a -> c   = (\a -> c) b which should be the same as let a = b in c
05:25:15 <Catnaroek> I have a StateT monad transformer stacked upon another (with some other monad transfomers in between). If I call "put" or "get", can Haskell use type inference to determine which state transformer to use when calling put/get?
05:25:21 <nand`> barring recursion
05:25:41 <nand`> (or free variables in general)
05:25:44 <unnali> right!
05:25:50 <unnali> and yeah, free variables are the killer here.
05:26:19 <unnali> Catnaroek: not afaik; you'll need to explicitly lift to get past one of them. type inference will at least let you know which one you got!
05:26:54 <Catnaroek> Dang.
05:27:05 <Catnaroek> This is sad.
05:27:23 <unnali> the accepted wisdom(?) is to put together helpers for your monad transformer stack.
05:27:53 <unnali> e.g. "putCounter :: Int -> MyStack (); putCounter = lift . put"
05:28:06 <unnali> "putOtherThing :: Thing -> MyStack (); putOtherThing = put"
05:28:36 <nand`> added benefit of being able to easily add another monad on top
05:28:38 <unnali> that way it's obvious in the using-code which one is going where, and if you re-organise your stack, you only need to change one set of puts/gets
05:28:44 <nand`> in case you really, really, really need to stack three of the same monad
05:29:13 <Catnaroek> Oh.
05:29:19 <unnali> I once wrote `lift . lift . lift . tell' ;/
05:29:29 <Catnaroek> @src tell
05:29:29 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
05:29:39 <unnali> @src Writer tell
05:29:40 <lambdabot> Source not found. Are you on drugs?
05:29:41 <nand`> lift2 = lift . lift -- (?)
05:29:42 <Eduard_Munteanu> If you have different monads, you might not need to lift.
05:29:43 <unnali> :|!
05:29:49 <Eduard_Munteanu> E.g. Reader over State.
05:30:01 <Eduard_Munteanu> See MonadReader and MonadState's instances.
05:30:03 <Catnaroek> I have State over Error over State.
05:30:05 <unnali> right! unless you're mixing non-mtl transformers.
05:30:05 <Eduard_Munteanu> They auto-lift.
05:30:10 <Catnaroek> Both States are not the same.
05:30:30 <fuchsto> dmwit: Exciting news: I installed ghc7.4 from source and downloaded/patched/built/installed the latest version of cabal-install with it, then built my app ... AND i don't get any segfaults any more!
05:30:54 <Eduard_Munteanu> Catnaroek: you should probably just use a single State and use records in there, or stuff like that.
05:31:01 <fuchsto> dmwit: So it looks like there is an issue when compiling gtk2hs or anything else in the dep chain with ghc7.2
05:31:02 <Franciman> hey if you have a custom Monad transformer, then to let the non-usage of lift should you create instances for all the monad typeclasses, right?
05:31:30 <Catnaroek> Eduard_Munteanu: That sounds almost as bad as declaring all the variables at the top of a procedure in an imperative program.
05:31:37 <Eduard_Munteanu> Franciman: I think you can derive MonadState etc. using some GHC extensions
05:31:57 <Catnaroek> Eduard_Munteanu: No, wait, what you suggested me is *exactly* the same.
05:32:04 <Franciman> otherwise that would become like suicide
05:32:04 <Franciman> :)
05:33:09 <Eduard_Munteanu> Catnaroek: and isn't using multiple States the same thing after all?
05:33:22 <Eduard_Munteanu> You still have a fixed number of states.
05:34:00 <Catnaroek> Eduard_Munteanu: Well, in this case, no. I am using the internal state in what would be an internal loop inside a procedure.
05:34:34 <Eduard_Munteanu> Then I guess you wouldn't have to lift.
05:34:45 <Catnaroek> Ah!
05:34:46 <Eduard_Munteanu> e.g. just run your State stuff and extract the value.
05:34:47 <Catnaroek> Sweet.
05:35:08 <Eduard_Munteanu> :t evalState
05:35:09 <lambdabot> forall s a. State s a -> s -> a
05:37:11 <merijn> @djinn [(a, Maybe b)] -> [Maybe (a, b)]
05:37:11 <lambdabot> Error: Undefined type []
05:37:22 <merijn> @djinn (a, Maybe b) -> Maybe (a, b)
05:37:23 <lambdabot> f (a, b) =
05:37:23 <lambdabot>     case b of
05:37:23 <lambdabot>     Nothing -> Nothing
05:37:23 <lambdabot>     Just c -> Just (a, c)
05:37:45 <nand`> Eduard_Munteanu: different states can be different when you want to encapsulate a stateful sub-computation type-safely
05:38:50 <mysticc> cabal install installs the package .. How to just generate the documents in ~/.cabal directory , where docs are automatically generated when I install a package ?
05:38:52 <nand`> for example, you have an over-arching State Something; and you want to produce a State Something statefully, for example StateT Context (State Something); instead of using State (Context, Something) you can now “evalState” the sub-computation and ensure its “Context” is locked away aftwerwards
05:39:11 <mysticc> when I run cabal haddock .. It generates the docs in the package directory ..
05:40:31 <Eduard_Munteanu> merijn: strength!
05:41:01 <Taneb> Is there a way to update the docs for base?
05:42:04 <merijn> Eduard_Munteanu: Huh?
05:42:26 <nand`> merijn: it's a function, I think I've seen it before but forgot where it was defined
05:42:43 <Eduard_Munteanu> merijn: (a, Maybe b) -> Maybe (a, b) is strength for the Maybe monad, see http://en.wikipedia.org/wiki/Strong_monad
05:42:53 <Eduard_Munteanu> :t traverse
05:42:54 <lambdabot> Not in scope: `traverse'
05:42:57 <Eduard_Munteanu> @hoogle traverse
05:42:58 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
05:42:58 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
05:42:58 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
05:43:04 <Eduard_Munteanu> Erm.
05:43:26 <Eduard_Munteanu> @hoogle sequence
05:43:27 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
05:43:27 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
05:43:27 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
05:43:30 <Eduard_Munteanu> Bah.
05:43:38 <Eduard_Munteanu> :t Data.Traversable.sequence
05:43:39 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
05:43:42 <Eduard_Munteanu> That.
05:44:01 <Eduard_Munteanu> with t = (,) a
05:44:16 <Eduard_Munteanu> (or erm, some 'b' anyway
05:44:25 <nand`> No instance for Data.Traversable.Traverse ((,) t0)
05:44:27 <nand`> is this defined anywhere?
05:44:41 <nand`> Traversable*
05:45:06 <Eduard_Munteanu> Hm, not sure, but   (,) a   should have some other instances.
05:45:13 <Eduard_Munteanu> e.g. Functor
05:46:23 <Eduard_Munteanu> And anyway, all Haskell monads are strong, that should work for (,) a and any monad.
05:46:24 <merijn> Eduard_Munteanu: Ah, once again I'm not knowledgeable enough :p
05:47:28 <Eduard_Munteanu> IIRC, it follows from Hask being a monoidally-closed category, but I'm not sure, maybe someone can confirm it.
05:48:04 <nand`> @djinn Applicative f => (x, f a) -> f (x , a)
05:48:05 <lambdabot> Error: Class not found: Applicative
05:48:08 <nand`> :(
05:49:59 <Eduard_Munteanu> @djinn (f (a -> b) -> f a -> f b) -> (a -> f a) -> (x, f a) -> f (x, a)
05:50:00 <lambdabot> -- f cannot be realized.
05:50:11 <Eduard_Munteanu> @djinn Functor f => (f (a -> b) -> f a -> f b) -> (a -> f a) -> (x, f a) -> f (x, a)
05:50:12 <lambdabot> Error: Class not found: Functor
05:50:14 <Taneb> :t \(a,b) -> (,) <$> pure a <*> b
05:50:16 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => (a, f a1) -> f (a, a1)
05:50:42 <Taneb> :t \(a,b) -> fmap (a,) b
05:50:43 <lambdabot> Illegal tuple section: use -XTupleSections
05:50:51 <Taneb> :t \(a,b) -> fmap ((,) a) b
05:50:53 <lambdabot> forall t a (f :: * -> *). (Functor f) => (t, f a) -> f (t, a)
05:51:51 <nand`> :t uncurry (fmap . (,))
05:51:53 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
05:54:34 <nand`> :t uncurry ((.).(,))
05:54:35 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
05:54:38 <nand`> perl mode
05:54:52 <Taneb> :t (.)
05:54:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:55:03 <Taneb> Unconventional
05:58:16 <srhb> Is it possible to run a Yesod web site on the same IP and port as different servers? I guess I want to somehow distinguish by domain, but I don't know what tool should be on the front end of this.
05:59:25 <donri> srhb: maybe some proxying with e.g. nginx?
05:59:48 <srhb> donri: That sounds like what I need, thanks. :)
06:14:44 <nand`> what would be the most idiomatic way to implement dropFromEnd :: Int -> [a] -> [a] ? \n -> reverse . drop n . reverse ?
06:15:10 <Taneb> I'd say to use Data.Sequence
06:16:04 <nand`> say I had to use [], would the round-trip to Data.Sequence and back to [] be more efficient than reverse . reverse?
06:16:07 <Paprikachu> http://www.youtube.com/watch?feature=player_embedded&v=TROd29XFHY0
06:16:09 <Paprikachu> \o/
06:16:27 <Taneb> Probably not
06:16:48 <zomg> Paprikachu: they should just bring ballmer to do the developers dance
06:16:52 <nand`> hmm, seems like they should be the same
06:16:57 <Paprikachu> true story :D
06:23:07 <Cheery> what was the famous quote about every language having lisp inside?
06:23:37 <Taneb> "Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp".
06:23:45 <Taneb> (Greenspun's 10th rule)
06:24:22 <Cheery> how does it manifest in them?
06:25:17 <Cheery> I've seen hash tables, but those are popularized by python, not CLISP
06:25:27 <Taneb> Because Lisp is such a simple language (it's essentially an abstract syntax tree), and in Lisp it's easy to make DSLs
06:26:09 <Taneb> So it's supposedly easier to make an ad hoc, informally-specified, bug-ridden, slow implementation of half of common lisp and use that rather than just using a DSL straight-off
06:26:20 <irene-knapp1> yes, haha
06:26:23 <irene-knapp1> that is the theory
06:26:29 <bitonic> Taneb: CL is not simple at all
06:26:41 <bitonic> well. it's not "little"
06:26:43 <irene-knapp> yeah, but half of it is
06:26:52 <nand`> irene-knapp: heh
06:26:53 <Taneb> It is for the inside of compilers
06:26:56 <Cheery> ^^
06:27:02 <bitonic> so I think that the point in that joke is that you are going to reimplement the CL environment
06:27:20 <bitonic> which is very comprehensive
06:27:24 <Yuras> hi, I have an issue with acid-state. Is there anybody familiar with it?
06:27:25 <mauke> that just means CL is an overcomplicated, bloated, all-encompassing mess
06:27:34 <donri> Yuras: sure
06:27:37 <bitonic> Yuras: ask, don't ask to ask :)
06:27:53 <Cheery> http://www.raspberrypi.org/phpBB3/viewtopic.php?f=31&t=8155
06:27:57 <Itkovian> does the term 'futures' ring a bell to anybody? the way they're explaining  it here is like it's a thunk, allowing laziness
06:28:02 <Yuras> Data.Acid.Update has MonadState instance: http://hackage.haskell.org/packages/archive/acid-state/0.6.4/doc/html/Data-Acid.html#t%3aUpdate
06:28:13 <Cheery> looks like my structural editor went lisp.
06:28:24 <Cheery> but no, there's more.
06:28:27 <Taneb> Itkovian, like futures trading?
06:28:29 <Yuras> but when I try to load use it, compiler can't find the instance
06:28:42 <Itkovian> no, like futures in ParalleX
06:28:46 <donri> Yuras: "load use it"?
06:28:55 <Itkovian> (parallel computation runtime thingie)
06:29:02 <Cheery> the way I make the interpreter seems to tell ideas on how to implement the editor
06:29:02 <Yuras> No instance for (MonadState HelloWorldState (Update HelloWorldState))
06:29:12 <Yuras> sorry, load in ghci or use in code
06:29:23 <donri> Yuras: show code please
06:29:23 <donri> @hpaste
06:29:24 <lambdabot> Haskell pastebin: http://hpaste.org/
06:30:05 <Yuras> http://mirror.seize.it/acid-state/examples/HelloWorld.hs
06:30:11 <nand`> is anybody else annoyed by the fact that hpaste doesn't infer Author/Title as “Anonymous”/“Untitled”?
06:30:16 <irene-knapp> no
06:30:17 <irene-knapp> I like that
06:30:21 <irene-knapp> it forces you to enter something
06:30:32 <Taneb> I keep getting author and title backwards
06:30:35 <irene-knapp> even if it's just "La la la" for the title, it's useful to distinguish from the 50 other "untitled" things
06:30:41 <irene-knapp> ah, well, there's that
06:30:46 <Taneb> There's a bunch of pastes in the site called Taneb
06:30:50 <irene-knapp> it should have placeholder values but not let you actually submit with them
06:31:04 <nand`> placeholder values would be silly imo
06:31:05 <donri> it should persist author in a cookie ;)
06:31:12 <irene-knapp> that, also
06:31:13 <nand`> there's a big “Title:” “Author:” right next to it
06:31:21 <irene-knapp> nand: well, maybe so
06:31:26 <donri> Yuras: you're loading that exact file in a clean ghci with :load?
06:32:00 <Yuras> actually I expect ghci to show MonadState instance when I type ":i Update" in ghci, but it doesn't
06:32:32 <Yuras> ghci HelloWorld.hs
06:32:33 <Cheery> it's odd... but I feel I can leave the python alone very very soon.
06:32:41 <Itkovian> ah, several slides later, the word lazy turns up
06:32:45 <ski> Itkovian : i think Alice ML has futures
06:32:49 <Cheery> at least reduce the editor part of python into a renderer and keycode retriever
06:32:52 <Itkovian> thx ski
06:33:11 <Cheery> rest of it will be something that resembles lisp, and can be edited by the editor itself.
06:33:20 <Yuras> I can't actually load HelloWorld.hs, cos if error "No instance for (MonadState HelloWorldState (Update HelloWorldState))"
06:34:07 <morel> can you give me a link to a paper which defines a context-free grammar?
06:34:18 <Laguana> a specific one, or what one is?
06:34:24 <Yuras> and when I ":m + Data.Acid", ":m + Control.Monad.State", ":i Update", it doesn't list MonadState instance :(
06:35:01 <donri> Yuras: duno, works for me?
06:35:18 <Yuras> really? I'm using ghc-7.4.2
06:35:37 <Yuras> and acid-state 0.6.4
06:35:43 <Franciman> hey, I can't install haskell-src-exts, it tells me it needs happy >= 1.17, but I have it and its version is 1.18
06:36:03 <donri> me too except ghc 7.4.1
06:36:47 <davesq> n00b q: how can i putStrLn each string in an IO [String]? (f :: IO [String] -> IO () )
06:37:00 <hpc> Franciman: are you installing it directly, or as a dependency for something else?
06:37:16 <Yuras> damn, a but in ghc-7.4.2?
06:37:16 <hpaste_> Franciman pasted “haskell-src-exts” at http://hpaste.org/70071
06:37:22 <donri> doubtful
06:37:29 <Franciman> that is the output
06:37:44 <Veinor> @pl do {x <- strs; mapM putStrLn x}
06:37:45 <Franciman> hpc, as a dependency for hlint
06:37:45 <lambdabot> (line 1, column 4):
06:37:45 <lambdabot> unexpected "{"
06:37:45 <lambdabot> expecting variable, "(", operator or end of input
06:37:49 <adnauseam> what's [1..] sugar for?
06:37:50 <Veinor> @undo do {x <- strs; mapM putStrLn x}
06:37:51 <lambdabot> strs >>= \ x -> mapM putStrLn x
06:38:07 <mcstar> enumFrom*
06:38:18 <Veinor> davesq: you can do something like do { x <- strs; mapM putStrLn x }
06:38:32 <donri> Yuras: the instance is defined with newtype deriving, i can't see how that could possibly fail o_O
06:38:32 <hpc> Franciman: something later in the install process must want older happy
06:38:32 <adnauseam> hmm
06:38:40 <adnauseam> *q lambdabot
06:38:42 <hpc> but haskell-src-exts gets installed first and triggers the "oh-crap"
06:38:43 <adnauseam> err, sorry
06:38:44 <donri> Lemmih: got time for Yuras?
06:39:02 <Franciman> hpc, so whattodo?
06:39:18 <hpc> add verbosity probably
06:39:56 <morel> what does "::=" mean in some papers?
06:40:37 <Yuras> are instances listed in .hi files?
06:40:37 <hpaste_> Franciman pasted “output-verbose” at http://hpaste.org/70072
06:40:46 <Franciman> hpc that's the output now
06:41:04 <daniel_-> is there any pyvideo.org equivalent for haskell, or is the small amount of videos on youtube all there is? :]
06:41:28 <theadmin> Are there functions which are normally called "split" or "join" in other languages? Split a String into [String] by specific separator or join them back a similar way -- like "words" and "unwords" or "lines" and "unlines", but with the separator specified manually
06:42:06 <mcstar> i'd rather not learn haskell from videos
06:42:17 <hpc> oh, i was reading that (>=) the wrong way
06:42:23 <Itkovian> morel: example?
06:42:24 <hpc> uh, i have no clue
06:42:29 <davesq> Veinor: thanks. i had a mental blank on mapM :)
06:42:41 <Veinor> > intercalate ", " ["foo", "bar", "baz"]
06:42:42 <lambdabot>   "foo, bar, baz"
06:42:48 <Veinor> theadmin: ^^^
06:42:51 <daniel_-> no i'm reading through learnyouahaskell (completed with that) and im halfway through realworld haskell, but pyvideo.org is not about learning python but more talks about interesting topics
06:42:58 <theadmin> Veinor: Hm, that works, what's the opposite though?
06:43:31 <Veinor> http://hackage.haskell.org/packages/archive/split/0.1.4.3/doc/html/Data-List-Split.html something from here, depending on what you need
06:43:43 <daniel_-> or rather collected videos from all python conferences
06:43:47 <yitz> daniel_-: there are actually quite a few, but they're scattered around.
06:43:58 <mcstar> daniel_-: idk, there are scattered videos on various hosting sites
06:44:00 <theadmin> Veinor: Thanks! Also, interpserse works nicely (just found that)
06:44:19 <Veinor> ah yeah, intersperse works too if you've only got a single character
06:44:31 <Veinor> http://www.haskell.org/hoogle/ this is useful for finding functions
06:45:30 <theadmin> Veinor: Indeed.
06:46:48 <mcstar> btw, is there an official badge for people who convert others to haskell?
06:47:34 <srhb> λ
06:47:37 <zomg> The Haskell Jesus badge?
06:47:42 <llano> Anyone want to try and help a rookie with some basic type conversion?
06:48:04 <mcstar> zomg: lol
06:48:22 <Cheery> mcstar: Pagan -> Haskeller ?
06:48:34 <Taneb> Is it possible to have infix types?
06:48:47 <Taneb> Like type a || b = Either a b
06:48:51 <srhb> llano: Ask :)
06:50:08 <bitonic> Taneb: yes, but you have to put a colon
06:50:15 <bitonic> Taneb: and enable TypeOperators
06:50:15 <Taneb> Okay
06:50:25 <bitonic> type a :|| b = Either a b will work
06:50:38 <Taneb> Thanks
06:52:01 <mcstar> like Complex
06:52:04 <mcstar> :+
06:52:15 <ski> @src Ratio
06:52:15 <lambdabot> data (Integral a) => Ratio a = !a :% !a
06:52:32 <ski> theadmin : .. did you check out that monad link yet ?
06:53:43 <theadmin> ski: Why yes, quite a while ago
06:53:48 <theadmin> ski: Thanks for that
06:54:06 <ski> it helped ?
06:54:14 <ion> Which link?
06:54:55 <theadmin> ski: Did indeed
06:54:55 <ski> "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>
06:55:17 <theadmin> By the way, is it true that there's a new upcoming standard (Haskell 2012)?
06:56:43 <srhb> theadmin: There's always a new upcoming standard. :)
06:56:52 <theadmin> srhb: :) That's good! lol
06:56:53 <morel> Itkovian: i am looking for an example :P  i read a couple of papers which used ::= – i think for defining grammers (of programming languages) or so…
06:56:59 <srhb> Whether there's a 2012, I don't know. I don't think so.
06:57:18 <srhb> I suppose it depends if there's enough in haskell'
06:57:32 <Yuras> dorni: I unpacked acid-state and loaded Data.Acid: "ghci -i../dist/build/autogen/ -i../src-unix Data/Acid.hs". and I see MonadState instance: "instance MonadState st (Update st)   -- Defined at Data/Acid/Common.hs:35:31"
06:57:54 <Yuras> but it magically disappears when installing the library
06:58:22 <donri> yea i don't get it at first either but i do if i load that hello world program
07:00:02 <Yuras> donri: did you get it when import Control.Monad.State?
07:00:11 <Yuras> from ghci I mean
07:01:23 <Yuras> does anybody have ghc-7.4.2 to test acid-state?
07:01:27 <donri> yea that works too
07:15:25 <adnauseam> does zip [1..] "ab" reduce to zip ([1] ++ [2..]) "ab" ?
07:15:59 <adnauseam> (take 1 $ iterate (+1) 1) ++ [2..] ?
07:17:14 <bitonic> adnauseam: the .. are implemented with the methods in Enum
07:17:33 <bitonic> so [1..] is `enumFrom 1'
07:17:56 <bitonic> (in fact, you can use whatever type implementing Enum with the .. notation)
07:18:01 <adnauseam> aye enumFrom is i think what iterate is
07:18:58 <adnauseam> bitonic: i'll look at the implementation dude, thanks
07:19:02 <bitonic> adnauseam: well for Int, `enumFrom = iterate (+1)'
07:19:10 <bitonic> @src Enum Int
07:19:10 <lambdabot> Source not found. Just try something else.
07:19:17 * hackagebot persistent-mysql 0.9.0.3 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-0.9.0.3 (FelipeLessa)
07:19:20 <bitonic> @src Int Enum
07:19:20 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:19:28 <bitonic> @src Int enumFrom
07:19:28 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:19:32 <adnauseam> i think it downloads it if you askfor it, but it takes time
07:19:35 <bitonic> @src enumFrom Int
07:19:36 <lambdabot> Source not found. Do you think like you type?
07:19:38 <bitonic> ok.
07:19:42 <adnauseam> i've had the same happen to me on my lambdabot
07:19:45 <Taneb> @src Int Enum
07:19:45 <lambdabot> Source not found. Take a stress pill and think things over.
07:19:49 <adnauseam> i'll brb
07:20:23 <WhoSayIn> hello guys
07:20:29 <srhb> WhoSayIn: Hi
07:20:32 <ski> adnauseam : `[1 ..]' reduces to `1 : [2 ..]'
07:20:44 <WhoSayIn> I want to ask some questions about functional programming
07:20:49 <bitonic> WhoSayIn: go ahead
07:20:50 <srhb> WhoSayIn: Go for it.
07:21:40 <WhoSayIn> I'm a computer science student and I want to learn functional programming
07:21:40 <WhoSayIn> but I really dont know where to start
07:21:40 <WhoSayIn> First I wanted to learn scheme
07:21:40 <WhoSayIn> by reading SICP
07:21:40 <WhoSayIn> but it was really tough for me
07:21:46 <WhoSayIn> I had some difficult times reading it
07:21:56 <srhb> WhoSayIn: Check out "Learn you a Haskell"
07:22:06 <srhb> WhoSayIn: It's very accessible.
07:22:07 <yitz> @where lyah
07:22:08 <lambdabot> http://www.learnyouahaskell.com/
07:22:20 <WhoSayIn> btw, I dont know what language to decide
07:22:24 <nand`> Haskell has damaged my brain: Just look at the kind of imperative code I'm producing: https://paste.lugons.org/show/ZEWJ53rOfMCw8XXuJF2E/ :(
07:22:29 <nand`> I just wish I could pattern match
07:22:32 <bitonic> WhoSayIn: haskell.
07:22:47 <ski> WhoSayIn : you might also try HTDP ("How To Design Programs") for Scheme
07:22:49 <srhb> WhoSayIn: Everyone in here will say Haskell. ;)
07:22:55 <WhoSayIn> i've checked out common lisp, scheme already
07:23:15 <yitz> @faq can haskell help WhoSayIn to learn functional programming?
07:23:16 <lambdabot> The answer is: Yes! Haskell can do that.
07:23:23 <nand`> WhoSayIn: maybe it's best to start with a very simple language; say something that has only two possible values: call them S and K
07:23:23 <bitonic> WhoSayIn: Scheme and CL are nice, but Haskell is very different. I prefer the Haskell way :)
07:23:25 * nand` is joking
07:23:34 <yitz> nand` !!
07:23:47 <WhoSayIn> thats why im here, if haskell is the right choice for me, i need to believe it
07:23:56 <srhb> WhoSayIn: You won't know until you try it.
07:24:00 <bitonic> WhoSayIn: ehe. read LYAH
07:24:04 <bitonic> @where LYAH
07:24:04 <lambdabot> http://www.learnyouahaskell.com/
07:24:11 <ski> nand` : what's bad about it ?
07:24:12 <NSNO> LYAH is really accessible.
07:24:14 <WhoSayIn> but at the end of summer, I really want to learn a functional programming language
07:24:25 <srhb> WhoSayIn: Well, just.. Do it. :D
07:24:37 <siracusa> @where tryhaskell
07:24:37 <lambdabot> http://tryhaskell.org/
07:24:43 <WhoSayIn> so, at tha haskell channel, you say haskell
07:24:45 <ski> WhoSayIn : you might find HTDP easier going than SICP -- but Haskell is nice too :)
07:25:05 <theadmin> WhoSayIn: Haskell Tutorial for C Programmers is also nice if you're migrating from the imperative land. I say take that first, then LYAH, then RWH, finally, "Write yourself a Scheme in Haskell in 48 hours", and by then you should be good :P
07:25:07 <nand`> ski: I'm doing recursive string processing like I would in Haskell, even though python strings are immutable (or so I've been led to believe)
07:25:25 <ski> nand` : Haskell strings are also immutable
07:25:27 <NSNO> WhoSayIn: I was in the same position as you a couple of weeks ago, chose Haskell in the end.
07:25:47 <srhb> WhoSayIn: Everyone language-centric channel will recommend their personal flavor. You can't get anywhere by asking that question. :) The only thing you can do is figure out the differences (mostly by trying) and deciding what you like best.
07:25:55 <NSNO> not least because my university is a haskell shop..
07:25:59 <WhoSayIn> @NSNO why did you choose haskell?
07:25:59 <lambdabot> Unknown command, try @list
07:26:02 <ski> WhoSayIn : in any case, you'll probably want to learn both Scheme and Haskell -- so it's just a question of which you start with
07:26:08 <bitonic> WhoSayIn: no need for the @
07:26:26 <nand`> ski: hmm, well for example tail is O(1). is that also the case with python's [:1] section?
07:26:28 <nand`> err [1:]
07:26:38 <ski> (or if not Scheme, then another lisp, like Common Lisp -- but Scheme is nicer, imo)
07:26:49 <NSNO> WhoSayIn: For the great documentation, community and syntax initially. Have come to love its purity and power since.
07:26:54 <ski> nand` : hm, dunno, but i suspect the answer is no
07:27:03 <bitonic> nand`: well in python you have to copy the tail, but that has little to do with mutability
07:27:15 <srhb> WhoSayIn: Most other FP "give up" on being pure when it comes to IO. Haskell does not. This sold me.
07:27:19 <bitonic> nand`: (and I'm sure you know that everything in haskell is immutable anyway)
07:27:27 <nand`> yeah good point; I shouldn't have used “mutable”
07:27:46 <nand`> it seems programming Haskell has made me forget what “mutable” means
07:27:49 <NSNO> also, there seems to be a real concerted effort to 'build' things with Haskell in recent times
07:28:05 <srhb> WhoSayIn: Perhaps you should try and google things like "Haskell vs Scheme" to see the differences, perhaps you have opinions on some of the points.
07:28:06 <ski> srhb : yeah, there's Clean as well (and Mercury, which is a hybrid LPL/FPL)
07:28:10 <bitonic> nand`: maybe you're talking about python strings not being lists of chars like Haskell String
07:28:15 <srhb> ski: Didn't know those :)
07:28:29 <bitonic> srhb: that's probably going to be useless (Scheme vs. Haskell webpages)
07:28:33 <nand`> bitonic: I figured they are, since I can use len() on strings, and section them with what appears to be list sectioning tools
07:28:35 <WhoSayIn> but you know, there are other options, as well, like clojure
07:28:37 <ski> srhb : check them out ? ;)
07:28:39 <WhoSayIn> what about clojure?
07:28:45 <srhb> ski: Will do.
07:28:53 <nand`> but I'll stop talking about python before I embarrass myself further, I don't know the language whatsoever :P
07:28:57 <bitonic> nand`: you figured they are what?
07:29:03 <nand`> bitonic: lists of chars
07:29:16 <bitonic> nand`: I don't think they are
07:29:19 <NSNO> WhoSayIn: sample code made me cry. but that's me coming from python/ruby
07:29:28 <srhb> WhoSayIn: I think a program here is explaining the differences if you've done no FP at all. You should learn one (any one!) and then you can start judging by the knowledge you've gained.
07:29:29 <nand`> I'm not too sure. Nothing in python really makes sense
07:29:32 <ski> srhb : there's a #mercury channel here (pretty small, but exists) -- afaiu, most Clean action is on mailing lists (and maybe usenet ?)
07:29:35 <srhb> er, problem, not program
07:29:36 <WhoSayIn> I'm also coming from Python
07:29:43 <bitonic> nand`: that's not true, Python is cute
07:29:51 <bitonic> anyway. enough of Python
07:30:04 <nand`> bitonic: cute things can be incomprehensible, I'm sure some females apply
07:30:18 <NSNO> nand`: :P
07:30:27 <bitonic> nand`: and still some of us like them!
07:31:46 <nand`> that reminds me of something. WhoSayIn: http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
07:31:49 <srhb> ski: The Mercury syntax seems a bit annoying at first glance.
07:32:04 <WhoSayIn> :)
07:32:15 <ski> srhb : it's mostly borrowed from Prolog (which is another language one should know about)
07:32:22 <srhb> ski: Yes, I recognize that.
07:32:33 <srhb> ski: Prolog also has annoying syntax.
07:32:34 <srhb> :-)
07:32:50 <ski> well, it's uniform
07:32:53 <srhb> Yes.
07:33:09 <ski> (maybe you'd prefer sexprs ?)
07:33:21 <bitonic> srhb: Erlang is even worse. It has the peculiar property of being impossible to get right at the first time
07:33:36 <bitonic> still, you get used to everything
07:33:36 <srhb> bitonic: That's not peculiar, I've seen many languages with that property. ;)
07:33:52 <srhb> ski: Clean looks more ML-like. Makes me happy.
07:34:03 <bitonic> srhb: no but *never* even 5 lines of code. the biggest problem is its comma rules
07:34:14 <srhb> bitonic: Haha. That sounds like awesome fun.
07:34:24 <bitonic> (maybe it's me eh).
07:34:27 <ski> srhb : Clean is basically what was left of lazy functional programming after Haskell gobbled up the other systems
07:34:46 <senmorta> comma, like Lisp?
07:35:05 <WhoSayIn> okay guys, thank you so much for your interests. I've just started to reading "Learn you a Haskell" and scheme will be the next
07:35:06 <ski> srhb : anyway, Clean and Mercury handles I/O and (mutable) state in very similar ways (though i understand they developed the ideas independently)
07:35:08 <bitonic> senmorta: no, very unlike lisp.
07:35:22 <bitonic> ski: linear types and all that right?
07:35:43 <ski> bitonic : comma rules ?
07:35:44 <srhb> WhoSayIn: Good luck, be sure to come back if you get stuck :-)
07:35:59 <srhb> ski: Can you summarize that model?
07:36:00 <WhoSayIn> I'm sure I will be back :)
07:36:00 <ski> bitonic : not *linear* types, but *uniqueness* types (or modes, in the case of Mercury)
07:36:05 <NSNO> WhoSayIn: Oh you will :P
07:36:15 <bitonic> ski: uhm, ok. I've looked at both only superficially.
07:36:26 <ski> srhb : "pass around the world" (or a mutable array)
07:36:35 * NSNO grumbles something about tabs/spaces
07:36:44 <srhb> ski: Ah.
07:37:10 <ski> srhb : the uniqueness typing/modes makes sure you never duplicate the world
07:38:05 <WhoSayIn> btw, what do you use for coding haskell?
07:38:12 <WhoSayIn> I'm a long time Vim user
07:38:15 <ski> bitonic : anyway, as long as you recall they botched up the use of `;' for multiple clauses in Erlang, the syntax is ok
07:38:45 <nand`> WhoSayIn: vim works well
07:38:53 <ski> WhoSayIn : some people use Vim, others use Emacs. there's also other editors like Leksah,Notepad++,&c.
07:38:59 <nand`> WhoSayIn: syntax highlighting came out of the box in mine and there's not much else you need. Remember to :set ExpandTabs
07:39:09 <nand`> because tabs are bad
07:39:12 <bitonic> ski: well, in `case', and `fun'. also, I don't like the sequencing commas to begin way.
07:39:30 <bitonic> ski: the fact that you exclude the last one makes code changes annoying
07:39:33 <ski> bitonic : well, the comma is conjunction
07:39:59 <WhoSayIn> okay, thanks, one of my friends, -who writes his own implementation of LISP- suggested me to use emacs bdly
07:40:04 <bitonic> ski: well in erlang it doesn't really mean that anymore...
07:40:14 <nand`> WhoSayIn: it doesn't really matter
07:40:32 <WhoSayIn> okay, thanks again
07:40:57 <bitonic> WhoSayIn: of course it matters. Learning to use emacs is a great asset.
07:40:57 <barrucadu> WhoSayIn: I use emacs, it works. Other people use vim, that works. Just go with what you prefer - no need to add the confusion of a new editor on top of a new language.
07:41:25 <bitonic> also, emacs is much better than the competition.
07:41:27 <WhoSayIn> barrucadu: good point :)
07:41:42 <shapr> bitonic: Is that what barrucadu said? ;-)
07:42:08 <bitonic> shapr: err, not exactly
07:42:22 <ski> bitonic : `foo(X) -> Y = bar(X),baz(X,Y).' in Erlang isn't that different from `foo(X) = Z :- Y = bar(X),Z = baz(X,Y).' in Mercury or `foo(X,Z) :- bar(X,Y),baz(X,Y,Z).' in Prolog
07:43:44 <bitonic> ski: no but I wouldn't call the comma a conjunction operator.
07:43:45 <Yuras> donri: in case you are interested: the issue was with two mtl version installed, hiding wrong version solved the issue. ty
07:43:53 <nand`> so how come “Num” doesn't have the Eq constraint but “Integral” still has it (among others)?
07:43:56 <bitonic> ski: (in erlang)
07:44:27 <bitonic> nand`: because members of Integrals are computable and should have Eq?
07:44:39 <bitonic> (I'd guess that)
07:44:42 <nand`> and members of Num aren't?
07:44:43 <MostAwesomeDude> ski: I am trying to remember whether this is the sameish: foo(X) :- baz(X, bar(X)).
07:44:47 <rwbarton> yeah
07:44:55 <rwbarton> after all you could test for equality by converting to Integer
07:44:59 <rwbarton> @type toInteger
07:45:00 <lambdabot> forall a. (Integral a) => a -> Integer
07:45:06 <nand`> yeah good point
07:45:24 <nand`> wait; does Integral have an Eq constraint or is there an Integral a => Eq a instance?
07:45:37 <rwbarton> surely not the latter
07:45:37 <nand`> because defining (==) as (==) `on` toInteger would make sense
07:46:18 <bitonic> nand`: in what case?
07:46:55 <bitonic> for some numbers - e.g. reals - it does not make much sense to have an == with the type sig that == has
07:47:54 <ski> bitonic : also, i think it's nice that you can do `case foo() of {yes,X} -> ok ; {no} -> X = bar() end,baz(X)' in Erlang -- defining a variable in each branch of a `case' and then use it afterwards
07:48:16 <shapr> luite: No, I haven't written the svg prototype yet, I got distracted by wife and Indiana Jones.
07:48:33 <nand`> bitonic: reals are not Integral
07:48:34 <ski> MostAwesomeDude : no, Prolog doesn't have functions; that doesn't work -- however in Mercury `foo(X) = baz(X,bar(X)).' would work
07:48:47 <bitonic> ski: sure. that is some good heritage from prolog. but those unification semantics bite often in other contexts
07:50:02 <bitonic> nand`: ok, but you can define Eq and Integral recursively anyway
07:50:32 <bitonic> nand`: and it makes good sense to have that Eq constraint there
07:52:20 <ski> > toInteger (2 :+ 3 :: Complex Integer)  -- gaussian integers ?
07:52:21 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Integer.Type.Integer)
07:52:21 <lambdabot>    arising f...
07:52:53 <ski> bitonic : yes, an explicit existential quantifier could be useful in Erlang
07:54:03 <ski> (MostAwesomeDude : one could also say `foo(X) = baz(X,Y) :- Y = bar(X).' ..)
07:54:26 <MostAwesomeDude> ski: Curious. I guess I'd need a real example.
07:56:14 <ski> (a real example of what ?)
08:06:36 <Palmik> Hi guys, I want to have type synonym type App = forall tag . Transport tag => SockMonad tag () and then have a synonym Env = (App, Something, ...) for that I need Rank2Types (or rank N) and ImpredicativeTypes. However, if I wrap App in newtype (instead of just using synonym), I need only Rank2Types. Is there a way to avoid impredicative types and the wrapping at the same time?
08:09:26 <Eduard_Munteanu> Palmik: use separate "arguments" for the environment? E.g. App -> Something -> ...   if that's part of a function's type.
08:11:44 <Palmik> Hmm, yes, that would work, however it's not (simply) applicable in my case (as I also have container of Envs)
08:11:52 <Eduard_Munteanu> Palmik: but really, perhaps you should use a   data Env = Env { app :: App, something :: Something }
08:12:45 <Eduard_Munteanu> Depends how you're using it, and which is the most convenient form.
08:13:28 <Eduard_Munteanu> But since you're using tuples, you might as well go for data / records.
08:13:29 <Palmik> Yes, taht should also do the trick, thanks Eduard_Munteanu. :)
08:13:40 <Palmik> s/taht/that
08:15:47 <Palmik> I was not quite sure for what reason I did need the impredicative types, this clears it up a bit. Apart from few haskell-cafe discussions I did not find much about it. :)
08:17:10 <amf> in "| otherwise = a `elem'` xs" (elem' is the function name) what do the back ticks mean?
08:17:47 <Palmik> They allow you to use the function in infix form.
08:18:24 <amf> Palmik: gotcha, thanks!
08:19:02 <Palmik> It works with an function, so if you have foo :: a -> b -> c, instead foo x y you can write x `foo` y. :)
08:25:33 <Eduard_Munteanu> Palmik: impredicative types let you add universal quantification within a type constructor's argument.
08:26:20 <Eduard_Munteanu> So   Maybe (forall a. a) is impredicative, while forall a. Maybe a is a normal rank-1 type (if not nested further)
08:26:42 <Eduard_Munteanu> (sure, (->) doesn't count as a type constructor for impredicativity)
08:28:34 <Veinor> what values inhabit Maybe (forall a. a)? just Nothing, i assume
08:30:35 <Eduard_Munteanu> Veinor: yeah
08:31:31 <srhb> Right.. I'm trying to manually build GTK+ with Quartz for use with haskell, but failing miserably. Does anyone know where to go with these questions? Is there an IRC channel?
08:31:43 <Saizan> Veinor: Just _|_ and _|_ too
08:31:52 <Veinor> well yes
08:32:05 * Eduard_Munteanu should go back to #agda :P
08:32:07 <Saizan> fully defined only Nothing
08:32:13 <donri> bottom, trolling haskell since '88
08:32:19 <ben> What values inhabit forall a. Maybe a? I'm not good at values.
08:32:25 <unlink> does bos hang around here?
08:32:39 <donri> preflex: xseen bos
08:32:39 <preflex>  bos was last seen on freenode/#haskell 26 days, 20 hours, 59 minutes and 22 seconds ago, saying: shachaf: thanks for letting me know
08:32:42 <Eduard_Munteanu> ben: still just Nothing
08:33:23 <Saizan> ben: still Nothing, Just _|_ and _|_
08:33:29 <haskellgirl> Now there's only love in the dark.
08:34:13 <Eduard_Munteanu> That wasn't meant as an interesting example of impredicative types though.
08:34:21 <haskellgirl> Neither have you.
08:35:46 <Eduard_Munteanu> The interesting part is e.g. when you can wrap fully-polymorphic values, or stuff like that.
08:36:29 <ben> I've seen people do ie. [Show a => a] or however you spell it
08:36:47 <donri> Show a => [a]
08:36:58 <Eduard_Munteanu> Mm, that's usually an existential.
08:37:07 <Eduard_Munteanu> If that's what you meant.
08:37:16 <ben> Probably.
08:37:16 <ben> Looked similar to me :V
08:37:22 <mcstar> a total eclipse of a heart...
08:37:26 <Eduard_Munteanu> It's quite different, actually.
08:38:38 <hpaste_> KSkrzet pasted “Stack overflow problem” at http://hpaste.org/70074
08:38:43 <Eduard_Munteanu> e.g. data Showable = forall a. (Show a) => S a; foo :: [Showable]     vs     bar :: [forall a. (Show a) => a]
08:39:20 <ben> well the latter sure looks neater...
08:39:24 <ski> the former is essentially `foo :: `[exists a. Show a *> a]'
08:39:25 <KSkrzet> I have a problem with parsing Google NGrams data from http://books.google.com/ngrams/datasets
08:39:26 <ben> but I guess this is my cue to step back and do some reading :)
08:39:50 <ski> the latter `bar :: [forall a. Show a => a]' is (in this case) basically useless
08:39:58 <Eduard_Munteanu> And simple rank-N types in  data ShowableRankN = SRN (forall a. (Show a) => a); baz :: [ShowableRankN]
08:40:11 <Eduard_Munteanu> (which are different again)
08:40:20 <ski> yeah, `baz' is akin to `bar' (not `foo') there
08:40:22 <KSkrzet> I want to take repeating ngrams for multiple years and add them together as in http://hpaste.org/70074 but for long runs of identical ngrams I get stack overflows... any ideas?
08:43:18 <mcstar> KSkrzet: did you turn on optimzation?
08:44:33 <KSkrzet> mcstar: cabal build optimizes by default, no? anyway I compiled with -O and result is identical
08:45:20 <mcstar> i encountered stack overflow sometimes and -O2 solved it
08:45:36 <mcstar> im not sure whether -O would have sufficed
08:45:45 <mcstar> as for the rest idk
08:45:52 <KSkrzet> mcstar: I tried -O2 too, didn't really help in this case
08:45:57 <mcstar> sry
08:47:25 <HairyDude> @hoogle Enum a => Int -> Maybe a
08:47:26 <lambdabot> Prelude toEnum :: Enum a => Int -> a
08:47:26 <lambdabot> Data.IntMap lookup :: Key -> IntMap a -> Maybe a
08:47:26 <lambdabot> Data.Graph.Inductive.Graph lab :: Graph gr => gr a b -> Node -> Maybe a
08:47:34 <HairyDude> hm.
08:49:44 <HairyDude> there are so many partial functions in Prelude, I wish they all had Maybe equivalents :(
08:51:03 <Veinor> safeify :: (a -> b) -> a -> Maybe b; safeify f x = unsafePerformIO $ (return $ f x) `catch` (const $ return Nothing)
08:51:05 <Veinor> 8)
08:51:17 <Eduard_Munteanu> spoon?
08:51:22 <rwbarton> there is no spoon
08:51:25 <Eduard_Munteanu> :D
08:51:53 <HairyDude> Veinor: tempting, but evil
08:52:16 <Eduard_Munteanu> HairyDude: there's a package on Hackage providing that.
08:52:41 <HairyDude> Eduard_Munteanu: what, safeify, or Maybe versions of partial Prelude functions ?
08:52:59 <Veinor> the latter
08:53:02 <HairyDude> @hoogle (a -> b) -> a -> Maybe b
08:53:03 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
08:53:03 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
08:53:03 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
08:53:03 <rwbarton> well, both
08:53:12 <Veinor> http://hackage.haskell.org/package/safe
08:53:15 <Eduard_Munteanu> The former.
08:53:19 <Eduard_Munteanu> @hackage spoon
08:53:19 <lambdabot> http://hackage.haskell.org/package/spoon
08:53:43 <HairyDude> oh, that's what you meant by spoon
08:54:04 <rwbarton> i don't think you are going to have much luck with a safe toEnum though
08:54:19 <rwbarton> unless you write a new type class for it
08:55:33 <rwbarton> or use Bounded too and cross your fingers
08:56:38 <HairyDude> safeToEnum :: (Enum a, Bounded a) => Int -> a; safeToEnum v | fromEnum minBound <= v && v <= fromEnum maxBound = Just $ toEnum v | otherwise = Nothing
08:56:57 <rwbarton> i guess any use of Enum already involves a certain amount of finger-crossing
09:00:45 <mcstar> only IO supports exceptions?
09:01:01 <HairyDude> @hoogle ErrorT
09:01:02 <lambdabot> Control.Monad.Error ErrorT :: m (Either e a) -> ErrorT e a
09:01:02 <lambdabot> Control.Monad.Trans.Error ErrorT :: m (Either e a) -> ErrorT e m a
09:01:03 <lambdabot> Control.Monad.Trans.Error newtype ErrorT e m a
09:01:07 <HairyDude> @hoogle MonadError
09:01:08 <lambdabot> Control.Monad.Error.Class class Monad m => MonadError e m | m -> e
09:01:08 <lambdabot> Control.Monad.Error class Monad m => MonadError e m | m -> e
09:03:38 <HairyDude> Veinor: Safe has no safe toEnum :(
09:04:02 <HairyDude> oh well, manual bounds checking it is
09:09:56 <mcstar> Noel calls 'bind' 'then'
09:10:19 <mcstar> afaic it makes more sense
09:10:23 <Eduard_Munteanu> mcstar: are you sure that isn't (>>)
09:10:24 <Eduard_Munteanu> ?
09:10:43 <mcstar> i think
09:11:06 <mcstar> yeah im sure
09:11:23 <mcstar> Here, the infix operator >>= is used instead of then,
09:11:28 <mcstar> he even says so himself
09:14:39 <grade1000> Where to find programs, games, movies 0day?
09:15:09 <mcstar> right here
09:21:06 <osfameron> programs in haskell, and games too
09:21:20 <osfameron> I guess you could write a plugin to lambdabot to animate haskell statemnts with ascii escape codes!
09:21:22 <nand`> movies about haskell
09:21:26 <nand`> where can I get those 0day?
09:21:47 <osfameron> there is some hot SPJ on Insurance Combinators action on the interwebs
09:22:13 <osfameron> though that's a bit racy. I want a Haskell romantic comedy
09:28:53 <hpaste_> tiram pasted “associated types” at http://hpaste.org/70075
09:29:15 <tiram> why do I get type error at: http://hpaste.org/70075 ?
09:29:41 <rwbarton> can you paste the error?
09:30:01 <rwbarton> actually never mind
09:30:08 <rwbarton> the reason is it has no way to know which instance to select
09:30:29 <tiram> how can I guide it then?
09:30:49 <rwbarton> probably simplest is "don't use type classes"
09:31:03 <rwbarton> if you want to use this type class, 'a' needs to be reachable from the type of f
09:31:54 <rwbarton> for example you can add an unused argument to f of type a
09:32:50 <tiram> aha got it
09:32:52 <tiram> tnx
09:33:03 <rwbarton> here the problem is it knows it needs f :: Bool -> Bool, but Input a = Bool doesn't mean a has to be Char
09:33:35 <Veinor> iirc a fundep will also solve this problem
09:34:27 <netogallo> does haskell allow type synonims for tuples. ie. type Vec2 = (Int,Int)
09:34:30 <netogallo> ?
09:34:34 <danr> yes...
09:34:46 <Veinor> rwbarton: wait, why doesn't the fact that it knows x is a Char allow it to infer?
09:35:07 <rwbarton> because there could be another instance Test () with Input () = Bool as well
09:35:55 <Veinor> right, but x == '0' forces x to be a Char
09:35:57 <Veinor> ... oh
09:36:02 <Veinor> right
09:36:04 <Veinor> :)
09:36:04 <rwbarton> this example type class is a bit silly since 'a' serves no role except to introduce ambiguity
09:36:45 <rwbarton> yeah, x is not related to a at all
09:37:40 <rwbarton> (why not just write class Test i where f :: i -> Bool)
09:39:54 <netogallo> thanks danr, just making sure that wasn't my error, it's solved btw
09:39:59 <danr> netogallo: np
09:46:27 <tiram> is it possible to have associated kinds?
09:50:29 <MagneticDuck> hey, I have a little problem... I'm not at peace with ().
09:50:44 <MagneticDuck> @type ()
09:50:45 <lambdabot> ()
09:50:52 <MagneticDuck> okay so that makes sense a little bit
09:50:59 <MagneticDuck> it's a dummy value
09:51:03 <MagneticDuck> > const 4 ()
09:51:05 <lambdabot>   4
09:51:53 <MagneticDuck> ...that's where I'm not all happy. I know it just represents a dummy value that doesn't get used, but it seems to have a few superpowers
09:52:01 <Veinor> like what?
09:52:12 <MagneticDuck> like it can represent any type
09:52:14 <Taneb> It's used when context matters but the actual value doesn't
09:52:16 <Veinor> no it can't
09:52:19 <Veinor> > 2 + ()
09:52:20 <lambdabot>   No instance for (GHC.Num.Num ())
09:52:20 <lambdabot>    arising from the literal `2' at <intera...
09:52:26 <MagneticDuck> that's because it's being USED
09:52:43 <Taneb> So, how can it represent something if it's not being used?
09:52:50 <Veinor> > const 4 undefined
09:52:51 <Taneb> I think you may be mixed up with undefined
09:52:52 <lambdabot>   4
09:53:10 <azaq23> MagneticDuck: open up a new file and do something like data W = W, and use W instead of () in every place you want to. no difference will ensue.
09:53:25 <MagneticDuck> > (let (fun x a = if x == 0 then a else 5) in (fun 5 ()))
09:53:27 <lambdabot>   <no location info>: parse error on input `='
09:53:34 <azaq23> except when dealing with functions which already use () of course
09:53:47 <Veinor> > let f x a = if x == 0 then a else 5 in f 5 ()
09:53:49 <lambdabot>   No instance for (GHC.Num.Num ())
09:53:49 <lambdabot>    arising from a use of `f' at <interacti...
09:53:58 <HairyDude> "The import of Data.Text is redundant" <- I get this when doing "import qualified Data.Text as T" and later do "T.pack"
09:53:59 <MagneticDuck> okay
09:54:09 <HairyDude> so the message is clearly wrong
09:54:17 <Veinor> HairyDude: hpaste your entire code?
09:54:27 <rwbarton> HairyDude, do you also have a second import of Data.Text somewhere?
09:54:27 <HairyDude> Veinor: I can hpaste a test case
09:54:28 <MagneticDuck> @type undefined
09:54:30 <lambdabot> forall a. a
09:54:35 * hackagebot cblrepo 0.6.2 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.6.2 (MagnusTherning)
09:55:37 <Veinor> here's an example: consider putStrLn
09:56:22 <Veinor> it has type putStrLn :: String -> IO something (IO because it evaluates to an IO action). but what should the something be?
09:56:43 <Veinor> it's not semantically meaningful since if putStrLn fails it'll throw an exception
09:56:52 <Veinor> so you might as well just come up with some datatype which only has one value and use that
09:56:53 <monochrom> I think no one understands the question. the allegedly superpower has not been reproduced by an independent party
09:56:56 <MagneticDuck> okay
09:57:06 <MagneticDuck> alright, I understand ()
09:57:15 <MagneticDuck> but now I'm mixed up about undefined
09:57:17 <ben> Why not a datatype that has no value?
09:57:21 <MagneticDuck> THAT has superpowers right?
09:57:28 <Taneb> :t let x = x in x
09:57:29 <lambdabot> forall t. t
09:57:31 <MagneticDuck> yeah, that's what azaq said
09:57:53 <ben> Or something like printf does, return how many characters it wrote~
09:57:57 <Veinor> undefined is 'special' in that way, yeah
09:58:28 <MagneticDuck> It's built into the language. And error?
09:58:31 <MagneticDuck> @type error
09:58:33 <lambdabot> forall a. [Char] -> a
09:58:38 <azaq23> undefined is a compiler feature for development, and yes you cannot yourself define it
09:58:46 <MagneticDuck> yeah
09:58:57 <MagneticDuck> but it's not used in any permanent situations, right?
09:59:02 <Taneb> undefined is pretty much a cheaty way to leave out bits of a program you haven't got to writing yet.
09:59:07 <MagneticDuck> okay
09:59:14 <rwbarton> you can essentially write it. undefined = let x = x in x
09:59:20 <nand`> undefined = undefined
09:59:27 <MagneticDuck> heh
09:59:33 <azaq23> oh true
09:59:34 <Taneb> > undefined
09:59:35 <lambdabot>   *Exception: Prelude.undefined
09:59:40 <Veinor> > let x = x in x
09:59:42 <nand`> but in base it's implemented in terms of error
09:59:44 <lambdabot>   mueval-core: Time limit exceeded
09:59:46 <MagneticDuck> okay
09:59:47 <nand`> for your own sanity
09:59:52 <MagneticDuck> error is the real black sheep
09:59:57 <Taneb> > error "Prelude.undefined"
09:59:59 <lambdabot>   *Exception: Prelude.undefined
10:00:00 <Veinor> error is implemented in terms of exceptions, apparently
10:00:00 <otters> :t let x = x in x
10:00:02 <azaq23> not sure if you could do "let x = x in x" without let though
10:00:02 <lambdabot> forall t. t
10:00:05 <otters> neat
10:00:09 <Veinor> azaq23: fix id
10:00:09 <nand`> Veinor: correct
10:00:17 <MagneticDuck> cool
10:00:29 <MagneticDuck> okay
10:00:35 <nand`> and exceptions are implemented in terms of a magical compiler primitive
10:00:42 <MagneticDuck> > 5 == undefined
10:00:43 <lambdabot>   *Exception: Prelude.undefined
10:00:55 <MagneticDuck> > putStrLn "hello"
10:00:55 <Eduard_Munteanu> azaq23: or if you want to say   f x y = undefined,   you can say   f x y = f x y  :)
10:00:56 <lambdabot>   <IO ()>
10:01:14 <rwbarton> it's not entirely unheard of to use undefined in "production"/finished code, but the instances where you'd use it are rare
10:01:23 <MagneticDuck> I don't like that idea
10:01:45 <nand`> usually you want to avoid writing partial functions
10:02:02 <rwbarton> just because you mention undefined doesn't mean you are writing a partial function
10:02:12 <rwbarton> that is my point
10:02:13 <MagneticDuck> today ima gonna start learning gtk2hs and glade
10:02:19 <MagneticDuck> this will be fun
10:02:19 <rwbarton> but, probably i shouldn't have mentioned it
10:02:28 <MagneticDuck> rwbarton: an example?
10:02:31 <nand`> rwbarton: example? sanity checking in case the implementation is supposed to be a total function but has a bug?
10:02:38 <Taneb> > const () undefined
10:02:39 <lambdabot>   ()
10:02:50 <rwbarton> well the first example that came to mind is writing a function Void -> a
10:03:01 <Veinor> rwbarton: i've used it as the 'initial state' in something where i know that the state'll be overwritten
10:03:01 <MagneticDuck> Void?
10:03:12 <nand`> MagneticDuck: data Void
10:03:18 <rwbarton> a data type with no constructors
10:03:24 <nand`> (that's it's definition)
10:03:28 <MagneticDuck> Veinor: Don't you usually use () in that occasion?
10:03:32 <rwbarton> haha
10:03:34 <MagneticDuck> Veinor: Like tell?
10:03:37 <Taneb> () has one constructor
10:03:40 <Taneb> Void has zero
10:03:44 <rwbarton> weren't you just asking about () :P
10:03:49 <Veinor> MagneticDuck: no, because if i used () then the only type i could set the state to would be ()
10:03:53 <MagneticDuck> What's Void using for then....
10:04:08 <azaq23> Eduard_Munteanu Veinor: ah neat, well yes, it boils down to some primitive operation / syntax which lets you do recursion
10:04:11 <nand`> MagneticDuck: logical negation I guess? not sure
10:04:17 <Taneb> Programs as proofs
10:04:22 <ben> can you seq a Void without exploding?
10:04:25 <rwbarton> e.g. you have a type constructor with a type variable a used in certain constructors, and you don't want those constructors to appear
10:04:32 <MagneticDuck> nand`: Mixing up Java and C programmers who venture too far into haskell?
10:04:36 <nand`> ben seq on a void would probably be _|_
10:04:36 <Eduard_Munteanu> azaq23: yeah, you could say Haskell is inconsistent all the way down :D
10:04:41 <Taneb> ben, I'd like to see you manage to get a Void into a seq
10:04:48 <nand`> print :: String -> Void
10:04:50 <nand`> excellent
10:05:08 <nand`> Taneb: (fix id :: Void) `seq` ()
10:05:18 <MagneticDuck> ....and then it just has to return undefined..?
10:05:19 <Taneb> Ah, okay
10:05:30 <Veinor> nand`: that'll blow up by diverging
10:05:39 <ben> I figured!
10:05:42 <nand`> Veinor: what do you mean? it'll just be _|_
10:05:51 <Veinor> oh true
10:06:02 <nand`> to clarify
10:06:09 <nand`> since Void has no constructors, it has only one possible value
10:06:11 <nand`> _|_
10:06:14 <nand`> and seq on _|_ is always _|_
10:06:21 <MagneticDuck> @type _|_
10:06:23 <lambdabot> parse error on input `|'
10:06:23 <monochrom> apparently, trying to fit "programs are proofs" into a language where programs are not proofs is funny
10:06:35 <MagneticDuck> @type (_|_)
10:06:37 <lambdabot> parse error on input `|'
10:06:41 <nand`> MagneticDuck: _|_ isn't haskell syntax
10:06:42 <Taneb> _|_ means "Good luck"
10:06:48 <Taneb> "This doesn't work"
10:06:49 <MagneticDuck> and thanks for all the fish?
10:07:06 <MagneticDuck> yeah anyway...
10:07:19 <nand`> _|_ can mean “undefined” or “unevaluated” depending on the context
10:07:26 <MagneticDuck> btw I'm still stuck on why in the world anyone would want to return Void
10:07:38 <Taneb> Programs as proofs.
10:07:46 <MagneticDuck> ..hm?
10:07:56 <Taneb> If you can get Void, you've disproved something
10:08:13 <rwbarton> especially if your program isn't in Haskell
10:08:32 <MagneticDuck> ...and so your program is wrong
10:08:48 <ben> http://hackage.haskell.org/packages/archive/conduit/0.4.2/doc/html/Data-Conduit.html#t:Source here's a Void!
10:08:52 <MagneticDuck> There's something I'm not seeing.
10:09:19 <rwbarton> I gave an actual use of Void earlier ... ah ninja'd
10:09:21 <rwbarton> http://hackage.haskell.org/packages/archive/conduit/0.4.2/doc/html/Data-Conduit.html#t:Sink
10:09:42 <MagneticDuck> Oh. In that case it seems to be a placeholder that never gets used, and can't be used either.
10:10:24 <rwbarton> more like it can never be created
10:10:52 <rwbarton> well, in Source at least
10:11:02 <rwbarton> or do I mean Sink
10:14:26 <killy9999> If I have "instance Num Int where" how do I call that? Instance declaration of Num Int?
10:14:52 --- mode: holmes.freenode.net set +o ChanServ
10:15:26 <mcstar> this ChanServ guy keeps hanging around my own channel too...
10:15:37 <ben> > show id
10:15:38 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:15:39 <lambdabot>    arising from a use of `...
10:15:46 <coppro> mcstar: there's an option to turn that off
10:15:47 <ben> oh come on lambdabot >:[
10:16:02 <Franciman> hpc, I still cannot solve the hlint issue
10:16:04 <MagneticDuck> someone has to write a big book on how to pronounce haskell syntax
10:16:05 <MagneticDuck> :x
10:16:06 <tiram> does GHCi 7.4.1 support constraint kinds?
10:16:06 <ben> I wanted the diagnostic for "Possible fix: add an instance declaration for (Show (a0 -> a0))"
10:16:13 <mcstar> coppro: before the update, it always disappeared in a sec
10:16:30 <killy9999> ben, show the code
10:16:51 <ben> I just wanted to answer your question since ghc calls it an instance declaration :D
10:16:58 <monochrom> lambdabot is not ghci
10:17:01 <killy9999> ah, ok :)
10:18:11 <monochrom> yes, ghc 7.4 supports constraint kinds
10:19:20 <tiram> monochrom, it keeps complaining "    Not in scope: type constructor or class `Constraint'" !
10:19:42 <monochrom> oh, that one requires import GHC.Exts
10:20:49 <tiram> ah, right... hoogle didn't help!
10:21:12 <tiram> tnx
10:22:08 <srhb> How do I specify package flags to cabal install? I'm standing in the source dir about to run cabal install.. is it -f "flagname" ?
10:23:11 <monochrom> I think so
10:23:45 <parcs`> or -fflagname
10:23:51 <monochrom> "cabal install --help" and look for -f, there is an example
10:24:44 <srhb> ah, I was doing cabal --help. Thanks!
10:25:16 <srhb> Nice, now it shows the flag right when I fire the command. Works. :)
10:32:17 <nand`> if I remember correctly, all Agda programs terminate, right?
10:32:43 <Enigmagic> that's what i've been told
10:33:12 * Enigmagic hasn't written a single line of Agda though
10:33:20 <nand`> what's the relationship between this property and the halting problem? Is Agda turing complete?
10:33:26 <rwbarton> I think functions that don't pass the termination checker just get marked
10:33:27 <nand`> (assuming it is correct)
10:33:31 <nand`> rwbarton: I see
10:33:52 <monochrom> Agda shifts the proof obligation to you
10:34:01 <coppro> It allows for verification of programs via the Curry-Howard Isomorphism
10:34:10 <nand`> right
10:34:16 <monochrom> so the right question is: what is the relationship between you and the halting problem?
10:34:23 <coppro> This can't be done if you admit bottom
10:34:57 <rwbarton> I think possibly functions that don't pass the termination checker can't be used in types, but you can still run them
10:34:58 <nand`> monochrom: so, if Agda can't automatically tell something terminates; it marks it so I have to prove it myself? or what?
10:35:20 <danr> nand`: if it fails the termination checker you have to write your definition in some other way
10:35:21 <monochrom> yes, you have to prove it yourself, and submit your prove to Agda for approval
10:35:41 <monochrom> so, can you solve the halting problem?
10:35:45 <danr> for instance using a well founded order
10:36:11 <nand`> that somewhat clears it up
10:38:16 <cheater_> hi i have a question
10:40:04 <geekosaur> so, ask it.  someone will answer if they can
10:40:04 <cheater_> how did ghc come to be, did spj find haskell on a website one day and think "oh i'll implement that" or was he involved in actually coming up with haskell
10:40:04 <bitonic> cheater_: Haskell was conceived by a committee that had spj in it
10:40:33 <bitonic> cheater_: he was one of the main proponents and logically he wanted an implementation, and so it started
10:40:39 <bitonic> @where being.lazy.with.class
10:40:39 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/history-of-haskell/history.pdf
10:45:51 <cheater_> thanks
10:47:19 <MagneticDuck> hey just a question: I'm used to the whole world of hackage... but basically a package just exports one value: main. Am I correct?
10:47:29 <Nimatek> > abs minBound :: Int
10:47:30 <lambdabot>   -9223372036854775808
10:47:32 <MagneticDuck> That doesn't seem right
10:47:47 <shapr> MagneticDuck: Hackages have exposed libraries too.
10:48:01 <MagneticDuck> Okay, but programs and libraries are different things
10:48:05 <MagneticDuck> okay
10:48:12 <shapr> MagneticDuck: I don't understand?
10:48:14 <nand`> Nimatek: funny
10:48:32 <nand`> I wonder if that should be considered a bug in Int's Num instance
10:48:38 <nand`> actually, the alternative wouldn't be much better
10:48:45 <nand`> (returning maxBound instead)
10:48:59 <Nimatek> Int is just bad overall.
10:49:15 <Igloo> Arguably it should throw an exception, like minBound `div` (-1)
10:49:18 <nand`> I think the best “solution” would be to increase the minBound of Int by one instead
10:49:44 <nand`> (not just that function, but the whole instance)
10:49:49 <Franciman> hey people can you help me with haskell-src-exts installation problem?
10:49:53 <rwbarton> > minBound `div` (-1) :: Int
10:49:54 <lambdabot>   *Exception: arithmetic overflow
10:50:03 <Igloo> nand`: What would minBound - 1 be in that case? Bearing in mind we don't really want to do a bounds check for every subtraction
10:50:06 <MagneticDuck> shapr: I mean, there are programs that just export main, but there are also open libraries
10:50:06 <Nimatek> > read "13123132312321342423" :: Int
10:50:07 <nand`> > maxBound + 1 :: Int
10:50:08 <lambdabot>   -5323611761388209193
10:50:09 <lambdabot>   -9223372036854775808
10:50:17 <nand`> so how come `div` throws an exception
10:50:19 <MagneticDuck> are they really different?
10:50:21 <nand`> but (+) doesn't
10:50:35 <Igloo> The rationale is that (+) is expected to wrap, but `div` isn't
10:50:57 <nand`> “(+) is expected to wrap” <- I'd consider that entirely non-intuitive, personally
10:51:05 <MagneticDuck> programs export commands that you can run from the shell, but libraries just export modules that you can add to the context in a program. Correct?
10:51:21 <Igloo> Well, I think that most programmers are used to (+) on integral types wrapping
10:51:44 <rwbarton> (+) and (*) on Int as arithmetic mod 2^32/2^64 is fast and useful and intuitive
10:51:51 <Enigmagic> Igloo: leads to security bugs though... i like c#'s default of overflow checking by default.
10:52:04 <shapr> MagneticDuck: I think you can have both without much trouble. I've seen that used for for demonstrations, testing, etc.
10:52:06 <fragamus> can you guys see any way to make this prettier:  value c = min 10 $ case c `mod` 52 > 26 of True -> 13 - c `mod` 13; False -> c `mod` 13 + 1
10:52:17 <rwbarton> fragamus: if ... then ... else ...
10:52:19 <Igloo> Enigmagic: Well, that's a larger proposal that someone could make
10:52:22 <shapr> @pl value c = min 10 $ case c `mod` 52 > 26 of True -> 13 - c `mod` 13; False -> c `mod` 13 + 1
10:52:22 <lambdabot> (line 1, column 49):
10:52:22 <lambdabot> unexpected ">" or "-"
10:52:23 <lambdabot> expecting variable, "(", operator, "<*", "*>", "<$>", "<$", "<**>", "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`", "$", "$!", "`seq`" or end of input
10:52:25 <shapr> hrm
10:53:20 <Enigmagic> Igloo: i'll put it on my list. when i was doing systems development in c++ we used safe int (bounds checked) operations by default for the same reason.
10:53:34 <rwbarton> (also do you mean >= 26?)
10:53:55 <Igloo> Enigmagic: http://hackage.haskell.org/package/safeint exists, incidentally, but obviously it's opt-in
10:54:25 <fragamus> no
10:54:53 <Enigmagic> Igloo: yeah i know. personally i think the other way is safer, the people who want wrapping/overflow usually know that they need it.
10:54:55 <fragamus> maybe
10:57:04 <fragamus> yes
10:57:36 <fragamus> thank you
11:03:36 <asperge> do you know any good Haskell graphics library not especially intended for vector graphics in 2D?
11:03:57 <asperge> there's always OpenGL but I don't really like the interface
11:04:00 <nand`> asperge: you mean like for raster graphics?
11:04:27 <asperge> yeah something like that I think
11:04:35 <asperge> I'm trying to draw Mandelbrot set
11:04:54 <nand`> there are a few existing mandelbrot renderers that you could look into; some of them output .png or other files
11:05:12 <DMcGill> asperge: have you seen http://yannesposito.com/Scratch/en/blog/Haskell-OpenGL-Mandelbrot/ ?
11:05:13 <nand`> I used a few raster graphics manipulation modules in the past as well, one of them had “devil” in the name I think
11:05:21 <nand`> Codec.Image.DevIL
11:05:28 <nand`> not sure which one I ended up using though
11:05:32 <asperge> DMcGill: yes, but it uses OpenGL
11:05:42 <asperge> although I think that's what I'll use at the end
11:06:37 <tgeeky> here's a really simple question. In a module like this: http://hackage.haskell.org/packages/archive/bound/0.2/doc/html/src/Bound-Class.html  -- why not put the type and definition inside Bound?
11:06:57 <shapr> @quote
11:06:57 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
11:07:35 <Eduard_Munteanu> Heh.
11:07:55 <Eduard_Munteanu> @yarr
11:07:56 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
11:08:25 <MagneticDuck> I'm using ubuntu... what exactly do I download to get gtk2hs? I don't see a precompiled package for ubuntu. I'm just learning about packages...
11:08:36 <MagneticDuck> I'm stuck at this page: <http://projects.haskell.org/gtk2hs/download/>
11:08:40 <DMcGill> tgeeky: do you mean to ask why the def for (=<<<) isn't part of the class Bound?
11:08:40 <MagneticDuck> ._.
11:10:35 <Eduard_Munteanu> MagneticDuck: you could cabal install 'gtk' and perhaps other packages
11:11:11 <MagneticDuck> aaaahhhh
11:11:15 <MagneticDuck> I didn't see that
11:11:28 <DMcGill> if so, it's because he couldn't think of a situation where (=<<<) could be anything other than `flip (>>>=)'
11:11:30 <MagneticDuck> I'm just about as savvy as your average grandma when it comes to packages
11:12:03 <Eduard_Munteanu> Hm, yeah, see the "Sources" paragraph.
11:13:31 <Culio> How guys , where can i find some good informations abour WHNF- Haskell ?
11:13:49 <bitonic> @google weak head normal form haskell wiki
11:13:51 <lambdabot> http://www.haskell.org/haskellwiki/Weak_head_normal_form
11:13:51 <lambdabot> Title: Weak head normal form - HaskellWiki
11:14:23 <bitonic> Culio: ^^^
11:14:36 * hackagebot attoparsec-parsec 0.0.0 - An Attoparsec compatibility layer for Parsec  http://hackage.haskell.org/package/attoparsec-parsec-0.0.0 (SimonHengel)
11:14:51 <Culio> :D thx
11:14:59 <bitonic> you're very welcome
11:15:50 <MagneticDuck> the first result in google --  recommended by lazy people everywhere
11:19:27 <killy9999> Culio: http://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form
11:32:03 <edwardk> preflex: xseen byorgey
11:32:03 <preflex>  byorgey was last seen on freenode/#haskell 1 day, 4 hours, 11 minutes and 46 seconds ago, saying: if you're just writing a bunch of text to the screen, or to a file, turning off buffering slows things down a lot
11:32:16 <srhb> Wisdom.
11:39:23 <d-old> why are all the helper functions of MVar not atomic? aren't the kind of useless?
11:39:31 <d-old> not even readMVar is atomic
11:39:52 <c_wraith> no, they're quite useful
11:40:06 <dmwit> d-old: If you want large atomic transactions, use STM.
11:40:12 <edwardk> dmwit++
11:40:52 <d-old> oh wait, ofcourse they are atomic as long as any operation tries to read before it writes
11:40:57 <edwardk> making large chains of MVar actions atomic cannot be done without potential deadlock. STM has a way to resolve that deadlock, but you can't do that with arbitrary IO actions mixed in
11:41:23 <d-old> which all of them are, it only becomes dangerous when you call putMVar without doing takeMVar first
11:42:00 <edwardk> well, even if you takeMVar first, you don't know if someone raced in there and put something
11:42:06 <edwardk> there are usecases for just putting
11:42:39 <dmwit> No, I'm pretty sure he's right: if *all* threads call takeMVar before putMVar, you're in good shape.
11:42:40 <tgeeky> DMcGill: yes
11:43:10 <edwardk> dmwit: fair nuff, in that sense you're just using it to imitate another control primitive
11:43:13 <dmwit> This is a whole-program invariant that you must document and maintain, though.
11:43:14 <DMcGill> tgeeky: did you see the comment I made about 3 posts below my other one?
11:43:30 <edwardk> or just hide behind a module and an opaque type
11:43:35 <dmwit> Yes, that would be better.
11:43:38 <tgeeky> DMcGill: nope. ok.
11:44:08 <DMcGill> if it really bothers you, hide its import and define it yourself
11:44:28 <tgeeky> DMcGill: it doesn't. I'm wondering for a different circumstance
11:44:38 * hackagebot attoparsec-parsec 0.0.1 - An Attoparsec compatibility layer for Parsec  http://hackage.haskell.org/package/attoparsec-parsec-0.0.1 (SimonHengel)
11:44:52 <tgeeky> DMcGill: namely, http://hackage.haskell.org/packages/archive/ClassLaws/0.3.0.1/doc/html/src/Control-Monad-Laws.html <-- that kind of thing
11:45:17 <tgeeky> the question is, why would you put (functorLawN) *in* Functor, and why would you not
11:45:27 <tgeeky> same for Monad, etc, etc
11:45:38 <edwardk> functorLawN ?
11:45:53 <tgeeky> edwardk: where N is [1,2..]
11:46:03 <tgeeky> I don't necessarily like the naming scheme, but the idea is general
11:46:23 <edwardk> i get the gist of what that code is trying to say, but yegods its unreadable ;)
11:46:38 <tgeeky> to pair a test generator with a class
11:47:40 <d-old> weird, no modifyMVar that takes (a -> a), why would I want to run IO in there?
11:47:54 <edwardk> why are the defaultFunctorLaw etc not just defined inline rather than made external to the class?
11:47:57 <identity> Hey guys. As the question is not specific to either frameworks, I figure this is the rigt venue: Which web framework is more 'beginner-friendly', Yesod or Happstack? I'm looking for something that would let me set up a site relatively easily, without all too much hassle, with support for some kind of templating. Any takers?
11:48:14 <tgeeky> edwardk: that is exactly why I asked the question above
11:48:40 <tgeeky> 14:06 < tgeeky> here's a really simple question. In a module like this: http://hackage.haskell.org/packages/archive/bound/0.2/doc/html/src/Bound-Class.html  -- why not put the type and definition
11:48:44 <tgeeky>                 inside Bound?
11:48:53 <edwardk> well, i mean that FunctorLaws has functorLaw1 = defaultFunctorLaw1
11:48:57 <srhb> identity: Eh, not sure.. I thought Yesod was a little complex to set up, while happstack was really easy. On the other hand doing anything with Happstack is a little complex once it's setup, but Yedos is quite easy from there.
11:49:00 <edwardk> not that its not in Functor proper
11:49:05 <identity> If you feel Snap is a good choice, then feel free throw that out there, as well.
11:49:09 <identity> srhb: I see.
11:49:25 <dmwit> d-old: For example, to call "evaluate".
11:49:27 <rwbarton> maybe an instance's custom functorLaw1 would want to refer to the defaultFunctorLaw1 for the same type? i dunno
11:49:29 <identity> I have touched a bit on Happstack, I must admit, but it was a while ago(possibly over a year ago) and I don't remember much of it at all.
11:49:36 <dmwit> :t modifyMVar
11:49:37 <lambdabot> Not in scope: `modifyMVar'
11:49:38 <tgeeky> edwardk: yeah. So, assume I say that I want to do it (put the functorLaw fuctions in the genuine Functor class (in base, I guess?))
11:49:39 <srhb> identity: If you're familiar with Django-esque style, I guess Yesod might be easier. I liked Happstack more for being very haskell-y
11:49:41 <dmwit> :t evaluate
11:49:42 <lambdabot> Not in scope: `evaluate'
11:49:45 <tgeeky> edwardk: why would that be bad?
11:49:46 <dmwit> ?hoogle evaluate
11:49:47 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
11:49:47 <lambdabot> Control.Exception evaluate :: a -> IO a
11:49:47 <lambdabot> Control.OldException evaluate :: a -> IO a
11:49:49 <identity> srhb: Oh, happstack is haskelly? I like that
11:49:52 <tgeeky> edwardk: it wouldn't cost any performance, would it?
11:49:54 <srhb> identity: Pretty sure this is really a case of taste.
11:49:58 <identity> srhb: I see.
11:49:59 <tgeeky> edwardk: unless people call the functions
11:50:08 <identity> Well, I know I like "haskell-y", so I'll check happstack out. thanks
11:50:13 <asperge> edwardk: sorry if this has been asked already, but why isn't there a function to apply a parser to a String and which returns the result of applying the parser (that is, not parseTest)?
11:50:22 <edwardk> i say it'd be tedious. i like programming in haskell. that becomes programming in an easily fooled weaker agda ;)
11:50:29 <asperge> is it because it's not yet implemented, or for some deeper reason?
11:50:37 <edwardk> asperge: laziness. send a patch ;)
11:50:42 <asperge> ok
11:50:51 <asperge> I'll try to do it tomorrow
11:50:54 <edwardk> mainly because i was working on a larger rewrite that got stalled
11:50:57 <tgeeky> edwardk: tedious? for the person who has to write these things, sure. But what about for the user and programmer?
11:51:04 <edwardk> for the author
11:51:24 <edwardk> keep in mind this is the same culture that thought making everyone write a Functor when they specified a Monad was too much work ;)
11:51:55 <edwardk> also some of those equalities are up to some quotienting
11:52:06 <tgeeky> that's minor
11:52:15 <edwardk> so what do i do when my monad transformer _isn't_ properly a monad transformer but is only up to some equivalence notion
11:52:35 <edwardk> well, its a real issue. have you seen the crazy amount of work that has been going into copumpkin's categories library in agda?
11:52:40 <rwbarton> then you provide a non-default implementation :)
11:52:48 <tgeeky> nothing, you have some tests which don't pass, but you didn't write them anyway
11:52:48 <rwbarton> monadLaw1 = const True
11:53:03 <edwardk> what is the definition for Law ?
11:53:12 <tgeeky> equality of a two element list
11:53:13 <shapr> What does the symbol >>> mean?
11:53:16 <rwbarton> (i have no idea, i made that up)
11:53:16 <shapr> In math?
11:53:17 <tgeeky> it could be weakened
11:53:27 <tgeeky> shapr: much much much greater than?
11:53:28 <tgeeky> lol
11:53:36 <shapr> tgeeky: I think that might be true.
11:53:47 <edwardk> :t Control.Category.(>>>)
11:53:48 <lambdabot> Couldn't find qualified module.
11:53:55 <edwardk> :t (Control.Category.>>>)
11:53:55 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
11:54:05 <shapr> edwardk: Is there anything else in the math world?
11:54:09 <tgeeky> shapr: there are (package)-unicode-symbols on hackage
11:54:11 <tgeeky> that might help
11:54:24 <tgeeky> shapr: http://hackage.haskell.org/packages/archive/base-unicode-symbols/0.2.2.3/doc/html/Control-Category-Unicode.html
11:54:25 <edwardk> its a very domain specific symbol. there isn't any canonical mathematical meaning for it, why?
11:54:28 <tgeeky> U+22D9, VERY MUCH GREATER-THAN
11:54:33 <shapr> edwardk: Ah, just curious
11:54:36 <rwbarton> I would guess some context-dependent notion of asymptotically greater than
11:54:45 <edwardk> usuall << is used for much less than or >> for much greater than
11:54:54 <tgeeky> edwardk: evidently the unicode boffins took that one step further
11:54:58 <tgeeky> I don't think it's standard either
11:55:56 <edwardk> anyways i escaped agda/coq to come back to haskell to escape writing those proofs ;)
11:56:08 <tgeeky> edwardk: that's the whole point of what I'm saying
11:56:22 <edwardk> that you want to drive me out of the haskell community too? =)
11:56:31 <tgeeky> it's no worse for anyone in the Haskell community except the dork who wants to write the "proof" -> test generators the first time
11:56:37 <tgeeky> everyone else just has quickcheck tests they can choose to use or not
11:56:56 <tgeeky> edwardk: hell no. If anything, you write *too much* code in other languages :O
11:57:30 <edwardk> in general i dont like embedding quickcheck tests in code. part of this comes from the fact that the quickcheck framework is fragmented between the 1.x and 2.x versions, so doing so currently has the effect of cutting off half your user base
11:58:06 <tgeeky> that's a legitimate gripe
11:58:13 <tgeeky> not that bad, though -- many people have moved to 2
11:58:20 <tgeeky> though if there's a 3, it's an even worse gripe :o
11:58:57 <edwardk> the problems i have is that when i do upgrade some of my dependencies force me down to 1.x again, etc. its just a mess
11:59:03 <tgeeky> edwardk: also, what's to stop you from doing this on the type level with type-level(strings, ints)?
11:59:20 <edwardk> that sounds even more fun
11:59:35 <Addihockey10> Hello :-0
11:59:36 <tgeeky> hehe
11:59:48 <edwardk> in general that would work, but only for rank-1 properties
11:59:56 <tgeeky> awh
12:00:09 <edwardk> so basically i couldnt do anything with my code
12:00:17 <Addihockey10> I have a question, are there any bloggers in here? I'm redesigning my blog but I can't figure out how to do something
12:00:51 <tgeeky> edwardk: btw, just curious: when you INLINE all the things (as you often do), do you write those annotations by hand? :o
12:01:00 <edwardk> yes
12:01:09 <tgeeky> man I've got to fix that for you somehow
12:01:26 <tgeeky> this bound package is pretty neat
12:01:33 <tgeeky> came at the right time for me to look at too
12:01:41 <edwardk> hah i just wrote a module full of them https://github.com/ekmett/bound/blob/master/Bound/Scope.hs
12:01:48 <edwardk> great =)
12:01:52 <edwardk> i'm looking for users =)
12:01:55 <tgeeky> hehe
12:02:09 <edwardk> i like how clean it turned out
12:02:19 <edwardk> and its small enough that people won't give me the usual grief ;)
12:02:25 <tgeeky> heh
12:02:29 <saml> https://gist.github.com/2939665#L93  hey am I doing the right thing in showRequest function?
12:02:36 <saml> ] ++ getHeaders.. part
12:02:42 <edwardk> that and i guess documenting it helps
12:02:54 <tgeeky> edwardk: you have no idea how much :)
12:03:09 <edwardk> =)
12:03:45 <edwardk> i'm thinking about adding a data Named n a = Named n a comonad to it and some combinators that allow you to abstract into Scoped (Named a b) f a
12:04:02 <edwardk> where Named only compares for (==) and compare on its second argument
12:04:05 <tgeeky> wouldn't that be just an idiomatic scope?
12:04:09 <edwardk> so you can capture sort names
12:04:12 <Addihockey10> edwardk: Hi, you blog? Do you mind giving me feedback on http://addihockey.helpmebot.org.uk/2012/06/piriform-ccleaner-v3-19-review/ ? It's one of my first posts and I'm still a bit unfamiliar with this all ;-P
12:04:50 <tgeeky> Scoped (Idiom a u) f a
12:05:03 <edwardk> Idiom = const?
12:05:17 <edwardk> the problem is i rather want the extract to yield the bound value
12:05:37 <tgeeky> hm
12:05:55 <edwardk> or did i misparse that
12:06:01 <edwardk> :source Idiom ;)
12:06:04 <tgeeky> hehe
12:06:20 <tgeeky> what is b in Named b?
12:06:23 <tgeeky> Named a b
12:06:37 <edwardk> well, if you are abstracting a single value, it'd probably be ()
12:06:45 <edwardk> but in my examples i usually have composite patterns, etc.
12:06:59 <edwardk> so in https://github.com/ekmett/bound/blob/master/examples/Deriving.hs it'd be an Int
12:07:21 <edwardk> and in https://github.com/ekmett/bound/blob/master/examples/Overkill.hs it'd be a (Path i) for some index type
12:07:40 <metadave> does anyone have an example of using Network.Curl.Easy to download and save a file to disk?
12:07:56 <tgeeky> edwardk: oh, so
12:08:04 <tgeeky> edwardk: let me show some of my code (from bird's paper
12:08:06 <tgeeky> err
12:08:08 <tgeeky> hinze's paper)
12:08:09 <nand`> hooray, I managed to map ∀∃∈∉ etc. to my keyboard
12:08:10 <chrisdone> how can i use the CPP #if or #ifdef to conditionally compile code for a specific GHC version?
12:08:11 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
12:08:13 <edwardk> so you could have pattern matching code that captures not only the logical identity of something, its usual GenVar number, but also its provenance
12:08:16 <nand`> thought it wasn't possible with xmodmap
12:08:57 <tgeeky> edwardk: https://github.com/technogeeky/d-A/blob/master/src/Control/Applicative/I/GADT.hs
12:09:10 <tgeeky> edwardk: i'm weird, so I used "OOZ" instead of "Z" and "OZI" instead of "Succ"
12:09:23 <edwardk> obviously ;)
12:09:49 <tgeeky> but, the weird thing, is that in an idiom, it seems like the smallest term is not Z, but (S Z)
12:10:10 <chrisdone> ah i found it __GLASGOW_HASKELL__ is a number
12:10:10 <tgeeky> is that a general thing with de brujin indices?
12:10:15 <edwardk> you keep saying idiom, can you give a definition?
12:11:01 <edwardk> thats a fairly traditional Term type, so far so good
12:11:07 <tgeeky> yep
12:11:18 <edwardk> this is exactly what i was trying to avoid with bound
12:11:56 <tgeeky> edwardk: well I just learned it for the first time, so I don't know enough to know to avoid it
12:12:07 <edwardk> i think mcbride said atkey called willingness to work with debruijn indices a good cylon detector =)
12:12:15 <edwardk> fair nuff
12:12:33 <tgeeky> edwardk: the last paragraph of "page 5" http://www.cs.ox.ac.uk/ralf.hinze/Lifting.pdf
12:12:41 <tgeeky> edwardk: "An element of type ..."
12:12:57 <tgeeky> it surprised me that the smallest context is Zero :: Ix ((env, t1), t0), t0
12:13:03 <edwardk> ah yes, i never did pop my reading stack far enough to get here
12:13:04 * monochrom is a dalek. exterminate all humans! and debruijm ftw
12:13:15 <edwardk> tgeeky: maybe a useful example is in that Overkill module
12:13:29 <companion_cube> delete! delete!
12:13:56 <edwardk> notice that https://github.com/ekmett/bound/blob/master/examples/Overkill.hs#L60 H and T both need a Cons cell to index into
12:14:05 <edwardk> you can't HAVE any references into an empty environment
12:14:17 <edwardk> this is important or you can't have closed terms ;)
12:14:32 <Addihockey10> edwardk: Brooke?
12:14:35 <edwardk> its like why Fin n is numbers < n.
12:15:40 <edwardk> so you can index Vec n a with a Fin n
12:15:50 <tgeeky> that (a ':as) is a lifted kind?
12:15:53 <tgeeky> lifted type*
12:15:54 <edwardk> yeah
12:16:32 <edwardk> that module has patterns and indices into the patterns that cannot disagree, you cannot try to reference a part of the pattern that doesn't exist ;)
12:16:39 <edwardk> its a bit overkill
12:16:51 <edwardk> and it complicates the presentation something fierce
12:17:06 <edwardk> a evidenced by the fact that i had to define my own heterogeneous equalities everywhere, etc.
12:17:16 <tgeeky> H and T are Head and Tail?
12:17:17 <edwardk> and i lost all the elegance you get from the Derived.hs example
12:17:19 <edwardk> yeah
12:18:14 <edwardk> so when you were asking what 'b' would be in my names, they can be things like paths into a pattern for complex binders
12:18:20 <edwardk> rather than binding one variable at a time
12:18:29 <edwardk> i can bind all the variables in a pattern in one instantiation
12:18:41 <tgeeky> and you can *not* do that, right?
12:18:45 <tgeeky> you can do partial binding?
12:18:59 <tgeeky> you can bind just some of the variables in a pattern in one go?
12:19:08 <edwardk> https://github.com/ekmett/bound/blob/master/examples/Deriving.hs#L81 does a partial binding
12:19:22 <edwardk> viewpatterns can only reference stuff that occurs earlier than them in the pattern
12:19:32 <edwardk> to mimic ghc's behavior
12:20:19 <tgeeky> I think I am using view patterns in this third-list-homomorphism pearl to do (blah, (x,xs) <- unsnoc ...)
12:20:34 <edwardk> lam (conp "F" [varp "x", viewp (V "y") $ varp "y"]) (V "y")  -- will fail to bind the 'y' in the view pattern function
12:20:35 <tgeeky> or is that guards?
12:20:55 <edwardk> view patterns are \x (x -> y) -> y
12:21:50 <edwardk> so i think you just flipped the arrow in your head unless thats a pattern guard on the right of an |
12:22:11 <tgeeky> it's a pattern guard, let me see where it is
12:22:46 <edwardk> view patterns are useful to avoid naming temporaries, pattern guards are useful to do some work and still be able to backtrack in the pattern matching machinery
12:23:02 <tgeeky> ah: foldlr (||>) ( e   , unsnoc -> (xs,x) ) = (||>) ( foldlr (||>) (e,xs)  ,  x  )
12:23:18 <tgeeky> i have ViewPatterns and PatternGuards both turned on :o
12:23:27 <edwardk> yeah thats a view pattern
12:23:37 <byorgey> edwardk: looking for me?
12:23:43 <edwardk> heya
12:23:49 <edwardk> didn't mean to go all stalkery =)
12:23:55 <byorgey> no worries =)
12:24:04 <edwardk> wanted to get your thoughts on http://hackage.haskell.org/package/bound
12:24:12 <tgeeky> byorgey: me too
12:24:17 <tgeeky> byorgey: I was actually going to ask you
12:24:21 <asperge> edwardk: in `LineDirective (UTF8.fromString fn)` what is LineDirective for?
12:24:32 <asperge> (I've decided to write that patch today :p)
12:24:47 <hhb_> I trying to cabal install hdfs-haskell and I get "Missing (or bad) header file: hdfs.h". I've built libhdfs and definately have it in /usr/local/lib and include and I have tried the cabal args to specify the dirs with libs and headers. This is Mac OS. does anyone know what might be wrong?
12:24:50 <edwardk> asperge: that forces it to give the appropriate filename in the error message
12:24:58 <asperge> is it some information about the source or something?
12:24:59 <asperge> ok
12:25:16 <edwardk> you can replace it with "-" or just leave it off if the subsequent code is robust about printing deltas that involve only cols and lines
12:25:46 <asperge> I think I'll just ask the user what he wants to put
12:26:07 <edwardk> line directives are residue from c preprocessing that tell you what file you're in, the delta type in trifecta supports mappending them to change where errors are reported from
12:26:31 <edwardk> you can just ask for a Delta i think, that way if they don't want to specify one at all they don't have to
12:27:04 <asperge> ok
12:27:12 <edwardk> byorgey: my apologies for riffing on your package name ;)
12:27:33 <byorgey> edwardk: no apologies necessary =)
12:27:35 <tgeeky> enslaving the things byorgey was trying to set free
12:27:46 <byorgey> edwardk: seems cool, I'll have to take a closer look soon
12:28:01 <edwardk> https://github.com/ekmett/bound/blob/master/examples/Deriving.hs is a decent example
12:28:12 <edwardk> of its use in actually constructing a term type
12:28:46 <edwardk> and in https://github.com/ekmett/bound/blob/master/examples/Simple.hs i build a cheesy untyped lambda calculus evaluator, etc.
12:29:06 <tgeeky> edwardk: if a DList has a newtype like: newtype DList a = DL { unDL :: [a] -> [a] }
12:29:09 <edwardk> mostly i wanted something that had pretty much zero cost and was haskell 98
12:29:18 <tgeeky> what would the newtype of List be?
12:29:39 <tgeeky> edwardk: the paper you linked said that the "higher order abstract syntax" was the only implementation that was fast, so you went with a variation on it? :o
12:29:43 <edwardk> why newtype it
12:29:52 <tgeeky> edwardk: oh, I don't want to
12:29:54 <edwardk> tgeeky: no, this is a form of debruijn indices
12:30:03 <edwardk> hoas is a bear to work with when you want to do a lot of manipulation
12:30:28 <`Jake`2> did you ever to use irc via telnet? You should do it, it's kind of funny
12:30:52 <edwardk> and since it goes into negative positions everywhere, you have a hard time theorem proving with it, which forces you into 'weak hoas' or phoas which is blechy
12:30:58 <tgeeky> edwardk: I don't want to newtype List, but I just want to know what it would look like. Rather, I want to know what "unList"'s type would be
12:31:13 <edwardk> i have no idea what you are getting at ;)
12:33:23 <Saizan> edwardk: stratification also works, like when you embed a predicate hierarchy of universes
12:33:39 <edwardk> Saizan: for hoas?
12:33:43 <Saizan> *predicative
12:33:47 <Saizan> yeah
12:33:51 <edwardk> fair nuff
12:34:41 <edwardk> i just have enough trouble getting under binders to do real work in hoas, you can pretty much always do it, but i'd rather be solving problems than performing mental gymnastics for every traversal
12:35:10 <Saizan> yep, i wasn't objecting to that :)
12:35:20 <HairyDude> @hoogle Functor f => f a -> (a -> b) -> f b
12:35:21 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:35:21 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
12:35:21 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
12:35:34 <HairyDude> aw, no pretty name for flip fmap
12:35:38 <Saizan> https://personal.cis.strath.ac.uk/conor.mcbride/pub/Hmm/Hier.agda <- though the fact that Set is big enough to contain a whole hierachy is quite fun (see UpU)
12:35:38 <edwardk> the main thing i need to add to Bound is some newtype or data type for helping you annotate bound names with a hint of what you should call them
12:36:15 <tgeeky> edwardk: like, if you have three bound things, "r" "g" "b" ?
12:36:18 <edwardk> ah, i seem to recall seeing this
12:36:46 <edwardk> tgeeky_: mostly so that when i pretty print i can give back names a user will recognize, can point to source locations, etc.
12:37:23 <edwardk> Saizan: wasn't this one of his examples that would work or not work depending on the version of agda? =)
12:37:28 <Saizan> (i guess _^_ is more it, UpU is just one layer)
12:38:38 <Saizan> edwardk: i think those were earlier attempts, this one works if you have enough memory to throw at it :)
12:38:45 <edwardk> ah yes
12:38:56 <edwardk> someone came along and figured out how to get it to fit in memory
12:38:58 <edwardk> now i remember
12:39:14 <edwardk> i mostly skim the agda mailing list
12:43:23 <Saizan> edwardk: are you going to need unification or reduction on terms like these?
12:43:41 <edwardk> i actually have a batch of unification combinators i've been playing with
12:43:55 <edwardk> in particular i have a haskell 98 version of unification-fd
12:44:06 <srhb> When trying to link gtk2hs programs, I get "Undefined symbols for architecture x86_64: "_gdk_x11_drawable_get_xid", referenced from: _s2pLf_info in libHSgtk-0.12.3.a(Structs.o)" -- but I did build gtk with --flags="have-quartz-gtk" - so I don't see why it would use this symbol at all. Anyone know?
12:44:39 * hackagebot shake 0.3 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.3 (NeilMitchell)
12:44:43 <edwardk> requires a slightly different interface than sheard's two-level types, because i want the user to supply a full ideal monad rather than just the base functor of a free monad
12:45:31 <edwardk> by reduction you mean beta reduction etc?
12:45:41 <hhb_> I'm getting a missing .h when I cabal install. It is in my includes. Any tricks I should try?
12:45:41 <edwardk> i have a whnf evaluator in one of the examples for instance
12:48:45 <Saizan> edwardk: i see
12:49:04 <hhb_> OK, cabal -v3 shows the real error: /usr/local/include/hdfs.h:33:17: error: jni.h: No such file or directory. I can deal with that.
12:51:21 <asperge> edwardk: I've moved parseTest to Text.Trifecta.Parser.ByteString to avoid cyclic dependencies, does that seem ok to you?
12:51:36 <asperge> (so that it uses the new function)
12:51:40 <edwardk> i can't think of any terrible objection
12:52:10 <asperge> it's not perfect but I think it should be ok in general
12:52:20 <asperge> I'm sending the pull request
12:52:26 <hpaste_> d-snp pasted “Helper function in Monad” at http://hpaste.org/70077
12:52:34 <DMcGill> in Data.Map, is there a way to find the keys that contain a specific value or should I use an association list for this sort of thing?
12:52:59 <d-old> I'm utterly failing in constructing this helper function
12:53:05 <d-old> it's giving all kinds of errors
12:53:11 <DMcGill> I'm using Data.Graph and want (Vertex -> Value) and (Value -> Vertex) functions
12:53:32 <monochrom> use the bimap package for lookup both ways
12:56:10 <daniel_-> sigh, anyone who can tell me how i change dns server in ubuntu? been getting dns lookup errors all day...
12:56:32 <Eduard_Munteanu> /etc/resolv.conf ?
12:57:07 <geekosaur> or whatever dhcp config is setting it
12:57:33 <Eduard_Munteanu> I guess it could be a ISP DNS issue, maybe you can run your own bind/named.
13:01:07 <DMcGill> can you add a 'where' clause inside a lambda function?
13:01:16 <monochrom> no
13:02:03 <DMcGill> thanks
13:02:40 <ben> where clauses are the best clauses
13:02:45 <ben> we should have more of them
13:03:28 <daniel_-> would someone mind giving me the ip for yesodweb.com (dns lookup errors with isp)
13:03:41 <ben> PING yesodweb.com (208.94.116.204) 56(84) bytes of data.
13:03:54 <daniel_-> ty
13:07:05 <geekosaur> daniel_-, http://www.liberiangeek.net/2012/05/setup-static-dns-servers-in-ubuntu-12-04-precise-pangolin/ --- I use google public dns, 8.8.8.8 / 8.8.4.4
13:15:18 <Targen> Is there some impediment to using a module alias in import statements when working in hs-boot files for breaking cyclic module inclusion in GHC?
13:19:14 <miyako> hello
13:20:02 <balor> Given an Aeson value, how can I "wrap" it by prepending "doFoo(" and appending ")" in order to do JSONP rather than JSON
13:20:50 <Botje> O_o
13:21:24 <Botje> is JSONP what I think it is?
13:21:36 <Botje> 'here, eval this random code from this random server'
13:21:52 <balor> yeah
13:21:56 <balor> it's a bit strange
13:21:59 <Botje> you can do the wrapping after you create your output, i guess.
13:22:45 <miyako> so, I know this is an irritatingly common question, but I'm trying to wrap my head around monads and I'm looking for good documentation. The haskell wiki has good information on what monads are, and using them, but where I'm getting hung up is on creating monads.
13:23:18 <roconnor_> @go you could have invented monads
13:23:19 <lambdabot> Maybe you meant: google googleit do
13:23:20 <hpaste_> HairyDude pasted “horrendous error message” at http://hpaste.org/70079
13:23:20 <hpaste_> HairyDude pasted “horrendous error message” at http://hpaste.org/70080
13:23:26 <Botje> i've been writing haskell for three years now, haven't written one myself yet.
13:23:27 <HairyDude> gah
13:23:29 <roconnor_> @google you could have invented monads
13:23:31 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
13:23:33 <miyako> I just worked through the section on the wiki on creating the state monad, and I think I followed it well enough, but I'd like more of that so I feel like I have a more solid understanding
13:23:35 <HairyDude> ^ how am I to interpret this and fix the error?
13:24:41 <Botje> HairyDude: you made an error in a quasiquote, that's about the only thing I can say :)
13:24:54 <Botje> miyako: I just slap together monad transformers until I get what I want
13:25:02 <rwbarton> maybe try compiling with -ddump-splices
13:25:59 <HairyDude> oh, I see. I tried to make a link that has arguments without supplying the arguments
13:26:03 <hpc> miyako: do Reader and Writer
13:26:11 <hpc> then if you are feeling adventurous, do []
13:29:50 <roconnor_> > do []
13:29:51 <lambdabot>   []
13:31:09 <nand`> now I can program Agda too
13:31:12 <nand`> or I could, if I knew Agda
13:31:22 <nand`> but I managed to map ∀, → and all that fancy stuff to my keyboard
13:31:34 <nand`> no emacs needed
13:32:11 <DMcGill> don't let it go to waste, ghc has a unicode mode somewhere!
13:32:22 <balor> > concat [ Data.Aeson.Encode.encode "Foo", Data.Aeson.Encode.encode "Bar" ]
13:32:23 <lambdabot>   Not in scope: `Data.Aeson.Encode.encode'Not in scope: `Data.Aeson.Encode.en...
13:32:41 <hpc> -XUnicodeSyntax
13:33:02 <roconnor_> @quote edwardk unicode
13:33:02 <lambdabot> edwardk says: i used to be a huge proponent of unicode syntax everywhere, then i used agda ;)
13:33:12 <nand`> hehe
13:33:18 <balor> How do I concat two Data.ByteString.Lazy.Internal.ByteString types?
13:33:23 <otters> why is return called return?
13:33:30 <otters> why ins't it called unit or something
13:33:30 <hpc> otters: to confuse
13:33:32 <nand`> because μ was considered too hard to type
13:33:33 <otters> isn't
13:33:42 <otters> unit is pretty easy to type
13:33:51 <nand`> why not “pure”
13:33:58 <otters> because pure is used for something else
13:34:02 <nand`> but they're the same thing
13:34:04 <hpc> monad was discovered before applicative though
13:34:05 <nand`> :P
13:34:07 <nand`> at least they should be
13:34:08 <hpc> so it could have used pure
13:34:13 <otters> :t pure
13:34:15 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
13:34:20 <otters> then what would pure be called
13:34:24 <nand`> return
13:34:25 * nand` runs
13:34:37 <nand`> otters: to clarify, Monad wouldn't have “return” at all
13:34:42 <nand`> it would have Applicative as a superclass
13:34:47 <otters> I see
13:34:47 <Botje> balor: isn't that just the append function of the Data.ByteString package?
13:35:07 <otters> oh, that's a good joke
13:35:15 <otters> "pure" can lift a value into the IO monad
13:35:26 <nand`> hehe
13:35:31 <nand`> that is an amusing consequence
13:35:37 <otters> even better named
13:35:41 <DMcGill> is there module that is like list but with an O(1) length, efficient indexing and you don't need to know the bounds ahead of time? Is there something better than Map Int?
13:35:56 <roconnor_> DMcGill: Seq Int
13:36:04 <roconnor_> er
13:36:06 <roconnor_> wait
13:36:10 <hpc> Seq Char
13:36:13 <hpc> er
13:36:16 <roconnor_> DMcGill: Map Int has O(1) length
13:36:16 <hpc> Seq whatever
13:36:56 <hpc> roconnor_: don't think so
13:36:57 <nand`> what's Seq's indexing time complexity? O(log n)?
13:37:03 <balor> Botje, thanks.  Why does "Data.ByteString.Lazy.concat" not concat elements of [Data.ByteString.Lazy] ?
13:37:12 <Luke> is there a way to match any possible data constructor of a given type to pull out one of that constructors fields? For example data = X Int | Y Int;     f (_ i) = i
13:37:20 <roconnor_> DMcGill: but there is also IntMap
13:37:32 <hpc> oh, roconnor_ is right
13:37:54 <fmap> nand`: log(min(i, n-i))
13:37:55 <roconnor_> hpc: Map uses size internally for balancing.
13:37:57 <rwbarton> @type Data.ByteString.Lazy.concat
13:37:58 <lambdabot> [BSLC.ByteString] -> BSLC.ByteString
13:38:04 <nand`> fmap: I see
13:38:11 <Eduard_Munteanu> Luke: no
13:38:37 <nand`> Luke: if the fields are named you can use views, I think
13:38:42 <nand`> but that's something different
13:38:54 <nand`> (ie. record accessors)
13:39:12 <Luke> nand`: they are unnamed but good point - thanks
13:39:23 <Luke> nand`: and you reminded me of lenses potentially
13:39:24 <roconnor_> Luke: if you name the field the same, then you can use that name as a projection function to extract that field.
13:39:40 <Luke> projection function?
13:39:46 <rwbarton> the default assumption with "X Int | Y Int" is that the two Int fields are unrelated in semantics
13:39:58 <rwbarton> just by coincidence they happen to both have type Int
13:40:09 <Luke> right
13:40:14 <nand`> Luke: maybe you want (Bool, Int)
13:40:33 <Luke> there are more than 2 dataconstructors in the real example
13:40:51 <Luke> it's actually data Distance = Meters Float | Miles Float | ...
13:41:00 <Luke> there's not already a distance type is there?
13:41:01 <roconnor_> Luke: I usually call the functions generated by field names, projection functions for some reason.
13:41:19 <Luke> roconnor_: gotcha
13:41:29 <Eduard_Munteanu> Luke: how about   data Distance = Dist Unit Float    ?
13:41:36 <rwbarton> that is almost exactly the reason I was going to give for why there is not a way to uniformly extract the Float value... :P
13:41:47 <rwbarton> er, the example I was going to give
13:41:49 <Luke> Eduard_Munteanu: that probably would have been a lot easier =)
13:41:58 <Luke> i spent all this time trying to pull it out from the DB in that form
13:42:24 <Luke> Eduard_Munteanu: thanks
13:43:02 <nand`> does -XUnicodeSyntax have ∘ for (.)?
13:43:27 <c_wraith> no.  (.) isn't syntax
13:43:37 <Eduard_Munteanu> On the upside, you can define it then :)
13:43:43 <Luke> right
13:43:44 <rwbarton> "data Distance = Meters Float | Miles Float | ..." is a semantically better representation
13:44:00 <Luke> rwbarton: you're saying keep it?
13:44:28 <HairyDude> hm. there's no multiple version of Database.Persist.get
13:44:36 <Luke> rwbarton: i guess you're right. it's incorrect to be able to swap out the units for example
13:44:51 <HairyDude> i.e. that lets you get several rows based on their IDs
13:45:17 <nand`> newtype Meters = Meters { getMeters :: Double } -- type safe functions, forcing you to convert to SI units. class IsMeter m where toMeter :: m -> Meters
13:46:03 <nand`> hmm
13:47:42 <nand`> maybe something like that could be experimented with, perhaps with alternatives (for equivalent representations of the same unit)
13:47:52 <nand`> has anybody done type safe physical calculations like that?
13:48:53 <nand`> I'm just not sure how to allow for eg. polytypic :* so I can use say A :* Ω (as an equivalent for V), would type families be a solution for this?
13:49:04 <Luke> nand`: I don't want to convert the units btw
13:58:56 <nobdraisentone> Is there a way to check in guard that input MArray contains less than 2 elements? Something like `liftM ((< 2) . uncurry subtract) . getBounds =<< arr' could return (m Bool) value, actually.
13:59:59 <roconnor_> nobdraisentone: Speaking of bools, you can just use Bool as the index.
14:00:38 <Targen> If I’m understanding this correctly, I believe there’s a small error in the documentation at <http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards>.  Can anyone check my reasoning?  If I’m not mistaken, the last line in the last code listing in that section should read «  f b = R { .. }».
14:00:51 <tgeeky> hm. how about that. the syntax << URL >> allows you to specify an image, but it's not documented in Haddock
14:07:14 <hpaste_> nand` pasted “Physical unit types” at http://hpaste.org/70082
14:21:09 <mzero> anyone manage to get Leksah and cabal-dev to be happy together?
14:28:27 <kaustuv> A newbie question -- I want to create a module M with an exported field x :: IORef Int and I want M.x to refer to the same reference in all clients of M. Am I then forced to use unsafePerformIO?
14:28:53 <monochrom> yes
14:29:24 <mzero> and be sure to put in a NOINLINE pragma too
14:29:28 <mzero> then you're okay
14:29:50 <mzero> but a good question is - does this really need to be a global? Is it like, for example, a database pool?
14:30:34 <kaustuv> It is a variable holding the current last used variable name in a unification engine, and I absolutely cannot pay the price of doing it purely
14:30:59 <kaustuv> So yes, very much like a database pool
14:31:15 <twanvl> but that just means it has to be mutable, not that it has to be global
14:32:00 <kaustuv> Its initializer must be executed exactly once. How would I achieve this safely?
14:32:07 <mzero> it might be better to export     lastUnifiedVar :: IO Int    and   setLastUnifiedVar :: Int -> IO ()
14:32:23 <mzero> then the thing with the unsafePerformIO is totally local to the module
14:33:16 <twanvl> I would prefer to have a Unifier object that holds the variable, the you have mkUnifier :: IO Unifier; lastUnifiedVar :: Unifier -> IO Int
14:34:44 <mzero> internalHoldingCell :: IORef Int;  internalHoldingCell = unsafePerformIO $ newIORef 0; {-# NOINLINE internalHoldingCell #-}
14:35:21 <mzero> I might prefer to have that be   IORef (Maybe Int)
14:37:27 <kaustuv> Thanks to all. This is unfortunate but I suppose not a surprise.
14:40:52 <nand`> so what kind of morphism does ↬ represent?
14:41:31 <squidz> can somebody help me out with "Learn you a Haskell". I was reading and came across: Doing (+) <$> [1,2] <*> [4,5,6]results in a non-deterministic computation x + y where x takes on every value from [1,2] and y takes on every value from [4,5,6]. I dont understand what they mean here by nondeterministic. As far as i knew nondeterministic meant that I could get different results for the same input
14:42:16 <sipa> it can also mean "multiple results"
14:42:39 <nand`> non-deterministic means “multiple states”, pretty much
14:42:55 <squidz> sipa: is that something specific to haskell? Or am I thinking of non-determistice in the sense of algorithms which differs?
14:43:11 <nand`> “different results for same input” <- impossible in Haskell (safely)
14:43:17 <Nimatek> Hm, is there a way to rewrite " loopWhileM p f x = when (p x) $ f x >>= loopWhileM p f " using existing functions and no explicit recursion?
14:43:18 <shachaf> squidz: It acts "as if" it picked arguments for (+) nondeterministically from [1,2] and [4,5,6], but in the end it gives you a list of all the possible results.
14:43:35 <rwbarton> it is a kind of deterministic simulation of a nondeterministic computation
14:43:40 <nand`> also, I'd called that “random” or “stochastic” or something
14:43:45 <sipa> the N in NP-complete is also "nondeterministic", and it means running all possible code paths in practice
14:45:32 <squidz> hmm I am not sure if I am able to define non-determistic now
14:46:18 <nand`> I'd say “involving choices/branches between indistinguishable possibilities”
14:46:20 <sipa> i'd define it as "not a single (possible) output given a single input"
14:46:48 <squidz> oh okay, i guess I just should have continued reading because shortly after i see that LYAH quotes "To represent the result of that non-deterministic computation, we use a list, where each element in the list is one possible list. That's why the result is a list of lists."
14:47:02 <rwbarton> given a state of the system there is more than one possible next state
14:47:14 <squidz> which makes sense to me now
14:47:36 <squidz> thanks everybody
14:48:53 <Nimatek> Oh, and not @pl (in addition to my question)
14:49:25 <squidz> also, I am also to the monads chapter in LYAH. Is there an article out there that is considered amazing? I was wondering if I should read such an article before embarking on possible the most diffifult part of learning haskell from what ive heard
14:50:19 <Nimatek> squidz: It's not the most difficult part of learning Haskell.
14:50:26 <shachaf> squidz: You've probably heard a lot of nonsense, because there's a lot of nonsense out there.
14:50:43 <shachaf> It's not the most difficult part of learning Haskell at all, but there's a lot of misinformation so people get confused.
14:50:47 <mcstar> it good to read LYAH first and look for resources afterwards
14:50:50 <mcstar> s
14:50:51 <Luke> just registered for hacphi this year. anyone else coming?
14:50:52 <shachaf> You should read the FAQ entry about it.
14:50:54 <shachaf> @where faq
14:50:54 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:51:08 <shachaf> Luke: Presumably a lot of the people in #haskell-hacphi are.
14:51:11 <shachaf> (Though not me.)
14:51:28 <Luke> ah yeah  - thanks =)
14:51:37 <mzero> I wish people wouldn't call the [] monad the non-determinsm --- it's really the "all possible ways" monad
14:51:44 <mzero> and really "all possible ways, in order"
14:51:59 <shachaf> mzero: That's nondeterminism!
14:52:08 <mzero> no, not really
14:52:10 <nand`> I'd be hard pressed to find “a most difficult part of learning Haskell”, because it all flows naturally and sequentially, as long as you do it in the right order
14:52:21 <shachaf> I mean, when you say do { x <- foo; ... }, from your perspective, x is "nondeterminstically" chosen from foo.
14:52:34 <mzero> and there is no point in trying make some theortic argument about it being the only deterministic way to implement non-determinism or some such -----
14:52:56 <mzero> because in reality, the [] doesn't do anything that any programmer would consider non-deterministic
14:53:01 <shachaf> mzero: It's not the only deterministic way to implement non-determinism!
14:53:08 <nand`> I tend to think of [] as the “concatenation monad”
14:53:25 <shachaf> mzero: See http://apfelmus.nfshost.com/articles/operational-monad.html
14:53:32 <mzero> so we should stop using terms to mean what we claim they mean, and recognize that EVERYONE gets confused by that expression w.r.t. to [] as a monad
14:53:34 <nand`> but I'm one of those people that think ‘join’ is more fundamental than >>=
14:53:39 <nand`> and should be in the type class
14:53:44 <nand`> (instead of >>=, mind)
14:53:54 <shachaf> You can pick an element of "foo" at random, by using something like State RandomGen, and get the exact same interface in your monad.
14:53:59 <rwbarton> also Logic/LogicT
14:54:01 <mzero> why, because Categorty theory says so?
14:54:07 <mzero> >>= is far more useful than join
14:54:12 <mzero> from a programming persepective
14:54:18 <Eduard_Munteanu> Mm, it's nondeterministic as in NP, no?
14:54:28 <nobdraisentone> How can I trace some recursive function calls? All I need is a values of arguments for all of the calls.
14:54:36 <shachaf> mzero: I think people mainly say that because "join" is simpler than ">>=".
14:54:52 <shachaf> I don't really care. It's good for a lot of senseless arguing, if you're into that.
14:55:02 <shachaf> nobdraisentone: If it's just a debugging thing, you can use Debug.Trace.
14:55:24 <nand`> mzero: it's just that I feel “join” is what defines a monad and it's simpler to conceptualize, at least in my opinion
14:55:59 <nand`> ie. the ability to flatten associatively
14:56:34 <sipa> nobdraisentone: try Debug.Trace
14:56:38 <nand`> (join . join = join . fmap join)
14:58:00 <nand`> for example, in the IO monad; join is what I would consider the primitive that sequences an IO∘IO into an IO by performing the other IO's side effects first
14:58:50 <hpaste_> identity pasted “Num, Fractional, Floating etc” at http://hpaste.org/70085
14:58:58 <dmwit> ?tell srhb it is done
14:58:58 <lambdabot> Consider it noted.
14:59:03 <identity> I could definitely use some help with the link above.
14:59:08 <identity> the question is at the bottom of it.
14:59:43 * hackagebot gtk 0.12.3.1 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.3.1 (DanielWagner)
15:00:00 <identity> I'm trying to create a program that will automatically 'calculate' the derivative of an expression, if that isn't clear.
15:00:30 <nand`> > deriv (2*) 3
15:00:32 <lambdabot>   2
15:00:46 <sipa> nand`: never thought about it that way, but indeed
15:00:55 <sipa> a list of lists can be flattened
15:01:13 <sipa> a tree with trees as its leaves can be substituted
15:01:30 <nand`> Maybe∘Maybe can be flattened too in the entirely obvious way
15:01:30 <shachaf> sipa: The nice thing about "join" in IO is that when used with Control.Monad.Spawn, it actually means what "join" means in most other languages.
15:03:02 <Cale> shachaf: What's that? (I'm unfamiliar with Control.Monad.Spawn)
15:03:58 <identity> Any takers? http://hpaste.org/70085
15:04:28 <Cale> oh I see
15:04:36 <Cale> join in the concurrency sense
15:05:23 <rwbarton> identity: when you write 3 * 4 :: Expression Int it reallt means fromInteger 3 * fromInteger 4 :: Expression Int
15:05:28 <rwbarton> that only happens with literals
15:05:33 <Cale> identity: y :: a
15:05:58 <Cale> identity: and (*) :: (Num a) => a -> a -> a
15:06:08 <Cale> so y * ... :: a
15:06:09 <identity> Cale: Ah, I see.
15:06:46 <identity> Thanks! I'll do it the tedious way :)
15:06:55 <shachaf> Cale: It's completely useless, of course.
15:07:03 <shachaf> But I like it anyway. :-)
15:07:22 <Cale> shachaf: and join in the list monad is another popular interpretation in other languages :)
15:07:41 <rwbarton> I used to write join instead of concat since I could never remember the name 'concat'
15:08:12 <nand`> Is it common to use ι as an identity, eg. when describing Monoids (M,·,ι) ?
15:08:29 <nand`> or am I thinking of some other eltter
15:08:32 <nand`> letter*
15:08:47 <rwbarton> ε i would say
15:08:52 <rwbarton> (but more commonly just 1)
15:09:08 <nand`> rwbarton: oh, we need joinFmap
15:09:12 <nand`> analog to concatMap
15:09:19 <nand`> err
15:09:20 <nand`> forget I said anything
15:09:25 <rwbarton> wikipedia has e, that is another common choice
15:09:28 <nand`> I just embarrassed myself didn't I? :)
15:09:43 * hackagebot xmlhtml 0.2.0.1 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.2.0.1 (DougBeardsley)
15:09:45 * hackagebot heist 0.8.1 - An (x)html templating system  http://hackage.haskell.org/package/heist-0.8.1 (DougBeardsley)
15:10:07 * Eduard_Munteanu wonders what e stands for there
15:10:23 <dmwit> Eduard_Munteanu: epsilon ;-)
15:10:27 <nand`> yeah, I see ‘e’ being used. I'm just wondering whether ι would be appropriate when I really don't want to present the chance of confusion with Euler's constant or the numerical 1
15:10:29 <Eduard_Munteanu> Heh.
15:10:30 <shachaf> Cale: True. I got really annoyed by Ruby's "flatten" today.
15:10:37 <rwbarton> e...lement?
15:10:39 <rwbarton> I got nothing
15:10:45 <nand`> empty?
15:10:53 <rwbarton> I think it may be a French thing
15:11:07 <nand`> eg. empty list
15:11:11 <shachaf> I think it's common to use 1
15:11:30 <shachaf> (M,•,1)
15:11:38 <ski> nand` :)
15:11:40 <rwbarton> as in I would not be surprised to learn that usage of e comes from Bourbaki
15:11:59 <nand`> ⟨M,•,ε⟩ -- needs more fancy symbols
15:12:37 <companion_cube> e is probably the neutral element
15:12:49 <Eduard_Munteanu> Yeah, sure.
15:16:13 <ski> rwbarton : maybe german "Einheit" ?
15:16:48 <Eduard_Munteanu> eigen?
15:17:02 <Eduard_Munteanu> Hm.
15:18:00 <hpaste_> identity annotated “Num, Fractional, Floating etc” with “Num, Fractional, Floating etc (annotation)” at http://hpaste.org/70085#a70086
15:18:46 <identity> Okay, so I think I understand why this isn't working. There is no guarantee that the "a" in "Expression a" is the same as the result, or something. Am I close?
15:19:05 <rwbarton> identity: you can still write   Constant y * x ** (Constant y - 1)
15:19:23 <identity> I can?
15:19:37 <rwbarton> sure
15:19:41 <nand`> ski: I'm German and I totally didn't even think of that
15:19:43 * hackagebot snap-core 0.9.0 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.0 (DougBeardsley)
15:19:51 <rwbarton> because Expression a is an instance of Num and of Floating
15:19:52 <nand`> “eigen” makes less sense; but “einheit” is perfect
15:20:06 <rwbarton> is that "unity"?
15:20:08 <nand`> because “einheit” directly translates to “unit”
15:20:12 <rwbarton> oh, unit
15:20:14 <nand`> in all meanings of the word
15:20:19 <nand`> from military to physical to mathematical
15:20:37 <nand`> rwbarton: that too
15:21:20 <identity> rwbarton: Well, truth be told, I'm not really sure why I can't do this. I know it has something to do with the typeclasses and such, and the fact that I have no restrictions on derive, but i'm not sure what to do to make this work.
15:21:24 <identity> Do I have to approach this differently?
15:21:30 <ski> nand` : anyway, i'm just guessing, i don't know if it comes from "Einheit", but it might as well do
15:21:33 <identity> Do I merely need to impose the restrictions on a?
15:21:33 <rwbarton> no, you just have a random error in your current code
15:22:06 <rwbarton> at the second use of y
15:22:44 <rwbarton> oh, and you will need a class context for a for sure, yeah
15:22:58 <identity> Oh, I see.
15:25:14 <rwbarton> ski: you win
15:25:18 <rwbarton> http://mathoverflow.net/questions/87794/why-is-the-identity-element-of-a-group-denoted-by-e
15:25:34 <identity> rwbarton: Thanks a lot. It was the whole lack of typeclass restrictions, it seems.
15:25:43 <identity> And possibly an error that you menntioned.
15:25:52 <identity> But I had already modified the code to your suggestion.
15:26:33 <rwbarton> aha
15:26:47 <rwbarton> the constraint is ultimately needed in order to say "Constant 1"
15:27:11 <identity> Yeah, that was indeed what it was complaining about, the constant.
15:31:32 <otters> oh man
15:31:55 <otters> so my cabal file has the character ↔
15:32:02 <otters> which on hackage displays as â†”
15:32:05 <otters> whose fault is it?
15:32:30 <DMcGill> is there a function that is to fmap as mapM is to map?
15:32:44 <DMcGill> I want to mapM over a Data.Map
15:32:50 <rwbarton> DMcGill: sort of, check out Data.Traversable
15:33:43 <rwbarton> otters, what encoding is your .cabal file in
15:33:51 <otters> surely it's utf-8
15:33:52 <DMcGill> that's what I was looking for, thanks
15:33:53 <otters> hang on
15:33:54 <JEntrep> Anyone here ever build and utilize a GPU cluster for general purpose computing??
15:33:58 <rwbarton> DMcGill: Data.Map.Map is Traversable so that will work yeah
15:34:30 <rwbarton> â†” does sort of look like utf-8 interpreted as latin-1
15:34:38 <otters> yeah
15:34:40 <otters> let me check
15:34:43 * hackagebot snap-server 0.9.0 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.0 (DougBeardsley)
15:34:45 * hackagebot kevin 0.1.2 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.1.2 (JoelTaylor)
15:34:47 * hackagebot snap 0.9.0 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.9.0 (DougBeardsley)
15:34:49 <otters> yeah, see
15:34:54 <otters> hackagebot can't display it either
15:35:13 <otters> (kevin 0.1.2 - a dAmn ↔ IRC proxy)
15:35:26 <rwbarton> http://hackage.haskell.org/package/kevin-0.1.2 looks okay to me
15:35:42 <otters> yeah
15:35:45 <otters> but http://hackage.haskell.org/packages/archive/kevin/0.1.2/kevin.cabal
15:35:55 <rwbarton> aha
15:36:10 <rwbarton> that looks fine here too but probably just because my browser is correctly guessing the encoding whereas yours is not
15:36:22 <otters> oh, there we go
15:36:28 <otters> yeah, I had chrome choose utf-8 instead of latin-1 and there you go
15:36:45 <brady> I am trying to cabal install yesod. On the way, an sqlite package is trying to install as well. The compilation of the sqlite package, I get the following error.
15:36:50 <brady> undefined reference to symbol 'pthread_mutexattr_settype@@GLIBC_2.2.5'
15:36:50 <brady> /usr/bin/ld: note: 'pthread_mutexattr_settype@@GLIBC_2.2.5' is defined in DSO /lib64/libpthread.so.0 so try adding it to the linker command line
15:36:50 <brady> collect2: ld returned 1 exit status
15:37:19 <brady> Any guidance would be much appreciated.
15:37:23 <rwbarton> maybe it would be nice if hackage would set a content encoding header on .cabal files
15:37:29 <otters> whose job is that
15:37:33 <rwbarton> since I imagine they are specified to be utf-8
15:37:37 <otters> because I'll do it if someone lets me in
15:37:47 <otters> I'm not doing anything this afernoon
15:37:50 <otters> after
15:37:56 <rwbarton> whoever runs hackage.haskell.org, I don't know who that is off-hand
15:39:20 <otters> wow, it's been up since 2006
15:39:44 * hackagebot snap-loader-static 0.9.0 - Snap: A Haskell Web Framework: static loader  http://hackage.haskell.org/package/snap-loader-static-0.9.0 (DougBeardsley)
15:40:24 <brady> One error line was omitted (b/c it looked like an IRC command): /lib64/libpthread.so.0: could not read symbols: Invalid operation
15:49:28 <rwbarton> how do I use cabal (the program) to install the dependencies for a package I want to build but not install?
15:49:44 * hackagebot snap-loader-dynamic 0.9.0 - Snap: A Haskell Web Framework: dynamic loader  http://hackage.haskell.org/package/snap-loader-dynamic-0.9.0 (DougBeardsley)
15:49:44 <hpc> --dependencies-only or something like that
15:49:47 <hpc> cabal install --help
15:49:50 <rwbarton> 'cabal configure' tells me about dependencies
15:49:51 <rwbarton> okay
15:50:14 <HairyDude> --only-dependencies
15:50:19 <rwbarton> yep
15:54:30 <rwbarton> so I'm trying to build rss2irc and its cabal file lists both base and haskell98 as dependencies
15:54:56 <c_wraith> rwbarton: fixing that is probably a matter of renaming some imports
15:55:12 <rwbarton> and so I get an error "Implicit import declaration: Ambiguous module name `Prelude': it was found in multiple packages: base haskell98-2.0.0.0"
15:55:20 <rwbarton> which I found amusing... did this ever work?
15:55:24 <c_wraith> yes
15:55:33 <HairyDude> that is quite funny actually
15:55:34 <c_wraith> I think it stopped working as of GHC 7.2?
15:55:41 <c_wraith> somewhere around there
15:55:41 <rwbarton> that's the version I'm using
15:55:57 <c_wraith> base and haskell98 were made incompatible
15:56:09 <c_wraith> before that, they were compatible, so you could use both at once
15:56:22 <rwbarton> did you have to use both at once?
15:56:29 <HairyDude> so you'll need to patch it and poke the maintainer
15:56:35 <rwbarton> or did it somehow know that base's Prelude was the same as haskell98's Prelude?
15:57:14 <c_wraith> I'm not sure, actually
15:57:43 <HairyDude> maybe the ones that want haskell98 have {-# LANGUAGE Haskell98 #-}
15:57:45 <rwbarton> I fixed it by updating the source of defaultTimeLocale, yeah
16:01:06 <edwardk> hrmm is there any way to use DefaultSignatures on ghc 7.4 in a cabal file without making cabal warn about something or other? if I use -XDefaultSignatures it asks me to use extensions:, if I put it in extensions it complains it doesn't know the extension.
16:01:24 <edwardk> i guess i could try CPP and ghc options in the file itself
16:01:28 <edwardk> but thats blechy
16:01:28 <HairyDude> LANGUAGE pragma?
16:01:33 <kallisti> edwardk: that was my first thought
16:01:35 <kallisti> use CPP
16:01:40 <edwardk> well, i need to CPP around the LANGUAGE pragma
16:01:50 <kallisti> why does it ask you to use extensions when you enable defaultsignatures in the cabal file?
16:01:52 <mightybyte> How do you set up a package that uses the Paths_foo module created by cabal?
16:02:05 <edwardk> or use ghc-options, but even then i need to cpp around it anyways
16:02:10 <kallisti> edwardk: how can you conditionally use defaultsignatures in the first place? sounds like you'd need CPP to begin with.
16:02:19 <edwardk> er OPTIONS_GHC
16:02:49 <mauke> mightybyte: you just use it
16:02:53 <HairyDude> good old {-# OPTIONS_GHC -fglasgow-exts #-}
16:02:56 <edwardk> kallisti: well, right now i just have if impl(ghc >= 7.4) in the cabal file and set the extensions there
16:03:04 <edwardk> HairyDude: *shudder*
16:03:31 <mightybyte> mauke: When I do "cabal sdist" I get this:
16:03:33 <kallisti> edwardk: right but I mean, when you actually make use of the extension, won't you need to use CPP anyway to conditionally use it based on GHC version?
16:03:36 <edwardk> i suppose i can just let cabal warn my users, but it annoys me that there is no way to shut it up
16:03:39 <edwardk> yeah
16:04:04 <edwardk> i already have to use CPP, but using CPP to turn on or off language pragmas strikes me as awkward behavior, given that CPP itself is a language pragma
16:04:07 <mightybyte> "cabal: Error: Could not find module: Paths_foo with any suffix: ..."
16:04:18 <kallisti> so the issue isn't really that you need to enable CPP, it's that you don't want to conditionally use LANGUAGE pragmas specifically.
16:04:22 <kallisti> right. okay.
16:04:39 <mauke> mightybyte: is your code online somewhere?
16:04:47 <kallisti> it's... -shrug- it seems like the best solution to avoid warnings and still get the behavior you want.
16:04:56 <edwardk> and i'd rather have the extension listed in the cabal file, because using other-extensions: CPP   and if impl(ghc >= 7.4) extensions: DefaultSignatures      means that when and if cabal is fixed to properly check other-extensions i won't be lying ;)
16:05:11 <mightybyte> mauke: Yeah.  https://github.com/mightybyte/snaplet-postgresql-simple
16:05:26 <kallisti> oh I didn't know that as going to be added to cabal
16:05:35 <edwardk> yeah i'm going that route, which means i'll be disabling the other-extensions listing  in the .cabal file, since the only thing i can do there is lie or get yelled at
16:05:38 <edwardk> just makes me sad
16:05:42 <kallisti> I've always used LANGUAGE pragmas.
16:06:15 <kallisti> seems like the correct behavior for cabal would be to actually parse LANGUAGE pragmas as well as the cabal file.
16:06:20 <kallisti> to check extensions.
16:06:56 <edwardk> kallisti: well, the issue with extensions is it turned them on in every module, so they added other-extensions: which tells you a list of what LANGUAGE pragmas are used by modules
16:07:07 <edwardk> but cabal is pretty picky about which of those it accepts
16:07:14 <kallisti> ah okay.
16:07:42 <edwardk> i think its kind of silly that those are baked into cabal and not updateable. if they were something that could be send like the package list, then cabal wouldn't fall out of date on those warnings
16:07:52 <edwardk> er that could be sent
16:08:05 <mightybyte> mauke: It all builds and works properly.  It's just "cabal sdist" that complains.
16:08:33 <mauke> cabal: cannot configure snaplet-postgresql-simple-0.1. It requires snap ==0.9.*
16:08:34 <edwardk> i understand that there is some type safety gained by having most of them parseable in an ADT inside cabal, etc. just being able to send it a list of new extensions would save a lot of warnings
16:08:35 <mauke> There is no available version of snap that satisfies ==0.9.*
16:08:43 <mightybyte> I just uploaded it.
16:09:54 * kallisti has never been convinced by the argument that CPP is inherently non-Haskell-like
16:10:21 <kallisti> ...as an aside. I don't mean to imply that you think so in this circumstance.
16:10:25 <youseeli> hi room~i need some help~~i setup the haskell platform ghc7.4.1 and cabal 0.14 on windows system with minGw
16:11:04 <youseeli> when  cabal install download get error message
16:11:08 <edwardk> i don't mind using CPP to patch over library versioning, etc.
16:11:12 <mauke> holy dependencies, batman
16:11:16 <youseeli> E:\>cabal install download
16:11:16 <youseeli> Resolving dependencies...
16:11:16 <youseeli> Configuring download-0.3.2...
16:11:16 <youseeli> cabal: Bad header file: download.h
16:11:16 <youseeli> The header file contains a compile error. You can re-run configure with the
16:11:17 <youseeli> verbosity flag -v3 to see the error messages from the C compiler.
16:11:17 <youseeli> cabal: Error: some packages failed to install:
16:11:17 <youseeli> download-0.3.2 failed during the configure step. The exception was:
16:11:18 <youseeli> ExitFailure 1
16:11:33 <edwardk> youseeli: please use hpaste.org or something rather than flood
16:11:38 <barrucadu> Did you try running it with -v3 to see the error messages from the C compiler?
16:12:11 <mightybyte> mauke: Heh :)  It's not the worst package out there.
16:12:24 <mauke> this may take a while
16:12:43 <mightybyte> I can wait
16:13:18 <youseeli> cbits/download.h:49:15: error: 'MAXHOSTNAMELEN' undeclared here (not in a
16:13:18 <youseeli> function)
16:13:18 <youseeli> cbits/download.h:93:1: error: expected '=', ',', ';', 'asm' or '__attribute__'
16:13:18 <youseeli> before 'FILE'
16:13:18 <youseeli> cbits/download.h:124:1: error: expected '=', ',', ';', 'asm' or
16:13:18 <youseeli> '__attribute__' before 'typedef'
16:13:26 <rwbarton> ...
16:13:30 <mightybyte> mauke: I tried adding dist/build/autogen to hs-source-dirs and that seemed to solve the immediate problem, but then it gave me another warning about not depending on that location and that hackage would reject the package.
16:13:41 <mightybyte> ...which kind of defeats the purpose.
16:14:10 <youseeli> with -v3 show errors like that
16:16:21 <kallisti> youseeli: based on the fact that you're on Windows and download installs fine for me on linux, I'm guessing you're missing some C library dependency. cabal can only cover Haskell dependencies, not system library dependencies.
16:16:26 <youseeli> what can i do??help me please
16:17:53 <kallisti> #include <sys/param.h> /* MAXHOSTNAMELEN */
16:17:59 <kallisti> here's the header you're likely missing.
16:18:02 <kallisti> in download.h
16:18:35 <youseeli> i setup full mingw and msys
16:19:11 <aristid> youseeli: you probably just want to download an HTTP URL, right?
16:19:19 <kallisti> that doesn't imply that you have every C library dependency possible.
16:19:36 * kallisti isn't sure what library sys/param.h comes from
16:20:08 <mauke> probably the OS
16:20:13 <youseeli> yes ..i want to fetch some webpage..some one tell me the package download can do it
16:20:32 <rwbarton> well on debian it comes from 'libc6-dev' so...
16:20:40 <kallisti> so then maybe download just isn't Windows compatible?
16:20:41 <aristid> youseeli: if you have installed the haskell platform, you might be able to use HTTP instead, which comes with it
16:20:47 <kallisti> youseeli: are you installing download within a mingw shell?
16:22:23 <youseeli> hum..i add mingw path to system "path"
16:22:36 <kallisti> path isn't used to find libraries and header files.
16:22:37 <youseeli> and i can use linux command in cmd
16:22:42 <kallisti> youseeli: yes
16:22:45 <youseeli> like netstat and ls
16:22:46 <kallisti> try open up a mingw shell
16:22:51 <kallisti> and installing download from there.
16:23:30 <youseeli> well now i install it in cmd . then i get the message
16:23:31 <aristid> kallisti: what's wrong with just using HTTP?
16:23:48 <kallisti> maybe I'm mising something here, what would HTTP fix?
16:23:58 <kallisti> oh you mean the package.
16:23:59 <aristid> kallisti: it should build on windows.
16:24:01 <kallisti> sure you could use that.
16:24:02 <aristid> yes.
16:24:24 <youseeli> kallisti : install in mingw shell windows you mean?
16:24:33 <kallisti> in my quest to fix the problem at hand, I hadn't considered the better solutions. :P
16:24:36 <aristid> download is more flexible, but i'm not sure if that flexibility is needed in his case
16:24:50 <kallisti> youseeli: I mean open up the mingw shell program, in Windows, and do the installation in that environment.
16:24:58 <kallisti> where you're likely to have libc headers.
16:25:15 <youseeli> i does not work
16:25:24 <youseeli> it does not work
16:25:32 <youseeli> same error message
16:26:04 <kallisti> oh it looks like mingw actually doesn't use libc at all.
16:26:09 <kallisti> er glibc rather
16:26:14 <kallisti> it uses msvcrt. makes sense.
16:26:32 <mightybyte> mauke: Still building?
16:26:35 <kallisti> yeah you'll just want to use a different library. like HTTP, as aristid was saying.
16:26:39 <kallisti> `hackage HTTP
16:26:41 <kallisti> @hackage HTTP
16:26:42 <lambdabot> http://hackage.haskell.org/package/HTTP
16:26:43 <mauke> mightybyte: just finished and reproduced the problem
16:27:16 <mightybyte> Great.  I went out, ordered dinner, came back, and ate in the same amount of time. :)
16:27:46 <kallisti> youseeli: ^  install and use that instead.
16:28:10 <youseeli> kallisti: i installed http package
16:28:34 <youseeli> success the package "http" can do it too?
16:28:40 <kallisti> yep.
16:28:50 <aristid> youseeli: HTTP (not http), but yes
16:30:22 <DMcGill> Why does Map have a Traversable instance but Set doesn't?
16:30:51 <jmcarthur> DMcGill: because the values in a Map don't have an Ord constraint on them like those of Set do
16:31:03 <rwbarton> in 'Set s' s is more like the k in 'Map k a' than the a
16:31:13 <youseeli> ok..let me try it .thx kallisti and aristid.
16:32:36 <parcs`> so when will 'base' be augmented by the power of ConstraintKinds
16:33:01 <c_wraith> probably never
16:33:07 <ben> If I say data Bit = Zero | One, can I make that an instance of Num where 0 or 1 :: Bit works but 2 :: Bit is a compile time error?
16:33:28 <mauke> mightybyte: argh, such a stupid issue
16:33:37 <mightybyte> Yeah
16:33:38 <c_wraith> ben: not compile-time
16:33:39 <mauke> mightybyte: remove it from exposed-modules
16:33:43 <mightybyte> Oh, really?
16:33:45 <ben> all right
16:34:30 <mightybyte> Let's see...
16:36:46 <mightybyte> mauke: If I do that, then I get a linker error when I build the example.
16:37:07 <mightybyte> ("ghc --make Site.hs" from the example directory)
16:38:08 <mauke> ah, I see
16:38:39 <rwbarton> {-# RULES fromIntegral 2 :: Bit == ??? #-}
16:38:55 <rwbarton> terrible idea i guess
16:39:13 <mauke> mightybyte: list it in other-modules:
16:39:14 <kallisti> there should be a compiletimeerror constant. :P
16:39:27 <rwbarton> what if the RHS of the rule is just not in scope
16:39:45 * hackagebot bound 0.2.1 - Haskell 98 Locally-Nameless Generalized de Bruijn Terms  http://hackage.haskell.org/package/bound-0.2.1 (EdwardKmett)
16:39:54 <DMcGill> could GADTs do it?
16:40:31 <rwbarton> you can't really do this legitimately
16:40:44 <DMcGill> I suppose not actually, as things like user input would be a problem
16:40:49 <rwbarton> yeah
16:41:39 <DMcGill> if you defined your own Peano integers with their literals, that might work
16:42:02 <DMcGill> (that is a terrible, terrible idea)
16:42:48 <mightybyte> mauke: Awesome, that works.  Thanks.
16:43:40 * illissius wonders if evaluate . unsafePerformIO = id and unsafePerformIO . evaluate = id
16:44:51 <illissius> seems like they would be...
16:46:46 <ski> the latter one sounds like it could be sensible -- i wouldn't rely on the former, though
16:48:56 <bitonic> illissius: well, to begin with the first one has a different type sig
16:49:13 <bitonic> illissius: so we can rule that out
16:49:46 * hackagebot snaplet-postgresql-simple 0.1 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.1 (DougBeardsley)
16:49:46 <ski> ?
16:50:01 <bitonic> @type evaluate . unsafePerformIO
16:50:02 <lambdabot> Not in scope: `evaluate'
16:50:02 <lambdabot> Not in scope: `unsafePerformIO'
16:50:13 <illissius> :t evaluate . unsafePerformIO
16:50:14 <lambdabot> Not in scope: `evaluate'
16:50:15 <lambdabot> Not in scope: `unsafePerformIO'
16:50:15 <illissius> evaluate . unsafePerformIO :: IO b -> IO b
16:50:18 <bitonic> well. it's going to be `forall a. IO a -> IO a'
16:50:24 * applicative was given an enigmatic half-hebrew captcha by freenode's web page IncyHo ויחפרו]
16:50:28 <bitonic> much less polymorphic than `id'
16:50:51 <ski> well, that's a possibly type for `id'
16:51:15 <kallisti> so then reverse = id
16:51:19 <bitonic> ski: yeah but that `=' is inappropriate.
16:51:22 <kallisti> because [a] -> [a] is a possible type of id.
16:51:26 <ski> bitonic : i don't think so
16:51:56 <bitonic> ski: uhm. so we're arguing about what equality is when talking about haskell functions
16:52:00 <rwbarton> ...
16:52:03 <illissius> bitonic: the important thing isn't whether I can use evaluate . unsafePerformIO to implement id, it's whether their behaviour is the same where they are both defined
16:52:11 <unnali> :t id :: [a] -> [a]
16:52:13 <lambdabot> forall a. [a] -> [a]
16:52:32 <bitonic> illissius: you can't
16:52:33 <ski> bitonic : i interpret `evaluate . unsafePerformIO = id' as meaning the same as `evaluate . unsafePerformIO = (id :: IO a -> IO a)', given a type `a'
16:52:43 <kallisti> well unsafePerformIO has no well-defined semantics to begin with.
16:53:12 * ski is assuming `unsafePerformIO . return = id'
16:53:13 <bitonic> illissius: sorry, I read "the important thing is" :P
16:54:01 <bitonic> ski: ok, I interpreted it differently. they're not the "same" function to e
16:54:03 <bitonic> *to me
16:54:31 <rwbarton> people say things like "join . return = id" all the time, it's not intended that the most general types of the two sides are the same necessarily.
16:54:31 <jonkri_> i'm trying to make a computation in a custom monad, and i want it to stop what it's doing after three seconds and, like, return. i'm trying to use forkIO, throwT, and ErrorT, but i can't seem to make it work. any other part of the haskell api i could look into? :)
16:55:08 <kallisti> jonkri_: sounds like you want timeout
16:55:29 <kallisti> http://hackage.haskell.org/packages/archive/base/4.2.0.0/doc/html/System-Timeout.html
16:55:36 <rwbarton> ski: why wouldn't evaluate . unsafePerformIO = id
16:55:54 <illissius> anyway if I have y = unsafePerformIO x, that means x will be executed when y is evaluated. then if I have z = evaluate y, that means y will be evaluated when z is executed. end result: x is executed when z is executed. so I think it holds.
16:56:12 <rwbarton> because the compiler might speculatively evaluate the argument to unsafePerformIO?
16:56:29 <jonkri_> kallisti: i'm not sure that works. a) the computation to produce the value i want is not an io computation, and b) i want to return the value as-is even if the computation times out
16:56:50 <kallisti> jonkri_: return makes a pure value into an IO computation, so that's irrelevant.
16:56:56 <illissius> I don't think anyone's written down a semantics for unsafePerformIO, but it does need to be well-behaved in some sense to be useful. and it *is* useful
16:56:57 <rwbarton> jonkri_, you will have to make it an IO computation
16:56:59 <kallisti> the fact that you want the computation to be sensitive to its execution time requires IO.
16:57:01 <ski> rwbarton : afaics, that's assuming a specific operational semantics. i'm taking `unsafePerformIO ma' to come with a precondition that `ma = return a' for some `a', and in that case the whole application is equal to `a'
16:57:27 <jonkri_> rwbarton: it's not possible. it's a MonadIO? :)
16:57:35 <ski> rwbarton : in `evaluate . unsafePerformIO' we can't claim this precondition is always holding
16:57:40 <rwbarton> MonadIO m means you can lift IO operations into m
16:57:44 <Catnaroek> @pl f x = \n -> g n >>= x
16:57:44 <lambdabot> f = flip ((>>=) . g)
16:57:58 <rwbarton> IO actions I should say
16:58:07 <rwbarton> but timeout is not an IO action, it's some kind of higher operator on IO actions
16:58:10 <rwbarton> @hoogle timeout
16:58:11 <lambdabot> System.Timeout module System.Timeout
16:58:11 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
16:58:11 <lambdabot> System.Event type TimeoutCallback = IO ()
16:58:18 <jonkri_> kallisti: the (pure) value is not the problem, the computation is
16:58:34 <ski> rwbarton : of course, when i say `ma = return a', i mean that the effect of executing `ma' is *observationally* the same as executing `return a', for some `a'
16:58:37 <Catnaroek> Is there no way to "bind" a chain of "a -> m b"?
16:58:48 <rwbarton> in general there is no way to "lift" timeout to Int -> m a -> IO (m a) with just a MonadIO m instance
16:58:48 <Catnaroek> I mean, without explicitly using a lambda.
16:58:55 <ski> Catnaroek : `(<=<)' and `(>=>)' ?
16:59:01 <rwbarton> ski, I see
16:59:03 <Catnaroek> ski: What are those?
16:59:11 <illissius> :t (<=<)
16:59:11 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
16:59:12 <ski> @type (<=<)
16:59:13 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
16:59:16 <illissius> favorite operator :)
16:59:21 <ski> @type (>=>)
16:59:22 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
16:59:33 <bitonic> ski: what does "observationally" mean? extensionally :P?
16:59:42 <Catnaroek> ski: Oh, pretty cool.
16:59:58 <ski> bitonic : yes, that's basically the same thing
17:00:00 <illissius> Catnaroek: they're pronounced 'fish' and 'backfish' :)
17:00:13 <Catnaroek> :D
17:00:15 <ski> (maybe there's some small technical difference, i can't recall)
17:00:24 <kallisti> jonkri_: not sure I understand.
17:00:25 <rwbarton> jonkri_: there's packages like monad-control which may or may not meet your needs
17:00:26 <bitonic> ski: ok
17:00:26 <jonkri_> kallisti: are you saying that it's not possible to have timeouts to any other kind of monad than io?
17:00:43 <Catnaroek> ski: Is the only difference the order of the arguments?
17:00:47 <ski> Catnaroek : also, you can turn `a -> m b' into `Kleisli m a b' and then use arrow composition
17:00:51 <ski> Catnaroek : yes
17:00:52 <kallisti> jonkri_: indeed
17:01:03 <Catnaroek> :D
17:01:19 <jonkri_> thanks rwbarton, i'll look into that
17:01:28 <Catnaroek> ski: Unfortunately, I do not understand arrows yet.
17:01:34 <ski> @type \amb bmc -> runKleisli (Kleisli amb >>> Kleisli bmc)
17:01:36 <lambdabot> forall a (m :: * -> *) b b1. (Monad m) => (a -> m b) -> (b -> m b1) -> a -> m b1
17:01:47 <kallisti> jonkri_: it may be possible to implement your own via monad-control
17:01:50 <Catnaroek> :O
17:01:52 <kallisti> but what monad do you need to run?
17:02:52 <tnks> I'm trying to learn a little more category theory to catch up with the explosion of duals/co-terms
17:03:17 <tnks> I understand "free monad" and "cofree comonad"
17:03:38 <tnks> but not sure if there's a "cofree monad" or a "free comonad"
17:03:44 <jonkri_> kallisti: my own, XmppConMonad
17:03:57 <tnks> in other words, I feel like "co-" is sometimes introduced as a term without a formalism.
17:04:16 <mm_freak> tnks: like in coffee?
17:04:27 <illissius> yeah, it's totally coconuts
17:04:36 <bitonic> tnks: co = flip all the arrows :)
17:04:42 <jonkri_> thanks to your both :) i'll try to see if i can find a work-around. it's just a silly problem that i have
17:04:48 <ski> illissius : yes, but since `unsafePerformIO' must come with a programmer-checked precondition, i wouldn't trust my operational instincts on `evaluate . unsafePerformIO' being ok (the compiler might take this, rewrite the program a bit, then assume that what is passed to `unsafePerformIO' is essentially pure, so that it can e.g. compute it more often or less often than you expect) -- i wouldn't even by sure about `unsafePerformIO . evaluate', t
17:04:55 <kallisti> jonkri_: one option is to use lifted-base and implement timeout yourself (you could even submit it as a patch to lifted-base). An easier way may be to just run the monad explicitly and then wrap the result again.
17:05:09 <tnks> bitonic: I've seen the arrow-flipping explanation, but it's a little loose.
17:05:15 <ski> (the cut off part at the end was "-- i wouldn't even by sure about `unsafePerformIO . evaluate', though this one appears more benign to me")
17:05:18 <tnks> it kind of works for monad/comonad.
17:05:21 <tnks> but what about free?
17:05:28 <tnks> there's no type for free, is there?
17:05:32 <rwbarton> tnks: the universal property for a cofree comonad is dual to the one for a free monad
17:05:45 <mm_freak> tnks: it's not loose, if you view it in the context of category theory, where "arrow" has a precise meaning
17:06:01 <tnks> mm_freak: I agree with that.
17:06:23 <tnks> so now my next step would be to understand what "free" really means in category theory with respect to arrows that can be flipped.
17:06:33 <ski> tnks : the basic idea is that you have a concept which is sensible to consider in *any* category, then that concept has a dual which is also sensible to consider in any category
17:07:00 <Haskell_chap> hello all
17:07:16 <ski> tnks : e.g. we know what a "categorical product" is in any category, hence by duality, we know what a "categorical coproduct" is in any category
17:07:18 <tnks> ski: that makes sense for most of the duals I've encountered.
17:07:20 <rwbarton> free means that giving a monad homomorphism Free f -> m is the same as giving a functor homomorphism (natural transformation) f -> m
17:07:20 <kallisti> jonkri_: I assume you have some kind of "run" function. why not just run the monad explicitly within the timeout computation and extract the result with liftIO.
17:07:36 <ski> tnks : or take "monomorphism" vs. "epimorphism", which are also dual concepts
17:07:43 <illissius> ski: I should probably restrict my wondering to "as implemented by GHC". :) There's a separate function, unsafeInlinePerformIO or something similarly named, which you can use if you're *really really really* sure that the argument is actually pure. Otherwise for regular unsafePerformIO GHC makes all kinds of precautions that the argument is opaque to the optimizer, doesn't get evaluated by more than one thread, etc.
17:07:52 <rwbarton> whereas cofree (comonad) means that giving a comonad homomorphism w -> Cofree f is the same as giving a natural transformation w -> f
17:08:34 <Haskell_chap> I need to know how to get access to Functional Programming with Miranda by Ian Holyer OR Introduction to Functional Programming by Bird and Wadler
17:08:45 <ski> tnks : one of the most important ideas here is that of opposite category. if we have any category `C', then we can form the opposite category `C^op', which has the same objects as `C', but morphisms "going in the opposite direction"
17:08:51 <Haskell_chap> Thanks in advance
17:08:58 <tnks> this is all great; now I need to see if this sinks in.
17:09:44 <ski> tnks : e.g. take the category `Set' with e.g. objects `|N' and `|Z', and an inclusion morphism (function) which maps each natural number in `|N' to the corresponding number as an integral number in `|Z'
17:10:08 <ski> tnks : we can write this morphism as `iota : |N >---> |Z'
17:10:47 <tnks> ski: I'm following you thus far, I think.
17:10:50 <ski> tnks : now, in the opposite category, `Set^op', the objects are still sets, but the morphisms are morphisms of `Set' "going in the opposite direction"
17:10:59 <edwardk> hrmm, can someone who is familiar with cabal test tell me what the heck i am doing wrong in https://github.com/ekmett/bound ?
17:11:19 <kallisti> no, but I can pretend I know a lot about cabal.
17:11:19 <edwardk> i tried to add cabal test support to run main from examples/Simple.hs and i get some rather unhelpful reporting from cabal
17:11:21 <ski> tnks : what this means is that for each morphisms, like `iota', in `Set', that morphism is also a morphism of `Set^op', but the source and domain are flipped
17:11:25 <edwardk> so i have no idea what i'm doing wrong
17:11:42 <tnks> rwbarton: I think your explanation might have gotten to a good way of understanding why "cofree"
17:11:54 <rwbarton> well, it's the definition of cofree :)
17:12:14 <kallisti> edwardk: why kind of unhelpful reporting?
17:12:30 <ski> tnks : so in `Set^op' we'd have `iota : |Z >---> |N' -- and to emphasize that we think of this as `iota', but "turned around", we might write this morphism as `iota^op : |Z >---> |N' (or even `iota^op : |Z^op >---> |N^op')
17:12:34 <edwardk> >>> Test suite Simple: RUNNING…\n>>> Test suite Simple: FAIL\n>>> Test suite logged to: dist/test/bound-0.3-Simple.log
17:12:38 <edwardk> which is also the contents of that file ;)
17:13:40 <ski> tnks : now, note that `iota' is a monomorphism in `Set' (because it's an inclusion/injection, and every such morphism in `Set' is a monomorphism)
17:14:03 <rwbarton> tnks, you have to check that the formulas (definitions in Haskell) for Free and Cofree actually satisfy these universal properties
17:14:19 <jonkri_> kallisti: thanks for all your help. i'll consider my options :)
17:14:30 <ski> tnks : this automatically means that `iota', (i.e. `iota^op' with the explicit notation) seen as a morphism in `Set^op' is an *epi*morphism (because "epimorphism" is the dual concept of "monomorphism")
17:15:11 <kallisti> edwardk: hm, it's not printing "Unexpected result: "?  interesting.
17:15:19 <ski> tnks : this holds generally : any time you have an instance of a concept "foo" in a category `C', that instance, seen as living in the category `C^op' instead, is an instance of the concept "cofoo" (in `C^op')
17:15:31 <ski> tnks : did i lose you yet ?
17:15:43 <tnks> ski: I think a little.
17:15:44 <kallisti> edwardk: maybe try stderr?
17:15:52 <tnks> mostly parsing the English.
17:16:07 <nyingen> Is there a function like 'read' that has a type like :: Read a =>  String -> Maybe a ?
17:16:08 <tnks> commas, parenthises, etc.
17:16:24 <tnks> maybe this would be a good SO question.
17:16:27 <ski> tnks : what dualizing a categorical concept means is "turn all the arrows around" .. and this is exactly what we do when we go from a category `C' to the opposite category `C^op'
17:17:21 <edwardk> gah got disconnected
17:17:23 <edwardk> any ideas?
17:17:29 <edwardk> heya copumpkin
17:17:36 <kallisti> edwardk: so it's not display stdout at all?
17:17:41 <edwardk> kallisti: nothing
17:17:47 <kallisti> try stderr and see if that works. that's about all I've got for ideas. :P
17:17:58 <edwardk> i see nothing, so how?
17:18:06 <nyingen> I have something like data Foo = Bar | Baz | ... (20 of these), and I want to parse strings into these data constructors easily
17:18:14 <edwardk> i just typed cabal configure --enable tests; cabal test
17:18:23 <ski> tnks : commonly, concepts "foo" that we dualize makes sense in any category `C', and therefore the dual concept "cofoo" makes sense in the dual category `C^op' -- but we know that `(D^op)^op = D' for any category `D' so this means that "cofoo" makes sense in any category `D'
17:18:41 <edwardk> and the program if it runs will print
17:18:43 <jonkri_> kallisti: i just noticed that Control.Exception.Lifted was already in use >_< :D
17:18:48 <jonkri_> problem solved
17:18:54 <edwardk> so i'm wondering if cabal is just not finding it, not building it or is otherwise doing something stupid
17:19:06 <kallisti> based on the output it looks like it's running it.
17:20:25 <ski> tnks : so really, that "if \"foo\" makes sense to consider in any category then \"cofoo\" makes sense to consider in any category" depends on that fact that the definition of what a category is is a *self*-dual concept : if you take the definition of what a category is, and turn all the arrows around, you'll end up with basically the same definition (though `dom' and `cod' have been interchanged, and composition is defined the other way around
17:21:10 <edwardk> hah, i think i got it to work by adding myself as a build-dependency
17:21:11 <edwardk> odd
17:21:13 <Catnaroek> Is there anything like forM_, but which works on a Maybe instead of a list?
17:21:21 <kallisti> edwardk: oh...
17:21:46 <kallisti> the examples in the user guide don't list themselves as dependencies
17:21:47 <edwardk> https://github.com/ekmett/bound/blob/master/bound.cabal#L124 worked
17:21:56 <Catnaroek> I mean, short for (forM_ . maybeToList).
17:22:03 <edwardk> the examples also don't do squat
17:22:13 <rwbarton> Catnaroek: Data.Foldable.forM_
17:22:55 <Catnaroek> Oh.
17:23:07 <edwardk> well, travis-ci built and ran the test for me at least
17:23:15 <edwardk> http://travis-ci.org/#!/ekmett/bound/L104
17:23:18 <Catnaroek> Why does Control.Monad.forM_ work only on lists, then?
17:23:19 <Catnaroek> grrrr
17:23:30 <ski> Catnaroek : hysterical raisins
17:23:35 <edwardk> Catnaroek: historical nonsense and its part of the traditional prelude
17:23:40 * kallisti would expect the library itself to be an implied dependency of its test-suites.
17:23:43 <jmcarthur> i imagine for the same reason that Prelude.map only works on lists
17:23:46 <Catnaroek> Oh, that is what "hysterical raisins" means.
17:23:54 <ski> jmcarthur : though `map' was `fmap' in 1.4, iirc
17:24:19 <geekosaur> originally a humorous misreading
17:24:20 <edwardk> jmcarthur: to be fair i don't think Foldable/Traversable were defined back then
17:24:40 <ski> edwardk : yes
17:24:42 <edwardk> but map vs fmap was a crime against humanity
17:24:42 <Catnaroek> Unfortunately, since I am not a native English speaker (and my spoken English is actually bad), I fail to see the point in these plays on words.
17:24:43 <jmcarthur> i was trying to imply something other than that it was for historical reasons
17:24:46 <geekosaur> and yeh, a lot of stuff in the prelude is insufficiently polymorphic mainly because the PTB decided that the correct definitions produced lousy error messages
17:25:02 <Catnaroek> PTB?
17:25:06 <geekosaur> powers that be
17:25:08 <Catnaroek> Oh.
17:25:10 <edwardk> i'm not sure ski is a native english speaker either, but he's a little odd ;)
17:25:11 <jmcarthur> the reason, i think, was that the more general version was seen by some as harder to understand for newbies
17:25:27 <kallisti> I used to be a native english speaker, then I learned Haskell..
17:25:32 <Catnaroek> I already hate map/fmap...
17:25:41 <edwardk> i speak haskell with a slight lisp
17:25:44 <ski> Catnaroek : sorry, "hysterical raisins" is an old well-known travesty of "historical reasons" -- so in-grained that i didn't even think about it when writing it
17:25:50 <geekosaur> admittedly, back before ghc 6.8 or so the error messages produced by ghc for something that polymorphic could be quite difficult to untangle
17:25:52 <Catnaroek> Oh, hehe.
17:25:54 <Catnaroek> Ew, Lisp, no.
17:26:03 <ski> Scheme is nice :)
17:26:09 <Catnaroek> Well, only Scheme.
17:26:16 <kallisti> I speak Haskell with a slight... perl? I don't even know.
17:26:18 <Catnaroek> But Common Lisp, oh, god, that is...
17:26:18 <ski> (and Scheme is a Lisp)
17:26:25 <Ralith> a language you don't know?
17:26:39 <Catnaroek> lol I wish.
17:26:47 <Iceland_jack> Ah, Lisp hate
17:26:48 <Ralith> lucky day!
17:27:34 <ski> edwardk : why thank you, good sir :)
17:29:48 <Catnaroek> Is there any way to say import everything from a module except this name?
17:30:11 <rwbarton> import M hiding (x)
17:30:15 <Catnaroek> Nice. Thanks.
17:30:29 <edwardk> ok, test suite works with its ever so complicated single test
17:30:37 <ski> tnks : one thing about "arrow-flipping explanation" is that you have to keep track of which arrows corresponds to CT morphism arrows, which corresponds to CT exponentials, and which corresponds to functions/constructions which may take morphisms as input / given morphisms as output
17:31:19 <tnks> ski: okay, and you flip them all, or just certain ones?
17:31:30 <tnks> I feel flipping every arrow doesn't always work.
17:31:40 <edwardk> rwbarton: so when do you want to give that talk? =)
17:31:59 <edwardk> tnks: it doesn't work because some of those arrows are very different things =)
17:32:06 <rwbarton> oh that thing
17:32:19 <ski> tnks : just the ones corresponding to morphism arrows
17:32:22 <edwardk> rwbarton: trying to get something together for boston haskell for this summer
17:32:24 <rwbarton> edwardk: let me get back to you on that, i haven't thought about it in a long time
17:32:32 <edwardk> i can give a talk on bound, i just need another speaker
17:33:16 <ski> tnks : consider the categorical product construction : one part of this is that if we have two morphisms `f : T >---> A' and `g : T >---> B', we should be able to construct a morphism '<f,g> : T >---> A * B'
17:33:27 <shachaf> rwbarton: You should come give a talk at bay area haskell too!
17:33:38 <tnks> ski: okay, I'm with you.
17:33:59 <tnks> easy to make a product that way.
17:34:08 <ski> tnks : in Haskell, we could define `(&&&) :: Category (~>) => (t ~> a) -> (t ~> b) -> (t ~> (a,b))'
17:34:27 <tnks> okay, I see that too.
17:34:36 <edwardk> Category ?
17:34:55 <ski> er, well as a method in some class i meant :)
17:35:03 <edwardk> =)
17:35:17 <ski> (so skip the `Category (~>) => ', let's say that's already in scope)
17:35:52 <ski> (=
17:35:58 <ski> tnks : now, when we're considering the dual, the coproduct, for each `f : A >---> P' and 'g : B >---> P' there should be a morphism `[f,g] : A + B >---> P'
17:36:01 <tnks> okay, although I don't understand what nit was just picked.
17:36:48 <ski> tnks : we have to realize that we only flip the morphism arrows here, so we get `(|||) :: (a ~> p) -> (b ~> p) -> (Either a b ~> p)'
17:36:56 <ski> but we don't try to flip the `->'s here
17:37:13 <ski> this is harder to keep track of, if we just have `->', instead of `~>' in here
17:37:22 <ski> @type either
17:37:24 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
17:38:15 <tnks> ski: thanks a lot, that helps explain why not every arrow
17:38:26 <ski> otherwise, if we dualize this again, one might naïvely think we'd get `((c -> (a,b)) -> (c -> b)) -> (c -> a)'
17:38:48 <ski> but also see
17:39:11 <Catnaroek> Oh, God, I hate the monomorphism destriction.
17:39:13 <ski>   app :: ArrowApply (~>) => (a ~> b, a) ~> b
17:39:14 <Catnaroek> restriction*
17:39:35 <ski> the outer `~>' here is a morphism arrow, but the inner one is really an exponential arrow
17:40:25 <ski> in CT-notation, `app : B^A * A >---> B' (or sometimes written `app : (A => B) * A >---> B')
17:40:46 <ski> the point is that this `^'/`=>' is conceptually different from the morphism arrow `>--->'
17:41:51 <tnks> ski: this is good stuff.
17:42:11 <tnks> I haven't encountered discussions of "exponentiation" arrows.
17:42:38 <ski> tnks : btw, if you wonder why i swapped between `(,)' and `Either' : this is because "flip every arrow" means flip *every* (morphism) arrow, *including* the ones which are hiding behind the categorical concepts of "categorical product" and "categorical coproduct"
17:43:11 <ski> tnks : in `Set', `B^A'/`A => B' is the set of all functions from the set `A' to the set `B'
17:44:47 * hackagebot bound 0.3.1 - Haskell 98/2010 Locally-Nameless Generalized de Bruijn Terms  http://hackage.haskell.org/package/bound-0.3.1 (EdwardKmett)
17:46:03 <tnks> I'm not sure I understand how to read `B^A'/`A => B'
17:46:13 <tnks> what's the "/"?
17:46:35 <shachaf> tnks: It means "or", just like English. :-)
17:47:02 <rwbarton> B^A and A => B are two notations used for the exponential object
17:47:39 <tnks> interesting.
17:47:39 <ski> tnks : in `Top', `T^S'/`S => T' is the topological space of all continuous functions from the topological space `A' to the topological space `B' -- however, this doesn't exist for all such spaces `A' and `B'
17:48:03 <tnks> ski: this is very interesting.
17:48:07 <ski> er, s/A/S/,s/B/T/
17:48:45 <ski> (the morphisms of `Top' are continuous functions between the objects, which are the topological spaces)
17:49:03 <Catnaroek> Is there a way to prevent my programs from importing the Prelude by default?
17:49:18 <rwbarton> there are two ways!
17:49:19 <ski> (tnks : since "/" wasn't quoted, it was part of the english, yes :)
17:49:26 <tnks> I should disclaim I know pretty much no topology, so that example might be lost on me.
17:49:54 <rwbarton> you can give an explicit Prelude import like import Prelude ()
17:50:03 <Catnaroek> Oh.
17:50:05 <Catnaroek> Nice.
17:50:19 <rwbarton> that will secretly still import things like Prelude.Num and Prelude.fromInteger used in desugaring various syntaxes
17:50:19 <Catnaroek> I will do that, because I am sick of the not polymorphic enough defaults.
17:50:26 <Catnaroek> Oh.
17:50:31 <rwbarton> or you can use the language extension NoImplicitPrelude
17:50:51 <ski> tnks : for vector/linear spaces in the category `Vect', you can at least have a space `K^U' of all linear transformations from the vector space `U' to the special vector space `K' corresponding to the field the vector spaces use as scalars (commonly this field is `|R' or `|C')
17:51:01 <rwbarton> and then 3 will mean fromInteger 3 for whatever fromInteger happens to be in scope! fun times.
17:51:26 <rwbarton> similarly do notation will use whatever (>>=) is at hand
17:51:37 <Catnaroek> Has anyone researched what explicit imports one should use to avoid the "not polymorphic enough" problem?
17:51:57 <shachaf> rwbarton: It won't really import them.
17:52:05 <rwbarton> well, right
17:52:06 <shachaf> You just won't be able to refer to them.
17:52:07 <ski> tnks : in any case, we can consider what it would mean for an object `C' to be an exponential object (usually written `B^A' / `A => B') of two given objects `A',`B', in any category
17:52:12 <shachaf> s/just //
17:52:25 <rwbarton> 3 will mean Prelude.fromInteger 3, but Prelude.fromInteger will give 'not in scope'
17:52:38 <rwbarton> as I understand it
17:52:44 <Catnaroek> I never use fromInteger explicitly anyway.
17:53:08 <ski> tnks : then it's another question of whether the exponential object of `A' and `B' exists or not (but if it does, it's "unique up to isomorphism" -- every other object which is also an exponential of `A',`B' is isomorphic to it)
17:53:59 <tnks> ski: interesting.
17:54:11 <tnks> I'm still trying to find a good intro Category book.
17:54:25 <tnks> hopefully with some sensitivity to non-mathematicians.
17:54:35 <ski> rwbarton : yes, meaning it works like a hygienic macro
17:55:36 <ski> rwbarton : however with `NoImplicitPrelude', those and that `do' will use whichever `(>>=)' is in scope means it behaves as an unhygienic macro
17:56:35 <tnks> actually, I have a PDF saved away, "Computational Category Theory" by Rydeheard and Burstall
17:56:46 <tnks> maybe that's a good start
17:57:52 <ski> you can try it and see how you like it
17:57:55 <ski> it uses SML, iirc
17:57:55 <mzero> @pl \f (a,b) -> f a b
17:57:56 <lambdabot> (`ap` snd) . (. fst)
17:58:39 <ski> tnks : iirc, there's a book (or two ?) called "Category Theory for Computer Scientists" or something like that
17:59:37 <tnks> that's Pierce's, I think.
17:59:44 <tnks> it's deceptively dense.
18:00:05 <tnks> I have that one, but feel another line of attack might be helpful.
18:01:18 <tnks> it would be really helpful if CS programs just taught this stuff as a first-class curriculum.
18:02:41 <tnks> actually, maybe Piece's book isn't so bad looking back at it now.
18:02:51 <tnks> I know a little more than I did when I first picked it up.
18:04:09 <Luke> what's a terse way to map a function over a list and return a [(input, output)]?
18:05:10 <unnali> @djinn (a -> b) -> [a] -> [(a,b)]
18:05:11 <lambdabot> Error: Undefined type []
18:06:49 <m3ga> > let l = [1,2,3] in zip l $ map (+ 1) l
18:06:51 <lambdabot>   [(1,2),(2,3),(3,4)]
18:06:56 <m3ga> Luke: ^^^^^^
18:07:40 * ski . o O ( "Documents as Categories" by William C. Wake in 1996-03-26 at <http://xp123.com/wwake/dissertation/model.shtml> )
18:08:05 * ski . o ( "Categories for Software Engineering" by José Luiz Fiadeiro in 2004(?) at <http://homepage.mac.com/fiadeiroj/jose/CATBook/> )
18:08:09 * ski . o O ( "Category theory in software engineering" (slides) by Steve Easterbrook in 2002 at <http://www.cs.toronto.edu/~sme/presentations/cat101.pdf> )
18:08:37 <ski> tnks : ^not directly introductions to CT, but might be interesting nonetheless
18:10:28 <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph f = arr id &&& f
18:10:30 <lambdabot>  Defined.
18:10:35 <parcs`> i just thought of something: currently, 'type State s = StateT s Identity'. wouldn't it be more convenient if 'type State s a = forall m. Monad m => StateT s m a'?
18:10:35 <ski> @let cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph f = f ||| arr id
18:10:36 <lambdabot>  Defined.
18:10:43 <ski> > ((2 ^) `graph`) `map` [0,1,2,3]  -- Luke
18:10:45 <lambdabot>   [(0,1),(1,2),(2,4),(3,8)]
18:11:10 <parcs`> that way, you can embed 'pure' State expressions within State expressions that are on top of IO
18:11:39 <parcs`> as it is, you have to use mapStateT (return . runIdentity) to turn State s a into Monad m => StateT s m a
18:11:56 <ski> parcs` : yes, the alternative is to provide `Monad m => State s a -> StateT s m a'
18:11:59 <unnali> > (\f -> map (first f . join (,))) succ [3,4,5]
18:12:02 <lambdabot>   [(4,3),(5,4),(6,5)]
18:12:24 <unnali> whoops, wrong way around
18:12:26 <unnali> > (\f -> map (second f . join (,))) succ [3,4,5]
18:12:28 <lambdabot>   [(3,4),(4,5),(5,6)]
18:12:42 <ski> > ((,) `ap` (2 ^)) `map` [0,1,2,3]
18:12:43 <lambdabot>   [(0,1),(1,2),(2,4),(3,8)]
18:13:28 <parcs`> ski: but it would be even better if you can directly embed it into any StateT s m a
18:13:36 <ski> > (fmap (2 ^) . join (,)) `map` [0,1,2,3]
18:13:38 <lambdabot>   [(0,1),(1,2),(2,4),(3,8)]
18:14:28 <ski> parcs` : yes, meaning the `Monad m => State s a -> StateT s m a' operation is basically `id'
18:14:50 <ski> parcs` : however, you'd probably want a `newtype', to avoid needless `ImpredicativeTypes'
18:15:01 <parcs`> is it not 'type State s a = forall m. Monad m => StateT s m a' because it requires RankNTypes?
18:15:08 <parcs`> ski: it doesn't require impredicative types
18:15:40 <ski> it does, if you e.g. use `sequence :: [State s a] -> State s [a]'
18:15:53 <parcs`> i see
18:16:39 <parcs`> well that sucks
18:17:27 <parcs`> well you can just avoid using the type synonym in that case
18:17:30 <ski> a `newtype State s a = MkState (forall m. Monad m => StateT s m a)' wouldn't be so bad, i think
18:18:31 <ski> (parcs` : it'd also require `Rank2Types' or `RankNTypes' if you used `State s a' in argument types, unless you wrapped in a `newtype')
18:18:42 <parcs`> a newtype would prevent direct embedding of a State expression into a arbitrary StateT expression, which is what i was going for
18:19:30 <ski> hm, maybe one question is whether `Monad m' would always be enough, here
18:20:05 <ski> parcs` : by "direct embedding" do you mean using one as the other ?
18:20:57 <ski> (hm, no "enough" is probably the wrong question)
18:23:05 <parcs`> ski: i mean being able to pass it as an argument to '>>='. eg 'foo :: State s a; bar :: StateT s IO a; bar = do ...; a <- foo; ....'
18:24:09 <ski> without saying something like `liftState foo' instead of `foo', *nod*
18:24:19 <parcs`> yeah
18:24:34 <ski> if `State s a' could be a subtype of `StateT s m a', that'd also work
18:25:09 <parcs`> i see what you mean about Monad m not being enough. for example you wouldn't be able to use 'fmap' without an added Functor constraint
18:26:26 <parcs`> i guess this brings more trouble than it's worth
18:26:37 <ski> hm, we'd have to implement `fmap :: (a -> b) -> ((forall m. Monad m => StateT s m a) -> (forall m. Monad m => StateT s m b))' .. which seems possible, given that we know `m' in the resuls is a monad, and thus has 'liftM'
18:26:59 <ski> so, i don't see a problem with that part, yet
18:27:52 <ski> (talking about implementing `instance Functor (State s)', here)
18:28:53 <parcs`> i mean 'fmap id (return ()) :: State s ()' doesn't typecheck because there is no Functor constraint on m
18:35:12 <shapr> Haskell_chap: Why do you want to use Miranda?
18:42:09 <parcs`> "The order of constructors of Map matters when considering performance. Currently in GHC 7.0, when type has 2 constructors, a forward conditional jump is made when successfully matching second constructor."
18:43:12 <parcs`> then shouldn't the 'Right b' data constructor come before the 'Left a' constructor in the 'Either' data type? right now 'Left a' is defined first
18:43:53 <parcs`> the same can be said for [a].. [] comes before :
18:44:18 <parcs`> and Maybe!
18:49:21 <ski> parcs` : whence ?
18:49:49 * hackagebot vector-clock 0.1.0 - Vector clocks for versioning message flows  http://hackage.haskell.org/package/vector-clock-0.1.0 (AlexandruScvortov)
18:51:06 <parcs`> http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/src/Data-Map-Base.html#Map
19:08:51 <triam> isn't it possible to overload a constant function for different types? class HasName a where name :: Bool ?
19:09:24 <parcs`> triam: do you mean class HasName a where name :: a ?
19:09:31 <parcs`> yes it's possible
19:10:18 <unnali> maybe you want `class HasName a where name :: a -> Bool', even if the value of `a' is disregarded.
19:13:52 <ski> (with `name :: a', `name' wouldn't be a function (apart from the case when `a' is a function type))
19:14:04 <geekosaur> triam: the exact thing you asked for is *not* possible, because it's not possible to figure out which one you want; the specific type has to be known at the call site.  (often, this thinko means you're expecting to do OOP; don't.  typeclasses are not OO.)
19:14:23 <parcs`> geekosaur: he left
19:14:28 <geekosaur> ah
19:14:38 <ski> "Ping timeout: 245 seconds"
19:21:46 <applicative> what do you mean, 'a constant function' triam ?
19:22:27 <kallisti> sounds to me like it means a single value aka "a zero-argument function"
19:22:40 <kallisti> in which case, yes, that is possible
19:22:43 <kallisti> > maxBound :: Bool
19:22:44 <lambdabot>   True
19:22:45 <applicative> oh wait I see, a constant.  foo :: a ; foo = foo is pretty polymorphic
19:22:46 <kallisti> > maxBound :: Char
19:22:48 <lambdabot>   '\1114111'
19:23:33 <kallisti> right, constant would be the best word.
19:23:54 <applicative> > mempty :: Int
19:23:55 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
19:23:56 <lambdabot>    arising from a use of...
19:24:05 <kallisti> > mempty :: Product
19:24:07 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
19:24:10 <kallisti> > mempty :: Product Int
19:24:11 <lambdabot>   Product {getProduct = 1}
19:24:13 <applicative> tthanks
19:24:22 <applicative> > mempty :: Sum Int
19:24:23 <lambdabot>   Sum {getSum = 0}
19:24:32 <applicative> > mempty :: Maybe Char
19:24:33 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
19:24:34 <lambdabot>    arising from a use o...
19:24:41 <applicative> hm, forgot about that
19:24:48 <applicative> skip Monoid
19:25:08 <applicative> > mempty ::  String
19:25:09 <lambdabot>   ""
20:39:53 * hackagebot monadio-unwrappable 0.3 - Reversibly allow monad transformer stacks to run in IO  http://hackage.haskell.org/package/monadio-unwrappable-0.3 (AndrewMiller)
20:57:17 <pakaran> Hi.
20:57:25 <pakaran> I'm a CS grad student learning haskell as a summer project
20:57:36 * Clint nods.
20:57:42 <pakaran> I'd like to do a toy example to see if I know the basics, but the more I think about it the more I wonder if it's even possible.
20:58:02 <pakaran> what I want to do is make an infinite list, without duplicates, of the composite numbers
20:58:10 <shachaf> Yes, it's possible.
20:58:39 <shachaf> Assuming "composite" means something like "non-prime integer > 2"?
20:58:43 <pakaran> just using the single case: an integer is a member of the list if it is the product of two integers greater than two
20:58:47 <pakaran> yes.
20:59:04 <pakaran> (1 is a unit, technically, on the basis that being composite means it has strictly more than one proper factor.
20:59:19 <pakaran> and 1 has no proper factors (factors less than itself)
20:59:20 <mauke> naive way:  filter isComposite [2 ..]
20:59:54 <shachaf> pakaran: That's why I said > 2. "technically"
21:00:05 <pakaran> but that way would (for example) add 12 or 30 to the list five or six times, each time it found a new factor.
21:00:18 <pakaran> and yes, i saw.
21:00:26 <mauke> what?
21:00:27 <pakaran> i was just making that clear because it's sometimes a point of confusion.
21:00:41 <shachaf> pakaran: If you're talking about mauke's example, you're wrong.
21:00:59 <pakaran> wow.
21:01:00 <shachaf> filter will only pick things out of the existing list.
21:02:05 <pakaran> so what i was thinking is something like...
21:02:24 <pakaran> raw-material = [1..]
21:03:02 <pakaran> heh, now i'm confusing myself, never mind
21:03:14 <pakaran> i can see i need to do more design and stuff
21:03:18 <pakaran> and thinking about corner cases
21:03:27 <pakaran> but i had *thought* that it could be done in less than five lines.
21:03:48 * BMeph_ is curious why there has been no comment on mauke's example...
21:04:14 <shachaf> BMeph_: ?
21:04:15 <pakaran> in a language with assignment it would be easy; I could cons each new item to the end of the list, using the old list as raw material
21:04:26 <pakaran> that was actually why i wanted to first try the list of primes...
21:04:52 <shachaf> I don't know what "raw material" means.
21:05:03 <BMeph> shachaf: Sorry; besides your comment, of course. :)
21:05:06 <pakaran> it seemed like a recursive definition along the lines of "x is in primes iff (x%p == 0 for all p in primes)" would work
21:05:06 <shachaf> But you won't gain much from learning Haskell if you keep tring to make it act like a language with assignment. :-)
21:05:15 <pakaran> erm, !=
21:05:25 <pakaran> yeah, i should step back and re-read a chapter in the tutorial
21:05:26 <mauke> you don't have a list of primes
21:06:19 <pakaran> sigh.
21:06:28 <ski> pakaran : iirc, you could simultaneously build a list `primes' and a list `composites', with `primes' more or less defined `[2 ..]' minus `composites', and `composites' defined as the product of `[2 ..]' with `primes', flattening and removing duplicates on the way
21:06:34 <pakaran> my goal for this project was in part to convince myself i was not, in fact, born with the wrong kind of brain for haskell
21:07:17 <pakaran> hmm
21:07:28 <ski> pakaran : for this to work, you'll have to "cheat" a bit with the first element to get it's "tail-chasing" to not succeed
21:07:45 <pakaran> and keeping the invariant that both lists are sorted in ascending order, so that searches can be done easily?
21:07:54 <ski> pakaran : exactly
21:08:24 <ski> you'll want a `merge' and a `difference' function which takes two sorted lists and returns a sorted list
21:08:25 <pakaran> hmm
21:08:52 <pakaran> yeah, i see how to do that
21:09:11 <ski> (since the lists are infinite, if they weren't sorted you wouldn't know when to stop looking for duplicates to remove, so that wouldn't terminate)
21:09:16 <pakaran> nod.
21:09:41 <pakaran> so the highest number seen so far can be an argument to the recursive call
21:10:31 <pakaran> one weird case: when the first element of both lists is the same, that element should be added, but NOT if that element has been added before in that, or any other, case.
21:10:42 <pakaran> oh!
21:10:52 <pakaran> just make the highest number yet added another argument
21:11:05 <ski> `primes' and `composites' should be defined directly in terms of each other, with no helper recursive function (other that then generic `merge',`difference', and possibly other generic functions like `map',`foldr',&c.)
21:13:09 <ski> pakaran : well, i think you can add as an invariant that the two lists don't contain duplicates
21:13:13 <pakaran> is a boolean function ismember(list,elt) to determine membership, immediately returning false if an element > elt is found, allowed?  or helpful?
21:13:46 <ski> so there's only three cases : `x < y',`x == y',`x > y' when merging. only in the middle case do you remove an element
21:13:52 <ski> @type elem
21:13:54 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
21:14:18 <ski> well, that's not taking advantage of sorted lists
21:14:25 <ski> > elem 3 [5 ..]
21:14:29 <lambdabot>   mueval-core: Time limit exceeded
21:14:43 <ski> pakaran : if you think you need it, you can define it
21:15:57 <lolcathost> ski: maybe that could work for a Seq?
21:16:33 <ski> pakaran : btw, mauke's suggestion is another way to generate the composites, in a less "origami"-way -- yet another way is doing sieve of eratosthenes with infinite lists
21:16:48 <ski> lolcathost : iirc, `Seq' doesn't work for infinite number of elements
21:18:49 <pakaran> hmm
21:18:54 <pakaran> i think i know what i want to do now, thanks
21:19:01 <ski> yw
22:09:59 <dmwit> come on, come on, somebody ask something crazy
22:10:45 <AfC> I think we should fix do syntax
22:11:18 <MasseR> What's wrong with do syntax?
22:12:02 <dmwit> do-blocks are too restrictive!
22:12:07 <dmwit> everything has to be in A-normal form
22:12:08 <dmwit> laaaaame
22:12:19 <dmwit> Somebody propose a way to infer which things need to be bound, quick!
22:13:32 <AfC> I find it really annoying *syntactically* to have to differentiate between `a <- getSomethingFromMondaic` and `let b = doSomtehingElse x y` in the same block.
22:13:38 <AfC> dmwit: (yes, that was just for you)
22:14:19 <dmwit> AfC: Yeah!
22:14:42 <dmwit> use that type inference
22:15:51 <AfC> In fact, as a beginner that boggled the mind. I understand the difference now, but coming from just about any imperative language that was really frustrating.
23:27:18 <startling> is there a way I can use $ in types? I almost remember a ghc extension/pragma/whatever that did that
23:27:32 <startling> I just want to get around a thousand nested parens
23:27:46 <shachaf> type a :$ b = a b
23:28:23 <shachaf> However, you probably don't actually want to do it.
23:28:45 <startling> yeah.
23:28:54 <startling> still, good to know
23:32:16 <startling> is there a function (arrow?) that takes an x and a function and returns (x, f x)?
23:32:23 <dmwit> type (:$) a = a -- ?
23:32:35 <dmwit> :t (id &&&)
23:32:36 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
23:32:50 <startling> dmwit: oh, didn't think of using id. thanks!
23:33:44 <dmwit> ?hoogle (a -> b) -> a -> (a, b)
23:33:44 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
23:33:45 <lambdabot> Control.Monad.Writer.Lazy listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
23:33:45 <lambdabot> Control.Monad.Writer.Strict listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
23:33:47 <shachaf> @ty ap (,)
23:33:49 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
23:34:14 <dmwit> ?. pl djinn (a -> b) -> a -> (a, b)
23:34:14 <lambdabot> f = ap (,)
23:34:16 <shachaf> More sensible when used infix, as in ((,) <*> ...)
23:34:56 <Lemon> (((x, f x), f (f x)), f (f (f x))) ...?
23:35:07 <dmwit> :t iterate
23:35:08 <lambdabot> forall a. (a -> a) -> a -> [a]
23:35:12 <dmwit> > iterate f x
23:35:13 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
23:35:18 <mikeplus64> @pl (\x -> ["hi #haskell", x])
23:35:18 <lambdabot> ("hi #haskell" :) . return
23:35:33 <dmwit> hi mikeplus64 :)
23:35:42 <Lemon> I mean, just in case startling wants more than a single level of this
23:36:02 <shachaf> Hah, take 2 . iterate f
23:36:05 <dmwit> Lemon: But being able to write f (f x) restricts the type of f.
23:36:17 <mikeplus64> dmwit: starting to think that : for cons is specifically for writing faces
23:36:21 <shachaf> dmwit: Sadly. :-(
23:36:53 <Lemon> iterate (+ 1) 0
23:36:55 <Lemon> > iterate (+ 1) 0
23:36:57 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
23:37:12 <startling> man
23:37:35 <startling> every time I ask a question here, I get a thousand different variations and generalizations
23:37:40 <startling> haskell's pretty cool like that
23:40:35 <startling> is there a way to get the "empty" version of a thing, like [] for lists? is this related to "monad with a zero", or would [] be the identity?
23:40:52 <shachaf> There's mempty and mzero and a few others.
23:41:07 <shachaf> It depends on what "the \"empty\" version of a thing" is even supposed to mean.
23:42:04 <startling> I suspect I need to do more reading
23:43:37 <Lemon> startling, read up on algebraic structures
23:44:54 <Lemon> I suspect you want the identity element of a Monoid
23:45:47 <startling> Lemon, that's mempty?
23:46:24 <Lemon> startling, is it what you want?
23:46:36 <startling> yep.
23:46:44 <Lemon> because mempty for lists should be [] with (++) as mappend
23:46:56 <startling> is that the identity element of a monoid? why is that the identity and not the zero?
23:47:07 <Lemon> iunnolol
23:47:20 <startling> alright. seems pretty arbitrary?
23:47:48 <alang> startling: what do you call the zero of a monad?
23:47:55 <alang> startling: monoid, sorry
23:47:58 <Lemon> "identity element" = "using it as one of the arguments to the operation will give you the identity function"
23:48:12 <alang> startling: the identity and zero of a monoid are usually 2 names for the same thing
23:48:19 <startling> alang, oh, okay
23:48:23 <Lemon> hence, (+ 0) = id
23:48:32 <startling> but for other things they're separate?
23:48:52 <startling> Lemon: right. or mappend mempty = id, right?
23:49:00 <startling> for Monoids
23:49:00 <Lemon> yes
23:49:12 <startling> thanks!
23:49:20 <Lemon> more specifically, mappend mempty = flip mappend mempty = id
23:49:27 <startling> mhm
23:49:59 <alang> startling: for rings (with unity), for example, you have a separate (multiplicative) identity and (additive) zero
23:50:24 <startling> alang, okay, that's where I was getting confused
