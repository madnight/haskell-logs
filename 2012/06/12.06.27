00:13:24 <srhb> If I need Haskell processes on two different servers to talk together, what are my options?
00:14:08 <srhb> Cloud Haskell?
00:14:21 <mauke> sockets
00:14:41 <Axman6> zeromq?
00:14:46 <Axman6> there's lots of possibilities
00:14:56 <startling> json?
00:15:04 <startling> and a wire I guess
00:15:07 <srhb> Hehe.
00:15:27 <srhb> Yes, I'm mostly thinking about high level interfaces, how about failure, etc. Just trying to gain an overview.
00:21:42 <startling> does haskell have something like twisted for python?
00:22:02 <Ralith> the ghc runtime, I believe
00:22:58 <startling> hmmm?
00:23:22 <startling> I guess I don't mean general asynchronicity -- i mean networking in particular
00:23:39 <shachaf> What about networking?
00:24:48 <dmwit> ?faq Can Haskell do networking?
00:24:49 <lambdabot> The answer is: Yes! Haskell can do that.
00:25:39 <srhb> And System.Event is baked in.
00:25:44 <srhb> (I think)
00:26:17 <shachaf> Mmm, baking.
00:26:34 * srhb has fresh cinnamon butter rolls in the oven
00:28:50 <srhb> startling: What is it you want the network to do? :-)
00:29:26 <shachaf> 1. Net 2. Work
00:29:28 <startling> srhb, is there an event-driven networking library for haskell that implements a large number of protocols?
00:29:36 <startling> hence "does haskell have something like twisted for python"
00:29:46 <startling> nothing specific, just idle curiousity
00:29:49 <shachaf> startling: Why do you want an event-driven networking library?
00:30:00 <srhb> You have events, and you have networking libraries.
00:30:08 <shachaf> Protocol implementations are all over the place.
00:30:13 <shachaf> It's certainly true that we could use more.
00:30:31 <srhb> I think you'll find that the abstraction level means you can use the same events over a large number of networking libraries.
00:35:32 <Obfuscate> srhb: In practice you need an event model built in to the networking library, for performance reasons (e.g. epoll/kqueue/iocp).
00:36:43 <shachaf> In practice using epoll/kqueue/iocp has little to do with the API you're using.
00:37:49 <srhb> I think the event library wil pick the one that's available.
00:40:25 <dmwit> I think the point here is that GHC's RTS includes an IO manager; hence something like Twisted is unnecessary; and additionally Ralith's answer from 20 minutes ago was spot-on.
00:40:57 <dmwit> You just use threads for everything.
00:41:09 <srhb> Hurray, threads!
00:41:09 <shachaf> I think startling has yet to specify what they're looking for out of "something like twisted".
00:41:29 <shachaf> If it's performance because of the "events=fast threads=slow" myth, then what dmwit said.
00:43:25 <startling> no, i'm just used to twisted and it's really nice having a thousand protocol definitions in a single library in obvious places
00:44:23 <shachaf> So you're asking whether there are a thousand network protocol implementations available?
00:44:26 <shachaf> Probably not. :-)
00:44:43 <dmwit> Oh, in that case the Haskell analog of Twisted is Hackage.
00:46:10 <srhb> Do the lightweight threads have anything to do with epoll/kqueue or is that only forkOS threads? Or am I confusing things in general?
00:46:39 <dmwit> You're confusing things, but only a tiny bit.
00:46:49 <srhb> :-) That's a start.
00:47:18 <dmwit> The GHC IO manage uses epoll or kqueue to decide which Haskell threads are ready to run.
00:47:30 <srhb> So, the "master thread" will use it?
00:47:31 <dmwit> And to pick a specific one to do IO.
00:47:39 <srhb> Ah
00:47:45 <dmwit> Right, there's a master thread that uses it.
00:48:11 <dmwit> And calls to the various networking/file access libraries actually go through the IO manager.
00:48:27 <srhb> Cool, so the short answer is I don't have to worry about it. :-)
00:48:35 <shachaf> Until you do, that is.
00:48:39 <dmwit> That's the idea, yeah.
00:49:15 <shachaf> Keep in mind that if the GHC runtime didn't do the whole epoll thing, you could still implement it yourself on top of lightweight threads.
00:49:26 <srhb> On top of them? How so?
00:49:31 <srhb> Wouldn't I need a whole new IO library?
00:49:32 <shachaf> Well, "with" them.
00:49:38 <shachaf> Right, but you could write one.
00:49:42 <srhb> Well, true. :P
00:50:08 <shachaf> Converting event-driven things to threaded things (and vice versa) is reasonably easy.
00:50:29 <shachaf> (You could implement cooperative threads by yourself, too, if you really wanted to.)
00:50:55 <srhb> I think I see how it would be done.
01:30:37 <srhb> Say I have a validator for some input.. Should I if valid input then doStuff else (loop around) or is a better method to return Either (or Maybe) ValidInput.. I'm not sure the latter approach really does give me anything, since the validator still needs to be correct in both cases. Am I just adding complexity by wrapping ValidInput around things?
01:31:11 <srhb> "how far to go" :-)
01:40:55 <danr> How can I make a flag in Cabal turn off generation of a particular executable?
01:41:00 <danr> in the .cabal-file, that is
01:53:29 <danr> thanks, I found it here http://www.haskell.org/haskellwiki/Cabal/Developer-FAQ#Conditional_compilation, buildable is what you want to set
02:05:03 <srhb> Does anyone know of an article explaining the transformation from having a state parameter passed around to actually using the State monad?
02:08:31 <shachaf> "the transformation"?
02:09:16 <srhb> I was under the impression that having a bunch of functions that are modifying the (game) world that each take a parameter world could more or less be translated algorithmically to using the State Monad. Is this a misconception?
02:10:03 <shachaf> Well, no, it's directly the same thing.
02:10:14 <shachaf> When you say State s a it's just a way of saying s -> (a,s)
02:10:28 <srhb> Ah.
02:10:34 <shachaf> I.e., something that takes a state and returns a new one.
02:10:37 <srhb> Right.
02:10:48 <shachaf> Do you have a general sense of monads?
02:10:55 <srhb> Ish. :-)
02:11:06 <shachaf> You should implement instance Monad (State s).
02:11:20 <quicksilver> srhb: part of the point of this transformation is not having to keep naming the state.
02:11:28 <srhb> Alright.
02:12:00 <Catnaroek> Hello. I want to reinstall GHC and the Haskell platform from source (I previously used the Debian packages, but attempting to get aptitude and cabal to coordinate seamlessly as a pain in the ass). Can I use GHC 7.4.2. with the Haskell platform?
02:12:04 <quicksilver> srhb: with explicitly managed state functions you end up with code like : \s -> let s0 = s + 6 in let s1 = s0 * 2 in let s2 = s1 - 1 in let s3 = .....
02:12:23 <quicksilver> srhb: (normally there is more interesting stuff in between the parts which modify the state.
02:12:23 <srhb> quicksilver: Yes, That's what I've experienced, so I thought now was a good time to clean it up.
02:12:47 <quicksilver> with a state monad that's do modify (+6); modify (*2); modify (subtract 1); ....
02:13:01 <quicksilver> so you don't have the name the state and you can't accidentally use an 'old' value of it
02:13:07 <quicksilver> which is a classic mistake in that kind of code.
02:13:15 <shachaf> quicksilver: Except when you're implementing (>>=)! :-)
02:13:19 <quicksilver> indeed.
02:13:25 <srhb> But it's general enough to not just work on primitives, right? I mean, my World is usually a record with several fields.
02:13:26 <quicksilver> and sometimes you end up naming it with "s <- get"
02:13:35 <shachaf> (There's a way to write (>>=) that threads the state backwards and then you get a weird monad.)
02:13:46 <quicksilver> srhb: right, but then you get to write your own neat combinators for modifying parts
02:13:50 <shachaf> srhb: There's one "state" type, but it can be a record.
02:13:54 <srhb> Ok. :)
02:14:06 <shachaf> For that matter, your primitives might not be "get" and "put" at all.
02:14:06 <quicksilver> srhb: and it reads like : do addACloud; moveTheSun; makeBirdsSing;
02:14:26 <quicksilver> where those operations are defined in terms of ways to get and change parts of the state.
02:14:33 <shachaf> There are probably sensible primitives for State MyWorld -- what quicksilver is saying.
02:14:33 <srhb> I think I will just finish a simple game in the "old style" then try to implement the State monad, and then try to transform it to use that.
02:14:39 <srhb> quicksilver: Right, that would certainly help a lot.
02:14:45 <quicksilver> once you've done a bit of that you start to appreciate lenses.
02:14:58 <quicksilver> (which are just tools to make it easy to write combinators which "modify" "part of" a record)
02:15:05 <srhb> I really haven't seen the bad thing about records yet, except for the namespacing issues.
02:15:54 <quicksilver> well records are only a notation for normal data types; there is nothing wrong with normal data types :)
02:16:03 <quicksilver> record *notation* doesn't scale well to nested data
02:16:13 <quicksilver> and it's annoying that record notation isn't first class.
02:16:23 <quicksilver> because it means some patterns are fiddly to abstract.
02:16:27 <srhb> I mean world { field = bar } isn't that bad, is it?
02:16:35 <quicksilver> no it's not, it's fine in itself
02:17:01 <quicksilver> world { field = field world { baz = bar } } is a bit annoying though
02:17:07 <srhb> Ok, true. :P
02:17:13 <quicksilver> note the weird way world/field repeat in an opposite order
02:17:17 <srhb> Yeah
02:17:29 <quicksilver> and now try to abstract out "field"
02:17:37 <quicksilver> (hint, you can't - fields aren't first class)
02:17:40 <srhb> Right.
02:17:53 <srhb> OK, so good project, two things to learn :-) I'll get right on it.
02:17:57 <shachaf> Compare to "set (baz.field) world bar" or something like that.
02:21:02 <Catnaroek> Hello, I asked this in #haskell-overflow, and they redirected me here. I want to reinstall GHC and the Haskell platform from source (I previously used the Debian packages, but attempting to get aptitude and cabal to coordinate seamlessly as a pain in the ass). Can I use GHC 7.4.2. with the Haskell platform?
02:21:14 <quicksilver> no.
02:21:21 <quicksilver> well hmm now I think about it.
02:21:26 <quicksilver> if you're installing from source, perhaps you can?
02:21:41 <Catnaroek> Yes, I am installing from source.
02:22:22 <quicksilver> I don't know, although I would quite like to know the answer. I would guess you could, but you might need to do some manual tweaking where versions have changed
02:22:37 <quicksilver> in effect you'd be building an unofficial "new version of the platform"
02:22:42 <shachaf> The Haskell Platform is just a collection of packages as far as I can tell.
02:22:59 <ocharles> + GHC
02:22:59 <shachaf> I've used it with unsupported versions of GHC in the past by just "cabal install"ing in each subdirectory.
02:23:08 <shachaf> ocharles: Not the Linux binaries!
02:23:13 <ocharles> shachaf: hm?
02:23:20 <Catnaroek> quicksilver: The Haskell Platform download was much smaller than the GHC download, so that led me to think the HP does not include GHC itself.
02:23:30 <ocharles> I mean the Haskell platform is a version of GHC with a set of Haskell packages
02:24:06 <quicksilver> binaries of the HP include GHC
02:24:10 <Catnaroek> Oh.
02:24:11 <quicksilver> source of the HP does not
02:24:15 <quicksilver> this is potentially confusing.
02:24:19 <shachaf> ocharles: Well, you have to install GHC separately for the Linux version.
02:24:23 <quicksilver> many things abotu the HP are potentially confusing.
02:24:28 <quicksilver> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
02:24:32 <Catnaroek> Ah, okay, if the HP includes GHC, then I have no need to separately install GHC.
02:24:34 <shachaf> quicksilver: Like the way it says "Download Haskell"?
02:26:39 <srhb> Can I roll this into one list comprehension? My mind breaks.. [(x,y) | y <- [0,size], x <- [0..size]] ++ [(x,y) | x <- [0,size], y <- [0..size]]
02:27:03 <srhb> Actually this is fairly logical and understandable, I should just keep it like that.
02:27:35 <quicksilver> only in horrible ways, srhb
02:27:39 <srhb> Right. :-)
02:28:01 <shachaf> Keep in mind that list has duplicates.
02:28:06 <srhb> Does it?
02:28:07 <shachaf> Well, I guess that's obvious.
02:28:11 <srhb> Oh, right
02:28:12 <srhb> The edges
02:28:14 <quicksilver> [(x,y) | x <- [0..size], y <- [0..size], (x `elem` [0,size] || y `elem` [0,size]) ]
02:28:27 <quicksilver> eliminates the duplicates but does a lot of stupid busywork.
02:28:45 <quicksilver> calculating and then excluding all interior points.
02:28:48 <srhb> Yeah.
02:29:12 <quicksilver> you should probably use 1..(size-1) as the bounds for y in your second term.
02:29:17 <srhb> Yeah :)
02:29:25 <quicksilver> > [1..0]
02:29:26 <lambdabot>   []
02:29:33 <quicksilver> ^^ yay for languages which get edges cases right
02:29:35 <quicksilver> sometimes.
02:29:51 <srhb> You're praising fail? gasp :-)
02:29:57 <danr> what about [f (x,y) | y <- [0,size], x <- [0..size], f <- [id,\(x,y) -> (y,x)] ]
02:30:07 <quicksilver> heh
02:30:21 <quicksilver> of course that gets the duplicates back, danr
02:30:24 <quicksilver> but it's a nice trick.
02:30:41 <evancz> is `type String = [Char]`
02:30:47 <evancz> generally considered a bad idea
02:30:48 <evancz> ?
02:31:02 <merijn> evancz: What do you mean?
02:31:06 <srhb> String is already [Char].
02:31:10 <danr> quicksilver: oh right, we get some duplicates at (0,0)
02:31:17 <evancz> i mean from a language design point of view
02:31:31 <quicksilver> it's a compromise, evancz
02:31:43 <srhb> Good for some things, bad for others. But then you have Text.
02:31:43 <quicksilver> it's nice that you can use all the generic list functions on String
02:31:52 <quicksilver> but it's not an efficient representation.
02:32:06 <quicksilver> > map toUpper "hello"
02:32:07 <lambdabot>   "HELLO"
02:32:16 <evancz> Looking at Text, it looks like pretty much all of the list functions are available for Text
02:32:32 <evancz> > Text.toUpper "hello"
02:32:33 <lambdabot>   Not in scope: `Text.toUpper'
02:32:36 <quicksilver> yes, but someone had to write them all
02:32:45 <quicksilver> so there is no code sharing and no polymorphism
02:33:01 <quicksilver> and more sophisticated custom combinators you might have written on [a] can't be used.
02:33:20 <evancz> hmmm
02:34:03 <evancz> so you lose pattern matching on strings and any special list functions
02:34:10 <quicksilver> yes.
02:34:21 <quicksilver> and of course you lose tail-sharing, in the current implementation
02:34:35 <quicksilver> but you can of course imagine String representations which have some degree of tail sharing which aren't [Char]
02:34:40 <quicksilver> (but Text is not one)
02:34:55 <quicksilver> actually maybe lazy Text can tail-share?
02:34:57 <evancz> maybe a finger tree (?) implementation
02:35:18 <evancz> where (++) creates a data structure that points to two different strings
02:36:33 <evancz> One thing to point out is that separating [Char] and String does not stop anyone from using the [Char] representation
02:36:44 <quicksilver> that's what we did, evancz
02:36:47 <quicksilver> but we called it Text :)
02:37:13 <evancz> I know, but the default is to use [Char] which seems odd.
02:37:22 <quicksilver> you should ignore my comments about tail-sharing. Text does quite reasonable sharing, including substring sharing
02:37:27 <quicksilver> in what sense is that "the default" ?
02:37:33 <quicksilver> do you mean that Text is not in base?
02:37:48 <evancz> As in, when you say "hello" that's a [Char]
02:37:56 <quicksilver> it might be, if you're using OverloadStrings
02:37:58 <evancz> unless you do something special
02:38:11 <quicksilver> that's just a hysterical raisin.
02:38:21 <quicksilver> to do with how the libraries have evolved.
02:38:32 <evancz> oh historical :)
02:38:42 <evancz> wait
02:38:53 <evancz> what is "hysterical raisin"
02:39:18 <merijn> evancz: Common spoonerism for historical reason
02:40:24 <evancz> so, are you saying that ("hello" :: Text) would be the default if it was designed today?
02:40:35 <quicksilver> it might well be.
02:40:47 <merijn> quicksilver: Will the compiler convert string literals (if possible) to the appropriate type at compile time or will it generate a [Char] that gets converted at runtime
02:41:07 <quicksilver> another advantage of [Char] we didn't discuss is that it rquires no work by the compiler implementation.
02:41:09 <merijn> (When using OverloadedStrings, that is)
02:41:31 <quicksilver> whereas Text, to be efficient, basically requires the existence of certain low-level primitives which aren't part of the standard.
02:41:43 <quicksilver> so [Char] made it easier for a bunch of different haskell compilers to spring up.
02:41:45 <evancz> quicksilver: as in all list optimizations apply to [Char] with no extra work
02:42:06 <evancz> hmm
02:42:30 <quicksilver> there is also that, yes, the fusion and stuff works with [Char], but that's not what I meant.
02:42:55 <quicksilver> merijn: currently I think it's a [Char] which is converted at runtime, but that's "just a matter of a tweak in the compiler front-end"
02:43:06 <quicksilver> and I could be wrong.
02:43:16 <shergill> perhaps i'm missing something, but how do you convert a Data.Bytestring into Text? applying 'pack . show' results in an extra pair of quotes
02:43:20 <chrisdone> sup homies
02:43:48 <chrisdone> is there a ghc flag to just check types and not bother producing any code?
02:44:01 <quicksilver> shergill: well for that to make sense you need to know what the encoding of the bytestring is.
02:44:25 <quicksilver> shergill: if it's "just ascii" then Text.pack . Data.ByteString.Char8.unpack is the right thing.
02:45:01 <shergill> quicksilver: ah, ok. hmm i should give it some thought (wrt ascii or not)
02:45:01 <quicksilver> shergill: however, typically, one of the ByteString -> Text functions in http://hackage.haskell.org/packages/archive/text/0.11.1.9/doc/html/Data-Text-Encoding.html
02:45:13 <evancz> I ask because I am trying to decide how Elm should handle this. Currently, it also takes [Char] == String route (because it was fairly easy and comfortable). The downsides are speed and the size of compiled programss.
02:46:44 <chrisdone> evancz: depends on the program of course. using a js array doesn't let you take the head or tails of a list quickly and cheaply
02:47:01 <Enigmagic> shergill: Data.Text.Encoding.decodeUtf8 and other decode* functions do that
02:47:12 <evancz> head is pretty fast
02:47:25 <evancz> but yeah, tail is not as good
02:47:33 <shergill> Enigmagic: right, i was going through the documentation that quicksilver linked
02:48:02 <Enigmagic> shergill: yep... saw that after i hit enter :)
02:48:04 <evancz> head can just use array[0]
02:48:12 <shergill> heh
02:48:13 <chrisdone> evancz: in v8, at least, a cons will have registers for each slot. whereas an array is a lookup
02:48:29 <chrisdone> (provided you're using a proper object, anyway)
02:49:13 <evancz> right now a data constructor for cons is something like [ "Cons", 's', ... ]
02:49:14 <chrisdone> i'd compare with jsperf to be sure though. but yeah…
02:49:35 <chrisdone> yeah that's gonna be slower, i already tested that particular case
02:49:54 <evancz> what would be a faster representation?
02:50:12 <evancz> also, are you working on a Haskell to JS project ?
02:50:32 <evancz> at some point i'd like to replace the data constructor name with an integer
02:50:33 <chrisdone> i was using arrays for cons for my hs->js compiler, a friend sugested i use a proper object so function Cons(x,y){this.x=x;this.y=y;} and o.x and o.y is a lot faster, at least in v8, as it optimizes these fields to registers
02:50:47 <evancz> so [ "Cons" , ... ] becomes [ 0 , ... ]
02:51:00 <chrisdone> you mean to speed up pattern matching?
02:51:07 <evancz> yeah
02:51:41 <evancz> oh, but you are saying that an object representation is going to be faster than the array representation
02:51:59 <evancz> hmm, I must have found some dated benchmarks when I made this decision then
02:52:28 <chrisdone> what were the objects like though? a literal {a:1,b:2} won't be optimized
02:53:07 <chrisdone> (for me at least, and not saying this is better or worse, Cons is a function from the data type data List = Cons …, so i had something like [Cons,1,2] -- i still have this for user data types… cons is optimized as a special case, it would be cool to replace the rest with proper objects)
02:54:13 <evancz> right now, the representation of all ADT's is [ "Constructor", field1, field2, ... ]
02:54:33 <evancz> so lists are deeply nested arrays
02:54:50 <evancz> which kinda sucks but is also consistent with the rest of the language
02:55:18 <chrisdone> yeah, that's what i have now (so that i could automatically serialize/unserialize without type information >_>). i just made a special case for cons
02:55:18 <chrisdone> let me see if i can whip up a quick benchmark comparison
02:55:20 <evancz> so "hi" == [ "Cons", 'h', [ "Cons", 'i' , ["Nil"] ]
02:55:22 <evancz> ]
02:55:41 <evancz> where do you do benchmarks?
02:55:51 <chrisdone> http://jsperf.com/
02:56:18 <chrisdone> but i'll just do this locally with node as i'm pretty sure the difference is huge
02:56:38 <evancz> thanks for the link :)
02:57:07 <evancz> which Haskell to JS project are you working on?
02:58:30 <chrisdone> my own >_>
02:59:04 <evancz> very cool :)
02:59:25 <evancz> Elm is a similar story :)
03:00:45 <evancz> oh, and with the "Constructor" mapped to integers, that makes the compiled code smaller in addition to speeding up pattern matching
03:01:38 <chrisdone> sure. i presume you're passing the output to closure to collapse code for you right?
03:02:01 <quicksilver> chrisdone: you've made some contributions to ghcjs though haven't you?
03:02:44 <evancz> not at the moment
03:03:05 <evancz> I didn't want "Install the Closure compiler" to be part of the install process
03:03:30 <chrisdone> quicksilver: i experimented with it but haven't contributed anything substantial
03:04:13 <evancz> accessibility is important to me, so I didn't want to have people getting discouraged by the install process.
03:04:38 <evancz> I tried using ClojureScript and getting Closure working with it was a huge pain
03:04:39 <chrisdone> evancz: ah, ok. by assuming the js will be passed to a js compressor i got very nice compression out of closure
03:05:41 <evancz> I'll look into compression with closure a bit more
03:06:37 * hackagebot criterion-to-html 0.0.0.3 - Convert criterion output to HTML reports  http://hackage.haskell.org/package/criterion-to-html-0.0.0.3 (JasperVanDerJeugt)
03:08:00 <MasseR> Just my 5 cents: As far as I've seen, people appreciate readable output. So if you make your constructors integers, you'll lose lot of readability. I think roy creates proper named objects for the constructors
03:08:49 <chrisdone> yeah, true
03:09:43 <fenris_kcf> what could be the reason that ghc doesn't find Maybe anymore?
03:09:46 <chrisdone> if you have e.g. Cons=1, then [Cons,1,…] a closure/uglifier will replace it all with [a,1,2,3] anyway (actually it will probably collapse constants to numbers, thinking about it)
03:09:51 <xarch> hello, I've written this alex lexer : http://paste.awesom.eu/1JL
03:09:57 <xarch> but when I try to lex "fn x"
03:10:21 <xarch> Alex lexes [TokenVar "fn", TokenVar "x"] instead of [TokenFun, TokenVar "x"]
03:10:36 <xarch> do you have any idea why?
03:11:41 <xarch> which is funny because it lexes correctly let x in 3, for example
03:12:32 <evancz> the readable-ness of the output always struck me as strange
03:12:47 <ocharles> does anyone have any rules-of-thumb for setting +RTS options?
03:13:02 <evancz> it's akin to trying to get Haskell to produce readable assembly
03:13:06 <evancz> It's just odd
03:13:12 <evancz> but your point is well taken :)
03:13:46 <ocharles> I have a 4 core machine with 512mb ram
03:14:04 <ocharles> doesn't have to super tuned, but i hear running with just -N makes a big difference
03:14:11 <evancz> chrisdone: I really like that suggestion
03:16:21 <tdammers> anyone else having problems with cabal on debian lately?
03:16:46 <ksf> what's the canonical filename extension for hstringtemplate? htemplate?
03:16:52 <tdammers> I'm on wheezy, amd64, and it complains about not finding libgmp.so.3
03:17:31 <ksf> do you have libgmp and libgmp-dev installed?
03:18:26 <tdammers> yup
03:18:30 <chrisdone> evancz: looking at the speeds… it does seem to depend on the program. it's hard to get real behaviour as V8's optimizer is so clever, but here's one:
03:18:30 <chrisdone> chris@midnight:~$ time node y.js; time node x.js
03:18:30 <chrisdone> Object: 3 real	0m1.249s user	0m1.236s  sys	0m0.012s
03:18:30 <chrisdone> Array: 3 real	0m1.893s user	0m1.892s sys	0m0.004s
03:18:33 <chrisdone> evancz: of course, do your own benchmarks. in my code i was using an array for thunks. for sure an object literal vs a properly declared object will make "sum 1000000" go from 1509ms to 417ms
03:18:53 <tdammers> I only have libgmp.so.10 and libgmp.so though
03:19:08 <ksf> just link it, I'd say.
03:19:17 <chrisdone> evancz: doesn't seem the array vs proper-object gap is big enough that you care about it this stage in your dev :) just mentioning it
03:19:37 <tdammers> that feels dirty
03:19:42 <ksf> it is.
03:19:50 <chrisdone> dirty in a good way?
03:19:51 <tdammers> let's see what debian's bug db has to say
03:19:54 <ksf> alternatively, deal with debian
03:20:13 <tdammers> one should expect them to figure these things out for you
03:20:45 * ksf has libgmp 10, 10.0.2 and 3 , package version 5.0.2_p1
03:20:47 <ksf> (gentoo)
03:20:52 <tdammers> but then, serves me right for running unstable
03:21:10 <ksf> well, in debian there's the choice between ancient and unstable.
03:21:30 <evancz> chrisdone: thanks for testing that :)
03:21:37 <evancz> I'll look into jsperf more
03:21:59 <tdammers> that, and the slightly more tedious ancient base + backports
03:22:15 <tdammers> that usually works sufficiently well, but this time I thought I'd give it a shot
03:22:39 <tdammers> still much better than any of my ubuntu experiments so far
03:23:22 <evancz> it sounds like no one has any huge objections to [Char] as the default type for strings though, correct?
03:24:04 <ksf> tdammers, gentoo. switch to gentoo.
03:26:55 <LaughingMan> can't find interface-file declaration for variable xxxx       Probable cause: bug in .hi-boot file, or inconsistent .hi file
03:27:04 <tdammers> but is it not true what they say? that emerge will collapse into a heap of tears if you look at it wrong?
03:27:18 <LaughingMan> it does work in ghci, but why not if installed with cabal??
03:30:13 <Hail_Spacecake> how can I introduce a function definition with a number of different patterns to match in ghci?
03:31:41 <bitonic> Hail_Spacecake: use `case'?
03:31:56 <solarus> > let foo True = 1; foo False = 2 in foo False
03:31:57 <lambdabot>   2
03:32:29 <solarus> or as bitonic said case also works if you separate the matches with ;
04:05:59 <evancz> bye! thanks for the advice!
04:11:14 <lifeng> hi all, I have a question on high order function.
04:11:21 <lifeng> if I define a second-order function, say "double", which calls its parameter function, say "f", twice, is there any way to define a third-order function, say "foo", when I act it on "double", it returns a function calls "f" three times?
04:11:49 <merijn> lifeng: What do you mean "calls f three times"?
04:11:52 <merijn> Calls f on what
04:12:13 <ciaranm> if i understand your question, the answer is no
04:12:35 <ciaranm> it's like asking if, given a function (*2), you can make a function (*3)
04:14:16 <pooya72> lifeng: no, but you could call double once and f once that would give you 3 f.
04:15:05 <ocharles> isn't lifeng asking for something that takes an f and produces f . f . f ?
04:15:13 <merijn> He still hasn't mentioned what he wants to call it on, nor what he means by "call it three times" so you're making lots of assumptions
04:15:19 <lifeng> hmmm, I think it's impossible if there is no additional restriction on "f"
04:15:49 <merijn> lifeng: Can you show what double does? Maybe then it'll be clear what you mean
04:16:44 <lifeng> merijn: double ignores the result of the first call to f, and return the second call's
04:17:23 <merijn> That makes no sense
04:17:27 <merijn> What would that even do?
04:17:39 <Cale> What does 'call' mean here? :)
04:17:50 <merijn> If it ignores the first call to f then you might as well not make it
04:18:16 <merijn> And if it does not, in fact, ignore the first call then your explanation is unclear
04:18:33 * merijn is suspecting monadic actions being confused for function calls
04:18:54 <Cale> call = application?
04:19:10 <Peaker> Hmm.. I have something like: data Widget = Widget { .. fromSize :: Size -> WidgetData }  and a SEC lifter:  atFromSize :: ((Size -> WidgetData) -> Size -> WidgetData) -> Widget -> Widget ;    and I use:   atFromSize memo   ("memo" from ugly-memo, that uses unsafePerformIO to memoize the function) -- and apparently it doesn't cause memoization
04:19:36 <Cale> I'm having trouble picturing this expression. Do you mean a case expression like...  double f x = case f x of _ -> f x ?
04:20:25 <Cale> (that's fairly obviously equivalent to   double f x = f x)
04:21:09 <merijn> lifeng: I suspect you're either confused about terminology and asking for something different from what you want OR you haven't entirely thought your question thorugh
04:21:16 <Cale> I don't know what it means to call a function in this context though.
04:21:21 <lifeng> I'm also confused, let me re-think it for several hour to make myself clear :-)
04:21:28 <merijn> As Cale mentions your current suggestion of double is identical to not using double
04:21:48 <merijn> lifeng: Can you give an example use case/pseudo code of what you want to do/see happen?
04:21:50 <Cale> (we don't really have a notion of calling a function in Haskell... we have a notion of applying a function)
04:23:20 <Cale> A function application evaluates to some result. If we don't use that result, then it's semantically equivalent to just erasing that expression from our program and replacing it with some other constant value like ()
04:23:59 <Cale> (well, up to possibly forcing the evaluation of the function and its argument in the presence of things like seq)
04:24:06 <fenris_kcf> question: why does the following not work? http://codepad.org/z5KEpsny
04:24:18 <fenris_kcf> (yes, i read the error-message)
04:24:30 <fenris_kcf> (but can't really comprehend it)
04:24:50 <Cale> fenris_kcf: Because you didn't write the instance of Foo which you said ought to be a prerequisite for an instance of Bar
04:25:21 <Cale> class (Foo t) => Bar t   means that if you want to write an instance of Bar, then you'd better also supply an instance of Foo
04:25:40 <merijn> Also, you're Bar instance is only defined for Qux instances
04:25:48 <merijn> And Qux instances require a Bar instance
04:25:57 <merijn> So that seems counter intuitive
04:26:07 <Cale> Well, that would be fine
04:26:45 <fenris_kcf> so i have to write an instance of Foo for Test?
04:26:47 * hackagebot exception-mailer 0.1 - Catch all runtime exceptions and send an email  http://hackage.haskell.org/package/exception-mailer-0.1 (DavidPowell)
04:27:14 <Cale> For example, if Monad required Functor (like it doesn't, but ought to), you could always satisfy that constraint by implementing the monad operations and then supplying an instance of Functor where fmap = liftM
04:27:28 <Cale> fenris_kcf: yeah
04:28:09 <Cale> fenris_kcf: As an example of these superclass constraints, consider
04:28:24 <Cale> class Eq t where (==) :: a -> a -> Bool; ...
04:28:55 <Cale> class Eq t => Ord t where (<) :: ...
04:29:26 <Cale> This says that in order to make something an instance of Ord, *in addition* to the Eq operations, we need things like (<) etc.
04:29:56 <Cale> But we're allowed to assume then that if something is an instance of Ord, then it's also an instance of Eq
04:30:01 <fenris_kcf> Cale: the pasted code is just boiled down from something bigger
04:30:12 <fenris_kcf> actually i have an instance of Foo in there
04:30:39 <fenris_kcf> i try to create a minimum example ...
04:30:46 <Cale> (because the compiler will force us to write it)
04:31:02 <Cale> Maybe you should show us your actual code?
04:31:15 <Cale> Might be able to provide more specific advice then
04:31:19 <fenris_kcf> Cale: i could do that. hope you can read it ...
04:33:48 <fenris_kcf> Cale: http://codepad.org/1H0PPRCU
04:34:05 <fenris_kcf> should i translate it?
04:34:09 <linduxed> i just finished a piece of code and i need some kind of forum where i could ask for critique
04:34:16 <fenris_kcf> (maybe it's more readable after)
04:34:17 <linduxed> the repository is located here https://github.com/linduxed/kalaha-solver
04:34:23 <Cale> fenris_kcf: No, I can tell what the English translations are :)
04:34:52 <linduxed> is this channel good enough, or is there some haskell oriented site where i could pose the question?
04:36:38 <Cale> fenris_kcf: Okay, here's the problem, in order to make something an instance of Monoid, you need to also make it an instance of Magma
04:37:29 <Cale> fenris_kcf: If t is a unitary ring, you want it to be a monoid, but you haven't said why it ought to be a magma. You've only said here why Euclidean rings are magmas.
04:37:30 <fenris_kcf> yes, line 43
04:37:44 <Cale> er, sorry, I misstated that pretty badly
04:38:15 <Cale> You've only said why ModulRing t is a Magma assuming that t is a Euclidean ring
04:38:30 <Cale> but not how it's a Magma assuming only that t is a unitary ring.
04:39:02 <Cale> and in the last instance there on line 45, you're only assuming that t is a unitary ring
04:39:36 <Cale> http://codepad.org/t87fWEQB
04:39:50 <Cale> If you add that constraint, then the problem goes away
04:40:26 <fenris_kcf> Cale: ahhhh.... thank you very much
04:40:32 <fenris_kcf> it's kind of obvious
04:40:37 <fenris_kcf> but i didn't see it
04:42:20 <Cale> No worries :)
04:44:15 <fenris_kcf> so can i generally say, that the "dependencies" are also inherited downwards the class-hierarchy?
04:47:06 <merijn> Constraints is a better term than dependency, I think. And I would stay away from the word inherited/inheritance entirely
04:47:48 <fenris_kcf> yes, i know what you mean
04:58:21 <Peaker> I compose a large (Size -> Result) function from many (Size -> Result) smaller functions.  Then I memoize the result function (ugly-memo combinator), and I expect the outer AND inner (Size->) functions to only be evaluated once. But when I add traces, I can see the outer one is somehow evaluated just once and that's it, whereas the inner ones are evaluated many times.. How come?
04:59:33 <Peaker> I am suspecting GHC funny business
05:11:52 <jaxtr> ahh it's a wonderful day
05:16:54 * t7 just discovered he can get the inverse of a rotation matrix by just transposing it :O
05:18:10 <chrisdone> so my original question was: is there a ghc flag to just check types and not bother producing any code? i guess there isn't otherwise you'd know about it. for some reason i thought there was one
05:19:06 <quicksilver> chrisdone: I don't know who "you" refers to, but my memory is that there is no such flag.
05:19:23 <quicksilver> chrisdone: it might be faster to give it to ghci or runhaskell if speed is your concern.
05:19:32 <bitonic> chrisdone: or GHC API
05:19:36 <bitonic> shouldn't be hard
05:19:52 <xwl> hmm, i'm reading Real World Haskell.  when introducing foldl, it says due to limited stack, we should avoid using foldl, instead, use foldl'.  What about foldr? isn't it similar to foldl ? is there a similar foldr' ?
05:20:11 <bitonic> chrisdone: but I seem to *vaguely* recall a flag to do what you want. just to give you some unfounded hope.
05:20:50 <bitonic> xwl: foldr' would not be as useful as foldl', since foldr is not tail recursive anyway
05:21:28 <bitonic> xwl: btw, "use `foldl'" is a horrible advice. I'd say to always start with `foldr', which is most likely what you want semantically
05:22:05 <xwl> bitonic: but would not foldr run out of stack at some point?
05:22:12 <frerich> bitonic: Except that some things are much easier to express with foldl than with foldr.
05:22:21 <xwl> it feels unsafe to me.
05:22:23 <bitonic> xwl: every program could run out of stack at some point
05:22:36 <bitonic> computation with limited memory is unsafe
05:23:00 <quicksilver> every program can also run out of time
05:23:04 <bitonic> frerich: I'd say most of the time you want foldr.
05:23:09 * bitonic goes to have lunch
05:23:09 <quicksilver> computation in a bounded universe is unsafe.
05:23:27 * quicksilver recommends critical computations are run in a TARDIS.
05:23:30 <frerich> xwl: Did you finish chapter 4 in RWH yet? It has a long discussion of how foldl can cause problems whereas foldr won't, and how they differ.
05:24:17 <frerich> xwl: The only hint I want to give: the whole chapter is spent on how foldl can be problematic, but then the very first exercise given is much easier if you use foldl :-}
05:24:19 <xwl> but haskell is recursive, wouldn't it run into trouble much more easier than, like `for' loop in C language.?
05:24:37 <quicksilver> not really, no.
05:24:56 <quicksilver> if you use a foldr in a way which parallels a 'for' loop you never use any stack space
05:25:03 <quicksilver> and the list is GC'ed as you go along
05:25:05 <merijn> xwl: No, you forget two things: laziness and tail call optimisation
05:25:15 <merijn> Oh, and fusion I guess
05:25:16 <quicksilver> merijn: tail call optimisation is not relevant.
05:25:17 <frerich> xwl: I may be annoying, but this is *also* discussed in chapter 4 of RWH (look for 'tail recursion')
05:25:35 <xwl> merijn: yes.  but foldr is not tail recursive, right?
05:25:44 <quicksilver> the evaluation of the STG machine is not like compiling C.
05:25:45 <merijn> xwl: See laziness
05:25:54 <quicksilver> recursion does not inherently use stack space.
05:26:27 <quicksilver> stack space overflows general result from trying to force very deeply nested thunks.
05:26:33 <quicksilver> which is not your classic "for loop" situation.
05:26:46 <merijn> xwl: "map f (x:xs) = f x : map f xs" is not tail recursive and would be O(n) in stack space. But in haskell that definition has O(1) space requirement
05:27:18 <merijn> Well, if you discard it immediately that is
05:27:33 <merijn> If you keep the list you obviously need space for the entire list. But it still won't grow the stack
05:27:54 <chrisdone> quicksilver: 'you' in the plural :p sad that english lost that useful distinction. i was just thinking that i often make some changes while maintaining a project that have project-wide implications across a hundred modules, so i run cabal build and see what errors come up. that's fine but it takes a bit of time, it would be cool to run several processes at once to cheaply check the modules
05:27:55 <xwl> merijn: interesting. you mean, when we running map, it actually only takes O(1) space?
05:27:59 <merijn> xwl: Due to laziness the recursive "map f xs" call is not computed/evaluated when the initial item is returned
05:28:26 <quicksilver> the analysis is more complex than that.
05:28:36 <quicksilver> There is certainly a sense in which map consumes O(n) space
05:28:46 <quicksilver> but it *doesn't* consume any stack space.
05:29:04 <quicksilver> and it only consumes O(n) space if you force the entire list and it does so gradualy
05:29:08 <quicksilver> "as you demand elements"
05:29:24 <quicksilver> and temporarily - those cons cells can be GCed immediately in many cases
05:29:29 * ski . o O ( "incrementally" )
05:29:30 <merijn> xwl: Think of it as the following (simplified and wrong!) idea: map returning a tuple of "f x" and a pointer to the computation that returns "map f xs"
05:29:39 <merijn> How else would this work
05:29:50 <merijn> > take 10 . map (+1) $ [1..]
05:29:53 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
05:29:58 <quicksilver> and in certain cases, like a map of a map, the cons cells are eliminated by the compiler and not allocated at all.
05:30:28 <merijn> In that case I'm mapping over an infinite list, without laziness the recursive call would never return
05:30:36 <xwl> i have done a test.  config the stack to 35K , then i try to run:   foldr (+) 0 [1..10000],
05:30:40 <xwl> then i got stack overflow.
05:30:56 <merijn> Yes, but not from the recursion but due to the build up of thunks
05:31:31 <xwl> isn't building up the thunks caused by the recursion...
05:31:44 <ski> > foldr seq "done" [0 .. 9999]
05:31:45 <lambdabot>   "done"
05:32:07 <merijn> xwl: Well yes, but that's like saying segfaults are caused by running a program
05:32:20 <merijn> Technically correct, but hardly a useful observation :p
05:32:39 <xwl> with the same stack size, in C, we can use a for loop to calculate it without problem.
05:32:51 <xwl> how would you calculate it in haskell?
05:33:00 <quicksilver> foldl' (+) 0 [1..10000]
05:33:20 <ski> > foldl' (+) 0 [1..10000]
05:33:21 <lambdabot>   50005000
05:33:25 <xwl> so, back to my original question, is there an equivalent foldr' ?
05:33:28 <quicksilver> no.
05:33:29 <ski> no
05:33:37 <quicksilver> there can't be
05:33:50 <quicksilver> since foldr (+) has to reduce from right to left
05:33:57 <quicksilver> it can't help building it all up first.
05:34:31 <Peaker> I prefer reading "foldr" as "right-associative fold" than "fold from right", because "from" implies chronological order whereas the "r" just implies the nesting of applications
05:34:36 <xwl> ok.  the book i am reading is kind of emphasizing that we should foldr almost, most of the time.
05:35:04 <quicksilver> yup.
05:35:16 <quicksilver> you use foldl' when you are reducing a large list to a summary value
05:35:32 <Peaker> xwl, "foldr" is the natural fold over lists -- if your operation is associative such that you don't care if it associates left or right, then the rule of thumb is: lazy operation -> use foldr,  eager operation -> use foldl'
05:35:33 <roconnor> and you use foldl when you are implementing reverse
05:35:39 <chrisdone> a tail recursive function in a lazy language runs a like: while (!thunk.forced) thunk = thunk.force();
05:35:41 <quicksilver> and foldr when the result can be consumed piecewise
05:36:18 <xwl> Peaker: good summary.
05:37:06 <xwl> Do you use foldr more often, or foldl' ?
05:37:29 <chrisdone> i've never used foldl' in years, but i would know when to use it if i needed it
05:38:56 <KBme> hi
05:38:58 <fmap> i've used foldl' when was doing project euler and never since that
05:38:59 <xwl> ok… interesting…   maybe since we have big memory nowadays.
05:39:11 <hiptobecubic> i use foldl' but i'm mostly an idiot
05:39:50 <hiptobecubic> I still have trouble "seeing" the fold before it's written
05:39:51 <chrisdone> xwl: well it's just that i haven't needed to do anything strictly, except when in the IO monad where that's just normal
05:40:23 <KBme> I'm learning haskell right now from the book realworldhaskell
05:40:52 <hiptobecubic> KBme, ignore the stuff about exceptions.
05:41:04 <KBme> I have this code http://pastebin.com/raw.php?i=VjKTpL4X
05:41:06 <mauke> The paste VjKTpL4X has been copied to http://hpaste.org/70511
05:41:34 <chrisdone> hiptobecubic: https://lh5.googleusercontent.com/--1Jh_w9-07A/T-X_NqozC-I/AAAAAAAAAk4/68w7aUce1RU/s853/hascat.jpg
05:41:39 <KBme> but it won't compile. what could I do to make it work?
05:41:52 <KBme> hiptobecubic, why?
05:42:03 <Peaker> xwl, any time I write an explicit pattern-match on lists, if I see that it matches the foldr pattern, I replace it with foldr
05:42:11 <KBme> seems like the book isn't maintained…at all…
05:42:22 <Peaker> xwl, and that happens a lot.  foldl' is often used with arithmetic/integers because those operations are eager
05:42:26 <rwbarton> KBme: okay, so... it does compile
05:42:40 <Peaker> xwl, but I don't write lots of number crunching in Haskell
05:42:52 <hiptobecubic> KBme, unless it's been updated recently, it uses the old-style exceptions which aren't really compatible with the 'new' ones
05:43:10 <rwbarton> (how are exceptions relevant to KBme's question?)
05:43:15 <chrisdone> Peaker: difference between eager and strict?
05:43:18 <hiptobecubic> KBme, for me at least, it was a problem because I couldn't get things to build and it took me awhile to learn how to go between the two
05:43:25 <fmap> KBme: and the error is?
05:43:42 <hiptobecubic> rwbarton, they aren't. I warned him before he metnioned any problems.
05:43:50 <Peaker> chrisdone, lazy/eager are evaluation strategies.  non-strict/strict are semantic (f _|_ = _|_ means it is strict, otherwise non-strict)
05:43:52 <merijn> KBme: It doesn't look like it does what you want, but it should compile as far as I can see...
05:44:01 <rwbarton> I don't think trying to guess someone's problem based on the information "I'm reading RWH" is a good idea.
05:44:21 <Peaker> chrisdone, eagerness usually implies strictness, and laziness implies non-strictness, but it is sometimes more nuanced than that
05:44:22 <chrisdone> Peaker: ah, ok. what types of eagerness are there?
05:44:36 <merijn> KBme: What kind of error are you getting?
05:44:39 <KBme> http://hpaste.org/70512
05:44:42 <KBme> here it is
05:45:00 <Peaker> chrisdone, I think just one: evaluating the argument to a function before evaluating the application
05:45:01 <chrisdone> sure, non-strictness can be non-memoizing and such
05:45:06 <hiptobecubic> rwbarton, I didn't try to guess his problem. I just told him to ignore the stuff about exceptions.
05:45:07 <rwbarton> KBme, you should read that error message
05:45:16 <srhb> KBme: You're probably wrappiong a Just at each recursive call of something.
05:45:18 <rwbarton> and look at the code you pasted
05:45:26 <rwbarton> and notice how they do not relate to one another
05:45:42 <hiptobecubic> rwbarton, like saying "I'm going to thailand." and someone says "watch out for malaria", and then you say "... and i'm looking for a cheap hotel."
05:45:44 <merijn> KBme: That eror is not related to the pasted code
05:45:46 <KBme> I don't get it
05:45:48 <chrisdone> Peaker: sounds like an interesting way to program :)
05:45:52 <KBme> huh
05:45:55 <KBme> let me see
05:46:02 <merijn> KBme: The error mentions a problem in myfact, you paste myfactprint
05:46:33 <KBme> oh damn i fixed myfactprint
05:46:38 <KBme> dammit thanks and sorry :D
05:47:26 <hpaste> KBme pasted “myfact” at http://hpaste.org/70513
05:47:36 <KBme> there is myfact
05:47:48 <rwbarton> okay, better :)
05:47:52 <srhb> KBme: Like I said, you're wrapping Just at each recursive call
05:47:59 <srhb> Just (Just (Just (Just (Just ...
05:48:09 <chrisdone> Peaker: where's my haskell semantic editor?
05:48:10 <KBme> so what can I do?
05:48:13 <rwbarton> KBme, can you write a type signature for myfact?
05:48:18 <Peaker> chrisdone, http://github.com/Peaker/bottle :-)
05:48:21 <Peaker> chrisdone, making lots of progress
05:48:28 <Peaker> chrisdone, it does type-inference as you edit now
05:48:35 <KBme> Integer → Maybe Integer
05:48:44 <rwbarton> right
05:48:47 <Peaker> now debugging some performance issues...
05:48:59 <rwbarton> so on line 3, you are trying to multiply the Integer a by the Maybe Integer myfact (a - 1)
05:49:05 <KBme> yes
05:49:17 <KBme> I know the problem, but what can I do about it?
05:49:27 * chrisdone tries building it
05:49:37 <luite> Peaker: should it work on os x?
05:49:39 <KBme> I mean I understand that according to the compiler I might be multiplying with Nothing
05:49:41 <rwbarton> the most straightforward thing is to use a case expression
05:49:48 <rwbarton> I don't know what you've learned yet from RWH
05:49:59 <KBme> aha
05:50:14 <KBme> so I would compute fact(a-1) twice
05:50:16 <Peaker> luite, yeah
05:50:24 <Peaker> luite, though some of the packages are hard to build
05:50:25 <fmap> KBme: you can't multiply Integer with Just ... either
05:50:26 * chrisdone installs libdb-dev
05:50:27 <rwbarton> not necessarily
05:50:38 <Peaker> luite, though it's not really ready for real use-- still preliminary
05:50:44 <luite> Peaker: ok i'll just try then
05:50:55 <Peaker> luite, as a demo, it is already cute :)
05:51:08 <KBme> rwbarton, you mean because of lazyness right?
05:51:12 <chrisdone> luite: let's try it and make critiques as if it's a finished product
05:51:19 <luite> hehe
05:51:25 <rwbarton> why do you think you would be computing fact(a-1) twice?
05:51:42 <rwbarton> oh maybe i can guess why you think that
05:51:50 <KBme> well, you do a case on fact(a-1) and if it's not nothing you can compute
05:52:05 <rwbarton> when you do the case, you extract the value as well if it is Just something
05:52:13 <KBme> aha
05:52:16 <srhb> KBme: The problem is not just the Nothing.. You can't say 6 * Just 2 either
05:52:16 <Peaker> current features: 1) Tiny System-F-like language you can edit,  2) nice GUI toolkit with shiny animations 3) persistent undo buffer which is also a structural revision control (with branching support, but no merges yet)  4) everything persists without need to "save"
05:52:45 <rwbarton> like case fact(a-1) of Nothing -> ...; Just f -> {- use f here -}
05:53:01 <Peaker> the ui is rough and kind of a mess with its layout of the inferred types...
05:53:11 <chrisdone> Peaker: ah, so you're starting with a small haskellish language to prototype with and then somewhere in the distance do it for haskell?
05:53:53 <KBme> rwbarton, hmm let me see if I can write it then
05:54:22 * chrisdone still building dependencies
05:57:04 <KBme> rwbarton, but I still can't multiply an Integer with a Just Integer, as srhb said
05:57:19 <hpaste> KBme pasted “fact” at http://hpaste.org/70515
05:57:37 <chrisdone> Peaker: (still installing) the editor is written in opengl? you sly fox!
05:57:39 <srhb> KBme: You can pattern match the integer out, like rwbarton said
05:57:56 <rwbarton> right
05:58:03 <rwbarton> so let's say fact(a-1) = Just 6
05:58:04 <KBme> check my paste up there, isn't that what I'm doing?
05:58:16 <rwbarton> then inside the ... yes
05:58:27 <srhb> > case Just 3 of Just n -> n
05:58:28 <lambdabot>   3
05:58:41 <rwbarton> oh
05:58:59 <rwbarton> you need to produce a Maybe Integer, but line 5 produces an Integer
05:59:05 <KBme> aaaa
05:59:07 <KBme> heh
05:59:08 <srhb> Type juggling :-)
05:59:09 <zachk> Peaker: what is this wonder shiny small "toy" you are working on called?
05:59:17 <KBme> yes!
05:59:23 <KBme> thank you so much
05:59:32 <rwbarton> KBme, sure thing
06:00:02 <rwbarton> later you'll learn shorter ways to write things like "case myfact (a-1) of Just f -> a * f; Nothing -> Nothing", but it is good to learn the direct way first
06:00:13 <rwbarton> um, with the missing Just inserted of course :)
06:01:17 <chrisdone> HNNNNNNNNGGGG that is nice
06:01:29 <frerich> chrisdone: You built Bottle?
06:01:57 <chrisdone> Peaker: i can see it's rough, but i can tell what you're going for. this is sexy
06:02:01 <chrisdone> freiksenet: yeah
06:02:42 <chrisdone> Peaker: this is exactly what i've been working on how to do nicely. you saw my structured editor stuff right?
06:02:58 <frerich> chrisdone: Sweet, I'd love to see it in action :-)
06:03:25 <KBme> rwbarton, that's pretty much exactly what I wrote, or?
06:03:49 <srhb> better ways than _that_
06:03:51 <luite> hmm can't install BerkeleyDB dependency
06:04:02 <chrisdone> luite: apt-get install libdb-dev?
06:04:21 <luite> chrisdone: oh i'm on os x, did brew install berkeley-db
06:04:29 <pooya72> anyone know how to return the id of the most recent insert in HDBC?
06:04:40 <chrisdone> ah ok
06:06:06 <chrisdone> pooya72: i don't think there's a portable way
06:06:24 <pooya72> chrisdone: yeah that's what it looks like.
06:06:25 <chrisdone> in postgresql you can write insert returning id
06:06:50 <pooya72> chrisdone: yeah, but it seems like HDBC doesn't support that. It only returns the number of rows changed
06:07:22 <chrisdone> seems worth adding to the api
06:07:48 <pooya72> chrisdone: agreed. Does postgres-simple support that?
06:08:40 <chrisdone> iirc it's just as low level
06:12:01 <KBme> @srhb++
06:12:02 <lambdabot> Unknown command, try @list
06:12:52 <KBme> @karma+ srhb
06:12:53 <lambdabot> srhb's karma raised to 1.
06:15:30 <int-e> @karma (
06:15:30 <lambdabot> ( has a karma of 90
06:16:59 <int-e> > foldr (++) [] (tails "abc") -- maybe because of code like this?
06:17:01 <lambdabot>   "abcbcc"
06:21:58 * hackagebot colada 0.5.1 - Colada implements incremental word class class induction  using online LDA  http://hackage.haskell.org/package/colada-0.5.1 (GrzegorzChrupala)
06:22:12 <Peaker> chrisdone, sorry, had some phone calls
06:22:23 <Peaker> chrisdone, yeah, the plan is to do Haskell or even a DT lang later (Agda?)
06:22:39 <Peaker> chrisdone, Yeah, I saw your efforts, cool stuff :) I am not a big JS fan though
06:23:15 <Peaker> @tell zachk The shiny toy is called "bottle", and it's at: http://github.com/Peaker/bottle
06:23:16 <lambdabot> Consider it noted.
06:24:54 <Peaker> chrisdone, we're also avoiding the mouse as far as we can -- keyboard is much more efficient... btw, try to make an apply of a lambda, see what happens :)
06:25:11 <Peaker> luite, what's failing with bdb?
06:27:01 <luite> Peaker: Db.hsc:163: error: âDB_NOSERVER_HOMEâ undeclared (first use in this function)
06:28:34 <Peaker> luite you have to install the versions of bdb specified by the haskell bindings (I think >=4.7 && <= 4.8)
06:28:42 <luite> oh
06:29:11 <luite> ah right, i have 5.3.15
06:30:05 <Goatflakes> o hi
06:31:08 <Peaker> luite, bdb is a pain. We need a good key/value store that's usable as a library, easily
06:31:26 <Peaker> (and does transactional commits safely, handles crashes properly, etc)
06:31:40 <luite> Peaker: hmm, sqlite and acid-state aren't an option?
06:32:16 <Peaker> sqlite is SQL, which is probably a silly way to do a key/value store.  acid-state is all RAM, I think, and we really want to avoid a large vmem signature
06:32:18 <chrisdone> Peaker: yeah, doing it in JS is just prototyping. the mouse thing was totally not what want, as an Emacs user i spit on the mouse *ptuh!*, it's just that i'm still thinking about keyboard navigation. i have a concept in my brain but rendering it to software will take some time
06:32:29 <arnsholt> Peaker: Sounds like you want something along the lines of nosql, perhaps?
06:32:29 * chrisdone tries lambda
06:33:11 <Peaker> chrisdone, see the legend and try stuff out.. Ctrl+Shift+arrow is nice too :)
06:33:31 <Peaker> arnsholt, sure, but most of the "nosql" stuff is daemon-stuff, rather than in-process. We want a simple library API,
06:33:37 <Goatflakes> does anyone know how to get the parser examples from Graham Hutton's book to compile? they baulk cause >>=, return are already defined and do is right out of the question
06:33:53 <luite> Peaker: right, acid-state is all ram, i expect sqlite to work ok though for not too large values
06:34:06 <luite> dunno how much performance is required
06:34:12 <Goatflakes> i have tried putting things like Main.(>>=), Main.return and stuff but no joy
06:34:25 <Peaker> luite, we might have the entire known code-base (think "all of hackage") in the DB
06:34:36 <Peaker> luite, (or rather, subset of hackage that you use)
06:34:56 <chrisdone> all of hackage can't be that big?
06:35:20 <Peaker> the DB includes revision control, which is probably roughly 5x as big.. and I think the editor, if successful, could make hackage much bigger :)
06:35:24 <fmap> Goatflakes: link?
06:35:34 <Goatflakes> one sec
06:35:46 <Peaker> chrisdone, structural revision control is a must with a structural editor, I believe
06:35:53 <merijn> Peaker: I don't think SQlite is that silly for key/value store
06:36:46 <Peaker> merijn, it's not the intended purpose so it's like not to perform well at that task, and be wasteful, etc.
06:36:54 <chrisdone> Peaker: this seems more or less exactly how i'd envisioned my own stuff. i might contribute to this if i don't find the codebase too intimidating
06:37:28 <chrisdone> Peaker: agreed, structural source control just makes too much sense
06:37:36 <Peaker> chrisdone, awesome! :) Note we do intend to perhaps turn this commercial at some point, so it may be converted to some sort of semi-open-source thing later on
06:37:48 <chrisdone> ah, hm
06:37:56 <luite> what's the license for the current code?
06:38:01 <Peaker> currently GPLv3
06:38:05 <merijn> Peaker: SQLite is extremely lightweight, stable, well-tested and can handle huge data sets, though
06:38:09 <kalven> what about leveldb?
06:38:11 <chrisdone> Peaker: i expect the *thinking of how it should work* is harder than implementing right?
06:38:19 <arnsholt> Peaker: Right, that makes it a bit more complicated
06:38:24 <merijn> Peaker: Actually...why not berkeley DB?
06:38:45 <Peaker> chrisdone, I guess it depends on the feature. Debugging performance problems is hard
06:38:50 <chrisdone> merijn: it's already using berkely db, no?
06:38:53 <arnsholt> But I think merijn is right; sqlite wouldn't be completely silly, even if you're doing key-value storage
06:39:15 <Peaker> chrisdone, we're aiming for a smooth 60FPS experience and it's sometimes hard
06:39:16 <merijn> oh, bdb isn't good enough usability wise
06:39:40 <chrisdone> Peaker: why's that? it's merely text… the simplest thing ever to render :p
06:39:42 <Peaker> merijn, it's hard to build it, and it's a pretty annoying API, and a bit messy on the file system
06:39:59 <merijn> Peaker: I doubt you'll find something performing better than SQLite, though.
06:40:00 <chrisdone> (well, it's a complex tree, i'm joking a bit)
06:40:25 <Goatflakes> http://pastebin.com/H6hREntb
06:40:27 <mauke> The paste H6hREntb has been copied to http://hpaste.org/70520
06:40:28 <merijn> Most other database will be amateur quality compared to that
06:40:43 <Peaker> chrisdone, the composed widget may change every frame, and it turns out our implementation has efficiency difficulties when there are lots of widgets on screen.. also when you use flynav (ctrl+shift+arrow) it computes the "nearest selectable" 60 times per sec and that's a bit heavy too, apparently
06:41:00 <Goatflakes> verbatim from hutton pages 75-77
06:41:06 <Peaker> chrisdone, we're using a naive, somewhat elegant (in our opinion) compositional approach,   surely an imperative, optimized approach could have no difficulties at all with it
06:41:09 <Goatflakes> doesn't compile :<
06:41:22 <Peaker> chrisdone, and possibly we could find a way to make our compositional approach optimize much better too
06:41:55 <Peaker> merijn, I thought bdb is supposed to be faster than sqlite?
06:42:30 <chrisdone> holy shit fly nav is awesome
06:42:38 <Goatflakes> what is a fly nav?
06:43:15 <Peaker> basically mouse emulation with keyboard so you don't have to lift your fingers from keyboard... I experimented with that expecting it to suck, but it feels nice :)
06:43:35 <Goatflakes> well
06:43:38 <Peaker> chrisdone, press enter on some stuff to open their definition so there's more on screen
06:43:40 <chrisdone> it's nice because it moves the cursor
06:43:56 <Goatflakes> kind of pointless if you have to use arrow cause then you have to move your fingers from the home keys anyway
06:44:02 <chrisdone> yeah i tried that, was a little weird, i opened zipwith and changed its definiteion, heh
06:44:20 <merijn> Peaker: bdb might be, but we were discussing the hypothetical world where you wanted to use something else, right? :)
06:44:40 <Peaker> Goatflakes, moving to arrows is easier for me than moving to mouse
06:44:43 <quicksilver> pointless is too strong, moving to cursor keys is less of a context switch than moving to a mouse
06:44:48 <merijn> Peaker: Also, so you basically rediscovered that modal editing owns? :p
06:44:48 <Peaker> Goatflakes, but I'll add hjkl for flynav too :)
06:44:54 <fmap> Goatflakes: probably the easiest way is to hide return and (>>=) and rewrite do-block with them
06:44:57 <quicksilver> many (strange) people even use cursor keys for text editing
06:45:03 <Goatflakes> also why i think wasd movement is teh cancer
06:45:05 <Peaker> merijn, Modal editing owns if the modes make sense :)  I think "insert/normal mode" are pretty weak
06:45:09 <quicksilver> but Peaker can/should add homerow movement of some kind.
06:45:21 <Goatflakes> cause u have to move your fingers from home keys
06:45:29 <kalven> Peaker: have you checked out leveldb?
06:45:36 <Goatflakes> hjkl makes more sense
06:45:47 <Goatflakes> what about dfjk?
06:45:49 <chrisdone> it doesn't feel like modal editing
06:46:09 <chrisdone> it feels more like replacing the "code is a sequence of characters" paradigm with "code is a tree"
06:46:20 <chrisdone> retaining the single mode
06:46:39 <Peaker> kalven, nope, what's that?
06:46:56 <Goatflakes> if you were good and learnt how to touch type you are being punished for it now with wasd, keyboards in a plethora of incompatible layouts, etc
06:47:01 <Goatflakes> it's really annoying
06:47:07 <Peaker> chrisdone, well, it is modal in the sense that you get different actions/keys available on different types of subtrees.. e.g: when editing an integer, you might have a "display in hex" operation
06:47:11 <Goatflakes> anyway anyone looked at that paste?
06:47:13 <chrisdone> Peaker: how do i delete the db/start from scratch? i messed up and i want to start from the first 'foo'
06:47:20 <Peaker> chrisdone, and "rename" is a separate mode, for example
06:47:25 <Peaker> chrisdone, rm -rf ~/bottle :)
06:47:52 <Goatflakes> problems with it include: Parser isn't a Monad, so do doesn't work
06:48:02 <Goatflakes> erm
06:48:19 <Goatflakes> return and >>= already defined. and i don't know what else
06:48:20 <kalven> Peaker: a key-value db in a library, http://code.google.com/p/leveldb/
06:49:38 <chrisdone> Peaker: sure, the same modality exists in completion and dropdowns in eclipse-like editors, but i'll go along with calling it modal, just doesn't feel the same as explicitly switching modes a la vim
06:50:06 <Peaker> chrisdone, yeah, I agree. I think it just stems from vim's modes not being as useful
06:51:12 <Goatflakes> http://hpaste.org/70520
06:51:32 <luite> Peaker: i'll try it later when i'm on linux again
06:51:36 <nand`> the concepts of groups etc. have been extended to algebras with multiple operations, eg. a ring; have the concepts of a category and similar constructs been (usefully) extended to include an operation other than (∘)?
06:51:46 <Goatflakes> straight from "Programming in Haskell" by Graham Hutton. Doesn't compile >.<
06:52:27 <Goatflakes> @where hutton
06:52:27 <lambdabot> I know nothing about hutton.
06:52:30 <Goatflakes> :p
06:52:42 <Goatflakes> @where programming haskell
06:52:42 <lambdabot> I know nothing about programming.
06:52:45 <Goatflakes> ahaha
06:52:57 <Goatflakes> aint that the truth?
06:53:10 <Peaker> luite, my co-developer is on OSX, btw
06:53:47 <luite> Peaker: yeah i guess i need to learn how to install older versions with brew :)
06:54:16 * Goatflakes checks the book's website like he should have before
06:55:58 <Goatflakes> what's .lhs?
06:56:03 <nand`> literate haskell
06:56:20 <Goatflakes> orite like web2c and all that shite?
06:56:23 <nand`> it's like regular haskell except the top level is considered to be a comment and you need to specially mark non-comments
06:56:29 <stepkut> Goatflakes: no, much simplier
06:56:36 <Goatflakes> ok i got that by looking at it
06:56:46 <Goatflakes> there are tools for it?
06:56:48 <nand`> by either prefixing every source line with ‘> ’ or wrapping it with \begin{code} \end{code} or so
06:56:57 <Goatflakes> ta
06:57:03 <stepkut> Goatflakes: instead of code being the default mode and comments requiring special delimiters, you have comments as the normal mode and code requires special delimiters
06:57:04 <kopi> which one is better Vim with haskell plugin or Leksas IDe, or wihich one is more complete or updated
06:57:15 <Axman6> Goatflakes: that code you pasted, can you also paste the error you get? we can't help you at all without knowing whats wrong
06:57:21 <nand`> vim without haskell plugin is fine
06:57:23 <Goatflakes> yep thanks
06:57:25 <stepkut> Goatflakes: that makes it easy to write markdown, literate haskell, etc, but still be able to run the document
06:57:25 <Axman6> kopi: yes
06:57:32 <kopi> Ah ok
06:57:34 <kopi> Thanks.:)
06:57:39 <Axman6> kopi: in other words, whichever you prefer
06:57:43 <kopi> :P
06:57:53 <kyagrd> nand`: Syntastic vim plugin supports haskell pretty well
06:58:05 <nand`> kyagrd: what does it do?
06:58:57 <kyagrd> nand', it is a automatic syntax checker using compiler (or other tool)
06:59:09 <kyagrd> so, for Haskell it works with GHC
06:59:13 <Goatflakes> http://pastebin.com/fC3ZjSke
06:59:15 <mauke> The paste fC3ZjSke has been copied to http://hpaste.org/70522
06:59:17 <Goatflakes> for ghci
06:59:17 <nand`> I see
07:00:00 <nand`> Goatflakes: you can use import Prelude hiding (return)
07:00:16 <Goatflakes> thanks that might work and also fix the >>=
07:00:16 <Axman6> hiding (return, (>>=)) probably
07:00:46 <Goatflakes> yeah just qualifying them with Main. doesn't work
07:01:02 <nand`> it should though shouldn't it?
07:01:13 <Goatflakes> also winhugs gives the same error but with less context
07:01:44 <Goatflakes> http://pastebin.com/DXNGN2Mt
07:01:46 <mauke> The paste DXNGN2Mt has been copied to http://hpaste.org/70523
07:02:11 <LaughingMan> lookupSymbol failed in relocateSection - did anyone had this error before?
07:02:52 <Goatflakes> so how to use the hiding thing? just type into the wrapper?
07:03:05 <Peaker> chrisdone, did you manage to make an apply-of-lambda and see what happens?
07:04:45 <Goatflakes> Prelude> hiding (return, (>>=))
07:04:45 <Goatflakes> <interactive>:1:1: Not in scope: `hiding'
07:05:50 <Goatflakes> it would be nice if examples from introductory books would actually like compile or something :p
07:05:56 <fmap> i don't think you can hide Prelude.return in ghci
07:06:07 <Goatflakes> :/
07:06:13 <Goatflakes> hugs?
07:06:28 <fmap> just use some .hs file
07:06:45 <Goatflakes> i put it at the top got this
07:07:05 <Cale> Goatflakes: hiding clauses are part of import declarations
07:07:05 <Peaker> Goatflakes, I added the home-row keys to flynav too
07:07:16 <fmap> put it as nand` has written
07:07:21 <Goatflakes> http://pastebin.com/rtMk4xFm
07:07:23 <mauke> The paste rtMk4xFm has been copied to http://hpaste.org/70524
07:07:23 <KBme> so…recursion isn't really as useful as a for loop eh?
07:07:25 <Goatflakes> faks
07:07:29 <Goatflakes> fanks even
07:07:44 <KBme> for example the factorial function written recursively isn't as useful as with a loop
07:07:45 <Goatflakes> wot? heresy! ;)
07:07:56 <fmap> KBme: what
07:07:58 <KBme> for a big number it overflows the stack.
07:08:01 <Goatflakes> why do you say that?
07:08:08 <Goatflakes> orite
07:08:20 <Goatflakes> maybe
07:08:40 <Peaker> KBme, loops are like tail-recursions, both take same amount of "stack".
07:09:02 <KBme> I can't imagine a for loop overflowing the stack
07:09:37 <Goatflakes> what about loop variables? won't have to push atleast one of them onto the stack for each call?
07:09:45 <Goatflakes> variable i know
07:09:45 <hpaste> KBme pasted “factoverflow” at http://hpaste.org/70525
07:10:20 <KBme> well, the number 100000000000000 won't overflow
07:10:35 <KBme> maybe a bigger number would, but it would need to be really huge
07:10:40 <Goatflakes> hmm that's a worry
07:11:06 <Cale> KBme: you're assuming that there is a stack, but you can do graph reduction without one
07:11:21 <Cale> KBme: GHC's evaluator has a stack, but it's not a call stack
07:11:29 <Goatflakes> guess all them ns are garbage collected fast enough
07:11:34 <Goatflakes> ^aren't
07:11:54 <Goatflakes> so tail recursion elimination doesn't really help
07:12:31 <KBme> well, this just means tail recursion optimization still doesn't make the functions as powerful as a loop would
07:13:02 <Goatflakes> isn't there functions to do loops?
07:13:08 <Cale> In this case, the stack overflow happens as a result of (*) demanding the evaluation of (pattern matching) both of its arguments.
07:13:08 <KBme> I thought somehow it could, since it could add the values as it goes
07:13:12 <Goatflakes> try using them instead of explicit recursion
07:13:19 <fmap> KBme: you can write both recursive (you factorial function) and iterative (factorial with accumulator) processes with recursion
07:13:22 <Goatflakes> ahh
07:13:34 <Cale> Also, you didn't write go in a tail recursive way
07:13:34 <Goatflakes> wait
07:13:52 <KBme> well, but then it could multiply 100 * 999 *(factn-1) no?
07:13:55 <Goatflakes> how to make an accumulator when u can't assign variables?
07:13:56 <KBme> er
07:13:59 <KBme> well, but then it could multiply 100 * 99 *(factn-1) no?
07:14:18 <Cale> You have 100 * (99 * go (n-1))
07:14:20 <KBme> Cale, oh, I didn't?
07:14:23 <merijn> Goatflakes: Allocate a new one and garbage collect the old one every time?
07:14:24 <KBme> right
07:14:28 <Goatflakes> orite
07:14:29 <KBme> ok let me see
07:14:31 <Goatflakes> der
07:14:35 <Goatflakes> anyway
07:14:47 <Goatflakes> brain full need to sleep and digest :3
07:14:50 <Goatflakes> l8r
07:14:54 <KBme> bai
07:15:02 <Cale> Of course, you're inevitably going to run out of memory trying to compute that factorial
07:15:05 <KBme> Cale, is there a way to make it tail recursive?
07:15:16 <KBme> even with tail recursion?
07:15:27 <chrisdone> Peaker: was just showing it to my colleagues who I've been raving to about strucutred editors for months and they weren't believing it would work ;) they say it's very impressive
07:15:31 <Cale> You can write  foldl' (*) 1 [1..n]
07:15:44 <chrisdone> the future of editors looks interesting
07:15:50 <fmap> > let fact a 0 = a; fact a n = a `seq` fact (a * n) (n - 1) in fact 1 1000
07:15:51 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
07:16:11 <chrisdone> inventing on principle style gave birth to editor protoypes like the light table thing
07:16:15 <merijn> Peaker/chrisdone: Is there a simple "cabal install" command I can run to build it?
07:16:18 <chrisdone> here we've got structural editing on the other side
07:16:18 <Cale> or something tail recursive (+ a little explicit strictness) like fmap shows
07:16:43 <chrisdone> merijn: i ran cabal install in the directory. had to install a few libhwatever-dev's with apt-get but that's all
07:16:43 <Cale> You could also just write product [1..n], and compile with optimisations
07:17:04 <KBme> still, that would fill the memory with that list eh?
07:17:21 <Peaker> chrisdone, awesome! :-)
07:17:22 <merijn> Pretty sure that'd fuse, no?
07:17:30 <Cale> no
07:17:39 <Cale> The list will never exist in memory all at once
07:17:45 <chrisdone> merijn: from my bash history: sudo apt-get install libdb-dev libgl-dev libgl1-mesa-dev libglu1-mesa-dev libftgl-dev
07:17:49 <Cale> However, the numbers will fill up memory
07:17:50 <Peaker> merijn, you can "cabal install" in the bottle repo - but it'll need some c dependencies
07:17:50 <KBme> Cale, oh? interesting
07:18:01 <merijn> chrisdone: Probably won't work very to run apt-get under OSX :)
07:18:11 <merijn> s/very to/very well to
07:18:18 <Cale> Regardless of which method you use to compute it, 100000000000000! is large enough that you probably don't have enough memory to store it.
07:19:35 <Peaker> merijn, If you pulled recently, pull again, I pushed a bad commit recently
07:20:04 <KBme> well, fmap's version is going further than my implementation
07:20:20 <Cale> It would require on the order of 2.32 petabytes of memory to store the result of that computation.
07:20:43 <KBme> heh
07:22:21 <KBme> then again, fmap's version doesn't deal with negative integers
07:22:57 <Cale> product [1..n] does :)
07:23:02 <Cale> > product [1..(-10)]
07:23:04 <lambdabot>   1
07:23:11 <Cale> > product [1..10000]
07:23:13 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
07:23:35 <KBme> > product [0]
07:23:37 <lambdabot>   0
07:23:41 <KBme>  ◕ ‿ ◕
07:23:44 <Cale> > product []
07:23:46 <lambdabot>   1
07:23:53 <KBme> ah
07:24:00 <Philippa> Cale: that's Big Data :-)
07:24:26 <wingy> amazes me that there are 900 members in here
07:24:28 <nand`> Cale: who cares about storing it, just write the digits to the console lazily :)
07:24:36 <wingy> more than ruby, node.js etc
07:24:55 <nand`> Maybe more Haskell programmers are IRC-savvy?
07:25:12 <nand`> that's the impression I get from “popular” languages; they don't use the IRC channels that much
07:25:25 <wingy> yeah
07:25:46 <chrisdone> nand`: i reckon you could discount that by counting the intersection of the #haskell and #ruby channel
07:25:57 <harrison> irc4lyfe
07:26:06 <wingy> could one say that FP is to eliminate the bad parts causing the most bugs in our systems (state) while OOP is creating a bigger problem rather than solving the main cause?
07:26:30 <harrison> if one wanted to be annoying one could say that
07:26:38 <chrisdone> wingy: sounds like you've come to get support for an argument with someone else ;)
07:26:51 <Franciman> hi all
07:27:09 <wingy> harrison chrisdone : i want to understand why FP
07:27:10 <harrison> why not argue right here? i will start! you are all quite wrong. discuss.
07:27:12 <chrisdone> > "hell" ++ cycle "o"
07:27:14 <lambdabot>   "helloooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
07:27:29 <wingy> eh .. dont get me wrong .. im all ears
07:27:41 <favonia> Hi, does anyone know why there are two seemingly identical packages, MonadCatchIO-mtl and MonadCatchIO-transformers?
07:28:00 <srhb> wingy: How about working by example instead and showing how entire classes of bugs don't happen with type safety. Seems a more professional way to go about it :)
07:28:01 <chrisdone> wingy: it's just not a very interesting thing to talk about tbh
07:28:48 <chrisdone> favonia: mtl and transformers are slightly different libs, and the MonadCatchIO-* packages are basically the same extension
07:28:50 <Cale> nand`: It's easy enough to get the *last* 20000000000000 digits or so.
07:28:53 <Franciman> favonia, I guess it's related to the difference between mtl and transformes
07:29:02 <Cale> nand`: but the other end is a bit trickier :)
07:29:14 <nand`> wingy: I like FP because it makes sense
07:29:22 <nand`> that's honestly the only explanation I can give
07:29:37 <chrisdone> nand`: pretty bland explanation ;)
07:29:41 <nand`> Cale: do you have a printer and lots of paper? :)
07:29:49 <chrisdone> nand`: needs more shouting and waving of lambdas
07:29:49 <favonia> chrisdone: ah I see. I only focus on the interface and feel that they are absolutely identical.
07:29:59 <favonia> Franciman: right...
07:30:21 <nand`> in particular, the tenets of Haskell: referential transparency and type strictness
07:30:23 <wingy> very surprised by the reaction i get actually ... "FP is like, a style, a trend .. use it or not use it .. who cares"
07:30:24 <nand`> those are the way things should be
07:31:06 <Franciman> hey people, in a case expression is the selection of the "case to use" done in O(n) or O(1) like switch in C-like languages?
07:31:07 <nand`> evaluating the same thing twice should have the same result; and things should always be well typed because the only thing you can do with something of an unknown type is nothing
07:31:41 <Franciman> favonia, maybe one uses the transformers style and the other mtl style
07:32:24 <Cale> wingy: Well, here's another opinion for you... This is 2012 -- we've known how to implement first class functions efficiently for decades now, and we've known about their importance to the business of expressing algorithms for longer than electronic computers have existed. There's no excuse to still be starting new projects in languages without them.
07:32:30 <nand`> (also laziness but that one isn't as particularly flashy as it can be just as hard to deal with as strictness if you're not well versed in it)
07:32:54 <fmap> Franciman: O(1)
07:33:13 <fmap> see https://github.com/ghc/ghc/blob/master/compiler/codeGen/CgUtils.hs#L647
07:33:25 <nand`> Cale: I don't think first class functions alone make something a “functional language”; though the term is awfully overloaded and subjective
07:33:54 <Cale> Well, yes.
07:33:57 <KBme> yeah, some imperative languages have 1st class functions
07:34:20 <wingy> Cale: wasn't that what i was trying to get?
07:34:29 <wingy> that FP is good for eliminating bugs
07:34:53 <nand`> to me, “functional” means “primarily operates by composing, combining and applying functions” and “uses functions for control flow”
07:34:56 <Cale> wingy: I don't know -- just felt like saying something counter to the idea that FP is a trend.
07:35:20 <nand`> wingy: I think strict static typing is the most important aspect of eliminating bugs
07:35:28 <Franciman> fmap, great thanks
07:35:29 <wingy> Cale: you thought i was joking?
07:35:32 <wingy> lol
07:35:32 <nand`> but referential transparency gets a good second
07:35:35 <Cale> wingy: No.
07:35:53 <srhb> If FP was a trend, I'd have a job.
07:35:55 <srhb> ._.
07:35:58 <Cale> Programming functionally is sort of a natural consequence of having first class functions in your language and making use of that feature in an intelligent way.
07:36:30 <Cale> srhb: I hear Galois is hiring :)
07:36:37 <harrison> it is 2012? why did i not get a memo warning me?
07:36:40 <Philippa> something can be a trend without dominating /right now/
07:36:42 <srhb> :-) I was mostly kidding.
07:36:44 <harrison> how much time is left?
07:36:52 <srhb> I suppose it would be more correct to say that FP is trending.
07:37:08 <Philippa> not on Twitter, it's not :p
07:37:11 <srhb> Haha.
07:37:12 <harrison> I thought he was killed in a duel.
07:37:26 <Cale> harrison: http://corp.galois.com/
07:37:29 <nand`> harrison: I'd wager about 10^100 seconds or so
07:37:57 <wingy> honestly now, i have no idea why you guys reacted like you did .. a: you though i was disliking FP for OOP? b: you thought i wanted to start a flame war? could someone explain
07:38:29 <favonia> chrisdone: Franciman: I am confused now. mtl just re-exposes transformers, right? And MonadCatchIO-* only depends on MonadIO I guess? So I feel MonadCatchIO-mtl should just re-expose MonadCatchIO-transformers?
07:38:51 <srhb> wingy: I think for most people, the fact that it feels good is good enough :P
07:38:57 <Philippa> wingy: we try to avoid the worst of propaganda here, at least some of the time
07:39:16 <wingy> Philippa: what was the propaganda?
07:39:22 <wingy> i dont get it .. seriously
07:39:24 <Philippa> srhb: yeah, getting to eventually program in the language in your head is always a joy
07:39:28 <srhb> "Why Haskell" is less interesting than "Haskell" :P
07:39:44 <wingy> srhb: its always about the WHY
07:39:46 <Philippa> wingy: eh, all kinds of stuff I really don't care to try to reconstruct because I never believed it
07:39:51 <Cale> wingy: I didn't think you were expressing your own opinions. You mentioned that some people think that FP is a fad.
07:39:56 <Philippa> nah. The WHAT can be pretty shiny too
07:40:04 <chrisdone> wingy: if you're referring to my reaction, this page sums up my thoughts http://wiki.chrisdone.com/Delivering%20a%20Khutbah
07:40:28 <wingy> Cale: i did not?
07:40:30 <Philippa> (for me, the WHY is that I get more stuff done with less room to screw up, though perhaps the screwups are more immediately interesting when they happen)
07:40:35 <Cale> wingy: Maybe I missed it
07:41:01 <nand`> chrisdone: interesting
07:41:29 <Philippa> there're many arguments as to how that might happen: certainly strongly statically typed pure FP makes a decent metalanguage that's better at not breaking your abstractions than many bases
07:41:45 <Philippa> (though I have respect for highly reflective OO systems as well)
07:41:47 <srhb> I guess a company can have a why and a person can have a why, but ultimately, they don't have to be the same even between different people. Why don't you try it out, wingy, and make your own impression? I'm not sure why anyone should rush to the defense of Haskell - Haskell really doesn't need it :P
07:42:13 <Philippa> yeah, we keep failing to avoid success
07:42:28 <srhb> Failure of the best kind. Maybe.
07:42:28 <Cale> Need to fail more!
07:42:28 <srhb> :P
07:42:36 <merijn> Cale: Only dons-skilled haskell programmers or...? :p
07:42:49 <merijn> (The Galois hiring I mean)
07:42:52 <Philippa> (and in the long run, that /will/ become a curse: we're not the cutting edge of FP any more, though we're getting on the for cutting edge of FP-that-can-deal-with-the-World if you want to get stuff done)
07:42:55 <Cale> merijn: I don't know
07:42:59 <wingy> srhb: defense? when was the attack
07:43:04 <chrisdone> nand`: glad you think so :)
07:43:16 <roconnor> thankfully there is still Agda and Epigram
07:43:24 <roconnor> uncorrupted by bottoms
07:43:35 <nand`> hehe
07:43:35 <wingy> jezz .. was curious about FP and if that would help eliminating bugs and asked a question .. and get attacks .. mature
07:43:46 <Cale> wingy: Who attacked you? :)
07:43:54 <nand`> yes, the logical next step in functional programming is eliminating partial functions :)
07:43:57 <Peaker> does Go have first class functions?
07:44:11 <nand`> Peaker: If I remember correctly yes
07:44:24 <roconnor> nand`: does Go have sum types?
07:44:29 <Philippa> roconnor: I'm not touching that with the traditional ten foot pole...
07:44:32 <Peaker> I think except for Java, C, and C++, the most popular languages all have first-class functions these days.. So FP isn't really about that
07:44:32 <srhb> wingy: I never meant to attack you. I mean that the comparison is.. Well, often not fruitful. Suffice to say OOP and Haskell are very different.
07:44:36 <roconnor> Philippa: :)
07:44:38 <wingy> from 9s: http://www.youtube.com/watch?v=MrTsuvykUZk
07:44:49 <roconnor> FP is about sum types :D
07:44:49 <nand`> Peaker: yes, func{} types are, well, types in go
07:44:56 <Peaker> roconnor, it has "type switches" that let you emulate that with multiple classes and static "duck typing"
07:45:04 <merijn> Peaker: C++ has first-class functions now too
07:45:09 <roconnor> Peaker: interesting
07:45:10 <Cale> Peaker: Well, first class procedures anyway
07:45:21 <Peaker> roconnor, but the syntactic overhead is so huge, that Go doesn't use sum types where it should (e.g: error codes from functions)
07:45:37 <Peaker> merijn, in what form? How do they capture the lexical scope without GC?
07:45:43 <roconnor> Peaker: sad
07:45:49 <Cale> (but most programmers don't seem to care about the distinction between a function and a procedure which computes a value)
07:45:50 <merijn> Peaker: I dunno, I didn't read the C++11 spec
07:46:08 <Cale> Of course, we do :)
07:46:12 * roconnor isn't entirely sure how one makes a "Type-safe" langauge without having sum types.
07:46:30 <Peaker> roconnor, yeah, Go uses a product type (and is really proud to have anonymous product types at all) like (error code, result)   with invalids/undefineds on either side to represent: Either (error code) result
07:46:38 <nand`> Peaker: reminds me of the last time I programmed in go, before Haskell had me fully in her grasp - those ugly, ugly type switches
07:46:57 <Peaker> roconnor, type-safety is relative :)
07:46:59 <Philippa> it's tricky pinning down what (aside from "pure FP") FP should mean in the absence of static typing these days
07:47:18 <roconnor> Peaker: ah right,  Type-safe means the program won't segfault; instead it throws a runtime error
07:47:22 <roconnor> well I suppose that it is better
07:47:25 <wingy> srhb: wasn't a comparison..was a question based on some facts i have gathered .. read some articles that FP is to eliminate states since those could be very potential to introduce bugs .. that OOP was "hiding" the bugs under better abstractions .. while FP was eliminating it, hence my question
07:47:37 <nand`> FP doesn't eliminate states: see State monad
07:47:40 <Philippa> Van Roy's argument about the embedding fallacy (or whatever it was he calls it?) is valid, but metaprogramming like a mofo is a legit and sensible use of FP
07:47:44 <Peaker> nand`, I claimed on Hacker News that Go was designed mostly boolean blind out of ignorance of Rob Pike and the other authors -- and was downvoted. They disbelieve that the Go authors could be ignorant of language design
07:47:55 <nand`> if anything I'd say FP eliminates the program counter
07:48:08 <Philippa> hah. Not inherently, though lazy FP makes more of a mess of it
07:48:14 <Peaker> wingy, mutation and state are made explicit rather than eliminated in pure FP
07:48:17 <srhb> wingy: OK: Avoiding mutable state, which FP is good at, often helps eliminate bugs.
07:48:18 <roconnor> Peaker: what does "designed mostly boolean blind"
07:48:20 <roconnor> mean
07:48:26 <Cale> wingy: Not doing mutation where you don't need it is just good programming practice.
07:48:27 <Peaker> roconnor, did you see the "boolean blindness" article?
07:48:28 <srhb> fsvo often
07:48:30 <Peaker> roconnor, by Harper?
07:48:32 <roconnor> Peaker: yes
07:48:35 <Philippa> roconnor: lots of booleans where more informative types could've been used
07:48:49 <Cale> But yeah, FP makes that more obvious
07:48:57 <roconnor> Peaker: to me, boolean blindness means that "if statements are code-smell"
07:49:01 <nand`> Peaker: I used to find Go useful, back when I was still using clumsy VM/JIT languages for which no machine compiler existed
07:49:01 <Philippa> Cale: up to certain values of 'need', anyway. There comes a point where if I'm doing State, I'd rather own it
07:49:05 <roconnor> oh
07:49:10 <nand`> Peaker: nowadays I find Haskell sufficient even for trivial/small programs
07:49:15 <Peaker> roconnor, well, Go does have ugly "type switches" that are not boolean blind, but the majority of conditionals in Go are not type-switches, and it is probably not practical to use type-switches for most things, so you end up with almost all conditionals in Go being boolean-blind
07:49:31 <Peaker> roconnor, to me, boolean blindness is: "Branching operations don't gain any type information"
07:49:46 <roconnor> Peaker, Philippa: I think I might have got the opposite definition of boolean blindness from the article.
07:49:49 <Philippa> (but an IDE that can be really picky about telling you types would be useful: which terms are only forced to be in a State monad by enclosing constraints, for example - aka which ones don't use State)
07:49:49 <Peaker> nand`, yeah, I even switched to Haskell for most of my shell scripting :)
07:49:56 <Franciman> gotta run see ya
07:50:13 <Philippa> roconnor: "boolean-inflicted ignorance" might be a better term?
07:50:13 <chrisdone> Philippa: meta-programming in a lispy, and therefore transparent way, really appeals to me… to have it in a haskell would make my cotton socks pink. laziness+cheap closures covers most cases, but the classic getLine >>= \line -> case line of … really irks me ;_;
07:50:23 <Franciman> favonia, I don't know much about those libs sorry :S
07:50:45 <Philippa> chrisdone: yeah. One of my side projects is a language with a middle ground on macros
07:50:58 <Philippa> enough to deal with that kind of case, don't think it's enough to be anywhere near turing complete
07:51:56 <nand`> Peaker: same. btw: What confuses me about Go is the fact that they set on to make a “lightweight, non-OOP language” then went on to add basically every aspect of OOP languages to it via means of various trickery
07:52:01 <nand`> and/or syntactic sugar
07:52:07 <Philippa> Haskell's already pretty good at "semantic metaprogramming" though, it's just the odd bits of syntactic mess that are a PITA
07:52:11 <chrisdone> Philippa: ooo. i should come here more often, it seems everyone's doing the projects i want to do.
07:52:11 <chrisdone> Philippa: that sounds great -- it's indeed not that i want a particularly powerful macro language—indeed, macros aren't composable and often feel The Wrong Solution—just one that can handle such cases!
07:52:18 <chrisdone> right!
07:52:36 <Philippa> well, that and we're not so good at doing it at type level, I guess
07:52:42 <Philippa> we still need TH to generate types
07:52:52 <Peaker> nand`, I don't know why Rob Pike commands so much respect
07:53:09 <Philippa> (or else an absolute /ton/ of syntactic mess and typeclass abuse)
07:53:11 <chrisdone> the fact i can write (when foo (print bar)) and then zipWith when … is power that you can't get from lisp macros (unless you get into the mess of compiler macros, anyway)
07:53:21 <chrisdone> hm, yeah
07:53:40 <Philippa> Peaker: for having done major stuff back in the day, amongst other things. It's easier for people to grasp how that's a big deal
07:53:49 <Peaker> besides the embarassing mistakes in Go, I read some outright embarassing ideas about uses of #include in C "Simple rule: include files should never include include files"
07:53:51 <earthy> Peaker: because of Plan9 and UTF8 The Practice of Programming and...
07:54:20 <Philippa> Peaker: Pike's from a less formal culture. Such rules are expected to be broken on occasion
07:54:51 <Peaker> earthy, Plan9 is a minor incremental improvement over Unix that did not catch on, I'm not sure how impressive that is.. UTF8's achievement is mainly a sociological one (getting everyone to agree on it), it is not a complex feat.  I haven't read the Practice of Programming
07:54:52 <merijn> Peaker: I dunno, Go feels like a pretty decent "get shit done"-language
07:55:10 <nand`> My main annoyance with Haskell is my perceived strangeness of the Prelude, mostly for historical reasons
07:55:20 <Peaker> merijn, maybe, you can be very productive in very badly designed languages too...
07:55:23 <chrisdone> Philippa: is there a page or some sauce online for your side project that i can follow?
07:55:33 <merijn> So many people seem to want Go to be the next big revolutionary language features/perfect design
07:55:36 <nand`> merijn: Haskell feels that way to me too; tbh
07:55:46 <Philippa> nand`: that and the amount of crud you have to import for what feels like the "Real Prelude" these days - Control.Monad, Control.Applicative, etc etc
07:55:48 <merijn> nand`: Different sort of get shit done language
07:56:04 <Peaker> nand`, Yeah, and the ecosystem's dark spots (cabal install's unreliability), and some quirks (MR) and some language limitations (no structural records, no anonymous sums), ..
07:56:11 <merijn> Peaker: Yes, but as far as badly designed but productive languages go Go is pretty good
07:56:21 <Philippa> chrisdone: not currently, sorry. My usual failure at getting shit done kicked in a third of the way through the initial hack while stuff messing about with basic embedding issues
07:56:25 <ciaranm> go still can't implement sorting, can it?
07:56:43 <merijn> ciaranm: What do you mean?
07:56:44 <Philippa> the basic plan amounts to treating macros as synthesised attributes and not letting them do anything recursive though
07:56:52 <nand`> Control.Monad.Instances (wtf? wouldn't you rather explicitly hide instances than have to pull them in constantly?), lack of Functor/Applicative superclass on Monad, (>>=) in Monad instead of join/bind (as alternatives), etc.
07:56:56 <chrisdone> Philippa: haha, i know that feeling. well i'll ask about it later, sounds neat
07:56:59 <ciaranm> merijn: if i want to sort an array of monkeys, do i still have to code my own sort?
07:57:12 <Philippa> (that is, within a given node - obviously you get recursion founded on the AST)
07:57:19 <nand`> Peaker: I don't use cabal-install so I've never had any issues with it :)
07:57:21 <Peaker> nand`, yeah, though I sympathize with the way instances work
07:57:26 <earthy> peaker: plan9 is actually quite impressive from a 'how much you can get done from base principles' point of view
07:57:28 <Peaker> nand`, how do you install stuff?
07:57:29 <chrisdone> Philippa: synthesized attributes? . o O ( what grammar would that be, without recursion…? )
07:57:36 <merijn> ciaranm: I fail to see how that's relevant from a language perspective?
07:57:37 <nand`> Peaker: using my distro's package manager
07:57:50 <nand`> which does a better job than cabal-install imo; and is cabal-aware itself
07:57:54 <Peaker> earthy, what do you mean? IIRC, plan9 is unix where more stuff are mapped to file system namespaces and file descriptor operations?
07:57:57 <Philippa> chrisdone: as in Attribute Grammars. Turned out to be the name for the concept I was grasping for :-)
07:58:02 <ciaranm> merijn: the question is really "do they have a powerful enough language to do generics or templates or whatever yet?"
07:58:09 <Philippa> basically, data only propagates bottom-up, node-at-a-time
07:58:14 <chrisdone> Philippa: ah, perfect, let me look that up. heard of it, never looked at it
07:58:15 <merijn> Peaker: They have a proper distributed filesystem and remote operations using them too
07:58:29 <merijn> ciaranm: You don't have those in C either
07:58:36 <ciaranm> merijn: exactly
07:58:36 <Peaker> merijn, what's a "proper distributed file system" and is that part of the OS project, or just happened to be implemented on plan9 and can be ported?
07:58:46 <Philippa> (with grammar extensions having covered any top-down stuff you're supposed to give a shit about)
07:58:50 <Peaker> ciaranm, C has "qsort"
07:58:52 <nand`> Peaker: for example, it automatically rebuilds broken or outdated packages (after, say, a GHC upgrade); allows for reverse-dep-cleaning (uninstalling orphaned packages no longer needed), etc.
07:58:58 <Philippa> as planned, it's not powerful enough to do 'case compilation', make sense?
07:59:04 <merijn> ciaranm: Go's niche is aimed at "C, but nicer and slightly less low level"
07:59:15 <Philippa> (though at this rate I risk tending awk-ward)
07:59:17 <Peaker> nand`, yeah, cabal install ought to have handled that :)
07:59:21 <ciaranm> Peaker: yeah, if your data happens to be in an appropriate enough layout for void * to work
07:59:48 <nand`> merijn: hilariously failing at everything C is used for
07:59:53 <ciaranm> merijn: sure, but even ada had a sane way of implementing a "sort an array of X for any comparable X"
07:59:57 <Peaker> ciaranm, sort in these languages is basically always on a homogenous array, and that's all that's assumed there
08:00:45 <merijn> Peaker: It's build in to the OS. The network and all machines attached to it are treated as one thing (afaik), so running it on one machine is just the special case of running Plan9 on a 1 machine network
08:00:46 <nand`> ciaranm: re: sorting; no, you just have to implement the “Sortable” interface or whatever which exposes ≤ and swap(int, int) or something
08:00:52 <merijn> nand`: I disagree
08:01:17 <Peaker> merijn, does it automatically migrate processes around between systems?
08:01:31 <merijn> Peaker: I don't know
08:01:41 <Peaker> merijn, if it's just a better-NFS, it can probably be ported
08:01:51 <nand`> merijn: I had the feeling C was used for interfacing with native code (something Go still requires ugly plan9 assembly for last time I checked, unless its tools have matured) as well as stuff like manual memory access (ie. if you're implementing a garbage collector for another language)
08:02:35 <nand`> ciaranm: oh, which of course makes the sort() procedure in go very slow since it has to route through all of those virtual interface calls
08:02:45 <nand`> I think I measured something like 19x overhead last time I checked
08:02:49 <ciaranm> youch
08:02:57 <ciaranm> c's overhead is down to a factor of 3 on modern CPUs
08:03:30 <nand`> ciaranm: oh; and the type signature uses interface{} which is go's equivalent of “void* I will check at runtime”
08:03:38 <merijn> nand`: We have a language runtime implemented in C, which would be a lot nicer and more extendable in Go. We don't really need manual memory management, but languages like Haskell or Python would be right out for the implementation
08:03:46 <nand`> it's an ugly hack
08:04:19 <nand`> merijn: Haskell RTS running in a Haskell RTS running in a RTS running in a ...
08:04:25 <nand`> What's it's RTSs all the way down
08:04:27 <nand`> What?*
08:04:32 <Catnaroek> Is there any easy way to download the Haskell platform for those of us who do not have a desktop/window manager?
08:04:34 <merijn> nand`: I'm not really aware of a lot of other languages that would fit that niche
08:05:05 <bartavelle> Catnaroek, wget ?
08:05:13 <nand`> merijn: this is just my impression either way, I won't continue pretending I know anything about “low-level” languages
08:05:27 <Catnaroek> bartavelle: Yeah, but how do I obtain the URL to wget in first place?
08:05:44 <nand`> Catnaroek: links
08:05:44 <merijn> C has just to much baggage for this usecase
08:05:52 <bartavelle> use a text mode browser or ask here ;)
08:06:15 <bartavelle> what's your os ?
08:06:33 <merijn> Like no namespaces, include headaches, that sorta thing
08:06:56 <harrison> tacgnol ftw!
08:07:18 <nand`> merijn: I agree in that respect; C carries way too much baggage and in my opinion also ambiguous semantics
08:07:50 <harrison> C is a cross between an abomination and a monstrosity
08:08:04 <harrison> only ugly
08:08:11 <nand`> C is just old
08:08:21 <nand`> people did not have as much experience with monstrosities back then
08:08:31 <harrison> C allows pointer aliasing
08:08:36 <harrison> C is not typesafe
08:08:49 <ciaranm> c is state of the art early 1960s technology!
08:10:06 <harrison> But of course a systemslevel typesafe language is possible
08:10:22 <ciaranm> sure. it's called ada.
08:10:27 <ciaranm> and we all know what happened there.
08:10:30 <harrison> um, no
08:10:42 <harrison> guess again
08:10:46 <nand`> you can easily be “type safe” by having a trivial type system, after all
08:11:15 <harrison> You can also make a trivial comment on IRC. Thank you for sharing.
08:11:54 <wingy> one of the answers explaining it well (the above one): http://programmers.stackexchange.com/questions/117276/example-of-where-functional-programming-is-superior-to-imperative-or-object-orie
08:12:04 <harrison> Is there an OS written in ada that runs on metal?
08:12:19 <ciaranm> well no, because there are no complete programs written in ada
08:12:52 <Peaker> C is more type-safe than Python.. and using some trickery, you can make C much more type-safe
08:12:57 <harrison> wingy: you bring up an important point by demonstrating a common error in thinking
08:13:00 <Yarou> C is fine and can be quite elegant, notwithstanding its flaws due to datedness
08:13:02 <Peaker> C cannot encode sum-types, but it can encode catamorphisms of sum types, for example
08:13:12 <roconnor> Peaker: yoneda?
08:13:21 <wingy> harrison: like?
08:13:26 <harrison> namely, that on the one hand we have C and on the other, FP
08:13:37 <Peaker> roconnor, not sure what yoneda is, but you can have the "maybe" function in C, but not the Maybe type
08:13:49 <Peaker> (maybe function that's already applied to a Maybe value, at least)
08:13:54 <Peaker> And using a struct-of-one-element, C supports "newtype" for safety, too
08:13:55 <harrison> and that for type safety and GC we need to transcend imperative languages
08:13:58 <roconnor> that's okay.  I'm not sure what Yoneda is either :)
08:14:13 <harrison> which is laughably horribly wrong
08:14:37 <harrison> i like and am attracted to FP in general and haskell in particular
08:14:38 <tac-tics> roconnor: Isn't Yoneda one of those really deep mathematical theorems in category that no one who it would be useful to actually understands?
08:14:50 <Peaker> if you want to write:  f :: Int -> Maybe Char    in C, you can write:    void f(int x, void (*nothing)(void *), void (*just)(void *, char), void *);
08:14:50 <Yarou> isn't that every mathematical theorem?
08:14:52 <roconnor> tac-tics: maybe
08:15:21 <Peaker> IOW, using trickery, C can become somewhat type-safe :-)
08:15:25 <harrison> but it just is stupid to say that C is inevitable given the need for an imperative systems language
08:15:38 <tac-tics> Yarou: Not true. I used the Hairy Ball Theorem of topology to make my friends laugh.
08:15:46 <bartavelle> C is inevitable given the need for a simple effective language
08:15:55 <harrison> and haskell should not call into C when it needs speedy loops
08:16:01 <harrison> C is horrible and ugly
08:16:12 <bartavelle> I disagree, I just find it horrible
08:16:14 <nand`> for some definition of “simple” and “effective” we evidently do not share
08:16:26 <Peaker> harrison, C has justifications for its horribleness and ugliness, it was designed before anyone knew better.  Java, otoh...
08:16:28 <harrison>  C is inevitable given the need for a simple effective language: bartavelle is playing misere' here
08:16:35 <Clint> C is lovely
08:16:40 <MostAwesomeDude> As usual, I'm obligated to point out that you're all on Freenode. :3
08:16:48 <bartavelle> depends on the application, when you are mostly moving bytes around C code will be nicer than almost all languages
08:16:58 <harrison> ahf, good morning MostAwesomeDude
08:17:17 <nand`> bartavelle: erlang :)
08:17:20 <c_wraith> C is a disaster. It made all the wrong choices at standardization-time, making things complicated that shouldn't have been.  (see: all "undefined behavior")
08:17:21 <MostAwesomeDude> harrison: Yes, it is morning! I am up. Somehow.
08:17:21 <harrison> you at least know whereof which I speak of
08:17:36 <harrison> I don't assert that you care.
08:17:47 <ciaranm> yoneda's not that bad
08:18:06 <nand`> c_wraith: I've always been under the impression that it was the cost for allowing architecture-specific low-level programming, as contradictory as it sounds
08:18:13 <Peaker> c_wraith, UB has important advantages. Java cannot compete with C in some niches because it doesn't have UB
08:18:25 <MostAwesomeDude> harrison: I quite literally just woke up.
08:18:31 <harrison> OK, what language would one choose for a realtime raytraced sierpinskicube flythrough demo?
08:18:40 <harrison> UB?
08:18:41 <ciaranm> algol
08:18:54 <harrison> algolicious
08:18:54 <Peaker> harrison, undefined behavior
08:18:54 <ciaranm> java has UB!
08:19:01 <nand`> harrison: Haskell
08:19:05 <ciaranm> on floating point stuff where you don't use strictfp
08:19:28 <tac-tics> Probably should have been using a decimal type in the first place.
08:19:48 <harrison> nand`, i accept your challenge! please establish a repository for our new project
08:19:51 <Peaker> c_wraith, for example, a signed int having UB for overflow means a compiler can optimize: (x < x + MACRO) away.  Signal processing code can assume no overflows occur, and I read that accounts for a factor of 2 speed improvement over equivalent Java loops doing the same computations
08:19:53 <tac-tics> Because now you have $50.02222222222222... in your bank account
08:19:53 <harrison> i will pull it
08:20:23 <nand`> harrison: if you pay me, sure :)
08:20:40 <ciaranm> will you accept $0.022222222222...?
08:21:21 <nand`> harrison: (no guarantees)
08:21:45 <Philippa> Peaker: having room to set aside types that allow you to make those assumptions is good, yes
08:21:53 <Philippa> OTOH, you can make /Coq/ do that
08:21:58 <Philippa> you just assert that it's allowed to
08:21:59 <c_wraith> Peaker: an appropriate low-level language would give you tools to address that explicitly.  And yes, they'd be architecture-specific.  But you already *have* to write architecture-specific code for correctness in C.  It would have been better to flip the assumptions and correct behavior portable, but optimizations platform-specific.
08:22:24 <c_wraith> *make correct behavior portable, that is
08:23:04 <Peaker> c_wraith, how do you address that explicitly?
08:23:10 <Philippa> c_wraith: the part where we know better than cpp nowadays is important too, of course
08:23:16 <ahf> harrison: thanks, i guess
08:23:17 <ahf> :-P
08:23:18 <harrison> nand`, you misunderstand as usual
08:23:22 <Philippa> (C with an MLish module system is instantly a much more pleasant language!)
08:23:32 <harrison> i have the algorithm already
08:23:44 <harrison> we will only be porting
08:23:45 <Peaker> c_wraith, you could have UB-variants and no-UB variants for operations, and only use the UB ones when you need the speed. Or otherwise you could just use C only when you need the speed
08:23:50 <Philippa> harrison: there comes a stage where you should consider whether you might be part of the communication problem, y'know
08:23:50 <harrison> thus
08:23:56 <harrison> you can pay me
08:24:01 <c_wraith> Peaker: I haven't tried to solve the problem.  But I'm sure it can be done.
08:24:02 <harrison> IN GRATITUDE
08:24:23 <Kruppe> I've only just learned about lenses (been a while since I've done any FP), what's the best library for lenses to play with?
08:24:34 <harrison> Philippa: says the chatter with a name that evokes invective
08:24:39 <Peaker> c_wraith, ah, I don't think it's fair to criticize a solution that lets the optimization take place as horrible unless you have an alternative/better solution.  "horrible" is in fact a relative term
08:24:48 <parcs`> Kruppe: data-lens or fclabels
08:25:10 <Kruppe> parcs`: Thanks! I'll check them out.
08:25:10 <c_wraith> Peaker: you don't need *undefined* behavior, ever, though.
08:25:12 <Philippa> harrison: huh, that's the first time anyone's told me that. Am I more infamous than I thought?
08:25:36 <MostAwesomeDude> Kruppe: data-lens is pretty awesome.
08:25:45 <harrison> http://en.wikipedia.org/wiki/Philippic
08:25:47 <Peaker> c_wraith, maybe if you can use Coq style proofs, but without that, the compiler either has to generate checks or trust the programmer something does not happen. The former implies slow, the latter implies UB
08:25:49 <Philippa> or is this just "zomg, we have a woman using her first name as her nick!"?
08:26:00 <ciaranm> clearly it's "zomg, someone is pretending to be female"
08:26:06 <ciaranm> because there are no girls on the internet
08:26:08 <harrison> A philippic is a fiery, damning speech, or tirade, delivered to condemn a particular political actor. The term originates with Demosthenes, who delivered several attacks on Philip II of Macedon in the 4th century BC.
08:26:10 <c_wraith> Peaker: you just need how the platform chose to implement the behavior the spec didn't specify.
08:26:16 <Philippa> we can read the link, harrison
08:26:33 <harrison> Oooh. snap!
08:26:39 <Peaker> c_wraith, but that would mean you couldn't optimize (x < x+MACRO) away, for example
08:26:53 <c_wraith> Peaker: it could if you were using operations that defined it to be correct.
08:27:03 <Peaker> c_wraith, and the compiler may not be able to do equational-reasoning optimizations in the presence of defined wrap-arounds
08:27:05 <Kruppe> MostAwesomeDude: I'm looking at it now, documentation seems a little on the slim side though.
08:27:26 <Peaker> c_wraith, but if you define it in the way the platform actually handles it -- you get wraparounds, which ruin all the equational reasoning/etc
08:27:41 <chrisdone> ciaranm: actually that rule is a common mistelling, it's actually “no *gerbils* on the internet”—which is a sensible rule, they haven't got the dexterity to type
08:27:41 <Peaker> c_wraith, and if you define it in a way the underlying platform doesn't handle it, you get slowness
08:27:52 <Philippa> harrison: tell you what, you start playing nice and I'll continue to. Trolling people about their actual, RL names? Not appropriate behaviour in here
08:27:59 <parcs`> Kruppe: fclabels is probably easier to use if you are new to lenses. it has examples, lens-deriving functions and good documentation
08:28:44 <Kruppe> parcs`: Yeah, looking up these two libs, it seems data-lens might be better once I have a handle on them
08:28:49 <Peaker> fclabels and the monomorphic lens libs are not very useful, IMO.  The new lens ideas seem promising though
08:28:51 <c_wraith> Peaker: yes, slowness.  whatever.  So you still have to write platform-specific code to recover the speed on platforms that don't support the ops your generic code did.  But that's not different than C today anyway.
08:29:22 <harrison> What actual, RL names? What trolling? Please be more specific.
08:29:24 <Peaker> c_wraith, Not sure why you claim you have to write platform-specific code? The only thing I can think of is having different optimal word sizes?
08:29:27 <c_wraith> Peaker: the point is, claiming *undefined* behavior is a fix for this is 100% wrong.  It's just a lazy hack to avoid having to think.
08:29:39 <Peaker> c_wraith, I'd agree if I saw a better solution
08:29:51 <bartavelle> harrison, he is Philip II of Macedo
08:30:15 <Peaker> c_wraith, I agree that UB is a bad idea if you don't need the speed. But it's good to have a language with low-level operations and a good optimizer that's allowed to assume a lot
08:30:24 <harrison> Oh, him! His son's horse's name is Bucephalus, right?
08:30:31 <Peaker> and UB is the mechanism that allows the optimizer to assume a lot
08:30:32 <c_wraith> Peaker: you don't see it because it's in libraries.  But the amount of architecture-specific code is rather immense, given differences in instruction sets between even "x86" CPUs out there today.
08:30:46 <Philippa> harrison: Stop playing the idiot, if you're honestly incapable of working out that my nick isn't actually a nickname after my earlier comment then you're not smart enough to play "piss off the ops without getting in trouble"
08:31:11 <Peaker> c_wraith, I write a lot of C code, and the platform-specific stuff is very small.. the libraries we use for atomic operations are platform-specific but are rather miniscule
08:31:14 <harrison> Philippa, try "/nick mingeywhiner"
08:31:26 <Philippa> nah, I have a better idea
08:31:31 --- mode: ChanServ set +o Philippa
08:31:40 --- mode: Philippa set +b *!*@2602:306:cd2c:320:d227:88ff:fe57:5a7c
08:31:50 --- kick: harrison was kicked by Philippa (you were asked to play nice, you chose not to)
08:32:01 --- mode: Philippa set -o Philippa
08:32:07 <Peaker> woah, that's the first ipv6 ban I've ever seen
08:32:24 <bartavelle> which means it will probably not be that effective
08:32:29 <nand`> wait, ISPs have already figured out IPv6? What is the world coming to?
08:32:34 <MostAwesomeDude> I didn't want to say anything in advance, but he's been a dick in other channels in the past.
08:32:56 <bartavelle> anyway, C is actually pretty nice when you have to write architecture specific code
08:33:12 <bartavelle> I might be unimaginative but I don't believe it can get much better than that
08:33:12 <nand`> funny for an architecture independent language
08:33:22 <Philippa> mmm. Funny how assertion is suddenly whining if your european name's got an a at the end, too
08:33:33 <nand`> (I suppose the alternative is lots of machine-specific languages which I'm not sure is an improvement)
08:33:35 <Peaker> MostAwesomeDude, hey, do you still do more Python than Haskell or have you become more of a Haskeller?
08:33:49 <c_wraith> Peaker: all you need is language that supports a broad variety of explicit behavior.  Heck, you could do it with pragmas or compile flags.  "in this file, integer math doesn't overflow".  Whatever.  It's just moving from implicit dependency on the platform to explicit dependency on the platform, allowing correct (but slow) behavior on other platforms.
08:34:00 <Philippa> (with apologies to various people here who that applies to but are nevertheless male...)
08:34:12 <Peaker> c_wraith, if you use "doesn't overflow" pragma and generate an overflow, what happens?
08:34:38 <bartavelle> exactly, why would you want to do that ?
08:34:49 <Peaker> c_wraith, dare I say, UB? :)
08:34:52 <c_wraith> Peaker: whatever it's defined to do.  clamp, probably.  The point is, you define the behavior.
08:35:10 <bartavelle> if you want to make sure you do not overflow either use operations that don't, or check before doing the operations
08:35:18 <Peaker> c_wraith, well, if it is still defined behavior such as clamping -- that means the compiler cannot optimize freely, equational reasoning does not work as well in the face of clamping
08:36:04 <Philippa> bartavelle: this may come as a shock, but sometimes you want to just write the code that assumes it
08:36:09 <Peaker> c_wraith, and your pragma isn't useful if the compiler can't assume it won't overflow
08:36:17 <bartavelle> Philippa, then don't write C I suppose
08:36:23 <Peaker> c_wraith, and still has to make sure it acts as though it was clamped in case it does
08:36:25 <bartavelle> I write C when I want to be sure my + will be an "add"
08:36:33 <bartavelle> but I suppose not many people is it as a "nice assembler"
08:36:55 <c_wraith> C is a terrible assembler.  It's very far from how modern CPUs work.
08:36:58 <nand`> assembly should be a prerequisite to learning C, mind
08:36:59 <Philippa> well yeah, it's a shitty assembler that happens to be moderately portable as anyone who knows CPS knows
08:37:04 <bartavelle> c_wraith, not at all
08:37:10 <bartavelle> depends of what you do
08:37:11 <Peaker> bartavelle, C is not really so direct w.r.t assembly. Your + may become ADD, or it may become LEA. Your * may become add in a loop, if the optimizer is lucky, and so forth
08:37:32 <bartavelle> my example is programming the sse instructions with intrinsics
08:37:40 <ninegrid> whats the difference between playing with something like CloudHaskell vs zeromq-haskell?
08:37:41 <c_wraith> where's the MFENCE instruction in C?
08:37:44 <bartavelle> if you are not using a horrible compiler, you are pretty sure of what will happen
08:37:52 <bartavelle> except it is more readable than the corresponding asm file
08:38:17 <chrisdone> a real scotsman knows what his c will output
08:38:22 <Peaker> bartavelle, do you know the "embedded in academia" blog and his C compiler work?
08:38:28 <bartavelle> yes
08:38:31 <Philippa> chrisdone: yeah. Demons, from his nose
08:38:33 <nand`> c_wraith: I don't know what MFENCE is in particular but usually such exotic things are exposed via intrinstic functions that aren't actually functions
08:39:00 <Peaker> bartavelle, it shows quite nicely that it's not so easy to know what code does in the face of UB and what it will compile to. The optimizer can rip away chunks of the program due to non-trivial reasons
08:39:07 <c_wraith> nand`: it's hardly exotic.  It's a basic building block for writing any kind of correct multi-processor code.
08:39:28 <bartavelle> I fully agree. However you still have much more control than any language I know of.
08:39:34 <nand`> I say “exotic” here to mean “not the product of an arguably equivalent C semantic's compilation”
08:39:55 <nand`> I know that for example stuff like SSE2 optimization is done via intrinsics, but I don't know how related that is to MFENCE
08:39:57 <c_wraith> nand`: so, you're saying C is not expressive enough to cover what CPUs do these days?
08:40:28 <nand`> c_wraith: I doubt C is expressive enough to cover what CPUs did when it was introduced
08:41:29 <bartavelle> If you want a good example of compiler "optimizing away" stuff, resulting in public humiliation, there is this : http://www.pcworld.com/article/140064/hacker_uses_sony_playstation_3_to_crack_passwords.html
08:42:03 * hackagebot derive 2.5.9 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.9 (NeilMitchell)
08:42:05 <ninegrid> are CloudHaskell and ZMQ orthogonal?  If I understand it correctly, zeromq is just a transport lib and CloudHaskell gives you something more... I'm trying to figure out what that "something more" is
08:42:50 <c_wraith> ninegrid: cloud haskell is about making haskell more like erlang - adding the ability to simply pass messages between independent processes.
08:43:10 <c_wraith> ninegrid: it takes care of things like the serialization format for you.  That's the part zeromq doesn't
08:43:21 <ninegrid> ok
08:43:39 <c_wraith> ninegrid: and things like managing a mapping between logical processes and network locations
08:43:56 <Peaker> does Cloud Haskell do the "graceful failure handling" Erlang is famous for?
08:43:57 <bartavelle> if the haskell zeromq bindings is just that (bindings), you still have a lot of work before your messaging system is done
08:43:59 <chrisdone> Peaker++
08:44:11 <c_wraith> Peaker: it does not.  "more like"...  not "like" :)
08:44:14 <Peaker> chrisdone, bottle-related? :)
08:44:20 <ninegrid> bartavelle: that's true
08:44:21 <chrisdone> :-)
08:44:24 <bitonic> Peaker: erlang is not graceful at all. it's just resilient. it's really good at restarting stuff
08:44:33 <chrisdone> i'm showing all my friends, it's like christmas when you get a great toy
08:44:35 <ninegrid> c_wraith: it seems my efforts would be best spent tinkering with cloudhaskell then
08:44:45 <Peaker> chrisdone, cool! :-)
08:44:50 <donri> bottle mo
08:44:59 <Peaker> chrisdone, so you generated a "where" via apply-of-lambda? :)
08:45:20 <nand`> bartavelle: it does have a few abstractions as far as I remember; it's not a straight-up IO () translation of every single procedure
08:45:37 <nand`> but it's not awfully high level either
08:45:46 <Peaker> chrisdone, btw, did you try switching between branches with mild differences, such that it animates the changes between them?
08:45:56 <chrisdone> Peaker: i did indeed :-)
08:46:05 <nand`> equivalent Haskell code will, of course, still be shorter than the same ZeroMQ calls in C :)
08:46:08 * chrisdone wipes the drool from his keyboard
08:46:09 <Philippa> I gather the idea was to port eg the error handling bits of OTP to Cloud Haskell?
08:46:18 <Peaker> chrisdone, :-)
08:46:22 <Philippa> (by which I mean: that's the impression I had from the Fun in the Afternoon talk about it earlier this year)
08:46:33 <chrisdone> donri: http://github.com/Peaker/bottle
08:46:56 <Peaker> chrisdone, next we want to restrict the operations to type-sane ones.. instead of allowing any edit anywhere, allow stuff that makes sense w.r.t types
08:47:11 <nand`> oh, is this that Haskell structural editor?
08:47:13 <Peaker> chrisdone, currently space lets you add arg anywhere, but it should probably just jump to next hole or such
08:47:35 <donri> http://bottlepy.org/docs/dev/ ;)
08:48:02 <chrisdone> Peaker: right. i tried that out, noticed List Integer→List Integer let me write x*x inside it. that would be interesting to deal with
08:48:21 <Peaker> chrisdone, yeah, we added types relatively recently, still didn't have a chance to make them meaningful w.r.t editing
08:48:32 <Peaker> chrisdone, also inferred types and annotated types don't interact well yet
08:48:37 <MostAwesomeDude> Peaker: I'm on the fence. Still mostly Python 'cause of the day job though.
08:48:43 <Peaker> and we might have way too many type annotations on screen
08:48:53 <jfischoff> Peaker: just sent you a screenshot of a small display issue
08:49:09 <chrisdone> Peaker: sure-- possibly just a matter of configuration?
08:49:14 <Peaker> MostAwesomeDude, it took me maybe a couple of years of Haskelling to leave Python completely for Haskell
08:49:36 <jfischoff> ditto for me with ruby
08:49:43 <chrisdone> donri: it's what i've been raving about for months on end about the future of editors :p
08:49:48 <Peaker> chrisdone, you'd probably want to be able to configure "show/hide all types", but not sure what the default should be
08:49:59 <donri> chrisdone: aha!
08:50:03 <chrisdone> donri: one less project i have to produce :)
08:50:07 <donri> cool
08:50:15 <Catnaroek> Hello. Could anybody please give me the link to download the Haskell platform? I mean the link to the compressed tarball itself, not to the download page, which for some reason I cannot open in lynx.
08:50:23 <nand`> Peaker: do bottle require an X server or can it run in a “smart” serial console?
08:50:26 <nand`> does*
08:50:43 <MostAwesomeDude> Peaker: I don't know if Haskell will ever become my Get Shit Done language.
08:50:44 <Peaker> jfischoff, basically type-variables get an arbitrary name from their guid if they aren't associated with a name. and the inferred types are always new entities so are never associated with a name. We better copy the associated name from the original definition and/or generate new names
08:50:48 <Peaker> nand`, it uses OpenGL
08:50:53 <srhb> Catnaroek: http://lambda.haskell.org/platform/download/2012.2.0.0/haskell-platform-2012.2.0.0.tar.gz
08:51:02 <Catnaroek> Thank you, srhb. :)
08:51:11 <nand`> Peaker: I see. That translates to needing an X server for my OpenGL implementation as well
08:51:12 <srhb> Catnaroek: You're going to need GHC 7.4.1 to compile it
08:51:18 <chrisdone> Peaker: right. i feel the need to play with it more to see how much i actually use the types, maybe even a mere keypress to toggle display of them would be good, as an idea
08:51:25 <Peaker> MostAwesomeDude, ah, it's a really great get-shit-done language once you get past the fight-ghc-a-lot stage :)
08:51:31 * chrisdone takes a screenshot for donri
08:51:34 <jfischoff> Peaker: aye
08:51:38 <Catnaroek> srhb: Are there no binary distributions?
08:51:39 <tac-tics> MostAwesomeDude: Haskell has the requisite number of blog posts for it, but you still need to spend too much time learning shit you don't actually need
08:51:46 <chrisdone> then you proceed to fight-cabal-a-lot which lasts forever
08:51:56 <srhb> Catnaroek: Yes, but you asked for the tarball.
08:52:05 <Catnaroek> Oh.
08:52:11 <MostAwesomeDude> No, I mean, I use Python for shell scripts. I will not likely ever do that with Haskell.
08:52:35 <Catnaroek> srhb: Sorry for wasting your time twice, but could you give me the link to the binary distribution instead?
08:52:40 <srhb> Catnaroek: Which one?
08:52:46 <bartavelle> MostAwesomeDude, that's what I thought. I use to mostly write shell and perl. Now I do haskell everytime I can. And I am a sysadmin.
08:53:03 <srhb> Catnaroek: I think you can browse this page in text mode: http://hackage.haskell.org/platform/linux.html
08:53:04 <Catnaroek> srhb: Linux.
08:53:09 <Peaker> MostAwesomeDude, Haskell is pretty nice for shell scripts..   e.g: mapM_ deleteFile $ walk (somePath </> ".tmp")    shorter than python and safer than shell
08:53:22 <srhb> Catnaroek: Yes, well.. Which flavor. But you can find it yourself on that page :-)
08:53:22 <Catnaroek> srhb: I tried browsing that page, and it says some temporary file could not be decompressed or something like that.
08:53:26 <Peaker> MostAwesomeDude, at least if you make a nice ShellImports thing you can import openly at the top
08:53:43 <MostAwesomeDude> Peaker: You picked a weird way to spell $ find -name .tmp -exec rm {} +
08:53:46 <srhb> Catnaroek: Ah. Which distro are you on then
08:53:47 <MostAwesomeDude> But okay.
08:53:51 <Peaker> MostAwesomeDude, yeah, I just made an example up as I wrote it :)
08:53:52 <Catnaroek> srhb: Arch. But I do not want to download the HP from Arch's repos. I already had bad experiences mixing Debian and cabal packages.
08:53:55 <jfischoff> Calling external processes is more work in haskell the ruby
08:54:06 <jfischoff> in ruby `ls -all`
08:54:07 <donri> MostAwesomeDude: find -delete? :)
08:54:11 <nand`> the “Arch Linux” link on that download page 404s
08:54:18 <nand`> which is interesting
08:54:19 <srhb> Catnaroek: You're on the tarball then
08:54:24 <Peaker> consider instead: e.g: mapM_ (\x -> renameFile x (atBaseName  (reverse x))) $ walk (somePath </> ".tmp")    shorter than python and safer than shell
08:54:25 <srhb> Catnaroek: Get a binary ghc to compile it.
08:54:34 <Catnaroek> srhb: Oh, okay. :)
08:54:39 <srhb> Catnaroek: http://www.haskell.org/ghc/download_ghc_7_4_1#binaries
08:54:41 <bartavelle> jfischoff, well the cool stuff with haskell is that instead of calling an external process and be done with it, you rewrite it and enjoy 2 weeks of programming ;)
08:54:53 <Catnaroek> srhb: ty :)
08:55:02 <Peaker> jfischoff, Backticks in Ruby call system processes?
08:55:10 <jfischoff> Peaker: yeah
08:55:14 <Peaker> ouch :)
08:55:22 <Peaker> I guess that's a Perlism from the dark ancestry?
08:55:26 <jfischoff> yep
08:55:31 <bartavelle> also in perl and php, that makes the holy trinity of unreadable languages
08:56:30 <jfischoff> Peaker: shell scripting could be much better in Haskell, but I don't think we are there yet, or at least I'm not there yet.
08:56:33 <donri> in turn probably from the shell itself
08:56:46 <nand`> Peaker: Which of these two packages does bottle depend on? BerkeleyDB or berkeleydb? They seem to be distinct (as per hackport), with one having the latest version at 0.8.5 and the latter at 2008.10.31
08:56:50 <jfischoff> Peaker: but I haven't tried shelly or any shell prog lib
08:56:51 <Peaker> nand`, the former
08:57:24 <donri> @hackage shqq -- only wish it was syntax checked, which would be possible to add
08:57:25 <lambdabot> http://hackage.haskell.org/package/shqq -- only wish it was syntax checked, which would be possible to add
08:57:27 <Clint> chrisdone: what's the deal with wordcloud?
08:57:36 <nand`> Peaker: okay. now I just have to figure out how to tell hackport which one I want
08:57:44 <quicksilver> surely backticks calling processes is a shellism
08:57:51 <quicksilver> not a perlism nor a rubyism.
08:57:53 <jfischoff> donri: that's cool
08:58:37 <jfischoff> quicksilver: true
08:59:21 <Peaker> quicksilver, well, Ruby isn't a shell language, so you wouldn't expect it to have Shellisms. But it does have many Perlisms
08:59:30 <nand`> you can actually overload the `` in ruby to do neat stuff
08:59:56 <chrisdone> Clint: abandoned and left for dead in a gutter
08:59:58 <chrisdone> Clint: why?
08:59:59 <Philippa> and some Perlisms are consciously adopted Shellisms
09:00:09 <Clint> chrisdone: i was just looking for something to do tag clouds
09:00:33 <savask> Hello. I'm making a program which uses HNN as neural network library, and I have a question: how do I dump network's state to a file? Neurons weights are in UArr, but I couldn't find functions to transfer UArr to list.
09:01:19 <chrisdone> Clint: maybe it still works, not sure
09:01:21 <quicksilver> Peaker: it might be that perl was the first non-shell to support a shell-like backtick.
09:01:21 <lispy> hello
09:01:28 <Peaker> savask, it'd probably be a good idea to use Data.Binary (binary package) or Data.Serialize (cereal) to serialize the array
09:01:31 <Clint> chrisdone: doesn't seem to
09:01:32 <quicksilver> certainly nothing earlier than that springs to mind
09:01:49 * lispy tries to imagine people using perl as an interactive shell
09:01:53 <savask> Peaker: But does it work with UArr?
09:02:23 <pooya72> any way to get rid of the annoying " " when using fromJust?
09:02:32 <Peaker> savask, http://hackage.haskell.org/packages/archive/cereal/0.3.5.2/doc/html/Data-Serialize.html  says it has an instance of UArray
09:03:03 <jfischoff> pooya72: not sure what you mean there
09:03:06 <quicksilver> pooya72: ? fromJust doesn't insert spaces... what do you mean?
09:03:18 <savask> Peaker: Hmm, I thought that UArr (http://hackage.haskell.org/packages/archive/uvector/0.1.1.1/doc/html/Data-Array-Vector-UArr.html#t:UArr) and UArray are different types.
09:04:03 <pooya72> no I mean the quotes. lets say x = Just "hello" when I use fromJust x i get "hello" but i want hello
09:04:18 <quicksilver> that's not related to fromJust
09:04:18 <Peaker> savask, oh, they might be, I was assuming too much :)
09:04:22 <pooya72> no quotation marks
09:04:26 <quicksilver> that's related to how you choose to print strings.
09:04:38 <quicksilver> if you use 'show' or 'print' it will add quotation marks and escapes
09:04:43 <quicksilver> because that is the purpose of those functions
09:04:47 <quicksilver> if you just use putStrLn it will not.
09:04:55 <savask> Peaker: That's not good for me :< Such a good library, and no way to save network's state.
09:05:06 <rwbarton> people still use uvector?
09:05:51 <Peaker> savask, I can't seem to install uvector.. it seems to only build on older GHC's
09:06:00 <rwbarton> savask, can't you call indexU a lot?
09:06:01 <jfischoff> rwbarton: I'm completely ignorant on all things relating to Haskell and performance, what should people use?
09:06:30 <savask> rwbarton: Not a good idea, to my mind.
09:06:31 <rwbarton> well i think vector has superseded uvector
09:06:43 <donri> pooya72: is this in ghci?
09:06:49 <Peaker> That's what the hackage page of uvector says -- "use vector"
09:06:58 <rwbarton> okay, so you don't really mean "how do I", you mean "how do I efficiently"
09:07:04 <rwbarton> I guess?
09:07:12 <pooya72> woops never mind, yeah quicksilver was right, i had thrown in a show, and that was giving the extra " " quotaitons
09:07:26 <rwbarton> won't writing to a file cost more than calling indexU a lot anyways?
09:07:40 <savask> Peaker: I'm not sure, but I just installed hnn from git repo. Hackage says that neurons use UArr.
09:08:09 <rwbarton> were you able to build hnn?
09:08:11 <savask> I'll better check if it is so now, maybe something changed.
09:08:14 <rwbarton> what version of GHC are you using?
09:08:15 <savask> Yep.
09:08:17 <Peaker> hnn depends on uvector indeed :(
09:08:33 <savask> rwbarton: 7.4.1
09:09:06 <savask> Peaker, rwbarton - false alarm, new HNN uses Vector.
09:09:12 <Peaker> Apparently Vector has no instances of Binary/Serialize
09:09:24 <savask> Just hackage version is smaller.
09:09:39 <rwbarton> aha, right
09:09:43 <savask> Peaker: But it might be easier to work with it though.
09:09:55 <chrisdone> donri: check this homie https://dl.dropbox.com/u/62227452/Movies/bottle.ogv
09:10:03 <Peaker> savask, you could instantiate Serialize or Binary for Vector yourself
09:10:37 <savask> Peaker: Vectors are read and show instances, so maybe later :-P
09:10:50 <Peaker> savask, ah heh
09:12:16 <donri> chrisdone: thanks
09:12:34 <nand`> Peaker: so where do go to find out how to use bottle?
09:12:54 <nand`> I compiled it without build errors but I'm unsure what comes next
09:13:00 <Peaker> nand`, run dist/build/Editor/Editor
09:13:07 <nand`> I did
09:13:17 <nand`> I see a mostly empty window with some lines and boxes
09:13:17 <Peaker> nand`, ah, you get a legend of possible actions... just try stuff :)
09:13:28 <Peaker> nand`, press <enter> to rename "foo" to "fac"
09:13:28 <chrisdone> do a barrel roll
09:14:11 <Peaker> nand`, press <space> to make the parameter.  Change the Red hole to an "Integer" type (under the name of the parameter). Press "=" to move to RHS. Then use "if" on it, before you give if any args, press enter on it to see its definition and its type (the type var is explicit)
09:14:53 <nand`> I'm confused. This is what I see: http://sadpanda.us/images/1045301-S0YQGMM.png
09:15:54 <Peaker> nand`, hmm.. seems like there's some kind of problem, perhaps with text rendering
09:15:59 <Peaker> nand`, did you see any text at all?
09:16:02 <chrisdone> looks like it doesn't fit on the screen
09:16:04 <nand`> no
09:16:17 <nand`> I see no text. Do you think my .fonts.conf may be the issue?
09:16:20 <chrisdone> nand`: try resizing the window
09:16:24 <nand`> I have known it to cause issues before
09:16:42 <Peaker> nand`, maybe the font rendering causes all text to have 0-width
09:16:42 <chrisdone> oh yeah it is unrendered text
09:16:54 <Peaker> nand`, so yeah, it is likely
09:16:55 <nand`> if I resize the window the top-left stays the same but the bars at the bottom left and bottom right move to the new edges
09:16:58 <nand`> I see
09:17:03 <donri> hey all fonts are monospaced at 0-width
09:17:07 <monochrom> heh 0-width font
09:17:16 <Peaker> nand`, I'm using FTGL, it's probably using your ~/.fonts.conf
09:17:22 <nand`> Peaker: do you have a way of overriding the font in particular without relying on my editing my .fonts.conf?
09:17:29 <nand`> that is what I do in mplayer to fix a similar situation
09:17:37 <Peaker> nand`, I load a particular .ttf file, and hand it to FTGL for rendering
09:17:44 <Peaker> nand`, maybe a different TTF file would work
09:17:54 <nand`> uh yeah, I get a flood of “FTGL warning: NULL pointer in _ftglRenderFont”
09:18:04 <Peaker> nand`, Main.hs has "defaultFont", you can try to change that
09:18:18 <nand`> ah, I don't have the source code in front of me
09:18:35 <Peaker> nand`, how did you build?
09:19:03 <nand`> using my distro's package manager, which pulled the sources from git internally and built them in a temporary directory
09:19:10 <nand`> I could pull/build it manually though
09:19:23 <nand`> Peaker: just a wild guess: maybe it doesn't handle monospaced fonts very well?
09:19:25 <Peaker> nand`, that should be easy if the dependencies are installed
09:19:27 * monochrom had the idea of a 1-width font. each character takes up just 1 pixel. the exact colour tells you which character it is.
09:19:36 <Peaker> nand`, it's not monospaced
09:19:47 <Peaker> monochrom, fonts don't have colors, I think :)
09:20:09 <monochrom> yeah I guess I bend the meaning of font :)
09:20:19 <nand`> Peaker: have a glance at my .fonts.conf https://github.com/nandykins/gentoo-conf/blob/master/.fonts.conf
09:20:43 <Peaker> nand`, I'm not an expert on fonts, I just render via FTGL/drawing-combinators and they do the rest :)
09:20:48 <nand`> I see
09:20:59 <Peaker> nand`, I do see that the rendering you get is consistent with a situation where the text has no width
09:21:01 <nand`> but note that Terminus is a bitmap font which can't be scaled (reasonably)
09:21:03 <chrisdone> monochrom, fonts don't have colors,
09:21:05 <chrisdone> monochrom fonts don't have colors,
09:21:07 <chrisdone> still works
09:21:13 <osfameron> hah
09:22:23 <monochrom> haha
09:22:59 <nand`> I got rid of my .fonts.conf; I still see no text. I still get the NULL pointer errors in _ftglRenderFont
09:23:10 <nand`> so it must be some other issue
09:23:36 <nand`> I'll try building manually
09:25:35 <nand`> Peaker: I do not have /usr/share/fonts/truetype on my system; that must be the cause
09:25:59 <nand`> I don't have “FreeSerifBold.ttf” anywhere in my /usr/share/fonts folder, for that matter
09:26:11 <Peaker> nand`, ah, easy to fix then :)
09:26:52 <donri> i suppose an interesting side-effect of this kind of code editor is that you can use proportional fonts
09:27:24 <Peaker> donri, yeah, alignments are no longer a chore
09:27:29 <nand`> I changed it to “/usr/share/fonts/terminus/ter-u14n.pcf.gz” in hopes it would work, unfortunately that segfaulted upon launching Editor :)
09:27:47 <Peaker> nand`, I don't know if FTGL can handle that.. try a TTF file?
09:28:07 <Peaker> a bit sad if FTGL segfaults :-(
09:28:50 <nand`> ah
09:28:54 <nand`> that is immediately much, much better
09:29:00 <nand`> now I see lots of text
09:29:03 <Peaker> nand`, :-)
09:29:29 <nand`> text is huge though, is that intentional?
09:29:40 <Peaker> nand`, I like big fonts :-)
09:29:50 <Peaker> I press Ctrl++ 6 times at every new web page I visit :)
09:30:06 <Peaker> and those that lock the font size get an extra C+w after that
09:30:07 <pooya72> so I seem to be doing a lot of type transformations between String , ByteString and Text. Is there an easy way to manage them all?
09:30:08 <donri> Peaker: you know you can configure the base size of your browser?
09:30:19 <Peaker> donri, nope :)
09:31:06 <monochrom> use Text internally. encode/decode to Bytestring just at I/O boundaries
09:31:07 <mm_freak> <Peaker> I press Ctrl++ 6 times at every new web page I visit :) ⇐ statements like this always remind me how little sense mutable variables and updates like ++ make
09:31:13 <Peaker> donri, I don't see such an option in Chrome
09:31:38 <rwbarton> @karma x
09:31:38 <lambdabot> x has a karma of 6
09:32:17 <donri> Peaker: show advanced settings, web content
09:32:46 <donri> also means you can zoom only the font so images don't get scaled
09:33:18 <Peaker> donri, ah, "Very Large" saves me about 3 Ctrl+'s :)
09:33:38 <donri> Peaker: you can further click "customize" :P
09:33:44 <Peaker> heh, ya
09:34:09 <Peaker> donri, ok, now the fonts are enlarged, but the other elements are small, so it looks all wrong
09:34:17 <Peaker> e.g: upvote/downvote arrows are tiny, next to huge text
09:34:28 <pooya72> monochrom: I think my problem is that snap uses ByteString alot
09:34:35 <donri> Peaker: i thought that'd be a good thing, but if not you can change page zoom instead of font size
09:34:38 <mm_freak> Peaker: if you have firefox, you can set a minimum font size
09:35:05 <mm_freak> unfortunately it can destroy the layout of poorly designed webpages
09:35:11 <rwbarton> maybe you need to adjust what X/your desktop environment thinks your screen dpi is
09:35:18 <pooya72> monochrom: and I was using Text
09:36:16 <nand`> I force all rendered text to be 14 pt terminus, and don't let websites choose their own fonts, sizes or colors :P
09:36:21 <nand`> it makes for a much more pleasurable viewing experience
09:36:37 <nand`> Peaker: I'm still left utterly confused. I'll probably have to watch a video or something on how this works
09:36:59 <Peaker> nand`, do you see the legend of possible keys?
09:37:13 <nand`> I'm trying to define a fac function with pattern matching as an example. So far I've stumbled my way into producing “fac 0 = 1” with “Integer” written below it, but that's about where it stops
09:37:15 <nand`> Peaker: I do
09:37:35 <Peaker> nand`, basically you navigate, and use <space>, [, ], to add args, <return> to jump-to-definition or rename (if on definition), \ for lambda-wrapping,
09:37:43 <Peaker> nand`, there's no pattern matching support yet
09:38:03 <Peaker> nand`, you can use "if" but you'll have to manually instantiate the type variables (they're explicit as of yet)
09:38:27 <Peaker> i.e:  fac (x : Integer) = if Integer (x == 0) 1 (x * (fac (x - 1)))
09:38:44 <DMcGill> in the same way that for = flip map, is there a nice `flip filter'?
09:38:48 <Peaker> you can press <return> on the "if" after choosing it, and it will show you its full type (along with the explicit type variable)
09:39:00 <Peaker> DMcGill, nope
09:40:16 <nand`> I'm having trouble navigating, eg. if I press hjkl to move around it takes me into various input modes all the time and I have to press escape to get back out. I don't think the factorial function is supposed to look like this :( http://sadpanda.us/images/1045338-YZUAUQ0.png
09:41:05 <nand`> ah, at least “ctrl+z” works to take me back to where I was before I screwed up
09:41:31 <Peaker> nand`, various input modes? what do you mean?
09:41:59 <Peaker> nand`, if you navigate with hjkl it doesn't actually enter text-editing/rename mode anywhere
09:42:06 <Peaker> nand`, oh, unless you enter a hole
09:42:15 <Peaker> nand`, the red boxes that grow into completion lists when you enter them are "holes"
09:42:22 <DMcGill> you know you've been doing too much Haskell when: while writing a sentence you put a word in brackets and then go to take them out because brackets are only for grouping
09:42:25 <nand`> DMcGill: yes, I enter those constantly
09:42:25 <Peaker> nand`, you're supposed to fill them in and press <return>
09:42:52 <nand`> I see
09:43:04 <nand`> that explains my troubles
09:43:09 <nand`> the screen is full of holes :)
09:43:12 <Peaker> :)
09:43:28 <Peaker> nand`, maybe you'd prefer explicit entering into holes.  For that,  codeedit/Editor/CodeEdit/ExpressionEdit/HoleEdit.hs:358, can change FocusDelegator.Delegating to FocusDelegator.NotDelegating
09:43:45 <Peaker> nand`, and then when you enter a hole you'll have to press <return> to edit the hole
09:44:13 <nand`> yes, that is much much better
09:45:07 <Mortchek> nand`, what program is that?
09:45:15 <nand`> how do I properly input a type? “Integer -> Integer” produces “Integer” “-> Integer” with the second highlighted red
09:45:17 <nand`> Mortchek: bottle
09:45:41 <Peaker> nand`, yeah, that part is very rough for now... you have to select "->" first, and then fill in the arg/result type.. Terrible, will be fixed :)
09:46:04 <c_wraith> Peaker: yikes. :)
09:46:13 <nand`> Peaker: if it helps, here's some feedback right off the bat: I'm used to normal editors, I'd expect to be able to type just like a normal editor. Any structural editor should at least appease to people used to normal editors; I didn't write the thing and have absolutely zero clue how to input things, even with the list at the bottom right
09:46:15 <Peaker> nand`, the fonts there are terrible :)
09:46:30 <nand`> I'd like to, say, write “fac :: Inte” and have that automatically jump to the type
09:46:36 <Peaker> nand`, I agree mostly -- and we did work on some features to make it respond to text input similarly to the way a text editor would
09:46:36 <nand`> so I don't have to escape, navigate, <enter> manually
09:46:48 <nand`> yes that would be a vast improvement imo
09:46:52 <Peaker> nand`, though the "fac : " part will disappear and the type will be only under the underline
09:47:14 <Peaker> nand`, for example, when you write:  "fac" <space> "x" "="  it will generate:   fac x = <hole>
09:47:28 <Mortchek> Where is that program available?
09:47:37 <Peaker> https://github.com/Peaker/bottle
09:47:39 <nand`> Peaker: so I have to say it is a function first, then define the types of its operands?
09:47:45 <nand`> if I understand correctly (and that is how I did it)
09:47:47 <nand`> for the type
09:47:49 <Peaker> nand`, yes, until we fix it
09:48:10 <nand`> Peaker: Ctrl+c should act as Escape
09:48:11 <Peaker> nand`, later you'll be able to just type "Integer", <space>, "->", ...
09:48:29 <nand`> Help, I typed “if” for the body and my screen is now scary
09:48:37 <Peaker> hehehe
09:48:46 <Peaker> nand`, yeah, it's not type-directed enough yet
09:48:59 <nand`> I get huge red boxes underneath the function full of stuff like <b833..> -> <b833..> -> <b833..>
09:49:01 <Peaker> nand`, later if you have an "Integer->Integer" function, and you use "if", it will immediately make all the param holes as needed
09:49:09 <nand`> as well as stuff like “Integer”, “Bool”, “Set” mixed in between
09:49:13 <Peaker> nand`, yeah, that's an anonymous type-variable
09:49:18 <nand`> so how do I use “if”?
09:49:24 <Peaker> if : (a : Set) -> Bool -> a -> a -> a
09:49:25 <nand`> how do I write “if n == 0 then foo else bar”?
09:49:39 <Peaker> nand`, you have to instantiate the type variable explicitly (for now), so you write:
09:49:48 <Peaker> "if Integer (n == 0) foo bar"
09:49:55 <Peaker> ("if" is just a function with no special syntax, too)
09:50:18 <Peaker> nand`, remember it's very preliminary, just proof-of-concept. we're aware it is not very usable yet :)
09:51:10 <nand`> now I'm stuck, I have “if” “Integer” with a line “Set” below it, then ( then “n” with a “<box> Integer <box> -> Bool” below it, then another hole with my cursor and “-> n fac' ...” below it
09:51:14 <nand`> but I can't input ==
09:51:19 <c_wraith> Peaker: are you going to advertise on HN and then start a kickstarter drive? (never did get the fuss over light table..)
09:51:45 <Peaker> c_wraith, nah, we don't want to raise money because then we are bound to whoever gave us money. We can afford to spend our time on it for now
09:51:56 <nand`> Peaker: oh, that edit you suggested to me I think had the adverse side effect of not automatically entering holes I create with, say, space - I still want those to auto-focus, I just don't want the same to happen while navigating with hjkl
09:52:28 <Peaker> c_wraith, and so we're completely unchained to work on it as we think is best
09:52:31 <nand`> if that makes sense. While in navigate mode, I should be “free”
09:52:47 <Peaker> nand`, yeah, I predicted that might happen. If you want I can make a branch like that for you :)
09:53:00 <nand`> no no, I'm just giving opinions
09:53:07 <nand`> I doubt I will use the editor any time soon, with all due respect
09:53:31 <nand`> it seems too crazy and counter-intuitive to really be practical for now; I'll stick to vim
09:53:58 <Dtgr> can i implement + function for a type without making it a member of Num?
09:54:00 <nand`> to emphasize again: if you can make an editor that just allows me to type haskell like I normally would in vim and have that transformed to structural representation on the fly, that would be amazing
09:54:09 <nand`> Dtgr: not without redefining (+)
09:54:13 <nand`> which will then not be the same
09:54:30 <Dtgr> okay.
09:54:39 <nand`> :t (+)
09:54:40 <lambdabot> forall a. (Num a) => a -> a -> a
09:54:44 <Peaker> nand`, it's preliminary, it will be far more intuitive in the future
09:54:49 <nand`> the function itself requires Num (because that's where it's defined)
09:54:55 <nand`> Peaker: that is good to hear
09:54:56 <Peaker> nand`, but some habits will probably have to change
09:55:04 <nand`> Peaker: also make it work at smaller font sizes :)
09:55:10 <Peaker> nand`, there are many old artifacts in text editing whose existence is just an accident :)
09:56:02 <nand`> Peaker: I think what I would personally like is a “transitionary” editor that works like a normal editor but shows me these cool type annotations and hints and all of that flashy stuff as I edit, somewhere where it won't bother me much
09:56:06 <bourbaki> Does haskell allow me to have control on the memory layout of data?
09:56:21 <tac-tics> bourbaki: no.
09:56:28 <Peaker> nand`, I think we just need to be lighter on the visual noise
09:56:37 <bourbaki> What is the reason for that?
09:56:41 <Peaker> nand`, and make it more type-directed, so type errors don't happen all the time
09:56:55 <tac-tics> bourbaki: Haskell has no native notion of "memory" at all. (Although GHC Haskell may have low-level extensions which do)
09:56:58 <Peaker> Haskell does give some limited control
09:57:02 <nand`> Peaker: Yes, it's also more important to let the user know what exactly is what. I see a box and I have no idea what's supposed to go there
09:57:09 <nand`> since I'm unfamiliar with the semantics
09:57:29 <nand`> so I don't know if I'm expected to fill in a type there, or a body, or a name, or whatever
09:57:39 <Peaker> nand`, note that under each hole box you get the type that box is supposed to have
09:57:50 <Peaker> nand`, though a learning curve of minutes should cover those things :)
09:58:01 <Peaker> (the holes are all completion boxes, basically)
09:58:06 <bourbaki> I thought about writing a small path tracer in haskell using parallel execution but i still wonder in general if you can make something like this efficient in execution time and memory usage.
09:59:05 <nand`> I'm still trying to figure out how to write if (n == 0); typing ‘(’ doesn't seem to do what I want it to do
09:59:06 <Peaker> nand`, non_delegating_holes -- has the feature
09:59:21 <Peaker> nand`, you need: "if Integer (n == 0)"
09:59:44 <Peaker> nand`, oh and use '[' in the hole rather than '(' since '(' is usable for searching functions
09:59:47 <nand`> right now I have “if Integer _” where _ is a box with “Bool” written below it - so far so good
09:59:50 <nand`> oh
09:59:54 <Peaker> maybe we need to avoid '(' for searching
10:00:04 <Peaker> it's somewhat useful to differentiate infix from prefix, though types could do the same job, probably
10:00:22 <Peaker> oops, I messed up!
10:00:26 <bourbaki> tac-tics: What extension is it you where referring to?
10:00:26 <Peaker> you can't search for "=="
10:00:35 <Peaker> let me push a fix :)
10:01:12 <tac-tics> bourbaki: I don't know, since I don't use low-level stuff. But haskell, in the most general sense, isn't supposed to touch memory. I would look at the FFI extensions.
10:02:05 <nand`> now I have “if Integer (n _)” where n has “[red box] \n Integer \n [red box] -> Bool” below it and _ is a bright red box
10:02:09 <nand`> how do I get from this to n == 0
10:02:20 <Peaker> nand`, I messed up a few commits ago
10:02:24 <Peaker> nand`, so can't search for equals
10:02:31 <Peaker> I'll fix it in a couple of minutes :)
10:02:35 <bourbaki> tensorpudding: cool nick :)
10:02:38 <nand`> I see
10:03:24 <monochrom> "parallelized path tracer" doesn't seem to require the control-freak kind of memory layout control
10:04:16 <nand`> Peaker: alright. I'll start with a simpler function, say f :: Integer; f = (2 *)
10:04:31 <Peaker> nand`, pushed
10:04:40 <Peaker> f :: Integer -> Integer
10:04:41 <nand`> Peaker: how do I de-clutter the screen? I have all of these “experiments” open that I want to delete entirely
10:04:50 <Peaker> nand`, alt-W to remove panes
10:04:50 <bourbaki> \leave
10:04:55 <nand`> or stuff like “Integer : Set; Integer = Prelude.Integer”
10:04:58 <nand`> which I no longer care about
10:04:58 <hayashi> yay, installing haskell-platform from FreeBSD ports.  This is going to be a long wait
10:05:07 <nand`> (or rather opened accidentally)
10:05:18 <Peaker> there's no way to actually delete stuff yet (and with revision control, it is not that meaningful to delete, unless you squash it with the creation later)
10:05:52 <Peaker> anyway, alt-w closes panes. Alt-up/dn is useful to move the thing you're editing to where you want it
10:05:54 <semigroup> How can I write this in such a way that it is :: * -> *? type WithParam a = (->) String (IO a)
10:06:31 <nand`> Peaker: well, say I'm worried about disk space wasted by all of those functions I wrote once only to backspace later when I realized they were either impossible or useless :P
10:06:34 <Peaker> semigroup, what you wrote is the same as: type WithParam a = String -> IO a
10:07:03 <Peaker> nand`, heh, we plan to have auto-squash of old history and I guess create+delete which are squashed together can truly be deleted
10:07:30 <semigroup> Peaker, right, and I'm wanting to use that as an instance of a type class whose parameter is * -> *. It seems like it should be possible
10:07:59 <Peaker> semigroup,   WithParam a :: *   and a :: *    therefore: WithParam :: * -> *
10:08:43 <Dtgr> can i implement + function for a type without making it a member of Num?
10:08:45 <Peaker> semigroup, though it is a type-synonym. Maybe you want to make it a newtype if you want to instantiate it
10:08:49 <Dtgr> .. wrong terminal :)
10:08:57 <tac-tics> Is there any compelling reason why you can't create an IORef "purely"?
10:09:10 <semigroup> Peaker, that would defeat the point of what I'm doing if I have to wrap it.
10:09:17 <nand`> tac-tics: wait, how would that work?
10:09:21 <Peaker> tac-tics, a = ioRef,  b = ioRef,   a == b?
10:09:30 <tac-tics> Peaker: thanks :)
10:09:40 <tac-tics> That was the answer I was looking for.
10:10:35 <Peaker> nand`, did you manage to make the == now?
10:10:45 <Peaker> nand`, also I pushed the branch with the hole behavior you want
10:11:09 <nand`> Peaker: I'm currently trying to remember how to merge in a git branch
10:11:22 <nand`> (I want the new hold behavior branch's commits in master)
10:11:24 <Peaker> git pull   will update your current branch (e.g: master)
10:11:37 <Peaker> git merge origin/non_delegating_holes
10:11:43 <Peaker> will put the commits in master
10:11:45 <nand`> ah, that
10:11:50 <nand`> I was trying git merge non_delegating_holes
10:12:03 <Peaker> that would work if you had a local branch by that name
10:12:17 <nand`> right, but I never fetched it
10:12:57 <Peaker> git checkout non_delegating_holes   is a nice short-cut that creates a local branch that follows the remote branch
10:15:29 <nand`> I made a mistake while typing, and now have: fac n = if Integer (n == 0) 1 (n * (n - 1)). I want to change this to (n * fac (n - 1)). How do I “insert” something like that? space only adds it at the end
10:16:25 <nand`> also the ‘1’ is highlighted red for some reason. I don't quite get it
10:16:45 <Peaker> nand`, you can use shift+left to mark (n - 1)
10:16:57 <Peaker> nand`, and then press ] to apply a function on it
10:17:08 <nand`> I see
10:17:20 <nand`> ah, I see [ and ] in the legend now
10:17:26 <nand`> these things make sense *after* I'm shown how to use them
10:17:30 <Peaker> maybe we ought to allow standing on the '(' and press space there too
10:18:02 <Peaker> we'll do deeper "usability studies" when we focus on the UI. currently we're focusing on fundamentals still
10:18:11 <nand`> Okay. I seem to have successfully defined this function. Lots of overhead, and the ‘1’ is still highlighted red
10:18:22 <Peaker> nand`, press enter on the '1'
10:18:31 <nand`> oh
10:18:35 <Peaker> nand`, '1' searches for functions with '1' in their name
10:18:38 <nand`> that's odd, I pressed enter twice and it's no longer red (green instead)
10:18:40 <Peaker> if you press enter again it becomes the literal
10:18:44 <nand`> I see
10:18:51 <Peaker> first enter -> dive into hole,  second enter -> select first search result (literal 1)
10:19:35 <Peaker> in the master branch it's just 1 enter :)
10:19:37 <nand`> there are still some oddities with the new hole behavior, btw
10:19:55 <Peaker> which?
10:20:02 <Peaker> oddities that is
10:20:06 <alex404> Is there a way to apply a list of arrows to a list of inputs?
10:20:14 <nand`> for example at some points it didn't automatically enter the hole, I'm not sure when; I think it was when defining the () with [, or when jumping from the LHS to the RHS of =
10:20:35 <nand`> alex404: what do you mean by “arrows”?
10:20:48 <Peaker> nand`, ah, I may have missed some things.. each thing that makes a hole needs to specify where to go independently
10:20:54 <Peaker> nand`, I guess it better be indirected by an abstraction
10:21:04 <alex404> nand`: It's a control structure like monads
10:21:37 <alex404> Or maybe i can restate and say is there a way to feed a list of inputs into a list of arrows such that we get an arrow from and to a list?
10:21:49 <nand`> alex404: I was thrown off by the word “apply”
10:21:54 <Peaker> alex404, map arr ?
10:22:13 <Peaker> alex404, oh, which context are you using arrows in?
10:22:34 <alex404> Peaker: They're these automaton arrows
10:22:38 <alex404> nand`: Fair enough
10:22:50 <alex404> So I wouldn't think I could just map them...
10:23:12 <Peaker> alex404, write the Haskell type you're looking for
10:23:16 <nand`> I'm still not sure how you “feed a list of inputs” into a list of arrows. Aren't arrows just there to be composed?
10:23:27 <nand`> (among others)
10:23:32 <jfischoff> There is ArrowApply
10:24:12 <Peaker> Arrow in its current form is just an awkward way to represent Category+Applicative
10:24:23 <alex404> [Automaton a b] -> Automaton [a] [b]
10:24:28 <alex404> I guess it's that simple yah
10:25:06 <alex404> Peaker: I don't know about awkard. It does some things very well.
10:25:14 <Peaker> alex404, what things? :)
10:25:41 <alex404> Peaker: I certainly could be wrong, but this automaton thing I think is pretty great.
10:26:23 <alex404> Peaker: For modelling synchronous circuits with internal state
10:26:35 <jfischoff> Peaker: you can get first and second for cat+applicative?
10:26:41 <nand`> Peaker: you need to fix what happens with the window is not wide enough to display the function
10:26:42 <alex404> Peaker: It's the only task I would think to use arrows first
10:26:46 <nand`> I can move the cursor off-screen
10:26:54 <alex404> Peaker: for
10:27:22 <Peaker> nand`, yeah, for that we need to fix the graphics-drawingcombinators library.. can't support scroll yet (I guess except full-screen scroller)
10:27:53 <Peaker> jfischoff, Arrow is essentially fully described by Category, "arr" and "***"
10:28:11 <Peaker> jfischoff, Category+Applicative has Category, so we just need to get "arr" and "***"
10:28:22 <Cale> Peaker: hmm, how do you get first from that?
10:28:32 <Peaker> first = (***id)
10:28:46 <Cale> oh, right, silly me :)
10:28:49 <nand`> What do you mean by “Category + Applicative”? What's the applicative here?
10:29:46 <Peaker> nand`, I mean I could write, in pseudo-Haskell:  instance (Category cat, Applicative (cat a)) => Arrow cat where ...
10:32:10 <jfischoff> Peaker: so how do you express with (***) with applicative?
10:32:38 <nand`> I'm more confused about “arr”. I mean, I can use pure to get a b (b -> c); but how do I get from that to a b c?
10:33:01 <nand`> ah, wait
10:33:05 <nand`> I can use category's id with <*>
10:34:14 <Peaker> (`fmap` Control.Category.id)  :: (Functor (cat a), Category cat) => (a -> b) -> cat a b
10:34:39 <Cale> Arrow should really have a lot more stuff in it than it presently does though. It relies too much on arr for structural stuff that it shouldn't have to.
10:35:04 <nand`> right, pure f <*> id = fmap id f
10:35:15 <nand`> uh
10:35:16 <nand`> fmap f id even
10:37:00 <Peaker> had to re-figure it out, but :-) here goes:
10:37:21 <Peaker> ab *** cd = liftA2 (,) (ab . arr fst) (cd . arr snd)
10:37:25 <Peaker> (and we already have arr)
10:41:21 <jfischoff> okay that makes sense. I thought you were making a different claim. That Applicative forms a combinative monoid with the product type the way Arrow does.
10:43:11 <dgpratt> have any of you folks had success installing the BerkeleyDB package on Windows?
10:43:40 <jfischoff> s /combinative/communative
10:43:50 <Cale> commutative?
10:44:13 <jfischoff> commutative
10:44:35 <Cale> jfischoff: Arrow as described in the paper has very weak laws
10:45:16 <Cale> In particular, it doesn't have (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k)
10:46:08 <Philippa> Cale: agreed re arr, that's especially dire as we refit our typeclasses for ConstraintKinds
10:46:58 <Cale> I think that Arrow ought to look a lot more like the definition of a symmetric (or braided, maybe) monoidal category.
10:47:30 <jfischoff> yeah and with arrow choice you get a semiring
10:47:37 <jfischoff> like category
10:48:26 <jfischoff> Cale: Something I wrote a little while ago https://takeittothelimit.files.wordpress.com/2012/03/semiring.pdf
10:48:43 <jfischoff> Cale: not useful though
10:50:55 <deech> Hi all, in an IO-enabled monad transformer is there any difference between using "trace ..." to print a message to console vs. using "liftIO $ putStrLn ..."?
10:51:19 <Botje> Debug.Trace.trace ?
10:51:25 <Botje> that prints to STDERR, not STDOUT
10:51:25 <deech> Botje: yup
10:52:28 <deech> Botje: That doesn't really matter to me. I was thinking more about order of evaluation issues.
10:53:35 <nand`> “The calls succ maxBound and pred minBound should result in a runtime error.”
10:53:37 * nand` cries
10:54:12 <mroman> nand`: You'd expect wrap-around?
10:54:27 <nand`> that's even worse
10:54:35 <alex404> Peaker: Do you really feel like arrows are such a write off? Due you know about this synchronous circuit stuff?
10:54:43 <Clint> you'd expect id?
10:54:44 <mroman> well... then?
10:54:52 <nand`> I'd want the type signature changed
10:54:54 <nand`> to -> Maybe
10:54:59 <mroman> of succ?
10:55:03 <alex404> Peaker: I'm trying to imagine how to reformulate that in terms of arrows and categories and I can't...
10:55:06 <Cale> alex404: The circuit stuff makes a lot more sense once you extend Arrow with some additional laws and methods.
10:55:16 <nand`> mroman: to clarify, Enum should be distinguished between bounded and nonbounded
10:55:23 <alex404> Cale: How do you mean?
10:55:38 <nand`> then again, all of these solutions are ugly
10:55:48 <mroman> there probably aren't many unbounded enums?
10:55:55 <alex404> Cale: I can't say I have a very deep grasp of these stuff, but the circuit stuff makes sense to me I feel.
10:56:07 <Peaker> alex404, Arrows in their current form are equivalent to Category+Applicative, but have less libraries, and are less well studied, etc.  Thus I think it's better to consolidate on the existing classes everyone use
10:56:07 <alex404> Cale: And the arrow notation allows a very intuitive expression of it.
10:56:30 <Peaker> (or fix the arrow class)
10:56:40 <alex404> Peaker: Fair enough.
10:56:50 <Cale> alex404: Presently, Arrow is not required to satisfy that naturality law: (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k), which basically means that if you're thinking of your Arrow computations as circuits, the way that you draw the circuit diagram (and not just how things are connected together) is allowed to affect the result :(
10:57:39 <Cale> You can see that this fails for things like the Kleisli arrow for most monads (any noncommutative monad)
10:57:55 <Cale> because the effects in g and h will occur in a different order in either case
10:58:54 <alex404> I see your point about the law... but how could that be fixed?
10:59:19 <Cale> (I appear to be severely lagged)
10:59:19 <mm_freak> it could be fixed by disallowing arrows that don't satisfy it
10:59:31 <mm_freak> however, that would also rule out a lot of useful stuff
10:59:41 <alex404> Anything besides Kleisli arrow?
10:59:58 <Cale_> hmm
11:00:01 <alex404> And laws are not things that can be tested be the type system, right?
11:00:05 <Cale_> alex404: Well, HXT probably fails.
11:00:13 <mm_freak> netwire would fail
11:00:35 <Cale> Most FRP arrows should succeed
11:00:43 <Cale> and parsers too
11:00:56 <Cale> (I think!)
11:01:05 <mm_freak> yampa would succeed, but netwire wouldn't…  at least not in general…  it would succeed over a commutative monad
11:01:20 <alex404> Right... that's basically what I like about arrows, FRP style programming
11:01:23 <alex404> But I see the problem
11:01:42 <alex404> The whole point with modelling synchronous circuits is modelling nodes with isolated state
11:02:12 <alex404> Which is a principle that can be broken if one is not careful...
11:02:23 <mm_freak> i don't think you would want to program a lot of AFRP using arrow style
11:02:32 <mm_freak> arrow style is ugly in general
11:02:38 <Cale> alex404: The reliance on arr for structural transformations on pairs also means that anything written with the proc/do notation will in general be impossible to do dynamic analysis of any kind on.
11:02:56 <Cale> which is really unfortunate, as that is one of the main advantages Arrow would have as a notation over Monad
11:03:41 <Cale> Essentially, your arrow computations end up with lots of opaque lambdas in the middle of them, and so are impossible to optimise.
11:04:12 <mm_freak> Cale: my solution to that is to just avoid Arrow and use Applicative instead
11:04:29 <Cale> With a few additional primitives, it would be possible to limit that to only the cases where you do complex pattern matches or put complex expressions on the right of -<
11:04:40 <mm_freak> x &&& y = liftA2 (,) x y
11:04:54 <mm_freak> if you replace (,) by something else you prevent the tuple from being created in the first place
11:04:58 <Cale> That's like giving up though.
11:05:14 <mm_freak> i don't think so…  applicative style looks much more declarative
11:05:23 <Cale> It's not about how it looks in this case
11:05:34 <Cale> It's about the ability to inspect your computations before running them
11:06:09 <mm_freak> well, you could also say that you want automatic optimization of something you could prevent easily in the first place =)
11:06:35 <alex404> Cale: What do you recommend at this point though? I've been loving modelling circuits with arrows, but, especially if I'm interested in performance, I should avoid them and somehow retrofit things to (cat+applcative)?
11:06:41 <mm_freak> even if you would have that machinery, on the source level you still deal a lot with tuples
11:07:36 <mm_freak> alex404: /modelling/ circuits doesn't work with arrows anyway…  you would want to use a DSL for that
11:07:47 <mm_freak> arrow computations are opaque
11:07:51 <mm_freak> a DSL is not
11:07:57 <mm_freak> (necessarily)
11:08:02 <Cale> alex404: Well, heh, you could repeat a lot of the work we did at IPwn redesigning an Arrow hierarchy and writing our own preprocessor :P
11:08:30 <Cale> But eventually we want to release that stuff in some form.
11:09:21 <Cale> I'll paste our Control.Arrow replacement...
11:09:52 <hpaste> Cale pasted “Arrow redesign” at http://hpaste.org/70533
11:11:04 <Cale> That's generalised over () and (,), though I'm not sure if that's actually necessary (it was possible, so we did it :)
11:12:44 <alex404> Cale: Well, I do sort of have a mini DSL based on http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
11:12:55 <alex404> Where the only members that I'll be using pass through the accum function
11:14:25 <alex404> Cale: But anyway, you mean to release that work at some point? I can't say I grasp all the subtleties of this discussion...
11:14:32 <mm_freak> alex404: what he defines there is the automaton arrow
11:14:39 <alex404> I know
11:14:44 <Cale> yeah
11:15:00 <mm_freak> (just with a slightly awkward result order)
11:15:01 <Cale> alex404: That tutorial was written by my coworker :)
11:15:17 <alex404> Cale: Tell him/her I think it's awesome.
11:15:34 <alex404> Cale: Though based on this discussion I now feel deceived!
11:15:43 <Cale> Nah, everything there is true :)
11:16:02 <Cale> That law I mentioned holds for *some* arrows
11:16:22 <Cale> but it would be a lot nicer if the syntax sugar translation could rely on it
11:16:31 <alex404> I see what you're saying
11:16:42 <Cale> (and people could rely on it in reading the notation)
11:16:59 <alex404> But are there serious optimization problems? Is it possible to write effecient programs in the style proposed in that tutorial?
11:17:11 <Cale> Depends on how efficient
11:17:12 <alex404> That's what's freaking me out at the moment because I've generated a lot of code based on this stuff :)
11:17:21 <mm_freak> it would make the notation more declarative…  and you could probably even reorder the intermediary relations
11:17:36 <mm_freak> the optimization problems are fairly serious
11:18:07 <Cale> It's more like Arrow kinda not living up to its promise relative to what Monad etc. do.
11:18:20 <mm_freak> an applicative-style wire gets FPS numbers above the 100 million
11:18:21 <Cale> You can have fairly efficient Monad code
11:18:25 <alex404> mm_freak: What would? Switching to an applicative style? Is it possible to model circuits/automatons using them?
11:18:28 <Cale> it's just Arrow is supposed to be able to do better
11:18:37 <mm_freak> the same wire in arrow style is up to two orders of magnitude slower
11:19:05 <Cale> mm_freak: proc/do or not?
11:19:10 <mm_freak> alex404: sure, that's what i do
11:19:19 <mm_freak> Cale: with proc/do
11:19:29 <mm_freak> even without you have to construct the tuples
11:19:51 <Cale> mm_freak: Yeah, but there's a lot of extraneous plumbing
11:20:06 <alex404> mm_freak: What do you do? Can you show me the way? ;)
11:20:25 <mm_freak> alex404: i'm the author of netwire, another AFRP library
11:20:42 <alex404> mm_freak: Oh, of course. We had a long discussion about netwire once upon a time
11:20:54 <alex404> mm_freak: Couldn't remember why your name was familiar
11:21:02 <mm_freak> Cale: the problem is that the combinators in Arrow are inherently based on tuples
11:21:08 <mm_freak> you can't do without
11:21:34 <mm_freak> even when you write combinator style (which makes you code unreadable in general)
11:22:13 <mm_freak> that's also the reason why netwire nowadays focusses on applicative style instead
11:22:32 <alex404> That's what I was wondering
11:22:34 <alex404> The last release
11:22:38 <alex404> Which I toyed with for a while
11:22:46 <alex404> Was all about automaton arrows
11:22:55 <mm_freak> alex404: AFRP is based on that arrow
11:23:37 <mm_freak> yampa's SF arrow is equivalent to Auto, and netwire's Wire arrows are a generalization of it
11:24:16 <alex404> mm_freak: Yah. What's the status of netwire these days though? And if I have a bunch of code relying on it written in an arrow style, are you saying I should reformulate it in an applicative way?
11:24:47 <xplat> one problem with applicative is it's not as clear what the 'generalized' version corresponding to generalized arrows would be
11:24:54 <mm_freak> alex404: netwire 4 is about to be released, which is pretty much applicative, but using arrow style will always be an option and in some cases even mandatory (keyword: ArrowLoop)
11:25:02 <Peaker> xplat, what are generalized arrows?
11:25:37 <xplat> Peaker: arrows without arr, but with some combinators for rearranging product (and possibly sum) types
11:26:20 <mm_freak> alex404: it uses a new concept to allow pure wire computations that obey the law Cale mentioned, depending on what underlying functor you use (it's not an arrow transformer anymore)
11:26:33 <Cale> mm_freak: You can do things to eliminate all the spurious cases of tuples though
11:26:41 <Peaker> xplat, ah, that is indeed a different beast than Applicative, I think
11:27:19 <mm_freak> Cale: i could reinvent what your company has done, but that would be a lot of work, and i don't see the advantage…  with the new combinators applicative style is really convenient and amazingly declarative
11:27:26 <Peaker> xplat, I think Applicative/Arrow let you be inside a lambda's lexical context, and thus have implicit inputs that are not apparent in the type.  Arrow-without-arr makes all inputs fully explicit
11:27:27 <timthelion> As a non math background person, what might I read to figure out what you guys are talking about?
11:27:37 <mm_freak> Cale: it also outperforms even netwire 3
11:27:39 <timthelion> ;)
11:27:50 <alex404> mm_freak: I'm glad to see the project is still alive and well. When do you think it will be released?
11:28:04 <alpounet> mm_freak, any sample to show?
11:28:07 <mm_freak> alex404: this or next week
11:28:17 <Peaker> xplat, though that may be wrong, it's just an intuition I have developed and haven't thought through
11:28:40 <alpounet> timthelion, the typeclassopedia
11:28:41 <mm_freak> alpounet: i'm afraid not yet…  i'm currently reimplementing the prefab library, which is a lot of work…  then i'll be able to show examples
11:28:43 <Peaker> mm_freak, Why not ApplicativeLoop? :)
11:28:45 <alpounet> this isn't much about math really
11:28:55 <alpounet> mm_freak, cool
11:29:04 <alpounet> please ping me when you have a few examples to show
11:29:16 <mm_freak> alpounet: just read the -cafe =)
11:29:23 <mm_freak> Peaker: because using 'loop' explicitly is for masochists =)
11:29:25 <alpounet> ah right you announce them
11:29:34 <Cale> timthelion: hmmm... what do you already know about Arrow/Applicative/etc.?
11:29:47 <timthelion> alpounet: thanks
11:29:58 <timthelion> Cale: I know nothing about them :)
11:30:00 <mm_freak> timthelion: if you want, i can point you to my unfinished arrow tutorial…  people seem to like it
11:30:11 <mm_freak> but it requires that you understand monads
11:30:15 <Cale> Ah, yeah, I agree typeclassopedia would be a good place to start if you haven't read it
11:30:33 <mm_freak> at least i think it requires it
11:30:39 <timthelion> I will read it and come back.
11:30:49 <Cale> There's also, if I recall correctly, a paper explaining how Arrow can be looked at as Applicative + Category
11:30:54 <mm_freak> http://ertes.de/new/tutorials/arrows.html
11:31:02 <Cale> (at least as classically formulated)
11:31:43 <xplat> remind me what Applicative is in 'real' CT again?
11:32:41 <Cale> xplat: It's roughly the same thing as a monoidal endofunctor on (Hask, (,), ())
11:32:58 <alex404> Okay, Cale, mm_freak, which of you am I supposed to believe? Arrows should be left behind for applicative, or arrows are worth saving?
11:33:07 <Cale> alex404: both?
11:33:12 <alex404> Damnit!~
11:33:14 <alex404> :)
11:33:19 <Cale> alex404: There are a lot of ways to do everything.
11:33:45 <xplat> Cale: ah, and its effect on functions is a consequence of the adjuntion between (e->) and (e,)?
11:33:47 <byorgey> xplat: lax monoidal endofunctor or something like that
11:33:51 <alex404> The performance issues are worrisome though.
11:33:52 <xplat> *adjunction
11:34:04 <mm_freak> alex404: both
11:34:13 <xplat> lax monoidal is kind of different
11:34:26 <mm_freak> alex404: we're just proposing two different directions in solving the problem of arrows
11:34:50 <byorgey> xplat: look at "Applicative Programming with Effects", it goes into some detail on the CT at the end
11:34:58 <alpounet> alex404, it's just good to know about both of them
11:34:59 <xplat> it seems like you're solving at least 3 different problems of arrows
11:36:43 <mm_freak> alex404: basically cale wants to preserve arrow notation while solving its problems…  i'm proposing to program in a different style instead and only use arrow notation for expressing relationships in edge cases like feedback
11:36:53 <Cale> xplat: yeah, probably that's the explanation for it :)
11:37:16 <Cale> alex404: There will of course be libraries which can take advantage of either one of these approaches.
11:37:33 <Cale> (or maybe even both, I don't know)
11:38:21 <alex404> Cale: Are you planning on releasing a library which would allow me to use arrow notation and model programs in the way done in that tutorial, while avoiding the performance problems?
11:38:58 <Cale> alex404: Possibly. We'll have to decide how much to release at some point.
11:39:33 <alex404> mm_freak: So loops are a critical part of what I'm doing. I haven't seen what this code looks like, but if the edge case is important to me, won't the mix of applicative and arrow end up looking strange?
11:40:26 <Cale> alex404: Ultimately if the code you're writing is working fast enough for you, that's all that matters though :)
11:41:47 <mm_freak> alex404: not at all
11:41:51 <alex404> Cale: Well, once things are properly developed, the point is to be doing some pretty heavy machine learning, so 10 times faster may mean 1 day of waiting as opposed to ten. But I'm still only playing with a handful of nodes at a time. The computation is in massive matrix operations and sampling...
11:42:44 <mm_freak> alex404: the idea is to write everything in applicative style and then just connect the looping parts in arrow notation
11:42:57 <alex404> Cale: So maybe this discussion isn't relevant anyway. I mean, if I have 20 arrows which are pounding the cpu with computation, is desugaring really so costly?
11:43:22 <Cale> alex404: You may want to look at what the desugaring is producing at some point
11:43:35 <Cale> it's often suboptimal for a given computation
11:43:56 <alex404> mm_freak: Well, I definitely look into it in any case. Will you be releasing some examples/tutorials?
11:44:15 <mm_freak> GHC is quite smart at doing the right thing, but of course it won't always produce the best possible code
11:44:20 <mm_freak> alex404: soon =)
11:44:27 <mm_freak> alex404: if you read -cafe, you'll know
11:44:33 <alex404> mm_freak: Cheers :)
11:44:48 <alex404> mm_freak: I suppose I should start...
11:44:58 <nexion> if I have an "atomically" block with two writes to the same TChan, can it be that another thread does a write in between those two?
11:45:12 <alex404> mm_freak: I thought planet haskell was enough haskell news but I guess that's wrong...
11:45:38 <Cale> nexion: no.
11:45:51 <kane77> hi, I'm trying to build package for leksah in arch and when building one of it's dependencies - ltk, I get this error: package bin-package-db-0.0.0.0 is broken due to missing package binary-0.5.1.0
11:45:58 <nexion> Cale: thought so; thanks
11:45:59 <Cale> nexion: If it does, those writes will never be committed to the TChan
11:46:11 <Cale> (and the block will be run again at some point)
11:46:19 <diego_diego> Hey all, I'm a total haskell newbie. I'm setting up a server side fcgi app that will respond to http requests which have various parameters. There must be a library that makes it possible for me to extract a given parameter and turn it into an Int (or double or string) or a Nothing if it's not safe/what's expected. Any pointers into what'd be good to use? I'm basically building an API but not really using a framework...  any/all fee
11:46:20 <diego_diego> appreciated
11:46:22 <mm_freak> nexion: STM actions are fully atomic (unlike e.g. database transactions)
11:47:14 <Cale> diego_diego: your first message ended with "any/all fe"
11:47:24 <mm_freak> diego_diego: if you want to do web development in haskell i suggest using one of the ready-made frameworks
11:47:32 <mm_freak> if you really want to program at a lower level, have a look at WAI
11:47:34 <diego_diego> feedback appreciated
11:48:01 <mm_freak> WAI provides the bare minimum to write a web application
11:48:31 <Cale> diego_diego: Okay, so the first thing I'd wonder is whether 'reads' from the Prelude isn't good enough.
11:48:54 <Cale> (or some parsing library like Parsec)
11:49:13 <Cale> I don't know a heck of a lot about how people write web applications in Haskell these days though.
11:49:19 <diego_diego> mm_freak: my application takes data from some hardware, so although this is web programming I'm not making anything that a human will ever see, simply putting this in a database. Eventually I will use a framework to get data out of database and display in friendly way
11:49:40 <mm_freak> diego_diego: then use WAI
11:49:50 <mm_freak> it does all the plumbing for you
11:50:25 <Cale> What's wrong with Network.CGI?
11:50:43 <diego_diego> mm_freak: I thought WAI was just an interface, which yesod and perhaps other frameworks implement
11:51:01 <mm_freak> WAI is an interface on which yesod is built
11:51:29 <mm_freak> it's really fast, convenient enough for a barebones web developer and is gateway-interface-agnostic
11:51:48 <mm_freak> so if you at some point decide to switch to CGI, SCGI or Warp, it's just changing a line of code
11:52:04 <diego_diego> cale: well, currently using the getInput function from network.fastcgi (which I think extends network.cgi), but I find myself writing something like getParameterInt where I try to extract an int from a query string... but that must be written already
11:53:02 <diego_diego> cale: indeed, came across reads while trying to do this today, wanted to double check to see if there wasnt' something else that might better.
11:53:15 <Cale> I'm having trouble separating your question from the question of how to parse a String into an Int
11:54:20 <c_wraith> Cale: the main problem with Network.CGI is the use of String everywhere.  I suppose for toys that doesn't matter, but it's a serious correctness problem in real web apps.
11:54:42 <c_wraith> (ignoring performance concerns entirely)
11:54:53 <Cale> c_wraith: I guess if you're handling lots of binary data, it's a problem?
11:55:13 <zachk> c_wraith: bytestrings all the way?
11:55:13 <lambdabot> zachk: You have 1 new message. '/msg lambdabot @messages' to read it.
11:55:24 <zachk> or what is wrong with String :-/
11:55:30 <Cale> (though there's a reasonable, if a bit ugly, way to cope with that just using the lowest 256 Char values)
11:55:31 <c_wraith> or at least some way to control decoding.
11:56:17 <c_wraith> most of the time you want string-like representations internally - you just want to control encoding/decoding on the web, thanks to the flaky nature of web browsers
11:56:42 <c_wraith> ... mostly due to people still using 15 year old web browsers for no discernable reason
11:56:57 <diego_diego> cale: hmm yeah sorry, I think that's it really... Ibut I guess it's maybe related to what c_wraith mentions, that sometimes I will have a Maybe String. I guess I just want to pass a Maybe String and get a Maybe Int, and before writing the short code I thought it'd be somewhere already
11:57:26 <zachk> ahhh
11:58:02 <Cale> :t listToMaybe
11:58:03 <lambdabot> forall a. [a] -> Maybe a
11:58:15 <mm_freak> i think in a web application ByteString is also unfortunate, which is why i don't like snap a lot
11:58:29 <mm_freak> Text is the way to go
11:58:48 <c_wraith> the problem is that the specs don't specify a correct encoding
11:58:57 <c_wraith> so if you do it automatically, you're wrong.
11:59:08 <mightybyte_> mm_freak: Heh, c_wraith beat me to it
11:59:14 <Cale> You can't just use UTF-8 everywhere?
11:59:40 <mm_freak> c_wraith: for receiving from the client all modern frameworks automatically convert to the proper internal representation
11:59:48 <mm_freak> and for sending you would just use UTF-8
12:00:13 <c_wraith> mm_freak: automatically and *incorrectly*
12:00:27 <mm_freak> why incorrectly?
12:01:03 <c_wraith> I don't think anyone would object to a snap wrapper that assumed UTF-8 on lots of APIs and did the conversions to text.  But you still need an escape hatch to the raw bytes for cases where automatic is wrong.
12:01:31 <c_wraith> and snap's been built very bottom-up.  Get the necessary parts first, add in optional stuff later.
12:01:41 <c_wraith> the raw bytes are necessary.
12:01:53 <mm_freak> i don't understand…  the client sends its data along with the encoding information
12:01:54 <mightybyte_> We have discussed doing just that
12:02:14 <c_wraith> mm_freak: you think http is only for web browsers?  only for text data?
12:02:34 <mm_freak> no, i don't
12:03:25 <mm_freak> i'm trying to understand the problem you're addressing
12:05:04 <c_wraith> problems like "sometimes data is binary" and "browsers don't send encoding information with form submissions"
12:05:40 <xplat> an escape hatch for bytes is necessary, but handling the most common cases of text data automatically seems important even for a relatively low-level server interface
12:06:41 <xplat> the fact that it's tricky to get right makes it even more important to provide, so that all your downstream programmers don't produce their own wrong versions
12:09:13 <mm_freak> c_wraith: if you don't have encoding information you can only try to auto-detect certain encodings, but that's the best you can do
12:09:36 <xplat> (and if there are knobs like 'default hopeless wild guess encoding' that need to be set site-specifically, provide the knobs)
12:10:14 <c_wraith> mm_freak: you can also detect it independently from other error conditions, if you are doing the decoding yourself.
12:11:45 <xplat> c_wraith: presumably you are still having the computer do it ...
12:12:51 <c_wraith> xplat: nope.  I have it email me a bunch of octets, and I email back unicode codepoints.  all conversion done by hand. :)
12:13:05 <c_wraith> But more seriously, I meant "outside the framework"
12:13:23 <xplat> if you can write code that detects which encoding you want to use, why can't someone else write that code?
12:14:17 <xplat> what specific advantage is there to doing it outside the framework?
12:14:29 <c_wraith> I honestly don't care about encoding detection.  I care about handling decoding failures in my app-specific way
12:15:51 <xplat> okay, so your complaint is not about encoding choice that is 'automatic' or 'in the framework', but just about the way errors are handled
12:17:24 <c_wraith> I care that anything that removes a piece of information from me has removed a piece of information from me.
12:17:40 <c_wraith> If I used to know what the bytes were, but don't anymore, I have lost.
12:22:45 <zachk> could the internet possibly be one massive neural network that is linking all our minds together and forming a new conscious entity never before seen on this planet, or maybe even in this quadrant of the galaxy? FULL STORY at 7
12:23:20 <edwardk> but who would put together such a massive AI that seems to be only capable of identifying cute cats?
12:23:45 <joshc> relevant: https://en.wikipedia.org/wiki/Betteridge%27s_Law_of_Headlines
12:24:20 <hiptobecubic> I would probably do that.
12:24:40 <hiptobecubic> You could auto generate slides shows of only cute pictures, put ads on the side and go on vacation
12:25:03 <byorgey> edwardk: no one "put it together".  It just turns out that emergent massive AIs are interested in cute cats.
12:25:32 <edwardk> byorgey: that makes sense. http://www.smh.com.au/technology/sci-tech/googles-brain-simulator-16000-computers-to-identify-a-cat-20120626-20zmd.html
12:25:40 <byorgey> also, pretty sure Orson Scott Card already covered this one.
12:25:52 <byorgey> hehehe
12:26:54 <zachk> did Card write anything outside of the ender series?
12:27:22 <edwardk> i kind of gave up on orson scott card some time after he infected bean with every-sperm-is-sacred baby rabies
12:28:10 <edwardk> zachk: yeah, its not worth chasing after the other stuff, the beginning of the alvin journeyman stuff was okay, but it also descended into thinly veiled preaching
12:28:10 <jamiltron> @zachk quite a bit, actually
12:28:11 <lambdabot> Unknown command, try @list
12:28:20 <zachk> that item of sacredness is not unique to his christian roots, it also has roots in some eastern religions/philosophies
12:37:52 <Catnaroek> N00bish question. Does the Haskell platform include GHC itself?
12:37:53 <zeroseven> Hello, I'm trying to install curl-1.3.7 with cabal unsuccessfully on openBSD 5.1. I get an error "curl libraries not found", I've tried google to no avail... I was hoping maybe someone here would have some insight?
12:38:04 <hiptobecubic> Catnaroek, yes.
12:38:05 <tac-tics> Catnaroek: yes
12:38:25 <shachaf> Catnaroek: Sometimes.
12:38:27 <hiptobecubic> zeroseven, you have curl installed i assume?
12:38:36 <zeroseven> Yes
12:38:40 <shachaf> Catnaroek: You might need to install GHC separately.
12:38:43 <Catnaroek> shachaf, tac-tics, hiptobecubic: I downloaded the HP's source, then installed it, then deinstalled the ghc I used to compile the HP.
12:39:00 <shachaf> Catnaroek: When you're compiling it from source you don't get GHC.
12:39:07 <Catnaroek> Ooooooooooooh. Okay.
12:39:18 <shachaf> "The Haskell Platform" is really just a bunch of packages.
12:39:23 <hiptobecubic> ah indeed
12:39:33 <Catnaroek> Ah, good, good.
12:39:37 <hiptobecubic> I thought you were probably just installing a package, since you were presenting yourself as a noob
12:39:40 <Catnaroek> Can I use the HP with GHC 7.4.2?
12:39:44 <timthelion> Is there some sort of definition for a "valid" fmap instance?  For example, is instance Functor Pair where fmap f (Pair a b) = Pair (f b) (f a) not valid because it's destructive to the structure of the origional Pair?
12:40:19 <byorgey> how is that "destructive to the structure"?
12:40:29 <Cale> timthelion: fmap id = id,  fmap (f . g) = fmap f . fmap g
12:40:32 <edwardk> timthelion: fmap id = id, and then the type signature checks everything else
12:40:36 <byorgey> that is in fact a valid Functor instance.
12:40:39 <timthelion> byorgey: it doesn't maintain the order of a and b?
12:40:44 <byorgey> oh!
12:40:50 <Catnaroek> hiptobecubic: Well, I am a n00b, but I really hated the inconsistency between Debian's packages and cabal's packages. And now that I switched to Arch, I do not want to go through the same inconsistency. So I decided to install the HP from source.
12:40:51 <byorgey> haha, I should read more carefully.
12:40:56 <byorgey> that is NOT a valid functor instance.
12:40:58 <timthelion> Cale: aha!  so it's not valid :)
12:40:59 <byorgey> because fmap id /= id.
12:41:06 <timthelion> thanks :)
12:41:19 <edwardk> timthelion: yes, swapping the order of a and b makes fmap id /= id
12:42:14 <timthelion> so is there then a way to construct "standard Functor unit tests" in some prepackaged maner? Or do I need to just be aware of such laws when writing functor instances...
12:43:17 <zeroseven> hiptobecubic, I have curl installed, I've tried the --extra-lib-dirs, however results are the same.
12:43:25 <hiptobecubic> Catnaroek, to be honest. I usually just install ghc and then use cabal for everything else in my home dir
12:43:27 <timthelion> Like is it possible to tell GHC to run fmap id (some-given-structure) at compile time to check?
12:43:41 <edwardk> timthelion: there is a package out there that generates law quickcheck tests for classes
12:43:51 <Catnaroek> hiptobecubic: Seems legit. :)
12:44:04 <edwardk> i keep meaning to make a version of that law package that uses polymorphic kinds so you can make the Law class once
12:44:06 <hiptobecubic> zeroseven, i don't know a great deal about debugging cabal, but i believe you can use -v3 to give a bunch of debug output as far where it's searching for libs etc
12:44:13 <edwardk> but i still don't like the overall API
12:44:17 <hiptobecubic> Catnaroek, the dependency resolution takes care of things pretty quickly
12:44:41 <zeroseven> hiptobecubic, thanks, I will give that a shot.
12:44:53 <hiptobecubic> the first few libraries that you need take a long time because they always need things like hunit and quickcheck and whatever, but from there out it's pretty easy going
12:44:56 <timthelion> edwardk: ok, thank you.
12:45:31 <Catnaroek> There is no reason to use sudo when installing cabal packages, right?
12:46:07 <hiptobecubic> Catnaroek, you specifically should not
12:46:31 <dmwit> zeroseven: Do you have the -dev versions of the curl libraries installed?
12:46:38 <Catnaroek> :)
12:46:41 <Catnaroek> hiptobecubic: Thanks!
12:46:46 <hiptobecubic> Catnaroek, notice though that this puts everything under ./cabal so it's only there for your user. if you need system wide libs then you are stuck with debian i guess
12:47:00 <hiptobecubic> Catnaroek, although you can overlap them
12:47:16 <Catnaroek> hiptobecubic: I am pretty much my computer's only user, anyway. :)
12:47:21 <hiptobecubic> sure
12:47:50 <dmwit> hiptobecubic, Catnaroek: Not at all; cabal is perfectly capable of installing system-wide libraries.
12:47:53 <zeroseven> dmwit, now that you mention it, I'm sure that is my problem, I faced the same issue with bdb and just gave up for the night. Simple as a pkg_add curl-dev??
12:48:13 <dmwit> hiptobecubic, Catnaroek: Just set user-install: False in your .cabal/config.
12:48:14 <hiptobecubic> dmwit, yes but you want to be root then and have root permissions
12:48:22 <dmwit> Yep.
12:48:39 <dmwit> Hard to imagine installing something system-wide unless you have system-wide installation permissions. =)
12:48:59 <hiptobecubic> dmwit, Catnaroek, also i can't say i recommend let anything but your package manager shit files all over the computer. Things will become inconsistent eventually and then you are boned. there is no cabal uninstall.
12:49:44 <hiptobecubic> Of course, if you're the only one on the computer then you can just do whatever you want all the time so whatever
12:49:51 <dmwit> eh, usually by the time I've hosed my system there's a new GHC release out anyway. ;-)
12:50:40 <hiptobecubic> dmwit, do all the system-wide libs go into one easy to find place? rm -r ~/.cabal ~/.ghc is nice and easy when things get out of hand
12:51:34 <dmwit> Well, they do, but those directories are a bit more dangerous to nuke, since they have libraries you can't reinstall. =)
12:51:45 <xplat> 15:23 < edwardk> but who would put together such a massive AI that seems to be only capable of identifying cute cats? <-- cute cats in search of their props, obviously
12:51:53 <edwardk> aha
12:51:53 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
12:52:10 <hiptobecubic> @tell lambdabot abuse me
12:52:11 <lambdabot> Nice try ;)
12:54:29 <nand`> instance (Eq b, Arbitrary a) => Eq (a -> b) where ... -- quickCheck
12:54:31 * nand` hides
12:54:46 <ion> hah
12:55:34 <dmwit> I sometimes define class Universe a where universe :: [a] and instance (Universe a, Eq b) => Eq (a -> b) where f == g = all (\x -> f x == g x) universe
12:55:49 <illissius> Is there a recommended way to debug why RULES don't fire, especially in the case where I suspect types are getting in the way (some of the RULE arguments are polymorphic)? perhaps someone's written something about it online that I could be looking at?
12:57:02 <squidz> im reading through lyah and wanted to know if anybody knows of any excercises i can go through. Right now im towards the end of the book(Monads)
12:57:23 * hackagebot cypher 0.1 - Haskell bindings for the neo4j "cypher" query language  http://hackage.haskell.org/package/cypher-0.1 (SamAnklesaria)
12:57:58 <nand`> I was about to link 20 intermediate haskell exercises but it seems the URL 404s
12:58:02 <jamiltron> squidz: 99 Haskell problems? http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
12:59:58 <nand`> ah, found it: https://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/ -- squidz
13:01:03 <Cale> Why is that https, I wonder
13:01:17 <shachaf> Cale: Because https ought to be the default.
13:01:23 <nand`> ^
13:01:30 <otters> @pl \x -> x == reverse x
13:01:30 <lambdabot> ap (==) reverse
13:01:53 <otters> :t (<*>)
13:01:54 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:01:57 <otters> :t a
13:01:58 <lambdabot> Expr
13:01:59 <otters> :t ap
13:02:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:02:03 <otters> there we go
13:06:18 <mdhopkins> trying to read args and having run-time type errors. How do I set a variable number of arguments in a type? https://gist.github.com/e45c96827bfcb7251c4b
13:09:53 <c_wraith> mdhopkins: that's not runtime.  It's compile-time in the interpreter
13:10:20 <c_wraith> mdhopkins: it's complaining that you're treating a non-function value (printArgs) as if it was a function.
13:10:27 <c_wraith> mdhopkins: that seems like a valid complaint to me
13:10:43 <dmwit> mdhopkins: You may name your function main, and then use :main foo bar in ghci.
13:11:03 <dmwit> mdhopkins: Alternately, you may call withArgs ["foo", "bar"] printArgs
13:11:23 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Environment.html#v:withArgs
13:11:52 <c_wraith> wow. I didn't know about withArgs.  How long has that been around?
13:11:56 <KBme> so…what books do haskell fans recommend for learning haskell?
13:12:01 <dmwit> like... ages
13:12:03 <KBme> rwh seems to be kind of outdated
13:12:08 <c_wraith> And is there any chance withArgs is thread safe?
13:12:21 <DMcGill> @where lyah
13:12:22 <dmwit> Sure it is.
13:12:22 <lambdabot> http://www.learnyouahaskell.com/
13:12:31 <DMcGill> that seems to be the most common one
13:12:38 <DMcGill> it's pretty good
13:12:42 <KBme> ah thanks
13:12:45 <c_wraith> dmwit: well, I could think of two potential implementations, depending on how getArgs is implemented.
13:12:48 <dmwit> c_wraith: It doesn't set the arguments for later calls. It only sets the arguments for the *one* call that is its argument.
13:12:52 <DMcGill> and what do you mean by "outdated"?
13:12:54 <mdhopkins> c_wraith dmwit: thanks, obviously I did not understand what I was doing. :)
13:13:13 <c_wraith> DMcGill: there's a bunch of stuff in rwh that doesn't compile anymore because libraries have changed
13:13:32 <KBme> DMcGill, dunno, seems like the authors haven't looked in that direction for 4 years
13:14:14 <dmwit> c_wraith: Oh, hm, actually... looking at the source now I'm not as confident as I was before. =P
13:14:35 <srhb> KBme: RHW is still great. :)
13:14:49 <srhb> KBme: But depending on your field of interest there may be specific writeups to your liking.
13:15:14 <c_wraith> the majority of the information in RWH is still good.  But you might need some knowledge of library changes to fix things that depend on stuff that changed.
13:15:31 <dmwit> KBme: Yeah, the RWH authors sort of obsoleted their own book by writing libraries that encapsulated all the patterns in the book. =)
13:15:53 <srhb> How dare they!
13:16:17 <lpsmith> how do you hide a module from haddock?
13:16:40 <alpounet> KBme, they're actually preparing an update to RWH
13:16:57 <alpounet> a 2nd edition
13:16:57 <nand`> something that I've always been wondering; Say I wanted to make Either String a Monad where fail = Left, but I still want to make Either e a Monad where fail = error; except for e = String. Can I somehow encode this, ie. instantiate over every type except String?
13:17:10 <jamiltron> I'm really excited for RWH 2
13:17:17 <KBme> that sounds great
13:17:48 <KBme> i also wonder why noone has ripped out the rwh contents and updated it to fit the comments
13:17:48 <byorgey> nand`: no, not without Olegian type hackery.
13:18:06 <KBme> there are a bunch of typos and other things the comments point out very well
13:18:31 <nand`> byorgey: I see. I figured it might have been as simple as placing a “not equal (?)” type constraint on the instance or something
13:19:09 <byorgey> nand`: it would be that simple, if there existed such a thing as type inequality constraints.
13:19:33 <byorgey> but implementing type inequality constraints would not be simple.
13:20:09 <nand`> byorgey: is there a technical reasons such constraints can't exist (undecidability, incompatibility with current framework, violating axioms etc.) or is it just the case that it's not very useful so nobody has proposed it?
13:20:17 <nand`> oh, I should read before I hit enter
13:20:37 <dmwit> c_wraith: seems not to be thread-safe
13:21:03 <hpaste> dmwit pasted “withArgs thread safety test” at http://hpaste.org/70547
13:21:09 <byorgey> nand`: they could be useful, but I think it's just far from obvious how they would interact with other type system features.
13:22:17 <c_wraith> dmwit: yeah...  hence my asking that question
13:22:57 <dmwit> It's a shame, really, since it seems like it would be pretty easy to make it thread-safe with a little runtime support.
13:25:07 <xplat> type inequality constraints can act very badly in conjunction with things like fundeps, type families, and GADTs
13:26:22 <nand`> maybe the solution can be simpler: by simply picking the less general instance instead of throwing an “Overlapping instance declarations” for a certain instance
13:27:10 <nand`> (the “less general” property here being derived from some arbitrary rules possibly including user-input in the form of pragmas)
13:28:34 <xplat> nand`: defaulting when instances overlap doesn't even behave well without all that stuff
13:28:37 <KBme> is anyone using haskell2010 yet?
13:28:46 <KBme> is that the recommended language?
13:29:10 <c_wraith> I believe cabal enables it by default these days
13:29:13 <srhb> It does.
13:29:31 <KBme> thanks
13:29:58 <nand`> Isn't like basically every single library haskell2010 nowadays? I thought haskell 98 doesn't have hierarchical module names
13:30:09 <srhb> KBme: You won't really know the difference, except if you had to go back you'd probably slightly miss pattern guards slightly at some point :)
13:30:35 <nand`> srhb: on the plus side, n+k patterns!
13:30:40 * nand` hides
13:30:46 <stepkut> nand`: :)
13:30:46 <KBme> oh guards were introduced in 2010? :D
13:30:50 <shachaf> I accidentally n+k match in Haskell 98 all the time.
13:30:52 <srhb> No, pattern guards
13:31:01 <KBme> right
13:31:12 <shachaf> I mean, I *try* to type "f x = ...", but it comes out as "f (x+1) = ..."
13:31:18 <shachaf> And the compiler doesn't catch it. :-(
13:31:41 <srhb> > let foo x | (a,b) <- x = b in foo (1,2)
13:31:42 <lambdabot>   2
13:31:48 <srhb> Ah, lambdabot is 2012
13:31:51 <srhb> 10*!
13:32:14 <srhb> KBme: The pattern bit is the fact that you can match patterns in the guard, as show there :)
13:34:48 <McManiaC> @pl \mm -> m mm >>= f
13:34:48 <lambdabot> (f =<<) . m
13:34:52 * nand` does f (Succ x) = ... all the time. What do you mean, your Prelude doesn't have Peano?
13:35:02 <McManiaC> is there an alternative to "join . fmap" ?
13:35:07 <McManiaC> for Maybe for example
13:35:23 <srhb> nand`: Yeah I miss those. Why is there no default natural number type that can do that?
13:35:27 <c_wraith> :t join .: fmap
13:35:29 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
13:35:43 <nand`> now if only we had some combinator like that!
13:35:50 <c_wraith> that would never exist.
13:36:05 <nand`> no way, I can't imagine it being useful except in a few very contrived situations
13:36:12 <nand`> :t (=<<) -- McManiaC
13:36:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:36:24 <shachaf> @quote newsham combinator
13:36:24 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
13:37:52 <McManiaC> hmk
13:39:55 <donri> is it possible to use type operators for context variables?
13:40:52 <nand`> donri: you mean like :: Arrow (~>) => a ~> a
13:41:02 <nand`> or did I misunderstand?
13:41:35 <donri> aha, i was using :~>
13:41:47 <xplat> @quote . combinator
13:41:48 <lambdabot> No quotes for this person. I can't hear you -- I'm using the scrambler.
13:42:04 <xplat> why can i never remember the syntax for that?
13:42:06 <xplat> @help quote
13:42:07 <lambdabot> quote <nick>
13:42:07 <lambdabot> remember <nick> <quote>
13:42:08 <lambdabot> Quote somebody, a random person, or save a memorable quote
13:42:18 <nand`> @quote combinator
13:42:18 <lambdabot> kmc says: Zagen, you'll need a zygohistomorphic prepromorphism from the bifunctorial Kleisli category of username-password pairs to a combinatory arrow calculus of php scripts
13:42:24 <Eduard_Munteanu> xplat: @quote regexp
13:42:25 <ion> donri: : is handled like capital letters.
13:42:25 <xplat> oh, because it's not even in the help :)
13:42:46 <Eduard_Munteanu> @quote from.*bif
13:42:47 <lambdabot> kmc says: Zagen, you'll need a zygohistomorphic prepromorphism from the bifunctorial Kleisli category of username-password pairs to a combinatory arrow calculus of php scripts
13:43:30 <xplat> @quote a.*b.*c
13:43:30 <lambdabot> glguy says: lazy evaluation is best 50% of time because there are 2 cases, the cases where it is the best and the cases where it is not the best
13:43:47 <nand`> what happens with multiple parameters like that? is it @quote <nick> <regexp> or is it @quote <regex₁> <regex₂> ... where all have to match?
13:43:59 <xplat> @quote a b c
13:43:59 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
13:44:13 <nand`> I guess that rules out the latter
13:44:17 <xplat> @quote glguy a b c
13:44:18 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
13:44:24 <Eduard_Munteanu> I think it's just @quote <regexp> and regexp finishes at the newline
13:44:30 <ion> @quote glguy of time
13:44:30 <lambdabot> glguy says: lazy evaluation is best 50% of time because there are 2 cases, the cases where it is the best and the cases where it is not the best
13:44:48 <Eduard_Munteanu> @quote says
13:44:48 <lambdabot> Pseudonym says: Phil Wadler says so, so it must be true.
13:44:52 <carter___> quote carter
13:44:57 <nand`> @quote gl.* of time
13:44:57 <lambdabot> No quotes for this person. Maybe you made a typo?
13:45:05 <xplat> no, it seems to be @quote [<nick>] <regex>
13:45:08 <Eduard_Munteanu> Hm.
13:45:29 <nand`> okay, so it's either @quote <regex-without-spaces> or @quote <name> <regex with spaces>
13:45:39 <carter> quote carter *
13:45:47 <Eduard_Munteanu> @quote there are 2 cases
13:45:48 <lambdabot> No quotes for this person. My pet ferret can type better than you!
13:45:51 <Eduard_Munteanu> Right.
13:46:01 <otters> @quote otters
13:46:02 <lambdabot> No quotes match. That's something I cannot allow to happen.
13:46:04 <otters> awwww
13:46:22 <xplat> @quote otter
13:46:23 <lambdabot> hpc says: appEndo sounds like a harry potter spell
13:46:37 <hpc> heh
13:46:39 <otters> appendo
13:46:47 <Eduard_Munteanu> :)
13:47:14 <nand`> @vixen
13:47:14 <lambdabot> I can see clearly now... that I was wrong in not acting more decisively and more forthrightly in dealing with Watergate.
13:47:22 <nand`> ^- odd command
13:47:34 <xplat> @niven
13:47:35 <lambdabot> Your boys will be home for Christmas.
13:47:36 <ksf> that sounds more like nixon
13:47:46 <xplat> @nixie
13:47:46 <lambdabot> I am not a crook.
13:48:38 <xplat> @nylon
13:48:39 <lambdabot> Certainly in the next 50 years we shall see a woman president, perhaps sooner than you think. A woman can and should be able to do any political job that a man can do.
13:49:02 <xplat> hm, time's about up, isn't it?
13:49:36 <ksf> xplat, yep, but it's extra time.
13:49:49 <ksf> 2x15m. then shootout.
13:50:20 <ksf> football isn't really geared towards ensuring clear winners and loosers.
13:50:26 <ksf> probably the reason the americans hate it.
13:50:31 <dmwit> 2019 is the deadline
13:50:52 * ksf is OT and proud of it.
13:50:58 <dmwit> So this election or the next (or some catastrophy that kills enough people to get to a woman in the chain of command).
13:51:20 <nand`> huh
13:51:26 <ksf> rice?
13:51:26 <nand`> I thought xplat and ksf were replying to lambdabot's quote
13:51:33 <nand`> until the “football” comment
13:51:43 <dmwit> I still think xplat was. Only ksf was mucking about.
13:52:22 <Doom99> @ksf: not enough shots on goal to be interesting
13:52:22 <lambdabot> Unknown command, try @list
13:54:20 <ksf> Doom99, that's like saying sex sucks because there's not enough ejaculation.
13:54:58 <hiptobecubic> Is there an api for hpaste somewhere?
13:55:12 <ksf> in some sense, certainly.
13:55:19 <ksf> haskellmode has hpaste integration
13:55:23 <Doom99> ha well just giving american perspective.. hockey has so many many more even if most games are 3-2
13:55:35 <hiptobecubic> that's an emacs plugin, right?
13:55:39 <ksf> no vim.
13:55:47 <ksf> emacs' is called haskell-mode
13:55:48 <hiptobecubic> i thought that was broken
13:56:02 <ksf> the hpaste plugin?
13:56:06 <hiptobecubic> yeah
13:56:07 <ksf> in general the mode works for me.
13:56:12 <xplat> dmwit: this election is essentially impossible
13:56:15 <ksf> never tried the hpaste thing.
13:56:40 <hiptobecubic> it works for me as well, although it's very slow. I've been trying to get by with ghc-mod and neco lately
13:57:18 <ksf> someone needs to hack up a proper vi mode for yi
13:57:26 <hiptobecubic> I get the feeling that emacs's haskell mode is in better shape. but maybe it's a grass-is-greener problem
13:57:35 <ksf> it's on my todo list, but on max. place three.
13:57:47 <hiptobecubic> yi crashes immediately for me when i try to open a haskell file
13:57:51 <nand`> Peaker: how closely tied is bottle to Haskell? Have you thought about something similar for Agda?
13:57:58 <xplat> hiptobecubic: i can only hope for your sake it is (a grass-is-greener problem)
13:58:06 <nand`> I noticed you have to provide type annotations manually
13:58:15 <ksf> yi is wasting massive cycles in the pango backend while scrolling.
13:58:23 <xplat> bottle doesn't even edit haskell, strictly speaking
13:58:37 <ksf> pango is overkill, anyway, a program like yi should work on raw X.
13:58:42 <xplat> and it does its own typechecking, not using a compiler interface
13:58:46 <hiptobecubic> oh of course, if i load it in gdb it runs
13:59:01 <hiptobecubic> but why use yi, what's the killer feature?
13:59:13 <ksf> I'd like to hack on it, that's the feature.
13:59:21 <ksf> I loathe vimscript with a passion.
13:59:25 <hiptobecubic> true
13:59:29 <hiptobecubic> viml is disgusting
13:59:33 <nand`> ksf: a vim compatibility mode for yi would be much, much appreciated
13:59:35 <dmwit> vimscript is truly the worst language.
13:59:41 <nand`> I like vim. but I want to hack on my editor as well
13:59:52 <nand`> I like vim for its user interface, not its configuration; mind
13:59:56 <ksf> well it does have some vi functionality.
14:00:04 <dr_balor> Can someone point me at darcs/git for ghc as I can only see source tarballs on the webpage?
14:00:05 <hiptobecubic> it offered it to me when i started it
14:00:06 <ksf> and I wouldn't try to clone vim
14:00:09 <nand`> yeah, the basics seem to be there
14:00:14 <hiptobecubic> i have some more-or-less vim bindings right now
14:00:23 <ksf> I'd start with vi and ex, complete POSIX spec and then go from there.
14:00:27 <dmwit> dr_balor: http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources?redirectedfrom=GhcDarcs
14:00:28 <hiptobecubic> although i can't "do" anything because i don't knwo what the hell yi does
14:00:42 <nand`> I've never used vi; though I notice a ton of “this feature is unavailable in vi” in vim's :help
14:00:47 <nand`> so I can only imagine I would not like it
14:00:47 <ksf> dr_balor, github.
14:01:01 <ksf> https://github.com/ghc/ghc
14:01:12 <hiptobecubic> vi is terrible
14:01:15 <dmwit> dr_balor: and http://hackage.haskell.org/trac/ghc/wiki/Building is a bookmark of mine
14:01:17 <dr_balor> dmwit: thanks
14:01:35 <ksf> well, you'll want to clone from it as it's fast. http://darcs.haskell.org/ghc.git/ is the real one.
14:02:28 <Doom99> need another emacs guy and can start a good vi/emacs war
14:02:41 <hiptobecubic> lol
14:03:03 <Taneb> I have an irrational fear of using letter keys to move the cursor
14:03:18 <nand`> my main issue with yi off the bat is the user interface: 1. I can't see things because the colors clash horribly and 2. it replaces stuff like :: by unicode characters that don't render very nicely
14:03:23 <dr_balor> How do you recognise an emacs user?  Just wait 5 minutes for them to tell you.
14:03:31 <nand`> I can't seem to figure out how to 1. port my vim color scheme and 2. disable those unicode translations
14:03:38 <nand`> those two alone would be an instant usability improvement, imo
14:03:43 <Taneb> There's really only two other reasons why I'm not using a cli interface primarily
14:03:44 <hiptobecubic> 3. how to do anything
14:04:18 <hiptobecubic> i personally hate unicode crap in my source.
14:04:30 <c_wraith> I really dislike unicode syntax.  It isn't something that should be enabled by default.
14:04:35 * ksf just noticed he's on #haskell not on -blah
14:04:37 <hiptobecubic> It's annoying to see things like a»v»c
14:05:51 <fmap> It's annoying to use vim conceal just because not anyone likes UnicodeSyntax :(
14:05:53 <nand`> I think the only time I've ever used unicode in my source is when I disambiguated some functions that worked on Lambda types with λ
14:06:03 <ksf> nand`, try http://hpaste.org/70550
14:06:14 <ksf> it's not complete, but quite zenburn.
14:06:18 <nand`> ksf: I will tomorrow and report back, if that's okay
14:06:29 <ksf> ofc
14:07:17 <hpaste> nand` annotated “yi.hs” with “.vimrc colors” at http://hpaste.org/70550#a70551
14:07:24 <nand`> ^ here's my vim color scheme, for reference
14:07:53 <ksf> oh. termcolours.
14:08:05 <ksf> I have no idea how to do those with yi, but it's possible.
14:08:06 <nand`> oh yeah, I use the Vty interface
14:08:24 <nand`> I can still use your file as a skeleton - I have no idea how to even set a color scheme
14:08:34 <ksf> oh but you want pango.
14:08:38 <nand`> I browsed through the haddock page but I couldn't really find what I wanted
14:08:40 <ksf> just because you want zenburn.
14:08:59 <nand`> I don't know what zenburn is, for starters
14:09:01 <ksf> well, I looked at a scheme and copied it, then modified.
14:09:02 <nand`> other than “a theme”
14:09:10 <ksf> *the* colour style.
14:09:23 <ksf> http://slinky.imukuppi.org/zenburnpage/
14:09:23 <nand`> ah, it's a vim color scheme
14:09:36 <nand`> I don't have a 256-color terminal, for starters
14:09:46 <nand`> so I can't use zenburn in vim
14:10:04 <ksf> in general, it's  a pastelly lowish-contrast not-black background theme.
14:10:05 <Taneb> I like the idea of unicode in my code, but I'd only actually use it if I could get the symbols easily on my keyboard
14:10:07 <Taneb> Which I can't
14:10:18 <ksf> the not black background is important because lcds aren't completely black.
14:10:20 <nand`> Taneb: what OS?
14:10:24 <ksf> it's extremely easy on the eyes.
14:10:34 <nand`> ksf: I'm quite fond of mine
14:10:43 <dmwit> pfft, darkblue is the one true color theme
14:10:44 <Taneb> nand`, Ubuntu. That's a can't of "too difficult to remember the codes" rather than "impossible"
14:11:17 <Eduard_Munteanu> Taneb: you can usually set up your editor to transform key sequences to unicode chars, e.g. \-> to →
14:11:28 <nand`> Taneb: I use xmodmap for this, adding a symbol is a three step process of 1. decide on a key, 2. find the unicode point, 3. map it and reload
14:11:40 <Eduard_Munteanu> Uh, I wouldn't do that :/
14:11:41 <Taneb> Eduard_Munteanu, you mean the same text editors I write HTML and poetry in?
14:11:52 <ptrf> Ok, I'm still reading the typeclassopedia, and i've not really progressed further than the exercises for section 3.2. I really can't get my head around finding a type of kind * -> * which can't be made an instance of Functor (Without using undefined)
14:11:56 <Eduard_Munteanu> If you use SCIM, yeah.
14:11:58 <nand`> you can use https://raw.github.com/nandykins/gentoo-conf/master/.Xmodmap for inspiration if you want, it covers all the symbols I consider commonly used
14:12:04 <hiptobecubic> But i don't *want* the unicode
14:12:12 <dmwit> Taneb: If your text editor can't change its behavior based on file type, you need to get a better editor.
14:12:15 <ptrf> so thinking about it, we're looking for a type, so not a concrete example of a function of that type
14:12:25 <Eduard_Munteanu> ptrf: any functor is * -> *
14:12:26 <ptrf> but, also, we know we need something undefined
14:12:27 * hackagebot Vec-Transform 1.0.6 - Extends the Vec package with some 4x4 transform matrices  http://hackage.haskell.org/package/Vec-Transform-1.0.6 (TobiasBexelius)
14:12:28 * hackagebot Vec-Boolean 1.0.5 - Provides Boolean instances for the Vec package  http://hackage.haskell.org/package/Vec-Boolean-1.0.5 (TobiasBexelius)
14:12:32 <hiptobecubic> and i don't want you to have it either :D   i need an editor that substitutes in the other direction
14:12:34 <Eduard_Munteanu> ptrf: e.g. Maybe
14:12:37 <ptrf> Give an example of a type of kind * -> * which cannot be made an instance of Functor (without using undefined).
14:12:38 <Taneb> dmwit, but I save all my webpages and poems as .hs to confuse them!
14:12:42 <Eduard_Munteanu> Ah.
14:12:45 <ksf> ptrf, try a phantom type
14:12:51 <ptrf> hmm
14:12:56 <ptrf> ok, I'll look into that
14:13:05 <Taneb> dmwit, but seriously, it's after 10 at night, I've travelled 300 miles today, and I really can't be bothered
14:13:15 * dmwit nods supportively
14:14:16 <ksf> there's other things, too. like type family Foo a :: * ; data Bar a = Baz (Foo a)
14:14:32 <ptrf> ksf: nice, thanks. i'm looking on the wikipage
14:14:36 <dmwit> It can be even easier than that.
14:14:47 <ksf> ...might need more than one type family, though.
14:14:49 <Eduard_Munteanu> A contravariant functor also does, I think.
14:15:00 <dmwit> Try data BackwardsArrow a b = BackwardsArrow (b -> a), for example.
14:15:09 <Eduard_Munteanu> Yup ^^
14:16:02 <ptrf> ksf: ok, so basically, you make a data type with an unused paramter, so that you can write specific instances for different types, when making instancens?
14:16:15 <ptrf> i'm from SML-land, so i'm trying to adjust here
14:16:30 <ksf> data PhantomCarrier a = PhantomCarrier Int
14:16:54 <ksf> foo :: PhantomCarrier PhantomType -> Foobar
14:17:17 <Eduard_Munteanu> ksf: I think that makes a fine functor
14:17:26 <srhb> Me too
14:17:26 <srhb> :P
14:17:30 * hackagebot GPipe 1.3.2 - A functional graphics API for programmable GPUs  http://hackage.haskell.org/package/GPipe-1.3.2 (TobiasBexelius)
14:17:32 * hackagebot GPipe-TextureLoad 1.0.4 - Load GPipe textures from filesystem  http://hackage.haskell.org/package/GPipe-TextureLoad-1.0.4 (TobiasBexelius)
14:17:34 <ptrf> hej srhb
14:17:37 <ksf> without undefined?
14:17:38 <Eduard_Munteanu> fmap f = id
14:17:39 <srhb> hej ptrf :)
14:17:43 <dmwit> Without undefined, yes.
14:17:50 <ksf> id is a -> a, not a -> b
14:17:59 <dmwit> Eduard_Munteanu: ill-typed, you actually need to deconstruct and reconstruct the value (unfortunately)
14:18:06 <Eduard_Munteanu> Erm, yeah.
14:18:12 <ksf> oh, yes.
14:18:12 <dmwit> fmap f (PhantomCarrier i) = PhantomCarrier i
14:18:26 <dmwit> looks like id, but isn't =)
14:18:26 <ksf> well, never mind, I brainfarted.
14:18:29 <ptrf> we actually used these phantom types back in a class in last autumn but I didnt know that they were called phantom types
14:18:38 <ptrf> we used them to implement a stack machine monad
14:18:50 <ksf> Eduard_Munteanu's contravariant arrow is probably the intended solution.
14:19:08 * dmwit feels vaguely slighted
14:19:09 <srhb> ptrf: In AP?
14:19:13 <ptrf> yes srhb
14:19:19 <srhb> Wish I had had that course...
14:19:26 <Eduard_Munteanu> Unless you can define arbitrary "functors" on Hask.
14:19:29 <Eduard_Munteanu> I guess.
14:19:56 <Eduard_Munteanu> Type families kinda let you do that, I suppose.
14:20:15 <dmwit> There are things which are neither covariant nor contravariant functors.
14:20:21 <otters> @pl \x -> chr $ (65345 +) $ ord
14:20:22 <lambdabot> const (chr (65345 + ord))
14:20:25 <dmwit> e.g. data Iso a b = Iso (a -> b) (b -> a)
14:20:27 <otters> oh yeah
14:21:04 <Eduard_Munteanu> Hm, yeah.
14:21:22 <tgeeky_> but to be most correct, (->) is a difunctor, right
14:21:42 <tgeeky_> contra -> co
14:21:50 <ion> Princess Difunctor
14:22:06 <Eduard_Munteanu> Yeah, (->) is the Hom_Hask(_, _) bifunctor.
14:22:26 * hackagebot GPipe-Collada 0.1.3 - Load GPipe meshes from Collada files  http://hackage.haskell.org/package/GPipe-Collada-0.1.3 (TobiasBexelius)
14:23:25 <absence> is there a library function that will group each n items of a list?
14:23:40 <ksf> nope
14:23:50 <tgeeky_> there is the SQL-like syntax
14:24:12 <absence> sql-like?
14:24:55 <tgeeky_> absence: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#generalised-list-comprehensions
14:25:16 <jairavax> Heyllo.
14:25:17 <tgeeky_> section 7.3.10
14:25:28 <nand`> absence: Data.List.Split.splitEvery :: Int -> [a] -> [[a]] -- this?
14:25:30 <Eduard_Munteanu> jairavax: hi
14:25:38 <fragamus> Ok I have a bunch of state I need to work with but I want to segregate it such that the functions that access this state can't access that state and vice versa. Is there a well known pattern for this?
14:26:10 <tgeeky_> fragamus: a pair of state monads?
14:26:17 <tgeeky_> or StateTs
14:26:30 <Eduard_Munteanu> fragamus: existentials perhaps? You could also split the state into two parts and e.g. hide constructors / accessors.
14:26:31 <tgeeky_> or some sort of newtype wrapper
14:26:34 <dmwit> fragamus: You can use lenses to embed one state type in another.
14:27:01 <tgeeky_> dmwit's suggestion is probably the coolest
14:27:16 <tgeeky_> and edwardk's recent discussion on lenses might help
14:27:29 <dmwit> Most libraries provide a function of type (MonadState m s, MonadState m' s') :: Lens s s' -> m' a -> m a
14:27:30 <shapr> Is there an easy way to ask my ghc for the value of __GLASGOW_HASKELL__ ?
14:27:38 <dmwit> s/libraries/lens libraries/
14:28:03 <tgeeky_> shapr: just enable CPP and do it?
14:28:10 <absence> nand`: exactly that, thanks :D
14:28:14 <dmwit> shapr: System.Info.compilerVersion
14:28:34 <tgeeky_> shapr: another version is like doing this by hand: http://hackage.haskell.org/packages/archive/ghc-paths/0.1.0.8/doc/html/src/GHC-Paths.html
14:28:36 <shapr> dmwit: Thanks!
14:28:41 <tgeeky_> I bet that's what System.Info.compilerVersion does
14:29:20 <dmwit> compilerVersion = __GLASGOW_HASKELL__ -- yup =)
14:29:47 <dmwit> err, compilerVersionRaw = __GLASGOW_HASKELL__
14:29:49 <shapr> Aha, so __GLASGOW_HASKELL__ 704 would be versionBranch = [7,0,4], right?
14:29:54 <tgeeky_> shapr: yep
14:30:01 <dmwit> no
14:30:05 <shapr> no?
14:30:08 <dmwit> versionBranch [7,4]
14:30:20 <dmwit> > 704 `divMod` 100
14:30:21 <lambdabot>   (7,4)
14:30:54 <shapr> > 740 `divMod` 100
14:30:55 <lambdabot>   (7,40)
14:32:15 <dmwit> Hm, that type doesn't look right.
14:32:28 <dmwit> Maybe I meant Lens s s' -> StateT s' m a -> StateT s m a
14:32:28 <tgeeky_> no kidding
14:32:49 <tgeeky_> 742 `divMod` 100
14:32:53 <tgeeky_> > 742 `divMod` 100
14:32:55 <lambdabot>   (7,42)
14:33:47 <tgeeky_> oh, they rollover all of the digits involved mod10, so that should be unambiguious
14:34:09 <tgeeky_> but no they don't because there was a version 6.12.x?
14:36:39 <dmwit> :t \f s -> let (s', f') = f s in f' s'
14:36:40 <lambdabot> forall t t1 t2. (t -> (t1, t1 -> t2)) -> t -> t2
14:37:06 <dmwit> ?unmtl State t1 t2
14:37:07 <lambdabot> t1 -> (t2, t1)
14:37:36 <dmwit> ?src State
14:37:37 <lambdabot> Source not found. :(
14:38:08 <dmwit> :t \f s -> let (f', s') = f s in f' s'
14:38:09 <lambdabot> forall t t1 t2. (t -> (t1 -> t2, t1)) -> t -> t2
14:39:29 <stepkut> esh
14:39:52 <Taneb> Hey #haskell, if you had to choose between Java and Python, which would you go for
14:40:44 <Catnaroek> Taneb: Suicide.
14:40:51 <Taneb> Probably a good choice
14:40:58 <danr> Taneb: Python...
14:41:17 <tac-tics> Suicide seems a lot like _|_.
14:41:22 <parcs`> > Nothing < Just 0
14:41:23 <lambdabot>   True
14:41:47 <tac-tics> parcs`: Improper! Dirty abuse of types!
14:42:08 <tac-tics> > Nothing == Nothing
14:42:09 <lambdabot>   True
14:42:29 <Catnaroek> > Nothing < Just (minBound :: Int)
14:42:30 <lambdabot>   True
14:42:37 <Catnaroek> > Nothing < Just (minBound :: Char)
14:42:39 <lambdabot>   True
14:43:03 <Catnaroek> Well, there we have it.
14:44:04 <codolio> > Nothing < Just undefined
14:44:05 <lambdabot>   True
14:44:16 <Catnaroek> Wow, that is even cooler.
14:44:27 <hpaste> paf31 pasted “generics with datakinds” at http://hpaste.org/70552
14:44:31 <DMcGill> it seems to me that most of my Ord instances are just arbitrary ones so I can use Set and Map rather than with any significant meaning
14:44:41 <DMcGill> see: deriving Ord from VersionRange
14:44:55 <Catnaroek> @hoogle VersionRange
14:44:55 <lambdabot> No results found
14:45:03 <DMcGill> try hayoo, it's in Distribution I think
14:45:12 <Catnaroek> ?
14:45:27 <DMcGill> http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Version.html#t:VersionRange
14:45:35 <DMcGill> hayoo is another search engine like hoogle
14:45:43 <Catnaroek> Ah!
14:45:43 <DMcGill> it covers more packages by default
14:46:15 <DMcGill> funnily enough deriving Ord on VersionRange generates a load of warnings because it uses the raw constructors which are depreciated
14:46:20 <paf31> could someone familiar with the DataKinds extension please help me to understand the issue in the above hpaste?
14:52:28 * hackagebot factual-api 0.3.3 - A driver for the Factual API  http://hackage.haskell.org/package/factual-api-0.3.3 (RudigerLippert)
15:10:25 <enko> in leksah is there a way to modify compiler call?
15:10:35 <enko> i want to add -fllvm
15:11:20 <xplat> > let wat = chr . (65345+) . ord in map wat "lambdabot"
15:11:23 <lambdabot>   "\65453\65442\65454\65443\65445\65442\65443\65456\65461"
15:12:13 <aristid> > maxBound :: Char
15:12:14 <lambdabot>   '\1114111'
15:12:39 <aristid> > chr . succ . ord (maxBound :: Char)
15:12:40 <lambdabot>   Couldn't match expected type `f GHC.Types.Int'
15:12:40 <lambdabot>         against inferred typ...
15:13:15 <xplat> > succ maxBound :: Char
15:13:17 <lambdabot>   *Exception: Prelude.Enum.Char.succ: bad argument
15:13:44 <aristid> > (chr . succ . ord) maxBound
15:13:46 <xplat> > let wat = chr . (65345+) . ord in text $ map wat "lambdabot"
15:13:46 <lambdabot>   *Exception: Prelude.chr: bad argument: 1114112
15:13:48 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
15:15:15 <rwbarton> according to my ghci, the output is a string of 9 boxes :)
15:20:44 <xplat> > let wat = chr . (848+) . ord in text $ map wat "lambdabot"
15:20:46 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
15:21:17 <shachaf> > text . (:[]) . chr $ 128
15:21:20 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
15:22:50 <xplat> mueval fail ꌦ_ꌦ
15:24:06 <c_wraith> mueval doesn't really handle unicode except accidentally
15:24:52 <xplat> it should be less careful then!  ∼̥_∽̥
15:27:30 <jairavax> What do you use Haskell for, primarily? Anyone ever incorporate Haskell into professional work?
15:27:59 * dcoutts is a full-time haskell consultant
15:28:54 * jfischoff uses it as his primary language at work
15:29:35 <dcoutts> jairavax: it's hard to summarise what our clients use Haskell for, it's quite varied. But I guess in general it's hard problems, or ones that'd take a lot more code in other languages.
15:30:28 <dcoutts> personally I mainly use Haskell to write programming tools for Haskell ;-)
15:30:58 <jfischoff> thankfully :)
15:31:49 <strager> jairavax: I'm working on a compiler at work written in Haskell.
15:32:10 <jfischoff> hey strager
15:32:22 <strager> oh hey
15:32:40 <strager> BBC CEO is here; pretty cool.
15:32:52 <jfischoff> BBC?
15:34:13 <jairavax> Oh yeah?
15:34:46 <bgamari> Berkshire Brewing Company?
15:35:50 <jfischoff> British Broadcasting Corporation?
15:39:25 <jesse_> yeah berkshire brewing company
15:39:28 <jesse_> :)
15:46:39 <hayashi> Is there any way of stating in a data constructor leaf that one of the arguments is recursively that data type but only if its constructor matches a given type signature?
15:46:45 <hayashi> Sounds a bit too complicated to exist
15:47:03 <shachaf> hayashi: Maybe with a GADT.
15:47:11 <shachaf> Depends on what you mean.
15:47:33 <strager> heh, no; British Broadcasting Corp
15:47:44 <mdmkolbe> hayashi: examples?
15:48:14 <hayashi> well, say I have data Foo = Bar String | Baz Int Int | Woz Foo, but the parameter to Woz is restricted to those Foo that have constructor type (Int -> Int -> Foo), in other words only Baz can be stored in it
15:48:21 <hayashi> Though to be sure I probably just need to split the datatype
15:48:41 <shachaf> You can do that with a GADT and a tag presumably.
15:48:45 <Taneb> Goodnight!
15:48:48 <shachaf> But splitting the type might well be nicer.
15:49:33 <shachaf> For that matter, ignoring _|_, there's no difference between Woz and Baz other than the constructor name, is there?
15:50:34 <hayashi> ah, I've just given into common sense and split the datatype =P
15:50:38 <mdmkolbe> hayashi: if you define Foo to take a parameter (and be a GADT), then you can do it
15:52:02 <mdmkolbe> Woz :: Foo (Int -> Int -> Foo) -> Foo (Foo (Int -> Int -> Int))
15:52:35 <mdmkolbe> or something like that (too tired right now)
15:52:58 <shachaf> mdmkolbe: But there are much simpler things to do in this case. :-)
15:53:44 <mdmkolbe> agreed
16:08:10 <mrky> hello. what haskell tutorial is usually recommended for someone with prior programming experience?
16:08:18 <hpc> @where lyah
16:08:19 <lambdabot> http://www.learnyouahaskell.com/
16:08:19 <Clint> lyah
16:08:22 <Clint> too slow
16:08:29 <mrky> thanks!
16:08:40 <hpc> haskell is different enough that almost any prior experience will be irrelevant or unhelpful :P
16:10:42 <heatsink> Is lyah recommended over rwh?
16:13:02 <hpc> yes
16:13:07 <hpc> rwh is more of a reference
16:13:21 <hpc> and ironically, rwh itself spurred a lot of development and kind of rendered itself obsolete
16:13:23 <rwbarton> I think LYAH is very good for what it covers but RWH has a broader scope.  So personally I would recommend going through LYAH and then starting somewhere in the middle of RWH
16:13:43 <hpc> unless it's being actively updated
16:13:48 * hpc hasn't checked in a while
16:13:57 <alpounet> hpc, they're preparing a second edition
16:13:59 <rwbarton> (not clear that my recommendation is worth anything though, since I learned Haskell before we had any of these new-fangled "book" things)
16:14:10 <blackdog> i think the best part about LYAH is that after reading it, you won't come into #haskell complaining about how hard monads are :)
16:14:12 <zmv> hipster alert
16:15:07 <shachaf> rwbarton: You learned Haskell before books were invented?!
16:15:13 <rwbarton> Yes.
16:15:26 <shachaf> Hutton's book, _Programming in Haskell_, is quite good, for what it's worth.
16:15:30 <rwbarton> It was difficult, since there were no computers at the time either.
16:15:31 <blackdog> the ancient lambda cave-paintings
16:16:44 <mrky> what about a haskell mode for emacs, with the repl, ability to recompile functions on the fly etc. is there anything like that?
16:16:56 <shachaf> There's haskell-mode.
16:17:01 <heatsink> There's ghci
16:17:18 <hpc> ghci in one terminal, vim in another
16:17:20 <shachaf> You probably won't be able to "recompile functions on the fly" in a ghci session.
16:17:21 <heatsink> Clearly we need to put ghci in emacs
16:17:22 <hpc> is how i prefer to code
16:17:34 <mdmkolbe> "break" breaks at the first matching element is there another function for breaking at the last matching element? (i.e., let (x, y) = break f . reverse in (reverse y, reverse x))
16:17:43 <shachaf> mrky: The main lesson is that your environment doesn't matter at all. Just use something.
16:18:07 <mdmkolbe> (ok, not exactly that b/c the break is on the wrong side of the "breaking" character)
16:18:19 <blackdog> mrky: ghc-mod is quite nice - you get typechecking in the editor
16:18:20 <heatsink> When I interactively test in GHCI, I edit files in emacs and then use :reload in GHCI
16:18:23 <shachaf> mdmkolbe: Probably not, because it's an unnatural operation on lists.
16:18:34 <shachaf> mdmkolbe: Data structures that it's more natural on, like Data.ByteString, do have it.
16:20:25 <mrky> what happens when you reload a file, isn't that recompiling all the functions?  does it restart the session?
16:21:03 <jmcarthur> it basically does. don't count on things you defined within the session still being around after a reload
16:21:16 <jmcarthur> but your history and stuff will still be there
16:21:22 <mrky> okay
16:21:24 <jfischoff> if the file hasn't changed is the session lost?
16:21:33 <jmcarthur> hmm... afaik it's not
16:21:57 <jmcarthur> but this would be an easy claim to disprove
16:22:03 <shachaf> mrky: Oh, all of them, sure.
16:22:11 <shachaf> Not just recompiling one function.
16:23:21 <mrky> ok I thought you can redefine functions in the session since there's a repl. is that why i can't define a function there?   getting parse error when typing main = print "Hello"
16:23:36 <mrky> works if in a file
16:24:01 <ski> `let main = print "Hello"' works in GHCi
16:24:35 <mrky> does that define a function?
16:24:41 <ski> no
16:24:46 <ski> it defines an `IO'-action
16:25:10 <ski> but you can define functions like that, as well, like e.g. `let square x = x*x'
16:26:49 <dmwit> If you think of ghci as being one big IO-based do-block, you won't be far wrong.
16:27:18 <mrky> ok I need to do some reading because I have no idea what IO-based do-block is. :P
16:27:40 <dmwit> If you don't understand that, then ignore it and just follow the rules other people are suggesting blindly.
16:28:02 <rwbarton> you'll get to use them later, when you learn about do blocks :)
16:28:05 <dmwit> When you do learn what it is, you will suddenly understand why your files and ghci seem to use slightly different syntax. =)
16:28:55 <mrky> is IO-block a non-functional code?
16:29:00 <ski> no
16:29:43 <ski> it's a way to write what amounts to imperative code, in a pure system
16:29:54 <mrky> ok
16:29:59 <mrky> I seemed to have blocked GHCI btw
16:30:07 <mrky> I typed let x = x * x
16:30:09 <mrky> typed x
16:30:20 <mrky> and now whenever I press enter I just get newlines
16:30:24 <dmwit> Yep, that's a loop.
16:30:55 <ski> try `<Ctrl>-c' ?
16:31:02 <dmwit> x = x * x = (x * x) * (x * x) = ((x * x) * (x * x)) * ((x * x) * (x * x)) = ...
16:31:23 <ski> mrky : the same would happen if you typed `x = x * x' into a file, loaded it, and asked it to evaluate `x'
16:31:24 <mrky> yeah C-c worked
16:31:53 <ski> `='-bindings are recursive
16:32:14 <jfischoff> mrky: fyi you might have a zombie ghc process you will have to manually kill
16:32:19 <dmwit> > let x = x * x in (x :: Expr) `seq` ()
16:32:20 <lambdabot>   ()
16:32:36 <ski> assuming `Integer' by defaulting, yes :)
16:32:38 <dmwit> There exist types for which that expression is not a loop, I suppose. ^_^
16:33:08 <ski> (`Expr' is known to be a hack)
16:34:58 <dmwit> Hm, I wonder if Expr's Show instance is lazy enough...
16:35:04 <dmwit> > let x = x * x in x :: Expr
16:35:10 <lambdabot>   mueval: ExitFailure 1
16:35:10 <lambdabot>  mueval: Prelude.undefined
16:35:57 <dmwit> > ((x * x) * (x * x)) * ((x * x) * (x * x))
16:36:01 <lambdabot>   x * x * (x * x) * (x * x * (x * x))
16:36:03 <dmwit> ah
16:36:11 <ski> > fix negate :: Expr
16:36:15 <lambdabot>   negate (negate (negate (negate (negate (negate (negate (negate (negate (neg...
16:36:32 <dmwit> > let x = -x in x :: Expr
16:36:33 <ski> the problem is left-recursion
16:36:33 <lambdabot>   negate (negate (negate (negate (negate (negate (negate (negate (negate (neg...
16:37:01 <dmwit> ski: Alternately, the problem is that Expr assumes left-associative (*) in its Show instance.
16:37:51 <dmwit> You could reasonably hope that show (fix (join (*))) = fix ('(':)
16:37:53 <ski> well, `*' *is* left-associative ..
16:38:10 * dmwit nods agreeably
16:38:32 <ski> > fix (join (**)) :: Expr
16:38:35 <lambdabot>   (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((...
16:44:57 <jfischoff> Can anyone point me to some examples of complex error and warning handling…out of ghc itself?
16:45:49 <jfischoff> trying to refactor my Either String to something that can have types of errors and warnings with configuration for what types of warnings should be treated as errors, etc..
16:46:41 <alpounet> web servers/frameworks maybe?
16:46:47 <c_wraith> Huh.  The code I wrote for that was only used in an internal project, never released.
16:47:12 <gumdrop> jfischoff: you may be interested in this: http://book.realworldhaskell.org/read/error-handling.html
16:48:15 <jfischoff> c_wraith: how did you go about it?
16:49:27 <c_wraith> jfischoff: a combination of StateT and MaybeT.  the state consisted of a list of errors/warnings.  the call to log a warning altered the state, but let execution proceed.  The call to log an error caused execution to short-circuit
16:49:58 <c_wraith> jfischoff: then I added some combinators for "run this action, recovering if there were any errors" and "run this action, then fail if there were any warnings"
16:50:01 <gumdrop> jfischoff: oh and also this http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors there's also a followup to that (called "8 ways revisited" or something)
16:50:05 <dmwit> Sounds like what I did in the sgf package: WriterT for the warnings, EitherT for the errors.
16:50:34 <c_wraith> It was relatively basic, but it worked reasonably well.
16:52:56 <jfischoff> I wondering if I can  get a stack trace in there for errors with something like this: http://hackage.haskell.org/package/monadloc
16:54:42 <adimit> is there a library that gives file timestamps as Data.Time.LocalTime.LocalTime (or UTCTime or whatnot) and not as ClockTime, which System.Directory does?
16:55:55 <adimit> Hoogle has been hugely unhelpful by just spitting out various String -> X functions for my query "FilePath -> LocalTime"
16:56:02 <jfischoff> I'm trying to get a sense of all the features that I want. I would like to be able to turn warnings on and off, make them errors. Show call stacks for errors. Is there something else useful to do with errors and warnings?
16:56:27 <dmwit> ack, black text on a dark-gray background
16:56:35 <jfischoff> yeah right
16:56:58 <rwbarton> well FilePath -> IO LocalTime would be closer for sure
16:57:35 <dmwit> jfischoff: The other thing you're going to want is warning levels, or perhaps different sets of warnings, i.e. to support something like -v3 or -fno-warn-incomplete-patterns, etc.
16:57:47 <jfischoff> yep
16:58:50 <jfischoff> so I guess categories for warnings as well
16:59:25 <jfischoff> and then different ways of logging, i.e. to a file to the screen
17:06:12 <ptrf> hmm
17:06:18 <ptrf> in the typeclassopedia
17:07:23 <ptrf> when discussing applicative, the ziplist way of having a list be an instance of Applicative, the pure instance is left undone
17:07:30 <ptrf> am I right in letting it be pure a = ZipList { getZipList = repeat a }
17:07:41 <hpc> yes
17:07:46 <ptrf> lovely
17:07:53 <ptrf> it starts to make a little more sense now :-)
17:10:33 <ptrf> thanks
17:12:22 <ptrf> the typeclassopedia is really great
17:12:27 <ptrf> but my bed is calling
17:12:33 <ptrf> g'night, thanks for the help
17:32:20 <adnap> @hoogle Bool -> a -> a -> a
17:32:21 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
17:32:21 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
17:32:21 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
17:34:03 <adnap> i wrote a function that maps an angle to the interval (-pi, pi): angle x = if x < 0 then x - (fromIntegral . ceiling $ x / (2 * pi)) * (2 * pi) else x - (fromIntegral . floor $ x / (2 * pi)) * (2 * pi) can anyone simplify it?
17:34:25 <rwbarton> @type mod'
17:34:27 <lambdabot> forall a. (Real a) => a -> a -> a
17:34:48 <rwbarton> this is like mod but for floating point
17:34:49 <adnap> > 7.13 `mod` (2 * pi)
17:34:51 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:34:51 <lambdabot>    `GHC.Real.Integral a'
17:34:51 <lambdabot>   ...
17:34:59 <adnap> > 7.13 `mod'` (2 * pi)
17:35:00 <lambdabot>   0.8468146928204137
17:35:05 <adnap> > -7.13 `mod'` (2 * pi)
17:35:06 <lambdabot>   -0.8468146928204137
17:35:16 <rwbarton> > (-7.13) `mod'` (2 * pi)
17:35:17 <lambdabot>   5.436370614359173
17:35:27 <adnap> rwbarton: ty
17:35:42 <Cieplak> Does anyone here have experience with HDBC?
17:35:49 <c_wraith> sure.
17:36:06 <Cieplak> I have a SqlValue
17:36:19 <Cieplak> that I am trying to turn into a string
17:36:21 <c_wraith> though my experience is along the lines of "this is painful unless you need to write backend-agnostic code"
17:36:37 <Cieplak> Couldn't match expected type `SqlValue'                 with actual type `IO [[SqlValue]]'
17:37:01 <Cieplak> haha
17:37:04 <c_wraith> oh.  Do you know how to do IO in haskell in general?
17:37:09 <Cieplak> Not really
17:37:14 <c_wraith> thought so.
17:37:20 <Cieplak> haha
17:37:53 <Cieplak> Is there a function that I can wrap
17:37:56 <Cieplak> fromSql x
17:38:10 <Cieplak> with so that it works
17:38:19 <rwbarton> what's "it"
17:38:47 <Cieplak> let x = quickQuery conn "select * from foo" []
17:38:54 <gumdrop> adnap: the 'then' branch and 'else' branch differ only in ceiling and floor, right? you could just write "angle x = x - (fromIntegral . (if x < 0 then ceiling else floor) $ x / (2 * pi)) * (2 * pi)
17:39:18 <rwbarton> if you want to convert SqlValue to String you can use show
17:39:28 <rwbarton> unless that's not the conversion you want
17:39:29 <c_wraith> Cieplak: try this instead:  x <- quickQuery conn "select * from foo" []
17:39:33 <Cieplak> x is then [[SqlByteString "1",SqlByteString "Hello"],[SqlByteString "2",SqlByteString "World"]]
17:39:36 <c_wraith> Cieplak: assuming you're in an IO block
17:39:44 <Cieplak> yes
17:39:50 <Cieplak> actually i'm in ghci
17:40:00 <c_wraith> Cieplak: ghci works like a do block
17:40:06 <c_wraith> Cieplak: so that'll work
17:40:21 <Cieplak> I just tried show x
17:40:35 <Cieplak> and   No instance for (Show (IO [[SqlValue]]))
17:40:48 <rwbarton> right, do what c_wraith said
17:40:49 <c_wraith> Cieplak: bind with <- instead of let
17:40:50 <adnap> gumdrop: ty. i was looking for Bool -> a -> a -> a so i could do that. i don't know why i didn't think of "if"!
17:41:28 <benmachine> @pl return ()
17:41:28 <lambdabot> return ()
17:41:30 <Cieplak> c_wraith: Thank you!!!
17:41:57 <rwbarton> and if you're at the ghci prompt, you don't need show, since just typing 'x' means 'print x'
17:42:01 <Cieplak> c_wraith: what is the difference between using let and <- ?
17:42:02 <gumdrop> damn hoogle doesn't even find if ;-)
17:42:45 <c_wraith> Cieplak: in a very hand-wavey sense, using <- removes the IO.  (not exactly true, but a useful first step)
17:42:57 <Cieplak> ok
17:43:09 <c_wraith> Cieplak: more explicitly, it means "actually run the action, and store the result in the name I gave"
17:43:18 <c_wraith> Cieplak: where a let doesn't actually run the action
17:43:26 <Cieplak> because it's lazy?
17:43:36 <rwbarton> 'quickQuery conn "select * from foo" []' is a description of an action
17:43:40 <rwbarton> not the result of that action
17:43:43 <Cieplak> oh
17:43:44 <c_wraith> in this case, no.  Just because binding is the only way to actually *execute* IO
17:43:55 <rwbarton> nothing to do with laziness directly
17:43:57 <Cieplak> ok
17:44:10 <rwbarton> 'let x = quickQuery conn "select * from foo" []' just makes x another name for that action
17:44:11 <Cieplak> thank you for your help
17:45:04 <Cieplak> how can I select an element from the SqlValue?
17:45:29 <Cieplak> I'm thinking of it as an array
17:45:50 <rwbarton> [[SqlValue]] is a list of lists of SqlValues
17:45:55 <rwbarton> select based on what, index?
17:45:59 <Cieplak> yes
17:46:06 <rwbarton> you can use !!
17:46:16 <rwbarton> e.g. x !! 0 !! 1
17:46:26 <Cieplak> awesome!
17:46:27 <copumpkin> oh I thought rwbarton was just very enthusiastic
17:46:30 <rwbarton> however if you use !! a lot on the same list, you are probably doing something wrong
17:46:49 <hpc> or if you parameterize over the index
17:47:15 <Cieplak> what do you mean parametrize over the index?
17:47:28 <parcs`> is this still implemented in ghc: http://research.microsoft.com/en-us/um/people/simonpj/papers/optimistic/
17:47:36 <hpc> let foo x = blah blah blah (list !! x)
17:47:54 <Cieplak> ah
17:48:08 <hpc> because it might not be apparent from the context of the function that it takes linear time
17:48:28 <Cieplak> is there a way to make it O(1)?
17:48:40 <parcs`> aw, it's not: http://www.haskell.org/pipermail/haskell/2006-August/018424.html
17:49:10 <rwbarton> you should consider first whether it matters, e.g., if you only use !! once on a particular list, the cost of indexing is much less than the cost of getting the data from the DB in the first place
17:49:20 <Cieplak> true
17:49:45 <rwbarton> but yes, there are arrays which have O(1) index and you could put the data you get into an array
17:50:28 <Cieplak> but would the operation of putting it from the SqlValue into the array make it O(n) anyways?
17:51:10 <rwbarton> you have to pay a cost once proportional to the amount of data you are putting into the array, then you can make many O(1) accesses
17:51:25 <Cieplak> maybe if you want to persist a big array that has to be queried often
17:51:35 <rwbarton> right
17:51:44 <Cieplak> like memcache or sometihng
17:54:39 <gumdrop> Cieplak: i suggest you write your program in the simplest, most direct way. if profiling then discovers that this use of (!!) is a bottleneck, you can still think about optimization. but chances are you won't have to
17:55:24 <Cieplak> gumdrop: good point
17:55:34 <Cieplak> premature optimization
17:55:48 <mizu_no_oto> I know that there's Categories for the Working Mathematician.  But has anyone ever written a good Categories for the Working Haskell Hacker?  i.e. something that would go over the same sort of material, but use more programming examples (e.g. rose trees are the co-free comonad of lists) and less in the way of examples from topology, etc.?
17:55:48 <lambdabot> mizu_no_oto: You have 1 new message. '/msg lambdabot @messages' to read it.
17:55:57 <Cieplak> Mostly I'm just trying to learn the language
17:56:01 <gumdrop> Cieplak: exactly :)
17:56:33 <enko> does anyone compile their haskell via llvm?
17:56:37 <rwbarton> (!!) is usually not idiomatic Haskell, but in this case where your list is really more like a record it makes sense, and in any event it's better than nothing :)
17:56:49 <liyang> mizu_no_oto: there's this one by Pierce: http://www.amazon.co.jp/dp/0262660717
17:56:51 <enko> if so how are you doing it? (ide, os)
17:57:09 <Cieplak> rwbarton: What would the idiomatic Haskell be?
17:57:32 <adnap> wtf...
17:57:33 <rwbarton> well it depends on the situation, but for example if you wanted to do something to each element of a list, you wouldn't loop over 0..n-1 and do xs !! i
17:57:39 <Cieplak> haha
17:57:42 <adnap> > (-3 * pi / 2 - pi)
17:57:44 <lambdabot>   -7.853981633974483
17:57:45 <rwbarton> you would use a map or a mapM or something
17:57:47 <Cieplak> map
17:57:49 <adnap> > (-3 * pi / 2 - pi) `mod'` (2 * pi)
17:57:50 <lambdabot>   4.71238898038469
17:57:51 <mizu_no_oto> liyang: have you read it?  How good is it?
17:57:53 <rwbarton> right okay
17:58:01 <rwbarton> you don't need my warning then :)
17:58:04 <adnap> > -7.853981633974483 `mod'` (2 * pi)
17:58:05 <lambdabot>   -1.5707963267948966
17:58:29 <Cieplak> i'm looking for a function with a signature like sqlbytestring -> string
17:58:33 <Cieplak> and Hoogle hasn't proved helpful
17:58:51 <Cieplak> http://www.haskell.org/hoogle/?hoogle=sqlbytestring+-%3E+string
17:59:23 <liyang> mizu_no_oto: I haven't gone through it properly, but it seems fairly introductory.
18:00:09 <otters> huh
18:00:18 <otters> I wonder why SqlValue doesn't derive Eq
18:00:33 <adnap> can someone explain the above?
18:00:43 <mizu_no_oto> liyang: Where does it generally pull examples from?  Could you read it without having taken any topology and only a first course on abstract algebra?
18:01:06 <adnap> i expect (-3 * pi / 2 - pi) `mod'` (2 * pi) = -1.5707963267948966
18:01:14 <liyang> I seem to remember it doesn't assume much, if anything.
18:01:25 <rwbarton> mod' always has a nonnegative result (if the modulus is positive), like mod
18:01:44 <adnap> rwbarton: i don't think that is true
18:01:52 <adnap> > -7.853981633974483 `mod'` (2 * pi)
18:01:53 <lambdabot>   -1.5707963267948966
18:01:54 <rwbarton> you have written -x `mod'` y which means -(x `mod'` y)
18:02:05 <adnap> oops
18:02:13 <adnap> > (-7.853981633974483) `mod'` (2 * pi)
18:02:15 <lambdabot>   4.71238898038469
18:02:29 <adnap> rwbarton: ty
18:02:41 <Eduard_Munteanu> mizu_no_oto: there's Awodey's book, and it does have topology-related examples, however most of that is optional. He does give some CS-related examples too, e.g. those related to quantifiers, lambda calculus etc.
18:03:13 <Eduard_Munteanu> mizu_no_oto: but you won't find it much like edwardk's blog posts, if that's what you're expecting :)
18:03:37 <adnap> i am still having a hard time producing my original function in terms of mod'
18:03:39 <hpaste> irene-knapp pasted “Just a table of contents, don't mind it” at http://hpaste.org/70556
18:04:47 <Eduard_Munteanu> mizu_no_oto: btw, there's ##categorytheory ;)
18:08:27 <adnap> let angle' x = if x < 0 then (x - pi) `mod'` (-2 * pi) else (x + pi) `mod'` (2 * pi)
18:10:26 <adnap> oops. should be let angle' x = if x < 0 then (x - pi) `mod'` (-2 * pi) + pi else (x + pi) `mod'` (2 * pi) - pi
18:11:26 <rwbarton> couldn't it just be (x + pi) `mod'` (2 * pi) - pi
18:11:53 <rwbarton> hmm
18:11:58 <rwbarton> > 3 `mod'` (-5)
18:11:59 <lambdabot>   -2
18:12:09 <rwbarton> oh i misread what you wrote, okay
18:13:09 <adnap> rwbarton: i think that works
18:14:57 <adnap> > let x = (7 * pi) in (x + pi) `mod'` (2 * pi) - pi
18:14:59 <lambdabot>   -3.141592653589793
18:15:04 <adnap> i sort of expect that to be pi
18:15:17 <rwbarton> well the function is discontinuous there
18:16:43 <adnap> > let x = (7 * pi) in (x + pi + 0.1) `mod'` (2 * pi) - pi - 0.1
18:16:44 <lambdabot>   -3.141592653589792
18:18:34 <adnap> > let x = (7 * pi) in (x - pi) `mod'` (2 * pi) + pi
18:18:35 <lambdabot>   3.141592653589793
18:18:38 <adnap> yay
18:18:50 <adnap> > let x = (-7 * pi) in (x - pi) `mod'` (2 * pi) + pi
18:18:52 <lambdabot>   3.141592653589793
18:18:56 <aristid> > pi
18:18:57 <lambdabot>   3.141592653589793
18:19:11 <aristid> adnap: simplified the formula for you ;)
18:19:19 <adnap> lol
18:19:39 <adnap> i'm trying to make a function that maps angles to [-pi,pi]
18:19:50 <adnap> and i want f pi = pi and f (-pi) = -pi
18:20:04 <aristid> angles? as in 0 to 360 degrees?
18:20:19 <aristid> oh
18:20:27 <adnap> radians
18:20:50 <aristid> > let angle d = d mod' (2*pi) - pi in angle 2*pi
18:20:51 <lambdabot>   -3.5864190939097718
18:21:05 <aristid> > let angle d = (d mod' (2*pi)) - pi in angle 2*pi
18:21:06 <lambdabot>   -3.5864190939097718
18:21:15 <aristid> oh, lol
18:21:18 <dibblego> what is the name of the haskell (?Ed Kmett's) package that explores which monads compose?
18:21:19 <aristid> > let angle d = (d mod' (2*pi)) - pi in angle (2*pi)
18:21:20 <lambdabot>   3.141592653589793
18:21:43 <adnap> aristid: why don't you look at what was typed so far?
18:21:56 <aristid> adnap: because you have weird factors like 7
18:22:02 <aristid> adnap: those shouldn't be there!
18:22:07 <adnap> aristid: that was just a test!
18:22:54 <dmwit> adnap: How would you feel if it mapped pi to -pi instead?
18:23:03 <adnap> dmwit: bad
18:23:08 <dmwit> Why?
18:23:08 <aristid> adnap: oh. well it's your fault for some reason anyways ;)
18:23:14 <adnap> aristid: wtf
18:23:26 <dibblego> instance (Monad f, Monad g) => Compose f g — does not exist, however, I recall a package (?name) that looks at finding restrictions that do
18:23:56 <adnap> aristid: let x = bla in exp accomplishes let f x = exp in f x
18:24:33 <adnap> dmwit: 'cause pi is in the interval [-pi, pi], so it shouldn't change
18:25:16 <aristid> adnap: shouldn't the interval be closed at exactly one side for sanity?
18:25:38 <adnap> oh yeah!
18:26:00 <aristid> (-pi,pi] would be fine i guess
18:28:23 <adnap> okay, now i'm fine with
18:28:24 <adnap> let f x = (x - pi) `mod'` (2 * pi) + pi
18:35:00 <adnap> rwbarton: can you explain your comment "well the function is discontinuous there"
18:36:16 <aristid> > let f x = (x - pi) `mod'` (2 * pi) + pi in map f [-pi, 0, 1, pi, 2*pi]
18:36:17 <lambdabot>   [3.141592653589793,6.283185307179586,7.283185307179586,3.141592653589793,6....
18:36:56 <aristid> adnap: doesn't look all perfect to me
18:38:40 <adnap> oh, i forgot that a discontinuity can be something where the derivative of the function does not exist
18:38:52 <adnap> but the function can still be evaluated at all points
18:41:27 <adnap> perhaps the function is C^0 continuous but not C^1
18:45:12 <Eduard_Munteanu> adnap: mind the derivative might not exist at some point, yet the function can be continuous
18:45:23 <Eduard_Munteanu> e.g. f(x) = |x|
18:45:35 <adnap> right
18:46:03 <adnap> i was confused because rwbarton said f x = (x - pi) `mod'` (2 * pi) + pi is not continuous. perhaps he meant not C^1 continuous?
18:46:22 <adnap> or not differentiable
18:47:00 <Eduard_Munteanu> I'm not sure what mod' is.
18:47:06 <adnap> it's floating point mod
18:47:23 <adnap> > 3.1 `mod'` 2.2
18:47:25 <lambdabot>   0.8999999999999999
18:47:44 <ion> > 3.1 `mod'` 2.2 :: CReal
18:47:45 <lambdabot>   *Exception: CReal.toRational
18:47:46 <Eduard_Munteanu> Ah, well, graph it.
18:47:56 <Eduard_Munteanu> It should be apparent.
18:48:40 <Eduard_Munteanu> It should look like a sawtooth.
18:50:54 <Eduard_Munteanu> The discontinuities appear when x - pi is a multiple of 2 * pi.
18:52:19 <gurrag> is fmap a builtin?  There's no @src listing for it on lambdabot
18:52:31 <Eduard_Munteanu> :t fmap
18:52:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:52:36 <dibblego> it's built-in, but the source depends on the type-class instance
18:52:37 <Eduard_Munteanu> @src Functor Maybe
18:52:38 <lambdabot> Source not found. You type like i drive.
18:52:46 <dibblego> @src fmap Maybe
18:52:46 <lambdabot> Source not found.
18:52:50 <dibblego> @src Maybe fmap
18:52:51 <lambdabot> fmap _ Nothing       = Nothing
18:52:51 <lambdabot> fmap f (Just a)      = Just (f a)
18:53:07 <Eduard_Munteanu> It's not actually a "builtin" as a special language thing.
18:53:17 <Eduard_Munteanu> It's just there in the standard library, that's all.
18:53:40 <Eduard_Munteanu> And it's a typeclass method, not a normal function.
18:56:48 <adnap> oh. i just realized there is a crucial difference between (x + pi) `mod'` (2 * pi) - pi and (x - pi) `mod'` (2 * pi) + pi
18:58:47 <adnap> > let (f, g) = (\x->(x + pi) `mod'` (2 * pi) - pi, \x->(x - pi) `mod'` (2 * pi) + pi) in (f (6 * pi), g (6 * pi))
18:58:49 <lambdabot>   (0.0,6.283185307179586)
18:59:07 <aristid> Eduard_Munteanu: which plotting package would you use for such simple plots?
18:59:29 <gumdrop> aristid: wolfram alpha?
18:59:31 <Eduard_Munteanu> In Haskell, or in general?
18:59:36 <aristid> in haskell
18:59:40 <Eduard_Munteanu> In Haskell, 'chart' sounds like it.
19:00:02 <Eduard_Munteanu> Generally, gnuplot or octave.
19:00:04 <adnap> can it plot lists?
19:00:16 <adnap> plot :: [a] -> Plot
19:00:25 <Eduard_Munteanu> I guess so, haven't been using it for some time.
19:00:29 <adnap> or lists of tuples
19:00:31 <adnap> okay
19:03:08 <dmwit> adnap: Did you not get your plusses and minuses mixed up there?
19:03:25 <dmwit> Oh, yes, I see that at 21:56 you discovered this yourself.
19:03:51 <dmwit> > let f x = (x - pi) `mod'` (2*pi) + pi in f pi
19:03:53 <lambdabot>   3.141592653589793
19:03:59 <dmwit> > let f x = (x - pi) `mod'` (2*pi) + pi in f (-pi)
19:04:01 <lambdabot>   3.141592653589793
19:04:17 <dmwit> Okay, I got a sign wrong in my probe question anyway. =)
19:04:30 <dmwit> should have been "how would you feel if f -pi = pi?" =)
19:04:38 <ApacheBeard_> is haskell faster than python?
19:04:38 <adnap> > let f x = (x - pi) `mod'` (2*pi) + pi in f (6 * pi)
19:04:40 <lambdabot>   6.283185307179586
19:04:43 <adnap> that's the problem
19:04:43 <ApacheBeard_> python2.7
19:04:59 <pcavs> ApacheBeard_: for most things that don't spend most of their time in syscalls, yes.
19:05:01 <dmwit> > let f x = (x + pi) `mod'` (2*pi) - pi in f pi
19:05:03 <lambdabot>   -3.141592653589793
19:05:06 <dmwit> Oh, goodie!
19:05:07 <adnap> the function needs to map to [-pi,pi) or (-pi,pi]
19:05:09 <dmwit> I got my question right, after all!
19:05:21 <Eduard_Munteanu> ApacheBeard_: AFAIK, it is, in many cases. See http://shootout.alioth.debian.org/ for a (just-as-flawed) benchmark :D
19:06:23 <Eduard_Munteanu> (although I usually like to say the interpretation is flawed, rather than the benchmark :P)
19:06:58 <Eduard_Munteanu> @where shootout
19:06:59 <lambdabot> http://shootout.alioth.debian.org/
19:07:06 <Eduard_Munteanu> Hm, good, it's there too.
19:07:36 <adnap> suppose i want the function that maps angles to (-pi, pi]
19:07:40 <Eduard_Munteanu> adnap: if you restrict its domain, it can be continuous
19:07:57 * gienah wonders is F# is cheating on the threadring benchmark, wonders if there should be some sort of async benchmark stuff like F# async workflows
19:09:36 <Eduard_Munteanu> adnap: that sounds like f x = pi - x assuming radian inputs in [0, 2*pi)
19:10:10 <adnap> Eduard_Munteanu: i want a function that maps all angles to (-pi, pi]
19:10:36 <adnap> f x = (x + pi) `mod'` (2 * pi) - pi does [-pi, pi)
19:10:55 <Eduard_Munteanu> pi - (x `mod` 2 * pi)?
19:10:58 <mrky> why am I getting errors?  take 5 map (^ 2) [1..]
19:11:07 <Eduard_Munteanu> erm, mod'
19:11:20 <Eduard_Munteanu> and (2 * pi)
19:11:24 <parcs`> mrky: why wouldn't you be getting errors?
19:11:38 * Eduard_Munteanu should tune into a proper language mode
19:12:12 <Eduard_Munteanu> mrky: that's   (((take 5) map) ... )
19:12:41 * hackagebot ghc-mod 1.11.0 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.11.0 (KazuYamamoto)
19:13:15 <adnap> Eduard_Munteanu: g x = pi - (x `mod'` (2 * pi)) maps pi to 0
19:14:19 <Eduard_Munteanu> Oh, yeah, I didn't take that into account.
19:14:20 <mrky> eduard I see.  take 5 (map (^ 2) [1..]) works
19:14:36 <Eduard_Munteanu> mrky: or  take 5 $ ...   or take 5 . ...
19:14:50 <Eduard_Munteanu> (if you add a $ before [1..)
19:15:25 <dmwit> adnap: Are you ready for this?
19:15:34 * adnap holds on tight
19:15:45 <dmwit> f x | x == pi = x | otherwise = ...
19:15:57 <dmwit> No, that's buggy.
19:15:57 <Eduard_Munteanu> Yep ^^
19:15:58 <adnap> ewww
19:16:00 <dmwit> But this one is better.
19:16:03 <Eduard_Munteanu> But you have to do mod' first.
19:16:25 <dmwit> f x = (x + pi) `mod'` (2 * pi) - pi; g (f -> x) | x == -pi = pi | otherwise = x
19:16:41 <rwbarton> how about f x = pi - ((pi - x) `mod'` (2 * pi))
19:17:00 <rwbarton> anyways it's a bit silly to worry about the difference between (-pi,pi] and [-pi,pi) when you're doing floating point
19:17:08 <dmwit> rwbarton: much cleaner
19:17:29 <adnap> huzzah
19:17:33 <adnap> rwbarton: ty
19:17:47 <rwbarton> (I just simplified -f(-x))
19:18:14 <rwbarton> from the [-pi,pi) version
19:18:15 <adnap> i see
19:18:34 <adnap> how did you think of doing that?
19:19:54 <dmwit> adnap: step 1. notice that [-pi,pi) = -(-pi,pi]; step 2. brilliance
19:19:54 <adnap> nvm. now i see
19:19:59 <adnap> yeah
19:20:11 <Eduard_Munteanu> 3. Profit!!!11
19:20:17 <adnap> lol
19:20:22 <adnap> you can't make money with haskell
19:20:51 <aristid> that's just the "avoid success at all costs" propaganda
19:21:28 <adnap> i wish all the programmer jorbs were haskell
19:21:52 <aristid> Eduard_Munteanu: i don't like the Chart API much
19:21:57 <dmwit> no way
19:22:07 <dmwit> Then I'd have to learn an even more esoteric language to be able to scoff at people.
19:22:17 <adnap> aristid: can it plot lists?
19:22:23 <aristid> adnap: yes
19:22:30 <aristid> adnap: but i still don't like the API :)
19:22:31 <adnap> aristid: and lists of tuples?
19:22:40 <aristid> didn't check that.
19:22:42 <Ralith> dmwit: might I suggest idris?
19:22:50 <Eduard_Munteanu> aristid: have you seen http://hackage.haskell.org/packages/archive/Chart/0.15/doc/html/Graphics-Rendering-Chart-Simple.html  ?
19:22:51 <aristid> adnap: look for yourself: http://hackage.haskell.org/package/Chart
19:22:56 <aristid> Ralith: safe bet i'd say
19:23:02 <adnap> ooo-kay
19:23:07 <aristid> Eduard_Munteanu: yes, that's the one i especially dislike
19:23:13 <Eduard_Munteanu> Heh, fair.
19:23:47 <adnap> dmwit: do you know racket?
19:24:09 <dmwit> I know the name.
19:24:38 <adnap> aristid: the answer is yes
19:24:51 <otters> why doesn't printf just take a list?
19:25:00 <rwbarton> a list of what
19:25:07 <otters> oh
19:25:10 <otters> that's why
19:25:23 <adnap> are you talking about C?
19:25:28 <otters> no, Haskell
19:25:38 <adnap> @t printf
19:25:39 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:25:52 <adnap> @hoogle printf
19:25:52 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
19:25:53 <lambdabot> Text.Printf class PrintfArg a
19:25:53 <lambdabot> Text.Printf class PrintfType t
19:25:53 <aristid> rwbarton: it could take a list with a sum type :)
19:25:58 <rwbarton> internally it does
19:26:05 <Eduard_Munteanu> A HList :)
19:26:07 <dmwit> otters: If you like, you can think of it as taking an HList... but also being deeply uncurried.
19:26:24 <dmwit> err... curried, I guess
19:26:46 <rwbarton> data UPrintf = UChar Char | UString String | UInteger Integer Integer | UFloat Float | UDouble Double; uprintf :: String -> [UPrintf] -> String
19:27:27 <aristid> Eduard_Munteanu: the non-simple API seems quite a bit better actually
19:27:48 <Eduard_Munteanu> aristid: hm... any particular thing you dislike?
19:28:44 <aristid> Eduard_Munteanu: just take this: plotPDF "foo.pdf" [0,0.1..10] sin "- " cos ". " cos "o"
19:28:49 <aristid> that's just too "magicky"
19:28:59 <aristid> i'd expect that in a javascript library ;)
19:29:13 <rwbarton> what on earth
19:29:28 <rwbarton> oh are those line styles?
19:29:32 <Eduard_Munteanu> Yeah.
19:29:35 <aristid> rwbarton: yup
19:29:38 <rwbarton> that's sort of ... something
19:29:59 <dmwit> Just looking at the types, I have to wonder how it guarantees there's (exactly? at most?) one style per function.
19:30:19 <dmwit> The fact that I have to ask "exactly? at most?" also bothers me. The type should say this.
19:30:20 <aristid> dmwit: i guess it'll just pick the latest or so
19:30:29 <rwbarton> i believe the word you are looking for is "hopefully"
19:30:54 <dmwit> rwbarton: heh
19:31:18 <rwbarton> couldn't it work though
19:32:35 <rwbarton> is it using the IsPlot Char instance?!
19:32:48 <rwbarton> desperately clinging to Haskell 98 compatibility
19:33:02 <rwbarton> for the line styles
19:33:49 <aristid> this API is nicer: http://dockerz.net/twd/HaskellCharts/Example1
19:34:17 <rwbarton> in the past i've found the gnuplot library to be pretty easy to use
19:34:48 <ClaudiusMaximus> Text.Encoding.Z> zDecodeString "z0"
19:34:48 <ClaudiusMaximus> "*** Exception: decode_num_esc: 0
19:34:51 <ClaudiusMaximus> :-[
19:35:06 <dmwit> preflex: zdec z0
19:35:15 <rwbarton> *** Exception: decode_num_esc: 0
19:35:17 <dmwit> neat
19:35:29 <rwbarton> preflex: zdec z0blah
19:35:37 <rwbarton> preflex: zdec z1blah
19:35:40 <dmwit> preflex: zdec easy
19:35:40 <preflex>  easy
19:35:43 <rwbarton> well i don't really know the format
19:35:53 <dmwit> preflex: easyzmpeasy
19:35:56 <dmwit> um
19:36:14 <rwbarton> zdec = guard (p `notElem`)
19:36:15 <dmwit> ClaudiusMaximus: Anyway, where are you getting a z0 from?
19:36:18 <rwbarton> uh
19:36:20 <rwbarton> zdec = guard ('z' `notElem`)
19:36:24 <dmwit> 0 doesn't need to be encoded, I thought.
19:36:42 <dmwit> rwbarton: hah
19:36:49 <dmwit> preflex: zdec easyzmpeasy
19:36:49 <preflex>  easy-peasy
19:37:00 <ClaudiusMaximus> dmwit: i'm just paranoid - was hoping to use zEncodeString/zDecodeString to round-trip source locations through SCC pragmas
19:37:05 <rwbarton> preflex: zenc 0123&!@#?/#abcd
19:37:06 <preflex>  z30U123zaznz40Uzhz3fUzszhabcd
19:37:11 <ClaudiusMaximus> and profiling output
19:37:23 <rwbarton> this maybe wasn't the best test case
19:37:49 <dmwit> ClaudiusMaximus: You just need a way to notice where the z-encoded stuff starts and stops.
19:38:13 <rwbarton> preflex: zdec z31U
19:38:14 <preflex>  1
19:38:26 <rwbarton> preflex: zdec z0U
19:38:26 <preflex>  
19:38:44 <rwbarton> preflex: zdec z2204U
19:38:44 <preflex>  ∄
19:38:47 <ClaudiusMaximus> dmwit: well my paranoia is probably too extreme in this case :)
19:38:49 <dmwit> preflex: zenc zenc
19:38:49 <preflex>  zzenc
19:39:17 <rwbarton> interesting
19:39:20 <liyang> preflex: zenc ztop
19:39:20 <preflex>  zztop
19:39:25 <aristid> rwbarton: the "Simple" gnuplot API seems decent enough
19:39:37 <rwbarton> when i paste ∄ into chrome's address bar and press delete, it changes first to ∃
19:39:46 <rwbarton> i should say backspace i guess
19:40:17 <liyang> it canonicalised Not-Exists to Exists and the Not composing character.
19:40:25 <ClaudiusMaximus> dmwit: because i'm converting (srcfile, startline, startcolumn, endline, endcolumn) to SCCPrama  zEncodeString srcfile ++ concatMap (('-':) . show) [startline, startcolumn, endline, endcolumn]
19:40:37 <rwbarton> thanks?
19:40:38 <rwbarton> :P
19:41:25 <rwbarton> preflex: zenc 0
19:41:25 <preflex>  z30U
19:41:45 <dmwit> ClaudiusMaximus: So change it to SCCPragma zEncodeString (length srcfile) ++ "-" ++ zEncodeString srcfile ++ concatMap blah
19:41:47 <rwbarton> what's z0 supposed to be
19:42:03 <ClaudiusMaximus> > showHex (ord '0') ""
19:42:04 <lambdabot>   "30"
19:42:07 <ClaudiusMaximus> rwbarton: it's not allowed
19:42:18 <dmwit> rwbarton: I think he's just scared of zdecoding something that didn't come out of zEncodeString by accident and getting an exception.
19:42:21 <dmwit> not 100% sure
19:42:23 <ClaudiusMaximus> i was hoping for a Maybe result instead of error
19:42:28 <rwbarton> ahh
19:43:00 <dmwit> or better yet
19:43:15 <Eduard_Munteanu> SPOON
19:43:16 <Eduard_Munteanu> :P
19:43:22 <dmwit> SCCPragma zEncodeString (show (length (zEncodeString srcfile))) ++ "-" ++ ...
19:44:01 <rwbarton> preflex: zdec zazzbd-0-1-2-3
19:44:01 <preflex>  &zbd-0-1-2-3
19:44:13 <ClaudiusMaximus> dmwit: well, still just reduces the risk :P  which was already exceedingly small ;)
19:44:54 <dmwit> Oh, indeed, you already could tell where the zencoded stuff ended.
19:45:11 <rwbarton> isn't it always safe to pass the whole thing through zdec
19:45:33 <dmwit> rwbarton: Again, he's worried about trying to zdec pragmas that didn't come from him.
19:45:36 <dmwit> I think.
19:45:47 <ClaudiusMaximus> yes
19:45:51 <dmwit> And zdec throws exceptions when it doesn't know what to do.
19:46:07 <rwbarton> oh i thought he was zdecing the whole string and it was going to be built wrong
19:46:22 <ClaudiusMaximus> ghc might add additional scc in profiling output that didn't come from my pgmF
19:46:26 <rwbarton> i.e. only concerned about his own pragmas
19:46:31 <dmwit> So, yes, I think either hacking zdec to expose a Maybe or []-based answer would be best, and using spoon or similar would be second-best.
19:46:32 <rwbarton> well, it could add anything right
19:46:49 <rwbarton> SCCPragma "ClaudiusMaximus" ++ ...
19:46:53 <ClaudiusMaximus> heh
19:47:23 <dmwit> rwbarton: That works great right up to the moment I define data Gotcha = ClaudiusMaximus and add a cost center...
19:47:26 <dmwit> ;-)
19:48:11 <ClaudiusMaximus> anyway.. http://hackage.haskell.org/packages/archive/zenc/0.1.1/doc/html/src/Text-Encoding-Z.html#zDecodeString if someone feels bored enough to update it
19:48:25 <gurrag> is Maybe a Monad?
19:48:38 <Clint> yes
19:48:40 <gurrag> I feel like I'm on the cusp of finally getting this
19:49:06 <dmwit> ?instances Monad
19:49:07 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
19:49:17 <dmwit> seventh one on the list =)
19:49:45 <serialhex> [] is a monad???
19:49:56 <dmwit> yup!
19:50:03 * serialhex needs to learn much haskell!
19:50:18 <dmwit> > do { x <- [1,2,3]; y <- [10, 20, 30]; return (x+y) }
19:50:19 <lambdabot>   [11,21,31,12,22,32,13,23,33]
19:50:48 <serialhex> ...which is why i'm here; i've got a Q if anyone is willing to help me code it
19:51:21 <serialhex> i have a (mostly working) solution to one of the project eueler Q's... but i have *no idea* on how to code it
19:52:42 * hackagebot github-backup 1.20120627 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20120627 (JoeyHess)
19:52:55 <serialhex> so i dont know if anyone is interested in staying up late and helping me hack on this & learn some haskell in the process...  or even willing to hear if my possible solution is totally wrong :P
19:53:18 <zachk> serialhex: that is why most of the people are in this channel :-D
19:53:38 <copumpkin> joeyh: interesting versioning scheme :P
19:53:44 <serialhex> ok, well, i guess i'll just lay it all out then...
19:53:57 <tactics_[home]> Can ST be modeled as a free monad?
19:54:03 <copumpkin> joeyh: have you seen http://www.haskell.org/haskellwiki/Package_versioning_policy ?
19:54:12 <copumpkin> tactics_[home]: if it can, I don't think anyone's figured it out
19:54:25 <tactics_[home]> hmm
19:54:27 <serialhex> this is the problem: http://projecteuler.net/problem=389
19:56:47 <serialhex> my (possible) solution is this: there are rather easy formulas to find the mean of a set of dice, and the probability of any one of the outcomes... so the mean of 3d6 is 10.5 and the prob of rolling a 7 is... something
19:58:23 <serialhex> there is also a decient way to compute the variance based on the mean & probability of a dice roll... so if i compute the probability of rolling a 6 on 3d6, one can take that probability, times the variance of 6d8... and so on for each one
19:58:58 <serialhex> does that make sense?  or did i loose the one person who was paying attention?
19:59:04 <dmwit> ?hackage probability
19:59:04 <lambdabot> http://hackage.haskell.org/package/probability
19:59:12 <dmwit> And no, that doesn't make sense.
19:59:21 <serialhex> :D awesome!  :P
19:59:39 <serialhex> maybe a picture would help...  -_-
20:00:04 <dmwit> If you just mean "list all the possible outcomes along with their probabilities, and use the formula for variance", well, then... yes.
20:00:07 <dmwit> That's one easy way to do it.
20:00:36 <serialhex> yeah, thats prettymuch it
20:00:36 <dmwit> And the "probability" package can help.
20:01:50 <serialhex> hmm... i just have a horrible time figuring out how on earth to start coding these things...
20:02:01 * serialhex is looking at probability package
20:04:13 <dmwit> d n = uniform [1..n]; distribution = do { t <- d 4; c <- sum <$> replicateM t (d 6); o <- sum <$> replicateM o (d 8); {- etc. -} }
20:04:40 <dmwit> for consistency, you could even write t <- sum <$> replicateM 1 (d 4)
20:05:58 <serialhex> ....?  seriously??
20:06:13 <dmwit> yes
20:06:21 <dmwit> You'd probably want to throw some "norm"s in there for efficiency, though.
20:06:59 <rwbarton> you can also... write a function! dice n k = sum <$> replicateM n (d k)
20:07:13 <serialhex> ok, could you do me a *huge* favor, and explain what everythhing does...
20:08:07 <aristid> serialhex: http://hackage.haskell.org/packages/archive/probability/0.2.4/doc/html/Numeric-Probability-Distribution.html#g:2
20:08:10 <serialhex> i understand [1..n] makes a list [1,2,3...n]
20:10:21 <dmwit> Yes, definitely look at the blog posts linked by the documentation linked by aristid.
20:10:43 * BMeph hints: "uniform" likely stands for "uniform distribution"...
20:10:52 <serialhex> yeah, i know :P
20:11:36 <aristid> it even has a pre-built variance function
20:12:14 <serialhex> i'm just looking at the rest of the code, and haskell is like 3rd on my 'i can program in this language' list, and i'm not super-skilled in any lang :-/
20:12:26 <BMeph> serialhex: That's the risk you run when you say things like "explain what everythhing does" - the stuff you already know gets explained first... ;)
20:12:42 <serialhex> true, thanks BMeph :D
20:13:13 * BMeph goes back to rubbing his hands together and muttering, "SOON..."
20:13:48 <serialhex> soon??  soon what??  :P
20:14:16 <dmwit> Alright, the explanation goes like this.
20:14:35 <dmwit> The simplest representation of a probability distribution over values of type a is [(a, Probability)].
20:14:46 <dmwit> For simplicity, we could take type Probability = Double or some such thing.
20:14:54 <serialhex> okay
20:15:02 <dmwit> There's lots of different interesting ways to combine probabilities.
20:15:32 <cschneid> I'm new to haskell - should I bite the bullet and learn how to parse with a library, or manually? Specifically, the redis wire format is all text, and well structured and I'm trying to parse that
20:16:20 <pooya72> cschneid: I'm new too. By parse manually do you mean use regex?
20:16:22 <dmwit> But one particularly interesting one is this: suppose I have a probability distribution over "a"s (e.g. a probability of rolling a given die roll) and a function from "a"s to distribution over "b"s (e.g. a function from die rolls to distributions over more die rolls). Then I'd like to form the distribution over "b"s that I get by first sampling an "a" and then using it to sample from the appropriate "b" distribution.
20:16:24 <aristid> cschneid: well, firstly there are redis libraries already. you might want to use them.
20:16:28 <dmwit> With me so far?
20:16:37 <cschneid> aristid: a learning exercise is to learn to reimplement the redis server.
20:16:37 <tactics_[home]> cschneid, doesn't really matter. Parsec is nice though.
20:16:44 <dmwit> (We haven't written any code yet. Just an outline of what code we want to write.)
20:17:06 <cschneid> aristid: no hope of production quality, but to learn, redis has a lot of fun problems as a server app :)
20:17:12 <aristid> cschneid: secondly, definitely use a parser combinator library like parsec or attoparsec, if you want to actually parse
20:17:20 <serialhex> ok
20:17:25 * BMeph strangely, finds Rational a much "simpler" prob type...
20:17:25 <serialhex> i'm prettymuch with you
20:17:32 <dmwit> Cool.
20:17:40 <dmwit> Now, I have to ask a bit about what you know before we can write some code.
20:17:43 <dmwit> Do you grok list comprehensions?
20:17:57 <cschneid> ok. It's a simple format - http://redis.io/topics/protocol -- I hope that'd be easy enough to write a parser for? (the first block of commands)
20:18:07 <serialhex> i've heard the term, and i'm sure i've read about them, but quick refresher plz
20:18:12 <aristid> BMeph: i've occasionally just used [a] for distributions, with multiple copies denoting higher probability :D
20:18:20 <dmwit> That's fine if you don't know them.
20:18:24 <dmwit> Do you grok map and concat?
20:18:38 <serialhex> yes
20:18:46 <dmwit> Fine, we'll use those.
20:18:49 <pooya72> cschneid: why not parse json? There's a work through here: http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html
20:18:58 <BMeph> aristid: Now, THAT's clever! :)
20:18:59 <dmwit> So, here's what we're trying to write
20:19:12 <aristid> BMeph: oO
20:19:21 <cschneid> pooya72: because redis has parsing, server, persistent data, and a really cool external test suite that I can leverage to check my implementation)
20:19:27 <dmwit> foo :: (a -> Density b) -> (Density a -> Density b)
20:19:48 <dmwit> serialhex: (I've swapped the order of arguments from the textual description, but hopefully you'll see how this is the same type as the English text above.)
20:19:50 <pooya72> cschneid: that sounds awesome.
20:20:20 <dmwit> type Density a = [(a, Probability)] -- I just realized I never gave this type a name, so let's do that now
20:20:23 <cschneid> pooya72: all on top of a simple to implement thing. Set/Get should be easy, and then you can get into the data structures, etc,etc,etc.
20:20:26 <enko> anyone use leksah with llvm?
20:20:48 <pooya72> cschneid: I'd actually be interested in how you go about doing this...
20:21:00 <cschneid> pooya72: poorly I'm guessing.  Seriously brand new to haskell here
20:21:02 <scooty-puff> given newtype Fix f = Fix (f (Fix f)), can you imagine any reason to have a function have argument f (Fix f) over Fix f, or return type of one or the other?
20:21:08 <serialhex> ok, cool
20:21:16 <cschneid> currently the plan is to parse enough Get/Set commands, and have just Map as a backing store
20:21:20 <cschneid> and be really dumb about things
20:21:22 <dmwit> Right, so
20:21:27 <pooya72> cschneid: I'm new to programming so you're ahead of me
20:21:37 <dmwit> foo f da = {- working on this part now -}
20:21:50 <cschneid> heh, problem with me is that I've been doing ruby and similar for so long my head is all polluted :)
20:22:04 <BMeph> scooty-puff: Yes. ;)
20:22:10 <dmwit> Here's our implementation plan: we're going to run down the list of "a" probabilities in da, and sample from the appropriate "b" distribution for each.
20:22:24 <dmwit> Sampling first from one, then the other, should multiply the probabilities.
20:22:35 <serialhex> ok
20:23:03 <dmwit> This will give us a list of densities, one for each possible a, a [Density b].
20:23:13 <serialhex> yeah, we'd have to mult the probs....
20:23:26 <dmwit> We're actually looking for a Density b, but we can get there by just calling concat.
20:23:37 <serialhex> http://en.wikipedia.org/wiki/Variance#Discrete_random_variable
20:23:48 <dmwit> (since [Density b] = [[(b, Probability)]])
20:24:01 <scooty-puff> BMeph: i'm leaning, as a writer of the function, of using Fix f, but as a user, f (Fix f), but for novery good reasons
20:24:12 <dmwit> So let's write the code for this English text...
20:24:29 <dmwit> foo f da = concat ({- run down the "a" probabilities and multiply -})
20:24:47 <cschneid> pooya72: feel free to follow along, or fork and play.  There's like 20 lines of code so far... :)  https://github.com/cschneid/RedHask
20:24:56 <dmwit> foo f da = concat (map {- sample, then multiply -} da)
20:25:02 <pooya72> cschneid: thanks!
20:26:34 <dmwit> foo f da = concat (map (\(a, pa) -> {- have to multiply each probability here -} (f a)) da)
20:26:55 <dmwit> foo f da = concat (map (\(a, pa) -> map (\(b, pb) -> (b, pa*pb)) (f a)) da)
20:27:15 * dmwit pauses to wait for complaints or agreement
20:27:25 <\rs> concatMap ?
20:27:31 <dmwit> \rs: yes
20:28:00 <dmwit> \rs: In fact, this is bind in the WriterT (Product Probability) [] monad. =)
20:28:05 <serialhex> i'm wondering where the a, pa b & pb come from... i'm assuming it's the density??
20:28:19 <dmwit> serialhex: Oh, you're familiar with map/concat but not lambdas?
20:28:37 <dmwit> "\x -> e" is like "let f x = e in f"
20:29:14 <BMeph> scoot: I'd use record-style for the declaration, and (ab)use the heck out of the converting functions, based on whichever form was easier to do what I wanted. :)
20:29:15 <dmwit> (Remember, the first argument to "map" is a function that takes one of the input list's elements and outputs one of the output list's elements.)
20:29:20 <serialhex> oh, ok, so \(a, pa)... takes a density and splits the a & Prob part...
20:29:25 <dmwit> Yes, exactly.
20:29:31 <serialhex> ok, now i see
20:30:09 <pooya72> cschneid: ohh.. so you're going to remake redis in haskell.
20:30:22 <cschneid> pooya72: right. Not a client - the server part is what I'm after
20:30:30 <cschneid> also look at the readme I put up. I'm the dog.
20:30:46 <pooya72> cschneid: for fun? man you must really like programming. I made a blog :)
20:30:51 <dmwit> serialhex: Okay, there's one other cute thing we will want to do with distributions occasionally, and that's to represent the deterministic distribution that, when sampled, *always* has a particular value.
20:30:58 <dmwit> deterministic :: a -> Density a
20:31:04 <dmwit> deterministic a = [(a, 1)]
20:31:08 * BMeph thinks redis looks much nicer, when written in the original Haskell. ;)
20:31:30 <cschneid> pooya72: I do ruby all day, and the project is at a size where I keep wishing for stricter typing.
20:31:38 <pooya72> cschneid: lol. Man if you're that dog, thn I don't now what I am.
20:31:39 <dmwit> And now it turns out that foo and deterministic are in fact (=<<) and return for a monad.
20:31:40 <cschneid> so now I'm going to learn haskell to learn the downsides of that thinking
20:31:47 <dmwit> You can try proving the monad laws yourself, if you're interested. =)
20:31:57 <cschneid> also since it's an awesome language :)
20:32:11 <serialhex> umm, yeah... lats not and say we did :P
20:32:35 <dmwit> Well, it's not hard.
20:32:52 <dmwit> But it does rely on a few facts about multiplication -- like 1 * x = x and (x * y) * z = x * (y * z).
20:32:54 <serialhex> i'm trying to understand haskell, then i can try to grok haskell - monads... and then grok monads
20:33:01 <pooya72> cschneid: yeah, I had a love hate relationship. really took a long time for things to kind of start clicking. Especially IO's and transferring between types. Not like everything clicks now..
20:33:19 <serialhex> ...though i have seen some spiffy tutorials on monads....
20:33:22 <cschneid> What's the standard naming scheme for hunit files? Add .test afterward?
20:33:25 <dmwit> The whole "monad" thing is just a side note, though.
20:33:30 <pooya72> cschneid: the first language I learned was ruby via sinatra. really liked it.
20:33:53 <cschneid> pooya72: I worked on sinatra a fair bit before the 1.0 release :) Got me my first ruby job.
20:34:00 <cschneid> anyway, enough ruby. How do I name hunit files
20:34:01 <dmwit> There's one more function we want to write, and then we'll be done re-implementing the bits of the probability package that you'll need to use.
20:34:08 <dmwit> And that's uniform :: [a] -> Density a
20:34:21 <serialhex> pooya72: i learned ruby first cause it's high-level and easy...  but nobody uses it for anything except the web (or so it seems)
20:34:25 <dmwit> But it's really easy: we'll just pair each value with 1/(length of the list).
20:34:31 <pooya72> cschneid: oh really? cool, it's an awesome framework.
20:34:47 <pooya72> serialhex: I wouldn't have a clue. I'm a philosophy major.
20:34:50 <dmwit> uniform as = map (\a -> (a, 1/n)) as where n = fromIntegral (length as)
20:35:39 <serialhex> dmwit: are you sure about that?? 1/(lenght of list)??  i dont think it collects all the values (or maybe ot does and i just dont see it)
20:36:08 <dmwit> serialhex: Well, what probability do you want to assign to choosing the first element of the list?
20:36:59 <serialhex> for instance:there is 1 way to roll a 2 on 2d6, and 2 ways to roll a 3 on 2d6... and so on...
20:37:07 <cschneid> question for understanding - parsec is a monadic library, so all my work happens in a monad. Can I call from pure code into this?  Is IO the only one that has to propagate from the top level?
20:37:12 <dmwit> serialhex: That's not a uniform distribution.
20:37:22 <serialhex> true
20:37:45 <startling> cschneid: yep
20:37:48 <dmwit> serialhex: So, here's your first challenge: can you implement a 2d6 die using only the pieces we've written so far?
20:38:01 <dmwit> (hint: yes ;-)
20:38:06 <startling> cschneid: a similar thing would be pattern-matching against Maybe
20:38:07 <serialhex> hmm, ok
20:38:24 <serialhex> (FSCK!  he's asking me to think!!!)
20:38:28 <cschneid> startling: sure, I keep forgetting that Maybe is just another monad, instead of something special :)
20:38:29 <cschneid> thanks
20:38:51 <dmwit> serialhex: Put all this code in a file and play with it in ghci. Let us know when you've had a good play. =)
20:39:30 <dmwit> For bonus points, see if you can reproduce it yourself without reading back.
20:39:45 <serialhex> dmwit: a gist of what i've got so far (did i miss anything?) https://gist.github.com/3008792
20:40:03 <dmwit> Oh, nice, you've been taking notes. =)
20:40:15 <serialhex> yes
20:40:41 <pooya72> so what's the difference between quickcheck and hunit?
20:40:49 <solrize> @where socket
20:40:49 <lambdabot> I know nothing about socket.
20:40:52 <startling> pooya72: lots
20:40:56 <solrize> @where recv
20:40:56 <lambdabot> I know nothing about recv.
20:41:11 <solrize> @where tcp
20:41:11 <lambdabot> I know nothing about tcp.
20:41:14 <startling> pooya72: quickcheck is for generating test cases
20:41:20 <solrize> any idea what module to import to talk to a socket?
20:41:26 <startling> pooya72: HUnit is if you want to hand-write test cases
20:41:41 <pooya72> startling: can you use them together?
20:42:03 <ion> sure
20:42:14 <startling> pooya72: dunno if you can use them *together*, but you can certainly use both HUnit and quickcheck to test a project
20:42:29 <siracusa> solrize: Have a look the network package
20:42:30 <cschneid> pooya72: hunit checks specific stuff against known input and output. Quickcheck lets you say "always this will be like xyz, try to prove me wrong"
20:42:43 <pooya72> startling: cool
20:42:57 <pooya72> cscnheid: thanks. I'll see how you use it :)
20:43:15 <ion> @quickcheck \xs ys -> reverse (xs ++ ys :: [Integer]) == reverse ys ++ reverse xs
20:43:15 <lambdabot> Unknown command, try @list
20:43:17 <solrize> siracusa, it's not in the ghc lib, hmm i will check hackage
20:43:20 <ion> @check \xs ys -> reverse (xs ++ ys :: [Integer]) == reverse ys ++ reverse xs
20:43:22 <lambdabot>   "OK, passed 500 tests."
20:43:44 <cschneid> pooya72: don't expect too fast of progress :)
20:44:01 <dmwit> serialhex: While playing, you might want to import Data.Ratio and use type Probability = Rational instead of Double; it's easier to read the output and more correct anyway.
20:44:09 <dmwit> (namely, there's no rounding)
20:44:14 <solrize> ah ok, i thought it was in the stdlib but that stuff is all in hackage
20:44:23 <serialhex> true :)
20:44:28 <pooya72> cschneid: haha, I was hoping you'd say that.
20:46:44 <parcs`> @check (<) <$> abs (sin^2 + cos^2 - 1) <*> 0.0000001
20:46:46 <lambdabot>   "OK, passed 500 tests."
20:47:55 <ion> @check \x -> (sin^2 + cos^2 - 1) x == (0 :: CReal)
20:47:56 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary Data.Number.CReal.CReal)
20:47:57 <lambdabot>    aris...
20:48:15 <ion> @check \x -> (sin^2 + cos^2 - 1) (fromRational x) == (0 :: CReal)
20:48:19 <lambdabot>   mueval-core: Time limit exceeded
20:49:05 <serialhex> dmwit: do i have all the code in that gist??
20:49:13 <dmwit> yup!
20:49:38 <dmwit> What have you tried?
20:49:56 <serialhex> d 6 gives me 1d6
20:50:07 <dmwit> Yep, that's a good start.
20:50:13 <serialhex> `foo 2 (d 6)` throws an error
20:50:25 <dmwit> For sure. What's the type of foo?
20:50:46 <serialhex> not (Num (t0 -> [(t10, t20)])) :P
20:51:33 <mm_freak> for testing complicated scenarios lazysmallcheck is an amazing library…  particularly when testing complicated data structures
20:51:43 <dmwit> serialhex: remember the motivation for foo
20:51:58 <solrize> hmm network.server seems kind of crufty, uses stuff from socket.internal
20:52:03 <dmwit> We have a distribution over "a"s and a way to form distributions over "b"s, if only we had an "a" lying around
20:52:19 <dmwit> so foo :: (a -> Density b) -> (Density a -> Density b)
20:53:03 <dmwit> and so far, foo is the *only* tool we have that lets us sample from more than one distribution, so we must have to use it here... the trick is figuring out how ;-)
20:54:58 <serialhex> dmwit: hmm... trying `foo d (d 6)` gives me an answer, but it dosn't look like the right answer....
20:55:32 <dmwit> Well, what does foo d (d 6) do?
20:55:33 <ion> lazysmallcheck, huh? I hadn’t noticed that one. Thanks.
20:55:36 <dmwit> (In English?)
20:56:00 <pooya72> member:cschneid: don't mean to bother, but is it just me or is "import Parser" necessary to be added to Executor.hs to get it to compile?
20:56:36 <cschneid> pooya72: probably, since that's where the data is defined. I'm reading about Parsec currently :)
20:56:40 <cschneid> haven't run it in a bit
20:56:57 <pooya72> cschneid: ok, just want to make sure I was completely off...
20:57:05 <pooya72> wasn't **
20:57:12 <serialhex> it gives me a list of densities (not really, cause it's not using the types... fixing) but they seem to be off...
20:57:26 <cschneid> I need to ask at some point what the best practice on data types is. Should they be pushed to top level? Put where they make sense? both depending on situation?
20:57:44 <dmwit> serialhex: No, no, don't tell me what ghci does. Any fool can type the program text in and see that.
20:57:52 <serialhex> the min i should get is [(2, *float*), ...]
20:58:02 <serialhex> ok
20:58:07 <dmwit> serialhex: I want the high-level description of what it means. What distribution is it describing?
20:58:44 <dmwit> serialhex: If necessary, re-read the high-level description of what foo does and plug in the meaning of the "d" function as necessary. =)
20:59:11 * serialhex goes and finds def of `foo`
21:06:02 <serialhex> dmwit: i'm still here... sorry it's taking me a bit
21:06:07 <dmwit> Take your time.
21:06:30 <dmwit> I may have set too hard a first exercise.
21:06:58 <dmwit> If you want, you could back off to an easier one: make a distribution that rolls a d6, then triples the number it sees.
21:07:21 <dmwit> (No fair just running a uniform distribution on pre-tripled numbers, either.)
21:08:22 <serialhex> updated gist: https://gist.github.com/3008792  thinking....
21:15:02 <dmwit> (In case you've seen the relationship between functors and monads before, I'm essentially asking you to implement fmap given (=<<) and return. If you haven't seen it before, well, don't worry -- pretty soon, you will have seen it. =)
21:15:33 * BMeph chants: SOON
21:15:51 <serialhex> ok, i know fmap is a special type of map, though i'm not sure what the difference is...
21:16:00 <startling> serialhex: nothing
21:16:04 <startling> serialhex: map is fmap for lists
21:16:05 <serialhex> -_-
21:16:13 <startling> serialhex: it's kind of silly, yeah
21:16:36 <serialhex> BMeph wants to brainwash me.... :P
21:16:44 <dmwit> Don't worry about the name. Just implement it first, and name it later. =)
21:17:07 <serialhex> so i've tried ` foo (\x -> deterministic x*3) (d 6)`
21:17:15 <dmwit> Nice!
21:17:23 <dmwit> That looks right; the only problem is parentheses.
21:17:28 <serialhex> and making a function `triple as = map (\a -> (a, 3/n)) as where  n = fromIntegral (length as)`
21:17:34 <dmwit> foo (\x -> deterministic (x*3)) (d 6)
21:17:35 <serialhex> (that last one blew up!)
21:17:46 <serialhex> srsly?
21:17:57 <dmwit> yup!
21:17:58 <serialhex> -_-
21:18:03 <serialhex> damn parens!
21:18:16 <serialhex> though the probs are all wrong....
21:18:18 <startling> $, even, if you haven't seen that before
21:18:28 <dmwit> The probabilities look okay to me.
21:18:32 <serialhex> but everything is all wrong really :P
21:18:39 <dmwit> huh?
21:18:52 <serialhex> `[(3,1 % 6),(6,1 % 6),(9,1 % 6),(12,1 % 6),(15,1 % 6),(18,1 % 6)]`
21:19:05 <serialhex> the P of rolling a 3 on 3d6 is 1/216
21:19:12 <dmwit> We're not rolling a 3d6.
21:19:17 <dmwit> We're rolling a 1d6 and tripling it.
21:19:21 <serialhex> true, 1d6 * 3
21:19:24 <serialhex> yeah
21:19:46 <serialhex> ok, back on trac
21:19:47 <startling> anyway, why isn't fmap just named "map"?
21:19:47 <serialhex> k
21:19:49 <dmwit> (By the way, congratulations: you now understand fmap.)
21:20:08 <serialhex> and it's named foo?  :P
21:20:17 <dmwit> no, foo is (=<<)
21:20:23 <dmwit> Oh, I guess we didn't actually write fmap.
21:20:30 <dmwit> Okay, that's your next assignment, then.
21:20:36 <dmwit> Abstract out the part that triples things: write
21:20:46 <dmwit> fmap' :: (a -> b) -> (Density a -> Density b)
21:21:02 <dmwit> (It should look very similar to the thing above... just replace the tripling part with the function you're handed!)
21:22:29 <serialhex> fmap' f = deterministic f
21:22:40 <blackdog> hey, dumb question: should i use mtl or transformers for a new project?
21:22:45 <serialhex> or: fmap' f n = deterministic (f n)
21:22:54 <dmwit> serialhex: Not quite, that one has type (a -> b) -> Density (a -> b)
21:22:55 <BMeph> blackdog: Yes.
21:23:01 <blackdog> BMeph: ... gah
21:23:14 <dmwit> serialhex: And the second one has type (a -> b) -> a -> Density b
21:23:15 <BMeph> :D
21:23:29 <dmwit> serialhex: Try writing the type in your file, and see if ghci accepts it. ;-)
21:23:40 <dmwit> s/it/your definition of fmap'/
21:24:00 <blackdog> BMeph: should i prefer mtl to transformers? :)
21:24:27 <BMeph> blackdog: Hmm, now, that's a different question entirely.
21:24:55 <dmwit> Eh, transformers is a dependency of mtl.
21:25:41 <blackdog> dmwit: really? Transformers is Haskell 98 and thus more portable, and doesn't tie you to functional dependencies. But because it lacks the monad classes, you'll have to lift operations to the composite monad yourself (examples).
21:25:50 <blackdog> (that should have been quoted, from the wiki)
21:26:04 <blackdog> oh, mtl depends on transformers. duh
21:26:24 <dmwit> "Dependenciesbase (<6), transformers (0.3.*)" -- from the Hackage page for mtl ;-)
21:28:06 <dmwit> I dunno. I mean, are you aiming for compatibility with something that isn't GHC for some reason?
21:35:17 <serialhex> OOHHHH!!!!!  GRR!!!!! `fmap' f n = f (deterministic n)`
21:35:34 <serialhex> nada  :(
21:38:13 <dmwit> serialhex: Start from your previous implementation!
21:38:16 <dmwit> foo (\x -> deterministic (x*3)) (d 6)
21:38:39 <dmwit> But cut out the (*3) and (d 6) parts and make them arguments to your function...
21:38:44 <serialhex> the whole thing?  cause i was starting at the lambda....
21:38:48 <dmwit> I don't think I can give more hints than that without giving away the answer.
21:38:53 <serialhex> ok
21:39:03 <mrlemao> is it possible to define a default method for a method defined in the super type class?
21:39:09 <dmwit> no
21:39:14 <dmwit> (sorry)
21:40:02 <mrlemao> e.g. class Feature a where name :: a -> String, class (Feature a) Installable a where a = "The provider can install"
21:41:06 <rwbarton> you seem to have left out several tokens from that last bit
21:42:30 <rwbarton> there's some recent extension relating to default methods, but i don't know quite what it does
21:43:25 <hpaste> mrlemao pasted “Default method in sub type classes” at http://hpaste.org/70563
21:44:14 <mrlemao> sorry, although following haskell for a while, now is the first time I am having my fingers dirty
21:44:47 <serialhex> dmwit: parse error: `fmap' f n = foo (\x deterministic (f x)) (d n)` am i on the right track?
21:45:04 <mrlemao> maybe there is a better way. I basically want to automatically print out a description for an instance that implements a Feature type class
21:45:34 <mrlemao> without having to replicate the implementation for each instance
21:45:56 <mrlemao> so each sub-type defines it's own method implementation
21:46:04 <rwbarton> maybe it's just a proposed extension
21:46:37 <mrlemao> I am not sure. thanks. it maybe just a crazy idea on my part
21:47:30 <rwbarton> I sort of get the feeling you shouldn't really be using type classes at all
21:52:22 <mrlemao> :-) Quite possible … I am trying to model what puppet does with ruby: i.e. you have a Resource (abstract entity that describes Properties, parameters and Features). You can then implement a Resource as a Provider. E.g. a Package resource has a feature installable and that basically means it has an install function. I then can implement an Apt provider that implements the install by interfacing with ubuntu apt.
21:52:59 <serialhex> wow i'm sloww.....  :(
21:56:59 <newsham> does anyone know if HaLVM can be run in a virtual machine (ie. for testing)?
21:57:00 <serialhex> dmwit: ok, the type of `foo (\x -> deterministic (x*3)) (d 6)` is `(Enum b, Num b) => Density b`
21:57:54 <serialhex> so i need to figure out how to make a function that goes from that to another DEnsity a
22:05:36 <dmwit> serialhex: Oh, sorry, I was reading about the TF2 update. ^_^
22:05:41 <dmwit> serialhex: Yes, you're very on the right track.
22:05:48 <dmwit> Probably your parse error is because you forgot a "->".
22:06:08 <dmwit> fmap' f n = foo (\x -> deterministic (f x)) (d n) -- isn't quite right, but is close
22:06:34 <dmwit> The only thing left is to finish abstracting away from which probability density you start from.
22:06:45 <dmwit> This one always starts from a "d n" density -- that is, always a uniform distribution.
22:07:25 <serialhex> hmm...
22:08:45 <serialhex> `fmap' fa fb = foo (\x -> deterministic (fa x)) fb`!!!!!!
22:08:52 <dmwit> YES!!
22:08:56 * dmwit high fives serialhex
22:09:10 <serialhex> sweet!!!  :D
22:09:19 <serialhex> ok, and i see why
22:09:58 <dmwit> Right, so this says sample from fb, then given that sample, sample from the deterministic distribution that is fa applied to the previous sample.
22:10:10 <dmwit> good stuff
22:10:21 <serialhex> the fb implicitly takes an arg all the way at the end, so fmap' funA funB 6... funB would have 6 as it's arg!!
22:10:36 <dmwit> Wait, what?
22:10:44 <serialhex> no no, i see
22:10:53 <serialhex> ok, yeah you're right
22:11:05 <serialhex> yes!
22:11:10 <dmwit> Nice!
22:11:22 <dmwit> Okay, now for the slightly harder problem. Time to write a 2d6. =)
22:11:44 <serialhex> sorry, this is all very heady, and sometimes kind of painful (but in a good way
22:11:45 <dmwit> Or, as an alternate slightly harder problem, try to explain what "foo d (d 6)" does. =)
22:11:47 <serialhex> !)
22:13:22 <serialhex> ok 2d6....
22:24:09 <mrky> why can't factorial function be declared as Integral -> Integral, instead of (Integral a) => a -> a  ?
22:24:31 <shachaf> Because Integral isn't a type.
22:24:57 <mrky> what is it?
22:25:26 <serialhex> ok, smaller #'s make life easier: `foo d (d 3)` first samples the d3, makes another die with the roll on the die (a d1) and multiplies it by that...  then it does the same with the next roll: a 2, and multiplies that out, giving (2,1 % 3) * [(1,1 % 2),(2,1 % 2)] = [(1,1 % 6),(2,1 % 6)]; and so on...
22:25:34 <serialhex> dmwit: ^^^
22:25:57 <kfish> mrky, it's a constraint on a type; the constraint that a must implement the typeclass (interface) Integral
22:26:38 <shachaf> mrky: Integer is a type.
22:26:41 <serialhex> that gives us a (kind of) exponential distribution...
22:27:07 <serialhex> at the limit it would anyway :D
22:30:03 <startling> mrky, Integral is a typeclass
22:30:26 <Axman6> :t 7
22:30:28 <lambdabot> forall t. (Num t) => t
22:30:38 <Axman6> @src Num
22:30:38 <lambdabot> class  (Eq a, Show a) => Num a  where
22:30:38 <lambdabot>     (+), (-), (*)           :: a -> a -> a
22:30:38 <lambdabot>     negate, abs, signum     :: a -> a
22:30:38 <lambdabot>     fromInteger             :: Integer -> a
22:31:00 <dmwit> serialhex: Hm, no multiplication of *values* is happening in foo d (d 3)...
22:31:05 <shachaf> If you want to learn about typeclasses Integral and Num are terrible examples.
22:31:16 <Axman6> yeah :\
22:31:20 <startling> oh, weeiiird
22:31:24 <dmwit> Or did I misunderstand your explanation?
22:31:24 <serialhex> of probabilites... sorry :)
22:31:26 <dmwit> maybe I did
22:31:27 <dmwit> okay, yeah
22:31:34 <Axman6> kfish: o/
22:31:41 <dmwit> Okay, yes, you got it. =)
22:31:48 <startling> never realized that numbers were polymorphic like that
22:31:50 <startling> that's really cool
22:32:05 <serialhex> i'm still puzzling over 2d6 :P
22:32:18 <dmwit> So foo d (d 6) rolls a d6, then uses the number n that comes up to roll a dn, and reports the answer from the second roll.
22:32:27 <kfish> hey Axman6
22:32:35 <Axman6> kfish: you gonna come along to AusHac next month? =)
22:32:41 <serialhex> yes
22:32:43 <augur_> sig_wall: are you dan piponi mayhaps
22:32:48 * gienah will be there :]
22:32:58 <Axman6> gienah: you win! :D
22:33:08 <dmwit> augur_: Dan Piponi goes by sigfpe in here, I think.
22:33:18 <Axman6> gienah: don't forget to tell anyone you know who liked haskell in Aus about it!
22:33:23 <augur_> sure, but people do mess with their names, dmwit!
22:33:31 * dmwit nods
22:33:31 <augur_> so i figured, it might be him, why not check
22:33:32 <gienah> Axman6: sure :-)
22:35:15 <Axman6> we've got like 14 people signed up right now
22:36:09 <Axman6> 15 actully
22:37:01 <Axman6> I've got no idea what I'm going to be working on. I might be working on the CPU design I've been thinking up recently though. not very haskell related, but I might be able to get some ideas from others
22:37:51 <zalzane> https://dl.dropbox.com/u/19138775/Images/Vidyadev/1259829153228.png
22:37:52 <gienah> Axman6: so will its machine code be system F :-)
22:38:20 <kfish> Axman6, i did consider nipping down for fp-syd/aushac next month ...
22:39:09 <otters> @quote >>=
22:39:10 <lambdabot> monochrom says: one ring to rule them all! and in your monad >>= them!
22:39:14 <otters> @quote >>=
22:39:14 <lambdabot> Badger says: one does not simply >>= into mordor
22:39:16 <otters> hm
22:39:21 <otters> two LOTR quotes in a row
22:39:55 <Axman6> no, nothing as exotic as that, it's a fairly similar architecture to ARM, but with 64 bit instructions, and some other exotic instructions like pop count, count leading zeros (which ARM has), bound to next power of two, and extract bit range, and the MOR and MXOR instructions from Knuth's MMIX CPU design
22:40:15 <gienah> Axman6: neat :-)
22:40:49 <Axman6> kfish: you totally should, it's a combo not to be repeated this year! plus it'd be great to catch up while drinking
22:40:53 <gienah> Axman6: you could prove its correctness in coq, isabelle or agda :-)
22:41:23 <Axman6> I'm sure there's better ways to prove hardware without them :P
22:41:53 <gienah> Axman6: intel used a proof assistant to fix the pentium divide bug
22:41:55 <srhb> Count leading zeroes? What on earth is that good for?
22:42:09 * srhb has a poor imagination when it comes to cpu design
22:42:26 <Axman6> srhb: I'm not sure either, but ARM has it, so I though, what the hell =)
22:42:31 <srhb> :P
22:42:53 <shachaf> Axman6: Those are nifty instructions, MOR and MXOR. Good thinking!
22:43:13 <Axman6> shachaf: yeah, I totally came up with it myself! =)
22:43:39 <shachaf> Are you sure they don't replace any of your other instructions?
22:44:04 <Axman6> thanks for the link, they seem like amazingly useful instructions that generalise a whole bunch of complex operations
22:45:15 <Axman6> I'm not yet no. I still need to fully understand how they work. need to grab a piece of paper and play with them
22:47:47 * hackagebot split-channel 0.1.0.0 - Control.Concurrent.Chan split into sending and receiving halves.  http://hackage.haskell.org/package/split-channel-0.1.0.0 (LeonSmith)
22:48:35 <serialhex> dmwit: am i able to make a 2d6 out of the functions i currently have? or do i need to make another one?
22:50:00 <serialhex> i'm guessing this isn't going to be a simple one-liner.... :-/
22:51:52 <srhb> serialhex: What do you have so far?
22:52:19 <serialhex> https://gist.github.com/3008792
22:52:51 <serialhex> and i'm trying to make a 2d6... or a 2d2 for starters
22:53:03 <dmwit> serialhex: It should be a (relatively) simple one-liner using the functions you have available.
22:53:10 <srhb> Ow, okay, and here I was thinking..
22:53:35 <srhb> > liftM2 (+) (randomRIO (1,6)) (randomRIO (1,6))
22:53:36 <lambdabot>   <IO Integer>
22:53:40 <srhb> Oh dear..
22:53:52 <dmwit> Yes, I'm asking him to implement liftM2 (+), but not for IO. =)
22:54:18 <srhb> No, indeed. :)
22:55:03 <blackdog> this interface is ... idiosyncratic
22:55:18 <dmwit> blackdog: It's not!
22:55:20 <dmwit> It's Monad!
22:55:20 <blackdog> having a play with the scribd robot fruit hunt challenge
22:55:30 <dmwit> Just with different names. =)
22:55:30 <serialhex> -_-  i dont even know what liftM2 (+) is....
22:55:41 <srhb> :t liftM2 (+)
22:55:42 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
22:55:50 <dmwit> serialhex: Don't worry about it.
22:55:51 <blackdog> there's a ruby script which uses sprintf to assemble a haskell file from pieces, which it then compiles
22:55:58 <dmwit> serialhex: Hack first, abstract second.
22:56:10 <serialhex> okay
22:56:18 <srhb> serialhex: dmwit gives good adfice, don't let me distract you :P
22:56:21 <blackdog> which means you can't even check your types, because the ADTs you operate on don't exist till runtime
22:56:22 <srhb> advice, too.
22:56:43 <srhb> blackdog: Eek?
22:57:09 <blackdog> srhb: https://github.com/egonSchiele/robot-fruit-hunt
22:57:26 <blackdog> it looks like a fun contest, but the API is Lovecraftian
22:57:56 <serialhex> srhb: thus far dmwit has been a good teacher; giving me enough to go on, and then slamming me with a problem and giving me space to figure it out (and time for him (?) to do whatever else)
22:58:20 <srhb> serialhex: :-) Perfect.
22:58:33 <srhb> blackdog: Yeah I just saw it on Reddit. Sounded great.
22:59:54 <dmwit> him =)
23:00:52 <serialhex> ok... it's usu safe to assume that on the intarwebz, but you have that one chick which you assume is a guy and gets all bent out of shape b/c of it (or just slightly insulted)
23:01:27 <serialhex> cause, you know, on the internet all the men are men, the women are also men, and the children are FBI agents...
23:03:20 <srhb> serialhex: Thanks ;)
23:03:29 <srhb> (And yes, it's friggin' annoying)
23:03:33 <serialhex> srhb: ???
23:03:56 <serialhex> ohh!  ok :D
23:03:57 <srhb> We are several female Haskellers in this channel, and we all seem to be 'he' :P
23:04:14 <shachaf> I don't mind if you refer to me as "he" or "she" or whatever other pronoun you like.
23:04:27 <startling> didn't we change linguistic gender to haskellers and non-haskellers?
23:04:32 <startling> maybe I'm misremembering
23:04:32 <c_wraith> shachaf: can I invent some new ones?
23:04:37 <srhb> That would be smart.
23:04:48 <shachaf> c_wraith: If you like.
23:04:59 <serialhex> startling: that would make more sense....  but it's more letters than him or her
23:05:26 <shachaf> c_wraith: Certai types of linguistic innovation are likely to invite my c_wrath, though.
23:05:27 <startling> right! so "he" is short for "haskeller". obv.
23:05:44 <srhb> startling: :P
23:05:45 <shachaf> @google person paper
23:05:47 <lambdabot> http://www.cs.virginia.edu/~evans/cs655/readings/purity.html
23:05:47 <lambdabot> Title: Douglas Hofstadter - Person Paper on Purity in Language
23:05:47 <serialhex> ok: HE == HaskEller
23:06:07 <nyingen> let's use the spivak pronouns
23:06:13 <dmwit> Let's not.
23:06:15 <nyingen> if nothing else, they're a fantastic trolling device
23:06:28 <startling> nyingen: i love the spivak pronouns. I get to pretend i'm talking with a cockney accent
23:06:36 <nyingen> I can envision the flame wars on -cafe even now
23:06:43 <shachaf> This isn't the channel for Internet gender discussions. Those usually turn out badly, and if they don't, they're still offtopic.
23:07:03 <serialhex> +1 ^
23:08:40 * dmwit suddenly hopes that srhb's last name has only one consonant
23:09:15 <adnam> is it possible to use Control.Monad.Error to create a stack trace, or can you only use it to receive the root cause of the error?
23:09:19 <srhb> dmwit: Er.. Why? :P
23:09:40 <dmwit> Because then I would feel like I had worked out exactly how you chose your nick. =P
23:09:51 <dmwit> ?hackage monadloc adnam
23:09:51 <lambdabot> http://hackage.haskell.org/package/monadloc adnam
23:09:56 <srhb> dmwit: Haha! I am sorry to disappoint.
23:09:58 <solrize> can someone look at http://hpaste.org/70506 and tell me why STArray2 is 2x slower than STArray ?
23:10:01 <shachaf> dmwit: Can you figure out how I chose my nick?
23:10:22 <adnam> dmwit: thanks!
23:10:27 <srhb> srhbrfldt is cool and all, but I thought being able to pronounce it "shrub" was cooler. :-)
23:10:45 <dmwit> shachaf: Is it one of your names?
23:11:01 <dmwit> srhb: hah
23:11:07 <srhb> I think it's some kind of weird dancing term.
23:11:36 <shachaf> srhb: I know a person whose nick is srh who used to be in here.
23:11:48 <shachaf> I tend to think of you as "srh B".
23:11:54 <srhb> oh lol
23:13:02 <startling> solrize, what do you think the 2 in STArray2 is for?
23:14:19 <solrize> just that it's the second of two implentations using starray
23:14:27 <solrize> oh :(
23:14:54 <startling> ;)
23:22:38 <serialhex> fsck.... it's taken me almost an hour to figure this out....  :(  i know what i *want* to do, but i'm not sure how to do it :(
23:23:33 <MostAwesomeDude> serialhex: Well, what *do* you want to do?
23:23:35 <startling> serialhex, what are you trying to do again?
23:24:28 <serialhex> small set: 2d2, i have a function that can make a dN, but i'm not sure how to make a XdN
23:24:31 <serialhex> https://gist.github.com/3008792
23:24:48 <serialhex> d2 is [(1,1 % 2),(2,1 % 2)]
23:25:36 <serialhex> 2d2 would be `d2 * d2`... with all the breaking out and whatnot that is needed
23:26:12 <serialhex> the fun algebra stuff we all learned in highschool (hopefully anyway, maybe some earlier, probably nobody in here later)
23:27:16 <serialhex> but it's more like (x1, y1)*(x2, y2) == (x1+x2, y1*y2)
23:27:41 <serialhex> for each item in the list
23:27:41 <MostAwesomeDude> Offhand, wouldn't this be roughly [ (a,
23:27:52 <MostAwesomeDude> Er, I should finish typing my thought before hitting Enter. :3
23:28:01 <serialhex> yeah, maybe :D
23:28:31 <dmwit> serialhex: Well, we definitely need to sample from two distributions, right?
23:28:36 <serialhex> yes
23:28:44 <dmwit> And "foo" is the only way we're allowed to sample from more than one distribution.
23:28:48 <dmwit> So we should start off with a "foo".
23:29:05 <serialhex> hmm... okay, i was starting from fmap'
23:29:26 <dmwit> Well, that's not a terrible thought.
23:29:40 <dmwit> Consider my advice to start off with "foo" a hint, then. =)
23:29:55 <serialhex> i had sitting in ghci: `fmap' (\x -> d ) (d 2)`
23:30:00 <serialhex> :P
23:30:04 <MostAwesomeDude> [ (x1 + x2, y1 *y2) | (x1, y1) <- l, (x2, y2) <- l ]
23:30:07 <dmwit> And I think I can safely give you a hint that one of the arguments to the top "foo" (there may be more by the time we're done) will be "d 2".
23:30:31 <dmwit> So for now we're at "foo {- the hard stuff goes here -} (d 2)".
23:30:40 <serialhex> yeah
23:30:55 <dmwit> MostAwesomeDude: Yes, but 1. he hasn't really grokked list comprehensions yet and 2. we're implementing a probability monad, so using the list monad underneath is cheating.
23:31:18 <MostAwesomeDude> dmwit: I posit that the list monad is too awesome to be considered cheating. :3
23:31:21 <serialhex> thanks :P
23:31:31 <dmwit> Unless you want to be the one to teach him monad transformers before he's learned about monads. =)
23:31:31 <MostAwesomeDude> But yes, I am taking a shortcut because I am still waking up.
23:31:44 <MostAwesomeDude> No, no, I'm good.
23:31:52 <serialhex> waking up??  it's 2:31 am here :P
23:32:02 <serialhex> ugh... i'm glad i have off today :D
23:33:29 <serialhex> btw, for anyone who dosnt know: xmonad rocks!
23:34:14 <startling> i remember when my xmonad configuration was completely copy-paste'd.
23:34:17 * startling sighs
23:34:33 <serialhex> startling: mine still is (mostly anyway)
23:34:55 <MostAwesomeDude> serialhex: I was napping.
23:34:55 <startling> serialhex: sure, but now it's more than a magic incantation that makes your window manager work!
23:35:41 <serialhex> yes, i can (mostly) understand what's happening, and make it do what i want it too!!!
23:36:05 <serialhex> (i sooo hate windows, and osx to a lesser extent /rant)
23:37:32 <srhb> Is this correct terminology: Maybe a is not a type, Maybe String is a type. Maybe a is an incomplete(?) type?
23:38:07 <Eduard_Munteanu> srhb: it is a type, except not a concrete one.
23:38:26 <srhb> I see.
23:38:34 <nexx> Maybe is a typeconstructor
23:39:16 <startling> nexx: and a type
23:39:35 <srhb> Maybe is not a type, is it
23:39:41 <srhb> Maybe a is (but not concrete)
23:39:48 <dmwit> depends who you ask
23:40:23 <Eduard_Munteanu> In the general sense it is a type. However some make a distinction between ordinary types (those in *) and type functions etc.
23:41:43 <dmwit> In general, I think it's polite to give a short sentence at the beginning of your writing to say what conventions you're going to use when talking about types, terms, etc.
23:42:07 <dmwit> (Because the conventions aren't strong enough across authors.)
23:42:43 <serialhex> okay, i've got this: `foo (\x -> fmap (\y -> y)  (d 2) ) (d 2)` it dosn't do *quite* what i want it to, and i'm not exatly sure what it does, but i think i'm getting somewhere
23:43:23 <dmwit> serialhex: You know the functor law?
23:43:25 <dmwit> laws?
23:43:34 <dmwit> One of them is "fmap id = id"
23:43:38 <Eduard_Munteanu> Or hierarchically/level-wise it is a type, I should say.
23:43:39 <serialhex> i have to abide by laws now???
23:43:56 <dmwit> serialhex: Well, you told me you wanted to skip proving that you happened to already abide by them...
23:44:02 <dmwit> serialhex: Anyway, that law means
23:44:13 <dmwit> fmap (\y -> y) (d 2) = fmap id (d 2) = id (d 2) = d 2
23:44:35 <dmwit> Which may help you think about what the code you wrote does (it is indeed quite close to what you want!).
23:45:00 <startling> serialhex: if only!
23:45:07 <startling> they're more suggestions than anything
23:45:42 <MostAwesomeDude> startling: Yeah, but if you write a Functor instance that doesn't obey them, nobody's gonna be happy with you.
23:47:16 * MostAwesomeDude wonders if GHC could automatically derive Functor here
23:48:23 <dmwit> definitely
23:48:39 <dmwit> um
23:48:41 <dmwit> maybe
23:48:41 <dmwit> =P
23:48:42 <MostAwesomeDude> I have a feeling it's not gonna behave the way serialhex wants it to behave though.
23:48:48 * MostAwesomeDude checks
23:49:19 <dmwit> For Functor, there's only one instance (if there's any).
23:49:30 <MostAwesomeDude> Right.
23:49:38 <shachaf> dmwit: Now you suddenly believe in parametricity?!
23:51:00 <dmwit> Um, if I didn't, I'd say functor instead of Functor??!!?!
23:51:10 * BMeph wonders: is parametricity what you use, until the regular metricity comes by?
23:52:17 <startling> BMeph, also known as U.S. Imperial
23:53:23 <serialhex> ahhh, but all of US love our wonky units!!!!   -_-
23:57:25 <ahkurtz> I wish someone would do a study about how much it costs the economies of the world every year to have non-decimal measurement systems
