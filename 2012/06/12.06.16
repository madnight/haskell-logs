00:20:16 <RosePerry> Could someone help me parse this type constructor?
00:20:18 <RosePerry> type State s = StateT s Identity
00:20:34 <nand`> Identity is the Identity monad, if that helps
00:20:42 <RosePerry> Yep, I get that
00:21:01 <nand`> so what exactly are you asking about?
00:21:02 <RosePerry> nand: what's its purpose?
00:21:07 <nand`> well, nothing
00:21:18 <nand`> it may help to look at the definition of StateT
00:21:30 <nand`> @unmtl StateT s Identity
00:21:30 <lambdabot> Plugin `unmtl' failed with: `StateT s Identity' is not applied to enough arguments, giving `/\A. s -> (A, s)'
00:21:35 <nand`> @unmtl StateT s Identity a
00:21:35 <lambdabot> s -> (a, s)
00:21:45 <nand`> @unmtl StateT s m a
00:21:45 <lambdabot> s -> m (a, s)
00:21:48 <RosePerry> ah, what's a state transformer monad?
00:21:59 <nand`> it's like a normal state monad but there's an extra ‘m’ as seen above
00:22:04 <shachaf> State monad transformer.
00:22:15 <nand`> meaning you can “chain” monads
00:22:21 <shachaf> The idea of monad transformers is that they can turn one monad into a more complicated monad by adding things.
00:22:33 <shachaf> Identity is the monad that "does nothing".
00:22:57 <shachaf> If you just want to figure State and/or Monad out, you shouldn't worry about monad transformers.
00:22:59 <RosePerry> whoa, can you point me to some documentation on chaining monads?
00:22:59 <nand`> so if you put “Identity” in the place of that ‘m’, it dissipats into s -> (a, s) -- the normal state monad
00:23:21 <RosePerry> alright, thanks
00:23:25 <nand`> http://book.realworldhaskell.org/read/monad-transformers.html <- RosePerry
00:23:35 <shachaf> RosePerry: I suspect based on this and other questions you asked before that you shouldn't look into this yet. :-)
00:24:06 <RosePerry> good to know. thanks (:
00:24:11 <shachaf> RosePerry: Here's the normal definition of State:
00:24:16 <nand`> oh yeah, that definition is awfully out of place if you're learning about monads :)O
00:24:19 <nand`> -O
00:24:21 <shachaf> newtype State s a = State { runState :: s -> (a,s) }
00:24:55 <shachaf> RosePerry: The idea is that a monad transformer has "more information" than a monad, so you can always derive a monad out of the transformer, but not vice versa. So the library definitions use transformers.
00:25:06 <shachaf> But when you're learning it just makes things needlessly complicated. :-)
00:25:38 <shachaf> My favorite way of figuring out how State works is figuring out what "state" even means, and then implementing State yourself.
00:29:46 <edwardk> shachaf: added a pretty printer, but not masochistic enough to write a parser ;)
00:30:10 <shachaf> edwardk: Pfooey. You could probably write a really hacky one in a few lines.
00:30:36 <edwardk> i can, but for some reason my right elbow is killing me right now, so the prospect of writing it is exhuasting
00:30:59 <edwardk> i'm going to go take some ibuprofen or something and sleep
00:31:29 <Eduard_Munteanu> Hm, so you do that sometimes :P
00:31:35 <Eduard_Munteanu> Sleep, that is.
00:31:53 <edwardk> another observation, that code runs about twice as fast when i use the builtin fix from let rather than the manually constructed 'fix'
00:31:58 <edwardk> so that was kind of nice
00:32:06 <nand`> write a pretty printer/parser for (Enum a, Bounded a, Show a, Show b) => a -> b
00:32:18 * nand` hides
00:32:21 <edwardk> didn't copumpkin already do that?
00:32:39 <nand`> no idea
00:35:48 <edwardk> i wonder if some of those old neil ghani / patricia johann papers that complained about not being able to write code polymorphic in certain kinds work better with the new polymorphic kind syntax
00:36:51 <gienah> edwardk: not sure but if you wanted to try it I have heard its necessary to use ghc head :]
00:37:09 <edwardk> i've been abusing it for a while now
00:37:32 <gienah> edwardk: yah! I've added it to the gentoo-haskell overlay :-)
00:37:35 <edwardk> with 7.4.1 it was brittle, 7.4.2 it was better, head is definitely needed though
00:37:54 <gienah> yeah head is really neat for the polykinds stuff :-)
00:38:14 <edwardk> for a while our language at work had better polykind support than ghc ;)
00:38:19 <shachaf> edwardk: s/cooked = fromJust/Just cooked =/ :-(
00:38:21 <edwardk> we still do better at printing them out, etc. ;)
00:38:28 <Eduard_Munteanu> gienah++
00:38:33 <Eduard_Munteanu> Keep those coming :)
00:39:02 <gienah> Eduard_Munteanu: there's also a live ebuild of ghc head from git :]
00:39:32 <edwardk> given that we wrote it primarily because we couldn't be bothered to figure out when to shoe-horn in the monomorphization pass for data types, i was very pleased ;)
00:39:54 <edwardk> (kind monomorphization that is)
00:40:41 <gienah> edwardk: that
00:41:18 <gienah> oops that's really neat. Sometime I will try to figure out how to use your recursion schemes stuff.
00:41:40 <edwardk> for that matter, we have constraint kinds working here as well, because it was a lot easier than dealing with a separate adt, etc.
00:42:08 <edwardk> don't bother, recursion schemes are mostly useless =P
00:42:27 <gienah> edwardk: ok, that will save hurting my head trying to figure them out :-)
00:42:39 <edwardk> learn the key ones that matter, cata, ana, hylo, and learn that you can use a distributive law to push a monad or comonad over parts of them
00:42:49 <edwardk> then the rest are just different choices of monad/comonad
00:43:17 <gienah> ok, thanks (guess my head is still going to hurt figuring this out)
00:43:25 <edwardk> in the end i don't think they provide useful intuition, they have godawful names, and everyone who ever cared about them in earnest has moved on
00:44:02 <edwardk> and when i last talked to tarmo uustalu about them, he seemed downright depressed that he'd spent so much time defining them ;)
00:44:37 <gienah> edwardk: neat, thanks for the insights
00:50:42 <Eduard_Munteanu> edwardk: hm, I somehow thought one thing was reasoning about fusion in a more sensible manner
00:50:53 <Eduard_Munteanu> I mean, the thing about recursion schemes.
00:52:16 <edwardk> Eduard_Munteanu: yep. its nice for the few fusion cases it covers, but hylo fusion isn't all that great, and foldr/build unfoldr/destroy fusion are pretty obvious, and only use the first couple of constructions
00:54:08 * Eduard_Munteanu kinda wonders if Uustalu & Vene hang in here
00:54:57 <Eduard_Munteanu> There are quite a few articles by them I should (re)read sometime.
00:57:21 <edwardk> they don't
01:00:38 <Eduard_Munteanu> :(
01:00:41 * Eduard_Munteanu should go too :D
01:18:16 <RosePerry> Does "b" represent a monad? What documentation should I look at to find out? Here's the code:  "type BFSState a b = State (Queue [a], Set.Set a) b"
01:18:59 <unnali> RosePerry: b represents whatever the return value of the action is! Finding relevant doc.
01:20:55 <unnali> difficult to find a particular doc for it; it's a property of monads in general. The Monad typeclass is defined as 'class Monad m where …', which means you get values of type `m a' for some Monad m.
01:22:01 * hackagebot bound 0.1.3 - Combinators for manipulating locally-nameless generalized de Bruijn terms  http://hackage.haskell.org/package/bound-0.1.3 (EdwardKmett)
01:22:04 * hackagebot blaze-from-html 0.3.2.1 - Tool to convert HTML to BlazeHtml code.  http://hackage.haskell.org/package/blaze-from-html-0.3.2.1 (JasperVanDerJeugt)
01:22:05 <unnali> the State monad is `State s a', so the actual State-controlled part is `State s' (where `s' is the type of the state carried around), and `a' is whatever action is relevant.
01:22:47 <unnali> i.e. `doThing :: State Int ()` is an action which operates with state of type Int, and returns unit.
01:23:33 <unnali> so BFSState is just a type synonym where the first type parameter `a' is used as the basis for the Queue and Set, and `b' is passed through as the return type of any given action.
01:24:07 <RosePerry> unnali: Thanks for all your answers!
01:24:17 <edwardk> also note that type BFSState a b = State (Queue [a], Set.Set a) b is unnecessarily inconvenient you can reduce it to type BFSState a = State (Queue [a], Set.Set a)
01:24:27 <unnali> RosePerry: I hope I helped more than hindered :\
01:24:49 <RosePerry> ha, it did help. Thank you!
01:40:40 <RosePerry> If the return type of my dequeue function is Maybe (a, Queue a), would this match? "let (res,q') = dequeue q"
01:41:02 <unnali> no; you'd need use `case' (what if it returned `Nothing'?)
01:41:32 <RosePerry> thanks! so then I should say let d = dequeue q in case d of … ?
01:41:41 <unnali> sure, or drop the let:
01:41:44 <unnali> e.g. case dequeue q of Just (res,q') -> …
01:41:56 <unnali> (and also handle Nothing :))
01:42:25 <RosePerry> unnali: Thanks!
01:42:46 <unnali> np! :)
01:45:33 * mekeor now knows what a semigroup, a group and a monoid is =)
01:45:34 <lambdabot> mekeor: You have 1 new message. '/msg lambdabot @messages' to read it.
01:50:08 <mekeor> lists, trees etc. are all algebraic structures, right? so, how do i write "data List a = Empty | Full a (List a)" mathematically, iykwim?
01:50:38 <mauke> what do you mean by "mathematically"?
01:51:08 <mekeor> with a mathematical notation, i don't know. like a mathematician, i mean.
01:51:14 <mekeor> as an algebraic structure.
01:51:43 <mekeor> i'm quite sure mathematicians don't write that haskell code to define a list =)
01:52:01 <flixil> Why would a mathematician want a list?
01:52:13 <flixil> Hello
01:52:14 <companion_cube> why not?
01:52:40 <mekeor> flixil: okay, then let's consider "data Tree a = Empty | Full a [Tree a]", okay?
01:53:34 <mekeor> flixil: btw, mathematicians are using lists all the time… anyway.
01:53:46 <mekeor> how do i write that definition of a data-type in haskell mathematically?
01:54:18 <mekeor> is there a common notation or so? idk, say something. – aren't there any algebraist here?
01:54:53 <companion_cube> it's an inductive definition, like "\epsilon is a list, and if a \in A and l is a list, then (a:l) is a list"
01:55:05 <roconnor> T a = 1 + a / (1 - T a)
01:55:07 <roconnor> :P
01:55:57 <mekeor> companion_cube: aah, cool. great.
01:56:36 <roconnor> 2 * T a - (T a)^2 = 1 + a
01:57:22 <flixil> Btw talking about lists.... I if do a traverse function to a list (catamorphism for instance, sum, product...) and then i compute the length ot the list i have to traverse it twice. Can conceptually the compiler traverse it once without writting a function that does both things at the same time?
01:57:26 <RosePerry> Where can I find documentation on what -> means in different contexts?
01:57:42 <mekeor> companion_cube: Definition of Trees: (1) ε is a tree. (2) if a∈A, and l is a list of trees, then (a # l) is a tree.
01:57:45 <mekeor> right?
01:58:11 <companion_cube> mekeor: something like this, yeah
01:58:39 <companion_cube> and you can reason by induction on such inductive objects, which basically amounts to write recursive functions in haskell ;)
01:59:25 <mekeor> companion_cube: heh :)
01:59:30 <mekeor> companion_cube: thank you!
01:59:51 <mekeor> roconnor: huh? i don't understand anything of what you are saying. explain!
02:01:33 <flixil> So to speak   sum list   and length list   both need to traverse the list, is the compiler smart enough to do it once?
02:02:10 <shachaf> flixil: Probably not.
02:02:32 <ion> > foldMap (Sum &&& Sum . const 1) [5..10]
02:02:33 <lambdabot>   Not in scope: `foldMap'
02:02:37 <ion> > Data.Foldable.foldMap (Sum &&& Sum . const 1) [5..10]
02:02:39 <lambdabot>   (Sum {getSum = 45},Sum {getSum = 6})
02:03:08 <ion> I wonder if there are some strictness issues with that?
02:03:39 <roconnor> mekeor: well the data type says that T a = 1 + a * (T a)^* where X^* = 1 + X*(X^*)
02:03:47 <flixil> mmm... what´s the meaning of &&&?
02:04:01 <ion> > (getSum *** getSum) . Data.Foldable.foldMap (Sum &&& Sum . const 1) $ [5..10]
02:04:03 <lambdabot>   (45,6)
02:04:17 <ion> @type (&&&) `asAppliedTo` (undefined :: a -> b)
02:04:18 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
02:04:26 <ion> @@ @djinn @type (&&&) `asAppliedTo` (undefined :: a -> b)
02:04:27 <flixil> well, i said sum and length but would be sum' and length' where sum returns also w and length takes w as an argument
02:04:28 <lambdabot>  -- f cannot be realized.
02:05:36 <roconnor> mekeor: if I were an algebrist, I look at X^* = 1  + X * (X^*) and I solve for X^*  yeilding X^* = 1 / (1 - X)
02:05:54 <roconnor> mekeor: so T a = 1 + a / (1 - T a)
02:06:15 <mekeor> roconnor: ah, i see.
02:06:17 <roconnor> mekeor: Now we solve for T a, but we get the quadratic equation 2 * T a - (T a)^2 = 1 + a
02:07:38 <mekeor> roconnor: "data Foo = Bar Bool | Baz Integer" == Bool + Integer; "data Foo a = Bar a" == 1; "data Foo" == 0; "data Foo = Bar Bool Integer" == Bool × Integer; "data Foo = Bar (Bool -> Integer)" == Bool ^ Integer.
02:07:48 <flixil> ion i don´t quite understand foldMap (Sum &&& Sum . const 1) [5..10]  and what you where trying to show me
02:08:04 <roconnor> mekeor: naturally
02:08:09 <mekeor> roconnor: … or Integer ^ Bool? oO
02:08:19 <roconnor> mekeor: yes Integer ^ bool
02:08:31 <ion> > map (id &&& id . const 1) [5..10]
02:08:33 <lambdabot>   [(5,1),(6,1),(7,1),(8,1),(9,1),(10,1)]
02:08:39 <ion> First of all, that creates a list of tuples like that.
02:08:46 <ion> > map (Sum &&& Sum . const 1) [5..10]
02:08:48 <lambdabot>   [(Sum {getSum = 5},Sum {getSum = 1}),(Sum {getSum = 6},Sum {getSum = 1}),(S...
02:09:10 <ion> That wraps them in the Sum type. http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html#v:Sum
02:09:13 <mekeor> roconnor: great! thank you!
02:09:52 <flixil> that looks like a nice way not to have to rewrite a new function to combine two functions no?
02:09:56 <ion> > foldl' mappend . map (Sum &&& Sum . const 1) $ [5..10]
02:09:57 <lambdabot>   Overlapping instances for GHC.Show.Show
02:09:57 <lambdabot>                              ([[(Da...
02:10:15 <ion> > foldl' mappend mempty . map (Sum &&& Sum . const 1) $ [5..10]
02:10:17 <lambdabot>   (Sum {getSum = 45},Sum {getSum = 6})
02:10:53 <ion> That folds the list using mappend (the strict foldl' might be better than using foldMap here).
02:11:05 <ion> > (getSum *** getSum) . foldl' mappend mempty . map (Sum &&& Sum . const 1) $ [5..10]
02:11:07 <lambdabot>   (45,6)
02:11:22 <ion> That just applies getSum to both items in the tuple, unwrapping them from the Sum wrapper.
02:11:47 <ion> > Sum 4 `mappend` Sum 5
02:11:48 <lambdabot>   Sum {getSum = 9}
02:12:17 <ion> mappend for Sum is just (+) for the inner values.
02:12:45 <ion> > (Sum 4, Sum 5) `mappend` (Sum 5, Sum 6)
02:12:46 <lambdabot>   (Sum {getSum = 9},Sum {getSum = 11})
02:12:54 <ion> And since tuples are monoids as well, that works.
02:13:18 <roconnor> mekeor: if you like this you might also like http://www.sciencedirect.com/science/article/pii/002240499500098H
02:13:32 <flixil> I think the problem is that i almost but not quite entirely missunderstand monads, and arrows are more fuky :)
02:13:54 <ion> No monads are used here, and ignore arrows completely.
02:14:06 <roconnor> mekeor: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.8517
02:14:07 <ion> (f &&& g) a = (f a, g a)
02:14:13 <ion> (f *** g) (a, b) = (f a, g b)
02:14:16 <flixil> oh, this looks easy
02:14:23 <xraycat> mekeor: we did something like that with algebraic structures: http://bit.ly/MwZJ0N
02:14:49 <flixil> who got more preference, &&& or the dot?
02:14:59 <ion> The dot binds tighter.
02:15:14 <mekeor> great, roconnor! thank you, xraycat.
02:15:15 <ion> infixr 9 .; infixr3 &&&
02:15:29 <flixil> I understand your example now, now i only need to get the point made by you
02:15:29 <unnali> RosePerry: did your question go unanswered? What sort of different contexts were you thinking of?
02:15:47 <RosePerry> control flow vs. binding
02:15:51 <RosePerry> as in
02:16:01 <RosePerry> getLine >> \a -> putStrLn...
02:16:06 <RosePerry> The arrow seems to act like >>
02:16:10 <ion> flixil: Well, that traverses the list only once. And monoids are awesome. :-P
02:16:17 <RosePerry> sorry, the get line has >>=
02:16:34 <unnali> RosePerry: ah; in this case it's just a part of the syntax of lambdas (anonymous functions).
02:16:46 <unnali> that syntax being `\arg1 arg2 ... argn -> expr'
02:16:54 <RosePerry> unnali: oh! thanks (:
02:18:35 <ion> > foldl' (\(s, c) a -> (s+a, c+1)) (0, 0) . map (\n -> (n, 1)) $ [5..10]
02:18:35 <flixil> ion that really only traverses the list once?
02:18:37 <lambdabot>   ((45,6),6)
02:18:37 <unnali> RosePerry: in a more complete sense, `getLine >>= \a -> putStrLn ("hello " ++ a)' is the same as saying `getLine >>= sayHi' and `sayHi = \a -> putStrLn ("hello " ++ a)' -- and the last one there is identical to `sayHi a = putStrLn ("hello " ++ a)'
02:19:19 <flixil> ion yes, this is more readable :) this is what i was saying by compining the two functions and interleaving them
02:19:23 <RosePerry> if I have a function on the LHS that returns something, and it's followed by "=> variable where…" does the return value get bound to the variable?
02:19:31 <flixil> or for instance sum and ++ for lists or similar
02:19:48 <ion> > foldl' (\(s, c) a -> (s+a, c+1)) (0, 0) $ [5..10]
02:19:49 <lambdabot>   (45,6)
02:20:36 <ion> > foldl' (+) 0 . map (\n -> (n, 1)) $ [5..10]  -- In fact, this works with the NumInstances tuple instance.
02:20:39 <lambdabot>   (45,6)
02:21:05 <unnali> RosePerry: I'm trying to think about where that might occur. could you give an example?
02:22:08 <mauke> > x => x
02:22:09 <lambdabot>   <no location info>: parse error on input `=>'
02:22:29 <mauke> > (=>)
02:22:30 <flixil> ion: thanks. So you are saying that most of the time you have to interleave the two functions together and a nice readable way to do it is via arrows, yes?
02:22:30 <lambdabot>   <no location info>: parse error on input `=>'
02:22:38 <RosePerry> unnali: let's say myInt() returns an Int, and I have  myfunc = myInt >>= myvar where myvar = ...
02:22:51 <RosePerry> sorry, myInt :: Int
02:23:21 <ion> flixil: Ignore arrows completely. Imagine that (f &&& g) a = (f a, g a); (f *** g) (a, b) = (f a, g b)
02:23:47 <unnali> RosePerry: hmm. That couldn't be the case, if only because (>>=)'s type is (>>=) :: Monad m => m a -> (a -> m b) -> m b; i.e. the first argument (in this case it's `myInt') should be of type `m a' for some monad `m'.
02:23:49 <mauke> RosePerry: then you'll get a type error because >>= can't be called on Ints
02:24:01 <ion> flixil: I might as well have used (\a -> (Sum a, 1)) and (\(a,b) -> (getSum a, getSum b)) instead of using (&&&) and (***).
02:24:05 <unnali> RosePerry: if we use getLine and putStrLn as examples again;
02:24:09 <ion> (\a -> (Sum a, Sum 1))
02:24:29 <unnali> RosePerry: myFunc = getLine >>= myResultAction where myResultAction name = putStrLn ("Your name is: " ++ name)
02:24:45 <ion> flixil: In my latter example, i used no monoids and no (&&&) or (***), just foldl'.
02:24:55 <unnali> RosePerry: getLine :: IO String; putStrLn :: String -> IO ()
02:25:10 <ion> flixil: I’m not sure whether i’d use monoids or a lower-level foldl' in that case.
02:25:14 <RosePerry> ah, then what is bound to "name" is the result of "getLine"?
02:25:24 <unnali> RosePerry: right! That's what (>>=) is doing.
02:25:34 <RosePerry> unnali: Thanks!
02:25:50 <unnali> RosePerry: treat `where' just like it's introducing a top-level declaration, except .. not at the top-level, but only available inside `myFunc'.
02:25:56 <unnali> and no probs. :)
02:26:11 <unnali> (and because it's available inside `myFunc', it also would have access to other names bound there.)
02:28:58 <hpaste_> RosePerry pasted “word ladder loop” at http://hpaste.org/70026
02:29:41 <RosePerry> Thanks, unnali! I have another question: where does the value of "wll" get bound in the paste above?
02:29:56 <mauke> in line 3
02:30:02 <mauke> wll wrdst = ...
02:30:06 <mauke> that's the definition of 'wll'
02:30:08 <RosePerry> sorry, I meant wrdst
02:30:20 <mauke> wrdst is the parameter of wll
02:30:28 <mauke> it is bound when wll is called
02:30:51 <unnali> RosePerry: wordsSetIO >>= wll
02:30:52 <RosePerry> I thought the type of all was Set.Set String
02:30:56 <mauke> (and when that happens, it will be the result of wordsSetIO)
02:31:04 <unnali> wordsSetIO :: IO (Set.Set String)
02:31:06 <RosePerry> by *all I mean wll
02:31:09 <unnali> :t (>>=)
02:31:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:31:20 <unnali> so we have m = IO, a = Set.Set String
02:31:32 <mauke> RosePerry: impossible
02:31:33 <unnali> b = ()
02:32:03 <unnali> ... which means `wll' must be of type `Set.Set String -> IO ()'
02:32:17 <mauke> RosePerry: the last thing in wll is a call to (>>)
02:32:35 <mauke> unnali: I don't see where you get () from
02:33:49 <RosePerry> the last part of the :t (>>=) where we chain m a to m b. We provide no parameter to the monad, so I think it's ()
02:34:37 <mauke> huh?
02:34:38 <unnali> mauke: line 1: `wordLadderIOLoop :: IO ()
02:34:39 <unnali> '
02:34:59 <mauke> I don't think that affects wll
02:35:26 <mauke> that is, I think wll :: Set String -> IO a
02:35:28 <unnali> well, wll should be Set.Set String -> IO a
02:35:48 <unnali> yeah, sorry, I over-thought that one
02:36:12 <RosePerry> What's the b in :t (>>=) ?
02:36:29 <RosePerry> in the context of wordSetIO >>= wll
02:36:33 <unnali> well, it's whatever the second argument `(a -> m b)' returns in `m', only in this case it turns out it's unbound.
02:36:49 <unnali> since `wll' always ends up calling itself; technically it never returns anything
02:37:13 <RosePerry> what do you mean it calls itself?
02:39:29 <mauke> RosePerry: lines 8, 9
02:39:51 <unnali> RosePerry: note that at the end of `wll' in the `case', in both cases it ends up finishing up with `wll wrdst'
02:40:52 <RosePerry> How does the value of wrdst get bound?
02:41:37 <RosePerry> its type is Set.Set String
02:42:12 <mauke> <mauke> it is bound when wll is called
02:42:38 <unnali> well, that comes from (>>=) executing wordsSetIO (of type `IO (Set.Set String)') and passing the pure `Set.Set String' as the first arg to `wll'
02:42:42 <unnali> okay, little one calling. back later!
02:43:12 <mauke> (except >>= doesn't actually execute anything, it just arranges things to be executed later)
02:43:24 <RosePerry> aw, cute (: Thank you so much unnali!
02:46:51 <RosePerry> mauke: Why does Set.Set String get passed as the first arg to 'all'?
02:46:55 <RosePerry> 'wll'?
02:47:19 <mauke> because that's the type of the result of wordsSetIO
02:49:28 <RosePerry> ah, of course. Thanks, mauke!
02:52:07 * hackagebot iso3166-country-codes 0.20111111.4 - A datatype for ISO 3166 country codes  http://hackage.haskell.org/package/iso3166-country-codes-0.20111111.4 (JonFairbairn)
03:00:02 <hpaste_> RosePerry pasted “breadth first search” at http://hpaste.org/70028
03:00:43 <RosePerry> What does the end of the last line >> bfs do, and how does this function call itself?
03:01:25 <mauke> bfs isn't a function
03:02:07 <RosePerry> right
03:02:18 <mauke> but your questions sort of answer each other
03:02:21 <RosePerry> It's a [String]
03:02:27 <mauke> no
03:02:37 <mauke> :t evalState
03:02:38 <lambdabot> forall s a. State s a -> s -> a
03:02:48 <mauke> it's a 'State s a' for some types s, a
03:03:38 <RosePerry> Is a the return value?
03:04:08 <mauke> return value of what? and what do you mean by "return value"?
03:04:18 <mauke> (I suspect the answer is "yes", but ...)
03:04:32 <RosePerry> I think I'm getting monads and state confused
03:06:20 <RosePerry> It looks like bfs is a monad
03:06:25 <RosePerry> How does it get called?
03:06:40 <mauke> bfs can't be a monad, it's not a type
03:06:44 <mauke> it's a value
03:06:50 <mauke> what do you mean by "called"?
03:07:05 <RosePerry> evalState m s = fst (runState m s)
03:07:11 <RosePerry> is bfs the "m"?
03:07:26 <mauke> yes
03:09:31 <Lemon> @hoogle (a -> b -> f c) -> f a -> f b -> f c
03:09:32 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
03:09:32 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
03:09:32 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
03:10:22 <Lemon> :t (,) <$> return 1 <*> return 2
03:10:24 <lambdabot> forall a a1 (f :: * -> *). (Num a, Monad f, Applicative f, Num a1) => f (a, a1)
03:10:41 <Lemon> :t (return .) . (,) <$> return 1 <*> return 2
03:10:43 <lambdabot> forall (m :: * -> *) a a1 (f :: * -> *). (Monad m, Num a1, Monad f, Applicative f, Num a) => f (m (a1, a))
03:10:54 <Lemon> :t join . (return .) . (,) <$> return 1 <*> return 2
03:10:56 <lambdabot> forall a a1 (f :: * -> *). (Num a1, Monad f, Applicative f, Num a) => f (a1, a)
03:11:25 <RosePerry> mauke: Is "bfs" the initial state, and then it gets updated in the where clause?
03:11:32 <mauke> RosePerry: no
03:11:34 <Lemon> :t join . (pure .) . (,) <$> pure 1 <*> pure 2
03:11:35 <lambdabot> forall a a1 (f :: * -> *). (Num a1, Applicative f, Num a) => f (a1, a)
03:11:45 <Lemon> yeah okay
03:11:48 <mauke> RosePerry: do you know what 'where' does?
03:12:16 <RosePerry> It binds a value in local scope, right?
03:12:26 <mauke> yeah
03:12:39 <mauke> do you know what that means? :-)
03:13:30 <RosePerry> I think it means that the bfs won't be visible outside breadthFirstSearch, but the RHS of bfs has all of breadthFirstSearch's parameters visible to it
03:13:53 <mauke> good enough
03:15:10 <RosePerry> When bfs is on the RHS of the bfs = … what is the value of the RHS bfs?
03:15:31 <mauke> there is only one bfs
03:15:56 <RosePerry> How can the bfs get set to itself?
03:16:00 <mauke> easily
03:16:06 <mauke> > let foo = foo in "hello"
03:16:07 <lambdabot>   "hello"
03:16:11 <mauke> > let foo = foo in foo
03:16:15 <lambdabot>   mueval-core: Time limit exceeded
03:16:16 <mauke> ^ infinite loop
03:16:27 <mauke> > let foo = [length foo] in foo
03:16:28 <lambdabot>   [1]
03:16:51 <RosePerry> What if there is no "in" clause?
03:17:02 <reinoud> Ni!!
03:17:06 <Lemon> :t join . (return .) . (,) =<< return 1
03:17:08 <lambdabot> forall a b. (Num a) => b -> (a, b)
03:17:12 <mauke> RosePerry: then it's a syntax error, unless you're in a 'do' block
03:17:18 <Lemon> :t return . (,) =<< return 1
03:17:19 <lambdabot> forall (m :: * -> *) a b. (Monad m, Num a) => m (b -> (a, b))
03:17:21 <RosePerry> I'm in a "where"
03:17:28 <RosePerry> ah, which contains a do
03:17:37 <mauke> RosePerry: ?
03:17:37 <Lemon> :t (return . (,) =<< return "") <*> return ""
03:17:39 <lambdabot> forall (f :: * -> *). (Monad f, Applicative f) => f ([Char], [Char])
03:17:43 <reinoud> Hi :)
03:17:52 <mauke> RosePerry: 'in' is part of the syntax of 'let'
03:18:05 <mauke> let DEFINITIONS in EXPR
03:18:07 <RosePerry> I posted the code on hpaste, if it would help you to see it
03:18:19 <mauke> as opposed to EXPR where DEFINITONS
03:18:22 <RosePerry> I'm not actually using a let statement
03:18:33 <mauke> except that's a lie because you can't attach 'where' to arbitrary expressions
03:18:43 <mauke> RosePerry: doesn't really matter
03:18:58 <mauke> 'let' and 'where' do the same thing, just with slightly different syntax
03:19:13 <Lemon> @hoogle (a -> f b) -> f a -> f b
03:19:14 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
03:19:14 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
03:19:14 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
03:19:19 <RosePerry> oh, I see
03:20:18 <RosePerry> So what if inside the EXPR, bfs gets set to itself? See the code snippet
03:21:10 <mauke> bfs doesn't get set to itself
03:21:25 <mauke> also, that's the DEFINITIONS part, not EXPR
03:21:40 <RosePerry> You're right
03:21:55 <RosePerry> What does the very last line >> bfs do?
03:21:58 <mauke> high-level structure: bfs = ... >>= ...
03:22:15 <mauke> RosePerry: it calls (>>) with two arguments
03:22:23 <mauke> the first one is mapM_ (\z->bfsEnqueue (z:y:ys)) (nextsFun y)
03:22:25 <mauke> the second one is bfs
03:22:49 <mauke> and that bfs is indeed the same one we're currently defining
03:26:29 <RosePerry> In (>>) :: Monad m => m a -> m b -> m b, where does the b come from?
03:26:51 <mauke> I don't understand that question
03:27:40 <srhb> RosePerry: the as and bs are just "forall a and b..."
03:27:48 <srhb> RosePerry: or any, in this case, is probably more clear.
03:28:57 <srhb> RosePerry: This goes for any letter which is not in the constraints, like m is in this case "Monad m => ..."
03:30:41 <mekeor> xraycat: it's in german :) i'm from germany =)
03:31:19 <mekeor> xraycat: did you write that book?
03:31:53 <xraycat> mekeor: no, I've just had to work with it
03:32:09 <srhb> RosePerry: Just 'a' >> Just 2 -- for example, here a is Char and b is Int. That they are different and unconstrained tells you that "a and b can be any types, and they can be different types"
03:34:44 <xraycat> mekeor: I just took a quick look and wasn't able to find anything similar in english and since you asked about the notation, I thought it might help, even if it's in german, I guess it worked out better than expected ;-) was that something you were looking for?
03:35:48 <mekeor> xraycat: quite, yes :)
03:36:23 <mekeor> at least, it's a book, i mean. so, you can read it… :)
03:37:20 <xraycat> I mean content-wise
03:38:44 <paddy_> Hi, I am looking for the best way to work with matrix's in haskell, and am wondering if repa is the best way to go
03:39:18 <srhb> paddy_: Big matrices?
03:39:39 <paddy_> couple of million members
03:39:47 <srhb> paddy_: Then repa is probably a good choice.
03:40:12 <srhb> paddy_: Free parallellism is nice, after all. :-)
03:40:12 <paddy_> will that allow me to "map (+3) someMatrix"?
03:40:16 <paddy_> oh
03:40:18 <paddy_> that is nice
03:40:21 <paddy_> free paralism?
03:40:36 <srhb> paddy_: Yes, repa has map functionalities.
03:40:47 <srhb> paddy_: http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial#Maps.2C_zips.2C_filters_and_folds -- note the docs are a bit outdated
03:41:33 <srhb> paddy_: Things like map will be automatically parallel with repa.
03:41:45 <paddy_> I love the idea of that
03:41:58 <srhb> (Or at least, that is my understanding - I am no expert)
03:42:03 <srhb> Easy to test though :-)
03:42:57 <RosePerry> srhb: What if the second parameter to >> is just a monad that has no parameter? See the hpaste titled "breadth first search". I'm referring to the very last line.
03:43:18 <srhb> RosePerry: Monad with no parameter? Now, what monad would that be?
03:43:34 <RosePerry> See the code. It's called "bfs"
03:44:11 <srhb> RosePerry: Looks like a State monad
03:44:25 <RosePerry> Thanks! I'll read about it more
03:44:39 <srhb> @type evalState
03:44:41 <lambdabot> forall s a. State s a -> s -> a
03:44:48 <srhb> Hmm
03:44:51 <fmap> second parameter to >> can't be a monad, since a monad is a type
03:44:54 <fmap> not a value
03:45:12 <srhb> :t (>>)
03:45:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
03:46:26 <srhb> But the type of that value is some monad.
03:46:49 <srhb> some monadic type?
03:46:55 <srhb> Not sure of the terminology here :-)
03:49:51 <OceanSpray> @hoogle (a -> f b) -> f (a -> b)
03:49:52 <lambdabot> No results found
03:49:56 <OceanSpray> @hoogle (a -> f b) -> f (a -> f b)
03:49:56 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
03:49:56 <lambdabot> Data.Generics.Aliases choiceQ :: MonadPlus m => GenericQ (m r) -> GenericQ (m r) -> GenericQ (m r)
03:49:57 <lambdabot> Data.Generics.Aliases recoverQ :: MonadPlus m => r -> GenericQ (m r) -> GenericQ (m r)
03:51:03 <paddy_> What happens if a haskell program runs out of memory?
03:51:59 <srhb> paddy_: Computer starts swapping, swap goes full, computer crashes? :-)
03:52:15 <paddy_> I mean if a  malloc fails
03:52:22 <paddy_> does the progam always crash?
03:53:05 <paddy_> could i say, run a function and if it runs out of memory, forget about it and tell the user to try something smaller?
03:53:38 <srhb> paddy_: I suppose it depends how the memory is allocated. Someone else will know this better than me. I imagine there are exceptions thrown that you can dela with
03:53:52 <RosePerry> In the hposte code, "breadth first search", how does "bfs" change over the course of the function definition?
03:56:09 <srhb> paddy_: Never actually managed to exhaust the heap in any nonbugged code.. :P
03:57:24 <alang> anyone know about quadratic programming? There don't seem to be any packages for it on haskell, so I figure I would write my own. Just curious if anyone would happen to know what the best-performing algorithms are nowadays?
04:22:26 <theadmin> So I was wondering... What's the meaning behind the name "Haskell"?
04:22:39 <theadmin> And why a lambda for a logo?
04:23:32 <hpc> @google Haskell Curry
04:23:34 <lambdabot> http://en.wikipedia.org/wiki/Haskell_Curry
04:23:34 <lambdabot> Title: Haskell Curry - Wikipedia, the free encyclopedia
04:23:56 <hpc> "Haskell" is the name of a person
04:24:12 <theadmin> I see, heh, that was unexpected
04:24:32 <hpc> also, https://en.wikipedia.org/wiki/Lambda_calculus
04:25:47 <theadmin> I see. Kind of figured it has nothing to do with headcrabs and such.
04:26:06 <nand`> Haskell is older than Half Life 2 if I'm not mistaken
04:26:42 <byorgey> it's even older than Half Life 1!
04:26:43 <hpc> older than half life
04:27:06 <hpc> and λ is a physics symbol too that has something to do with nuclear decay
04:27:14 * hpc hasn't taken physics in forever
04:27:24 <theadmin> What's the license for the Haskell logo by the way? Can I reuse it freely?
04:28:09 <nand`> https://en.wikipedia.org/wiki/File:Haskell-Logo.svg <- public domain
04:28:31 <theadmin> hpc: It's a symbol for half-life. http://en.wikipedia.org/wiki/Effective_half-life
04:31:39 <theadmin> Just making sure... There isn't a way to make recursive lambdas, right?
04:31:47 <unnali> theadmin: fix?
04:31:55 <theadmin> unnali: ?
04:32:05 <unnali> uhhhh, lemme find it
04:32:10 <unnali> @hoogle fix
04:32:10 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
04:32:11 <lambdabot> Data.Fixed module Data.Fixed
04:32:11 <lambdabot> Data.Function fix :: (a -> a) -> a
04:32:13 <nand`> > fix (\f x -> if x == 0 then 1 else x * f (x-1)) 5
04:32:14 <lambdabot>   120
04:32:16 <hpc> fix $ \f x ... -> ...
04:32:18 <hpc> =
04:32:22 <hpc> f x ... = ...
04:32:31 <hpc> roughly
04:32:44 <unnali> @src fix
04:32:44 <lambdabot> fix f = let x = f x in x
04:33:04 <theadmin> Ah, I see
04:33:47 <unnali> theadmin: but otherwise, no, there's no general way for a lambda to refer to itself (without itself being bound somewhere, like with fix or let or whatever)
04:34:23 <theadmin> unnali: That makes sense, can't really refer to something which has no name
04:35:40 <srhb> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 10
04:35:42 <lambdabot>   3628800
04:35:44 <srhb> cool :-)
04:36:24 <nand`> > fix (\xs -> 1 : map (1+) xs)
04:36:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:36:48 <nand`> > let xs = 1 : map (1+) xs in xs
04:36:49 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:37:04 <unnali> @pl \xs -> 1 : map (1+) xs
04:37:04 <lambdabot> (1 :) . map (1 +)
04:42:53 <unnali> theadmin: just found this, seems to be making things work better for me in my head: http://www.vex.net/~trebla/haskell/fix.xhtml
04:44:49 <theadmin> unnali: ic -- well, I am familiar with let ... in ... constructs
04:45:05 * unnali nods
04:47:47 <nand`> > let fix f = f (fix f) in fix ((1:) . map (2*))
04:47:49 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
04:48:14 <unnali> > fix $ scanl (+) 1
04:48:16 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
04:48:34 <theadmin> ...What's scanl?
04:48:48 <byorgey> > scanl f z [a,b,c,d]
04:48:49 <unnali> (^-- shamelessly copied from aforementioned URL)
04:48:49 <srhb> @src scanl
04:48:49 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c,f (f (f (f z a) b) c) d]
04:48:50 <lambdabot> scanl f q ls = q : case ls of
04:48:50 <lambdabot>     []   -> []
04:48:50 <lambdabot>     x:xs -> scanl f (f q x) xs
04:49:31 <byorgey> > scanl (+) z [a,b,c,d]
04:49:33 <lambdabot>   [z,z + a,z + a + b,z + a + b + c,z + a + b + c + d]
04:49:33 <unnali> it's like foldl, except you get successive reductions, not just the last one.
04:49:36 <srhb> I think the classical form is clearer..
04:49:40 <unnali> > foldl (+) z [a,b,c,d]
04:49:42 <lambdabot>   z + a + b + c + d
04:49:43 <srhb> > fix (\f s -> s : f (s*2)) 1
04:49:43 <srhb>  
04:49:44 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
04:49:53 <unnali> srhb: i'd be inclined to agree. :)
04:50:59 <byorgey> > fix $ ((0:) . scanl (+) 1)
04:51:02 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:51:10 <srhb> Nice. :P
04:52:48 <nand`> > iterate (scanl (+) 1) []
04:52:49 <lambdabot>   [[],[1],[1,2],[1,2,4],[1,2,4,8],[1,2,4,8,16],[1,2,4,8,16,32],[1,2,4,8,16,32...
04:53:18 <theadmin> Heh, just messed with the $ operator (?), looks nicer than parentheses...
04:53:51 <srhb> theadmin: Often, yes. Though some people disagree. :)
04:53:58 <theadmin> srhb: How come?
04:54:25 <srhb> theadmin: Same reason some people prefer green to purple, I think, even though green should be objectively disgusting.
04:55:55 <theadmin> I take it "fix" is defined in Control.Monad.Fix? GHC doesn't seem to auto-import whereever it is defined...
04:56:04 <ion> I guess one can say somewhat objectively that using more than one ($) in an expression is too much.
04:56:05 <hpc> i think that's more about not using ($) right, than anything else
04:56:06 <nand`> Data.Function.fix
04:56:09 <srhb> theadmin: I get it from Data.Function..
04:56:24 <hpc> you use ($), (.), and parens to make code look like what it means
04:56:26 <byorgey> theadmin: it's defined in Data.Function, and re-exported from Control.Monad.Fix as wel
04:56:34 <hpc> if the important part is this huge expression, and then you print it
04:56:36 <hpc> print $ huge expr
04:56:49 <hpc> if it's just some math, nothing's wrong with print (math)
04:57:06 <ion> yeah
04:57:21 <theadmin> I agree, matter of place
04:58:51 <ion> “foo . bar $ baz” is always better than “foo $ bar $ baz”; “(foo . bar) baz” may or may not be better.
04:59:03 <hpc> indeed
05:00:33 <theadmin> ion: So, something along the lines of "print $ take 10 . fix $ scanl (+) 1"?
05:00:37 <nand`> liftIO . putStrLn $ "foo" ++ bar ++ "bat" -- much prettier than liftIO (putStrLn ("foo" ++ bar ++ "bat")) if you ask me
05:01:16 <hpc> i think i would do
05:01:26 <hpc> liftIO $ putStrLn ("foo" ++ bar ++ "baz")
05:01:50 <hpc> to visually distinguish that the trailing expression is a single logical thing
05:02:17 <kaini> Is there a way to apply a patch to a cabal package (once)? -- I am affected by this https://gist.github.com/60d44b1ef5e28e528845 problem and I know how to fix it in the code
05:02:19 <nand`> “liftIO” is pretty much the only thing I use with . on the LHS of a ($), since usually I'd write putStrLn $ "foo" ++ bar ++ "baz"
05:02:39 <nand`> the liftIO doesn't change the semantic meaning of the expression, it's just there to plaster the MonadIO onto the type
05:03:12 <ion> theadmin: There are two ($)s in that. That’s too much. :-P
05:22:25 <Catnaroek> @hoogle intercalate
05:22:26 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
05:22:26 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
05:22:26 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
05:22:27 * hackagebot yesod-auth-fb 1.0.6 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.0.6 (FelipeLessa)
05:24:10 <Catnaroek> @hoogle for
05:24:11 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
05:24:11 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
05:24:11 <lambdabot> Foreign module Foreign
05:49:02 <teneen> is Data.HashTable efficient?
05:50:47 <loxs> hi. I am an Erlang  programmer. Now I am trying to decide between haskell and ocaml for my second functional language. could anyone please care to suggest me which one should I pick (obviously, having in mind that we are in #haskell).  I am not searching for a "mega service powerhorse". For that I already have Erlang.  Any good articles on the topic would be appreciated.
05:55:01 <Clint> loxs: is there anything in particular you wish you had in erlang?
05:55:29 <fmap> teneen: are you having some perfomance problems?
05:56:07 <teneen> fmap: I want to use an efficient structure
05:56:30 <teneen> fmap: HashTable vs Unboxed vectors
05:56:35 <teneen> mutable or immutable
05:56:40 <teneen> or Data.Map
05:57:29 <loxs> Clint, well, mostly I want a nice experience with static type systems. But in this recard ocaml and haskell both seem to be equally good (although in a different manner). Otherwise, there is nothing in particular I miss in Erlang. So far it's great.  Probably I want something to write "smaller"  applications. Ones that don't need to run in clusters etc.
05:57:54 <hpaste_> ocharles pasted “3 way merges” at http://hpaste.org/70032
05:58:00 <fmap> i dont' think there is a generally efficient data structure
05:58:09 <ocharles> Hey, I'm trying to write some code to do 3 way merges with the ability to get conflict information out
05:58:16 <fmap> an efficiency depends on operations you want
05:58:18 <ocharles> So far I have what's in the above paste, I'd love to hear if anyone has any feedback
05:58:27 <ocharles> I don't like the instance of Mergeable for TestThing, because I have to do way too much threading
05:58:36 <ocharles> I want something more like TestThing <$> mergeEq <*> mergeEq
05:58:52 <ocharles> but not quite sure how to get to that
05:59:34 <merijn> loxs: Some reasons I'd personally pick haskell over ocaml are: Laziness, prettier syntax and typeclasses being really cool
06:00:29 <loxs> merijn, and it seems quite a lot more popular... which probably means more "batteries"?
06:00:46 <teneen> fmap: The problem with HashTable is that it uses boxed vaues
06:00:56 <merijn> loxs: Could be, I can't really say anything objective about that
06:01:40 <mekeor> loxs: also the haskell community is great =) especially, #haskell ^^ and especially merijn :)
06:02:09 * mekeor was not objective… :D
06:02:14 <loxs> merijn, me, being a web programmer, I am mostly interested in tools for writing web. And I am also a user of xmonad, which will be another free "extra" (I'll be able to understand what I put in my config :))
06:02:24 --- mode: ChanServ set +o mauke
06:02:57 <mekeor> loxs: yea, haskell's web frameworks are great. xmonad is awesome (ignore the ambiguity, please), too :)
06:03:10 <Clint> sounds like your path is clear
06:03:28 <hpc> @remember mekeor xmonad is awesome (ignore the ambiguity, please)
06:03:28 <lambdabot> I will remember.
06:03:37 <mekeor> :D
06:03:48 <mekeor> i think that's my first quote! yippie yay! :D
06:04:01 <Catnaroek> @hoogle Control.Monad.Map
06:04:01 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:04:02 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:04:02 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
06:04:07 <mekeor> i want to define a type-class C. for a type t being able to be an instance of C, it has either to be an instance of type-class D or type-class E. (how) can i do that?
06:04:20 <loxs> how would you guys compare the claimed "compiler catches most, if not all errors" of both haskell and ocaml?  And how would you compare the experience with something like erlang's dialyzer (type analysis tool)
06:05:04 <ion> It was shown once again that Haskell code usually works when the compiler doesn’t find anything to complain about :-). I coded a client implementation for this (horrible) protocol and it worked the first time i ran it. https://developer.valvesoftware.com/wiki/Source_RCON_Protocol
06:05:41 <Catnaroek> @type runMap
06:05:43 <lambdabot> Not in scope: `runMap'
06:05:44 <Catnaroek> @type runMapT
06:05:45 <lambdabot> Not in scope: `runMapT'
06:05:47 <hpc> ion: ouch
06:05:54 <hpc> have you seen the source-engine side of that code?
06:06:18 <ion> hpc: Nope. I’m meaning to interface with the Minecraft server which uses that protocol for remote control.
06:06:23 <unnali> loxs: i somehow failed to ever get dialyzer to work. probably just me.
06:07:09 <loxs> unnali, getting it to work is a PITA, after that it's great. Though, sometimes its error messages make you scratch your head a lot :)
06:07:26 <ocharles> haskell is no different there then :)
06:08:45 <merijn> loxs: Well, I think there's certainly more haskell web frameworks than ocaml
06:09:12 <merijn> Yesod, snap and happstack seem the most popular
06:09:32 <unnali> ^i only really know of ocsigen for OCaml
06:09:42 <unnali> ocaml-http doesn't really count…
06:10:03 <merijn> loxs: In both ocaml and haskell the compiler does catch a lot of stuff. I have some code I completely refactored about 5 times relying on the compilers lack of errors to tell me when I was done
06:10:15 <merijn> So far the refactorings haven't broken anything :p
06:10:27 <merijn> (Well, not anything the compiler didn't catch)
06:10:56 <loxs> merijn, the question is though, which one is better at "easily" writing small and easy to deploy/manage applications. The "easy" and "small" is really important to me, as for my big stuff I use erlang (for now), and it's really awkward for "small" stuff.
06:11:21 <loxs> I would like things like "ship only binaries" etc.
06:12:03 <merijn> I would think haskell, mostly since I've only written any significant code in haskell. Ocaml I mostly wrote very simple sample code
06:12:27 <ion> https://github.com/ion1/rcon-haskell
06:12:34 <unnali> there's no reason why you can't write big deployable stuff in OCaml
06:12:48 <merijn> Writing your own stuff shuldn't be that hard to get started with, but working with other people's stuff might be a bit trickier
06:13:30 <loxs> yeah, for now I mostly will write my own "hobby" stuff :)
06:13:33 <merijn> If you're not all that familiar with standard libraries and typeclasses like Functor, Applicative, Monad, etc. other people's code might be a bit cryptic
06:13:33 <k0ral> anyone knows of a good learning material about category theory ?
06:14:07 <loxs> thanks, I guess I'll start writing something in haskell today. Especially after the warm welcome :)
06:14:49 <srhb> loxs: This channel totaly sold it to me, too. :-)
06:16:37 <lzm> hello. what is the proper way of installing haskell and its packages on osx?
06:16:44 <lzm> brew perhaps?
06:16:55 <srhb> lzm: Haskell Platform
06:16:55 <merijn> lzm: Installing Haskell Platform and install the rest using cabal
06:17:28 <merijn> If you have homebrew I figure you already have Xcode+command line tools, so you should be good to go after installing Platform
06:17:39 <merijn> @where platform
06:17:39 <lambdabot> http://hackage.haskell.org/platform/
06:17:42 <unnali> note that `haskell-platform' is on brew.
06:17:45 <unnali> and is up-to-date.
06:18:02 <lzm> cool, thanks
06:19:29 <hpaste_> openstanards pasted “cabal install DBus” at http://hpaste.org/70033
06:20:25 <openstandards> hi running archlinux and install haskell and cabal-instal  via pacman and just tried installing DBus vis cabal-install but i'm getting an error would someone be able to help me out? i have paste binned the error and you'll find that above
06:22:28 <unnali> openstandards: ghc -V
06:22:30 <unnali> what do you see?
06:23:26 <openstandards> version 7.4.2
06:23:52 <unnali> hmmm.
06:24:15 <srhb> It would appear the DBus package has not been updated for 7.4
06:24:25 <gienah> openstandards: if you really want to use it there's a patch here: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/hdbus/files/hdbus-0.4-ghc-7.4.patch
06:24:51 <loxs> also, is it "easy" to run haskell applications (compiled elsewhere) without having to install haskell stuff system wide?
06:25:12 <ocharles> loxs: yes, haskell statically links by default
06:25:19 <ocharles> all you need is the same architecture and you're good to go
06:25:21 <gienah> openstandards: there's a note on the home page suggesting to use dbus-client, although the author of dbus client has a habit of radically changing the API (totally breaking manatee twice)
06:26:13 <gienah> openstandards: oops, *not* dbus-client, dbus-core. dbus-client being replaced by dbus-core was 1 of the total breaking api changes :-/
06:26:27 <loxs> thanks ocharles
06:27:52 <openstandards> thanks gienah for sharing your knowledge with me i never would of figured this out without your help so its much welcomed
06:28:08 <gienah> openstandards: no worries :-)
06:31:49 <srhb> Where on the Haskell Platform page do I see which GHC is in there?
06:32:09 <loxs> how good is emacs at haskell?
06:32:14 <srhb> Nevermind, found it
06:32:30 <srhb> loxs: Very good imo, and a very new and fancy mode is being actively developed.
06:32:46 <gienah> loxs: has next to no understanding of haskell indendation, but after getting over that its works quite well
06:33:34 <loxs> gienah, what do you mean by "getting over that"? could you please share some article?
06:33:53 <t7> i need a cross platform way to watch a file/directory for changes
06:34:02 <ocharles> loxs: chris' latest work on haskell-mode on github makes it very nice to work with haskell in emacs
06:34:07 <srhb> I've had no issues with haskell-mode's indentation
06:34:10 <ocharles> hit f5 to load code into a repl, cabal support, etc
06:34:20 <gienah> loxs: http://www.haskell.org/haskellwiki/Emacs
06:34:40 <loxs> thanks
06:35:10 <gienah> loxs: the cool kids use the github version though :-) http://www.youtube.com/watch?v=E6xIjl06Lr4
06:35:34 <ocharles> yep
06:36:56 <loxs> gienah, yeah, I can do that too :)
06:37:07 <gienah> loxs: by "getting over that" I just mean accepting that haskell-mode has next to no idea of how to indent haskell :-/
06:37:13 <beefcube> if I have two constructors for a type, and they both have an identical record field, is there a way to pattern match on either of them and just that field, instead of having to match seperately for each constructor?
06:38:11 <shachaf> You can use the record accessor as a function.
06:38:21 <roconnor> beefcube: you can use the field name as a projection function.
06:38:25 <shachaf> It won't work with pattern-matching. You might consider factoring the common field out, though.
06:38:33 <beefcube> gienah: https://github.com/kana/vim-filetype-haskell/blob/master/indent/haskell.vim
06:39:46 <beefcube> ah, of course, thanks
06:39:59 <gienah> beefcube: that looks neat, is that commonly used by haskell vim users (me wonder if should add it to the gentoo-haskell overlay)?
06:40:34 <loxs> gienah, and is there a "better" editor for haskell? (though I can't imagine leaving emacs)
06:40:47 <shachaf> loxs: Your editor really doesn't matter.
06:40:50 <beefcube> gienah: no idea
06:40:53 <shachaf> Just use whatever you like. It'll work.
06:41:16 <gienah> loxs: not that I know of (I use emacs with the github haskell-mode)
06:41:18 <nand`> gienah: I wouldn't be too sure about it. Most vim+haskell users I've spoken about it with use either no auto-indentation or a primitive “keep same indentation level” mode
06:41:20 <srhb> The syntax is really nice, so yeah. Any editor will do. Emacs is one such editor that is great for it. :-)
06:41:28 <nand`> myself included (the latter)
06:41:35 <beefcube> gienah: it works for some indent cases, i'm not entirely satisfied with it
06:41:54 --- mode: ChanServ set +o shapr
06:42:10 <gienah> beefcube: thanks, haskell indentation is difficult to handle
06:42:13 <nand`> just make sure to use spaces and not tabs, those are generally frowned upon
06:42:21 <srhb> Yes!
06:42:51 <shapr> gienah: Are you using indent or simple-indent?
06:43:19 <shapr> I'm a big fan of chris done's latest haskell-mode as well.
06:43:41 <srhb> Is there an el-get recipe for it?
06:43:57 <shapr> I don't know, I just have a huge elisp directory.
06:44:00 <srhb> :-)
06:44:21 <gienah> shapr: I'm not really sure, I have (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
06:44:27 <shapr> I just downloaded haskell-mode, commented out everything in ~/.xemacs/shae-haskell.el and added chris done's configuration at the bottom.
06:44:50 <shapr> After which I used it for a few days, and then figured out which parts of my original config I wanted back.
06:45:08 <shapr> For example, Chris uses simple-indent, and I prefer the slightly smarter indent :-)
06:45:29 <shapr> I'm also not really a fan of having my F-keys rebound, but I'm still sticking with that for now.
06:45:43 <gienah> shapr: thanks, maybe I should try the slightly smarter indent :-)
06:46:22 <shapr> I *am* a fan of having a separate ghci process for each of the different cabal projects I have open at any given moment, that's a neat feature!
06:46:36 <srhb> There was indeed an el-get recipe for it. Yay!
06:47:10 <loxs> shachaf, sorry for late answer. Well... my editor certainly does matter if it makes it difficult to write code in the right way....
06:47:47 <shachaf> loxs: You can use an editor that does zero autoindentation and it'll work just fine.
06:47:53 <nand`> any editor that makes it difficult to write things in a certain way should be avoided, imo
06:48:04 <hpc> imo, no-auto-indent produces better code
06:48:12 <srhb> loxs: It is not. Just use what you're used to, Emacs is a great choice. Stop deliberating! O:-)
06:48:16 <hpc> because you have to pay for each extra level of indentation with more typing
06:48:24 <hpc> it encourages you to write smaller functions
06:48:33 * nand` just switches indentation to 2 spaces instead to make it not that bad
06:48:48 <hpc> nand`: i do that too, but it still gets annoying quickly for me
06:49:14 <nand`> I agree, I avoid large stacked definitions if I can
06:49:25 <hpc> the only exception to the rule, i think
06:49:27 <nand`> hpc: the update to ghc-man-completion that enables file completion works fine, by the way
06:49:30 <nand`> much better
06:49:39 <hpc> is when you are using haskell to generate a highly nested structure
06:49:44 <hpc> nand`: yeah, glad you mentioned that
06:49:53 <hpc> would have been forever before i noticed myself :P
06:50:01 <hpc> all it took was a -f flag
06:50:01 <nand`> indeed, I usually don't invoke ghc manually
06:50:22 <dino-> I'm suddenly seeing a problem where the Synopsis tab in Haddock docs always defaults to being open on every new doc page I arrive at.
06:50:46 <dino-> I wish I could turn that fruity JS business off altogether. It's a pain in the ass. bleh
06:50:57 <openstandards> gienah: how would i go about applying that patch you told me about
06:51:21 <nand`> hpc: I might as well share the ebuild I wrote for it, in case you want to upload it anywhere: https://paste.lugons.org/raw/2189/
06:51:49 <hpc> http://hpaste.org/70034 -- this is pretty much the only kind of situation where i would say "go crazy with nesting"
06:52:11 <gienah> openstandards: I'm not exactly sure since I never use cabal-install, but I think its something like: cabal unpack DBus-*.tar.gz; patch --verbose -p 1 <path-to-patch; cabal configure; cabal build; then I'm not sure
06:52:52 <nand`> hpc: the main reason to avoid large nesting, for me, is to avoid breaking 80 col
06:53:27 <hiptobecubic> hpc, what is that?
06:53:28 <nand`> (which is another way of forcing you to refactor large functions)
06:53:45 <hpc> hiptobecubic: embedded html in haskell code
06:53:48 <dino-> Hm, looks like just the Happstack docs, I wonder if it's the way they were generated.
06:53:49 <hpc> i write my website in that style
06:54:10 <hiptobecubic> which framework is it?
06:54:17 <hpc> no framework
06:54:36 <gienah> openstandards: anyway I think "cabal unpack" is part of the first step, so maybe google for "cabal unpack" patch might find better instructions
06:54:38 <hpc> in fact, the only two depends are SHA and hdbc-mysql
06:54:48 <hpc> (and their depends, naturally)
06:55:00 <nand`> presumably one could achieve a similar affect using some form of Writer String
06:55:13 <nand`> similar-looking code, that is
06:55:13 <hiptobecubic> hpc, why not one of the frameworks everyone seems so thrilled about?
06:55:22 <srhb> Is there a getFilesMatching "/path/to/foo*.?.ext" ?
06:55:43 <hpc> hiptobecubic: this way was easier
06:55:55 <hpc> i already know how CGI works
06:56:15 <hpc> and if i ever care to make it generate static files, that's a piece of cake too
06:56:42 <hpc> and if i ever want to extend it, the only code i ever need to look at is my own
06:59:03 <hpc> nand`: you should try and get it into gentoo's package manager
07:05:08 <hpc> what
07:05:20 <hpc> ghc-man-completion is working when i cabal-install from a tarball
07:05:23 <hpc> but not from hackage
07:06:36 <hpc> er, when i compile from github
07:06:42 <hpc> tarball doesn't work
07:07:23 <hpaste_> nand` pasted “HTML generation” at http://hpaste.org/70035
07:07:41 <nand`> hpc: I couldn't get the hackage version to compile either
07:08:43 <hpc> oh i see
07:09:20 <hpc> so cabal doesn't use other-modules to determine what goes on the compilation path
07:09:33 <hpc> and if you leave that field out of the cabal file, it still builds when you test it
07:09:39 <hpc> and it doesn't even warn in cabal check
07:09:53 <theadmin> I have a little problem... http://sprunge.us/eWJX -- it awaits for the input *first* and then performs the putStr -- how can I fix that?
07:10:02 <hpc> but what it does do, is stop your other modules from being included in the final tarball
07:10:47 <saep> @pl \v ->  (Var (UnQual (Ident ((pp . normCat) p))))
07:10:47 <lambdabot> const (Var (UnQual (Ident (pp (normCat p)))))
07:11:07 <saep> @pl \p ->  (Var (UnQual (Ident ((pp . normCat) p))))
07:11:08 <lambdabot> Var . UnQual . Ident . pp . normCat
07:13:30 <nobdraisentone> Is there some way to convert unix timestamp to something readable like '2 days ago' or `year ago', etc ...
07:13:33 <nobdraisentone> ?
07:15:10 <saep> nobdraisentone: http://book.realworldhaskell.org/read/systems-programming-in-haskell.html in the section "ClockTime and CalendarTime"
07:15:31 <theadmin> Bwah, figured it out... hSetBuffering stdout NoBuffering
07:15:36 <theadmin> Crazy stuff :/
07:15:40 <theadmin> Oh well
07:18:37 <fmap> there is nothing crazy, you want buffering most of the time
07:19:37 <mikeplus64> fmap: when do you want buffering, and why?
07:20:05 <merijn> Almost always, because it improves speed
07:20:17 <byorgey> if you're just writing a bunch of text to the screen, or to a file, turning off buffering slows things down a lot
07:20:26 <merijn> It drastically reduces the number of system calls needed
07:21:11 <theadmin> fmap: You hardly ever want buffering on STDOUT, not on interactive apps anyway, though
07:21:22 <merijn> theadmin: Sure you do
07:21:29 <merijn> newlines flush stdout anyway
07:21:36 <merijn> Or any file, really
07:21:53 <theadmin> merijn: When I'm trying to do a prompt-style thing with putStr I haz no newlines (obviously)
07:22:08 <theadmin> But I didn't know they do that... Oh well %)
07:22:33 <barrucadu> You could use hFlush
07:22:34 <merijn> theadmin: That's a rather uncommon scenario (btw, the same behaviour happens in python, C and any other language I've used)
07:22:42 <merijn> Normally you call flush in those scenario's
07:25:40 --- mode: holmes.freenode.net set +o ChanServ
07:29:05 <theadmin> merijn: I see... Hm, doesn't happen in Perl, guess I'm just used to that %)
07:30:29 <rwbarton> it looks like perl makes reads from stdin flush stdout
07:31:19 <theadmin> What's the "h" in hFlush (or even in hSetBuffering and such) stand for? %)
07:31:26 <Iceland_jack> handle
07:31:31 <theadmin> ...duh *facepalm*
07:31:37 <Iceland_jack> (:
07:34:24 <loxs> so, happstack is the "Django" of haskell? :)
07:34:52 <theadmin> loxs: There are also Snap and Yesod.
07:35:52 <loxs> yes, I see, now I'm trying to find which one is what kind of web framework
07:39:36 <alpounet> loxs, there's a blog post about that on mightybyte's blog
07:42:45 * hackagebot ghc-man-completion 0.0.0.3 - Generate a bash completion from the GHC manpage  http://hackage.haskell.org/package/ghc-man-completion-0.0.0.3 (JoeQuinn)
07:44:18 <loxs> alpounet, yup, just found it, thanks
07:44:55 <mm_freak> loxs: basically happstack and snap are about maximum composability, while yesod is for maximum ad hoc productivity
07:45:07 <mm_freak> you can be very productive with all three of them
07:52:17 --- mode: mauke set -o mauke
08:14:51 <theadmin> Can someone explain what the heck a Monad is -_- No tutorial makes any sense on it
08:15:32 <zhulikas> :D
08:15:57 <ski> do you know what a priority queue is (e.g.) ?
08:16:13 <mikeplus64> theadmin: it's a typeclass
08:16:16 <Catnaroek> theadmin: A monad is like a box. Out of it, you may get something (of type a, possibly many values, possibly even no value at all), but in order to get that value, you have to... unwrap the present box.
08:16:36 <ion> catnaroek: How do you unwrap IO?
08:16:37 <Catnaroek> And what "unwrapping the present box" consists in depends on the specific monad.
08:16:41 <Catnaroek> ion: Running it.
08:16:49 <Catnaroek> Well, you do not unwrap it.
08:16:49 <mikeplus64> theadmin: the monad typeclass has the operations >>, >>= and return
08:16:53 <theadmin> Catnaroek: Ok... so it's something of type a... in a container.
08:16:53 * ski unwraps a box of chocolate ..
08:17:00 <Catnaroek> ski: lol
08:17:15 <ion> theadmin: You should learn about functors and applicative functors first.
08:17:17 * ski finds himself trapped inside a box of chocolate
08:17:45 <rwbarton> unsafeEatEntireBoxOfChocolate
08:17:46 <mikeplus64> theadmin: >> will sequence two monadic expression, >>= will 'evaluate' a monadic expression, passing it to another that will create a new monadic expression (of the same monad), and return will put something into a monad
08:17:51 <parcs`> @where lyah
08:17:51 <lambdabot> http://www.learnyouahaskell.com/
08:18:00 <parcs`> theadmin: have you tried understanding that resource
08:18:02 <mikeplus64> theadmin: for instance, print 1 >> print 2 -- print 1, then print 2
08:18:22 <mikeplus64> theadmin: getLine >>= putStr -- get a line, then print it via putStr
08:18:36 * ski . o O ( `StomachAcheException' )
08:18:39 <theadmin> mikeplus64: Which is the same as do { print 1; print 2; }, yes, I know of the >> operator
08:18:43 <mikeplus64> theadmin: return 10 :: IO Int -- evaluates to an IO Int
08:18:54 <mikeplus64> theadmin: then you know of monads :)
08:19:09 <theadmin> mikeplus64: Heh, okay :D Knowing how to use something without knowing what it is is... weird
08:19:33 <mikeplus64> theadmin: as far as ghc cares, Monad is simply a typeclass
08:19:36 <ski> theadmin : a monad provides a way to compose smaller "commands" into a larger "command" -- what a "command" really is / can do depends on the monad in question
08:19:39 <srhb> theadmin: People like to do IO before they can actually understand how intelligently IO is handled in Haskell. It makes sense. :)
08:19:43 <mikeplus64> theadmin: if you know what that is then you're fine
08:19:59 <theadmin> mikeplus64: Hehe, okay :)
08:20:02 <Minoru> theadmin: some people say one shouldn't learn "monads"; one should understand List, IO, Maybe and so on, i.e. just instances of monad
08:20:13 <mikeplus64> exactly
08:20:20 <ski> theadmin : e.g. the `Maybe' monad is for "commands" which can possibly fail
08:20:38 <Minoru> ski: your definition also defines (.) and arrows
08:20:54 <ski> yes
08:21:12 <ski> (though it wasn't meant as a definition, only as a(n incomplete) description)
08:21:40 <srhb> I wish there were some arrow instances in Prelude. I find myself importing so often for (&&&)
08:21:46 <ski> theadmin : have you seen <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> yet (it's not very long) ?
08:22:03 <theadmin> ski: No, will look at it after I take the trash out, thanks.
08:22:30 <ski> theadmin : after you have read it, could you come back and say whether it helped ?
08:22:48 * hackagebot shelly 0.10.0.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.10.0.1 (GregWeber)
08:28:43 <shapr> preflex: seen kamatsu
08:28:43 <preflex>  kamatsu was last seen on #haskell 1 day, 18 hours, 27 minutes and 19 seconds ago, saying: then you could use rank n types.
08:28:47 <shapr> poo
08:30:40 <theadmin> ski: I will, surely.
08:32:46 <theadmin> What's the versioning idea behing GHC anyway? 7.2.2 then suddenly 7.4.1...
08:33:30 <HairyDude> it's like the linux kernel. odd minor numbers are development versions
08:34:09 <theadmin> ski: Okay, thanks, that looks quite understandable, I'll dig into it further later
08:35:31 <theadmin> HairyDude: Okay, huh. I see...
08:36:23 <parcs`> HairyDude: how is that like the linux kernel?
08:36:40 <rwbarton> like the linux kernel used to be
08:37:20 <peteretep> I'm trying to properly understand the difference between pattern-matching in functions with [x,y] and (x:s) (although I know the difference between those two). Can anyone point me to an explanation for the difference syntaxes? Or even just the correct names for each type, and then I can google myself
08:38:01 <theadmin> peteretep: x:s means x attached to the list s. So when you call fun ([1,2,3]) you get x == 1 and s == [2,3]
08:38:17 <rwbarton> [x,y] is syntactic sugar for x:(y:[])
08:38:36 <rwbarton> in both patterns and expressions
08:39:09 <peteretep> theadmin: I was under the impression that you couldn't say [x:xs], though, suggesting the outside brackets have a meaning
08:39:25 <srhb> peteretep: You can, that's a list with one element, which is a list
08:40:22 <srhb> > let foo [x:xs] = x in foo [[1,2,3]]
08:40:24 <lambdabot>   1
08:41:39 <rwbarton> peteretep: you may or may not find http://www.haskell.org/onlinereport/exps.html#pattern-matching useful
08:41:54 * peteretep looks
08:43:48 <rwbarton> list patterns like [x,y] are a built-in special syntax, as you can see there
08:44:28 <peteretep> I'm finding that less clear still than anything I've read so far :-)
08:45:03 <srhb> peteretep: I think intuition helps more than anything here. Try your hand and it will all make sense. You can build list patterns with [] and : -- and there are only so many combinations that all make sense :)
08:45:08 <rwbarton> my point is mostly there are a small number of these special syntaxes so i'm not sure what kind of thing you are looking for if you say you already are familiar with [x,y]
08:45:35 <peteretep> The problem is I am currently trial-and-erroring my patterns, which is the wrong way to go about it
08:46:02 <theadmin> Speaking of pattern matching, is there any pattern that's the reverse of (x:xs)? As in, which gives you a list and "chops off" an element off it's *end*, not beginning?
08:46:05 <peteretep> And I don't fully understand when: foo [???] =   is what I want instead of: foo (???) =
08:46:22 <dmwit> peteretep: It's what you want when you want to match a list that looks like [???].
08:46:29 <barrucadu> preflex: You use foo [???] when you know exactly how many elements the list has
08:46:38 <barrucadu> eg, foo [x,y] matches a two-element list
08:46:50 <barrucadu> Whereas foo (x:y) would match any list with at least one element
08:46:51 <dmwit> e.g. [3], ["foo"], [Dogbert { name = "foo", occupation = SalesManager }], etc.
08:47:00 <rwbarton> in general the pattern syntax is the same as the syntax for how you'd write a value that would match the pattern
08:47:29 <rwbarton> so if you understand what the syntax [x,y] means for an expression, you should understand what it means for a pattern too
08:47:30 <peteretep> barrucadu: I thought srhb just gave an example where he matched an unknown number using [x:xs]
08:47:38 <srhb> peteretep: Of INNER lists
08:47:43 <srhb> peteretep: The OUTER list has exactly one element
08:47:55 <rwbarton> (INNER list items*)
08:47:56 <peteretep> ah, ok
08:48:09 <srhb> rwbarton: Oops, yes, sorry
08:48:18 <peteretep> right, I think I've just stumbled in to the circle of wisdom
08:48:23 <srhb> peteretep: :-)
08:48:45 <srhb> peteretep: The inner list was not entirely unknown though, it has at least one element
08:48:55 <srhb> > let foo [x:xs] = x in foo [[]]
08:48:56 <lambdabot>   *Exception: <interactive>:3:4-17: Non-exhaustive patterns in function foo
08:49:01 <srhb> explodes. :)
08:49:19 <peteretep> OK, so: let foo [???] =
08:49:23 <rwbarton> if there was a second equation for foo, it would go on to try it
08:49:41 <peteretep> Will only match when the function is applied to one element, which is a list
08:49:51 <rwbarton> no
08:50:01 <rwbarton> well, maybe you misspoke
08:50:01 <dino-> I'm having trouble making a pattern like theadmin asked about, what  last :: [a] -> a  does
08:50:02 <srhb> peteretep: A list of one element.
08:50:03 * peteretep stumbles back out
08:50:46 <barrucadu> peteretep: foo [x] matches when called on a one-element list, foo [x,y] matches when called on a two-element list, etc
08:50:53 <rwbarton> well, without knowing what kind of thing ??? is supposed to represent it is hard to understand
08:50:56 <rwbarton> yeah
08:51:14 <dmwit> dino-: last can't be implemented with a single pattern match. It needs recursion.
08:51:32 <ski> peteretep : note that in `foo (x:xs) = ...' the pattern is `x:xs', the brackets are just needed for disambiguation, since `foo x:xs' would parse as `(foo x):xs'
08:51:33 <dino-> theadmin: ^ there you are
08:51:48 <peteretep> ski: That makes sense
08:51:59 <rwbarton> peteretep: probably you need to understand this:
08:52:07 <rwbarton> if I want to match any list at all I would just write
08:52:09 <rwbarton> foo x = ...
08:52:14 <theadmin> dmwit: We're not trying to  "implement" last, what we're trying is to find a pattern "similar" to what last does. That is, a pattern which when used on a list will return a list without it's last element and the last element of said list.
08:52:15 <hiptobecubic> Has anyone ever played with a "liquid state machine"?
08:52:17 <ski> peteretep : so, instead of asking about when to use `foo [???] = ...' and when to use `foo (???) = ...', you should be asking about when to use the pattern `[???]', and when to use the pattern `???'
08:52:23 <hiptobecubic> It seems like garbage to me.
08:52:33 <dmwit> theadmin: There isn't one. You need to use recursion.
08:52:34 <srhb> let foo [x,y] = "Two"; foo [x,y,z] = "Three" in foo [1,2,3]
08:52:42 <dmwit> theadmin: Though of course you can use, e.g.
08:52:52 <peteretep> let foo [x] [y] = y
08:53:00 <dmwit> > let foo (head . reverse -> x) = x in foo [1..10]
08:53:02 <lambdabot>   10
08:53:03 <peteretep> That has helped me figure it out
08:53:21 <ski> > let foo ((init &&& last) -> (xs,x)) = (xs,"and",x) in foo [0,1,2,3]
08:53:23 <lambdabot>   ([0,1,2],"and",3)
08:53:31 <theadmin> dmwit: Woah... You can use functions inside patterns? That's new to me.
08:53:43 <ski> theadmin : this is a language extension, `ViewPatterns'
08:54:01 <ski> @type init &&& last
08:54:03 <lambdabot> forall a. [a] -> ([a], a)
08:54:06 <dmwit> theadmin: Sort of. That translates to "let foo x_ = case (head . reverse) x_ of x -> x in foo [1,2,3]".
08:54:18 <dmwit> theadmin: You'll notice that the translated version still doesn't use functions in any patterns.
08:55:02 <dmwit> theadmin: (Also, that translation isn't quite right, but you get the idea of how it could be implemented without using functions in patterns, I hope.)
08:55:12 <ski> peteretep : great
08:55:25 <rwbarton> peteretep: what do you think "let foo [x] [y] = y" does?
08:55:34 <rwbarton> Just to double-check.
08:56:05 <peteretep> rwbarton: (foo [3] [4]) returns 4
08:56:18 <rwbarton> Okay good.
08:56:34 <peteretep> I am now trying to construct the same thing using ()
08:56:38 <rwbarton> and if either the first or second list doesn't have exactly one element, it doesn't match right?
08:56:44 <rwbarton> there is no "using ()"
08:56:56 <dmwit> rwbarton: He means using parentheses instead of square brackets.
08:56:57 <rwbarton> but, you mean without the [x] syntactic sugar
08:57:00 <peteretep> let foo (x:y) = head head y
08:57:04 <peteretep> (doesn't work)
08:57:05 <srhb> You cannot do it without paranthesis though
08:57:10 <dmwit> I don't think he means using unit. =)
08:57:14 <rwbarton> no, I know
08:57:14 <srhb> peteretep: foo (x:[]) (y:[]) = y
08:57:22 <rwbarton> ...
08:57:31 <dmwit> srhb: challenge accepted!
08:57:50 <dmwit> foo x_ y_ = case x_ of x:[] -> case y_ of y:[] -> y
08:57:54 <dmwit> no parentheses =)
08:58:00 <srhb> dmwit: :D
08:58:04 <ion> FSVO “it”
08:58:20 <theadmin> Is there some "compiler instruction" or whatever that I can use inside the source-code to enable a language extension?
08:58:29 <ion> {-# LANGUAGE foo #-}
08:58:32 <dmwit> {-# LANGUAGE ViewPatterns #-}
08:58:33 * peteretep has a "Functional Programming with Haskell" course coming up and is trying to learn as much Haskell first as possible
08:58:48 <theadmin> ...That looks much like a comment to me
08:58:49 <rwbarton> > let infixl 1 `foo`; x:[] `foo` y:[] = y in foo [3] [4]
08:58:50 <lambdabot>   4
08:58:57 <dmwit> theadmin: It is a comment, yes.
08:59:12 <Eduard_Munteanu> peteretep: so you can be mr Smart Guy in the class? :D
08:59:31 <dmwit> theadmin: Also, it probably has to appear in your file somewhere special. I don't know the exact rule, but putting it as the very first thing in the file will satisfy the rule, whatever it is.
08:59:34 <peteretep> Eduard_Munteanu: Because I have the concentration span of a gnat, so it's important I know the material
08:59:39 <theadmin> dmwit: Well, technically it's not... Comments are things ignored by the compiler :P
08:59:59 <dmwit> theadmin: If that's how you define comment, I suppose.
09:00:07 <schlicht_> i have code that use the State Int monad, and there the liftM function. now i want to change that code to WriterT String State Int. What do i do with liftM? Or where can i learn to understand what should be done?
09:00:38 <nand`> {-# #-} isn't a comment I thought, it's a compiler pragma
09:00:52 <dmwit> Define comment.
09:01:02 <rwbarton> It is a comment that happens to tell the compiler "pssst, wouldn't it be cool if I could use view patterns in this file"
09:01:08 <srhb> peteretep: Anyway, though I'm scared that dmwit will kill me for saying anything definitive now, I think you can see that x:[] is the same as [x] now -- the one element list, ie. one element consed onto the empty list
09:01:11 <srhb> :-)
09:01:19 <hpc> it's a comment in the same way haddock -- | is a comment
09:01:28 <theadmin> dmwit: How do *you* define a comment?
09:01:31 <peteretep> srhb: Yes, thankyou
09:01:43 * peteretep isn't quite done understanding, but is playing around in ghci a bit
09:01:45 <dmwit> theadmin: It's the syntactic category accepted by a particular non-terminal in the language grammar...
09:01:59 <theadmin> dmwit: Well... that's very vague.
09:02:00 <ski> dmwit : "if you change the contents of a comment, the semantics are unaffected" ?
09:02:04 <rwbarton> vague???
09:02:22 <srhb> peteretep: That's really the way to go. :)
09:02:23 <parcs`> schlicht_: lift
09:02:26 <nand`> dmwit: oh, let me correct myself. {-# #-} is indeed a comment
09:02:35 <dmwit> theadmin: I can look up the specific nonterminal in the report if you want, I guess.
09:02:38 <rwbarton> hint, he is talking about the 'comment' non-terminal
09:02:43 <nand`> as per http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-170002.3
09:02:48 <rwbarton> or actually the ncomment non-terminal
09:02:50 <parcs`> :t lift (modify succ :: State Int ()) :: WriterT String (State Int) () -- schlicht_
09:02:51 <lambdabot> WriterT String (State Int) ()
09:02:55 <theadmin> Anyway, I'm off
09:02:55 * ski thinks it would be better if `{-# ... #-}' and `-- | ...' weren't comments ..
09:03:09 <dmwit> ski: And don't forget -- ^ =)
09:03:10 <nand`> “No legal lexeme starts with “{-”; hence, for example, “{---” starts a nested comment despite the trailing dashes.”
09:03:16 <nand`> I assume the same applies to “{-#”
09:03:26 <ski> dmwit : is that Haddock, too ?
09:03:33 <hpc> ski: yes
09:03:40 <hpc> -- | before haddock
09:03:44 <hpc> -- ^ after haddock
09:03:48 <hpc> i think
09:03:55 <dmwit> yes, exactly right
09:06:03 <nand`> oh, the report even explicitly states that {-# are comments. “Nested comments are also used for compiler pragmas, as explained in Chapter 12.”
09:06:28 <peteretep> http://pastebin.com/TN0WgcC9
09:06:29 <mauke> The paste TN0WgcC9 has been copied to http://hpaste.org/70038
09:06:30 <peteretep> This makes it all clear
09:06:33 <parcs`> actually not all things starting with {-# are comments
09:06:41 <parcs`> > {-# RULES a #-} ()
09:06:42 <lambdabot>   <no location info>: parse error on input `{-# RULES'
09:07:01 <rwbarton> > {- RULES a -} ()
09:07:02 <lambdabot>   ()
09:07:10 <rwbarton> interesting
09:07:21 <parcs`> > {-# INLINE #-} () -- etc
09:07:22 <lambdabot>   <no location info>: parse error on input `{-# INLINE'
09:07:23 <rwbarton> > {-# XYZZY #-} ()
09:07:24 <lambdabot>   ()
09:07:46 <rwbarton> so those are pragmas it understands but are malformed
09:07:46 <nand`> they're still “comments” as defined by the haskell report. They just aren't ignored by the compiler, I suppose
09:07:50 <ion> That’s only GHC’s opinion, though. It’s not authoritative.
09:08:14 <hpc> this is making me see the logic behind simon's law
09:08:25 <srhb> peteretep: Now you should try different patterns in one function and see how they can be useful as a control structure. :)
09:08:33 <hpc> that if X time is spent discussing syntax
09:08:52 <hpc> 2X time is spent discussing syntax
09:09:01 <hpc> ditto for lexical syntax, then lexical syntax of comments
09:09:03 <peteretep> srhb: Now is when I go through my flashcards and nuke all the ones I wrote before I understood it
09:09:20 <srhb> peteretep: Ambitious! :-)
09:09:46 <nand`> hpc: clearly, the implication of this law is that “no time is spent discussing syntax”
09:09:49 * nand` scratches head
09:10:06 <rwbarton> simon wadler
09:10:08 <hpc> heh
09:10:20 <rwbarton> i guess he can be an honorary simon
09:10:21 <ski> well, `2 * |N' is isomorphic to `|N'
09:11:13 <ski> (maybe ordinals would be more appropriate with time ?)
09:11:23 <peteretep> Next up: removing all the Flash cards that express things in Z-Notation and ask for a translation to Haskell
09:22:08 <peteretep> Guys, thanks again for all your help. I have it down pat now, and understand it a lot better
09:25:17 <JoeyA> > (let g !(~(x:xs)) = "cons"; g [] = "nil" in g) [1]
09:25:18 <lambdabot>   "cons"
09:27:34 <lamefun3> hello
09:27:44 <lamefun3> is it possible to use Haskell as a scripting language?
09:27:49 <hpc> yes
09:27:50 <lamefun3> with sandbox
09:27:53 <nand`> define “scripting language”
09:27:57 <Eduard_Munteanu> Sandbox?
09:28:18 <Ke> shebang
09:28:31 <mikeplus64> lamefun3: mostly people use #!/bin/runhaskell (but there is also runghc)
09:28:34 <lamefun3> something I can distribute in a platform-independent way (sources included) and execute in an environment in which it can't interact with the system beyond I allow
09:28:42 <c_wraith> > 1 + 1
09:28:43 <lambdabot>   2
09:28:52 <srhb> lamefun3: That's usually a product of the executing user's privileges though
09:28:56 <lamefun3> and embed in a normal Haskell application
09:28:59 <c_wraith> lambdabot uses mueval, which is a package for sandboxing execution
09:29:11 <lamefun3> I want the priviligies LOWER than user privileges
09:29:31 <hpc> mueval sandboxes by disallowing execution entirely
09:29:36 <nand`> maybe you can do something like what mueval does where you disallow IO ()
09:29:53 <nand`> this would allow the user to evaluate arbitrary haskell without any real world interaction
09:29:56 <nand`> disallow IO *
09:30:52 <JoeyA> > (let g !(~(x:xs)) = "cons"; g [] = "nil" in g) []
09:30:54 <lambdabot>   "nil"
09:31:14 <lamefun3> Well, I actually want to allow some IO
09:31:34 <mikeplus64> lamefun3: as far as shell scripting goes, you can use shelly, or just any normal haskell app chmod +x'd and with #!/bin/runhaskell or #!/bin/runghc at the top
09:32:10 <mikeplus64> lamefun3: runghc for if you want the script to be optimized to the extent that ghc would normally do it, runhaskell for unoptimized interpreting
09:32:25 <lamefun3> Can I embed it like lua?
09:32:30 <mikeplus64> what do you mean?
09:32:40 <mikeplus64> i don't have much experience in lua
09:32:56 <c_wraith> you can embed haskell in C, but it's way more work than lua, since it wasn't really designed for it
09:32:56 <lamefun3> or, like JavaScript
09:33:11 <rwbarton> > (let g (~(x:xs)) = "cons"; g [] = "nil" in g) []
09:33:12 <lamefun3> I want to embed Haskell in a Haskell app.
09:33:12 <lambdabot>   "cons"
09:33:14 <lamefun3> as Lua
09:33:20 <lamefun3> *like lua
09:33:44 <mikeplus64> lamefun3: well the way we do that normally is just by writing it normally?
09:33:45 <srhb> Doesn't Yi do something like that?
09:33:57 <lamefun3> app should load Haskell modules dynamically and execute them in a safe environment
09:34:03 <lamefun3> The problem is I want to execute untrusted code.
09:34:27 <c_wraith> you can do it with a combination of safe haskell and the ghc api...
09:34:40 <mikeplus64> that's more a problem for your actual setup if you're allowing IO
09:34:41 <c_wraith> But it's a good chunk of work, and I don't think anyone's done it so far.
09:35:00 <mikeplus64> lamefun3: look at the package hint, it can do what you want i think
09:35:03 <c_wraith> mikeplus64: you need to disallow unsafePerformIO, too, which means you need safe haskell
09:35:59 <mikeplus64> c_wraith: i'm not sure if lamefun3 means safe as in safe haskell or safe as in "the user can't delete the other user's stuff"
09:36:16 <hpc> can't you just make another user with no permissions to anything at all?
09:36:18 <c_wraith> mikeplus64: safe haskell is a pre-requisite for the other
09:36:23 <lamefun3> uhm
09:36:34 <hpc> then run untrusted code as that user using your favorite method
09:36:41 <lamefun3> I want to allow untrusted modules to open and write files, but only in one specific directory
09:36:43 <c_wraith> mikeplus64: if you allow running user code with its own imports, you need to prevent it from importing unsafePerformIO
09:36:58 <srhb> lamefun3: So you make a dummy user with only permission for that directory..
09:37:00 <mikeplus64> c_wraith: unsafePerformIO doesn't magically sidestep operating systems i mean
09:37:57 <lamefun3> I also want to make my app user-friendly (it shouldn't make it necessary to reconfigure system).
09:38:20 <lamefun3> Browser, for example, securely executes JavaScript without the need to create a separate user for each web page.
09:38:45 <c_wraith> lamefun3: so, I've mentioned three or four times how to do it...
09:38:47 <hpc> browsers do it by writing their own js interpreter
09:39:28 <lamefun3> Is there a Haskell interpreter?
09:39:35 <mikeplus64> lamefun3: runhaskell, ghci
09:39:40 <c_wraith> the ghc api
09:39:51 <lamefun3> an embeddable Haskell interpreter?
09:39:55 <c_wraith> the ghc api
09:40:03 <geekosaur> is this another case where $user believes haskell is a VM technology as opposed to a programming language?
09:40:33 <c_wraith> it's certainly another case where I keep answering the question and getting ignored
09:41:05 <hpc> @faq can haskell synchronize web-scale virtual cloud social web ajax?
09:41:06 <lambdabot> The answer is: Yes! Haskell can do that.
09:41:40 <hiptobecubic> @faq can haskell?
09:41:41 <lambdabot> The answer is: Yes! Haskell can do that.
09:41:56 <hiptobecubic> There. Solved for the general case.
09:41:56 <hpc> @faq glub glub glub
09:41:57 <lambdabot> The answer is: Yes! Haskell can do that.
09:41:57 <c_wraith> lamefun3: the tools to do what you want exist.  However, there's no easy packaging for the combination you want, and it'll require learning a lot about the primitives to build up the system.
09:42:32 <hpc> lamefun3: if you can come up with an easy packaging, you should put it on hackage
09:42:36 <hiptobecubic> run v8 with a javascript interpreter
09:42:59 <lamefun3> no point
09:42:59 <hpc> hiptobecubic: and ghc -> llvm -> js? XD
09:43:25 <lamefun3> I intend the part that runs with user privileges be just a script loader
09:43:29 <nand`> lamefun3: browsers don't allow arbitrary system IO (other than their constrained ajax interface etc.)
09:43:54 <srhb> nand`: He stated exactly that earlier :-)
09:43:55 <luite> hpc: that doesn't actually work though
09:44:20 <nand`> srhb: yes, but in protest of manipulating user accounts and permissions
09:44:20 <luite> hpc: not sure if it's just more of the rts that needs to be supported, or a limitation of emscripten
09:44:50 <mikeplus64> lamefun3: you could create a chroot for the program to run in (but chroots are bad as security devices)
09:45:34 <srhb> I kind of think extending hint would be cool here.
09:45:56 <nand`> what I would probably do is disallow IO entirely, then make your own analog to it that only allows certain methods of IO
09:46:00 <srhb> Yes.
09:46:18 <c_wraith> nand`: you still need to integrate with safe haskell to prevent unsafePerformIO tricks.  That's the new part.
09:46:32 <nand`> c_wraith: indeed; but it solves his problem of “but I want to allow some IO”
09:46:37 <mikeplus64> hint can definitely do it, but the question is making it somehow sandboxed /without/ just using the operating system's sandboxing capabilities
09:47:09 <nand`> hint looks incredibly interesting, I've never seen it before
09:47:11 <c_wraith> mikeplus64: hint can't really do it without integrating safe haskell - and I'm pretty sure that's some deep modifications
09:47:33 <mikeplus64> c_wraith: why does it require safe haskell?
09:47:43 <nand`> from what I figure: hint basically does what he wants, but allows arbitrary execution?
09:47:50 <c_wraith> mikeplus64: .... to prevent importing modules unsafePerformIO
09:47:58 <mikeplus64> nand`: only with what you import
09:48:04 <nand`> mikeplus64: I see
09:48:25 <c_wraith> nand`: hint allows you to constrain the type of the expression you evaluate.  With unsafePerformIO prevented, that gives you a sandbox.
09:48:28 <mikeplus64> c_wraith: it could interpret the file and hack out System.Unsafe.IO ;)
09:49:06 <hpc> i think you can also whitelist modules
09:49:07 <mikeplus64> i mean System.IO.Unsafe
09:49:20 <nand`> personally, I'm not too concerned about files executing arbitrary code; it should be the user's responsibility not to shoot himself in the foot
09:49:32 <nand`> (by adding a malicious module)
09:49:40 <mikeplus64> c_wraith: ie map (\l -> if "System.IO.Unsafe" `isInfixOf` l then "" else l) . lines
09:50:01 <mikeplus64> that's one way to herp up code trying to import it anyway
09:50:19 <c_wraith> mikeplus64: that...  doesn't work at all in practice.  You can't blacklist every module that exports it.
09:50:30 <c_wraith> because that's not a finite list
09:50:47 <mikeplus64> c_wraith: i tried :(
09:50:48 <mikeplus64> lol
09:51:13 <c_wraith> safe haskell, on the other hand, is *designed* to prevent importing it.  that's the entire *point* of safe haskell
09:51:38 <hpc> and it succeeds until a package lies about safety
09:52:00 <mikeplus64> there is getLoadedModules
09:52:02 <c_wraith> as long as you don't install a package that lies, you're fine.
09:52:06 <srhb> ie. mysteriousButTotallySafePerformIOWinkWink
09:53:46 <KirinDave> I'm all for the positive Erlang results here
09:53:47 <KirinDave> But
09:53:49 <KirinDave> https://github.com/ericmoritz/wsdemo/blob/results-v1/results.md
09:53:57 <KirinDave> I'm surprised Haskell did it so poorly
09:56:19 <c_wraith> and by "so poorly", you mean "better than everything except erlang" :P.  But yeah, the GHC runtime isn't optimized for that case, and it shows.
09:56:45 <Joe__> map (\xs -> negate (sum (tail xs))) [[1..5],[3..6],[1..7]]..........................Hi guys can somebody expain me how does it works this function after sum(tail xs) ?
09:56:47 <KirinDave> c_wraith: Go did pretty good.
09:56:54 <KirinDave> c_wraith: Actually, I suspect it is Snap
09:58:09 <taylorgb_> Not bad for 2 lines of code though
09:58:29 <Joe__> anybody ?
09:58:31 <KirinDave> c_wraith: Because I've had haskell processes doing 10k connections simultaneously before.
09:58:34 <KirinDave> taylorgb_: Indeed.
09:58:45 <KirinDave> taylorgb_: Were it truly 2 lines and not a call into a massive library ;)
09:59:05 <srhb> Joe__: Er, it takes the sum of every list in the list except for the first 1 in each, and then negates each.
09:59:27 <srhb> Joe__: except for the first number* in each
09:59:43 <nand`> imo the Haskell code is undoubtedly the cleanest / easiest to understand: “acceptRequest req >> forever (receive >>= send)” is very clear in its semantics
10:00:37 <Joe__> Thank you very much ....and btw how i can mark that i answer you on the screen ???
10:01:11 <KirinDave> nand`: Without a doubt, the haskell is great.
10:01:18 <taylorgb_> I always find these kinds of comparisons lacking in value, as the implementations are rarely of the same quality. Depending on the implementors knowledge of the language and libraries involved you're like to get different results
10:01:46 <nand`> I would be far more interested in a comparison pitting snap against other haskell web frameworks like yesod and happstack
10:01:56 <nand`> because as far as I'm concerned the other languages aren't worth comparing to :P
10:02:03 <KirinDave> I would like to see someone who can post code of haskell doing 10k concurrent tcp connections.
10:02:07 <nand`> (except erlang, obviously)
10:02:09 <KirinDave> I have code that does this
10:02:12 <KirinDave> But I cannot publish it.
10:02:23 <KirinDave> 10k concurrent echo server, anyone?
10:03:28 <mikeplus64> KirinDave: wasn't there mighttpd or something?
10:03:43 <KirinDave> mikeplus64: Don't even need http
10:03:45 <KirinDave> Just echo server
10:05:15 <hpc> i have an echo server that might work, but not the hardware to test
10:05:17 <hpc> lemme hpaste
10:05:51 <hpc> http://hpaste.org/70039
10:06:17 <hpc> probably need to remove some of the debugging stuff
10:06:46 <hpc> it's different from a regular echo server in that it has separate in and out connections, and everything from inputs is replicated to all outputs
10:07:30 <merijn> KirinDave: Doesn't warp do this?
10:07:59 <merijn> I thought I saw some benchmarks about the Warp http-server serving something like up to 10k-100k connections?
10:08:17 <KirinDave> merijn: I dunno
10:08:20 <nand`> benchmark this: http://paste.lugons.org/show/2194/
10:08:24 <nand`> I want to see how awful it is
10:08:31 <nand`> for all its simplicity
10:08:54 <luite> hm, i think that was requests per second, the number of connections was lower
10:33:33 <navaati> hi
10:34:03 <navaati> i can't find a way to create symlinks in System.IO or in System.Directory, where is it hidden ?
10:35:10 <fmap> System.Posix.Files
10:35:11 <fmap> ?
10:36:15 <navaati> …
10:36:38 <mcstar> afaik there should be a function in Data.List that takes an item and a list, and returns a list of other lists with the item inserted in every position
10:36:40 <navaati> i forgot that windows has no symlink, and thus that it can't be in standard functions…
10:36:44 <navaati> thanks
10:36:53 <mcstar> with that, permutations would look much nicer, and be a tad faster
10:37:26 <mcstar> thats afaic not afaik
10:38:01 <james-ubyssey> why is it that Just 3  >> Just 7 will return 7 but Nothing >> Just 7 will return nothing?
10:38:18 <mcstar> thats how monad is deined for Maybe
10:38:21 <mcstar> f
10:38:35 <james-ubyssey> wtf
10:38:40 <merijn> james-ubyssey: Because "x >> f" equals "x >>= \_ -> f"
10:38:41 <james-ubyssey> but it says on the doc that
10:38:49 <james-ubyssey> it iscards the first value
10:38:50 <mcstar> navaati: i heard these new windowses have real symlinks
10:39:06 <merijn> And "Nothing >>= f" will always return Nothing, regardless of f
10:39:11 <mcstar> or is it windii?
10:39:17 <KirinDave> james-ubyssey: That's what the maybe monad is for, man.
10:39:20 <navaati> yeah, heard that too. but with XP still being around…
10:39:32 <KirinDave> james-ubyssey: It chains forward results unless you hit a nothing, then the entire sequence goes to Nothing.
10:39:34 <james-ubyssey> im so mindblown right now...
10:39:43 <merijn> > Just 5 >>= (+1)
10:39:45 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
10:39:45 <lambdabot>    arising from a use of...
10:39:50 <ski> james-ubyssey : `Nothing' is a "failing computation", so it aborts the whole computation, not doing the rest -- this is the point of the `Maybe' monad
10:39:53 <merijn> > Just 5 >>= return . (+1)
10:39:55 <lambdabot>   Just 6
10:39:56 <rwbarton> what says on what doc
10:40:01 <Adeon> >> discards the encapsulated value in the Maybe monad but not the computation
10:40:40 <KirinDave> james-ubyssey: This stuff is a whole different discipline from the traditional programming most people use. If it seems crazy to start, that's really okay.
10:40:41 <Adeon> if you have  x >>= \y -> f then y would be the value, not the computation
10:40:49 <KirinDave> james-ubyssey: Just give it time.
10:41:06 <ski> james-ubyssey : the point of `ma >>= amb' is to pass on the value (if any) from `ma' to `amb' -- in this case `ma' was `Nothing', so it contained no value -- there's nothing to pass on
10:41:17 <james-ubyssey> Sequentially compose two actions, discarding any value produced by the first
10:41:28 <mcstar> you discard with >>
10:41:29 <KirinDave> Except that in some cases
10:41:35 <mcstar> if you dont want that use >>=
10:41:40 <KirinDave> Things persist across >> :)
10:41:45 <KirinDave> Like using State
10:41:47 <james-ubyssey> so uh why does the nothing matter... disnt discard mean that it just evaluates the first and does nothing?!?!
10:41:54 <ski> james-ubyssey : and 'ma >> mb' is the same as `ma >>= \_ -> mb', so here it would pass on a value, only to discard it -- but there still has to exist a value to pass on, even if it's discarded
10:42:01 <mcstar> but as was said earlier, you want Nothing if you encountered Nothing in the chain
10:42:09 <KirinDave> james-ubyssey: My advice is to look at the definition of the monad instance for Maybe.
10:42:16 <KirinDave> james-ubyssey: Why it does that becomes crystal clear.
10:42:24 <merijn> @src Maybe >>=
10:42:24 <aristid> @src Monad Maybe
10:42:24 <lambdabot> Source not found. That's something I cannot allow to happen.
10:42:24 <lambdabot> Source not found. I feel much better now.
10:42:25 <ski> james-ubyssey : think of `Nothing' as representing "exception raised" -- meaning that something wen't wrong, we don't want to continue the computation
10:42:37 <ski> @src Maybe (>>=)
10:42:37 <lambdabot> (Just x) >>= k      = k x
10:42:38 <lambdabot> Nothing  >>= _      = Nothing
10:42:38 <aristid> @src >>= Maybe
10:42:38 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
10:42:43 <KirinDave> james-ubyssey: Do you know any other programming languages?
10:42:45 <aristid> ski: dammit
10:42:58 <aristid> @src (>>)
10:42:58 <lambdabot> m >> k      = m >>= \_ -> k
10:43:14 <james-ubyssey> KirinDave: just a bit of scheme and c
10:43:24 <james-ubyssey> * racket
10:43:31 <KirinDave> james-ubyssey: Well then. I have no familiar and slightly incorrect analogies to offer you.
10:43:40 <mcstar> XD
10:43:41 <james-ubyssey> lol
10:44:05 <nand`> james-ubyssey: (>>) doesn't ignore the first computation; it just ignores the value it extracted from it
10:44:18 <nand`> think of a >> b like a >>= \_ -> b
10:44:32 <KirinDave> But, consider that Nothing >>= \x -> return (x + 1)  has no sensible way forward. And >> and >>= are related.
10:44:38 <aristid> thinking of it that way makes sense, because that's how it's defined
10:44:45 <mcstar> anyway, what about my idea to extend Data.List ?
10:44:45 <rwbarton> there are really two questions here -- why is Nothing >> Just 7 equal to Nothing given the way the Monad Maybe instance is defined, and why is it defined that way in the first place
10:44:48 <ski> james-ubyssey : consider `(let ((x 0)) (begin (set! x (+ x 1)) x))' in Scheme, here `begin' is comparable to `>>'
10:44:58 <james-ubyssey> okay so basically >> is just a synonym for  >> \_ ->
10:44:59 <james-ubyssey> ?
10:45:06 <nand`> james-ubyssey: correct
10:45:08 <KirinDave> Yeah.
10:45:08 <nand`> well
10:45:10 <nand`> >>=
10:45:14 <ski> james-ubyssey : note that the *effect* of `(set! x (+ x 1))' isn't discarded, even though the *result value* of it *is* discarded
10:45:14 <james-ubyssey> yeah
10:45:23 <nand`> james-ubyssey: but some monads have specific implementations that are more optimized
10:45:26 <nand`> but that's the default, yeah
10:45:40 <ski> james-ubyssey : in the case of `Nothing >> ...', the *effect* of `Nothing' is to abort the computation, i.e. to *not* carry on with the `...'
10:46:07 <james-ubyssey> ehh damn
10:46:13 <ski> james-ubyssey : also, this is really the point of having the `Maybe' monad : to have a nice way to abort computations if some sub-computation fail
10:46:46 <james-ubyssey> okay that makes sense
10:46:49 <nand`> there's also the “Either e” monad, which lets you fail with arbitrary error values
10:46:50 <james-ubyssey> sort of ...
10:46:55 <nand`> incidentally, “Either ()” is isomorphic to “Maybe”
10:47:57 <james-ubyssey> alrighty thanks
10:48:27 <nand`> > let a // 0 = Left "divide by zero"; a // b = Right (a/b) in zipWith (//) [1, 3, 5, 4] [5, 3, 0, 8]
10:48:28 <lambdabot>   [Right 0.2,Right 1.0,Left "divide by zero",Right 0.5]
10:48:49 <rwbarton> your question is sort of like asking about foo() { 4; return 7; } vs. foo() { throw SomeKindOfException; return 7; }
10:48:54 <singpolyma> https://github.com/ericmoritz/wsdemo/blob/results-v1/results.md
10:49:03 <ski> james-ubyssey : did you see <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>, btw ?
10:49:07 <KirinDave> Hahah
10:49:09 <KirinDave> singpolyma
10:49:16 <KirinDave> just "throwing it out there"
10:49:26 <rwbarton> hit and run
10:49:27 <KirinDave> In the parlance of the internet, "Imma just leave this here."
10:50:17 <ski> (rwbarton : except there's no exceptions in standard C and Scheme ..)
10:50:36 <james-ubyssey> ski:  nope, i'll check it out now
10:50:40 <rwbarton> yeah
10:51:01 <rwbarton> really, scheme doesn't have a built-in exception system?
10:51:04 <ski> > let a // 0 = Left ("divide by zero : " ++ show a); a // b = Right (a/b) in zipWithM (//) [1, 3, 5, 4] [5, 3, 0, 8]
10:51:06 <lambdabot>   Left "divide by zero : 5.0"
10:51:12 <KirinDave> Racket does
10:51:19 <ski> rwbarton : most implementations do have, but R5RS doesn't
10:51:26 <rwbarton> I see
10:51:44 <KirinDave> ski: Isn't R6RS the target now?
10:51:53 <ski> (and i think R6RS do have, as well, but it's a controversial report)
10:52:05 <KirinDave> And http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-15.html#node_sec_A.5
10:52:16 <ski> KirinDave : R7RS is currently in the works (mostly/partly as a reaction against R6RS)
10:52:42 <KirinDave> I miss the world of Scheme politics.
10:52:46 <KirinDave> So refreshingly pure
10:52:50 <nand`> rwbarton: except that would be more analogous to do { error "SomeKindOfException"; return 7 }  :P
10:53:08 <rwbarton> yes clearly that is the best way to explain
10:53:30 <ski> nand` : which isn't a bad analogy (except that you can't catch `error' outside `IO', but that feature wasn't examplified above)
10:53:46 <rwbarton> replace the thing he is trying to understand with something else entirely then form an analogy
10:53:56 <nand`> (I'm not particularly fond of explaining Maybe with exceptions, mind)
10:54:06 <ski> why not ?
10:54:33 <ski> do you prefer thinking of them as nondeterministic computations, with at most one solution ?
10:55:31 <nand`> I prefer thinking of them as.. well.. nullable values; and disregarding the “computation” analogy in favor of just taking (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b  at its face value
10:55:56 <nand`> to me, “failable computations” is one specific *application* of the maybe monad
10:55:57 <rwbarton> that's all well and good until you want to explain *why* (>>=) is defined the way it is :P
10:56:06 <rwbarton> which, I think, was the question
10:56:22 <monochrom> I think of Maybe as Nothing | Just a
10:56:23 <nand`> rwbarton: isn't it the only sensible definition? or do you mean (>>=) in general
10:56:23 <mcstar> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/src/Data-List.html#permutations vs. http://hpaste.org/70027
10:56:42 <nand`> (non-sensible here including: undefined, _|_, coerce, etc.)
10:56:58 <rwbarton> I don't think "the only sensible definition" would have been a terribly satisfying answer either
10:57:21 <rwbarton> for one thing you have to check that it is indeed sensible
10:57:57 <nand`> monad laws should cover that; I suppose
10:58:16 <nand`> x >>= return = x -- rules out stuff like _ >>= _ = Nothing
10:58:47 <nand`> but I'll agree, it's not a particularly sexy way of explaining the Maybe monad
10:58:54 <nand`> that doesn't mean I like the exception analogy
10:59:00 <ski> nand` : hm, "nullable value" breaks down with `Maybe (Maybe Foo)' (domain contagion and all that)
10:59:57 <nand`> ski: oh, I meant the analogy as Maybe a = NULL | Just a
11:00:05 <ski> yes, i know
11:00:12 <nand`> but yeah, I see your point
11:00:37 <nand`> there's also the issue of strictness, matching on (Just _) is different from matching on _ but doesn't force the value to be computed
11:00:59 <ski> (for "domain contagion" see the "2006-02-03 Option types, optional parameters" entry at <http://mumble.net/~campbell/blag.txt>)
11:01:17 <KirinDave> So dons points out http://www.yesodweb.com/blog/2011/03/preliminary-warp-cross-language-benchmarks
11:01:26 <KirinDave> Which suggests that it's jut Snap's relatively new websocket server.
11:05:40 <nand`> KirinDave: do test yesod/warp some time
11:05:43 <nand`> I'd be very interested
11:06:01 <KirinDave> nand`: Maybe later. I have husband time now.
11:06:06 <KirinDave> Taking wife to farmer's market, etc.
11:14:08 <mcstar> i take it theres no great need for that function then
11:14:20 <mcstar> but what would it be called?
11:21:13 <teslaH> is there anything equivalent to the following in the standard library?   check :: (a -> Bool) -> a -> Maybe a        check p v | p v = Just v         check _ _ =Nothing
11:21:42 <hpc> :t guard
11:21:43 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
11:21:56 <hpc> check f a = do
11:21:59 <hpc>   guard f a
11:22:00 <hpc>   return a
11:22:07 <HairyDude> @hoogle (a -> Bool) -> a -> Maybe a
11:22:08 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:22:08 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
11:22:08 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
11:22:29 <HairyDude> @hoogle Monad m => (a -> Bool) -> a -> m ()
11:22:30 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
11:22:30 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
11:22:30 <lambdabot> Foreign.Marshal.Error throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()
11:22:57 <monochrom> no, I think it is not in the standard library
11:23:00 * hackagebot cgen 0.0.5 - generates Haskell bindings and C wrappers for C++ libraries  http://hackage.haskell.org/package/cgen-0.0.5 (AnttiSalonen)
11:23:31 <ion> @type \f a -> a <$ guard f a  -- Double typeclass dependency :-(
11:23:32 <lambdabot>     Couldn't match expected type `f b' against inferred type `()'
11:23:32 <lambdabot>     In the second argument of `(<$)', namely `guard f a'
11:23:33 <lambdabot>     In the expression: a <$ guard f a
11:23:45 <ion> @type \f a -> a <$ guard (f a)
11:23:47 <lambdabot> forall a (f :: * -> *). (MonadPlus f, Functor f) => (a -> Bool) -> a -> f a
11:24:27 <ski> `liftM . const'
11:24:33 <ion> yeah
11:25:07 <ion> But that’s not really more concise than do …; return a
11:28:42 <mcstar> were the exports of standard modules decided for eternity?
11:29:25 <geekosaur> no, but there are procedures for making changes to them
11:30:13 <geekosaur> well, for the specific language standards they are "for eternity" but you don't generally force h'98 or h'2010 mode
11:30:33 <Minoru> edwardk is amazing: I have an idea about blog post, I google it and it turns out that he wrote that post two years ago
11:31:57 <hpc> what was the post?
11:33:00 <Minoru> sorry, I means ezyang, not edwardk.
11:33:33 <Minoru> hpc: OOP Design Patterns viewed from the functional programming point of view
11:33:42 <hpc> ooh
11:34:21 <hpc> http://blog.ezyang.com/2010/05/design-patterns-in-haskel/ -- this i take it?
11:34:43 <Minoru> yep, that one
11:35:08 <yongliang> ohai ppls
11:35:19 <yongliang> Oh, sorry, wrong channel.
11:35:53 <ion> Indeed. No greeting people in here.
11:36:08 <mapreduce> That was an amazing improvement in standard of English.
11:37:04 <srhb> Weird, I tend to prefer ohai. Seems more personally engaged. :<
11:37:42 <mcstar> ohai sounds just like a cat would say hello
11:38:10 <sipa> meeow?
11:38:15 <mcstar> lolcat i.e.
11:38:21 * ski often prefers `ehlo'
11:38:29 <sipa> cat != lolcat
11:38:35 <sipa> ow
11:38:46 <sipa> cat /= lolcat
11:38:50 <mcstar> XD
11:39:04 <aristid> sipa: lolwut
11:39:05 <mcstar> haskell is not in your muscle memory
11:39:20 <ion> ≠
11:39:24 <sipa> too much c++ these days
11:39:28 <zzing> Should there be any problems compiling  ghc 7.4.2 with clang 3.1?
11:40:44 <james-ubyssey> what does base-4.5.0.0 was excluded because of the top level dependency base -any
11:40:46 <james-ubyssey> mean?
11:40:55 <james-ubyssey> i was trying to install examples-gloss
11:41:11 <rwbarton> it means you have the wrong version of GHC for the package you're trying to install
11:41:16 <james-ubyssey> gloss-examples rather
11:42:39 <mcstar> i f'ed up my packages i think, i deleted all the haskell packages except ghc that my distro has to offer
11:43:01 <hpc> apt-get remove them
11:43:02 <hpc> remove ghc
11:43:08 <hpc> then start over?
11:43:30 <mcstar> i just want to adhere to 'only ghc from distro, everything else from cabal' idea
11:44:03 <c_wraith> best to not get ghc from your distro either, with that plan
11:44:08 <ion> mcstar: This may or may not be useful: https://gist.github.com/2815423
11:44:24 <c_wraith> many distros break GHC in some way or another
11:44:43 <ion> or just have an old version
11:44:45 <mcstar> oh
11:44:46 <c_wraith> (debian-based things split it up into tons of packages, for instance)
11:44:49 <mcstar> well, this is arch
11:44:54 <c_wraith> arch should be good
11:45:26 <infame> I actually had problems getting GCH on my linux dist... I don't know why... but it felt ever so much more easy when I did it on my laptop...
11:45:54 <hpc> i downloaded the binary from here
11:45:55 <hpc> @where ghc
11:45:55 <lambdabot> http://haskell.org/ghc
11:46:03 <hpc> then installed all the dependencies with apt
11:46:11 <ski> Minoru : <http://webcache.googleusercontent.com/search?q=cache:afwL5xn7mV8J:http://lambda-the-ultimate.org/node/4256> and <http://programmers.stackexchange.com/questions/89273/where-are-all-the-functional-programming-design-patterns> might be interesting
11:46:24 <ski> (i also find "Abstract Design Patterns for Functional Strategic Programming" by Ralph Lämmel,Joost Visser in 2002-10-05 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.105.4354>)
11:46:39 <hpc> ooh, that SE link is good, if it's what i think it is
11:46:51 <ski> ("SE" ?)
11:47:08 <Minoru> how you guys manage to do cool stuff when there's so much cool things to read? Thanks for links, ski!
11:47:09 <ion> _tack_xchange
11:47:37 <c_wraith> tack xchange.  Hmm.  Do I need different tacks?
11:47:56 <ski> @babel sv en tack
11:47:56 <lambdabot> Plugin `babel' failed with: Error: Language sv not supported
11:48:14 <ski> ("tack" is swedish for "thanks")
11:48:17 <hpc> xchange sounds like a way to swap WMs without restarting X
11:50:47 <slack1256> how do I get a hackage account
11:50:58 <slack1256> the mail I sent is automatically replied
11:51:14 <slack1256> or there is a person that reads them?
11:51:19 <hpc> it's a person
11:51:33 <hpc> it took me a while too, just be patient and maybe resend
11:51:54 <slack1256> oh. yeah I'll wait for a few more days before resend
11:59:31 <LambdaDusk> anyone here knowing about currently maintained FRP libs? I have huge problems using Yampa, I want my monads back
12:02:42 <illissius> LambdaDusk: reactive-banana is the most popular recently, afaik
12:03:20 <LambdaDusk> illissius: Is it dependent on reactive? Because there's no compilable version of reactive
12:03:38 <illissius> LambdaDusk: no, only the name is shared
12:03:52 <LambdaDusk> illissius: Thank you
12:03:57 <illissius> yw
12:04:00 <parcs`> sodium, oto
12:04:02 <parcs`> too
12:06:12 <LambdaDusk> parcs`: You can make any qualitative evaluation of that one?
12:11:27 <parcs`> LambdaDusk: no, but it's worth a look. people who are more experienced with frp than me prefer it over reactive-banana for various reasons
12:12:18 <LambdaDusk> parcs`: I think I'll try the banana-thingy first ,despite the name
12:18:03 * hackagebot hogre 0.1.5 - Haskell binding to a subset of OGRE  http://hackage.haskell.org/package/hogre-0.1.5 (AnttiSalonen)
12:32:43 <augur> is there a reason to use the reader monad for evaluation in an environment instead of the reader applicative?
12:36:13 <kallisti> augur: basically when you want to do something like ask >>= monadicFunction
12:36:20 <kallisti> instead of ask >>= return . f
12:36:25 <kallisti> ...unless I misunderstood the question
12:36:41 <augur> well yes but i mean
12:36:43 <augur> for an evaluator
12:36:49 <augur> is there a case where that's desired?
12:36:57 <LambdaDusk> anyone can tell me what the difference between "subtract" and "(-)" is?
12:37:07 <nand`> LambdaDusk: flipped arguments
12:37:17 <LambdaDusk> oh jeez
12:37:22 <kallisti> augur: not that I can think of off-hand.
12:37:25 <nand`> > 5 - 3
12:37:25 <lambdabot>   2
12:37:27 <nand`> > subtract 3 5
12:37:28 <lambdabot>   2
12:37:42 <kallisti> any reader function will already have access to the environment, making ask >>= f   redundant
12:37:58 <LambdaDusk> nand`: so "subtract 1" === "(- 1)" ?
12:38:08 <geekosaur> but the real point is that it's hard to make a section with (-), because of the conflict with unary (-) (which as a result *also* has issues)
12:38:08 <ski> augur : interpreting a language with dynamic scope^Wextent ?
12:38:09 <hpc> LambdaDusk: yes, except not
12:38:22 <hpc> ideally, that would work, but (- 1) is negative
12:38:26 <hpc> > (- 1)
12:38:27 <lambdabot>   -1
12:38:29 <hpc> :t (- 1)
12:38:31 <lambdabot> forall a. (Num a) => a
12:38:38 <LambdaDusk> oh jeez
12:38:38 <nand`> lambdabot: not quite
12:38:47 <nand`> err
12:38:49 <hpc> hence subtract
12:38:50 <augur> ski: wossat
12:39:00 <nand`> I meant to reply to LambdaDusk, perhaps obviously :P
12:39:20 <mapreduce> @check \x y -> subtract x y == y - x
12:39:22 <lambdabot>   "OK, passed 500 tests."
12:39:33 <nand`> LambdaDusk: that's exactly why “subtract” exists. You can't do map (-1) because -1 is a number (well, you can, but let's ignore Cale for now); but you can do map (subtract 1)
12:39:38 <LambdaDusk> nand`: I get that about once a day in here
12:39:51 <ski> augur : like `[|e e0|] = case [|e|] of Clos f -> f [|e0|]'
12:39:56 <nand`> LambdaDusk: you have the same color as lambdabot in my IRC client. I blame that
12:40:09 <nand`> otherwise I would have picked it up in time to correct
12:40:29 <augur> ski: im not sure i follow
12:40:31 <hpc> i blame.... Cale
12:40:32 <hpc> just for fun
12:40:35 <LambdaDusk> nand`, hpc: Thanks for clarifying that
12:40:41 <nand`> actually, I'm not sure if Cale is the one to blame
12:40:52 <nand`> didn't conal + some other funny jokers come up with the Num instance for functions?
12:41:00 <hpc> it's from vector-space
12:41:06 <nand`> I thought it was NumInstances
12:41:57 <hpc> er, probably not vector-space, unless i suck at reading docs
12:41:58 <nand`> http://hackage.haskell.org/package/NumInstances in particular
12:42:03 <ski> augur : so that `[|(\f. (\x. f 5) 4) ((\x. \y. x + y) 3)|]' evaluates to `Int 9' instead of `Int 8'
12:42:33 <augur> ski: oh oh dynamic scope instead of lexical scope
12:42:36 <augur> well
12:42:40 <augur> honestly, who wants that
12:44:30 <ski> augur : i think a language with staged evaluation and a `run'/`eval' primitive can also qualify (at least if we can call it on open expressions)
12:45:03 <mcstar> im getting a headache form translating some nested lets from ocaml to haskell :S
12:45:13 <ski> which ?
12:45:44 <hpc> mcstar: i think there's a naive translation to ST
12:45:52 <edwardk> preflex: xseen byorgey
12:45:52 <preflex>  byorgey was last seen on freenode/#haskell 5 hours, 25 minutes and 35 seconds ago, saying: if you're just writing a bunch of text to the screen, or to a file, turning off buffering slows things down a lot
12:47:19 <mcstar> hpc: oh, ive got to see this through, im just commenting on its subjective unreadability
12:48:17 <hpc> heh
12:54:37 <HairyDude> when using :m in ghci, is it possible to rename the module like 'qualified'?
12:55:14 <fmap> you can use `import qualified' directly
12:55:29 <hpc> ooh, neat
12:55:55 <hpc> used to be, you generally wanted to assume that if you wanted your imports done right, put them in a file and load that
12:57:35 <roconnor> @djinn a -> (a,a)
12:57:36 <lambdabot> f a = (a, a)
12:57:47 <conal> nand`: (catching up) yes, i defined a few Num (etc) instances, including for functions, in NumInstances. Used to be in vector-space, but i factored it out. the function instance is a special case of a general pattern for applicative functors.
13:03:01 <hpc> conal: you should devise an applicative transformer with constraint kinds
13:03:15 <hpaste_> HairyDude pasted “xmonad.hs” at http://hpaste.org/70042
13:03:25 <HairyDude> woops, wrong channel
13:04:09 <conal> hpc: intriguing. i think of applicatives as being their own transformers, since they compose. buy i suspect you're thinking of something else.
13:05:29 <hpc> no, now that i think about it it's a nonsensical idea
13:05:30 <hpc> :P
13:06:10 <conal> hpc: i haven't played with constraint kinds yet, but i have a hunch they'll be insanely useful.
13:06:31 <hpc> insanely
13:07:11 <hpc> i want to play with them, but i am not very good at writing ridiculously complex code unless i have an objective
13:28:46 <ezyang> a -> m b is a Kleisli arrow. Is m a -> m b any sort of well known arrow?
13:30:36 <bootcode> i'm reading monads in realworldhaskell, the part ch14/Logger.hs. It tells that >>= ensures that logged things will appear in the good order, but does not guarantee anything about when `a` and `b` are evaluated.
13:31:31 <bootcode> m >>= f = let (a, w) = extractLogger m; n = f a; (b, x) = extractLogger n; in Logger (b, w ++ x)
13:31:50 <kallisti> bootcode: correct
13:32:22 <abnormalized> #mongodb
13:32:33 <bootcode> but as I see, to get b, one would need to evaluate n, which would need to evaluate a
13:32:42 <kallisti> bootcode: some monads are "strict" in the sense that they do impose an evaluation order on a and b
13:32:45 <bootcode> so there seems to be an ordering on evaluating a and b?
13:32:52 <abnormalized> oops .. sorry .. that wasn't an advertisement :/
13:33:36 <kallisti> bootcode: not if "f" doesn't force a
13:34:51 <kallisti> consider const (return 2) as f
13:34:56 <kallisti> now a is completely ignored
13:34:56 <bootcode> kallisti: good point
13:35:20 <bootcode> kallisti: then I guess IO is a strict monad?
13:38:05 <donri> achievement unlocked: ghc panic
13:45:11 <bootcode> looking at the IO >>= definition at http://www.haskell.org/haskellwiki/IO_inside, it writes: (action1 >>= action2) world0 =  let (a, world1) = action1 world0; (b, world2) = action2 a world1;  in (b, world2)
13:46:40 <bootcode> is IO forcing the `world` argument what causes the sequencing?
13:48:59 <donri> looks like the panic i ran into is fixed in 7.6 already
13:51:11 <edwardk> bootcode: no, its more that ghc isn't allowed to reorder stuff past a the case match on the World
13:53:59 <bootcode> edwardk: so it is not directly encoded in the operations then, but a compiler-specific behavior on RealWorld?
13:54:18 <edwardk> as i understand it
13:55:32 <bootcode> thank you
13:57:58 <monochrom> that IO_inside article is actually misleading
13:58:43 <monochrom> sure, compilers are free to use whatever tricks to generate desired code. does not mean that the tricks are the semantics
14:01:45 <bootcode> is there a default semantics for a monad? strict vs. lazy? the definition of a monad doesn't deal with this maybe.
14:02:27 <bootcode> if there isn't an obvious semantic in this regard, then possibly it is all down to implementation detail?
14:02:32 <sipa> there are 'monad laws', but they don't specify any operational semantics
14:03:58 <bootcode> so operatonal semantics is an orthogonal issue, having to be given on a monad by monad case then I assume
14:04:03 <monochrom> monad is very general. perhaps too general. there is no default. different examples look unrelated
14:05:09 <monochrom> unlike finite-dimensional vector spaces where if you know the scalar field is the real numbers then you nail them down to R^1 or R^2 or R^3 or ...
14:09:14 <yitz> monochrom: category theory tends to be that way.
14:10:50 <nand`> I think the semantics of IO are such that executing a >> b guarantees a's side effects to occur before b's; excluding unsafe*
14:11:10 <monochrom> right
14:11:28 <yitz> nand`: not really, in the presence of lazy IO.
14:11:33 <monochrom> but I would say "intended effects" instead of "side effects" :)
14:11:52 <monochrom> lazy IO falls under unsafe* e.g. unsafeInterleaveIO
14:13:17 <yitz> monochrom: the exposed combinators of lazy IO are very predictable, i wouldn't call them unsafe. instead, i would just say that there is no guarantee of what nand` says in its presence.
14:13:59 <monochrom> "Actions, however, must be ordered in a well-defined manner for program execution – and I/O in particular – to be meaningful. Haskell’s I/O monad provides the user with a way to specify the sequential chaining of actions, and an implementation is obliged to preserve this order." Haskell 2010 chapter 7.
14:14:47 <nand`> I was specifically thinking about unsafeInterleaveIO (and unsafePerformIO) with that comment
14:16:15 <yitz> monochrom: ok, that's true. it does provide that. the way to specify it is not just with >>, though.
14:16:58 <yitz> monochrom: it would be nice if there were something both usable and practical in general, and as simple as that. so far, we don't have it.
14:17:53 <monochrom> "Special operations (methods in the class Monad, see Section 6.3.6) sequentially compose actions, corresponding to sequencing operators (such as the semicolon) in imperative languages."
14:18:33 <monochrom> methods of Monad are return, >>=, >>, fail. guess who receive the spotlight when it comes to sequencing
14:19:38 <yitz> yep. and also in imperative languages, operations initiated before the semicolon are not always guaranteed to complete before those after the semicolon. those statements don't imply any guarantess.
14:19:42 <yitz> guarantees
14:22:28 <nand`> monochrom: the most elegant way to formulate it, clearly, would have to be with “join”
14:23:01 <yitz> monochrom: anyway, if your source of authority is the Report, the Report explicitly requires lazy IO. So that way at best you'll prove that the Report is inconsistent, not that IO ought not to be lazy.
14:24:02 <yitz> monochrom: don't get me wrong. i'm not enamoured with lazy IO. but it
14:24:34 <yitz> it's still the best we've got for many purporse. probably most purposes even. not for long though, i hope. there is progress on many fronts.
14:41:31 <rwbarton> yitz++ good to hear this kind of balanced view on lazy IO.
14:41:47 <donri> is there a better way to write this? http://hpaste.org/70047
14:44:39 <rwbarton> hmm, instance (a ~ b) => F a b is different from instance F a a I guess?
14:45:04 <donri> rwbarton: well, can you make an instance for (Map k) with the latter?
14:45:11 <parcs`> donri: why not class IsList f where fromList :: [a] -> f a ?
14:45:24 <donri> parcs`: because of Map
14:45:26 <parcs`> oh right constraints
14:45:28 <parcs`> :(
14:45:36 <rwbarton> well all of your examples are of the form where b is constrained only as being equal to a, so couldn't you just replace b by a everywhere
14:45:37 <donri> [(k,v)] -> Map k v
14:45:46 <rwbarton> and remove a ~ b
14:46:01 <rwbarton> but now it occurs to me that in fact that would change the meaning, probably?
14:46:09 <donri> rwbarton: but in the map case "a" is actually (k,a)
14:46:23 <rwbarton> oh I don't mean remove b from the class.
14:46:33 <rwbarton> I mean you don't need a variable named 'b' in any of those instances.
14:46:51 <rwbarton> Just replace all the 'b's by 'a's.
14:47:00 <nand`> that would require -XFlexibleInstances yes?
14:47:02 <fuchsto> I want to implement a signal generator, and i was thinking about doing so with a state monad. What i want to do is: Pass a function accepting three arguments: Generating function (like sin), and two arguments for that function to generate a signel (frequency and phase)
14:47:02 <rwbarton> Not the type that's the second parameter of the type class, but the type named 'a' in the instance.
14:47:19 <fuchsto> Now, silly beginner that i am: What's the most elegant way to do this?
14:47:41 <donri> rwbarton: then i get errors like No instance for (IsList Data.Set.Set a0 Affix)
14:47:46 <parcs`> donri: you'll probably want a fundep f -> a b
14:48:01 <rwbarton> f a -> b rather
14:48:01 <donri> i was thinking fundeps might be relevant
14:48:10 <donri> i don't fully understand those yet
14:48:15 <parcs`> rwbarton: why?
14:48:17 <rwbarton> and yeah I was eventually going to get around to suggesting a fundep or a type family
14:48:26 <rwbarton> parcs`: well, take []
14:48:29 <nand`> | a -> b  -- just means that every ‘a’ is associated with at most one ‘b’
14:48:30 <rwbarton> [] doesn't determine a or b
14:48:36 <rwbarton> but [] and a determine b = a
14:48:38 <nand`> so if the compiler knows ‘a’ it can automatically infer the only possible ‘b’
14:49:52 <rwbarton> and yeah, this "instance (a ~ b) => F a b" technique gives you some of the advantages of fundeps I guess
14:50:09 <rwbarton> except it is a per-instance decision, rather than a per-class decision
14:50:20 <rwbarton> so it would only work once the instance is selected
14:50:54 <rwbarton> Sorry, I'm probably not making much sense.
14:53:34 <donri> f a -> b works, thanks :)
14:53:44 <donri> now to understand why
14:54:11 <rwbarton> < donri> rwbarton: then i get errors like No instance for (IsList Data.Set.Set a0 Affix) -- right; because with "instance (Ord a, a ~ b) => IsList Set a b" it knows when it needs an instance with f = Set and b = Affix that it must use this instance, since it has the most general possible head, and then it can conclude that a = Affix too; while with "instance IsList Set a a" it doesn't have any reason to pick that instance over
14:55:09 <donri> cut of at "pick that instance over"
14:55:16 <rwbarton> pick that instance over a hypothetical "instance IsList Set (a,a) a", for example
14:56:12 <rwbarton> So that's the difference between "instance (Ord a, a ~ b) => IsList Set a b" and "instance IsList Set a a"
14:56:35 <rwbarton> the latter doesn't preclude adding more instances "instance IsList Set Foo Bar"
14:56:47 <rwbarton> and so more type annotations are required to use it
14:58:58 <donri> so when can we have -XOverloadedLists? :)
14:59:56 <shachaf> loading=rated
15:00:01 <shachaf> s/\</over/g
15:00:10 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/22065/
15:00:29 <rwbarton> Then when can we have -XUnderloadedLists?
15:00:45 <shachaf> List syntax that corresponds to *no* Haskell values?
15:00:50 <donri> monochrom: would that version work for Map?
15:01:07 <monochrom> no, Map is not like [a]
15:01:15 <shachaf> donri: Maps aren't lists. I'm not sure why you'd want to act like they are.
15:01:42 <monochrom> oh wait, I guess it works too. I have carefully set up a fundep
15:01:50 <donri> because I have Map.fromList all over my code and have to add qualified imports everywhere
15:02:22 <illissius> donri: another way you could possibly do it is class FromList l where type ElemOf l; fromList :: [ElemOf l] -> l; instance FromList [a] where type ElemOf [a] = a; fromList = id; instance FromList (Map k a) where type ElemOf (Map k a) = (k, a); fromList = Map.fromList; and you could do ByteString too
15:02:32 <illissius> but that might be worse for type inference
15:02:34 <monochrom> instance IsList (Map k a) (k,a) where fromList = Map.fromList
15:02:37 <rwbarton> actually i'm confused why donri's fundep f a -> b apparently works when the error was "No instance for (IsList Data.Set.Set a0 Affix)"
15:02:47 <illissius> ...and the Map instance might be impossible because of the Ord thing :\
15:02:47 <rwbarton> that looks like it needs a fundep f b -> a
15:03:09 <monochrom> instance Ord k => IsList (Map k a) (k,a) where fromList = Map.fromList
15:03:29 <illissius> or not. thinking is hard
15:03:48 <monochrom> it's why I gave up on thinking, and switched to calculating
15:03:59 * geekosaur thinks "fl = Map.fromList" might be more appropriate, cf. the common "fi" shorthand for fromIntegral
15:04:22 <monochrom> anyway I am proud of my fundep :)
15:04:29 <donri> geekosaur: see IsString
15:05:50 <donri> monochrom: you're right; I got rid of my "b"
15:14:31 <hpaste_> sykora pasted “Generating random lists.” at http://hpaste.org/70049
15:15:02 <sykora> That was fast.
15:16:07 <sykora> I've got a problem with writing an instance of Arbitrary for one of my data types, which involves generating a random ordered list of non-negative integers, given the size of the list, and an upper bound on the elements of the list.
15:16:51 <sykora> I've written a preliminary version which does this, but it looks suspiciously like something that could be made simpler, anyone have any ideas?
15:18:23 <sykora> oh, and the elements must be unique within the range.
15:22:42 <d-old> hey, is there a webframework like Sinatra.rb for Haskell?
15:23:07 <luite> d-old: scotty
15:23:41 <parcs`> happstack is like sinatra
15:23:51 <parcs`> based on my limited usage of sinatra
15:24:29 <luite> scotty is actually sinatra-inspired
15:24:37 <parcs`> oh cool
15:28:18 <HairyDude> <happstack> I did it myyyyyyyyy waaaaay
15:28:23 <HairyDude> (sorry, couldn't resist)
15:28:38 <hpaste_> “Jonathan Fischoff” pasted “Optimizing Expression Evaluation” at http://hpaste.org/70050
15:29:42 <jfischoff> So I have a very simple expression tree in the example above. I have a function evalList :: :: (Num a) => Expr a -> [a] -> [a] that I want optimize.
15:29:57 <jfischoff> the naive version reevaluates the whole tree
15:30:41 <jfischoff> but I know that I should be able to reuse most of the calculations from the previous evaluation on the last element of the list
15:31:39 <jfischoff> I'm wondering what an elegant way is to optimize these type of incremental calculations. I'm guess memo tables of some sort...
15:33:12 <HairyDude> I don't suppose it's possible to export "Foo (..) hiding (bar, baz)" ?
15:34:25 <adnauseam> is [1,1+2] in weak normal form ? or does the addiction still happen alongside the cons ?
15:34:38 <adnauseam> addition*
15:35:07 <HairyDude> dunno about WNF, but it's WHNF
15:35:19 <HairyDude> (I'm not quite clear on the difference)
15:35:22 <adnauseam> oh sorry, weak head normal form, i've missed the h there
15:35:43 <HairyDude> WHNF just means the top level constructor is known.
15:35:46 <HairyDude> here that's []
15:35:56 <adnauseam> hrm, that makes the two of us. the material i've found on the subject doesn't offer enough info for the novice
15:36:21 <d-old> thanks luite that will do :)
15:36:50 <HairyDude> I recall seeing a book by SPJ on writing compilers for functional languages from the early '90s in my university library... I was tempted to borrow it but didn't feel like I had time to study it
15:37:12 <ceasarbautista> Hi! I'm trying to do the following "instance Arbitrary (Nfa Int) where" and am having some trouble. Is there a simple way to get that to compile?
15:37:15 <parcs`> jfischoff: why do test0 and test1 have different outputs?
15:37:23 <d-old> hey, a names collision question, I have a function neighbours :: Board -> Position -> [Position], and I want to do multiple stuff to it, so I want to store the result so my line is: neighbours = neighbours board position
15:37:32 <d-old> obviously this is a name collision, how do you guys solve it?
15:37:38 <d-old> what is the standard way?
15:37:54 <jfischoff> parks`: bad paste ...
15:37:56 <adnauseam> HairyDude: i'd like to have thename if you can remember. i've read the first 5 google results about this and it's still pretty vague to me
15:38:06 * HairyDude googles
15:38:16 <adnauseam> make that the first 7 actually
15:38:17 <jfischoff> parcs`: updated
15:38:28 <HairyDude> adnauseam: you might try google scholar, btw
15:38:31 <hpaste_> “Jonathan Fischoff” annotated “Optimizing Expression Evaluation” with “Optimizing Expression Evaluation (annotation)” at http://hpaste.org/70050#a70051
15:39:17 <HairyDude> well here's one, it's a bit older than I thought http://dl.acm.org/citation.cfm?id=1096899
15:40:32 <adnauseam> HairyDude: oh, an excellent idea
15:41:19 <HairyDude> adnauseam: more: http://dl.acm.org/citation.cfm?id=62717 http://dl.acm.org/citation.cfm?id=99385
15:42:24 <HairyDude> (ISTR GHC used to be based around a "spineless tagless G-machine" but these days has tags again... not that I really understand what that means)
15:43:24 <adnauseam> HairyDude: that makes the both of us then ;p
15:43:45 <parcs`> jfischoff: what exactly is being reevaluated/
15:44:43 <jfischoff> parcs`: The old right branch of the expression that hasn't changed.
15:44:47 <d-old> you guys never have this name collision problem?
15:45:10 <yitz> d-old: i don't understand your question. why not just use a different name?
15:45:37 <BMeph_> d-old: I don't know what "multiple stuff" you're planning to do, and for that matter, I'm not even exactly sure if it's the function, or results of applying the function that is what you want to "do". :)
15:46:20 <rwbarton> jfischoff: one technique is to store the result that you want to avoid recomputing in each node
15:47:03 <rwbarton> when you construct the node
15:47:12 <rwbarton> thanks to laziness you only actually compute the result if you need it
15:47:22 <jfischoff> rwbarton: ah, cool
15:47:30 <jfischoff> well that's easy
15:47:39 <jfischoff> thanks :)
15:50:35 <d-old> yitz: hmm I chose a different name.. I guess it never happens that it's not possible to pick a better name
15:54:28 <jmcarthur> @tell Jeanne-Kamikaze sorry nobody was around during your questions in #haskell-game. ping me when you come back and if i'm around we can discuss it
15:54:28 <lambdabot> Consider it noted.
15:57:48 <shapr> aw
16:32:29 <bootcode> yay! RealWorldHaskell featuring Attila the Hun (in Ch 15)
16:34:57 * mzero is at the HackerDojo in Mtn. View, CA - lest anyone else is too
16:43:48 <d-old> I'm porting a project simultaneously from Dutch to English and from Miranda (dialect) to Haskell :P
16:49:24 <shapr[> d-old: that's really cool
16:49:39 <edwardk> preflex: xseen byorgey
16:49:40 <preflex>  byorgey was last seen on freenode/#haskell 9 hours, 29 minutes and 22 seconds ago, saying: if you're just writing a bunch of text to the screen, or to a file, turning off buffering slows things down a lot
16:52:09 <edwardk> http://hackage.haskell.org/package/bound is my foray into the strange realm of actually documenting a package
16:52:41 <luite> d-old: what kind of project? something from utwente?
16:53:08 <openstandards> gienah: ended up doing cabal install dbus-core as thats actually maintained still but thanks for helping earlier today
17:08:24 * hackagebot bound 0.1.4 - Haskell 98 Locally-Nameless Generalized de Bruijn Terms  http://hackage.haskell.org/package/bound-0.1.4 (EdwardKmett)
17:09:17 <edwardk> gah, screwed up the pvp on that release
17:13:26 * hackagebot bound 0.2 - Haskell 98 Locally-Nameless Generalized de Bruijn Terms  http://hackage.haskell.org/package/bound-0.2 (EdwardKmett)
17:13:28 * hackagebot ircbot 0.5.1 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.5.1 (JeremyShaw)
17:14:48 <edwardk> guess i'll probably just give a talk on the library at the next boston haskell, my other speaker bailed out
17:14:57 <edwardk> anyone else interested in giving a talk in the boston area?
17:17:32 <d-old> luite: yeah, did you went there?
17:17:51 <luite> yes, only undergrad though
17:18:05 <d-old> I'm porting https://github.com/d-snp/Go-in-Amanda to https://github.com/d-snp/Ergo
17:18:27 <d-old> ah, did do a master somewhere else or did you go work?
17:18:40 <luite> master in utrecht
17:18:56 <d-old> oh that's interesting, don't see that very often, why? :)
17:19:02 <d-old> more girls? ;)
17:19:12 <luite> courses looked more interesting
17:19:33 <gienah> openstandards: that's neat, dbus-core looks like a well written library (and you can hope there's no more major api changes)
17:20:23 <d-old> and where they? :D
17:21:04 <luite> dunno, hard do compare if you've only seen one side :p
17:21:06 <luite> to
17:21:16 <dylukes> Hm, so `pipes` looks pretty nice, but it hasn't been maintained in a long while.
17:21:16 <lambdabot> dylukes: You have 1 new message. '/msg lambdabot @messages' to read it.
17:22:32 <dylukes> ski: Thanks for the advice! That does indeed work in zsh.
17:23:26 <dylukes> How are conduits btw?
17:33:57 <dylukes> Wait no here we go. I was looking at 1.0.1 hehe.
18:18:10 <b0llo> i need help getting this to compile
18:18:14 <b0llo> http://wikipaste.eu/KpUEcXZa
18:18:59 --- mode: ChanServ set +o mauke
18:18:59 --- mode: mauke set +b $a:b0llo
18:19:02 --- kick: b0llo was kicked by mauke (b0llo)
18:19:24 <mauke> (don't open that)
18:21:02 --- mode: mauke set -o mauke
18:22:07 <parcs`> what is it
18:23:51 * geekosaur only saw a flash thingy (not loaded, of course)
18:24:28 <geekosaur> didn't let the rest of the page finish loading either (sometimes being on crap network has its advantages)
19:03:27 <applicative> seems to have been suspiciously calm here; where are the subtle ghc error messages to decode?
19:09:38 <shapr[> applicative: typeclass defaulting?
19:10:51 <applicative> a frequent cause of trouble; but no more it seems; everyone has attained total comprehension.
19:11:35 <applicative> what are the valid uses of unsafeCoerce? or where can I find out
19:12:21 <strager> @src ord
19:12:22 <lambdabot> Source not found. stty: unknown mode: doofus
19:12:54 <strager> Well, if Char and Int were compatible...
19:13:02 <hotaru2k3> how about this error message (not from ghc, from a program compiled with ghc): Segmentation fault/access violation in generated code
19:13:07 <hotaru2k3> i just fixed that...
19:13:32 <hotaru2k3> by adding "(0+) ."
19:13:46 <strager> Are you running out of memory?
19:14:10 <joeyadams> @djinn ((as -> as) -> [a]) -> ((a, as) -> (a, as)) -> [a]
19:14:11 <lambdabot> Error: Undefined type []
19:14:20 <applicative> ord is a safe coerce, I'd say
19:14:40 <strager> @check \x -> ord x == unsafeCoerce x
19:14:42 <lambdabot>   Not in scope: `unsafeCoerce'
19:14:57 <strager> @check \x -> ord x == Unsafe.Coerce.unsafeCoerce x
19:14:59 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
19:16:18 <applicative> @check \c -> chr (ord c) == c
19:16:20 <lambdabot>   "OK, passed 500 tests."
19:16:47 <shachaf> @quote unsafeCoerce
19:16:47 <lambdabot> Japsu says: segfault cat is watching you unsafeCoerce
19:16:58 <applicative> @check \n -> ord (chr c) == n
19:16:59 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:17:20 <applicative> @check \n -> ord (chr n) == n
19:17:21 <lambdabot>   "*Exception: Prelude.chr: bad argument: (-1)
19:17:33 <applicative> hah, not so safe
19:18:33 * hackagebot suffixarray 0.0.3 - n log n implementation of suffix array.  http://hackage.haskell.org/package/suffixarray-0.0.3 (VictorDenisov)
19:33:34 * hackagebot suffixarray 0.0.3.1 - n log n implementation of suffix array.  http://hackage.haskell.org/package/suffixarray-0.0.3.1 (VictorDenisov)
19:34:23 <Joe_> myLast' :: [a] ->a     myLast' = head . reverse                Hi guys, when i try implement this function as reverse . head instead of head . reverse   it doesnt work !!!
19:34:40 <Joe_> Can anybody expain me why ?
19:35:15 <Axman6> :t head
19:35:16 <lambdabot> forall a. [a] -> a
19:35:21 <Axman6> :t reverswe
19:35:22 <lambdabot> Not in scope: `reverswe'
19:35:23 <Axman6> :t reverse
19:35:24 <rwbarton> Can you explain why you would expect it to work?
19:35:25 <lambdabot> forall a. [a] -> [a]
19:35:35 <Axman6> @src (.)
19:35:35 <lambdabot> (f . g) x = f (g x)
19:35:35 <lambdabot> NB: In lambdabot,  (.) = fmap
19:36:14 <Joe_> oh i didnt realized the type.....
19:36:18 <Joe_> yep i got it
19:36:26 <Joe_> thank you very much
19:36:31 <rwbarton> it's not even a type issue, really
19:36:35 <rwbarton> but okay
19:37:00 <Joe_> and btw....how i can answer as private
19:37:08 <Axman6> please don't
19:37:11 <Joe_> on the screen
19:37:14 <rwbarton> I think most people would strongly prefer you not do that
19:37:53 <Joe_> oh right then ...
19:38:01 <Joe_> thanks lot one more time
19:38:28 <applicative> > reverse . head $ ["hello", "world"]
19:38:30 <lambdabot>   "olleh"
19:38:50 <Joe_> :D
19:38:51 <applicative> > head . reverse  $ ["hello", "world"]
19:38:53 <lambdabot>   "world"
19:39:13 <Joe_> :DDD
19:39:20 <applicative> the first only works if its a list of lists
19:39:28 <Joe_> got it
19:39:33 <rwbarton> yeah this is what I meant, they are just totally different things
19:39:46 <rwbarton> good demonstration
19:39:55 <parcs`> "answer as private"? what does that mean?
19:40:02 * shapr[ dances cheerfully
19:40:06 <shapr[> I love working code!
19:41:12 <Joe_> i mean when you answer my question , i would like to answer to you...which keyboard should i press , that i mean answer to you ...
19:41:54 <rwbarton> Joe_: if you want to address a line like this, you do it by pressing the 'J', 'o', 'e', '_', ':', and space keys on your keyboard.
19:42:34 <rwbarton> However it's not "private", it just serves to identify the intended primary recipient of your message.
19:44:43 <Joe_> great :)
19:45:59 <Joe_> nice to talk to a newbie ha ?
19:46:42 <Axman6> Joe_: if you try typing ax<tab> it should tab complete my name, makes life easier
19:46:50 <tgeeky> Axman6: he's on webchat
19:47:01 <Axman6> i think it still works there
19:47:02 <strager> Most webchats nowadays have tab competion
19:47:04 <tgeeky> Axman6: dunno if that means he doesn't have tab completion or not :o
19:47:04 <strager> completion*
19:47:16 <Axman6> pretty sure the free node one does
19:47:21 <Joe_> Axman6: works , thx
19:58:35 * hackagebot seqloc 0.5.0.2 - Handle sequence locations for bioinformatics  http://hackage.haskell.org/package/seqloc-0.5.0.2 (NicholasIngolia)
20:05:53 <applicative> there seems to be a spike in bioinformatic haskell
20:08:35 * hackagebot seqloc-datafiles 0.2.2.1 - Read and write BED and GTF format genome annotations  http://hackage.haskell.org/package/seqloc-datafiles-0.2.2.1 (NicholasIngolia)
20:08:37 * hackagebot samtools 0.2.1.2 - Binding to the C samtools library  http://hackage.haskell.org/package/samtools-0.2.1.2 (NicholasIngolia)
20:15:13 <JoeyA> ski: Thanks for rambling about the usefulness of polymorphic recursion the other day.  I found another use case: a function that takes N items and returns exactly N items.
20:15:51 * ski doesn't recall rambling about that recently ..
20:15:57 <JoeyA> Well, two weeks ago.
20:15:58 <JoeyA> Time flies
20:16:25 <JoeyA> My current formulation is: data PairFuncR a b as bs = Done (as -> bs) | Longer !(PairFunc a b (a, as) (b, bs))
20:16:38 <applicative> what does this mean, it has various arities, and returns a tuple?
20:16:54 <JoeyA> The number of Longer nodes indicates how many arguments the function takes.
20:17:07 <ski> i have a vague memory explaining what polymorphic recursion is, and also a memory of mentioning it as a counter-example to the thesis that there's a fixed (taken to be interpreted as "finite") set of instances in a closed program
20:17:17 <JoeyA> It's not convenient to define such a function by hand, but typeclass hackery can make it more convenient.
20:17:47 <rwbarton> are PairFuncR and PairFunc supposed to be the same there?
20:17:53 <JoeyA> The use case is defining a "let rec" combinator for an eDSL.
20:18:01 <JoeyA> rwbarton: yes, my bad
20:18:17 <JoeyA> type PairFunc a b = PairFuncR a b () ()
20:18:37 <rwbarton> ah
20:18:46 <JoeyA> With let rec, the user requests that N things be defined, and needs N corresponding arguments.
20:19:48 <JoeyA> Thus, it is like [a] -> [b], with two key differences: 1) The function gets to decide how many arguments there are, and 2) The function can only return the same number of items as it requested.
20:20:12 <JoeyA> What's a better name for an N-ary function that returns an N-tuple?
20:20:18 <JoeyA> (besides PairFunc)
20:22:23 <ski> JoeyA : <http://twanvl.nl/blog/haskell/non-regular1>,<http://twanvl.nl/blog/haskell/non-regular2> might perhaps be interesting
20:24:08 <JoeyA> Neat
20:24:53 <ski> JoeyA : you could turn this type inside-out to get `data ListFun a b = Done b | More (a -> ListFun a (a,b))' which is more like your `PairFuncR'
20:25:14 <ski> er, `PairFunc', i.e.
20:27:22 <JoeyA> ski: That's similar to my original formulation: data ListFun a b r = Done r | More (a -> ListFun a b (b, r))
20:27:36 <mm_freak> since Free is essentially based on CPS i suppose it's impossible to turn it into a MonadFix?
20:27:40 <JoeyA> (the difference being that returned items may have a different type)
20:27:54 <mm_freak> (or rather not yet known how to)
20:28:16 <JoeyA> I had trouble coming up with a fixpoint combinator for ListFun, but that doesn't mean it's impossible.
20:28:22 <ski> JoeyA : one could existentially quantify `a', to allow each input-output to have an independent type  -- but then one can't extract any of these (directly), so it's more like `let val rec f = ... and g = ... in ..f..g.. end' than like `val rec f = ... and g = ...'
20:28:39 <mm_freak> JoeyA: what's ListFun?
20:29:05 <JoeyA> mm_freak: The goal is a function that takes N arguments and returns exactly N results.
20:29:10 <JoeyA> e.g. (a, a, a, a) -> (b, b, b, b)
20:29:15 <JoeyA> or (a, a) -> (b, b)
20:29:19 <ski> mm_freak : `Free' is based on CPS ?
20:29:44 <mm_freak> ski: the DSL you write is based on CPS (unless you never process results)
20:29:59 <mm_freak> data MyLang b = GetChar (Char -> b)
20:31:26 * ski doesn't see how CPS enters the picture ..
20:32:22 <applicative> data Free f r = Free (f (Free f r)) | Pure r
20:32:24 <mm_freak> ski: the argument to MyLang is a function that processes the result
20:32:51 <mm_freak> getChar = Free (GetChar Pure)
20:33:01 * ski thinks the argument to `MyLang' is a type (of kind `*')
20:33:37 * hackagebot kevin 0.1.1 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.1.1 (JoelTaylor)
20:33:39 * hackagebot thumbnail 0.5 - generate thumbnail image  http://hackage.haskell.org/package/thumbnail-0.5 (KatsutoshiItoh)
20:33:48 <mm_freak> how is that relevant?
20:33:59 <rwbarton> because you said MyLang when you meant GetChar
20:34:11 <mm_freak> oh
20:34:18 <mm_freak> yeah, stupid mistake =)
20:34:27 <mm_freak> ski: the argument to GetChar is a function that processes the result
20:34:29 <mm_freak> there we go
20:34:47 * ski still doesn't follow :/
20:35:08 <ski> (just passing around functions isn't necessarily CPS)
20:35:52 <otters> aww, hackagebot
20:35:57 <otters> y u no display non-ascii characters
20:35:57 <rwbarton> the argument to GetChar is the continuation-action that will consume the Character that was gotten
20:36:04 <rwbarton> getChar >>= f <---> GetChar f
20:37:12 <rwbarton> Anyhow I don't think it's accurate to say that Free itself is based on CPS
20:45:07 <mm_freak> well, perhaps that was not correct, but as far as i see it your DSL essentially is CPS-based
20:52:17 <parcs`> @localtime hackagebot
21:00:53 <ski> hm, attempting to define `mfix' seems to need some kind of 'zipM :: m (m a) -> m a' (which is not `join')
21:02:24 <ski> perhaps with an imaginative invention of a new class as precondition, it might work -- i'm not sure
21:03:01 <ski> using CPS to yield a counterexample might perhaps work instead
21:03:10 * ski is too tired to think about this atm
21:49:09 <mm_freak> ski: i tried to define MonadFix (Free MyFunctor) specifically
21:49:16 <mm_freak> i don't even know where to start
21:49:48 <mm_freak> funny that i found it almost trivial to define ArrowLoop for AutoT, but MonadFix for Free MyFunctor seems more difficult
21:50:06 <mm_freak> they are structurally similar
22:40:24 <fuchsto> I want to implement a signal generator, that is: I have a function expecting an int (the t value) and returns the sample value at this t, like sin(fromIntegral(t) * 2.0/pi)
22:40:53 <mapreduce> To model SQL in a typed way, bearing in mind you can do avg(x) + 5 or x + 5, I've ended up with Q for queries such as avg that give one value and MQ for queries such as x that give a set.
22:41:03 <fuchsto> i now want to implement a function using a state monad like   State Int Float  incrementing the t-value on each call.
22:41:10 <mapreduce> apart from the names, which will change, does that seem reasonable?
22:41:58 <mapreduce> I thought about keeping them as one type but I think I'll go mad if I try that.
22:42:15 <fuchsto> i tried    nextSignal :: SignalGenerator -> State TValue SValue; nextSignal siggen = do t <- get; let value = genSignal siggen t; return value;
22:42:50 <fuchsto> well, this didn't even compile :/   (Complains at t <- get : Last statement in do construct must be an expression)
22:43:19 <fuchsto> so, what am i doing wrong here? I didn't quite get State, perhaps.
22:44:20 <mauke> let { ... };
22:44:42 <Axman6> do {  }; I think you mean?
22:44:49 <mauke> no
22:45:02 <Axman6> oh, hmm
22:47:55 <fuchsto> ah, okay, i needed a newline after 'do'
22:49:34 <Axman6> if you're going to use do notation, I would not use a single line, it looks horrible
22:50:11 <fuchsto> apart from the syntax: Am i doing this right?
22:51:47 <Axman6> well, it depends how you're using it
22:52:05 <fuchsto> hm, like  nextSignal mySigGenerator 0   ?
22:52:31 <fuchsto> first things first: I use   State TimeValue SampleValue
22:53:00 <fuchsto> because it's a state over the time value (which should be incremented on every call) and produces a SampleValue. Right? Horribly wrong?
22:55:54 <yitz> fuchsto: besides the syntax issue, it looks like you're on the right track (you didn't increment the time value though)
22:56:11 <fuchsto> yitz: i forgot put $ time+1, yes
22:56:40 <fuchsto> yitz: Just wondering if this is really all i have to define
22:56:49 <yitz> yep
22:57:00 <fuchsto> yitz: I'd be flabbergasted
22:57:33 <yitz> well, you need to import the symbols you are using. and you haven't *used* this function yet. but yeah, that's it.
22:57:54 <fuchsto> yitz: Hm, but, errm. Assuming i want to generate 3 sequential samples. I would call    nextSignal siggen 0  three times in a row?
22:59:17 <yitz> fuchsto: right. inside an expression whose type is State TValue whatever. which will probably be a do expression, so "three times in a row" makes sense.
23:00:06 <fuchsto> yitz: My intuition is that i pass 0 as a start value for the State Int. Is that right?
23:00:39 <fuchsto> yitz: Passing the same start value every time and expecting different results looks funny to me
23:01:27 <yitz> fuchsto: sounds good. to get things started from an outer function whose type isn't in your State monad, you call evalState f 0, where f is something in the State monad.
23:01:47 <ag90> Hello. I have a design block that I would like help with.
23:02:54 <ag90> Consider a class MonadRequest that defines a monadic interface for HTTP requests (disregard implementations). Consider another independent class MonadFoo that defines *some* set of monadic operations. Intuitively, I would choose to say "(MonadRequest m) => instance MonadFoo m" to say that given an instance of MonadRequest may be treated as an instance of MonadFoo with the given implementations.
23:02:56 <fuchsto> yitz: Sorry for re-re-reassuring, but i could call   putStrLn $ nextSignal siggen 0; putStrLn $ nextSignal siggen 0; ...   and get different values?
23:03:21 <yitz> fuchsto: it actually *is* the same value every time. the type State s a is really just an alias for a function of type s -> (a, s). So you are not actually doing anything 3 times. you are defining a function that, when called via evalState, does it 3 times, passing a different value of s each time.
23:04:25 <yitz> s/value of s/value of type s/
23:04:30 <ag90> As I understand it, that is possible with UndecidableInstances, but somehow not recommended. I think I understand some of the reasons for it not being recommended. What would you say is the preferred approach to such a design?
23:04:57 <fuchsto> yitz: Ah! So nextSignal would return a state initialized with 0, and evalState'ing it would execute the function generated, thus returning a value and increment the state.
23:05:02 <yitz> ag90 no that's not what it means
23:06:17 <yitz> ag90: it means: m is required to be already an instance of MonadRequest. otherwise, this instance definition for MonadFoo will be rejected at compile time.
23:08:02 <yitz> ag90: then there are extensions like UndecidableInstances that allow you to write that definition even though it only makes sense for *some* types m but not all, and the compiler does its best to reject things that don't make any sense at all.
23:08:46 <yitz> ag90: but it can't always tell, because that is an undecidable problem. there is no algorithm that will allow the compiler to reject nonsense 100% of the time.
23:09:29 <ag90> yitz: Ah, I see. So, what would you say is the better approach towards such a design? Or is the design idea wrong to begin with?
23:10:38 <ag90> Some part of an OOP approach may be leaking into the design. In an OOP language, I may do exactly this: make interfaces Request and Foo, and a class Foo backed by an object that satisfies the Request interface.
23:10:44 <yitz> fuchsto: well, evalState will call your state function with an initial value. your definition will result in multiple function calls, passing along that hidden extra parameter containing the state and modifying it as necessary as it goes along.
23:10:59 <kallisti> ag90: the current approach involves tediously writing instances for each individual type.
23:11:02 <kallisti> also
23:11:13 <kallisti> you only need OverlappingInstances I believe.
23:11:17 <kallisti> not undecidable.
23:12:00 <kallisti> the problem is that the class constraint is ignored for the purposes of deciding instances.
23:12:09 <yitz> ag90: yes, this desing sounds like it is likely OO-influenced and not the most natural way to do things in Haskell. but it's hard to tell without seeing more of the design. :)
23:12:33 <yitz> design
23:14:07 <kallisti> yitz: here's an example of taking a monadic operation and overloading it over monad transformers. http://hackage.haskell.org/packages/archive/webdriver/0.3.3/doc/html/Test-WebDriver-Classes.html
23:14:14 <kallisti> ag90: ^
23:14:31 <kallisti> I just bit the bullet and defined instances by hand.
23:14:50 <yitz> kallisti: yeah
23:14:59 <ag90> Ooh. I see. Thanks for that.
23:15:09 <kallisti> the most common reason to overload a monadic operation in a typeclass is to make it convenient for transformer stacks to use the operation without a lifting function.
23:15:37 <kallisti> but you could have other reasons. for example, the WebDriver class would allow me to create a "dummy" monad that simply logs HTTP requests rather than doing any real networking.
23:15:47 <kallisti> I've yet to do that though.
23:16:04 <yitz> kallisti: but classes aren't need for that really. they just add unneeded complexity. unless you really have several very different data types that need to follow this whole pattern, and even then there are probably much nicer ways to do it.
23:17:55 <kallisti> yitz: how would you propose avoiding a typeclass in my example?
23:18:08 <kallisti> sure I can just liftBase or liftIO, but I didn't want to. :P
23:18:52 <yitz> in short: yes, it is possible to force Haskell's type system to bend into the shape of an OOP-oriented design. the closer to the actual OOP design you stay, the messier the type hackery you need. but if you want to know the best way to write any given program in haskell, the first step is to leave OOP thinking aside altogether.
23:23:22 <yitz> kallisti: for example: you would have pure function that builds a request object. maybe inside pure state monad, if that's worth the extra machinery to avoid passing around the session state. then you would have function in the IO monad that takes a request and a url and returns a result. composing the two is easy, but if you do that often enough, you could define that composition as an extra helpre function.
23:23:45 <yitz> helper. boy, i can't type today.
23:24:14 <kallisti> yitz: well yes, that's how my library is implemented.
23:24:31 <kallisti> the purpose of the type class is to avoid explicit lifting in transformers where the base is my existing monad.
23:24:46 <kallisti> the type class appeared after the rest of the library, when I determined that there was a good reason to exist.
23:26:53 <ag90> Thanks guys. This has actually been helpful. I'll try to rework my design. Perhaps the first step is getting rid of the "layers" of classes.
23:26:59 <kallisti> the library was a fun challenge:  take an API aimed for traditional object-oriented language implementations, and rework it into idiomatic Haskell.
23:27:19 <kallisti> ag90: unless you know what you're doing, starting off with typeclasses isn't a great idea.
23:27:19 <yitz> kallisti: you could just define a monad directly that has the operations you need. if you have many such monads, this "automatic lifting" thing might save some boilerplate, but even then, it's not clear to me that this is any neater. if you don't already have quite a few different monads for which you need this, then it's definitely a premature optimization.
23:27:49 <ag90> kallisti: Hah, okay.
23:28:15 <kallisti> in most situations, I find it best to work with concrete values first, until the need for a typeclass emerges.
23:28:25 <yitz> kallisti: yes it's definitely a great excerise though, you're right. :)
23:28:46 <kallisti> yitz: I do define a monad directly with the operations I need. :P
23:29:01 <yitz> kallisti: i figured so. ;)
23:29:29 <kallisti> I figured it would be a pretty common use-case to use StateT or ReaderT with WD
23:30:34 <kallisti> previously WD was taking up the useable MonadState instance, and you had to explicitly use lift, when presumably the central goal of the user program is to test web applications via this library.
23:30:42 <fuchsto> yitz: Hrm, well, this doesn't seem to work (still fiddling around with State)
23:31:11 <yitz> fuchsto: paste
23:31:13 <yitz> @where hpaste
23:31:14 <lambdabot> http://hpaste.org/
23:31:41 <fuchsto> yitz: It's on github, actually. Let me sync it ...
23:32:46 <kallisti> ag90: unlike what you may be familiar with in OO languages, type classes in Haskell aren't really the focal point of abstraction and reusability.
23:32:50 <fuchsto> yitz: https://github.com/fuchsto/drool
23:33:42 <fuchsto> yitz: Source is src/Drool/Utils/SigGen.hs
23:34:00 <fuchsto> yitz: Usage is in src/Drool/Main.hs
23:34:23 <fuchsto> yitz: Don't giggle to loud, it's my first steps in real world Haskell
23:34:39 <kallisti> welcome aboard.
23:35:14 <fuchsto> kallisti: Thanks, this channel is really helpful and welcoming, i appreciate it
23:35:28 <kallisti> are you familiar with functional reactive programming?
23:35:39 <kallisti> many of the concepts that are used with that are relevant to signal processing code such as this.
23:35:41 <Axman6> fuchsto: how fully do you understand the State monad by the way?
23:36:01 <fuchsto> Axman6: On a perceived scale from 1 to 10? ... 2
23:36:16 <Axman6> care to explain how you understand it works?
23:36:25 <Enigmagic> fuchsto: it goes to 11
23:36:29 <fuchsto> Axman6: As i can't quite estimate how much i didn't understand yet, i tend to think i now nothing.
23:36:30 <yitz> fuchsto: looks great. what goes wrong?
23:36:38 <fuchsto> Enigmagic: I'm afraid so
23:36:57 <fuchsto> yitz: Hm, it does seem to produce the same values every time
23:37:12 <fuchsto> yitz: I am supposed to call   evalState generator 0  ?
23:37:21 <Axman6> State is not global state, you understand that right?
23:37:28 <kallisti> State itself just stores some value that gets passed around implicitly. you can get it and modify it. that's pretty much it.
23:37:31 <dmwit> "same values every time" is a feature, not a bug
23:37:40 <Axman6> it's just passing around the 'state' as a function input
23:37:52 <Axman6> @unmtl State s a
23:37:52 <lambdabot> s -> (a, s)
23:37:54 <yitz> fuchsto: small style point: it usually turns out more convenient to define the alias for your state monad type with a parameter. like type SignalGeneratorState a = State TValue a
23:37:57 <fuchsto> Axman6: As a function input for evalState, i presume?
23:38:26 <yongliang> @unmtl Writer
23:38:26 <lambdabot> Plugin `unmtl' failed with: `Writer' is not applied to enough arguments, giving `/\A B. (B, A)'
23:38:31 <fuchsto> yitz: Yes, it's restrictive without a cause otherwise, right
23:38:34 <Axman6> > evalState (do {x <- get; put 7; run x}) 3
23:38:35 <lambdabot>   Not in scope: `run'
23:38:37 <kallisti> runState, evalState and friends start the ball rolling with an initial value.
23:38:42 <Axman6> > evalState (do {x <- get; put 7; return x}) 3
23:38:43 <lambdabot>   3
23:38:43 <yongliang> @unmtl Writer a b
23:38:43 <lambdabot> (b, a)
23:38:49 <yitz> fuchsto: it will produce the same values every time you call evalstate generator 0. for an expression within the state monad, you'll get different values every time.
23:38:56 <Axman6> > runState (do {x <- get; put 7; return x}) 3
23:38:57 <lambdabot>   (3,7)
23:39:02 <dmwit> yitz: Did you get that backwards? Usually without a parameter is better, like type SignalGeneratorState = State TValue
23:39:20 <yitz> dmwit: ok right
23:39:22 <kallisti> dmwit: in this case he's talking about an explicitly provided a
23:39:26 <dmwit> (Since type aliases must always be fully saturated, and the non-parameterized alias is fully saturated more often.)
23:39:29 <dmwit> kallisti: aaah
23:39:33 <dmwit> my mistake
23:39:37 <kallisti> instead of allowing it to be parametric.
23:39:52 <yitz> either way works fine
23:39:57 <Axman6> > runState (do {x <- get; put 7; return x}) 22
23:39:58 <lambdabot>   (22,7)
23:40:19 <dmwit> Ah, yes, I see what you're talking about now.
23:40:20 <Axman6> > let foo = (do {x <- get; put 7; return x}) in runState foo 22
23:40:22 <lambdabot>   (22,7)
23:40:27 <Axman6> > let foo = (do {x <- get; put 7; return x}) in runState (foo >> foo) 22
23:40:29 <lambdabot>   (7,7)
23:40:29 <fuchsto> Okay, makes perfect sense. And how would i, say, implement a function that returns an incremented value every time?
23:40:58 <Axman6> you'd have to use IO, because that is impossible for a pure function
23:41:02 <kallisti> it doesn't really work like that.
23:41:05 <dmwit> fuchsto: replicateM_ 10000 generator -- ;-)
23:41:09 <kallisti> you'd modify the value inside the State
23:41:25 <dmwit> or perhaps replicateM with no underscore depending on what you want
23:41:34 <kallisti> outside of state no value persists.
23:41:40 <fuchsto> Narf! So State is -pure-
23:41:40 <yitz> fuchsto: if you are doing all this stuff in OpenGL, you may need to use an IORef instead of a state monad, if you need to do IO operations in between while still remembering the state.
23:41:57 <fuchsto> yitz: I'm using IORefs on the signal buffer
23:41:58 <Axman6> of course, check out its definition:
23:42:00 <Axman6> @src State
23:42:00 <lambdabot> Source not found. Wrong!  You cheating scum!
23:42:05 <Axman6> bleh
23:42:15 <ag90> I have to go. yitz, kallisti: thanks for your help
23:42:20 <geekosaur> @unmtl State
23:42:20 <lambdabot> Plugin `unmtl' failed with: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
23:42:26 <geekosaur> @unmtl State s
23:42:26 <lambdabot> Plugin `unmtl' failed with: `State s' is not applied to enough arguments, giving `/\A. s -> (A, s)'
23:42:28 <kallisti> fuchsto: one of the uses of state is to emulate this kind of "increment a value" logic, /within/ the State computation.
23:42:29 <fuchsto> Axman6: thanks, i found it online.
23:42:30 <geekosaur> @unmtl State s a
23:42:30 <lambdabot> s -> (a, s)
23:42:43 <yitz> Axman6: grr. i always forget how to convince lambdabot to cough up the source for those things.
23:42:54 <Axman6> @unmtl State s a
23:42:54 <lambdabot> s -> (a, s)
23:43:05 <dmwit> That error message actually gives the answer you wolud want in such a case, anyway.
23:43:16 <geekosaur> which tells you State is just a tuple in disguise, not some magic
23:43:20 <dmwit> State gives /\A B. A -> (B, A)
23:43:29 <fuchsto> geekosaur: Yeah, (state, valueOfThisState)
23:43:32 <Axman6> no, state is a function, returning a tuple in disguise ;)
23:44:52 <yongliang> @hoogle forM
23:44:52 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
23:44:52 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
23:44:52 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
23:45:08 <fuchsto> So, actually State is just mapping a value of a (the state type) to b (the state result value), returning it as a tuple?
23:45:14 <kallisti> yep.
23:45:35 <fuchsto> Ouuuhkay ... then it's not helping much for my problem
23:45:46 <dmwit> fuchsto: Uh, not quite.
23:46:07 <dmwit> fuchsto: It's mapping a value of type a (the state type) to an output value of type b (the result type) *and* an updated value of type a.
23:46:18 <fuchsto> So i should create an instance of the IO monad, implementing the 'increment value' part
23:46:26 <kallisti> fuchsto: the >>= and >> plumbing passes the state along implicitly. and get retrieves it.
23:46:38 <kallisti> fuchsto: if you're not interacting with the outside world you should avoid IO completely.
23:46:50 <yitz> kallisti: it's an OpenGL app
23:46:52 <fuchsto> kallisti: Okay, now it makes sense
23:47:24 <Axman6> get = State (\s -> (s,s)), put newS = State (\s -> ((),newS))
23:47:31 <fuchsto> kallisti: Okay, so how would i increment (kind-of globally) without IO?
23:47:42 <kallisti> ...no clue. :P
23:47:47 <yitz> an IORef
23:47:49 <fuchsto> :D
23:47:51 <dmwit> fuchsto: To increment, stay in State.
23:48:03 <kallisti> I will say that pure functions are already an excellent representation of signals. :D
23:48:04 <dmwit> fuchsto: Only use runState on the very top-level thing, not some sub-computation.
23:48:28 <yitz> dmwit: it depends what kind of UI operations are needed in between
23:48:29 <fuchsto> kallisti: Of samples, not of signals :)
23:48:55 <kallisti> no, the samples are obtained from the function
23:48:57 <dmwit> If IO is necessary, you might consider using StateT and IO.
23:49:03 <kallisti> the function itself represents the continuous signal.
23:49:15 <dmwit> If somebody else is in control of the IO, you might consider something more subtle.
23:50:22 <dmwit> I've implemented an instance of MonadState for ReaderT IORef IO before, for example...
23:50:39 <fuchsto> kallisti: Well, i have base functions generating a signal depending on time t
23:50:49 <kallisti> fuchsto: what's ampTransformationFun
23:50:57 <roconnor> @free f : a -> (a,a)
23:50:58 <lambdabot> Extra stuff at end of line
23:50:59 <fuchsto> kallisti: an envelope
23:51:03 <roconnor> @free f :: a -> (a,a)
23:51:03 <lambdabot> $map_Pair g g . f = f . g
23:51:07 <kallisti> oh nevermind I found it
23:51:11 <fuchsto> kallisti: 'amplitude transformation over time'
23:51:23 <kallisti> right
23:51:34 <kallisti> Int -> TValue -> SValue -> SValue
23:51:37 <kallisti> can you decode this a bit for me?
23:52:06 <fuchsto> kallisti: It's   periodLength -> Time -> InputSampleValue -> OutputSampleValue
23:52:29 <kallisti> ah okay.
23:53:03 <fuchsto> kallisti: a plain old transfer function. Period length just means: "How many samples should i take to complete one period of this sine/saw tooth/square"
23:53:22 <kallisti> from my basic understanding of signal processing, an envelope would just e a higher-order function.
23:53:40 <kallisti> so it would take a function over time and produce a new one.
23:53:45 <kallisti> where the envelope is applied to each value.
23:53:47 <fuchsto> kallisti: It's not in the time domain, so i can't say "Generate a sine of 10 Hz", because the sample frequency is not known at this point
23:54:07 <kallisti> fuchsto: hm? you don't need to know the sample rate.
23:54:15 <fuchsto> i do!
23:54:32 <fuchsto> I need the sample rate to generate a signal with frequency 10Hz
23:54:53 <fuchsto> without the sampling frequency known, i can't decide how many samples i would need to complete a period
23:55:15 <dmwit> Shouldn't a signal with frequency 10Hz just be \t -> sin (t * 10 / tau) where tau = 2 * pi or some such thing?
23:55:27 <fuchsto> sine 10Hz with sampling frequency 100: 10 samples per period. With sampling frequency 200: 20 samples.
23:55:45 <kallisti> dmwit: right
23:55:48 <fuchsto> dmwit: Exactly, but t is not a frequency, it's a discrete time value
23:55:55 <kallisti> fuchsto: why?
23:56:00 <dmwit> Yeah, why?
23:56:13 <kallisti> given a continuous function you can produce the sampled values later
23:56:30 <kallisti> just apply the envelope as a pure function, then extract samples later.
23:56:40 <dmwit> You're not thinking with functions yet. =)
23:56:56 <fuchsto> that's rather probable :)
23:58:07 <kallisti> transfer env f t = env(t)*f(t)
23:58:08 <fuchsto> but my current problem still is: I want to produce a new signal (consisting of n samples) every tick
23:58:25 <fuchsto> kallisti: That's how my envelope functions are defines
23:58:28 <fuchsto> -defined
23:59:07 <fuchsto> okay, not quite, they expect a sample, not a function generating a sample
23:59:50 <fuchsto> Well, even if i was using continuous functions only, i still would need to read a new sample every tick.
