00:16:01 <BleuM937> Hello
00:16:31 <BleuM937> Have there been lots of changes to cabal-install recently? I've had very flaky performance
00:18:34 <BleuM937> cabal: dependencies conflict: ghc-7.0.4 requires bytestring ==0.9.1.10 however bytestring-0.9.1.10 was excluded because ghc-7.0.4 requires bytestring ==0.9.2.0
00:18:54 <BleuM937> This is really broken
00:19:01 <dcoutts> http://www.haskell.org/cabal/FAQ.html#dependencies-conflict
00:19:02 <BleuM937> Any ideas on how to resolve it?
00:20:36 <BleuM937> dcoutts thanks, I'll give a shot
00:21:17 <Veinor> is there a nice way to tell cabal 'upgrade this package and then reinstall everything necessary'?
00:22:39 <dcoutts> Veinor: cabal install blah --dry-run, when it complains that certain packages will be broken, list those to install too. You'll need cabal-install-0.14.x
00:24:13 <Veinor> ah, i see
00:26:53 <Veinor> dcoutts: doesn't work
00:26:58 <Veinor> it doesn't complain that anything breaks
00:27:27 <dcoutts> Veinor: you need cabal-install-0.14.x
00:27:30 <dcoutts> as I mentioned
00:27:39 <Veinor> $ cabal --version
00:27:41 <Veinor> cabal-install version 0.14.0
00:27:43 <Veinor> using version 1.14.0 of the Cabal library
00:28:03 <Veinor> oh, i wasn't clear
00:28:10 <Veinor> what i meant by 'reinstall everything necessary' was 'reinstall everything that depends on this package'
00:28:59 <dcoutts> ok that's different, what I suggested works for things that would actually be broken by installing the target
00:29:10 <Veinor> ah ok
00:29:15 <Veinor> is there any way to do what i want to do?
00:30:07 <dcoutts> not easily, you'd need to know the reverse deps of the source versions corresponding to all your installed packages
00:30:32 <Veinor> blah :(
00:31:15 <Veinor> on a related note, is there any work being done to making it so that you don't have to recompile reverse dependencies?
00:32:26 <dcoutts> Veinor: yes
00:33:16 <Veinor> awesome :) what exactly would that involve? i know nothing about compilers
00:33:21 <dcoutts> Veinor: and step 1 there was the new stuff in cabal-install-0.14.x so that you at least know when deps do currently get broken
00:33:38 <dcoutts> Veinor: there's a GSoC project about making a nix-like package store
00:35:57 <Veinor> package store?
00:48:37 <isson> take 3 ( Data.List.sort [1..]) will report error "out of memroy" , so i think Data.List.sort is strict function. is there a non-strict sort function in haskell library?
00:48:55 <isson> i cannot find it in google.
00:49:02 <c_wraith> how could that even work?
00:49:13 <adamt> You can't sort if you can't look.
00:49:16 <c_wraith> what element goes first?
00:49:48 <adamt> maybe one could actually do a running quick sort
00:50:07 <c_wraith> one single pass of quick sort looks at every element
00:50:13 <adamt> i know
00:50:32 <adamt> but you could just stream data to it, and stop at some point.
00:51:28 <isson> hmm...
00:51:38 <c_wraith> the problem is..  to be lazy, it needs to first produce the first element of the sorted list.  It can't do that without looking at every element.  I mean..  If it skips an element, how does it know that wasn't the smallest one?
00:51:45 <dzhus> can I do runST for ST action inside another ST?
00:51:57 <c_wraith> dzhus: sure.
00:51:58 <adamt> you could always partition the data you're getting into lower and higher than the pivot (which could just be the first value), and then sorting the above- and lower bunks as data arrives.
00:52:07 <adamt> c_wraith: I see your point.
00:52:25 <c_wraith> dzhus: you can't share refs between them, though.  Which probably isn't a problem at all
00:52:32 <isson> ah..~~~
00:54:01 <isson> thanks a ton. i think i misconceived "quick sort's lazy"
00:55:27 <c_wraith> it is...  as much as possible.  It only does O(n) work before returning the first element
00:56:02 <c_wraith> it's more or less the same thing as quick select, in that case
00:56:53 <isson> now i get it.
00:56:57 <dzhus> c_wraith: I don't need to; I get typing error though: http://hpaste.org/69534; runST invocation is at line 44.
00:57:00 <isson> thanks c_wraith
00:58:43 <c_wraith> dzhus: you're using g in the nested computation and the outer one
00:59:06 <c_wraith> dzhus: that's attempting to share a ref between scopes, which doesn't work
01:00:34 <c_wraith> but...  why use runST?
01:01:05 <c_wraith> you can just have d7 <- spawnParticles ... inside the do block
01:01:53 <dzhus> c_wraith: I want to turn spawnParticles into a pure function, once the PRNG state is fixed. Then I can use parMap.
01:02:34 <danr> dzhus: are you only using ST for a PRNG?
01:02:41 <c_wraith> Then make it take a generator that doesn't depend on s
01:03:03 <dzhus> danr: yes
01:04:06 <danr> dzhus: ok, you'll be better off using State rather than ST then for a start
01:04:22 <danr> ST is for when you need references or arrays
01:04:43 <dzhus> danr: mwc-random uses ST to efficiently update PRNG state
01:05:16 <danr> but they must surely have some reasonable API
01:05:47 <danr> oh I'm looking at it now, it does look rather fishy :) ignore my comments then
01:08:04 <danr> dzhus: sorry, I have only been using dons' bindings at http://hackage.haskell.org/package/mersenne-random-pure64, but I read now that they are a bit slower than the ST s versions.
01:10:06 <dzhus> danr: yes, because it has only pure interface. You can wrap (s0) → (x1, s1) rng function they have in ST though, but you'll end up having the same interface as mwc-random.
01:35:31 <dmwit> ski, shachaf: http://dmwit.com/gtk2hs
01:41:40 <srhb> Does anyone else have gtk2hs borking out on.. error: #error "Only <glib.h> can be included directly." ?
01:42:53 <dmwit> srhb: cabal update and try again
01:43:10 <dmwit> the 0.12.3.1 releases from a few days ago are (supposed) to include a fix for that
01:43:25 <srhb> I see. I think I updated yesterday, but I'll give it a shot. :) Thanks.
01:43:33 <dmwit> hm
01:44:13 <dmwit> Which package is it, in particular? And which version is it trying to install?
01:44:52 <dmwit> If the most recent release is still broken, we should push another and another until it works. =)
01:45:34 <srhb> dmwit: I'm not sure how to tell which package it is (I'm new to this). I know which file that triggers it though, "In file included from Graphics/UI/Gtk/General/hsgthread.c:29:0:"
01:46:33 <dmwit> Okay, the gtk package, then.
01:47:41 <dmwit> Well, there is no gtk-0.12.3.1 on Hackage. =P
01:48:35 <srhb> Oh.. So I have to get it from darcs to make it work?
01:48:43 <dmwit> I'm investigating. Give me a moment.
01:48:50 <srhb> Ok :) Thank you.
01:49:44 <dmwit> huh
01:49:51 <dmwit> Well, yes, the darcs version should work.
01:50:06 <dmwit> This unfortunately means some critical patch slipped through my fingers somewhere. annoying
01:50:18 <dmwit> Well, I can't make a release tonight; I'm much too tired.
01:50:47 <srhb> It's no worries. I was going to experiment with gtk2hs on Mac, but honestly, getting it to play nice has been a pain for months. I'll just stick with wx. :) Thanks for looking, anyway.
01:50:52 <dmwit> You should be able to build from darcs, though, or in the next few days I'll try to make a release that fixes this if you don't want to mess around with darcs.
01:51:14 <dmwit> Ah, yeah, gtk2hs on Mac has always been a bit of a pain.
01:51:20 <dmwit> I wish I knew what to do to make it easier.
01:51:47 <dmwit> ...it's especially hard when I don't have a Mac to test things out on... =P
01:52:58 <srhb> dmwit: Honestly, I don't think it would help. The way of getting the libraries is usually homebrew, which is broken as often as gtk2hs on Mac is. And when that isn't broken, the normal buildchain for C is. Sigh! :-)
01:53:27 <merijn> srhb: Really? I (and most OSX users I know) are using MacPorts
01:53:58 <merijn> I haven't really seen a compelling case why homebrew is better/worth switching
01:55:04 <srhb> merijn: If you check the wiki, most of the articles there have Homebrew as the first choice for getting libraries. I assume that's proportional with the number of users using Homebrew. I might be wrong.
01:55:36 <merijn> Homebrew users mostly seem really vocal about using homebrew
01:56:28 <srhb> They are. And I remember when it was better in the sense that it worked "more often". The argument was that MacPorts was unnecesarily complicated, but now I think it was just a matter of "more packages, more problems" - and now Homebrew suffers from the same issues,
01:56:52 <hamishmack> I don't user homebrew or macports.  Just https://live.gnome.org/GTK%2B/OSX/Building
01:57:19 <srhb> Well in this case, gtk actually did build on Homebrew.
01:57:25 <srhb> I was just complaining. :-)
01:58:44 <hamishmack> Then I build a GHC to use the jhbuild version of iconv…
01:58:49 <hamishmack> ./configure --with-iconv-includes=/Users/hamish/gtk/inst/include --with-iconv-libraries=/Users/hamish/gtk/inst/lib --prefix=/Users/hamish/ghcjs --with-macosx-deployment-target=10.6 --host=i386-apple-darwin
02:01:17 <dmwit> If he's gotten as far as "#error Only <glib.h> can be included directly", he's surely gotten Gtk itself installed already.
02:02:24 <hamishmack> Then the only other thing I do to get GTK on OS X for the Leksah binaries is to a few things to my .cabal/config
02:02:41 <hamishmack> extra-include-dirs: /Users/hamish/gtk/inst/include extra-include-dirs: /Developer/SDKs/MacOSX10.6.sdk/usr/include extra-lib-dirs: /Users/hamish/gtk/inst/lib extra-lib-dirs: /Developer/SDKs/MacOSX10.6.sdk/usr/lib
02:03:24 <hamishmack> Including MacOSX10.6.sdk fixes the binaries so that they work on 10.6 as well as 10.7
02:03:45 <hamishmack> but it causes problems with some template haskell so you might want to leave that out
02:54:11 <dzhus> I managed to overcome shared PRNG state issue by purifying top-level functions so that they accept Seed and only after runST seeds are restored into PRNG states; and parMap now works :3
03:16:49 <Franciman> hi all
03:17:05 <Franciman> hey guys can I do : "mystring" : listOfStrings
03:17:05 <srhb> Franciman: hi
03:17:06 <Franciman> ?
03:17:18 <srhb> Franciman: Yes.
03:17:30 <Franciman> but the compiler tells me that it's an error
03:17:32 <srhb> > "Foo" : "bar" : []
03:17:33 <lambdabot>   ["Foo","bar"]
03:17:54 <Franciman> ah maybe I should add the final []
03:18:00 <srhb> Franciman: Then listOfStrings is not a list of strings.
03:18:42 <Franciman> but it is
03:19:00 <srhb> Franciman: Really? ;)
03:19:07 <Franciman> if I type
03:19:09 <Franciman> :t args
03:19:10 <lambdabot> Not in scope: `args'
03:19:22 <Franciman> it tells me : args :: [String]
03:19:33 <srhb> Then "mystrings" : args should work just fine
03:19:55 <Franciman> the whole line is
03:19:57 <srhb> > let args = ["bar"] in "foo" : args
03:19:58 <lambdabot>   ["foo","bar"]
03:20:31 <Franciman> rawSystem $  "/opt/google/chrome/chrome" : args
03:21:07 <srhb> What's the type of rawSystem? And what is your error, exactly?
03:21:21 <Franciman> Couldn't match expected type `Char' with actual type `[Char]'
03:21:21 <Franciman>     In the first argument of `(:)', namely
03:21:21 <Franciman>       `"/opt/google/chrome/chrome"'
03:21:21 <Franciman>     In the second argument of `($)', namely
03:21:21 <Franciman>       `"/opt/google/chrome/chrome" : args'
03:21:22 <Franciman>     In the expression: rawSystem $ "/opt/google/chrome/chrome" : args
03:21:37 <Franciman> :t rawSystem
03:21:38 <merijn> Franciman: Please use hpaste.org or a similar site for multi-line pastes
03:21:38 <lambdabot> Not in scope: `rawSystem'
03:21:54 <Franciman> merijn sorry, I thought it was smaller
03:22:10 <srhb> Franciman: Its type is String -> [String] -> IO ExitCode
03:22:16 <Franciman> oh my god, yes
03:22:21 <srhb> :)
03:22:31 <Franciman> thanks a lot, and sorry for the paste mistake :)
03:23:00 <srhb> Franciman: No worries, and hpasting your entire problem at the very beginning is usually the fastest way to go :-)
03:23:11 <merijn> Franciman: If you look at the error it actually tells you that (in a bit convoluted manner)
03:23:21 <Franciman> yeah
03:23:41 <Franciman> now I have my 50 tabs in a chrome window :)
03:23:56 <merijn> Franciman: It's saying that it expected type Char as first argument for (:) (i.e. it's expecting a String) rather than the found type [Char]
03:24:16 <Franciman> yes, sometimes I don't think a lot :P
03:24:45 <ketil> join #cabal
03:24:49 <ketil> Sigh
03:26:07 <Franciman> btw, I am finding haskell very useful for system programming
03:26:17 <Franciman> it makes things so fast and clean to do
03:35:55 <ocharles> hmm, I can easily create a sort of Reader/IO monad with newtype: newtype Foo a = newtype { runFoo :: ReaderT Env IO a } deriving (Monad, etc). Is it possible to do the same but use a type variable for IO? Ie, runFoo :: MonadIO m => ReaderT Env m a
03:36:05 <ocharles> This sort of works, but newtype deriving fails
03:45:43 <savask> Hello. One library uses lazy bytestrings, and another strict ones. How do I convert a strict bytestring into lazy?
03:47:50 <fmap> savask: fromChunks/toChunks
03:48:12 <fmap> http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/Data-ByteString-Lazy.html#v:fromChunks
03:48:20 <ocharles> http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/Data-ByteString-Lazy.html#g:2
03:48:22 <ocharles> bah.
03:48:28 <savask> fmap: I need Strict -> Lazy
03:48:40 <ocharles> then use fromChunks with 1 chunk
03:48:59 <savask> Oh, let's try.
03:53:07 <savask> ocharles, fmap: Thanks, that worked.
04:01:54 <hpaste> luca pasted “state learning” at http://hpaste.org/69538
04:02:16 * hackagebot authenticate-oauth 1.3.0.1 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.3.0.1 (HiromiIshii)
04:02:26 <luca> trying to learn to use state monad, can't figure out the errors in this
04:02:38 <luca> mainly that it cannot match  (Int,b0) with actual type IO () in putStrLn $ show res
04:04:27 <luca> or if i take it's suggestion from hpaste to use print, get error cannot match expected [b0] with IO ()
04:05:00 <fmap> transform is [Int] -> [Int]
04:05:01 <unnali> luca: you don't need to use "<-" to assign the result of 'transform'
04:05:05 <unnali> because transform itself is a pure funciton.
04:05:07 <unnali> function*
04:05:10 <fmap> res <- transform wouldn't work
04:05:13 <luca> ahhhh of course
04:05:53 <luca> right, thanks
04:06:09 <fmap> luca: and btw you can replace your case expression with `when'
04:06:22 <hpaste> luca annotated “state learning” with “state learning (annotation)” at http://hpaste.org/69538#a69539
04:06:30 <fmap> when (x == 0) $ modify (0:)
04:22:20 * hackagebot Paraiso 0.3.1.1 - a code generator for partial differential equations solvers.  http://hackage.haskell.org/package/Paraiso-0.3.1.1 (TakayukiMuranushi)
04:26:44 <luca> @pl \x -> (fst x) ++ (snd x)
04:26:44 <lambdabot> uncurry (++)
04:27:07 <luca> forgot curry,uncurry even existed haha
04:36:19 <Cheery> Peaker: are you there?
04:41:31 <ocharles> urgh. I have something like: 'class Foo a where bar :: MonadIO m => m a'. I want to create an instance, 'instance Foo a where bar = do ... blah <- m a', assuming that bar is polymorphic, but I don't know how to bring either m or a into scope for the type annotation
04:42:12 <ocharles> (blah in this case is a postrgesql-simple 'query' call which returns FromRow r => m r, and I need to be explicit that it's returning an 'a')
04:48:59 <fmap> ocharles: i don't think i understand your question but there is -XScopedTypeVariables
04:49:06 <ocharles> yea, doesn't help
04:49:09 <ocharles> I ended up using asTypeOf
04:49:13 <ocharles> which does seem to do the job
04:49:35 <ocharles> well, fmap (asTypeOf (undefined :: something specific here)) blah
04:49:50 <hpc> :t fmap `asTypeOf` 5
04:49:51 <lambdabot> forall a b (f :: * -> *). (Functor f, Num (f b)) => (a -> b) -> f a -> f b
04:50:12 <ocharles> this whole module is a mess, but I'm just trying to get it to compile before I get surgical :)
05:34:16 <luca> @pl \xs -> sequence (map transf xs) >>= (return.concat)
05:34:16 <lambdabot> (join `fmap`) . sequence . map transf
05:34:58 <luca> not sure if that's clearer or not haha
05:37:31 * hackagebot tamarin-prover-utils 0.6.0.0 - Utility library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-utils-0.6.0.0 (SimonMeier)
05:37:33 * hackagebot tamarin-prover-term 0.6.0.0 - Term manipulation library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-term-0.6.0.0 (SimonMeier)
05:37:35 * hackagebot tamarin-prover 0.6.0.0 - The Tamarin prover for security protocol analysis.  http://hackage.haskell.org/package/tamarin-prover-0.6.0.0 (SimonMeier)
05:56:07 <YaZko> Hello
05:56:45 <luca> @pl \xs -> return [EArray $ concat xs]
05:56:45 <lambdabot> return . return . EArray . join
05:56:50 <luca> haha
05:57:32 <YaZko> I would have a little question : I have a function whose type is a -> IO Bool, can I still use the "partition" function with it ? And if so, how ? Thought I got the monads, but once I'm on myself on practice...
05:58:03 <Axman6> YaZko: no. the types don't match:
05:58:06 <Axman6> :t partition
05:58:07 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:58:15 <Axman6> why does it need IO anyway?
05:58:27 <Axman6> @hoogle partition
05:58:27 <lambdabot> Data.List partition :: (a -> Bool) -> [a] -> ([a], [a])
05:58:28 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
05:58:28 <lambdabot> Data.Text partition :: (Char -> Bool) -> Text -> (Text, Text)
05:58:55 <YaZko> I need it because I extract my boolean judgment from an IORef field
05:59:09 <Axman6> @hoogle Monad m => (a -> m Bool) -> [a] -> m [b]
05:59:09 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
05:59:10 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:59:10 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:59:27 <Axman6> @hoogle Monad m => (a -> m Bool) -> [a] -> m ([a],[a])
05:59:28 <lambdabot> No results found
05:59:41 <luca> :t liftM partition
05:59:42 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m ([a] -> ([a], [a]))
06:00:07 <Axman6> YaZko: that sounds like a pretty horrible thing to do. why are you using an IORef like that?
06:00:20 <JamesRustle> Axman6: there are ones in Extra.List and Control.Monad.ListM
06:01:02 * Axman6 's battery is dying, so he's going to sleep
06:01:12 <YaZko> Well I'm working on a compiler, making an internship in a lab, so it does not come from me. Anyway, I can change it if needed, but I first wondered if I could do the job with it
06:01:57 <JamesRustle> sure, but not with partition
06:02:03 <Axman6> compilers are expressed pretty naturally without the need for very much IO at all in Haskell
06:02:09 * Axman6 -> sleep
06:02:55 <YaZko> Sure, and the guy who developed it used very few of them, but here I have to admit that a mutable field is kind of confortable
06:04:12 <YaZko> So the point is that I kind of have to rewrite the partition function with my particular signature if I want to deal with it this way ?
06:04:28 <JamesRustle> or import it
06:04:31 <JamesRustle> but yes
06:04:49 <JamesRustle> hmm...
06:04:51 <Peaker> Cheery, now I am here
06:05:05 <burbul> @pl f x = [x]
06:05:05 <lambdabot> f = return
06:05:23 <YaZko> what do you mean by import ?
06:05:27 <unnali> :t mapM (undefined :: (a -> IO Bool))
06:05:28 <lambdabot> forall a. [a] -> IO [Bool]
06:05:30 <srhb> YaZko: Well, would it be a problem to lift all of them to IO?
06:05:42 <adamt> YaZko: Maybe you should tell what you actually are trying to accomplish, or paste some code.
06:05:49 <JamesRustle> YaZko: wait, you don't know what 'import' is?
06:06:05 <YaZko> adapt : I don't think so
06:06:23 <JamesRustle> @pl (\x -> f x >>= \b -> return (b, x))
06:06:23 <lambdabot> liftM2 (>>=) f ((return .) . flip (,))
06:06:32 <YaZko> JamesRustle : I can try
06:06:56 <Cheery> Peaker: I only implemented document model yesterday. I changed the design quite a bit.
06:07:04 <YaZko> No no I do, I mean did it means that I missed the existence of the adequate function in the libraries ?
06:07:12 <Cheery> Turns out it doesn't work well to treat trees as text
06:07:18 <JamesRustle> YaZko: yes
06:07:33 <Peaker> Cheery, Ah.. I have much work on type inference
06:08:06 <JamesRustle> :t do xs' <- mapM (\x -> do b <- ?f x; return (b, x)) ?xs; return $ partition fst xs'
06:08:07 <lambdabot>     Ambiguous occurrence `fst'
06:08:07 <lambdabot>     It could refer to either `L.fst', defined at <local>:12:0
06:08:07 <lambdabot>                           or `Data.Tuple.fst', imported from Data.Tuple
06:08:12 <JamesRustle> @undefine
06:08:13 <JamesRustle> :t do xs' <- mapM (\x -> do b <- ?f x; return (b, x)) ?xs; return $ partition fst xs'
06:08:14 <lambdabot> forall a (m :: * -> *). (?f::a -> m Bool, Monad m, ?xs::[a]) => m ([(Bool, a)], [(Bool, a)])
06:08:15 <YaZko> JamesRustle : ho ok my bad
06:08:26 <luca> how can we patern match against a list of 1-element lists
06:08:48 <JamesRustle> luca: not directly. you need a guard or something
06:09:18 <YaZko> Well I'll check this, thanks for all your help
06:09:59 <Cheery> Peaker: if I'm not too busy on other things I'll make a simple implementation very soon. :)
06:10:07 <JamesRustle> isSingleton [x] = True; isSingleton _ = False; ... case f a b c of xs | all isSingleton xs -> ...
06:10:35 <luca> can we do this in a do block? like xs | all isSingleton xs <- ...
06:10:36 <luca> :P
06:10:52 <Cheery> Peaker: this is where I'm going at: http://bpaste.net/show/zyB0wmQXl8xJ5tpeiyhp/
06:11:04 <luca> i want to match against singleton lists as a sort of assertion, the result isn't changed, but i would get a runtime error when something has gone wrong at least
06:11:50 <JamesRustle> xs <- ...; ensure (all isSingleton xs); ...
06:11:50 <luca> or maybe should just add a more specific function in this case which will be typed as returning a singleton list isntead of getting runtime errors
06:11:56 <Peaker> Cheery, but as I said earlier, I think editors should edit structures, not approximations of structures or visualization or serialization of structures
06:11:57 <JamesRustle> definition of 'ensure' left as an exercise for the reader
06:12:01 <luca> hah
06:12:10 <Cheery> Peaker: why do you think so?
06:12:34 <Peaker> Cheery, because editing these non-structures wastes most of the UI space on nonsense, rather than meaningful editing operations
06:12:35 * hackagebot repa 3.2.1.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.2.1.1 (BenLippmeier)
06:12:37 * hackagebot repa-algorithms 3.2.1.1 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-3.2.1.1 (BenLippmeier)
06:13:09 <JamesRustle> Peaker: that sounds like it would make it hard to write polyglots :-)
06:13:18 <Peaker> Cheery, if every single input you can give is meaningful, less input will do more than if the majority of inputs just destroy the syntax/structure/etc...
06:13:42 <Peaker> Also, if you have a guarantee the structure is always valid, it makes various other features much better/easier (e.g: merge conflict resolution)
06:13:52 <Cheery> Peaker: ok
06:13:52 <Peaker> JamesRustle, heh
06:14:11 <JamesRustle> reference: http://mauke.hopto.org/stuff/poly.poly
06:14:14 <Cheery> Peaker: agreed. It has implications but not too bad ones.
06:14:27 <shirt> is it bad to use XRank2Types ?
06:14:44 <JamesRustle> shirt: no, but it should probably be a LANGUAGE pragma
06:15:09 <nand`> what's the difference between Rank2Types and RankNTypes, other than that the former has a few more restrictions?
06:15:22 <JamesRustle> none
06:15:46 <Cheery> Peaker: here's my document format http://bpaste.net/show/S23J74o0WE8xh0NSUWCZ/
06:16:34 <rtharper> nand`: I believe rank-2 type checking decidable, Rank-n is not
06:16:37 <Cheery> Editor will convert that document into frames, very similar to what web browsers are doing
06:16:39 <rtharper> Hence the distinction
06:16:53 <rtharper> is decidable*
06:17:00 <nand`> rtharper: what does “decidable” mean in this context?
06:17:11 <JamesRustle> rtharper: I don't know any Haskell compiler that actually infers rank-2 types
06:17:21 <Cheery> Peaker: I ended up to that structure as it was easy to implement in a day. :)
06:17:29 <nand`> I checked it a while ago and GHC didn't infer rank 2 types, instead simply erroring
06:17:39 * hackagebot repa-io 3.2.1.1 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-3.2.1.1 (BenLippmeier)
06:17:41 * hackagebot repa-examples 3.2.1.1 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-3.2.1.1 (BenLippmeier)
06:17:49 <rtharper> JamesRustle: Ah, that may be, but I believe rank-2 decidable type inference is decidable ;)
06:17:51 <Peaker> Cheery, I used to love Python.. now when I see this Python code all I can see is so much verbosity :)
06:17:51 <unnali> @hoogle [a -> b] -> a -> [b]
06:17:52 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
06:17:52 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
06:17:52 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
06:18:06 <Cheery> Peaker: I used to love python too.. :D
06:18:12 <unnali> anyone know of an exact match for what I want?
06:18:28 <JamesRustle> unnali: sequence
06:18:48 <nand`> unnali: flip
06:19:02 <nand`> Caleskell's flip, that is
06:19:03 <nand`> :t flip
06:19:04 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:19:08 <Cheery> Peaker: Did you heard me mentioning yesterday that I think every tool should have a simple version, which can be implemented quickly from scratch?
06:19:12 <unnali> nand`: ta!
06:19:26 <shirt> JamesRustle: ok thanks :)
06:19:30 <merijn> unnali: That's Caleskell flip, though. Not Haskell flip
06:19:31 <nand`> unnali: sequence works too
06:19:38 <Cheery> well that applies to interactive editing tools at least I think.
06:19:44 <nand`> but for sequence you need Control.Monad.Instances
06:19:59 <Cheery> somewhat to operating systems as well
06:20:01 <unnali> aha, that's what I'm missing.
06:20:02 <JamesRustle> nand`: hugs supports rank 2 types but not rank n AFAICS
06:20:13 <nand`> JamesRustle: I see
06:20:14 <unnali> for Monad ((->) a)?
06:20:18 <nand`> unnali: yeah
06:20:30 <unnali> great! :)
06:20:35 <unnali> thanks very much.
06:21:01 <JamesRustle> > map ($ 5) [id, negate, (^2)]
06:21:02 <lambdabot>   [5,-5,25]
06:21:14 <nand`> It's funny how sequence and flip both work here, but from different “directions”; flip has the (->) in the type but is polymorphic in the functor used, sequence has [] in the type but is polymorphic in the monad used :P
06:21:20 <unnali> JamesRustle: that's a bit more straightforward, huh.
06:21:25 <Peaker> Cheery, You mean a "demo"?
06:21:46 <nand`> JamesRustle: that's how Caleskell's flip is implemented either way, \x -> fmap ($x)
06:21:56 <Peaker> Cheery, it's not always much easier than the full thing - so we're going for the full thing, and I think we're making nice progress
06:22:04 <nand`> oh, except with the arguments flipped
06:22:29 <JamesRustle> nand`: ap and (=<<) are sort of dual
06:22:46 <JamesRustle> > ap (,) length "asdf"
06:22:47 <lambdabot>   ("asdf",4)
06:22:51 <JamesRustle> > (=<<) (,) length "asdf"
06:22:52 <lambdabot>   (4,"asdf")
06:22:57 <Peaker> @type ap
06:22:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:23:13 <Peaker> @type (=<<)
06:23:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
06:23:52 <luca> @pl \x -> do { x' < t x; return [x'] }
06:23:53 <lambdabot> (line 1, column 10):
06:23:53 <lambdabot> unexpected "{"
06:23:53 <lambdabot> expecting variable, "(", operator or end of input
06:24:10 <luca> @pl \x -> [x]
06:24:10 <lambdabot> return
06:24:11 <JamesRustle> :t liftM return
06:24:11 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 a1 -> m1 (m a1)
06:24:25 <JamesRustle> :t fmap pure
06:24:26 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Applicative f, Functor f1) => f1 a -> f1 (f a)
06:24:36 <Cheery> Peaker: I mean.. say we have text editors. A human can implement notepad in hours.
06:24:56 <JamesRustle> :t [ap, (=<<) . flip]
06:24:57 <lambdabot> forall a (m :: * -> *) b. (Monad m, Functor m) => [m (a -> b) -> m a -> m b]
06:25:17 <Peaker> Cheery, so what?
06:25:21 * byorgey doesn't think he could implement notepad in hours.
06:25:35 <Cheery> It's possible to implement notepad and then improve it to better text editor.
06:25:49 <Cheery> I think that should apply to structural editing as well.
06:25:56 <Peaker> Cheery, if we had no editing tools whatsoever, it might have been good to implement just anything at all.. now that we have editing tools, it doesn't make sense to work on something very sub-par
06:26:16 <Peaker> Cheery, I think we've reached (or nearly reached) the dead-end/local-optimum of text editors
06:26:26 <Peaker> Cheery, did you run our structural editor?
06:26:35 <Cheery> Peaker: sure
06:26:36 <byorgey> "build something simple and then improve it" only gets you so far.  To build something more complex you have to think hard about the design up front.
06:26:54 <nand`> that or days of refactoring
06:27:01 <luca> According to lambdabot, \x -> [x] is the same as return; which makes sense. but then why can I not translate \x -> do { x' <- t x; return [x'] } as \x -> (t x) >>= return
06:27:03 <byorgey> if you try to just improve on something simple you just get yourself into a mess after a certain point.
06:27:36 <nand`> luca: return x is not return [x]
06:27:40 <nand`> that would be return (return x)
06:27:42 <JamesRustle> luca: because you removed one return
06:28:07 <luca> haha yeh i see; \x -> (t x) >>= (return.return) is fine :P
06:28:12 <JamesRustle> @undo \x -> do { x' <- t x; return [x'] }
06:28:12 <lambdabot> \ x -> t x >>= \ x' -> return [x']
06:28:15 <JamesRustle> @. pl undo \x -> do { x' <- t x; return [x'] }
06:28:15 <lambdabot> (return `fmap`) . t
06:28:22 <JamesRustle> a.k.a. liftM return . t
06:28:47 <nand`> :t \x -> ?t x >>= return . return
06:28:48 <lambdabot> forall t (m :: * -> *) a (m1 :: * -> *). (?t::t -> m a, Monad m, Monad m1) => t -> m (m1 a)
06:29:12 <Cheery> byorgey: actually.. if you try jump straight into something, that usually also ends up in a mess.
06:29:34 <Peaker> luca,   a >>= return . b          ==      liftM b a
06:30:13 <nand`> why would lambdabot section (return `fmap`) like that instead of simply (fmap return . t)
06:30:21 <byorgey> Cheery: well, you're right.  My best work has always looked like this: (1) write something simple (2) improve it (3) get stuck (4) completely throw it away and think hard about the design (5) write something awesome
06:30:36 <byorgey> and I don't think steps (1)-(3) can be avoided.
06:30:37 <Cheery> byorgey: agreed the throwaway is important.
06:30:50 <nand`> boils down to knowing what you're working with before you're able to think about its design
06:30:55 <byorgey> right.
06:31:17 <Peaker> we did quite a few throwaways of structural editor prototypes
06:31:41 <byorgey> excellent, so hopefully you are now on to steps (4)-(5) =)
06:31:56 <Cheery> also it's true a proper editor like vim takes longer than a day to implement
06:32:10 <byorgey> although I think step (1) sometimes recursively contains (1)-(5)
06:32:11 <Cheery> but I think you can implement a simple version of vim in hours.
06:32:26 <Peaker> We've already got something preliminary and awesome :)
06:32:32 <byorgey> yay =)
06:32:37 * hackagebot haha 0.3.1.1 - A simple library for creating animated ascii art on ANSI terminals.  http://hackage.haskell.org/package/haha-0.3.1.1 (ErikHesselink)
06:32:39 * hackagebot gloss-raster 1.7.4.4 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.7.4.4 (BenLippmeier)
06:32:42 <Cheery> anyway
06:32:56 <Cheery> once I get the simple version of the editor done.. I think I'll look into virtual machines next :)
06:32:57 <Peaker> now I just did steps (1-3) on the type inference part -- going to do 4 and hopefully 5 now :)
06:33:04 <byorgey> ooh, gloss-raster, nice =)
06:33:10 <nand`> :t ?t >=> return . return -- luca
06:33:11 <lambdabot> forall a (m :: * -> *) b (m1 :: * -> *). (?t::a -> m b, Monad m, Monad m1) => a -> m (m1 b)
06:33:25 <applicative> Cheery: what is your editor going to do?  I guess you said somewhere
06:33:30 <Cheery> an useful structural programming editor implies you can run the code it produces.
06:33:38 <Peaker> Cheery, of course
06:33:57 <Peaker> Cheery, we're going to get to code execution pretty soon.. I predict a month or two of work
06:34:06 <Peaker> we need to get basic typing right first
06:34:08 <Cheery> I'm going to get it in a day.. two.
06:34:19 <Peaker> Cheery, we clearly have differing goals...
06:34:31 <Cheery> actually no
06:34:38 <Peaker> I'm not after making something useful *now*, I'm after making the most awesome possible editor for functional programming :)
06:34:45 <Cheery> but we have differing approaches to getting there
06:34:51 <Peaker> (in a reasonable time frame)
06:35:07 <Peaker> where reasonable includes "a year or two"
06:35:36 <unnali> JamesRustle, nand`, merijn: only just finished going through the types for sequence and instance Monad ((->) r), finally grokked it. Thanks for the enlightenment!
06:36:01 <Cheery> I've been working on this years so I think it'd be reasonable to get something asap. :)
06:36:56 <Cheery> I have all sort of visions of what this kind of editor could do.. but I don't know how to get them all yet.
06:37:25 <merijn> I think an editor is actually undershooting my vision
06:37:37 * hackagebot gloss-examples 1.7.4.4 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.4.4 (BenLippmeier)
06:37:48 <merijn> But so far I haven't *really* considered writing my own OS
06:37:55 <Cheery> merijn: I have.
06:38:09 <luca> have a Maybe a, and a function a -> M a and want to make that function into: Maybe a -> M (Maybe a)
06:38:13 <Cheery> but been thinking I'd like to use it on linux as well
06:38:51 <merijn> Meh, I've come to realise I dislike *nix and the way it holds OS's back
06:39:02 <merijn> luca: Is M a monad?
06:39:03 <luca> holds back?
06:39:05 <luca> yes
06:39:09 <Cheery> afk, going to do some errands.
06:39:32 <JamesRustle> luca: return
06:39:37 <merijn> luca: lift/MaybeT something like that should help
06:39:42 <JamesRustle> er
06:40:05 <JamesRustle> let me change that to a -> M b to avoid confusing myself
06:40:08 <Peaker> luca, so you want:  b -> M b    ?   "pure" or "return" ?
06:40:11 <mgsloan> Peaker: Other than the over-sized-ness, I like the animation aspects of the implementation.  Very cool!  It makes a lot of sense to me to take advantage of persistence-of-vision / consistency across frames
06:40:18 <luca> aka want to shortern: x' <- case (x) of \n Just y -> Just f y \n Nothing -> Nothing
06:40:39 <JamesRustle> @djinn (Monad m) => (a -> m b) -> Maybe a -> m (Maybe b)
06:40:39 <lambdabot> -- f cannot be realized.
06:40:40 <luca> i think.
06:40:47 <Peaker> merijn, yes, we also think the OS needs to be replaced too... but the best editor in existence is already ambitious enough
06:40:51 <merijn> luca: You can write your own combinator for that (which is convenient if you don't use it alot)
06:41:09 <mgsloan> Peaker: did you all look at diagrams?  Was the main concern performance?
06:41:16 <Peaker> mgsloan, Cool :)  Yeah we think animations are really important to convey what's going on when things all move around
06:41:28 <merijn> Peaker: Did you see the 7 laws of sane personal computing? Guy who wrote it was working on his own, but he's closed the code because he got to much criticism
06:41:32 <Peaker> mgsloan, We didn't look -- but diagrams itself said it wasn't meant for real time graphics
06:41:49 <Peaker> mgsloan, we want smooth animations, it's pretty important for the feel of it
06:41:57 <mgsloan> yup, fair point!
06:42:00 <Peaker> merijn, nope, what's that?
06:42:02 <merijn> Some nice ideas in there: http://www.loper-os.org/?p=284
06:43:04 <merijn> luca: Yeah, if you read about some of the stuff that was invented in the 70s *nix is really backwards in some regards
06:43:45 <merijn> Don't get me wrong, pipes, "everything is a file" and a bunch of other stuff are great ideas, but that's hardly enough to call it the "best OS we can ever come up with"
06:43:45 <nand`> where's our fully pure and lazy OS?
06:44:21 <nand`> features: type safe pipes/shell, no such thing as daemons (after all, you're not observing their output)
06:44:26 <merijn> I mean, why are sockets not files?
06:44:58 <yitz> merijn: sockets were only invented in the 80's.
06:45:17 <yitz> i think
06:45:25 <Peaker> merijn, yeah, I agree with many of those ideas... that's why I have a pet peeve of hating the stupid "Save" button, for example
06:45:31 <merijn> yitz: So? They could've easily been implemneted using file descriptors, making the nicely compatible with everything else
06:45:36 <merijn> Peaker: Word.
06:45:40 <Peaker> merijn, and I also believe in orthogonal persistence/caching, and automatic background compilation
06:45:42 <hpaste> luca pasted “maybe stuff” at http://hpaste.org/69543
06:45:54 <luca> I want to get this into one declaration
06:46:14 <yitz> Peaker: the Save button is gone in Mac OS X Lion. Windows is heading that way too, but it will take longer.
06:48:10 <Peaker> yitz, cool.. undo buffers do need to persist, though, when save is gone
06:48:22 <Peaker> does Lion do that?
06:48:50 <merijn> They removed "Save As", not "Save"
06:49:11 <merijn> And they automatically lock files that haven't been edited for a while, which is dumb behaviour
06:51:06 <Peaker> merijn, I'm speculating that Gnome/Unity will copy all these behaviors from Apple in a couple of years :-(   They seem to be copying and and all Apple behavior regardless of whether it makes sense
06:52:30 <hpaste> merijn annotated “maybe stuff” with “maybe stuff (annotation)” at http://hpaste.org/69543#a69544
06:52:38 * hackagebot gloss-examples 1.7.4.5 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.4.5 (BenLippmeier)
06:52:48 <merijn> luca: I'd write a combinator like that and then use "foo myFunc"
06:52:50 * applicative notices that homebrew now carries 'urweb' 
06:53:09 <merijn> You can probably write it nicer/cleaner, but I can't be arsed to figure it  out
06:53:32 <luca> haha okay
06:53:33 <luca> thanks
06:54:15 <merijn> luca: If you have a lot of different stuff you write like this you might want a Monad Transformer, but it's hard to tell from this code
06:55:04 <luca> I've not done much monad stuff before, so I think i want to stay away from transformers for now ;P
06:55:05 <hpaste> applicative annotated “maybe stuff” with “maybe stuff (annotation) (annotation)” at http://hpaste.org/69543#a69545
06:55:31 * applicative cant 'return Maybe'
06:55:39 <merijn> oh, whoops
06:55:41 <merijn> Typo :p
06:57:23 <hpaste> Peaker annotated “maybe stuff” with “maybe stuff (annotation) (annotation) (annotation)” at http://hpaste.org/69543#a69546
06:57:56 <Peaker> foo f = maybe (return Nothing) (liftM Just . f)      <-- this is basically inlining MaybeT
06:58:39 <luca> yay concise
07:00:00 <hpaste> d-snp pasted “Why does it expect readMVar to return a Maybe?” at http://hpaste.org/69547
07:00:32 <d-snp> I apparently still don't get do syntax
07:00:40 <d-snp> could anyone take a quick peek?
07:00:54 <byorgey> d-snp: 'return Map.lookup tag assocs' looks suspicious
07:01:03 <byorgey> you probably want  return (Map.lookup tag assocs)
07:01:07 <byorgey> or return $ ...
07:01:23 <byorgey> what you have is  ((return Map.lookup) tag) assocs
07:01:44 <d-snp> changing that didn't fix it
07:01:48 <byorgey> d-snp: also, return Just (association socket) has the same problem
07:02:15 <byorgey> also also, the 'Nothing' on line 5 needs to be lined up with the 'Just' on line 3
07:02:32 <d-snp> ahh that fixed it
07:02:33 <d-snp> thanks
07:02:36 <WraithM> Oh, good catch
07:02:41 <d-snp> damn, I need to be more precise
07:02:41 <byorgey> great =)
07:03:42 <WraithM> So, I want to do a simulation over many different seeds, and my simulation involves infinite lists of random numbers. I don't want to cut my infinite lists to finite lists. I was thinking that I would make a list of infinite lists, but I've been having trouble implementing that. :/ Is there a better way to go about what I'm doing?
07:04:32 <WraithM> What I can do already is just do newStdGen and print out the result once it's done, but I want to do computations on the results.
07:04:33 <applicative> d-snp: do you need $ or brackets after return?
07:04:47 <byorgey> Haskell eats lists of infinite lists for breakfast.
07:04:47 <applicative> oh byorgey seems to have said.
07:04:56 <WraithM> Good :D
07:04:58 <WraithM> Perfect
07:05:00 <nand`> infinite lists of infinite lists*
07:05:00 <d-snp> yeah, I needed $ in both returns
07:05:11 <WraithM> Yeah, I want infinite lists of infinite lists :D
07:05:23 <nand`> > map (\x -> [x..]) [0..]
07:05:24 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
07:05:41 <d-snp> :D
07:05:41 <applicative> > let os = 0:os ; oos = 1:os  ; master = iterate (0:)  oos ; crop n = take n . map (take n) in crop 5 master
07:05:43 <lambdabot>   [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]]
07:05:50 <applicative> > let os = 0:os ; oos = 1:os  ; master = iterate (0:)  oos ; crop n = take n . map (take n) in crop 3 master
07:05:52 <lambdabot>   [[1,0,0],[0,1,0],[0,0,1]]
07:06:02 <Peaker> if Haskell had ScopedTypeVariables by default, and you could do:  "do :: MyMonad m" to specify a monad explicitly, it would make debugging some type errors easier...
07:06:14 <untitled> how do I call function with three arguments with iterate? and why do I have to use flip with iterate?
07:06:28 <merijn> untitled: Partially apply the function?
07:06:29 <nand`> > let os = 0:os; oos = 1:os in iterate (0:) oos
07:06:30 <lambdabot>   [[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
07:06:31 <applicative> @type iterate
07:06:32 <lambdabot> forall a. (a -> a) -> a -> [a]
07:06:43 <d-snp> Peaker: it would
07:07:03 <nand`> oh, I see what you did there
07:07:28 <untitled> merijn: you mean with flip?
07:07:37 <applicative> @type flip iterate
07:07:38 <lambdabot> forall a. a -> (a -> a) -> [a]
07:07:44 <nand`> > iterate (0:) (1 : repeat 0)
07:07:45 <lambdabot>   [[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
07:07:47 <applicative> @type flip iterate 0
07:07:48 <lambdabot> forall a. (Num a) => (a -> a) -> [a]
07:08:15 <WraithM> Yeah, I guess I'm having trouble dealing with the seeds in my implementation :/ Let me post some code or something. One sec.
07:08:51 <applicative> untitled: what is the example like?  what is the function you are giving to iterate
07:10:19 <rekado> Hi, I'd like to auto derive an instance for an existing data type whose definition  is in a separate module.
07:10:22 <rekado> Is this possible?
07:10:35 <JamesRustle> yes
07:10:40 <applicative> StandaloneDeriving
07:10:50 <rekado> thanks, I'll look it up.
07:11:01 <applicative> derive instance MyClass MyType
07:11:03 <rekado> want to derive Typeable which looks difficult to implement manually.
07:11:12 <applicative> or is that the syntax?
07:11:18 * applicative is easily mixed up
07:11:52 <applicative> rekado: Typeable should never be handwritten.
07:12:14 <applicative> i guess that should work, you need DeriveTypeable too of course
07:12:17 <untitled> applicative: well, I have a bigger problem here, I need to call 2 functions 10 times and after each time I have to pass the results of the second function to the first one, or just return 2 results after 10 iterations
07:12:39 <luca> @pl \x -> f n x y
07:12:39 <lambdabot> flip (f n) y
07:12:45 <rekado> applicative: thank you
07:14:27 <hpaste> WraithM pasted “Infinite list of infinite list of random numbers” at http://hpaste.org/69548
07:15:57 <luca> @pl \x y -> f x y
07:15:57 <lambdabot> f
07:16:04 <luca> haha oops
07:16:20 <luca> @pl \x y -> f (g x) (g y)
07:16:20 <lambdabot> (. g) . f . g
07:16:32 <luca> ew
07:16:42 <applicative> WraithM maybe you should fill a sort of pascals triangle shape series of finite lists, then turn it sideways
07:17:24 <qubodup> hello
07:17:47 <WraithM> Hm
07:17:51 <WraithM> turn it sideways?
07:18:30 <qubodup> it seems like heist (using snap) converts "&amp;" to "&" but converts "&amp;amp;" to "&amp;amp;"
07:19:38 <applicative> because the parser thinks "&amp;amp;" doesn't make sense?
07:21:07 <applicative> WraithM, my thought is half baked but I think familiar.  If you picture the first infinite as starting at the origin and extendign up to infinity; and the second as to the right of it, above one
07:21:44 <applicative> the think of the line from  (1,0)  (0201), and from (2,0) to (0,2)
07:22:08 <applicative> the sequence of them corresponds to an infinite sequence of finite lists
07:22:19 <WraithM> Sure
07:22:36 <applicative> WraithM: I guess I am thinking of the way Cantor enumerated the rational numbers  :)
07:22:42 <WraithM> :D
07:23:13 <Peaker> @let infixr 2 ~> ; (before ~> after) f = after . f . before
07:23:14 <lambdabot>  Defined.
07:23:58 <applicative> > let   pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1] in take 3 pascal
07:24:00 <lambdabot>   [[1],[1,1],[1,2,1]]
07:24:01 <Peaker> @type [\f g x y -> f (g x) (g y), \f g -> g ~> g ~> id $ f]
07:24:02 <lambdabot> forall t a1 a. (Functor ((->) t)) => [(a1 -> a1 -> a) -> (t -> a1) -> t -> t -> a]
07:24:19 <applicative> WraithM: you need the reverse of this operation, so to say  ^^^
07:25:35 <applicative> wait, no, you need such an operation, but then define the infinite list of infinite lists
07:25:41 <nand`> uh
07:25:45 <Peaker> god damn Caleskell
07:25:49 <applicative> so
07:25:59 <applicative> > let   pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1] in map  head pascal
07:26:00 <JamesRustle> Peaker: ?
07:26:01 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:26:09 <nand`> :t let f g -> let (g', g'') = split g in randoms g' : f g'' in f
07:26:10 <lambdabot> parse error on input `->'
07:26:14 <applicative> > let   pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1] in map  head (tail pascal)
07:26:15 <nand`> :t let f g = let (g', g'') = split g in randoms g' : f g'' in f
07:26:16 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:26:17 <lambdabot> forall t a. (Random a, RandomGen t) => t -> [[a]]
07:26:21 <Peaker> @let infixr 2 ~> ; (before ~> after) f x = after (f (before x))
07:26:22 <nand`> ^ does this work?
07:26:23 <lambdabot>  Defined.
07:26:29 <applicative> woops
07:26:54 <applicative> > let   pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1] in map  (head .  tail) pascal
07:26:55 <Peaker> @type [\f g x y -> f (g x) (g y), \f g -> g ~> g ~> id $ f]
07:26:55 <lambdabot>   [*Exception: Prelude.head: empty list
07:26:56 <lambdabot> forall t t1 t2. [(t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2]
07:27:11 <applicative> > let   pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1] in map  (head .  tail) $  tail pascal
07:27:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:27:34 <Peaker> JamesRustle, Cale put arbitrary "enhancements" of Haskell's Prelude into lambdabot, so whenever you want to show something about Haskell, you end up showing something about Caleskell instead, to everyone's great confusion
07:27:41 <applicative> > let   pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1] in map  (head .  tail . tail)  ( tail $ tail pascal)
07:27:43 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
07:28:05 <JamesRustle> Peaker: was it really Cale?
07:28:25 <Peaker> luca, your @pl of \x y -> f (g x) (g y)    is:  (g ~> g ~> id) f      if you want
07:28:39 <luca> ~> wtf
07:28:39 <Peaker> JamesRustle, yes, he runs lambdabot
07:28:47 <luca> :t ~>
07:28:48 <lambdabot> parse error on input `~>'
07:28:52 <luca> hah
07:28:55 <JamesRustle> Peaker: that doesn't mean he maintains it
07:29:09 <Peaker> luca, it's a nice little combinator someone devised a while back:      f ~> g       modifies a function by applying f on the argument and g on the result
07:29:16 <applicative> WraithM: so isn't there a way to define this as a general operation?
07:29:32 <Peaker> f ~> g ~> h      applies f,g,h on a,b,c  in the type:   a -> b -> c
07:29:35 <nand`> :t unfoldr (Just . (randoms *** id) . split)
07:29:36 <lambdabot> forall a b'. (Random a, RandomGen b') => b' -> [[a]]
07:29:43 <Peaker> very "visual" :)
07:29:58 <hpaste> “iterate function with 3 args” pasted “untitled” at http://hpaste.org/69549
07:30:02 <qubodup_> applicative: I believe it has the duty to convert "&amp;" to "&amp;"
07:30:30 <Peaker> JamesRustle, he has defended these enhancements before
07:30:40 <JamesRustle> so have I
07:31:06 <applicative> qubodup_: could be a bug I wonder what library heist is using
07:31:09 <Peaker> :t (~>)
07:31:10 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t2 -> t3) -> (t1 -> t2) -> t -> t3
07:31:33 <Peaker> JamesRustle, why? :P
07:31:45 <parcs`> qubodup_: ask in #snapframework :)
07:32:35 <applicative> qubodup_: where is the "&amp;amp;" coming from?
07:32:55 <untitled> Peaker: was (~>) for me?
07:33:01 <WraithM> applicative: I think I lost you. Define your pascal function as a general operation?
07:33:12 <hpaste> nand` annotated “Infinite list of infinite list of random numbers” with “Infinite list of infinite list of random numbers (annotation)” at http://hpaste.org/69548#a69550
07:33:37 <WraithM> Oh!
07:33:40 <WraithM> Thank you!
07:33:43 <applicative> WraithM: I was just using the familiar  pascals triangle construction as an illustration of series of finite lists
07:33:56 <WraithM> Ah
07:34:33 <Peaker> untitled, no, for luca
07:34:34 <applicative> WraithM: and then illustrating how you would convert an infinite list of increasingly long finite lists to an infinite list of infinite lists
07:35:09 <applicative> WraithM: by first taking the first member of each, the second member of each one that has a second member, then ...
07:36:32 <WraithM> so on
07:36:53 <applicative> you can generate the infinite list of short lists by taking the infinite list from randoms (isn't that an infinite list)
07:37:00 <applicative> then use
07:37:07 <applicative> @type splitAt
07:37:08 <lambdabot> forall a. Int -> [a] -> ([a], [a])
07:37:39 <applicative> iteratively
07:37:51 <ocharles> Is there anything like Applicative Maybe that still calls all actions, even if an earlier action returns Nothing?
07:38:24 <ocharles> (my understanding is that Applicative Maybe is implemented in terms of Monad Maybe)
07:38:33 <applicative> or some other cleverness to break [a,b,c,d,e...] into  [a],[b,c],[d,e,f] ...
07:40:53 <luca> well they would be generated like [ take i (drop (i-1) xs) | i <- [1..] ] no?
07:41:09 <luca> wait no nvm
07:41:29 <luca> drop (i*(i-1)/2) :P
07:41:46 <applicative> WraithM: that way, if you ask for (crazyList !! 3) !! 4 ghc will know what to do?
07:42:38 <applicative> WraithM: it would of course help to know what you propose to do with the 'infinite list of infinite lists of random numbers' once you get it....
07:43:13 <WraithM> My simulation takes an infinite list of random numbers as an argument
07:43:31 <WraithM> Thank you so much for your help, by the way :) I'm still learning
07:43:36 <luca> yeh that works
07:43:37 <applicative> luca, but then it has to keep starting over on the same list, no?
07:43:51 <luca> let magical haskell optimise it? :P
07:44:16 <WraithM> And I want to map my simulation function over the list of lists of random numbers to do many simulations
07:44:55 <WraithM> And then I'd calculate things like statistics on them and such
07:45:13 <Siod> what's a good open source haskell project that uses plugins (besides lambdabot)
07:45:47 <osfameron> Yi?
07:46:08 <osfameron> xmonad
07:46:19 <WraithM> darcs
07:46:30 <WraithM> maybe not darcs
07:46:32 <WraithM> idk
07:46:33 <Siod> yi works by providing a bunch of features, and then allows the user to import those features, right?
07:46:48 <Siod> it's like of like inversion of control for plugins, right?
07:49:15 <WraithM> applicative: I actually got it to work!
07:49:35 <WraithM> Another random question that just popped into my head
07:49:45 <WraithM> Is there a package for numerical integration?
07:49:58 <WraithM> I mean, I can write my own function
07:50:09 <WraithM> but packages are better than not packages
07:52:21 <WraithM> Nevermind, I found numeric-tools package
07:53:20 <Luke> nominolo: you around?
07:54:12 <ocharles> Hmm, on thinking about this, I don't think it's even possible to write an applicativo functor like Maybe that evaluates all arguments, regardless of short circuiting
07:55:00 <applicative> > > let step (n,xs) = let (zs,ws) = splitAt n xs in Just (zs, (n+1,ws)); shortLists inflist =  unfoldr step (0,inflist) ; randomInflist = randoms (mkStdGen 5) :: [Word8] in take 20 (shortLists randomInflist)
07:55:01 <lambdabot>   <no location info>: parse error on input `>'
07:55:03 <applicative> > let step (n,xs) = let (zs,ws) = splitAt n xs in Just (zs, (n+1,ws)); shortLists inflist =  unfoldr step (0,inflist) ; randomInflist = randoms (mkStdGen 5) :: [Word8] in take 20 (shortLists randomInflist)
07:55:04 <lambdabot>   [[],[137],[175,57],[114,80,85],[56,50,236,115],[255,143,188,105,15],[159,45...
07:57:34 <Luke> anyone here familiar with scion? I'm getting a lot of errors telling me "unknown server command" though other stuff is working
08:00:40 <Siod> is darcs well designed? is it worth learning from?
08:01:47 <nand`> Does anybody else keep accidentally searching hoogle when meaning to search the internet?
08:02:14 <armlesshobo> nope
08:04:35 <d-snp> anyone know a link to a (smallish) library that is properly test with quickcheck?
08:04:55 <stepcut> nand`: no, but I do often forget that the address for hoogle is haskel.org/hoogle, not hoogle.com
08:04:58 <d-snp> I'm wondering what the best way to do it automatically is
08:05:03 <applicative> Siod, maybe look at the users of the plugins library?  http://hackage.factisresearch.com/package/plugins/reverse Other things like xmonad do it themselves, though my comprehension is low
08:06:51 <luite> if i have cbits/cfile.c that includes cbits/cfile.h, what's the correcy way to list the .h file so that it's included in the sdist?
08:07:16 <d-snp> do haskell people don't like to test their code?, this line in the quickcheck introduction: "its nice that we can use the QuickCheck testing framework directly from the Haskell prompt"
08:07:32 <d-snp> how is that nice? it's a pretty terrible thing to do...
08:07:45 <nand`> d-snp: unit testing is not a popular thing in the Haskell world
08:07:52 <nand`> or proprietary testing, for that matter
08:07:56 <nand`> d-snp: we prefer proofs
08:08:00 <d-snp> :P
08:08:05 <nand`> s/proprietary/property/
08:08:15 <d-snp> so I take it there's a good proofing library then?
08:08:18 <luite> d-snp: why is it terrible?
08:08:31 <nand`> no idea
08:09:24 <d-snp> luite: because ghci discards everything you type after you exit
08:09:25 <untitled> so, about calling iterate $ flip function with 3 args: http://hpaste.org/69549
08:09:29 <untitled> what's going wrong there?
08:09:31 <d-snp> what good is a test if you only run it once?
08:10:12 <parcs`> luite: install-includes?
08:10:16 <applicative> d-snp maybe checkout the containers package for a model? https://github.com/ghc/packages-containers/tree/master/tests
08:10:21 <luite> d-snp: you can still include the tests in a cabal test section
08:10:35 <luite> but it's easier if you can try them out first
08:11:04 <luite> parcs`: i don't really need it to be installed, it just needs to be included by the .c file
08:11:23 <applicative> d-snp: you can run zillions of quickcheck tests every night, you'll never be repeating yourself....
08:11:56 <parcs`> luite: extra-source-files?
08:12:07 <parcs`> "The Extra-Source-Files tells Cabal to put the files in the release tarball, but nothing more"
08:12:17 <applicative> d-snp: checkout http://video.google.com/videoplay?docid=4655369445141008672 for an impressive motivational sermon from Hughes himself
08:12:27 <luite> parcs`: hmm that might do it
08:12:45 <applicative> d-snp: you'll never write another unit test again
08:12:55 * applicative is exaggerating
08:13:34 <luite> parcs`: ok, dcoutts confirmed it :)
08:13:40 <dcoutts_> @arr!
08:13:40 <lambdabot> Arrr!
08:14:32 <shapr> @quote dcoutts
08:14:34 <lambdabot> dcoutts says: jcreigh: you mentioned Haskell, so dons found you. He can smell that kind of thing.
08:14:39 <shapr> hah
08:17:24 <aristid> @quote arr
08:17:24 <lambdabot> DuncanCoutts says: I’m slightly embarrassed to admit that I spent three days at the Haskell Hackathon and wrote no Haskell code, only POSIX shell script and M4 autoconf macros!
08:17:34 <pooya72> hello everyone!
08:17:49 <d-snp> thanks applicative
08:18:00 <pooya72> does cabal-dev have a ghc --make? like cabal-dev ghc --make test.hs ?
08:19:18 <applicative> d-snp i hate online video lectures, but the hughes one is, i think, worth the trouble.
08:19:58 <d-snp> alright, I got it working, ((\s -> s == s) :: [Char] -> Bool), runs without the Arbitrary declarations
08:20:14 <d-snp> does that mean I don't need to define Arbitrary definitions for most basic types?
08:20:55 <applicative> d-snap tons of basic ones are exported
08:20:58 <colah> Hey all, I've been experimenting with a library I'm calling FormatParser. It's a Parsec-inspired library for simultaneous writing of parsers and formaters. I'd appreciate comments. https://github.com/colah/FormatParser
08:21:01 <d-snp> ok
08:23:07 <aristid> colah: that's certainly a cool idea, i think there are some libraries which do similar things on hackage too
08:24:32 <colah> aristid: I'd be very interested in such things. I couldn't seem to find them.
08:24:33 <colah> (I just did some google searches, though)
08:24:33 <applicative> d-snp: inside ghci do import Test.QuickCheck then  do :i Arbitrary  .  Then the obvious building blocks will be shown
08:24:33 <_jak> does anyone have a preferred image manipulation library? ghci
08:24:37 <applicative> d-snp Int Char Bool etc. then lists tuples maybes ...
08:24:59 <applicative> so [Char] is thus covered.
08:25:13 <aristid> colah: http://hackage.haskell.org/package/boomerang
08:25:52 <aristid> colah: http://hackage.haskell.org/package/cassette
08:26:31 <colah> aristid: Thanks!
08:28:24 <aristid> colah: and specifically for JSON: http://hackage.haskell.org/package/JsonGrammar
08:30:18 <Matt``> Is there a user manual for lambdabot?
08:32:01 <colah> aristid: That one is particularily cool. Thanks again!
08:32:48 * hackagebot tamarin-prover 0.6.1.0 - The Tamarin prover for security protocol analysis.  http://hackage.haskell.org/package/tamarin-prover-0.6.1.0 (SimonMeier)
08:33:00 <WraithM> @pl
08:33:00 <lambdabot> (line 1, column 1):
08:33:01 <lambdabot> unexpected end of input
08:33:01 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:33:06 <WraithM> @pl help
08:33:06 <lambdabot> help
08:33:53 <WraithM> @pl (\x -> (!!) x . pred)
08:33:53 <lambdabot> (. pred) . (!!)
08:36:37 <WraithM> @pl (\(x:xs) -> (x : takeWhile (== x) xs) : group (dropWhile (== x) xs))
08:36:39 <lambdabot> ap (ap (ap . ((:) .) . liftM2 (.) (:) (takeWhile . (==))) ((group .) . dropWhile . (==)) . head) tail
08:39:08 <applicative> james_k: what do you want to do with images?
08:40:07 <WraithM> @pl (\n j g -> take n . map f . map (h j) (k g))
08:40:07 <lambdabot> (. (((map f .) .) . (. k) . map . h)) . (.) . (.) . take
08:40:48 <james_k> applicative: I've been writing some code that should do some simple pattern matching. I just need JPEG/PNG decompression
08:41:33 <applicative> james_k: http://hackage.haskell.org/package/JuicyPixels reads and writes from .jpeg and .png, the image is represented as Vector Word8 etc
08:41:58 <james_k> applicative: I just wanna know if anyone has a favorite
08:42:06 <james_k> applicative: ah that looks good, thanks
08:42:21 <applicative> that's necessarily the favorite for what it does, since its pure Haskell :)
08:42:33 <applicative> other things are c bindings
08:42:40 <pooya72> so i'm trying to follow this wxHaskell tutorial for Mac http://www.haskell.org/haskellwiki/WxHaskell/MacOS_X I just have no idea where cabal-macosx is installed to put in my path. It doesn't run.
08:43:25 <applicative> there is a link of it with repa, as with the libdevil bindings, but these will be suddenly out of date with the new repa
08:43:44 <smithw> @pl (\x -> liftM (f x) . g . (*x))
08:43:44 <lambdabot> ap ((.) . fmap . f) ((g .) . (*))
08:44:28 <luca> quick Q;
08:44:46 <luca> writing a function pretty print an AST. it's probably going to be nicer using the Writer monad yeh?
08:47:05 <pooya72> anyone have any experince with wxHaskell on mac?.... just trying to run cabal-macosx
08:47:26 <otters> is there an "or" operator for case expressions
08:47:52 <otters> like case x of { y -> some_large_expression; c -> same_large_expression } translating to case x of { y | c -> some_large_expression }
08:53:20 <applicative_> pooya72: I'm  not sure what the executable in the wx tutorial was supposed to do.
08:53:55 <navaati> otters: i don't think it's possible, but you can factorize the "some_large_expression" in a functio, using a let binding
08:54:12 <pooya72> applicative_: it was this https://raw.github.com/jodonoghue/wxHaskell/master/samples/wxcore/HelloWorld.hs
08:54:13 <applicative_> pooya72: there is a macosx-app executable that goes into ~/.cabal/bin which wraps an executable in a kind of null App structure, I think as an illustration
08:54:31 <pooya72> applicative_: yeah i used that but still didn't work
08:54:48 <pooya72> i was wondering what this cabal-macosx thingy was
08:55:08 <pooya72> applicative_: and thanks again for your help man
08:55:22 <applicative_> I think https://github.com/gimbo/cabal-macosx/blob/master/macosx-app.hs the source, is intended as an example
08:58:29 <luca> ooooh actually had to give a type for a function
09:03:29 <applicative_> pooya72: this is the thing I used as an example when I did this a year or so ago, https://github.com/gimbo/cabal-macosx/tree/master/examples
09:04:27 <pooya72> applicative_: yeah I'm running through those now, but runghc Setup configure give me Setup: At least the following dependencies are missing:
09:04:28 <pooya72> cabal-macosx -any, wx -any
09:04:43 <pooya72> although they are both installed
09:05:08 <applicative_> pooya72: dunno, what about cabal configure cabal build ?
09:05:09 <pooya72> using cabal configure and cabal build, builds the app. but it doesn't work
09:06:46 * applicative_ studies
09:07:29 <d-snp> suppose I have the test from the quickcheck introduction: *A> quickCheck ((\s -> (reverse.reverse) s == s) :: [Char] -> Bool)
09:07:38 <d-snp> and for my reverse, it returns false
09:07:54 <d-snp> how could I print the result of the reverse for which it is false
09:07:56 <d-snp> ?
09:09:38 <d-snp> hm found a way around it..
09:10:01 <pooya72> applicative_: did this work for you a year ago?
09:10:11 <applicative_> pooya72: yes it was fine
09:10:38 <applicative_> i made a not very complex app
09:11:07 <applicative_> it looks like theres something broken in homebrew nonsense
09:12:03 <pooya72> applicative_: maybe....
09:12:18 <pooya72> applicative_: took me the whole day to get here :|
09:17:27 <d-snp> ah take only takes as much as it can :(
09:18:45 <strager> Indeed.
09:18:51 <strager> > take 10 [1]
09:18:52 <lambdabot>   [1]
09:19:29 <adamt> > take 10 $ cycle [1]
09:19:30 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
09:19:36 <adamt> Fixed it for ya. :P
09:19:48 <augur> hmm
09:20:09 <augur> is there a standard text processing library for doing templatic stuff?
09:21:24 <strager> You mean a bunch of combinators, or HTML or some other language specifically, or things like printf and .NET's ToString?
09:21:59 <augur> a bunch of combinators
09:22:27 <strager> There's the 'pretty' package, but I don't think that's what you want.  Maybe it is.
09:22:48 <augur> that sounds like a pretty printing package...
09:22:56 * hackagebot hfsevents 0.1.1 - File/folder watching for OS X  http://hackage.haskell.org/package/hfsevents-0.1.1 (LuiteStegeman)
09:23:04 <applicative_> pooya72: yeah i think something is broken in my homebrew wxmac , I had the 32 bit version and installed the 64 bit when I installed the new haskell platform
09:23:27 <applicative_> but things like libtiff were build before
09:23:42 <parcs`> yay new repa version
09:24:22 <killy9999> is there a way to automatically remove a particular package from my local ghc installation
09:24:34 <killy9999> or do I need to unregister it and delete files on the disc manually?
09:25:34 <strager> The latter.
09:25:40 <strager> Not too pleasant...  =[
09:25:55 <strager> Such problems make cabal-dev appealing.  If you're not using it, you should try it.
09:27:06 <killy9999> mhm
09:27:24 <killy9999> I think the best solution is to install all the Haskell Platform within one directory
09:27:49 <coppro> win 14
09:28:28 <strager> coppro: alt-R
09:30:00 <applicative_> killy9999: what do want to do?
09:31:35 <HugoDaniel> i have different user accounts for different setups of haskell
09:31:38 <HugoDaniel> and the problem is solved
09:31:44 <HugoDaniel> ...much better than cabal-dev :D
09:32:16 <luite> HugoDaniel: you might want to try virthualenv
09:32:49 <applicative_> killy9999: it seems the arrangement i'm getting with my shiny haskell platform will make this easier rm -r ~/.cabal/ghc-7.4.1/lib/annoyinglib
09:33:45 <applicative_> HugoDaniel: hah, i did that once it certainly causes less conceptual chaos
09:36:53 <applicative_> killy9999: ghc-pkg unregister annoying && rm -r ~/.cabal/ghc-7.4.1/lib/annoying doesn't strike me as too hard.
09:38:20 <killy9999> applicative: I'm trying to remove the old haskel platform
09:38:23 <killy9999> and install the new one
09:38:39 <killy9999> ghc-pkg list | grep -v "^/" | sed -e "s/[ {}]//g" xargs ghc-pkg --force unregister
09:38:52 <killy9999> I'm struggling to figure out why this doesn't work
09:39:20 <killy9999> btw. I have system-wode installation
09:42:41 <strager> You need another pipe there, killy9999
09:42:45 <strager> Before xargs
09:43:06 <killy9999> yes, I have the pipe
09:43:14 <killy9999> it was pasting error
09:43:17 <strager> The common thing to do is to blow away all of ~/.ghc and ~/.cabal
09:43:20 <applicative> who was asking about wx
09:43:40 <killy9999> I get error from ghc-pkg that command line syntax is wrong
09:43:50 <applicative> pooya72: you! yes, i reinstalled various homebrew things, and now the might WxHello.app works fine
09:44:09 <killy9999> interestingly, if I squeeze 'head -n 1' between sed and ghc-pkg it works fine
09:44:10 <nand`> Why is the Haskell Platform such a pain to update either way? Personally I don't even bother using it
09:44:23 <pooya72> applicative: ha! really?
09:44:25 <strager> Then use a while loop, I guess
09:44:48 <strager> ghc-pkg list | grepsed ... | while read pkg; do ghc-pkg --force unregister $pkg; done
09:44:49 <pooya72> applicative: how are you building the WxHello.app?
09:44:54 <applicative> yeah, the error i was getting before mentioned something about libtiff and lib-cocoa-tiff-blah
09:45:33 <applicative> pooya72: cabal  configure  , cabal build , open dist/build/WxHello.app
09:46:01 <killy9999> strager: that's what I'm doing ;)
09:46:03 <pooya72> applicative: yeah that doesn't work for me :(. I'm on an older 32-bit system.
09:46:13 <pooya72> applicative: could that be it?
09:46:28 <pooya72> applicative: Like I can't run Lion.
09:46:35 <applicative> pooya72: i killed off a bunch of things like libtiff, reinstalled them with --universal and then reinstall wxmac with --devel
09:47:05 <pooya72> applicative: wow, I put you through a lot of trouble!
09:47:06 <applicative> pooya72: oh i see, yes, this is more confusing then. or maybe less confusing.
09:47:30 <applicative> pooya72: no, actually, I was getting ready the other day to do just this, so I'm a little more ready
09:48:19 <applicative> pooya72: so are you using homebrew?
09:48:23 <pooya72> yeah
09:48:23 <augur> does haskell perform any tail-recursivization?
09:48:29 <pooya72> applicative: yeah
09:48:43 <applicative> pooya72: yeah, I think your situation will be over my head.  I'm not using lion though
09:48:51 <pooya72> applicative: :'(
09:48:54 <augur> im sure it dos TCO, but does it try to find tail-recursive variants of non-tail-recursion functions?
09:49:03 <applicative> but the previous feline.
09:49:09 <pooya72> I can't install GTK+ either... :(
09:49:16 <pooya72> lol
09:50:34 <armlesshobo> pooya72: :|
09:50:36 <applicative> pooya72: i don't know.  i recommend shelling out $X zillion for a quadcore macbook pro, or whatever...:)
09:51:07 <conal> augur: hey there.
09:51:07 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
09:51:10 <pooya72> applicative: lol... or maybe I should go back to writing assembly
09:51:13 <augur> conal: heyo
09:51:24 <applicative> pooya72: no not that!
09:51:40 <conal> augur: i saw your question about bottom-up trees. yes, they always have 2^n leaves.
09:51:51 <fragamus> how did you guys learn haskell
09:52:21 <augur> conal: hmm. do you know of any interesting views on normal binary trees?
09:52:48 <nand`> fragamus: a mixture of reading haskell, reading about haskell and writing haskell
09:52:52 <fragamus> i read the hutton book but it goes only so far
09:53:15 <conal> augur: which was part of my interest in them. some algorithms assume arrays of 2^n elements, which i wanted to capture in the type. i think i got the trick from a paper by Chris Okasaki.
09:53:28 <augur> hm!
09:53:48 <applicative> pooya72: well, i think in any case we're close to seeing that wxhaskell + wx 64 bit + cocoa frufruness can actually be built.  Probably some new error like the tiff one will arise
09:54:18 <pooya72> so what's a good gui toolkit for haskell?
09:54:33 <conal> augur: "From fast exponentiation to square matrices" -- a lovely paper!
09:54:46 <applicative> fragamus: you've looked at the other standard tutorials?  lyah and rwh?
09:55:02 <applicative> pooya72: vty
09:55:04 <conal> augur: i don't think i've stumbled across any such interesting variations on non-perfect trees.
09:55:09 <applicative> just kidding
09:55:23 <fragamus> I'm working my way through RWH now and chapter 15 is slow going
09:55:37 <pooya72> lol
09:56:03 <augur> conal: shame :(
09:56:40 <applicative> whats chapter15 fragamus
09:57:05 <conal> augur: except that i think one can capture the tree shape in a type, even when the tree isn't perfect. when perfect, the depth is enough.
09:57:16 <hpaste> fragamus pasted “i memorized this crap” at http://hpaste.org/69556
09:57:35 <nand`> applicative: is ‘vty’ good / easy to use / simple? How does it compare to ncurses?
09:57:54 <fragamus> i forced myself to memorize the supply example
09:58:16 <fragamus> because reading is one thing but being able to do it is another
09:58:32 <augur> conal: this is true :)
09:58:38 * nand` looks at RWH chapter 15
09:58:44 <nand`> ugh, liftM3 where an applicative would be perfect!
09:59:10 <fragamus> and it wasn't sticking any other way.  it helped me focus on some issues. I retyped it until I could diff it with a perfect example file cleanly
09:59:28 <augur> conal: ok, im off to school, time to do category theory. :)
09:59:29 <augur> ciao
10:00:31 <applicative> pooya72: are you looking for a 'gui toolkit' properly speaking or just something with  moving images etc.
10:01:53 <pooya72> applicative: gui toolkit, like GTK+, Qt
10:02:05 <pooya72> I like Haskell as a language but the libraries are killing me
10:02:53 <navaati> pooya72: there is gtk2hs, a binding of gtk
10:03:16 <pooya72> navaati: yeah, dosen't install for me
10:03:18 <applicative> pooya72: its the  evil world of c and c++ that are killing you :)
10:03:19 <navaati> and there also is a binding of wxWidgets
10:03:27 <pooya72> applicative: yes :)
10:03:37 <nand`> I think wxWidgets is pretty popular
10:03:41 <nand`> + reactive-banana
10:04:43 <navaati> (c'mon, seriously, wxWidgets ? i HATE it when i have to use an application written with this…)
10:05:06 <nand`> I hate it when I have to use an application written with GTK+ or Qt :)
10:05:45 <pooya72> nand`: yeah I can't get them to work properly on my system
10:05:45 <applicative> nand` it developed that wx + wxhaskell + ye olde mac are a nightmare
10:05:45 <applicative> navaati: because the library is gross, or the result is gross?
10:06:49 <navaati> applicative: the result (from what i've heard the lib is fine, never programmed with it tho)
10:07:15 <nand`> pooya72: they work fine on my system, they're just horribly clunky to work with and look fairly ugly; though part of that is due to me not writing a proper .gtkrc
10:07:39 <pooya72> nand`: yeah, I like Qt the best out of the bunch
10:07:44 <armlesshobo> if you mix wx + wxhaskell + mac then you're gonna have a bad time
10:08:09 <pooya72> armlesshobo: haha, tell me about it!
10:08:22 <applicative> navaati: I was just admiring the fancy macness of the  new 64bit ghc + new wxhaskell + new wx with 'cocoa' nonsense
10:09:21 <applicative> navaati: so its just a question of selling your soul to the Apple Corporation, which might be hard if its already in possession of the Google Corporation
10:09:31 <nand`> pooya72: iunno, I only have two applications installed that use Qt, one of them looks just as ugly as Gtk (if not more so since I haven't styled it at all), and the other is libreoffice
10:09:50 <nand`> so it's just this flat gray thing
10:10:02 <pooya72> so I'm hoping i don't hit any problems with yesod-platform
10:10:14 <pooya72> i wish we could just do html5 gui's with haskell
10:10:15 <applicative> armlesshobo: I think it may now be easy, I just wish I had freshly install homebrew, I think it would have been three easy to state steps
10:10:38 <luite> is it possible to let Cabal detect the OS X version (and set some flag if it's 10.7 or higher?) ?
10:10:54 <nand`> pooya72: no way, HTML5 needs to die :)
10:11:09 <pooya72> lol
10:11:13 <navaati> hum, nothing is better than programming directly for your native platform. good thing is that gtk is my native platform :D
10:11:39 <pooya72> navaati: very true
10:11:40 <nand`> pooya72: btw, isn't there a version of wxWidgets that uses GTK+ internally? That's what I seem to have installed: ‘x11-libs/wxGTK: GTK+ version of wxWidgets’
10:11:56 <pooya72> nand`: don't know
10:12:28 <navaati> nand`: are you referring to this "trollolol let's implement every OS api in the browser in javascript" tendency ? then +1, html5 needs to die…
10:12:52 <nand`> navaati: I'm referring to “let's make websites more flashy than the plaintext + images they need to be”
10:13:01 <luca> navaati: psh why? who doesn't want an OS in js?
10:13:18 <luca> running in your browser? fucking cool
10:13:19 <nand`> but yeah, the metro “Javascript + HTML5 should become the programming platform of the future” thing is simply ridiculous
10:13:34 <luca> (sarcasm if wasn't clear)
10:13:51 <navaati> well, i'm ok with having an OS in JS if you can find me a processor that have JS as it's assembly language…
10:14:08 <`Jake`> build one yourself
10:14:16 <nand`> speaking of processors and assembly languages, what ever happened to the reduceron?
10:14:22 <nand`> and is there an OS for the thing yet
10:14:40 <navaati> (err, actually, no, i'm not ok with this, JS would be a terrible assembly language)
10:15:10 <armlesshobo> lol
10:15:23 <illissius> navaati: so is x86
10:15:54 <JamesRustle> <script type="asm/x86">
10:16:02 <armlesshobo> lmao
10:16:20 <applicative> pooya72: anyway, if you have the haskell platform you should have opengl and so on already, so you can e.g. build gloss, right?
10:16:50 <barrucadu> nand`: IIRC one of the PhD students here (York) is doing compiler verification stuff for the reduceron
10:16:55 <luca> i want an intelJS chip
10:16:57 <nand`> how cool would it be to have the de-facto standard scripting language for web applications be some form of Haskell with FRP?
10:16:59 <pooya72> applicative: what's build gloss?
10:17:07 <applicative> cabal install gloss
10:17:09 <luite> yeah javascript is not a great assembly language :(
10:17:16 <nand`> barrucadu: I hope it takes off :P
10:17:26 <illissius> javascript is not a great anything language :(
10:17:35 <luca> is there a better function for writing: sequence_.(map f)
10:17:44 <nand`> mapM_
10:17:48 <pooya72> applicative: how would I use that to make a user interface? Like buttons and stuff?
10:18:02 <luca> thanks nand`
10:18:03 * hackagebot shelly 0.9.7 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.9.7 (GregWeber)
10:18:46 <applicative> pooya72: that's why i asked what you wanted exactly, it takes various kinds of user input for example
10:19:15 <pooya72> applicative: yeah thanks. just want something for buttons and text :)
10:19:59 <applicative> pooya72: you mean the user is to type in text?
10:20:27 <pooya72> applicative: yeah. like a gui for sql server. For notes... blog like...
10:20:42 <applicative> grr
10:21:24 <nand`> applicative: you never answered my question about vty; is this because you can't offer me a satisfactory answer, you overlooked it, you're still fathoming it or you're ignoring me?
10:21:31 <applicative> in fact, the usual way forward is to make a little server and use the browser
10:21:44 <applicative> nand`: hmmm
10:22:18 <applicative> nand`: sorry, I was really making a joke about what gui library pooya72 should use since he cant get wx or gtk  bindings wrorking
10:22:55 <nand`> I saw that; I was just wondering whether you mentioned vty because you've actually used it or just because you've seen the name somewhere before
10:23:24 <nand`> the way I interpreted the joke was “you shouldn't use a GUI framework, you should make a terminal interface” + suggestion
10:24:51 <applicative> pooya72: there are several things where the 'app' is a little local web server that you get at through the browser
10:25:14 * nand` cringes
10:25:25 <pooya72> applicative: like what?
10:25:28 <applicative> nand`: no, the joke was in pretending that terminal interfaces are perfectly adequate guis
10:25:35 <nand`> applicative: oh. I misinterpreted :(
10:25:42 <armlesshobo> "let me go write GUI in Visual Basic so I can trace that IP"
10:25:54 * nand` <- huge fan of terminal interfaces, if you didn't guess
10:25:59 <luca> :t \f -> maybe (return ()) (liftM . Just f)
10:26:00 <lambdabot>     Couldn't match expected type `()' against inferred type `m r'
10:26:01 <lambdabot>       Expected type: m a1 -> ()
10:26:01 <lambdabot>       Inferred type: m a1 -> m r
10:26:01 <applicative> i'm looking for an example; i know many people run e.g.gitit just locally
10:26:26 <nand`> :t \f -> maybe (return ()) (liftM Just . f)
10:26:27 <lambdabot>     Couldn't match expected type `()' against inferred type `Maybe a1'
10:26:27 <lambdabot>     In the first argument of `liftM', namely `Just'
10:26:27 <lambdabot>     In the first argument of `(.)', namely `liftM Just'
10:26:30 <armlesshobo> all this GUI talk:
10:26:48 <applicative> you have to start ther server first, then go to localhost//whatever.
10:27:05 <armlesshobo> http://www.youtube.com/watch?v=hkDD03yeLnU
10:27:10 <armlesshobo> get ready to cringe
10:27:14 <luca> :t \f -> maybe (return ()) f
10:27:14 <applicative> pooya72: this is  quite common ^^^ but i cant think of a simmple example
10:27:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
10:27:48 <applicative> pooya72: but if you were thinking of learning yesod anyway, it will give you all that anyway.
10:27:51 <grw7> how would i get the product of 2 lists using a list comp ,but only the product of the elements in order , ie [1,2,3] * [1,2,3] = [1*1,2*2,3*3]
10:28:04 <luca> @pl \x -> (tell "a") >> (teller x)
10:28:05 <lambdabot> (tell "a" >>) . teller
10:28:06 <nand`> looks like a zipList
10:28:16 <nand`> or just zipWith
10:28:27 <pooya72> applicative: yeah but I also wanted something i could give to friends, as a one click install.
10:28:31 <grw7> what does zipWith do ?
10:28:39 <applicative> pooya72: I mean database conncections and so on.  Of course the server can be run by the user ...
10:28:46 <luca> > zipWith (+) [1,2] [10,20]
10:28:47 <lambdabot>   [11,22]
10:28:50 <nand`> > zipWith (*) [1,2,3] [4,5,6] :: [Expr]
10:28:51 <lambdabot>   [1 * 4,2 * 5,3 * 6]
10:28:59 <grw7> ahh nice :)
10:29:05 <grw7> thanks
10:29:53 <navaati> why are there separate Monoid, MonadPlus and ArrowPlus whereas they are exactly the same thing ?
10:29:59 <pooya72> applicative: if you can think of a way of deploying something like that for non-technical users that would be great. like bundling everything in one exe. I know you can do it in java, that's how solr is packaged...
10:30:08 <applicative> pooya72: yes, i understand, I'm not sure this model couldnt cover that case too.  i wish i could think of a less gigantic illustration that a git backed wiki :)
10:30:09 <byorgey> grw7: if you want to do it with a list comprehension, you can also turn on the ParallelListComp extension, and do something like   [ x * y  | x <- [1,2,3] | y <- [1,2,3] ]
10:30:12 <byorgey> note the second |
10:30:32 <grw7> and what if i wanted [1 * 4^2, 2*5^2,3*6^2]
10:30:34 <pooya72> applicative: :)
10:30:38 <nand`> navaati: I think it's because of the extra laws in MonadPlus; eg mzero >>= f = mzero and v >> mzero = mzero
10:30:45 <navaati> oh, ok
10:30:47 <navaati> makes sense
10:31:10 <grw7> byorgey thats what i tried to do at first haha cool so you can enable that :)
10:31:11 <luca> question: writing a pretty printer for an AST, right now using Writer monad which works nicely; but I want to also keep track of indentation scopes; so i want the State monad to keep track of current scope too
10:31:21 <luca> guessing need to use a transformer then to combine them>?
10:31:22 <nand`> byorgey: what does that extension do? just zip instead of binding?
10:32:21 <nand`> > zipWith (*) [1,2,3] (map (^2) [4,5,6]) :: [Expr] -- grw7
10:32:22 <lambdabot>   [1 * (4 * 4),2 * (5 * 5),3 * (6 * 6)]
10:32:29 <jfischoff> how does one convert a function String -> Bool to parsec parser?
10:32:47 <grw7> damn you guys are cool :)
10:33:05 <grw7> thanks again, just started haskell yesterday
10:33:22 <luca> what exactly should the parser be doing?
10:33:47 <jfischoff> luca: were you responding to me?
10:33:50 <luca> yeh
10:34:35 <armlesshobo> grw7: you can then do a zipWith with '^' the result of the first zipWith, and [2,2,2]
10:34:54 <armlesshobo> > zipWith (^) (zipWith (*) [1,2,3] [4,5,6]) [2,2,2] :: [Expr]
10:34:55 <lambdabot>   [1 * 4 * (1 * 4),2 * 5 * (2 * 5),3 * 6 * (3 * 6)]
10:34:58 <nand`> luca: not sure if this is the best way to do it (relating to your pretty printing question) but you can compose a state and writer monad by simply using (StateT s (Writer w)) instead
10:35:00 <armlesshobo> oops
10:35:26 <rwbarton> or how about a simple zipWith (\x y -> x * y^2)
10:35:27 <armlesshobo> already been answered lol
10:35:34 <byorgey> jfischoff: how will the parser know when to stop?
10:35:59 <shapr> grw7: yay Haskell!
10:36:09 <grw7> haha so many ways :)
10:36:23 <jfischoff> luca, byorgey: yeah my bad. basically I am looking for a function f :: (String -> (a, Int)) -> ParsecT Char u m a
10:36:47 <jfischoff> where the Int is the count of how many characters were consumed
10:37:09 <jfischoff> actually what I really want to is to convert a Happy, Alex combo to Parsec
10:37:23 <jfischoff> I have a Happy parser, I want a Parsec one from it
10:37:33 <luca> nand`: know a good reference for learning about combining monads?
10:38:12 <strager> jfischoff: I think you can get the rest of the stream
10:38:13 <nand`> luca: there's http://book.realworldhaskell.org/read/monad-transformers.html but I don't know if it's the best
10:38:20 <navaati> is there a class in haskell for something that have a + and a * operation ? monoid only covers the +
10:38:35 <strager> http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Prim.html#t:State
10:38:48 <strager> Maybe stateInput is what you want
10:38:50 <ocharles> navaati: * is also a monoid
10:39:01 <jfischoff> strager: get the stream, had it to the Happy parser, and adjust after parsing?
10:39:08 <rwbarton> + and *? like Num?
10:39:08 <jfischoff> s /had/hand
10:39:37 <navaati> ocharles: yep, but i want both at the same time (for example Bool have a + (which is OR) and a * (which is AND)
10:39:54 <strager> jfischoff: Maybe do: string (take (snd result) input)
10:40:00 <strager> to do the consumption in the stream
10:40:03 <applicative> @type Sum
10:40:04 <lambdabot>     Ambiguous occurrence `Sum'
10:40:04 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
10:40:04 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
10:40:09 <applicative> grrr
10:40:23 <ocharles> navaati: I don't understand what both at the same time means
10:40:25 <jfischoff> strager: yeah something along those lines should work. Thanks
10:40:26 <navaati> (i know the Sum and Prod wrapper, and that's not what i need)
10:40:26 <byorgey> navaati: maybe take a look in http://hackage.haskell.org/package/algebra
10:40:28 <strager> jfischoff: Or maybe you can try lookAhead
10:40:37 <Rc43> Hi, guys.
10:40:38 <nand`> navaati: maybe there's a class for Rings
10:40:42 <byorgey> navaati: something like a Rig, Ring, or Rng
10:40:49 <rwbarton> That class is called Num. :P
10:40:51 <byorgey> depending on what sorts of identity elements you want
10:41:12 <byorgey> rwbarton: no, Num has a bunch of other silly cruft on top =P
10:41:17 <navaati> nand`, byorgey: ah, a Ring may be what i need
10:41:17 <rwbarton> those don't exist
10:41:20 <rwbarton> :)
10:41:26 <byorgey> hehe
10:42:00 <Rc43> Why `reservedOp` has different types in documentation? In Hoogle it is GenParser -> .. -> .. http://www.haskell.org/hoogle/?hoogle=reservedOp ; but if go to hackage by link from Hoogle then we can see that type is without `GenParser` in beginning.
10:42:18 <Rc43> On my computer I have version with GenParser and I have parsec-3.1.1
10:42:22 <rwbarton> isn't reservedOp a record field
10:42:37 <JamesRustle> Rc43: you're misinterpreting the documentation on hackage
10:43:06 <rwbarton> yeah, you have to scroll up a bit to see the context
10:43:14 <luca> reservedOp is function which matches a reversed operator (from record field) as long as it is not the prefix of a valid operator as defined by operatorLetter record field
10:43:19 <luca> reserved*
10:43:40 <Rc43> eee
10:43:48 <Rc43> about what context do you talk?
10:44:15 <JamesRustle> "data GenTokenParser s u m
10:44:17 <rwbarton> "data GenTokenParser s u m" "Constructors" "TokenParser"
10:44:17 <JamesRustle> The type of the record that holds lexical parsers that work on s streams with state u over a monad m."
10:45:00 <Rc43> Oh, understood.
10:45:11 <Rc43> Obvious =/
10:45:24 <rico> hi there .. I will just stay here and listen I think if you don't mind : )
10:45:36 <byorgey> rico: not at all, please do
10:45:45 <rico> seems to be interesting talk around here
10:45:52 <nand`> not an awful lot to listen to. one would think there's more reading involved
10:45:54 <byorgey> 700 other people doing the same thing can't be wrong!
10:45:57 * nand` hides
10:46:18 <Rc43> Btw, http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Expr.html example in the bottom of page cannot be compiled; or I again doing something wrong.
10:46:23 <rico> thx byorgey
10:46:41 <rico> : )
10:46:48 <JamesRustle> Rc43: how does it fail?
10:46:49 <Rc43> Here: `do{ reservedOp name; return fun }`. reservedOp requires one more argument.
10:47:31 <rico> well nand ... I think I can parse this stuff around here
10:47:50 <rico> so 700 people dont generate much talk? : )
10:48:54 <rwbarton> perhaps the style at the bottom of http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Token.html is assumed to be in effect
10:49:24 <hpaste> luca pasted “StateT Writer” at http://hpaste.org/69558
10:49:33 <luca> to nand`
10:49:40 <rwbarton> in which parens, etc. are names for the fields of a particular GenTokenParser and the record constructors are being imported qualified
10:50:01 <xemdetia> My mind is blanking, what is the term for what haskell does to cache the results of a function call, its a general CS term but its just escaping me at the moment.
10:50:19 <rwbarton> memoization, and it doesn't do it :)
10:50:28 <xemdetia> Oh I thought it did?
10:50:46 <rwbarton> unless you explicitly assign the result to a variable (or function argument) and use that variable several times
10:50:49 <luca> compiler may do it; but it's not guaranteed
10:50:54 <nand`> luca: the error message isn't for the code you pasted
10:51:09 <luca> ah sorry nand` i had 'lift get'
10:51:20 <nand`> yeah, you don't want to lift manually :)
10:51:30 <luca> just using get doesn't work either though :P
10:51:38 <rwbarton> the compiler does not go around willy-nilly memoizing facts like "fib 6 = 8" in case you might happen to apply fib to 6 again later
10:51:38 <rico> @byorgey haskell seems to be no wrong thing indeed
10:51:39 <lambdabot> Unknown command, try @list
10:51:41 <nand`> post new error
10:52:06 <xemdetia> rwbarton: ah okay
10:52:22 <hpaste> luca annotated “StateT Writer” with “StateT Writer (annotation)” at http://hpaste.org/69558#a69559
10:53:07 * hackagebot hfsevents 0.1.2 - File/folder watching for OS X  http://hackage.haskell.org/package/hfsevents-0.1.2 (LuiteStegeman)
10:53:36 <otters> rwbarton: if you applied fib to 6 again later, wouldn't it still be 8?
10:53:54 <c_wraith> luite: That's cool to see.  how's a cross-platform wrapper coming along?
10:54:35 <rwbarton> yes, for sure
10:54:37 <nand`> luca: odd, compiles for me; some context maybe?
10:54:56 <rwbarton> but your program would do the work of computing fib 6 again
10:55:40 <S11001001> luca: monomorphism restriction
10:55:49 <luca> maybe it's how i'm trying to run it? trying to do: evalStateT (runWriter teller) 0
10:56:12 <Rc43> rwbarton, ok, it's clear; but I can't get what GenTokenParser I should substitute in code on initial page.
10:56:19 <luite> c_wraith: I was just talking to Mark Dittmar who's making it for his GSoC project, he needed some extra API to check support for some OS X functionality (file-level events were only added in OS X 10.7, the cross-platform thingie falls back to polling without those), so i added them to my package
10:56:33 <S11001001> luca: so it needs an explicit type or language NoMonomorphismRestriction
10:56:45 <stepcut> shapr: any luck on that in-browser Haskell editor I asked for ? :p
10:56:46 <nand`> luite: wouldn't you have to use runWriter (evalStateT teller) 0
10:56:53 <nand`> err
10:56:56 <nand`> 0 inside the )
10:56:58 <luca> where is that coming from though? that would mean it's unable to infer a type variable right?
10:57:08 <nand`> s/luite/luca/
10:57:30 <rwbarton> it can't figure out what monad m0 to use and due to the monomorphism restriction it has to eliminate the type class constraint on m0
10:57:41 <rwbarton> so it is trying to find an instance that will work for any m0, like the error message says
10:57:52 <nand`> ah
10:58:03 <nand`> no wonder it compiled for me, I have the monomorphism restriction disabled
10:58:07 <rwbarton> the error message doesn't really make sense unless you understand this back story first though
10:58:22 <luca> i've actually gotten an error which specifically said it was a monomorphism problem
10:58:26 <luca> this one doesn't even mention it >.>
10:58:31 <nand`> luca: and that's why you should always write down the types of your functions
10:58:35 <luca> last one went away just after writing more code
10:59:11 <illissius> I wish I were smart.
10:59:18 <nand`> in this case; tellstate :: (Show a, MonadState a m, MonadWriter String m) => m () -- though if you don't need such general definitions you can always restrict it to the concrete types used in your program
10:59:28 <rwbarton> interesting, i don't remember ever seeing an error message that mentioned the monomorphism restriction by name
10:59:44 <luca> so what 'is' the type here?
10:59:51 <nand`> eg. by providing a type alias for your StateT/Writer composition and then :: MyMonad ()
11:00:35 <S11001001> luca: trying the rhs with :t shows typeclass constraints, which is a good test for that sort of thing, not to mention a sig you can put in explicitly to make it work
11:00:37 <nand`> luca: basically :: Show a => StateT a (Writer String) ()
11:01:10 <luca> right okay works now
11:01:11 <luca> thanks
11:01:28 <luca> was trying StateT a (Writer String ()) and failing :P
11:01:51 <Rc43> rwbarton, do you understand how I need to change that code?
11:01:52 <nand`> @kind StateT
11:01:53 <lambdabot> * -> (* -> *) -> * -> *
11:02:03 <nand`> @kind Writer String
11:02:04 <lambdabot> * -> *
11:03:00 <shapr> stepcut: some progress, but so far I'm only just matching tryhaskell
11:03:31 <stepcut> shapr: k
11:04:00 <luite> :)
11:04:06 * nand` wonders if there's an in-browser version of vim
11:04:32 <JamesRustle> nand`: pentadactyl?
11:04:38 <rwbarton> Rc43: i lost context somewhat but can't you just pick your favorite language definition to pass as the first argument to reservedOp or whatever
11:05:13 <nand`> JamesRustle: not the way I meant it; I mean like a JavaScript version of the vim editor for those times when you can't bring it with you
11:05:36 <JamesRustle> I can't imagine that not sucking
11:06:41 <nand`> it can't be worse than using notepad, can it?
11:07:17 <nand`> but you're right, it would be silly
11:07:49 <luca> lol got tripped up here
11:07:54 <rwbarton> Rc43: there is a module somewhere that defines a bunch of those GenTokenParser things
11:07:56 <luca> @pl \x -> x-1
11:07:56 <lambdabot> subtract 1
11:07:59 <luca> haha subtract
11:08:12 <luca> is there a way of doing that point free since (-1) fails due to being a literal (-1)
11:08:19 <luca> +1 is fine as \x -> x+1
11:08:28 <nand`> ... subtract
11:08:33 <luca> subtract looks silly though
11:08:36 <S11001001> :t (- 1)
11:08:37 <lambdabot> forall a. (Num a) => a
11:08:40 <S11001001> hmm
11:08:45 <nand`> :t (+(-1)) -- even sillier
11:08:46 <lambdabot> forall a. (Num a) => a -> a
11:09:03 <luca> :t (-) 1
11:09:04 <lambdabot> forall t. (Num t) => t -> t
11:09:06 <luca> :P
11:09:10 <nand`> luca: not the same thing
11:09:28 <luca> > ((-) 1) 2
11:09:28 <nand`> (-) is not commutative :)
11:09:29 <lambdabot>   -1
11:09:34 <rwbarton> this question is specifically why subtract exists
11:09:40 <luca> > (flip (-) $ 1) 2
11:09:42 <lambdabot>   1
11:09:43 <luca> hah
11:09:48 <nand`> > subtract 1 2
11:09:48 <luca> yeh, subtract is looking rather nice now
11:09:49 <lambdabot>   1
11:11:23 <luca> yay ghc didn't want type annotations in my actual application of it
11:12:39 <wunki> is the "tab" character seen as two different characters in Haskell? "\t"?
11:12:46 <luca> shouldn't be
11:12:56 <luca> > "\ta"
11:12:57 <lambdabot>   "\ta"
11:12:59 <rwbarton> "\t" is a string containing one character
11:13:05 <rwbarton> > length "\t"
11:13:06 <lambdabot>   1
11:13:07 <luca> lol lambdabot disagrees 8D
11:13:18 <rwbarton> i don't know what you were trying to demonstrate
11:13:21 <luca> so why did it print "\ta" isntead of "   a"
11:13:26 <luca> wait
11:13:28 <luca> ignore me
11:13:28 <luca> haha
11:13:32 <rwbarton> because that is how strings are shown
11:13:32 <luca> > show "\ta"
11:13:33 <lambdabot>   "\"\\ta\""
11:13:37 <luca> hah
11:14:04 <nand`> > text "\ta"
11:14:05 <lambdabot>           a
11:14:19 <rwbarton> > length "\&"
11:14:20 <lambdabot>   0
11:14:33 <nand`> > "\&"
11:14:34 <lambdabot>   ""
11:14:56 <luca> yay <3 haskell
11:15:30 <nand`> Are there any good examples of applications that use vty-ui? I checked my package manager and it didn't pick up any reverse deps
11:15:35 <rwbarton> > map chr [14,72]
11:15:36 <lambdabot>   "\SO\&H"
11:15:47 <nand`> what about vanilla vty? So far I've found yi and hach
11:16:29 <otters> > map chr [14,71]
11:16:31 <lambdabot>   "\SOG"
11:17:01 <nand`> oh, never mind; hach has a reverse dep on vty-ui, not vty
11:17:06 <nand`> I guess I'll use that as an example
11:17:10 <nand`> s/reverse dep/dep/
11:17:23 <luca> @pl \x -> (tell x) >> (tell " ")
11:17:23 <lambdabot> (>> tell " ") . tell
11:18:03 <JamesRustle> @pl \tell x ->  (tell x) >> (tell " ")
11:18:04 <lambdabot> liftM2 flip ((>>) .) ($ " ")
11:18:16 <jjbohn> back
11:18:17 <luca> lmao
11:18:42 <luca> @pl is funny
11:18:43 <lambdabot> is funny
11:18:49 <luca> yes lambdabot, you are funny
11:20:01 <JamesRustle> @pl let f x = show x in (f (), f "hi")
11:20:01 <lambdabot> (show (), show "hi")
11:20:32 <nobdraisentone> nand`: why did vanilla vty is so important for you?
11:21:04 <nand`> nobdraisentone: I'm looking to develop terminal applications so I'm interested in all of the options available, including stuff like ncurses
11:21:15 <rico> is there a way to use the =~~ operator (of the Text.PCRE package) for multiline strings?
11:21:27 <nand`> I don't know how vty-ui compares to vty whatsoever, mind
11:22:11 <illissius> Oh.
11:22:56 <rico> I mean i am fiddling around with this for a few days (being relatively new to haskell) and I finally could get some matching going ... but now I see that multiline strings don't work (at least not without some modifiers) and I have no idea how to integrate them
11:23:09 * hackagebot git-annex 3.20120605 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120605 (JoeyHess)
11:23:12 <rico> I have a function like this
11:23:19 <rico> -- Replaces the whole match for the given regex using the given function
11:23:19 <rico> regexReplace :: String -> (String -> String) -> String -> String
11:23:19 <rico> regexReplace regex replace text = go text
11:23:19 <rico>     where
11:23:19 <rico>         go text = case text =~~ regex of
11:23:20 <rico>             Just (before, match, after) ->
11:23:22 <rico>                 before ++ replace match ++ go after
11:23:24 <rico>             _ -> text
11:23:30 <applicative> Rc43: http://hpaste.org/69560 maybe?
11:24:06 <rico> but where and how would I integrate modifiers? : )
11:25:13 <nobdraisentone> nand`: hach is really minimal application and use only some basic vty-ui features, take a look at https://github.com/dmalikov/HaCh/blob/develop/nclient/NClient/GUI.hs
11:25:16 <Rc43> applicative, yea, `x = makeTokenParser emptyDef` is the key; thanks
11:26:22 <rico> is there some way to make it work like this? or would I have to resort to some completely different approach?
11:27:26 <strager> @pl \x -> (a x, b x)
11:27:26 <lambdabot> liftM2 (,) a b
11:27:43 <luca> am I allowed to do: import Module (hiding x) import qualified Module (x)
11:27:53 <strager> Yes, except
11:27:54 <luca> (x) as M **
11:27:56 <strager> import Module hiding (x)
11:28:13 <luca> i want everything from Module imported, except that one of the functions is qualified
11:28:19 <strager> I'm not sure if the 'as' clause comes before or after the symbols
11:28:29 <rwbarton> luca: yes that will work
11:28:34 <nand`> I think before
11:28:57 <luca> yeh  import Module hiding (x) import qualified Module (x) as M
11:29:31 <nand`> luca: has to be import qualified Module as M (x)
11:29:38 <luca> ah
11:30:06 <illissius> Hmm. Today I learned that if you have types 's n' and 'S (S (S Z))' and want to unify them, it's only possible for 's' to be 'S' and 'n' to be 'S (S Z)', and not, for example, for 's' to be 'S S S' and 'n' to be 'Z'. In hindsight it's blindingly obvious.
11:30:32 <rico> does someone in here have some experience with the Text.Regex module?
11:31:14 <leino> I am using Prelude.writeFile to write to a file. when I go and look, using 'ls' from bash, I see the file there. but when I do some operations, for instance 'cat file.txt', cat tells me that the file doesn't exist.
11:31:25 <rico> @illissius and you wish you were smart eh? : ) I think you just got smarter
11:31:25 <lambdabot> Unknown command, try @list
11:31:35 <rwbarton> illissius: yes, and very important! otherwise instance selection for higher kinds wouldn't work (it is necessary that the type of return foo :: m a determines m and a)
11:31:38 <nand`> is ‘S S’ even possible?
11:31:43 <nand`> (what kind would S have?)
11:31:55 <strager> leino: Is it readable?  What perms does ls -l show?
11:32:01 <illissius> rico: If I were smart I would have realized it hours earlier :)
11:32:26 <applicative> Rc43: of course you can improve on emptyDef  which is here http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Language.html#v:emptyDef
11:32:44 <akosch> I'm checking out alternatives to parsec, but the 81 packages in the parsing category on hackage are a bit many to check out individually: could you recommend some of them? which are considered the state of the art in the community (today)?
11:32:45 <leino> strager: -rw-r--r--
11:32:53 <applicative> Rc43: i meant to point to the source http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/src/Text-Parsec-Language.html#emptyDef
11:33:41 <rico> illisius: oh well ... most people out there would have to spend an extraordinary amount of time to figure out what you learned today though
11:33:49 <applicative> akosch: i  think it depends what you are doing whether you want attoparsec or what
11:33:59 <leino> strager: can it be that it doesnt get closed? lsof doesnt show it, however
11:34:10 <pooya72> applicative: do you use yesod?
11:34:21 <strager> leino: Odd...  Can you tail -f it?
11:34:37 <Rc43> applicative, thanks; I have never seen this langDef before, it was suddenly to understand that example expression works not only with pure parsec.
11:34:38 <rwbarton> maybe the filename has some unexpected funny characters? (wild guess)
11:34:58 <leino> strager: it says it cannot open it: no such file or directory
11:35:17 <rwbarton> more likely you somehow aren't in the directory you think you're in
11:35:23 <akosch> applicative: performance / memory consumption is not an issue for me with parsec, but I thought maybe there are other, similarly high-level solutions out there
11:35:26 <applicative> Rc43: It's extremely confusing the way that chunk of Parsec works,
11:35:34 <leino> rwbarton: hg_3_3_hypergraphs.txt
11:35:40 <leino> so, no :)
11:35:44 <rico> illisius: do you know things about the regex stuff in haskell?
11:35:50 <rwbarton> also i assume you aren't on windows or any funny business like that
11:35:54 <Rc43> Hmm, it seems I should have been started from *.Language modules =/
11:35:59 <leino> rwbarton: nope
11:36:00 <companion_cube> do you think parsec can be used to parse something like 10Mb of text in a few seconds?
11:36:08 <Rc43> I am working on task on programming language implementation.
11:36:16 <Rc43> Just training/exam.
11:36:33 <strager> leino: Are you tab completing it?
11:36:36 <morel> akosch: check out happy
11:36:39 <luca> In my experiance parsing is 'usually' bounded by memory latency
11:36:39 <strager> leino: Can you ls -l it directly?
11:36:50 <Rc43> So mb using ready solutions is cheating.
11:36:52 <akosch> morel: thanks, will do
11:37:05 <leino> strager: what do you mean by tab completing?
11:37:10 <rico> @pl test
11:37:11 <lambdabot> test
11:37:17 <rwbarton> cat hg_3_<tab>
11:37:20 <rwbarton> what happens
11:37:23 <strager> leino: You can type part of the filename, and hit 'tab' to complete the filename.
11:37:31 <rico> @pl help
11:37:31 <lambdabot> help
11:37:39 <strager> This reduces the chance of typing mistakes, and reveals issues like odd unicode characters.
11:37:41 <leino> strager: ls -l shows '-rw-r--r-- 1 leino leino     182 Jun  5 21:20 hg_3_3_hypergraphs.txt '
11:37:44 <applicative> akosch: I think the only objection state-of-the-art people have to parsec is efficiency, no?  there are alternatives like uu-parsinglib that are parseclike with different ideas
11:37:52 <leino> strager: yeah I can do that
11:37:57 <nand`> leino: is that a space after the t?
11:38:03 <illissius> rwbarton: Yeah, it's just another manifestation of the "thou shalt not have type-level lambdas" thing I've run into a few times before. Once I actually try to write it down with the parentheses and all it's pretty obvious that s = 'S (S (S' doesn't exactly work and it would have to be '/\n -> S (S (S n))' (which it can't).
11:38:07 <nand`> (in the file name)
11:38:11 <rwbarton> illissius, yup
11:38:24 <leino> nand: why yes, it is   :|
11:38:38 <nand`> leino: tab completion would have solved that, otherwise “...txt\ ”
11:39:25 <leino> nand: problem solved!
11:40:25 <applicative> Rc43: yeah, if you are parsing a language, you need to figure out the 'stylized' use of import and export mentioned in http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Token.html#v:makeTokenParser
11:41:38 <luca> is there a way (without diong it manually) of doing say mapM_ f xs but between each x in xs, another monadic action would happen?
11:42:02 <rwbarton> is this "manual"? mapM_ (\x -> f x >> anotherAction) xs
11:42:08 <nand`> mapM_ f (intersperse x xs)
11:42:16 <rico> Is there something wrong with the Text.Regex? should I use something else to modify text? I mean having a mostly python/php background Perl Regular expressions always served me well ... But is there something else I should be using for matching and replacing text?
11:42:19 <rwbarton> mine has an extra anotherAction at the end
11:42:25 <luca> yeh, i don't want it at end
11:42:32 <rwbarton> intersperse is a good idea
11:42:41 <rwbarton> sequence_ $ intersperse anotherAction $ map f xs
11:42:56 <nand`> oh, yeah; my example was flawed
11:43:02 <luca> intersperce yay
11:43:38 <akosch> applicative: in some cases I find it difficult to formulate my ideas in parsec, but maybe it's just me. Using parsec feels a bit like imperative programming in contrast to me being used to writing mostly declarative code in Haskell. I make a lot of mistakes, usually concerning greediness of my parsers (I haven't been using parsec for long)
11:44:20 <illissius> :t intercalate
11:44:21 <lambdabot> forall a. [a] -> [[a]] -> [a]
11:44:33 <rwbarton> :t intersperse
11:44:34 <lambdabot> forall a. a -> [a] -> [a]
11:44:47 <akosch> applicative: also I find it hard to compose more complex parsers to do what I want (as I said I'm new to it though)
11:45:16 <nand`> @check \x xs -> intercalate x xs == concat (intersperse x xs)
11:45:18 <lambdabot>   "OK, passed 500 tests."
11:46:22 <luca> nicer way of doing: case (bool) of True -> a False -> b ?
11:46:34 <nand`> if bool then a else b
11:46:34 <luca> wait. if
11:46:36 <luca> yeh
11:46:36 <luca> lol
11:46:45 <applicative> if bool then a else b
11:46:59 <nand`> you don't need the extra ( ) around bool either
11:47:29 <luca> i know, but it's automatic from working in imperative languages so much :P
11:47:37 <Rc43> Any ideas how to implement if-the-else in way, described at http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Expr.html ?
11:47:46 <nand`> has anybody thought about integrating hlint's errors to GHC (as warnings)?
11:48:03 <Rc43> But it seems, it is simplier to write custom parser for it.
11:48:15 <rico> Ok ... I will try to reformulate my question ... I am trying to wrap each <table.*?table> part of a given piece of HTML with some stuff
11:48:26 <rico> is there a way to do this in haskell?
11:48:43 <parcs`> Rc43: this will help you http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Token.html
11:50:14 <akosch> applicative: also I miss a lot of common things out of the standard functions. Surely I could write my own solutions, but given that parsec isn't a new project I wonder why someone didn't write them already
11:50:34 <illissius> Though now I'm a bit fuzzled trying to reconcile "thou shalt not have type-level lambdas" with the fact that 'forall' is the syntax we use for type-level lambdas.
11:50:42 <applicative> Rc43: here is someone doing it from scratch https://github.com/Jem777/deepthought/blob/master/src/Lexer.hs
11:51:58 <illissius> Thou shalt not have type-level lambdas inside of type variables? But isn't that what ImpredicativeTypes does?
11:51:59 <applicative> akosch: I think my experience is similar
11:52:23 <heatsink> Those are foralls, not lambdas
11:52:34 <illissius> what's the difference?
11:52:53 <heatsink> Lambdas are applied to arguments inside types.
11:53:01 <heatsink> Foralls are applied to arguments inside expressions.
11:53:10 <heatsink> value-level expressions.
11:53:38 <illissius> processing...
11:54:32 <applicative> Rc43: sorry, keep spamming, but if you look at their next module you see what is intended by the example  we started with https://github.com/Jem777/deepthought/blob/master/src/Expr.hs
11:54:51 <rico> ok ... I guess I will just tail this channel ... and hopefully someone will bring up the Regex topic sometime : )
11:55:17 <heatsink> If I have the lambda-term ((\a. [a]) Int), it reduces to [Int]
11:55:41 <applicative> Rc43 when you write a language definition like in the Lexer.hs above you don't use the exrpressions like parens and natural you find in Parsec, you export your own
11:55:42 <heatsink> That is, a type-level lambda applied to an argument
11:55:59 <akosch> applicative: good to know I'm not alone with this. I heard a lot of praise about parsec before and it's a nice improvement over parsing libraries for other languages (trivial examples look just great), but I think Haskell can still do better :)
11:55:59 <Rc43> applicative, thanks; btw, this way with expr works fine; this part of work is done
11:56:24 <heatsink> If I have (forall a. [a]), I can't do anything at the type level to get rid of the 'forall'.  It can't be reduced to something else.
11:56:54 <c_wraith> dcoutts: you around?
11:57:24 <rwbarton> in particular, "(forall a. [a]) Int" is not [Int] (or sensible at all)
11:57:30 <Rc43> applicative, yes, it was mistake to write code firstly; but now I haven't time to refactor all my code -- I must finish task to next evening. Any way, I think, it will be not bad experience.
11:58:02 <illissius> heatsink: Ah, so foralls can be unified, but not applied?
11:58:31 <nand`> “foralls can be specialized, but not applied” <- correct?
11:59:56 <illissius> (Whereas lambdas can be applied, and *could* be unified but nobody's figured out how, if I'm remembering correctly?)
12:00:06 <applicative> akosch: what you need is a really full service flotilla like trifecta :)   https://github.com/ekmett/trifecta/
12:01:04 <heatsink> Foralls can't be applied at the type level.  They can be applied at the value level.  That's less like type appilcation and more like a function call.
12:03:27 <heatsink> By unification, do you mean deciding whether two types are equal?
12:03:27 <illissius> Right. Thanks for the explanation.
12:03:27 <akosch> applicative: wow, a bit overwhelming. I'm not really impressed by it's homepage :)
12:04:16 <applicative> akosch: I think the homepage is edwardk's blog....
12:04:47 <Siod> how should i create state for a plugin; i'd like to encapsulate it inside the plugin
12:05:49 <Siod> darcs is doing what i want with its notion of commands, but those commands don't have state
12:06:04 <luca> is there a way of doing a 'default' in case?
12:06:17 <illissius> heatsink: well, if you have a 'forall a. [a]' that unifies with '[Int]' by substituting a = Int. If you have '/\a -> [a]' then... it's meaningless to ask whether it unifies with '[Int]' because the kinds are different?
12:06:31 <pooya72> is yesod good if someone is trying to learn the in's and out's of haskell, or does it abstract too much away where you're just working with yesod api?
12:06:41 <akosch> applicative: which is? I can't seem to find it on google
12:07:11 <Siod> in the interface between the plugin and plugin manager i could use an existential type for state
12:07:21 <applicative> akosch: http://comonad.com/reader/2011/a-parsec-full-of-rats/ maybe he hasnt written about it much; it comes up in here
12:07:32 <heatsink> illissius, That's actually instantiation followed by unification.
12:08:16 <Siod> what exactly is a comonad? are lenses comands?
12:08:23 <Siod> s/comands/comonads
12:09:16 <heatsink> If we have "foo :: forall a. [a]", and "foo" is mentioned in a program, then that translates to "foo @ b" where b is a new type variable and @ is the type-application operator for foralls
12:09:20 <akosch> applicative: thanks, I will definitely check it out. any thoughts about happy, which was mentioned by morel earlier?
12:09:33 <heatsink> Then, b can be unified with something
12:09:50 <shapr> Is there a handy utility wrapper for catchError that rethrows the errors of your choice?
12:10:08 <applicative> akosch: never used happy
12:10:30 <heatsink> Note that the type of "foo @ b" is "[b]".  Instead of a polymorphic type, it's a type with a unifiable variable.
12:10:30 <nand`> a comonad is some w that has extract :: w a -> a and duplicate :: w a -> w (w a)
12:10:48 <illissius> nand`: and fmap
12:11:15 <nand`> right
12:11:17 <copumpkin> they also need to behave right :)
12:11:26 <illissius> heatsink: I see, thanks!
12:11:37 <nand`> with these can be defined (=>>) :: w a -> (w a -> b) -> w b; not too dissimilar from (>>=) :: m a -> (a -> m b) -> m b
12:11:39 <nand`> :)
12:11:58 <miniBill> is there a better way to say this -> isDODD = not <$> ( (||) <$> (endswith "/.") <$> (endswith "/..") )
12:12:18 <sipa> nand`: any nontrivial useful example of a comonad?
12:12:20 <heatsink> @unpl not <$> ( (||) <$> (endswith "/.") <$> (endswith "/..") )
12:12:21 <lambdabot> (not <$> (((||) <$> (endswith "/.")) <$> (endswith "/..")))
12:12:45 <heatsink> "pointless" doesn't understand applicative combinators
12:12:53 <pooya72> applicative: I guess yesod does what I've been looking for :) Another nifty backend is wai-handler-webkit. This backend combines Warp and QtWebkit to create an executable that a user simply double-clicks. This can be a convenient way to provide an offline version of your application.
12:13:24 <rwbarton> @pl \x -> not (endswith "/." x || endswith "/.." x)
12:13:24 <lambdabot> not . ap ((||) . endswith "/.") (endswith "/..")
12:13:25 * hackagebot RepLib 0.5.3 - Generic programming library with representation types  http://hackage.haskell.org/package/RepLib-0.5.3 (BrentYorgey)
12:13:27 * hackagebot unbound 0.4.1 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.4.1 (BrentYorgey)
12:13:39 <parcs`> luite: use a pattern that always succeeds
12:13:42 <rwbarton> btw you mean not <$> ( (||) <$> (endswith "/.") <*> (endswith "/..") ) I think
12:13:48 <parcs`> eg _
12:13:48 <ClaudiusMaximus> :t \f a b -> not $ join (liftM2 (||)) f a b
12:13:49 <lambdabot>     Couldn't match expected type `t -> Bool'
12:13:49 <lambdabot>            against inferred type `Bool'
12:13:49 <lambdabot>     In the first argument of `liftM2', namely `(||)'
12:13:53 <miniBill> rwbarton: yupp
12:14:25 <shachaf> dmwit: Unbound threads aren't "assigned" to OS threads?
12:14:44 <shachaf> Presumably when an OS thread is busy evaluating values for the Haskell thread, it's "assigned" in some sense, at least.
12:14:51 <miniBill> this is not bad -> not . ap ((||) . endswith "/.") (endswith "/..")
12:14:58 <luite> parcs`: ?
12:15:25 <illissius> akosch: iirc happy is a parser generator, you give it a grammar and it generates haskell for you. whereas with parsec and friends you write haskell yourself using the combinators they provide.
12:15:25 <dmwit> shachaf: Are you asking about my questions in #ghc?
12:15:35 <shachaf> Yes.
12:15:39 <dmwit> shachaf: If so, I'm responding to JaffaCake's comment some hours ago in the same channel.
12:15:41 <nand`> sipa: there's a Comonad instance for “Tree” in the Control.Comonad package
12:15:44 <dmwit> let me quote it, one moment
12:15:55 <nand`> but I've been scratching my head over practical applications of comonads as well
12:16:17 <dmwit> this point I find a bit confusing: "Evacuate any other unbound threads on the same OS thread to the newly  allocated OS thread."
12:16:26 <dmwit> because that doesn't really correspond to what happens
12:16:33 <dmwit> actually the new OS thread just takes over running unbound threads
12:17:24 <parcs`> luite: oops i meant luca
12:17:24 <Siod> Main Program (MP) -> Plugins; MP is ignorant of plugin implementation -- how should Plugins create their own state?
12:17:40 <illissius> nand`: don't worry, so have a lot of people. there are some blog posts exploring it (on sigfpe's blog iirc, and probably edwardk's)
12:17:54 <Siod> MP does have basic interface to plugins; e.g., data Plugin = Plugin { pluginName, pluginCommand } ect
12:18:50 <luca> parcs` thanks
12:19:14 <Siod> Plugins implements thier own Plugin; eg. data Plugin = Plugin { pluginName = "hello world", pluginInit = myPluginInit }
12:19:37 <luca> oh i was curious; isn't it technically incorrect to have floating point operations as pure?
12:20:19 <geekosaur> yes, and that's a rant that comes up somewhat regularly :)
12:20:22 <rwbarton> luca, not as long as you don't muck about with the floating point control registers via FFI... or do I misunderstand something
12:21:23 <nand`> “extend” for Tree seems interesting; given something like say sumTree = sum . flatten :: Num n => Tree n -> n; I can use “extend sumTree” to get the sum of the node + all children at each node
12:21:25 <geekosaur> actually, I suppose they are fully determinate if you understand everything that's going on, or some such
12:22:29 <dmwit> nand`: Well, for commutative monoids like (+) you can do much better in terms of efficiency than that. =)
12:22:37 <rwbarton> I believe they are logically pure as long as you don't write to the rounding mode or read from the floating point exception registers
12:23:23 <rwbarton> well, and maybe there is the excess-precision issue also on x86
12:25:21 <tazjin> Where does $hoogle data put the DB it generates?
12:25:43 <rwbarton> different architectures/compilers may implement floating point arithmetic differently too, but then you could say the same about Int
12:27:57 <illissius> nand`: this one is interesting, for example: http://blog.sigfpe.com/2008/03/comonadic-arrays.html
12:32:24 <adnauseam> can sumCont (d:ds) f = f (d + foldr (+) 0 ds) be considered cps ?
12:32:49 <shachaf> Yes.
12:32:57 <adnauseam> thanks ma n
12:33:44 <byorgey> why  d + foldr (+) 0 ds  instead of   foldr (+) 0 (d:ds) ?
12:34:07 <shachaf> Or foldr (+) d ds
12:34:09 <dmwit> or foldr (+) d ds
12:34:29 <byorgey> assuming (+) is commutative, sure
12:34:34 <dmwit> Depending on intended usage, possibly also foldl' (+) 0 (d:ds)
12:34:43 <shachaf> byorgey: If it's not, then yours is also possibly wrong.
12:35:05 <byorgey> it is?
12:35:34 <shachaf> Oh, no, it's not.
12:35:39 <dmwit> > d + foldr (+) 0 [x,y,z]
12:35:40 <lambdabot>   Ambiguous occurrence `x'
12:35:40 <lambdabot>  It could refer to either `L.x', defined at <local...
12:35:41 <byorgey> pretty sure   f d (foldr f z ds) == foldr f z (d:ds)  for any f,z
12:35:53 <shachaf> Never mind, indeed.
12:36:01 <dmwit> > w + foldr (+) 0 [x,y,z]
12:36:02 <lambdabot>   Ambiguous occurrence `x'
12:36:02 <lambdabot>  It could refer to either `L.x', defined at <local...
12:36:10 <dmwit> Oh, I didn't read the error message.
12:36:13 <dmwit> anyway
12:36:30 <byorgey> @pl sumCont ds f = f (sum ds)
12:36:31 <lambdabot> sumCont = flip id . sum
12:36:48 <shachaf> Anyway byorgey was right.
12:37:20 <shachaf> @pl sc l f = f (foldr (+) 0 ds)
12:37:20 <lambdabot> sc = const ($ foldr (+) 0 ds)
12:37:23 <shachaf> @pl sc l f = f (foldr (+) 0 l)
12:37:23 <lambdabot> sc = flip id . foldr (+) 0
12:37:30 <nand`> illissius: interesting example
12:39:15 <orzo> hi. I'm wanting to look at some haskell code in vim in gnome-terimal on debian wheezy.  There is apparently unicode symobols that are showing garbled.  Anybody got a tip as to how to make my terminal show these?
12:39:39 <shachaf> orzo: That's probably more of a vim and/or gnome-terimal and/or debian wheezy question.
12:39:47 <shachaf> It works fine for me, for what it's worth.
12:39:59 <shachaf> I recommend that you take The Usual Debugging Steps.
12:40:02 <JamesRustle> orzo: screenshot?
12:40:10 <nand`> it would work for me if my terminal displayed unicode properly
12:42:08 <dmwit> orzo: First check that your locale's encoding matches the file's encoding; then check that your terminal can correctly show unicode characters; then check that vim is using the correct encoding when reading the file.
12:43:17 <dmwit> "locale" and "file" will help with the first; "cat" with the second; and :help 'fenc" with the third.
12:43:24 <orzo> i believe my locale is set for english utf8
12:43:25 <dmwit> uh, :help 'fenc'
12:43:41 <JamesRustle> you don't actually need the second '
12:43:45 <orzo> first line of output of locale is LANG=en_US.UTF-8
12:43:48 <JamesRustle> orzo: so how about that screenshot?
12:43:53 <orzo> uh
12:44:00 <orzo> okay i guess
12:45:43 <orzo> http://wordslurp.com/2012-06-05-154406_1280x800_scrot.png
12:45:53 <JamesRustle> 404
12:46:07 <orzo> holon
12:46:32 <diszno> boff
12:46:56 <orzo> sorry, http://wordslurp.com/2012-06-05-154417_1280x800_scrot.png
12:47:34 <JamesRustle> orzo: :set fenc?
12:48:23 <orzo> JamesRustle: that command outputs that the variable is empty
12:48:40 <JamesRustle> orzo: :set fencs?
12:48:54 <orzo> fileencodings=ucs-bom
12:49:21 <JamesRustle> open your ~/.vimrc, add "set fencs=ucs-bom,utf-8,default,latin1"
12:49:38 <JamesRustle> restart vim, report results
12:50:28 <orzo> it looks the same to me
12:50:32 <orzo> still garbled
12:50:44 <JamesRustle> orzo: :set enc?
12:50:57 <orzo> it says latin1
12:51:02 <JamesRustle> ok, that's definitely bad
12:51:22 <JamesRustle> I wonder what's going on
12:51:35 <orzo> hm
12:51:48 <orzo> maybe i should try another editor
12:52:20 <JamesRustle> 'encoding' is supposed to be set based on LANG and you said yours had UTF-8 in it
12:52:51 <orzo> gedit shows symbols for Real and Natural numbers
12:53:05 <JamesRustle> orzo: :echo has("multi_byte")
12:53:36 <orzo> 1
12:53:45 <JamesRustle> ok, so that's fine
12:54:46 <orzo> does haskell use those symbols as standard type names?
12:54:50 <JamesRustle> no
12:55:45 <JamesRustle> orzo: can you paste the full output of 'locale' somewhere?
12:56:01 <orzo> alright
12:56:20 <orzo> holy crap
12:56:22 <orzo> it changed
12:56:25 <orzo> it says C
12:56:32 <JamesRustle> no, the full output
12:56:37 <orzo> yeah well
12:56:53 <orzo> its nothing like what i saw before
12:57:42 <orzo> waiting for a pstebin to load
12:57:54 <JamesRustle> which pastebin are you using?
12:58:09 <orzo> paste.debian.net
12:58:13 <orzo> http://paste.debian.net/173032/
12:58:21 <orzo> no utf there
12:58:24 <orzo> its all C now
12:58:35 <JamesRustle> yeah, that's likely to be the source of your problems
12:58:47 <JamesRustle> btw, you can remove the 'set fencs=...' line from your .vimrc
12:59:23 <JamesRustle> the command 'LANG=en_US.UTF-8' will probably fix it in that shell
13:01:09 <Cheery> I looked at the light table video again.
13:01:10 <Cheery> wondering.
13:01:26 <Cheery> how does that interactive REPL work?
13:01:44 <Cheery> which shows the values in source code
13:03:23 <bjorkintosh> is '98 the most recent haskell standard?
13:03:43 <JamesRustle> bjorkintosh: no
13:03:54 <bjorkintosh> what is?
13:03:58 <dmwit> ?where report
13:03:59 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
13:05:01 <bjorkintosh> ah. i was here: http://www.haskell.org/onlinereport/
13:05:11 <bjorkintosh> why doesn't that page show the most recent report by default?
13:05:46 <byorgey> excellent question.
13:08:17 <killy9999> how can I change the directory into which packages from hackage are installed?
13:08:37 * hackagebot cron 0.1.0 - Cron datatypes and Attoparsec parser  http://hackage.haskell.org/package/cron-0.1.0 (MichaelXavier)
13:08:41 <killy9999> e.g. I want "cabal install --global foo" to place all files in /usr/ghc
13:09:01 <Cheery> hmm.. the term was live coding
13:14:46 <JamesRustle> killy9999: you have to edit your ~/.cabal/config
13:14:52 <JamesRustle> do you have one?
13:15:14 <orzo> omg, its god*d*md GNOME 3 that screwed with the locale
13:15:24 <orzo> you have to change it in 'dconf'
13:15:33 <orzo> system settings are jus toverridden
13:16:21 <killy9999> JamesRustle: thanks, I've found it
13:16:47 <keep_learning> Hello All
13:16:57 <keep_learning> I am reading this paper http://research.microsoft.com/en-us/um/people/simonpj/papers/c--/hoopl-haskell10.pdf
13:17:09 <keep_learning> In topic 3.4 Graphs
13:17:41 <keep_learning> it says "More general graphs are represented by GMany, which has three
13:17:41 <keep_learning> ﬁelds: an optional entry sequence, a body, and an optional exit
13:17:41 <keep_learning> sequence."
13:18:09 <keep_learning> I am bit confused about optional entry and exit sequence.
13:18:47 <keep_learning> When we concatenate the blocks using BCat
13:19:07 <keep_learning> If it will enter and then it will leave
13:19:46 <keep_learning> So why optional entry ?
13:22:37 <hpaste> lazyfinn pasted “nested foreach” at http://hpaste.org/69566
13:22:46 <lazyfinn> how would you do this in haskell?
13:23:36 <lazyfinn> two simple nested loops and a condition
13:23:47 <lazyfinn> must be pretty easy
13:27:15 <Adeon> that piece of code modifies a list
13:27:49 <Adeon> do you mean to get a list that has elements of list2 that are not in list1
13:28:39 <snhmib> lazyfinn: [ c | c <- a, not (c `elem` b) ] :)
13:28:55 <Adeon> yeah, that's one
13:29:59 <byorgey> filter (not . (`elem` b)) a
13:30:18 <lazyfinn> mm, thanks
13:30:29 <lazyfinn> so much shorter code :)
13:30:40 <lazyfinn> sometimes shorter is good :)
13:31:03 <nand`> if you have an Ord instance instead of Eq you can optimize it by using a Collection instead of a list
13:31:34 <lazyfinn> don't think I need that..
13:32:22 <nand`> well, it would be O(n log n) instead of O(n²) :)
13:33:11 <lazyfinn> mm
13:33:24 <lazyfinn> naah, this is not important
13:33:47 <armlesshobo> nand`: he's lazy. it's in he name :P
13:33:49 <nand`> hehe
13:33:55 <lazyfinn> :)
13:34:02 <nand`> also did I say Collection? I meant Set
13:34:13 <Peaker> @type notElem
13:34:14 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
13:34:18 <Adeon> good thing our language is lazy as well
13:34:41 <byorgey> Peaker: oh right, nice =)
13:34:49 <nand`> wouldn't be much more code for the set :)
13:35:00 <Peaker> @type ala
13:35:01 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
13:35:13 <nand`> :t \b -> let set = fromList b in filter (`notMember` set)
13:35:14 <lambdabot> Not in scope: `notMember'
13:35:17 <nand`> :(
13:35:31 <nand`> :t \b -> let set = S.fromList b in filter (`S.notMember` set)
13:35:33 <lambdabot> forall a. (Ord a) => [a] -> [a] -> [a]
13:35:36 <mietek> Is it possible to use Cabal to substitute ModuleFoo with TestModuleFoo for a specific target?
13:35:47 <Peaker> nand`, I don't think you need the "let"
13:36:03 <Peaker> (the S.fromList can be in there and would be computed once)
13:36:40 <Bakon> Hi #haskell
13:36:41 <nand`> I see; I'm not entirely sure what gets recalculated sometimes so I just use a let for good measure
13:37:27 <nand`> :t \b -> filter (`S.notMember` S.fromList b)
13:37:28 <lambdabot> forall a. (Ord a) => [a] -> [a] -> [a]
13:37:31 <nand`> there you go lazyfinn :)
13:37:33 <Bakon> I'm trying to implement a DP algorithm. My first version was a simple, elegant memoization using the laziness of the Array time.
13:37:41 <Bakon> *Array type
13:37:56 <Bakon> the problem is - it runs almost 1000 times slower than unoptimized C
13:38:32 <hpaste> int80_h pasted “problem with createProcess” at http://hpaste.org/69567
13:38:41 <Bakon> I've looked around the web, but all the solutions seem to either be like mine, or they use the ST Monad
13:39:16 <Bakon> I'm wondering if there's a way to write it idiomatically but not take such a gigantic performance hit.
13:39:28 <Cale> Bakon: Just to check, are you building with -O2?
13:39:31 <Bakon> yeah.
13:39:34 <Cale> Okay
13:40:16 <Cale> 1000 times is a significantly larger factor than I'd usually expect.
13:40:18 <Cale> hmm
13:40:51 <Bakon> Same. I'd expect 10 or so.
13:40:56 <Cheery> hmm
13:41:10 <Cheery> seems like I'd have to spend some time writing code still
13:41:26 <Cale> Well, there are other data structures you could try using, like just an IntMap or something like that which has reasonably fast insertion/lookup
13:41:43 <Cale> Though I'm surprised about the Array solution being so slow that I wonder if that's really the problem
13:42:07 <Cale> Is it a numerical problem?
13:42:18 <Cale> Are the functions you're using polymorphic or monomorphic?
13:42:21 <luca> @pl \f = (tell $ (fst f) ++ ":") >> (tell_expr $ snd f)
13:42:22 <lambdabot> (line 1, column 4):
13:42:22 <lambdabot> unexpected "="
13:42:22 <lambdabot> expecting operator, pattern or "->"
13:42:32 <luca> @pl \f -> (tell $ (fst f) ++ ":") >> (tell_expr $ snd f)
13:42:33 <lambdabot> ap ((>>) . tell . (++ ":") . fst) (tell_expr . snd)
13:42:38 <Bakon> To try out, I'm just doing Pascal's triangle mod a million
13:42:42 <Cheery> but first sauna
13:42:42 <Cheery> maybe I'll get the editor done this night
13:43:14 <Adeon> int80_h: try separating the "--pool vm" to "--pool", "vm"
13:43:15 <Cale> Are the type signatures Num a => ... or using Int/Integer?
13:43:21 <Bakon> Int
13:43:38 <Cale> hrm
13:43:43 <Bakon> could it be laziness?
13:44:04 <Cale> Well, laziness can be helpful with dynamic programming
13:44:14 <int80_h>  Adeon: thanks :)
13:44:15 <Bakon> it definitely makes for an elegant solution.
13:44:23 <Adeon> int80_h: as it is now, it takes "--pool vm" as a single argument
13:44:29 <Adeon> normally if you wrote that in shell, the shell automatically separates them
13:44:45 <Cale> It's usually not inefficient either. Can you check somehow that things are actually being memoised as you expect?
13:44:50 <Adeon> (which you would avoid by using backslash so --pool\ vm would be a single argument)
13:45:03 <Bakon> Cale > What do you mean?
13:45:27 <Bakon> The values I get are correct, but I'm not sure how to check the order in which values are evaluated.
13:45:29 <Cale> I mean, print the (i,j) entry of this structure, and then do it again and make sure that it's actually faster.
13:45:37 <Bakon> ah
13:45:53 <Cale> Because if it's just recomputing everything, then that would explain the large factor slowdown.
13:46:14 <Cale> (Maybe can we see the code?)
13:47:39 <luca> @pl \x -> sequence_ $ intersperse (tellLn ";") $ map tell_expr x
13:47:39 <lambdabot> sequence_ . intersperse (tellLn ";") . map tell_expr
13:48:02 <Bakon> Cale > Yeah, seems to be memoizing right
13:48:48 <Bakon> Here's the code : arr n m = let a = listArray ((0,0),(n,m)) [f (i,j) | i <- [0 .. n], j <- [0 .. m]] in a
13:49:06 <Bakon> where f (0,_) = 1
13:49:15 <navaati> totally hs, but… is someone on fedora here ? i'd like to see what is the official gdm.service unit file (it's not shipped with gdm sources)
13:49:17 <Bakon> where f(_,0) = 1
13:49:27 <navaati> s/hs/off-topic/
13:49:32 <Bakon> where f (i,j) = (a ! (i, j-1) + a ! (i-1, j)) `mod` 1000000
13:49:41 <Cale> Try something for me -- replace n and m with top-level constants.
13:49:49 <Cale> Or else
13:50:05 <Cale> myArr = arr 1000 1000  -- or something
13:50:09 <Cale> at the top level
13:51:29 <copumpkin> arr matey
13:51:31 <Bakon> yeah
13:51:39 <Bakon> it's about 20% faster
13:51:40 <Bakon> :P
13:52:55 <Cale> well, that's something
13:52:56 <Bakon> I just defined n and m to be 1000 and removed the arguments from 'arr'
13:53:08 <Cale> Yeah, functions aren't automatically memoised
13:53:19 <Cale> (because it would result in nothing ever being GCed)
13:53:29 <Bakon> right
13:53:36 <Bakon> but all the memoizing is internal to the function, no?
13:54:08 <Cale> well, do you only apply it once?
13:54:24 <Bakon> yeah
13:54:44 <Bakon> I mean I could make it persistent
13:55:10 <Bakon> but actually calculating the matrix in the first place is the bottleneck
13:55:13 <Nisstyre> Is this a good way of finding the next power of two after a certain number? nextPower n = 2 ^ (ceiling (logBase 2 n))
13:55:22 <Nisstyre> any danger of floating point problems?
13:55:38 <Nisstyre> (I know it will fail on 0 btw)
13:56:07 <Bakon> Nisstyre - strictly after?
13:56:12 <Nisstyre> Bakon: yeah
13:56:20 <Nisstyre> like for 34 it gives 64
13:56:25 <Nisstyre> 31, 32
13:56:30 <Bakon> then you'll want floor (log2 n - 1)
13:56:36 <Nisstyre> oh, that's nicer
13:56:41 <Bakon> since your function gives nextPower 1 = 1
13:57:36 <Cale> Bakon: yeah, in that case, it's a little confusing that fixing n and m would be any improvement, but perhaps it causes other definitions to get floated up and optimised better
13:57:44 <Cale> hmm
13:58:59 <Nisstyre> Bakon: that doesn't seem to work
13:59:21 <Bakon> Nisstyre: sorry, I just gave you a partial answer
13:59:57 <Bakon> nextPower n = 2 ^ (floor ((logBase 2 n ) -1))
14:00:02 <Nisstyre> yeah I wasn't sure what you meant
14:00:03 <Nisstyre> okay
14:00:48 <Bakon> wait no, that doesn't work either
14:00:58 <Nisstyre> Bakon: that gives a different answer though, to clarify, I want the next power greater than the current number
14:01:05 <Bakon> sorry. +1 not -1
14:01:22 <Nisstyre> my logic behind using ceiling is that it will always give the next power of 2 greater
14:01:33 <Nisstyre> but I'm not sure if there's a chance of any issues with that
14:01:45 <Nisstyre> other than 0 and 1 not being defined
14:01:49 <Bakon> extPower n = 2 ^ (floor ((logBase 2 n )  + 1))
14:01:52 <Nisstyre> (or negative numbers)
14:01:59 <Bakon> The only difference between your version and mine
14:02:14 <Bakon> is that nextPower (2^n) = 2^(n+1) in my version'
14:02:27 <Bakon> and nextPower (2^n) = 2^(n) in yours
14:02:36 <Nisstyre> well, that's actually what I want
14:02:46 <Nisstyre> if it's a power of 2 then it should stay a power of 2
14:03:10 <Bakon> ok, then yours is right for any positive value of n
14:03:13 <Nisstyre> To give some context, this is for a hash tree implementation
14:03:58 <dmwit> Nisstyre: http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2Float
14:04:00 <Nisstyre> Bakon: useful to know that if I ever do need that kind of function though
14:04:27 <Bakon> Nisstyre: It's all a matter of how you treat the border cases, right
14:04:59 <Bakon> the only difference between ceil (n) and floor(n)+1 is how the integers are treated.
14:05:17 <Nisstyre> dmwit: cool, I'm not much of a bit operations person, so I would never have thought of that
14:06:22 <dmwit> Of course, to use the fast version (the one that doesn't go via Float) you have to know exactly what bitwidth you're working with.
14:06:26 <dmwit> Dunno whether this is an issue for you or not.
14:07:18 <Nisstyre> I could change my code to do that, but I'm only doing this once in the entire program
14:07:27 <Nisstyre> so I don't think speed is an issue
14:07:50 <Bakon> Nisstyre: Not worth it, then. I'd avoid bit twiddling unless speed is very much an issue
14:15:43 <nand`> > (\xs -> init $ zipWith (++) (tails xs) (inits xs)) [1,2,3]
14:15:45 <lambdabot>   [[1,2,3],[2,3,1],[3,1,2]]
14:19:16 <deadrabbit> applyTwice :: (a -> a) -> a -> a
14:19:24 <deadrabbit> applyTwice f x = f (f x)
14:19:35 <nand`> applyTwice f = f . f
14:19:39 <nand`> = join (.)
14:19:47 <deadrabbit> with this function if i do (*3) 6
14:19:52 <luca> @pl \f x -> f (f x)
14:19:52 <lambdabot> join (.)
14:20:07 <deadrabbit> how does it know that what i want done with the 6 on the end
14:20:17 <deadrabbit> that is if i want it added to 9 or multiplied?
14:20:19 <luca> (*3) is a function
14:20:32 <luca> it is a function that takes a value, multiplies it by 3
14:20:54 <luca> 3 * 6 is syntax sugar if you will for (*) 3 6
14:20:56 <james-ubc> hey guys! do any of you know if there's anything in haskell similar to scheme's h2dp/image?
14:21:02 <nand`> deadrabbit: to reduce it; applyTwice (*3) 6 = (*3) ((*3) 6) = 3 * (3 * 6)
14:21:32 <deadrabbit> thanks nand' that helps a lot :)
14:21:39 <dmwit> (*3) ((*3) 6) = (6 * 3) * 3
14:21:43 <james-ubc> like something to draw suff with and create super simple games, like snake...
14:21:57 <dmwit> could be slightly different than 3 * (3 * 6) depending on your Num instance
14:22:24 <nand`> true
14:22:40 <nand`> I was drawing on the commutativity of (*) in my simplification
14:22:47 <dmwit> james-ubc: I've heard good things about gloss for beginners.
14:23:30 <alpounet> james-ubc, you may want to check out gloss indeed, i've tested it myself and found it to be pretty cool! there's a game module for simplistic games
14:25:13 <nand`> deadrabbit: to perhaps clarify dmwit's point, (*3) ((*3) 6) = (\x -> x*3) ((\x -> x*3) 6) = (\x -> x*3) (6 * 3) = (6 * 3) * 3
14:25:21 <hughfdjackson> :| gloss looks ..
14:25:32 <hughfdjackson> :D exactly the kind of thing i was looking for
14:25:44 <hughfdjackson> something fun to mess about with that made me feel powerful ;)
14:25:52 <alpounet> and there's gloss-web
14:26:07 <alpounet> to output things to your favorite browser :)
14:32:54 <james-ubc> dmwit, alpounet, thx :D i'll check that out
14:35:20 <james-ubc> is there any place i could find more tutorials/examples with gloss?
14:35:25 <hughfdjackson> i'm disproportionately excited about how easy it was to draw a circle in a window with gloss :|
14:35:32 <hughfdjackson> cheers guys and gals
14:36:09 <alpounet> james-ubc, i think there's a gloss-examples package
14:36:14 <nand`> one thing I'm lacking from gloss is the ability to do pixel shader-like stuff; eg. drawing a mandelbrot fractal without rendering it to a texture first
14:36:24 <alpounet> and maybe the gloss package itself embeds an "examples" directory or something, i don't remember
14:37:00 <nand`> eg. I'm lacking a (Double -> Double -> Color) primitive
14:37:18 <nand`> but oh well
14:38:00 <nand`> a library for exploring fractals (possibly with variable precision) would be pretty neat
14:39:25 <james-ubc> alpounet: aight! thanks :D
14:39:46 <james-ubc> btw
14:39:49 <geekosaur> there are a couple of mandelbrot explorers on hackage, I think
14:40:12 <nand`> http://hackage.haskell.org/package/hfractal <- sounds related
14:40:41 <james-ubc> ehh nvm :D
14:42:51 <`Jake`> is there any difference between hayoo and hoogle?
14:42:58 <hpc> hoogle has better results
14:43:05 <hpc> but doesn't index as often
14:43:08 <hpc> or ever, i think
14:43:24 <hpc> oh, it does
14:43:32 <illissius> doesn't have nearly as big coverage in my experience
14:43:34 <hpc> when in doubt, hoogle
14:43:58 <hpc> hoogle has a command-line tool, hayoo has JSON
14:44:04 <illissius> hayoo seems to have all of hackage while hoogle just has... I'm not really sure
14:44:06 <rwbarton> then if still in doubt, hayoo
14:44:11 <hpc> hayoo's json kinda sucks though; querying for 'list' gives back 5MB
14:44:32 <hpc> illissius: hoogle lacks foreign stuff, is the only pattern i can think of
14:44:33 <nand`> meh, the precision of hfractal is very limited and its interface is very odd
14:44:48 <hpc> it's the only reason i can think of for things like gtk to all be missing
14:48:04 <illissius> hpc: hoogling for Abelian returns no results, while hayoo returns quite a few
14:48:17 <illissius> is the most recent example I encountered
14:48:23 <illissius> but it happens regularly
14:48:24 <hpc> hmm
14:48:34 <hpc> yeah, that needs to be figured out
14:48:47 <rwbarton> i always assumed what hoogle decided to index was without rhyme or reason
14:49:07 <dmwit> hpc: Hoogle has gtk.
14:49:14 <dmwit> hpc: try e.g. "initGUI +gtk"
14:49:18 <`Jake`> well, thanks
14:49:29 <hpc> dmwit: that's silly
14:49:42 <illissius> oh, it has the algebra package too
14:49:58 <illissius> didn't know you had to explicitly specify extra packages like that
14:50:01 <illissius> it is silly!
14:50:15 <dmwit> File a feature request. =)
14:50:30 <Clint> the feature of being less aggravating
14:53:37 <nand`> illissius: from the link you've sent me, I figured out one method of making ‘extend’ somewhat intuitive: a beefed up version of ‘fmap’ where the function being mapped observes the entire structure being mapped over, this structure presumably being changed for each application
14:54:18 <dmwit> mmm
14:54:27 <dmwit> I think the structure is unchanged for each application.
14:54:53 <illissius> extend :: w a -> (w a -> b) -> w b right?
14:55:03 <nand`> illissius: flipped arguments
14:55:05 <nand`> but yeah
14:55:27 <nand`> (at least in edwardk's implementation)
14:55:51 <dmwit> Well, bind arguably should have its arguments flipped compared to the current standard library, too. =)
14:56:00 <dmwit> (a -> m b) -> (m a -> m b) makes a lot more sense
14:56:08 <nand`> yeah
14:56:26 <illissius> hm yeah, extend is another kind of function application ish, like <$> and <*> and =<<
14:56:30 <nand`> but I'm not sure how that would prettify or uglify code using >>=
14:56:42 <nand`> (then again, it doesn't really matter)
14:56:46 <illissius> I also prefer =<< to >>= :)
14:56:50 <dmwit> I think (>>=) is in the order it's in because lambdas extend forever in the parser.
14:57:12 <nand`> Monad should have bind :: (a -> m b) -> m a -> m b; and then (>>=) = flip bind
14:57:18 <nand`> like edwardk's comonads package does it
14:57:25 <dmwit> yes
14:57:51 <illissius> Monad should also have join and no fail and an Applicative superclass and so on
14:58:23 <dmwit> yes =)
14:59:10 <nand`> and Monoid should have a Semigroup superclass etc.
14:59:45 <nand`> hmm
15:00:59 <luca> there is no general way of taking the n'th item from an m-tuple right?
15:01:06 <illissius> luca: right
15:01:47 <nand`> I wonder if it would make sense to define a class Identity i where id :: i; this can then be reused for other stuff that has an identity eg. Monoid or MonadPlus; maybe even something like Category :). instance Identity (a -> a) where id x = x
15:02:32 <strager> Wouldn't that be like Default?
15:02:34 <dmwit> luca: The "tuple" package works if you drop the "general".
15:02:37 <illissius> nand`: Data.Default in I can't remember which package (probs data-default), but I'm not sure if it makes sense to tie it in with the others
15:02:47 <dmwit> luca: And the "HList" package works if you change your representation of m-tuples.
15:03:08 <nand`> yeah, I was thinking of Identity as separate for Default so you don't get possible overlapping instances
15:03:12 <nand`> from*
15:04:00 <illissius> I wonder if anyone's done research into what it would take / look like to integrate variadic types (and presumably functions) into a Haskell-like language
15:04:20 <JamesRustle> like printf?
15:04:21 <dmwit> Specifically: "tuple" works for m-tuples up to a fixed upper-bound for m, and HList works if your tuples are encoded like (a, (b, (c, (d, ()))))
15:04:30 <illissius> it's a bit embarrassing that C++ can handle its tuples of whatever size in a generic way but we can't :)
15:05:27 <dmwit> What are tuples in C++?
15:05:32 <dmwit> You mean varargs, or something else?
15:05:44 <JamesRustle> probably variadic templates
15:05:46 <illissius> JamesRustle: sorta yeah. but in C++ (with a bit of legwork) you can define template<typename... Ts> struct Tuple { ... }; (and in fact I think it's in the standard library)
15:05:54 <luca> no, c++ has std::tuple with variadic template args
15:06:07 <luca> essentially replace () in haskell with std::tuple<>
15:06:16 <dmwit> ...and we have HList.
15:06:18 <illissius> with even more legwork you can also implement variadic discriminated unions
15:06:18 <dmwit> I don't get it.
15:06:47 <JamesRustle> since templates are essentially preprocessing, we could do that with TH
15:06:55 <illissius> dmwit: No. The difference is it's not just a chained binary thing but truly variadic.
15:07:25 <dmwit> Okay, I'll bite. What does "truly variadic" mean?
15:07:52 <luca> you can give as many (differently typed) template arguments as you like
15:08:05 <luca> and it'll generate static code
15:08:18 <illissius> dmwit: yeah, I have trouble putting thoughts into words. but it's "flat" not "nested"
15:08:59 <dmwit> HList allows as many differently typed type arguments as you like. What is "static code"?
15:09:18 <luca> as in staticly typed
15:09:26 <dmwit> HList is statically typed.
15:09:46 <luca> compared to C varargs which is just a list of void pointers :P
15:09:56 <strager> illissius: Is a Haskell list flat or nested
15:10:07 <illissius> strager: if you mean [a], nested
15:10:19 <strager> And is there anything which makes that inelegant?
15:11:14 <bootcode> practical question: when do you use IO as is and let it eventually throw an exception, versus using something like ErrorT IO?
15:11:45 <bootcode> I mean I know the difference, but when would you take the effort to use the explicit error handling
15:12:23 <strager> I've used ErrorT or similar outside of IO
15:12:26 <illissius> dmwit: anyway, one of the places this shows up is when in various Haskell libraries you sometimes have someFunction1...N defined which have different numbers of parameters but follow the same pattern.
15:13:12 <illissius> (or probably other cases where you have 1...N duplication of things like this)
15:13:14 <dmwit> illissius: I believe that most occurrences of this pattern are an attempt to avoid extensions that have already been well-studied, not an inability to write a general version.
15:13:32 <dmwit> So then the answer to your very first question is "yes, somebody's done research into that".
15:14:11 <illissius> dmwit: HList uses OverlappingInstances and all kinds of not-so-pretty things to get the result it wants, IIRC.
15:14:23 <dmwit> Yes, that's what I just said.
15:15:35 <dmwit> Not OverlappingInstances, I think.
15:15:49 <dmwit> Nothing worse than UndecidableInstances.
15:16:19 <crdueck> how can I do something like this: f n = [[t1,t2,...,tn] | t1 <- someList, t2 <- someList, ... , tn <- someList]
15:16:37 <illissius> HList figures prominently in a recent ML discussion on what to do about the whole TFs/FDs/overlaps situation so I'm pretty sure it does
15:16:45 <sipa> :t transpose
15:16:46 <lambdabot> forall a. [[a]] -> [[a]]
15:16:53 <sipa> crdueck: ^
15:17:18 <dmwit> uh, not transpose
15:17:18 <sipa> > transpose [[1,2,3,4],[10,20,30,40],[111,222,333,444]]
15:17:19 <lambdabot>   [[1,10,111],[2,20,222],[3,30,333],[4,40,444]]
15:17:20 <dmwit> :t sequence
15:17:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:17:32 <sipa> oh, right
15:17:45 <sipa> > sequence [[1,2,3,4],[10,20,30,40],[111,222,333,444]]
15:17:46 <dmwit> > sequence [[1,2],[10,20],[100,200]]
15:17:46 <lambdabot>   [[1,10,111],[1,10,222],[1,10,333],[1,10,444],[1,20,111],[1,20,222],[1,20,33...
15:17:47 <lambdabot>   [[1,10,100],[1,10,200],[1,20,100],[1,20,200],[2,10,100],[2,10,200],[2,20,10...
15:18:31 <dmwit> illissius: The original paper states in its introduction that they manage to avoid overlapping instances.
15:18:40 <dmwit> Dunno whether the current library still does that, though.
15:18:51 * hackagebot seqloc-datafiles 0.2.2 - Read and write BED and GTF format genome annotations  http://hackage.haskell.org/package/seqloc-datafiles-0.2.2 (NicholasIngolia)
15:19:21 <illissius> hm, ok. not really an expert about it
15:19:33 <crdueck> dmwit: that will work, thanks
15:20:10 <luca> is there a nice way of including a pure statement into a do block?
15:20:25 <luca> wait
15:20:25 <luca> duh
15:20:26 <luca> return
15:20:29 <parcs`> nope
15:20:30 <dmwit> luca: let
15:20:31 <parcs`> let :)
15:20:39 <luca> can't use let within the do block though?
15:20:45 <dmwit> Yes, you can.
15:20:54 <nand`> hooray, I came up with my first comonad instance
15:20:55 <dmwit> In fact, it's special-cased not even to need an "in" when it's in a do-block.
15:20:57 <luca> like do { ys <- ...; let x = f ys in .... }
15:21:03 <luca> ahah
15:21:31 <dmwit> > do { x <- [1,2,3]; let { y = x + 1 }; return y }
15:21:32 <lambdabot>   [2,3,4]
15:21:50 <coppro> luca: why do you want to just perform a pure statement?
15:24:27 <luca> to not make the last line be silly long
15:25:07 <parcs`> does repa have a mapWithIndex function anywhere?
15:25:47 <luca> :t maybe
15:25:48 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:26:26 <luca> :t maybe [] id . fst
15:26:27 <lambdabot> forall a b. (Maybe [a], b) -> [a]
15:26:37 <luca> :t (maybe [] id) . fst
15:26:38 <lambdabot> forall a b. (Maybe [a], b) -> [a]
15:26:42 <luca> hm.
15:27:10 <luca> ah right
15:27:27 <luca> :t maybe [] fst
15:27:28 <lambdabot> forall a b. Maybe ([a], b) -> [a]
15:27:30 <luca> much better
15:27:53 <dmwit> maybe x id is better spelled fromMaybe x
15:28:02 <luca> forgot that existed
15:28:11 <luca> though i need maybe x fst
15:28:17 * dmwit nods
15:28:18 <luca> maybe [] fst even
15:28:21 <luca> but yeh
15:30:01 <luca> for fun.
15:30:24 <luca> @pl \ys -> (concatMap (maybe [] fst) ys) ++ [EVars $ map snd ys]
15:30:24 <lambdabot> liftM2 (++) (maybe [] fst =<<) (return . EVars . map snd)
15:30:27 <luca> lmao
15:30:27 <nand`> Data.List.Zipper.Zipper is a comonad, with duplicate = duplicatez, extend = extendz and extract = cursor :)
15:30:39 <luca> <3 @pl
15:31:34 <illissius> @unpl liftM2 (++) (maybe [] fst =<<) (return . EVars . map snd)
15:31:34 <lambdabot> ((\ f -> f >>= (maybe [] fst)) >>= \ b -> (\ i -> return ((EVars) (map snd i))) >>= \ a -> return (b ++ a))
15:31:47 <luca> yay
15:32:05 <luca> @pl ((\ f -> f >>= (maybe [] fst)) >>= \ b -> (\ i -> return ((EVars) (map snd i))) >>= \ a -> return (b ++ a))
15:32:05 <lambdabot> (`fmap` (return . EVars . map snd)) . (++) =<< (maybe [] fst =<<)
15:32:10 <dmwit> :t \yss -> [y | Just (ys@(_:_)) <- yss, y <- ys]
15:32:11 <lambdabot> forall t. [Maybe [t]] -> [t]
15:32:30 <dmwit> :t \yss -> [y | Just (ys, _) <- yss, y <- ys]
15:32:31 <lambdabot> forall t t1. [Maybe ([t1], t)] -> [t1]
15:32:59 <dmwit> oooh
15:33:08 <dmwit> :t \yss -> [y | (Just ys, _) <- yss, y <- ys]
15:33:09 <lambdabot> forall t t1. [(Maybe [t1], t)] -> [t1]
15:33:42 <dmwit> Not actually sure which one you want. The thing you passed ?pl doesn't look well typed.
15:34:23 <dmwit> since "map snd" and "map (maybe ...)" can never apply to the same list, but you are applying them both to the same list.
15:34:44 <pooya72> any one here have experience with scala? how similar is it to haskell?
15:35:29 <nand`> :t \ys -> (concatMap (maybe [] fst) ys) ++ [?evars $ map snd ys]
15:35:30 <lambdabot>     Couldn't match expected type `(a, b)'
15:35:31 <lambdabot>            against inferred type `Maybe ([a1], b1)'
15:35:31 <lambdabot>       Expected type: [(a, b)]
15:36:05 <c_wraith> pooya72: It's not really that similar. The bleeding edges of the type systems have some commonalities, but what the code you write in each looks like is pretty different
15:38:06 <illissius> I haven't looked at very much Scala code but what I did see was very ugly
15:38:20 <illissius> maybe because it was trying to implement Haskell-things in Scala which doesn't go so easily...
15:38:53 <nand`> is copoint = extract?
15:39:17 <illissius> nand`: pretty sure yes
15:39:30 <pooya72> c_wraith: I c, i was thinking that scala would be more influenced by haskell
15:40:02 <c_wraith> pooya72: well, you can use a haskell-like style. it's just that most people don't
15:40:17 <luca> nand` yeh: i just wanted ys' on the rhs of the ++
15:40:27 <illissius> nand`: though now that you mention it I'm not sure why Comonad isn't just (Extend w, Copointed w), so there might be a reason..
15:40:29 <pooya72> c_wraith: most people go imperative?
15:40:43 <fmap> > let ys = unsafeCoerce 1 in map (maybe 3 id) ys ++ map snd ys
15:40:44 <c_wraith> pooya72: not imperative so much as non-pure.
15:40:44 <lambdabot>   Not in scope: `unsafeCoerce'
15:40:46 <nand`> illissius: that's what I'm interested about as well
15:40:48 <fmap> :(
15:41:18 <illissius> nand`: best to wait for edwardk/ekmett to turn up
15:41:21 <c_wraith> pooya72: since effects aren't typed in scala, it's easy for them to creep in
15:42:11 <taylorgb> Given a real choice between scala and Haskell, do people tend to choose scala?
15:42:44 <illissius> taylorgb: Not sure about 'tend', but yes, some choose Scala.
15:42:51 <c_wraith> I have no clue if there are broad tendencies either way there
15:42:57 <illissius> but I'd suspect it's often because of the JVM
15:42:59 <pooya72> c_wraith: yeah, I saw a talk the creator have haskell gave, and he thought it would be impractical to completely separate side-effects. He complained that monads bring change the programming syntax and bring us back to pascal
15:43:38 <pooya72> taylorgb: yeah JVM and it's easier for java programmers cause it supports imperative programming.
15:43:44 <taylorgb> Sure
15:44:08 <luca> :t zipWith
15:44:09 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:44:10 <c_wraith> ask someone like edwardk, who uses both quite a bit, what he thinks.
15:45:12 <nand`> https://github.com/ekmett/dysfunctional/tree/0fe8300700978356619e9aff30b4f89922a0fc45/src/main/scala/dysfunctional
15:45:14 <nand`> oh look, monads in Scala
15:45:38 <nand`> (efficient ones)
15:46:31 <luca> FINALLY
15:46:39 <luca> this function is a beasdt
15:47:01 <nand`> hmm
15:47:02 <hpaste> luca pasted “beast” at http://hpaste.org/69570
15:47:23 <nand`> > [x+y | x <- [1,2,3] | y <- [4,5,6]]
15:47:24 <lambdabot>   [5,7,9]
15:47:31 <nand`> > [x+y | x <- [1,2,3] | y <- [4,5,6,7]]
15:47:32 <lambdabot>   [5,7,9]
15:48:03 <luca> nice hint from hpaste
15:48:11 <luca> maybe Nothing (Just . snd) == fmap snd
15:48:38 <nand`> nice how hlint picks up stuff like that
15:49:36 <luca> would be nice if ghc did it too :P
15:49:45 <luca> compile and get a nice list of suggested improvements 8d
15:49:59 <heatsink> The research on parallel container operations in Scala seems to parallel Haskell's parallel map/filter/reduce operations
15:50:23 <heatsink> Let's see if I can find a third meaning of "parallel" and use it in the same sentence
15:50:25 <nand`> luca: I asked about that earlier. For your reference, the “hlint” command line utility does it - it would be interesting to get its errors as GHC warnings
15:50:36 <nand`> to me, it's such an integral part of my build process; I run it for every change
15:50:46 <nand`> lots of quality of life improvements are discovered that way
15:51:29 <luca> sudo apt-get install hlint :P
15:51:46 <nand`> emerge hlint :)
15:52:21 <luca> ooooo lots of suggestions
15:52:26 <luca> fucjk
15:52:28 <luca> lots of suggestions.
15:52:36 <luca> like 8 A4 pages
15:52:41 <Lemon> guys
15:52:55 <nand`> a while ago somebody gave a tip on how to use stylish-haskell from within vim to directly modify the working buffer; anybody know how it's done?
15:52:56 <Lemon> how do I infer types for mutually recursive definitions?
15:53:08 <Lemon> and yes I've read "Typing Haskell in Haskell"
15:53:41 <Lemon> it doesn't help
15:53:57 <nand`> I would guess the same way you type “undefined”, then see if you can get those two to match
15:56:21 <illissius> hooray for GPU hangs.
15:56:32 <geekosaur> nand`, https://github.com/jaspervdj/stylish-haskell/blob/master/README.markdown shows a simple keybinding
15:57:00 <nand`> geekosaur: oh right; that's actually where I got it from - not in here
15:57:43 <nand`> that said; why doesn't this work? stylish-haskell Test.hs 2>&1 | diff Test.hs -    <- I'm trying to see the differences it would do, but the diff command behaves as if stdin is empty
15:58:03 <nand`> I checked with stylish-haskell Test.hs 2>&1 | cat  and I see the file
15:58:34 <nand`> actually, drop the 2>&1 (doesn't make a difference either way)
15:58:45 <dzhus> How can this work: http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/Data-Vector.html#v:modify?
15:59:45 <illissius> so I was going to say: Oh look, the punctuation monster upset its stomach. https://github.com/scalaz/scalaz/pull/94#issuecomment-5926410
16:00:43 <luca> @pl \nl -> do { (f,_) <- get; unless f nl }
16:00:43 <lambdabot> (line 1, column 11):
16:00:43 <lambdabot> unexpected "{"
16:00:43 <lambdabot> expecting variable, "(", operator or end of input
16:00:49 <luca> meh
16:02:00 <luca> is do { (f,_) <- get; unless f nl } the same as ((fmap fst) get) >>= (flip unless nl)
16:02:02 <luca> seems like it is
16:02:33 <c_wraith> nearly
16:02:38 <c_wraith> in this case, they're the same
16:02:45 <c_wraith> well
16:02:47 <luca> ?
16:02:59 <Cale> fmap could become liftM
16:03:16 <c_wraith> They're the same modulo bottoms
16:03:27 <Cale> and that would remove the Functor instance
16:03:32 <Cale> requirement*
16:03:42 <luca> :t (fmap fst) get
16:03:43 <lambdabot> forall a b (f :: * -> *). (Functor f, MonadState (a, b) f) => f a
16:03:46 <c_wraith> and the way they're both being used, the bottoms probably aren't important
16:03:46 <luca> :t (liftM fst) get
16:03:47 <lambdabot> forall a b (m :: * -> *). (MonadState (a, b) m) => m a
16:03:54 <luca> nice
16:04:16 <pooya72> Lemon: Typing haskell in haskell looks cool. You went through it all?
16:04:17 <c_wraith> luca: they would be identical, except for the pattern match on the left of the <-
16:04:18 <Cale> But you're pretty much guaranteed that instances of Monad are instances of Functor. It's sort of a bug for them not to be.
16:04:38 <twanvl_> or without the fmap:  get >>= flip unless nl . fst
16:04:46 <c_wraith> luca: pattern matching on the left of a <- brings in some semi-arcane rules
16:05:41 <luca> how about shorterning modify (\(_,n) -> (True,n))
16:06:30 <luca> @pl \(_,n) -> (True,n)
16:06:31 <lambdabot> (,) True . snd
16:06:34 <luca> hah
16:06:45 <luca> i likw rhR
16:06:47 <nand`> :t first (const True)
16:06:48 <lambdabot> forall b d. (b, d) -> (Bool, d)
16:06:48 <twanvl_> the point-free version is  modify (first (const True)), but I don't think that it is an improvement
16:06:49 <luca> i like that*
16:07:28 <nand`> lambdabot's versions is equal to (True,) . snd FWIW
16:07:33 <Peaker> twanvl_, in SEC form it is very readable
16:07:34 <nand`> -s
16:07:42 <luca> :t (True,) . snd
16:07:43 <lambdabot> Illegal tuple section: use -XTupleSections
16:07:51 <nand`> oh, yeah, you need -XTupleSections
16:08:00 <luca> so far i havn't need any extensions
16:08:10 <nand`> Peaker: SEC?
16:08:12 <luca> think maybe nice to keep it that way if possible :P
16:08:20 <Peaker> @where SEC
16:08:20 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
16:09:02 * hackagebot cereal 0.3.5.2 - A binary serialization library  http://hackage.haskell.org/package/cereal-0.3.5.2 (TrevorElliott)
16:09:16 <luca> :t flip (,) snd . (+1)
16:09:17 <lambdabot> forall a b a1. (Num a1) => a1 -> (a1, (a, b) -> b)
16:09:35 <luca> :t flip (,) fst . (+1)
16:09:36 <lambdabot> forall a b a1. (Num a1) => a1 -> (a1, (a, b) -> a)
16:10:30 <luca> @pl \x -> (fst x, (+1) snd x)
16:10:31 <lambdabot> liftM2 (,) fst (snd + 1)
16:11:28 <luca> @pl \x -> (fst x, (snd x) + 1)
16:11:28 <lambdabot> liftM2 (,) fst ((1 +) . snd)
16:13:02 <geekosaur> automated obfuscation
16:13:44 <JoeyA> heh
16:13:58 <luca> i don't think liftM2 (,) fst ((+1) . snd) is obfuscated really
16:14:03 <Peaker> luca, \(x, y) -> (x, y + 1)
16:14:08 <luca> yeh i know :D
16:14:13 <Peaker> or   second (+1)
16:14:22 <nand`> seconding (heh) second (+1)
16:14:29 <luca> :t second (+1)
16:14:30 <lambdabot> forall b d. (Num b) => (d, b) -> (d, b)
16:14:33 <luca> haha
16:14:37 <luca> didn't know that existed
16:14:44 <nand`> wait what
16:14:46 <nand`> :t second
16:14:47 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
16:14:52 <nand`> oh
16:14:57 <nand`> the (+1) forces it to be (->)
16:15:28 <JoeyA> :t \f -> second (f . id)
16:15:29 <lambdabot> forall a c d. (a -> c) -> (d, a) -> (d, c)
16:15:36 <JoeyA> Specialize'd
16:15:39 <luca> where the heck is second defined?
16:15:47 <JoeyA> @hoogle second
16:15:47 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
16:15:48 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec class SecondaryColor a
16:15:48 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec secondaryColor :: SecondaryColor a => a -> IO ()
16:15:51 <luca> ahah
16:16:03 <nand`> JoeyA: I don't get it
16:16:08 <nand`> oh
16:16:10 <nand`> nvm
16:16:44 <nand`> :t second `asAppliedTo` id
16:16:45 <lambdabot> forall c d. (c -> c) -> (d, c) -> (d, c)
16:16:49 <luca> i definately prefer modify $ second (+1) to modify (\(n,x) -> (n,x+1))
16:16:50 <nand`> :)
16:17:00 <JoeyA> :t asAppliedTo
16:17:01 <lambdabot> forall t b. (t -> b) -> t -> t -> b
16:17:10 <JoeyA> @hoogle asAppliedTo
16:17:11 <lambdabot> No results found
16:17:16 <nand`> JoeyA: that one's in lambdabot
16:17:20 <luca> :pl \x -> a
16:17:21 <JoeyA> @src asAppliedTo
16:17:21 <lambdabot> Source not found. I am sorry.
16:17:27 <luca> @pl \x -> a
16:17:27 <lambdabot> const a
16:17:33 <luca> ahah so that's what const is
16:17:40 <nand`> @src asTypeOf
16:17:40 <lambdabot> asTypeOf = const
16:19:08 <luca> :t first (const True)
16:19:09 <lambdabot> forall b d. (b, d) -> (Bool, d)
16:19:42 <parcs`> :t \f -> second (f Control.Category.. Control.Category.id)
16:19:43 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
16:20:41 <nand`> :t \f -> second (f Control.Category.. (\x -> x))
16:20:42 <lambdabot> forall c b d. (b -> c) -> (d, b) -> (d, c)
16:21:18 <luca> :t concatMap (maybe [] fst) ys
16:21:19 <lambdabot> Not in scope: `ys'
16:21:35 <luca> :t \ys -> concatMap (maybe [] fst) ys
16:21:36 <lambdabot> forall a b. [Maybe ([a], b)] -> [a]
16:21:46 <luca> :t \ys -> [l | (_,Just l) <- ys]
16:21:48 <lambdabot> forall t t1. [(t, Maybe t1)] -> [t1]
16:22:27 <nand`> if you're throwing around types like that I'd seriously start using type aliases to make things more clear
16:22:46 <nand`> [Maybe ([a], b)]  <- I need a few double takes on that one
16:22:49 <luca> no i'm not just checking if they ewre same thing
16:22:53 <nand`> oh
16:22:59 <navaati> shouldn't Monoid be in Control rather than in Data ?
16:23:02 <luca> :t \ys -> [l | Just (_,l) <- ys ]
16:23:03 <lambdabot> forall t t1. [Maybe (t, t1)] -> [t1]
16:23:14 <luca> otherwise in (_,l) and then the same
16:23:17 <luca> other way*
16:23:55 <luca> what's nicer: [x | Just (x,_) <- ys'] or concatMap (maybe [] fst) ys'
16:24:04 <nand`> navaati: truth be told I don't understand the distinction between ‘Data’ and ‘Control’; or rather why for example monad is in Control.Monad but functor is in Data.Functor
16:24:23 <luca> well concat [x | Just (x,_) <- ys' ] anyways
16:25:07 <nand`> I personally think the concatMap version is nicer
16:25:11 <luca> yeh
16:25:50 <luca> zipWith (\(n,t,_) v -> (n,t,v)) vs (map (fmap snd) ys') or: [(n,t,v) | ((n,t,_),(_,v)) <- zip vs ys']
16:25:51 <nand`> not only does it avoid pattern matching / throwing around ‘fail’ like that, but it also lends itself to eta reduction
16:25:59 <nand`> eg. f = concatMap (maybe [] fst)
16:26:37 <navaati> Well, it seems logical that Data is for datatypes, like Map or Maybe or Ratio, whereas Control is for "programming structures" like monads, monoid and indeed functors
16:26:57 <nand`> navaati: that's what I'd think as well
16:27:23 <nand`> but then again the line between “data types” and “programming structures” is a bit blurred in Haskell
16:28:54 <nand`> with [] for example expressing recursive control flows
16:29:53 <nand`> (or non-determinism with concatMap)
16:30:29 * nand` off
16:37:54 <monochrom> Data.Function vs Control.Function can get people into heated debates on nothing :)
16:41:31 <luca> :t maybe (return Nothing) (liftM Just . )
16:41:32 <lambdabot> forall (m :: * -> *) a1. (Monad m, Functor m) => Maybe (m (Maybe a1)) -> m (Maybe (Maybe a1))
16:41:44 <luca> :t \f -> maybe (return Nothing) (liftM Just . f)
16:41:45 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m a) -> Maybe a1 -> m (Maybe a)
16:44:27 <parcs`> which of the two is preferred for reading a list of TVars in a concurrent application: mapM (atomically . readTVar) or atomatically . mapM readTVar ?
16:45:10 <parcs`> or perhaps it depends on the number of TVars and the average number of concurrent transactions
16:46:27 <parcs`> the first creates a lot of transactions which add overhead (?) but the second may increase contention because only one thread can read the list at a time
16:47:32 <hpc> parcs`: if you want to be paranoid, do it in chunks
16:47:47 <hpc> and then you have the chunk size as a slider you can use to control the two concerns
16:48:33 <parcs`> good idea. i should test this
16:50:38 <monochrom> correctness first. are the TVars related such that you absolutely want a consistent snapshot of them as one group?
16:51:16 <monochrom> remember, if it doesn't have to be correct, I always know a way 100x faster
16:51:59 <parcs`> monochrom: no, no need for consistent ss\
16:52:29 <monochrom> alright, then benchmarking various granularities makes sense
16:53:22 <dmwit> luca: traverse
16:54:00 <dmwit> :t Data.Traversable.traverse
16:54:01 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:58:07 <luca> dmwit?
16:58:43 <dmwit> luca: instead of \f -> maybe (return Nothing) (liftM Just . f), use traverse
16:59:11 <luca> ah
17:00:13 <luca> thanks
17:10:30 <parcs`> http://paste.debian.net/173060 if anyone wants to play with it
17:13:27 <parcs`> looks like it doesn't matter unless you have a lot of TVars and/or a lot of threads
17:13:39 <parcs`> the chunk size, that is
17:14:44 <parcs`> if you have a lot of tvars or a lot of threads then smaller chunk size is a winner
17:16:33 * shapr grumbles at Aeson
17:20:37 <parcs`> http://paste.debian.net/173062/ better version
17:22:25 <parcs`> crap. forget to replace the expression inside the forkIO with chunks :P
17:24:22 * shapr grumbles more at Aeson
17:26:40 <navaati> is there a LANGUAGE extension that simplifies the cumbersome "\e -> case e of …" ?
17:27:10 <byorgey> no
17:27:54 <byorgey> I've seen such a thing proposed.
17:28:13 <dmwit> Lambdas should introduce blocks!
17:28:23 <heatsink> A monadic such a thing would be useful.
17:28:26 <dmwit> And never use (>>=)!
17:28:41 <heatsink> What is a block?
17:29:05 <dmwit> heatsink: That's the Haskell term for places where you can use indentation to replace {;}
17:29:10 <int80_h> same as local scope right?
17:29:29 <dmwit> not really related to scoping...
17:29:39 <int80_h> ah okay
17:29:41 <dmwit> Indeed, different blocks have different scoping rules in Haskell.
17:30:08 * int80_h waves
17:30:53 <heatsink> > \x -> { x > 3; x < 3}
17:30:54 <lambdabot>   <no location info>: parse error on input `{'
17:31:59 <dmwit> heatsink: I'm proposing that instead of "\x -> case x of { 3 -> ...; 5 -> ...; n -> ... }", you should be able to write "\{3 -> ...; 5 -> ...; n -> ...}".
17:32:10 <dmwit> This interacts in unfortunate ways with (>>=)-style monadic code, though.
17:32:33 <heatsink> Oh, I see
17:32:35 <hpc> dmwit: there's a similar proposal that translates it to "case of {...}"
17:32:48 <c_wraith> case of seems simpler
17:32:48 <dmwit> hpc: Yeah, but that syntax obviously sucks. =)
17:32:54 <hpc> heh
17:33:12 <c_wraith> eh. It's just broadening section syntax
17:33:20 <dmwit> It's too much typing.
17:33:30 <navaati> dmwit: your proposal seems cool, but i don't see how it is related to (>>=) ?
17:33:33 <c_wraith> still less than the current!
17:33:50 <dmwit> Less than the current, but more than the sane proposal. ;-)
17:34:12 <dmwit> navaati: I don't recall the details, but let's see if we can work them out...
17:34:14 <c_wraith> I don't know if I'd call something that introduces syntactic ambiguity "sane"
17:34:18 <heatsink> do { y <- foo >>= \x -> bar x; baz y } no longer works right, I think
17:34:51 <parcs`> what about case _ of {..} ?
17:34:58 <parcs`> doesn't scala do that
17:35:10 <parcs`> (use _s in expressions to introduce lambdas)
17:35:21 <heatsink> Scala uses _ to introduce lambda in some contexts, like _ + 1
17:35:32 <parcs`> that's pretty cool  ithink
17:35:33 <heatsink> Doesn't Agda use _ to mean "any value that typechecks"?
17:35:37 <navaati> you mean that one doesn't know anymore if the ";" between bar x and baz y is to separate statements of the do block or of the lambda block ?
17:35:42 <heatsink> non-bottom value :)
17:35:52 <parcs`> yeah, in agda it means "you can infer this value"
17:36:00 <navaati> (there is no bottom value in agda, btw)
17:36:02 <dmwit> There's never ambiguity in explicit {;} mode. So trying to give the ambiguous statement over IRC isn't going to work.
17:36:10 <dmwit> We'll need to use something that has multiline -- say, hpaste.
17:36:19 <dmwit> But I'm having trouble remembering what the ambiguous thing is, now.
17:36:49 <navaati> anyway, a haskell with all agda's syntax greatness would be, well, great
17:37:14 <navaati> also, agda's way of doing typeclasses is the greatest thing in the world
17:38:17 <dmwit> c_wraith: Do you remember where the ambiguity arises?
17:38:35 <c_wraith> not offhand
17:38:46 <parcs`> heatsink: do you know whether it's possible to have _ + _ in scala?
17:41:48 <heatsink> parcs`, I don't know
17:46:51 <pdxleif> What's with the import Stuff ( Foo (..) ) things?
17:47:08 <pdxleif> I only know about import Stuff ( Foo, etc )
17:47:17 <heatsink> It also imports Foo's constructors
17:47:37 <heatsink> import Prelude(Maybe(Just, Nothing))
17:47:50 <pdxleif> Interesting...
17:48:36 <pdxleif> Could you do the same thing with import Prelude.Maybe(Just, Nothing)?
17:51:38 <heatsink> No, that refers to a module named Prelude.Maybe
17:51:39 <mapreduce> I think he just showed that.
17:51:43 <mapreduce> ah, oops
18:08:23 <pdxleif> And in the case import Stuff ( Foo (..) ) where Foo is a typeclass, that imports all the instances of Foo?
18:14:32 <byorgey> pdxleif: all the methods of foo
18:14:43 <byorgey> instances are always imported whether you like it or not.
18:43:04 <shapr> I'm trying to produce an Object with Aeson
18:43:08 <shapr> but I think I'm only getting an array...
18:44:16 * illissius directs two minutes hate at #5591 S:|
18:52:30 <parcs`> illissius: looks like it's fixed in ghc 7.5
18:53:23 <parcs`> at least inj1 typechecks
19:38:31 <boccato> I updated my haskell platform and when I do cabal install on yesod it says I don't have a ~/Library/Haskell/bin directory.
19:38:35 <boccato> Any clues what I did wrong?
19:49:08 <illissius> parcs`: oh, great. thanks! (still, annoying if one still wants to support 7.2-7.4)
19:59:56 <crdueck> @src sequence
19:59:56 <lambdabot> sequence []     = return []
19:59:57 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:59:57 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
20:02:36 <crdueck> does sequence produce a list lazily? i'm mapping a function over a very large list generated by sequence and its taking up a lot of memory and i'm sure it isnt the function
20:16:30 <hpaste> megajosh2 pasted “Constantly get ConnectionNotEstablished error” at http://hpaste.org/69577
20:17:28 <megajosh2> Does anybody know why I wouldn't be able to send anything?
20:18:10 <megajosh2> Once it gets to sendData I get that exception and I can't figure out why
21:19:58 <mietek> hscurses doesn't seem to build on 7.4
21:20:07 <mietek> Any replacement libraries?
21:21:39 <parcs`> ncurses
21:21:46 <parcs`> vty/vty-ui
21:22:38 <mietek> vty seems abandoned as well... but thanks, I haven't noticed ncurses
21:34:59 <ifnspifn> So, I'm trying to turn an NxN matrix of letters (in the form of [String]) into a graph whose edges describe the standard 2D "neighbor" relationship. i.e., in [[a,b,c],[d,e,f],[g,h,i]], there'd neighbor edges (a,b), (a,d), and (a,e). Only problem is, I've no idea where to start, apart from giving each and  every element an index and doing some rather imperative-styled iteration
21:35:12 <ifnspifn> any suggestions?
21:35:16 <gienah> mietek: there's patch to make hscurses build with ghc 7.4: https://github.com/gentoo-haskell/gentoo-haskell/blob/f1950b1fdc5cc0302f86ce35a8f53d56ba93d963/dev-haskell/hscurses/files/hscurses-1.4.1.0-ghc-7.4.patch
21:35:25 <otters> ifnspifn: you'd really have to iterate through the indexes
21:36:41 <mietek> gienah: thanks
21:36:53 <ifnspifn> otters: blah! I guess I was hoping there'd be some nice functional approach (I'm still quite new to Haskell/functional languages)
21:37:08 <shachaf> ifnspifn: There would indeed be.
21:37:15 <otters> would there be?
21:37:18 <otters> hm
21:37:18 <shachaf> At least, there are approaches that don't involve thinking about indices.
21:37:44 <ifnspifn> sounds splendid, shachaf. What do you  have in mind?
21:39:32 <shachaf> @let f1 l = zip l (tail (cycle l))
21:39:34 <lambdabot>  Defined.
21:41:56 <shachaf> > let foo = ["abc","def","ghi"] in (f1 foo >>= uncurry zip) ++ (foo >>= f1)
21:41:57 <lambdabot>   [('a','d'),('b','e'),('c','f'),('d','g'),('e','h'),('f','i'),('g','a'),('h'...
21:42:01 <shachaf> I don't know something involving this basic idea?
21:42:26 <shachaf> Assuming you want it to wrap.
21:42:33 <shachaf> If not, then something else.
21:42:56 <ifnspifn> alas, wrapping isn't the goal, but I'll try to run with this as a start
21:43:06 <shachaf> Oh, and you want diagonals.
21:43:10 <ifnspifn> yessir
21:43:17 <shachaf> Anyway, something involving zipping.
21:43:45 <shachaf> @let f2 l = zip l (tail l)
21:43:46 <lambdabot>  Defined.
21:43:54 <shachaf> > let foo = ["abc","def","ghi"] in (f2 foo >>= uncurry zip) ++ (foo >>= f2)
21:43:56 <lambdabot>   [('a','d'),('b','e'),('c','f'),('d','g'),('e','h'),('f','i'),('a','b'),('b'...
21:45:34 <shachaf> Diagonals might be a bit trickier but just do a cascading tail thing or something.
21:45:39 <ifnspifn> I'm awfully green when it comes to monadic thinking.. what is the role of bind in that?
21:45:46 <shachaf> Oh, it's just concatMap
21:45:56 <shachaf> list >>= f == concat (map f list)
21:46:39 <ifnspifn> nuts. Does >>= always play that role, even in monads?
21:46:54 <shachaf> (>>=) is a pretty generic function.
21:47:04 <shachaf> When its first argument is a list, it does that.
21:47:12 <ifnspifn> Looks like I've got to read up on it some more
21:47:33 <shachaf> When its first argument is something of another type, it does something similar, but seeing how it's "similar" can take a little while. :-)
21:47:43 <shachaf> Watch out, there's a lot of misinformation out there about this!
21:47:46 <shachaf> Start with the FAQ:
21:47:48 <shachaf> @where faq
21:47:48 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
21:48:16 <ifnspifn> Will do, many thanks!
21:48:24 <shachaf> > takeWhile (not.null) . iterate (tail . map tail) $ ["abc","def","ghi"]
21:48:26 <lambdabot>   [["abc","def","ghi"],["ef","hi"],["i"]]
21:48:37 <shachaf> Maybe something like that.
21:49:32 <shachaf> > zipWith (flip const) <*> iterate (tail . map tail) $ ["abc","def","ghi"] -- Ignore this line. :-)
21:49:33 <lambdabot>   [["abc","def","ghi"],["ef","hi"],["i"]]
21:50:03 <shachaf> Anyway, those are a few building blocks you can probably use to figure out how to make the exact function you want.
21:50:39 <ifnspifn> absolutely. just knowing the tools that lend toward 'functional' strategies is very helpful
21:52:01 <shachaf> If you're using indices with or computing the length of a list, you're probably doing something wrong.
21:52:16 <shachaf> (That something wrong might be: Using a list, where another data structure would do better.)
21:52:33 <shachaf> (But in this case you should be able to manage without any indices.)
21:52:42 <shachaf> (And it'll even be nicer.)
22:04:34 <ifnspifn> after typing "import Data.List" into my REPL, why can't I use splitEvery? (http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html#v:splitEvery)
22:04:55 <otters> because you have to import Data.List.Split
22:05:15 <ifnspifn>  <no location info>:      Could not find module `Data.List.Split':        Use -v to see a list of the files searched for.
22:05:20 <otters> then install it
22:05:26 <shachaf> Data.List.Split isn't a standard module.
22:19:18 <dmwit> ifnspifn: Since nobody else is being helpful apparently... you need to install the "split" package from Hackage. The easiest way is to just "cabal install split" from a command line.
22:20:37 <ifnspifn> dmwit: Thanks, though luckily google got me the same information :)
22:21:25 <dmwit> Okay, great. =)
22:32:38 <mietek> Ooh, vty-ui.
22:34:53 <digcon9> (with-mongo conn
22:34:54 <digcon9>     (fetch :matches :where {:_id "4fcdd07cdf6ab16707a3222e"}))
23:13:00 <zzo38> What are criteria for (f x -> f y) to make a Arrow?
23:13:55 <mietek> What is the not-old way of formatting time?
23:14:10 <dmwit> ?hoogle formatTime
23:14:29 <dmwit> Huh, \bot died.
23:14:33 <dmwit> Data.Time.Format.formatTime
23:14:44 <Pseudonym> zzo38: Good question. Arrows correspond to Freyd categories.
23:14:54 <Pseudonym> So first and foremost, they have to obey the category laws.
23:15:01 <mietek> dmwit: of course. Thanks/
23:15:02 <mietek> .
23:15:04 <Cale> dmwit: I'm trying to ssh in at the moment and not getting a response
23:15:18 <Cale> oh, there we go, just really slow
23:15:48 <zzo38> Pseudonym: My guess was that f has to be idempotent but I am unsure if that is quite correct.
23:17:10 <Pseudonym> I don't think so.
23:17:29 <Pseudonym> [a] -> [b] is an Arrow. So is [[a]] -> [[b]].
23:17:50 <Pseudonym> Oh, of course.
23:18:07 <Pseudonym> Oh, hang on....
23:18:14 <applicative> zzo38: well we need to be able to go from a->b  to f a -> f b; thus its a functor. we have obvious id and . for a category, because of the ->  . then all that pair stuff...
23:18:17 <Pseudonym> No, I think f a -> f b is an Arrow for any Functor.
23:18:34 <Pseudonym> Yeah.
23:19:05 <zzo38> I know there it is always a category, and if f is Functor then there is always the functor from (->) to this category, but can you show me how it is always Arrow by defining first or (***)?
23:19:08 <yitz> Cale: ssllowww...
23:19:37 <Cale> The answer also probably depends on whether you consider (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k) to be an Arrow law or not (the paper says no in order for Arrow to generalise Monad, but I think most really reasonably-behaved instances of Arrow satisfy this)
23:20:01 <zzo38> applicative: Yes it is the pair stuff which I was concerned about
23:20:25 <dmwit> :t first
23:20:26 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
23:20:28 <Pseudonym> :t (***)
23:20:29 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
23:20:51 <Pseudonym> @free mult :: A b c -> A b' c' -> A (b,b') (c,c')
23:20:52 <lambdabot> Plugin `free' failed with: Plugin/Free/FreeTheorem.hs:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
23:20:56 <Pseudonym> Ah, damn.
23:21:00 <Pseudonym> Let me try my own build.
23:21:01 <zzo38> Cale: I don't know why it makes any sense for Arrow to generalise Monad; it is a category. The Kleisli category of monads is a Arrow, though.
23:21:44 <Cale> zzo38: It's an instance presently, but I'd actually like to deny most Kleislis from being instances of Arrow
23:21:45 <yitz> zzo38: the point is that without that law, arrows can have effects whose order matters
23:21:56 <zzo38> Pseudonym: The recent documentation for Arrow lists a bunch of laws although they seem very long and complicated
23:22:19 <Cale> e.g. Kleisli IO should not be an Arrow, even though it is an instance
23:22:19 <dmwit> Isn't there a Zippable class somewhere...?
23:22:38 <zzo38> Cale: O, well. It is still a category and there is a functor from (->). Even, if it is not properly Arrow by the other laws
23:22:47 <Pseudonym> At least one of the Arrow axioms is actually a free theorem in disguise.
23:22:57 <Cale> Well, it's an Arrow by the original Hughes laws for Arrow
23:23:05 <Pseudonym> Phil Wadler also rpoved that one of them is a theorem.
23:23:11 <Pseudonym> Two down, lots to go.
23:23:39 <zzo38> There is something that says you can make Applicative from any Arrow. What laws would apply if this were what you are doing?
23:23:41 <Cale> But I think the one I mentioned is really important for being able to work with Arrows and maintain your sanity.
23:23:58 <dmwit> Hm, no laws for the Zip typeclass.
23:24:05 <Cale> because it's what lets you draw the cute wiring diagrams which everyone draws and have them actually mean something
23:24:26 <Cale> (without also drawing in lots of boxes to say exactly how those wiring diagrams are built up from the combinators)
23:24:30 <zzo38> I do not care about sanity. Let's do mathematics.
23:25:34 <yitz> Cale: a lot of people think of arrows as being more or less equivalent to applicative nowadays. you use one or the other based on which notation works out nicer for your particular application.
23:25:38 <zzo38> Cale: Yes I like the wiring diagrams too, although that wouldn't be using arr. The package for lenses includes a Tensor class for (***) and I could make another class for fanout (fanout = id &&& id)
23:27:15 <yitz> Cale: i was just having a discussion the other day about whether conduit ought to be an arrow. so far it doesn't have an instance, but there's a feeling that it ought to. seems like it would be natural.
23:27:35 <Cale> yitz: At some point, I think it would be nice to take over Control.Arrow and revamp it into something which is more deeply rooted in symmetric or braided monoidal categories.
23:27:52 <yitz> Cale: or maybe fork it
23:28:07 <Cale> In iPwn's FRP system, we have our own Control.Arrow and preprocessor for arrow notation
23:28:18 <ifnspifn> anyone very familiar with Data.Graph?
23:28:31 <zzo38> I like having one class for categories and another for tensor categories, and then another one can be added for fanout category
23:28:32 <dmwit> Don't ask to ask, just ask.
23:28:44 <Cale> which ends up relying on that law I mentioned pretty heavily
23:29:03 <luca__> @pl \xs -> (concatMap fst xs, map snd xs)
23:29:03 <lambdabot> liftM2 (,) (fst =<<) (map snd)
23:29:37 <ifnspifn> Fair enough. Alright, so I'd like to construct a graph from a list of edges of type [(Char, Char)]. I'm not really following Data.Graph's buildG function (http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Graph.html) which seems to require a graph constructed from ints
23:29:49 * hackagebot leksah-server 0.12.1.1 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.12.1.1 (JuergenNicklischFranken)
23:30:10 <tertl3> hi
23:30:22 <yitz> Cale: do all arrow-based frp systems satisfy that "no-effects" law?
23:30:33 <yitz> Cale: does hxt?
23:30:37 <zzo38> What is a "no-effects" law?
23:30:42 <Cale> yitz: hxt doesn't
23:30:48 <Cale> Because hxt is really a monad
23:30:55 <luca__> @pl \x -> liftM return . return $ x
23:30:56 <lambdabot> return . return
23:30:58 <Cale> (well, not "because" exactly)
23:31:21 <Cale> But I think most arrow-based FRP systems ought to satisfy this law
23:31:30 <Cale> If they don't, it should be easy to make them do so
23:31:57 <dmwit> Huh, I didn't even know containers had a Graph type.
23:31:59 <zzo38> What would the monad have to satisfy for the Kleisli category to be Arrow using the other laws?
23:32:13 <yitz> Cale: a lot of people find arrow notation convenient for hxt. so that's a good example of why it might be better to fork arrow to what you want, not "take it over" and break what other people are doing.
23:32:34 <luca__> I don't understand this. As a last function decl. to catch all other argument shapes I have transf x = (return . return) x. But if i reduce this to transf = return . return I get an error that it has a different number of arguments now
23:32:50 <dmwit> ifnspifn: graphFromEdges seems to have a more realistic type.
23:33:10 <zzo38> I have thought of much things relating to classes that have laws but no methods
23:33:12 <Cale> yitz: Yeah, maybe. Our desugaring of Arrow syntax has the advantage that it's actually useful.
23:33:35 <Cale> yitz: The problem with the existing desugarer is that it uses arr between almost everything
23:33:53 <ifnspifn> dmwit: What is the structure of the nodes, though? I don't understand what the keys represent
23:34:01 <Cale> which basically defeats most of the purpose of using Arrow in the first place. arr is okay, if kept to a minimum
23:34:28 <dmwit> ifnspifn: The nodes are any kind of data you want to store at the nodes of the graph; the keys are your Char's.
23:34:48 <yitz> zzo38: the law that Cale proposes:  (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
23:34:49 * hackagebot Paraiso 0.3.1.2 - a code generator for partial differential equations solvers.  http://hackage.haskell.org/package/Paraiso-0.3.1.2 (TakayukiMuranushi)
23:35:38 <dmwit> ifnspifn: The nodes of the graph are uniquely identified by a value of type "key", and contain some data of type "node"; edges contain no data and are uniquely identified by a pair of keys.
23:36:22 <zzo38> yitz: Does that have a name in general in mathematics?
23:36:28 <ifnspifn> ahh, that clears things up. Thanks, dmwit
23:37:48 <yitz> zzo38: Cale's law
23:38:09 <zzo38> You could use . instead of <<< and >>> for morphism composition
23:38:35 <Cale> It's called the interchange law
23:38:47 <Cale> c.f. the definition of a 2-category
23:39:05 <zzo38> OK
23:39:12 <Cale> Basically I want Arrow to be roughly "symmetric monoidal category", which is a kind of 2-category
23:39:25 <Cale> Or possibly "braided monoidal category"
23:39:45 <Cale> The string diagrams which people draw are really a notation for weak-2-categories
23:40:27 <Cale> (which also supposedly include, in some fashion which I don't fully understand, Feynman diagrams from physics)
23:40:58 <zzo38> What monad's Kleisli category follows interchange law, then?
23:41:06 <Cale> Commutative monads
23:41:36 <Cale> Ones where   do a <- x; b <- y; f a b  is equivalent to  do b <- y; a <- x; f a b
23:41:57 <zzo38> I know what commutative applicative is
23:42:05 <zzo38> And I assume you mean the same thing here
23:42:49 <Cale> Oh, yeah, another way to put it would be that the monad is commutative when  liftM2 f a b = liftM2 (flip f) b a
23:42:56 <Cale> which generalises to the Applicative case nicely
23:43:54 <mietek> Is old-locale obsoleted by anything newer?
23:44:00 <zzo38> (By commutative applicative I mean   (<**>) = flip (<*>))
23:44:25 <zzo38> (I also dislike do-notation; I can understand it better without)
23:45:23 <Cale> Well, it's nice here because you simply interchange the order of the statements in do-notation
23:45:30 <ClaudiusMaximus> @pl \f a b -> liftM2 f a b == liftM2 (flip f) b a
23:45:30 <lambdabot> ap (ap . (liftM2 (==) .) . liftM2) (flip . liftM2 . flip)
23:45:51 <Cale> (sort of helps to explain what's commutative about this)
23:46:19 <zzo38> There are many other ways to specify commutative applicative too, including    fmap swap . liftPair = liftPair . swap
23:46:52 <ClaudiusMaximus> :t (flip . liftM2 . flip, liftM2)
23:46:53 <lambdabot> forall a1 a2 r (m :: * -> *) a11 a21 r1 (m1 :: * -> *). (Monad m, Monad m1) => ((a2 -> a1 -> r) -> m a2 -> m a1 -> m r, (a11 -> a21 -> r1) -> m1 a11 -> m1 a21 -> m1 r1)
23:48:15 <zzo38> Yes, and    flip . liftA2 . flip = liftA2    is another way.
23:48:28 <ClaudiusMaximus> :)
23:49:54 <ClaudiusMaximus> i find   flip . f . flip = f  a lot easier to grasp than the pointy verion
23:50:14 <zzo38> I happen to prefer    fmap swap . liftPair = liftPair . swap
23:51:09 <ClaudiusMaximus> yeah,   flip . flip = id ?   so  f . flip = flip . f  would be even nicer
23:51:40 <zzo38> O, yes!
23:51:41 <ClaudiusMaximus> well, maybe not - i need breakfast
23:51:50 <hpaste> Cale pasted “A bit of our Arrow library” at http://hpaste.org/69578
23:52:38 <zzo38> Cale: So what would f have to be in (f x -> f y) to follow the interchange law?
23:53:02 <Cale> Well, you need a *** first
23:53:04 <zzo38> And what would the comonad have to be in a coKleisli category to follow interchange law?
23:53:10 <zzo38> Cale: Yes I know that
23:53:18 <Cale> before you can even say what the interchange law would mean
23:53:42 <zzo38> What definition of *** would work here?
23:53:56 <Cale> Probably depends heavily on what f is
23:54:08 <Cale> and not really in any uniform way that I can see
23:54:08 <dmwit> :t (***)
23:54:09 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
23:54:34 <zzo38> Is there one way that works if and only if f is idempotent?
23:54:47 <Cale> So you'll need a function  (f b -> f c) -> (f b' -> f c') -> (f (b,b') -> f (c,c'))
23:54:56 <zzo38> Also, is there a way that works if and only if f is commutative?
23:55:06 <zzo38> Is there a way that works for other conditions?
23:55:51 <dmwit> :t let zip :: Functor f => f a -> f b -> f (a,b); zip = undefined in \fab fab' faa' -> zip (fmap (fab . fst) faa') (fmap (fab' . snd) faa')
23:55:52 <lambdabot> forall a a1 b (f :: * -> *) b1. (Functor f) => (a1 -> a) -> (b -> b1) -> f (a1, b) -> f (a, b1)
23:56:33 <dmwit> oh
23:56:34 <zzo38> (By idempotent applicative I mean: join (<*) = id)
23:56:56 <dmwit> :t let zip :: Functor f => f a -> f b -> f (a,b); zip = undefined in \fab fab' faa' -> zip (fab (fmap fst faa')) (fab' (fmap snd faa'))
23:56:57 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) a1 b1. (Functor f1, Functor f) => (f a -> f1 a1) -> (f b -> f1 b1) -> f (a, b) -> f1 (a1, b1)
23:57:09 <dmwit> How about that as a definition of (***)?
23:57:14 <Cale> maybe :)
23:57:22 <dmwit> What do we need to demand of zip for the laws to work out? =)
23:57:25 <Cale> has the right type at least
23:59:09 <Cale> yitz: http://hpaste.org/69578
23:59:48 <Cale> yitz: That's the sort of thing that we've been using. The Pair type constructor is a bit of extra fanciness, and you can just as well replace it by (,)
