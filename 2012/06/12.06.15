00:18:27 <tiger2wander> hi there
00:20:23 <tiger2wander> I'm new with Haskell and I have a problem with type casting
00:20:48 <shachaf> tiger2wander: You should ask your question! Someone here will probably know the answer.
00:21:06 <tiger2wander> Yeah, I hope so :-)
00:21:15 <shachaf> (Also, "type casting" is a pretty ambiguous term so people don't usually use it in Haskell.)
00:21:28 <Eduard_Munteanu> tiger2wander: my guess is you're mistaking type ascription with casting
00:21:41 <Eduard_Munteanu> (or simply, type signatures)
00:21:57 <Eduard_Munteanu> s/mistaking/mixing up/
00:22:05 <tiger2wander> I'm trying to get value of environment variable and store it to a variable which will be use later for string concatnation operation
00:22:32 <tiger2wander> but I always got IO String/ Char instead of pure String type
00:22:33 <tiger2wander> and
00:22:54 <shachaf> tiger2wander: Ah -- this isn't even a type issue. :-)
00:22:57 <tiger2wander> I learned IO operation which get value from IO var
00:23:03 <shachaf> You should read about how IO works in Haskell.
00:23:05 <shachaf> @where faq
00:23:06 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
00:23:42 <shachaf> It's worth your while to make sure you understand it -- it's not what you might think it is. I think the FAQ links to "introduction to IO".
00:24:12 <kulin> tiger2wander, the function to get the env var value is almost certainly not pure so the value is wrapped in IO, once it's in IO you can't get out of that, but you shouldn't feel constrained, it means you are thinking about what you are trying to do in a backwards way
00:24:32 <tiger2wander> Yes, I has spent a few hours to try to understand how it work but still not get what I want
00:24:49 <tiger2wander> I learned to get String value from it
00:24:59 <shachaf> Also you'll get a lot of misleading information that uses phrases like "wrapped in IO".
00:25:07 <tiger2wander> but it is only affected inside `do` scrope
00:25:20 <tiger2wander> outside `do` expr it back to IO type :(
00:25:31 <shachaf> tiger2wander: It's important to realize that "IO String" doesn't contain a String.
00:25:34 <shachaf> @quote /bin/ls
00:25:35 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
00:25:50 <shachaf> tiger2wander: You should read the FAQ and the things it links to!
00:25:52 <RosePerry> When I run ghci, why do I get "-bash: /usr/local/bin/ghci: No such file or directory" when which ghci gives me "/usr/bin/ghci" ?
00:25:58 <kulin> shachaf, im of the opinion that you don't start learning at a graduate level :)
00:26:06 <shachaf> RosePerry: bash issue with recently installed binaries.
00:26:21 <shachaf> Try exiting bash, or maybe just updating your PATH or something.
00:26:23 <Eduard_Munteanu> RosePerry: do   hash -r   and try again
00:26:40 <RosePerry> IT worked! Thanks (:
00:26:42 <tiger2wander> shachaf, I will take my time to read it and will need your help after that :)
00:27:13 <shachaf> kulin: Right, but that doesn't mean you say wrong things to people who are trying to learn!
00:27:26 <kulin> ya it does! remember how columbus discovered america? :)
00:27:27 <shachaf> This particular wrong thing has led to a lot of confusion among a lot of beginners.
00:27:59 <kulin> i suppose, fine i retract my simplification
00:30:18 <kulin> besides with things like 'return' i dont think that wrapped is a terrible term to use
00:32:05 <shachaf> kulin: I think it is.
00:32:24 <shachaf> For example, the thing I said above about getLine.
00:32:26 <Eduard_Munteanu> It shouldn't make any difference if you follow the types :)
00:32:48 <shachaf> Eduard_Munteanu: "Go back to #agda." :-)
00:33:02 <Eduard_Munteanu> :P
00:34:01 <kulin> shachaf, theres nothing particularly IO String about: return "this"
00:34:02 <kulin> however
00:34:13 <kallisti> hey what's the GHC version on the latest HP?
00:34:29 <shachaf> kulin: Yes there is, if you give it the type IO String?
00:34:38 <kulin> hah
00:34:44 <shachaf> You might as well say that (\_ -> "this") isn't a function.
00:37:33 <tiger2wander> I'm curious about why Haskell use IO String as a return type but not simply String for some simple function like System.Environment.getEnv() ?
00:37:36 <Catnaroek> Hey, is there anything like modify, but which also returns the old state?
00:37:58 <shachaf> tiger2wander: Because it's not a function.
00:38:27 <kulin> tiger2wander, getEnv isn't always going to give you the same string even with the same parameters, so it is not a pure function
00:38:35 <tiger2wander> shachaf, it's IO action?
00:38:45 <shachaf> kulin: It's not a function at all.
00:39:05 <shachaf> tiger2wander: Yes.
00:39:13 <kulin> what is it?
00:39:26 <Eduard_Munteanu> A value.
00:39:30 <Eduard_Munteanu> @hoogle getEnv
00:39:30 <lambdabot> System.Environment getEnv :: String -> IO String
00:39:31 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
00:39:31 <lambdabot> System.Posix.Env getEnv :: String -> IO (Maybe String)
00:39:39 <Eduard_Munteanu> Wait, it is a function.
00:39:40 <tiger2wander> I was try to read FAQ many time and I will try to read it again which new idea to understand :-)
00:40:38 <shachaf> Eduard_Munteanu: Fine. :-(
00:40:43 <shachaf> I was thinking of getEnvironment.
00:42:09 <mgsloan> Catnaroek: modifyWithOld l f = id &&& modify l f
00:42:27 <Catnaroek> mgsloan: Oh, thank you. :)
00:42:44 <tiger2wander> ok, so is there anyway to get value from an IO Action and concat it with a string without use temperary var?
00:43:00 <mgsloan> welcome!  I wouldn't recommend actually calling it this, btw!  (since the definition is shorter than the name!)
00:43:22 <shachaf> tiger2wander: There's no "getting the value from the action". You can run the action, though. (This seems pedantic but it's helpful to get it straight.)
00:43:41 <shachaf> You can do something like getEnv "foo" >>= function
00:43:57 <shachaf> I'd say just write it using do { x <- getEnv "foo"; ...x... } for now.
00:44:11 * hackagebot cryptocipher 0.3.5 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.3.5 (VincentHanquez)
00:45:06 <shachaf> Yay, another person implementing cryptography primitives in pure Haskell for the something of it!
00:45:25 <tiger2wander> shachaf, Look like it became much more complex compared with another language for a just simple action like get data
00:46:05 <shachaf> tiger2wander: Well, it's a different way of thinking about things.
00:46:12 <tiger2wander> And I was use that way but don't like it
00:46:32 <shachaf> Well, there are shorter ways of writing it.
00:46:42 <tiger2wander> I wanna to store it to global var, outside of do expr
00:47:13 <Catnaroek> Hello. I am writing a program that uses a State monad to keep track of changes to a collection of people indexed by their names (Data.Map.Map String Person). Here is the code: http://hpaste.org/69979 . In line 45, I get an error saying that function is not a member of the record. (Well, it technically is not, but its value is a member of the record.) Is there any way to get around this problem?
00:48:05 <shachaf> That code is frighteningly nested.
00:48:07 <tiger2wander> Another problem, x <- getEnv "HOME" work inside do expr but outside it will raise an error :-(
00:48:27 <shachaf> Catnaroek: What's the type of fun?
00:48:34 <shachaf> The answer to your question might be "lenses".
00:48:55 <shachaf> Or it might be "rethink your code"...
00:49:16 <Catnaroek> shachaf: It is Person -> Maybe String
00:49:37 <kulin> tiger2wander, you should try and think of it this way: you can perform an IO action inside of a 'do' but anything that works on the result of that IO action is automatically an IO action by its very nature
00:50:16 <kulin> tiger2wander, so you trying to take something out of an IO action to work with it as if it were independant is nonsense and the language is trying to prevent that
00:51:03 <tiger2wander> Is it "strict types"?
00:51:24 <mgsloan> Catnaroek: You're using "fun" as a field name on line 45, which means it needs to be a member of the person datatype
00:51:32 <shachaf> It has nothing to do with types.
00:51:40 <shachaf> Oops, I said I'd get out of here.
00:54:08 <Catnaroek> mgsloan: But fun is either father or mother, which are members of the Person data type.
00:54:23 <Catnaroek> Oooooooooooooooooooh. Dang. I see it.
00:54:35 <Catnaroek> (That fact cannot be validated by the type system.)
00:54:40 <Catnaroek> (So it rejects it.)
00:55:52 <programm1r> hellop
00:55:54 <programm1r> hello
00:56:10 <Catnaroek> Hello.
00:56:14 <mikeplus64> tiger2wander: if you do want a global variable of an IO action, then you can use unsafePerformIO
00:56:21 <mikeplus64> but you really should avoid it :)
00:56:26 <mgsloan> Catnaroek: well, the syntax "p' { fun = Just n' }" means "set field fun in p' to the value on the right"
00:57:02 <mgsloan> field fun is not in p' - this is probably a scope error rather than type error
00:57:35 <mgsloan> (though I guess it probably needed types in order to realize that it's an error..)
00:57:39 <mikeplus64> tiger2wander: if you want real variables, you can use newIORef or newMVar from Data.IORef and Control.Concurrent respectively, you can make either of these using unsafePerformIO, but again, it's best to do it in the IO monad somewhere else (ie the main function or functions called by main)
00:58:08 <mgsloan> Catnaroek: Consider replacing "fun" with "gender"?  I'm not sure what the code is trying to do (haven't tried to figure it out)
00:58:32 <tiger2wander> mikeplus64, I will think about it
00:59:06 <programm1r> Does anyone use the module Decimal?
00:59:12 * hackagebot SimpleEA 0.2.1 - Simple evolutionary algorithm framework.  http://hackage.haskell.org/package/SimpleEA-0.2.1 (ErlendHamberg)
01:00:12 <programm1r> Illegal datatype context (use -XDatatypeContexts): Integral i =>
01:00:54 <barrucadu> Integral is not a typeclass
01:01:01 <programm1r> ?
01:01:03 <mauke> ?
01:01:25 <barrucadu> (I think)
01:01:30 <Axman6> @instances Integral
01:01:31 <lambdabot> Int, Integer
01:01:40 <barrucadu> Ah, I was thinking of Integer. Right
01:04:09 <programm1r> More please explain
01:07:48 <shachaf> mgsloan: "fun" in Catnaroek's code is either "father" or "mother", the *function*.
01:07:54 <shachaf> Which isn't the same as the record accessor.
01:08:28 <mgsloan> yeah
01:08:33 <shachaf> Lenses would be the obvious answer to the problem, but I think rewriting the code somewhat is also a good answer because it's rather difficult to understand. It might also render the whole thing unnecessary, but I don't know.
01:09:49 <programm1r> What options -XDatatypeContext
01:10:12 <quicksilver> don't do it anyway
01:10:15 <quicksilver> datatype contexts are pointless
01:10:21 <quicksilver> that's why they got relegated to an extension
01:10:33 <programm1r> Illegal datatype context (use -XDatatypeContexts): Integral i =>
01:11:53 <kallisti> I'm building Haskell Platform from source and it's recommending I use ghc 7.4.1. has anyone had any problems with using ghc 7.4.2?
01:12:22 <startling> kallisti, worked for me.
01:14:45 <kallisti> /usr/bin/ld: unrecognized option '--build-id=none'
01:14:56 <kallisti> hm. I get this when building HUnit
01:15:29 <Catnaroek> Is there any way to give record members default values?
01:15:40 <startling> Catnaroek: don't think so
01:15:46 <flux> you probably want to rather create a value that has them in place
01:15:48 <kallisti> ah. looks like I'm using an old version of ld
01:15:48 <Eduard_Munteanu> Catnaroek: define a default value, modify that
01:15:50 <shachaf> Make a "default" record, modify that.
01:15:51 <kallisti> damn this centOS install..
01:15:55 <Eduard_Munteanu> Heh.
01:16:07 <Catnaroek> Eduard_Munteanu: Oh, yeah, I had not realized I could use a constant for that, hehe. :)
01:16:50 <kallisti> hm, well this is interesting
01:18:58 <kallisti> so I installed a new glibc, but it looks like haskell platform is attempting to link with the old ld
01:19:40 <Eduard_Munteanu> kallisti: ld isn't a glibc thing, it's in binutils
01:20:05 <kallisti> time to compile more things from source then..
01:20:25 <kallisti> (I guess I could just request a more up-to-date server...)
01:20:37 <Eduard_Munteanu> Maybe you could try adding EPEL to your sources.
01:20:52 <Eduard_Munteanu> (maybe that gets you newer stuff, though I'm not sure)
01:21:10 <kallisti> ah maybe.
01:21:28 <kallisti> I must say I'm new to the red hat world.
01:21:37 <kallisti> I mostly stick to Debian-based distros.
01:23:53 <kallisti> doesn't look like it has binutils
01:24:28 <kallisti> assuming centOS works anything like Debian I could probably just reconfigure yum to point to a more up-to-date repo.
01:36:40 <tiger2wander> What's best practice for following snippet? http://pastebin.ca/2161574
01:38:42 <tiger2wander> shachaf, Any idea?
01:39:06 <mikeplus64> tiger2wander: that's not that bad, although what i would do is make a function to generate that big long string
01:39:34 <RosePerry> Could someone explain this line of code? newtype Rand g a = Rand (RandT g Identity a)
01:39:35 <RosePerry>     deriving (Functor, Monad, MonadRandom)
01:40:06 <mikeplus64> like icon colour path h = "^p(5)^fg(" ++ colour ++ ")^i(" ++ path ++ h ++ ")^fg()^p(5)" Itkovian
01:40:08 <mikeplus64> tiger2wander:
01:40:09 <mikeplus64> oops
01:40:11 <mikeplus64> sorry Itkovian
01:40:30 <Itkovian> np :-)
01:40:48 <Catnaroek> Is there any function that lets me easily change an atribute of a record?
01:40:52 <mikeplus64> and with that you could write iconB h = icon "blue" myBitmapsPath h
01:40:58 <tiger2wander> mikeplus64, Yeah, it is using to generate conky's icon statusbar with xmonad
01:41:53 <tiger2wander> mikeplus64, It is dirty for now, and I will cleanup then
01:47:00 <tiger2wander> mikeplus64, Ok, it is look better now: http://pastebin.ca/2161578
01:47:23 <mikeplus64> tiger2wander: yeah
01:47:35 <tiger2wander> mikeplus64, What do you do with line 2 as my comment?
01:48:11 <mikeplus64> tiger2wander: btw, you don't need the parens on line 2, and it's pretty standard to have type annotations above your function definitions (in this case though i might just do iconB, iconY, iconW ... :: String)
01:48:18 <mikeplus64> tiger2wander: probably just put it on the line above
01:49:48 <tiger2wander> mikeplus64, I want to use value from env var instead of hardcode for icon's path
01:50:20 <tiger2wander> and yes, parens are no need for line 2, it was there from last test with getEnv :-)
01:50:38 <mikeplus64> tiger2wander: in that case id put in your main function, path <- getEnv (or whatever), then just apply 'path' to the functions
01:51:22 <hpaste_> av pasted “attoparsec with large data” at http://hpaste.org/69984
01:52:23 <av> hello gals and blokes, here's a piece of code which I'm struggling with: http://hpaste.org/69984
01:52:58 <womb> HI !
01:53:01 <t3eblinder> RosePerry: RandT is a monad transformer, so you can use another monad within it (like IO, e.g. to print statements...) The Identity monad has simply no effects.
01:54:28 <av> question: main1 and main2 both work, but main2 is a lot faster and uses less memory -- why?  is there a way of defining a parser for the entire data (rather than line-by-line) that doesn't memory leak?
01:54:38 <RosePerry> So it's defining a Rand constructor, such that the first parameter must be a (type RandT?) and the second can be anything?
01:58:34 <t7> How many monads could a monad transformer transform, if a monad transformer could transform monads?
01:58:36 <programm1r> Module Decimal (took hackage) how to fix? Illegal datatype context (use-XDatatypeContexts): Integral i =>
01:59:29 <t3eblinder> You are just using the RandT monad with explicit Identity monad. It really does not do something special. You could use any kind of monad to stack in RandT and wrap a newtype around, e.g. newtype RandIO g a = R (RandT g IO a)  (http://www.haskell.org/haskellwiki/Newtype)
02:00:05 <Enigmagic> av: main2 parses line at a time, main1 parses the whole thing into a giant list
02:02:00 <Enigmagic> programm1r: either add -XDatatypeContexts or remove the Integral constraint since it doesn't do much of anything anyways
02:03:20 <tiger2wander> mikeplus64, How can I use path in main func outside do expr?
02:03:54 <mikeplus64> tiger2wander: no, not without a global String
02:04:01 <mikeplus64> herpoops
02:04:02 <programm1r> Enigmagic: It depends on the compiler version?
02:04:03 <mikeplus64> oops
02:04:18 <mikeplus64> tiger2wander: i mean, by making it a parameter of your functions
02:04:35 <Enigmagic> programm1r: old versions of the compiler don't complain
02:04:51 <mikeplus64> ie main = do path <- getEnv "foo"; something_using_path path "hi tiger2wander "
02:05:12 <mikeplus64> tiger2wander: (sorry, misread question first time)
02:05:26 <Enigmagic> programm1r: they didn't do much of anything in old compilers either... just newer versions of GHC don't support them by default.
02:05:44 <programm1r> Enigmagic: How to add this option? At the command line or in the source file?
02:05:45 <tiger2wander> mikeplus64, OK, leme try it
02:06:13 <Enigmagic> programm1r: -XDatatypeContexts on the command line or {-# LANGUAGE DatatypeContexts #-} in the top part of your source file
02:06:47 <programm1r> Enigmagic: thank you
02:06:50 <Enigmagic> programm1r: i'd really recommend removing the context though since it's more portable
02:07:01 <Enigmagic> programm1r: current versions of ghc say this when you enable it: Warning: -XDatatypeContexts is deprecated: It was widely considered a misfeature, and has been removed from the Haskell language.
02:10:01 <programm1r> Enigmagic: I understand. So far I've just started learning haskell and I need this module (for example), but it gives this error. I'll try to run, and then we will see ...
02:13:58 <hpaste_> kallisti pasted “weird gcc messages might be causing a linker error later?” at http://hpaste.org/69985
02:14:19 <kallisti> any idea what this might be about? google isn't turning up with any helpful results.
02:15:54 <programm1r> Enigmagic: Thank you, Decimal module loaded. Tell me, where you can read about these changes?
02:16:19 <Enigmagic> programm1r: http://stackoverflow.com/questions/7438600/datatypecontexts-deprecated-in-latest-ghc-why
02:17:12 <Enigmagic> kallisti: i think you have an old version of binutils
02:17:50 <kallisti> I have a new version now. it could be that the postgres packages use an old binutils.
02:17:59 <kallisti> so... more source compilation.
02:18:09 <Enigmagic> that's a ghc error
02:18:12 <programm1r> Enigmagic: Thank you very much!
02:18:36 <kallisti> Enigmagic: right but it's linking to a postgresql C library
02:18:37 <tiger2wander> mikeplus64, It's look better now, but I still have some work with IO redirection, make me confusing :-(
02:18:49 <Enigmagic> kallisti: then again, maybe not.. might just be a warning apparently. is the symbol actually exported?
02:19:05 <kallisti> I have no clue about the symbol. and yes it's a warning
02:19:11 <Enigmagic> kallisti: http://hackage.haskell.org/trac/ghc/ticket/5240
02:20:14 <Enigmagic> kallisti: just check to see if PQisthreadsafe is exported from the postgres library
02:20:19 <kallisti> it could be that gcc isn't using the new ld I installed.
02:21:06 <kallisti> "Can we do that? Care needs to be taken if people use the -pgmL option, and we should make sure that gcc is actually using GNU ld."
02:21:44 <kallisti> Enigmagic: not sure how to do that.
02:22:00 * kallisti is not a C programmer. :P
02:23:03 <kallisti> if it's what I think it is I may need to compile GCC from source. >_>
02:23:14 <Enigmagic> kallisti: nm -D /usr/lib/libpg.so.* | grep PQisthreadsafe
02:23:31 <Enigmagic> fill in whatever postgres library you're actually linking against
02:24:34 <Enigmagic> err libpq.so
02:24:53 <Enigmagic> should look like this: 000000000000ab80 T PQisthreadsafe
02:25:14 <Enigmagic> (ignore the number, make sure it says T)
02:26:02 <kallisti> yes it's in all 3 shared libs named "libpq"
02:26:12 <kallisti> which is what HDBC-postgresql is a binding of.
02:26:31 <Enigmagic> well try building with ghc -v3 to see what it's linking against
02:26:40 <kallisti> oh right..
02:27:50 <kallisti> wow what...
02:27:58 <kallisti> this bash doesn't have |&
02:28:33 <Enigmagic> alright well good luck
02:28:45 <Enigmagic> bed time for me
02:29:12 <mm_freak> t7: hi there…  have you implemented a compiler by now?
02:29:40 <kallisti> Enigmagic: thanks for the help
02:30:00 <mm_freak> i have finally managed to write non-optimizing lambda-to-SKI compiler that actually compiles \f x y z -> f x y z to I
02:30:51 <startling> mm_freak: very cool
02:31:05 <mm_freak> and that makes me wondering whether it's still worth writing a G-supercombinator compiler
02:32:34 <startling> kallisti, sure it's bash?
02:32:48 <kallisti> startling: sh is bash. I'm not sure how to tell what my current shell is.
02:32:59 <kallisti> but yes I opened bash and tested it out
02:33:13 <Catnaroek> mm_freak: Will you post the source? :O
02:33:14 <kallisti> bash 3.2
02:33:37 <mm_freak> Catnaroek: the translation is actually very simple (the code is on another computer)
02:34:04 <mm_freak> you need the traditional supercombinators S, K, I, B and C…  i've also added SPJ's combinators S', B' and C'
02:34:16 <mm_freak> the real magic comes from two additional combinators of my own
02:34:56 <mm_freak> F x y = y x
02:35:07 <mm_freak> and the corresponding lifting version F'
02:35:45 <mm_freak> i also added a builtin fixpoint combinator that generates two graph nodes
02:35:50 <kallisti> startling: my client keeps throwing old centOS boxes at me, meanwhile I'm trying to build up-to-date Haskell. :P
02:36:20 <startling> kallisti: heh
02:36:32 <mm_freak> Catnaroek: also unlike SPJ's paper i'm performing the K optimization implicitly as part of the compilation
02:40:43 <kallisti> startling: should I be reading the GCC INSTALL file in the voice of rms?
02:40:48 <kallisti> because I am.
02:40:51 <Catnaroek> mm_freak: To be honest, I do not know anything about CS.
02:41:28 <mm_freak> Catnaroek: oh, sorry…  SPJ's book from 1987 introduces SKI pretty well
02:41:57 <mm_freak> (the chapter is called SK calculus, because technically I is redundant)
02:42:14 <Catnaroek> mm_freak: I know what the SKI combinators are... but only as a general culture topic.
02:43:03 <mm_freak> you can translate any lambda calculus expression into an SKI expression getting rid of all abstractions and variables…  that makes compilation to a graph representation extraordinarily simple
02:43:22 <Catnaroek> :O
02:43:27 <Catnaroek> Nice.
02:43:52 <mm_freak> the concern is that SKI programs generate more graph nodes, hence run slower, but i have written a compilation scheme that produces a reasonably low amount of nodes
02:43:56 <adamt> can i do something like "import Foo.Bar (Baz as Quux)"? or "import qualified Foo.Bar as Bar (Baz)"?
02:44:16 <Catnaroek> mm_freak: :O
02:44:37 <mm_freak> adamt: you can't rename symbols inside a module, but you can import the same module a number of times each time with a different name
02:44:45 <startling> adamt: the second works
02:45:05 <adamt> startling: and gives med Bar.Baz?
02:45:10 <startling> adamt: yep
02:45:14 <hpaste_> james-ubc pasted “day of the year calcuator” at http://hpaste.org/69986
02:45:20 <adamt> great. Thanks both of you.
02:45:51 <james-ubyssey> hey guys, just started haskell a week ago
02:46:01 <kallisti> awesome.
02:46:25 <Catnaroek> @src forM_
02:46:26 <lambdabot> forM_ = flip mapM_
02:46:38 <srhb> james-ubyssey: Welcome to a better world. :-)
02:46:38 <james-ubyssey> thought i'd write a little test program toget my feet wet, tell me what you think
02:46:40 <mm_freak> james-ubyssey: welcome to the wonderful planet haskell =)
02:47:26 <james-ubyssey> hehe thanks :P the thing is here if anybody could comment that'd be great :) http://hpaste.org/69986
02:47:50 <srhb> james-ubyssey: error is generally bad
02:48:59 <mm_freak> james-ubyssey: first of all, write a type signature for all of your top level functions
02:49:33 <kallisti> month could be simplified using guards and elem
02:49:50 <mm_freak> james-ubyssey: as srhb suggests 'month' should have a type like Int -> Maybe Int
02:50:13 <mm_freak> also you may want to choose a better name =)
02:50:38 <kallisti> month n | n `elem` [1,3,5,7,8,10,12] = 32 | n `elem` [4,6,9,11] = 31
02:50:40 <james-ubyssey> srhb:  why is that? i thought it'd be nice to inform any hypothetical users where their data was wrong
02:50:42 <kallisti> and so on
02:50:55 <mm_freak> james-ubyssey: you shouldn't do that in 'month'
02:51:26 <srhb> james-ubyssey: error crashes your program in a utility function though. instead that could be made completely safe by returning a Maybe Int, and you could handle that with pattern matching.
02:52:04 <mm_freak> james-ubyssey: the idea is that a pure function should never crash the program
02:52:14 <srhb> > let month 1 = Just 31; month _ = Nothing
02:52:16 <lambdabot>   not an expression: `let month 1 = Just 31; month _ = Nothing'
02:52:24 <srhb> Oh really.
02:52:37 <mm_freak> ++ "in month 1"
02:52:58 <srhb> > let month 1 = Just 31; month _ = Nothing in month 1
02:53:00 <lambdabot>   Just 31
02:53:03 <srhb> Ah there we go
02:53:05 <james-ubyssey> cool, speaking of pattern matching, how would i fix the pattern matching/parsing failurs when reading the input?
02:53:06 <srhb> > let month 1 = Just 31; month _ = Nothing in month 34
02:53:08 <lambdabot>   Nothing
02:53:24 <mm_freak> james-ubyssey: give a variable pattern:  _ -> …
02:53:38 <kallisti> james-ubyssey: the reads function allows you to catch failures
02:53:41 <kallisti> it's a bit awkward though.
02:53:52 <srhb> readMaybe perhaps
02:53:56 <kallisti> :t readMaybe
02:53:57 <lambdabot> Not in scope: `readMaybe'
02:54:04 <kallisti> is that a thing?
02:54:15 <james-ubyssey> do i have to declare  type for main?
02:54:32 <srhb> kallisti: Uh, I guess I usually just define it myself for consistency. :-)
02:54:33 <kallisti> strictly speaking, no. you can though. I usually don't, personally.
02:54:40 <mm_freak> james-ubyssey: you don't have to…  many haskellers do, because it's good style
02:54:53 <mm_freak> james-ubyssey: also it can make a subtle difference:  main = getLine
02:55:01 <kallisti> for most other  top-level functions I do. I tend to leave out main because of.. reasons.
02:55:04 <mm_freak> if you write "main :: IO ()" that's a type error, if you don't it compiles
02:55:18 <mm_freak> view type signatures as the specification of your program
02:55:57 <srhb> I generally leave out the signature for main too. It's always IO something anyway.
02:56:01 <srhb> And "special" :-)
02:56:22 <mm_freak> hmm…  i don't see the speciality of main compared to, say, getLine
02:56:38 <srhb> mm_freak: only that it's a known entry and exit point.
02:57:03 <james-ubyssey> wait wha
02:57:10 <james-ubyssey> if it's not type IO () then what is it?
02:57:24 <srhb> :t getLine
02:57:25 <lambdabot> IO String
02:57:47 <mm_freak> james-ubyssey: "=" in haskell actually means "is equal to"
02:57:49 <james-ubyssey> i did :t in ghci and it returned IO () O.o
02:57:56 <mm_freak> so if you write main = getLine, then their types are the same, because they are the same thing
02:57:57 <startling> james-ubyssey, getLine?
02:58:07 <kallisti> james-ubyssey: the type of /your/ main is IO ()
02:58:10 <startling> :t getLine
02:58:11 <lambdabot> IO String
02:58:12 <srhb> james-ubyssey: It depends what your main does. If your main is equal to getLine, it also has the type signature of getLine
02:58:13 <kallisti> he's talking about a different one.
02:58:17 <startling> oh
02:58:18 <james-ubyssey> oooooooooooh okay
02:58:41 <kallisti> the Haskell report defines main to have the type IO a
02:58:50 <mm_freak> kallisti: that's correct
02:59:03 <james-ubyssey> oh  also, when igave read a type of Integer it failed
02:59:03 <kallisti> so anything can be used in the parameter.
02:59:07 <mm_freak> it makes sense, because the RTS ignores the result
02:59:34 <kallisti> that's because read takes a String.
02:59:37 <kallisti> :t read
02:59:38 <lambdabot> forall a. (Read a) => String -> a
03:00:24 <dinges> :t forall
03:00:26 <lambdabot> Not in scope: `forall'
03:00:56 <james-ubyssey> it looks like the sum
03:01:02 <james-ubyssey> wants to convert everything into Int
03:01:03 <kallisti> what does.
03:01:17 <kallisti> you mean +?  not quite
03:01:17 <james-ubyssey> instead of Integer o.o
03:01:24 <srhb> Oh, there's a readMay in Safe.
03:01:38 <kallisti> james-ubyssey: addition does not type conversions
03:01:41 <kallisti> *no
03:01:55 <james-ubyssey> huh?
03:02:11 <kallisti> james-ubyssey: I must have misunderstood. What is "the sum"
03:02:15 <startling> :t (+)
03:02:16 <lambdabot> forall a. (Num a) => a -> a -> a
03:02:19 <srhb> I think there's confusion over the forall
03:02:32 <RosePerry> Why might I be getting this error? Expected type: Maybe [a]
03:02:33 <RosePerry>       Actual type: Maybe (Maybe [a])
03:02:35 <RosePerry> From this code:
03:02:43 <RosePerry> getDuplicates :: (Eq a) => [a] -> Maybe [a]
03:02:43 <RosePerry> getDuplicates (x:xs) = if (elem x xs) then Just  xs else Just $ getDuplicates xs
03:02:57 <t7> offtopic: anyone know a wiki with a built in calender ?
03:02:57 <dinges> hi there ... anyone tried to "cabal install json" recently (with ghc 6.12 or something)?
03:03:03 <mm_freak> RosePerry: because of your 'else'
03:03:03 <srhb> RosePerry: Try running it through two runs of else
03:03:12 <srhb> RosePerry: Just $ Just $ ...
03:03:14 <kallisti> RosePerry: getDuplicates (supposedly) returns a Maybe
03:03:22 <kallisti> RosePerry: and then you wrap it in a Just
03:03:35 <dinges> Compiling Text.JSON.Parsec takes ages while sucking up all memory on my machine
03:03:44 <mm_freak> dinges: i don't think json is used much nowadays…  aeson is the popular JSON library
03:03:45 <RosePerry> Why the two Just $ Just $ in a row?
03:03:55 <srhb> RosePerry: Becuase your recursive call is wrapped in a Just
03:04:04 <srhb> RosePerry: Another else gives you another Just. And another, and another
03:04:05 <Catnaroek> Hello. I need some logic tips. I am creating an application that stores a list of people on a map. I have managed to ensure that 1. the same person will not be entered twice, 2. if a person's father/mother/children are specified, then those are also valid people in the map. And now I would like to add a validation for 3. no one can be their own ancestor. Anyone can help me? Here is my code: http://hpaste.org/69992
03:04:18 <mm_freak> RosePerry: getDuplicates x :: Maybe [a]
03:04:26 <mm_freak> Just :: b -> Maybe b
03:04:36 <mm_freak> ergo:  Just (getDuplicates x) :: Maybe (Maybe [a])
03:05:39 <RosePerry> I see. It compiles if I don't use any Just before the expression in the else
03:06:07 <james-ubyssey> aigt ill see if i can fix some things :D
03:06:11 <james-ubyssey> thx
03:06:15 <dinges> mm_freak: well ... its a package required by pandoc ..
03:06:27 <dinges> mm_freak: and this is pretty troubling
03:07:50 <dinges> mm_freak: it hangs at the *** Simplifier Phase 0 [post-worker-wrapper] btw ... (dont know that that means though)
03:08:16 <mm_freak> oh, i can't help you, just wanted to point it out =)
03:08:23 <hpaste_> edwardk pasted “for cads” at http://hpaste.org/69993
03:08:30 <RosePerry> Thanks so much for the quick response, everyone!
03:08:35 <dinges> mm_freak: thank you anyway...
03:08:36 <kallisti> Catnaroek: you'll want to go through each person in the map, traverse up the mother/father pathways and test to see if any of them are equal to the original.
03:08:41 <srhb> RosePerry: Are you sure your function does what you want it to now, though?
03:08:48 <RosePerry> Ha, no
03:08:52 <dinges> anyone here who used pandoc recently then? :-)
03:08:55 <RosePerry> I'm working on it (;
03:09:17 <dinges> or has a intimate relationship with the author(s)? ;-O
03:09:32 <srhb> RosePerry: Ok, good :-)
03:09:44 <Catnaroek> kallisti: I would not need to traverse through each person down in the map as well, would I?
03:10:36 <kallisti> Catnaroek: you could attempt to do something fancy so that cover multiple people within one walk, and then skip over those people later
03:11:09 <Catnaroek> kallisti: But then I would not understand the resulting program. :(
03:11:11 <dinges> maybe I should try to contact the author...
03:11:14 <dinges> right?
03:11:29 <kallisti> Catnaroek: you could use Reader or State perhaps to simplify the logic a bit. I dunno.
03:11:46 <kallisti> you're basically accumulating a set.
03:11:53 <hpaste_> edwardk annotated “for cads” with “for cads (the "expert" category)” at http://hpaste.org/69993#a69994
03:12:26 <Catnaroek> kallisti: I do realize one easy way to solve this problem would be to require that all parents be registered in the map before their children. But there is no challenge there. :P
03:12:52 <Catnaroek> Oh, wait! That is it!
03:12:53 <hpaste_> edwardk annotated “for cads” with “for cads (the "expert" category) (annotation)” at http://hpaste.org/69993#a69995
03:13:02 <Catnaroek> :D
03:13:14 <Catnaroek> Thanks, kallisti!
03:15:18 <kallisti> Catnaroek: by accumulating a map, you can test against that map as you walk through the graph; if a node is already in the set as you're walking through the graph, then they are their own ancester. if a node is in the graph as you're traversing the map, you've already tested that node.
03:15:26 <kallisti> er, accumulating a set rather
03:17:05 <WraithM> @pl (\n m gen -> take n $ nub $ randomRs (1, m) gen)
03:17:05 <lambdabot> (. ((nub .) . randomRs . (,) 1)) . (.) . take
03:17:47 <RosePerry> Could I have some help with this function?
03:17:48 <RosePerry> getDuplicates :: (Eq a) => [a] -> Maybe [a]
03:17:48 <RosePerry> getDuplicates (x:xs) = if (elem x xs) then Just $ x : Just $ getDuplicates(filter  (\y   ->  not (x  ==  y))   xs) else (if xs == [] then Nothing else getDuplicates xs)
03:18:12 <james-ubyssey> im getting this error when i try to add types
03:18:13 <james-ubyssey>     Couldn't match expected type `Int' with actual type `Integer'
03:18:14 <james-ubyssey>     In the first argument of `daysBefore', namely `m'
03:18:14 <james-ubyssey>     In the first argument of `(+)', namely `daysBefore m'
03:18:14 <james-ubyssey>     In the expression: daysBefore m + d
03:22:10 <james-ubyssey> for some reason (m - 1 ) wants to be an integer
03:23:10 <Catnaroek> @pl flip mapM_
03:23:11 <lambdabot> flip mapM_
03:24:35 <mekeor> james-ubyssey: you can use fromInteger
03:24:35 <lambdabot> mekeor: You have 1 new message. '/msg lambdabot @messages' to read it.
03:25:16 <james-ubyssey> mekeor:  * ahh i mis typed, it wants to be an Int instead of Integer
03:25:31 <mekeor> yup
03:26:05 <fmap> RosePerry: why not getDuplicates :: Eq a => [a] -> [a]?
03:27:19 <fmap> then you simply can convert [] to Nothing and (x:xs) to Just (x:xs) if you want
03:29:50 <RosePerry> Why am I getting a "non-exhaustive" pattern error?
03:29:51 <RosePerry> getDuplicates :: (Eq a) => [a] -> [a]
03:29:51 <RosePerry> getDuplicates (x:xs) = if (elem x xs) then x : getDuplicates(filter  (\y   ->  not (x  ==  y))   xs) else (if xs == [] then [] else getDuplicates xs)
03:30:47 <kallisti> RosePerry: because you don't match the [] case
03:31:26 <RosePerry> kallisti: Thanks!! It works now
03:32:01 <Peaker> > let getDuplicates xs = xs \\ nub xs in getDuplicates [1,2,1,3,2,4,5,5]
03:32:02 <lambdabot>   [1,2,5]
03:33:49 <fmap> > let getDuplicates = (\\) <*> nub in getDuplicates [1,2,1,3,2,4,5,5]
03:33:50 <lambdabot>   [1,2,5]
03:34:04 <RosePerry> nice, thanks
03:35:38 <adamt> how do i make a type alias involving something like "data Request m"? (i'm not sure about what to do with the m part?)
03:36:41 <fmap> `type T a = D a'
03:37:32 <adamt> I feared that would be the answer, heh. Thanks though :-)
03:38:13 <kallisti> adamt: note that they partially apply as well
03:38:15 <kallisti> so in that example
03:38:17 <kallisti> type T = D
03:38:21 <kallisti> would suffice
03:40:19 <mekeor> why don't we define lists with "data List a = One a | More (List a)" such that a list always has elements? that way, "head", "tail", "last" and "init" would never cause run-time errors! if you need to be able to return empty list, just "Maybe List" instead then.
03:42:10 <Ralith> habit?
03:42:18 <kallisti> mekeor: there's a type for that called Stream
03:42:26 <kallisti> it's around Hackage in various libs.
03:42:38 <kallisti> oh wait
03:42:46 <kallisti> no it's usually called NonEmpty or something like that.
03:42:55 <kallisti> Stream is the infinite list (no [])
03:42:58 <mekeor> ah, cool.
03:43:08 <mekeor> kallisti: ah :)
03:43:51 <mekeor> kallisti: is it http://hackage.haskell.org/packages/archive/semigroups/latest/doc/html/Data-List-NonEmpty.html ?
03:44:08 <mekeor> doesn't seem so…
03:44:19 <mekeor> kallisti: did you mix up nonempty and stream? :)
03:44:36 <mekeor> hmm… no.
03:44:43 <kallisti> at first.
03:44:44 <mekeor> aah!
03:44:46 <mekeor> okay.
03:44:46 <kallisti> but then I corrected myself.
03:45:02 <mekeor> yea, i got it. now undestand the definition of Data.List.NonEmpty.
03:45:21 <mekeor> it uses list…
03:45:41 <mekeor> kallisti: cool, thanks :)
03:49:30 <fmap> wow, a documented package from edwardk
03:49:43 <edwardk> which one?
03:49:51 <fmap> semigroups
03:49:52 <edwardk> i thought i'd managed to eradicate all of my documentation
03:49:55 <edwardk> i must have missed one
03:49:56 <edwardk> ah
03:50:36 <HugoDaniel> :D
03:51:16 <HugoDaniel> (<$>) (<$>) is now my official favourite haskell combo
03:51:36 <HugoDaniel> im not really sure how it can be used, but it reminds me of two eyes with $ in them
03:52:16 <edwardk> well, (<$>).(<$>) is useful
03:52:17 <srhb> HugoDaniel: Isn't ($) ($) better in that regard?
03:52:29 <edwardk> :t (<$>).(<$>)
03:52:30 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
03:52:53 <edwardk> that way you get a nose
03:53:17 <srhb> A criterion by which all serious code is measured, obviously.
03:53:34 <KSkrzet> can I make a requirement for associated type synonym so that it implements specific typeclass? Like Traversable or such.
03:53:56 <kallisti> > (:[])>=>(:[])>=>(:[])  -- a favorite of mine. the totem pole.
03:53:56 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> [b])
03:53:57 <lambdabot>    arising from a use of...
03:55:00 <HugoDaniel> :D
03:55:19 <HugoDaniel> <$> -> money changes evenrything operator
03:55:26 <HugoDaniel> *everything
03:55:32 <fmap> KSkrzet: type synonym is just an alias
03:55:36 <kallisti> fix ((:[])>=>)  -- not to be out-played by the infinite totem pole.
03:58:05 <hpc> :t fix ((:[])>=>)
03:58:06 <lambdabot> forall b c. b -> [c]
03:58:21 <hpc> > fix ((:[])>=>) True
03:58:23 <lambdabot>   *Exception: stack overflow
04:00:19 <kallisti> hpc: the infinite totem pole is mostly about style over substance.
04:02:30 <KSkrzet> fmap: what should I use then?
04:03:40 <fmap> KSkrzet: that depends on what are you trying to do
04:05:07 <KSkrzet> fmap: I want to let the user of the typeclass specify return types of several functions, but I want that type to implement another typeclass for all cases
04:05:19 <hpaste_> ion pasted “Well, this will be fun to debug” at http://hpaste.org/69996
04:05:49 <ion> test-framework-th’s code doesn’t seem to call head directly anywhere.
04:10:16 <fmap> KSkrzet: class Constraint a ⇒ C a where t ∷ a
04:10:17 <fmap> ?
04:11:58 <fmap> then `a' should implement `Constraint' for every `C a' instance
04:12:48 <fmap> (misplaced every)
04:22:49 <illissius> it's so evil that you can generate haddock documentation with CPP macros :-}
04:24:11 <hpc> honestly, it's less evil than generating code
04:25:55 <james-ubyssey> what sorcery is this
04:27:04 <fmap> i wish it could be possible with TH
04:34:12 <KSkrzet> fmap: yes, except I cant express constraints in the head of the typeclass
04:34:40 <KSkrzet> fmap: because you dont have the type synonyms defined below there
04:34:50 <KSkrzet> fmap: or maybe you do?
04:36:04 <fmap> i don't think i get how type synonyms are related
04:38:15 <fmap> KSkrzet: you can paste something you think should work and what error you get instead
04:38:18 <fmap> @where hpaste
04:38:18 <lambdabot> http://hpaste.org/
04:39:49 <hpaste_> james-ubyssey pasted “why Int?” at http://hpaste.org/69997
04:40:32 <james-ubyssey> hey guys, im having trouble understanding why calc day and dsysb4 want to have Int as arguments for month
04:40:40 <james-ubyssey> instead of something more generic
04:40:41 <lio> hi
04:40:54 <james-ubyssey> could someone explain?
04:41:15 <mekeor> hi lio :)
04:41:16 <KSkrzet> james-ubyssey: what library are you talking about?
04:41:34 <fmap> :t take
04:41:36 <lambdabot> forall a. Int -> [a] -> [a]
04:41:41 <fmap> james-ubyssey: ^
04:42:09 <fmap> :t genericTake
04:42:10 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
04:42:27 <james-ubyssey> in the thing i pasted
04:42:28 <lio> im coming from an imperative background: lots of python and java. now im interested in haskell. but after visiting your website i grew weary. it appears that haskell has a primarily scientific appeal. what can i do with the language as a small habby programmer ?
04:43:02 <lio> my question is: has haskell the same "hacking factor" of python ? is it productive for small hobby projects ?
04:43:11 <fmap> james-ubyssey: `take` takes Int as its first parameter, then `(m - 1)` should be Int, then `m` should be Int
04:43:13 <KSkrzet> lio: it is very productive, yes.
04:43:42 <james-ubyssey> fmap dayum, isthere any way around that?
04:43:43 <lio> can i use it for the same projects as python ? or are there limitations from the functional paradigm
04:43:55 <fmap> james-ubyssey: yes, `genericTake` from Data.List
04:43:58 <KSkrzet> lio: indeed if you see Hackage, there are many small projects uploaded there. http://hackage.haskell.org/package/
04:44:30 <james-ubyssey> cool thanks :D
04:44:57 <james-ubyssey> im curious though, why is it so partial to Int?
04:45:03 <teneen> In which case will OverlappingInstances not  be able to choose an instance? given that one of the instances is more specific than the others
04:45:46 <james-ubyssey> is it because of some historical mess up /comparability issues ?
04:45:51 <KSkrzet> lio: that usually boils down to: "are there libraries for the thing I need?". the collection of libraries on Hackages is growing rapidly so most common needs are already served.
04:45:58 <ion> lio: Haskell is a general-purpose language with no emphasis in science in the syntax or the standard library.
04:46:33 <ion> lio: There are plenty of libraries for all kinds of things you might want to do.
04:47:08 <fmap> james-ubyssey: this and i don't think one would want to `take' more elements than `maxBound ∷ Int' often
04:47:09 <lio> ive already looked at hackage. its hard to deduce anything from a list of projects but the one impression i has was that haskell is great for complicated projects. the list of applications in bioinformatics is very long, but ill probably never contribute to it. its hard to convey my meaning: lets say i have to write a little game such as tetris. can i say "hm, today im picking haskell" without having any functional troubles ?
04:47:15 <mekeor> lio: it's really fun to program in haskell. but especially, it's fun to *learn* haskell =)
04:47:37 <mekeor> lio: also, the community is great and there's a there are cool, free online books.
04:48:33 <lio> ion: general-purpose language sounds cool but how general is it ? are there any limitations from the functional paradigm ?
04:49:20 <mekeor> lio: no. haskell is as well a imperative language.
04:49:21 <ion> lio: Implementing a game of Tetris along the learning of the language sounds fine.
04:49:23 <KSkrzet> lio: no limitations in what you can achieve. you just do it differently, some paths are more natural.
04:49:49 <ion> lio: Haskell’s IO is a better imperative language than most other imperative languages IMO.
04:49:58 <james-ubyssey> lio:  from one beginner to another, it's definately a fun language, theres a thing on hackage called gloss that i've been mucking around with a little
04:50:12 <james-ubyssey> lio:  you can make games with that prett yeasy
04:50:17 <lio> KSkrzet: i guess the idea of "paths that are more natural" hits the point.
04:50:30 <lio> ion: that sounds good
04:50:58 <KSkrzet> lio: you can write very nice imperative programs in Haskell. then you notice you can abstract few things and make it even prettier. you end up with idiomatic Haskell program that is much better than the original - which you were very fond of in the beginning.
04:51:05 <lio> james-ubyssey: the game was just an example but thanks for the package name
04:51:18 <fmap> lio: besides you can always use haskell as imperative language
04:51:30 <lio> KSkrzet: that is exactly what i wanted to hear ;)
04:51:31 <fmap> perhaps the best imperative language so far
04:51:49 <ion> IO actions being first-class objects lets you e.g. create a list of print "foo"s, pick the element number 3 and only have that executed.
04:52:04 <hpc> the best part of using haskell as an imperative language is being able to occasionally write new control flow statements
04:52:04 <james-ubyssey> lio: there are some really *diffrent* ideas you need to get used to, stuff monads and pattern matching can be a complete mindfuck at first
04:52:08 <hpc> "statements"
04:52:13 <lio> ion: wow, as a matter of fact i always wanted something like that
04:53:09 <james-ubyssey> lio:  but i'd also say  haskell isnt any much harder than python
04:53:10 <KSkrzet> lio: I'm glad to hear that :-)
04:53:19 <ion> % ghc -e '[ print "foo", print "bar", print "baz"] !! 2'
04:53:19 <ion> "baz"
04:53:51 <lio> james-ubyssey: well after my hatred with java became unbearable i wrapped my head around scala. this is what leads me here. i loved the functional aspects but couldnt imagine scala without object-orientation. scalas match clauses were my favorite syntax feature
04:53:54 <programm1r> Good time!
04:54:19 * hpc has been meaning to learn scala
04:54:43 <ion> lio: http://learnyouahaskell.com/
04:54:59 <lio> hpc: do yourself a favour and try it. youll marvel at the elegance. unfortunately scala is so powerful that many frameworks use too much "magic"
04:55:15 <lio> take a look at the play framework and youll know what i mean
04:55:35 <hpc> lio: sounds like perl with more OO and FP
04:55:45 <lio> ion: thanks for the link
04:55:51 <lio> hpc: i never tried perl
04:55:58 <hpc> you'd love it
04:56:34 <hpc> it's juuuust strongly-typed enough to prevent the most stupid mistakes
04:56:45 <lio> hpc: if i had to summarize scala id say its: Java only without the ugliness plus FP
04:56:55 <hpc> and it has ridiculous lambda magic
04:58:02 <lio> thanks to you all for the great responses. ill definitely give haskell a try.
04:58:07 <lio> got to go now
04:59:34 <hpc> lio: http://hpaste.org/69998 -- my most favorite perl function ever
05:00:32 <ion> hpc: Why “&callback” in Perl 4 style?
05:00:53 <programm1r> Who is the course? Are there any haskell module for BCD-numbers?
05:01:07 <Gx4> I am the captain of this ship!
05:01:16 <hpc> ion: it makes the function blue in vim
05:01:29 <hpc> and habit, i suppose
05:01:31 <kallisti> it's also semantically different
05:01:45 <hpc> it's only semantically different when you don't pass arguments
05:01:50 <kallisti> right.
05:01:54 <hpc> which is a horrible practice and should never be done
05:02:08 <Gx4> never say never
05:02:11 <gienah> programm1r: there is Decimal on hackage
05:02:17 <hpc> unless you use it to write perl -p -e "sed scripts", i suppose
05:02:17 * kallisti commented before looking at how the & was used. :P
05:02:41 <ion> “It makes the function blue in Vim” is an awesome response to any question about why you do things a certain way.
05:03:24 <hpc> actually, let me elaborate on that
05:03:28 <programm1r> gienah: Is this BCD-numbers?
05:03:38 <hpc> it makes the function the same blue color as $scalars, @arrays, %hashes
05:03:48 <hpc> rather than being white like GLOBs
05:03:53 <Gx4>    i think you can customize colors
05:04:13 <gienah> programm1r: I'm not sure, but it has decimal arithmetic
05:04:17 <hpc> it helps me see at a glance that i am not doing anything ridiculous with globs when i should use file handles
05:04:49 <kallisti> I literally never see globs in modern perl 5 code.
05:05:05 <hpc> i have seen them a couple of times, i think
05:05:35 <unnali> can you avoid them when you want to talk about, e.g. *STDOUT?
05:05:52 <ion> Back when i used Perl, i never had the problem of accidentally using globs.
05:05:56 <hpc> \*STDOUT
05:06:07 <hpc> gives you a $ref
05:06:16 <kallisti> pretty sure you just called it STDOUT
05:06:23 <kallisti> *call
05:06:26 <unnali> kallisti: doesn't always work if you're wanting a ref/thing
05:06:34 <unnali> $blah->(*STDOUT)
05:06:46 <kallisti> people do that?
05:06:59 <unnali> intsead of?
05:07:11 <kallisti> instead of... not doing that.
05:07:12 <hpc> using IO::File
05:07:21 * unnali does, apparently <_<
05:07:25 <hpc> using \*STDOUT (or however you say it)
05:08:13 <ozgura> Hi! I have a data type like this: data Tree a = Branch String [Tree a] | Leaf a. I am using the String in Branch as a label so there will be lots of equality checks on it. Question: which IsString type provides fastest equality checks? String, Text or ByteString?
05:08:51 <scopedTV> not String
05:08:54 <hpc> equality checks aren't going to be your bottleneck
05:08:57 <unnali> ozgura:
05:08:58 <unnali> what hpc said.
05:09:02 <kallisti> asymptotically they're all the same. I'd wager either Text or ByteString depending on what month it is.
05:09:07 <hpc> use Text or ByteString, but don't pick one arbitrarily
05:09:11 <hpc> if your data is text, use Text
05:09:16 <hpc> if it's bytes, use ByteString
05:09:34 <unnali> use whatever makes `sense' for the data type, don't prematurely optimise unless you have good reason to believe that this thing is slowing you down.
05:09:39 <ion> Yeah. Text is akin to [Char] and ByteString is akin to [Word8]. Completely different purposes.
05:10:01 <unnali> even if it was the string comparison, you may find there's a better solution (e.g. calculating a hash of the string at creation time and comparing those instead).
05:10:03 <ozgura> I am using Text now. Just wanted to see if there was some common knowledge on this.
05:10:34 <ozgura> Text for now then. Thanks.
05:10:49 <hpc> also, if you know you won't have a lot of labels, and can determine all of them at compile-time
05:10:55 <hpc> data Label = L1 | L2 | ...
05:11:51 <ozgura> yes I used to have something like than. but then I had introduce a "OtherL Text"
05:12:10 <hpc> ah
05:12:15 <ozgura> and I don't like that because it takes away the nice uniformity
05:12:30 <ozgura> I still know a few at compile time
05:12:32 <ozgura> we'll see
05:13:06 <ozgura> wow, I can't type today.
05:13:30 <hpc> just dictate code to your phone
05:13:34 <hpc> what could possibly go wrong!
05:13:48 <scopedTV> There is a type system, right? =)
05:14:21 <kallisti> #haskell: a comedy goldmine
05:14:38 <kallisti> you'll laugh. you'll cry.
05:14:48 <hpc> mostly though, all you'll find is dirt
05:14:54 <hpc> :D
05:18:42 <taylorgb_> dirt at the type level though
05:32:44 <teneen> In which case will OverlappingInstances not be able to choose an instance? specially that one of the instances is more specific than the others
05:35:27 <yields_> Hello, i'm new here, i have a question.
05:35:42 <srhb> yields_: Ask. :)
05:35:53 <scopedTV> teneen: I can't think of a counterexample, but the problem with OI is that the instance might not be the one that you expect.
05:35:57 <yields_> how difficult it is for a guy that came from node.js to understand haskell.
05:36:09 <srhb> yields_: 7.
05:36:09 <unnali> yields_: why not? :)
05:36:23 <S11001001> succ srhb
05:36:38 <yields_> unnali, what do you mean by "why not" ?
05:36:39 <unnali> fix S11001001
05:36:53 <srhb> yields_: tryhaskell.org
05:36:55 <unnali> yields_: sorry, I maen, why would it be difficult? Or even, why would it be more difficult than any other person?
05:36:59 <scopedTV> yields_: We can't tell in your specific case. In general, I'd say it's not easiser or harder than for anybody else necessarily.
05:37:04 <S11001001> ≠ ⊥
05:37:27 <srhb> yields_: Really you can get the basics done in a few hours, after that it will be much easier for yourself to judge how hard it is for _you_ specifically.
05:37:43 <srhb> yields_: You should just go for it and see if you like it. We'll be here when you have questions, which should make things a lot easier. :)
05:37:58 <yields_> no i mean, for a guy that knows concurrency through callbacks.
05:38:28 <S11001001> > const 42 ⊥
05:38:29 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:38:39 <ion> You’ll find Haskell’s style of concurrency refreshing.
05:38:45 <unnali> > const 42 undefined
05:38:46 <lambdabot>   42
05:39:03 <ion> No more manual typing of CPS boilerplate.
05:39:21 <unnali> yields_: you can get a similar performance model without nesting callbacks.
05:39:42 <mikeplus64> yields_: [using] haskell concurrency is pretty simple, you fork IO actions by forkIO ..., send and receive messages through MVars or Chans
05:39:54 <ion> Well, Haskell can also run the code on multiple cores.
05:40:18 <ion> And you don’t have to be careful about blocking operations.
05:40:27 <mikeplus64> does node.js not have multi threaded concurrency?
05:40:42 <vishesh> `0    , className =? "Dialog" --> doFloat
05:40:49 <scopedTV> No, it does not, I think.
05:40:56 <mikeplus64> scopedTV: that's a scary thought
05:40:58 <unnali> mikeplus64: no, but later versions do have support for forking processes and communicating.
05:41:01 <vishesh> Oops.
05:41:27 <scopedTV> mikeplus64: not necessarily. node.js is useful for certain things, I'm sure, it's just not suitable for long computations.
05:41:27 <nand`> I have the feeling I finally properly understood categories
05:41:33 <scopedTV> although I'd never write JS if I can avoid it.
05:41:36 <srhb> nand`: You're probably wrong.
05:41:37 <srhb> <_<
05:41:43 <unnali> rofl
05:41:49 <yields_> sounds good, what resources do you guys recomment ?
05:41:53 <nand`> srhb: probably. Note the deliberate usage of “I have the feeling”
05:41:59 <srhb> yields_: learn you a haskell. :-)
05:42:02 <ion> @where lyah
05:42:02 <lambdabot> http://www.learnyouahaskell.com/
05:42:10 <mikeplus64> yields_: hoogle, rwh
05:42:12 <mikeplus64> @where hoogle
05:42:13 <lambdabot> http://haskell.org/hoogle
05:42:16 <mikeplus64> @where rhw
05:42:16 <lambdabot> I know nothing about rhw.
05:42:19 <mikeplus64> @where rwh
05:42:19 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:42:22 <srhb> nand`: Yes, and I was projecting. O:-)
05:42:31 <scopedTV> definitely LYAH, not RWH as a beginner's introduction.
05:42:31 <vishesh> I was trying to float the dialog boxes that show up in firefox. "className =? "Dialog" --> doFloat" doesnt seem to work even when I can see "Dialog" in the WM_CLASS string by xprop. AM I doing something wrong or missing something?
05:42:42 <nand`> here's my current intuition: categories are just like monoids, except every element a type that says what it can be composed with; ie. the composition is not a total function like it is for monoids
05:42:45 <scopedTV> Although RWH is excellent, it's better for somewhat more advanced programmers.
05:42:51 <nand`> every element has a type*
05:43:06 <mikeplus64> vishesh: which dialogue boxes?
05:43:29 <scopedTV> nand`: right, a monoid is just a category on one object
05:43:32 <nand`> this also makes the analogy of monoids as one-object categories transparent: since there's only one possible type, everything can be composed with itself and thus defines a monoid
05:43:37 <scopedTV> which would be "the universal type"
05:43:41 <nand`> :)
05:43:43 <mikeplus64> vishesh: checking now i think you want appName =? "Dialog"
05:43:45 <vishesh> mikeplus64: "Lauch Application", "About Firefox"
05:44:07 <nand`> it also makes the correlation between semigroups and semigroupoids; groups and groupoids painfully obvious
05:44:21 <nand`> (and monoids and categories to fill the gap)
05:44:30 <yields_> i'm trying haskell in tryhaskell.org and it seems that numbers, strings, and lists are not objects, so you don't do "yields".sort but sort "yields"
05:44:41 <yields_> so there are no objects in haskell ?
05:44:46 <srhb> yields_: Not in an OOP sense.
05:44:46 <scopedTV> yields_: correct. the . means something else entirely
05:44:47 <mikeplus64> vishesh: and maybe appName =? "Browser" or title =? "About Mozilla Firefox"
05:44:55 <scopedTV> yields_: Yes, not in the sense that you are used to.
05:45:01 <nand`> “object” has no clearly defined meaning in Haskell
05:45:05 <ion> Haskell is not an OOP language, yes.
05:45:08 <nand`> you have values, and types
05:45:20 <nand`> (and lots of other nice things)
05:45:25 <scopedTV> no subtyping
05:45:59 <vishesh> mikeplus64: Yeah, seems like appName worked. What appName is for btw?
05:46:06 <mikeplus64> yields_: in haskell instead of accessing a function from an object, you use a function that works across different types, for sort, you want 'sort' from Data.List
05:46:31 <mikeplus64> vishesh: WM_CLASS
05:46:37 <nand`> also, Haskell has no concept of “methods”; functions don't belong to a certain type, they exist globally so to say (or at least within the module)
05:47:05 <scopedTV> . is composition, not "record accession" or something like that
05:47:07 <vishesh> mikeplus64: ok. and className?
05:47:24 <scopedTV> I'm sure LYAH makes that clear :)
05:47:27 <nand`> scopedTV: except when accessing sub-modules, but w/e :P
05:47:39 <scopedTV> Yeah. :)
05:47:44 * scopedTV wants namespacing :(
05:47:52 <scopedTV> *inside* a module
05:47:56 <nand`> scopedTV: “namespacing”? What do you mean?
05:48:03 <srhb> Does the Haskell platform now contain GHC 7.4.2 or do I have to upgrade that manually?
05:48:13 <scopedTV> so module X { namespace Y { ... }; {- use Y.f here -} }
05:48:29 <mikeplus64> vishesh: the second WM_CLASS thingo (look at xprop something, it'll return like "Navigator", "Firefox", the "Firefox" is the className afaik
05:48:42 <S11001001> srhb: I got 7.4.1 when I installed 2012.2
05:49:09 <srhb> S11001001: Yeah me too, I was just wondering whether it would secretly be updated with the bugfixed GHCs, or if it will have to wait until the next Platform release.
05:49:14 <scopedTV> the whole record system is pretty bad
05:49:14 <nand`> srhb: so how wrong am I in my understanding of categories? :P
05:49:44 <nand`> scopedTV: it can come in handy
05:49:45 <srhb> nand`: Don't ask me, my experience is that I don't understand categories, and I was just projecting that experience unto you. Sorry. :P
05:49:49 <nand`> oh
05:49:50 <srhb> nand`: It sounded very fancy!
05:49:51 <nand`> I see
05:50:13 <mikeplus64> scopedTV: records are ugly but still pretty awesome at times (record pattern matching for instance is nice)
05:50:31 <scopedTV> yes, i use them all the time of course.
05:50:39 <scopedTV> but they can be improved D:
05:50:41 <S11001001> would be nice if they gave you lenses instead of just half-lenses
05:50:42 <nand`> (it helps breaking away from the “arrows = functions” fallacy, mind; one could just as well write morphism types as tuples eg. f : (A,B) instead of f : A -> B)
05:50:52 <mikeplus64>  my only quible is naming of record accessors :(
05:51:46 <mikeplus64> if there was some magical global typeclass keeping track of record accessors it would be nice
05:52:01 <mikeplus64> i mean field accessors
05:52:31 <S11001001> I doubt it
05:53:13 <yields_> how fun is it to write haskell program? i don't know about you guys but "fun" is what i'm in to
05:53:19 <nand`> know what would be nice for record field accessors? being able to qualify them as RecordType.fieldName <- more notation that sort of looks like OOP to confuse the newcomers, obviously
05:53:23 <mikeplus64> yields_: very!
05:53:24 <nand`> yields_: very
05:53:30 <S11001001> yields_: you can program pointlessly in haskell, it's awesome
05:53:47 <vishesh> Damn, I just realized I was positing xmonad query on haskell channel!
05:53:55 <srhb> yields_: Most fun I've had programming is with Haskell. It's pretty amazing.
05:54:22 <jaxtr> ahh it's a wonderful day
05:54:27 <ion> yields: Haskell is certainly fun.
05:54:38 <nand`> S11001001: yeah, just too bad there's this stupid bot that does it faster than you; spoils the fun of golfing
05:54:40 <yields_> srhb: what languages you used ?
05:54:56 <S11001001> nand`: fortunately it misses useful combinators, so you can do a better job with it
05:55:30 <nand`> obviously. Its knowledge of Caleskell is fairly limited as well; which comes in handy when showing off code on #haskell (is there any other reason?)
05:55:31 <srhb> yields_: Before Haskell, mostly Java, JS, (god save me) PHP, and some Lisps
05:56:08 <ion> Yay! “Fixed bug (#5836) where GHCi would silently accept an import statement for a non-existing module.”
05:56:29 <nand`> ion: I never realized that was a bug, just an annoyance
05:57:44 <yields_> so from what i understand haskell is about cuncurrency just as much as nodejs
05:58:00 <srhb> yields_: Haskell has excellent facilities for concurrency, no doubt about that.
05:58:00 <nand`> nodejs isn't about concurrency. It just pretends to be
05:58:04 <nand`> from my experience
05:58:10 <srhb> Whether node.js has.. WEll, yeah, what nand` said :P
05:58:25 <nand`> yields_: have you ever used Go?
05:58:26 <bitonic> nodejs is not concurrent by design
05:58:40 <vishesh> I though nodejs was about non-blocking ops
05:59:08 <mikeplus64> http://codepad.org/7Km6P2pT if someone wants some overly pointless magic that i whipped up a few days ago :)
05:59:08 <yields_> used it a bit, i didn't like the naming conventions and the ugly c++ syntax
05:59:40 <mikeplus64> (a little parser that splits up stuff based on indentation
05:59:41 <nand`> yields_: just mentioning it because I think it provides a good comparison; I quote “Haskell threads are goroutines on steroids”
05:59:42 <mikeplus64> )
06:00:12 <srhb> yields_: If you care about syntax, Haskell will make you cry tears of joy. :-)
06:01:12 <ski> (isn't NodeJS cooperative concurrency of some sort ?)
06:01:43 <srhb> yields_: I'm relatively new to Haskell, and I made a snake game recently. My main "loop" runs this code: moreCheese . eat . die . move $ world -- it just makes me so happy. :-)
06:01:53 <nand`> Haskell is also very nice if you care about consistency. Very, very few things are “magic” in Haskell; at least not in that sense - they're implemented using the stock Haskell type system / features
06:02:45 <bn291697> how can I get source of Control.Applicative?
06:03:02 <nand`> step 1: search hoogle
06:03:07 <ion> Hoogle Applicative, open the documentation, click on Source.
06:03:08 <nand`> step 2: click on the “Source” at the top
06:03:08 <mikeplus64> bn291697: look at the hackage page, click source
06:03:15 <niteria> thanks
06:03:16 <nand`> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Applicative.html
06:03:17 <mikeplus64> ion: nand`: pzap
06:03:46 <yields_> before trying haskell, i tried Luvit Luajit, the syntax is awesome, lua is very similiar to javascript, and it's faster than node, what drove me away is that instead of using coroutines that guys from Luvit used callbacks.
06:04:09 <ion> pzap?
06:04:34 <nand`> callbacks? are those basically primitive continuations or what? <- /me doesn't know much about callbacks *or* continuations
06:05:06 <S11001001> huh, fmap continues to type no matter how many of them you chain together
06:05:12 <S11001001> > fmap fmap fmap fmap fmap
06:05:13 <lambdabot>   Overlapping instances for GHC.Show.Show
06:05:13 <lambdabot>                              ((a ->...
06:05:17 <S11001001> oh whatever
06:05:22 <S11001001> :t fmap fmap fmap fmap fmap
06:05:23 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
06:05:31 <nand`> S11001001: yeah, and every nonzero multiple of 6 fmaps have the same type again
06:05:53 <nand`> but the memory/time complexity is exponential
06:06:33 <S11001001> nand`: neat
06:16:05 <nand`> scopedTV: the comparison to a monoid is good for another reason; it shows that a functor follows basically the exact rules that a monoid homomorphism does: F(e) = e; F(f×g) = F(f)×F(g) except that e=1 and ×=.
06:17:24 <scopedTV> nand`: Sure, that's another reason.
06:31:45 * Gx4 inserts a coin into EvilMachine
06:35:02 <mparodi> @hoogle Int -> Char
06:35:02 <lambdabot> Data.Char chr :: Int -> Char
06:35:03 <lambdabot> Data.Char intToDigit :: Int -> Char
06:35:03 <lambdabot> Data.Text index :: Text -> Int -> Char
06:36:46 <mparodi> is there a print function to do something like: print ["Foo ", bar, ": ", 123]?
06:37:20 <srhb> mparodi: That list does not type.
06:37:22 <mparodi> if bar = 'a' it should print:         Foo a: 123\n
06:37:46 <srhb> mparodi: Lists are always homogenous, so that is not possible.
06:37:47 <mparodi> err, I'm sorry, I meant a tuple
06:37:53 <nand`> you can use printf
06:37:55 <nand`> maybe
06:37:56 <mparodi> print ("Foo ", bar, ": ", 123)
06:38:12 <mparodi> @hoogle printf
06:38:13 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
06:38:13 <lambdabot> Text.Printf class PrintfArg a
06:38:13 <lambdabot> Text.Printf class PrintfType t
06:38:16 <nand`> mparodi: such a function, while it could exist; would not be very useful since it would be limited to exactly 4 arguments, no more no less
06:38:40 <mparodi> right
06:39:01 <mparodi> how do you print arbitrary variables with different types?
06:39:07 <srhb> mparodi: Better to make your own type and a relevant prettyprinter. :)
06:39:20 <nand`> printf however does some fancy thing where it accepts as many arguments as you want to provide it
06:39:34 <nand`> and throws runtime exceptions if they don't match the format
06:39:46 <ski> > let foo = 'a'; bar = 123 in printf "Foo %c: %d" foo bar :: String
06:39:47 <lambdabot>   "Foo a: 123"
06:39:50 <nand`> it's just for easy formatting / quick and dirty coding though, I would proclaim
06:39:59 <mparodi> oh, nice
06:40:13 <srhb> mparodi: Don't give in! :P
06:40:16 <ski> mparodi : you can use `IO ()' instead of `String' to send it to `stdout', i think
06:40:49 <mparodi> ok, that was part of the issue
06:41:16 <mparodi> the other part is that I need to print something (these variables) and then execute a function
06:41:18 <ski> (and of course, in many cases the explicit type ascription would not be necessary)
06:41:26 <nand`> you don't execute functions
06:41:27 <mparodi> like in trace (printf ... :: String) foo
06:41:32 <mparodi> is it a good idea to use trace?
06:41:33 <srhb> >>
06:41:34 <srhb> no
06:41:38 <nand`> for debugging
06:41:42 <nand`> that's about it
06:41:49 <ski> `trace' is only for debugging purposes
06:41:49 <mparodi> it's not debugging, the program needs to print that
06:41:52 <mparodi> ok
06:41:58 <ski> then you should not use `trace' for that
06:42:10 <srhb> > putStr "Foo" >> bar where bar = putStr "bar"
06:42:11 <lambdabot>   <no location info>: parse error on input `where'
06:42:14 <srhb> erghl
06:42:41 <ski> > case () of () -> putStr "Foo" >> bar where bar = putStr "bar"
06:42:42 <srhb> > let bar = putStr "bar" in putStr "Foo" >> bar
06:42:43 <ski> better ?
06:42:43 <lambdabot>   <IO ()>
06:42:43 <lambdabot>   can't find file: L.hs
06:42:49 * srhb cries
06:43:11 <mparodi> > putStr "Foo" >> bar where bar = 123
06:43:12 <lambdabot>   <no location info>: parse error on input `where'
06:43:15 <mparodi> it's more like that ^
06:43:24 <mparodi> > let foo = putStr "Foo" >> bar where bar = 123
06:43:25 <lambdabot>   not an expression: `let foo = putStr "Foo" >> bar where bar = 123'
06:43:38 <srhb> in foo.. :-)
06:43:50 <S11001001> :t ($>)
06:43:51 <lambdabot> Not in scope: `$>'
06:44:03 <mparodi> srhb, ?
06:44:12 <nand`> I don't think IO a has a num instance
06:44:36 <nand`> who knows, maybe some funny joker provided it (return . fromInteger)
06:44:38 <mparodi> the idea is.. print something, return something else (of type Whatever)
06:45:10 <nand`> mparodi: then you need to use ‘return’ in your example
06:45:13 <srhb> mparodi: putStr "foo" >> return bar
06:45:21 <mparodi> @type return
06:45:22 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:45:26 <mparodi> o.o
06:45:27 <srhb> To lift bar into the relevant monad, here IO
06:45:39 <mparodi> @src return
06:45:40 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:45:43 <mparodi> >_>
06:45:57 <nand`> return doesn't have a clearly defined body
06:45:59 <nand`> it depends on the monad
06:46:00 <mparodi> > putStr "Foo" >> return bar where bar = 123
06:46:01 <lambdabot>   <no location info>: parse error on input `where'
06:46:06 <mparodi> > putStr "Foo" >> return 123
06:46:07 <lambdabot>   <IO Integer>
06:46:22 <srhb> > Just 3 >> return 5
06:46:23 <lambdabot>   Just 5
06:46:37 <ski> > [2,3,4] >> return 5
06:46:38 <lambdabot>   [5,5,5]
06:46:51 <nand`> > ("hello", "world") >> return 5
06:46:52 <lambdabot>   No instance for (GHC.Base.Monad ((,) [GHC.Types.Char]))
06:46:52 <lambdabot>    arising from a u...
06:47:01 <nand`> oh, it isn't a monad
06:47:07 <mparodi> > let foo x = putStr "Foo" >> return bar x where bar x = x+1 in foo 123
06:47:11 <lambdabot>   Couldn't match expected type `GHC.Types.IO b'
06:47:13 <lambdabot>         against inferred type...
06:47:18 <mparodi> what on Earth?
06:47:20 <ski> nand` : well it is, but it's apparently not in scope in lambdabot
06:47:29 <fmap> > ((+1) >> return 3) 5
06:47:30 <lambdabot>   3
06:47:30 <nand`> mparodi: precedence error, return (bar x)
06:47:50 <nand`> > ((+1) >> 3) 5
06:47:51 <lambdabot>   3
06:47:59 <mparodi> how do you deduce a "precedence error" from an error message like that? xD
06:48:03 <mparodi> > let foo x = putStr "Foo" >> return (bar x) where bar x = x+1 in foo 123
06:48:04 <lambdabot>   <IO Integer>
06:48:11 <ski> nand` : `instance Monoid w => Monad (w,)' -- this is basically `Writer w'
06:48:25 <srhb> mparodi: Because return only takes one argument :-)
06:48:36 <mparodi> the point is, it's not doing what it should
06:48:43 <srhb> mparodi: Really?
06:48:46 <ski> > return 2 3
06:48:47 <lambdabot>   2
06:48:48 <mparodi> well, I don't think so
06:49:01 <mparodi> let foo x = putStr "Foo" >> return (bar x) where bar x = x+1 in foo 123
06:49:06 <mparodi> should print "foo" and return 123
06:49:12 <srhb> mparodi: It does.
06:49:13 <mparodi> actually 124
06:49:15 <srhb> Yeah
06:49:18 <ion> > return (+1) "o hai" 42
06:49:20 <lambdabot>   43
06:49:27 <ski> mparodi : it does, when you *execute* the resulting `IO'-action
06:49:44 <ski> mparodi : note that lambdabot doesn't execute `IO'-actions
06:49:47 <ski> @help run
06:49:48 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
06:49:49 <mparodi> ahh, that's how lambdabot tell you there was a IO
06:50:05 <mparodi> alright :)
06:50:18 <srhb> mparodi: But you can just play around with other monads to see the behaviour you want.
06:50:30 <mparodi> no, it's ok
06:50:36 <srhb> :)
06:50:40 <jelly1> hi
06:50:44 <mparodi> thanks
06:50:45 <mparodi> @type let foo x = putStr "Foo" >> return (bar x) where bar x = x+1 in foo 123
06:50:46 <lambdabot> forall t. (Num t) => IO t
06:50:55 <jelly1> does runhaskell have something like make check ?
06:51:00 <srhb> mparodi: This might be easier to do in do-syntax, by the way. The last line will be the return value
06:51:16 <srhb> mparodi: So you can have print on one line and then return 123 on the last
06:51:38 <mparodi> hmn, let me check the syntax
06:52:08 <srhb> > do putStr "123"; return 123
06:52:08 <ski> @type let foo x = do putStr "Foo"; return (bar x) where bar x = x+1 in foo
06:52:09 <lambdabot>   <IO Integer>
06:52:09 <lambdabot> forall a. (Num a) => a -> IO a
06:52:23 <mparodi> > let foo x = do putStr "Foo"; return (bar x) where bar x = x+1 in foo 123
06:52:24 <lambdabot>   <IO Integer>
06:52:38 <mparodi> isn't it the same?
06:52:42 <srhb> mparodi: Yes. :)
06:52:43 <ski> of course
06:52:52 <ski> it's just another way to write the same thing
06:53:04 <fmap> jelly1: what is `make check'?
06:53:17 <jelly1> unit tests
06:53:19 <ski> (the `do'-syntax is just sugar for the previous version)
06:53:24 <srhb> mparodi: Once you start to chain more than one pair of >> or >>=, you'll be happy with do, probably. ;)
06:53:44 <jelly1> fmap: ah its runhaskell test
06:53:47 <jelly1>   test          Run the test suite, if any (configure with UserHooks).
06:54:12 * ski notes that large parts of GHC was written with `>>' and `>>=' (or maybe they were named `thenIO' and `bindIO' ?) before the `do'-notation was invented
06:54:20 <mparodi> I have to change the types of the functions I already wrote >_>
06:54:29 <mparodi> trace (whatever here) foo
06:54:33 <mparodi> is better in that sense
06:54:53 <srhb> mparodi: No, you lose a ton of safety from that.
06:55:08 <mparodi> I didn't say it's perfect :P
06:55:11 <srhb> mparodi: The idea is to make most of your functions pure and have only one or few IO entry points, like main.
06:55:11 <ski> mparodi : no, since the compiler is free to rewrite your code so that that `trace' message is shown more times or less times than you think
06:55:35 <b_jonas> trace is for debugging only
06:56:06 <mparodi> I know, but I'm not saying I will use trace. maybe there was a function like trace but not just for debugging purposes
06:56:24 <srhb> mparodi: No, it cannot exist. What are you trying to do?
06:56:38 <EvanR> a refreshing desert in the oasis of referential transparency
06:56:54 * Gx4 goes party*
06:57:03 <ski> EvanR :)
06:57:06 <mparodi> I need to print traces in a program, but not to debug it but because it needs to print that to stdout
06:57:34 <srhb> mparodi: So you're making more of your functions work in the IO Monad?
06:57:55 <ski> you might want to use an output/writer monad
06:58:23 <mparodi> srh, yes, main and more 3 functions to be precise
06:58:29 <mparodi> err, srhb
06:58:34 <srhb> mparodi: Sounds like Writer is the way to go. :)
06:58:49 <programm1r> good time!
06:59:00 <mparodi> 3 more functions *
06:59:08 * mparodi is reading about Writer
07:00:07 <ski> @localtime programm1r
07:00:09 <lambdabot> Local time for programm1r is Fri Jun 15 20:59:46 2012
07:00:30 <mparodi> lambdabot, where do you live? :P
07:00:30 <ski> sounds like good time, yes
07:00:31 <EvanR> 9pm on friday
07:00:34 <EvanR> heh
07:00:55 <EvanR> its still tuesday over here
07:01:07 <srhb> EvanR: That's fairly amazing.
07:01:25 <ski> (mparodi : .. try asking ?)
07:01:30 <EvanR> i was playing with Acme.Now
07:01:48 <mparodi> ski, uh?
07:02:05 <ski> mparodi : asking lambdabot about her local time ?
07:02:14 <EvanR> @help
07:02:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:02:31 <applicative> is this otherwise done on Hackage, naming major version changes Paraiso-0.3.0.0 'Doughnut' , Paraiso-0.2.0.0 'Companion' etc  http://hackage.haskell.org/package/Paraiso
07:02:54 <programm1r> evening...
07:03:08 <mparodi> I just asked -jokingly- where it's 9pm
07:03:20 <ski> mparodi : i mean like this :
07:03:21 <ski> @localtime lambdabot
07:03:21 <lambdabot> I live on the internet, do you expect me to have a local time?
07:03:44 <ski> programm1r : how's haskell programming ?
07:05:38 <mparodi> @index printf
07:05:38 <lambdabot> Text.Printf
07:06:13 <programm1r> I did not speak English, you're laughing at me?
07:06:48 <programm1r> localtime 21:05 (9:05pm)
07:08:07 <programm1r> I thought "good time" - any time of day ...
07:09:02 <applicative> programm1r: no, maybe just "hi" "howdy" or "hello"
07:09:37 <applicative> programm1r: or else drawing attention to it ,  "good afternoon, or morning, or whatever it is for you"
07:10:08 <programm1r> hi
07:10:17 <applicative> hi! programm1r!
07:10:39 <shapr> Good Morning programm1r! How's code?
07:11:41 <ski> programm1r : no, i was just jokingly checking which time you considered good :)
07:15:06 <applicative> programm1r: your English is good;  #haskell uses  English but it is for the world, not just native speakers.
07:15:07 <mparodi> can you print [(1,2,3), (4,5,6)] with printf or you have to do printf "... %s ..." (show [(1,2,3), (4,5,6)])?
07:16:23 <nand`> the latter
07:16:44 <nand`> there doesn't seem to be a PrintfArg instance for anything resembling Num a => [(a,a,a)]
07:17:27 <mparodi> maybe there was a %tuple
07:17:32 <quicksilver> there isn't.
07:17:40 <quicksilver> there are only the standard C-style things.
07:17:55 <quicksilver> printf is a pretty horrible design, for legacy compatibility, you wouldn't want to extend it :P
07:17:55 <mparodi> yep, I just found http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Text-Printf.html
07:18:02 <fmap> i'd use a pretty printer for this task
07:18:38 <mparodi> fmap, do you mean you would write your own printer?
07:18:42 * shapr gets out his ugly printer
07:19:44 <nand`> shapr: haha
07:19:47 <nand`> not much love for that one
07:19:50 <shapr> :-)
07:20:27 <fmap> mparodi: probably use an existing library
07:21:01 <arnsholt> quicksilver: Maybe you'd prefer CL-style format? O:)
07:21:11 <mikeplus64> mparodi: i wrote a little tutorial about it
07:21:25 <mikeplus64> mparodi: http://quasimal.com/posts/2012-05-25-quasitext-and-quasiquoting.html
07:21:35 <nand`> quicksilver: legacy compatibility? for those C programs ported to Haskell, you mean?
07:21:48 <quicksilver> or fragments of them
07:21:55 <Bohaty> hello
07:21:56 <quicksilver> or config file formats which use printf strings
07:22:07 <nand`> ah
07:22:20 <mparodi> mikeplus64, thanks
07:22:35 * ski . o O ( "Implementation of PRINT-XAPPING with my FORMAT replacement concept" by Hexstream at <http://paste.lisp.org/display/128010> )
07:23:14 <mikeplus64> just hogging my nicks
07:24:30 <srhb> Bohaty: Hello :)
07:25:27 <applicative> hey Bohaty
07:25:49 <fmap> Is there any package that can read some images from disk and append them? hsmagick apparently cannot.
07:26:28 <quicksilver> what does appending an image mean
07:27:04 <fmap> I want one big image from a bunch of smaller ones
07:27:07 <fmap> left-to-right
07:28:17 <srhb> fmap: The docs are pretty horrid, but isn't that what mosaic does?
07:30:02 <quicksilver> you need an image manipulation library then
07:30:04 <quicksilver> cairo or opengl
07:30:18 <fmap> srhb: can't tell since `initializeMagick >> readImage "somepath" >>= \…' gives a segfault
07:30:45 <srhb> fmap: Well, if it weren't segfaulting I'm fairly sure that's what it does :-)
07:39:19 <applicative> fmap  what kind of images are they?
07:40:06 <fmap> applicative: screenshots
07:40:18 <applicative> i think with repa-devil it is just a matter of append ++
07:40:44 <parcs`> i'm surprised there're no tuple instances for Random...
07:45:25 <fmap> applicative: thanks, looks good
07:46:12 <applicative> fmap i was going to try it but my homebrew libdevil is broken it seems
07:47:54 <applicative> one could do with a repa-devil-obvious-combinators
08:10:03 * hackagebot hbayes 0.5 - Bayesian Networks  http://hackage.haskell.org/package/hbayes-0.5 (alpheccar)
08:30:05 * hackagebot edenskel 1.1.1.0 - Semi-explicit parallel programming skeleton library  http://hackage.haskell.org/package/edenskel-1.1.1.0 (MischaDieterle)
08:33:13 <hpaste_> applicative pasted “repa devil append image” at http://hpaste.org/70002
08:33:51 <applicative> fmap: well, here's the simplest case ^^ appending an image to itself on the right :)
08:34:38 <fmap> applicative: can you explain `transpose` stuff?
08:35:07 <fmap> i've already gave up on repa and done appends via gd bindings though
08:35:39 <applicative> fmap it's just that it's a 3d array, the 3rd D representing  color.  so you transpose and that gives you the left right dimension
08:36:16 <applicative> so now when you append, you  get one to the right
08:36:33 <fmap> aha, what's why simple R.++ gave weird output
08:36:35 <applicative> but then the colors are trapped in the middle dimension so you retranspose
08:36:50 <applicative> fmap: yes, I saw  the result :)
08:38:54 <fmap> applicative: thanks, so i probably should rewrite with repa
08:39:37 <applicative> I'm not sure what R.++ does if the 'height's aren't the same, for  example
08:40:20 <applicative> one would guess its like zip, the too-long one gets cropped
08:48:44 <angstrom> is there a way to quantify a record field? e.g., `data A = A { s :: String } ; x = A "bla" ; print $ A.s x'
08:51:11 <unlink> how can I phrase a function (encodeM4A :: FilePath -> Metadata -> Handle -> IO ()) applicatively so that I can do encodeM4A <*> pure dest <*> readMetadata src <*> decodeOgg src?
08:51:47 <hiptobecubic> Have any of you ever heard of Single-Assignment-C?
08:52:50 <srhb> hiptobecubic: Yes
08:53:33 <hiptobecubic> srhb, why?
08:54:23 <srhb> hiptobecubic: Well, because we were building a single assignment C dialect in class once, and were told of the real single assignment C for perspective. Nothing deep. :-)
08:54:24 <proofit404> does anybody use xmonad here& :)
08:54:48 <armlesshobo> proofit404: i am right now
08:54:49 <proofit404> ?
08:55:05 <proofit404> How I can use setLayout in current workspace with manageHook? Layout define in "variable".
08:55:10 * hackagebot HaXml 1.23 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.23 (MalcolmWallace)
08:56:26 <applicative> angstrom: what do you mean quantify?
08:56:52 <hiptobecubic> srhb, ah, where was this?
08:57:13 <srhb> hiptobecubic: CompSci at Uni. Copenhagen.
08:57:17 <hiptobecubic> proofit404, there is also an #xmonad channel
08:58:49 <applicative> angstrom: if you just want to print  the string field you write  :  putStrLn  $ s x
09:02:19 <programmer> h
09:03:05 <applicative> angstrom: the fields of a record type cant appear  in other records, a point frequently complained about, so something like A.s is unnecessary.
09:03:17 <applicative> hi programmer
09:03:33 <programmer> hi applicative
09:16:46 <fuchsto> Can someone tell me how i can resolve the length of an IOArray?
09:17:47 <fuchsto> so in    x <- newArray(0,1023) 0    how do i resolve the size of x (here: 1024) ?
09:18:31 <rwbarton> getBounds
09:18:42 <rwbarton> and rangeSize
09:20:03 <fuchsto> rwbarton: Thank you! Google failed me on this one. What's the difference between rangeSize and getBounds, if any?
09:20:57 <shachaf> fuchsto: I think you use both. Just look at their types in the documentation. :-)
09:22:41 <fuchsto> ah, rangeSize expects a tuple and returns the range size.
09:22:59 <fuchsto> rangeSize(0,10) => 11
09:24:37 <realitygrill> can haskell not define a function that starts with a number?
09:25:05 <ben> names only get to start with underscores and letters and that sort of thing
09:25:09 <ben> numbers are reserved for numbers
09:25:46 <realitygrill> i see.. so no functions like 10_elems lst = take 10 lst
09:26:24 <ben> nope, sorry
09:28:42 <fuchsto> Hm. Assuming i have a data constructor like    data Signal = Signal (IOArray Int Float)
09:29:33 <fuchsto> and i define     signal <- (newListArray(0, 100) 0) :: IO (IOArray Int Float)
09:30:46 <fuchsto> and   let myBuf = (Signal signal)::Signal
09:31:22 <fuchsto> i can't use    getBounds myBuf   then, as it expects an IOArray but receives a Signal. Casting won't help here.
09:31:47 <fuchsto> Should i define a conversion function like    signalToArray Signal a = a   ? (if that is even possible)
09:32:48 <geekosaur> data Signal = Signal { toArray :: IOArray Int Float } -- possibly
09:33:17 <geekosaur> then "getBounds (toArray signal)"
09:33:20 <fuchsto> geekosaur: Gnaaarrh, of course
09:33:30 <fuchsto> i knew that some days ago
09:33:35 <fuchsto> thank you
09:34:40 <fuchsto> ah, what's the difference between data, type and newtype, actually?
09:35:13 <applicative> type  is just aliasing
09:35:46 <fuchsto> that's why type has no data constructor, i presume
09:35:55 <applicative> yes
09:36:13 <applicative> newtype is when you have exactly one field, it wraps it for various purposes, but in theory has no cost and makes no new 'bottom' element
09:36:43 <applicative> data is the main way of constructing new data types
09:36:53 <fuchsto> okay, so something like a 'handler' for one type, but with a data constructor
09:37:06 <fuchsto> so, i can't define alternatives for newtype
09:37:22 <applicative> right, you can newtype a type that has alternatives
09:37:33 <nand`> no
09:37:49 <applicative> but you cant  newtype two things at once so to say
09:38:14 <fuchsto> so, newtype has exactly one constructor, data has one for every alternative
09:38:27 <applicative> right
09:38:41 <applicative> newtype can be recursive, which is a little surprising
09:39:07 <fuchsto> like the classical     data Tree a = Leaf a | Branch (Tree a) (Tree a)
09:39:08 <realitygrill> what's wrong with '(take 3) . sort lst', as opposed to '(take 3) $ sort lst'?
09:39:24 <applicative> @type sort
09:39:25 <lambdabot> forall a. (Ord a) => [a] -> [a]
09:39:39 <applicative> > take 3 . sort
09:39:40 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
09:39:40 <lambdabot>    arising from a use ...
09:39:51 <applicative> @type take3 . sort --rather
09:39:52 <lambdabot> Not in scope: `take3'
09:39:57 <applicative> @type take 3 . sort --rather
09:39:58 <lambdabot> forall a. (Ord a) => [a] -> [a]
09:40:17 <realitygrill> just seems like the composition should work to me
09:40:30 <applicative> take 3 composes with sort, not sort [1,2,3]
09:40:54 <applicative> take 3 applies to sort [1,2,3]
09:41:09 <realitygrill> ..so?
09:41:23 <srhb> realitygrill: (.) takes a second argument which, again should take on argument
09:41:32 <srhb> realitygrill: sort [] does not take an argument
09:41:42 <srhb> :t (.)
09:41:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:41:46 <applicative> > (take 3) . sort $ "dcba"
09:41:48 <srhb> Agh.
09:41:48 <lambdabot>   "abc"
09:42:17 <srhb> > take 3 . sort $ "bca"
09:42:19 <lambdabot>   "abc"
09:42:35 <fuchsto> it's just like in math:   f(g(x))   or   f . g x
09:42:49 <fuchsto> (if i got that right)
09:42:50 <srhb> fuchsto: Except that would work in math but not in Haskell.
09:42:59 <realitygrill> lol..
09:43:03 <srhb> fuchsto: f . g $ x -- in Haskell
09:43:06 <applicative>  (f . g) x
09:43:07 <fuchsto> srhb: right, that's the nasty part :)
09:44:31 <fuchsto> it's composition (.) versus application ($) ... took me some trial and error in ghci to get it
09:44:51 <realitygrill> ok well.. i guess i'm still confused
09:45:11 <realitygrill> is the problem you can't partially apply sort?
09:45:24 <applicative> fuchsto: one principal purpose of newtyping is that you can rewrite a class instance you don't like.  Another is to swap and identify parameters in type, so it's like a poor mans type level lamda or something
09:46:58 <fuchsto> applicative: Okay,that's helpful, thanks!
09:47:03 <applicative> so if you have Stream r m i o you might newtype Pipe i o m r = Pipe (Stream r m i o)
09:48:10 <fuchsto> applicative: So, this is expressing the use of the type "this is used as a pipe" and hides the implementation "this actually is a Stream"
09:48:49 <fuchsto> like in C:    typedef buffer_t float[]
09:49:06 <fuchsto> err, typedef float[] buffer_t, whatev
09:49:13 <strager> newtype is not like typedef.
09:49:24 <applicative> I guess so. The point in that case might be e.g. that "Pipe i o m" might be a monad over things in the r position, and "Pipe i o" might be a monad transformer
09:49:42 <applicative> meanwhile "Stream r m" might be a category or arrow or whatever
09:50:19 <applicative> you might get different class instances depending how you arrange the parameters, but to do this you need to wrap in a newtype
09:50:27 <fuchsto> okay, that's powerful
09:52:30 <srhb> realitygrill: The problem is sort foo does not have type (a -> b). (.) :: (b->c) -> (a->b) -> a -> c
09:56:22 <nyingen> I have a question about vectors. I have a list of Word8 values, and I want to initialize a vector with those values. The only function in Data.Vector.Storable.Mutable that seems to support this is replicateM, but I can't figure out how I would use that function in this case
09:57:04 <nyingen> The vector will be larger than the initial list, and I want to initialize the rest of the elements to 0
09:58:39 <nyingen> I'm also totally confused by the PrimMonad module. What is it for?
09:59:47 <applicative> the PrimMonads are ST s and IO, right
10:00:38 <nyingen> ah, so they are
10:01:24 <Mortchek> What does <*> mean?
10:02:20 <applicative> Mortchek: when one thing 'returns' a function and another 'returns' a value , f <*> x returns the function applied to the value
10:02:51 <applicative> Mortchek: it applies in any instance of Applicative
10:03:13 <applicative> > [(+1), (*2)] <*>[10,100]
10:03:14 <lambdabot>   [11,101,20,200]
10:03:42 <applicative> > Just (*2) <*> Just 100
10:03:43 <lambdabot>   Just 200
10:04:02 <applicative> and more strangely
10:04:27 <applicative> > (*) <*> (+1) $ 10
10:04:28 <lambdabot>   110
10:05:44 <Mortchek> What module is that in? I asked because I've seen it but wasn't sure if it was an actual function.
10:05:51 <ski> @index (<*>)
10:05:52 <lambdabot> bzzt
10:05:55 <applicative> nyingen: the poor man's way is to use Data.Vector.Unboxed.fromList with the length of  0's at the end that you want.  Then thaw
10:06:05 <ski> @hoogle (<*>)
10:06:05 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
10:06:21 <Mortchek> Aha. Thanks.
10:07:32 <otters> wow
10:07:41 <otters> the ghc trac captcha is absolutely incomprehensible
10:08:45 <Nimatek> Is it now?
10:08:49 <Mortchek> applicative, in what sense do you mean "returns"?
10:08:49 <Nimatek> He's a robot, get him!
10:09:13 <ski> Mortchek : depends on the applicative functor in question
10:09:24 <applicative> i was just using it in the sense we do with a monad, very fuzzily
10:09:26 <otters> oh good there's already a bug report
10:09:36 <ski> Mortchek : in the case of lists, it applies each function in a list of functions to each argument in a list of arguments
10:10:19 <ski> Mortchek : in the case of `Maybe' it check if there is a function there (not `Nothing') and an argument there, and in that case applies the function to the argument (rewrapping in `Just')
10:10:20 <otters> oh it's been fixed in head but not here
10:10:23 <otters> how do I update ghc
10:10:59 <ski> Mortchek : in case of `ZipList' it applies each function to the argument in the corresponding position
10:11:26 <Mortchek> > Just (+1) <*> Just 0
10:11:26 <lambdabot>   Just 1
10:11:39 <ski> Mortchek : in case of `IO', it runs the action that produces the function, and the action that produces the argument and then applies the function to the argument
10:12:30 <otters> also, how do I "unregister" ghc since apparently that's necessary to use -C
10:12:40 <ski> > getZipList (ZipList [(1 +),(2 *),(3 ^)] <*> ZipList [10,100,1000])
10:12:41 <lambdabot>   [11,200,1322070819480806636890455259752144365965422032752148167664920368226...
10:13:16 <ski> > length (getZipList (ZipList [(1 +),(2 *),(3 ^)] <*> ZipList [10,100,1000]))
10:13:18 <lambdabot>   3
10:13:31 <Mortchek> Hmm. So is Maybe basically designed to propagate errors if any value comes up Nothing?
10:13:53 <ski> yes, `Maybe' is a simple error-propagation (and -handling) thing
10:14:22 <rwbarton> > getZipList $ ZipList [(+), (*), (^)] <*> ZipList [1, 2, 3] <*> ZipList [10, 100, 1000]
10:14:23 <lambdabot>   [11,200,1322070819480806636890455259752144365965422032752148167664920368226...
10:15:35 <otters> > ZipList [(+),(*),(^)] <*> ZipList [1,2,3] <*> ZipList [10,100,1000]
10:15:37 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
10:15:37 <lambdabot>    arising ...
10:15:58 <aristid> @src ZipList <*>
10:15:58 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:16:06 <Mortchek> Would I just use fmap to work on a value in Maybe?
10:16:08 <ski> Mortchek : if you even find yourself writing nested boiler-plate code like at the top of <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>, then you probably want to use either monadic or applicative functor combinators
10:16:26 <ski> Mortchek : yes, if you have a single value of type `Maybe Foo'
10:17:58 <Mortchek> All right thanks. I'm mainly just curious at this point, am still getting the hang of writing Haskell.
10:18:07 <ski> if you want to combine several, ones, you need `(<*>)' (or other operations which use it, like `liftA2',`liftA3',`sequenceA',`traverse')
10:18:22 <byorgey> > getZipList $ ZipList [(+),(*),(^)] <*> ZipList [1,2,3] <*> ZipList [10,100,1000]
10:18:23 <lambdabot>   [11,200,1322070819480806636890455259752144365965422032752148167664920368226...
10:18:30 <ski> (s/, ones/ ones/)
10:18:37 <otters> if you need to keep doing computations that return Maybe a based on the values of each other you can also use >>=
10:18:44 <ski> *nod*
10:19:03 <ski> @hoogle replicateA
10:19:04 <lambdabot> Data.Sequence replicateA :: Applicative f => Int -> f a -> f (Seq a)
10:19:07 <otters> which is very satisfying
10:20:24 <ski> (what is very satisfying ?)
10:20:43 <otters> using >>= with Maybe
10:20:50 <ski> ah, yes
10:21:00 <otters> because of its elegance and beauty
10:21:10 <Mortchek> otters, can you show an example?
10:21:12 <hpaste_> Grue pasted “Skype replaces P2P supernodes with Linux boxes hosted by Microsoft (updated)” at http://hpaste.org/70004
10:21:18 <otters> Mortchek: sure thing
10:21:27 <otters> Say you have a nested map
10:21:41 <otters> M.lookup key map >>= M.lookup nextKey
10:21:47 <ski> Mortchek : the link above has an example, though it calls it `thenMB' instead of `(>>=)'
10:21:59 <fuchsto_> How would i iterate over an IOArray? I have trouble using map :/
10:22:53 <fuchsto_> actually i want a list comprehension:    [ Vertex3 0 value 0 | idx <- [0..numSamples], value <- readArray myArray idx ]
10:23:58 <fuchsto_> ghc complains about a type mismatch: Expected type [t0], actual type Float
10:24:07 <fuchsto_> (myArray is an IOArray Int Float)
10:24:19 <ski> @type Data.Array.MArray.mapArray
10:24:20 <lambdabot> forall e' e (a :: * -> * -> *) i (m :: * -> *). (Data.Array.Base.MArray a e' m, Data.Array.Base.MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
10:24:22 <ski> maybe you want that ?
10:24:35 <fuchsto_> ski: That's more like it!
10:24:56 <fuchsto_> ski: So, would a list comprehension even work? readArray returns a monadic
10:25:10 <MostAwesomeDude> I miss monad comprehensions. :c
10:25:17 <MostAwesomeDude> I mean, you can't miss what you never had, but still.
10:25:29 <fuchsto_> so IOArray Int Float   -> readArray myArray  -> m Float
10:25:42 <fuchsto_> so, no, list comprehensions and monads don't mix?
10:26:13 <Targen> Hi.  I’ve tried to install lambdabot using the latest Haskell Platform on top of GHC7.4.2 and ran into a few errors.  It turns out they were quite trivial to fix: it was just a matter of enabling FlexibleInstances in a few source files.  I’m wondering if there’s a way to report the issue and submit a patch, or at least check whether it’s been addressed somehow.  Where should I look?
10:26:13 <MostAwesomeDude> LCs only work on the list monad.
10:26:15 <ski> fuchsto_ : you couldn't use a list comprehension directly .. you could first extract the elements and then use a list comprehension on that, though -- e.g. using `getElems'
10:26:55 <fuchsto_> getElems returns a monad on a list containing the array elements?
10:27:08 <fuchsto_> listOfArrayElems <- getElems myArray  ?
10:27:27 * fuchsto_ tries
10:27:31 <illissius> MostAwesomeDude: monad comprehensions are back as of 7.2
10:28:01 <fuchsto_> illissius: orly? I have 7.2 here. How do those work?
10:28:16 <illissius> fuchsto_: LANGUAGE MonadComprehensions.. that's probably it.
10:28:17 <fuchsto_> eh, nevermind, i want to be compatible to ghc6
10:28:37 <illissius> unrelatedly, haddock doesn't seem to handle grouped functions well :c
10:29:50 <ski> fuchsto_ : s/returns a monad/returns a monadic action/
10:30:41 <MostAwesomeDude> illissius: Oooh, nifty.
10:30:56 <ski> illissius : i don't think that'd help in this case (unless something like `ListT IO' or `ContT Something IO' was used)
10:31:14 <ski> illissius : "grouped" ?
10:31:26 <illissius> ski: hm? what would help in what case?
10:31:48 <ski> fuchsto_ : wants to read from an `IO' array, iterating over indices
10:31:59 <fuchsto_> ski: Yes, a monadic action, i always mix that up ... it does not return a class, yes
10:32:02 <ski> so you'd need to combine `IO' with backtracking
10:32:06 <illissius> right, I wasn't paying attention to that, just saw the lament for monad comprehensions :)
10:32:42 <fuchsto_> thing is: I want an IOArray for constant random access, actually
10:32:57 <fuchsto_> i feel bad for making a list out of my pretty array to iterate over it
10:33:07 <fuchsto_> i smell overhead.
10:33:16 <ski> fuchsto_ : hehe, consider `getLine :: IO String' : (a) `getLine' is a monadic action (specifically, an `IO'-action); (b) `IO' itself is a monad (an instance of type class `Monad'); (c) `Monad' is a type class (the class of monads)
10:33:53 <fuchsto_> ski: yes ... i'm a noob. I am unworty. I am dust :(
10:34:05 <ski> fuchsto_ : if you just want to map, use `mapArray' -- otherwise it's probably not much of a problem if you just use the list for iteration
10:34:29 <ski> fuchsto_ : don't worry, with some practice you'll learn :)
10:34:34 <fuchsto_> ski: I have an array of GFloats and want to map it to a list of Vertex3
10:34:53 <fuchsto_> ski: So mapArray should work if i got that right
10:34:54 <ski> ok, so not an array of `Vertex3' elements, then ?
10:35:10 <ski> `mapArray' will give you back a new `IOArray'
10:35:43 <illissius> ski: wrt grouped functions: you can write "foo, bar :: A -> B -> C" in source, but haddock doesn't preserve that, and splits them apart instead. which is annoying because I wanted to define named functions along with operators which are synonyms for them in that way to make it obvious and compact and share the same doc comment for both, but instead they're listed separately with one of them missing documentation. :\
10:36:30 <fuchsto_> ski: Yeah, sure, map is not supposed to change the type ... so i need getElems in any case
10:37:12 <ski> fuchsto_ : ok
10:37:28 <fuchsto_> My use case is: I have an IOArray of Floats, i want a List of Vertex3. Somewhere in between, i have to construct that list.
10:37:42 <ski> in that case it might be better to not use `mapArray' (no need to allocate a new `IOArray' if it's not going to be used)
10:37:54 <ski> if in doubt, you could time and/or profile the code, i suppose
10:38:01 * ski nods
10:38:06 <fuchsto_> either mapArray + getElems, or getElems + map
10:38:29 * ski would probably try the latter first
10:39:13 <fuchsto_> i think so, too, yes. The IOArray ist just a nice construct for my buffer, i don't actually want to handle with arrays in my functions
10:39:20 <ski> illissius : ah, coordinated type signatures
10:39:38 <illissius> ski: is that what they're called? I had trouble googling for it
10:40:16 <ski> illissius : i'm not sure whether the word "coordination" is common in this use (though i think it makes sense) -- however, it's a kind of type signature, yes
10:43:43 <fuchsto_> hm, another practical questions:  getBounds someIOArray  returns a m (start,end)    (a monadic action returning a tuple)
10:44:05 <fuchsto_> rangeSize expects a tuple and returns its range, like rangeSize (0,10) == 11
10:44:29 <fmap> illissius: actually haddock can handle "foo, bar :: A -> B -> C"
10:44:34 <fmap> see repa docs
10:44:36 <fuchsto_> rangeSize $ getBounds myArray   of course does not work, as rangeSize expects a tuple, not a monadic action returning one. Can i solve this without a temp variable?
10:44:56 <fmap> http://hackage.haskell.org/packages/archive/repa/3.2.1.1/doc/html/Data-Array-Repa-Operators-IndexSpace.html#v:append
10:45:09 <fuchsto_> currently i'm using:     bounds <- getBounds myArray;  let size = rangeSize bounds
10:45:30 <fuchsto_> works, but i just wonder if there is a more concise way
10:45:39 <rwbarton> size <- rangeSize <$> getBounds myArray
10:45:46 <rwbarton> (<$>) is also liftM/fmap/etc.
10:46:02 <illissius> fmap: Oh, thanks!
10:46:09 <illissius> maybe my haddock is old?
10:46:10 <illissius> hmm
10:46:12 <fuchsto_> rwbarton: Argh, yes, thank you
10:47:04 <shapr[> @type (.=)
10:47:05 <lambdabot> Not in scope: `.='
10:48:03 <luite> shapr[: it's in aeson, it produces a Pair
10:48:41 <luite> (educated guessing :p)
10:48:58 <shapr[> Eh, I was trying to fix this unexpected type error.
10:49:24 <shapr[> The aeson on my desktop from two months ago wants a bytestring, the version I have now wants a normal string.
10:49:26 * shapr[ shrugs
10:49:38 <shapr[> But phrasing my question answered it, so I like that :-)
10:49:46 <luite> (.=) :: ToJSON a => Text -> a -> Pair
10:50:14 <luite> the first one has been Text for a long time at least
10:50:36 <illissius> Oh yay, it works now. Probably I was using an older haddock.
10:50:43 <shapr[> I dunno then. But it works now, so I won't argue.
10:50:59 <illissius> It's even preserved across re-exports. Awesome.
10:51:18 <luite> shapr[: might have something to do with the OverloadedStrings extension being enabled?
10:51:37 <shapr[> oh that's entirely possible... I don't know
10:51:39 <luite> you have to do pack "..." if you don't, (but the Text pack, not the ByteString one)
10:52:02 <shapr[> oh
10:52:14 * shapr[ grumbles
10:52:32 <shapr[> Now I'm getting duplicate symbol definition for _hs_text_decode_utf8
10:52:57 <luite> hm, guess: indirect dependencies on multiple versions of the text package
10:53:09 <shapr[> probably so, I'll just stop using runghc
10:53:56 <luite> yeah making a cabal package is better :)
10:54:05 <luite> you can still use cabal-dev ghci then
10:54:08 <luite> and run your main
10:55:01 <shapr[> I'll try that.
10:55:21 <luite> heard from apfelmus yet btw?
10:55:38 <shapr[> Not yet
10:56:28 <luite> the jquery-console sample wokrs here btw, cool :)
10:56:38 <shapr[> yay!
10:56:49 <shapr[> It's not yet connected to hint though!
10:57:01 <luite> only if i let it load your Demo.hs, it does something wrong
10:57:06 <shapr[> :-(
10:57:36 <luite> oh haha you're cheating with haskell.json from tryhaskell.org
11:00:27 <luite> shapr[: oh you removed the raphael handler!
11:00:45 <shapr[> Right, I don't think I'll need that.
11:00:45 <luite> try circle 100 50 50
11:00:47 <luite> in tryhaskell
11:00:48 <luite> :)
11:00:48 <luite> :p
11:01:11 <shapr[> it works?
11:01:28 <luite> yeah but it's probably better to do diagrams->svg instead
11:01:28 <shapr[> Do you think I should have left the raphael handler?
11:01:42 <luite> nah, it's just a fun play thing, but there are much better ways to do graphics now
11:02:02 * ski idly wonders who raphael is, and why he needs to be handled
11:02:18 <luite> ski: one of the ninja turtles
11:02:28 <srhb> And if you hande him, handle with care.
11:02:33 <programmer> Someone is using gnuplot?
11:02:59 * ski recalls meeting a Teenage Mutant Ninja Tortoise in a game
11:03:52 <ski> (in that specific case, he was handled with a butcher knife, iirc)
11:04:02 <luite> shapr[: that's also why i think there should be two types in the json response
11:06:28 <luite> shapr[: btw if you want to go for CodeMirror everywhere, it's easy to make one-line codemirror with highlighting similar to the split input you had in your previous thing
11:06:55 <luite> shapr[: but you'd need to handle history manually (not too difficult)
11:08:45 <luite> shapr[: another possibility is to have a one-line codemirror act as the input line as the console. you can remove the input codemirror after receiving a result and run the syntax highlighter standalone. then insert a new single line editor
11:09:16 <luite> the advantage of codemirror is that it works more like a textarea/field, copy/paste and cursor stuff work more as expected
11:09:57 <luite> i think you need a runmode extension for codemirror if you want to run the highlighter standalone, but it's quite simple
11:15:20 <shapr[> luite: eh?
11:15:53 <shapr[> luite: I'd actually prefer one pane for source code and another pane for 'ghci'
11:17:27 <luite> shapr[: right, but i mean, the jquery-console is more a console view, the textarea(results)+input view is more like an irc client
11:17:57 <shapr[> That's true
11:18:05 <luite> you can replace the input with CodeMirror and the result thing with a scrolling div and then use CodeMirror to highlight the evaluated expressions
11:18:14 <shapr[> I'd like to have one pane for codemirror (or whatever) and another pane for ghci
11:18:28 <luite> then you have a one-line codemirror for entering expressions
11:18:40 <shapr[> What's the advanteg?
11:19:18 <luite> shapr[: highlighting in the expression you're entering and cursor and copy/paste behaviour more like usual text boxes
11:20:33 * hackagebot git-annex 3.20120615 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120615 (JoeyHess)
11:47:50 <LambdaDusk> is there anyone in the world able to explain yampa's dpSwitch?
11:55:58 <hpaste_> pmk pasted “typepuzzle” at http://hpaste.org/70012
11:56:47 <pmk> ok, i thought that i understood type inference and classes, but i sure don't grok why this example fails to compile
11:57:09 <fmap> `a' is unrelated to `t'
11:57:13 <pmk> reduced case and compilation error:  http://hpaste.org/70012
11:57:21 <fmap> you want ScopedTypeVariables
11:57:37 <byorgey> pmk: just get rid of the type signature.
11:57:42 <fmap> or that
11:57:55 <byorgey> ScopedTypeVariables is not really necessary.
11:57:55 <pmk> removing the type signature(s) does not work, alas.
11:58:05 <byorgey> oh, hmm
11:58:13 <c_wraith> It's never necessary, but it does make code look nicer sometimes.
11:58:27 <byorgey> oh, right, I see why
11:58:35 <pmk> wonderful!
11:59:15 <monochrom> inOrder (fromList xs) is the same problem as show (read x). this is why the author had to add a type to specify which instance he/she wants. but how to write that type is tricky under polymorphism
11:59:21 <byorgey> I guess you probably do want ScopedTypeVariables
12:00:32 <hpaste_> byorgey annotated “typepuzzle” with “typepuzzle (annotation)” at http://hpaste.org/70012#a70013
12:00:49 <byorgey> untested, but that's the idea
12:00:50 <pmk> inOrder (fromList xs :: SetImpl a) fails in the same way
12:01:09 <byorgey> well, it has to be SetImpl t
12:01:22 <byorgey> the t has to match the t from the type signature
12:01:45 <byorgey> but by default, you can't refer to type variables from the type signature in the body.
12:02:04 <S110010011> Ord t
12:02:05 <byorgey> that's what ScopedTypeVariables gives you.
12:02:29 <byorgey> S110010011: good catch, you need an Ord constraint too
12:02:41 <pmk> setSort :: forall t. Ord t => [t] -> [t] setSort xs = inOrder (fromList xs :: SetImpl t)
12:02:51 <pmk> that compiles
12:03:02 <byorgey> yup
12:03:18 <byorgey> do you see why it has to be the same t?
12:03:24 <pmk> would prefer a Haskell' solution, if possible
12:03:46 <pmk> yes, of course
12:03:46 <byorgey> Haskell' ?  you mean Haskell 2010?
12:03:52 <pmk> yes
12:04:27 <byorgey> ok, let me think, I forget what the trick is to simulate ScopedTypeVariables...
12:07:00 <pmk> honestly, i guess i don't understand why a and t do not unify, given the type signatures in the class.  (inOrder . fromList) has to have type Ord a => [a]->[a].
12:08:55 <LambdaDusk> :i []
12:09:21 <joeyh> @pl concatMap (\(fs, p) -> map (\(f, m) -> (f, m, p)) fs)
12:09:21 <lambdabot> (uncurry (flip (map . (`ap` snd) . (. fst) . flip (flip . (,,)))) =<<)
12:09:29 <LambdaDusk> sorry wrong window
12:10:04 <tgeeky> byorgey: implicitparamters
12:11:17 <tgeeky> byorgey: the example they give is the same example as they give for ScopedTypeVars. In ImplicitParamters case; it's:  sort :: (?cmp :: a -> a -> Bool) => [a] -> [a]
12:11:20 <byorgey> pmk: because the signature ss :: SetImpl a  means, "this expression must have type SetImpl a  for *any* type a"
12:11:35 <byorgey> pmk: but it doesn't, it only works when a = t
12:12:40 <hpaste_> byorgey annotated “typepuzzle” with “typepuzzle, without scopedtypevariables” at http://hpaste.org/70012#a70015
12:12:45 <pmk> ah
12:12:53 <pmk> that makes sense
12:13:12 <byorgey> pmk: ^^^ here's one way to do it.  it's not pretty but it is H2010.
12:13:42 <pmk> awesome
12:13:48 <byorgey> esentially, you write a function which is just 'const' but with a more restrictive type, that forces the types to unify in the way that you want
12:13:58 <pmk> that's the same technique used to implement asTypeOf in the Prelude, iirc
12:14:08 <S11001001> or just id
12:14:11 <byorgey> yes, exactly
12:14:14 <byorgey> it's
12:14:22 <byorgey> it's the same idea.
12:14:44 <teneen> Why is it claimed that attoparsec is faster than parsec?
12:14:56 <byorgey> id wouldn't work here, the point is that we want to relate the types of two expressions
12:15:02 <geekosaur> because it was at one point.
12:15:12 <byorgey> it isn't?
12:15:21 <geekosaur> it may even still be for some things, but parsec has come a long way since attoparsec was first written
12:17:42 <teneen> geekosaur: Was the main thing that attoparsec was able to parse Bytestrings?
12:18:12 <geekosaur> that was a large part of it, yes.  and while I think parsec3 was out nad had that capability, early versions were very slow
12:19:05 <pmk> fixType = const     -- does work, though
12:19:30 <teneen> geekosaur: parsec, parsec1, parsec2, parsec3 ... which one to use?
12:20:54 <geekosaur> parsec is correct.  the others came about because of that severe slowdown in parsec3 that I mentioned, causing many people to go back to parsec2
12:21:10 <geekosaur> it was ... not one of the prettier package management mishaps
12:21:52 <nyingen> there was a post on the yesod blog about how attoparsec "has replaced parsec for most of us"
12:23:08 <teneen> geekosaur: so there are different versions of parsec (1,2 and 3), and the best one is always kept in the parsec package?
12:23:23 <geekosaur> "parsec" is always the latest.
12:24:16 <geekosaur> parsec1 and parsec2 are historical; back when early parsec3 was having severe performance issues, the parsec2 and parsec3 packages were added so people could explicitly depend on one or the other
12:24:33 <nyingen> Sorry, I misspoke. The post just mentioned attoparsec in that context and implied that it was better. I was going to ask what the author might have meant by that. Is it true that attoparsec is more widely used now?
12:24:37 <geekosaur> hackage doesn't currently have a good way to deprecate old packages
12:24:44 <zzo38> If a category has more than one final object, I think then that category would have more than one Finalize monad. And if there is more than one initial object then it has more than one Initialize comonad.
12:24:57 <zzo38> geekosaur: Can you add it?
12:25:08 <teneen> geekosaur: I see
12:25:16 <geekosaur> nyingen, I think that's up to the developer
12:25:24 <geekosaur> zzo38, huh?
12:25:37 <zzo38> geekosaur: I mean add that feature to Hackage
12:25:39 <geekosaur> if you meant my comment about hackage, I am not a hackage maintainer
12:25:50 <geekosaur> but, hackage2 is out there... somewhere
12:26:19 <geekosaur> there's a test site which is occasionally synced against the live one; I do not know what the timetable is for final implementation
12:26:26 <nobdraisentone> Comparing hdbus and dbus-core packages - which of them is more usable?
12:30:01 <zzo38> Is it possible to make a lens from two categories c1 and c2 like:  newtype Lens c1 c2 x y = Lens (c1 x (c2 y x, y));  to make up the new lens category from this? What is needed from c1 and c2? It seem perhaps c2 is simply a category (with the same objects as c1), what does c1 have to be? One thing it might have to be is a tensor category, perhaps there needs to be a functor from (->) as well?
12:30:07 <zzo38> And what else?
12:31:39 <tgeeky> hm. A difference between where/let: You may not mix implicit-parameter bindings with ordinary bindings in a single let expression; use two nested lets instead. (In the case of where you are stuck, since you can't nest where clauses.)
12:32:18 <kaini> Hi, I am looking for a function I am not aware of. It must be something like (a -> a) -> a -> Int -> a, and I want it to do the (a -> a) n times and pass the result "around"
12:32:24 <kaini> Does something like that exist? ^^
12:32:53 <zzo38> kaini: There is something like that with a different order in my "prelude-generalize" package, where the function is called  church
12:32:56 <ion> @type \n f -> (!! n) . iterate f
12:32:57 <lambdabot> forall a. Int -> (a -> a) -> a -> a
12:33:13 <kaini> Looks good! Thanks
12:35:15 <netogallo> How should I run a haskell program with #if directives, I get lexical error at character 'i' with runghc
12:35:16 <netogallo> ?
12:35:35 <tgeeky> {#- LANGUAGE CPP -#}
12:35:37 <zzo38> netogallo: You need to enable C preprocessor
12:35:39 <luite> netogallo: -XCPP
12:35:46 <luite> or what tgeeky said in the .hs file
12:35:49 <netogallo> thanks makes sense
12:36:04 <luite> except that it's {-# instead of {#-
12:36:10 <tgeeky> doh
12:36:34 <zzo38> Can anyone understand my question about the lens?
12:37:44 <tgeeky> zzo38: uhhh.
12:37:47 <tgeeky> zzo38: http://hackage.haskell.org/packages/archive/multiplate/0.0.1.1/doc/html/Data-Generics-Multiplate.html <--
12:37:56 <tgeeky> that's probably not exactly what you're looking for
12:38:07 <tgeeky> but it only has two easy to understand and satisfy laws
12:38:49 <zzo38> tgeeky: Not even close.
12:39:03 <tgeeky> it is somewhat close, as it's a functional multireference
12:39:14 <zzo38> Multiplate is not even a category.
12:40:05 <illissius> zzo38: if you have a tensor category with a functor from (->), isn't that basically Arrow?
12:40:33 <zzo38> illissius: Arrow is basically that, although it is also a fanout category; and there are some additional laws although it is not agreed what they are.
12:40:50 <zzo38> But I could use Arrow, yes
12:41:03 <zzo38> Still that doesn't answer my question, though.
12:41:04 <rwbarton> poeple don't agree on what "tensor category" is either :P
12:41:09 <rwbarton> so maybe it works out!
12:41:18 <tgeeky> zzo38: it probably is a category, though it hasn't been proven (multiplate)
12:42:18 <fuchsto_> Another question: I want a list of tuples (index, value), and a list of values. I want the index to increment by a certain amount for every value, like [(0,10), (1,11), (2,23) ...]
12:42:51 <fuchsto_> i tried with [ (idx,value) | idx <- [0..10], value <- listOfValues ]
12:42:57 <luite> fuchsto_: something like zip [1..] values
12:43:04 <fuchsto_> of course this returns a list of n*n values, not n
12:43:32 <luite> fuchsto_: there's some parallel list comprehension syntax for this, but just using zip is usually better imho
12:44:00 <zzo38> I also don't know if "fanout category" is the standard term for what I am describing; I mean a tensor category with an additional operation fanout which is morphism for all objects on the category from that object to the product of the object with itself, satisfying certain laws
12:44:14 <fuchsto_> hm, zip only works on tuples ... i would need that for MyType index value, too
12:44:28 <fuchsto_> luite: How does a parallel list comprehension work?
12:44:33 <rwbarton> zipWith
12:44:34 <luite> fuchsto_: zipWith (\a -> b -> MyType b a) [1..] values
12:44:43 <luite> err, without that first ->
12:44:56 <fuchsto_> luite: Ah, good old zipWith :) thank you
12:45:37 <Kuraitou> Is there a way to define a list comprehension local variable that isn't a list?
12:46:25 <fmap> > [x + a | x <- [10..20], let a = 3]
12:46:26 <lambdabot>   [13,14,15,16,17,18,19,20,21,22,23]
12:46:53 <Kuraitou> thanks, that's just what I needed :)
12:46:58 <applicative> > [ x * y |x <- [1..] | y <- map (10^) [1..10]]
12:46:59 <lambdabot>   [10,200,3000,40000,500000,6000000,70000000,800000000,9000000000,100000000000]
12:47:35 <T_S_> Is there any experience report out there regarding using haskell to access S3? Specifically the hackage package hS3.
12:49:35 <c_wraith> T_S_: my company uses hS3 (for uploads only) with no trouble
12:49:46 <RosePerry> What's wrong with having a series of let statements like this?
12:49:54 <RosePerry> let c0 = Card Two Heart
12:49:55 <RosePerry> let c1 = Card Three Heart
12:49:56 <RosePerry> let c2 = Card Two Spade
12:49:57 <RosePerry> let c3 = Card Four Club
12:49:58 <RosePerry> let c4 = Card Ace Heart
12:50:14 <RosePerry>  I get a parse error on the second line
12:50:16 <applicative> followed by 'in'?
12:50:27 <S11001001> get rid of the extra lets
12:50:38 <luite> multiple lines of lets only work in a do block
12:50:43 <applicative> just one let then several statements, then one in
12:50:50 <HairyDude> and let doesn't work at all on the top level
12:50:57 <RosePerry> alright, I want to make sure all the variables are globally visible
12:51:07 <startling> RosePerry: then don't use let at all
12:51:08 <applicative> right, in a do block it makes sense to do that
12:51:10 <geekosaur> leave off the "let" at the top level
12:51:11 <luite> oh then just remove the lets altogether
12:51:12 <RosePerry> why doesn't let work no the top level? What should I use instead?
12:51:18 <HairyDude> just a binding
12:51:22 <startling> RosePerry: c0 = Card Two Heart
12:51:27 <RosePerry> thanks!
12:51:32 <applicative> oh i see
12:51:53 <RosePerry> Why doesn't let work on the top level?
12:52:02 <luite> RosePerry: ghci is a bit weird in that it lets you do this, it simulates some IO do block
12:52:08 <geekosaur> it's not needed
12:52:10 <HairyDude> let is for local declarations
12:52:11 <luite> more or less
12:52:13 <applicative> it's just not the haskell way
12:52:26 <RosePerry> Thank you a lll!
12:52:30 <RosePerry> *all
12:52:32 <startling> RosePerry, it would be no different than = at the top level
12:52:38 <applicative> if you do you module will turn into a sequence of imperatives!, as script!
12:52:43 <applicative> a script!
12:53:05 <luite> it will turn into BASIC!
12:53:33 <geekosaur> "let" is used to introduce a binding where an expression is expected
12:53:35 <Cale> RosePerry: let/in is an expression form and has a value
12:54:00 <geekosaur> at the top level you can't have expressions, so there is no need for (or use for) let
12:54:59 <geekosaur> (that is, "let ..." at the top level makes the same kind of sense as "2 + 3" by itself at the top level, namely none to speak of)
12:55:27 <luite> geekosaur: nah, let ... without `in' could more or less mean the same as let in a do block
12:55:27 <applicative> geekosaur: 2+3 at the top level should obviously print 5 when you load the file
12:55:43 <HairyDude> SHA takes an awfully long time to compile...
12:56:57 * applicative made a start at a fake imperative scripting language, it was interpreted basically be feeding the text line by line to a ghci process
12:57:05 <applicative> by feeding
12:58:25 <T_S_> c_wraith: thanks. Does it support multipart uploads?
12:58:47 <c_wraith> T_S_: not sure. didn't have a use case for that.
12:59:45 <HairyDude> hm. it's swapping a lot, maybe I should give virtualbox more memory
13:00:43 * hackagebot shelly 0.10 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.10 (GregWeber)
13:00:45 * hackagebot shelly-extra 0.2 - shelly features that require extra dependencies  http://hackage.haskell.org/package/shelly-extra-0.2 (GregWeber)
13:00:50 <T_S_> cool. at least I know it's in use. Might give it whirl then.
13:03:59 <ion> 600
13:04:01 <ion> whoops
13:04:43 <luite> ion: 755
13:05:32 <ion> 777
13:06:23 <ion> I like how chmod 777 is the answer to permission issues in web server-side scripting in many tutorials.
13:07:07 <armlesshobo> lol
13:07:10 <Jeanne-Kamikaze> :)
13:07:40 <startling> ion: "permissions error? that means you need to open the terminal and type 'chmod 777'"
13:08:05 <HairyDude> let me guess, these are mostly php tutorials
13:12:05 <RosePerry> how do I get the ith element from an enum?
13:13:31 <byorgey> @type toEnum
13:13:32 <lambdabot> forall a. (Enum a) => Int -> a
13:13:39 <byorgey> RosePerry: like that
13:14:13 <HairyDude> much better. SHA build no longer swapping like crazy
13:14:31 <RosePerry> Let's say I have a 2, and I want to get a Rank Two out of it
13:14:32 <RosePerry> data Rank = Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten | Jack | Queen | King | Ace
13:15:06 <Clint> RosePerry: are you deriving an Enum instance or making your own?
13:15:31 <RosePerry> What do you mean by "deriving an ENum instance?"
13:16:11 <startling> RosePerry, if you put deriving Enum underneat that data declaration, you can use toEnum 2
13:16:13 <HairyDude> stick "deriving Enum" on the end and you get toEnum 0 = Two
13:16:46 <HairyDude> or you can write your own and get toEnum 2 = Two
13:16:46 <RosePerry> got it, yes, this type derives Enum
13:17:22 <RosePerry> Where do I write toEnum 2?
13:17:24 <startling> oh right, you don't wnat toEnum
13:17:50 <HairyDude> startling: derived instance will give toEnum 0 = Two, which is probably not what RosePerry wants.
13:18:01 <startling> RosePerry: I'd write "fromNumber n = toEnum $ n + 2"
13:18:28 <RosePerry> How does haskell know which enum I'm referring to?
13:18:34 <startling> RosePerry, type inference
13:18:37 <startling> RosePerry: good question
13:19:12 <startling> RosePerry: if it's going to a function that takes a Rank, it'll know automatically. if it's ambiguous, you need to put in a type declaration
13:19:24 <RosePerry> startling: thanks!
13:27:52 <fuchsto_> is there a data type for a ring list?
13:28:33 <fuchsto_> in effect, i have an IOArray and i want to append an element and drop the first one
13:29:03 <fuchsto_> without having to shift every value by -1 positions
13:29:13 <geekosaur> arrays are bad for that.  Seq?
13:29:19 <HairyDude> like a fixed length FIFO queue?
13:29:37 <fuchsto_> HairyDude: Absolutely exactly correct
13:29:49 <ion> How about wrapping an array along with a shift value?
13:30:14 <c_wraith> Seq can fake it, with amortized O(1) access to the front and back, but it has no intrinsic support for fixed size
13:30:32 <fuchsto_> ion: So maintaining a start index?
13:30:39 <ion> yeah
13:31:00 <fuchsto_> ion: Hm, meh
13:31:32 <fuchsto_> ion: That would do, but it's a bit messy perhaps
13:31:43 <ion> Not really if you abstract it.
13:32:25 <c_wraith> ion: updates (assuming a pure structure) would be expensive.
13:32:25 <HairyDude> so you could probably wrap seq where (|>) is followed by a "drop 1"
13:32:54 <fuchsto_> it's easy with lists: fixedListPushFront xs y = take (length xs) $ y:xs
13:33:01 <HairyDude> (guessing that's the right append function, I haven't actually used Seq)
13:34:04 <fuchsto_> well, huge advantage of maintaining a start index as ion proposed: I can imagine there's no memory issues involved.
13:34:14 <fuchsto_> It's always exactly the same memory area
13:34:26 <fuchsto_> no realloc, in C terms
13:34:30 <startling> yeah, I would use a list like "circular = a : b : c : d : e : circular"
13:34:53 <c_wraith> fuchsto_: only if you use a mutable array, or never update the contents
13:35:12 <fuchsto_> i use IOArray ... it's an MArray, not a UArray, so i should be fine
13:35:37 <c_wraith> If you're already in mutable-land, just track the start point, yeah
13:35:49 <whittle> Is there a standard way to break cyclic module dependencies?
13:36:02 <fuchsto_> c_wraith: but thanks for pointing that out, i always wondered about the memory differences of MArray vs. UArray
13:36:16 <HairyDude> sigh. linux's cabal-dev still fails to resolve dependencies
13:36:32 <fuchsto_> whittle: In C++ you would forward-declare, like   theFun = undefined
13:37:05 <fuchsto_> so, declaring the function without an implementation. Don't know if that's okay for Haskell. Ususally the C/C++ way of things is dead wrong for Haskell
13:37:07 <whittle> fuchsto_: Right. And GHC has boot files that I can use like a C header file.
13:37:34 <fuchsto_> whittle: It has?
13:37:34 <whittle> fuchsto_: In Haskell, I don’t think I can get away with defining something twice.
13:37:37 <ion> whittle: Always avoid them. If you really, *really* can’t avoid one, use a .hs-boot file.
13:38:18 <fuchsto_> whittle: So, how would you solve that in a .hs-boot file?
13:39:09 <whittle> ion: I’m writing a library to consume the Twitter API. When I ask for a user, the API embeds a tweet in it. When I ask for tweets, each one includes a user.
13:39:53 <ion> whittle: That’s certainly not a reason to have a cyclic module dependency. Add a module like .Types that defines shared types and refer to them from both modules.
13:39:54 <RosePerry> In ghci, this expression is of type "Rank" ((getDuplicates $ getRanks hand) || 0), but when I load my code, it is type "Bool". Any ideas?
13:40:27 <ion> @type (||)
13:40:29 <lambdabot> Bool -> Bool -> Bool
13:40:37 <ion> @type (!!)
13:40:38 <SkooO> I have an interesting challenge: I get to teach an intern anything I want during 20 week period (1.5 days a week), and I offered him three choices: I teach him basic python, I teach him basic Haskell, or I teach him basic JavaScript. He chose Haskell. So now I am working through some books with him, giving him some basic programming problems that he has to solve functionally with Haskell. But
13:40:38 <SkooO> I am looking for an interesting little project for him. He is mostly into game development (any kind), but also likes to learn parsing/DSL design. Any ideas?
13:40:38 <lambdabot> forall a. [a] -> Int -> a
13:41:22 <geekosaur> || doesn't even typecheck there, did you mean !! ?  (or see ion)
13:41:24 <whittle> fuchsto_: I don’t know how to use hs-boot files. I was trying to avoid them, because my engineer-sense was tingling in that way that means “fragile!”
13:42:15 <RosePerry> Can I see an example of how forall gets a value out of an array?
13:42:34 <c_wraith> whittle: the standard approach is to refactor such that you have an acyclic graph.
13:43:22 <fuchsto_> whittle: Yeah, i now that feeling :(
13:44:51 <geoffh> SkooO: Write Yourself a Scheme in 48 hours?
13:45:10 <SkooO> geoffh, his background is PHP and a bit of C#
13:45:23 <SkooO> he has been programming for ~1.5 years
13:45:35 <SkooO> incredibly talented (which is why I wanted to expose him to Haskell early on)
13:45:42 <geoffh> SkooO: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
13:45:44 <SkooO> but not too familiar with functional programming
13:46:14 <SkooO> is it doable given said experience?
13:47:08 <geekosaur> RosePerry, forall does not get values out of everything, in fact it tends ot obscure values; what are you really trying to do?
13:47:26 <RosePerry> geekosaur: Thanks, I actually found I had || instead of !!
13:47:41 <SkooO> is there an open source project he could play with?
13:47:53 <SkooO> I remember a game called Nikki and the Robots or something?
13:49:01 <geoffh> SkooO: Maybe? I worked through it and had fun. I also knew some scheme though
13:49:24 <SkooO> he's still at the point where recursion scares him
13:49:33 <kqr_> what is known about the state of SSL in haskell? i have found two libraries, one which seems to be a wrapper to openSSL, and another Network.SSL which seems deceptively simple. is there any reason not to use Network.SSL?
13:49:40 <SkooO> though in fact he's grasped most of the basics in a single day
13:50:15 <SkooO> but his goal is game dev. I fear though that he has a very vague idea of what this actual encompasses
13:50:24 <SkooO> actually*
13:50:35 <whittle> c_wraith, ion: Is there a way to refactor that doesn’t involve dumping the types into a single module? That works fine for this situation, but I worry about what happens when this library gets more complex over time.
13:50:47 <SkooO> but question is: how much ground work should I lay before pushing him onto an open source project?
13:50:56 <c_wraith> whittle: no, dumping the types into a common module is pretty much the standard approach
13:51:22 <whittle> c_wraith: Good to know.
13:51:28 <whittle> c_wraith, ion: Thanks!
13:52:18 <shapr> SkooO: Raincat?
13:53:15 <shapr> SkooO: Have you already seen http://raincat.bysusanlin.com/ ?
13:53:26 <whittle> SkooO: What about letting him start his own thing; maybe a rogue-like? There are interesting resources out there for creating maps that might make for a good starting point.
13:53:48 <MostAwesomeDude> What *are* those resources? Is there anything better than SDL for writing games in Haskell right now?
13:55:00 <SkooO> shapr I have not, but I will now, cheers. whittle, I was thinking about that. Do you know where or how I could find those resources?
13:55:23 <shapr> Richard Braakman wrote a rogue-like a very long time ago...
13:55:25 * shapr digs around
13:55:48 <shapr> This is more than six years old: http://www.scannedinavian.com/~shae/mage-1.0pre35.tar.gz
13:55:54 <SkooO> initial goal is to broaden his perspective by showing him functional programming, and second is to give him a push towards his goals
13:55:57 <SkooO> thanks shapr
13:56:15 <shapr> I don't know if it still compiles or what.
13:56:26 <SkooO> will have a look with him monday
13:56:34 <shapr> I should really set up a github repo for all the old open source Haskell projects I have lying around.
13:57:04 <shapr> Wow, I have *lots* of old Haskell sources.
13:57:17 <shapr> Holy crap, I found malcolmw's remorse!
13:57:24 <Eduard_Munteanu> MostAwesomeDude: I guess cairo might work too, depending on the game
13:57:29 <shapr> I found the iohcc entries from 2007!
13:57:35 <Eduard_Munteanu> e.g. cairo and gtk2hs
13:57:49 <RosePerry> What's a good way to test if all elements in an array are the same value?
13:58:08 <SkooO> all (== x) ?
13:58:19 <RosePerry> Thanks!
13:58:38 <whittle> SkooO: Jamis Buck has written up a number of maze algos: http://www.jamisbuck.org/mazes/
13:58:40 <shapr> I should do another obfuscated Haskell code contest
13:58:45 <Eduard_Munteanu> :t all
13:58:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:59:05 <Eduard_Munteanu> Not sure if you get that for arrays.
13:59:21 <Eduard_Munteanu> @hoogle all
13:59:21 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
13:59:21 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
13:59:21 <lambdabot> Data.Monoid All :: Bool -> All
13:59:22 <SkooO> whittle: thanks
13:59:27 <illissius> :t Data.Vector.all
13:59:28 <lambdabot> Couldn't find qualified module.
13:59:31 <illissius> hm.
14:00:00 <shapr> Is anyone else using chrisdone's latest haskell-mode? How do I force a reload of the haskell-process?
14:00:21 <hpaste_> kmels pasted “findSequenceIndex” at http://hpaste.org/70019
14:00:48 <SkooO> RosePerry: I fear it was a function I wrote myself
14:00:48 <kmels> is the function above in Data.List? I think it could be useful
14:00:52 * hackagebot type-eq 0.1 - Type equality evidence you can carry around  http://hackage.haskell.org/package/type-eq-0.1 (GaborLehel)
14:00:57 <SkooO> will see if I can find it
14:01:23 <whittle> SkooO: Jamis’ blog (http://weblog.jamisbuck.org/) has explanations of most of the algorithms.
14:01:38 <SkooO> thanks a lot
14:02:34 <SkooO> he was very excited today about Haskell
14:02:42 <shapr> yay!
14:02:57 <SkooO> he could not believe how concise and fast it was
14:03:03 <fuchsto_> what should i do if i want an action performed for every element in an IOArray, or in a list?
14:03:32 <Eduard_Munteanu> fuchsto_: mapM?
14:03:48 <Eduard_Munteanu> :t mapM
14:03:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:03:53 <Eduard_Munteanu> :t mapM_
14:03:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
14:04:08 <fuchsto_> or mapM_ as i don't care about the return value. But somehow i fail at doing so :/
14:05:06 <Eduard_Munteanu> @hoogle mapM
14:05:07 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:05:07 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:05:07 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
14:05:10 <Eduard_Munteanu> @more
14:05:15 <Eduard_Munteanu> Bah.
14:05:21 <ski> @hoogle+
14:05:21 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
14:05:22 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
14:05:22 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
14:05:40 <Eduard_Munteanu> You want the last one.
14:05:52 * hackagebot type-eq 0.1.1 - Type equality evidence you can carry around  http://hackage.haskell.org/package/type-eq-0.1.1 (GaborLehel)
14:06:00 <lpvb> Skoo0: have you looked at this yet? http://www.amazon.com/The-Haskell-School-Expression-Programming/dp/0521644089/
14:06:18 <RosePerry> How can I find all the indices of a value in an array? e.g. 5 in  [ 2, 2, 5, 6, 5] would give me 2, 4
14:06:30 <ski> Eduard_Munteanu : is `IOArray i' really in `Foldable' ?
14:06:41 <kaini> RosePerry, elemIndices from Data.List
14:06:55 <RosePerry> kaini; thanks!
14:06:56 <fuchsto_> Eduard_Munteanu: Foldable? I really want to foldr it?
14:07:23 <SkooO> lpvb, I have not. He's currently working through Hutton's "Programming in Haskell" (at monstrous pace), and afterwards I will have him do part of LYAH. Would the book you suggested complement those?
14:07:27 <Eduard_Munteanu> fuchsto_: maps are folds too
14:08:24 <Eduard_Munteanu> ski: hm, not sure, but it should be
14:09:35 <Eduard_Munteanu> Ix i => Foldable (Array i)    http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
14:09:45 <lpvb> Skoo0: I would think so. The book has lots of examples of building graphics in functional and teaches reactive animation, things he might need for game development
14:10:02 <Eduard_Munteanu> So you can freeze the array, and map over it.
14:10:22 <SkooO> lpvb: alright, thanks
14:14:36 <illissius>     Could not deduce (f ~ Succ)
14:14:37 <illissius>     from the context (f i ~ Succ n)
14:14:41 <illissius> GHC I love you :(
14:27:12 <whittle> Oh, Haskell. Must you catch every stupid mistake I make?
14:27:45 <whittle> You and your type system are always watching over me for any screw-up.
14:28:15 <hpc> there's always common lisp
14:28:36 <whittle> So I can make meta-errors?
14:29:03 <hpc> or you can apply macros to the problem until it fits what you already have
14:31:25 <whittle> I learned Lisp before I had ever heard of unit testing. Going back to those days gives me the heebie-jeebies.
14:34:00 <hpc> unit needs no tests! it's either defined or undefined
14:34:56 <adamt> Or written by the common faultless developer.
14:36:09 <whittle> unit :: () -> Bool
14:36:20 <illissius> @check () == ()
14:36:21 <lambdabot>   "OK, passed 500 tests."
14:36:32 <whittle> Ha!
14:36:43 <otters> @check True
14:36:44 <lambdabot>   "OK, passed 500 tests."
14:36:46 <otters> okay, good.
14:36:56 <illissius> @check False
14:36:57 <lambdabot>   "Falsifiable, after 0 tests:\n"
14:37:15 <illissius> 0 is impressive, though
14:37:16 <whittle> Lambdabot didn’t need any tests?
14:37:28 <illissius> could tell just by looking at it!
14:37:29 <otters> it just /knows/, man
14:37:39 <illissius> @check fix error
14:37:40 <lambdabot>   No instance for (Test.QuickCheck.Testable [GHC.Types.Char])
14:37:40 <lambdabot>    arising from...
14:37:48 <illissius> @check fix error == fix error
14:37:49 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:38:00 <ion> @check const True
14:38:01 <lambdabot>   "OK, passed 500 tests."
14:38:30 <whittle> @src fix
14:38:30 <lambdabot> fix f = let x = f x in x
14:38:52 <otters> :t if'
14:38:53 <lambdabot> Not in scope: `if''
14:40:51 <hpc> @check mate
14:40:52 <lambdabot>   Add a type signature
14:40:58 <hpc> :(
14:41:10 <hpc> @check mate
14:41:12 <lambdabot>   "*Exception: (
14:41:26 <hpc> :(
14:41:30 <ion> : (
14:41:37 <hpc> was supposed to be
14:41:38 <hpc> (ノಠ益ಠ)ノ彡┻━┻
14:41:52 <armlesshobo> lol
14:41:53 <byorgey> hehe
14:42:01 <Jeanne-Kamikaze> can anyone give me the output of haddock --version please
14:42:25 <whittle> Haddock version 2.10.0, (c) Simon Marlow 2006
14:42:26 <whittle> Ported to use the GHC API by David Waern 2006-2008
14:42:30 <armlesshobo> Haddock version 2.10.0, (c) Simon Marlow 2006
14:42:30 <armlesshobo> Ported to use the GHC API by David Waern 2006-2008
14:42:37 <Jeanne-Kamikaze> thanks
14:44:09 <Jeanne-Kamikaze> for some reason the haddock freebsd port wants me to have haddock installed
14:44:12 <Jeanne-Kamikaze> I hope this hack works
14:44:54 <armlesshobo> who here went to Florida State University?
14:46:27 <Jeanne-Kamikaze> what's the parameter to make haddock spit the ghc version it was built with ?
14:47:36 <fmap> --ghc-version?
14:47:52 <Jeanne-Kamikaze> will try thanks
14:48:08 <HairyDude> :t "This is a string"
14:48:10 <lambdabot> [Char]
14:48:12 <HairyDude> hrm
14:48:17 <fmap> probably not
14:48:36 <Jeanne-Kamikaze> fmap, and what does it print exactly ?
14:48:36 <HairyDude>  :t doesn't work in a PM to lambdabot?
14:48:41 <hpc> no
14:49:06 <hpc> it's some plugin nincompoopery
14:49:56 <b_jonas> HairyDude: isn't there a @type command to replace it?
14:50:04 <b_jonas> @type True
14:50:06 <RosePerry> Will x:xs match an array of length 1?
14:50:06 <lambdabot> Bool
14:50:12 <b_jonas> HairyDude: ^
14:50:15 <HairyDude> so there is, thanks
14:50:29 <hpc> > let (x:xs) = ["yes"] in (x, xs)
14:50:30 <lambdabot>   ("yes",[])
14:50:37 <hpc> RosePerry: ^
14:51:02 <RosePerry> hpc: Thanks!
14:51:15 <HairyDude> :t let maybeRead :: Read a => String -> Maybe a; maybeRead = undefined in liftM fromIntegral <=< maybeRead
14:51:16 <lambdabot> forall b. (Num b) => String -> Maybe b
14:51:19 <HairyDude> :t let maybeRead :: Read a => String -> Maybe a; maybeRead = undefined in liftM fromIntegral . maybeRead
14:51:21 <lambdabot> forall b. (Num b) => String -> Maybe b
14:51:31 <HairyDude> so (.) = (<=<) in this case
14:56:01 <kaini> https://gist.github.com/042f24caa6edb1486e89 It feels so wrong - Is there any better way to accomplish this? This generates a string representation of a 2 dimensional field
14:56:23 <fuchsto_> i just discovered Control.Monad.Queue from Lloyd Allison ... any ideas where i could get usage examples for it?
14:56:32 <fmap> Jeanne-Kamikaze: cProjectVersion
14:56:33 <fuchsto_> the source does not contain example code
14:59:18 <RosePerry> how do I tell haskell what type a variable is?
14:59:19 <ski> > let x:xs = ["yes"] in (x, xs)  -- hpc,RosePerry, also like this
14:59:20 <lambdabot>   ("yes",[])
14:59:28 <ski> RosePerry : `variable :: Type'
14:59:32 <Peaker> kaini, you can use:   liftA2 (,) [0..w-1] [0..h-1]    to get a list of all coordinates
14:59:57 <Peaker> kaini, or replace (,) with (cellStr f)
15:00:04 <ski> RosePerry : however, you usually never *need* to do this -- but it's good to add such *type signatures* for your "top-level" operations
15:00:46 <ski> b_jonas : actually `:t' was added after `@type' :)
15:00:47 <Peaker> kaini, your folds seem like they are simple concatMaps anyway?
15:01:42 <RosePerry> I'm trying to test fromEnum in ghci. What's a good way to do so, if I have, say "data Rank = One | Two | Three deriving (Enum) ?
15:02:27 <ski> @type fromEnum
15:02:28 <lambdabot> forall a. (Enum a) => a -> Int
15:02:44 <ski> RosePerry : try `fromEnum One' e.g. ?
15:02:55 <ski> or `map fromEnum [One,Two,Three]' ?
15:02:57 <kaini> Peaker, that might be, since I didn't know concatMap until now
15:03:15 <kaini> Thanks for the hint
15:03:24 <ski> (btw, `deriving (Enum)' can be written as `deriving Enum')
15:03:42 <HairyDude> fuchsto_: looks like it's a monad. "enQ foo" adds an element, "deQ" removes one if it exists
15:04:11 <ski> HairyDude> :t enQ
15:04:15 <ski> HairyDude> :t deQ
15:04:38 <HairyDude> ski: enQ :: e -> Q e ()
15:04:45 <HairyDude> ski: deQ :: Q e (Maybe e)
15:04:49 <Peaker> kaini, well, concatMap f = concat . map f
15:05:22 <fuchsto_> HairyDude: It's    enQ :: MonadQueue e q => e -> q ()
15:05:38 <RosePerry> ski: Thanks!
15:05:38 <Peaker> kaini, note that a foldl is very inefficient if it ends up like:  ((((a++b)++c)++d) ...)   it's much more efficient to have (a ++ (b ++ (c ++ (...)))
15:05:45 <shapr> I'd love to get any critique on my new GSoC post: http://ghclive.wordpress.com/2012/06/15/june-update/
15:05:51 <fuchsto_> (from Control.Monad.Queue.Class)
15:05:56 <HairyDude> fuchsto_: um, which enQ is that?
15:06:17 <ski> HairyDude : so can one make an operation of type `Q (Q e ()) () -> Q e ()' ?
15:06:22 <HairyDude> fuchsto_: oh, right, I see
15:06:45 <fuchsto_> Hrmpf, actually i want an IOArray as FIFO
15:06:48 * HairyDude slaps HairyDude for replying to ski by mentioning fuchsto_ 
15:07:15 <HairyDude> fuchsto_: why do you want an IOArray?
15:07:45 <fuchsto_> HairyDude: I don't want an IOArray specifically, just a nice, performant buffer for signals
15:08:06 <fuchsto_> for every new signal: Push it to buffer. Remove last element from buffer. Render buffer.
15:08:11 <HairyDude> urgh, signals :)
15:08:30 <fuchsto_> HairyDude: The signals are the easy part so far
15:08:42 <fuchsto_> ('signal' as in 'sampled value')
15:08:49 <HairyDude> ah, not unix signals then
15:09:15 <fuchsto_> HairyDude: Nonono! 'Signal' as 'a sequence of samples'
15:09:41 <fuchsto_> Well, IOArray works nicely as a buffer, but it doesn't like being a FIFO
15:10:22 <HairyDude> fuchsto_: if your program is some sort of state monad, you could just write a transformer version of Q, make it a MonadQueue and add it to the stack
15:10:49 <HairyDude> but... tbh I don't have much experience in writing full programs :D
15:13:05 <Peaker> I wrote a circular-queue-over-array once, to solve a riddle
15:13:54 <Peaker> https://github.com/Peaker/slidingmax/blob/master/MFifoQ.hs
15:15:23 <fuchsto_> Peaker: Let me look into it ...
15:17:04 <fuchsto_> Peaker: look promising! Thank you
15:17:18 <ski> (`type family MFifoQOf (m :: * -> *) :: * -> *' looks like it'd be nicer there ..)
15:18:53 <fuchsto_> Peaker: So new 10 returns a queue of length 10
15:19:36 <fuchsto_> Peaker: What's a PolyRef?
15:21:30 <HairyDude> doing "vi ~/.emacs" makes me feel guilty
15:22:17 <Peaker> ski, yeah, probably
15:22:30 <Peaker> fuchsto_, it's in the same repo, basically a type-class around IORef/STRef
15:23:11 <monochrom> nano .vimrc
15:23:20 <fuchsto_> What do you need STRef for?
15:23:25 <Peaker> fuchsto_, it's not extensible, though, you can't add elements
15:23:26 <monochrom> eclipse .nanorc :)
15:23:34 <ski> fuchsto_ : when you want to use `ST s' instead of `IO'
15:24:00 <schovi> Hello. I am shortly new with Haskell and have hard fight with function definitions. I have simple following function
15:24:01 <schovi> collatz 1 = 1
15:24:01 <schovi> collatz n
15:24:02 <Peaker> fuchsto_, you mean why I need mutable refs? Or what STRefs particularly?
15:24:02 <schovi>   | even n    = n / 2
15:24:04 <schovi>   | otherwise = n * 3 + 1
15:24:06 <schovi> i can load it to ghci, but when i call it like 'collatz 10' it throw on me
15:24:08 <schovi> <interactive>:1:9:
15:24:10 <schovi>     Ambiguous type variable `a0' in the constraints:
15:24:12 <schovi>       (Num a0) arising from the literal `3' at <interactive>:1:9
15:24:14 <schovi>       (Integral a0) arising from a use of `collatz'
15:24:16 <schovi>                     at <interactive>:1:1-7
15:24:18 <schovi>       (Fractional a0) arising from a use of `collatz'
15:24:20 <schovi>                       at <interactive>:1:1-7
15:24:22 <schovi>     Probable fix: add a type signature that fixes these type variable(s)
15:24:24 <schovi>     In the first argument of `collatz', namely `3'
15:24:26 <schovi>     In the expression: collatz 3
15:24:28 <schovi>     In an equation for `it': it = collatz 3
15:24:38 <monochrom> use ST for imperative algorithms for pure functions
15:24:45 <kallisti> @where hpaste
15:24:54 <kallisti> schovi: in the future use a pastebin for large errors.
15:25:03 <kallisti> that error is happening because you're attempting to use / on an integral type
15:25:05 <schovi> kallisti: ups sorry
15:25:25 <kallisti> since / is a floating point operator and not an integra operator
15:25:33 <kaini> Peaker, https://gist.github.com/042f24caa6edb1486e89 it's much cleaner now :)
15:25:34 <kallisti> if you want integer division you should use the div operator
15:25:37 <kallisti> > 5 `div` 2
15:25:44 <kallisti> like that
15:25:53 <kallisti> (if lambdabot were here that would result in 2)
15:26:49 <fuchsto_> Peaker: so instead of newArray i would use MFifoQ.new
15:26:59 <Peaker> fuchsto_, yeah
15:27:14 <fuchsto_> Peaker: And you use a Ref on the current start index in the array?
15:27:34 <fuchsto_> Peaker: as in   hd <- newPolyRef 0
15:28:09 <Peaker> fuchsto_, yeah, head/count mutable refs
15:28:13 <schovi> kallisti: it just this! After this crash (tried to solve it for 20 minutes i guess :D ) i will remember that. Haskell is really 'mind switch' for me, but i love it! :) Thanks
15:28:21 <Peaker> some use head/tail, but that sucks because it cannot distinguish empty from full
15:28:46 <brendon43> http://www.reddit.com/r/nsfwhot/comments/tuc5r/hot_lesbians/
15:29:47 <fuchsto_> Peaker: Thank you, i'll see how far i'll get with it :) I think the performance will be fine, you keep using the same memory range
15:30:34 <Peaker> fuchsto_, yeah, I was solving an algorithmic riddle so I needed that structure for the complexity I wanted
15:31:07 <fuchsto_> Peaker: About an hour before, someone made this proposition (maintaining a queue head)
15:31:29 <Peaker> fuchsto_, what do you need a queue for?
15:33:48 <fuchsto_> Peaker: Rendering signals ...
15:34:05 <fuchsto_> Peaker: for every new signal: Push it to buffer. Remove last element from buffer. Render buffer.
15:34:30 <Peaker> fuchsto_, "rendering" as in graphics?
15:34:38 <fuchsto_> Peaker: Hm, type is  MFifoQ IOArray (Int, ValueT)  ?
15:34:45 <fuchsto_> Peaker: Yes, as in OpenGL
15:34:57 <Peaker> MFifoQOf IO
15:35:18 <Peaker> fuchsto_, (Int, ValueT) is your cell content?
15:35:39 <fuchsto_> Peaker: yes, actually i am using  IOArray Int GLfloat right now
15:35:46 <Peaker> fuchsto_, is a simple list as your queue a performance problem in practice?
15:36:03 <fuchsto_> Peaker: Well, it's a lotta signals ...
15:36:21 <fuchsto_> about 60Hz, so, well
15:36:25 <Peaker> fuchsto_, so you probably want:  MFifoQOf IO GLfloat ?
15:36:33 <fuchsto_> Peaker: got it :)
15:36:40 <Peaker> fuchsto_, 60 list operations per second sounds miniscule :)
15:36:46 <fuchsto_> Peaker: Well, errm, not quite
15:37:02 <fuchsto_> Peaker: the queue is a buffer of signals. A signal consists of samples. A sample is a GLfloat
15:37:18 <fuchsto_> Peaker: So i want a MFifoQOf IO Signal
15:37:29 <Peaker> every "tick", you replace a signal with another?
15:37:40 <Peaker> (append to one end, remove from the other)?
15:37:42 <fuchsto_> Peaker: with   newtype Signal = Signal { signalArray :: IOArray Int GLfloat }
15:38:20 <fuchsto_> Peaker: yes, every 1000/60 ms, i am adding a signal, removing the last one, and render the buffer
15:38:24 <Peaker> fuchsto_, if you iterate all the signals to render them anyway, I doubt the list copying overhead will be noticeable
15:39:05 <Peaker> you could have a list of your signal-as-array, and it'd probably be good enough
15:39:11 <fuchsto_> Peaker: there wouldn't be any lazy evaluation problem anyways, i just like how IOArray is bound to a memory area
15:39:32 <Peaker> every tick, you can do:   modifyIORef signalsRef ((newSignal:) . take count)
15:40:14 <fuchsto_> Peaker: modifyIORef? I am currently using   myIORef $=! ...
15:40:34 <Peaker> fuchsto_, if the next thing after the modifyIORef is rendering all the signals, it'll be forced anyway
15:40:40 <Peaker> how many signals will you have?
15:40:44 <hpc> if you are feeling extra silly, you can drop all the rotating array stuff, and just shift the framebuffer
15:40:57 <fuchsto_> Peaker: Hm, about 50 Signals with 512 samples each
15:41:07 <Peaker> fuchsto_, did you encounter a performance problem?
15:41:08 <fuchsto_> Peaker: It can be defined in the UI
15:41:18 <Peaker> fuchsto_, it sounds like -O2 would cover you with a list of signal arrays
15:41:20 <hpc> your draw operation becomes "move framebuffer over a square, draw current sample in that new empty space"
15:41:36 <fuchsto_> Peaker: No, i'm just extra cautious
15:41:42 <Peaker> fuchsto_, just 50 signals would be fine in a list.. 50 is really small
15:41:53 <Peaker> fuchsto_, and you don't need random access over it anyway
15:42:01 <fuchsto_> Peaker: Yes, but it's a 50 x 512 matrix
15:42:16 <Peaker> fuchsto_, no, the size of each signal is irrelevant.. the list has references in it
15:42:20 <fuchsto_> Peaker: Random access can become necessary, depending on how i render the stuff
15:42:36 <Peaker> fuchsto_, rendering of signals is inter-dependent?
15:42:41 <fuchsto_> Peaker: When rendering a surface with triangle strips, i do lots of random accesses
15:42:58 <fuchsto_> Peaker: Yes, due to how triangle strips work in OpenGL
15:43:15 <fuchsto_> Peaker: I have to weave lines between two signals
15:43:35 <Peaker> fuchsto_, again, I'm talking about the container-of-signals, not the signals themselves, which can remain arrays (though you might want them to be IOUArray if you care about performance)
15:43:47 <fuchsto_> Peaker: ...
15:43:55 <Peaker> fuchsto_, but that is still sequential access, not random access, iiuc
15:43:58 <fuchsto_> Peaker: Yeah, okay, that's very true
15:44:19 <fuchsto_> Peaker: I need random access between signals, but for 50, i should be fine
15:44:38 <Peaker> yeah, 60hz is easy with that
15:45:16 <fuchsto_> Peaker: I go  signal[0][0], signal[1][0], signal[1][1], signal[0][1]
15:45:45 <fuchsto_> in a nested loop over time (first index) and samples (second index)
15:45:47 <Peaker> why not prototype with lists of array, see if perf. is ok, and then move to array/fifoq of array if it isn't?
15:46:10 <fuchsto_> but you're absolutely right ... i won't need an IOArray for the first dimension
15:46:52 <fuchsto_> Yes, i will do that. But i have a copy of your MFifoQ (annotated with a link to your repo) just to be sure.
15:47:17 <fuchsto_> Peaker: Thanks for questioning my motivation :)
15:48:13 <unlink> is there some built-in arrow combinator equivalent to (arr id &&&)?
15:49:02 <Peaker> fuchsto_, also IOUArray is nicer if you have floats as values
15:50:09 <HairyDude> for the next Haskell revision, I wish for a programmable "deriving"
15:50:24 <fuchsto_> Peaker: why is that?
15:51:55 <hpc> :t ((,) <*>) -- unlink ?
15:52:03 <hpc> hmm
15:52:43 <geekosaur> HairyDude, http://hackage.haskell.org/package/derive / http://hackage.haskell.org/package/derive-gadt ?  or DrIFT?
15:53:36 <Peaker> fuchsto_, it is unboxed.. an actual array of floats, rather than an array of thunks
15:53:49 <HairyDude> oh, I hadn't thought about Data.Serialize
15:54:11 <Peaker> fuchsto_, the values are floats, not "lazy computations that may yield a float", you get auto-eagerness on the values, and much less indirection / memory cost
15:57:15 <HairyDude> @hoogle Generic
15:57:25 <HairyDude> @bot
15:58:06 <HairyDude> huh, lambdabot quit
15:58:26 <geekosaur> there's some odd network foo going on
15:59:07 <geekosaur> I'm hearing reports of some people having trouble loading xmonad.org, and I personally keep losing connectivity to various google-ish things
15:59:40 <HairyDude> what's the Generic that DeriveGeneric refers to?
16:03:13 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html
16:03:58 <fuchsto_> Peaker: No performance drop to see when using lists :)
16:04:29 <fuchsto_> Peaker: And thanks for the hint on IOUArray ... will try that
16:04:37 <HairyDude> ah, Serialize doesn't do what I hoped it did.
16:04:38 <geekosaur> as distinct from SYB or other older generics libraries
16:05:25 <Peaker> fuchsto_, cool :)
16:05:55 <HairyDude> (the answer is GHC.Generics.Generic, btw)
16:28:55 <shapr> wheee!
16:28:58 <shapr> Yay code!
16:38:03 <parcs`> i just thought of something neat: you can
16:48:07 <parcs`> you can use 'let's within a degenerate do-expression to neatly create local bindings that can't be mutually-recursive, which helps catch subtle bugs due to typos
16:50:46 <teneen> The example for buildExpressionParser in the parsec documentation does not work
16:50:48 <teneen> http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/src/Text-Parsec-Expr.html#buildExpressionParser
16:50:58 <monochrom> like this? do { let x = 0; let x = x + 1 } catches typoes?
16:51:56 <parcs`> monochrom: not that kind of typo, but the identity monad can catch that
16:52:21 <parcs`> i was thinking eg  "let a = blah; a' = foo a; a'' = bar a''"
16:52:49 <parcs`> i was thinking eg  "let a = blah; a' = foo a''; a'' = bar a'" :P
16:56:11 <parcs`> er, you need separate lets for each binding. but you get the idea
16:56:23 * hackagebot base64-bytestring 0.1.1.3 - Fast base64 encoding and deconding for ByteStrings  http://hackage.haskell.org/package/base64-bytestring-0.1.1.3 (BryanOSullivan)
16:58:42 <monochrom> right, I think of separate let's, too
17:01:26 * hackagebot text 0.11.2.2 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.2.2 (BryanOSullivan)
17:01:28 * hackagebot base16-bytestring 0.1.1.5 - Fast base16 (hex) encoding and decoding for ByteStrings  http://hackage.haskell.org/package/base16-bytestring-0.1.1.5 (BryanOSullivan)
17:01:30 * hackagebot bloomfilter 1.2.6.10 - Pure and impure Bloom Filter implementations.  http://hackage.haskell.org/package/bloomfilter-1.2.6.10 (BryanOSullivan)
17:20:01 <ion> Ooh, i might find the bloomfilter package useful.
17:26:26 * hackagebot set-monad 0.1.0.0 - Set monad  http://hackage.haskell.org/package/set-monad-0.1.0.0 (GeorgeGiorgidze)
17:38:10 <jfischoff> what's the easiest library to scale png's and jpg's?
17:38:19 <jfischoff> speed is not that important
17:42:04 <shapr> My code is getting complex enough that I need real unit tests.
17:42:36 <edwardk> its like you decided to spend the entire summer on it or something
17:42:54 <kallisti> shapr: psh. who needs unit tests.
17:43:05 <shapr> me me!
17:43:20 <kallisti> what are you writing, out of curiosity?
17:43:35 <monochrom> () is the unit that does not need tests :)
17:43:41 <kallisti> jfischoff: imagemagick? :P
17:43:42 <monochrom> @botsnack
17:44:16 <zzo38> Is this correct?   newtype Lens c1 c2 x y = Lens { runLens :: c1 x (c2 y x, y) }; instance (Arrow c1, Category c2) => Category (Lens c1 c2) where { id = Lens . arr $ (,) id; Lens f . Lens g = Lens (arr indexedWriterJoin . second f . g); }; indexedWriterJoin (x, (y, z)) = (x . y, z);
17:46:05 <edwardk> i have no idea what that is supposed to be =)
17:46:06 <kallisti> zzo38: correct as in "is it a category?"
17:46:16 <zzo38> kallisti: Yes, that is one question
17:46:27 * hackagebot prelude-extras 0.2 - Haskell 98 - higher order versions of Prelude classes  http://hackage.haskell.org/package/prelude-extras-0.2 (EdwardKmett)
17:46:29 <edwardk> indexedWriterJoin?
17:46:56 <zzo38> edwardk: It is supposed to be a lens based on two categories. indexedWriterJoin is the join operation for the indexed writer monad.
17:47:41 <zzo38> edwardk: Why can you not know what that is supposed to be?
17:48:07 <edwardk> because i was trying to figure out what you wanted to do with writers and didn't see the definition dangling there on theend
17:48:07 <zzo38> Isn't it clear?
17:48:39 <zzo38> edwardk: indexedWriterJoin is just the name I have this function; the name is not relevant
17:49:44 <zzo38> What I intended is that your Lens is what with my definition would have c1 and c2 both be (->)
17:49:57 <edwardk> zzo38: i pose to you the same question i pose to all the folks who keep throwing random monads in the middle of lenses. what do the laws mean in your generalization?
17:50:14 <zzo38> While a partial lens would have c1 being (Kleisli Maybe)
17:50:28 <zzo38> edwardk: Do you mean the category laws?
17:50:43 <zzo38> The category laws are the same for any category
17:51:10 <edwardk> i mean the lens laws, the store comonad coalgebra properties that any valid lens is required to provide, what do they translate to and are they useful?
17:51:29 * hackagebot void 0.5.6 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.6 (EdwardKmett)
17:51:31 <zzo38> edwardk: I also don't like throwing random monads in the middle of lenses; I prefer putting categories there instead
17:51:31 * hackagebot shelly-extra 0.2.1 - shelly features that require extra dependencies  http://hackage.haskell.org/package/shelly-extra-0.2.1 (GregWeber)
17:52:07 <zzo38> edwardk: I don't know what the laws are for a proper lens here, but I suppose you can still make improper lenses, as long as the category laws still apply
17:52:13 <edwardk> you can probably weaken the requirement from Arrow to a CCC
17:52:34 <zzo38> edwardk: Yes, OK
17:52:36 <edwardk> yes, but the problem is even with partial lenses the meaning of those laws is awkward enough
17:53:51 <zzo38> edwardk: Well, it seems c1 needs to be a tensor category with a functor from (->), as far as I can tell. Maybe there is a way to do it without a functor from (->)
17:56:40 <zzo38> But yes I suppose that a Cartesian closed category should be sufficient although I don't know much about that
17:58:38 <shachaf> Cale: Is lambdabot down?
17:58:56 <Cale> @bot
17:59:05 <Cale> I guess so
18:09:20 <Luke> I've got a "data X = X Float | Y Float" and I want to read an enum type of "x |  y" from postgresql-simple though I can't figure out how to build up the type with FromRow and FromField instances. I have a "instance FromField (Float -> X)" and then an "instance FromRow X where fromRow = field <*> field" I'm getting the error "No instance for (FromField (a0 -> X)) arising from a use of `field'"
18:09:26 <Luke> anyone see what i'm doing wrong?
18:12:24 <zzo38> My lens seems similar to the southern lenses where c1 is (Kleisli m) and c2 is (Kleisli w)
18:14:30 <zzing> Does ghc compile with clang 3.1?
18:30:03 <edwardk> hrmm. i think i need some kind of intermediate example for the library i'm working on
18:30:19 <edwardk> i have one that is haskell 98, nice and simple, and another that requires pretty much every extension known to man
18:31:31 * hackagebot bound 0.1 - Combinators for manipulating locally-nameless generalized de Bruijn terms  http://hackage.haskell.org/package/bound-0.1 (EdwardKmett)
18:31:47 <edwardk> for comparison, the easy example: https://github.com/ekmett/bound/blob/master/examples/Simple.hs
18:32:02 <edwardk> and the ridonculous example https://github.com/ekmett/bound/blob/master/examples/Exp.hs
18:32:11 <Eduard_Munteanu> H98 is even outdated :P
18:32:28 <edwardk> Eduard_Munteanu: when i say haskell 98 i usually state it to mean the intersection of haskell 98 and haskell 2010
18:32:50 <Eduard_Munteanu> Ah, so no n+k nonsense.
18:32:58 <edwardk> yeah
18:33:12 <edwardk> and i avoid the pattern guards because they don't really help
18:33:56 <edwardk> i'll probably do something with less strongly typed patterns perhaps
18:34:11 <edwardk> that way it doesn't require a million custom combinators to traverse
18:35:02 <Cale> ?
18:35:04 <shapr> I love it when my code actually works!
18:35:07 * shapr boings cheerfully
18:35:08 <Cale> I like pattern guards
18:35:31 <Cale> They're really nice for unpacking type constraints from lots of GADTs at once.
18:35:47 <Cale> rather than nesting cases over and over
18:36:03 <Cale> especially when things depend on each other
18:37:02 <Cale> edwardk: Or are you talking about the pain of desugaring them?
18:37:27 <edwardk> Cale: well, they are pretty convenient in some case statements i use from time to time
18:37:39 <edwardk> and when i have a package that is already using a bunch of extensions i use them with abandon
18:38:14 <Cale> Pattern guards are one of those things which save your life (as much as syntax sugar could) when you need them, but probably most code won't really need much of.
18:39:18 <Cale> I guess I don't really care whether they're in the standard or not, but I tend to care more about the implementation than the standard anyway :)
18:39:59 <saml> hey, is there utility function   Request -> ByteString  ?
18:41:56 <shapr> @hoogle Request -> ByteString
18:41:56 <lambdabot> Did you mean: Request a -> ByteString
18:41:56 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
18:41:56 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
18:42:06 <shapr> @hoogle Request a -> ByteString
18:42:07 <lambdabot> Network.HTTP.Base rqBody :: Request a -> a
18:42:07 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
18:42:07 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
18:42:12 <zzo38> What would be a colens?
18:42:44 <shapr> zzo38: Phil Colens? :-)
18:42:53 <zzo38> No I mean dual to a lens
18:42:56 <ion> Semicolens
18:49:53 <saml> hey, is there operator for bytestring append?
18:49:58 <zzo38> edwardk: Can you please write down what the laws would be for proper lenses?
18:50:05 <saml> +++ = append ?
18:52:26 <ion> saml: One could redefine (++) as mappend, then (++) would work. :-P
18:52:31 <parcs`> saml: <>
18:52:40 <ion> Ah, i forgot about (<>)
18:52:55 <shapr> :t (<>)
18:52:56 <lambdabot> Doc -> Doc -> Doc
18:53:05 <wagle> can anyone get to lambda-the-ultimate.org?
18:53:53 <ion> http://www.isup.me/lambda-the-ultimate.org
18:55:00 <Luke> I've got a "data X = X Float | Y Float" and I want to read an enum type of "x |  y" from postgresql-simple though I can't figure out how to build up the type with FromRow and FromField instances. I have a "instance FromField (Float -> X)" and then an "instance FromRow X where fromRow = field <*> field" I'm getting the error "No instance for (FromField (a0 -> X)) arising from a use of `field'". Anyone know what I'm doing wrong?
18:56:08 <ion> I’m not familiar with FromRow, but field <*> field looks strange.
18:56:29 <Luke> ion: agreed - i feel like I need a <$> though I'm not sure how it would work in
18:56:45 <Luke> http://hackage.haskell.org/package/postgresql-simple-0.1.4.3 btw
18:57:06 <rwbarton> I don't understand 'an enum type of "x |  y"'.
18:57:25 <Luke> postgresql has enum types
18:57:35 <Luke> my type has "x" and "y" as possible values
18:57:53 <rwbarton> where do the Floats come from then?
18:58:15 <Luke> there's a separate sql field that I want to combine into one haskell type
18:58:25 <Luke> data X = X Float | Y Float
18:59:55 <Luke> I feel like I should be using <$> though I'm not sure how it comes into play
19:02:41 <hpaste_> Luke pasted “postgresql-simple read” at http://hpaste.org/70023
19:02:55 <Luke> ^^ a more complete example
19:04:48 <rwbarton> Luke, oh
19:04:59 <rwbarton> it doesn't have any way to know the intermediate type should be Float
19:05:10 <Luke> right - how do I tell it that?
19:05:13 <rwbarton> you could be using instance FromField Char and instance FromField (Char -> X)
19:05:16 <rwbarton> add a type annotation of some kind
19:05:18 <Luke> I tried doing (field :: Float)
19:05:44 <rwbarton> it should be (field :: A Float) where A is whatever Applicative instance is involved with this <*>
19:06:43 <Luke> I'm unclear on what A would be in this case?
19:06:53 <parcs`> :t (pure.) . (<|>)
19:06:54 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a. (Applicative f, Alternative f1) => f1 a -> f1 a -> f (f1 a)
19:07:02 <rwbarton> your guess is undoubtably better than mine
19:07:07 <parcs`> :t (.pure) . (<|>)
19:07:08 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> a -> f a
19:07:18 <Luke> RowParser from the library possibly?
19:07:24 <rwbarton> what's the type of 'field'?
19:07:37 <edwardk> zzo38: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285 gives the laws
19:08:16 <Luke> yeah that was it rwbarton - thanks!
19:08:19 <Luke> it was type RowParser
19:08:42 <Luke> so it knew Float but it didn't know the Functor type
19:08:45 <Luke> ?
19:08:58 <rwbarton> no, the opposite
19:09:21 <Luke> oh but to specify the Float type, it had to be in the context of the Functor explicitly?
19:09:36 <rwbarton> yeah, you have to give type signatures that are correct :)
19:09:50 <rwbarton> here it would be helpful to give a "partial type signature" (field :: _ Float), but those don't exist
19:10:50 <Luke> ah
19:11:12 <Luke> or type (field :: a Float)
19:11:35 <Luke> thanks for your help. there's literally no way I would have figured this out on my own
19:11:42 <rwbarton> that is wrong though, it means field :: a Float for any a whatsoever
19:12:04 <Luke> _ doesn't mean "anything whatsoever?"
19:12:17 <Luke> in the case you gave
19:15:26 <rwbarton> well it doesn't mean anything in reality
19:15:34 <rwbarton> but it would mean "figure out what should go here"
19:15:42 <rwbarton> as opposed to "anything can go here"
19:21:21 <rodayo> I'm writing a fucking that takes a list of tuples of Ints and returs a list of the sum of each individual pair. (i.e. [(Int,Int)]->[Int]) I can't seen anything plainly wrong with what I've written and the error message I'm getting doesn't make sense. Could someone take a look: http://pastie.org/4095701
19:22:18 <rodayo> Well I can't believe I misspelled "function" so badly...freudian slip eh
19:24:18 <shachaf> rodayo: Your types don't match.
19:24:32 <shachaf> It's the same issue in both lines.
19:24:36 <shachaf> What's the type of fst x + snd x?
19:24:56 <shachaf> (By the way, you can pattern-match directly, as in "f ((a,b):...) = ...".)
19:24:59 <rodayo> ooo so need the brackets right?
19:27:08 <rodayo> Yeh, that fixed it. =)
19:27:12 <rodayo> thx
19:27:52 <JoeyA> Who maintains the channel topic?  It should be updated to point to http://www.haskell.org/ghc/download_ghc_7_4_2 , I think.
19:46:20 --- mode: ChanServ set +o JoeyA
19:46:25 <shapr> JoeyA: fix it?
19:47:32 --- topic: set to '["Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]' by JoeyA
19:47:33 --- topic: set to '["Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.1: http://is.gd/vkWMMa ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]' by ChanServ
19:47:33 --- mode: ChanServ set -o JoeyA
19:47:46 <shapr> aw
19:47:49 <JoeyA> Hmm, that didn't save what I typed...
19:47:51 <JoeyA> http://is.gd/EllZnn
19:48:06 <JoeyA> err, nevermind
19:48:28 --- mode: ChanServ set +o JoeyA
19:48:31 <JoeyA> It seems I've overstepped my authority
19:48:35 <shapr> JoeyA: try it again?
19:48:45 <shapr> I dunno if the topic is locked...
19:48:46 * shapr checks
19:48:52 --- topic: set to '["Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]' by JoeyA
19:48:59 <shapr> JoeyA: looks good :-)
19:49:08 --- topic: set to '["Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.1: http://is.gd/vkWMMa ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]' by ChanServ
19:49:08 --- mode: ChanServ set -o JoeyA
19:49:14 <shapr> or not :-|
19:49:20 * shapr kicks ChanServ
19:49:26 <JoeyA> heh
19:49:47 <JoeyA> meh, I forgot to put a space after the URL for the benefit of IRC clients, so no biggie.
19:50:30 --- mode: ChanServ set +o shapr
19:50:42 --- topic: set to '["Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]' by shapr
19:50:48 <shapr> ?
19:50:50 * shapr waits
19:51:00 <shapr> ChanServ: I guess you're nice to me?
19:51:05 <shapr> JoeyA: Thanks for pointing that out :-)
19:51:11 --- mode: shapr set -o shapr
19:51:27 * shapr reads docs
19:51:42 <newsham_> man shapr
19:52:01 <shapr> Aha, I have the +t flag in the #haskell access list, as show by /msg chanserv access #haskell list
19:52:04 <shapr> That explain it.
19:52:25 <tgeeky_> doesn't explain the tides, though
19:52:32 <tgeeky_> can't explain that.
19:52:35 <shapr> tgeeky_: I think that's the moon.
19:53:20 <tgeeky_> shapr: Surely the great Bill O'Rielly would have accounted for the moon
19:53:24 <JoeyA> Today's tides were grown in Shelley, Idaho.
19:54:23 <tgeeky_> do you know what life would be like, if it weren't for the moon?
19:54:34 <ion> Well, the moon may explain the tides, but you certainly can’t explain the moon.
19:55:07 <edwardk> hrmm, any ideas on how to clean up the code for https://github.com/ekmett/bound/blob/master/examples/Deriving.hs ?
19:55:15 <edwardk> trying to get this down to an elegant example
19:55:18 <JoeyA> > map ord "’"
19:55:20 <lambdabot>   [8217]
19:55:41 <shapr> I'm checking in my jquery-console using hint prototype, w00t!
19:55:52 <edwardk> i've shrunk it about as far as i can think of without doing anything unreasonable
19:56:37 * hackagebot bound 0.1.1 - Combinators for manipulating locally-nameless generalized de Bruijn terms  http://hackage.haskell.org/package/bound-0.1.1 (EdwardKmett)
19:56:41 <JoeyA> edwardk: What does the (first) Int do in Lam {-# UNPACK #-} !Int (Pat Exp a) (Scope Int Exp a)  ?
19:56:54 <JoeyA> I guess that's a de Bruijn index.
19:56:56 <edwardk> JoeyA: it just memoizes the number of variables bound by Pat Exp a
19:57:03 <JoeyA> oh
19:57:12 <edwardk> this is sort of a 'chunky' de bruijn indexing scheme
19:57:35 <edwardk> all those pattern variables are bound at the same time, and its using a generalized debruijn scheme where you can 'succ' whole expression trees to improve sharing
19:57:45 <edwardk> thats all taken care of for you by "Scope"
19:58:23 <edwardk> which is the ubiquitous "expression with one more variable" construction, just generalized to "expression with n more variables, where we can succ trees"
19:58:26 <tgeeky_> edwardk: add unfoldale instances (and biunfoldable instances) where appropriate
19:58:34 <edwardk> tgeeky_: =P
19:59:04 <tgeeky_> edwardk: wat? bad idea?
19:59:12 <JoeyA> Holy smokes, is that a Haskell compiler in <100 lines?  :D
19:59:20 <edwardk> not yet ;)
19:59:31 <edwardk> but i wanted to show some interesting features
19:59:53 <JoeyA> doc comment parse failed:  "I am not a number, I am a /free monad/!"
19:59:57 <edwardk> the next example will probably show how to keep user names
20:00:01 <edwardk> gah
20:00:04 <edwardk> i'll go fix that
20:01:26 <JoeyA> edwardk: Did you mean to backslash-escape the quotes?
20:01:44 <edwardk> yeah
20:02:01 <edwardk> i always forget haddock's rules which is why i don't write much documentation ;)
20:02:10 <tgeeky_> edwardk: plus they are really fucking frustrating
20:02:23 <edwardk> haddocks should build now
20:02:28 <edwardk> i just pushed
20:02:37 <edwardk> should ding on the channel in a minute or two
20:02:38 <tgeeky_> this looks like a much cooler version of the lifting lemma stuff that I copied from Hinze
20:03:00 <edwardk> my goal was to make a library where you can work with names non-monadically and not have it suck
20:03:19 <edwardk> its also completely haskell 98 =P
20:03:29 <JoeyA> edwardk: Would that be applicable to an embedded DSL that generates code?
20:03:34 <edwardk> yeah
20:03:44 <edwardk> because its very easy to use the resulting dsl
20:03:48 <edwardk> just use instantiate
20:04:03 <edwardk> i was thinking about adding an evaluator to the example
20:04:39 <edwardk> i have 2 other examples there, one doesn't support patterns and doesn't use any extensions, the other is crazy and uses everything, and gets almost as far as the Deriving example
20:04:54 <edwardk> i rather prefer the Deriving approach, since its far less code
20:04:59 <edwardk> and doesn't require anything exotic
20:05:26 <tgeeky_> edwardk: can you put the outputs of ghci in the bottom there
20:05:40 <edwardk> i could be talked into that =)
20:05:57 <tgeeky_> preferrably in the doctest format -- >>> expr\n-- result
20:06:13 <tgeeky_> this is really, really, really, small and simple
20:06:21 <edwardk> ghci> lam (varp "x") (Var "x")    => Lam 1 VarP (Scope (Var (B 0)))
20:06:23 <tgeeky_> if it's anywhere close to a haskell compiler
20:06:38 * hackagebot bound 0.1.2 - Combinators for manipulating locally-nameless generalized de Bruijn terms  http://hackage.haskell.org/package/bound-0.1.2 (EdwardKmett)
20:06:58 <edwardk> so that becomes -- >>> lam (varp "x") (Var "x")\n-- Lam 1 VarP (Scope (Var (B 0)))
20:06:59 <edwardk> ?
20:07:08 <edwardk> what uses doctest?
20:07:16 <tgeeky_> edwardk: doctest uses the REPL format of haddock
20:07:17 <tgeeky_> which is:
20:07:32 <tgeeky_> -- >>> 1 + 1
20:07:35 <tgeeky_> -- 2
20:07:56 <tgeeky_> if you do that with your examples, and then run doctest, it will verify your examples output what they say
20:08:11 <JoeyA> edwardk: Why did you decide to include ViewP (which I guess means "view pattern") in your example?  Does it present an interesting and important challenge?
20:10:04 <edwardk> JoeyA: well, done correctly a view pattern can see things earlier than it in the pattern set
20:10:11 <edwardk> so i need to actually implement it as Scoped as well
20:10:24 <edwardk> (i just haven't done so yet)
20:10:47 <edwardk> so its an interesting problem, much like the telescope example from unbound
20:12:50 <edwardk> e.g.
20:12:56 <edwardk> \x (x -> y) -> y
20:13:12 <edwardk> or \(Foo x (x -> y)) -> y
20:13:47 <edwardk> but for some reason they didn't get fancy and allow \(x -> x) -> x
20:14:49 <edwardk> @hpaste
20:14:49 <lambdabot> Haskell pastebin: http://hpaste.org/
20:15:09 <hpaste_> edwardk pasted “bound doctests for tgeeky” at http://hpaste.org/70024
20:31:40 * hackagebot wizards 0.1 - High level, generic library for interrogative user interfaces  http://hackage.haskell.org/package/wizards-0.1 (LiamOConnorDavis)
20:32:02 <JoeyA> I'm working on a JavaScript code generator whose input is a little more "abstract" than an abstract syntax tree.  For example, variable declaration is represented by a constructor like this: ExprVar (VarName -> Expr).
20:32:46 <edwardk> tgeeky: does the doctest stuff have any problem with other comments in the immediate area?
20:32:55 <edwardk> id like to comment above some of the examples why they are interesting
20:33:08 <edwardk> or does it only look at the -- immediately after the >>>
20:36:27 <slack1256> to get an account on hackage. the mail I sent is replied automatically (and should have a certain format) or interpreted by a person?.
20:38:39 <edwardk> JoeyA, tgeeky : https://github.com/ekmett/bound/blob/master/examples/Deriving.hs
20:38:56 <edwardk> added the doctests (but can't get doctest to install), and made view patterns work like ghc
20:41:59 <RosePerry> I'm trying to learn about monads. I'll post some code, and then a description of the code. My question is, in the description, what does "the result of the IO, (), the (), and does another IO ()" mean?
20:42:03 <RosePerry> parrot :: IO String
20:42:04 <RosePerry> parrot = getLine >>=
20:42:05 <RosePerry> \ln -> putStrLn ("You just said " ++ ln) >>=
20:42:07 <RosePerry> \_ -> putStrLn "BAAAAAK. I’m a parrot" >>=
20:42:08 <RosePerry> \_ -> return ln
20:42:10 <RosePerry> getLine has type IO String, and the lambda in the second line has type String -> IO ().
20:42:11 <RosePerry> The next »= takes the result of the IO (), the (), and does another IO (). Finally, the
20:42:13 <RosePerry> third line takes the String from the original getLine and upgrades it to an IO String with
20:42:14 <RosePerry> return. If this upgrade didn’t happen, you coudln’t use a bind. The types make sure you
20:42:14 <RosePerry> can’t leak something of type String after doing IO stuﬀ
20:42:21 <shachaf> RosePerry: Please don't paste more than a couple of lines in here.
20:42:23 <shachaf> Use hpaste.org
20:42:28 <RosePerry> ah, sorry
20:42:33 <shachaf> RosePerry: Are you trying to learn about monads or about IO? They're two different things.
20:42:41 <RosePerry> monads
20:42:49 <mauke> then I'd ignore IO for now
20:43:35 <RosePerry> mauke: Is this an example of a monad?
20:43:47 <mauke> yes
20:43:51 <shachaf> RosePerry: According to some people, no one knows!
20:43:56 <shachaf> But at any rate it's a weird instance of Monad.
20:45:10 <shachaf> RosePerry: Note that if you want to do IO, learning about IO before learning about Monad is fine!
20:45:41 <RosePerry> Hm, alright. Do you think you could answer my question above?
20:46:15 <shachaf> RosePerry: It's more than just the type.
20:46:16 <mauke> oh, there was a question in there?
20:46:30 <mauke> it looked like a paste from a pdf
20:46:31 <shachaf> A value :: IO String isn't a "tainted" String -- it doesn't contain a String at all.
20:46:47 <shachaf> So it's not an issue of a String leaking.
20:47:14 <shachaf> Oh, that's a paste from an introduction, not your question.
20:47:23 <shachaf> I suggest that you should read another introduction. :-)
20:47:25 <JoeyA> @quote /bin/ls
20:47:25 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
20:47:43 <RosePerry> I apologize. My question was in the very first line I posted
20:48:39 <shachaf> RosePerry: I suggest that that paragraph is pretty confusing and you're better off finding a different paragraph than trying to untangle that one at this point.
20:49:10 <RosePerry> shachaf: Alright, thank you.
20:49:23 <shachaf> Also, please don't try to "learn about IO" and "learn about Monad" at the same time. :-)
20:49:26 <shachaf> RosePerry: Have you seen the FAQ?
20:49:26 <shachaf> @where faq
20:49:27 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
20:49:58 <RosePerry> schachaf: Thanks! I'm checking it out.
20:53:35 <yongliang> @hoogle runListT
20:53:36 <lambdabot> Control.Monad.List runListT :: ListT a -> m [a]
20:53:36 <lambdabot> Control.Monad.Trans.List runListT :: ListT m a -> m [a]
20:53:41 <yongliang> Oh, neat.
20:54:38 <tgeeky> edwardk: doctest looks at the consecutive lines after --, unfortunately. And it won't even see those (they have to be connected to a typedecl via -- ^ or -- |
20:54:43 <tgeeky> edwardk: which I think is dumb
20:55:09 <edwardk> oh
20:55:27 <edwardk> then i probably won't go out of my way to support it here since they'll clutter up the main definitions
20:57:21 <yongliang> Hey. Is there anything like "read", but which yields a Maybe T instead of a T?
20:57:43 <yongliang> (Nothing meaning no value could be read.)
20:58:19 <rwbarton> you can use "reads"
20:58:47 <rwbarton> there isn't anything exactly like what you're asking for in the standard libraries, though it would be useful and I'm sure it exists in various libraries on hackage
20:58:50 <shachaf> I wonder what it would take to get this added to the standard library.
20:59:05 <yongliang> Actually, it would be nice if read by default returned a Maybe T.
20:59:14 <yongliang> And then I would be able to decide what to do with the Nothing value.
20:59:23 <shachaf> yongliang: I don't think many people disagree with you.
20:59:24 <yongliang> (Attempt to read again, throw an error, whatever.)
21:02:05 <applicative> > let mread = map fst . reads in map mread ["124","1","hello", "264"] :: [[Int]]
21:02:07 <lambdabot>   [[124],[1],[],[264]]
21:03:06 <applicative> there isn't really any advantage in getting a maybe is there? you just write case mread str of []  -> putStrLn "not a number", ...
21:04:37 <shachaf> Maybe has a bunch of nice combinators.
21:05:08 <yongliang> applicative: If you don't need it, you could use some function that takes a Maybe, expecting it to be Just x, and takes the x out.
21:06:00 <yongliang> But reading input from the user seems like an operation that cannot be guaranteed to return a valid result. Only Maaaaaaaaaaaaaybe.
21:06:07 <rwbarton> @type readIO
21:06:08 <lambdabot> forall a. (Read a) => String -> IO a
21:06:32 <rwbarton> clearly this is precedent for readMaybe, readList, readError, ...
21:06:32 <applicative> yongliang: the reads function always returns a value
21:06:49 <yongliang> @src reads
21:06:50 <lambdabot> reads = readsPrec minPrec
21:07:47 <applicative> reads fits the general formula:  a parser of things is a function from strings to a list of pairs of things and strings.
21:07:51 <yongliang> @hoogle readMaybe
21:07:52 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
21:07:52 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
21:10:18 <applicative> @src read
21:10:18 <lambdabot> read s = either error id (readEither s)
21:10:34 <applicative> @src readEither
21:10:35 <lambdabot> Source not found. My pet ferret can type better than you!
21:12:46 <rwbarton> wait, what?
21:12:52 <rwbarton> @type readEither
21:12:54 <lambdabot> Not in scope: `readEither'
21:12:58 <rwbarton> @hoogle readEither
21:12:58 <lambdabot> No results found
21:13:30 <shachaf> Apparently it's unexported.
21:13:35 <rwbarton> ah yes I see
21:13:44 <shachaf> What a scam.
21:14:09 <shachaf> I've never seen Prelude.read: ambiguous parse
21:16:50 <applicative> yes, the types suggest its possible
21:57:13 <james-ubyssey> hey is there any indent standards for haskell?
21:57:24 <shachaf> Lots.
21:57:35 <james-ubyssey> um where can i find them? O.,o
21:57:57 <james-ubyssey> quick googling  comes up with a bunch of diffrent answers
21:58:02 <james-ubyssey> pretty conflicting
21:58:49 <james-ubyssey> like it says he haskell report stats a tab is 8 spaces but on every giude i find it says to set it to 4 and sometimes 2
22:01:23 <JoeyA> In my opinion, the most important thing is: use spaces instead of tabs.
22:02:27 <mauke> james-ubyssey: what do you mean by "it"?
22:03:11 <james-ubyssey> *it says in
22:03:39 <mauke> ... "says to set it to 4 and sometimes 2"  <- that 'it'
22:04:17 <geekosaur> there is a difference between tab as the encoding and tab as the operation; the latter is often referred to as the indent offset or similar to try to avoid the confusion
22:15:08 <edwardk> hrmm
22:15:32 <edwardk> can someone who hasn't been staring at this thing crosseyed for a half hour take a look at https://github.com/ekmett/bound/blob/master/examples/Simple.hs and see if they can spot the bug in the cooked example?
22:16:05 <edwardk> it should be a straight transcription of the tail end of http://www.augustsson.net/Darcs/Lambda/top.pdf
22:17:37 <edwardk> i think i either screwed up some of the lambda calculus terms or i messed up the nf/whnf
22:18:39 <rking> edwardk: I am of no use (don't yet know Haskell), but I have this to ask. Why does Github default to a proportional font?
22:19:13 <edwardk> it doesn't when viewed on my machine, if you are looking through the code there
22:19:52 <rking> On that s
22:20:15 <rking> ...same URL you pasted?
22:20:20 <edwardk> yeah
22:20:23 <JoeyA> Renders in a fixed-width font for me.
22:20:29 <edwardk> all the columns line up for me
22:21:48 <JoeyA> edwardk: I'm 1/3 of the way through skimming through the lambda calculus definitions.  Perhaps this bug is a sign that your library has a usability bug ;-)
22:21:55 <edwardk> hah
22:21:56 <rking> Oh, weird. I'm on my phone, and Dolphin is proportional while FF is fixed.
22:22:07 <edwardk> well, this was just a transcription so i'd have a scary big example ;)
22:22:13 <edwardk> i don't recommend coding this way ;)
22:22:29 <mauke> it's in a <pre> tag and the CSS specifies monospace
22:22:32 <nyingen> How do I catch the "read: no parse" exception?
22:22:36 <JoeyA> Why not lam $ \x -> (where x has a variable type) ?
22:22:38 <edwardk> i can bang out a parser once i get a bit farther
22:22:42 <mauke> nyingen: by not using read
22:22:46 <JoeyA> Ah
22:22:49 <edwardk> JoeyA: you need to supply it a name still
22:22:52 <rking> Default browser gets it wrong, too. Anyway.
22:22:56 <edwardk> its not hoas
22:23:09 <JoeyA> hoas?
22:23:13 <nyingen> mauke: Sure, but I'm literally interested in catching that exceptio from 'read'. Is it possible?
22:23:15 <edwardk> higher order abstract syntax
22:24:26 * rking learns him a Haskell for great good.
22:24:35 <shachaf> edwardk: Yes, there's a bug.
22:24:38 <shachaf> In fix
22:24:44 <shachaf> ("fix", lam "g" $ (lam "x" $ V"g":@V"x":@V"x") :@ (lam "x" $ V"g":@V"x":@V"x"))
22:24:46 <JoeyA> V"g":@V"x":@V"x"
22:24:47 <edwardk> oh?
22:24:52 <JoeyA> Dang, shachaf won
22:24:52 <shachaf> :@ is infixl
22:25:04 <JoeyA> (g x) x instead of g (x x)
22:25:08 <edwardk> aha
22:25:13 <edwardk> hanks
22:25:15 <edwardk> er thanks
22:25:22 <shachaf> thanks, hanks. thanks.
22:25:27 <nyingen> Why does 'handle' or 'try' deal with 'head []' correctly, but not an erroneous 'read' ?
22:25:28 <JoeyA> tanks
22:25:38 <shachaf> edwardk: I wonder whether an infix operator for lambda would make that more readable.
22:25:55 <edwardk> yep. it works =)
22:25:59 <edwardk> evaluates to true
22:26:05 <edwardk> possibly
22:26:09 <edwardk> yeah
22:26:11 <edwardk> i can see that
22:26:14 <edwardk> :\ or something
22:26:28 <shachaf> Maybe $\
22:26:30 <edwardk> or just .
22:26:47 <edwardk> (!)
22:26:48 <edwardk> ?
22:26:56 <shachaf> ==>?
22:27:15 <edwardk> hrmm, want minimal number of chars
22:27:20 <shachaf> →
22:27:26 <edwardk> ! is the shortest not bound by preude i can think of
22:27:27 <shachaf> Give in to the Unicode.
22:27:36 <shachaf> (Come on, it would make it more readable.)
22:28:01 <macUzer> how do I locate the package name using a partial module name?
22:28:05 <shachaf> edwardk: You should've called the commit "fix fix". :-(
22:28:14 <yongliang> @hoogle runListT
22:28:15 <lambdabot> Control.Monad.List runListT :: ListT a -> m [a]
22:28:15 <lambdabot> Control.Monad.Trans.List runListT :: ListT m a -> m [a]
22:28:23 <yongliang> @hoogle runMaybeT
22:28:23 <lambdabot> Control.Monad.Trans.Maybe runMaybeT :: MaybeT m a -> m (Maybe a)
22:28:54 <yongliang> Is there any reason to prefer importing Control.Monad.List vs Control.Monad.Trans.List ?
22:29:01 <JoeyA> nyingen: Are you using 'read', or some flavor of it like 'readIO' (which throws an IOException instead of an ErrorCall) ?
22:29:02 <yongliang> (The same for Error and State)
22:29:45 <mzero> nyingen: are you sure? are you perhaps using the wrong versions of handle or try (there are several)
22:29:55 <mzero> though, off hand, why would you want to do this?
22:30:01 <nyingen> 'read' isn't the point
22:30:07 <shachaf> edwardk: You should totally use OverloadedStrings there, too!
22:30:09 <JoeyA> Also, could you post an isolated example?  If you want to catch an exception in pure code, you have to evaluate it first.
22:30:16 <nyingen> I'm just surprised that, in ghci, I can catch the head: empty list error, but not the read error
22:30:17 <edwardk> thought about it =)
22:30:42 <shachaf> Also, overload them to do function application.
22:30:45 <edwardk> the problem there is that Exp String makes a crappy target for OverloadedStrings
22:30:45 <shachaf> So you don't need :@
22:30:50 <nyingen> mzero: I'm just using Control.Exception
22:31:51 <JoeyA> So handle (...) (return (read "")) won't catch the error, but handle (...) (evaluate (read "")) will.
22:32:02 <nyingen> JoeyA: Interesting
22:32:10 <nyingen> your first example was what I tried
22:32:16 <nyingen> why doesn't that work?
22:32:34 <edwardk> ok, with the ! for infix lam its a lot nicer
22:32:36 <nyingen> I'm just looking for enlightenment, not solutions :)
22:32:55 <shachaf> edwardk: No Unicode? :-(
22:33:00 <geekosaur> because it's lazy, so the read will be performed when the value is required which usually is outside the handle
22:33:14 <macUzer> @hoogle median
22:33:14 <lambdabot> No results found
22:33:23 <shachaf> →
22:33:23 <macUzer> @hoogle statistics
22:33:24 <lambdabot> package statistics
22:33:24 <lambdabot> package statistics-fusion
22:33:24 <lambdabot> package statistics-linreg
22:33:34 <edwardk> pushed
22:33:42 <edwardk> https://github.com/ekmett/bound/blob/master/examples/Simple.hs
22:33:49 <shachaf> ⇒
22:34:01 <nyingen> geekosaur: hm, I see
22:34:10 <edwardk> ! at least has the . in it ;)
22:34:36 <shachaf> ⤑
22:34:38 <shachaf> Lots of dots!
22:34:39 <mzero> ah - laziness....
22:34:45 <shachaf> ⤞
22:34:46 <edwardk> hah
22:34:48 <JoeyA> nyingen: If a pure value contains an error value inside, no error will be thrown until an attempt to use the value is made.
22:34:59 <nyingen> though I don't immediately see why that doesn't apply to 'head []' as well
22:35:14 <JoeyA> nyingen: Lemme guess, you did this?  > handle (...) (head [])
22:35:32 <shachaf> ⊸
22:35:35 <JoeyA> This type checks, because [] could be a list of IO actions.
22:35:39 <shachaf> OK, that's kind of horrible.
22:35:46 <nyingen> JoeyA: yes
22:35:48 <shachaf> ⟿
22:36:09 <shachaf> Come on, ⟿  is great.
22:36:18 <edwardk> =)
22:36:28 <shachaf> ⥅
22:36:35 <JoeyA> In order to perform an IO action, the action has to be evaluated, and since head [] fails to evaluate, you get an error.
22:36:50 <JoeyA> But return (head []) can be performed without evaluating the (head [])
22:37:05 <edwardk> now it'd be kind of nice to make an evaluator for Derived.hs, but pattern matching is more owkr
22:37:06 <edwardk> er work
22:37:45 <shachaf> edwardk: Or you could write a parser. Then there'd exist an example of someone actually using Trifecta!
22:37:51 <edwardk> hah
22:37:54 <edwardk> i thought about it =)
22:37:55 <nyingen> JoeyA: I see
22:38:06 <edwardk> the main thing is the example i just showed was the 'no extensions' example
22:38:18 <edwardk> i could get away with someting like you described in the other two though
22:38:33 <shachaf> edwardk: Oh, you could use "combining ^ above"!
22:38:44 <shachaf> Isn't that what originally brought about the lambda syntax or something?
22:38:46 <edwardk> combining ^ ?
22:38:57 <edwardk> oh
22:39:05 <edwardk> for x^ etc
22:39:27 <mauke> id = x̂x
22:39:43 <edwardk> yeah he wanted ^'s over variables being bound and it got typeset to the left and then retypeset as a lambda
22:40:35 <mauke> (x̂ŷxx)(x̂ŷxx)
22:41:12 <edwardk> i'm somewhat disturbed that after all of that it just works
22:41:34 <mauke> preflex: remember <edwardk> i'm somewhat disturbed that after all of that it just works
22:41:44 <otters> @quote
22:41:44 <lambdabot> Heffalump says: CPP leads to suffering
22:41:48 <otters> yeah
22:43:17 <nyingen> C/CPP
22:43:31 <mauke> also known as C
22:43:52 <nyingen> C or C++, also known as C/C++
22:44:06 <mauke> CPP is not C++
22:44:22 <nyingen> I'm just joking
22:44:50 <otters> Is it better to use f $ g $ h $ i x or f . g . h . i $ x?
22:44:59 <mauke> the latter
22:45:05 <otters> why
22:45:12 <mauke> more extractable subexpressions
22:45:24 <edwardk> i always figured c/c++ = 1
22:45:29 <S11001001> also 'cause they're gonna change $ to be infixl any day now :)
22:45:33 <otters> oh good
22:45:35 <mauke> let gh = g . h in f . gh . i $ x
22:45:42 <mauke> can't do that with g $ h ...
22:45:49 <otters> right
22:45:51 <mauke> edwardk: it's actually UB in both C and C++
22:46:14 <edwardk> yeah because of multiple references in the same equation, etc.
22:46:19 <edwardk> but still =)
22:46:22 <nyingen> @karma C/C
22:46:22 <lambdabot> C/C has a karma of 140
22:46:36 <edwardk> @karma C
22:46:36 <lambdabot> C has a karma of 0
22:46:42 <mauke> preflex: karma C
22:46:42 <preflex>  C: 190116
22:46:43 <shachaf> Aw.
22:46:46 <shachaf> @karma+ c
22:46:46 <lambdabot> c's karma raised to 1.
22:46:56 <mauke> preflex: karma i
22:46:56 <nyingen> preflex: karma C/C
22:46:57 <preflex>  i: 2386
22:46:58 <preflex>  C/C: 6357
22:47:10 <mauke> preflex: karma <!
22:47:11 <preflex>  <!: -1190
22:47:16 <nyingen> heh
22:47:32 <edwardk> does anyone remember the :set command you use to get ghci to give you evaluation times?
22:47:40 <mauke> edwardk: I like to view sequence point rules in terms of threads
22:47:55 <mauke> that is, every part of an expression is evaluated at the same time
22:48:04 <mauke> and if it leads to race conditions, it's wrong
22:48:05 <edwardk> sure
22:48:27 <edwardk> well, just don't look at the result, just use it as an awkward way to increment c ;)
22:48:47 <mauke> still UB
22:53:26 <edwardk> ok, other fun examples i can throw in there?
22:53:35 <edwardk> i was thinking about doing a tiny type checker
22:53:47 <shachaf> What's a tiny type?
22:53:48 <mauke> tiny int i;
22:53:49 <edwardk> showing how to deal with binding for foralls or something
22:54:06 <edwardk> tiny (type checker) not (tiny type) checker ;)
22:54:20 * mauke builds a tiny tim checker
22:54:28 <S11001001> I bet a tiny type checker could have disambiguated that phrase for shachaf
22:54:47 <shachaf> You'd need a pretty hefty type checker to check English.
22:55:07 <S11001001> only support words frequently said in #haskell
22:55:12 <mauke> the cotton socks are made of grows in india
22:55:29 <edwardk> meh, just skimming his copy of strunk and white, clearly the other parenthesization is the less likely native speaker judgment because we have the - for disambiguating chained adjectives
22:56:25 <shachaf> Yes, it took some effort to misinterpret you!
22:56:37 * shachaf will do anything for a stupid pun.
22:56:59 <edwardk> there has to be a fix joke in here somewhere
22:57:02 <mauke> the alliteration helps
22:57:51 <shachaf> mauke likes M better than fix, right?
22:58:30 <mauke> well, how much does fix like M?
22:58:46 <shachaf> Not very much.
23:09:48 <zzo38> What are lens laws?
23:14:18 <Snyp> i was trying to figure this out myself but i'd just ask anyways, why [1.02,1.04..1.20] gives a strange output containing 1.5000000004, etc etc?
23:18:44 <c_wraith> Snyp: the Enum instance for Double is bizarre.  It's according to spec, but I have no clue why the spec requires that behavior
23:19:26 <Snyp> i see..
23:19:34 <c_wraith> Snyp: unless your question is why that number is in the sequence at all
23:19:53 <c_wraith> Snyp: in which case the answer is "because the IEEE 754 spec requires it, and it makes perfect sense"
23:20:00 <c_wraith> > 1 / 3
23:20:01 <lambdabot>   0.3333333333333333
23:20:15 <c_wraith> > (1 / 3) + (1/3)
23:20:16 <lambdabot>   0.6666666666666666
23:20:29 <c_wraith> > (1 / 3) * 4
23:20:31 <lambdabot>   1.3333333333333333
23:20:34 <c_wraith> strange.
23:20:47 <c_wraith> > [1, 1.1, ..]
23:20:48 <lambdabot>   <no location info>: parse error on input `..'
23:20:51 <c_wraith> > [1, 1.1,\ ..]
23:20:53 <lambdabot>   <no location info>: parse error on input `..'
23:20:54 <c_wraith> > [1, 1.1 ..]
23:20:56 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000...
23:20:58 <c_wraith> There
23:21:18 <c_wraith> That's required for IEEE 754 floating point
23:21:18 <Snyp> why are there digits in the last decimal place?
23:21:25 <Snyp> mhm..
23:21:31 <c_wraith> because 0.1 can't be exactly represented in that format
23:21:38 <c_wraith> so it picks the closest approximate
23:21:44 <c_wraith> and keeps adding that
23:21:47 <c_wraith> the error adds up
23:21:58 <Snyp> hmm..
23:22:42 <c_wraith> only sums of powers of 2 can be represented in floating point.
23:33:06 <shachaf> > [1.0,3.0..10.0]
23:33:07 <lambdabot>   [1.0,3.0,5.0,7.0,9.0,11.0]
23:33:27 <c_wraith> *that* is the strange Enum behavior
23:37:24 <otters> > [2.0,4.0..16.0]
23:37:26 <lambdabot>   [2.0,4.0,6.0,8.0,10.0,12.0,14.0,16.0]
23:39:58 <ninegrid> say i clone someones haskell code from github, how would i then import a module from it in my own code? in otherwords, how do i supply the path, or what is the canonical location to place other peoples code like this?
23:41:13 <strager> ninegrid: Give another source path to GHC?  Or do you want to treat it as a separate package?
23:42:00 <ninegrid> strager: i'd like to just play with it, im not building anything with it... but I do want to understand what the best practice is in this circumstance
23:42:33 <ninegrid> strager: so i suppose treating it as a seperate package would be what I want ultimately... ideally just import the module as though I had installed it with cabal
23:42:53 <strager> cd into that project, 'cabal install'
23:43:00 <ninegrid> well then
23:43:07 <strager> I'm guessing that's not what you want to hear =]
23:43:18 <strager> I don't have experience beyond that.
23:43:23 <ninegrid> no that sounds too hard ;)
23:43:40 <ninegrid> no that is a perfect solution
23:44:28 <ninegrid> strager: so is there a way to generate a manifest or something? because it is not "packaged" like cabal packages afaik
23:44:58 <strager> oh
23:45:19 <strager> In that case either cabalify it with 'cabal init', or just give -ipath/to/src to GHC
23:45:33 <ninegrid> alright
23:47:37 <flazz> i made a simple scotty app, when benchmarking it with "ab -n 5" it resets the connection and only responds to the first few. am i missing some sort of configuration?
23:49:20 <KSkrzet> is there any way to access default implementation of a method when defining your own implementation?
23:50:38 <ninegrid> strager: seems that after doing cabal init i get the error "there is no installed version of base" from cabal install... any idea wha that is? a quick vim search of the .cabal file showed no matches for 'base'
23:50:45 <strager> KSkrzet: Of a typeclass?  Interesting question.  (Can't say I know the answer myself.)
23:51:03 <strager> ninegrid: Did you install the Haskell Platform?
23:51:37 <ninegrid> strager: i suppose i did, running archlinux i installed ghc and cabal
23:51:54 <KSkrzet> strager: yes, I meant a method from a typeclass.
23:51:59 <strager> Install the Haskell Platform if you can.
23:53:37 <KSkrzet> ninegrid: Haskell Platform is on Aur
23:53:57 <ninegrid> KSkrzet: thanks
23:55:18 <ninegrid> too bad im doing this on an eee... should take approximately: forever
23:56:32 <ninegrid> its compiling now, i'll keep you aprised if/when it works
