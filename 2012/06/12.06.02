00:01:39 <lpsmith> adamt, I think the answer is,  undefined can only pop out of crappy code,  but there is a fair bit of "crap" in the standard Prelude... so...
00:01:59 <plat0> lpsmith: Do you have a simple example of when you like shadowing?
00:02:06 <adamt> lpsmith: Aww. Okay.
00:03:36 <lpsmith> plat0, yeah,  like when I write something like    foo as = case as of { [] -> bar;  (a:as) -> loop a as }   where loop a as = ...
00:04:50 <lpsmith> plat0, also, if I know I definitely do not want to use a particular variable,  shadow it with something more useful :)  That way you can express and enforce that intention
00:05:32 <lpsmith> plat0:  also, shadowing can come in handy with record wild cards
00:07:27 <plat0> I see.
00:07:33 <plat0> I guess the alternative is to do
00:07:42 <plat0> loop a_ as_ = ... which is ugly
00:07:45 <plat0> or loop = ...
00:07:57 <plat0> err, you can't do the latter
00:08:00 <plat0> so just the ugly one!
00:08:02 <plat0> yes i see
00:08:21 <plat0> (you can't do the latter if you want to be recursive about it!)
00:08:24 <lpsmith> I like warnings about incomplete pattern matches.   I like warnings about unused variables.   These are,  in my experience,  good things to know about,  as there is a pretty good chance it's a real problem
00:08:57 <plat0> Is there a pragma to turn the warning off for a certain instance of shadowing?
00:09:06 <lpsmith> Not that I'm aware of
00:09:15 <lpsmith> I just turn it off altogether if I go -Wall
00:10:13 <plat0> OK
00:15:07 <plat0> main can be :: IO String?
00:15:13 <plat0> % cat test.hs
00:15:13 <plat0> main :: IO String
00:15:13 <plat0> main = return "hi"
00:15:18 <plat0> % ghc test.hs
00:15:19 <plat0> %
00:15:22 <plat0> I expected that to fail
00:18:34 <RichyB> plat0, you've created a module with an IO action in it called "main", but you haven't actually built an executable.
00:19:13 <RichyB> plat0, wait, ignore me, ghc does something different than I was expecting.
00:19:33 <RichyB> Apparently main can be IO x for any x.
00:19:42 <plat0> I never knew that.
00:21:49 <RichyB> Yeah, the H98 report says "The value of the program is the value of the identifier main in module Main, which must be a computation of type IO t for some type t"
00:22:11 <RichyB> main :: IO () is pretty much just convention.
00:22:59 <plat0> Can it ever do anything with t?
00:23:13 <RichyB> plat0, and if you omit the "module Something where..." then Haskell will assume that the module line is "module Main(main) where"
00:23:45 <RichyB> No. That is *why* everybody sets the return type of main to (), so that it's explicit that nothing can be done with it.
00:23:52 <plat0> Is "main = x" always equivalent to "main = x >> return ()"?
00:24:18 <RichyB> No, "main = x" will give main exactly the same type as x,
00:24:35 <RichyB> whereas "main = x >> return ()" will give main the the IO (), regardless of what x's type is.
00:24:38 <plat0> Sure but I mean they will always produce equivanent programs?
00:24:53 <RichyB> Yes
00:24:54 <RichyB> unless
00:25:10 <RichyB> main = main -- will produce an infinite loop that merely burns CPU
00:25:27 <roconnor_> RichyB: or throw a Loop exception
00:25:29 <RichyB> main = main >> return () -- will produce a program that burns CPU for a few seconds and then crashes
00:25:37 <Cale> actually, I don't think that should burn CPU
00:26:13 <plat0> I wonder why the report didn't require main :: IO () then
00:26:30 <RichyB> roconnor_, yeah okay, it's implementation-defined which happens. :)
00:26:54 <RichyB> plat0, convenience if you have a recursive main, probably.
00:27:16 <Cale> think of the runtime as accepting a main polymorphically
00:27:19 <plat0> I don't see what that would help.
00:27:23 <RichyB> Also, the type (forall t. t) is formally just as useless as the type () because you have no information about it and therefore can't do *anything* with it.
00:27:43 <roconnor_> RichyB: (forall t. t) is quite different from ()
00:28:14 <plat0> roconnor_: In what way?
00:28:41 <RichyB> roconnor_, in the specific context of what the RTS would do with exactly one value of type () or (forall t. t), they're about the same.
00:28:43 <roconnor_> forall t. t has no inhabitants and () has one inhabitant ... from a moral point of view.
00:29:18 <RichyB> plat0, you can use explicit (forall t. t) to implement several type-level invariant enforcers like the safety of the ST monad.
00:30:01 <roconnor_> RichyB: the runtime could immedately halt with a loop exception if it ever encountered a value of type (forall t. t) since only infinite loops can give rise to this type.
00:30:40 <RichyB> Good idea, didn't think of that.
00:30:53 <roconnor_> and the compiler could use this to eliminate "dead code" of this type.
00:30:55 <RichyB> Wait no it can't, it can't force it, the type has no inhabitants?
00:31:11 <plat0> Anyway, the issue here is not (forall t. t), it's (forall t. IO t) which I think is something quite different
00:31:14 <lpsmith> I like using forall a. IO a   to write server loops that I know don't terminate
00:31:33 <roconnor_> plat0 indeed.
00:32:12 <roconnor_> Recently I've been advocating that the type of main should be IO (forall t. t) ... but I do admit it is a bit akward.
00:32:31 <plat0> So if the report required IO (), lpsmith wouldn't be able to do his trick?
00:32:51 <roconnor_> Hmm
00:33:04 <lpsmith> plat0, yes I could
00:33:07 <roconnor_> I guess IO (forall t. t) and forall t. IO t are isomorphic.
00:33:14 <plat0> roconnor_: surely not!?
00:34:09 <roconnor_> forall t. IO t works for all t, including t = (forall t. t) ... thanks to impredicativity
00:34:43 <RichyB> IO (forall t. t) *requires* that there isn't a return value from main.
00:35:32 <roconnor_> and IO (forall t. t) can be turned into forall t. IO t via fmap magic.
00:35:51 <RichyB> It can?
00:36:09 <hpaste> jonaskoelker pasted “my code” at http://hpaste.org/69404
00:36:15 <roconnor_> magic :: (forall s. s) -> t
00:36:18 <roconnor_> magic x = x
00:37:12 <roconnor_> I think under weak assumptions we can prove the conversions between IO (forall t. t) and forall t. IO t are inverses of each other.
00:38:17 <plat0> I though the noncommutativity of forall and IO was why we don't need the value restriction in Haskell.
00:38:27 <plat0> I'll have to rethink that ...
00:39:48 <pooya72> hello everybody!
00:39:56 <plat0> Hello!
00:40:07 <roconnor_> my intuition is that these two conversions only fiddle with the contents of the leaves of the IOTree and the leaves don't even exist or if they do exist only contain bottoms.
00:41:10 <pooya72> how does one use IO [Char} and stuff outside of mondaic I/0 or is that not possible?
00:41:47 <roconnor_> pooya72: one uses io-list-char >>= f
00:42:21 <roconnor_> pooya72: then f has type [Char] -> IO Something and it is like receiving an un IO wrapped [Char]
00:43:00 <pooya72> roconnor: I want to go from IO [Char] -> [Char]
00:43:39 <mcstar> hm, why would you want that?
00:44:02 <lpsmith> pooya72, you can't do that
00:44:22 <lpsmith> (well,  you can by ignoring the first argument,  but that's not too interesting)
00:44:32 <roconnor_> pooya72: you don't need to go from IO [Char] to [Char]  Just write the rest of the function that you would write after you have [Char] and pass that to >>=
00:45:03 <roconnor_> pooya72: for concreteness, let me ask, if you did get a [Char], what would you do with it?
00:45:37 <mcstar> once in the sacred labirinth of IO, theres no way out, you need to go deeper, or ask Scotty to unsafeTransport you out
00:45:46 <pooya72> lpmsmith: yeah, that's what i figured
00:46:11 <pooya72> roconnor_: wanted to get SQL query to a new data type.
00:46:36 <roconnor_> what is the type of the SQL query function?
00:46:44 <pooya72> SqlValue
00:46:57 <pooya72> I'm using HDBC-postgresql
00:47:34 <roconnor_> pooya72: what function are you calling to get the SqlValue?
00:48:14 <roconnor_> SqlString?
00:48:47 <pooya72> roconnor_: http://hpaste.org/69405
00:51:45 <roconnor_> pooya72: okay, while I'm looking at this, can you explain the problem here?
00:53:37 <roconnor_> pooya72: is id the string parameter?
00:53:50 <pooya72> roconnor_: well I just want to go from the Sql query to to a new data type. http://hpaste.org/69407 so that i could use that data throughout the program.
00:54:56 <pooya72> roconnor_: yes. i get the correct SqlValues, just don't know how to incorporate it with the rest of haskell. It looks like if use a Sql query the I am in IO world forever.
00:55:23 <mcstar> *evil grin* looks like it
00:55:47 <pooya72> mcstar: haha
00:56:13 <roconnor_> pooya72: being trapped in IO forever is okay.  Write a function pooyaParse :: [Char] -> BlogPost
00:56:47 <roconnor_> pooya72: then fmap pooyaParse :: IO [Char] -> IO BlogPost
00:57:07 <roconnor_> so yes, you are still in IO, but you can keep chaining like this indefinitely.
00:57:37 <roconnor_> using fmap and >>=
00:57:44 <roconnor_> (or by using the nice do notation)
01:00:16 <sipa> you are inevitably forever trapped in IO, as the type of main is IO ()
01:00:39 <Franciman> hi all
01:00:48 <sipa> but that doesn't you can't use pure code to build that IO action
01:02:15 <pooya72> roconnor_: ok, so I'm not to sure on how to go from IO [Char] -> IO BlogPost. Do I need to create a new data type IO Blogpost?
01:03:01 <roconnor_> nope
01:03:12 <RichyB> pooya72, you would create a new data type Blogpost.
01:03:29 <roconnor_> you write another function BlogPost -> Whatever
01:03:45 <roconnor_> and the fmap thatFunction :: IO BlogPost -> IO Whatever
01:03:52 <roconnor_> just keep going like this.
01:04:28 <roconnor_> pooya72: I should point out you cannot make a global variable containing your blogposts.
01:04:38 <roconnor_> pooya72: you will have to pass it around to everyone.
01:04:38 <pooya72> roconnor_: ok, I'll try that. Thanks!
01:04:43 <mcstar> pooya72: you already know how to do that, conn and post are both freed from their IO burden, you could pass them to pure/impure functions
01:05:34 <pooya72> mcstar: but only inside a do monad right?
01:05:45 <roconnor_> pooya72: there are ways to use ReaderMonads to implicitly pass around your blogpost, but for now I recommending passing it by hand.
01:05:45 <mcstar> yes, just like you did already
01:06:04 <mcstar> btw, it isnt a do monad
01:06:13 <mcstar> do is just syntactic sugar...
01:06:38 <pooya72> roconnor: ok, I will. I'm just trying to learn to use the data type.
01:06:54 <pooya72> mcstar: yeah, I just didn't know what to call it :)
01:09:13 <jonaskoelker> :i Bits
01:09:20 <jonaskoelker> :i Data.Bits
01:11:23 <jonaskoelker> what's up with Bool not being a Data.Bits instance ^_^
01:12:19 <dmwit> Well, it's only one Bit!
01:12:29 <shachaf> dmwit makes a good point.
01:13:01 <shachaf> Anyway, Data.Bits is for numberish things. Bool isn't a numberish thing. :-)
01:13:13 <jonaskoelker> but I want to say b `xor` b'! :\
01:13:27 <mcstar> isnt there a logical xor?
01:13:35 <jonaskoelker> yes, (/=)
01:13:37 <jonaskoelker> ^_^
01:13:41 <jonaskoelker> which is ugly
01:13:52 <shachaf> It is?
01:13:57 <dmwit> xor = (/=)
01:14:10 <jonaskoelker> but that clashes with all my loverly Bits instances -.-
01:14:18 <pooya72> roconnor_: ok so I was able to go from SqlQuery to the Data type by doing something like this: http://hpaste.org/69410 but i have a feeling that this is really crude :)
01:15:06 <mcstar> npost <- return (fillData postById) => let npost = fillData postById
01:15:12 <jonaskoelker> also, why is Bits a subclass of Num?  Does Bits make any guarantees about numeric properties of what it does?
01:16:30 <mcstar> btw, why dont you use String instead of [Char]?
01:16:58 <hpaste> Anonymous pasted “Pony Fantasy VI” at http://hpaste.org/69411
01:17:22 <mcstar> yay, spam
01:17:25 <RichyB> I'm pretty certain that that isn't what hpaste was meant for.
01:17:39 <pooya72> mcstar: yeah I changed that [Char]-> string.
01:18:32 <mcstar> renderPostById xs = [fromSql x::[Char]| x<- (head xs)] => renderPostById (x:xs) = [fromSql x]
01:18:55 <pooya72> mcstar: dude, thanks :)
01:18:56 <mcstar> renderPostById (x:_) = fromSql x is better, you probably dont need the list wrapper
01:19:19 <mcstar> (i mean, you have to change something for this to work, but it seemed redundant)
01:20:56 <dmwit> renderPostById = map fromSql
01:21:15 <mcstar> does fromSql return IO a?
01:21:30 <dmwit> Don't know, don't care.
01:23:01 <mcstar> dmwit: map fromSql is not equivalent with that, you only need to map on the first element of the argument to renderPostById
01:23:18 <dmwit> Calling f (head xs) instead of map f xs is premature optimization.
01:23:30 <pooya72> mcstar: no returns a
01:24:14 <pooya72> and what is hpaste using to suggest all those changes at the bottom?
01:24:19 <dmwit> Remember: map is not expensive unless you look at all the elements.
01:24:25 <dmwit> hlint
01:24:27 <dmwit> ?hackage hlint
01:24:27 <lambdabot> http://hackage.haskell.org/package/hlint
01:25:10 <pooya72> dmwit: thanks!
01:27:10 <jonaskoelker> spam though the pony thing may be, I think it's some of the more amusing spam I've seen in a long time ^_^
01:29:43 <pooya72> btw what's the best to connect to postgres? hdbc-postgres, persistent, postgres-simple??
01:45:44 <akosch> is there a nice syntax in Control.Applicative for lifting a function multiple times? like lifting a -> b into IO (Maybe a) -> IO (Maybe b)
01:50:02 <bitonic> akosch: fmap . fmap?
01:50:20 <bitonic> @type fmap . fmap
01:50:21 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:50:35 <akosch> @type (<$>) . (<$>)
01:50:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:50:41 <akosch> bitonic: :)
01:51:02 <akosch> maybe I could define <$$> = (<$>) . (<$>)
01:51:23 <bitonic> akosch: I don't think fmap . fmap is that bad.
01:51:46 <bitonic> unless you're using it all the time
01:52:10 <akosch> bitonic: yeah, maybe it's worth it to be more explicit
01:52:23 <dmwit> :t fmap fmap fmap
01:52:24 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:52:29 <dmwit> because why not
01:53:07 <bitonic> akosch: btw you can also do
01:53:22 <bitonic> @type (\f x -> (f <$>) <$> x)
01:53:23 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
01:53:36 <shachaf> @ty (.:)
01:53:37 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
01:54:13 <akosch> shachaf: thanks, exactly what I was looking for!
01:54:21 <bitonic> shachaf: btw, is that defined in any big accepted library?
01:56:01 <shachaf> akosch: It's unfortunately only defined in lambdabot.
01:56:06 <shachaf> bitonic: It's unfortunately only defined in lambdabot.
01:56:26 <dmwit> bitonic: http://hackage.haskell.org/package/plumbers
01:57:25 <akosch> dmwit: is that a collection of emoticons? :)
01:57:59 <mcstar> omg
01:58:23 <dmwit> http://www.mgsloan.com/wordpress/?p=228
01:58:38 <akosch> or just a perl compatibility module ;)
01:58:39 <mcstar> when i will teach haskell to my friend, ill make sure, he learns this package first
01:58:58 <dmwit> Oops, I mean http://www.mgsloan.com/wordpress/?p=148
01:58:58 <bitonic> dmwit: that doesn't seem to export .:
01:59:20 <dmwit> It has a different name, and it's a bit more monomorphic.
02:00:05 <mcstar> btw, what is convention, where to break the line when using these sequencing operators?
02:00:33 <bitonic> dmwit: anyway. that doesn't count as "accepted" library :P. I'd rater avoid having it as a dependency
02:01:45 <bitonic> tbh, I rarely have the urge to use .:.
02:02:45 <mcstar> lets say, you have to sequence a big IO action, with >> and >>=, where do you break the line? before >> or after >> ?
02:03:19 <sipa> personal preference, probably, but i like:
02:03:22 <silver> after
02:03:43 <sipa> action =     action1
02:03:44 <silver> just like in do block
02:03:53 <sipa>          >>= action2
02:04:27 <taylorgb> You won't find consensus, do what makes more sense to you.
02:05:01 <mcstar> sipa: thats not very resilient to changes
02:06:03 <mcstar> breaking after, makes more sense to me
02:06:16 <mcstar> and i break line after a do, too
02:06:40 <mcstar> i didnt want to first, but this way i dont have to fiddle with indentation that much
02:08:08 <silver> make sense
02:08:14 <silver> makes*
02:22:39 <roconnor_> > find (\x -> x `mod` 1000 == 0) [512*n | n <- [0..]]
02:22:39 <lambdabot>   Just 0
02:22:43 <roconnor_> > find (\x -> x `mod` 1000 == 0) [512*n | n <- [1..]]
02:22:43 <lambdabot>   Just 64000
02:26:53 <sipa> let { gcd a 0 = a; gcd a b = gcd b (a `mod` b) } in gcd 1000 512
02:26:55 <sipa> > let { gcd a 0 = a; gcd a b = gcd b (a `mod` b) } in gcd 1000 512
02:26:56 <lambdabot>   8
02:27:10 <zzo38> Yes, it looks like (Free (CoYoneda f)) is similar to MonadPrompt
02:27:28 <sipa> > 1000*512 / 8
02:27:29 <lambdabot>   64000.0
02:27:33 <mroman> @type find
02:27:34 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
02:27:39 <mroman> @info find
02:27:40 <lambdabot> find
02:27:54 <mroman> @src find
02:27:55 <lambdabot> find p          = listToMaybe . filter p
02:28:09 <mroman> oh. ok.
02:28:38 <mroman> @src listToMaybe
02:28:38 <lambdabot> listToMaybe []        =  Nothing
02:28:38 <lambdabot> listToMaybe (a:_)     =  Just a
02:29:09 <mroman> hu? Why that?
02:30:00 <dmwit> mroman: I don't understand it either. "filter p" seems perfectly good to me, and the rest just seems like mangling.
02:30:15 <zzo38> Instead of listToMaybe I use my own function convList (there is a RULES pragma to make it call listToMaybe if the types match)
02:31:28 <dmwit> > lcm 512 1000
02:31:29 <lambdabot>   64000
02:31:39 <mroman> Why does listToMaybe only take the head?
02:31:48 <mroman> I mean, that's not really 'list' toMaybe :)
02:31:55 <mroman> more like headToMaybe
02:32:09 <dmwit> mroman: There's just not that many sensible things to do, given the type.
02:32:13 <bitonic> mroman: how else would you define it?
02:32:30 <mroman> well
02:32:35 <dmwit> All you can do is look at the length of the list, and then choose which one (if any) element to pick given that length.
02:32:56 <zzo38> Yes I know it only take the head, but, using convList it automatically just takes the head due to the definition:   convList = foldr consA empty;  consA x y = pure x <|> y;
02:33:01 <mroman> let lsToMaybe [] = Nothing; lsToMaybe a = Just a
02:33:12 <turingtest> listToMaybe is a safe version of head.  There is no safe version of last.
02:33:16 <dmwit> > guard (not . null) []
02:33:17 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
02:33:17 <lambdabot>         against inferred type ...
02:33:27 <dmwit> > guard (not . null) [] :: Maybe [Int]
02:33:28 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
02:33:29 <lambdabot>         against inferred type ...
02:33:31 <dmwit> oh, right
02:33:42 <dmwit> turingtest: listToMaybe . reverse
02:33:49 <bitonic> mroman: that doesn't have that type
02:34:13 <turingtest> dmwit: that is not safe for infinite lists.
02:34:30 <dmwit> turingtest: Nonsense, it does exactly the right thing: it loops infinitely.
02:35:06 <turingtest> dmwit: which is why it is not a safer version of last.  The listToMaybe is a safer version of head.
02:35:19 <mroman> bitonic: It has a different type yes.
02:35:24 <bitonic> turingtest: it is safer, see empty list case
02:35:38 <mroman> and it does not really make sense as you can easily match against []
02:35:52 <turingtest> bitonic: granted, it is safer for finite lists.
02:36:06 <dmwit> turingtest: I don't get itutation that loops infinitely before returning either a [] or (_:_), and listToMaybe will then loop infinitely.
02:36:25 <bitonic> mroman: you don't gain anything at the type level with your function
02:36:28 <dmwit> turingtest: So what validates this claim that listToMaybe is somehow safer than listToMaybe . reverse?
02:36:39 <shachaf> Ooh, are we talking about lazy-reverse again?
02:36:48 <dmwit> hm, s/ituation/it. I can write something/
02:37:16 <shachaf> Oh, no, we're not. :-(
02:37:21 <turingtest> dmwit: for a list in WHNF, listToMaybe is a total function while (listToMaybe . reverse) is not.
02:37:25 <shachaf> dmwit: That's a weird notion of "before" you've got there.
02:38:51 <dmwit> That seems like a pretty arbitrary definition of "safe".
02:41:09 <mcstar> > head [n | n <- [1..] , n == 0]
02:41:13 <lambdabot>   mueval-core: Time limit exceeded
02:43:10 <dmwit> listToMaybe . reverse is a safer version of last in exactly the same sense listToMaybe is a safer version of head: the safer version terminates in all the same situations that the unsafe version does, and the safer version doesn't crash when handed the empty list.
02:43:24 <answer_42> he air
02:44:23 <shachaf> dmwit: That's one sense, anyway.
02:44:39 <shachaf> The sense that "head is partial, listToMaybe is total" seems reasonable to me.
02:44:58 <dmwit> "and the safer version doesn't crash when handed the empty list"
02:45:10 <mcstar> i just wanted to demonstrate theres no reason to make reverse safe, right?
02:45:54 <mroman> what is "total"?
02:46:19 <mcstar> returns non-bottom for all its possible input?
02:46:26 <shachaf> dmwit: You can define saferYetListToMaybe [] = Nothing; saferYetListToMaybe l = Just (last l)
02:46:34 <dmwit> all well-defined inputs, usually, but yes
02:46:35 <mcstar> (i.e. compatible with its argument type?)
02:46:43 <shachaf> Which doesn't return _|_ for *any* non-_|_ input. :-)
02:46:50 <dmwit> "total" means well-defined inputs yield well-defined outputs.
02:46:55 <shachaf> You could also argue that that definition is incorrect, of course.
02:47:43 <mcstar> _L
02:48:05 <mcstar> > flip 'T'
02:48:06 <lambdabot>   Couldn't match expected type `f (a -> b)'
02:48:06 <lambdabot>         against inferred type `GH...
02:51:20 <covi> Guys, I think when theory vs. practicality, theory is more important. What do you think
02:51:47 <mcstar> in general or per haskell?
02:51:59 <covi> in general cs world.
02:52:18 <sipa> that's like asking whether math or physics is more important
02:52:21 <mcstar> i vote for 'hand in hand'
02:52:22 <arnsholt> Depends on what you're doing I think
02:52:32 <arcatan> i, as a math major, vote for math
02:52:52 <silver> lol
02:53:09 <silver> covi, provoker
02:53:29 <mcstar> yeah, hes got a flamethrower on his back, his the guy from lethal weapon
02:54:07 <covi> I am just graduating from high school, and I am learning a NLP and ML course from coursera.org. My experience is that, anyone can successfully *implement* an advanced+useful model if he's given the theory. But one such person can hardly really understand the essence of the model, which makes use of much math.
02:54:39 <mcstar> covi: well, the math is pretty simplisitic for those kinds of things
02:54:51 <covi> I am that kind of person right now. And I know how confusing it would be.
02:55:11 <covi> mcstar: lol, given that this is #haskell?
02:55:20 <sipa> still, skilled electricians rarely know or understand kirhchoff's laws, much less maxwell's laws
02:55:20 <mcstar> hm?
02:55:42 <sipa> and many university students who study physics do, but can't safely install an electrical system
02:55:57 <arcatan> covi: I feel that once you start implementing those models in practice, you'll learn to appreciate the practicality, too
02:56:14 <bitonic> sipa: I'd be careful to compare programmers to electricians
02:56:29 <mcstar> sipa: what do you mean by 'they dont understand kirchoffs laws'?
02:56:30 <sipa> bitonic: sure, once it's about designing electrical systems, things get different
02:56:46 <bitonic> sipa: exactly
02:56:52 <covi> sipa: I agree with bitonic. The difference is you have to at least know the theory in cs world
02:57:11 <silver> covi, sometimes it's a lot harder to apply theory than to reason about it
02:57:14 <mcstar> programming is not CS, come on
02:57:16 <sipa> i guess my point is you just can't compare the two
02:57:31 <covi> arcatan: Yeah.
02:57:32 <mcstar> anyone can make a living by programming wo CS education
02:57:41 <covi> mcstar: agreed.
02:58:38 <arcatan> I also know some people who are pretty good at being computer scientists, but i wouldn't hire to work as programmers who actually deliver software to customers
02:59:06 <sipa> indeed
02:59:47 <mcstar> sipa: i still dont get your "skilled electricians rarely know or understand kirhchoff's laws" statement
02:59:58 <covi> I guess it's best to be a good programmer and a comp scientist
03:00:04 <mcstar> whom do you consider a skilled electrician then?
03:00:39 <bitonic> arcatan: in my small experience, the reverse happens much more often (working programmers not "getting" theoretical stuff)
03:00:59 <arcatan> bitonic: sure
03:01:10 <arcatan> but it does happen the other way, too
03:01:32 <sipa> mcstar: someone who knows not to touch an electrical wire when there is voltage on it, knows how to install a crossbar switch, knows where to look when there is no power
03:01:36 <silver> bitonic, probably because there are more programmers than computer scientists :)
03:01:44 <bitonic> arcatan: yeah but it's often due to personality issues :P
03:01:48 <covi> arcatan: are you an employer than?
03:02:01 <sipa> mcstar: i'm sure many of them once learnt about the physics of it, but i'm not sure many still knows all that actively while doing the job
03:02:05 <arcatan> covi: no, not yet anyway
03:02:36 <covi> silver: One does not need to be a comp scientist to get the theory
03:03:18 <silver> well you need to allocate  time for learning
03:03:26 <mcstar> thats what i wanted to say
03:03:26 <silver> I mean "getting"
03:03:35 <mcstar> and thats better done in formal CS training
03:05:35 <arcatan> for long time i thought i wanted to be a theoretician. it took me years to understand that i actually prefer pragmatic work, i just happen to like working with abstract things and tools.
03:06:26 <Yunisika> why haskell is so hot ?
03:07:08 <sipa> to make sure kids don't mess with it?
03:07:32 <arcatan> to offset the coolness of its users
03:07:34 <mcstar> i think there is radioactive fission going on in its core
03:07:41 <covi> arcatan: what are your vocation now?
03:08:07 <dmwit> 1. awesome type system 2. first-class functions 3. enforced separation between pure and impure code 4. laziness
03:08:13 <sipa> mcstar: you mean haskell core is not pure? i thought there was no destructive update in there :(
03:08:19 <dmwit> in rough order of significance
03:08:43 <plat0> Is there any difference between laziness, and implicitly wrapping everything in a \() -> ... (from an operational point of view)
03:08:45 <dmwit> sipa: Nonsense, laziness is all about destructive update (of uncomputed to computed values).
03:08:53 <mcstar> sipa: you should know better, immutability is just an illusion, pulled over your eyes, form blinding you from the truth:
03:09:00 <arcatan> covi: math student and aspiring startup entrepreneur
03:09:04 <sipa> there is no spawn?
03:09:12 <sipa> so we'll have to fork?
03:09:20 <mcstar> there is no soon
03:09:30 <sipa> dmwit: sure, operationally
03:09:32 <covi> arcatan: cool, why not double majoring in cs?
03:10:26 <dmwit> plat0: Yes, laziness implies sharing as well as delayed evaluation.
03:11:04 <arcatan> covi: i'm not sure how double majoring maps to finnish education system, but i'm studying cs, too
03:11:16 <plat0> dmwit: if you take memoization out of it, are they the same?
03:11:30 <dmwit> Memoization isn't related.
03:11:35 <plat0> hmm
03:11:41 <plat0> What do you mean by "sharing" then?
03:12:10 <dmwit> Memoization involves transforming functions by reifying them as data.
03:12:17 <dmwit> Sharing involves having two pointers to the same object.
03:12:46 <plat0> They seem like two sides of the same concept to me.
03:13:13 <plat0> Can you give me an example where laziness including sharing is different from delayed evaluation?
03:13:27 <dmwit> Yes, consider let x = 10 + 10 in x * x
03:13:40 <dmwit> vs let x () = 10 + 10 in x () * x ()
03:13:57 <dmwit> In the former, we compute 20 once, then 400 immediately; in the latter, we compute 20 twice
03:14:19 <plat0> In the latter with memoizing you would compute it once, also.
03:14:58 <mcstar> dmwit: oh, so even if x () is pure, it gets evaluated twice in haskell?
03:15:09 <dmwit> In GHC, yes.
03:15:12 <shachaf> mcstar: Haskell doesn't specify.
03:15:22 <plat0> Not even in GHC!
03:15:55 <plat0> See http://okmij.org/ftp/Haskell/index.html#memo-off
03:16:10 <bitonic> dmwit: I wouldn't be surprised if GHC optimizes that out... Haskell does not dictate that not to be memoized, the compiler is free
03:16:21 <plat0> "It seems GHC is just too smart. Apparently it notices that a thunk (\() -> e) can only be applied to the same argument. Therefore, the first time the thunk is forced by applying it to (), the result can justifiably be memoized: the next time around the thunk will be applied to the same (), and hence, will give the same result anyway."
03:17:02 <mcstar> so the GC cant collect the result
03:17:14 <plat0> Indeed
03:17:40 <bitonic> plat0: since haskell is always pure, the compiler is free to perform a wide range of optimizations, including this one. but you have no guarantees
03:17:45 <plat0> Not having explicit control over when things can be memoised is rather a weakness of this approach, IMHO.
03:18:49 <bitonic> plat0: what would you do? mandate memoization when possible? compiler pragmas?
03:19:10 <dmwit> Could not reproduce.
03:19:33 <plat0> dmwit: Could not reproduce what?
03:19:42 <hpaste> dmwit pasted “memoization test” at http://hpaste.org/69414
03:20:33 <plat0> I see
03:20:36 <plat0> That's not my question though
03:20:43 <bitonic> dmwit: maybe the trace influenced GHC behaviour, since it uses unsafePerformIO
03:21:00 <bitonic> I'd check the core with the simple, pure function
03:21:26 <plat0> I'm saying from the operational semantics point of view, is lazy evaluation the same as an evaluation strategy that wraps everything in a \() -> ... and caches the results?
03:21:40 <dmwit> bitonic: constant folding turns it into Main.main3 = __integer 400
03:22:09 <bitonic> dmwit: right, so it does optimize it.
03:22:32 <dmwit> yes
03:22:33 <bitonic> plat0: more or less.
03:22:39 <dmwit> plat0: yyes
03:22:48 <plat0> OK that's good to know, thanks.
03:22:58 <dmwit> eh...
03:23:07 <bitonic> plat0: but there's pattern matching and seq to take into account in haskell
03:23:11 <dmwit> provided that you then have a call-by-value semantics after that =)
03:23:35 <dixie_> hmm, I saw somewhere and I don't know where request to help with testing of new wxhaskell installer for windows
03:23:35 <bitonic> dmwit: if every value is a thunk, you will
03:23:39 <dixie_> anybody know ?
03:23:41 <adamt> Using GHC.Conc.atomically, how do i execute more than one action atomically?
03:23:59 <plat0> bitonic: How does pattern matching change things?
03:24:17 <bitonic> plat0: it forces execution before you actually need the value
03:24:42 <plat0> bitonic: Depends what you mean by "need" I guess!
03:24:43 <dmwit> adamt: STM is a monad, so just sequence the actions with the usual monad operations.
03:24:48 <dmwit> adamt: (>>), etc.
03:25:04 <dmwit> oops, misread
03:25:16 <plat0> bitonic: and it doesn't force the value, just the constructor, surely?
03:25:19 <bitonic> plat0: ? what do you mean
03:25:32 <dmwit> Oh, no, GHC.Conc is the STM thing after all.
03:25:40 <bitonic> plat0: well, but to get the constructor you have to evaluate
03:25:50 <plat0> bitonic: I mean that if you need to pattern match to choose a code path, then you do indeed need to force something, regardless.
03:25:58 <plat0> bitonic: Sure, you have to evaluate something
03:26:00 <plat0> I agree.
03:26:14 <bitonic> plat0: e.g, `(\(_, _) = 1) undefined' === undefined
03:26:41 <adamt> dmwit: okay, thanks for the pointer. ;)
03:26:53 <bitonic> sorry, = should be -> :)
03:26:55 <BIGBOOMBA> hey guys, after updating to ubuntu 12.04 i'm getting error messages about ghc and ghc-doc
03:27:10 <bitonic> BIGBOOMBA: post them on hpaste
03:27:14 <dmwit> ?hpaste
03:27:14 <lambdabot> Haskell pastebin: http://hpaste.org/
03:27:18 <plat0> bitonic: sure I agree.  And the same would hold in a strict language where you wrap everything in \() -> ...
03:27:56 * roconnor needs a name for (Functor f) => (b -> f b) -> Store b a -> f a
03:28:21 <morel> roconnor: foobar
03:28:29 <bitonic> plat0: it's subtle. one could argue that what I posted should terminate, and in fact haskell offers a way to do that
03:28:34 <dmwit> :t Data.Traversable.traverse
03:28:35 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:28:37 <bitonic> (lazy patterns)
03:29:00 <dmwit> roconnor: hm
03:29:13 <hpaste> BIGBOOMBA pasted “ghc-doc error when trying to install  libdvdread4” at http://hpaste.org/69415
03:29:19 <mcstar> > (\(_, _) -> 1) (undefined, undefined)
03:29:20 <lambdabot>   1
03:29:26 <dmwit> roconnor: Store b a ~= (b, b -> a) ?
03:29:32 <bitonic> plat0: http://www.haskell.org/haskellwiki/Lazy_vs._non-strict
03:29:36 <BIGBOOMBA> not sure if i should be here or in the ubuntu channel
03:30:12 <roconnor> dmwit: yes
03:30:14 <BIGBOOMBA> i get other errors related to ghc-doc but i'm not sure how to replicate them
03:30:32 <mcstar> bitonic: if the second undefined were a regular haskell expression, that code wouldnt throw undefined, right?
03:30:44 <BIGBOOMBA> seems like something went wrong during the upgrade
03:31:10 <bitonic> mcstar: what's a "regular haskell expression"?
03:31:23 <plat0> bitonic: Thanks.  I suppose I'm actually more interested in non-strict evaluation ...
03:31:24 <mcstar> well, with undefined you go around the type system
03:31:26 <roconnor> dmwit: Store b a is also ~= foall f. (Functor f) => (b -> f b) -> f a, so this function I'm trying to name is a rearranged version of this iso.
03:31:29 <plat0> bitonic: anyway, thanks for your help.
03:31:31 <mcstar> with anything else, you dont
03:31:49 <dmwit> roconnor: Yeah, I was about to suggest something like runStore. =P
03:31:53 <roconnor> if I were edwardk I'd call the function %!@=~!
03:32:10 <bitonic> mcstar: `(\(_,_) -> 1) (let x = x in x)' works as well, and `error', and any other partial function
03:32:45 <mcstar> weird
03:33:01 <bitonic> mcstar: in other words, haskell lets you write diverging values :P
03:33:02 <BIGBOOMBA> bitonic, you're just drawing ascii butts now
03:33:14 <dmwit> BIGBOOMBA: Perhaps you should try reinstalling haddock.
03:33:27 <roconnor> dmwit: I'm a little tempted to call it eeks to rhyme with peeks and seeks.
03:33:34 <mcstar> bitonic: yeah, i didnt know
03:33:36 * dmwit is not really an Ubuntu expert
03:33:54 <bitonic> mcstar: really? you thought every haskell program terminated?
03:34:14 <mcstar> no
03:34:21 <sipa> sure it does, when the computer dies
03:34:29 <bitonic> mcstar: then you have diverging values
03:34:43 <mcstar> i heard this term just now for the first time
03:34:46 <dmwit> bitonic: I reject your application of the law of the excluded middle.
03:34:55 <dmwit> ;-)
03:34:58 <bitonic> mcstar: aka _|_, or bottom
03:35:22 <bitonic> dmwit: ehe.
03:35:39 <bitonic> constructivist
03:35:41 <mcstar> thats more familiar :)
03:36:13 <bitonic> mcstar: actually, that's not correct
03:36:47 <plat0> Does anyone here know about call-by-push-value?
03:37:34 <khs> Hi, what exactly is runhaskell ?
03:37:39 <khs> in ghc...
03:37:40 <bitonic> mcstar: there are non-terminating computations that produce stuff, e.g. [1..]. I'm not sure I'd call that bottom
03:37:41 <mcstar> bitonic: hm, i compiled this program but its terminated, i guess i didnt force its return value
03:38:00 <bitonic> mcstar: what program?
03:38:07 <morel> bitonic: what does terminate mean? main = main -- of course doesn't terminate. do all agda-programs terminate?
03:38:15 <bitonic> morel: yes
03:38:22 <morel> why?
03:38:26 <bitonic> you can't write that in agda
03:38:33 <morel> bitonic: is this a feature or a lack of a feature?
03:38:40 <bitonic> morel: so that you have a consistent logic
03:38:45 <bitonic> morel: it's both
03:38:55 <mcstar> bottom: <<loop>>
03:38:59 <morel> bitonic: in what way a consistent logic? Xplain.
03:39:01 <dmwit> khs: runhaskell interprets a Haskell file.
03:39:27 <mcstar> bitonic: http://sprunge.us/iWAc
03:39:32 <BIGBOOMBA> trying to reinstall gives essentially the same error - "haskell-platform-doc depends on ghc-doc; however:   Package ghc-doc is not configured yet"
03:39:40 <khs> I'm working on an interpreter for haskell, would it make sence to benchmark against runhaskell in addition to ghc ?
03:39:49 <bitonic> morel: he, this might take a long time if you haven't heard about curry-howard before :)
03:40:18 <bitonic> mcstar: yeah GHC tries to detect recursive values.
03:40:30 <dmwit> morel: Agda doesn't allow general recursion; all recursive definitions must have a proof of termination associated with them.
03:40:39 <bitonic> > (\(_,_) -> 1) (let x = x in x)
03:40:39 <dmwit> (The easiest way is to use structural recursion everywhere.)
03:40:41 <plat0> BIGBOOMBA: what does "apt-get -f install" say and do?
03:40:43 <lambdabot>   mueval-core: Time limit exceeded
03:40:48 <bitonic> mcstar: ^^^
03:40:51 <dmwit> khs: sure
03:41:14 <mcstar> bitonic: yeah, i tried that in ghci, i was just wondering how does the type of 'x' gets resolved
03:41:15 <morel> dmwit: cool.
03:41:23 <morel> bitonic: i heard about it!
03:41:31 <morel> "curry-howard isomorphism" or so…
03:41:31 <bitonic> morel: in short, haskell types can also be seen as logic propositions. the problems is that in hakell you can "prove" everything
03:41:43 <mcstar> bitonic: will it be inferred as x :: (t, t)?
03:41:48 <bitonic> @type (let x = x in x)
03:41:49 <lambdabot> forall t. t
03:41:52 <mcstar> bitonic: will it be inferred as x :: (t1, t2)?
03:41:55 <bitonic> morel: ^^^
03:42:09 <mcstar> bitonic: but that is not compatible with (_, _)
03:42:12 <bitonic> mcstar: x can have any type, see above
03:42:19 <hpaste> BIGBOOMBA pasted “Reply to plat0” at http://hpaste.org/69416
03:42:28 <bitonic> mcstar: it is. you can substitute `t' with whatever you want.
03:42:33 <bitonic> that's what the forall means.
03:42:47 <dmwit> morel: To say that Agda is a consistent logic is to say two things: there are types which no expression can ever have, and there are types which some expression has.
03:42:51 <morel> bitonic: hm am ahm.
03:42:53 <mcstar> well, well, i dont get that
03:43:00 <plat0> BIGBOOMBA: no I mean just "apt-get -f install"
03:43:02 <plat0> no haddock
03:43:15 <mcstar> it cant be "anything", it must fit the pattern
03:43:18 <bitonic> mcstar: `forall t. t' means "this value can have any type"
03:43:30 <mcstar> if let x = x in x werent looping, you would need a type of (t1, t2)
03:43:31 <bitonic> in very poor words :P
03:43:51 <morel> i should learn agda some day.
03:44:09 <dmwit> morel: There's two kinds of boring logics: the logics where everything is false, and the logics where everything is true. "consistent" means "not boring"
03:44:11 <bitonic> @type (let x = x in x) :: (a, b)
03:44:12 <lambdabot> forall a b. (a, b)
03:44:14 <hpaste> BIGBOOMBA pasted “"sudo apt-get -f install" error” at http://hpaste.org/69417
03:44:17 <bitonic> mcstar: ^^^
03:44:32 <bitonic> @type (let x = x in x) :: (a -> b)
03:44:33 <lambdabot> forall a b. a -> b
03:44:38 <bitonic> @type (let x = x in x) :: Int
03:44:39 <lambdabot> Int
03:44:45 <bitonic> mcstar: and so on.
03:44:48 <sunwi> @type a
03:44:49 <lambdabot> Expr
03:45:05 <bitonic> sunwi: that's something different :)
03:45:07 <dmwit> morel: Haskell is a boring logic, because everything is true: pick any old type you like, and I can write an expression with that type.
03:45:15 <BIGBOOMBA> "(let x = x in x)" <-- how can this be anything but gibberish?
03:45:24 <sunwi> :)
03:45:32 <dmwit> morel: In fact, Haskell is *such* a boring logic that you don't even have to tell me what type you picked before I write down my expression. =)
03:45:40 <bitonic> mcstar: this is an interesting and deep subject anyway, I suggest you read something better than me about it :)
03:45:43 <sipa> > undefined
03:45:44 <lambdabot>   *Exception: Prelude.undefined
03:45:48 <sipa> eh
03:45:50 <sipa> :t undefined
03:45:51 <lambdabot> forall a. a
03:46:17 <plat0> BIGBOOMBA: I would try "dpkg --remove ghc-doc haskell-platform-doc; apt-get install libffi5; apt-get install haskell-platform-doc"
03:46:21 <dmwit> BIGBOOMBA: You might enjoy "Learn You a Haskell", "Real World Haskell", or the "Gentle Introduction to Haskell".
03:46:34 <morel> dmwit: nice explanantion, now i got it! thanks!
03:46:58 <morel> dmwit: so, in agda there are types which you can't find values for?
03:47:04 <dmwit> Right!
03:47:06 <bitonic> morel: yes
03:47:18 <morel> dmwit: is this the property that is used for proving things?
03:47:19 <dmwit> data False -- here's one such type
03:47:20 <plat0> BIGBOOMBA: Dunno why it needs libffi and it's not already installed, but try those commands ...
03:47:24 <bitonic> morel: yes.
03:47:27 <dmwit> morel: It is, indeed.
03:47:40 <morel> dmwit: well, in haskell2010 that works though…
03:47:47 <morel> bitonic, dmwit: NICE!
03:47:47 <execc_13> Is there anything like 'Design patterns' in Haskell, or in FP in general?
03:47:54 <bitonic> morel: yes but it has no value
03:47:59 <dmwit> morel: It means you can write down a type without knowing before-hand if there's going to be an expression with that type. If you find an expression... then you've proved a theorem!
03:48:09 <bitonic> morel: but in haskell you can just slap an undefined
03:48:19 <mcstar> bitonic: but why wouldnt the type checker allow such a thing? looking at the types of symbols, it is evident at compile time, that the thing wont terminate, why would it allow such a thing?
03:48:23 <bitonic> morel: that is, undefined :: False
03:48:50 <morel> "undefined :: False" ??!
03:48:52 <hpaste> BIGBOOMBA pasted “sudo apt-get install libffi5” at http://hpaste.org/69418
03:49:14 <morel> oh, okay.
03:49:15 <mcstar> wouldnt->would
03:49:17 <unnali> execc_13: my experience is that most of them become parts of the language itself. whereas in OO you might have a Visitor or whatever, you just use higher-order funcs in FP (map, foldr, whatever.).
03:49:20 <bitonic> mcstar: because a large class of programs do not terminate. the irc client you're using, for example
03:49:29 <dmwit> morel: Yes, in Haskell, you can pick any type T you like and write "undefined :: T".
03:49:31 <barrucadu> mcstar: Evident at compile time? How?
03:49:32 <morel> i thought of False as Bool…
03:49:38 <barrucadu> mcstar: It may be evident in *some* cases, but not all
03:49:53 <morel> dmwit: is "data Void" defined somewhere in the base-package?
03:50:09 <dmwit> morel: Well, I picked a confusing name. If Void is more familiar, we can use that instead of False from now on.
03:50:09 <bitonic> mcstar: the ability to write non-terminating programs is related to turing completeness. agda & co are not turing complete
03:50:18 <mcstar> coq?
03:50:23 <bitonic> morel: no, see the `void' package
03:50:24 <dmwit> ?hackage void -- morel, it's here
03:50:24 <lambdabot> http://hackage.haskell.org/package/void -- morel, it's here
03:50:36 <morel> agda is not turing-complete? oO
03:50:37 <mcstar> oh, company
03:50:39 <BIGBOOMBA> some say monads are a strange, ugly way to do IO and basically demonstrate the folly of functional purity
03:50:42 <BIGBOOMBA> comments?!
03:50:45 <bitonic> morel: no
03:50:47 <dmwit> morel: Right!
03:50:52 <morel> thanks for the void-package.
03:50:58 <dmwit> morel: In fact, no language in which all programs terminate can possibly be Turing complete.
03:51:04 <morel> oh
03:51:06 <morel> wow
03:51:12 <unnali> BIGBOOMBA: I don't find it either, and principally because I use monads for so much more than IO. :)
03:51:20 <dmwit> morel: But Turing completeness is overrated. =)
03:51:20 <plat0> BIGBOOMBA: interesting.  So libffi6 is the latest version, and somehow ghc-doc requires libffi5.  Sorry about that!
03:51:21 <mcstar> turing completeness in overrated, even humans arent turing complete, they all terminate
03:51:35 <dmwit> okay
03:51:35 <morel> dmwit: yea, i see.
03:51:37 * dmwit -> bed
03:51:42 <morel> @time dmwit
03:51:44 <lambdabot> Local time for dmwit is Sat Jun  2 06:51:21 2012
03:51:49 <plat0> Ouch.
03:51:50 <bitonic> dmwit: that's not true, turing completeness is important :). most useful programs do not terminate
03:51:51 <morel> er… whuut?
03:51:51 <barrucadu> If they were turing complete, then the halting problem would be solved.
03:51:59 <sunwi> mcstar: they terminate because of mechanic failures
03:52:00 <execc_13> unnali: Well, may i ask nother way. Is there any 'Best practice' or 'Recipes' books?
03:52:12 <bitonic> execc_13: RWH?
03:52:18 <bitonic> @where RWH
03:52:18 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:52:53 <BIGBOOMBA> plat0: so ghc-doc needs libffi5, but libffi5 has been deprecated?
03:53:00 <unnali> execc_13: +1 bitonic's remarks.
03:53:17 <BIGBOOMBA> plat0: and i can't roll back from libffi6 (which it turns out i have) to libffi5...
03:53:57 <plat0> BIGBOOMBA: What does "apt-cache show ghc-doc" show?
03:54:02 <execc_13> Thanks)
03:54:05 <mcstar> so in agda, there is no unguarded recursion?
03:54:18 <bitonic> mcstar: right
03:54:19 <plat0> I'm rather surprised that ghc-doc would depend on libffi5.  I imagine it's a haddock problem actually.
03:54:41 <plat0> BIGBOOMBA: try "apt-get install ghc-haddock"
03:54:56 <mcstar> does this have to do with first order vs. higher order logic?
03:55:21 <plat0> I never knew agda was written in haskell, until now :)
03:55:31 <BIGBOOMBA> ghc-haddock already installed, newest version
03:56:00 <BIGBOOMBA> says it's set to manually installed. i don't recall manually installing it. wonder if that has something to do with it.
03:56:15 <morel> BIGBOOMBA: try "apt-get install --reinstall ghc-haddock"
03:57:06 <mcstar> im going to be an expert in automated reasoning, i already read john harrisons book: practical logic and automated reasoning up until the introduction
03:57:13 <BIGBOOMBA> that went through with no errors; i'll try installing the package that generated the error originally
03:57:19 <sunwi> > "hello"
03:57:20 <lambdabot>   "hello"
03:57:28 <morel> hi sunwi
03:58:04 <BIGBOOMBA> any thoughts on writing an OS in haskell, or compiling to machine language in general?
03:58:09 <BIGBOOMBA> haskell compiles to C, right?
03:58:21 <unnali> no, to machine code.
03:58:37 <jonaskoelker> the thought struck me too, BIGBOOMBA---writing a kernel in haskell would be... interesting :)
03:58:41 <sunwi> lol, i think haskell is ill-suited for writing OSes
03:58:43 <jonaskoelker> it does both, right?
03:58:44 <unnali> BIGBOOMBA: a project called Mirage runs Haskell directly on top of Xen, that's quite similar.
03:58:47 <BIGBOOMBA> oh...it's written in C, though?
03:58:53 <morel> BIGBOOMBA: yes, there were efforts to write an OS in haskell.
03:58:53 <unnali> http://openmirage.org/ https://github.com/avsm/mirage
03:59:05 <unnali> here's a Haskell OS: https://sites.google.com/site/haskell/house-operating-system
03:59:26 <BIGBOOMBA> haskell vs. scheme, thoughts?
03:59:28 <unnali> whoops, mirage is in OCaml. my bad!
03:59:39 <unnali> http://halvm.org/wiki/ HaLVM is the Haskell on Xen one.
03:59:39 <BIGBOOMBA> haskell, Ocaml, whatever
03:59:42 <BIGBOOMBA> j/k
03:59:42 <plat0> BIGBOOMBA: installation problem solved?
03:59:49 <unnali> BIGBOOMBA: hah. :D You almost had me going.
04:00:12 <morel> unnali: isn't Mirage OCaml?
04:00:22 <BIGBOOMBA> plat0, about to try the installation that gave teh error originally
04:00:22 <unnali> morel: yes, my bad. HaLVM is the one I wanted.
04:00:36 <unnali> morel: I spend time in both worlds, so they start to get mixed up in my head.
04:00:42 <morel> cool
04:00:50 <morel> i never heard of HaLVM…
04:00:54 <BIGBOOMBA> problem appears to be solved
04:01:00 <morel> BIGBOOMBA: thank me!
04:01:12 <unnali> BIGBOOMBA: re: "haskell vs. scheme"; apple vs. orange, thoughts?
04:01:12 <morel> :D
04:01:18 <plat0> BIGBOOMBA: cool
04:01:19 <BIGBOOMBA> thank you, morel :)
04:01:22 <BIGBOOMBA> and plat0
04:01:22 <morel> hehehe
04:01:31 <morel> plat0 in particular!
04:01:36 <BIGBOOMBA> just because morel's command did it, thanks to plat0 anyway :)
04:01:40 <BIGBOOMBA> for several tries
04:01:44 <morel> heh
04:02:14 <BIGBOOMBA> unnali: fuck apples and oranges; i eat meat
04:02:23 <unnali> BIGBOOMBA: huh. I don't!
04:02:35 <unnali> but at any rate, static vs. dynamic typing makes a big difference.
04:02:56 <BIGBOOMBA> what about teh macros
04:02:58 <BIGBOOMBA> ;)
04:03:03 <morel> and i eat loquats.
04:03:10 <morel> http://en.wikipedia.org/wiki/Loquat
04:03:49 <mcstar> you eat lolcats?
04:04:04 <BIGBOOMBA> wow, i just laughed out loud, loudly, for real
04:04:16 <unnali> BIGBOOMBA: sure, but they're not so incredible. I'll take an expressive type system over macros any day.
04:04:18 <morel> BIGBOOMBA: why?
04:04:43 <morel> is scheme dynamically typed?
04:04:43 <BIGBOOMBA> <morel> and i eat loquats. [05:02] <morel> http://en.wikipedia.org/wiki/Loquat <mcstar> you eat lolcats?
04:04:52 <morel> ah, ok, i see.
04:04:55 <unnali> ^yes.
04:05:10 <BIGBOOMBA> isn't there a site for funny stuff like that?
04:05:12 <BIGBOOMBA> i forget the name
04:05:17 <unnali> bash.org, qdb.us ...
04:05:22 <BIGBOOMBA> ah yes, bash
04:05:47 <morel> will you add it??
04:09:02 <morel> wait. 5:02? wtf?!
04:09:07 <morel> @time BIGBOOMBA
04:09:08 <lambdabot> Local time for BIGBOOMBA is Sat Jun 02 05:08:46 2012
04:13:15 <BIGBOOMBA> bash won't accept the submission
04:13:26 <BIGBOOMBA> i'm gonna paste it how i trimmed it; maybe someone knows what's wrong
04:13:57 <hpaste> BIGBOOMBA pasted “bash no likey” at http://hpaste.org/69419
04:14:01 <taylorgb> Just a heads up, Haskell jokes aren't likely to be accepted.
04:14:16 <BIGBOOMBA> it's not a haskell joke
04:14:40 <unnali> not nearly enough functor instances for loquats
04:14:44 <taylorgb> Could be because of the link, I don't know what their policy is on that.
04:14:53 <BIGBOOMBA> taylor, just thought of that
04:15:29 <BIGBOOMBA> yay, it worked after i took the link out
04:15:52 <BIGBOOMBA> (pending moderation)
04:16:06 <mcstar> the one with the VISA is quite laughable
04:25:33 <roconnor> @hoogle fold
04:25:33 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
04:25:33 <lambdabot> Data.List foldl :: (a -> b -> a) -> a -> [b] -> a
04:25:33 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
04:25:44 <roconnor> @type fold
04:25:45 <lambdabot> Not in scope: `fold'
04:26:04 <roconnor> @type traverse
04:26:05 <lambdabot> Not in scope: `traverse'
04:26:12 <roconnor> @type traverseA
04:26:12 <lambdabot> Not in scope: `traverseA'
04:26:15 <roconnor> :/
04:27:10 <taylorgb> @type Data.Foldable.fold
04:27:11 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
04:30:14 <morel> How does Integer work internally?
04:30:57 <taylorgb> To which how are you referring?
04:31:17 <merijn> morel: What do you mean by "work"?
04:32:15 <morel> merijn: well, Int is just a 32-bit number or so, internally. that is, it's just 32-bits or ss.  but how does Integer work?
04:32:46 <silver> with gmp library as backend
04:33:12 <silver> GMP is a free library for arbitrary precision arithmetic, operating on signed integers, rational numbers, and floating point numbers. There is no practical limit to the precision except the ones implied by the available memory in the machine GMP runs on. GMP has a rich set of functions, and the functions have a regular interface.
04:33:59 <morel> silver: nice, coool. thanks… i'm still wondering how GMP handles such big numbers internally though…
04:34:15 <silver> sadly I don't know :(
04:35:06 <ment> morel: mostly pen & pencil algorithms
04:35:16 <ment> morel: with uint8/unit32 digits
04:36:07 <unnali> ^ what
04:36:08 <unnali> The speed is achieved by using fullwords as the basic arithmetic type, by using fast algorithms, with highly optimised assembly code for the most common inner loops for a lot of CPUs, and by a general emphasis on speed.
04:36:32 <roconnor> frontPL listLens ^$ [1,2,3]  ---> 3
04:36:33 <roconnor> ...
04:36:36 <mcstar> there no magic, you could have a big vector of bits and operate on them like they were integers
04:36:40 * roconnor renames frontPL to backPL
04:38:20 <mcstar> a lot of people make their own bigint implementation for PE
04:38:30 <mcstar> personally i think its a waste of time
04:38:46 <sipa> PE?
04:38:51 <morel> project euler
04:39:22 <morel> @where pe
04:39:22 <lambdabot> I know nothing about pe.
04:39:28 <morel> @where+ pe http://projecteuler.net/
04:39:28 <lambdabot> Okay.
04:39:30 <morel> @where pe
04:39:30 <lambdabot> http://projecteuler.net/
04:45:56 <morel> there are so many language-extensions which should be included in the language-specification… e.g. kind-signatures.
04:46:09 <morel> and multiparamtypeclasses!
04:46:14 <unnali> morel: there's been a lot of discussion of said on the mailing lists.
04:47:10 <morel> unnali: kind-signatures or multiparamtypeclasses?
04:47:48 <unnali> rather, extensions which should become in the spec.
04:48:02 <unnali> actually, i'm a bit wrong -- they were extensions which should be defaults in GHC, which isn't the same thing at all
04:48:49 <unnali> morel: one such discussion: http://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid
04:48:51 <roconnor> @type (<**>)
04:48:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
04:49:17 <morel> roconnor: /msg lambdabot pls
04:49:27 <roconnor> k
04:51:49 <unnali> morel: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/98570
04:54:25 <morel> oh, i read that mail, yes
04:54:54 <Peaker> How is this: class Lift1 f where lift1 :: (a -> b) -> f a -> f b ;  class Lift1 f => Lift2 f where lift0 :: a -> f a ; lift2 :: (a -> b -> c) -> f a -> f b -> f c ; class Lift2 f => Join f where join :: f (f a) -> f a
04:55:20 <Peaker> lift0, lift1, lift2 rather than various unrelated names that don't show the relationships: pure, fmap, liftA2
04:55:30 <Peaker> lift0, lift1, lift2, join  to rule them all
04:55:48 <Peaker> Then we'd have thousands of Join tutorials :)
05:01:22 <byorgey> nice =)
05:06:50 <Peaker> it's nice that liftN is composeable in a way that (<*>) isn't
05:07:43 <Peaker> lift0 . lift0 . lift0,   lift1 . lift1 . lift1,   lift2 . lift2 .lift2,   etc.  shows why Functor/Applicative are composable where Monads aren't
05:10:53 * hackagebot SafeSemaphore 0.9.0 - Much safer replacement for QSemN, QSem, and SampleVar  http://hackage.haskell.org/package/SafeSemaphore-0.9.0 (ChrisKuklewicz)
05:11:23 <Peaker> I never really understood the point of semaphores.. I don't think I ever saw a semaphore in the wild that wasn't used as a mutex
05:12:22 <hpc> i like languages where any object can be a semaphore
05:13:46 <Peaker> don't they just have mutexes in every single object?
05:16:46 <hpc> probably
05:17:07 <hpc> i think it's a great opportunity for obfuscated threading code
05:20:29 <hiptobecubic> semaphores are much nicer to work with than mutex+counter manually
05:26:26 <Peaker> hiptobecubic, when do you do that?
05:28:17 <mcstar> http://bash.org/?330261
06:21:06 * hackagebot Hach 0.0.1.1 - Simple chat  http://hackage.haskell.org/package/Hach-0.0.1.1 (DmitryMalikov)
06:21:56 <Taneb> What's the point of Comonads?
06:22:25 <hpc> nonononono, comonads have copoint
06:22:40 <Taneb> :P what's the copoint of comonads, then?
06:22:52 <hpc> (basically, if monads are structure you can put things into, comonads are structure you get things out of)
06:22:56 <ion> You could also ask “cowhat’s the point of comonads”.
06:23:53 <hpc> a comonad is a type with operations
06:23:58 <hpc>   dup :: w a -> w (w a)
06:24:07 <hpc>   extract :: w a -> a
06:25:21 <mcstar> who put the thing in the comomad in the first place?
06:27:00 <Taneb> Can you tell me some examples of its use?
06:27:12 <hpc> http://hackage.haskell.org/packages/archive/comonad-random/0.1.2/doc/html/Control-Comonad-Random.html -- here's a good example of comonads in action
06:27:40 <taylorgb> Can you have comonad transformers, or monad cotransformers?
06:28:24 <Taneb> How could a codo notation  work?
06:29:52 <Leif_Bork> Hellou!
06:30:12 <hughfdjackson> is $'s low precedence the natural result of the one shared by all infix functions
06:30:13 <Leif_Bork> When defining data-stuff with the pipe sign
06:30:16 <hughfdjackson> or is it magical?
06:30:28 <Leif_Bork> How should I write records so that it looks good?
06:30:34 <Taneb> hughfdjackson, you can define infixiness
06:30:57 <byorgey> hughfdjackson: it's not magical, it is simply declared to be 0.  All infix functions do not share the same precedence.
06:31:20 <hughfdjackson> Taneb: :D i've done this (a replacement implementation with % as application)
06:31:25 <hpc> Leif_Bork: when writing records, you generally don't want to be using the pipe sign
06:31:28 <hughfdjackson> but i didn't know how to know if it just worked i my test cases, or generally
06:31:34 <Leif_Bork> hpc: Why?
06:31:39 <hpc> Leif_Bork: or to put it in more correct terms, your record should have exactly one constructor
06:31:43 <hughfdjackson> byorgey: can you define precedence for an infix?
06:31:47 <hpc> Leif_Bork: consider the following
06:32:13 <hpc> data Foo = Nope | Yep {theWord :: String}
06:32:14 <byorgey> hughfdjackson: that's the only thing you *can* define precedence for
06:32:29 <byorgey> precedence for prefix things does not make sense
06:32:33 <hpc> now, theWord (Yep "bird") is going to evaluate to "bird"
06:32:39 <hpc> but what about theWord Nope?
06:32:46 <hughfdjackson> byorgey: :D cheers, shall look that up
06:32:48 <fabrydrunk> hello
06:32:48 <Leif_Bork> You mean it's unsafe
06:32:53 <hpc> yeah
06:32:56 <byorgey> hi fabrydrunk
06:32:57 <Leif_Bork> Oki
06:33:00 <Leif_Bork> Thank you
06:33:00 <fabrydrunk> I've got a problem with xmonad configuration
06:33:16 <hpc> fabrydrunk: #xmonad is that way -->
06:33:22 <hpc> they'll know more than us
06:33:51 <fabrydrunk> mm so who I can contact to help me?
06:34:12 <byorgey> though if it's just a problem with syntax etc. it's fine to ask here
06:34:23 <hpc> fabrydrunk: /join #xmonad
06:34:37 <fabrydrunk> oh thanks :)
06:35:29 <fabrydrunk> anyway it's probably a syntax error
06:37:34 <jonaskoelker> is there some fancy way of piping a value through a series of function, so that it reads left(inside)-to-right(outside)?
06:37:47 <jonaskoelker> i.e. "($) but the other way" :-)
06:38:01 <unnali> jonaskoelker: well, what's the type? hoogle it :)
06:38:01 <ClaudiusMaximus> :t (>>>) `asTypeOf` (Prelude..)
06:38:02 <lambdabot> forall b. (b -> b) -> (b -> b) -> b -> b
06:38:04 <byorgey> jonaskoelker: you can use (>>>) which is (.) but the other way
06:38:09 <unnali> :t ($)
06:38:10 <lambdabot> forall a b. (a -> b) -> a -> b
06:38:26 <unnali> @hoogle a -> (a -> b) -> b
06:38:27 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
06:38:27 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
06:38:27 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
06:38:30 <hpc> also (#) = flip ($) might be nice
06:38:31 <byorgey> jonaskoelker: or if you really want ($) but the other way you can just define your own, e.g.  (#) = flip ($)
06:38:53 <jonaskoelker> :i (>>>)
06:38:58 <jonaskoelker> hoogle (>>>)
06:39:00 <byorgey> jonaskoelker: from Control.Arrow
06:39:00 <jonaskoelker> @hoogle (>>>)
06:39:01 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
06:39:01 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
06:39:06 <jonaskoelker> I fail -.- :)
06:40:23 <unnali> :t Data.Accessor.Basic.($%)
06:40:24 <lambdabot> Couldn't find qualified module.
06:40:28 <unnali> heh >_>
06:40:57 <hpaste> adamt pasted “type-problems related to IO ProcessHandle” at http://hpaste.org/69428
06:41:01 <unnali> does seem to be defined as (#) most often.
06:41:28 * adamt is typing a reason for people to click the paste
06:42:19 <unnali> :t Control.Conditional.(?)
06:42:20 <lambdabot> Couldn't find qualified module.
06:42:26 * unnali gives up.
06:43:05 <adamt> I have data ChildApp = ChildApp {... , .. ="Maybe ProcessHandle", .. }, and want to make a function in where i execute the process handle, and stick the process into the ChildApp structure.
06:44:06 <adamt> I know i can't turn something with IO into non-IO, so i suspect my typesig for the function has to be something with IO, i just don't know how/where/etc.
06:44:46 <hpc> @let mkChildApp = 15 -- just for demonstration
06:44:47 <lambdabot>  Defined.
06:45:16 <hpc> > do {let {app = mkChildApp}; putStrLn "some IO stuff"; return app}
06:45:18 <lambdabot>   <IO Integer>
06:45:21 <hpc> voila!
06:45:38 <hpc> replace {;} with layout, etc
06:55:46 <nomeata> Hi. Does Vincent Hanquez hang around here?
07:05:49 <nomeata> Or is there maybe someone else who can comment on https://github.com/vincenthz/hs-cryptocipher/issues/16?
07:06:49 <mekeor> did you mail him?
07:11:57 <nomeata> mekeor: no, just filed the bug
07:12:18 <nomeata> (I’m not implying he is slow or unreachable.)
07:16:09 <mekeor> mail him.
07:17:50 <rydgel> hi guys, is Yesod a good web framework to start learning Haskell too?
07:18:38 <mekeor> rydgel: so, you know the basics of haskell already?
07:19:16 <mekeor> a web-framework is certainly not good for learning the basics of haskell.
07:20:20 <mekeor> (unlike learning ruby with rubyOnRails, probably, dunno.)
07:20:45 <unnali> mekeor: even then I'd say it's a bad idea. :| rails does weird things to ruby beginners.
07:21:06 <mekeor> OK.
07:22:14 <rydgel> mekeor: rails is awful, it does a lot of things magically. But yes I know the basics of Haskell, and I've got a few books
07:23:32 <unnali> rydgel: Yesod is maybe particularly not a great idea, if only because it uses a *lot* of Haskell's magic. (different kind of magic to rails ;-))
07:24:10 <rydgel> unnali: ow. So maybe I should instead make something from scratch right?
07:24:22 <unnali> rydgel: might be more instructive. :)
07:24:40 <unnali> LYAH and RWH are both good bets in terms of books, if they're not already on your list.
07:25:00 <dschoepe> There are also projects that are better for learning the basics though. xmonad (the core, not contrib) is pretty readable, imo.
07:25:56 <rydgel> unnali: that's the 2 books I own ;)
07:26:03 <unnali> awesome :)
07:26:09 <unnali> off to a good start then!
07:26:16 <rydgel> dschoepe: my wm is xmonad :3
07:26:42 <pooya72> noob question: in other languages i would use things like ruby hashes, and clojure maps, that map key-value pairs. In haskell is it better just to assign it a data type and use things that way? Does haskell even have hashes?
07:26:51 <dschoepe> rydgel: Then looking at its source may be a fun experience, since you already have an intuition of what the parts may be supposed to do.
07:26:55 <unnali> rydgel: I might be a bit heretical in suggesting, but for me taking a look at another functional programming language with a different take helped me see some of the decisions in context. (for me that was OCaml.)
07:27:01 <Phlogistique> RWH is pretty outdated though
07:27:18 <unnali> pooya72: that's Data.Map; but check out this question/answer on StackOverflow first: http://stackoverflow.com/questions/10786178/why-does-haskell-lack-a-literal-data-map-constructor-syntax
07:27:26 <rydgel> unnali: I coded a few stuff in clojure, might that help? :)
07:27:30 <unnali> Phlogistique: yeah, that was my experience when I see it in the SERPS.
07:27:37 <dschoepe> @where gentle -- I also liked this, even though it's usually not considered very gentle
07:27:37 <lambdabot> http://www.haskell.org/tutorial/
07:28:08 <unnali> rydgel: that'll definitely be handy for a functional programming mindset; for me it was things like seeing laziness, functional purity, monadic IO, monads in general, etc. in context.
07:28:27 <unnali> OCaml is similar to Haskell superficially, but it's strict and impure -- and already you have a world of difference.
07:28:38 <unnali> but anyway, that's more of an academic exercise.
07:28:42 <Phlogistique> also the 48 hours Scheme is a good introduction to a bigger program in Haskell
07:28:54 <Phlogistique> it goes well hand-in-hand with the gentle intro
07:29:39 <hpaste> Tom pasted “Conditional execution in do” at http://hpaste.org/69429
07:30:04 <pooya72> unnail: thanks. I think that answered my question. I really like data types in haskell. But IO monads are still weird :)
07:31:01 <tew88> Is anyone able to hold my hand through the following compilation error (http://hpaste.org/69429)? I think it's a misconception on my behalf RE conditional execution within a do...
07:31:32 <Squarism> This has to be one of the bigger channels on freenode - but allways quiet in here?
07:32:00 <rydgel> thanks all, I'm going to dive in Haskell more. I already love it.
07:32:26 <pooya72> what's the most minimal web framework for a noobie to use to learn haskell? or should I just go with yesod?
07:32:45 <stepcut> pooya72: happstack-lite ?
07:32:58 <ion> pooya72: Perhaps learn the basics first from LYAH.
07:33:04 <stepcut> pooya72: http://www.happstack.com/C/ViewPage/9
07:33:22 <stepcut> pooya72: the tutorial assumes some familiarity with Haskell though
07:33:30 <pooya72> what about scotty: https://github.com/xich/scotty
07:33:44 <pooya72> ion: yeah I'm going through that
07:33:51 <stepcut> pooya72: but all the types are made as simple as possible, and there is a minimal number of functions
07:34:39 <pooya72> stepcut: thanks!
07:37:20 <rydgel> Another noob question: can Xmonad have memory leaks if I code like a dumbass, or is there something like a garbage collector? Since all seems compiled to bytecode I don't think so. Is there a tool to track memory leaks?
07:37:46 <navaati> tew88: after "then" and "else", there must be expressions. "
07:37:46 <lambdabot> navaati: You have 1 new message. '/msg lambdabot @messages' to read it.
07:37:47 <navaati> ( o, _ ) <- genNormalDist ( u, v )
07:37:47 <navaati> return ( g + o )" is not an expression, however if you add a do before the pattern-matching (and adapt the indetnation in consequence), it'll be
07:38:03 <tew88> navaati: Got it, thanks
07:38:14 <geekosaur> rydgel, there is no bytecode involved, and Haskell is garbage-collected
07:38:21 <tew88> navaati: Incidentally, genNormalDist isn't IO, either! ;)
07:38:25 <tew88> <-- idiot
07:39:47 <navaati> oh, is it pure ? then, "return . (g+) . fst $ genNormalDist ( u, v )" :)
07:40:17 <navaati> (and thus no "do" necessary)
07:52:58 <arnsholt> What's the difference (if any) between Array and Data.Array?
07:53:36 <sipa> i guess Array dates from before hierarchical modules
08:06:14 * hackagebot indexed-extras 0.1.1 - Indexed functors, monads and comonads that require extensions to Haskell98  http://hackage.haskell.org/package/indexed-extras-0.1.1 (ReinerPope)
08:11:14 * hackagebot safe-freeze 0.2.1 - Support for safely freezing multiple arrays in the ST monad.  http://hackage.haskell.org/package/safe-freeze-0.2.1 (ReinerPope)
08:21:18 * hackagebot shelly 0.9.5 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.9.5 (GregWeber)
08:26:03 <ClaudiusMaximus> no library for writing animated gifs :(
08:26:23 <ClaudiusMaximus> guess i'll stick to ppm + gifsicle commandline...
08:30:52 <byorgey> ClaudiusMaximus: what's wrong with diagrams? ;)
08:31:24 <byorgey> (seriously though, I'm curious what you're trying to do)
08:32:52 <ClaudiusMaximus> byorgey: http://img191.imageshack.us/img191/2057/warp11d.gif
08:33:04 <mekeor> coool
08:33:25 <ClaudiusMaximus> byorgey: does diagrams support animgif? didn't find anything on hayoo..
08:33:39 <mcstar> ClaudiusMaximus: :( i was curious to see some warp action, but you disappointed me
08:33:40 <byorgey> ClaudiusMaximus: oh, I see, you want a library for creating animated gifs from existing images
08:34:14 <mcstar> rectangular rotating lollipoop
08:34:28 <byorgey> ClaudiusMaximus: not directly, but you could make an animation and output pngs, then convert.  But of course that's only if you're doing stuff with vector graphics.
08:34:52 <ClaudiusMaximus> byorgey: well, from haskell code - not necessarily existing images
08:36:55 <mcstar> ClaudiusMaximus: is that some 11th degree newton fractal?
08:37:03 <ClaudiusMaximus> mcstar: yep
08:37:24 <mcstar> ClaudiusMaximus: add much more frames, id look better
08:37:35 <ClaudiusMaximus> mcstar:  f(z) = (9.090909090909091e-2) * z^11 + (-0.3333333333333333) * z^9 + (0.42857142857142855) * z^7 + (-0.2) * z^5 + (cis t)
08:37:55 <ClaudiusMaximus> mcstar: that's with 1/5 the frames - the full 150 frames is about 6MB
08:38:04 <mcstar> :(
08:38:50 <mcstar> ClaudiusMaximus: maybe you'd be better off with ffmpeg?
08:38:53 <ClaudiusMaximus> mcstar: rendering a 1min 1080p version now though, if you like i can @tell you when it's on archive.org or wherever
08:39:08 <ClaudiusMaximus> mcstar: probably!
08:39:09 <mcstar> haha sure
08:40:54 <ClaudiusMaximus> it's essentially an implementation of this http://www.chiark.greenend.org.uk/~sgtatham/newton/ (the bit about specifying multiplicities of zeroes of the derivative; plus the smooth colouring)
08:41:23 <mcstar> i always sucked at coloring those damn fractals
08:42:14 <ClaudiusMaximus> mcstar: i'll put this on hackage when i get around to making it use regular Data.Complex instead of my half-baked MPTC+FD version...
08:45:55 <mcstar> http://imgur.com/rSZ0V when i was fond of mathematica...
08:46:26 * hackagebot Blobs 0.1 - Diagram editor  http://hackage.haskell.org/package/Blobs-0.1 (AlanZimmerman)
08:46:32 <adamt> but now you made an even prettier version with Haskell?
08:47:06 <mcstar> if you like the story better that way :)
08:50:18 <mcstar> if a codec supports affine transformation, a spinning something could be compressed well
08:50:26 <mcstar> do they?
08:52:52 <mcstar> there are some research papers
08:53:22 <pooya72> Is there any way to pattern match this? [[SqlInteger 31,SqlByteString "Title",SqlByteString "Body"]] so that I have SqlInteger do something and SqlByteString something else?
08:54:41 <mcstar> map a case over the list?
08:55:01 <pooya72> mcstar: how would i check for SqLInteger?
08:55:12 <monochrom> case mys of [[SqlInteger x, SqlByteString y, _]] -> ... x ... y ...
08:55:20 <mcstar> i assume SqLInteger is the constructor of a type of SqlValue
08:56:35 <pooya72> mcstar: yes it is
08:56:36 <mcstar> but that would only match that particular sequence, do you want that?
08:56:59 <monochrom> it is unclear what is wanted
08:57:58 <pooya72> I want to take a list like [[SqlInteger 31,SqlByteString "Title",SqlByteString "Body"]]  and map it to BlogPost {blogid = 1, title = "test", body = "first post", tags = "another post"} but have id remain as integer
08:58:31 <mcstar> map (\a -> case a of SqlInteger _ -> "int"; SqlByteString _ -> "bs"; _ -> "other") [SqlInteger 31,SqlByteString "Title",SqlByteString "Body"]
08:59:21 <mcstar> you want a record, from a list of SqlValues
08:59:32 <monochrom> ok, I am not seeing the connection, if any, from 31, "Title", "Body" to 1, "test", "first post", "another post"
09:00:01 <monochrom> perhaps I should just not answer
09:01:09 <pooya72> mcstar: you smart man
09:01:36 <mcstar> pooya72: if im correct about what you want, you can write a case like i did, and make it into a recursice function, that travels the list, and repeatedly updates a record that was 'empty'
09:02:56 <adamt> when using System.Process.runProcess, will it automatically start the new process in a new thread, or do i have to fork it?
09:04:04 <pooya72> mcstar: thanks man, you got me on to the right track.
09:04:11 <mcstar> np
09:05:31 <mcstar> adamt: you dont need to fork it
09:05:41 <pooya72> so why is haskell so string about keeping integers and strings on separate lists?
09:05:48 <mcstar> createProcess runs it for you, and form the doc, i think this behaves similarly
09:06:03 <pooya72> sorry so strict about .. not string about
09:08:59 <taylorgb> pooya72: What do you mean by that?
09:10:07 <pooya72> taylorgb: why doesn't haskell allow integers and strings to be in the same list? like [21,"hello"]
09:10:42 <taylorgb> Because the Haskell cons list is a homogenous list and there isn't implicit coersion of integers to strings.
09:11:15 <pooya72> taylorgb: ok, so it's because of the strict type system?
09:11:29 <mcstar> this is not really the 'why' but the 'what'
09:12:00 <pooya72> mcstar: couldn't haskell just do something like [a,a,a]
09:12:06 <taylorgb> Yes, it's statically typed, therefore you can't do that. If you want to do that you'll need to use Typeable, or tuples, or some other mechanism.
09:12:23 <mcstar> pooya72: you can have product types, called tuples
09:12:30 <mcstar> but they are of fixed 'length'
09:13:17 <pooya72> mcstar: yeah, i just wanted to why lists were the way they are. I'm sure they could have made it more robust with type inference, or maybe made them more like tuples.
09:13:21 <mcstar> pooya72: you are accustomed to 'dynamic languages' which employ a teg-system
09:13:24 <mcstar> tag*
09:13:30 <pooya72> mcstar: yeah
09:13:35 <mcstar> all the types basically derive from 1 type
09:13:45 <mcstar> so these union types are natural
09:14:12 <mcstar> but with 'real' type systems, this is different, you have to be very explicit about sum types
09:14:28 <mcstar> (excuse my vocabulary, im not an expert)
09:15:07 <pooya72> mcstar: but why?
09:15:26 <mcstar> you lose some control over your types
09:15:49 <pooya72> mcstar: if they aren't explicit?
09:15:56 <mcstar> if they are present at all
09:16:23 <mcstar> just think about list, there are 2 constructors: Null and Cons
09:16:35 <mcstar> but the type is List a
09:16:59 <mcstar> now, your code branches, depending on what it encounters, Null or Cons
09:17:08 <mcstar> (or call Null Nil rather)
09:18:06 <mcstar> now imagine, you make a list of List (Maybe Int), now you have 4 constructors
09:18:12 <mcstar> Nil, Cons, Nothing, Just
09:19:11 <mcstar> at least in haskell there is a great way to do this: pattern matching
09:19:17 <mcstar> but how do you handle this in c++?
09:19:27 <mcstar> with unions? or with OO?
09:22:29 <adamt> mcstar: thank you very much
09:25:34 <adamt> mcstar: I think people cross their fingers, and hope not to do nasty things when they shouldn't (in c++) ;)
09:26:15 <taylorgb> adamt: Since when?
09:26:27 <mcstar> well, i write horrible c++ code
09:26:54 <taylorgb> My experience has been that people admit the language is inconvenient, then do the nasty things anyway, because it makes more sense than duplication.
09:27:34 <mcstar> id like something like lambda-class in the language
09:27:56 <mcstar> oh, and better c++11 support in msvc
09:28:00 <taylorgb> Personally, I think C++ really needs a module system that works first.
09:28:04 <a95m> kk`, hai
09:28:07 <a95m> I should have known.
09:28:09 <mcstar> (i had to deploy something on win)
09:29:00 <taylorgb> Yeah, they're not doing so well in that regard. Seems that they're putting off variadic templates at least. But I guess it's not surprising as I think they've got basically 1 library developer and 1 or 2 front end developers.
09:29:13 <taylorgb> They even outsource the intellisense engine, which perhaps explains why it is so awful
09:29:33 <pooya72> mcstar: thanks, I think I got it now. types help to keep the functions pure and which also help for pattern matching. Mixed lists of strings and integers would give multiple result types and would not keep functions pure. am i close??
09:29:49 <mcstar> no
09:30:42 <monochrom> types help prevent some non-sense code
09:32:02 <pooya72> mcstar: haha, that sucks. thought i got it
09:32:16 <pooya72> monochrom: so that's all types are for? helping the coder?
09:32:26 <taylorgb> I'm not convinced list elements with mixed types is a desirable property. You either lose compile-time safety as you require more run-time checking and magic, or you lose utility as you've got to define functions in pretty much everything for the varying types.
09:32:36 <monochrom> yes. sometimes it also helps the compiler on code optimization
09:33:40 <mcstar> you apply functions to elements of the list, but you cant make sure, there are only 1 types of elements in the list, (1, that That function accepts), so what happens? you deal with types at runtime?
09:33:49 <mcstar> or give up at compile time?
09:34:20 <mcstar> yeah, compile time safety exatcly
09:34:52 <taylorgb> Alternative being you can only map over a structure with functions that handle each type of the element.
09:35:10 <mcstar> pooya72: you have types in python too, you could say, that a class that implements a method is of type A, another one is of type B that doesnt have it
09:35:22 <taylorgb> Which is roughly the same as using tuples
09:35:22 <mcstar> but it is runtime, when you actually check this property
09:35:33 <mcstar> you cant do that at compile time in a language like python
09:36:11 <monochrom> earlier checks are better. static check is earlier than runtime check. runtime check is still better than never check
09:36:35 <mcstar> monochrom: never check? does that behavior really exist?
09:36:50 <monochrom> exists in assembly and perl
09:37:00 <mcstar> asm ofc, but in perl??
09:37:06 <monochrom> and php
09:37:06 <taylorgb> C++ too ;)
09:37:09 <mcstar> i take your word for it
09:37:20 <mcstar> taylorgb: run time polymorphis?
09:37:47 <mcstar> taylorgb: or you mean some casting operation?
09:37:54 <taylorgb> I was thinking about casting
09:37:57 <mcstar> k
09:38:00 <taylorgb> But I suppose it depends on your view
09:38:05 <ion> Real men type everything as void * in C and coerce at the last moment.
09:38:35 <mcstar> real men are a myth
09:38:49 <ion> Chuck Norris is a myth?
09:38:54 <mcstar> isnt it?
09:39:13 <monochrom> the "feature" in perl I have in mind is: an object becomes different values in different "contexts" ("scalar context", "list context").
09:39:18 <adamt> Nothing matters, because you're all inside the Matrix, and are clueless about the real world.
09:39:38 <mcstar> wrong, you can have real world haskell
09:39:42 <taylorgb> I'm not sure, real men are often purported to do something pretty stupid sounding. Quite a few of those people exist.
09:39:57 <pooya72> so this conversation went over my head :)
09:40:18 <monochrom> now, if you say, that is not no-checking, that is casting and/or runtime polymorphism. ok sure, but the same can be said about what everyone agrees to be no-check in assembly.
09:40:26 <mcstar> monochrom: is that some implicit conversion?
09:40:55 <monochrom> "the same register value becomes different things in different contexts: char context, int context, pointer context"
09:41:41 * mcstar "ive never seen anyone quote their own thoughts"
09:41:44 <monochrom> yes, implicit conversion. and it is implicit conversion in both perl and assembly.
09:41:51 <monochrom> heh
09:42:45 <taylorgb> @faq Can Haskell deliver me a pizza.
09:42:46 <lambdabot> The answer is: Yes! Haskell can do that.
09:42:53 <taylorgb> Great
09:44:29 <pooya72> we should have a series of Chuck Norris style haskell jokes
09:44:47 <monochrom> we have Oleg
09:44:52 <silver> I guess it's too late to do that
09:44:53 <pooya72> Haskell typeclasses are so hard core, they write themselves
09:44:56 <monochrom> @quote oleg.*type
09:44:57 <lambdabot> Jafet says: Can oleg create a term so complicated that even he could not type-check it?
09:44:58 <snhmib> chuck norris doesn't do haskell he just stares at the computer until it works
09:45:07 <monochrom> @quote oleg.*type.level
09:45:08 <lambdabot> edwardk says: oleg doesn't write haskell. he writes prolog. he just happens to write it at the haskell type level.
09:45:34 <monochrom> we have several jokes like "Oleg does ____ at the type level!"
09:45:49 <mcstar> Oleg already did it!
09:46:04 <monochrom> a fabled example is "Oleg solves the halting problem... at the type level!"
09:47:06 <pooya72> yeah, i googled it and got this http://haskell.spreadshirt.com/oleg-already-did-it-A6499531
09:47:27 <mcstar> it just happens that i know someone named oleg, he had quite a laugh when i shoed him an 'oleg adi' t-shirt
09:47:31 <mcstar> showed*
09:47:37 <silver> lol
09:47:47 <mcstar> the guys knows some ocaml too
09:47:47 <silver> funny thing my name is Oleg
09:48:02 <ion> There can be only one!
09:48:04 <silver> and I suck and CS :D
09:48:07 <silver> at
09:48:29 * mcstar thinks hard of nasty CS acronym
09:48:52 <silver> lol don't do that please !
09:48:56 <mcstar> XD
09:48:57 <silver> :D
09:53:29 <taylorgb> Hm, Oleg's site seems rather useful. I've been looking for a place where everything complicated lives.
09:54:03 <monochrom> hehe
10:31:13 <mrkronecker> I am getting this wild, inexplicable inconsistency between GHCI and compiled code insofar as input and output are handled. Essentially I just have -
10:31:16 <mrkronecker> http://pastebin.com/RuVqSsv3
10:31:20 <mauke> The paste RuVqSsv3 has been copied to http://hpaste.org/69433
10:31:40 <mrkronecker> this piece of code being called repeatedly (cliPutStr wraps putStr and cliGetLine wraps getLine)
10:31:54 <mrkronecker> When this runs in GHCI I get this :
10:32:05 <mrkronecker> http://pastebin.com/KY1CsUAg
10:32:07 <mauke> The paste KY1CsUAg has been copied to http://hpaste.org/69434
10:32:11 <mrkronecker> which is what I want and expect!
10:32:18 <mrkronecker> But then I COMPILE my code and run the program and it botches up
10:32:29 <mrkronecker> http://pastebin.com/4dwJZ6H3
10:32:30 <mauke> The paste 4dwJZ6H3 has been copied to http://hpaste.org/69435
10:32:48 <mrkronecker> It looks like the output is completely delayed until the end
10:32:56 <Cale> mrkronecker: hSetBuffering stdout NoBuffering
10:33:11 <Cale> Or, call hFlush stdout after each prompt.
10:33:22 <mrkronecker> Ah, thanks!
10:33:48 <Cale> (That stuff is in System.IO)
10:34:19 <Cale> I believe the default is line buffering, but it's different in ghci
10:52:26 <hiptobecubic> j
10:54:43 <vodik> k
11:03:09 <mcstar> mauke almost fooled me for a person
11:04:13 <roconnor> http://www.youtube.com/watch?v=AC41C1XjZYY
11:50:58 <tgeeky_> someone put this in topic, if it's topic worthy: http://www.reddit.com/r/haskell/comments/uhhd2/icfp12_accepted_papers_with_links_where_available/#
12:26:18 <strager> @quote
12:26:18 <lambdabot> tnks says: I'm astounded that LYAH makes an FP language accessible, while Why's Poignant Guide makes a straight-forward imperative language look arcane.
12:27:56 <KaneTW> @quote
12:27:56 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
12:28:06 <KaneTW> whoops!
12:29:30 <strager> @quote
12:29:30 <lambdabot> dkc says: one way to scale a learning curve is to just flatten it with your face
12:32:32 <tgeeky> @quote physics
12:32:32 <lambdabot> nand` says: Programming in front of the compiler is like physics; you observe a system, make deductions, use these to build models then find methodology to arrive at your solution. Programming (with)
12:32:32 <lambdabot>  the compiler is like mathematics; your thoughts, your system, your rules, your experiments
12:32:39 <kallus> @tgeeky_ nice to see 2 papers from my quite small university (chalmers)! is it hard to get published there?
12:32:39 <lambdabot> Unknown command, try @list
12:33:12 <tgeeky> kallus: I don't know if it's hard to get published there. But Chalmers is quite involved in Haskell and FP
12:34:10 <dmwit> I have an FFI call that grabs a lock.
12:34:22 <dmwit> I replicateM_ 10 (forkIO grabLock >> return ())
12:34:30 <dmwit> and then I run with +RTS -N1
12:34:38 <dmwit> This results in three OS threads. Why?
12:34:55 <dmwit> (Why not 11?)
12:35:06 <tgeeky> oh. I thought you were going somewhere else.
12:35:21 <tgeeky> I thought the RTS doesn't try to be near 1-1?
12:35:25 <parcs`> dMazz: why 11?
12:35:27 <parcs`> dMazz:
12:35:29 <parcs`> dmwit:
12:35:43 <dmwit> One for the one HEC I asked for with -N1, and one for each FFI call.
12:36:16 <parcs`> ffi calls don't necessarily run in a separate thread
12:36:26 <dmwit> Alternately, one for the one HEC I asked for and one for FFI calls, for a total of two (still not three).
12:36:33 <tgeeky> dmwit: from Rts/Scheduler: An unbound thread is created by Control.Concurrent.forkIO. Foreign calls made by an unbound thread are made by an arbitrary OS thread.
12:36:54 <dmwit> Alternately, one for the one OS thread I asked for with -N1. Period.
12:37:03 <tgeeky> dmwit: that is what I would have expected
12:37:05 <dmwit> I really, really don't understand how we can get *three* OS threads out of this.
12:37:08 <tgeeky> you said one, you get one
12:37:45 <parcs`> -N<n>     Use <n> processors (default: 1)
12:37:47 <tgeeky> dmwit: do you happen to know if the number is different before they supported dynamic +RTS -Nxx ?
12:37:59 <parcs`> do processors == threads?
12:38:02 <dmwit> parcs`: Yes, but the manual doesn't agree. And also that doesn't answer my question even if it's true.
12:38:19 <dmwit> Right, because what does "use <n> processors" actually mean?
12:38:32 <dmwit> tgeeky: I didn't think to check.
12:38:46 <tgeeky> dmwit: also: When running on an SMP, we begin by creating the number of OS threads specified by the +RTS -N option, although during the course of running the program more OS threads might be created in order to continue running Haskell code while foreign calls execute. Spare OS threads are kept in a pool attached to each Capability
12:38:51 <tgeeky> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler
12:38:53 <dmwit> tgeeky: I'll give it a shot, wait a moment.
12:38:56 <tgeeky> dmwit: so that does explain 2 threads.
12:39:08 <Saizan> dmwit: i suspect the fact that main is a bound thread is relevant
12:39:10 <tgeeky> maybe the dynamic RTS explains a third
12:39:17 <dmwit> Saizan: Ah!
12:39:21 <dmwit> Saizan: Is that always true?
12:39:28 <dmwit> Saizan: If so, that would explain things perfectly...
12:39:39 <Saizan> dmwit: yep, afaik
12:40:08 <tgeeky> dmwit: yep: http://community.haskell.org/~simonmar/papers/conc-ffi.pdf <-- "The main thread"
12:40:20 <dmwit> Okay, so I get one OS thread for main, one OS thread for FFI calls, and one HEC.
12:40:23 <dmwit> accurate?
12:40:29 <dmwit> Saizan: ?
12:40:39 <Saizan> sounds plausible
12:41:01 <dmwit> The hypothesis then is that if I try +RTS -Nn, I'll get n+2 threads.
12:41:02 <dmwit> Let's try.
12:41:21 <dmwit> (up to a total of... 12?)
12:42:22 <dmwit> whoa
12:42:29 <tgeeky> over 9000?
12:42:36 <dmwit> -N11 gives 13 threads
12:42:54 <dmwit> Oh, I get it.
12:43:05 <dmwit> There's no maximum, because it just makes all the HEC threads up front.
12:43:20 <dmwit> So it's whatever number of HEC threads I ask for +1 for main +1 for FFI.
12:44:13 <tgeeky> dmwit: so, all FFI-using programs have at least 2 threads.
12:44:33 <dmwit> Well, all FFI-using programs linked with the threaded runtime.
12:44:45 <tgeeky> ok.
12:44:52 <tgeeky> dmwit: watcha hackin on?
12:44:54 <dmwit> And, I think, actually all have at least three threads.
12:45:01 <tgeeky> dmwit: yeah. because -N1 is default
12:45:05 <dmwit> +RTS -N0 is not allowed
12:45:06 <dmwit> right
12:45:32 <tgeeky> here you go RTS, schedule 0 threads. Scumbag programmer.
12:45:40 <dmwit> (This actually makes me wonder whether +RTS -N0 might be a reasonable thing to allow.)
12:46:03 <parcs`> dmwit: is grabLock marked safe or unsafe?
12:46:07 <dmwit> parcs`: safe
12:46:13 <dmwit> parcs`: Should have mentioned that, you're right.
12:46:13 <dmwit> sorry
12:46:36 <dmwit> Oh, actually... I didn't check, and just assumed it was safe.
12:46:38 <dmwit> Let's see.
12:46:42 <parcs`> by default it's safe
12:47:04 <dmwit> Ah, no, it's unsafe.
12:47:35 <parcs`> what happens to the thread count if you mark it safe?
12:47:48 <dmwit> That's a good question.
12:47:52 <dmwit> Let's make a hypothesis first.
12:49:16 <dmwit> I hypothesize that I'll get 12 threads with -N1: 1 for main, plus one HEC, plus one each for the 10 safe lock grabs.
12:49:24 <dmwit> Let's try it.
12:49:35 <parcs`> i think you'll still get 3
12:49:43 <dmwit> Okay, why?
12:50:01 <dmwit> You think even the safe calls will all go on the one FFI thread?
12:50:46 <parcs`> yeah. i can't really say why though. just an intuiton
12:52:14 <zzo38> Is idempotence of f sufficient to make (f x -> f y) arrow?
12:52:31 <zzo38> Is it necessary?
12:53:22 <dmwit> um
12:53:48 <dmwit> Now the program terminates.
12:53:50 * dmwit scratches head
12:54:42 <Taneb> Reader r a is like r -> a
12:55:04 <Taneb> Writer w a is like (w, a)
12:55:07 <zzo38> Taneb: Yes
12:55:10 <Taneb> Is State s a like anything?
12:55:11 <parcs`> dmwit: i guess because now that it's marked safe the main thread can progress and finally terminate
12:55:24 <parcs`> when it was unsafe the main thread was blocked due to the foreign call
12:55:29 <zzo38> However they don't have the Monad instance for (,) but they should have it
12:55:49 <byorgey> Taneb: yes, it is like  s -> (a,s)
12:56:00 <dmwit> parcs`: I think it's more likely I just built it wrong.
12:56:01 <Taneb> Okay, thanks byorgey
12:56:11 <zzo38> byorgey: But that type isn't a monad (or even a functor)
12:56:17 <zzo38> But, yes that is how State is
12:56:19 <byorgey> Taneb: which, you may note, is essentially  Reader s (Writer s a)
12:56:35 <Taneb> Hmm
12:56:36 <zzo38> byorgey: The monad is different, though
12:56:45 * hackagebot ftp-conduit 0.0.5 - FTP client package with conduit interface based off http-conduit  http://hackage.haskell.org/package/ftp-conduit-0.0.5 (MylesMaxfield)
12:56:47 * hackagebot Blobs 0.2 - Diagram editor  http://hackage.haskell.org/package/Blobs-0.2 (AlanZimmerman)
12:56:55 <dmwit> parcs`: I thought I was going to be clever and avoid rebuilding all of gtk2hs by creating a file SafeThreadsEnter.hs with 'module SafeThreadsEnter where foreign import ccall safe "gdk_threads_enter" safeThreadsEnter :: IO ()'.
12:57:09 <Taneb> So, RWS r w s is like r -> s -> (w, s, a)
12:57:12 <Taneb> Or something
12:57:23 <parcs`> dmwit: oh :P
12:57:26 <nand`> Taneb: yeah pretty much
12:57:28 <dmwit> Which was clever, but 'ghc -rtsopts -threaded test.hs' succeeded without any pointer to the real Gtk library...
12:57:41 <dmwit> so...
12:57:52 <dmwit> dunno what it's actually calling there
12:57:57 <nand`> Taneb: r -> s -> (a, s, w) to be precise
12:58:13 <Taneb> Okay, thanks nand`
13:01:55 <dmwit> oh, magical
13:02:15 <dmwit> It *is* linked against libgdk, because I happened to import a Gtk2Hs module that links against that.
13:02:29 <dmwit> So, yeah, it really does terminate.
13:02:36 <dmwit> Alright, we can fix that. =)
13:03:18 <parcs`> dmwit: yeah you're right about the 12 threads being spawned
13:03:28 <parcs`> (tested it with foreign import ccall "getchar" getchar :: IO Int)
13:04:13 <dmwit> Hm, is there no waitThread :: ThreadId -> IO ()?
13:04:33 <dmwit> parcs`: ah, cool
13:04:36 <shysoft> It seems like functional style programming is gaining traction in industry. Is Haskell, in particular?
13:04:44 <dmwit> parcs`: (and that's with -N1?)
13:06:17 <dmwit> parcs`: Well, here I get 13 threads!
13:06:22 <dmwit> (with -N1)
13:06:35 <zzo38> newtype State s a = State { runState :: s -> (a, s) }; fmap f (State x) = State (first f . x); return = State . (,); join (State f) = State (runState . fst . f <*> snd . f);
13:06:38 <byorgey> shysoft: yes.
13:07:18 <shysoft> What companies are using haskell
13:07:26 <byorgey> shysoft: http://www.haskell.org/haskellwiki/Haskell_in_industry  -- a bit out of date but still relevant
13:08:23 <zzo38> This is one way to define a State monad.
13:10:21 <shysoft> I ask because I'm interested in working with haskell and I'm trying to 1) determine whether it's a language with a future 2) find what opportunities are out there.
13:11:37 <parcs`> what kind of future are you talking about?
13:13:23 <parcs`> future in the sense that it will one day be popular in industry?
13:13:28 <younder> There will likely be languages that follow Haskell., But I am sure Haskell will be there too. It has already existed for almost 20 years and it's popularity has just increased.
13:13:42 <shysoft> A future like c++ in 1985, not COBOL in 1985.
13:14:23 <Philippa_> somewhere in between, I think
13:14:35 <Philippa_> technologically, Haskell is far more mature than C++ of '85 for example
13:14:40 <nand`> oh nice, detexify is written in Haskell
13:14:43 <younder> Tha larger the base of software written in a language the greater the pressure to keep the language alive.
13:14:44 <nand`> I did not know that :)
13:15:06 <Taneb> My parents learned COBOL around '85
13:15:56 <parcs`> nand`: looks like the successor is being written in ruby, though https://github.com/kirel/sketch-a-char
13:15:58 <mgsloan> shysoft: Even if Haskell doesn't come to be a primary language of the world, it seems reasonable to expect that it will remain influential for language design / evolution
13:16:02 <Philippa_> inertia is certainly a factor these days, but to nowhere the extent that it was for COBOL - in 15 years' time I expect most haskell uses to be legacy to some extent, but not the way COBOL was in 2000!
13:16:06 <younder> COBOL is still around as if Fortran and Lisp. But they have changed GREATLY in that time.
13:16:13 <mgsloan> and this has already happened with the evolution of C# / Perl / etc
13:16:16 <nand`> Haskell has already influenced concepts in a number of popular languages, including C#
13:16:29 <nand`> so by learning it you won't do yourself any harm, that's for sure
13:16:42 <Philippa_> younder: I think Lisp's a poor thing to throw in that comparison, FWIW
13:16:52 <dmwit> Are there any good tools to "screenshot" a terminal window?
13:16:59 <dmwit> Copy-and-paste loses colors.
13:17:05 <nand`> dmwit: scrot works
13:17:10 <younder> Philippa_, How so?
13:17:12 <nand`> (for X11-based terminals)
13:17:27 <dmwit> nand`: Some markup would be nicer, if it's possible.
13:17:35 <younder> Philippa_, They are all from the 50's and  all very different.
13:17:51 <nand`> dmwit: oh, I figured you wanted a literal screenshot
13:17:54 <zzo38> dmwit: I don't know. What format do you want it in?
13:18:08 <zzo38> ANSI escape codes format?
13:18:20 <dmwit> zzo38: ANSI escape codes would be fine. HTML would be even better.
13:19:16 <Philippa_> younder: their relationships with standardisation are too
13:19:55 <zzo38> What else I want to know, is there a way to capture ANSI escape codes (or even just plain video memory) for the Linux console even one might not be activated?
13:19:56 <Philippa_> and Common Lisp is... not the most influential lisp
13:20:38 <zzo38> kmc: Can you give example what you mean?
13:20:55 <Philippa_> (talking about 'COBOL' and 'FORTRAN' families is nowhere near as significant, for example)
13:21:15 <dmwit> preflex: seen kmc
13:21:15 <preflex>  kmc was last seen 5 days, 12 hours, 58 minutes and 25 seconds ago, saying: <private message>
13:21:54 <luca> hello, seemingly simple issue: getting error about ambiguous occurence where I have 'import module as P' and then both Main (current module) and P define same function
13:22:13 <dmwit> Ah, screen can do it (of course!).
13:22:30 <luca> i thought the whole idea of importing 'as' was to avoid this... but it's wanting me to use Main.function still >.>
13:22:33 <Taneb> luca, you want "import qualified module as P"
13:22:59 <luca> ahah okay
13:23:00 <luca> thanks
13:23:08 <dmwit> luca: "as" changes the qualified name that's defined; "qualified" says not to define the unqualified name
13:23:18 <yitz> dmwit: screen sounds like overkill just for that though
13:23:27 <dmwit> yitz: I'm open to other suggestions.
13:23:32 <Philippa_> shysoft: I'd be wary of looking for interestingly-young languages with a 30 year future right now, FWIW
13:23:35 <dmwit> It doesn't seem so much like overkill to me.
13:24:03 <Philippa_> (but then, C++ wasn't viable on any hardware I would've had access to in '85 either)
13:24:46 <dmwit> Oh, bugger, screen's hardcopy loses colors, too.
13:24:51 <dmwit> grrrr
13:25:50 <yitz> dmwit: your question is interesting. every x terminal has that information in its buffer. isn't there *any* that gives you access to its buffer in some usable form?
13:26:35 <dmwit> yitz: I know, right??
13:30:51 <yitz> dmwit: how about urxvt's print-pipe resource?
13:31:42 <dmwit> testing
13:32:05 <dmwit> Hah, I currently have URxvt.print-pipe: xclip in .Xdefaults. =P
13:32:22 <dmwit> This makes me suspicious that it will strip control codes.
13:33:06 <dmwit> Yep, strips control codes.
13:33:26 <ion> xsel > xclip, btw. xsel seems to handle Unicode without problems.
13:33:26 <EvilMachine> hello. the guys at #gentoo-haskell just told me that apparently, GHC doesn't do multithreading / multiple jobs in parallel? how come?
13:34:06 <dmwit> EvilMachine: Do you mean GHC isn't multithreaded, or GHC-compiled programs can't use threads?
13:34:16 <dmwit> If the former: because it's Freaking Hard (patches welcome).
13:34:21 <dmwit> If the latter: they're wrong.
13:34:22 <EvilMachine> dmwit: the former.
13:35:06 <EvilMachine> dmwit: interesting. i thought doing "ghc --make -threaded WhateverGHCsMainHsIs.hs" would do it. ;))
13:35:24 <dmwit> EvilMachine: That just links the program with the threaded runtime.
13:35:54 <parcs`> ghc +RTS -N
13:35:58 <parcs`> multithreaded ghc :)
13:36:09 <EvilMachine> dmwit: ah, good to know, because some people state it would make the whole thing multi-threaded.
13:36:29 <EvilMachine> parcs`: doesn't result in speed-ups, according to #gentoo-haskell
13:36:57 <dmwit> It was a joke. GHC is not threaded, so running with multiple threads doesn't help.
13:37:02 <EvilMachine> parcs`: but yeah, multi-threading still requires a bit more than the Automagic Threading Button(TM). ;)
13:37:26 <dmwit> If you have multiple threads but never call fork, ... =)
13:38:27 <EvilMachine> what i don't understand, is why GHC can't convert the whole non-io/non-sequential code into a nice dependency tree, notice the things that can be done in parallel, and make them into thread sparks to spread to the cpus?
13:39:04 <EvilMachine> (with dependency tree i mean functions that depend on (=use/call) other functions)
13:39:13 <hpc> EvilMachine: because it can't tell when it would be worth it to split up work
13:39:39 <hpc> evaluating "how long does it take to run this" is a harder problem than the halting problem
13:40:36 <hpc> in practice, you would end up with "spark a computation to add 5, 5", "spark a computation to add 2, 1", "spark a computation to multiply 10, 3", ...
13:40:39 <EvilMachine> hpc: let's see... if you have 4 cores, and your program is a tree of functions using functions, then take the first place where there are more than 4 branches, and put one branch on each cpu.
13:40:45 <hpc> and that's a lot of overhead
13:41:01 <parcs`> also i doubt there is a ton of non-sequential code in ghc; almost everything is done in some kind of state monad
13:41:21 <EvilMachine> hpc: but there would be 4 cpus doing it instead of one.
13:41:30 <EvilMachine> ohoh
13:41:38 <EvilMachine> parcs`: that's of course bad
13:42:02 <EvilMachine> parcs`: so it's one big pipe? hmm... that makes it understandable, why it is so hand to make multi-threaded.
13:42:18 <EvilMachine> parcs`: it would require a complete rewrite... the haskell way. :PP
13:42:46 <EvilMachine> hand=hard
13:44:11 <EvilMachine> btw, if you don't set +RTS -N, then all haskell code runs in a single thread? because then i would like to set this somewhere globally, to profit from having more than one core, if the program supports it.
13:44:41 <dmwit> export RTS_OPTS=-N
13:44:51 <parcs`> you have to realize that ghc is a gigantic, complex 20-year-old program
13:45:35 <yitz> EvilMachine: haskell programs tend to be composed of many small modules. so people are working on parallel compilation of separate modules. that sounds more doable.
13:45:41 <dmwit> whoops
13:46:00 <dmwit> Checked the manual, it's GHCRTS=-N
13:46:05 <EvilMachine> parcs`: i knew that it's gigantic and complex (and very cool, not to forget ;), but ... 20 years? ... wow. yeah, that explains a lot.
13:46:08 <hpc> i think you could get pretty far doing noop refactors over a few releases
13:46:13 <hpc> to ease the burden of rewriting
13:46:48 * EvilMachine is a friend of complete rewrites, when the skeletton doesn't support the meat anymore.
13:47:37 <yitz> EvilMachine: true, but we're talking wooly mammoth here
13:47:45 <dmwit> parcs`: Have you played with the GHC source much?
13:47:58 <EvilMachine> hpc: yes. refactors often help with architectural changes. up to a certain limit, of course.
13:48:30 <parcs`> dmwit: a little bit, mostly on the ghci side of it
13:48:38 <EvilMachine> yitz: so young? 20 years sounds more like Mr. Dinosaur Senior. ;)
13:48:44 <dmwit> cool =)
13:49:30 <EvilMachine> well, i guess it's also a manpower thing.
13:52:48 <EvilMachine> having staff on the payroll solely for Haskell platform advancement is one of my goals, should i ever have something like staff. ^^
14:04:42 <greymalkin> data CommandId = ByteString
14:04:48 <greymalkin> data Packet = CommandId ByteString
14:05:28 <greymalkin> But when I try to use it (Packet cmdid payload) it ghci says "Not in scope: data construct...... nevermind.. I just figured it out.
14:06:29 <greymalkin> nm the nm; still doesn't work. (Packet (CommandId cmdid) payload) is saying "Not in scope: data constructor `Packet'"
14:06:56 <kallisti> greymalkin: there is no constructor named Packet
14:07:00 <kallisti> there's a type named Packet
14:07:40 <kallisti> there's also a type named CommandId with a constructor named ByteString
14:07:46 <kallisti> are you sure you understand what data declarations do?
14:07:56 <greymalkin> kallisti: No, I'm pretty sure I don't.
14:08:11 <mgsloan> EvilMachine++
14:08:14 <greymalkin> I'm trying to apply some of what I've picked up in the last week + 1/2
14:08:40 <kallisti> it seems like you're using data as type
14:08:45 <kallisti> type defines type synonyms
14:08:58 <kallisti> I think
14:09:01 <kallisti> I don't know actually
14:09:07 <kallisti> how you're viewing data. :P
14:09:19 <kallisti> data Type = Constructor Field1 Field2 ...
14:09:46 <kallisti> here's a simple data declaration. It defines a type, with a constructor named Constructor that takes 2 fields.
14:10:11 <kallisti> Constructor someField1 someField2   produces a value of type Type   (I hope these names aren't confusing..)
14:10:49 <kallisti> Gracenotes: so the CommandId  in data CommandId = ByteString
14:10:52 <greymalkin> kallisti: No, it isn't; that was what I needed. I've got it now, thanks!
14:11:07 <kallisti> is a completely different entity than the one defined by data Packet = CommandId ...
14:11:51 <greymalkin> It just so happens that so many of the datatypes I've seen so far have a constructor by the same name of the datatype, so my brain probably left out redundancy without asking me
14:11:52 * hackagebot Elm 0.1.2.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.1.2.1 (EvanCzaplicki)
14:12:01 <kallisti> ah, yes.
14:12:20 <kallisti> it's a convenient thing to do for types with very straightforward constructors, but it's also confusing to people unfamiliar with how data declarations work.
14:13:01 <kallisti> constructors and types exist in 2 completely different namespaces. so data CommandId = ByteString  is actually creating a new value-level name called ByteString... it doesn't in any way refer to the ByteString type
14:13:10 <greymalkin> I have a few other gaps too... "Learn a Haskell" doesn't seem to ever describe how indentation is interpreted... it just says it's important (in passing)
14:13:51 <tazjin> greymalkin: http://en.wikibooks.org/wiki/Haskell/Indentation
14:13:52 <kallisti> you can read about the nitty-gritty details of layout rules in the Haskell report, but it's pretty straightforward.
14:14:43 * EvilMachine has become 2
14:14:55 <EvilMachine> mgsloan: ;)
14:14:58 <kallisti> greymalkin: you can use { } and ; in place of indentation and newlines.
14:15:10 <kallisti> if that's your thing  (or if you're using lambdabot on IRC)
14:15:44 <kallisti> > let x = 2; y = 3 in (x,y)
14:15:45 <lambdabot>   (2,3)
14:15:48 <kallisti> > let {x = 2; y = 3} in (x,y)
14:15:49 <lambdabot>   (2,3)
14:16:54 * hackagebot elm-yesod 0.1.3 - The Elm language Yesod compatibility module.  http://hackage.haskell.org/package/elm-yesod-0.1.3 (VincentAmbo)
14:17:24 <mgsloan> EvilMachine: :D paying people to hack on Haskell is something that I want to do too!  A model that might make some sense would be something like a smaller scale GSoc
14:19:02 <hughfdjackson> yay, elm
14:20:57 <kallisti> greymalkin: except for some gotchas involving do notation, the layout rules tend to "just work"
14:21:31 <greymalkin> kallisti: I'm not sure what you mean by layout rules, but intuition seems to be doing the trick too :)
14:21:43 <zzo38> Many monads can be seen as a free monad of something, and some monads can also be seen as a codensity monad of something. Such as, (Either x) being the free monad of (Const x), Maybe being the free monad of Finalize, [] being the codensity monad of Endo, Identity being the free monad of Initialize, and even Finalize being the codensity monad of Initialize.
14:21:49 <greymalkin> The only time I've had an "indentation error" was when I left something incomplete
14:22:05 <kallisti> the layout rules are what determine the block structure of your program based on indentation;  it inserts the semicolons and curly braces based on newlines and indentation.
14:22:29 <jfischoff> mgsloan: out of curiosity, what would you like to see someone make/improve?
14:22:34 <zzo38> You can turn off layout rules if they are causing too much trouble for you
14:22:38 <kallisti> and it's pretty flexible in what it allows.
14:24:07 <kallisti> greymalkin: the big gotcha is that you can't have the "then" and "else" pieces of an if expression flush with the if, within a do block
14:24:18 <kallisti> because it will interpret it was do {if blah; then blah; else blah}
14:24:24 <kallisti> instead of do {if blah then blah else blah}
14:25:14 <kallisti> so basically you have to indent the "then" and "else" more than the starting if.
14:25:22 <kallisti> in that case.
14:25:22 <mgsloan> jfischoff: I've got quite the laundry list.  Mostly, I'd want to get people working on projects that I'm trying to make happen.  Probably mostly I'm interested in encouraging richer Haskell IDEs, good meta-programming / quasi-quotation support (especially with IDE support), and better 2D / 3D graphics (diagrams library)
14:26:30 <kallisti> greymalkin: http://en.wikibooks.org/wiki/Haskell/Indentation#if_within_do  this probably explains it better (it also can show you the indentation, which I can't do over IRC)
14:26:37 <mgsloan> so, mostly Haskell toolchain stuff, but also more kickass libraries.
14:26:40 <jfischoff> mgsloan: me too :). Working on some related stuff as we speak. (iOS, and the first setup to a visual programming app)
14:26:47 <mgsloan> awesome!!
14:27:02 <jfischoff> mgsloan: are you interesting in iOS?
14:27:05 <jfischoff> with haskell?
14:27:16 <mgsloan> yeah, I want the IDE to support toggleable-substitution of visual language equivalents
14:27:25 <tazjin> jfischoff: I definitely am, do you have anything public on that yet?
14:27:26 <kallisti> mgsloan: I should have some free time available for such projects. I'm by no means an expert, but I do have experience developing small Haskell libraries.
14:27:32 <mgsloan> (with richer editing of these visual languages)
14:28:02 <mgsloan> jfischoff: pretty interested in that!  I love the multi-touch interaction paradigm, and would like to make a good UI abstraction for that
14:28:14 <jfischoff> mgsloan, tazjin: https://github.com/jfischoff/ghc-ios-simple-setup is what I am working on right now. I'm verifying a recent push. Feel free to check it out.
14:28:22 <greymalkin> kallisti: Yeah, the visual was descriptive.
14:29:40 <tazjin> jfischoff: Thanks, will do when I get back home
14:29:55 <mgsloan> jfischoff: cool! /me watches
14:30:00 <jfischoff> tazjin: feel free to ping me if you have questions
14:30:26 <mgsloan> it seems like a good number of people these days are thinking about more novel IDEs, Haskell and otherwise
14:30:36 <kallisti> http://hackage.haskell.org/package/filesystem-trees-0.1.0.2  this is the project I'm working on at the moment. It's basically indented to simplify any complex filesystem manipulation logic by using lazy IO and rose trees. The API is currently pending a complete rewrite though, so I wouldn't use the current docs to get a feel for what it will look like in a month or so.
14:30:37 <jfischoff> mgsloan: still a work in progress but hopefully by the end of day, it will build everything need to get the TestApp running
14:30:56 <kallisti> mgsloan: have you seen the Light Table project on KickStarter?
14:31:01 <jfischoff> mgsloan: its work now…I'll know in a hour
14:31:06 <kallisti> that's a good example of novel IDEs.
14:31:17 <jfischoff> mgsloan: have you seen Peaker bottle editor?
14:31:19 <mgsloan> Kallisti: Yup!  It embodies many of the things I've been thinking about
14:31:28 <mgsloan> jfischoff: I haven't!
14:32:31 <jfischoff> mgsloan: its the very humble beginnings of a structural editor, I'm watching it closely https://github.com/Peaker/bottle
14:33:03 <mgsloan> kallisti / jfischoff: My #1 desired feature for an editor is good type visualization.  I've written a bunch of code attempting to get to this point, but it's not at all up to the level of these mockups (which are a bit rough as well): http://www.mgsloan.com/mockup5.png
14:33:35 <mgsloan> http://www.mgsloan.com/mockup6.png
14:33:40 <ifnspifn> heya, I'm working on my first haskell IO project, and I'm kind of unsure about where to start. Right now I want to turn a dictionary.txt file into a [String], and an NxN matrix of letters into a [[char]]. What resources might help me here?
14:34:24 <jfischoff> mgsloan: very cool. I definitely think mockups are what we need. If there a legend for to interpret it?
14:34:43 <jfischoff> s /If/ is
14:34:54 <mgsloan> mockup5 has a miniature legend
14:34:54 <zzo38> ifnspifn: Both types are the same.....
14:35:08 <mgsloan> the type for composition has its parameters reversed, though..
14:35:21 <ifnspifn> right, I figured that out as I was typing it :P but that doesn't get me any closer to reading the files in
14:35:43 <kallisti> :t readFile
14:35:43 <lambdabot> FilePath -> IO String
14:35:44 <zzo38> ifnspifn: Perhaps   fmap lines . readFile
14:36:31 <kallisti> or the more beginner friendly:   f path = do { contents <- readFile path; return (lines path) }
14:37:17 <zzo38> kallisti: That works too but is extra-long and doesn't help to understand IO monads at all
14:37:28 <zzo38> (Except for the mistake you made)
14:37:52 <kallisti> yeah should be return (lines contents)
14:38:02 <zzo38> Yes
14:38:18 <mgsloan> jfischoff: That's a nice filetree library!  Would be cool to see a projection of that to an interactive diagram.  Bottle also looks very cool.  A far more developed version of my "panopti" project, at least along the axis of structure editing
14:38:45 <parcs`> are structural editors "the answer"?
14:39:03 <jfischoff> mgsloan: right now I working on repl for a language that has a built-in visual language. https://www.cs.indiana.edu/~rpjames/papers/rational.subc.pdf. https://github.com/jfischoff/pi-eta-epsilon
14:39:14 <mgsloan> so, yeah, seems like a lot of people want to do a structure + visual editor + rich info / ghc integration
14:39:33 <zzo38> How HTTP POST with Haskell? In addition, I also want something like readProcess for network connections but I could instead call the external netcat, which works too
14:39:34 <mgsloan> parcs`: I don't think so, but I think a semi-structural editor is
14:39:42 <jfischoff> mgsloan: I think structural editors plus visual is nice way to go. You don't have to drag and drop, but you get a pretty picture
14:40:15 <mgsloan> parcs`: In other words, you can manipulate stuff using more semantic operations, but these operations do modify the text
14:40:56 <mgsloan> and it just kinda ignores the bits that don't make sense / parse, while making it transparent that this will be ignored while performing hte refactoring
14:41:01 <kallisti> one cool thing about using trees is that recursive move/copy operations will actually return the tree in its new destination, which lets you keep track of a set of files.
14:41:07 <jfischoff> parcs`: Its an interesting space to explore, but what value structural will have is big question mark. I'm still optimistic :)
14:41:31 <mgsloan> jfischoff: Whoah, awesome!! That paper is still on my to-read pile
14:41:38 <zzo38> ifnspifn: Can you understood by now?
14:41:39 <mgsloan> from a skim it seems very cool
14:42:07 <jfischoff> mgsloan: you can thank dmwit and tgeeky for helping put that implementation together
14:42:22 <ifnspifn> zzo38; I'm trying to use "problem <- lines ( readFile "problem.txt" )", but I'm getting some compiler errors
14:42:25 <mgsloan> sweet, yeah, I heard about the paper from tgeeky
14:42:53 <zzo38> ifnspifn: In a do-block you could use:   problem <- lines <$> readFile "problem.txt"   (you need to import Control.Applicative to use <$>)
14:44:06 <kallisti> ifnspifn: readFile "blah" returns an IO String. To bind a name to the result value you have to use the monadic bind operator (>>=)
14:44:10 <zzo38> The reason   lines ( readFile "problem.txt" )   doesn't work, is that the result is the wrong type. You have   IO String   and   lines   meaks   String -> [String]   so with <$> or fmap you change it from     String -> [String]    to be able to work    IO String -> IO [String]
14:44:13 <kallisti> ifnspifn: which is conveniently sugared via do notation
14:44:35 <jfischoff> mgsloan: I could just hack together a temporary visualizer, but I'm trying to use pee as a chance to get some OpenGL work I made for the iOS ghc version working. Visual programming with the iPad … hmm … yummy :)
14:44:43 <kallisti> ifnspifn: so when you try to do lines (readFile "blah")  it's giving you an error because you're trying to apply a String -> [String] function to a IO String argument. You haven't bound the result of the IO computATION YET.
14:45:06 <zzo38> It also works to use    problem <- readFile "problem.txt";    and then later on use    (lines problem)    since the variable (problem) is of type String
14:45:08 <kallisti> hlep caps lock what is hap--
14:45:14 <mgsloan> jfischoff:  Cool!  I'm hoping that diagrams will sometime offer a good solution to doing stuff like that
14:45:22 * kallisti makes faint gurgling noises.
14:45:24 <ifnspifn> Alright, using my rudimentary knowledge of monads (it's bad), I need to 'unwrap' the IO String data then?
14:45:31 <kallisti> yes
14:45:36 <kallisti> using bind
14:45:46 <mgsloan> visual IPad programming would be awesome.  This is what I thought of first when I saw the multi-touch demos from 6 yrs or so ago
14:45:49 <mikeg> Ever since fclabels got rid of fmapL, I can't figure out a label (a :-> Maybe c) given two labels (a :-> Maybe b) and (b :-> c). Is there a replacement?
14:45:50 <kallisti> so using the >>= function, which is what do notation translates to
14:45:51 <kallisti> you need to do
14:45:52 <ion> Note that a value of type IO String doesn’t contain a String.
14:46:04 <kallisti> readFile "blah" >>= \contents -> return (lines contents)
14:46:21 <luite> hm i'm not yet convinced that you can get close to the productivity of a regular keyword
14:46:23 <ifnspifn> interesting. That looks like a callback
14:46:24 <luite> keyboard
14:46:32 <zzo38> fmap lines . readFile    is a shorter way to do the same thing
14:46:39 <ion> luite: With what?
14:46:47 <luite> ion: with a visual multitouch programming surface
14:47:09 <ion> luite: I’d bet you can’t until you get tactile feedback.
14:47:16 <mgsloan> luite: It might lead to a somewhat more leisurely programming experience.  In particular, type checking gives us enough info to give intelligent suggestions
14:47:21 <jfischoff> mgsloan: You know I am not as familiar with diagrams as I should be. The OpenGL stuff I have (have but not really functional yet) is just to help prototype on the iPad without rebuilding, so I don't really have my high level visual library worked out. Maybe you can help me navigate that space?
14:47:37 <kallisti> ifnspifn: yes. >>= is an overloaded operator; each monad defines it differently. This is sort of the power behind a monad as a means of modeling comutation; the monad itself can do any sort of plumbing under the hood while presenting a simple model of computation.
14:47:40 <luite> mgsloan: hm, why would you have typechecking there and not with a text editor?
14:47:46 <mgsloan> so, hardcore programming?  Probably not very good, but for throwing together a little demo, or playing the typechecking game?  I think multitouch could do well
14:47:49 <zzo38> :t fmap lines . readFile
14:47:50 <lambdabot> FilePath -> IO [String]
14:48:28 <ifnspifn> what kind of thing is IO [String] as compared to IO String?
14:48:40 <mgsloan> luite: Well, it's not so much typechecking, it's just turning the programming problem from "type the code" to "select the computer-generated alternative"
14:48:40 <adamt> [..] = list of something
14:48:45 <zzo38> ifnspifn:   IO [String]   is some I/O action where the result of type   [String]
14:48:53 <kallisti> the type parameter describes the type of the result of executing the IO computation.
14:48:54 <zzo38> Where [String] is a list of strings
14:48:57 <luite> mgsloan: right
14:48:59 <ifnspifn> ah, since that is what lines does
14:49:06 <ifnspifn> String -> [String]
14:49:13 <kallisti> ifnspifn: the import thing to note is the type of >>=
14:49:16 <kallisti> :t (>>=)
14:49:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:49:18 <mgsloan> luite: In other words, automatically hoogle stuff, substitute, and try a few, and visualize the results of concrete values being evaluated
14:49:24 <ifnspifn> oh lord.
14:49:27 <jfischoff> mgsloan: I think a got graph editor seems like a first step to visual programming. I'm going to look at https://github.com/alanz/Blobs as a starting point.
14:49:28 <kallisti> ifnspifn: the function that you pass to it is required to return a result that's wrapped within the monad.
14:49:37 <jfischoff> s /got/good
14:49:38 <zzo38> ifnspifn: Yes. So, using do, >>=, or fmap, will allow you to use functions meant for non-IO inside of a monad
14:49:50 <kallisti> ifnspifn: you can ignore the first half of the type, as lambdabot likes to be verbose for no reason. you can read it as:   Monad m => m a -> (a -> m b) -> m b
14:49:55 <luite> mgsloan: the last one can also be done with intellisense style select menu's in a text editor
14:49:55 <mgsloan> multitouch could be more effective for navigation + selection / application of speculative results
14:50:17 <luite> maybe you could replace them with multitouch spinners
14:50:26 <kallisti> ifnspifn: so since readFile "blah" is an IO String, the function passed on the right-hand side of >>= is given a value of type String, and it then must return a value of type IO String.
14:50:29 <mgsloan> sure, but I feel like you could offer some very effective multitouch exploration strategies
14:50:34 <kallisti> ifnspifn: er, rather IO b
14:50:36 <kallisti> where b is any type
14:50:43 <luite> mgsloan: hm maybe
14:51:08 <luca> how does one return unit from do block? aka have do block that i want to have output of () ?
14:51:21 <kallisti> return () ?
14:51:21 <mgsloan> luite: just speculation :) It is definitely a little bit more in the "spinning rims" section of the IDE features I want
14:51:38 <luca> ah, thanks :P
14:51:41 <zzo38> luca: Put   return ()    at the end
14:51:45 <ifnspifn> kallisti: so, that's why in your callback-y example, the lambda function uses "return"? because that returns a monadic type?
14:51:51 <kallisti> :t return
14:51:51 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:51:53 <kallisti> ifnspifn: yep
14:51:54 <mgsloan> jfischoff: seems reasonable!  I didn't know that existed!  Cool
14:52:02 <ifnspifn> handy!
14:52:09 <jfischoff> :)
14:52:13 <kallisti> ifnspifn: this isn't how you would normally write this code, but it's helpful to go to the fundamental level to see how monads work.
14:52:16 <zzo38> luca: Or, alternatively, put    () <$    at the outside
14:52:23 <alanz> msgloan,jfischoff:I am resurrecting Blobs to play with what you guys are talking about
14:52:27 <luite> mgsloan: i personally feel that typing would be most efficeint for getting the first version, and then some other interaction to do the experiments
14:52:40 <ifnspifn> considering the 'superficial' level of monads is thus far pure magic to me, this definitely helps
14:52:47 <kallisti> ifnspifn: a slightly shorter way to write it would be readFile "blah" >>= return . lines
14:53:05 <kallisti> in do notation it would be  do { contents <- readFile
14:53:06 <jfischoff> alanz: oh great! how far are you into that process? is it working?
14:53:11 <mgsloan> jfischoff: Just need to port that to diagrams.  I like diagrams quite a bit - apart from a few efficiency issues - it's a very good generic treatment of the problem
14:53:17 <kallisti> in do notation it would be  do { contents <- readFile "blah"; return (lines contents) }
14:53:20 <alanz> Just started today
14:53:22 <kallisti> ifnspifn: as I mentioned before.
14:53:39 <kallisti> the do notation translates to >>= and lambdas.
14:53:43 <ifnspifn> so the semicolon is just sugar for that lambda?
14:53:44 <mgsloan> luite: I agree!  A good keyboard interface is definitely the priority
14:53:45 <luca> is there a shorter way of writing:  do { res <- a; b; return res } ?
14:53:46 <alanz> But it looks like a very mature library, handling the complicated visual editor stuff
14:53:55 <zzo38> luca:   a <* b
14:54:03 <kallisti> ifnspifn: x <- m ; n   is sugar for m >>= \x -> n
14:54:10 <mgsloan> well, unfortunately I gtg
14:54:28 <kallisti> ifnspifn: do {m; n}  is sugar for m >> n
14:54:35 <jfischoff> alanz: I'm really interested. I'm still not ready to make the visual editor of the language I'm working on, but that time is fast approaching.
14:54:36 <mgsloan> but we should totally form a cabal of collaboration towards a rich-haskell-editor!
14:54:41 <luca> zzo38: not in scope <*
14:54:48 <jfischoff> mgsloan: damn straight
14:54:51 <zzo38> luca: You need to import Control.Applicative
14:54:59 <alanz> agree
14:55:08 <kallisti> ifnspifn: >> is just >>= but with the function argument ignored. m >> n = m >>= (const n)
14:55:09 <mgsloan> awesome :D
14:55:30 <luite> :)
14:55:32 <ifnspifn> that makes a bit of sense... but why wouldn't contents be of type IO String in the lambda?
14:55:43 <kallisti> ifnspifn: >> acts as a sort of semicolon. "execute the side-effects of this computation, ignore the result, then execute this computation"
14:55:48 <kallisti> ifnspifn: well, the short answer is because of the type of >>=
14:56:01 <kallisti> it wouldn't be very useful if >>= didn't allow you to refer to the inner type of the monad.
14:56:06 <ifnspifn> true
14:56:21 <alanz> I found a paper from 1994 that was proposing stuff like this already.
14:56:22 <ifnspifn> AH, because it's >>= is the unwrapping bit, bind?
14:56:29 <jfischoff> alanz, mgsloan, whoever else join: #haskell-visual-programming
14:56:30 <kallisti> ifnspifn: oh yes. >>= is called bind
14:56:31 <alanz> Basically using the labview approach
14:56:33 <kallisti> forgot to mention that.
14:57:06 <zzo38> As far as I know, is better understand monad in terms of a Functor, so you have fmap, return, join, and then show >>= as a way to use fmap and join together
14:57:16 <kallisti> ifnspifn: using the do notation as a visual aid, you can kind of see that it somewhat resembles variable assignment in an imperative language.
14:57:21 <alanz> http://ptolemy.eecs.berkeley.edu/~johnr/papers/visual.html
14:58:10 <Cale> except that it's not variable assignment, it's naming the results of the actions
14:58:14 <kallisti> ifnspifn: the difference is that the monad can define arbitrary behavior for >>= , as long as it satisfies a few laws.
14:58:22 <Cale> (and that)
14:58:29 <kallisti> Cale: keyword is "resembles"
14:58:35 <Cale> right :)
15:01:26 <cizra> Can you define Agda-style operators in Haskell, like _[_] :: Array T -> Integer -> T?
15:01:41 <kallisti> cizra: no mixfix, unfortunately.
15:01:49 <zzo38> cizra: No, Haskell lacks those things
15:01:54 <cizra> Mmkay.
15:01:57 <hpc> the price of mixfix is losing sections
15:02:01 <kallisti> we only have infix operators (and with a GHC extension, something similar to postfix operators)
15:02:03 <cizra> What's a section?
15:02:09 <shysoft> Anyone been to ICFP?
15:02:11 <hpc> > map (* 5) [1..10]
15:02:12 <lambdabot>   [5,10,15,20,25,30,35,40,45,50]
15:02:16 <hpc> (* 5) is a section
15:02:17 <cizra> Ah.
15:02:30 <cizra> I thought it was a curried multiplication.
15:02:35 <kallisti> it's also that.
15:02:37 <hpc> it is
15:02:48 <kallisti> the section refers to the syntax of writing it as (*5)
15:02:50 <cizra> Mmkay. So a section is how you use it?
15:02:51 <cizra> OK
15:02:52 <hpc> but (* 5) sucks less than (flip (*) 5)
15:02:53 <kallisti> instead of flip (*) 5 or something
15:02:55 <copumpkin> curried doesn't really mean partially applied
15:03:07 <hpc> and (5 *) sucks less than (*) 5
15:03:25 <cizra> Agreed about the previous points. copumpkin, could you please elaborate the difference?
15:03:42 <copumpkin> (a, b) -> c curried is a -> b -> c
15:03:48 <copumpkin> the latter form _can_ be partially applied
15:03:55 * kallisti would argue that the benefits of mixfix for defining DSLs could possibly outweigh the benefits of operator sections.
15:04:09 <copumpkin> well, mixfix doesn't inherently prevent sections
15:04:11 <cizra> OK
15:04:13 <copumpkin> it's just that agda hasn't implemented them yet
15:04:21 <kallisti> curried describes the functions, partial application describes what you do to them. basically.
15:04:23 <copumpkin> and it gets pretty tricky
15:04:36 <kallisti> (pedantry to the max)
15:05:34 <kallisti> copumpkin: what happens to the grammar as a result of attempting to parse both operator sections and prefix/postfix operators?
15:05:47 <zzo38> kallisti: Well, I would prefer better macros to those kind of things
15:06:06 <copumpkin> kallisti: gets insane, I assume :)
15:06:07 <copumpkin> anyway, gotta go
15:06:09 <copumpkin> bbl
15:06:41 <kallisti> seems like it /would/ be possible though
15:06:53 <kallisti> it just greatly confuses the AST.
15:06:54 <zzo38> Also, multiplication is commutative so (* 5) and (5 *) are same ways anyways due to commutativity
15:07:23 <kallisti> so now you have an AST node that means something like "this could possibly be a section or a postfix operator"  and "this could be possibly be a section or a prefix operator"
15:07:34 <kallisti> and then you resolve it by looking at definitions.
15:07:35 <cizra> kallisti: It will confuse the poor 2. year student more than the AST. If the grammar will grow a beard, more so will the student's brain.
15:07:52 <kallisti> ha. yeah that sounds more accurate.
15:08:02 <kallisti> the AST won't be confused at all. it'll be... an AST.
15:08:39 <dmwit> parcs`: Aha!
15:08:55 <kallisti> cizra: wait did you just imply that brains can grow beards?
15:08:59 <kallisti> I'm so confused by this metaphor.
15:09:29 <adamt> kallisti: Maybe the hair starts growing inwards at one point.
15:09:31 * kallisti obviously needs more beard on his brain.
15:09:40 <cizra> kallisti: yep. Well, no, but I'm sure the students will have some hair coming out of the nostrils, trying to use Haskell. It has a bad reputation outside comp sci world as it stands.
15:10:02 <dmwit> parcs`: threadsEnter only blocks when you've asked for the thread-safe version of Gtk; and unsafeInitGUIForThreadedRTS only asks for the thread-safe version of Gtk when running under the threaded RTS; and so threadsEnter doesn't take a lock in the non-threaded RTS; and so my program terminates in the non-threaded RTS.
15:13:27 <zzo38> Sure there are some problems with Haskell although not everyone agrees about what all of them are or how to correct them
15:15:23 <kallisti> cizra: that's one reason I'm against the idea of revising the Prelude to be more general. Haskell already has a high learning curve as it is.
15:15:48 <kallisti> you already can't use numbers at all when explaining the basics of the type system to someone.
15:15:55 <kallisti> it would be worse if everything were overloaded everywhere.
15:15:58 <edwardk> My main problems with Haskell stem from infelicities in the standard with regards to certain types. The fact that MonadPlus has two sets of semantics, that Functor/Applicative aren't superclasses of Monad. The main technical hurdle that leads to these is that there is no way to make up a superclass retroactively,and this makes  it a pain to fully factor a class hierarchy as it makes it more work for end users to use.
15:16:23 <zzo38> edwardk: Yes those things I agree too.
15:16:35 <parcs`> it's a partially applied infix operator
15:16:44 <parcs`> oops, scrollback
15:17:20 <edwardk> kallisti: personally i don't mind the number situation. most of my problems come from the fact where haskell 98 went out of its way to monomorphize things that have perfectly good generic definitions, like ++ and map
15:17:32 <edwardk> so i'm definitely in the other camp ;)
15:18:20 <zzo38> edwardk: It is one thing I intended correcting with Ibtlfmm that you can make up a superclass retroactively. It is also I did in Haskell making Prelude.Generalize to polymorphize everything instead of monomorphize
15:23:02 <zzo38> edwardk: So I agree with you in those things
15:41:39 <luca> any nice way of writing: do { x <- p; return (f x) }
15:41:50 <zzo38> luca:  f <$> p
15:44:47 <luca> what module is that defined in?
15:45:06 <Clint> Control.Applicative
15:45:08 <zzo38> luca: Again, Control.Applicative. However you can also use fmap which is the same as <$> and is defined in Prelude
15:45:21 <luca> wait sorry. Forgot i'd imported it qualified
15:45:37 <hpc> @quote if.the.first
15:45:38 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
15:45:41 <hpc> :(
15:45:48 <zzo38> edwardk: I have thought about that many monads can be seen as the free monad of something, and/or of the codensity monad of something, such as:   Either x = Free (Const x)   Maybe = Free Finalize   Identity = Free Initialize   [] = Codensity Endo   Finalize = Codensity Initialize
15:45:59 <zzo38> luca: Why did you import it qualified?
15:46:43 <luca> because it conflicts with Parsec module
15:47:05 <Clint> import Control.Applicative ((<$>),(<*>))
15:47:23 <zzo38> luca: Yes it does but you should instead hide the things it conflicts from the Parsec import, since the corresponding things in Control.Applicative will work too
15:47:31 <luca> okay
15:50:29 <applicative> > let  f = show; p = [1,2,3] in (f <$> p, fmap f p, liftM f p, do {x <- p; return (f x)}, [f x| x <- p])
15:50:31 <lambdabot>   (["1","2","3"],["1","2","3"],["1","2","3"],["1","2","3"],["1","2","3"])
15:51:42 <applicative> > let  f = show; p = [1,2,3] in do {(f -> x) <- p; return x} -- wait can't do without ViewPatterns
15:51:43 <lambdabot>   ["1","2","3"]
15:53:58 <kallisti> Parsec conflicts with Applicative?
15:54:03 <kallisti> surely it just re-exports the Applicative operators.
15:54:15 <luca> on a few things like <|> optional many etc
15:54:47 <kallisti> hm. Attoparsec uses the Alternative isntance for those
15:55:03 <aristid> luca: some of them are compatible, maybe with different fixity
15:55:12 <aristid> i think optional actually has a different type tho
15:55:24 <kallisti> @hoogle optional
15:55:25 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
15:55:25 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
15:55:25 <lambdabot> Text.Parsec.Combinator optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
15:55:36 <aristid> yup:)
15:55:53 <kallisti> weirdness.
15:55:57 <luca> yeh, Parsec's is optionMaybe
15:56:14 <aristid> i'd suggest importing Parsec qualified :)
15:56:30 <zzo38> Yes it does, and the Parsec's optional type is not so useful
15:56:31 * kallisti isn't sure why you would want optional to discard the result by default.
15:56:45 <luca> well in most cases i'm using Parsec stuff, just the odd place where i want <$> and <*
15:57:17 <aristid> luca: well you _can_ import Control.Applicative ((<$>), (<*))
15:57:32 <luca> yes, that's what I've done at present
15:58:14 <kallisti> :)
16:01:33 <lpsmith> If somebody has a (newtype Foo = Foo Integer),  is it safe to unsafeCoerce a Foo to Integer if the data constructor is not exported from the module?
16:02:06 <lpsmith> Specifically,  I want to coerce a Data.Fixed.Fixed  to Integer.
16:04:01 <lpsmith> ok
16:04:05 <lpsmith> the answer is yes
16:04:35 <hughfdjackson> can you find all types in scope that are instances of a typeclass?
16:04:45 <hughfdjackson> like.. everything that implements Eq
16:04:50 <applicative> in ghci if  you load the module
16:05:01 <applicative> then do :i Blahclass
16:05:08 <hughfdjackson> :D thankyou very much
16:06:50 <zzo38> lpsmith: The answer is, yes it is safe to use unsafeCoerce in that way, but you shouldn't do so in case the internal representation changes in a later version, or if optimizations mess it up
16:07:25 <lpsmith> optimizations won't mess it up.
16:07:59 <zzo38> The reason they won't is because such optimization are not implemented.
16:12:05 * hackagebot singletons 0.8 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-0.8 (RichardEisenberg)
16:13:15 <parcs`> > 2^64
16:13:16 <lambdabot>   18446744073709551616
16:15:09 <luca> 2^65
16:15:14 <luca> > 2^65
16:15:15 <lambdabot>   36893488147419103232
16:15:17 <luca> i see
16:17:29 <adamt> > 2^128
16:17:30 <lambdabot>   340282366920938463463374607431768211456
16:17:39 <luca> <3 buildExpressionParser
16:17:43 <adamt> > 2^1024
16:17:44 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
16:17:52 <adamt> Poor bot
16:17:57 <luca> > 10^10^10
16:18:02 <lambdabot>   mueval: ExitFailure 1
16:18:02 <lambdabot>  mueval: Prelude.undefined
16:18:05 <luca> haha
16:35:28 <tuxit> what are people using here for editing haskell code ?
16:35:33 <luca> vim
16:37:29 <d-snp> vim
16:37:52 <nand`> vim
16:38:10 <fmap> and vim sometimes
16:38:50 <sipa> what's wrong with cat? :(
16:38:56 <d-snp> we all have terrible taste in editors..
16:39:53 <luca> to be frank, the 'main' reason I use vim is because i like working in termal, enjoy not having wasted space from an IDE, and like being able to have transparency and don't want to use emacs
16:40:05 <luca> + not needing to use mouse
16:40:10 <luca> but that applies to other editors too
16:41:03 <mcstar> emacs ofc
16:41:04 <synonymous> that looks like 5 main reasons:)
16:41:14 <luca> reasons* ;)
16:41:34 <parcs`> my favorite ide is zsh/coreutils/vim because i like being able to access my work environment remotely
16:42:20 <mcstar> i cant stand vim people
16:42:48 <luca> why?
16:42:53 <parcs`> i agree some vim people are obnoxious
16:43:11 <mapreduce> Since you became a VI person it's like your problems have all worsened.. Just Stack - Starz In Their Eyes
16:43:13 <luca> you get obnoxious people in any group; I can guarantee there are plenty of obnoxious IE6 users :P
16:43:23 <mapreduce> Just Jack, even.
16:47:54 <nand`> I've met plenty of rude, abusive and downright obnoxious emacs users in my time as well
16:48:03 <nand`> doesn't mean I'll judge the editor for it
16:50:33 <Clint> i use emacs but i wouldn't dream of editing files with it
16:51:54 <hughfdjackson> mapreduce: that made me crack a smile
16:56:19 <ifnspifn> If I were to make a custom data type for a tree whose elements are letters, and whose nodes have a variable number of children, would the following suffice: data ProblemTree a = (char, [ProblemTree])
16:56:38 <nand`> ifnspifn: not if you want it to ever terminate
16:57:04 <nand`> wait
16:57:09 * nand` is being silly
16:57:30 <monochrom> yeah, ('x', []) is a fine leaf
16:57:35 <nand`> I guess you can't have an empty tree that way
16:57:38 <nand`> not that it matters much
16:58:10 <ifnspifn> so it should be kosher?
16:58:17 <luca> if you don't need empty trees
16:58:23 <nand`> shouldn't there be a type for this already?
16:58:26 <ifnspifn> I don't :]
16:58:34 <ifnspifn> and probably... Tries looked promising
16:58:46 <nand`> ifnspifn: Data.Tree.Tree Char
16:59:19 <nand`> basically the same except with a fancy record constructor instead of a tuple
16:59:35 <nand`> also polymorphic and with plenty of existing functions
16:59:48 <ifnspifn> sounds a helluva lot better, I'll look it up
16:59:49 <ifnspifn> thanks
17:24:10 <mapreduce> What's the kind of -> ?
17:24:43 <luca> what do you mean kind?
17:25:10 <mapreduce> Well, [] is a * -> *
17:25:33 <mapreduce> What's the kind of 'function' in Haskell?
17:25:33 <nand`> * -> * -> *
17:25:44 <nand`> you can actually check in ghci
17:25:47 <nand`> :k (->)
17:26:11 <luca> there is no single 'function' type, any given function has a specific type based on it's argument types and return type
17:26:17 <lambdabot> ?? -> ? -> *
17:26:23 <mapreduce> I tried with lambdabot earlier (with :kind instead of :k though)
17:26:36 <mapreduce> What's the ?? and ? for?
17:26:43 <nand`> no idea, actually; I think those are some ugly internals
17:26:50 <mapreduce> ok
17:26:55 <nand`> in GHCi I get (->) :: * -> * -> *
17:27:06 <redscare> I expect to get yelled at, but does anyone know of a good discussion comparing haskell and lisp?
17:27:07 <nand`> I'd go with that personally; it's what makes sense
17:27:20 <mapreduce> I saw someone say that (for Scala) it's * x * -> *
17:27:39 <byorgey> yeah, ?? and ? are internal kinds used by GHC to track things like strictness or unboxing or something like that.  Basically you should think of them as *
17:28:00 <mapreduce> Are the two notations isomorphic?
17:28:05 <nand`> mapreduce: that sounds like something that's uncurried; but I have no idea
17:28:13 <byorgey> yes, exactly
17:28:21 <byorgey> they are isomorphic because of currying.
17:28:26 <mapreduce> Thank you.
17:28:26 <nand`> in Haskell (->) is curried; (->) e :: * -> * is a valid type as well
17:29:01 <byorgey> but I wonder if you can actually partially apply (->) in Scala
17:29:10 <byorgey> (I don't really know any Scala)
17:29:11 <nand`> try it?
17:29:14 <nand`> neither do I
17:29:18 <nand`> does scala have functors and the like?
17:29:32 <byorgey> you can define them, yes
17:30:03 <mapreduce> byorgey: I don't think you can partially apply it, no.
17:30:22 <nand`> so you can't define a functor instance for (->) e in scala? :(
17:30:24 <byorgey> ok. so they are isomorphic in theory but not in practice.
17:30:26 <mapreduce> I know you can use it unapplied (as the word Function1 instead of as => though)
17:30:43 <byorgey> nand`: you can, somehow.  see http://marakana.com/s/scala_typeclassopedia_with_john_kodumal_of_atlassian_video,1198/index.html
17:30:57 <mapreduce> I think there's a hack where you write another type to represent a partially-applied Function1.
17:31:06 <byorgey> yeah, could be.
17:31:21 <dmwit> I'm pretty sure Scala doesn't have any kinds other than *.
17:31:53 <mapreduce> dmwit: class X[Y[_]] - Y is a type parameter that is of kind * -> *
17:32:12 <dmwit> And that's not the last time I'll be wrong, either!
17:32:13 <mapreduce> so within X's body you can do Y[Int], Y[Double] etc.
17:42:32 <zzo38> Can you tell me why something like this fails?   withSocketsDo (connectTo "zzo38computer.cjb.net" (PortNumber 70) >>= \h -> hPutStr h "quiz.menu*b\r\n" >> hGetContents h)
17:43:04 <parcs`> how does it fail?
17:43:04 <nand`> hFlush h maybe
17:43:19 <zzo38> parcs`: It just hangs
17:43:41 <nand`> well, which part does it hang on?
17:44:00 <zzo38> nand`: hFlush worked, thanks
17:44:35 <nand`> fyi you can avoid it with hSetBuffering h NoBuffering -- or whatever
17:45:06 <parcs`> zzo38: don't use the high level network api
17:45:12 <parcs`> use the Network.Socket api
17:45:25 <zzo38> parcs`: I cannot understand it very well though
17:45:49 <nand`> parcs`: why?
17:47:10 <parcs`> nand`: it is less magic and more predictable
17:47:59 <zzo38> (Note: the hGetContents in my example is the strict version)
17:48:56 <parcs`> i think it's more efficient too
17:53:10 <hughfdjackson> why does haskell use && and ||, but not ! for unary not?
17:53:28 <zomg> Who knows
17:53:32 <hughfdjackson> (perhaps just because the authors wanted it that way, but i wonder if there's a language or disapline that they inherited it from)
17:53:35 <zzo38> hughfdjackson: Because of how unary operators with in Haskell in general
17:53:39 <hughfdjackson> hehe
17:53:43 <hughfdjackson> just the 1?
17:53:55 <hughfdjackson> -, iirc
17:53:57 <geekosaur> unary ! would have the same problems unary - does
17:54:02 <hughfdjackson> :D okay
17:54:17 <hughfdjackson> that does make sense
17:54:27 <nand`> Isn't ! used for strict parameters already
17:54:39 <hughfdjackson> nand`: it may be, i haven't got that far
17:54:44 <geekosaur> yes, but that's in types or (with BangPatterns) patterns, not general expressions.
17:55:09 <parcs`> haskell doesn't support unary operators
17:55:13 <nand`> geekosaur: oh; okay. I thought you could have them in function parameter names as well; but I've never read up on them (or used them) before
17:55:42 <geekosaur> they do work there, as a special case of patterns (again, with BangPatterns)
17:55:53 <geekosaur> sunce function parameters are patterns
17:56:31 <nand`> yeah; I figured that would conflict with unary operator definitions (eg. !x = not x)
17:56:43 <nand`> hypothetical unary operator definitions*
17:57:26 <nand`> then again, this whole thing can be averted by simply defining (!) = not
17:57:56 <nand`> now if you could only get rid of the brackets somehow you could use ! x to negate :P
17:58:46 <nand`> like, iuno; an extension that lets you define operators that have no LHS
18:00:53 <zzo38> I do not like defining all of these extensions for these syntax (including some of the built-in stuff such as do-notation); instead, it should be macros which can be used to define those kind of syntax
18:01:20 <nand`> Haskell 2.0: Common Lisp edition
18:01:38 <luca> macros are fun <3 we added monadic programming, operator overloading, nested pattern matching to haxe with it's macros
18:02:20 <mgsloan> zzo38: I totally agree with you
18:02:49 <nand`> it would be fun to have stuff like “do” notation defined via macros instead of built in to the language
18:02:52 <mgsloan> Ideally, even the haskell-98 extensions could be moved into libraries
18:03:19 <mgsloan> here's my swing at doing this: https://github.com/mgsloan/quasi-extras/blob/master/src/Language/Quasi/Internal/Desugar.hs
18:03:24 <zzo38> Yes I agree those things
18:03:58 <zzo38> Although, my idea to do so, would be, inventing an entirely new programming language, which also has some other differences from Haskell too
18:04:25 <mgsloan> (the top comment in that file is particularly relevant)
18:04:57 <mgsloan> zzo38: while this would be cool, I think Haskell can be evolved, a little bit messily, in that direction
18:05:22 <zzo38> mgsloan: That appears to be an HTML document, not a Haskell program
18:06:14 <mgsloan> zzo38: that's strange
18:06:35 <mgsloan> it does inline a bunch of quotes from the report
18:06:49 <mgsloan> (mostly to show off how close the code is to the report, bwaha)
18:07:38 <geekosaur> use the "raw" link at top right border of the textarea if you don't want github being fancy
18:07:52 <mgsloan> zzo38: https://raw.github.com/mgsloan/quasi-extras/master/src/Language/Quasi/Internal/Desugar.hs
18:09:25 <zzo38> OK, I can understand now.
18:14:22 <hpaste> “Joey Adams” pasted “What if you could define data constructors in a class and derive the corresponding type?” at http://hpaste.org/69448
18:14:39 <JoeyA> Out of pure curiosity, has anyone proposed such an extension?  ^
18:16:07 <zzo38> JoeyA: Perhaps it could be done using Template Haskell?
18:16:34 <mgsloan> so, I think that TH already gives most of the power necessary to start playing with extending Haskell.  Providing a nice platform for orthogonal and syntactic extension on the other hand...
18:17:13 <zzo38> mgsloan: It does many things but I find it very insufficient. See also:   gopher://zzo38computer.cjb.net/0phlog*c_prog.ibtlfmm-part-i
18:18:09 <dmwit> gopher?
18:18:15 <kallisti> edwardk: there's a documentation bug in Data.Functor.Bind
18:18:36 <mgsloan> it is insufficient, but not innately - libraries that build higher level stuff atop are needed
18:18:42 <geekosaur> polymorphic type constructors would, I suspect, complicate type resolution considerably
18:18:43 <kallisti> a <. b = const <$> a <.> b  is interpreting the <...> as a hyperlink.
18:19:44 <zzo38> Perhaps read my ideas I wrote there; if you have netcat you can also download them by:  echo 'phlog*c_prog.ibtlfmm-part-i' | nc zzo38computer.cjb.net 70
18:20:46 <kallisti> edwardk: it might look nice to use the > blockquote thing there instead of explicitly escaping the angle brackets
18:26:32 <zzo38> I don't know yet about the syntax for my macros, but perhaps with a few similarities to Lisp?
18:27:51 <JoeyA> geekosaur: You mean polymorphic data constructors?  In my example, SimpleExpr would be a concrete type, but Cond's type has a class-constrained type variable.
18:28:02 <kallisti> edwardk: sent a pull request with the fix.
18:28:09 <zzo38> But I also had a way to make type classes be something different too; the Monad class might look something like this (not too sure of the syntax yet):  type Monad (m :: * -> *) :: & = (Functor m, MonadLaws m, method return :: x. x -> m x, method join :: x. m (m x) -> m x);   Probably not quite because it would be based on MonadC and MonadCR
18:29:31 <geekosaur> JoeyA:  Sequence currently is monomorphic; with this extension, SimpleExpr is monomorphic but Sequence is not when multiple instances are in scope... and the open nature of typeclasses may complicate *that* quite a lot
18:30:37 <mgsloan> zzo38: I like these ideas!  You'd need good ways of defining the conversions between the two different versions of (Ord Integer)
18:30:44 <JoeyA> geekosaur: As in, ambiguous types aplenty?
18:31:28 <mgsloan> zzo38: this is a post I was working on that presents some pretty grand ideas.  It hasn't been very cleaned up, and so for a while wasn't posted / publicized
18:32:06 <mgsloan> I hope to get the ideas refined / exemplified in a project sometime soonish... http://www.mgsloan.com/wordpress/?p=219
18:32:23 <geekosaur> yes.  and what Sequence means depends on the instances in scope and is open to orphan instances possibly wreaking havoc on a formerly working program
18:32:55 <mgsloan> my post is relevant because I think it presents a decent way of dealing with orphans
18:33:17 <zzo38> mgsloan: I have thought about that a bit. There could be some operator taking something of kind @ (which is a program module) so that you can access instances from that module.
18:33:59 <mgsloan> The main takeaway is that it's valuable to focus on how code can change, and whether we can express the change to APIs by declaring a module
18:34:13 <mgsloan> zzo38: very cool!
18:36:11 * kallisti has considered the idea of adding several new features to the import/export syntax, including the ability to hide instances.
18:36:30 <kallisti> you could even go so far as to allow instances to be named, or even to require orphan instances to be named so that they can be easily hidden.
18:36:48 <zzo38> kallisti: I have considered the similar things.
18:36:52 <mgsloan> what I want is local imports
18:37:20 <mgsloan> import qualified Control.Category as Cat
18:37:20 <mgsloan> fooLens = bar . baz . quux where import Cat
18:39:08 <zzo38> mgsloan: Yes
18:39:34 <mgsloan> and when you go that far, might as well let any top-level live in a where
18:39:45 <mgsloan> but imports are most important
18:40:02 <kallisti> ...local instances. :P
18:40:19 <mgsloan> aaand that's where things get messy :)
18:40:44 <mgsloan> the local orphan population..
18:41:07 <kallisti> local fixity rebinding. ;D
18:41:16 <kallisti> I guess you can cheat and do that anyway
18:41:31 <kallisti> but you'd have to rename the operator.
18:42:06 <aristid> or import it qualified, and use the same name
18:42:15 * kallisti doesn't think local instances are a bad idea.
18:42:52 <kallisti> module My.Long.Module.Name (...) as M where
18:43:11 <zzo38> Yes, also things like local instances and local fixity rebinding, as well as local import and all of that stuff too. My ideas for Ibtlfmm involved these things too, as well as some of these things in idea of Haskell extensions.
18:43:11 <JoeyA> kallisti: Well, local instances can violate expectations of e.g. Data.Map
18:43:22 <kallisti> some modules would benefit quite a bit from being able to give themselves a shorthand name  (can you already do that?)
18:43:26 <JoeyA> Say you give a local Ord instance for Double that differs from the one used elsewhere.
18:43:35 <zzo38> JoeyA: My ideas for Ibtlfmm and stuff would correct that problem
18:43:43 <JoeyA> To keep from violating this expectation, allow local data types.
18:43:55 <kallisti> JoeyA: then it would be an overlapping instance
18:44:03 <kallisti> just because it's local doesn't mean it would shadow existing instances.
18:44:08 <JoeyA> > map pred "Ibtlfmm"
18:44:11 <lambdabot>   "Haskell"
18:45:01 <JoeyA> kallisti: Still, couldn't you give conflicting instances in two different functions and have them share data?
18:45:23 <kallisti> sure
18:45:33 <dmwit> kallisti: Modules can import themselves, using the usual "qualified" and "as" keywords.
18:45:38 <zzo38> For example if you have (Map Integer String) and you have in one place a function taking (Map Integer String) and then in another place you have a different instance for (Ord Integer), and make up a (Map Integer String) there and pass it to the function in the other place, you get a type mismatch error.
18:46:12 <JoeyA> How would it know the instances conflict statically?
18:46:25 <kallisti> it can't
18:46:49 <JoeyA> The static type Map Integer String doesn't carry with it information on what instances it has hung out with.
18:47:08 <JoeyA> (values of that type have hung out with, that is)
18:47:15 <dmwit> Yes, it can. But it sounds dangerously like dependent types.
18:47:22 <zzo38> JoeyA: The type would carry the instance tag with it. See the file with my ideas I posted and how that would work
18:47:44 <dmwit> You'd need to put the ord instance in the type, e.g. Map (x < y = {- some code here -}) Integer String
18:48:12 <dmwit> Then you can write union :: Map ord k v -> Map ord k v -> Map ord k v
18:48:17 <kallisti> of course the other option is to not care and let it break. >_> but that's not how you make something tractable in the Haskell community. :P
18:48:19 <JoeyA> interesting
18:48:31 <dmwit> But you need some pretty hard work to check that two values have equal types, then.
18:48:32 <zzo38> dmwit: Yes it would be effectively like that but it is an implicit parameter rather than explicit.
18:48:55 <zzo38> (Although you can have it explicit too if you wanted; I had the definition of {} kind for this purpose)
18:50:18 <zzo38> And I know that you cannot then check if the values have equal types; but I have thought of that and placed restrictions on the use of {} kind
18:50:45 <zzo38> So, they might not be considered the same type, even if they are the same value.
18:51:12 <luca> is there a nice way of taking a list; say [A 1,B 2,C 3,A 4,B 5] and extracting [1,4] [2,5] and [3] from it?
18:51:31 <dmwit> luca: If you have isA, isB, and isC functions, you can use partition.
18:52:07 <dmwit> luca: Depending on how you feel about Typeable, you can have isA/isB/isC written for you by the compiler.
18:52:29 <kallisti> alternatively you could reincode your types. sometimes it's better to have a single product type that contains a sum type. the outer product type contains all the information shared by each of the sum types.
18:52:40 <kallisti> gives you more flexibility when pattern matching
18:52:41 <dmwit> You can also use sortBy/groupBy if you have functions that project out just the tag (and again Typeable can write these projection functions for you).
18:53:08 <rwbarton> "[ x | A x <- xs ]" is pretty easy
18:53:52 <mzero> so is      map A
18:53:59 <mzero> do'h
18:54:01 <mzero> nevermind
18:54:03 <rwbarton> unmap A :)
18:54:11 <mzero> shoulnd't drink beer and IRC while doing three other things
18:55:47 <mzero> acutally      map   unA        which is surprisingly pretty common
18:56:19 <luca> un?
18:56:28 <luca> [x|A x<-xs] works nicely :P
18:56:35 <kallisti> mzero: that won't work with sum types.
18:56:44 <mzero> true dat
18:57:05 <kallisti> data T = A {unA :: Int} | B Int | C Char
18:57:45 <kallisti> luckily list comprehensions are semi-magical
18:58:04 <dylukes> This literally compiles to swiching on an integer.
18:58:08 <dylukes> It's just a case statement.
18:58:49 <luca> is there a way of turning [x | A x <- xs] into a function for generic A ?
18:59:04 <dylukes> I think you'd need scoped type variables.
18:59:33 <dmwit> luca: With Typeable, yep. =)
18:59:38 <dmwit> Everything is about Typeable.
18:59:46 <luca> never head of it
19:00:13 <dmwit> http://stackoverflow.com/questions/10112733/haskell-simple-constructor-comparison-function
19:01:13 <kallisti> Data.Data.Data
19:03:57 <luca> of course a nicer solution for my case here would be to learn how to use state monad inside of a different monad :P
19:04:35 <luca> (at present i accumulate set of results appearing any order, then distribute to seperate lists at end)
19:04:59 <luca> or maybe easier to just not need to distribute at all
19:13:30 <dmwit> mgsloan: I have another proposed solution.
19:13:42 <dmwit> mgsloan: Allow many copies of each library to be installed, even at the same version.
19:14:00 <dmwit> mgsloan: Store which versions of each dependency the library was built against in the metadata about the library.
19:14:10 <dmwit> done?
19:14:15 <mgsloan> but not compiled together?
19:14:33 <dmwit> together?
19:15:06 <dmwit> Sorry, you probably have to store which versions of *all* dependencies (not only direct dependencies) in the metadata.
19:15:06 <mgsloan> nvm, pidgin seems to be broken - I should use a proper IRC client (didn't scroll)
19:15:30 <mgsloan> right - isn't that already stored?
19:15:33 <dmwit> nope
19:15:56 <dmwit> For example, if I build package foo-1.5 against package bar-1.0 and later rebuild bar-1.0 against other packages, foo-1.5 will be broken.
19:16:11 <dmwit> Or maybe I misunderstood the question.
19:16:15 <dmwit> It's possible the metadata is there.
19:16:29 <dmwit> But my proposal is to allow many copies of the same library version to be installed, provided they have different metadata.
19:16:31 <mgsloan> Huh, strange!  the problem I want to solve is somewhat more fundamental - and also unavoidable - how to use code that targets API v 1.0.0 with code that targets v 1.6.0
19:17:07 <mgsloan> right, that would help things quite a bit
19:18:12 <mgsloan> thing is, I think a lot of upper bounds are unecessary
19:18:29 <kallisti> mgsloan: you can do this with data types to a degree, using implicit configurations to store version-information within a type parameter.
19:19:22 <mgsloan> and this will allow the set of constructors to be different for a different version?
19:19:24 <kallisti> oh you're talking about cabal and stuff.
19:19:39 * kallisti is a bit late.
19:20:07 <kallisti> mgsloan: with type families and type classes, yes.
19:20:41 <kallisti> or in some cases just typeclasses can be used.
19:21:21 <kallisti> it's not exactly an easy solution, but it's possible.
19:21:48 <mgsloan> right, but then anything that's generic on these will need to use viewpatterns or similar to do pattern matching on the data
19:21:58 <kallisti> the reflection package makes the type reification stuff pretty simple (and efficient)
19:22:01 <kallisti> mgsloan: yep
19:22:30 <mgsloan> yeah, I remember ekmett describing how it works.. pretty incredible!
19:23:09 <kallisti> mgsloan: I like using lenses to create overloaded/abstract "record fields"
19:23:41 <kallisti> but it's admittedly something I don't do often.
19:24:15 <mgsloan> oh, I do too
19:25:36 <mgsloan> lenses are akin to C# properties --> implementation hiding --> API transparent code evolution
19:25:47 <kallisti> of course if the functional API changes there's not much you can do about that.
19:26:06 <mgsloan> yup
19:26:44 * kallisti uses lenses in filesystem-trees so that you can use the same interface with Trees and FSTrees
19:27:09 <kallisti> that's very much a work in progress though
19:28:10 <mgsloan> have you seen http://hackage.haskell.org/packages/archive/pez ?
19:28:23 <kallisti> I haven't
19:29:02 <kallisti> I've seen other "generic zipper" libraries that were pretty baffling though
19:29:03 <mgsloan> it's very cool!  Uses lenses-for-trees in a very interesting way
19:29:35 <mgsloan> I like pez because while a little bit baffling at first, it's not too bad
19:29:49 <kallisti> at some point I'd like to add zippers to filesystem-trees, once I figure out the core API. it would be nice to have traversal functions that also maintain a zipper context for each element to be able to poke around at other nodes.
20:01:41 <fergusnoble> luite: hey, are you the same luite behind hfsevents?
20:02:39 <fergusnoble> I had a quick question about it - I'm writing some bindings to work with a HID Manager driver which uses a very similar runloop thing
20:02:39 <luca> is there a way of adding a type constraint to one particular type variable in an otherwise inferred type? :P
20:02:56 <luca> Aka i want haskell to infer the function type... except to add (Show a) to one of the eventually inferred variables
20:03:16 <luca> as otherwise i get errors about ambiguous type variable when trying to use show on the value
20:03:24 <fergusnoble> is there a reason you must make a pipe from the pthread to the haskell thread and not just run the callback function directly from the pthread?
20:03:29 <kallisti> adding a show constraint won't help you there
20:03:35 <kallisti> you need a specific, monomorphic type annotation
20:03:49 <mietek> Does anyone know of a practical example of using Control.Pipe? (pipes package)
20:04:28 <kallisti> luca: show automatically infers the Show constraint, the problem is that it needs to know which show method to call
20:04:37 <kallisti> luca: here's the classic example:   show . read $ x
20:04:49 <AfC> No, but I know of lots of people arguing about pipe vs pipes-core vs conduit vs ... :)
20:04:51 <kallisti> how is x meant to be read? how is it meant to be shown?
20:05:59 <AfC> mietek: e.g. http://www.reddit.com/r/haskell/comments/uav9d/pipes_20_vs_pipescore/
20:06:45 <mietek> Oh man
20:06:55 <mietek> Thanks, I haven't read this one yet
20:09:10 <AfC> mietek: [if you weren't already aware: pipes was an original idea, pipes-core was someone forking it about 5 minutes later (and refusing to merge their work back because it is, of course, so much more special) and conduit is conduit. There does seem to be a strong "math vs pragmatism" flavour to the debate]
20:09:38 <mietek> Thanks, I was mostly aware
20:09:46 <mietek> I liked pipes-1.0, as it seemed simple
20:09:49 <AfC> yeah
20:09:57 <mietek> But pipes-2.0 has confused me a bit
20:10:29 <luca> kallisti; so what should I do to resolve it?
20:10:37 <mietek> I think all this abstraction is really nice, but the point of it should be to actually simplify real-world code
20:10:40 <kallisti> luca: depends on what the code looks like
20:10:46 <mietek> So what's the use case?
20:11:16 <kallisti> mietek: conduit provides a pretty clear use case from the start.
20:11:34 <kallisti> deterministically allocation/deallocation of resources, constant memory usage, etc.
20:11:53 <mietek> kallisti: so claim pipes as well
20:12:04 <luca> actually, it only seems to happen if i have the do block return (x,Nothing) instead of say (x,[])
20:12:05 <mietek> What is conduit actually used for?
20:12:18 <mietek> IIRC it's part of Yesod?
20:12:21 <kallisti> yes.
20:12:25 <luca> wait, that makes sense >.>
20:12:42 <kallisti> http-conduit is used quite a bit for various networking stuffs.
20:12:46 <luca> (x,0) even, (x,[]) gives error for same reason
20:13:00 <stepcut> mietek: it's not actually part of yesod, but rather the IO library that yesod is built on top of
20:13:09 <mietek> Right.
20:13:10 <stepcut> mietek: an alternative to lazy IO, enumerator, and pipes
20:13:10 <luca> is there a way of giving a compiler hint like say: Nothing::(Maybe Int) ?
20:13:26 <kallisti> luca: exactly like that.
20:13:29 <kallisti> but there's no need usually.
20:13:41 <mietek> stepcut: when you say it's an alternative, I imagine there's been a concrete problem with several solutions, each implemented using each competing approach
20:13:52 <mietek> It's probably wishful thinking on my part
20:14:06 <mietek> But I'd really like to see that.
20:14:07 <aristid> mietek: take HTTP requests
20:14:14 <luca> this is only needed temporarigly, when the function's complete inferrence should be able to take over again
20:14:31 <aristid> mietek: there are libraries on hackage for many of these IO styles to do HTTP requests
20:14:32 <kallisti> > show Nothing
20:14:33 <lambdabot>   "Nothing"
20:14:37 <stepcut> mietek: yes.. in the late 80s early 90s, there was no real way to do IO in Haskell -- and that was a problem. So a handful of solutions were tried. Then eventually lazy IO + monads became the dominating solution
20:15:20 <kallisti> luca: are you just trying to print values for debugging purposes?
20:15:47 <stepcut> mietek: then around 2005 or so, Oleg wrote a post describing some of the issues with lazy IO and how it is hard to reason about space usage and proposed something called left-fold enumerators (I think he was the first)
20:16:04 <luca> it's a parser which eventually will be returning tuple like (Maybe X, Y), at present havn't finished writing it so it just looks like return (Nothing,y) to test rest of parser
20:16:24 <stepcut> eventually people started making actually libraries based on the idea. The two big ones being iteratee and enumerators  (or something like that)
20:16:27 <kallisti> luca: you mean Just X ?
20:16:29 <luca> writing return (Nothing::(Maybe Int),y) just for now was enough to get it to compile
20:16:37 <kallisti> luca: Nothing is Maybe a
20:16:48 <kallisti> luca: so it will infer to be whatever you want it to be.
20:16:52 <stepcut> snap and yesod were original based on those (and happstack decided to wait things out)
20:17:22 <stepcut> the yesod people ran into some limitations with enumerators and created conduits to solve their particular problems in a pragmatic manner
20:17:46 <luca> it seems the problem was it could only give a polymorphic type for the tuple element, and for some reason or another, having that tuple type as a type parameter in the Parsec monad; meant it couldn't 'show' the result of the parser :P
20:17:52 <aristid> stepcut: is happstack still waiting things out?
20:18:16 <kallisti> luca: right, there's no Show instance for Maybe a
20:18:31 <luca> yeh it makes sense now
20:19:16 <stepcut> around the time conduits came out, gabriel released pipes 1.0, which aimed to implement a enumerator/conduits style library that was a lot more simple, and based on a strong mathematical foundation.
20:20:34 <aristid> which was heavily criticized by the conduit community for not solving real-world(tm) problems regarding error handling and such
20:21:16 <stepcut> pipes 1.0 did not attempt to  address issues relating to finalization and exception handling.
20:21:54 <geekosaur> specifically, IIRC, it was shown that left-fold enumerators would leak resources if an exception occurred; conduits were designed to mimic them while providing deterministic exception behavior.  pipes were intended to handle them but didn't initially.  hence the conduits folks focusing on that
20:22:03 <stepcut> another guy (something with 'p' and 'c' in it) made (with permission) a fork of pipes called pipes-core, that takes one approach to adding finalization and exception handling to pipes
20:22:18 <mietek> Paolo Capriotti
20:22:22 <stepcut> yeah
20:22:28 <mietek> I appreciate the recap
20:22:35 <mietek> But I have been following the saga quite closely
20:22:51 <stepcut> gabriel has been working on a different solution that attempts to decompose all the pieces into separate layers
20:22:55 <mietek> What I still haven't seen is a comparative implementation
20:23:05 <aristid> mietek: what do you mean?
20:23:47 <AfC> I daresay that Gabriel would have liked Paolo's work to be merged back in. It's not like we needed yet-another such library.
20:23:54 <mietek> aristid: someone taking all four approaches and solving the same problem with each
20:24:09 <mietek> aristid: then pointing out the pros/cons of each
20:24:19 <mietek> I was wondering if this has been done
20:24:24 <stepcut> aristid: yes .. and no. I did some experiments with pipes 1.0 and pipes-core. I plan to experiment with pipes 2.0 soon.
20:24:35 <aristid> mietek: i.e. comparing the existing set of HTTP client libraries might be ok?
20:24:42 <aristid> stepcut: no experiments with conduits?
20:25:12 <stepcut> aristid: no.. my previous attempts to reuse snoyman's libraries have not left me wanting more
20:25:41 <stepcut> aristid: and Gabriel seems much more committed to doing things 'right' versus 'works for me'
20:25:44 <mietek> aristid: I see http-conduit on hackage, and a reference to http-enumerator, which seems to be no longer there
20:26:03 <AfC> stepcut: I appreciate the completeness of http-conduit, but I find it ugly to use.
20:26:05 <Clint> a bunch of the -enumerator packages were deprecated in favor of -conduit
20:26:05 <aristid> mietek: http-enumerator is deprecated, but it should still be out there
20:26:24 <AfC> stepcut: mind you, curl is worse :/
20:26:39 * kallisti has the beginnings of an irc-conduit library on his github
20:26:41 <aristid> AfC: compared to curl, it's a breath of fresh air indeed
20:26:44 <stepcut> despite all the excitement about the left-fold derivatives.. lazy IO in happstack actually works pretty well… so we can afford to wait for a solid solution
20:26:48 <kallisti> no complaints thusfar.
20:26:48 <mietek> aristid: what about http & pipes?
20:26:57 <aristid> mietek: i don't know:)
20:27:12 <stepcut> the original conduits library used IORefs, which was also a big turn-off.. though that is no longer the case
20:27:24 <mietek> OK, I see there appears to be a zlib for enumerator, conduits and pipes
20:27:33 <mietek> I'll check that out.
20:27:51 <mietek> pipes-core*
20:27:57 <geekosaur> note that enumerator is more or less defunct at this point because of the exception handling problems
20:29:07 <aristid> stepcut: conduits by now seem to be quite similar in some ways to pipes
20:29:27 <stepcut> aristid: yes, gabriel comes around and beats michael over the head now and then
20:29:59 <Clint> that's why the conduit 0.4 api is better
20:30:20 <stepcut> Clint: and why 0.5 will be even better :)
20:30:26 * aristid liked the conduit api from the beginning because it was better than enumerators :P
20:30:41 <stepcut> aristid: :)
20:30:53 <aristid> and pragmatism is also not a dirty word for me :>
20:30:59 <stepcut> aristid: the lazy IO AP is great.. as long as you have unlimited system resources
20:31:09 <aristid> yeah
20:31:10 <geekosaur> anything was better than enumerators.  which was why iteratees was created :}
20:31:23 <aristid> geekosaur: i mean the enumerator package
20:31:40 <aristid> i think the iteratee package predated the enumerator package
20:31:43 <geekosaur> (specifically because people had trouble keeping enumerators and enumeratees straight, so iteratees unified them)
20:31:57 <geekosaur> maybe I have that backwards thoguh
20:32:24 <kallisti> lazy IO appears to be working fine for filesystem-trees.
20:32:49 <kallisti> none of the streaming data libraries seem to encapsulate the notion of a tree structure.
20:32:58 <aristid> geekosaur: in the enumerator package (and also in the iteratee package i think), enumerators were type synonyms for functions which take iteratees
20:33:17 <aristid> geekosaur: which is not my definition of easy to deal with
20:34:15 <Guest73069> the types and type definitions in those libraries are really loathesome
20:34:44 <applicative> hm seems my nick was rejected
20:35:20 <applicative> but now we have FreeT whatever in Pipes... ick
20:35:38 <strager> What is FreeT?
20:35:39 <Clint> is that like ResourceT?
20:35:42 <mietek> aristid: yeah...
20:35:49 <strager> I've heard it mentioned a few times but Hoogle brought up nothing
20:35:50 <mietek> s/aristid/applicative/
20:35:58 <applicative> the T just means its a monad transformer
20:36:58 <aristid> mietek: dammit, and there i thought you were agreeing with me :P
20:37:00 <applicative> it's like Either a  (f  a) but recursive
20:37:09 <stepcut> and Free is the free Monad!
20:37:12 <mietek> aristid: well, can't say I'm not ;)
20:37:38 <strager> Are there any papers on Free, or Comonad, or any other "next steps" after monad transformers?
20:37:49 <mietek> "A free monad is a free object relative to a forgetful functor whose domain is a category of monads."
20:37:54 <mietek> Of course.
20:38:00 <aristid> comonads are a "next step" after monad transformers? :)
20:38:03 <applicative> like FreeT f a = FreeT (Either a (FreeT f a)) or some equivalent
20:38:33 <strager> I dunno; they sound related aristid ;P
20:38:49 <aristid> strager: to category theorists i guess
20:39:10 <augur> is there any possibility that Conor's Newtype will become standard haskell magic?
20:39:25 <Ralith> conor's newtype?
20:39:34 <Saizan> strager: it's basically an F-branching tree, where F is the functor
20:40:16 <Saizan> strager: i.e. for F x = (x,x) it'd be a simple binary tree; for F = [] it's a rose-tree, etc..
20:40:17 <strager> Saizan: Well that's like saying "A monad is return and bind"; it doesn't really *mean* much =]
20:40:54 <applicative> oh here is the pipes version http://hackage.haskell.org/packages/archive/pipes/2.0.0/doc/html/src/Control-Monad-Trans-Free.html#FreeF
20:41:07 <Saizan> strager: well, examples should help
20:41:37 <applicative> That Gabriel has a weakness for this sort of thing was already visible  in this way, in the original pipes library,
20:41:49 <aristid> applicative: so using FreeF you can make a monad transformer from any functor?
20:42:02 <applicative> he would write Yield (a,b) rather than Yield a b
20:42:03 <augur> Ralith: http://hpaste.org/69449
20:42:31 <aristid> applicative: why the tuple?
20:42:35 <applicative> aristid: right, it doesn't need to be a monad, Saizan can say
20:42:39 <augur> Ralith: basically, generic methods for newtypes so you dont need to remember the names of the relevant widgets
20:42:52 <applicative> aristid: exactly, because it expresses
20:43:01 <Ralith> widgets?
20:43:03 <applicative> the deep categorical idea  of product
20:43:05 <kallisti> "Pipes form a Category, but if you want to define a proper Category instance you have to wrap the Pipe type using a newtype in order to rearrange the type variables:"
20:43:11 <kallisti> what. why not just rearrange the type variables...
20:43:21 <aristid> applicative: oh
20:43:28 <applicative> but in a Haskell context,  its not only verbose but potentially catastrophic
20:43:43 <applicative> because of the added layer of The Lazy
20:43:46 <aristid> applicative: i imagine the GC might get a bit busier with that
20:44:13 <applicative> there were several warning signs like that
20:44:25 <applicative> but it was wonderful
20:44:39 <augur> Ralith: the thing to produce an element of the newtype and a thing to extract it
20:45:10 <Ralith> ah.
20:45:11 <augur> newtype Foo = Foo { unFoo :: Oldtype }
20:45:19 <Ralith> weird name for it but yeah
20:45:22 <Ralith> that seems like a useful thing
20:45:29 <augur> if you did
20:45:51 <augur> instance Newtype Oldtype New where pack = Foo ; unpack = unFoo
20:45:56 <applicative> intuitively Yield (a,x) should have been Yield !a x
20:46:10 <augur> you never have to remember the constructor/accessor, you just only ever use pack/unpack
20:46:15 <augur> for any newtype
20:46:54 <aristid> augur: is that instance generated automatically?
20:47:01 <applicative> augur: you know lambdabot has Control.Newtype in scope :)
20:47:11 <augur> aristid: well, the idea is that it would be, hence my asking :)
20:47:18 <augur> applicative: yes well, lambdabot is fancy :)
20:47:24 <aristid> augur: haha i guess it can automatically be generated with GeneralizedNewtypeDeriving if there's an identity instance
20:47:43 <aristid> :t pack
20:47:44 <lambdabot> forall o n. (Newtype n o) => o -> n
20:47:49 <aristid> woot
20:47:57 <applicative> aristid: I think someone has devised template haskell to do that or someting
20:48:22 <aristid> applicative: why? GeneralizedNewtypeDeriving should suffice :)
20:48:27 <kallisti> heaven forbid we have to write pack = Fool unpack = unFoo
20:48:34 <aristid> kallisti: !!!!
20:48:43 <aristid> pack the Fool
20:48:47 <kallisti> oh...
20:48:49 <kallisti> ha.
20:48:51 <aristid> lol
20:48:52 <applicative> {=#LANGUAGE DeriveNewtype, GeneralizedNewtypeDeriving#-} was going to be my attempt at wit, aristid
20:49:06 <augur> kallisti: well, it should just be there automatically, why not?
20:49:12 <augur> its not like its fancy or anything
20:49:28 <aristid> augur: well there should be a way of disabling the instance i think
20:49:37 <augur> sure
20:49:38 <aristid> some people want their newtypes totally opaque
20:49:52 <augur> well, opaque in what sense?
20:50:02 <applicative> newtype TopSecret = TopSecret Int
20:50:02 <kallisti> no visible constructor/unwrapper
20:50:16 <augur> except you can always match on it ..
20:50:25 <copumpkin> not if you don't export it
20:50:27 <Ralith> only if you export the data constructor
20:50:28 <augur> and always write your own accessor if you hate opacity
20:50:31 <augur> copumpkin: ahh fair enough
20:50:32 <aristid> augur: say you have a graph library and want to hide from the world (in shame) that you use Int as your vertext type
20:50:39 <applicative> not if they dont export it
20:50:41 <aristid> newtype Vertex = Vertex Int :)
20:50:55 <applicative> like copumpkin said
20:51:00 <augur> yeah, i mean, it should be a deriving thing
20:51:10 <copumpkin> except you can get around that kind of stuff with GeneralizedNewtypeDeriving already
20:51:14 <copumpkin> and standalone deriving
20:51:17 <augur> hmm
20:51:29 <augur> so then i guess conor's newtype IS in haskell! :)
20:51:37 <augur> hoorah
20:51:39 <aristid> applicative: but if Newtype is always instantiated automatically, the constructor will be implicitly accessible
20:51:41 <copumpkin> but we really want ala
20:51:51 <aristid> :t ala
20:51:52 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
20:51:57 <augur> conor's ala
20:52:01 <augur> :)
20:52:09 <aristid> @hoogle ala
20:52:09 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
20:52:09 <lambdabot> Graphics.UI.GLUT.Callbacks.Window DialAndButtonBoxButton :: ButtonIndex -> KeyState -> DialAndButtonBoxInput
20:52:09 <lambdabot> Graphics.UI.GLUT.Callbacks.Window type DialAndButtonBoxCallback = DialAndButtonBoxInput -> IO ()
20:52:15 <aristid> no lambdabot
20:52:15 <augur> are there any good tutorials on the Foldable and Traversable type classes?
20:52:15 <dmwit> copumpkin: Can you explain ala to me?
20:52:17 <applicative> aristid: ah indeed,  i am finally grasping your point
20:52:21 <parcs`> pack/unpack would be useful for rewrite rules involving newtypes, eg 'map pack = unsafeCoerce' :D
20:52:23 <copumpkin> dmwit: sure!
20:52:26 <augur> dmwit: ala is basically
20:52:33 <augur> you have some function over the new type
20:52:38 <augur> and you want it to work over the old type too
20:52:44 <dolio> :t ala'
20:52:44 <lambdabot> forall o n a b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((a -> n) -> b -> n') -> (a -> o) -> b -> o'
20:52:46 <applicative> avoid DeriveNewtype in your graph library, the user is sure to find out
20:53:10 <copumpkin> > ala ZipList Data.Traversable.traverse [[1,2,3], [4,5,6], [7,8,9]]
20:53:11 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
20:53:21 <copumpkin> traverse, ZipList-style ;)
20:53:24 <augur> copumpkin: teach me about Foldable and Traversable!
20:53:30 <aristid> applicative: devious users might recompile the library with -XDeriveNewtype ;)
20:53:36 <dolio> :t ala ZipList
20:53:37 <lambdabot> forall a b n' o'. (Newtype n' o') => (([a] -> ZipList a) -> b -> n') -> b -> o'
20:53:45 <dmwit> For example, why does ala have *two* Newtype constraints in its context?
20:54:21 <aristid> :t ala ZipList id
20:54:21 <applicative> @type ala'
20:54:22 <lambdabot> forall a. [a] -> [a]
20:54:22 <lambdabot> forall o n a b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((a -> n) -> b -> n') -> (a -> o) -> b -> o'
20:54:59 <applicative> :t  ala
20:55:00 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
20:55:42 <dolio> The n o one is for the input, the n' o' one is for the output.
20:55:51 <applicative> @type ala' Endo
20:55:51 <dolio> :t ala ZipList traverse
20:55:52 <lambdabot> forall a a1 b n' o'. (Newtype n' o') => ((a1 -> Endo a) -> b -> n') -> (a1 -> a -> a) -> b -> o'
20:55:52 <lambdabot> Not in scope: `traverse'
20:56:03 <dolio> :t ala ZipList Data.Traversable.traverse
20:56:04 <lambdabot> forall a (t :: * -> *). (Data.Traversable.Traversable t) => t [a] -> [t a]
20:56:10 <dolio> :t ala' ZipList Data.Traversable.traverse
20:56:11 <lambdabot> forall a a1 (t :: * -> *). (Data.Traversable.Traversable t) => (a1 -> [a]) -> t a1 -> [t a]
20:56:18 <dmwit> You guys are really crap at explaining things.
20:56:20 <dmwit> No offense.
20:56:22 <copumpkin> lol
20:56:28 <copumpkin> :t ala Endo Data.Foldable.foldMap
20:56:29 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> a -> a
20:56:39 <augur> oh god what have i done
20:56:39 <augur> lol
20:56:40 <copumpkin> the ala types obscure things
20:56:40 <mietek> dmwit: hahah
20:56:44 <copumpkin> it's much better with type families
20:56:45 <aristid> dmwit: that's just because they're so obvious that nobody knows what could possibly be explained
20:57:08 <dolio> ala' is his original one, I think.
20:57:40 <copumpkin> dmwit: so, the first function in the ala type is the newtype constructor that you use to identify the newtype you want to use
20:57:49 <dmwit> Right.
20:58:14 <applicative> copumpkin, i was about to paste
20:58:16 <applicative> @type ala' Endo Data.Foldable.foldMap
20:58:17 <lambdabot> forall a a1 (t :: * -> *). (Data.Foldable.Foldable t) => (a1 -> a -> a) -> t a1 -> a -> a
20:58:44 <parcs`> :t Data.Traversable.traverse ZipList
20:58:45 <lambdabot> forall b (t :: * -> *). (Data.Traversable.Traversable t) => t [b] -> ZipList (t b)
20:58:49 <applicative> @type ala' Endo Data.Foldable.foldMap (+)
20:58:50 <lambdabot> forall a (t :: * -> *). (Num a, Data.Foldable.Foldable t) => t a -> a -> a
20:59:44 <parcs`> :t ala
20:59:45 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
21:00:11 <dmwit> When will "not (n ~ n')"?
21:00:38 <dolio> When your traversal doesn't produce n.
21:01:04 <parcs`> why 'ala Data.Traversable.traverse ZipList' instead of 'foo (Data.Traversable.traverse ZipList)' ?
21:01:14 <parcs`> where foo is (b -> n') -> b -> o'
21:02:20 <parcs`> but then why 'foo (Data.Traversable.traverse ZipList) b' instead of 'bar (Data.Traversable.traverse ZipList b)' where bar :: n' -> o' which is unpack?
21:02:43 <Saizan> it's ala ZipList traverse, btw
21:03:10 <parcs`> :t unpack (Data.Traversable.traverse ZipList [[1,2,3],[2,3,4],[9,9,9]])
21:03:11 <lambdabot> forall b. (Num b) => [[b]]
21:03:19 <parcs`> ala seems redundant as hell
21:04:03 <parcs`> it is essentially a specialized 'a -> (a -> b -> c) -> b -> c'
21:04:58 <copumpkin> the point is to be able to do "adverbial programming"
21:05:14 <copumpkin> where you can use newtype constructors as tags to indicate different instances
21:05:26 <applicative> like in OO? sounds great
21:05:30 <copumpkin> no
21:05:36 <dolio> I believe ala' ZipList, when passed traverse, gives you the ZipList's traverse, except acting on regular lists.
21:05:37 <parcs`> at the cost of being cryptic
21:05:48 * copumpkin shrugs
21:05:57 * applicative reflects that in Haskell there are no verbs, but now there are adverbs
21:06:21 <copumpkin> traverse is a verb
21:06:30 <copumpkin> ZipList-ly traverse that list
21:06:35 <dmwit> I see, I asked the wrong question.
21:06:35 <parcs`> well actually ala is '(c -> d) -> a -> (a -> b -> c) -> b -> d'
21:06:44 * copumpkin hugs dmwit 
21:06:58 <augur> copumpkin!
21:07:03 <augur> teach me! please? :x
21:07:04 <dmwit> I didn't want to know when "not (n ~ n')", I wanted to know when "(n ~ f a) and not (n' ~ f b)".
21:07:05 <applicative> like  (+)
21:07:26 <copumpkin> augur: I can't really commit to any solid time right now :P
21:07:37 <augur> i just want something to read :P
21:07:37 <dmwit> Which tells me the answer, too: probably never, but "not (a ~ b)", and that's why you need two Newtype constraints.
21:07:48 <copumpkin> augur: I didn't read about it, I fooled around with it :P
21:07:57 <augur> bah :P
21:08:07 <dmwit> copumpkin: Does this sound right to you?
21:08:10 <copumpkin> hmm
21:08:12 <dmwit> aristid: And to you, for whom everything is obvious?
21:08:23 <kallisti> does ala go in the opposite direction? can I treat a newtype as its unwrapped counterpart?
21:08:24 <applicative> augur, you want him to teach you Newtype?
21:08:26 <dolio> dmwit: I think that's the answer.
21:08:38 <augur> applicative: no, i want to understand Foldable and Traversable
21:08:46 <dmwit> dolio: Great, thanks.
21:08:55 <copumpkin> dmwit: yeah, I think that might be it. As I said, it was a lot clearer back in the type family exposition
21:09:06 <dolio> dmwit: Although of course, you could probably come up with a function where n and n' aren't both of the form f a.
21:09:08 <kallisti> :t getZipList
21:09:08 <copumpkin> but that was scrapped due to an old GHC bug that has been fixed
21:09:09 <lambdabot> forall a. ZipList a -> [a]
21:09:19 <kallisti> :t ala getZipList traverse
21:09:20 <lambdabot> Not in scope: `traverse'
21:09:39 <kallisti> :t ala getZipList Data.Traversable.traverse
21:09:39 <dmwit> dolio: Yeah, I'm sure. =)
21:09:40 <lambdabot> forall a (t :: * -> *) o'. (Data.Traversable.Traversable t, Newtype [a] (ZipList a), Newtype [t a] o') => t (ZipList a) -> o'
21:09:51 <applicative> the icky part about Newtype is the 'functional depency
21:09:57 <applicative> dependency'
21:10:01 <dmwit> copumpkin: Hm, time for a newtype-tf? =)
21:10:02 <mietek> Ooh, pipes-extra has some nice very simple examples, including a telnet client.
21:10:26 <copumpkin> dmwit: or we can just bug djahandarie to update it
21:10:34 * copumpkin prefers to bug people to do stuff
21:10:48 <dmwit> djahandarie: Do stuff!
21:10:53 <copumpkin> that's the spirit
21:10:57 <applicative> kallisti: in principle you can declare data Newtype Int String where pack = show  or something
21:11:00 <mietek> copumpkin: I see you're moving into management
21:11:01 <dmwit> preflex: seen djahandarie
21:11:01 <preflex>  djahandarie was last seen on #haskell-blah 3 days, 5 hours, 42 minutes and 50 seconds ago, saying: Cool, thanks
21:11:17 <applicative> data Newtype Int String where pack = show; unpack = read
21:11:22 <copumpkin> mietek: oh shit
21:11:34 * copumpkin slaps applicative 
21:11:55 <augur> applicative: the functional dependency is what makes it magic, at least the op part. not that i know quite what that's for :p
21:11:56 * applicative quickly adds, but that would be wrong.
21:12:39 <applicative> augur, yes, but somehow I am  quickly defeated by errors involving functional dependencies
21:13:16 * applicative concedes that he is weak
21:16:01 <applicative> it occurs to me that newtype should be a dependency of acme-php
21:16:31 <applicative> instance Newtype Float String, instance Newtype Int String, instance Newtype Bool String
21:16:44 <applicative> is basically the idea...
21:18:02 <copumpkin> :)
21:20:06 * applicative contemplates acme-php-extras
21:20:45 * applicative renames to acme-php-fd
21:21:14 <strager> This is brilliant
21:22:08 <applicative> the best definition in Prelude.PHP is:  notElem x ys = elem (not x) ys
21:22:40 <applicative> it leads to somewhat counterintuitive results in the hands of unskilled programmers
21:23:19 <AfC> it leads to somewhat counterintuitive results in the hands of skilled programmers
21:23:41 <dmwit> ?src foldr
21:23:41 <lambdabot> foldr f z []     = z
21:23:41 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:24:00 <dmwit> What's the joke with foldr?
21:24:02 * mgsloan actually seriously wants to write acme-python, consisting of a syntactic desugaring to haskell
21:24:14 <mgsloan> acme-* is a great naming scheme
21:26:10 <monochrom> acme-* is also a great name, where * means Kleene star this time :)
21:26:51 <djahandarie> Do stuff?! What?!
21:26:51 * applicative renames to acme-acme-php
21:27:08 <dmwit> Bring back type families!
21:27:11 <dmwit> RABBLE RABBLE RABBLE
21:27:21 <djahandarie> I am the worst package maintainer ever
21:27:55 <dmwit> And fix that ridiculous "operatate" typo!
21:28:13 <djahandarie> Typo? Lies
21:28:16 <dmwit> And give me under2!
21:28:23 <dmwit> And a pony!
21:28:24 <djahandarie> I will never provide under2!
21:28:42 <dmwit> And I'm running out of exclamation points|
21:28:50 * applicative prepares newtype-extras
21:28:56 <djahandarie> Hey, there is no operatate typo
21:28:59 <mgsloan> ah, so you will provide many, then? Excellent1
21:29:32 <mgsloan> lemme know if newtype changes so I can update newtype-th accordingly
21:29:59 <applicative> oh newtype-th exists
21:30:26 <vodik> �l
21:30:30 <djahandarie> I've always been curious if we can make the deriving stuff work with this
21:30:34 <djahandarie> But I have no idea how it works :(
21:30:48 <djahandarie> Where do I wave the dark magic wand?
21:31:07 <mgsloan> as in deriving / standalone deriving?
21:31:21 <applicative> oh, my idea of newtype-extras has been taken http://hackage.haskell.org/package/newtyper
21:31:27 <mgsloan> as far as I know, it's either got to be "special", or GeneralizedNewtypeDeriving
21:31:56 <djahandarie> Yes, GeneralizedNewtypeDeriving is what I'm talking about
21:32:00 <djahandarie> But I'm not sure how to use that thingy
21:32:10 * applicative prepares newtype-utils with under3, under4 under1_3_5
21:32:34 <Saizan> itym Generics
21:32:40 * applicative prepares newtype-done-right
21:33:57 <mgsloan> djahandarie - that just lets you "inherit" instances from whatever you're wrapping - can't introduce a new instance that way
21:34:11 <mgsloan> short of extending / using a plugin with GHC, I think TH is the way to go
21:34:22 <djahandarie> Man I hate Template Haskell
21:34:29 <mgsloan> Man I love it :)
21:34:43 <mgsloan> checkout this stuff: https://github.com/mgsloan/quasi-extras/blob/master/examples/Example2.hs
21:35:16 <djahandarie> Evil!
21:35:45 <mgsloan> ok, well I disapprove of many of its design decisions.  But, to give it credit, trying to do a more "safe" and "typesafe" version is so frought with complexities, that likely the wrong decisions would be made
21:36:03 <shysoft> I'm a newbie to haskell. I just 'cabal install'ed' SDL. Looking in ~/.cabal/lib/SDL-0.6.3 I find a bunch of '*.hi' files (haskell object files?). Haskell doesn't have header files. Where do I look if I want to find the interface for the contends of the haskell SDL package?
21:36:13 <applicative> mgsloan: this is demonic
21:36:15 <mgsloan> here, there were fewer ways to mess up - just a lot of TH infrastructure left to make
21:36:44 <mgsloan> applicative: you think so?  a typeful wrapper can always be made, once we figure out how to do it
21:36:52 <djahandarie> Okay
21:37:02 <djahandarie> So I'm going to make a new newtype package
21:37:10 <djahandarie> I'm going to make it use type families
21:37:11 <mgsloan> it was either have TH a few years ago, or only just start having it now, with nice safety and such
21:37:11 <djahandarie> And also
21:37:18 <dmwit> copumpkin: Holy crap, it worked.
21:37:31 <djahandarie> Do that Control.Newtype.Unsafe that edwardk wanted
21:37:32 <copumpkin> what worked?
21:37:46 * applicative is really just expressing  resentment at mgsloans evident TH prowess
21:37:54 <dmwit> being management =)
21:37:58 <copumpkin> oh :)
21:38:01 <copumpkin> yeah!
21:38:06 <mgsloan> applicative: paaahah
21:38:08 * copumpkin cracks the whip
21:38:08 <djahandarie> I'll just need to scroll back in the logs to figure out exactly when unsafeCoercing things broke
21:38:11 <JoeyA> shysoft: Look at the Haddock documentation: http://hackage.haskell.org/package/SDL
21:38:38 <shysoft> So, you always reference the online haddock documentation?
21:38:53 <JoeyA> Usually.  You can install it offline, too.
21:38:54 <shysoft> is there a way to browse the contents of a library using ghci or some other tool?
21:38:58 <dmwit> shysoft: You can configure cabal to install the documentation locally.
21:39:10 <applicative> shysoft: if things are set up right, they are also generated when you cabal install
21:39:13 <dmwit> shysoft: You can :browse particular *modules* in ghci.
21:39:21 <dmwit> shysoft: And you can ask ghc-pkg what modules a particular library provides.
21:39:24 <applicative> shysoft: like dmwit said
21:40:00 <dmwit> shysoft: "ghc-pkg describe SDL"
21:42:28 <applicative> shysoft: or, google Graphics.UI.SDL.Video or whatever, usually it autocompletes pretty quickly :)
21:44:06 <JoeyA> Though I'd recommend using Hoogle (http://www.haskell.org/hoogle/) or Hayoo instead, since Google will frequently take you to old versions of things.
21:44:08 <applicative> @google haskell foldMap
21:44:10 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
21:44:10 <lambdabot> Title: Data.Foldable
21:44:35 <JoeyA> I (wonder if | wish) robots.txt could tell the search engine where to find the latest version of something.
21:44:36 <applicative> ^^^ note : "docs/latest
21:45:16 <JoeyA> Because if people keep clicking on the link for GHC 6.6, it'll stay on the first page...
21:45:16 <applicative> @google Control.Monad.Instances
21:45:18 <lambdabot> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Monad-Instances.html
21:45:18 <lambdabot> Title: Control.Monad.Instances
21:45:34 <applicative> Ah here we have it
21:45:49 <JoeyA> Let's see if we can golf the version number :D
21:45:57 <JoeyA> @google Control.Exception block
21:45:59 <lambdabot> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Exception.html
21:45:59 <lambdabot> Title: Control.Exception
21:46:14 <applicative> yeah, the Control.Monad.Instances from 6.12.2 was the real classic
21:46:19 <JoeyA> (in #haskell-blah, of course)
21:46:26 <applicative> ha
21:46:46 <applicative> we are explaining haskell documentation to shysoft :)
21:47:48 <applicative> shysoft, but the best way is to setup cabal to haddock the files, then put the appropriate icon on the upper left hand corner of your desktop
21:48:11 <applicative> thats what the pros do :)
21:48:52 <JoeyA> I have a tab in my bookmarks toolbar called Documentation, where I insert links to locally-installed documentation.
21:48:52 <mgsloan> djahandarie: I've got a suggestion for the new version!
21:48:52 <mgsloan> overM :: (Monad m, Functor m, Newtype n' o', Newtype n o)  => (o -> n) -> (o -> m o') -> n -> m n'
21:48:52 <mgsloan> overM x f = (x `overF` (>>= f)) . return
21:49:52 * applicative  nominates mgsloan to take over maintainership after the ingrates lynch djahandarie 
21:49:58 <shysoft> I attempted 'cabal install SDL-image' and got a configure error saying 'C compiler cannot create executables' see 'config.log' for details.
21:50:07 <shysoft> What could cause this error? Where is config.log?
21:50:23 <applicative> shysoft what operating system are you using
21:50:31 <shysoft> ubuntu 64bit
21:51:05 <mgsloan> applicative: hah!  Then the ingrates will truly learn the error of their ways :D
21:51:05 <shysoft> gcc is 4.6.3 (if that matters)
21:51:24 * applicative rescinds nomination
21:51:44 <applicative> shysoft, it is that you dont have  the right as a mere user
21:52:01 <applicative> as least not the way cabal + ghc are calling it
21:52:23 <shysoft> 'sudo cabal install SDL-image' gives same error.
21:52:45 <applicative> oh, now its getting mysterious
21:53:06 <shysoft> sudo cabal install SDL works.
21:53:13 <shysoft> SDL-image doesn't
21:53:21 <applicative> hmm
21:54:43 <applicative> it would give a different error if libSDL_image werent there or was unfindable
21:55:50 <applicative> grr this is some unix subtlety over my head where is geekosaur :)
21:57:20 * geekosaur here but that's not something I expect to happen on ubuntu...
21:58:51 <dmwit> Can it be a 64-bit gcc but 32-bit ghc or vice versa?
21:59:33 <applicative> doesnt ghc know what gcc its sleeping with
22:00:41 <mzero> isn't gcc usually multi-arch?
22:01:15 <mzero> on Mac it certainly is - will produce both 64 and 32 bit executables
22:01:30 <mzero> ghc certainly doesn't care what arch. gcc _itself_ is
22:05:53 <geekosaur> (I'm installing the C libs now, but (a) network has been iffy all day (b) it's 32-bit debian, not 64-bit ubuntu.  but "C compiler cannot create executables" is from very early on in configure, so unless they're doing something broken (not impossible but unlikely) arch should not yet figure into it.  arch check is typically the thing right after the basic C compiler test
22:09:08 <geekosaur> ahaaaa.  ok, configure script is broken.  what it's really saying is you didn't install the C library for sdl-image
22:09:38 <hpaste> applicative pasted “SDL-image configure” at http://hpaste.org/69450
22:09:43 <geekosaur> on my debian vm it's libsdl-image1.2-dev; try apt-cache search sdl-image
22:09:53 <applicative> oh geekosaur sees it
22:10:59 <geekosaur> (basically they already jammed -lSDL_image into the test compile line, which is a configure no-no)
22:12:27 <applicative> but if it could find SDL-image it wouldn't give the error?
22:14:01 <applicative> shysoft: is SDL-image a separate package on ubuntu? i see it is in homebrew (to use a remote  analogy) Maybe you havent installed it
22:14:15 <geekosaur> I'd have to see the config.log from your build attempt ("cabal unpack SDL-image; cd SDL-image-0.6.1; cabal configure") to be certain, but that's the most likely reason; the script should test the compiler, *then* look to see if SDL-image is installed --- but instead it assumes its there and adds it to the compile command before even testing the compiler
22:14:18 <shysoft> umm.
22:14:27 <geekosaur> [03 01:06] <geekosaur> on my debian vm it's libsdl-image1.2-dev; try apt-cache search sdl-image
22:15:14 <shysoft> "apt-cache search libsdl" yields 'libsdl1.2-dev . . . libsdl-image1.2-dev' looks like it is a separate package, but I thought I'd installed both.
22:15:36 <geekosaur> search just checks that a package exists, not that it's installed
22:15:59 <shysoft> I know.
22:16:21 <geekosaur> dpkg -l libsdl-image1.2-dev
22:16:29 <shysoft> Okay. I hadn't installed it. It works now
22:16:39 <shysoft> Obscure error message tho.
22:17:00 <geekosaur> yes.  as I said, they did a configure no-no; complain to the maintainer of the haskell binding
22:17:11 <applicative> this is annoying
22:17:48 <applicative> lemmih is the maintainer. hm.
22:18:37 <shysoft> I dont' understand this documentation. How do you construct a Pixel? "Pixel (Word32 123))"?:  http://hackage.haskell.org/packages/archive/SDL/0.6.3/doc/html/Graphics-UI-SDL-Color.html#t:Pixel
22:18:50 <geekosaur> it should probably use pkg-config in the cabal file to verify that the dev package is installed, too
22:18:59 <geekosaur> (SDL_image is the pkg-config package)
22:19:05 <applicative> how do we tell him from in here, @tell Lemmih or whatever?
22:19:58 <applicative> you write myPixel = Pixel 123"
22:20:26 <applicative> the literal 123 can express a Word32
22:20:42 <geekosaur> shysoft, numeric literals will work there, Pixel 123 (the implicit fromIntegral will produce a Word32).  it'd be nice to know what a Pixel stands for --- but that's probably in the main SDL docs
22:20:52 <applicative> > [minBound::Word32 .. 3]
22:20:53 <lambdabot>   [0,1,2,3]
22:21:57 <geekosaur> I would expect the cabal file to include contact information, although @tell might work since e's idling here
22:24:07 <applicative> @tell Lemmih sorry to trouble you; it seems there is something wrong with the configure script for SDL-image, geekosaur identifies  it 01:09 and following June 3.
22:24:07 <lambdabot> Consider it noted.
22:24:36 <geekosaur> beware of timezones...
22:25:11 <applicative> oh yes, this is my time, I just didnt believe it was this late....
22:26:08 <geekosaur> but is it Lemmih's?  (I tend to use UTC for this.  in fact I should go rearrange my IRC setup so it's doing things in UTC again...)
22:26:17 <applicative> @tell Lemmih, by  01:09 I of course meant 22:09:08 :)
22:26:17 <lambdabot> Consider it noted.
22:27:06 <applicative> now that i think of it i am using the tunes.whatever time .  I  give up!
22:27:33 <shysoft> Why doesn't Pixel(Word32 123) work?
22:28:51 <geekosaur> because Word32 is not a constructor, it is a type
22:28:57 <applicative> @Lemmih sorry to spam, time is too hard for me, but by 22:09:08 I meant  whatever http://tunes.org/~nef/logs/haskell/12.06.02 means
22:28:57 <lambdabot> Unknown command, try @list
22:29:03 <shysoft> oh.
22:29:36 <geekosaur> the type constructors for numeric types are generally hidden, since Haskell's implicit fromIntegral of integral literals does it for you and the internal representation of such things hsould not be visible
22:29:48 <applicative> shysoft: Word32 is a type; Pixel is a type constructor, a special kind of function :: Word32 -> Pixel
22:30:00 <applicative> @list Lemmih sorry to spam, time is too hard for me, but by 22:09:08 I meant  whatever http://tunes.org/~nef/logs/haskell/12.06.02 means
22:30:00 <lambdabot> No module "Lemmih sorry to spam, time is too hard for me, but by 22:09:08 I meant  whatever http://tunes.org/~nef/logs/haskell/12.06.02 means" loaded
22:30:06 <applicative> hhaha
22:30:18 <applicative> okay, we have verified it is too late for me...
22:30:21 <shysoft> And all of the type constructors for integral types are hidden.
22:32:17 <geekosaur> @tell Lemmih quick summary: -lSDL_image is added to compile command even before the compiler has been tested, so its absence leads to "C compiler cannot create executables". it also would be better to use pkg-config, and Cabal's knowledge of same, to test for the dev packages being installed even before then
22:32:17 <lambdabot> Consider it noted.
22:37:08 <shysoft> I want to draw vector graphics in Haskell. What library should i use?
22:37:46 <dmwit> shysoft: Do you want to do animations on the screen, draw to the screen, or make image files?
22:38:03 <dmwit> diagrams for the latter two, maybe gloss or cairo/gtk for the former
22:38:05 <shysoft> do animations and draw to the screen
22:38:14 <shysoft> 'diagrams'?
22:38:44 <shysoft> I also want to draw text on the screen
22:39:18 <mzero> what's the package that does beautiful graphics on web pages - is that diagrams as well?
22:39:54 <mzero> http://projects.haskell.org/diagrams/
22:40:55 <mzero> no, that one isn't it --- there was one that someone was creating really cool interactive graphic web pages with...
22:44:42 <fryguybob> mzero: luite is making cool interactive web things with diagrams.
22:46:47 <mzero> link?
22:48:14 <fryguybob> http://hdiff.luite.com/tmp/q3.png
22:48:15 <mzero> this! http://pnyf.inf.elte.hu/fp/Diagrams_en.xml
22:48:26 <mgsloan> I'm making cool interactive gtk things with diagrams :)
22:48:47 <mzero> yes - that image is very very exciting - but that work isn't public yet
22:48:53 <mgsloan> Can't wait for wolfgang lambda though
22:48:55 <mzero> the other link  I posted is and runs cool
22:49:57 <mzero> I see, they generage SVG from diagrams and then AJAX it into the page
22:50:00 <mzero> VERY effective
22:56:30 * hackagebot PDBtools 0.0.3 - A library for analysis of 3-D protein coordinates  http://hackage.haskell.org/package/PDBtools-0.0.3 (GrantRotskoff)
23:01:04 <kallisti> > fix ([2]++)
23:01:07 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
23:01:08 <kallisti> > fix (++[2])
23:01:12 <lambdabot>   mueval-core: Time limit exceeded
23:02:32 <mzero> > fix  (2:)
23:02:33 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
23:05:17 <hpaste> dibblego pasted “is this right? (predicateLens)” at http://hpaste.org/69453
23:05:25 <dabblego> edwardk: you about? ^^
23:05:32 <edwardk> ish
23:05:52 <edwardk> sup?
23:06:30 <dabblego> just not sure if I really made a lens
23:06:41 <edwardk> whats this one?
23:06:52 <dabblego> dunno, that's the question :)
23:07:06 <dabblego> Lens (a -> Bool, a) (Either a a)
23:11:55 <shysoft> cabal install gtk results in 'glib-0.12.3 depends on glib-0.12.3.1 which failed to install' 'glib-0.12.3.1 failed during the confure step.' 'gtk-0.12.3 depends on glib-0.12.3.1 which failed to install'
23:12:40 <shysoft> 'gio' actually, in place of the first 'glib'
23:14:16 <edwardk> interesting
23:15:00 <edwardk> you can i suppose change the Either for (Bool, a)
23:15:31 <dabblego> Bijection (Either a a) (Bool, a)
23:15:35 <edwardk> yeah
23:15:50 <edwardk> i'm tempted to say it fails, but i need to check
23:16:19 <edwardk> it gives you back an Either a a such that the predicate succeeds if its Right or fails its Left?
23:16:42 <edwardk> when you put it back in, using the Either what do you do? negate the predicate?
23:17:16 <edwardk> if you negate the predicate when you change the Left/Right by pushing, then perhaps it works
23:17:48 <dabblego> yeah I think the const looks suspicious for that reason
23:17:51 <edwardk> of course it'd be dreadfully inefficient to use a lot
23:18:28 <edwardk> because they'll just chain a bunch of nots onto the function
23:18:56 <dabblego> rewrite rule :)
23:20:22 <edwardk> just write it in scala and use subtypes of Function1 you can case analyze :)
23:20:42 <dabblego> omg we have become scala trolls
23:21:01 <edwardk> shh don't tell anyone
23:21:24 <edwardk> funny thing is i didn't even realize what channel i was in ;)
23:21:26 <tgeeky> dabblego: maybe if you have a -> (Bool,Bool) instead?
23:22:09 <tgeeky> Lens (a -> (Bool,Bool), a) (Either a a)
23:22:12 <dabblego> you mean Lens (a -> (Bool, ..
23:22:24 <dabblego> right, maybe, I'm a bit burnt and will look again later, thanks
23:23:09 <tgeeky> you have the product on the LHS to do it (from (a -> .., a) ) if that makes sense? who knows. not me.
23:24:22 <tgeeky> edwardk: have you read http://www.iis.sinica.edu.tw/~scm/pub/icfp055fp-mu.pdf closely enough for me to ask a few questions and for you to be useful without me wasting your time?
23:24:52 <edwardk> i've seen it before
23:25:05 <edwardk> but i'm probably not awake enough for a quiz ;)
23:25:11 <tgeeky> heh :)
23:25:30 <edwardk> i mostly remember the result, not the derivation
23:26:04 <tgeeky> so, in fuzzy nonsense speak, it occurs to me that they are building some sort of list and d-list hybrid
23:27:22 <dmwit> shysoft: To install gtk2hs, you must first install alex and happy, then gtk2hs-buildtools, *then* gtk. =)
23:27:53 <dmwit> shysoft: Also check that you've got libgtk2-dev, etc. packages installed.
23:27:59 <edwardk> well, i don't recall actually being able to use the result of the paper directly, it was mostly a claim of the existence of such a monoidal reduction, no?
23:28:11 <tgeeky> edwardk: theorem 7?
23:30:09 <edwardk> yes, but what i mean is that converse mapping used in theorem 7 isn't tractable for arbitrary functions in a constructive setting, unless i'm misremembering the limitations of the paper
23:30:37 <tgeeky> yeah. I don't think they know how to use it at all, really, however.
23:31:07 <edwardk> yep
23:31:08 <tgeeky> The entire paper from Lemma 6 onward, is under the condition of Lemma 6
23:31:20 <tgeeky> which is the dumbest possible case of theorem 7
23:32:07 <edwardk> going to crash
23:32:09 <tgeeky> edwardk: so, my main question is -- let's assume I'm incompetent (I am)
23:32:11 <tgeeky> oh ok
23:32:25 <edwardk> sorry, for leaving it with that cliff-hanger. ;)
23:32:30 <tgeeky> hehe :)
23:32:37 <edwardk> you can email me or @tell me the rest ;)
23:32:40 <tgeeky> nah, I should sleep too.
23:40:24 <shysoft> What does this mean: could not find module 'Time' It is a member of the hidden package 'haskell9802.0.0.1'
23:43:39 <geekosaur> shysoft, you have a newer ghc and are compiling an older library/program that uses obsolete package names
23:45:03 <shysoft> Hmm. Well I'm looking for a good simple (up to date) example of using the cairo graphics library.
23:45:15 <geekosaur> the flat namespace (module names like Time instead of Data.Time) is Haskell 98, which didn't have hierarchical modules.  since the H98 compatibility library can no longer be used with modern hierarchical libraries, the module names need to be updated
23:47:10 <geekosaur> Time is actually a bit harder to deal with because the modern Data.Time has a different API; you'd need the old-time package, I think
23:47:56 <shysoft> What editors/IDEs are typically used for haskell?
23:50:17 <bmktuwien> shysoft: well, it depends on your personal taste, but emacs is really a good choice if you ask me
23:50:41 <geekosaur> some use emacs, some vim, some leksah, some eclipse with the eclipsefp plugin...
23:50:46 <shysoft> what plugins are used for emacs
23:51:19 <geekosaur> http://www.haskell.org/haskellwiki/Emacs should have details for the current haskell-mode
23:52:36 <shysoft> Is there a haskell library for parsing haskell code and gaining access to the AST?
23:54:14 <gienah> ?hackage haskell-src-exts
23:54:15 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
23:55:07 * tgeeky giggles at the output of (do this in PM): @djinn (b -> (b,a)) -> (b -> (Bool,Bool)) -> b -> (b,(a,a,a,a))
23:56:08 <unnali> tgeeky: wow, poor thing!
