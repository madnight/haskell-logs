00:04:08 <darkf> Is there a function that takes a list and returns a new list with one element modified?
00:05:24 <startling> darkf, how do you want to modify it? how will you know which element?
00:05:56 <darkf> startling: the returned list should be the same list only the element at the index specified should be swapped for a new element
00:07:02 <startling> @hoogle [a] -> Int -> a -> [a]
00:07:02 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
00:07:03 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
00:07:03 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
00:08:51 <MostAwesomeDude> startling, darkf : I'm sure you can see how that wouldn't be a total function.
00:08:53 <darkf> startling: Doesn't look like it. Basically I want to have a State [T] and have functions which modify one element of it and return the new state.
00:10:02 <startling> MostAwesomeDude: nope
00:10:32 <MostAwesomeDude> Well, it's based on !!
00:10:36 <MostAwesomeDude> :t (!!)
00:10:37 <lambdabot> forall a. [a] -> Int -> a
00:11:04 <darkf> So how do you guys normally do this?
00:11:30 <startling> darkf, maybe you shouldn't be using a list
00:11:41 <startling> MostAwesomeDude, doesn't have to be
00:12:10 <MostAwesomeDude> startling: No, doesn't have to be, but you're gonna have to be creative here.
00:12:35 <darkf> TIL Haskell sucks for state
00:12:46 <MostAwesomeDude> Yes.
00:13:45 <Axman6> darkf: what you should have learned is that state sucks for programs and leads to insidious bugsin the real world all the time
00:14:02 <darkf> Axman6: hint: the real world is very stateful
00:14:19 <Axman6> real world programs are much more stageful than needed
00:14:29 <Axman6> stateful*
00:14:59 <darkf> sure, but I do need a way to pass around a modifiable list :p
00:15:20 <startling> darkf, out of curiousity: why?
00:15:23 <Axman6> well, what's wrong with using State [a] then?
00:15:35 <darkf> Axman6: see above: I need a way to replace an element of it by index
00:15:44 <Axman6> then do that...
00:15:47 <darkf> Axman6: how?
00:15:49 <Axman6> what's so hard about that?
00:16:23 <darkf> Axman6: I don't know of a function which does that.
00:16:35 <MostAwesomeDude> darkf: Write one. It's not *that* hard.
00:16:49 <MostAwesomeDude> I mean, you might not write the best one on your own, but you can write it now and improve it later.
00:17:29 <Axman6> > let replace n x [] = []; replace 0 x (y:ys) = x:ys; replace n x (y:ys) = y : replace (n-1) x ys in replace 3 "Help!" $ words "oh my gosh help help help!"
00:17:30 <lambdabot>   ["oh","my","gosh","Help!","help","help!"]
00:18:10 <Axman6> this sort of stuff is trivial, you shouldn't be playing with State if you can't come up with that off the top of your head imo :\
00:19:44 <unnali> darkf: in general, if you want to be replacing stuff at an index as a matter of course, it's probably a hint you want a Map and not a list.
00:19:59 <Axman6> or a Seq
00:20:00 <darkf> unnali: That actually sounds better.
00:20:23 <Enigmagic> :t Data.Sequence.update
00:20:25 <lambdabot> forall a. Int -> a -> Seq.Seq a -> Seq.Seq a
00:20:25 <Axman6> @hoogle Int -> a -> Seq a -> Seq a
00:20:26 <lambdabot> Data.Sequence update :: Int -> a -> Seq a -> Seq a
00:20:26 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
00:20:28 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
00:21:06 <darkf> Enigmagic: Thank you.
00:22:06 <Enigmagic> np
00:23:53 <startling> MostAwesomeDude: anyway, what did you mean "I'm sure you can see how that wouldn't be a total function."?
00:24:06 <hpaste_> edwardk pasted “I am not a number, I am a free monad” at http://hpaste.org/69918
00:24:52 <rodayo> How do I convert from an Int32 to an Int?
00:25:12 <Axman6> fromIntegral
00:25:42 <MostAwesomeDude> startling: A version that relies on !! would have the same problem as !! itself.
00:26:06 <startling> MostAwesomeDude, no one was talking about using !!
00:26:20 <MostAwesomeDude> If you defined it to not attempt the replacement on lists which were too short, then it would be fine, if slightly misleading.
00:26:33 <startling> ah
00:26:42 <MostAwesomeDude> startling: Anyway, it does appear that a Map was desired, so.
00:26:52 <startling> MostAwesomeDude: yeah, i was just confused
00:26:59 <rodayo> Axman6, thanks!
00:27:00 <startling> and seeking further enlightenment
00:27:02 <edwardk> hah, woops, patternson, interesting typo
00:40:37 <startling> hm, how do I unwrap an IO x for a guard?
00:41:07 <Axman6> there is no wrapping. do you mean execute?
00:41:21 <startling> yes
00:41:33 <Axman6> well what do you have so far?
00:42:58 <startling> Axman6: https://gist.github.com/1b619114453fdb9cf04b
00:43:16 <edwardk> startling: you don't do it in a guard
00:43:21 <edwardk> you have to move it into the body
00:43:27 <edwardk> typically i'd use
00:43:28 <startling> darn. :/
00:44:27 <edwardk> getState dir = doesDirectoryExist dir >>= \b -> if b then .. else ..  or >>= \b -> case b of _ | .. -> | .. -> ..
00:45:33 <startling> that works
00:48:59 <shachaf> Or getState dir = doesDirectoryExist dir >>= go where go b | ...
00:49:04 <shachaf> In some cases.
01:00:28 <roconnor__> oh no, I made it into HWN again
01:03:59 <opqdonut> gah
01:04:07 <opqdonut> where is HWN released nowadays?
01:04:42 <opqdonut> oh, right, the mailing list
01:04:55 <opqdonut> it's Monad.Reader that kept changing hands
01:05:57 <startling> @hoogle FilePath -> IO [FilePath]
01:05:57 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
01:05:58 <lambdabot> Graphics.UI.GLUT.Initialization initialize :: String -> [String] -> IO [String]
01:05:58 <lambdabot> System.FilePath.Windows splitDirectories :: FilePath -> [FilePath]
01:06:37 <startling> it's beautiful how I can find what I want by coming up with the type signature
01:08:14 <startling> is there a thing that recursively gets all the files in a directory?
01:25:40 <fmap> startling: no
01:36:37 <startling> fmap: darn
01:43:31 <womb> Hi!
01:51:36 * hackagebot webserver 0.5.0 - HTTP server library  http://hackage.haskell.org/package/webserver-0.5.0 (JohnLato)
02:02:43 <poldinho92> ciao
02:02:46 <poldinho92> !list
02:10:37 <startling> can I turn a bunch an IO x and an IO y into an IO (x, y)?
02:10:41 <startling> s/a bunch//
02:11:56 <startling> actually, better question: I have a data constructor that takes a bunch of stuff that (usually) comes from IO monads. what's the best way to construct this?
02:12:35 <Axman6> there's lots of different ways. for the example you gave, you can use liftM2 (,):
02:12:36 <startling> I could do (readFile f2 >>= (readFile f1 >>= Foo)) etc etc etc, but that's terrible
02:12:42 <Axman6> :t liftM2 (,)
02:12:43 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
02:12:49 <startling> Axman6: ooh, didn't think of that
02:14:02 <startling> @hoogle a -> b -> c -> d -> (a, b, c, d)
02:14:02 <lambdabot> Data.Sequence zip4 :: Seq a -> Seq b -> Seq c -> Seq d -> Seq (a, b, c, d)
02:14:02 <lambdabot> Data.List zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
02:14:35 <startling> oh
02:14:40 <shachaf> (,,,)
02:14:42 <startling> :t (,,,)
02:14:43 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
02:14:44 <startling> yeah
02:16:28 <startling> @hoogle FilePath -> IO UTCTime
02:16:28 <lambdabot> Foreign.C.Error throwErrno :: String -> IO a
02:16:28 <lambdabot> Network.Socket.Internal throwSocketError :: String -> IO a
02:16:28 <lambdabot> Foreign.C.Error throwErrnoPath :: String -> FilePath -> IO a
02:16:38 * hackagebot paragon 0.1.19 - Paragon  http://hackage.haskell.org/package/paragon-0.1.19 (NiklasBroberg)
02:36:19 <Gx4> hello
02:36:57 <Axman6> 'lo
02:38:42 <edwardk> heya
02:38:52 <edwardk> @hpaste
02:38:52 <lambdabot> Haskell pastebin: http://hpaste.org/
02:39:28 <hpaste_> edwardk pasted “i'm not a number, I'm a free monad” at http://hpaste.org/69926
02:39:47 <edwardk> continuing to fiddle with variable binding/unification/substitution
02:40:09 <edwardk> i've managed to get all of the abstraction/instantiation stuff to be pretty much independent of the user data type we're manipulating
02:40:28 <edwardk> still have decent names, and internally be effectively debruijn, so i'm rather liking it
02:41:31 <edwardk> i just need the (free-ish) monad and traversable instance for your type
02:51:41 * hackagebot graph-rewriting-lambdascope 0.5.2 - Implementation of Lambdascope as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.5.2 (JanRochel)
02:56:22 <Saizan> edwardk: how does thos compare with Scope f a = f (Maybe a) ?
02:56:47 <edwardk> Saizan: logically the same, in practice you get more sharing
02:57:12 <edwardk> that was the thing mentioned at the end of the bird and patterson paper
02:57:30 <edwardk> i just rewrote it out of those horrible combinators they used and replaced it with Monad ;)
02:57:49 <Saizan> ah, i haven't seen that
02:58:17 <edwardk> http://www.cs.uwyo.edu/~jlc/courses/5000_fall_08/debruijn_as_nested_datatype.pdf
02:58:27 <Saizan> thanks
02:58:29 <edwardk> i was beating on that and the i am not a number paper
02:58:45 <edwardk> i had gotten to this point (sans the factored out Scope type) before
02:59:08 <edwardk> but i really liked the fact that abstract/instantiate are fully generic this way
03:00:27 <edwardk> i'm also curious if i flopped the f and b arguments on Scope if it can be a monad transformer
03:01:02 <edwardk> since it is effectively f (Maybe a)
03:01:09 <edwardk> or rather f (Either b a)
03:01:23 <edwardk> (i'm binding multiple things at a time to ease multiple substitutions)
03:02:54 <t7> File mode specification error: (file-error "Cannot open load file" "haskell-ghci"
03:03:01 <t7> :(
03:03:46 <Peaker> Scope f a = f (Maybe a)  <-- Scope = MaybeT
03:03:51 <edwardk> yep
03:04:22 <edwardk> just need to make sure that that has the right semantics
03:05:19 <edwardk> its implemented as Scope b f a = f (Either b (f a))
03:05:39 <edwardk> (well Scope f b a at the moment)
03:05:51 <edwardk> if it turns out to be a monad transformer i may swap
03:06:04 <Saizan> ah, i guess that way return . Right is a O(1) weakening
03:06:27 <edwardk> yeah
03:06:42 * hackagebot cabal-sort 0.0.5 - Topologically sort cabal packages  http://hackage.haskell.org/package/cabal-sort-0.0.5 (HenningThielemann)
03:07:03 <edwardk> its nice if you can push the 'Free' constructors (Right) down the tree as well, because the code for interacting with them usually fires as you traverse it, so you can apparently save some work
03:07:27 <Peaker> what is a typical instantiation of Scope?
03:08:19 <edwardk> http://hpaste.org/69926   look at abstract and instantiate as they'd be used to work with Lam or Let in the little example at the bottom
03:09:32 <Peaker> edwardk, What is this for?
03:09:52 <startling> @hoogle Monad m => [m a] -> m [a]
03:09:52 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
03:09:52 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
03:09:52 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
03:10:01 <edwardk> experimenting with ways to deal with variable binding, because i wasn't happy with the way i was doing some of it in my toy haskell type checke
03:10:06 <edwardk> so i wanted a better way
03:10:41 <Peaker> edwardk, ah.. we store our code in bottle in a key/value store, and every Lambda/Pi has its Guid key, so that's the variable name
03:10:54 <edwardk> thats fairly common
03:10:54 <hilhil> Where do I find EitherT? (hoogle says Control.Monad.Trans.Either ... but that doesn't seem to exist)
03:10:59 <edwardk> we use a splittable variable supply here
03:11:01 <t7> windows is rubbish
03:11:07 <edwardk> rather than a guid
03:11:26 <Peaker> edwardk, ah, well, we do need the code to persist and code elements to have "identities"
03:11:36 <edwardk> basically http://hackage.haskell.org/packages/archive/concurrent-supply/0.1.1/doc/html/Control-Concurrent-Supply.html ported to scala
03:11:40 <edwardk> yeah
03:11:42 <edwardk> i can see that
03:11:57 <edwardk> would be kind of nice to have that property here as well
03:12:12 <edwardk> since we send code over the wire
03:13:05 <Peaker> hilhil, funnily, there's edwardk's lib at: http://hackage.haskell.org/packages/archive/either/0.3.0.1/doc/html/Control-Monad-Trans-Either.html   and mine at: http://hackage.haskell.org/packages/archive/EitherT/0.2.0/doc/html/Control-Monad-Trans-Either.html
03:13:10 <edwardk> hilhil: if its not in my 'either' package i'll write one
03:13:54 <Peaker> (funny because we happened to be talking at the moment, so interesting coincidence)
03:14:16 <Peaker> my library is old and probably incomplete... Maybe I should hide/deprecate it
03:15:16 <hilhil> thanks!
03:15:22 <Peaker> does anyone know of a nice C-level language, without GC, that doesn't have boolean blindness?
03:15:50 <Peaker> It's pretty weird that the low-level language domain remains an "industry area" where all the designs repeat age-old mistakes because they shun academia
03:16:02 <companion_cube> boolean blindness?
03:16:03 <opqdonut> how about go?
03:16:03 <Peaker> academia only cares about high-level languages?
03:16:12 <Peaker> opqdonut, horribly boolean blind..
03:16:18 <pooya72> Peaker: yeah, I was going to mention go http://crypto.stanford.edu/~blynn/c2go/index.html
03:16:27 <Peaker> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
03:17:08 <Peaker> Boolean blindness is basically the lack of typeful-pattern-matching/sum-types -- i.e: when you do branching, the code-point at which you end up has no new type information about anything.. the type-checker gains no information from your conditionals
03:17:18 <startling> is there a function that removes a file's suffix somewhere?
03:17:34 <Peaker> and you need to keep track of your conditional relationships to your program's invariants manually, and debug the resulting silly runtime errors
03:17:41 <opqdonut> Peaker: oh, right
03:17:49 <opqdonut> I had actually read that blog post but had forgotten about it
03:18:21 <Peaker> startling, http://hackage.haskell.org/packages/archive/filepath/1.3.0.0/doc/html/System-FilePath-Posix.html#v:dropExtension
03:18:45 <startling> Peaker: thanks! I knew it was around there somewhere, but i was missing it
03:20:18 <Peaker> Before that blog post, I was not as well aware of how important it was..  Now it seems so silly/dumb to have boolean blindness in a statically typed language
03:20:28 <aforemny> Hi, trying to build poppler-0.12.2 I am having the same problem as described here. http://goo.gl/auFkG Anyone knows what's going on?
03:20:29 <Franciman> hi all
03:21:24 <Franciman> hey guys, I was reading haskell's standard 2010, and in the tokens list I found the symbol "~"
03:21:29 <Franciman> what's its use?
03:21:50 <startling> what's everyone's favorite date string -> LocalTime library, since there seems to be nothing in the stdlib or haskell platform?
03:22:19 <Peaker> Franciman, it makes a pattern-match become "irrefutable", which means the pattern is only matched/unpacked to the variables when those variables are used/forced
03:23:03 <Franciman> Peaker, why?What happens normally?
03:23:29 <mikeplus64> Franciman: normally if you try to pattern match say Just x to something Nothing for example it will fail
03:23:35 <Peaker> > let f x ~(a, b) = if x then a+b else 0 in f False undefined
03:23:35 <lambdabot>   0
03:23:39 <Peaker> > let f x (a, b) = if x then a+b else 0 in f False undefined
03:23:40 <lambdabot>   *Exception: Prelude.undefined
03:24:11 <adamt> Oh, nice trick.
03:24:29 <pooya72> <-- programming noob here.  I don't understand why this sample query from postgresql isn't working: http://hpaste.org/69927
03:24:38 <startling> here I thought it was going to be something boring like bitwise inverse
03:24:40 <Franciman> > let f x ~(a,b) = if x then a+b else 0 in f True undefined
03:24:41 <lambdabot>   *Exception: Prelude.undefined
03:24:41 <Peaker> Franciman, the (a,b) pattern-match is only done if "a" and "b" are used.   so:  f ~(a, b) = ... a ... b ...     is equivalent to  f pair = ... fst pair ... snd pair ...
03:24:43 <pooya72> sorry postgresql-simple
03:25:13 <Peaker> Franciman, if a and b are actually used/forced, then the pattern is matched
03:25:37 <bartavelle> looks like the syntactic sugar that will bite you later
03:25:48 <fmap> pooya72: what's type of `query'?
03:25:54 <Franciman> oh ok thanks a lot
03:26:39 <shachaf> Peaker: f False _ = 0; f True (a,b) = a + b -- :-)
03:26:51 <Peaker> shachaf, of course :-)
03:27:00 <shachaf> I guess you were demonstrating ~ rather than that function.
03:27:05 <Peaker> yeah
03:27:14 <edwardk> woot, Scope works nicely as a monad transformer
03:27:48 * shachaf → threadDelay . (1000000*)
03:28:11 <hpaste_> pooya72 pasted “query type” at http://hpaste.org/69928
03:28:17 <fmap> pooya72: looks like query wants 3 parameters and you gave it only 2
03:28:35 <edwardk> that means you can do that weakening with just lift
03:28:45 <fmap> perhaps you want `query_'
03:28:53 <mikeplus64> pooya72: i think query expects another argument representing how you want the query's result returned
03:29:01 * fmap doesn't know any postgress
03:29:16 <fmap> postgres*
03:29:25 <pooya72> yeah, I'm just following the directions: http://hackage.haskell.org/packages/archive/postgresql-simple/0.1.4.3/doc/html/Database-PostgreSQL-Simple.html
03:29:43 <mikeplus64> i guess their docs haven't been updated
03:30:12 <pooya72> mikeplus64: arg.. do you know of any tutorial or examples?
03:30:29 <mikeplus64> sorry, no, but fmap is right, you probably want query_
03:30:37 <edwardk> @hpaste
03:30:37 <lambdabot> Haskell pastebin: http://hpaste.org/
03:30:45 <mikeplus64> actually, pooya72, the yesod book might have something on it
03:31:02 <hpaste_> edwardk pasted “i'm not a number i'm a free monad transformer” at http://hpaste.org/69929
03:31:03 <mikeplus64> pooya72: the yesod book certainly covers sqlite
03:31:07 <pooya72> on postgresql-simple? don't they use persistent?
03:31:13 * sipa finds it confusing to see standard haskell names being used as nickname
03:31:28 <mikeplus64> pooya72: yeah, but i think persistent has a postgresql backend, don't quote me on that
03:31:55 <edwardk> now i wonder if the monad instance for Scope can be better written using the traversable instance for Var
03:31:58 <mikeplus64> edwardk: what is this?
03:31:59 <adamt> mikeplus64: It does, but persistent isn't really revealing much of the underlying backends.
03:32:27 <edwardk> mikeplus64: an experiment in dealing with variable naming
03:32:41 <pooya72> mikeplus64: adamt: guess not: https://groups.google.com/group/yesodweb/browse_thread/thread/5fe9400c6a3dd236
03:33:14 <mikeplus64> edwardk: for a compiler, or just a play-around?
03:33:22 <mikeplus64> instance Functor f => Functor (Scope b f) where
03:33:24 <mikeplus64>   fmap f (Scope a) = Scope (fmap (fmap (fmap f)) a)
03:33:30 <mikeplus64> fmapfmapfmapfmapfmap
03:33:32 <edwardk> both
03:33:39 <edwardk> this version of things is at the play around stage
03:33:42 <mikeplus64> ah, cool
03:33:54 <edwardk> but i'm toying with it because i wanted to do something nicer in a couple of compilers ;)
03:34:50 <edwardk> basically i started writing this because i was sick of
03:34:57 <edwardk> Type (Var SuperKind Kind) (Var (Kind (Var SuperKind Kind)) (Type (Var SuperKind Kind)) -> Type (Var SuperKind Kind) (Var (Kind (Var SuperKind Kind)) (Type (Var SuperKind Kind)) -> IO (Type (Var SuperKind Kind) (Var (Kind (Var SuperKind Kind)) (Type (Var SuperKind Kind)))
03:35:22 <edwardk> (thats somewhat ridiculous as all the aliases have been expanded, but you can get the idea ;)
03:35:26 <KaneTW> my eyes
03:35:41 <mikeplus64> yeah, that is quite horrifying
03:36:29 <mikeplus64> if a Var is Bound, does this mean it cannot be altered or what?
03:36:31 <edwardk> now all those additional binding considerations are taken care of behind the scenes by the use of a monad transformer and a couple of tricks
03:36:49 <pooya72> so anyone have any experience using postgresql-simple? or should i just move back to HDBC... :\
03:37:00 <mikeplus64> :$ is certainly a nice way to represent function application :)
03:37:06 <edwardk> it means that a lambda/forall/some other binder 'outside of you' controls it
03:37:21 <mikeplus64> ah
03:37:32 <edwardk> stole that one from conor mcbride -- works well right up until you need to annotate the AST with location information or meta data
03:37:42 <edwardk> Exp is just a test
03:37:53 <edwardk> the goal was to factor as much out of it for reuse as possible
03:39:35 <edwardk> mikeplus64: basically in order to work with the bound variables the best way is to just instantiate them
03:40:43 <mikeplus64> i'd be very interested in using a small-ish AST like this to create a simple haskell-like compiler/interpreter
03:41:18 <edwardk> thats kind of the motivation
03:41:33 <edwardk> we have one at work, and i have a toy haskell typechecker i keep kicking around
03:41:47 <edwardk> the one at work went another way with variable binding
03:41:54 <hilhil> I don't suppose someone could tell me what I'm doing wrong with the indentation here? http://hpaste.org/69930
03:42:12 <edwardk> of starts a layout block
03:42:30 <edwardk> move the (LambdaTypeFn from to) -> out to the left of the when but to the right of where 'case' starts
03:42:45 <hilhil> thanks!
03:43:50 <edwardk> let, of, where and do all start layout blocks
03:51:33 <aforemny> Why does poppler try to create bindings to C pango which are already in the Haskell pango package?
03:52:01 <aforemny> Is poppler not maintained anymore?
03:52:17 <fuchsto> does anyone use Gtk2Hs? I get segmentation faults on any call of timeoutAddFull and others, but only on linux. On Windows, it works.
03:52:51 <fuchsto> And i am using the latest sources ... ghc7 and cabal-0.15
03:53:00 <dcoutts> fuchsto: when you call timeoutAddFull, or when timeoutAddFull calls back?
03:53:08 <fuchsto> when i call it!
03:53:24 <dcoutts> fuchsto: strange, never had that
03:53:41 <fuchsto> even with a callback that just consists of a putStrLn
03:54:28 <fuchsto> Oh, no, when it calls back
03:54:43 <fuchsto> So, i add a timeout with 2000ms
03:54:59 <fuchsto> right after 2 seconds, the app crashes with a segfault.
03:55:29 <fuchsto> The callback code doesn't seem to matter.
03:55:40 <dcoutts> fuchsto: well report it to the gtk2hs-dev mailing list. But fortunately you don't need to use timeoutAddFull, since you can use threads and threadDelay
03:56:10 <fuchsto> dcoutts: So, Haskell threads via forkIO?
03:56:16 <dcoutts> right
03:56:25 <dcoutts> fuchsto: see the gtk2hs guide on threading
03:56:28 <sipa> :t forkIO
03:56:29 <lambdabot> Not in scope: `forkIO'
03:56:44 <Peaker> :t Control.Concurrent.forkIO
03:56:45 <lambdabot> IO () -> IO GHC.Conc.ThreadId
03:56:59 <fuchsto> yep, that one :)
03:57:29 <fuchsto> okay, so a timeout producing a segfault is not a commonly known issue,
03:57:32 <Peaker> I think it would be more useful to have a bracket around it in the lib:   withForkedIO :: IO () -> (ThreadId -> IO b) -> IO b
03:57:39 <fuchsto> i will report it, thanks
03:57:55 <Peaker> withForkedIO = bracket forkIO killThread
03:59:13 <Peaker> It would also be nice to have:  newtype BracketT r m a = BracketT { unBracketT :: ContT r m a } deriving (everything..)    and then wrap all those (a -> IO b) -> IO b   results of bracket functions with the BracketT transformer, so you can sequence them nicely/etc
04:05:34 <ceepress> hello all
04:07:14 <yitz> hi ceepress
04:07:18 <ceepress> What is the most smooth haskell mode for emacs? The version I have can only do C-c C-l to reload file and C-c C-b to switch to inferior mode
04:07:34 <yitz> Peaker: what's the advantage of BracketT over ContT?
04:07:52 <ceepress> I want it to run main but cannot
04:08:20 <Peaker> yitz, ContT is too powerful.. if you just want it's bind for your bracket computations, you might not want to bring in callCC and friends..
04:08:25 <ceepress> so I have to manually switch buffer and type main + return, to run
04:08:28 <Peaker> so it may be easier to reason about BracketT than about ContT
04:08:42 <yitz> ceepress: http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
04:08:49 <Peaker> (at least if callCC/etc are considered invalid in a BracketT)
04:09:12 <yitz> Peaker: ok, got it.
04:09:14 <Peaker> it's easy to enforce if the only way to make BracketT computations is via a "bracket" call
04:09:23 <hpc> Peaker: you could actually bring in a different definition of bracket
04:09:32 <Peaker> hpc, what would it be?
04:09:35 <hpc> which would be callCC plus wrapped exception handling
04:10:29 <hpc> open resources, do exception-trapping stuff, then callCC, then close resources and end trapping
04:10:32 <Peaker> hpc, well, the idea is just to make things like this nice/possible:  do { f <- withFile ... ; x <- withThread ... } ; all are closed at exit from "do"
04:10:39 <hpc> ah
04:11:04 <Peaker> also, in BracketT, sequence = Python's nested, which is nice
04:11:23 <hpc> i think for non-trivial brackets, you would end up with open resources for longer than is needed
04:11:46 <hpc> unless you only want to support bracket r (bracket t (bracket w (...
04:11:54 <mauke> Peaker: that looks illegal
04:12:04 <Peaker> mauke, what looks illegal?
04:12:13 <mauke> where illegal = breaks monad laws
04:12:17 <Peaker> mauke, why?
04:12:27 <mauke> intuition
04:12:36 <Peaker> I mean, elaborate :)
04:12:54 <mauke> I have this gut feeling that automatically doing stuff at end of 'do' violates laws
04:12:58 <hpc> do {x} >> do {y} /= do {x; y}
04:13:21 <hpc> it's not violating laws, it's merely impossible
04:14:10 <mauke> o ok
04:14:24 <Peaker> what's impossible?
04:14:26 <hpc> do-notation desugars, and then you can't tell where a block ends
04:14:36 <Peaker> oh, that's what you mean
04:14:37 <hilhil> Is there an existing nice name for 'either Just (const Nothing)'?
04:14:52 <hpc> :t either
04:14:53 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
04:14:59 <hpc> hilhil: don't think so
04:15:02 <Peaker> hilhil, that is the opposite of conventions (Left correlates to error like Nothing, not Right)
04:15:14 <hpc> i think you want the parameters flipped
04:15:17 <hilhil> yup, I want to pull out the error message (if any)
04:15:23 <hpc> oh
04:15:37 <Peaker> mauke, every bind "callback" is wrapped with an init/fini before/after it
04:15:56 <hpc> @hoogle (a -> Maybe a) -> (b -> Maybe a) -> Either a b -> Maybe a
04:15:56 <lambdabot> No results found
04:16:19 <hilhil> (I'm type checking a bunch of expression and want to collate all of the type errors)
04:17:29 <Peaker> you probably want Maybe c there?
04:17:43 <Peaker> or just "c" ?
04:17:49 <hilhil> Don't worry -- it was just one of those places where I thought there might be a slick predefined thing I didn't know about .
04:18:43 <hilhil> Just out of curiosity, is there a 'eitherToMaybe ' or something like that meaning 'either (const Nothing) Just'?
04:18:52 <hilhil> hoogle doesn't turn anything up for me
04:19:03 <Peaker> @type lefts
04:19:03 <lambdabot> forall a b. [Either a b] -> [a]
04:19:11 <Peaker> hilhil, that "collects all the errors"
04:19:27 <hilhil> aha -- thanks!!
04:19:49 <hpc> @src lefts
04:19:49 <lambdabot> Source not found. There are some things that I just don't know.
04:20:52 <fuchsto> I love this bot
04:23:46 <merijn> fuchsto: Be aware that @src is filled with disgustling lies
04:23:58 <merijn> s/disgustling/disgusting
04:25:38 <fuchsto> merijn: Why, where does src get its sources from?
04:25:48 <mauke> a text file someone wrote
04:26:42 <fabjan> @src even
04:26:42 <lambdabot> even n = n `rem` 2 == 0
04:26:56 <linduxed> @src snd
04:26:57 <lambdabot> snd (_,y) =  y
04:28:06 <Peaker> merijn, I think they are cute lies, not disgusting lies, mostly
04:28:20 <fuchsto> ah, i see ... so it's not really showing an official implementation
04:28:36 <Peaker> maybe nicer def of fst/snd:  data (,) a b = (,) { fst :: a, snd :: b }
04:29:10 <fuchsto> Peaker: I see, but i wouldn't have come up with this
04:29:26 <fuchsto> my passive Haskell still is way better than my active Haskell.
04:29:37 <hpc> i think with new extensions, (,) is no longer possible to write in haskell
04:29:49 <hpc> it used to be, all you needed was to make ',' a capital symbol
04:29:53 <Peaker> data [] a = [] | (:) { head :: a, tail :: [a] }
04:30:11 <fuchsto> (what is a capital symbol?)
04:30:25 <hpc> fuchsto: it's like a capital letter, only a symbol
04:30:29 <hpc> right now the only one is ':'
04:30:42 <hpc> which means you have to start infix constructors with ':'
04:30:47 <Peaker> fuchsto, Haskell makes capitalization of names significant in the grammar. So there needs to be equivalent rules for the operator side
04:31:01 <fuchsto> What is the capital variant of ',' ?
04:31:07 <Peaker> well, ->  is also considered capital
04:31:11 <fuchsto> (i feel kidded to)
04:31:25 <Peaker> fuchsto, ':,' if there was one
04:31:32 <fuchsto> ouu..kay?
04:31:49 <mauke> hpc: not really
04:31:51 <hpc> if you arbitrarily decided that ',' was uppercase, is what i was saying before
04:31:52 <mauke> hpc: , is not infix
04:32:06 <hpc> mauke: eh?
04:32:07 <mauke> the parens are required (and it doesn't compose)
04:32:16 <hpc> oh, and that
04:32:23 <tac-tics> Now that you mention it.... The capitalization rules in Haskell are only there because lowercase types are implicitly quantified, right?
04:32:38 <tac-tics> Using uppercase for constructors isn't actually significant in anyway, is it?
04:32:49 <Peaker> mauke, it would be nice if , was infix
04:32:53 <hpc> tac-tics: correct
04:33:10 <mauke> tac-tics: unambiguous patterns
04:33:11 <tac-tics> fmmm
04:33:14 <hpc> tac-tics: it makes pattern-matching harder too
04:33:31 <tac-tics> What's an example of an ambiguous pattern?
04:33:34 <hpc> foo nothing = nothing
04:33:40 <hpc> what is foo (just 5)?
04:33:45 <bdfoxid> @run 1+1
04:33:46 <lambdabot>   2
04:33:48 <tac-tics> hpc: I gotcha
04:34:07 <tac-tics> So it's a convenience for the reader who might not know the ctor names
04:34:20 <bdfoxid> @pl \m n -> add n (mul m n)
04:34:20 <lambdabot> ap add . mul
04:34:21 <mauke> foo otherwise = otherwise  -- foo :: Bool -> Bool?
04:34:49 <fuchsto> hpc: isnt't that a non-exaustive pattern, not an ambiguous one?
04:35:14 <hpc> fuchsto: depends on what you consider "nothing" to be
04:35:18 <Peaker> if it was based on data cons in scope, rather than upper-case, it would mean a new import could change the meaning of a compiling program completely
04:35:28 <Peaker> (I guess overlapping instances also have that property)
04:35:32 <hpc> what if it was "foo x = x"
04:35:36 <hpc> hooray, problem solved
04:35:45 <hpc> until some chucklehead defines data trololo = x
04:35:45 <fuchsto> hpc: ah, in this case it's just an untyped variable, right?
04:36:08 <Peaker> hpc, actually, you've given me a reason to support it.. it'll finally stop people from doing mass open imports
04:36:15 <Peaker> (though that is not a strong enough reason, heh)
04:36:29 <bdfoxid> @type ap
04:36:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:36:32 <hpc> nah, it'd just be one more annoying thing for newbies to discover the hard way
04:36:45 <Peaker> hpc, yes, there are massive reasons against it.. just one reason for it :)
04:36:47 <hpc> we already have enough "why can't i divide 5/4" stuff
04:36:50 <bdfoxid> @type add
04:36:51 <lambdabot> Not in scope: `add'
04:36:53 <Peaker> It would become really painful to import willy-nilly
04:37:15 <Peaker> hmm.. or maybe not, it would not type-check anyway
04:37:18 <hpc> i actually would like to see it become easier for people to open import lots of stuff at once
04:37:33 <fuchsto> What is a mass open import?
04:37:40 <hpc> both at the language level and at GHC not slowing to a crawl when you do it in every file
04:37:43 <mauke> > 5/4
04:37:44 <lambdabot>   1.25
04:38:20 <hpc> fuchsto: just a lot of ordinary imports with no qualification or restrictions on what they want from the imported module
04:38:24 <hpc> import Foo;
04:38:27 <hpc> import Bar;
04:38:31 <hpc> ... continue for 10 lines
04:38:40 <hpc> er, minus semicolons
04:39:07 <fuchsto> What's the alternative if you really need that many modules?
04:39:18 <fuchsto> need as in 'depend on'
04:39:22 <Peaker> hpc, no.. mixing everyone's namespaces into one big mess is a really bad thing
04:39:31 <mauke> import Foo (the, stuff, you, actually, need)
04:39:35 <fuchsto> aaah, got it
04:39:42 <Peaker> or, import qualified Foo
04:39:46 <hpc> import qualified Bar (quux, schnoz)
04:39:54 <hpc> etc, etc
04:39:58 <Peaker> hpc, it's bad for getting what a name means.. It's bad when something is added to any of these modules and the build breaks
04:40:08 <Peaker> no need for name list in a qualified import
04:40:11 <fuchsto> i tend to use import qualified as it forces me to remember where the funs are coming from
04:40:24 <Peaker> I mean, it only serves a purpose if you use a qualified import of multiple stuff onto the same name
04:40:28 <fuchsto> especially helpful when mixing Gtk, OpenGL and GtkGLExt
04:40:46 <Peaker> I use qualified imports because then I don't need to manually mix the name of the module somehow into every exported name in that module
04:40:52 <hpc> Peaker: what i do is import lots of things open, and then let the build break
04:40:56 <Peaker> i.e:  IORef.new   instead of newIORef
04:41:05 <hpc> if a library change is enough to break the build, it probably changed semantics too
04:41:09 <hpc> and needs a going-over anyway
04:41:15 <Peaker> hpc, no, it didn't
04:41:21 <Peaker> hpc, it added a new symbol for convenience
04:41:30 <Peaker> hpc, and that new symbol breaks with your build for no good reason
04:41:48 <Peaker> or as I suffered with the "bitmap" package -- it imported multiple exports of "unsafePerformIO" which worked fine earlier
04:41:59 <Peaker> but then "unsafePerformIO" in one of those modules became a "deprecation wrapper" around the original unsafePerformIO
04:42:03 <Peaker> and so it broke the "bitmap" package
04:42:13 <Peaker> (which now uses unsafePerformIO ambiguously)
04:42:20 <Peaker> that single annoyance costed me many hours
04:42:41 <Peaker> import qualified Unsafe ; Unsafe.performIO   would be so much nicer and no problems
04:42:58 <Peaker> people who like open imports often end up doing manual qualification of all their symbols, it's so silly
04:43:10 <HairyDude> this is strange. "yesod devel" is hanging
04:43:42 <HairyDude> I think the cause is cabal-install
04:44:14 <Peaker> Haskell should have had an "unqualified" keyword, not a "qualified" keyword
04:44:42 <illissius> it's kind of embarrassing though how a lot of time the import list is as long as the actual code
04:44:52 <Peaker> illissius, why is that embarrassing?
04:44:53 <illissius> well, embarrassing for the module system, flattering for the rest of the language.
04:45:12 <Peaker> I disagree, I think it's just a slightly annoying artifact of the textual encoding of our programs
04:45:28 <adamt> really, how so? it's much better than the alternative (well, hello mr. PHP!)
04:46:09 <HairyDude> php doesn't *have* a module system
04:46:15 <adamt> exacly :-)
04:46:25 <illissius> Peaker: a lot of the time it's because you have to do silly things like import qualified Data.Text as Text; import Data.Text (Text) and things like that
04:46:38 <illissius> or well I mean, s/a lot of the time/a part of it/
04:46:50 <Peaker> illissius, yeah, that is slightly annoying
04:46:59 <illissius> there should be a better solution to that. like submodules or something.
04:47:00 * hackagebot wai-extra 1.2.0.5 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.2.0.5 (FelipeLessa)
04:47:02 <ocharles> illissius: clearly you haven't seen how big a typical java import list is
04:47:12 <ocharles> and of course the solution is to just have code folding in your ide and collapse it to one line
04:47:22 <hpc> an interesting experiment would be {-# LANGUAGE OverwritingImports #-}
04:47:25 <illissius> it should be possible to export things pre-qualified or something like that
04:47:25 <adamt> ocharles: To be fair most java import lists are generated on the fly by the IDE.
04:47:32 <hpc> where in the event of name collisions, the most recently imported name wins
04:47:34 <Peaker> illissius, IMO the better solution is to just refer to any name from anywhere via GUID (i.e: in a non-textual editing environment) and not worry about imports
04:47:51 <ocharles> adamt: whether or not the are generated automatically doesn't change the fact that there are typically alot :)
04:47:59 <illissius> ocharles: Vade retro, satana.
04:48:22 <adamt> ocharles: No, but at least the developer doesn't have to deal with it most of the time.
04:48:54 <ocharles> right
04:49:08 <ocharles> i was more addressing the verbosity part
04:49:13 <illissius> Peaker: how's your semantic(?) editor coming along?
04:49:23 <Peaker> illissius, in Haskell, it would be ok I think to just have:  import Data.Text as Text   mean "import qualified Data.Text as Text ; import Data.Text(Text) -- if it exists
04:49:27 <Peaker> illissius, structural editor
04:49:48 <Peaker> illissius, it's coming along nicely, though my co-author is on a 3-week break so I'm left to work on it alone, so I prefer to do the less substantial stuff
04:50:18 <illissius> Peaker: is the coauthor also a #haskeller?
04:50:27 <Peaker> not much.. he used to be here sometimes
04:50:31 <Peaker> but I don't remember the last time he was
04:50:33 <Peaker> "yairchu"
04:50:43 <illissius> remember the name
04:50:46 <illissius> but that's about it :)
04:50:56 <adamt> Peaker: Do you have any information about the editor anywhere available?
04:51:00 <Peaker> he did some cool Haskell stuff (the "list" package, nicest GADT-verified RBTrees/AVLTrees in Haskell, IMO :)
04:51:13 <Peaker> The "defend the king" game with the "peakachu" FRP framework
04:51:27 <Peaker> adamt, https://github.com/Peaker/bottle -- not much beyond that
04:51:31 <Peaker> adamt, it's preliminary work
04:52:15 <illissius> another small thing that would be nice is if you could qualify names with the smallest suffix of the module that makes it unambiguous -- e.g. if you import Data.Text, you could use Text.whatever right away and not have to write "as Text"
04:52:29 <illissius> though that doesn't make sense for all modules, it would help
04:53:18 <HairyDude> that sounds very brittle... you can make programs not build by installing new libraries
04:54:18 <illissius> HairyDude, how so?
04:54:37 * HairyDude suspects his virus scanner is what's causing "yesod devel" to hang
04:54:46 <illissius> you could make programs not build by adding another import with the same suffix, but you can make things ambiguous by adding imports already, so.
04:55:42 <hpc> really, the broken imports problem is solved by putting good upper limits on depends in your cabal file
04:57:32 <HairyDude> argh! this was working yesterday
04:57:58 <Peaker> I hate the upper limits. in practice they do so much more damage than good
04:58:15 <HairyDude> brb
04:58:20 <Peaker> Changed symbol semantics? Rename it -- much nicer strategy
04:58:25 <Peaker> Changed many symbols' semantics? Rename the module
04:59:00 <Peaker> If people imported stuff sanely, and fully-qualified name was a good indicator of a name's semantics, we wouldn't be needing the version constraints at all
04:59:35 <Peaker> We might end up with openFileEx32, but that's far better than the brittle cabal builds we currently have
05:02:14 <HairyDude> after reboot, yesod devel is still hanging. what the hell?
05:02:49 <Peaker> HairyDude, strace it, see where it's hanging?
05:03:15 <HairyDude> Peaker: what's the windows equivalent of strace?
05:06:18 <sipa> starting a virtual machine with ubuntu? ;)
05:07:00 <adamt> My guess would be a silent prayer.
05:07:27 <Peaker> maybe http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx ?
05:07:30 <adamt> HairyDude: Try starting it directly, instead of using yesod devel.
05:08:51 * HairyDude does cabal build
05:11:18 <tac-tics> Is there a technical reason why haskell (GHC?) executables can't decide the number of cores they want to use at runtime? Why do you need to pass it as a special flag to the exe?
05:11:20 <HairyDude> adamt: seems to work...
05:11:33 <tac-tics> Is that a limitation of the operating system? Or of GHC's runtime?
05:11:39 <ion> tac-tics: Maybe you don’t want it to use all the cores by default.
05:11:45 <hpc> tac-tics: the runtime is set up that way
05:12:29 <tac-tics> Just so i have a frame of reference to compare, is that the same way that the .NET framework and/or Java work? That you declare the number of cores up front at launch time?
05:12:34 <hpc> theoretically, you would use one of these: http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Conc-Sync.html#v:numCapabilities
05:12:47 <hpc> to set a reasonable -N in a shell script or something
05:13:02 <tac-tics> I gotcha
05:13:08 <tac-tics> Thanks hpc :D
05:13:48 <hpc> don't mess with setNumCapabilities though, because you can't decrease the number with it
05:14:27 <tac-tics> hpc: but again, the fact you can't decrease it is a limitation of the runtime
05:14:30 <tac-tics> right?
05:14:34 <hpc> yes
05:14:59 <tac-tics> neat
05:15:14 <HairyDude> ok, I'm running Process Monitor from sysinternals, and having it show only events from yesod.exe
05:15:32 <hpc> an interesting implementation of decreasing the number would be to mark a capability as "released", and then stop scheduling jobs to it
05:15:41 <HairyDude> it's stopped after IRP_MJ_QUERY_INFORMATION on cabal.exe
05:15:44 <hpc> and when it can be safely removed, it is
05:16:10 <tac-tics> Garbage collection for cores :)
05:16:29 <fmap``> Hi everyone. I'm trying to find native haskell library to work with vectors and matrices, but I'm a bit confused. Many packages is just bindings to some external BLAS library. 'vector-space' package just providing common classes, but do not contain an instance for vectors, as I understand. Does anyone know lightweight package that provide native(!) BLAS?
05:17:05 <hpc> fmap``: hmatrix looked good last i saw it
05:17:10 <hpc> i have never used it though
05:17:33 <HairyDude> now got it showing cabal.exe as well, and there's nothing
05:17:56 <HairyDude> I can't open the task manager at this point, but if I kill yesod it opens and shows a cabal process
05:25:35 <fmap``> hpc: it seems that I need, thx
05:25:39 <t7> terminfo doesnt build! :O
05:26:50 <t7> http://hydra.nixos.org/build/2612638
05:27:23 <t7> haskeline even
05:29:50 <HairyDude> last thing cabal does is try to open a couple of registry keys that don't exist
05:30:28 <dcoutts_> HairyDude: that might be it checking http proxy settings
05:30:33 <dcoutts_> which keys?
05:31:35 <HairyDude> HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\VERSION.dll and HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\guard32.dll
05:32:04 <HairyDude> I have no proxy set, btw
05:32:18 <HairyDude> also firewall and antivirus are off
05:32:39 <fuchsto> Hm. Data.IORef defines a function 'get', right? As in    val <- get myIORef
05:32:54 <dcoutts_> HairyDude: oh, then that's not something that cabal is doing directly
05:32:57 <unnali> fuchsto: it's readIORef
05:33:07 <fuchsto> i imported Data.IORef and ghc complains about 'get' not being in scope.
05:33:11 <unnali> fuchsto: you may be thinking of the State monad.
05:33:19 <fuchsto> Hm? This works fine in two other modules in the same project?
05:33:26 <dcoutts_> HairyDude: if cabal.exe is accessing those registry entries then it must be something internal in some windows system library
05:34:00 <HairyDude> dcoutts_: those entries are immediately after successfully loading those dlls
05:34:02 <unnali> fuchsto: see http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html, http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-State-Lazy.html
05:34:22 <unnali> if it is working in other modules, something else is going on (perhaps someone's redefined get somewhere, or perhaps it's not Data.IORef at all)
05:34:30 <fuchsto> unnali: Thank you, but why is this working in two other modules in my project? I got this from tutorials.
05:34:40 <unnali> Could you link those tutorials? :3
05:34:41 <fuchsto> So, it's my idea to use get there
05:34:47 <HairyDude> dcoutts_: the weird thing is, this was all working the other day
05:35:39 <unnali> ohhh
05:35:56 <unnali> fuchsto: you're doing OpenGL stuff?
05:37:23 <fuchsto> unnali: Sure: http://www.haskell.org/haskellwiki/OpenGLTutorial1
05:37:28 <unnali> right!
05:37:41 <unnali> Graphics.UI.GLUT re-exports, I think, Data.StateVar
05:37:45 <fuchsto> unnali: Search for 'currentheight <-'
05:37:47 <unnali> http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
05:37:53 <unnali> note the "get" definition
05:37:58 <fuchsto> d'uh, so it's from GLUT ...
05:38:02 <unnali> and use of "$="
05:38:03 <unnali> yeah.
05:38:16 <fuchsto> okay, but the proper way would be to use readIORef here?
05:38:26 <unnali> well, if you wanted to use an IORef, yes. :)
05:38:41 <fuchsto> hm. Why are they using get on an IORef?
05:39:01 <unnali> they're not! :) heh
05:39:03 <unnali> wait
05:39:06 <unnali> i meant to erase that first bit
05:39:09 <unnali> and just write "heh"
05:39:10 <unnali> shot myself in the foot
05:39:16 <fuchsto> :)
05:39:22 <unnali> turns out they're reimplementing the Data.StateVar thing in OpenGL, not GLUT:
05:39:23 <unnali> http://hackage.haskell.org/packages/archive/OpenGL/2.2.2.0/doc/html/Graphics-Rendering-OpenGL-GL-StateVar.html
05:39:27 <fuchsto> Why does this even work?
05:39:36 <unnali> hehe
05:39:48 <unnali> because "get" is defined to work in these modules as working on anything with a 'HasGetter' instance
05:39:49 <fuchsto> i imported Graphics.Rendering.OpenGL, too
05:39:53 <unnali> and they define an instance 'HasGetter IORef'
05:39:54 <fuchsto> aaah
05:40:00 <unnali> meaning their "get" will work on an IORef too
05:40:17 <fuchsto> okay
05:40:30 <fuchsto> oh, and it also complains about $=! not being in scope
05:40:34 <unnali> if you read their source, you see what's going on though: http://hackage.haskell.org/packages/archive/OpenGL/2.2.2.0/doc/html/src/Graphics-Rendering-OpenGL-GL-StateVar.html#get
05:40:41 <unnali> instance HasGetter IORef where get = readIORef
05:40:43 <unnali> instance HasSetter IORef where ($=) = writeIORef
05:40:47 <unnali> about $=! !?
05:41:03 <fuchsto> unnali: yes
05:41:18 <unnali> you may need to import it from .. somewhere
05:41:22 <unnali> which one complains of that?
05:41:33 <fuchsto> well, my code using it
05:41:46 <fuchsto> (when using readIORef instead of get, it works)
05:41:48 <unnali> ah; are you importing Data.StateVar or GL in this module?
05:41:53 <fuchsto> yes
05:42:00 <fuchsto> aaah, i
05:42:03 <fuchsto> i'm a dork
05:42:08 <unnali> :D!
05:42:21 <mauke> and here I thought you were a fox
05:42:23 <fuchsto> i did:    import qualified Graphics.Rendering.OpenGL as GL
05:42:30 <unnali> aha, that'll do it! :)
05:42:35 <fuchsto> mauke: Also true :)
05:42:48 <fuchsto> no, the qualified is the problem
05:42:58 <fuchsto> because i had to use GL.get and GL.$=!
05:43:00 <unnali> wow, I just thought I was in the wrong channel for a second when we started talking about foxes
05:43:04 <unnali> yup :)
05:43:04 <fuchsto> (if the latter is even possible)
05:43:27 <unnali> sure is. :)
05:43:37 <unnali> you can use infix functions with package qualifications just like any other
05:43:43 <fuchsto> sweet
05:43:44 <unnali> (i too thought the parser might choke on them, but apparently not.)
05:44:13 <fuchsto> being a beginner in Haskell sure is a splendid frustration test
05:44:24 <tac-tics> fuchsto: for sure :P
05:44:27 <tac-tics> Haskellers are masochists
05:44:39 <fuchsto> tac-tics: Rawwwr
05:44:40 <tac-tics> the type system is no more than a straightjacket you put on
05:44:42 <unnali> fuchsto: prepares you for having kids, or something.
05:45:12 <fuchsto> unnali: That's another good reason to learn haskell.
05:45:19 <unnali> an awesome straightjacket at that, tac-tics.
05:45:33 <fuchsto> "You are having a KID?! Did you even implement a MonadPlus ONCE?!"
05:45:37 <unnali> :D!!
05:45:58 <unnali> happy to say I managed the latter before I did the former, and I seem to be doing okay :}
05:46:35 <sipa> "you should really learn referential transparency before even thinking about forkIO'ing yourself"
05:47:10 <fuchsto> unnali: So, i'm supposed to raise kids the way i code haskell? Do something that i think could work and then wait for it to yell at me, so i know i was wrong?
05:47:11 * tac-tics is mostly interested in Haskell for the jokes.
05:48:08 <hilhil> More like: Do something that you think would work and then wait for your other half to yell at you...
05:48:42 <Peaker> tac-tics, the straightjacket is much quicker than a hammer forcing you into position, painfully and slowly, bug after bug :)
05:48:50 <unnali> fuchsto: basically, if it runs, it's probably not broken.
05:50:30 <hilhil> Is there a more idiomatic way of writing 'return ()' ?
05:50:45 <tac-tics> hilhil: return () seems plenty idiomatic to me
05:50:50 <unnali> indeed :)
05:50:55 <tac-tics> If you're working with a monad, of course
05:50:56 <Peaker> hilhil, no, it's very idiomatic. though "pure ()" also works
05:51:03 <Peaker> (if you can use Applicative)
05:51:12 <mauke> some people use 'def' but they might be crazy
05:51:30 <hilhil> @hoogle def
05:51:30 <lambdabot> System.Posix.DynamicLinker.Prim Default :: DL
05:51:30 <lambdabot> System.Posix.Signals Default :: Handler
05:51:30 <lambdabot> keyword default
05:51:57 <hilhil> anyway, thanks as ever!
05:51:58 <Peaker> with an ugly   instance Applicative m => Default (m ()) where def = pure ()   ?
05:52:48 <hilhil> Also, does anyone here use Leksah?
05:52:56 <unnali> hilhil: or you could wrap the whole(?) monadic action in void
05:52:59 <unnali> :t void
05:53:00 <lambdabot> Not in scope: `void'
05:53:01 <hilhil> I've been finding it getting slower and slower and slower to build, and I don't know why...
05:53:02 <unnali> bah.
05:53:09 <unnali> :t Control.Monad.void
05:53:10 <lambdabot> Not in scope: `Control.Monad.void'
05:53:12 <hilhil> Yup, I ran across avoid, which was actually what prompted the question .
05:53:13 <mauke> Peaker: no, it needs a separate instance for each type
05:53:14 <unnali> well, fine.
05:53:17 <hilhil> *across void
05:53:22 <Peaker> mauke, to be H98/H10?
05:53:42 <mauke> to be useable
05:53:42 <hilhil> Only thing was it took argument, whereas I needed something standalone
05:54:00 <unnali> hilhil: I guess you can't get any better than plain old return, then.
05:54:06 <hilhil> no, that's fine
05:54:17 <hilhil> It's just sometimes hard to know what's idiomatic.
05:54:28 <unnali> true
05:54:56 <hilhil> I think I'm going to uninstall Leksah and the Haskell platform and upgrade to the newer Haskell platform version -- wish me luck!
05:55:06 <fmap> hilhil: you can avoid some `return ()' with `when'/`unless' (which basically write `return ()' for you)
05:55:08 <unnali> that said, tours of unidiomaticy(?) are sure fun: `pure mempty'? :)
05:55:31 <unnali> fmap: you must get your IRC client pinging you a lot for mentions in this chan …
05:55:34 <HairyDude> hm. it's using a program called pkg-config.exe that comes with graphviz... that can't be right
05:56:05 <Peaker> HairyDude, I think pkg-config is a standard tool to describe the cmdline options needed for various build tools to build a certain package
05:56:33 <fmap> unnali: i'm using some nlp technics to not to be bothered too much
05:56:34 <Peaker> rather to build *with* a certain package
05:56:50 <d-snp> :t fromIntegral
05:56:52 <lambdabot> forall a b. (Integral a, Num b) => a -> b
05:57:00 <HairyDude> Peaker: it's not haskell-specific then?
05:57:23 <Peaker> HairyDude, no
05:59:45 <hpaste_> d-snp pasted “Cast” at http://hpaste.org/69931
05:59:57 <d-snp> hey guys, is something like this possible?
06:00:14 <d-snp> I would like to cast without unsafeCoerce
06:01:06 <hilhil> that snippet doens't make sense to me...
06:01:11 <MasseR> fmap: What kind of techniques?
06:01:26 <hilhil> you can't turn a into Just a AND turn it into Nothing
06:01:33 <unnali> d-snp: you've got the same pattern match for both. what do you really want?
06:01:40 <hilhil> which do you wnat?
06:02:02 <hilhil> in fact, What are you trying to achieve?
06:03:01 <hpaste_> d-snp annotated “Cast” with “Cast (revision)” at http://hpaste.org/69931#a69932
06:03:19 <d-snp> well I want to unsafeCoerce, but without the danger :P
06:03:35 <d-snp> so I would want the pattern match to check for the type
06:03:42 <fuchsto> Another newbie question: What's the difference between / and div?
06:03:50 <merijn> :t (/)
06:03:51 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:03:52 <merijn> :t div
06:03:53 <lambdabot> forall a. (Integral a) => a -> a -> a
06:03:54 <hilhil> Do you want to turn a Association s into an s?
06:03:58 <fuchsto> latter doesn't seem to work on floats
06:04:08 <d-snp> no, I want to turn an Association s into an Association s
06:04:10 <unnali> right. It's integer division! (or "Integral" division, in this case.)
06:04:13 <merijn> fuchsto: div only works on Integrals, / works on any Float
06:04:14 <fuchsto> merijn: Ah, could have looked that up in ghci myself, thank you
06:04:31 <unnali> d-snp: and an Association t where t ≠ s into Nothing?
06:04:42 <hilhil> How is the one you get out different from the one you get in?
06:04:49 <greed_> Can anyone tell me how to append paths to HS-Source-Dirs from Setup.hs? I'm trying to generate code from data, without having to distribute the generated code.
06:04:50 <d-snp> where t != s, yes
06:04:55 <hilhil> ah
06:04:56 <unnali> riiight
06:05:25 <fuchsto> Yarr! Good sirs, i have an OpenGL widget that i can modify using GTK widgets now.
06:05:30 <hilhil> Can you show us a bit more of the context? it would be useful to see why you're trying to do this...
06:05:30 <d-snp> haha, do you think it's possible? :)
06:05:37 <d-snp> sure
06:05:47 <unnali> fuchsto: nice! (n.b. sirs/madams/????s ;))
06:05:56 <hilhil> Type signature of the thing you want is
06:06:04 <hilhil> Association s -> Association t
06:06:20 <fuchsto> unnali: I use "Sir" as a respectful title. It has a genus, but defines no sexus.
06:06:20 <hilhil> And I'm not sure the compiler will allow that (although one of the many people here who knows more than me will)
06:06:35 <fuchsto> unnali: Remember peanuts?
06:06:43 <d-snp> basically the s in the association is the state of the application, the associations get put into a map, together with the associations from other applications
06:06:58 <unnali> fuchsto: that's fair, I guess, though it can't be helped that the term carries a lot of baggage. (but this is wildly OT for this channel I guess! :))
06:07:19 <d-snp> and when an application wants its association back, it looks it up in the map
06:07:37 <d-snp> but the map returns an association of any type, while the application needs an association of a specific type
06:07:39 <unnali> hilhil: I think d-snp wants Assocation s -> Maybe (Association t), since there's a chance the type won't match. there's probably a way, but I'm not sure I know it. :)
06:08:10 <hilhil> This looks to me  like it involves runtime types rather than compile time types
06:08:26 <fuchsto> unnali: Yes, and yes :) Are there female haskell coders around? I never met one :/  Women tend to use Java, according to my experience to far
06:08:29 <d-snp> actually I'm fairly certain they never don't match, but unsafeCoerce is a bit unsafe :P
06:08:31 <greed_> unnali: then you'd want (Failure e m) => Association s -> m (Association t)
06:08:32 <hilhil> Which pushes me out of my depth as far as Haskell is concerned
06:08:36 <unnali> does Data.Typeable do anything here? I've never used it, but it seems to crop up in these discussions.
06:08:40 <greed_> unnali: because Failure is very useful
06:08:45 <unnali> greed_: good point!
06:09:07 <hilhil> Do you know all of the possible types of state you might need to store, or is it possible that
06:09:20 <hilhil> You will have to keep adding more kinds of applications with more kinds of state?
06:09:49 <unnali> fuchsto: there sure are! Female coders are uncommon in general, I guess, and perhaps an apparent Java majority is just reflecting the corporate world (or something).
06:10:22 <unnali> d-snp: is this something you can solve by having all the application states being part of a single typeclass?
06:10:33 <hilhil> Hmmm
06:10:35 <srhb> fuchsto: o/
06:10:36 <hilhil> Data.Dynamic:
06:10:37 <hilhil> A value of type Dynamic is an object encapsulated together with its type.
06:10:44 <hilhil> It looks to me like this is the kind of thing you need
06:10:49 <fuchsto> unnali: I'm afraid so.
06:10:57 <hilhil> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Dynamic.html#v:fromDynamic
06:11:09 <hilhil> Take your states and convert them to a Dynamic before storing them in your map
06:11:35 <fuchsto> "How many female haskell coders do you need to screw in a light bulb?"
06:11:39 <hilhil> And then pull out of the map and convert them back using fromDyn (with the default value of 'Nothing')
06:11:43 <fuchsto> "Both of them"
06:11:44 <hilhil> But I've never played with that.
06:11:59 <greed_> fuchsto: :')
06:12:07 <Philonous_> Is there a library that handles groups/hierarchies of threads?
06:12:23 <unnali> hilhil: seems like that uses Typeable underneath. You could do (Data.Typeable.cast x) :: Maybe y
06:12:29 <unnali> and you'll get Just someY if x=y.
06:12:33 <fuchsto> I accidentally claimed that a female haskell coder could not screw in a light bulb alone, sorry, unintended
06:12:38 <unnali> that should really be @d-snp, not hilhil.
06:13:08 <unnali> fuchsto: well, you didn't say anything about how many male haskell coders (or otherwise), so there's no point of comparison yet! But I get what you mean re: both of them ;p
06:13:34 <greed_> How many Haskell coders do you need to screw in a light bulb?
06:13:40 <unnali> > (cast True) :: Maybe Int
06:13:41 <lambdabot>   Nothing
06:13:44 <unnali> > (cast True) :: Maybe Bool
06:13:44 <lambdabot>   Just True
06:13:59 <hilhil> unnali: what's the equivalent of toDyn?
06:14:02 <unnali> greed_: an infinite list of them; they're all so lazy?
06:14:05 <greed_> None. Although light bulbs exist, the screwing will be abstracted to the type level.
06:14:13 <greed_> That one is even better, unnali :)
06:14:14 <unnali> hilhil: none; use universal quantification.
06:14:29 <greed_> (repeats question)
06:14:34 <greed_> I'm trying to generate code from data, without having to distribute the generated code.
06:14:36 <hilhil> Hm -- I don't know about that
06:14:36 <greed_> Can anyone tell me how to append paths to HS-Source-Dirs from Setup.hs?
06:14:39 <hilhil> How does it work?
06:14:51 <unnali> hilhil: I'm just testing to make sure I'm talking about something I know about. (or was it the other way around?)
06:15:00 <unnali> greed_: wish I knew how it worked so I could help :|
06:15:08 <greed_> Cabal is a PITA.
06:16:03 <hilhil> How long should 'cabal configure' take to run? I'm waiting about 30 seconds, and I'm sure it didn't always take that long...
06:16:17 <greed_> cabal configure may link a Setup.exe, right?
06:16:25 <hilhil> ah
06:16:32 <greed_> That takes a while at times :(
06:16:54 * greed_ is clearly using too much Windows and assumes *.exe.
06:17:16 <greed_> At least I can't do any GUI programming with Haskell -____-
06:19:01 <hilhil> Hmmm... 'cabal install intern' Says it's likely to break a bunch of packages including ghc-7.4.1, which sounds a little worrying
06:19:17 <hilhil> also haskell-platform-2012.2.0.0
06:19:21 <hilhil> Is it safe to do?
06:19:32 <greed_> I doubt that
06:19:42 <greed_> you should ask ghc-pkg what's wrong with your current setup
06:19:44 <hilhil> Doubt it safe, or that it will break things?
06:19:53 <greed_> doubt it's safe
06:20:07 <greed_> unless you like fixing your repos as root
06:20:49 <hilhil> I've just reinstalled the Haskell platform on a Windows box (using an account with admin privileges)
06:21:00 <greed_> W7 or WXP?
06:21:02 <hilhil> Not sure what ' fixing repos as root' corresponds to...
06:21:03 <hilhil> XP
06:21:06 <greed_> ah
06:21:24 <hilhil> I do really need intern -- bit puzzled about why it installing it would break anything.
06:21:25 <greed_> You have multiple package repositories with Cabal.
06:21:33 <greed_> one system, one per user
06:21:36 <hilhil> ah
06:21:45 <greed_> cabal install --dry-run -v intern?
06:22:08 <hilhil> (thanks, by the way -- I'd be totally swamped with this on my own)
06:22:24 <hilhil> That gives much the same output as the original
06:22:30 <greed_> :S
06:22:46 <hilhil> http://hpaste.org/69933
06:22:57 <greed_> ghc-pkg check
06:23:26 <greed_> deepseq-1.3.0.0 (reinstall) changes: array-0.4.0.0 -> 0.3.0.3  <== culprit right here
06:23:29 <greed_> together with
06:23:35 <greed_> array-0.3.0.3 (new version)
06:23:43 <greed_> I think
06:23:52 <hilhil> So it's trying to downgrade array??
06:24:21 <greed_> ah
06:24:22 <greed_> I see why
06:24:25 <greed_> intern-0.8
06:24:38 <greed_> wants array (≥0.3.0.2 & <0.4)
06:24:46 <hilhil>  ghc-pkg check just gives some haddock warnings
06:24:49 <hilhil> ah
06:24:52 <greed_> cabal update
06:24:54 <greed_> ;)
06:25:18 <hilhil> ah -- thanks!!!
06:25:20 <unnali> oh heck :(
06:25:32 <unnali> I was trying to make an example with a Map and Data.Typeable.cast, and now this:
06:25:41 <unnali> "My brain just exploded"
06:25:43 <unnali> from GHC
06:25:43 <unnali> >_>
06:25:51 <hilhil> [BTW, if I install library versions with --enable-library-profiling, will they be slower when I'm *not* profiling? Or take longer to compile?]
06:25:54 <greed_> wat
06:26:09 <unnali> greed_: "I can't handle pattern bindings for existential or GADT data constructors." :D! whoops.
06:26:18 <ClaudiusMaximus> hilhil: it compiles 2 copies, 1 with profiling, 1 without
06:26:18 <greed_> hilhil: enabling profiling will only double the compiling time
06:26:29 <greed_> hilhil: you'll end up with .o and .p_o files
06:26:45 <greed_> hilhil: so you'll have specialized profiling binaries alongside normal ones
06:26:51 <unnali> I appear to have failed at what I was trying to do, but I had some fun anyway.
06:27:03 <hilhil> unnali: I think it might be simpler to just use Dynamic
06:27:09 <hilhil> greed: thanks!
06:27:18 <hpaste_> unnali pasted “not quite the Map I foresaw” at http://hpaste.org/69934
06:27:19 <HairyDude> failure is just success rounded down!
06:27:32 <unnali> hilhil: I'm inclined to agree, *but*, I'd also really like to get this one to work!
06:27:33 <mauke> unnali: yeah, that's what happens when you try to create a freestanding existential
06:27:57 <hilhil> Is that an existential or a universal?
06:27:59 <mauke> T looks useless
06:28:02 <hilhil> I would have expected a existential
06:28:04 <greed_> soooo... nobody here knows enough about Cabal to help me? :(
06:28:05 <unnali> existentials here, whoops.
06:28:18 <dcoutts_> greed_: have you looked at the Cabal lib API?
06:28:30 <Peaker> unnali, what's the purpose of T?
06:28:41 <mauke> unnali: T is in fact useless
06:28:44 <dcoutts_> greed_: you just want to modify the buildinfo for the component in the appropriate user hooks in the Setup.hs
06:29:02 <greed_> ah...
06:29:14 <greed_> oh i see
06:29:20 <unnali> Peaker, mauke: I'm quite lost.
06:29:26 <greed_> the modifications don't persist past the phase?
06:29:28 <dcoutts_> greed_: but note that changes you make to the package description (including the buildinfo within) in hooks is not persistent, so you should use the same modifier function in each hook, configure, build etc
06:29:39 <greed_> :)
06:29:42 <greed_> thanks, I'll try that
06:29:49 <Peaker> unnali, Since "MkT" can take any value in the world and built a T out of it, that means that given a T, the content is of some unknown type, rather than of some polymorphic type
06:30:04 <Peaker> unlink, MkT :: forall a. a -> T     unT :: exists a. T -> a
06:30:19 <hpaste_> mauke annotated “not quite the Map I foresaw” with “not quite the Map I foresaw (annotation)” at http://hpaste.org/69934#a69935
06:30:28 <mauke> unnali: ^
06:30:32 <unnali> a-ha.
06:30:54 <unnali> that would be why I failed to cast it. :)
06:31:05 <HairyDude> if you have a value MkT foo, you know nothing at all about foo
06:31:20 <unnali> and because I had my case and cast backwards.
06:31:35 <unnali> HairyDude: intentional; was trying to use Data.Typeable.cast for fun.
06:31:45 <Peaker> unnali, adding (:: type) at the end is an "annotation", not a cast
06:31:53 <Peaker> unnali, it can specialize a type, but it cannot change it
06:32:06 <Peaker> oh sorry, you did use "cast" :)
06:32:12 <unnali> yeah, I meant cast as in Typeable's
06:32:37 <Peaker> unnali, ah, you had two problems, the "cast" was outside of the "case", so the "exists a." qualifier escaped the case stmt
06:32:41 <unnali> mauke: thanks! That's what I was trying to achieve, though I now know I'm thoroughly confused by existential and universal quantification, even moreso than before this.
06:32:43 <Peaker> unnali, and the lack of Typeable constraint
06:32:47 * unnali nods.
06:33:10 <greed_> dcoutts_: yep, that was my mistake, thank you for the hint :)
06:33:17 <unnali> I probably need to re-read this a bit. (but at any rate, this might be … closer … to what d-snp was wanting .. maybe ;))
06:33:26 <unnali> s/this/on quantification/
06:33:31 <greed_> Have a nice day, everyone ^_^
06:33:32 <Peaker> unnali, it may be helpful to think of "forall" as a function from types.  And "exists" as a tuple of type and..
06:34:16 <Peaker> unnali, data T = forall a. MkT a        is actually:   data T = MkT (a :: *, x :: a)
06:34:19 <HairyDude> never managed to follow the explanation of why "forall" is used to mean "exists"
06:34:37 <Peaker> HairyDude, the "forall" does not mean exists..
06:35:19 <Peaker> HairyDude,   forall bear.  not (bear is black)    is the same as:   not (exists bear. bear is black)
06:35:22 <unnali> Peaker: I'm guessing the asterisk there is meaning a wildcard type and not the kind "*")
06:35:36 <unnali> wait, possibly wrong or the same thing!
06:35:45 <Peaker> unnali, "*" is the kind *
06:35:46 <HairyDude> Peaker: where's the not in the declaration of T?
06:35:58 <unnali> Peaker: yeah, I just realised that the two things as I meant them are somewhat equivalent.
06:36:28 <hilhil> unnali: I *think* the point is that MkT is a function from _any_ type to a T .
06:36:29 <Peaker> HairyDude, well, "not" is just an example here.  A "forall/exists" in different nesting levels means different things.   So a "forall" outside a data constructor means the *constructor* is polymorphic. Which means the value in it is anti-polymorphic, you can't know what's put inside
06:36:36 <hilhil> (Rather than a function from some type to a T)
06:36:49 <hilhil> Is that right?
06:37:02 <unnali> hilhil: that works for me (and gels with Peaker's most recent comment hence to HairyDude)
06:39:02 <Peaker> HairyDude, do you know about covariant/contravariant?  It's useful to see that a type in a covariant position is given to you, so you're forced to work with it (you don't get to choose it), whereas a type in the contravariant position is polymorphic, you choose whatever type works for you.  "forall" is contra-variant (type->), and "exists" is covariant (type,)
06:39:51 <Peaker> and when you're writing the body of a value that is polymorphic, you've got the given type in scope, so it's covariant in your context, so to you it is like an existential (GHC calls it "rigid type variable" I think)
06:40:36 <Peaker> maybe "existential" would have been clearer as "anti-polymorphic"?
06:40:52 <HairyDude> I know what "contravariant" means in category theory, but not what "contravariant position" means
06:40:58 <mauke> semimorphic?
06:42:13 * hackagebot ListLike 3.1.5 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-3.1.5 (JohnLato)
06:42:42 <Peaker> HairyDude, ((a -> b) -> (c -> d))       covariant: a,d,  contravariant: b,c
06:43:11 <Peaker> HairyDude, intuitively, covariant is "given out", and contravariant is "taken in"
06:43:53 <HairyDude> hm... I suppose you could think of "forall a. MkT a" as being a function that takes a type a and returns "MkT a", so once you have a value "MkT x", you know x has a type but not what
06:44:15 <Peaker> HairyDude, yeah, that's exactly it
06:44:27 <Peaker> having a type but not knowing what it is, that's "exists a . ..."
06:44:49 <Peaker> so if the constructor is universal/forall'd, that means the contents inside it are existential
06:46:07 * unnali feels a tad brighter.
06:46:59 <HairyDude> Peaker: is this legal: data T = MkT (forall a. a)
06:47:15 <mauke> yes, but fairly useless
06:47:25 <Peaker> HairyDude, yes (with some GHC extensions), but it is not usable except with _|_
06:47:26 <mauke> the only value of type forall a. a is _|_
06:47:31 <HairyDude> right.
06:48:15 <Peaker> btw, data T = forall a. MkT a     is also useless, as mauke said earlier, because   (exists a. a) is isomorphic to ()
06:49:35 <HairyDude> Peaker: what does an inhabitant of (exists a. a) look like?
06:49:52 <Peaker> HairyDude, any value of any type is an inhabitant of that
06:50:12 <Peaker> so you don't know of anything in common to all these types, so there's nothing useful you can do with it
06:50:16 <HairyDude> Peaker: but they are all indistinguishable?
06:50:39 <mauke> HairyDude: "hey, here's a value and it has some type. have fun!"
06:50:50 <mauke> and I'm all like "what"
06:50:50 <hilhil> my cabal build has become really slow, and reinstalling didn't fix it...
06:50:58 <hilhil> It prints
06:50:59 <hilhil> Preprocessing executable 'postparse' for postparse-0.0.1...
06:51:05 <hilhil> And then spends ages before running the type checker
06:51:10 <HairyDude> how do you tell the difference between _|_ : exists a. a and the value of that type that isn't _|_ ?
06:51:22 <hilhil> It's very frustrating as it means that Leksah isn't really usable...
06:51:27 <hilhil> Anyone have any idea what might be causing it?
06:51:30 <Peaker> HairyDude, if you had:   exists a. (a, a -> a, a -> String)   you could do something with it,  but that too is just equivalent to (Int -> String)
06:51:47 <mauke> HairyDude: in general you can't detect _|_
06:51:50 <mauke> because infinite loops
06:51:53 <ski> HairyDude : "but they are all indistinguishable?" -- yes (apart from being able to semi-distinguish `_|_' from non-`_|_' values with `seq'/strictness patterns)
06:51:53 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
06:51:55 <Peaker> HairyDude, in general, you can't tell the difference between _|_ and non-_|_
06:52:01 <ski> @messages
06:52:01 <lambdabot> tgeeky said 2d 21h 33m 56s ago: Did you ever figure anything out about Moufang loops in Haskell?
06:52:10 <Peaker> (or rather, you'll have false negatives)
06:52:15 * hackagebot fb-persistent 0.1.3 - Provides Persistent instances to Facebook types.  http://hackage.haskell.org/package/fb-persistent-0.1.3 (FelipeLessa)
06:52:49 <hilhil> In fact, what on earth does the preprocessor even do?
06:54:23 <ClaudiusMaximus> aarg. frustrations - source code says instance MonadIO IL; documentation says instance MonadIO IL; ghci errors with no instance MonadIO IL - turns out ghci is using transformers-0.3  but  repa-devil has a <0.3 upper bound so its MonadIO is a different MonadIO to ghci :-[
06:54:31 <ski> Peaker : false negatives ?
06:55:10 <Peaker> or rather _|_'s in the detection :)
06:55:48 <ski> if it's not `_|_', then you can detect it. if it is, then you don't detect it
06:56:04 <ski> (hence *semi*-distinguish)
06:56:39 <_Vi> ":t (4 :: Data.Word.Word8)"   leads to    GHC.Word.Word8. What is the difference between Data.Word and GHC.Word? What to write in the source code?
06:56:52 <Peaker> ClaudiusMaximus, I hate upper-version constraints
06:56:57 <Peaker> they're almost always wrong
06:57:23 <Peaker> and a bad compilation against a too-new version is easier to detect/fix than all the butterfly deps problems resulting from upper constraints
06:57:25 <ski> _Vi : `GHC.Word' is (i think) the implementation in GHC of `Data.Word' -- use the latter for more portability
06:58:29 <Peaker> ClaudiusMaximus, a good workaround for now is using a modern cabal-install that refuses to reinstall, detecting who had the faulty upper constraints and remove them
06:59:11 <_Vi> How given "GHC.Word" can I know that it I actually should use "Data.Word"? Is there a command (like ":t") that gives standard type?
07:00:09 <_Vi> Even on page http://hackage.haskell.org/packages/archive/base/3.0.3.2/doc/html/GHC-Word.html I don't see any note like "This is GHC's implementation of Data.Word".
07:00:12 <Peaker> _Vi, you can use :i Data.Word.Word and :i GHC.Word.Word
07:00:39 <unnali> night all! Thanks for much elucidation. :)
07:01:36 <_Vi> ":i Data.Word.Word" shows me "GHC.Word.Word". But ":i GHC.Word.Word" does not show me anything about "Data.Word.Word"...
07:01:54 <Peaker> _Vi, well, that's enough to establish they're the same
07:01:56 <hilhil> Are there cabal user directories somewhere (on Windows)?
07:02:02 <Peaker> Data.Word is basically a synonym for GHC.Word
07:02:06 <hilhil> I'd like to clean them out and see if things speed up again
07:02:23 <HairyDude> hilhil: %APPDATA%\cabal
07:02:26 <ski> _Vi : afaik, unfortunately not -- if you use `:i' then you can assume that the one which the other is implemented as is the implementation-detail, which you shouldn't use
07:02:37 <hilhil> thanks
07:02:37 <ingolfur> l
07:02:43 <unnali> ingolfur: j
07:02:56 <_Vi> Peaker, If I know about "Data.Word" then yes. But if I only seen "GHC.Word" (for example, by looking at ":t Data.ByteString.Lazy.head") I can't easily know that it is actually "Data.Word".
07:03:13 <ski> _Vi : imo it ought not even mention `GHC.Word' (except perhaps in a comment in the `:i' command), unless you have imported that module
07:03:31 <hilhil> Can I just wipe the contents of that directory?
07:04:03 <ski> HairyDude : re `data T = forall a. MkT (Foo a)', the idea is that for every type `a', `MkT' has type `Foo a -> T', i.e. `MkT :: forall a. Foo a -> T' -- so `MkT' can be thought of as a function that takes a type `a' (implicitly) and a value of type `Foo a' and gives a value of type `T'
07:04:04 <HairyDude> right, so "yesod devel" doesn't work (it just hangs while running cabal)... but building with cabal and runnign directly is fine
07:04:12 <Peaker> _Vi, yeah, :i is not perfect
07:04:23 <Peaker> _Vi, There's no notion of "canonical name for .."
07:04:40 <HairyDude> ski: ahh, that makes a lot of sense
07:04:44 <ski> HairyDude : so when you match on such a value, you only know that there's *some* type `a' such that the data constructor argument has type `Foo a' (but you don't know what this type `a' is)
07:04:46 <_Vi> May be at least documentation should mention "canonical name for ..."?
07:05:42 <ski> HairyDude : iow, `MkT :: forall a. (Foo a -> T)' is basically the same as `MkT :: (exists a. Foo a) -> T' (in which `MkT' conceptually takes a *pair* of a type `a' and a value of type `Foo a' -- though the type is of course "passed implicitly")
07:05:58 <_Vi> Peaker, So what to use to prevent type information detouring me from standard types to GHC ones? (like in ":t Data.ByteString.Lazy.head")
07:06:14 <ski> HairyDude : meaning that when you unpack `T' you conceptually get something of type `exists a. Foo a' -- hence the name "existential data type"
07:06:53 <Peaker> _Vi, perhaps the haddocks are better?
07:07:16 * hackagebot iteratee 0.8.9.0 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.9.0 (JohnLato)
07:07:35 <_Vi> What is a haddock? (Google mentions a fish).
07:08:01 <ski> HairyDude : however, consider the situation with two constructor arguments : `data T = forall a. MkT (Foo a) (Bar a)' -- here the type signature is `MkT :: forall a. Foo a -> Bar a -> T', where we can't make this rewriting into `exists' -- but if we change the constructor from a curried one to a tupled one, then we get `data T = forall a. MkT (Foo a,Bar a)' and then we can think of this as giving `MkT :: (exists a. (Foo a,Bar a)) -> T'
07:08:33 <Peaker> _Vi, Haddock is the Haskell documentation tool, and the resulting docs (e.g: the package docs on hackage)
07:08:52 <ski> HairyDude : in any case, even in the curried constructor situation we name this an "existential data type" since it's basically the same thing which happens
07:09:04 <_Vi> Is http://hackage.haskell.org/packages/archive/base/3.0.3.2/doc/html/GHC-Word.html part of this "Haddock"?
07:09:45 <Peaker> _Vi, those are GHC.Word's haddocks, yeah
07:09:56 <ski> HairyDude : a final note : it's really the data constructor, not the type itself, which has the existential quantification; consider `data Expr a = Val a | forall b. App (Expr (b -> a)) (Expr b)'
07:09:59 <_Vi> Peaker, And I see no cues about "Data.Word" there.
07:10:10 <HairyDude> ski: yeah, I get it now
07:10:26 <Peaker> _Vi, http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/Data-ByteString.html#v:unpack
07:10:43 <Peaker> _Vi, if you follow the haddocks rather than :i from there, it leads you to Data.Word, and no GHC. stuff
07:11:34 <_Vi> Peaker, OK. Should I mistrust ":i" only when get "GHC.Whatever" or by default?
07:12:04 <HairyDude> ski: actually, you can see it in agda where the type constructor for sigma types has the type signature A -> P A -> Sigma A P (for given A and P)
07:12:33 <HairyDude> s/type constructor for sigma types/constructor for values of sigma types/
07:13:08 <ski> HairyDude : actually `(a : A) -> P a -> Sigma A P', but yes :)
07:13:17 <HairyDude> doh, yes
07:14:53 <Peaker> _Vi, The info at :i is trust-worthy, but it exposes implementation details. So it's useful, but don't use it to discover how to import/use stuff, just how stuff works
07:15:10 <Peaker> _Vi, The Haddocks help you figure out how to use,  :i helps you figure out how it works
07:15:59 <_Vi> Peaker, OK, now I understood. So auto-inserting type information for functions based on ":t" is not a good idea.
07:16:07 * ski . o O ( `data _And_ (A : Set) (B : {_ : A} -> Set) : Set where Pair : (a : A) -> B {a} -> A And B' )
07:17:16 * hackagebot bits-conduit 0.1.0.0 - Bitstream support for Conduit  http://hackage.haskell.org/package/bits-conduit-0.1.0.0 (HideyukiTanaka)
07:17:18 * hackagebot bson 0.2.0 - BSON documents are JSON-like objects with a standard binary  encoding.  http://hackage.haskell.org/package/bson-0.2.0 (FedorGogolev)
07:17:20 * hackagebot repa-devil 0.3.2 - Support for image reading and writing of Repa arrays using in-place FFI calls  http://hackage.haskell.org/package/repa-devil-0.3.2 (RaphaelJavaux)
07:17:22 * hackagebot mongoDB 1.3.0 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-1.3.0 (FedorGogolev)
07:18:03 <Peaker> _Vi, not always. If you get types like "GHC" or "Internal" then usually you have to work to find the canonical name of these. Haddocks of the reasons these types showed up are a good place to start
07:22:17 * hackagebot ClassLaws 0.3.0.1 - Stating and checking laws for type class methods  http://hackage.haskell.org/package/ClassLaws-0.3.0.1 (PatrikJansson)
07:27:55 <hilhil> Does the Haskell platform store anything that's not removed by uninstalling it? (Other than in the APPDATA/cabal directory)
07:28:36 <hilhil> I'm just about to reinstall it for the fourth time...
07:28:54 <hilhil> And something seems to be persisting across uninstalls
07:28:57 <dcoutts_> there's also the appdata/ghc dir I think
07:29:07 <hilhil> right -- thanks
07:29:10 <dcoutts_> for the per-user ghc-pkg dir
07:29:22 <dcoutts_> I assume that's where it is on windows anyway
07:29:25 <dcoutts_> ghc-pkg list will tell you
07:29:30 <hilhil> Well, there was something there, and I deleted it
07:32:06 <_Vi> Is there already function like this: "iterateUntilNothing :: (a->Maybe a) -> a -> [a]"? Can't find such signature on Hoogle.
07:32:22 <illissius> @hoogle unfold
07:32:23 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
07:32:23 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
07:32:23 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
07:32:24 <applicative> @type unfoldr
07:32:25 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
07:34:26 <applicative> @type fmap (\x-> (x,x)) (Just 17)
07:34:27 <lambdabot> forall a. (Num a) => Maybe (a, a)
07:34:36 <applicative> @type fmap (\x-> (x,x)) Nothing
07:34:37 <lambdabot> forall a. Maybe (a, a)
07:34:46 <applicative> > fmap (\x-> (x,x)) Nothing
07:34:47 <lambdabot>   Nothing
07:34:57 <applicative> > fmap (\x-> (x,x)) (Just 17)
07:34:58 <lambdabot>   Just (17,17)
07:36:31 <applicative> @type let iterateUntilNothing f = unfoldr (fmap (\x->(x,x)) f) in iterateUntilNothing
07:36:32 <lambdabot>     Couldn't match expected type `Maybe (a, b)'
07:36:32 <lambdabot>            against inferred type `(a1, a1)'
07:36:32 <lambdabot>     In the expression: (x, x)
07:36:47 <S11001001> > join (,) . Just 17 -- :)
07:36:49 <lambdabot>   Just (17,17)
07:36:54 <applicative> where'd i go wrong... the lights are growing dim
07:37:05 <applicative> ah indeed join (,)
07:38:50 <applicative> @type let iterateUntilNothing f = unfoldr (fmap (\x->(x,x)) . f) in iterateUntilNothing -- forgot to compose
07:38:51 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
07:40:47 <_Vi> Thanks. Actually this iterateUntilNothing was part of 'unfoldr' reimplementation.   {- newbie -}
07:45:08 <jonash> Hi everyone! Taking my first steps in Haskell. Could anyone help me with this error? http://dumpz.org/217118/ http://dumpz.org/217117/
07:47:19 <rwbarton> jonash: search takes a Maybe (BinaryTree a), so on line 10 the non-Nothing case ought to be Just (Branch left x right)
07:47:28 <HugoDaniel> yeah
07:48:06 <HugoDaniel> you could also use a case instead of pattern matching, im not really sure what would be the difference though
07:48:13 <HugoDaniel> besides syntax
07:48:40 <merijn> I feel like I'm writing "maybe (return ()) (some lambda)" a lot, is there a better/cleaner option?
07:48:43 <jonash> rwbarton: thanks... already tried that, now ghc complains about the equations having different arguemtn count
07:48:52 <rwbarton> probably you didn't use enough parentheses
07:49:28 <HugoDaniel> merijn: fmap ?
07:49:40 <rwbarton> "search Just (Branch left x right) needle" would be three arguments
07:49:43 <jonash> HugoDaniel: sure. I'm still struggling with Haskell syntax and pattern matching worked for me. Haskell was way too much syntax :)
07:49:44 <rwbarton> if that's what you wrote
07:50:13 <merijn> HugoDaniel: The return is not for Maybe
07:50:28 <merijn> HugoDaniel: Essentially I'm doing when with a Maybe input
07:50:47 <rwbarton> merijn: you can use Traverable's mapM_
07:51:00 <jonash> rwbarton: yeah it doesn't work. http://ideone.com/3DAGC
07:51:00 <merijn> :t Traversable.mapM_
07:51:01 <lambdabot> Couldn't find qualified module.
07:51:09 <merijn> :t mapM_
07:51:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
07:51:13 <rwbarton> jonash: read what i just said
07:52:18 <Peaker> :t Data.Traversable.mapM_
07:52:19 <lambdabot> Not in scope: `Data.Traversable.mapM_'
07:52:23 <applicative> jonash: you need brackets http://ideone.com/Y3zXl  like rbarton said
07:52:33 <rwbarton> oh yeah, i guess the mapM_ version is in Foldable
07:52:43 <rwbarton> since it doesn't produce a result
07:52:46 <applicative> jonash: now there is a new problem though :)
07:52:49 <rwbarton> , Traversable is not needed
07:52:50 <merijn> :t Data.Foldable.mapM_
07:52:51 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
07:52:59 <jonash> rwbarton: sorry, didn't catch the "between the lines" advice to put parens around (Just ... )
07:53:32 <hilhil> Hmmm... turns out the trick to getting Leksah to run fast is to make it use ghci rather than ghc
07:53:53 <hilhil> (He says after reinstalling Haskell + Leksah 4 times)
07:54:27 <merijn> rwbarton: Thanks, I guess that works. Althought I'm not sure it improves readability. I might just implement my own function as "flip $ maybe (return ())" and use it like when
07:57:07 <jonash> applicative: yeah I basically need to say that a can only be of Ord + Eq. this works but is it idiomatic? http://ideone.com/TWLIV (I guess this syntax has been introduced in Haskell > 6.8 because it fails to compile on ideone?)
07:57:45 <applicative> the constraints are a comma separated list (Ord a, Eq a) =>
07:58:16 <ski> jonash : what applicative said, but since `Ord a' implies `Eq a', you only need to say `Ord a =>
07:58:19 <ski> '
07:58:24 <applicative> jonash but doesnt Ord entail E
07:58:26 <applicative> ...
07:58:45 <nand`> it does
07:58:46 <applicative> like ski said
07:59:02 <ski>   search :: Ord a => Maybe (BinaryTree a) -> a -> Maybe (BinaryTree a)  -- i.e.
07:59:05 <jonash> right
07:59:21 <ski> (note that i removed the redundant brackets around the `Maybe' calls there)
08:00:15 <ski> jonash : is there a reason you use `Maybe' in the definition of `BinaryTree' instead of having an alternative `Tip' constructor for an empty tree ?
08:00:23 <applicative> jonash, dont worry about excessive brackets, they go away with experience. HLint is really  good at pointing out where you dont need them.
08:00:50 <ski> (since you seem to be passing `Maybe (BinaryTree a)' anyway, so you have the possibility for emptiness there anyway, in that piece of code)
08:01:00 <jonash> ski: had that before but didn't know how to express a branch with only one leave
08:01:04 <jonash> *leaf
08:01:22 <ski> jonash : like `Branch leftTree element Tip' e.g.
08:01:47 <jonash> yeah but an empty tree isn't actually a tree
08:01:53 <ski> (where `Tip' is the empty tree and `leftTree' is some (presumably non-empty) sub-tree)
08:02:00 <ski> jonash : why not ?
08:02:30 * ski frowns on unfair discrimination against empty cases
08:02:50 <applicative> jonash, here is hlint pointing out  the unneeded brackets ski mentioned  http://hpaste.org/69939
08:03:08 <jonash> applicative: thx
08:03:13 <ski> an empty list is a list, an empty bag is a bag, an empty document is a document, an empty purse is a purse
08:03:25 <jonash> ski: yeah seems like I confused the definition
08:03:44 <ski> applicative : missing `|'s
08:03:48 <jonash> although I believe to remember some definitions where empty trees aren't actually trees
08:04:03 <ski> applicative : er, forget what i said. misread
08:04:15 <applicative> the second was a different and more important point....
08:04:43 <ski> jonash : yes. however imo you should normally include empty cases unless you have a specific reason not to
08:04:52 <jonash> right
08:05:33 <ski> jonash : in this case, including the empty case seems to simplify the code somewhat, without leading to extraneous generality, afaics
08:05:52 <ski> (simplify because the `Maybe',`Nothing',`Just' disappears)
08:05:55 <HairyDude> @hoogle (Read a) => Text -> a
08:05:56 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:05:56 <lambdabot> Prelude id :: a -> a
08:05:56 <lambdabot> Data.Function id :: a -> a
08:05:58 <HairyDude> hm
08:06:39 <ski> (well, not the `Maybe' in the result of `search' i suppose, since you still want to be able to express the search failing)
08:06:46 <jonash> yep
08:07:14 <ski> jonash : btw, instead of using `==' and `<', i'd use `compare'
08:07:20 <applicative> HairyDude: I dont recommend unsafeCoerce for that... :)
08:07:24 <HairyDude> hehe
08:07:45 <HairyDude> @hoogle String -> Text
08:07:46 <lambdabot> Data.Text.Lazy pack :: String -> Text
08:07:46 <lambdabot> Data.Text pack :: String -> Text
08:07:46 <lambdabot> Prelude read :: Read a => String -> a
08:08:03 <jonash> ski: yeah saw that but it looked kindof ugly
08:08:08 <jonash> dunno why, just a feeling
08:08:09 <applicative> dont you want the other way, first unpack then read
08:08:23 <ski>   search (Just t@(Branch left x right)) needle = case needle `compare` x of
08:08:33 <ski>     LT -> search left  needle
08:08:41 <ski>   EQ -> Just t
08:08:47 <applicative> readT = read . T.unpack
08:08:48 <ski>     GT -> search right needle
08:08:51 <ski> something like that
08:08:55 <illissius> There are two hard problems in computer science: cache invalidation and naming things, and I'm not sure about cache invalidation.
08:09:34 <HairyDude> @hoogle (<$>)
08:09:34 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
08:09:34 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
08:10:07 <ski> jonash : the `t@' names the whole current tree `t', so that you don't have to retype `Branch left x right' in the `EQ' case (and more importantly, so can see immediately it's the same tree, without having to scan and compare, when reading it)
08:10:43 <ski> jonash : fwiw, i'd also flip the order of the arguments to `search' ..
08:11:38 <applicative> HairyDude: I suppose you noticed Data.Text.Read has some functions for number types
08:11:46 <HairyDude> it does?
08:12:15 <HairyDude> not that I'm actually interested in that, I was more hoping to avoid manually writing CustomDataType -> Text
08:12:29 <HairyDude> pity there's no derivable Text version of Read
08:12:52 <applicative> they are like so type Reader a = Text -> Either String (a,Text)
08:13:11 <applicative> ah I see
08:14:15 <HairyDude> applicative: calling it Reader is rather unfortunate...
08:17:31 <applicative> HairyDude: Where are you getting these Text representations of Haskell values?
08:18:01 * ski doesn't like the `String' there ..
08:18:20 <HairyDude> applicative: part of a URL (using maybeRead, so it fails gracefully)
08:32:21 * hackagebot word24 1.0.3 - 24-bit word and int types for GHC  http://hackage.haskell.org/package/word24-1.0.3 (JohnLato)
08:32:23 * hackagebot splaytree 0.1.3 - Provides an annotated splay tree  http://hackage.haskell.org/package/splaytree-0.1.3 (JohnLato)
08:33:41 <jonash> is there any equivalent to running map against a heterogenous list? like (map show [1, "hi"])
08:35:23 <namor> "Safe Haskell itself is aimed to be as minimal as possible while still providing strong enough guarantees about compiled Haskell code for more advance secure systems to be built on top of it. These include techniques such as information flow control security or encrypted computations." <- from the safe haskell page on haskell.org
08:35:48 <namor> ^ do i get that right: safe haskell is meant to be used as a basis for implementing information flow control security?
08:36:14 <namor> (not solely of course)
08:36:33 <byorgey> jonash: no, not without complicated, dirty tricks.
08:36:48 <ski> jonash : do you have any specific application in mind ?
08:36:58 <mzero> igloo, dcoutts - are we going to move the Haskell Platform to lambda?
08:37:22 * hackagebot cabal-debian 1.24 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-1.24 (DavidFox)
08:37:42 <mzero> d'oh - wrong channel - that was meant for #ghc
08:38:01 <jonkri> i'm a little confused about the operator precedence of readsPrec. what is that for?
08:38:01 <namor> me?
08:38:14 <namor> ah, i guess my question goes #ghc too
08:38:27 <luite> namor: the idea is that safe haskell allows code that doesn't let you to naughty things with the types (like unsafeCoerce) or runtime system (unsafe writes). you can build your higher level security on top of it if you can encode your security in the types then
08:38:55 <ski> jonash : it's similar to `showsPrec'
08:39:04 <unlink> I'm having trouble thinking of a better way to write this function  http://paste.lisp.org/display/130037
08:39:23 <namor> luite, looks promising. i have to do smth like that as a bachelor thesis, and im thinking of using safe haskell for it
08:39:24 <unlink> It's almost identical to Data.List.select
08:39:29 <ski> > showsPrec 7 (2%3) ""
08:39:30 <lambdabot>   "2 % 3"
08:39:31 <ski> > showsPrec 8 (2%3) ""
08:39:32 <lambdabot>   "(2 % 3)"
08:39:59 <ski> > (readsPrec 7 :: ReadS Rational) "2 % 3"
08:40:00 <lambdabot>   [(2 % 3,"")]
08:40:01 <ski> > (readsPrec 8 :: ReadS Rational) "2 % 3"
08:40:02 <lambdabot>   []
08:40:03 <ski> > (readsPrec 7 :: ReadS Rational) "(2 % 3)"
08:40:03 <lambdabot>   [(2 % 3,"")]
08:40:05 <ski> > (readsPrec 8 :: ReadS Rational) "(2 % 3)"
08:40:05 <lambdabot>   [(2 % 3,"")]
08:40:08 <ski> jonash ^
08:40:15 <jonkri> hmm...
08:40:30 <mzero> unlink:
08:40:32 <mzero> write it
08:40:53 <mzero> (if p then first else second) (x:)
08:41:04 <mzero> unlink - you must ahve missed my rewrite of your function
08:41:10 <unlink> (My ultimate goal is to write something like partition, except of type  (a -> f Bool) -> [a] -> f ([a], [a]))
08:41:16 <ski> jonash : the idea is to be able to read values which are encoded as strings representing operators with certain precedences, lacking or not lacking brackets
08:41:22 <mzero> unlink: http://hpaste.org/69915
08:41:38 <jonash> ski: are you sure you're not talking to jonkri
08:41:51 <ski> hum, so i ought to be
08:41:57 <ski> jonkri ^
08:42:53 <illissius> Is there any kind of general algorithm or heuristic to figure out what precedence is best for your operators to have? (If the operator can't be chained then fixity is meaningless right?)
08:43:34 <unlink> mzero: thanks. let me study that.
08:44:17 <jonkri> > (readsPrec 8 :: ReadS Rational) "2 % 3"
08:44:18 <lambdabot>   []
08:44:20 <jonkri> what happens to the result there?
08:44:39 <HairyDude> why is ghc saying "The import of <foo> is redundant"?
08:44:57 <applicative> @type \p x -> (if p  x then first else second) (x:)
08:44:58 <lambdabot> forall a. (a -> Bool) -> a -> ([a], [a]) -> ([a], [a])
08:45:20 <ski> jonkri : for `Ratio' i'd be something like `instance Read a => Read (Ratio a) where readsPrec p = readParen (p > 7) $ \s0 -> [(n % d,s) | (n,s1) <- readsPrec 7 s0 , ("%",s2) <- lex s1 , (d,s) <- readsPrec 8 s2]'
08:46:19 <fmap> HairyDude: because imported <foo> isn't used anywhere
08:46:31 <HairyDude> ah
08:46:58 <unlink> mzero: the reason I defined prompt that way before is so that entering nothing would yield True (and thus the default was a safe operation)
08:47:10 <ski> jonkri : the `8' there tells the `readsPrec' call that this sub-expression `2 % 3' occurs with precedence level `8' (as the argument of some operator), so that brackets are required
08:47:30 <hilhil> :t dropWhile isSpace . reverse  . dropWhile isSpace . reverse
08:47:30 <rwbarton> > 2 % 3 % 4
08:47:31 <lambdabot> [Char] -> [Char]
08:47:31 <lambdabot>   No instance for (GHC.Real.Integral (GHC.Real.Ratio t))
08:47:31 <lambdabot>    arising from a us...
08:48:00 <tac-tics> @type (%)
08:48:01 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
08:48:14 <tac-tics> > 0 % 0
08:48:15 <lambdabot>   *Exception: Ratio.%: zero denominator
08:48:20 <MostAwesomeDude> :t Data.Text.strip
08:48:21 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text
08:48:25 <MostAwesomeDude> hilhil: ^^
08:48:36 <ski> > (reads :: ReadS Rational) "0 % 0"
08:48:37 <lambdabot>   [(*Exception: Ratio.%: zero denominator
08:48:41 <hilhil> Except then I have to pack/unpack...
08:48:55 <ski> interesting that that parses
08:49:23 <hilhil> (But thanks for the suggestion)
08:50:09 <MostAwesomeDude> :t takeWhile (not isSpace) . dropWhile isSpace
08:50:10 <lambdabot>     Couldn't match expected type `Bool'
08:50:11 <lambdabot>            against inferred type `Char -> Bool'
08:50:11 <lambdabot>     In the first argument of `not', namely `isSpace'
08:50:20 <MostAwesomeDude> :t takeWhile (not . isSpace) . dropWhile isSpace
08:50:20 <lambdabot> [Char] -> [Char]
08:50:31 <MostAwesomeDude> Avoids reverse. ^^
08:51:04 <MostAwesomeDude> Although, now that I think about it, that won't work right.
08:51:08 <MostAwesomeDude> Never mind!
08:51:55 <hilhil> The problem seems to be that there isn't a String version of dropWhileEnd
08:51:59 <hilhil> (Presumably because it's inefficient)
08:52:09 <MostAwesomeDude> Yeah.
08:52:16 <ibt> someone made the claim that all values in haskell are unapplied (partially applied) functions. this sounds wrong to me, but can someone say for sure?
08:52:22 <MostAwesomeDude> OTOH if you're doing lots of string handling, Data.Text is your friend so hard.
08:52:38 <MostAwesomeDude> So it might be worth it to do the transformation to Text.
08:52:43 <MostAwesomeDude> IIRC it's not spendy.
08:52:55 <hilhil> This is just for processing of commandline arguments.
08:53:02 <hilhil> All the file IO is happening via Data.Text
08:53:05 <Saizan> ibt: it's not a popular (or useful imo) point of view
08:53:12 <Philippa> ibt: it's BS. What is true is that you can produce an encoding into (say) the pure lambda calculus where that's true
08:53:17 <rwbarton> ibt: ultimately it is a matter of terminology
08:53:25 <rwbarton> but certainly not any value can be applied
08:53:36 <ibt> okay, but when you're trying to actually get stuff done, it isn't useful, right?
08:53:46 <Philippa> there are various other implementation strategies where that's true of the implementation's idea of 'function' too
08:53:47 <Saizan> they were likely referring to laziness
08:53:53 <MostAwesomeDude> hilhil: Hm. Considered actually using an argument parsing library?
08:53:56 <jonkri> ski: why can't "(readsPrec 8 :: ReadS Rational) "2 % 3"" not be successfully parsed?
08:53:58 <Philippa> ibt: in Haskell terms, it's just plain not true
08:54:07 <jonkri> s/can't/can
08:54:23 <hilhil> MostAwesomeDude: I suspect what I'm doing wouldn't be handled by a library terribly well...
08:54:32 <hilhil> I'm passing in strings like
08:55:05 <Philippa> Saizan: yeah, it's common to talk about thunks as C-functions (or equivalent) that haven't been run yet
08:55:06 <hilhil> "chart_input $wd/alms.cf_rules; filter_caps $wd/symbolic_categories.txt; filter $wd/filters.txt; recfilter $wd/recursivefilters.txt; filter_implication_lists; filter_an; filter_flow $wd/alms.cf_flow"
08:55:11 <MostAwesomeDude> Guh.
08:55:13 <MostAwesomeDude> Yeah, okay.
08:55:16 <hilhil> And then those are being broken into sections by ; s
08:55:21 <Philippa> ibt: you've probably had too much information here - was it useful?
08:55:31 <ibt> Philippa: do you know of a place with diagrams about how things like x :: Int; x = 4  is treated?
08:55:32 <hilhil> And then one picks out one Haskell function for each section and chains them together...
08:56:00 <Philippa> ibt: depends a bit on what you mean by "is treated", but I don't off-hand if you want diagrams
08:56:04 <MostAwesomeDude> hilhil: TBH I would just figure out the grammar of the string and then pass it to Parsec or whatnot.
08:56:08 <Philippa> I can talk you through drawing some though?
08:56:26 <ibt> Philippa: i always kind of thought of functions in haskell always taking one argument, and if they took anything more then it was a function that took an argument and returned a new function that took another (partially applied funcitons)
08:56:38 <Philippa> ibt: yep, that's entirely correct
08:56:45 <hilhil> I think that's overkill here -- just wanted an equivalent of Python strip()
08:56:52 <hilhil> But thanks for the suggestions!
08:57:03 <MostAwesomeDude> hilhil: Yeah, there's a reason why Python's my get-stuff-done language. :3
08:57:09 <Philippa> ibt: we don't bind /functions/ to variables though, we bind terms (or values, if you prefer, but I don't these days) to them
08:57:19 <Philippa> ibt: functions aren't the only terms or values :-)
08:57:50 <ibt> Philippa: it seemed useful to bind a constant to a name and then reference that all over since that will use the same memory, but maybe ghc can do that anyway? (say,.. if i referenced the number 4 all over a series of functions)
08:58:19 <hilhil> I'm pretty sure it's guaranteed that if you write
08:58:24 <hilhil> a = <long expression>
08:58:26 <hilhil> At the top level
08:58:31 <hilhil> Then that long expression will only be evaluated once
08:58:40 <Philippa> ibt: GHC actually doesn't do common subexpression elimination, because it turns out bad things can happen when it's combined with laziness
08:58:56 <rwbarton> bad things as in increased memory usage
08:58:57 <Philippa> but yes, if you write x=4 then it's x that gets shared
08:58:59 * applicative wonders, if haskell values are all partially applied functions, what do you get when you apply them fully?
08:59:10 <Philippa> applicative: a headache
08:59:27 <MostAwesomeDude> hilhil: Yes, it's called a Constant Applicative Form.
08:59:28 <HairyDude> how do you get log messages out of a yesod app if you're not using yesod devel? (which seems to be broken)
08:59:46 <hilhil> Ahhh... is that waht the CAFs there were coming out of my profiling referred to?
08:59:48 <ibt> Philippa: okay. thanks.
08:59:49 <MostAwesomeDude> Yes.
08:59:50 <illissius> woo! only one-and-a-half naming dilemma left. :d
09:00:05 <MostAwesomeDude> CAFs show up on profiling as one-time costs.
09:00:15 <Philippa> ibt: basically it just won't go "oh, you've used 4 lots" and lift 4 out and bind it to x in the optimisation pass
09:00:37 <tac-tics> Is there a page on the haskell wiki that lists the pros and cons of non-strict evaluation?
09:00:38 <Philippa> yeah, the tradeoff with CAFs is it's hard to let go of 'em
09:01:39 <applicative> tac-tics: we use robert harper for the cons, lennart a for the pros
09:01:42 <rwbarton> is 4 really an Applicative Form though? it looks more like a Literal Form. :)
09:01:55 <Philippa> rwbarton: :p subset thereof
09:01:58 <rwbarton> I wonder whether the fromInteger (4 :: Integer) stuff gets optimized away by GHC somehow
09:02:07 <Philippa> I'd assume so
09:02:12 <ski> jonkri : let's assume you've defined `infixl 8 :#; data Foo a = a :# a | ... deriving (Show,Read)', then if you do `let r = 6 % 8 in show (r :# r)' you get `"(3 % 4) :# (3 % 4)"' (for the left argument, `showsPrec' is called with `8', in the right argument, with `9')
09:02:26 <tac-tics> applicative: Exception: Unknown Reference at line 1.
09:02:51 <ibt> Philippa: can you clarify the difference between a term and a function? is it just that one is bound to a name and the other isn't?
09:03:09 <Philippa> ibt: do you mean a term and a value?
09:03:15 <Philippa> (functions being those things you can apply)
09:03:34 <ski> jonkri : if you then try to `reads' this, it works ok (`reads = readsPrec 0'), but if you try to `reads' `"3 % 4 :# 3 % 4"', it'll try to parse it as `3 % (4 :# 3) % 4', which won't work
09:03:39 <applicative> http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/  http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html <- tac tics
09:03:42 <ibt> Philippa: sorry, confused what you said.
09:03:45 <illissius> this has probably been asked a few times, but *why* are Constant Applicative Forms called Constant Applicative Forms? what's the connection between the name and the thing?
09:03:56 <Philippa> ibt: 'sokay :-)
09:04:03 <tac-tics> ibt: A term is any expression in the language. A function is an expression that has a particular kind of type (one with an arrow -> in it)
09:04:08 <tac-tics> applicative: danke
09:04:12 <Philippa> illissius: constant because they evaluate to a constant. Applicative form because they contain function applications
09:04:54 <Philippa> tac-tics: and the controversial statement would be /we never write values in source code/ :-)
09:04:54 <illissius> Philippa: Hmm, I see. Thanks.
09:05:06 <applicative> tac-tics: it was a tempest in a teapot a year or so ago.  there was no clear victory.  the last point of lennart conceded by harper does explain my experience that as soon as you go into an unrelently strict lan
09:05:20 <applicative> language, you turn into a moron or a compiler
09:06:05 <tac-tics> applicative: Was this a symposium or a debate or something?
09:06:18 <tac-tics> Or just some CS professor's internal angst incarnate? :)
09:06:18 <Philippa> a debate mostly on bob's blog
09:06:43 <kamaraj> hi..all
09:06:44 <ski> ibt : monochrom's <http://www.vex.net/~trebla/haskell/lazy.xhtml> might help somewhat
09:06:56 <applicative> no, Harper, whose blog is excellent was teaching SML and along the way dissing our language.
09:07:06 <tac-tics> Philippa: So serious Internet debate :P
09:07:14 <applicative> but the concession "As you know, in the eager world we tend to write out our own recursive functions, rather than use combinators." is basically of everything
09:07:16 <kamaraj> today just heard about this haskell. Is it very popular language ? in what domain it is used ?
09:07:28 <kamaraj> what kind of application, we can create using haskell ?
09:07:42 <Philippa> kamaraj: in the domain of "I'm fed up of impersonating a compiler to get anything done", which turns out to be wide-ranging :-)
09:07:58 <applicative> Philippa :)
09:08:05 <tac-tics> kamaraj: Haskell is useful for anything you might write in C++, IMO. It's the most popular "unpopular" language :)
09:08:10 <Philippa> our main compiler spits out binaries for *nix or windows, we've got a good foreign function interface so we can bind to libraries you could use from C
09:08:30 <Philippa> tac-tics: including many things you /might/ write in C++ but should really know better
09:08:46 <applicative> kamaraj what language do you usually use
09:09:15 <kamaraj> i am good in shell script, perl, sql and core java
09:09:25 <jonkri> ski: thanks for your patient and extensive explanations ;)
09:09:39 * ski casually impersonates an interpreter
09:09:39 <adimit> I want to efficiently *append* to a list — so I figured I'd use continuations. I define g k a = \b -> k (a:b), and I first call g id 'a', then save the result (in an STRef, since I have to insert elements from a mutable array.) Then when I have a new element, I call { k <- readSTref…; g k 'b' }, and in the end g k []. Is this idiotic? Is there a better alternative?
09:09:47 <tac-tics> Philippa: Kidding aside :) C++ seems "roughly on par" with Haskell in terms of computing power and use cases.
09:09:47 <illissius> you can use Haskell for basically anything, but have to be crazier than the usual to write a kernel.
09:10:01 <hilhil> Hmmm. *The* situation in which you should use C++ is if speed or memory usage are critical.
09:10:17 <Philippa> tac-tics: yeah. But the last C++er I ran into IRL didn't bother trying to defend the language, 'nuff said? :p
09:10:17 <hilhil> Indeed, the stated of design goal of C++ is to give you precise control over those.
09:10:27 <ski> jonkri : the precedence argument to `showsPrec' is the means for knowing whether certain expressions needs to be `show'n with explicit wrapping brackets or not
09:10:42 <hilhil> So I'm not keen on the 'useful for anything you might write in C++'
09:10:42 <tac-tics> Philippa: Emphasis on speed. It has a very "compiled" feel compared to Python or Ruby. Doesn't really grow into large corporate ecosystems like .NET languages or Java.
09:11:07 <hilhil> Haskell is a lot faster than e.g. Python but still considerably slower than C++
09:11:24 <tac-tics> In terms of what you might use them for, though, they are similar
09:11:24 <ski> jonkri : similarly, the precedence argument to `readsPrec' is the means for knowing whether it needs to require mandantory wrapping brackets or not, when reading values back in
09:11:25 <Philippa> hilhil: I'm not convinced of the latter these days if you're willing to go to equivalent lengths
09:11:27 <illissius> right. C++ if speed and resource usage are paramount, Haskell if safety and correctness and power and abstraction and etc. aren't of second-order importance relative to that.
09:12:02 <Ptival> adimit: adimit have you considered difference lists?
09:12:03 <hilhil> Phillippa: YMMV. Coming from a C++ background, I'm finding Haskell noticeably slow.
09:12:09 <applicative> kamharaj I would think its uses are most like those of java of the languages you mention, but of course the infrastructure isnnt nearly as elaborate
09:12:13 <kamaraj> i am from banking domain, so this language used in banking ?
09:12:21 <hilhil> Part of that is not even the language itself but the fact that e.g. the profiling tools are much more primitive than the ones I'm used to.
09:12:34 <applicative> kamaraj: yes,all our best masters have been sucked into finance...
09:12:36 <Philippa> hilhil: Sure. From a C++ background, what I'm finding is that fast Haskell looks almost as bad or worse than fast C++, but
09:12:46 <ski> adimit : `Endo [a]' ?
09:12:49 <adimit> Ptival: difference lists. Interesting, I know about them from Prolog, but never thought of them in Haskell.
09:12:50 <Philippa> agreed re tooling though
09:13:02 <HairyDude> now I'm getting link errors -_-
09:13:03 <illissius> though one of these days the ease of parallelizing haskell code vs. C++ might catch up with it.
09:13:09 <Philippa> (and if you really care about speed you want to learn to read core, which is slightly better than poking at asm output, but)
09:13:13 <adimit> ski: never heard of it. Checking it out, thanks.
09:13:19 <Ptival> adimit: AFAICS, it's not like in Prolog
09:13:34 <ski> adimit : note that "difference lists", as that name is used in Haskell, isn't exactly the same as the Prolog idea (though there is a similarity)
09:13:36 <applicative> kamaraj: of course it isnt superwidely used, but finance is one of the places
09:13:39 <Philippa> that said: my own C++ background was gamedev oriented - /which/ efficiency concerns you have varies considerably between domains
09:13:48 <lhk> hi
09:13:58 <applicative> hi lhk
09:14:12 <Ptival> adimit: http://hackage.haskell.org/packages/archive/dlist/0.5/doc/html/Data-DList.html
09:14:24 <hilhil> Philippa: for games, do not you find that the lack of direct control over the cache is a killer?
09:14:29 <adimit> Ptival, ski, I guess I'll have to read up on them then. I take it my initial idea is cumbersome/inefficient? It does kind of have this center-embedding property that makes it look like it'd waste a lot of space.
09:14:55 <Philippa> hilhil: I said my C++ background, not my haskell background :-)
09:15:04 <hilhil> The one good friend I have from a game development background be much said they would never consider using anything garbage collected for that reason
09:15:05 <ski> adimit : basically, the idea with Ptival's "diff-list" suggestion, and the `Endo [a]' one, is to skip the `k' part and only have the `b' part
09:15:09 <hilhil> :-)
09:15:45 <Philippa> that said: if I was that bothered about memory layout in Haskell then I'd have done the same as I'd do in C++ anyway, namely implement my own memory management for most of what I'm doing
09:15:47 <hilhil> kamaraj: also be warned that (unless you have a maths degree) Haskell may seem a lot harder than other languages, especially to start with
09:16:00 <Philippa> what you /can/ do with GHC Haskell if you're determined is a lot more than you'd expect
09:16:02 <hilhil> Can you implement your own memory management in Haskell? (genuine question.)
09:16:09 <Philippa> FFI, 'nuff said? :-)
09:16:17 <Philippa> you're going to spend a lot of time in the IO monad, sure
09:16:19 <kamaraj> lol i am little weak in maths :(
09:16:26 <hilhil> FFI to C?
09:16:35 <Philippa> hilhil: not necessarily
09:16:36 <adimit> ski: interesting; so I take it the Endo-idea and the DList idea are pretty equivalent?
09:16:39 <adimit> Ptival: thanks!
09:16:50 <ibt> Philippa: btw, with (f 2 + f 2) * f 2 .. i see that f 2 will only be evaluated once, but where does this end? will this be the case until the result of f 2 is garbage collected? then it must once again evaluated?
09:16:50 <ski> adimit : yep, conceptually
09:16:55 <hilhil> kamaraj: I'm not saying not to look at the language -- just that the beginning will be hard going.
09:16:57 <Philippa> old-fashioned "allocate me a big block to use as a pool and I'll take it from there" stuff works
09:17:00 <kamaraj> jusat saw about this language while searching for lisp. so just joined this discussion
09:17:11 <Philippa> ibt: nope, f 2 will be evaluated three times
09:17:23 <kamaraj> i wll gothrough when i get time..
09:17:27 <Philippa> that's exactly what I meant about no common subexpression elimination
09:17:28 <kamaraj> thanks for the information :)
09:17:47 <Philippa> kamaraj: tryhaskell.org and LYAH may be good starting points?
09:18:01 <rwbarton> ibt: but in "let x = f 2 in (x + x) * x", f 2 will be evaluated only once
09:18:06 <lhk_> back again. my client just crashed.
09:18:10 <ski> adimit : the basic thing which you want to avoid is `((foo ++ bar) ++ baz) ++ quux', instead what you do is basically `((((foo ++) . (bar ++)) . (baz ++)) . (quux ++)) []'
09:18:15 <applicative> kamaraj: haskell is unusually easy ... then very hard ... then very easy ...  It sort of keeps going
09:18:20 <Philippa> rwbarton: exactly. Then the fun one is "let x = f 2 in (x + x) * f 2"
09:18:45 <illissius> btw, I'm wondering whether Haskell doesn't have a considerably bigger disadvantage in space usage than in time. I mean, to store a boxed int, you have a pointer, a constructor, a thingie for the garbage collector, and then finally the int, so it's something like 400+% overhead. (obviously this is an extreme example though, and usually you can avoid using boxed ints.) and then the garbage collector typically waits until heap size
09:18:46 <illissius> doubles before doing a major collection, and then when it does that I think it needs an amount of memory equal again to the size of the heap to do it, so that's something like another 4x overhead. how accurate is this?
09:18:47 <Philippa> yeah, haskell tends to make you accidentally the entire hard problem. Then you find you solved it once and for all
09:18:51 <ibt> rwbarton: Philippa: i thought there was some automatic memoisation in some instances
09:19:10 <ski> ibt : did you check the link i suggested yet ?
09:19:21 <ibt> ski: i'm sorry. i must've missed it
09:19:22 <adimit> ski: right, avoiding left-associative use of (++) — I'm always appending single elements, so running around with an O(n) operation on every append would be dumb.
09:19:38 <ski> ibt : no automatic memoization. only caching of results of thunks
09:19:45 <illissius> ibt: there's no automatic memoization. the rule of thumb is that if something is bound to a name, it's only computed once every time it "comes into scope"
09:19:51 <tac-tics> Are there any languages that use strict semantics by default -- but then JIT compile live code to be lazy?
09:19:58 <Philippa> ibt: it's not that so much as the interaction with referential transparency. It doesn't make any difference to what value you get, only how long it takes
09:20:00 <tac-tics> (or any literature on such a technique?)
09:20:10 <ski> <ski> ibt : monochrom's <http://www.vex.net/~trebla/haskell/lazy.xhtml> might help somewhat
09:20:13 <ski> ibt ^
09:20:18 <hilhil> tactics: wouldn't that change the program behaviour?
09:21:08 <rwbarton> illissius: extravagant space usage is something of an issue, yes, especially on 64-bit systems
09:21:12 <tac-tics> hilhil: Not necessarily. For example, in a strongly normalizing language, both always lead to the same answer.
09:21:13 <ski> adimit : so, instead of storing a list `[a,b,c]' you end up storing a function `([a,b,c] ++)' / `(a :) . (b :) . (c :)' -- then adding at either end is easy
09:21:43 <ski> adimit : however, what you lose is that you can't observe the elements without extracting a result list by passing `[]', so you want to avoid doing this often
09:22:16 <tac-tics> I had a thought earlier today that maybe laziness should be a JIT optimization when it's heuristically better, and provably still correct
09:22:21 <ibt> Philippa: i always thought one of the great things about haskell was the separation of stateful vs pure code. if functions are pure, you know that given the same arguments, they will always evaluate to the same value. have they just not found an efficient way to implement what i was mentioning?
09:22:29 <lhk_> in the next semester at the uni functional languages will be one of the important topics. i figured it would be a good idea to get the feel of one of these and haskell seemed like a good choice. the problem is: after browsing through the website and a tutorial i can see that haskell is a very elegant language but i dont know what to use it for. id like to start a little pet project to get accustomed to the language.
09:22:30 <lhk_>  can you recommend a task that haskell is great for ? maybe a package that demonstrates the power of the language. im thinking of something like rails for ruby or scipy/numpy for python
09:22:41 <quicksilver> tac-tics: you're not the first person to think that.
09:22:41 <illissius> rwbarton: but like, is 16x versus a C/C++ program at all realistic? how would you guesstimate it?
09:22:47 <adimit> ski, yeah, that was what I was trying to do with my g k a = \b. k (a:b) idea above. I don't need to view the list while its building, which is quite fortunate :-)
09:22:56 <tac-tics> quicksilver: That is refreshing to hear. Do you know of any literature on the subject?
09:22:58 <rwbarton> well the thing is one does not normally have a heap full of boxed Ints
09:22:59 <quicksilver> tac-tics: but heuristically deciding when to strictify (or lazify) turns out to be quite hard.
09:23:03 <rwbarton> that is a rather unrealistic scenario
09:23:14 <illissius> right
09:23:14 <quicksilver> tac-tics: "speculative evaluation"  is one phrase to google for
09:23:21 <rwbarton> if you have a lot of Ints to store, but you can keep them in an unboxed array, then you have (virtually) no overhead
09:23:31 <illissius> but I don't have a good picture of what one usually does have and what the overhead for that is like :)
09:23:41 <tac-tics> quicksilver: thanks
09:23:57 <applicative> lhk_ the obvious example is parsec and the similar libraries
09:24:42 <tac-tics> quicksilver: Is "speculative evaluation" typically something done at compile time? or as an analysis on a running program?
09:25:28 <applicative> lhk_: here is an illustrative application based on parsec http://johnmacfarlane.net/pandoc/  https://groups.google.com/group/pandoc-discuss
09:25:41 <ski> adimit : btw, in a sense, `rest' in `\rest -> [a,b,c] ++ rest' is a continuation
09:26:02 <quicksilver> tac-tics: runtime I think. at compile-time it's called "supercompilation" or "partial evaluation".
09:26:11 <quicksilver> tac-tics: I *think*. Sometimes I get terminology backwards :)
09:26:13 <lhk_> applicative: hey that looks great
09:26:16 <adimit> ski: I thought continuations were necessarily functions?
09:26:22 <olsner> illissius: I think you get at least two words per item (one for a header and one for the actual data), so for boxed Int8 och Word8's on a 64-bit system that's indeed a 16x overhead
09:26:55 <rwbarton> if you are storing ASCII strings in a String you can get much larger than 16x overhead
09:26:56 <illissius> rwbarton: if you write a nontrivial program to do the same thing in both Haskell and C++ in more or less an optimal way, how would peak heap usage compare typically? just very roughly? is that an impossible question / does it entirely depend on the problem?
09:27:12 <rwbarton> I think it depends a lot on the problem
09:27:12 <applicative> lhk_ there are a number of web frameworks  competing at the moment.  their advantage over something like rails is the compiler; the advantage over other compiled languages is that ours is 'high level'.
09:27:23 <applicative> lhk_: this is all to put things rather crudely
09:27:33 <ski> adimit : yes, but in this case, every continuation that you pass (if you do proper CPS) will be of the shape `\xs -> foo ++ xs', so instead of passing this as `k', doing `k result', you can pass just `xs', and do `result ++ xs' instead
09:28:01 <ski> adimit : so it's a representation of continuations of this restricted shape
09:28:09 <olsner> illissius: if optimality includes memory use, both would use approximately the optimal amount of memory :)
09:28:26 <applicative> lhk_: here's the two sexiest web frameworks http://snapframework.com/ http://www.yesodweb.com/
09:28:32 <ski> (er, pass just `foo' and do `result ++ foo', rather)
09:29:00 <tac-tics> quicksilver: interesting. Thanks again. I'll look into it tonight :)
09:29:39 <illissius> olsner: I mean if you write in the way experienced haskellers would recommend that you write it, so that it achieves a good tradeoff of abstraction/maintability/performance, without explicitly going to extreme lengths to minimize space usage.
09:29:59 <applicative> lhk_: here is an illustration of the advantage of a compiled language,  http://snapframework.com/blog/2010/05/23/snap-0.1-benchmarks
09:30:01 <nobdraisentone> @hoogle (m a, b) -> m (a,b)
09:30:01 <lambdabot> No results found
09:30:05 <lhk_> applicative: how do i deploy a website in one of these ?
09:30:05 <nobdraisentone> How can I do that?
09:30:11 <quicksilver> illissius: 2x - 4x is probably not the worst rule of thumb.
09:30:19 <quicksilver> it will vary enormously depending on the nature of the problem.
09:30:38 <rwbarton> it really depends a lot on basically how much you can use unboxed arrays
09:31:09 * ski ponders how to express this properly
09:31:40 <applicative> lhk_: http://www.yesodweb.com/page/quickstart Now I'm sure you want to test this out! Installing Yesod also provided you with a yesod executable, which has two important commands.   yesod init   will ask you a few questions, and then generate a scaffolded site for you. Once you change into that directory, type   yesod devel   to start the development server. You can now access your site at http://localhost:3000/
09:31:42 <illissius> quicksilver: That's peak? so at the point where the garbage collector is doing a major collection?
09:31:50 <quicksilver> no
09:31:52 <quicksilver> it's long term
09:31:52 <rwbarton> or in general how much of your memory is being used by things other than Haskell data types
09:32:00 <quicksilver> short term peaks are not relevant
09:32:07 <quicksilver> they're just hiccups on the way to your overall usage
09:32:17 <quicksilver> the GC will run lots of times during the execution of your program
09:32:38 <lhk_> applicative: wow. bye then ive got to dive in
09:32:42 <applicative> lhk_: then study the book http://www.yesodweb.com/book  there is a #yesod channel
09:32:49 <lhk_> applicative thanks for your help
09:32:51 <illissius> quicksilver: well, it's relevant if you're running on, say, a desktop system and whenever you do a collection it causes swapping... :)
09:32:59 <adimit> ski: very interesting, thanks for your help!
09:33:00 <quicksilver> of course
09:33:06 <quicksilver> in a very specific case you measure and find out
09:33:14 * quicksilver shrugs
09:33:27 <illissius> yeah, I know this is a dumb question and I should just profile and find out
09:33:29 <adimit> I'm not exactly positive on the exact use of Endo, but I'll figure it out.
09:33:30 <quicksilver> you're asking an unanswerable question I can't make my answer any more precise I don't think :)
09:33:42 <hilhil> Silly question: why do both lift and liftio exist\
09:33:43 <illissius> I'm just wondering about typical order-of-magnitude or something
09:33:47 <quicksilver> whichever language you use there will be ways to improve memory usage until it's close to optimal.
09:33:49 <hilhil> Probably silly question: why do both lift and liftIO exist?
09:34:02 <ski> @type appEndo
09:34:03 <lambdabot> forall a. Endo a -> a -> a
09:34:03 <hilhil> gah -- sorry, pasted twice
09:34:04 <ski> @type Endo
09:34:05 <lambdabot> forall a. (a -> a) -> Endo a
09:34:16 <tac-tics> hilhil: liftIO lifts as much as you need to to get to the IO layer of your monad stack
09:34:29 <rwbarton> lift is for lifting actions one monad transfomer level
09:34:38 <_Vi> What are code style rules for records? How should they be laid out, where to place comma, what names to choose for entries?
09:34:40 <adimit> ah, so I build up an Endo by using AppEndo?
09:34:43 <hilhil> hm...
09:34:44 <ski> > (Endo (^ 2) `mappend` Endo (* 2)) `appEndo` 3
09:34:45 <lambdabot>   36
09:34:50 <hilhil> Sometimes I get the impression that lift is lifting more than one level
09:34:55 <hilhil> Is that just me getting confused?
09:34:56 <tac-tics> hilhil: So liftIO = lift . lift . ... . lift (for some number of chained calls to lift)
09:35:00 <ski> adimit : and you use `mempty' and `mappend' to combine
09:35:26 <hilhil> Also, why have a special version for IO and not e.g.
09:35:27 <Philippa> ibt: there are a range of ways to implement memoisation in haskell, but doing it automatically has the same problem that common subexpression elimination does - or failing that, you end up with a lot of tuning of caching strategies to do still
09:35:28 <hilhil> liftReader
09:35:30 <hilhil> liftState
09:35:32 <hilhil> etc.
09:35:33 <hilhil> ?
09:35:42 <Philippa> ibt: the problem is we keep building functions with infinite domains :-)
09:35:51 <rwbarton> because the Reader operations are already lifted automatically like that
09:35:57 <rwbarton> @type ask
09:35:58 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
09:36:01 <hilhil> Why can't the IO operations be automatically lifted?
09:36:05 <illissius> hilhil: those exist, it's call MonadReader/MonadState/etc
09:36:08 <hilhil> I.e. why can't they be defined on
09:36:10 <hilhil> MonadIO
09:36:14 <rwbarton> because the Prelude defines them the way they are
09:36:18 <illissius> hilhil: hysterical raisins :)
09:36:28 <ski> Philippa : having a pragma for turning memoization on a specific function might be nice, though ..
09:36:32 <tac-tics> hilhil: Why a special version for IO? Because IO is often the best choice for your "top" monad :)
09:36:36 <luite> it would be nice if you could somehow manually enable memoization
09:36:57 <hilhil> So one reason is historical, and another is somewhat practical?
09:37:01 <hilhil> got it -- thanks, all!
09:37:07 <ski> (luite : see above ..)
09:37:10 <luite> ski: at least if you could give it some memoization strategy
09:37:29 <ski> luite : yes .. iirc, the Melbourne Mercury Compiler allows this
09:37:40 <illissius> MonadReader etc. are basically the same thing (I think!), but instead of providing a lift they just lift the methods directly, because there's a limited amount, unlike IO
09:37:41 <rwbarton> what advantage would that have over, say, a library like data-memocombinators?
09:37:55 <luite> rwbarton: that you can specify a memoization strategy
09:38:05 <rwbarton> That's what the "combinator" part means
09:38:15 <rwbarton> I mean... you are writing the library so you can specify the strategy
09:38:19 <Philippa> ski: yeah. There's always wrapping in a memoisation implementation, of course, but yes
09:38:26 <rwbarton> Why can't it just be in a library, I guess is my question.
09:38:44 <luite> rwbarton: with data-memocombinators, you memoize everything as long as the meomized stuff is in scope, you can't do something like remembering the last 100 values, or keeping the memoization alive for the next call
09:38:52 <ski> luite : see <http://www.mercurylang.org/information/doc-latest/mercury_ref/Tabled-evaluation.html>
09:39:19 <rwbarton> okay, that i would need unsafePerformIO to do in a library
09:39:57 <luite> rwbarton: right, I've done this, but for some reason people thought this was ugly ;p
09:39:58 <illissius> there's IO-using memoization libraries on hackage (at least one), but I don't think they give you that kind of control either
09:40:09 <illissius> but maybe they could. dunno
09:40:42 <rking> https://gist.github.com/2931389 # very basic problem, here. Trying to check the return value of a system call.
09:41:10 <rking> I've tried numerous versions - that one fails with: foo.hs:3:23: Not in scope: data constructor `ExitSuccess'
09:41:18 <rwbarton> @hoogle ExitSuccess
09:41:18 <lambdabot> System.Exit ExitSuccess :: ExitCode
09:41:18 <lambdabot> System.Exit exitSuccess :: IO a
09:41:32 <luite> illissius: yeah but one of the attractions of memoization (imho) is that you can influence the operation of pure functions, swap out a pure one with the same but memoized one
09:41:47 <luite> illissius: having an IO memoization lib makes it very difficult
09:42:00 <rwbarton> rking: try "import System.Exit"
09:42:03 <rking> Ahh
09:42:08 <illissius> luite: I mean iirc the interface is pure, but it's using unsafePerformIO and MVars internally.
09:42:17 <luite> illissius: oh right
09:42:31 <rking> rwbarton: Haha, works great. How could I have figured that out without pestering #haskell?
09:42:36 <rwbarton> @where hoogle
09:42:37 <lambdabot> http://haskell.org/hoogle
09:42:45 <rwbarton> go there and type in ExitSuccess
09:42:46 <hilhil> I remember one of my aha moments was being told that purity wasn't the important thing, referential transparency was.
09:42:52 <illissius> obvs can't remember what package it was :) iirc there were benchmarks showing it's a few times faster than 'pure' memoization.
09:42:58 <rking> Ahh, cool. Many thanks. =)
09:43:05 <bpk_> this seems like it's an xmonad question but I think everyone is asleep in there, is there an easy way to combine 2 Query Bool, like ( title =? "title" || className =? "class" )
09:43:34 <adimit> ski: I got it, thanks. so I'd go (Endo (1:) `mappend` Endo (2:) …) `appEndo` [] — quite elegent, actually.
09:43:35 <bpk_> the || fails since it's for Bool obviously, but I'm new to haskell and it's kind of driving me crazy
09:43:41 <ski> bpk_ : maybe you can use `liftA2 (||)' or `liftM2 (||)' ?
09:43:46 <illissius> hilhil: what do you mean by purity?
09:44:08 <ski> bpk_ : iow, `liftA2 (||) (title =? "title") (clasName =? "class")'
09:44:14 <byorgey> bpk_: yes, use <||>
09:44:28 <ski> bpk_ : see what byorgey said
09:44:41 <bpk_> ski and byorgey thanks!
09:44:46 <rking> rwbarton: Hrm, I'm still not 100% seeing the answer. http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Exit.html#v:ExitSuccess doesn't seem to say anything about System.Exit
09:44:46 <byorgey> which is a shorthand for liftM2 (||) provided by xmonad
09:45:03 <rking> Oh, it's in the title.
09:45:05 <ski> bpk_ : will that always do both queries ?
09:45:06 <ski> er
09:45:09 <ski> byorgey ^
09:45:12 <rking> OK, so I guess each page is the module or something to import.
09:45:17 <rwbarton> yes
09:45:30 <byorgey> bpk_: http://xmonad.org/xmonad-docs/xmonad/XMonad-ManageHook.html
09:45:37 <rwbarton> it also says on the hoogle result list, "base System.Exit" <- package & module
09:46:15 <byorgey> ski: yes, I suppose it will
09:46:22 <ski> ok, i see it's just `liftM2'
09:46:49 <rking> rwbarton: Cool.
09:46:50 <byorgey> ski: usually queries are effect-free and fast, so I'd never thought about it before
09:47:29 <bpk_> byorgey: it was for a namedscratchpad toggle, unfortunately every example I could find was just for a single className or title, but <||> does it great.
09:47:32 <tac-tics> Man, coming up with your own well-founded opinion on things is hard.
09:47:54 <HugoDaniel> can i use darcs as a lib in my haskell code ?
09:47:56 <bpk_> so in xmonad stuff is most of the <+> and stuff xmonad specific wrappers around liftM?
09:48:02 * tac-tics chugs on with the extrinsic differences between strict and non-strict evaluation
09:48:45 <byorgey> bpk_: only <||> and <&&>
09:49:25 <rking> Now for my very final problem on this task, getting the expression to work for "mod3Mask" and "mod1Mask" on the RHS. On this one, for line 14, I get: The last statement in a 'do' construct must be an expression -- https://gist.github.com/2931432
09:49:35 <byorgey> bpk_: <+> is a synonym for mappend, which is from the Monoid class
09:49:37 <rking> I /think/ it's trying to call mod3Mask as a function, so I need some way to quote it.
09:49:43 <ski> byorgey : i still wonder whether we ought to have a class for `ApplicativeChoice' with `eitherA :: ApplicativeChoice i => i (a0 -> b) -> i (a1 -> b) -> i (Either a0 a1) -> i b'
09:49:54 <rwbarton> rking: just looks like an indentation problem
09:50:13 <rking> Oh, oops. =)
09:50:16 <bpk_> byorgey: I see, yeah I just looked it up on hoogle, I didn't get past the arrow stuff in the learn you a haskell book, seems like I should go back and read it
09:50:17 <rwbarton> 'if' on line 15 should be below 'retval' on line 14
09:50:38 <byorgey> bpk_: no, there are no arrows involved in xmonad.
09:50:48 <rking> Fixing the indentation gives me: Couldn't match expected type `IO b' against inferred type `KeyMask'
09:51:03 <rking> (In the expression: mod3Mask) (line 16)
09:51:07 <rwbarton> right
09:51:07 <byorgey> bpk_: this is a different <+> we are talking about
09:51:11 <bpk_> byorgey: on hoogle it says it's arrow related?
09:51:30 <hilhil> Is there an infix operator equivalent to liftM (for a general monad) ?
09:51:31 <bpk_> byorgey: hmm, is there a better place and hoogle to look for these symbols?  I couldn't find =? on there either
09:51:43 <byorgey> bpk_: nothing prevents multiple libraries from using the same name for different things
09:51:58 <rwbarton> rking: I would rename myModMask to getModMask and then change main to
09:52:05 <rwbarton> main = do myModMask <- getModMask
09:52:12 <byorgey> bpk_: try adding +xmonad to your hoogle queries
09:52:13 <rwbarton>           xmonad defaultConfig { ...
09:52:14 <ski> hilhil :   foo `liftM` bar
09:52:38 <ski> hilhil : you can also use `fmap' or `liftA' or `(<$>)'
09:52:41 <hilhil> ski: I was hoping for something with lower precedence. (I think I mean lower)
09:52:55 <byorgey> bpk_: it doesn't search all packages by default
09:52:57 <hilhil> I know about those, but unfortunately I'm working in a general MonadError instance, so I don't think I can access them
09:53:07 <hilhil> It's this perpetual nuisance of a monad not being a functor
09:53:12 <rking> rwbarton: Hrm, I'm not sure that I follow. I'd put that right before the "xmonad defaultConfig" ?
09:53:34 <bpk_> byorgey: that is awesome, I didn't know about that, searchable documentation has been frustrating me since the xmonad base is so big, this should help a lot
09:53:44 <rwbarton> let me just hpaste rather than try to describe
09:53:58 <S11001001> hilhil: I think you can declare fixity of `` things
09:53:58 <jonkri> ski: great! thanks again
09:54:05 <rking> Hehe. rwbarton I really appreciate it.
09:54:12 <bpk_> byorgey: you've been extremely helpful, have a great day
09:54:51 <JoeyA> I have a type class with three parameters, all of which functionally determine each other.  Is there a nicer way to express that than this?  class Function t f c | t -> f, f -> c, c -> f, f -> t
09:54:57 <hpaste_> “Joey Adams” pasted “Indicate that class parameters are mutually dependent” at http://hpaste.org/69943
09:55:04 <hpaste_> rwbarton pasted “xmonad” at http://hpaste.org/69944
09:55:04 <ski> jonkri : typically, `showParen' is used to conditionally wrap in brackets, and `readParen' is used to conditionally require wrapping brackets
09:55:05 <JoeyA> ^ there's some context
09:55:08 <rwbarton> hopefully i did that right
09:55:31 <ski> jonkri : usually you only use these if you're writing `Read' instances manually, though
09:55:44 <ski> (well, `Read' and `Show')
09:56:37 <rking> rwbarton: Strangely enough, it gives the same: Couldn't match expected type `IO b' against inferred type `KeyMask'
09:56:39 <ski> JoeyA : hm, i'd assume you only need three FDs, connecting your parameters together in a "cycle"
09:56:56 <rwbarton> oh
09:57:01 <rwbarton> lines 16 & 17 need return
09:57:06 <JoeyA> ski: Ah, true.
09:57:12 <rking> Aha
09:57:14 <JoeyA> Still, this construction is a bit awkward.
09:57:23 <rking> rwbarton: What does it mean with and without the 'return's?
09:57:37 <jonkri> ski: ah, i see. that's not the case for me :)
09:57:41 <JoeyA> Here's an example of what this class provides:
09:57:42 <JoeyA> func2 :: (Var a -> Var b -> Expr r) -> Expr (a -> b -> Func r)
09:57:43 <jonkri> (writing instances manually(
09:57:48 <JoeyA> call2 :: Expr (a -> b -> Func r) -> Expr a -> Expr b -> Expr r
09:57:59 <rwbarton> well without the return it means that getModMask should execute the mod3Mask action (or mod1Mask action)
09:58:10 <rwbarton> of course mod3Mask is not an action so you get that type error
09:58:47 <rwbarton> return mod3Mask is the action that has no effects and just has the result mod3Mask
09:58:55 <rwbarton> you could also put a return around the whole if-then-else
10:00:35 <ski> JoeyA : two associated types, so that you say `func :: Func t -> Expr t; call :: Expr t -> Call t' might be nice
10:02:01 <rking> rwbarton: Hehe, that exited xmonad. =)
10:03:23 <JoeyA> ski: So the associated types are Func and Call?
10:03:29 <ski> `call . func' looks sortof `(=<<)'-ish ..
10:03:35 <ski> JoeyA : yeah
10:04:07 <_Vi> [repost] What are code style rules for records? How should they be laid out, where to place comma, what names to choose for entries?
10:04:17 <JoeyA> ski: Will the caller have to use Func and Call data constructors?
10:04:45 <ski> _Vi : when i break them on multiple lines, i tend to write the comma at the start
10:05:02 <ski> JoeyA : i don't see why
10:05:25 <nand`> simplest way to implement  combinations :: [a] -> [[a]] -- (infinite) list of all (finite) combinations of elements from the input
10:05:28 <_Vi> ski, camelCase? under_scores? Should I prepend record name (full? abbreviated?) to each entry name/
10:05:34 <nand`> that was a question, mind
10:05:42 <ski> (you'll have to use an associated type synonym, instead of an associated data type, though)
10:05:58 <JoeyA> ski: Ah, okay.
10:07:04 <ski> > Data.Tree.Node {Data.Tree.rootLabel = () , Data.Tree.subForest = []}
10:07:05 <lambdabot>   Node {rootLabel = (), subForest = []}
10:07:09 <nand`> in a way that I can find any finite list in the result if I look long enough; ie. combinations [1,2] = [[], [1], [2], [1,1], [1,2], [2,1], [2,2], ...] -- not [[], [1], [1,1], [1,1,1] ...]
10:07:41 <ski> _Vi : i'd typically use camelCase. re the prepending, i'd say it depends
10:08:29 <_Vi> Is there in general one "official" code style for Haskell, like in Java?
10:08:39 <nand`> hmm, I can probably implement it by folding (++) over the list monad or something
10:09:36 <nand`> _Vi: there are different opinions as far as indentation/layout is concerned
10:09:46 <nand`> but camelCase naming is pretty much universally accepted
10:09:47 <ski> > let combinations as = [] : (as >>- \a -> combinations as >>- \as -> [a:as]) in combinations "ab"
10:09:48 <lambdabot>   ["","a","b","aa","ba","ab","bb","aaa","baa","aba","bba","aab","bab","abb","...
10:10:00 <ski> nand` : does that qualify ?
10:10:11 <nand`> :t (>>-)
10:10:12 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
10:10:37 <nand`> ski: yeah, sure
10:10:38 <HairyDude> @info MonadLogic
10:10:38 <lambdabot> MonadLogic
10:10:39 <nand`> and thanks
10:10:44 <HairyDude> +1, Informative
10:10:46 <ski> @info HairyDude
10:10:46 <lambdabot> HairyDude
10:10:58 <nand`> @help info
10:10:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:11:03 <ski> @info this is really calling `@echo'
10:11:04 <lambdabot>  Parse error at "@echo..." (column 25)
10:11:16 <rwbarton> no, it's @undo
10:11:20 <HairyDude> lambdabot: I like your sense of humour
10:11:38 <ski> oh, you're right
10:11:46 <HairyDude> @info Maybe
10:11:46 <lambdabot> Maybe
10:11:48 <HairyDude> hm
10:12:00 <ski> @info do ()
10:12:01 <lambdabot> ()
10:12:12 <nand`> @info do { a; b }
10:12:13 <lambdabot> a >> b
10:12:17 <nand`> why is that alias defined?
10:12:26 <ski> there is no alias, it's spell-correction
10:12:39 <ski> @botsmack
10:12:39 <lambdabot> :)
10:12:45 <nand`> oh
10:13:32 * nand` thinks spelling correction should be far less eager to ‘correct’ words that are valid english
10:13:51 <nand`> but probably not worth the trouble of defining a dictionary just for that
10:14:01 <adimit> what is "valid" English isn't exactly obvious to most humans, let alone machines.
10:14:13 <HairyDude> lambdabot is a masochist?
10:14:59 <Axman6> no, smack the drug
10:16:24 <HairyDude> ah
10:16:59 <nand`> adimit: for this purpose it should be reasonable to restrict the definition of “valid” to, say, “present in dictionary X” (suitably chosen)
10:17:18 <nand`> wiktionary lists “info”, for example
10:17:35 <HairyDude> @eval
10:17:42 <HairyDude> strange plugin
10:18:50 <ski> @whence report
10:18:51 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
10:19:33 <nand`> ski: more importantly, how does (>>-) differ from (>>=)?
10:19:37 <nand`> I can't find MonadLogic on hoogle
10:20:01 <ski> nand` : it's more fair, interleaves results from different choices
10:20:46 <rking> rwbarton: Any ideas re: `return` simply exiting xmonad?
10:21:48 <ski> > [0,1] >>= \b -> [0,2 ..] >>= \n -> [n+b]
10:21:53 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
10:21:54 <ski> > [0,1] >>- \b -> [0,2 ..] >>= \n -> [n+b]
10:21:57 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
10:22:30 <LambdaDusk> hi, I have an unusual question, but perhaps someone can help me: How would I add the Creative Commons licence to my cabal file? The artwork I am using kind of requires it.
10:23:06 <dcoutts_> lambdabot: put it in your license file, and list that in the license-file field in the .cabal file
10:23:11 <dcoutts_> oops
10:23:16 <dcoutts_> LambdaDusk: ^^ :-)
10:23:22 <nand`> ski: Do you know if there's a similar applicative?
10:23:44 <LambdaDusk> dcoutts: Yes but what is the canon name for the "License" field?
10:23:51 <dcoutts_> LambdaDusk: and you may then need to say license: OtherLicense
10:24:05 <LambdaDusk> dcoutts_: thanks
10:26:23 <ozataman> is there a version of many in parsec that would accept an empty string?
10:26:38 <ski> nand` : see <http://hackage.haskell.org/package/logict> for `MonadLogic' -- as to whether there's something related for applicative functors, i dunno
10:27:44 <hpaste_> kmels pasted “Nested map lookup” at http://hpaste.org/69946
10:27:46 <fmap> ozataman: ehm, many?
10:28:10 <ozataman> fmap: many is a combinator in parsec
10:28:10 <kmels> hello, is there a combinator that can help me to reduce the code in the paste above?
10:28:34 <kmels> with the nested Maybe's
10:28:36 <fmap> ozataman: and it accepts empty string
10:28:43 <ozataman> fmap: nope
10:29:06 <ozataman> well, perhaps I should have been clearer
10:29:16 <ozataman> many will not accept a parser as argument that accepts an empty string
10:29:26 <ozataman> I'm looking for something that would
10:29:49 <edwardk> ozataman: many will accept an empty string, but it cannot take a parser that would, otherwise that parser can keep accepting forever
10:30:07 <edwardk> this is somewhat of a problematic idea though, because it ignores parsers that accept but mutate state
10:30:10 <S11001001> kmels: <|>, <$>, and maybe should help
10:30:12 <ozataman> edwardk: right, I tried to clarify my question above. I'd like to manually ensure it will terminate
10:30:23 <edwardk> ozataman: you'd have to write it yourself
10:30:27 <edwardk> brb
10:30:33 <kmels> S11001001, Thank you!
10:32:03 <ozataman> edwardk: the issue I'm running into is this: I'm trying to potentially discard anything after "--" in a number of places in my parser. but since "--" is two characters, I have to use a "try" in there somewhere. if do that, however, now many or skipMany will not take my comment parser, since it "maybe" eats input :)
10:32:37 <hpaste_> rking pasted “modMask / xmonad.xs” at http://hpaste.org/69949
10:32:41 <rking> Anyone else have a clue why that code gives: Couldn't match expected type `IO b' against inferred type `KeyMask'
10:33:06 <rking> It doesn't seem to like me leaving "mod1Mask" and "mod3Mask" hanging as the RHS of the "then" and "else".
10:33:21 <rking> I tried putting "return mod1Mask" but all that does is exit xmonad. =)
10:36:05 <rwbarton> rking: can you paste your current file
10:37:23 <rking> rwbarton: That recent one is it: http://hpaste.org/69949
10:37:48 <rwbarton> what? isn't this an old one
10:37:53 <rking> Well, yeah. =)
10:38:22 <rking> The version with getModMap did the same error, and the return was the one that exited xmonad.
10:38:28 <fmap> rking: you can't do `modMask = myModMask' where `myModMask ∷ IO KeyMask' sinse `∷ KeyMask' is expected
10:38:38 <fmap> since*
10:38:43 <rwbarton> i wanted the one with the return
10:39:28 <rking> rwbarton: Ahh, sorry.
10:39:30 <ski> rking : it would be easier to find the various pastes if you used the "Annotate" button to annotate on the original paste ..
10:39:37 <rking> Crud, I have to take this work call. BBIAW.
10:42:38 * hackagebot SimpleEA 0.2 - Simple evolutionary algorithm framework.  http://hackage.haskell.org/package/SimpleEA-0.2 (ErlendHamberg)
10:56:01 <JoeyA> ski: I don't think the type family solution you proposed (Func t and Call t) will work in my case: http://www.haskell.org/haskellwiki/GHC/Type_families#Injectivity.2C_type_inference.2C_and_ambiguity
10:56:42 <hilhil> ozataman: option will help
10:56:44 <JoeyA> This is because Func t1 = Func t2 does not imply that t1 = t2, which I need to be able to do.
10:56:53 <JoeyA> Thanks for the suggestion, though.
10:58:20 <JoeyA> Maybe the external API works, but I can't use this lower-level implementation function: jfunc :: Func t -> JFunc
10:58:21 <HairyDude> hm, lambdabot no longer implements @seen
11:00:10 <fmap> preflex: seen HairyDude
11:00:11 <preflex>  HairyDude was last seen on #haskell 1 minute and 49 seconds ago, saying: hm, lambdabot no longer implements @seen
11:00:41 <parcs`> @seen hackagebot
11:00:41 <lambdabot> Unknown command, try @list
11:02:43 * hackagebot select 0.2 - Give the select(2) POSIX function a simple STM interface  http://hackage.haskell.org/package/select-0.2 (GardSpreemann)
11:19:40 <MostAwesomeDude> preflex: seen MostAwesomeDude
11:19:41 <preflex>  MostAwesomeDude was last seen on #haskell 2 hours, 19 minutes and 36 seconds ago, saying: CAFs show up on profiling as one-time costs.
11:29:17 <HairyDude> preflex: help
11:29:18 <preflex>  try 'help help' or see 'list' for available commands
11:29:23 <HairyDude> preflex: list
11:29:24 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
11:29:25 <preflex>  ZCode: [zdec, zenc]
11:31:00 <HairyDude> preflex: 8ball Will lambdabot's @src ever be useful again?
11:31:00 <preflex>  most likely
11:37:08 <MostAwesomeDude> preflex: cdecl void *(*)(const void*, const void*)
11:37:08 <preflex>  pointer to function(pointer to const void, pointer to const void) returning pointer to void
11:38:26 <_Vi> I load module in ghci with ":l Something.hs". I can use qualified imports like "B.splitAt" right from ghci. Then I try to load changed module with ":l Something.hs", but it fails. Why I immediately can't use import from previous version of the module anymore until I load it again successfully?
11:41:44 <Cale> _Vi: I guess because the module is unloaded first before it tries to reload it.
11:42:22 <_Vi> How to reload the module safely (i.e. do nothing if it new version fails to load)?
11:43:50 <Cale> _Vi: I don't think there's a safer way. I guess if you were really worried, you could load it in a separate ghci
11:44:17 <_Vi> I'm just looking for ways to make it more convenient.
11:45:01 <_Vi> Now I'm commenting out or changing to "undefined" and reload again just to keep expressions in ghci's input history valid.
11:45:24 <scooty-puff> is there anything like a haskell-specific grep or sed that understands haskell structure?
11:45:39 <scooty-puff> to replace module names, function names, data types
11:46:05 <scooty-puff> sed --module s/Module/OtherModule/
11:46:06 <scooty-puff> or something
11:46:21 <scooty-puff> (asking to make sure i don't do something already done..)
11:48:35 <byorgey> scooty-puff: no, though it's not too much trouble to parse using haskell-src-exts, modify using some generic programming tool like uniplate, then pretty-print it back out
11:49:01 <byorgey> it even lets you exaactly preserve whitespace etc.
11:49:16 <fmap> _Vi: you can use `import Module as M' in new ghci
11:50:15 <scooty-puff> byorgey: do you know if would be possible to retain the original formatting - i would guess the SrcLoc's aren't used, or don't contain enough information anyways to recreate exactly
11:50:33 <byorgey> scooty-puff: yes, it is actually
11:50:40 <scooty-puff> o, perfect
11:51:20 <byorgey> e.g. see http://hackage.haskell.org/packages/archive/haskell-src-exts/1.13.3/doc/html/Language-Haskell-Exts-Annotated-ExactPrint.html
11:52:12 <luite> byorgey: it's tricky to do it correctly though, you can easily replace some identifier, but it might not refer to the same thing as another... oh and the exact prettyprinter is tricky to work with
11:52:15 <rwbarton> what happens when your replacement moves the starting column of a layout block
11:53:05 <byorgey> oh, is it?  I haven't actually used it, I just know it's supposed to be possible
11:53:07 <luite> rwbarton: right, that's one of the problems, if your name has a different length, you will probably have to update lots of positions in the ast
11:53:34 <byorgey> oh, heh, good point
11:54:13 <scooty-puff> either way, seems better than just grep and sed - and at least the grep part would work every time
11:56:47 <roconnor> what is FPComplete?
11:57:33 <srhb> So, docs say terminateProcess should be avoided. Are there better ways>]
11:58:56 <geekosaur> srhb: what exactly are you trying to do?
12:00:18 <geekosaur> in general, what you should do is use some kind of communication protocol to ask the process to clean up and shut down; terminateProcess (aka kill()) *sometimes*, especially with daemons, is that communications protocol, but other times it forcibly stops the process without giving it a chance to make sure its state is saved properly or etc. and it may not start up properly next time as a result
12:01:00 <geekosaur> it's not so much "should be avoided" as "you should make sure you know what you're doing"
12:02:19 <srhb> geekosaur: I thought that was the whole idea of SIGTERM. Which seems to be what terminateProcess is.
12:02:48 <geekosaur> yes, but not all programs actually handle SIGTERM
12:03:01 <geekosaur> many programs *should* but don't
12:03:07 <srhb> Indeed, and VLC seems to not do that. Then again, I'm not too bothered about sending SIGKILL.
12:03:10 <armlesshobo> only REAL programs handle any signal
12:03:39 <scooty-puff> anyone use HaRe?
12:04:01 <geekosaur> but if you know that SIGTERM is an acceptable way to stop the process, go ahead and use it.  if some other signal is more appropriate, see System.Posix.Signal
12:06:00 <srhb> geekosaur: Thanks for the clarification. :) I wish motivations like that were directly in the docs instead of just "you shouldn't do this.."
12:08:04 <byorgey> scooty-puff: I tried to use it somewhat recently.  It was really difficult to build and get it set up, and in the end I couldn't use it anyway since it only supports haskell 98.
12:10:04 <geekosaur> the haskell documentation is really not the place for a proper discussion of when and how to use it; but the documentation could use some unpacking, rather than an implicit suggestion that you look at the appropriate documentation for the platform including "when should you use this" documentation that may not be part of the official API docs
12:10:47 <scooty-puff> byorgey: k; that sucks..
12:11:10 <byorgey> yeah, it does
12:14:54 <HairyDude> interesting. cabal-dev decided to build successfully this time
12:17:13 <hpaste_> scooty-puff pasted “*sigh*” at http://hpaste.org/69953
12:19:31 <mauke> http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon
12:19:49 <HairyDude> and cabal-dev install on a new project gives a dependency resolution failure
12:20:07 * HairyDude knocks cabal and yesod's heads together
12:21:31 <HairyDude> rejecting: yesod-platform-1.0.4.2 (conflict: cereal==0.3.5.2, yesod-platform
12:21:31 <HairyDude> => cereal==0.3.5.1)
12:21:34 <dcoutts> scooty-puff, byorgey: there's a chap working on redoing it on top of the ghc api, so it'd work for real programs
12:21:44 <HairyDude> installed cereal is 0.3.5.1... I don't get it
12:21:48 <byorgey> ooooooh, shiny!
12:22:09 <dcoutts> HairyDude: the fact it's installed isn't especially relevant
12:22:39 <dcoutts> it's a question of what the solver picks, and yes it will prefer to use installed versions, but that's only a soft preference
12:23:43 <scooty-puff> dcoutts: that would be very nice, currently refactoring (moving modules, etc.) is he only really sigh-inducer for me..
12:23:49 <scooty-puff> *really -> real
12:23:50 <dcoutts> HairyDude: so at that point in its search, it's picked cereal==0.3.5.2, hence it cannot pick yesod-platform-1.0.4.2
12:24:17 <HairyDude> dcoutts: oh, wtf? why did it pick cereal first? that dep only comes from yesod-platform!
12:24:39 <dcoutts> HairyDude: if you want to know why it's picking cereal==0.3.5.2, see elsewhere in the log or use --constraint=cereal==0.3.5.1
12:24:47 <HairyDude> right
12:25:03 <dcoutts> if you tell it do what you expected in the first place, then it'll either do it, or it'll tell you why that's impossible
12:25:50 <dcoutts> this is a good technique for working out package dep problems: add as constraints what you want/expect and see what it says in response
12:26:12 <HairyDude> ah, I see. it goes my project -> http-conduit -> socks -> cereal
12:26:25 <HairyDude> but it can't backtrack on its choices?
12:26:29 <dcoutts> it can yes
12:26:52 <dcoutts> HairyDude: it's possible it might find a solution if you increase the backtracking limit
12:27:33 <HairyDude> --max-backjumps ?
12:27:42 <dcoutts> right
12:28:35 <HairyDude> see what happens with --max-backjumps=-1
12:29:23 <HairyDude> let's see if --reorder-goals helps
12:29:27 <dcoutts> HairyDude: if it does find a solution, it'd be interesting to know what limit is needed for your example, the current default limit is based on a few tests but could be changed if in practice it's not big enough
12:29:35 <HairyDude> ok
12:29:53 <HairyDude> well 500 is not enough
12:30:19 <HairyDude> I'll use --dry-run so I can find the number
12:31:25 <dcoutts> HairyDude: does it find a solution if you use --constraint=cereal==0.3.5.1 ?
12:31:56 <HairyDude> 1000 seems to be enough
12:32:00 <HairyDude> dcoutts: trying that now
12:32:38 <dcoutts> HairyDude: "seems to be enough"? you mean it does find a solution?
12:32:54 * hackagebot fb 0.9.7 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.9.7 (FelipeLessa)
12:33:03 <dcoutts> HairyDude: would you mind making a log and sending it to me, or kosmikus, or to cabal-devel
12:33:41 <HairyDude> dcoutts: it prints "Resolving dependencies..." and then despite --dry-run it then does "Configuring SHA-1.5.0.1..."
12:34:02 <HairyDude> argh, it's compiling stuff even though I told it not to
12:34:02 <dcoutts> ?!
12:34:02 <lambdabot> Maybe you meant: . ? @ v
12:34:41 <dcoutts> sure you didn't make a typo? I've never seen it not respect --dry-run ?
12:34:58 <dcoutts> erm, that was a statement not a question :-)
12:35:01 <HairyDude> nope
12:35:32 <HairyDude> this is Windows, if that makes a difference
12:35:43 <HairyDude> annoyingly, ^C didn't kill it
12:35:44 <dcoutts> what cabal --version? is it reproducible?
12:35:48 <byorgey> nope, you didn't make a typo, or nope, you're not sure?
12:35:57 <HairyDude> sure I didn't make a typo
12:36:06 <HairyDude> cabal-install version 0.14.0
12:36:06 <HairyDude> using version 1.14.0 of the Cabal library
12:36:20 <HairyDude> ah, this is cabal-dev, not cabal
12:36:35 <HairyDude> cabal-dev 0.9.1
12:36:35 <dcoutts> ah, ok, make sure you can reproduce it with cabal
12:37:00 <dcoutts> otherwise report it against cabal-dev
12:38:00 <dcoutts> HairyDude: but the log of the solver may be useful for us I think
12:38:18 <HairyDude> ok, tried with a fresh yesod project, and cabal succeeds in finding a solution but cabal-dev doesn't
12:38:42 <dcoutts> HairyDude: oh, finds a solution without needing any extra flags?
12:38:46 <HairyDude> yup
12:38:59 <HairyDude> also respects --dry-run
12:38:59 <dcoutts> sounds like cabal-dev is not using the latest cabal-install
12:39:05 <dcoutts> HairyDude: great
12:39:13 <Peaker> I have a:   data Property m a = Property { get :: m a, set :: a -> m () }     I want to make a different type/tag for actions that read, and those that write.  I was thinking of using:  data Property mr mw a = Property { getR :: mr a ; getW :: mw a ; set :: a -> mw () }
12:39:37 <HairyDude> cabal-dev "built with Cabal 1.14.0" which is the same as the real cabal
12:39:41 <dcoutts> HairyDude: mind you, I'm surprised that it understood the --max-backjump param if it were using an older cabal
12:39:57 <Peaker> But having "getR" and "getW" is ugly. I was thinking of maybe creating a type-class for write-transactions with a method to lift from read-transactions? Then I would be able to have a single get
12:39:57 <dcoutts> HairyDude: right, but it calls out to an external cabal binary
12:40:24 <HairyDude> dcoutts: I installed it myself, so I should think it's using the same version
12:40:24 <Peaker> Anyone handled something like this, and has advice on how to design it?
12:40:32 <HairyDude> installed and built
12:40:47 <dcoutts> HairyDude: well I don't really know what cabal-dev is doing
12:40:54 <dcoutts> odd though
12:42:45 <HairyDude> https://github.com/creswick/cabal-dev/issues/47
12:42:48 <LambdaDusk> acid-state for game saving, you opinions?
12:42:55 <HairyDude> "cabal-dev just manages flags and environment details (such as configuration files) for cabal-install, and then delegates all the heavy lifting to cabal-install (and thus, to cabal)."
12:42:58 <startling> hi, what's the best library for reading LocalTimes and UTCTimes from strings? I don't see anything in the stdlib or haskell-platform
12:43:19 <dcoutts> HairyDude: right, which is why I wonder how it manages to behave so differently here
12:44:25 <startling> s/and/or
12:46:39 <geekosaur> startling, I think the best you'll do is http://www.haskell.org/ghc/docs/latest/html/libraries/time-1.4/Data-Time-Format.html#g:2
12:47:36 <HairyDude> dcoutts: --constraint=cereal==0.3.5.1 rejects hspec
12:48:09 <startling> geekosaur: oh nice, i missed that one
12:48:34 <dcoutts> HairyDude: context?
12:48:55 <dcoutts> HairyDude: plain cabal now? it finds a solution if you don't specify that constraint right?
12:48:56 <HairyDude> hm. --max-backjumps=1000 is failing now... maybe that build was a "cabal install" I ^C'd earlier
12:49:07 <HairyDude> dcoutts: this is cabal-dev still
12:49:27 <dcoutts> HairyDude: ok, since it's behaving differently then I'm not trusting it :-)
12:49:33 <HairyDude> :)
12:49:46 <HairyDude> dcoutts: does seem to be a bug in cabal-dev, not cabal proper
12:49:59 <dcoutts> HairyDude: see if you can find out how cabal-dev is calling cabal
12:50:09 <HairyDude> trying --max-backjumps=10000
12:50:09 <dcoutts> so you can see if it's the same binary it's using
12:50:24 <HairyDude> dcoutts: ok, I should be able to trace it
12:50:26 <dcoutts> or if there's other flags it's passing that might be doing something odd
12:50:41 <dcoutts> if it's anything like cabal, -v3 should show what programs it calls
12:50:48 <HairyDude> ah, k
12:54:59 <mparodi> how do you create sets?
12:55:25 <HairyDude> mparodi: singleton, mappend, fromList
12:55:37 <mparodi> > fromList [(1,2),(3,4),(5,6)]
12:55:39 <lambdabot>   No instance for (GHC.Show.Show (m t))
12:55:39 <lambdabot>    arising from a use of `M3785911704...
12:55:43 <mparodi> HairyDude, ^
12:55:50 <HairyDude> > Data.Set.fromList [1,2,3,4]
12:55:51 <lambdabot>   Not in scope: `Data.Set.fromList'
12:56:00 <HairyDude> damn you lambdabot
12:56:08 <mparodi> > fromList [1,2,3]
12:56:10 <lambdabot>   No instance for (GHC.Show.Show (m a))
12:56:10 <lambdabot>    arising from a use of `M1681388062...
12:56:17 <HairyDude> :t fromList
12:56:18 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
12:56:24 <HairyDude> wrong fromList :)
12:56:58 <mparodi> @instances Ord
12:56:59 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
12:57:10 * HairyDude kills the super-backjumping cabal-dev
12:57:24 <HairyDude> ... but the cabal process was still going... bloody Windows
12:58:48 <mparodi> @src fromList
12:58:49 <lambdabot> Source not found. My mind is going. I can feel it.
12:58:56 <mparodi> @src Data.Set.fromList
12:58:57 <lambdabot> Source not found.
12:58:58 <mparodi> >_>
12:59:36 <HairyDude> @quote
12:59:36 <lambdabot> Takusen says: One install script to rule them all, and in the darkness build them...
12:59:41 <Draggor> Using parsec, say I have a parser p  as Parser String, and I do (many p).  I want to join that resulting array into one string.  How would I do that?
13:00:05 <ski> `liftM concat (many p)' ?
13:01:14 <Draggor> huge success!
13:01:18 <Draggor> And that makes a lot of sense
13:01:23 <d-snp> hey unn
13:01:32 <Draggor> aaaaaaaand now my last test is passing, amazing
13:01:49 <shapr> yay!
13:02:15 <hpaste_> HairyDude pasted “cabal-dev install log” at http://hpaste.org/69954
13:02:46 <raek> I'm trying the excercises from the Typeclassopedia wiki article. Does anyone have an idea why my types are incorrect here? https://gist.github.com/2932538
13:03:43 <raek> the trouble is with the ITree instance
13:09:03 <HairyDude> for the node you're applying myFmap at the type (a -> b) -> [ITree a] -> [ITree b] which you can write as (a -> b) -> [] (ITree c) -> [] (ITree d)
13:09:47 <HairyDude> that tries to unify a = ITree c and b = ITree d
13:09:53 <HairyDude> but a = c and b = d
13:09:59 <startling> ugh, why doesn't Data.Time.Format let me do month of the year without a leading zero?
13:10:33 * HairyDude pokes dcoutts
13:11:16 <dcoutts> startling: I was wondering that yesterday, there's two forms for days, but not months
13:11:22 <HairyDude> dcoutts: cabal.exe is the one from the haskell platform
13:11:39 <dcoutts> startling: send the maintainer an email :-)
13:11:47 <dcoutts> startling: or better, a patch
13:11:57 <dcoutts> HairyDude: which version of the platform
13:12:02 <HairyDude> dcoutts: 2012
13:12:11 <HairyDude> .2
13:12:20 <dcoutts> HairyDude: so it's cabal-install-0.14.0 then right?
13:12:43 <HairyDude> correct
13:12:55 <startling> dcoutts: will do. any idea what the format string should be?
13:13:15 <dcoutts> startling: they're all rather arbitrary, your suggestion is as good as mine
13:13:44 <dcoutts> HairyDude: so it's the same version you're using
13:13:49 <HairyDude> yup
13:13:53 <geekosaur> see the glibc-style modifiers (as opposed to the POSIX sanctioned stuff which is somewhat arbitrary)
13:13:54 <raek> HairyDude: oh, I see now! thank you sir!
13:14:15 <HairyDude> raek: my pleasure :)
13:14:53 <Peaker> can a non-applied type family be given as a type parameter?
13:15:21 <illissius> Peaker: no
13:15:24 <HairyDude> Peaker: type synonym family, pretty sure no
13:15:28 <illissius> Peaker: a non-applied data family yes, though
13:15:34 <startling> dcoutts: looks like it.
13:17:11 <HairyDude> istr allowing you to pass type synonyms as parameters would break parametricity due to non-injectivity
13:18:14 <HairyDude> dcoutts: should I report a bug in cabal-dev?
13:18:25 <illissius> I asked this before, but: how do you go about figuring out what precedence your operators should be? just look at some existing operators and try to work out where they should stand in relation to them?
13:18:39 <dcoutts> HairyDude: did you work out how it's calling cabal?
13:18:49 <HairyDude> dcoutts: http://hpaste.org/69954
13:19:11 <HairyDude> Complete arguments to cabal-install:
13:19:11 <HairyDude> ["--config-file=D:\\MinGW\\msys\\1.0\\home\\Peter
13:19:11 <HairyDude> Berry\\cabaldev-bugtest\\cabal-dev\\cabal.config","install","--verbose=3"]
13:20:07 <dcoutts> HairyDude: right, so you ought to be able to reproduce it by using that config file
13:20:23 <dcoutts> HairyDude: and see if there's anything interesting in that config file
13:20:23 <HairyDude> dcoutts: the .cabal file?
13:20:38 <dcoutts> HairyDude: the --config-file=  bit
13:20:50 <HairyDude> ah, right
13:20:52 <dcoutts> it's not a .cabal file, it's a cabal config file
13:37:01 <HairyDude> dcoutts: success! cabal fails with that config file
13:37:34 <HairyDude> dcoutts: (took me a while to figure out what you wanted me to do...)
13:37:57 <dcoutts> HairyDude: can you post the config file
13:39:03 <hpaste_> HairyDude pasted “cabal.config that causes dependency resolution to fail” at http://hpaste.org/69955
13:39:06 <HairyDude> done
13:40:52 <dcoutts> HairyDude: so it's adding in an extra local source repository, and also a local installed package set
13:41:17 <dcoutts> HairyDude: you can get cabal-dev to tell you whats in the sandbox already
13:42:36 <HairyDude> dcoutts: the sandbox is empty
13:43:41 <HairyDude> dcoutts: (according to explorer, that is... how do you ask cabal-dev?)
13:44:25 <dcoutts> HairyDude: I don't use cabal-dev, but I know it has a way to add packages to the sandbox, I presume it lets you list them too
13:44:43 <dcoutts> but you can also look manually
13:45:17 <HairyDude> dcoutts: there's no such command that I can see, but looking manually I can see the sandbox just contains the index and cache and nothing else
13:46:01 <dcoutts> HairyDude: so that's the cabal-dev\packages-7.4.1.conf, what about the cabal-dev/packages ?
13:46:47 <HairyDude> cabal-dev\packages-7.4.1\package.cache, cabal-dev\packages\00-index.cache, cabal-dev\packages\00-index.tar
13:47:09 <strager> ls cabal-dev/lib/
13:47:18 <HairyDude> there is no such directory
13:47:28 <strager> Then no libs are installed, I'm guessing.
13:47:48 <HairyDude> there shouldn't be, all the deps are installed with the real cabal-install
13:48:02 * hackagebot hsx 0.10.4 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx-0.10.4 (NiklasBroberg)
13:48:09 <dcoutts> HairyDude: so you started with a clean sandbox then, and didn't use cabal-dev add-source ?
13:48:54 <HairyDude> dcoutts: 1) yesod init 2) cd cabaldev-bugtest 3) cabal-dev install
13:49:05 <HairyDude> dcoutts: that's it
13:49:38 <dcoutts> HairyDude: I've no idea what yesod init does, but if it's the one making the cabal-dev sandbox then it's almost certainly putting something into it
13:49:53 <luite> yesod init only generates a cabal project
13:49:54 <HairyDude> dcoutts: yesod makes a cabal file, but not the cabal-dev directory
13:49:59 <luite> doesn't do any cabal-dev stuff
13:50:04 <dcoutts> ok
13:50:36 <dcoutts> HairyDude: ok, then we need a log of using cabal normally, and also with the config file so we can compare
13:51:05 <HairyDude> dcoutts: ok, for using cabal normally does -v3 --dry-run suffice?
13:51:12 <dcoutts> yes
13:51:14 <HairyDude> ok
13:51:51 <dcoutts> HairyDude: and if you could tar up the cabal-dev dir, and then attach both logs and the tarball to a new cabal ticket, that'd be great.
13:52:16 * dcoutts notes that cabal now uses github's tracker, and hopes it's possible to add attachments
13:52:28 <HairyDude> dcoutts: you probably want the .cabal file as well?
13:52:34 <dcoutts> yes
13:54:23 <hpaste_> d-snp pasted “Typeable” at http://hpaste.org/69956
13:54:40 <d-snp> hey guys, I have a vague problem again for you guys to debate about :D
13:54:50 <d-snp> can I have a typeclass in my datatype definition?
13:54:54 <d-snp> somehow?
13:55:03 <mauke> d-snp: Dynamic?
13:56:00 <d-snp> mauke: let me check
13:57:09 <startling> anyone know a decent amount about heist? what's the best way to interpolate some html into a template? passing it as an argument escapes all the < and >; I could make it a template and pass it in, but I don't really need to parse the html.
13:57:28 <kamatsu> One common feature of sophisticated shell scripts is that they ask a lot of questions like:
13:57:42 <kamatsu> what herps should I derp? [foo, bar]:
13:58:01 <kamatsu> is there a library for asking a series of such questions in Haskell?
13:58:03 * hackagebot ixset 1.0.5 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-1.0.5 (JeremyShaw)
13:58:08 <kamatsu> it'd be nice if I didn't have to roll my own
13:58:27 <dcoutts> kamatsu: not afaik, though there's probably code from darcs or cabal-install you can steal
13:58:35 <dcoutts> but check hackage first too
13:58:46 <kamatsu> not exactly sure what I should look for
13:59:11 <Peaker> I want (forall t. Monad (m t)) => class constraint...
14:00:15 <bitonic> Peaker: what would be the use of the thing on the lhs?
14:00:54 <Peaker> currently I am trying something like:   data RO ; data RW ; data Property m a = Property { get :: forall t. m t a ; set :: a -> m RW () }
14:00:56 <k0ral> hi, I can't compile the gtk package, I'm getting "error: #error "Only <glib.h> can be included directly.", is this a known problem ?
14:01:12 <illissius> Peaker: http://hackage.haskell.org/trac/ghc/ticket/2893
14:01:13 <kamatsu> Peaker, a hack might be to re-write the monad class as a data type with return and bind as fields.
14:01:21 <Peaker> bitonic, I want to specify whether I have writes in my transaction monad type
14:01:24 <kamatsu> then you could use rank n types.
14:01:37 <bitonic> Peaker: but you can do that already with higher ranked type
14:01:43 <illissius> also includes a workaround-ish using GADTs
14:01:47 <bitonic> (your second example)
14:01:48 <dcoutts> k0ral: check the gtk2hs-users mailing list
14:02:22 <bitonic> Peaker: I still don't see how your first example could ever be useful, since you can't use the `t' on the rhs
14:02:50 <Peaker> bitonic, well, now I need to use (Property m a) but I can't say:  (forall t. Monad (m t)) => Property m a -> ...
14:02:59 <d-snp> mauke: awesome! thanks :)
14:03:21 <Peaker> bitonic, the idea is that "Property" takes a (*->*->*) type function that results in a monad for all types
14:03:23 <bitonic> Peaker: ok, so the m is quantified for the whole thing, right
14:03:29 <Peaker> bitonic, the first param is just a type-level tag
14:04:54 <Peaker> maybe I should use:  data Property mr mw a = ... get :: mr a ; set :: a -> mw ()         and then I can say: Property (forall t. m t) (m RW) ?
14:05:03 <bitonic> Peaker: you can't declare the class like that, but you can make sure that all your instances have no constraint on the `t'. but I'm sure you already know that
14:05:18 <Peaker> then I can express the Monad constraint there
14:05:28 <k0ral> dcoutts: no clue on gtk2hs-users archives
14:05:30 <Peaker> bitonic, I'm not declaring any classes
14:05:36 <k0ral> did I miss something ?
14:05:53 <dcoutts> k0ral: ok, try asking there, or the gtk2hs-devel list
14:06:04 <Catnaroek> Hello. I am writing a program that uses a state transformer monad to update a collection of people indexed by their names: http://hpaste.org/69957 . I would like to insert validations such that, if any of they fail, the whole "insert person" operation fails and raises an exception. Anyone can help me?
14:06:26 <bitonic> Peaker: ok... so why can't you use GADTs to put a constraint on the constructor?
14:06:27 <dcoutts> k0ral: my guess is you're running a new glib and they've tightened up the rules for their header files
14:07:01 <Peaker> Catnaroek, the "modify" method is useful for   x<-get; put (f x)   patterns
14:07:14 <Peaker> bitonic, oh, maybe I can...
14:07:18 <Catnaroek> Peaker: I know, but I have to insert validations in between.
14:07:19 <Peaker> bitonic, I'll try
14:07:43 <bitonic> Peaker: I'm fairly sure that you can
14:08:29 <Catnaroek> I have been looking for another monad (which I could compose with my state transformer monad using a monad transformer), which would let me compose my validations sequentially.
14:09:55 <byorgey> Catnaroek: is a simple failure enough, or do you also want to propagate an error message?
14:10:14 <byorgey> Catnaroek: sounds like you want MaybeT or ErrorT
14:11:10 <bitonic> Peaker: wait, no. I'm confused tonight.
14:11:20 <Catnaroek> byorgey: I would rather throw an exception right when the first problem is detected.
14:11:33 <bitonic> Peaker: you can put constraints on the data constructor, not on the typecon.
14:12:06 <bitonic> Peaker: but the "solution" to your problem is simply to use smart constructors and a bit more verbose type signatures
14:12:08 <Catnaroek> byorgey: How do I use ErrorT? (I think MaybeT would not let me output specific error messages, but I may be mistaken.)
14:12:17 <byorgey> Catnaroek: yes, I understand, that's what MaybeT or ErrorT give you
14:12:27 <byorgey> Catnaroek: correct
14:12:30 <byorgey> that's
14:12:37 <hpaste_> Peaker pasted “GADT constraints” at http://hpaste.org/69958
14:12:46 <importantshock> Is it possible, using cmdargs (0.9.5), to get a list of unrecognized options rather than failing when an unrecognized option is found?
14:12:51 <byorgey> that's what I was trying to get at with my question before
14:13:01 <Catnaroek> byorgey: Oh.
14:13:25 <hpaste_> Peaker annotated “GADT constraints” with “GADT constraints (annotation)” at http://hpaste.org/69958#a69959
14:14:01 <Peaker> I've never noticed this problem with GADTs before -- the type system can't express their yielding of class constraints out to the user
14:14:38 <byorgey> Catnaroek: with ErrorT you can use throwError to generate an error and catchError to catch it
14:14:39 <applicative> Catnaroek: shouldn't this validation function be written separately?  coolWith :: Map -> Person -> Maybe String or whatever
14:14:58 <byorgey> Catnaroek: see http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Error.html
14:15:18 <rwbarton> Peaker, that GADT is exactly just an existential
14:15:21 <d-snp> I'm starting to like haskell
14:15:32 <byorgey> d-snp: =)
14:15:40 <Catnaroek> applicative: Why?
14:15:45 <mparodi> how do I do something like "if (x = foo y /= Nothing) then f1 x else if (x = bar y /= Nothing) then f2 x else 0"?
14:15:46 <Peaker> rwbarton, what if the "m" was a type param of the GADT?
14:15:55 <c_wraith> Peaker: I think you can express that with a rank-2 type.
14:15:56 <rwbarton> then it would not be an existential
14:15:56 <bitonic> Peaker: that is an existential in disguise. You want `(forall m. Monad m => m ()) -> WithClass'
14:16:18 <rwbarton> but it would still provide a dictionary
14:16:20 <c_wraith> oh, nevermind
14:16:35 <bitonic> Peaker: wich is different from `Monad m => m () -> WithClass'
14:16:36 <byorgey> mparodi: like that, except (x == foo && y /= Nothing)
14:16:42 <hpaste_> Peaker pasted “GADTs again” at http://hpaste.org/69960
14:16:46 <applicative> well, it just seems like a pure function, but nevermind,it's always good to throw another transformer on... :)
14:17:06 <mparodi> @hoggle except
14:17:07 <lambdabot> Control.Exception module Control.Exception
14:17:07 <lambdabot> Control.Exception.Base class (Typeable e, Show e) => Exception e
14:17:07 <lambdabot> Control.Exception class (Typeable e, Show e) => Exception e
14:17:16 <bitonic> Peaker: I'm still not sure about what you want to do :P
14:17:18 <mparodi> byorgey, can you explain me?
14:17:42 <Peaker> bitonic, I want the caller of "f" to not have to prove "m" is a Monad, but in fact get that proof by using f's return value
14:17:50 <byorgey> mparodi: which part are you confused about?
14:17:51 <Catnaroek> applicative: I want to simplify the interface for the user, even if it is at the cost of potentially raising exceptions.
14:18:03 <rwbarton> that is what your previous paste does
14:18:25 <mparodi> byorgey, how is that "(x == foo && y /= Nothing)" means the same I'm trying to do?
14:18:40 <bitonic> Peaker: so you want that signature and `f (WithClass x) = x'? it would work with the type sig I provided for the constructor
14:18:42 <Peaker> rwbarton, but the newest paste does have the monad instance proof inside the WithClass constructor?
14:19:04 <byorgey> mparodi: no, I meant to replace (x = foo y /= Nothing) with what I wrote
14:19:05 <hpc> mparodi: oh, you want something like C-style assignment expressions?
14:19:29 <Peaker> bitonic, well, all type signatures involving a covariant class constraint means the caller provides the class constraint, but it is "f" which should provide it
14:19:50 <byorgey> mparodi: maybe you should explain what exactly you are trying to do
14:19:56 <hpaste_> bitonic annotated “GADT constraints” with “GADT constraints (annotation) (annotation)” at http://hpaste.org/69958#a69961
14:19:57 <mparodi> the behavior I want to achieve is the same as here:     if (x /= Nothing) then f1 x else if (y /= Nothing) then f2 y else 0 where x = foo z; y = bar z
14:20:17 <rwbarton> Peaker, no
14:20:42 <bitonic> Peaker: I don't follow
14:20:51 <rwbarton> the latest paste has a WithClass constructor which contains a value of type m () but only for those types m that are Monad instances
14:20:57 <mparodi> byorgey, hpc: http://paste.kde.org/499910
14:21:00 <byorgey> mparodi: ohhhh, I see now, I misunderstood before, sorry
14:21:00 <rwbarton> so if you want to get the m () out, you need to provide a Monad m instance
14:21:02 <mparodi> it's pretty verbose, isn't it?
14:21:06 <Peaker> bitonic, in your example, if I try to call f with  m = forall any. n any       I will fail to compile because I need to provide   Monad (n any)
14:21:52 <byorgey> mparodi: doesn't
14:21:59 <byorgey> sorry
14:22:01 <Peaker> rwbarton, oh, right. so a GADT doesn't help me at all
14:22:11 <byorgey> mparodi: doesn't look that bad to me =)
14:22:29 <Azel> mparodi: Couldn't you do what you want with maybe ? Like that: maybe (maybe 0 f2 y) f1 x ?
14:22:37 <byorgey> mparodi: anyway, no, there's no way to do what you are asking that I know of
14:22:45 <mikeplus64> mparodi: the way people tend to chain up ifs/thens/elses like they would in other languages is by using guards
14:22:54 <Peaker> rwbarton, I have a Transaction monad, and I want to type-differentiate read-only from read-write transactions
14:23:06 <mparodi> mikeplus64, how would you do http://paste.kde.org/499910 using guards?
14:23:08 <thinker341> dumb question : So, i want to get user account balance at big bank, If i write a function for Account number, it wouldn't give me same result every time, this is where we use Monads?
14:23:23 <mikeplus64> mparodi: just a sec :)
14:23:24 <Peaker> rwbarton, and I have:  data Property m a = Property { get :: m a, set :: a -> m () }        that I use with the Transaction monad a lot
14:23:25 <byorgey> Azel: that's not quite the same.  but it is strange to be calling f1 on x rather than pattern-matching x first
14:23:41 <shachaf> thinker341: The short answer is "no".
14:24:17 <Peaker> rwbarton, I am wondering how to change Transaction and Property so that if you do read-only stuff you get a read-only transaction (including using just "get" from properties) and if you also use writable stuff, you get a writable transaction
14:24:20 <bitonic> Peaker: ok... but that doesn't have to do with how you construct your datatype. I'd like a specific example so I can "see" the problem :)
14:24:22 <mikeplus64> mparodi: http://hpaste.org/69962
14:24:33 <shachaf> thinker341: I think the FAQ has is a good resource for this.
14:24:36 <shachaf> @where faq
14:24:36 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:24:40 <mikeplus64> mparodi: hpaste is good enough to tell us that we can use isJust too, heh
14:24:54 <thinker341> shachaf : thx
14:24:56 <bitonic> Peaker: can't you just tag the Transaction? e.g. `data Transaction m transaction_type a = ...'?
14:25:11 <mparodi> that seems better
14:25:13 <mparodi> thanks!
14:25:25 <mikeplus64> np
14:25:29 <bitonic> Peaker: and `instance Monad (Transaction m transaction_type)'
14:25:46 <byorgey> yeah, isJust is better since it doesn't require an Eq constraint on the type wrapped by Maybe
14:25:53 <Azel> byorgey: Why isn't that the same ?
14:26:04 * shachaf tries to figure out the context of what Peaker is doing.
14:26:57 <Azel> If f1 and f2 both return the same type (which must be an instance of Num), I don't see the difference...apart that it might seem strange, that much is true
14:26:58 <byorgey> Azel: because in your version f1 will be called on the contents of Just, when x is constructed with Just
14:27:06 <byorgey> Azel: but
14:27:13 <Azel> Didn't see that, sorry
14:27:17 <wl2u> is there anyway to avoid using lambda and variable names for: \x y -> snd x == snd y ?
14:27:21 <HairyDude> dcoutts: https://github.com/creswick/cabal-dev/issues/59 <- I can't see how to attach a file
14:27:23 <byorgey> but mparodi's version called it on x itself
14:27:25 <shachaf> ((==) `on` snd)
14:27:47 <hpaste_> Peaker pasted “Transaction” at http://hpaste.org/69963
14:27:52 <dcoutts> HairyDude: oh I meant reporting against cabal, though attachements would work the same
14:27:59 <byorgey> Azel: no worries. I like your version better anyway =)
14:28:01 <HairyDude> dcoutts: ah, oops
14:28:01 <parcs`> :t (== EQ) .: comparing snd
14:28:02 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Bool
14:28:15 <Peaker> bitonic, I can tag the transaction type, but how would Property work?
14:28:15 <mparodi> byorgey, http://hpaste.org/69962 <- is the same? what difference do you see?
14:28:28 <mparodi> s/?//
14:28:31 <Peaker> bitonic, the simple Property datatype gives you a get/set pair in the same monad
14:28:52 <byorgey> mparodi: line 3 should have f2 y
14:28:57 <Peaker> bitonic, if that monad is the RW transaction type, then even getting values will type as RW transaction
14:29:05 <byorgey> other than that it looks equivalent to me
14:29:08 <mparodi> ah, yes, a typo I guess
14:29:09 <dcoutts> HairyDude: hmm, I didn't realise it didn't support attachements at all
14:29:47 <bitonic> Peaker: `m = Transaction n whatever'? I don't get why you need the notion of read/write in the definition of Property
14:29:49 <Peaker> bitonic, if it has different monads for get/put then the monad you use for get is still problematic because it better be polymorphic, otherwise you'll need explicit lifting from RO to RW everywhere
14:29:50 <dcoutts> HairyDude: I guess just submit them as comments
14:29:58 <bitonic> Peaker: you can put that in the single function definitions
14:30:04 <byorgey> mparodi: it is a little strange to check whether x and y are nothing and then pass them along to f1 and f2 without taking off the Just
14:30:38 <Peaker> bitonic, When you build a property, you will be forced to always build   Property (Transaction RW m) a       (because there's a setter in there)
14:30:40 <bitonic> Peaker: also, that newtype is wrong, it should be `newtype Transaction m t a = ...' - probably a typo
14:30:40 <byorgey> mparodi: now you have "forgotten" that x or y is not Nothing, and f1 and f2 will have to do a case analysis all over again
14:30:41 <mparodi> yes, I'll add a fromJust
14:30:47 <byorgey> no!
14:30:54 <byorgey> pattern-match
14:31:06 <byorgey> fromJust is worse =)
14:31:11 <bitonic> Peaker: well then `buidProperty :: Property (Transaction RW m) a', or whatever
14:31:17 <Peaker> bitonic, the idea is that the "m" in Transaction is a monad, and the "m" below is a type-function making a monad
14:31:27 <byorgey> repeat after me: "I will never use fromJust"
14:31:32 <Peaker> bitonic, but then you can't use Properties to build RO transactions
14:31:40 <adamt> So i heard fromJust is awesome
14:31:41 <Peaker> bitonic, even though you only use "get"
14:32:01 <bitonic> Peaker: ok wait a second. let me write something down
14:32:06 <mparodi> byorgey, how do you do a pattern matching to remove the Just in that case? x@(Just p) ?
14:33:17 <mparodi> (instead of x /= Nothing)
14:33:18 <bitonic> Peaker: 1) that property would be a typeclass, in my world
14:33:20 <hpaste_> byorgey annotated “guards” with “guards (annotation)” at http://hpaste.org/69962#a69966
14:33:27 <byorgey> mparodi: ^^^ like that
14:33:57 <Peaker> bitonic, What instances would the Property type-class have?
14:33:59 <byorgey> @slap adamt
14:33:59 * lambdabot smashes a lamp on adamt's head
14:34:05 <mparodi> what is x'?
14:34:10 <mparodi> interesting..
14:34:16 <Peaker> bitonic, I don't think it makes a big difference, anyhow
14:34:37 <byorgey> mparodi: it says if x matches Just, then call the contents x'
14:34:49 <byorgey> adamt: =)
14:35:05 <mparodi> great! how is it called? it wasn't in the book I read >_>
14:35:13 <Catnaroek> Hello. Can I provide "deriving" for my own type classes?
14:35:50 <bitonic> Peaker: 2) I wouldn't have a `forall t. Monad (m t)'. I would have it to be a monad only for the right tags (e.g. RO, RW)
14:35:58 <roconnor> Catnaroek: more or less no.
14:36:04 <byorgey> mparodi: pattern guards, like it says at the top =)
14:36:23 <Peaker> bitonic, that's a problem, because Property.get must be polymorphic for (forall t. m t)
14:36:27 <mparodi> hmn, yes.. but the use of ' wasn't mentioned
14:36:36 <bitonic> Peaker: why?
14:36:38 <rwbarton> there is no "use of '"
14:36:51 <rwbarton> x' is just a name
14:36:55 <Peaker> bitonic, so that you can use the same property to build both RO and RW transactions
14:37:38 <mparodi> do you mean he could put p' instead? rwbarton
14:37:54 <Peaker> bitonic, I use a Property as sort of a first-class mutable-value in my data store.   I have an "outer" RO transaction that uses the properties for reads only, and generates a data structure that contains RW transactions built from the same properties
14:38:02 <rwbarton> Peaker, I think you should paste enough code to get to the point where you want to write the hypothetical (forall t. Monad (m t)) constraint on a function, otherwise this is going nowhere
14:38:03 <parcs`> Catnaroek: you can provide default instances for your class with the DefaultInstances extension, so one can create an instance of your class simply by writing 'instance Foo Bar'
14:38:19 <byorgey> Catnaroek: sort of, yes, using GHC's generics
14:38:24 <ahkurtz> byorgey: can you say anything about how pattern guards are implemented? do they end up as actual branches in assembly? is there some universal function that inspects objects on the heap and looks at a type field or something?
14:38:27 <greg`> noob question here
14:38:38 <greg`> how can i check that an element is a member of a list
14:38:42 <parcs`> :t leem
14:38:43 <lambdabot> Not in scope: `leem'
14:38:48 <rwbarton> mparodi, sure, p' is just a name too
14:38:53 <parcs`> greg`: elem
14:38:53 <mparodi> then it doesn't work. in the first case it was asking x /= Nothing and y /= Nothing. now it doesn't say if it's x or y that it must match
14:38:53 <rwbarton> x' is related to x only by convetion
14:38:57 <greg`> thanks
14:39:24 <mparodi> ahhhhh, never mind. I didn't notice the "<- x" and "<- y"
14:39:27 <mparodi> nice, thank you!
14:39:27 <byorgey> ahkurtz: I haven't the faintest idea.  note, however, that types are erased before runtime, so there is no such thing as a "type field"
14:39:32 <Catnaroek> byorgey: I have the following situation. I have three types "newtype A = A { name :: String }", "newtype B = B { name :: String }" and "newtype C = C { name :: String }""
14:39:42 <Catnaroek> byorgey: I would like name to be a polymorphic function of a type class.
14:39:51 <greg`> is there a lazy version of elem|
14:39:52 <greg`> ?
14:40:04 <rwbarton> a what?
14:40:05 <Peaker> rwbarton, let me minimalize the irrelevant parts out
14:40:13 <rwbarton> lazy in what regard
14:40:45 <greg`> such that not all of the elements of the list need to be evaluated
14:40:45 <byorgey> Catnaroek: I see.  Yes, I think you can do that with generics -- though it might be more trouble than it's worth
14:40:56 <greg`> im reading the list from a file lazily
14:40:58 <rwbarton> elem doesn't do more work than it has to.
14:41:07 <rwbarton> Why would you think it does?
14:41:11 <byorgey> Catnaroek: http://www.haskell.org/haskellwiki/GHC.Generics
14:41:18 <greg`> thanks ... dunno just checking
14:41:25 <byorgey> there
14:41:33 <JoeyA> Why is the categorical dual of Functor just a Functor?  If I take (a -> b) -> f a -> f b (the type of fmap) and flip the arrows around, I get: (a -> b) -> f a -> f b.  This appears to have nothing to do with the original fmap.
14:41:35 <byorgey> blargh, new keyboard
14:41:39 <geekosaur> Catnaroek, http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields may do what you want already
14:41:44 <hpaste_> bitonic annotated “Transaction” with “Transaction (annotation)” at http://hpaste.org/69963#a69967
14:41:55 <bitonic> Peaker: so wait, why isn't the above good?
14:41:56 <JoeyA> err
14:42:00 <JoeyA> f b -> f a -> (b -> a)
14:42:43 <Peaker> bitonic, it's specific to Transactions.. might be good enough though
14:42:51 <sclv> look at the categorical arrows of a functor, not the haskell typeclass!
14:42:56 <byorgey> JoeyA: there are many possible sorts of categorical duality.  Anyone who says you get "the" categorical dual by flipping all the arrows is lying or confused.
14:42:59 <rwbarton> "categorical dual" isn't a terribly precise term and "flip the arrows around" needs to be interpreted in an intelligent way
14:42:59 <bitonic> Peaker: you can generalise it
14:43:12 <greg`> er although there is a version of ByteString.Lazy.elem
14:43:37 <mk12> In haskell, what structure should I use for a program that uses the periodic table? It would need to parse strings as elements and look up data for each element such as names in different languages and charges. I started writing "data Element = H | He | Li | Be | B | C | N | O | . . .
14:43:40 <geekosaur> that's about the laziness of the bytestring, not of elem
14:43:43 <bitonic> Peaker: think about what you need and not what you want :)
14:43:45 <hpaste_> Peaker pasted “Problematic code” at http://hpaste.org/69968
14:43:46 <rwbarton> greg`, I thought you wanted to check whether a value is an element of a list
14:43:47 <mk12> " but I'm not sure if that's the best approach
14:43:57 <startling> mk12: data Element = Element Int
14:44:12 <Peaker> rwbarton, bitonic: more concrete paste
14:44:33 <bitonic> Peaker: that's no good, because you'll never be able to put a Monad constraint. Just have `any' as a param to the tycon
14:44:52 <bitonic> (tycon being Property)
14:44:55 <startling> mk12: though I wouldn't write this data in haskell; use json or a db or something and read from it
14:44:59 <mk12> and then I would have very long functions definitions of charges :: Element -> [Int], englishName :: Element -> String, etc
14:45:05 <Peaker> bitonic, yeah, interesting idea
14:45:15 <mk12> yes, I was thinking of that
14:46:02 <mk12> what kind would work well with Haskell? json you think?
14:46:06 <greg`> yes i do
14:46:10 <Peaker> bitonic, might as well go with "mr" and "mw" monad params for Property
14:46:17 <bitonic> Peaker: but you're basically doing what GHC does to compile typeclasses manually... I'd have a PropertyMonad or whatever. Unless you need high composability
14:46:18 <Peaker> bitonic, then I can use IO IO
14:46:27 <byorgey> what does json have to do with anything?
14:46:31 <startling> mk12: dunno. json might get clumsy since it'd be a giant plaintext file.
14:46:36 <greg`> i want to check whether a ByteString is an element of a [ByString]
14:46:42 <roconnor> JoeyA: the problem is that the catogrical dual only flips some arrows and not others.  And knowing which arrows to flip requires a fairly deep understanding of the categorical derivation of the type in question.
14:46:54 <ion> IO! IO! Cthlambda fhtagn!
14:47:22 <tommd> greg` so just use the 'elem' function.
14:47:38 <JoeyA> roconnor: Okay, thanks.
14:47:46 <roconnor> JoeyA: in the case of fmap the most common intepretation of (a -> b) -> (f a -> f b), the categorical dual will only flip the arrows in (a -> b) and (f a -> f b).  The other arrow is a sort of "meta-arrow" that has been internalized in Hask.
14:48:03 <mk12> startling: any suggestions for a db then? sqlite or something?
14:48:09 <greg`> so my compiler was like hey do you want to use ByteString.elem or Prelude.elem, what the diffence?
14:48:14 <S11001001> mk12: well, with the enumeration you have, you can derive pretty useful Read, Show, Ord, Enum instances
14:48:26 <sclv> roconnor: that's a very nice way to put it.
14:48:28 <startling> mk12: I've never used any dbs in haskell, but I would try sqlite, yeah
14:49:05 <roconnor> JoeyA: this is easier to see in the interal Haskell categorical functor where that has type fmap :: (a ~> b) -> (f a ~> f b)
14:49:13 <rwbarton> ByteString.elem is for checking whether a byte is an element of a ByteString.
14:49:16 <rwbarton> As its type indicates.
14:49:19 <fuchsto> Let's say i have an IOArray Int Float and i want to iterate it - how do i do that?
14:49:22 <mk12> startling: ok I'll look around here http://www.haskell.org/haskellwiki/Database_interfaces
14:49:22 <bitonic> Peaker: also, you can simply have `get :: m RO a', and then you can probably have something like `m RO a -> m RW a', if your transaction are hierarchical that way
14:49:26 <roconnor> well I guess the two twiddles don't even have to be the same
14:49:48 <Peaker> bitonic, I could write a lifter but that might get tedious
14:49:50 <rwbarton> greg`: You probably want to import Data.ByteString qualified to avoid these name clashes.
14:50:00 <geekosaur> greg`, ByteStrings are not lists but they emulate lists to some extent, so there is a ByteString-specific version of elem.  But they can't actually have literally the same name, so if you just say "elem" and you have both versions in scope it complains.  figure out what you're working on and specify that one, or hide the one you don't need on import
14:50:00 <mparodi> can you write a pattern for an argument in terms of another argument? like in Prolog:  let foo (t@(n, _) : _) n = t; foo (_:ts) n = foo ts n
14:50:04 <geekosaur> or that
14:50:22 <rwbarton> mparodi, no
14:50:23 <startling> mk12: and then have "data Element = Element {names :: [(Language, Name)], charges :: [Int]}" etc
14:50:24 <roconnor> fmap :: (a ~> b) -> (f a ≈> f b)
14:50:34 <mparodi> it would be nice :P
14:50:43 <rwbarton> a variable can only appear once in a pattern
14:50:46 <bitonic> Peaker: well there are a thousand way to ease the pain ehe :)
14:50:47 <greg`> thanks guys
14:50:49 <rwbarton> it would have sort of complicated semantics
14:51:16 <rwbarton> you can just write let foo (t@(n, _) : _) n' | n == n' = t; foo (_:ts) n = foo ts n
14:51:38 <Peaker> back to my original question, though:      data Foo a where Constraint a => FooCons :: a -> Foo a       "Foo a" is supposed to contain evidence that "a" is constrained, right?
14:51:56 <mparodi> ok
14:51:57 <fuchsto> there is readArray and writeArray, but those only work on a single index. Can i map over it?
14:52:01 <Peaker> if I:   case x of FooCons y -> ... y's type is constrained here ...
14:52:10 <shachaf> Yes.
14:52:16 <wl2u> how can I express the following predicate on lists without list comprehensions (with and/or operator):  (forall x in xs. forall y in ys. x < y => x = 0) ?
14:52:18 <rwbarton> Peaker, if you fix the syntax of your data declaration, yes
14:52:22 <Peaker> but if I write:  getFoo (FooCons x) = x    the type of getFoo cannot expose the constraint
14:52:35 <rwbarton> right
14:52:39 <Peaker> rwbarton, oops, FooCons :: before constraint :)
14:53:08 <Peaker> getFoo can only demand the constraint, it cannot yield it, iiuc
14:53:29 <rwbarton> just like there are no first class existentials
14:53:55 <Peaker> ah, ok, so I do understand correctly
14:54:04 <mparodi> a built in function (not . null) would be nice too
14:54:16 <JoeyA> wl2u: Filter out the 0s, and make sure all the remaining items are equal?
14:54:24 <shachaf> Could you write something a CPSed getFoo to expose the constraint?
14:54:27 <Peaker> mparodi, what better name is there for (not . null) than "(not . null)" ? :)
14:54:28 <bitonic> Peaker: what do you mean `cannot expose the constraint'? it depends if you have an existential or not
14:54:35 <rwbarton> and in the same way you can write getFoo :: Foo a -> (Constraint a => a -> b) -> b; getFoo (FooCons x) f = f x
14:54:40 <shachaf> getFoo :: Foo a -> (Constraint a => a -> r) -> r
14:54:42 <mparodi> Peaker, notNull
14:54:43 <mparodi> :)
14:54:47 <shachaf> ...What rwbarton said.
14:55:05 <bitonic> Peaker: the syntax is confusing, but with an higher ranked type as I wrote before you will be able to get the constraint out
14:55:07 <bitonic> btw
14:55:33 <wl2u> JoeyA well, that is only an example, I want to know if there are any neat way of expressing logical checks on lists in Haskell, a "DSL"
14:56:17 <rwbarton> there is notElem for some reason
14:56:31 <Peaker> rwbarton, I am not sure I deeply understand the rule about when constraints can be floated out. I thought, until now, that it only had to do with the scope of the constrained variables or the covariance
14:56:34 <bitonic> Peaker: you can get it out with an existential as well if you have the type param exposed
14:56:58 <bitonic> as in the "Foo" example
14:56:58 <Peaker> bitonic, but there's no "forall" or existential here, only ordinary type params for my GADT
14:57:33 <rwbarton> what do you mean "floated out"
14:57:35 <Peaker> rwbarton,   is   "return :: a -> Monad m => m a"  different from "return :: Monad m => .." ?
14:57:36 <bitonic> Peaker: in `data Foo a where; Foo :: Ord a => a -> Foo a', you can write a `getFoo :: Ord a => Foo a -> a'
14:57:42 <rwbarton> they are the same
14:57:53 <mparodi> oh, wait! there's a notElem and there's not a notNull
14:57:55 <rwbarton> :t return :: a -> Monad m => m a
14:57:56 <lambdabot>     Could not deduce (Monad m) from the context ()
14:57:56 <lambdabot>       arising from a use of `return' at <interactive>:1:0-5
14:57:56 <lambdabot>     Possible fix:
14:57:59 <mparodi> Haskell is incomplete
14:58:01 <rwbarton> what
14:58:14 <Peaker> rwbarton, oh, it did become contravariant in your/shachaf's example...
14:58:16 <bitonic> rwbarton: you're missing the forall?
14:58:35 <bitonic> :t return :: a -> (forall m. Monad m => m a)
14:58:36 <lambdabot>     Inferred type is less polymorphic than expected
14:58:36 <lambdabot>       Quantified type variable `m' escapes
14:58:36 <lambdabot>     In the expression: return :: a -> (forall m. (Monad m) => m a)
14:58:42 <shachaf> Works for me in ghci.
14:58:43 <rwbarton> it works in my ghci
14:58:48 <shachaf> Must be something about lambdabot's version of GHC.
14:59:02 <hpc> ?version
14:59:02 <lambdabot> lambdabot 4.2.2.1
14:59:02 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:59:05 <Cale> wl2u: all (\x -> all (\y -> not (x < y) || x == 0) ys) xs
14:59:10 <shachaf> I think it's 6.12?
14:59:16 <hpc> ?ghc-ver
14:59:16 <lambdabot> Unknown command, try @list
14:59:32 <fragamus> offtopic: I'm trying to set up colloquy on my iPhone so I can access #haskell but I am having problems. There is no help to be had on the support room for colloquy.  Is there anyone out there who can help?
14:59:37 <hpc> anyone know any ghc bugs we can try out?
14:59:38 <Peaker> shachaf, rwbarton, bitonic: OK, I see now.. by using CPS, you can get a contravariant constraint, so can expose it out
14:59:49 <hpc> or ask Cale i suppose
15:00:06 <shachaf> hpc: Or just not care.
15:00:10 * shachaf often uses that approach.
15:00:11 <hpc> that works
15:00:12 <Cale> yeah, it's 6.12.3
15:00:20 <rwbarton> > compilerVersion
15:00:21 <lambdabot>   Not in scope: `compilerVersion'
15:00:29 <Peaker> @hoogle version
15:00:29 <lambdabot> Data.Version module Data.Version
15:00:29 <lambdabot> Data.Version Version :: [Int] -> [String] -> Version
15:00:29 <lambdabot> Data.Version data Version
15:00:32 <rwbarton> > System.Info.compilerVersion
15:00:33 <lambdabot>   Not in scope: `System.Info.compilerVersion'
15:00:47 <Cale> I should maybe update it, except that most of the new features aren't things which are easily checked for just by evaluating expressions.
15:01:12 <bitonic> fragamus: try on #haskell-blah
15:01:20 <shachaf> 6.12 supports some impredicative types that 7.0 doesn't!
15:01:21 <shachaf> I think.
15:01:53 <HairyDude> dcoutts: FYI, on github you're apparently supposed to use git repos to store test cases. Which I have done
15:19:12 <comak> hi, can anyone point me how to `easily` embed haskell interperer (ghc-api?) in c/c++ code?
15:20:59 <hpc> what do you need it to do?
15:21:20 <hpc> if you are particularly ridiculous, you can pipe in and out of ghci with an IPC library
15:21:34 <hpc> or just use mueval
15:23:16 <comak> i'd like to embed in in some soft as a plugin
15:24:28 <S11001001> why the "easily" qualifier, comak?
15:25:01 <comak> not requier to recompile all ghc/libs with -fPIC -shared
15:25:11 <comak> i'd stuck on  this
15:26:19 <greg`> quick way to convert a strict bytestring into a lazy bytestring anyone?
15:26:38 <comak> i played a little with hint and calling it via FFI but it was pain in the ass and i can't finish it
15:27:31 <mauke> greg`: fromChunks [bs]
15:28:21 <bitonic> comak: that's not going to be easy, there is no ready made solution to embed haskell code in C
15:28:29 <bitonic> but you can call haskell functions from C
15:28:39 <bitonic> so maybe that helps?
15:28:43 <greg`> thanks
15:29:13 <HairyDude> @hoogle Data.ByteString.ByteString -> Data.ByteString.Lazy.ByteString
15:29:14 <lambdabot> Parse error:
15:29:14 <lambdabot>   Data.ByteString.ByteString -> Data.ByteString.Lazy.ByteString
15:29:14 <lambdabot>       ^
15:29:17 <HairyDude> sigh.
15:29:34 <bitonic> @hoogle fromChunks
15:29:34 <hpc> @hoogle chunks
15:29:34 <lambdabot> package chunks
15:29:34 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
15:29:34 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
15:29:34 <lambdabot> Data.ByteString.Lazy fromChunks :: [ByteString] -> ByteString
15:29:34 <lambdabot> Data.ByteString.Lazy.Char8 fromChunks :: [ByteString] -> ByteString
15:29:36 <lambdabot> Data.Text.Lazy fromChunks :: [Text] -> Text
15:29:48 <hpc> @hoogle toChunks
15:29:49 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
15:29:49 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
15:29:49 <lambdabot> Data.Text.Lazy toChunks :: Text -> [Text]
15:30:00 <hpc> use fromChunks
15:30:13 <hpc> i think that's [S.BS] -> L.BS
15:30:29 <HairyDude> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#v:fromChunks
15:30:46 <HairyDude> the use of "ByteString" there is equivocal :(
15:30:54 <bitonic> HairyDude: click on it
15:31:29 <bitonic> it's from list of strict BS to lazy
15:32:08 <HairyDude> bitonic: ah. but if you used that type signature in actual code, the two "ByteString"s would be the same.
15:32:12 <comak> bitonic: not realy, haskell module must be -shared -fPIC to do so - ghc-api and some base libs aren't
15:32:41 <bitonic> comak: recompile
15:32:44 <bitonic> ah
15:32:54 <bitonic> ghc-api might be a problem. might
15:33:11 <HairyDude> isn't ghc usable somehow as a library?
15:33:20 <armlesshobo> what are "dyn" libraries?
15:33:24 <bitonic> comak: but I wasn't proposing that solution. I was saying that maybe for him calling haskell functions would be enough
15:33:40 <bitonic> armlesshobo: libs that can be dynamically linked?
15:33:43 * bitonic is guessing
15:34:23 <comak> bitonic: i nead full compiler/interpreter
15:34:46 <bitonic> actually yeah, I vaguely remember compiling everything twice on arch, and "dyn" were the .so files
15:35:16 <bitonic> comak: yeah, then it's not going to be easy. or at least, I am not aware of a ready made thing.
15:35:24 <comak> not good
15:35:32 <armlesshobo> bitonic: well, I thought that when I installed the library, it came with it. but, i guess i was wrong.
15:35:52 <armlesshobo> is there a seperate procedure to allow libs to be built so that I can dynamic link them?
15:35:58 <bitonic> comak: it's not a common use case
15:36:07 <bitonic> but yeah, I guess you aren't happy ehe
15:36:10 <comak> there are some .dyn|.so libs for ghc form archlinux but thats not enougth
15:36:38 <comak> bitonic: i find it strange why libs arent compiled with -fPIC -shared
15:37:15 <bitonic> @google dynamic linking ghc
15:37:18 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/DynamicLinking
15:37:18 <lambdabot> Title: SharedLibraries/PlatformSupport – GHC
15:37:27 <bitonic> comak: GHC by default builds everything statically
15:38:37 <bitonic> comak: either you change that or you'd have to build every lib one more time
15:38:48 <bitonic> and one more for the version with profiling
15:38:51 <comak> bitonic: hmm i can find all libs with dyn_hi files
15:38:58 <comak> on my default arch install
15:39:55 <bitonic> and one more for ghci
15:39:56 <bitonic> and....
15:39:56 <bitonic> comak: arch installs dyn libs as well, iirc.
15:39:56 <bitonic> cabal doesn't (by default)
15:40:47 <comak> but their still unsiutable as i recall ;]
15:40:55 <bitonic> comak: for what?
15:41:01 <comak> for ffi
15:41:37 <bitonic> comak: ? why?
15:41:57 <davesq> any recommendations on packages for working with ZIP archive files?
15:42:00 <comak> their are not PIC afair -- but i can be wrong now - that was some time ago i'd try it (mounth maybe)
15:42:06 * HairyDude gives up on windows yesod development and installs virtualbox
15:42:27 <comak> i'll give it a try in weekend - will see what happens ;]
15:42:40 <bitonic> comak: does that prevent C calling haskell? have you read this: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C , for example?
15:42:47 <fragamus_> Yeeeeehaaaaaa!!!!! Im on my app thingy on my phone using #haskell
15:42:53 <HairyDude> ello :)
15:43:27 <comak> bitonic: if you want bin maybe not if you want to make an .so there is problem
15:43:47 <bitonic> comak: well sure, but that's another question
15:44:25 <comak> i need an .so so thats why ghc lib are not suitable for me
15:45:18 <comak> but as i said i may be wrong - haven't my code in front of me to test :(
15:45:24 <bitonic> comak: it's still not clear to me what you need to do
15:45:52 <comak> i want an haskell intepreter/compiler shipped as .so
15:46:17 <bitonic> comak: ...so you want a .so with a function that interprets haskell?
15:46:21 <comak> yes
15:47:13 <bitonic> comak: ok. I'd suggest to look at mueval as hpc said
15:48:03 <bitonic> but tbh, I'd bundle the interpreter in your binary
15:48:07 * bitonic has to go
15:48:42 <comak> isn't it use ghc-api as well?
15:48:54 <comak> bitonic: thanks for help
15:49:00 <comak> bye
15:49:48 <bitonic> comak: yes, and if you really can't generate a PIC version of ghc-api, you're screwed :P
15:50:43 <comak> :(
15:51:04 <unnali> comak: sorry I made you so sad for arriving!
16:07:34 <mparodi> is there a way to do [z | y <- [(1,[]), (2,[3,4])], z@(_, (_:_)) <- [y]] without having to put [] around y?
16:08:12 <Cale> mparodi: you could write return y ;)
16:08:20 <mparodi> uh?
16:08:40 <mparodi> @hoggle return
16:08:40 <lambdabot> Prelude return :: Monad m => a -> m a
16:08:40 <lambdabot> Control.Monad return :: Monad m => a -> m a
16:08:40 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
16:08:42 <hpc> [z | z@(_, (:){}) <- [(1,[]), (2,[3,4])]] -- this is quite ugly though
16:08:47 <mauke> can you just use z@(_, (_:_)) instead of y?
16:08:56 <hpc> i shortened (_:_) just because i suck at typing
16:09:21 <Cale> oh, yes, you can do that
16:09:38 <Cale> > [z | z@(_, (_:_)) <- [(1,[]), (2,[3,4])]]
16:09:39 <lambdabot>   [(2,[3,4])]
16:09:53 <mparodi> <mauke> can you just use z@(_, (_:_)) instead of y? <-- no, because in the real code I need to apply a function to y
16:09:55 <mparodi> oh, I can use map
16:10:07 <mparodi> [z | z@(_, (_:_)) <- map f [(1,[]), (2,[3,4])]]
16:10:19 <mparodi> :)
16:10:29 <Cale> right
16:22:20 <parcs`> would 'let z@(...) = y' do it?
16:22:43 <hpc> no
16:22:48 <hpc> it doesn't call fail
16:23:17 <parcs`> fail!
16:23:59 <parcs`> > [z | y <- [(1,[]), (2,[3,4])], z@(_, (_:_)) <- [y]]
16:24:00 <lambdabot>   [(2,[3,4])]
16:25:59 <whittle> I’m having some conceptual trouble combining monads and lists--with (f :: Value -> Parser a) and a (Vector Value), how do I get a (Parser (Vector a))?
16:26:51 <parcs`> fmap and sequence
16:27:06 <whittle> :t sequence
16:27:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:30:53 <parcs`> :t mapM
16:30:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:32:25 <whittle> Got it. Thanks, parcs`.
16:33:02 <fragamus> One function to rule them all one function to find them one function to bring them all and in the darkness >>= them
16:34:05 <S11001001> whittle: from Data.Traversable, rather (or was it Control?)
16:34:53 * infame nerdgasm
16:35:23 <S11001001> hmm
16:35:28 <S11001001> :t T.traverse
16:35:29 <lambdabot> Couldn't find qualified module.
16:35:34 <S11001001> ah well
16:35:37 <S11001001> @hoogle traverse
16:35:37 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:35:38 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
16:35:38 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
16:35:44 <whittle> S11001001: The library I’m using (Aeson) uses Data.Vector. Which fortunately defines it’s own mapM.
16:35:55 <S11001001> that's unfortunate
16:36:03 <whittle> It is?
16:36:57 <S11001001> if it can define mapM that makes sense, it can define Traversable, and so play more nicely with others
16:37:33 <whittle> Looking at it now, and it does implement Traversable.
16:37:37 <S11001001> lovely
16:38:48 <S11001001> and I wasn't aware of traverse_ in Foldable until now, though of course it makes perfect sense :)
16:43:35 <RosePerry> Where can I find what functions come with the "Utils" module?
16:45:00 <unnali> RosePerry: where does that module come from ..?
16:45:24 <RosePerry> At the top of some starter code, I see "import Utils" and "import Data.List"
16:45:32 <S11001001> RosePerry: do you have it loaded into repl?
16:45:42 <RosePerry> What's "repl"?
16:45:52 <S11001001> e.g. ghci
16:46:00 <unnali> RosePerry: it's probably a local module (i.e. look for a file called Utils.hs!)
16:46:21 <RosePerry> ah, you're right!
16:46:28 <RosePerry> What is the "Maybe" type constructor?
16:46:38 <S11001001> @src Maybe
16:46:38 <lambdabot> data Maybe a = Nothing | Just a
16:47:09 <jdavis> At the very end of http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo I see that Barry is made an instance of Functor. The instance starts like: "instance Functor (Barry a b) where" but where are the type variable "a" and "b" used?
16:47:09 <RosePerry> aha. What is "Nothing" and "Just"?
16:48:09 <unnali> RosePerry: they're data constructors
16:48:11 <jdavis> rather, where *can* those type variables be used? I can't put a type signature in an instance declaration, right?
16:48:12 <tactics_> RosePerry, Nothing and Just are roughly "null" and ... "not null"
16:48:29 <S11001001> jdavis: fmap there is (c -> d) -> (Barry a b c) -> (Barry a b d)
16:48:30 <unnali> Nothing is a nullary constructor (literally it takes no arguments; which is a fancy way of saying it's a value all on its own)
16:48:50 <unnali> and Just is a unary constructor (meaning it takes one value (of type 'a' if the thing is of type Maybe a) and gives you the value 'Just a' in turn)
16:49:16 <RosePerry> Thanks, can I see the definitions of Nothing and Just?
16:49:38 <jdavis> S11001001: I tried to put a type signature in the instance declaration similar to that, and it wouldn't let me.
16:49:48 <Cale> It's worth mentioning that Just is a value all on its own as well
16:49:56 <Cale> That value just happens to be a function.
16:49:58 <S11001001> jdavis: no, it wouldn't
16:50:13 <Cale> RosePerry:  data Maybe a = Nothing | Just a
16:50:19 <S11001001> jdavis: try giving it as a signature to fmap as a value, that is, try :t fmap :: what I wrote at the repl
16:50:28 <Cale> RosePerry: they're defined by that line, along with the Maybe type constructor
16:50:37 <S11001001> jdavis: which proves that fmap is a generalization of that signature
16:51:13 <RosePerry> Thank you!
16:51:36 <unnali> Cale: good point.
16:52:29 <jdavis>  S11001001: OK, that's helpful, thank you. I was confused reading LYAH because it says "fmap :: (a -> b) -> Barry c d a -> Barry c d b" which is confusing given the instance declaration.
16:53:45 <RosePerry> How do we know that Nothing is a nullary constructor, and not a type like Int?
16:54:00 <S11001001> jdavis: you can read it as, "for all types a and b you might give, Barry a b forms a Functor"
16:54:29 <S11001001> jdavis: like, Barry Int Int is a different functor than Barry Int String
16:54:56 <jdavis> S11001001: Yeah, that makes sense, but those are not the same "a" and "b" that LYAH uses in the fmap signature.
16:55:01 <jdavis> Right?
16:55:08 <S11001001> indeed
16:55:22 <S11001001> think of them like lexical variables
16:55:24 <jdavis> In other words, your fmap signature makes a lot more sense to me than the one in LYAH.
16:55:29 <jdavis> ok.
16:55:39 <S11001001> you may use the varname x in two definitions, but that doesn't mean the x's have anything to do with eachother
16:55:52 <unnali> RosePerry: do you mean, just by looking at the names? Or something deeper?
16:56:14 <jdavis> S11001001, OK. Thank you for clarifying.
16:56:20 <RosePerry> How does the compiler know what "Nothing" is?
16:56:30 <S11001001> homework?
16:56:45 <RosePerry> I'm going through Learn You a Haskell for GReat Good
16:56:47 <jdavis> S11001001: Not I.
16:56:59 <whittle> If I write a function of type `(Query q, Response r) => q -> IO (Maybe r)' how do I further constrain q and r so that the response type matches the query type?
16:57:09 <unnali> RosePerry: well, if you use it in a value context (when a value is expected, i.e.), then it looks at all the bound value names for something called Nothing; and there just happens to be one defined by Prelude.
16:57:20 <jdavis> S11001001: Been slowly learning haskell in the background for a while now. Never quite used it for anything.
16:57:34 <RosePerry> Ahh can I see that definition of "Nothing" from Prelude?
16:57:37 <unnali> in other words, `data Maybe a = Nothing | Just a' is a part of the Prelude, which you get by default unless you hide it or something.
16:57:40 <unnali> yup!
16:57:43 <unnali> @src Nothing
16:57:43 <lambdabot> Source not found. Sorry.
16:57:47 <unnali> fail! One sec. :)
16:57:49 <S11001001> jdavis: worth it
16:58:01 <S11001001> unnali: you want Maybe
16:58:14 <unnali> yeah.
16:58:28 <unnali> though that doesn't show us where it really comes from.
16:58:29 <unnali> RosePerry: http://www.haskell.org/onlinereport/standard-prelude.html
16:58:45 <whittle> @hoogle Nothing
16:58:45 <lambdabot> Prelude Nothing :: Maybe a
16:58:45 <lambdabot> Data.Maybe Nothing :: Maybe a
16:58:45 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
16:58:47 <unnali> the Haskell Report defines what a compatible Haskell implementation should make available in the Prelude, and what Haskell definitions of those things should look like (where possible)
16:58:59 <unnali> if you scroll far enough, you see: data  Maybe a  =  Nothing | Just a      deriving (Eq, Ord, Read, Show)
16:59:18 <unnali> RosePerry: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Prelude.html there's ghc's Prelude
16:59:27 <unnali> it re-exports Maybe from Data.Maybe
16:59:39 <RosePerry> I don't see the Nothing :: Maybe a line. What does it mean?
16:59:43 <unnali> so you can finally see it here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Maybe.html
17:00:11 <unnali> RosePerry: that was a Hoogle search for `Nothing', it's shows what modules a value of a given type or name could be found in.
17:00:25 <unnali> it's saying that Nothing is defined in Prelude and Data.Maybe, and in both it carries type `Maybe a'
17:00:41 <S11001001> RosePerry: do you have a repl running, now?
17:01:10 <RosePerry> Thanks! I see it. Sorry, what is "repl"?
17:01:23 <S11001001> like ghci, or hugs
17:01:34 <S11001001> if you installed haskell platform you should have ghci
17:01:55 <RosePerry> Yes, gotcha. What does repl stand for?
17:02:00 <whittle> RosePerry: If you point your web browser at http://www.haskell.org/hoogle/ there’s a search box which takes to you hyperlinked searched results where you can look at documentation and even look at the source code if you’re feeling brave.
17:02:12 <S11001001> read eval print loop
17:02:30 <whittle> s/searched/search/
17:02:37 <RosePerry> Awesome! Thanks for the link to hoogle! and thanks fro the clarification on repl
17:03:39 <whittle> RosePerry: I’m new to Haskell, too. I spend a lot of time reading the source of existing packages.
17:03:39 <RosePerry> It seems like Maybe is recursively defined… it could be a type "Nothing" which is type "Maybe a"
17:04:01 <S11001001> Nothing isn't a type
17:04:15 <S11001001> i.e.
17:04:20 <S11001001> :t undefined :: Nothing
17:04:20 <RosePerry> Ah sorry, it's a nullary constructor
17:04:21 <lambdabot>     Not in scope: type constructor or class `Nothing'
17:04:47 <unnali> RosePerry: the format of this thing is `data MyNewTypeName (typevar1? typevar2?...) = MyNewDataConstrutorName (typevar1? typevar2?...) | AnotherOne (etc?...)'
17:05:13 <unnali> so `data MyType = X | Y | Z' means you'll have a new type called `MyType', and there are three values of this type (or three values `inhabiting' the type): X, Y, Z.
17:05:20 <unnali> hence X, Y, Z :: MyType.
17:06:04 <RosePerry> Thank you! I gotta go, but I'll be back on in an hour.
17:06:52 <whittle> Anybody have any thoughts on my type constraint question?
17:07:21 <unnali> whittle: you want to constrain q = r ?
17:07:28 <S11001001> whittle: use q for both?
17:07:40 <unnali> (Query q, Response q) => q -> IO (Maybe q) ?
17:08:37 <whittle> No, I want to set up pairs of (q, r) so that if q is of type e.g. UserSearchQuery, then r must be of type UserSearchResponse.
17:08:46 <unnali> oh-ho!
17:09:17 <whittle> unnali: Am I getting too close to deep magic?
17:09:27 <unnali> whittle: I hope not. I'm just thinking about it. (I'm no wizard either.)
17:10:10 <S11001001> whittle: if you can define those as constructions with some common type variable
17:10:24 <S11001001> whittle: such as Query UserSearch and Response UserSearch
17:10:55 <S11001001> oh, well
17:11:02 <S11001001> so I suppose you want fundeps then
17:11:11 <whittle> Then I would have a type signature of (q a) -> IO (Maybe (r a))?
17:11:20 <whittle> S11001001: Fundeps?
17:12:25 <S11001001> class QueryResponse q r | q -> r where
17:12:45 <S11001001> you'll have to turn on a few extensions to use that
17:13:30 <S11001001> with flexible contexts, you can also write constraints like (Query (Something a), Response (Something a)) =>
17:13:45 <S11001001> a sort of thing less controversial
17:14:25 <unnali> S11001001: is the fundep necessary? Can't we just use a constraint like `f :: (QueryResponse q r, Query q, Response r) => q -> IO (Maybe r)'?
17:14:41 <S11001001> unnali: I don't know
17:15:05 <S11001001> I assume by default that multiparam type classes need fundeps or families :/
17:15:36 <S11001001> but if queries some with responses, then Query q, Response r might as well constrain QueryResponse q r
17:15:45 <S11001001> s,some,come,
17:16:19 <unnali> Actually, it is required.
17:16:26 <unnali> Not required, but it won't automatically infer the response without.
17:16:43 <S11001001> my heuristic continues to work well :)
17:16:47 <hpaste_> unnali pasted “QRPairs” at http://hpaste.org/69971
17:16:52 <unnali> I gotta head to a meeting, but here's what I had
17:17:09 <unnali> `:t (f MyQuery)' yields a MyResponse in ghci :)
17:17:46 <whittle> Thanks, unnali. I clearly have some reading ahead of me.
17:25:13 <_Vi> How to portably convert lazy ByteString to String (in UTF-8 encoding)?
17:25:58 <whittle> _Vi: I recommend using Data.Text instead of String.
17:26:18 <whittle> In which case it’s just Data.Text.pack.
17:26:29 <whittle> Or rather, Data.Text.unpack.
17:28:53 <whittle> _Vi: Sorry. The functions I just mentioned are for transforming back and forth from Text to Strings. Just check out http://hackage.haskell.org/packages/archive/text/0.11.2.1/doc/html/Data-Text-Encoding.html for what you need.
17:29:20 <_Vi> Looks like "Data.Text" is the answer (with Encoder.decodeUtf8).
17:30:14 <whittle> Yes.
17:30:47 <shachaf> _Vi: That's if your ByteString actually contains UTF-8-encoded codepoints.
17:33:14 <_Vi> How to convert between various ByteStrings? (lazy to one that decodeUtf8 understands)
17:37:20 <_Vi> "Exception: Cannot decode byte '\xff': Data.Text.Encoding.decodeUtf8: Invalid UTF-8 stream"  How to decode to "Maybe Text" to be able to handle failure?
17:38:24 * hackagebot iteratee 0.8.9.1 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.9.1 (JohnLato)
17:41:34 <_Vi> Found myself: decodeUtf8With
17:44:18 <kallisti> @hoogle removefile
17:44:18 <lambdabot> System.Directory removeFile :: FilePath -> IO ()
17:47:34 <boccato> The name convention for packages is like that? my-very-good-package (with a my-very-good-package.cabal file on a my-very-good-package directory)
17:48:25 * hackagebot git-annex 3.20120614 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120614 (JoeyHess)
17:51:19 <illissius> Couldn't match kind `*' against `BOX'
17:51:21 <illissius> FROWN :(
17:51:44 <_Vi> Is it the right way to convert Data.ByteString.Lazy.ByteString to Data.ByteString.ByteString:   (Data.ByteString.Char8.concat . Data.ByteString.Lazy.Char.toChunks) ?
17:51:51 <hpc> what's BOX?
17:52:14 <illissius> hpc: BOX is the sort of all kinds.
17:53:50 <hpc> _Vi: there might be a "pack" that does it
17:53:56 <hpc> otherwise, if the types line up that should work
17:54:33 <_Vi> "pack" is from String, not from other ByteString.
17:54:47 <_Vi> It works. I'm asking if it is the right way to do it.
17:56:12 <hpc> think so
17:56:30 <pengw> !haskell
17:58:25 * hackagebot system-fileio 0.3.8 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.8 (JohnMillikin)
18:01:03 <_Vi> E.decodeASCII (CN.pack "qwsdf\xffwr")   ->   Invalid UTF-8 stream   ???
18:01:16 <_Vi> How to decode ASCII?
18:01:34 <illissius> hpc: it's a known bug with PolyKinds in 7.4 and I was hoping to avoid it. the really annoying thing is that it worked, and I don't think I changed the part of the code it's now complaining about at all, and now it doesn't work.
18:01:50 <illissius> so either there's non-local effects or I was hallucinating or some other thing.
18:08:26 * hackagebot ghc-man-completion 0.0.0.2 - Generate a bash completion from the GHC manpage  http://hackage.haskell.org/package/ghc-man-completion-0.0.0.2 (JoeQuinn)
18:15:40 <_Vi> How to decode from 4 byte or 8 byte ByteString with IEEE float number to Double?
18:16:03 <shachaf> Data.Binary or something?
18:17:03 <_Vi> Data.Binary describes some portable thing between Haskels. Will it suit reading values written from C code?
18:18:27 * hackagebot gnutls 0.1.3 - Bindings for GNU libgnutls  http://hackage.haskell.org/package/gnutls-0.1.3 (JohnMillikin)
18:20:24 <geekosaur> _Vi, its primites are closer to C than Haskell; the internal representations of Haskell values can't really be serialized meaningfully, plus C types are more or less the de facto standard for binary serialized values
18:21:00 <_Vi> Trying it...
18:23:12 <_Vi> DB.decode (C.pack "\xcd\xcc\xac\x40") :: Float -> Exception: too few bytes.    Expected "5.4".
18:32:40 <illissius> yay, the problem was that I forgot to update a boot file.
18:36:10 <_Vi> Looks like the answer is "data-binary-ieee754" package with wordToFloat and wordToDouble.
18:36:34 <S11001001> @pl \x -> if f x then [x] else []
18:36:35 <lambdabot> flip (liftM2 if' f return) []
18:37:05 <S11001001> @hoogle if'
18:37:05 <lambdabot> No results found
18:41:00 <S11001001> @hoogle guard
18:41:00 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
18:41:00 <lambdabot> Language.Haskell.TH.Syntax data Guard
18:41:00 <lambdabot> Language.Haskell.TH data Guard
19:08:17 -ServerScript(BernieBank@62.186.178.91.Orania.dyn.greenmobile.co.za)- In order to ensure the seamless merger of Efnet with Freenode, Chanserv will be down for three days starting at 00:00 GMT on the 16th of June.  Sorry for the inconvenience.  -Freenode Staff
19:08:35 --- mode: ChanServ set +o mauke
19:08:35 --- mode: mauke set +b $a:BernieBankenberg
19:08:39 <shawng> hello, I would like to know the best resource for an introduction to Hugs 98
19:09:02 --- kick: ServerScript was kicked by mauke (ServerScript)
19:10:49 <shawng> hello, i'd like to know the best resource for learning hugs 98 and i'll be on my way
19:11:02 --- mode: mauke set -o mauke
19:12:10 <mgsloan> hopefully shawng was just trolling.  Can't expect help if you leave in an instant!
19:13:08 <mgsloan> I wonder if anyone gets sucked into Hugs these days.  Years ago I didn't learn haskell for a few months because Hugs didn't work with anything
19:13:33 <mgsloan> before realizing everyone used GHC
19:13:35 * hackagebot smallarray 0.2.2.4 - low-level unboxed arrays, with minimal features.  http://hackage.haskell.org/package/smallarray-0.2.2.4 (AntoineLatter)
19:13:37 * hackagebot smallstring 0.3.3 - A Unicode text type, optimized for low memory overhead  http://hackage.haskell.org/package/smallstring-0.3.3 (AntoineLatter)
19:13:55 <mauke> shawng: welcome back
19:14:20 <unnali> mgsloan: I got trapped for a month or two once, as well.
19:15:50 <mgsloan> yeah, maybe the Hugs web presence should be dismantled / clearly marked with "Use GHC!"?  Are the errors still friendlier than GHC in some cases?
19:16:10 <mauke> I never found hugs to be friendlier than ghc
19:17:09 <mgsloan> yeah, me either, and the marketing materials saying that it is led to me picking it back when I was trying to learn
19:17:19 <S11001001> sounds a little supremacist
19:17:59 <geekosaur> hugs was friendlier than GHC back in the 6.4 and a bit in the 6.6 days.  ghc error messages have gotten a lot better since then
19:18:54 <geekosaur> there was an active effort to make the error messages better reflect the user's version of what was going on instead of the guts of the typechecker
19:19:13 <mgsloan> S11001001: there are a number of Haskell implementations, it's true.  But hugs just sounds so darn nooby friendly, in name and webpage, and it isn't anymore.
19:19:17 <mauke> ah, a ... gutsy move
19:19:38 <mgsloan> (and wasn't five years ago)
19:25:02 <JoeyA> > printf "%d" 5 :: String
19:25:03 <lambdabot>   "5"
19:25:27 <JoeyA> Why doesn't this produce an ambiguous type error?
19:26:24 <geekosaur> defaulting, I believe
19:26:35 <JoeyA> I'm trying to do the variadic function trick, but I get an ambiguous type error, rather than it defaulting.
19:26:46 <mauke> extended defaulting?
19:27:30 <Jesin> > printf "%d" 5
19:27:31 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:27:31 <lambdabot>    `Text.Printf.PrintfType ...
19:27:36 <Jesin> > printf "%d" 5 :: String
19:27:37 <lambdabot>   "5"
19:27:47 <Jesin> huh.
19:27:54 <Jesin> > printf "%d" 5 :: Integer
19:27:55 <lambdabot>   No instance for (Text.Printf.PrintfType GHC.Integer.Type.Integer)
19:27:55 <lambdabot>    arisin...
19:28:07 <Jesin> > printf "%d" 5 :: Char
19:28:08 <lambdabot>   No instance for (Text.Printf.PrintfType GHC.Types.Char)
19:28:09 <lambdabot>    arising from a u...
19:28:23 <JoeyA> Jesin: The first error was because it couldn't pick between IO (), String, or some other list type.
19:28:27 <mauke> Jesin: your choices are String and IO ()
19:28:27 <Jesin> > printf "%d" 5 :: IO String
19:28:28 <lambdabot>   <IO [Char]>
19:28:38 <Jesin> > printf "%d" 5 :: IO ()
19:28:39 <lambdabot>   <IO ()>
19:28:47 <Jesin> k
19:28:48 <Ralith> :t printf
19:28:49 <lambdabot> forall r. (PrintfType r) => String -> r
19:28:56 <JoeyA> But I want to know why PrintfArg gets to be defaulted.
19:29:08 <JoeyA> > 5 :: Integral t => t
19:29:09 <lambdabot>   5
19:29:10 <Ralith> that is a strange type
19:31:31 <JoeyA> Ah, I know what it is.  My base case is List [a], and if I don't put a context on a, it becomes an ambiguous type error.
19:31:41 <JoeyA> I have to say something like Integral a => List [a], and it works.
19:33:58 <unnali> List [a]
19:34:08 <unnali> a list of a lists?
19:34:25 <JoeyA> unnali: A class instance indicating that 'list' may have type [a]
19:34:58 <JoeyA> I'm trying to make a variadic 'list' function (a simplified version of my actual problem), sort of like the Text.Printf trick.
19:35:36 <SrPx> Wow guys, http://tryhaskell.org/ HOW? Is there a haskell > javascript thing going on there, or is this a service?
19:36:09 <avpx> It's probably something like an AJAX interface to lambdabot
19:36:33 <avpx> Very cool, though.
19:36:45 <unnali> JoeyA: ah, right.
19:38:09 <Shou-> I have a very minimal IRC client written in Haskell where I use Data.Text, but anything outside of ASCII characters show up as something like `ããããã' there. Any pointers on what I should do to make the characters display correctly?
19:38:44 <mauke> what are you using for output?
19:40:01 <JoeyA> What encoding is your IRC client set to?  (make sure it's UTF-8, or I'll sic lambdabot on you)
19:40:30 <zzo38> Can there make a lens taking two categories as parameters to make up the lens category?
19:42:02 <Shou-> mauke: Data.Text.putStrLn, if that's what you mean.
19:42:06 <zzo38> Such as:  newtype Lens c1 c2 x y = Lens (c1 x (c2 y x, y));
19:44:11 <zzo38> Does there need to be a functor from (->) to c1? Does there need to be a functor from c1 to (->)? (If c1 is a Kleisli category then it will be the case; the composition of these two functors will be the endofunctor of that monad.)
19:44:20 <mauke> Shou-: what do you see when you 'print' it instead?
19:44:42 <hpaste_> Anonymous pasted “Skype replaces P2P supernodes with Linux boxes hosted by Microsoft (updated)” at http://hpaste.org/69973
19:44:42 <luite> SrPx: haskell->javascript is possible, but the compilers are not yet production ready
19:45:05 <SrPx> okay...
19:46:11 <Shou-> JoeyA: I'm assuming that's the issue. I'm not doing any conversion from/to character encodings, just reading from the handle with Data.Text.hGetLine and sending the output to Data.Text.putStrLn so whatever is default.
19:46:44 <zzo38> I would prefer to have Haskell->Glulx rather than Haskell->JavaScript
19:46:55 <mauke> hah
19:48:01 <JoeyA> Shou-: http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text-IO.html#g:2
19:48:16 <JoeyA> My guess is that it's defaulting to an inappropriate locale.  What OS is your IRC server on?
19:50:21 <JoeyA> You might want to do this instead: Data.Text.Encoding.encodeUtf8 the string, and Data.ByteString.hPutStr it.  That'll force it to use UTF-8 encoding, rather than catering to your system terminal or whatever.
19:50:33 <mauke> blargh
19:50:40 <mauke> I'd rather understand what the problem actually is
19:50:45 <zzo38> Do you know answer about my question about the lens?
19:50:59 <JoeyA> (I don't know nuthin' bout Data.Text's choice of encoding)
19:54:11 <otters> Data.Text doesn't have encoding
19:54:46 <JoeyA> otters: Data.Text.IO, I mean.  My bad.
20:00:44 <Shou-> JoeyA: Oh, this is just an IRC client. I'm using Freenode to test it, however.
20:01:08 <Shou-> I uploaded the simple source to hpaste if that helps: http://hpaste.org/69974
20:01:25 <mauke> Shou-: hello?
20:02:08 <Shou-> Yeah?
20:02:23 <Shou-> Oh, the print output?
20:02:25 <mauke> yes
20:02:34 <mauke> also groaning at NoBuffering
20:02:51 <otters> what's bad about nobuffering?
20:03:03 <mauke> it's horribly inefficient
20:03:13 <otters> is default buffering better?
20:03:42 <Shou-> This is what print prints "\227\129\130\227\129\132\227\129\134\227\129\136\227\129\138\r", it's supposed to be あいうえお.
20:03:53 <JoeyA> I'd lean toward LineBuffering, for network-related things.
20:04:05 <JoeyA> (err, for text-based network protocols)
20:04:07 <otters> Shou-: print uses show
20:04:33 <otters> you want putStrLn
20:04:37 <rwbarton> ...
20:04:40 <JoeyA> NoBuffering is fine if you're not printing one char at a time (which putStrLn does with String)
20:04:41 <mauke> otters: no
20:04:43 <Shou-> I know. It shows as ``ããããã'' otherwise.
20:04:46 <JoeyA> It's probably more efficient for Text, though.
20:04:47 <otters> okay
20:04:49 <otters> never mind then
20:05:34 <mauke> Shou-: you're effectively decoding the input as latin-1 but it's really utf-8
20:05:46 <JoeyA> (printing one Char at a time is inefficient in any case, because it has to take one or two MVar locks and append to a buffer for each character.
20:06:22 <mauke> JoeyA: but at least it doesn't go over the network
20:06:31 <Shou-> mauke: How do I go about making it decode it as UTF-8 instead?
20:07:45 <mauke> Shou-: first thing I'd try is hSetEncoding h utf8 in line 39
20:09:20 <mauke> and hSetNewlineMode h CRLF while you're at it
20:09:38 <mauke> oh wait
20:10:07 <mauke> it's hSetNewlineMode h (NewlineMode CRLF CRLF)
20:12:06 <Shou-> Alright, thanks! That worked. Should I set it to LineBuffering as well, instead of NoBuffering?
20:12:21 <mauke> yeah
20:12:34 <JoeyA> What's a concise name for this data structure?  data Foo r a = Done r | Feed (a -> Foo r a)
20:13:33 <JoeyA> Would it be accurate to call it an "iteratee" ?  It's basically like [a] -> r, but the consumer gets to decide how long the list is, rather than the producer.
20:13:46 <JoeyA> (and that's exactly how I'm using it)
20:14:05 <rwbarton> It has a name in conduit I imagine.
20:14:44 <Ralith> that looks an awful lot like any number of state abstractions
20:16:02 <rwbarton> I mean, if you like you can call it the free monad on the functor (->) a (except the arguments are in the wrong order)
20:16:45 <rwbarton> conduit calls it a Sink
20:17:05 <rwbarton> (more or less)
20:17:32 <JoeyA> In my actual case, there aren't any type arguments (r and a are both concrete).
20:17:39 <JoeyA> I think I'll just call it a "list consumer"
20:19:16 <kulin> I know this comes up a lot, but I want to use a type class like a data type, so i can do something like [AbstractInterface a] where i really dont care whatever 'a' is (it can be multiple things) but any functions that use that parameter will only have access to the functions for the type class
20:19:22 <kulin> is there any extension that allows that?
20:19:22 <JoeyA> Actually, I'll just say "it asks for zero or more variable names, and returns an expression using them"
20:19:45 <Clint> apparently a Sink is called a Consumer in pipes
20:20:15 <JoeyA> kulin: ExistentialQuantification
20:20:19 <zzo38> kulin: It is possible to do.
20:20:22 <JoeyA> Though it's not written like that.
20:20:27 <rwbarton> these names both sound good to me
20:20:59 <JoeyA> class AbstractSingletonFactoryProxyFactoryBean a where ...
20:21:17 <JoeyA> Then, foo :: (AbstractSingletonFactoryProxyFactoryBean a) => [a] -> IO ()
20:21:41 <JoeyA> Oh wait, that's too many Factory's.
20:22:12 * geekosaur *eyeroll*
20:22:53 <zzo38> It is also possible to make up something like:  data Node where { Node :: NodeClass x => x -> Node; };
20:24:08 <zzo38> JoeyA: I think that Foo isa kind of things like (Free ((->) a) r)
20:26:03 <kulin> im reading up on the existentialquantification extension, but ill be the first to admit it's assuming i have a much more intellectual background than i do
20:26:43 <JoeyA> kulin: Are you familiar with OO?
20:27:05 <kulin> zzo38: Is that a new syntax for data declarations? I've never used 'where' like that.
20:27:13 <kulin> JoeyA: Yes.
20:27:16 <JoeyA> kulin: That's GADT syntax
20:27:26 <geekosaur> kulin, that's GADT syntax
20:27:32 <geekosaur> ...slow
20:27:38 <JoeyA> Existential quantification lets values carry class methods at runtime.
20:29:24 <JoeyA> So you can have data Zoo = [Cage]; data Cage = forall a. Animal a => Cage a; class Animal a where makeNoise :: a -> IO ()
20:29:41 <Draggor> I'm having something of a brainfart again:  in parsec, I'm parsing a character via 'do c <- char letter'  Now say I want to do a case on c, but as is it won't work because of its type.  how do I get the actual char out of it?
20:29:54 <JoeyA> Where, just like in real life, a Cage holds the set of methods that define an animal .
20:30:01 <mgsloan> hmm.  I'm trying to use constraint kinds for something (haven't used these yet!), and I'm getting "Not in scope: type constructor or class `Constraint'" When trying to write a kind signature
20:30:13 <mgsloan> should "Constraint" be in scope?
20:31:00 <rwbarton> you have to import it from somewhere under GHC.*
20:31:12 <kulin> JoeyA: interesting, so the 'object' if you will, is the 'Cage' and the ExistentialQuantification hides the type of the cage but allows me to call it's methods.
20:31:15 <geekosaur> Draggor, c should have the correct type there, although `char c' does not
20:31:50 <geekosaur> ...but is char what you actualy mean there?
20:32:04 <kulin> JoeyA: that doesnt cause problems with the compiler when you have a list of [Cage] that have different animals?
20:32:13 <geekosaur> since it matches the character that you pass it, its result is either failure or its argument
20:32:19 <mgsloan> rwbarton: ahh, cool, thanks! I'll look for example code
20:32:33 <rwbarton> try likely-sounding stuff like GHC.Prim or GHC.Exts
20:33:12 <rwbarton> Draggor, my guess is letter has the wrong type (it's not a Char)
20:33:47 <Draggor> The type in c is Parser Char
20:33:53 <rwbarton> actually, I see char is monomorphic to parsing streams of Chars
20:34:00 <geekosaur> then you have done something else wrong
20:34:12 <Draggor> I didn't actually use letter, I have something else I've written
20:34:23 <rwbarton> did you actually use "c <- char ..."?
20:34:27 <Draggor> I want to use what I get in c in a case statement, and that's where the confusion is
20:34:49 <rwbarton> like geekosaur said you know that char only matches a single specific character right?
20:34:58 <rwbarton> what is letter even supposed to mean?
20:35:10 <Draggor> My initial line is wrong, let me fix:
20:35:25 <Draggor> c <- myParserCharParser
20:36:05 <rwbarton> well then you probably have an issue with myParserCharParser
20:36:10 <geekosaur> maybe you better paste a significant snippet of your code; that is quite meaningless
20:36:17 <geekosaur> @paste
20:36:17 <lambdabot> Haskell pastebin: http://hpaste.org/
20:37:29 <S11001001> @pl \(x, y) -> flip (,) y `fmap` fmap f x
20:37:29 <lambdabot> uncurry (flip (fmap . flip (,)) . fmap f)
20:37:30 <Draggor> https://github.com/draggor/haskell-scheme/blob/master/Scheme.hs#L23
20:38:27 <rwbarton> should be "let rc = ..." not "rc <- ..."
20:39:13 <Draggor> That makes sense, thanks
20:39:19 <Draggor> It's been far too long since I've poked at this
20:39:59 <Draggor> And success, tests pass again
20:41:04 <shapr> yay software testing!
20:41:45 <S11001001> excellent, Kleisli arrows to the rescue
20:41:51 <JoeyA> kulin: You can pattern match on a Cage and access the value with one of Animal's methods, but the value inside pretty much cannot "escape".
20:42:04 <Draggor> The scheme interpreter in 48 hours thing is great,it's fun to learn haskell this way, but it had nothing for testing.  I decided to throw that in myself and it's been saving me lots of headaches.
20:42:23 <JoeyA> It's type will prevent you from, say, prepending it to a [Int].
20:42:31 <JoeyA> You can put it in another Cage, though.
20:43:15 <JoeyA> But it's called "existential" quantification because the value inside has *some* type (we don't know what exact type, though)
20:43:52 <kulin> JoeyA: is this suppose to work using your example: cageAnimal :: Animal a => a -> [Cage] -> [Cage]
20:44:26 <JoeyA> kulin: Yes.
20:44:41 <JoeyA> Though you could go simpler and say cageAnimal :: Animal a => a -> Cage
20:44:51 <JoeyA> That is exactly the type of the Cage data constructor.
20:45:12 <JoeyA> A Cage can hold *any* type of animal.
20:45:37 <JoeyA> But if you're looking at a Cage that has already been constructed, there is only *one* type of Animal inside.
20:46:04 <kulin> I'm just trying to get to a zoo that has 50 cages with 50 different animals in a single list
20:46:15 <kulin> and this code is throwing errors but if you are saying its possible, it just means im doing something wrong
20:47:58 <JoeyA> kulin: Keep trying ;-)  Paste your code in hpaste.org or similar if you need help.
20:48:43 * hackagebot hDFA 0.0.2 - A simple library for representing and minimising DFAs.  http://hackage.haskell.org/package/hDFA-0.0.2 (PeterGammie)
20:50:23 <S11001001> @pl \a b c -> a . (>>= b) . c
20:50:23 <lambdabot> (. ((.) . (=<<))) . (.) . (.)
20:50:28 <S11001001> haha what
20:50:46 <S11001001> @pl \b -> a . (>>= b) . c
20:50:46 <lambdabot> (a .) . (. c) . (=<<)
20:54:13 <mzero> :t  a . (>>= b) . c
20:54:14 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
20:54:14 <lambdabot>     In the first argument of `(.)', namely `a'
20:54:14 <lambdabot>     In the expression: a . (>>= b) . c
20:54:28 <mzero> :t \a b c -> a . (>>= b) . c
20:54:29 <lambdabot> forall b (m :: * -> *) a b1 (f :: * -> *). (Monad m, Functor f) => (m b1 -> b) -> (a -> m b1) -> f (m a) -> f b
20:54:41 <mzero> :t \a b c -> a . c >=> b
20:54:42 <lambdabot> forall a (m :: * -> *) b a1 c. (Monad m) => (a -> m b) -> (b -> m c) -> (a1 -> a) -> a1 -> m c
20:55:25 <mzero> :t \a b c -> a . (c >=> b)
20:55:26 <lambdabot> forall b a (m :: * -> *) b1 c. (Monad m) => (m c -> b) -> (b1 -> m c) -> (a -> m b1) -> a -> b
20:58:09 <kulin> JoeyA: I must be missing something: hpaste.org/69975
20:59:26 <kulin> also probably the world's most boring zoo, just dogs and cats
20:59:36 <mzero> you have no instance of Animal for Cage
21:00:06 <mzero> either write one or uncage 'em before you let 'em makeNoise
21:01:09 <JoeyA> kulin: rattleCage :: Animal a => Cage a -> IO (); rattleCage (Cage animal) = makeNoise animal
21:01:22 <mzero> (oops, is this perhaps homework and I shouldn't be giving so many hints?)
21:01:44 <kulin> not homework, this is me trying to make an observer patern for a text editor :P
21:02:08 <mzero> JoeyA: er, no:   rattleCage :: Animal a => Cage -> IO (); rattleCage (Cage animal) = makeNoise
21:02:12 <kallisti> here's a fun thought experiment: what would be the best way to modify Haskell's semantics so that memory management were explicit
21:02:35 <JoeyA> Right, except makeNoise needs animal after it.
21:03:24 <JoeyA> Use unboxed types?
21:03:26 <mzero> uhm - yes - paste failure
21:04:16 <RosePerry> Could not find module `Control.Monad.State'
21:04:37 <mzero> kulin: you really need the list of things to be open-ended? - if not, a plain ol' ADT of the things that can be in it is often easier
21:05:25 <kulin> mzero yes, because i don't want to keep a list of all the plugins that may be created, i just want to notify any that have registered themselves with any events that have come up
21:05:37 <mzero> ah - good
21:05:49 <zzo38> I have done such things where you can add new things on.
21:05:52 <RosePerry> Anyone know how I can find 'Control.Monad.State'?
21:05:58 <mzero> and presumably the plug-ins have more than just one or two methods
21:06:24 <mzero> @hoogle Control.Monad.State
21:06:24 <lambdabot> Control.Monad.State module Control.Monad.State
21:06:24 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
21:06:24 <lambdabot> Control.Monad.Trans.State.Lazy type State s = StateT s Identity
21:06:43 <mzero> RosePerry: find in what way?
21:06:49 <zzo38> For example in "dvi-processing" there is:   data Node where { Node :: forall x. NodeClass x => x -> Node; } deriving Typeable; class Typeable x => NodeClass x where { ... };
21:07:14 <MostAwesomeDude> Out of curiosity, if I were to build games in Haskell, which libraries would I look at?
21:07:47 <mzero> web games? console games? text adventure games? iOS games?
21:08:03 <m3ga> MostAwesomeDude: for the desktop, there are haskell bindings to the SDL libraries.
21:08:52 <S11001001> mzero: for your edification: https://bazaar.launchpad.net/~scompall/+junk/associative--mainline/view/head:/src/Data/Associative/MapDomain.hs#L27
21:09:36 <MostAwesomeDude> m3ga: Okay. Are there any libraries that decrease suffering caused by game-writing?
21:09:46 <RosePerry> Even though I "import Control.Monad.State" in the file I'm loading into ghci, it can't seem to find it.
21:09:51 <zzo38> MostAwesomeDude: It depends much on the game.
21:09:57 <kulin> JoeyA, mzero: When I try rattleCage :: Animal a => Cage a -> IO () I get the error "'Cage' is applied too many type arguments" and when i try rattleCage :: Animal a => Cage -> IO () i get "Ambiguous constraint 'Animal a'"
21:10:04 <RosePerry> mzero: see previous message
21:10:23 <zzo38> In some cases you need no GUI or anything like that, and just the rules of the game.
21:10:24 <m3ga> MostAwesomeDude: not sure. if it were me, and i was interested in desktop games i would look at the SDL bindings.
21:10:42 <zzo38> In other cases you might want multiplayer over telnet or whatever.
21:10:45 <JoeyA> kulin: Because we both posted misinformation ;-)  The class constraint on rattleCage isn't necessary; it's just rattleCage :: Cage -> IO ()
21:10:57 <mzero> RosePerry: that's odd
21:11:01 <JoeyA> The Animal become available when you match on the Cage constructor.
21:11:09 <mzero> S11001001: consider me edified
21:11:11 <JoeyA> Animal methods*
21:11:41 <JoeyA> More precisely, Animal methods can be used on the unwrapped value.
21:11:42 <kulin> JoeyA: Yer awesome, that worked!
21:12:31 <mzero> kulin: I'd been more inclined to make    instance Animal Cage where makeNoise (Cage a) = makeNoise a
21:12:38 <kulin> Now that I have something working, I should read more I think to figure out why it worked. I feel like the interns at my company when I look at the 'forall a.' (Just able to copy and paste and have to find someone more senior when it doesnt work!)
21:12:48 <zzo38> If doing something like what I was doing, you can also make Typeable to be a superclass of Animal if you want certain parts of the program to be able to distinguish their data if they know them.
21:13:09 <zzo38> mzero: That too; in fact in "dvi-processing" I have done like that too
21:14:00 <kulin> mzero that looks good too, but I don't mind the rattle cage, functions that look like doSomething x = doSomething x' make me nervous
21:14:48 <MostAwesomeDude> Okay, so there's Irrlicht bindings, but Irrlicht is not a sane option.
21:15:12 <mgsloan> Any constraint kinds experts here? hmmm.. Why is order significant to constraint tuples?
21:15:17 <mzero> really? they shouldn't.... standard wrapper pattern - I use it alot in Plush --- where I have a PosixLike class, and then have ShellState wrapped around a PosixLike - which is then defined to also be PosixLike
21:15:38 <kulin> zzo38, thats a good idea too, thx!
21:15:39 <mzero> RosePerry: what is the error you are getting from ghci? Perhaps put it in hpaste?
21:15:44 <RosePerry> AFter I download a package from hackage, how should I make sure it's installed?
21:15:53 <RosePerry> mzero: I think I'm missing the mtl package.
21:16:02 <mzero> Whoa? reallly
21:16:07 <mgsloan> Seems like constraint synonyms (type synonyms of constraint tuples) should be sets of constraints, and not ordered / hieararchicalized tupleage
21:16:10 <mzero> how did you install Haskell?
21:16:12 <strager> RosePerry: Did you install the Haskell Platform?
21:16:25 <RosePerry> I used brew
21:16:32 <strager> Install the Haskell Platform.
21:16:43 <mzero> RosePerry: you don't need to download from Hackage explicitly --- you just say   "cabal install mtl"
21:16:43 <strager> http://hackage.haskell.org/platform/
21:17:00 <mzero> that downloads builds and installs, and does so recursively for all dependencies
21:17:07 <mzero> are you using brew on Mac OS X?
21:17:16 <RosePerry> mzero: yes
21:17:21 <mzero> install the platform!
21:17:33 <RosePerry> What command should I enter in the terminal?
21:18:03 <mzero> to install the platform? It is a 190MB downloadable installer package (native Mac OS X installer, that is)
21:18:05 <strager> Download and run the installer from that page.
21:18:18 <mzero> it installs GHC, and about 45 packages with all docs built etc....
21:18:40 <mzero> for mac OS X, it is the preferred way to install unless you have some special set up or needs
21:19:54 <kallisti> > (+)3(read"3")
21:19:54 <strager> The Haskell Platform includes mtl.
21:19:55 <lambdabot>   6
21:20:03 <strager> As well as cabal-install, which you will find very helpful.
21:20:19 <RosePerry> Nice! From which page can I install the platform?
21:20:24 <strager> http://hackage.haskell.org/platform/
21:20:29 <mzero> (cabal-install is the package that provides the cabal command line tool)
21:20:32 <RosePerry> Should I uninstall the current version of ghc iI installed using brew?
21:20:39 <mzero> yes, probably
21:20:48 <mzero> and do you have Xcode installed?
21:20:59 <RosePerry> Yes
21:21:08 <mzero> then you're good to go
21:21:25 <mzero> I suggest the 32-bit version unless you have need for very big data sets in memory
21:21:50 <RosePerry> mzero: Thanks! It's downloading now.
21:22:21 <mzero> just curious- version of OS X and Xcode you have?   (full disclosure: I'm the packager of Haskell Paltform for Mac OS X)
21:24:18 <kulin> lol, gives all new meaning to 'preferred way to install'
21:24:38 <mzero> heh: well, that sounded better than "my way to install"
21:24:53 <mzero> :-)
21:26:12 <zzo38> RosePerry: Why does your message contain a backspace code instead of the client handling the backspace? (IRC server doesn't handle backspace itself)
21:26:39 <zzo38> (Another possibility is if the client requires ^? for backspace but your terminal sends ^H for backspace)
21:26:50 <MostAwesomeDude> Has anybody done things with fungen?
21:28:51 <RosePerry> haha I have mac os 10.7.4 and Xcode 4.3.2
21:29:14 <mzero> lovely - did you install the "Command Line Tools for Xcode"?
21:29:18 <RosePerry> zzo38: what "backspace code" are you referring to?
21:29:57 <zzo38> RosePerry: In your message above ".. of ghc iI installed .." there is a backspace code between "i" and "I"
21:29:58 <RosePerry> mzero: I think so. How can I make sure?
21:30:10 <mzero> RosePerry: run    ls /usr/bin/gcc
21:30:16 <mzero> if it is there, you are good to go
21:30:50 <mzero> or run    gcc -v
21:31:03 <RosePerry> mzero: yep, it's there
21:31:11 <mzero> you're set
21:32:52 <RosePerry> mzero: Nice. It all works! Thank you very much!
21:33:00 <mzero> welcome
21:33:21 <mzero> remember to bookmark that web page that it opened - it links to all the doc locally
21:33:39 <RosePerry> got it
21:33:39 <mzero> (where it == the installer)
21:36:46 <kulin> man, i am loving this existential quantification, i feel like now i will use it incorrectly to solve every problem for sure
21:37:43 <shachaf> @remember kulin man, i am loving this existential quantification, i feel like now i will use it incorrectly to solve every problem for sur
21:37:44 <lambdabot> Done.
21:44:31 <zzo38> What is it called if you have a category C and D having a functor from C to D leaving objects alone, and from D to C translating objects?
21:57:19 <Catnaroek> Hello, I have an instance of record with a lot of members. How do I construct a new instance of this record with the value of one of its members changed.
21:57:20 <Catnaroek> ?
21:57:49 <mzero>    new = old { k = v }
21:57:59 <Catnaroek> Thanks!
21:58:34 <mzero> "value of a record" is a better term than "instances of a record"
21:59:24 <fragamus> hi
21:59:46 <fragamus> :set +m       <---- no workie
22:00:02 <Catnaroek> mzero: Oh.
22:00:36 <mzero> "instance" is reserved for type classes
22:00:40 <fragamus> ghci multiline mode is what i wish for
22:00:55 <Catnaroek> mzero: In this case, the member I want to update is a list. In particular, I want to add a new element to it. Can I just do...
22:01:11 <Catnaroek> new = old { listMember = newHead : listMember }
22:01:12 <Catnaroek> ?
22:01:31 <mzero> new = old { k = newV : k old }
22:01:49 <mzero> alas, you need to repeat the record
22:02:13 <Catnaroek> Oh.
22:02:35 <Catnaroek> In the rhs, k is simply the function name, right?
22:03:35 <mzero> right - the member name acts as a function in that position
22:07:01 <mzero> Catnaroek: if you use -XRecordWildCards
22:07:56 <mzero> you can write something like         extendWithX r@(Rec { .. }) x = r { listMember = x : listMember }
22:08:20 <mzero> the { .. } brings all the members of the record into scope as their values, not as functions
22:11:56 <mikeplus64> mzero: Catnaroek: with RecordWildCards you can simply write extendWithX r{..} x = r {listMember = x : listMember}
22:12:20 <mzero> ah - even fewer characters
22:12:28 <mzero> that said, I never use that extension
22:14:50 <Aarontpz> hello, haskell people
22:28:49 * hackagebot Histogram 0.1 -   http://hackage.haskell.org/package/Histogram-0.1 (MikeIzbicki)
22:38:45 <mattr> haskell web devs: what db libraries do you use?  I have read everything I can find on the matter and nothing is standing out as a clear winner.
22:38:50 * hackagebot Histogram 0.1.0.1 -   http://hackage.haskell.org/package/Histogram-0.1.0.1 (MikeIzbicki)
22:40:36 <barrucadu> mattr: I've been using Yesod for the little web dev I have done in Haskell, and its Persistent framework is quite nice
22:41:46 <mattr> barrucadu: It is missing some things I would imagine are important, like chasing joins automatically - I read the suggested way around this is to do the join haskell side?
22:42:21 <kulin> Is there a common naming scheme when using ExistentialQuantification type classes and data types? I find that I really want to use the same name for both types.
22:42:31 <mattr> ie, load up all records from the source table then iterate over getting all the records from the other table.
22:43:03 <barrucadu> mattr: Yes, it's missing some things but it's nice to use within Yesod. tbh, I haven't tried any other db libraries for web development
22:43:23 <mattr> barrucadu: otherwise it looks very nice, so a recommendation goes a long way :)
22:46:20 <shergill> mattr: persistent handles one-many joins. for more complicated stuff you have the option of writing either raw sql queries or doing the join 'haskell side' as you suggested
22:50:59 <killy9999> let's say I have: func :: a -> b -> c -> d -> e
22:51:20 <killy9999> I'd like to create a curried function that has 3rd and 4th parameters set
22:51:42 <killy9999> to get a partially applied function of type a -> b -> e
22:51:57 <killy9999> is there some sort of built in function to achieve that?
22:53:17 <AfC> killy9999: just create a one-liner function to wrap the call?
22:53:17 <mattr> shergill: thanks, I imagine this is unlikely to change in the future since Perisistant is non-relational (supports things like mongo)?
22:53:33 <killy9999> AfC: yes, but that is not flexible
22:54:14 <killy9999> I'f later I'd like to pass b and d and get a -> c -> e I would need another wrapper
22:54:31 <shergill> mattr: perhaps. i have been looking into integrating haskelldb with persistent however, for writing raw sql queries
22:54:37 <shachaf> killy9999: If you want to do a different thing, you'll need to write different code?
22:55:42 <mattr> shergill: sounds awesome, haskelldb was second on my list of likely contenders, but rails has spoiled me for lower-level apis :)
22:56:12 <killy9999> shachaf: I think I would if I followed solution proposed by AfC
22:56:29 <killy9999> since it depends on which parameters I want to pass in first
22:56:45 <shachaf> killy9999: It's an unfortunate fact of computer programs that if you put into the machine the wrong figures, the right answers won't come out.
22:56:57 <killy9999> ?
22:57:00 <shachaf> What kind of solution are you hoping for?
22:57:38 <killy9999> I was thinking there miht be some already existing function tat could achieve that
22:58:47 <shachaf> apply3rdAnd4thArgsInA4ArgFunction?
22:59:03 <shachaf> What sort of thing are you hoping to be able to type here?
22:59:04 <shachaf> Maybe you want a concatenative language. :-)
23:00:30 <killy9999> shachaf: I'll be perfectly satisfied with "there is no such function" answer
23:01:08 <MostAwesomeDude> So is SDL the best bet for making games? Not that I don't like SDL, but I was kinda hoping that somebody had built a Cocos-ish thing that was all Haskelly and leveraged types.
23:01:13 <shachaf> killy9999: I'm really wondering what you're hoping to type that would be clearer than (\a b -> f a b foo bar)
23:01:28 <shachaf> killy9999: I don't really like those points -- if you have a good proposal I'd be happy to hear it. :-)
23:03:21 <killy9999> shachaf: there are already some functions that do this kind of stuff on binary functions, I was thinking that they might have a generalization :)
23:03:47 <Axman6> @djinn (a -> b -> c -> d -> e) -> c -> d -> (a -> b -> e)
23:03:47 <lambdabot> f a b c d e = a d e b c
23:04:21 <Axman6> @@. pl djinn (a -> b -> c -> d -> e) -> c -> d -> (a -> b -> e)
23:04:26 <Axman6> @. pl djinn (a -> b -> c -> d -> e) -> c -> d -> (a -> b -> e)
23:04:26 <lambdabot> f = ((flip . (flip .)) .) . flip . (flip .)
23:05:08 <shachaf> @ty ((flip . (flip .)) .) . flip . (flip .)
23:05:10 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) b a1. (Functor f, Functor f1) => f (f1 (a1 -> a -> b)) -> a1 -> a -> f (f1 b)
23:05:10 <shachaf> @ty let flip = P.flip in ((flip . (flip .)) .) . flip . (flip .)
23:05:12 <lambdabot> Couldn't find qualified module.
23:05:18 <shachaf> @ty let flip = Prelude.flip in ((flip . (flip .)) .) . flip . (flip .)
23:05:20 <lambdabot> forall a b a1 c b1. (a -> a1 -> b1 -> b -> c) -> b1 -> b -> a -> a1 -> c
23:06:01 <shachaf> @ty let flip = Prelude.flip; flop = (flip Prelude..) in flop flop .: flip . flop
23:06:02 <lambdabot> forall a a1 b c b1. (a -> a1 -> b1 -> b -> c) -> b1 -> b -> a -> a1 -> c
23:07:22 <newsham_> ?type out
23:07:24 <lambdabot> forall (t :: * -> *). Mu t -> t (Mu t)
23:07:28 <newsham_> ?type flip out
23:07:29 <lambdabot> forall a. a -> Mu ((->) a) -> Mu ((->) a)
23:08:11 <shachaf> @ty let flip = Prelude.flip; flop = (flip Prelude..) in flop flop .: flop flop
23:08:12 <lambdabot> forall a a1 b c b1. (a -> a1 -> b1 -> b -> c) -> b1 -> b -> a -> a1 -> c
23:21:46 <test_> testing
23:21:51 <pharaun> hi
23:23:53 * hackagebot cpu 0.1.1 - Cpu information and properties helpers.  http://hackage.haskell.org/package/cpu-0.1.1 (VincentHanquez)
23:24:33 <avpx> I'm curious, what do Haskellers generally use for versioning these days?
23:24:56 <avpx> I'm guessing git or darcs?
23:25:01 <pharaun> i use git
23:25:13 <AfC> i use bzr
23:25:43 <avpx> Hmm, interesting
23:25:52 <unnali> git
23:30:30 <mgsloan> Any constraint kinds experts here?  Still not sure why tuples of constraints have order - this decision seems very broken
23:31:30 <mgsloan> currently I am actually considering a type-level constraint tuple cannonicalizer  -_-  to support type equality on constraint types properly
23:33:18 <mgsloan> quick-sort in the type system paired with TH to derive the ordering relationship between constraint constructors, here we come!
23:45:34 <Gx4> good horning
