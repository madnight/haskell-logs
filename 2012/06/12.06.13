00:05:52 <fragamus> does do notation work with comonads
00:06:11 <c_wraith> not really
00:06:14 <c_wraith> > do 5
00:06:15 <lambdabot>   5
00:06:18 <c_wraith> except in that sense
00:45:45 <hpaste_> “Alexander Yuriev” pasted “Binary ” at http://hpaste.org/69879
01:48:29 <juhp> http://hdiff.luite.com/cgit/glib/commit/
01:48:33 <juhp> yes very cute
01:48:51 <juhp> or please don't ;) :)
01:59:11 <jamil_1> hi
02:03:14 <jamil_1> if a value is of type nil, what is the type of a in data [a] = a:[a] | nil ?
02:03:37 <jamil_1> sorry, if a value IS nil ...
02:04:11 <Ralith> unspecified
02:04:23 <Ralith> try it in ghci
02:04:31 <Ralith> :t []
02:04:32 <lambdabot> forall a. [a]
02:05:32 <quicksilver> jamil_1: nil isn't a type.
02:05:34 <jamil_1> how is nil::[Int] differenct from nil::[Char]
02:05:49 <Ralith> quicksilver: he means the value []
02:05:49 <jamil_1> quicksilver: yeah realied after posting :)
02:05:53 * quicksilver nods
02:06:02 <Ralith> jamil_1: it has a different type.
02:06:06 <quicksilver> jamil_1: in one sense, they are completely unrelated values.
02:06:19 <quicksilver> just represented by the same text
02:06:32 <quicksilver> but that's not really fair - they're are related of course
02:06:52 <quicksilver> they are different instances of the same polymorphic term
02:08:48 <jamil_1> what is an instance of a polymorphic term ?
02:09:05 <quicksilver> well [] :: forall a . [a] is polymorphic
02:09:14 <quicksilver> [] :: [Int] is one instantiation of that.
02:09:40 <quicksilver> I'm not sure it's entirely standard terminology but I can't think of a better word.
02:10:07 <merijn> jamil_1: Think of how "1 :: Num a => a" i.e. an a of any numeric value, depending on type-inferred context
02:10:21 <jamil_1> how is this different from saying [] is a value of type [a]
02:10:38 <jamil_1> merijn: isn't this a type contraint ?
02:10:42 <jamil_1> constraint
02:10:43 <quicksilver> [] :: [a] is precisely saying [] is a value of type [a]
02:10:54 <jamil_1> sorry for my bad typing
02:10:59 <quicksilver> merijn: I think you may have appealed to a more advanced concept to try to explain a simpler one?
02:11:18 <merijn> quicksilver: Yeah, I realised after I hit enter that that probably didn't help
02:11:18 <quicksilver> merijn: I don't think jamil_1 is *more* comfortable with numeric overloading than he is with polymorphism in general.
02:11:42 <quicksilver> jamil_1: no problem with your typing but I'm not sure quite how best to answer your question
02:11:56 <quicksilver> it feels like we're following definitions around in circles :)
02:13:23 <merijn> jamil_1: "forall a. [a]" means that the compiler knows how to construct a value of type [a] regardless of which a you want. However, *at some point in time* the compiler will actually have to pick which a to *actually* use
02:14:28 <merijn> jamil_1: So if you use "[]" in a context where the compiler infers that you wanted [Int] it will create an instance of [] for [Int]. Now in practice the implementation of [] might be the same for all values of 'a', but there's no real restriction forcing that to be the case
02:14:37 <jamil_1> I asked this before, but is there something opposed to forall ? like forsome ?
02:14:56 <merijn> jamil_1: exists, but as far as I can tell GHC implements exists using forall
02:15:21 <merijn> (In other words, semantically there is an "exists", but there's no keyword for it)
02:15:49 <merijn> In type theory you will reasonably frequently encounter a separate notation for "exists", though
02:17:39 <jamil_1> the reason I asked this is because when I see people using forall the first think that comes to mind is that there must be some thing other than forall, the reason people are trying to be precise
02:18:04 <merijn> jamil_1: Well, usually the location of forall can change the meaning
02:18:37 <jamil_1> how so ?
02:19:43 * merijn is trying to think of an example that is clear, but not with much success
02:20:58 <merijn> I might be screwing this up, in which case I assume someone will correct me :p "forall a . a -> String" is different from "(forall a . a) -> String"
02:21:19 <quicksilver> merijn is right, those are different.
02:21:32 <quicksilver> also, forall a . [a] is different from [forall a. a]
02:21:42 <merijn> The former says "there is a function 'a -> String' for all possible types of a" (i.e., number of functions is equal to the number of types a)
02:22:07 <merijn> The latter says "there is a function that takes *any* input type and returns a String" (i.e., only one function taking any input type)
02:22:22 <merijn> Mind you, the latter function is not very useful, most likely :p
02:22:41 <quicksilver> I don't really agree with that description.
02:22:43 <rtharper> are nullary constructors always shared?
02:22:51 <rtharper> anyone know?
02:22:56 <jamil_1> oh right, like different scope for forall
02:23:01 <merijn> quicksilver: I'm half making this up, feel free to correct any mistakes :)
02:23:05 <quicksilver> rtharper: in GHC, yes, but htat's an implementation detail and not part of the language obviously.
02:23:08 <rtharper> aye
02:23:13 <rtharper> thanks
02:23:14 <rtharper> =)
02:23:21 <quicksilver> "forall a . a -> String" is a function which can take any input type.
02:23:27 <merijn> jamil_1: You can erase "like" from that observation. Different scopes is exactly what it is
02:23:32 <quicksilver> you could *also* think of that as a family of functions, one per type.
02:23:45 <quicksilver> those two descriptions are two perspectives on the same idea.
02:24:00 <quicksilver> "(forall a . a) -> String" is a function which takes polymorphic values
02:24:14 <quicksilver> its parameter must be a "value of every type"
02:24:16 <merijn> quicksilver: Yeah, I wasn't really sure how to distinguish the meaning
02:24:22 <quicksilver> or a "value which is prepared to inhabit any type"
02:24:30 <merijn> Or maybe just wrong in general :p
02:24:37 <quicksilver> in standard haskell there are no such values except undefined, though.
02:24:45 <quicksilver> forall a . a is uninhabited.
02:25:03 <rtharper> we should colonise
02:25:12 <rtharper> terraform, perhas
02:25:15 <rtharper> perhaps(
02:25:18 <jamil_1> lol
02:25:21 <Ralith> ah, but then it wouldn't be forall a . a anymore!
02:25:39 <merijn> quicksilver: Only in ideal theory world, right? Since in actual implemented haskell undefined inhabits everything rendering the type system consistency slightly suspect in practice
02:26:05 <rtharper> :t undefined
02:26:07 <lambdabot> forall a. a
02:27:17 <danr> quicksilver: is it so that the `forall' in [forall a . a] works as an existential?
02:29:10 * hackagebot ghc-mod 1.10.18 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.10.18 (KazuYamamoto)
02:31:31 <jamil_1> thanks merijn, quicksilver I think now I understand the difference :)
02:31:59 <ion> Ooh, i’ll have to try ghc-mod.
02:34:01 <LambdaDusk> when exactly is an IO () function "executed"... like when I am having an Arrow of the type a e [IO ()] to collect drawing functions, are they executed right then...?
02:34:41 <ion> When they’re assigned to “main” directly or as a combination with other actions that lead to them.
02:35:23 <quicksilver> danr: I wouldn't say that, no.
02:35:29 <ion> You’ll have to get the IO () values out of there somehow and have a code path from “main” to them to have them executed.
02:36:04 <quicksilver> merijn: if "unihabited" is to mean anything then it means "types for which the only valid values are _|_"
02:36:16 <quicksilver> merijn: and, we want it to mean something, because its' a useful word :)
02:36:18 <LambdaDusk> ion: Thanks
02:36:42 <quicksilver> danr: [exists a . a] would be a list of things, each of which has some (unknown/unspecified) type.
02:37:04 <quicksilver> danr: [forall a . a] is a list of things, each of which can take *every* type.
02:37:17 <quicksilver> some people like to relate the duality to playing a game.
02:37:36 <quicksilver> in [exists a . a] "your opponent" gets to choose the type of each element, and can do so in whatever way will be most annoying to you.
02:37:50 <quicksilver> in [forall a . a] you get to choose the type of each element, in whatever way is most convenient to you.
02:37:57 <ion> Also, it might be confusing to think of them as functions. “Actions” is a good word; function is anything with “->” in its type.
02:38:53 <b6> hi, i'm maintainer of glfw-b. a user reported failure to install on OS X. could somebody with OS X try to install it and see if they hit an issue?
02:41:20 <merijn> LambdaDusk: IO actions are lazy (just like everything else), so the only way the IO actions in a list will be executed is if you use them in some other IO actions. (For example using their return value in main)
02:42:06 <quicksilver> the reason they are not executed is not because they are lazy.
02:42:17 <quicksilver> even if they were strictly evaluated they would not be executed.
02:42:26 <quicksilver> because evaluation is not execution.
02:42:43 <quicksilver> > putStrLn "ninja text" `seq` "empty room"
02:42:45 <lambdabot>   "empty room"
02:43:15 <quicksilver> seq ensures the evaluation of the putStrLn, but that certainly does not cause its execution.
02:44:52 <merijn> LambdaDusk: Ok, to be more pedantic (although I guess others will still feel this isn't correct  enough): You need to chain the result of your IO actions all the way back to main which will cause them to be executed when main is executed.
02:45:59 <LambdaDusk> merjin: Thanks, now I understand it. I was just afraid that FFI actions are somehow evaluated even though I only want to "collect" possible actions to execute them later
02:46:06 <quicksilver> yes
02:46:07 <merijn> Given [IO ()] You must likely want to use "sequence_ :: [m a] -> m ()" (essentially just "sequence :: [m a] -> m [a]" which discards its result)
02:46:13 <LambdaDusk> tl;dt I am dumb
02:46:15 <quicksilver> no need to be afraid, LambdaDusk
02:46:24 <merijn> To actually run them, that is
02:46:32 <quicksilver> collecting them to execute later is exactly one of the cool things you can do with first-class actions
02:46:40 <merijn> If you don't want to run them, just pass them through lists/whatever without worrying
02:46:41 <quicksilver> it's one of the things that made the IO type finally make sense to me
02:47:03 <merijn> Word. First class IO is cool :>
02:47:04 <quicksilver> (you can store IO a actions in lists, send them over Chans, duplicate them, store them in Maps - and finally execute them later)
02:47:20 <LambdaDusk> Yes, I like IO better now
02:48:14 <LambdaDusk> I have seperated input, update and draw actions, and my update collects the necessary drawing for the last action
02:51:23 <LambdaDusk> also, there's a mapM function that maps a monadic action over a list... is there an equivalent function for arrows?
02:51:45 <LambdaDusk> arrows are generally not functors, so no fmap...
02:52:04 <quicksilver> arrows generally *are* functors actually
02:52:10 <quicksilver> (in their right-hand parameter)
02:52:24 <quicksilver> there might be some condition required for that to be true I don't remember.
02:52:37 <LambdaDusk> the SF arrow is not =/
02:52:47 <quicksilver> LambdaDusk: can't you just compose with pure?
02:52:58 <quicksilver> if my_arr :: a b c
02:53:03 <quicksilver> and pure_f :: c -> d
02:53:15 <quicksilver> then my_arr >>> pure (pure_f) :: a b d
02:53:17 <quicksilver> right?
02:53:46 <LambdaDusk> that would be just a simple map
02:53:58 <LambdaDusk> but I have an Arrow that I want to apply to a list
02:54:05 <quicksilver> show me the types.
02:54:07 <LambdaDusk> wait, I'll quickly gist it
02:54:17 <quicksilver> or a simplified version if you like :)
02:54:31 <LambdaDusk> https://gist.github.com/2923143
02:54:39 <LambdaDusk> I have the curRect arrow
02:54:39 <ion> Huh, pure works in there?
02:54:50 <ion> pure = arr?
02:54:52 <LambdaDusk> he means "arr"
02:55:18 <LambdaDusk> anyway, I have the curRect, and I want to apply it to a [Tile] as well
02:55:34 <quicksilver> arr was called pure at one point
02:55:58 <LambdaDusk> but it is not pure as in Applicative, right
02:56:14 <quicksilver> it's not although it is related
02:56:46 <quicksilver> so your question is about applying an arrow "a b c" to a list [b] ?
02:56:50 <ion> Was that before Applicative existed?
02:57:19 <LambdaDusk> quicksilver: Yes, like mapM applies a "b -> m a" to a list of [b]
02:58:46 <LambdaDusk> actually, it would be more like "Arrow a => a b c -> a [b] [c]"
02:59:29 <quicksilver> I remember thinking about this before
02:59:39 <quicksilver> you can build something out of ***
03:00:42 <quicksilver> f *** f :: a (b,b) (c,c)
03:00:49 <quicksilver> lets you apply it to two elements at onece
03:00:59 <quicksilver> you can fold *** over a list to apply to lots
03:01:15 <quicksilver> but I can't remember if there is some problem with that idea
03:01:57 <LambdaDusk> sorry, have to brb for some minutes
03:02:47 <ziman> can you even "apply" arrows?
03:03:17 <ziman> what you describe is creating an arrow a [b] [c], not applying (a b c) to the whole lot of [b]
03:03:37 <bartavelle> is there something I should know with the System.Process "system" function and forkIO ? I either have not found a stupid bug, or I cannot run concurrently more than 2 system commands
03:03:58 <quicksilver> ziman: yes, that is what I am describing.
03:04:16 <quicksilver> ziman: the use of the word 'apply' was an abuse of notation.
03:04:42 <ziman> so hopefully LambdaDusk abused the notation the same way
03:04:52 <quicksilver> agreed.
03:05:06 <quicksilver> he did say "it would be more like "Arrow a => a b c -> a [b] [c]"
03:05:10 <quicksilver> so I think he was on the same page.
03:05:23 <bartavelle> ah
03:05:26 <quicksilver> bartavelle: are you compiling with -threaded?
03:05:31 <bartavelle> just realized it
03:05:41 <LambdaDusk> quicksilver, ziman: Yes, like that...
03:05:57 <bartavelle> so that was something stupid
03:07:16 <LambdaDusk> how could you feed a ghci command to the lambda bot again?
03:07:50 <sipa> what kind of command?
03:08:09 <ziman> > fix error
03:08:10 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
03:08:11 <LambdaDusk> :t foldr (***)
03:08:12 <lambdabot>     Occurs check: cannot construct the infinite type: b' = (b, b')
03:08:12 <lambdabot>       Expected type: a b' c'
03:08:12 <lambdabot>       Inferred type: a (b, b') (c, c')
03:08:18 <LambdaDusk> ah
03:09:44 <quicksilver> LambdaDusk: http://stackoverflow.com/questions/6894253/is-map-f-concatmap-map-f uses arrowchoice
03:09:53 <quicksilver> which maybe says it's a bit more fiddly than I was suggesting.
03:11:10 <LambdaDusk> yeah SF doesn't instance ArrowChoice for a reason, I guess...
03:11:46 <LambdaDusk> I use the Yampa SF and that one's a bit more complicated
03:11:55 <quicksilver> you've reached the limits of my intuition I'm afraid
03:12:01 <ClaudiusMaximus> i have a solution using arrow notation (well, it typechecks)
03:12:49 <LambdaDusk> quicksilver: http://www.haskell.org/pipermail/haskell-cafe/2011-July/094030.html says that ArrowChoice is not possible within Yampa SF
03:12:56 <LambdaDusk> ClaudiusMaximus: I am eager to hear it
03:13:00 <ClaudiusMaximus> :t let parallel f = proc xs -> do{ case xs of [] -> returnA -< [] ; (h:ts) -> arr (uncurry (:)) <<< f *** parallel f -< (h, ts) }
03:13:02 <lambdabot> parse error on input `->'
03:13:09 <ClaudiusMaximus> (needs -XArrows)
03:14:02 <quicksilver> ClaudiusMaximus: that is roughly my idea of repeated applications of *** correct?
03:14:09 <ClaudiusMaximus> yeah
03:14:15 <ClaudiusMaximus> and it has type   parallel :: ArrowChoice t => t b a -> t [b] [a]
03:14:21 <ClaudiusMaximus> according to ghci
03:14:55 <quicksilver> ah, so it does require arrowchoice
03:15:18 <ClaudiusMaximus> i imagine that's what the case needs
03:15:23 <quicksilver> yes
03:15:37 <quicksilver> case or if in arrow notation pulls in ArrowChoice
03:15:51 <LambdaDusk> yeah, I've hit that before =/
03:16:49 <LambdaDusk> at least I feel less dumb now for not finding a solution...
03:18:31 <ben_> let x' = fromIntegral x'
03:18:37 <ben_> hmm why is my program hanging
03:19:07 <fmap> > let x = x in x
03:19:11 <lambdabot>   mueval-core: Time limit exceeded
03:19:28 <quicksilver> ben_: that is recursive.
03:19:31 <ben_> that would be silly, it's clearly
03:19:36 <ben_> > let x = id x in x
03:19:39 <lambdabot>   mueval-core: Time limit exceeded
03:31:42 <LambdaDusk> quicksilver: I have rewritten the entire thing to use list of tiles instead of single tiles: https://gist.github.com/2923143
03:32:11 <LambdaDusk> Now I am kinda stuck trying to find a way to turn "drawTiles :: SF [Tile] (Surface -> Surface -> [(Int, Int) -> IO ()])" into "drawTiles :: SF [Tile] (Surface -> Surface -> [(Int, Int)] -> IO ())"
03:45:02 <merijn> LambdaDusk: The (Int, Int) comes from surface I guess?
03:45:25 <LambdaDusk> no, the (Int, Int) is the position of each tile, individually
03:45:45 <merijn> I'd say use map and ($) to turn "[(Int, Int) -> IO ()]" into [IO ()] and then sequence_ to turn [IO ()] into IO ()
03:45:49 <LambdaDusk> they all share the same source surface and are drawn on the same dest surface
03:46:23 <LambdaDusk> huh?
03:47:34 <merijn> LambdaDusk: Well, after passing in the source/destination surfaces you (now) have [(Int, Int) -> IO ()], right?
03:47:44 <LambdaDusk> yes
03:48:10 <merijn> Which you presumably want to apply to (Int, Int) in some fashion. And I gather (Int, Int) is coming from the [Tile] value?
03:48:23 <LambdaDusk> no
03:48:31 <LambdaDusk> that will be coming from the TileMap, later
03:48:47 <LambdaDusk> TileMap is a 2D array of Tiles
03:49:46 <merijn> Anyhoo, do you want to apply the "[(Int, Int) -> IO ()]" functions to one (Int, Int) value, to each of multiple (Int, Int) values or do you want to apply each function to a different (Int, Int)?
03:50:35 <LambdaDusk> the latter
03:51:07 <LambdaDusk> because that way I can do an isometric map, too
03:51:29 <merijn> Okay, then you probably want "zipWith ($)" for that step
03:51:32 <merijn> :t zipWith ($)
03:51:33 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
03:51:37 <LambdaDusk> the actual tile positions will have to be provided by the TileMap, when it is drawn
03:51:46 <merijn> Make sense?
03:51:48 <LambdaDusk> yes
03:52:19 <merijn> ok, so now you just want to turn that [IO ()] result into IO () to get the type signature you want, right?
03:52:26 <merijn> :t sequence
03:52:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:52:29 <merijn> :t sequence_
03:52:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
03:53:48 <merijn> :t \x y -> sequence_ $ zipWith ($) x y
03:53:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => [b -> m a] -> [b] -> m ()
03:54:55 <merijn> Make sense?
03:55:02 <LambdaDusk> yes it does
03:55:17 <LambdaDusk> but the type checker gives me trouble as I am trying to insert hat
03:55:19 <LambdaDusk> *that
03:56:00 <Peaker> lambdabot, what do you get?
03:56:03 <Peaker> oops
03:56:06 <Peaker> LambdaDusk, ^^
03:56:46 <LambdaDusk> I changed the offending line to "returnA -< \src dst -> sequence_ . zipWith ($) . (map (drawTile' src dst) rs)" and get Tile.hs:30:44:
03:56:46 <LambdaDusk>     Couldn't match expected type `[m0 a0]'
03:56:46 <LambdaDusk>                 with actual type `[b0] -> [c0]'
03:56:46 <LambdaDusk>     Expected type: [a1] -> [m0 a0]
03:56:46 <LambdaDusk>       Actual type: [a1] -> [b0] -> [c0]
03:56:47 <LambdaDusk>     In the return type of a call of `zipWith'
03:56:47 <LambdaDusk>     Probable cause: `zipWith' is applied to too few arguments
03:56:48 <LambdaDusk>     In the first argument of `(.)', namely `zipWith ($)'
03:56:51 <LambdaDusk> oops sorry
03:57:30 <LambdaDusk> oh wai
03:57:31 <LambdaDusk> t
03:57:45 <LambdaDusk> i removed the (.) between zipWith and map
03:57:49 <LambdaDusk> now it's fine
03:57:57 <merijn> \o/
03:58:11 <LambdaDusk> thank you guys so much, you're awesome
03:59:00 <merijn> Man, I need to make a site where people can give testimonials so I can turn #haskell karma into employment recommendations :>
03:59:12 <hpc> heh
03:59:50 <LambdaDusk> merijn: Then go for it. Though in my experience there aren't many haskell employers
04:00:20 <merijn> The trick is to not look for haskell employers, but employers in general and then just not telling them you're solving their problems in haskell :p
04:01:00 <LambdaDusk> what a trick
04:02:42 <LambdaDusk> the result, for those who care (ie nobody): https://gist.github.com/2923143
04:06:37 <merijn> Hah, I might just check that out later, just because I couldn't be arsed to figure out Yampa + graphics myself and now can just let you do the annoying figuring out and steal the lessons later :p
04:07:20 <merijn> On semi-unrelated note, it's really nifty how I can troubleshoot people haskell code while barely having a clue what it does :D
04:07:31 <hpc> you have the types
04:07:38 <hpc> i wouldn't call that "barely having a clue"
04:07:56 <merijn> hpc: Yeah, but I don't know what any of those types are beyond (->) and [] :p
04:08:31 <merijn> Imagine troubleshooting someone's Java/C code based on just the types...
04:08:56 <hpc> that's because java/c types are completely meaningless...
04:09:59 <merijn> hpc: Just the fact that haskell's types are expressive doesn't make it a less nifty feat. Point remains you couldn't do that in any popular language (well, maybe ocaml/SML which is stretching the definition of popular)
04:11:59 <LambdaDusk> merijn: In that case, you might want to watch my Yampa project as I am painstalkingly stagger along: https://github.com/scan/PonyQuest
04:12:43 <LambdaDusk> the main program already uses the input to move a square about, it's total nonsense, but imagine how happy I was after 5 hours to get that done
04:16:44 <merijn> :)
04:19:25 <hilhil> @hoogle Maybe a -> Either b a
04:19:25 <lambdabot> Prelude Right :: b -> Either a b
04:19:25 <lambdabot> Data.Either Right :: b -> Either a b
04:19:25 <lambdabot> Prelude Left :: a -> Either a b
04:19:40 <LambdaDusk> generally, Haskell is a language that makes you happy: Even the simplest tasks can become so painfully difficult to shove into the type checker's maw that you're as happy as can be when it finally digests your crap
04:20:30 <hilhil> But when something type checks, it very often works first time run...
04:20:52 <hilhil> I often find that I hit 10x fewer run-time errors in Haskell
04:21:11 <hilhil> (Unfortunately they often  take 5x as long to debug, but it's still nice.)
04:21:40 <LambdaDusk> hilhil: Exactly what I love about Haskell - it just works
04:22:24 <hilhil> If the debugging and profiling tools were comparably good, I'd probably never use anything else
04:22:37 <hpc> hilhil: eventually you will get REALLY good at tracking down runtime errors
04:22:56 <hpc> when that happens, go learn another language, like ruby
04:23:07 <hpc> then see how fast you can code and for how long without runtime errors
04:23:08 <hilhil> I can track things down. But I don't think I'll ever be as fast as I'll be in a language with better debugging tools.
04:23:23 <hpc> hilhil: you will
04:23:35 <hpc> in my experience, debugging tools provide too much data to be helpful
04:23:42 <hilhil> Usually my runtime errors are conceptual
04:24:10 <hilhil> I mean something as simple as (in an imperative language) being able to step through something in a debugger and then
04:24:20 <hilhil> Seeing exactly which code path is taken
04:24:26 <hilhil> And possibly examining the values of one or two variables
04:24:28 * hackagebot sodium 0.4.0.0 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.4.0.0 (StephenBlackheath)
04:24:34 <hilhil> not putting traces on everything in sight
04:24:50 <hilhil> So I'd agree that debugging tools certainly can swamp you in data...
04:24:56 <hilhil> But they don't have to be used that way.
04:25:02 <Peaker> LambdaDusk, getting stuff to type-check becomes easier and easier with time
04:25:18 <Peaker> LambdaDusk, also you learn to discern what the errors mean pretty quickly
04:25:51 <Peaker> hilhil, Haskell could definitely use better debuggers
04:26:06 <Peaker> I think nobody has tapped into the awesome power of pure-code-debugging yet
04:26:29 <Peaker> If you are debugging correctness, rather than performance, evaluation order does not matter, so you can just dive into any computation you want with a debugger
04:26:45 <Peaker> If you are debugging performance, then maybe "step-through" isn't a very good way to debug it anyway
04:26:51 <LambdaDusk> btw, is there a reason why hackage recently doesn't do haddocks on libs any more?
04:27:06 <Peaker> LambdaDusk, why do you think it doesn't?
04:27:23 <Peaker> new libs often take a while to get their haddocks generated
04:27:38 <LambdaDusk> but surely not some days?
04:27:59 <Peaker> do you have an example?
04:29:06 <LambdaDusk> not on my hand... it's usually I try to look it up and then I have to go versions backwards - but I never note which libs exactly
04:33:10 <Peaker> LambdaDusk, I'm betting they're newer than a few days old when that happens
04:33:26 <LambdaDusk> ok, sorry then
04:33:29 <Peaker> LambdaDusk, if you want, you can enable the documentation building in your private cabal, so that "cabal install" makes docs
04:33:37 <Peaker> LambdaDusk, then you'll have all the haddocks locally
04:39:02 <dzhus> can 10% GC time be considered a nice value?
04:44:44 <hpc> dzhus: if the total runtime is nice, then yes :P
04:45:51 <hpc> if it isn't, the best you can do is a 10% speedup by optimizing just the time spent in GC
04:46:15 <hpc> so basically, it can't be considered any kind of value, without context :P
04:47:01 <shirt> is there a flag to completely disable GC?
04:47:30 <hpc> no
04:47:39 <hpc> you wouldn't want it, anyway
04:48:03 <hpc> haskell code can allocate gigs per second, easily
04:48:33 <hpc> and 99% of it is going to have a lifetime of maybe 100 clock cycles
04:49:00 <shirt> i have a program where GC is taking 30% of running time. the program is very short lived, just opens a file, analyzes it, prints some output and exits.
04:50:30 <Siod> how can i check if a haskell program is already open
04:51:09 <ClemHout> shirt: http://www.haskell.org/haskellwiki/Performance/IO
04:51:09 <shirt> Siod: same way you check if any other program is already open
04:51:33 <hpc> Siod: an easy way in any language is to write a pid file to /tmp or somewhere
04:51:38 <Siod> id use a mutex in c++
04:51:58 <hpc> and then when you run a new instance, if there's a pid in the file, that's the pid of the program already running
04:52:00 <shirt> ClemHout: interesting, but in my program IO is not the bottleneck
04:52:07 <Peaker> Siod, mutexes are typically process-local
04:52:15 <Siod> http://msdn.microsoft.com/en-us/library/windows/desktop/ms682411%28v=vs.85%29.aspx peaker
04:52:31 <Peaker> Siod, ouch, my eyes!!
04:52:46 <Siod> hurr
04:52:54 <LambdaDusk> Array (Int, Int) a vs. [[a]], your opinions?
04:53:17 <Peaker> Siod, yes, it is possible to create IPC mutexes, you could call that same function from Haskell
04:53:30 <hpc> LambdaDusk: need random access?
04:53:36 <taylorgb_> It's not such a great idea to use mutexes for that on windows, as someone can just create the mutex first and your program won't start anymore.
04:53:43 <Peaker> LambdaDusk, lists are a great control structure but a pretty bad data structure
04:54:09 <LambdaDusk> hpc: Perhaps I need to "slice" a 2-dimensional portion out of it
04:54:15 <LambdaDusk> oh wait I don't
04:54:20 <LambdaDusk> Haskell is lazy
04:54:30 <ClemHout> shirt: I just assumed that the IO of your program is what gives a lot of work to the GC... maybe I'm wrong :)
04:55:32 <Siod> Peaker: i didn't see it in the win32 api on hackage
04:56:11 <Siod> or is there a more portable way of doing the same thing
04:57:17 <LambdaDusk> peaker, hpc: I am actually in favour of the Array because with [[a]] I can't be sure all the inner lists have the same length
04:57:34 <Peaker> Siod, you could extend the win32 package
04:58:02 <Siod> better yet is there a portable way of doing it
04:58:50 <Siod> maybe there's a haskell library that abstracts listing processes?
04:58:55 <Peaker> LambdaDusk, you could create a data-type that forces all the lists to be the same length
04:59:00 <taylorgb_> You can always use a lock file in some data directory
04:59:04 <Peaker> LambdaDusk, while still being lists
04:59:16 <taylorgb_> What is the nature of the requirement for only one instance, is there some underlying contended resource?
04:59:18 <Peaker> Siod, a pidfile is probably best..
04:59:43 <hpc> @hoogle pidfile
04:59:43 <lambdabot> No results found
05:00:02 <LambdaDusk> Peaker: You mean by only allowing it to be created via a constructor that ensures this?
05:00:49 <Peaker> LambdaDusk, that's one option, but I actually meant using types
05:01:30 <LambdaDusk> Peaker: Uh, do you have an example, perhaps?
05:01:54 <Peaker> Writing one down
05:04:27 <LambdaDusk> Peaker: Thanks
05:04:49 <quicksilver> Peaker: do you have any pictures of bottle? I am intriguied.
05:06:22 <Peaker> quicksilver, after writing LambdaDusk's example, I'll take some newer screenshots
05:06:23 <adamt> is there any nice alternatives to (Map String (Map String Int))? I need to be able to do a mapping from hostname -> [list of routes for that host] -> portnumber.
05:06:30 <quicksilver> Peaker: thank you.
05:06:36 <Peaker> quicksilver, it's really cool, screenshots won't do it justice cause it has shiny animations :)
05:06:46 <Peaker> quicksilver, best if you run it
05:07:00 <quicksilver> I probably can't. What libraries does it depend on?
05:07:14 <Peaker> GLFW-b/OpenGL/drawing-combinators,   berkeley db
05:08:19 * quicksilver has the 6.12.1 version of the haskell platform
05:09:34 * hackagebot async 2.0.0.0 - Run IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/async-2.0.0.0 (SimonMarlow)
05:10:23 <LambdaDusk> I thought GHC haskell is Async by default?
05:10:35 <quicksilver> I'm not sure what the question means, LambdaDusk
05:10:49 <adamt> quicksilver: Related to the hackagebot announcement.
05:10:52 <quicksilver> sure
05:11:01 <quicksilver> still don't really know what "async by default" would mean
05:11:07 <quicksilver> a <- doSomething
05:11:13 <LambdaDusk> http://news.ycombinator.com/item?id=1549228
05:11:18 <quicksilver> what value does 'a' contain if haskell was async by default?
05:11:23 <hpc> it means async semantics
05:11:43 <quicksilver> LambdaDusk: that just means that haskell threads cooperate over IO.
05:11:55 <quicksilver> LambdaDusk: it's orthogonal to JaffaCake's upload
05:12:08 <hpaste_> Peaker pasted “LenList” at http://hpaste.org/69883
05:12:08 <LambdaDusk> quicksilver: Oh sorry. I misunderstood it, then
05:12:12 <Peaker> LambdaDusk, ^^
05:12:16 <quicksilver> async by default would mean that every single IO action would have to return a promise, I guess
05:12:19 <quicksilver> or a deferred
05:12:22 <quicksilver> or whatever the trendy name is these days.
05:12:29 <quicksilver> but, that's not a very convenient API :)
05:12:53 <Peaker> I guess "async" would mean that the kernel calls used are the nonblocking ones with a polling mechanism (like epoll)
05:12:59 <Peaker> rather than kernel threads with blocking calls
05:13:04 <Peaker> (which is indeed how GHC works)
05:13:46 <Peaker> every IO bind, binds a callback, so it's all very async anyway :)
05:14:12 <quicksilver> you don't mean kernel calls, Peaker
05:14:32 <Peaker> quicksilver, libc calls?
05:14:33 <quicksilver> but yes, certainly GHC uses select/epoll for its file descriptor IO
05:14:44 <quicksilver> however that's only relevant if your program has multiple threads.
05:14:54 <LambdaDusk> Peaker: Thanks for the example... The "n" part would be abstracted away after compilation?
05:14:57 <quicksilver> and file descriptor IO != all IO.
05:15:03 <Peaker> LambdaDusk, note "n" is a phantom type
05:15:22 <Peaker> LambdaDusk, it's not the type of any value -- it's there for type-checking purposes only
05:15:40 <LambdaDusk> Peaker: the problem here would be that the user can't type in an integer and have the square generated from it ^^
05:16:04 <Peaker> UnknownLenList is supposed to make you able to degrade LenList back to list of unknown length -- but I failed to whip up a fromList for it :) My GADT foo is limited, so it all takes me a while
05:16:27 <Peaker> LambdaDusk, sure it can :)   You can have functions that extend the square
05:16:29 <LambdaDusk> it is surely very interesting
05:16:55 <Peaker> LambdaDusk, you can write:  extend :: LenList n a -> LenList n a -> a -> Square n a -> Square (Succ n) a
05:17:02 <Peaker> (row, column, corner) args
05:17:37 <Peaker> LambdaDusk, notice that the type-checking here checks *symbolically* that the "n" is being maintained correctly, it doesn't need to know the actual runtime value of "n"
05:18:02 <Peaker> (there is no actual runtime value of "n" as it is erased)
05:18:04 <LambdaDusk> Peaker: and by adding it incrementially when creating from a list, it should work ^^
05:18:27 <LambdaDusk> would it be able to also make it a Binary instance?
05:18:35 <LambdaDusk> *it be possible
05:18:46 <Peaker> LambdaDusk, yes, but you will need to use a wrapper type like UnknownLenList, or UnknownSquare  for the result of your from-user-generation,  so your user input results in something like:   exists n. Square n a
05:19:32 <Peaker> LambdaDusk, it should be possible, but note that since the length is static, the binary instance is going to depend on the specific "n". You could have a binary instance for "UnknownLenSquare" that serializes the "n" too
05:19:55 <Peaker> i.e: a binary instance for Square is going to want a compile-time-specified "n" to deserialize from
05:20:11 <Peaker> (when serializing, it can rely on the Cons/Nil distinction)
05:20:57 <LambdaDusk> Peaker: Very nice, thank you. Unsure if it's not an overkill for my application, but I will experiment with it nevertheless
05:23:58 <Peaker> quicksilver, http://i.imgur.com/JdPsJ.png
05:24:12 <Peaker> quicksilver, extremely cluttered at the moment, the UI needs mucho work :)
05:24:23 <Peaker> though I think this clutter mode could still be useful when debugging type errors
05:25:01 <Peaker> quicksilver, note how it can semi-handle infinite types.. That screenshot doesn't have type errors though, I'll make one with errors
05:25:56 <LambdaDusk> Ok, guys, I have to go home, see ya later!
05:26:10 <Peaker> quicksilver, http://i.imgur.com/JSTWG.png
05:26:33 <Peaker> quicksilver, note how it shows the inferred types for "badType" are both the annotated type "Integer" and the function type "Bool -> Bool"
05:26:39 <Peaker> (because 'x' is annotated as Bool)
05:26:45 <Peaker> so the conflict is marked as red
05:27:02 <Peaker> quicksilver, also notice that for now, "if" is polymorphic so it is used with an explicit "Integer" type param
05:27:26 <Peaker> quicksilver, one thing that's really nice, is that when you start typing into a "hole" it shows the type you need to fill out under the hole you're filling
05:28:21 <Peaker> there are also lots of niceties -- no explicit "save", everything is saved as you type.  "undo buffer" persists and is the structural revision control -- no need to guess what the user changed.  branch switching/creation is quick and easy inside the same GUI. (diffs/merges are not yet supported..)
05:28:23 <quicksilver> Peaker: very interesing yes
05:28:39 <quicksilver> very ugly but that's not the point ;)
05:28:58 <Peaker> hehe, practicality over asthetics :-)
05:29:09 <Peaker> I only find the clutter ugly
05:29:21 <Peaker> but it is indeed useful to see those types, so maybe it should just be a mode
05:29:30 <quicksilver> what language is that which has Prelude.if?
05:30:05 <Peaker> quicksilver, hehe, all the "builtins"/imports are supposedly "FFI to Haskell", but of course we just made up our random imports
05:30:13 <Peaker> for the purpose of being able to test this preliminary editor
05:30:23 <quicksilver> <8202..> is a generated type variable?
05:31:10 <Peaker> quicksilver, it's actually the same type of "if" as above the "if", but it got its own Guid, and the references to variables are via guids, and that guid has no associated name in the database, so it's displayed as first 4 hex chars of the guid
05:31:32 <Peaker> quicksilver, basically you can press <return> on that part of the type, rename it to "a", and then it will show "a" in place of all the 8202..'s
05:31:40 <quicksilver> are you using ghc-api to do the inference?
05:31:48 <Peaker> no, we do our own
05:31:51 * quicksilver nods
05:32:08 <Peaker> but we only have explicit type params, not HM style inference, so it is much easier (for now)
05:32:08 <quicksilver> does this project have a commercial context? or are you donig this for fun?
05:32:55 <Peaker> quicksilver, I've been wanting to make a good structural editor for 10 years, I believe it may help take us out of the programming stone age :)  we hope we can make a commercial profit, but we don't intend to limit the "4 freedoms" of non-profit users
05:33:59 <Peaker> I don't care about limiting the freedoms of for-profit's, though.. so maybe we can do some creative-commons thing rather than an opensource thing
05:34:18 <Peaker> or maybe we can make a closed variant for hardware devel. where virtually everything's for-profit anyway
05:34:37 <Peaker> (and hardware programming is functional, so it can benefit from live execution of code as well, a strength the editor will have in the future)
05:35:22 <quicksilver> Peaker: you ideas are very interesting but I'm wary of coupling VCS too tightly with the editor.
05:35:32 <Peaker> quicksilver, btw, my forage into Haskell started (in late 2007) because I was having a lot of trouble with my attempted implementation of a structural editor in Python, and discovered I was implementing a purely functional DSL on top of Python without knowing anything about pure functional languages
05:35:39 <quicksilver> modular tools are better.
05:36:03 <Peaker> quicksilver, I believe modularity is more about hiding implementation details than having different processes communicating via unix files/etc
05:36:18 <quicksilver> I think I know what you're trying to say
05:36:22 <quicksilver> but I can't agree with what you wrote.
05:36:26 <Peaker> quicksilver, people will be able to replace the source control implementation - but they'll still have the undo buffer available
05:36:33 <quicksilver> "hiding implementation details" is abstraction, not modularity.
05:36:54 <quicksilver> modularity is solving separate problems separately so that the solutions can be used in other contexts.
05:36:57 <Peaker> well, then maybe I believe in abstraction and not modularity :)
05:37:32 <Peaker> Sure, stuff is also re-usable/seperate enough to be re-used separately
05:37:41 <Peaker> it's just not a separate "program"
05:39:49 <quicksilver> being a separate program is, indeed, not a requirement in itself
05:39:52 <quicksilver> that's just an implementation detail :)
05:40:52 <Peaker> well, the revision control is currently implemented as a transactional key/value store API on top of a key/value store API, with every transaction making a "version" and the ability to jump to different versions/etc.
05:41:17 <Peaker> and is completely separate from the editor, it was actually written before any of the GUI existed (I had a console editor of dumb trees it was implemented for)
05:41:38 <Peaker> but we're not entirely sure we have the right model for version control..   we *are* sure that heuristic-line-diffs as the basis for revision control is wrong
05:41:46 <t7> is it good practise to use Set anywhere order doesnt matter? or just me being a silly billy... ?
05:42:37 <Peaker> t7, Set doesn't only make order not matter, it also makes uniqueness matter, and requires Ord instance
05:42:50 <t7> yeah that too
05:42:51 <Peaker> t7, MultiSet would be the "right" way of saying "order doesn't matter"
05:43:41 <Peaker> t7, if you're actually comparing them, then Sets do make sense.. if you compare rarely and prepend often, maybe it would make sense to use lists and  Set.fromList when you compare
05:44:09 <Peaker> quicksilver, btw, what do you find ugly? UI feedback would be good :)  I think I'm going to gray out the non-active definitions slightly to make things clearer now
05:44:29 <quicksilver> Peaker: the things are not important, really.
05:44:48 <quicksilver> Peaker: excessively contrasting colour, horizontal lines a bit too close to surrounding text
05:45:00 <quicksilver> Peaker: font that doesn't work brilliantly at small sizes
05:45:10 <quicksilver> these details could be tuned later and are a matter of taste.
05:45:22 <quicksilver> however, a constructive suggestion:
05:45:40 <quicksilver> have you considered delimiting expressions by solid rectangles of (background) colour instead of horizontal lines?
05:45:59 <quicksilver> I've often thought that might look nicer. Either gently altering shades as nesting increase
05:46:13 <quicksilver> or a slightly shadow/outline around the whole rectangle
05:46:36 <Peaker> quicksilver, the underline is actually meant to mark what the inferred type beneath it is of
05:46:42 <Peaker> (rather than delimiting expressions)
05:47:20 <quicksilver> right
05:47:24 <Peaker> quicksilver, well, background colors are an "expensive resource" we'll probably want for various purposes, so using it for delimiting might be wasteful
05:47:35 <quicksilver> but it does mark the expression
05:47:49 <quicksilver> and expressions are perhaps better expressed by rectangles than lines
05:48:00 <quicksilver> I see what you mean, but the meanings can overlap.
05:48:04 <Peaker> though instead of a white underline, maybe it can be a slightly wider, more gentle-colored line
05:48:09 <quicksilver> for example you could use shades of gray for plain nesting
05:48:18 <quicksilver> and then shades of red for subexpressions in error
05:48:29 <Peaker> well, the lines are just "connecting" the upper (expr) with the lower (inferred type)
05:48:36 <quicksilver> shades of blue for sub expressions "related to" the current expression (like other uses of this identifier)
05:48:58 <Peaker> quicksilver, ah, interesting idea
05:53:14 <Peaker> oh man, gray tinting inactive definitions feels awesome :-)
05:53:24 <quicksilver> :)
05:54:19 <hpaste_> Peaker pasted “Gray tinting diff” at http://hpaste.org/69884
05:54:30 <Peaker> (that's all it took to add the tinting, that is)
05:54:35 <quicksilver> :)
05:55:26 <Peaker> quicksilver, so, can you run it? Are you on Windows?
05:57:39 <quicksilver> Peaker: I am not on windows.
05:57:41 <quicksilver> Peaker: http://lorgonblog.wordpress.com/2010/11/18/f-source-code-structural-colorizer-available/
05:57:52 <quicksilver> example of background colours for nestig
05:58:01 <quicksilver> although not the most attractive
05:58:42 <quicksilver> nicer one perhaps : http://www.aldec.com/images/content/features/HDL_Editor.png
05:59:54 <quicksilver> Peaker: apparently I can't compile GLFW-b
06:00:13 <Peaker> quicksilver, how does it fail?
06:00:24 <quicksilver> Warning: the following files would be used as linker inputs, but linking is not being done: glfw/lib/cocoa/cocoa_enable.m
06:01:10 <quicksilver> funnily enough b6 was asking for mac help 3 hours ago
06:01:20 <quicksilver> but I didn't know, 3 hours ago, that I wanted to install GLFW-b :)
06:01:23 <Peaker> quicksilver, OS X should be ok with GLFW-b, yairchu (my co-developer) is on OS X
06:01:25 <Peaker> hehe
06:01:29 <quicksilver> 10:38 < b6> hi, i'm maintainer of glfw-b. a user reported failure to install on  OS X. could somebody with OS X try to install it and see if they hit  an issue?
06:01:36 <Peaker> haha :)
06:07:32 <Peaker> quicksilver, btw, isn't that just a warning?
06:09:38 <quicksilver> Peaker: I think the actually error is the next line "ghc: no input files"
06:09:44 <quicksilver> but the one I pasted is the reason for it
06:10:32 <Peaker> quicksilver, sounds like some cmd line is being munged incorrectly? Filename specified in wrong place/way?
06:12:41 <quicksilver> yes
06:12:45 <quicksilver> I think so
06:12:54 <quicksilver> I don't rember how to compile obejctive-C files with ghc
06:13:05 <quicksilver> I think the only time I've done it, wxhaskell did it for me
06:13:36 <Peaker> I'm now working on adding a "free nav mode" where you'd use alt+dirkeys to move (relatively quickly) the current cursor in geometric space, and when you unpress alt, it will jump the cursor to the nearest element.  This is basically sort of "mouse emulation" so for some cases you wouldn't have to lift your hand from the keyboard, but still faster than navigating left,left,left,down,down, etc
06:13:48 <Peaker> I wonder if it'll work well in practice :)
06:27:37 <fmapE> Hi all. When trying to install cabal-dev, I get the warning contained in the following paste: http://hpaste.org/69885
06:28:26 <fmapE> Why is cabal trying to install an old mtl? There's no dependency on mtl from cabal-dev.
06:29:41 * hackagebot SableCC2Hs 0.0.1.0 - Generate a parser (in Haskell) with the SableCC parser generator.  http://hackage.haskell.org/package/SableCC2Hs-0.0.1.0 (MarcFontaine)
06:30:24 <dcoutts_> fmapE: -v --dry-run might help
06:32:08 <fmapE> dcoutts_ There are only 2 extra lines in that output: Reading available packages... \n Choosing modular solver.
06:34:27 <adamt> fmapE: That's the result of installing packages globally. Either force, or start over and use cabal-dev from the beginning :-)
06:34:53 <fmapE> adamt This is a fresh install of HP 2012.2
06:35:02 <fmapE> on a just-rebuilt computer
06:36:03 <dcoutts_> fmapE: oh sorry, I guess it needs v3
06:36:14 <adamt> fmapE: to answer your original question, maybe cabal-dev depends on something that depends on something that ... eventually depends on and older mtl
06:36:49 <fmapE> adamt: I traced the whole dependency tree back, using hackage. That's what confuses me. cabal-dev only depends on base and Cabal
06:36:57 <fmapE> Cabal in turn depends only on base and filepaths
06:37:03 <fmapE> and filepaths depends only on base
06:37:37 <adamt> Oh. Then i give up. :-)
06:38:27 <dcoutts_> fmapE: actually it depends on a lot more than that
06:38:33 <dcoutts_> see http://hackage.factisresearch.com/package/cabal-dev-0.9.1/cabal-dev.cabal
06:39:28 <dcoutts_> fmapE: mtl >= 1.1 && < 2.1
06:39:52 <dcoutts_> fmapE: hopefully -v3 would also point that out
06:40:28 <fmapE> (Oh, I thought you were referring to v3 of a package and was about to ask which. Didn't catch that it was a verbosity flag)
06:41:27 <fmapE> _dcoutts: So cabal-dev isn't yet compatible with HP 2012.2, which is annoying, because I wanted to use it to attempt an install of snap to see if that broke anything, because something deep in the dependencies of snap also needs an older mtl
06:41:29 <dcoutts_> fmapE: "selecting cabal-dev-0.9.1 (source) and discarding ... mtl-1.0, 2.1 ..."
06:42:19 <sopvop> fmapE: if you are on *nix, you can use virthualenv instead (I prefer it)
06:42:34 <dcoutts_> fmapE: the other way to find out is to say --constraint='mtl >= 2.1' and then see why it complains
06:42:43 <mightybyte> fmapE: I've found that cabal-meta works much better for me than cabal-dev.
06:42:58 <dcoutts_> and it does complain: cabal: cannot configure cabal-dev-0.9.1. It requires mtl >=1.1 && <2.1
06:43:37 <dcoutts_> fmapE: that's the general strategy of asking it to do what you expected, and let it explain why your expectation was wrong.
06:43:56 <mightybyte> fmapE: We're getting ready to release a new version of Snap.  It should work if you use the latest code from github.
06:45:58 <fmapE> OK I'll try that. Apparently the offending package wanting the old mtl in that version is heist.
06:46:37 <mightybyte> fmapE: Yep, we've had several people report that.  It's fixed in HEAD.
06:46:51 <fmapE> Alright thanks everybody :)
06:56:18 <parcs`> > Data.Set.split 3 (Data.Set.fromList [1,2,3,4,5])
06:56:19 <lambdabot>   Not in scope: `Data.Set.split'Not in scope: `Data.Set.fromList'
06:57:14 <fmap> > S.split 3 (S.fromList [1,2,3,4,5])
06:57:15 <lambdabot>   (fromList [1,2],fromList [4,5])
07:13:06 <lunaris> Noob question: in the type a -> b -> c -> d, what are the co/contravariant argument positions (if that's even a valid question to ask)?
07:14:15 <sordina3> Hey haskellers. I'm having a look at a bug I ocasionally come across when using Codec-Image-DevIL. If I don't have support for a particular formar compiled in to devil, then the output isn't generated and doesn't trigger any warnings. I'm having a look at modifying the source, checking for IL_NO_PNG and others with hsc, but that doesn't seem to be working. Does anyone have any experience with this?
07:14:34 <sordina3> *format
07:15:33 <mekeor> lunaris: what does "co/contravariant argument position" mean?
07:15:44 <lunaris> mekeor: I'm trying to figure that out myself.
07:16:22 <lunaris> I'm sure I've heard reference to co/contravariance as a property of an argument's position in a function type, but it may be complete garbage.
07:16:47 <lunaris> The closest the internet gets me is w.r.t subtyping/generics, which is not what I care about/
07:17:02 <lunaris> Like I said, it might be complete garbage.
07:17:02 <mekeor> lunaris: i'm not sure if i suppose correctly what that means, but in haskell, you can't *just* give a function (f :: a -> b -> c) first a value of type b. you can use flip for such things…
07:17:16 <Peaker> in a type like:   data Foo a b c = .........              "a" and "b" and "c" are covariant if they appear only in positions that are on the left of (->) an even amount of times,   contravariant if they appear only in positions that are an odd number,  and invariant if they appear in both
07:17:19 <DrSyzygy> weeeell, in Hom(A,B); if you vary A by a morphism, Hom(-,B) will vary contravariantly; and varying B by a morphism makes Hom(A,-) vary covariantly.
07:17:34 <mekeor> lunaris: did i totally misunderstand the question? sorry if so :D
07:17:41 <lunaris> Peaker: I think that's the answer I'm looking for.
07:17:43 <DrSyzygy> this kinda sounds like it is by extension of this property.
07:18:06 <Peaker> basically,  if a type is "covariant" in its last type parameter, then it can be made an instance of Functor
07:18:10 <Peaker> "if" -> "iff"
07:18:20 <lunaris> Essentially, I wish to state that a Rank-N (n > 1) type occurs when one uses explicit quantification in a contravariant position, but didn't know if that was complete crap or simply non-sensical.
07:18:20 <Peaker> any valid Functor instance is covariant on its last type parameter
07:18:32 <Peaker> any valid ContraFunctor instance is contravariant on its last type parameter
07:19:01 <mekeor> lunaris: how is this a noob question? :D
07:19:14 <Peaker> I think even if you have the quantification in covariant positions it can be Rank-N but I don't understand Rank-N myself
07:19:44 <lunaris> Peaker: I was trying to succinctly account for the fact that in (forall a. a -> (forall b. b -> a)), you can float the "forall b" out.
07:19:49 <Peaker> for example:   ((forall b. b -> b) -> r) -> r         the "forall" is in a covariant position...
07:19:55 <lunaris> But in ((forall b. b -> b) -> a -> a) you can't.
07:20:06 <lunaris> Indeed.
07:20:14 <lunaris> Like I said, it seems to be pure garbage.
07:20:15 <lunaris> Oh well.
07:20:16 <lunaris> :)
07:20:24 <lunaris> mekeor: Sorry, I feel like I should know the difference by now.
07:20:27 <Peaker> I don't know if you can float that "forall" out, I am pretty sure you can't (at least not in the general case)
07:21:15 <lunaris> Peaker: you certainly can -- it's the type of const.
07:21:39 <lunaris> Peaker: But not in f :: (forall b. b -> b) -> a -> a, where the quantification appears to the left of an arrow.
07:21:42 <lunaris> I think that's the rub.
07:21:56 <Eduard_Munteanu> You can move the foralls leftwise/outwards, as long as variables don't conflict.
07:22:09 <Peaker> lunaris, it's not const, its Cont
07:22:13 <Peaker> @src Cont
07:22:13 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
07:22:47 <Peaker> {(forall b. b -> b) -> r} -> r      used {} to emphasize the parens that make it not-const
07:22:52 <lunaris> Peaker: Sorry, I thought you meant my example.
07:22:56 <Peaker> oh
07:23:02 <lunaris> viz. (forall a. a -> (forall b. b -> a))
07:23:42 <lunaris> Peaker: surely the only function you can pass that forall b. b -> b is id?
07:23:42 <Eduard_Munteanu> Yeah, in that one you can move the forall out.
07:23:44 <lunaris> Seems a bit off.
07:23:47 <lunaris> Indeed.
07:23:57 <lunaris> Should it not be forall b. ((b -> b) -> r) -> r
07:24:07 <lunaris> Thus Rank-1.
07:24:18 <Peaker> lunaris, I made a special case of Cont:  i.e:   Cont (polymorphic type here) a
07:24:26 <Peaker> yeah, the example I gave is not interesting, just id func
07:24:34 <lunaris> Ok.
07:24:45 * hackagebot repa-devil 0.3.1 - Support for image reading and writing of Repa arrays using in-place FFI calls  http://hackage.haskell.org/package/repa-devil-0.3.1 (RaphaelJavaux)
07:25:10 <lunaris> So TL;DR: my statement about quantification in contravariant positions being the cause of Rank-N types is false?
07:25:15 <lunaris> (I wouldn't be surprised :))
07:27:37 <Peaker> lunaris, I am not an expert, so maybe I'm wrong, but I think it's false
07:27:45 <lunaris> Peaker: I'm inclined to agree.
07:27:51 <lunaris> Thanks very much for your help nonetheless.
07:27:56 <Eduard_Munteanu> Peaker: that's Lan r a no, or something like that?
07:28:11 <Eduard_Munteanu> (the special case of Cont)
07:29:18 <Peaker> Eduard_Munteanu, Haven't heard of Lan
07:29:26 * Eduard_Munteanu looks
07:29:30 <lunaris>  Do you mean Kan?
07:30:36 <Eduard_Munteanu> lunaris: the left Kan extension
07:30:43 <lunaris> Yep.
07:30:50 <Eduard_Munteanu> Ah... http://comonad.com/reader/2008/kan-extensions/   but it's not quite that/
07:30:50 <lunaris> Sorry, this is way above my head now.
07:30:58 * lunaris sits back down.
07:31:01 <Eduard_Munteanu> And it was Ran, anyways.
07:38:44 <lunaris> Success! I believe I've found the definition in "Practical type inference for arbitrary-rank types" (SPJ et. al) which was lying on my desk.
07:38:49 <lunaris> Hence noob question.
07:39:08 <lunaris> "The rank of a type describes the depth at which universal quantifiers appear contravariantly."
07:44:47 * hackagebot yesod-auth-fb 1.0.4 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.0.4 (FelipeLessa)
07:44:59 <Peaker> how is "depth" measured?
07:45:19 <Eduard_Munteanu> How many times it sits left to an arrow.
07:45:30 <Peaker> so then there's only Rank1, Rank3, Rank5?
07:45:40 <Peaker> because Rank2,Rank4 would be covariant..
07:45:40 <Eduard_Munteanu> No.
07:46:35 <hpaste_> beefcube pasted “State monad example” at http://hpaste.org/69886
07:46:37 <Eduard_Munteanu> Rank1 is normal types.
07:46:50 <Eduard_Munteanu> Rank2 is stuff like runST's type.
07:47:00 <Eduard_Munteanu> :t runST
07:47:01 <lambdabot> forall a. (forall s. ST s a) -> a
07:48:02 <Eduard_Munteanu> Higher ranks nest foralls further.
07:48:31 <beefcube> WRT my paste, I don't understand how playGame is being combined, to produce a score, from my understand of do expressions, this looks like >> but it isn't
07:48:48 * Eduard_Munteanu isn't sure how to clarify that definition further
07:48:49 <beefcube> (the example is from the wiki)
07:49:30 <Cale> I'm not sure how many others here are interested in this, but there's a nice video now of how to get that powerup incrementation in Super Mario World that I was talking about before (the video also shows off some other nice glitches like ? block duping and P duping) http://www.youtube.com/watch?v=zQFseooBPl0
07:49:31 <Eduard_Munteanu> Obviously Rank1 types are Rank k, k > 1 too
07:49:47 * hackagebot pcap-enumerator 0.3 - Convert a pcap into an enumerator.  http://hackage.haskell.org/package/pcap-enumerator-0.3 (KatsutoshiItoh)
07:50:21 <Peaker> Eduard_Munteanu, but you said the rank is the depth of left-of-(->) and if that number is even it's supposed to be covariant
07:50:33 <Eduard_Munteanu> Yeah, that's rather confusing.
07:50:35 <Peaker> but only contravariant foralls are higher-ranked?
07:50:57 <Cale> beefcube: evalState x s where x is a computation in the State monad, and s is an initial state, will produce the result of running that state computation with that initial state
07:51:00 <Peaker> I am guessing covariant forall's that are not "strictly positive" are also higher-ranked
07:51:11 <Cale> evalState :: State s t -> s -> t
07:51:22 <lunaris> Peaker: I think I can explain it.
07:51:25 <Cale> (It discards the final state of the computation)
07:51:34 <lunaris> Consider: FA a. (FA b. b -> b) -> a
07:52:00 <lunaris> Here, the maximum depth of an FA in a contravariant position is 2 (assuming the top depth is 1).
07:52:05 <lunaris> So it's rank-2.
07:52:35 <lunaris> If we have: FA a. (FA b. b -> (FA c. c -> c) -> b) -> a -> a
07:52:57 <lunaris> Nah, I can't explain it.
07:53:01 <lunaris> That's rank-3, but so is:
07:53:21 <lunaris> FA a. (FA b. (FA c. c -> c) -> b -> b) -> a -> a
07:53:27 <lunaris> And the FA c. c -> c  is in a covariant position there./
07:53:30 * lunaris gives up.
07:53:44 <lunaris> I'll just write "You know what a rank-N type is."
07:54:08 <lunaris> Anyway, I apologise but I'll be back later.
07:54:10 * lunaris is away
07:55:29 <roconnor> On page 6 of http://www.reddit.com/r/haskell/comments/uqc33/beautiful_code_compelling_evidence_opengl_cairo/  why is it suggested to transpose the data in the file?
07:55:36 <roconnor> I don't get why it is better transposed.
07:56:35 <youseeli> haskell platform url:http://hackage.haskell.org/platform/ can not connection??i am in china mainland
07:56:38 <Cale> roconnor: I think it's clearer when you show the implied []'s and
07:56:41 <Cale> commas
07:56:57 <Cale> errr
07:57:03 <Cale> actually, nevermind
07:57:14 <Cale> oh, yeah
07:57:17 <youseeli> somebody help me??how to download haskell platform
07:57:20 <S11001001> youseeli: works for me
07:57:49 <Tinned_Tuna> youseeli: which platform is it for?
07:57:55 <mekeor> @where hp -- youseeli
07:57:55 <lambdabot> http://hackage.haskell.org/platform/
07:58:14 <Tinned_Tuna> mekeor: I think he's being duped by the great firewall of china
07:58:19 <youseeli> can not connection...
07:58:20 <mekeor> oh
07:58:33 <Tinned_Tuna> youseeli: which platform, Mac, Windows or Linux?
07:58:34 <Cale> roconnor: I guess they're just saying that since you want to process all the records in turn, you want to be able to read each column lazily? I dunno
07:58:41 <youseeli> windows
07:58:55 <nand`> the first step is to move to a country that allows you to download the haskell platform
07:59:06 <Tinned_Tuna> youseeli: give me 5 mins and I'll get you a link
07:59:12 <mekeor> youseeli: can you connect to http://lambda.haskell.org/platform/download/2012.2.0.0/HaskellPlatform-2012.2.0.0-setup.exe ?
07:59:30 <youseeli> thanks very much...tinned..
07:59:37 <mekeor> yay :D
08:00:00 <mekeor> Tinned_Tuna is awesome.
08:00:04 <youseeli> wow...it is work...
08:00:14 <youseeli> thanks you all..~
08:00:35 <mekeor> youseeli: the link worked??
08:00:42 <S11001001> haskell platform blocked for including too many modules
08:00:49 <youseeli> yes..it is worked..
08:00:55 <youseeli> download ing
08:01:01 <mekeor> Tinned_Tuna: did you hear that?
08:02:20 <Tinned_Tuna> youseeli: can you see hilbert.dannyturner.net ? It should be file not found (404)
08:02:42 <Tinned_Tuna> if so, then you can get hilbert.dannyturner.net/HaskellPlatform-2012.2.0.0-setup.exe
08:02:47 <Tinned_Tuna> oh
08:02:48 <Tinned_Tuna> lol
08:02:54 <Cale> lol, 403'd
08:02:59 <Tinned_Tuna> haha
08:03:01 <Tinned_Tuna> ah well
08:03:09 <Tinned_Tuna> out done by pre-existing infrastructure
08:03:18 <Cale> also, he already got it, yeah
08:03:33 <youseeli> tinned tuna..let me try..
08:03:36 <Tinned_Tuna> see, the internet just treats censorship as damage and routes around it (to paraphrase an existing saying :-p)
08:03:40 <Cale> Note to self: remove mentions of Tianenmen square from the Haskell Platform download page
08:03:45 <Tinned_Tuna> haha
08:04:12 <roconnor> Cale: ya, but the untransposed version lets you process each record in turn.
08:04:31 <Cale> roconnor: Yeah, it's kinda weird
08:04:47 <youseeli> Tinned_Tuna: the link nginx 403 message
08:05:20 <mekeor> Tinned_Tuna's link does work for me.
08:05:46 <nand`> I actually get a 404, breaking the trend
08:06:11 <Tinned_Tuna> lol
08:06:24 <nand`> works now
08:06:39 <Tinned_Tuna> I'm not a good guy to have around web sites. That's why I work for a company which makes a web site.
08:07:22 <nand`> (may I just comment on how odd it is to leave out the http:// in front of the link? I had to copy/paste it manually into my browser instead of using my semi-automatic “URL-opening” scripts)
08:07:24 <youseeli> i am not good at english...the link forward to http://176.58.90.210/ get 403 also now
08:07:57 <Tinned_Tuna> youseeli: that is the IP of my server, you should be looking at http://176.58.90.210/HaskellPlatform-2012.2.0.0-setup.exe
08:08:34 <Tinned_Tuna> btw, someone should post checksum of the exe for so that youseeli can verify -- I can't spot it immediately on the site.
08:09:20 <Tinned_Tuna> And me posting it would be a bad idea, as I could've done something nasty to my version prior to putting it on my website.
08:09:23 <youseeli> oh...the url worked..i can get it...
08:09:27 <Tinned_Tuna> youseeli: :-)
08:09:31 <youseeli> thanks..
08:09:43 <Tinned_Tuna> youseeli: no problems, best of luck.
08:09:49 <nand`> (didn't youseeli already get it from mekeor's link already)
08:10:07 <youseeli> you all are very kind
08:10:08 <Tinned_Tuna> I thought so, but I don't know
08:10:19 <tac-tics> youseeli: #haskell is the best
08:11:32 <youseeli> nand`: i got the soft from mekeor's link..and tinned_tuna's link is work too...so...i thank for you all...
08:11:47 <youseeli> i am not good at english..
08:11:59 <youseeli> so i say so slow..
08:12:15 <nand`> Tinned_Tuna: that gives me an idea; the hp download links *really* need a checksum and cryptographic signature to be available immediately alongside it
08:12:23 <Tinned_Tuna> nand`: aye
08:12:38 <nand`> I wouldn't trust china to not modify my compilers
08:12:52 <Tinned_Tuna> nand`: I am a little security obsessive. some might call me a tin-foil-hat-wearing-schneier-fan-boy, I call it being careful.
08:13:01 <nand`> Tinned_Tuna: don't worry, so am I
08:13:27 * nand` is downloading the hp from haskell.org to provide an md5sum for youseeli right now, incidentally)
08:13:38 <rwbarton> nand`: Why do you think all those GHC-produced executables are so large!
08:13:42 <Tinned_Tuna> nand`: my next project -- fully understand the mathematical background of public key-based digital signatures.
08:13:50 <Tinned_Tuna> well, bed-time reading...
08:14:13 <nand`> Tinned_Tuna: yeah, I've worked my way into RSA a bit but I haven't fully grokked the mathematical nature behind it, I know it has to do with very large prime factors and modulo calculations something or other
08:14:19 <Tinned_Tuna> I should really apply to be in the security serivces one day, but I don't think they'd like me on my anti-authoritarian principles.
08:14:40 <nand`> Tinned_Tuna: do you know about homomorphic encryption algorithms?
08:14:41 <Tinned_Tuna> nand`: I used to be able to do RSA encryption by hand, for sufficiently small primes.
08:14:59 <Tinned_Tuna> nand`: not yet, but it's on my list of things to studty
08:15:02 <youseeli> can not download hp from haskell.org also
08:15:10 <tac-tics> Tinned_Tuna: that's a neat trick.
08:15:17 <nand`> bdaf067516ded2d7daeb7d548a7276fc  HaskellPlatform-2012.2.0.0-setup.exe -- youseeli
08:15:23 <nand`> I hope this is correct
08:15:28 <nand`> the transfer might be corrupted on my end
08:15:34 <Tinned_Tuna> youseeli: check your md5sum matches
08:15:39 <nand`> (my country does not have a very good internet infrastructure)
08:16:03 <youseeli> oh..yes i see..check it now...
08:16:19 <youseeli> thank you again..
08:16:41 <Tinned_Tuna> I assert that mine matches on my server :-p
08:17:02 <Tinned_Tuna> tac-tics: we had to do it in our num thy exam about a year ago
08:17:17 <nand`> okay, then with a probability of something-or-other, Tinned_Tuna hasn't modified his copy. Either that or he's lying to us, or by a freak accident my copy corrupted itself to his
08:17:31 <Tinned_Tuna> nand`: I MITM'd your download ;-)
08:17:42 <tac-tics> Tinned_Tuna: I was really bummed. I took Hard Ass Number Theory in college. I did all right in the class, but I skipped *the one day* we went over encryption. It was sort of an extra topic that was never tested on, and never reviewed :<
08:18:14 <nand`> tac-tics: plentiful enough information is available on the internet that I wouldn't consider that to be too much of a loss, frankly
08:18:24 <Tinned_Tuna> tac-tics: Do you hang around in #haskell often? If so, I can stop off in the library on the way home and recommend you the book I studied ?
08:18:42 <tac-tics> Tinned_Tuna: I'm here or in #haskell-blah pretty much every work day
08:18:45 <Tinned_Tuna> infact, I can log into my library account
08:19:01 <youseeli> Tinned_Tuna: would you tell me how to check the md5sum code in windows ? i never try it before.
08:19:35 <nand`> I believe a port of “md5sum” is included in GnuWin32 or some other project
08:19:48 <nand`> apart from that, a number of utilities are available
08:19:55 <nand`> a quick duck for “md5sum windows” brings up interesting hits
08:19:55 <Tinned_Tuna> tac-tics: it was either A course in number theory / H. E. Rose or Elementary number theory / David M. Burton.
08:20:12 <Tinned_Tuna> youseeli: see nand` 's comments :-)
08:21:05 <Tinned_Tuna> tac-tics: there's also a description of the algo in Schneier's big red book, but no rigorous treatment of the algo to prove it secure (given assumptions...)
08:21:50 <Tinned_Tuna> tac-tics: Yea, Scheier's book has it on page 466
08:21:52 <nand`> youseeli: http://support.microsoft.com/kb/841290 <- relevant
08:22:10 <Tinned_Tuna> *Schneier
08:22:25 <youseeli> yes...i got it ..i try to get the soft's md5sum
08:22:38 <Tinned_Tuna> afk
08:24:20 <nand`> If this is still about RSA, there's a description of the algorithm available on https://en.wikipedia.org/wiki/RSA_(algorithm)#Operation
08:24:40 <nand`> sufficient for understanding how it works; it doesn't analyze its security directly however some of the references may prove useful
08:25:31 <youseeli> HaskellPlatform-2012.2.0.0-setup.exe           bdaf067516ded2d7daeb7d548a7276fc
08:25:45 <nand`> youseeli: looks good
08:25:51 <tac-tics> I'm always really curious how they prove things in cryptogrpahy
08:26:00 <youseeli> :)
08:26:13 <youseeli> nand`: thanks...
08:26:14 <tac-tics> (or for that matter, in complexity theory)
08:26:36 <nand`> https://en.wikipedia.org/wiki/RSA_(algorithm)#Proofs_of_correctness <- somewhat related
08:28:30 <tac-tics> it feels like a lot of cryptography would be more "sciency" than I'm typically comfortable with :)
08:29:05 <shergill> tac-tics: it's math =/
08:29:06 <nand`> as opposed to “artsy”? :P
08:29:34 <tac-tics> shergill: It's math based on unproven conjectures.
08:30:10 <shergill> tac-tics: sure
08:30:45 <tac-tics> And asymptotic behaviors map well, but not perfectly, to actual security properties in the real world
08:35:31 <Tinned_Tuna> tac-tics: well, they're unproven, but holding up well-enough so far...
08:35:38 <Tinned_Tuna> (also, I'm not entirely AFK anymore)
08:36:06 <tac-tics> So far....
08:36:07 <tac-tics> :)
08:37:19 <tac-tics> Lousy wikipedia. Their RSA algorithm is partial!
08:37:54 <tac-tics> I chose primes 2 and 3, and I'm being asked to choose a number e such that 1 < e < phi(6) = 2
08:38:07 <Tinned_Tuna> tac-tics: lol
08:38:08 <tac-tics> and INTEGER number
08:38:10 <tac-tics> :<
08:38:19 <Tinned_Tuna> choose bigger primes
08:38:45 <Tinned_Tuna> also, wikipedia has an edit button ;-)
08:40:16 <Tinned_Tuna> I'd love to develop a little bit of code that when running on as an unpriviledged user discovers RSA keys be performing a timing analysis...
08:40:30 <Tinned_Tuna> that'd be cute, but I has no time.
08:49:10 <shergill> does haskelldb allow you to get the 'compiled' sql queries (which you can then execute with your own backend)?
08:51:49 <tac-tics> Tinned_Tuna: Yeah, this looks like what I remember from the last 15 minutes of class I did manage to catch.
08:51:55 <tac-tics> It's just so simple :)
08:52:22 <tac-tics> and somehow, encryption does *exactly* what we would want it to
08:52:34 <shergill> hmm looks like it can
09:00:55 <akosch__> how would I write a function which composes two sorting functions into one, if the first one results in EQ then the second is used instead? sortCompose :: (a -> a -> Ordering) -> (a -> a -> Ordering) -> (a -> a -> Ordering)
09:01:33 <akosch__> naturally a is an instance of Ord
09:01:47 <tac-tics> akosch__: Sounds like a lexical ordering.
09:02:19 <tac-tics> akosch__: First match on the first ordering. If it's LT or GT, return that. If it's EQ, then return the second ordering results
09:03:56 <akosch__> tac-tics: can I maybe use guards for this?
09:04:18 <nand`> sortCompose a b x y = case a x y of EQ -> b x y; o -> o
09:04:21 <tac-tics> akosch__: Yeah. Guards or a case statement.
09:04:29 <tac-tics> akosch__: What nand` said ^
09:05:27 <akosch__> thanks, I was thinking the same. Maybe it's also doable without explicitely mentioning x and y?
09:05:36 <nand`> akosch__: ‘a’ shouldn't even need to be an instance of ord, you're providing the comparing functions
09:05:56 <nand`> @pl \a b x y -> case a x y of EQ -> b x y; o -> o
09:05:56 <lambdabot> (line 1, column 30):
09:05:56 <lambdabot> unexpected ">" or "-"
09:05:56 <lambdabot> expecting variable, "(", operator or end of input
09:06:20 <nand`> hmm
09:08:15 <rwbarton> akosch__: mappend
09:08:26 <rwbarton> :t mappend ::  (a -> a -> Ordering) -> (a -> a -> Ordering) -> (a -> a -> Ordering)
09:08:27 <lambdabot> forall a. (a -> a -> Ordering) -> (a -> a -> Ordering) -> a -> a -> Ordering
09:08:51 <tac-tics> :t mappend
09:08:52 <lambdabot> forall a. (Monoid a) => a -> a -> a
09:09:09 <illissius> haskell is crazy
09:09:17 <tac-tics> illissius: It's just misunderstood
09:09:25 <c_wraith> crazy like a fox!
09:09:48 <otters> a fox murdered all 12 of my chickens four nights ago
09:10:27 <tac-tics> otters: and after waiting all that time for them to hatch before you counted them....
09:10:29 <nand`> rwbarton: excellent, I did not know about that instance
09:10:30 <tac-tics> a tragedy
09:10:49 <otters> don't count your chickens before they die a PEACEFUL death of OLD AGE
09:11:01 <illissius> there is a joke about otters somewhere in the vicinity, can anyone find it?
09:13:31 <hilhil> Is Either a still an instance of MonadError? I remember that it's been tweaked across library versions, but not exactly what happened...
09:14:48 <hilhil> @src Either a MonadError
09:14:48 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:14:52 <hilhil> @src Either MonadError
09:14:52 <lambdabot> Source not found. You speak an infinite deal of nothing
09:15:00 <hilhil> @src Either a throwError
09:15:00 <lambdabot> Source not found. You speak an infinite deal of nothing
09:18:08 <HairyDude> @hoogle String -> Maybe Int
09:18:08 <lambdabot> Test.HUnit.Base Label :: String -> Node
09:18:08 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
09:18:08 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
09:18:36 <HairyDude> maybeRead should be more general than Network.CGI :|
09:31:42 <applicative> > let toSq [] = 0; toSq (x:_) = x*x in map (toSq . map fst. reads) ["12","4","HairyDude","7"]
09:31:44 <lambdabot>   [144,16,0,49]
09:33:34 <nand`> :t listToMaybe . map fst . reads
09:33:35 <lambdabot> forall a. (Read a) => String -> Maybe a
09:34:15 <theadmin> What's "Maybe"? lol, I'm new to Haskell but I see this type (?) everywhere
09:34:21 <applicative> listToMaybe isn't the Prelude though is it
09:34:23 <otters> :src Maybe
09:34:27 <otters> no
09:34:29 <otters> @src Maybe
09:34:30 <lambdabot> data Maybe a = Nothing | Just a
09:34:35 <nand`> @hoogle listToMaybe
09:34:35 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
09:34:51 <otters> it's haskell's replacement for nullable values
09:35:19 <applicative> theadmin: if you have a type like  Int then Maybe Int is the Ints with an additional "Nothing" element, crudely
09:35:50 <theadmin> applicative: I sort of see, thanks
09:35:53 <applicative> "Just  3"  is the representation of 3 in Maybe Int
09:36:33 <applicative> theadmin: so a partial function will often be given a type like String -> Maybe Int rather than String -> Int
09:36:51 <theadmin> applicative: Makes sense, thank you :)
09:40:00 <theadmin> Also, "Int" and "Integer" are different types aren't they? Just making sure
09:40:09 <illissius> theadmin: yes
09:40:50 <tac-tics> theadmin: Int is finite in size
09:40:53 <illissius> theadmin: Int is like C int (sans undefined behaviour), Integer is like BigNum
09:41:09 <tac-tics> Typically just short of the register size.
09:41:43 <theadmin> Thanks.
09:45:17 <theadmin> Speaking of, how often do the official builds of Haskell Platform get updated?
09:45:40 <Igloo> Once per release, generally
09:45:57 <theadmin> Igloo: So, now that GHC 7.4.2 is out it should get updated then?
09:46:11 <Igloo> No, once per Haskell Platform release
09:46:24 <Igloo> GHC 7.4.2 isn't in the Haskell Platform
09:47:17 <theadmin> Oh, uh... Okay, so you're saying "Haskell Platfrom gets updated whenever Haskell Platform gets updated"?
09:47:34 <theadmin> s/Platfrom/Platform/
09:47:51 <otters> yeah
09:48:00 <MagneticDuck> as correct as can be
09:48:06 <applicative> Igloo: it was a little confusing.
09:48:07 <Igloo> Oh, I thought you were specifically talking about builds, rather than the platform itself
09:48:25 <Igloo> It's meant to release every 6 months: http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable
09:48:46 <applicative> theadmin: there is a new version of the Haskell Platform for ghc 7.4,  I gather that's clear
09:50:10 <theadmin> applicative: Yeah, the current Haskell Platform includes GHC 7.4.1 right?
09:50:30 <Igloo> right
09:50:37 <applicative> yeah, the last one had ghc-7.0
09:50:46 <Igloo> Oh, apparently that's 6 months for major releases. Minor releases may be more frequent
09:51:05 * Igloo isn't sure if a GHC update could happen in a minor release, though
09:52:57 <applicative> if by ghc update you mean in the third position 7.0.x , I think it has happened
09:53:32 <Axman6> what was fixed in .2 again?
09:53:38 <Baughn> > fixIO forkIO
09:53:40 <lambdabot>   Not in scope: `fixIO'Not in scope: `forkIO'
09:54:02 <Axman6> @hoogle fixIO
09:54:02 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
09:54:03 <Clint> http://hackage.haskell.org/trac/ghc/ticket/5991
09:55:35 <abhinavmehta> can you suggest some good function name, which merges data of same-nature, but it could accept single as well multiple. For example: accepts fun(dict, list) or fun(list, dict) or fun(dict, dict) or fun(list, list)
09:55:41 <tac-tics> @src fixIO
09:55:41 <lambdabot> Source not found. Sorry.
09:55:49 <tac-tics> @src System.IO.fixIO
09:55:49 <lambdabot> Source not found. There are some things that I just don't know.
09:56:19 <Axman6> abhinavmehta: you'll have to use haskell types, that question is very hard to understand (for me anyway)
09:56:27 <applicative> abhinavmehta: where dict and list are different types?
09:56:36 <abhinavmehta> yes.
09:56:44 <Axman6> abhinavmehta: what is the return type?
09:56:57 <theadmin> Oh, just remembered, does Haskell have dictionaries/hashes/associative arrays/somesuch?
09:57:02 <abhinavmehta> Axman6: my mistake…would return list, if anyone of them is list..else dict.
09:57:10 <Baughn> theadmin: Lots and lots and lots such
09:57:14 <MagneticDuck> hey just a question... would it be possible to make Writer an instance of Monad if you declared it as "Writer a w = Writer { runWriter :: (a, w) }"? (Writer still being a container for 'a')? How would you do that? ...a lambda function... for types?
09:57:17 <Baughn> theadmin: What particular kind do you want?
09:57:36 <S11001001> MagneticDuck: newtype
09:57:36 <theadmin> Baughn: Eh I dunno, basically an array with strings for indices instead of integer values?
09:57:39 <Axman6> theadmin: not built into the language
09:57:46 <Baughn> theadmin: Data.Map will do it
09:57:49 <MagneticDuck> S11001001: I was afraid of that...
09:57:54 <theadmin> Baughn: ty
09:58:00 <Axman6> there's also maps specialised for string keys
09:58:00 <applicative> abhinavmehta: the obvious thing is to write fun to take Either list dict as an argument
09:58:03 <MagneticDuck> it would be cool if there was a kind of lambda function that worked in the world of types...
09:58:03 <Axman6> and byte string keys
09:58:10 <MagneticDuck> but it would probably usually be useless
09:58:11 <Baughn> theadmin: And while Axman6 is technically correct, practically *nothing* is built into the language. Not even for loops; those are functions too. :P
09:58:13 <abhinavmehta> Axman6: yeap
09:58:31 <S11001001> MagneticDuck: well, they kind of work, scala has them.  More trouble than they're worth, though
09:58:41 <Baughn> theadmin: Anyway, Data.Map / Data.Seq should do 90% of what you want. Then there are all kinds of specialized structures.
09:59:13 <theadmin> Baughn: Isn't basically *everything* a function here? :P
09:59:34 <Baughn> theadmin: Not if.
09:59:41 <Baughn> theadmin: ..strangely enough; it certainly could be.
09:59:53 <applicative> MagneticDuck: isnt there a monad for (a,_) already
10:00:21 <MagneticDuck> S11001001: Interesting. I can't really think of any good things to do with them... but at least it would let me sleep well to know that the world of types has all the power that the world of values has. ;P
10:00:21 <Axman6> I don;t think so...
10:00:26 <MagneticDuck> applicative: That's writer..
10:00:35 <MagneticDuck> I know
10:00:43 <MagneticDuck> I was just wondering
10:00:45 <rwbarton> > return 1 :: (String, Int)
10:00:46 <S11001001> (,) a's monad isn't constrained on a
10:00:46 <lambdabot>   No instance for (GHC.Base.Monad ((,) GHC.Base.String))
10:00:46 <lambdabot>    arising from a us...
10:02:02 <S11001001> MagneticDuck: you could make the type unifier work less well with them
10:02:40 <applicative> I see you're right, for some reason I thought w was first in the pair buried in WriterT
10:04:22 <MagneticDuck> it seems everyone mixes up everything about WriterT. :P
10:04:26 <MagneticDuck> @src WriterT
10:04:26 <lambdabot> Source not found.
10:04:30 <MagneticDuck> um..
10:04:34 <rwbarton> Well it should be. (To the extent that it is possible to care about the order)
10:04:35 <Baughn> WriterT is pretty simple.. and useful
10:04:41 <MagneticDuck> yeah
10:05:01 * hackagebot factual-api 0.3.1 - A driver for the Factual API  http://hackage.haskell.org/package/factual-api-0.3.1 (RudigerLippert)
10:05:07 <dolgosm> test
10:05:54 * MagneticDuck is away: Goinek for walk on skateboard
10:13:06 <MagneticDuck> > runWriter $ (Writer (1, []) :: Writer [Int] Int)
10:13:07 <lambdabot>   Not in scope: data constructor `Writer'
10:13:25 <MagneticDuck> ...um..
10:13:26 <Baughn> :t execWriterT
10:13:27 <lambdabot> forall w (m :: * -> *) a. (Monad m) => WriterT w m a -> m w
10:13:37 <Baughn> :t execWriter
10:13:38 <lambdabot> forall w a. Writer w a -> w
10:13:58 <Baughn> > execWriter $ do { tell [1]; tell [2] }
10:13:59 <lambdabot>   [1,2]
10:14:26 <MagneticDuck> how do I construct a writer value from a tuple.?
10:14:31 <MagneticDuck> xD
10:14:36 <Baughn> MagneticDuck: You don't
10:14:41 <Baughn> What are you trying to do, exactly?
10:14:51 <MagneticDuck> figure out what's going on with tel
10:14:53 <Baughn> The simplest way of constructing a Writer value is with return
10:14:53 <MagneticDuck> *tell
10:15:09 <Baughn> ..not an /interesting/ Writer value, perhaps.
10:15:10 <MagneticDuck> > runWriter $ return 5
10:15:11 <lambdabot>   (5,())
10:15:26 <MagneticDuck> okay, what's so special about ()?
10:15:32 <Baughn> > runWriter $ tell [2] >> return 5
10:15:34 <lambdabot>   (5,[2])
10:15:48 <MagneticDuck> where is it defined as that weird value that can be any type?
10:15:50 <rwbarton> () was what it picked as the default type that's an instance of Monoid
10:15:50 <Baughn> MagneticDuck: Nothing. The interpreter just defaults to () when you don't /use/ Writer in any way.
10:16:04 <MagneticDuck> it's also there when you use tell of course
10:16:05 <rwbarton> () isn't a weird value that can be any type
10:16:12 <MagneticDuck> > runWriter $ tell [5]
10:16:13 <lambdabot>   ((),[5])
10:16:16 <Baughn> > runWriter $ tell ()
10:16:17 <lambdabot>   ((),())
10:16:25 <Phlogistique> hi
10:16:30 <MagneticDuck> hi
10:16:36 <Phlogistique> how did Haskell handle IO before monads?
10:16:42 <ion> Horribly
10:16:49 <Baughn> Phlogistique: Basically, the way Prelude.interact does it
10:16:49 <Phlogistique> any link?
10:16:50 * MagneticDuck is away: Goinek for walk on skateboard
10:16:54 <ion> main :: String -> String or something like that.
10:17:02 <Baughn> Phlogistique: I.e. lazy i/o, but more generic than String->String
10:17:09 <Baughn> Phlogistique: And if you got the forcing slightly wrong, it'd deadlock. xD
10:17:09 <otters> > runWriter $ tell [5] >> tell [6]
10:17:11 <lambdabot>   ((),[5,6])
10:17:16 <otters> @src tell
10:17:17 <lambdabot> Source not found.
10:17:21 <parcs`> wasn't it main :: [Response] -> [Request] ?
10:18:12 <otters> so how did [5] and [6] end up appended?
10:18:28 <rwbarton> by the Monoid instance of [a]
10:18:48 <otters> oh
10:18:50 <otters> oh it uses mappend
10:19:04 <otters> that would be why tell has a Monoid constraint
10:19:25 <rwbarton> even the Monad instance for Writer has a Monoid constraint
10:19:29 <rwbarton> tell doesn't really need it
10:19:33 <rwbarton> @type tell
10:19:34 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
10:19:46 <rwbarton> well, right it has it for that reason
10:19:53 <otters> oh yeah, I see
10:19:55 <Minoru> Phlogistique: http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/  SPJ. Tackling the Awkward Squad
10:20:41 <Minoru> Phlogistique: there's not much detail about previous approach itself, though; but that's the closest match I've been able to found when I asked the same question you just asked
10:21:03 <Minoru> (actually, the *only* match)
10:21:29 <Phlogistique> thanks Minoru
10:24:43 <navaati> hi
10:25:30 <navaati> does GHC's stdlib (on unix) use the libc to do IO, or does it directly use syscalls ?
10:30:42 <migge> How does the type Int# differ from Int?
10:31:34 <ion> It probably implements the primitives Int’s Num and other instances use.
10:32:00 <sclv> Int# is unboxed
10:32:02 <navaati> nah, nothing to do with Num
10:32:09 <ion> ok
10:32:15 <tac-tics> migge: Int# is unboxed. It is always coputer straight to normal form
10:32:31 <sclv> its strict and basically equiv to an underlying int in C
10:33:03 <migge> ok, thanks
10:33:03 <tac-tics> migge: Normal Int's can be suspended thunks -- computations that can be run later to generate an integer value.
10:33:10 <tac-tics> Int# can't be suspended
10:33:48 <sclv> # is generally used to denote things that should be internal to the compiler
10:33:58 <sclv> and map to primitives
10:34:36 <tac-tics> Yep. From a Haskeller's perspective, Int# and its friends are magical
10:34:52 <tac-tics> because they require understanding the guts of the compiler
10:35:19 <shergill> can lambdabot accept messages for people currently not on here?
10:35:26 <shergill> @help
10:35:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:35:30 <tac-tics> shergill: @help tell
10:35:33 <tac-tics> @help tell
10:35:33 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
10:35:43 <nand`> @help ask
10:35:43 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
10:35:45 <shergill> thanks tac-tics
10:36:51 <monochrom> the guts of generated code, actually
10:37:24 <shergill> @ask chrisdone have you got the chance to wrap your haskelldb helpers from http://chrisdone.com/posts/2011-11-06-haskelldb-tutorial.html#fn7 in a git repo?
10:37:24 <lambdabot> Consider it noted.
10:41:46 <linduxed> i've got a function that returns an Int, but i'd like to represent that Int as a String (so effectively casting it). i've forgotten what the best way of doing this is, anyone care to help?
10:42:01 <nand`> “show”?
10:43:10 <Axman6> migge: In case you didn't quite get it, Int is basically a pointer to an Int# (which is a machine/C int), or a computation that will eventually compute an Int# (so either a pointer to the value, or a pointer to the thunk that can compute its value)
10:43:13 <linduxed> hmm, i'll look that up
10:43:31 <Axman6> > show 123
10:43:32 <lambdabot>   "123"
10:43:37 <Axman6> :t show
10:43:38 <lambdabot> forall a. (Show a) => a -> String
10:43:44 <Axman6> all you need to know really
10:44:04 <linduxed> oh ok, so if i've already got deriving (Show) then that's all set?
10:44:06 <linduxed> nice
10:44:15 <Axman6> yes
10:44:28 <c_wraith> linduxed: casting is a heavily overloaded term. Sometimes it means "semantic conversion", sometimes it means "bitwise conversion". Better to just not use it, unless it's a language that has specific meanings for it.
10:44:57 <shachaf> Even in languages that have a specific meaning for it it's often ambiguous. :-)
10:45:06 <nand`> sometimes it's related to spells. incidentally, all such usages have been limited to lisp-likes
10:45:19 <Axman6> how many different types of cast does C++ have?
10:45:41 <c_wraith> static, dynamic, const, reinterpret...  I must be missing some
10:46:06 <Axman6> C cast? or is that one of those?
10:46:14 <c_wraith> It is not one of those
10:46:54 <c_wraith> Though it may be overlapped by the combination of those
10:46:56 <Axman6> (yes I know you're not supposed to use it, but it is still there anyway)
10:47:40 <linduxed> c_wraith: true, it's a vague word
10:47:49 <saulzar> c_wraith: I think those are the core ones... then I think boost has a few more like lexical cast
10:47:50 <linduxed> c_wraith: i should have been more clear
10:50:11 <rwbarton> I'm a little confused, what does deriving (Show) have to do with show :: Int -> String
10:50:32 <nand`> rwbarton: presumably nothing
10:50:33 <rwbarton> separate question I guess
10:50:35 <rwbarton> yeah
10:51:50 <nand`> my only guess would be trying to manually write a show instance, but then “deriving (Show)” would have been irrelevant
10:59:50 <HairyDude> windows ghci doesn't seem to like talking to a real shell
11:00:06 <HairyDude> s/real/MinGW/
11:00:39 <HairyDude> and it doesn't seem to have any history
11:00:50 * MagneticDuck is back (gone 00:44:00)
11:09:08 <mekeor> @time MagneticDuck
11:09:09 <lambdabot> Local time for MagneticDuck is Wed Jun 13 19:08:47
11:10:41 <davidsiegel> Hi! Can someone please help me figure out why my program won't terminate? I've simplified as much as I could while preserving the problem. http://hpaste.org/69890
11:14:49 <c_wraith> davidsiegel: the problem is almost certainly mutual recursion between the two arbitrary instances. Why do they depend on each other?
11:16:04 <davidsiegel> c_wraith: I don't even understand your question, which instances are mutually dependent?
11:16:24 <shachaf> Those are some weird instances.
11:16:32 <c_wraith> The Val instance depends on the [] instance
11:16:46 <HairyDude> davidsiegel: why do (x : _ ) <- arbitrary? why not just x <- arbitrary ?
11:16:48 <c_wraith> and the [] instance depends on whatever instance its contents have
11:17:04 <davidsiegel> c_wraith: yes
11:17:17 <c_wraith> that's mutual recursion
11:17:35 <HairyDude> the [] instance depends on whatever instance its contents have, that's fine
11:18:02 <shachaf> If you just did what HairyDude said it should probably work.
11:18:04 <davidsiegel> HairyDude: (x : _) <- arbitrary was just a simplification
11:18:21 <c_wraith> davidsiegel: yes, but that's the line causing the problem
11:19:00 <davidsiegel> c_wraith: x <- arbitrary; return $ My (head x)
11:19:06 <davidsiegel> that change still doesn't terminate
11:19:11 <c_wraith> that's because it's the same thing
11:19:19 <c_wraith> it still requires the calculation to terminate
11:19:26 <c_wraith> which it won't, because of circular recursion
11:19:28 <HairyDude> don't use head, just do Val x
11:19:34 <HairyDude> return (Val x) I mean
11:19:38 <davidsiegel> but the change you are suggesting completely changes the meaning of my program, as far as I know
11:19:51 <davidsiegel> here is what my actual program is trying to do
11:19:52 <c_wraith> davidsiegel: yes, the meaning of your program is currently "loop forever"
11:20:01 <HairyDude> what you want is arbitrary :: Work Int which is what you get from the Int instance
11:20:02 <c_wraith> davidsiegel: aren't you asking us how to change that?
11:20:11 * hackagebot yesod-auth-fb 1.0.5 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.0.5 (FelipeLessa)
11:20:13 <davidsiegel> It also changes other meaning
11:20:15 <davidsiegel> let me explain
11:20:24 <davidsiegel> I am trying to create a program that generates random workouts
11:20:37 <davidsiegel> I have a class, Arbitrary a
11:20:43 <davidsiegel> there's an Arbitrary Exercises
11:20:49 <davidsiegel> sorry, Arbitrary Exercise
11:21:00 <davidsiegel> and Arbitrary Circuit
11:21:08 <davidsiegel> data Circuit = Circuit [Exercise]
11:21:28 <davidsiegel> so to make an arbitrary Circuit, I want an Arbitrary [a] and Arbitrary Exercise
11:22:31 <S11001001> davidsiegel: where your workouts last forever?
11:22:50 <davidsiegel> S11001001: no, which is why I take the head of the Arbitrary [a]
11:23:01 <davidsiegel> if I adopt the proposed change, then workouts become infinite
11:23:22 <hpaste_> HairyDude annotated “wont terminate” with “wont terminate (annotation)” at http://hpaste.org/69890#a69891
11:24:11 <HairyDude> davidsiegel: does it really matter? you can just take n for however many n you want
11:24:25 <davidsiegel> that's what I try to do, HairyDude, but the program won't finish
11:24:55 <davidsiegel> (x : _) <- arbitrary is just a simplification of take n `fmap` arbitrary, like I have in my actual program
11:25:12 <HairyDude> and n is also arbitrary?
11:25:17 <c_wraith> the problem is your use of State
11:25:18 <davidsiegel> yes
11:26:23 <c_wraith> Even with Lazy state, as soon as you do anything that depends on the state after an infinite loop, it has to run the whole infinite loop.
11:26:23 <HairyDude> ok, instead of liftM2 (:) arbitrary arbitrary, you could do replicateM n arbitrary
11:26:42 <c_wraith> As you've discovered, running the whole infinite loop is problematic
11:26:46 <eacameron> I need to parse HTML...any suggestions as to which library? HXT, HaXml, others? I just need all the leaf nodes of the html file...
11:26:50 <davidsiegel> HairyDude: yes, I tried that and it works perfectly
11:27:10 <HairyDude> davidsiegel: so, problem solved?
11:27:24 <davidsiegel> HairyDude: except that I really wanted an infinite list of arbitrary values
11:27:28 <davidsiegel> to take from
11:27:32 <davidsiegel> for filtering purposes
11:27:38 <c_wraith> davidsiegel: then you can't use the state afterwards
11:27:59 <c_wraith> davidsiegel: this is really important.  lazy state lets you have infinite loops, so long as you don't use the state after the loop
11:28:32 <davidsiegel> I don't understand because I do a take n on the infinite list
11:28:33 <c_wraith> davidsiegel: once you use the state after an infinite loop, it needs to figure out what the state actually is, which means running the whole infinite loop.
11:29:18 <eacameron> HXT vs. HaXml anyone?
11:29:26 <davidsiegel> I have an Arbitrary instance that lets me express a value arbitrary :: Work [Exercise]
11:29:34 <davidsiegel> and that list is infinite
11:29:36 <HairyDude> oh, I see. arbitrary is a constant thunk
11:29:37 <c_wraith> davidsiegel: see how the Int instance uses the state, via the choice combinator?
11:29:53 <HairyDude> for any given instance of Arbitrary
11:30:14 <davidsiegel> c_wraith: yes I see
11:30:35 <c_wraith> davidsiegel: you can do create *one* infinite list of Ints, no problem
11:30:39 <c_wraith> davidsiegel: that's why take 1 works
11:31:09 <c_wraith> davidsiegel: but as soon as you attempt to create the second infinite list of Int, you need to figure out what the final state after the previous infinite loops was
11:31:15 <c_wraith> davidsiegel: this is clearly problematic
11:31:23 <HairyDude> ah, I see
11:31:50 <davidsiegel> I really appreciate the help, guys, but maybe I haven't had enough coffee, I just don't see the problem.
11:32:01 <davidsiegel> Val instance depends on [a] instance, I see that.
11:32:11 <davidsiegel> [a] instance gives an infinite list
11:32:17 <c_wraith> I can simplify it a ton more.  Give me 5 minutes or so.
11:32:18 <davidsiegel> which I just take the head element from
11:32:30 <HairyDude> everything also depends on a StdGen
11:32:49 <davidsiegel> if I try to create just two Vals, the program won't terminate
11:33:27 <shachaf> davidsiegel: Think about how that infinite list works, though, and where your random seeds are going.
11:34:28 <davidsiegel> shachaf: sure, but since I discard the tail of the infinite list...
11:34:42 <shachaf> davidsiegel: Yes, but where's the next random seed coming from?
11:34:43 <c_wraith> davidsiegel: doesn't matter you're STILL THREADING STATE
11:35:00 <c_wraith> You have to thread that state through the entire calculation of the rest of the list that you then throw out
11:35:16 <c_wraith> but to be semantically correct, the state *must* be threaded through all the computations
11:35:29 <davidsiegel> c_wraith: ok, now I am starting to catch on
11:36:22 <c_wraith> lazy state saves you the first time - it lets you do infinite computations, as long as you don't need the state afterwards
11:36:35 <c_wraith> but the second time, you need the state from the previous infinite computation
11:37:00 <c_wraith> and everything falls over
11:39:55 <hpaste_> HairyDude annotated “wont terminate” with “wont terminate (annotation)” at http://hpaste.org/69890#a69892
11:40:28 <HairyDude> replace =<< with liftM there, sorry
11:42:41 <davidsiegel> HairyDude: what does that change mean? You split the StdGen and pass a new StdGen to continue the infinite computation
11:42:46 <HairyDude> yup
11:43:07 <hpaste_> c_wraith pasted “same problem” at http://hpaste.org/69893
11:43:23 <c_wraith> davidsiegel: that paste shows the exact same problem in action
11:43:42 <c_wraith> With all the decoration stripped away
11:43:43 <HairyDude> you give the infinite loop a StdGen to itself, so later random generations don't force it
11:44:05 <linduxed> ok guys, i've got this tricky problem. i'm trying to implement a "kalah-solver" (kalah being a simple board game which you can read about on wikipedia). the code is here https://gist.github.com/2925675 . my problem is that while the function called moveMarbles works for the first "lap" of the board, i don't know how to make any subsequent laps, since the list of pots i need to move across is the one that
11:44:07 <linduxed> moveMarbles creates. so it's like... moveMarbles needs the list itself is creating. don't really know how to do this
11:44:21 <davidsiegel> c_wraith: eureka
11:45:05 <davidsiegel> c_wraith, HairyDude: thanks!
11:45:12 <HairyDude> davidsiegel: hth :)
11:49:36 <augur> is there a name for n-ary predicates that can be defined solely in terms of existentials plus equations?
11:49:49 <augur> and functions
11:50:36 <Adeon> @pl \x -> take x . cycle
11:50:36 <lambdabot> (. cycle) . take
11:51:09 <MagneticDuck> yo guys, I'm not at peace with ()
11:51:11 <youseeli1> hello??anybody help me ??i "cabal update" in windows cmd..bug return"downloading the last pa.......haskell.org"
11:51:21 <youseeli1> cabal: faild.
11:51:46 <dcoutts> youseeli1: you can run with -v3 to see what the http stuff is doing, e.g. you may need a proxy
11:51:55 <MagneticDuck> I don't understand how this works:
11:52:30 <MagneticDuck> > tell "hello" >> 4
11:52:31 <lambdabot>   No instances for (Control.Monad.Writer.Class.MonadWriter
11:52:31 <lambdabot>                   ...
11:52:35 <MagneticDuck> ...
11:52:37 <MagneticDuck> oh
11:52:39 <youseeli1> you mean i can not connection the site?
11:52:45 <MagneticDuck> > runWriter $ (tell "hello")
11:52:46 <lambdabot>   ((),"hello")
11:52:58 <MagneticDuck> > runWriter $ (tell "hello" >> 5)
11:52:59 <lambdabot>   No instance for (GHC.Num.Num
11:52:59 <lambdabot>                     (Control.Monad.Trans.Write...
11:53:00 <youseeli1> docoutts:you mean i can not connection the site?
11:53:34 <MagneticDuck> > runWriter $ (tell "hello" >>= (\x -> 5))
11:53:35 <lambdabot>   No instance for (GHC.Num.Num
11:53:35 <lambdabot>                     (Control.Monad.Trans.Write...
11:53:37 <MagneticDuck> jskfdsf
11:53:49 <geekosaur> that's what it sounds like; please try "cabal -v3 update" and pastebin the result if it's not obvious
11:53:50 <MagneticDuck> oh
11:54:09 <geekosaur> how about a return?  numbers aren't Writer monads...
11:54:12 <MagneticDuck> > runWriter $ (tell "hello" >>= tell "hi")
11:54:13 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.Writer.Lazy.WriterT
11:54:13 <lambdabot>      ...
11:54:16 <MagneticDuck> yeah
11:54:23 <MagneticDuck> mixing everything up
11:54:24 <MagneticDuck> >_<
11:54:26 <MagneticDuck> okay
11:54:30 <MagneticDuck> let's start over
11:54:37 <youseeli1> any mirror site in china??like some linux update mirror site?
11:54:47 <MagneticDuck> > runWriter $ (tell "hello" >> return 5)
11:54:48 <lambdabot>   (5,"hello")
11:54:49 <MagneticDuck> ahah
11:54:57 <MagneticDuck> okay
11:55:09 <youseeli1> "haskell mirror site"
11:55:11 <MagneticDuck> I'm not at peace with what () really means
11:55:55 <tac-tics> > case (runWriter $ (tell (+1) >> return 5)) of (f, x) -> f x
11:55:56 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:55:56 <lambdabot>    `Data.Monoid.Monoid a'
11:55:56 <lambdabot>  ...
11:56:26 <MagneticDuck> youseeli1: Restating question: You're in China and the cabal update for <package name here> failed. With <error here>
11:56:34 <MagneticDuck> right?
11:56:37 <tac-tics> > case (runWriter $ (tell (+1) >> return 5)) of (x, f) -> f x
11:56:38 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:56:38 <lambdabot>    `Data.Monoid.Monoid a'
11:56:38 <lambdabot>  ...
11:56:51 <MagneticDuck> btw sorry to be nooby, but always state your questions clearly
11:56:52 <MagneticDuck> ^^
11:57:05 <geekosaur> youseeli1, there are no mirrors at present.  I don't know if any are planned
11:57:21 <MagneticDuck> (+1)?
11:57:33 <MagneticDuck> a -> a is a monoid??
11:57:41 <MagneticDuck> oh I guess it is
11:57:46 <MagneticDuck> ah hah
11:57:50 <MagneticDuck> yes of course
11:58:05 <tac-tics> I thought it might be... I don't know :P
11:58:11 <tac-tics> fmap (+1) 1
11:58:11 <MagneticDuck> well I'm pretty sure it is
11:58:16 <tac-tics> > fmap (+1) 1
11:58:17 <lambdabot>   No instance for (GHC.Num.Num (f a))
11:58:17 <lambdabot>    arising from a use of `e_111' at <in...
11:58:20 <MagneticDuck> mappend = (.)
11:58:27 <tac-tics> > fmap (1+) 1
11:58:28 <lambdabot>   No instance for (GHC.Num.Num (f t))
11:58:29 <lambdabot>    arising from a use of `e_111' at <in...
11:58:29 <MagneticDuck> ?
11:58:29 <rwbarton> there is a Monoid b => Monoid (a -> b) instance
11:58:35 <rwbarton> that is just pointwise mappend
11:58:58 <MagneticDuck> tac-tics: fmap only works on a "f a" for which f is a functor..
11:59:14 <tac-tics> err
11:59:27 <rwbarton> there's also Endo a which is a newtype of a -> a which has mappend corresponding to (.)
11:59:36 <MagneticDuck> (mconcat [(+1), (-1)]) 1
11:59:45 <MagneticDuck> > (mconcat [(+1), (-1)]) 1
11:59:46 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:59:46 <lambdabot>    `Data.Monoid.Monoid a'
11:59:46 <lambdabot>  ...
11:59:48 <MagneticDuck> ...
11:59:54 * HairyDude decides to install emacs
12:00:04 <MagneticDuck> ((+1) `mappend` (-1)) 1
12:01:13 <youseeli1> MagneticDuck: you meaning let me post the error message?
12:01:36 <youseeli1> just "cabal faild" no any more
12:01:47 <MagneticDuck> yeah
12:01:52 <MagneticDuck> g2g guys
12:01:52 <MagneticDuck> bb
12:02:27 <youseeli1> no "mirror"in china, so what can i do??
12:02:45 <youseeli1> how can i update the cabal success
12:06:18 <adamt> youseeli1: You probably need to chech whether you can actually connect to the update site at all
12:06:23 <adamt> *check
12:08:27 <youseeli1> i can not connect the update site , i sure
12:09:14 <youseeli1> adamt: i can not connect the update site, i sure it..and how can i do now?
12:09:49 <adamt> youseeli1: did you try connecting to it without cabal?
12:11:03 <mae> lo
12:11:46 <youseeli1> had try..can not connect
12:12:40 <senc> hi, can anyone point me to an example of how to use Data.Random.Extras.shuffle? thx in adv
12:12:53 <youseeli1> except proxy, have any other way?
12:13:35 <adamt> Can't you use whatever you would normally use to get around your great firewall? :-P
12:15:14 <nand`> senc: judging by the haddock, you need to use runRVar with a suitable RandomSource instance on the result of shuffle
12:15:18 <youseeli1> I didn't use any firewall
12:16:41 <senc> nand` i am pretty new haskell. i am trying to create RandomSource somehow. I can't seem to figure out how to do it after hours of googling
12:17:37 <adamt> youseeli1: Somebody said chinese, so i was referring to the firewall your goverment operates.
12:19:12 <nand`> senc: looks like the simplest option may be to use IO and DevRandom (uses /dev/random)
12:19:19 <nand`> but I don't know much about these modules
12:19:28 * nand` is going afk
12:19:36 <youseeli1> adamt: ok , i see...hummmm...depressed...
12:19:52 <adamt> youseeli1: Try asking for mirrors in #hackage
12:20:04 <tertl3> how much math do I need to know to use a theorem prover?
12:20:22 <shapr> tertl3: High school algebra is handy.
12:20:31 <shapr> tertl3: That's all I had when I started using theorem provers.
12:20:35 <youseeli1> #hackage is the other room in freenode for haskell??
12:20:41 <tertl3> really?
12:20:57 <youseeli1> adamt: #hackage is the other room in freenode for haskell??
12:20:59 <tertl3> I thought it would be for ivory tower mathematicians
12:21:22 <shapr> tertl3: Oh yeah, totally.. if that means high school algebra.
12:21:36 <tertl3> lol
12:21:55 <tertl3> well whats the easier one to start out with?
12:22:01 <shapr> tertl3: Srsly, I *started* this #haskell irc channel, and I learned Haskell and I did a bunch of other ... 'hard' things. Without ever having had Calculus, Trig, or any CS classes.
12:22:01 <tertl3> prover I mean
12:22:23 <shapr> tertl3: I just had Trig last term, but I started #haskell just over ten years ago.
12:22:40 <tertl3> nice shapr
12:22:43 <shapr> tertl3: Oh! I'm taking Cal 1 sometime in the next two terms! It's gonna be great!
12:23:12 <tertl3> i took calculus before but I did not test well
12:23:29 <shapr> tertl3: It's okay, I failed business cal THREE TIMES fifteen years ago. It was depressing :-(
12:23:39 <mparodi> @hoogle [a] -> [a] -> [a]
12:23:40 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
12:23:40 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
12:23:40 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
12:24:02 <shapr> tertl3: And yet, I can still write Haskell code, had a Haskell job, and organized some conferences, started a semi-academic journal...
12:24:07 <tertl3> well, thanks for your help shapr, and now I know who started this cool channel :)
12:24:12 <shapr> tertl3: Things aren't as hard as people make them seem :-)
12:24:24 <shapr> tertl3: Yes! And if you have any questions, feel free to ask me! I'll try to help you out!
12:24:45 <tertl3> you bet
12:25:09 <shapr> tertl3: Are you starting with Agda? Do you already know emacs?
12:25:16 <shapr> What got you interested in theorem provers?
12:25:30 <otters> shapr, you started this channel?
12:25:32 <tgeeky> shapr: I think things may be hard, but it's more that people who understand hard things well, and people who can communicate this understanding effectively to diverse audiences, are not necessarily correlated
12:25:36 <tac-tics> Theorem provers are teh awesome
12:25:44 <shapr> otters: yup, about 10.5 years ago
12:25:51 <otters> wow
12:25:59 <otters> this channel's more than half as old as me
12:26:19 <shapr> otters: cool! This channel is one quarter as old as me!
12:26:39 <tertl3> well, I like math and I just recently discovered all of these new(to me) ideas such as lambda calculus etc....
12:26:40 <otters> this channel is
12:26:49 <otters> 58.3% of my age
12:26:54 <otters> give or take infinite 3s
12:26:57 <aristid> cool! i think i know your approximate age ranges without having looked up the channel age
12:27:14 <shapr> :-)
12:27:17 <mparodi> is there any function to remove duplicates in a list?
12:27:20 <otters> approximation!
12:27:21 <shapr> mparodi: nub
12:27:23 <otters> mparodi: nub
12:27:28 <shapr> > nub [1,1,2,3,3]
12:27:29 <lambdabot>   [1,2,3]
12:27:32 <mparodi> oh, thanks
12:27:39 <shapr> nub [1,2,1,3]
12:27:42 <shapr> > nub [1,2,1,3]
12:27:43 <lambdabot>   [1,2,3]
12:28:04 <earthy> hm. #haskell only 10.5 years old? I've been here for about 9...
12:28:05 <otters> what's the time complexity of nub
12:28:07 <mparodi> > nub []
12:28:08 <lambdabot>   []
12:28:14 <shapr> earthy: Yes, you've been here since the beginning!
12:28:22 <aristid> otters: turns out my approximate guess was fairly close.
12:28:31 <otters> aristid: what did you guess
12:28:34 <tertl3> and I got a small taste of mathematica in uni, just by hearing the professor say how awesome it was
12:28:42 <aristid> otters: you 20, shapr 40
12:28:46 <otters> pretty close
12:28:53 <shapr> Yup
12:28:53 <otters> that'll be the day
12:29:02 <tertl3> is mathematica a theorem prover too?
12:29:11 <shapr> tertl3: If you like lambda calculus and mathematica, you're in the right place! There's SO MUCH COOL STUFF to learn!
12:29:26 <tac-tics> Mathematica never seemed very interesting to me
12:29:43 <tgeeky> tac-tics: mathematica is amazing
12:29:58 <tertl3> i want to go back to school so I can get it for a discount :)
12:30:07 <tgeeky> but it's not necessarily good for developing an understanding of what's going on, but rather it's great at goings on
12:30:09 <otters> is it good practice to have State SomeType ()
12:30:22 <otters> and then to extract the final state with execState?
12:30:30 <otters> or should I be using a different monad?
12:31:18 <tertl3> mathematica uses gpu compute now
12:31:46 <tertl3> but thats nothing but a speed up
12:32:12 <aristid> tertl3: does it do that by default?
12:32:30 <tertl3> nah, you have to tell it to
12:32:33 <aristid> tertl3: matlab needs a paid add-on to do _anything_ parallelised/accelerated
12:32:56 <hc> hi all, quick question about the Control.Monad.State monad:
12:33:14 <hc> i have looked at the implementation and it seems there are two almost identical source files, one for the lazy and one for the strict version
12:33:30 <hc> isn't there a more elegant way to do this, rather than duplicate all the logic?
12:33:38 <fmap> otters: i don't think you need a monad to use only `State s ()' and not `State s a'
12:33:53 <mparodi> is there a more elegant way to do (list!!n)!!k ?
12:33:54 <timthelion> Is there any way to/any value to, make an 2D array that rather than being of type [[a]] is of some type that requires all rows to be the same length?
12:33:57 <bartavelle> hi, I am a bit fuzzy on the string/bytestring/text question, if I want to parse every character of a (possibly with invalid utf-8) characters, is there a performance advantage in going with bytestring or text ?
12:34:19 <mparodi> @src (!!)
12:34:19 <lambdabot> xs     !! n | n < 0 = undefined
12:34:19 <lambdabot> []     !! _         = undefined
12:34:19 <lambdabot> (x:_)  !! 0         = x
12:34:19 <lambdabot> (_:xs) !! n         = xs !! (n-1)
12:34:26 <geekosaur> timthelion, use an actual Array of some stripe and not a linked list?
12:34:29 <tgeeky> timthelion: you want the type of square matrices?
12:34:32 <geekosaur> or a Vector?
12:34:34 <aristid> bartavelle: yes, compared to String very likely to be faster
12:34:37 <tgeeky> no, just row length
12:34:43 <shachaf> bartavelle: They're different performancewise but it's "not that simple".
12:34:50 <tgeeky> timthelion: you want a vector
12:34:52 <shachaf> Oh, if you're comparing to String, Text will almost definitely be faster.
12:35:05 <bartavelle> ok
12:35:08 <shachaf> bartavelle: If you're working with text, you should use Text.
12:35:16 <timthelion> tgeeky: a vector and not a matrix?
12:35:31 <bartavelle> won't I hit bad errors when my text is some horrible non utf-8 jam ?
12:36:00 <bartavelle> I had that when I played with yesod and couldn't find a way around it
12:36:21 <aristid> bartavelle: that's why ByteString is likely what you want
12:36:30 <bartavelle> ok, that makes sense
12:36:31 <aristid> bartavelle: Text is for things that are actually text
12:36:44 <aristid> bartavelle: what you have is bytes of which you're not yet sure if it's text
12:36:55 <bartavelle> and what is the point of using text over bytestring then ?
12:37:07 <aristid> some people do know that they have text.
12:37:41 <bartavelle> I mean, it seems that all the basics functions I will need are in the text, bytestring and string packages
12:37:50 <aristid> ByteString is simply a sequence of bytes, Text meanwhile is a sequence of _characters_
12:37:52 <bartavelle> so why not just stick to bytestring in all cases ?
12:37:53 <bartavelle> ah
12:38:01 <bartavelle> yes that makes sense
12:38:08 <aristid> characters means all of unicode
12:38:19 <Baughn> @hoogle fixIO
12:38:20 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
12:38:31 <bartavelle> yeah I get it, multibytes characters are a single entity in text
12:38:33 <aristid> Baughn: mfix?
12:38:54 <saep> > popCount 6
12:38:55 <lambdabot>   Not in scope: `popCount'
12:39:04 <shachaf> aristid: Text is actualy a sequence of codepoints. :-)
12:41:12 <aristid> shachaf: are you referring to obscenities like combining codepoints?
12:41:39 <Baughn> aristid: Yeah, that's more likely to be useful. Forgot I was using a transformer.
12:41:46 <Baughn> @hoogle mfix
12:41:46 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
12:42:02 <aristid> @src fixIO
12:42:02 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:42:39 <Baughn> ..though for what I'm actually /doing/, I need *fix*. xD
12:42:58 <aristid> Baughn: hah
12:43:11 <aristid> :t fix . join
12:43:12 <lambdabot> forall a. (a -> a -> a) -> a
12:43:14 <Baughn> (I.e. conditionally repeating an action until it works
12:43:16 <Baughn> )
12:43:44 <Taneb> If I make a minor complaint about a really popular module in here, will anyone listen?
12:43:52 <aristid> Baughn: what does "work" mean? IO Bool?
12:43:53 <Taneb> (the module in question is containers)
12:44:04 <adamt> what's the prettiest way to convert a lazy ByteString to a non-lazy one?
12:44:07 <tac-tics> Taneb: I love complaining. I probably enjoy listen to people complain too
12:44:23 <shachaf> adamt: SB.concat . toChunks?
12:44:41 <Taneb> Data.Sequence.Seq has neither an Applicative nor an Alternative instance, despite being a MonadPlus
12:44:46 <aristid> Baughn: if you like the convenience, maybe this package has something on offier ;) http://hackage.haskell.org/packages/archive/monad-loops/0.3.3.0/doc/html/Control-Monad-Loops.html
12:45:00 <adamt> shachaf: SB being?
12:45:00 <tommd> Taneb: Listen? Yes.  Do anything about it? No.  You should make a patch and propose it to the library mantainer.
12:45:07 <shachaf> adamt: Strict ByteString.
12:45:17 <Taneb> tommd, that sounds like a plan
12:45:18 <adamt> shachaf: Thanks, i'll try.
12:45:39 <Baughn> aristid: Yes indeed, lots of nice stuff I keep reinventing there.
12:45:48 <tommd> Lots of discussion on these sorts of topics happen on libraries@haskell.org if you ever want to join.
12:46:30 <mparodi> foo y = [x|x<-[1..10], x `mod` 3 == y `mod` 3]             VS          foo y = [x|x<-[1..10], x `mod` 3 == k] where k = y `mod` 3
12:46:32 <Baughn> aristid: Anything similar for forkIO-equivalents on ReaderT IO, that kind of thing?
12:46:36 <mparodi> are both the same in terms of performance?
12:46:55 <mparodi> I guess that y `mod` 3 is calculated just once in the first case
12:47:05 <shachaf> mparodi: The Haskell report doesn't specify anything about performance.
12:47:05 <aristid> Baughn: sorry, maybe hackage can help ;)
12:47:16 <shachaf> mparodi: Why don't you measure it? :-)
12:47:22 <mparodi> how?
12:47:51 <mparodi> I just want to know if "y `mod` 3" is calculated more than once in the first case
12:48:12 <mparodi> in that case it's a good idea to put it in a where clause
12:48:35 <HairyDude> heh. starting emacs provoked a BSOD
12:49:03 <mparodi> shachaf, do you know?
12:49:23 <shachaf> mparodi: As I said, the Haskell report doesn't specify.
12:49:31 <mparodi> hmn, ok
12:49:32 <rwbarton> it will depend on the whims of your compiler
12:49:33 <shachaf> GHC might have a different behavior with -O0 and -O11
12:49:47 <shachaf> It might also be that it doesn't even matter.
12:49:51 <shachaf> So you should measure it. :-)
12:49:58 <mparodi> I'll put it inside "where.." to be sure
12:50:04 <shachaf> I hear Criterion is popular for measuring this sort of thing.
12:50:23 <shachaf> "to be sure" :-(
12:50:25 <applicative> where does the Windows Platform put the equivalent of ~/.cabal?
12:50:31 <tommd> Criterion is popular for measuring this sort of thing.
12:50:37 <HairyDude> applicative: %APPDATA%/cabal
12:51:10 * Baughn wishes functions were just automatically lifted
12:51:22 <rwbarton> wut
12:51:50 <otters> that would make typechecking difficult
12:52:40 <shachaf> Also value-checking.
12:52:45 <shachaf> s/.$//
12:55:10 <HairyDude> ah, no, it was opening the haskell-mode customization group that provoked a BSOD :)
12:56:04 <t7> my websockets messages are ariving out of order in firefox
12:56:08 <t7> weird...
12:58:29 <MostAwesomeDude> t7: Haven't seen that before, but I'm not surprised.
12:59:15 <t7> the server sends a message when a client connects, then waits for reply and sends another. but the client shows the second one first
12:59:26 <t7> you cant explain that
12:59:54 <t7> maybe i need to flush or something...
13:01:22 <adamt> t7: Maybe you implemented it as a stack by accident :-)
13:02:14 <hpaste_> t7 pasted “wtf websockets” at http://hpaste.org/69898
13:02:46 <t7> i get reply to reply before the other thing
13:02:55 <t7> are alerts async or something
13:03:13 <tac-tics> Oh neat. Haskell has a web socks library?
13:04:20 <Leemp> Anyone here ever use any of the Haskell -> JS compilers? I'm curious on how much you could actually do in terms of real pages
13:05:10 <tac-tics> Leemp: I'm also curious about that. I believe there are smaller haskells with JS backends
13:05:16 <tac-tics> But sadly, no GHC support
13:06:01 <joeyh> huh, threadDelay uses Int in microseconds, so if I want to sleep a full day, it will overflow
13:06:07 <HairyDude> think it was yhc that had a JS backend
13:06:27 <HairyDude> http://www.haskell.org/haskellwiki/Yhc/Javascript
13:06:43 <Leemp> For what it's worth, http://www.haskell.org/haskellwiki/The_JavaScript_Problem
13:06:49 <illissius> joeyh: there's a package for that
13:06:59 <illissius> can't remember the name though
13:07:10 <HairyDude> oh, yhc is dead :(
13:07:14 <illissius> uses Int64 or Integer or something
13:07:52 <tac-tics> Leemp: interesting link... although I don't think it's really the appropriate place to discuss the pitfalls of Javascript
13:08:05 <Leemp> Unfortunately with JS and real Webpages, you're talking about an API more than a language. Things like DOM, HTML5 APIs, etc. So i was curious if anyone did anything real with Haskell->JS
13:08:20 <tac-tics> As a backend, Javascript is (afaik) 1) adequate... it's just a strict untyped lambda calculus and 2) necessary
13:08:23 <Leemp> tac-tics: I'm not discussing the pitfalls of JS, i'm curious about the Haskell side of Haskell->JS
13:08:49 <tac-tics> yeah, I just mean that page is beyond the scope of Haskell.org IMO :/
13:08:56 <Leemp> Notably, the frontend client-api side of things. And if any haskell dev has experience in this :)
13:08:58 <tac-tics> I'm also curious about that, though
13:09:06 <Leemp> Oh sorry, i thought this was language discussion. My bad :)
13:09:08 <tac-tics> I'd love to never have to write JS ever again
13:09:14 <joeyh> unbounded-delays I'll bet
13:09:16 <t7> ah it was an alert thing
13:09:24 <t7> dont panic guiz
13:09:50 <rwbarton> Luckily I was already not panicking.
13:10:38 <shachaf> rwbarton: Panic!
13:10:58 <joeyh> huh, seems needed for any delay over half an hour, if I got my math right
13:11:09 <t7> adding html elements to a page with websockets
13:11:13 <t7> who needs http
13:12:16 <adamt> t7: My guess would be the websockets layer.
13:12:19 <HairyDude> I don't see why a discussion of Haskell compilers with JS backends is beyond the scope of haskell.org
13:13:25 <HairyDude> shachaf: it always made me chuckle to see panic() in the source code of minix
13:15:36 <luite> Leemp: ghcjs actually supports a large chunk of haskell now, you can install packages with cabal, bytestrings, arrays and text work
13:16:10 <dcoutts> luis: how does bytestring work in ghcjs?
13:16:17 <dcoutts> it's all ForeignPtr etc
13:16:36 <luite> Leemp: problems are speed, and it doesn't support older IE at the moment
13:17:03 <luite> dcoutts: it has typed arrays for storage and lists of weak refs and finalizers
13:17:12 <Leemp> luis: Yea, speed and API are my two concerns. I mostly care about modern APIs, so IE is not really a concern
13:17:36 <dcoutts> luite: you mean it's a different implementation of the same bytestring package api
13:17:54 <luite> dcoutts: no it implements the ghc primops with those
13:18:16 <dcoutts> luite: you mean it provides ForeignPtr, ok interesting
13:18:38 <HairyDude> luite: by older IE you mean, say, IE8? or older?
13:18:40 <applicative> It seems our chinese friend was able go get cabal install going by editing the conf file to look to hackage.factisresearch.com
13:18:49 <luite> dcoutts: yeah, that's hamishmacks work btw
13:18:56 <dcoutts> nice
13:19:08 <luite> HairyDude: uhm atm IE9 isn't even supported :)
13:19:29 <HairyDude> so, it doesn't support any IE? :)
13:19:31 <luite> but i think that can be fixed
13:19:36 <luite> HairyDude: well IE10 beta should work
13:19:37 <HairyDude> (I support this, btw... IE is horrible)
13:19:42 <HairyDude> ah, right
13:20:18 * BriHir slaps joehenry around a bit with a large trout
13:20:25 * hackagebot tensor 0.1 - A completely type-safe library for linear algebra  http://hackage.haskell.org/package/tensor-0.1 (NicolaSquartini)
13:20:27 * hackagebot peparser 0.5 - A parser for PE object files.  http://hackage.haskell.org/package/peparser-0.5 (IanGraves)
13:20:54 <luite> dcoutts: but the generated code is rather slow, i'm trying to write a Cmm->JS backend (the current one is STG->JS) to see if it would improve things
13:21:21 <luite> but a lot of the rts would need to be reimplemented for that
13:21:30 <dcoutts> luite: hmm, my first guess would also be to do STG->JS
13:23:07 <luite> dcoutts: yeah maybe STG is a better source, but it looks like at least the current implementation has a huge overhead with all the function calls, closures being returned, small objects created often
13:23:35 <luite> dcoutts: where a Cmm thing could be much lower level and avoid most JS allocation
13:24:07 <luite> on the other hand it would need to do more work to collect and move garbage, dunno if it's worth it yet
13:24:38 <luite> emscripten claims that it's only 3-4 times slower than native gcc generated code
13:24:53 <luite> the stg thing is more like 1000 times slower :)
13:25:13 <luite> (not measured, but it's slow)
13:26:09 <bartavelle> why does this http://hpaste.org/69899 stack overflows ?
13:26:13 <dcoutts> luite: the problem with the cmm level is it's got an explicit stack already
13:26:30 <dcoutts> luite: so no local js vars, so jit will not be able to do anything clever
13:27:06 <bartavelle> I suppose it is the state that overflows, but I used Control.Monad.State.Strict
13:27:10 <luite> dcoutts: right, that would have to be typed arrays
13:27:16 <linduxed> currently in this code https://gist.github.com/2925675 I've got a function (moveMarbles) that does one "lap" around the board correctly, but need some info from the stuff happening inside of it, outside to be able to make another "lap". an example would be line 69 where currently i discard the second argument (marblesInHand), because i don't really know how i could pass it out of the moveMarbles function
13:27:27 <luite> dcoutts: registers could still be local vars in some cases though
13:27:28 <rwbarton> bartavelle: because after you read a million-line file, the "state" is the thunk (((...(0+1)+1...)+1)+1)+1
13:27:49 <bartavelle> rwbarton, isn't what Control.Monad.State.Strict is supposed to fix ?
13:27:54 <rwbarton> Control.Monad.State.Strict doesn't mean that the state is actually forced by a put/modify action
13:27:57 <rwbarton> no
13:27:59 <bartavelle> ahh
13:28:06 <luite> dcoutts: but the advantage of no local vars is that you only need to return existing function references, never allocate new closures
13:28:09 <rwbarton> it means that the pair (a, s) is forced
13:28:26 <mparodi> > (read [digit]) :: Int where digit = '3'
13:28:27 <lambdabot>   <no location info>: parse error on input `where'
13:28:29 <rwbarton> by (>>=)
13:28:32 <rwbarton> but s isn't
13:28:41 <bartavelle> rwbarton, you mean when I exit runState ?
13:28:46 <mparodi> > let f = (read [digit]) :: Int where digit = '3' in f
13:28:47 <lambdabot>   3
13:28:54 <dcoutts> luite: if you're going from STG then it's all lambda-lifted already
13:29:08 <shachaf> > digitToInt '3'
13:29:10 <lambdabot>   3
13:29:14 <mparodi> great!
13:29:15 <mparodi> thanks :)
13:29:17 <shachaf> > 3
13:29:18 <lambdabot>   3
13:29:42 <linduxed> i'd also need to somehow pass on whether the last pot i dropped a marble in was a store (by using the isStore method and then passing that on somehow)
13:29:44 <rwbarton> bartavelle: not sure what that is in reference to
13:29:47 <mparodi> @index digitToInt
13:29:48 <lambdabot> Data.Char
13:30:20 <rwbarton> if in reference to what I first wrote, then yes, that is what runStateT returns
13:30:28 <bartavelle> rwbarton, do you mean that Control.Monad.State.Strict makes the output of the runState function strict ?
13:30:30 <dcoutts> luite: hmm, I don't see how you avoid allocating closures, the cmm will be doing that explicitly, allocating closures in the heap
13:30:31 <rwbarton> a tuple whose second component is that big thunk
13:30:32 <bartavelle> and only that
13:30:33 <rwbarton> no
13:30:42 <rwbarton> the difference is in the implementation of (>>=)
13:31:49 <rwbarton> > runState (do { undefined; put 3 }) 4
13:31:49 <lambdabot>   ((),3)
13:31:55 <rwbarton> ^ this is the lazy state monad
13:32:36 <shachaf> Hmm, so that doesn't obey the monad laws, does it?
13:32:44 <shachaf> Or do people just make a special case for _|_?
13:32:55 <rwbarton> What's wrong with it?
13:33:00 <shachaf> > (undefined >>= (return :: a -> State s a)) `seq` 1
13:33:01 <lambdabot>   1
13:33:11 <rwbarton> oh
13:33:54 <shachaf> Making (>>= return) always strict would be a bit weird, though.
13:34:05 <rwbarton> > (undefined >>= (return :: a -> Reader r a)) `seq` 1
13:34:06 <lambdabot>   1
13:34:14 <rwbarton> it seems unavoidable for Reader and for State
13:34:33 <shachaf> Well, it's not the case with strict State, is it?
13:34:36 <rwbarton> oh, I guess (>>=) could randomly `seq` its first argument
13:34:47 <rwbarton> uh, right
13:35:04 <rwbarton> well, wait
13:35:14 <rwbarton> I think it still is, for strict State
13:35:25 <bartavelle> I did not understand much of this exchange, but does the strict version means that "runState (a >>= b) x" will have the state resolved before being fed to b ?
13:35:27 <luite> dcoutts: right, that would be mainly array manipulation in the generated code. apparently emscripten can do this relatively succesfully, but maybe it just means that there's something not great about the current stg code.
13:35:27 <rwbarton> because the x in x >>= f is still a function (up to newtype)
13:35:40 <rwbarton> it's when you try to run the resulting State action that the difference arises
13:35:52 <rwbarton> with strict State forcing the resulting pair x s
13:36:08 <shachaf> Oh, yes.
13:36:16 <shachaf> I guess you would have to seq the first argument.
13:36:23 <linduxed> bump?
13:36:29 <rwbarton> bartavelle: the strict version means the state is "resolved" inasmuch as the pair constructor (,) is forced.
13:36:30 <shachaf> I don't think many monads do that.
13:36:47 <HairyDude> > (undefined >>= (return :: a -> Control.Monad.State.Strict s a)) `seq` 1
13:36:48 <lambdabot>   Not in scope:
13:36:48 <lambdabot>    type constructor or class `Control.Monad.State.Strict'
13:36:51 <shachaf> Well, I guess the "data" ones do by virtue of pattern-matching.
13:36:52 <dcoutts> luite: my guess would still be that STG is a better starting point
13:36:55 <rwbarton> right
13:36:56 <HairyDude> doh
13:37:15 <shachaf> > (undefined >>= (return :: a -> IO a)) `seq` 1
13:37:17 <lambdabot>   1
13:37:19 <dcoutts> luite: though you might try early-stage cmm from the new code gen, before it makes the stack explicit
13:37:38 <bartavelle> rwbarton, so that means I should solve my problem by binding many calls to "genstats" instead of recursively calling it ?
13:37:49 <rwbarton> oh, sorry, right forgot about your actual problem.
13:38:28 <luite> dcoutts: that's in 7.6?
13:38:29 <rwbarton> you can ensure that the state is evaluated when you write it. e.g., replace "modify (+ 1)" by "x <- get; put $! x+1"
13:38:50 <dcoutts> luite: not sure, the new cmm backend is something Simon M has been hacking on
13:39:14 <bartavelle> rwbarton, I suppose that $! is like $, except it does something like seq ?
13:39:36 <rwbarton> yes
13:39:48 <bartavelle> thanks a lot, that was enlightening
13:39:50 <rwbarton> equivalent to "let y = x+1 in y `seq` put y"
13:40:01 <rwbarton> @src ($!)
13:40:01 <lambdabot> f $! x = x `seq` f x
13:40:05 <dcoutts> we should really have a ! operator, that does seq, but with the reverse assoc from $
13:40:17 <dcoutts> so you can write f !x !y
13:40:27 <dcoutts> currently, f $! x $! y is something else
13:40:42 <dcoutts> f $! x $! y  =  f $! (x $! y)
13:40:45 <dcoutts> where as we want
13:40:56 <dcoutts> f ! x ! y  =  (f ! x) ! y
13:42:15 <parcs`> >let (!) = ($!) in (+) !5 !4
13:42:18 <parcs`> > let (!) = ($!) in (+) !5 !4
13:42:19 <lambdabot>   9
13:43:11 <parcs`> awesome!
13:44:46 <shachaf> dcoutts: Cale says that both $ and $! should be infixl
13:45:07 <shachaf> There is some sense to that argument.
13:46:38 <dcoutts> shachaf: I've never understood that argument, the whole point of $ is that it's right assoc, and low precedence
13:46:45 <dcoutts> both are important
13:47:04 <shachaf> dcoutts: The argument is that you can eliminate just as many parentheses by using .
13:47:16 <shachaf> E.g. f x . g y $ z
13:47:33 <dcoutts> the nice thing about $ is that it always works
13:47:34 <shachaf> And on the other hand infixl $ lets you eliminate even more.
13:47:41 <dcoutts> you don't have to look at the expression on the right
13:47:47 <dcoutts> you just use   blah $ ...
13:47:51 <shachaf> dcoutts: Yes, that's the counterargument I've often seen. :-)
13:47:56 <dcoutts> never have to look at the structure of the ... bit
13:48:03 <shachaf> dcoutts: Except if it has a ::!
13:48:20 <dcoutts> e.g. extremely handy for use in ghci
13:48:38 <dcoutts> e.g. <home-key> take 10 $
13:48:45 <shachaf> Yep.
13:48:52 <shachaf> I've made that argument before too. :-)
13:49:02 <parcs`> C-a ( C-e ) is not that hard either
13:49:15 <shachaf> dcoutts: On the other hand infixr $! is kind of silly.
13:49:34 <dcoutts> shachaf: well, it's just not as useful as !
13:50:02 <dcoutts> shachaf: but given that $ has the assoc it does, then $! follows, which is why we want !
13:50:47 <parcs`> > let (!) = ($!) in !2 + !3
13:50:48 <lambdabot>   <no location info>: parse error on input `!'
13:50:54 <parcs`> that won't work though
13:51:07 <dcoutts> it's infix
13:51:10 <dcoutts> not prefix
13:51:18 <shachaf> @ty (!)
13:51:19 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
13:51:19 <dcoutts> f ! x
13:51:40 <parcs`> yeah, but it's kind of misleading because !a almost looks like syntax
13:51:41 <bartavelle> linduxed, you are trying to solve the kalah game right ?
13:51:49 <dcoutts> shachaf: right, we should pick something else for arrays, the language already uses ! for strict, in datatypes and in patterns
13:54:15 <bartavelle> linduxed, not sure if that helps, but for solving subsets of bloodbowl I found it useful to separate the rule description from the actual solving
13:55:34 <bartavelle> you can write a generic solving function that takes a state of type s, a function (s -> [a]) that retrieves available moves for a player, and a function (s -> a -> s) that computes the next step based on an action
13:55:47 <Cale> dcoutts: Another reason that I want to encourage people to write  f . g . h $ x  over  f $ g $ h $ x  is that the former has more effective subexpressions, because of the associativity of (.), and so when being read, can be understood and refactored in pieces more easily.
13:56:26 <dcoutts> Cale: I don't want to dissuade you on your mission to encourage people to use f . g $ x
13:56:27 <Cale> dcoutts: For example, g . h is meaningful, but g $ h isn't (even if it typechecks, it'll have nothing to do with the whole expression).
13:56:52 <Cale> In addition to that, $ being left associative would allow removal of even more parens :)
13:57:07 <dcoutts> Cale: just saying that we need $ as it is, and we should add a strict apply (!)
13:57:31 <Cale> I *never* make use of the right associativity of $ as it is, only its low precedence.
13:57:48 <Cale> But if it was left associative, I can see using that
13:58:28 <Cale> f $ g x1 x2 $ h y $ k z -- maybe even with $'s lined up in some cases
13:58:30 <hpc> Cale: oh, i have a good use-case for it associating the way it does
13:58:32 <hpc> uh, sec
13:58:44 <timthelion> Haskell, the only place in the world where there is too much change and too much progress :(
13:58:59 <hpc> Cale: handleInputs area w stVar = do$
13:58:59 <hpc>   w `on` keyPressEvent $ tryEvent $ do$
13:58:59 <hpc>     [] <- eventModifier$
13:59:01 <hpc> ...
13:59:15 <hpc> (ignore those trailing ($), they're just vim :set list)
13:59:17 <dcoutts> Cale: there's a couple options, one is to find a new symbol for infix apply with the reversed assoc, the other is to do something like $ and $$ though I'd argue against changing the assoc of $
14:00:23 <Cale> dcoutts: Well, it's obviously painful to break lots of code at this point
14:01:05 <Cale> But I don't think there's a really good reason to have a right associative application operator. I think it was pretty much just a mistake we sadly might have to live with.
14:01:35 <dcoutts> wouldn't left assoc break things like:  withFoo $ do ... withBar $ do ...
14:01:40 <Cale> no
14:01:52 <Cale> nested do expressions are fine
14:02:34 <Cale> (those aren't even really the same infix chain at that point, so associativity makes no difference)
14:02:56 <Cale> hpc's example, and other things like that are somewhat legitimate
14:03:03 <Cale> I don't know how often that even comes up though.
14:03:15 <Cale> It's rare compared to instances where you might want a left associating $
14:07:18 <rwbarton> I use right-associative $ all the time, I think Cale is completely mad on this one.
14:07:49 <rwbarton> Which I just mention to avoid a silent majority type of situation.
14:08:13 <rwbarton> (.) = fmap is completely mad too, btw.
14:09:04 <mgsloan> yeah, that's a mistake.  Generic != better when it comes to errors
14:09:27 <mgsloan> using Control.Category.(.) is even worse
14:10:49 <copumpkin> I wouldn't say that
14:10:57 <copumpkin> if anything I'd want the Category one
14:14:53 <mparodi> @hoogle [a] -> [a]
14:14:53 <lambdabot> Prelude cycle :: [a] -> [a]
14:14:53 <lambdabot> Data.List cycle :: [a] -> [a]
14:14:53 <lambdabot> Prelude init :: [a] -> [a]
14:14:58 <mparodi> @hoogle+
14:14:59 <lambdabot> Data.List init :: [a] -> [a]
14:14:59 <lambdabot> Prelude reverse :: [a] -> [a]
14:14:59 <lambdabot> Data.List reverse :: [a] -> [a]
14:15:00 <mparodi> @hoogle+
14:15:00 <lambdabot> Prelude tail :: [a] -> [a]
14:15:00 <lambdabot> Data.List tail :: [a] -> [a]
14:15:01 <lambdabot> GHC.Exts augment :: (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
14:15:13 <mparodi> (I'm looking for a "difference" function)
14:15:31 <mparodi> diff [1,2,3] [1] = [2,3]
14:16:34 <tac-tics> @let diff xs ys = [x | x <- xs, not $ x `elem` ys]
14:16:35 <lambdabot>  Defined.
14:16:47 <tac-tics> > diff [1,2,3] [1]
14:16:49 <lambdabot>   [2,3]
14:17:18 <mparodi> @src (\\)
14:17:18 <lambdabot> (\\) = foldl (flip delete)
14:17:28 <mparodi> > [1,2,3] \\ [1]
14:17:29 <lambdabot>   [2,3]
14:17:30 <mparodi> yay!
14:17:41 <mparodi> > [1,2,3] \\ [1,4,5]
14:17:41 <lambdabot>   [2,3]
14:18:46 <tac-tics> @type delete
14:18:46 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
14:18:58 <tac-tics> > delete 1 [1,2,3]
14:18:59 <lambdabot>   [2,3]
14:18:59 <mgsloan> copumpkin: hmm, the errors do turn out to be less bad than I thought they'd be.  However, I do think it's more confusing if you manage to accidentally mix categories, which has happened to me before when working with lenses
14:19:09 <S11001001> mparodi: diff [1,1,1] [1,1] -- ?
14:19:21 <tac-tics> > diff [1,1,1] [1,1]
14:19:23 <lambdabot>   []
14:19:23 <copumpkin> copumpkin: hmm, I guess so
14:19:24 <mparodi> > [1,1,1] \\ [1,1]
14:19:25 <lambdabot>   [1]
14:19:34 <mparodi> > [1] \\ [1]
14:19:36 <lambdabot>   []
14:20:28 <mparodi> > let diff l1 l2 = nub l1 \\ nub l2 in diff [1,1,1] [1,1]
14:20:30 <lambdabot>   []
14:20:33 <mparodi> there it is
14:20:46 <mparodi> > nub [1,1,1]
14:20:47 <lambdabot>   [1]
14:20:50 <mparodi> :)
14:20:57 <mgsloan> copumpkin:  I think / hope there will begin to be a discipline of exporting type-specialized interfaces, and perhaps even automating their creation
14:20:57 <S11001001> fake sets :/
14:21:27 <mparodi> S11001001, do you know a better representation?
14:21:41 <S11001001> like Set?
14:21:59 <mparodi> how do you represent a set like Set?
14:22:14 <S11001001> I mean, a Set is a set
14:22:22 <tac-tics> a finite set maybe.
14:22:35 <mparodi> but how do you create the set like {1,2,3}, S11001001
14:22:37 <mparodi> ?
14:22:49 <tac-tics> @type fromList
14:22:50 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
14:23:01 <S11001001> they're all fromLists
14:23:09 <hpc> @hoogle fromList
14:23:09 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
14:23:09 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
14:23:09 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
14:23:14 <S11001001> @type S.fromList
14:23:15 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
14:23:24 <hpc> there's a LOT of fromLists
14:23:31 <tac-tics> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Set.html#v:fromList
14:23:42 <copumpkin> screw sets
14:23:44 <copumpkin> I like presets
14:23:50 <S11001001> whatever copumpkin
14:24:03 <copumpkin> http://ncatlab.org/nlab/show/preset !!!
14:24:17 <illissius> I like big assets and I cannot lie.
14:24:18 <mgsloan> copumpkin: this'd be like the idea of ListLike - we've got a bunch of modules that export type specific interfaces - and we unify them using a class which provides the generic aliases
14:24:23 <copumpkin> you can't eliminate duplicate elements when you don't know what they'll be!!!
14:24:24 <copumpkin> muahahah
14:25:19 <mgsloan> but if we've got type-specific interfaces, then we can import the ones that our module uses.  I think / hope that this practice will make more sense when you have local imports
14:25:43 <mgsloan> (per declaration namespaces)
14:25:58 <hpc> copumpkin: preset sounds like a fancy definition of "type" :P
14:26:23 <hpc> (or perhaps less-fancy)
14:27:53 <S11001001> nah, it's a graph
14:27:58 <S11001001> graphs everywhere
14:37:39 <linduxed> currently in this code https://gist.github.com/2925675 I've got a function (moveMarbles) that does one "lap" around the board correctly, but need some info from the stuff happening inside of it, outside to be able to make another "lap". an example would be line 69 where currently i discard the second argument (marblesInHand), because i don't really know how i could pass it out of the moveMarbles function
14:41:01 <Cale> linduxed: You could pass it out paired with the existing result?
14:42:39 <Cale> generatePotList startingMarbles = [Pot (if n == 7 then 0 else startingMarbles) (n == 7) n | n <- [1..13]]
14:44:30 <Cale> linduxed: But I'm a little hazy on what your question actually is... do you want  moveMarbles :: [Pot] -> Int -> ([Pot], Int) ?
14:44:55 <linduxed> thxt for the tip on how to shorten the generatePotList
14:45:00 <linduxed> will probably use that
14:45:09 <linduxed> as for clarifying my question...
14:45:38 <linduxed> basically, when i run moveMarbles, it picks marbles up, goes forward correctly all the way up to pot number 13
14:45:40 <linduxed> but
14:45:41 * hackagebot websockets 0.6.0.3 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.6.0.3 (JasperVanDerJeugt)
14:46:42 <linduxed> in a real situation, this would mean that there might be marbles left in the hand, which means that this moveMarbles process should be restarted... but with the list of modified pots that moveMarbles just created
14:47:18 <linduxed> so the way i see it, i need to somehow pass out of this function both the finished list, and the information of how many marbles there are left in hand
14:47:37 <linduxed> as well as whether one had landed in the store with the last marble in hand
14:48:02 <linduxed> so i think it boils down to two questions:
14:49:22 <linduxed> 1. how do i modify moveLoop so that marblesInHand is passed out of it at the end (and possibly a boolean called "landedInStore")
14:50:12 <linduxed> 2. where+how should i implement some looping mechanism that checks whether moveMarbles should continue for another lap with the generated list of modified pots
14:50:43 * hackagebot ClassLaws 0.3.0.0 - Stating and checking laws for type class methods  http://hackage.haskell.org/package/ClassLaws-0.3.0.0 (PatrikJansson)
14:54:26 <tgeeky> :rwell that sounds cool
14:55:11 <linduxed> sur does...
14:55:14 <tgeeky> Using partially-defined values, we show that the standard lazy and strict implementations of the state monad do not satisfy the expected laws.!
14:55:18 <tgeeky> lolwat
14:57:41 <c_wraith> Basically nothing satisfies the expected laws with partially-defined values
14:57:58 <c_wraith> it's kind of implicit that the laws only need to hold for fully-defined values
14:58:28 <tgeeky> right, but to include the tests anyway is pretty nice
15:00:05 <fmap> is there a name for grammars which languages only difference is ε?
15:01:41 <tromp_> how about empty differing languages?
15:03:06 <tromp_> or equivalent-up-to-empty grammars
15:07:22 <linduxed> Cale: number 1 in particular i guess... that's the biggest hurdle
15:19:10 <Guest88588> hello?
15:19:29 <Guest88588> Is anyone reading this?
15:19:37 <sipa> no
15:19:39 <sipa> sorry
15:19:43 <Guest88588> ha, thanks
15:19:46 <Guest88588> just getting set up
15:20:17 <linduxed> haha, we can see that by looking at your name
15:20:47 * hackagebot biostockholm 0.3 - Parsing and rendering of Stockholm files (used by Pfam, Rfam and Infernal).  http://hackage.haskell.org/package/biostockholm-0.3 (FelipeLessa)
15:20:50 <linduxed> not got the IRC client installed yet? :-)
15:25:54 <RosePerry> What do you use haskell for?
15:27:04 <zomg> I made an irc bot and a web app stub
15:27:11 <zomg> and some miscelaneous junk
15:28:25 <linduxed> RosePerry: a huge range of things. is there something in particular you wish to make sure haskell is capable of?
15:30:27 <parcs`> i use haskell for writing programs, because it's a programming language
15:30:41 <RosePerry> No, actually. I'm taking a functional programming class, and just started learning haskell today. Did you use haskell in college?
15:31:21 <hpc> yes, but none of my classes required it
15:31:59 <hpc> i once got a toblerone by writing a sort function in haskell that had some ridiculously specific restrictions on what operations you could perform
15:34:49 * shapr builds the latest haskell-platform with ghc 7.4.2
15:34:55 <shapr> I wonder if that will actually work?
15:35:18 <linduxed> RosePerry: yes, a course which explored different programming paradigms included haskell as the representative for functional programming
15:38:27 <RosePerry> Thanks for the response. If you're a mac user, what text editor do you use to code in haskell?
15:38:50 <t7> vim
15:39:38 <myme> vim
15:39:57 <linduxed> RosePerry: textmate is always a good option, right? personally i use Vim (in linux, but macvim is available for Mac) and i absolutely love it, but if you don't already use it, then it might take some time just to get started
15:40:05 <fuchsto> I
15:40:48 * hackagebot bioalign 0.0 - Data structures and helper functions for calculating alignments  http://hackage.haskell.org/package/bioalign-0.0 (DanFornika)
15:40:50 * hackagebot data-util 0.2 - utilities for handle data  http://hackage.haskell.org/package/data-util-0.2 (KatsutoshiItoh)
15:40:52 <hughfdjackson> you can use vim regularly on mac
15:41:13 <hughfdjackson> the standard terminal does something hella ugly with font, iirc
15:41:41 <fuchsto> I'm trying to declare a data type of an IOArray over IOArrays like data Buffer = IOArray( Int, IOArray(Int,Float)), and ghc is complaining that IOArray(Int,Float) is not applied to enough type arguments. Can anyone tell me what's wrong here_
15:41:45 <fuchsto> ?
15:41:45 <linduxed> hughfdjackson: from what i've seen, the mac users that use vim always use the GUY-vim
15:41:56 <linduxed> GUI-Vim
15:42:04 <hughfdjackson> aye, i did or a while
15:42:05 <myme> I use the brew version.
15:42:09 <myme> In iterm.
15:42:12 <myme> Works like a charm.
15:42:16 <RosePerry> I'm actually an emacs user.
15:42:21 <shapr> Oh me too!
15:42:27 <RosePerry> Do you use textmate?
15:42:40 <shapr> I've never tried textmate, isn't that for Mac OS X?
15:42:44 <RosePerry> yep
15:42:44 <hughfdjackson> i used textmate for a little
15:42:51 <hughfdjackson> it's cute
15:42:57 <shapr> I've been a Linux-only user since 1999
15:42:59 <linduxed> RosePerry: oh, then you should be all set!
15:43:00 <hughfdjackson> and more than up for the job of .. editing code
15:43:21 <linduxed> RosePerry: emacs has plenty of addons that make it nice to edit in
15:43:38 <myme> I have yet to try Sublime Text... Something people around me have been mumbling about.
15:43:38 <linduxed> RosePerry: you should have no reason for switching if you're already accustomed to emacs
15:43:53 <RosePerry> Cool. Should I use emacs in the terminal, or textmate?
15:44:02 <fuchsto> this thing on? *cough* test one two ..
15:44:11 <RosePerry> yep, hi there.
15:44:12 <hughfdjackson> you'll be fine with any one of emacs, vim or textmate
15:44:15 <hughfdjackson> or sublime 2
15:44:25 <RosePerry> alright, thanks.
15:44:36 <hughfdjackson> :D sorry i can't be more specific
15:44:37 <myme> emacs is also already install afaik.
15:44:43 <fuchsto> RosePerry: Thanks, thought my client was lagging
15:44:51 <hughfdjackson> put a gun to my head and i'd say 'vim' ;)
15:44:54 <RosePerry> Does anyone know how I can specify the path where Textmate looks to find runhaskell?
15:45:30 <blackdog> RosePerry: in general, Haskell appeals to language mavens rather thna tool mavens, to use the terminology from http://osteele.com/archives/2004/11/ides
15:45:49 * hackagebot bioalign 0.0.1 - Data structures and helper functions for calculating alignments  http://hackage.haskell.org/package/bioalign-0.0.1 (DanFornika)
15:45:54 <hughfdjackson> RosePerry: not off the top of my head, but you could try ##textmate
15:45:56 <blackdog> so while there are a couple of neat tools like ghc-mod, in general any editor is fine.
15:46:03 <RosePerry> Interesting! Thanks for the article
15:46:16 <RosePerry> And hackagebot: thanks for the note about ##textmate
15:46:29 <hughfdjackson> hehe ^^ welcome
15:46:43 <linduxed> RosePerry: now that's more of a textmate question than a haskell question :-P
15:46:55 * hughfdjackson is definitely more of a language maven
15:48:34 <shapr> I still haven't tried ghc-mod
15:48:50 <blackdog> shapr: it's pretty sweet.
15:49:08 <shapr> Huh, ghc 7.4.2 took about two hours to build on my laptop, but haskell platform took only 14 minutes.
15:49:30 <stepcut> :-|
15:49:31 <blackdog> my only complaints are that it autosaves in the directory, so it can run the checker, which doesn't interop all that well with things like autotest, and it sometimes gets confused if you're using virthualenv or cabal-dev
15:49:38 <hpc> shapr: i am unsurprised
15:49:58 <hpc> shapr: i like to joke that i keep a debian VM around, ready to compile GHC
15:50:02 <shapr> ha
15:50:10 <hpc> just so if someone non-technical comes up behind me, i can make them think i hacked the matrix
15:50:19 <shapr> haha!
15:50:46 <shapr> Compiling with GHC is much improved when an SSD is added.
15:50:47 * Baughn commits heresy by catching ThreadKilled
15:50:50 * hackagebot bioalign 0.0.2 - Data structures and helper functions for calculating alignments  http://hackage.haskell.org/package/bioalign-0.0.2 (DanFornika)
15:51:13 <hpc> (i actually do have a VM ready to compile GHC right now, but it's a side-effect of me wanting to be able to repeat the install process for lambdabot from scratch)
15:51:29 <blackdog> shapr: everything is better with SSDs
15:51:47 <shapr> truly, I only wish I could afford another one for my desktop.
15:51:53 <shapr> I'll just have to upgrade my laptop to 8gb
15:51:55 <blackdog> Baughn: and on the third microsecond TID:313213213 rose again from the dead.
15:51:56 <shapr> (of ram)
15:51:57 <hpc> blackdog: except that one ridiculous class of problems where someone writes to the same file over and over and over again
15:52:19 <aristid> shapr: if you want to avoid compiling ghc, yet always be able to use fresh versions, nix might be an option :)
15:52:49 <hpc> i personally like the hybrid drives
15:52:50 <illissius> there was a really fascinating article on ars technica a few days ago about how SSDs work. it's not so simple.
15:52:58 <hpc> where they take a TB hard drive and put an SD card in as cache
15:53:31 <shapr> aristid: Not this season...
15:53:33 <blackdog> hpc: are they often performance-bound? I can only think of editing and logfiles off the top of my head.
15:53:46 <Baughn> blackdog: Well, not really. I'm catching it for the specific purpose of throwing it.
15:53:46 <aristid> shapr: ?
15:53:57 <Baughn> blackdog: As opposed to, with every other exception, throwing it to the parent thread.
15:53:58 <hpc> blackdog: it's more that it wrecks the lifetime of the drive
15:54:35 <shapr> aristid: I'm doing a Google Summer of Code project, and that's all the brainspace I have at the oment.
15:55:43 <blackdog> hpc: ah, because it keeps writing the same 512k block over and over?
15:55:55 <blackdog> i'm a bit surprised there aren't more SSD-specific filesystems
15:56:15 <blackdog> you'd think you'd be able to get some big wins, given how different the underlying hardware is.
15:56:52 <Baughn> blackdog: No modern SSD would ever wear down a single block like that
15:57:02 <Baughn> They've got wear-levelling, not to mention a lots more esoteric stuff
15:57:21 <aristid> shapr: ok then :)
15:57:22 <Baughn> I.e. you can only /zero/ an entire block at a time, but nothing stops the disk from writing smaller parts of it after zeroing - and they do
15:58:20 <illissius> afaik basically all existing filesystems are designed to minimize seek latency, which on SSDs simply doesn't exist. I wonder what it's worth optimizing for instead in an SSD's case though?
15:58:26 <aristid> Baughn: and it's all done in software... just that the software is running on a little CPU in the SSD itself ;)
15:58:32 <Baughn> Yup
15:58:46 <hpc> illissius: all the SSD optimization is in maximizing the life of the drive
15:58:51 <aristid> illissius: well, locality still matters for SSDs
15:59:05 <aristid> illissius: because of the 512K pages
15:59:05 <Baughn> Locality still matters.. somewhat
15:59:35 <Baughn> Also, depending on the SSD, whole-disk encryption will dramatically reduce its lifetime
15:59:53 <aristid> funnily, wear is currently not the biggest risk for SSDs
15:59:55 <Baughn> E.g. mine compresses everything written to it to get more scratch space
15:59:57 <aristid> buggy firmware is oO
16:00:06 <illissius> Baughn: Sandforce?
16:00:10 <Baughn> illissius: Mm
16:00:18 * aristid doesn't trust sandforce
16:00:25 <luite> sandforce have built-in encryption... except it's buggy
16:00:45 <Baughn> Didn't they fix that yet?
16:01:16 <aristid> Baughn: i guess if you make sure to regularly update your firmware
16:01:57 <hughfdjackson> blackdog: interesting article :D thanks for the link
16:02:07 <luite> Baughn: intel fixed it by reducing the key length from 256 to 128 bit, but it's a hardware problem, aes256 can't be fixed without updating the controller hardware
16:02:26 <aristid> luite: on their sandforce based ssds?
16:02:31 <illissius> it'll be funny when your CPU, your SSD, and your GPU are all running linux.
16:02:32 <luite> yeah, the intel 520
16:02:46 <aristid> luite: because my intel ssd is non-sandforce. good ole' postville g2 :)
16:02:52 <aristid> (the x25-m g2)
16:02:58 <hpc> illissius: it'll be even funnier when they start communicating with standard network protocols
16:03:04 <luite> nah it's only the sandforce ones
16:03:31 <luite> you can get a full refund for any 520 if you buy it before july 1
16:03:34 <aristid> luite: so i guess it was a good decision not to trust sandforce-based ssds :)
16:03:47 <arbn> Does anyone know of a good tutorial, book, or page covering any or all of: existential types, rankN types, GADTs? The Haskell wiki pages and the Haskell wikibook are a bit confusing to me.
16:04:02 <hpc> arbn: the GHC manual can help
16:04:10 <illissius> hpc: iirc with intel's Knight's Whatever stuff, you can ssh to it :)
16:04:14 <hpc> GADTs are fairly simple though
16:04:20 <illissius> though I don't know if that counts as a GPU or just a compute accelerator or what.
16:04:24 <hpc> arbn: let's start with GADT syntax
16:04:35 <aristid> illissius: the x86 many-core thing?
16:04:46 <aristid> illissius: AFAIK it's just slightly updated Pentium cores, many of them
16:04:48 <hpc> basically, instead of writing "data Foo a b c = Bar a | Baz c"
16:04:53 <aristid> illissius: with a VLIW unit
16:04:56 <hpc> you write the type signatures of the constructors Bar and Baz
16:04:57 <illissius> aristid: there might've been more than one of those, but yes, one of those
16:05:00 <aristid> (on each core)
16:05:08 <luite> aristid: right, though in practice, 128 bit key length is still more than enough
16:05:09 <hpc> data Foo a b c where Bar :: a -> Foo a b c; Baz :: c -> Foo a b c
16:05:38 <hpc> arbn: from there, what GADTs give you is the ability to be more specific about what kind of Foo it creates
16:05:44 <aristid> illissius: and i think it was originally supposed to be a GPU, at least the predecessor (larrabee), but was too slow at gpu tasks
16:05:54 <hpc> data Foo a b c where Bar :: a -> Foo a a c; Baz :: c -> Foo a c c
16:05:55 <illissius> arbn: I ended up giving a semi-involved explanation here http://stackoverflow.com/questions/10761583/evolving-data-structure/10762546#10762546
16:05:59 <hpc> or
16:06:40 <hpc> data Foo a = Number :: Int -> Foo Int; Function :: (a -> a) -> Foo (a -> a); Apply :: Foo (a -> b) -> Foo a -> Foo b
16:06:44 <arbn> hpc: Right. What I don't understand why this sort of thing is not a GADT but a rankN type: data Bar = Bar {bar :: Ord b => b -> Bar }
16:06:56 <aristid> hpc: syntax error
16:07:02 <hpc> aristid: close enough
16:07:11 <aristid> data Foo _where_ :P
16:07:25 <illissius> arbn: that's a datatype containing a polymorphic function
16:07:27 <hpc> arbn: because 'b' is being quantified inside Bar
16:07:31 <illissius> using record syntax
16:07:45 <hpc> instead of "data Bar b <-- now b is in scope", it's
16:08:02 <hpc> "data Bar = Bar {bar :: {- now b is in scope -} Ord b => ...}
16:09:12 <monochrom> "data Bar = Bar (forall b. Ord b => b -> Bar)" becomes "data Bar where Bar :: (forall b. Ord b => b -> Bar) -> Bar"
16:09:36 <arbn> hpc: OK... So, if a type-variable is introduced inside a constructor definition, that makes it rankN?
16:09:51 <hpc> more or less
16:09:57 <hpc> it makes it at least rank 2
16:10:15 <illissius> aristid: yeah Larrabee was supposed to be a GPU but it sucked, but they kept going so now they have Knight's Corner and Knight's SomethingElse (can't remember which is the newer one) which are compute-oriented, and I think they'll build back up to doing a GPU from there. (Or GPUs will just keep getting more general purpose to the point where they eventually converge without Intel having to put in any special effort to GPU-ize
16:10:16 <illissius> things.)
16:10:21 <hpc> the distinction isn't relevant here, but it's good to know it exists
16:10:29 <companion_cube> covariant position,in this case, is a position with negative polarity?
16:10:52 * hackagebot bioalign 0.0.3 - Data structures and helper functions for calculating alignments  http://hackage.haskell.org/package/bioalign-0.0.3 (DanFornika)
16:11:46 <MilosDj> hello people, I have a question about converting IO Char to Char
16:11:53 <MilosDj> rndChar = randomRIO (' ', '~') --(randomRIO ('a','z')))
16:11:53 <MilosDj> str 0 = []
16:11:53 <MilosDj> str n = rndChar : str (n-1)
16:11:57 <arbn> Now, just in simple terms what is the difference between "data Foo = forall b. Ord b => Foo {foo :: b}" and the rank-2 "Bar" above? I know it's existential, but the difference isn't obvious.
16:12:06 <hpc> MilosDj: short answer is "you can't"
16:12:11 <MilosDj> rndChar works, but str n does not
16:12:26 <MilosDj> what to do then?
16:12:34 <MilosDj> str 0 = []
16:12:34 <MilosDj> str n = rndChar : str (n-1)
16:12:37 <hpc> uh
16:12:41 <blackdog> hughfdjackson: np. it's the one i trot out every time a javadude asks me how i ever write anything without a gigabyte of eclipse to help me
16:12:44 <hpc> i can't really explain it that well
16:12:56 <hpc> but stick around and someone will have an explanation
16:13:03 <MilosDj> No instance for (Show (IO Char))
16:13:05 <illissius> aristid: iirc it's a whole lot of x86 cores, each capable of running something like 4 or 8 threads, with giant vector units (something like 1024 bits wide?), and then they have some of the cores running linux to distribute the work and things, or something like that.
16:13:08 <MilosDj> that's error
16:13:23 <MilosDj> ok, thanks
16:13:49 <hughfdjackson> blackdog: i may trot it out in future for that very reason :p
16:14:06 <arbn> hpc: OK. Thanks.
16:14:14 <kallisti_> MilosDj: not sure if anyone has answered yet, but:  that's not possible in a safe manner.
16:14:38 <blackdog> hey, anyone here work for google? just in the preliminary stages of interviewing... i don't know if i'm jaded, but it actually sounds like a pretty corporate job.
16:14:42 <MilosDj> ok, how to create random string than?
16:14:59 <MilosDj> rndChar = randomRIO (' ', '~')
16:15:03 <MilosDj> this works
16:15:14 <MilosDj> every time i all it ghci gives random char
16:15:19 <arbn> blackdog: I would think a job at a corporation would be "pretty corporate" by definition.
16:15:31 <blackdog> arbn: google is meant to be different :)
16:15:42 <MilosDj> str 0 = []
16:15:42 <MilosDj> str n = rndChar : str (n-1)
16:15:48 <MilosDj> this produces error
16:15:49 <hpc> @where hpaste
16:15:49 <lambdabot> http://hpaste.org/
16:15:56 <hpc> MilosDj: ^ use that to paste code, it'll be easier
16:15:59 <kallisti_> MilosDj: randomRIO is an IO Char because it performs a side-effect as parts of its computation. In order to use the result of that computation you have to chain it together into a larger IO computation.
16:16:08 <aristid> blackdog: The way it's meant to be different. :D
16:16:08 <blackdog> i dunno, there was just something about the way the dude pronounced "Haskell" - like a strange and not necessarily pleasant new taste in his muoth.
16:16:30 <MilosDj> ok, how?
16:16:36 <illissius> arbn: An existential means the constructor is polymorphic in some type variable that's not present in the type itself. So once it's constructed, the information about which type that was is lost. So the only thing you can do with it after that is things where the specific type doesn't matter -- polymorphic functions, or if you also stored the fact that it belongs to some type class, the things allowed by that class.
16:17:03 <kallisti_> MilosDj: you can do this a variety of ways. one way would be to use the >>= operator
16:17:07 <hughfdjackson> sometimes rwh's top-down coding style without warning is very frustrating
16:17:08 <kallisti_> you could also use fmap  (aka <$>)
16:17:19 <hughfdjackson> end up thinking you've forgotten to import a dependency somewhere :/
16:17:51 <kallisti_> MilosDj: for your case I think you want sequence . repeat . randomRIO $ (x, y)
16:17:54 <kallisti_> :t sequence
16:17:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:17:58 <kallisti_> or actually take n
16:18:06 <kallisti_> er replicate n, even. :P
16:18:12 <kallisti_> instead of repeat.
16:18:14 <hpc> you wouldn't want repeat there...
16:18:33 <arbn> illissius: OK. That actually makes sense. Why is it called "existential"? Just because it's quantified only over the scope of the data definition itself?
16:18:57 <hpc> arbn: it's a math term
16:19:11 <illissius> arbn: It's related to existential and universal quantification in first-order logic
16:19:17 <hpc> if you need a mnemonic, how about "all you know about the type is that it exists, but you don't know which type it is"
16:19:42 <arbn> I have a background in logic, which is why I'm asking. The relationship isn't obvious to me.
16:20:19 <irene-knapp> I actually am pleased to hear that, haha
16:20:25 <irene-knapp> because I find the name confusing
16:20:40 <irene-knapp> the analogy has never made sense to me either, but I /don't/ have a background in logic, so I didn't know if it might
16:21:37 <irene-knapp> suggestions for other names are welcome
16:21:39 <illissius> arbn: A higher-rank function is a function which takes a *polymorphic* function as an argument. Normally, higher-order function arguments are instantiated at the same types as the function they're an argument to (example: iterate :: (a -> a) -> a -> [a], the 'a' is the same inside the parentheses and outside). If the higher-order function is polymorphic, though, the function it's an argument to can instantiate it at whatever
16:21:41 <illissius> type it likes. (trivial example: foo :: (forall a. Show a => a -> String) -> b -> String, takes a polymorphic function that can be used on any 'a', and then uses it on a particular 'b' of the caller's choice.)
16:21:59 <hpc> arbn: types like "id :: a -> a" correspond to ∀a. a → a
16:22:36 <hpc> aaaand, lost my train of thought
16:22:44 <arbn> hpc: Yeah. That makes sense. I just don't see how making the scope of that quantifier more tightly bound makes the type existential.
16:24:14 <arbn> ∀a. a → a
16:24:28 <hpc> to start with, you can expand (forall b. b) to (forall b c. (b -> c) -> c)
16:24:35 <hpc> and i forget the next step to get exists
16:26:01 <hpc> it's easier to understand if you don't try and tie it back into logic, i find
16:26:28 <illissius> arbn: are you familiar with CPS/Scott/Church-encoding by any chance?
16:26:33 <irene-knapp> so wouldn't that mean that appropriating a name from formal logic is a bad idea? :)
16:27:30 <arbn> illissius: Not really. I'm familiar with Goedel numbering, and I've heard that the idea behind Church numerals is similar, but for lambda functions, but I'm not familiar with them.
16:28:30 <illissius> arbn: hmm, okay. never mind then :)
16:30:09 <arbn> illissius: My original question was for a reference, though. Any idea where I'd read to understand how the existential type is actually existential in the FOL sense?
16:31:32 <shapr> @quote
16:31:32 <lambdabot> p_l says: I still wonder why bubble-sort isn't prohibited
16:32:24 <hpc> @let bubblesort list = text "No! The bubbles are getting away!"
16:32:25 <lambdabot>  Defined.
16:33:03 <arbn> illissius: Also, that explanation of a rank-2 type makes sense to me. Thanks
16:34:22 <illissius> arbn: I think I might have something... if we ignore bottoms, a datatype containing a single value is isomorphic to the type it contains. so data Foo a = Foo a is isomorphic to a; data Foo = Foo (forall a. a -> a) is isomorphic to forall a. a -> a (higher-rank); but what's data Foo = forall a. Foo a isomorphic to? you can't just take that inner part out like with the other examples, because it's quantified over some arbitrary 'a'
16:34:23 <illissius> . and actually what it's isomorphic to is exists a. a, but you can't write that, which is why you have to encode it in datatypes.
16:34:28 <illissius> I don't have a link though, sorry
16:35:21 <hpc> illissius: oh, that's good
16:36:29 <arbn> illissius: Ah. Thanks. That actually is very helpful, and gives me a better sense of what's heppening.
16:36:35 <hpc> illissius: and now i can remember the difference between forall a. Foo a, and Foo (forall a. a)
16:36:46 <hpc> exists a. a VS (forall a. a)
16:37:25 <illissius> arbn: you're welcome. this is actually the first time I've managed to think this through, so I learned something new as well.
16:38:22 <illissius> hpc: I've thought at various times that there should be a wiki page like ForallWhereMeansWhat, but was always too lazy to make one
16:38:55 <hpc> heh
16:39:13 <hpc> i should add links to my language extension post now...
16:39:14 <hpc> http://hpc.dyndns-web.com:8000/blog/view.cgi?id=15
16:40:46 <illissius> what do data constructors correspond to in FOL? I can't even remember what the various things in FOL were called. But I think this might be one of those cases where if you move an exists/forall inside/outside some parentheses, it flips over to become the other one.
16:42:00 <shapr> Man, tryhaskell.org is way more impressive when you try to write your own clone.
16:42:28 <blackdog> shapr: where are the pain points?
16:42:53 <hpc> looks like plain old mueval
16:43:00 <hpc> with some ajax
16:43:34 <hpc> oh, it also does type queries
16:43:41 <hpc> that part is really fun
16:43:53 <nobdraisentone> Is there a way to handle a failed case in curl action, when there is no connect? curlGetResponse_ just wait 40 sec (is it a some default value) and return empty string
16:43:56 <luite> hpc: it uses a modified mueval because the overhead of starting a new mueval every time is rather high
16:44:11 <illissius> hpc: Heh, the DoRec/RecursiveDo part is already out of date, it's the reverse now.
16:44:21 <hpc> illissius: dammit
16:44:28 <illissius> or, I guess, will be once 7.6 comes out, if that's what it takes to make it official
16:45:12 <hpc> yeah, i changed it just so it can be futureproof
16:45:17 <shapr> blackdog: There's just lots to know.
16:46:00 <hpc> shapr: do you know how to get a type signature from ghci?
16:46:05 <shapr> Huh?
16:46:26 <luite> hpc: you can get a type with hint
16:46:44 <hpc> oh
16:47:02 <hpc> heh, that makes lambdabot's "run ghci and parse the output" look rather silly
16:47:20 <hpc> (and mine, but it's perl so it already looks silly)
16:47:56 <shapr> I have a working demo, but mine is ugly and I want to use chrisdone's jquery-console for this next prototype.
16:49:04 <illissius> hpc: there's also DeriveFunctor/DeriveFoldable/DeriveTraversable
16:49:15 <hpc> illissius: i lumped those together, i think
16:49:42 <hpc> or i was using 7.4.1, actually
16:49:43 <illissius> hpc: you have Typeable and Generic but not those, unless I'm blind
16:49:46 <hpc> which only has the two
16:49:53 <illissius> nah, they've been around a while I think
16:50:02 <hpc> my GHC doesn't have them
16:50:20 <hpc> $ ghc --version
16:50:20 <hpc> The Glorious Glasgow Haskell Compilation System, version 7.4.1
16:50:28 <hpc> $ ghc -XDerive
16:50:28 <hpc> -XDeriveDataTypeable  -XDeriveGeneric
16:50:57 <illissius> hm, what did you do there?
16:51:20 <illissius> $ ghc7.4 -XDerive
16:51:21 <illissius> ghc: unrecognised flags: -XDerive
16:51:24 <hpc> illissius: tab completion
16:51:40 <illissius> hpc: I think that's a property of your shell, not GHC.
16:51:48 <hpc> illissius: http://hackage.haskell.org/package/ghc-man-completion
16:52:17 <illissius> oh, I see. maybe they're not in the man page. but they def exist.
16:52:20 <hpc> it parses the man page, and i also took the extra precaution of grepping my man for Functor
16:52:29 <hpc> strange
16:53:43 <illissius> hpc: anyway, I would also put ExplicitForAll and GADTSyntax, and maybe ScopedTypeVariables, under syntax.
16:54:29 <hpc> i deliberately put them near the extensions that imply them
16:55:26 <illissius> ok
17:04:10 <hpaste_> mmcdermo pasted “Association List Alternative?” at http://hpaste.org/69907
17:04:41 <mmcdermo> Maybe I'm trying to do this the wrong way; what I would like is a convenient way to construct javascript objects
17:05:07 <mmcdermo> As far as I could tell, HJScript / HJavascript doesn't provide a convenient way to do so
17:07:18 <mdmkolbe> (This is in reference to the Haskell 2010 language spec.)
17:10:58 * hackagebot bioalign 0.0.4 - Data structures and helper functions for calculating alignments  http://hackage.haskell.org/package/bioalign-0.0.4 (DanFornika)
17:18:39 <linduxed> how was it that i turned on debugging?
17:18:54 <linduxed> or rather step by step progression through the application?
17:19:20 <fuchsto> i have defined a data constructor like this:    data SignalBuffer = IO (Int, Float)  in module 'Types'. When importing this module, ghc complains that there is no data constructor 'SignalBuffer' in scope. What am i doing wrong_
17:19:24 <fuchsto> ?
17:19:47 <fuchsto> I'm importing with    import qualified Types as T
17:19:47 <MostAwesomeDude> linduxed: I have yet to see such a thing, but then again I'm pretty bad at Haskell.
17:19:52 <Enigmagic> fuchsto: you named it IO
17:19:54 <fuchsto> and using T.SignalBuffer
17:20:03 <fuchsto> Gnaaaarrh
17:20:07 <mdmkolbe> fuchsto: 'SignalBuffer' is a type, you are trying to use it as an expression
17:20:08 <fuchsto> yes, yes i did
17:21:16 <fuchsto> actually i want to define an IOArray over an IOArray
17:21:43 <fuchsto> and have an IORef on it
17:21:48 <linduxed> MostAwesomeDude: i've used it before, can't remember the name though
17:22:10 <fuchsto> like   signalBuf <- newIORef(SignalBuffer)
17:22:37 <mdmkolbe> @type newIORef
17:22:38 <lambdabot> Not in scope: `newIORef'
17:22:52 <fuchsto> it's in Data.IORef
17:23:38 <mdmkolbe> fuchsto: what do you want the inidial value of the IORef to be?
17:23:41 <fuchsto> type is a -> IO( IORef a )
17:23:55 <mdmkolbe> fuchsto: you should do "signalBuf <- newIORef initial_value"
17:24:11 <fuchsto> mdmkolbe: i just groked that i have to ask that question myself :)
17:24:44 <fuchsto> i want it to be an empty IOArray of IOArrays
17:25:20 <fuchsto> defining this kind of type is my actual problem
17:26:08 <parcs`> @djinn a -> a -> Bool -> a
17:26:08 <lambdabot> f a b c =
17:26:08 <lambdabot>     case c of
17:26:08 <lambdabot>     False -> b
17:26:08 <lambdabot>     True -> a
17:26:29 <mdmkolbe> fuchsto: what module is IOArray?
17:27:14 <fuchsto> IOArray is Data.Array.IO
17:27:26 <otters> @hoogle IOArray
17:27:26 <lambdabot> Data.Graph.Inductive.Monad.IOArray module Data.Graph.Inductive.Monad.IOArray
17:27:26 <lambdabot> Data.Array.IO data IOArray i e :: * -> * -> *
17:29:24 <mdmkolbe> fuchsto: "array <- newListArray (low, hi) []; signalBuf <- newIORef newListArray"
17:29:50 <mdmkolbe> fuchsto: however, do you really want an IORef of an IOArray?  Or do you just want an IOArray?
17:30:09 <fuchsto> In this case i need an IORef, as multiple UI elements are accessing it
17:30:50 <fuchsto> some consumer/producer thingie. One module is producing signals over time (signalBuf[t]), another module is rendering these values
17:31:28 <mdmkolbe> fuchsto: over the IORef's lifetime will it potentially refer to different "SignalBuff/IOArray" objects?
17:31:52 <fuchsto> No, at least it is not supposed to
17:32:05 <fuchsto> i consider it a pointer to a common buffer
17:32:32 <mdmkolbe> fuchsto: then I don't think you want an IORef.  The IOArray is already mutable.  (Unless you are using the IORef as a mutex object or something.)
17:33:21 <fuchsto> it should be mutexed
17:33:50 <fuchsto> hm, actually i need two buffers: One that is written to, and one that is read from
17:34:06 <fuchsto> and swapping these after a write
17:34:37 <mdmkolbe> I suspect that IOArray already has mutex support.  You don't need the IORef as an IOArray is already a reference to a mutable array.
17:35:57 <fuchsto> mdmkolbe: Nice, thanks
17:36:57 <fuchsto> i just defined a function   newSignalBuffer = newArray(1,100) 0 :: IO (IOArray Int Float)
17:37:58 <fuchsto> this should produce an IOArray of 100, filled with 0s. Seems to work.
17:40:13 <mdmkolbe> @type (<$>)
17:40:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:40:39 <mdmkolbe> fuchsto: if you want type dicipline you can do "newtype SignalBuffer = SignalBuffer (IOArray Int Float); newSignalBuffer = SignalBuffer <$> newArray (1,100) 0 :: IO SignalBuffer"
17:41:02 * hackagebot bioace 0.0 - Library for reading ace assembly files  http://hackage.haskell.org/package/bioace-0.0 (DanFornika)
17:41:03 <mdmkolbe> "f <$> x" is the same as "liftM f $ x"
17:41:09 <fuchsto> mdmkolbe: That looks exaclty like what i want, thank you
17:41:39 <fuchsto> i tend to confuse data constructors and types, sorry, just using Haskell for some weeks
17:42:22 <otters> mdmkolbe: isn't it closer to Applicative?
17:42:34 <otters> mdmkolbe: err, I mean, isn't liftA closer
17:43:16 <mdmkolbe> otters: yeah, technically it is actually "fmap f $ x"
17:52:23 <fuchsto> mdmkolbe: So, in your example SignalBuffer is used as a function_
17:52:23 <fuchsto> ?
17:53:23 <mdmkolbe> when you declare "newtype Foo = Bar Int", there becomes a new function "Bar" (called a constructor) that takes an Int as argument and returns a Foo.
17:53:59 <mdmkolbe> In this example, yes, I use SignalBuffer as a function (but only because I named the constructor SignalBuffer, not because the type is named SignalBuffer)
17:54:32 <fuchsto> aaah, sure, i remember having understood that once :) thank you
17:56:10 <flazz> somebody was trying to explain to me that all values are functions, event something like 4::Int. 4 is a partially applied function of some sort. is this true? i thought 4 when evaluated was impossible to evaluate more and was a piece of memory with some annotation and some part that represented the number 4.
17:56:34 <hpc> you have it backwards
17:56:37 <hpc> functions are values
17:56:43 <flazz> i know that
17:56:52 <flazz> but non function values, are they functions too
17:56:54 <flazz> ?
17:56:57 <hpc> no
17:57:15 <heatsink> Maybe he was talking about thunks
17:57:42 <heatsink> Using any value may cause code to be executed to produce the "real" value
17:58:03 <hpc> hmm, maybe
17:58:05 <illissius> flazz: was it that guy on reddit?
17:58:15 <flazz> no, in person
17:58:23 <jfischoff> is there any difference between a constant function and a value?
17:58:28 <illissius> oh, i dunno then.
17:58:42 <jfischoff> err a value of type :: a
17:59:03 <mauke> jfischoff: yes, a function takes an argument
17:59:06 <mdmkolbe> illissius: what guy on reddit?
17:59:28 <jfischoff> duh
17:59:32 <jfischoff> my bad
17:59:36 <hpc> > True 15 -- a non-function getting passed a parameter makes no sense
17:59:37 <lambdabot>   Couldn't match expected type `t1 -> t'
17:59:37 <lambdabot>         against inferred type `GHC.B...
17:59:57 <flazz> don't constant functions still require application to be evaluated?
18:00:17 <mdmkolbe> Really you should think of "function" like you think if "Int".  All functions and Int are values, but not all values are functions or Int or either.
18:00:34 <illissius> mdmkolbe: http://www.reddit.com/r/haskell/comments/uwrb7/why_do_haskell_programmers_hate_parentheses/c4zhwrt
18:00:58 <mdmkolbe> flazz: Haskell doesn't have "constant functions" unless you mean something like "\x -> 4"
18:01:27 <flazz> mdmkolbe: that is what i mean
18:01:44 <mdmkolbe> @type \x -> 4
18:01:45 <lambdabot> forall t t1. (Num t1) => t -> t1
18:02:27 <mdmkolbe> flazz: "\x -> 4" is a function, it is not a number so yes, you need to apply it to an argument in order to get the "4" out
18:03:06 <flazz> so back to thunks, they are compiled but unevaluated applications in the heap?
18:04:15 <mdmkolbe> flazz: yes (unless someone I've forgotten a subtlety)
18:04:26 <hpc> a thunk of type FOO is something similar to a pointer to a function
18:04:38 <hpc> FOO *evalFOO();
18:05:00 <hpc> the first time you run evalFOO() (read, first time you evaluate x)
18:05:06 <hpc> it runs a computation
18:05:18 <hpc> then modifies the pointer that is pointing to it
18:05:24 <hpc> so it no longer points to evalFOO
18:05:42 <hpc> it now points to savedFOO() { return thatThingWeJustComputed; }
18:06:06 <mdmkolbe> flazz: think of thunks like JIT compilation.  You never see it at the programmers level (except that it gives you "odd" performance characteristics, e.g. laziness).  And it is the computer pretending it's already compiled (for JIT) or evaluated (for thunks) a value.  If it turns out you need it, then it will go back and actually compile or evaluate the value.
18:06:45 <flazz> is 4 a value constructor of the type Int?
18:07:01 <flazz> or is 4 just a value of the type Int?
18:07:16 <mdmkolbe> flazz: it is both
18:07:40 <illissius> flazz: when you write x = 1 + 2 Haskell doesn't store x = 3, it stores x = 1 + 2, where 1 + 2 is the thunk. if you write y = 5 + x, it stores y = 5 + x. it only evaluates the thunk when their value is actually needed for something, for example if you write y == 9 (and if the y == 9 is also needed for something, it's all rather pull-based), then it will evaluate the thunks, collapse y down to 8, and determine that it's not equal
18:07:41 <hpc> it's just a value
18:07:41 <illissius> to 9.
18:07:44 <hpc> in GHC at least
18:07:47 <hpc> @src Int
18:07:47 <lambdabot> data Int = I# Int#
18:07:53 <parcs`> 4 is actually 'fromInteger (S# 4#)' so it's a value
18:07:59 <hpc> but that's getting way deeper than anyone should need to know
18:08:12 <hpc> oh, also what parcs` said
18:08:31 <kallisti> :t f
18:08:32 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
18:08:41 <kallisti> :t x
18:08:42 <lambdabot> Expr
18:08:47 <kallisti> ah
18:08:53 <flazz> i think i need this depth, thanks
18:09:09 <illissius> @instance Monad IO
18:09:10 <lambdabot> Maybe you meant: instances instances-importing
18:09:15 <mdmkolbe> flazz: if I say "data List = Nul | Cons Int List", then "Nul" is called a "constructor", but it is not a function, it is just a value of type List.
18:09:30 <kallisti> parcs`: is that standard now or is it GHC specific?
18:09:53 <illissius> kallisti: the fromInteger part is standard, the S# 4# part is GHC specific
18:10:01 <kallisti> right, that's what I thought.
18:11:06 <illissius> there was some command to get lambdabot to spit out the source code for an instance. or am I misremembering?
18:11:20 <hpc> use @src
18:11:25 <kallisti> flazz: semantically numeric literals act as a sort of overloaded "pseudo-constructor", which basically means that you can use them in case expressions
18:11:25 <illissius> @src Monad IO
18:11:26 <lambdabot> Source not found. I feel much better now.
18:11:26 <hpc> but don't expect it to be correct
18:11:32 <flazz> for "x = Nul", what does the thunk look like?
18:11:32 <parcs`> @src [] (>>=)
18:11:33 <lambdabot> xs >>= f     = concatMap f xs
18:11:35 <illissius> @src instance Monad IO
18:11:35 <kallisti> but they work differently from other constructors
18:11:35 <lambdabot> Source not found.
18:11:36 <parcs`> @src IO (>>=)
18:11:36 <lambdabot> m >>= k     = bindIO m k
18:11:51 <parcs`> @src bindIO
18:11:51 <lambdabot> Source not found. There are some things that I just don't know.
18:11:53 <parcs`> :(
18:12:07 <illissius> ok. guess I'll have to look up the sources :)
18:12:16 <mdmkolbe> flazz: I forgot to mention the reason I talked about "List" was that "4" is a constructor/value in the same sense that "Nul" is a constructor/value
18:12:37 <illissius> I'm wondering if there's any reliable way to make RULES for monadic stuff
18:12:50 <parcs`> another reason why 4 isn't a value constructor: you can't pattern match on it
18:12:59 <kallisti> IIRC, now that Eq isn't needed for Num instances, I think pattern matching with numeric literals forces an Eq constraint.
18:13:01 <illissius> could make rules for >>= but I assume that'll get inlined away and it won't work
18:13:20 <mdmkolbe> parcs`: actually you can pattern match against 4
18:13:27 <kallisti> parcs`: you can, unless you mean something very specific by pattern match
18:13:36 <kallisti> > case 4 of 4 -> True
18:13:37 <lambdabot>   True
18:14:05 <illissius> @unpl fmap fmap fmap
18:14:05 <lambdabot> fmap fmap fmap
18:14:08 <illissius> k.
18:14:29 <fuchsto> Hm, to export fields of a record visibly, i use    module Foo ( MyRecord(field_a, field_b) )  right?
18:14:45 <kallisti> yes, or MyRecord(..) for all of the fields.
18:14:49 <flazz> are thunks only used to represent unevaluated applications? you wouldnt have a thunk for a simple value would you?
18:14:55 <kallisti> the same applies with typeclasses and typeclass methods
18:15:04 <kallisti> Eq((==), (/=))
18:15:09 <kallisti> or just Eq(..)
18:15:27 <fuchsto> kallisti: Fine, thanks
18:15:50 <illissius> flazz: yes, basically
18:15:54 <kallisti> flazz: a simple value is in what's known as normal form.
18:16:05 <kallisti> aka fully evaluated
18:16:32 <flazz> and method dispatch is determined at compile time?
18:16:42 <kallisti> for typeclasses? some times.
18:16:46 <kallisti> sometimes it's not.
18:16:56 <kallisti> also depends on your optimization flag, I believe.
18:17:22 <mdmkolbe> flazz: keep in mind that even a simple value results in something like "4" might have come from a complex expression like "3+1"
18:17:29 <kallisti> oh, wait. "determined".
18:17:40 <flazz> kallisti: yes
18:18:08 <kallisti> flazz: well, a polymorphic constraint must always be unambiguous at compile-time, yes (except where defaulting rules apply, such as with Integer for Num and Double for Floating)
18:18:26 <kallisti> I was thinking in terms of how method dispatch is implemented.
18:18:28 <startling> hi, i'm using heist. "state <- loadTemplates "templates" defaultHeistState" gets me " Ambiguous type variable `m0' in the constraints ... arising from a use of `defaultHeistState'". I'm not sure what else to do -- any ideas?
18:18:38 <flazz> is that a reason that the type system isn't turing complete?
18:19:07 <mdmkolbe> flazz: If you are talking about type classes, then dispatch is determined dynamically, but if the compiler can optimize it and figure out exact what instance is needed, it might be done statically (But to double check, remember that this is type classes not ordinary functions or an OOP notion of methods)
18:19:31 <flazz> because if it were turing complete you could make it halt right?
18:19:42 <JEntrep> I hear Haskell is difficult to efficienize with large array operations? True?
18:19:56 <startling> JEntrep, not if you use mutable arrays
18:20:00 <illissius> flazz: you could make it *not* halt :)
18:20:09 <flazz> illissius: true
18:20:19 <illissius> flazz: you can do that with UndecidableInstances
18:20:28 <illissius> (I'm not sure whether that corresponds to turing-completeness)
18:20:48 <startling> JEntrep, the problem is that functions "modifying" immutable arrays actually return a new array, so you're making new arrays all the time
18:20:52 <flazz> so polymorphic constraint is proved at compile time but actual dispatch is done dynamically?
18:21:01 <mdmkolbe> flazz: yes
18:21:09 <startling> JEntrep, DiffArray is one attempt to fix this, but I've read that it's not as efficient as it could be
18:21:22 <JEntrep> startling, ooohhhh. Okay well I still have to look into mutable arrays then.
18:21:31 <illissius> flazz: anyway, I'm not sure what you're asking, but this may or may not be relevant: http://stackoverflow.com/questions/10534744
18:21:33 <c_wraith> DiffArray kind of went away, due to *how* badly it performed
18:21:43 <flazz> concluding about thunks, they are not partially applied functions although they could evaluate to a partially applied function
18:21:49 <parcs`> kallisti, mdmkolbe pattern matching on integer literals uses the underlying eq instance which is not really pattern matching
18:22:01 <kallisti> parcs`: right. I suspected that's what you meant
18:22:18 <JEntrep> Is this them startling http://www.haskell.org/ghc/docs/4.08/set/sec-marray.html ?
18:22:20 <parcs`> i suspected you knew what i meant :P but perhaps mdmkolbe didnt
18:22:27 <kallisti> well, when == corresponds to structural equality, you could argument that == is a kind of pattern matching operator. :P
18:22:31 <kallisti> *argue
18:22:45 <illissius> also, immutable arrays *can* be made efficient with crazy stream fusion magic, see the 'vector' package.
18:23:12 <startling> JEntrep: things to google for are STArray and IOArray
18:23:46 <illissius> array is more or less deprecated in favor of http://hackage.haskell.org/package/vector
18:24:14 <startling> JEntrep: MArray is a typeclass for mutable arrays. STArray and IOArray are instances of MArray
18:24:19 <startling> (iirc)
18:24:46 <JEntrep> startling, Thanks! :D
18:24:55 <startling> illissius: interesting
18:26:28 * applicative wonders how JEntrep happened on the docs for ghc-4.0.8
18:27:03 * JEntrep wonders .. huh?
18:27:31 <applicative> The link was just from a surprisingly old version, thats all
18:27:48 <kallisti> applicative: google has a bad habit of giving me outdated Haskell docs.
18:27:58 <startling> applicative: google doesn't know versions
18:28:02 <applicative> July 2000
18:28:10 <mparodi> is there a function (called something like mapUntil) to apply f to a list until the first element is changed?
18:28:10 <illissius> yeah google tends to do that
18:28:28 <kallisti> mparodi: you can just map and then call takeWhile
18:28:43 <applicative> JEntrep: here's a not bad tutorial on the vector library http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
18:28:49 <kallisti> > takeWhile (<500) . map (2^) $ [1..] -- mparodi
18:28:51 <lambdabot>   [2,4,8,16,32,64,128,256]
18:28:54 <illissius> @hoogle ([a] -> [a]) -> (a -> Bool) -> [a] -> [a]
18:28:55 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (forall e. Data e => e -> e) -> (forall f. Data f => t f -> t f) -> d -> d
18:29:13 <illissius> @hoogle ([a] -> [a]) -> (a -> a -> Bool) -> [a] -> [a]
18:29:14 <lambdabot> No results found
18:29:16 <mparodi> kallisti, that's now what I want. let me give you an example
18:29:29 <kallisti> oh until its changed.
18:29:40 <illissius> @hoogle Eq a => ([a] -> [a]) -> [a] -> [a]
18:29:41 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (forall e. Data e => e -> e) -> (forall f. Data f => t f -> t f) -> d -> d
18:29:48 <illissius> ok, doesn't seem like it
18:29:51 <mparodi> for example, mapUntil f [1,2,3], where f keep unchanged the 1 and sum 1 to 2 or 3. it has to return [1,3,3]
18:30:06 <mparodi> since it's not applied to the last element because it changes the element 2
18:30:16 <kallisti> oh I see
18:30:31 <kallisti> nothing that I know of. should be trivial to write recursively though.
18:31:08 <mparodi> yes, but I wanted to be sure it doesn't exist
18:31:19 <JEntrep> thanks applicative does the Vector lib help you deal with large array efficiency problems?
18:31:27 <kallisti> I don't think it's a common use-case for lists.
18:32:18 <applicative> JEntrep yes, though maybe your idea of a large array is unknown to me
18:32:41 <JEntrep> applicative, erm ... about 10 million entries.
18:33:09 <mparodi> > let mapUntil f [] = []; mapUntil f (l:ls) | e == l = e : ls | otherwise = e : mapUntil f ls where e = (f l)
18:33:10 <lambdabot>   not an expression: `let mapUntil f [] = []; mapUntil f (l:ls) | e == l = e ...
18:33:12 <mparodi> this should work
18:33:50 <kallisti> mparodi: yes it should
18:33:54 <mparodi> whoops, f l, without ( )
18:34:42 <kallisti> not sure if mapUntil is the best name for that function, but I can't think of a better one.
18:34:55 <kallisti> changeOne perhaps
18:35:04 <mparodi> hehe, yes
18:35:52 <mparodi> actually it is e /= l, not e == l
18:37:55 <applicative> JEntrep: it didnt seem to have difficulty with a trivial sum of 10000000 entries
18:38:14 <JEntrep> Ok sounds good
18:38:58 <applicative> in the tutorial one example is "For example, to generate 100 million random Doubles and sum them:"
18:39:27 <orzo> > let x = x in x
18:39:31 <lambdabot>   mueval-core: Time limit exceeded
18:39:59 <JEntrep> What about handling incoming arrays, like if it was fed data at a particuliar rate?
18:41:15 <applicative> From a file, that is easy; maybe you are thinking of something more complicated
18:42:17 <navaati> :t fix
18:42:18 <lambdabot> forall a. (a -> a) -> a
18:42:35 <mparodi> @hoogle [a] -> Maybe a
18:42:35 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
18:42:35 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
18:42:35 <lambdabot> Prelude head :: [a] -> a
18:42:40 <navaati> > fix (1:)
18:42:41 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:43:25 <kallisti> > fix (True&&)
18:43:29 <lambdabot>   mueval-core: Time limit exceeded
18:43:30 <kallisti> > fix (False&&)
18:43:31 <lambdabot>   False
18:44:14 <otters> > fix ((1 :) . (1 :) . ap (zipWith (+)) tail)
18:44:16 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:44:58 <navaati> > fix f where { f [] = [1] ; f (h:t) = (h+1:t)
18:44:59 <lambdabot>   <no location info>: parse error on input `where'
18:45:03 <navaati> > fix f where { f [] = [1] ; f (h:t) = (h+1:t) }
18:45:03 <lambdabot>   <no location info>: parse error on input `where'
18:45:12 <navaati> > fix f { where f [] = [1] ; f (h:t) = (h+1:t) }
18:45:13 <lambdabot>   <no location info>: parse error on input `where'
18:45:22 <kallisti> that's not how where works
18:45:31 <navaati> argh, how the heck does explicit layout work ?
18:45:45 <navaati> > let { f [] = [1] ; f (h:t) = (h+1:t) } in fix f
18:45:48 <lambdabot>   mueval-core: Time limit exceeded
18:46:20 <kallisti> navaati: where isn't an expression. it's a declaration that you can attach to certain syntactic constructs
18:46:52 <navaati> ah, it was not the layout syntax that was wrong, ok
18:46:57 <illissius> > let mapUntil f = mapAccumL (\b x -> let (b', x') = (b || x' /= x, if b then x else (f x)) in (b', x')) False
18:46:59 <lambdabot>   not an expression: `let mapUntil f = mapAccumL (\b x -> let (b', x') = (b |...
18:47:10 <illissius> let mapUntil f = mapAccumL (\b x -> let (b', x') = (b || x' /= x, if b then x else (f x)) in (b', x')) False
18:47:50 <navaati> > fix (0*)
18:47:54 <lambdabot>   mueval-core: Time limit exceeded
18:48:03 <kallisti> navaati: fix tells if you a function is strict in its argument.
18:48:09 <kallisti> if it's strict, it'll diverge.
18:48:13 <navaati> no short-circuit on multiplicative absorbtion ?
18:48:37 <kallisti> no. arithmetic on numeric "primitives" is strict.
18:48:59 <navaati> yeah, while Bool, being a more classical datatype, is lazy
18:49:12 * navaati *nod*
18:49:32 <kallisti> adding explicit checks to artihmetic would add some noticeable overhead, I think.
18:49:49 <illissius> > let mapUntil f = Data.List.mapAccumL (\b x -> let (b', x') = (b || x' /= x, if b then x else (f x)) in (b', x')) False
18:49:50 <navaati> sure
18:49:50 <lambdabot>   not an expression: `let mapUntil f = Data.List.mapAccumL (\b x -> let (b', ...
18:49:53 <illissius> bah
18:50:03 <illissius> someone tell me how to make lambdabot work :\
18:50:21 <shachaf> By typing in expressions.
18:50:52 <navaati> well, actually there could be pure haskell (not machine-backed) numbers (maybe such a lib already exist actually), but would it be really useful… not sure
18:51:07 * hackagebot biostockholm 0.3.1 - Parsing and rendering of Stockholm files (used by Pfam, Rfam and Infernal).  http://hackage.haskell.org/package/biostockholm-0.3.1 (FelipeLessa)
18:51:07 <kallisti> navaati: yes those exist
18:51:13 <geekosaur> illissius, looks like mismatched parentheses to me
18:51:23 <JEntrep> applicative, real time feed? Like from Sensory input data? Like Video i.e. several images per second?
18:51:29 <kallisti> navaati: check out Data.Num.CReal and also peano natural number types (I don't know of a module off hand)
18:51:29 <illissius> geekosaur: ghci didn't complain
18:51:45 <geekosaur> oh wait, I see it; missed the nested let
18:51:51 <navaati> illissius: a "let" without an "in" doesn't have sense in lambdabot : lambdabot is *not* ghci
18:51:57 <kallisti> navaati: data Natural = Z | S Natural
18:52:10 <otters> does Z mean Zero
18:52:13 <kallisti> yes
18:52:15 <navaati> yep
18:52:15 <geekosaur> right, so the in I saw was for the intter let, and the outer one is not a valid expression
18:52:16 <illissius> people were defining functions in lambdabot earlier :\ how they do that magic?
18:52:18 <otters> neat
18:52:23 <otters> so natural numbers
18:52:29 <geekosaur> there is a special @let construct for lambdabot
18:52:37 <illissius> ah, ok, that's what I was missing
18:52:39 <cryptic> is haskell a good choice for parsing a DTD, creating a series of types corresponding to the element declarations, and creating objects from those types based on input XML files?
18:52:52 <navaati> floating point may be a bit more difficult to define… but this kind of discussion would quickly belong to agda :)
18:53:01 <kallisti> otters: http://en.wikipedia.org/wiki/Peano_axioms
18:53:23 <kallisti> navaati: CReal defines the computable reals as functions
18:53:32 <megajosh2> cryptic: If by that you mean parsing then yessir
18:53:33 <kallisti> > showCReal 42 pi
18:53:34 <lambdabot>   "3.141592653589793238462643383279502884197169"
18:53:39 <illissius> @let mapUntil f = Data.List.mapAccumL (\b x -> let (b', x') = (b || x' /= x, if b then x else (f x)) in (b', x')) False
18:53:40 <lambdabot>  Defined.
18:53:44 <applicative> JEntrep: that I wouldn't know about.  I know that with the associate repa library such things have been done; but I have only made trivial experiments with it; it's still a bit experimental.  See the demo http://repa.ouroborus.net/
18:53:55 <illissius> > mapUntil (*2) [0,0,0,1,2,3]
18:53:57 <lambdabot>   (True,[0,0,0,2,2,3])
18:54:07 <navaati> (for example, i have recently discovered that there is a subset of reals called computable reals… i guess it's only possible to define them, and not all of the reals, in agda)
18:54:11 <illissius> oh, right, missed a snd.
18:54:13 <otters> I see
18:54:23 <otters> are there practical uses for type-level natural numbers
18:54:26 <cryptic> I'd venture to guess that, at a high level, you'd have an element factory for each DTD element declaration, which are all mixins for the root DTD element type. does that sound reasonable, or am I just talking nonsense?
18:54:39 <kallisti> otters: yes. you could encode the length of arrays within their type, for example
18:54:48 <otters> nice
18:54:49 <navaati> otters: yes, for exemple the lenght of a type-level list
18:54:51 <otters> but wouldn't that just be a tuple?
18:54:55 <megajosh2> otters: ohai incluye
18:55:00 <otters> hi frogs
18:55:04 <kallisti> otters: not quite.
18:55:07 <mparodi> is there a function to delete the first element so that f is true? del (==2) [1,2,3,2,3,2]  => [1,3,2,3,2]
18:55:09 <otters> I see
18:55:10 <kallisti> a tuple is a bit less flexible
18:55:14 <kallisti> and requires a lot more hard-coding
18:55:14 <megajosh2> Frogs?
18:55:24 <otters> megajosh2: it's just something I call people
18:55:27 <megajosh2> lol
18:55:27 <kallisti> also it would be heterogenous, which an array would not be.
18:55:33 <otters> oh, okay
18:55:42 <kallisti> otters: so for example you could concatenate 2 arrays together and the length would be known at compile-time
18:55:48 <illissius> otters: tuples are heterogenous, and the various tuple sizes have *no* relation to each other besides syntax
18:55:52 <otters> right
18:55:55 <mparodi> it's not like filter because filter (/=2) [1,2,3,2,3,2]  => [1,3,3]
18:55:58 <mauke> @hoogle (a -> Bool) -> [a] -> [a]
18:55:59 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
18:55:59 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
18:55:59 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
18:56:07 * hackagebot hierarchical-clustering 0.4.3 - Fast algorithms for single, average/UPGMA and complete linkage clustering.  http://hackage.haskell.org/package/hierarchical-clustering-0.4.3 (FelipeLessa)
18:56:10 <otters> @hoogle delete
18:56:11 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
18:56:11 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
18:56:11 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
18:56:19 <otters> probably something like #2 is what you want
18:56:35 <kallisti> :t break
18:56:36 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:56:42 <kallisti> > break (==2) [1,2,3,4,2,3,4]
18:56:43 <lambdabot>   ([1],[2,3,4,2,3,4])
18:56:45 <navaati> actually i'm thinking more and more that tuples are bad and should die… they are so not flexible (<- how do i say that in proper english ?)
18:56:56 <mapreduce> inflexible
18:57:01 <mauke> :t splitAt
18:57:03 <lambdabot> forall a. Int -> [a] -> ([a], [a])
18:57:12 <otters> navaati: they are inflexible
18:57:22 <otters> I guess; you got pretty close
18:57:26 <JEntrep> okay well thanks for the info applicative
18:57:37 <navaati> mapreduce: oh, in that particular case it works… but what if the corresponding negative adjective does not exist ?
18:57:49 <otters> then "not x" is fine
18:57:52 <mparodi> I need to do something like: delete (_,2) [(1,1), (1,2), (2,1), (2,2)]
18:58:00 <otters> or "non-x"
18:58:01 <navaati> 'k, thanks
18:58:11 <mparodi> that should return [(1,1), (2,1), (2,2)]
18:58:15 <applicative> JEntrep sure, I think at other times you might bump into someone with  better  knowledge of your sort of domain
18:58:20 <navaati> #haskell : learning language
18:58:23 <otters> mparodi: delete ((==2) . snd)
18:58:39 <mauke> otters: type error
18:58:44 <otters> really?
18:58:59 <MostAwesomeDude> :t delete
18:58:59 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
18:59:00 <mauke> try it
18:59:01 <otters> oh man, you need deleteBy
18:59:02 <flazz> in "y = ($!) (+) 1 2" is y 3 from that point on or some thunk that will strictly evaluate 1 + 2 ?
18:59:03 <otters> my bad
18:59:08 <JEntrep> applicative, oh know any names off the top of your head?
18:59:24 * kallisti recommends break
19:00:00 <JEntrep> Look for someone named break?
19:00:02 <mauke> flazz: it's a thunk and I don't know what you mean by "strictly evaluate"
19:00:03 <kallisti> > break ((==2) . snd) [(1,3), (1,4), (1,5), (1,2)]
19:00:04 <navaati> flazz: a thunk, i think : ($!) makes a function strict, that is its arguments will be evaluated
19:00:05 <lambdabot>   ([(1,3),(1,4),(1,5)],[(1,2)])
19:00:11 <JEntrep> oh nm lol
19:00:23 <otters> yeah, just listen to kallisti
19:00:25 <otters> I'm a disaster
19:00:34 <mapreduce> navaati: they are not flexible.  'so not' sounds so not good.
19:01:31 <navaati> mapreduce: ah, that's what i was wondering…
19:01:37 <mparodi> err, I'm sorry. I'm mixing things up... the behaviors is:    del index list = take (index-1) list ++ drop index list
19:02:01 <applicative> JEntrep: I'm not sure
19:02:09 <mauke> > splitAt 0 "abc"
19:02:10 <lambdabot>   ("","abc")
19:02:13 <mparodi> > let del index list = take (index-1) list ++ drop index list in del 3 [(1,1), (1,2), (2,1), (2,2)]
19:02:15 <lambdabot>   [(1,1),(1,2),(2,2)]
19:02:23 <navaati> anyway, it's getting pretty late here, goodbye folks
19:02:29 <mauke> > fmap (drop 1) . splitAt 0 $ "abc"
19:02:31 <lambdabot>   ("","bc")
19:02:35 <mparodi> that works but I'm afraid it's not a good idea due to how drop is implemented
19:02:37 <mauke> > uncurry (++) . fmap (drop 1) . splitAt 0 $ "abc"
19:02:39 <lambdabot>   "bc"
19:02:44 <mparodi> @src drop
19:02:45 <lambdabot> drop n xs     | n <= 0 =  xs
19:02:45 <lambdabot> drop _ []              =  []
19:02:45 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
19:02:45 <illissius> flazz: y = (+) $! 1 2 (which is equivalent to what you wrote) will apply (+) strictly to 1 and lazily to 2. my brain is currently fried and I can't figure it if that makes any practical difference vs. not using $!, in that situation.
19:02:55 <mauke> illissius: that's not equivalent
19:03:48 <mparodi> > del index list = [elem | (i, elem) <- zip [1..] list, i /= index] in  del 3 [(1,1), (1,2), (2,1), (2,2)]
19:03:49 <illissius> oh, whatevs, sorry, brain is fried.
19:03:49 <lambdabot>   <no location info>: parse error on input `='
19:03:56 <mparodi> > let del index list = [elem | (i, elem) <- zip [1..] list, i /= index] in  del 3 [(1,1), (1,2), (2,1), (2,2)]
19:03:57 * illissius -> sleep(dunno);
19:03:57 <lambdabot>   [(1,1),(1,2),(2,2)]
19:04:05 <mparodi> that's better
19:04:14 <mauke> mparodi: that looks a lot more inefficient than drop
19:04:27 <mparodi> it's not -- I believe
19:04:35 <mauke> why do you believe so?
19:04:38 <applicative> JEntrop here is an example of a complicated enterprise https://github.com/AlbertoRuiz/easyVision
19:04:42 <mparodi> take (index-1) list ++ drop index list
19:05:03 <mparodi> ahm, ok, I'm not sure
19:05:23 <mauke> in that expression, drop your least problem
19:05:26 <mauke> heh
19:05:28 <mauke> drop is*
19:05:45 <mauke> drop just walks down the list
19:05:52 <mparodi> but take too
19:05:57 <mparodi> that's why I supposed it wasn't good
19:05:58 <mauke> no, take makes copies
19:06:04 <mparodi> @src take
19:06:04 <lambdabot> take n _      | n <= 0 =  []
19:06:05 <lambdabot> take _ []              =  []
19:06:05 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
19:06:26 <mauke> also, did you see my splitAt version?
19:06:43 <mparodi> <mauke> > uncurry (++) . fmap (drop 1) . splitAt 0 $ "abc"
19:06:43 <mparodi> ?
19:06:46 <mauke> yeah
19:06:54 <mparodi> does it work? lol
19:07:02 <mauke> ...
19:07:09 <mparodi> it's no intuitive
19:07:11 <mparodi> let me see
19:07:22 <megajosh2> > uncurry (++) . fmap (drop 1) . splitAt 4 "0123456"
19:07:23 <otters> @src fmap (,)
19:07:23 <lambdabot> Source not found. Where did you learn to type?
19:07:24 <lambdabot>   Couldn't match expected type `([a], [a])'
19:07:24 <lambdabot>         against inferred type `[G...
19:07:33 <megajosh2> > uncurry (++) . fmap (drop 1) . splitAt 4 # "0123456"
19:07:34 <lambdabot>   Not in scope: `#'
19:07:36 <megajosh2> > uncurry (++) . fmap (drop 1) . splitAt 4 $ "0123456"
19:07:39 <lambdabot>   "012356"
19:07:39 <megajosh2> Whoopsie
19:08:05 <mparodi> @type fmap
19:08:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:08:31 <kallisti> there's an instance of Functor for (a,)
19:08:31 <mauke> f = (,) e
19:08:33 <heatsink> > fmap f (x, y)
19:08:34 <lambdabot>   Ambiguous type variable `b' in the constraints:
19:08:34 <lambdabot>    `GHC.Show.Show b'
19:08:34 <lambdabot>      a...
19:08:51 <kallisti> > fmap f (x, y) :: (Expr, Expr)
19:08:53 <lambdabot>   (x,f y)
19:09:07 <megajosh2> Never seen that before ^
19:09:22 <heatsink> @t x
19:09:23 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:09:28 <heatsink> @type x
19:09:29 <lambdabot> Expr
19:09:37 <heatsink> @type f
19:09:38 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
19:09:46 <heatsink> @type y
19:09:48 <lambdabot> Expr
19:09:58 <otters> @type f 1
19:09:59 <lambdabot> forall t t1. (Num t, SimpleReflect.FromExpr (t -> t1)) => t1
19:10:00 <megajosh2> Strange... but clearly useful
19:10:01 * heatsink doesn't know why it needed a type signature.
19:10:03 <otters> > f 1
19:10:05 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:10:05 <lambdabot>    `SimpleReflect.FromExpr ...
19:10:13 <mparodi> this function seems common enough to be built in
19:10:18 <mauke> heatsink: because the result type is ambiguous
19:10:52 <mauke> > iterate f x
19:10:54 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
19:11:11 <mparodi> @hoogle Int -> [a] -> [a]
19:11:11 <lambdabot> Prelude drop :: Int -> [a] -> [a]
19:11:12 <lambdabot> Data.List drop :: Int -> [a] -> [a]
19:11:12 <lambdabot> Prelude take :: Int -> [a] -> [a]
19:11:19 <mparodi> @hoogle+
19:11:19 <lambdabot> Data.List take :: Int -> [a] -> [a]
19:11:20 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
19:11:20 <lambdabot> Prelude replicate :: Int -> a -> [a]
19:11:30 <mauke> > [x, f a, f a b, f a b c, f a b c d]
19:11:31 <mparodi> @hoogle+
19:11:32 <lambdabot>   [x,f a,f a b,f a b c,f a b c d]
19:11:32 <lambdabot> Data.List replicate :: Int -> a -> [a]
19:11:32 <lambdabot> Prelude (!!) :: [a] -> Int -> a
19:11:32 <lambdabot> Data.List (!!) :: [a] -> Int -> a
19:11:36 <mparodi> it's not :|
19:11:38 <heatsink> So... I guess the function instance of FromExpr is (FromExpr a, FromExpr b) => FromExpr (a -> b)
19:11:47 <heatsink> that would make hte result type ambiguous
19:12:11 <otters> > fix f
19:12:12 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:12:12 <lambdabot>    `GHC.Show.Show a'
19:12:12 <lambdabot>      a...
19:12:36 <megajosh2> > fix f :: Expr
19:12:37 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
19:12:51 <megajosh2> ...only in Haskell
19:12:58 <kallisti> @instances FromExpr
19:12:59 <lambdabot> Couldn't find class `FromExpr'. Try @instances-importing
19:13:16 <kallisti> @instances-importing SimpleReflect FromExpr
19:13:17 <lambdabot> Couldn't find class `FromExpr'. Try @instances-importing
19:13:49 * heatsink found http://hackage.haskell.org/packages/archive/simple-reflect/0.2/doc/html/Debug-SimpleReflect-Expr.html
19:13:54 <otters> hoogle doesn't know what FromExpr is
19:13:55 <kallisti> (Show a, FromExpr b) => FromExpr (a -> b)
19:14:20 <kallisti> so f x  has type FromExpr b => b
19:14:25 <kallisti> not Expr
19:14:39 <heatsink> I see
19:14:48 <kallisti> though Expr is an instance of FromExpr
19:14:54 <mparodi> @src (!!)
19:14:55 <lambdabot> xs     !! n | n < 0 = undefined
19:14:55 <lambdabot> []     !! _         = undefined
19:14:55 <lambdabot> (x:_)  !! 0         = x
19:14:55 <lambdabot> (_:xs) !! n         = xs !! (n-1)
19:15:24 <otters> undefined, ewww
19:15:30 <heatsink> Why undefined and not error "(!!)"
19:15:47 <kallisti> > [1,2,3] !! (-1)
19:15:48 <lambdabot>   *Exception: Prelude.(!!): negative index
19:15:50 <kallisti> because lambdabot is a liar
19:15:59 <heatsink> @slap lambdabot
19:16:00 * lambdabot will count to five...
19:17:24 <megajosh2> > foldr1 (-) [1..5] :: Expr
19:17:25 <lambdabot>   1 - (2 - (3 - (4 - 5)))
19:17:28 <megajosh2> heh
19:17:43 <megajosh2> Okay I've toyed enough
19:22:09 <Lemon> hey
19:22:32 <Lemon> the constrainkinds extension should allow me to use type families to construct constraints, right?
19:23:12 <Lemon> how come when I write type family Foo a :: Constraint, it tells me that it can't fnd a data or type constructor called `Constraint'?
19:31:55 <nand`> just a random guess: the extension is called ConstraintKinds, maybe this is the issue?
19:32:14 <Lemon> no, it turns out I have to import GHC.Exts
19:32:27 <Lemon> which has `data Constraint'
19:33:34 <nand`> I see
19:33:40 * nand` wonders why http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/constraint-kind.html doesn't mention it
19:44:02 <Lemon> HA HA OH WOW
19:44:14 <Lemon> I got the type checker to loop forever
19:44:43 <Lemon> no, wait
19:44:45 <Lemon> not forever
19:45:05 <Lemon> it's printing out a bunch of error messages that I can't read because the nesting is like hundreds of levels deep
19:45:55 <Lemon> I need some sort of type level 'if'
19:47:04 <nand`> as long as you don't try type checking fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
19:47:31 <barrucadu> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
19:47:47 <lambdabot> thread killed
19:47:52 <fuchsto> Assuming i have an IORef on a record. Can i change a single field in this record?
19:47:53 <Lemon> lol
19:47:53 <barrucadu> Aww
19:48:06 <mauke> LoRez: are you here because of AntiSpamMeta?
19:48:12 <nand`> barrucadu: I did it once, it consumed 80% of my system memory
19:48:21 <mauke> (because if so, that was a false alert just now)
19:48:54 <fuchsto> so as in    rec <- get myRecord; rec $=! newRecord    <-- this would overwrite the whole record. Can i update a single field of the record, too?
19:49:19 <LoRez> mauke: no.
19:49:28 <fuchsto> (meh, forget about the rec <- get part(
19:49:30 <mauke> well, n/m then
19:50:45 <applicative> @type modifyIORef
19:50:46 <lambdabot> Not in scope: `modifyIORef'
19:51:21 <freakhill> pl /x f -> f x x
19:51:43 <freakhill> pl ¥x f -> f x x
19:51:53 <mauke> japanese?
19:52:01 <freakhill> yes sorry
19:52:04 <mauke> :-D
19:52:08 <mauke> @pl \x f -> f x x
19:52:09 <lambdabot> flip =<< flip id
19:52:18 <freakhill> oh thank you!
19:52:40 <mauke> 1) you need a '@' for bot commands, and 2) ¥ is not the same as \
19:52:48 <mauke> (at least outside of japan)
19:52:58 <freakhill> ahah thank you ^^!
19:53:42 <freakhill> i am beginning so i don't know the ways yet
19:54:13 <mauke> feel free to play around and try stuff
19:54:50 <applicative> fuchsto: what's wrong with do ref <- newIORef (A a b c}; modifyIORef ref (\x -> x{a = 2}) or whatever
19:55:57 <nand`> :t flip joinx
19:55:58 <lambdabot> Not in scope: `joinx'
19:56:00 <nand`> err
19:56:02 <nand`> :t flip join
19:56:03 <lambdabot> forall a b. a -> (a -> a -> b) -> b
19:56:11 <freakhill> :t =<<
19:56:11 <lambdabot> parse error on input `=<<'
19:56:29 <mauke> :t (=<<)
19:56:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:56:51 <freakhill> ah thx!
19:57:56 <freakhill> why does lambdabot gives something different than ghci?
19:58:15 <nand`> freakhill: do you mean the forall a (m :: * -> *) b. stuff?
19:58:22 <freakhill> yes
19:58:36 <freakhill> nand`: yes
19:58:50 <nand`> I'm not quite sure which extension that is, but those are implicit quantifiers that are present on every version of the function; ghci just doesn't show them by default
19:59:03 <freakhill> oh ok thank you!
19:59:18 <nand`> it's basically a polymorphic type that works “for all a, m and b”
19:59:35 <nand`> the (m :: * -> *) stuff is just giving a kind signature
20:00:11 <aristid> @remember Philipp "While in Python every problem can be solved with a big enough Hashtable, in Haskell, every problem can be solved with an additional type parameter."
20:00:11 <lambdabot> I will never forget.
20:01:16 <freakhill> thanks for the info
20:02:24 <applicative> what version of ghc is lambabot using?  I seem to remember a ghci giving those long types
20:05:54 <freakhill> @pl \x y z -> f x x y z
20:05:54 <lambdabot> join f
20:06:03 <freakhill> @pl \f x y z -> f x x y z
20:06:04 <lambdabot> join
20:06:26 <freakhill> :t join
20:06:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:06:49 <Lemon> so how do I implement typecase in Haskell?
20:07:10 <Lemon> no, wait
20:07:13 <Lemon> that's not really what I want
20:07:22 <Lemon> I want closed type-level functions
20:07:32 <Lemon> unlike type families, which are open
20:07:33 <nand`> freakhill: \f x y z -> f x x y z  eta-reduces to \f x -> f x x, aka join f
20:08:18 <freakhill> indeed!
20:13:15 <freakhill> @pl ﻿\f x y z -> f z z x y
20:13:15 <lambdabot> (line 1, column 2):
20:13:15 <lambdabot> unexpected "\187"
20:13:15 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
20:13:44 <rwbarton> Lemon: look into the recent DataKinds extension, perhaps
20:14:04 <rwbarton> if you want a type-level function on a kind other than *
20:14:09 <freakhill> @pl \f x y z -> f z z x y
20:14:09 <lambdabot> (flip .) . flip . join
20:14:34 <Lemon> rwbarton, and those are guaranteed to be closed?
20:15:01 <Lemon> well
20:15:04 <rwbarton> well their inhabitants correspond to the values of a data type
20:15:08 <Lemon> let me describe the problem I'm having
20:15:14 <rwbarton> okay
20:15:38 <Lemon> I have a few functions that are polymorphic in a way that they require constraints of the form
20:15:58 <Lemon> (C a, C (F a), C (F (F a), ...)
20:16:24 <Lemon> and there is one specific `a' that terminates the recursion
20:16:35 <Lemon> let's say it's ()
20:17:31 <Lemon> so I want a type level function with the two cases {G Identity = C Identity; G a = (C a, G (F a))}
20:17:35 <Lemon> wait, no
20:17:45 <Lemon> so I want a type level function with the two cases {G () = C (); G a = (C a, G (F a))}
20:17:54 <Lemon> yeah, disregard that Identity thing
20:18:05 <rwbarton> C is a class?
20:18:10 <Lemon> yes, C is a class
20:18:18 <Lemon> and (a :: *)
20:18:26 <Lemon> to be instantiated at the use of the functions
20:19:15 <Lemon> I tried writing the type family like the above, but GHC won't let the overlap happen
20:19:22 <rwbarton> this sounds like it involves overlapping, yes
20:19:29 <rwbarton> I mean, () obviously overlaps with a
20:19:46 <Lemon> without the terminating case, it just loops forever and GHC runs out of reduction stack when typechecking
20:20:12 <Lemon> so I'm kind of bummed right now because I can't figure out how to do this
20:20:31 <rwbarton> I feel like you can't really intend to apply this to arbitrary types a, is that right?
20:20:47 <Lemon> rwbarton, well
20:20:54 <rwbarton> Because I can't imagine how you would know that F (F (... F a)) n times will be (), for some n, for every a
20:21:13 * hackagebot uuid 1.2.6 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.6 (AntoineLatter)
20:21:36 <Lemon> okay, I can live with the constraint that the type family only applies to a specific set of types
20:22:18 <Lemon> but this causes another problem
20:22:49 <rwbarton> if you can describe that set of types as the image of a type function whose input is one of these DataKinds, perhaps you have a chance
20:22:50 <Lemon> if I restrict the type family like so: {G () = C (); G A = (C A, G (F A))} where `data A' is my recursive case
20:23:26 <Lemon> the type checker can't deduce C (F A) for arbitrary types `a'
20:24:13 <Lemon> rwbarton, you mean I should instead of universally quantifying over something of kind *, and instead quantify over a closed kind and generate the concrete type via a type family?
20:24:28 <rwbarton> that is what I was suggesting, yeah
20:24:46 <Lemon> I was thinking of that but I'm not sure whether GHC is smart enough to allow it
20:24:49 <rwbarton> make G quantify over that closed kind also
20:24:52 <Lemon> but I'll try anyway
20:24:59 <rwbarton> then you can check whether the input is whatever corresponds to ()
20:25:25 <rwbarton> and you need a version of F that operates on that closed kind representation, as well
20:25:27 <Lemon> wait
20:25:42 <Lemon> forall (t :: MyKind). Foo t --this is allowed, right?
20:25:56 <rwbarton> in what context
20:26:08 <Lemon> myValue :: <the above thing>
20:26:19 <rwbarton> I assume so
20:26:26 <Lemon> okay, enough talk
20:26:30 <Lemon> gonna try this
20:26:32 <rwbarton> good luck :)
20:26:32 <Lemon> and hope for the best
20:29:09 <nand`> Does anybody know if I can bind ∀ to my keyboard using xmodmap? I tried keysym 0x2200 but pressing it does nothing and shows (no name) in xev
20:29:22 <nand`> (asking here because I'm guessing somebody would have tried it)
20:30:48 <Lemon> @hoogle
20:30:48 <lambdabot> No query entered
20:30:49 <lambdabot> Try --help for command line options
20:32:16 <hpaste_> applicative pasted “stupid kinds” at http://hpaste.org/69910
20:32:39 <applicative> Lemon: Here's something trivial thats possible ^^
20:32:48 <hpaste_> Lemon pasted “Does not compile.” at http://hpaste.org/69911
20:33:22 <Lemon> applicative, lol
20:33:32 <applicative> pretty amazing
20:33:43 <Lemon> how come yours works and mine doesn't?
20:34:20 <Lemon> I'm guessing it's the universal quantification
20:37:12 <hpaste_> applicative annotated “Does not compile.” with “Does not compile. (annotation)” at http://hpaste.org/69911#a69912
20:37:27 <applicative> Lemon, this works
20:37:45 <Lemon> brb lunch
20:37:47 <Lemon> thanks, applicative
20:37:57 <applicative> somehow I feel it won't help much....
20:39:51 <rwbarton> that is an interesting question, why Lemon's paste does not compile--I guess there is no mechanism whereby the compiler can do case analysis on n?
20:40:00 <rwbarton> on lines 11-12
20:40:10 <applicative> yeah thats what i was thinking
20:41:05 <tgeeky> actually, I might know this one
20:41:18 <tgeeky> maybe not :O
20:41:20 <mparodi> f = if False then 1
20:41:21 <mparodi>     else if True then 2
20:41:25 <mparodi> what's the problem with that?
20:41:36 <monochrom> missing the final else
20:41:48 <mparodi> is it necessary?
20:41:51 <nand`> yes
20:42:01 <unnali> mparodi: if always has else
20:42:04 <unnali> that's really two 'if's
20:42:12 <unnali> (if False then 1 else (if True then 2 ?????))
20:42:15 <applicative> no if without an else
20:42:17 <unnali> missing 'else' after 2
20:42:27 <shachaf> Clearly the answer is to add an additional "else if False && True then 3", just in case.
20:42:32 <monochrom> imagine in C you wite "false ? 'x' :"
20:42:42 <mparodi> yep, that was the problem. thanks
20:43:03 <unnali> shachaf: +1!
20:43:22 <shachaf> shachaf: -1! Stop confusing people who are asking genuine questions with silliness.
20:43:27 <mparodi> False && True?
20:43:28 <mparodi> what?
20:43:35 <mparodi> >_>
20:43:37 <shachaf> mparodi: Ignore what I said, please. I was overtaken with a demon.
20:43:48 * nand` thought it was funny
20:43:53 <rwbarton> He meant FileNotFound of course.
20:44:03 <nand`> yes
20:44:17 <nand`> Haskell 2012's Prelude: data Bool = True | False | FileNotFound
20:44:36 <nand`> in order to meet the growing demands of tomorrow's programming situations
20:44:38 <rwbarton> Haskell Enterprise Edition
20:44:45 <nand`> and next-generation error handling facilities
20:44:50 <unnali> we can surely organise a cabal to get this into haskell'
20:45:14 <mapreduce> data Bool = True | FalseNotFound
20:45:24 <mapreduce> more efficienter.
20:46:32 <nand`> data Bool = True | FileNotFound -- False is _|_
20:46:41 <unnali> ouch.
20:47:02 <Ralith> but my serialization code requires FileNotFalse
20:47:13 <mapreduce> Our experiments have shown that all Bools in the field are actually True.
20:47:35 <nand`> the ones that aren't, haven't realized yet
20:47:57 <cryptic> what does $$ mean if $ gives precedence to subsequent expressions?
20:48:13 <monochrom> that depends on where $$ comes from
20:48:43 <Enigmagic> monochrom: it's the bling operator
20:48:51 <nand`> no, that's $$$
20:49:12 <Enigmagic> always showing me up
20:49:18 <Enigmagic> just add one more dollar sign
20:49:35 <nand`> ($$$) feels like something taken straight out of Control.Arrow
20:50:28 <nand`> cryptic: to answer: nothing special, just depends on how it was defined. ($) isn't really anything special either, it's just a predefined operator with very low precedence
20:50:35 <Enigmagic> i'm surprised it's not in there
20:50:43 <Enigmagic> :t ($$$)
20:50:44 <lambdabot> Not in scope: `$$$'
20:50:46 <unnali> surely ($$$) is part of Haskell Enterprise Edition …
20:51:07 <Enigmagic> i use Enterprise Haskell 2012.1 (tm)
20:51:13 <monochrom> Haskell Enterprise Edition has all of $, $$, ... up to $$$$$$$$$$
20:51:25 <nand`> unnali: all operators in Haskell Enterprise Edition have been replaced by various overloaded forms of ‘+’ utilizing advanced dynamic typing to Get The Type You Want(tm)
20:51:36 <unnali> monochrom: I thought it was that the Haskell Enterprise Report required implementations to provide up to $20, but implementations were free to implement more than that.
20:51:59 <unnali> sorry, not "free", that would be unenterprise
20:52:01 <cryptic> oh, I imagine ($$) :: a $ b
20:52:03 <monochrom> oh, ok, yeah, up to $$$$$$$$$$$$$$$$$$$$ and could be more
20:52:25 <monochrom> "a $ b" doesn't look like a type
20:52:31 <Enigmagic> $20 aught to be enough for anybody
20:52:43 <Enigmagic> a :$ b is a type
20:53:11 <rwbarton> :t undefined :: a $ b
20:53:11 <lambdabot> forall ($ :: * -> * -> *) a b. ($) a b
20:55:00 <cryptic> in other words, a $$ b c would give b c precedence over a?
20:55:28 <monochrom> there is no standard $$
20:55:56 <cryptic> is it fair to call that one the de facto standard?
20:56:03 <geekosaur> no
20:56:07 <cryptic> ah okay
20:56:13 <geekosaur> $$ means whatever its definer wanted it to mean
20:56:26 <monochrom> there is no de facto standard either
20:56:40 <cryptic> fair enough, thanks
20:58:15 <geekosaur> "$" does have a sort of de facto connotation, but it's not related to precedence; it refers to some form of application.  see <$> in Applicative, for example
20:58:47 <geekosaur> or $! which is a sort of strict application
21:00:09 <cryptic> thanks geekosaur
21:01:19 <nand`> maybe ($$) should make sense as ‘join’, then (double application)
21:01:46 <geekosaur> I think the enumerators family has staked out $$ for something but do not know what they use it for
21:02:26 <geekosaur> (too many of them...)
21:06:16 * hackagebot concrete-relaxng-parser 0.1 - A parser driven by a standard RELAX NG schema with concrete syntax extensions.  http://hackage.haskell.org/package/concrete-relaxng-parser-0.1 (MarioBlazevic)
21:06:58 <Enigmagic> geekosaur: combining the source/sink iteratee/enumerator etc/etc pairs into something that can be executed
21:24:44 <Lemon> rwbarton, applicative
21:24:52 <Lemon> the idea doesn't work
21:25:36 <Lemon> the problem is that type families aren't bijective
21:26:01 <Lemon> the type inference engine can't deduce the Nat used to construct the *
21:26:07 <Lemon> one can only go the other way
21:27:55 <Lemon> it seems that GHC isn't content with just finding one Nat for which the function will typecheck
21:28:16 <Lemon> it must ensure that it's the ONLY Nat that can result in a correct type
21:28:52 <Enigmagic> yeah, you can use data families if you need it to go that way
21:38:47 <startling> is there a function to url-encode a string?
21:39:05 <shachaf> @hoogle urlencode
21:39:05 <lambdabot> Network.HTTP.Base urlEncode :: String -> String
21:39:05 <lambdabot> Network.CGI.Protocol urlEncode :: String -> String
21:39:06 <lambdabot> Network.CGI urlEncode :: String -> String
21:39:06 <startling> (in the haskell platform, I guess)
21:39:13 <startling> sclv: thanks!
21:39:16 <startling> err
21:39:22 <startling> shachaf: thanks!
21:39:58 <freakhill> @hoogle json
21:39:59 <lambdabot> package json
21:39:59 <lambdabot> package json-b
21:39:59 <lambdabot> package json-builder
21:40:12 <Lemon> okay
21:40:14 <Lemon> you know what
21:40:15 <Lemon> fuck it
21:40:34 <Lemon> I'm just gonna hardcode a level and use a preprocessor to deal with varying levels
21:40:52 <Lemon> alternatively: start using Agda
21:41:32 <startling> @hoogle (</>)
21:41:32 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
21:41:33 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
21:42:33 <Lemon> Haskell's type system, even with GHC extensions, isn't powerful enough for what I want to do
21:43:24 <freakhill> hwhat are you trying to do?
21:43:34 <Enigmagic> startling: there is one in http-types as well iirc
21:44:36 <Lemon> freakhill, infer exhaustiveness for a type family that operates on a concrete type
21:44:36 <startling> Enigmagic, a </> or a urlEncode?
21:45:18 <Enigmagic> urlEncode
21:45:22 <startling> why can't I use OverloadedStrings with Text?
21:45:28 <Lemon> wait, there might still be some hope
21:45:53 <Enigmagic> startling: did you import Data.Text?
21:46:06 <startling> oh, i didn't import all of it
21:46:11 <Enigmagic> you just need to import ()
21:46:20 <startling> oh weird
21:46:37 <freakhill> Lemon: i don't understand enough haskell yet to udnerstand what you're trying to do ahah, googling ^^
21:51:14 <startling> yeah, OverloadedStrings definitely doesn't work with Text for me even if I import all of Data.Text
21:52:41 <startling> "x :: Text\nx = "hello"" should work, right?
21:53:33 <Lemon> oh man
21:53:37 <Lemon> I just realized something crazy
21:53:41 <Enigmagic> startling: this is what it looks like on my box http://hpaste.org/69914
21:54:10 <Lemon> I don't have to calculate the entire set of constraints from the instantiated type
21:54:45 <Lemon> if I create a cycle (F () ~ ()) I can manually write a MAXIMUM length for the context
21:54:59 <startling> Enigmagic: yeah, that works
21:55:14 <startling> why doesn't [("title" :: Text, x)] work, then?
21:55:26 <Enigmagic> what error do you get?
21:55:36 <Lemon> by creating an instance C (), making any number of uses of F fewer than the max level still typecheck
21:55:45 <Lemon> (none of you know what I'm talking about, do you)
21:55:48 <startling> Couldn't match expected type `Text' with actual type `[Char]'
21:56:03 <shachaf> startling: The error is probably coming from somewhere else completely.
21:56:23 <startling> shachaf, points to that line number
21:56:29 <shachaf> For example, if you replace the "title" :: Text with T.pack "title", does it still happen?
21:56:36 <Enigmagic> startling: what's x?
21:56:44 <shachaf> Is the actual file that you're using compiled with OverloadedStrings?
21:57:26 <nand`> is there some common type class for a “collection” that can be queried for membership (of equatable elements) or enumerated?
21:58:03 <shachaf> No.
21:58:18 <shachaf> You can use (a -> Bool, [a]) to represent that, though!
21:59:18 <nand`> true, but not if you define additional operations such as union as well
21:59:22 <startling> shachaf, Enigmagic: code and traceback: https://gist.github.com/69502a8fffc7ed03cb83
21:59:30 <nand`> I guess I can just use Set as a common denominator
21:59:41 <mzero> nand`: sounds like you want Data.Set - why need a type class?
21:59:43 <shachaf> startling: Maybe you need to move {-# to the very first line in the file?
22:00:04 <qtplatypus> nand`: Is your intent with using a typeclass so you can abstract over the behavour and allow flexibility with the implimentation?
22:00:05 <startling> shachaf: ...ah
22:00:09 <startling> shachaf: thanks a bunch
22:00:34 <shachaf> GHC probably ought to say something about that.
22:00:37 <shachaf> (Assuming that fixed it.)
22:00:38 <startling> yeah,
22:00:41 <shachaf> You should file a bug!
22:01:25 <shachaf> mzero: Well, you might conceivably want Bag instead of Set.
22:01:44 <shachaf> Or maybe you want "enumerated" to have a specific order.
22:01:53 <mzero> It was mostly to question the need for the type class...
22:01:57 <shachaf> I don't think it's worth a type class, though.
22:02:10 <mzero> all depends - but we don't know enough of the use case to say, really
22:03:11 <unlink> Is there such a function as: Monad m => (a -> m [b]) -> [a] -> m [b]
22:03:45 <unlink> i.e. (fmap concat .) . mapM
22:04:39 <shachaf> Not really, other than that, in the standard library.
22:04:55 <nand`> qtplatypus: the intent is to just allow a common interface to define set-like functions on things that are not sets so you can, say, modify a list with ease without converting it to a set and back when you don't really care
22:05:24 <startling> how do I do that thing where I give lambdabot a type signature and it gives me some functions?
22:05:45 <shachaf> @google how do i search for a haskell function by type signature
22:05:46 <lambdabot> http://www.haskell.org/hoogle/
22:05:47 <lambdabot> Title: Hoogle
22:05:49 <shachaf> Like that. :-)
22:06:02 <startling> heh
22:06:20 <startling> @hoogle String -> ByteString
22:06:20 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
22:06:20 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
22:06:20 <lambdabot> Data.String fromString :: IsString a => String -> a
22:06:25 <mzero> @hoogle (a -> m b) -> [a] -> m [b]
22:06:26 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
22:06:26 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
22:06:26 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
22:06:30 <startling> :/
22:06:59 <startling> oh what, ByteString already IsString?
22:07:03 <mzero> have Chrome set up so hoogle is a search engine! I type    h Int -> String
22:07:17 <unlink> precisely ^
22:07:26 <geekosaur> ByteString was the impetus for IsString
22:07:31 <Enigmagic> startling: it truncates to 8-bit values
22:08:20 <startling> Enigmagic, well, i'm getting a No instance for (Data.String.IsString ByteString)
22:09:11 <shachaf> startling: That's because ByteStrings aren't Strings.
22:09:12 <mzero> :t asAppliedTo
22:09:14 <lambdabot> forall t b. (t -> b) -> t -> t -> b
22:09:20 <mzero> @src asAppliedTo
22:09:20 <lambdabot> Source not found. Sorry.
22:09:22 <shachaf> s/Strings/strings/
22:09:25 <Enigmagic> startling: imported Data.ByteString.Char8 and Data.ByteString.Lazy.Char8 .. ?
22:09:35 <shachaf> You can use .Char8 but you shouldn't. :-(
22:10:15 <unlink> If anybody is up for some code golf, I am having trouble refactoring a script.
22:10:15 <Enigmagic> shachaf: normally i agree but i think it's ok for string literals in code
22:10:37 * nand` uses Char8 whenever dealing with strictly ASCII values
22:10:43 <startling> shachaf: yeah, was gonna make it an IsString myelf and use utf-8
22:10:48 <unlink> http://paste.lisp.org/display/130020
22:10:51 <startling> Enigmagic: ah
22:10:52 <shachaf> Enigmagic: I'd rather someone uses an explicit "pack this and ignore codepoints higher than 127" or a quasiquoter meant for the purpose or something.
22:11:21 <shachaf> IsString instances like this are just terrible.
22:11:38 <startling> shachaf: yeah, utf-8 would make much more sense
22:11:58 <shachaf> startling: Except it doesn't make so much sense as a type class instance.
22:12:05 <startling> rather than "throw out everything higher than 127"
22:12:08 <startling> shachaf: true
22:12:50 <nand`> hpc: I don't seem to be able to tab-complete normal files with your ghc-man-completion
22:13:19 <unlink> in particular, I am wondering how I can avoid using liftIO quite so often.
22:13:33 <mzero> unlink - stop using state
22:13:42 <mzero> the only state here is a list of packages, yes?
22:13:47 <mzero> just pass it explicitly to go
22:14:44 <unlink> and how would I modify it from within the forM?
22:14:50 <nand`> Can Data.Set represent infinite sets?
22:15:11 <mzero> you wouldn't - you'd build up a list of new packages to add to the ignore list
22:15:15 <mzero> and add it on when you recurse
22:15:32 <nand`> actually, that's probably less useful than it seems
22:15:38 <nand`> since you can't reasonably test for non-membership
22:16:10 <mzero> in fact - you don't even need to - you are just partitioniong the list - you've alreday got the packages to remove - just filter out those giving the keepers
22:16:30 <mzero> of, if you want, build up a tuple of lists in the forM (or heck, do it as a fold!)
22:17:17 <mzero> yeah-  state monad is total overkill here
22:18:42 <mzero> you could make your whole forM thing be a foldM over ([],[]) - and the function asks the users and adds it to the first or second
22:19:40 <unlink> mzero: that's a good idea. I'm still getting used to the utility of foldM.
22:19:52 <cryptic> is http://hackage.haskell.org/packages/archive/pkg-list.html down?
22:20:45 <Clint> no
22:23:46 <dmwit> nand`: Data.Set is spine-strict (so can't represent infinite sets).
22:24:00 <dmwit> There are various tricks for implementing infinite sets, if you need that.
22:24:28 <startling> couldn't you just represent a set as a predicate?
22:24:40 <shachaf> Not if you want to enumerate it.
22:24:44 <startling> ah
22:24:50 <dmwit> For example (a -> Bool) is a pretty good type, and you can use the memoization techniques available on Hackage if you want to be able to efficiently update such a thing.
22:24:51 <shachaf> "contravariant sets"
22:25:13 <dmwit> If you want enumeration, you need another type.
22:25:20 <dmwit> It depends a lot on what you need to do with your set.
22:25:20 <shachaf> dmwit: I like how all the memoization techniques are doing is secretly building up a set. :-)
22:25:31 <shachaf> As in, a data structure for one.
22:26:10 <dmwit> =)
22:26:48 <dmwit> There's a package for ordered lists on Hackage which could probably be used for a halfway decent lazy, enumerable set implementation.
22:29:37 <hpaste_> mzero pasted “better brew” at http://hpaste.org/69915
22:29:50 <mzero> unlink: consider that
22:30:04 <startling> is there a syntax for importing a typeclass and all its instance methods?
22:30:45 <startling> dunno if "instance methods" is the right name
22:31:06 <shachaf> I think just "methods".
22:31:11 <mzero> import Data.FooType (FooType(..))
22:31:55 <startling> mzero: thanks!
22:32:01 <startling> shachaf: good to know
22:33:52 <mzero> unlink: I have probably written that exact program half a dozen times in the last 20 years!!! Though usually in shell script!
22:34:27 <startling> what in the world do I do with a Blaze.ByteString.Builder?
22:34:46 <shachaf> Why are you asking us?
22:34:52 <shachaf> No one here told you to use one. :-)
22:34:55 <shachaf> @google what in the world do I do with a Blaze.ByteString.Builder?
22:34:57 <lambdabot> http://www.yesodweb.com/blog/2011/06/cookbook-part-2
22:34:57 <lambdabot> Title: Cookbook, part 2
22:35:19 <startling> shachaf: thought someone might know off the top of their head!
22:35:57 <shachaf> startling: Your questions need more context. :-)
22:37:12 <beefcube> for "runState (do { put 5; return 'X' }) 1" how is 'put 5' being combined with return 'X' to produce ('X', 5) ? I tried correlating this syntax use with the do notation, and the closest match I can find is:'do {e;stmts}=e >> do {stmts}' but that isn't what is occuring here
22:37:51 <dmwit> beefcube: That *is* what's occurring here.
22:37:56 <beefcube> ah
22:38:02 <startling> alright, so I'm writing a small thing that uses Heist for generating html from templates. all of heist's rendering functions return Maybe (Builder, MimeType). dunno how I can turn that into a string or write it to a file or whatever
22:38:04 <dmwit> > runState (put 5 >> return 'X') 1
22:38:04 <lambdabot>   ('X',5)
22:38:20 <geekosaur> beefcube:  it's just the definition of >>= for the state monad
22:38:25 <beefcube> i guess I don't understand do blocks then
22:38:40 <geekosaur> do blocks are sugar for >>=
22:38:44 <dmwit> beefcube: Well, do you understand the example without do blocks?
22:38:51 <dmwit> If so, understanding do blocks is easy. =)
22:39:00 <Axman6> that basically translates to: (\s -> (\s -> ('X',s)) ((),5)) 1
22:39:07 <dmwit> (If not, then I make no claims about easiness or difficulty of understanding do blocks.)
22:39:24 <Enigmagic> startling: i'd recommend looking at the blaze-builder docs
22:39:25 <beefcube> dmwit: I thought those were independent, meaning, the state created by put 5 is discarded?
22:39:44 <dmwit> beefcube: No, (>>) doesn't necessarily make its arguments independent.
22:40:03 <startling> Enigmagic, i'm looking, it isn't helping very much. :(
22:40:04 <dmwit> beefcube: And state is only discarded when you explicitly ask it to be (by, e.g., executing another put).
22:40:41 <Enigmagic> startling: this one? http://hackage.haskell.org/packages/archive/blaze-builder/0.3.1.0/doc/html/Blaze-ByteString-Builder.html#g:3
22:41:02 <dmwit> beefcube: What's being discarded is the value returned from the put action.
22:41:09 <dmwit> beefcube: So, this one is also equivalent:
22:41:19 <startling> Enigmagic: oh. that looks like the function I want. thanks!
22:41:23 <dmwit> > runState (put 5 >>= \thisIsIgnored -> return 'X') 1
22:41:24 <lambdabot>   ('X',5)
22:41:36 <dmwit> beefcube: But the thing returned by put isn't interesting... it's just a ().
22:41:44 <dmwit> > runState (put 5) 1
22:41:45 <lambdabot>   ((),5)
22:41:54 <beefcube> ahh
22:46:17 <startling> is there a thing for getting the nth element of a tuple?
22:46:35 <dmwit> ?hackage tuple
22:46:35 <lambdabot> http://hackage.haskell.org/package/tuple
22:46:38 <startling> actually I don't need the general case; I just need the first element of a two-tuple
22:46:46 <dmwit> :t fst
22:46:47 <lambdabot> forall a b. (a, b) -> a
22:46:50 <startling> thanks!
22:48:46 <hpaste_> mzero annotated “better brew” with “better brew (annotation)” at http://hpaste.org/69915#a69916
22:49:01 <mzero> I know - I'm an addict, I can't stop myself
22:49:07 <mzero> for you, unlink !
22:49:30 <Axman6> startling: time to learn about hoogle :)
22:49:35 <Axman6> @hoogle (a,b) -> a
22:49:35 <lambdabot> Prelude fst :: (a, b) -> a
22:49:36 <lambdabot> Data.Tuple fst :: (a, b) -> a
22:49:36 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
22:49:37 <Axman6> @hoogle (a,b) -> b
22:49:38 <lambdabot> Prelude snd :: (a, b) -> b
22:49:38 <lambdabot> Data.Tuple snd :: (a, b) -> b
22:49:38 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
22:50:15 <mzero> @hoogle (a -> b) -> (a, c) -> (b, c)
22:50:16 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
22:50:16 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
22:50:16 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
22:50:30 <mzero> didn't think it would find it... a shame, really
22:50:32 <mzero> :t first
22:50:34 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
22:51:19 <mzero> first and second are among my favorite functions - but as generalized Arrow functions, folks rarely find them for use with tuples
22:51:23 * hackagebot PortFusion 1.2.0 - high-performance distributed reverse / forward proxy & tunneling for TCP  http://hackage.haskell.org/package/PortFusion-1.2.0 (CetinSert)
22:53:00 <startling> mzero: i used &&& for the first time yesterday
22:53:03 <startling> very satisfying
22:53:38 <hpaste_> DanBurton pasted “Where did the instance Show UTCTime go?” at http://hpaste.org/69917
22:54:04 <DanBurton> riddle me this guys ^
22:55:21 <shachaf> DanBurton: Data.Time
22:56:09 <dmwit> instance Show UTCTime -- Defined in `time-1.4:Data.Time.LocalTime.LocalTime'
22:56:09 <dmwit> instance Show UTCTime -- Defined in `time-1.4:Data.Time.LocalTime.LocalTime'
22:56:19 <dmwit> sorry for the double-paste
22:56:45 <dmwit> But yes, importing Data.Time is the simplest way to bring it in.
22:56:59 <DanBurton> ah
22:57:38 <dmwit> It would be nice if haddock had something for this.
22:57:41 <dmwit> dunno what, though
22:58:15 <dmwit> This is a good example of why simply showing which module defines an instance isn't really the right thing to do, even though it's the literal question that first comes to mind.
22:58:23 <startling> is there something like $ that groups in the opposite direction? a $ b $ c == (a (b (c)), right? can I get (((a), b), c)?
22:58:33 <DanBurton> instances are slippery things
22:58:52 <dmwit> startling: No, and in fact it should be ($) that's infixl.
22:58:56 <dmwit> A historical mistake.
22:59:04 <DanBurton> startling: there's nothing predefined that works like that
22:59:05 <startling> hm
22:59:07 <dmwit> It's easy to define your own, though.
22:59:11 <startling> yeah
22:59:25 <DanBurton> Yesod style abuses the right associativity of $
22:59:27 <dmwit> Just write "infixl 9 $$; ($$) = id".
22:59:37 <startling> not gonna though, because $ reduces readablity of code enough already
23:00:01 <DanBurton> it can be slightly better than parens in certain situations, imho
23:00:21 <Saizan> a . b $ c
23:00:41 <startling> DanBurton: yeah, but a lot of them isn't very nice
23:00:58 <startling> anyway, i love parens with rainbow-delimiter-mode. <3
23:01:00 <Saizan> (instead p
23:01:05 <DanBurton> (insert generic power/responsibility advice here)
23:02:35 <Axman6> how often do you ever need to put more than one $ in a statement? o.O
23:02:51 <Axman6> if used idiomatically it aids readability imo
23:02:53 <shachaf> Axman6 is obviously the 99%
23:03:16 <DanBurton> Axman6: technically never, given that foo $ bar $ baz == foo . bar $ baz
23:03:17 <shachaf> Axman6: People like copumpkin program a little *differently* from the rest of us.
23:03:40 <copumpkin> lol
23:03:55 <copumpkin> yeah, we just have too many $ and gotta spread them around the code
23:04:19 <Axman6> :t map (flip ($))
23:04:20 <lambdabot> forall a b. [a] -> [(a -> b) -> b]
23:04:35 <DanBurton> dmwit: might I ask how you discovered where that particular Show instance was defined?
23:04:40 <Axman6> :t map (flip ($)) . map (flip ($))
23:04:42 <lambdabot> forall b a b1. [a] -> [(((a -> b1) -> b1) -> b) -> b]
23:04:44 <dmwit> DanBurton: :i in ghci =)
23:04:54 <DanBurton> ah
23:05:04 <mzero> startling: ... uhm... application!
23:05:10 <mzero> (a) (b) (c)
23:05:10 <dmwit> DanBurton: + knowing to begin with that importing Data.Time would put it in scope
23:05:14 <mzero> does what you want
23:06:04 <startling> mzero: that's true
23:06:18 <dmwit> mzero: That doesn't really answer the question, though, which asked for something "like $".
23:06:26 <DanBurton> but the whole point of $ is for use by paren-haters ;)
23:06:37 <mzero> there is a difference here
23:06:43 <mzero> $ gets rid of nested parens
23:06:45 <dmwit> I mean, imagine how you'd feel if you asked "is there something like $ that groups to the right" and people answered "parentheses" instead of "well $ groups to the right". =P
23:06:53 <mzero> in the other order, you don't need to nest
23:07:06 <DanBurton> true
23:07:10 <mzero> and don't even need them if one of the elements is just a single thing
23:07:22 <dmwit> mzero: Not always correct... e.g. consider
23:07:30 <dmwit> f . g $$ h . j $$ x
23:07:42 <shachaf> Or just f g $$ h j $$ x
23:07:44 <mzero> vs.   (f . g) (h . j) x
23:07:45 <mzero> ?
23:08:14 <dmwit> shachaf: I don't think that's enough, since that's just f g h j x.
23:08:17 <dmwit> mzero: yes
23:08:28 <shachaf> dmwit: No, it's f g (h j) x
23:08:38 <dmwit> shachaf: You're quite right, of course.
23:08:56 <mzero> well - I wasn't sure if startling would have noticed that what he wanted could be written, sans nest parens, without another operator
23:08:59 <shachaf> There's no reasonable non-parenthesis way to express that currently.
23:09:07 <DanBurton> Someone suggested using ' as single-arg application
23:09:09 <mzero> (given past questions)
23:09:13 <DanBurton> ''''f g 'h j x
23:09:20 <mzero> ew
23:09:24 <DanBurton> wait only 3
23:09:38 <mzero> ew^3
23:09:44 <dmwit> haha
23:09:53 <dmwit> As if we all want to implement a mental stack.
23:09:53 <DanBurton> at first it looks ugly, but I think after looking at it for a while, it's not much uglier than parens or $
23:10:25 <dmwit> At least with parentheses there's half a chance that our text editors will give us some help with parsing the stack out of the box.
23:10:29 <shachaf> That's just unlambda, isn't it?
23:10:40 <DanBurton> lol, I guess so
23:10:42 <shachaf> ``sk`kk
23:21:48 <startling> is there a way to have cabal include some data files?
23:21:55 <startling> and put them in a place I can find later?
23:22:01 <c_wraith> yes
23:22:13 <c_wraith> but I don't remember what it's called :)
23:22:22 <c_wraith> but at least you know it's there, so you can go looking for it!
23:22:24 <startling> perfect!
23:22:36 <mzero> yes
23:22:54 <Axman6> you can't ask for better than that!
23:22:55 * mzero is gathering links
23:23:22 <mzero> in the .cabal file, use a Data-Files: section -- see for example: https://github.com/mzero/plush/blob/master/plush.cabal
23:24:09 <Lemon> should I have Setup.hs in .gitignore?
23:24:11 <mzero> then include Paths_projectname   -- see https://github.com/mzero/plush/blob/master/src/Plush/Server.hs#L40
23:24:17 <Lemon> cabal install seems to generate it
23:24:33 <mzero> lastly, call   getDataDir to get the directory
23:24:52 <c_wraith> Lemon: no, you might have reason to customize it - and cabal sdist expects it to be present
23:25:00 <Lemon> okay
23:25:01 <mzero> startling: the down side of this is that when developing - you need to
23:26:06 <mzero> export  projectname_datadir=`pwd`
23:26:34 <startling> mzero: ugh what
23:26:41 <mzero> DO
23:26:43 <mzero> er
23:26:46 <startling> oh, "when developing"
23:26:47 <startling> got it
23:27:00 <startling> does it work if i do a directory?
23:27:27 <mzero> you can get around this by check  doesDirectoryExist on getDataDir's response, and if it is missing, substitute (or try) "."
23:28:07 <mzero> you can have multiple subdirs in there -- see my links for examples - but you can't include a dir recurisively in the .cabal file
23:28:23 <mzero> you must list all files (with limited wildcard syntax)
23:28:55 <mzero> see http://lambda.haskell.org/platform/doc/current/ghc-doc/Cabal/developing-packages.html#accessing-data-files-from-package-code
23:28:58 <mzero> for all the gory details
23:31:26 <rodayo> If there's a type synonym being used in something, is there a way to find what it is in ghci without looking through the code?
23:32:01 <Lemon> rodayo, use :i
23:32:28 <rodayo> Lemon, perfect =)
23:37:09 <unlink> http://paste.lisp.org/display/130020#1
23:37:16 <unlink> no more StateT
23:40:21 <startling> so cabal doesn't let me do Data-Files for a directory for some dumb reason. what else could I do?
23:45:58 <DanBurton> not use cabal? If the method it provides for adding extra files to your package doesn't work... and you need to add extra files...
23:46:18 <DanBurton> you've seen the cabal user guide, right?
23:46:21 <DanBurton> http://www.haskell.org/cabal/users-guide/developing-packages.html
