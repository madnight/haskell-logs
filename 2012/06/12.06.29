00:00:19 <ksf> pure code should transform quite easily, List -> Data.List etc.
00:01:30 <ksf> oh. if all those qualified names are non-haskell ones you should be able to just enable hierarchical modules
00:02:02 <Nensha> how to get cabal version in haskell?
00:02:38 <wnoise> They're Haskell ones.  And I need to be careful with the sed, as I don't want to transform Data.List to Data.Data.List.
00:02:56 <ksf> Nensha, there should be a generated module.
00:03:18 <abhiranjanlost> Hi all
00:03:23 <Nensha> ksf: generated module ?
00:03:46 <ksf> sed -e "s/^import *List/import Data.List/" -e "..."
00:03:52 <abhiranjanlost> It would be greatfull if anyone tells me about a good source for learning haskell
00:04:25 <abhiranjanlost> I am already introduced to basic haskell (but not to monads) :(
00:04:42 <Botje> @where lyah
00:04:42 <lambdabot> http://www.learnyouahaskell.com/
00:04:44 <startling> abhiranjanlost: http://learnyouahaskell.com/ is great
00:04:46 <startling> jinx
00:04:48 <ksf> hmm. Paths_Foo doesn't contain it.
00:04:56 <ksf> only the package version.
00:06:12 <ksf> Nensha, do you want the cabal version your code gets build by, or the cabal version you're linking to?
00:06:52 <ksf> the latter is in http://hackage.haskell.org/packages/archive/Cabal/1.14.0/doc/html/Distribution-Simple-Utils.html#v:cabalVersion
00:07:07 <Nensha> ksf: I want to get cabal version
00:07:23 <abhiranjanlost> lambdabot, startling: thanks for advice. But I had already gone through this book
00:07:23 <ksf> well, there's two versions you might be interested in.
00:07:51 <abhiranjanlost> startling: now looking for some advance source.
00:08:02 <Nensha> ksf: yes
00:08:12 <Botje> abhiranjanlost: there's also real world haskell and a gentle introduction to haskell
00:08:36 <ksf> as for the first case, not using Distribution.Simple would help, but I don't know much about cabal.
00:09:35 <wnoise> Looks like the most significant change is getArgs moving to System.Environment form System.
00:10:29 <startling> abhiranjanlost, but you don't understand monads? the typeclassopedia is useful
00:10:30 <startling> @where typeclassopedia
00:10:30 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
00:10:49 <Nensha> ksf: I need cabal-install version
00:11:06 <startling> abhiranjanlost: this helped me understand monads, too: http://blog.sigfpe.com/2007/04/trivial-monad.html
00:13:05 <ksf> Nensha, System.Process, call cabal-install --version
00:13:34 <Nensha> ksf: maybe there is something else that could provide it ?
00:14:04 <ksf> nope, the cabal version cabal-install was built with might not even exist anymore in the package database.
00:14:43 <abhiranjanlost> startling lamdabot Botje: Thanks a lot. :)
00:14:50 <startling> abhiranjanlost, lambdabot is a bot
00:15:29 <mroman> :D
00:16:12 <abhiranjanlost> startling: missjudged by -his- its correct (near to) replies
00:16:17 <abhiranjanlost> startling: ok
00:16:34 <ksf> argh recursion-schemes doesn't even use Control.Categorical.Functor
00:16:36 <startling> abhiranjanlost: well, he knows what to say when we ask him @where something is. :)
00:16:39 <Nensha> Where is Distribution.Client.IndexUtils
00:16:54 <startling> does anyone have an example of an applicative that's not also a monad?
00:17:06 <abhiranjanlost> startling: cool
00:17:46 <ksf> startling, regular parser combinators.
00:18:16 <Nensha> can I import cabal-install to .cabal file ?
00:18:26 <ksf> monads introduce dependencies on the current context, so it's not regular, any more.
00:21:46 <Nensha> At least the following dependencies are missing: Cabal-install -any
00:22:01 <Nensha> How should I get cabal-install Distribution.Client.IndexUtils
00:25:41 <Nensha> ^^^ http://stackoverflow.com/questions/11257712/how-to-get-cabal-install-distribution-client-indexutils
00:30:37 <mcstar> would it be possible to define a GHCI function that does what ipython's %paste magic command?
00:31:01 <shachaf> That would depend on what ipython's %paste magic command.
00:31:22 <mcstar> pastes the clipboard correctly into the interpreter
00:31:48 <shachaf> I'm afraid ghci only supports pasting the clipboard incorrectly.
00:32:26 <mcstar> it would need to prepend 'let' before the paste also
00:32:33 <shachaf> (...What does "into the interpreter" mean?)
00:32:37 <mcstar> and dont be sarcastic
00:32:50 <shachaf> Oh, you want to paste a Haskell file into ghci and have it just work.
00:32:54 <startling> I can't stop laughing
00:33:04 <shachaf> No, that's much trickier than putting "let" in front of every line.
00:33:05 <mcstar> not a whole file, just a definition
00:33:16 <shachaf> With that said, you can write ghci macros so you can make them do whatever you want.
00:35:00 <wnoise> Done.  Well, I should probably fix the warning about using the catch from Control.Monad.Exception, rather than the Prelude.  And run hlint.
00:35:18 <mcstar> what is the state of completion support for emacs's ghci repl?
00:35:41 <mcstar> cause it would make sense to do this from emacs directly, but i dont want to lose ghci goodness
00:36:46 <b52> i would love to see lighttable with haskell support :)
00:37:30 <ksf> @tell edwardk I'd love a Foldable class that works with categorical functors
00:37:31 <lambdabot> Consider it noted.
00:38:22 <mcstar> b52: it is on the way, last i heard
00:38:40 <b52> including haskell support?
00:38:47 <b52> i thought it would only support lisp and python
00:38:54 <startling> b52: *clojure
00:39:00 <b52> my bad
00:39:09 <b52> too much ((()()()()()()
00:39:15 <b52> noise
00:39:26 <startling> heh. clojure is pretty nice as far as lisps go
00:39:59 <mcstar> cheery said he plans to add haskell support
00:40:06 <Dtgr> clojure and other lisps make me feel nausious
00:40:37 <mcstar> why get people distracted by the parenthesis
00:40:49 <mcstar> its like saying i dont like haskell, cause it has pattern matching
00:41:26 <flux> I think it's the )))))
00:41:31 <Dtgr> because they make things unclear
00:41:34 <Dtgr> flux: exactly
00:41:48 <flux> iirc there is a lisp variant with ]
00:41:52 <flux> that closes all open )'s
00:42:01 <flux> I think it somehow misses the point, however..
00:42:55 <osfameron> an editor macro that autocloses the ((((( is quite sensible though
00:43:08 <flux> it's not the writing, it's the reading, IMO
00:43:29 <osfameron> yeah.  I bet you get used to it quite quickly though
00:43:39 <osfameron> I find haskell doesn't have enough () for my liking ;-)
00:43:51 <flux> no doubt due to lisp-allergy ;)
00:43:52 <osfameron> (not that I'm a lisp programmer either)
00:44:04 <shachaf> That sounds like a topic for a channel that isn't #haskell. Like #lisp-h8rs or something.
00:44:13 <Iceland_jack> shachaf: isn't that #haskell though?
00:44:24 <ion> …
00:44:40 <shachaf> Iceland_jack: No. The point of this channel isn't to say bad things about other languages.
00:44:53 <startling> #haskell is #we-used-to-use-lisp
00:45:13 <ion> -and-potentially-still-do
00:45:32 <flux> who here doesn't use emacs?-)
00:45:41 <mcstar> many
00:46:08 <osfameron> there seems to be a slight bias towards emacs here, but a fair number of vimsters too (and other editors)
00:46:43 <osfameron> s/bias/leaning
00:47:29 <shachaf> Next up in #haskell: Is 0.999... = 1???
00:47:55 <Botje> only on a pentium 90.
00:49:13 <augur> so im curious
00:49:23 <mcstar> not, it isnt equal
00:49:31 <augur> how are knot-tying definitions modelled categorically?
00:49:40 <astropirate_> shachaf, is .999 == 1?
00:49:58 <ion> > read ("0." ++ repeat '9') == 1
00:50:02 <lambdabot>   mueval-core: Time limit exceeded
00:50:17 <Botje> computer says no
00:51:34 <ion> botje: It didn’t. It said bottom.
00:52:54 <shachaf> ion: Timed out is very different from _|_.
00:53:49 <ion> Granted. It was me who analyzed it to be bottom.
01:04:44 * hackagebot bits-conduit 0.2.0.0 - Bitstream support for Conduit  http://hackage.haskell.org/package/bits-conduit-0.2.0.0 (HideyukiTanaka)
01:10:52 <mcstar> > let go n = if n == 1 then "yay!" else go ((9 + n)/10) in go (9/10)
01:10:53 <lambdabot>   "yay!"
01:14:04 <Lemon> so
01:14:20 <Lemon> type synonyms, normally, can't be used without full saturation
01:14:30 <Lemon> but type synonyms for constraint kinds can?
01:15:24 <Lemon> because right now I have `type Foo a = (Bar a, Show a)` and I'm using it in a type family like `myFamily Baz Foo` and the compiler ain't sayin' shit
01:16:24 <jamil_1_> hi
01:17:19 <jamil_1_> I am reading a post on free monads and I am confused about types/do-notation
01:17:20 <jamil_1_> http://paste.ubuntu.com/1065636/
01:17:35 <b52> which post?
01:17:37 <jamil_1_> line 24, definition of interleave uses do notation
01:17:45 <jamil_1_> b52: here: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
01:18:29 <jamil_1_> my brain is unable to infer type of next1, next2 on line 27,28
01:22:34 <Botje> next1 and next2 are again Thread m r things.
01:26:06 <jamil_1_> Botje: yep because you are calling interleave again on them. but my problem is how ?
01:27:02 <mcstar> Thread is used in its own definition
01:27:35 <Botje> jamil_1_: evaluating an Atomic thing will yield a new one
01:28:08 <jamil_1_> Botje: should it yield m (Thread m r) ?
01:28:15 <Botje> yes
01:28:21 <Botje> and <- strips the outermost monad
01:28:32 <Botje> just like x <- getLine strips the IO from IO String
01:28:45 <shachaf> "strips the IO from IO String" :-(
01:29:07 <jamil_1_> Botje: (atomic m1) :: Thream m a rigth ?
01:29:58 <Botje> jamil_1_: m1 :: m (Thread m r), so atomic m1 :: Thread m (Thread m r)
01:30:40 <Botje> (since you pattern match m1 and m2 out of Atomic constructors on line 26)
01:33:47 <jamil_1_> Botje: why isn't type of next1 :: m(Thread m r) ? I guess this has to with how monad instance is defined but I am not clear about ti
01:35:17 <jamil_1_> brb
01:41:23 <mcstar> :S i broke the Collatz map badly
01:50:23 <Penetrator> @pl  a x f = b (\y -> b (u . y) x ) f
01:50:23 <lambdabot> a = b . flip (b . (u .))
01:51:36 <Penetrator> @pl  \x f -> b (\y -> b (u . y) x ) f
01:51:36 <lambdabot> b . flip (b . (u .))
01:55:10 * ksf needs a categorical wizard
02:09:27 <mcstar> im wondering if its possible to combine PlotTypes in gnuplot with Graphics.Gnuplot.Simple
02:09:30 <quup> I have a missing dependency 'List >=0.4.2 && <0.5
02:09:41 <quup> but that's pretty much ungooglable, what package is it from?
02:11:01 <fmap> @package List
02:11:01 <lambdabot> http://hackage.haskell.org/package/List
02:11:14 <fmap> quup: ^
02:11:55 <quup> fmap: thanks!
02:14:55 <quup> oh nice! cabal installs in home directory instead of messing up my /
02:15:20 <mcstar> im blind, there is a combined Lines and Points type, sophisticatedly called LinesPoints
02:21:25 <mroman> quup: If it's not googable it might be hoogable.
02:22:13 <quup> mroman: oh look at that, thanks
02:26:48 <cads> @hoogle (a -> b) -> f a -> f b
02:26:49 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
02:26:49 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
02:26:49 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
02:26:55 <cads> excellent.
02:26:56 <t7> Vim users aren't 'neckbeards', right?
02:27:03 <cads> now for the trick
02:27:13 <cads> @hoogle (b -> a) -> f a -> f b
02:27:14 <lambdabot> Data.IntMap updateMax :: (a -> a) -> IntMap a -> IntMap a
02:27:14 <lambdabot> Data.IntMap updateMin :: (a -> a) -> IntMap a -> IntMap a
02:27:14 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
02:27:56 <cads> @type lift
02:27:57 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
02:28:05 <mroman> @hoogle (c -> (a -> b)) -> a -> b -> c
02:28:06 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
02:28:06 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
02:28:06 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
02:28:27 <mroman> @djin (c -> (a -> b)) -> a -> b -> c
02:28:28 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
02:28:33 <mroman> @djinn (c -> (a -> b)) -> a -> b -> c
02:28:33 <lambdabot> -- f cannot be realized.
02:29:10 <Tinned_Tuna> @djinn a -> b
02:29:11 <lambdabot> -- f cannot be realized.
02:29:16 <cads> @djin (a -> b) -> f a -> f b
02:29:17 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
02:29:35 <cads> @djinn (a -> b) -> f a -> f b
02:29:35 <lambdabot> -- f cannot be realized.
02:30:23 <cads> oh fmap has to be written for each instance of functor
02:30:55 <cads> so there's no fpam for contravariant functors?
02:32:41 <PatrickRobotham> Surely it'd be pamf
02:40:58 <Lemon> Wah! What are we gonna do in the functor?
02:41:07 <Lemon> =3 PAMF
02:56:36 <SrPx> Hey, will haskell applicate a function to values on it's left too? Because (1 +) is a function...
02:56:42 <SrPx> applicate = apply
02:56:43 <dp_wiz> How to convert from Data.Time.Calendar.Day to Data.Time.UTCTime ?
02:57:00 <ben> SrPx: (1 +) is special syntax for (+) 1
02:57:11 <ben> (1 + 2) is also (+) 1 2
02:57:14 <SrPx> ben: you mean defined on the implementation
02:57:17 <SrPx> ?
02:57:24 <ben> it's syntax for operators
02:57:33 <SrPx> operators?
02:57:37 <ben> opterator sections
02:57:41 <SrPx> is + different from a function then
02:57:45 <ben> operator*
02:57:57 <SrPx> opterator heh
02:58:00 <ben> operators are functions too
02:58:04 <ben> operators are funtions with symbol-ish names
02:58:14 <SrPx> but can I declare them?
02:58:18 <ben> yeah
02:58:25 <SrPx> hm okay, lmgt
02:58:26 <SrPx> thanks
02:58:46 <ben> > let x +++ y = x + y * 3 in 5 +++ 10
02:58:47 <lambdabot>   35
02:59:02 <ben> > let x +++ y = x + y * 3 in (+++) 5 10
02:59:04 <lambdabot>   35
02:59:18 <ben> You can use a "normal" function like an operator by putting `` around it's name
02:59:37 <ben> > let plus x y = x + y in 3 `plus` 5
02:59:39 <lambdabot>   8
02:59:48 * hackagebot cabal2nix 1.37 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.37 (PeterSimons)
03:03:07 <hiptobecubic> can't the nix packager just call cabal?
03:03:55 <fmap> dp_wiz: UTCTime day 0?
03:04:39 <dp_wiz> fmap: yeah
03:15:33 <ksf> @hoogle getConst
03:15:33 <lambdabot> Control.Applicative getConst :: Const a b -> a
03:15:33 <lambdabot> Data.Functor.Constant getConstant :: Constant a b -> a
03:16:29 <Nensha> If someone could help me with cabal : https://github.com/haskell/cabal/issues/959
03:19:34 <ksf> @hoogle getId
03:19:35 <lambdabot> No results found
03:28:12 <gienah> @hoogle SomeException
03:28:12 <lambdabot> Control.Exception.Base SomeException :: e -> SomeException
03:28:12 <lambdabot> Control.Exception SomeException :: e -> SomeException
03:28:12 <lambdabot> Control.Exception.Base data SomeException
03:28:26 <gienah> Nensha: ^^^ maybe import it from there
03:28:45 <Nensha> gienah: I can't edit cabal sources
03:29:03 <Nensha> gienah: /s/can't/don't want to
03:29:22 <gienah> Nensha: it is kind of difficult to tweak cabal sources (give that Cabal is a ghc core library)
03:29:53 * hackagebot scyther-proof 0.5.0.0 - Automatic generation of Isabelle/HOL correctness proofs for security protocols.  http://hackage.haskell.org/package/scyther-proof-0.5.0.0 (SimonMeier)
03:30:11 <Nensha> gienah: I think anyways that it's my fault somewhere but I can't understand where
03:30:22 <Nensha> gienah: what I need to compile it "correct"
03:31:13 * Nensha hell they has got ~500 issues
03:32:53 <linduxed> hey guys, i need some hints on how to improve this code of mine https://github.com/linduxed/kalaha-solver
03:42:12 <ksf> are there open recursions inexpressible with traverse?
03:44:24 <int-e> ksf: how does that translate to FP anyway?
03:50:08 <ksf> traverse applies an applicative over a data type
03:51:23 <int-e> Sorry, I should not have used "that". I meant the open recursion part.
03:52:02 <ksf> good question.
03:57:08 <int-e> Late binding usually translates to existential datatypes, with class dictionaries playing the role of virtual method tables.
04:04:58 <quicksilver> int-e: (or just some reified method table inside the existential, no particular reason for it to be a dictionary of a typeclass)
04:13:16 <ksf> what's a functor called that bases its replacements on data it collected top-down?
04:16:28 <commanace> Hey, I was trying to install json-0.4.4 via cabal-install... and ghc (6.12.3) ran out of memory. http://hpaste.org/70608
04:16:34 <commanace> Any ideas? is this a known problem?
04:17:46 <Jeanne-Kamikaze> try updating your ghc ? thats pretty old
04:17:47 <lambdabot> Jeanne-Kamikaze: You have 1 new message. '/msg lambdabot @messages' to read it.
04:18:01 <Saizan> commanace: how much memory do you have?
04:18:25 <commanace> Jeanne-Kamikaze: I don't really dare going to ghc 7 because I'm afraid i might break something
04:18:49 <commanace> Saizan: ehm... to be honest I'm not quite sure anymore :D I think a gig or so, should be enough in any case
04:19:24 <bitonic> commanace: GHC can be quite a memory hog. Maybe try turning optimisations off, if they are enabled?
04:19:52 <commanace> Jeanne-Kamikaze: plus, the one I have installed is the latest version in the ubuntu repository I think...
04:20:11 <bitonic> commanace: yeah, distros fall behind - that's a general truth.
04:20:24 <bitonic> that's by design really
04:20:31 <hpc> i just installed json-0.5 on a laptop with a gig of memory without OOM
04:20:35 <hpc> ghc 7.4.1
04:21:13 <commanace> bitonic: alright, thanks I can try that, but still I don't think that it should use *that* much memory even with optimisations
04:21:28 <bitonic> commanace: I agree with you. It is a very complex compiler
04:22:20 <bitonic> try clearing up memory before starting anyway - with a "modern" distributions the DE alone ofter consumes an obscene amount of memory
04:23:17 <hpc> or if you can't clear up memory, mount an external hard drive as a swap partition or something
04:23:35 <bitonic> and then go take a long walk
04:23:45 <commanace> okay :P thanks
04:24:17 <hpc> my personal benchmark is that i should be able to compile GHC from source on any given computer
04:24:47 <bitonic> hpc: that's obviously false, unless you have a very strict notion of "computer"
04:24:58 <hpc> *on any given computer i own
04:25:01 <bitonic> ok.
04:25:20 <commanace> by the way, shouldn't I be able to "bootstrap" ghc7 via cabal install? I mean given that even json runs out of memory, probably I won't be able to compile ghc, but I was still rather confused not to find it with "cabal list ghc"
04:25:33 <hpc> @where ghc
04:25:33 <lambdabot> http://haskell.org/ghc
04:25:38 <hpc> you don't get ghc from cabal
04:25:44 <dcoutts> commanace: no, ghc is not a cabal package
04:26:13 <commanace> dcoutts: but it used to be, right?
04:26:19 <dcoutts> commanace: no, never
04:26:33 <hpc> ghc is too ridiculous for cabal to handle :P
04:27:00 <commanace> hm...? okay, then probably I confused something :) thank you guys, ... I'll try to give ghc some more memory to play with
04:27:04 <dcoutts> commanace: ok, one confusion, there's ghc the compiler, and there is also the ghc library which as a package in ghc-pkg list is called 'ghc'. Perhaps that's what you're thinking about.
04:27:23 <commanace> dcoutts: maybe
04:28:31 <dcoutts> so you might find certain tools (like haddock) that depend on a library package called ghc, but that library package is a bit special in that it gets installed with ghc and not installed from hackage via cabal
04:29:32 <commanace> dcoutts: ah, okay, that makes sense
04:30:35 <commanace> by the way: http://hpaste.org/70609
04:30:50 <commanace> shouldn't that really be sufficient...??
04:32:50 <Penetrator> @pl \f -> b (u . f)
04:32:50 <lambdabot> b . (u .)
04:33:08 <Penetrator> damn this moppy!!!
04:35:19 <commanace> running top during compilation reveals that ghc requests 2.5 GB of memory! Even knowing that ghc is a memory hog that is not really justifyable I guess... so I guess it is probably a bug solved in a more recent version of ghc
04:36:36 <hiptobecubic> ghc requests a truly absurd amount of memory when building things
04:37:34 <Adeon> is that just allocated virtual memory or is it actually used
04:38:05 <Penetrator> Aldeon: look at the RSS field in top to find that out
04:38:12 <hiptobecubic> Adeon, when i am building something big, i have to close everything else or it will start thrashing the swap
04:38:20 <Adeon> ah, so it is used
04:38:35 <hiptobecubic> i think it's the linking stage that's the worst
04:43:27 <Penetrator> @t mapM
04:43:27 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
04:43:34 <Penetrator> @:t mapM
04:43:35 <lambdabot> Done.
04:43:47 <Penetrator> @type mapM
04:43:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:57:09 <t7> is there something like SCRUM for one person?
04:57:27 <Botje> pick a task, do it, repeat?
04:58:22 <t7> im slacking, i need someone on my back
04:58:28 <t7> but im a solo programmer
04:58:42 * t7 says get to work
04:58:48 <hiptobecubic> block reddit
04:58:51 <hiptobecubic> done
04:59:06 <zhulikas> :D
04:59:07 <roconnor> The time you enjoy wasting is not wasted time -- Russell
04:59:11 <zhulikas> scrum for one person :D
04:59:25 <zhulikas> t7, what you do need is motivation
04:59:40 <zhulikas> its not easily achievable with shitty projects
04:59:54 <t7> i have a reasonable idea
05:00:06 <t7> i think i just need to set achievable goals
05:00:36 <zhulikas> yeaaa, I have an idea too, which I do occasionally
05:00:43 <zhulikas> like two evenings a month
05:00:48 <zhulikas> not sure if it will be ever finished
05:01:09 <t7> im making an aerosol art game/simulation
05:01:18 <t7> say goodbye to your vram
05:03:28 <t7> i allways get something working then get bored
05:03:43 <hpc> @quote oleg motivation
05:03:43 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
05:07:01 <t7> classic me
05:08:12 <lunaris> Camera-ready version finally finished: http://www.doc.ic.ac.uk/~wlj05/files/Deconstraining.pdf
05:08:45 <nand`> hpc: so true
05:39:46 <tomboy64> hiya
05:40:01 <tomboy64> i'm trying to jump a little through documentation, reading about monads now
05:40:17 <tomboy64> i found an explanation for Maybe - but i still don't get Just
05:41:48 <however> tomboy64: i think the haddock documentation is a very poor source for trying to learn new things. try lyah for example, possibly also rwh
05:41:50 <however> @where lyah
05:41:50 <lambdabot> http://www.learnyouahaskell.com/
05:41:52 <however> @where rwh
05:41:53 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:42:19 * hiptobecubic doesn't like rwh
05:42:52 <tomboy64> can someone give me a one-liner as to what it does?
05:42:54 <tomboy64> i am in rwh
05:42:55 <tomboy64> i just jumped a little forward
05:42:56 <tomboy64> and couldn't find a quick definition of Just
05:43:15 <hiptobecubic> "Maybe" is the name of the type
05:43:24 <hiptobecubic> as in "foo is a 'Maybe Int'"
05:43:35 <hiptobecubic> Meaning it might be an Int, but it might not.
05:43:48 <hiptobecubic> That is represented by "Just Int" and "Nothing"
05:44:27 <fmap> @src Maybe
05:44:28 <lambdabot> data Maybe a = Nothing | Just a
05:44:59 <tomboy64> so Just is another type?
05:45:02 <tomboy64> @src Just
05:45:02 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:45:05 <hiptobecubic> It's a constructor
05:45:11 <mux> hiptobecubic: saying "Just Int" was kinda confusing.
05:45:24 <hiptobecubic> mux, yeah, I'm not a great orator
05:45:27 <however> tomboy64: a Maybe is a tiny data structure that can be either Nothing, or it can be "Just a". for "a" you can substitute any haskell value (42, "lolcats", ...). in other languages this kind of thing might be expressed as a pointer that points to null, or points to a real value.
05:46:09 <mux> I like to think of the Maybe type as some neat way to insert one null-like value in the set of values for a type, in a safe way
05:46:10 <tomboy64> why not a then as in [a]? why Just a?
05:46:13 <mux> I have no idea if that helps
05:46:40 <hiptobecubic> tomboy64, because  "a" doesn't include any information abuot the fact that it might not have been "a"
05:46:48 <hiptobecubic> it might have been "Nothing" instead
05:46:51 <however> it's really not that scary. you'll find many functions that will return (say) a Maybe Int, i.e. they will return Nothing if an error occurred, or Just 37 for the result of the computation. this is like a c function returning either -1 or 37
05:47:37 <mux> canonical example would be a safeDiv function, taht would return Nothing in case it was called with 0 as the divisor, or Just <the_result> otherwise
05:48:09 <mcstar> in c you would pass a pointer to the function, for mutation and use return value purely for error propagation
05:48:16 <however> tomboy64: there's definitely overlap between "[a]" and "Maybe a". (in fact there's functions that allow some sort of conversion between those.) the difference is that a list "[a]" can hold many things of type a, not just 0 or 1
05:49:12 <tomboy64> hm
05:49:34 <tomboy64> well, maybe is clear. Just still ain't :-D
05:49:49 <merijn> > let safeDiv :: Int -> Int -> Maybe Int; safeDiv x y = if y /= 0 then Just (x/y) else Nothing in safeDiv 2 3
05:49:51 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
05:49:51 <lambdabot>    arising from a use o...
05:49:57 <merijn> ah, bollocks
05:50:01 <mux> Just is just one of the two ways to introduce Maybe values at the term-level (in the body of your functions)
05:50:06 <merijn> > let safeDiv :: Int -> Int -> Maybe Int; safeDiv x y = if y /= 0 then Just (x `div` y) else Nothing in safeDiv 2 3
05:50:08 <lambdabot>   Just 0
05:50:14 <merijn> > let safeDiv :: Int -> Int -> Maybe Int; safeDiv x y = if y /= 0 then Just (x `div` y) else Nothing in safeDiv 2 0
05:50:16 <lambdabot>   Nothing
05:50:38 <mux> :t Just 'a'
05:50:40 <lambdabot> Maybe Char
05:50:43 <mux> :t Just 1
05:50:45 <lambdabot> forall t. (Num t) => Maybe t
05:50:57 <mel-> wow
05:51:04 <mel-> we have a haskell-evaluating bot in here?
05:51:11 <mux> sure
05:51:29 <merijn> mel-: Yes, it has type based API searching and automated point free conversion too
05:51:31 <t7> anyone know how to convert from barycentric to 3d coords? i can convert from 3d to barycentric
05:51:40 <mux> > nubBy (\x y -> gcd x y > 1) [2..]
05:51:42 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:51:53 <merijn> Althought the point free conversion tends to often not be all that useful :p
05:51:58 <however> tomboy64: possibly you can think of Just as a bit of boilerplate. a Maybe that is empty is constructed by Nothing. a Maybe that is full is constructed by Just "lolcats"
05:51:59 <mux> and free prime numbers :-P
05:52:43 <merijn> @pl \f x y -> f x (f y)
05:52:43 <lambdabot> flip =<< ((.) .)
05:54:12 <tomboy64> however: ok, i think i got it.
06:00:45 <mcstar> @pl \x y -> gcd x y > 1
06:00:45 <lambdabot> flip flip 1 . ((>) .) . gcd
06:00:55 <mcstar> thats ugly
06:03:37 <mcstar> nubBy ((> 1) ... gcd) [2..]
06:03:40 <mcstar> this is better
06:03:52 <mcstar> let (...) = \g f a b -> g (f a b)
06:05:11 * hackagebot yaml 0.8.0 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.8.0 (MichaelSnoyman)
06:12:14 --- mode: ChanServ set +o shapr
06:12:57 --- mode: shapr set +b progster!*@*
06:24:37 <aristid> if i want a package to be portable, is FlexibleInstances fair game?
06:25:17 <dmwit> That depends on what you mean by "portable", I'm afraid.
06:25:26 <dmwit> If you want cross-platform portability, extensions don't matter: packages do.
06:25:46 <dmwit> If you want cross-implementation portability, then packages don't matter, and basically all extensions are Right Out.
06:25:54 <aristid> all?
06:26:24 <dmwit> Well, what implementations do you want it to work on?
06:26:24 <aristid> i want to be portable to serious implementations of haskell, of which right now there is only ghc i guess
06:26:30 <bitonic> aristid: no, all "popular" haskell compiler support some
06:26:39 <bitonic> I'm thinking of Hugs mainly
06:27:07 <dmwit> Hugs supports some extensions, yes; and JHC supports some extensions; and LHC and UHC and...
06:27:12 <dmwit> But their intersection is small. =)
06:27:23 <bitonic> dmwit: FlexibleInstances is in that intersection
06:27:55 <aristid> bitonic: so FlexibleInstances support at least hugs, jhc, lhc and uhc?
06:28:06 <bitonic> aristid: definitely Hugs and UHC.
06:28:11 <bitonic> not sure about the rest.
06:28:31 <dmwit> http://repetae.net/computer/jhc/manual.html#extensions
06:28:48 <hiptobecubic> What's the shortest valid haskell program that segfaults? Without using FFI :)
06:29:22 <bitonic> hiptobecubic: unsafeCoerce can do that.
06:29:37 <bitonic> wait, what do you mean with "valid haskell"?
06:30:08 <ssbr_> If a function isn't annotated to give type information, is there a way to get haskell to emit the type information? like the --dtypes flag for ocaml
06:30:33 <ssbr_> or maybe this is something one does in the interactive interpreter?
06:30:37 <bitonic> ssbr_: emit where? You can use :t in ghci
06:30:53 --- mode: shapr set -o shapr
06:31:08 --- mode: ChanServ set +o dmwit
06:31:29 <ssbr_> bitonic: well, ocaml emits it to a file. So if we had foo.ml, there'd be foo.annot, and your editor can query this foo.annot file when your cursor is on a variable to tell you its type
06:31:36 <ssbr_> e.g. tuareg-mode for emacs does this
06:32:19 <ssbr_> the interactive interpreter works, at least for functions (not for variables within functions)
06:32:32 <bitonic> ssbr_: I'm not aware of such an option, but GHC will output warnings with the -Wall (or you can use the specific option, which is probably something like -fwarn-missing-type-signatures). ghc-mod for emacs can do that.
06:32:38 <hiptobecubic> bitonic, valid is not a good word. I mean 'idiomatic' perhaps. I don't mean using a ghc extension to inline some assembly that reads from 0xDEADBEEF
06:32:46 <shapr> :t map
06:32:47 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:33:00 <bitonic> hiptobecubic: idiomatic haskell does not segfault
06:33:11 <bitonic> :)
06:34:37 <bitonic> you can segfault really quickly with most unsafe* functions
06:34:53 <bitonic> e.g. you can do it the usual way by creating a bogus Ptr
06:35:03 <flux> they should call them 'exciting*' instead
06:35:06 <bitonic> you don't even need unsafe* for that
06:35:21 <hiptobecubic> bitonic, that's what i mean though
06:35:33 <dmwit> peek at nullPtr
06:35:36 <dmwit> whoa, ops
06:35:51 <hiptobecubic> for example, int main() { return *((volatile char *)0x0); }  is a valid c program that dies immediately.
06:36:41 <dmwit> main = peek nullPtr >>= print
06:36:42 <bitonic> hiptobecubic: main = peek nullPtr :: IO Int
06:36:52 <hiptobecubic> ok
06:37:07 <dmwit> bitonic: not quite
06:37:19 <dmwit> bitonic: perhaps you meant peek nullPtr >>= exitWith . ExitFailure
06:37:24 <hiptobecubic> return $ peek nullPtr ?
06:37:32 <bitonic> hiptobecubic: but that's FFI in a way
06:37:43 <dmwit> hiptobecubic: nope, not that either =)
06:37:53 <hiptobecubic> @type peek
06:37:54 <lambdabot> Not in scope: `peek'
06:38:17 <bitonic> dmwit: no, main = peek nullPtr :: IO Int is OK
06:39:12 <bitonic> main can be IO <whatever>
06:39:31 <dmwit> Oh, I thought you were trying to write the Haskell equivalent of hiptobecubic's C code.
06:39:56 <hiptobecubic> no i just want a short program that segfaults
06:39:58 <bitonic> dmwit: ah, no. Just a short segfault
06:40:02 <hiptobecubic> without Import Control.Segfault
06:40:11 <bitonic> hiptobecubic: btw Ptr and Storable are FFI in some way...
06:40:17 <hiptobecubic> is that a package yet? I should make it.
06:40:20 <dmwit> Well, there's sneaky ways with generalized newtype deriving.
06:40:21 <hiptobecubic> that's a good first package
06:40:30 <dmwit> Is that the kind of thing you're looking for?
06:40:47 <mcstar> let ref = unsafePerformIO (newIORef (unsafePerformIO (readIORef ref))) :: IORef Int i hoped this would segfault when i'd use the value from ref, but it only loops :(
06:40:54 <bitonic> dmwit: I want to see that, is it something to do with storable
06:40:59 <hiptobecubic> I'm just curious about where you see segfaults in haskell code
06:41:02 <dmwit> bitonic: it isn't
06:41:19 <bitonic> dmwit: OK, I'm even more curious then :D
06:41:42 <dmwit> http://hackage.haskell.org/trac/ghc/ticket/1496 -- seems to be what I'm thinking of after a quick glance
06:42:16 <bitonic> wow, aged bug.
06:42:51 <dmwit> It's tricky to solve it correctly.
06:46:17 <bitonic> dmwit: that's interesting. thanks.
06:46:21 <mcstar> what i dont get is, what is happening in when i run that stuff? it hangs, but doesnt consume cpu time
06:46:31 <bitonic> hiptobecubic: that's probably the "cleanest" segfault you can get
06:47:07 <dmwit> mcstar: You wrote let ref = f ref, with f a strict function.
06:47:11 <dmwit> -> loop
06:47:36 <dmwit> to evaluate ref, it must evaluate f ref; the first thing f does is inspect ref and you start from the top
06:47:44 <mcstar> dmwit: ok, but why doesnt it consume cpu time?
06:47:55 <dmwit> should do
06:47:57 * dmwit tests
06:49:19 <mcstar> can lambdabot accep that line?
06:49:20 <dmwit> neat
06:49:31 <Botje> mcstar: the GHC runtime detects you're evaluating ref as you're evaluating ref, so it just stops processing. there is nothing useful to be done anyway.
06:49:52 <mcstar> Botje: i suspect, this wasnt always the case/
06:49:55 <mcstar> ?
06:51:24 <dmwit> mcstar: You might like this one though.
06:51:35 <dmwit> let ref = unsafePerformIO (newIORef undefined)
06:51:40 <dmwit> writeIORef ref 16
06:51:45 <dmwit> readIORef ref :: IO [()]
06:52:19 <dmwit> (pick your favorite arbitrary value/type pair for lines 2 and 3)
06:52:42 <mcstar> dmwit: yeah, it works too
06:53:05 <dmwit> mcstar: I have to agree that I don't understand how your code doesn't loop, though. =)
06:53:20 <dmwit> Usually, when GHC detects loops that it doesn't need to do work for, it prints an exception.
06:53:33 <dmwit> Just sitting there not consuming CPU or doing anything else is quite unusual.
06:53:34 <Botje> mcstar: 'ghc blackhole' returns a paper where they extend blackholing for SMP systems
06:53:52 <mcstar> Botje: dmwit let the 2 of you work it out
06:54:05 <Botje> that was 2005, so that was probably implemented some time before that.
06:54:24 <dmwit> Botje: Black holes don't sit and do nothing. They exit the program with an exception.
06:54:34 <Botje> true
06:54:41 <dmwit> Oh!
06:54:46 <dmwit> Actually, untrue, in ghci, apparently.
06:54:53 <mcstar> dmwit: im just wondering, if doing this in lambdabot would halt or not, how doest lambdabot measure executing time?
06:54:58 <mcstar> execution*
06:55:37 <rwbarton> it uses wall clock time, i think, that's why sometimes even 2 + 2 can time out
06:55:49 <mcstar> ok, so thats safe
06:56:05 <mcstar> > let ref = unsafePerformIO (newIORef undefined)
06:56:06 <lambdabot>   not an expression: `let ref = unsafePerformIO (newIORef undefined)'
06:56:23 <mcstar> > undefined
06:56:25 <lambdabot>   *Exception: Prelude.undefined
06:56:38 <mcstar> can i use lambdabot in private?
06:56:46 <dmwit> yes
06:57:06 <dmwit> > let x = x in x
06:57:10 <lambdabot>   mueval-core: Time limit exceeded
06:57:38 <int-e> @quote fix
06:57:38 <lambdabot> thoughtpolice says: i believe #haskell established at one point or another that prefixing co- to things makes them exist in the bizarro-world
06:57:54 <frerich> hah
06:58:03 <dmwit> mcstar: There we go. Compile and run this file:
06:58:24 <hpaste> dmwit pasted “<<loop>>” at http://hpaste.org/70612
06:58:39 * dmwit feels less confused now
06:59:00 <dmwit> Botje++
07:00:29 <mcstar> dmwit: so ghc has some bottom detection
07:00:45 <dmwit> Yes.
07:00:58 <dmwit> I don't know why ghci doesn't use it in the same way.
07:02:14 <dmwit> http://hackage.haskell.org/trac/ghc/ticket/2786 <- it's a bug, apparently, Botje and mcstar
07:03:16 <mcstar> dmwit: im only 4 years late, better late than never
07:20:49 <BobFunk> can't seem to get lifted-base to install under the newest Haskell Platform and mongoDB seems to depend on it
07:21:24 <BobFunk> keep getting this: https://gist.github.com/3018232
07:32:34 <shapr> Is there some generalized way to convert any Haskell function into a spigot algorithm?
07:33:47 <roconnor> shapr: spigot algorithm?
07:34:10 <dmwit> I don't think so...
07:34:17 <dmwit> roconnor: productive function
07:34:36 <roconnor> shapr: let x = x in x
07:34:47 <d-snp> I am going to use unsafePerformIO
07:34:53 <shapr> I guess that's saying the same as "can I persuade a haskell function to generate a lazy list?"
07:35:02 <dmwit> exactly
07:35:03 <shapr> d-snp: You pollute your SOUL!
07:35:13 <shapr> d-snp: Er, I mean.. oh that's nice :-)
07:35:17 <d-snp> it is for science!
07:35:21 <Guest60606> stand back! im about to use unsafePerformIO
07:35:25 * shapr laughs
07:35:26 <Adeon> just put your standard safety helmet on
07:35:44 <Guest60606> you might cause monkeys to fly out of your nose
07:35:49 * dmwit dons his standard safety helmet of PROOF
07:36:04 <Gurragchaa> is it possible to create a haskell REPL that lets you create data constructors without loading them from a file?
07:36:14 <dmwit> Gurragchaa: ghci does this
07:36:25 <dmwit> Just upgrade to the newest GHC. =)
07:36:30 <Guest60606> nice
07:36:41 <Gurragchaa> Oh! Okay, I'll upgrade when I get home
07:36:43 <shapr> Gurragchaa: Yes, but the only way I've seen that done is when those tiny snippets were saved to a file and loaded without you seeing it.
07:36:49 <shapr> dmwit: really?
07:36:59 <dmwit> Well, you have to upgrade to HEAD.
07:36:59 <Gurragchaa> does it do function definitions on the fly too?
07:37:01 <dmwit> But yes.
07:37:06 <dmwit> And it will be included in the next release.
07:37:06 <Gurragchaa> i.e. without "let..in"
07:37:19 <dmwit> Gurragchaa: It's done that forever. Use let without in.
07:37:31 <Gurragchaa> ... oh, okay.  Thanks
07:38:31 <fmap> dmwit: I thought data declarations work since 7.4.1
07:39:00 <fmap> or mine ghci is special
07:39:06 <dmwit> err, yes
07:39:26 <dmwit> Apparently I typed "date Foo = Bar" during my test instead of "data ...".
07:42:06 <ssbr_> What is a good, fast tutorial for haskell? I was recommended real world haskell once, but it moved so slowly I abandoned it
07:42:20 <nand`> LYAH!
07:42:22 <ssbr_> at the same time, going my own way is annoying when I get very confused by things like "=>"
07:42:35 <nand`> LYAH covers all of the bare basics, after that you can pretty much go your own way
07:42:38 <ssbr_> Also I have experience in ocaml, scheme, etc.
07:42:39 <nand`> (from my experience)
07:42:45 <Botje> ssbr_: there's also the gentle introduction to haskell
07:42:48 <nand`> ssbr_: you can also read the haskell report :)
07:42:52 <dmwit> ssbr_: You want speed, you read the Gentle Introduction.
07:42:53 <nand`> (it's fairly readable)
07:42:59 <ssbr_> Botje: that doesn't sound like what I want at all :(
07:42:59 <Botje> it's anything but gentle, though
07:43:02 <dmwit> ?where gentle
07:43:02 <lambdabot> http://www.haskell.org/tutorial/
07:43:05 <Botje> ssbr_: look at it first :)
07:43:18 <ssbr_> man, why do people name things the opposite of what they are
07:43:24 <dmwit> ssbr_: It is gentle, if you are a researcher in programming languages. =D
07:43:40 <ssbr_> dmwit: I think I am, technically
07:43:40 <nand`> ssbr_: usually that's called ‘irony’. I don't know if it's applicable here
07:43:42 <ssbr_> just for the summer ;)
07:43:46 <dmwit> (Haskell's type system is pretty tame compared to what PL people do for a living.)
07:43:58 <Botje> they hunt wild type families?
07:44:05 <dmwit> =D
07:44:11 <dmwit> But they spare the women and children types. ;-)
07:44:18 <dmwit> Orphan instances are OK, too.
07:44:28 <Botje> dmwit: are you opped for a particular reason?
07:44:37 <dmwit> shapr's idea of a joke, I think =)
07:44:51 * shapr snickers
07:45:12 <dmwit> I don't even have enough permissions to deop myself, according to ChanServ.
07:45:18 <Clint> that doesn't make sense
07:45:24 <nand`> /mode -o dmwit
07:45:25 <nand`> ?
07:45:28 --- mode: dmwit set -o dmwit
07:45:30 <dmwit> neat
07:45:34 <t7> shapr: hows your gsoc thing coming along?
07:45:36 <Adeon> but now you are powerless
07:45:44 <nand`> dmwit fell into my trap
07:45:45 <nand`> clearly
07:45:57 <shapr> t7: I got the display class working yesterday! I'm excited!
07:46:15 <t7> linky
07:46:20 <shapr> t7: Means this web-enabled ghci can display text and svg outputs.
07:46:40 <t7> do you only get paid if you implement everything you promised?
07:46:48 <shapr> Not exactly, no
07:47:15 <shapr> The overall goal is to get a useful tool up for people to use.
07:47:56 <shapr> t7: http://c-71-207-252-122.hsd1.al.comcast.net:3000/hint.html
07:48:27 <shapr> t7: That's the demo on my desktop, and the source is here: https://github.com/shapr/ghclive/
07:48:39 <t7> nice
07:49:11 <shapr> As you can probably see, it uses byorgey's diagrams library to generate SVG output.
07:50:20 <shapr> t7: But it will also correctly display "show $ map (+1) [1..9]" as well.
07:51:31 <t7> not using snap! :O
07:51:47 <shapr> Nope, using scotty and hint and jquery-console
08:00:00 <mcstar> http://www.scannedinavian.com/~shae/antenna.jpg
08:00:09 <mcstar> someone isnt following instructions apparently ^^
08:00:28 <t7> or rotated the camera
08:00:45 <mcstar> j/k
08:01:02 <mcstar> btw, the product has a funny name
08:03:21 <nand`> shapr: I'm finding that site very hard to use; hints don't work on it, I can't see a caret and I need javascript enabled in the first place to do just about anything. Just wanted to mention it
08:03:55 <shapr> nand`: hints? Can you give me more info?
08:04:27 <t7> lol spj on a unicycle
08:05:16 <shapr> t7: Where'd you find that?
08:05:30 <t7> in your dir
08:05:35 <shapr> oh :-)
08:05:41 <nand`> shapr: oh, it's hard to explain - basically a firefox addon that lets me navigate using the keyboard by giving each element on the page an ID and lets me interact with them by pressing keys to enter certain hints modes; I can't seem to for example focus arbitrary inputs or click on the button with hints like I normally would, instead pressing ‘f’ focuses the input and gets seemingly ignored by the
08:05:42 <nand`> browser
08:06:14 <mcstar> hah, spj is on a unicycle
08:07:43 <shapr> nand`: I use firemacs for my keyboard navigation, but I admit, I don't have a good way to jump focus to the textbox generated entirely by javascript.
08:08:06 <shapr> nand`: Do you usually have a caret in your textboxes?
08:08:21 <nand`> shapr: I should note that normally even javascript-heavy pages work fine with hints and yes, I normally see a caret
08:08:28 <nand`> in normal <input> elements, for example
08:09:18 <shapr> nand`: Can you send me a link to the firefox addon?
08:09:57 <nand`> shapr: sure, it may not be entirely intuitive though: http://5digits.org/pentadactyl/
08:10:22 <Catnaroek> Hello. Is there any syntactic sugar for MonadPlus, similar to the do notation for Monads?
08:10:40 <Guest60606> mconcat
08:10:42 <Guest60606> and list
08:10:49 <Guest60606> er msum
08:11:00 <Catnaroek> Oh. Thanks.
08:11:01 <shapr> nand`: I'll try it out later today, thanks for the input.
08:12:52 <auastro> hiall, can any well informed fellow tell me what versions of gcc on macosx ghc is know to work with?
08:15:30 <merijn> auastro: The one shipping with Xcode (probably the most recent one, but some older Xcode's might still work?)
08:16:01 <merijn> auastro: What problem(s) are you running into? The installation on OSX is pretty straightforward
08:16:32 <auastro> merijn: thanks! I'm going to be the new maintainer for the macports ghc port
08:17:02 <merijn> auastro: Ah, I just get it from Platform
08:17:09 <merijn> Or the separate install
08:17:22 <merijn> I personally wouldn't really get GHC/platform from macports
08:17:26 <auastro> merjin: I'm wondering what variants I should add for gcc support
08:18:54 <auastro> merjin: also qq, I get some unexpected test failures in 7.4.2 mainly related to objective-c, is this a known thing?
08:19:44 <auastro> yeah, well I really don't like cabal and for some reason "cabal is not a package manager"
08:20:17 <auastro> so I'm hoping to write a tool to automate the conversion of packages from hackage into ports
08:20:39 <auastro> you know, so i can like, uninstall things
08:21:04 <auastro> also ghc from platform is a bit old
08:21:14 <auastro> I'm eagerly awaiting 7.6
08:21:31 <merijn> You can just unregister things from GHC and nuke the respective folder(s), I believe there's some tools to automate (parts) of this already
08:21:36 <auastro> but ghc on macports is badly unmaintained right now
08:21:58 <merijn> auastro: Eh, at most platform is one production release behind and I think the latest platform has the latest production release
08:22:37 <auastro> I'm not clued in, is there a separate is production release different to stable?
08:22:44 <mpwd> auastro:  Yeah, I had to switch to homebrew
08:22:49 <auastro> sorry, malformed
08:22:59 <auastro> is production separate from stable?
08:23:13 <merijn> I think 7.4 is the latest production GHC
08:23:20 <merijn> So, yes
08:23:20 <auastro> I should go to bed soon
08:23:35 <auastro> cool, well, I'm the new maintainer for ghc on macports
08:23:44 <auastro> so expect me here asking a lot of stupid questions,
08:24:01 <auastro> mainly because i'm new to maintaing ports, and most of the ghc build system
08:24:02 <merijn> Also, the reason GHC in platform lags behind latest is because the maintainers check whether the important hackage libraries compile with it
08:24:35 <merijn> A production compiler that doesn't compiler all major packages is a bit useless :p
08:24:57 <auastro> meijn: yeah haskell platform is awesome, but there are just a few problems
08:25:45 <auastro> I mostly use haskell platform, but this libedit/readline old iconv thing is totally borked
08:26:03 <auastro> so it's nice to have a ghc linked entirely to non-ancient versions of things from macports
08:26:15 <Cale> I'm not aware of there being a "production" GHC as far as that name actually being applied by the developers. There are released versions of GHC, and then there are snapshots, and then there's whatever's in the git repo.
08:26:42 <auastro> also I've discovered some linking bugs in the build system while setting up the port
08:27:15 <mpwd> Question: Data.Set.Monad appears to be implements with continuations.  Does anyone know if the author managed to resolve the issues with doing this, as presented in this thread? http://www.haskell.org/pipermail/haskell-cafe/2011-January/088110.html
08:27:50 <auastro> Cale: thanks, that's what I thought, I've been targeting 7.4.2 "stable" for the port
08:28:06 <mpwd> *implemented
08:29:17 <auastro> What percentage of ghc users are on mac do you guys estimate?
08:30:13 <Yarou> haha, i have ghc on a mac in a VM, does that count? :D
08:30:38 <mpwd> Yarou: I think so
08:31:02 <auastro> Yarou: I think so too, it also unfortunate that it's necessary
08:32:18 <auastro> anyway, I hope that by maintaing this package I can at least give something back to the community.
08:32:28 <ssbr_> Egh. So in an imperative programming language, I might do "return foo(bar())". In haskell, I might do "do { x <- bar; return (foo x) }". I'm a bit new to all this -- is that all there is? Can I write it the way I'd write it in a "normal" imperative programming environment?
08:32:54 <auastro> ssbr_: bar >>= foo
08:32:56 <DMcGill> bar <=< foo
08:33:08 <DMcGill> oops
08:33:09 <Guest60606> fmap foo x
08:33:11 <DMcGill> auastro is right
08:33:13 <ssbr_> auastro: egh, the case is too simple
08:33:28 <Guest60606> er fmap foo bar?
08:33:37 <auastro> can can 'lift' foo
08:33:40 <ssbr_> the actual case is do { s <- next ; return NFA { start = s, transitions = [...], outTransitions = [...]}
08:33:42 <ssbr_> }
08:34:03 <auastro> or use an 'applicative style'
08:34:10 <Cale> Either fmap foo bar or foo =<< bar depending on what the types are.
08:34:15 <auastro> I guess like foo <$> bar
08:34:21 <Guest60606> ssbr_: well the record syntax there isnt really a function
08:34:33 <ssbr_> Guest60606: no, it isn't
08:34:38 <DMcGill> can you have record sections in the same way tuple sections is an extension?
08:34:43 <ssbr_> I meant for the function to be a palceholder for an arbitrary expression
08:34:48 <Cale> ssbr_: oh, in that case, using record syntax at the same time is going to make that tricky :)
08:34:51 <ssbr_> but I forgot that of course the obvious answer is >>=
08:34:57 <Guest60606> ssbr_: well arbitrary expressions arent first class ;)
08:34:58 <Cale> ssbr_: what you have is probably best
08:35:04 <ssbr_> :(
08:35:10 <ssbr_> what I have feels like I'm programming in Ada
08:35:22 <ssbr_> Haskell is supposed to be the world's best imperative programming language
08:35:29 <Guest60606> write it however its easiest to read
08:36:03 <Cale> Which monad is that?
08:36:11 <Eduard_Munteanu> ssbr_: not really, though some claim it to be
08:36:14 <auastro> ssbr_: that's mostly I joke, the best Imperative programming is no imperative programming
08:36:15 <ssbr_> Cale: state monad
08:36:18 <mcstar> looks better in 2D
08:36:20 <DMcGill> ssbr_: records are weird, lots of people think that they don't really fit in Haskell
08:36:31 <however> ssbr_: if you post a longer code snippet (hpaste), maybe people will have more ideas for improvement
08:37:01 <ssbr_> however: I'm not sure if my code snippet even works at all, because I haven't tested it whatsoever. But give me a moment
08:37:31 <mpwd> DMcGill: XMonad uses them very, very heavily
08:37:49 <nand`> beats n-tuples
08:37:54 <nand`> when it comes to readability
08:38:04 <ssbr_> it's not XMonad, I can really do what I like here. I liked records because it gives names to fields, unliked regular ADTs or tuples
08:38:31 <Cale> ssbr_: yeah, it's really not so bad :P
08:38:37 <ssbr__> http://bpaste.net/show/zSc1lp5lTdZDas5v3lAD/
08:38:44 <auastro> ssbr_: using the Record{..} makes them a lot more palatable
08:38:46 <ssbr_> (sorry, was programming from another machine)
08:38:47 <mpwd> ssbr_: It's syntactic sugar over ADTs
08:38:52 <Guest60606> ADT = abstract data type right
08:38:55 <Guest60606> or algebraic
08:38:59 <ssbr_> algebraic
08:38:59 <auastro> ssbr_: it's a ghc extension
08:39:04 <mpwd> algebraic
08:39:11 <Guest60606> algebraic in haskell context
08:39:14 <Guest60606> otherwise
08:39:16 <ssbr_> it stands for both, but here I mean algebraic
08:39:30 <leimy> Anyone got a K-D tree implementation in Haskell? :-)
08:39:35 <ssbr_> mpwd: I like syntactic sugar that lets me type the names that are associated with values
08:39:53 <ssbr_> anyway, that bpaste up there is the (untested, no idea if it works) code
08:40:18 * hackagebot pandoc 1.9.4.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.4.2 (JohnMacFarlane)
08:40:45 <ssbr_> if you want to give style / methodology suggestions, I'd be happy to learn. Although I was going to get something working before I asked :)\
08:41:01 <DMcGill> ssbr:_ have you seen http://jrupac.roopakalu.com/blog/?p=349 ?
08:41:13 <Guest60606> are you sure you need imperative programming ;)
08:41:22 <Anon> Hi guys, is there anyone familiar with Data.Trie?   I would like to change keys from     prefix ++ [k] ++ rest    to     prefix ++ rest  .   Is there a better way other than deleting and re-inserting?
08:41:36 <Cale> ssbr_: you can write  statefulRegexpToNFA (Concat a b) = concatenateNFA <$> statefulRegexpToNFA a <*> statefulRegexpToNFA b
08:42:06 <ssbr_> Guest60606: No, but off the top of my head I couldn't think of a better way to represent the NFA than via an explicit graph representation
08:42:18 <ssbr_> I'm using the state monad to keep track of what labels I've used, so that I can create new ones
08:42:22 <ssbr_> it does seem ugly
08:42:35 <ssbr_> Cale: haha, alright :)
08:42:44 <mcstar> Anon: in a trie, the structure changes when keys are changed, i'd just make a new trie with the new keys
08:42:47 <ssbr_> that reads very well, too
08:42:50 <Guest60606> ssbr_: ah so you just need a unique name generator
08:43:10 <ssbr_> Guest60606: Right. Unless there's another worthy representation
08:43:40 <Anon> mcstar: so it would be delete and insert
08:43:42 <ssbr_> DMcGill: once, a long time ago. Again now -- it doesn't seem useful for what I want to do. Representing transitions as an arbitrary pure function loses me out on inspecting the transition table
08:43:54 <ssbr_> I want to implement things like NFA -> DFA transformations
08:43:55 <however> ssbr_: haskell allows updating records, you don't have to construct one from scratch every time (NFA { ... }). you can say "oldrecord { field = newvalue }", which gives a new record identical to oldrecord, except that field is updated
08:44:02 <Cale> ssbr_: If you had more pure functions for constructing NFAs from various other components already, you could do the same for the other cases.
08:44:11 <mcstar> Anon: if you want it done on all the keys, then just create a new trie
08:44:19 <ssbr_> however: Ah, nice. I was kinda missing that, from ocaml
08:45:13 <ssbr_> Cale: That's fair. I'd only written out concatenation separately because it is an important building block (see it used in Star, also)
08:45:14 <Anon> mcstar: I only needed to perform it on sub-branch of the trie (starting with 'prefix')
08:45:22 <Guest60606> a monad to produce unique values on demand without IO
08:45:36 <mpwd> ssbr_ : BNF grammar is another good representation. The translation BNF -> NFA does not need you to have fresh labels
08:45:49 <ssbr_> mpwd: BNF grammar?
08:45:51 <Anon> mcstar: it would be expensive to recreate the whole trie
08:46:10 <mpwd> ssbr_: Regex/NFA/"Backus Naur Form" grammar
08:46:14 <mcstar> Anon: ok, i get it now
08:46:23 <mpwd> ssbr_: All the same representation
08:46:23 <ssbr_> mpwd: I'm translating from an AST of a regular expression, like might be produced by a BNF grammar for parsing regexps. I'm not sure what you mean
08:46:34 <mpwd> Erm, all isomorphic representations
08:46:41 <ssbr_> mpwd: oh, right right
08:46:53 <ssbr_> the whole point of this is to express the isomorphism between Regexes and NFAs
08:46:56 <mcstar> Anon: im not sure it is possible more efficiently than delete/reinsert wo control over the inner workings of the trie
08:47:00 <ssbr_> by translating from the former to the latter
08:47:26 <however> ssbr_: for the future, hpaste iirc automatically runs hlint for you, giving some tips (like extra ghc warnings)
08:47:30 <Guest60606> Anon: modify = insert . delete, or similar ;)
08:47:38 <Guest60606> .:
08:47:42 <hpaste> Cale pasted “Regular” at http://hpaste.org/70613
08:48:37 <Cale> ssbr_: ^^ there's some code I wrote a long time ago while helping someone go through some papers on regular languages
08:48:39 <Anon> mcstar: ok, I'll stick with insert and delete for the moment, thanks
08:48:47 <however> ssbr_: also, if you get tired of "x <- blah ; y <- blahblah ; return SomeRecord { x = x, y = y }", you can enable record wildcards. that allows "x <- blah ; y <- blahblah ; return SomeRecord {..}". see http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
08:49:25 <however> that link also discusses record puns, which you may like (i.e. simplify "{ a = a }" to "{ a }")
08:49:25 <ssbr_> however: ooh, disgusting :P
08:49:57 <Guest60606> ssbr_: write it however its easiest to read ;)
08:50:04 <ssbr_> Cale: thanks
08:50:46 <Cale> ssbr_: It looks like I avoided generating unique names by just doing parity tricks. I do nothing to ensure that all numbers are contiguous.
08:51:10 <however> ssbr_: well you don't have to turn it on :-) but it's a purely syntactic simplification, nothing magic or disgusting as far as i can see. a compiler warning tells you if you forget to initialize a field (that's one of the weaknesses of haskell's records in general, nothing to do with wildcards)
08:51:36 <ssbr_> Bup.
08:51:59 <Guest60606> make sure you need records ;)
08:52:04 <ssbr_> I don't!
08:52:09 <Guest60606> good
08:52:56 <ssbr_> And yet I find them easier to read! how awful
08:53:05 <Guest60606> then use them
08:53:39 <Cale> Record syntax isn't perfect, but it's good.
08:53:41 <however> Guest60606: i don't think ssbr_ abused records. it all looks pretty sound afaict
08:53:47 <Cale> yeah
08:56:34 <auastro> does a segfault in runghc for pure haskell always mean a bug in GHC?
08:56:50 <auastro> no, only if it uses safe functions?
08:56:58 <Cale> Right.
08:57:16 <mcstar> cosmic radiation can do that too
08:57:30 <Cale> If you start using FFI stuff or unsafePerformIO, or unsafeCoerce, you can get segfaults.
08:57:50 <Guest60606> ffi stuff could mean 'a library'
08:57:57 <auastro> how does one go about debugging one of these segfaults
08:57:58 <Guest60606> headaches
08:58:18 <Cale> Debug.Trace.trace might help
08:58:34 <auastro> basically yesod segfaults on mac os x with ghc 7.4.2
08:58:41 <Cale> Usually there's a "most suspicious" part of any program
08:58:51 <Cale> Oh
08:58:53 <auastro> Cale: thanks don't really know where to start though :/
08:59:07 <Cale> Yeah, if you didn't write said program, then it's really hard
08:59:28 <mcstar> id suggest run it under valgrind
08:59:38 <mcstar> maybe you learn something
08:59:39 <Guest60606> valgrind on osx?
08:59:46 <auastro> Cale: unfortunately michael from yesod doesn't have a mac or know much about the platform
08:59:50 <mcstar> what is osx?
08:59:58 <leimy> mac os x
08:59:58 <Guest60606> osx isnt linux/bsd
08:59:59 <nand`> https://en.wikipedia.org/wiki/Template:Group-like_structures makes it seem like a Category is just a Monoid without the totality constraint, but this is possibly misleading: I can't seem to construct an arbitrary category from a partial monoid; eg. ({a,b},·,a) where a is the identity and b is an absorbtive element: a·a=a, a·b=b, b·a=b, b·b=b; Say I want to make b·b undefined, this can't be done using
09:00:00 <nand`> category theory: a is clearly an endomorphism, yet b can appear on both sides of it, so b must be one as well; which allows me to write b∘b. Confirm? I may want to mention this on the talk page for that template
09:00:13 <sclv> os x is based on bsd
09:00:15 <sclv> sorta
09:00:24 <Guest60606> so valgrind works on it
09:00:25 <Guest60606> ?
09:00:28 <auastro> ish
09:00:28 <sclv> sure
09:00:34 <Guest60606> came up earlier today didnt know
09:00:39 <auastro> it was kinda buggy
09:00:48 <sclv> lmgtfy: http://www.sealiesoftware.com/valgrind/
09:00:56 <auastro> I haven't looked at for a few months though
09:01:31 <Yarou> valgrind works on far more obscure platforms iirc, so i'm pretty sure it works on OS X
09:02:20 <auastro> Yarou: works is a scale, I've found mac os x to be a bit patchy
09:02:25 <auastro> YMMV
09:02:31 <Guest60606> Yarou: windows? xD
09:02:31 <parcs`> :t ap maybe . max
09:02:32 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
09:02:33 <lambdabot>       Expected type: (a -> b) -> b -> a -> b
09:02:33 <lambdabot>       Inferred type: (a -> b) -> (a -> b) -> a -> b
09:02:35 <DMcGill> @pl f qs s = g . h x y s $ qs
09:02:36 <lambdabot> f = flip ((g .) . h x y)
09:03:01 <ssbr_> Weird. I thought valgrind was only for linux. That's what the SQLite guy said, anyway (as part of his rant of why linux is the only platform worth using for C programmers)
09:03:10 <DMcGill> :r
09:03:12 <Adeon> I think it used to be
09:03:13 <DMcGill> oops lol
09:03:16 <Adeon> but it got better!
09:03:20 <nand`> Linux is the only platform worth using for sane human beings :)
09:03:32 <Yarou> i enjoy being insane
09:03:33 <merijn> Guest60606/sclv: OSX follows SUSv2 so is by definition a unix, it uses a significant portion of the old 4.4BSD userland too
09:03:40 <mcstar> linux is worth using if you like it
09:03:48 <mcstar> im telling you
09:03:53 <merijn> ssbr_: wut. valgrind predates linux
09:04:30 <auastro> I generally use linux servers, my laptop is a mac and my desktop is FreeBSD
09:04:35 <parcs`> :t maybe <*> max
09:04:37 <lambdabot> forall a. (Ord a) => a -> Maybe a -> a
09:04:38 <DMcGill> @pl f qs s = g (h (x y s) qs)
09:04:39 <lambdabot> f = (g .) . flip (h . x y)
09:04:43 <merijn> nand`: Until you turn 25+ and graduate and realise that you're getting to old with linux's BS
09:04:44 <parcs`> isn't that pretty
09:04:46 <auastro> there are pros and cons to all of them
09:04:46 <mpwd> Does anyone know of any performance issues with the package "set-monad" ?
09:05:03 <mpwd> (sorry for the repeat question)
09:05:11 <merijn> auastro: You must be the only FreeBSD desktop user that doesn't use BSD for his servers... :p
09:05:38 <auastro> merijn: auastro: yeah FreeBSD could stuff is still pretty green
09:05:45 <parcs`> mpwd: there was some discussion on the mailing list about set-monad, regarding performance
09:06:03 <auastro> merijn: *cloud
09:06:14 <mpwd> parcs`: Yeah, I found that
09:06:31 <merijn> cpercival is working on it for AWS, so that's nice
09:06:32 <mpwd> Looks like the author of set-monad wasn't part of the "Set as a Monad" discussion on haskell-cafe
09:07:22 <auastro> anyway, thanks for the advice if I get desperate I'll run valgrind
09:07:31 <auastro> or just use 7.0.4 :/
09:07:40 <mpwd> (I'm a tool who was taught that the power set functor is a monad in Category theory class before learning Haskell… so I am tempted to use set-monad even though it's considered bad)
09:07:44 <mcstar> whats worse than a segfault?
09:07:55 <auastro> half a segfault?
09:08:00 <mcstar> ergh
09:08:02 <auastro> …I don't know
09:08:09 <leimy> kernel panic
09:08:10 <merijn> mcstar: segfault in mmapped memory so you can see that segfaulting data structure in your core dump!
09:08:12 <mcstar> having valgrind segfault on you :)
09:08:22 <merijn> s/can/scan't
09:08:29 <merijn> I can't type...
09:08:29 <hpaste> DMcGill pasted “NFA to DFA” at http://hpaste.org/70614
09:08:41 <coppro> mcstar: asan :)
09:08:43 <mcstar> merijn::Maybe merijn
09:08:59 <Cale> nand`: http://mathoverflow.net/questions/76083/categories-presented-with-arrows-only-no-objects-partial-monoids
09:09:09 <Cale> (see first response)
09:09:33 <Cale> nand`: Basically, you can't just make it partial in any way at all
09:09:43 <nand`> Cale: oh my, the latex notation makes that impossible to read
09:09:48 <Cale> what?
09:10:00 <Cale> why?'
09:10:03 <nand`> “a set $D_\mathcal{C} \subseteq \mathcal C \times \mathcal C$ (the set of pair of composable arrows) and a map $\circ \colon D_\mathcal{C} \to \mathcal C$,”
09:10:07 <nand`> very hard for me at least
09:10:12 <Cale> oh
09:10:19 <Cale> It's supposed to appear typeset
09:10:46 <nand`> There must be some error
09:10:46 <mcstar> it doesnt happen immediately
09:10:56 <however> nand`: you may have to turn on javascript
09:11:12 <mcstar> mathjax?
09:11:14 <nand`> however: thanks, I had to allow googleapis.com
09:11:22 <MilosDj> hi all
09:11:42 <Cale> http://cale.yi.org/share/Screenshot-Categories%20presented%20with%20Arrows%20only,%20no%20objects:%20partial%20monoids%20-%20MathOverflow%20-%20Google%20Chrome.png
09:11:43 <MilosDj> can someone tell me why is floor :: (Integral b, RealFrac a) => a -> b
09:11:46 <DMcGill> ssbr_: see http://hpaste.org/70614 . I'm curious to what things you can do with a state table that you can't do with this.
09:11:50 <MilosDj> defined like that?
09:12:01 <MilosDj> but not like this
09:12:11 <MilosDj> floor :: (RealFrac a, Integral b) => a -> b
09:12:21 <nand`> Cale: thanks, that helps a lot
09:12:28 <mcstar> whats the difference?
09:12:30 <MilosDj> why are realFrac and Integral fliped?
09:12:32 <Cale> nand`: Do you have javascript disabled?
09:12:58 <nand`> Cale: yes; I also have the background forced to black and the font forced to 14 point terminus, with the result that the images were misaligned as well and nearly impossible to read (black on dark gray)
09:13:10 <Cale> MilosDj: There's no difference between those. The order doesn't matter.
09:13:22 <MilosDj> really?
09:13:28 <however> cale: ewww, hinting turned off ;-)
09:13:38 <Cale> however: What?
09:13:45 <however> MilosDj: to the left of the "=>", the order is unimportant
09:13:46 <nand`> Cale: he's talking about a font rendering feature
09:13:47 <Cale> however: I have hinting enabled.
09:13:50 <nand`> oh
09:14:29 <Cale> It's set to full hinting.
09:14:40 <MilosDj> so ghci uses alphabetic ordering ;)
09:14:41 <however> cale: hm ... i have hinting set to full blast (as god intended) and your screenshot looks strangely blurry
09:14:47 <MilosDj> wow, thanks
09:14:53 <Cale> Maybe the picture is being scaled?
09:15:38 <Cale> MilosDj: I think it will generally try to keep the order the same as the order in the declaration
09:15:45 <however> it's gotta be autohint. i like to have it enabled
09:16:24 <MilosDj> :t floor
09:16:25 <Cale> MilosDj: but in the case of class methods, you don't mention that class in the type signatures that you write for the methods
09:16:26 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
09:16:31 <luite> the 'w' in particular looks fatter here
09:17:14 <mcstar> im using freetype2-infinality if anyone cares, best hinting ever for gtk
09:17:59 <MilosDj> thanks Cale
09:18:00 <luite> i'm using os x so i'm used to slightly blurry fonts anyway
09:20:03 <mcstar> im using lucida grande fonts on linux
09:20:14 <mcstar> best fonts ever, leftover from my osx days
09:20:21 <dmwit> I suspect people here are complaining about the math-y parts being blurry.
09:20:31 <dmwit> This will not be affected by hinting, since those are images, not text.
09:20:51 <dmwit> Though there is some piece of software somewhere in the pipeline, certainly, generating those images.
09:21:00 <mcstar> the mathy part looks great on his screenshot, the others do not
09:21:26 <dmwit> In that case, I find your taste questionable. =)
09:22:18 <mcstar> go ahead, my taste is excellent and can withold any critique :)
09:22:36 <leimy> So let's say I have a map, which will have a constant set of keys and values, and should run in a constant space overhead.  That map is updated by concurrent processes.  If I don't access the map to view the data I've inserted, is there a way to keep a service running without spacel leaks in haskell?  I couldn't figure it out so I just read the values for each key out to a log as I produced them.  That only kind of solved the problem.
09:23:25 <merijn> leimy: Why does it space leak? How are you accessing the map?
09:23:59 <mcstar> dmwit: and no, the latex renderings are not images
09:24:12 <luite> does anyone know some haskell implementation of operational transformations or something similar?
09:24:14 <leimy> The program is a service that polls some hardware and builds up a map so that another client can come in and ask question and get a fairly recent answer as to the state of some microcontrollers.
09:24:37 <leimy> the problem is if the client doesn't visit every item thunks pile up that don't get evaluated for a particular key in the map.
09:24:44 <nand`> Cale: thanks for the link, by the way. that answers some questions I had been asking myself
09:24:46 <dmwit> luite: All the implementations I've heard about have been in other languages.
09:24:47 <leimy> they get resolved when I observe the value at a key.
09:24:57 <however> dmwit: for the record, the difference i noticed was in the text, mostly w, a, s, v ...
09:25:13 <merijn> leimy: Make the values strict? (Might waste computational time, dunno if that's an issue)
09:27:03 <luite> dmwit: yeah i haven't seen anything in haskell either. i think it could be useful to have something haskell-specific, you can be more general than just manipulating text buffers or xml trees
09:27:06 <leimy> But shouldn't the map also have to be strict?
09:27:15 <leimy> I guess that's my real question :-)
09:29:46 <DMcGill> @pl g q = (or) (f q) (g q)
09:29:46 <lambdabot> g = fix (liftM2 or f)
09:29:54 <DMcGill> @pl g q = (or) (f q) (h q)
09:29:54 <lambdabot> g = liftM2 or f h
09:33:17 <Eduard_Munteanu> leimy: do you have an actual leak?
09:33:36 <leimy> I did until I plugged it by logging everything I put into the map.
09:34:06 <leimy> ghc profling is pretty cool :-)
09:39:28 <jaxtr> ahh it's a wonderful day
09:39:49 <leimy> So basically I'm smart enough to spot the problem, understand that it's happening, but too dumb to understand where to add strictness appropriately to eliminate it.  Sometimes I wish I could build up an entire strictness barrier in Haskell.
09:39:50 <leimy> but the problem here really is a laziness update issue.
09:44:25 <kallisti> is there not an indefinite sleep command?
09:44:29 <kallisti> I've yet to find one.
09:45:02 <however> kallisti: forever (threadDelay 9999999) ?
09:45:12 <kallisti> I've been using maxBound
09:45:14 <kallisti> but that doesn't count..
09:46:26 <however> kallisti: i think that'll wait only 35 min or something, hence the "forever"
09:46:32 <lpsmith> yeah,  forever (threadDelay maxBound) works pretty well
09:47:12 <lpsmith> it's close enough to indefinite sleep on 32-bit systems
09:47:24 <lpsmith> err, 64-bit systems
09:48:05 <lpsmith> on 32-bit systems it wakes up every half hour or so, just to go back to sleep
09:48:30 <lpsmith> so it really doesn't use much CPU at all
09:50:31 <mm_freak> ok, i have implemented a working tagless G-machine now, but somehow the effort seems wasted given that the STG machine works totally different =/
09:50:39 <mm_freak> and appears to be much more complicated
09:50:58 <matthiasgorgens> In Data.Enumerator, how do I turn enumFile into something of the type Enumerator FilePath ByteString IO b
09:51:00 <matthiasgorgens> ?
09:51:33 <matthiasgorgens> EnumFile has type FilePath -> Enumerator BysteString IO b
09:51:51 <matthiasgorgens> (oops, I want something of the type Enumeratee FilePath ByteString IO b, note enumerator.)
09:51:58 <lpsmith> In a 64-bit environment,  threadDelay maxBound will sleep for 73,000 years,  so I think that's close enough to forever for most software purposes.
09:53:19 <lpsmith> oops, make that 292,227 years.
09:53:44 <mm_freak> matthiasgorgens: well, write the corresponding enumeratee
09:54:01 <DMcGill> it's shortsightedness like that causing all this IPv6 switch over trouble!
09:54:36 <lpsmith> I mean,  humans as a species haven't even been around that long.
09:55:04 <mm_freak> DMcGill: there is a big difference between 2^32 and 2^128…  IPv4 was designed based on considerations other than address space size
09:55:18 <mm_freak> back in the days traffic wasn't as cheap as today
09:55:46 <DMcGill> (There really needs to be some kind of "joke" punctuation mark)
09:56:57 <however> lpsmith: i still maintain it's not really the situation you'd want to get into. "the thing works great one one box, but on the other box, it works for half an hour and then mysteriously quits after giving no signs of trouble at all"
09:56:59 <DMcGill> speaking of though, when does the unix clock run out on 32-bit systems?
09:58:21 <lpsmith> however,  that's why I'd put a "forever" on it =)
09:58:41 <however> lpsmith: right. we seem to be agreeing vigorously then
09:58:45 <lpsmith> yup
10:03:09 <MilosDj> if there is someone with free time, can you please try to answer some of my lame questions here:
10:03:11 <MilosDj> http://stackoverflow.com/questions/11231859/haskell-numbers-and-type-system
10:03:59 <james-ubc> hi, im having a weird issue with ghci, when i import a lib it dosnt seem to actually do it... as in if i import Graphics.Gloss.Interface.IO.Game, the fuction game dosnt load
10:04:09 <MilosDj> yes, second set of q with -1 :D
10:07:51 <mcstar> james-ubc: if the imported module doesnt appear in the prompt, it couldnt import the module then
10:08:34 <james-ubc> mcstar: it appears in the prompt but i cant call it, it just says it's undefined
10:08:48 <james-ubc> mcstar:  only seems to be happening to gloss though
10:10:04 <james-ubc> like not in scope error
10:11:08 <mcstar> in ghci you can tab-complete on exported names
10:11:24 <mcstar> are you sure everything is installed?
10:11:37 <MilosDj> james-ubc: did you downloaded that lib just now?
10:12:18 <james-ubc> MilosDj: no, it was working last week...
10:12:19 <MilosDj> ghci must be restarted to be aware of new libs
10:12:37 <MilosDj> eh...
10:12:39 <james-ubc> and i rebooted/reinstalled gloss to make sure
10:12:42 <james-ubc> but sitll nothing
10:14:30 <mcstar> check the doc if that function is available at all
10:14:46 <james-ubc> mcstar: how do i do that?
10:15:12 <mcstar> well, i told cabal to build the docs, so i just open them in my interweb browser
10:17:30 <james-ubc> o.o
10:17:32 <james-ubc> wha
10:18:38 <matthiasgorgens> mm_freak: will try.
10:21:03 <ssbr__> Okay, records are pretty annoying for a multi-phase computation. Records from different phases of compilation either have to have different field names or be in separate modules. :(
10:22:12 <james-ubc> christ
10:22:37 <james-ubc> whats wrong @_@
10:23:21 <Taneb> family-tree-0.2 is out!
10:24:29 <mcstar> james-ubc: well, debug!
10:24:35 <mcstar> is the package installed?
10:24:43 <mcstar> ghc-pkg list
10:26:35 <mcstar> james-ubc: http://hackage.haskell.org/packages/archive/gloss/1.7.2.1/doc/html/Graphics-Gloss-Interface-IO-Game.html
10:26:41 <mcstar> i told you to look for the documentation
10:26:50 <mcstar> i dont see any functions named 'game' there
10:27:23 <Jeanne-Kamikaze> anyone familiar with happstack ?
10:27:34 <stepkut> Jeanne-Kamikaze: I am
10:27:49 <Jeanne-Kamikaze> I want to match the entire path in the get request, but I don't see how to do it
10:27:57 <Jeanne-Kamikaze> if I use 'path', it only matches the first string until /
10:28:23 <stepkut> you can do, askRq and rqUri to get the original url
10:29:21 <stepkut> not sure, off hand, but percent encoded stuff may not be decoded at that stage (since it makes it impossible to distinguish between %2F and /)
10:30:14 <james-ubc> Graphics.Gloss.Data.Point dosnt load the Point constructor
10:30:21 <james-ubc> or type
10:30:29 <stepkut> Jeanne-Kamikaze: you could also use, askRq to get the Request and rqPath to get the unconsumed path segments
10:30:33 * hackagebot family-tree 0.2 - Family trees with lenses  http://hackage.haskell.org/package/family-tree-0.2 (NathanVanDoorn)
10:30:51 <shirt> "This package provides the old locale library. For new code, the new locale library is recommended."
10:30:54 <shirt> where is the new locale library?
10:31:03 <stepkut> Jeanne-Kamikaze: as a [String], where everything has been decoded. It is a [String] so that / can appear inside a path segment
10:31:04 <Jeanne-Kamikaze> ok thanks, I'm reading the docs
10:31:09 <james-ubc> as in >:t (3,4):: Point
10:31:14 <james-ubc> dosnt work
10:31:30 <stepkut> Jeanne-Kamikaze: if the docs aren't clear, let me know and I'll submit a patch so that they are :)
10:32:12 <Jeanne-Kamikaze> the reference is good, the tutorial doesn't seem to mention any of this, at least in the first chapters
10:32:45 <stepkut> k
10:32:54 <Jeanne-Kamikaze> I also noticed there's uriRest
10:33:03 <stepkut> yeah
10:33:24 <stepkut> I think rqUri is the full original request, and uriRest is the unconsumed portion?
10:33:55 <dmwit> shirt: It's a trick. There is no new locale library.
10:33:57 <however> shirt: i think there is no "new locale" package. the documentation is wrong (sorry). the old locale thing is still all we have
10:34:59 <shirt> dmwit, however: ok. so just use the "old-locale" package?
10:35:07 <however> yep
10:35:13 <shirt> ok thanks :)
10:35:38 <mcstar> james-ubc: works here
10:40:37 <Jeanne-Kamikaze> stepkut, indeed uriRest is the unconsumed part
10:40:52 <Jeanne-Kamikaze> I got it tamed now
10:41:26 <Jeanne-Kamikaze> a web server is 30 lines of code, not bad
11:05:38 * hackagebot git-annex 3.20120629 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120629 (JoeyHess)
11:08:10 <sm> go git-annex
11:13:31 <aristid> sm: i suppose i should have filed a bug for it (sorry, joeyh), but when i was trying out git-annex, it didn't work on os x at all, but without error messages. everything just silently failed. that kinda eroded my trust in it
11:15:38 <nobdraisentone> How can I rewrite `(\(a,b) (c,d) -> (a+c, b+d))' ?
11:16:09 <DMcGill> @pl f (a,b) (c,d) = (a+c, b+d)
11:16:10 <lambdabot> f = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
11:16:36 <DMcGill> I think your version is better
11:16:37 <fmap> > (2,3) + (4,5)
11:16:39 <lambdabot>   (6,8)
11:17:17 <mcstar> what do you need for that?
11:17:52 <fmap> Num instance for tuples
11:18:07 <mcstar> yeah, but from where to import?
11:18:36 <nand`> NumInstances
11:18:49 <navaati> :t curry $ uncurry (+) *** uncurry (+)
11:18:51 <lambdabot> forall a a1. (Num a, Num a1) => (a, a) -> (a1, a1) -> (a, a1)
11:19:13 <navaati> nobdraisentone: this ?
11:19:24 <navaati> ah, no
11:19:26 <navaati> wrong
11:20:23 <jfischoff> > (3, 1) * (3, 1)
11:20:24 <lambdabot>   (9,1)
11:20:40 <jfischoff> > (3, 1) <*> (3, 1)
11:20:41 <lambdabot>   Ambiguous type variable `t' in the constraints:
11:20:41 <lambdabot>    `GHC.Num.Num t'
11:20:41 <lambdabot>      ari...
11:20:43 <nand`> mtl update, time to rebuild 79 packages..
11:23:32 <mcstar> > (sin * sin + cos * cos) 5435355
11:23:33 <lambdabot>   1.0
11:23:38 <mcstar> hah
11:23:56 <fmap> > first getSum $ (Sum 0,(+)) <*> (Sum 1,2) <*> (Sum 3,4)
11:23:57 <lambdabot>   (4,6)
11:24:01 <navaati> :t curry $ let split f = f *** f in (split fst &&& split snd) >>> split (uncurry (+))
11:24:02 <lambdabot> forall b. (Num b) => (b, b) -> (b, b) -> (b, b)
11:24:33 <Taneb> @djinn a -> a
11:24:34 <lambdabot> f a = a
11:24:43 <Taneb> @djinn (a -> b) -> a -> b
11:24:43 <lambdabot> f a = a
11:24:55 <Taneb> @djinn (a, b) -> a -> b -> c -> c
11:24:56 <lambdabot> f _ _ _ a = a
11:25:07 <Taneb> @djinn (a, b) -> (a -> b -> c) -> c
11:25:08 <lambdabot> f (a, b) c = c a b
11:25:17 <startling> wow, what a smartass
11:25:33 <mcstar> djinn?
11:25:46 <Taneb> Generates a function from a type signature
11:25:50 <Taneb> It's pretty niave though
11:25:51 <startling> yeah
11:25:57 <navaati> (curry $ let split f = f *** f in (split fst &&& split snd) >>> split (uncurry (+))) ((3,4),(5,2))
11:25:59 <startling> f _ _ _ a = a is pretty funny
11:26:09 <Taneb> I forgot brackets
11:26:15 <navaati> > (curry $ let split f = f *** f in (split fst &&& split snd) >>> split (uncurry (+))) ((3,4),(5,2))
11:26:17 <lambdabot>   Overlapping instances for GHC.Show.Show
11:26:17 <lambdabot>                              (((t, ...
11:26:40 <Taneb> @djinn (a -> b) -> (b -> d) -> (a -> d) -> (d, d)
11:26:41 <lambdabot> -- f cannot be realized.
11:26:41 <navaati> wut ?
11:26:51 <startling> I've got a bunch of bytes that I want to bit-twiddle and stuff. should I use data.bytestring.char8 or what?
11:26:52 <Taneb> @djinn (a -> b) -> (b -> d) -> (a -> d) -> a -> (d, d)
11:26:53 <lambdabot> f a b c d = (b (a d), c d)
11:27:13 <nand`> startling: can't use the word8 instance for bit-twiddling?
11:27:19 <nand`> word8 functions*
11:27:42 <startling> nand`, I've basically got a file that I want to access bytewise
11:28:00 <startling> isn't Word8 for a single byte?
11:28:26 <nand`> startling: the normal Data.ByteString API sounds perfect for that
11:28:44 <nand`> Word8 is for a single byte yes, assuming byte = 8 bits
11:29:10 <startling> yeah.
11:29:12 <nand`> Char8 will just do an ord/chr round-trip + truncating
11:29:14 <startling> neat, thanks
11:29:17 <nand`> not exactly what you need here
11:29:29 <nand`> the Char8 is really just there for when you want to be quick and dirty
11:29:38 <Taneb> I'd say Data.Bits is the best bet
11:29:56 <startling> nand`, how do I do ord/chr to stick something into a bytestring?
11:30:42 <nand`> startling: I mean the [Char] -> ByteString function differs from the [Word8] -> ByteString (and their corresponding reversals) by mapping chr/ord over the list
11:31:13 <nand`> (+ presumably some additional functions to get from Int to Word8 and vice versa)
11:31:17 <startling> ah
11:31:43 <startling> Taneb: Data.Bits looks good, thanks
11:32:01 <Taneb> :)
11:32:03 <Taneb> Glad to help
11:33:23 <Taneb> I've also just realised I'm still using family-tree 1.1
11:33:27 <Taneb> I write that package
11:34:27 <govindmanian> Hi all: Just installed Haskell (64 bit, on Mac Lion) and I get an error at the end. Interestingly, /Library/Frameworks/GHC.framework exists and I can load ghci and do things. Any experience with this error? Thakns!
11:34:43 <startling> govindmanian, what does the error say?
11:34:43 * shapr boings randomly
11:34:45 <shapr> YAY CODE!
11:35:15 <govindmanian> "The Installation Failed: The installer encountered an error that caused the installation to fail. Contact the software manufacturer for assistance."
11:35:16 <shapr> Taneb: Is family-tree for genealogy?
11:35:36 <govindmanian> (Also interestingly: running 32-bit Haskell on a 64-bit machine and doing ceiling $ -1.2 gives a seg fault)
11:35:55 <govindmanian> startling ^
11:36:19 <shapr> govindmanian: whoa, craziness
11:36:26 <Taneb> shapr, yes
11:36:38 <startling> govindmanian, weird. is this 7.4.x?
11:36:41 <nand`> “The installer encountered an error” <- the *BEST* kind of error
11:36:44 <shapr> Taneb: That's cool, I didn't know Haskell had any genealogy tools at all.
11:36:54 <nand`> I did not realize Haskell had such Microsoftiness in it
11:37:01 <nand`> s/Haskell/GHC + Haskell Platform/
11:37:04 <Taneb> shapr, yeah, I saw that, and I made one
11:37:31 <govindmanian> startling Latest build I think
11:37:49 <govindmanian> shapr Indeed. Can/should I open a bug somewhere?
11:38:35 <govindmanian> startling http://hackage.haskell.org/platform/mac.html got it from here
11:38:54 <Taneb> shapr, I'm slowly making it perfect
11:39:41 <nand`> Taneb: “head1”, “head2” <- this seems arbitrary, why not “head :: [Int]” ?
11:39:51 <nand`> well, a better name obviously
11:39:52 <shapr> govindmanian: perhaps? Have you asked on #ghc about that?
11:40:12 <Taneb> nand`: because people only have two parents
11:40:13 <nand`> unless I'm misunderstanding the purpose of head1/head2
11:40:20 <Taneb> Maybe (Int, Int)
11:40:26 <govindmanian> shapr Didn't know there was such a channel. I'll do that now.
11:40:44 <fmap> > let f = ((join (***) sum . (map fst &&& map snd)) .) . (. return) . (:) in f (1,2) (3,4)
11:40:46 <lambdabot>   (4,6)
11:41:07 <Taneb> Aaah
11:41:40 <nand`> Taneb: Ah, I see. It seems to be a trend in your library that only very simple families can be represented; with only one relationship and a maximum of two people in a relationship; or is the intention here to use multiple families to consider families which, say, broke up and reformed?
11:41:55 <nand`> Also what about three-way relationships; say between a man and two women, where different children have differing mothers
11:41:56 <Taneb> nand`, yes, that is the intention
11:42:15 <nand`> would those be two distinct families, each considered as the subset spawned from that particular pair?
11:42:15 <Taneb> A family is for associating parents with children primarily
11:42:20 <nand`> I see
11:42:39 <Taneb> So, children have a maximum of two parents
11:42:45 <nand`> yeah, makes sense - biologically, you can only have two parents, and this is genealogy after all
11:43:00 <Taneb> I may change it so it can represent, e.g., adoption
11:44:55 <nand`> Taneb: How would I, say, write parents :: FamilyTree -> Person -> (Maybe Person, Maybe Person) ?
11:45:03 <ssbr__> Is it possible to define a type like, say, Maybe, except that it can only contain instances of Eq?
11:45:05 <Taneb> With difficulty
11:45:10 * ssbr__ is searching and can't find this :/
11:45:20 <Taneb> Iterate over the family intmap, probably
11:45:32 <nand`> Taneb: it seems to be like the primary purpose of a genealogy type would be tracing back a person's lineage
11:45:45 <Taneb> This is very preliminary
11:45:49 <nand`> I see
11:45:54 <startling> ssbr__, you could make a type and then make a little function that only takes eqs
11:46:00 <roconnor_> @go haskell constructor constraints
11:46:01 <lambdabot> Maybe you meant: google googleit do
11:46:10 <roconnor_> @google haskell constructor constraints
11:46:12 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2005-September/011402.html
11:46:12 <lambdabot> Title: [Haskell-cafe] Constructor constraints
11:46:42 <ssbr__> startling: that's the only way?
11:46:48 <roconnor_> ssbr__: you can write data Eq a => EqMaybe a = EqJust a | EqNothing
11:47:02 <ssbr__> roconnor_: Ack, there we go
11:47:09 <Eduard_Munteanu> But that's usually considered evil.
11:47:10 <ssbr__> I wrote data (Eq a) => ... . Silly me. :/
11:47:14 <Taneb> nand`, so yeah, this is probably gonna be a life project for me
11:47:15 <roconnor_> ssbr__: but it doesn't actually really do what you want it to do, and isn't very useful in practice.
11:47:18 <nand`> that's invalid in haskell 2011, mind
11:47:21 <ssbr__> roconnor_: Oh?
11:47:44 <ssbr__> Eduard_Munteanu: Well, I'm defining an NFA. Obviously without equality comparisons it can't ever be run. :(
11:47:55 <ssbr__> so this is a real constraint on the types of things that can be used with NFAs
11:48:14 <nand`> Taneb: wouldn't it be boring to work on one project your whole life?
11:48:18 <ssbr__> roconnor_: What does it do differently than what I'd expect?
11:48:46 <roconnor_> ssbr__: it doesn't automatically propogate the constraint to functions that use the data type. It just adds the constraint to the constructor IIRC.
11:48:47 <nand`> ssbr__: requires you to put the Eq a constraint on every function dealing with that type
11:48:54 <Eduard_Munteanu> In a way this kinda sucks.
11:49:16 <edwardk> ssbr_: the constraints on data types were removed from the language recently. they only enforce that the terms you put into the data type have to satisfy that instance, they don't empower you to use that instance later
11:49:16 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
11:49:17 <ssbr__> Oh. How awful.
11:49:17 <nand`> id `asAppliedTo` EqNothing :: Eq a => EqMaybe a -> EqMaybe a -- example
11:49:21 <Taneb> nand`, I'm going to do other things, but this I will get brilliant
11:49:22 <edwardk> ssbr__: they are just a bad idea
11:49:38 <ssbr__> edwardk: not a bad idea. Bad consequences in haskell, apparently.
11:49:46 <nand`> ssbr__: the general consensus is that you shouldn't limit what your data type can contain; what matters is that the functions you expose use it correctly. If you want to enforce some invariant, hide the constructor
11:50:00 <edwardk> ssbr__: they used to have a place a long long time ago, back when you used to need them for strictness annotations.
11:50:08 <edwardk> ssbr__: then they remained in vestigial form
11:50:08 <mcstar> can the mathy people tell me what is that symbol similar to less-than? http://mathworld.wolfram.com/SharkovskysTheorem.html
11:50:13 <edwardk> ssbr__: no, still a bad idea. ;)
11:50:25 <edwardk> ssbr__: in haskell you just move the constraint to the use site
11:50:30 <ssbr__> edwardk: Why?
11:50:44 <ssbr__> edwardk: if the constraint could be placed on the type, once, instead of in a bunch of use sites -- why is that bad?
11:50:48 <edwardk> ssbr__: take for example the data type from complex from Haskell 98
11:50:50 <Eduard_Munteanu> mcstar: I think it's just an arbitrary ordering
11:50:57 <ssbr__> especially if the constraint is fundamental to what the type represents
11:51:06 <edwardk> data RealFloat a => Complex = !a :+ !a
11:51:09 <edwardk> er
11:51:16 <edwardk> data RealFloat a => Complex a = !a :+ !a
11:51:21 <Eduard_Munteanu> Well, this stuff seems much cleaner in Agda, although you do end up having to re-specify constraints.
11:51:27 <edwardk> this ensures that you can only put in things that satisfy realfloat
11:51:32 <mcstar> edwardk: so just for not to confuse with the usual one?
11:51:54 <edwardk> but this immediately precludes the use instances for Complex to make it a Functor, Traversable, etc.
11:51:55 <roconnor_> mcstar: the article is definining a new order for the numbers.  So it is irreflexive and transitive and asymetric.
11:51:57 <mcstar> just because ive never seen that symbol before, but otherwise makes sense
11:52:03 <Eduard_Munteanu> mcstar: wrong edward? :)
11:52:04 <edwardk> even though those types are otherwise perfectly meaningful
11:52:30 <Eduard_Munteanu> mcstar: yeah, that's my guess
11:52:34 <nand`> mcstar: http://www.fileformat.info/info/unicode/char/227a/index.htm
11:52:36 <nand`> no idea if that helps
11:52:38 <nand`> but there you go
11:52:43 <edwardk> ssbr__: if we had a more sane numeric tower, you could use Complex for gaussian integers, even though Int isn't a 'RealFloat' as well
11:52:57 <mcstar> nand`: actually it does
11:53:08 <edwardk> ssbr__: in practice, moving the constraints isn't that much of a burden and they are usually moving into other instance heads anyways
11:53:08 <mcstar> i can pronunce it: precede
11:53:09 <edwardk> now
11:53:14 <edwardk> all that said, you _can_ do what you asked for
11:53:23 <Eduard_Munteanu> mcstar: that's \prec in latex according to http://detexify.kirelabs.org/classify.html
11:53:31 <edwardk> you can make data Foo a where Foo :: Eq a => a -> Foo a
11:53:33 <ssbr__> edwardk: This philosophy seems oddly sided in favor of flexibility instead of safety
11:53:35 <edwardk> using a GADT
11:53:39 <nand`> mcstar: that's always a good thing. It's awesome seeing some symbol in a textbook and having no idea how to pronounce it. :)
11:53:41 <ssbr__> which isn't how I viewed haskell
11:53:42 <edwardk> ssbr__: what safety is lost?
11:53:51 <edwardk> you actually lose a LOT of safety with the GADT i just described
11:54:05 <edwardk> because it makes your code a LOT more brittle
11:54:08 <ssbr__> edwardk: if the type cannot meaningfully represent anything that does not satisfy the typeclass constraint, then you can accidentally produce useless values without haskell warning you away
11:54:17 <ssbr__> edwardk: e.g. in the case of NFA
11:54:21 <edwardk> if you decide you want to work with something more refined than your previous constraint you wind up wasting time making up an entirely NEW data type
11:54:40 <edwardk> ssbr__: you can't do anything with those useless values. the types don't check
11:55:00 <edwardk> consider taking a Complex Float  to a Complex Double
11:55:01 <ssbr__> edwardk: you can pass them around to virtually anything, except a function that actually does work and runs the automaton
11:55:09 <nand`> ssbr__: the thing is; ‘creating’ an illegal value isn't a problem in Haskell. As long as the functions that actually do meaningful things with it have the constraint, you still can't apply it to your malformed data
11:55:14 <edwardk> to do it now, you have to go through and write a one-shot combinator to do it
11:55:21 <nand`> creating an ‘illegal’ *
11:55:38 <nand`> and a value with no functions to apply to it is essentially meaningless
11:55:51 <ssbr__> I guess you're right.
11:56:02 <ssbr__> (I don't mean that flippantly. That came out wrong. I just hadn't thought it through.)
11:56:17 <edwardk> with the type we have for Complex now, if it had a Functor you could just fmap realToFrac
11:56:18 <nand`> (which actually makes the Eq a => EqMaybe a thing seem like not a half-bad idea: prevents you from operating on values that don't have the eq constraint, at all)
11:56:27 <nand`> it just makes typing type signatures slightly more clumsy
11:56:40 <saml> hey, i have a very large xml file. it's two lines. i want to indent.
11:56:45 <saml> pretty print. how do i do that?
11:56:55 <saml> it's about 100GB
11:57:06 <nand`> saml: seq?
11:57:18 <nand`> uh, not seq
11:57:22 <nand`> some unix utility I'm thinking of
11:57:35 <nand`> awk
11:57:46 <nand`> oh, wait; I misunderstood
11:57:59 <nand`> I thought you wanted to indent every line by two indentations :)
11:58:04 <Taneb> Isn't it annoying when a function that'd never be actually used doesn't exist?
11:58:23 <edwardk> ssbr: given a lot of experience with the two extremes, ultimately working with constraints at usage sites actually yields a.) better performing code, because you aren't tupling up everything with redundant dictionaries, and only pass them into the few functions that use them b.) more flexible code, because you get data types that are more able to be reused
11:58:37 <nand`> Taneb: they exist, it's just that nobody has forced them yet
11:58:37 <saml> give me one liner
11:58:48 <saml> that reads file, parses xml, pretty prints it to stdout
11:58:55 <saml> or to other file
11:59:01 <Taneb> foldMapWithKey :: Monoid m =>  (Int -> a -> m) -> IntMap a -> m
12:00:24 <edwardk> ssbr__: it does take a bit of getting used to, but its a logical consequence of haskell separating classes from the data they manipulate
12:01:32 <ssbr__> edwardk: "separating"? I still don't view typeclasses as all that different from, say, abstract base classes in a (multiply-inheriting) Java-style language.
12:02:05 <edwardk> ssbr__: consider the data type      newtype Compose f g a = Compose (f (g a))
12:02:06 <ssbr__> except they lack field definitions
12:02:24 <edwardk> ssbr__: are f and g supposed to be Functors, Foldable, Applicative, Traversable?
12:02:25 <edwardk> well
12:02:27 <edwardk> if you don't pick then
12:02:39 <edwardk> instance (Functor f, Functor g) => Functor (Compose f g)
12:02:47 <edwardk> instance (Foldable f, Foldable g) => Foldable (Compose f g)
12:02:50 <edwardk> etc
12:02:53 <jfischoff> saml:  fmap (fmap ppTopElement  .  parseXMLDoc) . readFile
12:03:10 <edwardk> it can be all of those things, limited by the powers granted to it by f and g
12:03:51 <edwardk> if you entangle this thing with specific restrictions on f and g, now yes, you gain some flexibility at the use site, but it comes at the expense of having to make entirely new data types for all possible combinations of class restrictions!
12:03:58 <saml> jfischoff, thanks
12:04:04 <ssbr__> edwardk: OK, I didn't know this was a thing that happened
12:04:13 <ssbr__> I have basically no idea what you're referring to :(
12:04:28 <saml> is there haskell shell that i can run that?
12:04:38 <saml> something like bash
12:04:47 <edwardk> ssbr__: the short version is 'trust us its better this way' ;)
12:04:48 <jfischoff> saml: sure I just ran it in ghci
12:05:07 <jfischoff> saml: you need to import the Text.XML.Light package
12:05:29 <jfischoff> saml: which means you need to have it install ;)
12:05:45 * hackagebot cmdtheline 0.1.1 - Declaritive command-line option parsing and documentation library.  http://hackage.haskell.org/package/cmdtheline-0.1.1 (EliFrey)
12:06:37 <jfischoff> edwardk: Thanks for the optparse-applicative suggestion. Worked out well.
12:06:59 <edwardk> jfischoff: i was just thinking about releasing a library for that ;)
12:07:16 <jfischoff> oh on top of it?
12:07:18 <edwardk> using lenses and a less declarative option syntax to be less magic
12:07:40 <edwardk> so you didn't have to reason about where in your option structure the options occurred
12:08:19 <jfischoff> ah right, okay I see what your saying
12:08:45 <edwardk> came up in a discussion the other day
12:08:45 <jfischoff> instead of Config <$> … you would have a series of lenses in any order of something like that
12:08:51 <edwardk> yeah
12:09:07 <jfischoff> how is the polylens stuff going in general
12:09:15 <jfischoff> I'm definitely excited about it
12:09:36 <edwardk> config = do flag foo "foo" "Enable Foo"; flag bar "bar" "Enable Bar"
12:09:36 <roconnor_> edwardk: is there an package with indexed store comonad?
12:09:57 <edwardk> roconnor_: nope, i have a module full of code for them but there is an awkward sticking point
12:10:12 <edwardk> in particular the ComonadApply equivalent and Apply from Applicative cease to coincide
12:10:42 <roconnor_> maybe for clone it is easier to write a special purpose one anyways, like Getter and Setter.
12:10:53 <edwardk> yeah
12:11:35 <roconnor_> I realized today that type synomyms won't survive composition, but maybe that isn't so bad in practice.
12:11:44 <edwardk> its not that bad
12:12:03 <edwardk> you get at least the warning that Getting != Setting more or less
12:12:15 <sclv> edwardk: btw what ever happened to your reducers stuff with compression algos baked in?
12:12:19 <sclv> like reducertransformers or whatever?
12:12:23 <sclv> it was in monoids 0.01
12:12:43 <edwardk> http://hackage.haskell.org/package/compressed has the LZ78 monoid/generator and run length encoder
12:13:12 <edwardk> now, 'reducers' subsumes 'monoids'
12:13:16 <sclv> thanks -- its hard to keep track of the great categories diaspora :-)
12:13:18 <roconnor_> edwardk: I'm thinking of making a H98 lens-family library and a rank-2 layer on top.
12:13:20 <edwardk> its based on semigroup reducers
12:13:34 <roconnor_> is LZ78 patent free now?
12:13:35 <edwardk> roconnor_: thats baically what dan burton did with polylens
12:13:41 <edwardk> roconnor_: '78' ;)
12:14:10 <edwardk> > 78+17 < 112
12:14:11 <lambdabot>   True
12:14:50 <roconnor_> > 1978 + 17 < 19112
12:14:51 <lambdabot>   True
12:15:30 <edwardk> =P
12:16:04 <roconnor_> drb says his synonyms are not rank2
12:16:25 <sclv> lool
12:17:21 * edwardk hangs his head
12:18:44 <roconnor_> this library surprisingly sparse
12:19:28 <roconnor_> I guess we could add (^$)
12:20:42 <roconnor_> making partial-lens families requires a Pointed Functor class.
12:21:01 <roconnor_> Oh right, the whole state monad stuff is missing
12:21:15 <roconnor_> ... I'm not sure the state monad likes the type of its state changing though.
12:29:53 <ladr0n> so, the signature for foldl is foldl :: (a -> b -> a) -> a -> [b] -> a
12:30:04 <roconnor_> @type foldl
12:30:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:30:17 <ladr0n> but i'm having a really hard time coming up with any examples where a and b are not the same type
12:30:44 <ladr0n> can anyone think of one?
12:30:50 <Cale> > foldl (flip (:)) [] [1,2,3,4,5]
12:30:52 <lambdabot>   [5,4,3,2,1]
12:31:05 <startling> hm, is there an easy way to turn a String into a list of Word8s?
12:31:08 <roconnor_> @src reverse
12:31:08 <lambdabot> reverse = foldl (flip (:)) []
12:31:15 <Cale> > foldl (\m d -> 10*m + d) 0 [1,2,3,4,5]
12:31:16 <lambdabot>   12345
12:31:42 <Cale> oh, those are the same, of course :)
12:32:12 <fmap> startling: map c2w
12:32:19 <ladr0n> @type flip
12:32:21 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
12:32:51 <Cale> > foldl (\r x -> concat ["(f ", r, " ", show x,")"]) "z" [1,2,3,4,5]
12:32:52 <lambdabot>   "(f (f (f (f (f z 1) 2) 3) 4) 5)"
12:33:08 <Cale> There they're different.
12:33:20 <startling> fmap, where's c2w? and that's not strictly what I want -- multibyte characters should make more than one Word8
12:33:26 <Cale> ladr0n: the prelude one is  flip f x y = f y x
12:33:40 <startling> @hoogle Char -> [Word8]
12:33:40 <lambdabot> Data.Data gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]
12:33:41 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
12:33:41 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
12:33:51 <Cale> > foldl (\xs x -> x : xs) [] [1,2,3,4,5]
12:33:52 <lambdabot>   [5,4,3,2,1]
12:33:59 <Cale> ^^ another way to write the same thing
12:34:26 <Cale> http://cale.yi.org/share/Folds.svg
12:34:47 <startling> so presumably I want concatMap something
12:34:49 <Cale> ^^ see here for a graphical approach to what foldl and other folds do
12:34:53 <nand`> > foldl f z [1,2,3,4,5]
12:34:54 <lambdabot>   f (f (f (f (f z 1) 2) 3) 4) 5
12:34:54 <fmap> startling: it's in Data.ByteString.Internal
12:34:56 <startling> is there a thing that turns a Char into a list of Word8s?
12:35:08 <nand`> startling: you'd have to use some encoding for that
12:35:21 <nand`> startling: I'd guess unpack . encodeUtf8 should be pretty close to what you want
12:35:52 <Cale> startling: There are functions which turn String or Text into ByteString which you could use.
12:37:16 <ladr0n> Cale: okay, in the first example you gave the (flip (:)) part is just [a] -> a -> [a]
12:37:18 <Cale> http://hackage.haskell.org/package/utf8-string-0.3.7
12:37:26 <Cale> ladr0n: right
12:37:33 <ladr0n> Cale: oh, wait, i get it.
12:37:49 <Cale> [a] and a are not the same type :)
12:37:50 <ladr0n> Cale: so [a] is "a", and a is "b". they are two types
12:37:56 <ladr0n> Cale: yeah
12:38:05 <ladr0n> Cale: that catches me off-gaurd sometimes
12:38:14 <hc_> hi, is there any way to build a lazy list of strings by doing something like: 'lazyList = sequence $ repeat (hGetLine handle)'?
12:38:43 <Cale> hc_: fmap lines (hGetContents handle)
12:38:44 <parcs`> hc_: fmap lines . hGetContents
12:39:07 <hc_> thanks! :)
12:39:18 <Cale> hc_: You'll have to actually run that action to get the list though
12:39:29 <Cale> hc_: also, make sure you don't ever close the handle after that point
12:39:52 <Cale> hc_: It becomes the responsibility of hGetContents to close it when you reach the end of the input.
12:40:30 <nand`> what if the handle by its very nature will never have an EOF?
12:40:31 <Cale> (it can be hard to control resource usage of handles when doing this, but in cases where you're not opening many handles, it can be handy)
12:41:03 <hc_> i'll keep that in mind. any hints btw why my solution doesn't work? is it because hGetLine is not lazy?
12:41:04 <Cale> nand`: Then the only way it'll close is sometime after the list you get is GCed.
12:41:11 <nand`> ah, right
12:41:20 <Cale> hc_: It's because you're running all those actions up front.
12:41:25 <Cale> IO actions execute in order
12:41:34 <hc_> ah, right
12:41:39 <Cale> You need some magic to defer them to the time at which things get evaluated
12:41:52 <Cale> hGetContents packages up some of that magic
12:41:57 <hc_> :)
12:42:03 <hc_> i can also use filter with that, right?
12:42:08 <Cale> and gives you a string which magically reads the handle when evaluated
12:42:18 <Cale> yeah
12:42:56 <parcs`> @src hGetContents
12:42:57 <lambdabot> Source not found. Just try something else.
12:42:59 <parcs`> @src getContents
12:43:00 <lambdabot> getContents = hGetContents stdin
12:43:05 <Cale> btw, this magic is separately available as unsafeInterleaveIO :: IO a -> IO a
12:43:30 <Cale> It turns an IO action into one which produces a result immediately without doing anything
12:43:42 <Cale> and when that result is evaluated, the IO will actually happen.
12:44:20 <Cale> This can become really confusing and horrible if abused though :)
12:44:56 <hc_> aah!
12:45:07 <hc_> i'm just toying with it atm, experimenting
12:46:29 <hc_> unsafeInterleaveIO looks nice
12:46:49 <danr> hc_: yeah, it can be quite helpful
12:47:26 <Cale> You have little guarantee about how many times the IO action given to unsafeInterleaveIO will be evaluated though, so take care.
12:47:37 <parcs`> what non-evil things could it be helpful for?
12:47:54 <Cale> er, how many times it will be executed*
12:48:25 <twanvl> really? Why would the action be executed more than once?
12:48:38 <parcs`> inlining, maybe
12:48:39 <Cale> I think it's hard to make that happen, but likely possible
12:48:51 <danr> parcs`: if you want to return a lazy list that's generated in IO
12:49:02 <Cale> At the very least by having more than one thread evaluate the result at about the same time
12:49:03 <twanvl> I believe even unsafePerformIO guarantees single execution, right?
12:49:18 <danr> twanvl: not with parallelism
12:49:33 <Cale> There is probably a slight race condition there, or at least there was at one point.
12:49:33 <danr> par could evaluate your thunks several times
12:49:34 <twanvl> then why is there a separate unsafeDupablePerformIO function?
12:49:45 <Cale> Maybe they've managed to close the hole
12:49:49 <danr> aha interesting
12:50:24 <illissius> is unsafeInterleaveIO basically return . unsafePerformIO?
12:50:48 <twanvl> according to the source, unsafeInterleaveIO m = unsafeDupableInterleaveIO (noDuplicate >> m)
12:50:54 <bbrittain> convert Integers to Chars? when I try to use show I just get Strings
12:50:55 <danr> noDuplicate = IO $ \s -> case noDuplicate# s of s' -> (# s', () #)
12:51:08 <danr> twanvl: pretty cool, I did not know this
12:51:10 <rwbarton> convert Integers to Chars how
12:51:18 <Cale> unsafeInterleaveIO m = unsafeDupableInterleaveIO (noDuplicate >> m) -- apparently
12:51:33 <illissius> right, I'm just wondering whether it's conceptually equivalent :)
12:51:33 <Cale> yeah
12:51:36 <bbrittain> I could use like show 5 !!0  but that is really hacky
12:52:01 <barrucadu> bbrittain: What exactly do you want to do?
12:52:13 <Cale> > intToDigit 5
12:52:14 <lambdabot>   '5'
12:52:18 <Cale> > intToDigit 9
12:52:19 <lambdabot>   '9'
12:52:22 <Cale> > intToDigit 10
12:52:22 <bbrittain> Cale, thank you!
12:52:23 <lambdabot>   'a'
12:52:32 <Cale> > intToDigit 16
12:52:33 <lambdabot>   *Exception: Char.intToDigit: not a digit 16
12:52:58 <Cale> You could also use:
12:53:13 <fmap> @hoogle Int -> Char
12:53:14 <lambdabot> Data.Char chr :: Int -> Char
12:53:14 <lambdabot> Data.Char intToDigit :: Int -> Char
12:53:14 <lambdabot> Data.Text index :: Text -> Int -> Char
12:53:21 <Cale> > (\n -> chr (ord '0' + n)) 15
12:53:22 <lambdabot>   '?'
12:53:27 <Cale> oh, derp
12:53:34 <Cale> right, won't work for hex :)
12:53:37 <Cale> > (\n -> chr (ord '0' + n)) 3
12:53:39 <lambdabot>   '3'
12:53:39 <bbrittain> haha
12:53:44 <Cale> but will work for decimal :)
12:53:53 <bbrittain> great, thanks
12:54:21 <Cale> I guess to handle base 36 or whatever, you'd need to do something fancier
12:54:48 <Cale> Kinda sucks that intToDigit doesn't just go ahead and do the whole alphabet
12:54:59 <bbrittain> Cale, just gotta deal with base 10 for this problem :P
12:55:19 <twanvl> IMO it's a bug that intToDigit doesn't work up to 36
12:58:12 <spree> > intToDigit 63
12:58:14 <lambdabot>   *Exception: Char.intToDigit: not a digit 63
12:58:19 <spree> > intToDigit 1
12:58:21 <lambdabot>   '1'
12:58:24 <spree> > intToDigit 9
12:58:26 <lambdabot>   '9'
12:58:30 <spree> > intToDigit '10'
12:58:31 <lambdabot>   <no location info>:
12:58:32 <lambdabot>      lexical error in string/character literal at chara...
12:58:46 <spree> > hexToDigit "0x10"
12:58:47 <lambdabot>   Not in scope: `hexToDigit'
13:00:13 <nand`> > intToDigit (read "0x10")
13:00:14 <lambdabot>   *Exception: Char.intToDigit: not a digit 16
13:10:00 <raincole> how does Haskell deal with floating number? 1/3*3 == 1 is True in Haskell, but False in most languages I know
13:10:20 <rwbarton> luck?
13:10:23 <rwbarton> > 1/3*3
13:10:24 <lambdabot>   1.0
13:10:26 <rwbarton> > 1/3*3 == 1
13:10:27 <lambdabot>   True
13:10:41 <rwbarton> > 1/5*5 == 1
13:10:42 <lambdabot>   True
13:10:43 <Jeanne-Kamikaze> it's a fractional
13:10:46 <bitonic> well. the trick is that those are not necessarly floats
13:10:54 <Jeanne-Kamikaze> > :t 1/3*3
13:10:56 <lambdabot>   <no location info>: parse error on input `:'
13:10:59 <bitonic> since we actually have.... Rational numbers!
13:11:05 <bitonic> @type 1/3*3
13:11:07 <lambdabot> forall t. (Fractional t) => t
13:11:22 <rwbarton> but Fractional defaults to Double
13:11:26 <nand`> my resident favorite
13:11:27 <bitonic> true.
13:11:29 <nand`> > showCReal 1000 pi
13:11:30 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
13:11:50 <nand`> blows a few minds every now and then
13:12:00 <sclv> > (1/3 :: Double) * 3
13:12:01 <lambdabot>   1.0
13:12:01 <nand`> yes, the stock ‘pi’ (can) have infinite precision
13:12:04 <sclv> > (1/3 :: Double) * 3 == 1
13:12:05 <lambdabot>   True
13:12:08 <nand`> s/infinite/unbounded/
13:12:15 <sclv> > (1/33 :: Double) * 33 == 1
13:12:16 <lambdabot>   True
13:12:34 <rwbarton> > 1/49 * 49 == 1
13:12:35 <lambdabot>   False
13:12:39 <sclv> well done.
13:12:40 <raincole> oh-oh
13:12:42 <nand`> @check \n -> 1/n*n == (1 :: Double)
13:12:43 <lambdabot>   "Falsifiable, after 1 tests:\n0.0\n"
13:12:48 <nand`> ..
13:12:55 <raincole> seems it's just luck...
13:13:15 <nand`> > 1/3*3 == (1 :: Float)
13:13:16 <lambdabot>   True
13:13:24 <rwbarton> @check \n -> n < 0 || 1/n*n == (1 :: Double)
13:13:25 <lambdabot>   "Falsifiable, after 0 tests:\n0.0\n"
13:13:32 <rwbarton> @check \n -> n <= 0 || 1/n*n == (1 :: Double)
13:13:33 <lambdabot>   "Falsifiable, after 32 tests:\n3.8\n"
13:13:36 <rwbarton> also yeah
13:13:47 <rwbarton> @check \n -> n <= 0 || let n' = fromInteger n in 1/n'*n' == (1 :: Double)
13:13:49 <lambdabot>   "Falsifiable, after 464 tests:\n161\n"
13:14:09 <parcs`> > (1/0) * 0
13:14:11 <lambdabot>   NaN
13:14:16 <nand`> @check \n -> n == 0 || 1/n*n == (1 :: Rational)
13:14:17 <lambdabot>   "OK, passed 500 tests."
13:14:29 <parcs`> > (1/0) * 0 :: Rational
13:14:30 <lambdabot>   *Exception: Ratio.%: zero denominator
13:14:53 <bbrittain> > pi
13:14:54 <lambdabot>   3.141592653589793
13:15:04 <nand`> > pi :: Rational
13:15:05 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
13:15:05 <lambdabot>    arising from a us...
13:15:06 <nand`> oh
13:15:13 <nand`> good thing too
13:15:30 <bbrittain> > pi :: Int
13:15:32 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
13:15:32 <lambdabot>    arising from a use of...
13:15:36 <bbrittain> :(
13:15:39 <nand`> > toRational pi
13:15:40 <lambdabot>   884279719003555 % 281474976710656
13:15:51 <bbrittain> woad
13:15:54 <bbrittain> woah
13:16:06 <parcs`> > 884279719003555 / 281474976710656
13:16:07 <lambdabot>   3.141592653589793
13:16:14 <rwbarton> looks legit
13:16:19 <nand`> how does toRational work? it seems to violate ℚ⊂ℝ
13:16:49 <bbrittain> > toRational 3.23743284170328653
13:16:50 <c_wraith> Double is not even close to the reals, though
13:16:50 <lambdabot>   1822512667441491 % 562949953421312
13:16:56 <rwbarton> well Doubles are actually numbers of the form n/2^k
13:17:03 <nand`> > toRational (pi :: CReal)
13:17:03 <lambdabot>   *Exception: CReal.toRational
13:17:04 <rwbarton> (the ones that are numbers anyways)
13:17:06 <bbrittain> > 1822512667441491 / 562949953421312
13:17:07 <nand`> oh
13:17:07 <lambdabot>   3.2374328417032867
13:17:09 <nand`> good.
13:17:12 <parcs`> > 884279719003555 / 3141592653589793
13:17:13 <lambdabot>   0.281474976710656
13:17:14 <nand`> or bad, however you want to see it
13:17:14 <rwbarton> > toRational (1/3)
13:17:16 <lambdabot>   6004799503160661 % 18014398509481984
13:17:39 <nand`> still, toRational's type is highly misleading
13:17:53 <bbrittain> > :t toRational
13:17:54 <lambdabot>   <no location info>: parse error on input `:'
13:18:11 <Adeon> @type toRational
13:18:12 <lambdabot> forall a. (Real a) => a -> Rational
13:18:17 <nand`> bbrittain: it's just ‘:t’, not ‘> :t’
13:18:40 <bbrittain> nand`, k. I just pulled up ghci :)
13:18:53 <nand`> ‘>’ has nothing to do with ghci, mind
13:18:58 <nand`> (though amusingly, :t actually does)
13:19:16 <bbrittain> nand`, ya. I thought > was lambdabot stuff
13:19:52 <nand`> ‘> ’ is an alias for @run, which uses mueval internally
13:21:38 <rwbarton> you can somewhat reconcile the type of toRational by thinking of Reals as "things that can be approximated by Rationals" (this can be made precise) and then toRational gives you some specific approximation, but you don't have any control over what approximation
13:22:16 <nand`> in that respect it should be possible to write :: CReal -> Rational
13:22:25 <nand`> it's not like CReal doesn't approximate some functions already either way
13:22:39 <rwbarton> @src Real
13:22:39 <lambdabot> class  (Num a, Ord a) => Real a  where
13:22:39 <lambdabot>     toRational      ::  a -> Rational
13:23:10 <nand`> oh
13:23:17 <nand`> “the rational equivalent of its real argument with full precision”
13:23:41 <nand`> I thought the class would be a bit... larger
13:24:32 <rwbarton> I wonder why CReal implements Real at all if it is just going to produce an error, is Real a superclass of something important?
13:24:42 <nand`> uhm
13:24:45 <nand`> RealFrac, RealFloat
13:24:48 <nand`> I'd guess
13:25:07 <rwbarton> @src RealFrac
13:25:07 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
13:25:07 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
13:25:07 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
13:25:20 <rwbarton> > truncate (pi :: CReal)
13:25:21 <lambdabot>   3
13:25:24 <rwbarton> > truncate (3 :: CReal)
13:25:25 <lambdabot>   3
13:25:28 <rwbarton> hmm
13:25:50 <nand`> I always get confused by those classes
13:25:55 <rwbarton> > floatDigits (pi :: CReal)
13:25:56 <lambdabot>   *Exception: CReal.floatDigits
13:26:00 <nand`> I can't tell which one is which
13:26:17 <rwbarton> > isNaN (pi :: CReal)
13:26:18 <lambdabot>   False
13:26:26 <rwbarton> oh atan2 is in RealFloat
13:26:30 <nand`> yeah
13:26:38 <nand`> (for what reason?)
13:26:46 <rwbarton> I was wondering that also
13:27:54 <rwbarton> well i guess it sort of makes sense
13:28:24 <nand`> why not in Floating like atan and atanh?
13:28:27 <rwbarton> it can't go in Floating because it needs a notion of sign
13:28:46 <nand`> :t signum
13:28:47 <lambdabot> forall a. (Num a) => a -> a
13:29:00 <rwbarton> a notion of sign like the one that real numbers have :P
13:29:11 <nand`> I don't follow
13:29:16 <nand`> what notion of sign do real numbers have?
13:29:22 <rwbarton> positive or negative?
13:29:27 <rwbarton> basically atan2 doesn't make sense for complex numbers
13:29:30 <nand`> and ‘signum’ differs from this how?
13:29:37 <rwbarton> complex numbers have signum
13:29:48 <nand`> oh
13:30:24 <rwbarton> which is sort of an ugly arrangement
14:07:26 <Taslem> Is there a way to go about saying (TypeX q) is a member of the Show iff q is a list?
14:07:37 <Taslem> Of that Show typeclass, that is.
14:08:00 <Dtgr>  /away
14:08:03 <Dtgr> ..
14:08:18 <acowley> instance Show a => Show (TypeX [a]) where ...
14:11:14 <rwbarton> maybe instance (a ~ [b]) => Show (TypeX a) where ...
14:12:03 <Taslem> Looks like either would work.
14:14:26 <fragamus> so what are lenses
14:14:43 <fragamus> i saw mention of them a few days back
14:15:54 * hackagebot state-plus 0.1 - MonadPlus for StateT  http://hackage.haskell.org/package/state-plus-0.1 (BorisSukholitko)
14:15:56 * hackagebot Elm 0.3.5 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.3.5 (EvanCzaplicki)
14:17:39 <acowley> fragamus: ekmett's answer on SO here is pretty outstanding… http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
14:19:15 <c_wraith> huh.  cabal install zlib is failing...  I can't figure out why
14:22:01 <c_wraith> hmm.  I wonder if this is due to using gold instead of ld
14:22:27 <acowley> bravery will not go unpunished
14:22:58 <c_wraith> yep.  zlib won't install with gold
14:23:01 <c_wraith> interesting
14:23:25 <c_wraith> it's not really bravery - ld was running out of memory
14:25:54 * hackagebot elm-server 0.3.5 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.3.5 (EvanCzaplicki)
14:30:02 <fragamus> advice needed… I am working in isolation, and I have no worries about compatibility with any particular version of haskell.  Which lens implementation would you recommend?
14:30:05 <fragamus> http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
14:30:17 <acowley> data-lens
14:30:54 <fragamus> why is data-lens the best
14:31:02 <acowley> and don't forget data-lens-template
14:31:29 <acowley> I think that SO question covered the tradeoffs pretty comprehensively
14:34:00 <cixa> jaspervdj: are you here
14:34:17 <jaspervdj> cixa: yes
14:34:46 <cixa> jaspervdj: hello
14:34:52 <jaspervdj> hiya :-)
14:35:05 <cixa> jaspervdj: i have some questions about hakyll
14:35:25 <cixa> should i email you?
14:36:24 <jaspervdj> cixa: You can either ask it in #hakyll, or if you don't have much time, try the mailing list: hakyll@googlegroups.com
14:44:36 <startling> is there a nice way to take a list and unpack things from it with defaults?
14:45:18 <startling> e.g, I have a list of arguments. I want the first argument to be a filename (or default to stdin) and the second argument to be a filename (or default to stdout)
14:47:05 <Nereid> startling:
14:47:07 <Nereid> :t zipWith const
14:47:08 <lambdabot> forall a b. [a] -> [b] -> [a]
14:47:37 <Nereid> oops.
14:48:00 <Nereid> that's not it, obviously.
14:48:05 <startling> hehe
14:48:06 <Nereid> never mind.
14:48:27 <Nereid> but zipWith something.
14:48:38 <startling> yeah
14:48:51 <startling> I think I can turn it into a list of Maybes and then mess with it
14:48:57 <Nereid> that's what I was thinking.
14:49:14 <startling> ugh, the worst part of haskell is writing frontends
14:49:43 <Nereid> >zipWith from Maybe [1,2,3] [Nothing, Just 5]
14:49:45 <Nereid> >zipWith fromMaybe [1,2,3] [Nothing, Just 5]
14:49:47 <Nereid> heh.
14:49:50 <Nereid> oh right, space.
14:49:51 <Nereid> > zipWith fromMaybe [1,2,3] [Nothing, Just 5]
14:49:52 <lambdabot>   [1,5]
14:49:57 <Nereid> nope.
14:50:18 <Nereid> just add some Nothings at the end though?
14:50:26 <startling> yeah
14:51:38 <Nereid> using Maybes gives you a way to tell it to use the default too, I guess
14:52:08 <Nereid> well, whatever
14:54:53 <dmwit> startling: xs ++ drop (length xs) ys -- ?
14:55:52 <Nereid> aw, that's no fun. :(
14:55:52 <startling> dmwit: ooh
15:02:11 <startling> is there a nice way to bind to a case? or do I need a lambda in there?
15:02:53 <Nereid> ?
15:02:58 <dmwit> You need a lambda.
15:03:13 <acowley> I usually follow a bind with auxiliary function defined in a where block so I can use pattern matching rather than an explicit case.
15:03:52 <dmwit> \ should introduce a (pattern-matching) block. ;-)
15:03:57 <Nereid> zipWith ($) (map const ys ++ repeat id) xs -- just having fun here
15:04:01 <startling> acowley: yeah, that's what i think i'll do
15:04:15 <Nereid> slightly different behaviour though
15:05:26 <Nereid> oh that's what you mean.
15:06:49 <dmwit> Man. I really can't remember what's so bad about \ introducing a block.
15:06:53 <dmwit> There must have been something.
15:07:49 <shachaf> foo >>= \x ->
15:07:52 <shachaf> bar >>= \y ->
15:07:53 <shachaf> ...
15:07:58 <dmwit> What's wrong with that?
15:08:09 <startling> sometimes you need parens, which is annoying
15:08:24 <dmwit> bar starts a new line in the enclosing block, just like it would in
15:08:43 <dmwit> foo >>= \x -> case x of _ -> return ""
15:08:47 <dmwit> bar >>= \y -> ...
15:08:51 <dmwit> um
15:08:57 <dmwit> excuse my stupid errors
15:09:31 <dmwit> My point being that, since bar is indented less than x, the block containing x has ended by the time we get to bar.
15:10:38 <dmwit> startling: hm?
15:11:01 <acowley> I took it as a comment on life in general
15:11:09 <dmwit> haha
15:11:51 <dmwit> Oh, I suddenly wonder what things end a block.
15:12:03 <dmwit> Is a new line of an enclosing block the only thing that can do that?
15:12:22 <dmwit> If so, that explains what's wrong with shachaf's example to me.
15:13:18 <dmwit> oh
15:13:24 <dmwit> oh, I'm really an idiot
15:13:44 <rwbarton> syntax errors also can close blocks
15:13:54 <dmwit> heh
15:14:10 <dmwit> But anyway, you don't want the \x -> block to close, I guess is the point.
15:14:12 <rwbarton> > let x = 3 in x + 1 -- a block is closed
15:14:13 <lambdabot>   4
15:14:18 <rwbarton> no {}, magic!
15:14:39 <dmwit> You want the bar >>= \y -> ... stuff to be contained inside the \x -> stuff, which is incompatible with closing the \x block.
15:15:59 <dmwit> rwbarton: Is that really the right way to describe what happened there?
15:16:07 <dmwit> I'd be more inclined to say "in" can close blocks. =P
15:16:44 <rwbarton> "Note 1 implements the feature that layout processing can be stopped prematurely by a parse error."
15:16:54 <startling> acowley: heh
15:17:16 <startling> is there a `flip fmap` somewhere already?
15:17:19 <rwbarton> if I could figure out how I would link you to section 9.3 of the Haskell 98 report
15:17:36 <dmwit> saying 9.3 is a pretty good link, thanks
15:18:15 <rwbarton> > do a == b == c
15:18:16 <lambdabot>   Precedence parsing error
15:18:16 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
15:18:26 <rwbarton> > a == b == c
15:18:27 <lambdabot>   Precedence parsing error
15:18:28 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
15:18:54 <dmwit> My goodness.
15:19:20 <dmwit> Maybe Haskell 2010 fixed this bug.
15:19:47 <Dtgr> > 2048 * 3
15:19:49 <lambdabot>   6144
15:19:53 <Jeanne-Kamikaze> anyone familiar with happstack ?
15:19:59 <dmwit> ...it doesn't =/
15:20:09 <bitonic> Jeanne-Kamikaze: ask, don't ask to ask. there's also #happs
15:20:11 <dmwit> I wonder if any implementations actually bother to get that rgiht.
15:20:14 <stepcut> Jeanne-Kamikaze: i still am
15:20:24 <Jeanne-Kamikaze> ah, I was looking for "sepcut"
15:20:42 <bitonic> dmwit: you mean defining == as `infix{l,r}'?
15:20:49 <Jeanne-Kamikaze> ok, so how do I run the server on port 80 ? One doesn't simply bind a low port as a non root user, and I don't want to run the server as root
15:21:14 <Jeanne-Kamikaze> I mean, I've seen the httpConf argument and all that
15:21:39 <dmwit> bitonic: I mean syntax errors ending blocks.
15:21:40 <Jeanne-Kamikaze> but how, if it's even possible, do you tell it to drop privileges after binding ?
15:21:57 <dmwit> bitonic: do a == b == c is actually valid code.
15:22:04 <startling> can anyone come up with a nice way to do (FilePath, FilePath) -> IO (Handle, Handle) such that the first is opened in ReadMode and the second is opened in WriteMode?
15:22:14 <dmwit> (provided a, b, and c have the right types)
15:22:43 <startling> is that (a == b) == c or a == (b == c)?
15:22:51 <dmwit> uncurry (\x y -> liftM2 (,) (openFile x ReadMode) (openFile y WriteMode))
15:22:56 <dmwit> startling: no
15:22:57 <dmwit> =)
15:23:06 <startling> dmwit: waiiit
15:23:14 <dmwit> It's do { a == b } == c
15:23:14 <startling> dmwit: one of them has to be a Bool regardless, right?
15:23:20 <startling> oh ugh
15:23:23 <bitonic> dmwit: they both fail here, complaining about conflicts with the fixity
15:23:42 <dmwit> bitonic: Yes, GHC does not implement the Report, apparently.
15:23:54 <startling> dmwit: so C has to be m Bool where m has Eq?
15:24:03 <dmwit> (Honestly, I would consider this a Report bug, not a GHC bug. ;-)
15:24:17 <dmwit> startling: do blocks do not create a monadic type.
15:24:21 <dmwit> > do ()
15:24:22 <lambdabot>   ()
15:24:33 <bitonic> dmwit: no wait a second, following the report `1 == 2 == 3' is not valid but `do 1 == 2 == 3' is?
15:24:39 <startling> dmwit: oh right, I had assumed it would be monadic through context
15:24:41 <dmwit> bitonic: correct
15:24:54 <bitonic> dmwit: whoa. why?
15:25:06 <dmwit> bitonic: As rwbarton said above: syntax errors close blocks.
15:25:26 <dmwit> Check out the note after note 6 in section 9 of the Report (H98 or H2010).
15:25:30 * bitonic scrolls up
15:25:41 <dmwit> err, in the Syntax section, might not be section 9 in both
15:27:36 <parcs`> http://comonad.com/reader/2012/mirrored-lenses/ this is amazing
15:27:37 <bitonic> dmwit: reading it now, interesting. and I thought I knew everything at least about Haskell's syntax :)
15:27:59 <dmwit> We use a strange beast.
15:28:29 <startling> is there a way to compose two functions a -> b and c -> d to make a (a, c) -> (b, d)?
15:28:37 <parcs`> edwardk: you missed a type variable in the type signature of 'reals' in your mirrored lenses article
15:28:49 <edwardk> did i? woops
15:28:50 <edwardk> updating
15:28:51 <dmwit> ?hoogle (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:28:51 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:29:05 <dmwit> hm, okay, technically correct
15:29:06 <edwardk> startling: bimap
15:29:10 <dmwit> :t (***)
15:29:11 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:30:12 <startling> interesting
15:35:15 <rwbarton> and it looks like there is a typo in the 98 Report at least, Note 1 should refer to Note 5
15:35:28 <bbrittain> what would be the best way of comparing the speed of one algorithm vs another in haskell?
15:35:31 <startling> alright, the best I got is mHandles (a:b:[]) = liftM Just $ liftM2 (,) (openFile a ReadMode) (openFile b WriteMode). anyone want to try better?
15:35:48 <startling> this is mHandles :: [FilePath] -> IO (Maybe (Handle, Handle))
15:36:56 <bbrittain> I guess a better way to phrase it would be speed of various functions
15:37:05 <acowley> bbrittain: criterion
15:37:25 <bbrittain> acowley, sweet. I'll check it out
15:42:44 <ksf> ...if the implementation of intmap wasn't hidden I could deserialise it to better haskell than fromAscList [...3000 elements...]
15:48:15 <bitonic> ksf: yes. They ought to export stuff with .Internal module or whatever
15:54:32 <parcs`> ksf: deserialize what?
15:54:48 <ksf> well, I have a *big* lookup table.
15:54:52 <ksf> bidirectional, even.
15:55:14 <ksf> but thinking about it, I should probably deserialise it to straight lookup code
15:57:39 <sm> hey all
15:58:03 <sm> is there a liftIO-equivalent in mtl ? I don't want to pull in transformers as well as mtl
15:58:16 <ksf> they're the same thing.
15:58:22 <sm> or can I safely do that ? hm
15:58:30 <parcs`> mtl depends on transformers
15:58:39 <sm> right you are. great, thx
16:04:49 <avpx> I've been wondering what about monads makes them such a useful programming pattern. For instance, I've never seen a comonad out explicitly used, but monads are a pretty fundamental tool for programming in Haskell.
16:05:29 <c_wraith> avpx: read cdsmith's article on the topic
16:05:57 <c_wraith> avpx: http://cdsmith.wordpress.com/2012/04/18/why-do-monads-matter/
16:06:01 <JuanDaugherty> am I mistaken that there's no ready way to disable GLUT and parallel in haskell platform? Or any individual with --without ?
16:06:10 <S11001001> avpx: if comonads were the more common they would be the monads and monads the comonads
16:06:25 <avpx> S11001001: That is a great argument.
16:06:42 <ksf> they're so bloody useful because they're strictly more powerful than arrowchoice.
16:07:20 <startling> is there a thing that takes a [Maybe x] and a default of type x and turns it into [x]?
16:07:31 <startling> that is, replacing Nothing with the default x
16:07:34 <shachaf> @ty map (fromMaybe ?default)
16:07:36 <lambdabot> forall a. (?default::a) => [Maybe a] -> [a]
16:08:04 <startling> oh neat
16:08:19 <S11001001> :t map . maybe
16:08:21 <lambdabot> forall b a. b -> [a -> b] -> [Maybe a -> b]
16:08:29 <S11001001> or ... something.
16:08:47 <avpx> c_wraith: Thanks.
16:11:07 * hackagebot shelly 0.12.1.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.12.1.1 (GregWeber)
16:16:07 * hackagebot hledger-lib 0.18.1 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.18.1 (SimonMichael)
16:16:09 <startling> @hoogle [Word8] -> IO ()
16:16:09 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
16:16:09 <lambdabot> Control.Concurrent.Chan writeList2Chan :: Chan a -> [a] -> IO ()
16:16:09 <lambdabot> Test.HUnit.Base listAssert :: ListAssertable t => [t] -> Assertion
16:21:07 * hackagebot hledger 0.18.1 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.18.1 (SimonMichael)
16:21:09 * hackagebot hledger-web 0.18.1 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.18.1 (SimonMichael)
16:26:11 * hackagebot flow2dot 0.9.0.3 - Library and binary to generate sequence/flow diagrams from plain text source  http://hackage.haskell.org/package/flow2dot-0.9.0.3 (DmitryAstapov)
16:56:30 * shapr sighs
16:58:42 <shapr> So I have a Display class that lets me produce SVG or Text or whatever in a web browser.
16:58:45 <S11001001> :t map . flip maybe id
16:58:46 <lambdabot> forall a. a -> [Maybe a] -> [a]
16:58:50 <shapr> Can anyone think of more interesting Display instances?
16:59:02 <shapr> What can browsers automatically play? midi?
16:59:16 <mgsloan> or mp3
16:59:24 <jfischoff> WebGL?
16:59:31 <shapr> jfischoff: oh that's a good idea
16:59:46 <shapr> mgsloan: Is that only html5 that supports playing mp3s?
17:00:05 <jfischoff> I think so
17:00:27 <mgsloan> shapr: yeah, probably so
17:01:09 * hackagebot haskell-xmpp 1.0.1 - Haskell XMPP (eXtensible Message Passing Protocol, a.k.a. Jabber) library  http://hackage.haskell.org/package/haskell-xmpp-1.0.1 (DmitryAstapov)
17:01:31 <jfischoff> shapr: how can I checkout your progress? I'm excited
17:02:57 <shapr> jfischoff: http://c-71-207-252-122.hsd1.al.comcast.net:3000/hint.html
17:03:04 <shapr> jfischoff: Or grab the repo
17:03:11 <shapr> jfischoff: I just put in "graycode"
17:03:21 <jfischoff> graycode?
17:03:21 <shapr> as a top level binding from http://projects.haskell.org/diagrams/gallery/Gray.html
17:03:29 <jfischoff> oh
17:03:33 <jfischoff> cool
17:03:43 <shapr> The neat thing is that I don't need to restart the server to add new diagrams definitions.
17:03:53 <shapr> But I do need to change the color :-)
17:04:26 <mgsloan> so, I saw a demo of someone's augmented ghci wrapper that had folding of pretty-printed Show output
17:04:37 <shapr> mgsloan: That would be nifty!
17:04:40 <mgsloan> been trying to find it, but haven't been able to :/
17:04:43 <mgsloan> it was really sweet
17:04:52 <mgsloan> so yeah, that'd be a cool thing to think about!
17:05:02 <shapr> I was wondering if I could integrate http://hackage.haskell.org/package/vacuum-cairo
17:05:14 <luite> mgsloan: i believe chrisdone had it in his emacs script
17:05:17 <mgsloan> yeah!!
17:05:25 <mgsloan> luite - yeah, that's the one
17:05:25 <luite> shapr: yes that's easy, just let it output a png
17:05:36 <jfischoff> I wonder which would be easier that version or the opengl backend
17:05:42 <jfischoff> with webgl
17:05:47 <shapr> luite: Cool, I'll try it.
17:05:59 <nexion> is there an easy (Maybe a, Maybe b) -> Maybe (a,b)? or is applicative the best way?
17:06:00 <shapr> jfischoff: Oh, you're thinking HOpenGL to webGL?
17:06:06 <luite> shapr: difference is that you get an IO value now, instead of a pure DisplayResult
17:06:16 <shapr> luite: That makes sense.
17:06:27 <jfischoff> maybe it depends on how vacuum-opengl is implemented
17:06:35 <jfischoff> could be a nightmare
17:06:40 <jfischoff> could be not that hard
17:08:21 <otters> @hoogle Monad m => (m a, m b) -> m (a, b)
17:08:21 <lambdabot> No results found
17:10:06 <otters> (uncurry (liftM2 (,))) (Just 4, Just 5)
17:10:24 <otters> > uncurry (liftM2 (,)) (Just 4, Just 5)
17:10:26 <lambdabot>   Just (4,5)
17:10:41 <jfischoff> shapr: vacuum-opengl is not really setup for client rendering
17:10:54 <shapr> That's too bad.
17:11:40 <jfischoff> you would need to replace dot…which there was a javascript graph layout thing cads was showing me that might work
17:14:12 <mgsloan> shapr; do you already use something like http://hackage.haskell.org/package/data-pprint ?
17:14:34 <mgsloan> It'd be really fancy to be able to have an "ask for more output" button
17:14:45 <mgsloan> and actually go to the server for more
17:15:03 <mgsloan> so, the folding feature I'm talking about would sometimes be async
17:15:38 <shapr> mgsloan: Oh that's cool!
17:15:43 <shapr> That's the same guy who did ActiveHS, I think...
17:16:10 <shapr> I wish hackage would let me click on Author or UploadedBy and get to that person's other packages.
17:16:15 <mgsloan> yup, it's been on my list of libraries to use for my own GHCI-wrapper projects
17:17:02 <shapr> Wow, pprint fixes one of the TODO items in my list :-)
17:17:09 <mgsloan> awesome :)
17:18:23 <mgsloan> using something like this: http://hackage.haskell.org/package/GenericPretty  (or merging the two approaches, while adding support for folding) could be an interesting way to go
17:19:01 <mgsloan> I'd love to see the ability for people to supply custom web interpretations for their values
17:19:07 <shapr> Yah, I'd like that too.
17:19:22 <shapr> I was discussing that earlier, how to make a Display instance for various types.
17:20:32 <mgsloan> yeah!  It's more of a priority to get a good set of instances baked in than worrying about user customization right off the bat
17:56:48 <shergill> so i tend to overengineer my personal projects as a means to learn new concepts. i need a parser, any suggestions? i'd prefer to go with something which has greater applicability and may give better performance even if it might have a higher learning curve
17:57:26 <bitonic> shergill: ...parsec?
17:57:33 <edwardk> trifecta
17:58:21 <edwardk> if you don't mind the learning curve you might as well try to drive the rolls royce of parsers ;)
17:58:42 <fragamus> I just installed the latest Haskell platform; I need to reinstall some packages; my code requires the Maybe package; ghc says: "It is a member of the hidden package `haskell98-2.0.0.1'.";this doesn't seem right to me; shouldn't I be using something more modern?
17:58:49 <edwardk> and your users get pretty diagnostics
17:59:10 <shergill> edwardk: assuming there's a payoff in the rolls royce, sure. specific wins over, say, parsec?
17:59:23 <edwardk> as for performance it is faster than parsec and competitive with attoparsec.
18:00:13 <shergill> i take it attoparsec is faster, though perhaps not by much?
18:00:29 <edwardk> sure, you get clang style diagnostics with ^'s etc, automatic generation of a syntax highlighter, compatibility with monad transformers (you can transform a parser), more combinators, a sane re-envisioning of the 'language' combinators
18:00:54 <edwardk> attoparsec will be faster for long inputs, if you are parsing a language, i'd go with trifecta because you actually get error messages
18:01:01 <edwardk> if you are parsing a protocol, go with attoparsec
18:01:29 <shergill> parsing a language, and i expect there to be an extended repl like thing as i tweak the system
18:01:49 <shergill> *natural language
18:02:44 <edwardk> the other thing that trifecta will give you when i get around to pushing it into the main branch is tab-completion for your repl for arbitrary grammars ;)
18:03:27 <shergill> wait, how would that work?
18:03:37 <\rs> how to provide different implementations for a concrete type (say Double) and a type class (say Integral)
18:03:39 <edwardk> you annotate the grammar with completion hooks
18:03:50 <\rs> without syb
18:03:55 <shergill> ooh nice
18:04:18 <shergill> ok trifecta wins if only for the coolness factor heh
18:04:21 <edwardk> \rs: you make a newtype wrapper or you make a defaultFooIntegral :: Integral a => …. a ...
18:04:30 <shergill> care to elaborate on the namechoice?
18:04:47 <edwardk> and then you make everybody who makes an instance for Integral use foo = defaultFooIntegral  for their instance
18:05:16 <edwardk> shergill: i gave a talk a few years ago on a way to mix parsec iteratees and monoids to get high performance easy parallelizable parsing
18:05:29 <edwardk> shergill: a 'parsing trifecta' as it were
18:05:44 <edwardk> and i kept the name even after i moved to other techniques
18:05:58 <shergill> edwardk: got a link to the video, if its still relevant with current version of trifecta?
18:06:07 <\rs> edwardk: for example, i need to define sqrt_. when a Double is provided, use default; resorts to a special version for Integral when Integral is provided
18:06:51 <illissius> \rs: do the implementations have different behaviour, or is one of them just faster?
18:07:12 <edwardk> \rs: make a class Sqrt a where sqrt_ :: a -> a;    instance Sqrt Double where sqrt_ = your algorithm
18:07:24 <edwardk> sqrtIntegral :: Integral a => a -> a
18:07:33 <\rs> illissius: different behavior. i know there is a SPECIALIZE pragma
18:07:45 <edwardk> then for the concrete choices of integral you care about make instance Sqrt Foo where sqrt_ = sqrtIntegral
18:07:50 <edwardk> if you want to make that suck less
18:08:16 <edwardk> use class Sqrt a where sqrt_ :: a -> a; default sqrt_ :: Integral a => a -> a; sqrt_ = your integral code
18:08:37 <edwardk> then you just need to use instance Sqrt Int; instance Sqrt Integer, for the concrete instantiations of Integral
18:09:35 <edwardk> the problem is you dont want to make an instance for instance Integral a => Sqrt a      -- because that will overlap with the Double instance. and yes while i know it is impossible for Double to have a legal Integral, the type checker doesn't, and overlapping instances are evil, unsafe and lead to unsound behavior
18:09:39 <zeiris_> Speaking of parsers: what's the state of the art got to say about defining a parser, and multiple pretty printers (into different formats) from a single definition?
18:09:56 <edwardk> zeiris_: we say it is a pain in the ass ;)
18:10:15 <edwardk> zeiris_: even just into the original format
18:10:23 <\rs> edwardk: how to provide a polymorphic implementation for Integral instead of making various versions for each instance of Integral
18:10:55 <edwardk> because bidirectional parsing/pretty printing is effectively a quotienting process. it should be idempotent, so that parse . pretty . parse = parse, but you do lose information during parsing
18:11:13 <rwbarton> edwardk: oh that's that recent default method extension I was looking for. what's it called?
18:11:35 <illissius> {-# DefaultSignatures #-}
18:11:40 <illissius> LANGUAGE :)
18:11:57 <edwardk> \rs: you don't its a bad idea. you _can_ use overlapping instances, but i seriously don't recommend doing it. you save a few lines of code in exchange for losing all ability to reason about what instances get dispatched to and unsound behavior when other extensions are turned on
18:12:18 <rwbarton> thanks
18:14:20 <edwardk> \rs: the correct way to do it is to make separate non-overlapping instances, and provide the user an easy way to make those instances for types of their own, and if they need to work with a particularly exotic integral type (?!) in lots of places you can make a newtype wrapper to permit them to dispatch it by hand
18:15:50 <\rs> edwardk: sqrt is a unfortunate example, but i just want to know how to accomplish similar task as providing a polymorphic implementation accompanying with a concrete one (which does not overlap with the polymorphic) simultaneously
18:16:40 <edwardk> \rs: the short answer is you can't. you can use overlapping instances, but they are a terrible idea. the best practical solution is to give people a newtype wrapper. let me give you examples from base
18:17:11 <edwardk> http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Control-Applicative.html#t%3AWrappedArrow
18:17:14 <edwardk> http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Control-Applicative.html#t%3AWrappedMonad
18:17:37 <shergill> edwardk: does trifecta handle a streaming situation well, as in out of the box? or are there special gotchas i need to be aware of?
18:17:58 <edwardk> shergill: the short answer is i don't stream. its for programming languages, not protocols
18:18:11 <edwardk> i'm looking at relaxing that, the classes themselves don't care one way or the other
18:18:17 <edwardk> but the concrete parser instantiation i use does
18:18:24 <shergill> ah k
18:18:36 <edwardk> my current plan is to finish refactoring trifecta to use 'parsers' for the majority of the combinators
18:18:50 <\rs> edwardk: thanks, i'll look into it. i would like to know a Haskell approach when i found the so-called `type function' implementation in gcc sqrt
18:18:51 <edwardk> and then folks can work parametric in the choice of parser
18:19:43 <zeiris_> edwardk: the idempotent thing is a big deal when working with something like network protocols, or file structures. Many of them are complicated enough to justify structured parsing, but you usually want to be able to modify and re-serialize / generate Wireshark dissectors from your spec / who knows what.
18:19:44 <edwardk> \rs: basically the notion of 'partial template specialization' from the c++ world doesn't have a satisfying equivalent here. which makes sense when you view it under the open world assumption
18:20:00 <shergill> hmm i'll have to revisit trifecta at a later point then. thanks anyway
18:20:08 <edwardk> shergill: no problem
18:21:04 <zeiris_> Which you can do pretty well in Lisp, and pretty poorly in Python. I'd love to be able to do it with a strong type system, but don't know how - lenses have the back-forth transformations but don't parse, parsers lose data, and I'd hate to have to use template Haskell.
18:21:56 <zeiris_> The only design I can kind of see, is having a nice DSL that produces complicated data structures, then producing parsers/pretty printers from those. So, write your own bytecode-language and interpret in different ways.
18:22:21 <edwardk> zeiris_: the main issue is that parsing is 'covariant', while pretty printing is contravariant
18:22:50 <edwardk> zeiris_: so when you compose them both you get something with either two awkward type parameters or an invariant argument
18:22:51 <edwardk> which means you can only apply isomorphisms or embedding/projection pairs
18:23:16 <edwardk> this makes actually putting together the parser and pretty printer enough harder that the code sharing is swamped by the extra headaches of stitching it together ;)
18:26:10 <zeiris_> I'm going to have to do some reading to puzzle that out. Project for the weekend :)
18:27:49 <zeiris_> Will adding Conceptual Mathematics: A first introduction to categories to my reading list, help clarify things?
18:28:13 <edwardk> i do want to take a pass and take some of the combinators from 'parsers' and 'wl-pprint-extras' and make them come from a common class so you don't have to come up with separate names for putting together certain parser/pretty printer parts
18:28:29 <edwardk> lawvere/schanuel?
18:28:47 <zeiris_> Yeah.
18:28:59 <edwardk> it'll get you a lot of drill with some basic category theory. i don't think they have a notion of variance that arises anywhere in the book though
18:29:15 <edwardk> well covariance and contravariance in the functor sense
18:29:20 <edwardk> so i guess it does
18:29:43 <edwardk> but i'm not sure they beat on the contravariant case much at all
18:31:29 <hpaste> fragamus pasted “error from ghc” at http://hpaste.org/70617
18:33:31 <hpaste> z annotated “error from ghc” with “error from ghc (annotation)” at http://hpaste.org/70617#a70618
18:34:38 <zeiris_> Erlang's bit syntax is sort of what I want, except with an intermediate structure you can use to write new pretty-printers. However implement a very limitd parser.
18:34:47 <zeiris_> *they implement
18:35:00 <shergill> edwardk: hmm general idempotence maybe hard to achieve, and not even lisp really achieves it. but semantic idempotence, or eta idempotence if you like, shouldn't be _that_ hard. so what am i missing?
18:35:42 <zeiris_> However, Haskell's type system is great for separating similar-looking but different things. So a small library for very simple but reversible parsers, with more complicated 'glue' that you have to reverse yourself, would be very interesting.
18:35:57 <edwardk> shergill: the problem is that the parser/pretty printer specification is hard, you wind up with a type parameter you need to manipulate both co and contravariantly while preserving those invariants,
18:36:14 <edwardk> this means you can't just <$> over it. but instead have to write some horrible combinator taking multiple arguments
18:36:56 <edwardk> i haven't been able to come up with a bidirectional parsing/pretty printing library that i'd be willing to actually put up with to use
18:37:43 <shergill> covariance does permit 'converting' to an equivalent class (instead of a more specific/narrower one) right?
18:37:54 <shergill> (similarly with contravariance)
18:38:52 <shergill> i suppose what i meant by eta-idempotence was wrt your specification. but i guess in that i'm shuffling the complexity underneath the coming-up-with-the-specification rug
18:43:18 <ski> zeiris_ : hm, stream parsers in Camlp4 at <http://caml.inria.fr/pub/docs/manual-camlp4/manual003.html> might be intersting to compare with ..
18:51:24 <zeiris_> ski: thanks, I'll take a look :)
18:56:56 <ski> zeiris_ : "multiple pretty printers (into different formats)" -- into different formats, how do you mean ?
18:57:42 <ski> (zeiris_ : .. for the stream parsers there, i suppose i was mostly thinking about comparing them with Erlang bit syntax)
19:00:36 <edwardk> shergill: yes, you wind up with either one covariant parameter for what you are parsing and one contravariant parameter for what you are pretty printing, or you wind up with one invariant parameter. that invariant parameter is ugly because you often do (locally) want to lose information during the pretty print and you often do want to lose information during parsing
19:00:53 <avpx> Does http://tryhaskell.org/ only allow one to evaluate expressions?
19:00:53 <edwardk> but, sleep now
19:01:06 <avpx> I expected something like ghci, where you are essentially trapped in a do block in the IO monad
19:01:24 <shachaf> "trapped"
19:01:27 <shachaf> How tragic.
19:01:53 <shergill> reminds me of limbo
19:02:00 <avpx> I suppose System.IO.Unsafe.unsafePerformIO lets you get out
19:02:04 <shergill> that was a fun game
19:02:08 <shachaf> Someone I know made the observation that you can think of code as "being trapped in the IO monad", but you can just as easily think of it as "being trapped outside of the IO monad".
19:02:23 <rwbarton> http://spl.smugmug.com/Humor/Lambdacats/trapd-in-IO-monad-plz-help/960526421_MnNqB-O-1.jpg
19:02:43 <avpx> Does anyone else like to think that the IO monad encapsulates the state of the entire universe?
19:02:58 <avpx> Sometimes I do and it's like, woah. You know? Woah.
19:03:03 <hughfdjackson> haha
19:03:04 <hughfdjackson> no edge
19:03:08 <shachaf> avpx: A lot of people seem to want to think that. They tend to be wrong.
19:03:29 <avpx> rwbarton: I literally laughed out loud.
19:03:42 <rwbarton> check out the whole site
19:03:55 <irene-knapp> @hackage acme-realworld
19:03:56 <lambdabot> http://hackage.haskell.org/package/acme-realworld
19:03:56 <avpx> Did that already exist?
19:04:07 <rwbarton> yes, it's quite old
19:04:26 <avpx> Oh, I'm a bit disappointed now.
19:04:32 <rwbarton> sorry :(
19:05:44 <ski> shachaf : due to concurrency issues ? or non-uniqueness ?
19:11:27 <shachaf> ski: Those and more. It gives more or less no insight into what IO "is" and it generally just causes a lot of confusion.
19:14:15 <ski> `IO' is a sin-bin
19:14:52 <shachaf> I think people might talk about that definition because of GHC's RealWorld# thing, but that has nothing to do with "the state of the universe", it's just an implementation hack.
19:15:57 <ski> well, i found it helpful as a stepping stone (and at that time, i used Hugs, not GHC)
19:16:38 <ski> (and no, Hugs, doesn't use that internal implementation of `IO')
19:16:48 <shachaf> I think a much more sensible introduction is something that first uses something like data IO = End | PutStrLn String IO | GetLine (String -> IO)
19:17:01 <shachaf> And an "interpreter" for that data type (which would be the RTS normally).
19:18:00 <rwbarton> the Awkward Squad paper presents the State World view on IO
19:18:17 <ski> i think one problem with this is that it's more abstract
19:18:21 <shachaf> Awkward Squad is awkward.
19:18:59 <rwbarton> sure but I imagine it contributes to the mind share of that point of view
19:19:43 <markamber> I started learning haskell a while ago and now really what I would love is a set of problems that I can devise solutions for someone could just suggest one right here or point me to where someone already has done so
19:20:23 <palmfrond> re
19:20:55 <yarou_> hey all, how do i pass ghc flags when using cabal install?
19:21:10 <yarou_> i see "flags: " under ~/.cabal/config
19:21:13 <yarou_> but it didn't seem to work
19:21:46 <palmfrond> what's the term in printing/publishing, in content layout, where you place 2 objects of content directly together, so their borders meet. imagine 2 pieces of paper aligned side by side, touching
19:21:51 <palmfrond> (please)
19:22:02 <peddie> hi, I'm having trouble how template haskell and indentation interact from reading the GHC documentation . . . does anyone know of another reference?
19:22:18 <ski> in the `State# RealWorld#' case, you can plausibly believe that you have certain primitives `getChar# :: RealWorld# -> (# Char , RealWorld# #)',&c. (just like there's primitives `(+#) :: Int# -> Int# -> Int#') -- however in that `data IOResult = End | PutCharBind Char IOResult | GetCharBind (Char -> IOResult)' one is left wondering "who is connecting the dots", going from `GetCharBind k' to `k c' for some `c' (where does `c' come from ?)
19:22:36 <mgsloan> palmfrond: Probably "juxtapose"?
19:22:51 <mgsloan> ala http://hackage.haskell.org/packages/archive/diagrams-core/0.5.0.1/doc/html/Graphics-Rendering-Diagrams-Juxtapose.html :)
19:23:13 <ski> of course, in some sense the mystery is there in both cases, but in one case it's "turned outside-in" (so the mystery is in the context around you), in the other the mystery is in the primitive operations
19:24:20 <ski> palmfrond : or maybe `alignVertically' vs. `alignHorizontally' ?
19:24:45 * ski str the Craft has some such combinators
19:25:03 <palmfrond> eh
19:25:14 <palmfrond> ski, i was thinking tilt
19:25:18 <palmfrond> err
19:25:33 <mgsloan> peddie: Since $( splices are still haskell code, I /think/ that you still need to indent beyond the current indent level.  However, for [e| |] style quotes and quasi-quotes, the current indent level is not significant
19:25:35 <palmfrond> no wrong question. i was thinking 'mate'
19:25:44 <shachaf> ski: I'd rather have a mystery that keeps my language free of primitives that aren't functions.
19:25:46 <palmfrond> 'articles 1 and 2 are mated'
19:26:07 <palmfrond> shachaf, so you want even 2 to be a function?
19:26:15 <peddie> mgsloan: thanks.  I've written a quasi-quoter myself, but I can't get that to work, and I get the same problem with [d|. . .|]
19:26:57 <shachaf> palmfrond: I mean primitives of type (a -> b) that aren't actually functions.
19:27:38 <mgsloan> peddie: strange!  Well, TH pretty much takes the literal text between the vertical bars
19:27:43 <mgsloan> so any whitespace will be included
19:28:21 <mgsloan> maybe for [d||] you are putting a space before your declaration?  [d| x = "hello" |] won't work - it needs to be [d|x = "hello"|]
19:28:22 <peddie> mgsloan: I am getting a parse error, so I haven't found a good way to get more information about the problem; -ddump-splices happens too late
19:28:42 <mgsloan> peddie: you can use Debug.Trace to print out extra stuff
19:28:50 <ski> shachaf : well, formally i think there's only the (non-)uniqueness problem there ..
19:28:53 <mgsloan> I think there's also a function in the Q monad for debugging
19:29:03 <peddie> mgsloan: ok, will have another look -- thank you!
19:29:13 <mgsloan> peddie: welcome!
19:29:55 <ski> (practically, there's also (imprecise) exceptions, concurrency, and `unsafeInterleaveIO' which i count as a variant of concurrency)
19:30:23 <palmfrond> ski, what do you think about mate?
19:30:30 <peddie> mgsloan: one more question; what if I want to use my quasiquoter within a where clause?  Q [Dec] seems like the right context, but maybe not because [d||] is top-level only
19:30:50 <mgsloan> I think that ought to work
19:30:52 <ski> palmfrond : it suggests a mix-and-match process to me ..
19:30:59 <peddie> mgsloan: ok, thanks again
19:31:28 <mgsloan> welcome! I'm not sure if it'll work, I wonder what the error looks like if you generated other types of declarations
19:31:31 <palmfrond> ski, how about flush?
19:32:14 <ski> palmfrond : when you say "you place 2 objects of content directly together, so their borders meet", which borders are you referring to ?
19:32:38 <ski> bottom and top border ? right and left border ? anything else ?
19:32:59 <palmfrond> the borders of the content
19:33:03 <palmfrond> i think i'll go with flush
19:33:23 <ski> maybe you mean place one after the other, and the syste, decides whether to place them side-by-side, or one below the other ?
19:33:28 <palmfrond> things can be stacked, separate, or flush it seems. stacked = on top of each other; grouped. separate… obvious. and flush = next to each other, no overlap; grouped
19:33:38 <ski> *which* of the borders ?
19:33:40 <palmfrond> nah i mean the layout relationship here
19:33:47 <palmfrond> think 2 pieces of paper
19:34:07 <ski> should i place one paper to the right of the other, or below the other ?
19:34:12 <palmfrond> they layout flush, but why? because their relationship is flush, vs stacked or separate
19:34:17 <palmfrond> side by side
19:34:24 <ski> which sides ?
19:34:26 <palmfrond> but that's irrelevant to my Q
19:34:35 <palmfrond> that's next :) values
19:34:58 <palmfrond> right now i'm just hashing out a model of publishing/printing/layout
19:35:03 <ski> you're saying whether it's the bottom and top sides, or the right and left sides, is irrelevant from your POV ?
19:35:32 <palmfrond> man i don't know what your deal is but i have my answer so i'll be bailing. thanks tho
19:35:53 <mdmkolbe> What is a good package for benchmarking (both quick and dirty, and for more regerious benchmarks)?  Someone once suggested Criterion, but then I had a reviewer complain that Criterion has known problems.  So what is the current "state of the art" in Haskell benchmarking?
19:36:10 <shachaf> mdmkolbe: I hear Criterion is pretty good.
19:36:28 <ski> palmfrond : sorry, i just don't know what you mean, more specifically, and hence (i think) i can't really answer your question
19:41:42 <palmfrond> yea np. thanks for trying to help tho
19:42:15 <zeiris_> ski: the multiple pretty printers thing is a bit out there... But imagine writing a parser for some protocol, then generating graphviz composition diagrams + wireshark dissector + whatever else from it.
19:42:37 <zeiris_> A task for which something like OMeta is probably better suited - but I like static types.
19:42:42 <kuhrt> is http://hackage.haskell.org/platform/ the preferred way to install haskell? on a mac, preferrable to brew?
19:44:21 <palmfrond> what's OMeta?
19:45:02 <ski> zeiris_ : ok, so you're talking about multiple different formats of pretty-printing in (as opposed to just different pretty-printers giving outputs in the same space)
19:49:14 <ski> "OMeta: an Object-Oriented Language for Pattern Matching" by Ian Piumarta,Alessandro Warth at <http://tinlizzie.org/ometa/>, apparently
19:49:35 <palmfrond> what's multi pretty printers btw?
19:50:15 <ski> see what zeiris_ said above (or ask for clarification) ?
19:52:21 <palmfrond> url?
19:52:55 <zeiris_> ski: yes, different formats. "Pretty printers" might've been a poorly chosen name - I was thinking about serializing/deserializing stuff... Which are inverses, but pretty-printing doesn't need to be invertable.
19:53:43 <palmfrond> i thought you meant logging text in different colors to a console, hehe
19:53:50 <palmfrond> like NSLog() in objc
19:55:53 <ski> zeiris_ : when you say "pretty printers", i think `parse :: A -> B', `prettyPrint :: B -> A' (simplified)
20:15:55 <Penetrator> @location forkIO
20:15:55 <lambdabot> Unknown command, try @list
20:16:00 <Penetrator> @list
20:16:00 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:16:07 <palmfrond> hey what's the best channel for ppl making projector based touch tables?
20:16:56 <Penetrator> @where forkIO
20:16:57 <lambdabot> I know nothing about forkio.
20:18:37 <solrize> control.concurrent
20:23:05 <zeiris> ski: yeah, what I'm thinking of is `deserialize :: A -> B; serialize :: B -> A; pprint1 :: B -> C; pprint2 :: B -> D; ...`
20:23:13 <zeiris> All from one definition! :D
20:24:06 <zeiris> edwardk's comments suggest that's fundamentally tricky for interesting parsers, though, so vOv
20:50:49 <kylemcgill> Has anyone done the Scribd AI Bot Challenge thing?
20:50:56 <blackdog> kylemcgill: i've been playing with it
20:51:14 <blackdog> mostly fixing problems with the harness, i haven't actually written a bot yet.
20:52:18 <kylemcgill> I see, i have only seen it today, so figure it might be a good way to practice Haskell (only really started a week ago)
20:52:55 <blackdog> yep. the only problem is that the dude who released it slurps your code in and synthesises a haskell program at runtime
20:53:15 <blackdog> which means that you can't even typecheck it standalone
20:53:25 <kylemcgill> lol fail
20:53:32 <blackdog> so the write-compile-test cycle is longish
20:53:33 <Axman6> o.O
20:53:37 <blackdog> it's a bit of a weird setup, really
20:53:55 <blackdog> he recreates the program at each turn, too - pastes in the current x and y coords, then builds and runs
20:54:15 <Axman6> . wut
20:54:32 <blackdog> miclorb: this is what i was playing with at sweeney's - you may remember the muttered obscenities.
20:54:39 <startling> blackdog: what
20:55:01 <blackdog> startling: https://github.com/egonSchiele/robot-fruit-hunt/blob/master/haskell/gameserver.rb
20:55:51 <kylemcgill> maybe someone should send a pull request to fix up some of those issues to make it a little easier lol
20:56:16 <startling> blackdog: whaaaaat
20:56:25 <blackdog> kylemcgill: i started doing it
20:56:34 <kylemcgill> lol
20:56:39 <kylemcgill> good luck dude
20:56:41 <startling> blackdog: ugh this is terrible
20:56:44 <blackdog> kylemcgill: https://github.com/mwotton/robot-fruit-hunt
20:56:57 <blackdog> startling: :) it's fascinatingly awful
20:57:14 <blackdog> still, i'm glad the dude got it started. is fixable now.
20:57:17 <startling> blackdog: and they run a new process on each upload?
20:57:35 <kylemcgill> awesome
20:57:36 <blackdog> on each move.
20:57:40 <startling> blackdog: ahahaha
20:58:19 <blackdog> he's clearly not a haskeller, so kudos to him for having a go.
20:58:20 <startling> how easy it is to compile haskell in haskell code? I feel like you could keep a long-running haskell process that did all that
20:58:33 <startling> can you import GHC internals?
20:58:39 <blackdog> startling: it's unnecessary
20:58:47 <blackdog> he's only recompiling each time so you can pass the coords in
20:58:58 <blackdog> chuck a json parser on the front, and you're done.
20:58:58 <startling> heh
20:59:15 <startling> he's recompiling each time to stick some constants in? :/
20:59:17 <blackdog> i've timed out on it though
20:59:30 <blackdog> need to do real work now, feel free to take what i started and unfuck it further
20:59:40 <kylemcgill> LOL
20:59:41 <blackdog> they're not constants, they're the current positions
20:59:43 <startling> also, can you forkbomb ghc? maybe with template haskell?
21:00:08 <startling> blackdog: they're constants as far as the short-lived haskell program is concerned
21:01:01 <blackdog> yes, that's true.
21:01:20 <blackdog> i think you can run arbitrary code in TH.
21:02:14 <startling> poor guy
21:14:09 <kludgy> hallo.. is there a way to look up pretty function names on haskell.org? specifically in this instance I'm trying to find out what (~) is commonly used for
21:15:02 <startling> @hoogle (~)
21:15:03 <lambdabot> keyword ~
21:15:03 <lambdabot> Test.HUnit.Base (~:) :: Testable t => String -> t -> Test
21:15:03 <lambdabot> Test.HUnit.Base (~=?) :: (Eq a, Show a) => a -> a -> Test
21:15:18 <kludgy> nice thank you!
21:15:39 <startling> kludgy: http://www.haskell.org/hoogle/ if you don't feel like showing everyone what you're searching for. :)
21:16:06 <kludgy> That's invaluable. thanks for the info. :)
21:16:22 <startling> yep, it's very cool. you can also search by type signature
21:16:28 <blackdog> kludgy: even better: you can pass hoogle a type signature, and it'll tell you a list of things you might find useful
21:18:01 <kludgy> works a treat.. wish I had that for other languages
21:36:21 * hackagebot tagstream-conduit 0.4.0 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.4.0 (YiHuang)
21:53:22 <startling> is it worth implementing monads in a language that doesn't have type safety?
21:53:56 <copumpkin> the question is what that would even mean
21:54:17 <copumpkin> since a key part of the monad definition is the type-level action
21:54:30 <hpaste> diego_diego pasted “logging fcgi” at http://hpaste.org/70620
21:54:34 <startling> I really like how well monads work for parsing, for example
21:54:48 <diego_diego> hi all. complete haskell newbie here. I'm using the network.fastcgi (extends network.cgi) and I just want to log something to my server's (nginx) logs. Anybody that could help me out? here's what my current attempt sort of looks like
21:54:49 <diego_diego> http://hpaste.org/70620
21:55:28 <diego_diego> for some reason things seem to compile fine, but I don't see what I'd like to see ...
22:05:03 <orzo> why is System.GetProgramName returning an IO String.  The program name is ordinarily a constant throughout the programs life, right?
22:05:59 <startling> orzo, sure. so are args (getArgs is IO [String])
22:06:16 <startling> orzo, a referentially transparent function should always always run the same
22:07:01 <Ralith> why aren't args an argument to main?
22:12:52 <startling> Ralith: I always wondered about that too
22:17:37 <orzo> startling: im unclear on your last point.  It sounds like you're saying getProgramName should return in IO because getArgs does, but why not have both return pure values
22:18:08 <Ralith> orzo: that was just an example.
22:18:11 <startling> orzo, a function should return the same thing across runs
22:18:29 <orzo> and those functions do
22:18:37 <startling> orzo: ?
22:19:39 <orzo> if getProgramName returns "myprog" once, itll do it again if i invoke it again.  It always returns "myprog" until the program quits.  Does it not?
22:20:10 <startling> orzo, across runs
22:20:40 <startling> orzo, it'll be different if move that executable or symlink to it
22:21:32 <orzo> um.  but why is that important?
22:22:38 <orzo> i could wrap it up with unsafePerformIO and you think that could cause trouble?  The program will cache the value accross runs?
22:23:03 <startling> orzo, because it reflects the state of the world?
22:24:12 <startling> orzo, it has nothing to do with caching, that's just something nice that the compiler can do
22:24:35 <startling> orzo, it's a design choice. why are you using a purely functional language if you don't want pure functions?
22:24:57 <orzo> haskell is a general purpose language
22:25:13 <startling> orzo, yes?
22:26:01 <orzo> are you asking me some question?
22:26:11 <orzo> because it didnt come accross
22:26:28 <startling> orzo, that haskell is both a general purpose language and a (mostly) purely functional language
22:26:31 <orzo> i answered "why are you using a purely functional language" with "haskell is a general purpose language"
22:26:50 <orzo> meaning, why the hell not use haskell
22:26:59 <orzo> why should i defend the choice of language
22:27:05 <orzo> i dont do that for other languages
22:27:19 <orzo> maybe haskell was the only language i know
22:27:37 <startling> orzo, k? I'm just trying to explain the design choice
22:28:20 <orzo> i just missed the part of your explanation that involved any explaining
22:29:29 <startling> orzo: okay! i'll stop
22:31:06 <orzo> all the functional functions are ultimately state-affecting, its an illusion
22:31:07 <mewalz> Just discovered haskell-mode for emacs. I have no idea how to use emacs; but my productivity has somehow tripled.
22:31:21 <orzo> so it was an arbitrary choice where to draw the line
22:33:50 <orzo> maybe they thought an implementation might want to cache values accross runs and that's why they drewthe line where they did
22:34:27 <orzo> no other technical justificaiton occurs to me
22:36:05 <mgsloan> orzo: Based on your prior reactions, I have a feeling this might be in vain.. But, the reason it matters is for the sake of reasoning.  If a function is pure and safe, then you can be sure that you do not need to know anything else about how computation will proceed than the values it is given
22:36:38 <mgsloan> there is no arbitrariness involved.
22:38:34 <mgsloan> you could, as a part of the build process generate the definition programName = "foobarbaz"
22:38:37 <C0D3A11> Hey guys. I made a forum recently and im trying to recruit gamers, programmers, musicians and artists. Its brand new, so join and start posting to liven up the community! http://ellondusgamingrepublic.freeforums.org/index.php
22:38:41 <mgsloan> and then, there you go, a constant!
22:39:27 <mgsloan> but the module that defines getProgramName knows nothing of your program.
22:39:44 <meiji11> that guy has a glaring spelling error in his site banner. this irks me.
22:40:02 <orzo> heh, you actually visited his link
22:40:20 <meiji11> yeah, I'm like that :-/
22:40:45 <mgsloan> the meiji era's always curious about potential foreign influences
22:45:15 <orzo> mgsloan: i understand what you're saying and it is, despite what you say about prior reactions, more explanation than i was receiving.  Still there's a choice to favor this pure-reason timeless notion over a more practical, pure-for-this-run notion.  You say "pure and safe" but those are two different things.  Would it be unsafe to use unsafePerformIO to extract the progrma name from the IO monad?
22:46:03 <mgsloan> yes, it would, and safe actually has a very specific definition - http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/safe-haskell.html
22:46:24 <shachaf> mgsloan: What's the definition?
22:46:38 <mgsloan> shachaf - you're right, it's still fuzzy :)
22:47:56 <shachaf> "pure" is also fuzzy.
22:48:16 <shachaf> unsafePerformIO getProgName isn't going to segfault your program.
22:48:26 <mgsloan> as made clear in this thread, ended by the creator of safe haskell - http://www.haskell.org/pipermail/haskell-cafe/2012-June/101819.html
22:48:58 <shachaf> ...Hey, I just made getProgName segfault my program.
22:48:59 <mgsloan> "Trustworthy modules are inherently risky: they declare of themselves > that they're trustworthy, but really, they could do anything."
22:49:47 <shachaf> I guess this is a bug!
22:50:36 <mgsloan> orzo - anyway, this is a distinction that rarely makes any difference, and so Haskell libraries make the conservative choice.  You are certainly free to use "unsafePerformIO getProgName" if that's more appealing to you
22:50:39 <orzo> well even the code in the safe language surely is implemented by GHC which declared it safe but in fact can do whatever it wants
22:50:43 <dmwit> Only if you didn't write (withProgName segfault) or something!
22:50:53 <shachaf> Hmm, I can make a GHC-compiled program segfault even without explicitly using getProgName.
22:51:17 <dmwit> shachaf: There's a few cheap ways to get a segfault.
22:51:26 <mgsloan> right, you don't have assurance that GHC's implementation is correct.   Proving it so would take a lot more manpower than GHC currently has behind it
22:51:33 <dmwit> FFI/Storable stuff is one; GeneralizedNewtypeDeriving and TypeFamilies are another.
22:51:47 <shachaf> dmwit: I can make "main = return ()" segfault.
22:51:50 <mgsloan> but point is, our _idealized_ haskell has these properties - implementation doesn't matter
22:52:10 <dmwit> shachaf: And I suppose unsafe* and friends are a cheap way, too.
22:52:13 <dmwit> But do tell me more.
22:52:20 <mgsloan> dmwit: how can the latter two make it segfault?
22:52:52 <dmwit> http://hackage.haskell.org/trac/ghc/ticket/1496
22:54:18 <shachaf> Hah, it's a bug in the RTS.
22:55:14 <mgsloan> dmwit: holy cow!
22:55:40 <dmwit> Oh, wait, are we finding a technical justification for making getProgramName be an IO type?
22:55:57 <shachaf> void setProgName(char *argv[]) { char *last_slash; if ( (last_slash = (char *) strrchr(argv[0], '/')) != NULL ) { ... } else { ... } }
22:55:59 <dmwit> I've got a pretty good one: referentially transparent things should be able to be replaced with the value they evaluate to without changing the program semantics.
22:56:11 <shachaf> Can you spot the bug?
22:56:16 <MostAwesomeDude> I'd probably justify it with the fact that argv is editable in a lot of environments.
22:56:16 <dmwit> So if getProgramName was pure, I ought to be able to replace it with a constant string everywhere and get the same program.
22:56:26 <dmwit> But busybox et al show that this is *not* a correct program transformation.
22:56:45 <MostAwesomeDude> dmwit: Yeah, that's a great reason.
22:57:13 <startling> MostAwesomeDude, oh, didn't even think of that
22:57:24 <startling> MostAwesomeDude: that's a *really* good reason
22:58:17 <MostAwesomeDude> startling: One thinks of these things after enough years of C. :3
22:59:02 <startling> MostAwesomeDude: I don't even want to imagine
22:59:23 <MostAwesomeDude> startling: How do you think getenv() and setenv() work?
22:59:32 <startling> I just want to thank the genius who decided not to just have argv null-terminated
22:59:55 <MostAwesomeDude> Also there are libraries like GTK+ that expect you to pass argv and argc in, and return mod'd argv/argc that only have non-GTK+ arguments left over.
23:00:38 <startling> >:(
23:00:52 <MostAwesomeDude> Yeah, IKR?
23:03:39 <otters> @pl \f a b -> f a 0 b
23:03:39 <lambdabot> flip flip 0
23:04:05 <MostAwesomeDude> :t flip flip 0
23:04:06 <lambdabot> forall (f :: * -> *) a b. (Functor f, Num a) => f (a -> b) -> f b
23:04:26 <startling> weird
23:06:24 <orzo> dmwit: why did you use busybox as an example
23:07:18 <startling> orzo: busybox is an executable that's linked as a bunch of things, and then it detects which link it was called as to determine what to do
23:07:45 <orzo> okay
23:09:18 <startling> if it were written in haskell, it would presumably use getProgName
23:09:35 <MostAwesomeDude> There's not a Haskell busybox yet? :c
23:09:44 <orzo> heh
23:11:13 <dmwit> Sure there is.
23:11:21 <dmwit> On the wiki for simple Unix utils, they use exactly that approach.
23:11:28 <MostAwesomeDude> Is it on hackage?
23:13:10 <Brofessional> Is there anything like any and all for arbitrary Foldables?
23:13:25 <Brofessional> Oh, never mind.
23:13:34 <Brofessional> I just had to import Data.Foldable
23:14:52 * dmwit shrugs at MAD
23:18:54 <MostAwesomeDude> dmwit: Just curious. When we build our pure-Haskell OS to take over the world, it's important that we have a busybox.
23:20:05 <orzo> "pure-Haskell" is ambiguous in the meaning of pure
23:20:09 <orzo> heh
23:21:02 <startling> MostAwesomeDude: haha
23:21:14 <startling> it'd be pretty cool if someone wrote a lower-level functional language
23:21:31 <startling> maybe laziness is too unpredictable for a low-level language, but meh
23:21:32 <MostAwesomeDude> startling: Google for "haskell house kernel".
23:21:35 <orzo> anybody here use neil mitchell's CmdArgs module?
23:21:44 <blackdog> orzo: yeah
23:21:59 <blackdog> are you hitting the problem with having TH and profiling turned on? :)
23:22:03 <startling> MostAwesomeDude: i've seen it
23:22:14 <orzo> no
23:22:39 <orzo> I just started looking at it and then ended up leaning otward plain old getOpt
23:23:45 <orzo> it is simpler to use, that's true, but its also unsettling to me
23:24:16 <orzo> for example, it gleens the program name from the name of the type you declare
23:24:41 <orzo> which wasn't at all clear from the intro i was reading as he used the same word Simple in a dozen places
23:26:32 <orzo> and then the use of attributes with the &= operator to make annotations that are available only the firest time a value is evaluated seems a bizare choice to me
23:27:40 <orzo> so although its simpler given you know how ot use it, it seems not as nice to read if you aren't already very familiar with it
23:27:45 <MostAwesomeDude> Are any of the people responsible for Haskore in here?
23:33:40 <orzo> i notice hascore mentions lilypond as a TODO output format.  I've experience with abc notation and was very pleased with it, so the authors should probably consider that as well.  It's probably easier.
23:34:06 <orzo> in fact, im not sure why i'd use hascore when i could use abc
23:34:10 <orzo> heh
23:34:57 <MostAwesomeDude> I *really* don't like dealing with ABC.
23:35:06 <MostAwesomeDude> I wrote a thing that parses *in* Lilypond.
23:35:58 <orzo> you wrote an abc parser in lilypond input format?
23:36:28 <MostAwesomeDude> No, I wrote a parser in Python (and Haskell, somewhat) that parses Lilypond to a meta-MIDI format.
23:38:09 <orzo> what is it about abc that you dont like?
23:39:29 <MostAwesomeDude> b3 is a pretty big problem.
23:39:48 <orzo> b3?
23:40:05 <orzo> paper size?
23:40:18 <MostAwesomeDude> No, the note. b3 is a dotted-quarter.
23:40:25 <MostAwesomeDude> I much prefer Lilypond's b4. instead.
23:41:01 <orzo> oh
23:44:15 <orzo> isn't lilypond harder to parse?
23:44:55 <MostAwesomeDude> Very. :3
23:44:58 <MostAwesomeDude> But I don't mind.
