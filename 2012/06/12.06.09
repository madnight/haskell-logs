01:58:25 * hackagebot hspec 1.1.2 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.1.2 (SimonHengel)
01:58:31 <osa1> is there a way to draw png images in gloss?
02:11:04 <zzo38> Although the Monad class does not allow monads on subcategories (so that constraints are required for the types), it is possible to make the Category class do so, to make the subcategory of (->) where objects are types having instance of Ord or whatever you want
02:14:06 <zzo38> And using that you can even make up the Kleisli category of Set and so on
02:23:57 <zzo38> What are your opinions about the implicit parameters extension?
02:26:02 <benmachine> it's quite rarely used
02:26:16 <benmachine> for that reason at least it should probably be avoided, because it's not that recognisable
02:28:18 <Franciman> hey gents, is there any "functional" OS ?
02:28:23 <zzo38> I also don't use it. But, in Ibtlfmm with idea I have written about, and someone also said they wanted to be able to have local instances, which I agree, then implicit parameters can simply be defined by local instances and specified by a constraint mentioning a class method like (method k :: Integer) is a valid constraint.
02:28:35 <Franciman> I mean an OS written with an functional language
02:28:40 <Franciman> *a
02:32:20 <augur> hey peeps
02:32:24 <augur> whats some good reading
02:33:06 <benmachine> zzo38: yeah, implicit parameters can give you sort of local instances; there are good reasons why instances are global though
02:35:24 <zzo38> benmachine: Yes I know, and I have also considered how to deal with the problems they are able to cause
02:38:07 <Ralith> benmachine: what are those reasons?
02:39:22 <benmachine> Ralith: well, consistency: for example if you have a Set from Data.Set, it needs to use the same instance when you're inserting as when you lookup
02:39:27 <benmachine> otherwise it outright won't work
02:39:53 <benmachine> that's a good start
02:40:13 <benmachine> and general sort of coherence, so that two pieces of code that look the same will behave the same
02:40:26 <Ralith> you could use the same argument against lexical scoping in general.
02:40:46 <benmachine> you could
02:41:29 <benmachine> but I suppose the ideal is that you have some behaviours that you want to be consistent
02:41:33 <benmachine> like equality testing
02:41:35 <zzo38> benmachine: I do understand those things. I have considered the way to make it work, make it so that (Set Integer) is a different type when (Ord Integer) is a different instance, so the type include the instance tag. This is what I have in idea of Ibtlfmm (I have posted the URL here before perhaps you have read it?)
02:41:38 <benmachine> and some behaviours that you want to be specific
02:41:53 <benmachine> zzo38: I have not read it
02:41:57 <benmachine> I've not been in here for a while
02:42:00 <benmachine> just rejoined yesterday
02:42:29 <theadmin> Ugh, anybody up to help a newbie? I'm trying to write a ridiculously simple countdown thing, and it works like this: http://sprunge.us/BADC -- however, when I try to make it an actual countdown... http://sprunge.us/LNOK -- can someone explain what it wants >.<
02:43:17 <osa1> how can I place executable generated by ghc to another folder? I'm using -outputdir but it's putting the executable in folder I run ghc instead of -outputdir
02:43:36 <zzo38> theadmin: The types are wrong.
02:44:01 <theadmin> zzo38: I can tell that much, but... Why is it complaining about the type of print? print is not the return value of count (or is it for some reason?)
02:44:10 <theadmin> Err, sleep, not print
02:44:16 <zzo38> theadmin: Do like this:  count 0 = putStrLn "Done!"; count n = sleep 1 >> print n >> count (n - 1);
02:44:30 <theadmin> ...What's that >> do?
02:44:51 <zzo38> theadmin: The same as multiple lines in a do-block, just not using do
02:45:00 <Cale> If x and y are actions then x >> y is the action which first performs x and then y, producing the result of y
02:45:18 <Cale> You can just as well write  count n = do sleep 1; print n; count (n-1)
02:45:33 <theadmin> zzo38: But if it's the same and I have multiple lines in a do block and it fails then this won't help, no?
02:46:32 <Cale> theadmin: the main problem with your code is that you have a string on one of the lines of your do-block
02:46:39 <zzo38> theadmin: The reason is that sleep is IO action and then you have a string there so it is not a IO action
02:47:10 <Cale> sleep 1 is (presumably) an IO action
02:47:11 <zzo38> theadmin: Use what I have and then    main = count 5;   and then it might work.
02:47:30 <theadmin> Ugh, types are so confusing -_-
02:48:08 <Cale> theadmin: An IO action of type IO t is a description of some stuff which could be done in order to produce a value of type t
02:48:18 <zzo38> theadmin: The type of some I/O action resulting in x would be (IO x) and >> and so on just combines them together
02:49:08 <Cale> You can combine IO actions using a do-block. Inside of a do, putting an action by itself on a line means to run that action and discard its result, while v <- x where x is some action means to run the action x, and name its result v
02:49:24 <Cale> The do-expression as a whole will be another IO action
02:49:40 <dmwit> Funny, my complaint would have been that he had "sleep 1", not that he had a String. =D
02:50:03 <Cale> Well, he obviously wants to leave a delay in between printing the strings
02:50:15 <zzo38> theadmin: The type () has only the value () and nothing else, so it contains no information; since print and putStrLn do not return a result to the program their result is () like how a function in C has void
02:50:15 <Cale> So taking that out will spoil his intention
02:50:58 <Cale> except that void has no values, and () has one
02:51:04 <theadmin> zzo38: Okay, the one you suggested works just fine, except... How come it adds newlines even though I use "print", not putStrLn?
02:51:20 <Cale> print = putStrLn . show
02:51:24 <zzo38> theadmin: print = putStrLn . show
02:51:31 <theadmin> zzo38: What's the dot mean? >.<
02:51:39 <Cale> print x = putStrLn (show x)
02:51:41 <zzo38> theadmin: The dot means both function
02:51:49 <Cale> (f . g) x = f (g x)
02:51:54 <Cale> ^^ the definition of (.)
02:51:55 <zzo38> theadmin: Like Cale wrote, that is what it means
02:52:09 <Cale> It's function composition
02:52:34 <theadmin> Ah... Man, Haskell is way cool but way hard (I'm all new to functional programming altogether, it took a while to realize how to deal without loops and variables...)
02:53:04 <hpaste_> myxol pasted “elerea stateful” at http://hpaste.org/69730
02:53:15 <myxol> can someone help me?
02:53:51 <zzo38> theadmin:   putStrLn :: String -> IO ();   means that putStrLn is a function that receive a string, the output will be I/O action that displays that message.
02:54:17 <shachaf> Cale: void has a value in C!
02:54:24 <shachaf> I mean, it's inhabited.
02:54:33 <theadmin> zzo38: I see... So uh, statements inside a do {} block must always be of type IO something?
02:54:41 <zzo38> In C, "void" is not really a type but a lack of a type.
02:54:42 <Cale> shachaf: oh?
02:54:49 <zzo38> theadmin: Basically, yes.
02:54:55 <shachaf> Cale: Well, I guess "inhabited" is a little weird here.
02:55:00 <Cale> shachaf: what C value has type void?
02:55:10 <shachaf> Cale: But it's very easy to return void from a function!
02:55:30 <theadmin> zzo38: And... no way to avoid that? As in, how about a multi-statement (and multi-line, so not ugly-looking) function which returns, I dunno, an Int for example?
02:55:38 <shachaf> Cale: I've complained several times that you can't make values of type void.
02:55:47 <dmwit> myxol: funny, that's the exact sample code taken from the documentation ^_^
02:55:48 <shachaf> It's just a weird special-case in the language.
02:55:59 <myxol> dmwit: yep.
02:56:01 <shachaf> In gcc you can say void foo(); void bar() { return foo(); }, but I don't think that's standard.
02:56:11 <Cale> theadmin: You should think of do-blocks as a way to glue together IO actions (actually, they're more general, it doesn't have to be IO actions)
02:56:13 <zzo38> theadmin: There is "return" for that, for example:   return 'x'    is of type     IO Char    (for the IO monad, that is)
02:56:15 <dmwit> myxol: Maybe you should write to Patai (the author and maintainer) and see what he says.
02:56:15 <shachaf> In C++ having values of type void would actually be very useful.
02:56:17 <companion_cube> i think it is, and it should be a tail call
02:56:27 <dmwit> myxol: Alternately, see if you can read the source and figure out what's going wrong on your own.
02:56:28 <shachaf> (Rather than just theoretically nice.)
02:56:51 <theadmin> zzo38: Can you show some example? I think "return" in Haskell is not the "return" I'm used to %)
02:56:52 <companion_cube> shachaf: you mean, void-typed values as first order actions?
02:56:59 <myxol> dmwit: does Patai come to this channel?
02:57:02 <zzo38> theadmin:   return 'x'   performs no I/O action; it only indicates the result.
02:57:03 <shachaf> companion_cube: No, I mean as values.
02:57:04 <Cale> theadmin: for example, since  getLine :: IO String  and  putStrLn :: String -> IO ()  we have  (do x <- getLine; putStrLn x) :: IO ()
02:57:05 <companion_cube> in a similar way to IO () ?
02:57:14 <dmwit> myxol: I don't recognize the name, so I suspect not.
02:57:15 <shachaf> No, just uninhabited values.
02:57:21 <Cale> return v is the IO action which does nothing, and returns v every time
02:57:22 <shachaf> Er.
02:57:24 <myxol> okay
02:57:25 <shachaf> Inhabited.
02:57:25 <companion_cube> uh, ok
02:57:30 <theadmin> zzo38: Ah, I see.
02:57:30 <companion_cube> what would it be useful for?
02:57:42 <Cale> (do x <- getLine; putStrLn x; return v) :: IO String
02:57:47 <Cale> er
02:57:51 <Cale> s/v/x/
02:58:00 <Cale> (do x <- getLine; putStrLn x; return x) :: IO String
02:58:07 <Obfuscate> shachaf: The point to void in C++ is that it does /not/ represent a value at all. You're thinking of a 'unit' type, which you can trivially have in C++: it's just an empty struct.
02:58:23 <theadmin> By the way, does Haskell have any support for regular expressions of any sort?
02:58:32 <Cale> There's library support
02:58:33 <shachaf> Obfuscate: But that's not really the same as void.
02:58:40 <Cale> The language itself doesn't do anything to support them
02:58:41 <dmwit> That's misleading. void in C/C++ is a unit type which is implicitly discarded, not a type with no value at all.
02:58:50 <shachaf> What dmwit said.
02:59:07 <Cale> Also, because there are parser combinator libraries, you're unlikely to actually want to use regular expressions for much
02:59:13 <zzo38> dmwit: Maybe, but in my opinion, void in C is the lack of a type.
02:59:17 <shachaf> companion_cube: Something like: template <typename res_t>res_t foo(...) { struct { res_t res; run() { res = ...; } s; ...; return s.res; }
02:59:32 <Cale> Unless your application wants to give the user the ability to use regular expressions somehow.
02:59:36 <Obfuscate> dmwit: No. It's not possible to instantiate void at all, hence you can never discard it.
03:00:02 <dmwit> Obfuscate: Incorrect. "return;" implicitly instantiates (and then the caller implicitly discards) a value of type void.
03:00:07 <shachaf> Obfuscate: If it was "uninhabited" in the standard sense, you couldn't return it from functions.
03:00:36 <companion_cube> theadmin: yes, there is
03:00:39 <dmwit> Simply ending the function block performs a similar set of implicit construction/destruction pairs.
03:01:00 <companion_cube> theadmin: http://www.haskell.org/haskellwiki/Regular_expressions
03:01:27 <Cale> shachaf: Can you allocate a void on the stack?
03:01:30 <dmwit> It is a type with one inhabitant, which the language therefore lets you elide for brevity.
03:01:39 <dmwit> Cale: Yes, in a zero-bit register, for example. =)
03:01:42 <theadmin> companion_cube: So you *do* speak after all! :P
03:02:03 <shachaf> Cale: It's a weird special-cased type that doesn't let you do that for not much of a reason.
03:02:11 <dmwit> () in Haskell is also badly named, since it has two inhabitants (and hence can't be stuffed in a zero-bit register).
03:02:17 <Obfuscate> dmwit: Due to my pdfreader screwing up, I can't look the wording in the standard, but since the old C days, functions returning void do not return a value at all for the caller to discard.
03:02:33 <Ralith> dmwit: two inhabitants?
03:02:34 <zzo38> dmwit: Well it only has one defined inhabitant; the other one is undefined.
03:02:37 <shachaf> Obfuscate: What's the difference there?
03:02:38 <Ralith> :P
03:02:39 <dmwit> Obfuscate: That is merely an optimization. =)
03:02:52 <dmwit> Ralith: Yes, () and infinite loops/exceptions/etc.
03:03:20 <Obfuscate> dmwit: It's not merely an optimization. The point is that you never get a value that you need to discard.
03:03:38 <dmwit> Yes, eliminating unnecessary data structures is what I call an optimization.
03:03:39 <shachaf> What does it even mean to "discard" a value?
03:03:58 <theadmin> shachaf: Never store it anywhere? I dunno
03:04:06 <zzo38> dmwit: That is why I say there is only one defined inhabitant. Undefined is like the lack of a value, I suppose.
03:04:20 <dmwit> This is the idea behind list fusion and friends in Haskell, too: never constructing intermediate lists that are about to be consumed anyway.
03:04:49 <dmwit> It's just that unit fusion is particularly easy to implement, so it's been in the spec since forever. =)
03:04:50 <shachaf> zzo38: dmwit's point is that you still need to keep an actual value for it somewhere, because it could be two different things.
03:04:58 <theadmin> Does Haskell have anything like Perldoc? Some built-in commandline documentation reader thingo, basically
03:05:22 <theadmin> Or not built-in, but available around
03:05:24 <shachaf> I think there's just the HTML Haddock generates.
03:05:32 <Obfuscate> shachaf: You can create an empty struct (which is effectively an "empty" value), and then discard it, but such a value has a type and can be passed to functions. You can't pass void around; you can't return void. You can take the address of a value and cast it to a void*, but that's a different concept, because there is no void "value".
03:05:36 <shachaf> I prefer to read the sources, which have all the information anyway.
03:06:09 <zzo38> shachaf: Yes that is because of semantics of errors in Haskell. Specification of Ibtlfmm is such that for compiled programs there is no need to keep track of it in that case (but interpreted programs work like Haskell).
03:07:50 <shachaf> zzo38: The semantics of errors in Haskell is precisely what dmwit is talking about.
03:08:23 <zzo38> shachaf: Yes, that is
03:09:41 <hilhil> Would anyone have any idea why I might get a 'realgcc.exe: ": Invalid argument' error while linking?
03:09:41 <Cale> How many compilers are there for Ibtlfmm? ;)
03:09:59 <hilhil> (On Windows)
03:10:04 <theadmin> Because Windows is Windows :P
03:10:07 <theadmin> *hides*
03:11:01 <dmwit> Obfuscate: Here's the main point we're trying to make: when we say "empty type" we mean something very different from what you mean when you say "empty type".
03:11:06 <Cale> hilhil: which ghc are you using?
03:11:19 <dmwit> Obfuscate: We're trying to teach you a bit about what we mean when we say "empty type". You can learn a bit, or not, as you please.
03:11:27 <hilhil>  version 7.0.3
03:11:31 <hilhil> (Came with the Haskell platform)
03:12:17 <Cale> hmm
03:12:19 <hilhil> http://hpaste.org/69731
03:12:24 <dmwit> Obfuscate: Namely: we don't mean a type that merely contains no data, but rather a type which indicates *something has gone wrong*.
03:12:42 <hilhil> Gives a bit more detail. (This all started happening after I switched on profiling, and reinstalled libraries with the profiling options.)
03:12:49 <Cale> The only reference to something like that problem has to do with localised versions of windows... something funny about code pages
03:12:51 <Obfuscate> dmwit: I'm aware. I was responding to shachaf's confusion about void in the context of C++, where the behavior is very different from that of Haskell.
03:13:05 <dmwit> shachaf is not confused about the behavior of void in C++.
03:13:44 <dmwit> He's just using different terms than you're used to when describing his understanding of it.
03:14:17 <dmwit> Or, possibly more insidiously: terms you're used to, but with *meanings* different to what you're used to.
03:14:23 <hilhil> Cale: Is there anything I can do to work around it?
03:14:38 <shachaf> dmwit: What I said was that I wish you could have values of type void.
03:14:46 <Cale> hilhil: I'm not a windows user, so I have no idea what you'd do
03:14:54 <Cale> hmm
03:14:57 <hilhil> ah well. thank you anyway.
03:15:23 <Obfuscate> dmwit: I'll take that as is. I have no means of determining whether he actually is confused or not: merely that it /appears/ that way.
03:15:29 <dmwit> shachaf: What motivates your wish? =)
03:15:37 <shachaf> dmwit: There are reasonable reasons not to like that idea -- for example, two different variables in C++ must have two different addresses.
03:15:41 <shachaf> Which causes a bit of a problem.
03:15:48 <shachaf> dmwit: See my excerpt to companion_cube above.
03:15:56 <shachaf> Something like: template <typename res_t>res_t foo(...) { struct { res_t res; run() { res = ...; } s; ...; return s.res; }
03:15:58 <Cale> hilhil: If you can't find help here, be sure to try the Haskell-cafe mailing list.
03:16:25 <hilhil> ok -- thanks!
03:16:30 <Cale> There *are* windows users out there
03:16:44 <Cale> I'm not sure how many of them are awake right now though
03:17:10 <dmwit> shachaf: Ah, yes, for uniformity it would indeed be nice.
03:17:34 <shachaf> dmwit: In particular for a piece of code a lot like that I had to write it twice, once with void and once without.
03:17:42 <dmwit> right
03:17:58 <shachaf> dmwit: (The ..., by the way, is a function that returns void, or something similar.)
03:18:09 <shachaf> s/void/res_t/
03:18:12 <shachaf> Anyway, you get the point.
03:18:23 <hilhil> ah, wait -- it fails from the command line, but works via Leksah. weird but serendipitous.
03:18:26 <dmwit> Yes, it would be nice if the spec talked about it as if there were 0-bit variables which were required to be fused away.
03:18:49 <Cale> hilhil: weird! :)
03:19:28 <dmwit> That said, it's a subtle enough issue that I think the original C guys can be forgiven for not spotting it.
03:20:21 <Cale> hilhil: I've heard about "invalid argument" errors happening in windows when a program assumes that it can encode characters in UTF-8 but instead Windows wants its funny default codepage 1252 or whatever.
03:20:39 <shachaf> dmwit: As I mentioned, there's the issue with addresses.
03:20:39 <hilhil> I've had a lot of assorted Unicode headaches.
03:20:47 <dmwit> The horrible "void *" pun (rather than having some kind of "any" type) makes it worse, yes.
03:20:47 <hilhil> And my code does include Unicode characters.
03:20:47 <shachaf> (Which is one of the places that C disagrees with C++, by the way.)
03:20:51 <hilhil> So that sort of makes sense
03:21:00 <shachaf> (struct foo {}; What's sizeof (foo)?)
03:21:10 <shachaf> sizeof (struct foo), rather.
03:21:18 <dmwit> If there were distinct "void *" and "any *", the addressing thing would be no problem.
03:21:27 <shachaf> ...And why are we talking about that in here instead of, say, in #-blah?
03:21:38 <dmwit> ...
03:21:40 * dmwit shuts up
03:21:47 <shachaf> You should join #-blah instead!
03:21:55 <DrSyzygy> because #haskell has ambitions on being #plt ? ;-)
03:24:15 <osa1> is there a way to draw png images with gloss?
03:25:41 <hilhil> Hmmm...how would I switch on '-rtsopts' via Cabal? (Actually need to do it via Leksah, but I can probably figure it out if I know the Cabal...)
03:27:10 <dmwit> osa1: You have the same tools for searching the documentation as we do. If you haven't found it, you're probably right.
03:27:11 <Cale> ghc-options: -rtsopts
03:27:18 <hilhil> thanks
03:27:51 <Cale> In other news, I hate that flag, and wish that GHC would leave it on by default.
03:29:06 <benmachine> Cale: I don't see the big deal
03:29:06 <hilhil> Switching on profiling is turning out to be rather more work than I expected!
03:29:22 <benmachine> it always struck me as weird back when any Haskell application automatically exposed itself as such
03:29:27 <benmachine> automatically and irrevocably!
03:29:57 <Cale> benmachine: It's annoying to realise that you need to recompile something because it wasn't compiled with -rtsopts
03:30:15 <benmachine> Cale: I guess I just don't use RTS options enough that it's ever been a problem for me
03:30:52 <benmachine> besides, the original reason they were turned off is because setuid binaries could write arbitrary files
03:30:52 <dmwit> DrSyzygy: What does PLT stand for? I'm having a heck of a time finding out by searching around online...
03:30:56 <benmachine> which was... un-ideal
03:31:10 <hilhil> Adding that line ('    ghc-options: -rtsopts') to the cabal file stops linking from working
03:31:16 <benmachine> or maybe not arbitrary but certainly files that they oughtn't
03:31:28 <benmachine> hilhil: huh, what's the error?
03:32:01 <Cale> benmachine: But how often do you setuid a binary that wasn't specifically designed to be setuid?
03:32:27 <Cale> Hopefully not that often!
03:32:33 <benmachine> heh, fair point
03:32:44 <benmachine> but what if I specifically designed it so, but didn't know about obscure profiling options?
03:32:51 <benmachine> after all, I didn't write them into my program at all
03:33:15 <Cale> If you're a Haskell programmer and you don't know about the existence of RTS options, maybe you shouldn't be writing setuid programs yet.
03:33:21 <hilhil> benmachine: Leksah dispalys nothing
03:33:25 <Cale> :)
03:33:54 <Cale> I dunno, I guess it's *possible* that it could bite someone
03:34:03 <hilhil> cabal build gives
03:34:04 <hilhil> realgcc.exe: n7\Tools♠: No such file or directory
03:34:08 <hilhil> anyway, never mind
03:34:15 <hilhil> I'l give up on profiling
03:34:17 <Peaker> it's not just a setuid thing, it's also a network thing...
03:34:19 <Cale> But I don't think anyone actually has been bitten by it.
03:34:47 <benmachine> Cale: well, as far as we know no-one's been bitten by how hideously insecure hackage is yet :P
03:34:52 <benmachine> that doesn't make it a good thing
03:35:27 <benmachine> which reminds me, now that exams are done I should take another look at hackage 2
03:35:55 <ahax> hello
03:35:58 <benmachine> hi
03:36:11 <Cale> benmachine: The insecurity of Hackage is a problem that in my mind seems at least a few orders of magnitude more important. (and yet it's still not that big a deal somehow)
03:36:23 <ahax> does anyone have troubles using blaze-html ?
03:36:37 <benmachine> ahax: I use it just fine
03:36:47 <Cale> hilhil: Something is almost certainly mangling a commandline somewhere.
03:37:00 <ahax> do you have to use toValue for an Attribute?
03:37:12 <ahax> I have to do this:
03:37:17 <ahax> simpleImage = img ! src (toValue "foo.png")
03:37:18 <benmachine> ahax: usually I use OverloadedStrings
03:37:26 <ahax> aahh
03:37:30 <ahax> i check
03:37:30 <Cale> hilhil: the spade is awfully weird
03:38:53 <ahax> benmachine: thanks!
03:39:03 <ahax> it works fine now
03:39:21 <ahax> this part of the tutorial slipped out of my head
03:39:23 <benmachine> ahax: sometimes I have to use toValue anyway, when I'm not writing a literal string
03:39:24 <ahax> thanks again
03:39:32 <benmachine> but yeah, no problem
03:39:32 <ahax> ok, good to know
03:41:02 <benmachine> you know what strikes me as really strange? the blurb on http://www.haskell.org/ doesn't mention the type system *at all*
03:48:01 <ahax> maybe it's too specific
03:48:20 <ahax> even if it's a great sttrength
03:49:18 <ahax> it doesn't say it's lazy too
03:52:05 <benmachine> ahax: yeah, that's a good point
03:53:43 * hackagebot test-framework-doctest 0.2.1.2 - Test.Framework wrapper for DocTest  http://hackage.haskell.org/package/test-framework-doctest-0.2.1.2 (SimonHengel)
03:56:39 <DrSyzygy> dmwit: Programming Language Theory
03:57:51 <dmwit> Well, I got the P and the L right. =)
04:25:00 * mekeor has a crush on lambdabot *blush*
04:25:01 <lambdabot> mekeor: You have 1 new message. '/msg lambdabot @messages' to read it.
04:25:12 <mekeor> wow! this is my first message! oO
04:25:24 <mekeor> i always wanted to get one!
04:25:57 <Franciman> lol
04:27:26 <mekeor> wow… i got a very important, secret message. i mustn't talk about it… it's from FBI. oO
04:28:03 <Taneb> If you're not allowed to talk about it, why are you talking about it? :P
04:29:06 <taylorgb_> Taneb: It said that it was imperative he not speak about it, we only do functional here.
04:29:14 <Taneb> :)
04:36:06 * Baughn grumbles about the size of Hackage
04:36:13 <Baughn> ..there are /too many/ pckages, I can't find one for UDP
04:37:01 <mekeor> Baughn: use http://hackage.haskell.org/packages/archive/pkg-list.html and hoogle and hayoo and google.
04:37:14 <Baughn> mekeor: Oh, I'm seeing it.
04:37:19 <Baughn> I'm seeing it, it just isn't /helping/.
04:37:27 <Baughn> Guess I'll use the base network package.
04:37:47 <taylorgb_> UDP is a little non-specific, what are you wanting to do?
04:38:08 <Baughn> Send and receive UDP packets.
04:41:25 <Peaker> Baughn, haven't seen you in a bazillion years :)
04:41:52 <Kashyap_> Can someone please point me to a good resource on using Data.Graph -
04:45:27 <fmap> Kashyap_: when i had to use it it was fairly intuitive, do you have any specific question?
04:46:02 <Kashyap_> hmmm ... well looking at the documentation, I was not able to figure out how to create a graph
04:46:51 <Kashyap_> I am trying to create a graph of various screen navigation's in my app .... for which I need to create a graph of data type Screen (Screen is my own data type)
04:48:29 <fmap> Kashyap_: there is a `Building graphs' section in the documentation
04:49:12 <Kashyap_> can you give me an example of creating a graph 1 -> 2 -> 3 and 3  pointing back to 1 ... graph of integers
04:50:28 <Kashyap_> I tried with buildG ...was not quite working out
04:52:27 <hpc> buildG (1, 3) [(1,2),(2,3),(3,1)]?
04:52:55 <hpc> might need to change the (1,3) param around; i don't know if that's an off-by-one error
04:52:56 <fmap> or something like `graphFromEdges [(0, 1, [2]), (0, 2, [3]), (0, 3, [1])]'
04:54:37 <fmap> (you might need to extract Graph from tuple then)
04:54:39 <Kashyap_> wow ... thanks hpc and fmap .... looks like it works ...this is what I've been trying -
04:54:41 <Kashyap_> bounds = (2,2) e1 = (0,0)  --g = buildG bounds [e1]
04:55:06 <Kashyap_> kept giving me array *** Exception: Ix{Int}.index: Index (0) out of range ((2,2))
04:56:18 <Kashyap_> hpc - can you help me understand the "bounds" parameter of buildG ... why 1x3 ?
04:56:55 <hpc> (first node, last node)
04:57:07 <hpc> [list of (edge from this node, to this node)]
04:57:41 <adminuser> say i want to manage my projects dependencies in a folder vendor/ (as sources). would cabal-dev be the right tool for that?
04:58:00 <Kashyap_> oh ... got it... I think I should read up Array to understand more
04:58:04 <Kashyap_> but I get it
04:58:11 <Kashyap_> thanks a lot folks
04:58:22 <hpc> hdev: i think so; haven't ever used cabal-dev before though
05:00:41 <hpc> hdev: basically you would cabal-dev install stuff from vendor/ as you normally would, but it is registered just for a specific set of projects
05:02:41 <hdev> hpc: i thought of using it as a way to reference specific git checkouts of various dependencies, that change rapidly, so i would just have to make a simple cabal-dev install to install all dependencies whenever they change
05:04:47 <hpc> my off-the-cuff answer would be to use make to handle the "when they change" and git checkouts, then make calls cabal-dev
05:04:49 <hpc> but that would be horrible
05:17:38 <hpc> finally got around to learning haddock markup, and it's quite nice
05:17:57 <hdev> hpc: it appears cabal-dev only creates a sandbox environment, i'm still missing a tool here. I expected it to rebuild the dependency if i increase the version number in the library
05:19:11 <hdev> so i manually have to cabal install each dependency whenever i make a change there?
05:19:39 <hpc> hdev: perhaps make, or a bit of perl
05:20:18 <hdev> hpc: i hoped there already was a tool for that, can't be i'm the first one being in need for something like this
05:21:17 <hdev> i also don't understand why i have to manually unpack each package in cabal to see its source. Really hard to setup development tools (tags) for something like this
05:25:37 <teneen> What's a use for mfix for lists?
05:28:17 <hpc> > mfix (\x -> 1 : 2 : [x * 2, x * 3])
05:28:21 <lambdabot>   mueval-core: Time limit exceeded
05:28:24 <hpc> :(
05:29:28 <hpc> > mfix (\_ -> [])
05:29:28 <lambdabot>   []
05:30:18 <hpc> > mfix (\x -> 1 : x : [])
05:30:21 <lambdabot>   mueval-core: Time limit exceeded
05:30:27 <mekeor> i guess: mfix :: Monad m => a -> m a -- ?
05:30:27 <hpc> i have no clue
05:30:33 <mekeor> @type mfix
05:30:34 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
05:30:39 <mekeor> oh
05:30:49 <mekeor> a -> m a -- is return…
05:31:00 <hpc> mfix f = case fix (f . head) of []    -> []; (x:_) -> x : mfix (tail . f)
05:31:34 <hpc> > mfix (\_ -> [1..])
05:31:35 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:34:35 <hpc> > head (mfix (\x -> 1 : x : []))
05:34:36 <lambdabot>   1
05:35:07 <mekeor> > mfix (:[])
05:35:11 <lambdabot>   mueval-core: Time limit exceeded
05:36:57 <mekeor> > mfix (\x -> [x+1])
05:37:00 <lambdabot>   mueval-core: Time limit exceeded
05:40:11 <mekeor> what's the best way to write a function 'f :: String -> [String]' such that e.g.: f "123" = ["123"]; f "123+123" = ["123","+","123"]; f "123+(234+345)" = ["123","+","234+345"] -- ?
05:40:26 <hpc> mekeor: parsec
05:40:39 <mekeor> hpc: is it difficult?
05:40:44 <hpc> shouldn't be
05:40:58 <hpc> use (many isDigit), etc
05:41:19 <mekeor> do i have to read a long tutorial/paper or so?
05:41:24 <mekeor> i don't like reading much…
05:42:09 <mekeor> also, is "happy" easier/better?
05:43:47 <mekeor> hmm… actually http://legacy.cs.uu.nl/daan/download/parsec/parsec.html isn't thaat long…
05:43:48 <hpc> well, are you familiar with parser generators like yacc?
05:43:57 <teneen> hpc: Ok I kinda understood mfix
05:44:07 <mekeor> hpc: nope.
05:44:12 <hpc> go with parsec :P
05:44:24 <mekeor> hehe :D OK =)
05:45:26 <hpc> honestly, the hardest part is likely going to be figuring out where to put "runParser"
05:45:27 <teneen> @let fibs = mfix (\f -> return (\n x -> n:f x (n+x))) >>= \f -> f 0 1
05:45:28 <lambdabot>  <local>:9:0:
05:45:28 <lambdabot>      Multiple declarations of `L.fibs'
05:45:28 <lambdabot>      Declared at: <local...
05:45:31 <hdev> hpc: cabal-meta is what i was looking for, thanks for your help
05:45:41 <teneen> > take 10 fibs
05:45:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
05:45:54 <hpc> hdev: oh, neat
05:46:14 <mekeor> @let someOtherIdentifierNameHere = mfix (\f -> return (\n x -> n:f x (n+x))) >>= \f -> f 0 1
05:46:15 <lambdabot>  Defined.
05:46:19 <mekeor> > take 10 someOtherIdentifierNameHere
05:46:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
05:47:03 <fmap> mekeor: btw there is nice expression parser in parsec already (Text.Parsec.Expr iirc)
05:47:07 * mekeor is glad that everything works totally absolutely really fine with ghc 7.4.1!
05:47:20 <mekeor> fmap: oh cool
05:50:54 <chineseboy> ciao
05:50:56 <chineseboy> !lit
05:50:59 <chineseboy> !list
05:51:31 <mekeor> @list -- ?
05:51:31 <lambdabot> No module "-- ?" loaded
05:51:38 <mekeor> @list
05:51:38 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:52:08 <mekeor> how do i use default methods of a type-class?
05:52:19 <mekeor> while instanciating, i mean.
05:52:28 <chineseboy> ciao
05:52:31 <chineseboy> !list
05:54:09 <hpc> mekeor: by not using your own definition
05:54:51 <mekeor> ah ok.
05:55:20 <mekeor> it's weird that you only get a warning if you don't define a complete definition.
05:55:33 <mekeor> e.g. i just got "Warning: No explicit method nor default method for `signum'"…
05:56:09 <hpc> signum doesn't have a default definition
05:56:18 <hpc> "nor default method"
05:56:32 <hpc> try doing it for Eq
05:56:38 <hpc> defining (==) but not (/=)
05:56:41 <mekeor> yup
05:57:03 <hpc> oh i see what you mean
05:57:05 <mekeor> i thought i don't need signum for the minimal complete definition, you know…
06:08:41 <hpc> whoa
06:08:46 <hpc> today i discovered: ghc -M
06:08:55 * hackagebot lucienne 0.0.1 - Server side feed aggregator/reader  http://hackage.haskell.org/package/lucienne-0.0.1 (AlexanderBau)
06:10:54 <mekeor> coool
06:11:34 <mekeor> it generates a makefile
06:11:38 <mekeor> nice!
06:18:48 <t7> who needs a makefile?
06:18:55 <hpc> make does
06:19:10 <hpc> (almost typed "mauke")
06:19:23 <sipa> real programmers compile to binaries in their head
06:19:34 <sipa> http://xkcd.com/378/
06:19:35 <t7> oh boy here we go
06:20:21 <hpc> just prove that the program you want exists and move on :P
06:20:49 <basti_> hi all
06:20:57 <adnauseam> allo gents, a cs question about lambdas and type inference. when reading the type expression: int->int.* int
06:20:57 <boccato> hi
06:21:09 <basti_> can i use a "don't care" element in type specifications?
06:21:13 <adnauseam> how should i be reading .* int?
06:21:22 <basti_> eg: a :: m (*->*)
06:21:59 <sipa> * is the 'kind' (type of type) of types which have values
06:22:11 <adnauseam> mhmn, as far as i know, that means that the type still needs to conform to itself where m = m
06:22:22 <adnauseam> so it's not exactly a don't care
06:22:26 <basti_> hmm
06:22:27 <hpc> basti_: you can have unused type variables
06:22:31 <hpc> :t forever
06:22:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
06:22:34 <hpc> :t const
06:22:35 <lambdabot> forall a b. a -> b -> a
06:22:36 <sipa> so * contains Int, [String], IO Bool, [String] -> [IO [Int]]
06:22:41 <basti_> ahh
06:22:44 <basti_> okay.
06:22:45 <hpc> both the 'b's there are "don't care" type variables
06:22:54 <sipa> but * doesn't contain IO, [], Maybe, StateT Int, ...
06:23:13 <basti_> i see
06:23:19 <hpc> if you feel like being even more hardcore, you can use rank 2 types
06:23:21 <hpc> but don't
06:23:25 <basti_> *g*
06:23:32 <basti_> I'm currently trying to work with "ST Arrays"
06:23:39 <basti_> and they turn out to be a type nightmare
06:24:05 <hpc> basti_: it shouldn't be that bad
06:24:14 <hpc> are you trying to return an STArray from runST?
06:24:24 <basti_> yes
06:24:26 <basti_> is that wrong?
06:24:28 <hpc> very
06:24:31 <basti_> oh
06:24:35 <basti_> oh no wait
06:24:43 <basti_> I'm trying to USE an starray inside runST
06:24:50 <hpc> oh, that's totally fine
06:24:57 <hpc> uh
06:25:01 <basti_> http://pastebin.com/LzEnvaFC < have a look at that please
06:25:06 <mauke> The paste LzEnvaFC has been copied to http://hpaste.org/69737
06:25:26 <basti_> i can't even use thaw/freeze without getting type errors
06:25:54 <basti_> the compiler tells me it can't deduce the MArray type
06:25:56 <rwbarton> paste the error too
06:25:58 <rwbarton> ah
06:25:58 <basti_> ok
06:26:02 <rwbarton> yes, i imagined so
06:26:41 <basti_> i tried adding types eg. for arr_
06:26:47 <basti_> but i never seem to get it right
06:27:36 <basti_> i tried adding a constraint, but i can't seem to get that right either
06:27:45 <basti_> (eg. like suggested, MArray ...)
06:29:13 <rwbarton> it's tricky without ScopedTypeVariables
06:29:32 <basti_> i saw the scopedtypevariables error a few times
06:29:39 <rwbarton> ?
06:30:20 <hpc> im trying to fix it
06:30:25 <rwbarton> if you turn on ScopedTypeVariables you should be able to write st :: forall s a i e. (IArray a e,Ix i) => a i e -> i -> ST s (a i e) and then "thaw arr :: ST s (STArray s i e)"
06:30:28 <hpc> it's being quite bitchy
06:30:29 <basti_> oh no another warning "flexible contexts"
06:32:08 <basti_> thanks for your help everybody
06:32:14 <hpc> im getting monomorphism restriction stuff
06:32:38 <basti_> I seem to be talented in digging out hard cases :(
06:32:45 <hpc> really, unless you are going to change st in the future, it should be
06:32:58 <hpc> st arr i = return (readArray arr i)
06:33:33 <basti_> hpc: i was just trying to write as short as possible a piece of code demonstrating the problem
06:33:37 <hpc> ah
06:35:32 <basti_> actually there's some change supposed to be going on. I'm using "immutable arrays" to transfer data.
06:36:03 <rwbarton> here is another way to go about it, define thawU :: (Ix i, IArray a e) => a i e -> ST s (STArray s i e); thawU = thaw
06:36:10 <rwbarton> then use thawU in place of thaw
06:36:29 <basti_> okay.
06:36:35 <basti_> that sounds like a good suggestion.
06:36:42 <hpc> basti_: http://hpaste.org/69738
06:36:46 <hpc> that works if you comment out main
06:36:47 <illissius> is there any way to define cabal's --with-compiler using an environment variable?
06:37:06 <hpc> illissius: edit ~/.cabal/config, or something like that
06:37:19 <illissius> hpc: right, that's not an environment variable :)
06:38:04 <hpc> oh, it HAS to be an environment variable?
06:38:30 <illissius> (moment)
06:38:37 <hpc> basti_: what is happening in main is, it calls st, but doesn't say what specific array type to use
06:38:44 <hpc> and doesn't let the caller decide either
06:38:56 <hpc> or something like that
06:39:05 <hpc> basically, add type signatures inside main
06:39:11 <hpc> and your short example will compile
06:39:34 <basti_> hpc: okay
06:39:54 <basti_> hpc: thanks a lot
06:39:58 <hpc> you probably want thawU, like rwbarton said
06:40:11 <hpc> so you don't have to use scoped type variables
06:41:07 <illissius> hpc: So I have multiple installations of GHC but one cabal-install, and I can make wrapper scripts to put the appropriate GHC in the path, but then I still have to give cabal the appropriate --with-compiler manually. Though maybe I'm at this point workarounding a workaround and it'd be better to just remove with-compiler from the config file and then it'll automatically use the one in PATH?
06:41:09 * illissius tries
06:41:57 <basti_> hpc: that's true, thawU is far easier to read
06:43:04 <hpc> illissius: and when you need a different ghc, --with-ghc=ghc-6.12.1 or whatever
06:43:27 <hpc> i think
06:43:35 <ksf> @hoogle (a -> f b) -> (a -> f c) -> a -> (b -> c -> d) -> f d
06:43:35 <lambdabot> No results found
06:43:52 <hpc> @djinn Functor f => (a -> f b) -> (a -> f c) -> a -> (b -> c -> d) -> f d
06:43:52 <lambdabot> Error: Class not found: Functor
06:43:54 <ksf> @hoogle (a -> f b) -> (a -> f c) ->  (b -> c -> d) -> a -> f d
06:43:55 <lambdabot> No results found
06:44:12 * basti_ bows to hpc and rwbarton
06:44:28 <ksf> wait -> is just an applicative transformer.
06:44:46 <illissius> nope, it's not using the one from the path, it has the ghc it likes to use baked in somehow :(
06:45:05 <hpc> ksf: foo f g h x = h <$> f x <*> g x
06:45:34 <illissius> so I'm back to wanting an environment variable, but I guess because there isn't one I'll have to make separate wrapper scripts for cabal if I don't want to keep typing --with-compiler.
06:45:47 <hpc> @pl foo f g h x = h <$> f x <*> g x
06:45:47 <lambdabot> foo = (flip ((.) . (<$>)) .) . liftM2 (<*>)
06:45:48 <ksf> hpc, yes, but I happen to have foo, but not <$> and <*>
06:46:05 <hpc> ah
06:46:07 <hpc> freaky
06:49:56 <illissius> oh never mind me I'm an idiot. it *is* using the ghc from the path, I just managed to fail at the simple task of commenting out the right line in the config file. so yay.
06:50:20 <ahax> hello, anyone familiar with regex.pcre ?
06:50:33 <ahax> i cannot find out how to extract a match
06:50:58 <ahax> i can see how to match a string but not how to filter out what i want to extract
06:51:37 <ahax> e.g.
06:51:41 <ahax> "<!--- title: Learning Haskell -->" =~ "title:(.*) -->" :: String
06:52:04 <hpc> :t (=~)
06:52:05 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
06:52:10 <ahax> returns "title: Learning Haskell -->"
06:52:18 <fmap> > "<!--- title: Learning Haskell -->" =~ "title:(.*) -->" :: String
06:52:18 <mekeor> i wished that: length "Left" == length "Right"
06:52:19 <lambdabot>   "title: Learning Haskell -->"
06:52:24 <hpc> ahax: try [String]
06:52:34 <benmachine> ahax: as I recall it, what that function returns depends on what type you give the return value
06:52:37 <hpc> > "<!--- title: Learning Haskell -->" =~ "title:(.*) -->" :: [String]
06:52:38 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
06:52:38 <lambdabot>                    ...
06:52:43 <benmachine> ahax: imo it's a classic case of excessive polymorphism
06:52:44 <hpc> or something like that
06:52:48 <benmachine> kind of a ridiculous API
06:52:52 <hpc> > "<!--- title: Learning Haskell -->" =~ "title:(.*) -->" :: (String, [String])
06:52:53 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
06:52:53 <lambdabot>                    ...
06:53:02 <fmap> > "<!--- title: Learning Haskell -->" =~ "title:(.*) -->" :: (String, String, String)
06:53:03 <lambdabot>   ("<!--- ","title: Learning Haskell -->","")
06:53:17 <ski> mekeor ?
06:53:34 <ahax> thanks for the help
06:53:45 <mekeor> ski: for case-expressions… such that the arrows (->) are on the same level. looks nicer.
06:53:58 <mekeor> ski: for casing Either.
06:54:03 <ski> heh, i always indent them to align anyway :)
06:54:12 <ahax> i don't know why it kinda ignores the parens
06:55:11 <hpc> @let tryParser p str = case runParser p ()
06:55:11 <lambdabot>   Parse error: ;
06:55:45 <hpc> @let tryParser p str = case runParser p () "parser" str of Left{} -> Nothing; Right r -> Just r
06:55:46 <lambdabot>  <local>:11:23: Not in scope: `runParser'
06:55:54 <hpc> :(
06:55:57 <fmap> ahax: ah, you want \1 ?
06:56:17 <ahax> yes, "Learning Haskell"
06:56:51 <ahax> i can slice it, but i think there is a better way
06:56:56 <ahax> i hope actually
06:57:22 <fmap> > "<!--- title: Learning Haskell -->" =~ "title:(.*) -->" :: (String, String, String, [String])
06:57:23 <lambdabot>   ("<!--- ","title: Learning Haskell -->","",[" Learning Haskell"])
06:57:36 <hpc> aha!
06:57:40 <ahax> thanks fmap !
06:58:00 <hpc> they couldn't have it always return a quadruple?
06:58:44 <ahax> or just the captured string?
06:59:06 <hpc> you can have multiple captures
06:59:32 <fmap> > "<!--- title: Learning Haskell -->" =~ "title:(.*) -->" :: [[String]]
06:59:33 <lambdabot>   [["title: Learning Haskell -->"," Learning Haskell"]]
06:59:52 <benmachine> basically it's a damn silly API
07:00:11 <ahax> i shall look at pcre-light as well, may be simpler
07:00:16 <hpc> it's not
07:00:26 <hpc> they all use the same overly-generalized (=~)
07:00:37 <hpc> with different RegexMaker/RegexContext instances
07:01:27 <ahax> which is good in a sense, but not really practical to use
07:01:30 <ski> @quote jwz
07:01:30 <lambdabot> jwz says: Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.
07:01:36 <hpc> it's like the array type classes, except you would never have more than one backend in scope at a time
07:02:31 <ahax> btw, can i have the same result using parsec, or is it a regex only problem ?
07:02:59 <ahax> ski: :D but he doesn' t like perl anyway
07:03:31 <hpc> it's regex-only
07:03:42 <hpc> parsec and friends have types that don't break your brain
07:04:01 <hpc> except trifecta
07:04:06 <ahax> i was meaning extracting a match like that
07:04:06 <hpc> though that's probably just the lack of docs
07:04:25 <ski> @quote lifetime.of
07:04:25 <lambdabot> ddarius says: When a programmer has a problem and says "I'll use regular expressions," they have two problems.  When the programmer says "I'll use Haskell," they have a lifetime of problems.
07:04:33 <ahax> otherwise it's a nice occasion to learn parsec
07:04:36 <ski> @quote the.opposite
07:04:36 <lambdabot> Wadler says: "You know how they say that when you have a problem and you decide to use regular expressions to solve it, you now have two problems? Well, Haskell is the opposite in that regard. You
07:04:36 <lambdabot> start out with a problem, then you go through a lot of trouble to actually learn the language and then you no longer have the problem in the first place because you have lost interest in programming.
07:04:36 <lambdabot> " - by Ph
07:04:49 <fmap> parsec can do everything that regexes can
07:04:50 <fmap> and more
07:05:10 <mekeor> what is (<-) in do-blocks called? "bind", too, like (>>=)?
07:05:10 <n0den1te> ski: careful there. I'm going to run away from haskell!
07:05:12 <ahax> ok
07:05:34 <ski> n0den1te : hehe
07:05:53 <mekeor> … because it's actually the same …
07:06:01 <ahax> thanks, i'm going to look at the parsec version then
07:06:12 <ahax> and thanks also for the regex solution
07:06:19 <ski> mekeor : hm, not sure ..
07:07:11 <n0den1te> hm, speaking of parsec, is there any way I can run sample tests for hexDigit from ghci?
07:08:01 <n0den1te> it keeps complaining of being unable to find instances of Stream s m Char, when it should be Stream s m String. :/
07:08:30 <ski> mekeor : maybe i'd pronounce it as "from"
07:08:42 <mekeor> hm
07:10:03 <n0den1te> Basically, I can't find a way to use Stream instances in ghci (which is declared to be an instance of Monad, if I'm not too wrong)
07:10:14 <DMcGill> so I've just got a fresh installation of the Haskell platform and have network-2.3.0.13 in my extralibs directory but my ghc can't find it  (even though it can find other packages in the same directory). What do?
07:11:45 <ski> (`p <- e' in a list comprehension is known as a "generator", and we can pronounce it as "in" or "from" or "taken from"; i suppose in a `do'-expression it might perhaps be called a "binding" (though that risk conflation with `p = e' bindings in `let' and `where'), and pronounced as .. what ? "from" ? "yielded from" ? "gets" ?)
07:13:25 <fmap> n0den1te: can you paste these tests?
07:13:58 <n0den1te> fmap: http://therning.org/magnus/archives/289. This is what I'm trying to do. As soon as I get to hexDigit, ghci promptly complains.
07:14:15 <n0den1te> fmap: I'll paste those error messages in a bit.
07:15:40 <hpc> DMcGill: are you sure it's finding other things in that directory, and not from the platform?
07:16:00 <DMcGill> I've looked a bit more, and network is in my ghc-pkg list
07:16:08 <n0den1te> fmap: https://gist.github.com/2901112
07:16:23 <n0den1te> I'm using parsec-3.1.2
07:16:34 <DMcGill> and as per the website, doing "ghc-pkg field network exposed-modules" even gives back a list of the network modules
07:17:44 <hpc> n0den1te: what are you importing?
07:18:13 <n0den1te> hpc: Text.ParserCombinators.Parsec and Text.Parsec.Prim
07:18:28 <DMcGill> calling ":set -package network" in ghci gives this error: http://pastebin.com/9axHHsKb
07:18:30 <mauke> The paste 9axHHsKb has been copied to http://hpaste.org/69740
07:18:55 * mekeor is discovering Parsec and its beauty.
07:18:57 <hpc> remove both of those, and import Text.Parsec
07:19:45 <hpc> Text.ParserCombinators is a compatability thing
07:20:23 <n0den1te> hpc: I get the same error message doing that.
07:20:35 <n0den1te> hpc: want me to gist the .hs file too?
07:21:01 <hpc> i can copy from the blog
07:21:13 <n0den1te> ok
07:21:56 <Peaker> DMcGill, you must have reinstalled/unregistered a dependency of live packages. cabal-install used to do this on its own :(   You can probably "ghc-pkg check" and then "ghc-pkg unregister <packageName>" on all the broken packages
07:22:18 <hpc> okay, reproduced the error
07:22:45 * n0den1te expectantly waits for a solution to appear.... 
07:24:55 <hpc> aha!
07:24:57 <hpc> parseAddress :: Parsec String () Address
07:25:06 <fmap> i guess it's MR sruff
07:25:06 <hpc> er
07:25:08 <fmap> stuff*
07:25:14 <hpc> parseAddress :: Parsec String s Address
07:25:20 <hpc> no, it's type inference stuff
07:25:30 <hpc> http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Prim.html#t:Stream
07:25:39 <hpc> it couldn't infer if it should use ByteString or Text
07:25:49 <hpc> or String
07:26:11 <hpc> not from the function as written, at least
07:26:43 <hpc> it inferred an s0, m0 that were totally polymorphic
07:27:15 <fmap> well, that works with -XNoMR
07:27:27 <n0den1te> aha...! hpc, great!
07:27:27 <hpc> ah
07:27:36 <n0den1te> fmap: what's MR?
07:27:38 <hpc> oh right, i see
07:27:50 <fmap> monomorphism restriction
07:27:51 <hpc> n0den1te: monomorphism restriction
07:27:52 <n0den1te> Monomorphism Re?
07:27:58 <n0den1te> hpc: ah, yes..
07:28:04 <hpc> makes things that "look like values" have monomorphic types
07:28:07 <hpc> at the top level
07:28:13 <hpc> and other places too, maybe
07:28:23 <n0den1te> yes, been reading about it elsewhere.
07:28:42 <DMcGill> Peaker: when I do "ghc-pkg check" I get a whole lot of warnings about missing haddock files but no actual errors.
07:28:55 <n0den1te> ghc's type inferencer needs more information when it's unable to resolve the types and ties it to one, but fails.
07:29:30 <Peaker> DMcGill, can you paste "ghc-pkg list" output?
07:30:14 <fmap> i don't think i get how MR related here but that's the very first thing to try when getting weird errors in ghci
07:30:37 <hpaste_> DMcGill pasted “ghc-pkg list” at http://hpaste.org/69741
07:30:50 <n0den1te> fmap: is there any way I can tell what type ghc inferred when I get such errors?
07:30:59 <hpc> fmap: something made it drop the (Stream s m Char) context
07:31:01 <Peaker> DMcGill, it's not a good idea to "shadow" global packages with user packages
07:31:28 <Peaker> DMcGill, "ghc-pkg unregister parsec"
07:31:44 <n0den1te> fmap: I mean, for the particular function, parseAddress.
07:31:47 <hpc> like maybe it decided that since it saw a concrete type in the last position, that context could be dropped in the final "monomorphic" type
07:32:01 <hpc> then saw that s and m were universally quantified and bailed
07:32:02 <Peaker> DMcGill, does that work?
07:32:33 <n0den1te> hpc: heh, from what I read - that doesn't sound like MR kicked in here.
07:32:38 <hpc> er, "concrete type in the last position of the Stream context)
07:33:05 <DMcGill> Peaker: yes it does, thanks very much
07:33:19 <hpc> n0den1te: see what happens if you change it to parseAddress :: (Stream s m Char) => ParsecT String s m Char
07:33:21 <DMcGill> I don't know how that got there, I certainly haven't written a package called parsec
07:33:25 <hpc> er
07:33:40 <hpc> parseAddress :: (Stream s m Char) => ParsecT s u m Char
07:33:54 <Peaker> DMcGill, you cabal-install'd parsec or something that depends on it while requiring it to be linked with different versions than the one you have globally installed
07:34:15 <aristid> hpc: an address can be encoded in a single Char?
07:34:26 <hpc> er
07:34:33 <hpc> whatever it is
07:34:50 <hpc> it's too early in the morning here
07:34:58 <Peaker> DMcGill, every installed package is linked against specific versions of its dependencies. When something depends on a package and on a constrained-version of that package's dependency, it can force cabal to reinstall the package, causing shadowing and trouble
07:35:17 <Peaker> DMcGill, newer versions of cabal-install warn you about reinstalling packages
07:35:17 <basti_> i think i just wrote the most involved class constraint of my life
07:35:24 <DMcGill> ok, thanks!
07:35:32 <hpc> basti_: do share!
07:35:44 <n0den1te> hpc: the Char thing is what made me confused.
07:36:15 <hpc> n0den1te: i have a feeling you can manually write out the type in terms of Stream and ParsecT and have it magically work
07:36:23 <hpc> once the type is right
07:36:50 <n0den1te> hpc: "magically"? I hate that word, too overused in perl world. :)
07:36:50 <hpaste_> “Bastiaan Zapf” pasted “The most contrieved Type Contstraint i've written so far” at http://hpaste.org/69742
07:36:54 <basti_> :D
07:37:10 <basti_> and it works and it makes sense
07:38:23 <hpc> n0den1te: perl implements its own magic, with mirrors and fog machines
07:38:32 <hpc> haskell magic is imported directly from gypsies
07:38:45 <n0den1te> hpc: like Erik Meijer? :D
07:38:58 <hpc> exactly
07:39:08 <n0den1te> hpc: I saw him on C9 and the first thing that came to my mind was "What's that gypsy face doing here?"
07:39:11 <n0den1te> :D
07:40:12 <t7> my reddit name is gypsyface....
07:40:17 <hpc> he looks like my AI professor
07:40:27 <hpc> only significantly more dutch
07:45:44 <n0den1te> hpc: doppelganger kinda similarity?
07:45:56 <n0den1te> t7: you can have all the fun with Erik!
07:54:04 <ahax> i got the parsec version of my regex:
07:54:07 <ahax> entryTitle = do{ string "<!--- title: " ; manyTill anyChar (try (string " -->"))}
07:54:28 <ahax> almost directly from the parsec api doc
07:55:08 <ahax> i think now everything will be a good excuse to play around with parsec
07:55:21 <hpc> now for extra fun, write compile :: String -> Parsec whatever
07:55:37 <hpc> parse a regex and output a parser
07:56:33 <parcs`> parse a regex with parsec and output a parsec parser?
07:56:44 <hpc> yes
07:56:46 <hpc> :D
07:57:49 <ahax>  parse entryTitleParser "no title found" "<!--- title: Learning Haskell -->"
07:57:49 <ahax> Right "Learning Haskell"
07:58:00 <ahax> \o/
07:58:07 <byorgey> nice =)
07:58:08 <parcs`> It Works!
07:59:14 <ahax> actually it's just parsing a html comment
07:59:40 <ahax> but i find it way simpler (at least now) than using a regex
07:59:51 <fmap> so you were trying to parse html with regexes
08:00:00 <ksf> how did fudgets ever get away with intermingling semantics and layout?
08:00:24 <n0den1te> hpc: got it - parseAddress :: ParsecT String u Control.Monad.Identity.Identity Address
08:00:33 <parcs`> isn't an html comment <!-- --#>
08:00:35 <parcs`> -->*
08:00:50 <n0den1te> hpc: ParsecT is basically a newtype declaration, I simply looted that thing in here for our type signature.
08:01:10 <ksf> heck even *imperative* languages specify layout declaratively nowadays.
08:01:34 <ahax> no, just 3 comments
08:01:35 <hpc> ksf: not well, though ;)
08:01:44 <ksf> yep, wholly static.
08:01:45 <ahax> inside markdown actuallt
08:02:32 <ahax> i use comments inside markdown to hold metadata, like title, date, tags, etc
08:04:07 <luite> is it possible to make cabal-install use a different config file?
08:05:09 <hpc> luite: chroot? XD
08:05:12 <ksf> and I begin to feel the downsides of FRP libs that come with a construction monad.
08:06:33 <luite> hmm, perhaps the CABAL_CONFIG env var
08:07:18 <hpc> ksf: i still don't get FRP
08:08:02 <hpc> i can't find any articles in the middle ground between "FRP is like eating a banana at every point in space-time" and "here's our implementation of FRP with no examples"
08:08:57 <parcs`> frp is like, an idea, man
08:10:36 <ksf> what I find more annoying is "here is yet another frp library but I won't tell you whether it supports switch, proper sharing, or computes trivial networks before the heat death of the universe"
08:11:15 <Tomsik> Why don't they all work on just one FRP framework :(
08:11:34 <ksf> the design space is big
08:11:46 <Tomsik> Seriously, pipes/conduits/iteratees business at least talks to each other or something
08:11:47 <parcs`> why don't they all work on one incremental IO framework :(
08:11:52 <ksf> and it seems to be impossible to implement all the good things without language support.
08:12:24 <ksf> well, you can hook up the different frp frameworks via their IO interfaces.
08:12:30 <hpc> honestly, all i need is an example of someone writing notepad in FRP style
08:12:36 <Philippa> do we know what the relevant language support looks like?
08:12:42 <Philippa> notepad doesn't need FRP, it's event-only
08:12:53 <Philippa> someone should /really/ build a just-the-events-not-behaviours lib
08:12:59 <hpc> yes, that
08:13:10 <hpc> that would make non-trivial GTK work SOOOOOOO much nicer
08:13:32 <ksf> frp without behaviours has a hard time combining anything.
08:14:09 <ksf> you'll soon want to hook up an event to an accumulator to be able to bundle it with the value of another event.
08:14:17 <ksf> ...at which point you have invented behaviours.
08:14:32 <otters> @pl \(x,y) -> x ++ ": " ++ y
08:14:32 <lambdabot> uncurry ((. (": " ++)) . (++))
08:14:51 <Philippa> ksf: if it all behaves discretely, it's still a difference, I would've thought?
08:14:52 <ksf> behaviours, modulo conalisms, are just events that don't fire but keep their value inbetween firings.
08:15:06 <hpc> heh, "conalisms"
08:15:13 <ksf> non-discrete events are conalisms.
08:15:34 <hpc> ah
08:16:00 <ksf> and you can turn any behaviour into an event again with an edge function
08:16:02 <Philippa> see, we do need a clear dividing line around there, it's a major chunk of design space
08:16:17 <ksf> it's more an issue of how you use the buggers.
08:17:03 <hpc> im writing a turn-based game, and im stuck on how to avoid a huge increase in complexity once i start adding interaction
08:17:16 <Tomsik> > (\x y -> mconcat [x, ": ", y]) "a" "b"
08:17:17 <lambdabot>   "a: b"
08:17:18 <hpc> and i think FRP can help, but i have no idea how to use it
08:17:22 <Philippa> hpc: I was always planning on using a two-level 'sim' for that
08:17:30 <Tomsik> @pl \x y -> mconcat [x, ": ", y]
08:17:31 <lambdabot> (mconcat .) . (. ((": " :) . return)) . (:)
08:17:43 <Philippa> one for the game, one for the UI, as it were
08:18:09 <hpc> Philippa: yeah, i already have two data structures
08:18:09 <ksf> hpc, can you wrap your mind around https://github.com/the-real-blackh/sodium/blob/master/examples/poodle/poodle.hs  ?
08:18:19 <hpc> one for game state, another for "how the state will change"
08:18:27 <ksf> mostly "poodleGame"
08:18:28 <hpc> ksf: if that's what i think it is, not even remotely
08:18:55 <Philippa> hpc: huh, point if you've got undo. But what does stuff like the cursor and unit animations and so forth?
08:19:07 <ksf> it spawns random poodles that jump, and that die if you click on them.
08:19:15 <Tomsik> hpc: I think there was a post somewhere from a guy who wrote a "functional MMO" where he said he followed architecture of having game state and a "log"
08:19:48 <Tomsik> and then apply log to the state
08:19:55 <hpc> Philippa: dunno
08:20:19 <hpc> ksf: yeah, i only tenuously see what it's doing
08:20:41 <ksf> hpc, then you probably need more experience.
08:21:03 <hpc> it looks a lot like how in gtk, you create your UI and then add a crapton of event handler functions
08:21:15 <hpc> and then run it
08:21:50 <hpc> ksf: i see the progression of "make poodles, tell them what to do when these things happen"
08:21:59 <hpc> but everything indented further than that is just bamboozlement
08:22:16 <hpc> lots of case and eventE and (=<<) and let-in
08:22:58 <ksf> justE throws away Nothing-events and keeps the Just, for example.
08:23:02 <ksf> that's just vocabulary.
08:23:32 <Tomsik> I don't know what it looks like, but last time I've looked at an FRP example it tied the knots all over the place
08:23:52 <ksf> yep, most networks are loopy.
08:24:11 <ksf> even arcanoid is.
08:25:08 <Tomsik> I find this quite confusing. I feel that it's easier to tie a knot than read the resulting code.
08:27:13 <ksf> well. the current velocity of the ball depends upon the position of ball and paddle, the position of the ball depends on past velocity and past position.
08:27:18 <ksf> there's your loop.
08:27:51 <ksf> ...just that it's expressed via direct data dependencies, and not via recursion over state.
08:28:08 <ksf> in the end it's just a loop like any other.
08:28:55 <Tomsik> Heh. Perhaps it's a problem with me. The most RP I've done is using a spreadsheet.
08:29:10 * hackagebot lucienne 0.0.2 - Server side feed aggregator/reader  http://hackage.haskell.org/package/lucienne-0.0.2 (AlexanderBau)
08:30:01 <illissius> ksf: wait, the velocity of the ball depends on its position and the paddle's? what game is this?
08:31:18 <ksf> illissius, arcanoid.
08:31:23 <ksf> velocity as in direction.
08:31:50 <Peaker> There's the "peakachu" discrete-only FRP-like library, with a little demo game "defend" [the king]
08:33:08 <ksf> I don't see no switch in that API
08:35:24 <Peaker> ksf, What are the switch semantics?
08:36:38 <Peaker> peakachu has composable "backends" that perform the effects behind the scenes, and the frontend is your effect-free program.  A program is composeable vertically, horizontally, and chronologically
08:37:06 <ksf> switch :: Event (Event a) -> Event a
08:37:20 <ksf> join, practically.
08:37:34 <Peaker> Ah, Programs are applicatives and categories, not monads, iirc
08:37:36 * clixsense hi
08:38:39 <ksf> without switch, implementing something like a tabbed plane is awkward at best.
08:39:07 * clixsense join http://www.clixsense.com/?4005905 and click and task and win very much
08:39:15 <ksf> or a preview area. got to switch between image and text displays etc.
08:43:52 <ksf> netwire has one of those ugly stepper-function interfaces.
08:44:13 <ksf> got to call a function with all input to get at the output.
08:45:01 <ksf> sodium is at the other far end of that spectrum, but then constructing everything in a Monad becomes ugly, fast.
08:45:55 <ksf> feeding all input through one bottleneck also means that you have to update everything for every single event that occurs.
08:46:14 <ksf> (modulo dirty tricks that I bet aren't applied)
08:49:12 * hackagebot happstack-static-routing 0.3.1 - Support for static URL routing with overlap detection for Happstack.  http://hackage.haskell.org/package/happstack-static-routing-0.3.1 (MagnusCarlsson)
08:53:22 <otters> has anybody here used Network.TLS?
08:56:12 <tibbe> Is writing "data T e where; C :: Binary a => a -> T ByteString" in GADT syntax equivalent to writing "data T = forall a. Binary a => C a" in "normal" style? In other words, does GADTs add an implicit forall?
08:56:44 <ksf> tibbe, it has to be.
08:56:49 <benmachine> tibbe: GADTs can definitely make existential types for you
08:56:49 <tibbe> right
08:56:57 <tibbe> that was my guess
08:56:59 <ksf> ...as you can add D :: Ord a =>
08:57:05 <benmachine> those types are not quite equivalent, since T has different kinds in each
08:57:06 <tibbe> curious as to why you're less explicit about them there
08:57:18 <tibbe> benmachine: I screwed up my example :)
08:57:31 <tibbe> but you got the point so no matter
08:59:15 <benmachine> http://cs.stackexchange.com/q/2301/1808 if anyone has views on this I'd be grateful
09:00:11 <monochrom> I write "data T where C :: Ord a => a -> T", that is, without "forall a.", because I'm too lazy to turn on one more extension, that's all. :)
09:00:49 <hpc> benmachine: perhaps you can distinguish between strong and weak as
09:01:21 <hpc> "weak: sometimes you can put a value of one type in a position where that type would not normally be accepted"
09:01:26 <otters> @pl \x y z -> [x,y,z]
09:01:26 <lambdabot> (. ((. return) . (:))) . (.) . (:)
09:01:35 <monochrom> I sometimes classify type systems into "system F", "system F1", "system F2"...
09:01:52 <hpc> which covers C's int-as-char, and OO implicit conversions
09:01:54 <benmachine> hpc: perhaps I can! I think that's roughly the third definition
09:02:08 <benmachine> or maybe I misunderstand
09:02:18 <benmachine> I'm not sure what you mean by "normally"
09:02:19 <monochrom> some other times, I classify by "does it have subtyping", "does it have parameteric polymorphism", "does it have higher-order functions"
09:02:31 <heatsink> @seen ezyang
09:02:31 <lambdabot> Unknown command, try @list
09:02:36 <hpc> benmachine: it's the third definition, plus "the language might have a mechanism for converting on its own"
09:03:02 <hpc> so you can have weak languages that are still type-safe
09:03:09 <heatsink> @help seen
09:03:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:03:14 <benmachine> oh, well, that's not the third definition then :P
09:03:17 <hpc> (if there are any remains to be seen)
09:03:29 <illissius> tibbe: GADTs and normal ADT syntax with ExistentialQuantification and equality constraints are equally powerful. data T a where Foo :: Int -> T Int can be written data T a = (a ~ Int) => T Int. basically, anything you can write in one you can also write in the other.
09:03:54 <tibbe> illissius: ah, that's useful to know
09:04:13 <tibbe> illissius: I'm starting to find the GADT syntax nice for things involving exestentials
09:04:44 <hpc> benmachine: oh, a good example of a type-safe language would be "haskell, plus attempted implicit fromIntegral when typechecking would fail"
09:04:54 <hpc> *type-safe weak language
09:05:03 <benmachine> hpc: would you regard perl as weak type-safe then?
09:05:27 <hpc> no
09:05:29 <illissius> tibbe: yeah, I think I've always preferred them too
09:05:43 <hpc> you can build hashes with invalid keys by converting from an array with odd length
09:05:55 <tibbe> back to hacking :)
09:06:33 <monochrom> I regard perl typing and machine code typing to be of similar strength and similar safety
09:06:54 <hpc> heh
09:07:51 <ksf> actually... having only behaviours but no events makes a hell a lot of sense when writing things in FRP.
09:07:54 <monochrom> "the same perl variable @s is a list in one context, is a number in another context"  "the same machine register BX is a unicode code point in one context, is a pointer in another context"
09:08:08 <benmachine> hpc: oh, I didn't even know that was possible
09:08:21 <benmachine> hpc: hmm. how about PHP, then?
09:08:25 <ksf> the implementation not knowing of behaviours, but only push-events makes most sense in my case, though.
09:08:33 <monochrom> did you know: in python, max(None, 5) = 5, min(None, 5) = None
09:08:50 <benmachine> hpc: also, what do you mean by "invalid keys"
09:08:59 <benmachine> monochrom: I did not know that!
09:09:02 <ksf> with the notion that a behaviour can't update inbetween outside events.
09:09:50 <benmachine> monochrom: that is consistent in a sense though
09:10:23 <monochrom> a few days ago I just met a student who wrote python code to find both maximum and minimum over a collection (numbers stored in a tree actually), well the collection may be empty so the initial max and the initial min are both None, he designed. well it completely flopped.
09:10:49 <monochrom> oh sure, if you read "None" as our ⊥
09:10:59 <illissius> I think it might be worth distinguishing different kinds of ways-you-can-use-types-that-don't-exactly-match. There's polymorphism, there's subtyping, there's implicit/explicit conversion based on meaning (like Perl), and implicit/explicit conversion based on representation (like C).
09:11:13 <monochrom> but it's just as reasonable to read "None" as our Nothing, "5" as our "Just 5"
09:12:51 <hpc> monochrom: was it a sorted tree?
09:13:15 <monochrom> no. just typical recursive search over the whole tree
09:13:19 <hpc> ah
09:13:31 <monochrom> and it doesn't matter when the tree is empty
09:14:54 <illissius> benmachine: wrt to the static vs dynamic thing
09:15:58 <benmachine> illissius: well, and there's another option, namely "vomit everywhere" :)
09:16:10 <benmachine> (as in some invalid C conversions)
09:16:35 <benmachine> monochrom: hmm, I'm not sure I buy your outrage
09:16:40 <benmachine> > min Nothing (Just 5)
09:16:41 <lambdabot>   Nothing
09:16:51 <benmachine> > max Nothing (Just 5)
09:16:52 <lambdabot>   Just 5
09:16:53 <illissius> bah, accidentally pressed return. so. benmachine: wrt to the static vs dynamic thing, I think the distinction is "the types are checked comprehensively before it's run" vs. "the types are checked as-needed while it's running". which is independent of implementation, because in the latter case (while you can obviously make optimizations when things are known) the semantics demand it.
09:18:05 <benmachine> illissius: yes, that sounds approximately equivalent to what I thought, thanks. any chance you know an authority I can cite?
09:18:49 <heatsink> Maybe one of papers about gradual typing or related stuff
09:19:05 <illissius> benmachine: I'm not sure, but I think SPJ's recent paper on deferred type errors might be relevant. Are you familiar with that?
09:19:58 <benmachine> illissius: I've not read it, but I've heard of it and could probably find it
09:22:47 <illissius> benmachine: right, the point is whether I can talk about it without having to explain the context :). in the paper there's an interesting part where they mention that even if type errors are deferred to runtime, which expressions are ill-typed is still determined at compile time, so even if you happen to pass in types at runtime which would be legal it will still abort. unlike dynamic languages, where this is checked dynamically.
09:23:37 <benmachine> illissius: ah, hmm
09:23:40 <nand`> So exactly what type system does Haskell use? Hindley-Milner? What about with the various GHC extensions such as RankNTypes, GADTs, etc.?
09:23:49 <heatsink> Generally, dynamic types are described in terms of static types as the type (?x. x) with explicit run-time type casts
09:23:50 <geekosaur> System Fc
09:23:54 <benmachine> nand`: it's way more advanced than HM at this stage :P
09:24:24 <heatsink> If you can find a paper that says that, will that meet your needs?
09:24:26 <benmachine> heatsink: er, is the symbol before that x meant to be a question mark
09:24:34 <heatsink> It's "exists"
09:24:38 <benmachine> ah
09:26:02 <geekosaur> heatsink, I think it got mangled, as it displayed as a question mark here too and my utf8 setup is correct (and a missing character displays differently so it's not a hole in the font)
09:26:08 <ksf> \o/
09:26:16 <ksf> nl:dk 0:1
09:27:12 <benmachine> heatsink: that would certainly go some way towards meeting my needs
09:27:33 <illissius> nand`: iirc H98/H2010 uses System F, GHC with TypeFamilies GADTs etc. uses System Fc which adds type functions and equality constraints, GHC with PolyKinds uses Fc^ (there's a c in the bottom index and an upwards arrow in the top index) which adds kind polymorphism
09:27:58 <illissius> I'm not sure what things like RankNTypes and ConstraintKind correspond to
09:28:01 * heatsink can't find a way to change the encoding used by its IRC client
09:28:35 <illissius> (of course GHC always uses the same typechecker, it just disables certain source constructs when extensions aren't enabled)
09:29:00 <boccato> Anyone doing the 99 haskell problems? I just created a repo to put hunit tests for them (https://github.com/boccato/99_haskell_problems).
09:29:58 <benmachine> boccato: why HUnit, ooi? it seems like QC could get better coverage
09:30:14 <Guest80845> I am reading 'Learn you a Haskell', and am loving it so far. Which book would ya'll recommend reading next?
09:30:30 <nand`> illissius: thanks for the informative answer
09:30:51 <nand`> The ‘c’ is subscript in ‘Fc’ too?
09:31:00 <illissius> nand`: right
09:31:40 <boccato> benmachine: Because I am most used to the xunit style and am still learning. One of the ideas is to add QuickTest to it too. But translating the examples from the problems to HUnit seemed very straight forward.
09:32:19 <boccato> Guest80845: Real World Haskell is good, with some outdated material.
09:32:41 <boccato> Guest80845: If you like videos: http://channel9.msdn.com/Shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1
09:32:56 <heatsink> Chapter 18 in Robert Harper's book is about dynamic typing http://www.cs.cmu.edu/~rwh/plbook/book.pdf
09:33:17 <Phlogistique> Guest80845: after LYAH, you are able to write Haskell code already, so maybe give you some time to get your hands dirtier before looking for more doc
09:33:23 <basti_> [x] st monad stuff is lightning fast compared to "pure"
09:33:38 <heatsink> There's a sequent calculus exercise on ezyang's tutorial that I think is unprovable: |- exists x. P(x) -> (forall y. P(y))
09:33:40 <nand`> odd, unicode doesn't seem to have a subscript c, though it has subscript a,e,h,i,k,l,m,n,o,p,r,s,t,u,v,x + some symbols
09:33:55 <heatsink> Assuming P(x), you can't prove forall y. P(y), right?
09:34:07 <Phlogistique> Guest80845: other than that, the too-rarely-recommanded "Write a Scheme in 48 hours" is a very good hands-on book
09:34:14 <heatsink> Assuming P(x) and exists x. P(x) -> (forall y. P(y)), I mean
09:34:34 <rwbarton> heatsink: it's definitely true classically
09:34:54 <mauke> ᶠc
09:34:57 <Guest80845> thanks boccato and Phlogistique, those are great tips
09:35:16 <morel> is there a (nice) way to make (Either Integer Double) an instance of Num? or is there even a package/library/module doing so?
09:35:43 <c_wraith> morel: not really.  how would you add a Left 1 and a Right 3.5 ?
09:35:59 <morel> @type fromIntegral
09:36:00 <rwbarton> here is an informal language proof, either P(z) is true for all z, in which case we can pick any x, or P(z) is false for some z, in which case we can pick that z as x
09:36:00 <lambdabot> forall a b. (Integral a, Num b) => a -> b
09:36:11 <morel> c_wraith: with this?
09:36:43 <morel> (Left l) + (Right b) = Right (fromIntegral l + b) -- or so?
09:36:46 <morel> c_wraith: ?
09:36:55 <mauke> is Either Integer an instance of Applicative?
09:37:26 <c_wraith> That's really not a good idea.  So many ways for it to blow up in your face.
09:37:43 <nand`> mauke: it should be
09:37:53 <morel> c_wraith: but it should work, shouldn't it?
09:38:06 <mauke> > Left 42 <*> Right 3.5
09:38:07 <lambdabot>   Left 42
09:38:11 <mauke> excellent
09:38:17 <mauke> then there's an obvious instance for Num
09:38:23 <morel> namely?
09:38:24 <c_wraith> "work".  Until you get overflows, underflows, etc, etc
09:38:38 <nand`> instance Num a => Num (Either e a) -- ?
09:38:44 <mauke> morel: http://mauke.hopto.org/stuff/haskell/fun.hs
09:38:47 <mauke> this one
09:38:59 <mauke> just replace 'f' by 'Either e'
09:39:05 <c_wraith> Well, if you ignore the e type, then you're fine.
09:39:12 <rwbarton> classic example of a question underdetermined by only asking about type signatures
09:39:31 <nand`> Either MathError a -- might be more interesting
09:39:37 <nand`> defining MathError as DivisionByZero, etc.
09:39:49 <morel> mauke: thanks, dude! i'll try…
09:40:06 <c_wraith> morel: it won't do what you want. it'll do something sane, instead
09:40:24 <rwbarton> and we wait to see how long before the asker realizes the answer was not what was wanted at all
09:40:46 <morel> c_wraith: rly? why?
09:41:44 <rwbarton> morel: didn't you already answer your own question?
09:41:50 <rwbarton> 16:36 < morel> (Left l) + (Right b) = Right (fromIntegral l + b) -- or so?
09:42:13 * nand` doesn't understand how the (+) morel defined is supposed to work; what is the purpose of “Left”?
09:42:35 <nand`> seems like you're defining an instance for Num a => Either a a -- where all ‘Left’s are treated as ‘Right’s instead
09:42:53 <mauke> communism!
09:42:55 <rwbarton> I guess so you can still represent Integers outside the range of Double, though it does seem a bit silly
09:43:13 <c_wraith> Integers outside the range *and* precision of Doubles
09:43:16 <c_wraith> it's a really bad idea
09:43:23 <c_wraith> because it will fail in mysterious ways
09:43:25 <c_wraith> all the time
09:43:26 <nand`> oh, /me missed that fromIntegral
09:43:34 <morel> i'd like to use "naturalOrFloat :: ParsecT s u m (Either Integer Double)" from http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Token.html but i need a Num instance for (Either Integer Double) to be able to use it in my code.
09:43:40 <nand`> so it's instance (Integral a, Num b) => Either a b
09:43:51 <nand`> Num (Either a b)*
09:43:58 <mauke> morel: no, you need to convert it to a sane number type
09:44:09 <morel> ah!
09:44:11 <rwbarton> how about Rational
09:44:18 <morel> that's another option… true.
09:44:28 <heatsink> rwbarton: So... introduce x, assume P(x), invoke the law of the excluded middle on (Ay. P(y)), if (Ay. P(y)) then it's proven, otherwise Ey. not P(y) and you have a contradiction
09:44:32 <morel> i need a function :: Either Integer Double -> Double!
09:44:52 <c_wraith> :t either fromIntegral id
09:44:53 <lambdabot> forall a b. (Integral a, Num b) => Either a b -> b
09:44:53 <nand`> either (fromIntegral) id
09:45:04 <morel> thanks =) you're great
09:45:51 <rwbarton> i wonder why that Parsec module doesn't simply return Rational. after all isn't that how "floating-point" literals are defined in Haskell
09:46:01 <rwbarton> 0.5 = fromRational (5 % 10)
09:46:10 <morel> @pl \x y -> f x + f y
09:46:11 <lambdabot> (. f) . (+) . f
09:46:33 <mauke> @pl \f x y -> f x + f y
09:46:33 <lambdabot> flip =<< (((.) . (+)) .)
09:46:40 <Tomsik> :t join (+)
09:46:41 <lambdabot> forall a. (Num a) => a -> a
09:46:47 <mauke> @pl \(+) f x y -> f x + f y
09:46:47 <lambdabot> (line 1, column 3):
09:46:47 <lambdabot> unexpected "+"
09:46:48 <lambdabot> expecting pattern
09:46:56 <mauke> @pl \c f x y -> f x `c` f y
09:46:56 <lambdabot> join . ((flip . ((.) .)) .) . (.)
09:46:57 <Tomsik> :t join (&&&)
09:46:58 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
09:47:07 <nand`> (+) `on` f
09:47:14 <Tomsik> :t join (***)
09:47:15 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
09:47:32 <Tomsik> :t join (***) . uncurry (+)
09:47:33 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a, Num (a b c)) => (a b c, a b c) -> a (b, b) (c, c)
09:47:40 <nand`> :t \f -> (+) `on` f
09:47:41 <lambdabot> forall b a. (Num b) => (a -> b) -> a -> a -> b
09:47:41 <Tomsik> oops
09:47:46 <otters> > (join (&&&) succ) 1
09:47:47 <lambdabot>   (2,2)
09:47:58 <otters> > join (,) $ succ 1
09:47:59 <nand`> note that f is now monomorphic
09:47:59 <lambdabot>   (2,2)
09:48:02 <nand`> but otherwise the same thing
09:48:18 <Tomsik> nand`, that's too easy :P
09:48:20 <otters> @src (->) (>>=)
09:48:20 <lambdabot> f >>= k = \ r -> k (f r) r
09:48:39 <otters> f >>= id = \r -> id (f r r)
09:48:41 <otters> okay
09:48:46 <morel> btw, Data.Function.on is cool.
09:48:52 <sipa> :t on
09:48:53 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:49:12 <morel> > (*) `on` (^2) 3 5
09:49:13 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> b)
09:49:13 <lambdabot>    arising from a use...
09:49:17 <morel> > (*) `on` (^2) $ 3 5
09:49:18 <lambdabot>   Precedence parsing error
09:49:18 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
09:49:24 <sipa> @djinn  (b -> b -> c) -> (a -> b) -> a -> a -> c
09:49:24 <lambdabot> f a b c _ = a (b c) (b c)
09:49:28 <morel> > ((*) `on` (^2)) 3 5
09:49:28 <lambdabot>   225
09:49:50 <byorgey> oh, I'm surprised djinn doesn't use the last argument
09:49:58 <byorgey> it's usually good about that kind of thing
09:50:18 <sipa> i suppose it reuses c because that already has the right type
09:50:41 <byorgey> sipa: yes, but it seems like it usually tries to use all the arguments
09:50:59 <opqdonut> @djinn a -> a -> (a -> a -> b) -> b
09:50:59 <lambdabot> f a b c = c b a
09:51:02 <opqdonut> like so
09:51:23 <byorgey> @djinn a -> a -> (a -> b) -> (b,b)
09:51:23 <lambdabot> f _ a b = (b a, b a)
09:51:45 <otters> @djinn (a,a) -> (a -> b) -> (b,b)
09:51:45 <lambdabot> f (_, a) b = (b a, b a)
09:51:49 <opqdonut> I guess it doesn't work for complex expressions
09:51:52 <otters> bull crap
09:52:36 <hpaste_> fragamus pasted “can this be altered to use modify?” at http://hpaste.org/69751
09:54:10 <fragamus> hi I'm trying to figure something out    I pasted it above
09:55:12 * morel solved his issue with "fmap (either fromIntegral id)" =)
09:55:27 <temoto> Please djinn [a,b,c] -> [(i,a), (i+1,b), (i+2,c)]
09:55:53 <heatsink> fragamus, only pure computations can be used with 'modify'
09:55:58 <int-e> fragamus: no, modify really needs a function mapping states to states rather than a monadic action.
09:56:00 <morel> fragamus: what do you want to do? what does not work? what's the error?
09:56:17 <fragamus> there is no error
09:56:32 <heatsink> It doesn't make sense to use the state while it's changing, so modify is pure
09:56:33 <fragamus> I just wanted it to be tighter
09:57:14 <fragamus> i wanted to make some code that would look like a real haskell programmer had written it
09:58:25 <int-e> fragamus: You can write it all on a single line using bind (>>=) directly...  get >>= \(l, c, r) -> asdf l c >>= \(riffed, lb, cb) -> put (lb, riffed ++ cb, r)  ... but I would prefer the 3 line version because it seems more readable to me.
09:59:16 * hackagebot pipes-extra 0.2.0 - Various basic utilities for Pipes.  http://hackage.haskell.org/package/pipes-extra-0.2.0 (PaoloCapriotti)
10:01:51 <temoto> Okay i figured it's   zip [1..] xs
10:07:08 <heatsink> Yay, I finished the proof
10:07:12 <heatsink> Now I have to figure out what I did
10:09:17 * hackagebot pipes-zlib 0.1.0 - Pipes to deal with zipped data.  http://hackage.haskell.org/package/pipes-zlib-0.1.0 (PaoloCapriotti)
10:10:55 * ski wonders what heatsink proved
10:11:16 <heatsink> A sequent calculus exercise on ezyang's website
10:11:30 <heatsink> Ex. P(x) -> Ay. P(y)
10:12:00 <ski> oh, that one
10:12:19 <ski> we talked about it in ##logic, the other week
10:13:03 <ski> you used (right-)contraction, right ?
10:13:07 <heatsink> ##logic doesn't seem to have a chatlog
10:13:09 <heatsink> Yeah
10:13:14 <heatsink> right-contraction is not intuitive to me
10:14:11 <illissius> that seemed impossible to me because I read it as (exists x. P(x)) -> (forall y. P(y)), but based on rwbarton's explanation it's actually exists x. (P(x) -> (forall y. (P(y)) which is a bit weird but not impossible-seeming
10:14:35 <illissius> missed a ).
10:14:36 <ski> heatsink : if you'd like, i could paste the relevant parts of the log somewhere
10:15:46 <morel> where can i find that exercise? (link, pls.)
10:15:46 <heatsink> ski, please
10:15:52 <heatsink> http://logitext.ezyang.scripts.mit.edu/logitext.fcgi/tutorial
10:15:58 <morel> thanks
10:17:18 <heatsink> One of the disjuncts introduces a premise that then is used to prove the other disjunct
10:17:34 * heatsink squints at it
10:18:19 <unlink> Is there a better way to do this? foldM (\x y -> if x then return x else y) FalsefoldM
10:18:32 <unlink> s/FalsefoldM/False
10:19:56 <roconnor> is <> mappend yet?
10:20:07 <hpc> can some people help me test this GHC bash completion generator?
10:20:08 <hpc> https://github.com/headprogrammingczar/ghc-man-completion
10:20:24 <hpc> run ghc-man-completion -f completion.sh && . completion.sh
10:20:31 <hpc> then try ghc -X<tab><tab>
10:20:58 <heatsink> You should be able to write it as a foldr
10:21:47 <nand`> roconnor: I thought (<>) was Data.Semigroup.Semigroup's associative operation
10:22:18 <morel> hpc: are there any installation-instructions?
10:22:20 <parcs`> roconnor: yeah since ghc 7.4
10:22:28 <heatsink> foldr (\m k -> m >>= \x -> if x then return True else k) (return False)
10:22:34 <hpc> morel: the usual cabal stuff
10:22:41 <hpc> morel: you can also runghc MainParse.hs
10:22:44 <morel> heatsink: … or is it just cabal install ghc-man-completition ?
10:22:53 <morel> i meant hpc.
10:23:07 <parcs`> @hoogle foldM
10:23:08 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
10:23:08 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
10:23:08 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:24:28 <nand`> hpc: http://paste.lugons.org/show/2052/
10:24:35 <nand`> when running ghc-man-completion -f completion.sh
10:25:26 <hpc> hmm
10:26:06 <hpc> what version of ghc?
10:26:12 <hpc> your man is longer than mine
10:26:13 <nand`> 7.4.1
10:26:32 <hpc> strange
10:26:49 <nand`> It has 2099 lines
10:27:10 <hpc> can you paste your man?
10:27:14 <hpc> "man ghc > man-ghc"
10:27:26 <markamber> I have been reading through learn you a haskell and I am kind of stuck at this functors and applicative functors part, I really want to understand what is going on here. any other recources you could point me to or just a brief explaination of what it is?
10:28:08 <nand`> hpc: http://paste.lugons.org/show/2053/
10:28:08 <hpc> actually, scratch that
10:28:13 <hpc> oh, yay
10:28:15 <nand`> man ghc 2>&1 | wgetpaste -- output
10:29:02 <hpc> hmm
10:29:12 <hpc> yours has colors or something
10:29:18 <markamber> And on another note does someone here have a simpleish haskell application that does something useful with enough complexity and good coding style that I could read through it and understand it
10:29:27 <hpc> and so it's seeing OPTIONS[something]\n
10:29:30 <hpc> instead of OPTIONS\n
10:29:30 <nand`> hpc: bold marks
10:29:33 <hpc> yeah
10:29:43 <hpc> that's extremely helpful
10:30:31 <nand`> there must be some option to man that will omit the formatting
10:30:35 <nand`> I can't seem to find it
10:30:54 <unlink> parcs`: ideally I would use `or` or (||).
10:31:33 <parcs`> :t fmap . (||)
10:31:34 <lambdabot> forall (f :: * -> *). (Functor f) => Bool -> f Bool -> f Bool
10:31:36 <heatsink> markamber, http://www.nobugs.org/developer/htrace/htrace.hs
10:32:00 <parcs`> :t (fmap . (||)) True (undefined :: Maybe Bool)
10:32:01 <lambdabot> Maybe Bool
10:32:04 <parcs`> > (fmap . (||)) True (undefined :: Maybe Bool)
10:32:06 <lambdabot>   *Exception: Prelude.undefined
10:32:29 <hpc> nand`: pipe "man ghc" through "col -b", and see if it still works after recompiling
10:32:43 <hpc> er wait, don't
10:32:47 <hpc> i didn't make that easy to do
10:32:52 <hpc> uh
10:33:02 <nand`> hpc: output of man ghc | col -b still has “1mFILES0m” and so on
10:33:35 <hpc> -t cat, perhaps?
10:33:53 <hpc> er
10:34:25 <hpc> hmm
10:34:33 <hpc> trying to find a man option that kills the formatting
10:34:39 <hpc> so i don't have to watch for it
10:37:12 <hpc> nand`: are you using bash?
10:37:17 <nand`> hpc: yes
10:37:19 <hpc> damn
10:38:44 <kkyqqp> I have a very large, sorted by the first element, list of 4-tuples, and I want to group together the terms that have the same first element of the tuple. is there any especially fast way of doing this?
10:40:11 <hpc> nand`: can you pull and retry?
10:40:45 <nand`> hpc: same error
10:40:59 <Veinor> kkyqqp: groupBy i think will run in O(n)
10:41:17 <Veinor> @type (==) `on` \(a, b, c, d) -> a
10:41:18 <lambdabot> forall b t t1 t2. (Eq b) => (b, t, t1, t2) -> (b, t, t1, t2) -> Bool
10:41:35 <hpc> er, forgot to put it in both places...
10:41:39 <hpc> again?
10:41:40 <Veinor> so grouped = groupBy ((==) `on` \(a, _, _, _) -> a) myList
10:41:54 <nand`> hpc: same
10:41:56 <Veinor> where on is in Data.Function and groupBy is in Data.List
10:42:07 <kkyqqp> I'll try that, thanks veinor!
10:42:38 <nand`> http://unix.stackexchange.com/questions/4527/program-that-passes-stdin-to-stdout-with-color-codes-stripped
10:42:39 <Veinor> out of curiosity, why are you passing around 4-tuples
10:42:40 <nand`> hpc ^
10:42:42 <Veinor> ?
10:43:29 <hpc> nand`: oh yay
10:44:20 <hpc> will try
10:44:41 <ski> heatsink,morel : see <http://pastebin.ca/2159839>
10:44:44 <kkyqqp> veinor: I'm using it as a simple data structure for a combinatorics problem in four variables
10:44:54 <Veinor> ah ok
10:44:56 <nand`> hpc: the perl oneliner?
10:45:26 <nand`> hpc: oh, there's a sed answer below
10:45:35 <Veinor> o/` hey i just met you / and this is crazy / but don't use null values / haskell has Maybe o/`
10:48:15 <hpc> nand`: again; i went with the perl -pe fix
10:49:03 <nand`> I'd think ‘sed’ is more portable than ’perl’
10:49:12 <nand`> and saves you the perl dependency
10:49:36 <hpc> i think ghc still depends on perl?
10:49:47 <nand`> oh
10:49:50 <nand`> hpc: works now
10:49:53 <nand`> completions and all
10:49:57 <nand`> do you complete anything other than -X ?
10:50:08 <nand`> oh, nice
10:50:16 <nand`> it completes -W* and -f* and I'm guessing all other options
10:50:38 <hpc> everything except stuff like -idir1:dir2
10:50:45 <roconnor> is there some (MonadPlus m) => [a] -> m a?
10:50:51 <hpc> actually, that might be the only one it doesn't
10:51:16 <hpc> nand`: that was a huge help
10:51:46 <nand`> hpc: glad it help, sounds like an excellent thing to have. I'll see if I can't get it merged to my distro's GHC package some time
10:52:13 <hpc> :D :D :D
10:52:53 <Veinor> roconnor: mconcat
10:53:22 <Veinor> oh wait that's monoid
10:53:31 <Veinor> foldm mplus mzero
10:53:52 <roconnor> :/
10:54:00 <benmachine> msum = foldr mplus mzero
10:54:00 <Veinor> why is MonadPlus a thing, anyway?
10:54:05 <benmachine> but I don't think that's what roconnor wants
10:54:09 <hpc> omg this is the best
10:54:11 <roconnor> @type msum
10:54:12 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
10:54:17 <hpc> i am running this program on every new machine i have
10:54:17 <benmachine> or
10:54:21 <benmachine> I suppose msum . map return
10:54:25 <roconnor> ya
10:54:26 <benmachine> would be roughly the thing?
10:54:34 <benmachine> :t foldr (mplus . return) mzero
10:54:35 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
10:54:42 <Veinor> oh that works too
10:54:48 <Veinor> map return is clearer though IMO
10:55:05 <roconnor> @type traverse
10:55:05 <lambdabot> Not in scope: `traverse'
10:55:10 <Veinor> and the list will probably get fused with sufficient -O
10:55:11 <roconnor> @hoogle traverse
10:55:11 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:55:11 <morel> hpc: i cabal-installed it. what can i do now?
10:55:11 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
10:55:11 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
10:55:22 <benmachine> Veinor: yeah, probably, but I have it hard-wired into me that foldr g and map f can fuse into foldr (g . f)
10:55:22 <roconnor> @type sequence
10:55:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:55:33 <roconnor> hmm
10:56:00 <morel> hpc: i cloned the repo, and successfully typed "cabal install". how can i use those completions now?
10:56:52 <hpc> morel: ./dist/build/ghc-man-completion/ghc-man-completion -f completions.sh
10:57:15 <hpc> and then move that shell script and add ". completions.sh" to your .bashrc
10:57:57 <morel> ah
10:58:29 <ski> morel : did you catch the link ?
10:58:52 <hpc> i want to get more sophisticated with this eventually, and have it also parse the docs for each flag
10:58:56 <morel> ski: yes i have.
10:59:12 <hpc> so when there isn't an overwhelming number of completions, it shows them in one column with those docs to the right
10:59:45 <morel> hpc: nice. does work now.
11:09:21 * hackagebot ghc-man-completion 0.0.0.1 - Generate a bash completion from the GHC manpage  http://hackage.haskell.org/package/ghc-man-completion-0.0.0.1 (JoeQuinn)
11:10:14 <nand`> hpc: does any other completion system work like that? (inlining descriptions) I've never seen it
11:10:42 <ski> @djinn (forall a. (a -> b) -> (a -> c)) -> (forall a. a -> (b -> c))
11:10:43 <lambdabot> -- f cannot be realized.
11:11:22 <ski> can this be proved in some way, using parametricity ?
11:13:01 <ski> well, i suppose i mean proved in a way such that the composition with the obvious other direction is identity
11:19:18 <hpc> nand`: fish does
11:19:19 <hpc> http://ridiculousfish.com/shell/beta.html
11:19:24 <hpc> it's where i got the idea
11:19:28 <nand`> hpc: I see
11:19:37 <hpc> incidentally, fish can't parse the ghc manpage
11:19:58 <hpc> my guess is it does the same thing i did, but look for DESCRIPTION instead of OPTIONS
11:20:04 <nand`> personally I'd like to see consistency, when using the bash shell, so if you could make that feature optional it'd be great
11:20:21 <hpc> nand`: yeah, i already planned for that
11:20:31 <ski> (.. not to be confused with `F[i]-shell' at <http://fishell.sf.net>)
11:25:55 <parcs`> zsh does to
11:28:31 <Martty_> > 10^10^5
11:28:32 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
11:28:39 <Martty_> can i benchmark that
11:34:29 <RebelBunny> what are some good forums for functional programming?
11:34:57 <hpc> you can always idle here :P
11:38:20 <parcs`> i don't know of any FP forums
11:41:06 <ski> RebelBunny : Lambda the Ultimate isn't exactly an FP forum, but you might like it (nor not) nonetheless. then there's comp.lang.functional
11:41:17 <ski> (s/nor/or/)
11:48:24 <thinker341> Hi all, can you please help me understand why this pie of code giving me an exception : hpaste.org/69755
11:48:45 <mauke> that code can't give you an exception
11:48:48 <mauke> it's a syntax error
11:49:02 <Martty_> hmm pie of code
11:49:16 <parcs`> thinker341: did you read the exception
11:49:50 <thinker341> parcs' : 2:7: Parse error in pattern:putStrLn
11:50:40 <mauke> o_O
11:53:25 <thinker341> mauke : where is the syntax error:)
11:53:40 <ski> thinker341 : i don't see how that snippet you pasted could give that error
11:54:01 <ski> however, the last command in a `do'-expression can't be of form `<pat> <- <expr>'
11:54:02 <geekosaur> thinker341, you can't end a do expression with a binding
11:54:03 <rwbarton> possibly if line 3 is indented more than line 2
11:54:13 <geekosaur> tabs vs. spaces?
11:54:17 <ski> yes, but it isn't, in the paste
11:54:20 <applicative> it should be that the do block doesn't end in an  expression
11:54:22 <mauke> rwbarton: ooh
11:54:24 * hackagebot optparse-applicative 0.0.1 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.0.1 (PaoloCapriotti)
11:54:28 <ski> (/me already checked for tabs in the paste, none present)
11:54:45 <rwbarton> me too but ....
11:54:59 <rwbarton> @type do { f a b <- return () }
11:55:00 <lambdabot> Parse error in pattern
11:55:08 <ski> we can only wait for thinker341 to clarify ..
11:55:15 <applicative> thinker341: you dont use the iName variable, which is a bit like writing getLine >>= \iName ->
11:55:15 <geekosaur> I don't trust that, too many placres that could "correct" it
11:55:30 <applicative> so the sentence just ends with -> , thinker341
11:55:37 <ski> (trust what ?)
11:55:53 <rwbarton> the implication "no tabs in hpaste => no tabs in file"
11:56:11 <ski> hm, i suppose
11:56:11 <geekosaur> indentation having passed through cut and paste, a browser, a pastebin, and possibly another browser
11:56:19 <thinker341> Hi all, i think it's problem with tabs, let me type the whole thing in a new file
11:56:39 <thinker341> i am using notepad++
11:56:48 * ski pastes by typing into his editor, so didn't think of that
11:58:06 <applicative> certainly a lot of stuff I remove from hpaste with cut and paste appears in my editor with tabs, but not this
11:59:04 <ski> (i know that i can paste form feeds on hpaste as well, without them disappearing ..)
12:02:12 <hpaste_> fragamus pasted “can you make this into a one liner using semicolons?” at http://hpaste.org/69756
12:02:38 <fragamus> I'm having trouble converting my function into a one liner
12:03:14 <mauke> fragamus: put { } around the let binding
12:03:18 <ski> use `let {...}; ...'
12:06:03 <fragamus> thanks that worked
12:07:24 <osa1> is there a way to push last read char to buffer again in alex, so that alexMonadScan reads it again? I'm trying to tokenize an indentation based grammar and I need to emit dedent token multiple times based on last indentation
12:26:29 <`rand`> Does anyone have ghc-pkg working on SUSE 12.1? Every time I run it (e.g., list,  check), it says Aborted.
12:27:17 <parcs`> why does hSeek take as input an integer and not an int64
12:28:09 <hpc> so you can seek on streams
12:28:23 <t7> ready for windows 128
12:49:28 * hackagebot ixset 1.0.4 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-1.0.4 (JeremyShaw)
12:53:55 <balor> Given type X, if I "instance Foo X where ..." and then wish to "instance Bar X where ..." can I use the "toFoo" function (of typeclass Foo) in the functions used to implement "toBar"?
12:54:41 <Saizan> balor: sure
12:54:50 <balor> Saizan, thanks
12:54:56 <hpc> you can even mutually recurse
12:55:03 <everythingWorks> What sounds funnier: "kladus" or "spobat"? :D
12:55:34 <illissius> spobat
13:09:59 <mippie_moe> Anyone in here have experience using the Snap framework?
13:10:23 <ozataman> mippie_moe: yes - you should come over to #snapframework
13:18:11 <mandyed> hello everyone
13:41:23 <teneen> What are the characteristics of monadic parsers? Are they LL(k), LR(k),  SLR, top-down, bottom-up?
13:43:22 <Ralith> I think that depends on how you write the parser.
13:43:22 <mauke> usually recursive descent
13:44:54 <c_wraith> uu-parsinglib and polyparse both have multiple strategies that they run in parallel
13:45:27 <mippie_moe> does anyone here use Haskell at their job?
13:45:44 <strager> I do, mippie_moe
13:47:25 <mippie_moe> strager, That's awesome. I have some experience with Haskell and would like to get a lot more. The only problem is that there aren't a lot of companies that use Haskell
13:47:59 <mroman> Job? :D
13:48:05 <strager> I introduced Haskell to my company.  ;P
13:48:21 <mippie_moe> strager, a lot of banks, and companies where program correctness is mission-critical. But I feel like I don't have the experience to get a job like that, I'm fresh out of college haha
13:48:22 <strager> If you're competent and have understanding management, you can do that too.
13:48:42 <mippie_moe> That's really cool
13:49:12 <mippie_moe> Do you think the reason a lot of companies don't use haskell is because it's hard to find a good haskell programmer?
13:49:43 <strager> That's definitely a problem, yes.
13:49:55 <mippie_moe> Or do you think it has more to do with whether Haskell is a good fit for the problem they're trying to solve?
13:50:04 <teneen> c_wraith: can you name some of these strategies?
13:50:06 <strager> If you get stuck and you have no one to help you move along, it's frustrating and demotivating.
13:50:21 <strager> And if you don't have redundancy, if you're out sick or on vacation or get hit by a bus, the company has a problem.
13:50:29 <mippie_moe> strager, yep
13:50:47 <teneen> mauke: may I ask how did you know that they use recursive descent?
13:51:30 <mauke> it's what you get with the "obvious" implementation
13:51:34 <mippie_moe> I really torn between spending spending time learning haskell or sticking with python. I still only have about 8 months of experience with python
13:52:03 <mippie_moe> I enjoy programming in haskell a lot more than in python, but in all practicality, I need a job
13:52:16 <mroman> Why do people always measure experience in months?
13:52:37 <strager> mroman: Because it's an easily-measurable number.
13:52:47 <strager> It's quantitative, which is easier to explain than qualitative.
13:52:49 <mippie_moe> haha well i spend 12+ hours a day, 6 pr 7 days a week
13:52:54 <Yarou> seconds is better
13:52:55 <mroman> It has nothing to do with quality.
13:53:06 <mippie_moe> I just wanted to let it be known that I'm not fully immersed in python
13:53:12 <tgeeky> strager: easier to measure for whom? I can't measure months without assistance from devices.
13:53:27 <Cale> I wonder how many months of Haskell experience I have... 130 or something?
13:53:34 <geekosaur> of course, it ignores the whole "X years experience" vs. "1 year of experience, X times over" thing
13:53:50 <strager> tgeeky: Easier to measure than, say, amount of bugs avoided.  =]
13:53:52 <mroman> I can easily say "I have used C# for two years now"
13:53:54 <tgeeky> I have a friend who likes to measure things in: "the duration of 9,192,631,770 periods of the radiation corresponding to the transition between the two hyperfine levels of the ground state of the caesium 133 atom"
13:54:08 <mroman> But that doesn't say much more than that ;)
13:54:10 <mippie_moe> haha
13:54:29 <strager> I probably should have said "simply measurable".  =]
13:54:33 <mroman> I started learning haskell >1 year ago. So I have 1 year of haskell experience.
13:54:35 <mippie_moe> mroman, of course not, you're right.
13:54:37 <strager> And oyu're right geekosaur
13:54:49 <mroman> But I haven't done anything big with it.
13:55:25 <mroman> I know various haskell golf tricks :D. But that's probably it.
13:55:53 <tgeeky> mippie_moe: Here's an expected difference. I'll bet, after three years of use, the toolset python will not be teaching you anything. The toolset haskell/ghc will.
13:56:50 <mippie_moe> tgeeky, that's a great point. When I'm programming in Haskell, I always feel like I'm learning so much
13:57:28 <mippie_moe> tgeeky, that's one of the reasons I'm motivated to try to get a job programming in Haskell once I feel comfortable with the language, because I feel like you get so much out of programming with it
13:57:54 <mippie_moe> tgeeky, but to be honest, I'm still getting a lot out of python
13:58:18 <strager> Hell, I started working on a project at work in Haskell without telling anyone.  (Worked on my normal stuff, of course.)  Then I asked for forgiveness and go to work on it anyway.  ;D
13:59:11 <scooty-puff> the major difference i see between GADTs and data families is that data families are open - however, if higher kinds are used, is there a substantial difference between them?
13:59:35 <scooty-puff> strager: for a tool, or something integrated in a major product?
13:59:40 <scooty-puff> (if you don't mind my asking)
13:59:53 <strager> I built two things in Haskell at my job.
14:00:01 <strager> Rather, I partially built.
14:00:04 <mroman> also... knowing haskell as an it supporter is pretty much useless
14:00:17 <mippie_moe> do you guys now fully use haskell? or do you use other languages too?
14:00:20 <strager> The first thing was a decompiler.  The second thing was a compiler.
14:00:35 <scooty-puff> that sounds like a very good fit for both
14:00:41 <strager> The decompiler was a good idea, but it was too large of a project for me alone.
14:01:09 <strager> The compiler was also a good idea, and replaced a compiler I had written in JavaScript.  (As you can imagine, JS isn't very good for compilers!)
14:01:21 <strager> I'm currently only working on the compiler.
14:01:45 <strager> mippie_moe: I program in a lot of other languages.  Mostly Bash and JavaScript at work, though, and some C++.
14:01:59 <strager> mippie_moe: Though actually this morning I planned to write a new piece of software in Python.
14:02:13 <scooty-puff> are there any parser generators in javascript
14:02:16 <scooty-puff> ?
14:02:17 <strager> (It's scripty, like Bash, but the project is too large for Bash.)
14:02:26 <mippie_moe> strager, gotcha, thanks a lot for answering all my questions. I'm really interested in learning Haskell and you've been a big help
14:02:42 <scooty-puff> i would imagine if you adhered strictly to a visitor pattern to replay pattern matching on the syntax, wouldn't be horrible, though definitely not great
14:02:45 <strager> scooty-puff: I don't know, but there are many parsers written in JS.  I had experience with one of those parsers, which is why I started the compiler project using that parser.
14:02:48 <scooty-puff> (for javascript)
14:02:49 <strager> (The JS version)
14:03:02 <strager> Yes, it was visitor-based.
14:03:06 <scooty-puff> *replay -> replace
14:03:26 <strager> One main problem was that I couldn't match on multiple nested constructors.
14:03:52 <strager> So I built some tooling around that, but pattern matching really didn't fit with JavaScript.
14:04:06 <strager> (Tooling as in a bunch of fancy higher-order functions.)
14:04:11 <strager> (DSL of sorts.)
14:04:19 <scooty-puff> yeah, just would be difficult
14:04:24 <b_jonas> hello channel. nooodl asked about this programming question http://www.reddit.com/r/dailyprogrammer/comments/uh03h/622012_challenge_59_intermediate/
14:04:30 <scooty-puff> and wouldn't get good data structure coverage analysis
14:04:36 <strager> Yes.
14:04:43 <b_jonas> so I showed this apl-like function to get the length of runs of ones in a zero-one list
14:04:49 <strager> Not having a compiler to verify everything I did really hurt productivity and hid a LOT of bugs.
14:05:10 <strager> I love that Haskell can tell me I missed some pattern matching cases at compile time.
14:05:12 <b_jonas> @let r = [1,1,1,1,1,0,0,0,0,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,1,1,0,1,1,0,1]
14:05:13 <lambdabot>  Defined.
14:05:25 <b_jonas> > filter (0<) (map (-1-) ((liftM2 (zipWith (-)) init tail) (elemIndices 0 (0:r++[0]))))
14:05:26 <lambdabot>   Ambiguous occurrence `r'
14:05:26 <lambdabot>  It could refer to either `L.r', defined at <local...
14:05:30 <b_jonas> :(
14:05:39 <c_wraith> > L.r
14:05:41 <lambdabot>   [1,1,1,1,1,0,0,0,0,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,1,0,1,1,1,0,...
14:05:46 <c_wraith> there you go
14:05:58 <b_jonas> > filter (0<) (map (-1-) ((liftM2 (zipWith (-)) init tail) (elemIndices 0 (0:L.r++[0]))))
14:06:00 <lambdabot>   [5,3,1,3,1,6,1,3,1,3,2,1]
14:06:05 <b_jonas> thanks
14:06:08 <c_wraith> > maximum . map length . group $ r
14:06:09 <lambdabot>   Ambiguous occurrence `r'
14:06:09 <lambdabot>  It could refer to either `L.r', defined at <local...
14:06:13 <c_wraith> > maximum . map length . group $ L.r
14:06:15 <lambdabot>   6
14:06:18 <c_wraith> oh, right
14:06:39 <c_wraith> > maximum . map length . filter ((==1) . head) . group $ L.r
14:06:41 <lambdabot>   6
14:06:48 <nooodl> yeah i figured in haskell it's easy when you have group
14:06:54 <c_wraith> > map length . filter ((==1) . head) . group $ L.r
14:06:55 <b_jonas> @let rx = L.r
14:06:55 <nooodl> > map length . filter ((==1) . head) . group $ L.r
14:06:56 <lambdabot>  Defined.
14:06:57 <lambdabot>   [5,3,1,3,1,6,1,3,1,3,2,1]
14:06:57 <lambdabot>   [5,3,1,3,1,6,1,3,1,3,2,1]
14:07:01 <nooodl> that
14:07:17 <b_jonas> lol
14:08:12 <mauke> @undefine
14:09:10 <aristid> :t r
14:09:11 <lambdabot> Expr
14:09:17 <aristid> lol
14:11:14 <otters> has anybody here used Network.TLS?
14:11:37 <mroman> "transposing" that thing although is probably a little bit uglier.
14:12:55 <fmap> > takeWhile (/= 0) . map (length . takeWhile (==1)) . iterate (dropWhile (== 0) . snd . break (== 0)) $ [1,1,1,1,1,0,0,0,0,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,1,1,0,1,1,0,1]
14:12:57 <lambdabot>   [5,3,1,3,1,6,1,3,1,3,2,1]
14:17:20 <Peaker> strager, I moved from Python to Haskell even for my system scripts...
14:19:21 <strager> Peaker: I think Python will be easier for other developers to manage.
14:19:46 <Peaker> very possible.. Python's main feature over Haskell is that it is easier to learn by trial and error
14:19:57 <strager> Who knows, though; I may change my mind and do Haskell or Bash.
14:20:01 <Peaker> and there's less to learn to get things done
14:20:13 <strager> It's a small project which will just evolve as things are needed by developers.
14:20:18 <b_jonas> fmap: ah, that's a quite different approach
14:20:34 <b_jonas> breaking down one chunk of ones at a time, and repeating
14:20:43 <strager> (I want the tool to be a way for developers to run cross-project tests on their local machine, among other things.)
14:21:59 <mroman> Someone should write a JSP Parser in Haskell.
14:22:35 <mroman> Somebody should write ja JSP Parser suffices already :)
14:23:30 <Peaker> oh man, I had a guard:    | n < 0x100 = ...       where (n :: Word8)  -- and no warning from GHC :(
14:23:43 <Peaker> (0x100 *literal* silently truncated to 0, at compile-time)
14:23:54 <Peaker> or rather, could be at compile-time, with specializations
14:24:00 <zhulikas> filter (...) $ filter (...) [...]
14:24:03 <zhulikas> how can I write that prettier?
14:24:12 <zhulikas> to get rid of multiple filters
14:24:18 <dschoepe> zhulikas: filter (... . ...) :)
14:24:19 <mroman> combinging (...) and (...) into one predicate?
14:24:23 <zhulikas> heh
14:24:23 <Peaker> zhulikas, filter (liftA2 (&&) (...) (...)) ...
14:24:23 <mroman> *combining
14:24:30 <dschoepe> err, that should be a lifted &&
14:24:49 <zhulikas> yea
14:24:52 <zhulikas> lifted && looks good
14:24:53 <zhulikas> thanks
14:25:23 <dschoepe> (not literally `lifted (&&)', but what mroman wrote)
14:25:29 <zhulikas> yea
14:25:30 <zhulikas> I got that.
14:25:50 <mroman> liftA2?
14:25:52 <mroman> :t liftA2
14:25:53 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
14:26:38 <Peaker> tracePutStrLn s = trace s $ return ()           <--- so convenient for debugging
14:26:41 <fmap> > filter (\x -> getAll $ All (x < 10) `mappend` All (x > 5)) [1..20]
14:26:42 <lambdabot>   [6,7,8,9]
14:27:20 <mroman> Isn't there a library that provides operators for this?
14:27:22 <Peaker> liftA2 (&&) :: Applicative f => f Bool -> f Bool -> f Bool        for:  f = (r->)      you get:   liftA2 (&&) :: (r -> Bool) -> (r -> Bool) -> r -> Bool
14:27:22 <zhulikas> how can I figure out if my program is looping or calculating?
14:27:23 <dschoepe> > foldr filter [1..10] [odd, (>5)] -- also a possibility
14:27:24 <lambdabot>   [7,9]
14:27:39 <Peaker> zhulikas, the profiler?
14:27:44 <Peaker> zhulikas, are you using -O2 ?
14:27:55 <zhulikas> I am running from Leksah
14:28:00 <roconnor> zhulikas: if it isn't calculating ghc will throw a loop exception :)
14:28:06 <zhulikas> and have no knowledge of compiling/running it with ghc directly
14:28:19 <nooodl> dschoepe: that looks cool
14:28:20 <b_jonas> > filter (0<) ((ap (zipWith (\x y -> (1 - x) * y)) (scanl (\x y -> y * succ x) 0)) rx) -- another approach I tried
14:28:22 <lambdabot>   [5,3,1,3,1,6,1,3,1,3,2]
14:28:24 <Peaker> Leksah must be progressing pretty well if that's the case :)
14:28:42 <dschoepe> zhulikas: If by calculating you mean "will terminate" then that's tricky... :D
14:28:48 <Peaker> @pl \x y -> y * succ x
14:28:48 <lambdabot> (*) . succ
14:29:14 <b_jonas> right
14:29:23 <zhulikas> I am solving project euler and cant determine if my algorithm sucks or I left a bug and it loops infinitely :)
14:29:32 <b_jonas> it could be made a scanr I think, because you can do the (*) lazily
14:30:09 <mroman> ghci would provide an excellent tool for inspecting that.
14:31:25 <zhulikas> ok, I will try to print every value and see if it stops printing
14:31:29 <zhulikas> lame, but will work
14:31:35 <hpc> @quote oasis
14:31:35 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
14:32:05 * zhulikas googling
14:32:36 <b_jonas> lol
14:32:43 <fmap> zhulikas: is "my algorithm sucks or i left a bug and it loops" a decidable problem in general?
14:32:45 <Peaker> I'm in the process of tracing the hell out of my code..
14:32:54 <b_jonas> that's a nice quote
14:33:32 <zhulikas> well it is :D
14:33:33 <Peaker> I don't understand how people use "trace" alone. It's so bare.  traceId, tracePutStrLn, traceIdVia, traceAround are so useful
14:33:39 <zhulikas> by 'sucks' I meant slow
14:34:35 * hackagebot liblastfm 0.0.3.1 - Wrapper to Lastfm API  http://hackage.haskell.org/package/liblastfm-0.0.3.1 (MatveyAksenov)
14:34:38 <zhulikas> what
14:34:45 <zhulikas> trace is printing? how the hell it isnt in IO monad??
14:34:53 <geekosaur> deep evil
14:34:55 <lakatosi> Good day
14:35:05 <lakatosi> I am getting an Ambiguous occurrence error
14:35:11 <geekosaur> (it is a quasisafe use of unsafePerformIO)
14:35:16 <zhulikas> :D
14:35:23 <Peaker> zhulikas, Haskell is explicit about effects -- but when debugging you really don't care
14:35:23 <zhulikas> and it's a debug function after all
14:35:26 <zhulikas> I guess its fine...
14:35:27 <dschoepe> zhulikas: Note that your question can be rephrased as "will my algorithm hold for a given input" :)
14:35:28 <Peaker> zhulikas, this is not for production use
14:35:31 <zhulikas> yeah, debugging it is
14:35:46 <lakatosi> I have defined a datatype TranslationDirection, with Up, Down, Left, Right constructors
14:35:55 <dschoepe> s/hold/terminate/
14:36:00 <lakatosi> How can I shadow the Right from Prelude?
14:36:08 <lakatosi> (and Left)
14:36:28 <JEntrep> Anyoen ever heard of this guy: http://www.andres-loeh.de/
14:37:06 <roconnor> yes
14:37:13 <geekosaur> yes
14:37:46 <JEntrep> Really? Whats he known for?
14:38:32 <JEntrep> I'm new to Haskell so...
14:38:45 <ion> A friend’s cat had created a directory named (and i quote) “löööööööööööööh” on the desktop.
14:39:07 <JEntrep> :p
14:39:27 <geekosaur> http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fpackage&as_q=L%F6h :)
14:40:14 <geekosaur> (with a definite bias toward generic programming, which is unsurprising)
14:40:24 <ion> lhs2TeX is great.
14:40:47 <ion> I wish there was a Haskell code editor that looked like lhs2TeX output.
14:41:53 <Peaker> ion, we're working on a structural editor.. the gui is free to display code like that
14:42:02 <ion> (lhs2TeX was made by him, too, AFAIU.)
14:42:02 <Peaker> (though it's not the focus .. yet)
14:42:05 <ion> peaker: Cool
14:45:13 <davean> Peaker: Who is "we"?
14:46:16 <Peaker> davean, me and yairchu
14:46:28 <Peaker> (another Haskeller)
14:51:41 <ion> Yet Another IRC and Haskell User?
14:53:04 <Peaker> he's not on irc much
15:02:39 <mroman> Is wrapping Parsec in StateT a good thing?
15:03:18 <mroman> Or in other terms: Is checking semantics while parsing a good thing :D
15:03:25 <Peaker> mroman, it has its own state
15:09:47 <prescheme> so I've been having trouble installing gd on windows for ages now, but finally there's just a single thing stopping it from working now it seems
15:10:08 <prescheme> when installing gd through cabal, I get some warnings "resolving [...] by linking to [...]"
15:10:25 <nexx> I guess it depends on the complexity of your language/semantic analyses. But you already combine lexical analyses and parsing via parsec
15:10:31 <prescheme> e.g. "resolving _gdImagePtrDestroyIfNotNull by linking to _gdImagePtrDestroyIfNotNull@4"
15:11:09 <prescheme> then when compiling a Haskell program I get the error "undefined reference to gdImagePtrDestroyIfNotNull"
15:11:29 <prescheme> I have no idea how to fix this, anyone have any advice? it seems like the last hurdle I have to jump before getting it working...
15:12:59 <hpaste_> ill_logic pasted “Template Haskell scope issue.” at http://hpaste.org/69757
15:13:12 <ill_logic> Hi all. Last time I was here I pasted this scope issue.
15:13:30 <ill_logic> I had to leave in a hurry, but somebody mentioned that there was a Template Haskell module restriction.
15:13:51 <ill_logic> I looked it up, and it seems like you can't use things defined by TH in the same module as it's defined. Fair enough.
15:14:21 <ill_logic> But in my example here, b is not affected by Template Haskell, right?
15:18:59 <fmap> with TH order of declarations matters
15:19:47 <ill_logic> So what exactly is the rule I should know about to avoid the issue I'm seeing?
15:20:43 <ill_logic> ilove, ponies, and q are not used anywhere else, so I don't see any reason there should be an issue.
15:20:55 <ill_logic> oh wait maybe I see what you're saying
15:21:22 <ill_logic> you're saying that, if TH exists in a Haskell source file, then even the normal Haskell can't reference things before it?
15:21:46 <ill_logic> no, putting b = 5 above the quaziquote fixes the problem of not knowing what b is
15:21:55 <ill_logic> it's definitely something to do with the quaziquote.
15:27:19 <alanz> peaker: is there a writeup somewhere of what you are doing with bottle?
15:27:31 <geekosaur> ill_logic: TH runs at the point it is spotted in the source, and only those names which have been seen/defined before it can be referenced by it
15:28:41 <ill_logic> geekosaur: Ok, I can accept that. But in my example, the TH doesn't refer to b, nor a
15:28:53 <Peaker> alanz not yet
15:29:08 <alanz> ok. Looks interesting.
15:29:25 <alanz> Is the language it represents pure haskell, or something else?
15:29:39 <hpc> it's not haskell
15:29:53 <hpc> it's a totally different language with some similarities
15:29:57 <hpc> and it outputs haskell
15:30:17 <hpc> (iirc, it can also run haskell)
15:30:19 <geekosaur> hrm.  I have no idea.
15:30:30 <alanz> looks very interesting
15:31:18 <alanz> what do you mean 'run haskell', can it load haskell files?
15:31:30 <edwardk> @hpaste
15:31:30 <lambdabot> Haskell pastebin: http://hpaste.org/
15:31:46 <hpaste_> edwardk pasted “Contravariant J” at http://hpaste.org/69758
15:31:49 <Peaker> hpc, doesn't output anything or run anything yet :)
15:32:14 <edwardk> kicking around adding something like the top half of that module to contravariant
15:32:21 <Peaker> alanz, not yet... very preliminary. Has its own nice GUI toolkit, code stored in db, some type inference
15:32:35 <hpc> Peaker: oh, thought we were talking about TH
15:32:37 <edwardk> and maybe the rest to 'contravariant-extras'
15:32:49 <alanz> ok, but I like the concept in the editor
15:32:55 <edwardk> or contravariant-search
15:33:02 <Peaker> alanz, cool! try it out :) http://github.com/Peaker/bottle
15:33:16 <alanz> I am, hence my questions
15:34:34 <Peaker> alanz, oh, did it run yet?
15:34:57 <Peaker> I just pushed an overhaul of type inference btw... infinite types currently kill the editor :)
15:34:59 <edwardk> have to admit i'm somewhat sad that it seems to be slower than the polymorphic search code i blogged about though
15:35:04 <alanz> yes, the master branch, using ghc 7.4.1 and the new haskell platform
15:35:27 <alanz> I see you are working on another branch though
15:35:35 <Peaker> alanz, just killed that other branch
15:35:49 <Peaker> the type inference with union-find works well enough now
15:36:51 <prescheme> any advice with my previous question? getting "undefined reference" errors while linking despite the c compiler saying it is resolving those previously
15:40:58 <drrckln> i am curious. how did you guys learn haskell?
15:41:18 <Cale> prescheme: I've never seen anything like that, sorry, though I also don't use Windows.
15:41:23 <niteria> this might not be the best place to ask, but, what's the classic book on smalltalk?
15:42:38 <Cale> drrckln: I learned it about 11 years ago, so most of the tutorials I learned from have been supplanted by better ones. But basically, by reading tutorials online and writing small programs to compute combinatorial things and do random system tasks, and then asking and answering questions here.
15:43:26 * geekosaur notes leading underscore, also notes calling conventions may play into it, but is not particularly knowledeable about Windows compilation/linking
15:43:30 <Cale> drrckln: I eventually got hired to help work on (the lower-level bits of) a compiler for a special purpose language for signal processing applications in Haskell.
15:43:44 <drrckln> Cale: ah thanks. I am about halfway through LYAH and am wondering how I am gonna ever get used to higher order functions and such
15:44:42 <ski> drrckln : with practice
15:45:11 <Cale> Basically, whenever you see code which is similar except for a piece which changes, you define a function in order to not have to write the same code over and over, right?
15:45:28 <drrckln> yes, sure
15:45:29 <Cale> The same is true even when the bit of code which changes is itself a function.
15:46:07 <Cale> You just make that function a parameter, just like any other case where you'd do it :)
15:46:14 <niteria> My opinion is, read SICP first, then learn Haskell
15:46:18 <Cale> For example, consider the following programs:
15:46:26 <hpc> SICP isn't a particularly great book
15:46:32 <Cale> sum [] = 0
15:46:35 <hpc> most of it is LISP 101
15:46:38 <Cale> sum (x:xs) = x + sum xs
15:46:43 <Cale> product [] = 1
15:46:50 <Cale> product (x:xs) = x * product xs
15:46:54 <byorgey> my opinion is, read whatever looks interesting to you.
15:46:55 <Cale> concat [] = []
15:47:04 <Cale> concat (x:xs) = x ++ concat xs
15:47:09 <ski> hpc : ooi, do you prefer HTDP ? CTM ?
15:47:15 <Cale> these are all very similar programs
15:47:26 <hpc> er, that was unfair
15:47:36 <Cale> Except that the bits which were 0 and (+) in the case of sum are being replaced by other values
15:47:38 <hpc> isn't a particularly good book for learning FP from scratch
15:47:48 <Cale> drrckln: yeah?
15:48:04 <drrckln> Cale: yeah..hmm
15:48:31 <drrckln> partial functions are cool
15:49:04 <drrckln> niteria: i'm actually reading SICP, but haskell's a lot of fun so far also
15:49:39 <ski> hpc : i know some people think SICP isn't didactically good for most people
15:49:59 <niteria> I don't see how SICP might be bad
15:50:08 <drrckln> Cale: i guess I see that, and I'd guess you can rewrite it with fold, but it's still a pretty big jump
15:50:09 <ski> (ask eli in #scheme to hear all about it)
15:50:16 <Cale> drrckln: So, what we do in Haskell is just to abstract the bits which are changing out
15:50:44 <Cale> So we define foldr f z to be the function where f takes the place of (+) and z takes the place of 0 in sum:
15:50:49 <Cale> foldr f z [] = z
15:50:57 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
15:51:10 <hpc> intermediate step there:
15:51:12 <Cale> and then we can rewrite the three programs as:
15:51:15 <hpc> sum (+) zero [] = zero
15:51:21 <Cale> sum = foldr (+) 0
15:51:25 <Cale> product = foldr (*) 1
15:51:27 <hpc> sum (+) zero (x:xs) = x + (sum (+) zero xs)
15:51:30 <Cale> concat = foldr (++) []
15:51:55 * ski is tempted to interleave even more defining equations ..
15:52:05 <hpc> hah
15:52:53 <drrckln> the product of an empty list is 1?
15:52:57 <Cale> yes
15:53:01 <otters> now I understand what forall is for
15:53:07 <Cale> because 1 is the identity for multiplication
15:53:18 <Cale> 1 * x = x * 1 = x
15:53:21 <drrckln> oh, the identity element
15:53:27 <drrckln> err..
15:53:48 <drrckln> i forgot the term
15:53:55 <Cale> we want it to be true that  product (xs ++ ys) = product xs * product ys
15:54:29 <ski> drrckln : see monochrom's <http://www.vex.net/~trebla/homework/empty.html> for an explanation of empty sum,product,conjunction,disjunction
15:54:37 <drrckln> Cale: you mean s/*/+, right?
15:54:46 <Cale> no
15:54:54 <Cale> ++ is list concatenation though
15:54:58 <hpc> > product [2,5]
15:54:59 <Cale> in case that's not clear
15:54:59 <lambdabot>   10
15:55:02 <drrckln> oh right
15:55:04 <hpc> > product [2] + product [5]
15:55:05 <lambdabot>   7
15:55:34 <Cale> and if that's true, then  since [] ++ ys = ys, we'll have   product ys = product ([] ++ ys) = product [] * product ys
15:55:47 <Cale> and so product [] had better be 1
15:55:49 <drrckln> wait, isn't 2 ++ 5 .. 25?
15:55:49 <niteria> there's a slightly more interesting book (than SICP), "Concepts, Techniques and Models of Computer Programming"
15:55:57 <Cale> 2 ++ 5 is a type error
15:56:01 <Cale> ++ applies to lists
15:56:04 <Cale> > [1,2,3] ++ [4,5]
15:56:06 <lambdabot>   [1,2,3,4,5]
15:56:37 <drrckln> oh, i see..
15:56:47 <drrckln> and * is still just multiplication here
15:57:07 <ski> niteria : yeah, CTM :)
15:57:10 <Cale> yep
15:57:30 <Cale> (that product [] = 1 is more a math thing than it is a Haskell thing)
15:57:58 <drrckln> right, 1 is the identity element for multiplication?
15:58:01 <Cale> right
15:58:31 <ski> `product' is an `n'-ary multiplication, where `n' is the length of the given list
15:58:55 <ski> (and it makes sense to define this because multiplication is associative and has an identity element)
15:59:00 <niteria> I find that reading some more advanced stuff (e.g. okasaki) makes what you learned earlier easy, suddenly
15:59:02 <mauke> > 123 ^ 0
15:59:03 <lambdabot>   1
15:59:13 <mauke> > product (replicate 0 123)
15:59:14 <lambdabot>   1
15:59:31 <drrckln> now i am having a lot of trouble keeping track of what gets applied in what order
15:59:39 <SoleSoul> Hi. Is it possible to host a Wordpress site and a site written with Yesod (just an example of a Haskell web framework, any other is good) on the same Linux server? (I have never used Haskell for web programming, just reading about it for now)
15:59:42 <drrckln> generally i should assume things are left associative?
16:00:27 <ill_logic> drrckln: I think you should think that it's greedy.
16:00:40 <ski> niteria : yeah, and then you forget that it was hard, once, and wonder what people are having trouble with. then when you attempt to teach it, you rediscover how hard it still is; then when you can manage to teach it, you have learnt that you didn't understand it properly before ;)
16:00:44 <drrckln> ill_logic: hrm...?
16:00:46 <Cale> drrckln: Generally, evaluation order is outermost-first
16:00:48 <stepcut> SoleSoul: yes. you can run wordpress the normal way, and run the yesod app as a reverse proxy
16:01:05 <Cale> But if you're talking about precedence, function application binds more tightly than anything else
16:01:19 <Cale> That is  f x + g y  means (f x) + (g y)
16:01:28 <drrckln> except if you use $
16:01:29 <drrckln> hmm
16:01:37 <Cale> $ is also an example of that
16:01:37 <drrckln> and math stuff goes by order of operations
16:01:40 <ski> no, even if you use `$'
16:01:56 <Cale> $ is defined as function application with really low precedence
16:02:00 <Cale> f $ x = f x
16:02:01 <ill_logic> drrckln: starting from the left, the first function named will keep taking tokens after it until A) there are no more tokens to take or B) it doesn't accept any more.
16:02:09 <ski> there's no specified "evaluation order" in math
16:02:11 <Cale> but $ has low precedence
16:02:42 <SoleSoul> stepcut: thanks. I'll read about reverse proxies to understand the setup.
16:03:21 <ill_logic> drrckln: So "a b c" - if a is a function that takes two parameters, it'll take b and c as parameters, regardless of whether b takes any parameters. b won't have anything applied to it here.
16:03:34 <illissius> it's an edwardk!
16:03:44 <stepcut> SoleSoul: sure. There is probably a document somewhere describing how to run yesod apps behind apache or ngix
16:03:45 <Cale> Oh, and function application is normally left associative (though they screwed up and $ is oddly right associative)
16:03:48 <illissius> edwardk: I noticed that MonadST (http://hackage.haskell.org/packages/archive/monad-st/0.2.1.1/doc/html/Control-Monad-ST-Class.html) defines a single instance generically for all monad transformers. Is that because there are no sensible instances other than the base monads and lifting through transformers?
16:03:51 <Cale> So when you write f x y z
16:03:56 <Cale> it means ((f x) y) z
16:04:15 <illissius> (constrast to MonadIO which defines instances for various transformers individually)
16:04:17 <Cale> and correspondingly in types -> is right associative
16:04:19 <edwardk> illissius: yep
16:04:25 <Cale> So when you see  Integer -> String -> Double -> Bool
16:04:37 <Twey> ill_logic: They only take one parameter
16:04:37 <Cale> it means  Integer -> (String -> (Double -> Bool))
16:04:51 <edwardk> illissius: its kind of awful i admit ;)
16:05:07 <ill_logic> Twey: You mean technically functions only take one parameter, right?
16:05:14 <niteria> > minimum &&& maximum $ [3,1,2,5,4]
16:05:15 <lambdabot>   (1,5)
16:05:18 <niteria> ^^
16:05:45 <ill_logic> Depends how technically accurate you want to get explaining to someone of a particular level.
16:05:57 <SoleSoul> stepcut: I got it. now if I may ask, the reverse proxy is the one which is being exposed to the world, right? why not let Apache be the reverse proxy? why Warp? (as I understand from what you wrote "run the yesod app as a reverse proxy")
16:05:58 <edwardk> illissius: in practice it is probably a little wrong, given that you could well have another monad of shape (* -> *) -> * -> * that has a secret ST monad inside of it somewhere
16:06:14 <ski> hm, is there a point with not having `instance (MonadTrans t,MonadIO m) => MonadIO (t m)' as well ?
16:06:20 <drrckln> hey thanks guys, i gotta leave now :/
16:06:27 <edwardk> illissius: but it works for all the monads i cared about, and i didn't have to write a million instances
16:06:44 <edwardk> i figured when someone came to me with a counter-example i'd break it apart
16:06:49 <hpaste_> fragamus pasted “can you help make this oneliner a little less awkward” at http://hpaste.org/69760
16:07:07 <fragamus> I am unfamiliar with the braces thingy
16:07:15 <illissius> edwardk: right. avoiding the combinatorial explosion seems like a good thing which is why I was wondering :)
16:07:22 <drrckln> Cale: gee..
16:07:23 <stepcut> SoleSoul: no, I meant let Apache be the reverse proxy, sorry
16:07:26 <edwardk> usually you can't get away with it
16:07:37 <SoleSoul> stepcut: Thank you :)
16:07:39 <fragamus> essentially I want two "let" things, but I am unsure how to make them
16:07:54 <james-ubc> hey guys, is there any irc/webchat clients written in haskell?
16:07:57 <james-ubc> *are
16:08:04 <illissius> (also I would never have guessed that you don't enjoy writing instances.)
16:08:09 <mauke> yes, lambdabot
16:11:21 <ski> fragamus : btw, next time, annotate the original paste with updates
16:11:32 <ski> fragamus : i'm not sure what you mean by "two \"let\" things"
16:11:52 <bungley> hey, in ghci is there a way to see which module something has been imported from?
16:12:15 <hpaste_> fragamus annotated “can you help make this oneliner a little less awkward” with “can you help make this oneliner a little less awkward (annotation)” at http://hpaste.org/69760#a69761
16:12:28 <fragamus> I mean that^^^
16:12:37 <ski> bungley : try `:i something'
16:12:44 <bungley> thanks ski
16:13:06 <ski> well, you can write
16:13:13 <ski>   let {(xt,xb) = pick x; (yt,yb) = pick y};
16:13:16 <ski> if you want to
16:13:24 <ski> i'm not sure if you think that's nice enough
16:13:44 <ski> in case `x' and `y' have the same type, you could also write
16:14:03 <ski>   let {[(xt,xb),(yt,yb)] = map pick [x,y]};
16:14:31 <ski> fragamus : does that help ?
16:14:54 <fragamus> yeah dang it sure does
16:15:17 <otters> my cabal-dev ghci isn't giving me warnings despite having -Wall in the ghc-options field in the cabal file
16:16:36 <ski> you could also use `((xt,xb),(yt,yb)) = join (***) pick (x,y)', but i'm not sure if it's any better
16:17:13 <fragamus> that's far out
16:17:21 <Hani_> interesting
16:18:15 <ski> you could use a "mix"-combinator to turn `((xt,xb),(yt,yb))' into `((xt,yt),(xb,yb))' and then use `second (uncurry riff2)' on that to get `(z,(xb,yb))' -- that way you wouldn't have to mention these nested tuples explicitly at all
16:18:36 <ski> something like
16:19:01 <ski> hm, right it's monadic as well
16:19:06 <otters> :t pick
16:19:07 <lambdabot> Not in scope: `pick'
16:19:37 <ski> (oh and s/second/first/, i meant ..)
16:21:19 <ski> @type (uncurry . flip) (liftM . flip (,))
16:21:20 <lambdabot> forall b a1 (m :: * -> *). (Monad m) => (m a1, b) -> m (a1, b)
16:22:47 <ski>   riff_tops = curry (lStrength . first (uncurry riff2) . mix)
16:23:02 <ski>   lStrength = (uncurry . flip) (liftM . flip (,))
16:23:25 <illissius> edwardk: Oh, (sorry for bothering) the other thing someone was wondering about the other day (I think it was nand`?) was whether there's any reason Comonad isn't defined as class (Extend w, Copointed w) => Comonad w, i.e. whether there's any difference between copoint and extract.
16:23:29 <ski>   mix = (fst &&& fst) &&& (snd &&& snd)  -- i think
16:23:35 <ski> @type (fst &&& fst) &&& (snd &&& snd)
16:23:36 <lambdabot> forall c b. (c, b) -> ((c, c), (b, b))
16:23:41 <ski> hm, no
16:23:56 <ski> @type (fst *** fst) &&& (snd *** snd)
16:23:57 <lambdabot> forall c b a b1. ((c, b), (a, b1)) -> ((c, a), (b, b1))
16:23:58 <ski> right
16:24:11 <edwardk> yes, Copointed is largely useless, and i don't really like classes that offer only a law
16:24:44 <ski> why ?
16:25:01 <ski> fragamus : but i assume you wouldn't want to use the above anyway :)
16:26:03 <ski> oh, i forgot to call `pick' ..
16:26:21 <ski>   riff_tops = curry (lStrength . first (uncurry riff2) . mix . join (***) pick)  -- then ..
16:26:24 <fragamus> omg wow
16:27:14 <ski> fragamus : note that this is just a silly exercise, i don't suggest that one would *want* to write (or read) this
16:27:55 <ski> edwardk : why ?
16:34:22 <edwardk> mainly because deep class hierarchies in haskell don't come for free, since you have to explicitly instantiate all of your superclasses, so you need something to keep yourself from going insane. as for why i prefer Extend to Copointed, an associative law is a lot more useful than some random point with no laws. when you write code that uses, say Pointed and Monoid to build a Set, you have no reason to believe that those two are compat
16:34:22 <edwardk>  general!
16:34:51 <edwardk> There are very few correct usecases for Pointed/Copointed while there are lots for Apply/Bind/Extend
16:35:46 <ski> ".. you have no reason to believe that those two are compat"
16:35:55 <edwardk> 'compatible in general'
16:36:28 <edwardk> most uses of Pointed are like that, where you use Pointed and something else that has no laws to tie it to Pointed.
16:36:48 <ski> yes, and that's why you need a merging class with laws (and possibly zero ops) -- or rephrase so as to not have the disjoint to begin with
16:37:05 * ski nods
16:37:28 * ski glares at `Read' and `Show' in the report
16:37:30 <edwardk> ultimately, haskell is a pretty crappy language to write all those classes in, because i have to pay for every point above me in the class lattice for every type i want to make instantiate the hierarchy
16:37:56 <edwardk> mind you almost every other language is as bad or worse at things like this ;)
16:38:45 <ski> (i'm sure we've talked about this before), but it'd be really nice if one could write default implementations of superclass methods, when defining a class
16:39:10 <ski> i suppose a problem is what happens when two disjoint subclasses both wants to give a default to a superclass member ?
16:41:05 <illissius> ski: right, that's one of the main tripping points I remember from the discussions on this a year(?) or so ago
16:41:15 <ski> the other related idea here is to allow one to declare superclasses of existing classes by (a) removing members; and/or (b) restricting the types of existing members
16:41:29 <ski> (cf. refinement types)
16:42:28 <ski> (i'm not sure how well (b) would work, but it seems like one should consider it at least)
16:42:49 <illissius> ski: the former method makes it cheap to add subclasses, while the latter method makes it cheap to add superclasses, afaict
16:43:03 <illissius> also the former method is less counterintuitive and weird :)
16:43:45 <ski> well, i didn't mean to remove the usual subclassing mechanism if the other superclassing stuff was added
16:44:18 <ski> in math, both ideas are used all the time
16:44:31 <edwardk> ski: the other problem with the default instances for superclass methods is it doesn't help enough. when you go to define instance (Foo a, Foo b) => Foo (a, b)  and you have a subclass of Foo, Bar, then you often need instance (Bar a, Bar b) => Bar (a, b) completely independently
16:44:42 * HairyDude investigates yesod
16:44:52 <edwardk> and you'd need to define the members of the former entirely anyways
16:45:25 <ski> edwardk : hm, with the "same" definitions of the methods ? or different ones ?
16:45:52 <ski> edwardk : possibly bounded polymorphism over classes could come to the rescue here ?
16:46:31 <edwardk> consider data (f :*: g) a = Both (f a) (g a) -- the instances for Functor, Foldable and Traversable. you can't really get around defining them all separately
16:46:39 <ski> (if different ones, then maybe this is a case where inheritance would be useful ..)
16:46:56 <edwardk> otherwise the Functor instance for (f :*: g) will want the Traversable for f and the Traversable for g because the Traversable instance for (f :*: g) did
16:47:09 <HairyDude> cor, yesod has a lot of dependencies that aren't included in the haskell platform
16:47:11 <ski> hm
16:48:18 <illissius> ski: what I'm wondering is whether there isn't some big insight to be had about the nature of the problem that yields an elegant solution, like ConstraintKinds was for the 'other half'.
16:48:23 <ski> edwardk : ty for an interesting problem to ponder ;)
16:48:30 <illissius> of course that's super-vague and i have no idea what it might look like.
16:49:28 * ski 's knee-jerk reaction is bounded polymorphism, but he can see that that is not going to work here, at least not directly
16:49:32 <edwardk> basically the superclass defaulting mechanism is only really useful when you aren't transforming something into something else
16:51:08 <ski> hm, this feels sortof lensy
16:51:34 <edwardk> if you write sufficiently monomorphic code its fine, but when do i do that? =)
16:51:53 * ski knows the feeling
16:56:04 <zhulikas> interesting... avoiding function nesting (let ... in syntax) gave around 10% performance boost
16:56:32 <zhulikas> writing function type signatures gave another ~5%
16:56:38 <zhulikas> any more tricks I should be aware of?
16:56:49 <HairyDude> use -O ?
16:57:04 <mauke> use -O2
16:57:07 <HairyDude> that too
16:57:09 <hpc> -O2 is magic
16:57:10 <ion> use -O999
16:57:35 <mauke> -O999 doesn't exist
16:57:41 * HairyDude twiddles thumbs waiting for stuff to compile
16:58:26 <sipa> use -Oi, that enabled imagimary optimizations
16:58:56 <zhulikas> -O2 didn't help a bit
16:58:58 <HairyDude> ghc.exe: internal error: evacuate: strange closure type 65535
16:59:04 <HairyDude> sounds bad
16:59:21 <HairyDude> while compiling http-conduit
17:00:23 * zhulikas in the evening solved 4 project euler problems o/
17:00:25 <ion> sipa -O2+2i
17:00:34 <HairyDude> hehe
17:00:49 <zhulikas> all around #40-#50
17:00:55 <sipa> ion: ah, complex optimizations, yes!
17:00:59 <mauke> use -OI to enable comonads
17:01:25 <zhulikas> so yeah, -O
17:01:32 <zhulikas> I was more curious about in-code optimizations I can do
17:01:37 <zhulikas> to help compiler do it's work
17:01:47 <edwardk> OI doesn't work very well, stick to IO ;)
17:02:02 <otters> ohh, I get it
17:02:04 <otters> 10/10 would read joke again
17:02:32 <HairyDude> odd, rerunning my cabal install command made it work without the error.
17:04:04 <ion> instance Extend IO where { duplicate a = a <$ a }; instance Comonad IO where { extract = unsafePerformIO }
17:04:59 * HairyDude abjures the Impure Function of Doom
17:05:05 <otters> so if Comonad is the dual of Monad
17:05:11 <otters> what's the concept dual of IO?
17:05:26 <hpc> OI
17:05:37 <otters> what's it do?
17:05:40 <hpc> named after what british kids say while doing nothing
17:05:41 <HairyDude> I don't think the question makes sense tbh... IO is a real thing, not a theoretical one
17:06:01 <otters> technically yes
17:07:37 <sipa> yes, but theoretically there is no difference between practice and theory!
17:08:03 <otters> in practice, however, there is
17:08:33 <sipa> details
17:18:27 <ski> otters : `IO' isn't a concept at the same level as `Monad'
17:19:05 <ski> otters : it makes sense to talk about monads in any category, which is why there is a dual concept
17:19:18 <otters> Right
17:19:23 <otters> Okay
17:19:52 <ski> if you had a concept, like "universal algebra" which makes sense in any cartesian category, you could dualize this to "couniversal algebra", which then makes sense in any cocartesian category
17:20:55 <ski> the point in the case with monads and comonads is that "category" is a self-dual concept, so it always makes sense to talk about monads as well as comonads in any particular category
17:21:57 <HairyDude> or another way "universal coalgebra"
17:22:54 <Baughn> @. pl undo do { a <- x; b <- x; c <- x; return [a,b,c] }
17:22:54 <lambdabot> (x >>=) . (((x >>=) . (return .)) .) . (. ((. return) . (:))) . (.) . (:) =<< x
17:23:12 <otters> so gorgeous
17:23:41 <ion> Pointfree makes everything better.
17:23:52 <HairyDude> s/better/less readable/
17:23:54 <niteria> it makes it pointless
17:24:17 <ion> @@ @unpl @pl @undo do { a <- x; b <- x; c <- x; return [a,b,c] }
17:24:17 <lambdabot>  (\ l -> x >>= \ ae -> x >>= \ ah -> return ((x >>= ((:))) l (((:)) ae (return ah))))
17:24:21 <ion> @@ @redo @unpl @pl @undo do { a <- x; b <- x; c <- x; return [a,b,c] }
17:24:21 <lambdabot> Plugin `compose' failed with: Unknown command: "redo"
17:24:30 <ski> `do'
17:24:31 <Peaker_> @type let list3 x y z = [x,y,z] in \x -> liftM3 list3 x x x
17:24:32 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1]
17:24:36 <ion> @@ @do @unpl @pl @undo do { a <- x; b <- x; c <- x; return [a,b,c] }
17:24:36 <lambdabot>  (\ l -> do { ae <- x; ah <- x; return ((do { a <- x; ((:)) a}) l (((:)) ae (return ah)))})
17:24:54 <HairyDude> and the S:N ratio of #haskell goes down... :P
17:24:57 <sipa> steadily improvinh
17:25:05 <Peaker_> @pl list3 x y z = [x,y,z]
17:25:05 <lambdabot> list3 = (. ((. return) . (:))) . (.) . (:)
17:25:09 <otters> I don't think there are enough parentheses there
17:25:09 <coppro> pm please
17:25:10 * Baughn remembers sequence. Yeah, that'll work.
17:25:29 <Peaker_> replicateM 3 x
17:25:31 <Peaker_> :)
17:25:42 * Peaker_ admits he missed that
17:25:47 <HairyDude> replicateM in the list monad is great
17:25:55 <otters> :t replicateM 3
17:25:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
17:25:56 <Baughn> In the real version, the x has three parameters, separate for each instance. :P
17:26:06 <Baughn> ..let's try that
17:26:31 <Baughn> @. pl undo do { a <- f 1 2 3; b <- f 10 20 30; c <- f 1 2 30; return [a,b,c] }
17:26:31 <lambdabot> (f 10 20 30 >>=) . (((f 1 2 30 >>=) . (return .)) .) . (. ((. return) . (:))) . (.) . (:) =<< f 1 2 3
17:26:47 * Baughn shrugs. Guess that's not surprising.
17:27:02 <niteria> there's a sad thing information theory made me realize, functions can't increase entropy, so every computation we do just reduces the information we had
17:27:39 <ion> baughn: Are you sure you want to encode something like 3-tuples as a list?
17:27:43 <HairyDude> eh... not exactly
17:27:53 <HairyDude> it can't increase the information we have
17:28:00 <HairyDude> but it can fail to destroy information.
17:28:03 <Baughn> ion: sequence [ trickle 1 2 3, .., ..].
17:28:17 <niteria> it can, there are reversible functions
17:28:19 <Cale> niteria: Is there an information shortage?
17:28:21 <HairyDude> you meant functions can't decrease entropy, right?
17:28:26 <Baughn> ion: What it actually does is rate-limit network traffic, over three separate horizons
17:28:36 <Baughn> (trickle returns a TVar)
17:29:01 <niteria> HairyDude: they obviously can
17:29:17 <Baughn> niteria: Yet as fractals show, you can get very interesting behaviour out without putting any more information in
17:29:18 <HairyDude> define entropy in this context
17:30:07 <HairyDude> (I may be lacking the appropriate information-theoretical background to understand this conversation properly, mind)
17:30:47 <niteria> I mean entropy in this sense http://en.wikipedia.org/wiki/Entropy_(information_theory)
17:30:49 <HairyDude> Baughn: the key insight is information /= data
17:31:09 <Baughn> HairyDude: Feel free to define "data".
17:31:27 <HairyDude> bits
17:31:42 <Baughn> And "information"?
17:31:50 <niteria> it's essentially the measure of amount of information
17:32:05 * Baughn actually /did/ study information theory, though. :P
17:32:09 <HairyDude> ok, that was an overly glib definition. let me try again.
17:32:20 <Baughn> Nah, "bits" is reasonable
17:32:32 <Baughn> But for "information", maybe you want kolmogorov complexity
17:32:47 <HairyDude> now I start to hit the limits of my understanding :)
17:33:15 <niteria> good point about fractals
17:33:23 <Baughn> Kolmogorov complexity = the size of the smallest specification of some piece of data, in a fixed language(, in bits)
17:33:26 <irene-knapp1> um, information is also measured in bits
17:33:30 <irene-knapp1> cf. Claude Shannon
17:33:36 <irene-knapp1> _The Mathematical Theory of Information_
17:33:39 <HairyDude> quite, that was the point of Baughn's retort
17:33:40 <irene-knapp1> it's not the same thing as data, true
17:33:46 <Baughn> Which is almost but not quite the same as shannon entropy
17:34:05 <ski> hm, couldn't you measure the information content of a symbol on a stochastic channel in (possibly non-integral) bits ?
17:34:20 <Baughn> You can and would.
17:34:25 <HairyDude> does cabal-dev work in windows?
17:34:25 <niteria> so it seems that even if we have little information it can lead to complex behavior
17:34:33 <elliott> HairyDude: I think so.
17:34:36 <Baughn> Of course you can't actually transmit fractional bits, so at some point you end up rounding up
17:34:38 <elliott> (Not sure, thoiugh.)
17:34:48 <koltar> most symbols have fractional bits :)
17:34:59 <HairyDude> cabal just says installing it will probably break haskell-platform
17:35:24 <niteria> or fractals just arent complex
17:35:34 <Baughn> niteria: A little from column A, a little from column B
17:36:09 <niteria> I only know one complexity measure (Kolmogorov) and according to that fractals aren't complex
17:36:27 <Baughn> That assumes you can find *and grasp* the compression function
17:36:55 <Baughn> "Understanding" seems to be mostly a function of compression.. so if you can't mentally compress the fractal, then it's complex for you
17:37:04 <Baughn> At least in the subjective sense of "complexity"
17:37:12 <HairyDude> let me guess. haskell-platform depends on specific versions of packages, so upgrading them means breaking the dependencies. Correct?
17:37:14 <Baughn> On an absolute scale, sure, the kolmogorov complexity remains low
17:37:18 <Baughn> HairyDude: Yep.
17:37:25 <Baughn> HairyDude: That's one reason I prefer to install just GHC.
17:37:26 <koltar> i think complexity theory makes much more sense when viewed through an algorithmic lens
17:37:29 <niteria> that's more filosophical
17:37:30 <HairyDude> right
17:37:37 <sipa> kolmogorov complexity requires a language being encoded; entropy just measures information in an already-serialized symbols
17:37:42 <HairyDude> I think I'll do that
17:38:39 <HairyDude> ghc comes with cabal, right?
17:38:47 <Baughn> Cabal, yes. cabal-install, no.
17:38:49 <HairyDude> or the other way round...
17:38:50 <HairyDude> ah
17:39:02 <Baughn> But just keep the binary you have. It'll keep working.
17:39:36 <HairyDude> is there any way to remove the haskell-platform package? I'd rather not keep getting bogus messages about broken dependencies
17:39:40 <Peaker_> someone was worried about anti-aliasing in bottle...  if anyone is interested, I pushed use of texture fonts to: https://github.com/Peaker/graphics-drawingcombinators
17:39:49 <Baughn> HairyDude: rm -rf?
17:39:55 <HairyDude> sigh :)
17:40:03 <Baughn> HairyDude: There's also ghc-pkg unregister, but I don't know how well that'll work
17:40:10 <HairyDude> ah
17:40:13 <Baughn> (And it won't remove the files)
17:40:37 <HairyDude> isn't haskell-platform just a pseudopackage that depends on stuff?
17:40:44 <Baughn> Yes
17:40:58 <HairyDude> right, so ghc-pkg unregister haskell-platform should be fine?
17:41:10 <Baughn> Yes, but if you have something that conflicts with it, then you'll probably have to end up unregistering more packages
17:42:33 <HairyDude> ah, installing cabal-dev downgrades mtl
17:43:20 <HairyDude> getting a bunch of errors about header files present but not compilable
17:44:13 <HairyDude> and network-2.3.0.14 failed to install
17:46:29 <gienah> HairyDude: a cabal-dev patch for mtl/transformers: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/cabal-dev/files/cabal-dev-0.9.1-tf-0.3.patch
17:48:45 <HairyDude> let's see if I can apply that...
17:48:57 <gienah> HairyDude: for network it needs mingw setup: http://blog.johantibell.com/2011/01/setting-up-haskell-development.html
17:49:25 <HairyDude> ohhhh, thanks
17:49:31 <HairyDude> that looks promising
17:49:56 <HairyDude> (I'm using cygwin, btw)
17:50:10 <HairyDude> (just as a better shell really)
17:50:26 <gienah> HairyDude: no worries, of course sounds like you need both of these. ghc binaries are compiled with mingw, not cygwin
17:50:40 <HairyDude> right
17:51:04 <gienah> HairyDude: I'm not sure if cygwin works for other haskell libs like network or not
18:14:51 * hackagebot not-gloss 0.3.0 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.3.0 (GregHorn)
18:14:53 * hackagebot not-gloss 0.3.0.1 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.3.0.1 (GregHorn)
18:14:55 * hackagebot not-gloss-examples 0.1 - examples for not-gloss  http://hackage.haskell.org/package/not-gloss-examples-0.1 (GregHorn)
18:24:38 <elliott> not-gloss is some name for a package
18:24:46 <HairyDude> I'm going to have to try all this again tomorrow, too late for doing stuff like this...
18:51:04 <copumpkin> @free fix :: (a -> a) -> a
18:51:04 <lambdabot> f . g = h . f => f (fix g) = fix h
19:06:03 <luite> how does cabal-install determine the location of the user package database?
19:06:27 <hpc> it goes in your home
19:06:35 <hpc> unless you are doing --global
19:06:43 <hpc> and then it is determined by where ghc is
19:06:50 <hpc> i think
19:08:40 <luite> i know where it goes, but i don't know why it goes there :p
19:09:49 <luite> i mean, if i wanted to change the default location of the user package dir, how would i patch ghc, ghc-pkg or cabal?
19:12:17 <luite> oh wait, i think it just uses ghc-pkg update -
19:19:14 <fmap> is there any way to generate comments with TH?
19:19:25 <Peaker_> fmap, are you saving TH's output?
19:19:48 <tgeeky> fmap: no, and I don't think there is an AST for comments
19:20:35 <fmap> Peaker_: i'm trying to automatically generate haddocks for generated functions
19:20:37 <luite> you wanted pragma's or rules
19:20:38 <luite> ?
19:20:40 <luite> ah
19:20:40 <fmap> tgeeky: bad :(
19:22:53 <tgeeky> fmap: I assume it's also not possible to write a GHC extension to do that, since presumably the extension would run long after comments are stripped
19:23:31 <elliott> I wouldn't be so sure
19:23:34 <luite> does haddock actually see post-TH code?
19:23:38 <elliott> Since GHC "knows" about comments, I think
19:23:41 <elliott> luite: Yes.
19:23:53 <elliott> Look at the docs for a package which generates combinators or such with TH.
19:24:01 <elliott> And Haddock uses the GHC API, so...
19:24:21 <tgeeky> elliott: don't extensions run on core?
19:24:34 <elliott> tgeeky_: Oh, perhaps. You mean that new thing?
19:24:40 <tgeeky> elliott: yes, the 7.2 thing
19:24:55 <elliott> Right.
19:24:58 <elliott> Never mind, then.
19:24:59 <luite> elliott: ah
19:25:26 <tgeeky> the most generator-combinatory- thing on Hackage that I know if is "pointless-plumbers"
19:25:37 <tgeeky> it doesn't generate any comments or help, it also doesn't generate fixity declerations
19:25:44 <tgeeky> though the author is working on that
19:26:55 <tgeeky> I am pretty miffed that the default cabal installations: 1) don't install documentation by default, and 2) when they do install docs, they don't run hscolor by default (and this can't be enabled with the config file)
19:27:14 <elliott> tgeeky_: they don't even give source links, never mind syntax highlighting.
19:27:19 <tgeeky> 1) causes the "bug" that ghc-pkg check produces warnings about everything you install (without docs, which is everything)
19:27:44 <tgeeky> and 2) would be nice because it would mean that you local version of documentation would be have more or less the same as Haddock itself
19:28:04 <elliott> tgeeky_: my understanding is that the cabal devs want to spend time perfecting the haddock stuff rather than just adding a quick option to do hscolour.
19:28:33 <elliott> and with all due respect, the fact that it doesn't seem to be getting maintained much makes me sceptical that it'll ever appear :/
19:28:47 <tgeeky> yes I was going to say something more offensive than that
19:28:54 <tgeeky> the list of bugs for haddock is daunting
19:29:04 <elliott> i hear there is a patch to do it or something
19:29:07 <elliott> for cabal-install, I mean
19:29:20 <elliott> but it's unmerged because $insert_your_reason_here
19:30:25 <tgeeky> elliott: I have a project that's about 90% done now, which is to transliterate a functional pearl into Haddock completely
19:30:39 <tgeeky> it's tough work bending haddock to your will :)
19:30:46 <elliott> that sounds awful
19:30:47 <elliott> my condolences
19:30:55 <tgeeky> it's going to turn out nicely though
19:31:04 <elliott> I wanted to integrate Pandoc into Haddock once, but then noticed Pandoc was GPL and didn't have a gigabyte of dependencies
19:31:16 <elliott> so you could use markdown rather than dumbhaddockmarkupthatdoesn'tevensupportlinktext
19:31:21 <tgeeky> yeah
19:31:28 <elliott> erm
19:31:31 <elliott> s/didn't have/has/
19:31:31 <tgeeky> i came to the same conclusion very quickly
19:31:39 <tgeeky> why would you even start with haddock
19:31:51 <elliott> because haddock exists :P
19:32:06 <elliott> i think a more lightweight markdown implementation would be nice, so it could have a chance of becoming a boot package
19:32:08 <tgeeky> yep. Fallacy of argument by tradition. :)
19:32:21 <tgeeky> there is a haskell sundown version
19:32:34 <elliott> really though, haddock is probably more good than bad
19:32:35 <tgeeky> I still dislike markdown because it acts like lots of symbols are the same, when they aren't
19:32:47 <tgeeky> elliott: yes. It survives, so it can't be worthless.
19:32:52 <elliott> markdown isn't ideal but people know it and it's well-tested
19:33:30 <luite> hmm, the license of pandoc seems to be a problem for many people, what's the standpoint of the author on this?
19:33:50 <elliott> luite: I think they like it
19:33:56 <Axman6> which license is it?
19:33:56 <elliott> luite: there's a github issue on the matter
19:33:57 <elliott> Axman6: gpl
19:34:02 <Axman6> :(
19:34:05 <elliott> luite: see https://github.com/jgm/pandoc/issues/180
19:34:21 <elliott> luite: (and there's also a slight issue with relicensing in that a dependency uses external files, some of which are GPL'd)
19:35:52 <koltar> actually, the external files (like the script mentioned) can be non-GPL
19:36:02 <palmfrond> when you connect to a running haskell instance, what 'node' or operating context do you enter by default?
19:36:13 <koltar> for example, GNU make can call proprietary CC's
19:36:35 <elliott> palmfrond: that's a bit of a vague question
19:36:37 <elliott> connect howso?
19:36:51 <elliott> koltar: yeah, but AIUI it's a derivative work
19:37:00 <palmfrond> let's say you connected via a console to a smalltalk instance, or you fired up a haskell REPL
19:37:16 <palmfrond> my curiosity is in how platforms 'begin' an operating context
19:37:32 <palmfrond> like when you first mound a hard drive, does the hard drive return a root node to begin at?
19:37:40 <palmfrond> or do you just begin sending commands to the hard drive like list files
19:37:43 <elliott> GHC doesn't really support connecting to running processes...
19:37:50 <elliott> ("GHC" because this is implementation-specific.)
19:38:08 <elliott> But firing up a GHCi REPL just puts you at the rough equivalent of a do block in the IO monad.
19:38:26 <palmfrond> elliott, a what?
19:38:33 <palmfrond> can you say it generally? i'm very new to haskell
19:38:51 <elliott> Well, it's hard to tell you exactly how GHCi starts up without you knowing details of Haskell :)
19:39:12 <elliott> But it just lets you enter expressions that assign variables and do IO, more or less.
19:39:25 <luite> and it has the Prelude module loaded
19:39:39 <palmfrond> so it loads some functional modules automatically?
19:40:08 <shachaf> palmfrond: What does that mean?
19:40:23 * shachaf can't figure out what palmfrond is trying to figure out here.
19:40:24 <palmfrond> well what does Prelude do?
19:40:32 <elliott> It... loads the Prelude. But I have a feeling it's hard to understand what you're trying to understand without knowing Haskell.
19:40:36 <elliott> So maybe you should learn Haskell :)
19:40:44 <elliott> palmfrond: It contains a bunch of useful definitions.
19:40:50 <palmfrond> elliott, please stay focused on my questions
19:40:54 <palmfrond> such as?
19:40:57 <elliott> Some of them are built-in (not implementable in Haskell, like IO primitives), some of them are defined in Haskell.
19:41:12 <elliott> palmfrond: I'm allowed to express an opinion on how fruitful I think an answer to your question will be...
19:41:15 <palmfrond> oh interesting
19:41:21 <palmfrond> no you're doing great
19:41:37 <palmfrond> so it seems you start right into a fresh operating context, namespace, memory space
19:41:58 <elliott> Um. Sort of, sure.
19:42:21 <ion> New system processes tend to work like that.
19:42:21 <palmfrond> so what are a couple of things Prelude defines?
19:42:39 <elliott> http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Prelude.html
19:42:53 <elliott> (That's a list of all of them.)
19:45:08 * geekosaur scans back to start of discussion, is somewhat mystified as to viewpoint
19:45:12 <palmfrond> ah prelude adds a lot
19:45:41 <elliott> It doesn't really "add" a lot, it's more like it *is* the lot. Without the Prelude, you have nothing predefined, just the core language constructs themselves.
19:46:06 <Axman6> palmfrond: prelude is basically the standard library of Haskell
19:46:49 <palmfrond> elliott, but isn't that still a lot? i wonder what that would look like
19:46:57 <palmfrond> a bunch of functionality with no data?
19:47:04 <shachaf> palmfrond: The questions you're asking are probably not going to help you understand what you're trying to understand. But then again I'm not quite sure what it is that you're trying to understand. :-)
19:47:16 <arbn> Having trouble following the Glade tutorial for Gtk2Hs...
19:47:26 <hpaste_> arbn pasted “Glade problem” at http://hpaste.org/69767
19:47:33 <palmfrond> i'm building a programming language and i'm working on the console/REPL, so i'm seeing how other langs do stuff
19:47:49 <elliott> palmfrond: Check the Haskell Report.
19:48:07 <arbn> I'm running out things to try, to get this to work. Any tips or pointers would be appreciated. I can provide any other needed information.
19:48:16 <elliott> palmfrond: It's just the tools you can use to define things: basic constructs like let...in and if...else (although if...else depends on Bool in Prelude, so it's not really separable from the language itself!), data declarations, typeclass declarations, etc.
19:49:10 <palmfrond> elliott, ahh, and implemented in the local way, like these double datatypes etc
19:49:30 <Axman6> double datatypes?
19:49:42 <shachaf> palmfrond: I have no idea what that means.
19:49:42 <palmfrond> must make the core platform neutral ?
19:49:59 <geekosaur> something to understand is that Haskell is not primarily a dynamic interpreted language; ghci and runghc exist and provide a sort of virtual machine environment, but are not optimized and are mainly intended for debugging and testing.  The primary mode of use is as a compiler that produces native executables, which don't involve a VM
19:50:11 <palmfrond> data Double
19:50:21 <elliott> palmfrond: What must make the core platform neutral? ...And what's the core platform, anyway?
19:50:31 <elliott> Really, I don't quite understand any of your questions :)
19:50:45 <palmfrond> geekosaur, ahhhh
19:50:54 <geekosaur> see my response.  I believe palmfrond is imagining a setup like Smalltalk / JVM / CLR
19:51:01 <geekosaur> or some Lisps
19:51:09 <palmfrond> yea
19:51:12 <palmfrond> you're right
19:51:17 <palmfrond> thanks for the clarification
19:51:29 <elliott> palmfrond: Note that "Haskell" is not "GHC".
19:51:41 <geekosaur> and while ghci can be used like that, it's really somehting of an afterthought; there are platforms where the compiler works but ghci does not (notably ARM, although I think they're working on it)
19:51:45 <elliott> GHC is a compiler and an interpreter, the interpreter part acting basically like a Python REPL.
19:51:48 <palmfrond> is GHC an implementation of the Haskell spec?
19:51:49 <elliott> Not really like a Lisp or Smalltalk.
19:51:55 <elliott> Hugs is a plain interpreter, acting... well, like Python again.
19:51:58 <elliott> palmfrond: Yes (and more).
19:52:08 <elliott> But you could also write a Haskell implementation that's a VMy type thing like Lisp or Smalltalk.
19:52:12 <elliott> Not that I know that anyone has.
19:52:22 <palmfrond> yea that's what i'm building
19:52:26 <geekosaur> jhc is an implementation of the Haskell spec that generates ANSI C
19:52:28 <palmfrond> a way to console in to a running operating instance
19:52:37 <palmfrond> monitor, issue commands, add to the programming, etc
19:52:53 <palmfrond> like introspection
19:54:33 <geekosaur> elliott, I think I'd argue that Hugs *is* that kind of system
19:54:42 <geekosaur> unforutnately it's not seeing a lot of development any more
19:54:48 <elliott> geekosaur: Can it dump the running state to a file and such?
19:54:53 <elliott> I wouldn't really consider it Smalltalky if not.
19:55:14 <geekosaur> no, although I think there was work on it but was never completed
19:55:20 <luite> there's a ghc fork that can do that
19:55:31 <elliott> geekosaur: What differentiates Hugs from a regular interpreter, then?
19:56:14 <geekosaur> at some level there isn't a lot of difference between a regular interpreter that uses bytecodes and a VM
19:56:16 <ion> palmfrond: Erlang has something like that, you should look at it.
19:56:37 <palmfrond> ion, ok thanks
19:57:07 <geekosaur> I mean, JVMs and CLR don't dump running state to a file either, but the JM functions as heir apparent to Smalltalk (at least as far as IBM and some other current/former Smalltalk users are concerned)
19:57:28 <palmfrond> i will allow dumping running state to a file
19:57:35 <palmfrond> (and more)
19:58:57 <unnali> @pf (:[])
19:58:57 <lambdabot> Maybe you meant: bf pl
19:59:02 <elliott> geekosaur: JVMs and CLR aren't Smalltalky in the way being considered, at least
19:59:09 <elliott> Erlang is, though, like ion said.
19:59:18 <Axman6> unnali: that's already pointfreee
19:59:23 <unnali> well, yes.
19:59:26 <Axman6> @unpl (:[])
19:59:27 <lambdabot> (\ a -> a : [])
19:59:28 <unnali> I really wanted to see if there was an alternate bette form.
19:59:31 <unnali> better*
19:59:34 <unnali> @pl (:[])
19:59:34 <geekosaur> and it's pl
19:59:34 <lambdabot> return
19:59:36 <unnali> ^^
19:59:38 <unnali> that's what I wanted.
19:59:41 <ion> pure
20:00:04 <Axman6> take 1 . repeat
20:00:08 <Axman6> >_>
20:00:16 <unnali> Axman6: <.<
20:00:18 <ion> hah
20:00:29 <ion> maybeToList . listToMaybe . repeat
20:00:31 <elliott> unnali: pure
20:00:39 <elliott> pure is nicer than return IMO. Less connotations :P
20:00:58 <elliott> Axman6: heh
20:01:09 <Axman6> except it isn't really a verb. I'm gonna pure the crap outta this a!
20:01:32 <unnali> verb or not, pure is nice.
20:01:35 <shachaf> Verbs are bad function names anyway.
20:01:36 <tswett> Neither are "odd" or "max".
20:01:36 <ion> Since when do function names need to be verbs?
20:02:01 <tswett> Nor "Just" nor "Left" nor "IO" nor.
20:02:30 <unnali> lift . lift . lift . tell . pure
20:02:33 <unnali> this is a bit ..
20:05:42 <elliott> unnali: those lifts are usually unnecessary
20:11:02 <unnali> not in this case, it seems!
20:11:17 <unnali> i have a StateT VM (WriterT [Message] (ErrorT String (WriterT [String] Identity))) -- yuck
20:11:22 <elliott> unnali: nope
20:11:27 <elliott> oh, hmm
20:11:30 <elliott> you might need two stacked lifts
20:11:31 <elliott> but not there
20:11:32 <elliott> *three
20:11:40 <unnali> strange
20:11:48 <elliott> because you get the lifts for free with mtl's typeclasses
20:11:52 <unnali> in that case i get a type mismatch of ErrorT vs. WriterT
20:12:02 <elliott> are you using Control.Monad.Trans.Foo instead of Control.Monad.Foo?
20:12:07 <unnali> yes
20:12:14 <elliott> Don't do that if you don't want to write "lift" a lot, then :P
20:12:19 <rwbarton> @type tell
20:12:20 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
20:12:25 <elliott> Ideally you would encapsulate each of those writers in their own newtype and class, anyway, so you'd need a grand total of 0 lifts.
20:12:26 <unnali> right!
20:12:28 <elliott> But that could be a pain.
20:12:42 <unnali> hah, yeah. at this stage I'm just writing the lifts once-off for the whole stack
20:12:44 <elliott> (Still, mixing two of the same monad transformers in a stack is always a bit awkward.)
20:13:07 <unnali> yeah, and I'm not expecting to do that 'for free', as such.
20:13:13 <xil> hello everyone. This isn't haskell specific but I thought y'all could help. I recently made a Turmite simulator and I'm looking for a next project. I had thought about Conway's Game of Life, but I don't really know what to do with it. Anyone have any ideas?
20:13:46 <unnali> hm, okay, good call! using the non .Trans. variants let me drop a lift. thanks! I was thinking there should be a way to do something like that.
20:14:20 <elliott> unnali: Right. You should only need lifts to get below a monad transformer so that it sees one of the same type, essentially.
20:14:25 <elliott> Other than that, you shouldn't have to lift at all.
20:14:32 <elliott> (To execute "primitives" like that, I mean.)
20:14:39 <unnali> that's what I was hoping (and I could've sworn I had read something similar)
20:14:52 <unnali> I didn't realise there was WriterT in C.M.W
20:15:03 <unnali> but now I'm a little more clear on the packages involved
20:15:12 <elliott> basically, Control.Monad.Foo builds on top of Control.Monad.Trans.Foo and adds some more typeclasses
20:15:21 <elliott> which can't go in transformers itself, because they require extensions to standard haskell
20:15:32 <JoeyA> xil: How about a cellular automaton whose transition function takes a QR code and always returns a valid QR code?  :D
20:15:34 <unnali> aha.
20:15:59 <xil> JoeyA: haha, but to what end?
20:16:03 <elliott> (multiple-parameter typeclasses, essentially, so that it can associate the type of the state with the stack that has a StateT in it)
20:16:09 <elliott> (or the monoidal type for a stack with WriterT, etc.)
20:16:42 <JoeyA> xil: "haha" is the end to which that would be done ;-)
20:16:55 <xil> lol
20:17:02 <startling> that's a pretty cool idea
20:17:16 <elliott> JoeyA: I have a feeling you can't make a CA which does that and doesn't just stay the same always.
20:17:31 <JoeyA> I think I'll have to add another rule: each tile must be determined only by neighboring tiles and itself.
20:17:36 <elliott> i.e., I suspect no repeated local change to a QR code can keep it always valid.
20:17:38 <unnali> elliott: right! Thanks for the explanation. :)
20:17:44 <elliott> JoeyA: Well, that's what a CA is.
20:17:45 <elliott> unnali: np :)
20:17:46 <JoeyA> This rules out simply decoding the QR, applying Conway, then re-encoding it.
20:17:47 <xil> well the thing I liked about the Turmite simulator was running it with random rule sets. I basically set it up so that at the press of a button it would randomize the rules and reset. I spent literally hours just doing that
20:17:48 <startling> what is "valid" in this case?
20:17:56 <elliott> startling: "Decodes properly", presumably.
20:18:26 <startling> then why wouldn't it be possible?
20:19:01 <elliott> startling: Because I suspect any local change can be applied to every cell of a given pathological QR code to make it invalid by introducing errors into it.
20:19:07 <elliott> For a start, you need to preserve the static marker things it uses.
20:19:16 <elliott> Without enough context to determine that they're actually part of the maker.
20:19:18 <elliott> marker.
20:19:34 <startling> oh hmm, i was exepcting to special-case those
20:19:47 <startling> that *is* interesting, though
20:20:01 <xil> it sounds like it would be impossible for a general case
20:20:10 <xil> if you're limited to a small neighborhood
20:20:28 <startling> is an empty qr code valid?
20:20:34 <startling> except for the markers
20:22:31 <JoeyA> I suppose it would be possible by having computations hug the three position anchors.  I don't plan on spending any time trying to figure out, though.
20:24:05 <xil> what about other ideas though. Are there other automata that are interesting?
20:24:45 <xil> I don't know all the terminology, but for example, Conway's Game of Life is built on a different premise than Turmites
20:25:07 <xil> I'm wondering about even more premises than either of those, rather than just different rules
20:26:42 <startling> xil, you can make a set of rules that looks a lot like fire
20:27:29 <startling> I don't remember the specifics, but someone in the 0x10c scene did something like that
20:27:56 <xil> well...I did explore rule sets for Turmites, maybe I should explore rule sets for the Game of Life scenario
20:28:12 <xil> just randomize the rules, but the question is then what the initial conditions should be
20:37:41 <Jackson> Wow, this room is packed.
20:38:01 <xil> maybe I'll make Snake, lol
20:38:41 <Clint> the possibilities are endless
20:38:54 <xil> just need an idea, and I'm partial to simulators, but have no idea for one
20:39:26 <startling> xil, write an interpreter
20:39:28 <xil> in the long term I'm an artificial neural network and genetic algorithms guy, but I'd like to start with something small in the mean time
20:40:03 * hackagebot spatial-math 0.1.3 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.1.3 (GregHorn)
20:55:03 * hackagebot spatial-math 0.1.4 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.1.4 (GregHorn)
20:55:55 <xil> well I guess I'll get back to my Haskell neural network work then =/. Just have no motivation to work on it. I feel like I still have so much to learn about programming in Haskell effectively
21:18:44 <td123> xil: are you implementing it with matrix multiplication?
21:20:25 <xil> td123: doubtfully. The focus actually isn't about the neural network implementation, but a particular genetic training algorithm. But either way the network I'm going to be using will doubtfully be conveniently layered, so I don't think I could do it with matrix multiplication
21:23:46 <td123> ah, os your GA is evolving NNs?
21:24:00 <td123> s/os/so/
21:24:04 <xil> yes
21:24:12 <xil> it's called NEAT
21:24:15 <xil> if you've heard of it
21:25:19 <xil> I wrote a simulation using it that came out pretty well, but it was very bad code. Now I'm trying to write it better/more generally
21:25:28 <td123> haven't heard of it until now, will read the wiki page for it though :)
21:25:48 <xil> NeuroEvolution of Augmenting Topologies
21:25:56 <xil> just so you know you have the right thing =P
21:25:59 <td123> yup, found it :)
21:28:17 <xil> it's super cool. I wrote my undergraduate thesis on it and that's what the simulation was for. But man is it poorly written
21:31:50 <td123> wikipedia article doesn't have much, still sounds pretty neat
21:32:12 <td123> doh.. pun intended
21:35:07 * hackagebot not-gloss 0.4.0 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.4.0 (GregHorn)
21:35:47 <shachaf> td123: Wait... what pun?
21:40:07 * hackagebot not-gloss-examples 0.2 - examples for not-gloss  http://hackage.haskell.org/package/not-gloss-examples-0.2 (GregHorn)
21:40:28 <ion> xil: Ooh, i’ve been thinking of making an implementation of NEAT in Haskell for ages but i haven’t managed to get around to that.
21:42:47 <xil> ion: well I'm in the process of making one myself. I guess we'll see how that goes. I doubt it'll be particularly great code, but hopefully it'll be a starting point for something better
21:43:08 <xil> I still have a lot to learn about paradigms for writing classtypes
21:43:36 <ion> xil: Will your implementation do pruning of nodes?
21:43:53 <xil> ion: only in the sense of disabling them, but yes if that's what you mean
21:44:01 <xil> that's a part of the NEAT spec right?
21:44:35 <xil> though I found out that there has been some improvement to NEAT having to do with geometry of the problem to be solved
21:44:41 <xil> I haven't read up on that though
21:44:45 <ion> Hmm, i don’t remember. I thought the removal of nodes as a part of the evolution was an extension to the original NEAT, but i might be wrong.
21:45:07 <xil> it is part of the paper I read, which was from 2002
21:45:11 <ion> ok
21:45:17 <xil> each gene just has an enabled bit
21:45:24 <ion> alright
21:45:46 <ion> I’m looking forward to your module. :-)
21:46:09 <xil> me too =P
21:46:27 <xil> but I actually realized a possible way to help the process along, so I'm trying that now
21:47:18 <ion> I’ve been thinking whether it would be feasible to generate a LLVM code representation of the network and evaluate it by running it with JIT.
21:47:50 <ion> One could then export an implementation of the final network as, say, LLVM bytecode.
21:48:33 <xil> just have to make sure to make it general enough to the type of network
21:49:22 <xil> that's what I'm excited for this module for
21:49:40 <xil> I'm planning on not presuming anything about the network itself, just providing an interface for people to plug their own networks into
21:49:51 <ion> Alright, cool.
22:04:33 <lutS112> please irc.arcamens.com is better than freenode. tau rocks copumpkin: has aids and doesnt know any shit about programming.
22:04:33 <lutS112> please irc.arcamens.com is better than freenode. tau rocks copumpkin: has aids and doesnt know any shit about programming.
22:04:33 <lutS112> please irc.arcamens.com is better than freenode. tau rocks copumpkin: has aids and doesnt know any shit about programming.
22:04:33 <lutS112> please irc.arcamens.com is better than freenode. tau rocks copumpkin: has aids and doesnt know any shit about programming.
22:04:33 <lutS112> please irc.arcamens.com is better than freenode. tau rocks copumpkin: has aids and doesnt know any shit about programming.
22:04:33 <cyrp88> please irc.arcamens.com is better than freenode. tau rocks copumpkin: has aids and doesnt know any shit about programming.
22:04:33 <cyrp88> please irc.arcamens.com is better than freenode. tau rocks copumpkin: has aids and doesnt know any shit about programming.
22:04:33 <cyrp88> please irc.arcamens.com is better than freenode. tau rocks copumpkin: has aids and doesnt know any shit about programming.
22:04:33 <cyrp88> please irc.arcamens.com is better than freenode. tau rocks copumpkin: has aids and doesnt know any shit about programming.
22:04:33 <cyrp88> please irc.arcamens.com is better than freenode. tau rocks copumpkin: has aids and doesnt know any shit about programming.
22:04:45 <copumpkin> o.O
22:04:54 <ion> k
22:05:14 <copumpkin> wow, I remember getting in a fight with a guy called tau maybe two or three years ago
22:05:23 <copumpkin> haven't spoken to him since
22:05:26 <copumpkin> ಠ_ಠ
22:05:28 <drrckln> what a grudge
22:05:37 <copumpkin> I can't even remember what it was about :)
22:05:42 <ion> hah
22:05:51 <copumpkin> oh, he was spamming a channel on freenode
22:05:56 <copumpkin> I complained to the ircops about him
22:06:03 <xil> copumpkin: he was a huge troll in ##philosophy
22:06:16 <copumpkin> yeah, not hard to believe :)
22:06:21 <ion> It’s nice to see he has grown up and stopped his spammy behavior.
22:06:45 <xil> I miss ##philosophy, but it's a circus
22:22:13 <xil> lol, I just noticed that: "Spam is off topic on freenode"
22:22:43 <otters> tau obviously rocks
22:22:53 <otters> see, he's such a good programmer that he can make spambots
22:24:28 <xil> haha. I think he actually is a programmer. I know he at least made an IRC client, but it wasn't impressive
23:20:18 <rlpowell> cabal(-dev) dependency hell time.  ;(
23:21:30 <rlpowell> Something, somewhere, is including mtl, but I've no idea what; any idea how I find out?
23:23:23 <shachaf> Doesn't -v usually say something about it?
23:23:36 <shachaf> A complete error message would be helpful.
23:24:36 <rlpowell> shachaf: LOL.  Hi.
23:24:43 <rlpowell> (I know him from elsewhere)
23:25:40 <rlpowell> http://fpaste.org/I7V8/ -- errors
23:28:02 <rlpowell> --verbose=3 gives a bunch more output, but not helpful to me; I can paste that too if you like.
23:28:48 <rlpowell> (amusingly, --verbose=4 appears to == no -v at all)
23:32:47 <hckjsnzf> hi, everyone
23:43:35 <amatsu> How would I write a function that takes from a list until a duplicate element is found?
23:45:37 <shachaf> > let foo l = foo' S.empty l; foo' _ [] = []; foo' s (x:xs) | x `S.member` s = [] | otherwise = x : foo' (S.insert x s) xs in foo "abcdabc"
23:45:38 <lambdabot>   "abcd"
23:46:15 <rlpowell> Shanachan: What's S there?
23:46:16 <amatsu> What module is S?
23:46:20 <rlpowell> erm, shachaf
23:46:20 <shachaf> Data.Set
23:46:25 <rlpowell> Ah.
23:46:34 <amatsu> Wouldn't Set order everything?
23:46:45 <shachaf> Yes, but it's just used to keep track of which elements you've seen already.
23:46:58 <amatsu> Oh, that's cool. Thanks!
23:47:00 <rlpowell> shachaf: Could one do it via short-circuiting monadic code, do you think?
23:47:07 <shachaf> rlpowell: What does that mean?
23:49:28 <rlpowell> Well, I'm thinking of the tricks I've seen where >>= over Maybe will basicalyl stop processing when Nothing is reached, and wondering if you could do something similar over the list monad to have it sort of give up and return the current list at the appropriate time.
23:49:36 <rlpowell> It's a very nebulous thought, as you can see. :)
23:51:05 <amatsu> shachaf: Would it be possible to use something like `elem` on a list instead of keeping it in a set?
23:51:28 <shachaf> rlpowell: I can't think of a way to make that work. But maybe you can! You should figure it out.
23:51:46 <shachaf> amatsu: Yes, but it would be less efficient, because you'd need to scan through the entire list each time.
23:51:56 <shachaf> Whereas with a set it's just a logarithmic-time lookup.
23:52:01 <rlpowell> shachaf: When I"m done beating on libraries, maybe.  :)
23:52:17 <amatsu> shachaf: Oh, ok, sounds good.
23:52:55 <shachaf> There's probably a nicer way to express what I wrote but at least it should work.
23:55:57 <shachaf> amatsu: Here's a shorter way of writing the list version:
23:56:04 <shachaf> > (map fst . takeWhile (uncurry notElem) . (zip <*> inits)) "abcdabc"
23:56:06 <lambdabot>   "abcd"
23:56:16 <shachaf> In fact this version is even less efficient. But at least it's short, eh? :-)
