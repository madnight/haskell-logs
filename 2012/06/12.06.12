00:22:59 <adamt> Could anybody with a bit of http-conduit-fu decipher this error (at the bottom): http://hpaste.org/69837 ?
00:24:22 <nand``> I saw HDBC which is like an abstraction layer between different SQL databases, but it has a lot of strange semantics that I'm uncomfortable with, for example string equality checking. Is there something similar that is not an abstraction to existing SQL databases but instead a from-scratch database system aimed towards natively supporting Haskell types?
00:24:30 <nand``> eg. a field of say, Maybe Rational
00:31:28 <hpaste_> Enigmagic annotated “http-conduit trouble” with “http-conduit trouble (annotation)” at http://hpaste.org/69837#a69839
00:32:18 <Enigmagic> adamt: the return statement was in the wrong spot
00:33:43 <dmwit> Wow, well spotted. Enigmagic++
00:35:24 <Enigmagic> one of the few benefits of 5000+ hours of haskell development :P
00:35:42 * hackagebot aivika 0.3 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-0.3 (DavidSorokin)
00:38:09 <OceanSpray> okay I have fixed it
00:38:13 <adamt> Enigmagic: Oh. I see. Thanks :o
00:38:26 <Enigmagic> adamt: np
00:38:28 <OceanSpray> you know, there should be a wiki entry that helps newbs deal with the problem I had
00:38:41 <dmwit> OceanSpray: Well, it's a wiki. Make one! =D
00:38:44 <dmwit> What was your problem?
00:38:48 <nand``> I'm not sure if that's general enough to warrant a wiki article
00:38:54 <adamt> Now, obviously, i would like to query you about $!, at least the name of the operator would be nice :-)
00:38:57 <nand``> seems like a pretty specific error
00:39:13 <nand``> $! = strict apply
00:39:17 <nand``> is what I would call it
00:39:23 <OceanSpray> that is, comment out the impredicative application sites, replace with undefined, use the inferred types to annotate terms, and turn parts of the annotations into the desired rank
00:39:46 <OceanSpray> dmwit, I needed rank 2 types but GHC couldn't infer them for me
00:39:51 <Enigmagic> adamt: just a habit... when you have a function ends in "return x" where "x" might not be evaluated it can save a little time by not allocating a thunk
00:40:42 * adamt just realized $! can be looked on up hoogle
00:41:11 <OceanSpray> I feel like this is one of those places where the new type-errors-deferred-until-runtime flag could be useful
00:41:13 <adamt> Thanks guys, now to delve deeper into the rather scary world of http-conduit.
00:41:15 <nand``> oh, ignore my comment about wiki articles, I was confusing OceanSpray with adamt. I hate this client :)
00:42:29 <OceanSpray> and you know what the really painful part was?
00:42:41 <OceanSpray> it was not enough to simply annotate ONE function
00:43:01 <OceanSpray> I had to annotate SIX functions simultaneously or else the whole thing wouldn't type check
00:43:50 <adamt> OceanSpray: Just annotate everything. :-)
00:44:15 <OceanSpray> that's exactly what I just did
00:44:25 <adamt> I mean, annotate everything, all the time.
00:45:01 <Enigmagic> definitely a good idea with RankN types
00:45:36 <dmwit> hm, can undefined have a type whose kind is not *, e.g. one of these new DataKinds?
00:45:44 <Enigmagic> no
00:45:55 <Enigmagic> undefined needs an OpenKind iirc
00:46:02 <Enigmagic> which is basically *
00:46:14 <dmwit> I wonder if that's a fundamental restriction.
00:46:21 <dmwit> (It certainly seems like a natural one.)
00:46:29 <Enigmagic> without kind annotations it defaults to *
00:46:47 <edwardk> dmwit: nope
00:47:04 * Enigmagic is dicking around with DataKinds right now :(
00:47:05 <edwardk> dmwit: only # and * and their superkind OpenKind have representation
00:48:03 <edwardk> (well, Constraint has a representation you just can't manipulate it directly) ;)
00:48:38 <dmwit> edwardk: I know the guy on the mailing list is a bit obnoxious, but he has asked one vaguely interesting question, which I think I've repeated above: is that a fundamental restriction or an engineering restriction?
00:49:06 <dmwit> Like, is it just that way because that's the most useful, or is it important for the theory somehow as well?
00:49:22 <edwardk> dmwit: well, honestly bounded polymorphism is easy when its a small closed set of types like that, when you go off and allow it to be anything you want it becomes a lot uglier
00:49:48 <dmwit> Oh, I don't want subkinding.
00:49:56 <dmwit> ...I don't think.
00:50:41 <edwardk> i don't see the problem really, you can just make a type/term that are parameterized by your kind such that each type has a singleton inhabitant
00:50:50 <dmwit> Just kind polymorphism, e.g. undefined :: (forall k. forall a :: k. a)
00:51:26 <edwardk> but you have no way to apply that, and now i have to worry about all these other kinds where before if it came up in a term and was polymorphic it wound up defaulted to *
00:51:31 <dmwit> No, I don't see the problem, either. Proxy is a well-known (and fine) solution to the direct question he's asking.
00:52:18 <edwardk> his way a whole lot of strange kinds will show up to people. to what practical end?
00:52:36 <dmwit> ...yes, and singleton types, as well.
00:52:49 <dmwit> And yeah, I definitely don't want (->) to have the weird kind he suggested.
00:53:25 <edwardk> in my little toy haskell type checker i've bastardized the kinds for (,) and (), but thats mostly because of the syntax used for constraint kinds
00:53:49 <edwardk> so in some sense i've already taken a small step down that slippery slope
00:53:57 <edwardk> but at least it doesn't have any impact at the term level ;)
00:53:57 <dmwit> I feel like I don't really understand this answer: "you have no way to apply that" <- apply what?
00:54:50 <edwardk> well, you then need to be able to plumb your singletons through lambdas, etc. so now what is the type of (x -> x) ? does it get a polymorphic type parameterized by the polymorphic boxed kind? why?
00:55:06 <edwardk> er (\x -> x)
00:56:33 <dmwit> Let's let (\x -> x) :: forall a :: *. a -> a, as it is now.
00:56:54 <edwardk> and its a different notion than OpenKind currently presents. OpenKind describes where unboxed values can live, he wants to use it where he wants a completely different kind of (presumably boxed) singleton values to live as well, but thats not quite right, because once it goes polymorphic, you'd want to be slightly less open than OpenKind, since you'd want to preclude things of kind #
00:56:54 <dmwit> The only change to the whole system is the single axiom "undefined :: forall k. forall a :: k. a".
00:56:58 <dmwit> Does something break?
00:57:04 <edwardk> so you'd need an extra level in the lattice already
00:57:18 <dmwit> I don't want to talk about what that guy wants. That guy is clearly wrong.
00:57:45 <edwardk> ok, well, that kind you just gave is wrong =)
00:57:54 <dmwit> Great! Why?
00:57:56 <edwardk> since now i can instantiate undefined to kind * -> * ;)
00:58:03 <edwardk> what the heck does that mean
00:58:13 <edwardk> er as a type of kind * -> *
00:58:16 <dmwit> It's undefined. =)
00:58:19 <edwardk> =P
00:58:31 <Enigmagic> i just want something like "data Foo = Foo" to allow an "instance Bar 'Foo where..." to be in scope without a constraint if all the constructors have instances :)
00:58:32 <dmwit> We can already do wacky things like undefined :: Void. Why should undefined :: [] be so much weirder...?
00:58:39 <edwardk> but i hope you can see the breakdown in the entire kind system
00:59:01 <edwardk> i _like_ knowing that I'm an idiot when i try to apply Maybe Maybe
00:59:16 <dmwit> Maybe Maybe still looks like a kind error to me.
00:59:42 <dmwit> same as "undefined :: forall a. a" doesn't make "() ()" well-typed.
01:00:40 <edwardk> ok, if you start letting it plumb things around like this, now you have inhabitants for every kind. even those like * -> * where you don't want inhabitants
01:00:53 <dmwit> Yes, I'm with you so far.
01:00:58 <edwardk> id undefined :: Maybe is kinda stupid
01:01:33 <dmwit> id :: forall a :: *. a -> a; therefore the type classifying "id undefined" is classified by *
01:01:36 <shachaf> What's the email thread that had the motivation for this?
01:01:36 <TheLemonMan> how am i supposed to combine more results in attoparsec ?
01:01:40 <dmwit> So I don't yet see what stupid thing has happened.
01:01:55 <edwardk> you can make a subsuperkind of BOX for the 'simple' kinds, but then when you start admitting more superkinds things get messy
01:02:16 <dmwit> shachaf: My question is unmotivated. I'm just curious what's bad about this weird thing.
01:02:31 <edwardk> you lose the ability to detect a whole class of errors
01:02:39 <edwardk> its like turning off the occurs check
01:02:44 <edwardk> nothign terrible happens immediately
01:02:53 <edwardk> you just get to typecheck nigh everything
01:03:32 <edwardk> plus i don't even know what untold damagae you'll do to the ability of the kind system to actually figure out the kinds of things
01:03:52 <edwardk> since before if it came 'up' from a term, we always knew it had kind *
01:03:57 <edwardk> (or #)
01:04:15 <edwardk> with the proposed undefined type/kind signature we know nothing about it
01:05:52 <edwardk> because once you allow lambdas to pass things around like that, why is the type argument to Maybe that different?
01:07:49 <edwardk> you assign meaning to a whole host of otherwise meaningless concepts that 99% of the time are gross errors made by newbies this way, but to what end?
01:09:15 <edwardk> you probably can't do any case analysis in this goofy little 'broken pattern' universe of singleton types, they are singletons anyways
01:09:52 <edwardk> 6 months from now i'm sure greg weber will be trying to rally the troops for some broken proposal in this direction that i'm sure will save him a couple of lines of code in a web framework somewhere. ;)
01:11:11 <dmwit> Well, I wouldn't like to see GHC generalize undefined's type in that way without a fair amount of thought. But I would still be interested in seeing a concrete example of something weird that's well-typed or well-kinded because of this.
01:14:32 <edwardk> well i really don't like the fact that whether or not i happen to store something in a data structure would become visible in the kind of my function
01:16:08 <edwardk> in general you can rely on the assumption that unless you really try, anything that arises from the term level has kind *. i think the burden of proof is on whoever wants to try to program with something like that mess that you can do something useful with it =P
01:16:35 <Eduard_Munteanu> Um what's that about?
01:18:25 <dmwit> Eduard_Munteanu: My top-level question is what bad things happen if you allow undefined to be classified by all types, not just types of kind *.
01:18:30 <edwardk> Eduard_Munteanu: dmwit had a bout of temporary insanity ;)
01:18:40 <Eduard_Munteanu> Hm.
01:18:53 <dmwit> I assure you, it's quite permanent. =)
01:19:01 <edwardk> i was afraid of that
01:20:03 <Eduard_Munteanu> Wait, would that be a type-level undefined, or value-level?
01:20:26 <dmwit> value-level
01:20:46 <danr> I get physical aches of thinking about * -> * being inhabited at the value level =/
01:20:47 <dmwit> undefined :: forall k. forall a :: k. a -- to invent some syntax =)
01:22:07 <edwardk> danr: glad its not just me
01:22:38 <Eduard_Munteanu> Well, IDK, I get the same aches thinking of undefined :: Void :D
01:23:06 <Taneb> I'm trying to understand what comonads are for
01:23:18 <edwardk> danr: worse we actually had that bug here for a while, where we screwed up a few places where we needed to tell kind inference that something was coming from the term level, so i'm downright scared of it ;)
01:23:23 <Taneb> Monads are values where you can add a context...
01:23:29 <Eduard_Munteanu> Taneb: that's similar to asking what monads are for, mind
01:23:35 <Taneb> Comonads are values where you can strip a context away
01:23:36 <edwardk> Taneb: looking at lots of things and making small decisions you'll stitch together
01:23:43 <Eduard_Munteanu> And there are different monads and comonads around.
01:24:01 <edwardk> Taneb: have you familiarized yourself with the type signatures involved?
01:24:05 <Taneb> Yes
01:24:07 <Taneb> Ish
01:24:27 <edwardk> ok, so we have extract :: f a -> a, and extend :: (f a -> b) -> f a -> f b, right?
01:24:30 <edwardk> lets try a couple
01:24:32 <Taneb> Yeah
01:24:38 <edwardk> we can make a comonad for (,) e
01:24:42 <edwardk> that is (e,a) partially applied
01:24:49 <Taneb> extract = snd?
01:24:53 <edwardk> extract :: (e,a) -> a
01:24:55 <edwardk> yep
01:25:04 <edwardk> extend :: ((e,a) -> b)  -> (e,a) -> (e,b)
01:25:30 <Taneb> extend f (a, b) = (a, f (a, b))?
01:25:35 <edwardk> yep
01:25:40 <edwardk> @djinn ((e,a) -> b)  -> (e,a) -> (e,b)
01:25:40 <lambdabot> f a (b, c) = (b, a (b, c))
01:25:48 <edwardk> djinn agrees ;)
01:25:52 <Taneb> :)
01:25:55 <edwardk> ok, thats your first comonad
01:26:05 <edwardk> if you want you can view it through duplicate and fmap instead of extend
01:26:12 <edwardk> then duplicate (e,a) = (e,(e,a))
01:26:18 <danr> djinn does not have the same feeling for aestetic choice of variable names though
01:26:22 <edwardk> thats like looking at a monad through fmap and join
01:26:33 <Eduard_Munteanu> Random thought... I wonder if there's anything like a coclosure concept involving comonads.
01:26:48 <edwardk> Taneb: now, this comonad is the 'environment' comonad, which is similar to the reader monad
01:26:51 <Taneb> Hang on, I think my dog wants to be out
01:26:52 <Taneb> Okay
01:26:55 <danr> Eduard_Munteanu: you can make a strict comonad as you can make a lazy monad
01:27:13 <edwardk> you can define ask for it ask :: (e, a) -> e       and local :: (e -> e) -> (e, a) -> (e, b)
01:27:28 <Eduard_Munteanu> danr: hm, how is that related?
01:27:41 <danr> Eduard_Munteanu: I don't know :) What did you mean with a coclosure?
01:28:18 <edwardk> codata and data are independent of monad and comonad, closures aren't anything fundamental mathematically
01:28:20 <Eduard_Munteanu> danr: you can think of monads as closure operators, I wondered if there's anything like a coclosure operator somewhere in algebra / topology
01:28:25 <edwardk> oh
01:28:25 <edwardk> that
01:28:45 <edwardk> sorry got hung up on CS closures ;)
01:28:50 <Eduard_Munteanu> Heh.
01:29:30 <danr> Eduard_Munteanu: Ah, you're talking about topology
01:29:47 <danr> Well the dual of closure surely must be interior...
01:29:56 <edwardk> you're looking for a kernel operator iirc
01:29:56 <Eduard_Munteanu> Actually, I don't know much about topology.
01:30:16 <Eduard_Munteanu> Like ker in algebra?
01:30:17 <danr> But I guess if you take the cotopology you still get a monad (with interior), rather than a comonad
01:30:50 <edwardk> take a galois connection, one composition is the closure operator you're thinking of, which is your monad, the other is the comonad, and is a kernel operator
01:31:15 <danr> wait, I'm talking out of my hat, there is no co-topology
01:31:36 <danr> edwardk: and that is the adjunction these arise from?
01:31:55 <edwardk> hit the wikipedia page on galois connections
01:32:10 <edwardk> the galois connection is an adjunction, hence why they refer to the two halves and the upper and lower adjoint ;)
01:32:38 <edwardk> you have two monotone functions, which play the role of your functors
01:33:06 <Taneb> Back
01:33:27 <Eduard_Munteanu> Yeah, I'm trying to figure if there's a connection to the kernel of a homomorphism.
01:33:28 <edwardk> and the f a <= b <=> a <= g b condition is just restating the definition of an adjunction
01:33:46 <edwardk> Eduard_Munteanu: not sure. been a long time since i thought about them
01:33:57 <edwardk> Taneb: ok, so you got (,) e
01:34:01 <Taneb> Yeah
01:34:06 <edwardk> Taneb: now to up the difficulty level
01:34:09 <Taneb> Oh dear
01:34:27 <edwardk> we can make a comonad for manipulating images
01:34:51 <Eduard_Munteanu> Zippers are comonadic, if you're looking for a more familiar example, and might go with what edwardk is about to explain.
01:35:01 <edwardk> lets take something like data Image a = Image (Array (Int, Int) a) Int Int
01:35:16 <edwardk> i was going to leave off the zipper example for a minute til i got some intuition going here
01:35:30 <Taneb> Okay
01:35:34 <edwardk> so we have an array and an index into the array
01:35:46 <Taneb> Okay
01:35:47 <edwardk> extract (Image a i j) = a ! (i,j)
01:36:27 <edwardk> extend on the other hand takes your array and loops over all the positions, applying your function from (Image a -> b) to the same array with different chosen positions, to make up a new array
01:36:38 <edwardk> and then sets the 'position' of the result back where it started
01:36:57 <edwardk> you can do some neat things with this comonad
01:37:16 <edwardk> for instance we can define blur :: Image Double -> Double
01:37:21 <Taneb> I think I can see how you can do a blur, yeah
01:37:24 <edwardk> and extend it to get a function that blurs an entire image
01:37:59 <edwardk> the easiest way to do that would be to define 4 other operations, like, up, down, left, right, that extract the value of the image in a slightly permuted location
01:38:12 <edwardk> up (Image a i j) = a ! i (j - 1)
01:38:20 <edwardk> (with appropriate clamping or rolling at the edges)
01:38:36 <Taneb> Yeah :)
01:38:37 <edwardk> now if you 'extend up' you'll shift the entire picture
01:38:51 <Taneb> So you do
01:39:24 <edwardk> and you can define blur arr = (up arr + down arr + left arr + right arr) / 4
01:39:28 <edwardk> and extend blur
01:39:36 <edwardk> to get a simple blurred image
01:39:50 <edwardk> where it'll compute the entire blur all at once
01:40:06 <edwardk> you can easily sprinkle some par magic in there as well, and see how you can use this to reason about a form of parallelism
01:40:45 <edwardk> now lets play with a zipper on an infinite list
01:40:49 <edwardk> something like
01:40:58 <edwardk> data Zipper a = Zipper [a] a [a]
01:41:23 <edwardk> (infinite isn't necessary just easy)
01:41:24 <Taneb> extract (Zipper _ a _) = a
01:41:49 <Taneb> Would extend map right the way along both ways?
01:42:02 <danr> edwardk: why did you pick (i,j) as lookup index in extract?
01:42:03 <edwardk> and extend will just shift the entry off the list to the left of you over to the center and push the current focus off to the right, to ompute the next entry over, and vice versa
01:42:19 <edwardk> danr: because i wanted to talk about a 2d image
01:42:30 <danr> edwardk: why not (0,0)?
01:42:35 <edwardk> you can
01:42:41 <danr> ko
01:42:43 <danr> ok
01:42:48 <edwardk> you can do absolute addressing as well, from within your comonadic actions
01:43:18 <edwardk> e.g. its fine to average the entire image color or something in an action
01:43:18 <edwardk> probably pretty inefficient to extend that though
01:44:23 <edwardk> Taneb: a scarier variant on that comonad is http://hackage.haskell.org/packages/archive/comonad-extras/0.1/doc/html/src/Control-Comonad-Store-Zipper.html
01:44:31 <edwardk> zipper :: Traversable t => t a -> Maybe (Zipper t a)
01:44:46 <edwardk> where (Zipper t) is a Comonad
01:45:09 <edwardk> and it lets you slide around inside of the arbitrary traversable input you gave it
01:45:20 <edwardk> before packaging it back up in the same container you supplied in the first place
01:45:35 <edwardk> so if you give me a tree that happens to be traversable, you can use this and move left and right across the leaves
01:45:45 <edwardk> with pos and peek
01:46:23 <edwardk> Taneb: since we're dancing around the Store comonad, these generalize
01:46:48 <edwardk> data Store s a = Store (s -> a) s
01:46:56 <edwardk> i think you can guess extract
01:47:09 <edwardk> and fmap is pretty easy
01:47:27 <edwardk> duplicate is slightly easier to guess than correctly guessing extend though
01:47:34 <edwardk> after that its easy to derive extend
01:47:52 <edwardk> by just mashing together the definition of duplicate and fmap
01:48:13 <edwardk> here all we did was replace the array with a function
01:48:17 <Taneb> duplicate :: Store s a -> Store s (Store s a)
01:48:22 <edwardk> yep
01:49:37 <Taneb> duplicate (Store f s) = Store (\t -> Store f t) s?
01:49:41 <edwardk> also notice that since the array went away the function became a lot easier to modify
01:49:42 <edwardk> yep
01:49:47 <edwardk> you can even eta reduce
01:49:53 <edwardk> duplicate (Store f s) = Store (Store f) s
01:49:58 <edwardk> which is rather pretty
01:50:08 <Taneb> Heh
01:50:32 <edwardk> extend g (Store f s) = Store (g . Store f) s -- isn't quite as elegant
01:50:50 * hackagebot cabal2nix 1.34 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.34 (PeterSimons)
01:50:51 <edwardk> but follows from the definitions of duplicate and fmap
01:50:52 * hackagebot stylish-haskell 0.3.0.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.3.0.0 (JasperVanDerJeugt)
01:51:05 <Taneb> :)
01:51:22 <edwardk> you can define 'get' and 'put' like operations for Store
01:51:37 <edwardk> pos :: Store s a -> s; peek :: s -> Store s a -> a
01:52:04 <edwardk> and you can of course do a modify-like operation peeks :: (s -> s) -> Store s a -> a
01:52:26 <edwardk> when you extend them you 'shift' the entire function
01:53:33 <edwardk> with extend (peek s) overwriting the entire thing with one if its values, but 'peeks f' modifying the 'position' 's' with the function you supplied
01:54:08 <edwardk> one use of these is that you can use the store comonad to define lenses
01:54:21 <Taneb> Yeah, I thought that
01:54:30 <edwardk> given a pair of accessors like: a -> b,   a -> b -> a  you can fuse them
01:54:31 <TheLemonMan> attoparsec continuation style is a bit dumb, theres not function to throw the remaining input into another parser
01:54:35 <edwardk> a -> (b, b -> a)
01:54:36 <edwardk> which is just
01:54:40 <edwardk> a -> Store b a
01:54:59 <edwardk> and the laws of being a store comonad coalgebra are precisely the properties you want a lens to satisfy if your name isn't dmwit
01:55:43 <edwardk> they translate to 'you get what you put' 'putting what you get doesn't change anything' and 'putting is idempotent'
01:56:06 <Taneb> idempotent?
01:56:35 <edwardk> if you put twice, its the same as putting once
01:56:38 <merijn> Taneb: idempotent operations are operations that have the same result regardless of how often they're executed
01:56:44 <Taneb> Oh, cool
01:56:47 <edwardk> in reality the law is more that the second put wins
01:56:56 <merijn> In general any pure function is idempotent (by definition)
01:57:05 <edwardk> we can make another comonad
01:57:12 <edwardk> data Stream a = a :- Stream a
01:57:25 <merijn> It's a fairly useful notion when speaking of remote procedure calls or networking protocols
01:57:45 <edwardk> with stream, extract (a :- _) = a
01:57:48 <Taneb> edwardk, is that like a list that's forced to be infinite?
01:58:10 <edwardk> yeah, you can make one out of a list that is merely required to be non-empty as well
01:58:34 <edwardk> data NonEmpty a = a :| [a] -- is a comonad i use a lot (though its not nicely structurally recursive in this form)
01:58:52 <edwardk> data NonEmpty a = Last a | a :- NonEmpty a
01:58:57 <edwardk> is more structural
01:59:32 <Taneb> extend f a@(_ :- as) = f a :- extend f as ?
01:59:39 <edwardk> yep
01:59:42 <Taneb> :)
01:59:51 <danr> edwardk: duplicate in terms of repeat?
01:59:52 <edwardk> notice that the result for each element can see the entire tail of the stream
02:00:13 <edwardk> duplicate w@( :- as) = w :- duplicate as
02:00:21 <edwardk> not repeat
02:00:27 <edwardk> the laws fail if you try to repeat
02:00:36 <danr> oh so it's tails rather
02:00:45 <edwardk> pretty close
02:00:47 <edwardk> no []
02:00:52 * hackagebot postgresql-simple 0.1.4.3 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.1.4.3 (LeonSmith)
02:00:54 * hackagebot HUnit 1.2.4.3 - A unit testing framework for Haskell  http://hackage.haskell.org/package/HUnit-1.2.4.3 (RichardGiraud)
02:00:56 <danr> yeah modulo nils :)
02:01:01 <edwardk> but for the infinite case they coincide because you don't get there
02:01:14 <edwardk> with the NonEmpty stream type you have a few design choices
02:01:21 <edwardk> you can make a causal or an anti-causal stream
02:01:33 <edwardk> that is you can decide whether you want to be able to see effectively, inits, or tails
02:01:53 <edwardk> with Stream we only had one direction that extended infinitely
02:02:41 <edwardk> so we HAD to choose anticausality
02:02:59 <edwardk> http://hackage.haskell.org/packages/archive/streams/0.8.2/doc/html/Data-Stream-Future.html
02:03:06 <edwardk> gives a boring stream with Last
02:03:33 <edwardk> http://hackage.haskell.org/packages/archive/streams/0.8.2/doc/html/Data-Stream-Future-Skew.html sexes it up a bit by using a skew binary random access list, so you can jump downstream in logarithmic time
02:03:33 <Taneb> And that can choose?
02:03:44 <edwardk> yeah
02:03:52 <edwardk> because either gives rise to a valid comonad
02:04:02 <edwardk> you'd need to pick one for each concrete data type
02:04:28 <edwardk> http://hackage.haskell.org/packages/archive/streams/0.8.2/doc/html/Data-Stream-Infinite.html provides what i called 'Stream' above
02:04:46 <edwardk> and http://hackage.haskell.org/packages/archive/streams/0.8.2/doc/html/Data-Stream-Infinite-Skew.html makes a skew binary random access list out of that as well ;)
02:05:17 <edwardk> mostly relevant because the Infinite examples i gave there permit a Monad
02:06:15 <edwardk> those give you a bit better intuition for what comonads are useful for?
02:06:22 <Taneb> Yeah, I think so
02:06:23 <Taneb> Thanks
02:06:37 <edwardk> the zipper example data Zipper a = Zipper [a] a [a] is neat because you can use it for cellular automata
02:06:54 <edwardk> you start with a state, and apply a transition function, and it'll emulate a 'step' of the automaton
02:07:19 <edwardk> extend takes the local decision about the next state and makes that information global
02:07:37 <edwardk> you can see the same thing on the Image type, where its easy to encode the rules of say, conway's game of life
02:07:43 <edwardk> and then just extend that action
02:07:59 <Taneb> :)
02:08:07 <edwardk> i use a lot of comonads in scala
02:08:19 <edwardk> scala tends to suck pretty terribly at working with monad transformers
02:08:34 <edwardk> but every monad transformer is given rise to by a comonad, and comonads encode nicely in scala ;)
02:08:46 <edwardk> well
02:08:48 <edwardk> actually
02:08:54 <edwardk> every comonad gives rise to a monad transformer
02:09:06 <edwardk> there exist monad transformers that don't have a clean comonadic analogue that i know of
02:09:51 <edwardk> fun exercise: if w is a comonad then w (a -> r) -> r is a monad.
02:10:03 <edwardk> and so is forall r. w (a -> r) -> r
02:10:22 <appsee> hey guys, anyone know what OS use JaffaCake on machine when developing GHC?
02:10:45 <JaffaCake> Linux mainly
02:10:46 <t7> i cant parse that sentence
02:10:47 <lambdabot> t7: You have 1 new message. '/msg lambdabot @messages' to read it.
02:10:52 <edwardk> that latter one is kind of neat because you can lift the pos/peek operations above from store into a get/put for state
02:11:08 <edwardk> and the ask/local from env into ask/local for reader, etc.
02:11:10 <appsee> JaffaCake: thank very much for answer and your work
02:11:19 <JaffaCake> np :)
02:11:48 <edwardk> ack, if jaffacake is awake its definitely time for me to get some sleep
02:12:24 <Taneb> Hmm
02:12:44 <edwardk> taneb: both of those are rather advanced examples
02:13:07 <edwardk> Taneb: you might find the types in comonad-transformers to be more interesting now, especially if you are familiar with the mtl
02:13:36 <edwardk> in particular they show how you can make composite comonads just like you can make composite monads
02:14:19 <edwardk> instead of lifting code from a simpler monad to a more complex one, you lower code from a more complex comonad into something with less structure
02:15:14 <Taneb> Okay, I'll take a look at that
02:16:09 <edwardk> another fun example is that if f is any functor, data Cofree f a = a :< f (Cofree f a) is a comonad
02:16:37 <edwardk> and the implementation isn't appreciably harder than for Stream
02:16:45 <edwardk> (Stream ~ Cofree Identity)
02:16:59 <edwardk> while Cofree Maybe ~ NonEmpty
02:17:13 <edwardk> and Cofree [] ~ Tree from containers
02:17:41 <Taneb> Wow
02:18:13 <danr> edwardk: ah, rose trees? cool!
02:18:21 <edwardk> You can also assemble types for Moore machines using Cofree
02:18:49 <edwardk> Cofree ((->) b) a = a * (b -> a * (b -> …))
02:19:04 * quicksilver thought edwardk said "you can also assemble types for more machines using coffee".
02:19:15 <quicksilver> which, to be honest, made more sense than what he *actually* said.
02:19:24 <Taneb> :D
02:19:29 <danr> quicksilver: haha ^^
02:19:32 <edwardk> gives you the current state valuation a, and a transition function that takes an input 'b' and gives you a new valuation and transition function
02:19:37 <edwardk> quicksilver: that works too =)
02:20:15 <edwardk> data Moore b a = Moore b (a -> Moore b a)
02:20:34 <edwardk> Moore b ~ Cofree ((->) b)
02:21:03 <edwardk> those come up when you start kicking around theoretical underpinnings for iteratees
02:21:53 <edwardk> if you 'rotate' that definition slightly you can get Mealy machines
02:22:00 <Taneb> You've opened up a whole new world to me, thank you.
02:22:11 <edwardk> newtype Mealy b a = Mealy (a -> (b, Mealy b a))
02:22:12 <quicksilver> An edwardk is a machine for converting coffee into subtly powerful but entirely undocumented libraries on hackage.
02:22:38 <edwardk> documentation gets me users, users distract me from writing libraries
02:22:42 <edwardk> you can document when i'm dead
02:23:33 <merijn> quicksilver++
02:23:52 <merijn> Ha, jokes on you. data-lens is mostly usable without docs!
02:24:15 <edwardk> jokes on roconnor, i handed off maintainership when people started using it for productive stuff
02:24:21 <merijn> After properly rewiring your brains and complaining to roconoor to fix the versions :p
02:24:50 <merijn> (Unrelated, is it "joke's on" or "jokes on"? I'm thinking the latter)
02:24:57 <edwardk> i do maintain a few things that remain well documented in spite of me
02:25:23 <Taneb> (merijn, former. "The joke is on you"
02:25:26 <Taneb> )
02:26:16 <edwardk> the jokes on me are terrible. now i've forced it to work both ways ;)
02:28:14 <merijn> Although he didn't appreciate my meta suggestion of having a composite-lens lens. (i.e., "(b -> Lens a c) -> Lens a b -> Lens a c". Man, haskell is rendering me completely unintelligible to non-haskell people)
02:28:55 <edwardk> good luck passing the laws with that ;)
02:29:55 <edwardk> i mean, maybe you could pass dmwit's laws
02:30:03 <edwardk> but none of the real laws ;)
02:30:13 <merijn> Why wouldn't it pass the laws? You can trivially implement it using the basic lens operators
02:31:00 <merijn> Which, I'm assuming, follow the laws
02:31:16 <edwardk> need to check the problem with that when i'm more conscious
02:31:52 <Taneb> Hmm
02:32:02 <Taneb> Cofree Proxy is like Identity
02:32:06 <edwardk> given a b you can get a lens from a to c, but that lens may overlap the b
02:32:15 <quicksilver> I don't think the laws care because once you've constructed the Lens a c you can't get back to the 'b' in any sense
02:32:28 <edwardk> basically you can't take a Lens a b, Lens a c and get Lens a (b,c)
02:32:41 <quicksilver> all you have left is a Lens a c and that means you can only change the 'c' bit
02:32:48 <edwardk> and this runs afoul of the same problems that render that incorrect
02:33:02 <quicksilver> hmm
02:33:11 <quicksilver> but if you changed the c bit in a way which changed the b...
02:33:18 <edwardk> exactly
02:34:04 <merijn> How would the b be changed by the c? Or are you thinking of custom lenses (rather than just trivial ones that map one-to-one with record fields)
02:34:14 <edwardk> consider composing fstLens && fstLens to get Lens (a,b) (a,a) using the simpler a (b,c) lens
02:34:38 <edwardk> now you can't pass the lens laws there aren't two 'a' sized holes
02:35:27 <edwardk> in general its not safe in a lens to compose two lenses that may touch the same part of the input
02:35:40 <edwardk> because once you set it in one you break it for the other
02:38:16 <edwardk> in your Lens a c, if your write back to the c changes the b you have a problem. remember you have a lens law that says you have to be able to 'get what you put'
02:38:44 <dreixel> is there a command to get the free theorem of a type from lambdabot?
02:38:50 <edwardk> but after you changed the thing viewed by your original Lens a b, your combinator may choose a different 'c', violating that law
02:39:29 <edwardk> @free m :: (a -> b) -> [a] -> [b]
02:39:29 <lambdabot> g . h = k . f => $map g . m h = m k . $map f
02:39:44 <edwardk> where $map is the structural fmap
02:40:28 <Taneb> Cofree (Const a) is like (,) a
02:40:34 <edwardk> yep
02:40:49 <edwardk> disturbing how many there are, no?
02:40:53 <womb> Hi!
02:40:58 <Taneb> Yeah
02:41:07 <Taneb> By induction, I'd suppose there's an infinite amount
02:41:13 <edwardk> =)
02:41:23 <dreixel> thanks
02:41:26 <Taneb> As every comonad is a functor
02:41:29 <edwardk> i use cofree comonads to annotate syntax trees
02:41:36 <aleator_> can you catch <<loop>>'s as in let x = x in x during runtime somehow?
02:41:43 <dreixel> @free t :: f (g a) -> g (f a)
02:41:43 <lambdabot> Extra stuff at end of line
02:41:59 <edwardk> aleator_: sometimes
02:42:09 <dreixel> uh
02:42:11 <Taneb> Cofree (Cofree Proxy) is Cofree Identity is Stream
02:42:32 <edwardk> @free t :: f [a] -> [f a]
02:42:32 <lambdabot> Extra stuff at end of line
02:42:38 <edwardk> interesting
02:42:42 <edwardk> doesn't like that one =)
02:42:53 <dreixel> can't write it differently, though
02:42:55 <edwardk> i can never remember the finicky syntax of that command
02:43:00 <Taneb> ...sequence?
02:43:03 <edwardk> you want a distributive law's free theorem?
02:43:15 <dreixel> yes
02:43:20 <dreixel> http://linux.tcs.inf.tu-dresden.de/~voigt/ft/ is down :P
02:43:49 <dreixel> Taneb: it's not sequence, as there is no monad constraint
02:43:52 <aleator_> edwardk: Do you know how, and in which cases?
02:43:59 <Taneb> Oh, okay
02:44:30 <quicksilver> aleator_: there are no guarantees.
02:44:43 <dreixel> @free length
02:44:44 <lambdabot> length = length . $map f
02:44:47 <quicksilver> aleator_: however if it does produce a <<loop>> then you can catch it with GHC's normal exception catching.
02:44:48 <dreixel> @free sequenceA
02:44:49 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `sequenceA'\n\n"
02:45:12 <edwardk> aleator_: you can catch http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#t:NonTermination
02:45:22 <edwardk> aleator_: use the combinators in Control.Exception for it
02:45:41 <edwardk> aleator_: its not guaranteed to fire under all forms of non-termination though
02:45:46 <aleator_> quicksilver: Ah. Thanks!
02:46:02 <edwardk> e.g. (unsafeCoerce <*> unsafeCoerce) (unsafeCoerce <*> unsafeCoerce) never enters a blackhole
02:46:25 <quicksilver> edwardk: it is, in fact, guaranteed not to fire under all forms of non-termination ;)
02:46:28 <aleator_> quicksilver: Of course. But I'm trying to embed interpreters on my course page and would wish to retain most of the ghci functionality with it, so catching these is nice.
02:46:32 <edwardk> quicksilver: =)
02:46:46 <quicksilver> at least for one reading of "all under a negative" which is ambiguous in english.
02:47:13 <edwardk> aleator_: i think mu-eval or some of these others have ways to bound evaluation time
02:47:14 <aleator_> <<loops>> are rare, but it they can be quite impressive examples
02:47:24 <edwardk> http://hackage.haskell.org/package/mueval
02:47:25 <quicksilver> yes, they fork a separate process
02:47:29 <quicksilver> and use OS mechniams
02:47:35 <edwardk> yep
02:47:37 <quicksilver> rlimits, timers, etc.
02:47:50 <aleator_> edwardk: I already have bounded time using ghc-api and a separate process in a sandbox
02:47:53 <edwardk> but if you are planning on exposing ghc to the outside world like that you may want to try it
02:48:12 <edwardk> aleator_: you may want to check for the other things they do
02:48:27 <edwardk> because for a long time in here it used to be a game to find novel ways to crash lambdabot
02:48:49 <edwardk> and mueval is a port of the old lambdabot code
02:49:02 <edwardk> so its been tried under fire ;)
02:50:45 <aleator_> edwardk: I did actually. I found mu-eval to be a bit off target for me. But it is nice to read. So many safeguards
02:50:53 <edwardk> fair nuff
02:50:58 <edwardk> just so long as you know its out there
02:51:03 <edwardk> anyways, sleep time
02:51:05 <edwardk> later all
02:51:12 <aleator_> However -XSafe hopefully does many things done there,
02:54:10 <quicksilver> -XSafe does nothing at all about resource consumption
02:54:12 <quicksilver> space or time
02:54:38 <quicksilver> and if you permit IO, then nothing at all really.
02:55:13 <Taneb> Cofree IO...
02:55:39 <Taneb> a :< IO (Cofree IO a)
02:55:50 <aleator_> quicksilver: I don't permit IO and I have timelimits + rlimit in place.
02:56:03 * quicksilver nods
02:56:12 <roconnor> merijn: some lens functions are not safe, such as Lens and lens
02:56:22 <aleator_> Doing this safely is wee bit hard. :)
02:56:30 <roconnor> I'm thinking of hiding these functions in a scarily named module.
02:56:50 <roconnor> merijn: well, the are safe in the "Safe Haskell" sense of safe.
02:56:57 <roconnor> more like they are unchecked.
02:56:59 <quicksilver> Data.Lens.Godzilla
02:57:11 <roconnor> Data.Lens.Pandora
03:21:00 * hackagebot multirec 0.7.2 - Generic programming for families of recursive datatypes  http://hackage.haskell.org/package/multirec-0.7.2 (AndresLoeh)
03:27:27 <merijn> Data.Lens.OhGodHowDidThisGetHereImNotGoodWithComputers
03:45:17 <Peaker> Making an expression-with-explicit-loop type to represent infinite types is ruining all of my fold functions/etc :(
03:47:34 <Peaker> Every handling of expressions must take into account that there might not be a sub-expression but a back-reference to some part of the expression (forming an infinite type).. I wonder if there's a better way to do this
03:51:23 <hpc> write combinators on Mu and use those
03:52:05 <Peaker> the representation of the infinite type itself is not an infinite type.. It uses an explicit constructor to "break the loop"
03:59:45 <Peaker> man, how do people debug without tracePutStrLn ? :)
04:00:02 <Peaker> tracePutStrLn str = trace str $ return ()
04:03:26 <visof> Hello
04:03:57 <Peaker> howdy
04:07:53 <Peaker> yay, bottle no longer crashes with infinite types :)
04:12:09 <ssbr_> is it feasible to write a library in haskell that is usable from C?
04:12:31 <hpc> yes
04:12:41 <ssbr_> hpc: I'd like to know more!
04:12:43 <hpc> you have to start the haskell RTS first though
04:12:48 <hpc> on the C side of things
04:12:50 <hpc> uh
04:12:57 <ssbr_> hpc: ehhhhh, but can multiple different libraries do this, or is this global?
04:13:05 <hpc> there's a page on the haskellwiki that covers it
04:13:11 <hpc> it's a language thing, part of the FFI
04:13:13 <ssbr_> like it doesn't really work if it makes the library incompatible with any other library written in haskell
04:13:22 <ssbr_> (this is how ocaml works :< :<)
04:14:11 <hpc> if i am reading that right, haskell's FFI doesn't do that
04:14:22 <hpc> and you are free to import whatever you want, haskell-side
04:14:32 <ssbr_> where is this page?
04:14:34 <hpc> and other libraries are free to import your stuff
04:14:40 <hpc> i forget
04:14:46 <ssbr_> hpc: my issue is, what if there's another C library written in haskell?
04:14:48 <Eduard_Munteanu> @google calling haskell from c
04:14:50 <lambdabot> http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
04:14:50 <lambdabot> Title: Calling Haskell from C - HaskellWiki
04:14:59 <ssbr_> is the RTS global? if so, they'd both initialize it, and maybe bad things result (or maybe not)
04:15:15 <hpc> oh, there :D
04:15:31 <hpc> oh, that i don't know
04:15:53 <ssbr_> ... you have to compile your C code with ghc?
04:16:25 <ssbr_> no gcc support? Unsure if this is workable (e.g. could I make haskell libraries importable to Python? I don't know)
04:16:41 <Eduard_Munteanu> ssbr_: it probably calls through to GCC
04:17:26 <ssbr_> So what's the sane way to handle multiple libraries possibly using haskell backends?
04:18:00 <hpaste_> mikeplus64 pasted “threading problem?” at http://hpaste.org/69845
04:18:03 <Eduard_Munteanu> I'm unsure that's a problem, unless perhaps you want to pass different rtsopts
04:18:22 <ssbr_> I don't know if it's a problem. It sounds like it'd be one
04:18:24 <mikeplus64> any idea of what's causing the above not to work?
04:18:27 <mikeplus64> the above paste that is
04:20:29 <ssbr_> Eduard_Munteanu: the docs imply that this is totally fine (each library can have separate init / deinit functions)
04:20:51 <ssbr_> um, but all the example exported functions don't do IO :(
04:21:54 <hpc> you should be able to export IO actions in exactly the same way you export pure stuff
04:22:16 <hpc> or if not, unsafePerformIO perhaps
04:22:55 <ssbr_> I'm not really solid on how I export pure stuff, either. Magic foreign export declaration.
04:23:33 <ssbr_> Well, I can experiment
04:23:40 <ssbr_> hum, the docs are lying
04:24:01 <ssbr_> if hs_exit quits all haskell threads, it is not safe as a module_deinit function. So those cannot both be true, but the docs claim or imply both
04:24:06 <ssbr_> Very suspicious :/
04:24:33 <hpc> afaict, the foreign export declaration just tells ghc to use C conventions when generating object code for that function
04:26:35 <ssbr_> Truthfully I'm tempted to use something meant for C interop, like ATS or Idris
04:26:46 <ssbr_> unfortunately they're also designed for systems programming, and who wants to do that? Bah
04:28:29 <mikeplus64> if anyone here is a threading person can you (pretty please) yell at me about what i'm doing wrong at http://hpaste.org/69845
04:30:55 <RichyB> mikeplus64, what happens if you replace both of those forkOS calls with forkIO?
04:31:07 <mikeplus64> RichyB: nothing
04:31:12 <mikeplus64> that i can see
04:31:14 * hackagebot BNFC-meta 0.3.0.3 - Deriving Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.3.0.3 (JonasDuregard)
04:31:28 <Saizan> mikeplus64: ghc threading is not completely preemptive, you can't killThread a thread that never calls the RTS back
04:31:28 <RichyB> Give it a third capability? -N3.
04:31:47 <RichyB> What Saizan said too.
04:32:00 <mikeplus64> what does it mean for it to be completely preemptive?
04:32:02 <RichyB> You can only kill threads that perform hit the GC.
04:32:11 <mikeplus64> ah
04:32:14 <Saizan> mikeplus64: that's why e.g. mueval uses another whole process for this
04:32:43 <RichyB> Pre-emptive as in "you can manipulate the other thread/process regardless of what it's doing".
04:33:14 <RichyB> GHC's threads are cooperative but they emulate preemptiveness for many but not all use cases.
04:33:35 <mikeplus64> if I were to do something silly in that thread, like putMVar some_other_mvar (), would that allow ghc to kill it later on?
04:33:49 <RichyB> You really need a second process so that you can use your OS's process control and murdering facilities, which are much better than its thread murdering facilities.
04:35:00 <mikeplus64> going to see if i can hack my way around these limitations first :)
04:35:43 <RichyB> The most likely result of trying that is that you're going to become really intimately familiar with the RTS.
04:41:33 <merijn> RichyB: Couldn't you just throw an exception at the relevant thread?
04:42:25 <quicksilver> no.
04:42:37 <quicksilver> as RichyB said "You can only kill threads that perform hit the GC"
04:42:52 <RichyB> *perform allocation, and hit the GC.
04:42:53 <quicksilver> the funny thing is that OS threads which GHC uses in -threaded are, in fact, pre-emptive.
04:43:07 <quicksilver> but despite them being pre-emptive there is no facility to kill them.
04:43:29 <RichyB> merijn, you can *throw* the exception at the relevant thread, but the relevant thread won't *receive* it unless it performs an allocation.
04:44:21 <quicksilver> there is a reason that mueval uses a separate OS process.
04:44:25 <RichyB> Usually it's not a problem; try writing a Haskell program of any size which doesn't allocate and then tell me about the experience, but you *can* create them.
04:44:36 <merijn> :p
04:45:42 <quicksilver> it's not so much creating an entire program which doesn't allocate
04:45:54 <quicksilver> as accidentally creating a tight loop which doesn't
04:46:05 <quicksilver> (and takes potentially arbitrarily long)
04:46:29 <Peaker> I thought GHC fixed that?
04:46:33 <quicksilver> even that is pretty hard but, ironically, might become easier as code generation backends and optimisations get better
04:48:04 <Peaker> do pthreads have a way of being forcibly killed?
04:49:00 <exlevan> is there a standard function like (a -> b) -> ((a, a) -> (b, b)) ?
04:49:05 <quicksilver> Peaker: yes.
04:49:19 <quicksilver> standard caveats about violating your own invariants apply, of course.
04:49:53 <quicksilver> it is almost impossible to write a substantial threaded application such that killing a thread asynchronously isn't a really very very very bad idea.
04:50:14 <Peaker> well, if you control all of the low-level memory manipulations (as in the RTS) it might be possible?
04:50:15 <quicksilver> exlevan: f *** f
04:50:24 <quicksilver> exlevan: or join (***) if you like being cute/pointfree
04:50:36 <quicksilver> Peaker: no, I'm talking about high level invariants.
04:50:41 <quicksilver> your own program logic.
04:51:02 <Peaker> quicksilver, an unrestricted IO thread is a problem, but if it is just a computational one...
04:51:06 <quicksilver> the typical programming model is that subroutines start with your mutable state consistent, perform some changes, and finish with it consistent.
04:51:07 <Peaker> (pure one)
04:51:13 <quicksilver> if it's pure then its' fine, yes.
04:52:03 <Peaker> well, if you have a thread for its IO effects and you forcibly kill it, and all your races are potential IO states the thread was killed in, I think it would probably be manageable in most cases
04:52:29 <Peaker> A thread that streams IO inputs from one place to IO outputs in another place, probably can be killed and then the stream can be restarted or such
04:52:54 <Peaker> IMO the huge challenges of forcibly killing a thread are in the low-level memory manipulation states, not the high-level ones
04:53:44 <Peaker> I think making the low-level code accessing memory be capable of handling that is probably going to be more expensive than simply adding a penalty of making sure loops aren't too tight (by inserting yield points)
04:54:57 <quicksilver> we're talking at cross purposes.
04:55:11 <quicksilver> I wasn't talking about how hard it would be for the haskell RTS to handle this.
04:55:30 <quicksilver> I was talking about how bad idea it is in general for any process - in any language - to kill threads genuinely asychronously.
04:55:57 <quicksilver> and, yes, I do agree, no harm is done if the thread is quite pure.
04:57:22 <Peaker> I think it is a common style in Haskell to have threads that are almost all quite pure
04:57:36 * quicksilver agrees
05:02:36 <kopi> Haskell
05:02:36 <kopi> On a warm Saturday afternoon, sitting by the pool with a margarita, you casually sit up from your chaise lounge chair, reach over and pick up a gun, aim at your foot, and lazily pull the trigger.
05:02:36 <kopi> You shoot yourself in the foot very elegantly, and wonder why the whole world isn't shooting itself this way.
05:02:36 <kopi> You spend several hours creating a new copy of the Universe which is identical to the existing one except your foot has a hole in it. You then hear that it can be done more elegantly with Dyadic Functile Hyper-Arrows, but the very act of reading some of the included sample code causes one of your metatarsals to explode.
05:03:20 <kopi> http://www.toodarkpark.org/computers/humor/shoot-self-in-foot.html
05:04:52 <Nimatek> Haha.
05:11:52 <sunwi> > map (+1) [1..100]
05:11:54 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
05:12:49 <albertlee> map (*2) [1..50]
05:12:58 <albertlee> > map (*2) [1..50]
05:12:59 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
05:13:16 <sunwi> zipWith ((return .) . (:)) "hlowrd" "el ol "
05:13:24 <sunwi> > zipWith ((return .) . (:)) "hlowrd" "el ol "
05:13:26 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:13:26 <lambdabot>         against inferred ty...
05:13:42 <albertlee> -_-
05:14:24 <sunwi> @pl \x y -> x:[y]
05:14:24 <lambdabot> (. return) . (:)
05:14:36 <sunwi> > concat $ zipWith ((return .) . (:)) "hlowrd" "el ol "
05:14:38 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:14:38 <lambdabot>         against inferred ty...
05:14:53 <sunwi> > concat $ zipWith ((. return) . (:)) "hlowrd" "el ol "
05:14:55 <lambdabot>   "hello world "
05:16:31 <Peaker> @pl \x y -> [x,y]
05:16:31 <lambdabot> (. return) . (:)
05:17:51 <exlevan> > concat . transpose $ ["hlowrd", "el ol "]
05:17:53 <lambdabot>   "hello world "
05:23:39 <favonia> @pl concat $ zipWith ((return .) . (:))
05:23:39 <lambdabot> join (zipWith ((return .) . (:)))
05:23:53 <Peaker> which language reads vertically?
05:24:17 <Peaker> @ty concat $ zipWith ((return .) . (:))
05:24:18 <lambdabot>     Couldn't match expected type `[[a]]'
05:24:18 <lambdabot>            against inferred type `[a1] -> [[a1]] -> [m [a1]]'
05:24:18 <lambdabot>     In the second argument of `($)', namely
05:24:37 <Peaker> @ty zipWith ((return .) . (:))
05:24:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> [[a]] -> [m [a]]
05:26:14 <quicksilver> Peaker: traditional japanese?
05:26:37 <Peaker> @ty zipWith ((. return) . (:))
05:26:38 <lambdabot> forall a. [a] -> [a] -> [[a]]
05:26:52 <Peaker> sunwi/favonia: You changed (.return) to (return.)
05:27:05 <Peaker> oh, sorry, you saw that already :)
05:27:12 <Peaker> (missed the fix above)
05:27:28 <Peaker> well, then   let traditionalJapanese = concat . transpose
05:27:29 <arnsholt> Peaker: Mongolian script is written vertically
05:28:09 <favonia> Peaker: Chinese at least can be written in both ways. Actually vertical writing was the traditional way.
05:29:28 <favonia> and the order of columns is from right to left
05:33:04 <favonia> Peaker: I mean, you need to reverse the lists first :P
05:34:52 <quicksilver> or hold your combinators up to a mirror.
05:35:07 <Peaker> favonia, heh
05:36:35 <nobdraisentone> How can I get `Map a b' value from `Map a (IO b)'?
05:37:03 <Peaker> @hoogle Map a (IO b) -> Map a b
05:37:03 <lambdabot> No results found
05:37:13 <Peaker> @ty Data.Map.mapM
05:37:14 <lambdabot> Not in scope: `Data.Map.mapM'
05:37:29 <favonia> nobdraisentone: you can have IO (Map a b), but not Map a b (unless you cheat)
05:37:48 <Peaker> IO (Map a b) lends itself to binding a variable to Map a b
05:38:25 <nobdraisentone> IO (Map a b) will be great too
05:38:43 <Peaker> nobdraisentone, Data.Traverseable.sequenceA
05:38:55 <Peaker> @type Data.Traversable.sequenceA
05:38:56 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
05:39:05 <Peaker> t = Data.Map,  f = IO
05:39:16 <Peaker> oops, t = Map a
05:39:32 <Peaker> and a = b :)
05:39:47 <Peaker> so: Map a (IO b) -> IO (Map a b)
05:39:48 <hpaste_> mhwombat pasted “Conduit problem after upgrade” at http://hpaste.org/69848
05:40:09 <favonia> nobdraisentone: in intuition, you run each command within the input Map, and collect all outputs to construct the new Map
05:40:46 <mhwombat> After I upgraded to the newest Haskell Platform, this code no longer compiles. Can anyone help?
05:40:48 <favonia> nobdraisentone: sequenceA does all of these for you
05:46:37 * hackagebot bkr 0.1.2 - Backup utility for backing up to cloud storage services (S3 only right now)  http://hackage.haskell.org/package/bkr-0.1.2 (MichaelSmietana)
05:50:37 <saml> how can I write graph database?
06:00:04 <mhwombat> Can anyone help with this compilation error: http://hpaste.org/69848 ?
06:10:11 <byorgey> mhwombat: I don't know much about conduit but maybe I can help.  It looks like in the most recent version of cereal-conduit, sinkGet does not have a MonadException constraint, whereas in older versions it does.
06:10:20 <byorgey> mhwombat: what version of cereal-conduit do you have installed?
06:11:01 <byorgey> in the newest version of cereal-conduit, sinkGet has a MonadThrow constraint, and indeed ResourceT has a MonadThrow instance
06:11:19 <byorgey> so it looks to me like you have an older version of cereal-conduit which does not work with the latest version of conduit
06:12:44 <mhwombat> I have cereal-conduit 0.0.6.1 installed
06:12:57 <byorgey> right, that is too old I think
06:13:06 <byorgey> try installing cereal-conduit-0.5, which is the latest version
06:14:32 <byorgey> but take my advice with a grain of salt, I base this advice just on looking through the Haddock documentation on Hackage, so if you find anyone who actually knows about conduit and/or cereal-conduit, listen to them instead =)
06:14:41 <mhwombat> Woohoo! Thank you, Brent, I've been struggling with that one for hours.
06:14:47 <byorgey> did it work?
06:14:53 <mhwombat> All fixed now, yes!
06:14:56 <byorgey> yay!
06:15:04 <identity> #haskell heroes strike again!
06:15:54 <byorgey> mhwombat: hmm, do we know each other?  Just wondering since you used my real name (though I guess it's not hard to find, and you're welcome to use it even if we've never met =)
06:21:36 <arnthor> Hi, I am trying to find some example code that uses Data.Graph so I can see how to build a graph
06:21:41 <arnthor> any pointers
06:22:02 <arnthor> or links even?
06:22:08 <fmap> `building graphs' section in the documentation?
06:22:39 <fmap> http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Graph.html#g:3
06:23:32 <arnthor> Yes I was looking at that but I could not get buildG to do anything, I am a complete beginner.
06:24:17 <arnthor> what I was thinking was that buildG takes in a list of edges and edges contains two vertexes like (Int,Int)
06:24:23 <arnthor> am i on the right path?
06:24:31 <fmap> yes
06:24:53 <fmap> `buildG (1,3) [(1,2), (2,3), (3,1)]' as simple example
06:25:47 <fmap> which would build graph 1 → 2 → 3 → 1
06:26:58 <arnthor> I feel like such a noob, thank you so much!
06:27:08 <fmap> yw
06:36:48 <Nimatek> > read "11111111111111111111111111" :: Int
06:36:49 <lambdabot>   -8480526731661512249
06:37:23 <shapr> two's complement?
06:38:08 <augur> blimey, some people get rather upset about some things.. http://www.reddit.com/r/haskell/comments/uwrb7/why_do_haskell_programmers_hate_parentheses/c4zhwrt
06:38:10 <Nimatek> Just an overflow.
06:38:25 <byorgey> > 11111111111111111111111111 `mod` (2^63)
06:38:27 <lambdabot>   742845305193263559
06:38:34 <byorgey> > -8480526731661512249 `mod` (2^63)
06:38:35 <lambdabot>   -8480526731661512249
06:38:48 <Nimatek> > read "12341212312321312321312" :: Int
06:38:49 <lambdabot>   340527009622290208
06:38:49 <byorgey> err
06:38:51 <byorgey> > (-8480526731661512249) + 2^63
06:38:52 <lambdabot>   742845305193263559
06:42:07 <mhwombat> byorgey: You don't know me, but I'm sure everyone in Haskell-land knows you. You're famous!
06:42:22 <byorgey> haha, fair enough =)
06:42:49 <byorgey> well, perhaps we will have the pleasure of actually meeting someday
06:43:11 <mhwombat> If you come to Ireland, the pints are on me!
06:43:49 <Gx4> tag me along, please
06:45:41 <byorgey> ok!
06:45:45 <mhwombat> Gx4: You can be the designated driver ;^)
06:46:49 * hackagebot digestive-functors 0.4.1.2 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.4.1.2 (JasperVanDerJeugt)
06:47:15 <Gx4> I need to get pilot license fast
06:47:40 <osa1> I'm not sure if this is a right place for this question but, can any context-free grammar be parsed with CYK algorithm ? I'm asking this because I know most parsers are for some kind of subsets of context-free grammars
06:52:12 <xraycat> osa1: afair, yes, the grammar just has to be in chomsky normal form
06:53:12 <augur> osa1: there are general parser designs which can parse arbitrary CFGs
06:53:14 <osa1> xraycat: thanks. are there any other algorithms for parsing any context-free grammars?
06:53:19 <augur> the problem is they're horribly inefficient
06:53:59 <augur> osa1: theres a book, parsing techniques, that overviews some of the major ones
06:54:30 <osa1> augur: great, thanks for the book. I've just googled it and it looks like a free book
06:54:47 <augur> unger parsers can do arbitrary cfgs, for instance
06:54:58 <osa1> augur: is it's full name "parsing techniques: a practical guide" ?
06:54:59 <augur> but they have horrible properties
06:55:00 <augur> especially memory complexity
06:55:02 <augur> yeah
06:55:09 <osa1> great, thanks
06:56:51 * hackagebot language-objc 0.4.2.0 - Analysis and generation of Objcective C code  http://hackage.haskell.org/package/language-objc-0.4.2.0 (JohnLato)
06:57:08 <augur> osa1: chapter 4
06:57:21 <augur> 4.1 specifically
06:59:01 <augur> This example shows that we can save much time by remembering answers to questions. For instance, the question whether L derives ε is asked many times. Sheil [CF 1976] has shown that the efficiency improves dramatically when this is done: it goes from exponential to polynomial. Another possible optimization is achieved by computing in advance which non-terminals can derive ε. In fact, this is a special case of computing the minimum length of a ter
06:59:01 <augur> minal string that each non-terminal derives. If a non-terminal derives ε, this minimum length is 0.
06:59:13 <augur> exponential-time naive implementations = bad :(
06:59:30 <merijn> "~(Just foo) <- bar" will only try to inspect the Maybe value when foo is actually used, right?
06:59:50 <Peaker> merijn, yeah
07:00:43 <augur> i think chart parsing is also possible for arbitrary CFGs
07:01:47 <osa1> augur: indentation-based grammars are not context-free, right? I'm wondering if there are well-known algorithms for parsing indentation-based grammars
07:02:02 <augur> osa1: i believe this is true
07:02:24 <augur> i dont know of any techniques for indentation based stuff
07:02:25 <quicksilver> they are if you lex them first and interpret the indentation at lex time.
07:02:29 <Peaker> hlint has a weeeird hint. If your function is called "union" in any module, it will warn you to use it infix, even if it is fully qualified. Weird!
07:02:42 <augur> but its not that hard
07:02:47 <quicksilver> this is cheating but, this is a common cheat
07:02:51 <augur> indentation isnt a severly CS thing
07:02:53 <Peaker> Found: UnionFind.union a b    Why not: a `UnionFind.union` b
07:03:00 <quicksilver> transform a fiddly parse into a composition of parses
07:03:11 <Peaker> HLint: Why??
07:04:02 * Peaker succumbs to hlint pressure and does some weird stuff to get a clean hlint experience...
07:04:23 <augur> chart parsing is non-deterministic in a very elegant way
07:04:57 <arnsholt> How exactly is chart parsing non-deterministic?
07:05:21 <augur> arnsholt: it maintains a chart with multiple possible parsers simultaneously
07:05:34 <augur> http://www.nlp.org.cn/docs/20030724/resource/ParsingTechs_A_Practical_Guide.pdf
07:05:43 <augur> 4.2.8, at the end of chapter 4
07:05:56 <augur> notice that it has multiple partial parses in the chart all at once
07:06:24 <augur> because of this, its possible to produce more than one maximal arc in the chart, hence, non-deterministic parsing! :)
07:06:28 <osa1> augur: thanks. that's enough information for me, now I'm going to read
07:07:14 <arnsholt> I suppose you can call it non-deterministic, yeah
07:07:40 <arnsholt> Non-deterministic just makes me think more of Prolog than chart parsing =)
07:08:10 <augur> non-deterministic just means there isn't one result :)
07:08:19 <augur> but possibly many
07:08:43 <augur> prolog achieves non-determinism via backtracking in most implementations
07:08:56 <augur> or via continuations, which are just pre-compiled backtracks
07:14:24 <Peaker> @hayoo hexdump
07:14:24 <lambdabot> Unknown command, try @list
07:14:27 <Peaker> @hoogle hexdump
07:14:27 <lambdabot> package hexdump
07:14:27 <lambdabot> package uhexdump
07:14:48 * theadmin peeks in to watch the conversation and try to learn something from it, don't mind me.
07:15:07 <Peaker> Is there a name for:  concatMap as2DigitHex . BS.unpack ?
07:18:09 <theadmin> Peaker: Why not make one if there isn't a built-in one? You just described the function..
07:18:36 <Peaker> isn't there one in hackage, maybe?
07:18:36 <statusfailed> Maybe he means "does what that does have a name"
07:18:39 <statusfailed> or not~
07:19:06 <statusfailed> Peaker: isn't there Printf?
07:19:27 <Peaker> http://hackage.haskell.org/packages/archive/hex/0.1.2/doc/html/Data-Hex.html <-- terrible type-class abuse in there
07:19:36 <Peaker> or rather, just a non-sensible type-class
07:19:55 <kqr_> is negative numbers part of haskell syntax or is (-) a unary function? i can't find anything about negative numbers in the haskell 2010 report regarding syntax for literals, but i might be bad at reading BNF
07:20:07 <quicksilver> - is a unary function
07:20:08 <Peaker> statusfailed, Printf is good for "as2DigitHex", I guess. A bit of a big hammer though
07:20:29 <quicksilver> also known as an "annoying inconsistent"
07:20:48 <kqr_> quicksilver, yeah, i was thinking about the inconsistency
07:20:49 <statusfailed> Peaker: Yeah you're right :\
07:20:55 <statusfailed> You'd still need the map
07:20:59 <quicksilver> Peaker: showHex, for that part
07:21:20 <quicksilver> but overall, I'm not aware of a function for 'display bytestrings as hex', no
07:22:05 <Peaker> showHex 5 ""
07:22:06 <Peaker> > showHex 5 ""
07:22:07 <lambdabot>   "5"
07:22:12 <Peaker> need to pad to 2...
07:22:26 <quicksilver> hmm, maybe showHex doesn't pad to 2
07:22:28 <quicksilver> yeah
07:22:29 <quicksilver> :)
07:22:57 <Peaker> oh, nice: http://hackage.haskell.org/packages/archive/base16-bytestring/0.1.1.4/doc/html/Data-ByteString-Base16.html
07:23:04 <quicksilver> Peaker: http://stackoverflow.com/questions/8412398/pretty-print-bytestring-to-hex-nibble-wise
07:24:47 <Peaker> quicksilver, the answers there are wrong...
07:25:12 <Peaker> at least if they want a hex encoding
07:26:30 * quicksilver nods
07:27:20 <Peaker> I had a silly bug when I did:   to2DigitHex n | n < 0x10 = '0' : showHex n "" | n < 0x100 = showHex n "" | otherwise = error "Invalid ..."
07:27:32 <Peaker> hint: to2DigitHex :: Word8 -> String
07:28:20 <nand`> can that “otherwise” ever occur?
07:29:50 <Peaker> it did for all n >= 0x10
07:29:57 <rwbarton> hehe
07:30:52 * nand` doesn't get it
07:30:58 <nand`> oh
07:31:02 <nand`> oohhh
07:31:42 <Peaker> number truncation bugs are really annoying
07:32:14 <Peaker> maybe it could be nice to have a flag to get runtime errors instead of truncation (at a runtime penalty) for when performance matters less than catching bugs, and for debugging these kinds of things
07:32:53 <Peaker> basically all it takes is compiling against a different implementation of the truncated types (Int*, Word*)
07:32:58 <nand`> (<') :: Integral a, Integral b => a -> b -> Bool; a <' b = toInteger a < toInteger b -- :P
07:33:43 <quicksilver> Peaker: I think a warning - or even error - would be perfectly appropriate when you use a *literal* which doesn't fit in the range of the monomorphic type.
07:36:22 <nand`> Integer has spoiled me :(
07:36:26 <rwbarton> a bit ironic that in C this wouldn't have been a bug
07:36:38 <Peaker> quicksilver, I used a polymorphic type at first, which was silly
07:37:12 <Peaker> (hard-coded to 2 digits, polymorphic to any int size, wat?)
07:37:12 <nand`> it still would have been instantiated as a monomorphic type whenever you tried actually using it, thus ideally throwing aforementioned warning/error
07:37:58 <Peaker> nand`, only if it was actually specialized.. or maybe it could be nice if every polymorphic function was compiled along-side warning generators for each type, and when it is used with any of those types it generates any warnings associated with them, so you can get them even without specialization
07:39:39 <nand`> Peaker: yeah that's what I meant, not with the SPECIALIZE pragma but whenever you used that function in a scenario where it ended up monomorphic (and thus the literal did too)
07:40:28 <Peaker> nand`, the function didn
07:40:32 <Peaker> 't end up monomorphic
07:45:12 <ksf> It's annoying to no end that typefams can't do equality constraints.
07:45:17 <ksf> I'm trying it again and again.
07:46:51 <theadmin> Is there any same way to add a type signature to a function on the same line (in the same statement) as defining a function body?
07:47:18 <ksf> try a semicolon.
07:47:34 <nand`> theadmin: sure, just use :: on the body itself
07:47:41 <ksf> ...or that.
07:47:58 <nand`> :t let f = id :: (a, b) -> (a, b) in f
07:47:59 <lambdabot> forall a b. (a, b) -> (a, b)
07:48:19 <ksf> hmmm {;} doesn't seem to work top-level.
07:48:29 <nand`> :t let f = id; f :: (a, b) -> (a, b) in f
07:48:30 <lambdabot> forall a b. (a, b) -> (a, b)
07:52:03 <Peaker> hmm.. I need UI suggestions with regard to showing type information as you edit
07:52:55 <Peaker> bottle shows inferred types under most sub-expressions.. on the one hand, it generates a lot of clutter. OTOH, it's really nice to see the types as you edit.. Maybe someone can have a creative idea on how to reduce clutter while still showing the bulk of the information?
07:53:01 <nand`> status bar?
07:53:19 <Gx4> tooltip ?
07:53:40 <Peaker> I want to show them without requiring an extra UI round trip as a tooltip requires
07:54:07 <Peaker> it'd be great if you pulled the newest version of bottle and took a look - it'd make suggestions more concrete
07:54:34 <Peaker> http://github.com/Peaker/bottle <-- shows sub-expression types and type errors as you type
07:54:50 <Gx4> ajax tooltip?
07:55:26 <Peaker> "UI roundtrip" means -- sending the mouse ptr somewhere before you can see its type
07:55:36 <Peaker> it's a native Haskell program, not web
07:57:31 <Gx4> info box ?
07:59:20 <Peaker> still have to move cursor to it
08:00:00 <nand`> I can't make an accurate suggestion as I don't know how exactly bottle works (what it shows the type of and at what time), and I don't have the energy to try it right now; but I can tell you that what I personally would consider expected behavior is for the type of whatever sub-expression my editing cursor is currently on (however that scope is decided, I do not know) in a status bar at the bottom - or
08:00:03 <nand`> perhaps having it show the type of whatever I'm currently highlighting
08:06:08 <Gx4> make quake style console where you display all your info
08:15:02 <osa1> `\n $whitespace*` regex in Alex matches non-whitespace characters too, why is that?
08:22:04 * hackagebot sfml-audio 0.6.0.1816 - minimal bindings to the audio module of sfml  http://hackage.haskell.org/package/sfml-audio-0.6.0.1816 (SoenkeHahn)
08:26:35 <tac-tics> Is it just me, or do the identity laws for Applicative feel really "messy"?
08:26:50 <tac-tics> Functors are so clean. fmap preserves composition and identity maps.
08:27:04 <tac-tics> But the laws for Applicative seem to come out of nowhere
08:30:52 <quicksilver> I think the applicative laws are very clean and simple
08:31:00 <quicksilver> but they don't look very nice in haskell notation.
08:31:48 <nand`> pure id <*> v = v -- not that different from fmap id v = v
08:33:01 <nand`> pure (.) <*> u <*> v <*> w = u <*> (v <*> w) -- more or less analog of (u . v) w = u (v w)
08:33:04 <nand`> the <*> just makes it ugly
08:33:53 <t7> :t (<*>)
08:33:54 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:34:08 <t7> :t <$>
08:34:09 <lambdabot> parse error on input `<$>'
08:34:12 <t7> :t (<$>)
08:34:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:34:39 <otters> somebody posted a great paper on lenses in here a few days ago
08:37:05 * hackagebot resourcet 0.3.2.2 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.3.2.2 (MichaelSnoyman)
08:40:10 <coppro> What is the naming convention for acronyms at the start of non-constructor identifiers? All lowercase (e.g. IRCFoo for a constructor and ircFoo for a non-constructor)?
08:40:51 <nand`> “IrcFoo” doesn't look too bad either
08:41:13 <nand`> but ircFoo is definitely the way to go, since IRCFoo/IrcFoo are illegal and iRCFoo is just ridiculous
08:41:39 <nand`> (there's also fooIRC but that's very ugly)
08:41:49 <nand`> ideally you'd want Irc.foo either way
08:42:07 * hackagebot SoOSiM 0.2.0.0 - Abstract full system simulator  http://hackage.haskell.org/package/SoOSiM-0.2.0.0 (ChristiaanBaaij)
08:43:56 <coppro> nand`: I'm generally opposed to camel case acronyms
08:50:16 <parcs`>  
08:51:39 <merijn> otters: I suspect you will need to be slightly more specific :)
08:52:35 <otters> merijn: the only thing I can really say about it is that it used the ^= operator
09:04:44 <watermind> is there some usual notation to denote the 'type instantiation partial order'?
09:06:05 <watermind> i.e. tau R sigma  if  tau can be obtained from sigma by instantiation of (universaly quantified) type variables
09:22:50 <adamt> using Data.Map, is there a simple method (that i'm clearly missing) for traversing the values of the map?
09:23:49 <Peaker_> adamt, Data.Map.map ?
09:23:55 <Peaker_> what do you mean by traversing?
09:24:07 <Peaker_> Or Data.Map.elems? Or toList?
09:24:24 <parcs`> fmap
09:25:05 <adamt> I just want a list of the values
09:25:16 <luite_> elems
09:25:29 <luite_> i mean:
09:25:30 <luite_> :t elems
09:25:32 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
09:25:36 <luite_> wrong :(
09:25:46 <luite_> :t Data.Map.elems
09:25:47 <lambdabot> forall k a. M.Map k a -> [a]
09:26:11 <adamt> ah i see it now in the documentation as well, thanks luite :-)
09:26:22 <luite> Peaker_: beat me to it
09:26:36 <adamt> thanks as well, Peaker_ :-)
09:27:14 <parcs`> @hoogle Map k a -> [a]
09:27:14 <lambdabot> Data.Map elems :: Map k a -> [a]
09:27:14 <lambdabot> Data.Map keys :: Map k a -> [k]
09:27:14 <lambdabot> Data.Map null :: Map k a -> Bool
09:27:43 <luite> adamt: there are also some fold functions, and the Traversable and Foldable instances
09:27:45 <adamt> God damnit i keep forgetting about hoogle and yahoo :-(
09:29:24 <luite> is it possible to build only one executable for a apckage that has more?
09:31:41 <parcs`> yeah
09:31:56 <parcs`> wait i misread. i don't know
09:32:32 <nand`> is there a word for some ‘z’ such that forall e. z × e = z && e × z = z
09:33:06 <nand`> eg. 0 for (*)
09:33:46 <merijn> otters: ^= is used by data-lens, but I'm not sure which paper talks about data-lens?
09:46:38 <pyrtsa> nand`: Additive identity element, perhaps? http://en.wikipedia.org/wiki/Identity_element
09:47:14 <pyrtsa> Oh, not exactly.
09:47:51 <pyrtsa> Depends how (×) is allowed to be defined.
09:47:52 <ziman> nand`, neutral element, iirc
09:48:13 <pyrtsa> Neutral element is synonymous to additive identity.
09:48:33 <pyrtsa> I mean, to identity.
09:49:54 <ziman> hm, i thought zero vs. * is something along the lines of "absorptive element" but I cannot google it at all
09:50:05 <nand`> that's not what I'm asking for; the identity for (*) is 1, not 0. I'm looking for the property of (0,*) where 0*x = 0 for any x
09:50:13 <nand`> not that 1*x = x
09:50:51 <ziman> ah, here it is used in that sense: http://en.wikipedia.org/wiki/Near-semiring
09:50:53 <nand`> (re: identity) ziman: that could be it
09:51:17 <ziman> 0 is one (right or left, respectively) side absorptive element.
09:51:28 <nand`> ziman: that sounds good, thanks
09:53:23 <ziman> i'd expect that pair of words to have more relevant google hits, though
09:55:28 <nand`> I get lots of hits related to physics
09:55:53 <illissius> otters: logs are available from the topic. grep for http and lens?
09:58:56 <rwbarton> seems like "absorbing element" is more popular for the math sense
10:00:10 <Eduard_Munteanu> How about zero element?
10:00:50 <Eduard_Munteanu> Think zero divisor etc.
10:01:00 <richn> getting: Could not find module `CPUTime'
10:01:02 <richn>     It is a member of the hidden package `haskell98-2.0.0.1'
10:01:03 <richn> what should I import?
10:01:18 <rwbarton> System.CPUTime
10:01:23 <rwbarton> @hoogle CPUTime
10:01:23 <lambdabot> System.CPUTime cpuTimePrecision :: Integer
10:01:23 <lambdabot> System.CPUTime module System.CPUTime
10:01:23 <lambdabot> System.Posix.Signals cpuTimeLimitExceeded :: Signal
10:04:11 <Veinor> argh
10:04:21 <Veinor> i wish more things had list monads
10:07:17 <tac-tics> Veinor: I think quails have list monads.
10:07:26 <tac-tics> err wrong channel >_>
10:08:37 <Veinor> ... ?
10:11:09 <jfischoff>  nand`: annihilates is one word I've seen to describe x * 0 = 0
10:12:09 <jfischoff> and absorbing element ...
10:14:34 <nand`> I'll go with the more gentle version
10:16:08 <Veinor> nand`: if your structure also has addition then you can just say 'is the additive identity'
10:16:30 <Veinor> well
10:16:33 <Veinor> has addition and is a ring
10:18:06 <jonaskoelker> I was thinking about the data constructours `Just' and `Right'---do you think in some haskell prime there will also be `Good' and `Holy'?  *rimshot*  ;-)
10:19:20 <aristid> jonaskoelker: the oldest joke in the (haskell) world :)
10:21:36 <zhulikas> hmm, good idea
10:21:40 * zhulikas googles haskell jokes
10:22:16 <Peaker_> I always noticed "Right"'s dual meaning.. but only now noticed Just's :)
10:23:06 <nand`> data Comaybe x = Something | Unjust x; data Coeither x y = Right x | Wrong y
10:24:00 <zhulikas> I liked that
10:24:07 <zhulikas> data Neither a b = Left | Right
10:25:50 <nand`> data Unlikely x = Probably | Rarely x
10:28:32 <nand`> http://ro-che.info/ccc/05.html <- haha
10:28:52 <otters> data Unlikely x = Maybe x | Doubtful x | HighlyUnlikely x | NoWayInHell
10:29:53 <HairyDude> data Probably = Definitely x | Prob Double x | DefinitelyNot
10:30:11 <HairyDude> s/Probably/Probably x/
10:31:03 <otters> data IAintTellinYou = forall x. Unknown x
10:31:59 <HairyDude> :)
10:32:01 <c_wraith> the good ol' universal existential. "I have a type. I'm not telling you what it is."
10:33:06 <otters> maybe the constructor should be called NeenerNeener
10:33:14 * byorgey was just about to say that!
10:35:41 <nurpax> Hi, any Emacs Scion users around?  I'm trying to improve my Haskell edit-compile workflow in Emacs.  Is Scion still the thing to use?  Any other packages I should try?  Using it for building executables with .cabal works great, but I don't know how to work on cabal Test-Suites with Scion
10:42:08 <Cale> nurpax: It's not emacs-specific, but I just keep a running ghci open next to whatever text editor I'm using
10:42:28 <Cale> nurpax: then whenever I want, I can save my file and :r in ghci to load the changes
10:43:06 <Cale> I'm not sure what else anyone would need tbh :P
10:43:11 <nurpax> Cale: that's what I do now (most of the time) - but with Emacs it's nicer to do just <ctrl>-c <ctrl>-l to load my current .hs into ghci inside emacs
10:43:24 <nurpax> Cale: but I'm looking to integrate the same for .cabal files
10:43:38 <Cale> I never liked what emacs' terminal emulation did with long lines
10:44:11 <nurpax> Cale: scion actually integrates really well into Emacs.  It can compile my file on save and then mark compiler errors in red underline.  Really awesome stuff.  Just trying to find the last config bits to fit my workflow :)
10:53:13 <nurpax> Re Scion - looks like it doesn't support the Test-Suite type component.  I'll just turn my test into an Executable instead.  Seems to work
10:54:16 <Peaker_> nurpax, Emacs's flymake does that too
10:54:25 <Peaker_> though red background is probably more annoying than red underline
10:55:03 <byorgey> yeah, flymake can be nice.  ghc-mod includes flymake integration.  http://hackage.haskell.org/package/ghc%2Dmod
10:55:24 <nurpax> Peaker, byorgey: interesting!  maybe I should try that instead of scion
10:55:57 <nurpax> I stumbled upon this stuff on http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs and Scion was the first one on the list
10:56:38 <byorgey> yeah, I don't know if scion is being developed anymore.
10:58:53 <nurpax> byorgey: does this work with cabal based projects too?  e.g., instead of just loading .hs files it can compile the whole project?
10:59:44 <byorgey> nurpax: I don't know if ghc-mod does.  But you should try Chris Done's new(ish) extensions to haskell-mode, which does support that
11:02:26 <whittle> When unpickling with HXT is there any way to get more verbose error messages?
11:05:11 <ozataman> anyone familiar with quickcheck's size parameter? is it a recursive depth tracker or something else?
11:05:24 <ozataman> I can't seem to find documentation that explains it clearly
11:10:25 <JoeyA> Is there a shorter way to write return() to indicate a monadic action that does nothing?  (I'm golfing something)
11:10:44 <nand`> http://www.willamette.edu/~fruehr/haskell/SeussFinal2.JPG hehehehe
11:10:45 <c_wraith> :t (void <$>)
11:10:46 <lambdabot> Not in scope: `void'
11:10:55 <c_wraith> ...  not a new enough ghc for lambdabot
11:11:06 <byorgey> ozataman: it can be whatever you want.  Using it as a recursive depth tracker is common.
11:11:15 <nand`> c_wraith: wouldn't that be const () <$> ?
11:11:19 <nand`> or just void
11:11:25 <byorgey> ozataman: you are just guaranteed that generators will be called with gradually increasing values of the size parameter.
11:12:03 <JoeyA> Ah, pure() would work too (I'll just make an Applicative instance)
11:19:49 <nand`> http://www.haskell.org/haskellwiki/Humor/Enron he he. he.
11:23:03 <tzxn3> hahaha
11:23:11 <JoeyA> I know "where" binds to pattern matches of a function definition, but does it also bind to -> in a case expression?
11:24:02 <adamt> heh
11:24:07 <byorgey> JoeyA: no.  where can only be used with a declaration.  so it cannot be used with case, which is an expression
11:24:08 <adamt> valuations sure are fishy.
11:24:19 <JoeyA> byorgey: okay, thanks
11:24:40 <JoeyA> > case 5 of n -> x where x=n
11:24:41 <lambdabot>   5
11:24:44 <nurpax> byorgey: thanks for the tip on the experimental cabal-dev project features in haskell-mode.  gave it a go and it pretty much fixes my problems
11:24:48 <JoeyA> byorgey: I just did...
11:25:00 <byorgey> nurpax: great!
11:25:21 <byorgey> JoeyA: hmm, weird
11:25:43 * byorgey checks the Report
11:26:17 <byorgey> huh, what do you know, where is allowed on case expressions!
11:26:20 <byorgey> I never knew that
11:26:35 <sipa> whit is not
11:26:59 <sipa> it has nothing to do with that case
11:27:13 <nand`> > case 5 of 0 -> x where x=n; m -> x where x=m+1
11:27:13 <lambdabot>   <no location info>: parse error on input `->'
11:27:24 <rwbarton> it's attached to the pattern match I guess
11:27:26 <JoeyA> http://codepad.org/1VgaKprA
11:27:35 <nand`> > case 5 of 0 -> x; m -> x where x=m+1
11:27:36 <lambdabot>   5 + 1
11:27:36 <rwbarton> > case 5 of 0 -> x where {x=n}; m -> x where x=m+1
11:27:37 <lambdabot>   5 + 1
11:27:42 <JoeyA> Indeed.  In this example, if you back up the "where" line, it'll span both patterns.
11:27:52 <JoeyA> (in my example I pasted, that is)
11:28:38 <nand`> oh, those get forced to Expr because of the ‘x’
11:28:41 <nand`> somehow
11:28:45 <nand`> > case 5 of 0 -> x'; m -> x' where x'=m+1
11:28:46 <lambdabot>   Not in scope: `x''
11:28:51 <byorgey> yeah, it looks (from the Report) like where can only be attached to a single alternative of a case
11:29:03 <rwbarton> n rather
11:29:06 <byorgey> which makes sense, the variables bound in the pattern match will be bound inside the where
11:29:21 <nand`> rwbarton: x in my example, n in yours
11:29:26 <rwbarton> ah
11:29:43 <rwbarton> I would guess that it scopes over multiple guards on the same pattern match as well (like in a function definition)
11:30:00 <rwbarton> nand`: well my example was also one of your examples :)
11:30:01 <byorgey> rwbarton: yes, it does
11:30:44 <ozataman> byorgey: I see, thank you. I wasn't sure for a second if the bind implicitly incremented it, which is not the case.
11:30:51 <byorgey> Each alternative pi matchi consists of a pattern pi and its matches, matchi. Each match in turn consists of a sequence of pairs of guards gsij and bodies eij (expressions), followed by optional bindings (declsi) that scope over all of the guards and expressions of the alternative.
11:31:17 <ClaudiusMaximus> > case 5 of m | m == 0 -> n | otherwise -> n where n = "testing  case + guards + where"
11:31:18 <lambdabot>   "testing  case + guards + where"
11:32:27 <rwbarton> oh that's friendly. I thought you had deduced the scoping rules from a careful examination of the BNF :P
11:37:57 <otters> > case () of _ | 1 == 2 -> 3 | otherwise -> 4
11:37:58 <lambdabot>   4
11:43:29 <nand`> [referring to (>>=)] “Its pronunciation is a sort of bestial hissing that is difficult to describe; when you say it correctly, the terminal may become slightly moist.”
11:46:15 <carter_> nand`: don't you mean demonic bind
11:46:20 <carter_> rather than the functional sort?
11:46:23 <carter_> :)
11:46:39 <carter_> or are you saying they're the same
11:46:54 <nand`> context: http://www.haskell.org/pipermail/haskell-cafe/2006-November/019190.html
11:47:38 <otters> how are sort and bind related at all
11:47:53 <nand`> I don't think he meant the function ‘sort’
11:47:58 <nand`> but used ‘sort’ as an english word
11:48:01 <otters> oh
11:48:03 <otters> wow
11:48:05 <otters> okay
11:48:15 <carter_> ah
11:53:18 <tac-tics> @type seq
11:53:19 <lambdabot> forall a t. a -> t -> t
11:53:32 <tac-tics> What does seq actually do again?
11:53:41 <nand`> forces a before returning t
11:53:43 <S11001001> tac-tics: one thing before the other
11:53:45 <tac-tics> Does it just eval its first argument to whnf?
11:53:49 <otters> ja
11:54:13 <tac-tics> To whnf in particular?
11:54:58 <S11001001> > const 42 (seq undefined undefined) -- moreover,
11:54:59 <lambdabot>   42
11:56:13 <tac-tics> S11001001: what's the point you're making there exactly?
11:56:32 <tac-tics> That seq just evaluates like a normal haskell function (and in that example, it is never needed)?
11:56:48 <S11001001> aye
11:56:52 <tac-tics> cool
11:57:18 <tac-tics> Though, if I were to define the Naturals as data Nat = O | S Nat, seq wouldn't work the same on Nat as it does on Int, right?
11:57:39 <copumpkin> now for a weirder quiz
11:57:45 <copumpkin> let ((a, b), (c, d)) = ((1, 2), undefined) in a
11:57:52 <nand`> tac-tics: yes
11:57:56 <nand`> unless you use deepseq :P
11:58:02 <copumpkin> how will that behave? :)
11:58:23 <nand`> copumpkin: evaluates to 1?
11:58:43 <tac-tics> copumpkin: it would just find the top-level S or O, whereas on an Int, it fully normalizes the number.
11:58:46 <tac-tics> right?
11:58:58 <nand`> “exception: prelude.undefined”
11:58:59 <copumpkin> oh, I was talking about my question
11:59:00 <nand`> huh, guess not
11:59:08 <S11001001> copumpkin: evaluates to mzero :: forall m. Monad m => m (), obviously
11:59:20 <nand`> oh
11:59:22 <copumpkin> tac-tics: yeah, those naturals are lazy so you'd only force the outermost S when you seq
11:59:24 * nand` sees it now
12:00:10 <tac-tics> Is there a way to simulate the builtin Int semantics (in as far as how it interacts with seq) using a data decl?
12:00:23 <copumpkin> case ((1,2),undefined) of ~((a,b),(c,d)) -> a
12:00:27 <shapr> Is there something like Python's cString?
12:00:29 <copumpkin> case ((1,2),undefined) of ~(~(a,b),~(c,d)) -> a﻿
12:01:00 <nand`> > let ((a, b), ~(c, d)) = ((1, 2), undefined) in a
12:01:01 <lambdabot>   1
12:01:20 <tac-tics> What does the ~ mean again?
12:01:26 <nand`> irrefutable pattern match
12:01:46 <nand`> if what you're matching against is bottom, the result of the pattern match is bottom too; iirc
12:01:58 <copumpkin> yeah
12:02:01 <nand`> (but it still succeeds)
12:02:10 <copumpkin> > let f (x, y) = 5 in f undefined
12:02:11 <lambdabot>   *Exception: Prelude.undefined
12:02:15 <tazjin> shapr:
12:02:17 <copumpkin> > let f ~(x, y) = 5 in f undefined
12:02:18 <lambdabot>   5
12:02:19 <tazjin> @hoogle CString
12:02:19 <lambdabot> Foreign.C.String type CString = Ptr CChar
12:02:20 <lambdabot> Foreign.C.String type CStringLen = (Ptr CChar, Int)
12:02:20 <lambdabot> Foreign.C.String newCString :: String -> IO CString
12:02:51 <shapr> tazjin: I was wondering about a way to read and write to 'files' in memory.
12:02:55 <nand`> it seems counter-intuitive that a pattern match for (x, y) can fail since (,) is the only constructor for it
12:03:35 <nand`> > let f ~(x, 0) = 5 in f undefined
12:03:36 <lambdabot>   5
12:03:51 * tac-tics feels dirty after learning about irrefutable patterns
12:04:02 <tazjin> shapr: Do you really want them to work like files?
12:04:32 <shapr> I don't know...
12:04:48 <tazjin> What do you want to do?
12:05:14 <tactics> Are irrefutable patterns very useful in haskell?
12:05:16 <shapr> I want to see if there's a file-like object for Haskell that only uses memory, and see if I can use it the same way I've done some things in Python.
12:05:47 <otters> tactics: occasionally
12:06:51 <tactics> Just today, I feel like I should probably spend more time programming in Haskell for some reason >_>
12:06:55 <tazjin> shapr: Well, most file IO happens with Bytestrings, so you could probably use a simple IORef (ByteString, Filepath) -- if you want to keep some kind of path with it as well
12:07:10 <shapr> tazjin: That's a good point, I'll try that, thanks!
12:07:46 <tazjin> shapr: Still, depending on what you want to accomplish with that there might be better solutions
12:08:31 <tactics> So an irrefutable pattern always matches, but if it *would* have failed, it only raises an exception when you try to use one of the projections?
12:10:23 <raichoo> Can anyone give me a hint why my ConstaintKinds do not work? I'm using ghc 7.4.2 had the same issue with 7.4.1.
12:10:27 <hpaste_> raichoo pasted “Constraint Kinds” at http://hpaste.org/69859
12:10:58 <nand`> > let f ~(x, 0) = x in f (3, 5)
12:10:59 <lambdabot>   *Exception: <interactive>:3:4-16: Irrefutable pattern failed for pattern (x...
12:11:41 <luite> shapr: do you still want IO?
12:12:34 <geekosaur> raichoo, (1) please include the full error message (2) as I understanbd it, they're still experimental and a number of things *do not* work in 7.4.x but are fixed in HEAD
12:12:41 <luite> is it possible to use deriving instance Data for a GADT?
12:13:05 <shapr> luite: from the hint interpreter? YES!
12:13:12 <shapr> luite: Do you have some idea(s) ?
12:14:00 <raichoo> geekosaur: Oh yes sorry. My bad.
12:14:01 <luite> shapr: you mean like the safe python thing? don't know how it's called
12:14:41 <shapr> luite: Eh, forget the Python stuff, that's a sideline.. do you know how to connect IO to a web-based hint interpreter?
12:14:43 <hpaste_> raichoo annotated “Constraint Kinds” with “Constraint Kinds (annotation)” at http://hpaste.org/69859#a69860
12:15:02 <raichoo> Done
12:15:25 <luite> shapr: well, that part is easy, so security is not an issue yet?
12:15:38 <shapr> Yah, for the moment
12:15:48 <shapr> It is easy?
12:16:51 <luite> shapr: yeah, you do something like:   x <- interpret myExpr (as :: IO String); y <- x
12:17:05 <luite> where myExpr is a String
12:17:07 <raichoo> Ok, I write Constaint, but that's not it. The same error occurs with "Constraint".
12:20:04 <luite> shapr: you'd hav e to make sure that myExpr actually has type IO String of course
12:20:46 <shapr> How would I handle getLine?
12:21:36 <thoughtpolice> raichoo: you have to import 'Constraint' from GHC.Prim
12:21:45 <thoughtpolice> so just 'import GHC.Prim (Constraint)' will work
12:22:12 <luite> shapr: that would probably be tricky, what would you want it to do?
12:22:30 <shapr> Take input from the web browser
12:25:32 <luite> shapr: in that case, the y <- x part blocks, because x calls getLine somewhere. what you can do is eval that action in a separate thread
12:26:09 <luite> but it's a bit more difficult then, when it takes a while to run that action, it might just be computing, or it might wait for some input
12:27:00 <Taneb> Is Whales a functor?
12:27:20 <luite> the whole response thing would become asynchronous: when something is being evaluated, send browser input to the stdin of that action, if nothing is running, start new eval
12:27:51 <luite> but any request is not guaranteed a response anymore
12:28:08 <Taneb> Maybe that's why the Free Whales campaign has foundered
12:28:14 <Taneb> *floundered
12:28:27 <Taneb> I know there's a word somewhere around there, but I cannot think of what it is
12:28:40 <luite> shapr: you could have the client send POST requests to do the commands, and leave a websocket connection with the server to receive JSON responses as they become available
12:32:05 <luite> shapr: that websocket thing would be useful anyway if you want multiple clients to receive the same data in realtime, so it might be worth investigating anyway. there's a wai-websockets that should probably work with scotty, but you'lll probably be the firstt to use this combination
12:32:58 <shapr> hrm
12:35:01 <luite> shapr: but running actually interactive actions is a whole lot trickier than the simple request->respose things
12:35:31 <luite> do you think it's important to use getLine and other GHCi-like things?
12:46:07 <ben> Is there a canonical way to get thousands grouping for formatting numbers with haskell or do I roll it myself?
12:48:34 <shapr> luite: I'd certainly like to have getLine and friends in this web front end
12:48:42 <shapr> luite: Do you think it's doable?
12:52:15 <tgeeky_> luite: hdiff just went down?
12:56:12 <LambdaDusk> Hi, I seem to have a blockade in my head... I need a function "mid :: (Ord a) => a -> a -> a -> a" that will always give me the value in the middle of the three but all I have come up with is a not really working list of ugly if-thens
12:56:43 <raichoo> thoughtpolice: Awesome, thanks a bunch :)
12:59:52 <snhmib> LambdaDusk: maybe "mid a b c = max [a,b,c]", but i don't see anyhting wrong with if statements n such.. maybe put the if statements in a guard (what's the name)
13:01:01 <snhmib> like "mid a b c | a >= b && a >= c = a | .. " etc.
13:01:16 <LambdaDusk> snhmib: Is that really necessary...?
13:01:45 <snhmib> ?
13:02:00 <snhmib> err oh the middle
13:02:28 <snhmib> then what i said 1st is wrong :)
13:02:29 <nand`> mid a b c = (\_:m:_ -> m) (sort [a,b,c])
13:02:36 <ocharles> LambdaDusk: why not just...
13:02:36 <ocharles> yea, sort
13:02:38 <ocharles> heh
13:02:39 <Veinor> LambdaDusk: mid a b c | a >= b = min a c
13:02:58 <Veinor> wait no i don't know if that works
13:03:17 <snhmib> well you "get rid" of all the then clauses somewhat i guess
13:03:30 <Veinor> also yeah mid a b c = sort [a, b, c] ! 1
13:03:37 <nand`> oh yeah
13:03:56 <LambdaDusk> wow I knew there was a crazy haskell way
13:04:06 * nand` has been robbed of silly concepts such as “indexing lists”
13:04:22 <ocharles> LambdaDusk: that's not a "haskell" way
13:04:23 <dino-_> I need some happstack help if anyone here works with it.
13:04:25 <ocharles> it's a logical way
13:04:33 <LambdaDusk> dino-_: I do
13:04:40 <nand`> It's a “why reimplement the wheel” sort of thing
13:04:46 <dino-_> Switched my Happstack.Lite over to .Server ..
13:04:47 <ocharles> if this was perl I would do: sub mid { my (undef, $mid, undef) = sort @_; return $mid } too
13:04:56 <dino-_> And am now trying to get the entire body of the request.
13:05:03 <dino-_> Not those look* functions, the entire body.
13:05:26 <dino-_> I'm executing decodeBody, calling getData and am now stuck on no suitable instance of FromData.
13:05:30 <dino-_> And not finding any examples.
13:05:41 <dino-_> I just need a String or ByteString out of the request. Is that so much to ask?
13:06:01 <snhmib> heh, calling a sorting function for 3 values seems excessive to me.. must be C brainwashing for me ;)
13:07:41 * hackagebot happstack-authenticate 0.9.2 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.9.2 (JeremyShaw)
13:07:51 <ocharles> snhmib: if you were a good C programmer you'd profile that hypothesis though ;)
13:08:01 <ocharles> (not to imply you aren't, that came out a bit wrong!)
13:08:17 <LambdaDusk> dino-: Asked on the #happs channel yet?
13:08:21 <ben> last ben
13:08:26 <dino-> LambdaDusk: No, haven't been there yet.
13:08:27 <ben> err, ignore that!!
13:08:40 <dino-> Didn't think to go to specific channel. Will do soon.
13:08:52 <LambdaDusk> dino-: The happstack devs hang out there, they might be helping you
13:09:05 <dino-> LambdaDusk: ya, asking there. Thank you
13:13:30 <bindy> Hi all! Please, can anyone help me, how I can initialize a new record from [String]? The point is I have a record with many (40+) fields and I would like to feed it data from a [String]. Is there any other way except writing a huge 10lines function?
13:14:30 <parcs`> > let mid a b c = min (min (max a b) (max a c)) (min (max a b) (max b c)) in map (\[a,b,c] -> mid a b c) (permutations [1,2,3])
13:14:31 <lambdabot>   [2,2,2,2,2,2]
13:14:37 <fmap> a record with 40 fields?
13:14:41 <Justin_> wrong chat lol
13:14:45 <Justin_> fmap
13:14:50 <Justin_> I do not know about haskell
13:14:52 <nand`> Is there some elegant and pre-existing way to work with the mathematical ‘e’?
13:15:09 <Justin_> but you should use a variable variable
13:15:15 <Justin_> I only know the slang
13:15:44 <tactics> > e
13:15:45 <lambdabot>   e
13:15:55 <Justin_> but in Apple Basic making an associative array be like home[context1][insidecon]
13:15:57 <Justin_> so:
13:16:00 <bindy> fmap: yeah, writing a data transfer function. my data comes in a csv file and i'm trying to structure them
13:16:10 <Justin_> home[NJ][City]
13:16:20 <Justin_> and home[NY][city]
13:16:28 <Justin_> will all go inside the home var
13:16:40 <Justin_> then you can print everyone who lives in NJ and NY
13:16:42 <parcs`> > let mid a b c = min (min (max a b) (max a c)) (max b c) in map (\[a,b,c] -> mid a b c) (permutations [1,2,3])
13:16:43 <lambdabot>   [2,2,2,2,2,2]
13:16:46 <nand`> I can't very easily search hoogle for ‘e’
13:16:53 <dmwit> > exp 1 -- nand`
13:16:54 <lambdabot>   2.718281828459045
13:16:55 <nand`> nor any other search engine, mind
13:16:57 <nand`> oh
13:16:59 <nand`> excellent
13:17:21 <Justin_> anyone know how to do tic tac toe in Haskell just pm me
13:17:29 <Justin_> I don't want to work and learn the basics
13:17:42 <dmwit> We have a homework policy on our wiki. Look at it, please.
13:17:46 <Justin_> I just want to see it, and see if Haskell is really any efficient in this decade
13:17:50 <dmwit> (tl;dr: NO)
13:17:53 <Justin_> lol
13:17:54 <Justin_> ok
13:17:58 <HairyDude> please do not feed the troll
13:18:03 <Justin_> it's not homework
13:18:07 <Justin_> I work in PHP
13:18:23 <Justinba1010> somehow my name got cut
13:19:25 <dmwit> > let mid a b c = sort [a,b,c] !! 1 in map (\[a,b,c] -> mid a b c) (permutations [1,2,3])
13:19:26 <lambdabot>   [2,2,2,2,2,2]
13:19:31 <dmwit> parcs`: =)
13:21:04 <parcs`> dmwit: that does branching
13:21:18 <dmwit> ?src min
13:21:18 <lambdabot> min x y = if x <= y then x else y
13:21:22 <dmwit> parcs`: ?
13:21:50 <Justinba1010> also is there such thing as haskell homework...?
13:21:53 <HairyDude> what's a good type to use for, say, currency?
13:22:18 <dmwit> If you want to avoid branching, you have to use things like (-) and (.|.); min and max just don't cut it.
13:22:34 <dino-> stepkut on #happs got my happstack thing sorted out. Turns out need takeRequestBody and not decodeBody .. >> getData or similar
13:22:44 <Justinba1010> I mean Java ofcourse, but Haskell, I don't think Haskell is truly a peaking language
13:22:44 <dmwit> HairyDude: One of the fixed-point types, depending on how many digits of accuracy you need.
13:22:50 <applicative> Justinba1010: yes, Haskell is sometimes used for teaching general computer science.  You can find hundreds of tic tac toe immplementations with google
13:22:50 <HairyDude> I only need 2
13:22:57 <HairyDude> probably
13:23:04 <dmwit> scary assertion
13:23:06 <Justinba1010> wow never new that
13:23:14 <Justinba1010> knew*
13:23:17 <parcs`> dmwit: oh
13:23:20 <dmwit> Not doing any foreign currencies (with associated exchange rates)?
13:23:22 <Justinba1010> wow never knew that
13:23:55 <applicative> Justinba1010: http://stackoverflow.com/questions/tagged/haskell+homework for example
13:24:45 <Justinba1010> wow, haskell blows over php in ease
13:24:53 <Justinba1010> atleast it's no fortran
13:25:02 <HairyDude> I guess I could just represent everything as Int, but that makes parsing a bit awkward
13:25:11 <parcs`> > let min a b = b + ((a-b) .&. (a-b) `shiftR` 31) in min 10 5
13:25:12 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:25:12 <lambdabot>    `Data.Bits.Bits a'
13:25:12 <lambdabot>      a...
13:25:19 <HairyDude> I don't really need to do any arithmetic
13:25:20 <JoeyA> Justinba1010: Well, depends what libraries you use and what you're trying to do and such.
13:25:21 <adnauseam> given the code @ http://pastebin.com/dRV4cZPd , can i represenr (
13:25:23 <parcs`> > let min a b = b + ((a-b) .&. (a-b) `shiftR` 31) in min 10 5 :: Int32
13:25:23 <mauke> The paste dRV4cZPd has been copied to http://hpaste.org/69863
13:25:25 <lambdabot>   5
13:25:34 <parcs`> > let min a b = b + ((a-b) .&. (a-b) `shiftR` 31) in min 10 5 :: Int64
13:25:36 <lambdabot>   5
13:25:40 <parcs`> magic
13:25:50 <Justinba1010> but we can agree, fortran is no easy language to get used to
13:26:00 <Justinba1010> like PHP took me 8 months to get it done
13:26:10 <Justinba1010> and Objectation is the true hard part
13:26:25 <Justinba1010> OOP I should call it :D
13:26:25 <rwbarton> > let min a b = b + ((a-b) .&. (a-b) `shiftR` 31) in min 5 10 :: Int32
13:26:26 <HairyDude> frankly, I can't stand any imperative language now
13:26:26 <lambdabot>   5
13:26:43 <Justinba1010> well I have trouble moving across
13:26:56 <Justinba1010> I mean I wish I started with Java...
13:26:57 <adnauseam> given the code @ http://pastebin.com/dRV4cZPd , can i represent (\f\x -> f x) + with  (Lambda "f" (Lambda "x" (Appl (Appl (Var "f") (Var "x")) (Var "+")))) ?
13:26:57 <mauke> The paste dRV4cZPd has been copied to http://hpaste.org/69863
13:27:00 <tgeeky> HairyDude: Haskell is the finest imperative language out there today -- SPJ
13:27:02 <Justinba1010> it would make life so easy
13:27:20 <HairyDude> tgeeky: well, true... I don't know any other language that has user-definable control structures :)
13:27:20 <Justinba1010> no doubt it has 20 years of work on it
13:28:10 <Phlogistique> HairyDude: what, did you hear about, like Lisp?
13:28:12 <Phlogistique> Forth?
13:28:27 <HairyDude> Phlogistique: yeah, but those aren't imperative languages
13:28:32 <Justinba1010> well Fortan has influenced 25 languages
13:28:37 <HairyDude> (any more than Haskell is, anyway)
13:28:37 <Phlogistique> HairyDude: yes they are
13:28:40 <Justinba1010> very good for an imperative language
13:28:51 <Phlogistique> HairyDude: yes they are, more than Haskell
13:28:57 <HairyDude> ... well, Forth is, Lisp is kind of pseudo-imperative
13:29:10 <HairyDude> but I concede the point
13:29:13 <Justinba1010> well are there objects in Haskell?
13:29:24 <HairyDude> Justinba1010: define object
13:29:25 <tac-tics> Everything is an object in Haskell.
13:29:37 <Justinba1010> functions that users can make
13:29:50 <HairyDude> what a weird definition of an object
13:29:57 <rwbarton> i sort of like it though
13:30:05 <Phlogistique> I don't understand it
13:30:29 <Justinba1010> I was trying to say what I use the most
13:30:35 <Justinba1010> methods
13:32:45 * hackagebot archive 1.2.12 - A library and programs for creating hardlinked incremental archives or backups  http://hackage.haskell.org/package/archive-1.2.12 (JeremyShaw)
13:33:20 <HairyDude> wonder why comodo keeps telling me it's found a new network when my computer is wired and immobile...
13:34:53 <taylorgb_> C++ specifies an object to be a region of storage, but I suppose most imperative languages consider it to be data whose structure is determined by some type. More generally in OOP I suppose people consider it to be a 'thing' that does something, usually modelled on a concept or real-world entity. The doing thing part is what makes the metaphor somewhat non-usable for pure-functional languages. Best settle on the category theory definition ;)
13:35:29 <ewtoombs> I'm looking at the list of gui libraries and I'm not reading what I most want to know.
13:35:32 <shapr> taylorgb_: Have you read Luca Cardelli's papers on OOP?
13:35:52 <ewtoombs> What gui libraries are in active use and have been proven usable and stable?
13:35:55 <HairyDude> the definition of "object" varies wildly by language
13:36:01 <taylorgb_> Sadly not, I'm somewhat behind on my reading
13:36:12 <Justinba1010> sadly it does
13:36:19 <windcask> hello.
13:36:28 <MagneticDuckling> Say I have a Maybe a value but a is not necessarily Eq. What's a single line way to test is it is nothing, (as (==Nothing) doesn't work if a is not in Eq)
13:36:49 <raek_> MagneticDuckling: pattern match on the value
13:36:50 <windcask> I have a quick question: are there any webhosts that support haskell?
13:36:53 <HairyDude> ewtoombs: I know there is gtk2hs and probably a port of wxwidgets, but I don't know how good either is
13:36:58 <tac-tics> MagneticDuckling: pattern match with a case statement
13:37:06 <Justinba1010> I think taylor and I have replied on separate remarks
13:37:09 <mroman> gt2hs always worked fine for me.
13:37:11 <Cale> :t isJust
13:37:12 <mroman> *gkt2hs
13:37:12 <lambdabot> forall a. Maybe a -> Bool
13:37:15 <Cale> :t isNothing
13:37:17 <taylorgb_> windcask: They don't really need to support it, you can run it via fast-cgi or whatever
13:37:17 <lambdabot> forall a. Maybe a -> Bool
13:37:22 <tac-tics> > case Nothing of Nothing -> True | Just _ -> False
13:37:23 <lambdabot>   <no location info>: parse error on input `|'
13:37:26 <tac-tics> erk
13:37:27 <Cale> But yes, usually you just want to pattern match
13:37:33 <tac-tics> > case Nothing of Nothing -> True; Just _ -> False
13:37:34 <lambdabot>   True
13:37:44 <MagneticDuckling> Ty cale
13:37:46 <tac-tics> > case Just (\() -> *() of Nothing -> True | Just _ -> False
13:37:47 <lambdabot>   <no location info>: parse error on input `*'
13:37:50 <windcask> taylorgb_ thank you
13:37:56 <tac-tics> > case Just (\() -> *()) of Nothing -> True | Just _ -> False
13:37:57 <lambdabot>   <no location info>: parse error on input `*'
13:38:00 <taylorgb_> Of course it depends what kind of requirements you have
13:38:01 <ewtoombs> hm. that's one sort of vote for gtk2hs
13:38:02 <tac-tics> erk...
13:38:07 <ewtoombs> helpful...
13:38:12 <Cale> because usually if you go to the trouble of finding out that a value is Just x you also want to know what x is
13:38:21 <ewtoombs> I thought gtk was horrible, though.
13:38:35 <elliott> Every GUI framework is horrible.
13:38:40 <ewtoombs> oh
13:38:59 <MagneticDuckling> I know how to do it with a case pattern matching
13:38:59 <HairyDude> why does installing cabal-dev want to reinstall HTTP?
13:39:56 <shapr> ewtoombs: another vote for gtk2hs
13:40:00 <ewtoombs> lol
13:40:06 <shapr> ewtoombs: and another vote for "GUI frameworks suck"
13:40:20 <ewtoombs> also lol
13:40:21 <alpounet> HairyDude, maybe it *requires* a more recent version than the one you already have?
13:40:34 <HairyDude> alpounet: then how did I manage to install it?
13:41:02 <alpounet> HairyDude, "it" being ... ?
13:41:06 <HairyDude> HTTP
13:41:18 <uniquenick> if I have a function "foo a b c d e" how can I partially apply it to just say, c, and get a function "foo2 a b d e"?
13:41:32 <shachaf> (\a b d e -> foo a b c d e)
13:41:46 <HairyDude> ... sorry, I'm probably not making any sense
13:41:48 <shachaf> (\a b -> foo a b c) also works.
13:42:13 <alpounet> HairyDude, iirc, HTTP is bundled with haskell-platform
13:42:32 <HairyDude> alpounet: I installed everything via cabal
13:42:38 <alpounet> because, e.g, cabal-install needs it
13:43:22 <applicative> uniquenick: there's no doubt a library that defines flip3of5 or whatever :)
13:43:25 <ewtoombs> In the "abstract away the horrible!" category, I see grapefruit. Any thoughts on that?
13:43:41 <HairyDude> right, what is happening here is: I am trying to install cabal-dev. cabal-install gives me a list of things it would change and says a bunch of things would be broken by those changes
13:44:14 <HairyDude> included in those changes is a reinstall of network and HTTP, both include upgrading parsec, the latter includes downgrading mtl
13:44:23 <HairyDude> it's not clear why
13:46:08 <dcoutts_> ewtoombs: I've used gtk2hs for commercial projects, no problem.
13:46:24 <elliott> ewtoombs: grapefruit is not really usable for real programs afaik
13:46:53 <elliott> ewtoombs: reactive-banana is about as horrible-abstracting-away as you'll get (see also reactive-banana-wx, but the equivalent for gtk2hs is ~30 lines of boilerplate)
13:46:58 <elliott> (maybe less)
13:49:32 <applicative> HairyDude: is it cabal-dev that has the out of date dependency?
13:49:55 <HairyDude> applicative: well cabal-dev depends on transformers 0.2.*, I have 0.3 installed... trying to figure out what else
13:52:01 <HairyDude> ah, I guess when it says reinstall, it's reinstalling because its dependencies are changing?
13:52:08 <ewtoombs> elliott: would that be 30 lines total or 30 lines of horrible to the line of abstract?
13:52:41 <hayashi> You know you've ghci'd too much when you try to exit bash with :q.
13:52:50 <elliott> ^D works to exit ghci,ttoo. :p
13:52:55 <elliott> ewtoombs: Eh?
13:53:10 <elliott> ewtoombs: I mean that writing the equivalent of reactive-banana-wx for Gtk2Hs only takes about 30 lines.
13:53:34 <ewtoombs> oh
13:54:07 <ewtoombs> dcoutts: thanks for the input, btw
13:54:13 <dcoutts_> np
13:54:34 <applicative> HairyDude: is  there much to be said against getting https://github.com/dysinger/cabal-dev
13:55:18 <ewtoombs> oh, what about UI design? Do you ever need to use glade or anything, or do you just do it in source code?
13:55:39 <dcoutts_> ewtoombs: you can use either or both
13:55:42 <applicative> HairyDude: they just haven't responded to the second pull request https://github.com/creswick/cabal-dev/pulls which is trivial
13:55:57 <shoerain> hayashi: that sounds more like vim =o
13:56:10 <ewtoombs> oh. How about on your commercial projects, though? Did you have to use glade?
13:56:45 <armlesshobo> shoerain: lol
13:56:45 <hayashi> funnily enough, I use emacs
13:57:39 <dcoutts_> ewtoombs: for that project we did not use glade
13:57:42 <HairyDude> ... ah... yes, I remember that now. But I still couldn't install...
13:58:06 <ewtoombs> dcoutts_: oh, ok. Good to know.
13:58:08 <dcoutts_> ewtoombs: where as for example with ThreadScope we do use glade as well as making some stuff in code
13:58:12 <applicative> hm what was the error like in that case?
13:58:28 <HairyDude> I don't remember... let me try again
13:58:56 * dmwit doesn't find gtk2hs horrible at all
13:59:51 * applicative notes that threadscope depends on a pre-present-Platform mtl
14:00:08 <hpaste_> HairyDude pasted “cabal-dev build error” at http://hpaste.org/69867
14:00:14 <MagneticDuckling> Just a question from a newbie about something that's been bothering me... Why is Writer a newtype for (,) and not a data type?? (data Writer a m = Writer a m)
14:00:16 <armlesshobo> dmwit: yeah, it's too bad for simple things; i've written a simple image viewer with it before
14:00:32 <elliott> MagneticDuckling: There's no real reason.
14:00:36 <elliott> MagneticDuckling: But it's dual to Reader.
14:00:45 <elliott> (r -> a) vs. (w, a)
14:00:50 <MagneticDuckling> Oh
14:00:54 <elliott> So it's easier to see the correspondance in that form.
14:01:04 <MagneticDuckling> Hm
14:01:09 <elliott> MagneticDuckling: All of the standard transformers are newtypes over some "conceptual" definition like that, I think.
14:01:14 <elliott> Like state is s -> (s, a).
14:01:17 <elliott> (Or is it (a, s)? I forget.)
14:01:22 <HairyDude> applicative: http://hpaste.org/69867
14:01:30 <gienah> HairyDude: useless error, need more info
14:01:40 <nand`> (a, s) in the mtl iirc; (s, a) in some GHC internal types
14:01:45 <HairyDude> applicative: that's all there is
14:01:46 <Sgeo_> What's the difference between laziness and nonstrictness?
14:02:13 <dmwit> Sgeo_: laziness also implies sharing
14:02:16 <elliott> Sgeo_: Non-strictness is about operational semantics.
14:02:23 <elliott> Laziness is a certain implementation strategy of non-strictness (call by need).
14:02:30 <HairyDude> I'll do a clean build with that patch installed and paste all the messages
14:02:33 <nand`> under “nonstrictness” I'd understand “consumes its parameter lazily”
14:02:36 <applicative> try cabal clean then cabal install -v 3
14:02:38 <elliott> You could also implement non-strictness with call by name (recalculating results every time).
14:02:46 <elliott> nand`: No, that's not what non-strict semantics are.
14:02:49 <nand`> oh okay
14:02:59 <hpaste_> ifnspifn pasted “boggle solver” at http://hpaste.org/69868
14:03:20 <elliott> Sgeo_: Non-strictness just means that if there's any terminating evaluation order of an expression, then it will terminate, pretty much.
14:03:54 <Sgeo_> elliott, wouldn't that make Haskell not nonstrict in some circumstances?
14:04:02 <rtharper> Of course
14:04:06 <rtharper> some functins are strict =p
14:04:09 <rtharper> functions
14:04:30 <Sgeo_> I meant, in cases where, barring use of unamb, you pretty much need to try an evaluation order
14:04:30 <ifnspifn> Heya. So, I've written my first significant haskell program (130ish lines of code) that solves Boggle problems by returning a list of posssible words, sorted by value. It's probably ugly as all heck to you guys, but I thought someone might be interested in looking at it; if you have an comments or feel any large amount of disgust/horror towards it, let me know :]
14:04:33 <Sgeo_> @src (||)
14:04:33 <lambdabot> True  || _ =  True
14:04:33 <lambdabot> False || x =  x
14:04:40 <ewtoombs> oh, completely unrelated question: I was looking everywhere for a standard api function that removes element n from a list and I couldn't find one.
14:04:43 <ewtoombs> Is there one?
14:04:46 <Sgeo_> > undefined || True
14:04:48 <lambdabot>   *Exception: Prelude.undefined
14:04:51 <elliott> Sgeo_: If you "must" use an evaluation order, than the other evaluation orders don't exist.
14:04:58 <elliott> There is no terminating evaluation order of (undefined || True) there.
14:05:09 <elliott> *then
14:05:15 <Sgeo_> In principle there should be
14:05:18 <elliott> No.
14:05:26 <rtharper> what principle? =p
14:05:29 <elliott> You are saying you want a different (||).
14:05:40 <ifnspifn> ewtoombs: In Data.List, there's \\
14:05:41 <elliott> That may be true, but it's irrelevant -- given that (||), there's no terminating evaluation order of (undefined || True).
14:05:49 <ewtoombs> (basically, I was stuck with splitting the list into a and b, then joining a with the tail of b.)
14:05:49 <elliott> That is, let's inline (||):
14:05:56 <elliott> case undefined of True -> True; False -> True
14:06:04 <elliott> There is no evaluation order that makes this anything other than _|_.
14:06:04 <ewtoombs> ifnspifn: I shall have to ha ve a look
14:06:25 <ifnspifn> ewtoombs: iirc, it's used like so: "[1,2,3] \\ [2] == [1,3]"
14:06:25 <dmwit> Sgeo_: It's easier to believe if you write (||) in this way: (||) x y = case x of { True -> True; False -> y }
14:06:32 <HairyDude> ... I can't figure out how to download that diff :|
14:06:51 <Sgeo_> By that definition, could all languages be considered nonstrict, they just only allow you to write completely strict functions?
14:07:07 <dmwit> Sgeo_: Changing the "evaluation order" isn't allowed to change the "case" statement from scrutinizing "x" to scrutinizing "y".
14:07:12 <Sgeo_> (For languages normally considered 'strict', I mean)
14:07:50 <elliott> Sgeo_: Well, if you want a definition that avoids that: a non-strict language is a language with non-strict functions.
14:07:59 <elliott> That is, f _|_ is something other than _|_ for some f.
14:08:32 <ewtoombs> I wanted to delete by index, though. Not with a search, since I know the index of the element I want to remove.
14:08:57 <dmwit> ewtoombs: There isn't one, and you shouldn't want one. =)
14:09:13 <HairyDude> got it. resorted to view source and finding a link rel=alternative...
14:09:22 <Cale> If you want to work with elements by index, then lists are not the right data structure
14:09:24 <ifnspifn> ewtoombs: imperative talk like that's fighting words around here
14:09:39 <Cale> You might want Data.Sequence
14:09:51 <Cale> or Data.Map/IntMap
14:10:02 <dmwit> Cale's answer is better. It's not about imperative vs. functional, it's about linked-list vs. something more appropriate.
14:10:17 <ewtoombs> It's not imperative. It loses information, but it's information I don't need.
14:10:33 <Cale> Yeah, this has nothing to do with imperative/functional
14:10:38 <ewtoombs> Its input is a list and so is its output.
14:11:14 <Cale> ewtoombs: If you really want to stick with lists, you want splitAt
14:11:47 <elliott> ewtoombs: You shouldn't be using a list.
14:11:47 <Cale> But generally you want to minimise the number of list operations that you do which involve random accesses of any kind
14:11:49 <ewtoombs> That's what I decided on, but I think I'd rather change the data type anyway, since list deletion is order n
14:11:53 <ewtoombs> = horror
14:12:23 <hpaste_> HairyDude pasted “cabal-dev build error, fresh attempt” at http://hpaste.org/69869
14:12:29 <gienah> HairyDude: the gentoo cabal-dev patch can be downloaded: https://github.com/markwright/gentoo-haskell/raw/master/dev-haskell/cabal-dev/files/cabal-dev-0.9.1-tf-0.3.patch
14:12:32 <ewtoombs> so I need indexable, insertable order 1, deletable order 1
14:12:41 <HairyDude> gienah: I got it alread
14:12:42 <HairyDude> y
14:12:52 <ewtoombs> (amortised order 1 allowed)
14:13:08 <ewtoombs> *indexable order 1
14:13:30 <niteria> is there a book on type hackery?
14:13:50 <merijn> niteria: How advanced?
14:13:57 <ewtoombs> so there's Sequence, Map, and IntMap to examine.
14:14:00 <merijn> TaPL is supposedly a good intro book
14:14:05 <ewtoombs> time to get busy
14:14:07 <c_wraith> Sequence is nothing like the other two
14:14:37 <ClaudiusMaximus> ifnspifn: your  tuplify . pairify  is  zip`ap`tail  but with O(n^2) complexity and an Eq constraint, as far as i can tell
14:14:39 <ewtoombs> (that is time for me to get busy. I'm not a boss...)
14:14:41 <niteria> merijn: I mean some place you can learn about Phantom Types, GADTs etc.
14:14:43 <Cale> ewtoombs: You actually can't index any structure in O(1) time, because that doesn't allow for enough time to examine all the bits of the index
14:14:45 <merijn> ewtoombs: Also maybe Array? (Not sure, missed the conversation start, but it seems an obvious place if you index frequently)
14:14:59 <Cale> But you can do O(log n), and that's what Data.Sequence gives you
14:15:02 <niteria> merijn: TaPL seems more related to implementation
14:15:16 <niteria> I'm more interested in usage
14:15:22 <merijn> niteria: I think that's mostly Typeclassopedia, wikibooks and papers? But someone else may prove me wrong
14:15:25 <gienah> HairyDude: I wonder which cabal-install and Cabal you have, this prints it: cabal -V
14:15:58 <HairyDude> gienah: cabal-install 0.14.0, cabal library 1.14.0
14:16:30 <merijn> Cale: Well, if you have a fixed number of bits the O(n) for examining bits becomes a constant (fixed number of bits = fixed number of operations) and hence O(1), no?
14:16:41 <HairyDude> ghc 7.4.2, if that's interesting
14:16:55 <rwbarton> then guess what, your data structure has bounded size so anything is "O(1)"
14:16:59 <applicative> ifnspifn: the paste looks pretty good to me, but what do I know... often people define swap (a,b) = (b,a) then bidirect edges = edges ++ map swap edges, for example
14:17:10 <HairyDude> oh, also, it's not at all obvious that this is Windows XP
14:17:11 <elliott> ewtoombs: The whole "I want O(1) everything" thing is something you're not going to get from immutable data structures.
14:17:24 <ewtoombs> what the hell... Data.{Sequence,Map,Intmap} aren't in the docs I'm reading...
14:17:26 <elliott> ewtoombs: But (a) mutable structures aren't really O(1) either, and (b) you probably don't actually need O(1).
14:17:35 <elliott> ewtoombs: They're in the containers package.
14:17:37 <elliott> @hackage containers
14:17:37 <lambdabot> http://hackage.haskell.org/package/containers
14:17:45 <ewtoombs> oh
14:18:15 <applicative> ewtoombs: they also come somewhere with  typical ways of installing ghc and co.
14:18:21 <MagneticDuckling> It's a bit late here, so my brain is probably not working properly, but I'm trying to understand how the tell function works... namely how monads deal with ()
14:18:32 <MagneticDuckling> @t ()
14:18:33 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:18:40 <applicative> @type tell
14:18:41 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
14:19:07 <ClaudiusMaximus> ifnspifn: also you're using foldr to implement map and filter in several places, whish is a bit unidiomatic
14:19:08 <HairyDude> doesn't writer need a monoid?
14:19:09 <parcs`> MagneticDuckling: tell w = (w, ())
14:19:24 <gienah> HairyDude: I guess I'm starting to think the cabal-dev source code might have some problem on windows, might need to look in the cabal-dev source code and see what its doing
14:19:39 <HairyDude> ok
14:19:45 <HairyDude> I'm available for testing if you need me
14:19:54 <MagneticDuckling> MonadWriter is a type class?
14:20:05 <gienah> HairyDude: searching for the strings like "Interrogating cabal-install executable" in the cabal-dev source code
14:21:05 <gienah> HairyDude: and in Setup.hs or Setup.lhs
14:21:47 <ewtoombs> ooh. finger trees
14:21:52 <ewtoombs> tasty
14:22:18 <elliott> MagneticDuckling: Yeah.
14:22:19 <ewtoombs> yeah, sequence is probably appropriate for these operations.
14:22:30 <ewtoombs> *Sequence
14:22:39 <MagneticDuckling> I thought "tell :: (Monoid m) => a -> Writer m a"...
14:22:56 <ewtoombs> since programmers are case-sensitive lol
14:23:05 <Peaker> @hoogle tell
14:23:06 <lambdabot> Control.Monad.Trans.RWS.Lazy tell :: (Monoid w, Monad m) => w -> RWST r w s m ()
14:23:06 <lambdabot> Control.Monad.Trans.RWS.Strict tell :: (Monoid w, Monad m) => w -> RWST r w s m ()
14:23:06 <lambdabot> Control.Monad.Trans.Writer.Lazy tell :: (Monoid w, Monad m) => w -> WriterT w m ()
14:23:07 <parcs`> MagneticDuckling: no, that's return
14:23:12 <MagneticDuckling> Btw have pity because I'm working on a laggy iPod
14:23:30 <MagneticDuckling> Oh...
14:23:31 <Peaker> tell :: (Monoid w, Monad m) => w -> WriterT w m ()
14:23:43 <elliott> MagneticDuckling: Writer is an instance of MondaWriter
14:23:47 <elliott> Peaker: not in mtl
14:23:51 <elliott> *MonadWriter
14:24:02 <Peaker> If you use the MonadWriter type-class, then it is:   tell :: MonadWriter w m => w -> m ()
14:24:06 <elliott> MagneticDuckling: it's there for monad transformer stacks; if you don't know what they are, just assume your quoted type is correct
14:24:12 <MagneticDuckling> Rrr
14:24:42 <MagneticDuckling> *rereads everything and goes to sleep*
14:25:34 <ewtoombs> actually this list is traversed and appended more often than it is inserted or deleted and the lists will be small enough that O(n) indexing/insertion/deletion won't matter. Which would mean it really would be nice to have a function that deletes and inserts elements in Lists.
14:25:36 <Peaker> MagneticDuckling, where did you get that type? It sounds like it's from an old version of transformers?
14:25:48 <ewtoombs> Looks like I'm making it myself lol
14:26:00 <Peaker> @hoogle delete
14:26:01 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
14:26:01 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
14:26:01 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
14:26:09 <MagneticDuckling> Which? Writer?
14:26:11 <Peaker> ewtoombs, there are functions to insert/delete
14:26:22 <elliott> ewtoombs: Indexing a list is ugly even if you don't care about the cost.
14:26:26 <Peaker> MagneticDuckling, tell :: (Monoid m) => a -> Writer m a          <-- where is this type from?
14:26:30 <ifnspifn> ClaudiusMaximus: ah, I see what you mean. I guess that, for the most part, if I'm constructing a list using fold, I'm doing it wrong
14:27:58 <applicative> ifnspifn: it's not wrong just oversophisticated
14:27:58 <ewtoombs> elliott: as ugly as indexing is, searching just to delete an element whose location you already know is worse
14:28:21 <ewtoombs> and there are no functions for deleting an element at a location.
14:28:21 <Zariel> Is (<-) the same as >>= ?
14:28:32 <ewtoombs> *at an index
14:28:38 <applicative> Zariel: no
14:28:47 <applicative> Zariel: how did the question arise
14:28:53 <gienah> HairyDude: some discussion here as the windows cabal-dev stuff was being developed: https://github.com/creswick/cabal-dev/pull/24
14:28:55 <parcs`> Zariel: do syntax desugars to >>=
14:28:56 <MagneticDuckling> I was brought up thinking that "newtype Writer a w = Writer {runWriter = (w, a)}"
14:29:09 <elliott> ewtoombs: Right. So don't use a list.
14:29:09 <ewtoombs> in fact there is no function for deleting an element at an index in Data.Sequence either!
14:29:21 <Zariel> I mean doing >>= and doing <- in do, do the same thing ?
14:29:21 <elliott> MagneticDuckling: It is.
14:29:23 <elliott> Except :: intsead of =.
14:29:42 <merijn> @undo do { foo <- bar; f foo }
14:29:43 <lambdabot> bar >>= \ foo -> f foo
14:30:03 <applicative> Zariel: a line reading " contents <- readFile z" is the same as a line reading "readFile x  >>= \contents -> "
14:30:17 <Zariel> Well thats finally clicked :D
14:30:34 <merijn> Zariel: The above shows the relation between syntactic sugar and "normal form", it's just a prettier way to introduce a variable binding (using lambda) and using >>=
14:30:35 <Zariel> is do notation just sintactic sugar then?
14:30:48 <applicative> Zariel: yes
14:30:50 <merijn> Zariel: Yup, works for arbitrary monads like Maybe and List too
14:31:01 <Zariel> ah awesome thanks very much
14:31:14 <MagneticDuckling> Elliott: Kay then.. but then what's WriterT?
14:31:22 <adnauseam> how come is my data def failing? data LExpr = Var Name | Constant Integer | Lambda Name LExpr | Appl LExpr LExpr (deriving Show) ?
14:31:42 <merijn> Zariel: If you're now thinking "man, I can't belief it too me so long to see that!" then you've almost finished your path of monad enlightenment :p
14:31:45 <HairyDude> gienah: I guess it invokes cabal-install incorrectly resulting in a "user error" from it?
14:31:49 <merijn> s/belief/believe
14:31:50 <applicative> adnauseam: whats the error>
14:32:27 <adnauseam> 07.lhs:13:84: parse error on input `deriving'
14:32:36 <Zariel> merijn: getting there :), been using <- for ages but just understood what >>= does now
14:32:41 <applicative> right, paren should be after deriving
14:32:45 <adnauseam> seems like a syntax error of some sort ut i dont see it
14:32:51 <applicative> deriving (Show, Eq,Ord)
14:32:58 <adnauseam> oh shi...
14:33:01 <adnauseam> \thanks man
14:33:03 <applicative> not (deriving Show, Eq , Ord)
14:33:44 <MagneticDuckling> That deriving syntax always seemed very stiff to me
14:34:19 <Peaker> MagneticDuckling, it is a valid Writer, but that is not how it is defined in the contemporary library
14:34:38 <Peaker> MagneticDuckling, transformers defines WriterT, not Writer, and then Writer is just a synonym to WriterT with Identity
14:34:55 <Peaker> MagneticDuckling, and mtl re-exports the same Writer, I believe, along with the type-class
14:35:04 <MagneticDuckling> So this is how Haskell is "unorganized"
14:35:16 <Peaker> MagneticDuckling, what do you mean?
14:35:27 <applicative> it's so rational now, MagneticDuckling
14:35:38 <Peaker> MagneticDuckling, it's pretty organized -- there's one type defined for WriterT, and everything else just wraps it up with an extra feature or such
14:35:59 <MagneticDuckling> Oh, okay
14:36:10 <Peaker> MagneticDuckling, If Writer w a = (w, a)    WriterT w m a = m (w, a)
14:36:11 <MagneticDuckling> Nm then ^^
14:36:30 <Peaker> So Writer w a  is basically the same thing as    WriterT w Identity a
14:36:41 <applicative> there was a battle of incompatible monad transformer libraries when I was first using haskell
14:36:45 <Peaker> (because Identity a is just a newtype around a that doesn't change anything)
14:37:08 <MagneticDuckling> applicative: hard times then
14:37:51 <gienah> HairyDude: I'm not sure, if the 'user error' string does not appear in the cabal-dev src code, then you could search in the cabal-install and Cabal library source code
14:38:25 <MagneticDuckling> Btw just a word of advice: NEVER come on #haskell and type code with a laggy iPod
14:38:32 <HairyDude> gienah: only matches binaries
14:38:42 <MagneticDuckling> ._.
14:38:43 <tgeeky> Peaker: that's all transformers are? Just lifting the type to have an explicit context?
14:38:44 <Peaker> HairyDude, what's the exact error string?
14:39:04 <HairyDude> Peaker: http://hpaste.org/69869
14:39:45 <Peaker> tgeeky, well, writer is a simple case of transformer (just stick an "m" around the original Writer).  Other transformers have different type changes vs. the simple monad
14:40:03 <hpc> @unmtl ReaderT r m a
14:40:03 <lambdabot> r -> m a
14:40:08 <hpc> Δ for instance
14:40:10 <Peaker> tgeeky, Reader r a = r -> a    vs.   ReaderT r m a = r -> m a
14:40:12 <tgeeky> but it 's all about what's sitting outside the tuple
14:40:23 <ewtoombs> oh, I have a question: Suppose a is some kind of object. It doesn't matter what. b may be set equal to a in a let ... in ... expression or something. Then both a and b will be in scope. Is there a way to test to see if a and b are the same thing? (i.e. not ==. the equivalent in c would be a pointer comparison.)
14:40:24 <Peaker> s -> (s, a)     vs.   s -> m (s, a)
14:40:31 <tgeeky> yeah
14:40:39 <tgeeky> but you could also systematically reorder the things inside the tuple
14:40:48 <Peaker> Cont r a = (a -> r) -> r        ContT r m a = (a -> m r) -> m r
14:40:50 <hpc> incidentally, StateT is a transformation of ReaderT and WriterT
14:40:58 <hpc> kinda
14:41:49 <Peaker> ewtoombs, Haskell has values, not objects.. Namely the difference is that values don't have an identity to compare
14:41:56 <tgeeky> Peaker: I'm reading Hinze's Lifing Operators and Laws ...
14:42:03 <ewtoombs> Peaker: I don't get it.
14:42:35 <ewtoombs> Peaker: couldn't you easily have the same object twice in a list for instance?
14:42:44 <Peaker> ewtoombs, a and b are values, not objects. They don't have an "identity".   In GHC's implementation they may get an actual implementation-specific "identity" in practice, and that's very-unsafely comparable in runtime, but it is not really sound to do that
14:42:58 <kqr_> does it make sense to do the same distinction between primitive expressions and compound expressions as in scheme, but in haskell? where for example 4 or "hello" would be literal expressions, and "3 + 4" would be a function application?
14:43:09 <Peaker> ewtoombs, Referential transparency means that if a == b,  you can't tell if they are the "same" object, or if they are just equivalent constructions
14:43:35 <ewtoombs> I know what == does. I'm not talking about it.
14:43:41 <hpc> kqr_: it makes sense to make the distinction, but it isn't the same one
14:43:50 <tgeeky> Peaker: ah, right. If they had any more information than they would require for equivalence, then they shouldn't pass "sameness" anyway
14:43:51 <hpc> in haskell, the difference is almost entirely syntactic
14:43:53 <hpc> and not semantic
14:44:05 <gienah> HairyDude: the cabal-install and Cabal src code is on hackage: http://hackage.haskell.org/packages/archive/cabal-install/0.14.0/cabal-install-0.14.0.tar.gz http://hackage.haskell.org/packages/archive/Cabal/1.14.0/Cabal-1.14.0.tar.gz
14:44:08 <Peaker> ewtoombs, well, you're asking if there's a way to figure out if the identities are the same, and I'm saying that Haskell doesn't have the notion of "identities" that is very common in other languages
14:44:13 <ewtoombs> Peaker: does that mean if you do something like [a] ++ [a], it will copy a?
14:44:33 <HairyDude> hum. cabal fetch cabal-install gets 0.10.2 but I have 0.14.0
14:44:45 <Peaker> ewtoombs, no, it can share 'a', but if it copied, you wouldn't have any way to tell :)
14:44:53 <Peaker> (except for it running a bit longer and/or heating the cpu more)
14:45:03 <jfischoff> and stuff does get copied all the time
14:45:05 <kqr_> hpc, yes, i was thinking that. i know strings, characters, rational numbers and integers are defined in the syntax as literals, but values like True and False behaves just like those literals, so would it make sense to call them literals too?
14:45:31 <hpc> kqr_: those are identifiers, i would say
14:45:31 <Peaker> kqr_, True and False are just data constructors
14:45:34 <gienah> HairyDude: not sure why it wants to fetch the wrong version. I have to go out for several hours.
14:45:38 <Peaker> @src Bool
14:45:39 <lambdabot> data Bool = False | True deriving (Eq, Ord)
14:45:41 <hpc> they are names you can bind values to
14:45:47 <hpc> as opposed to literals which you can't
14:45:51 <Peaker> kqr_, If "True" and "False" are literals, then "Nothing" and "Just" are also literals?
14:45:55 <ewtoombs> so a list may refer to a twice. How is it not useful to do a comparison between elements of a list and remove duplicates, for instance?
14:46:04 <kqr_> Peaker, i was thinking about just that, and i'm having doubts
14:46:15 <ewtoombs> this should be possible even if the objects in the list aren't Eq.
14:46:23 <Peaker> ewtoombs, it is useful to do a comparison for equivalence with ==, not a comparison for identities, because that would expose identities, which is bad
14:46:41 <Peaker> ewtoombs, what if the values in the list are of type (Integer -> Integer) ?
14:46:43 <ewtoombs> == takes way longer.
14:47:02 <rwbarton> surely that is not going to stop ewtoombs from asking for pointer equality
14:47:09 <hpc> ewtoombs: your hypothetical compare and dedupe (we will call it "nub" after the Prelude function) does different things for
14:47:20 <Peaker> ewtoombs, Well, you are basically arguing that the notion of identities is useful in many cases, and that is true: you can give explicit identities to your values and then compare those explicit identities
14:47:22 <hpc> (let n = 1 in nub [1,1])
14:47:27 <hpc> (nub [1,1])
14:47:39 <HairyDude> no hits for "user error" in cabal-install sources
14:47:42 <hpc> (nub (map (+0) [1,1]))
14:48:00 <Peaker> ewtoombs, if you want a function for speed only, and don't care about false negatives in your comparisons, then you can use   reallyUnsafePtrEquality
14:48:05 <ewtoombs> rwbarton: don't be a phallus. I know haskell doesn't have pointers.
14:48:08 <Peaker> @hoogle reallyUnsafe
14:48:08 <lambdabot> No results found
14:48:14 <rwbarton> ...
14:48:17 <kqr_> doesn't == try to do some kind of pointer comparison first, and then do a deep comparison?
14:48:37 <hpc> why would it?
14:48:42 <applicative> > undefined == undefined
14:48:43 <lambdabot>   *Exception: Prelude.undefined
14:48:49 <Peaker> ewtoombs, http://www.haskell.org/ghc/docs/7.2.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#v:reallyUnsafePtrEquality-35-
14:48:56 <hpc> > let n = (0/0) in n==n
14:48:57 <lambdabot>   False
14:48:57 <applicative> it didnt  compare the 'pointers'
14:49:03 <shachaf> ewtoombs: You know, step 1 of asking for help on the Internet is usually "not being rude to the people for whose help you're asking".
14:49:06 <shachaf> Well, maybe that's step 4.
14:49:07 <Peaker> kqr_, it could, but that may be a de-ptimization in many cases
14:49:10 <HairyDude> none in Cabal source either... hmm
14:49:10 <rwbarton> all I was trying to say is that < Peaker> ewtoombs, what if the values in the list are of type (Integer -> Integer) ? -- the type of the thing being pointed to being something like a function would not preclude the possibility of pointer equality
14:49:11 <nobdraisentone> Is there some function to convert Either to Maybe? Like `Either a b -> Maybe b'
14:49:13 <shachaf> But it's still a step.
14:49:16 <kqr_> Peaker, oh
14:49:29 <rwbarton> Also, Haskell does too have pointers.
14:49:46 <applicative> nobdraisentone: good question
14:49:56 <Peaker> nobdraisentone, you can use:  either (const Nothing) Just
14:50:13 <dcoutts_> HairyDude: "user error" refers to the exception type you get from calling 'error'
14:50:19 <rwbarton> But they are not really relevant here.  Nevertheless what you are asking for is known as "pointer equality".
14:50:32 <HairyDude> dcoutts_: right, yeah, I just found an old ghc ticket mentioning it
14:51:10 <Peaker> from http://www.haskell.org/ghc/docs/7.2.2/html/libraries/ghc-prim-0.2.0.0/src/GHC-Prim.html#reallyUnsafePtrEquality%23 :
14:51:11 <nobdraisentone> Peaker: thanks
14:51:14 <Peaker> reallyUnsafePtrEquality# :: a -> a -> Int# ; reallyUnsafePtrEquality# = let x = x in x  <-- heh
14:51:21 <HairyDude> http://hackage.haskell.org/trac/ghc/ticket/1265 where the string passed to error wasn't being printed
14:52:11 <HairyDude>         -- XXX Needs updated for ghc 7
14:52:31 <HairyDude> that's in Distribution.Dev.InitPkgDb
14:53:02 <HairyDude> I suspect cabal-dev doesn't know my ghc version :(
14:53:11 <HairyDude> but the error message is very unhelpful
14:53:41 <rwbarton> And while GHC does use pointers to implement many types of data, it does not expose the operation of pointer equality (except through hacks like reallyUnsafePtrEquality#) because that is not part of the semantics of those types.
14:54:08 <ewtoombs> that doesn't make any sense. How can haskell not copy a in an expression like l = [a] ++ [a] and still not be able to check later if l!!0 and l!!1 are the same?
14:54:42 <applicative> ?
14:54:51 <rwbarton> ewtoombs: if I have int x = 6; int y; y = x; how can C not be able to check later if y and x are "the same"?
14:54:54 <ewtoombs> There's nothing unsafe about that.
14:55:08 <rwbarton> Or whether they "came from the same place"?
14:55:15 <HairyDude> dcoutts_: the example in that ticket doesn't say "user error" though...
14:55:21 <ewtoombs> sorrry, "that" referring to my example.
14:55:24 <HairyDude> on my ghc I mean
14:56:33 <rwbarton> The whole question makes no sense because there are not "different 6s" having "different identities".
14:56:40 <rwbarton> That's how it is in Haskell also.
14:56:54 <dcoutts_> HairyDude: oh actually, it's not 'error', it's the userError kind of IOError
14:57:13 <otters> ugh
14:57:17 <otters> I wish I could get a line number for exceptions
14:57:27 <HairyDude> dcoutts_: meaning a programmer-defined error, rather than, in fact, a user error?
14:57:36 <otters> cause stuff like ***Exception: user error (mzero) where I have no idea where it came from
14:57:38 <otters> makes me sad
14:57:46 <dcoutts_> HairyDude: in Cabal/cabal-install we use the userError kind of IOError for die, and the topHandler catches it and prints it
14:57:48 <otters> oh man, speak of the devil
14:58:05 <Peaker> ewtoombs, if you could distinguish, reliably, whether it was copied or not, it would mean that the compiler is not allowed to freely copy stuff for performance's sake
14:58:12 <Peaker> ewtoombs, or it would change the program's semantics
14:58:22 <HairyDude> dcoutts_: so what's causing this delightful error message?
14:58:41 <dcoutts_> HairyDude: what's the error message exactly?
14:58:47 * HairyDude sighs
14:58:49 <Peaker> ewtoombs, it would also mean that pure code had visible effects -- namely, copying vs. creating new values would be visible, despite having the exact same semantics, according to the equations
14:58:53 <HairyDude> dcoutts_: http://hpaste.org/69869
14:59:01 <dcoutts_> HairyDude: sorry, I wasn't in on the beginning of this conversation
14:59:09 <HairyDude> no worries :)
14:59:29 <Peaker> ewtoombs, your request contradicts referential transparency -- and referential transparency is very useful for reasoning about code, and limiting the scope of what a change could cause, and it is useful for compiler optimizations
14:59:46 <otters> what causes a user error?
14:59:57 <HairyDude> otters: installing cabal-dev
14:59:58 <ewtoombs> Oh, I think I get it now. I just wish that was in the tutorial or something.
15:00:04 <dcoutts_> HairyDude: ah so it's an error that occurred in some Template Haskell stuff
15:00:06 <hpc> :t error -- that causes user errors
15:00:07 <lambdabot> forall a. [Char] -> a
15:00:11 <applicative> ewtoombs if you could test for this, you could presumably use the results, then everything would go out the windo
15:00:12 <HairyDude> dcoutts_: looks like it
15:00:14 <applicative> window
15:00:44 <dcoutts_> HairyDude: so presumably the TH code deriveCabalCommands in cabal-dev is throwing the exception
15:00:45 <HairyDude> hpc: stupidity causes user errors :)
15:01:06 <dcoutts_> HairyDude: but yes it does look like the message is being swallowed
15:01:15 <HairyDude> dcoutts_: yes,  it's in Distribution.Dev.TH specifically
15:01:15 <dcoutts_> HairyDude: which would be a ghc/TH bug
15:01:49 <HairyDude> dcoutts_: http://hackage.haskell.org/trac/ghc/ticket/1265
15:01:53 <otters> HairyDude: really
15:02:04 <ewtoombs> This idea of abstracting away whether or not something is actually copied is really new to me here. I knew Haskell would be bizarre, but I didn't know it would be this bizarre.
15:02:12 <HairyDude> dcoutts_: the example in the description of that ticket works fine, though
15:02:51 <Peaker> ewtoombs, well, all programming languages implement abstractions, which hide things from you, for good reasons.. it's not that weird, it's just a different sort of abstraction that becomes possible/available with immutability
15:03:08 <tac-tics> ewtoombs: Life is wonderful when you can't actually bear witness to a mutable reference.
15:03:14 <tac-tics> bare?
15:03:31 <ewtoombs> bear
15:03:42 <tac-tics> no... I was right the first time. You can't see any bear witnesses. Giant woodland creatures which watch you unsafePerformIO
15:03:44 <otters> ohh, I see
15:03:45 <Peaker> ewtoombs, Java could be said to be weird in that it hides memory freeing from you
15:03:47 <hpc> ewtoombs: it gets easier when you realize that haskell is one of the rare languages where the equals sign is actually the equals sign
15:03:56 <otters> it's the use of "guard" inside a function that returns IO (Maybe Text)
15:04:02 <otters> and I guess IO's mzero is an error
15:04:41 <Peaker> otters, mzero/guard of IO in production code?
15:04:47 <otters> I guess
15:04:57 <GhostBarik> hi, guys! i have one question. Why i can't define just simple function like this func x = x + 2. I get some error from this online interpreter.
15:05:02 <ewtoombs> hpc: I am used to functional / immutable programming. I did about two semesters of it in Waterloo using scheme. Not knowing or caring whether something is copied is still new.
15:05:04 <Peaker> probably meant to use mzero of the Maybe
15:05:06 <otters> I was really going for guard to cause IO Nothing to be returned if the condition failed
15:05:08 <otters> yeah
15:05:12 <otters> I guess I didn't think it through
15:05:23 <Peaker> GhostBarik, the interpreter needs "let" prefix for definitions like that
15:05:24 <applicative> GhostBarik: which one are you using
15:05:29 <Peaker> GhostBarik, unlike files
15:05:35 <otters> I just don't want to put the rest of the function as the other branch of an if statement
15:05:36 <GhostBarik> i use this http://tryhaskell.org/#3
15:05:38 <otters> cause that seems ugly
15:05:39 <Peaker> GhostBarik, "let func x = x + 2"
15:05:43 <elliott> otters: use a guard
15:05:47 <GhostBarik> Tnx guys. Ye, it works
15:05:49 <otters> elliott: I thought I just did
15:05:54 <elliott> oh.
15:05:55 <elliott> ok then :)
15:06:01 <Peaker> otters, you can use MaybeT IO
15:06:03 <elliott> ha, you used the other kind of guard
15:06:07 <otters> wrong guard!
15:06:12 <elliott> I meant the | kind
15:06:16 <elliott> because I didn't read context
15:06:19 <elliott> (because who reads context)
15:06:23 <otters> it's still putting the whole thing into a guard
15:06:30 <HairyDude> :t guard
15:06:32 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:06:33 <Peaker> elliott, Haskell is pure, #haskell isn't :)
15:06:47 <HairyDude> #haskell fails the purity test?
15:07:10 <Peaker> otters, if you want to "short-circuit" out of the whole thing, then MaybeT sounds good.. if you want an explicit if/indent, just use if/when/unless?
15:07:58 <elliott> otters: just factor out the large branch into its own definition
15:08:00 <elliott> then if/then/else is ok
15:08:04 <Peaker> ewtoombs, in practice, you do care about copying vs. sharing due to performance reasons, but it is nice to have "modular reasoning". When you think about your program's correctness, you're free to ignore it completely. When you think about performance, then you do need to know exactly how it works under the hood
15:08:47 <rwbarton> scheme still has set-car! and set-cdr!, right
15:09:04 <Peaker> ewtoombs, stuff that gets put into names is shared, and function applications are re-computed
15:09:05 <shachaf> rwbarton: Didn't they take that out?
15:09:12 <shachaf> Maybe it was just Racket.
15:09:21 <Peaker> Isn't "Racket" the new name for Scheme?
15:09:34 <elliott> Peaker: you're kidding, right?
15:09:35 <ewtoombs> oh yeah about optimisation: I wrote a function for the fibonacci sequence like this:
15:09:36 <ewtoombs> f 0 = 0
15:09:36 <ewtoombs> f 1 = 1
15:09:36 <ewtoombs> f n = f (n - 1) + f (n - 2)
15:09:36 <ewtoombs> just to see if ghc could figure out the O(n) algorithm for computing this. I was surprised to see it couldn't.
15:09:55 <merijn> elliot: I suspect he meant "one of the few Schemes anyone still seems to care about"
15:10:13 <ewtoombs> It just did the obvious O(2^n) method.
15:10:27 <applicative> ewtoombs, it doesn't in that case
15:10:31 <tac-tics> etabot: Haskell isn't *always* magical :<
15:10:32 <elliott> ewtoombs: GHC isn't magic; you still have to write the appropriate algorithms.
15:10:44 <elliott> ewtoombs: Relying on optimisations that change big-O complexity is generally a bit iffy anyway.
15:10:44 <tac-tics> err
15:10:49 <applicative> gcc can see it in the parallel case, if I remember
15:10:49 <elliott> merijn: Racket isn't really even much of a Scheme.
15:10:49 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
15:10:50 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:10:53 <elliott> merijn: That's why it was renamed, after all.
15:11:13 <merijn> Non 2^n fibonacci implementation :p
15:11:32 <merijn> @quote haskell.fibonacci
15:11:32 <lambdabot> No quotes match. Wrong!  You cheating scum!
15:11:32 <tac-tics> merijn: and of course, don't define that at top level
15:11:46 <elliott> tac-tics: Why not?
15:11:49 <Peaker> merijn, elliott, no I really thought they renamed Scheme to Racket because "Scheme" has a lot of archaic connotation baggage associated with the name
15:11:54 <HairyDude> @hackage fixed-precision
15:11:55 <lambdabot> http://hackage.haskell.org/package/fixed-precision
15:12:05 <tac-tics> elliott: Because it will never release the memory
15:12:07 <merijn> Peaker: Racket is just the new name of PLT Scheme
15:12:08 <ewtoombs> Oh, yeah. Extremely iffy. Still, in this case it really was possible, and not completely magical.
15:12:10 <elliott> Peaker: No... PLT Scheme. a language/i,plementation/ecosystem that started as a Scheme dialect, renamed to Racket.
15:12:12 <elliott> tac-tics: Oh, sure.
15:12:17 <nobdraisentone> How can I convert Maybe (Maybe a, b) to Maybe (a, b) ?
15:12:20 <elliott> *implementation
15:12:29 <elliott> Peaker: Scheme still exists and R7RS is being worked on.
15:12:42 <shachaf> @djinn Maybe (Maybe a, b) -> Maybe (a, b)
15:12:43 <lambdabot> f a =
15:12:43 <lambdabot>     case a of
15:12:43 <lambdabot>     Nothing -> Nothing
15:12:43 <lambdabot>     Just (b, c) -> case b of
15:12:43 <lambdabot>                    Nothing -> Nothing
15:12:44 <lambdabot>                    Just d -> Just (d, c)
15:12:56 <elliott> thambdabot
15:12:58 <elliott> thspamdabot
15:13:08 <Peaker> ewtoombs, I think it is good that GHC doesn't transform your algorithms into completely other algorithms - in theory, an O(2^N) algorithm *might* be better than the O(N) algorithm for some special cases, it is nice to be able to express both algorithms.. even if it isn't true in this case, there's no way to figure out in the general case
15:13:09 <tac-tics> spambdabot
15:13:27 <merijn> hmmm
15:13:46 <merijn> lambdabot is suffering brain damage?
15:13:53 <merijn> <lambdabot> ghc says: try_stub.o: unknown symbol `Safe_zdffibonaccizuhszuaM1_closure'
15:13:56 <tac-tics> merijn: more like misconfiguration
15:14:35 <tac-tics> > reverse "scit-cat"
15:14:36 <lambdabot>   "tac-tics"
15:14:42 <elliott> @quote ghc
15:14:42 <lambdabot> ghc says: scavenge: unimplemented/strange closure type
15:14:49 <Peaker> @type join . fmap (liftA2 (,) . second Just)
15:14:50 <lambdabot> forall b b1 d. (Monoid d) => ((d, b) -> (d, b1)) -> (d, b) -> (d, (Maybe b1, b))
15:14:56 <elliott> merijn: They're quotes.
15:14:58 <tac-tics> > text "tac-tics"
15:14:59 <lambdabot>   tac-tics
15:15:08 <Peaker> oops
15:15:33 <Peaker> @type join . fmap (uncurry (liftA2 (,)) . second Just)
15:15:34 <lambdabot> forall a b. Maybe (Maybe a, b) -> Maybe (a, b)
15:15:54 <merijn> Bingo
15:16:00 <merijn> @quote _pizza_ fibonacci
15:16:00 <applicative> wow
15:16:00 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
15:16:29 <Peaker> nobdraisentone, in seriousness, I'd use:     do { (ma, b) <- m ; a <- ma ; return (a, b) }
15:16:30 <ewtoombs> merijn: Jesus Christ! I can't believe that implementation of the Fibonacci sequence actually works!
15:16:40 <ewtoombs> Haskell is a mind grenade
15:16:45 <Peaker> applicative, what's the "wow" about?
15:16:56 <applicative> your definition
15:17:06 <Peaker> applicative, ah, I've practiced extreme points-free riddles a lot :)
15:17:07 <elliott> ewtoombs: next try http://r6.ca/blog/20081116T213644Z.html :)
15:17:19 <merijn> ewtoombs: :)
15:17:20 <Peaker> applicative, I can actually read points-free definitions others consider crazy :)
15:17:21 <hpaste_> “tgeeky (from elsewhere)” pasted “de brujin indices” at http://hpaste.org/69870
15:17:32 <tac-tics> ewtoombs: Laziness is just stupid weird
15:17:51 <HairyDude> > let fib = 1:1:zipWith (+) fib (tail fib) in fib
15:17:52 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
15:17:58 <tgeeky> any takers thanks in advance
15:18:02 <merijn> ewtoombs: That's what makes it such a nifty example. Nicely shows people are the preconceived notions are bogus :p
15:18:15 <merijn> s/are the/their
15:18:22 <merijn> Getting late >.>
15:19:32 <tac-tics> > let x = 1 : y; y = 0 : x in x
15:19:33 <lambdabot>   [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,...
15:20:07 <ewtoombs> ow, my brain
15:20:16 <merijn> ewtoombs: Even better, if you map over it but don't keep the results the compiler should be able to fuse it into a constant space loop :)
15:20:25 <Peaker> > nubBy (\x y -> x `mod` y == 0) [2..]
15:20:27 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
15:20:31 <tac-tics> x ~> 1 : y ~> 1 : 0 : x ~> 1 : 0 : 1 : y ~> ....
15:20:42 <HairyDude> > let loop = loop in loop
15:20:46 <lambdabot>   mueval-core: Time limit exceeded
15:21:13 <jfischoff> can you use Typeable to get the data type name of a value?
15:21:18 <merijn> Peaker: Oh! Cool, I didn't know that one yet
15:21:43 <HairyDude> Peaker: nice. how efficient is it?
15:21:48 <jfischoff> or something similar...
15:21:58 <Peaker> HairyDude, not efficient :(
15:22:22 <Peaker> it tests every new list item against every previous list item, which is much more than necessary
15:23:03 <Peaker> > filterM (const [True,False]) "abc"
15:23:04 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
15:23:24 <Peaker> > let hist = map (head &&& length) . sort . group    in    hist "Hello world!"
15:23:24 <tac-tics> Peaker: I was going to say, "wasn't there a cool powerset with monads example?"
15:23:26 <lambdabot>   [(' ',1),('!',1),('H',1),('d',1),('e',1),('l',1),('l',2),('o',1),('o',1),('...
15:23:33 <ewtoombs> This isn't helping my preconception of "Haskell is nice, but impractical unless you're a genius."
15:23:39 <Peaker> these are my go-to examples when demo'ing Haskell to people
15:23:44 <HairyDude> [x | x <- [2..], all [x `mod` y == 0 | y <- 3,5..floor (sqrt x)]]
15:23:52 <elliott> ewtoombs: s/'re a genius/ know Haskell/
15:23:53 <HairyDude> oops
15:23:57 <tac-tics> ewtoombs: Most of those examples come up again in the channel because they are impressive.
15:24:03 <elliott> Java is pretty obscure for an initiate, too!
15:24:04 <tac-tics> ewtoombs: Most Haskell is much more mundane.
15:24:07 <Peaker> ewtoombs, I think everybody feels that way at first... I saw the one-liners problem solutions in here and was amazed -- then a few months later I wrote them :P
15:24:08 <HairyDude> > [x | x <- [2..], all [x `mod` y == 0 | y <- [3,5..floor (sqrt x)]]]
15:24:09 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
15:24:09 <lambdabot>         against inferred ...
15:24:10 <elliott> (Also most Haskell isn't that fancy, yeah.)
15:24:12 <HairyDude> fail
15:24:14 <elliott> (Unless you're doing it right!)
15:24:23 <hpc> ewtoombs: here's some more tame haskell:
15:24:37 <Nimatek> People don't come up with those in their programs on a regular basis.
15:24:52 <hpc> wrap f l m = do {putStrLn f; m; putStrLn l}
15:25:00 <hpc> html = wrap "<html>" "</html>"
15:25:01 <hpc> ...
15:25:05 <hpc> page = html $ do
15:25:07 <hpc>   head $ do
15:25:09 <tac-tics> There's also haskell that "seems" magical at first, but once you learn the pattern, you'd be amazed you've never known about it before
15:25:10 <HairyDude> > [x | x <- [2..], and [x `mod` y == 0 | y <- [3,5..floor (sqrt x)]]]
15:25:10 <hpc>     title "blargh"
15:25:11 <lambdabot>   Ambiguous type variable `t' in the constraints:
15:25:11 <lambdabot>    `GHC.Real.RealFrac t'
15:25:11 <lambdabot>   ...
15:25:13 <hpc>   body $ do
15:25:13 <merijn> Most of my programming consists of hoogling for type signatures so I don't have to actually write code :p
15:25:14 <HairyDude> dagnammit
15:25:15 <hpc>     ...
15:25:37 <tac-tics> Monadic parsing is so frickin incredible
15:26:00 <tac-tics> It seems dazzling at first, but it's actually really intuitive and useful
15:26:04 <Peaker> tac-tics, I dislike it... I'd much rather have Applicative parsing with handy optimizations in the parser builder
15:26:05 <hpc> ^
15:26:18 <Peaker> tac-tics, also I really miss a "tokenizing" step when doing monadic parsing
15:26:24 <hpc> Peaker: applicative parsing looks too wizardly for my taste
15:26:33 <tac-tics> Peaker: I never really learned Applicative parsing. Do you ahve a tutorial/paper?
15:26:42 <elliott> hpc: if you're not writing Parsec in applicative style, you're wasting time an deffort :)
15:26:45 <elliott> *and effort
15:26:47 <hpc> tac-tics: same as monadic parsing, but limit yourself to applicative style
15:26:50 <elliott> Parsec parsers, that is
15:26:57 <elliott> (for the mostpart)
15:27:01 <merijn> ewtoombs: On the flipside of the examples seeming complicated, when where you last this amazed/blown away by a language/language features? :p
15:27:34 <HairyDude> gah, WHY does mingw use cmd.exe as its terminal emulator :(
15:27:51 <hpc> why does mingw do anything? :P
15:27:54 <tac-tics> Most of the really aweful language stuff is really just mundane. IO is marked in the types. Stuff is immutable, which means no worrying about if code is threadsafe.
15:27:55 <merijn> HairyDude: Instal cygwin and ssh to localhost using putty?
15:27:58 <ewtoombs> merijn: last time I saw a Haskell demo at an event hosted by Waterloo's CSClub.
15:28:08 <tac-tics> s/aweful/awesome/g
15:28:11 <hpc> merijn: that's the best worst idea i have ever heard
15:28:12 <HairyDude> merijn: ghci doesn't work in cygwin
15:28:23 <merijn> hpc: Those are my middle name :)
15:28:35 <HairyDude> merijn: besides, I tried that, it was too much hassle
15:28:48 <merijn> Man, I wonder if I can put #haskell compliments on my resume :>
15:29:09 <Peaker> tac-tics, I don't think one exists.. which does the optimizations/safety-checks possible once you restrict the parser to Applicative
15:29:16 <merijn> (Well, for given values of compliment)
15:29:39 <tac-tics> Peaker: well, what kind of thing *can't* you do with applicative parsers?
15:29:47 <merijn> Most compliments I get seem to have words like "terrible", "awful", "insane" and similar in them :>
15:29:52 <hpc> tac-tics: context-sensitive parsing, i think
15:30:05 <hpc> tac-tics: stuff like haskell's precedence-setting operators
15:30:16 <hpc> where syntax over here changes the parsing rules over there
15:30:21 <tac-tics> ah
15:30:30 <tac-tics> I hate precedence setting operators ;;;>_>
15:30:52 <Peaker> ewtoombs, Haskell makes "real-world" mundane stuff much more bearable too, not just toying with lists and numbers.  For example, "threadIds <- replicateM 10 (forkIO (forever threadCode))"  makes 10 forever-looping threads running threadCode and gives you their thread ids.. so as an example, a thread pool is so easy to set up
15:30:57 <hpc> tac-tics: wait until you try mixfix...
15:31:06 <t7> mix fix is cool
15:31:11 <Peaker> tac-tics, You can't parse a Turing complete language
15:31:24 <Peaker> tac-tics, do you know the Chomsky hierarchy?
15:31:32 <merijn> Peaker: Needs less parenthesis :>
15:31:38 <tac-tics> Peaker: Sounds familiar
15:31:43 <Peaker> merijn, I'm trying to make this understandable with less syntactic baggage
15:31:43 <mroman> I'm pretty sure brainfuck is type 2
15:31:48 <HairyDude> Peaker: in the sense that sentences in a Turing-complete language may be arbitrarily large?
15:31:50 <hpc> what set of parsec operations corresponds to regular grammars?
15:31:53 <mroman> and therefore very well parseable.
15:31:58 <merijn> Peaker: I know, but I felt compelled to complain anyway :p
15:32:02 <ewtoombs> This must be a new meaning for the word "parse" I'm not familiar with.
15:32:05 <augur> Peaker: you cant parse it with a guarantee of success on all inputs, at least
15:32:06 * hpc is guessing { (>>) }
15:32:38 <Peaker> ewtoombs, replicateM 10  basically is  for i in xrange(10) -- with a guarantee that the actions are all the same.   forkIO makes a thread.  forever loops forever...  the real way you'd write this is:    threadIds <- replicateM 10 . forkIO . forever $ do   newline and indented code for each thread here
15:32:45 <HairyDude> technically, no language that doesn't have arbitrary precision integers is Turing-complete.
15:33:11 <Peaker> HairyDude, maybe that is a way to look at it -- Applicative's restriction over Monad is that you can't look at parsed values to decide how to parse the next value
15:33:14 <merijn> Technically, no language that runs on a computer is Turing-complete
15:33:18 <t7> what sort of stuff can i prove with sequence calculus?
15:33:28 <Peaker> HairyDude, you have to compose all your parsing stuff *before* knowing what's going to be parsed
15:34:15 <Peaker> HairyDude, (without looking at the parse result, that is)
15:34:27 <tac-tics> t7: I think sequent logic is just first-order logic
15:34:44 <tac-tics> t7: So basically, it's as strong as the simply typed lambda calculus
15:35:04 <ewtoombs> Actually, I was pretty impressed when I read about Erlang. Erlang is self-advertised as being ridiculously reliable.
15:35:04 <Peaker> HairyDude, so if your turing complete language says the grammar is:   <n : number> (if n is prime <a> else <b>)   then an Applicative can't do this because you have to compose with <a> or with <b> without seeing "n". with a Monad you can look at "n" and then decide whether to use <a> or <b>
15:35:06 <HairyDude> Peaker: I was more thinking that recursive elements may get arbitrarily deeply nested, requiring arbitrarily large amounts of stack
15:35:29 <ewtoombs> So that was the last time I was this impressed by a language's features.
15:35:33 <Peaker> HairyDude, that's already true with context-free grammars which Applicative parsers + fix combinator can do
15:35:34 <merijn> ewtoombs: btw, as far as the whole "need to be a genius for haskell"-thing, hanging around here for 2 years has taught me more thanh my master's degree :)
15:35:46 <HairyDude> ... but that's not actually a requirement for turing-completeness...
15:35:50 * HairyDude thinks
15:36:32 <merijn> ewtoombs: Erlang is pretty nifty. It's not necessarily reliable itself, but the way it is usually programmed leads itself well to programs that degrade gracefully in the presence of faults
15:36:46 <tac-tics> ewtoombs: I think Haskell has the potential to be just as reliable as Erlang. It has all the important ingredients Erlang does (a strong preference for immutability, good message-passing libraries), etc.
15:36:54 <HairyDude> Peaker: oh, you were talking specifically about Applicative parsing. I thought you meant in general
15:37:03 <merijn> tac-tics: But not hot-code swapping :\
15:37:13 <Peaker> Haskell has the potential to be more reliable than Erlang (type safety is reliability)
15:37:17 <tac-tics> merijn: *gasp*. That doesn't sound typesafe at all!
15:37:18 <merijn> I wish someone would implement that for GHC, that'd be cool
15:37:33 <ewtoombs> tac-tics: that's what I thought, as well. And I like Haskell's syntax much better than Erlang's, which I find slightly cryptic.
15:37:35 <Peaker> I think dons wrote a paper about hot code loading in Haskell
15:37:42 <HairyDude> Peaker: I gather erlang's reliability comes from hot-swappable components
15:37:53 <Peaker> HairyDude, not sure why that relates to reliability?
15:38:21 <merijn> Peaker: The Erlang model is not to be more reliable but just have fine-grained crashes and crash monitoring/service resurrection
15:38:28 <HairyDude> Peaker: if something crashes, you can fix it and stick it back in without changing anything else
15:38:57 <merijn> Which is a reasonable error handling method in an extremely IO heavy environment
15:38:57 <Peaker> HairyDude, if it didn't do too much damage already..
15:39:02 <HairyDude> Peaker: well, yes
15:39:17 <Peaker> HairyDude, that is very useful but I don't think it makes things reliable
15:39:28 <HairyDude> Peaker: but... about all I know about erlang comes from that ancient video
15:39:30 <merijn> Peaker: Well, state is confined to a single process so all it could do is go byzantine and send out confusing messages
15:39:37 <HairyDude> (and a bit of fiddling with ejabberd)
15:40:30 <merijn> Peaker: It does, it's just a different interpretation of reliability from what your thinking of :) Which is most relevant depends on your problem domain
15:42:15 <Peaker> seeing a Reddit comment and thinking "Who's this silly dude?" and then seeing it was me, 3 years ago, heh :)
15:42:39 <HairyDude> ah! it seems cygwin's terminal program (mintty) is available for msys too
15:42:57 <blackdog> Peaker: that's a good sign, right? It's always alarming to see something you wrote and think "wow, i was smart back then"
15:43:09 <tac-tics> Peaker: hehe
15:43:46 <Peaker> merijn, surely you're going to implement some high-level notion of persistent state -- via messages, so the fact you're message passing doesn't mean you don't have mutable state to worry about, just that you have less (which is great, but you could still have very bad damage from bugs)
15:44:06 <Peaker> merijn, consider a bug that corrupts the addresses of modify messages or such
15:44:36 <HairyDude> much better
15:45:33 <tac-tics> Can you access IORefs unsafely from foreign threads?
15:45:46 <Peaker> tac-tics, yeah
15:46:05 <tac-tics> Is there any synchronization? Or is it segfault bait?
15:46:17 <Peaker> not segfault, just bugs
15:46:21 <Peaker> (in your logic)
15:46:26 <tac-tics> gotcha
15:46:30 <merijn> Peaker: Sure, which is why I said that the language itself isn't really all that reliable. Just the common style adopted lends itself well to deal gracefully with IO errors/malfunctions
15:46:42 <Peaker> if you use modifyIORef, for example, between your read and write someone else may write
15:47:49 <tac-tics> but one IORef can't be, say, written to and read from in concurrently executing threads running on separate cores?
15:48:10 <HairyDude> ah, interesting mintty is based on putty
15:50:18 <startling> I've got a bunch of things that I need to access by name from a containing data structure. what's the best way to do this? a data?
15:50:37 <startling> they're all the same type, fwiw
15:51:24 <linduxed> let's say that i have a data type called point, that basically goes "data Point = Point { xVal :: Double, yVal :: Double, name :: String } deriving(Show)"
15:51:33 <merijn> startling: You mean similar to record fields? Or something else, it's a bit unclear what you want
15:51:52 <linduxed> i create a point with "a = Point 2 3 "a""
15:52:00 <tac-tics> MVar = Mutex variable?
15:52:02 <startling> merijn, yeah, im not sure if I should use record fields or something else
15:52:07 <linduxed> now
15:52:08 <tac-tics> what does the "M" stand for?
15:52:26 <startling> I have twelve different values of the same type, and I want to move them around as one thing.
15:52:35 <startling> and access them by name efficiently
15:52:42 <Peaker> tac-tics, it's like poetry, you get to decide
15:52:47 <linduxed> iirc there's a way to type something so that i get back the Point, but with one value changed
15:52:48 <merijn> startling: I recently learned to work with data-lens and I can now say that lenses are pretty nifty if you have to frequently updated (especially for nested values)
15:53:04 <tac-tics> Peaker: lol
15:53:08 <Peaker> I don't like lenses
15:53:22 <merijn> linduxed: "a {xVal = 5}" will return a with xVal set to 5
15:53:25 <merijn> Peaker: Why not?
15:53:27 <linduxed> so for instance, i'd like to change the 2 to a 4, so i'd do that magic thing, and i'd get a point back that looks like "Point 4 3 "a""
15:53:35 <Peaker> merijn, they restrict the types unnecessarily
15:53:44 <linduxed> merijn: ok, i'll try that
15:53:55 <Peaker> merijn, I have lots of polymorphic records:  data Foo a = Foo { x :: a, b :: Integer }
15:54:10 <Peaker> merijn, lens give me:  (a -> a) -> Foo a -> Foo a.   A bit of TH gives me:   (a -> b) -> Foo a -> Foo b
15:54:22 <linduxed> merijn: that did the trick
15:54:39 <Peaker> merijn, so I use a bit of TH instead
15:54:48 <merijn> Peaker: Ah, that hasn't been a common case for me so far
15:54:51 <Peaker> merijn, I don't get the getter part, but I can live with the ordinary field being the getter
15:54:54 <startling> also, I have a fixed amount of Word16s that i'd like to access by index frequently. what's the best way to store them? an array?
15:55:04 <merijn> And the state combinators for using lenses in StateT have been very convenient
15:55:11 <Peaker> merijn, so what I really lose is the composition of the getter/setter together, but that's fine, rarely do I want to pass that pair
15:55:23 <Peaker> startling, how many?
15:55:35 <Peaker> startling, only read access or also write access?
15:55:40 <startling> Peaker: 65536
15:55:45 <merijn> startling: Yeah, array seems the convenient way, unless they're sparsely indexed, in which case maybe IntMap?
15:55:57 <elliott> don't use an array that big
15:55:58 <startling> oh, yeah, they could be sparsely indexed
15:55:59 <Peaker> merijn, with SECs, I just use:   State.modify . atMyField . atOtherField $ const 5       to set field to 5
15:56:01 <elliott> immutable, that is
15:56:18 <startling> what should I use then?
15:56:18 <Peaker> elliott, why not? If it is never modified?
15:56:25 <merijn> Peaker: Yeah, but I don't really "get" SECs yet
15:56:28 <Peaker> startling, how many indexes will actually be utilized?
15:56:29 <ClaudiusMaximus> Peaker: why TH? why not {-# LANGUAGE DeriveFunctor #-} ?
15:56:35 <Peaker> merijn, did you read conal's blog about them?
15:56:36 <startling> Peaker, up to the user
15:56:42 <elliott> Peaker: oh, it's never modified?
15:56:44 <elliott> use a function then :P
15:56:56 <Peaker> ClaudiusMaximus, well, it's not always a Functor.. it might be in a contra/invariant position too
15:57:02 <ClaudiusMaximus> ah ok
15:57:29 <tgeeky> DeriveDifunctor?
15:57:30 <tgeeky> hehe
15:57:31 <Peaker> elliott, a sane function to use for speed in some situations would be  Array.!
15:57:40 <elliott> Peaker: Right.
15:58:00 <MostAwesomeDude> Hey, I know this isn't super-on-topic, but whatever. What would you guys say is *the* thing about Haskell that traditional imperative programmers could learn from and incorporate into their day-to-day work in traditional imperative languages?
15:58:54 <merijn> Peaker: I have it in my to read queue I think
15:59:00 <sipa> i think haskell has some features that are not related to being functional, and would be extremely useful in traditional languages
15:59:10 <Peaker> ClaudiusMaximus, or maybe there are multiple type variables:   data Foo a b c = Foo { x :: (a -> [b]), y :: IO c }        the TH I use gives me:    atX :: ((a -> [b]) -> c -> [d]) -> Foo a b z -> Foo c d z ; atY :: (IO c -> IO d) -> Foo a b c -> Foo a b d
15:59:19 <startling> I like typeclasses and data types a lot
15:59:20 <tac-tics> MostAwesomeDude: Immutability of core data types, separation of effectful code from algorithmic code, and totality of functions.
15:59:23 <Peaker> merijn, it's completely transformed the way I use Haskell
15:59:23 <sipa> ADTs, sane module system, type classes, ...
15:59:23 <MostAwesomeDude> The best thing I've found so far that I could explain quickly is higher-order functions.
15:59:26 <merijn> MostAwesomeDude: (Dumb) data structures first, code second
15:59:36 <Peaker> merijn, I use SECs everywhere
15:59:43 <MostAwesomeDude> merijn: Data-driven stuff is pretty awesome.
15:59:56 <merijn> MostAwesomeDude: Also, recursion is really sensible for many tree/list stuff. Really simplified much of my C code
16:00:11 <MostAwesomeDude> tac-tics: Categories could take too much time for a presentation. Also Haskell doesn't require totality.
16:00:49 <Nimatek> > "h3rp4d3rp" =~ "[0-9]+" :: String -- is there something like this for :: [String]
16:00:51 <lambdabot>   "3"
16:01:01 <MostAwesomeDude> Also also I like the iteration-vs-recursion-doesn't-matter idea of map more than actually telling people to recurse more often.
16:01:10 <ClaudiusMaximus> Peaker: yeah that makes sense
16:01:13 <tac-tics> MostAwesomeDude: I didn't mention category. And no, Haskell isn't total, but it's much easier to analyze totality recursively, IMO
16:01:33 <Nimatek> > "h3rp4d3rp" =~ "[0-9]+" :: [String]
16:01:35 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
16:01:35 <lambdabot>                    ...
16:01:42 <MostAwesomeDude> tac-tics: Well, yes, and I'm gonna mention that.
16:02:01 <Peaker> MostAwesomeDude, seeing the relationships between arithmetic and types is useful to understand code in any language..  The Visitor Pattern is about translating (A|B) -> C   to  (A -> C, B -> C)   because these languages don't have | (sum types).  It is easy to see this if you know the former is C ^ (A+B) and the latter is (C^A) * (C^B)
16:02:42 <tac-tics> MostAwesomeDude: but pushing state as far as you can "down the stack" is the biggie.
16:02:50 <tac-tics> (or is it "up the stack"?...)
16:03:12 <Peaker> The Visitor pattern is such a bulky workaround -- why don't most mainstream languages do sum types? They're so sane
16:04:06 <merijn> Peaker: Anyhoo, I'll bump SECs up my reading stack I guess
16:04:09 <merijn> But now bed time
16:04:12 <tac-tics> Peaker: My feeling is variants are better suited for heavily nesting languages while records are better suited for flat languages.
16:04:12 <Peaker> Lack of sum types -> branching on tags and losing all type-checking about the branching..    this is probably one of the primary reasons Haskell type-checking is worth so much more than other mainstream languages'
16:04:15 <Peaker> merijn, night
16:05:03 <Peaker> tac-tics, I disagree, to represent data you need both sums and products... you can emulate sums using products and built-in sums (e.g: integer types), but it sucks
16:05:12 <Peaker> I think they don't have "sums" because they simply haven't thought about it
16:06:13 <Peaker> or maybe they think their inheritance mechanisms give them enough of a sum -- but really they only give them a very weak folder function...   to build full pattern-matching from a folding function is a nightmare
16:06:13 <tac-tics> You do need both, but I think languages tend to evolve with a bias towards one or the other.
16:06:26 <Peaker> tac-tics, what languages have a bias towards sums?
16:06:33 <tac-tics> haskell :P
16:06:47 <Peaker> how is it biased towards sums?   Sums need |, products are juxtaposition
16:06:51 <tac-tics> Record syntax is really, really fugly. And it's because they weren't as important as sums :)
16:07:08 <Peaker> data A = A Int Char  <-- product
16:07:27 <Peaker> (,)  <-- product,  shorter than Either
16:07:53 <hpc> (,) is an out-of-language construct though
16:08:00 <hpc> it has specific parsing rules
16:08:06 <Peaker> Haskell makes products and sums both very easy (not easy enough, but much better than other mainstream languages)
16:08:07 <tac-tics> But what are the projections for variants in Haskell?
16:08:08 <hpc> and it has (,,,,,,,,,,,,,,,,,,) and family
16:08:21 <Peaker> tac-tics, I don't know what that means
16:08:24 <tac-tics> Either the projections are unnamed and you require pattern matching, or they are ugly, ugly record syntax
16:09:05 <Peaker> tac-tics, record syntax in Haskell is not that different from record syntax in these "product oriented languages"
16:09:21 <coppro> tac-tics: that's not true
16:09:28 <coppro> tac-tics: you can define projections yourself
16:09:50 <coppro> or use a record, but never use record syntax to define it
16:10:20 <coppro> data Foo = Foo { bar :: Int }; baz = Foo 4; barbaz = bar baz; -- works fine
16:10:56 <tac-tics> Let us all agree to think the other is wrong :P
16:11:20 <tac-tics> It's clear, though, that C and Java would really like to make everything a product if at all possible.
16:11:57 <Peaker> tac-tics, even Go! which is so sad.  They represent their Either Error Result   type for errors  as (Error, Result)  with an "invalid" value in Result if Error is not success
16:12:07 <coppro> C supports sums, although you have to do the discrimination yourself
16:12:08 <Peaker> if you use the result without checking for error -- well, bug for you!
16:12:24 <elliott> coppro: not really, union is just an optimised struct
16:12:31 <tac-tics> Peaker: There's plenty wrong with most languages :P
16:12:36 <Peaker> coppro, C supports Haskell programming too, you just have to implement a Haskell interpreter first :)
16:12:36 <elliott> :p
16:12:44 <tac-tics> null is just a Maybe a, where you can't distinguish between Nothing and Just Nothing.
16:12:48 <coppro> it's still a sum time
16:12:49 <tac-tics> in the case a = Maybe b
16:12:54 <coppro> *sum type
16:13:16 <tac-tics> Peaker: iirc, doesn't Scala have variants?
16:13:41 <Peaker> coppro, union isn't a sum type... union { char x[4]; int y; }  would have 2^32 possible values, rather than 2^32 + 2^32 as a sum type should
16:13:50 <Peaker> tac-tics, Sure, Scala has a pretty advanced type system
16:14:22 <tac-tics> I want to say from my short time looking over DDC, sums also act a little weird in the precence of mutability.
16:14:34 <tac-tics> (not that everything isn't weird with mutability)
16:14:41 <startling> so I want an array that's indexed with Word16s and contains Word16s. what type should I use? The docs for IArray and UArray are kind of dense. why can't I do "type Mything = = IArray UArray Word16"?
16:14:48 <tac-tics> But I don't remember exactly
16:15:10 <coppro> Peaker: from a defined semantics point of view, that's not actually the case
16:15:13 <Peaker> coppro, and the real issue with lack of sum types is "boolean blindness" (http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/) which is basically that branching on possibilities gives you no useful type information at compile-time, based on where the branch ended up
16:15:19 <coppro> there are 2^32 + 2^32 + 1
16:15:49 <Peaker> coppro, not in a total language, and not if you consider non-termination an effect rather than a value
16:16:03 <coppro> I wasn't referring to non-termination
16:16:11 <Peaker> startling, isn't IArray a type-class?
16:16:13 <coppro> I was referring to uninitialized
16:16:19 <tac-tics> Anyway, time to go home
16:16:21 <tac-tics> later
16:16:24 <Peaker> coppro, in what context? C or Haskell?
16:16:28 <coppro> C
16:16:36 <Peaker> coppro, in C there are just 2^32 options for that type
16:17:07 <startling> Peaker: ..yep. thanks!
16:17:45 <coppro> Peaker: No.
16:18:00 <coppro> that's a typical implementation detail
16:18:09 <coppro> but it is not the actual case.
16:18:20 <Peaker> startling, I think the interesting array types are all combinations of {mutable, immutable} {ST|IO} {boxed, unboxed}  and for unifying the interface of the boxed/unboxed/ST/IO ones, you have the IArray/MArray classes
16:18:29 <Peaker> coppro, according to the C standard, you mean?
16:18:48 <Peaker> coppro, the possibility of UB if you access an uninitialized value does not really add possible values to that type
16:19:08 <coppro> Peaker: It oculd.
16:19:09 <coppro> *could
16:19:19 <coppro> You could have an implementation which would error on undefined behavior.
16:19:21 <Peaker> coppro, you wouldn't be able to discern the additional values
16:19:32 <coppro> No, but nonetheless, the distinction is there.
16:19:47 <Peaker> the distinction is between programs, not between values of that data type
16:19:52 <startling> Peaker: ah
16:19:59 <coppro> Peaker: I disagree.
16:20:14 <coppro> Consider if you had a dynamically typed language with no way to inspect the type of a variable
16:20:14 <pikhq> Peaker: I'm pretty sure it would be *conformant* to implement a union as identical to a struct.
16:20:21 <Peaker> coppro, in any case, unions are very very poor "sum types" and don't solve the problems of boolean blindness at all
16:20:30 <coppro> that I'll agree with
16:20:40 <Peaker> pikhq, I think the standard might say something about member offsets of a union being 0
16:20:52 <Peaker> but I'm not sure
16:21:24 <coppro> I believe C++ has enough leeway for that
16:21:26 <coppro> not sure about C
16:21:32 <Peaker> coppro, how?
16:22:05 <Peaker> coppro, how can you implement a safe Maybe type in C++ where you can case on it safely, besides the "visitor pattern" / "folder" function?
16:22:08 <coppro> Peaker: I don't believe you can convert directly from a pointer to one union member to another in C++ and get defined behavior
16:22:31 <pikhq> Peaker: Also, there's 2^32 + 2^32 + 1 options for a union of two 32-bit values, it just so *happens* that 2^32 of them are _|_, and in common implementations are identical to the other half set of values.
16:22:56 <coppro> could be wrong
16:22:59 <pikhq> Erm, not _|_
16:23:09 <coppro> Peaker: you have to discriminate manually
16:23:10 <pikhq> Though that is a conformant implementation of UB.
16:23:51 <Peaker> coppro, then it's still "boolean blind" (i.e: you don't get any type info when you see it's a "Just" rather than a "Nothing")
16:24:30 <coppro> hmm... actually, C's unions may be more specified enough to not be sum types
16:24:33 <coppro> C++'s certainly are though
16:24:38 <coppro> Peaker: sure
16:25:03 <Peaker> Someone should make a language like C without these obvious mistakes...
16:25:45 * shapr hugs Heffalump and runs away
16:25:49 <startling> Peaker: i know, right
16:25:50 <Heffalump> has anyone successfully used :history in GHC 7.4 ? I'm using :trace as per the docs but just get the "Empty history. Perhaps you forgot to use :trace?"
16:25:59 <Peaker> pikhq, The field not being accessible due to UB does not give you 2^32 UB values
16:26:02 <Heffalump> hi shapr :-) and congratulations!
16:26:09 <shapr> Thanks!
16:26:18 <shapr> Heffalump: I get "Not stopped at a breakpoint"
16:26:37 <Heffalump> sorry, in conjunction with -fbreak-on-exception or -fbreak-on-error
16:26:55 <jfischoff> Heffalump: I tried recently and got nothing, not even a message after breaking
16:26:55 <shapr> oh, I really am walking out the door, you'll have to ask someone else.
16:27:22 <Peaker> Hmm.. would creating thousands of IORefs be very bad?
16:27:23 <pikhq> Peaker: Sure it does. There are 2^32 different values of the one field, and accessing the other field gives you undefined behavior in 2^32 different ways.
16:27:27 <Peaker> i.e: expensive?
16:27:50 <Peaker> pikhq, how is it 2^32 different ways? UB is UB
16:28:16 <Peaker> a conforming implementation can just give you UB in exactly one way when you access the other field
16:28:57 <pikhq> (incidentally, that union {char foo[4];int bar;} thing is silly: int bar;char (*foo)[sizeof bar] = &bar; gives you a defined behavior way of accessing the chars composing the int)
16:29:26 <t7> is there a functional alternative to blocky? ( http://blockly-demo.appspot.com )
16:29:31 <Peaker> pikhq, let's say you had:   struct { bool tag; union { int a; char b[4]; } }    and tag could only 2 values. And "a" or "b" are valid according to "tag" -- then you agree we have exactly 2^33 values, assuming the invariants are kept?
16:29:52 <Peaker> pikhq, the defined-way of accessing the int does not give you any more new values either
16:30:12 <Peaker> pikhq, you won't extract more than 2^32 of theoretical values out of a 32 bit storage :)
16:31:51 <pikhq> Peaker: The defined-way of accessing the int wasn't meant to, it's just meant to be less utterly stupid. :)
16:33:41 <Peaker> pikhq, in any case, I don't think you can say "C has type sums".. it has a very tedious way of emulating type sums
16:33:50 <teneen> Why does mapM run in constant stack space? isn't it co-recursive?
16:34:18 <teneen> sorry linear stack space
16:35:09 <c_wraith> no, it's not
16:35:39 <c_wraith> @src mapM
16:35:39 <lambdabot> mapM f as = sequence (map f as)
16:35:44 <teneen> c_wrait: it uses guarded recursion with the (:) operator within the monad
16:35:46 <c_wraith> @src sequence
16:35:47 <lambdabot> sequence []     = return []
16:35:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:35:47 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
16:35:58 <c_wraith> teneen: only if you ignore the liftM2
16:36:07 <c_wraith> but if you ignore that, you're ignoring the entire point
16:36:40 <c_wraith> really, the first definition of sequence is easier to think about
16:37:00 <c_wraith> when is the (:) in the result generated?
16:37:10 <teneen> c_wraith: What's the problem with liftM2, doesn't it inline to the first definition?
16:37:14 <c_wraith> *after* the effects of sequencing the tail of the list take place
16:37:42 <c_wraith> it's very important that effects happen *in the correct order*
16:38:52 <c_wraith> You're asking for effects to happen out of order
16:38:54 <c_wraith> that's dangerous
16:40:37 <Pseudonym> Incidentally, a monad where that's okay is called a commutative monad.
16:40:48 <Pseudonym> For obvious reasons.
16:41:54 <c_wraith> the only commutative monad I can think of offhand is Maybe...  There must be other ones, though
16:42:00 <Pseudonym> List.
16:42:01 <teneen> c_wraith: why can't the list be stored as "the execution of the first action `cons` the result of the execution of sequencing the rest of the list, and all this to be returned as a list in the monad "
16:42:17 <Pseudonym> Also, any tree substitution.
16:42:25 <c_wraith> teneen: because that's asking for the effects be to done at a random point in the future.  any random point in the future.
16:42:30 <Pseudonym> Basically, any data structure which is also a Monad.
16:42:34 <c_wraith> teneen: possibly even never
16:43:41 <c_wraith> teneen: the important part is the definition of sequence
16:44:08 <startling> what's the best way to map an enum type to a value in a way that I can make maps based on old versions?
16:44:10 <c_wraith> teneen: sequence says "I will perform all these actions and collect their results into a list to return"
16:44:23 <teneen> c_wraith: But it preserves the order. And, anyways, the normal definition of sequence is also lazy, isn't it?
16:44:35 <c_wraith> teneen: not in IO it isn't
16:45:23 <c_wraith> teneen: Do you really want the expression « sequence [ deleteFile a, deleteFile b, deleteFile c ] » to depend on evaluating the list to actually delete the files?
16:46:41 <teneen> c_wraith: So I think there should be two definitions for sequence. One which is lazy, and another which is strict.
16:47:10 <c_wraith> teneen: did you look at the definition? How would you possibly even do that?
16:47:18 <c_wraith> teneen: sequence is already maximally lazy
16:47:45 <c_wraith> teneen: the only way you can make it lazier is to change the type.
16:47:46 <startling> can I un-import something in ghci? or start over somehow?
16:48:09 <coppro> sequence is lazy; IO is not
16:48:24 <parcs`> strager: :m - and :m +
16:48:43 <teneen> c_wraith: I want it to be co-recursive
16:48:54 <c_wraith> teneen: that's not what the type says
16:48:58 <c_wraith> :t mapM
16:49:00 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:49:08 <c_wraith> see that m out front of the result?
16:49:13 <c_wraith> it *means* something
16:49:16 <c_wraith> you can't just ignore it
16:50:10 <parcs`> startling: ^
16:51:15 <c_wraith> teneen: the tools you have, given the type signature, are the tools of the monad type class.  There's only one natural implementation of that type. its behavior depends on the behavior of (>>=) for m
16:51:33 <startling> parcs`: ah, thanks
16:51:56 <teneen> c_wraith: I see
16:52:06 <c_wraith> there are degenerate implementations of that type, of course...  « mapWrong _ _ = return [] », for instance
16:52:22 <c_wraith> But most people wouldn't consider ignoring your inputs to be especially natural
16:53:41 <elliott> <teneen> c_wraith: why can't the list be stored as "the execution of the first action `cons` the result of the execution of sequencing the rest of the list, and all this to be returned as a list in the monad "
16:53:46 <teneen> c_wraith: so this implementation "let sequence (x:xs) = liftM2 (:) x (sequence xs)" is also not lazy enough?
16:53:49 <elliott> teneen: because then the effects depend on the evaluation of the value
16:53:52 <elliott> which is sort of the opposite of the point
16:53:59 <elliott> also, what would that even mean for a monad like []?
16:54:00 <c_wraith> teneen: the definitions are identical
16:54:27 <c_wraith> @src liftM2
16:54:27 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:54:36 <teneen> elliott: I see your point
16:54:38 <c_wraith> see?  identical
16:55:05 <teneen> c_wraith: but sequence will shortcut for monads like maybe, yes?
16:55:52 <c_wraith> Sure, that's part of the definition of (>>=)
16:56:06 <MostAwesomeDude> teneen: Well, Maybe's own implementation will short-circuit, yes.
16:56:10 <Peaker> > sequence (Nothing : repeat (Just 1))
16:56:11 <lambdabot>   Nothing
16:56:17 <ewtoombs> anybody here use archlinux? I'm trying to figure out how to install gtk2hs on here. I see a package for gtk2hs-buildtools, but that's it.
16:56:24 <sipa> :t forever
16:56:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
16:56:36 <Peaker> > forever Nothing
16:56:37 <lambdabot>   Nothing
16:56:37 <elliott> teneen: indeed, Maybe is a good example
16:56:43 <elliott> say sequence xs ends up being Nothing
16:56:47 <elliott> the whole thing should be Nothing
16:56:49 <elliott> not Just (something:something)
16:57:00 <sipa> > Nothing >>= forever (Just True)
16:57:01 <lambdabot>   Couldn't match expected type `a -> a1'
16:57:01 <lambdabot>         against inferred type `Data....
16:57:02 <dcoutts_> ewtoombs: the other packages are glib, gtk etc, so they might be called something like haskell-gtk, I'm not sure what naming scheme arch uses for its haskell packages
16:57:06 <elliott> note that sequence_/mapM_ *do* have this kind of "tail-recursive" behaviour
16:57:12 <Peaker> > Nothing >> forever (Just True)
16:57:14 <lambdabot>   Nothing
16:57:15 <ewtoombs> odd.
16:57:26 <ewtoombs> I'll give haskell-gtk a try
16:58:00 <irene-knapp> -fno-state-hack!!!
16:58:02 <irene-knapp> I need to try this
16:58:10 <dcoutts_> ewtoombs: that is, there's no gtk2hs package on hackage, the gtk2hs project has on hackage the packages: gtk2hs-buildtools, cairo, glib, cairo and a few other extensions
16:58:30 <dcoutts_> erm, cairo, glib, gtk :-)
16:58:40 <irene-knapp> came up on -cafe today and if it resolves performance in my two projects that I had to abandon because of the unacceptable and inexplicable performance problems in them, then it will justify my having read -cafe for the entire year :)
16:58:41 <teneen> elliot, c_wraith: so even if I "map unsafeInterleaveIO" first and then sequence it will not change the stack consumption issue? but it will execute the effects only on demand, correct?
16:58:41 <MostAwesomeDude> Double cairo all the way.
16:58:44 <ewtoombs> and presumably gtk2hs-buildtools isn't needed to use gtk2hs?
16:58:47 <ewtoombs> ...or is it...
16:59:09 <MostAwesomeDude> teneen: Well, the rules change when you do unsafe things.
16:59:11 <dcoutts_> ewtoombs: needed to build the gtk package from source, not needed at runtime
16:59:29 <elliott> teneen: don't use unsafeInterleaveIO.
16:59:38 <ewtoombs> and not needed to build projects that use gtk?
16:59:48 <ewtoombs> that's what I'm wondering about
17:00:46 <ewtoombs> When I read "haskell platform" in the subject, I thought, this is what Haskell will do if it gets elected, lol
17:01:01 <irene-knapp> haha
17:01:18 <parcs`> irene-knapp: what does it do?
17:01:27 <MostAwesomeDude> "Strongly typed, proven purity" is probably not the best platform. :3
17:01:38 <dcoutts_> ewtoombs: correct, only needed to build the gtk package, not to build things that depend on gtk
17:01:43 <MostAwesomeDude> OTOH, Haskell is tough on everything, so surely it's tough on crime. :3
17:01:55 <irene-knapp> something very subtle that I didn't totally understand, but its presence OR its absence can have an order-of-magnitude effect on transformed IO monads.
17:02:09 <irene-knapp> it has to do with whether an intermediate closure is used by bind
17:02:24 <Adeon> with haskell, world hunger problems will be solved
17:03:42 <parcs`> irene-knapp: is one of those projects that snes emulator you were working on/
17:03:59 <irene-knapp> NES, and yes it is!
17:04:04 <irene-knapp> I have some work to do before I can try it
17:04:15 <irene-knapp> but yes
17:04:26 <parcs`> yay
17:04:28 <ewtoombs> I'm using haskell to build an interactive quantum physics simulator. It's gonna rock!
17:04:38 <irene-knapp> were you one of the many people who gave me valuable help on optimizing htat?
17:04:50 <irene-knapp> ewtoombs: the universe is already an interactive quantum physics simulator
17:05:47 <enoksrd> Hi.  Anyone know where I can find a mapping from GHC versions to base package versions?
17:05:49 <ewtoombs> Yes, but there are impracticalities with trying to see what an individual electron is doing in the real universe.
17:05:59 <irene-knapp> fair enough
17:08:35 <Peaker> also you can't really feed the universe any input you want :P
17:08:55 <Peaker> it has such noisy input by default, and you can only slightly control the inputs
17:09:09 <irene-knapp> true enough
17:09:40 <jfischoff> I like it
17:09:46 <startling> what's the best way to map all the things of one type to some things of another type in a way that I can modify the mappings?
17:10:04 <jfischoff> @remember irene-knapp: ewtoombs: the universe is already an interactive quantum physics simulator
17:10:04 <lambdabot> Done.
17:10:05 <startling> well, nto really modify -- return a new map with most of the things from the old map
17:10:13 <irene-knapp> thanks, hehe
17:10:28 <teneen> elliott, c_wraith: what about this definition for sequence "sequence' [] = return []; sequence' (x:xs) = lift x >>= \x' -> modify (x':) >> seqs xs" .... and "sequence xs = execStateT (sequence' xs) [] "
17:10:34 <jfischoff> :)
17:10:35 <tarmstrong> Based on http://hackage.haskell.org/trac/ghc/ticket/1475 and the TH docs it looks like I can't generate import statements at compile-time. (Right?) Is there some way I can specify imported modules as part of a ghc command?
17:10:35 <teneen> will this run in constant stack?
17:11:02 <teneen> **err seqs --> sequence'
17:11:16 * enoksrd finds package versions in the *full* release notes: http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/release-7-2-1.html
17:11:20 <jfischoff> tarmstrong: what problem are you trying to solve?
17:12:45 <tarmstrong> jfischoff: the problem is of my own making :) I would like to have a TH function called moduleInvokeAll that generates a list of functions from modules within the current package that implement that "hook"
17:13:00 <elliott> teneen: you cannot do the impossible, so i don't even have to read the code to know it won't...
17:13:16 <tarmstrong> jfischoff: $( moduleInvokeAll "taco") would generate a list of functions from modules that implemented "taco".
17:13:33 <tarmstrong> jfischoff: I can get that to work, but I have to manually add import statements to the top of my Main.hs
17:13:44 <irene-knapp> if you really want that,
17:13:51 <irene-knapp> I think rather than TH you should investigate extending Cabal
17:13:59 <irene-knapp> it already provides various information about the package to itself
17:14:08 <irene-knapp> but the feature doesn't really fit there either
17:14:29 <jfischoff> sounds like you need haskell src-exts
17:14:44 <jfischoff> http://hackage.haskell.org/package/haskell-src-exts
17:15:05 <jfischoff> and runIO or whatever it is called from TH
17:16:51 <tarmstrong> so TemplateHaskell is a ghc plugin implemented by that package?
17:17:53 <irene-knapp> not exactly.  haskell-src-exts is just a parser.
17:19:01 <jfischoff> the runIO haskell-src-exts is a total hack but a powerfully one
17:19:25 <jfischoff> s /powerfully/powerful
17:19:38 <irene-knapp> oh, yeah, I see
17:19:40 <teneen> elliott: I believe the State monad version moves the burden from the stack to the heap, just as if it would be done with an accumulator
17:19:48 <irene-knapp> that Applicative quasiquoter uses it, doesn't it
17:20:25 <elliott> teneen: There is no real concept of "stack" in Haskell.
17:20:35 <elliott> The state monad uses the "stack" to hold the state, if anything.
17:20:54 <elliott> "Stack overflow" is GHC speak for "you blew a gigantic thunk".
17:21:12 <teneen> elliott: Is there a good source I can read about for this stuff?
17:21:20 <elliott> Dunno. #haskell?
17:21:53 <tarmstrong> ok, if I understand correctly: haskell-src-exts would let me write a haskell program that takes an existing package and injects import statements before feeding it to ghc?
17:23:03 <jfischoff> oh crap I think I forgot what you were trying to do :p
17:23:13 <jfischoff> trying to do too many things at once my bad
17:23:45 <jfischoff> and i have a meeting right now sorry!
17:23:50 <tarmstrong> jfischoff: :) no worries!
17:23:54 <Peaker> the fact you can build gigantic heaps but not gigantic thunks is non-trivial I think
17:23:59 <tarmstrong> jfischoff: thanks!
17:24:37 <teneen> elliott: so even function calls which are not co-recursive are not kept on a stack?
17:25:37 <elliott> teneen: I don't really know what you mean by that.
17:25:52 <shachaf> teneen: What does "a stack" mean? elliott just mentioned that that concept doesn't really mean much in Haskell.
17:26:01 <mgsloan> tarmstrong: It would, but you'd need to implement that as a GHC plugin or preprocessing step
17:26:19 <teneen> elliott: f x = 1 + f $! (x-1) + f $! (x-2)
17:26:23 <elliott> irene-knapp: the problem with an idiom bracket quasiquoter is that they don't nest :(
17:26:23 <mgsloan> parsing the entire module just to add imports might also be non-ideal, performance wise
17:26:33 <elliott> teneen: That doesn't really clarify to me.
17:26:38 <shachaf> Hey, it's mgsloan.
17:27:28 <irene-knapp> elliott: yes, indeed :( that was the first thing I said when I learned TH - "What, no quasiquoting?"
17:27:31 <mgsloan> Hey, it's shachaf!  Yeah, I always appear with mention of TH
17:27:54 <teneen> elliott: It's a recursive function which does not use guarded recursion and is not lazy (so no thinks I think). Shouldn't the (1+) be held on the stack until the two recursive calls return?
17:28:09 <shachaf> mgsloan: You said some things about arrows and/or monad transformers that I vaguely agreed with but didn't read carefully enough to see what they actually were!
17:28:14 <shachaf> ...Or something.
17:28:18 <teneen> elliot: thunks**
17:28:20 <mgsloan> elliott: Which isn't really a fundamental problem, just an annoying problem to solve.  I /really/ want to see / build a system for nesting quasi-quoters
17:28:34 <irene-knapp> mgsloan: Common Lisp has one, see
17:28:38 <shachaf> elliott? More like goneiott.
17:28:44 <irene-knapp> and my own language will have one too, but sans the Lisp syntax
17:29:26 <irene-knapp> in CL, you can easily do things like… hmm…. struggling to come up with an example that isn't contrived, but `(this is quasiquoted ,(but this is escaped `(and this is quasiquoted again ,(and this is escaped again))))
17:29:57 <irene-knapp> although you're more likely to do things like `(this is quasiquoted ,(but this is escaped `(and this is quasiquoted again ,',(this is escaped, quoted, and escaped))))
17:30:10 <irene-knapp> because that causes every escaped thing to evaluate at the time the form makes its first pass through the evaluator
17:30:28 <tarmstrong> thanks mgsloan! I'll give that a shot
17:31:36 <mgsloan> shachaf: Hmm, not sure what I was specifically saying, but usually what I say about those is that it seems like everyone just uses arrows for tuples, and that anything else is too complicated for the infix notation that it's lifted into
17:31:46 <kallisti> any particular reason why ordered binary trees are preferred for associative arrays over immutable hash table implementations?
17:32:01 <kallisti> I would think an immutable hash table would have asymptotic characteristics akin to Vector
17:32:26 <Peaker> kallisti, O(N) updates?
17:32:51 <Peaker> or do you mean the hash could support fusion?
17:32:54 <fragamus> what is a better way to say      do s <- get; return s
17:33:01 <Peaker> fragamus, get
17:33:22 <kallisti> Peaker: right
17:33:45 <fragamus> thanx
17:33:49 <fragamus> that worked
17:33:57 <fragamus> i am not experienced
17:34:07 <mgsloan> shachaf: So, with better (non-textual) notation, arrows might be better.  As for monad transformers, I feel like stacking them is ill-advised - and is akin to the spaghettiness that OOP / aspect oriented paradigms can cause.  So, in cases that a big stack of monad transformers seems like the solution, either a custom monad, or an unexposed monad stack would make sense
17:34:10 <fragamus> but I am coding a complex simulation in haskell
17:34:10 <Peaker> kallisti, well, you wouldn't really get persistent hash table updates and fusion at the same time
17:34:22 <Peaker> fragamus, do you know what "do" syntax opens up to? How it workS?
17:34:35 <fragamus> yes i do
17:34:39 <Peaker> mgsloan, were you the one who worried about anti-aliasing in bottle?
17:34:47 <mgsloan> Peaker: yup
17:34:59 <Peaker> mgsloan, I don't know if I told you but I uploaded a new graphics-drawingcombinators
17:35:03 <Peaker> mgsloan, with texture fonts
17:35:11 <mgsloan> cool! So did I :)
17:35:19 <teneen> Can someone briefly explain how "f x = 1 + f $! (x-1) + f $! (x-2)" is handled in the stack?
17:35:26 <mgsloan> Did you get the same disappearing-cursor thing that I got?
17:35:29 <Peaker> mgsloan, I mean I uploaded it to hackage..
17:35:33 <mgsloan> oh, cool!
17:35:52 <Peaker> mgsloan, Yeah -- the problem was that the FTGL library does what the OpenGL convention apparently is:  Leak the bound 2d texture state after it's done rendering the font
17:36:12 <Peaker> mgsloan, then all the GL operations by the graphics-drawingcombinators library operate with a texture bound but without setting any texture coordinates so you get all-black
17:36:23 <mgsloan> ahhh
17:36:43 <Peaker> so I just put a disable-2d-texture/enable-2d-texture around each operation in the lib
17:37:05 <Peaker> opengl is so horrible, even by imperative programming standards
17:37:10 <Peaker> communicating by mutating global state, bah
17:37:28 <Peaker> mgsloan, anyway, the rendering is fine now :)
17:37:38 <mgsloan> Peaker: better than fine! smooth :)
17:37:40 <Peaker> mgsloan, and I fixed all the known type inference bugs - - and it even handles infinite types now
17:37:53 <mgsloan> shweet!
17:38:16 <Peaker> mgsloan, now I am a bit agitated by the weird behavior of the cursor, hard to navigate. so I want to add a mouse-like movement of the cursor via alt-arrows..
17:38:45 <Peaker> Since I don't have text-lines, but rather arbitrary structure on screen, arrow key navigation doesn't work that well :(  I hope to find a good solution to this
17:40:14 <mgsloan> In my old data-flow-like interactive haskell thingy, I had a navigation thing where you move around the head of a vector from the current selection.  E.g. arrows act as velocitators / accelerators.  It'd then project a ray from this arrow, and use the first intersection as the navigation target that would be selected once you release the buttons
17:41:50 <mgsloan> it's definitely an interesting problem - good, keyboard-based, selection is the first step to good manipulation
17:42:42 <Peaker> mgsloan, interesting..
17:43:20 <Peaker> mgsloan, I think logical move rather than geometric move keys can be useful for a lot of operations, but when you move between totally unrelated entities it does not help
17:44:09 <mgsloan> well, what's cool about this idea is that very quick key gestures result in something like logical move
17:44:52 <mgsloan> e.g. if you just press up arrow briefly, it will create a short arrow, which will select the thing immediately above
17:45:33 <mgsloan> it'd be interesting to make it dual-mode, though, use the structure for the briefest key presses, and geometric for others
17:45:41 <Peaker> well, the arrow is geometric up, does it always correlate to logical up?
17:45:47 <mgsloan> nope
17:49:31 <mgsloan> So, I'm a bit of a heretic when it comes to structure editors.  I want them, but I want the majority of operations be text editing.  This comes from the assumption that the syntax of our languages, and the structure of well designed code, is such that many semantically interesting changes are straightforward text editing operations
17:50:29 <mgsloan> similarly, I think that geometric locality of well designed visual languages correspond directly to semantically interesting navigations
17:51:45 <Peaker> mgsloan, but they are also straight-forward structural editing operations :)
17:52:28 <Peaker> mgsloan, I don't want a "visual language", though, I want Haskell syntax and I think that there are constraints for readability about placements that mean geometric placement can't correspond too well to semantics
17:53:17 <mgsloan> Right!  The difference is the uniformity of the key interface.  For each domain / language part, you need to define "this is what up/down/left/right each mean".  Same for the structure manipulations.  We end up with a proliferation of key commands
17:54:18 <mgsloan> Yeah, I dislike the term "visual language", but use it in absence of a better canonical one
17:54:34 <mgsloan> (I usually use "rich language")
17:54:54 <mgsloan> to mean something that's largely textual, but has 2D structure for enhanced comprehension
17:56:17 <Peaker> mgsloan, there aren't that many key commands, I think
17:56:30 <mgsloan> oh yeah, it's not too bad - I like your implementation a lot!
17:56:32 <kallisti> mgsloan: I think any current editor needs to be largely texted-based, even if the text editor component is merely a small subcomponent of the larger structural editing interface; it's simply a reflection of how we write programs right now.
17:56:36 <Peaker> mgsloan, you get a pretty rich set of operations from just a few operations per type, many of which can overlap on keys if they are mutually exclusive
17:56:57 <Peaker> kallisti, the idea is to change how we write programs right now :)
17:57:04 <irene-knapp> oh yeah, so I just remembered a problem I had last week that I wanted to ask people here about
17:57:18 <Peaker> kallisti, it has a "text editor" for the name part of stuff, and for the "search dialog"
17:57:30 <irene-knapp> I wanted to make a monad that analyzed its action to determine what resources it was going to require, and acquired those resources in advance
17:57:43 <irene-knapp> but I realized that I couldn't, and that the reason I couldn't was precisely the difference between monads and applicatives
17:57:52 <kallisti> Peaker: sure. You can do that to some degree with existing languages. But you'll ultimately be working around their limitations.
17:57:55 <irene-knapp> so I did an applicative instead, but it was very awkward because there was a lot of almost-IO in it
17:58:14 <irene-knapp> it was my first time using applicatives :) so I'm not sure I did it the best way
17:58:21 <Peaker> kallisti, well, we might have a slightly modified language in the process, but what makes Haskell particularly text-bound?
17:58:33 <mgsloan> Peaker: Right! I want to get this kind of stuff going for real world stuff ASAP.  Which is why I think it'd be good to think about the evolution path for people used to vim-like editors.  Granted, it'll take time to implement this "vintage mode"
17:58:34 <irene-knapp> I don't have the code at home here, since this was actually for work, but I wanted to, mm, raise the subject for discussion I guess.  is it a reasonable thing to be atempting?
17:58:51 <Peaker> irene-knapp, sounds reasonable.. not sure why it was awkward
17:59:09 <irene-knapp> well, possibly the awkwardness was simply my growing pains
17:59:26 <Ralith> structural editing works great for lisp
17:59:31 <irene-knapp> I had to learn to structure it so all the interesting logic is in one place, left of the <$>, and the gathering stuff was after it
17:59:32 <Ralith> paredit is awesome
17:59:40 <irene-knapp> paredit and nxml-mode are awesome, yes
17:59:45 <sexykilla> helloooooooooooooo
17:59:47 <sexykilla> I provocative video and this is one of them. If you want more just go and click on advertising. I shall gain money by a single click and you are free ---->> https://www.youtube.com/watch?v=ptETHEjaHZg&feature=related
17:59:48 <irene-knapp> structure editing is another topic near and dear to me :)
18:00:05 <Peaker> irene-knapp, data RAct a = RAct Resources (Actions a)    instance Applicative RAct where pure = RAct mempty . pure   ;   RAct r1 a1 <*> RAct r2 a2 = RAct (mappend r1 r2) (a1 <*> a2)
18:00:41 <irene-knapp> hmm
18:00:42 <Peaker> Ralith, all the "structure editors" for lisp I saw seemed to be glorified text editors with some structural operations
18:00:51 <Peaker> Ralith, is paredit an emacs mode thing?
18:00:53 <Ralith> yes
18:00:55 <sexykilla> I provocative video and this is one of them. If you want more just go and click on advertising. I shall gain money by a single click and you are free ---->> https://www.youtube.com/watch?v=ptETHEjaHZg&feature=related
18:00:56 <kallisti> Peaker: well, you can make the editor structurally aware of the language as a tree of nodes, sure.
18:00:59 <irene-knapp> @where ops can we get sexykilla out of here please?
18:01:00 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
18:01:06 <mgsloan> gtg!  I'll be sure to read the logs, though
18:01:12 <Peaker> kallisti, it's not just aware -- it is the way the code is stored
18:01:29 <irene-knapp> so to my mind, what paredit doesn't do well enough is be scriptable
18:01:35 <irene-knapp> it would have great power for automated refactoring
18:01:38 <irene-knapp> if only it were
18:01:38 <Peaker> irene-knapp, did you see the code?
18:01:46 <irene-knapp> yes, digesting that
18:01:51 <Ralith> automated refactoring is more SLIME's domain
18:02:13 <irene-knapp> yes okay, that's what I did except I didn't use mempty or mappend (those are from Monoid, right?)
18:02:13 <Ralith> don't think it would take much to implement
18:02:32 <irene-knapp> perhaps, but then why doesn't it exist yet?  but yes
18:03:10 <sexykilla> I provocative video and this is one of them. If you want more just go and click on advertising. I shall gain money by a single click and you are free ---->> https://www.youtube.com/watch?v=ptETHEjaHZg&feature=related
18:03:11 <Peaker> irene-knapp, why not use a WriterT?
18:03:33 <kallisti> Peaker: what's your opinion of modal vs. not
18:03:45 <Peaker> irene-knapp, Yeah, mempty/mappend are Monoid's methods, and WriterT is basically a generalized RAct
18:03:49 <kallisti> I think a modal editor makes more sense when dealing with structures.
18:04:01 <irene-knapp> Peaker: well the "resources" in question were large tables of data being fetched from Postgres over the network, right, so the goal was to acquire them in advance
18:04:04 <kallisti> for example you can switch between the token level and the character level
18:04:06 <Peaker> kallisti, well, I dislike vi's modes, but our structural editor is very modal -- it has a different mode for each kind of language thingie you're editing
18:04:14 <irene-knapp> Peaker: so I'm not sure how WriterT applies
18:04:15 <irene-knapp> hmm
18:04:29 <Peaker> irene-knapp, so you can make a Monoid describing these tables
18:04:37 <irene-knapp> yeah, I see that
18:04:56 <irene-knapp> the thing is that I don't see how a Monad can do the analysis - it's precisely the difference, isn't it?
18:05:20 <irene-knapp> a Monad can't know the meaning of its actions before it performs them; contrariwise, an Applicative can't branch
18:06:06 <Peaker> so basically:   newtype RAct a = RAct (WriterT PostgresRequests (ReaderT PostgresResults IO)) a) deriving (Functor, Applicative)
18:06:09 <kallisti> Peaker: right I didn't mean "vi modal"  I meant modal more generally
18:06:17 <irene-knapp> the thing is that the place at which I want to acquire 'em is distant from the place at which I want to use 'em and I don't want to pass them down explicitly, whatever else
18:06:18 <irene-knapp> hmm
18:06:23 <irene-knapp> @hoogle WriterT
18:06:23 <lambdabot> Control.Monad.Writer.Lazy WriterT :: m (a, w) -> WriterT w a
18:06:23 <lambdabot> Control.Monad.Writer.Strict WriterT :: m (a, w) -> WriterT w a
18:06:23 <lambdabot> Control.Monad.Trans.Writer.Lazy WriterT :: m (a, w) -> WriterT w m a
18:06:23 <Peaker> irene-knapp, yeah, I'm suggesting WriterT for its applicative instance, not Monad instance
18:06:25 <kallisti> I don't think key combos are the way to go with an editor that has highly diverse "editing atoms"
18:06:27 <irene-knapp> no, bah, hmm
18:06:29 <irene-knapp> oh!  okay
18:06:30 <Peaker> kallisti, yeah, we're very modal
18:06:32 <irene-knapp> I didn't realize it was both
18:06:38 <irene-knapp> a applicative transformer, wow
18:06:58 <irene-knapp> *an
18:07:01 <kallisti> visual feedback is a must, I feel. it should be immediately obvious the state of the editor based on visual cues
18:07:03 <irene-knapp> @hackage mtl
18:07:04 <lambdabot> http://hackage.haskell.org/package/mtl
18:07:14 <Peaker> irene-knapp, so now you have RAct a, after you use Applicative on it, you eventually get something iso to:   (PostgresRequests, PostgresResults -> IO a)
18:07:16 <irene-knapp> kallisti: I agree
18:07:28 <irene-knapp> Peaker: right, okay, hmm
18:07:31 <Peaker> irene-knapp, actually applicatives don't really need transformers.. it's one of the advantages of applicatives/functors vs. monads
18:07:41 <Peaker> kallisti, you can try our editor out already
18:07:41 <irene-knapp> hmm, elaborate on that?
18:07:46 <Peaker> kallisti, and feel if it gives the feedback
18:08:01 <Peaker> irene-knapp, look at:
18:08:04 <Peaker> @ty fmap
18:08:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:08:05 <Peaker> @ty fmap . fmap
18:08:06 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:08:18 <irene-knapp> ah!  right
18:08:20 <Peaker> composing fmap's together like that gives you the "fmap" of the type-composed functors
18:08:20 <irene-knapp> vs
18:08:25 <irene-knapp> @ty return
18:08:26 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:08:30 <irene-knapp> @ty >>=
18:08:31 <lambdabot> parse error on input `>>='
18:08:35 <irene-knapp> @ty (>>=)
18:08:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:08:39 <Peaker> for Applicative, you have   pure/<*>
18:08:42 <irene-knapp> @ty return . return
18:08:43 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m, Monad m1) => a -> m (m1 a)
18:08:53 <Peaker> return . return   does compose well (just like   pure . pure)
18:08:58 <irene-knapp> yeah, okay, hm
18:09:00 <irene-knapp> right
18:09:08 <Peaker> But (<*>) and (>>=) don't compose well.  However,  liftA2 of applicative does compose well
18:09:13 * irene-knapp nods
18:09:16 <Peaker> @type liftA2 . liftA2
18:09:17 <lambdabot> forall (f :: * -> *) a b c (f1 :: * -> *). (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
18:09:29 <Peaker> f (f1 a)   is our composed applicative
18:09:38 <Peaker> And (<*>) is simply    liftA2 ($)
18:09:52 <Peaker> so this is what the TypeCompose library has:
18:10:15 <Peaker> newtype (f :. g) = O { unO :: f (g a) }
18:10:23 <Peaker> Giving the (:.) type-composition operator, and then:
18:10:33 <Peaker> oops
18:10:36 <Peaker> newtype (f :. g) a = O { unO :: f (g a) }
18:10:51 <Peaker> mirroring    (f . g) x = f (g x)   from the value-level
18:10:57 <Peaker> instance (Functor f, Functor g) => Functor (f :. g) where
18:11:26 <Peaker>   fmap f (O x) = O $ (fmap . fmap) f x
18:11:35 <irene-knapp> following mostly
18:11:39 <Peaker> or you can define:   inO f = O . f . unO
18:11:45 <Peaker> (apply a function inside the "O")
18:11:48 * irene-knapp nods
18:11:58 <Peaker> so fmap f = inO ((fmap . fmap) f)
18:12:10 <kallisti> Peaker: I'll check it out when my computer works again
18:12:25 <Peaker> so (:.) can compose two functors and yield a new functor
18:12:39 <Peaker> instance (Applicative f, Applicative g) => Applicative (f :. g) where
18:12:47 <Peaker>   pure = O . pure . pure
18:13:07 <Peaker>   (<*>) = inO2 ((liftA2 . liftA2) ($))
18:13:19 <Peaker> inO2 f (O x) (O y) = O (f x y)
18:13:35 <Peaker> however, if you try to instantiate Monad, you run into trouble
18:13:54 <Peaker> ideally you could do:        join :: f (g (f (g a))) -> f (g a)
18:14:11 <Peaker> but all you have is:   join :: f (f a) -> f a       and  join :: g (g a) -> g a
18:14:36 <Peaker> and you have functor/applicative, but all these together are not enough to compose these two joins into the composed join
18:15:36 <Peaker> irene-knapp, so say you have two Applicatives,   like IO  and  Maybe        you can just compose them with :.         (IO :. Maybe) a      and you got yourself an "applicative transformer" for free.. no need to implement one for each Applicative type
18:15:54 <Peaker> irene-knapp, this is why it is said that Functors/Applicatives compose, and Monads don't.. or that Applicative is more composable than Monad
18:16:15 <irene-knapp> yes, hmm
18:16:36 <irene-knapp> but IO is just an example, right?  you couldn't really create a Haskell-like language that has instance Applicative IO, could you?
18:16:50 <Peaker> IO has an instance of Applicative.. all (non-buggy) monads do
18:16:55 <irene-knapp> hmm
18:16:56 <Peaker> Applicative is a subset of the power of Monad
18:16:57 <irene-knapp> I suppose it does, hmm
18:17:16 <Peaker> pure = return
18:17:21 <Peaker> (<*>) = ap
18:17:22 <Peaker> @src ap
18:17:23 <lambdabot> ap = liftM2 id
18:17:41 <Peaker> irene-knapp, from   return and  (>>=)   you can define fmap, pure, and (<*>)
18:17:54 <irene-knapp> certainly
18:18:09 <Peaker> so if something has a Monad instance but not an Applicative instance, it's a bug
18:18:15 * irene-knapp nods
18:18:25 <Peaker> (and hopefully some day they make Monad a subclass of Applicative, like they dared change Num not to have Eq/Show)
18:20:27 <Peaker> irene-knapp, so I think transformers is a more common library than TypeCompose, so I suggested WriterT and ReaderT, but you could also use   ([PostgresRequest],) :. (PostGresResponse ->) :. IO   to build your Applicative
18:20:50 <irene-knapp> that makes sense to me, yes
18:20:52 <favonia> Peaker: the latter is less destructive in practice :P
18:20:57 <irene-knapp> well, I'm not going to rewrite it at this point but :)
18:21:03 <Peaker> favonia, what do you mean?
18:21:09 <irene-knapp> I was very interested in basically what you just told me, so
18:21:24 <favonia> removing Eq/Show from the superclasses of Num
18:21:50 <Peaker> favonia, I don't think Monad subclassing Applicative would be that destructive.. all damage would be trivial
18:22:13 <startling> so I've got a data type that contains two semantically different lists. what would be the typical way to deal with mapping over it? make it a functor that accepts ([a] -> [a], [b] -> [b])?
18:23:13 <startling> or is there some deeper magic I should know about?
18:24:13 <favonia> Peaker: hmm I guess you're right. adding superclasses requires more instances, and removing them requires more contexts in type declarations.
18:24:56 <Peaker> favonia, yeah, and Applicative/Monad instances must agree or its a bug anyway
18:25:11 <startling> oh, I can't do that, can I
18:25:17 <Peaker> favonia, so adding the instances of Applicative needed is trivial, and if it conflicts with others, deleting the others is trivial too
18:25:47 <Peaker> startling, you have: data Foo a b = Foo ([a], [b]) ?
18:26:24 <startling> Peaker, no, I have "data Foo = Foo [Word16] [Word16]"
18:26:55 <startling> actually the first one's a map and the second one's an array, but same deal, right?
18:27:51 <Peaker> startling, well, if it's not polymorphic, it's certainly not a Functor
18:27:58 <favonia> Peaker: I understand all of these could be trivial, as you can replace "Num a" with "Num a, Eq a, Show a" in old code in another direction. Perhaps people worry about that trivial modifications too. :)
18:28:00 <Peaker> class Functor (f :: * -> *) where ...
18:28:15 <startling> oh, right
18:28:17 <Peaker> favonia, it's unfortunate, because the damage due to these problems is non-trivial
18:28:25 <Peaker> favonia, and the damage due to a potential fix is trivial
18:28:52 <Peaker> startling, if you made it a record, you could use AtFieldTH to generate modifier functions for these
18:29:24 <Peaker> startling, data Foo = Foo { a :: [Word16], b :: Array Int Word16 }   AtFieldTH.make ''Foo   ;; now you have:   atA :: ([Word16] -> [Word16]) -> Foo -> Foo
18:29:40 <Peaker> startling, and    atB :: (Array Int Word16 -> Array Int Word16) -> Foo -> Foo
18:30:06 <Peaker> https://github.com/Peaker/bottle/blob/master/bottlelib/Data/AtFieldTH.hs
18:30:14 <startling> interesting
18:30:25 <startling> but there's no higher-level interface for such a thing?
18:30:27 <Peaker> you could map over both with f and g via:    atA f . atB g
18:30:41 <Peaker> what do you mean? This is pretty high-level :)
18:30:50 <Peaker> (atA . map) (*2)
18:30:58 <startling> Peaker, i guess I mean "there's no typeclass for this?". heh
18:31:08 <Peaker> that does what?
18:31:18 <startling> that defines an interface like this
18:31:22 <Peaker> you define your record -- you execute the macro -- you get accessors for everything
18:31:47 <Peaker> a type-class is meant to generalize some function to multiple types
18:31:55 <Peaker> or some non-function
18:32:02 <Peaker> what value do you want to generalize over multiple types here?
18:33:34 <startling> that's true
18:33:55 <startling> Peaker: I think I understand better now. thanks!
18:36:29 <startling> if I have two a -> x and an a, is there something that applies each function the that argument and then returns (x, x)?
18:36:39 <startling> i could use a lambda but meh
18:37:25 <shergill> my knowledge is rusty but seems similar to arrows
18:37:45 <startling> o rly. time to level up, I guess
18:37:57 <Peaker> startling, (f &&& f) or  join (&&&) f
18:38:12 <Peaker> oops
18:38:24 <Peaker> (f &&& g)
18:38:38 <startling> Peaker, lovely
18:38:44 <Peaker> from Control.Arrow
18:38:48 <Peaker> > (+100) &&& (*2) $ 10
18:38:49 <lambdabot>   (110,20)
18:44:46 <dmwit> startling: Longer-term, you probably will want to look into learning about lenses.
18:45:05 <dmwit> You get atFieldName-style things, but also several other useful abstractions.
18:46:10 <Peaker> dmwit, a getter?
18:46:42 <Peaker> I think lens is a less-useful-atFieldTH + getter  the tuple is nice, but usually you don't need the pair, and you already have a getter
18:46:57 <dmwit> yes, get and set, but also parallel and sequential composition, etc.
18:47:43 <dmwit> depending on how your library's author feels about PutPut, a map combinator...
18:48:33 <Peaker> well, the at'ers are composable, and getters are composable
18:48:41 <dmwit> And, of course, lenses are first class.
18:48:52 <Peaker> it's just that you don't have a pair to compose, but I haven't encountered many cases where I missed that
18:48:55 <dmwit> Which is nice in a few special cases.
18:49:00 <startling> dmwit: interesting
18:49:02 <Peaker> it's also nice to compose at'ers with fmap, argument, etc..
18:49:28 <dmwit> Peaker: Can you explain what you mean by "lens is a less-useful-atField"? What's less useful about it?
18:49:44 <Peaker> dmwit, its type is restrictive
18:50:02 <MostAwesomeDude> Are we talking about data-lens, or another lens?
18:50:02 <Peaker> you only get to lift (a -> a) functions for the fields, not (a -> b) ones (if there are no other fields constraining "a")
18:50:26 <dmwit> Ah, yes, lenses don't provide polymorphic record update.
18:50:47 <dmwit> Or polymorphic field update, I guess; whether it's a record or not is immaterial.
18:50:55 <Peaker> I use polymorphic updates very often..
18:51:01 <dmwit> yes
18:51:06 <dmwit> I agree that can be a bit annoying.
18:52:09 <MostAwesomeDude> How would that work, exactly? If you have your target type as Target a, then how could you lift an (a -> b) function onto a lens for it?
18:52:28 <MostAwesomeDude> Like, what would the function signature look like?
18:53:03 <dmwit> :t \f (Just a) -> Just (f a) -- its signature would look something like this, MostAwesomeDude =)
18:53:04 <lambdabot> forall t a. (t -> a) -> Maybe t -> Maybe a
18:53:47 <MostAwesomeDude> So how's that different from current lenses?
18:54:03 <startling> how do i return a new array with everything the same except a certain index, which is changed?
18:54:09 <dmwit> A current lens is less polymorphic: its first argument is only allowed to be an endomorphism (a -> a).
18:54:24 <dmwit> You can't change the type of a field with current lenses.
18:54:44 <dmwit> startling: \\, I think
18:55:07 <startling> dmwit: doesn't (\\) take a list of changes, though? seems like there would be something more basic
18:55:09 <dmwit> ?hoogle [(i,e)] -> Array i e -> Array i e
18:55:09 <lambdabot> Data.Array (//) :: Ix i => Array i e -> [(i, e)] -> Array i e
18:55:09 <lambdabot> Data.Array accum :: Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
18:55:09 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
18:55:23 <MostAwesomeDude> Hmm. Considering the rules of lenses, that doesn't seem like a big problem. But then again, I just think of lenses as more pleasant than record syntax.
18:55:24 <dmwit> Oops, it's //, not \\.
18:56:01 <dmwit> MostAwesomeDude: Yes, I agree. I'm now thinking about how you might write the type for a more polymorphic lens...
18:56:54 <dmwit> data Lens f a = Lens (f a -> a) (f a -> b -> f b) -- ?
18:57:10 <dmwit> tricky, though, because type functions have to be fully applied
18:57:19 <Peaker> dmwit, you need to have the "container" type be (* -> *) probably
18:57:23 <dmwit> maybe the type function you want can't be curried in the way required by this type
18:57:41 <Peaker> you could newtype it, but that would be horrible :)
18:57:44 <Peaker> maybe with type-family tricks
18:58:02 <dmwit> s/type function/type family/ above and reread my caveats =)
18:59:01 <Peaker> oh :)
18:59:07 <Peaker> worth a try
18:59:12 <Peaker> might bring me back to lenses :)
18:59:14 <Peaker> (if it works)
18:59:53 <shergill> hmm when would you want polymorphic field updates?
19:00:55 <MostAwesomeDude> transform (InputValue a b c) = OutputValue a b (transformed c)
19:01:04 <Peaker> shergill, almost every time your record is polymorphic and you want to update a field
19:01:06 <MostAwesomeDude> AFAICT.
19:01:31 <MostAwesomeDude> Oh, oh! You're talking about things where the actual type in the values you're creating is polymorphic.
19:01:42 <Peaker> shergill, https://github.com/Peaker/bottle/blob/master/bottlelib/Graphics/UI/Bottle/Widget.hs#L102
19:02:18 <fragamus> hey guys I would like to ask if this can be expressed more succinctly: burn = do modify (\(deck,discards) -> let part = splitAt 1 deck in (snd part, fst part ++ discards) )
19:02:36 <zhengsenlin> hello
19:02:41 <zhengsenlin> my name is zhengsenlin
19:03:09 <dmwit> fragamus: \(deck, discards) -> (drop 1 deck, take 1 deck ++ discards) -- ?
19:03:21 <fragamus> nice dude
19:03:36 <fragamus> i think it is slower though right
19:04:08 <dmwit> Benchmark it. I doubt you'll find a significant difference, though.
19:04:15 <fragamus> ok
19:04:46 <dmwit> If the 1 was not such a small number, then it might be different. =)
19:05:05 <startling> alright, i feel like I'm re-implementing monads but I can't make it fit. someone want to take a look? https://gist.github.com/00eb529408d7f9202977
19:05:16 <startling> note especially the functions at the end
19:05:25 <dmwit> But matching one list constructor (via take 1/drop 1) or one tuple constructor (via fst/snd) doesn't seem like a significant difference to me.
19:08:47 <copumpkin> startling: I wouldn't use a UArray there
19:09:05 <copumpkin> and I don't think you're reinventing monads
19:09:33 <startling> copumpkin, what would you use?
19:09:52 <copumpkin> an IntMap or the fancy Memory data type I was working on a couple of years ago :)
19:09:59 <copumpkin> but probably just an IntMap for your purposes
19:10:57 <dmwit> A mutable array is also possible.
19:11:11 <copumpkin> yeah
19:11:28 <copumpkin> startling: I don't advocate following what I did here, but this is one approach I started with ages ago: https://github.com/copumpkin/charm/blob/master/src/Architecture/ARM/State.hs
19:11:31 <startling> copumpkin, is there a word16 map thing?
19:11:44 <copumpkin> no, but it doesn't make much of a difference
19:11:48 <copumpkin> it's annoying to have to convert
19:11:53 <copumpkin> but other than that you shouldn't lose much
19:11:58 <startling> well, automatic overflow/underflow handling would be nice
19:12:18 <copumpkin> you get that just by dealing with a Word16 internally
19:12:24 <startling> s'true
19:12:28 <copumpkin> and converting to Int just when you need to access memory
19:13:27 <startling> DiffArray seems like it would be the best thing, but the wiki says not to use it
19:13:47 <startling> also, is there something better for mapping a Register to a Word16/Int?
19:13:50 <copumpkin> it's not terrible, but it's not that great
19:14:03 <copumpkin> I just used a Map in mine
19:14:50 <startling> I feel like there should be a mapping type that maps every X to some Y
19:15:06 <dmwit> (->)
19:15:08 <copumpkin> a function :P
19:15:09 <copumpkin> yep
19:15:17 <copumpkin> except you need to write it in agda
19:15:20 <startling> well yeah. but you can't update a function really
19:15:26 <startling> ...can you?
19:15:29 <copumpkin> immutably :P
19:15:32 <startling> sure
19:15:33 <copumpkin> but I wouldn't recommend it
19:15:43 <copumpkin> it takes O(number of updates) to read from it
19:15:48 <startling> ah
19:15:53 <dmwit> :t \f i newo i' -> if i' == i then newo else f i'
19:15:54 <lambdabot> forall t a. (Eq a) => (a -> t) -> a -> t -> a -> t
19:16:02 <dmwit> But you could flatten it every once in a while.
19:16:13 <startling> meh, I'll just use an array
19:16:17 <copumpkin> :P
19:16:22 <startling> Ix isn't onerous
19:17:02 <copumpkin> what architecture is this, by the way?
19:17:06 <startling> dcpu16
19:17:08 <startling> heh
19:17:31 <startling> I wrote an emulator in python and thought this would be an okay way to learn more haskell
19:17:37 <copumpkin> cool :)
19:17:45 <copumpkin> I started a similar project for ARM when I was starting haskell
19:17:54 <copumpkin> got buried in the decoder and never did any of the rest
19:18:08 <copumpkin> which is why the stuff I linked to was so sketchy
19:18:17 <startling> copumpkin, decoder?
19:18:17 <copumpkin> the decoder is monstrous though :)
19:18:21 <copumpkin> decoding instructions
19:18:28 <startling> oh
19:18:36 <startling> shoulda used attoparsec or something. :)
19:18:40 <copumpkin> no way
19:18:44 <copumpkin> have you seen how complicated ARM is?
19:18:48 <startling> nope!
19:18:49 <copumpkin> and thumb and thumb32
19:18:51 <copumpkin> and stuff like that
19:18:54 <copumpkin> it's terrifying
19:18:57 <startling> haha
19:19:02 <copumpkin> I basically have my own ad-hoc parser language for it
19:19:18 <copumpkin> here's one piece of it: https://github.com/copumpkin/charm/blob/master/src/Architecture/ARM/Decoder/ARM.hs
19:19:30 <copumpkin> it's all loosely derived from the libopcodes decoder
19:19:35 <copumpkin> but they use a nasty format string with no type safety
19:19:48 <copumpkin> and have several other icky things
19:19:55 <startling> copumpkin, well, it's C
19:19:59 <copumpkin> I know :)
19:20:05 <copumpkin> it's ugly even for C though
19:20:13 <copumpkin> but it does contain good data
19:20:22 <copumpkin> since ARM doesn't publish machine-readable specs of their instruction set
19:20:36 <copumpkin> but they have a couple of employees contributing to libopcodes
19:20:50 <startling> machine-readable specs? is that typical?
19:21:00 <copumpkin> I dunno, but you want them
19:21:03 <startling> yeah
19:21:20 <copumpkin> that big file is just one of several sub instruction sets
19:21:36 <copumpkin> https://github.com/copumpkin/charm/blob/master/src/Architecture/ARM/Decoder/Thumb32.hs
19:21:39 <copumpkin> that's another one
19:21:42 <irene-knapp> pity me btw,
19:21:52 * copumpkin pities irene-knapp 
19:21:54 <irene-knapp> because my latest "fun" project is to be an assembler for Intel
19:21:56 <irene-knapp> no
19:21:57 <irene-knapp> listen to why
19:22:00 <irene-knapp> THEN pity me
19:22:02 <copumpkin> lol
19:22:03 <irene-knapp> don't just pity me generically
19:22:04 <startling> irene-knapp, have you seen harpy?
19:22:07 <irene-knapp> no
19:22:11 <copumpkin> I double-pity you now
19:22:15 <irene-knapp> haha
19:22:23 <copumpkin> double-dog pity!
19:22:23 <irene-knapp> can I anti-pity myself so that I'm only pitied once?
19:22:30 <startling> irene-knapp: http://hackage.haskell.org/package/harpy
19:22:55 <irene-knapp> so mine is going to be a typed assembler, see
19:23:13 <startling> irene-knapp, are all the types "bytes"?
19:23:16 <irene-knapp> that is, it will embed proofs (which will have to be given to it by a higher layer) that the type ...
19:23:23 <startling> ah
19:23:27 <irene-knapp> meh, just cf. Benjamin Pierce's book
19:23:31 <copumpkin> so TAL/DTAL stuff
19:23:41 <irene-knapp> yes
19:23:51 <copumpkin> my main goal is reverse engineering and I've thought a decent amount about TAL-like ideas "From the other side"
19:24:30 <irene-knapp> right, hmm
19:24:32 <irene-knapp> from the other side?
19:24:40 <copumpkin> you have a big binary blob
19:24:44 <irene-knapp> oh, hmm
19:24:45 <copumpkin> you're trying to make sense of it
19:24:47 <irene-knapp> right
19:24:53 <copumpkin> you need a decoder, but you can't just run it willy-nilly
19:24:57 <irene-knapp> google "algorithm recognition", there's actually some stuff on it
19:25:01 <copumpkin> IDA does this, to varying degrees of success
19:25:11 <copumpkin> but I think types are quite valuable here too
19:25:12 <tgeeky> are De Brujin indices (or levels, whatever they are), the kind of thing the thing that one should be doing at the kind level these days?
19:25:17 <irene-knapp> I want that too, but it's not my goal this week/month/year
19:25:22 <copumpkin> :)
19:25:27 <copumpkin>  /decade (for me)
19:25:30 <irene-knapp> indices and levels are as I understand it the same thing but with the numbers flipped or something
19:25:30 <copumpkin> got too many other concurrent projects
19:25:34 <irene-knapp> right
19:25:39 <irene-knapp> well, this is mine for the moment :)
19:25:42 <copumpkin> cool
19:25:47 <copumpkin> sounds exciting
19:25:48 <irene-knapp> although with recent developments it may not be for long haha
19:25:55 <copumpkin> ?
19:25:57 <irene-knapp> recent developments being GHC works on OS X again
19:26:00 <copumpkin> oh ok
19:26:30 <startling> irene-knapp: hehe
19:26:33 <irene-knapp> and a couple of my old projects that might be resurrectable by this -fno-state-hack thing
19:26:49 <irene-knapp> if it turns out that the state hack was the cause of their inexplicable order-of-magnitude performance problems
19:27:02 <irene-knapp> I need to get my Haskell universe back into shape before I can find that out
19:28:09 <irene-knapp> but yes, exciting in principle
19:28:38 <copumpkin> :)
19:33:32 * hackagebot husk-scheme-libs 0.0.1 - Extra libraries for the husk Scheme platform.  http://hackage.haskell.org/package/husk-scheme-libs-0.0.1 (JustinEthier)
19:48:34 * hackagebot hmatrix-gsl-stats 0.1.3 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.3 (VivianMcPhail)
19:51:32 <ClaudiusMaximus> hm, compiling with  -fno-state-hack  reduced my runtime from 29.5s to 0.5s
19:53:59 <JoeyA> What's a good way to produce a graph from a Criterion benchmark?
19:55:10 <JoeyA> Just use CSV output and throw it into some Excel-like program?
19:56:12 <m3ga> JoeyA: i'm pretty sure Criterion already has the ability to create graphs.
19:56:29 <m3ga> it may be in a criterion related package.
19:56:48 <ClaudiusMaximus> it's built in
19:57:09 <ClaudiusMaximus> you need to give a path to a style file as a command line argument
19:57:24 <ClaudiusMaximus> an example template is provided in the cabal install'd location
19:57:41 <JoeyA> Are you sure Criterion still supports charting?  http://stackoverflow.com/a/9731244/149391
19:58:00 <ClaudiusMaximus> oh, not checked for a while
19:59:23 <m3ga> it still supports HTML charting :-)
19:59:26 <ClaudiusMaximus> JoeyA: the html has graphs generated by javascript, if that's what you didn't mean
20:01:03 <AfC> s/by javascript/by javascript on the client side in your browser/, yeah
20:02:19 <ewtoombs> does referential transparency mean any data structure can be copied, if the compiler wants to?
20:02:45 <JoeyA> ewtoombs: Yes, it implies that.
20:03:00 <ewtoombs> that's fucked up
20:03:04 <JoeyA> I'm not finding any options for HTML output.  I ran ./my-program -t /home/joey/git/criterion/templates/report.tpl , but it didn't produce any files.
20:03:17 <JoeyA> ewtoombs: How so?
20:03:55 <ewtoombs> what about stuff like cycles in references inside an object? how does it handle that?
20:04:36 <mightybyte_> Anyone know anything about a ghci crash like this?  https://gist.github.com/2921565
20:05:07 <JoeyA> ewtoombs: What has it to handle?
20:05:18 <startling> mightybyte_: os x?
20:05:21 <JoeyA> Garbage collection?
20:05:27 <startling> yep
20:05:31 <mightybyte_> startling: yep
20:05:35 <startling> mightybyte_: yeah, i get it too
20:06:36 <mightybyte_> I've searched for information about it, but so far I've come up dry.
20:07:47 <JoeyA> Ah, it's just ./my-criterion-benchmark -o out.html
20:07:54 <startling> me too. dunno where the appropriate place to report it would be, though; i probably should
20:08:04 <startling> mightybyte_, it's new with 7.4.x, isn't it?
20:08:08 <mightybyte_> Yes
20:08:25 <mightybyte_> I was hoping 7.4.2 would fix it, but nope.
20:09:27 <td123> mightybyte_: that's output from 7.4.2 crashing?
20:09:35 <td123> nvm
20:09:36 <mightybyte_> Yeah
20:09:39 <td123> :P
20:10:23 <startling> mightybyte_: yeah! fortunately they fixed the imports-fail-silently thing
20:10:36 <ewtoombs> >let x = (1,x) in x
20:10:37 <edwardk> :t traverse (const Nothing)
20:10:38 <lambdabot> Not in scope: `traverse'
20:10:49 <ewtoombs> > let x = (1,x) in x
20:10:50 <edwardk> :t Data.Traversable.traverse (const Nothing
20:10:50 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t1, t)
20:10:51 <lambdabot> parse error (possibly incorrect indentation)
20:10:51 <edwardk> :t Data.Traversable.traverse (const Nothing)
20:10:52 <lambdabot> forall a a1 (t :: * -> *). (Data.Traversable.Traversable t) => t a1 -> Maybe (t a)
20:11:06 <edwardk> that works
20:11:31 <ewtoombs> > let x = (1,x) in x
20:11:32 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t1, t)
20:11:33 <edwardk> want a 'closed' check for a term, so it can take t a -> Maybe (t Void)
20:12:33 <ewtoombs> > let x = (1,x) in fst x
20:12:34 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t1, t)
20:12:37 <dmwit> hm, is there a way to write something like
20:12:46 <dmwit> data Ext = Ext (forall v. F v ~ G v)
20:12:47 <dmwit> ?
20:13:00 <ewtoombs> hm. why doesn't what I just typed work?
20:13:03 <edwardk> you want a higher rank constraint?
20:13:11 <tac-tics> ewtoombs: The inferred type was an infinite type
20:13:14 <dmwit> edwardk: yeah
20:13:21 <ewtoombs> I thought haskell was into all that lazy stuff though.
20:13:23 <tac-tics> ewtoombs: While objects in Haskell can be infinite, types cannot.
20:13:26 <edwardk> are F and G type families or data types?
20:13:36 * hackagebot Adaptive 0.1 - Adaptive precision floating-point arithmetic  http://hackage.haskell.org/package/Adaptive-0.1 (DustinDeWeese)
20:13:47 <dmwit> edwardk: type families, of course; F v ~ G v is always false for data types
20:13:54 <edwardk> =)
20:13:55 <ewtoombs> I guess that's one way to make sure you can copy objects...
20:14:17 <tac-tics> ewtoombs: for example, you can have a list of integers, a list of lists of integers, a list of list of lists of integers, and so on
20:14:29 <tac-tics> ewtoombs: but you can't do that infinitely: [[[[[[....]]]]]]
20:14:41 <edwardk> you could make something that contained a reference to a class where the dictionary has an explicit witness of that somehow that you can instantiate for each type in turn
20:14:45 <dmwit> edwardk: actually, I want data Compose lens lens' = Compose (forall v. Source lens v ~ View lens' v) -- =)
20:15:08 <dmwit> That's worth a shot.
20:15:37 <tac-tics> ewtoombs: Not to say you can't "make sense" of infinite types -- theree are some languages that do allow them -- but Haskell does not.
20:15:38 <edwardk> just put some kind of leibnizian equality witness right in the class as one of the members
20:15:39 <orzo> i want to obtain argv[0] in my haskell program.  How do i do it?
20:16:06 <mightybyte_> :t getArgs
20:16:08 <lambdabot> Not in scope: `getArgs'
20:16:20 <tac-tics> orzo: getArgs in System.Environment
20:16:25 <dmwit> orzo: getProgramName
20:16:31 <dmwit> All you other folks are posers.
20:16:38 <edwardk> class Foo lens lens' | … where witness :: f (Source lens v) -> f (View lens' v) -- then use the polymorphism and lack of information about f to enforce that the only sane witness is id
20:17:03 <edwardk> you may have to abuse witness in a few places manually though
20:17:04 <dmwit> Whoops, it seems to be called getProgName, not getProgramName.
20:17:04 <orzo> thanks, dmwit
20:17:11 <orzo> hm
20:17:49 <edwardk> i guess you could just do that directly with a higher rank type and no class
20:18:44 <edwardk> data Ext l l' = Ext (forall f v. f (Source l v) -> f (View l' v))
20:18:54 <edwardk> er newtype even
20:19:14 <dmwit> edwardk: Right, that's actually exactly what I typed (up to alpha equivalence). =)
20:19:29 <dmwit> That's a good tip, let's see how it works out...
20:19:41 <edwardk> well, you had a ~ in there, which is stronger than leibnizian equality ;)
20:20:07 <dmwit> Sorry, I mean exactly what I typed after I read your "Leibnizian equality" hint. =)
20:20:12 <edwardk> ah
20:20:14 <edwardk> fair nuff
20:23:18 <edwardk> i always forget how useful free monads are
20:23:27 <mightybyte_> startling: Hmmm, I wonder if it has something to do with 64-bit.
20:39:26 <startling> mightybyte_, oh, hm, 7.4.x is the first 64-bit on os x, isn't it?
20:40:18 <mightybyte_> No
20:40:28 <mightybyte_> There was 64-bit for 7.0.x
20:40:43 <startling> but it wasn't the default?
20:40:54 <mightybyte_> Dunno
20:41:04 <mightybyte_> I think I made the choice.
20:41:14 <mightybyte_> This time I used homebrew and it chose for me.
20:44:58 <mightybyte_> startling: Hmmm, it looks like that may have fixed it.
20:49:29 <hpaste_> dmwit pasted “tricky error” at http://hpaste.org/69874
20:49:33 <geekosaur> 7.0.x had a 64 bit, but the official download page said to use 32-bit unless you really needed 64-bit.  various other installers seem to have followed suit; someone on the list noted they had had to override brew to get the new one 64-bit
20:49:39 <geekosaur> (and then had to clean up various 32 vs. 64 bit messes as a result of the switch)
20:49:41 <geekosaur> actually no, they didnt need to override, they got switched forcibly without notice, leading to the cleanup
20:51:22 <dmwit> Oh, maybe you can never apply a function of type (forall v. F v -> ...) when F is a type family.
20:51:31 <dmwit> That's annoying, isn't it.
20:53:33 <copumpkin> well, if you have the v appear alone
20:53:37 <copumpkin> and can provide a witness for it
20:53:39 <copumpkin> you should be able to apply it
20:53:51 <dmwit> Right, so I'll need to use the (usual) Proxy trick, no?
20:54:07 <copumpkin> yeah, but I'm not sure about constructing such a function
20:54:14 <copumpkin> or rather, what you'd be able to do with that value
21:06:36 <JoeyA> There should be a cabal option to disable upper bounds on package requirements.
21:06:39 <JoeyA> There, I said it.
21:07:20 <edwardk> cabal --leave-me-alone
21:08:00 <JoeyA> Reasoning: package writers don't know *for sure* that future versions of a dependency will break their own.  That is, unless they haven't gotten around to fixing their package.
21:08:54 <JoeyA> Sure, it's "safer" to use upper bounds or even a fixed version on the dependency, but then users end up, for example, having their version of array dragged down to 0.3.0.0
21:10:37 <JoeyA> In my opinion, an upper bound should not be used unless 1) a version exceeding that bound has already been uploaded to Hackage, and 2) it is known for a fact that the new version breaks the current package.
21:10:51 <blackdog> JoeyA: i just wish the whole thing could be type-driven
21:11:32 <JoeyA> Here's what set me off: http://hackage.haskell.org/package/jsmw
21:11:41 <JoeyA> build-depends: base >= 4.0.0, mtl, WebBits == 0.15, DOM == 2.0.1
21:12:23 <edwardk> the DOM == 2.0.1 is a pretty awkward bound
21:12:38 <JoeyA> Though maybe the author did in fact know the new version of WebBits breaks things.
21:12:57 <JoeyA> Still, what if there's a bugfix WebBits 0.15.1 uploaded?
21:14:15 <edwardk> well, you can do a little better with == 0.15.*
21:14:45 <edwardk> thats technically all the PVP will let you get away with there
21:21:02 <startling> mightybyte_, using 32-bit?
21:23:28 <JoeyA> Ugh, neither HJavaScript nor WebBits implements infix correctly.  For example, renderExpression $ (IntLit () 1 .+. IntLit () 3) .*. IntLit () 5  prints "1 + 3 * 5"
21:23:41 <JoeyA> where a .*. b = InfixExpr () OpMul a b ; a .+. b = InfixExpr () OpAdd a b
21:24:10 <JoeyA> At least WebBits has a github and issue tracker.  Maybe I'll submit a bug report.
21:25:58 <mightybyte_> startling: Yes
21:26:15 <startling> mightybyte_: interesting, thanks
21:26:40 <startling> mightybyte_, is there a homebrew flag?
21:27:14 <startling> --32-bit, surprisingly enough
21:27:20 <JoeyA> Oh, you have to put ParenExpr in yourself.
21:27:39 <JoeyA> So it's a concrete syntax tree, not an abstract syntax tree.
21:41:58 <startling> what are the standard types for dealing with dates?
21:42:48 <mightybyte_> startling: Did the homebrew flag work for you?
21:42:53 * ClaudiusMaximus tried to implement Monad Maybe in Lua, got to 15 lines then gave up when i realized that without lighter syntax for lambdas and/or do-notation it would be hell to use   function liftM2(f,a,b) return mbind(a, function(va) return mbind(b, function(vb) return mreturn(f(va,vb)) end) end) end
21:43:22 <startling> mightybyte_: yep
21:43:31 <mightybyte_> Nice
21:43:35 <mzero> mightybyte_: I just commented on your gist about the Mac OS X error
21:43:55 <mightybyte_> startling: For dates, I typically use Data.Time.Calendar.Day
21:44:32 <startling> mzero, you sure 4,1 costs money on 10.6?
21:44:43 <mzero> no - it isn't that Xcode costs
21:44:53 <startling> well, the developer thing does
21:44:55 <mzero> it is that the download section on apple's developer site
21:45:03 <mzero> now only has Xcode 4.x for 10.7
21:45:19 <mzero> the versions for 10.6 are no longer available except as a "historical" download
21:45:20 <mightybyte_> mzero: Oh, dang.  I'm using xcode 3.2.3
21:45:26 <mzero> and those are only available to paid developers
21:45:33 <startling> how much of xcode is needed?
21:45:36 <startling> there's this: https://github.com/kennethreitz/osx-gcc-installer
21:45:59 <mightybyte_> mzero: So yeah, sounds like that's it.
21:46:02 <mzero> I don't know, really.... can you use the 32-bit version of GHC there?
21:46:51 <mightybyte_> mzero: The thing I found bizarre is that 64-bit ghc seems to work fine.  It's just ghci that craps out.
21:46:53 <mzero> (to be honest, I don't see how that crash in garbage collection is related to what Xcode (and hence various tools) you have loaded on 10.6... but Igloo says it's so and I believe him
21:47:09 <mightybyte_> lol
21:47:47 <mzero> though, to be certain, he might just be saying that they couldn't get 64-bit to work on non-Xcode 4 systems, and so they aren't going to look into this
21:47:59 <startling> mzero: yeah, it's very strange
21:48:06 <startling> err, mightybyte_ ^
21:48:19 <mzero> do you need 64-bit? few people actually do, and it takes more memory, and hence often slower
21:48:58 <mzero> unless you need a >4GB data set in RAM, there is little benefit at present to 64-bit GHC
21:49:08 <mightybyte_> Yeah, 32-bit is fine for now.
21:49:11 <mzero> (at least on Mac, though I suspect it's true of Linux)
21:49:28 <mzero> try that - no one has reported this crash (at least to me) using the 32-bit version on 10.6
21:49:31 <mightybyte_> And if I needed 64-bit, I have beefy linux machines I would use
21:49:40 <mightybyte_> Yeah, 32-bit works fine for me.
21:50:09 <startling> yep, me too
21:50:26 <startling> and yeah, 32-bit seems to not crash
21:51:45 <mightybyte_> mzero: Thanks.  I just wanted to make sure the powers that be were aware...
21:56:37 <zzing> What was the alternative name for 'return'?
21:57:13 <mightybyte_> pure?
21:58:08 <zzing> I think that was it
21:58:57 <startling> where do you need to import pure from?
21:59:58 <solarus> Control.Applicative
22:00:00 <Lemon> I wrote 'type family Derp a :: Constraint", and I have -XTypeFamilies and -XConstraintKinds turned on,
22:00:09 <zzing> I have to go over monads again and was trying to remember that name, I remember somebody said that 'return' wasn't a good name
22:00:24 <Lemon> but it's giving me an error: Not in scope: type constructor or class `Constraint'
22:00:26 <Lemon> what gives?
22:00:29 <Lemon> I am running 7.4.1
22:00:40 <Lemon> on windows x86
22:05:29 <edwardk> unifyType :: Type (Meta Kind) (Meta (Type (Meta Kind)) -> Type (Meta Kind) (Meta (Type (Meta Kind))) -> IO (Type (Meta Kind) (Meta Type (Meta Kind))) -- clearly
22:06:48 <Lemon> good lord what
22:07:01 <Lemon> zzing, 'inject'
22:07:16 <edwardk> its a love story. i call it 'when type meta kind'
22:07:25 <zzing> Lemon, ok, actually that does sound better :-)
22:07:28 <Ralith> haha
22:07:38 <Lemon> or, like in Clojure, 'bind'
22:08:00 <Lemon> I like 'bind'
22:08:04 <yitz> Lemon: oh no that won't work in haskell
22:08:11 <yitz> Lemon: bind is >>=
22:08:17 <Lemon> well damn
22:08:23 <zzing> :t (>>=)
22:08:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:08:32 <zzing> :t return
22:08:33 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:08:37 <startling> what kinds of things are there for html templating in haskell? hamlet seems to need to be compiled in, which I don't want
22:08:44 * hackagebot biophd 0.0 - Library for reading phd sequence files  http://hackage.haskell.org/package/biophd-0.0 (DanFornika)
22:08:44 <zzing> :t (>>= return)
22:08:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
22:09:01 <Lemon> okay so I have this weird problem w.r.t. type families
22:09:06 <edwardk> hstringtemplate and beyond that the #yesod and #snapframework guys will have lots of answers
22:09:24 <Lemon> I have a typeclass called "Down"
22:09:31 <Lemon> and a type family called "Up"
22:09:52 <mightybyte_> startling: heist
22:10:00 <yitz> edwardk: don't the happstack guys also have some kind of templating solution?
22:10:05 <mightybyte_> (which I wrote)
22:10:06 <edwardk> i'm sure they do
22:10:18 <edwardk> but my eyes bleed when i read happstack source
22:10:22 <Lemon> and it turns out that my functions require (Down f, Down (Up f), Down (Up (Up f)), ...)
22:10:23 <edwardk> so i try not to do it very often
22:10:26 <Lemon> in a chain
22:10:29 <mightybyte_> yitz: It's also compiled
22:10:33 <yitz> ah
22:10:48 <mightybyte_> hsp/hsx
22:10:55 <yitz> right
22:11:21 <Lemon> I was able to avoid the infinite chain by writing 'instance Down Identity' and 'type instance Up Identity = Identity'
22:11:41 <startling> mightybyte_: heist looks very cool
22:11:45 <Lemon> but right now I using the constraint (Down f, Up f ~ Identity)
22:11:55 <JoeyA> Oh my, I think aeson 0.6.0.1 violated the version numbering policy by changing the type of Object from lazy HashMap to strict HashMap.
22:12:05 <Lemon> I don't want to manually adjust my type annotations if I want to add another level
22:12:09 <mightybyte_> startling: Thanks.  It has turned out to be pretty slick IMO.
22:12:18 <startling> mightybyte_: thank you for not using $
22:12:30 <Lemon> so is there a way to "automagically" have the constraint check that the chain ends with Identity?
22:13:07 <mightybyte_> And hey, edwardk even contributed to it. :)
22:13:12 <edwardk> hah true enough
22:13:17 <edwardk> once a year like clockwork ;)
22:13:21 <mightybyte_> lol
22:13:37 <JoeyA> Err, maybe Haddock fudged the link.
22:13:42 <Lemon> come on guys, where else can I go for help?
22:14:17 <JoeyA> Yeah, this link isn't right... http://hackage.haskell.org/packages/archive/aeson/0.6.0.0/doc/html/Data-Aeson.html#t:Object
22:14:28 <mightybyte_> edwardk: If the stuff I'm working on now is mature enough, I'm sure there will be more opportunities for you to contribute this year too. :)
22:14:36 <edwardk> nifty keen
22:14:42 <edwardk> i need to actually book the flight down
22:15:08 <startling> mightybyte_, what's a good way for me to learn heist? got a nice short example?
22:15:27 <mzero> Lemon - you might get more help if you put together a small example of the code in question in an hpaste
22:15:46 <mightybyte_> startling: http://snapframework.com/docs/tutorials/heist
22:15:47 <mzero> cause frankly, I can't follow it from the text here
22:16:08 <startling> mightybyte_, wellll, have you got a short example that doesn't use snap?
22:16:25 <Lemon> mzero, okay hold
22:16:42 <startling> i'm generating static html
22:17:08 <mightybyte_> startling: The vast majority of that tutorial has nothing to do with snap
22:17:52 <startling> mightybyte_, one of the two haskell snippets seems to
22:18:09 <mzero> Lemon: mind you - I know little about such convoluted uses of TypeFamilies
22:18:29 <mightybyte_> startling: True, hence "vast majority"
22:18:51 <startling> mightybyte_: ;)
22:20:16 <mightybyte_> startling: Are you just doing static templating?
22:20:47 <startling> yeah
22:53:49 * hackagebot hmatrix-repa 0.1.2.1 - Adaptors for interoperability between hmatrix and repa  http://hackage.haskell.org/package/hmatrix-repa-0.1.2.1 (VivianMcPhail)
22:57:15 * mightybyte_ wishes for an hmatrix-vector package
22:59:43 <mightybyte_> Hmmmm, on second look maybe repa *is* what I was wishing for.
22:59:45 <joeyh> @hoogle UTCTIme -> EpochTime
22:59:46 <lambdabot> Did you mean: UTCTime -> EpochTime
22:59:46 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:59:46 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
23:00:16 <mightybyte_> I had thought that repa was something of a competitor to vector.
23:00:17 <joeyh> blah. I think it takes several conversions, and I don't remember where they are
23:01:56 <Lemon> @hoogle join
23:01:56 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
23:01:56 <lambdabot> package join
23:01:56 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
23:02:07 <Lemon> well dang
23:03:50 * hackagebot hmatrix-gsl-stats 0.1.3.1 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.3.1 (VivianMcPhail)
23:03:52 * hackagebot hstatistics 0.2.4.1 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.4.1 (VivianMcPhail)
23:03:54 * hackagebot hsignal 0.2.4.1 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.2.4.1 (VivianMcPhail)
23:03:56 * hackagebot plot 0.1.3.5 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.3.5 (VivianMcPhail)
23:04:43 <startling> someone's busy
23:04:52 <Gx4> goood morning :)
23:06:35 <mzero> evening, Gx4
23:08:50 * hackagebot plot-gtk 0.1.0.10 - GTK plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk-0.1.0.10 (VivianMcPhail)
23:12:37 <Gx4> mzero 9 morning here :P
23:17:26 <mzero> 11pm here
23:38:52 * hackagebot egison 1.2.1 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.2.1 (SatoshiEgi)
23:39:53 <ClaudiusMaximus> this morning's lesson is: set a heap size limit for GHC when doing insane type family hackery...  http://claudiusmaximus.goto10.org/g/tech/oops.gif
23:41:19 <shachaf> ClaudiusMaximus: Shouldn't the OOM killer take care of that eventually?
23:42:32 <ClaudiusMaximus> shachaf: surprisingly, it didn't - ghc did eventually die from lack of memory
23:42:54 <shachaf> (Were you running GHC as root or something?)
23:43:09 <ClaudiusMaximus> shachaf: nope - my terminal says ^C^C^C^C^C^C^\ghc: out of memory (requested 1048576 bytes)
23:43:33 <shachaf> There's probably a SysRq to do it.
23:44:48 <ClaudiusMaximus> i think i might set up limits.conf to 7GB per process hard limit, just in case of future accidents like that
23:45:08 <shachaf> Do you have swap?
23:45:15 <ClaudiusMaximus> none
23:46:38 <shachaf> Consider yourself lucky in that respect, I guess. :-)
23:49:03 <ClaudiusMaximus> (though, even without swap, there is some thrashing as executables are flushed from ram and tried to be reloaded from disk, as far as i can tell from that little adventure)
23:49:41 <ClaudiusMaximus> based on the evidence of "my hdd led was on", rather than science
23:50:55 <ClaudiusMaximus> it would be much more useful if that ghc out of memory fail also reported the number of bytes it already had successfully requested previously
23:58:31 <JoeyA> Is it possible to indicate, in an instance constraint, that two types are distinct?
