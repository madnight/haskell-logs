00:05:33 <roconnor_> edwardk: here
00:11:11 <zalzane|alt> evade bans err day
00:11:41 <zalzane> oops wrong channel
00:21:02 * hackagebot Elm 0.3.0 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.3.0 (EvanCzaplicki)
00:26:03 * hackagebot elm-server 0.3.0 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.3.0 (EvanCzaplicki)
00:30:47 <srhb> readFile is said to be strict, so should I not be able to do readFile foo >>= writeFile foo . something...?
00:31:42 <shachaf> Who said readFile is strict?
00:32:04 <srhb> ... The file is read strictly ... -- Does this not mean what I think it does?
00:34:12 <srhb> shachaf: What does it mean then, if not that it's strict?
00:34:34 <shachaf> srhb: I would suggest you're not using the readFile you're reading about.
00:34:51 <srhb> You're probably right. :-)
00:39:38 <srhb> I'm curious. Why can't I just make it strict by doing... readFile foo >>= writeFile foo . (\s -> length s `seq` s) ?
00:40:32 <shachaf> That depends on what you mean by "make it strict".
00:40:46 <srhb> I mean read the file entirely before ever writing to it.
00:41:26 <shachaf> Oh, well, I guess writeFile doesn't force its argument until after it opens the file.
00:41:29 <shachaf> Maybe try readFile foo >>= (\s -> evaluate (length s) >> writeFile foo s) or something.
00:41:53 <shachaf> Or use ByteString.
00:43:44 <srhb> shachaf: That does work.
00:45:52 <srhb> So what I'm not getting is when the IO action is run, and how seq meddles with that (or in this case does not)?
00:47:13 <shachaf> readFile is run when you do <- readFile.
00:47:27 <shachaf> But the I/O will only happen as you force the string.
00:47:34 <shachaf> That's the evil of lazy I/O.
00:47:48 <srhb> Yeah. But why doesn't length s `seq` s suffice to force the string?
00:48:29 <shachaf> It does, but see what I said above.
00:48:55 <srhb> Ooooh
00:48:57 <srhb> I think I get it
00:49:18 <srhb> so.. this would work too
00:49:39 <srhb> readFile foo >>= \s -> writeFile foo $! length s `seq` s
00:49:55 <shachaf> I assume so.
00:50:00 <shachaf> Or length s `seq` writeFile foo s
00:50:03 <shachaf> Or who knows.
00:50:15 <srhb> This is tricky to reason about. But thanks a lot. :)
00:50:40 <hpaste> ClaudiusMaximus annotated “haskell irc fractal” with “haskell irc fractal (excerpt) (monads transformed)” at http://hpaste.org/70203#a70248
00:51:40 <ClaudiusMaximus> anyone feel like code review on my new improved implementation of part of my horrible original?
00:52:17 <edwardk> shachaf: any futher golfing progress?
00:53:08 <edwardk> > (!!1)<$>transpose[show$sum[(8-i.&.3*4)*div(1000^2^n)(a^i*i)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]
00:53:10 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
00:53:10 <shachaf> edwardk: Nope, haven't looked at it since.
00:53:14 <shachaf> @where pi_10
00:53:15 <lambdabot> (!!1)<$>transpose[show$sum[(8-i.&.3*4)*div(1000^2^n)(a^i*i)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]
00:53:19 <shachaf> @where pi_11
00:53:20 <lambdabot> [show(sum[(8-i.&.3*4)*div(1000^2^n)(a^i*i)|i<-[1,3..9*2^n],a<-[2,3]])!!n|n<-[0..]]
00:53:30 <shachaf> I think I'd grudgingly admit that pi_11 is OK.
00:53:33 <edwardk> > [show$sum[(8-i.&.3*4)*div(1000^2^n)(a^i*i)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]!!9
00:53:34 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
00:53:59 <edwardk> yeah, i still think its funny. horrible, but funny
00:54:22 <shachaf> The problem with it is that you can't check for correctness easily.
00:54:33 <shachaf> You have to, like, think and stuff, y'know? :-(
00:54:52 <edwardk> well, its correct if pi_10 is correct =P
00:55:16 <shachaf> pi_9, on the other hand, is most definitely not correct.
00:55:31 <shachaf> Which goes to show how much you can trust this method.
00:55:42 <edwardk> it is... up to the width of the result lambdabot shows ;)
00:56:05 <shachaf> > length "[show$sum[(8-i.&.3*4)*div(1000^2^n)(a^i*i)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]!!9"
00:56:06 <lambdabot>   81
00:56:20 <edwardk> saves one char over pi_11
00:56:21 <shachaf> > length "\"31415926535897932384626433832795028841971693993751058209749445923078164062a\""
00:56:22 <lambdabot>   77
00:56:28 <edwardk> hahahaha
00:56:50 <edwardk> > "\"31415926535897932384626433832795028841971693993751058209749445923078164062a\""
00:56:51 <lambdabot>   "\"314159265358979323846264338327950288419716939937510582097494459230781640...
00:56:59 <edwardk> > "31415926535897932384626433832795028841971693993751058209749445923078164062a"
00:57:01 <lambdabot>   can't find file: L.hs
00:57:05 <edwardk> > "31415926535897932384626433832795028841971693993751058209749445923078164062a"
00:57:06 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062a"
00:57:09 <shachaf> "Oh.
00:57:19 <shachaf> I guess the ...age is smarter than I thought.
00:57:23 <edwardk> > "31415926535897932384626433832795028841971693993751058209749445923078164062a..."
00:57:24 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
00:57:31 <shachaf> You can take the a off in that case.
00:57:52 <shachaf> > "31415926535897932384626433832795028841971693993751058209749445923078164062..."
00:57:54 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
00:58:02 <shachaf> > length "\"31415926535897932384626433832795028841971693993751058209749445923078164062...\""
00:58:03 <lambdabot>   can't find file: L.hs
00:58:25 <edwardk> > [show(sum[(8-i.&.3*4)*div(1000^2^n)(a^i*i)|i<-[1,3..9*2^n],a<-[2,3]])!!n|n<-[0..]]
00:58:28 <lambdabot>   mueval-core: Time limit exceeded
00:58:39 <edwardk> i'm wanting to reject pi_11 because lambdabot won't print with it
00:59:15 <shachaf> Probably no computer in existence will print 74 characters of it.
00:59:34 <shachaf> Clearly the only solution is to come up with a solution both shorter *and* more efficient.
00:59:34 <edwardk> true
01:01:29 <tgeeky_> and I'm the crazy one. You people are sick! Sick I say!
01:02:16 <edwardk> too bad there isn't a standard shorter name for transpose anywhere ;)
01:02:39 <tgeeky_> edwardk: I was thinking the same thing
01:02:43 <edwardk> (!!1)<$>transpose is pretty long
01:02:47 <tgeeky_> it stucks out like a sore thumb
01:02:55 <edwardk> thats probably the best candidate to shorten
01:03:04 <edwardk> everything else is golfed to hell
01:03:15 <shachaf> I wonder if you can do something about (8-i.&.3*4)
01:03:29 <shachaf> It's better than the division thing that was there before, but not by much.
01:03:30 <edwardk> yeah that bitwise and is long too
01:04:10 <edwardk> > [(8-i.&.3*4)|0,1,2,3]
01:04:11 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
01:04:12 <lambdabot>    arising from the literal `0'...
01:04:22 <edwardk> > [(8-i.&.3*4)|i <- [0,1,2,3]
01:04:24 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:04:26 <edwardk> > [(8-i.&.3*4)|i <- [0,1,2,3]]
01:04:27 <lambdabot>   Ambiguous type variable `t' in the constraint:
01:04:27 <lambdabot>    `Data.Bits.Bits t'
01:04:27 <lambdabot>      a...
01:04:41 * shachaf wonders whether this should move back to #-blah.
01:04:47 <edwardk> > [8-i.&.3*4| i <- [0..3]] :: [Int]
01:04:48 <lambdabot>   [8,4,0,-4]
01:05:03 <shachaf> The arguments are always odd natural numbers.
01:05:11 <edwardk> nobody else is chatting in here, *shrug*
01:05:21 <shachaf> True.
01:06:09 <srhb> Am enjoying watching, actually :P
01:06:28 <shachaf> It's times like this that you wish Haskell conflated Bool and Int like C. :-(
01:06:51 <MostAwesomeDude> Hmm.
01:07:00 <ClaudiusMaximus> and ""+ is 1char shorter than show :)
01:07:06 <MostAwesomeDude> Well, there are simpler generators, but they dno't express things as decimal digits.
01:07:18 <shachaf> MostAwesomeDude: That's the _10
01:07:39 * tgeeky_ wonders if you could do this more compactly using infinite products and streams: http://en.wikipedia.org/wiki/Infinite_product
01:07:50 <tgeeky_> like the Viete or Wallis products
01:07:54 <MostAwesomeDude> shachaf: Is that using continued fractions?
01:08:06 <MostAwesomeDude> Doesn't look like it, but perhaps I'm not actually grokking.
01:08:19 <edwardk> > (!!1)<$>transpose[show$sum[4*(-1)^div i 2*div(1000^2^n)(a^i*i)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]] is it with the other formulation right?
01:08:20 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:09:06 <edwardk> > (!!1)<$>transpose[show$sum[4*(-1)^div i 2*div(1000^2^n)(a^i*i)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]
01:09:08 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
01:09:08 <tgeeky_> there should be a diablo-like hardcore mode where you can only do golfing if you type it by hand every time instead of @where or paste
01:12:22 <edwardk> > length "cycle[4,-4]"
01:12:23 <lambdabot>   11
01:12:56 <edwardk> too expensive
01:16:54 <shachaf> > (!!1)<$>transpose[show$sum[(8-i.&.3*4)*(div(1000^2^n)(2^i*i)+div(1000^2^n)(3^i*i))|i<-[1,3..9*2^n]]|n<-[0..]]
01:16:56 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
01:17:01 <shachaf> Maybe you could do something with that?
01:17:17 <edwardk> unexpanding the a?
01:17:29 <shachaf> I don't think you can simplify it to get the same denominator with integer division, though. :-(
01:17:31 <edwardk> that was where we were a whole lot of characters ago
01:17:51 <shachaf> I ought to keep a history file.
01:18:04 <shachaf> Alternatively, you ought to put it somewhere where other people can see updates. :-)
01:19:17 <shachaf> (!!1)<$>transpose[show$sum[(8-i.&.3*4)*1000^2^n*div(2^(-i)+3^(-i))i|i<-[1,3..9*2^n]]|n<-[0..]] is one shorter, if you could only do that.
01:19:24 <edwardk> > (!!1)<$>transpose[show$sum[(8-i.&.3*4)*m(2^i*i)+m(3^i*i))|i<-[1,3..9*2^n]]|n<-[0..],let m=div(1000^2^n)]
01:19:25 <lambdabot>   <no location info>: parse error on input `)'
01:21:06 <ktosiek> Hi! Is there any way to create a type for 2 lists of same length?
01:21:07 <t7> haskell makes you a worse programmer in dynamic typed languages!
01:21:15 <t7> or possibly just enlightens you to how bad you were
01:21:28 <shachaf> ktosiek: [(a,b)] is such a type, sort of. :-)
01:21:36 <shachaf> It represents your constraint nicely, anyway.
01:21:48 <ktosiek> oh, yes
01:22:20 <edwardk> ktosiek: i tend to abuse the list of pairs and similar structures for that a lot in 'ad'
01:22:40 <t7> active directory ?
01:22:48 <edwardk> automatic differentiation
01:23:51 <ktosiek> I worded it wrongly, I'm modeling a neural network and I want to have a type that constraints lenghts of lists of weights
01:24:27 <t7> isnt there a Vector type with the new type families thing?
01:24:46 <ktosiek> so for every neuron in layer, it needs the number of weights equal to the number of neuron in previous layer
01:25:08 <ktosiek> I was looking at Vec, but I don't know the size of network at compile-time
01:25:46 <edwardk> > (!!1)<$>transpose[show$sum[1000^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]  is the same length byt moves the div around
01:25:47 <lambdabot>   Not in scope: `is'Not in scope: `the'Not in scope: `same'Not in scope: `byt...
01:26:25 <t7> lambdabot: needs a space after the identifier. Cale
01:26:57 <shachaf> Yes, I had that version once.
01:27:05 <shachaf> I couldn't figure out any savings through that kind of shuffling.
01:27:17 <edwardk> i've gone past it a few times myself
01:27:24 <edwardk> just frustrating ekeing out that last char
01:27:35 <edwardk> > length "(!!1)<$>transpose[show$sum[1000^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]"
01:27:36 <lambdabot>   95
01:27:47 <shachaf> @@ @run length @show @where pi_11
01:27:48 <lambdabot>   82
01:28:18 <edwardk> clearly the kolmogorov complexity of pi is at most 82
01:28:35 <nalssi> Using HDBC, I inserted rows into a table, and the next time I tried deleting the table in the same db, I got the  error message saying "step: database table is locked". I can't figure out the reason. Can anyone help ?
01:29:23 <edwardk> was hoping to use on(+)f or something to combine the two (a^i*i)'s but nope
01:29:31 <james-ubc> arr!!! is there anything a little more powerful than gloss but also less confusing than FunGEn available?
01:29:45 <james-ubc> like a 2d game engine
01:34:26 <shachaf> > transpose ["123"++cycle"A","456"++cycle"B","789"++cycle"C","qwe"++cycle"D"]
01:34:28 <lambdabot>   ["147q","258w","369e","ABCD","ABCD","ABCD","ABCD","ABCD","ABCD","ABCD","ABC...
01:34:34 <shachaf> I'm suddenly confused about why transpose works at all.
01:35:07 <zenzike> nalssi: did you commit your insertion?
01:35:24 <james-ubc> fungen appears to have zero documentation whatsoever apart from what's availble on hackage (which is to say next to nothing)
01:35:25 <nalssi> zenzike: Yes i did
01:35:50 <shachaf> Oh, it's because the lists are finite.
01:36:23 <zenzike> nalssi: and you're trying to delete the table via HDBC?
01:36:49 <nalssi> zenzike: Yes
01:37:09 <zenzike> nalssi: are you able to delete the table outside of HDBC?
01:37:42 <nalssi> zenzike: Using OS command? Yes I could
01:37:59 <hpaste> nalssi pasted “hdbc” at http://hpaste.org/70249
01:39:22 <zenzike> nalssi: what happens if you put an extra |commit conn| above line 9?
01:39:33 <zenzike> nalssi: I mean below line 9
01:40:01 <nalssi> zenzike: I think i've tried it, but I'll do that again.
01:40:55 <theadmin> Connection -> String -> String -> [String] -> ([Row] -> [SqlValue]) -> [String] -> IO () -- holy hell.
01:41:04 <zenzike> nalssi: (I don't think it's actually a good idea, but I'm just curious here)
01:41:05 <nalssi> zenzike: It's the same
01:41:40 <Tehnix> anyone have any good recommendations on starting out in Haskell (coming from OOP)?
01:42:03 <nalssi> zenzike: The code works as i expected except that it locks the table.
01:42:28 <theadmin> Tehnix: Haskell tutorial for C Programmers is a great one for anyone coming from the imperative world, in my opinion. Also, Learn You A Haskell for Great Good and Real World Haskell.
01:43:14 <zenzike> nalssi: so the table is successfully deleted, but also marked as locked?
01:43:33 <theadmin> Tehnix: You can find all those I mentioned and more @ http://www.haskell.org/haskellwiki/Tutorials
01:43:42 <nalssi> zenzike: Oh, no the table is not deleted.
01:43:57 <Tehnix> theadmin: ah, thanks :)
01:44:08 <james-ubc> Tehnix: real world haskell is better imo but learn you a haskell is the quickest -- you can blow through lyah in about a week pretty easily
01:44:36 <theadmin> Tehnix: But start off with installing the Haskell Platform for your OS (or at least GHC)
01:44:52 <hpaste> nalssi pasted “hdbc” at http://hpaste.org/70250
01:44:52 <nalssi> zenzike: By the way, this one works fine. I don't see any difference between them
01:45:04 <Tehnix> already done that, and played a bit with some very basic stuff :)
01:46:04 <Tehnix> but, thanks for the recommendations all!
01:46:21 <Tehnix> imma go back to lurking again
01:46:35 <shachaf> Tehnix: _Programming in Haskell_ by Hutton is quite good.
01:47:28 <zenzike> nalssi: might it be that groupAction is called within another statement that hasn't committed?
01:48:10 <Tehnix> shachaf: will check it out
01:48:47 <theadmin> RWH is a good one, but what I don't like is that it doesn't seem to mention list comprehensions at all somehow
01:49:08 <dalaing> Introduction to Function Programming by Bird and Walder is a pretty good introductory text with a lot of exercises
01:49:26 <srhb> theadmin: http://book.realworldhaskell.org/read/monads.html <-- search for list comprehension
01:49:55 <theadmin> srhb: Chapter 14... Nice place to put such a basic concept :P
01:49:56 <nalssi> zenzike: Thank you your help but can you check the code that makes an error?
01:49:57 <hpaste> nalssi pasted “hdbc” at http://hpaste.org/70251
01:50:19 <dalaing> I found RWH a bit hard to get through when I was starting out - some of the information was ordered strangely for a newcomer, made a lot more sense after I'd been some other books and "Write yourself a scheme in 48 hours"
01:51:11 <srhb> theadmin: It is a bit late.. I don't find myself using them very often, but I guess it really depends what kind of programming you're doing.
01:51:39 <nalssi> zenzike: foo works fine the first time, but the next time it fails with the message "database table is locked"
01:51:39 <geekosaur> I wouldn't really consider RWH for beginners, rather it's the next step after something like LYAH
01:51:41 <zenzike> nalssi: what's the underlying database type?
01:51:44 <theadmin> srhb: Well, I was using them before I found "filter" and "map"... lol
01:51:50 <nalssi> zenzike: sqlite3
01:51:55 <srhb> theadmin: Yeah :)
01:52:23 <nalssi> zenzike: If it's better to use another one, then I'll try.
01:53:01 <zenzike> nalssi: no, it's not a problem. I just wondering if there's something strange going on with the db itself
01:54:01 <zenzike> nalssi: so what happens if you run foo once and then try executing the commands that foo would do manually?
01:54:36 <zenzike> nalssi: (and presumably when you say you do foo twice, you mean you have something like main = foo >> foo ?)
01:54:42 <nalssi> zenzike: I'll try to delete a table manually
01:55:06 <nalssi> zenzike: No, I run it in the repl, and run it again
01:56:38 <nalssi> zenzike: Oh, I manually drop the table made by groupAction, and it works fine
01:56:58 <shachaf> edwardk: Maybe if there was a really short way of writing (\x y -> x ++ drop (length x) y) you could fold with that...
01:57:06 <shachaf> Seems unachievable, though.
01:57:11 <zenzike> nalssi: can you verify that the table really is being dropped by foo?
01:57:20 <shachaf> (Especially since you'd need to map init or something like that.
01:57:22 <shachaf> )
01:57:41 <edwardk> well, we used to use take n.drop n instead
01:57:52 <nalssi> zenzike: getTable says it's dropped.
01:57:56 <shachaf> Yes.
01:57:58 <nalssi> getTables
01:58:02 <edwardk> but we had to cons '3' on front
01:58:14 <zenzike> nalssi: and what does the database think?
01:58:26 <zenzike> nalssi: (outside of HDBC)
01:59:11 <nalssi> zenzike: I guess maybe what you are guessing is right. when I run groupAction again, it gives me the same error message
01:59:45 <nalssi> zenzike: I have to delete the db file from OS to make it work again
02:01:26 <zenzike> nalssi: it sounds like HDBC isn't actually dropping the table. I suggest you try a minimal example that should drop a table, and verify if it's gone using the sqlite prompt.
02:02:45 <nalssi> zenzike: Yes, I'll try but since I'm new to Haskell and I'm not even a programmer, so it'll take some time to figure out how to access the DB with sqlite prompt
02:03:22 <zenzike> nalssi: oh I see. I think there's a tool called sqlite3 that you can run on your sqlite database
02:03:54 <nalssi> zenzike: Thank you very much for everything
02:04:14 <zenzike> nalssi: so you do something like sqlite3 foo.db and then just try a few select statements
02:04:32 <zenzike> zenzike: np. I'm afraid that apart from that, I'm out of ideas
02:07:20 <nalssi> zenzike: Yes you are right. "drop table" doesn't work from HDBC
02:11:05 * hackagebot xlsx 0.0.1 - Simple and incomplete Excel file parser/writer  http://hackage.haskell.org/package/xlsx-0.0.1 (KirillZaborsky)
02:11:10 <zenzike> nalssi: I don't see why not. My best guess is that it's because sqlite it generating an error when you try to drop a table that's not there
02:12:16 <nalssi> zenzike: Hmm.. In that case REPL shows me a diffent message.
02:13:17 <nalssi> zenzike: Isn't it because the table is accessed from another process so I can't access from another one ?
02:13:22 <ktosiek> I'm getting "File name does not match module name:  Saw: `Main' Expected: `Network'" when loading a module importing that "Network" module
02:13:28 <ktosiek> any ideas why?
02:13:48 <ktosiek> Network starts with module Network
02:13:52 <_Vi> What is difference between HLint's warnings and errors?
02:14:06 <nalssi> zenzike: I mean it's not closed properly.
02:14:07 <shachaf> _Vi: Not much.
02:15:32 <zenzike> nalssi: yes it does seem like it's not closed properly. what happens if you run foo once in ghci, quit ghci, and run it again?
02:16:17 <nalssi> zenzike: Maybe I was wrong. The same error message.
02:16:25 <nalssi> zenzike: I guess you were right
02:17:07 <nalssi> zenzike: If I figure out how to properly delete the table, the the problem will be solved
02:17:50 <zenzike> nalssi: indeed. I'd try removing the "if exists" part, and making that conditional. (it's not ideal, but that'll help narrow the problem down)
02:18:33 <nalssi> zenzike: Good Idea, thank you I'll try it
02:19:34 <zenzike> nalssi: (I've never had problems with drop table before, but then again, I don't think I've ever used the "if exists" part either)
02:19:40 <nalssi> zenzike: By the way, what's really strange is csv2Table function works smoothly.
02:19:43 <_Vi> "Warning: Redundant bracket"  "Error: Redundant bracket" - the same HLint's suggestion can be both warning and error...
02:20:15 <fmap> _Vi: errors are meant things you always want to change
02:20:24 <fmap> meant to be*
02:21:39 <bitonic> fmap, _Vi: errors are things that make your program invalid
02:21:59 <_Vi> bitonic, HLint's error makes program invalid?
02:22:54 <shachaf> _Vi: No, it's pretty much arbitrary.
02:23:05 <fmap> bitonic: i don't think `concat . map' makes program more invalid than `concatMap'
02:23:21 <shachaf> http://i.imgur.com/0t8hu.jpg
02:25:04 <zenzike> nalssi: I agree. I still don't see what the real problem is.
02:26:00 <nalssi> zenzike: I fixed the code using "when" but it's the same. Thank you anyway. You helped me a lot. The problem is narrowed.
02:27:33 <zenzike> nalssi: how about moving the drop table from groupAction to before the select statement?
02:28:51 <nalssi> zenzike: You are amazing, It works fine!!!
02:29:09 * zenzike still has no idea why that would work
02:30:52 <theadmin> zenzike: magic?
02:32:13 <zenzike> nalssi: what does stmtC do?
02:32:49 <nalssi> zenzike: it generates a string like "create table t1  ...."
02:33:09 <zenzike> nalssi: something you defined, or in the library (I can't seem to locate it)
02:33:21 <nalssi> zenzike: I defined it.
02:34:06 <nalssi> zenzike: So it's simply a String
02:38:56 <t7> why is it Control.Monad but Data.Functor ?
02:39:12 <t7> (not Control.Functor)
02:39:34 <shachaf> "it just is, ok?"
02:40:35 <pooya72> hello everybody!
02:40:48 <pooya72> so haskell is finally starting to click!
02:40:53 <pooya72> yeaaahhh!!
02:41:21 <fmap> Data.Functor is kinda strange since it defines only 2 operators both re-exported from Control.Applicative
02:41:35 <t7> im really glad this deferred type error stuff is coming. Type safety is so overrated, it just slows me down
02:42:12 <t7> how can i write webscale code when i keep getting type errors :|
02:43:19 <theadmin> t7: Write type signatures yourself, don't let the compiler determine stuff for you. It'll be easier this way. (Also remember that main :: IO (), that confused me at first)
02:44:55 <fmap> actually main can be ∷ IO a
02:45:36 <t7> Today i learnt (learned?)
02:46:15 <Botje> pooya72: cool!
02:46:55 <srhb> t7: learnt :)
02:47:13 <pooya72> Botje: no really man, haskell has a real learning curve. Especially coming from a dynamic language.
02:47:37 <srhb> pooya72: No kidding. :)
02:47:46 <Botje> pooya72: learning curve means you're learning
02:48:00 <Botje> learning is good :)
02:48:01 <theadmin> pooya72: It does. Read the "Haskell Tutorial for C Programmers", it helps you set your mind on the functional track (at least did for me, and made Haskell a lot more fun)
02:48:02 <Botje> << food
02:48:39 <theadmin> Well, it made it more fun only because I started to understand wtf is going on, but
02:50:07 <LambdaDusk> reactive-banana: british edition. So I won't get any more type errors for "Behaviour"
02:50:09 <pooya72> theadmin: but that means I would have to learn C first :)
02:50:26 <theadmin> pooya72: Not really (I don't know C, only the very basics of it)
02:50:38 <pooya72> theadmin: ok I'll check it out.
02:51:29 <pooya72> Botje: I'm not a professional programmer, and a lot of times I seriously wanted to quit haskell. So I'm glad it finally started to click!
02:52:30 <srhb> pooya72: It made me real happy once I was able to make sweeping changes to my program without making type errors, even though those very errors are one of the great reasons Haskell is cool. :-)
02:55:27 <pooya72> srhb: yeah, it's a pain initially but it's beneficial down the line.
02:57:35 <t7> is there an infix op Set.union in the haskell platform?
02:57:43 <pooya72> srhb: and there's something eerie about compiling and knowing that everything just works...
02:58:00 <srhb> t7: `Set.union` ? :-)
02:58:03 <theadmin> t7: You can write prefix functions infix you know
02:58:12 <srhb> pooya72: Yes, it's a magical feeling. :P
02:58:17 <t7> yeah but my lines are too long
02:58:27 <t7> return (a1 `Set.union` a2, c1 `Set.union` c2 `Set.union` ....
02:58:33 <srhb> u = Set.Union ?
02:58:37 <nalssi> :)
02:58:52 <t7> needs more agda
02:59:11 <theadmin> t7: Define something like this: (+++) = Set.Union, and use a1 +++ a2 +++ ...
02:59:12 <srhb> ∪
02:59:36 <srhb> Unicode operators are the best.
02:59:49 <t7> im trying to make a tutorial for newbs, so i dunno whether to define my own operators
03:00:04 <theadmin> t7: You're just defining a function...
03:00:10 <srhb> t7: Maybe you should just import it unqualified?
03:00:28 <theadmin> Hm. Are there any "operators" in Haskell as such? Everything I find so far just seems to be an infix function
03:00:36 <t7> nah im using Map too, i get conflicts
03:00:43 <scopedTV> theadmin: no, they are just functions.
03:00:49 <theadmin> scopedTV: Sweet.
03:01:02 <srhb> theadmin: Except symbols are automatically infix.
03:01:09 <srhb> theadmin: Only difference.
03:01:11 <t7> im making a blog series 'Adding generics to C'
03:01:20 <t7> also adding type inference
03:01:22 <scopedTV> theadmin: There are some syntactic rules. Functions whose name consists of symbols are infix
03:01:44 <theadmin> scopedTV: I figured that out already, it's an interesting thingo
03:01:47 <scopedTV> theadmin: you can make them prefix by enclosing them in (), for example: + is infix, (+) is prefix.
03:01:57 <theadmin> scopedTV: I know that too
03:02:02 <theadmin> (+) 2 2 looks ugly though
03:02:10 <scopedTV> theadmin: and you can use `` to make other functions infix :)
03:02:25 <theadmin> scopedTV: And that.
03:02:27 <srhb> t7: import Data.Set hiding (map) could be very clear for beginners, too
03:02:30 <scopedTV> theadmin: yeah, nobody does that, it's useful when using (+) as a function partially (or not) applied at all
03:02:35 <tdammers> theadmin: it is useful if you want to pass them into other functions though
03:02:50 <scopedTV> theadmin: e.g. zipWith (+) xs ys
03:02:57 * theadmin wonders if she's the only one who defines (%) because `mod` is annoying
03:03:08 <scopedTV> theadmin: % is often from Data.Ratio.
03:03:12 <tdammers> also, if you partially apply them you have a similar syntax
03:03:18 <tdammers> map (+2) xs
03:03:19 <scopedTV> theadmin: but I fully agree that `mod` is annoying
03:03:48 <scopedTV> theadmin: if I work in a finite field I often just define the Num instance though.
03:13:15 <theadmin> scopedTV: Why Num? Wouldn't Integral apply better? I don't think using mod on non-Integral types will work anyway
03:13:39 <srhb> theadmin: Yes.
03:13:48 <theadmin> srhb: "yes"?
03:13:57 <srhb> theadmin: Yes, Integral would apply better. :)
03:19:24 <t7> @pl Set.map (\(_, t') -> Equal (TVar t') (TVar tv)) $ Set.filter (\(i', t') -> i == i') a
03:19:25 <lambdabot> Set.map (flip Equal (TVar tv) . TVar . snd) (Set.filter ((i ==) . fst) a)
03:19:39 <t7> hmm
03:20:38 <theadmin> What's snd?... What's TVar?... What's... Gah... I still have lots to learn
03:20:57 <srhb> > snd (1,4)
03:20:58 <lambdabot>   4
03:21:02 <srhb> > fst (1,4)
03:21:03 <lambdabot>   1
03:21:04 <theadmin> Oh, that's that... second thing
03:21:07 <t7> i wish i could write { t' `Equal` (TVar tv) | (i, _) `ExistsIn` A}
03:22:08 <t7> is there a language with set-theory-like syntax?
03:22:11 <srhb> theadmin: TVars mutable shared memory thingies used for atomic transactions
03:22:30 <srhb> theadmin: insert an "are" where appropriate :-)
03:22:31 <t7> well they are Type Variables, in this context
03:22:37 <srhb> Oh.
03:22:46 <t7> just a constructor
03:23:02 <srhb> Overloading classical names, eek :P
03:23:16 <t7> yeah i forgot about that
03:23:22 <t7> i allways used MVars
03:25:01 <dmwit> t7: odd, the condition in your set builder doesn't share any variables with the value you're building
03:25:06 <dmwit> Are you sure you spelled that right?
03:25:44 <t7> woops, i want to pattern match on one and bind another
03:26:08 * hackagebot sfml-audio 0.7.0.1816 - minimal bindings to the audio module of sfml  http://hackage.haskell.org/package/sfml-audio-0.7.0.1816 (SoenkeHahn)
03:26:12 <t7> { t' `Equal` (TVar tv) | (i, @t') `ExistsIn` A}   @ = bind this one
03:26:46 <dmwit> You can write [t' `Equal` TVar tv | (i, t') <- a] in Haskell.
03:26:51 <t7> maybe the ' in the formula has that meaning
03:26:57 <dmwit> That's pretty close to math syntax, in my opinion.
03:27:22 <t7> yeah but i needs to equal x
03:27:37 <dmwit> If you want that `Equal` to be a side condition, then you can write
03:27:55 <dmwit> [t' | (i, t'@(TVar tv)) <- a]
03:27:57 <t7> and it needs to work on Data.Set :)
03:28:36 <dmwit> fromList [t' | (i, t'@(TVar tv)) <- toList a]
03:29:00 <dmwit> Any other objections?
03:29:29 <t7> is that slow?
03:29:52 <dmwit> About as fast as you could hope for. n log n, where n is the size of the set
03:30:13 <dmwit> s/the set/a/
03:31:27 <dmwit> If you store your pairs in the other order, you can get a small (non-asymptotic, I think... but check the docs) speedup by using toAscList/fromAscList.
03:33:40 <t7> ah my code is so unreadable :(
03:34:16 <theadmin> t7: Don't be sad about that... You need to look at my old Perl code, THAT's unreadable lots >.<
03:34:57 <srhb> Unreadable Perl? Unpossible. :-)
03:35:02 <t7> @pl \(_, t') -> Equal (TVar t') (TVar tv)
03:35:03 <lambdabot> flip Equal (TVar tv) . TVar . snd
03:36:13 <dmwit> t7: Are you doing unification?
03:36:22 <t7> not yet
03:36:26 <t7> but very soon
03:36:27 <dmwit> If so, are you using one of the unification packages from Hackage?
03:36:38 <t7> could do
03:36:47 <dmwit> ?hackage unification-fd I had a pretty good experience getting up and running quickly with this one.
03:36:47 <lambdabot> http://hackage.haskell.org/package/unification-fd I had a pretty good experience getting up and running quickly with this one.
03:37:10 <dmwit> I think there's (exactly) one other... but I don't remember off the top of my head what it was called.
03:37:27 <dmwit> It was a tiny module tucked away in a library that seemed unrelated.
03:38:49 <dmwit> ?hackage compdata this is the one
03:38:49 <lambdabot> http://hackage.haskell.org/package/compdata this is the one
03:38:54 <t7> dmwit: it does the substitution too?
03:39:41 <t7> compdata returns a subst
03:41:09 <dmwit> t7: I didn't look into compdata much, but unification-fd makes the substitution available and relatively easy to use.
03:41:41 <dmwit> You choose whether you get back a value with variables + a substitution or whether you apply the substitution and just get back a frozen term.
03:42:03 <t7> oh cool
03:42:49 <dmwit> better than a stick in the eye =)
03:46:00 <womb_> Hi!
03:48:36 <srhb> womb_: Hi :)
04:06:19 <t7> this ghci multiline bug is really annoying now
04:07:15 <t7> GRRR
04:07:49 <spill> make -k
04:07:50 <spill> ghc -Wall  Main.o -o MAIN
04:07:50 <spill> Main.o:fake:(.text+0x1cd): undefined reference to `__stginit_wxzm0zi90zi0zi1_GraphicsziUIziWX_'
04:07:50 <spill> collect2: ld returned 1 exit status
04:07:54 <spill> makefile:8: recipe for target `MAIN' failed
04:07:57 <spill> make: *** [MAIN] Error 1
04:07:59 <spill>  
04:08:02 <spill> Compilation exited abnormally with code 2 at Thu Jun 21 13:07:09
04:08:05 <spill>  
04:08:07 <srhb> spill hpaste!
04:08:10 <spill> any ideas?
04:08:14 <spill> oops forgot context
04:10:42 <Botje> spill: you probably meant ghc --make
04:12:26 <hpaste> spill pasted “Haskell wx compile fail” at http://hpaste.org/70252
04:12:28 <hpaste> spill pasted “Haskell wx compile fail” at http://hpaste.org/70253
04:14:14 <Wooga> hi, anyone knows unicode symbol for '=>' in quicksort ∷ (Ord a) => [a] → [a]
04:14:19 <Wooga> ?
04:14:26 <spill> ah i didnt do --make
04:14:34 <spill> it takes forever to link
04:14:42 <spill> will it do that everytime+
04:15:00 <fmap> ⇒
04:15:16 <Wooga> fmap: thanks
04:15:37 <spill> Loading package wxdirect-0.90.0.1 ... linking ... done.
04:15:37 <spill> Loading package wxc-0.90.0.3 ... can't load .so/.DLL for: uuid (addDLL: could not load DLL)
04:15:47 <spill> cant it be done from the interpreter perhaps?
04:16:02 <spill> the .exe is still being compiled
04:16:12 <spill> MAIN.exe that is
04:17:07 <Botje> you don't need to compile your program to check it in ghci
04:17:27 <spill> no im doing 2 things but will everything work in ghci?
04:18:12 <spill> wxc.dll is missing when i run the compiled code
04:18:19 <spill> but i installed everything
04:18:20 <Botje> ghci is a bit slower but should be able to do anything your compiled program can.
04:18:27 <Botje> no idea about windows, sorry.
04:18:34 <Botje> maybe it's looking in the wrong place or something
04:25:09 <scopedTV> Wooga: see the GHC User's Guide, section 7.3.1
04:26:51 <Wooga> scopedTV: thanks
04:27:25 <Wooga> but i am not storing this symbols in very file, i ma just concealing them with vim
04:27:47 <Wooga> yet it is good reference anyway
04:28:19 <scopedTV> Aha. Anyway you could store the values, although your coworkers might hate you afterwards :)
04:28:32 <Wooga> yea %)
04:29:28 <Wooga> also, which monospaced font do you reccomend for such symbols?
04:31:53 <spill> what happened?
04:32:08 <spill> so i shouldnt use makefiles i should use cabal to build haskell programs?
04:32:34 <ksf> is there a standard library to share field labels in between multiple data types or do people just amend fclabels with a bit of class-foo?
04:33:10 <spill> weeee!!!!!!!!!!!!!!!
04:36:56 <fmap> Wooga: beware, vim conceal is just a first step to -XUnicodeSyntax addiction
04:38:27 <scopedTV> spill: you can use makefiles, cabal is a lot friendlier
04:38:30 <scopedTV> and more common
04:38:34 <ssbr_> I asked this earlier, but didn't receive a really satisfactory answer -- is it safe to embed haskell in a C library opaquely? Will that interfere with other C libraries that embed haskell?
04:39:03 <srhb> ssbr_: Sounds like a question for SO
04:39:12 <spill> opaquely?
04:39:22 <ssbr_> spill: without exposing that I'm using haskell in the library
04:39:36 <ssbr_> so that the user doesn't have to know or care, just call my init / deinit functions or whatever
04:42:11 <hpc> ssbr_: you can put the ghc runtime init/finish calls into your init/finish
04:42:17 <hpc> and then it should be more or less transparent
04:42:29 <ssbr_> hpc: But what if the other library does that too?
04:42:30 <hpc> modulo users who forget to call your finish function
04:42:35 <hpc> ah
04:42:38 <hpc> uh
04:42:48 <hpc> no clue :P
04:42:56 <ssbr_> it sounds like it'd wreck everything
04:43:05 <ssbr_> you'd think authors of a haskell implementation would avoid global state. bah
04:43:39 <hpc> to be fair, ghc is ancient
04:43:46 <hpc> and normally the runtime is global
04:45:48 <spill> how can i speed up the compilation of wxhaskell?
04:46:00 <spill> i got miself ay guui, !!!!
04:46:55 <srhb> spill: If you're on Windows, you're just going to have to live with the time to compile, I think. :)
04:47:26 <hpc> if you happen to still be using 7.0.4 on linux, you can use the gold linker
04:47:40 <hpc> which may or may not be faster
04:50:12 <b_> I'm having trouble compiling lambdabot -> "readline ... can't load .so/.DLL for /usr/lib/.../libncurses.so (-lncursesw: cannot open shared object file...
04:53:37 <hpc> apt-get install libreadline6-dev
04:53:41 <hpc> b_: ^
04:54:30 <hpc> you might also need to add FlexibleInstances to a bunch of files; i don't know if that's fixed yet
04:54:48 <b_> I run arch, but will look it up
04:56:02 <ksf> curses /= readline
04:56:23 <ksf> the package should be called ncurses
04:56:43 <b_> have it installed
04:56:44 <ksf> and frankly, you ought to havi it.
04:57:08 <ksf> the three dots between lib and lib look suspicious.
04:57:33 <b_> but the path it gives in the error /usr/lib/unknown_linuxetc/../../lib/ is not correct
04:57:48 <b_> libncurses.so etc are in /usr/lib
04:58:58 <ksf> you could circumvent the whole thing by using haskellline.
04:59:29 <Saizan> ghci had (or still has?) problems with link scripts
05:00:24 <b_> the exact path in my error is /usr/lib/gcc/x86_64-unknown-linux-gnu/4.7.1/../../../../lib/libncurses.so
05:00:25 <ksf> link scripts are stupid, that's why gentoo nukes them with extreme prejudice.
05:00:54 <ksf> well, that points to /usr/lib/libncurses.so
05:01:21 <b_> yeah
05:01:23 <ksf> ...unless, of course, gcc/x86 ... doesn't exist.
05:01:48 <b_> it does
05:03:35 <Saizan> try making /usr/lib/libncurses.so a symlink to the binary, if it's a linker script
05:03:52 <ktosiek> fun, fun, fun
05:04:04 <ktosiek> I'm getting "cabal-ghci: Prelude.head: empty list"
05:04:13 <ktosiek> after adding binary to build-depend
05:04:15 <ksf> linker scripts should be outlawed alongside with xml
05:04:33 <ksf> ktosiek, rejoice!
05:04:42 <ksf> at least it's saying which program!
05:04:51 <ktosiek> :-D
05:05:01 <hpc> ksf: just need to get rid of chroot and suexec and nobody can run apache ever again!
05:05:14 <ktosiek> but seriously, any ideas how to fix it?
05:05:15 <b_> cat /usr/lib/gcc/x86_64-unknown-linux-gnu/4.7.1/../../../../lib/libncurses.so = INPUT(-lncursesw)
05:06:26 <ksf> ktosiek, +RTS -xc gives you a stack trace.
05:07:09 <ktosiek> oh, and there goes my bug
05:07:15 <ktosiek> cabal configure fixed it
05:12:45 <ssbr_> woo, SO
05:13:12 <ssbr_> "hey I was wondering if there's a way around this problem with the FFI" "Yes you can use the FFI. Here are the docs for the FFI. You should use the FFI functions that you mentioned in your question."
05:13:25 <srhb> ssbr_: Patience. :P
05:13:54 <ssbr_> how people can get 2 upvotes for answering a question I didn't ask is beyond me
05:14:20 <ssbr_> they would need 10 downvotes to outweigh those 2 silly upvotes. Won't ever happen. Stack overflow rewards dumb spam responses. :(
05:15:15 <srhb> ssbr_: Well, your question is pretty horribly worded as well.
05:15:32 <ssbr_> then edit it. I don't care.
05:15:40 <srhb> ssbr_: Nor do I. :P
05:15:59 <ssbr_> if I mention "hs_init" and "hs_exit", your answer should not begin with, "Yes, it's possible to call Haskell code from C"
05:16:05 <ssbr_> this means that you can't read
05:16:43 <ssbr_> srhb: I meant I don't care if you edit it, not I don't care about the question :(
05:16:43 <srhb> Or that you don't know much about the FFI but is trying to be helpful. If you had been clearer, it would also be clear to novices that you are not. I don't think your whine is at all reasonable here. :)
05:16:48 <srhb> ssbr_: Ah :P
05:18:26 <ssbr_> "trying to be helpful" and "stack overflow" do not mix. Maybe I'm cynical. If I see a quick, short, relatively information-free answer, I assume it's someone trying to earn reputation, not trying to be helpful
05:18:40 <ssbr_> (the original answer was basically just a link to the FFI docs)
05:19:00 <srhb> ssbr_: Perhaps you're right and I'm naive. Either way, I agree it was not a good answer.
05:19:32 <ssbr_> Oh well. Not a good question. Not a good situation! I need to take a walk
05:20:12 <cwp>  Build-Depends:     base >= 3 && < 5
05:20:12 <cwp>   		     wx-0.90.0.1
05:20:25 <cwp> should i write wx >= 0.90.0.01?
05:21:47 <cwp> fails too
05:24:25 <cwp> got it
05:24:28 <int-e> cwp: you need a comma
05:27:47 <cwp> ExitFailure 1 isnt the most helpful exit info...
05:33:15 <fmap> cwp: if you are talking about cabal-install you can always provide -v[0-3] parameter to get some debug information
05:39:48 <hpaste> “_Vi” pasted “performance question” at http://hpaste.org/70254
05:40:10 <_Vi> Should such cases be optimised by compiler automatically?
05:40:20 <_Vi> *optimized
05:40:41 <cwp> i just write cabal install in mingw
05:41:48 <cwp> why does it take so long for a wx-program to start up?
05:42:11 <ksf> there should be a jargon word for "technology that has no merit and is only alive because idiotic companies hired a gazillion monkeys to make it functional"
05:42:40 <ksf> ...with emphasis on "pushed it to market because it's theirs"
05:43:18 <ksf> hmmm. IBSCC.
05:43:29 <ksf> Invented By Sirius Cybernetics Corporation.
05:43:44 <ksf> or, better, A Service Of Sirius Cybernetics Corporation.
05:43:58 <_Vi> ksf, "Serious Business" or "Enterprise Technology"?
05:44:00 <ksf> ASOSCC is even pronouncable.
05:44:38 <ksf> nono I'm not talking about tame beasts like java, but adominations like xml.
05:46:43 <_Vi> Is XML that bad (especially excluding namespaces/xpath/xslt/DOM)?
05:47:30 <favonia> Hi, is freeHaskellFunPtr allowed in the function itself now? I learned from a post from 6 years ago http://www.haskell.org/pipermail/haskell/2006-July/018273.html that it has been allowed for various platforms. What's the status quo?
05:47:59 <HugoDaniel> is there a tool that can look at my .cabal file and check if there are new versions of the build-depends that have upper bounds ?
05:49:49 <ksf> _Vi, just take schemas.
05:50:03 <ksf> and if you strip it of all that punk, there's always the abysmal syntax.
05:50:12 <int-e> _Vi: There's the big lie that XML is human readable (leading to abominations like XSLT), and it's a horrible representation for generic tree structured data. It does not help that some people use the term "XML" when they mean the latter.
05:50:14 <_Vi> ksf, Is RelaxNG that bad?
05:50:21 <ksf> and the completely and utterly pointless difference between attributes and elements.
05:50:42 <cwp> if it is gonna fial because there is no license file why doesnt it do that immediately instead of linking and then faling?
05:50:57 <ksf> it was a bad design from the beginning, and the later additions didn't make it any better.
05:51:00 <cwp> it seems that what it did because the only thing i changed was adding a lisence file
05:51:21 <ksf> on the contrary, the design flaws built up a huge synergism.
05:51:23 <int-e> _Vi: But it's not all bad--having a common standard is great, and the tool support for XML is impressive. It's just far enough from perfect to wish for something better.
05:51:56 <ksf> yep. and that tools support is the reason it earns the label.
05:52:05 <_Vi> (BTW my favourite XML tool is "xml2" (with 2xml, of course))
05:52:13 <ksf> it's fed by paid code monkeys.
05:52:35 <aristid> my favorite xml tool is xml-conduit :D
05:52:45 <ksf> it doesn't even have a proper binary syntax.
05:52:49 <ksf> and not even a regular one.
05:52:52 <sjoerd_visscher> can anybody try this in GHC HEAD: https://gist.github.com/2965588
05:52:53 <_Vi> XML is much better than myriads of hand-crafted wacky text (or even binary) formats in each case.
05:53:01 <srhb> Doesn't JSON completely replace XML with a non-crazy standard, or am I missing something?
05:53:26 <ksf> does json even have a concept of schemas?
05:53:36 <ksf> protocol buffers may come close, but still, sum types are missing.
05:53:41 <int-e> why exactly did ASN.1 lose?
05:53:54 <ksf> because it's not only not regular, it's ambigious.
05:54:26 <ksf> heck you could use it to make browsers accept false certificates.
05:55:14 <Botje> that reminds of that nice presentation about turing complete protocol processors
05:55:22 <ksf> a wide-spread data exchange language has to be a) fully and troughoutly, easily, schematisized and b) nested word regular, at the maximum.
05:55:38 <ksf> Botje, the CCC talk?
05:55:43 <Botje> yes :)
05:55:54 <Botje> it was entertaining, too
05:59:21 <int-e> Oh right. http://events.ccc.de/congress/2011/Fahrplan/events/4763.en.html
05:59:36 <ksf> http://www.youtube.com/watch?v=3kEfedtQVOY
06:00:36 <Peaker> _Vi, I hate XML because of the horrid syntax and because of the useless complexity.. Why do we need attributes and elements? Why can we mingle meaningful text just anywhere?  The XML data-type is a tree of elements with 2 other leaf types (Text, Attributes)  where you really just want a tree of one kind of thing (e.g: elements) and that could serve the same purpose and be so much simpler
06:00:37 <hahy> Can anyone please explain to me what this variable substitution in lambda calculus is all about? What's this notation? x[x := N] = N
06:01:41 <ksf> http://piqi.org/
06:01:41 <Peaker> hahy, basically it means that if you have:   (\x -> x + 1)   and that is applied to "BOO"  then you get   BOO + 1      (i.e: every appearance of 'x' is replaced by 'BOO' in the lambda body, namely 'x + 1')
06:01:44 <ksf> that sounds nice.
06:01:44 <int-e> hahy: M[x := N] denotes the result of substituting the variable x by a lambda term N in a lambda term M
06:01:57 <ksf> no haskell version yet, though.
06:02:24 <Peaker> hahy, so you can write:  (x + 1)[x := BOO]  to mean the same as  (BOO + 1)
06:02:25 <ksf> but the fact that the versions that do exist are erlang and ocaml is a good sign.
06:02:45 <hahy> hmm okay
06:03:19 <cwp> Why does wxHaskell programs take so long to start up? There is a 2-3second delay'
06:03:27 <hahy> thanks guys
06:03:31 <srhb> cwp: Instant here..
06:05:34 <mparodi> Hello guys
06:05:40 <srhb> mparodi: Hi.
06:05:55 <mparodi> let foo x y | Something x' <- x = ...
06:06:05 <mparodi> it's not working in hugs, what's wrong? isn't it supported?
06:06:12 <srhb> mparodi: Pattern guards. No, I don't think it is.
06:06:17 <mparodi> hmn
06:06:30 <mparodi> what do you do instead?
06:06:37 <srhb> mparodi: use GHC/GHCI
06:06:44 <srhb> mparodi: Or case expressions.
06:06:55 <mparodi> I need it to work in hugs
06:07:03 <mparodi> (it's already working in GHC)
06:07:59 <mparodi> let foo x y = case (x) of Something x' -> ...
06:08:00 <srhb> > let foo x = case x of (Just 2) -> "foo" in foo (Just 2)
06:08:02 <lambdabot>   "foo"
06:08:12 <Botje> mparodi: who is forcing you to use hugs?
06:08:22 <mparodi> Botje, our teacher :|
06:08:54 <srhb> Hm, superfluous parens..
06:09:05 <Botje> any good reason?
06:09:09 <srhb> > let foo x = case x of (Just 2) -> "foo"; _ -> "bar" in foo (Just 3)
06:09:10 <lambdabot>   "bar"
06:09:25 <srhb> mparodi: Got it? :)
06:09:26 <mparodi> the problem with case is that the real code is something like that:      foo | Whatever x' <- x = ... | Bar y' <- y = ... | ....
06:09:31 <mparodi> so I need like 7 case :|
06:10:05 <mparodi> 9 to be precise
06:10:23 <Botje> and you can't do a normal pattern match?
06:10:30 <mparodi> no in hugs
06:10:40 <Botje> that's not a normal pattern match, that's a pattern guard.
06:10:50 <Botje> can you give an overview of your cases?
06:11:05 <mparodi> ah, I got it. and no... all of theme are like "Foo s <- t = ..."
06:11:20 <mparodi> them*
06:11:21 <srhb> > let foo (Just x) y = x in foo (Just 2) "blah"
06:11:22 <lambdabot>   2
06:11:36 <Botje> if they all match on t you can case off of that.
06:11:42 <mparodi> let me past an example
06:11:51 <srhb> mparodi: hpaste.org
06:15:08 <hpaste> mparodi pasted “Example” at http://hpaste.org/70256
06:15:12 <cwp> btw, there are textfields in wxHaskell right?
06:15:31 <cwp> well obv there has to be
06:15:44 <srhb> mparodi: Where are s e and y from?
06:15:49 <mparodi> s/show//
06:16:01 <mparodi> ok, let me correct that
06:17:03 <hpaste> mparodi pasted “Example” at http://hpaste.org/70257
06:17:06 <mparodi> done
06:17:13 <mparodi> srh, Botje ^
06:17:26 <uncommonlisper> so when iw rite my client the easiest thing would be to just run from mingw prompt , open up a connection and print out in the prompt?
06:17:36 <noj> hi, I'm trying to use Network.Pcap, but run into the following exception: "MyApp: NetworkziPcapziBase_d3aJ: uncaught exception"
06:17:37 <Botje> mparodi: and what are the types of t1 and t2 ?
06:17:48 <mparodi> Char -> Foo
06:17:50 <noj> how do I figure out more about what/who/where the exception was thrown?
06:17:54 <srhb> mparodi: So you have whatever _ 0 = ... and whatever c _ = case c of..
06:18:06 <noj> I'm a haskell newbie
06:18:10 <mparodi> actually t1 returns ALWAYS Something or Done, t2 Example or Done, t3 Yada or Done
06:18:26 <Botje> mparodi: aha!
06:18:44 <mparodi> aha!?
06:18:51 <uncommonlisper> do we have sockets in haskell?
06:18:55 <Botje> mparodi: then define a Monoid instance for Foo and do case t1 c `mappend` t2 c `mappend` t3 c `mappend` ... of ...
06:19:07 <mparodi> what!?
06:19:40 <srhb> uncommonlisper: Network and Network.Socket for instance.
06:19:54 <Botje> mparodi: write a function that takes two Foo's and fold it over [t1 c, t2 c, t3 c, Done]
06:20:20 <fmap> isn't something like `case (t1 c, t2 c, t3 c) of (Something s, _, _) -> ...' easier?
06:20:35 <mparodi> can you do that?
06:20:39 <srhb> Sure..
06:20:44 <mparodi> oh
06:20:45 <mparodi> interesting
06:20:50 <mparodi> in hugs?
06:20:56 <mparodi> it would be easier I believe
06:20:59 <srhb> It's a standard case expression.
06:21:17 <uncommonlisper> ok that was easy enough
06:21:22 <srhb> uncommonlisper: :)
06:21:42 <mparodi> Botje, is your idea better than fmap's idea?
06:22:09 <Botje> mparodi: only on #haskell will you get a truthful response to that :)
06:22:11 <srhb> It'll give you a higher grade. :-)
06:22:25 <srhb> Or allegations of cheating...
06:22:30 <noj> let me rephrase my question: If I have a function, Network.Pcap.loopBS (yada :: IO Int) how do I protect that call with catch (Control.Exception.catch)? It returns an Int, so the naive thing doesn't work. any pointers?
06:22:30 <mparodi> hahaha
06:22:46 <srhb> noj: spoon?
06:23:03 <Botje> mparodi: both will work. fmap's idea makes it clear that you're only interested in *one* possible response from each helper function
06:23:09 <noj> srhb: say what?
06:23:21 <Botje> mine assumes each function returns Done *or* something useful.
06:23:35 <mparodi> ok, I'll try with fmap's idea now
06:23:37 <Botje> and uses that fact to fold all your functions into either Done or a useful value and then cases on that.
06:23:58 <srhb> noj: spoon (a -> b) gives you Just b if no exception was raised, otherwise Nothing. It's a bit general, I think...
06:24:05 <mparodi> actually it's not true, two of them can return something different from Done
06:24:31 <Botje> *now* you tell us :/
06:24:34 <hahy> so lambda substitution does not apply to bound variables? I mean, variables have to be free to be substituted?
06:24:42 <mparodi> for example, t1 = Something 1 and t2 = Done and t3 = Yada 'a'
06:24:55 <Botje> mparodi: please give more concrete specifications up front, it's really no fun to chase changing requirements
06:25:00 <Botje> we do that in real life enough already :)
06:25:22 <ksf> @hoogle concatMapM
06:25:23 <lambdabot> No results found
06:25:56 <noj> srhb: ok. But I want to find out more about the nature of the exception, what's a poor imperative programmer to do?
06:27:03 <srhb> noj: Well, if you want to know what the exception is caused by, there should be info about that specific Exception in the library of the function that threw it, I should think?
06:27:18 <mparodi> it's huge
06:27:25 <mparodi> (Foo x', _, _, _, _, _, _, _, _) -> ...
06:27:26 <mparodi> lol
06:29:05 <Botje> good thing you have pattern guards OH WAIT.
06:29:41 <noj> srhb: there's some name mangling going on: "NetworkziPcapziBase_d3aJ", besides the Network.Pcap.Base docs are non-existant, I shall dig into the code
06:29:44 <noj> thanks
06:30:06 <srhb> noj: Oh, yeah, I see that. Ew.
06:30:49 <srhb> noj: Sorry, I know nothing about that. Never seen it before.
06:30:56 <fmap> what's the difference between pattern guards and view patterns?
06:30:59 <noj> np
06:32:36 <srhb> noj: What are you doing to generate that exception? Would you care to paste it?
06:32:49 <fmap> ah, you probably cannot nest pattern guards
06:33:44 <quicksilver> preflex: zdec NetworkziPcapziBase_d3aJ
06:33:44 <preflex>  Network.Pcap.Base_d3aJ
06:33:50 <quicksilver> noj: ^^, FYI.
06:33:55 <mparodi> wow, you don't know how useful are patterns guards until you can't use them u.u
06:37:13 <mparodi> @src subsequences
06:37:14 <lambdabot> Source not found. It can only be attributed to human error.
06:37:37 <mparodi> @hoogle subsequences
06:37:37 <lambdabot> Data.List subsequences :: [a] -> [[a]]
06:37:46 <mparodi> it's not in hugs neither >_>
06:38:04 <Botje> mparodi: isn't it much easier to tell your teacher to upgrade?
06:38:11 <mparodi> haha
06:38:26 <mparodi> they should, I agree...
06:39:00 <srhb> Just paste your solution that works with pattern guards after your hugs solution :-) "Here's how it would look if you didn't suck..."
06:39:29 <mparodi> alright, I guess I'll need to implement subsequence as well
06:40:26 <srhb> noj: It looks like something is not right with pcap_geterr
06:40:27 <Botje> (this reminds of making websites IE6/7 compliant *shudder*)
06:41:10 <mparodi> have to taken a functional programming course at any College?
06:41:22 <mparodi> what did you use?
06:41:35 <srhb> mparodi: SML - MoSML
06:42:03 <Botje> mparodi: GHC Haskell.
06:42:10 <t7> moscow sml!?
06:42:27 <mparodi> ok, here we use Hugs' Haskell >_>
06:43:17 <srhb> t7: Yes :)
06:43:31 <mparodi> why ":)"? is it somehow better?
06:43:54 <srhb> Uh, I prefer Haskell by many lengths, but I knew nothing about it before I had that course.
06:44:26 <mparodi> then it's better here :P
06:44:42 <srhb> mparodi: No doubt, you get to do IO without feeling guilty.
06:56:08 <uncommonlisper> everyone here use emacs or vim for haskell?
06:56:34 <uncommonlisper> is there no generally used IDE including debugger for haskell?
06:56:39 <uncommonlisper> do people want one?
06:56:59 <t7> ghci
06:57:15 <ehamberg> there is leksah
06:57:26 <quicksilver> there is no "generally used" one
06:57:37 <quicksilver> you will find people who use leksah, and eclipse
06:57:48 <quicksilver> and there are some others in various stages of development
06:57:50 <raichoo> uncommonlisper: vim with neocomplcache and ghc-mod
06:58:07 <donri> no integrated debugger in vim AFAIK
07:00:28 <mparodi> haha
07:00:53 <mparodi> ok, suppose that want this code to work in both ghc and hugs
07:01:14 <mparodi> I have to implement subsequences since it's not in hugs
07:01:28 <mparodi> but for ghc I have to import Data.List (I use it) hiding subsequences
07:01:46 <mparodi> which makes hugs to print a warning since it's not in Data.List!
07:02:10 <donri> mparodi: does hugs support CPP?
07:02:15 <mparodi> CPP?
07:02:25 <sjoerd_visscher> mparodi: import only the functions you need
07:02:33 <donri> or that
07:02:36 <Botje> just ask your teacher if GHC haskell is fine, since that's what The Haskell Community (tm) recommends.
07:02:38 <donri> or qualified
07:02:43 <mparodi> I'll implement subsequences with another name
07:02:56 <uncommonlisper> File name does not match module name:
07:02:56 <uncommonlisper>     Saw: `Main'
07:02:56 <uncommonlisper>     Expected: `Communication'
07:03:02 <uncommonlisper> but thats not what it says
07:03:12 <mparodi> like... subseq >_>
07:03:31 <donri> uncommonlisper: if a file doesn't have an explicit module declaration, it is assumed to be Main
07:03:32 <uncommonlisper> Main.hs has module Main where, Communication.hs has module Communication where and IrcGui.hs has module IrcGui where
07:05:23 <donri> mparodi: http://www.haskell.org/haskellwiki/Import_modules_properly
07:11:31 <cwp> Build-Depends:     base >= 3 && < 5,
07:11:32 <cwp>                      network >= 2.3.0.5,
07:11:33 <cwp>                      wx >= 0.90.0.1
07:11:37 <cwp> whats wrong with that?
07:13:46 <Botje> which error do you get?
07:16:06 <cwp> could not find module Network perhaps you need to add it to buyild deps
07:16:17 <cwp> i already did that like above
07:17:36 <cwp> can you shut off all the * some_dude joined #haskell?
07:18:10 <xraycat> depends on the client I guess
07:24:11 <Peaker> say you have:  f :: Foo -> Bar       and you are implementing   g :: (forall bottom. bottom) -> Bar    why does this type-check:  g x = f x      but this doesn't:   g = f?   Why can't GHC see that the polymorphic type is instantiated to Foo?
07:24:16 <Peaker> (in the latter case)
07:24:57 <Peaker> Rank2 makes all kinds of mechanical refactorings break :-(
07:36:42 <int-e> Peaker: because it's the 'x' that's instantiated, from ghc's point of view - only outermost 'forall' can be dealt with.
07:37:14 <Peaker> is there an inherent reason for outer-most forall only?
07:37:19 <int-e> (at least that's my rule of thumb, and it works quite well in practice)
07:40:23 <sipa> Peaker: "g :: (forall bottom. bottom) -> Bar" means "g is a functon which you give something of an (to g) unknown type, and it returns something of type Bar
07:40:47 <int-e> Peaker: I'm not sure. On the surface, there is a connection to System F (which has explicit type applications, and the type needs to be applied to the x). SPJ might have an example where adding more "magical" conversions becomes very tricky. I don't.
07:40:50 <sipa> and f does not accept any type as input
07:41:18 <sipa> Peaker: wait, i must be missing something; neither of those should typecheck
07:42:00 <Peaker> sipa, g takes a polymorphic value, so it is able to instantiate that value to any type it wants, including Foo for the call to f
07:42:26 <sipa> oh, of course
07:50:07 <edwardk> @pl \p' q' -> duplicate (p' <@> q')
07:50:07 <lambdabot> (duplicate .) . (<@>)
07:51:14 <Peaker> (result . result) duplicate (<@>)
07:52:11 <edwardk> thats not bad
07:52:11 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:52:40 <edwardk> @where pi_10
07:52:41 <lambdabot> (!!1)<$>transpose[show$sum[(8-i.&.3*4)*div(1000^2^n)(a^i*i)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]
07:54:54 <noteventime> I want to use Haskell to do some basic processing of multipart/form-data for a website served by nginx. My initial and current try is to use fastcgi (+ spawn-fastcgi); but handling the form-data seems rather complicated. I've had some success with the mime package on hackage, but its results are somewhat cumbersome to work with and I have to manually extract the relevant headers using FastCGI.requestHeader (rather than being able to
07:54:54 <noteventime> just pass all headers). Should I do a reverse proxy to some WARP thing instead?
07:55:41 <noteventime> All I want to do is to twiddle a few values and set a redirect
08:00:35 <noteventime> Also, any file handling is done by the nginx upload module, so it's just a matter of parsing a number of text fields.
08:01:58 <keseldude> I think using fastcgi is a good/fine way (note: I've never done this; I've just read a little bit about it)
08:04:19 <keseldude> noteventime: to get all the headers (well, all the "vars"), you do cgiGet cgiVars
08:04:45 <keseldude> or http://hackage.haskell.org/packages/archive/cgi/3001.1.8.2/doc/html/src/Network-CGI.html#getVars
08:05:00 <keseldude> which will give you a list instead of a map
08:10:30 <noteventime> keseldude: The problem is that their names aren't what the mime package expects
08:10:36 <noteventime> nginx renames them
08:11:23 <keseldude> I suppose you could rename them manually before you pass them to the mime package
08:11:28 <keseldude> I've never worked with it
08:11:59 <noteventime> I guess I should just reconfigure nginx not to do it, but I think that'll mean telling it what name to use for each possible request header
08:35:06 <joe9> is there anything in cabal to clean up old libraries?
08:37:42 <chris2> yesod routing /#Int/foo/#Int/bar should match /6/foo/-8/bar, no?
08:37:52 <chris2> it only seems to work for positive numbers
08:44:05 <cwp> ghci cannot run wxHaskell becuase ghci cannot mix static and dynamic libs
08:44:30 <cwp> aha!
08:44:54 <matthiasgorgens> Is there a way in Haskell to automatically get typeclasses instances defined, if other instances are met?  E.g. to make a Functor out of a Monad?
08:46:45 <NemesisD> a couple of questions: is containers part of ghc? if so, is it then a bad idea to specify a version of it in a cabal file and if so, how can i get a list of packages included with the compiler so i make sure not to put them as deps
08:49:45 <td123> NemesisD: containers is included with ghc
08:51:21 <td123> NemesisD: check the provides array at http://www.archlinux.org/packages/extra/i686/ghc/ for a list
08:51:35 <NemesisD> ah ok
08:51:49 <NemesisD> secondly, do you know anything about cabal-dev?
08:53:14 <td123> I've heard of it, but I'm probably not the person to know about it :)
08:53:48 <NemesisD> shoot. the whole thing is that it behaves just like cabal but install deps local to the project to help with dependency hell
08:54:15 <td123> NemesisD: just ask your question, I'm not the only one in here :P
08:54:39 <NemesisD> which is good for everything except i think it tries to install stuff included with GHC like template-haskell. So on an old GHC it seems to be downloading the latest 2.7 and that won't fly with old ghc
08:55:50 <NemesisD> i think it needs to check the global ghc package db first before installing, or skip stuff included with ghc?
09:00:24 <cwp> anyone know how to connect an action to the X(close) button in wxHaskell?
09:02:18 <NemesisD> td123: alternatively, i'd like to know how to case off ghc version in the cabal file
09:02:32 <NemesisD> all examples refer to package versions with #if
09:14:53 <NemesisD> ugh
09:16:08 <NemesisD> i HATE old versions of GHC. make my job so much harder
09:17:02 <tac-tics> NemesisD: What's the problem you're having? /curious
09:17:29 <stprogrammer> I would have a question...
09:17:52 <stprogrammer> is there a Problem similar to the Expression Problem by Wadler to benchmark programming languages?
09:18:52 <NemesisD> tac-tics: basically this https://github.com/creswick/cabal-dev/issues/60
09:19:52 <NemesisD> tac-tics: my issue is that my dev env is ghc 7.4, which must have template-haskell > 2.6, my target env is ghc 7.0.4, which must have template-haskell 2.5. template-haskell is an indirect dep of my project, and when i try to build, cabal-dev goes and grabs the latest version, 2.7 then fails because the compiler is too old
09:20:19 <tac-tics> >_<
09:20:38 <cwp> ^^ so anyone using wxHaskell? or maybe someone else can also tell me. how do i do on Command := handle <- f a b c; ?
09:20:39 <tac-tics> I've never used Template Haskell, but I can't imagine it is a worthwhile thing.
09:20:56 <NemesisD> tac-tics: again, i don't really use it, but its an indirect dependency
09:21:28 <tac-tics> yeah
09:21:29 <NemesisD> and i'd love it if cabal-dev just linked against the version that came with ghc. but i know that if i specify template-haskell with no version in the cabal file that it will try to grab the latest
09:21:55 <quicksilver> cwp: on command := do {handle <- f a b c; something_else_with handle}
09:22:04 <quicksilver> cwp: you can use multiple lines instead of do, of course.
09:22:10 <quicksilver> or use a named action.
09:22:59 <td123> NemesisD: have you considered downgrading to ghc 7.0.4 if that is what you're targetting? you might have less headaches
09:23:49 <NemesisD> td123: difficult to do under arch linux, will also make all my development i do for less incompetent platforms pretty miserable
09:24:15 <NemesisD> i can't be the first person doing what i'm trying to do
09:24:46 <NemesisD> and also i don't think downgrading to ghc 7.0.4 would help since cabal-dev seems to just want to grab the latest template-haskell since the version of ghc doesn't seem to affect that
09:24:53 <cwp> quicksilver: but i want it avilable to another := later
09:25:00 <NemesisD> preprocessing the .cabal file would work too but i don't think i can do that
09:25:02 <cwp> which becomes weird
09:25:29 <cwp> NemesisD: use the C preprocessor?
09:26:06 <NemesisD> cwp: it isn't in the haskell code though, its in the cabal file
09:26:25 <cwp> same thing?
09:26:33 * hackagebot amqp 0.3.2 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.3.2 (HolgerReinhardt)
09:27:05 <NemesisD> cwp: how? i'm not compiling the cabal file so specifying -cpp in the flags does me no good? putting #if in the cabal file makes cabal not parse it
09:27:15 <quicksilver> cwp: well of course it won't exist until that event happens.
09:27:47 <quicksilver> cwp: the simplest solution would be to put it into an MVar that the other place can also see.
09:28:25 <rwbarton> you should be able to specify the template-haskell version based on the base version using cabal flags
09:28:35 <rwbarton> I don't know exactly how to do it though
09:28:36 <quicksilver> handleMV = newEmptyMVar; widg1 <- new widget [ on command := do { handle <- f a b c; putMVar handleMV handle } ]
09:28:53 <quicksilver> cwp: ^^ and then the other handler can use readMVar to access it.
09:28:53 <NemesisD> rwbarton: the conditional compilation section on the cabal page only references how to put it in code
09:29:06 <quicksilver> cwp: there are other ways to skin this cat but that should get you thinking along the right lines.
09:29:22 <rwbarton> something like
09:29:33 <favonia> NemesisD: this is hacky, but how about a conditional version specificiation based on GHC version?
09:29:40 <cwp> NemesisD: ok sorry
09:29:58 <rwbarton> If flag(ghc70) Build-Depends: base == X, template-haskell == Y Else Build-Depends: base == X', template-haskell == Y'
09:30:09 <NemesisD> favonia: i'd love to do that if i could
09:30:10 <favonia> NemesisD: oh sorry I was too slow and didn't see the following conversation
09:30:28 <rwbarton> oh and you have to define the flag too
09:30:42 <NemesisD> rwbarton: where?
09:30:48 <rwbarton> also in the cabal file somehow
09:32:01 <NemesisD> i can't find a list of built in flags for cabal, seems like they have one for arch
09:32:09 <favonia> NemesisD: if impl(ghc >= x.y) blah blah ?
09:32:15 <favonia> in .cabal
09:32:23 <rwbarton> you make up a flag
09:32:55 <favonia> NemesisD: I think you already have impl(ghc ...)
09:33:16 <NemesisD> rwbarton: i'm trying to figure out a way that i don't have to manually specify the compiler version in a flag, that's not the user's concern
09:33:27 <rwbarton> e.g. see http://hackage.haskell.org/packages/archive/json/0.5/json.cabal
09:33:37 <rwbarton> the user doesn't have to specify the flag
09:33:42 <rwbarton> the solver will determine what value to use
09:33:44 <geekosaur> NemesisD, cabal can figure flags itself via the dependencies
09:34:00 <geekosaur> but it has to have the flag to associate the dependencies with
09:34:43 <geekosaur> see for example all the packages that have a small_base flag, nobody has ever had to say --flags=small_base because cabal figures out itself that it needs to enable the flag
09:35:51 <NemesisD> favonia: well it seemed to parse impl, i can't find documentation about it anywhere. its like its a secret or something
09:35:56 <rwbarton> it seems like definitely a bug though that you have to do this in the first place, either in cabal or cabal-dev
09:36:19 <favonia> NemesisD: hmm for the doc I don't know :P
09:36:33 * hackagebot fixplate 0.1.5 - Uniplate-style generic traversals for optionally annotated fixed-point types.  http://hackage.haskell.org/package/fixplate-0.1.5 (BalazsKomuves)
09:36:53 <NemesisD> haskell needs better SEO i guess. i'm going to try to compile this in production, fingers crossed
09:37:44 <favonia> NemesisD: http://hackage.haskell.org/packages/archive/cabal-dev/0.9.1/cabal-dev.cabal <- you can check this. their usage should be authoritative
09:38:26 <NemesisD> favonia: that's exactly where i looked lol. wish that type of stuff made it into the cabal docs
09:38:30 <geekosaur> http://www.haskell.org/cabal/users-guide/developing-packages.html#configurations
09:38:55 <NemesisD> ah now i see it
09:38:58 <NemesisD> bookmark'd
09:39:27 <favonia> NemesisD: http://www.haskell.org/cabal/users-guide/developing-packages.html#conditions
09:39:37 <favonia> NemesisD: ah too late :P
09:39:51 <favonia> NemesisD: but mine is more accurate
09:42:14 <NemesisD> question for you guys, so should the build-depends be addative? i have a main Build-Depends then one under the impl() that names just one package in the build depends, do those two lists add together?
09:44:03 <cwp>  handleMV = newEmptyMVar; <- that doesnt work
09:44:06 <cwp> fails on =
09:45:19 <srhb> cwp: No it doesn't. Though that probably is not what you are doing either.
09:45:44 <cwp> arse error on input `='
09:46:04 <cwp> shopuildnt it be <-?
09:46:12 <rwbarton> yes that's what he meant of course
09:46:15 <srhb> If it's in a do block, that is probably what you want.
09:47:33 <NemesisD> thanks guys. everything seems to be working fine. i really appreciate it!
09:48:21 <favonia> NemesisD: I guess so. glad that youve figured it out
09:48:48 <zaphix> Can someone help me understand why the following raises a runtime error with the message "b" instead of with the message "a"?  I'm somewhat confused:  Ctor me ann -> maybe undefined (\_ -> error "a" >> error "b") me
09:50:34 <rwbarton> what monad is that (>>) in
09:51:20 <zaphix> rwbarton: WriterT [a] (StateT S Id)
09:51:33 <zaphix> rwbarton: from monadLib
09:51:39 <rwbarton> lazy writer? then (>>) demands its second argument first
09:51:44 <cwp> which module does MVar come from?
09:51:50 <rwbarton> or wait
09:52:15 <rwbarton> well yeah, what i said is still true assuming both lazy WriterT and lazy StateT
09:52:25 <zaphix> rwbarton: i was attempting (and failing) to write some monadic debugging routines without IO at the bottom of the transformer stack
09:52:25 <srhb> @index MVar
09:52:25 <lambdabot> GHC.Conc, Control.Concurrent.MVar, Control.Concurrent
09:52:35 <zaphix> and then noticed that even sequencing error calls like that gave me behavior I didn't understand ;P
09:53:02 <zaphix> rwbarton: Can you elaborate a bit on that?  Sounds like that is what is biting me, but I'm obviously not understanding why
09:53:27 <rwbarton> well i don't really understand why you expect any particular behavior from this code, or care which error it produces
09:53:47 <rwbarton> but
09:54:02 <rwbarton> "error" raises an error when it gets *evaluated*
09:54:24 <rwbarton> in general evaluation order may have nothing to do with the sequential order of actions in the monad
09:54:26 <zaphix> rwbarton: yeah, it's a bit of a contrived example.  perhaps another way to look at this is that i'm trying to trace through some code that i'm having a difficult time reasoning about, and output from trace is simply not being displayed at all.
09:54:30 <zaphix> rwbarton: yeah, okay, that makes sense.
09:54:50 <rwbarton> hmm
09:55:22 <zaphix> i mean, i can trace "foo" $ return () in this particular case and won't ever see that output, with or without a subsequent error call
09:55:42 <rwbarton> the lazy Writer and State monads are like that
09:56:02 <rwbarton> let me try to cook up an example
09:56:18 <zaphix> rwbarton: very cool, thanks
09:56:59 <rwbarton> > execWriter $ do { undefined; tell $ Last (Just 3); return () }
09:57:00 <lambdabot>   Last {getLast = Just 3}
09:57:09 <cwp> how do you get command line options?
09:57:29 <cwp> ./IRCclient cwp pw ?
09:57:33 <srhb> cwp: getArgs is a simple such method
09:58:12 <zaphix> rwbarton: yeah, that's very counter-intuitive to me.  Would it make sense if I unrolled the bind applications in that sequence?
09:59:08 <rwbarton> yeah, and take note of the difference between (>>=) for the strict and lazy Writer variants
09:59:30 <rwbarton> though... your monoid [a] is not so lazy as Last, so you can't quite have this kind of thing happening
09:59:31 <favonia> zaphix: EitherT seems to enable you to do what you want, by the way
10:00:09 <rwbarton> (I don't know why I included the return (), it's redundant)
10:00:20 <zaphix> favonia: yeah, i was debating the need to add a proper error handling layer to the transformer stack; is that basically what you mean?
10:00:34 <zaphix> rwbarton: *nod* okay, I think that helps a tad with the intuition; thanks
10:00:35 <rwbarton> > runState (do { undefined; put 5; get }) undefined
10:00:36 <lambdabot>   (5,5)
10:00:38 <rwbarton> another example
10:00:40 <favonia> zaphix: yes
10:00:45 <cwp> if i click the button again i egt output <<loop>> i guess because i try to put something in the MVar again, how can i check if the MVar is empty? but thats bad solution anyway, if the handle(socket) is open
10:00:46 <cwp> ?
10:01:08 <rwbarton> if you switch to the strict Writer and strict State you might get easier to understand trace output
10:01:39 <zaphix> For debugging stageful monadic codes -- e.g. I'm basically looking for the ability to do some lowbrow printf-style debugging -- what's the best solution?  An additional WriterT for logging messages, and inspection upon some kind of error raise, or what?
10:01:44 <zaphix> rwbarton: yeah, that's probably the first thing that i'm going to do
10:03:30 <zaphix> Whups, I meant "stageful", not "stageful" :P
10:03:35 <zaphix> Also, stateful!
10:04:30 <favonia> zaphix: personally I would like to break the function into small pieces and test each fragment, if possible
10:04:31 <cwp> lol
10:05:18 <cwp> getMVar nope, takeMVar?
10:05:19 <zaphix> favonia: i'm not sure how to do that in this case -- this is essentially imperative code that mutates a fair bit of state, and i'd like to see those intermediate state values at certain points
10:05:27 <rwbarton> fwiw i think trace will behave about how you expect with the strict variants
10:05:43 <navaati> (hey, hpc, great article about continuations you've written !)
10:05:52 <zaphix> rwbarton: *nod* that makes sense, and i'm going to try that -- just wondering how this kind of this is addressed in general
10:05:57 <zaphix> kind of thing*
10:06:07 <rwbarton> a more extreme option would be to change the base monad to IO temporarily
10:06:23 <rwbarton> even if you wrap the whole function in unsafePerformIO for testing
10:06:34 * hackagebot hs-java 0.3.3 - Java .class files assembler/disassembler  http://hackage.haskell.org/package/hs-java-0.3.3 (IlyaPortnov)
10:06:34 <rwbarton> might help with understanding what is going on
10:06:42 <zaphix> rwbarton: right. so something like a "LoggerT" or something might not work very well?
10:06:43 <rwbarton> of course it will also affect what is going on :)
10:06:47 <zaphix> rwbarton: right =D
10:08:04 <rwbarton> seems like that could end up in the same situation you find yourself currently
10:08:04 <zaphix> rwbarton: I guess my imperative roots are showing -- my go-to reasoning approach when faced with debugging something is still oriented around how the program executes rather than tracking what values are actually being computed =)
10:08:11 <zaphix> rwbarton: yeah
10:10:06 <zaphix> rwbarton: hmm, now i'm confused, though, the monadLib documentation states that its WriterT is strict in its output component.
10:10:51 <cwp> when i takeMVar i dont want to take it then the MVar is gone. or maybe i do
10:10:59 <cwp> oh wait u said read
10:11:14 <glguy> Is there a way to "scanl" repa arrays?
10:11:17 <SegFaultAX> Are all operators value constructors?
10:12:56 <rwbarton> oh i hadn't seen the monadLib versions
10:13:17 <zaphix> At least, that's what it says here: http://hackage.haskell.org/packages/archive/monadLib/3.6.2/doc/html/MonadLib.html =)
10:13:54 <favonia> zaphix: for things with states, I might, for example, specify the beginning state and see what have been changed after a micro step.
10:13:57 <rwbarton> its (>>=) isn't strict in the first argument though
10:14:18 <zaphix> favonia: ah that's a good idea, actually
10:14:25 <zaphix> rwbarton: ah right
10:14:37 <rwbarton> I think the monadLib version of what I said is to switch your base monad to Lift rather than Id
10:15:05 <zaphix> rwbarton: Ah ok, I'll take a look at that
10:15:08 <zaphix> Thanks everyone =)
10:15:20 <favonia> zaphix: of course it's boring to generate test cases. in some cases QuickCheck or something can help you
10:17:12 <zaphix> rwbarton: You're right, changing the base monad to Lift rather than Id gave me the strictness that I was presupposing.  Thanks muchly.
10:18:38 <cwp> set irc_frame [layout := minsize (sz windowSizeX windowSizeY) $ widget connect] //// anyone know how to add several widgets?
10:18:45 <cwp> and what is sz?
10:28:31 <NemesisD> how can i force the evaluation of a variable?
10:28:51 <zaphix> NemesisD:  seq?
10:29:10 <NemesisD> zaphix: the type signature confuses me though because it returns its second argument, don't i want something with 1 argument?
10:29:25 <NemesisD> unless i do like seq someVar someVar?
10:29:29 <zaphix> varToEval `seq` exprUsIngVarToEval
10:30:10 <zaphix> the second argument is just returned as the result
10:30:10 <NemesisD> zaphix: in my case i'm in a do-expression, and i want to do something like evaluatedvar <- forceEvaluation <$> someIOOperation
10:30:20 <cwp> so anyone know how to use the set function for several widgets?
10:30:27 <ion> @type evaluate
10:30:28 <lambdabot> Not in scope: `evaluate'
10:30:37 <zaphix> NemesisD: how about !evaluatedvar <- someIOOperation
10:30:41 <zaphix> with BangPatterns enabled?
10:31:06 <NemesisD> thatll work
10:31:16 <ion> @type System.Exception.evaluate
10:31:18 <lambdabot> Couldn't find qualified module.
10:31:28 <ion> @hoogle System.Exception.evaluate
10:31:28 <lambdabot> package isevaluated
10:31:34 <zaphix> NemesisD: Not sure if that's the "right" way to do it, but it's what I've done in the past =)
10:31:46 <ion> meh
10:31:54 <geekosaur> Control.Exception.evaluate
10:31:56 <ion> foo <- evaluate =<< someAction
10:32:05 <ion> geekosaur: Ah, brainfart. :-)
10:32:16 <zaphix> ion: interesting, i've not seen that before
10:41:44 <NemesisD> ion: question about weak head normal form, if someAction results in [a], wil it only evaluate the first element or all of it?
10:42:05 <c_wraith> NemesisD: neither
10:42:08 <roconnor_> NemesisD: it will evaluate enough to determine if it is nil or cons
10:42:13 <cwp> what would make you guys actually switch IRc-client? what are you missing? besides using one written in haskell...
10:42:14 <c_wraith> NemesisD: it will evaluate the constructor of the list
10:42:21 <roconnor_> NemesisD: and not touch any elements
10:42:41 <NemesisD> i'm not sure what the practical implications are of that
10:43:07 <NemesisD> basically in the monad, i do an IO query that returns a list and then close the connection and i want to make sure all of those results are returned before closing
10:43:07 <c_wraith> > (undefined:undefined) `seq` ()
10:43:08 <lambdabot>   ()
10:43:17 <rwbarton> the practical implication is that this probably isn't what you want to do
10:43:39 <c_wraith> NemesisD: it means you probably don't want something that uses unsafeInterleaveIO
10:44:14 <NemesisD> then what do i want to do? i'm using mysql-simple which has unsafe ffi bindings to the mysql c library
10:44:41 <c_wraith> it *probably* doesn't use unsafeInterleaveIO
10:44:47 <c_wraith> given what I know about the author of the package
10:45:11 <c_wraith> meaning that the IO will complete before the query action returns
10:45:41 <c_wraith> remember, IO is usually strict in sequencing effects.
10:45:49 <c_wraith> unless unsafeInterleaveIO is used
10:45:59 <NemesisD> c_wraith: oh, so i shouldn't need the evaluate then?
10:46:15 <c_wraith> yeah, you probably don't need it
10:46:29 <cwp> how do you lift something from IO to a function in one step?
10:46:40 <cwp> blah <- X; f blah; ?
10:46:47 <c_wraith> :t liftM
10:46:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:46:55 <c_wraith> :t fmap
10:46:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:46:59 <c_wraith> :t (<$>)
10:47:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:47:02 <cwp> blah $ liftM X?
10:47:11 <c_wraith> liftM blah X
10:47:21 <c_wraith> just follow the types!
10:48:44 <favonia> cwp: what's the type of that function? "a -> m b" or "a -> b" ?
10:49:16 <c_wraith> oh, that's a good point.
10:49:39 <rwbarton> @undo do { blah <- X; f blah }
10:49:40 <lambdabot> X >>= \ blah -> f blah
10:49:46 <rwbarton> @. pl undo do { blah <- X; f blah }
10:49:46 <lambdabot> f =<< X
10:50:13 <c_wraith> I answered the wrong question (though it may have been the intended question - it may not)
10:50:39 <c_wraith> This is why thinking in types are better.  Ask for the type of the function you want, and even hoogle can answer it for you
10:50:56 <rwbarton> or just ask @. pl undo :)
10:51:22 <ion> nemesisd: Perhaps something like “evaluate . force =<< someAction” or “(return $!!) =<< someAction”.
10:51:37 * hackagebot libvirt-hs 0.1 - FFI bindings to libvirt virtualization API (http://libvirt.org)  http://hackage.haskell.org/package/libvirt-hs-0.1 (IlyaPortnov)
10:52:20 <cwp> how do i get the docs for wxHaskell?
10:53:58 <cwp> http://hackage.haskell.org/package/wx <- cant understand how to see documentation
10:54:02 <ion> nemesisd: (In case you *really* need it)
10:54:27 <srhb> cwp: For some reason not all versions have working docs: http://hackage.haskell.org/package/wx-0.12.1.6
10:54:39 <ion> cwp: It seems there has been a build failure, perhaps that’s why the docs are missing.
10:55:54 <favonia> cwp: if you cabal install by yourself, you can generate the document by cabal haddock
10:56:33 <favonia> or cabal install --enable-documentation next time
10:57:09 <nand`> “Could not deduce (Functor m) arising from a use of `fmap' from the context (Monad m)”
10:57:11 * nand` grumbles
10:58:29 <cwp> i cant find how to use set to have several widgets or buttons
10:59:28 <favonia> nand`: unfortunate typeclass hierarchy :(
10:59:34 <S11001001> local documentation rocks
11:04:18 <cwp> set irc_frame [layout := minsize (sz windowSizeX windowSizeY) $ [widget connect]]
11:04:22 <cwp> doe snot work
11:04:31 <mekeor> What are new features of hackage2?
11:06:58 <bitonic> mekeor: facebook likes
11:08:45 <mekeor> bitonic: omg, wow! that's so awesome!
11:10:03 <hpaste> kini pasted “hyphens in symbols” at http://hpaste.org/70273
11:10:15 <kini> can someone explain this?
11:10:37 <kini> I was trying to experiment to see if Haskell allowed hyphens in symbols like lisp does
11:10:48 <geekosaur> it does not
11:10:49 <rwbarton> it doesn't
11:11:05 <kini> ok, but why does it half-work? (see the pastebin)
11:11:12 <kini> or... huh
11:11:16 <geekosaur> what you see there is that you created bindings for a and b with the let
11:11:16 <rwbarton> 'let a-b = "Hello, World!"' -- you just defined a function (-) so that a - b = "Hello, World!" for all a and b
11:11:18 <kini> I guess that's laziness and pattern matching actually
11:11:27 <kini> oh haha
11:11:32 <kini> I redefined (-)
11:11:37 <kini> I see, I see :)
11:11:54 <mekeor> rwbarton: is it possible to overwrite Prelude.(-)??
11:12:03 <rwbarton> you can shadow any identifier
11:12:04 <geekosaur> yes, and just as your redefined (-) stayed in scope, so did the a and b bindings around it
11:12:23 <mekeor> ah, but you get a warning, right?
11:12:33 <geekosaur> hm, no, you created b, sorry
11:12:40 <rwbarton> well apparently not by default in ghci
11:12:42 * geekosaur read for comprehension, dyh
11:12:59 <mekeor> rwbarton: well, it's actually not forall a and b then, right? it's rather pattern matching, actually, isn't it?
11:13:08 <rwbarton> what
11:13:17 <rwbarton> 'a' is a pattern that matches anything
11:13:18 <rwbarton> as is 'b'
11:13:40 <rwbarton> so, it is both 'pattern matching' and it is the case that a - b = "Hello, World!" for all a and b
11:13:41 <mekeor> but a and b are pre-defined…
11:13:44 <geekosaur> mekeor:  it's pattern matching with named variables that happen to be unused
11:13:45 <rwbarton> nope
11:14:03 <rwbarton> a and b there shadow the previously defined variables too, within that definition
11:14:04 <geekosaur> but in that particular context (let a-b = ...) it defines (-) and a and b are shadowed
11:14:38 <mekeor> ah. why? why isn't it pattern matched but shadowed?
11:14:48 <mekeor> i'd expect it do be pattern matching…
11:14:49 <rwbarton> "why"?
11:14:50 <geekosaur> it is
11:14:56 <mekeor> hm, ok.
11:14:59 <geekosaur> you're both saying the same thing
11:15:03 <rwbarton> (1) because that is how the language is defined, 'a' is a pattern that matches anything and names the value 'a'
11:15:04 <geekosaur> in different ways
11:15:14 <rwbarton> (2) the reason it is defined this way is that
11:15:50 <rwbarton> (2a) in general you cannot assume there is a notion of equality for whatever type the value 'a' is
11:15:52 <hpaste> MagneticDuck pasted “parse error...” at http://hpaste.org/70274
11:15:58 <bitonic> mekeor: :)
11:16:04 <cwp>  Not in scope: `*** Exception: <stderr>: hPutChar: invalid argument (character is not in the code page)
11:16:12 <bitonic> mekeor: (it's also not true, obviously)
11:16:13 <MagneticDuck> I got a parse error..
11:16:16 <cwp> what is this? i had some tuf8 encoding problem in emacs
11:16:17 <rwbarton> (2b) it would be bad if i could define 'x' and then it changed the meaning of every pattern match that used the variable 'x'!
11:17:17 <rwbarton> MagneticDuck, it looks like your indentation is in fact incorrect
11:17:21 <mekeor> rwbarton: hm. hmm.. hmmm… okay.
11:17:30 <geekosaur> MagneticDuck, stringPhrase etc. are indented beyond cleaned, so they are taken as continuations of that
11:17:37 <rwbarton> yep
11:18:10 <rwbarton> stringPhrase should start in the same column as cleaned
11:20:06 <cwp> what is this? i had some tuf8 encoding problem in emacs
11:20:09 <cwp>  Not in scope: `*** Exception: <stderr>: hPutChar: invalid argument (character is not in the code page)
11:20:12 <mekeor> rwbarton: so for pattern matching, i have to use constructors directly? i can't use variables, right?
11:20:21 <hpaste> MagneticDuck annotated “parse error...” with “parse error... (annotation)” at http://hpaste.org/70274#a70275
11:20:27 <MagneticDuck> ...this doesn't work either
11:20:35 <mekeor> rwbarton: now i got it!
11:20:58 <rwbarton> there is no kind of "variable pattern"
11:21:13 <mekeor> MagneticDuck: wtf? are you using tabs??
11:21:21 <rwbarton> like you can't define x = [] and then use x in a pattern in place of []
11:21:37 <MagneticDuck> mekeor: lol sry
11:21:42 <mekeor> rwbarton: yup, ok.
11:21:56 <MagneticDuck> mekeor: I am...
11:22:41 <geekosaur> don't use tabs, they just cause confusion
11:22:45 <rwbarton> if you want something like that, use a new variable y and a guard | y == x
11:23:05 <mekeor> MagneticDuck: see also https://github.com/tibbe/haskell-style-guide
11:23:11 <hpaste> mekeor annotated “parse error...” with “how I would indent it” at http://hpaste.org/70274#a70276
11:23:24 <mekeor> rwbarton: yup
11:25:38 <MagneticDuck> wait, what do I use instead of tabs?
11:25:41 <MagneticDuck> spaces?
11:25:46 <MagneticDuck> and why can't I use tabs?
11:25:48 <MagneticDuck> :'(
11:26:03 <rwbarton> you can, if you know what you are doing
11:26:12 <rwbarton> it's easier not to
11:26:19 <mekeor> MagneticDuck: 1 tab = 8 spaces
11:26:23 <newsham> if whitespace is meaningful and tabs are considered to be equivalent to some number of spaces and your tabs are set to be a different number of spaces
11:26:27 <newsham> then confusion may occur
11:26:28 <glguy> Is cabal supposed to build "build-depends" for targets which are not "buildable"?
11:26:44 <c_wraith> glguy: I don't know if it's supposed to, but it sure does
11:26:58 <mekeor> there's http://hackage.haskell.org/trac/haskell-prime/wiki/Tabs though… i just came across it… seems nice.
11:27:33 <xpololz> "[\z.z/x]x" what's this? I don't get why this is the same as \z.z
11:28:12 <newsham> {#- tab=8spaces -#} ?
11:28:14 <Botje> it means substitute \z.z for x in x
11:28:38 <Botje> (it always confuses me too, the ordering is all wrong.)
11:28:40 <mekeor> newsham: did you mean: {-# ?
11:28:47 <newsham> sure
11:29:00 * mekeor hopes he was not wrong.
11:29:20 <newsham> you were not
11:29:31 <mekeor> yep. :)
11:29:52 <xpololz> so it's simply another way/notion for writing x[x := \z.z] ?
11:30:14 <xpololz> the / it's just substitution?
11:30:53 <glguy> c_wraith: looks like the solution might be to put the build-depends under the same if statement that sets buildable to false
11:31:05 <c_wraith> glguy: yeah, that'll work
11:31:13 <c_wraith> glguy: on the other branch, of course
11:31:46 <apfelmus> Hello everyone.
11:32:56 <srhb> apfelmus: Hi :)
11:33:10 <mekeor> heeey apfelmus! nice to meet you =)
11:33:12 <cwp> why does ghc recompile things that havent changed?
11:33:17 <apfelmus> :)
11:33:56 <srhb> I was thinking the same, thanks for your great blogging on FRP ;)
11:34:11 <apfelmus> My pleasure. :)
11:34:26 <apfelmus> By the way, I'm going to give a tutorial on reactive-banana on July 13
11:34:31 <srhb> Where?
11:34:36 <apfelmus> In Halle/Germany...
11:35:07 <srhb> You should place it closer to Wacken at either end. <_<
11:36:16 <apfelmus> Hehe. I would have to change the logo into a death metal banana, though.
11:36:24 <srhb> :-)
11:36:25 <mekeor> no, rather at ulm/stuttgart =)
11:36:52 * apfelmus looks for a bite to eat
11:37:35 <cwp> how can ghci derive a type when you do :t that isnt in scope?
11:40:34 <cwp> forever a = do a; forever a ////polling like that doesnt seem very good
11:40:44 <cwp> isnt there some more reactive way of solving this?
11:42:01 <favonia> cwp: will MVar, TMVar or something help you?
11:45:27 <favonia> cwp: looks like you want concurrency, and (T)MVar, (T)Chan, etc are some nice building blocks
11:51:48 * hackagebot secure-sockets 1.2.7 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.2.7 (IavorDiatchki)
11:52:31 <favonia> cwp: even if a module is not changed, its code might depend on the interface of another module. GHC might cross-module optimize your code too, which makes things "worse" in this case.
11:55:08 <favonia> cwp: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html "Note that higher optimisation levels cause more cross-module optimisation to be performed, which can have an impact on how much of your program needs to be recompiled when you change something. This is one reason to stick to no-optimisation when developing code."
11:57:41 <coldpizza72i> I took a class called Programming Language Concepts and was briefly introduced to functional programming and haskell during a few weeks of the class. Im looking to enhance my understanding of haskell a lot more and was looking for ideas of a a good project that I could work on to do that...
11:59:01 <matthiasgorgens> Why can lead eta conversion to an error that a type is less polymorphic than expected?
11:59:13 <coldpizza72i> anyone have any ideas?
12:00:04 <matthiasgorgens> coldpizza72i: have you read "learn you a haskell for great good"?
12:00:08 <tac-tics> That's a pretty common question around here, I think. Someone ought to make a tutorial
12:00:13 <tac-tics> Or a list
12:00:14 <matthiasgorgens> it's available online and on dead trees.
12:00:16 <tac-tics> or good intro projects
12:02:10 <coldpizza72i> matthiasgorgens: that book looks excellent and I have been planning on reading it, but it was my impression that it was just a book with no assignments or projects to do while reading it
12:03:50 <matthiasgorgens> coldpizza72i: you might want to check out whether real world haskell has assignments.
12:04:03 <matthiasgorgens> coldpizza72i: and of course you can always repurpose the assignments of SICP.
12:04:08 <matthiasgorgens> coldpizza72i: or do Project Euler.
12:04:22 <matthiasgorgens> coldpizza72i: or check your local hackathon.
12:04:25 <shachaf> Don't do ProjectEuler. :-(
12:04:28 <c_wraith> Project Euler is about the opposite of learning haskell.
12:04:52 <c_wraith> It teaches you about 1 pattern (memoization) that is rarely used elsewhere, and otherwise depends on math knowledge, not knowledge of the language.
12:04:59 <matthiasgorgens> oh, Project Euler just gives you a few problems, if you can't come up with any of your own.  they are not ideal problems.
12:05:13 <matthiasgorgens> c_wraith: I'd call that dynamic programming not memoization.
12:05:31 <c_wraith> they're more or less identical in haskell, thanks to lazy evaluation by default
12:05:44 <matthiasgorgens> they are more or less identical everywhere, in a sense.
12:05:55 <gentleben> do the tsuru capital problem
12:05:57 <matthiasgorgens> and dynamic programming does come up quite often in other areas.
12:06:02 <gentleben> its interesting
12:06:08 <gentleben> and real
12:06:25 <c_wraith> the tsuru capital problem is a good idea
12:06:53 <matthiasgorgens> gentleben: URL?
12:07:05 <matthiasgorgens> ah, the code sample link gives it.
12:07:25 <gentleben> http://www.tsurucapital.com/en/code-sample.html
12:08:01 <gentleben> and if you want to see an interesting approach to the parsing piece see http://breaks.for.alienz.org/blog/2012/02/09/parsing-market-data-feeds-with-ragel/
12:08:16 <gentleben> different protocol, same idea
12:08:27 <k0ral> hi, could someone tell me why I should use CmdArgs over GetOpt ?
12:08:56 <matthiasgorgens> coldpizza72i: backissues of the monad reader also make good reading material.
12:12:39 <coldpizza72i> Ill check it out
12:14:18 <zaphix> k0ral: CmdArgs can be pretty concise if you don't stray too far from intended use cases, and there's some added type safety (IIRC)
12:16:41 <cwp> can someone point me to "learn about concurrent threas in haskell". if i need threads? because i need to listen to the irc socket but still notice if the user does something
12:18:03 <jfischoff> what's the cabal options to turn off profiling?
12:18:29 <jfischoff> oh I found it
12:24:53 <JoeyA> After learning about the Prompt monad (as seen in the "MonadPrompt" and "operational" packages), it occurred to me that defining a MonadFoo class is a simpler way to achieve pretty much the same effect (dependency injection).  When would a Prompt monad be better than just a MonadFoo class?
12:25:44 <JoeyA> To illustrate the correspondence: data PromptState s a where Get :: PromptState s s; Put :: s -> PromptState s ()
12:26:08 <JoeyA> versus: class Monad m => MonadState s m where get :: m s; put :: s -> m ()
12:26:53 <jfischoff> is there an automated way to download all dependencies for a cabal package?
12:27:03 <jfischoff> and unpack the sdists?
12:27:04 <JoeyA> jfischoff: Download without installing?
12:27:08 <jfischoff> yeah
12:27:16 <JoeyA> What are you trying to do?
12:27:38 <jfischoff> I want to check the code into a third party folder in source control
12:27:54 <jfischoff> and then use cabal-dev add-source to use the local copies
12:28:16 <jfischoff> so other developers at my company can install my libraries without depending on hackage
12:29:20 <Cale> JoeyA: The Prompt monad lets you define computations and determine how the primitives those computations are built from are carried out separately
12:29:22 <JoeyA> Well, if it doesn't have many dependencies, you could just list the dependencies and add git submodules manually (unless you aren't using git, and except for packages that don't have a git repo).
12:30:00 <jfischoff> it has like maybe a 50 - 100 hundred dependencies
12:30:09 <JoeyA> I'm not aware of an easy way to list dependencies, besides a quick patch I wrote which lists licenses too: http://hackage.haskell.org/trac/hackage/ticket/889
12:30:17 <Cale> Well, I guess polymorphism *sort of* lets you do that too.
12:31:14 <Cale> The typeclass polymorphism route isn't actually going to help you define the monads which are instances of that typeclass though.
12:31:46 <JoeyA> Cale: I'm thinking: define the class MonadFoo, listing and documenting all the operations allowed in that class.  Then, implement business logic, where every function is polymorphic in that monad.
12:31:58 <JoeyA> Define an instance for that monad in a completely separate module.
12:32:14 <jfischoff> JoeyA: have you tried that patch recently? I have a head version of cabal built, so in theory I could give it a shot
12:32:33 <Cale> JoeyA: Well, sure, but it's the instance which the Prompt machinery helps with more than the typeclass operations
12:32:47 <JoeyA> jfischoff: Not recently; you will have to tweak stuff to get it to work.
12:32:58 <JoeyA> Isn't cabal hosted on github now?
12:32:59 <Cale> JoeyA: In fact, you might still have everything you just mentioned and use Prompt to construct an instance quickly.
12:33:01 <Taneb> How does template haskell work on the inside?
12:33:04 <JoeyA> (the cabal package, that is)
12:33:24 <Taneb> Does it compile the bits in the templates, then run them, until there's no templates left to expand?
12:33:48 <Cale> JoeyA: Basically it just lets you put all the implementation of the primitives into the 'run' function for your monad, and gives you a data representation of your actions for free.
12:33:49 <JoeyA> Yeah.  The links aren't up to date on hackage, it seems: http://www.haskell.org/cabal/code.html
12:34:56 <k0ral> zaphix: thank you for your answer
12:35:35 <zaphix> k0ral: np, it's been a while since i've used it but let me know if you have any questions and i might be able to help you out
12:36:05 <JoeyA> Cale: Right.  The main advantage I see is that you can execute the prompts anywhere you want.
12:37:28 <JoeyA> With the MonadFoo class, you would instead define a monad that is capable of implementing MonadFoo (use (at least) ReaderT for any dynamic context it needs).
12:38:12 <k0ral> zaphix: I'm already using it
12:38:22 <zaphix> k0ral: ah, ok, cool =)
12:38:22 <k0ral> zaphix: just wondering if GetOpt wouldn't have been simpler
12:38:44 <JoeyA> Oh, one 'run' function.  The advantage there, I suppose, is that the run function can use a _ pattern to handle unhandled cases and such.
12:39:46 <JoeyA> Another alternative to Prompt and MonadFoo (and this is a pretty crummy one) would be a record of callbacks that run in some monad.
12:40:22 <cwp> testing
12:40:23 <JoeyA> That's pretty much what the compiler turns MonadFoo into internally, though.
12:40:30 <geekosaur> k0ral, GetOpt has some annoyances, so there are a lot of alternative packages that try to address them.  in my experience they *all* suck in one way or another
12:40:54 <JoeyA> But I've found that for handling events, I prefer case matching on data constructors to implementing callback functions.
12:41:16 <geekosaur> root problem being that options are things that, strictly speaking, belong in IO but *feel* like they should be static (because they are in the context of a given run)
12:41:33 <geekosaur> and, well, option parsing is always a bit idiosyncratic
12:41:46 <k0ral> right
12:42:01 <JoeyA> Cale: So I suppose the main benefit of Prompt is: you don't have to implement a monad to run prompts.
12:42:30 <JoeyA> Instead, you can say: runFoo :: FooEnv -> PromptFoo a -> IO (a, FooState)
12:43:01 <JoeyA> whoops, throw a FooState -> in there.
12:43:26 <JoeyA> Since runFoo interacts with the FooEnv and FooState a lot, it might not help to use ReaderT and StateT.
12:44:40 <Cale> Another nice thing is that you're guaranteed to have a good Monad instance, whereas if you're implementing your own return and bind, you might mess it up somehow.
12:45:17 <JoeyA> But if you end up changing it to runFoo :: FooPrompt a -> StateT FooState (ReaderT FooEnv IO) a, then I argue that the typeclass approach is simpler.
12:45:52 <tac-tics> Prompt feels like a very natural way to define client-server-looking monads.
12:46:02 <diego_diego> Hi, anyone here tried using haskell in a fastcgi environment with nginx?
12:46:11 <JoeyA> Cale: But you're also guaranteed to have a good Monad instance if you stick to good monad transformers, no?
12:46:25 <Cale> yes, that's true
12:46:28 <JoeyA> At some point, you have to get dirty and do IO.
12:46:47 <Cale> But you're also quite a lot more restricted in terms of the operations which you can implement with only pre-existing monad transformers.
12:47:05 <Cale> Not necessarily inside your monad.
12:47:14 <JoeyA> Good point.
12:47:16 <Cale> (your monad might have nothing to do with IO)
12:47:25 <diego_diego> It's not so much having to do with haskell but unix generally. I'm using spawn-fcgi to try to spawn the haskell process, and I can't seem to get it to bind to a socket or an ip:port pair...
12:48:11 <JoeyA> I wish Haskell had an extension that can derive GADTs from type classes.
12:49:09 <JoeyA> That is, given a type class, generate a corresponding GADT whose data constructors have the same signatures as the class methods, capitalizing function names.
12:49:33 <JoeyA> (though I wouldn't be surprised if this can be done with GHC generics or something)
12:50:32 <JoeyA> Cale: Thanks for enlightening me.
12:51:12 <Cale> JoeyA: Also, you might have a monad whose operations could both be implemented in terms of IO and purely
12:51:26 <Cale> and MonadPrompt would let you just define two different run functions for that same monad
12:51:43 <Cale> one which produced an IO action, and one which operated in some way on pure data
12:51:58 <JoeyA> Cale: You can do that with the typeclass approach, too.  Just define two instances, one for the IO version, and one for the pure version.
12:52:47 <Cale> I suppose so, yes.
12:53:30 <Cale> I can't think of a case where you'd need to lambda-bind the actions themselves and lose the polymorphism anyway.
12:56:30 <JoeyA> Aww, too bad GHC can't automatically derive an instance for this: newtype AnyState s a = AnyState { runAnyState :: forall m. MonadState s m => m a } deriving (MonadState)
12:56:57 <JoeyA> So you can say foo :: a -> b -> AnyState s instead of foo :: MonadState s m => a -> b -> m s
12:58:19 <JoeyA> err, AnyState s c
12:58:37 <cwp> what is the command to end to channel?
12:58:39 <Cale> JoeyA: It's not only impossible to automatically derive an instance for that
12:58:45 <cwp> spell: end -> send
12:58:46 <Cale> It's also impossible to write one by hand.
12:59:07 <JoeyA> Having AnyState isn't entirely equivalent to using contexts, e.g.: modifyM :: (s -> AnyState s s) -> AnyState s ()
12:59:08 <Yarou> cwp: PRIVMSG
12:59:14 <Cale> (think about how (>>=) would have to work)
12:59:33 <JoeyA> modifyM can't be used for any MonadState, but the resulting computation can.
12:59:49 <JoeyA> Cale: I'll try to write an instance.
13:00:02 <JoeyA> (it's not existential quantification, it's rank-2)
13:00:10 <Cale> oh
13:00:11 <Cale> oops
13:00:12 <Cale> yeah
13:00:39 <Cale> Okay then, it should be possible :)
13:01:43 <JoeyA> Because GHC can't make the derivation automatically, the MonadFoo approach loses one point.
13:02:12 <eacameron> I'm running a filter on (sequence (replicate n myList))...but it doesn't seem that the memory is being freed from the sequence or something....my machine screeches to a halt...anyone dealt with this before?
13:02:23 <JoeyA> With Prompt, you can just say: type FM = Prompt FooPrompt
13:02:28 <JoeyA> And write your code in the FM monad.
13:03:02 <tac-tics> Isn't existential quantification encoded as rank-2 universal quantification?
13:03:20 <bitonic> tac-tics: no
13:03:27 <bitonic> they're completely different
13:03:59 <JoeyA> data Foo = forall a. Show a => Foo a -- existential quantification
13:04:06 <tac-tics> bitonic: I'm pretty sure I remember that from TaPL
13:04:06 <bitonic> god how much I whish that they bothered adding an `exists' keyword
13:04:15 <cwp> what is the irc command to send to channel?
13:04:16 <JoeyA> data Foo = Foo (forall a. Show a) -- rank-2
13:04:48 <JoeyA> the former means: a Foo value has some unknown type with a Show instance.
13:04:54 <bitonic> tac-tics: I read that too, and I don't remember that. And I'd be surprised, because higher ranked types and existential types have little to do with each other, and are not functional equivalent.
13:05:06 <JoeyA> The latter means: the value under the Foo can be used as *any* type with a Show instance.
13:05:29 <cwp> fromfreenode
13:05:45 <JoeyA> The latter is kinda ludicrous.  undefined is the only type I can think of that satisfies it.
13:05:47 <Saizan> exists a. T a ~~ forall r. (forall a. T a -> r) -> r
13:05:48 <tac-tics> bitonic: I actually wanted to go back and read that chapter the other night.
13:05:49 <JoeyA> err, only *value*
13:06:08 <tac-tics> Saizan: That is pretty much the encoding I'm thinking of
13:06:11 <bitonic> Saizan: oh damn! really!
13:06:26 <JoeyA> eacameron: sequence (without a _) leaks memory by necessity in a strict monad.
13:06:26 <bitonic> can you express one in terms of the other in haskell?
13:06:45 <tac-tics> bitonic: The lambda is truly almighty, after all.
13:07:01 <Saizan> yeah, you can use the RHS i've just given
13:07:32 <JoeyA> eacameron: It's fine in the list monad (I think), but in IO (for example), it has to run all the IO actions that build up the list *before* the list can be used.
13:07:37 <tac-tics> bitonic: Pierce says in TapL (in the answers section), that encoding universal quantification using existential quantification is unknown to him
13:08:03 <eacameron> JoeyA: I'm using it in the list Monad
13:08:14 <bitonic> Saizan: yeah, but if I wanted to encode existential quantification with higher ranked types in an Haskell data declaration, could I do that?
13:08:17 <eacameron> JoeyA: I just want all combinations of a particular list
13:08:35 <JoeyA> eacameron: Are you running in ghci, or a compiled program?
13:08:38 <bitonic> tac-tics: I repent! sorry about the misinformation then
13:08:45 <eacameron> JoeyA: both
13:08:51 <JoeyA> Did you try -O2 ?
13:08:54 <tac-tics> heh, I don't know why I asked, if I knew the answer :P
13:08:56 <JoeyA> (compile with optimization)
13:09:03 <Saizan> bitonic: yes
13:09:14 <tac-tics> But it turned into a learning moment, so all is well
13:09:23 <eacameron> JoeyA: yeah :(
13:10:58 <bitonic> Saizan: ok, so lets say I wanted to emulate `data T = exists a. T a'. Can you write a type T1 that uses only higher ranked types, and conversion functions between T and T1?
13:11:43 <Saizan> bitonic: hard to say because T is not valid
13:12:03 <eacameron> JoeyA: I've asked about this a long time ago. the code is here https://github.com/3noch/square1/blob/master/haskell/square1.hs
13:12:22 <Saizan> bitonic: maybe you can rephrase in agda?
13:12:22 <bitonic> Saizan: what do you mean? it is valid haskell (with forall instead of exists)
13:12:38 <Saizan> bitonic: ah, ok, with forall
13:12:40 <JoeyA> eacameron: What version of GHC?
13:12:43 <eacameron> JoeyA: from what I can tell, it seems like sequence isn't being lazy enough ;)
13:12:49 <eacameron> JoeyA: 7.4.2
13:12:53 <tac-tics> Isn't "exists" in Haskell just a synonym for "forall"?
13:12:55 <Saizan> bitonic: btw the forall there is because T :: forall a. a -> T
13:13:26 <bitonic> Saizan: ah, that's interesting, thanks.
13:13:43 <dmwit> data T = T (exists a. a) -- is a better analogue of data T = forall a. T a than data T = exists a. T a
13:14:03 <bitonic> dmwit: true
13:15:06 <bitonic> I remember trying to do that, and failing miserably
13:16:06 <dmwit> to (T v) f = f v
13:16:42 <JoeyA> eacameron: I don't know why it's leaking memory, but you could try writing a simpler program involving (sequence . replicate n) to try to isolate the issue.
13:17:13 <bitonic> dmwit: I was asking for a `T -> T1', and I don't know what T1 is from that
13:17:16 <Saizan> bitonic: http://hpaste.org/70282
13:17:51 <Saizan> tac-tics: there's no exists in haskell
13:18:20 <tac-tics> I could swear I've seen it. Huh.
13:18:41 <tac-tics> There does not exist a keyword k in Haskell such that k = exists.
13:19:18 <bitonic> Saizan: thanks
13:19:46 <bitonic> my new motto: often in error, never in doubt
13:20:10 <Saizan> i thought that was your old motto too :)
13:20:43 <bitonic> Saizan: I never put it in words. but yes. always been
13:21:03 <bitonic> and if I did put it in words, refer to the motto.
13:21:49 <JoeyA> eacameron: Here's a simpler example that leaks memory: main = mapM_ putStrLn [s | s <- sequence (replicate 10 "hello")]
13:22:47 <tac-tics> bitonic: I would also adopt this motto
13:23:26 <eacameron> JoeyA: Yeah...I was actually just doing that. My simpler program just did random computations on numbers and then filtered ones that == 2. ghci crashed when I tried computations of 500 steps... :(
13:23:42 <bitonic> tac-tics: ehe. I'm particularly bad, because I say these things so confidently. there should be "don't trust bitonic" in the chan status
13:23:55 <eacameron> JoeyA: Maybe I sequence is dumb and refers to its previously generated items???
13:24:08 <JoeyA> @src sequence
13:24:08 <lambdabot> sequence []     = return []
13:24:09 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:24:09 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
13:25:35 <tac-tics> bitonic: My general strategy is talk loudly and make a lot of statements without regard to their validity.
13:25:38 <eacameron> JoeyA: so thats a "no" eh?
13:25:43 <JoeyA> sequence [] = [[]]; sequence (x:xs) = [v:vs | v <- x, vs <- sequence xs]
13:25:50 <JoeyA> (as defined for the List monad.
13:25:50 <tac-tics> bitonic: You end up learning a whole lot when people correct your ignorant statements :)
13:25:56 <matthiasgorgens> If I want to give a type declaration in a where clause, is there some way to re-use the type variables introduces in the outer scope?
13:26:07 <JoeyA> matthiasgorgens: ScopedTypeVariables
13:26:13 <ion> joeya: And all monads with MonadComprehensions. :-)
13:26:24 <JoeyA> First, enable that extension by adding this to the top of your module: {-# LANGUAGE ScopedTypeVariables #-}
13:26:34 <JoeyA> Then say foo :: forall a b. a -> b -> ...
13:26:56 <bitonic> tac-tics: that's true... I still hate this about myself, I just can't help believing the scheme of things in my brain
13:26:58 <matthiasgorgens> I already had that extention enabled.
13:27:01 <JoeyA> Then in type signatures under foo, 'a' and 'b' will refer to the types in foo's signature.
13:27:06 <matthiasgorgens> let's see if I can figure out how to use it.
13:27:19 <dmwit> matthiasgorgens: You need to use explicit "forall"s to bind variables.
13:27:21 <JoeyA> matthiasgorgens: You need the forall to make it work.
13:27:30 <matthiasgorgens> JoeyA: ok, I'll try the explicit foralls.
13:27:52 <dmwit> (Except in a handful of places like class declarations, where forall's are illegal; these are always bound.)
13:27:55 <matthiasgorgens> seems to have worked!
13:28:05 <matthiasgorgens> thanks!
13:28:55 <dmwit> eacameron, JoeyA: I don't know what we're talking about, but replicateM n = sequence . replicate n is a handy abbreviation.
13:29:37 <JoeyA> dmwit: The issue is a space leak.
13:29:56 <JoeyA> Namely, this leaks memory: main = mapM_ putStrLn [s | s <- sequence (replicate 10 "hello")]
13:30:08 <cwp> if i want to send a message to the channel, anyone know what i should put? i f i do (write handle "JOIN" "#haskell")  to join #haskell what do i do to send a message to #haskell?
13:30:26 <eacameron> JoeyA: yeah...if you look at my code. this kills your memory: last $ pathsOfLen 50
13:30:28 <dmwit> [s | s <- foo] is better spelled foo
13:31:12 <JoeyA> [s | s <- foo] is the UK spelling (snicker snicker)
13:31:28 <avpx> No, I'm pretty sure it's foough
13:31:36 <JoeyA> heh
13:33:30 <eacameron> JoeyA: soo...the question is ... how do I get rid of this horrendous space leak? it seems like a simple enough job of the gc but I must not being doing it correctly
13:35:25 <rwbarton> eacameron: are you building with optimizations enabled?
13:35:35 <dmwit> The problem is that replicateM 100 "hello" is actually ['h':replicateM 99 "hello", 'e':replicateM 99 "hello", 'l':replicateM 99 "hello", 'l':..., 'o':...], and all the ...'s are shared.
13:35:42 <dmwit> rwbarton: doesn't make a difference
13:35:45 <dmwit> (I checked.)
13:35:45 <rwbarton> why are they shared
13:35:51 <eacameron> rwbarton: -O2
13:35:56 <rwbarton> try -O0
13:36:03 <eacameron> first hint: http://stackoverflow.com/questions/3190098/space-leak-in-list-program
13:36:23 <dmwit> They're shared because of the implementation of sequence...
13:36:35 <dmwit> ?src sequence
13:36:35 <lambdabot> sequence []     = return []
13:36:35 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:36:35 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
13:36:45 <dmwit> vs <- sequence xs -- vs is shared among all choices of v
13:36:51 <rwbarton> no...?
13:36:56 <dmwit> no?
13:37:22 <rwbarton> "sequence xs" is in a position where syntactically it could depend on v, so a naive implementation would recompute it for each value of v
13:38:08 <adimit> I want to make a 2D array from a list [[a]]. The best I could come up with was this:
13:38:15 <adimit> >  let ls = ["abc","def","gh"] in [ [ ((x,y),e) | e <- l | y <- [0..] ] | l <- ls | x <- [0..] ]
13:38:17 <lambdabot>   [[((0,0),'a'),((0,1),'b'),((0,2),'c')],[((1,0),'d'),((1,1),'e'),((1,2),'f')...
13:38:44 <adimit> and read that into an array with (array . concat)
13:39:00 <adimit> is there a better/more idiomatic way?
13:39:06 <avpx> adimit: That's certainly one way to do it. I prefer to use zip
13:39:23 <avpx> adimit: Flatten the list out and then zip it with the coordinates you want each element to have
13:39:41 <adimit> avpx: dunno, I was scared of the constant tuple construction-deconstruction. Though flattening the list beforehand is actually interesting.
13:39:42 <dmwit> rwbarton: concatMap (\v -> concatMap (\vs -> [v:vs]) (sequence xs)) x -- no? surely "sequence xs" is shared here?
13:39:50 <dmwit> rwbarton: It's just a plain old closure...
13:39:54 <rwbarton> adimit: if you know that you have every cell of the array represented you can just use listArray . concat
13:40:18 <adimit> avpx: not all lists in the first dimension have the same number of elements though.
13:40:22 <adimit> rwbarton: I don't :-(
13:40:32 <rwbarton> i see
13:41:17 <rwbarton> dmwit, don't you expect that (\v -> complicatedExpression) will evaluate complicatedExpression every time it is entered while (let x = complicatedExpression in \v -> x) will not
13:41:33 <rwbarton> regardless of whether complicatedExpression actually mentions v?
13:41:46 <rwbarton> I mean, of course the optimizer may do whatever.
13:41:51 <rwbarton> But that's always my default assumption
13:42:02 <dmwit> um
13:42:30 <rwbarton> lifting computations out of lambdas is an optimization
13:42:35 <rwbarton> constant computations
13:43:02 <rwbarton> don't in fact people sometimes exactly write \() -> complicatedExpression in an effort to not store the result of complicatedExpression
13:43:07 <avpx> > let coords = [(x,y) | x <- [0..2], y <- [0..2]] in zip coords "abcdefgh"
13:43:09 <lambdabot>   [((0,0),'a'),((0,1),'b'),((0,2),'c'),((1,0),'d'),((1,1),'e'),((1,2),'f'),((...
13:43:10 <dmwit> You make a compelling argument.
13:43:27 <rwbarton> but you said it still leaked with -O0?
13:43:42 <dmwit> yes
13:43:44 <avpx> adimit: That's my solution, would that work?
13:43:45 <rwbarton> hmm
13:43:46 <tgeeky> dmwit: (totally not related to this conversation): Have you ever seen this definition of a Heap? The "Whereas the automorphisms..." part (before the Contents box) is nice
13:43:50 <tgeeky> http://en.wikipedia.org/wiki/Heap_(mathematics)
13:43:50 <adimit> avpx: that only works if you can guarantee all array cells to be filled. Which I can't.
13:44:00 <avpx> I see
13:44:12 <rwbarton> what about -fno-full-laziness or whatever it's calle
13:44:13 <rwbarton> d
13:44:18 <dmwit> rwbarton: For the following definition of "leaks": +RTS -M100M crashes
13:44:29 <adimit> It might not be a bad idea to make a true array of arrays in my case anyway.
13:45:31 <dmwit> still crashes
13:46:02 <rwbarton> maybe because Prelude is compiled with optimizations
13:47:35 <dmwit> tgeeky: This reminds me vaguely of a very weird construction in a book that's sitting on my desk that I could never wrap my head around.
13:47:39 <dmwit> Perhaps now I'll be able to.
13:47:40 <dmwit> thanks
13:48:11 <tgeeky> dmwit: it came up through "power associativity".
13:48:56 <tgeeky> dmwit: what book/construction, if you can remember without wasting time looking it up?
13:49:00 <rwbarton> dmwit: interesting... the original program works fine here with -O0 and +RTS -M100M
13:49:13 <rwbarton> but not with -M50M
13:49:16 <rwbarton> maybe because 32 bit
13:49:23 <rwbarton> okay
13:49:26 <yert> Hello. I am using Error Monad and I want to check for all elements on a list if there would be an error while processing it, how can I do that?
13:49:27 <tgeeky> rwbarton: can you link me to the code?
13:50:08 <rwbarton> main = mapM_ putStrLn $ sequence $ replicate 10 "hello"
13:50:14 <tgeeky> oh. heh
13:50:23 <tgeeky> @src sequence
13:50:23 <lambdabot> sequence []     = return []
13:50:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:50:23 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
13:51:54 <parcs`> yert: throwError
13:52:30 <dmwit> tgeeky: Group theory and three-dimensional manifolds, by John Stallings
13:52:53 <yert> I think I didn't make myself clear. I have function, which I want to call on all the list elements to see if it will return an error
13:53:10 <rwbarton> this version is fine
13:53:14 <dmwit> yert: You can use sequence to process them all and keep the first error or foldr (<|>) to process them all and keep the first success.
13:53:33 <hpaste> rwbarton pasted “sequence” at http://hpaste.org/70283
13:54:08 <yert> Thank you.
13:54:30 <rwbarton> oh
13:54:41 <rwbarton> i have sequence' calling sequence "recursively" :P
13:54:42 <Wooga> hi, is there any haskell libraries for working with unix pseudo-terminals?
13:54:49 <bgamari> @seen cdsmith
13:54:50 <lambdabot> Unknown command, try @list
13:55:01 <Wooga> i ultimately want to write own ttyrec-like application
13:55:09 <Wooga> recording all what happens in terminal to the file
13:55:54 <hpaste> rwbarton annotated “sequence” with “sequence (fixed)” at http://hpaste.org/70283#a70284
13:56:25 <rwbarton> > 5^10
13:56:26 <lambdabot>   9765625
13:56:50 <rwbarton> with -O2 that one leaks
13:56:57 <rwbarton> so, the performance of that code makes sense to me
13:57:11 <dmwit> rwbarton: Oh, I also used replicateM 1000. =P
13:57:21 <rwbarton> ah :)
13:57:42 <rwbarton> yeah, 50M is really close to the amount that it would leak with replicateM 10
13:57:43 <dmwit> (...I was sitting here wondering how you could manage to complete any version of this program... you must have a supercomputer!)
13:59:10 <rwbarton> if I use the definition of sequence in that SO answer, I get the same behavior (leaks with -O2, doesn't leak with no optimization flag)
13:59:12 <dmwit> But yes, even manually implementing sequence/replicateM as you outlined in your paste and compiling with -O0, I still get a space leak (now defined as crashing with -M1000M on a replicateM 1000 thing).
13:59:25 <dmwit> Oh, what SO answer?
13:59:43 <rwbarton> http://stackoverflow.com/questions/3190098/space-leak-in-list-program
14:00:03 <rwbarton> but if I use the *actual* definition of sequence then I do get a leak always
14:01:39 <rwbarton> just translating the list comprehension to do notation is enough to cause the leak
14:02:45 <dmwit> This is an unusually finicky program.
14:03:03 <rwbarton> .... or maybe not
14:03:15 <eacameron> dmwit: rwbarton: I'm watching your discussion...understanding 1/10 of it... ;)
14:03:17 <rwbarton> must not have tested what i thought i was testing
14:04:06 <dmwit> eacameron: Heck, that's better than me. =P
14:04:27 <hpaste> adimit pasted “Type conflict” at http://hpaste.org/70285
14:04:29 <adimit> I'm having a problem with type signatures. Basically, I define a function with a type variable a, and I need to further specify a type of an array with in the function body which stores something of type a, and that needs an explicit type signature.
14:04:39 <rwbarton> oh, duh, ok
14:04:45 <rwbarton> the real definition:
14:04:51 <adimit> The example I pasted is basically the minimal example I could come up with that exhibits the problem.
14:04:53 <rwbarton> sequence ms = foldr k (return []) ms where k m m' = do { x <- m; xs <- m'; return (x:xs) }
14:05:06 <rwbarton> ^ this won't recompute the recursive call as it is passed through the name m'
14:05:19 <geekosaur> adimit, shouldn't it be automatic in your minimal example?  x is already of type a
14:05:28 <dmwit> oh man, yes
14:05:54 <geekosaur> you can in any case use asTypeOf, or in complex cases you can use the ScopedTypeVariables extension
14:05:56 <adimit> geekosaur: yes, it should be, but it isn't in my non-minimal example, where I need to further specify the type of the array, because otherwise GHC can't figure it out.
14:06:02 <tgeeky> @src sequence
14:06:03 <lambdabot> sequence []     = return []
14:06:03 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:06:03 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
14:06:06 <cwp> if i want to send a message to the channel, anyone know what i should put? i f i do (write handle "JOIN" "#haskell")  to join #haskell what do i do to send a message to #haskell?
14:06:31 <dmwit> that -- OR: is subtly different in the sharing sense!
14:06:45 <rwbarton> yes, even more subtle there
14:06:48 <tgeeky> dmwit: when you say crashing is defined as: -M1000M, etc, you mean that when you run it, it actually uses all 1000MB?
14:07:06 <dmwit> cwp: Read the wiki page on writing your own bot, or, preferably, read the IRC spec.
14:07:16 <dmwit> It's pretty readable.
14:07:33 <dmwit> tgeeky: Yes, it uses 1000MB and then ends with a runtime message like "heap exhausted".
14:07:47 <tgeeky> dmwit: oh, I missed that! thanks.
14:07:50 <barrucadu> adimit: Are you saying that GHC gives you an error on f :: [a] -> a; f (x:xs) = x ?
14:08:13 <adimit> barrucadu: yes.
14:08:30 <adimit> if I specify the type of x as x::a
14:08:46 <geekosaur> right, you need ScopedTypeVariables for that
14:08:54 <dmwit> adimit: Turn on ScopedTypeVariables and write "f :: forall a. [a] -> a".
14:09:00 <adimit> geekosaur: but I do have them!
14:09:08 <adimit> dmwit: ah, I didn't know I'd need the quantifier.
14:09:10 <adimit> thanks!
14:09:11 <geekosaur> see what dmwit said
14:09:24 <geekosaur> the quantifier acts as a "local" declaration in this case
14:09:36 <bitonic> Saizan: I've been experimenting with higher ranked types and all the operations I do with existential are easily done. Why do we have existentials at all?
14:10:17 <bitonic> they've got much weirder rules - e.g. the ones about pattern matching
14:10:18 <adimit> now it works. Thanks!
14:10:37 <Saizan> bitonic: for the same reason we don't write code in continuation passing style most of the time
14:11:05 * geekosaur did assume that you'd read how to use the extension; the documentation makes it reasonably clear that you need to declare which type variables are to be held in scope instead of being available for use
14:11:42 <cwp> linking wxHaskell is very very slow
14:11:51 <Saizan> or, why we have tuples when they can be church encoded :)
14:11:56 <adimit> geekosaur: I don't even know where the docs for the extension live (and I used ScopedTypeVariables for something else in the same source file, so that's why it was turned on, so I didn't know ScopedTypeVariables was what I needed.)
14:12:13 <bitonic> Saizan: mhm... for some reason in this case the lambda version seems *more* bearable.
14:12:44 <eacameron> dmwit: rwbarton: so is that the solution? `sequence ms...`?
14:12:54 <adimit> geekosaur: now I've googled for these docs, and know where they are ;-)
14:13:01 <eacameron> dmwit: rwbarton: why does Prelude have crappy leaky functions like this?
14:13:33 <bitonic> Saizan: anyway, it all seems so obvious now...
14:13:58 <rwbarton> well in general there is a time/space tradeoff
14:14:26 <rwbarton> if Prelude had the other version of sequence someone would ask "why does Prelude have crappy functions that unnecessarily recompute values"
14:14:40 <cwp> can u see projirc in the memberlist?
14:15:04 <eacameron> rwbarton: ohh...makes sense
14:15:11 <cwp> if i want to send a message to the channel, anyone know what i should put? i f i do (write handle "JOIN" "#haskell")  to join #haskell what do i do to send a message to #haskell?
14:15:19 <rwbarton> @google IRC haskell
14:15:21 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
14:15:21 <lambdabot> Title: IRC channel - HaskellWiki
14:15:30 <rwbarton> oops
14:15:35 <cwp> isnt it /MSG #channel "msg" ?
14:15:36 <rwbarton> @google how to write an IRC bot in Haskell
14:15:38 <lambdabot> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
14:15:38 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
14:16:31 <ben> @google how to write an IRC bot in haskell with conduit
14:16:33 <lambdabot> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
14:16:33 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
14:16:42 <Clint> simpleirc isn't bad
14:16:43 <ben> @google how to write an IRC bot in haskell with pipes
14:16:45 <lambdabot> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
14:16:45 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
14:16:53 <rwbarton> If only that was how @google worked.
14:16:56 <ben> I think lambdabot might be biased
14:21:13 <adimit> if only search engines were actual question-answering machines.
14:21:54 <companion_cube> isn't it AI-complete? :)
14:22:12 <NemesisD> why is alex always such a pain in the ass dependency
14:22:14 <monochrom> http://www.multivax.com/ :)
14:24:04 <NemesisD> i'm trying to install some dependencies with cabal-dev and it complains that the alex >= 2.3 depedency is missing. i have it installed at the user level and with cabal-dev
14:26:55 <favonia> @google irc protocol message format
14:26:57 <lambdabot> http://www.irchelp.org/irchelp/rfc/chapter2.html
14:26:57 <lambdabot> Title: RFC 1459
14:27:04 * hackagebot postgresql-simple 0.2.0.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.2.0.1 (LeonSmith)
14:28:38 <pcavs> What's an example of a type with kind * -> * that one cannot write an instance of Functor for without using undefined?
14:30:22 <projirc> hello im a gui written in haskell
14:30:27 <projirc> hello im a gui written in haskell
14:31:23 <c_wraith> Hmm.  you might have some bugs
14:32:25 * Clint chuckles.
14:33:17 <mcnster> gm :)
14:33:17 <NemesisD> i have haskell-platform now and the alex thing persists
14:34:18 <Saizan> NemesisD: is it in your $PATH ?
14:38:09 <monochrom> alex is an executable. executables are not "managed".
14:39:10 <monochrom> it is why when I build haskell-platform, I tell it to --prefix=/usr/local/haskell-platform-1912.06.23 . then I just edit PATH.
14:40:07 <projirc> hello im a gui written in haskell
14:40:12 <projirc> im a processed textfield
14:40:20 <projirc> im a processed textfield
14:40:30 <cwp> weee!
14:41:31 <monochrom> why is there a repetition?
14:42:06 <rwbarton> in case one message is lost
14:42:08 <NemesisD> Saizan: yes. i do which alex and i get /usr/bin/alex
14:42:25 <NemesisD> how would it even determine what version of alex was installed
14:43:24 <monochrom> /usr/bin/alex would be the doing of your linux distro, unless you knowingly did --prefix=/usr
14:44:12 <monochrom> "alex --version" probably tells the version number
14:44:15 <NemesisD> monochrom: its from haskell-platform
14:44:33 <NemesisD> monochrom: yeah but is cabal actually calling the executable alex --version and parsing out the version?
14:44:39 <monochrom> yes
14:44:56 <monochrom> and cabal respects PATH
14:44:56 <NemesisD> monochrom: and in any case, the version from my system says 2.3.5
14:45:40 <hpaste> NemesisD pasted “alex and cabal-dev” at http://hpaste.org/70286
14:46:31 <NemesisD> ah ok i took it out of my .cabal file. that was a desperation move when i was troubleshooting this earlier
14:55:08 <teneen> I want to give a default definition for an associated type in terms of other associated types. Is this possible?
14:55:23 <hpc> try it
14:55:57 <hpc> should just be a matter of replacing <type> <params> with <type> <params> = <defn>
14:56:20 <teneen> hpc: It tells me that type XX is not in scope
14:56:52 <teneen> is not a visible associated type
14:58:25 <hpc> hmm
14:58:42 <teneen> class Num a => G a where {type C a = Int; type B a = Integral a => C a; f :: a -> B a}
14:59:07 <teneen> sorry  it is --->   class Num a => G a where {type C a; type B a = Integral a => C a; f :: a -> B a}
15:00:11 <hpc> depending on how you intend B to be defined, you could try doing
15:00:47 <hpc> class Num a => G a where type C a; type B a = Integral a; f :: B a => a -> C a
15:01:03 <hpc> {-# LANGUAGE ConstraintKinds #-}
15:02:13 <teneen> hpc: I do not want to add constraints in the function
15:04:06 <teneen> hpc: your code also does not work
15:04:20 <teneen> hpc: I tried it on ghci 7.4.2
15:07:01 <hpc> i suppose you can't, then
15:07:31 <teneen> hpc: It's not possible to give default definitions for associated types at all?
15:08:57 <cwp> anyone good with wxHaskell? i have a textfield, textCtrl and i want to get the text in it but i cant infd out how. http://hackage.haskell.org/packages/archive/wx/0.12.1.6/doc/html/Graphics-UI-WX-Controls.html
15:10:54 <geekosaur> cwp, it's of class Textual, which points to the Text attribute
15:12:20 <geekosaur> sorry, "text" attribute
15:12:24 <geekosaur> lowercase
15:13:11 <geekosaur> so, the usual wxwidgets thing:  get myWidget text
15:13:12 <cwp> @faq karma
15:13:12 <lambdabot> The answer is: Yes! Haskell can do that.
15:13:21 <cwp> > @faq karma
15:13:22 <lambdabot>   <no location info>: parse error on input `@'
15:13:38 <cwp> @hoogle add
15:13:38 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
15:13:39 <lambdabot> Foreign.ForeignPtr addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()
15:13:39 <lambdabot> Foreign.Concurrent addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
15:15:52 <cwp> @geekosaur still, i dont understand how to get the text
15:15:52 <lambdabot> Unknown command, try @list
15:16:16 <geekosaur> [21 22:12] <geekosaur> so, the usual wxwidgets thing:  get myWidget text
15:16:20 <cwp> oh i dditn see your later post
15:20:10 <hpaste> cwp pasted “get text” at http://hpaste.org/70288
15:20:50 <cwp> @geekosaur ^^ i dont get how to do i there because it seems to need a variable in its own "definition"
15:20:50 <lambdabot> Unknown command, try @list
15:22:29 <jfischoff> for something cabal-dev is not ignoring the global package-conf database on my coworkers computer with the newest haskell platform. I am using a straight ghc install and its working fine. Any ideas?
15:23:48 <geekosaur> cwp, add the handler afterward with set
15:24:08 <cwp> but it needs the processEnter
15:26:27 <jfischoff> how does one hide the global package database?
15:27:03 <donri> jsgf: maybe GHC_PACKAGE_PATH=
15:27:25 <jfischoff> okay I'll give it a show
15:27:34 <donri> jsgf: oh, for cabal-dev? --reinstall-dependencies or something like that might help
15:27:44 <donri> jsgf: sorry
15:27:46 <donri> jfischoff: you!
15:27:50 <jfischoff> hehe
15:27:50 <geekosaur> cwp, I do not understand your complaint
15:28:05 <jfischoff> I would rather it just ignore it
15:28:15 <jfischoff> like it does with the user database
15:28:35 <donri> jfischoff: well, the effect of ignoring is installing dependencies even when they're already in the database?
15:28:47 <hpaste> geekosaur annotated “get text” with “get text (annotation)” at http://hpaste.org/70288#a70289
15:29:00 <donri> jfischoff: the flag is --upgrade-dependencies btw
15:29:06 <jfischoff> I have all of the sources check into a third party folder locally
15:29:24 <jfischoff> I don't want to use hack age or the anything installed on the users computer
15:29:42 <donri> jfischoff: i hear cabal-meta is good for that sort of thing, maybe
15:29:56 <jfischoff> at some point I'll check that out
15:30:51 <cwp> geekosaur : i dont get how to create the handler outside. how do i define a handler? and i cant add a handler to a widget list
15:31:09 <geekosaur> see my paste above
15:31:37 <geekosaur> also, I think you need to sit down and actually read the wxwidgets documentation; the channel can't write your program for you
15:33:16 <monochrom> actually the channel is happy to write the program, but the channel is probably not happy to read the wx doc :)
15:34:30 <geekosaur> not repeatedly at least.  wx is very regular, the same mechanisms and forms come up again and again
15:36:07 <monochrom> then a program can be written to write those programs... :)
15:36:25 * monochrom awakens Turing for help on that
15:42:23 <yert> w
15:44:16 <mekeor``> @where hr
15:44:16 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
15:44:22 <mekeor``> is this nice?
15:44:56 <strager> @pl a x ++ b y
15:44:56 <lambdabot> a x ++ b y
15:45:14 <strager> @pl \x y -> a x ++ b y
15:45:14 <lambdabot> (. b) . (++) . a
15:47:53 <Botje> @pl \(x,y) -> a x ++ b y
15:47:53 <lambdabot> uncurry ((. b) . (++) . a)
15:48:00 <Botje> awwh, no arrow?
15:48:49 <cwp> yes but i need to somehow know the textCtrl when i call the handler. so i dont get bhow to write the handler, is there a handler type?
15:51:05 <cwp> processEnter :: Styled w => Attr w BoolSource
15:51:05 <cwp> Process enter key events, used in a comboBox or textCtrl and catched using a on command handler. (otherwise pressing Enter is either processed internally by the control or used for navigation between dialog controls).
15:52:07 <cwp> i need something like enterHandler :: textCtrl -> HandleMV -> String¨
15:58:32 <geekosaur> cwp, did you read my paste?  I referred to the control in the handler that I used "set" to assign
15:58:52 * lispy waves
16:00:13 <geekosaur> and I would expect your handler is (on processEnter := ...) in the same way that I did (on command := ...)
16:04:49 <gzmask> is it just me? My experience of cabal install *** on OSX has been rough : (
16:06:51 <jfischoff> its not just you
16:07:14 <jfischoff> the number of things that can go wrong is high
16:07:52 <gzmask> only for OSX or overall?
16:08:05 <jfischoff> overall
16:08:55 <jfischoff> it probably goes linux, OSX, windows in terms success likelihood
16:10:18 <gzmask> is it cause by bitrotten dependencies or things like A requires B-1.1, C requires B-1.2 sort of conflicts?
16:11:10 <jfischoff> I think is a mixture of things, some I am still beginning to understand as I run into new problems.
16:11:45 <jfischoff> there are old packages that break on new compilers
16:11:50 <jfischoff> which is pretty easy to fix
16:12:38 <gzmask> you should be able to use multi-version of compilers?
16:13:58 <jfischoff> no, I think it is okay that stuff breaks
16:14:12 <jfischoff> the issue is more that the community is small
16:14:23 <jfischoff> and important packages are not always well maintained
16:15:11 <gzmask> I am pretty sure the community is growing rapidly recently.
16:15:55 <gzmask> after ppl done with ruby, python, js, they start to look for new toys. Like myself
16:16:27 <jfischoff> and things are getting better. Cabal is actually relatively new.
16:16:49 <projirc> hello im a gui written in haskell
16:16:57 <projirc> Write something
16:17:04 <projirc> hello
16:17:16 <jfischoff> I think write people like myself are just starting to do larger scale development with haskell and realize something is wrong with how we are doing package management but don't know the answers
16:17:17 <projirc> thanks geekosaur
16:17:28 <projirc> thanks geekosaur
16:17:31 <projirc> thanks geekosaur
16:18:04 <gzmask>  I have the patient to wait for the ecosystem to mature. but yea... i won't be using haskell for anything productions
16:18:25 <pyry`> i have an i'm-struggling-to-comprehend-a-concept question about sockets and whatnot if anyone's willing to field it
16:18:30 <pyry`> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot reading through this
16:19:09 <pyry`> i'm not sure i quite understand yet how i'd handle data read from the server if the socket is held open, and thus what i read is never ended with the socket closing
16:19:41 <jfischoff> gzmask: patient is key. I was early ruby user and it took a long while to get as easy to use as it is now
16:19:55 <jfischoff> gzmask: it will be the same with haskell
16:20:09 <blackdog> slides from my talk on haskell in production from last night: http://mwotton.github.com/hs_gbu/
16:20:19 <Yarou> its ok to be gay i think
16:20:30 <Yarou> the jury's still out on that though
16:21:07 * jfischoff is reading blackdog's slides
16:21:15 <blackdog> gzmask: cabal is essential and broken. it's a hell of a thing.
16:21:19 <copumpkin> Yarou: that is not relevant to this channel
16:21:54 <Yarou> copumpkin: i'm still trying to figure what is relevant to this channel
16:22:04 <copumpkin> it doesn't seem hard
16:22:10 <copumpkin> it's about a programming language called haskell
16:22:12 <geekosaur> you might try what's in the /topic, for starters
16:22:13 <Yarou> right
16:22:14 <copumpkin> you talk about haskell and related topics
16:22:27 <Yarou> yet, why is there so much divergence from the "topic"
16:22:43 <copumpkin> we have common interests in theoretical computer science
16:22:48 <copumpkin> that's also mostly on-topic
16:23:16 <copumpkin> anyway, if you're having trouble with figuring it out, join #haskell-ops and someone can explain
16:23:30 <copumpkin> nobody else seems to have trouble so there's not much point in polluting it for 848 other people :)
16:23:48 <avpx> There are plenty of channels out there to chatter in. Why you chose #haskell is beyond me.
16:23:54 <jfischoff> blackdog: its like you read my mind.
16:24:06 <Yarou> ok, i understand
16:24:10 <blackdog> jfischoff: i'm glad i'm not totally off-base:)
16:24:12 <Yarou> well, i think i am beginning to understand
16:24:19 <Yarou> if i say something three times
16:24:23 <Yarou> it's considered on-topic
16:24:34 --- mode: ChanServ set +o copumpkin
16:24:42 --- mode: copumpkin set +b *!~himuraken@unaffiliated/yarou
16:24:42 --- kick: Yarou was kicked by copumpkin (it isn't that hard)
16:24:45 <blackdog> i think this is a serious issue - i would love to use haskell in prod again, but I would find it hard to justify in most environments.
16:24:48 --- mode: copumpkin set -o copumpkin
16:24:50 <irene-knapp> Just the place for a snark!  I have mentioned it twice.  That alone should encourage the crew.  Just the place for a snark!  I have mentioned it thrice.  What I tell you three times is true.
16:25:56 <hpaste> tsuraan pasted “weird compile error” at http://hpaste.org/70293
16:26:13 <jfischoff> blackdog: I'm still glad that I am using haskell, but I wish I had understand more about managing projects before I started. Would have saved a lot of time
16:26:39 <tsuraan> can anybody give some hints about why ghci is complaining about overlapping instances where both instances are the same one?
16:26:46 <blackdog> jfischoff: feels like it could be worth getting together an interest group about this stuff
16:27:05 <avpx> jfischoff: That's probably the best way to learn project management anyway
16:27:12 <jfischoff> blackdog: agreed. Maybe just coming up with a list of requirements and use cases
16:27:12 <blackdog> almost all of the haskell stuff i see is clever coding/type tricks, rather than the nitty-gritty of a functioning site
16:27:51 <jfischoff> along with comparison to other tools in different environments
16:28:04 <irene-knapp> meh, it works fine for me.  :)  I acknowledge that not everybody enjoys the hassle of deployment, but I don't think the situation is substantially worse than other research languages.
16:28:28 <jfischoff> irene-knapp: agreed. its not the end of the world. its just a pain point
16:28:30 <irene-knapp> yeah
16:28:47 <jfischoff> its growing pains
16:29:22 --- mode: ChanServ set +o copumpkin
16:29:29 --- mode: copumpkin set -b *!~himuraken@unaffiliated/yarou
16:29:42 --- mode: copumpkin set -o copumpkin
16:30:32 <tsuraan> can anybody explain the error I'm getting: http://hpaste.org/70293 ?
16:30:57 <tsuraan> it complains about overlapping instances, but there is only one instance
16:31:26 <irene-knapp> huh, wow
16:31:27 <avpx> Hmm, that is interesting
16:31:29 <irene-knapp> never seen that before
16:31:52 <irene-knapp> what's the definition of StreamID?
16:31:56 <avpx> tsuraan: Any way you could try to come up with a small example of this error?
16:32:20 <tsuraan> newtype StreamID = StreamID ByteString deriving (Eq, Ord)
16:32:29 <irene-knapp> that should be fine, hm
16:32:35 <tsuraan> avpx: I can try
16:32:58 <tsuraan> I'm making a Main now to see if it's a ghci-only error
16:34:42 <geekosaur> there;s a version number on the symbol
16:34:56 <geekosaur> you have two versions of aeson in play and the conflictling instances are probably one for each
16:35:22 <tsuraan> oh, I'll look into that
16:35:24 <blackdog> irene-knapp: yeah, i'm not claiming it's impossible, and if you compare against other research languages it's actually quite good
16:35:41 <blackdog> irene-knapp: but i'm comparing against ruby, because that's the default choice for a startup with very little time on its hands
16:36:08 <tsuraan> ghc-pkg list aeson only shows one aeson package
16:36:26 <irene-knapp> blackdog: yes, fair enough.  but honestly, I'm not sure startups /should/ use Haskell.
16:36:33 <blackdog> i think to some extent we've beaten that whole "haskell is slow" myth, but until it's as easy as ruby to get a small project up in the cloud, we won't get critical mass
16:36:42 <jfischoff> but to be fair ruby has gotten a lot of good tools in the last few years.
16:36:45 <geekosaur> hm.  so why s ghc insisting on a distinguishing version number?
16:36:58 <jfischoff> and I don't think haskell is just a research library
16:37:00 <blackdog> it's an open question :) i might have got things done faster if i hadn't, but I probably wouldn't have been as motivated
16:37:05 <geekosaur> it should only do that when it's the only way it can distinguish between two otherwise identical types
16:37:09 <jfischoff> s /library/ language
16:37:41 <blackdog> and it feels like there's a bunch of low-hanging fruit there. you don't need _all_ of ruby's seven million libraries, but a few simple services like heroku would make the dabbling stage a lot easier.
16:38:09 <geekosaur> or values, as with the $gdmparseJSON
16:38:17 <jfischoff> heroku would be nice, but that is not what made rails take off
16:38:35 <jfischoff> bundler was probably more important
16:38:53 <blackdog> rails was big before bundler too
16:38:58 <jfischoff> no doubt
16:39:05 <blackdog> it was a colossal pain to manage :)
16:39:11 <blackdog> the thing is, the bar has shifted
16:39:15 <jfischoff> yep
16:39:51 <jfischoff> more what I might is, if you solve package management it makes thing like heroku much easiest to get going
16:40:00 <blackdog> i find it really hard to recommend yesod to newbies, where i'd have no problems doing it for rails
16:40:16 <blackdog> jfischoff: yeah, that's reasonable
16:40:23 <jfischoff> I've still haven't used it
16:41:03 <copumpkin> oh man, it's KirinDave
16:46:12 <tsuraan> looks like my program compiles fine when I use a real Main and ghc, so I guess maybe DeriveGeneric doesn't work perfectly in ghci, or something like that
16:46:39 <avpx> tsuraan: This error only gets weirder and weirder, man.
16:47:14 <tsuraan> as long as I can compile, I'm happy :)
16:47:42 <tsuraan> it wasn't too long ago that you couldn't even define new data types in ghci, so I can live with a few rough edges
17:02:39 <td123> does anyone know a better way to write concat $ replicate 5 "* " ? I feel like there should already be a function that does the concat + replicate
17:03:09 <unnali> td123: try @pl
17:03:14 <unnali> @pl concat $ replicate 5 "* "
17:03:15 <lambdabot> join (replicate 5 "* ")
17:03:23 <unnali> hmm, doesn't look like it!
17:03:39 <td123> ok, thanks
17:05:07 <td123> time to create replicateString :)
17:07:38 <ion> replicate and concat operate on more than just Strings.
17:08:36 <td123> true, I don't know what else to call it, I'll take suggestions though :)
17:11:51 <rfw> @pl foldr (\x acc -> acc * 2 + (digitToInt x)) 0
17:11:51 <lambdabot> foldr ((. (2 *)) . (+) . digitToInt) 0
17:12:27 <geekosaur> something that is to cycle what replicate is to repeat?
17:22:21 <parcs`> td123: call it replicateConcat
17:23:10 <jfischoff> replicat
17:23:38 <c_wraith> replicon?
17:23:52 <jfischoff> replikong?
17:24:20 <jfischoff> http://replicat.biz/images/home/replicat.png
17:24:49 <td123> parcs`: concatReplicate :)
17:25:26 <td123> cause just remembered concatMap is already defined and is analogous to this functions behavior
17:33:23 <WraithM> ls
17:41:16 <pharaun> good/ haskell/ project/ bin/ .. .
17:43:31 <parcs`> not-porn/
17:43:42 <shergill> heh
17:50:38 <dstcruz> > encode $ object [ ("key" .= "value")]
17:50:40 <lambdabot>   Not in scope: `encode'Not in scope: `object'Not in scope: `.='
17:52:10 <dstcruz> why does that return: Chunk "{\"key\":\"value\"}" Empty, instead of just: {"key":"value"} ? How can I make it return that?
17:52:17 <dstcruz> using the Data.Aeson library?
17:52:36 <blackdog> dstcruz: that's the result of calling "show" on a ByteString
17:52:44 <dstcruz> I'm not being able to figure out here that Chunk … Empty is
17:52:45 <dstcruz> ah
17:53:21 <blackdog> if you want a list-based string, you can call unpack on it instead
17:53:48 <blackdog> (it might be Text, not Bytestring. not sure)
18:04:19 <dstcruz> hmmm: BL.unpack $ encode $ object [ ("name" .= "value") ]  now returns a list of numbers (Word8), not a string.
18:08:01 <favonia_> @hoogle ByteString -> String
18:08:02 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
18:08:02 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
18:08:02 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
18:12:03 <dstcruz> favonia_:  thanks!
18:12:05 <nand`> ^- might not be what you want
18:13:02 <nand`> does JSON define an encoding?
18:13:31 <nand`> the wiki article mentions “String (double-quoted Unicode, with backslash escaping)”
18:17:05 <dstcruz> nand`:  is there a different way you would suggest?
18:18:32 <nand`> dstcruz: usually you'd want to do ByteString -> String with some form of decoding eg. UTF-8. The .Char8 functions only operate in the range of [0,255] so stuff like Unicode characters will be garbled as a result
18:19:34 <nand`> dstcruz: of course, if your only intention is to preview the output of something in GHCi, this is more or less irrelevant as you'd be keeping all of the actual serialized data in ByteString form either way
18:19:59 <nand`> but if you want to, say, display it to the user; you'd arguably want something like Text instead of String half the time either way
18:20:35 <dstcruz> I think I'll need Unicode
18:20:52 <dstcruz> @hoogle ByteString -> Text
18:20:52 <lambdabot> Data.Text.Encoding decodeASCII :: ByteString -> Text
18:20:52 <lambdabot> Data.Text.Lazy.Encoding decodeASCII :: ByteString -> Text
18:20:52 <lambdabot> Data.Text.Encoding decodeUtf16BE :: ByteString -> Text
18:21:17 <dstcruz> no UTF-8?
18:21:21 <nand`> :t decodeUtf8
18:21:22 <lambdabot> Not in scope: `decodeUtf8'
18:21:31 <nand`> @hoogle decodeUtf8
18:21:31 <lambdabot> Data.Text.Encoding decodeUtf8 :: ByteString -> Text
18:21:32 <lambdabot> Data.Text.Lazy.Encoding decodeUtf8 :: ByteString -> Text
18:21:32 <lambdabot> Data.Text.Encoding decodeUtf8' :: ByteString -> Either UnicodeException Text
18:27:03 <nand`> dstcruz: I checked Aeson's documentation, ‘encode’ uses UTF-8
18:27:36 <dstcruz> so, decodeUtf8 $ encode $ object ….  should be safe, right?
18:27:43 <nand`> dstcruz: but if you don't need the ByteString, you can also use toLazyText :: Build -> Text
18:27:50 <nand`> Builder*
18:28:10 <nand`> see http://hackage.haskell.org/packages/archive/aeson/0.6.0.2/doc/html/Data-Aeson-Encode.html
18:28:59 <nand`> so decodeUtf8 . encode = toLazyText . fromValue . toJSON
18:29:46 <dstcruz> nand`:  gracias!
18:29:57 <nand`> interesting, ‘encode’ is actually defined that way: encode = encodeUtf8 . toLazyText . fromValue . toJSON
18:52:32 * hackagebot simple-sendfile 0.2.4 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.4 (KazuYamamoto)
18:52:34 * hackagebot interpol 0.2.3 - GHC preprocessor and library to enable variable interpolation in strings  http://hackage.haskell.org/package/interpol-0.2.3 (AlexandruScvortov)
19:19:54 <hpaste> proloy pasted “State trial” at http://hpaste.org/70294
19:21:35 <proloy> HI , i wanted to try State monad , the paste shows my code. My intention was to take a list of integer and calculate the sum and also the number of items which are 0
19:22:04 <proloy> my state is a triplet of the list of integers left to add, number of zero and the current sum
19:22:25 <proloy> i am obviously doing something wrong as it does not even compile .
19:25:10 <proloy> additionally I am probably in the wrong time zone :)
19:25:30 <geekosaur> proloy, one thing youre doing wrong is getting caught by a regime change, as it were; you can't mix flat and hierarchical modules in ghc 7.2 and up
19:25:43 <geekosaur> also, State is no longer the constructor
19:27:02 <proloy> ah i see . Need to read more current literature then.
19:28:15 <geekosaur> there are other issues with it but those leap out at me as immediate issues
19:30:15 <proloy> Thanks geekosaur , let me see what i can do . I do not have much experience with monads except the Maybe and []
19:30:19 <geekosaur> the next thing that comes up is that you're responding to runState with an explicit state construction; but runState *itself* is an explicit state
19:31:13 <proloy> that's the line 18 right ?
19:45:35 <kallisti> it would be nice if there was a way to annotate compile-time errors in some way.
19:45:50 <kallisti> so that libraries that rely heavily on TH could improve error messages.
19:49:06 <travitch> Has anyone ever noticed strange interactions between the GHC RTS and networked file systems (AFS in my case)?
19:49:13 <travitch> I notice file reads fail seemingly randomly if the files being read are on AFS while this never seems to happen for local disks.  It seems to happen both with the compiler (which fails to load files during TH expansion) and to my own programs
20:00:14 <geekosaur> travitch, there have been sporadic reports of issues with AFS.  I no longer have access to the CMU ECE cell so I've never been able to do any testing
20:00:31 <travitch> ah, at least it isn't just me
20:01:01 <travitch> I've been poking around the RTS source and the low-level IO operations looking for random things that might be wrong
20:24:50 <nyingen> @quote
20:24:51 <lambdabot> tnks says: I'm astounded that LYAH makes an FP language accessible, while Why's Poignant Guide makes a straight-forward imperative language look arcane.
20:28:58 <unnali> clearly we need a poignant guide to haskell
20:29:03 <unnali> reduce people to tears for the wrong reason
20:39:28 <nyingen> @quote
20:39:29 <lambdabot> drudge says: Need Chelsea Clinton Nose Job? See Chelsea Clinton Nose Job.
20:39:48 <nyingen> ...
20:39:50 <nyingen> @quote
20:39:51 <lambdabot> ChanServ says: No! I've just banned myself!
20:54:12 <gbluma> Does anyone know a good resource for determining how to organize state in a program? (i.e. I have a bunch fo ioRefs that are currently in typeclass and would like to move them out.)
20:56:31 <edwardk> sounds like a job for StateT or ReaderT ;)
20:57:39 * hackagebot trifecta 0.52 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.52 (EdwardKmett)
21:01:16 <gbluma> edwardk: Yeah, that might do it. Thanks.
21:04:38 <dmwit> tgeeky_: ping
21:12:32 <andares> the GUI scene seems weird in Haskell.
21:12:50 <andares> I've been trying to grok this experimental, arrow-based one but nobody seems to use it and it's quite minimal.
21:12:56 <andares> more of a proof of concept, probably.
21:17:04 <gbluma> andares: I'm sure someone will disagree, but FRP seems like a backwards concept to me.
21:17:19 <andares> I never quite got what that was.
21:17:28 <andares> was it the idea of a kind of event-driven functional programming?
21:18:31 <gbluma> Not quite. It's more about defining the chain of reaction through a system and letting the system figure out all the events.
21:18:57 <gbluma> very cool. I'm just not quite sure if it's well suited to UI.
21:19:01 <andares> ohhh, I see.
21:19:11 <andares> although no, I don't.
21:19:14 <andares> let me look at the wiki.
21:20:54 <andares> the wiki wasn't of much help. gbluma, can you provide an example? *flutters eyes*
21:21:17 <gbluma> hah, sure.
21:23:25 <gbluma> Reactive-banana has probably been the best maintained: http://www.haskell.org/haskellwiki/Reactive-banana/Examples
21:26:43 <gbluma> The idea I'm thinking of is that a slider can convey values to a text-box, and the FRP code describes it as such. The actual mechanics of interaction between the two are handled by the library.
21:27:07 <andares> argh, this example is just at the edge of my comprehension.
21:27:13 <andares> I just don't know the language's syntax well enough.
21:27:53 <mm_freak> gbluma: why wouldn't FRP be well suited for UIs?
21:27:54 <andares> so there's a NetworkDescription monad that describes the FRP "network"?
21:28:11 <gbluma> Actually that precisely is my issue with it. It's just not obvious what is happening.
21:28:25 <andares> well, to be fair I'm a beginner.
21:29:45 <andares> hehe, silly me. I was worried that things wouldn't be evaluated in the right order.
21:30:20 <gbluma> mm_freak: It may be. I can't speak from experience. What I do know is that UIs are complex compared to other reactive systems. UIs have modes, state, timing, and a thousand other things that affect control.
21:30:28 <andares> symbols don't even need to be defined top-to-bottom do they?
21:30:47 <mm_freak> gbluma: all of that is exactly what FRP is good at =)
21:30:53 <mm_freak> local state to be exact
21:31:40 <mm_freak> if you write x . y in FRP both x and y can have their individual state without needing any state monad or anything
21:32:27 <andares> https://github.com/HeinrichApfelmus/reactive-banana/blob/master/reactive-banana-wx/src/Arithmetic.hs
21:32:31 <andares> where is text defined in the above?
21:32:46 <andares> and (:=) for that matter.
21:33:47 <NemesisD> is there any way to get a longer stack trace when a haskell program crashes? i keep getting a broken pipe error
21:34:05 <mauke> NemesisD: do you know what that message means?
21:34:52 <NemesisD> mauke: well in the shell it usually means one end of the pipe has been closed and the other side has/wants more data
21:35:13 <mzero> that's what it means in Haskell, too
21:35:13 <mauke> hah
21:35:17 <mauke> not quite
21:35:25 <mauke> NemesisD: what's the exact text of the error?
21:35:32 <unnali> andares: Reactive.Banana or Reactive.Banana.WX, I guess
21:35:39 <unnali> or Graphics.UI.WX :|
21:35:45 <geekosaur> specifically, it means that the program wrote down a pipe whose read end is closed; it's an OS level signal
21:35:49 * mzero is now curious what mauke is after
21:36:00 <mauke> mzero: signal or exception?
21:36:42 <NemesisD> it was something about socket and broken pipe. im on windows unfortunately so i'm gonna need a minute to get ssh access to where this happened
21:37:04 <geekosaur> windows?  and the rules change
21:37:35 <mauke> yeah, windows has no signals
21:37:38 <NemesisD> geekosaur: not running it on windows
21:37:40 <NemesisD> im not that dumb
21:37:50 <geekosaur> (looks like ghc actually ignores SIGPIPE anyway, so you shouldn't see that as a signal but as an IO exception when the IO call returns EPIPE)
21:38:19 <NemesisD> i strongly suspect the error is coming from redis
21:38:33 <gbluma> mm_freak: It's certainly compelling. I'm sure I've just become a micromanager from years of procedural/OOP programming.
21:39:41 <geekosaur> so, exception.  +RTS -xc, but you may need to compile with profiling
21:40:45 <geekosaur> yes, hou need to compile everything with profiling.  and with -rtsopts
21:41:24 <NemesisD> ugh, well my ssh key is not available right now so i guess i won't be getting in
21:41:30 <mm_freak> gbluma: probably =)
21:51:53 <NemesisD> anyways, i just want to figure out how to get more information when my program decides to die in a fire
22:00:44 <Cale> NemesisD: geekosaur nailed it. For programs built without profiling, it's really hard.
22:01:15 <NemesisD> i'm not opposed to compiling with profiling
22:01:29 <Cale> While there is something which GHC calls a stack, it's not a stack of function calls, it's a stack of pattern matches, so "stack trace" is kind of strange :)
22:01:34 <NemesisD> i also don't understand how the pipe could have been closed, i'm doing some pretty vanilla stuff with redis
22:02:37 <Cale> However, the newer GHCs (7.4.x) are able to construct something which looks vaguely like the stack trace which you'd have had at the point of failure when they hit an exception, using the same machinery as is used to track cost centres.
22:03:03 <NemesisD> my production environment has 7.0.4 :/
22:03:16 <Cale> Older ones also have this feature, but it doesn't work quite the same way, and you'll be quite lucky if what it gives you is useful
22:03:30 <NemesisD> boy i just keep getting boned by RHEL/EPEL's crappy repositories
22:03:52 <mauke> gentoo is still at 7.0.4 as well
22:04:18 <Cale> I never rely on my distribution for anything directly related to Haskell.
22:04:33 <mauke> oh, I was wrong
22:04:36 <NemesisD> i had trouble compiling haskell otherwise in my experience
22:04:37 <mauke> it's at 6.12.3
22:04:58 <Cale> I just grab the generic linux binary GHC from haskell.org/ghc
22:05:17 <NemesisD> well i guess i'll need to be back tomorrow morning with more useful info when i can actually get into the box
22:05:21 <Cale> and then install cabal-install (using the bootstrap.sh inside the package for it on hackage)
22:05:43 <Cale> and then from there, I just use cabal to install whatever packages I need as user
22:06:43 <Cale> Compiling GHC yourself is kinda pointless
22:06:50 <Cale> unless you're hacking on it
22:07:51 <Cale> Because you'll need a working GHC binary in the first place in order to compile it, and in that case, why not just install the current release? :)
22:08:32 <NemesisD> it might be quicker for me to just troubleshoot my problem tomorrow
22:08:59 <NemesisD> i can't afford to lose another day to this. i pretty much raged on cabal and ghc problems most of my work day today
22:09:11 <Cale> :S
22:09:23 <Cale> Yeah, it can be quite tricky to sort out problems.
22:09:51 <Cale> There are a few tricks everyone picks up over time, but it's something which ought to work better overall.
22:10:05 <tsuraan> gentoo's haskell overlay is at 7.4.1 :)
22:10:21 <Cale> (cabal package dependencies and such)
22:10:28 <amiller> how do i go about hiring someone good at haskell to implement something as a bounty
22:10:49 <amiller> i'd put up $500 for an open source merkle hash tree library
22:11:23 <amiller> especially one based on this 1998 usenix paper, M. Naor, K. Nissim. Certificate Revocation and Certificate Update.
22:11:49 <amiller> the public benefits of such a library shall be staggering
22:12:21 <Cale> Might be able to use fingertrees with a preexisting cryptographic hash
22:12:41 <amiller> it's cryptography related, but it's really just a data structure, any collision resistant hash function can be used
22:12:52 <NemesisD> see you guys tomorrow.
22:13:33 <tsuraan> merkle trees are built on tiger hash, aren't they?  Cryptohash already has a tiger implementation that seems pretty good
22:13:59 <amiller> they are not specific to any particular hash function, or even any class of hash function more specific than 'collision resistant'
22:14:27 <tsuraan> oh, ok.  I had always seen them being mentioned alongside tiger trees, so I assumed they were the same :)
22:14:31 <amiller> the trick is that when you process a merkle tree, you usually do not actually have any of the data available, except for one O(log N) branch at a time
22:14:39 <Cale> Actually, uh... hmm
22:14:40 <amiller> so i don't know if finger trees would be a drop in
22:14:59 <Cale> There's a bad problem, in that most hashes aren't associative
22:15:05 <Cale> So FingerTree won't work :(
22:15:40 <amiller> the implementation in the paper i cited is a 2-3 tre
22:16:29 <amiller> i've also made a reference implementation of this in python, using a red black tree https://github.com/amiller/redblackmerkle/blob/master/redblack.py
22:17:24 <c_wraith> red-black and 2-3 are isomorphic
22:18:49 <amiller> that's totally true
22:20:03 <Lajla> There isn't really a nice way to define a type say Matrix 3 4 which gives you a nice 3 by 4 matrix right?
22:21:08 <Cale> Lajla: Not a really *nice* way. It's possible, but not pretty.
22:21:27 <Lajla> Cale, you mean encoding 3 and 4 into 'whatever' right?
22:21:31 <Cale> yeah
22:21:47 <c_wraith> doesn't ghc head have type-level nats?
22:21:54 <c_wraith> and type-level strings, for that matter...
22:21:54 <Cale> yeah, they're coming
22:22:03 <Lajla> schweet
22:22:04 <Cale> I didn't know about the strings
22:22:12 <Lajla> type level nats is what I'm after I guess.
22:22:15 <Cale> yeah
22:22:16 <SegFaultAX> I'm having trouble groking the purpose of the Functor type class. What benefit is there in deriving a class from Functor?
22:22:21 <Ralith_> what the crap is a type-level string
22:22:33 <SegFaultAX> Especially since every derived type is going to have to supply an implementation anyway.
22:22:48 <c_wraith> SegFaultAX: abstraction.  you can write code that works with any functor.
22:22:52 <Cale> SegFaultAX: Functor is essentially those type constructors for which there's a way to map a function over the data "inside them" of the type of their parameter
22:23:08 <Cale> > fmap (*10) (Just 5)
22:23:08 <lambdabot>   Just 50
22:23:12 <Cale> > fmap (*10) [1,2,3,4]
22:23:13 <lambdabot>   [10,20,30,40]
22:23:22 <Cale> > fmap (*10) (+4) 0
22:23:23 <lambdabot>   40
22:23:44 <shachaf> SegFaultAX: "deriving a class from Functor" isn't what you do, by the way. Make sure not to confuse it with an OO class, because it's completely different.
22:24:04 <Cale> Similarly, fmap can be used to apply a function to the result of an IO action, or the result of a parser (in many parsing libraries)
22:24:19 <SegFaultAX> shachaf: I'm not confused about that, although I may have applied the terminology wrong.
22:24:20 <Cale> yeah, the wording was kind of strange there
22:24:47 <mauke> SegFaultAX: the use of a class is to callers of methods, not other classes
22:25:07 <Cale> You write an instance of Functor for your type constructor f when there's a suitable fmap :: (a -> b) -> (f a -> f b) which satisfies fmap id = id and fmap (f . g) = fmap f . fmap g
22:25:12 <SegFaultAX> mauke: I'm afraid I didn't folow that.
22:25:14 <shachaf> If you class Foo a where foo :: a, is foo a method?
22:25:22 <mauke> shachaf: yes
22:25:31 <shachaf> mauke: And you "call" it?
22:25:43 <Cale> Yeah, method is the terminology that the report uses
22:25:44 <mauke> hmm, depends
22:25:47 <mauke> sloppy wording on my part
22:25:50 <mzero> think of a type class as more like an interface: When a type is an instance of the type class, it is saying how it implements the interface
22:25:50 <Cale> But 'call' is a bit strange in Haskell :)
22:25:54 <Cale> 'apply' is better
22:26:06 <shachaf> Cale: Well, not that either in my example.
22:26:12 <mzero> when a function uses a value with a typeclass constraint - it is saying it works with any value that implements the interface
22:26:13 <Cale> sure
22:26:23 <mauke> shachaf: it is if you think of dictionary passing
22:26:25 <mauke> but you're right
22:26:32 <Cale> SegFaultAX: actually, maybe we should be explaining what typeclasses are about?
22:26:36 <SegFaultAX> So for my class to correctly be a member of Functor, it has to be parametric?
22:26:41 <Lajla> is a type level string a type depending on a string or a form of parametric type naming?
22:26:50 <mauke> SegFaultAX: class? member?
22:26:56 * mauke is confused
22:26:59 <Cale> For your type constructor to be an instance of Functor, it has to have a type parameter, yes.
22:27:05 <mzero> SegFaultAX: 'your class" - are you defining a new typeclass, or a type?
22:27:09 <mzero> probably type
22:27:20 <SegFaultAX> I'm trying to understand the point of functor.
22:27:23 <Cale> It must be of kind * -> *, which means that it takes a plain type (like Int or String), and produces another plain type
22:27:28 <SegFaultAX> I'm just unsure how to correctly apply the terminology.
22:27:29 <mzero> in otherwords, when you define a type, and you choose to make the type an instnace of typeclass Functor
22:27:32 <copumpkin> SegFaultAX: other languages might call it Mappable
22:27:37 <mauke> SegFaultAX: are there other typeclasses you already understand?
22:27:38 <Cale> For example, suppose we have the following Tree datatype
22:27:41 <SegFaultAX> Cale: Ah, ok. Now that makes sense to me.
22:27:45 <mzero> then you implement the required methods of typeclass Functor for your type
22:27:50 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
22:27:56 <SegFaultAX> mauke: Sure, Eq Ord etc.
22:28:00 <Cale> We can make Tree an instance of Functor
22:28:02 <SegFaultAX> mauke: The uh, "simple" stuff.
22:28:08 <Cale> instance Functor Tree where
22:28:13 <Cale>   fmap f Tip = Tip
22:28:16 <mauke> ok, then I don't understand what's different about Functor :-)
22:28:26 <Cale>   fmap f (Branch x l r) = Branch (f x) (fmap f l) (fmap f r)
22:28:43 <SegFaultAX> Ah so that's the term. A type is an /instance/ of a type class. Member was incorrect, sorry.
22:28:45 <Cale> So fmap f in this case will apply the function f to every value in the tree
22:29:07 <SegFaultAX> Cale: Again, I understand that. But what does that afford you?
22:29:13 <mauke> if you make your type an instance of Eq, it lets your users call (==) on it
22:29:17 <Cale> The point of Functor is to encode which types have a sensible implementation of fmap
22:29:19 <mauke> if you make your type an instance of Functor, it lets your users call fmap on it
22:29:35 <Cale> You'll probably come upon many cases where you want to manipulate all the data in a tree at once
22:29:45 <Cale> and so this gives you a common interface for doing that
22:29:52 <SegFaultAX> Ok, I think it's clicking.
22:30:32 <Cale> Also, Functor is kind of simplistic, having only one operation, but some algorithms don't actually care what kind of container you have at some given point, only that you can apply a function to all the elements of it
22:30:56 <SegFaultAX> So in this type (a -> b) -> (f a -> f b) is f a variable for any type constructor of type * -> *?
22:31:00 <Cale> yeah
22:31:02 <mauke> SegFaultAX: yes
22:31:13 <SegFaultAX> In the same way that a and b are just variables for some concrete type?
22:31:17 <mauke> "types of types" are called "kinds", btw
22:31:18 <Cale> For example, we can specialise:
22:31:25 <Cale> fmap :: (a -> b) -> (Tree a -> Tree b)
22:31:32 <Cale> fmap :: (a -> b) -> ([a] -> [b])
22:31:38 <Cale> fmap :: (a -> b) -> (Maybe a -> Maybe b)
22:31:40 <SegFaultAX> Ok so wait there.
22:31:49 <SegFaultAX> That's another thing that LYSH lost me on.
22:32:02 <mauke> fmap :: (Double -> String) -> (Map Int Double -> Map Int String)
22:32:07 <SegFaultAX> It threw in (in like 1 sentence) that [] is a type constructor.
22:32:12 <Cale> yeah
22:32:17 <SegFaultAX> That's ok, except I thought type constructors had to start with :
22:32:22 <SegFaultAX> What makes [] so special?
22:32:25 <Cale> Well, infix ones
22:32:29 <mauke> SegFaultAX: no, that's infix constructors
22:32:30 <Cale> [] is special syntax
22:32:33 <SegFaultAX> Oh
22:32:45 <mauke> and yeah, [] is hardwired into the language
22:32:46 <SegFaultAX> Can you make a fixity for "wrap around" type thingies? Like []
22:32:50 <Cale> If we didn't have special syntax for lists
22:32:51 <SegFaultAX> Oh, ok.
22:32:54 <Cale> We'd have something like
22:33:01 <mauke> SegFaultAX: no
22:33:01 <Cale> data List a = Nil | Cons a (List a)
22:33:08 <Cale> and then List would be a type constructor
22:33:18 <Cale> and Nil and Cons would be data constructors
22:33:23 <mauke> data List a = Nil | a : List a   -- would still work
22:33:26 <mauke> because : starts with :
22:33:27 <Cale> yeah
22:33:27 <SegFaultAX> But `[] a` and [a] are the same, right?
22:33:28 <liyang> : is a perfectly good infix constructor name.
22:33:31 <Cale> yes
22:33:34 <Cale> at the type level
22:33:44 <SegFaultAX> Other than being hardly readable I'll grant you :)
22:33:50 <mauke> SegFaultAX: a -> b is the same as (->) a b
22:33:54 <copumpkin> omg it's liyang
22:33:56 <Cale> It's good though, for everything to have a prefix form
22:33:58 <mauke> and this is a real special case because -> is infix without :
22:34:15 <SegFaultAX> Yea, so... wtf is -> operator?
22:34:20 <Cale> At the type level?
22:34:24 <SegFaultAX> Yea.
22:34:27 <mauke> special case, builtin, etc
22:34:27 <liyang> copumpkin: I disappeared for about a month…
22:34:28 <Cale> It constructs the type of functions from a to b
22:34:41 <copumpkin> liyang: welcome back from disappearance!
22:34:49 <Cale> a -> b is the type of functions which take an argument of type a, and produce a result of type b
22:34:49 <SegFaultAX> Hmm. What's the type of functions look like?
22:34:57 * liyang finally did his thesis corrections.
22:35:01 <copumpkin> oh nice
22:35:06 <SegFaultAX> And what erm... type class? does -> come from?
22:35:08 <copumpkin> are you dr. liyang now?
22:35:13 <mauke> SegFaultAX: you mean the actual value constructors?
22:35:16 <Cale> (->) is built in
22:35:26 <mauke> SegFaultAX: they don't exist, functions aren't algebraic
22:35:28 <Cale> You can construct values of type a -> b using lambda
22:35:43 <liyang> copumpkin: pending my examiners okaying it and graduation, yes.
22:35:53 <Cale> (\x -> y) :: a -> b when x :: a and y :: b
22:35:57 <copumpkin> sweet
22:36:04 <SegFaultAX> Ah, I see.
22:36:21 <Cale> > (\x -> x * x) 5
22:36:22 <lambdabot>   25
22:36:26 <SegFaultAX> So you can use guards to enforce types?
22:36:38 <SegFaultAX> Or is that not what that is?
22:36:39 <Cale> Guards only enforce boolean conditions
22:36:43 <Cale> and they do it at runtime
22:36:49 <Cale> (types are compile-time stuff)
22:36:56 <SegFaultAX> Isn't x :: a kind of a boolean condition?
22:37:03 <Cale> Well...
22:37:09 <mauke> that's not a guard and it's not boolean
22:37:28 <mauke> and by "boolean" I mean "of type Bool"
22:37:30 <andares> I guess it's not boolean if it's templated.
22:37:31 <Cale> It's sort of a statement of truth, but it's not a Bool
22:37:33 <SegFaultAX> Oh, derp. Sorry, I'm slipping back to Erlang.
22:37:35 <andares> oh.
22:37:40 <SegFaultAX> I forgot when was just a function.
22:37:57 <mauke> @src when
22:37:58 <lambdabot> when p s = if p then s else return ()
22:37:58 <Cale> oh, 'when' here was just an English word
22:37:59 <andares> how does type inference work?
22:38:03 <Cale> in my sentence there
22:38:21 <mauke> andares: in the obvious way :-)
22:38:37 <Cale> andares: By collecting up constraints of which types are equal to which other types, and solving the equations, basically
22:38:40 <SegFaultAX> Cale: Ok, another lamer question. :) In one paragraph, the author mentions that pattern matching /only/ works on constructors.
22:38:48 <Cale> SegFaultAX: yes
22:38:52 <Cale> Data constructors
22:38:54 <andares> ah
22:39:11 <SegFaultAX> But isn't it kinda, eh, desconstructing?
22:39:30 <Cale> SegFaultAX: sure, in a sense
22:39:46 <SegFaultAX> foo (x:xs) = ... does the opposite of foo x xs = x:xs
22:40:09 <mauke> yes
22:40:11 <Cale> You could make that an exact opposite by using a pair
22:40:22 <SegFaultAX> Is there a term for whats happening in the pattern matching example. I imagine deconstructing isn't accurate.
22:40:26 <Cale> foo (x:xs) = (x,xs) is inverse to  bar (x,xs) = (x:xs)
22:40:35 <mauke> SegFaultAX: people actually call it deconstructing
22:40:37 <geekosaur> deconstructing *is* what we usually call it, yes
22:40:42 <SegFaultAX> Oh, haha.
22:40:48 <SegFaultAX> I just landed on that term organically.
22:40:49 <SegFaultAX> :)
22:41:02 <Cale> (:) itself is called a "data constructor" though
22:41:04 <mauke> .oO( or destructing/destroying, but that's just me )
22:41:18 <SegFaultAX> Ok, I have just one more question that I can think of for right now, and it's completely different line of questioning.
22:41:28 <Cale> Even though you can use it with case or other forms of pattern matching to take apart data as well
22:42:01 <Cale> That's essentially what separates data constructors from other functions and values, they can be pattern matched.
22:42:04 <SegFaultAX> I read the Haskell wiki article on IO Actions to supplement the chapter I'm on (More IO, chap 9 or 10 I think) and in both places the /only/ time you see them being used is in main
22:42:11 <Cale> okay
22:42:11 <SegFaultAX> So... can I only do IO from main?
22:42:20 <Cale> Well, you can define IO actions anywhere
22:42:25 <shachaf> SegFaultAX: Yes, just like in C.
22:42:27 <SegFaultAX> Because that's the only place I can call an IO action where RealWorld is a thing.
22:42:27 <Cale> but in a compiled program, main is the one which runs
22:42:35 <zomg> unsafePerformIO can be used from anywhere ;)
22:42:38 <Cale> I hate the RealWorld analogy
22:42:39 <shachaf> SegFaultAX: Forget about RealWorld.
22:42:51 <SegFaultAX> Oh, really?
22:42:51 <shachaf> It has nothing to do with how I/O works in Haskell.
22:42:57 <SegFaultAX> Have I just gone and confused myself
22:43:20 <Cale> Nah, lots of people like that view of things, but I think it's unintuitive once you get to things like concurrency
22:43:22 <shachaf> SegFaultAX: You should read the FAQ about this:
22:43:24 <shachaf> @where faq
22:43:24 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:43:39 <Cale> or this: http://www.haskell.org/haskellwiki/Introduction_to_IO
22:43:40 <Cale> :D
22:43:42 <SegFaultAX> But if I can call an impure function from anywhere in the call stack, doesn't that mean that essentially anything above that function in the call stack is also indirectly impure?
22:43:45 <shachaf> Cale: Yes, the FAQ links to that.
22:43:49 <Cale> oh :)
22:43:52 <shachaf> And it also says other useful things.
22:44:02 <shachaf> SegFaultAX: There' sno such thing as an impure function.
22:44:04 <Cale> SegFaultAX: Only IO actions are allowed to run other IO actions
22:44:15 <shachaf> SegFaultAX: Really, you should read the links people are posting. :-)
22:44:18 <SegFaultAX> Cale: That's what I thought.
22:44:21 <Cale> SegFaultAX: But pure functions can have IO actions as their result.
22:44:46 <shachaf> I mean, we can type in an explanation in here for you, but people have spent a lot of time writing up better introductions and putting them in web pages where you can read them. :-)
22:44:50 <Cale> You can compute an IO action with some function, store it in a list, and later retrieve it and execute it.
22:45:03 <Cale> (from within another IO action, and ultimately from main)
22:45:08 <SegFaultAX> I did read that Intro to IO link. I was linked there from the other article.
22:45:16 <Cale> Ah, good
22:45:20 <Cale> That one was mine :)
22:45:30 <shachaf> SegFaultAX: Notice how that one says nothign about World?
22:45:34 <SegFaultAX> This is the one I'm talking about: http://www.haskell.org/haskellwiki/IO_inside
22:45:49 <SegFaultAX> shachaf: But the longer one talked about it a lot.
22:46:02 <Cale> So the idea is that IO actions of type (IO t) are like recipes for doing a bunch of stuff (possibly) before producing a result of type t
22:46:15 <geekosaur> right.  it might be best to forget that one exists, though; it's about implementation, which is not actually that useful in understanding the concept
22:46:23 <shachaf> SegFaultAX: Yes, there exist unhelpful introductions in the world. Instead of reading those you should read the ones people are mentioning here. :-)
22:46:30 <SegFaultAX> And yes I did read the disclaimer that it doesn't accurately describe Haskell IO. but it did leave me to believe that you cannot call IO actions from outside of main (directly)
22:46:44 <Cale> SegFaultAX: Thankfully, nothing is outside of main.
22:46:52 <Cale> SegFaultAX: (except dead code)
22:46:54 <SegFaultAX> geekosaur: I wish I would have known that yesterday. It was linked from a SO article :(
22:48:00 <Cale> I tend to ignore SO, I still bear a mild grudge against it from back when it started existing and fragmenting the Haskell community with regard to providing help.
22:48:16 <SegFaultAX> But I mean, erm. Again I'm having a hard time describing what I'm asking. In LYSH, the IO actions happen /exclusively/ in the definition of main.
22:48:25 <SegFaultAX> No auxilliary function does any IO.
22:48:34 <Cale> Are you sure?
22:48:40 <mauke> SegFaultAX: main is not a function. you can't call actions.
22:48:46 <SegFaultAX> Cale: Uh, no?
22:48:49 <mauke> SegFaultAX: all functions are pure.
22:48:50 <SegFaultAX> mauke: It isn't?
22:48:54 <Cale> He never shows an example of defining a separate IO action and using it from main?
22:48:58 <mauke> SegFaultAX: main :: IO ()
22:49:01 <mauke> no -> there
22:49:02 <Cale> You can do something like:
22:49:12 <Cale> callAndResponse = do x <- getLine; putStrLn x
22:49:17 <rosie> Why is the 'b' unnecessary in this line of code? type BFSState a b = State (Queue [a], Set.Set a) b
22:49:25 <Cale> main = do callAndResponse; callAndResponse
22:49:33 <SegFaultAX> Cale: Maybe I'm just not far enough into the More IO chapter to have seen those examples.
22:49:44 <Cale> rosie: because you can cancel it from both sides of the equation
22:49:55 <newsham> rosie:   if X a = Y a then X = Y.
22:49:55 <Cale> rosie: (haha, only serious)
22:50:07 <rosie> Right, so what does that mean when we use the type? Can we always add extra parameters to a type?
22:50:16 <geekosaur> rosie:  eta reduction.  it's at the end of both and not referenced anywhere else, so it can be left off of both of them.  think of it as partial application of types
22:50:23 <Cale> Well, we can't, we have to respect the kind of the type constructor
22:50:23 <SegFaultAX> Actually, rosie just reminded me if another questions. Wtf is the point of Either? Of all the examples in the book, none of them seemed useful at all.
22:50:34 <Cale> SegFaultAX: Usually for errors
22:50:59 <liyang> Either is the dual of (,)
22:51:02 <SegFaultAX> Cale: So just being able to return an Int or a String, for example?
22:51:02 <Cale> Either String a  is a useful type for when something might either succeed and produce a result of type a, or else fail and you want to provide a string describing what went wrong.
22:51:14 <SegFaultAX> liyang: I'm afraid I don't follow you.
22:51:14 <rosie> Cale: then if I want to pass two agreements to a constructor, if I left off the 'b', I wouldn't be able to?
22:51:21 <geekosaur> the most common use is that Right is a value and Left is an error indication, so you can do something more useful than simply saying Nothing.  (like, an error message indicating what exactly went wrong)
22:51:23 <Cale> By convention, Left is always failure, and Right is success
22:51:54 <liyang> SegFaultAX: Either is to (,) what + is to *, and what OR is to AND.
22:51:57 <SegFaultAX> Ooh, that's important. I'll have to remember that.
22:52:04 <Cale> rosie: Well, you could in this case, because State itself has kind * -> * -> *
22:52:21 <Cale> rosie: and so State (Queue [a], Set.Set a) :: * -> *
22:52:23 <mauke> rosie: Map String Int == (Map String) Int
22:52:33 <SegFaultAX> liyang: Is (,) a function , or some weird emtpy 2-tuple? Sorry
22:52:47 <mauke> SegFaultAX: it's a function
22:52:48 <liyang> SegFaultAX: sorry, (,) is the `pair' type.
22:52:55 <mauke> well, and type constructor
22:52:56 <newsham> ?type (1,'c')
22:52:57 <SegFaultAX> liyang: Go on.
22:52:57 <lambdabot> forall t. (Num t) => (t, Char)
22:52:57 <liyang> mauke: I meant the type.
22:52:58 <Cale> SegFaultAX: (,) a b = (a,b)
22:53:04 <Cale> (both at the type and value level)
22:53:09 <SegFaultAX> Oh oh oh, right.
22:53:31 <SegFaultAX> As opposed to some other n-tuple, specifically a pair.
22:53:40 <Cale> yeah
22:53:47 <liyang> You can have (,,) too. :)
22:54:12 <SegFaultAX> But a tuple isn't just defined by its cardinality, right? Also the types of its elements?
22:54:18 <Cale> yeah
22:54:53 <SegFaultAX> liyang: So I'm still falling down on your analogy between Either and (,). It's not clicking yet...
22:55:13 <Cale> "Either" also needs parameters for the types
22:55:21 <liyang> Either A B is A or B; (A, B) is A and B.
22:55:30 <newsham> segfault:  (,) abstracts the notion of a type like "Foo a b" and  Either abstract a type like "Bar a | Blah c"
22:55:41 <SegFaultAX> Ohhh, I see!
22:56:09 <newsham> (,) is like logical "and" and Either is like logical "or"
22:56:14 <SegFaultAX> So one thing that I may have missed from the text, or maybe it was never said: are capitals in Haskell atoms?
22:56:22 <Cale> This connection goes almost arbitrarily deep :)
22:56:24 <mauke> SegFaultAX: yes
22:56:27 <SegFaultAX> Like Erlang atoms, that is (or Ruby symbols, I guess)
22:56:34 <mauke> SegFaultAX: and lowercase identifiers are variables
22:56:43 <Cale> SegFaultAX: we usually call them constructors
22:56:44 <geekosaur> sort of.  initial capitals are type or data constructors.  lowercase indicates variables
22:56:59 <SegFaultAX> mauke: Alright, cool. I figured as much but I don't know if the author ever explicityly came out with that.
22:57:01 <Cale> Constructors (both data and type constructors) start with an uppercase letter or :
22:57:15 <Cale> apart from the special case of the (->) type constructor
22:57:22 <Cale> and []
22:57:25 <mauke> and (,)
22:57:29 <Cale> hehe :)
22:57:37 <Cale> yeah, all the special syntaxes are exempt from that
22:57:43 * hackagebot prolog 0.2.0.1 - A Prolog interpreter written in Haskell.  http://hackage.haskell.org/package/prolog-0.2.0.1 (DanielSeidel)
22:57:44 <geekosaur> all of which are "weird" in various other ways as well
22:57:55 <Cale> I guess Char data constructors too :)
22:58:00 <SegFaultAX> So hmm, then in `data type Lights = Red | Green | Blue` are Red Green and Blue constructors?
22:58:06 <SegFaultAX> Or types, or values, or what?
22:58:12 <geekosaur> data constructors
22:58:13 <Cale> They're data constructors
22:58:19 <geekosaur> and Lights is a type constructor
22:58:22 <shachaf> They're also values.
22:58:22 <Cale> also s/type//
22:58:41 <SegFaultAX> Cale: Oh right yea.
22:58:42 <Cale> data Lights = Red | Green | Blue
22:58:48 <SegFaultAX> type is only used in synonyms, right?
22:58:54 <Cale> yeah
22:58:55 <SegFaultAX> Like type String = [Char]
22:59:00 <Cale> right
22:59:19 <Cale> (and a few places in GHC extensions, but you don't have to worry about that)
22:59:25 <SegFaultAX> But Red Green and Blue constructors are nullary, right?
22:59:29 <Cale> yeah
22:59:39 <SegFaultAX> They kinda are their own value. Almost like an atom?
22:59:42 <Cale> They're just simple values rather than functions because they have no parameters
23:00:43 <Cale> also, the plural in the type name is probably a bit inappropriate
23:00:48 <SegFaultAX> So for anyone who knows a bit of Erlang, are record types in Haskell the awful hacks they are in Erlang?
23:00:55 <Cale> Because any particular value of type Lights will be only one of the three
23:01:12 <Cale> They're different, I believe
23:01:19 <Cale> But many would consider them a bit hacky
23:01:33 <c_wraith> they're still awful hacks, but they're a bit less of a hack than erlang's records
23:01:45 <c_wraith> that is, they're really in the type system.
23:01:56 <Cale> They're just some syntax sugar for non-record algebraic types
23:02:03 <SegFaultAX> For example, Erlang resolves all usages of types at compile time. They can't be inspected at run time in any meaningful way.
23:02:19 <Cale> Haskell does too
23:02:28 <SegFaultAX> And even the "functions" that inspect records aren't really functions, they're basically macros.
23:02:33 <Cale> Data constructors you inspect at runtime
23:02:36 <Cale> Type constructors you do not
23:02:51 <Cale> Typeclasses provide a kind of connection between compile and runtime
23:02:53 <SegFaultAX> Is data constructor == value constructor?
23:03:02 <Cale> in that the types can determine which implementations for things are used
23:03:06 <Cale> yes
23:03:39 <SegFaultAX> So should I stay clear of recordtypes if possible?
23:03:44 <Cale> no
23:03:45 <SegFaultAX> Kind of a last resort thing?
23:03:47 <Cale> They're good enough
23:03:47 <SegFaultAX> Ok.
23:03:56 <Cale> They're just not as good as they could be
23:04:04 <Cale> now that we know about lenses and such
23:04:11 <SegFaultAX> Why are record types often hacky?
23:04:20 <SegFaultAX> Erm, lenses?
23:04:28 <augur> i wonder if there are any means of "holographic" audio compression
23:04:41 <shachaf> @google lenses haskell
23:04:44 <lambdabot> http://hackage.haskell.org/packages/archive/lenses/0.1.2/doc/html/Data-Lenses.html
23:04:44 <lambdabot> Title: Data.Lenses
23:04:54 <Cale> A lens is basically an abstracted way of setting and getting a piece out of a data structure
23:05:06 <shachaf> @where lenses
23:05:06 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/
23:05:07 <lambdabot> lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation>
23:05:10 <augur> lenses are interesting
23:05:24 <augur> conceptually, i mean
23:05:30 <coppro> sort of
23:05:44 <Cale> A simple implementation might be something like:
23:05:44 <SegFaultAX> So it's more or less a view for a data structure?
23:06:33 <Cale> data Lens a b = Lens { get :: a -> b, put :: b -> a -> a }
23:06:55 <SegFaultAX> Cale: What's the thingy in the {}? I've not gotten to that syntax yet.
23:07:02 <Cale> that's record syntax :D
23:07:07 <SegFaultAX> Oh, derp.
23:07:17 <SegFaultAX> Disregard me. :)
23:07:21 <Cale> So our lens has two fields, both of which are functions
23:07:35 <Cale> and the way that record syntax works in Haskell, this automatically defines functions
23:07:38 <Cale> get and put
23:07:41 <Cale> which extract those fields
23:07:52 <SegFaultAX> It didn't occur to me until this moment that a recordtype can hold any value, including function values.
23:07:57 <Cale> The actual types of the automatically-defined functions are
23:08:04 <Cale> get :: Lens a b -> a -> b
23:08:10 <Cale> put :: Lens a b -> b -> a -> a
23:08:42 <mauke> heh
23:08:53 <mauke> in haskell, all functions are values
23:09:11 <SegFaultAX> mauke: Yea, but for some reason that fact that they could also be put in a record didn't really sink in.
23:09:14 <shachaf> mauke: Except for type functions!
23:09:34 <SegFaultAX> shachaf: Are they not? You can't pass around type constructors?
23:09:44 <SegFaultAX> Or is that not what a type function is?
23:09:44 <Cale> If we have x :: Lens a b, and y :: Lens b c, we can compose them together into something of type Lens a c
23:10:05 <Cale> SegFaultAX: Not at runtime, anyway!
23:10:16 <SegFaultAX> Interesting.
23:10:19 <SegFaultAX> Why is that?
23:10:29 <Cale> SegFaultAX: Mostly tradition. Types get destroyed by compilation.
23:10:36 <SegFaultAX> They are curried like normal functions, so why aren't they values like normal functions?
23:10:42 <SegFaultAX> Oh, I see.
23:11:02 <mauke> did someone say dependent typing?
23:11:06 <Cale> There are other type systems which let you more freely mix types and values (dependent type systems)
23:11:11 <Cale> but Haskell isn't one of them yet :)
23:11:27 <SegFaultAX> Like ML?
23:11:34 <Cale> Nah, ML isn't
23:11:40 <Cale> Like Agda or Coq
23:11:50 <SegFaultAX> Oh. So what exactly is a dependent type system?
23:12:21 <mauke> dohoho
23:12:25 <shachaf> @google what exactly is a dependent type system?
23:12:26 <Cale> A type system in which types are allowed to depend on plain values
23:12:27 <lambdabot> http://en.wikipedia.org/wiki/Dependent_type
23:12:27 <lambdabot> Title: Dependent type - Wikipedia, the free encyclopedia
23:12:29 <kallisti> a type system where the type of a value can depend on a value.
23:12:33 <shachaf> It's that. :-)
23:12:50 <SegFaultAX> That sounds complicated.
23:13:12 <Cale> That dependency ends up forcing some types to exist at runtime
23:13:22 * kallisti doesn't know very much about it, himself.
23:13:41 <shachaf> Cale: But that's not necessarily a problem because they hold information that you'd otherwise hold in values. :-)
23:13:52 <Cale> right
23:13:56 <Cale> at least, usually
23:14:30 <Cale> kallisti: I'm somewhat in the same boat
23:14:33 <SegFaultAX> This is a bit out of my league for right now. I'm still trying to unscrew my brain from imperative programming and function programming-lite via Erlang.
23:14:50 <Cale> I've seen a whole bunch of dependently typed code, but I haven't done any programming in dependently typed systems myself.
23:15:05 <mauke> basically, stuff like agda or coq is double-haskell
23:15:09 <Cale> SegFaultAX: yeah, this is sort of the next level :)
23:15:09 <kallisti> I've been told that C++'s templates aren't dependently typed but I'm not sure where the difference lies.
23:15:46 <shachaf> kallisti: C++'s templates are just templates.
23:15:50 <SegFaultAX> Cale: I'll get there, but after I like, learn monads 'n shit. Ya know? :D
23:16:06 <shachaf> Please don't "learn monads". :-(
23:16:16 <Cale> SegFaultAX: In that regard, perhaps check out my Monads as Computation article at some point
23:16:44 <Cale> But yeah, monads aren't really *that* big of a deal
23:16:44 <SegFaultAX> Cale: I've seen that one references all over the place.
23:16:45 <mauke> understanding Functor is a good start!
23:16:57 <SegFaultAX> Cale: Although the one recomended to me was the uh, what's it called...
23:17:00 <mauke> Monad is just more of the same
23:17:08 <SegFaultAX> Oh right, you could have invented monads or some such.
23:17:12 <Cale> SegFaultAX: Monad is just an abstraction that a bunch of libraries happen to fit into
23:17:17 <mauke> you could have prevented monads
23:17:32 <Cale> SegFaultAX: like, a "shape" that lots of APIs happen to have in them
23:17:41 <Cale> SegFaultAX: and we abstract it out and give it a name
23:17:54 <Cale> SegFaultAX: and then we can write a bit of code which works with all of those libraries
23:17:57 <SegFaultAX> Cale: I feel I already understand the idea generally speaking. But understanding their application is the next level for me.
23:18:02 <mauke> "hey, this looks like a useful pattern. let's put it in a library."
23:18:18 <hayashi> A monad is a cherry blossom in the garden of the fallen Samurai who committed seppuku after being proven by the Shogunate to have eaten all the sushi between them.
23:18:20 <hayashi> ^-- new monad tutorial
23:18:22 <Cale> In particular, this shape consists of two things:
23:18:31 <Cale> or, I should say, three
23:18:37 <Cale> 1) A type constructor M
23:18:43 <Cale> 2) return :: a -> M a
23:18:53 <mauke> hayashi: *single tear*
23:19:02 <Cale> 3) (>>=) :: M a -> (a -> M b) -> M b
23:19:04 <AfC> hayashi: nice :)
23:19:25 <mauke> (>>=) is a bit like fmap, only different
23:19:26 <AfC> That should go in HWN
23:19:29 <Cale> In the computational view
23:19:40 <SegFaultAX> Cale: I mostly understand 1 and 3, no idea about 2.
23:19:50 <Cale> Oh, that's curious
23:19:57 <Cale> Usually it's 3 which is tricky :)
23:19:59 <SegFaultAX> Cale: The only thing I know about return is it's something to do with returning from the middle of a pipeline.
23:20:06 <Cale> nope!
23:20:24 <Cale> return just makes an action which does nothing, except to return the given value
23:20:27 <SegFaultAX> Or rather, it allows you to change its value from the last expression to any arbitrary expression.
23:20:43 <Cale> if you put it in the middle of a do-block or other chain of actions, it will behave like a no-op
23:20:54 <Cale> it doesn't have control effects like return in imperative languages
23:21:29 <SegFaultAX> The third bit I think I understand from reading that IO action tutorial. Seeing the bind operator described in context helped a lot.
23:21:35 <SegFaultAX> Unless I learned it wrong, then that sucks.
23:21:36 <Cale> yeah
23:21:40 <mauke> SegFaultAX: 'return' is a constructor (informally)
23:21:42 <Cale> Yeah, you should have the idea
23:22:01 <mauke> e.g. for lists return x = [x]
23:22:09 <Cale> So, let's have a look at the list monad, yes :)
23:22:40 <Cale> In the list monad, "running" a list xs basically means "picking an element from xs in all possible ways"
23:22:54 <SegFaultAX> The list monad? I'm all ears, but right now be warned that I've /only/ seen monads in context of IO actions which I understand are only tangentially related to monads.
23:22:58 <mauke> oh yes, the "multiple worlds" interpretation
23:23:00 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
23:23:01 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
23:23:14 <Cale> we can put that in terms of >>=
23:23:33 <Cale> > [1,2,3] >>= (\x -> [4,5] >>= (\y -> return (x,y)))
23:23:34 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
23:23:44 <Cale> (but you start to see why do-notation is nice)
23:23:59 <mauke> SegFaultAX: IO is special because it's abstract and the runtime system does interesting things with it
23:24:03 <Cale> In the list monad,  xs >>= f = concat (map f xs)
23:24:17 <Cale> If you think about the type, this implementation seems natural
23:24:18 <mauke> SegFaultAX: most other types are easier to "get"
23:24:24 <Cale> (>>=) :: [a] -> (a -> [b]) -> [b]
23:24:50 <Cale> So we're given a list of a's, and a function from a's to lists of b's, and we want to get a list of b's
23:24:58 <SegFaultAX> Wait
23:25:03 <SegFaultAX> That's something I don't get.
23:25:11 <SegFaultAX> How can we go from an a to a list of bs?
23:25:19 <SegFaultAX> If we just have the 1 value?
23:25:21 <coppro> The function provided does that
23:25:22 <Cale> Well, we're given a function which does this
23:25:36 <SegFaultAX> Can you give me a concrete example of such a function?
23:25:43 <Cale> For example, it might take an integer x and produce a list of Strings
23:25:52 <mauke> SegFaultAX: we're implementing (>>=) here. our *caller* is the one who has to worry about coming up with such a function
23:25:57 <Cale> \x -> [show (x - 1), show (x + 1)]
23:26:00 <coppro> :t repeat 2
23:26:01 <lambdabot> forall t. (Num t) => [t]
23:26:07 <kallisti> SegFaultAX: "But understanding their application is the next level for me."  The specific application depends on the monad. There is no single application for monads.
23:26:23 <coppro> bah, not the one I wanted :)
23:26:25 <mauke> SegFaultAX: but as an example, show :: Int -> [Char]
23:26:26 <coppro> :t replicate 2
23:26:28 <lambdabot> forall a. a -> [a]
23:26:30 <coppro> there we go
23:26:42 <SegFaultAX> Cale: So the actual function that goes from a -> [b] is kind of arbitrary?
23:26:47 <Cale> > [10,20,30] >>= \x -> [show (x - 1), show (x + 1)]
23:26:47 <coppro> SegFaultAX: Right.
23:26:48 <lambdabot>   ["9","11","19","21","29","31"]
23:26:53 <Cale> yes, completely arbitrary
23:26:59 <Cale> apart from we know that it has that type
23:27:12 <mauke> ... that type for some a, b
23:27:33 <SegFaultAX> But how is that possibly useful is this case?
23:27:51 <SegFaultAX> Why would I want a list of all nums -1 and +1 for each num in some starting list?
23:27:59 <coppro> Well, you probably wouldn't.
23:28:01 <Cale> oh, well, that wasn't a *useful* example
23:28:06 <SegFaultAX> Oh. :)
23:28:16 <SegFaultAX> So what's a really useful thing I can do with bind?
23:28:19 <Cale> I could enumerate Pythagorean triples
23:28:26 <SegFaultAX> Cale: That would be cool.
23:28:32 <shachaf> SegFaultAX: I recommend that you take the FAQ's advice -- http://www.haskell.org/haskellwiki/FAQ#The_M-word -- and learn about some simpler things before you try to "understand monads" (whatever that means).
23:28:46 <SegFaultAX> Cale: But I can do that in a list comprehension trivially, so what does expressing it as a monad provide me?
23:28:51 <coppro> SegFaultAX: List comprehensions actually expand to monad operations.
23:28:56 <kallisti> > (`replicateM` "abc") =<< [0..]  -- you can enumerate all the strings of a given alphabet with the list monad.
23:28:57 <lambdabot>   ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","a...
23:28:59 <shachaf> SegFaultAX: In particular, you should understand all the things in section 8.3.
23:29:17 <Cale> SegFaultAX: List comprehensions are essentially just another do-notation for the list monad
23:29:28 <SegFaultAX> Mind = blown.
23:29:34 <Cale> But yeah, what this gives you is all the other cool stuff from Control.Monad
23:29:45 <mauke> hey, lemme try an example
23:29:47 <Cale> (all the stuff which was already written in terms of >>= and return)
23:29:57 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
23:29:58 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
23:30:08 <SegFaultAX> So hang on, is Monad really just a type class then?
23:30:09 <Cale> > replicateM 5 "ab"
23:30:10 <lambdabot>   ["aaaaa","aaaab","aaaba","aaabb","aabaa","aabab","aabba","aabbb","abaaa","a...
23:30:12 <Cale> yes
23:30:12 <mauke> SegFaultAX: yes
23:30:15 <SegFaultAX> A type class that defines >>=?
23:30:18 <coppro> yup
23:30:20 <Cale> and return
23:30:20 <mauke> yes, and return
23:30:30 <Cale> class Monad m where
23:30:30 <liyang> (and fail!)
23:30:33 <SegFaultAX> Oh, sorry, what's that one do again?
23:30:35 <Cale>   return :: a -> m a
23:30:45 <Cale>   (>>=) :: m a -> (a -> m b) -> m b
23:30:47 <mauke> > [ (x, x) | x <- [1 .. 10], even x ]  -- SegFaultAX: do you understand this?
23:30:47 <lambdabot>   [(2,2),(4,4),(6,6),(8,8),(10,10)]
23:30:49 <SegFaultAX> Oh, ok.
23:30:54 <Cale> return does something different in every monad of course
23:31:00 <SegFaultAX> mauke: Sure do.
23:31:13 <mauke> > do { x <- [1 .. 10]; guard (even x); return (x, x) }
23:31:14 <lambdabot>   [(2,2),(4,4),(6,6),(8,8),(10,10)]
23:31:16 <Cale> but return v usually means something like "do nothing, but return v as the result"
23:31:28 <Cale> So in the list monad,  return v = [v]
23:31:28 <mauke> sure "do", hoho
23:31:37 <SegFaultAX> So somewhere in the bowels of the stdlib there is an instance Monad [] where...
23:31:40 <Cale> "running" the list [v] will have only one result, which is v
23:31:43 <mauke> @src Monad []
23:31:44 <lambdabot> Source not found. You untyped fool!
23:31:44 <Cale> yep
23:31:49 <Cale> instance Monad [] where
23:31:53 <Cale>   return v = [v]
23:32:02 <Cale>   xs >>= f = concat (map f xs)
23:32:07 <coppro> > [1 .. 10] >>= guard . even >>= \x -> return (x, x)
23:32:09 <Cale> that's all there is to that :)
23:32:10 <lambdabot>   [((),()),((),()),((),()),((),()),((),())]
23:32:13 <coppro> oops
23:32:17 <Cale> instance Monad Maybe where
23:32:21 <Cale>   return v = Just v
23:32:22 <coppro> :)
23:32:28 <Cale>   Nothing >>= f = Nothing
23:32:34 <Cale>   Just x >>= f = f x
23:32:44 <SegFaultAX> For right now I think it's easier for me to understand (>>=) xs f because I'm not used to infix pattern matching.
23:32:50 <Cale> oh, sure
23:32:58 <Cale> That would be  (>>=) Nothing f
23:33:01 <SegFaultAX> Like seeing xs ++ ys = ... is just bizzare.
23:33:03 <Cale> and (>>=) (Just x) f
23:33:06 <Cale> respectively
23:33:22 <mauke> SegFaultAX: ah, that took me some time to get comfortable with too
23:33:31 <SegFaultAX> So Monads are also a maybe something?
23:33:37 <mauke> no
23:33:38 <coppro> Maybe is a monad
23:33:40 <Cale> Maybe is a monad
23:33:44 <SegFaultAX> Oh.
23:33:46 <coppro> one of the easiest to understand, too
23:33:54 <mauke> coppro: Identity?
23:34:01 <Cale> He did say "one of"
23:34:04 <mauke> :-)
23:34:04 <SegFaultAX> class (Monad a) => Maybe a... ?
23:34:09 <Cale> nope
23:34:09 <coppro> mauke: Well, yes, but it doesn't let you learn much
23:34:11 <mauke> SegFaultAX: no, Maybe is not a class
23:34:15 <Cale> data Maybe a = Nothing | Just a
23:34:41 <SegFaultAX> Oh, right.
23:34:56 <sopvop> Why no one mentioned that monoids-endofunctors thing yet? :)
23:34:57 <Cale> SegFaultAX: remember, classes are not like Java classes, in that they're not types. They're more like Java interfaces, if you want to make a comparison
23:34:57 <mauke> you can think of Maybe as a list with at most 1 element
23:35:22 <coppro> SegFaultAX: Maybe represents a computation which may or may not return a value. So when you compose a series of computations in the Maybe monad, you perform a series of computations, but if you hit Nothing at any point, (>>=) short-circuits the rest of the computations and just gives you Nothing back.
23:35:34 <SegFaultAX> So it seems like the bind operator just takes the previous state of execution, and defines a function that for that value provides a new, possibly mutated state of execution.
23:36:07 <Cale> SegFaultAX: If you have a sufficiently general notion of what "execution" means
23:36:07 <sopvop> It's not about state, it's about composition. or something.
23:36:13 <coppro> You can think about it that way.
23:36:28 <Cale> SegFaultAX: I mean, it's also an operation on lists :)
23:36:30 <SegFaultAX> Eh, like everything I guess?
23:36:46 <SegFaultAX> All the relevant application state makes up the input to the monad I'd have thought.
23:36:47 <coppro> List is actually a weird monad
23:36:59 <Cale> What do you mean "input to the monad"?
23:37:11 <SegFaultAX> The left hand side of the >>=
23:37:21 <SegFaultAX> The first operand I guess.
23:37:21 <Cale> Oh, the input to bind
23:37:28 <SegFaultAX> Cale: That, yes.
23:37:40 <coppro> SegFaultAX: If you want my advice, try to stop thinking in terms of state.
23:37:44 <kallisti> coppro: I find List to be most effective when explaining join (fmap f m) = m >>= f
23:37:46 <Cale> Well, usually you don't think of that as "state" as much as "the first part of your computation"
23:37:53 <kallisti> but something like Maybe is better for a introduction.
23:38:24 <SegFaultAX> Cale: I guess I have trouble with that because you can't compute with no starting state, or data.
23:38:37 <SegFaultAX> Like, compute /what/ bind to /what/?
23:38:41 <SegFaultAX> Does that sentiment make sense?
23:38:50 <coppro> kallisti: True, but the main weirdness about list is that it can encapsulate multiple values. Most of the interesting monads have singular values; the common ones that don't are just data structures.
23:38:56 <Cale> The computation x >>= f will first "run" the computation x (whatever that means), and if its result is v, it will "then" "run" the computation (f v)
23:39:14 <coppro> SegFaultAX: It's easier to think less about state and more about functions, in my humble opinion.
23:39:21 <Cale> In each instance, the implementation of (>>=) itself constitutes what "run" and "then" mean here
23:39:32 <SegFaultAX> Ok, I think it's starting to make sense.
23:39:48 <SegFaultAX> This doesn't seem striking different from composition (.)
23:39:52 <Cale> In the case of lists, "run" means "pick an element in all possible ways"
23:40:04 <kallisti> SegFaultAX: it's more like a special kind of function application.
23:40:07 <SegFaultAX> Except there is an extra function in there that does some work between each composed function.
23:40:20 <Cale> and "then" will make selections one after the other, in a nested loops sort of way
23:40:38 <sopvop> This one helped me understand. Though you need to read about functors first.  http://learnyouahaskell.com/a-fistful-of-monads
23:40:40 <coppro> I found monads much easier to understand after a friend pointed out to me that you can regard IO as containing an input->output mapping.
23:40:48 <Cale> SegFaultAX: It's closer to an abstracted version of function *application* actually
23:40:49 <coppro> rather than an actual computation.
23:40:58 <Cale> that is, ($)
23:41:06 <Cale> Or flip ($) even :)
23:41:14 <Cale> :t ($)
23:41:15 <lambdabot> forall a b. (a -> b) -> a -> b
23:41:20 <Cale> :t (=<<)
23:41:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
23:41:36 <Cale> It's like we've stuck some m's into the type of ($)
23:41:50 <Cale> there's an analogous one for composition:
23:41:54 <Cale> :t (<=<)
23:41:55 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
23:42:03 <coppro> :t (.)
23:42:04 <Cale> which is defined in terms of bind
23:42:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:42:09 <Cale> kekeke
23:42:15 <Cale> :t (Prelude..)
23:42:16 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
23:42:22 <coppro> ah right :)
23:42:33 <SegFaultAX> You've lost me a bit now.
23:42:40 <Cale> okay
23:42:48 <Cale> So plain function composition takes
23:42:51 <coppro> SegFaultAX: (=<<) is (>>=) backwards. compare its type and ($)
23:42:52 <Cale> A function (b -> c)
23:42:55 <Cale> and a function (a -> b)
23:43:01 <Cale> and produces a function (a -> c)
23:43:06 <SegFaultAX> Yup, I'm with ya.
23:43:10 <Cale> Suppose that m is some monad
23:43:17 <Cale> Can we make a function which takes:
23:43:25 <Cale> A function (b -> m c)
23:43:33 <Cale> and a function (a -> m b)
23:43:40 <Cale> and produces a function (a -> m c) ?
23:44:08 <shachaf> Cale: This is much nicer than the other direction around.
23:44:52 <Cale> That's what the Kleisli fish does
23:44:53 <Cale> lol
23:44:59 <Cale> :t (<=<)
23:45:00 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
23:45:12 <SegFaultAX> So a function that turns b -> Maybe c, a -> Maybe b, the result is a function a -> Maybe c
23:45:18 <Cale> cover the part before the => with your hand
23:45:23 <Cale> yeah
23:45:29 <Cale> exactly
23:45:47 <Cale> Or takes (b -> [c]) and (a -> [b]) and gives (a -> [c])
23:45:58 <SegFaultAX> I had to make it concrete. Having a variable for the constructor and the type was too much.
23:46:11 <Cale> Or takes (b -> IO c) and (a -> IO b) and gives a -> IO c
23:46:16 <Cale> etc. etc. :)
23:46:32 <Cale> Parsers are also a good example
23:46:38 <SegFaultAX> But you started by saying this was closer to application, and now you've made an argument that again makes it seem closer to composition.
23:46:45 <SegFaultAX> How is this related to application?
23:46:48 <Cale> Oh, well, this operation isn't >>=
23:46:53 <Cale> This is something closer to composition
23:46:58 <kallisti> he was showing you the analogue to composition
23:47:06 <SegFaultAX> Ohhh.
23:47:08 <kallisti> as opposed to the one for application.
23:47:08 <Cale> This is the true analogue to composition
23:47:12 <SegFaultAX> So what's the proper bind then?
23:47:27 <SegFaultAX> Or rather, what's application, then what's bind?
23:47:28 <SegFaultAX> :)
23:47:32 <Cale> Compare a flipped over version of bind:
23:47:35 <Cale> :t (=<<)
23:47:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
23:47:38 <Cale> and
23:47:41 <Cale> :t ($)
23:47:42 <lambdabot> forall a b. (a -> b) -> a -> b
23:47:46 <kallisti> SegFaultAX: "calling" a function is application of a function.
23:47:47 <Cale> f $ x = f x
23:48:11 <SegFaultAX> Sure, I'm with that.
23:48:28 <Cale> So it's like we've stuck some m's into the type of ($)
23:49:02 <SegFaultAX> So it's like, m f $ x = m (f x)?
23:49:17 <Cale> Errr
23:49:34 <SegFaultAX> No
23:49:50 <Cale> How (>>=) will be implemented is highly dependent on the instance
23:49:51 <SegFaultAX> f $ Maybe x = Maybe (f x) makes more sense I think.
23:49:57 <Cale> Maybe is a type level thing
23:49:58 <shachaf> It doesn't.
23:50:01 <Cale> doesn't belong in values
23:50:14 <SegFaultAX> Oh, sure.
23:50:16 <Cale> However,  f =<< Just x = f x
23:50:20 <SegFaultAX> Yea.
23:50:26 <SegFaultAX> Just, that's what I was looking for.
23:50:41 <Cale> (and notice that we don't need a Just on the right)
23:50:51 <SegFaultAX> Where did the Just go, though?
23:50:52 <Cale> indeed, f might produce Nothing
23:50:57 <SegFaultAX> Is it just discarded?
23:51:00 <Cale> Or it might produce Just y
23:51:13 <Cale> f :: a -> Maybe b
23:51:19 <SegFaultAX> Ah!
23:51:28 <Cale> So it's already producing a Maybe-thing
23:51:28 <SegFaultAX> That clicked.
23:51:49 <SegFaultAX> So this doesn't make sense without a parametric type then?
23:51:52 <Cale> right
23:52:02 <Cale> The parametric type itself is what we refer to as "a monad"
23:52:10 <Cale> Though it's really that, together with the operations
23:52:25 <Cale> So we'll say "Maybe is a monad"
23:52:39 <Cale> with the understanding that some definition of return and (>>=) come along with that
23:52:44 <SegFaultAX> So hang on, in Just Int, what's Int called?
23:52:49 <SegFaultAX> As it relates to just
23:52:54 <Cale> Just is a data constructor
23:52:55 <Cale> Int is a type
23:52:59 <SegFaultAX> Right.
23:53:02 <SegFaultAX> Ok.
23:53:04 <Cale> (nullary type constructor)
23:53:13 <Cale> Just Int will be an error, usually
23:53:32 <Cale> Unless you either have a data constructor confusingly also called Int
23:53:38 <Cale> or a type constructor called Just
23:53:44 <SegFaultAX> Eq.
23:53:47 <SegFaultAX> Err, ew.
23:53:49 <Cale> (types and values are in separate name spaces)
23:54:09 <Cale> But there might be a reason
23:54:22 <Cale> Maybe you're writing a typechecker and want a value called Int :)
23:54:36 <SegFaultAX> Just 4 though, 4 is the value and it's type is Just 4 :: Maybe Int?
23:54:44 <Cale> (not too likely, but go with it :)
23:54:49 <Cale> yes
23:55:09 <SegFaultAX> But we need a way to kinda split the value off of the constructor.
23:55:12 <Cale> Just :: a -> Maybe a
23:55:16 <Cale> hmm
23:55:16 <SegFaultAX> To separate Just and 4
23:55:19 <mauke> data Just float = Int  -- where is your god now?
23:55:23 <Cale> lol
23:55:38 <Cale> SegFaultAX: pattern matching does that
23:55:52 <SegFaultAX> We have to descontruct the value.
23:56:10 <Cale> > case Just 4 of Nothing -> "oops"; Just x -> show x
23:56:10 <lambdabot>   "4"
23:56:50 <theadmin> What's the real difference between Float and Double? Is it like Int and Integer, or something else/
23:56:52 <theadmin> ?*
23:56:52 <lambdabot> Maybe you meant: . ? @ v
23:56:53 <dmwit> (There are many other functions for deconstructing Maybe values, of course. But they all bottom out at pattern matching.)
23:57:03 <dmwit> theadmin: single-precision vs. double-precision floats
23:57:12 <dmwit> theadmin: as specified in IEEE754 or whatever
23:57:23 <dmwit> theadmin: Basically, Double has twice as many bits as Float.
23:57:23 <Cale> theadmin: They're both finite representations here
23:57:24 <SegFaultAX> Cale: What was the list monad again?
23:57:40 <theadmin> dmwit: Not sure what that means >.< Haskell is the first static language I'm actually learning (after C#, where I learned "never use float unless you want the compiler to complain a huge lot")
23:57:42 <Cale> SegFaultAX: return v = [v] and xs >>= f = concat (map f xs)
23:57:43 <mauke> concatMap
23:57:54 <theadmin> dmwit: Oh, "twice as many bits". Okay.
23:58:04 <Cale> > pi :: Float
23:58:05 <lambdabot>   3.1415927
23:58:07 <SegFaultAX> What does concat do?
23:58:07 <Cale> > pi :: Double
23:58:09 <lambdabot>   3.141592653589793
23:58:15 <Cale> SegFaultAX: concatenate a list of lists
23:58:16 <dmwit> > pi :: CReal
23:58:16 <mauke> SegFaultAX: concat :: [[a]] -> [a]
23:58:17 <lambdabot>   3.1415926535897932384626433832795028841972
23:58:22 <Cale> > concat [[1,2,3],[4,5],[6,7,8]]
23:58:23 <lambdabot>   [1,2,3,4,5,6,7,8]
23:58:29 <theadmin> CReal? What's that now? Gah
23:58:44 <dmwit> theadmin: CReal is arbitrary-precision floats. =)
23:58:45 <SegFaultAX> Oh, so it's like a shallow flatten, kinda sorta.
23:58:48 <Cale> theadmin: A library datatype for infinite precision computable reals
23:58:50 <dmwit> "infinitely times as many bits"
23:58:58 <Cale> SegFaultAX: yes
23:59:06 <theadmin> dmwit: Ah, now that's a good one to have.
23:59:20 <Cale> I don't know when anyone has ever cared about deep flatten, but yeah
23:59:22 <dmwit> theadmin: In most cases, if you can get away with using Rational instead, you should.
23:59:38 <theadmin> Oh for god's sake! Too many types for the same thing >.<
23:59:45 <dmwit> They're not the same!
23:59:52 <theadmin> The types aren't, the thing is
23:59:52 <Cale> (for some reason all the dynamically typed languages love implementing deep flatten, but rarely anyone ever wants that one)
23:59:56 <mauke> theadmin: the thing isn't
