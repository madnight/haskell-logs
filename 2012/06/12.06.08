00:00:31 <Twisol> Conceptually understanding monads. What I'm getting at is that a monad action seems a lot like a function, even though it doesn't have a ->
00:00:58 <nand`> How is ‚ÄúMaybe ()‚Äù like a function?
00:02:58 <Twisol> mm‚Ä¶ not a great example, then...
00:03:05 <nand`> rather, a monad action is something that you can ‚Äúapply‚Äù a function (that produces another monad action) to; compare (>>=) :: Monad m => m a -> (a -> m b) -> m b
00:03:10 <Twisol> putStrLn "foo" is :: IO (), right?
00:03:16 <nand`> yeah
00:03:17 <ClemHout> well monads are functors, right ? and functors are functions between categories, right ?
00:03:24 <ClemHout> so monads are functions :)
00:03:24 <Twisol> but it has to execute within a context, right?
00:03:41 <Twisol> so IO () is like a function that takes the context and returns a context plus a value
00:03:49 <Twisol> (where the value is ())
00:04:07 <ClemHout> something like putStrLn "foo" >> return ()
00:04:11 <nand`> ClemHout: yeah true; ‚Äúfmap‚Äù is most certainly a function :P
00:04:21 <ClemHout> the context is >> return ()
00:04:44 <nand`> Twisol: hehe, that's funny because in GHC IO is actually implemented exactly that way; but nonetheless, in pure Haskell ‚ÄòIO‚Äô is just a place-holder for something that has real-world side effects
00:05:08 <Twisol> nand`: Well, my observation is that monads can be looked at in that fashion, in some sense
00:05:16 <ClemHout> nand`: yeah, I remember an explanation of monads actually centered about the function thing
00:05:18 <nand`> Twisol: some monads can, others can't
00:05:24 <Twisol> nand`: true
00:05:27 <nand`> Twisol: that's why the hard part is figuring out a more general abstraction :P
00:05:41 <Twisol> nand`: is that in any way related to the concept of an arrow?
00:06:00 <nand`> Twisol: is what in any way related to an arrow?
00:06:14 <Twisol> monads as similar to functions
00:06:22 <nand`> yes, very
00:06:28 <nand`> monads are arrows between categories
00:06:31 <nand`> well, functors are
00:06:37 <nand`> monads are functors + two more arrows
00:06:40 <nand`> so monads are three arrows :P
00:06:45 <Twisol> heh
00:06:55 <Twisol> do the other two come from monoid or something?
00:07:03 <nand`> something like that
00:07:12 <nand`> ‚Äúmonads are monoids in the category of endofunctors‚Äù
00:07:18 <startling> what's the problem?
00:07:21 <Twisol> yeah, the scary thing is that I understand that line now
00:07:23 <startling> sorry. >.>
00:07:24 <Twisol> :/
00:07:38 <Twisol> startling: XD
00:07:49 <nand`> notably, ‚Äúreturn‚Äù is the identity
00:07:57 <Twisol> okay, I don't understand the category bit yet, but yeah
00:08:04 <nand`> ie. consider x >>= return   =  x
00:08:14 <Twisol> right.
00:08:34 <Twisol> the arrow thing is what I think I'm trying to see in monads
00:08:42 <Twisol> I guess in IO it's more obvious
00:08:42 <nand`> (also return x >>= f  =  f x but that one's a bit uglier; these laws are better explained using kleisli arrows :P)
00:09:25 <nand`> Twisol: the ‚Äúarrow‚Äù part of functors is that F points from every haskell type X to a ‚Äúlifted‚Äù type F X
00:09:46 <nand`> and from every function f :: A -> B to a ‚Äúlifted‚Äù function fmap f :: F A -> F B
00:10:03 <Twisol> yeah, I saw that on Wikipedia but can't say I fully digested it. :)
00:10:28 <nand`> there's something similar going on for the other two arrows monads have (return :: a -> m a  and  join :: m (m a) -> a)
00:10:54 <nand`> return points from ‚ÄúIdentity‚Äù to ‚Äúm‚Äù, while join points from ‚Äúm . m‚Äù to ‚Äúm‚Äù
00:10:56 <Twisol> I can see the similarity in return immediately
00:10:56 <nand`> err
00:10:59 <nand`> join :: m (m a) -> m a
00:11:50 <Twisol> It's a little weird treating functions as actual types of data.
00:12:12 <Twisol> I'm used to being able to pass around functions as first-class values, but not so much on this level.
00:13:03 <nand`> yeah, something like instance Monad ((->) e) -- makes zero sense to somebody not used to it
00:13:13 <nand`> ‚Äúpartially applied function types? what world do we live in?‚Äù
00:13:20 <Twisol> Hah.
00:13:29 <Twisol> It kinda makes sense. Sorta.
00:14:08 <nand`> it does when you stop considering functions as something deeply magical that can be executed by some evil black box; and start considering them as morphisms in the category of haskell types :P
00:14:32 <Twisol> The weird thing to me about (->) is that the type constructors don't exist at the same level as other type constructors.
00:14:53 <Twisol> not like Just 42, for example
00:15:06 <Twisol> it seems that in Haskell, (->) instances are your definitions like main = ...
00:15:16 <Twisol> (or well, foo x y = ...)
00:15:17 <nand`> (\a -> b) -- has type (->) A B where A, B are the types of a, b
00:15:43 <Twisol> oh I didn't think of lambdas
00:16:00 <Twisol> my head D:
00:16:02 <nand`> but those aren't type constructors either way; you can't pattern match against them
00:16:23 <Twisol> Yeah. But they still end up creating a value of the (->) type.
00:16:24 <Twisol> Crazy stuff.
00:16:43 <nand`> it also can't be partially applied
00:16:57 <startling> woah wut
00:17:10 <Twisol> Well no, I wouldn't expect syntax-level constructs to behave like semantic-level constructs.
00:17:25 <nand`> (\e) :: b -> (E -> b) -- just doesn't make sense
00:17:29 <unnali> @type void
00:17:31 <lambdabot> Not in scope: `void'
00:17:44 <nand`> unnali: :: Monad m => m a -> m ()
00:17:56 <startling> what do I read to learn more of this stuff? Most of my problems learning haskell have been "how do I make cabal work" and "this library has terrible documentation".
00:18:07 <Twisol> startling: define "this stuff"
00:18:09 <startling> I'd like some more interesting problems!
00:18:15 <unnali> nand`: ta, that's what I was hoping. (that said, it appears to be defined for Functors, but whatever, it works :))
00:18:28 <startling> Twisol, "theory of haskell", so to speak
00:18:39 <nand`> unnali: oh, indeed
00:18:42 <Twisol> startling: get curious
00:18:47 <nand`> unnali: makes sense anyhow
00:18:59 <Twisol> startling: most of what I've learned so far has just been wondering about certain Haskell things and asking for clarity here
00:19:01 <nand`> startling: lots of this on the haskell.org wiki
00:19:36 <Twisol> startling: also, you may enjoy figuring out what this does: (\(x, y) -> (,) x <$> y)
00:19:37 <nand`> if you're interested in the ‚Äúcategory theory behind Haskell‚Äù, or perhaps don't know if you're interested or not, you could have a glimpse at http://www.haskell.org/haskellwiki/Category_theory
00:19:47 <nand`> and if it interest you, maybe pick up a few books on category theory in the process
00:20:13 <Twisol> nand`: is category theory "past" group theory, or on the same level?
00:21:02 <startling> :t <$>
00:21:03 <lambdabot> parse error on input `<$>'
00:21:11 <startling> :t (<$>)
00:21:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:21:20 <startling> oh right, that thing
00:21:21 <Twisol> startling: it's infix fmap
00:21:48 <nand`> Twisol: group theory is not a prerequisite of category theory; if anything the reverse would be true
00:22:07 <Twisol> nand`: in terms of learning order, I mean
00:22:16 <nand`> Twisol: though it might help to have a basic understanding of set theory when tackling category theory
00:22:30 <nand`> Twisol: I don't know. I've never really studied group theory, other than knowing approximately what groups are
00:22:35 <Twisol> ah, okay.
00:24:42 <nand`> but groups are trivially defined in terms of category theory :P
00:30:34 * hackagebot stylish-haskell 0.2.0.1 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.2.0.1 (JasperVanDerJeugt)
00:34:20 <ion> stylish-haskell: ‚ÄúReplaces tabs by four spaces‚Äù ‚Äì FOUR?
00:34:42 <unnali> hahahaha
00:35:35 <nand`> ion: file a bug report, intuition says it should be 8 for GHC compatibility
00:36:27 <ion> For *all* compatibility. The tab stop has a size of eight everywhere.
00:36:56 <nand`> surprisingly, there are editors that have it at 4
00:37:15 <frerich> Oh now *there's* a fruitful discussion topic...
00:37:29 <ion> They‚Äôre utterly broken. Their output looks wrong in everything from terminals to browsers to other text editors. :-)
00:38:15 <geekosaur> ion, losing battle.  that's why tabs are not supposed to be used to indent haskell (or python) code
00:38:25 <geekosaur> *lost* battle, in fact.  years ago
00:39:41 <nand`> https://en.wikipedia.org/wiki/Template:Group-like_structures <- nifty reference :)
00:40:13 <startling> wait, people use tabs in haskell?
00:40:29 <Twisol> I use tabs! One tab holds one file, and another tab holds another.
00:40:37 <nand`> geekosaur: that's not the reason people avoid tabs, it's because indenting by 8 spaces is overkill
00:40:43 <startling> Twisol: and a few with haskellwiki?
00:40:53 <startling> my tab key (emacs, haskell-mode) just lines stuff up
00:40:58 <nand`> startling: a few dozen with hackage docs
00:41:05 <Twisol> Haha. If only SublimeText could load web pages :P
00:41:07 <nand`> mine indents by two spaces :)
00:41:14 <geekosaur> nand`, most editors are "smart" and comvert spaces to tabs.  this is bad.
00:41:17 <Twisol> I use 2-space indentation
00:41:49 <Twisol> 2 is usually enough to make indentation obvious, in my experience
00:42:01 * Ptival too
00:42:01 <Twisol> 3-space is evil
00:42:02 <startling> I use four because of long experience with python
00:42:02 <geekosaur> 4 2-space indents => emacs and vi/vim will substitute a tab
00:42:11 <Twisol> in fact, odd spacing is evil
00:42:16 <startling> everything else looks wrong
00:42:16 <nand`> yeah, also in Haskell I'll often have keywords like ‚Äúwhere‚Äù or ‚Äúlet‚Äù/‚Äúin‚Äù on the ‚Äúhalf-indent‚Äù steps and code itself on ‚Äúfull-indent‚Äù (4) steps
00:42:26 <startling> hmmm, we should indent by ascending primes
00:42:28 <Ptival> though I have a colleague who gets mad when things are only 2-space indented
00:42:47 <Ptival> nand`: right
00:43:16 <nand`> also, small indentation is much better for 80col compatibility
00:43:31 <Twisol> How heretical is this indentation style? http://hpaste.org/69691
00:43:45 <nand`> Twisol: looks very sane to me
00:44:04 <Twisol> Cool. I usually leave the do on the first line and de-dent the rest if there's no where though.
00:44:13 <hpaste> nand` annotated ‚Äúindentation‚Äù with ‚Äúindentation (annotation)‚Äù at http://hpaste.org/69691#a69692
00:44:17 <nand`> This is how I do it
00:44:22 <nand`> but I have to admit, your style looks nice
00:44:43 <Twisol> I see. :)
00:44:56 <nand`> Twisol: yeah, but the whole ‚Äúwhere on the same line‚Äù looks ugly. I think I may have to ‚Äòsteal‚Äô your style for cases where I have a ‚Äúwhere‚Äù after the do block :)
00:45:02 <Twisol> Cool. :D
00:46:47 <nand`> also I'd personally probably write ‚Äúreturn $ intercalate "\n" (map BS.unpack lines)‚Äù in place of your line 5
00:46:56 <Twisol> It works pretty well even if you don't have a do-expression, too. http://hpaste.org/69691
00:47:27 <Twisol> nand`: yeah, I'm sure if I pasted my whole file, none of it would remain the same as I had written it after #haskell got through with it
00:47:40 <nand`> I tend to put ‚Äúthen‚Äù on the same indentation level as ‚Äúelse‚Äù, because you can avoid a lot of headaches that way
00:48:00 <Twisol> Oh?
00:48:08 <nand`> I think there are cases where the former breaks
00:48:24 <nand`> such as if blocks inside do blocks / case .. of -> bodies
00:48:31 <nand`> something like that
00:48:46 <Twisol> incidentally, if you know of any Either function that would let me get rid of that if expression, that would be lovely
00:49:01 <hpaste> ion annotated ‚Äúindentation‚Äù with ‚Äúindentation (annotation) (annotation) (annotation)‚Äù at http://hpaste.org/69691#a69694
00:49:12 <Twisol> ah, I see
00:49:22 <nand`> ion: yeah, something like that
00:49:50 <nand`> @hoogle Bool -> a -> b -> Either a b
00:49:50 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
00:49:50 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
00:49:50 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
00:49:53 <Twisol> I prefer putting a newline after keywords usually, like I did with do and where. If I don't, I usually have to add tons of padding to get it to align.
00:51:51 <nand`> averted with ‚Äúthen‚Äù and ‚Äúelse‚Äù
00:52:44 <nand`> I tend to keep things on the same line except when the body is multiple lines or would extend past 80col
00:52:50 <Twisol> hmm. I admit, my snippet looks better like that.
00:53:32 <nand`> for example, if I'm only defining one thing with ‚Äúwhere‚Äù, I'll keep it on the same line
00:54:31 <nand`> same goes for case/of; if the RHS of -> is one (short) line it'll be the same line
00:54:54 <Twisol> *nod*
00:54:56 <nand`> same goes for conditionals of the form f x | ... =
00:56:29 <Twisol> I tend to hang my function definitions off a newline unless they're really really short.
00:57:35 <nand`> I'll only do that if they would exceed 80col otherwise, or if I have a lot of parameters that should be visually distinct from the body
00:58:06 <nand`> On a related note, Haskell has made me consider the ‚Äú‚Äò,‚Äô at the beginning of a line‚Äù style for enumerations very elegant
00:58:15 <nand`> I used to always have , at the end of a line
00:59:18 <Twisol> I still put , at the end of the line, Haven't seen the light yet I guess :)
01:01:15 <Spockz> dreixel: I just noticed your Google + review on the bike hire shop in Oxford, I guess I'm heading there in a bit :)
01:08:29 <Spockz> dreixel: do you know a place to study/work?
01:17:54 <womb> HI !
01:44:44 <Cale> http://www.twitch.tv/cronikeys?format=html
01:45:14 <Cale> not Haskell related, Super Mario World bug abuse :)
01:45:44 <nand`> Cale: of course it's Haskell related. ‚ÄúWhat happens when you write impure code‚Äù
01:45:46 <Cale> She's triggered a bug which sets Mario's powerup to an invalid value, and really amusing things happen as a result
01:45:53 <Cale> heh, indeed
01:46:49 <Cale> at one point Mario turned into two eggs, and Yoshi's head became a hammer
01:47:19 <Cale> sometimes Mario gets infinite p-balloon, and at the same time, a pumpkin drops to the ground
01:47:21 <nand`> sounds like unsafePerformIO
01:47:28 <nand`> unsafeCoerce*
01:47:51 <Cale> at one point the game crashed with a glitched out intro screen displaying the message "still trapped in an egg"
01:49:03 <Cale> releasing the item in the top area often drops things which are not powerups, like those floating green bubbles (with glitchy textures), or a bird which promptly flies off the screen to the right
01:49:08 <roconnor__> Cale: is this a bug in the game or in the emulator?
01:49:12 <Cale> in the game
01:49:32 <Cale> she's using an emulator to try to understand it well enough to use it for speedruns
01:49:35 <nand`> unsafeCoerce :: Mario -> Egg√óEgg
01:49:35 <Twisol> Is it possible to set the powerup to an invalid value from within the game only?
01:49:40 <Cale> yes
01:49:44 <Twisol> impressive
01:51:42 <Cale> it involves spitting out a null sprite from Yoshi's mouth while on a spinning platform in a particular level
01:52:04 <Cale> I'm not sure how Yoshi is meant to get a null sprite in his mouth, but apparently this is bugception or something :)
01:53:03 <Cale> The bug is called powerup increment 106, because that's what it adds to your powerup number (which is usually only 0,1,2, or 3)
01:53:33 <Twisol> fireball, tanooki, normal-sized-mario, and tiny-mario?
01:53:46 <hiptobecubic> tanooki?
01:53:52 <hiptobecubic> raccoon-bro?
01:53:52 <Twisol> racoon tail
01:53:53 <Cale> small, big, fire, cape
01:54:00 <Cale> respectively
01:54:34 <Twisol> Makes sense.
02:05:41 * hackagebot ghc-mod 1.10.17 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.10.17 (KazuYamamoto)
02:06:28 <fragamus> http://hpaste.org/69688
02:06:58 <fragamus> can anyone see any tighter way to expiress this
02:07:28 <Cale> you could pattern match instead of binding half
02:07:52 <Cale> oh you mean the annotation?
02:09:08 <fragamus> no the annotation seems to change the meaning
02:17:43 <Taneb> Obfuscation is fun!
02:17:47 <Taneb> predXXIV = s (s (k s) (s (k (s (k s))) (s (s (k s) (s (k (s (k s))) (s (k (s (k k))) (s (s (k s) k) (k (s (k (s (k (s i)))) (s (k (s (k k))) (s (k (s i)) k)))))))) (k (k k))))) (k (k (k i)))
02:18:18 <Twisol> How common (or alternatively, how bad of an idea) is it to redefine an existing function? Like, I want to make (++) a synonym for mappend. Good idea or bad idea?
02:18:29 <Cale> Taneb: now write that using pure and (<*>)
02:18:36 <Botje> it's what caleskell does.
02:18:56 <Taneb> Cale, it essentially is, to do that, I'd just need to do a find+and+replace
02:19:02 <Taneb> s and k are just easier to think about
02:19:18 <Cale> Taneb: I know :)
02:19:30 <sopvop> Twisol: mappend already has (<>). Also `import Prelude hiding (++)'
02:19:44 <Twisol> had no clue about (<>). O_o
02:20:00 <Twisol> yeah, I know about the hiding trick - just wasn't sure whether it's the kind of thing I should be doing
02:20:10 <Taneb> Like, literally, I have a the top of the page, s = (<*>) :: (a -> b -> c) -> (a -> b) -> a -> c; k = pure :: a -> b -> a
02:21:33 <Twisol> sopvop: where is (<>) defined?
02:21:51 <Taneb> @hoogle (<>)
02:21:52 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
02:21:52 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
02:21:52 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
02:21:57 <Taneb> None of those :)
02:22:13 <Taneb> @hoogle Data.Semigroup.(<>)
02:22:14 <lambdabot> Parse error:
02:22:14 <lambdabot>   Data.Semigroup.(<>)
02:22:14 <lambdabot>       ^
02:22:46 <donri> @hoogle (Data.Semigroup.<>)
02:22:46 <lambdabot> Parse error:
02:22:46 <lambdabot>   (Data.Semigroup.<>)
02:22:46 <lambdabot>        ^
02:22:52 <Twisol> semigroup seems to have <++>
02:22:56 <sopvop> I was sure it was also synonym to mappend, without semigroups package. Maybe i'm wrong though :)
02:23:03 <Twisol> and .++.
02:23:37 <donri> sopvop: it is, in base 4.5
02:24:14 <sopvop> And for semigroups (<>) is a class functions http://hackage.haskell.org/packages/archive/semigroups/0.8.3.2/doc/html/Data-Semigroup.html
02:25:19 <sopvop> And yes, in base 4.5 in Data.Monoid (<>) :: Monoid m => m -> m -> m
02:32:01 <Lemmih> Cale: Is she trying to do something or is she just running around?
02:34:28 <Cale> Lemmih: She's testing what she can get each of the powerups to do, and see if there are repeatable effects which might be useful for speedruns
02:34:43 <Cale> also, she's done a bit of trying to compose this glitch with other known glitches
02:35:28 <Cale> It's mostly just really amusing because of all the crazy stuff that happens
02:38:14 <Twisol> What does "base 4.5" refer to?
02:39:08 <ocharles> Twisol: version 4.5 of the 'base' library
02:39:08 <Twisol> nevermind, I found it
02:39:25 <Twisol> How can I tell which version I have?
02:39:37 <donri> ghc-pkg latest base
02:40:11 <Twisol> 4.3.1. Is it usually a good idea to keep base updated?
02:40:29 <donri> base is bundled with ghc/platform
02:40:39 <Cale> You can't update it on its own
02:40:39 <donri> 4.5 comes with ghc 7.4
02:40:50 <Twisol> Ahhh.
02:43:09 <hpaste> foo annotated ‚ÄúGOLF!!!‚Äù with ‚ÄúGOLF!!! (annotation) (annotation)‚Äù at http://hpaste.org/69688#a69699
02:45:10 <Twisol> guess I have to wait for the next Haskell Platform then
03:01:44 <Taneb> I've got my Applicative factorial program working
03:01:57 <Taneb> But now it sounds like my computer is going to explode working out 10!
03:02:11 <Taneb> > product [1..10]
03:02:12 <lambdabot>   3628800
03:02:21 <Taneb> (imagine that, in unary)
03:02:30 <Taneb> (being unsafeCoerce'd all over the place)
03:03:35 <Botje> if you're cold, just turn up the heating!
03:03:44 <Botje> no need to punish your poor processor like that
03:25:31 <pippa> hi
03:36:24 <Taneb> What does "skolem" mean?
03:37:13 <mysticc> @where applicative
03:37:13 <lambdabot> http://darcs.haskell.org/packages/base/Control/Applicative.hs
03:37:31 <pippa> http://en.wikipedia.org/wiki/Skolem_normal_form
03:37:36 <mysticc> Where is the paper for applicative functors ?
03:39:07 <x26s> hello
03:39:59 <Taneb> Hey
03:40:10 <Saizan> mysticc: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.106.4830
04:02:28 <Taneb> I wish to report a very odd bug in GHC
04:03:00 <Taneb> Commenting out a function which is unused breaks compilation
04:03:20 <Peaker> Taneb, Do you have the monomorphism restriction turned on?
04:03:27 <Taneb> No
04:03:35 <Peaker> Taneb, have you explicitly turned it off?
04:03:40 <Taneb> No
04:03:44 <Peaker> then it's turned on
04:03:45 <Peaker> :)
04:03:51 <Taneb> Yeah, I misthought
04:04:17 <Peaker> Taneb, basically if you have:     x <no args here> = <something polymorphic here>     it kicks in the MR. The type 'x' will get depends on the use-sites of 'x'. one of which may be a function you later comment out
04:04:36 <Taneb> Okay
04:04:39 <Peaker> Taneb, can you paste the module this happens in?
04:04:49 <Peaker> Taneb, and/or try compiling with -XNoMonomorphismRestriction
04:05:43 <Taneb> Nevermind, I sorted it
04:06:02 <Taneb> I'm removing all the functions I don't need, and the one that it broke I don't need
04:11:19 <Taneb> Okay, who's a fan of obfuscation?
04:11:26 <mroman> \o
04:11:50 <hpaste> Taneb pasted ‚ÄúObfuscation!‚Äù at http://hpaste.org/69700
04:12:28 <Taneb> Applicatives teaming up with unsafeCoerce are unstoppable!
04:12:53 <Taneb> (factorial function, don't use with numbers more than 9 because it will take too long)
04:13:52 <adamt> Taneb: I think most people take pride in writing concise code, and not slow and obfuscated code :-)
04:14:01 <Taneb> You know it's obfuscated where there's one line with any code and it's over 1000 characters long
04:14:42 <Taneb> adamt, I can write code that's a million times more efficient and readable than that with my eyes closed.
04:15:13 <mroman> hlint is freaking out ;)
04:16:29 <Taneb> For the same reason every time
04:16:53 <Taneb> Which actually make it more obfuscated
04:17:45 <Taneb> main = putStrLn "Input number" >> (readLn :: IO Int) >>= (print . product . enumFromTo 1) >> main
04:17:48 <Taneb> does the same thing better
04:17:52 <Taneb> But it's less fun
04:18:08 <Taneb> Or even:
04:18:19 <Taneb> No wait, you need to import Control.Monad for that
04:19:17 <adamt> Taneb: It wasn't a critique of your skills, I just don't get why obfuscation is so funny :-)
04:19:28 <Taneb> It's a challenge
04:19:43 <Taneb> You need to know exactly what you've done and exactly what you're planning to do
04:22:23 <Taneb> I think this works on compilers other than GHC, too
04:22:28 <Taneb> Haven't tested, though
04:23:45 <Taneb> No, Hugs doesn't seem to have unsafeCoerce?
04:26:44 <quicksilver> unsafeCoerce only works the way they do because of GHC's exact data model
04:27:02 <quicksilver> other compilers with different data storage choices it might not be meaningful at all or it might behave differently.
04:27:04 <Peaker> what does the unsafeCoerce do here?
04:27:21 <Peaker> convert what type to what type with what mapping?
04:27:34 <Taneb> It allows functions to take themselves as input without driving the type checker insane
04:27:47 <Peaker> well, newtype can do that too
04:28:11 <Peaker> newtype F a b = F (F a -> b)
04:28:20 <Peaker> oops
04:28:22 <Taneb> Do I sound like the kind of person who'd use newtype when there's a combinator matching to one of SKI's?
04:28:23 <Peaker> F a b -> b that is
04:28:33 <Peaker> heh
04:28:48 <Taneb> I've used it where I could use id also
04:30:12 <Taneb> But with unsafeCoerce, the (->) r Applicative is Turing complete
04:31:06 <Taneb> And I believe (unsafeCoerce <*> id) is equivalent to fix
04:31:17 <Taneb> > (unsafeCoerce <*> id) (1:)
04:31:18 <lambdabot>   Not in scope: `unsafeCoerce'
04:31:28 <Taneb> > fix (:1)
04:31:29 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
04:31:33 <Taneb> > fix (1:)
04:31:34 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:33:24 <hpc> :t fix Mu
04:33:25 <lambdabot> Not in scope: data constructor `Mu'
04:33:28 <hpc> :t fix In
04:33:29 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
04:33:29 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `f :: * -> *'
04:33:29 <lambdabot>       Expected type: f (Mu f)
04:33:42 <hpc> :t In
04:33:43 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
04:34:10 <Taneb> :t fix unsafeCoerce
04:34:11 <lambdabot> Not in scope: `unsafeCoerce'
04:34:13 <Taneb> :t fix id
04:34:14 <lambdabot> forall a. a
04:34:22 <Taneb> That is why fix is a bad function
04:34:31 <hpc> :t fix (In :: (Mu f) -> (Mu f))
04:34:31 <Taneb> (by my definition of bad)
04:34:32 <lambdabot>     Couldn't match kind `* -> *' against `(* -> *) -> *'
04:34:32 <lambdabot>     When matching the kinds of `f :: * -> *' and `Mu :: (* -> *) -> *'
04:34:33 <lambdabot>       Expected type: Mu f1
04:34:53 <hpc> argh
04:35:25 <hpc> :t (In :: (Mu f) -> (Mu f)
04:35:27 <lambdabot> parse error (possibly incorrect indentation)
04:35:29 <hpc> :t (In :: (Mu f) -> (Mu f))
04:35:30 <lambdabot>     Couldn't match kind `* -> *' against `(* -> *) -> *'
04:35:30 <lambdabot>     When matching the kinds of `f :: * -> *' and `Mu :: (* -> *) -> *'
04:35:30 <lambdabot>       Expected type: Mu f1
04:35:31 <hpc> huh
04:39:43 <Gab1one> hey folks, can anyone tell me how I cani deconstruct an algebraic datatype with patternmatching, when I want all occurences of a certain type in a bigger expression, but the position of these occurences is not fixed?
04:40:14 <Gab1one> eg. a datatype that represents lambda expressions
04:40:43 <roconnor_> Gab1one: I'm a bit confused.
04:40:49 <Gab1one> im too
04:41:00 <roconnor_> ``when I want all occurences of a certain type in a bigger expression, but the position of these occurences is not fixed?
04:41:08 <Gab1one> yeah
04:41:15 <roconnor_> I cannot understand this
04:41:29 <roconnor_> well, I might, but I'm not certain
04:41:31 <luite> Gab1one: there isn't a way to do that directly with pattern matching, but i think what you might want is something like syb
04:41:43 <roconnor_> Gab1one: or maybe uniplate
04:41:59 <Gab1one> okay
04:42:37 <Gab1one> >type Name = String
04:42:37 <Gab1one> >data LExpr = Var Name
04:42:37 <Gab1one> >			| Constant Integer
04:42:37 <Gab1one> >			| Lambda Name LExpr
04:42:37 <Gab1one> >			| Appl LExpr LExpr
04:42:40 <Peaker> @index unsafeCoerce
04:42:41 <lambdabot> bzzt
04:42:53 <hpc> @where hpaste
04:42:53 <lambdabot> http://hpaste.org/
04:43:24 <hpaste> Gab1one pasted ‚Äúlambda‚Äù at http://hpaste.org/69702
04:43:44 <Gab1one> i know want to acces all occurences of Var
04:43:55 <Peaker> Taneb, (unsafeCoerce <*> id) (1:) :: [Int]  =  [1]   in my ghci
04:43:59 <Gab1one> so i can filter them
04:44:04 <Taneb> Hmm
04:44:34 <Taneb> Okay, I'm wrong
04:44:42 <roconnor_> Gab1one: sounds to me like you might want uniplate or one of the other *plate libraries
04:44:45 <fabjan> Gab1one: traversing the LExpr tree collecting a list of vars?
04:45:01 <Gab1one> f x y woud look like this :(Appl (Appl (Var "f") (Var "x)) (Var "y"))
04:45:16 <luite> Gab1one: yeah that's generic programming terrain, you could use syb listify to get a list of all Var
04:45:23 <Gab1one> okay
04:46:19 <Gab1one> thank you very much
04:46:33 <luite> Gab1one: though if you don't have more types than this, you can just fold manually
04:48:06 <Taneb> Peaker, I had it about half an hour ago...
04:48:22 <dzhus> can anyone confirm this issue https://github.com/bos/mwc-random/issues/16?
04:50:06 <hpc> seems someone already has confirmed it
04:50:43 <dzhus> it's just really strange issue
04:51:06 <dzhus> `VU.replicateM count $ standard g` runs for 0.1 sec
04:51:17 <dzhus> `VU.replicateM count $ liftM (*3) $ standard g` runs for 10 sec
04:51:22 <dzhus> how so?
04:51:28 <ocharles> If I have a graph with nodes A, B, C, D and edges A->B, A->C, B->D, C->D, is there a name for the property that it doesn't have any cycles?
04:51:28 <hpc> i think it does something in (>>=) and return which makes it not optimizable
04:51:40 <ocharles> Ie, A->B->D leaves me with no more edges to follow
04:51:55 <hpc> and normal just does more math than it needs to
04:52:29 <hpc> ocharles: directed acyclic graph
04:52:33 <hpc> or DAG
04:53:09 <ocharles> hpc: oh, that's what the acyclic bit means I guess :)
04:53:49 <hpc> well, you also need 'directed', otherwise you don't know which way is "up"
04:54:18 <ocharles> ah
04:54:19 <hpc> ie, you could go A->B->D->A
04:54:49 <ocharles> well there is no D->A edge so I don't think you could do that, but you could do A->B->A
04:54:59 <hpc> ah, yeah that
04:58:23 <morel> on debian gnu/linux, i downloaded the GHC-binary and installed it manually myself. how do/can i remove (all files of) GHC now?
05:00:26 <Eduard_Munteanu> morel: what does installing consist of? Unpacking an archive?
05:01:32 <morel> Eduard_Munteanu: yea, i downloaded the latest binary-package, unpacked it, joined the dir, and did something like "(sudo) make install" or so‚Ä¶
05:01:50 <deggis> quickCheck & IO: i'm testing RWST IO a monadic function and i've built a test case returning IO Bool. it seems this is not the way to go testing it: quickCheck (monadicIO $¬†run (return False :: IO Bool))
05:02:11 <geekosaur> I *think* if you unpack again you can "make uninstall" with the same options (if any) you used the first time
05:02:14 <deggis> (return False as the test case)
05:02:45 <morel> Eduard_Munteanu: i'm wondering whether it's enough to do "rm -rf /usr/local/lib/ghc-7.4.1/" and "rm /usr/local/bin/ghc*" and "rm -rf /home/morel/.ghc/ghc-7.4.1/" or so‚Ä¶
05:02:54 <morel> geekosaur: cool.
05:03:13 <Eduard_Munteanu> If it ended up in /usr/local maybe you can erase that completely.
05:03:22 <morel> geekosaur: nope, no rule for "uninstall".
05:03:25 <Eduard_Munteanu> (if you didn't install other stuff in there)
05:03:42 <geekosaur> hrm.  sad; I thought hat used to be part of the binary installer
05:04:45 <TheLemonMan> Whats the difference between TVar and MVar in layman terms
05:04:48 <morel> hm, okay. i'll just do as i said then.
05:05:25 <hpc> TheLemonMan: MVar is a mutex, TVar is basically "IORef for STM"
05:05:30 <deggis> ah, i was misusing things. solved that quickcheck thing
05:06:25 <hpc> https://en.wikipedia.org/wiki/Software_transactional_memory -- for more info
05:09:53 <morel> what's actually bad about always using --global option for cabal?
05:11:05 <saep> you need root priviliges and you may f*** up the packages for other users (the first one is just unneccessary overhead)
05:11:25 <morel> saep: i'm the only user on my PC.
05:12:39 <morel> saep: well, okay, then it's unnecessary to install with --global at all, right. =)
05:14:18 <saep> Yep, just make sure you have $HOME/.cabal/bin in your $PATH.
05:14:31 <morel> yep.
05:15:10 <byorgey> morel: it's also convenient to leave all the basic packages (i.e. the ones that come with GHC and/or the Haskell Platform) in the global package DB, and then always install into the user package DB.
05:15:41 <byorgey> morel: that way you (1) don't screw up the foundational packages, and (2) if things get screwed up you can easily just delete the user package DB without having to reinstall the entire Haskell Platform
05:16:42 <morel> byorgey: yeah, excellent. i'll do that.
05:19:09 <Taneb> There's no such thing as safeCoerce
05:19:26 <morel> Taneb: but unsafeCoerce
05:19:45 <tomboy64> i'm a newbie. i want to handle bitwise data passed either via STDIN or a file being opened and read.
05:19:52 <morel> Taneb: what are you trying to coerce/convert/transform/do?
05:20:01 <Taneb> Nah, I'm just thinking
05:20:07 <morel> ah. hehe :D
05:20:09 <tomboy64> should i just treat the stuff as Chars and convert them somehow? or is there a saner way to do that?
05:20:28 <Taneb> tomboy64, maybe ByteString?
05:20:32 <tomboy64> (i presume Chars are 8bit wide and unicode doesn't get involved)
05:20:34 <tomboy64> hmmm
05:20:40 <tomboy64> gonna have a look at that
05:21:51 <luite> Taneb: cast
05:22:02 <Taneb> @hoogle cast
05:22:02 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
05:22:02 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
05:22:02 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
05:22:30 <luite> Taneb: not quite the same type (if you ignore the Maybe) because of the extra Typeable constraints
05:22:42 <morel> luite, Taneb: Convertible form package convertible is nice, too.
05:22:49 <morel> @hoogle convert
05:22:49 <lambdabot> Network.Socket ConvertedToHandle :: SocketStatus
05:22:49 <lambdabot> package convertible
05:22:49 <lambdabot> package convertible-text
05:22:58 <morel> http://hackage.haskell.org/packages/archive/convertible/1.0.11.1/doc/html/Data-Convertible-Base.html
05:23:55 <tomboy64> Taneb: looks good, thank you
05:24:00 <rtharper> how does one usually cite GHC in a paper?
05:24:20 <Taneb> tomboy64, you're welcome
05:24:58 <morel> tomboy64: i don't think byteString is what you are looking for. it doesn't have to do with "bytes" or "binary" stuff.
05:25:37 <Taneb> morel, Data.ByteString.head gets a Word8
05:25:51 <Axman6> @src fromIntegral
05:25:51 <lambdabot> fromIntegral = fromInteger . toInteger
05:26:21 <geekosaur> actually it's entirely possible you do want ByteString, plus the binary package
05:26:29 <Taneb> And it's a lot better than just using String and Char, which are sort of Unicode
05:27:12 <morel> hm. okay, fine. sorry‚Ä¶
05:27:34 <Taneb> > show '\955'
05:27:35 <lambdabot>   "'\\955'"
05:27:44 <Taneb> @src putChar
05:27:44 <lambdabot> putChar c = hPutChar stdout c
05:28:00 <Taneb> putChar '\955' prints a lambda
05:28:33 <tomboy64> morel: well, i intend to take data and mangle it bytewise. the input data must be somehow converted to Word32/Word64 types.
05:28:53 <tomboy64> with that i can work then.
05:32:03 <Taneb> > (\w x y z -> (fromIntegral w `shiftL` 24) + (fromIntegral x `shiftL` 16) + (fromIntegral y `shiftL` 8) + (fromIntegral z)) (10 :: Word8) 11 3 230 :: Word32
05:32:04 <lambdabot>   168494054
05:32:05 <morel> tomboy64: ah, OK.
05:33:04 <Taneb> > 1917 + 95
05:33:06 <lambdabot>   2012
05:45:52 <Lajla> Is there a seen option on this channel?
05:46:16 <Lajla> Like '.seen :random username:' for some bot to handle?
05:46:22 * hackagebot Frank 0.3 - An experimental programming language with typed algebraic effects  http://hackage.haskell.org/package/Frank-0.3 (ConorMcBride)
05:46:52 <Taneb> ?seen Lajla
05:46:52 <lambdabot> Unknown command, try @list
05:46:58 <Taneb> .seen Lajla
05:47:01 <morel> preflex: seen Lajla
05:47:02 <preflex>  Lajla was last seen on #haskell 45 seconds ago, saying: Like '.seen :random username:' for some bot to handle?
05:47:03 <Lajla> @list
05:47:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:47:09 <morel> Lajla: like that.
05:47:09 <Taneb> That one
05:47:17 <Lajla> Danke sehr.
05:47:22 <Lajla> preflex: seen Elliott
05:47:22 <morel> hehe :D
05:47:22 <preflex>  Elliott was last seen on #haskell 1 day, 20 hours, 22 minutes and 2 seconds ago, saying: that's good :)
05:47:59 <Taneb> Lajla, he's on other channels, if you use lambdabot's @ask or @tell he should get it
05:48:09 <Taneb> Wait, that was only just two days agi
05:51:24 <astroboy> Taneb: or you can simply use /whois <nick>
05:51:46 <Taneb> Wow, I can
05:51:49 <Taneb> didn't know that
05:54:07 <byorgey> although that only works for people who are currently logged in
05:55:01 <Saizan> sometimes you get a whowas
05:55:14 <geekosaur> some clients support a /whowas for recently seen nicks
05:55:46 <morel> mine has even /whoami =)
06:03:53 <mikeplus64> what's the most convenient way to change a typeclass instance's definition for a specific function?
06:04:19 <opqdonut> a newtype + a new instance is the only way
06:04:26 <opqdonut> unless you want to edit the original definition
06:04:54 <mikeplus64> ok
06:06:04 <opqdonut> in the instance for the newtype you can of course easily delegate to the original definitions
06:06:26 <morel> hi ski :)
06:09:59 <Peaker> mikeplus64, what function did you want to change? If you need to change a specific function it sounds like something might be weird/off
06:11:49 <mikeplus64> Peaker: i'm changing the description function for ResizableTile in XMonad because "ResizableTall" is too long
06:14:00 <morel> mikeplus64: btw, i look at MouseResizeableTile, too. it's like ResizeableTile but supports mouse, too.
06:14:22 <morel> s/i //
06:14:30 <mikeplus64> morel: with an even larger name too!
06:14:35 <morel> yea :D
06:15:19 <morel> additionally, you'd probably want to use "mouseResizableTile { draggerType = BordersDragger }" instead of just "mouseResizableTile"‚Ä¶
06:16:24 * hackagebot GTALib 0.0.6 - A library for GTA programming  http://hackage.haskell.org/package/GTALib-0.0.6 (KentoEmoto)
06:16:52 <statusfailed> Is there a function to give all the combinations of a list's elements?
06:17:17 <Peaker> statusfailed, what are combinations?
06:17:18 <statusfailed> e.g, f [1,2] == [[1,1],[1,2],[2,1],[2,2]]
06:17:22 <statusfailed> sorry, slow typer
06:17:23 <statusfailed> hehe
06:17:37 <Peaker> hmm, why [1,1] and not [1,1,1] ?
06:17:37 <Lemmih> @type Data.List.permutations
06:17:38 <lambdabot> forall a. [a] -> [[a]]
06:17:49 <Peaker> if it was permutations it would be [1,2] == [[1,2],[2,1]]
06:18:14 <statusfailed> Peaker: oops, I forgot the "specify length" bit
06:18:16 <statusfailed> I assumed 2 there
06:18:22 <Peaker> > let f xs = replicateM (length xs) xs in    f [1,2]
06:18:23 <lambdabot>   [[1,1],[1,2],[2,1],[2,2]]
06:18:40 <morel> wow.
06:18:45 <Peaker> basically you're looking for replicateM, probably
06:19:25 <statusfailed> i'm not sure how that function works :|
06:19:29 <morel> > replicateM 10 [1,2]
06:19:30 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,2],[1,1,1,1,1,1,1,1,2,1],[1,1,1,1...
06:19:41 <Peaker> @type replicateM
06:19:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
06:19:51 <Peaker> replicateM performs an action N times (for some given N) and returns all the results
06:19:53 <morel> Int -> [a] -> [[a]]
06:20:00 <Peaker> the "xs" action is basically "choose some x"
06:20:08 <morel> ah
06:20:13 <Peaker> so you "choose some X" n times, you get all possible choice combinations
06:20:35 <morel> > replicateM 3 [1,2]
06:20:37 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
06:21:07 <morel> > replicateM 3 "01" -- it's like counting in binary!
06:21:08 <lambdabot>   ["000","001","010","011","100","101","110","111"]
06:21:13 <morel> coool
06:21:34 <statusfailed> I think that's just raised more questions than it answered :p
06:21:40 <statusfailed> Peaker: thanks though :D
06:22:04 <Peaker> the list monad may seem mysterious at first :)
06:22:30 <tromp_> [] is like a loop and replicateM makes n nested loops
06:22:43 <morel> @src [] >>=
06:22:43 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:23:17 <morel> how can i make lambdabot say me how [] is made an instance of Monad?
06:23:18 <astroboy> @src >>= []
06:23:19 <lambdabot> Source not found. Maybe you made a typo?
06:23:25 <astroboy> @src [] (>>=)
06:23:26 <lambdabot> xs >>= f     = concatMap f xs
06:23:29 <morel> ah =)
06:23:43 <morel> @src [] return
06:23:44 <lambdabot> return x    = [x]
06:23:47 <morel> @src Monad
06:23:48 <lambdabot> class  Monad m  where
06:23:48 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
06:23:48 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
06:23:48 <lambdabot>     return      :: a -> m a
06:23:48 <lambdabot>     fail        :: String -> m a
06:23:54 <statusfailed> It's the implementation of 'sequence' I don't get, heh
06:24:01 <morel> @src [] (>>)
06:24:01 <lambdabot> xs >> ys      = concatMap (const ys) xs
06:24:20 <morel> statusfailed: sequence? is easy.
06:24:22 <morel> @type sequence
06:24:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:24:33 <morel> @src sequence
06:24:33 <lambdabot> sequence []     = return []
06:24:33 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:24:33 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
06:28:58 <TheLemonMan> do i always need 'atomically' for operating on mvars, even when i know i'm the only one accessing it ?
06:29:45 <geekosaur> ..."atomically" is part of STM, not MVars.  or do you mean the atomic*MVar functions?  Or TMvars?
06:29:53 <otters> @src sequence
06:29:53 <lambdabot> sequence []     = return []
06:29:53 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:29:53 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
06:30:34 <TheLemonMan> geekosaur, ops, i meant TMVar
06:34:20 <geekosaur> "atomically" performs an STM transaction, resulting in an IO action; that's the only way to "commit" an STM transaction.  if you're using it in multiple places, you may want to refactor so more things happen in a given transaction
06:36:25 * hackagebot hsemail 1.7.2 - Internet Message Parsers  http://hackage.haskell.org/package/hsemail-1.7.2 (PeterSimons)
06:37:05 <TheLemonMan> its create tmvar -> spawn many threads with the var as argument -> wait for the threads to end -> read back the tmvar
06:41:36 <hpaste> J3ssi pasted ‚Äúarrays‚Äù at http://hpaste.org/69704
06:42:19 <aleator_> Anyone know a way to compare GHC.Type's using ghc-api?
06:42:22 <j3ss1> can somebody tell me how to check what value the first position of the array has and change it ?
06:43:21 <aleator_> j3ss1: 'array ! 0' to get the first element. Changing it depends on your array type
06:43:38 <arnsholt> j3ss1: You get the element at an index with the ! operator. One way to construct a new one from the previous one is the // operator
06:43:42 <aleator_> Or zeroth element anyways
06:44:20 <aleator_> if youre using lists then it is ' list !! 0', or rather, ‰head'
06:44:27 <j3ss1> thanks ;)
06:45:19 <morel> j3ss1: also, you should probably import Data.Array instead of Array. it's the same module but a better name.
06:46:17 <j3ss1> i am trying to read my first more than a bit of list comprehension in haskell so thanks for the help .... should be a soduko solver at the end
06:46:40 <j3ss1> -read +write
06:48:36 <fabjan> aleator_: I don't think zeroth is a word
06:50:01 <aleator_> fabjan: Aimed at zeroeth with that. Thats almost a word.
06:52:36 <teneen> Do recent versions of ghc do list fusion automatically, or I have to use the functions from Data.List.Stream to get this?
06:54:46 <geekosaur> list fusion has been standard for several years
07:01:26 * hackagebot codemonitor 0.2 - Tool that automatically runs arbitrary commands when files change on disk.  http://hackage.haskell.org/package/codemonitor-0.2 (RickardLindberg)
07:03:47 <teneen> geekosaur: so the stream-fusion package is useless now?
07:04:18 <rwbarton> as i understand it (someone correct me if i am wrong) there are two kinds of fusion, build/foldr fusion and stream fusion
07:04:59 <rwbarton> the first kind is built into GHC (or more accurately, into GHC's version of Prelude/Data.List/etc. via RULES)
07:06:27 * hackagebot doctest 0.7.0 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.7.0 (SimonHengel)
07:08:39 <hepek> hi guys, have you ever used Haskell GStreamer bindings?
07:09:32 <morel> hepek: best ask the concrete question.
07:10:12 <hepek> morel: when I test a graph from gst-launch ximagesink displays a new window
07:10:25 <hepek> when I do the same thing from ghci it Segfaults
07:10:33 <hepek> whereas if I compile and run the app
07:10:45 <hepek> it seems to be working, but no ximagesink window
07:11:01 <hepek> I am using Glib.mainLoop to block in main
07:11:03 <geekosaur> teneen, it was a technology demo; not only are the relevant fusions built into ghc now, but more and better versions are built in
07:11:05 <hepek> and handle events
07:11:25 <geekosaur> but there's no deprecation in hackage currently (I think hackage2 is supposed to fix this)
07:11:30 <dmwit_> Running gtk-based code in ghci is a bit dangerous; ghci uses threads in a slightly less predictable way than a compiled program does.
07:11:47 <dmwit_> I really should have learned more about that so I could say something more concrete right there.
07:12:33 <dmwit> Haven't seen that exact problem with a compiled program, though; perhaps you should share enough code for us to reproduce the problem.
07:13:40 <statusfailed> Hmm. I feel like the "replicateM" trick discussed earlier is ... not obvious. Is that true, or do I just need more experience?
07:14:26 <Peaker> statusfailed, it's "obvious" if the list monad is understood
07:14:44 <Peaker> statusfailed, but it's not typical beginner material. I remember being overwhelmed by the magic of the list monad :)
07:15:00 <statusfailed> Well, I thought I understood the list monad
07:15:06 <statusfailed> and I get the individual bits of what's going on
07:15:13 <mzero> statusfailed: you just need experience
07:15:22 <mzero> we all felt that way the first time someone showed us replicateM
07:15:23 <geekosaur> that ghci segfault:  try ghci --no-ghci-sandbox ?
07:16:00 <rwbarton> IMO it's a good idea at some point to go through basically every combination of standard monad function and monad, and see what they do :)
07:16:18 <rwbarton> since the resulting functions have a way of being useful
07:16:52 <morel> @src [] (>>)
07:19:50 <hepek> geekosaur: I don't have that option in ghci, im running 6.12 on a fairly old system
07:19:57 <hepek> here's my gstreamer test http://hpaste.org/69705
07:20:33 <quicksilver> morel: m >> k              = foldr ((++) . (\ _ -> k)) [] m
07:20:40 <quicksilver> morel: from http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html
07:21:04 <quicksilver> morel: @src is really not very useful; learning to browse the docs + src is better.
07:21:11 <statusfailed> Alright, i'll just chalk this up to inexperience and go refresh my monads :D
07:21:15 <morel> quicksilver: OK. thanks =)
07:21:28 <statusfailed> Peaker, thanks again for the help :)
07:21:35 <statusfailed> (and everyone else!)
07:22:39 <geekosaur> in that case you might be triggering compiler bugs...
07:27:26 <dmwit> hepek: "test.hs:35:49: Not in scope: `mdspproc'"
07:27:30 <dmwit> ?
07:27:55 <hepek> dmwit: that's my filter
07:28:14 <hepek> dmwit: you can safely replace it with, say, videoscale
07:28:31 <dmwit> That doesn't seem to be in scope, either.
07:29:21 <hepek> dmwit: missunderstanding, just a sec, i'll post a correction
07:31:00 <hepek> dmwit: http://hpaste.org/69706
07:32:45 <dmwit> um
07:32:52 <dmwit> did you mean to put something on the main loop?
07:33:03 <dmwit> It's just an empty loop right now...
07:34:13 <morel> why do i get "unrecognized option `--disable-benchmarks'" when i try to install Epic from source (https://github.com/edwinb/EpiVM) (with cabal-install version 0.14.0 using version 1.14.0 of the Cabal library) (with GHC 7.4.1)?
07:34:16 <otters> we should change the "w" in the type signature of Comonad to …Ø
07:34:56 <hepek> dmwit: well, it waits for Ctrl+C :) I meant to handle some events and introduce random seeking, pausing etc to test my filter
07:34:59 <dcoutts> morel: what command are you running exactly?
07:35:05 <morel> dcoutts: cabal install
07:35:37 <morel> dcoutts: which command should i use?
07:36:35 <dcoutts> morel: that really should work, does here with 0.14.0
07:36:55 <dcoutts> morel: you're quite sure, that's the version, and e.g. cabal install --help lists the option?
07:37:22 <matthiasgorgens> @pl (.:) f g a b = f (g a b)
07:37:40 <matthiasgorgens> What happened to the bot?
07:37:49 <dmwit> hepek: Huh, the "hello world" for gstreamer that I just looked up *also* uses an empty main loop.
07:37:54 <dmwit> that's really weird
07:38:04 <morel> dcoutts: no, it doesn't list such an option.
07:38:07 <matthiasgorgens> dmwit: threads behind your back?
07:38:49 <dcoutts> morel: oh, my version here is using version 1.14.1 of the Cabal library, perhaps that's it
07:39:21 <hepek> dmwit: well, gstreamer calls are non-blocking, I think they're using main loop to block the program from exiting
07:39:25 <morel> dcoutts: well, IIRC i was able to compile Epic with an even older version of cabal‚Ä¶ :/
07:39:36 <dcoutts> hm, no we didn't add it in 1.14.1
07:40:14 <hepek> morel: you can try editing the cabal package and removing the offending command line option -- that's what I did a few days back for a similar problem
07:40:55 <dcoutts> hepek: this is a flag passed to cabal install itself (unless I completely misunderstood morel)
07:40:56 <morel> hepek: yea, but i can't find the option in any of Makefile, Setup.hs and epic.cabal!
07:41:18 <morel> dcoutts: i just type "cabal install" and get that error.
07:41:19 <dcoutts> morel: wait, you're not passing it on the cabal install command line?
07:41:22 <dmwit> matthiasgorgens: seems so =)
07:41:31 <dcoutts> morel: is it in your ~/.cabal/config ?
07:41:32 <morel> dcoutts: exactly
07:41:47 <dcoutts> morel: or a shell alias or something
07:42:02 <morel> $ cat ~/.cabal/config  | grep benchmark
07:42:02 <morel> -- benchmarks: False
07:42:59 <morel> dcoutts: no shell-alias.
07:43:06 <dcoutts> morel: that's really odd
07:43:38 <dcoutts> morel: can you post a log of the commandm including  the exact error
07:44:36 <dmwit> hepek: Well, I'm definitely not a gstreamer expert.
07:45:00 <hpaste> morel pasted ‚Äúepic error‚Äù at http://hpaste.org/69707
07:45:01 <hepek> dmwit: neither am I :) that's why i'm asking
07:45:03 <dmwit> hepek: But as a next step, maybe you'd enjoy looking at the example application that's bundled with the gstreamer package and see what it does differently from yours.
07:45:07 <morel> dcoutts: ‚Üë
07:45:18 <hepek> thnx
07:45:41 <hepek> i'll do that
07:46:04 <dcoutts> morel: can you re-run with cabal install -v3. I can tell from the error message that it is not being reported by cabal itself, but something else.
07:46:20 <dcoutts> morel: cabal does not use the `' style of quoting
07:46:37 <dmwit> hepek: Even the sample application seems to do audio only, though, so gstreamer may need you to start your own window and ask it to attach to that or some such thing.
07:46:40 <dmwit> dunno for sure
07:47:29 <morel> dcoutts: i re-cloned the repository.
07:47:32 <hepek> I think I need to initialize Gtk or something
07:47:35 <morel> dcoutts: it works now!
07:47:55 <morel> dcoutts: i am very sorry to have wasted your time‚Ä¶ foo!
07:48:06 <morel> dcoutts: thank you very much! thanks man! thank you :)
07:48:15 <morel> dcoutts: excuse me for my stupid fault‚Ä¶
07:48:18 <otters> @bot
07:48:40 <morel> lambdabot's away. at the toilet‚Ä¶
07:49:29 <dcoutts> morel: but you never found where it was sneaking in?
07:49:40 <morel> no :D
07:50:04 <dcoutts> ah well
07:54:05 <mhwombat> @help
07:56:31 * hackagebot swift-lda 0.4.1 - Online sampler for Latent Dirichlet Allocation  http://hackage.haskell.org/package/swift-lda-0.4.1 (GrzegorzChrupala)
07:56:33 * hackagebot colada 0.4.3 - Colada implements incremental word class class induction  using online LDA  http://hackage.haskell.org/package/colada-0.4.3 (GrzegorzChrupala)
07:57:14 <mhwombat> preflex: list
07:57:14 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
07:57:15 <preflex>  ZCode: [zdec, zenc]
08:00:46 * morel still doesn't know who runs lambdabot‚Ä¶
08:01:33 <mhwombat> ?bot
08:02:03 <sipa> cale?
08:03:15 <morel> sometimes, when i install something with cabal, i get a compiler warning like ‚ÄúDeprecated: "Please use the new exceptions variant, Control.Exception.catch"‚Äù ‚Äì how do i make such warnings myself?
08:04:09 <dmwit> morel: Use the source!
08:04:13 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/System-IO-Error.html#catch
08:05:14 <morel> dmwit: huh?
08:05:55 <dmwit> The source shows how to make such warnings yourself.
08:05:57 <geekosaur> morel: that's a link to the syntax-colored source
08:05:58 <dmwit> Look there, and you'll see it.
08:06:03 <geekosaur> including the magic pragma
08:08:46 <morel> dmwit: i was confused because the name of that function ("catch") was the name of the function for which i got the error at the same time.
08:09:11 <morel> thanks, dmwit and geekosaur; great thing.
08:09:40 <stepkut> what is the 'normal' name for this type, data Path a = L (Path a) | R (Path a) | End a
08:10:07 <stepkut> or..what is it good for
08:10:25 <geekosaur> yeh, that there is a kinda dumb catch in Prelude and a sane one in Control.Exception is a bit of a wart
08:12:46 <codolio> stepkut: Looks like paths down a leaf binary tree.
08:12:53 <codolio> With the value at the leaf included.
08:13:25 <codolio> Actually, no, not a leaf tree. Just paths into a binary tree, ending with the element.
08:13:25 <stepkut> codolio: yeah.. I have a monad instance for it too.. which seems to concatenate the paths
08:14:53 <stepkut> I started with, data LR a = L a | R a, and then tried to implement, runLR :: Free LR a -> ???, and that is what I got :)
08:15:18 <codolio> Yeah.
08:16:07 <stepkut> there are multiple ways to implement runLR in this case. I could have just ignored the L and R and treated it like Identity
08:16:08 <codolio> Certainly if you just want a name, 'free monad over /\a -> a + a' is an answer.
08:18:00 <codolio> stepkut: It's also similar to the partiality monad, which is Free Id. data Delay a = Now a | Later (Delay a).
08:18:09 <codolio> Except you've got a direction at each delay.
08:18:13 <morel> "data LR a = L a | R a" is like [Either a a]‚Ä¶
08:18:24 <DrSyzygy> errr
08:18:33 <DrSyzygy> data LR a = L a | R a is like Either a a.
08:18:42 <Taneb> Or even (a, Bool)
08:18:43 <DrSyzygy> You need L (LR a) | R (LR a) to be like [Either a a]
08:18:49 <morel> DrSyzygy: oh right
08:19:01 <morel> "data LR a = L (LR a) | R (LR a)" is like [Either a a]‚Ä¶
08:19:11 <Taneb> No, It'd be L a (LR a) | R a (LR a)
08:19:16 <morel> well‚Ä¶ at least a bit =)
08:19:23 <DrSyzygy> Taneb: Fair enough
08:19:27 <codolio> You still need a nil in there.
08:19:50 <codolio> L a (LR a) | R a (LR a) | End
08:19:50 <DrSyzygy> So we're all just trying to reproduce the description stepkut had a page or so earlier, right?
08:20:12 <Taneb> I don't know, I wasn't paying attention
08:20:52 <DrSyzygy> ... so actually, I think I see an isomorphism between stepkut's data structure and > ([Either a a], a)
08:21:07 <dmwit> perhaps you mean ([Bool], a)
08:21:25 <DrSyzygy> dmwit: noooo, I don't.
08:21:32 * hackagebot wai-middleware-static 0.2.2 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.2.2 (AndrewFarmer)
08:21:33 <codolio> Then you're wrong. :)
08:21:34 * hackagebot stylish-haskell 0.2.0.2 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.2.0.2 (JasperVanDerJeugt)
08:21:40 <dmwit> There's only one a in stepkut's original type.
08:21:41 <DrSyzygy> dmwit: Oh wait, my bad.
08:21:52 <codolio> Or, you're not wrong that you think you see it.
08:21:53 <DrSyzygy> yeah, ([Bool], a)
08:21:54 <parcs`> @botsnack
08:21:56 <dmwit> In fact, this makes it quite clear what the Monad instance should do: it's Writer.
08:21:56 <codolio> But you don't actually see it. :)
08:22:14 <dmwit> specialized to the monoid [Bool], (++)
08:22:29 <DrSyzygy> codolio: I had to scroll up to see it in the first place -- I accidentially thought it was decorated with a everywhere.
08:26:58 <codolio> I guess dmwit's answer is probably the best.
08:27:23 <codolio> Although there are some oddities with Path a vs. ([Bool], a).
08:29:31 <codolio> They're isomorphic as data in a total language, but not as codata, for instance.
08:29:36 <codolio> (I think.)
08:34:13 <Taneb> codata?
08:39:41 <codolio> Taneb: If paths and lists are allowed to be infinite, an infinite path doesn't have an end with an a.
08:40:06 <Taneb> So, what's codata?
08:40:21 <codolio> But ([Bool], a) always has an a. If you write a function in Haskell to translate between the two, the a will be an infinite loop.
08:40:30 <tac-tics> taneb: Codata is the categorical dual of data
08:40:47 <codolio> codata is potentially infinite data structures, more or less.
08:40:50 <Taneb> tac-tics, assume I'm not very well versed it category theory
08:40:51 <Taneb> Okay
08:40:53 <codolio> Rather than finite data structures.
08:41:21 <geekosaur> http://blog.sigfpe.com/2007/07/data-and-codata.html
08:41:54 <Taneb> One day, I'll know everything
08:41:59 <Taneb> But that day is not today
08:42:07 <Taneb> Tomorrow isn't looking so good, either
08:42:24 <tac-tics> Taneb: basically, data is built out of a finite number of constructor applications, and it comes with an induction (recursion) principle.
08:43:11 <tac-tics> Taneb: codata is built from unbounded, but guarded recursion, and it comes with a case-matching principle (iirc)
08:43:54 <codolio> Case matching on codata is the dual of constructor application for data.
08:44:00 <tac-tics> Taneb: To give a concrete example, the Nats are 0, 1, 2, 3, ... and so on. The conats are the nats with an additional element infinity = S (infinity)
08:44:21 <morel> Taneb: you won't know everything (about CT, TT and Haskell) one day because i'll know more than you.
08:44:35 <codolio> The dual of induction/recursion is coinduction/corecursion which lets you build potentially infinite structures by unfolding.
08:44:43 <Taneb> Okay, hmm
08:45:30 <codolio> And prove things based on unfolding.
08:47:22 <tac-tics> codolio: What do you do for a living, out of curiosity?
08:47:36 <codolio> I write code.
08:47:42 <tac-tics> Are you at a university? Or just really interested hobbiest?
08:47:57 <codolio> The latter.
08:47:58 <Taneb> Are you a programmer or a cryptologist?
08:50:28 <codolio> Programmer. I write code, not codes. :)
08:50:47 <Taneb> :)
08:51:04 <kkyqqp> is there any really obvious ways of speeding up this computation of euler's totient function? http://pastebin.com/FZzT6LSa
08:51:06 <Taneb> One day, someone isn't going to ask that question and it's going to lead to all sorts of mayhem
08:51:09 <JamesRustle> The paste FZzT6LSa has been copied to http://hpaste.org/69711
08:52:12 <morel> is JamesRustle == mauke?
08:52:38 <Taneb> Your list is more nice than the ones nub caters for
08:52:48 <Taneb> In that it's strictly ascending
08:52:55 <Taneb> Well, not strictly
08:53:01 <Taneb> But it's ascending
08:53:17 <kkyqqp> what should I use instead of nub?
08:53:23 <Taneb> Probably nothing
08:53:29 <Taneb> By which I mean stick with nub
08:53:40 <Taneb> I think it may be possible to right one with O(n)
08:54:02 <Taneb> *write
08:54:03 <rwbarton> how about map head . group
08:54:51 <illissius> Woah, you can partially apply data families?
08:54:54 <illissius> Did not know.
08:55:10 <kkyqqp> I tried map head . group, it's nearly identical in terms of speed. thanks though!
08:55:21 <elliott> Cale: did lambdabot crash again?
08:56:02 <morel> kkyqqp: product . map (\p -> 1.0 - (1.0 / (fromIntegral p))) == (foldr (\x y -> let f = (\p -> 1.0 - (1.0 / (fromIntegral p))) in f x * f y)) -- i think
08:56:04 * illissius wonders if this is useful for anything
08:56:34 <morel> kkyqqp: i mean, product is a foldr and map is a map. but you could ONE foldr instead of a foldr + a map.
08:56:40 <morel> could i explain what i mean?
08:57:13 <kkyqqp> hmm, I think I understand- let me mess around with that for a little bit. thanks!
08:58:07 <Taneb> illissius, that reminds me, I need to learn data families at some point
08:58:43 <illissius> Taneb: I used to be in the same position. But it turned out to be pretty simple. Do you know type families?
08:58:54 <codolio> product is not a foldr.
08:58:59 <morel> kkyqqp: product = foldl (*) 1 -- sorry, it's not a foldr
08:59:06 <Taneb> illissius, no, I thought they were the same as data families
08:59:09 <Taneb> I have a lot to learn :/
08:59:37 <elliott> Taneb: they're related
08:59:40 <elliott> same extension
08:59:43 <elliott> just slightly different applications of the same idea
09:00:16 <morel> is this correct?  product . map f == foldl (\x y -> x * f y) 1
09:00:35 <morel> codolio: ‚Üë
09:00:41 <elliott> @check \f -> product . map f === foldl (\x y -> x * f y) 1
09:00:47 <elliott> oh wait, no lambdabot
09:00:48 <morel> lambdabot is at toilet.
09:00:48 <Taneb> I have less to learn than I thought
09:00:53 <tac-tics> @check \x -> (product . map f $ x) == (foldl (\x y -> x * f y) 1 $ x)
09:00:56 <illissius> Taneb: oh, ok then. data families were easy once I understood type families and noticed one thing (which in this case it doesn't make sense to mention).
09:00:56 <tac-tics> erk
09:00:56 <elliott> morel: yes, that's correct
09:01:01 <elliott> morel: unless I've made some stupid error, anyway
09:01:13 <jfischoff> I updated to cabal head and my options to use cpphs stopped working.
09:01:16 <morel> elliott: nice
09:01:16 <Taneb> illissius, any handy learning resources you can link me?
09:01:27 <jfischoff> I had ghc-options:  -cpp -pgmPcpphs -optP--cpp -threaded.
09:01:30 <fmap> so keyword `data' should really be `codata' since haskell always build codata if it can?
09:01:33 <jfischoff> I tried extensions: CPP, but I can't seem to convince cabal to use cpphs. Maybe I am not passing the options correct to cpphs, but either way it is not longer working.
09:01:34 <elliott> Taneb: the wiki has some good stuff on type families i think
09:01:35 <morel> kkyqqp: did you hear that? use this:    product . map f == foldl (\x y -> x * f y) 1
09:01:47 <Taneb> OK
09:01:47 <kkyqqp> OK sure- I'll try that now!
09:01:57 <illissius> Taneb: not sure where I started with it, but yeah, probably the wiki.
09:01:57 <elliott> so wait, why can't kkyqqp just use product . map f?
09:01:59 <elliott> I'm missing context :)
09:02:40 <Eduard_Munteanu> fmap: Haskell doesn't even make that distinction
09:02:58 <morel> elliott: because the foldl is faster?
09:03:06 <elliott> fmap: data Nat = Zero | Succ !Nat -- not codata
09:03:15 <morel> elliott: you zip the list only once, right?
09:03:17 <elliott> morel: That's untrue.
09:03:23 <elliott> kkyqqp: product . map f will be just as fast.
09:03:26 <elliott> morel: Laziness.
09:03:31 <elliott> List cells will be produced and consumed in tandem.
09:03:45 <illissius> anyways, GUYS, this is exciting, partially applied data families! did you know you could do this?: http://hpaste.org/69712
09:03:46 <morel> ah, coool! wow! didn't know that‚Ä¶ great!
09:03:47 <elliott> This is one of the main benefits of laziness: being able to compose rather than inline loops.
09:03:50 <kkyqqp> yeah, it computes at the same speed from my testing
09:03:59 <Eduard_Munteanu> Assuming it fuses, no?
09:04:03 <elliott> Eduard_Munteanu: No.
09:04:04 <elliott> No fusion required.
09:04:15 <elliott> A list cell is produced, consumed by the product, and eventually garbage collected.
09:04:23 <elliott> kkyqqp: In fact, I think product has specialised rules for Int/Integer and so on, so if anything it might be slightly faster.
09:04:33 <elliott> Isn't Haskell great? :)
09:04:44 <Eduard_Munteanu> Well, then the spine might be recomputed twice.
09:04:48 <kkyqqp> I just wish there were more libraries!
09:04:50 <morel> elliott: yes it is!! :D
09:04:52 <codolio> Laziness doesn't magically make it just as fast as the fused fold.
09:04:57 <Taneb> kkyqqp, what to do?
09:05:08 <elliott> kkyqqp: A few thousand isn't enough for you? :)
09:05:18 <elliott> codolio: No, but the overhead is a small constant.
09:05:29 <codolio> But, it prevents it from building a big intermediate list in memory.
09:05:30 <elliott> codolio: It certainly doesn't traverse the list twice.
09:05:39 <elliott> (Well, "a list of the same size".)
09:05:46 <elliott> Right, the main benefit over a strict version is in memory usage.
09:05:54 <kkyqqp> I'm using some number sieves, but this package doesn't compile anymore so I've been trying to write my own: http://hackage.haskell.org/package/NumberSieves
09:05:57 <elliott> Although you could make a cache-based argument for speed, too.
09:06:05 <dmwit> elliott: Are you also elliottt?
09:06:07 <tac-tics> What is this talk of nonsense runtimes? Once you've proved an algorithm exists, isn't that good enough :P
09:06:12 <kkyqqp> I just can't seem to make them fast enough
09:06:18 <elliott> dmwit: No. That's another elliott. There's too many. :(
09:06:28 <Eduard_Munteanu> elliott: one could argue traversing the list twice might be less expensive than GC-ing
09:06:30 <dmwit> oh
09:06:35 <Taneb> http://hackage.haskell.org/package/primes ? kkyqqp?
09:06:37 <elliott> kkyqqp: Have you tried http://hackage.haskell.org/package/arithmoi?
09:06:48 <elliott> Eduard_Munteanu: Well, strict languages usually do GC too.
09:06:48 <Taneb> No, not that
09:06:53 <Taneb> Try elliott's
09:06:57 <elliott> Try primes too!
09:07:02 <elliott> That's the other one I know of.
09:07:25 <kkyqqp> I'm using that to generate the primes and prime factors, but it doesn't have the secondary functions like euler's totient built in :(
09:07:27 <Eduard_Munteanu> elliott: yeah. but there's one intermediate cons cell to throw out when no fusion is involved
09:07:43 <elliott> Eduard_Munteanu: Right.
09:07:52 <elliott> Eduard_Munteanu: But they won't be collected one by one.
09:07:58 <elliott> It'll be bunched up into chunks.
09:08:01 <tac-tics> Euler's totient.... isn't that one of those functions in number theory that iterates over the primes less than n?
09:08:02 <Eduard_Munteanu> Hm, yeah, fair.
09:08:27 <elliott> Eduard_Munteanu: (Which does mean that the memory usage will be more than one cons cell. But you only care about this stuff when taking the product of really huge lists anyway, so that doesn't matter much.)
09:08:31 <Eduard_Munteanu> Actually, GC-ing itself isn't the problem.
09:08:49 <Eduard_Munteanu> More like the whole ordeal of going through an allocator etc.
09:08:51 <bitonic> ok I've had this conduit problem for a while: how do I feed a Sink a bunce of data, returning a new sink if the original one still needs data, or the result otherwise? I can do that fiddling with the constructors, but I feel like I'm doing the wrong thing.
09:09:05 <kkyqqp> tac-tics: yeah it's the number of integers k less than n that are coprime to n- it has a nice product formula but I can't figure out how to make it fast enough http://pastebin.com/bCd0zTue
09:09:08 <JamesRustle> The paste bCd0zTue has been copied to http://hpaste.org/69713
09:09:36 <Eduard_Munteanu> Wait a minute...
09:09:41 <Eduard_Munteanu> JamesRustle: mauke?
09:09:41 <codolio> elliott: Yes, but even cache isn't everything. If I write 'slowId [] = [] ; slowId (x:xs) = x : slowId xs ; slowerId [] = [] ; slowerId (x:xs) = x : slowerId (slowId xs)', it will take noticeably O(n^2) time when you go through the whole list, despite running in constant memory.
09:09:52 <elliott> codolio: Right.
09:10:05 <tac-tics> kkyqqp: seems like something that couldn't be written efficiently in a point-free way. Why not write it more algorithmically?
09:10:11 <Eduard_Munteanu> Hm, looks like it.
09:10:32 <kkyqqp> tac-tics: well, mostly because I'm a pretty novice programmer
09:10:49 <tac-tics> heh, kkyqqp fair enough.
09:10:58 <tac-tics> kkyqqp: do you do math then?
09:11:24 <kkyqqp> yeah math :)
09:14:07 <tac-tics> kkyqqp: you probably also want to avoid using fromIntegral and division the way you are doing it.
09:14:33 <tac-tics> kkyqqp: use x `mod` y == 0   to test if y divides x evenly.
09:15:04 <tac-tics> kkyqqp: and then use x `div` y to get the quotient of the two (`div` is division on integers, throwing away the remainder)
09:15:14 <fabrydrunk> hi everybody
09:15:30 <fabrydrunk> can someone help me to fix my xmonad.hs?
09:15:53 <Taneb> Almost certainly
09:15:54 <parcs`> #xmonad can help you better than this channel can
09:15:58 <morel> fabrydrunk: we could, yes, but #xmonad can better.
09:16:04 <fabrydrunk> yeah I know
09:16:12 <fabrydrunk> but that channel seems dead to me O.o
09:16:48 <fabrydrunk> anyway I just have to fix a compilation error
09:17:02 <fabrydrunk> but I don't understand anything about haskell lol XD
09:17:24 <morel> fabrydrunk: the channel is not dead!
09:17:26 <Taneb> hpaste.org it?
09:17:28 <morel> just ask there.
09:17:44 <Eduard_Munteanu> Hm, I should probably join #xmonad from time to time...
09:18:58 <TheLemonMan> hrm, whats the difference between stm tvar/mvar and plain ones ?
09:19:17 <parcs`> stm
09:20:38 <TheLemonMan> stm types are a bit harder to use than plain ones as they don't work in the io monad, so i need some hopping to get the work done
09:20:58 <TheLemonMan> but beside that docs don't explain the differences
09:21:06 <rwbarton> I don't believe codolio's slowerId runs in constant space
09:21:31 <fryguybob> TheLemonMan: STM allows for the composition of actions into new larger atomic actions.
09:21:33 <parcs`> probably because stm is a general thing, not specific to haskell
09:22:09 <TheLemonMan> so only stm is guaranteed to be atomic ?
09:22:23 <rwbarton> after demanding the first few cells of the result you build up expressions like x0 : x1 : x2 : slowerId (slowId (slowId (slowId (x3:x4:...))))
09:23:17 <fryguybob> TheLemonMan: There are other atomic actions in IO, but STM is about composing atomic actions.
09:25:05 <tac-tics> TheLemonMan: yeah. you can use channels to get atomic reads and atomic writes, but you can't atomically "read and then write"
09:25:38 <tac-tics> With channels, the sends and receives are all atomic themselves, but *between* them, Anything Could Happen (TM)
09:26:08 <tac-tics> With STM, you're guaranteed everything that happens inside an STM transaction happens with no interleaving actions
09:28:24 <TheLemonMan> got it. on a side note, whats the implementation of monadplus for stm ?
09:30:00 <elliott> TheLemonMan: mzero = retry
09:30:03 <elliott> mplus = orElse
09:30:27 <elliott> TheLemonMan: basically, retry makes the STM transaction fail
09:30:33 <elliott> and it retries again once the variables it touches change
09:30:41 <elliott> (it doesn't keep retrying if it knows nothing's changed, which is important)
09:31:01 <elliott> orElse can be used to say, e.g. "get me something from this TChan or something from this TChan, whichever becomes available first"
09:31:22 <elliott> fmap Left (readTChan firstChan) `orElse` fmap Right (readTChan secondChan) will either return Left valueFromFirstChan or Right valueFromSecondChan
09:31:43 <elliott> the retry/orElse stuff is one of the best things about haskell's stm, imo
09:33:47 <TheLemonMan> I wonder what happens under the hood
09:35:52 <elliott> TheLemonMan: clever stuff :)
09:36:39 <elliott> TheLemonMan: basically, each transaction records the variables it reads to and writes, as well as the values it changes them to, and then if all goes well and there's no conflicts in the meantime, it just copies them all over
09:36:50 <elliott> this also lets it know which variables it has to wait to change, etc. before retrying, and so on
09:37:50 <TheLemonMan> oh, really smart stuff indeed
09:44:53 <TheLemonMan> oh another question, does assert work only in ghci ?
09:51:28 <geekosaur> TheLemonMan, sort of?  ghci doesn't optimize, and enabling optimization disables assert
09:51:43 <geekosaur> it's intended for debugging
09:52:11 <TheLemonMan> i'm compiling without any parameter passed to ghc but seems that the assertion is getting stripped anyway
09:53:06 <Veinor> TheLemonMan: try -O0? that's a dash, capital O, number 0
09:57:43 <qnikst> hello, I've done a simple boilerplate code generator for testing adt subtype and extracting values, was it reinventing a wheel? (https://github.com/qnikst/derive-adt)
09:57:50 <TheLemonMan> Veinor, no luck
09:58:21 <tertl4> who wrote "
09:58:31 <morel> qnikst: there's a typo in the README.markdown ‚Äì "gerenator"
09:58:32 <tertl4> Learn you a Haskell?
09:58:42 <morel> qnikst: =)
09:59:16 <qnikst> morel: I think there are too much typos :/
09:59:18 <qnikst> thanks
09:59:19 <morel> tertl4: Miran Lipowaca
09:59:24 <morel> Lipovaca
09:59:31 <morel> tertl4: see http://learnyouahaskell.com/
10:02:30 <jfischoff> qnikst: The Is functionality is in derive. The extract is not. I would suggest investigating generating partial lenses from either data-lens or yall for extract
10:03:17 <jfischoff> qnikst: derive: http://hackage.haskell.org/package/derive
10:03:18 <taylorgb> Is there somewhere that explains what lenses are
10:03:22 <taylorgb> I think I missed it
10:04:17 <jfischoff> taylorgb: http://www.youtube.com/watch?v=efv0SQNde5Q
10:05:30 <morel> jfischoff: cool, thanks for that link!
10:05:45 <jfischoff> np
10:05:49 <taylorgb> Thanks
10:05:58 <morel> taylorgb: also take a look at http://www.scs.stanford.edu/11au-cs240h/notes/zipper-slides.html#%281%29
10:06:12 <morel> which explains some nice type-theory stuff and lenses and zippers.
10:06:27 <taylorgb> Perfect, thanks.
10:06:40 <qnikst> jfischoff: ok thanks
10:06:49 <morel> jfischoff: oh, that's edwardk? cool
10:10:10 <mwcampbell> What does it mean when a dollar sign appears between a function name and its argument?
10:10:43 <taylorgb> :t ($)
10:10:59 <taylorgb> It's function application
10:11:10 <S11001001> it's a magic form of whitespace
10:11:28 <S11001001> ;]
10:11:48 <c_wraith> mwcampbell: ($) is just a function.
10:12:03 <jfischoff> its a way to pipe functions
10:12:32 <morel> mwcampbell: f $ x = f x
10:12:47 <mwcampbell> In what situations would I use f $ x instead of simply f x?
10:13:01 <mwcampbell> I'm going through the book "Real World Haskell", and it seems to have just slipped in the $ without explanation
10:13:08 <morel> mwcampbell: f (g (h x)) = f $ g $ h x -- you need less parantheses.
10:13:40 <morel> mwcampbell: it's actually mostly just for saving parantheses.
10:13:44 <c_wraith> mwcampbell: yeah, that's one of my biggest complains about that book.  It's not a beginner's book, but they say it is.
10:14:11 <Siod> if you have experience with other languages i think it's good
10:14:23 <c_wraith> mwcampbell: RWH is more of a second book - once you know a bit about the language, it tells you how to use it to actually build real things. But it's not a good intro to the language
10:14:26 <Siod> i didn't like lyah
10:14:29 <morel> mwcampbell: you can also use it like this:   map ($5) [(*4),(+3),(^2)] = [20,8,25]
10:14:33 <tomboy64> mwcampbell: i like learnyouahaskell.com
10:14:40 <tomboy64> it's fun :-]
10:15:22 * morel agrees with tomboy64
10:15:25 <tomboy64> Siod: i really luv it <3
10:15:40 <morel> yea, it's writing-style is just fun :D
10:15:45 <Siod> i think it's too slow and wordy if you know other languages
10:15:49 <morel> also those pictures and the language‚Ä¶
10:16:17 <tomboy64> Siod: well, you can jump over topics and get back to it easily.
10:16:17 <morel> also it's more like for not-so-serious people.
10:16:30 <tomboy64> i went right to I/O, jumping 5 or so chapters
10:16:40 <tomboy64> then went back learning bout lambdas and $
10:17:55 <morel> lol. you didn't know \ before IO? wow.
10:18:10 <tgeeky> import           Data.Maybe        (isJust, fromJust, fromMaybe)
10:18:15 <morel> hehehe
10:18:17 <tgeeky> whoops
10:18:42 <elliott> tgeeky_: fromJust?!
10:18:44 <tomboy64> morel: exactly. that's why i jumped back to read about it :-p
10:18:46 <adamt> morel: I didn't stumble into \ before IO either, and I really don't see why that's a problem :-)
10:18:51 <elliott> tgeeky_: tut tut
10:18:52 <morel> pattern guards are a great replacement for isJust+fromJust =)
10:19:06 <tgeeky> elliott: not my code :o
10:19:23 <elliott> tgeeky_: ok, I'll let you off this time. but I'm watching you
10:19:30 <tgeeky> yes sir!
10:25:24 <hayashi> @unpl flip ( ( f . ) . map . flip id )
10:25:39 <hayashi> „Å´„Çá„Çç~„Çì
10:25:41 <morel> lambdabot is at toilet.
10:26:08 <hayashi> so he is >_>
10:26:26 <hayashi> or she, or whatever
10:29:15 <morel> hayashi: lambdabot is a she. what does „Å´„Çá„Çç~„Çì mean?
10:31:25 <tomboy64> morel: is that supposed to be japanese?
10:31:27 <hayashi> it's (supposed to be) nyoro~n, a nonsense utterance signifying defeat from the Japanese short series "nyoron! churuya-san", though being a very bad weeaboo I've probably got it wrong.
10:31:49 <morel> ah
10:36:51 * hackagebot Vec 0.9.9 - Fixed-length lists and low-dimensional linear algebra.  http://hackage.haskell.org/package/Vec-0.9.9 (ScottDillard)
10:40:09 <corneliu> anyone with leksah experience on windows about?
10:41:38 <morel> s/anyone with leksah experience on windows about?/Does anybody have experience(s) with leksah on Windows?/
10:44:09 <elliott> morel: if you're going to be pedantic, better s/leksah/Leksah/ and escape that ? in the regexp...
10:45:06 <morel> elliott: oh, okay, thanks.
10:48:07 <ozataman> any haskell-mode users out there? what's the shortcut for inserting function signatures at point?
10:49:13 <morel> yes, i am!
10:49:39 <morel> i use C-u C-c C-t ... dunno if theres a shorter one.
10:50:32 <ozataman> morel: cool, thanks!
10:50:34 <morel> ozataman: also check out the wiki-pages on emacs. chrisdone recently re-organized them nicely.
10:50:47 <morel> np :)
10:50:52 <ozataman> morel: yep, I've already upgraded to his version
10:50:57 <ozataman> pretty nifty!
10:51:21 <ozataman> love it with jaspervd1's stylish-haskell
10:51:33 <tertl4> morel is he ever in here?
10:51:55 <jaspervdj> thanks ozataman :-)
10:52:05 <ozataman> jaspervdj: :)
10:52:37 <Luke> does leksah use yi as the editor?
10:52:50 <elliott> no
10:54:31 <morel> tertl4: yep, sometimes.
10:54:35 <morel> as "chrisdone".
10:54:36 <tertl4> cool
10:54:48 <tertl4> question for you
10:55:04 <morel> shoot! go ahead!
10:55:10 <tertl4> is the bind opewrator mainly used in type declarations?
10:55:21 <morel> tertl4: you mean (>>=)?
10:55:27 <tertl4> ohh
10:55:29 <tertl4> my mistake
10:55:49 <tertl4> I was thinking that '=>' was bind
10:56:11 <tac-tics> => in type signatures is reserved for type class requirements
10:56:21 <morel> if => is not in a type declaration, it means "greater or equal"
10:56:25 <tac-tics> Num a => a is any type a as long as it's a numeric type.
10:56:26 <tomboy64> heh
10:56:43 <tomboy64> i can't help thinking of gonads when reading the term monads >.>
10:56:48 <morel> tertl4: maybe => is called bind, too. dunno.
10:57:02 <tac-tics> tomboy64: just one of millions of Monad jokes you'll find on #haskell
10:57:02 <morel> donut monad.
10:57:14 <tertl4> well I am just wondering if bind is used for anything other that monads
10:57:15 <tomboy64> ^^
10:57:17 <tac-tics> morel: => is *not* called bind.
10:57:29 <morel> OK.
10:57:35 <tertl4> probably getting ahead of myself
10:57:41 <morel> tac-tics: but (>>=) is, right?
10:57:45 <byorgey> >= is "greater or equal", not =>
10:57:46 <tac-tics> yes
10:58:01 <tertl4> i've watching brian beckman videos on channel 9
10:58:01 <morel> byorgey: oh, oops :D lol :D
10:58:06 <Adeon> => looks like an emoticon
10:58:20 <byorgey> tertl4: (>>=) is just a normal function, which is a method of the Monad class.  It's not special syntax.
10:58:21 <Adeon> it's happy
10:59:10 <tertl4> so how would someone use bind in a simple function?
10:59:29 <byorgey> > [1,2,3] >>= \x -> [4,5,6] >>= \y -> return (x,y)
10:59:48 <byorgey> oh, is lambdabot dead?
10:59:49 <morel> lambabot is in the john.
10:59:56 <tac-tics> byorgey: He's been afk all day
11:00:03 <morel> lambabot is for ladies.
11:00:11 <tertl4> he must be on a bender :\
11:00:20 <tgeeky> src\Data\Relation\On\SMS.hs:63:18:
11:00:20 <tgeeky>     Couldn't match expected type `SignedMultiset a'
11:00:20 <tgeeky>                 with actual type `containers-0.5.0.0:Data.Set.Base.Set k0'
11:00:20 <tgeeky>     In the return type of a call of `Map.keysSet'
11:00:20 <tgeeky>     In the expression: Map.keysSet (dom z)
11:00:37 <tgeeky> why is double click paste in irssi?
11:00:38 <tertl4> its ok i put it in ghci
11:00:46 <tgeeky> but, I did want to share that.
11:00:56 <tgeeky> I didn't know GHC told you the specific package information
11:01:09 <tomboy64> tgeeky: cause irssi is a broken bit of outdated software
11:01:20 <byorgey> tgeeky: it does sometimes.  I'm not sure how it decides when to show it.
11:01:22 <geekosaur> when a type comntains a versioned package, this is often a warning that it's got multiple versions of the package loaded
11:01:36 <Minoru> tgeeky: it does if you're using some package that was built agains specific version of another package
11:01:39 <geekosaur> which is all by itself a very suspicious situation
11:02:02 <tgeeky> geekosaur: I would be interested if that often could be strengthened
11:02:04 <tertl4> byorgey you returned a tuple there right?
11:02:15 <tgeeky> but uhh I do have two versions available
11:02:22 <byorgey> tertl4: I called the 'return' function on a tuple, yes
11:02:24 <tgeeky> but not imported, I hope
11:02:40 <tertl4> ok thank you
11:02:46 <byorgey> tertl4: the output of that expression is  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
11:02:56 <byorgey> tertl4: that's just a simple example of using (>>=) with the list monad
11:03:05 <tertl4> yes, thats what i got :)
11:03:21 <elliott> tgeeky: it's probably paste in your terminal, not irssi
11:03:31 <tgeeky> putty
11:03:40 <tertl4> byorgey so that was a list monad?
11:04:09 <byorgey> tertl4: that code uses the list monad
11:04:15 <byorgey> "a" list monad does not really make sense
11:04:18 <byorgey> there is only one =)
11:04:36 <tertl4> ok
11:05:16 <tertl4> still not fully understanding this monad stuff but I'll read further in book
11:05:40 <tac-tics> tertl4: Monads are best taught by example.
11:06:58 <tertl4> what do you mean it 'uses' the list monad?
11:07:47 <tertl4> [1,2,3] >>= \x -> [4,5,6] >>= \y -> return (x,y)        just to show it again
11:08:47 <morel> tertl4: it uses how lists are made an instance of the Monad typeclass.
11:09:06 <tertl4> ohh
11:09:21 <tertl4> i didnt know that Monad was a typeclass
11:09:55 <tertl4> he left that out of the types and typeclasses chapter
11:09:59 <morel> Peaker: i added a Issue to Bottle. Did you see it? I can't type [ and ] and { and } and \ in Bottle because i need AltGr for that purpose. I'm using the German keyboard-layout.
11:13:48 <morel> could Haskell be modified that way that the keywords "data", "type" and "newtype" aren't needed anymore?
11:14:14 <morel> (amongst others, by allowing kind-signatures.)
11:14:19 <C0deMaver1ck> EvanR: I be trolling.
11:14:46 <tac-tics> morel: It probably could, but there'd be some quirks.
11:15:45 <kaol> What, shapr is a GSoC student? That's almost like cheating. I approve.
11:15:50 <morel> i mean, "type A = B" would be "A = B". "newtype A = B C" would be "B :: * -> *; B = C -> A" or so‚Ä¶
11:15:59 <tac-tics> morel: There are languages that don't have any way to create new types. See SystemF
11:16:07 <morel> kaol: shapr is marrying today.
11:16:09 <zhulikas> @src reverse
11:16:23 <tac-tics> morel: SystemF, you have to use encodings for everything.
11:16:25 <morel> zhulikas: lambdabot is away, for ladies.
11:16:33 <zhulikas> ok :D
11:16:47 <morel> tac-tics: whut?
11:17:35 <morel> tac-tics: i though SystemF is a calculus‚Ä¶ is there such a prog-lang, too?
11:17:54 <bitonic> morel: what's the difference?
11:17:55 <tac-tics> morel: Surprise twist, calculii *are* languages :)
11:18:13 <morel> oh, cool :D
11:18:13 <tac-tics> It's just that most people don't bother writing implementations of them
11:18:26 <morel> wow. WOW!
11:18:55 <tac-tics> morel: http://www.cis.upenn.edu/~bcpierce/tapl/index.html
11:18:58 <tac-tics> I believe that's it
11:19:13 <morel> tac-tics: so Haskell is an implementation of SystemF? What does Agda/Idris implement?
11:19:20 <tac-tics> From B. Pierce's Types and Programming Languages text (TaPL), that's an implementation of the SystemF "polymorphic lambda calculus"
11:19:32 <morel> tac-tics: yea, i have that as PDF =)
11:19:37 <thoughtpolice> GHC is a whole lot more than regular System F now
11:19:51 <morel> thoughtpolice: GHC but not Haskell :P
11:21:12 <tac-tics> morel: That implementation is written in Ocaml, though, not Haskell, though, but it's close enough you should be able to figure it out with a little Google help
11:22:18 <morel> tac-tics: again; when Haskell is an implementation of SystemF, what does Agda/Idris implement?
11:22:29 <thoughtpolice> oh, then in that case, no, not regular haskell 2010. unfortunately GHC is still the de facto implementation is what i was more hinting at i guess. i still long for a day when another haskell compiler joins the production fray
11:22:53 <tac-tics> morel: Agda and Idris are based off a generalization of SystemF
11:23:04 <morel> which generalization of SystemF?
11:24:09 <tac-tics> They are modeled off of Martin Lof's intuitionist logic
11:24:25 <tac-tics> Basically, types and terms are the "same kind of thing".
11:24:36 <tac-tics> You can pass types into functions as parameters (like in System F)
11:24:54 <tac-tics> and you can also get terms into types, such as Vect A n, "vectors of length n"
11:25:00 <mm_freak> it seems like originally functional languages (including miranda) were compiled to an enhanced SKI calculus‚Ä¶  but modern compilers are moving towards supercombinators‚Ä¶  compiling SKI is really simple whereas compiling supercombinators is difficult‚Ä¶  i'm finally implementing the compiler for my language‚Ä¶  what do you think i should choose?
11:25:53 <mm_freak> morel: haskell is an implementation of system f_omega
11:26:04 <mm_freak> at least GHC haskell
11:26:16 <morel> tac-tics, mm_freak: cool. thanks!
11:26:40 * morel googles for supercominators‚Ä¶
11:26:57 <thoughtpolice> mm_freak: it's now even More Enhanced since the polykinds story, i can't remember exactly what GHC implements now
11:27:11 <tac-tics> morel: The core calculus is pretty simple. I think the Ivor language (the previous basis for Idris) is a really simple introduction
11:27:37 <tac-tics> morel: http://www.cs.st-andrews.ac.uk/~eb/writings/ivor.pdf
11:27:55 <mm_freak> thoughtpolice: i think it's still system f_omega‚Ä¶  there is really nothing between that and calculus of constructions
11:28:41 <mm_freak> together with PolyKinds it now has 'forall' on all levels
11:28:56 <mm_freak> what it lacks to be More Enhanced is a dependent forall
11:29:07 <tac-tics> morel: It has something like 9 typing rules. Though, if I recall correctly, at some point it starts using a tactics-based engine like Coq (whereas Agda is expressions and pattern-matching the whole way down).
11:29:22 <morel> tactics hehe
11:30:03 <morel> tac-tics: very exciting. thank you very much, i'll take a look at Ivor (and TAPL).
11:30:50 <tac-tics> morel: if you have any questions, I love this shit, so ask away :)
11:31:16 <morel> :D
11:37:34 <tac-tics> Speaking of Ocaml, why does Ocaml require that you mark recursive lets?
11:37:54 <tac-tics> They aren't compiled any differently are they? (other than you get to refer to it in the body)
11:41:48 <hpaste> mekeor pasted ‚Äúno data, type and newtype‚Äù at http://hpaste.org/69719
11:41:59 <morel> tac-tics: ‚Üë i just tried introducing a new syntax.
11:42:12 <morel> tac-tics: but i don't know how to make records nice.
11:42:25 <navaati> iirc, the paper about the DataKind and PolyKind extensions says GHC now implements something called "Systemd-F_omega‚Üë" (pronounced "lifted system f omega", i think)
11:43:34 <navaati> (s/Systemd/System/, btw)
11:43:42 <morel> hehe
11:44:04 <jbohn|lunch> back
11:44:18 <elliott> navaati: I thought there was a C in there too.
11:44:36 <tac-tics> morel: I'm not sure what you're trying to do there exactly
11:45:54 <morel> tac-tics: i'm just thinking how you could remove "data", "type" and "newtype" from haskell (by introducing new syntax).
11:46:48 <tac-tics> Type is easy. It's just a let expression. let X = Nat in ... works the same as type X = Nat
11:46:58 <tac-tics> (assuming you can work with types as first-class objects in your system)
11:47:36 <morel> tac-tics: yea, that's what i wrote in that hpaste.
11:47:39 <tac-tics> data is more complicated. In haskell, the "data" keyword is actually a coinductive type.
11:47:52 <morel> "type A = B" gets "A : *; A = B".
11:47:53 <tac-tics> In ML,  "data" is an inductive data type.
11:48:15 <morel> tac-tics: yea, my biggest issue is records.
11:48:34 <tac-tics> Records as in haskell records?
11:48:42 <morel> *nod*
11:48:59 <tac-tics> Records in haskell are just product types (A, B), except the projection functions are named instead of numbered.
11:49:15 <Rc43> Hi, guys.
11:49:43 <Rc43> What means `~` in `~alias@(expr)` ?
11:49:51 <shachaf> Rc43: Irrefutable pattern.
11:49:58 <morel> tac-tics: ah, okay.
11:50:06 <Rc43> shachaf, thank you
11:50:13 <tac-tics> So basically, data Record = Record {part1 :: Int} {part2 :: Bool} would be let Record = (Int, Bool); let part 1 = fst; let part2 = snd in ....
11:50:23 <tac-tics> But note there is a difference
11:50:32 <tac-tics> (and this comes up again when doing newtype)
11:50:44 <morel> okay‚Ä¶ namely?
11:50:46 <tac-tics> is that in Haskell, isomorphic types are distinct
11:51:03 <elliott> Rc43: To expand on what shachaf said:
11:51:14 <elliott> Rc43: Consider foo [x,y,z] = "abc"
11:51:14 <tac-tics> So in Haskell, Record (above) is NOT interchangable with (Int, Bool). If you want to use a Record as an (Int, Bool), you have to do explicit coercion
11:51:23 <elliott> Rc43: foo [] gives an error, because the pattern isn't matched.
11:51:32 <elliott> Rc43: But if you write foo ~[x,y,z] = "abc", it just assumes that the pattern matches, and foo [] gives "abc".
11:51:39 <elliott> x, y and z would individually give errors if evaluated.
11:51:41 <elliott> So,
11:51:45 <tac-tics> But when you do the definition above, the two types are equivalent (you just need to evaluate Record and you get (Int, Bool)
11:51:50 <elliott> foo [x,y,z] = ... is like foo xs = case xs of [x,y,z] -> ...
11:51:55 <elliott> but foo ~[x,y,z] = ... is like
11:51:57 <tac-tics> So they can be used interchangably without any coercion at all.
11:52:05 <Rc43> elliott, understood, thanks; funny thing
11:52:05 <elliott> foo xs = let x = xs!!0; y = xs!!1; z = xs!!2 in ...
11:52:17 <elliott> Rc43: It's not usually useful, but it can be used to make functions more lazy, so that they do not force their argument immediately.
11:52:21 <elliott> It's kind of niche.
11:52:23 <shachaf> > let [x,y,z] = (1:2:undefined) in (x,y)
11:52:33 <shachaf> lambdabot :-(
11:53:01 <shachaf> Cale: ‚òù
11:53:46 <shachaf> > let [x,y,z] = (1:2:undefined) in (x,y)
11:53:49 <kappabot>   (*Exception: Prelude.undefined
11:53:53 <shachaf> Hmm, OK.
11:54:21 <morel> Cale runs lambdabot?
11:54:32 <shachaf> Maybe
11:57:35 <JoeyA> Hmm, has anyone made something like WriterT w where w is like a monoid, but has an "mappend" that can fail?
11:57:36 <kappabot> JoeyA: You have 1 new message. '/msg kappabot @messages' to read it.
11:58:10 <JoeyA> > 2+2
11:58:11 <kappabot>   4
11:58:15 <tac-tics> :D
11:58:18 <tac-tics> @djinn a -> a
11:58:18 <kappabot> No output from Djinn; installed?
11:58:22 <tac-tics> :<
11:58:24 <morel> yippie!!! yay!
11:58:29 <morel> @djinn a -> Not a
11:58:30 <kappabot> No output from Djinn; installed?
11:58:30 <elliott> shachaf: No output from Djinn; installed?
11:58:35 <tac-tics> @check \x -> 2 * x == x + x
11:58:35 <kappabot>   unrecognized option `--loadfile='
11:58:35 <kappabot>  Usage: mueval [OPTION...] --expression E...
11:58:38 <elliott> JoeyA: What would happen when the mappend failed?
11:58:40 <shachaf> elliott: Yes, but I don't feel like setting it up.
11:58:43 <JoeyA> (that "new message" was 1y 10m 1d 12h 56m 55s ago, according to kappabot)
11:58:55 <elliott> JoeyA: :D
11:58:55 <shachaf> @admin + Cale
11:58:56 <JoeyA> elliott: It would signal failure in the transformed monad.
11:59:04 <elliott> JoeyA: Ew, "fail"?
11:59:14 <JoeyA> Not necessarily, but that would be acceptable for my case.
12:00:15 <JoeyA> Here's my situation: I'm traversing a tree corresponding to an editor.  An editor has a corresponding "Binding", which indicates what part of the value the thing edits.
12:00:45 <JoeyA> For example, Property (Set.singleton "foo") means it edits a single property of a JSON object, and that property is named Foo.
12:01:02 <JoeyA> Field True means it edits the entire value (for now, I don't care what type of value)
12:01:35 <JoeyA> A Binding is a monoid.  If two editors are composed in sequence, their bindings are unioned.
12:01:57 <JoeyA> Copied right out of my code: mappend (Properties a) (Properties b) = Properties (a `Set.union` b)
12:02:08 <JoeyA> mappend (Field a) (Field b) = Field (a || b)
12:02:21 <JoeyA> But what if bindings conflict?
12:02:56 <JoeyA> We need a separate check to see if bindings conflict.
12:03:19 <JoeyA> From this arises a monoid-like thing whose mappend is a partial function.
12:03:47 <elliott> JoeyA: Can't you just use something like
12:04:15 <elliott> data Failing a = Failed | Okay a; instance (Monoid a) => Monoid (Failing a) where mempty = Okay mempty; mappend (Okay a) (Okay b) = Okay (mappend a b); mappend _ _ = Failed
12:05:26 <JoeyA> elliott: Interesting idea.  However, I want to signal failure at the point the error happens, so I can attach context information telling where the conflict happened.
12:05:59 <JoeyA> Conflicts generally won't happen in different contexts, and I don't care to keep going so as to print all errors detected.
12:06:49 <JoeyA> I'll probably roll my own Writer-like monad that does this.  I was wondering if there was something off-the-shelf.
12:06:51 <JoeyA> Thanks for the input!
12:07:01 <startling> um, i upgraded to ghc 7.4.1 and now ghci SIGSEGVs. any idea?
12:07:13 <JoeyA> startling: What platform?
12:07:13 <EvanR> would be nice if combining monads was easier
12:07:59 <startling> JoeyA: os x 10.6.8, installed via homebrew (so essentially compiled from source)
12:08:11 <startling> reinstalling now to see if the problem persists
12:08:16 <c_wraith> EvanR: there are some theoretical difficulties wrt that. like, not all pairs of monads can be composed. (This is part of why Applicative exists)
12:08:33 <EvanR> yeah i heard of that
12:08:47 <c_wraith> homebrew isn't going to be building ghc from source - doing so requires ghc
12:09:29 <elliott> JoeyA: You might still be able to build it as a monoid instead, and tell (Failed failureInfo). But building your own monad transformer might be the simplest thing.
12:09:29 <startling> c_wraith, it downloads http://www.haskell.org/ghc/dist/7.4.1/ghc-7.4.1-x86_64-apple-darwin.tar.bz2 and then ./configures and make installs
12:09:35 <geekosaur> likely it is, but with a bootstrap compiler
12:09:39 <startling> so maybe not *really* from source
12:09:41 <geekosaur> macports ghc does the same thing
12:09:48 <JoeyA> startling: FYI, Haskell Platform 2012.2.0.0 with GHC 7.4.1 was released recently.
12:09:57 <geekosaur> ah, ok, so that does look like abi nary install
12:10:03 <startling> JoeyA, yep, that's the one I just upgraded too
12:10:07 <JoeyA> Ah, okay
12:10:12 <startling> *to
12:10:19 <luite> startling: do you have a simple way to reproduce those crashes?
12:10:47 <startling> luite: by running "ghci"
12:11:08 <luite> I've been having problems on OS X with 7.4.1 myself, but so far only had them with large yesod projects with lots of dependencies
12:11:17 <startling> geekosaur: doesn't seem like it, though; it takes quite some time
12:11:37 <startling> (the make install does, I mean)
12:11:41 <geekosaur> source would not have the platform name in it though
12:11:44 <luite> startling: so just running ghci without anything else crashes? you don't need to load or run any code?
12:11:57 <geekosaur> make install does copy a lot of stuff, and builds/edits some wrappers
12:12:09 <startling> luite: correct. it prints all the stuff for linking base and then SIGSEGVs
12:12:20 <startling> s/linking/loading
12:12:48 <startling> welp, reinstalling fixed it
12:13:43 <startling> odd. thanks anyway!
12:14:08 <startling> geekosaur, takes >5 minutes on my machine
12:15:25 <geekosaur> I wonder if it's running prelink or something
12:15:33 <geekosaur> (that would be ... risky)
12:19:46 <dzhus89> how can I know the N number of threads specified +RTS -N4 from my program?
12:21:08 <dzhus> (so I can schedule parallel computation appropriately, e.g. subdivide the problem into N tasks when running N threads)
12:21:32 <shachaf> dzhus: getNumCapabilities in GHC.Conc
12:21:42 <shachaf> But you're probably doing something wrong if you're using it for what you just said.
12:23:42 <dzhus> shachaf: probably you mean that in most cases you can just employ purity and map f over collection of data in parallel.
12:24:35 <startling> well this is odd. importing *anything* in ghci does nothing.
12:24:47 <shachaf> dzhus: For example, or various other things.
12:25:00 <dzhus> shachaf: but consider the case when you need to perform IO for every task subdivision
12:25:01 <shachaf> dzhus: You can start as many sparks as you like and let GHC schedule them appropriately.
12:25:12 <startling> even if the module doesn't exist.
12:25:13 <shachaf> dzhus: I think you're conflating two different things here...
12:28:51 <elliott> dzhus: That isn't what shachaf means.
12:29:00 <elliott> dzhus: GHC lets you start as many threads as you want, and efficiently schedules them between the "N".
12:29:18 <elliott> Managing your own thread stuff on top of that would duplicate work, and slow things down.
12:29:33 <elliott> A Haskell "thread" is very lightweight, not like an OS thread; you can very easily start thousands of them without a problem.
12:29:59 <dzhus> elliott: shachaf: consider a list [a1, a2, ..., an, b1, b2, ... , bn]. Consider a function which takes an item of this list, a random number and produces the result.
12:30:26 <elliott> OK, so start one thread per k items, where k is some constant.
12:30:32 <elliott> One thread per item would probably have a bit too large overhead.
12:30:38 <elliott> But k would be pretty small.
12:30:47 <dzhus> If list is of length N, we can start a *single* PRNG, produce N random numbers, then zipWith two lists (original and randoms). zipWith is pure, so parallelizes nicely
12:31:06 <elliott> dzhus: By the way, zipWith/map/etc. do *not* automatically parallelise at all.
12:31:15 <elliott> That's a common misconception.
12:31:57 <EvanR> dzhus: you can make a rng in the form of an infinite list, then zip that with the N length other list
12:31:58 <dzhus> elliott: that's implementation details. use parMap
12:32:19 <dzhus> EvanR: sure, but this limits you to single RNG and single thread
12:32:19 <EvanR> infinite list rng is kind of klunky unfortunately :(
12:32:32 <EvanR> multithread rng :(
12:32:36 <dzhus> EvanR: it's very natural abstraction for rng
12:32:46 <EvanR> yes but its klunky to use in haskell
12:34:13 <dzhus> so should my parallel Haskell program work nicely if I have 4 cores, but set +RTS -N8?
12:34:38 <elliott> Depends if your OS is good at scheduling 8 threads onto 4 cores.
12:34:50 <elliott> Generally, you should just use +RTS -N, which uses the same number of threads as you have cores.
12:35:18 <zomg> elliott: with intel CPUs you get hyperthreading which would mean 8 threads for 4 cores
12:35:40 <EvanR> not sure parallel on a rng makes sense
12:35:41 <elliott> zomg: Those show up as cores to the OS.
12:35:42 <geekosaur> ...as long as the threads do things that will hyperthread well
12:35:48 <zomg> elliott: true :)
12:35:50 <elliott> EvanR: It does if you use e.g. split.
12:35:51 <elliott> :t split
12:35:53 <kappabot> forall g. RandomGen g => g -> (g, g)
12:35:53 <dzhus> elliott: I can't currently confirm that giving high number to RTS doesn't ruin the performance. Apparently my linux box sucks.
12:36:02 <zomg> but he didn't say whether he was talking about "cores" or cores ;)
12:36:05 <elliott> dzhus: It might very well ruin the performance.
12:36:06 <shachaf> geekosaur: ...Which is more things than you'd expect, so it's usually worth trying.
12:36:12 <elliott> dzhus: Why would you do that? It's silly.
12:36:42 <elliott> dzhus: By "start a thousand Haskell threads", I mean "with forkIO", not with the -N command line option.
12:36:51 <elliott> The -N RTS option determines the number of *OS* threads to use.
12:37:01 <elliott> That's unrelated to the number of Haskell forkIO threads that will ruin simultaneously, though.
12:37:13 <elliott> (Well, FSVO simultaneously.)
12:37:49 <elliott> *run
12:37:56 <teurastaja> is everything controlable from haskell? are there things that cant be done?
12:38:13 <EvanR> unsafeLaunchMissles :: IO ()
12:38:30 <tac-tics> EvanR: Isn't unsafeLaunchMissiles :: () ?
12:38:44 <EvanR> @faq can haskell control everything
12:38:45 <dzhus> aha. that's enlightening. Now if you run a thread for every K items of my list, you can't statically predict how many threads will spawn since list size varies. If N=1e8 and K=1e6, then 100 green threads spawn. Now the question is: will congestion occur if too many threads are spawned?
12:38:45 <kappabot> The answer is: Yes! Haskell can do that.
12:38:50 <EvanR> tac-tics: oh lol
12:39:02 <elliott> teurastaja: Well, it can't make your computer fly. It can do everything Python can, sure. And most things C can.
12:39:05 <tromp_> @faw can Haskell do the impossible?
12:39:06 <kappabot> The answer is: Yes! Haskell can do that.
12:39:09 <elliott> (You can write a kernel in Haskell, but it's not very pleasant.)
12:39:33 <teurastaja> can you generate asm from haskell?
12:39:45 <elliott> dzhus: If you spawn too many, yes. At that point some kind of pooling could be reasonable.
12:39:46 <tommd> That's what th compiler does.
12:39:55 <elliott> dzhus: Have you seen http://hackage.haskell.org/packages/archive/parallel/3.2.0.3/doc/html/Control-Parallel-Strategies.html ?
12:40:05 <startling> teurastaja, how do you mean "generate"?
12:40:06 <thoughtpolice> teurastaja: you can generate assembly inside haskell as a DSL, and invoke it! http://hackage.haskell.org/package/harpy
12:40:06 <dzhus> elliott: I'm using it.
12:40:07 <elliott> dzhus: Especially parListChunk, etc.
12:40:09 <elliott> Ah.
12:40:15 <startling> thoughtpolice: woah
12:40:18 <dzhus> elliott: And Repa too.
12:40:18 <thoughtpolice> that package is a lot of fun
12:40:23 <thoughtpolice> too bad it's 32bit intel only
12:40:23 <teurastaja> i mean: write asm and launch it from a haskell sandbox?\
12:40:48 <tommd> teurastaja: Call a routine written in ASM from a Haskell function?
12:41:09 <elliott> teurastaja: There are Haskell libraries for doing assembly and calling it.
12:41:11 <elliott> Take a look at e.g. harpy.
12:41:16 <elliott> http://hackage.haskell.org/package/harpy
12:41:20 <parcs`> also the llvm package
12:41:22 <elliott> It's not "sandboxed", though. But you could plug it into qemu or something!
12:41:36 <teurastaja> its not x64 friendly
12:41:47 <elliott> What isn't?
12:41:53 <teurastaja> harpy
12:41:54 <elliott> LLVM does 64-bit code.
12:43:55 <dzhus> without knowing how many threads to spawn (coupled with using PRNG), there's much less ¬´deterministic parallelism¬ª here actually. parListChunk would require initializing RNG state inside every thread on every list division, while it would be desirable to maintain static amount of RNGs along the whole running time of program
12:44:10 <dzhus> since there may be many parallel maps with RNGs and N may change on every time.
12:44:43 <EvanR> not sure what the point of having more than one rng is
12:45:10 <EvanR> unless you use split, they might not be independent
12:45:16 <dzhus> EvanR: consider sampling 4 random processes
12:45:23 <otters> what are the advantages of lazy foldl over strict foldl'
12:45:33 <EvanR> lazy foldr, right
12:45:50 <otters> no
12:46:13 <elliott> otters: Usually nothing.
12:46:16 <tommd> I don't understand the problem with having a separate RNGs for each thread.
12:46:18 <elliott> Sometimes you want foldl. But only rarely.
12:46:24 <elliott> I forget the canonical example.
12:46:32 <EvanR> if they are truely separate
12:46:40 <dzhus> tommd: there's none with that.
12:46:49 <otters> Well, I just saw that foldl (+) 0 [1..10000000] used 654MB of RAM
12:46:58 <otters> while foldl' (+) 0 [1..10000000] did not
12:46:59 <dzhus> gather entropy, wroom up RNG's, use them till end of times.
12:47:02 <otters> and was significantly faster
12:47:18 <dzhus> otters: sure, thunks are not accumulating
12:47:31 <otters> yeah, so I can't see why you would want a lazy foldl
12:47:39 <otters> especially if it has to evaluate the entire list basically to WHNF
12:47:40 <shachaf> otters: I think the wiki has an example.
12:47:47 <shachaf> But usually never.
12:48:18 <EvanR> :t scanl
12:48:19 <kappabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
12:48:33 <EvanR> :t scanr
12:48:34 <kappabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
12:48:51 <EvanR> :t scanl'
12:48:52 <kappabot> Not in scope: `scanl''
12:49:02 <c_wraith> well, something like reverse...  lazy or not doesn't matter
12:49:11 <c_wraith> @src reverse
12:49:11 <kappabot> reverse = foldl (flip (:)) []
12:49:20 <otters> okay, sweet
12:49:28 <otters> so all I need foldl for is when I have a list with undefined in it
12:49:29 <c_wraith> that function is CONLIKE, from the optimizer's point of view
12:49:33 <otters> which is...rarely
12:49:54 <c_wraith> foldl' will only slow that down
12:50:04 <c_wraith> since it will be doing a bunch of seq operations that don't do anything
12:53:08 <elliott> otters: not really
12:56:21 <crdueck> @src permutations
12:56:21 <kappabot> Source not found. I am sorry.
12:57:58 <teurastaja> i need to understand how you can derive the cells that are solvable based on a permutated sudoku row (from 1 2 3 4 5 6 7 8 9), since the only 8 other possible rows in a sudoku are shifts from the starting row
12:58:02 <teurastaja> the rows of a sudoku made by successive (ordered) rotations from the first row are grouped by modulo 3 of their index and shuffled for every group of 3 rows
12:58:08 <teurastaja> those 3 groups are then shuffled too
12:58:12 <teurastaja> i end up with a working sudoku but i want to know how permutations affect the hints
12:58:50 <teurastaja> other channels remain silent and my rate of answered questions is higher on this chan\
12:59:28 <teurastaja> probably because of the involvement and intelligence of its users
12:59:54 <teurastaja> and their math skills
13:01:18 <teurastaja> i dont know how to compute the relations between permutations
13:01:29 <teurastaja> any hints?
13:02:00 <dzhus> somehow joining #sudoku results in joining #su-doku
13:02:12 <teurastaja> ive done great amounts of research
13:02:54 <teurastaja> i suspect their not as prompt to answer as here but ill try (4th chan asking)
13:04:36 <elliott> teurastaja: Try #haskell-blah for non-Haskell-related talk.
13:05:02 <teurastaja> i tried #algorithms, #math-software...
13:05:47 <teurastaja> alright but if you can answer that id be stoked
13:20:45 <otters> I need lambdabot :(
13:21:51 * byorgey can pretend for a few minutes
13:22:07 <shachaf> > 1 + 1
13:22:08 <kappabot>   2
13:22:24 <byorgey> haha, a successor to lambdabot!
13:23:10 <otters> awkward
13:23:13 <geekosaur> wouldn't that be mubot?
13:23:29 <byorgey> oh. right. a predecessor then.
13:23:58 <byorgey> > pred '?'
13:23:59 <kappabot>   '>'
13:24:01 <mauke> > (+) 0 1
13:24:02 <kappabot>   1
13:24:05 <mauke> > 1 0 (+)
13:24:06 <kappabot>   Overlapping instances for GHC.Show.Show ((a2 -> a2 -> a2) -> a0)
13:24:06 <kappabot>    arising...
13:24:22 <shachaf> > 1 0
13:24:23 <kappabot>   Overlapping instances for GHC.Show.Show (a1 -> a0)
13:24:23 <kappabot>    arising from the lite...
13:24:24 <shachaf> Sorry. :-(
13:24:25 <shachaf> @ty fmap
13:24:27 <kappabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
13:24:28 <shachaf> Er.
13:24:28 <shachaf> @ty (.)
13:24:30 <kappabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
13:24:38 <mauke> > deriv (^2) x
13:24:40 <kappabot>   1 * x + x * 1
13:24:49 <shachaf> Hmm, there are at least a few hundred milliCales in this bot.
13:25:03 <mauke> > deriv (2 * sin) x
13:25:04 <kappabot>   Overlapping instances for GHC.Show.Show
13:25:04 <kappabot>                              (Data....
13:25:08 <mauke> fail
13:25:10 <tomboy64> uhm
13:25:44 <tomboy64> let (Just action) = lookup command dispatch
13:25:46 <tomboy64>     action args
13:25:56 <tomboy64> could someone explain this construct to me?
13:26:01 <tomboy64> let (Just action) ?
13:26:11 <geekosaur> it's a pattern
13:26:11 <mauke> tomboy64: do you know 'let'?
13:26:12 <shachaf> > let Just x = Just 5 in x
13:26:13 <mekeor> whuut??! is deriv a valid haskell-function?
13:26:13 <kappabot>   5
13:26:14 <tomboy64> i just don't get it
13:26:19 <mauke> :t deriv
13:26:21 <kappabot> forall a b. (Num b, Num a) => (Dif a -> Dif b) -> a -> b
13:26:28 <mekeor> > deriv x
13:26:29 <kappabot>   Couldn't match expected type `Data.Number.Dif.Dif a0
13:26:30 <kappabot>                       ...
13:26:32 <otters> tomboy64: lookup command dispatch returns Just something
13:26:33 <tomboy64> mauke: yes. it replaces a = with <-
13:26:38 <mekeor> is x pre-defined?
13:26:38 <mauke> tomboy64: no
13:26:40 <otters> so let (Just action) binds action to that something
13:26:45 <mauke> :t x
13:26:46 <kappabot> Expr
13:26:49 <mekeor> ah, okay.
13:27:02 <mauke> :t [a, b, c, d]
13:27:04 <kappabot> [Expr]
13:27:45 <tomboy64> otters: and what is the Just for?
13:28:06 <otters> tomboy64: Just is one of the two constructors of the Maybe datatype
13:28:12 <otters> @src Maybe
13:28:13 <kappabot> data Maybe a = Nothing | Just a
13:28:21 <otters> it's haskell's substitute for nullable values
13:28:25 <tac-tics> @src IO
13:28:25 <kappabot> Source not found. :(
13:28:33 <EvanR> s/substitute/way better version of/
13:28:34 <mekeor> :t w
13:28:35 <kappabot> Expr
13:28:43 <otters> EvanR: not substitute in a negative sense
13:28:47 <otters> yeah, "version of"
13:28:59 <mekeor> so, all identifiers consisting of only one character are predefined as expr?
13:29:07 <mauke> :t f
13:29:08 <kappabot> forall a. SimpleReflect.FromExpr a => a
13:29:13 <otters> maybe in kappabot
13:29:15 <EvanR> otters: isnt undefined the substitute? ;)
13:29:18 <otters> certainly not in ghci
13:29:32 <otters> EvanR: undefined is cheating
13:29:37 <tomboy64> mhhmm
13:29:38 <tomboy64> k
13:29:43 <tomboy64> gotta read up bout maybe
13:29:48 <otters> yes, you do
13:29:56 <EvanR> unsafeIsUndefined :: a -> Bool
13:30:14 <EvanR> might crash wathc out
13:30:46 <otters> one thing I really love about Maybe is nested lookups
13:30:58 <otters> lookup x xs >>= lookup y >>= lookup z
13:31:02 <Twisol> tomboy64: if "Just 42" is like calling a constructor with a value, then using "Just x" in a pattern-matching context is like un-doing the construciton, un-wrapping the value from the type
13:40:58 <boxo> what cabal command do I use to download a package's documentation?
13:42:19 <JoeyA> cabal install --enable-documentation
13:44:20 <elliott> boxo: Turn documentation on in your ~/.cabal/config is the best thing to do.
13:44:22 <boxo> JoeyA: it says "no packages to be installed". is there a way to just download the docs without reinstalling the whole package
13:44:30 <elliott> Remove the "-- " before "documentation: False" and change "False" to "True".
13:44:31 <elliott> No, sorry.
13:44:37 <elliott> You have to reinstall things.
13:46:36 <boxo> right, enabled it
13:52:13 * hackagebot secure-sockets 1.2.6 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.2.6 (IavorDiatchki)
13:53:28 <elliott> boxo: You might find "cabal install --reinstall world" useful.
13:56:14 <fmap> and `cabal install --reinstall --dry-run world' too
14:02:17 * hackagebot pandoc 1.9.4.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.4.1 (JohnMacFarlane)
14:13:20 <mm_freak> wow, it's extraordinarily difficult to implement an efficient run-time system
14:13:45 <shachaf> mm_freak: That depends on what you want it to be a run-time system for!
14:16:59 <drrckln> hey, i'm working through LYAH
14:17:17 <drrckln> and I'm not sure why foldr works on infinite lists and foldl doesn't (this is what it says in the text)
14:17:43 <drrckln> I can guess that if you start foldr somewhere.. it has an end-point (the start of the list).. but if you're starting off in infinite I still don't see how you get there
14:18:13 <jfischoff> drrckln: have you read this? http://www.haskell.org/haskellwiki/Fold
14:18:30 <jfischoff> there is an image in the middle that might be helpful
14:18:42 <drrckln> jfischoff: oh, thanks!
14:19:07 <jfischoff> drrckln: if you still have questions feel free to come back!
14:19:29 <drrckln> will do
14:19:36 <jfischoff> hmm that might not be the right page ...
14:19:54 <tac-tics> What is the category theory channel again?
14:19:55 <tac-tics> On IRC?
14:20:03 <elliott> drrckln:
14:20:09 <elliott> > foldr f z [a,b,c,d]
14:20:10 <kappabot>   f a (f b (f c (f d z)))
14:20:11 <elliott> > foldl f z [a,b,c,d]
14:20:12 <jfischoff> drrckln: i meant this actually http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
14:20:13 <kappabot>   f (f (f (f z a) b) c) d
14:20:17 <elliott> drrckln: Perhaps this sheds some light?
14:20:24 <sipa> #haskell is the CT channel on freenode, no?
14:20:29 <elliott> drrckln: In particular, look at the "d" at the end, and think what that would be like for an infinite list.
14:20:43 <hpc> sipa: there's a #category-theory, i think
14:20:43 <tac-tics> sipa: lol, probably
14:20:53 <hpc> might be ##
14:21:59 <mekeor> ##categorytheory
14:23:11 <tac-tics> ahhh
14:23:23 <tac-tics> for some reason, most ## channels are auto-coerced from the corresponding # channel
14:23:26 <tac-tics> but not CT
14:23:28 <tac-tics> mekeor: danke
14:23:36 <mekeor> bittesch√∂n
14:23:44 <mekeor> actually: bitte sch√∂n.
14:23:51 <mekeor> (i think.)
14:27:19 * hackagebot wai-middleware-static 0.3.0 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.3.0 (AndrewFarmer)
14:29:22 <elliott> tac-tics: The "auto-coercion" is just people setting up redirect channels.
14:30:17 <drrckln> heh, no, i'm still pretty mystified :/
14:30:28 <tac-tics> elliott: gotcha
14:40:01 <gwern> > foldl 0 (+) [a..z]
14:40:02 <kappabot>   Overlapping instances for GHC.Show.Show (a0 -> a0 -> a0)
14:40:02 <kappabot>    arising from th...
14:40:14 <gwern> > foldl a (+) [b,c,d,e,f,g,h]
14:40:15 <kappabot>   Couldn't match expected type `a0 -> b0 -> a0'
14:40:15 <kappabot>              with actual type...
14:40:18 <hpc> :t f
14:40:20 <kappabot> forall a. SimpleReflect.FromExpr a => a
14:40:26 <gwern> man, I can never get these simplereflect expressions to work
14:40:43 <hpc> > foldl (+) a [b,c,d,e,f,g,h] :: Expr
14:40:44 <kappabot>   a + b + c + d + e + f + g + h
14:41:00 <gwern> that's weird, it eliminates the parenthesization?
14:41:13 <hpc> yeah
14:41:16 <gwern> > foldl f a [b,c,d,e] :: Expr
14:41:16 <hpc> it's a showsPrec thing
14:41:17 <strager`> foldr (+) a [b,c,d,e,f,g,h] :: Expr
14:41:17 <kappabot>   f (f (f (f a b) c) d) e
14:41:30 <strager`> > foldr (+) a [b,c,d,e,f,g,h] :: Expr
14:41:31 <kappabot>   b + (c + (d + (e + (f + (g + (h + a))))))
14:41:39 <strager`> Yes, because + is left-accociative
14:41:47 <strager`> so the parens are not needed to parse correctly
14:41:51 <strager`> (for foldl)
14:43:05 <elliott> gwern: don't use f,g,h
14:43:06 <elliott> they're functions
14:43:15 <elliott> also, the zero comes after the function in fold
14:43:23 <elliott> > foldl (+) a [b,c,d,e]
14:43:25 <kappabot>   a + b + c + d + e
14:43:35 <elliott> well, f,g,h work if you annotate the signature, but yeah
14:44:16 <hpc> :t f
14:44:17 <kappabot> forall a. SimpleReflect.FromExpr a => a
14:44:19 <hpc> :t a
14:44:20 <kappabot> Expr
14:53:38 <drrckln> elliott: i think i may have it now. foldl is left assoc, so it'd try to eval the last element first, while foldr will start at the beginning (and then you can terminate the computation somewhere)
14:53:54 <elliott> @src foldl
14:53:54 <kappabot> foldl f z []     = z
14:53:55 <kappabot> foldl f z (x:xs) = foldl f (f z x) xs
14:54:12 <elliott> drrckln: Basically, on an infinite list, foldl just keeps recursing forever, adding an application to each new element "around" the previous results as it goes.
14:54:27 <elliott> But never actually reaches the end, so there's no actual result at the top, if you can see what I mean.
14:54:30 <elliott> If you can't, no worries :P
14:54:31 <elliott> But yes.
14:59:51 <drrckln> elliott: think i got it! thanks!
14:59:57 <elliott> drrckln: :)
15:01:19 <strager`> foldl const 0 [0..]
15:01:22 <strager`> > foldl const 0 [0..]
15:01:26 <kappabot>   mueval-core: Time limit exceeded
15:03:14 <otters> > foldr const 0 [0..]
15:03:15 <kappabot>   0
15:04:23 <hpc> > foldl (flip const) 0 [0..]
15:04:27 <kappabot>   mueval-core: Time limit exceeded
15:06:44 <gjgfuj> b x = x + x is legal haskell code right?
15:06:51 <sipa> yes
15:06:57 <tgeeky_> @let b x = x + x
15:06:58 <kappabot>  Defined.
15:07:03 <mauke> @undefine
15:07:11 <gjgfuj> it says there is an error at =
15:07:19 <tgeeky_> you're doing it in ghci?
15:07:19 <mauke> gjgfuj: are you typing it into ghci?
15:07:21 <tgeeky_> you need a let
15:07:29 <tgeeky_> let b x = x + x
15:07:30 <gjgfuj> yes, ghci
15:07:31 <otters> @pl \x n -> (x !! n) !! n
15:07:32 <kappabot> join . ((!!) .) . (!!)
15:07:43 <mauke> gjgfuj: well, don't do that then
15:07:58 <gjgfuj> ok, done
15:08:28 <gjgfuj> how exactly do I call that then?
15:08:33 <tgeeky_> b 2
15:08:40 <gjgfuj> right i guess
15:08:53 <mauke> 2 b || not (2 b)
15:09:04 <mekeor> @type \g l x -> g (l x) x
15:09:06 <kappabot> forall t t1 t2. (t1 -> t2 -> t) -> (t2 -> t1) -> t2 -> t
15:09:15 <gjgfuj> kool.
15:09:19 <mekeor> @hoogle (t1 -> t2 -> t) -> (t2 -> t1) -> t2 -> t
15:09:19 <kappabot> A Hoogle error occurred.
15:09:33 <mauke> > (=<<) g f x :: Expr
15:09:33 <kappabot>   Could not find module `ShowIO':
15:09:33 <kappabot>    It is a member of the hidden package `sh...
15:09:39 <mauke> the hell
15:09:55 <mauke> I want lambdabot back :-(
15:10:25 <otters> @hoogle foldl'
15:10:25 <kappabot> A Hoogle error occurred.
15:11:23 <gjgfuj> haskell is already brilliant from what i've seen of it
15:12:29 <unlink> does a function like this already exist in the standard library?  [m Bool] -> m Bool (with short-circuiting)
15:13:13 <hpc> :t foldrM
15:13:15 <kappabot> Not in scope: `foldrM'
15:13:18 <hpc> @hoogle foldM
15:13:18 <kappabot> A Hoogle error occurred.
15:13:43 <elliott> hpc: it's a fake plastic imitation of lambdabot
15:13:44 <hpc> 18:13 <@Data> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
15:13:46 <elliott> right, shachaf?
15:13:47 <hpc> use that
15:14:21 <hpc> a = Bool, b = m Bool
15:14:36 <hpc> and give decent values for the first two parameters
15:14:53 <hpc> @djinn-ver
15:14:53 <kappabot> ersion 2011-07-23.
15:15:05 <c_wraith> version
15:15:12 <elliott> ersion :D
15:15:20 <hpc> shachaf: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=13 -- you can do at least a little bit of cleaning up kappabot ;)
15:15:31 <unlink> hpc: that's going to bind all the IO actions in its third argument, right?
15:16:11 <hpc> unlink: until your first function says not to
15:16:20 <hpc> your use of foldM will have its type be
15:16:35 <hpc> (Bool -> m Bool -> m Bool) -> Bool -> [m Bool] -> m Bool
15:17:13 <shachaf> elliott: "cheap" plastic imitation?
15:17:27 <Peaker> @hoogle foldM
15:17:27 <kappabot> A Hoogle error occurred.
15:17:28 <hpc> yourSequence = foldM (\previous next -> if previous then next else return False) True
15:17:32 <hpc> or something like that
15:17:33 <elliott> shachaf: Yes.
15:17:38 <shachaf> hpc: I don't care enough to get it to work
15:17:45 <hpc> shachaf: heh
15:17:47 <Peaker> where's foldM from?
15:17:52 <hpc> @index foldM
15:17:53 <kappabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
15:18:02 <shachaf> hpc: Feel free to push your changes, though!
15:18:09 <shachaf> I'll get them sometime and use them.
15:18:15 <hpc> shachaf: ive tried, can't figure out who to send them to
15:18:15 <Peaker> I don't think foldM itself can do short-circuiting. you can use a short-circuiting monad
15:18:29 <sipa> @src foldM
15:18:29 <kappabot> foldM _ a []     = return a
15:18:29 <kappabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
15:18:30 <elliott> hpc: Cale, I think.
15:18:37 <elliott> hpc: (Try "darcs send"?)
15:18:40 <hpc> ah, then i did send them, and he hasn't merged them
15:18:42 <hpc> elliott: did
15:18:44 <hpc> i think
15:18:47 <hpc> i forget now
15:18:57 <shachaf> I think it's not Cale.
15:18:57 <hpc> doing other things :P
15:19:17 <hpc> i think i was also told gwern was the person to send to
15:19:50 <elliott> gwern was my next option
15:19:53 <elliott> maybe we've had this conversation before!
15:21:17 <augur> :t foldM
15:21:18 <kappabot> forall (m :: * -> *) a b. Monad m => (a -> b -> m a) -> a -> [b] -> m a
15:21:35 <augur> hm
15:22:19 <Peaker> @pl foldM cons nil = foldr (\x rest -> rest >>= flip cons x) (return nil)
15:22:20 <kappabot> foldM = (. return) . foldr . ((=<<) .) . flip
15:23:20 <Peaker> @let argument = flip (.) ; result = (.)
15:23:21 <kappabot>  .L.hs:71:1:
15:23:21 <kappabot>      Failed to load interface for `ShowIO':
15:23:21 <kappabot>        It is a membe...
15:23:35 <Peaker> @type argument return . foldr . result (=<<) . flip
15:23:37 <kappabot> Not in scope: `argument'
15:23:37 <kappabot> Not in scope: `result'
15:23:46 <Peaker> @type (. return) . foldr . ((=<<) .) . flip
15:23:48 <kappabot> forall a (m :: * -> *) a1. Monad m => (a -> a1 -> m a) -> a -> [a1] -> m a
15:26:51 <Peaker> @type \cons nil -> ($nil) . foldr (>=>) return . map cons
15:26:52 <kappabot> forall (m :: * -> *) c a. Monad m => (a -> c -> m c) -> c -> [a] -> m c
15:27:54 <Peaker> @type (.)
15:27:56 <kappabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:27:58 <Peaker> yay, no Caleskell! :)
15:28:30 <illissius> I wonder if people other than edwardk ever reach the point where they understand everything on edwardk's blog.
15:29:41 <t7> i wonder if i could get away with wearing a haskell t-shirt in public. As long as nobody knows the haskell logo it looks really cool... otherwise; nerd
15:30:21 <hpc> i got away with wearing an upside down linux guide t-shirt in public
15:31:15 <shachaf> @ty (.)
15:31:16 <kappabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
15:35:51 <t7> i want a huge logo on a white t shirt
15:35:59 <t7> anyone know where i can get that?
15:36:13 <t7> the ones from the wiki are tiny
15:37:17 <Peaker> @type (.)
15:37:18 <kappabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
15:37:23 <Peaker> Why??
15:37:25 <shachaf> Peaker: Sorry. :-(
15:37:43 <shachaf> L.hs had a broken import, so I fixed it and everything came back.
15:37:57 <Peaker> shachaf, can you get rid of Prelude overrides?
15:38:45 <shachaf> Hmm, how about this?
15:38:47 <shachaf> @ty (.)
15:38:48 <kappabot> forall (cat :: * -> * -> *) b c a. Control.Category.Category cat => cat b c -> cat a b -> cat a c
15:38:57 <shachaf> rwbarton: U+261D
15:39:31 <elliott> U+261D I HATE YOU
15:39:33 <Peaker> shachaf, I think the purpose of lambdabot is pedagogic, showing newbies Haskell basics.. it really gets in the way when it is not Haskell
15:39:40 <Peaker> it's not to make a better Haskell
15:40:10 <shachaf> I don't think fancy(.) gets in the way pedagogically that much.
15:40:34 <Peaker> Showing newbies the type of something involving (.) is always annoying
15:41:00 <Peaker> Sometimes I try to show how SECs work and it ruins it, and I have to go rewrite it using Prelude.. or inline . in my code
15:41:09 <shachaf> SECs?
15:41:14 <Peaker> @let result = (.) ; argument = flip (.)
15:41:15 <kappabot>  Defined.
15:41:25 <shachaf> Anyway, kappabot is just here until Cale gets back.
15:41:32 <Cale> wat
15:41:34 <shachaf> If you actually want anything to happen, you should take it up with Cale.
15:41:35 <Peaker> @let infixr 2 ~> ; f ~> g = result g . argument f
15:41:37 <kappabot>  Defined.
15:41:50 <Peaker> @type (*2) ~> length ~> show
15:41:51 <kappabot> forall b1 b a. (Show b, Num b1) => (b1 -> Int -> b) -> b1 -> [a] -> String
15:42:15 <mzero> shachaf: http://conal.net/blog/posts/semantic-editor-combinators
15:42:26 <Peaker> shachaf, SECs are a killer feature/idiom in Haskell, IMO :)
15:42:29 <Peaker> @where SEC
15:42:30 <kappabot> http://conal.net/blog/posts/semantic-editor-combinators/
15:43:04 <Cale> @bot
15:43:05 <kappabot> :)
15:43:05 <Peaker> shachaf, basically if you want to modify some value "inside" another value (where "inside" is much more general than product/record/lens inside)...
15:43:10 <elliott> haha
15:43:12 <lambdabot> :)
15:43:13 <elliott> lambdabot doesn't want any of your @bot
15:43:21 <mzero> indeed - they are very very very cool
15:43:28 <Peaker> @type (fmap . fmap . argument . second . map)
15:43:29 <kappabot> forall (f :: * -> *) (f1 :: * -> *) c d a b. (Functor f1, Functor f) => (a -> b) -> f (f1 ((d, [b]) -> c)) -> f (f1 ((d, [a]) -> c))
15:43:31 <Cale> It's always slow in the beginning because it's busy joining ~100 channels
15:43:34 <lambdabot> Not in scope: `argument'
15:43:34 <shachaf> @quit
15:43:40 <lambdabot> Not enough privileges
15:43:43 <Peaker> @let argument = flip (.)
15:43:50 <lambdabot>  Defined.
15:43:52 <Peaker> @type (fmap . fmap . argument . second . map)
15:43:56 <elliott> Imagine if shachaf was a lambdabot admin.
15:44:00 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) b d a b1. (Functor f, Functor f1) => (a -> b1) -> f (f1 ((d, [b1]) -> b)) -> f (f1 ((d, [a]) -> b))
15:44:01 <elliott> Then that would have been hilarious!
15:44:12 <shachaf> elliott: Imagine that I wouldn't have done that!
15:44:22 <t7> :t arguement
15:44:23 <elliott> shachaf: I would.
15:44:24 <elliott> n't.
15:44:26 <Peaker> shachaf, look at   (f1 ((d, [b1]) -> b))    you can pinpoint the "b1" with the "path" I wrote above
15:44:29 <t7> @type arguement
15:44:30 <lambdabot> Not in scope: `arguement'
15:44:33 <t7> @type argument
15:44:35 <shachaf> Cale: You should make me a lambdabot admin to find out!
15:44:35 <Peaker> shachaf, and apply a function to that point in the type by listing its path with dots
15:44:36 <lambdabot> Not in scope: `arguement'
15:44:40 * shachaf tries "the elliott method".
15:44:42 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
15:44:46 <elliott> shachaf: Oh dear.
15:45:22 <Peaker> "go into two functors, to the left side of (->), to second in tuple, inside another functor"
15:45:30 <Peaker> all expressed with: (fmap . fmap . argument . second . map)
15:45:40 <mm_freak> shachaf: graph reduction
15:45:49 <mm_freak> shachaf: i'm implementing a functional language
15:46:11 <tromp_> which one?
15:46:35 <Peaker> and similarly to (***) which goes into both sides of a tuple at once,    ~> goes into both sides of a function at once..  so:   ((f *** g) ~> h ~> (i *** j))       will apply f,g,h,i,j on the corresponding type vars in  ((a, b) -> c -> (d, e))
15:50:39 <mm_freak> tromp_: i'm working on the core language right now, which is very similar to pisigma
16:17:29 * hackagebot hub 1.0.0 - For multiplexing GHC installations and providing  development sandboxes  http://hackage.haskell.org/package/hub-1.0.0 (ChrisDornan)
16:27:30 * hackagebot pretty-hex 1.0 - A library for hex dumps of ByteStrings  http://hackage.haskell.org/package/pretty-hex-1.0 (IavorDiatchki)
16:32:30 * hackagebot prelude-generalize 0.4 - Another kind of alternate Prelude file  http://hackage.haskell.org/package/prelude-generalize-0.4 (AaronBlack)
16:33:35 <mekeor> mm_freak: does your lang (1) have a name? (2) have haskell-like syntax? (3) be publicly available/accessable?
16:45:10 <t7> 4) is it webscale?
16:48:22 <ion> like Node.js
16:51:06 <shergill> is it just me, or do others more experienced with haskell also feel String would've been better as a typeclass?
16:51:29 <merijn> shergill: How so?
16:52:45 <merijn> Specifically, what would it do/what would you use it for?
16:52:57 <Cale> What would the typeclass methods be?
16:53:20 <sipa> fromString :: String -> a, i guess
16:53:22 <shergill> merijn: would allow functions to work seemlessly, say, across string and text
16:53:23 <hughfdjackson> doesn't string derive the necessary ones? Show, Ord, Eq (and probably more that i haven't looked at yet)
16:53:30 <otters> shergill: yeah
16:53:35 <otters> like ++ instead of `T.append`
16:53:39 <irene-knapp1> I do agree that it would be nice
16:53:41 <shergill> yeah
16:53:41 <otters> which drives me up the balls
16:54:47 <t7> "We can also combine a declaration and a subsequent deÔ¨Ånition: instead of x :œÉ; x = t we write x : œÉ = t. Finally we write unfold t as a shorthand for unfold t as x ‚Üí x"  what does unfold mean in that context?
16:55:02 <mekeor> shergill: there's IsString typeclass.
16:55:28 <mekeor> which is used by -XOverloadedStrings‚Ä¶
16:55:41 <irene-knapp1> yeah, but it should be used everywhere the standard library uses String
16:55:56 <mekeor> that's correct‚Ä¶ i agree.
16:56:15 <mekeor> the standard library should also use Integral instead of Int‚Ä¶
16:56:21 <mekeor> @type (!!)
16:56:22 <lambdabot> forall a. [a] -> Int -> a
16:56:26 <mekeor> dad sux
16:56:30 <shergill> Cale: string/text manipulation functions?
16:57:07 <shergill> mekeor: yeah but it you can also use pack/show to convert between datatypes. it's still cumbersome and feels ugly
16:58:22 <shachaf> Wouldn't it be nice if, like, instead of having types, Haskell *only* had typeclasses? And their instances would be *other typeclasses*.
16:58:57 <mekeor> actually, all operations on String are derived from (:) because Strings are lists of Chars. maybe that typeclass should also just contain something like head and tail?
16:59:23 <Peaker> shachaf, I don't think so.. maybe illustrate with a few example types?
16:59:43 <shachaf> Peaker: I'm only parodying the present sentiment of the channel.
16:59:50 <mekeor> shachaf: no concrete types? hmm‚Ä¶ cool idea!
16:59:51 <peter__> oo
17:00:22 <mekeor> shachaf: no, i think it's really a nice idea. but probably just useless‚Ä¶ hm‚Ä¶
17:00:34 <mekeor> but in case of strings, a typeclass is meaningful for sure!
17:01:07 <shachaf> Not unless you say what that typeclass is.
17:01:56 <dmwit> t7: Judging by the little text you posted, I would suspect "unfold" is one part of the isomorphism between a recursive type and its one-step unfolding.
17:01:56 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
17:01:59 <dmwit> t7: e.g.
17:02:01 <dmwit> ?src Fix
17:02:02 <lambdabot> Source not found. That's something I cannot allow to happen.
17:02:04 <dmwit> ?src Mu
17:02:05 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
17:02:09 <mekeor> lambdabot there again?! coool
17:02:23 <dmwit> t7: "out" is "unfold", probably
17:02:27 <dmwit> ?messages
17:02:27 <lambdabot> notdmwit said 18h 16s ago: https://sites.google.com/site/belayresearchproject/
17:02:29 <mauke> > (+) 0 1
17:02:30 <lambdabot>   1
17:02:31 <t7> ah ok
17:02:32 <dmwit> o right
17:02:35 <mauke> > 1 0 (+)
17:02:36 <lambdabot>   1
17:02:41 <mauke> lambdabot++
17:02:54 <mekeor> shachaf: maybe like this??   class StringLike s where f :: CharLike c => s -> (c,s)
17:03:04 <otters> @uptime
17:03:04 <lambdabot> uptime: 1h 20m 18s, longest uptime: 1m 10d 23h 44m 29s
17:03:42 <hpc> pppsh, that's nothing
17:03:46 <dmwit> mekeor: I don't see how that would help. All of the (performance) problems of String come from that interface.
17:03:52 <hpc> call back when it's more than half a year
17:04:08 <mekeor> dmwit: oh. right.
17:04:23 <dmwit> So anything that was polymorphic enough to handle any instance of that class would necessarily have the performance problems that our new types were designed to avoid.
17:05:04 <mekeor> dmwit: so, there's no solution to that problem currently??
17:05:17 <shergill> perhaps the better way is to go from Text and work backwards?
17:05:29 <dmwit> Text is an instance of many relevant typeclasses.
17:05:45 <dmwit> For example, monoid.
17:05:57 <shergill> right, i just took a look
17:06:29 <shergill> ok so really, there's already an abstraction which does what i want. i just have to stop using strings
17:06:52 <mekeor> dmwit: Eq Data Ord Read Show Typeable IsString Monoid NFData
17:17:43 <jaxtr> ahh it's a wonderful day
17:20:04 <t7> can anyone point me to a definition of the lambda pi calculus?
17:20:09 <t7> please
17:22:14 <hpc> @google lambda pi calculus
17:22:15 <lambdabot> http://lambda-the-ultimate.org/node/506
17:22:15 <lambdabot> Title: The pi-Calculus in Direct Style | Lambda the Ultimate
17:22:37 <t7> that is not my first result
17:22:38 <t7> :|
17:23:07 <dmwit> The pi calculus is not the same as the lambda Pi calculus.
17:23:10 <hpc> google likes to tweak things to each person
17:23:11 <dmwit> Do you know which one you want?
17:23:12 <shergill> so i take it the reason Text abandoned the list abstraction is because there's no way to have such an interface while still maintaining efficiency?
17:23:13 <t7> and thats not what im looking for :|
17:23:23 <ion> t7: http://en.wikipedia.org/wiki/Filter_bubble
17:23:39 <dmwit> If you want lambda Pi, probably the best place to look is in Barendregt's book where he first proposed the lambda cube.
17:24:31 <dmwit> http://www.diku.dk/hjemmesider/ansatte/henglein/papers/barendregt1991.pdf perhaps?
17:24:33 <badnbeefymiracle> what other languages have typeclasses?
17:25:05 <dmwit> Coq, Agda, Idris(?)
17:25:11 <dmwit> probably DDC
17:28:09 <ion> I‚Äôm sure Perl 6 will have them, too.
17:29:15 <tgeeky> has anyone read: www.cs.ox.ac.uk/ralf.hinze/Lifting.pdf , or can understand enough to explain what he means by "However, the set idiom possesses a 'c' [flip] combinator. In other words, there is a need for a linear version of the Lifting Lemma" (page 16, bottom)  (lifting lemma is page 10, middle)
17:34:09 <t7> oh shit de bruijn died this year :(
17:34:39 <hpc> but now who will tell me which function parameters are which?
17:37:01 <geekosaur> p6 is not going the typeclass route, no
17:37:18 <ion> (geekosaur: That was a joke.)
17:38:10 <hpc> ion: sufficiently subtle jokes are indistinguishable from seriousness
17:38:12 <geekosaur> larry would make a comment about sure it does. in the haskell dialect of p6...
17:38:27 * geekosaur is too tired for subtle jokes
17:39:49 <tac-tics> In the limit, infinitesimally subtle jokes are facts.
17:40:04 <irene-knapp1> haha
17:41:46 <badnbeefymiracle> lol pwell 6
17:41:51 <badnbeefymiracle> perl 6*
17:46:22 <ion> tac-tics: :-)
17:47:17 <tac-tics> (That theorem is called the Carlin Property. It's what made George Carlin so popular)
17:47:51 <Peaker> @index fix
17:47:51 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
18:06:20 <shergill> there's no way to generate an infinite stream of Text is there? a Text equivalent of repeat
18:07:22 <mrno>  exit
18:07:41 <Axman6> @hoogle a -> Text
18:07:41 <lambdabot> Data.Text.Lazy unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
18:07:41 <lambdabot> Data.Text unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
18:07:41 <lambdabot> Prelude id :: a -> a
18:07:47 <Axman6> @hoogle Char -> Text
18:07:48 <lambdabot> Data.Text singleton :: Char -> Text
18:07:48 <lambdabot> Data.Text.Lazy singleton :: Char -> Text
18:07:48 <lambdabot> Data.Text.Lazy snoc :: Text -> Char -> Text
18:08:44 <Axman6> shergill: if you have access to the the Text constructors. you can easily make a self recursive piece of Text
18:08:53 <elliott> You can?
18:09:02 <elliott> Text uses an unboxed array.
18:09:07 <elliott> Or is there a linked list on top of that?
18:09:13 <elliott> Non-lazy Text, I mean.
18:09:49 <Axman6> i meant lazy text
18:09:59 <ion> Œª> let cyc t = Data.Text.Lazy.concat (repeat t) in Data.Text.Lazy.take 20 . cyc . Data.Text.Lazy.pack $ "foo"
18:10:00 <ion> "foofoofoofoofoofoofo"
18:11:06 <enoksrd> Can someone suggest a mechanical approach to identifying unused code in a Haskell project?
18:11:16 <shergill> oh right
18:11:20 <shergill> thanks Axman6, ion
18:11:23 <enoksrd> I have found the -fwarn-unused flags, and hpc, but
18:11:41 <enoksrd> the flags require me to add import/export lists everywhere
18:11:44 <hpc> i can't help you ;)
18:12:26 <enoksrd> and i believe hpc does run-time / dynamic code coverage
18:12:39 * hackagebot lz4 0.1.0.1 - Haskell bindings to the lz4 compression library  http://hackage.haskell.org/package/lz4-0.1.0.1 (MarkWotton)
18:12:49 <enoksrd> but i'd prefer to know code that is not reachable on any possible run (so statically)
18:13:12 <ion> What‚Äôs wrong with export lists?
18:13:35 <enoksrd> ion: i inherited the code and it's a huge mess.
18:14:01 <enoksrd> i plan to add export lists later, but first i'd like to just delete everything that's never used (which has included whole files already :P)
18:14:02 <dmwit> I don't know of such a tool, though it seems feasible to write one.
18:14:13 <hpc> enoksrd: you can use a combination of grep and 'wc -l' to get a rough estimate
18:14:59 <Clint> grep -c
18:15:20 <enoksrd> hpc: you mean grepping for the occurrence of an identifier and counting the number of matches?
18:15:26 <hpc> yeah
18:15:41 <hpc> it'll get at least some of them
18:15:52 <hpc> making the rest more managable
18:15:53 <enoksrd> hpc: i have ~ 10,000 lines of code here, so that will take a while
18:16:19 <enoksrd> but yes, i've been using a similar approach so far, but it's getting frustrating
18:17:24 <enoksrd> dmwit: agreed.  i believe i'm just looking for reachability from 'main'.
18:17:24 <shergill> 10000 loc in a haskell project? is it darcs?
18:17:37 <dmwit> enoksrd: http://hackage.haskell.org/package/SourceGraph
18:17:47 <shergill> enoksrd: you may want to give sou.. what dimwit posted
18:18:25 <enoksrd> shergill: no, it's an implementation of an in-progress programming langauge
18:18:25 <blackdog> hey, is it normal for haddock on hackage to lag a bit?
18:18:27 <shergill> *dmwit sorry
18:18:32 <Clint> yes
18:18:35 <Axman6> blackdog:  yeah
18:18:43 <blackdog> looking at http://hackage.haskell.org/package/lz4 - i've added haddock stuff, but nothing's showing up
18:18:46 <blackdog> ah, fair enough.
18:19:01 <dmwit> haddocks are built once a day
18:19:01 <Axman6> it runs every 6 hours or so I think
18:19:07 <Axman6> or once a day...
18:19:27 <Axman6> i was pretty sure it was more frequent than once a day
18:19:35 <dmwit> You're probably right.
18:19:53 <blackdog> that's an odd decision. presumably the work has to be done anyway, why not do it on upload?
18:20:10 <dmwit> I honestly don't know.
18:20:54 <enoksrd> dmwit: thanks. that might be exactly what i need (a quick look shows it reports "inaccessible entities")
18:20:56 <shergill> perhaps payoffs from batch processing? or more probable, it was easier to hook a cron job
18:20:58 * enoksrd goes to investigate
18:21:51 <shergill> enoksrd: sourcegraph seems to have trouble with some haskell syntax. running it on my yesod app didn't yield very impressive results; ymmv
18:24:14 <blackdog> shergill: suppose so. but there's obviously some stuff getting run on upload, or it wouldn't appear at all.
18:25:02 <shergill> blackdog: true
18:52:49 <enoksrd> shergill: well, my copy of SourceGraph is still `cabal install`ing :P
18:53:04 * enoksrd crosses fingers
18:53:25 <shergill> oh wow
18:55:11 <enoksrd> i spent 10 minutes upgrading cabal first, because i ran into this bug: http://hackage.haskell.org/trac/hackage/ticket/714
18:55:35 <enoksrd> but this still seems excessive :D
18:57:38 <shergill> enoksrd: yeah i've run into that once or twice. it's annoying as hell, especially the first time around when i didn't know what was up
19:07:56 <tibbe> I'm having trouble wrapping up a function in an existential.
19:08:10 <startling> how would I remove all traces of my haskell installation in order to start over?
19:08:27 <startling> I've been getting the weirdest errors
19:09:16 <startling> namely SIGSEGVs everywhere and importing failing silently no matter what
19:12:02 <startling> I suppose the thing to do would be to kill my ~/.cabal directory and uninstall ghc?
19:12:12 <startling> any other hidden treasures?
19:14:16 <tibbe> startling: rm -rf ~/.ghc ~/.cabal
19:14:29 <tibbe> that will kill all installed packages
19:14:34 <tibbe> ~/.ghc is actually enough
19:15:11 <startling> tibbe: thanks!
19:15:21 <tibbe> you're welcome
19:17:37 <startling> what are the differences between ~/.ghc and ~/.cabal, by the way?
19:18:47 <otters> well, the name
19:19:11 <Adeon> other one comes before the other in alphabetical sorting
19:19:30 <otters> harf harf harf harf
19:19:32 <geekosaur> ~/.ghc is owned by GHC and stores user packages.  ~/.cabal is where cabal-install caches package information and writes documentation; the actual packages are then installed under ~/.ghc as user packages and registered with ghc as such
19:19:44 <otters> wow, would you look at that? a helpful answer
19:20:48 <startling> geekosaur: thanks!
19:20:52 <geekosaur> if we had multiple viable compilers (uhc and jhc are getting there but not quite complete enough as yet), the compiler-specific package libraries would be stored in the compilers' preferred locations as with ~/.ghc and the common compiler-independent stuff would remain under ~/.cabal
19:21:45 <startling> occasional sigsegvs are still there
19:21:50 <geekosaur> I think cabal-install has some ability to install packages for hugs and nhc98 but both are pretty much dead at this point
19:22:36 <startling> https://gist.github.com/09a425a2cc34aea5bea3
19:22:44 <startling> only happens every once in a while
19:23:58 <startling> also, nonsensical imports don't say anything and valid imports don't import anything: https://gist.github.com/09a425a2cc34aea5bea3
19:24:09 <geekosaur> it would be somewhat interesting to see where it's dying; can you try it under gdb?
19:24:14 <startling> yep
19:24:50 <geekosaur> hm, actually, that will b difficult because of the wrapper script :(
19:25:44 <geekosaur> you would have to find out the actual command run by the wrapper (which will be the real ghc binary with a bunch of path options telling it where to find packages, imports, libraries, etc.)
19:26:09 <startling> it's just exec "/usr/local/Cellar/ghc/7.4.1/bin/ghc-7.4.1" --interactive ${1+"$@"}
19:26:40 <geekosaur> hm, right, I suppose homebrew would compile in real paths; it's the official packages that pass -B options etc.
19:27:12 <geekosaur> so:  "gdb /usr/local/Cellar/ghc/7.4.1/bin/ghc-7.4.1", then ":run --interactive"
19:27:40 <startling> "/usr/local/Cellar/ghc/7.4.1/bin/ghc-7.4.1": not in executable format: File format not recognized
19:28:03 <geekosaur> sigh.  so, *that* is the wrapper script, I suspect
19:28:08 <startling> yep
19:28:17 <startling> heh
19:29:26 <geekosaur> aaaand, come to think of it, this may be a lose anyway; unless you have gdb from homebrew *and* they picked up the most recent patches, gdb may well fall over
19:29:44 <startling> neither of those are true
19:30:16 <geekosaur> apple's gdb is moderately buggy, and tends to do things like incorrectly follow dylib stubs in haskell-generated executables
19:30:33 <startling> alright. so uhhh, what now?
19:30:52 <geekosaur> and more recent gdbs have even worse bugs, since they lack apple's BFD patches for SL/Lion changes to Mach-O binary format
19:31:01 <geekosaur> try installing gdb from homebrew?
19:31:28 <startling> hm, doesn't seem to have it?
19:31:33 <geekosaur> ugh
19:31:34 <startling> Could've sworn it did
19:35:42 <otters> @src intercalate
19:35:42 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
19:35:49 <otters> @src intersperse
19:35:49 <lambdabot> intersperse _   []     = []
19:35:50 <lambdabot> intersperse _   [x]    = [x]
19:35:50 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
19:57:26 <edwardk> preflex: xseen conal
19:57:27 <preflex>  conal was last seen on freenode/#haskell 3 days, 10 hours and 20 seconds ago, saying: augur: except that i think one can capture the tree shape in a type, even when the tree isn't perfect. when perfect, the depth is enough.
20:20:49 <edwardk> is there a version of http://www.cs.ox.ac.uk/people/ralf.hinze/publications/ICFP02.pdf on hackage somewhere?
20:21:39 <edwardk> i have a rather cleaned up and modernized version i was playing with but i'm not sure i want to get into the business of rebuilding edison ;)
20:22:43 <badnbeefymiracle> hi
20:23:03 <otters> is there a Text version of printf? D:
20:24:03 <copumpkin> unriffle, eh
20:24:18 * copumpkin adds that to his list of meaningless words to use to name functions
20:24:50 <otters> having to use printf when input and output is all in Text = not fun
20:25:18 <copumpkin> don't use printf
20:25:23 <copumpkin> :P
20:25:28 <otters> what should I use
20:25:30 <otters> :|
20:25:34 <ben> just define textPrintf = fromString . printf :))))
20:25:36 <copumpkin> lol
20:25:38 <ben> what could go wrong :)))
20:25:55 <otters> because frankly using T.concat is just gross
20:27:36 <otters> okay, what about interleaving two lists?
20:27:54 <otters> interleave [a,b,c] [d,e,f] -> [a,d,b,e,c,f]
20:28:10 <Ralith> what about it?
20:28:22 <otters> is there a library function for that?
20:28:39 <Ralith> @hoogle [a] -> [a] -> [a]
20:28:39 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
20:28:40 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
20:28:40 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
20:28:52 <Ralith> looks like probably not
20:29:00 <otters> crap
20:29:11 <Ralith> it's trivial, though
20:29:18 <otters> yeah
20:29:53 <startling> @hoogle [(a, a)] -> [a]
20:29:53 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
20:29:53 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
20:29:54 <lambdabot> Prelude snd :: (a, b) -> b
20:30:17 <ben> flatten . zipWith (\a b -> [a, b])?
20:30:17 <ben> i'm stumped
20:30:29 <startling> ben: that's what I was thinking
20:30:51 <otters> :t flatten . zipWith (\a b -> [a,b])
20:30:52 <lambdabot>     Couldn't match expected type `Tree a'
20:30:52 <lambdabot>            against inferred type `[b] -> [[b]]'
20:30:52 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
20:31:03 <ben> though I suppose that's almost flatten . transpose
20:38:49 <mm_freak> @tell mekeor (1) vortex core (2) yes (3) not yet
20:38:49 <lambdabot> Consider it noted.
20:41:05 <mm_freak> i'm unable to find any papers on the STG machine
20:41:22 <mm_freak> how can you work without a spine?
20:44:30 <edwardk> mm_freak: ask a flatworm
20:44:41 <rekado> Hi, I'm using Aeson to parse a nested JSON structure.
20:45:03 <rekado> trying to get an optional key inside an optional key.
20:45:25 <rekado> it would be easy to do this if the containing structure was not optional:
20:45:59 <rekado> ((v .: "container") >>= (.:? "inside"))
20:46:23 <rekado> but when "container" is optional, I have to use a lambda to strip of the Maybe.
20:46:31 <rekado> Is there a combinator that does this for me?
20:48:59 <rekado> I currently use this, and I think it's ugly as hell:
20:49:01 <rekado> ((v .:? "container") >>= (\c -> if c == Nothing then return Nothing else (fromJust c) .:? "inner"))
20:50:00 <shachaf> I think you want something like (>>=)...
20:50:08 <Ralith> he's using >>=
20:50:08 <shachaf> I'm not sure of the types of all those other things involved there.
20:50:15 <shachaf> Ralith: The other >>=.
20:50:21 <Ralith> what?
20:50:22 <shachaf> Unless that >>= is also Maybe?
20:50:27 <Ralith> ...what?
20:50:32 <Ralith> oh
20:50:46 <Ralith> I am probably confused by not knowing anything about this lib
20:50:51 <rekado> that's all inside the instance declaration of FromJSON
20:50:56 <shachaf> rekado: First off, you want to say (\c -> case c of Nothing -> return Nothing; Just x -> x .:? "inner")
20:51:10 <shachaf> That's much better than the (==Nothing)/isJust/fromJust mess.
20:51:35 <rekado> shachaf: agreed. But it's still ugly.
20:51:42 <Ralith> next up is c >>= (\x -> x .:? "inner")
20:51:44 <shachaf> Yes.
20:51:54 <shachaf> Ralith: No, that's not the same function.
20:51:57 <Ralith> may need a return in there too
20:51:59 <Ralith> oh?
20:52:05 <shachaf> Look at the types again.
20:52:10 <shachaf> rekado: Second, you can use something like maybe:
20:52:12 <shachaf> @ty maybe
20:52:13 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:52:20 <Ralith> he hasn't given types :P
20:52:25 <shachaf> maybe (return Nothing) (.:? "inner")
20:52:51 <rekado> shachaf: ha, I was just looking this up on hoogle.
20:53:00 <shachaf> In fact maybe that's the nicest you'll be able to make it. I don't know how the .:? thing works.
20:53:02 <rekado> thanks.
20:53:16 <shachaf> Ralith: Yes, but you can infer them!
20:53:19 <rekado> .:? is Parser (Maybe t0)
20:53:29 <Ralith> I could if I knew the first thing about the code he was calling
20:53:32 <rekado> (I think)
20:54:07 <shachaf> Ralith: I don't know anything aobut the code. But I do know that c has to be of type (Just something), and therefore fromJust c (or x) has to be of type something.
20:54:24 <shachaf> Oh, maybe I just misread what you meant.
20:54:32 <shachaf> Yes, OK, I did.
20:54:36 <shachaf> It still doesn't work, though.
20:55:56 <rekado> actually, this does compile.
20:56:46 <rekado> ((o .:? "container") >>= maybe (return Nothing) (.:? "inner"))
20:56:59 <shachaf> Right.
20:57:10 <rekado> thank you.
20:57:51 * hackagebot zigbee-znet25 0.1 - XBee ZNet 2.5 (ZigBee) wireless modem communications  http://hackage.haskell.org/package/zigbee-znet25-0.1 (DavidJoyner)
21:01:10 <buriedHead> haskell noob here: i tried googling around for the right way of representing an object (directed acyclic) graph in the same way as we do in C++ with objects and pointers. It seems like they all recommend some graph library. What's wrong with simply using a recursive data structure?
21:01:35 <Ralith> buriedHead: graph libraries use recursive data structures.
21:01:44 <buriedHead> oh sure yes
21:01:59 <buriedHead> Ralith: but I meant ... instead of using indirections
21:02:05 <Ralith> indirections?
21:02:39 <buriedHead> Ralith: so ... i guess I am asking if I can directly have something like Node(child1,child2,child3)
21:03:04 <buriedHead> Ralith: where the same node could be child to many nodes
21:03:18 <shachaf> buriedHead: Haskell doesn't have pointer equality directly.
21:03:20 <Ralith> then that's not acyclic.
21:03:26 <shachaf> buriedHead: (On purpose.)
21:03:41 <shachaf> So you have to come up with some notion of "identity" yourself if you want to compare things.
21:04:31 <shachaf> Also, changing an immutable graph can sometimes be awkward. It's much more awkward if you have cycles, of course.
21:05:03 <buriedHead> shachaf: changing graph is an issue, ok yes that makes sense
21:06:07 <Saizan> if you do a directed acyclic graph in the naive way it'll look like a tree from the POV of the consumer
21:06:14 <Saizan> because the sharing is implicit
21:06:29 <buriedHead> Saizan: unless I can compare subparts for equality, yes
21:06:31 <Saizan> it could be fine for your purpouses though
21:06:49 <Saizan> buriedHead: yeah, but that's generally expensive because we don't have pointer equality
21:07:34 <Saizan> hence these graph libs which use an explicit identifier when they create a node
21:10:03 <buriedHead> so on a related note ... I was writing this data structure for digital logic circuits with AND/NOT gates ... simple enough. For the sake of exposition, let's say I attempt to do with without the graph libraries, by directly embedding child pointers the bad way. If I want to write an equality comparison here for entire circuits, am I just asking for trouble? Is there any way I can avoid comparing shared parts multiple times?
21:11:09 <buriedHead> or am I dead in the water because of the no pointer equality thing?
21:11:14 <shachaf> Yes -- by defining "identity" yourself using something that you can compare.
21:11:44 <buriedHead> ok
21:13:52 <buriedHead> thanks for all your answers ... shachaf, Saizan and Ralith! Let's see what I can do about these
21:23:59 <Saizan> np
23:13:07 * hackagebot accelerate 0.12.1.0 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.12.1.0 (ManuelChakravarty)
23:13:09 * hackagebot accelerate-cuda 0.12.1.0 - Accelerate backend for NVIDIA GPUs  http://hackage.haskell.org/package/accelerate-cuda-0.12.1.0 (ManuelChakravarty)
23:13:11 * hackagebot accelerate-io 0.12.1.0 - Read and write Accelerate arrays in various formats  http://hackage.haskell.org/package/accelerate-io-0.12.1.0 (ManuelChakravarty)
23:13:13 * hackagebot accelerate-examples 0.12.1.0 - Examples using the Accelerate library  http://hackage.haskell.org/package/accelerate-examples-0.12.1.0 (ManuelChakravarty)
23:17:16 <Lemon> I am writing a type checker and I have no idea what I'm doing
23:17:21 <Lemon> somebody help
23:18:31 <Lemon> more specifically, how am I supposed to typecheck patterns?
23:19:09 <Lemon> all the material I found dealt only with functions and built-in datatypes
23:19:17 <Saizan> a lot like you typecheck expressions
23:20:44 <Saizan> the difference is that variables appearing within them (as opposed to constructors) work like if they were the x in \ x -> ..
23:20:47 <c_wraith> almost exactly, really.  except expressions can only be constructors and free variables
23:22:10 <Saizan> so you add them to the scope, rather then checking if they already are in it
23:23:32 <Lemon> okay
23:53:32 <rodayo> got an exercise due in 8 mins. can someone tell me what's wrong with this line: join sep xs = foldr (\acc str = acc ++ sep ++ str) "" xs    I'm getting a parse error on the '='
23:53:59 <startling> rodayo: in ghci?
23:54:05 <rodayo> yep
23:54:12 <startling> rodayo, you need to use let in ghci
23:54:22 <ClaudiusMaximus> there are 2 = there, you probably want the second to be ->
23:54:27 <rodayo> no no, sorry i'm loading it in ghci
23:54:36 <rodayo> it's in a .hs file
23:54:44 <startling> rodayo, ClaudiusMaximus has got it
23:54:52 <startling> rodayo, lambda uses ->, not =
23:55:01 <rodayo> uggh that always gets me :p
23:55:03 <rodayo> thanks alot
