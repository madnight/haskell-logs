00:32:39 <Zeiris> Is there anything on Hackage that'll come close to Python's matplotlib in utility?
00:33:15 <Zeiris> Bindings to other language libs would work, I guess, provided the installation process is trivial.
01:07:22 <blackdog> say you were going to write an IO-intensive haskell program that you wanted to be able to scale up to many machines if necessary. what would be the sensible options, in terms of libraries?
01:07:43 <blackdog> having a quick look at Holombus...
01:15:07 <blackdog> it's entirely possible that i'm overthinking this and that the network is always going to be the bottleneck anyway, of course.
01:36:48 <zenzike> I'm looking into analysing a lot of C++ code, and I'd like to generate some metrics. I saw that there's a Language.C package in hackage, does anybody know if someone has attempted to work on something similar for C++?
01:37:26 <Jafet> Try geordi
01:37:38 <Jafet> I doubt you can get any closer to parsing C++ than that.
01:37:59 <fasta> Jafet, there is a company which specializes in this stuff. 
01:38:13 <fasta> I think they come closer, but for $$$.
01:38:31 <Jafet> fasta: in Haskell?
01:39:03 <fasta> Getting an AST into Haskell should be the least of your problems.
01:39:07 <Jafet> Sure, there's the high-nosed people at edison
01:39:07 <zenzike> Jafet: thanks. that's a good start. 
01:40:49 <zenzike> do you happen to know how hard it is to build an AST for C++ code? Is it known to have a crazy grammar?
01:41:05 <fasta> zenzike, yes, it is known to have a crazy grammar. 
01:41:16 <zenzike> I feared as much.
01:41:21 <Jafet> One might be hard pressed to describe its rules as grammatical
01:41:30 <zenzike> hehe :-)
01:42:17 <Starfire> Perhaps clang could be used to parse C++ nowadays?
01:43:12 <Jafet> There is an obvious advantage in using a compiler that people target their code against, to parse the code
01:45:37 <quicksilver> I think geordi does pretty well
01:45:42 <quicksilver> but I've no idea if it produces a useful ADT
01:48:27 <Eelis> geordi's C++ "parser" produces a value of an ADT that's pretty much a direct transcription of the grammar production rules.
01:48:52 <Eelis> however, since it doesn't do name lookup, it easily gets confused by ambiguous constructs involving expressions v.s. types and such.
01:49:44 <Eelis> also, geordi's C++ parser is extremely inefficient. i could get away with this because it's only used to parse snippets the size of an irc message.
01:51:09 <Eelis> i would definitely be interested in a Haskell library to translate Clang's XML output to a convenient Haskell ADT.
02:03:20 <mjrosenb> Eelis: clang's XML output is just its parse tree of C?
02:32:15 <zenzike> Starfire: thanks for the clang pointer. I hadn't realised just how much work they had done.
03:52:23 <bla123> ghc seems to leak memory: http://hpaste.org/40669/ghc_leaks_memory
03:55:14 <Ke> bla123: using alot of memory is not a memory leak
03:56:05 <Botje> bla123: GHC does not give memory back to the OS, iirc
03:56:11 <bla123> but shouldn't it release the memory that useSomeMemory consumed? it is not referenced afterwards
03:56:27 <Botje> there's very few programming languages that do that
03:56:27 <mjrosenb> bla123: try to re-use the memory
03:56:37 <bla123> Botje: do you mean NEVER!?
03:56:40 <mjrosenb> bla123: and see if you take up more memory
03:56:55 <mjrosenb> or if it just continues to use the same amount
03:56:56 <quicksilver> bla123: it's "released" in the sense of available to be used again. It's not released from your app back to the OS.
03:57:07 <Ke> if GHC really uses linux stack, it most certainly does not release any memory
03:57:07 <quicksilver> as Botje says, essentially no languages do that.
03:57:21 <mjrosenb> bla123: up until recently, malloc/free in C never gave up the memory.
03:57:42 <Botje> bla123: the only interface programs have to request memory is the sbrk() system call
03:57:43 <bla123> but doesn't a behaviour like that preclude long-running apps like server to be written in those languages?
03:57:48 <quicksilver> nope.
03:57:53 <quicksilver> because the memory can be used again
03:57:59 <quicksilver> the next time the program needs it.
03:58:28 <quicksilver> Java behaves the same, for example. Plenty of servers are written in Java.
03:58:31 <bla123> but what if another program needs it? shouldn't several deamons for example share the "free" memory?
03:58:52 * hackagebot xmms2-client 0.0.6.0 - An XMMS2 client library.  http://hackage.haskell.org/package/xmms2-client-0.0.6.0 (OlegBelozeorov)
03:58:54 * hackagebot xmms2-client-glib 0.0.6.0 - An XMMS2 client library  GLib integration.  http://hackage.haskell.org/package/xmms2-client-glib-0.0.6.0 (OlegBelozeorov)
03:59:09 <Botje> bla123: the OS can swap those pages out
03:59:10 <mjrosenb> bla123: the actual memory used by all of your programs should (in general) only be a small fraction of the memory on a system.
03:59:37 <mjrosenb> bla123: if another program needs the memory, the unused bits from your application will likely get swapped to disk.
04:00:04 * bla123 is a bit disturbed
04:01:17 <bla123> i think i will increase my swap space ...
04:01:37 <Botje> or install more ram ;)
04:01:44 <Botje> alternatively, you can limit haskell's heap size
04:01:51 <Botje> then you know it won't use more than that
04:02:01 <mjrosenb> bla123: patches welcome.
04:02:39 <bla123> installing more ram would be a waste, right? after all, a lot of it might end up being used just for pseudo-free memory
04:02:41 <Ke> I'd say writing daemons without explicit memory management by the programmer is silly
04:02:52 <Ke> unless you really want something cheap
04:03:36 <bla123> Ke: mjrosenb said that "up until recently" not even C really freed the memory
04:03:56 <Ke> I have no idea what he means
04:04:05 <ManateeLazyCat> HI all. :)
04:04:20 <Ke> perhaps something like, not before year 2000
04:04:40 <mjrosenb> Ke: malloc will now *occasionally* give you memory allocated with mmap("/dev/zero") rather than using the heap.
04:05:01 <Ke> mjrosenb: yes, there is an env for that
04:05:04 <bla123> Ke: i think he means that a call to free() will not return any memory to the OS unless you just happen to free the data with the highest address in your address space
04:05:08 <Ke> 12kB by default
04:05:08 <mjrosenb> but if you are not allocating huge things, you'll still get data from the heap
04:05:12 <bob31> anyone using ghc on Debian or Ubuntu and having successfully ran buildbot snapshots? I can't seem to dynlink gmp
04:05:30 <mjrosenb> at which point, freeing the memory does not return it to the OS
04:05:35 <Ke> you are irrelevant
04:06:47 <Ke> ;o)
04:07:12 <bla123> Ke: names, please ;)
04:07:58 <Ke> I'm just fed up with these guys writing python daemons for phones
04:08:28 <Ke> if heap fragmentation is really an issue, it can be profiled
04:08:30 <Botje> the way android does it is pretty cool
04:08:59 <Botje> they abuse the copy-on-write properties of fork() to get a lot of sharing
04:09:00 <therp> Botje: what does android do (briefly)?
04:09:13 <therp> ah :)
04:09:38 <Botje> so if you start a new application, a signal is sent to this application, which forks off a process and then starts your real application
04:09:51 <Botje> you still get a new java vm, but a LOT of stuff is shared
04:10:11 <therp> neat!
04:10:17 <Ke> well we do have shared libs even without that
04:10:33 <bla123> Botje: why did you say "abuse"? isn't that the way it's meant to be?
04:11:01 <therp> isn't that also happening in KDE? wasn't there a kde application launcher at some point?
04:11:20 <Botje> bla123: good point
04:15:03 <zygoloid> therp: that's what kde used to do. but it wasn't for sharing so much as for reducing dynamic link times.
04:16:10 <therp> ah right, there was this thing called prelink...
04:16:41 <zygoloid> this was pre-prelink, iirc. and ultimately the fix was to make ld.so not suck so much
04:17:03 <zygoloid> that and lots of visibility annotations
04:18:44 <koala_man> bla123: it's the way fork was meant to be, but forking an existing app to create a new instance instead of generic fork/exec was never the intention
04:19:10 <bla123> koala_man: ok, i see
04:19:33 <koala_man> sweet hack though
04:20:01 <koala_man> almost as good as a vm that can run multiple apps
04:21:24 <bla123> OK, one more try at that memory issue: couldn't the gc defragment the whole virtual memory space on the largest collections and trim the superfluous memory?
04:21:49 <bla123> (returning it to the OS)
04:22:50 <Botje> bla123: you cannot return memory to the OS.
04:23:18 <bla123> Botje: as in "there's no syscall for it"?
04:23:46 <Botje> heh
04:23:56 <Botje> okay, maybe you can
04:24:00 <Botje> http://stackoverflow.com/questions/2051994/how-do-i-free-memory-obtained-by-sbrk
04:24:08 <Botje> (sbrk is the syscall to request more memory)
04:24:30 <Botje> but i guess people don't use it because shrinking memory using sbrk might not be portable
04:25:28 <Botje> and it's also possible to use mmap to randomly get stuff.. brr
04:25:44 <bla123> Botje: well, without further investigation, i wouldn't even assume that it really returns the memory
04:26:12 <koala_man> glibc uses mmap CoW on /dev/zero for allocations over 128k or so, that way they can be returned to the os immediately when freed
04:28:37 <ketil> Is there a standard lines that removes superflous ^Ms at the ends?
04:29:32 <zygoloid> ketil: usually the ^Ms would be removed by the IO layer
04:31:03 <Ytinasni> bla123: the runtime doesn't return memory to the OS because the process doesn't own any memory; it merely has address-space.
04:31:30 <zygoloid> ketil: see GHC.IO.Handle.hSetNewlineMode if you want to configure that
04:31:44 <Ytinasni> address-space backed by memory, i'll agree, but that's just an implementation detail.
04:34:31 <bla123> Ytinasi: but the application could tell the os to free some virtual pages (so that they are not backed by real memory any longer and an access would cause a segfault)
04:35:02 <ketil> zygoloid, hm.  But changing it would mean that lines without ^M would not be counted as lines?
04:35:30 <ketil> zygoloid, current hack: filter (/= Char.chr 13).
04:37:57 <benmachine> ketil: filter (/= '\^M')
04:38:02 <benmachine> would be slightly less of a hack
04:40:06 <Ytinasni> bla123: given the cost of a syscall, that's too slow.
04:41:06 <bla123> Ytinasi: swapping is also expensive
04:41:06 <Ytinasni> a more efficent way (read: what actually happens in most language runtimes) is the GC zeros unused memory at the first opportunity, so that the cost of making thatmemory available to other applications is near 0.
04:41:18 <Ytinasni> by avoiding swapping.
04:41:29 <bla123> Ytinasi: ok, i see
04:42:41 <ketil> benmachine, :-)  Thanks, though.  Saves one import.
04:43:36 <bla123> Ytinasi: so that means that it is even more complicated to figure out how much memory an application is really using
04:44:00 <Ytinasni> ask the 
04:44:09 <Ytinasni> ask the OS 
04:44:14 <Ytinasni> it knows :D
05:10:09 <zygoloid> ketil: inputNL = CRLF means 'translate both "\n" and "\r\n" into newline on input'.
05:38:10 <EnglishGent> hello
05:48:01 <dino-> EnglishGent: Hello
05:48:25 <EnglishGent> hi dino- :)
05:52:30 <ManateeLazyCat> EnglishGent: Hey. :)
05:54:00 <EnglishGent> hi ManateeLazyCat :)
05:54:07 <wjt> ManateeLazyCat: hey, you called? :)
05:54:13 <ManateeLazyCat> wjt: Yes.
05:54:31 <ManateeLazyCat> wjt: I just working on binding Evince library, do you interested?
05:54:31 <wjt> ManateeLazyCat: (I haven't released the GooCanvas binding yet due to a lack of time :))
05:54:57 <wjt> I really think it would be worth automating the tedious parts of writing bindings using gobject-introspection
05:55:05 <ManateeLazyCat> wjt: I have binding poppler library, but i found Evince can do better since it support pdf, ps, dvi...etc.
05:55:26 <wjt> I don't really have time to help out with binding Evince, sorry
05:55:57 <ManateeLazyCat> wjt: Well gobject-introspection is not silver bullet.
05:56:11 <ManateeLazyCat> EnglishGent: Hey, how you doing?
05:56:37 <ManateeLazyCat> wjt: Some complicated situation, you still need hand tweak.
05:56:46 <wjt> ManateeLazyCat: not at all, but it would save a lot of writing out newAttrFromUIntProperty bindings
05:57:31 <ManateeLazyCat> wjt: I remember Matt working on gobject-introspection....
05:57:56 <ManateeLazyCat> wjt: Infact, gtk2hs have tool generate code that base on GObject.
05:58:04 <ManateeLazyCat> wjt: Don't need write by hand.
05:58:31 <wjt> ManateeLazyCat: i haven't been able to find any actual concrete g-i code
05:58:57 <wjt> maintaining custom tools where the g-i have done most of the hard work seems a suboptimal route
05:59:05 <ManateeLazyCat> wjt: Yep, i just hard Matt working on it (some months ago), but i don't know the progress.
06:03:01 <ManateeLazyCat> wjt: I was want g-i too, but not too much now.
06:03:39 <ManateeLazyCat> wjt: I use gtk2hs's ApiGen tool generate new GTK+ code, and tweak someplace by hand.
06:07:23 <ManateeLazyCat> wjt: Let me know you release GooCanvas, i want to play. :)
06:07:27 <wjt> ManateeLazyCat: sure :)
06:21:11 <tab> they are utf8 usually nowadays
06:21:44 <tab> gah wrong window
06:28:08 <fasta> tab, not wrong tab? 
06:29:09 <tab> fasta: :D, definitely the window
06:38:15 <bastl> Hello, could someone review http://hpaste.org/40675/clean_me_up ? I feel it can be written much more concisely, but im unsure about "good" style ...
06:38:48 * EvanR-work puts the link to the haskell style guide
06:38:55 <EvanR-work> except i dont know it
06:39:49 <HugoDaniel> bastl, "let Configuration config = readConfig src"
06:39:50 <HugoDaniel> hmm
06:40:02 <HugoDaniel> is Configuration a data type ?
06:40:17 <bastl> I'd like to concat lines 3,4,5, and 7,8
06:40:22 <bastl> yes.
06:40:30 <HugoDaniel> ok
06:40:43 <Axman6> (readFile rulefile) -> readFile rulefile
06:40:49 <Axman6> no need for the brackets
06:41:00 <Axman6> same with map (show) -> map show
06:41:38 <Axman6> map (show) (zip config results) could be map show $ zip config results
06:41:40 <bastl> brackets are not needed, but sometimes guide the reader :-) I dont care about brackets :-)
06:42:02 <bastl> Axman of course.
06:42:09 <bastl> thats too silly.
06:42:16 <Axman6> why not mapM_ putStrLn . map show $ zip config results?
06:42:43 <bastl> no nested maps, makes readers brain explode.
06:43:08 <Axman6> actually, what ypu're doing is just applying print
06:43:10 <EvanR-work> map show (zip config results) ftw
06:43:26 <Axman6> could make it mapM_ print $ zip config results
06:43:29 <EvanR-work> conservation of $
06:44:19 <bastl> ok. thanks. how about lines 3,4,5. in RWH there was something about fmap with IO-actions ...
06:44:30 <EvanR-work> liftM
06:44:33 <Axman6> there's also Configuration config <- readConfig `fmap` readFile rulefile
06:44:47 <bastl> yep.
06:45:06 <Axman6> and sleep time, night
06:45:37 <kaini> Hi, if I use list comprehension can I add multiple elements with one iteration? (eg. [ ??? | x <- [1..10]] shall generate a list [1, 1, 2, 2, 3, 3, ...])
06:45:54 <HugoDaniel> i have never used mapM :/
06:45:55 <Axman6> eh?
06:46:05 <Axman6> HugoDaniel: it's very useful
06:46:08 <Axman6> :t mapM
06:46:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:46:21 <Axman6> i find i use mapM_ more though
06:46:24 <Axman6> :t mapM_
06:46:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
06:46:33 <Axman6> @src mapM_
06:46:33 <lambdabot> mapM_ f as = sequence_ (map f as)
06:46:34 <HugoDaniel> oh that
06:48:41 <HugoDaniel> i dont know why i have never used that :/
06:49:08 <HugoDaniel> i do get to use and abuse applicative and (.), maybe they do the rounds for me :/
06:51:45 <HugoDaniel> bastl, i usually have a case on getArgs
06:52:01 <HugoDaniel> so i can display some usage guidelines to the user
06:52:58 <bastl> it's just a prototype. I want to remove all noise, that distracts from the "map check config" .
06:53:35 <bastl> Id rather like to get lines 3,4 together, the parsing of the Configuration might be presented as a separate step ...
06:54:47 <HugoDaniel> ok
06:55:05 <HugoDaniel> there are some things you can use to improve the poetry of your code
06:55:29 <HugoDaniel> for instance
06:55:31 <HugoDaniel> you have
06:55:40 <HugoDaniel> let Configuration config = readConfig src
06:55:41 <HugoDaniel> and then
06:55:44 <EvanR-work> poetry -> incontrovertible proof object ;)
06:55:47 <HugoDaniel> results <- mapM check config
06:56:03 <HugoDaniel> you could change the data type of check
06:56:06 <HugoDaniel> say
06:56:31 <HugoDaniel> define check as check :: Configuration -> Bool
06:56:33 <HugoDaniel> and then
06:56:44 <HugoDaniel> do it like: check (Configuration cfg) =  bla bla bla ...
06:57:00 <HugoDaniel> you could also just use a lambda there, if the function is simple enough...
06:57:40 <EvanR-work> or a pointless expression
06:57:43 <HugoDaniel> yes
06:57:51 <EvanR-work> ((< 16) . length)
07:01:30 <osaunders> Is it possible to declare a data type with a type the same as an existing definition? Example: foo = 'f'; data Bar = Bar { zim :: (:: foo) }
07:02:35 <HugoDaniel> osaunders: i dont understand your question
07:03:09 <osaunders> HugoDaniel: I want to declare zim (a part of Bar) with the type that foo has.
07:03:22 <HugoDaniel> osaunders: ok, there is no problem with that
07:03:24 <HugoDaniel> say
07:03:29 <HugoDaniel> foo :: a -> b -> c
07:03:31 <HugoDaniel> then
07:03:46 <HugoDaniel> data Bar = Bar { test :: a -> b -> c }
07:04:04 <HugoDaniel> test has the same type as foo
07:04:05 <osaunders> OK, now without the duplication.
07:04:23 <osaunders> s/now/now do it/
07:04:27 <HugoDaniel> data Bar a = Bar { test :: a }
07:04:28 <HugoDaniel> :)
07:04:54 <HugoDaniel> a is a type variable
07:05:34 <HugoDaniel> you can have as many Bar's, as you want...
07:05:52 <bastl> Can I do something against overlapping instances? I want a specific Show instance for a pair of types.
07:06:13 <HugoDaniel> bastl: yes
07:06:24 <bastl> hmm. that feels like OO multiple inheritance ....
07:06:30 <bastl> Hugo: what?
07:06:36 <HugoDaniel> if you have overlapping instances in haskell then you probably need to redefine your types in a better way
07:06:41 <bastl> hehe
07:06:50 <EvanR-work> osaunders: removing type signatures from top level stuff means hard to read
07:06:55 <HugoDaniel> but you can always abuse pattern matching, and see if it works for you
07:07:26 <HugoDaniel> bastl: use a case in your show
07:08:02 <HugoDaniel> sya
07:08:33 <HugoDaniel> instance Show MyStuff where show foo = case foo of ....
07:10:00 <bastl> no, that wont work in my case. I think I may not redifine Show (a,b) because it is already defined, and the compiler would not know which instance to choose ...
07:10:14 <HugoDaniel> then
07:10:29 <bastl> i stick to the standard :-)
07:10:30 <HugoDaniel> define a data type for your pair
07:10:59 <bastl> Hugo: right, that would be the cleanest way. But I want to hide my quick and dirty thingies *gg*
07:11:24 <HugoDaniel> try: type MyStuff = (a,b)
07:11:33 <bastl> hmm
07:12:57 <bastl> doesnt solve the conceptual problem
07:13:07 <bastl> this is multiple inheritance in OO-Speak.
07:15:23 <HugoDaniel> i dont understand your point, you can get away with a type synonym...
07:21:12 <CodeOfSilence> goto http://tinyurl.com/348ajfj for teh win. DO IT!
07:25:01 <nostard> hi, are there some discussions of cabal vs apt-get? Which is preferred?
07:26:26 <sipa> apt-get only gives you haskell modules that are (pre)packaged for your distribution
07:27:05 <nostard> sipa: yes, but when they are in both?
07:28:25 <dmbarbour> :t liftM
07:28:25 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:28:29 <dmbarbour> :t fmap
07:28:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:29:42 <dmbarbour> What is the critical difference between fmap and liftM?
07:29:49 <ddarius> The type.
07:29:55 <dmbarbour> IO
07:30:26 <dmbarbour> All monads are functors, right? ddarius
07:30:45 <ddarius> dmbarbour: That's what liftM proves.  But not all instances of Monad are instances of Functor.
07:31:29 <dmbarbour> Oh? I thought they were... it seems you're right.
07:32:24 <dmbarbour> So should liftM == fmap for instances of both Functor and Monad?
07:33:23 <dmbarbour> nm. Thanks ddarius.
07:33:52 <lorrden> why is a and b in the following expression inferred to be of different types?
07:34:02 <lorrden> test = do
07:34:02 <lorrden>      a <- [1]
07:34:02 <lorrden>      b <- [2]
07:34:03 <lorrden>      return a ++ b
07:34:42 <Lemmih> lorrden: try: return (a+b)
07:35:09 <Lemmih> lorrden: What you've written means: (return a) ++ b
07:35:37 <lorrden> right, but a is a list
07:35:46 <lorrden> b is infered to be an integer
07:36:07 <Lemmih> lorrden: No, both 'a' and 'b' are numbers.
07:36:55 <lorrden> right...
07:36:57 <Lemmih> > [ a + b | a <- [1], b <- [1] ]
07:36:58 <lambdabot>   [2]
07:37:51 <dstcruz> gug
07:38:16 <lorrden> so, i cannot use <- for lists
07:38:33 <Lemmih> lorrden: Sure you can. I just did.
07:38:58 <Lemmih> > do a <- [1]; b <- [2]; return (a+b)
07:38:59 <lambdabot>   [3]
07:39:45 <Lemmih> lorrden: (<-) may not mean what you think it does.
07:40:38 <lorrden> yeah, I got that
07:40:47 <lorrden> my haskell is incredibly rusty
07:43:25 <nostard> lorrden: maybe you meant "let a = [1]"
07:43:33 <sipa> > [ a + b + c + d | a <- [0,1], b <- [0,2], c <- [0,4], d < [0,8] ]
07:43:34 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
07:43:34 <lambdabot>         against inferred ...
07:43:39 <sipa> > [ a + b + c + d | a <- [0,1], b <- [0,2], c <- [0,4], d <- [0,8] ]
07:43:40 <lambdabot>   [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]
07:43:44 <sipa> > sort [ a + b + c + d | a <- [0,1], b <- [0,2], c <- [0,4], d <- [0,8] ]
07:43:45 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
07:44:54 <diPython> :t (<-)
07:44:55 <lambdabot> parse error on input `<-'
07:45:29 <sipa> it is synactic sugar
07:45:41 <nostard> oups, i broke my installation when i removec ~/.cabal how do i fix it? ^^
07:46:09 <diPython> sipa syntatic sugar to what?
07:46:17 <sipa> diPython: do { a <- b; c } is identical to b >>= \a -> c
07:46:42 <Lemmih> nostard: cabal update?
07:47:34 <Lemmih> nostard: Oh, you deleted the cabal binary. Ah.
07:47:48 <diPython> :t (>>=)
07:47:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:47:57 <nostard> Lemmih: hmm, that's installed via the distribution
07:48:27 <Lemmih> nostard: Oh, then you just reinstall whatever libraries you need.
07:50:26 <diPython> > [2] >>= \x -> x+1
07:50:27 <lambdabot>   No instance for (GHC.Num.Num [b])
07:50:27 <lambdabot>    arising from a use of `e_121' at <inte...
07:50:42 <Lemmih> > [2] >>= \x -> [x+1]
07:50:42 <lambdabot>   [3]
07:51:04 <diPython> yeah
07:51:04 <Lemmih> > do x <- [2]; [x+1]
07:51:05 <lambdabot>   [3]
07:51:16 <diPython> nice
07:51:34 <Lemmih> ?undo do x <- [2]; [x+1]
07:51:34 <lambdabot> [2] >>= \ x -> [x + 1]
07:51:53 <Lemmih> ?redo [2] >>= \x -> [x+1]
07:51:53 <lambdabot> Maybe you meant: do read todo undo
07:52:21 <Lemmih> Didn't we have a redo, once?
07:52:40 <ddarius> What would it do?
07:52:53 <ddarius> Perhaps you are thinking of @do?
07:52:54 <Lemmih> ddarius: The reverse of undo.
07:53:01 <sipa> > do x <- [2,3,5]; [x*x,x+1[
07:53:02 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:53:05 <sipa> > do x <- [2,3,5]; [x*x,x+1]
07:53:05 <Lemmih> ?do [2] >>= \x -> [x+1]
07:53:06 <lambdabot>   [4,3,9,4,25,6]
07:53:06 <lambdabot> do { x <- [2]; [x + 1]}
07:53:42 <diPython> why those names? (undo and do)
07:53:51 <sipa> do is haskell syntax
07:54:02 <sipa> undo undoes the syntactic sugar of the do construct
07:54:12 <sipa> (in lambdabot)
07:54:30 <ddarius> @undo do Just x <- m; return x
07:54:30 <lambdabot> m >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
07:54:46 <diPython> i see
07:54:56 <sipa> @pointfree [2] >>= \x -> [x+1]
07:54:56 <lambdabot> Unknown command, try @list
07:55:03 <sipa> @pl [2] >>= \x -> [x+1]
07:55:03 <lambdabot> [3]
07:55:14 <sipa> @pl (>>= \x -> [x+1])
07:55:14 <lambdabot> ((1 +) `fmap`)
07:55:16 <nostard> Lemmih: i couldn't because ghc-package complained that the packages i had installed with cabal were broken. I tried ghc-pkg unregister for all those packages. Now it seems to work =). Thanks
07:57:13 <diPython> :t (>>=)
07:57:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:57:20 <diPython> :t (>>=) [4]
07:57:21 <lambdabot> forall t b. (Num t) => (t -> [b]) -> [b]
07:58:41 <diPython> any command to show the instance Monad for lists?
07:59:08 <Lemmih> ?src [] (>>=)
07:59:08 <lambdabot> xs >>= f     = concatMap f xs
07:59:12 <Lemmih> ?src [] return
07:59:12 <lambdabot> return x    = [x]
08:00:35 <diPython> tks
08:01:05 <sipa> ?
08:05:20 <diPython> :t floatRadix
08:05:21 <lambdabot> forall a. (RealFloat a) => a -> Integer
08:06:25 <diPython> :t tan
08:06:26 <lambdabot> forall a. (Floating a) => a -> a
08:07:01 <diPython> ?src tan
08:07:01 <lambdabot> Source not found. My mind is going. I can feel it.
08:10:17 <diPython> which sin function is used by ghc? 
08:10:20 <dstcruz> :k (Either a)
08:10:21 <lambdabot> Not in scope: type variable `a'
08:12:07 <Ktstzo> <diPython>: mmmm it depends on the time of the day, the sin commited may vary
08:12:31 <diPython> how can i see it?
08:13:15 <ddarius> There isn't a single sin function.  It's a member of the Floating class.  At any rate, for Double/Float it will be the hardware fsin (or equivalent).
08:13:18 <Ktstzo> </Sarcasm>
08:15:30 <sipa> :t sin
08:15:31 <lambdabot> forall a. (Floating a) => a -> a
08:15:48 <diPython> Ktstzo :(
08:16:24 <mux> mmm, the EventM monad for events (ReaderT + IO) in gtk2hs is a neat idea
08:16:27 * hackagebot yesod 0.5.4.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.5.4.1 (MichaelSnoyman)
08:19:04 <Unforgivable> Hello everyone :w
08:19:45 <Unforgivable> im currently checking out some new stuff and I'm having a hard time understanding what it means
08:19:51 <Unforgivable> this type is defined:
08:19:52 <Unforgivable> type Parse a b = [a] -> [(b,[a])]
08:20:07 <Unforgivable> and a function to the latter
08:20:09 <Lemmih> Unforgivable: Keep in mind that it is only a type synonym.
08:20:12 <Unforgivable> succeed :: b -> Parse a b 
08:20:13 <Unforgivable> succeed val inp = [(val,inp)]
08:20:24 <Unforgivable> I have no idea where inp is coming from
08:20:42 <Unforgivable> nor how that type definition works
08:20:47 <Lemmih> Unforgivable: succeed :: b -> [a] -> [(b,[a])]
08:21:10 <Lemmih> Unforgivable: When you see 'Parse a b', replace with '[a] -> [(b,[a])]'.
08:21:20 <Unforgivable> aha
08:21:24 <Unforgivable> that makes sense indeed :)
08:22:15 <Unforgivable> but the type definition
08:22:49 <Lemmih> Yes?
08:22:57 <Unforgivable> its just some wrapper for the part its used for? 
08:23:32 <Unforgivable> there is also this function: 
08:23:32 <Unforgivable> token :: Eq a => a -> Parse a a
08:23:45 <Unforgivable> Equality type a, returning Parse a a
08:23:48 <Unforgivable> whats the output in that case
08:23:49 <Lemmih> Unforgivable: I don't understand your question.
08:23:59 <Unforgivable> is it Eq a => a -> [a] -> [a]
08:24:00 <Unforgivable> ?
08:24:12 <Unforgivable> well Lemmih , how does that type definition works
08:24:15 <Unforgivable> with the a b
08:24:18 <quicksilver> a -> [a] -> [(a,[a])]
08:24:30 <quicksilver> Eq a => a -> [a] -> [(a,[a])]
08:24:33 <Lemmih> No, token :: Eq a => a -> [a] -> [(a,[a])]
08:25:57 <Unforgivable> I see, so when i get this straight, you have a type definition with name Parse and variables a + b. It's completed to [a] -> [(b,[a])], so when you have Parse a a, its [a] -> [(a, [a])] and for Parse b b its [b] -> [(b, [b])] 
08:26:14 <Unforgivable> just like a normal function definition
08:26:17 <Lemmih> Unforgivable: Exactly.
08:26:29 <Unforgivable> I see
08:26:42 <Unforgivable> i read it in the book I got here but I couldnt find any explaination what it was
08:26:55 <Unforgivable> so it was rather confusing :p
08:27:29 <Unforgivable> much appreciated Lemmih and quicksilver :)
08:27:41 <Unforgivable> made the chapter from not understable at all to understable :p
08:28:11 <Lemmih> Unforgivable: What book are you reading?
08:28:34 <Unforgivable> The craft of Functional Programming from Thompson
08:28:41 <Unforgivable> thats where the formulas are also from
08:28:44 <Unforgivable> :)
08:28:53 <edlinde> hi guys, I have just done a course in ML so understand some basic FP ... am wondering what the best way to make a transition to Haskell is? Are there any good books or tutorials you guys recommend? Something that has more problem solving and theory ?
08:30:11 <edlinde> Unforgivable: is that book you just mentioned a good one?
08:30:12 <osaunders> Why is this a type error? eqs = [1, 'd'] :: Eq a => [a]
08:30:28 <Unforgivable^> taking over here :p
08:30:34 <Unforgivable^> well the book seems fine
08:30:54 <Unforgivable^> but sometimes it misses some explainations, or I didnt found it :)
08:30:57 <edlinde> Unforgivable^: what does it cover?
08:30:58 <Lemmih> osaunders: Because lists are heterogeneous.
08:31:04 <edlinde> ok
08:31:15 <edlinde> but is it more a cook book approach to Haskell?
08:31:18 <Unforgivable^> from standard functions to algebraic and solving a lot
08:31:27 <Unforgivable^> it covers a lot really
08:31:31 <edlinde> ok
08:31:45 <edlinde> are there any better books that most haskell programmers refer to?
08:31:51 <Lemmih> osaunders: The way you've written it, the type variable 'a' would have to be a number and a character at the same time.
08:31:55 <edlinde> a more definitive guide kind of book?
08:32:00 <Unforgivable^> the book is pretty old though
08:32:01 <edlinde> or is this the book? 
08:32:03 <Unforgivable^> 1999 or something
08:32:16 <Unforgivable^> but its recommended on a lot of sites so i bought it
08:32:21 <quicksilver> actually I think Lemmih is wrong.
08:32:45 <edlinde> http://www.amazon.com/Haskell-Craft-Functional-Programming-2nd/dp/0201342758/ref=sr_1_1?ie=UTF8&s=books&qid=1287415917&sr=8-1
08:32:48 <quicksilver> [1,'d'] :: Eq a => [a] is wrong because "Eq a => [a]" requires elements to be polymorphically of any (all) Eq types
08:32:48 <edlinde> thats the one yeah?
08:32:56 <Lemmih> I probably am. Listen to quicksilver instead of me, osaunders. (:
08:33:10 <quicksilver> that's not possible in any interesting way because you can't write any elements polymorphic in Eq.
08:33:16 <quicksilver> compare : [1,2,3] :: Num a => [a]
08:33:34 <quicksilver> which is possible because numeric literals are, indeed, polymorphic in Num.
08:33:35 <stepkut> edlinde: some people like http://learnyouahaskell.com/, other people like http://www.realworldhaskell.org/blog/
08:33:41 <Unforgivable^> <edlinde> thats the one yeah?
08:33:47 <Unforgivable^> yes
08:34:05 <edlinde> stepkut: k will check them out too
08:34:07 <stepkut> edlinde: but those are not especially theory oriented.. per se
08:34:22 <edlinde> I noticed the book had no section on Monads
08:34:23 <edlinde> ?
08:34:26 <osaunders> Lemmih: quicksilver: Hm.
08:34:42 <osaunders> Yes, you have reminded me that a type variable can only represent one type.
08:34:50 <edlinde> I have just heard about Monads in Haskell... but didn't find them there
08:35:25 <osaunders> But even eqs = ['a'] :: Eq a => [a] is illegal because 'a' isn't polymorphic, you are saying quicksilver?
08:35:42 <quicksilver> yes.
08:35:54 <quicksilver> > let eqs = ['a'] :: Eq a => [a] in eqs
08:35:55 <lambdabot>   Couldn't match expected type `a'
08:35:55 <lambdabot>         against inferred type `GHC.Types.C...
08:36:03 <edlinde> stepkut: have you read that Real World Haskell book ?
08:36:11 <edlinde> or is that book available for free?
08:36:17 <Unforgivable^> edlinde> I noticed the book had no section on Monads
08:36:17 <Unforgivable^> <edlinde> ?
08:36:22 <Unforgivable^> there is Monads in it
08:36:30 <edlinde> lemme double check :)
08:36:41 <Unforgivable^> at least i came across it, havent read it though
08:36:43 <edlinde> found the free version --> http://book.realworldhaskell.org/read/
08:37:03 <edlinde> Chap 18?
08:37:14 <edlinde> Unforgivable^: Pg 401?
08:37:32 <stepkut> edlinde: I have not read any books. The craft of functional programming doesn't talk about IO or monads until chapter 18 I think.. that is one reason that 'real world haskell' was written I believe :)
08:37:36 <osaunders> edlinde: You can probably scan bits of Learn You a Haskell where he goes through some of the Haskell standard libraries. See the chapter that introduces types and the one on modules, for instance.
08:37:51 <osaunders> 4 and 9, I think.
08:38:03 <edlinde> ah cool
08:38:07 <edlinde> ok sounds good
08:38:20 <edlinde> maybe then I don't need to buy the craft book :)
08:38:36 <osaunders> The one on modules spends most of its time talking about what's in some of the standard modules. Only the very beginning described the semantics of modules in general.
08:38:48 <osaunders> *describes
08:40:05 <edlinde> osaunders: and if I then wanted to practise using Haskell, is there a blog or site with problems and solutions?
08:41:00 <edlinde> Its just that with SML I noticed that there weren't enough problems outside of the textbooks
08:41:02 <stepkut> edlinde: perhaps this one? http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
08:41:22 <edlinde> awesome
08:41:23 <edlinde> thanks
08:42:01 <osaunders> edlinde: Yeah stepkut's link is good.
08:42:11 <edlinde> yeah looks nice
08:42:13 <stepkut> edlinde: a lot of people like to do project euler with Haskell, http://projecteuler.net/, but you have to come up with your own solutions
08:42:29 <quicksilver> I think project euler is a bad answer
08:42:40 <osaunders> quicksilver: I agree.
08:42:41 <quicksilver> ...unless you are rather interested in mathematics. (mainly number theory)
08:42:42 <edlinde> I think I will start to look at Learn Yourself Haskell
08:42:51 <edlinde> yeah quicksilver i agree
08:42:56 <quicksilver> project euler is actually a bunch of maths problems, which you solve using a computer.
08:43:07 <edlinde> I have seen those questions and I thought its more about math problems like finding primes, etc
08:43:09 <quicksilver> they're not a bad way to learn some basic number theory ;)
08:43:13 <osaunders> The first few are OK but only because they aren't mathematically too challenging.
08:43:24 <ddarius> quicksilver: From what I can tell, most of them are boring, uninteresting math problems.
08:43:33 <stepkut> well, it is called project euler ;)
08:43:33 <zygoloid> depending on how far through you get, it's not necessarily even /basic/ number theory :)
08:43:34 <edlinde> yeah I am looking more along the lines of manipulating lists
08:43:40 <edlinde> using datatypes in Haskell
08:43:51 <osaunders> edlinde: The Haskell Wikibook also has a bunch of exercises.
08:43:56 <edlinde> see how similar to ML it is and how much of my knowledge I can transfer
08:43:56 <quicksilver> ddarius: well that depends a bit how much maths you already know :) But yes, I find them boring. I've never liked number theory either.
08:44:01 <osaunders> ...at the end of each chapter.
08:44:09 <quicksilver> the 99 problems link is quite good for lists + some simple data structures.
08:44:13 <zygoloid> some of them are definitely above CATAM level
08:44:19 <quicksilver> there are exercises in RWH as well, I don't remember how good they are.
08:44:27 <quicksilver> s/remember/know/
08:45:28 <osaunders> edlinde: But if you need more or have specific requirements (exercise wise), nudge me; I'm supposed to be adding exercises to the Haskell wikibook.
08:45:50 <osaunders> Having someone else actually care about me doing that would encourage me to actually do it.
08:45:51 <Jafet> The specific problem with doing euler in Haskell is that you do the first fifty, and they seem all so easy and trivial, then you go on to write real stuff and you find out you have no clue how to use monad transformers, or Foreign, or concurrency
08:47:10 <edlinde> osaunders: cheers
08:56:33 <osaunders> What's a standalone deriving declaration?
08:56:58 <ClaudiusMaximus> deriving instance Eq SomeTypeDefinedElsewhere
08:57:14 <quicksilver> osaunders: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/deriving.html#stand-alone-deriving
09:03:03 <alpounet> how should I do to clean all my cabal stuffs, also registered in ghc's pkg database ? I mean I want it to be as if I just installed ghc and cabal
09:05:19 <quicksilver> alpounet: there is no easy way to distinguish between packages which were installed with GHC and global packages which you have installed more recently.
09:05:23 <dmwit> alpounet: First delete them, then unregister them.
09:05:28 <quicksilver> alpounet: ghc-pkg list will give you a clue as to where things live.
09:05:54 <quicksilver> you could completely blow away your user-installed stuff though, which all lives in .cabal
09:07:32 <alpounet> i don't care about them
09:07:41 <alpounet> I actually want a clean install
09:07:54 <alpounet> so I do want to remove them
09:08:28 <quicksilver> you want to remove GHC as well?
09:08:32 <alpounet> nope
09:08:33 <quicksilver> that's not what you said.
09:08:39 <quicksilver> OK then my point applies.
09:08:45 <quicksilver> alpounet: there is no easy way to distinguish between packages which were installed with GHC and global packages which you have installed more recently.
09:08:56 <quicksilver> so it's not trivial to work out which packages to keep and which to remove.
09:08:57 <alpounet> hm
09:09:06 <quicksilver> you can't blow everything away as you will lose the packages GHC requires to function.
09:09:21 <EvanR-work> if you never installed anything globally just delete your .cabal stuff
09:09:24 <quicksilver> right.
09:09:50 * hackagebot xss-sanitize 0.2.2 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.2.2 (GregWeber)
09:12:50 <alpounet> hmm
09:12:59 <alpounet> it may be a good idea to reinstall ghc anywayu
09:13:01 <alpounet> -u
09:13:20 <quicksilver> if you want to start afresh, I'd consider a haskell platform install
09:13:28 <quicksilver> bunch of known-good libraries in compatible versions
09:14:36 <alpounet> yeah
09:15:17 <ski> osaunders : it appears you wanted `[exists a. Eq a *> a]' ?
09:18:52 --- mode: Saizan set -o Saizan
09:20:41 <alpounet> thanks
09:24:23 <EnglishGent^afki> very quick question - what's the file extension for the literate programming style of haskell file? the one where most lines are comments unless you say otherwise
09:24:24 <EnglishGent^afki> ?
09:24:32 <monochrom> lhs
09:24:35 <EnglishGent^afki> thanks :)
09:29:57 <dstcruz> set away_devoice false
09:30:09 <dstcruz> darn, sorry, wrong window
09:35:18 <Saizan> alpounet, quicksilver: to remove the user installed packages you have to remove ~/.ghc
09:40:57 <Nopik> the more i learn about haskell, the more i like it ;) i'm now in a middle of 'real world haskell' book, and it rocks as well.. finally i understood many things about monads which i was wondering about for long time ;p
09:41:57 <EnglishGent^afki> hi Nopik :)
09:42:15 <Twey> Nopik: There aren't a whole lot of things to understand about monads.
09:42:23 <EnglishGent^afki> hmmm - could someone help me here - I'm looking for a definition of 'type level programming'
09:42:46 <Twey> EnglishGent^afki: Coding in the type system, where unifying the types is the same thing as evaluating the program.
09:42:54 <EnglishGent^afki> I'm trying to explain what it is to a friend - and it occurs to me that I can give examples of it
09:43:05 <EnglishGent^afki> but not really describe what it is *in general*
09:43:20 <EnglishGent^afki> hi Twey :)
09:43:32 <EnglishGent^afki> yes - but that doesnt really work as a definition - it doesnt explain *why*
09:43:56 <quicksilver> EnglishGent^afki: to do computation at compile time instead of run time?
09:44:18 <EnglishGent^afki> well that's also true ... but a regular macro system does *that*
09:44:23 <quicksilver> yup.
09:44:27 <quicksilver> it's a safe macro system
09:44:28 <monochrom> type level programming is like vcr programming
09:44:29 <EnglishGent^afki> and yet using Lisp macros doesnt feel like type-level programming
09:44:31 <quicksilver> FSVO safe
09:44:40 <EnglishGent^afki> FSVO?
09:44:49 <quicksilver> well the goal is, in particular, to calculate the *types* of your final program
09:45:04 <quicksilver> so that your final program will have the "better" (more precise) static guarantees
09:45:07 <quicksilver> "For Some Values Of"
09:45:08 <Jafet> Loading a program into your compiler to tell it how to type-check your code.
09:45:16 <quicksilver> yes, what Jafet said.
09:45:26 <Jafet> Man, that sounds even stranger than hacking VCRs.
09:45:43 <quicksilver> Jafet: don't forget to rewind your type-level programs before you press Play.
09:49:23 <Nopik> twey: yeah, like 2 years ago i had few days where i tried to learn about monads etc., read tons of manuals but did not grasped the idea.. which left me puzzled for long time ;) now i made second approach and things are much clearer now, thanks to good explaination in RWH
09:51:22 <EnglishGent^afki> well to me the whole point of type level programming is to express stronger invariants than I could otherwise express
09:51:36 <EnglishGent^afki> e.g. number indexed types, strongly typed hetrogenous lists, etc
09:52:10 * EnglishGent^afki thinks of papers where type level programming has been used as a solution somehow - the CoddFish library would be another
09:53:48 <ucasano> which is the best editor to write haskell programs?
09:53:59 <ucasano> somebody using acme?
09:54:04 <gwern> I doubt it
09:54:09 <gwern> does ghc even work on plan 9?
09:57:05 <aristid> gwern: probably not. eh?
09:57:20 <gwern> I mean, it is a unix, in a sense...
09:57:37 <aristid> ucasano: many people use emacs. but just use your favorite editor
09:59:44 <EnglishGent^afki> hey - does anyone know if there's a way of persuading emacs haskell mode to work with mmi - so that comments can be in a different mode? (say org-mode)
10:00:01 * EnglishGent^afki thinks that would be really neat as a haskell editor :)
10:12:03 <ucasano> I would like to use sam/ed/acme
10:12:16 <ucasano> but I saw indentation is of importance
10:14:20 <Saizan> if you set your editor to convert tabs to spaces there should be no problem
10:22:54 <Blkt> good evening everyone
10:25:11 * hackagebot formlets-hsp 2.3.1 - HSP support for Formlets  http://hackage.haskell.org/package/formlets-hsp-2.3.1 (JeremyShaw)
10:29:28 <Eduard_Munteanu> Hi.
10:29:57 <theom3ga> hi
10:30:46 <theom3ga> how can I write a function that displays something and then returns false? I've managed to write something, but I don't know how to return
10:31:28 <Eduard_Munteanu> Does anyone know a zipper structure that fits nicely with 2D grids? I already had a look at sigfpe's implementation of cellular automata but I don't really like the 1D x 1D representation, seems contrived to work with.
10:31:35 <roconnor> > putStrLn "Something" >> return false
10:31:36 <lambdabot>   Not in scope: `false'
10:31:40 <roconnor> > putStrLn "Something" >> return False
10:31:41 <lambdabot>   <IO Bool>
10:32:09 <roconnor> > do { putStrLn "Something"; return False}
10:32:10 <lambdabot>   <IO Bool>
10:32:28 <conal> Eduard_Munteanu: if you start with a nice 2d grid type, you can derive the corresponding zipper
10:33:37 <Eduard_Munteanu> conal: ah, you're suggesting using some zipper library to take the derivative of some (homegrown) 2D grid?
10:34:38 <Eduard_Munteanu> I'd really like to but I'm not sure how that would work, e.g. using diffarrays or something like that.
10:35:12 <conal> Eduard_Munteanu: either a generic zipper library, or use a systematic technique manually.  either way, you have a solid & elegant theory for the zipper aspect, and you've simplified the creative question.
10:35:14 <theom3ga> If my function "myFun" doest not have any parameters and returns a bool, what's its signature? myFun :: -> Bool does not work
10:35:21 <conal> Eduard_Munteanu: and there are some elegant ways to think of & formulate 2D grids
10:35:57 <roconnor> theom3ga: depends on what monad you are in
10:36:13 <theom3ga> I don't know what monads are, roconnor 
10:36:15 <roconnor> for IO it would be myFun :: IO Bool
10:37:02 <jmcarthur> theom3ga: do you mean that it's a value and not a function?
10:37:02 <conal> theom3ga: if your function doesn't have parameters, it's not a function.
10:37:18 <Eduard_Munteanu> conal: I see, thanks. I've been flirting with the idea of somehow making a coordinate transformation of the 2D grid into 1D and using a zipper on that, but I'm not sure how well that works for an automata.
10:37:21 <roconnor> theom3ga: Perhaps you should paste your source
10:37:34 <theom3ga> roconnor, never mind, I managed to fix it somehow
10:37:59 <roconnor> ok
10:38:08 <conal> Eduard_Munteanu: ah yeah.  clever, but probably not the most natural/elegant approach.
10:39:57 <conal> theom3ga: did you try myFun :: Bool ?  (or better, myBool :: Bool)
10:40:16 <theom3ga> myFun :: Bool seems to work
10:40:35 <roconnor> theom3ga: there are only two possible implemenations of that function
10:40:39 <roconnor> (three for the pendantic)
10:40:42 <conal> theom3ga: cool.  and check out http://conal.net/blog/posts/everything-is-a-function-in-haskell/
10:40:43 <kwuxalot> the documentation for Data.TCache is not very complete
10:40:51 <roconnor> "function"
10:41:03 * Eduard_Munteanu thinks a tree could fit this, i.e. children are neighbour cells (north, northwest etc.) of the parent node; but I'm still thinking it through.
10:41:11 <dmwit> roconnor: Nevertheless, it can make sense to name one of the three implementations.
10:41:21 <roconnor> yes
10:41:24 <roconnor> @src otherwise
10:41:24 <lambdabot> otherwise = True
10:41:28 <dmwit> e.g. verbose = False -- seems reasonable
10:42:11 <monochrom> the_3rd = unsafePerformIO (readLn :: Bool) :)
10:42:19 * hackagebot queue 0.1.2 - Abstraction typeclasses for queue-like things.  http://hackage.haskell.org/package/queue-0.1.2 (JamesCook)
10:42:21 <dmwit> ack
10:43:20 * hackagebot priority-queue 0.2.1 - Simple implementation of a priority queue.  http://hackage.haskell.org/package/priority-queue-0.2.1 (JamesCook)
10:43:39 <jmcarthur> conal: i love how that url slug seems to say one thing but your actual headline puts the phrase into quotes to imply that you are actually questioning it and not arguing for it
10:44:04 <monochrom> heh url slug
10:44:21 <conal> jmcarthur: :)  i like that bit also.
10:44:35 <conal> jmcarthur: i have a few other titles in mind like that one
10:44:38 <jmcarthur> monochrom: http://codex.wordpress.org/Glossary#Slug
10:45:02 <Eduard_Munteanu> Hm, rosezipper looks interesting.
10:45:39 <theom3ga> wtf
10:45:39 <theom3ga> http://hpaste.org/40677/wat?pid=40677&lang_40677=Haskell
10:46:06 <dmwit> theom3ga: print :: Bool is a lie
10:46:13 <dmwit> theom3ga: print :: IO Bool is the truth
10:46:44 <conal> :t print
10:46:45 <lambdabot> forall a. (Show a) => a -> IO ()
10:46:50 <jmcarthur> theom3ga: are you aware of how haskell is a "pure" language?
10:46:55 <roconnor> theom3ga: you are trying to short-circut the print statment
10:47:10 <roconnor> theom3ga: but Haskell won't allow you to write your code in such a way
10:47:16 <dmwit> theom3ga: Also, you are probably getting surprised by the fact that you're redefining "print" within the definition of "print".
10:47:29 <theom3ga> Looks llike I'm still thinkin in C++
10:47:55 <kwuxalot> I just found the ACME category in hackage ;)
10:48:11 <Eduard_Munteanu> theom3ga: read up on how to handle error conditions and failures in Haskell code, it's better than emulating C++ habits.
10:48:24 <Eduard_Munteanu> kwuxalot: heh, that's fun.
10:48:25 <dmwit> theom3ga: compare this strange looking function: (foo = do { foo "uh, what?"; return False })
10:48:27 <jmcarthur> theom3ga: myFun :: Bool means that myFun should be a pure value. it can't have side-effects with that type
10:48:32 <c_wraith> kwuxalot, ACME Now is my favorite. :)
10:49:01 <theom3ga> that window by me is saying "jump through me"
10:49:02 <kwuxalot> I wonder if there are any packages that depend on "empty"
10:49:27 <roconnor> kwuxalot: all packages should depend on empty :D
10:49:27 <dmwit> theom3ga: Here, let me give you an example of some code that *would* work.
10:49:48 <jmcarthur> (my use of the word "pure" is redundant. i just used it to provide some intuition.)
10:50:29 <roconnor> theom3ga: you can't jump through the window without using the IO monad
10:50:44 <theom3ga> roconnor, o_O omg 
10:50:59 <Eduard_Munteanu> :)) side effects are indeed nasty
10:51:08 <jmcarthur> actually, you just can't ever jump through the window
10:51:11 <jmcarthur> only the runtime can
10:51:15 <theom3ga> I'd better get back to my safe std namespace
10:51:18 <stepkut> c_wraith: so, sleeping paid off! When I woke up this morning, I noticed that, instance Lift Name, was defined in that module I pasted :) Though I wonder if it is a bad idea -- since most of the time you get that Lift Name error because your code is broken -- not because you really need it..
10:51:26 <dmwit> theom3ga: http://hpaste.org/paste/40677/dont_hide_the_fact_that_your#p40678
10:51:38 <stepkut> c_wraith: but an explicit liftName function could work around that
10:51:48 <c_wraith> stepkut, ah, that's a good point.  That is generally a mistake, not what you mean to do.
10:52:14 <c_wraith> stepkut, though I'm not sure it's such a big deal.  Because if it is a mistake, the compiler will still catch it, just on a later stage
10:52:36 <stepkut> c_wraith: right. I am not clear when is the less confusing stage though. TH is confusing enough already
10:53:16 <stepkut> at least I find it confusing, because I only try to write it once a year, so I forget anything I knew
10:54:22 <dmwit> theom3ga: Still with us? You've got to keep asking questions if you're not sure what's going on. =)
10:55:11 <osaunders> ski: Haskell wikibook says the exists keyword doesn't exist in Haskell: "This 'exists' keyword (which isn't present in Haskell) is, as you may guess, a union of types[...]"
10:55:39 <dmwit> osaunders: Yeah, we use "forall" in a strange way, instead.
10:55:57 <dmwit> The GHC folks are real big on keeping the number of keywords to a minimum.
10:56:46 <dmwit> newtype Existential = Existential (forall a. a) is approximately what you would expect from "exists a. a".
10:57:23 <osaunders> Way to confuse everybody (read: me).
10:57:27 <roconnor> osaunders: existential are actually data types which can be declared like dmwit illustrates
10:57:33 <monochrom> did not confuse me
10:58:17 <Eduard_Munteanu> Well is it really an existential quantifier? At least in rank-2 types inner foralls don't really look like it, even though they imply existential quantification at some other level.
10:58:20 <dolio> data Existential = forall a. Existential a
10:58:46 <dolio> That newtype is just a wrapped universal.
10:58:48 <roconnor> the type of the constructor for exists x. f x is MkExists ::forall x. (f x -> exists x. f x)
10:59:05 <dmwit> whoops
10:59:13 <roconnor> basically forall x. (f x -> foo) is the curried version of (exists x. f x) -> foo
10:59:29 <roconnor> so that is why we use forall to make exists
10:59:57 <dolio> I still think the syntax with non-GADT data is questionable.
11:00:22 <roconnor> indeed
11:01:35 <Eduard_Munteanu> Ah, that makes sense.
11:01:40 <dolio> Although it does make some sense.
11:02:26 <dolio> 'forall s. Exists s' means that for every s, there's a constructor Exists that takes an s parameter.
11:02:43 <dolio> But it's constantly confusing people who try to do the same thing with 'type'.
11:03:15 <roconnor> data Exists f = forall a. Witness (f a) -- perhaps a better illustration of Existentials
11:03:56 <osaunders> Should I just read forall as exists?
11:04:06 <dolio> No.
11:04:07 <c_wraith> No, because it doesn't always mean exists.
11:04:08 <roconnor> osaunders: very much not
11:04:23 <roconnor> arguably it never means exists
11:04:31 <monochrom> haskell is not english
11:04:40 <Eduard_Munteanu> Or the OOP-emulating usage of existentials without exporting the constructor.
11:05:06 <osaunders> So sometimes forall means exists?
11:05:41 <dolio> No.
11:05:49 <monochrom> sometimes you have to look at the whole parse tree
11:05:50 <osaunders> Is says in Haskell wikibook that forall is intersection of types and therefore a set of only bottom.
11:06:06 <Eduard_Munteanu> Some forall can be rewritten as exists, but in a different form.
11:06:10 <osaunders> I don't understand how that gives you the existential behavior.
11:07:03 <roconnor> basically forall x. (f x -> foo) is the curried version of (exists x. f x) -> foo
11:07:24 <sproingie> ezyang wrote a blog entry that explains that in detail
11:07:30 <roconnor> the type of the constructor for `exists x. f x' is MkExists ::forall x. (f x -> `exists x. f x')
11:07:47 <Eduard_Munteanu> osaunders: it becomes a bit clearer when you actually write some toy code that takes existential types.
11:08:00 <sproingie> it unfortunately lost me right at the point where he lifts the curtain, but someone else who understands CHI might grok it
11:08:08 <monochrom> heck, even in english, "stop to ask" and "stop asking" are opposite.
11:08:26 <monochrom> "so, does 'stop' mean do it or don't do it?"
11:08:31 <sproingie> monochrom: that's because you're using an ambiguous wording of "stop"
11:08:35 * FunctorSalad_ thought unsafeCoercing function types to and from () didn't work
11:08:41 <FunctorSalad_> but my example fails at failing
11:08:59 <c_wraith> I get a segfault of I do unsafeCoerce () ()
11:09:05 <c_wraith> *if
11:09:07 <osaunders> monochrom: Your first use of stop is telling the reader to stop something different from the second.
11:09:09 <sproingie> i.e. "stop [whatever else you're doing] to ask"
11:09:18 <FunctorSalad_> c_wraith: :o
11:09:21 <roconnor> FunctorSalad_: try turning on optimizations
11:09:38 <sproingie> english is fun
11:09:46 <monochrom> all your explanations of "stop" applies to "forall" too.
11:09:49 <FunctorSalad_> roconnor: tried both -O0 and -O2
11:10:00 <Eduard_Munteanu> I disagree, I wouldn't write my code in English :P
11:10:15 <roconnor> FunctorSalad_: I can send you code that should fail
11:10:40 <monochrom> "your first use of forall is telling the reader to forall something different from the second"
11:11:04 <monochrom> that is why one of them gives an existential type rather than a universal type
11:11:21 <FunctorSalad_> here is the code in question, inspired by the recent haskell-cafe discussion... http://hpaste.org/40679/unsafecoerce_fail_fail
11:11:48 <sproingie> does it fail to fail?
11:12:00 <FunctorSalad_> (I'm using String -> String as the state type there)
11:12:19 <FunctorSalad_> sproingie: yes. as opposed to failing *at* failing, which doesn't cancel :)
11:12:52 <sproingie> does the fail to fail result in success or does it fail worse?
11:13:37 <Acacio98> i can do projects in Haskell that i will do it in python, at more or less the same time?
11:13:52 <FunctorSalad_> sproingie: success, in this case
11:13:59 <Eduard_Munteanu> Acacio98: maybe, maybe not.
11:14:03 <roconnor> Acacio98: yes
11:14:15 <sproingie> nothing succeeds like success that shouldn't
11:14:28 * hackagebot plugins 1.5.1.4 - Dynamic linking for Haskell and C objects  http://hackage.haskell.org/package/plugins-1.5.1.4 (DonaldStewart)
11:14:46 <Acacio98> but haskell is not to mathy like scheme right?
11:14:59 <monochrom> scheme isn't mathy
11:15:04 <sproingie> APL is mathy
11:15:21 <monochrom> I use haskell faster than I use python
11:15:22 <sproingie> scheme has that number tower thing ... haskell is a little more practical there, but it has shades of it
11:15:55 <FunctorSalad_> we have a number tower too, but not one mathy people tend to like ;)
11:15:56 <Eduard_Munteanu> I suspect the difference is more visible when coming from C/C++ or that sort of languages in terms of productivity. Since it also depends on your level of expertise in Haskell, you might waste time churning out code or figuring out something you don't yet understand.
11:16:13 <Acacio98> monochrom: but the books are, like SICP, all about maths
11:16:13 <monochrom> haskell is more mathy than scheme
11:16:21 <FunctorSalad_> don't forget possibly less bug hunting thanks to static types
11:16:24 <sproingie> SICP isn't really about real world scheme
11:16:32 <monochrom> I can write a mathy book on C too
11:16:37 <sproingie> it just uses scheme for its very pedagogical curriculum
11:16:46 <conal> haskell is mostly mathy in the sense of being mostly "denotative", i.e. types have precise math meanings, and meanings of expressions are defined strictly compositionally.
11:17:03 <conal> with a small number of exceptions, including IO
11:17:06 * Eduard_Munteanu wishes monochrom would write a mathy book on Haskell, last time I checked those books weren't too mathy :)
11:17:20 <sproingie> a pure functional language is going to feel a lot more like a set of mathematical equations than an imperative one
11:17:29 <sproingie> so in that sense haskell can be very "mathy"
11:17:51 <FunctorSalad_> haskell is very 'mathy' with respect to the math branch that is mathematical logic
11:17:54 <monochrom> indeed, even the Report isn't mathy. in contrast look at the SML definition.
11:18:07 <sproingie> but you're not required to break everything down to highly rigorous abstractions
11:18:09 <FunctorSalad_> not particularly mathy with respect to, say, numerical analysis
11:18:36 <Eduard_Munteanu> Well, I mean RWH and all that don't really go into categorical details and such stuff.
11:18:54 <roconnor> conal: why is IO exceptional?
11:19:10 <monochrom> you can write a mathy book and a fluffy book for everything
11:19:10 <sproingie> you can go your entire haskell career without knowing what the curry-howard isomorphism is
11:19:10 <jmcarthur> in that it's not denotative
11:19:16 <tg_> roconnor: not denotational
11:19:26 <tg_> at least, not completely
11:19:33 <FunctorSalad_> undefined denotation, to put it differently
11:19:34 * tg_ tips his hat toward conal
11:19:37 <roconnor> tg_: well, it is still denotational IMO. though I do admit it is unclear what it denotes :D
11:19:40 <conal> tg_: :)
11:19:48 <conal> roconnor: hah
11:20:01 <Eduard_Munteanu> sproingie: sure, though not if you're looking for that sort of thing specifically.
11:20:03 <jmcarthur> roconnor: so you believe that IO does have a precise meaning? i kind of see it as more of a sin bin
11:20:15 <tg_> sin bin?
11:20:21 <tg_> that sounds like the thing that's passed around at church
11:20:23 <sproingie> where you throw all the naughty bits
11:20:24 <roconnor> jmcarthur: it is the free monad of FFI calls.
11:20:25 <jmcarthur> tg_: a place to put stuff that we can't fit in more nicely
11:20:29 <jmcarthur> roconnor: lol
11:20:32 <conal> tg_: simon peyton jones's term
11:20:36 <Eduard_Munteanu> I for one didn't find a Haskell book with a type/categorical-centric view point, though I'd really like to.
11:20:38 <roconnor> jmcarthur: what?
11:20:41 <Jafet> Repent, or you will be unsafed?
11:20:53 <sproingie> conal: is that in the "wearing the hair shirt" paper?
11:21:01 <conal> means IO is where we dump everything we don't understand
11:21:24 <FunctorSalad_> like the user's bizarre requests
11:21:28 <conal> sproingie: i think so.  i have a quote & ref on my blog somewhere.
11:21:38 <Eduard_Munteanu> So I'm delving into Awodey, TAPL etc. and coming up with stuff myself.
11:21:38 <FunctorSalad_> (phrase stolen from some other program ;))
11:21:39 <dbelange> tg_: More like the thing that's passed around during bukkake
11:21:54 <jmcarthur> tg_: i like what immediately came to your mind when i mentioned sin bin :P
11:22:03 <conal> ah.  here are some comments on "denotative" with a ref: http://conal.net/blog/posts/is-haskell-a-purely-functional-language/#comment-35882
11:22:04 <jmcarthur> i don't like dbelange's version :P
11:22:43 <conal> sproingie: or maybe the "awkward squad" paper
11:23:35 <sproingie> waiting for the next paper, "Wearing the Cilice"
11:24:05 <monochrom> wearing the awkward squad
11:24:18 <sproingie> bow wakka chikka
11:24:32 <roconnor> zygoloid suggested the free monad of IO be over FFI calls
11:24:40 <conal> given the essential purpose of IO as sin-bin, i'm very doubtful that there could be any useful denotational model of IO.
11:24:50 <roconnor> I think it quite good
11:25:05 <jmcarthur> roconnor: that's interesting
11:25:15 <jmcarthur> roconnor: i'm not sure that it makes things much clearer though
11:25:26 <jmcarthur> because then you have to define an FFI call
11:25:40 <roconnor> jmcarthur: that is whatever the runtime does with it
11:25:48 <jmcarthur> roconnor: it also fails to model concurrency, doesn't it?
11:25:57 <jmcarthur> hmm
11:26:00 <jmcarthur> i guess not necessarily
11:26:05 <roconnor> jmcarthur: yes, concurrency is more or less missing IMHO
11:26:22 <roconnor> jmcarthur: I think it can be modeled, but the data type will need to be more sophisticated
11:26:27 <dolio> There are papers on concurrency monads that are essentially free monads.
11:27:35 <dolio> As I recall, at least.
11:28:08 <dolio> And a scheduler is written on top that decides how to interleave execution of the various trees.
11:29:37 <jmcarthur> IMO, IO *must* be nothing more than a sin bin. the goal isn't to define IO. it's to extract many simpler ideas from it
11:29:55 <roconnor> dolio: that's fair, but it would be nicer to capture the syncronization in the data structure
11:30:14 <monochrom> to proof your extraction correct, you still need a definition or equivalent
11:30:15 <Twey> Simpler, *transparent* ideas?
11:30:18 <roconnor> dolio: similarly I would want to model IORef directly in the IO type rather than having it be FFI calls
11:30:20 <monochrom> s/proof/prove/
11:30:51 <roconnor> thus making IO a Free FFI monad plus some state stuff (essentially all of ST)
11:31:08 <roconnor> plus magic concurenccy syncronization stuff
11:31:34 <jmcarthur> i think the flaw in my explanation was the word "extract"
11:31:39 <ddarius> Li Peng's concurrency system was cleverly done.
11:31:44 <jmcarthur> i think it should have been "inspire"
11:31:53 <conal> it's great to have a sin-bin while we're still figuring out how to program denotatively.
11:32:06 <conal> denotative programming is a work in progress.
11:32:17 <jmcarthur> i'm not sure that we will ever be completely free of the sin bin
11:32:25 <OscarZ> conal: whats that about? 
11:32:31 <roconnor> conal: if it makes you feel better, the free FFI monad is has about as little denotaiton as possible
11:32:47 <conal> roconnor: of course.  it's free
11:33:00 <conal> it's syntactic, not semantic
11:33:13 <conal> in other words, it's at the syntactic end of the syntactic/semantic spectrum
11:33:33 <conal> OscarZ: what's what about?
11:33:35 <jmcarthur> i like that characterization of free
11:33:52 <OscarZ> conal: i ment denotative programming 
11:34:07 <conal> OscarZ: http://conal.net/blog/posts/is-haskell-a-purely-functional-language/#comment-35882
11:34:18 <roconnor> conal: still it is a better model then "State RealWorld" nonsense
11:34:34 <jmcarthur> more correct, maybe
11:34:43 <jmcarthur> s/maybe/at least/
11:35:04 <conal> roconnor: yes, weak statements are better than false ones.
11:35:41 <conal> OscarZ: that link has a reference to Peter Landin's paper that proposes the term "denotative" as a replacement for "functional"
11:36:08 <monochrom> denotative is detonative
11:36:59 <conal> i like Landin's replacement, because i see so much confusion about what "functional" is.
11:38:08 <conal> and because i see the more specific/precise "denotative" as getting to the essence of what makes most of functional programming good for reasoning about programming
11:39:21 * monochrom practices axiomatic programming on all languages
11:43:08 <conal> a thought to try on: perhaps axiomatic programming is most at home in logic languages, while still quite useful in functional languages, and awkward in imperative.  and similarly, perhaps denotational is most at home in (purely) functional/denotative languages, though still useful for logic languages and awkward in imperative.
11:43:43 <conal> oh -- and operational thinking is perhaps most native to imperative languages.
11:43:52 <jmcarthur> i'm trying to figure out if there is a way to evaluate under lambdas in a HOAS interpreter without explicitly "unembedding" (creating a syntax tree and manipulating it statefully)
11:44:01 <conal> just food for thought.
11:44:19 <conal> jmcarthur: statefully?
11:44:38 <OscarZ> what is purely functional but not denotational programming? 
11:44:56 <jmcarthur> conal: e.g. explicit susbtitution in a de bruin representation
11:45:10 <jmcarthur> which carries a data structure from a previous state to a current state
11:45:25 <jmcarthur> *substitution
11:45:39 <conal> OscarZ: any type in the functional language/library that doesn't follow the denotational discipline.  for instance, IO in haskell.
11:45:58 <FunctorSalad_> isn't that the problem with HOAS? that you can't do *anything* with it except unembedding, as you say it? :)
11:46:03 <OscarZ> ok
11:46:22 <FunctorSalad_> since it's impossible to do anything else with lambdas in haskell
11:46:37 <FunctorSalad_> except possibly using the ghc api, don't know
11:46:38 * Jafet imagines a denotative IO...
11:46:45 <jmcarthur> FunctorSalad_: you can do quite a bit without creating a syntax tree...
11:47:39 <conal> Jafet: hurray.  that imagining is exactly what i've been trying to inspire.  there used to be a lot of creative thought about denotative IO.
11:47:46 <FunctorSalad_> jmcarthur: hmm, plugging anything into the function that represents the binder already creates a syntax tree, doesn't it?
11:47:56 <adnap> Why would I get: parse error on input `<-'
11:47:58 <Jafet> Sorry, I just felt mild terror.
11:48:15 <ezyang> conal: Do you think an approach that involves "classifying" the various types of IO to be fruitful? 
11:48:15 <lambdabot> ezyang: You have 1 new message. '/msg lambdabot @messages' to read it.
11:48:15 <adnap> That means it doesn't know what bind is?
11:48:20 <ezyang> /msg lambdabot @messages 
11:48:26 <ezyang> @messages 
11:48:26 <lambdabot> ManateeLazyCat said 1d 9h 6m 53s ago: I have re-read your "six part intro to c2hs", it's brilliant! Discuss many details, thank you! :) Here have single pdf version : https://docs.google.com/
11:48:26 <lambdabot> fileview?id=0B8kprmQ446Y9ZWM4ZjllMzAtNmIyYS00ZjVhLWJjOWMtZmZmYmRjMzUwNWM0&authkey=CPe3orIE&hl=zh_CN
11:48:29 <Jafet> adnap: because <- wasn't valid in the place where you used it
11:48:48 <Jafet> ezyand: we do have ST
11:48:59 <adnap> s <- socket AF_INET Datagram defaultProtocol
11:49:00 <Jafet> Which is like IO, but pure on some level
11:49:01 <conal> ezyang: do you mean carving out subsets of IO?  ie retrieving bits out of the sin bin?
11:49:25 <Jafet> s/yand/yang/ -- wot
11:49:39 <ezyang> conal: Yeah, essentially. 
11:49:46 <jmcarthur> FunctorSalad_: would you say that just using the metalanguage as a HOAS interpreter is creating a syntax tree?
11:49:56 <ezyang> conal: For example, as far as I can tell, we've had a bit of success talking about the semantics of concurrent constructs. 
11:50:22 <jmcarthur> FunctorSalad_: i'm just wondering if maybe you are thinking of "syntax tree" somewhat more abstractly than i am
11:50:42 <conal> ezyang: yes, definitely i'm in favor of pulling bits out of the sin bin.
11:50:42 <conal> m
11:50:42 <conal> ake
11:50:42 <conal> s 
11:50:42 <conal> u
11:50:42 <conal> 
11:50:49 <conal> oops.
11:50:50 <conal> makes much more sense to me than the idea of "finding a model for IO".
11:50:52 <jmcarthur> okay conal needs to get rid of colloquy
11:50:56 <jmcarthur> :P
11:51:06 <conal> jmcarthur: how'd you know?  it's driving me nuts!
11:51:07 <pumpkin> :O
11:51:07 <FunctorSalad_> jmcarthur: the picture I have in mind is something like: data Expr = ... | Lambda (Expr -> Expr)
11:51:25 <conal> does anyone have recommendations for a mac os x irc client?
11:51:27 <ddarius> Wie geht's, pumpkin?
11:51:42 <FunctorSalad_> jmcarthur: so since 'Expr' is an AST type, you can't to anything *but* create a syntax tree in that picture
11:51:46 <FunctorSalad_> *do
11:52:02 <jmcarthur> FunctorSalad_: okay, that's concrete. you can obscure it a bit by using a type class instead of an ADT
11:52:10 <pumpkin> ddarius: not too bad, still in florida
11:52:14 <pumpkin> ddarius: you?
11:52:16 <jmcarthur> FunctorSalad_: and then different implementations of that type class are different interpreters
11:52:22 <ddarius> conal: I like XChat on Windows and Linux and there seems to be a Mac version.
11:52:31 <tg_> I don't.
11:52:33 <tg_> irssi ftw
11:52:57 <adnap> Jafet: It seems to be giving me a parse error no matter what I do.  It even does it for "line <- getLine".
11:53:05 <jmcarthur> FunctorSalad_: you can get surprisingly far without the ability to deeply pattern match like you can with an ADT
11:53:05 <ddarius> pumpkin: In theory I'll be working tomorrow, in the mean time I've gotten a lot better at violin and still have no furniture.
11:53:16 <tg_> judging from previous screenshots, I think conal runs linux
11:53:18 <pumpkin> ddarius: who needs furniture when you have a violin
11:53:26 <Jafet> adnap: well don't show us what code you have, or we might end up helping you!
11:53:35 <FunctorSalad_> jmcarthur: ah, I haven't tried that approach
11:53:38 <ddarius> pumpkin: Indeed.  Also, the completely empty room has awesome reverberations.
11:53:41 <jmcarthur> conal: i've been just using command line clients lately. they aren't very mac-like obviously
11:53:52 <pumpkin> I like textual on the mac
11:53:58 <pumpkin> after trying all the other IRC clients and hating them
11:54:15 <conal> tg_: i did run linux.  it was bliss for haskell work.  now i'm on mac os x, which is only better than windows for haskell hacking.   which is why i stopped working on functional guis & graphics.
11:54:21 <adnap> Jafet: Alright, my code is main = do $\n\tline <- getLine\n\treturn ().
11:54:35 <Jafet> do isn't a function.
11:54:55 <pumpkin> conal: there's a semi-stalled effort to make a nice cocoa/objc binding/foreign call convention on the GHC wiki
11:55:09 <adnap> Jafet: What's your point?
11:55:26 <ddarius> adnap: The ($) is syntactically invalid.
11:55:28 <Jafet> So having $ after do is an error.
11:55:51 <conal> pumpkin: yeah.
11:55:54 <adnap> Oh, my bad.
11:56:00 <conal> pumpkin: going nowhere, afaict.  too bad.
11:56:08 <adnap> main = withSocketsDo $\n\tline <- getLine\n\treturn ().
11:56:31 <pumpkin> conal: yeah, I added an idea to it a few weeks ago but it needs some serious time and I don't think any of the people interested have much of that :/
11:56:31 <FunctorSalad_> jmcarthur: but why would you use a typeclass instead of making the different interpreters different functions? I think I'm missing something
11:56:36 <aristid> adnap: i wonder why windows decided to demand startup/shutdown for sockets
11:56:53 <jmcarthur> FunctorSalad_: Finally Tagless, Partially Evaluated is a good read. they write an interpreter, compiler, and partial evaluator, all from a HOAS type class. the partial evaluator even evaluated under lambdas, answering my question, but i think i was asking the wrong question now.
11:58:00 <adnap> Oh, I know the problem.
11:58:10 <jmcarthur> FunctorSalad_: the different interpreters are still different functions. they are just the "run" functions to unwrap whatever type you use
11:58:10 <adnap> It should be: main = withSocketsDo $ do \n\tline <- getLine\n\treturn ().
11:59:29 <adnap> How did I forget that?
12:00:42 <jmcarthur> FunctorSalad_: basically it allows you to use the metalanguage's type checker but without the runtime tags that, say, a GADT would impose, and without being syntactically unclear about the totality of the interpreter (since you can't always pattern match every constructor in a GADT)
12:01:50 <FunctorSalad_> hmm wait, GADTs have runtime tags?
12:02:06 <jmcarthur> the constructor is a tag, isn't it?
12:02:14 <FunctorSalad_> ah
12:02:45 <FunctorSalad_> I somehow thought the typeclass methods would operate on some ADT as input too :)
12:02:54 <conal> jmcarthur: (just rejoining this conversation.)  have you looked into lambda-prolog?  it's easy to rewrite inside of lambda.
12:02:57 <FunctorSalad_> but think I see what you mean now, it works on haskell types directly
12:03:04 <jmcarthur> FunctorSalad_: right
12:03:10 <jmcarthur> conal: no i haven't. i'll take a look. thanks
12:04:39 <conal> jmcarthur: cool.  maybe the usual mapping from lambda-prolog to haskell loses something important.
12:04:39 <conal> hoas was more at home in in lambda-prolog
12:04:54 <jmcarthur> FunctorSalad_: for example:  class HOAS exp where lam :: (exp a -> exp b) -> exp (a -> b) ; app :: exp (a -> b) -> exp a -> exp b
12:06:23 <pumpkin> preflex: seen mtnviewmark
12:06:23 <preflex>  mtnviewmark was last seen on #haskell 1 day, 14 hours, 2 minutes and 56 seconds ago, saying: > reverse "is it opposite day"
12:07:46 <jmcarthur> conal: i'm trying to make it such that different applications of the same function will share whatever work they can. i think what i'm after is called "complete laziness"
12:08:12 <jmcarthur> or "completely lazy evaluation"
12:08:23 <conal> jmcarthur: aka "full laziness"?
12:08:28 <ezyang> Global memotable? 
12:08:37 <jmcarthur> conal: no, those are different, afaik
12:08:41 <conal> there's also "optimal beta reduction".
12:08:48 <conal> jmcarthur: ah.  glad i asked.
12:09:06 <jmcarthur> conal: optimal evaluation is the union of full laziness and complete laziness, i think
12:09:38 <conal> hm.  is there a tight, precise & accurate definition?
12:09:41 <conal> jmcarthur: ^^
12:09:46 <jmcarthur> ezyang: i have never heard of that before
12:10:42 <jmcarthur> conal: A Natural Semantics for Completely Lazy Evaluation gives a big step semantics
12:10:49 <ddarius> lambdaProlog does have higher-order (pattern) unification which is a big difference...
12:10:54 <conal> jmcarthur: thx.
12:11:25 <jmcarthur> conal: http://thyer.name/phd-thesis/thesis-thyer.pdf also covers it, but i haven't quite figured it out yet. it's a different angle
12:11:35 <jmcarthur> plus, it's a thesis. Natural is much shorter
12:11:53 <conal> lambda-prolog also has universal quantification & implication.  all three (incl HOU) are very helpful for hoas manipulation.
12:11:58 <jmcarthur> the thesis compares it to full laziness and optimal evaluation though
12:12:15 <ddarius> conal: True.
12:12:29 <conal> i haven't read the original "HOAS" paper in years, but i imagine it illustrates these features.
12:12:42 <conal> i probably haven't read it since 1988
12:12:45 <jmcarthur> okay, i'm definitely going to have to find that
12:12:52 <jmcarthur> i have never read it
12:13:10 <ddarius> jmcarthur: I highly recommend reading the papers behind lambdaProlog.
12:13:14 <ddarius> It's a cool system.
12:13:20 <jmcarthur> awesome
12:13:38 * conal seconds ddarius's recommendation
12:15:30 <dolio> HOAS in lambda prolog and Haskell are different because the lambda terms in the former aren't used as the basis of computation. They're more like data structures.
12:15:35 <dolio> At least, if I understand it correctly.
12:15:38 <dolio> It's the same with Twelf.
12:15:52 <Eduard_Munteanu> Hm, how would I define a recursive data type for a 2D grid that doesn't contain redundant information? I'd like to make a zipper on it.
12:16:18 <conal> dolio: that's my understanding also.  and i worked quite a lot with lambda prolog & hoas.
12:16:45 <Eduard_Munteanu> Seems to me a 2D topology is hard to turn into a zipper without repeats.
12:17:10 <ClaudiusMaximus> i'm writing bindings to libqd at the moment, which has functions like 'void c_dd_add(const double *, const double *, double *);' - what might go wrong when i make a Num instance using unsafePerformIO ?
12:17:28 <ddarius> Eduard_Munteanu: Normally you'd want the repeats, I'd think.
12:17:39 <dolio> Of course, dependently typed languages will evaluate under lambdas, too, assuming they appear in types. But that wouldn't generally be true for the evaluation model in general.
12:18:09 <ezyang> ClaudiusMaximus: since there doubles you should be ok. 
12:18:13 <ezyang> *they're 
12:18:44 <conal> Eduard_Munteanu: do you really want the constraint that the data type is recursive?
12:18:48 <Eduard_Munteanu> ddarius: Well I'm comparing with the 1D case (list zipper), there are no repeats
12:19:27 <ddarius> Eduard_Munteanu: Short of going backwards, there is only one path to an element in a list / 1D structure.
12:19:36 <ClaudiusMaximus> and a style question: would people prefer a two-level binding structure like OpenGLRaw / OpenGL ?
12:19:45 <ddarius> ClaudiusMaximus: Yes!
12:19:47 <conal> Eduard_Munteanu: if you start with a clean 2D grid type, i doubt you'll get repeats in your zipper.
12:19:55 <diofeher> i'm installing pandoc in mac os x using cabal... but binary is not found... how do i know where pandoc is installed?
12:20:20 <conal> diofeher: have you ever installed an executable from cabal?
12:20:25 <Eduard_Munteanu> conal: well I want to make a comonadic cellular automata out of it.
12:20:27 <diofeher> conal, yes
12:20:36 <Eduard_Munteanu> conal: so I guess it needs to be recursive
12:20:41 <diofeher> cabal install pandoc = successful :)
12:20:42 <ClaudiusMaximus> ddarius: cool, i can do that - but i'll probably not split it into separate packages as it isn't a huge library
12:20:43 <conal> diofeher: maybe your ~/.cabal/bin isn't on your path ?
12:20:52 <ddarius> ClaudiusMaximus: That's fine.
12:20:59 <conal> Eduard_Munteanu: good.  cool.
12:21:26 <diofeher> conal, yes, is this what i wanted to know! $cabaldir was empty and I didn't know where bin were installed :) going to put this in path
12:21:32 <Eduard_Munteanu> ddarius: yeah, and I can't find a useful coordinate tranformation from 2D to 1D, I thought of that too. :/
12:21:47 <conal> diofeher: :) !
12:22:18 <ClaudiusMaximus> namespace question now:  is Numeric.DoubleDouble, Numeric.DoubleDouble.Raw, Numeric.QuadDouble, Numeric.QuadDouble.Raw a sane layout?
12:24:09 <diofeher> conal, it solved, thanks a lot :)
12:24:31 <ClaudiusMaximus> the alternative i'm thinking of is Numeric.QD.* , which might make sense as there are functions that mix Double, DoubleDouble, QuadDouble arguments
12:24:56 <conal> Eduard_Munteanu: try choosing first a semantics of your 2D grid type.  and then play with possible representations.  the semantics will determine the properties.  especially if you follow the "type class morphism" discipline.
12:26:38 <stepkut> why isn't there a Traversable instance for Data.Set ?
12:27:00 <ClaudiusMaximus> :t traverse
12:27:01 <lambdabot> Not in scope: `traverse'
12:27:11 <Eduard_Munteanu> conal: I see.
12:27:16 <pumpkin> stepkut: you can't really write one
12:27:31 <pumpkin> :t Data.Traversable.traverse
12:27:32 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:28:01 <kwuxalot> So I have a pretty simple problem that's blocking me: I have a collection of types deriving show, and I want to put them on disk such that every update creates a new copy.
12:28:13 <Eduard_Munteanu> I'm considering trying something like data Grid a = Grid a [a] [a] ... [a], where each [a] represents the elements in a given direction. It's unwieldy and I'm not sure if works for the 2D case.
12:28:21 <Eduard_Munteanu> Should be a straight generalisation from 1D.
12:28:28 <EvanR-work> wow thats annoying. trying to debug this dynamic typing python trash, the error was that i forgot to put () on conn.commit, so changes werent happening. stupid haskell habits!
12:28:41 <conal> Eduard_Munteanu: if you need help learning denotational design (with type class morphisms), let me know.  it's my central design tool.
12:28:44 <EvanR-work> of course python cant tell me that thats the problem
12:28:49 <kwuxalot> I can't decide if I want to use Data.TCache or the tokyocabinet library, or what
12:29:10 <Eduard_Munteanu> conal: I'll have to look it up myself first, though I've probably seen it already.
12:29:46 <conal> Eduard_Munteanu: yeah.  give the paper a read and let me know.  also illustrated in several of my blog posts.
12:29:52 <Eduard_Munteanu> conal: heh, it's here http://conal.net/papers/type-class-morphisms/ 
12:31:14 <Eduard_Munteanu> Oh, it kinda looks familiar from some of my incursions into type-level arithmetics and Coq readings.
12:33:27 <amibacha> PLS I NEED SMTp
12:33:28 <amibacha> PLS I NEED SMTp
12:33:29 <amibacha> PLS I NEED SMTp
12:33:32 <amibacha> PLS I NEED SMTp
12:33:32 <amibacha> PLS I NEED SMTp
12:33:33 <amibacha> PLS I NEED SMTp
12:33:42 <sproingie> you need to get gone
12:34:05 <EvanR-work> MAIL TO: /dev/null
12:34:34 --- mode: ChanServ set +o pumpkin
12:34:51 <pumpkin> amibacha: please don't spam
12:34:55 <pumpkin> do you need help with haskell?
12:35:26 <amibacha> yeah 
12:35:30 <amibacha> can u help me
12:35:31 <amibacha> ?
12:35:39 <sproingie> you guys are way too patient
12:35:41 <pumpkin> ask your question in here and someone will help
12:35:58 <pumpkin> repeating yourself 6 times will just piss people off
12:35:58 <Eduard_Munteanu> And that's feeding him.
12:36:23 <EvanR-work> sproingie: hey, trolls may be genuinely interested in haskell ;)
12:36:31 <amibacha> dats to tell aw much i need it
12:36:36 <EvanR-work> they just have trouble expressing themselves
12:36:47 <amibacha> well i am sry
12:36:50 <sproingie> #haskell does seem to have a high annoyance threshold
12:37:07 <pumpkin> amibacha: so just ask your question
12:37:07 <sproingie> i just have a case of the mondays.  every day.
12:37:48 <pumpkin> amibacha: asking specific people in private will get you less help than asking a room with 600 people in it
12:37:50 <jmcarthur> i like giving trolls a fair chance to see that they suck at it
12:38:46 <edlinde> Is there a haskell quick reference page which lists all possible functions?
12:38:55 <edlinde> like the stuff you can do with lists for example
12:38:55 <EvanR-work> haskell cheat sheet
12:38:56 <jmcarthur> all possible functions?
12:39:04 <edlinde> Yeah like a cheat sheet
12:39:05 <pumpkin> all standard functions, I'd guess :P
12:39:11 <edlinde> or a reference where you can do a search
12:39:12 <jmcarthur> edlinde: you can see the documentation on Data.List
12:39:15 <EvanR-work> http://blog.codeslower.com/2008/10/The-Haskell-Cheatsheet
12:39:22 <jmcarthur> edlinde: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/index.html
12:39:32 <jmcarthur> @where hoogle
12:39:33 <lambdabot> http://haskell.org/hoogle
12:39:34 <jmcarthur> @where hayoo
12:39:34 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
12:39:40 <EvanR-work> you can also run ghci and tab complete every letter
12:40:32 <edlinde> awesome
12:40:35 <edlinde> :)
12:40:48 <edlinde> Ah I didn't know I could tab complete in ghci
12:40:55 <Eduard_Munteanu> A cheatsheet mapping type signatures in some sorted fashion to standard functions would be nice.
12:41:31 <Eduard_Munteanu> Though Hoogle does that too.
12:41:32 <edlinde> thanks guys
12:41:40 <EvanR-work> but yeah haskell is like perl, theres no magic keywords ;)
12:41:47 <EvanR-work> you make your own magic
12:41:52 <EvanR-work> s/is/is not/
12:41:54 <EvanR-work> >_<
12:42:00 <Eduard_Munteanu> @hoogle a -> a -> a
12:42:00 <lambdabot> Prelude asTypeOf :: a -> a -> a
12:42:00 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
12:42:00 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
12:42:17 <edlinde> I just done some ML and for a lot of these functions you got to write code to do it
12:42:28 <edlinde> like generation of natural numbers
12:42:31 <edlinde> init 
12:42:35 <edlinde> etc
12:42:53 <edlinde> Haskell seems to provide quite a lot of that out of the box
12:45:36 <pumpkin> preflex: seen chrisdone
12:45:37 <preflex>  chrisdone was last seen on #haskell 1 day, 3 hours, 2 minutes and 41 seconds ago, saying: ski: mine had titles :p
12:45:47 * mux thanks the gtk+ API docs for describing a callback type as taking a GdkEvent * when it was really taking a GdkEventButton *
12:45:49 <pumpkin> @remember chrisdone Production of two-handed use langes Schwerts with long flambard blades and heavily category-theoretically decorated guards, katzbalgers, axes, mail and Macedonian quality defence pikes. Lambda Knights need to be prepared for the inevitable battle against success.
12:45:49 <lambdabot> I will never forget.
12:46:11 <monochrom> ...
12:50:32 <dolio> Experimenting with Markov chains?
12:50:56 <pumpkin> dolio: beats me, he just wrote that to haskell-cafe
12:51:40 <monochrom> it answers "what does tool building mean" :)
12:51:47 <dolio> Man, I should stop reading comp.lang.functional.
12:52:13 <augustss_> why?
12:52:16 <monochrom> I stopped many years ago. What is fun lately?
12:52:28 * ddarius also stopped many years ago.
12:52:34 <Eduard_Munteanu> Is that really Usenet anymore or just some Gmane magic turning some MLs into groups?
12:52:39 <augustss_> I stopped many years ago too
12:52:45 <dolio> xah_lee: "List comprehensions are bad because [ f x | x <- l, p x] is just map f . filter p"
12:52:51 <dolio> several other people: "Yeah, totally right!"
12:53:01 <augustss_> ugh
12:53:19 <sipa> @undo [ f x | x <- l, p x]
12:53:19 <lambdabot> concatMap (\ x -> if p x then [f x] else []) l
12:53:26 <augustss> it's wrong
12:53:35 <sproingie> not sure there's a qualitative difference between usenet and gatewayed ML's these days
12:53:36 <monochrom> several factors why I stopped. xah lee appeared. comp.lang.haskell started. and of course, the eternal tendency to just bitch about syntax.
12:54:24 <augustss> sounds like i should start reading it again
12:54:32 <edlinde> just wondering... when would you use infinite lists?
12:54:38 <ddarius> augustss: It does?
12:54:41 <edlinde> in what context are they useful?
12:54:47 <pumpkin> edlinde: when whatever you're making a list of doesn't have a meaningful end
12:54:47 <monochrom> when I don't know how many items I want from the list
12:54:54 <augustss> xah lee sounds like a blast
12:55:06 <Eduard_Munteanu> > (!! 5) iterate (+1
12:55:07 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:55:12 <Eduard_Munteanu> > (!! 5) iterate (+1) 0
12:55:13 <lambdabot>   Couldn't match expected type `[t -> t1 -> t2]'
12:55:13 <lambdabot>         against inferred typ...
12:55:19 <Eduard_Munteanu> Damn, I'm stupid.
12:55:24 <monochrom> when I exploit lazy infinite list as a loop
12:55:29 <dolio> There was a nice big thread about how "strong testing" is better than "strong typing" recently, too.
12:55:40 <adnap> Is there a function that's basically sequence . map?
12:55:42 <edlinde> hmm are there any real world examples?
12:55:47 <ddarius> adnap: mapM
12:55:49 <ddarius> @src mapM
12:55:49 <lambdabot> mapM f as = sequence (map f as)
12:55:52 <adnap> Oh yeah
12:56:04 <adnap> I thought there was.  Thanks.
12:56:06 <ddarius> edlinde: It happens all the time.
12:56:08 <edlinde> where you would need to represent something as an infinite list?
12:56:08 <augustss> "strong testing", that must mean exhaustive testing
12:56:21 <Eduard_Munteanu> edlinde: you don't need it's just convenient.
12:56:24 <pumpkin> edlinde: I can give you an example of an infinite tree
12:56:28 <EvanR-work> dolio: sounds horrible already
12:56:53 <Eduard_Munteanu> edlinde: anyway, you're only interested in a part of such a list, but you're describing the object as it is, infinite.
12:57:07 <edlinde> I understand that since Haskell is lazy it doesn't matter if you have infinite data types
12:57:10 <edlinde> is that right?
12:57:10 <c_wraith> > let number x = zip [1..] x in number "foo" -- edlinde
12:57:11 <lambdabot>   [(1,'f'),(2,'o'),(3,'o')]
12:57:13 <monochrom> an OOP object is an infinite list.
12:57:22 <EvanR-work> testing did not fix (or even tell me about) all the implicit type errors in this python script
12:57:26 <edlinde> hmm
12:57:36 <c_wraith> edlinde: without an infinite list, that function's going to be much more awkward
12:57:44 <ddarius> EvanR-work: That's because you weren't using -strong- testing.
12:57:51 <EvanR-work> strong?
12:58:14 <Eduard_Munteanu> Well, that's better. I was going to complicate things.
12:58:30 <edlinde> so if i said I want an infinite tree, and then said I do a search on this.. how would that work?
12:58:51 <dolio> EvanR-work: You see, not having types is better, because it puts you in a more defensive stance.
12:58:52 <monochrom> filter your_search_predicate infinite_list
12:58:54 <edlinde> sorry just wondering :)
12:58:56 <EvanR-work> you cant test every input in every context
12:59:07 <monochrom> > filter even [1..]
12:59:08 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
12:59:10 <sproingie> monochrom: how's an OOP object map to an infinite list?  sequence of states?
12:59:10 <EvanR-work> dolio: im very defensive, it doesnt help
12:59:26 <edlinde> ok
12:59:32 <dolio> When you have types, you get over-confident, and start thinking that types catch all your errors. Then you forget to worry about matching units, and your space probe misses Mars, or something.
12:59:44 <monochrom> of course there are better ways to produce even numbers
13:00:02 <edlinde> but what I meant is that I used this tree, and we kept building it by adding new nodes
13:00:05 <dolio> O(n) extra work isn't too bad.
13:00:08 <ddarius> > find odd (iterate (2+) 0)
13:00:12 <lambdabot>   mueval-core: Time limit exceeded
13:00:13 <EvanR-work> well units is definitely a nice static typing features
13:00:19 <monochrom> sequence of states is right. the sequence is induced by unbounded number of setter method calls
13:00:29 <edlinde> and then I said I want to do a search ... depth first probably... but this key could be somewhere thousands of levels deep
13:00:38 <edlinde> how does Haskell handle this lazily?
13:00:45 <edlinde> thats the part I don't quite get
13:00:55 <EvanR-work> dolio: so basically static typing is like training wheels
13:01:03 <ddarius> monochrom is subtly hinting at the common coalgebraic nature of objects and infinite lists.
13:01:18 <dolio> EvanR-work: Who knows?
13:01:31 <sproingie> monochrom: sounds like one choice of monads out of many you could use to capture state
13:01:44 <monochrom> I did not choose a monad.
13:01:46 <Eduard_Munteanu> edlinde: laziness is not a guarantee it will terminate.
13:01:50 <EvanR-work> dynamic typing is a bug, not a feature. its the lack of a safety, lack of a good tool, lack of sanity
13:01:57 <EvanR-work> lack of compiler ingenuity
13:02:03 <edlinde> Eduard_Munteanu: ok
13:02:08 <ddarius> Sanity is over rated.
13:02:19 <edlinde> so I just wonder how an infinite tree is stored in memory
13:02:25 <sproingie> with infinite memory
13:02:26 <Eduard_Munteanu> edlinde: you can still get into processing infinite data.
13:02:27 <edlinde> or how its represented 
13:02:29 <ezyang> Real men code in untyped lambda calculus. 
13:02:35 * sproingie powers up his turing machine
13:02:39 <EvanR-work> or assembly language
13:02:40 <EvanR-work> or whatever
13:02:48 <pumpkin> ezyang: real men code in SK
13:02:50 <edlinde> k
13:02:57 <dolio> EvanR-work: That argument, at least, sounds suspiciously like the Ruby advocates', "the fact that Ruby's interpreter is slow encourages you to write better algorithms."
13:02:59 <Eduard_Munteanu> edlinde: let's say it's symbolical, just like you and me talk about infinite lists without getting stuck in an infinite loop
13:03:09 <sproingie> dolio: rationalizations are funny things
13:03:13 <pumpkin> dolio: oh nice, I hadn't heard that one
13:03:20 <EvanR-work> dolio: *laughs ass off*
13:03:21 <Eduard_Munteanu> edlinde: that doesn't me we can find its last element in finite time.
13:03:21 --- mode: pumpkin set -o pumpkin
13:03:33 <dolio> Only it's Lispers saying it, instead of Rubyists.
13:03:37 <adnap> What does the channel field on hpaste actually do?
13:03:46 <Eduard_Munteanu> edlinde: *mean
13:03:47 <monochrom> Eduard_Munteanu is right. Some representation of a piece of code that will produce "the next item" and "the next piece of code for more" when you run it.
13:03:48 <pumpkin> adnap: it's a mystery
13:03:49 <adnap> I put in #haskell, but does that do anything to notify the channel?
13:03:57 <sproingie> dolio: except good lisp implementations are smoking fast
13:03:58 <pumpkin> adnap: I think it's a planned feature or something :P
13:04:10 <adnap> lambdabot could say "new hpaste!"
13:04:26 <dolio> sproingie: Yes, well, the blanks are filled in differently in the Lisp case.
13:04:27 <monochrom> if you have written immutable objects in OOP, you know exactly what to do.
13:04:36 <edlinde> Eduard_Munteanu: there is this Lisp project that accepts C code as friend functions.. am wondering if there is a way to write stuff in Haskell, and somehow get it to integrate into Lisp :)
13:04:41 <EvanR-work> sproingie: even with dyanmic types?
13:04:52 <edlinde> Eduard_Munteanu: I have decided to learn Haskell from ML ... instead of learning Lisp 
13:04:53 <dolio> Deficiency _ encourages good behavior _.
13:05:01 <sproingie> EvanR-work: sbcl will still run circles around perl
13:05:03 <edlinde> Eduard_Munteanu: Lisp sounds slightly Archaic
13:05:07 <adnap> Anyhow, how can I receive input from standard and send it to the server while concurrently receiving messages from the server? http://hpaste.org/40685/udp_client
13:05:13 <sproingie> EvanR-work: except for file i/o.  perl has some frighteningly well-tuned internals there
13:05:17 <adnap> Currently, I only get a message after I send one.
13:05:22 <ddarius> Deficiency in iron encourages good behavior in iron.
13:06:20 <sproingie> there is something to be said for scarcity encouraging efficiency
13:06:27 <dolio> <Deficiency> encourages <good behavior>. Is that better?
13:06:30 <EvanR-work> dolio: mortal fear of results of deficiency _ in every other language encourages good behavior _ even if mostly system mostly protects you
13:06:33 <Eduard_Munteanu> edlinde: well there's a way to call C functions from Haskell, see FFI
13:06:49 <EvanR-work> nub mostly
13:06:56 <edlinde> Eduard_Munteanu: is there a way to convert hskell code to C?
13:06:59 <edlinde> *haskell
13:07:07 <ezyang> edlinde: Sort of. 
13:07:14 <Eduard_Munteanu> edlinde: yes, but not in a meaningful way.
13:07:14 <adnap> ghc
13:07:23 <Eduard_Munteanu> Looks mostly like garbage.
13:07:32 <EvanR-work> dolio: if only i could name that logic fallacy
13:07:38 <adnap> you can generate bindings for C and then call them from C
13:07:42 <edlinde> I am just trying to convince my prof that I could try writing plugins in Haskell for his Lisp project... (but he doesn't like haskell) :(
13:07:57 <edlinde> ah thats cool
13:07:57 <ddarius> Iron deficiency encourages slower population growth.
13:08:04 <Eduard_Munteanu> IIRC, jhc was a bit better at that, but it's still not clean code. Transformations like that are always difficult.
13:08:20 <edlinde> so I can basically write stuff in Haskell and just generate a C binding for it... that could work
13:08:23 <ClaudiusMaximus> edlinde: it is possible, but can be painful (you need to start the GHC RTS if you're using GHC)
13:08:30 <edlinde> as long as the binding is super fast
13:08:42 <EvanR-work> edlinde: sounds like the wrong way
13:08:44 <Eelis> ok, so i just finished debugging a problem that a user of mine ran into with my application. it turns out that the behavior of    fail "ugh" :: Either String Bool   changed in mtl 1.1.1.0. it used to just evaluate to   Left "ugh"  , but now it throws some kind of exception. seriously, who the fuck thought it was a good idea to silently change the semantics of that?!
13:08:47 <edlinde> yeah I am using GHC
13:09:04 <edlinde> EvanR-work: what do you suggest other than learning Lisp? :)
13:09:12 * hackagebot archlinux 0.3.4 - Support for working with Arch Linux packages.  http://hackage.haskell.org/package/archlinux-0.3.4 (MagnusTherning)
13:09:14 * hackagebot cabal2arch 0.7.5 - Create Arch Linux packages from Cabal packages.  http://hackage.haskell.org/package/cabal2arch-0.7.5 (MagnusTherning)
13:09:16 <EvanR-work> i dont think lisp takes much learning
13:09:33 <EvanR-work> you shouldnt avoid learning stuff anyway
13:09:37 <ddarius> Eelis: People didn't like the Error constraint, but fail requires that for a reasonable interpretation, so it was changed.  I agree that it is quite a destructive change.
13:09:46 <adnap> edlinde: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
13:09:54 <edlinde> EvanR-work: I would rather put that effort into learning Haskell better 
13:10:10 <EvanR-work> you must have very limitted effort resources ;)
13:10:20 <Eelis> ddarius: i see..
13:10:21 <adnap> Did anyone look at mah hpaste?
13:10:44 <edlinde> EvanR-work: or I am super efficient :)
13:10:51 <edlinde> adnap: thanks
13:11:12 <EvanR-work> the project is in lisp so use lisp
13:11:49 <EvanR-work> this thing about needing to be 'super fast' is sort of unnerving though
13:12:04 <EvanR-work> is this a BGP server or a video card driver?
13:12:42 * Eduard_Munteanu was rather going to cite BLAS-like hand tuned routines.
13:13:18 <edlinde> EvanR-work: was that for me sorry?
13:13:25 <EvanR-work> generally
13:13:27 <Eduard_Munteanu> If Lisp is good enough, probably Haskell is too.
13:13:37 <edlinde> its a data mining project
13:13:49 <edlinde> its a home grown dbms written in Lisp
13:13:51 <EvanR-work> but he cant change the entire project, team project
13:13:55 <edlinde> with some bits written in C
13:14:07 <edlinde> and people write Java plugins for it too
13:14:12 <EvanR-work> writing your part in not lisp sounds not good ;)
13:14:15 <Eduard_Munteanu> LOL
13:14:38 <edlinde> EvanR-work: well most of the students he has don't write Lisp and would much rather code the new stuff in C or Java
13:14:47 <edlinde> the prof just loves Lisp
13:14:47 <EvanR-work> thats even worse
13:14:53 <edlinde> yeah I know :)
13:15:01 <adnap> edlinde: wont he love haskell then?
13:15:07 <edlinde> but the Prof is like... Lisp can handle anything
13:15:25 <edlinde> I been bugging him to write something that can handle haskell plugins
13:15:28 <Eduard_Munteanu> Duh, it's Turing-complete.
13:15:29 <edlinde> but he won't budge
13:15:30 <edlinde> :)
13:15:38 <adnap> what advantages does lisp have over haskell?
13:15:43 <edlinde> he also allows people to write Perl, Python plugins
13:15:55 <edlinde> adnap: got no clue 
13:16:01 <adnap> i only know some really basic lisp; i've never used it for a project
13:16:08 <dolio> adnap: I was just explaining.
13:16:13 <Eduard_Munteanu> Probably that you can just press 'o' in vim and insert some impure code anywhere.
13:16:17 <dolio> Lisp doesn't have types, so it doesn't lull you into a false sense of security. :)
13:16:23 <EvanR-work> lol
13:16:28 <edlinde> but you ask a lisper ... for ex the prof goes.. After Lisp came out there should have been no need for any more languages
13:16:36 <edlinde> its the complete language
13:16:38 <edlinde> :)
13:16:48 <adnap> dolio: How does Haskell lull false sense of security?
13:16:56 <adnap> *lull you into
13:17:01 <adnap> *a
13:17:02 <adnap> lol
13:17:31 <mauke> edlinde: tell him lisp is blub
13:17:32 <adnap> What about type safety in lisp?
13:18:16 <adnap> It wont catch all type errors at compile time, right?
13:18:19 <edlinde> its just that he wouldn't even consider any other functional language
13:18:21 <Eduard_Munteanu> If you write the type of programs that don't run nuclear reactors, then it's probably safe :P
13:18:26 <edlinde> which I think is a bit sucky
13:18:50 <ezyang> I have a question: which is "how do real software engineers convince each other that their code is correct?" 
13:19:02 <edlinde> recently someone rewrote this Java code in ML in much fewer lines and it was way way quicker 
13:19:03 <edlinde> :)
13:19:21 <dolio> ezyang: They don't, probably.
13:19:22 <adnap> ezyang: they could always formally proove their algorithms
13:19:30 <adnap> ezyang: lol
13:20:09 <adnap> ezyang: They could run a diverse set of test cases, and show that the program gives the write answer
13:20:11 <ezyang> dolio: "Oh dear." 
13:20:11 <Eduard_Munteanu> Interesting, so you can code in his beloved functional Lisp, can code in impure non-functional languages, but not in any other functional language?
13:20:16 * hackagebot archlinux-web 0.1 - Website maintenance for Arch Linux packages  http://hackage.haskell.org/package/archlinux-web-0.1 (MagnusTherning)
13:20:57 <edlinde> Eduard_Munteanu: exactly
13:21:19 <edlinde> he is pretty much like.. if you gonna use a FP then its got to be lisp.. otherwise there is no point
13:21:37 <edlinde> coz he thinks the other Fps have nothing to offer that Lisp cannot do
13:21:43 <edlinde> so ah well...
13:21:49 <Eduard_Munteanu> Well he has a point... if you're going to make life harder for others, then at least go for Lisp.
13:22:02 <edlinde> I write a lot of C
13:22:27 <edlinde> but now that I am getting the hang of FP I would love to do some quick prototypes esp with tree data structures 
13:22:34 <edlinde> just to see if something works
13:22:54 <Eduard_Munteanu> edlinde: you can use Haskell for prototyping.
13:23:00 <edlinde> Yeah thats my idea
13:23:14 <edlinde> I want to show him that Haskell prototypes are infact faster
13:23:16 <edlinde> :)
13:23:31 <edlinde> and do kick ass ... nothing bad about it
13:24:41 <Eduard_Munteanu> I'm not sure you'll change his mind any bit. He either thinks Lisp is the ultimate thing, or he restricts your choice to Lisp so other students don't get too many headaches.
13:24:47 <adnap> Whoa, forkIO was what I needed guys!
13:24:51 <dolio> ezyang: I was once debugging a problem with some commercial application server...
13:25:15 <ezyang> "Hey, that sounds familiar..." 
13:25:26 <dolio> The problem boiled down to some code that went: "if <false> then <code for DB server separate from app server> else <code where the two are the same machine>".
13:25:26 <Entroacceptor> you know that picture?
13:25:34 <Eduard_Munteanu> Now if functional languages scare the hell out of them, using only Lisp is at least some relief.
13:26:06 <dolio> But it was never caught in their test environment, because they (presumably) always used a single-machine setup to test things.
13:26:26 <Eduard_Munteanu> And admittedly Lisp isn't all that hardcore, at least if you only use a certain subset of it.
13:26:28 <Entroacceptor> that one: http://i.imgur.com/1gF1j.jpg
13:26:36 <benmachine> @unmtl WriterT w (State s) a
13:26:37 <lambdabot> s -> (a, w, s)
13:26:44 <dolio> So their always-false test was always correct for them.
13:26:46 <benmachine> @unmtl StateT s (Writer w) a
13:26:47 <lambdabot> s -> (a, s, w)
13:26:55 * benmachine wonders if the binds for those are the same
13:26:56 <dolio> Anyhow, presumably they didn't have to convince anyone that that code was correct.
13:27:07 <dolio> At least, not very strenuously.
13:27:22 <ezyang> >.> 
13:27:55 <Eduard_Munteanu> Now imagine if someone were to write a significant component of that software in Coq/Agda/Epigram :)
13:28:07 <ezyang> I mean, it's not really practical to do so. 
13:28:57 <sproingie> "Beware of bugs in the above code; I have only proved it correct, not tried it." --Don Knuth
13:29:59 <monochrom> beware of proofs in knuth's writing. he has only proved them in prose, not formalized them.
13:30:24 <ddarius> dolio: That's a crappy test environment.
13:30:36 <dolio> Yeah, well...
13:31:17 <monochrom> iow I would trust knuth's proofs no more than other traditional mathematicians proofs. but I would trust Dijkstra's proofs much more: the language is much less ambiguous and the steps so much more atomic and the whole length so much shorter.
13:31:26 <ddarius> Usually no one cares for convincing that code is correct until it becomes a question of whose code has the (reported) bug.
13:31:59 <ddarius> monochrom: So Dijkstra's proofs are smaller even though the steps are "smaller" ?
13:32:25 <monochrom> yes
13:32:51 <monochrom> because he uses rewriting rules rather than natural deduction
13:34:23 <monochrom> I didn't do service to his proofs when I said that. He refactors proofs. That's why they're shorter and yet each step is more atomic.
13:35:15 <dolio> monochrom is a Dijkstra funbud.
13:35:30 <alexbobP> Dijkstra is pretty cool though
13:35:39 <dolio> No doubt.
13:35:44 <alexbobP> he taught at my university :D
13:36:44 <monochrom> E.g. prove one extremely useful rewrite rule that no one thought would be useful previously. Then use the rewrite rule a million times. Saves a lot of repeated work other people had been doing.
13:38:43 <monochrom> if you have ever golfed haskell code, you know how to do that exactly.
13:39:35 <Adamant> I think Knuth's comment was more about the underlying software stack he was running on and the fact you usually need to do more work than a general proof to ensure your code is actually proven in the context of your enviroment
13:40:45 <Eduard_Munteanu> It's certainly more work to get a proof that's machine-checked.
13:40:56 <Adamant> and while Djikstra was important and probably pushed the general field of CS ahead quite a bit, he never actually wrote all that much real software
13:41:17 <Adamant> that was probably not a coincident given the environment of the times
13:41:24 <Adamant> *coincidence
13:41:24 <Eduard_Munteanu> o/ Adamant 
13:41:29 <monochrom> he wrote real software before he joined academia.
13:41:40 <Adamant> yeah, let me rephrase that
13:41:45 <sipa> Adamant: according to dijkstra, i think software-writing is not computer science :)
13:42:17 <mreh> the man had no computer in his house
13:42:21 <Adamant> he never actually wrote much software in the style he advocated after joining academia
13:42:37 <mreh> I state that meerly as an observation
13:42:51 <Adamant> sipa: then he can go sit in the theoretical math department and get funded under their banner
13:42:52 <mreh> now where do I enable optimisations or warnings in my cabal file?
13:43:01 <adnap> Is there a function that's like: Bool -> Monad m -> Monad m
13:43:07 <adnap> if b then m else return
13:43:10 <Adamant> all STEM fields are a mix of theory and practice
13:43:12 <Adamant> even math
13:43:28 <sipa> Adamant: depends what you call computer science - i think the meaning he gave to it was quite mathematical/abstract indeed
13:43:35 <Adamant> theoretical math can certainly afford to pretend that is not the case
13:43:39 <Adamant> I can buy that absolutely
13:43:41 <Adamant> I agree
13:44:25 <dcoutts_> mreh: ghc-options: -Wall
13:44:37 <adnap> Ah, "when".
13:46:31 <mreh> dcoutts_ thanks
13:47:45 <bla123> adnap: you can use hoogle to search for functions when you know their signature
13:48:19 <sipa> adnap: if b then m else return    -> return what?
13:48:25 * mux sent anohter gtk2hs patch today and was able to eliminate all the connectGeneric calls in his application. Yay!
13:49:46 <Modius> Does that leksah IDE get much use?  Or do all the hardcores stick more to editors?
13:50:29 * mux wonders if Andy Stewart comes on IRC
13:50:48 <adnap> sipa: The function I wanted what "when".
13:50:55 <adnap> sipa: *was
13:50:59 <sipa> :t when
13:51:00 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:51:08 <sipa> @src when
13:51:08 <lambdabot> when p s = if p then s else return ()
13:51:18 <adnap> yep
13:51:29 <adnap> I guess I should have said return ().
13:51:37 <adnap> That's what I meant though.
13:51:41 <monochrom> Dijkstra's focus when he joined academia was streamlining proofs so that doing proofs for programs would be easy enough. That took the rest of his life and still not quite finished. But other people, like me, can write programs in his way.
13:51:56 <mux> which makes me think, we should really get whenMaybe into base some day
13:52:13 <mux> I need it constantly in IO-heavy code
13:52:24 <adnap> bla123: Thanks
13:52:30 <Adamant> yup, and he should be commended for that. but he probably shouldn't rail as much as he does against unproven programs given the very real costs of doing so at the time
13:52:54 <Twey> whenMaybe?
13:53:10 <mux> whenMaybe m f = maybe (return ()) f m
13:53:27 <mux> err
13:53:29 <mux> wait.
13:53:38 <bla123> adamant: isn't proving programs still expensive today?
13:53:40 <Twey> :t flip . maybe $ return ()
13:53:41 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe a -> (a -> m ()) -> m ()
13:53:47 <mux> well yes, that does it.
13:53:51 <Adamant> bla123: yes, but at this point it's semi-realistic
13:53:56 <Adamant> to do it for a lot more things
13:54:02 <mux> very, very useful
13:54:17 <Adamant> especially if it's code you're going to be using for a while and you are thinking long-term
13:54:20 <Twey> Hm, okay
13:54:35 <monochrom> But going back to answer the formidable stack of computing environment. The proper way to tackle that is first prove that the low-level operational semantics satisfy the high-level semantics (pick your choice: pre-post conditions, weakest precondition, denotational, predicative). Then reason about your program using the high-level semantics only. Your proof then will not deviate from testing.
13:54:36 <bla123> Adamant: but we demand more of our programs today, e.g. network communication, concurrency, etc
13:55:11 <monochrom> Knuth never did that. That is why his proofs may deviate from testing.
13:55:20 <mux> maybe whenJust would be a more appropriate name
13:55:47 * mux digs up some old source code of his that actually used that name
13:55:51 <Adamant> monochrom: even L4.verified is arguable still just a really workable toy compared to one of the major OS's
13:55:53 <mux> Util.hs:whenJust = flip (maybe (return ()))
13:55:57 <adnap> code review! http://hpaste.org/40689/udp_clientserver
13:55:57 <Adamant> *arguably
13:56:26 <monochrom> Knuth's proofs are sketch proofs that appeal to the operational semantics directly, not through a proxy of an easier-to-use semantics.
13:56:57 <monochrom> Knuth's machine is the rather simplistic MIX. Whatever Dijkstra advocated is extremely workable there.
13:57:27 <Adamant> I suspect he was not running the quoted program on a MIX machine
13:57:31 <monochrom> If you say, x86, sure, I can't do that. But MIX and SECD?
13:58:05 <Adamant> or the person he was advising wasn't
13:59:45 <mux> Adamant: your code looks mostly fine, but there are higher-level network constructs that would have allowed you to write this in a much simpler way; what you have here is what I like to call "C in Haskell". Also, why the IORef's?
13:59:52 <mux> woops, that was for adnap 
14:00:54 <mux> that really looks like the output of a C to Haskell converter program :-)
14:01:05 <sproingie> MIX has to use self modifying code just to get a stack.  sometimes simple results in something more complex
14:01:18 <adnap> mux: I don't know the higher level stuff.  Also, I don't know how to maintain state in a program yet.
14:01:21 <sproingie> something MMIX apparently fixes
14:01:38 <adnap> mux: I guess I could thread the hosts list back into the function over and over.
14:01:43 <mux> adnap: alright then; considering what you know about Haskell for now, this is ifne
14:02:01 <adnap> mux: Would that work?
14:02:27 <adnap> mux: Also, what higher level network stuff are you talking about?  I looked at the Network module, but it looks like it only does TCP.
14:02:55 <mux> oh, my bad, I hadn't realized this was UDP
14:03:19 <adnap> mux: yerp
14:03:22 <mux> I'm still trying to understand what you're doing with this IORef to see what to use instead
14:03:25 <bastl> Is anyone aware of a tool or approach to model references between nodes of syntax trees of _different_ languages (e.g. exposed modules in a cabal file reference the module headers themselves)
14:03:58 <mux> okay, you're really using it as a variable
14:04:07 <adnap> mux: Nothing important.  I think I can just send it back through the function.
14:04:08 <mux> like, modifying it, and then reading it the very next line
14:04:21 <dcoutts_> bastl: well there are lower level approaches for languages on a common VM, e.g. jvm, clr
14:04:23 <mux> yes, you need to send the new value to the function each time
14:04:29 <mux> this is what we mutate around here :o)
14:04:33 <mux> s/what/how/
14:05:22 <bastl> dcoutts_: wow. of course, they need it. any keywords to search for on a higher level (e.g. Java and XML). searching for "references" is no fun in the academia ...
14:05:28 <mux> adnap: if you need efficiency, you might wanna look at the network-bytestring package
14:05:40 <adnap> mux: Okay
14:05:45 <adnap> mux: I might in the future
14:05:46 <dcoutts_> bastl: maybe cross language program analysis or debugging
14:06:44 <dcoutts_> bastl: or the code weaving stuff that you get in aspect oriented compilers (e.g. aspectj or abc aspect java compilers)
14:09:31 <mux> damn bitbucket.org munges line breaks in the commit logs
14:09:56 <ddarius> "The Little Book of Semaphores" is not so little.
14:10:05 <hpc> haha
14:10:13 <davidL> why would 'cabal install haskell98' install itself again if it's already installed?
14:10:46 <monochrom> there is a haskell98 package?
14:11:01 <mux> dcoutts_: was the EventM monad your idea or was that introduced after you?
14:11:06 <monochrom> yes there is.
14:11:10 <dcoutts_> mux: not my idea
14:11:34 <mux> dcoutts_: it's neat; with phantom types to ensure you query the correct even structure
14:11:39 <dcoutts_> davidL: it's a bug in cabal-install, the workaround is not to have multiple instances of the same package version installed at once.
14:12:12 <monochrom> bad bug!
14:12:13 <dcoutts_> davidL: you'll find you've got two instances of that package, one in the user package db, one in the global.
14:12:30 <mux> my workaround is often to "cabal unpack" and then install the package by hand
14:12:38 * mux grins
14:12:38 <monochrom> oh, not so bad then. in fact, I'd say: good punishment
14:12:55 <mux> monochrom: you cannot really help that kind of things
14:13:16 <mux> monochrom: unless you stop using cabal-install altogether :-)
14:13:16 <dcoutts_> monochrom: it was an assumption that used to be true, but it changed underneath us, need a lot more work to handle multiple instances.
14:13:26 <davidL> dcoutts_: is the bug reported in a bug tracker somewhere? also, is someone working on a fix?
14:13:35 <pumpkin> is there a (co&contra)variant functor class somewhere? and associated monad?
14:13:58 <dcoutts_> davidL: not actively working on a fix, no. The proper solution is to rewrite the cabal-install package search constraint solver.
14:14:29 <monochrom> cabal doth too much
14:14:31 <ddarius> pumpkin: I don't understand your question.
14:14:58 <sid0> Hi. I'm trying to get data parallel Haskell running, but it's slower with more cores than with fewer
14:14:59 <pumpkin> ddarius: something with a map :: (a -> b) -> (b -> a) -> f a -> f b
14:15:03 <dcoutts_> monochrom: doing without the constraint solver is not much fun when there are >20 deps for a package
14:15:05 <monochrom> I personally would rather cabal not chase dependency. or chase, but don't automatically install. just tell me, let me do it.
14:15:16 <sid0> would anyone be able to help?
14:15:20 <dcoutts_> mornfall: use --dry-run
14:15:24 <dcoutts_> oops
14:15:27 <dcoutts_> monochrom: ^^
14:15:58 <sid0> (that's vectorized code)
14:16:02 <monochrom> alright, I admit I'm intimidated by the number 20!
14:16:15 <pumpkin> > product [1..20]
14:16:16 <lambdabot>   2432902008176640000
14:16:18 <mux> cabal-install clearly shouldn't try to install a newer version of a dependency by itself; only when it has been asked for with cabal upgrade on the said dependency, or via a full upgrade
14:16:23 <ddarius> pumpkin: Edward has a class ExpFunctor or something like that in category-extras.
14:16:37 <pumpkin> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Exponential.html
14:16:38 <pumpkin> aha
14:16:44 <mornfall> mux: Well, it doesn't overwrite the old version.
14:16:49 <pumpkin> is there a similar notion of a monad that works that way?
14:16:51 <mornfall> mux: And it won't upgrade if it doesn't have to IIRC.
14:16:56 <dcoutts_> mux: it doesnt, but sometimes one has to reinstall the existing version against different versions of deps.
14:17:05 <mux> it does in a way at least
14:17:20 <dcoutts_> mux: or if the thing you want to install needs a newer version of the dep
14:17:34 <pumpkin> this type I'm making is very functor/applicative/monadish but I need to pass inverse functions around too
14:17:36 <mux> try to install a package as a user with cabal-install, having a bytestring package in the system db that is not the newest version
14:17:37 <dcoutts_> monochrom: cabal install yi --dry | wc -l  gives 46 :-)
14:17:46 <mux> cabal-install will install the updated bytestring package in the user db
14:17:50 <monochrom> thank god I don't use yi
14:17:58 <mux> subsequently, you cannot upgrade anything at all
14:18:03 <mux> I've had this multiple times
14:18:14 <dcoutts_> mux: probably a dep pulled in a newer version, you can ask for the current version and see where it fails
14:18:22 <mornfall>     Latest version available: 0.9.1.7
14:18:22 <mornfall>     Latest version installed: 0.9.1.5
14:18:32 <mornfall> mux: ^^ that's bytestring
14:18:37 <mornfall> mux: The installed one is system
14:18:41 <mornfall> mux: I don't have a user one
14:18:49 <mornfall> Even though I cabal install stuff all the time.
14:18:59 <ddarius> pumpkin: You may want to explicitly split the covariant and contravariant occurrences if that is feasible.
14:19:06 <sid0> I'm trying out the example from http://empitsu-kami.livejournal.com/2075.html -- I realize it's old, but it seems like it should still work
14:19:16 <mux> mmm, alright, I drew wrong conclusions; there must have been some package that really requested the updated bytestring then
14:19:21 <pumpkin> ddarius: not really :/ at least as far as I can tell
14:19:33 <sid0> could someone verify that my command-line args etc are correct? http://github.com/sid0/dph-experiments/blob/master/dotp/Makefile
14:19:46 <dcoutts_> mux: right, and after than cabal will pick the latest installed one on the assumption that's the one you want.
14:19:57 <mux> still, it is legitimate to have multiple versions of a package installed in that case, and it would be nice if cabal-install could deal with it
14:20:05 <dcoutts_> mux: that's changeable by preferences, but I agree the defaults could be better here.
14:20:15 <dcoutts_> mux: it can, it's a question of policy
14:20:33 <mux> I thought you just said the constraint solver couldn't cope with that
14:20:53 <dcoutts_> mux: no, that was about multiple instances of the *same* version, different versions are fine
14:21:20 <mux> I'm not so sure what happened to me repeatedly, then :-P
14:21:47 <mux> luckily enough, GHC has a fast enough release cycle that I end up reinstalling everything before it gets too annoying.
14:21:48 <dcoutts_> you probably ended up with a user db later bytestring, then cabal started using that for all new things leading to a mess
14:22:05 <mornfall> Hm. I wonder when people actually start to use real SAT solvers to get dependencies right. : - )
14:22:16 <pumpkin> there's a yices binding
14:22:18 <dcoutts_> mornfall: they already do
14:22:24 <pumpkin> you just need to bind cabal-install to that binding :)
14:22:29 <monochrom> I request cabal-install to keep a history of its installs and decisions. Then users can send it to you, you decipher it, and you can explain "on Tuesday you did this and it is why"
14:22:37 <dcoutts_> mornfall: but the problem is error messages. I don't know how to get good error messages when using the SAT approach.
14:22:46 <mornfall> dcoutts_: unsat core?
14:22:58 <mux> "The constraint A = NOT B failed"
14:23:09 <mux> I see the problem
14:23:17 <dcoutts_> mornfall: right, good ones give you that. Then you have to map back into the problem domain and construct an error message.
14:23:30 <mornfall> dcoutts_: Which shouldn't be *too* hard.
14:23:39 <monochrom> oh, yes, actually, why not just SMT-solver it? :)
14:23:43 <dcoutts_> mornfall: well I can't see how to do it
14:23:47 <mornfall> It's probably a fair bit less work than write an actual good solver anyway.
14:23:50 <monochrom> NPC problems are not that scary.
14:23:59 <mornfall> monochrom: SMT is blah. : - )
14:24:05 <mornfall> It keeps coming up though.
14:24:19 <dcoutts_> mornfall: perhaps someone else more familiar with SAT could do it. There's no guarantee the reverse mapping makes any sense.
14:24:32 <mornfall> Also, wasn't yices like, nonfree?
14:24:39 <ClaudiusMaximus> what other classes should i implement for a numeric type?   so far i have    Eq Floating Fractional Num Ord Show Storable
14:24:51 <dcoutts_> mornfall: and even then, how does one present a bunch of unsatisfiable constraints in a way that makes any kind of sense to users, in particular how they can fix things.
14:25:00 <mornfall> ClaudiusMaximus: Typeable, Data
14:25:07 <monochrom> well, there is a bit of "<=" number comparison in cabal, that is the only reason I say SMT. I really just mean SAT plus <=
14:25:22 <dcoutts_> my current plan is to write another solver directly
14:25:25 <mornfall> dcoutts_: About fixing things, that's tricky, but I don't think there's an actual package manager that does it right anyway.
14:25:31 <ddarius> ClaudiusMaximus: Probably Real.  Check the Report.
14:25:37 <ClaudiusMaximus> mornfall: ah, good call - i'll derive those
14:25:49 <mornfall> ClaudiusMaximus: It would be foolish to write them by hand. :)
14:25:49 <dcoutts_> mornfall: ah but there is! nix does it right
14:25:52 <ClaudiusMaximus> ddarius: good plan too
14:25:57 <mornfall> dcoutts_: Nix cheats. :)
14:26:08 <ClaudiusMaximus> @src Real
14:26:08 <lambdabot> class  (Num a, Ord a) => Real a  where
14:26:08 <lambdabot>     toRational      ::  a -> Rational
14:26:10 <dcoutts_> mornfall: isn't that the best kind of solution :-)
14:26:27 <mornfall> dcoutts_: Well, it doesn't exactly do what you mean either, in the end.
14:26:31 <ClaudiusMaximus> that one's kinda tricky...
14:26:35 <sid0> Oh well, looks like no one knowledgeable about DPH is here. :(
14:26:38 <dcoutts_> mornfall: hence my medium term plan to make cabal use the nix style of persistent package management. All these package breaking problems would go away.
14:26:48 <dcoutts_> mornfall: no?
14:26:51 <mornfall> dcoutts_: That certainly makes sense.
14:27:06 <ddarius> "<Cale> stepcut: You know a library is good when just reading about it removes the particular task it performs from your life altogether."
14:27:07 <mornfall> dcoutts_: Well, the catch with nix is that you still have to select some (consistent) set of packages to actually activate.
14:27:14 <adnap> Okay, I searched Hoogle for this: Bool -> (a -> a) -> a, but I didn't find the function that's: if b then f a else a.
14:27:15 <mornfall> dcoutts_: So it just moves the problem. :)
14:27:20 <dcoutts_> mornfall: right, we'd continue to use a constraint solver
14:27:58 <mux> adnap: conditional function application; I've wished for that long, but any way I wrote it, it ended up as ugly
14:28:19 <adnap> mux: What's wrong with how I wrote it?
14:28:21 <ClaudiusMaximus> wait, it isn't tricky at all for this particular type - forgot about the invariant that DD a b is semantically a + b
14:28:37 <mux> adnap: I haven't seen what you wrote
14:28:40 <monochrom> you may like (if b then f else id) a
14:28:58 <adnap> mux: \b f a -> if b then f a else a
14:29:03 <mux> monochrom: that's usually what I do nowadays, albeit with some variations
14:29:37 <monochrom> but I personally don't care about the assymetry. it should be (if b then f else g) a  in general.
14:30:03 <mux> adnap: my problem was not so much about how it was written than how the code using it ended up as
14:30:20 <monochrom> there is a lot of myth and overrated obsession about "if b then do such-and-such else do nothing". there is no such thing as "do nothing".
14:30:28 <cocoaiiiiiiiiiii> hey, i want to learn Haskell, i know C, and i already finished the try haskell page
14:30:34 <hpc> i personally like: (x ?? y) p = if p then x else y
14:30:39 <cocoaiiiiiiiiiii> so what books do you recommend?
14:30:51 <mornfall> dcoutts_: (Although for libraries, nix really wins, so it should be a win for cabal, too.)
14:31:03 <hpc> then condAp = (?? id)
14:31:06 <adnap> mux: I was thinking of using it like this: foo (notElem thing things) (thing:) things
14:31:32 <monochrom> I recommend http://www.vex.net/~trebla/haskell/learn-sources.xhtml
14:31:41 <stepkut> cocoaiiiiiiiiiii: http://book.realworldhaskell.org/read/, http://learnyouahaskell.com/
14:31:48 <mux> adnap: fine as long as you need it only once
14:31:51 <monochrom> or rather, I recommend whatever is recommended there
14:31:59 <hpc> learnyouahaskell++
14:32:07 <adnap> mux: I guess what I need is a freakin' set!
14:32:12 <cocoaiiiiiiiiiii> but what is the best book to start with?
14:32:25 <dcoutts_> mornfall: right, distros and deployments still want to use tighter constraints and traditional layouts, but for people hacking around with semi-stable unsynchronised packages then it should really help (if we can do it well)
14:32:50 <monochrom> the best book to start with is any book you take a glance and you decide "if this book were a girl, I want to marry her"
14:33:06 <stepkut> cocoaiiiiiiiiiii: try both of the ones that I linked to, and which ever keeps you interested the most -- that's the one
14:33:22 <monochrom> the best book over your whole life (as opposed to "to start with") is the third book you read.
14:33:53 <monochrom> but please don't extend that analogy to "which girl is the best girl over my whole life" :)
14:34:43 <monochrom> and pardon for my entrenched boy-girl bias
14:34:48 <Entroacceptor> oh, that would suck, she was too crazy
14:35:46 <cocoaiiiiiiiiiii> i need some exercices so, i think i will choose Real World Haskell
14:36:06 <magthe> I'm reading the documentation for System.Exit.exitWith, is there some way of *not* using Control.OldException to get to the exit code?
14:38:12 <Saizan> magthe: ExitCode is an instance of Exception, so you should be able to catch it with Control.Exception.catch
14:38:50 <Saizan> magthe: catch ... (\e -> case e of ExitSuccess -> ..; ExitFailure code -> ..)
14:39:21 <monochrom> I be damned if exit can be caught. Not even C and Java allow that.
14:39:26 <mux> any reason the automatically generated getDataFileName function from Paths_<pkg> is in IO?
14:40:15 <benmachine> monochrom: it's handy for e.g. all your finally clauses to run
14:40:20 <magthe> Saizan: so I can disregard all the mention of ExitException and match on `ExitFailure n` directly?
14:40:56 <Saizan> mux: iirc, it's because the data directory can be overridden at runtime with an ENV var, but you could check the code, it's in dist/build/autogen
14:41:02 <monochrom> the provision for overruling the exit altogether blows my mind
14:41:21 <benmachine> mux: looks like they can depend on environment variables; take a look at the module youreslf
14:41:26 <benmachine> *self
14:41:43 <benmachine> mux: i.e. exactly what Saizan said
14:41:44 <mux> Saizan: well, I did look at the code, and it's not using the environment for getDataFileName
14:41:55 <benmachine> mux: it uses getDataDir
14:41:55 <Saizan> magthe: you also have to consider the ExitSuccess case
14:41:56 <mux> oh, it is
14:41:58 <monochrom> main = catch user_code_here (\e -> putStrLn "you are trapped in the monad, bwhahahaha" >> main)
14:42:01 <mux> yes, my bad
14:42:04 <mux> thanks!
14:42:16 <benmachine> monochrom: foreign import unsafe _exit
14:42:27 <benmachine> (unsafe just for the hell of it)
14:43:16 <monochrom> main = catch user_code_here (\e -> putStrLn "your PC is stoned!" >> main)
14:43:33 <magthe> Saizan: yes, indeed, thanks
14:44:03 <Jafet> user_code_here = raiseSignal sigTERM
14:45:27 <monochrom> the signal provision may blow your mind in some other way. summary: implement a global mutable cell.
14:50:30 <wavewave> can I ask something about darcs here?
14:50:54 <wavewave> it seems that nobody is answering me in #darcs 
14:51:30 <benmachine> wavewave: you can try
14:51:38 <wavewave> I cannot get darcs repository via ssh 
14:51:43 <benmachine> (but I won't be able to answer, which is why I'm not in #darcs :P)
14:51:53 <wavewave> darcs failed:  Not a repository: servername:/home/username/directory ((scp) failed to fetch: servername:/home/username/directory/_darcs/inventory)
14:52:02 <wavewave> I have this error. 
14:52:10 <adnap> How can you have a set in Haskell where the elements aren't necessarily ordered?
14:52:11 <wavewave>  darcs tries to find a file "inventory" but I have only "inventories" in _darcs directory.
14:52:51 <benmachine> adnap: such a structure would be pretty inefficient
14:52:58 <benmachine> wavewave: maybe a version mismatch?
14:53:19 <adnap> benmachine: But what if my type is a member of Eq but not Ord?
14:53:22 <cocaoiiii> where i can get exercicies to solve in haskell?
14:53:39 <wavewave> both are darcs-2. 
14:53:53 <benmachine> adnap: then such a structure would be pretty inefficient :P you can maintain such sets yourself with nub on a list, I suppose
14:54:03 <wavewave> benmachine: anyway, if it's a version mismatch, what can I do?
14:54:06 <benmachine> cocaoiiii: what level?
14:54:08 <byorgey> wavewave: check the permissions on the files in _darcs, perhaps?
14:54:14 <benmachine> wavewave: I dunno, I don't know any darcs
14:54:18 <cocaoiiii> benmachine: beginner
14:54:24 <byorgey> wavewave: I've had errors similar to this before, and the error messages are rather misleading
14:54:31 <cocaoiiii> benmachine: to solve in a learning process
14:54:42 <benmachine> cocaoiiii: most tutorials come with exercises
14:55:00 <wavewave> byorgey: I check with --debug option
14:55:03 <cocaoiiii> benmachine: Learn you Haskell dont have exercices
14:55:17 <benmachine> cocaoiiii: it doesnt?
14:55:19 <benmachine> I'm surprised
14:55:24 <wavewave> byorgey: it really tried to get inventory not inventories. 
14:55:53 <byorgey> wavewave: yes, as I understand it tries that first
14:55:59 <cocaoiiii> benmachine: me to :P
14:56:05 <byorgey> wavewave: what are the permissions on the files in _darcs?
14:56:21 <benmachine> cocaoiiii: how far have you got?
14:56:22 <wavewave> my userid.. 
14:56:35 <byorgey> wavewave: are they world-readable?
14:56:43 <wavewave> byorgey: yes.
14:56:57 <byorgey> hmm
14:57:06 <byorgey> I don't know then
14:57:28 <cocaoiiii> benmachine: just finished the try haskell page, i am searching for a good book to start
14:57:39 <byorgey> wavewave: keep trying in #darcs, the people there are very friendly and helpful when they're around
14:58:23 <wavewave> byorgey: strange. I sudo darcs get.. then it works. 
14:58:43 <wavewave> byorgey: it's a permission problem though I don't know where . 
14:58:50 <byorgey> so maybe it's a problem with permissions on the local side.
14:58:59 <wavewave> byorgey: thanks. 
14:58:59 <benmachine> cocaoiiii: well, I used lyah, but you could try rwh if you want exercises
14:59:02 <benmachine> @where rwh
14:59:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:59:16 <byorgey> wavewave: weird, glad you got it to work though.
14:59:27 <byorgey> although you may now have a repository that is only readable by root.
14:59:44 <aristid> who is responsible for hackage.haskell.org?
15:00:02 <hinkes>  #haskell
15:00:13 <wavewave> byorgey: but I used this repository without any problem until very recently. 
15:00:25 <wavewave> byorgey: both are my computers. 
15:00:36 <wavewave> byorgey: local, server..
15:01:00 <wavewave> byorgey: anyway, I will try to find what caused this. 
15:01:08 <wavewave> byorgey: thnx again. 
15:01:12 <byorgey> sure.
15:04:08 <cocaoiiii> benmachine: i read in a StackOverflow that Real World Haskell start to quicly for someone i never code in a functional language before
15:04:47 <benmachine> cocaoiiii: opinions differ, I would give it a try
15:05:04 <Kruppe> cocaoiiii: I read it without any previous functional language experience
15:05:13 <Kruppe> cocaoiiii: seemed to go smoothly to me
15:05:16 <monochrom> you have finished tryhaskell. you can't say you never coded in FP anymore
15:05:22 <aristid> heh, xml (the package) has a rather forgiving parse
15:05:27 <monochrom> you have lost your innocence!
15:05:32 <aristid> it accepts "<root"
15:05:37 <cocaoiiii> lol
15:06:04 <cocaoiiii> i dont notice almost any different
15:11:41 <EvanR-work> aristid: i see html in xmls future
15:12:22 <aristid> EvanR-work: i guess the package would accept html just fine, as long as the tags nest properly :D
15:12:34 <EvanR-work> if only xml were that simple
15:12:55 <aristid> another fun fact: parseXML cannot fail.
15:13:00 <EvanR-work> lol
15:13:01 <aristid> there is no error condition
15:17:28 <pumpkin> ooh, new TH proposals
15:17:35 <ezyang> spj is awesome yo :-) 
15:17:36 <pumpkin> and completely different metaprogramming
15:18:45 <benmachine> pumpkin: where :O
15:19:05 <byorgey> ezyang: for reals =)
15:19:19 <benmachine> for integers.
15:19:23 <conal> earlier today we were talking about IO being Haskell's "sin bin" and so unlikely that it has a precisely definable and usable denotational model.  i found the reference (simon pj) and some remarks: http://conal.net/blog/posts/notions-of-purity-in-haskell/#comment-22829
15:19:28 <byorgey> for integers, yo
15:20:07 <tg_> lol
15:20:11 <tg_> i like that
15:20:15 <tg_> 'for integers, dawg.'
15:20:49 <tg_> Did anyone in here shed a little tear for the passing of Mandelbrot?
15:21:16 <sproingie> yes, and my tear shed two little tears of its own
15:21:27 <sipa> tg_: almost
15:22:49 <ddarius> "The big issue is this: Template Haskell is both too weakly typed and too strongly typed."
15:23:11 <adnap> mux: How's this? http://hpaste.org/paste/40689/got_rid_of_iorefs#p40695
15:30:02 <kmc> ddarius, true that
15:38:49 <astroboy> When using happy, is there a way I can pattern match the contents of a token
15:38:52 <astroboy> in the BNF
15:40:26 <wlangstroth> sproingie: only on #haskell would someone make a /good/ fractal joke
15:41:10 <mux> I guess a good fractal joke would be good at every level of understanding
15:42:45 <sipa> yes, and to really get it, you'd need to take a step back
15:44:17 <Axman6> doesn't change anything :(
15:45:04 <byorgey> major revelation of the day: passing -j4 to make when compiling GHC on a dual-core machine MAKES IT GO FASTER
15:45:09 <byorgey> duuuuhhhh
15:45:22 <kmc> hehe
15:45:38 <Zao> byorgey: I never dare use -j on a Makefile project unless explicitly told it's safe by current documentation.
15:45:54 <kmc> i'd be curious to know the ideal number for -j on your dual-core machine
15:45:59 <Zao> Nothing more fun than building gcc for hours with -jXX and have it break.
15:46:03 <kmc> for a while the folk wisdom was to use (# cores)+1
15:46:05 <byorgey> I'd be curious to know it too
15:46:15 <aristid> benchmark it
15:46:19 <kmc> ghc --make does not support parallelism, does it? ;/
15:46:24 <Zao> I tend to go with 2#+1 generally.
15:46:38 <byorgey> kmc: not yet.
15:47:26 <Axman6> Zao: i find that when things break, if you just run make without j until it's passed the thing that broke, and then go back to -jN, it works pretty well
15:47:29 <danharaj_> 1d6 + #
15:48:05 <byorgey> Zao: fair enough, but since at this point I'm just merging patches and then making sure the merged code compiles, so occasional breakage due to bad parallelism is worth the time savings
15:52:05 <bastl1> Is it ok to say that "IORefs break referential transparency" ?
15:52:29 <Zao> Axman6: Doesn't work with things that touch files to indicate stages and all.
15:52:34 <Zao> Like #@$@# GCC :D
15:52:41 <Axman6> heh
15:53:08 <byorgey> bastl1: no.
15:53:24 <dmwit> bastl1: It might be safer to say something like "reading an IORef is not referentially transparent".
15:53:52 <byorgey> IORefs are squirreled away in the IO monad, and I have no idea what referential transparency is supposed to mean once you are in the IO monad.
15:54:21 <dmwit> hah
15:54:37 <dmwit> You want to claim that readIORef is referentially transparent because it always returns the same IO action? =P
15:54:49 <dmwit> maybe so
15:54:50 <ezyang> dmwit: Hehe 
15:54:59 <byorgey> no
15:55:03 <bastl1> :-)
15:55:16 <byorgey> my point was they can't "break" RT because when dealing with IO there's no RT to break.
15:55:56 <bastl1> why do you think of dealing ith IO as being special ?
15:56:20 <dmwit> Well, it is. It's the only kind of value that's treated specially by the run-time system.
15:57:10 <bastl1> so you want to say that also "normal" IO-stuff is not referentially transparent ?
15:57:25 <bastl1> because, the terminal may be killed or so ?
15:58:02 <dmwit> Yes, I want to say that -- but not for the reason you gave.
15:58:12 <bastl1> ok, bad example :-)
15:58:27 <bastl1> i see.
15:59:28 <kmc> referential transparency is about whether an expression can be substituted for its evaluated value
15:59:35 <kmc> this property always holds in Haskell, even for values of IO type
15:59:39 <kmc> (unless you cheat)
16:00:08 <kmc> RT is about evaluation and substitution, not about execution
16:09:22 <jimi_hendrix> whats the best way to shuffle a list?
16:09:48 <Martty> close your eyes and smash your num pad 
16:10:29 <jimi_hendrix> lol
16:10:43 <jimi_hendrix> but then its not a function! (yes i know all randomosity needs io)
16:11:45 <sipa> @hoogle shuffle
16:11:45 <lambdabot> No results found
16:11:52 <gwern> jimi_hendrix: oleg's perfect shuffle is on hackage
16:12:23 <c_wraith> gwern: it's O(n log n).   You can do better with ST
16:12:43 <gwern> c_wraith: jimi_hendrix didn't ask about ST and arrays though, but lists
16:13:00 <c_wraith> gwern:  you can still shuffle a list in O(n) time with ST.
16:13:16 <gwern> c_wraith: have you written that code and shown it correct?
16:13:25 <c_wraith> yes
16:13:33 <gwern> great. then point jimi_hendrix at it
16:13:38 * hackagebot qd 0.1 - double-double and quad-double type via libqd  http://hackage.haskell.org/package/qd-0.1 (ClaudeHeilandAllen)
16:13:39 <c_wraith> I'd need to find it. :)
16:13:43 <gwern> -_-
16:13:45 <c_wraith> let me see.  I think it's on patch-tag
16:14:25 <wlangstroth> http://www.haskell.org/haskellwiki/Random_shuffle
16:15:21 <c_wraith> https://patch-tag.com/r/c_wraith/yomid/snapshot/current/content/pretty/src/Util.hs shuffle isn't the only thing in there.
16:15:24 <c_wraith> But it's in there.
16:16:02 <wlangstroth> naturally, jimi_hendrix will be mashing the num pad with his left hand
16:16:38 <jimi_hendrix> wlangstroth, i am right handed
16:17:03 <wlangstroth> your name is jimi_hendrix
16:17:13 <sipa> > 5 `div` 3
16:17:14 <lambdabot>   1
16:17:15 <gwern> an unfortunate cognomen
16:17:24 <jimi_hendrix> DAMNIT
16:17:42 <jimi_hendrix> i have been foiled
16:17:44 <sipa> > let { shuffle [] _ = []; shuffle r n = let p = n `mod` (length r) in (r!!p) : shuffle (take n r ++ drop (n+1) r) (n `div` (length r)) } in shuffle [1,2,3,4,5,6] (18421472448775477::Integer)
16:17:45 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:17:45 <lambdabot>         against inferred type ...
16:18:34 <jimi_hendrix> if it wasnt for you meddling kids and your damn dog i would have gotten away with it
16:18:50 <sipa> > let { shuffle [] _ = []; shuffle r n = let p = n `mod` (length r) in (r!!p) : shuffle (take p r ++ drop (p+1) r) (n `div` (length r)) } in shuffle [1,2,3,4,5,6] (18421472448775477::Integer)
16:18:51 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:18:51 <lambdabot>         against inferred type ...
16:19:57 <Axman6> sipa: take takes an Int, not an Integer
16:20:08 <sipa> yes, figured that :)
16:20:34 <Axman6> > maxBound :: Int
16:20:35 <lambdabot>   9223372036854775807
16:21:25 <sipa> > let { shuffle [] _ = []; shuffle r n = let p = fromInteger (n `mod` (toInteger $ length r)) in (r!!p) : shuffle (take p r ++ drop (p+1) r) (n `div`  (toInteger $ length r)) } in shuffle [1,2,3,4,5,6] 74854
16:21:26 <lambdabot>   [5,1,6,4,3,2]
16:21:40 <sipa> jimi_hendrix: good enough? ;)
16:21:43 <jimi_hendrix> sipa, ya
16:21:53 <jimi_hendrix> sipa, i am just going to steal that function from you
16:22:08 <sipa> the second argument is a random number between 0 and n!-1 
16:22:13 <jimi_hendrix> it would be nice if haskell had a built in shuffle function
16:22:33 <jimi_hendrix> sipa, thats the seed i assume
16:22:53 <sipa> not really a seed, just an identifier for the order
16:23:04 <sipa> > let { shuffle [] _ = []; shuffle r n = let p = fromInteger (n `mod` (toInteger $ length r)) in (r!!p) : shuffle (take p r ++ drop (p+1) r) (n `div`  (toInteger $ length r)) } in shuffle [1,2,3,4,5,6] 0
16:23:05 <lambdabot>   [1,2,3,4,5,6]
16:23:08 <sipa> > let { shuffle [] _ = []; shuffle r n = let p = fromInteger (n `mod` (toInteger $ length r)) in (r!!p) : shuffle (take p r ++ drop (p+1) r) (n `div`  (toInteger $ length r)) } in shuffle [1,2,3,4,5,6] 1
16:23:09 <lambdabot>   [2,1,3,4,5,6]
16:23:12 <sipa> > let { shuffle [] _ = []; shuffle r n = let p = fromInteger (n `mod` (toInteger $ length r)) in (r!!p) : shuffle (take p r ++ drop (p+1) r) (n `div`  (toInteger $ length r)) } in shuffle [1,2,3,4,5,6] 2
16:23:13 <lambdabot>   [3,1,2,4,5,6]
16:23:17 <sipa> and so on
16:24:03 <sipa> @pl \r n -> let p = fromInteger (n `mod` (toInteger $ length r)) in (r!!p) : shuffle (take p r ++ drop (p+1) r) (n `div`  (toInteger $ length r))
16:24:04 <lambdabot> ap (ap . ap ((.) . ap . ((:) .) . (!!)) (ap ((.) . flip . (shuffle .) . ap (ap . ((++) .) . flip take) (flip (drop . (1 +)))) (flip div . toInteger . length))) ((fromInteger .) . flip mod . toInteger
16:24:04 <lambdabot> . length)
16:24:13 <sipa> ieuw
16:36:56 <jimi_hendrix> sipa, i see
17:06:45 <jimi_hendrix> also, what function works like take but returns the elements that were not taken (e.g. foo 4 [1..10] would return [6..10])
17:07:01 <Cale> drop
17:07:19 <jimi_hendrix> ty
17:07:28 <ClaudiusMaximus> @src splitAt
17:07:28 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
17:08:45 <ddarius> :t \n -> uncurry (++) . splitAt n
17:08:46 <lambdabot> forall a. Int -> [a] -> [a]
17:14:33 <ddarius> edwardk: How did work go?
17:14:40 <Nafai> Hey all.
17:14:42 <Nafai> ltns
17:15:25 <byorgey> hey Nafai!
17:15:29 <byorgey> long time no see indeed.
17:20:55 * gwern is grimly amused. I'm three if-thens deep, and still not done
17:22:22 <Nafai> gwern: Whatcha writing?
17:22:28 * byorgey takes shelter behind a guard
17:26:07 <gwern> Nafai: a link rewriter for hakyll/pandoc
17:26:19 <gwern> hahah. my end result is pretty ugly
17:26:26 <gwern> but the tests pass
17:27:31 <gwern> Nafai: http://hpaste.org/40701/behold_the_nested_conditionals
17:27:49 <gwern> I'm sure I could prettify it, but I'm not sure my mind is up to thinking through de morgan's laws and whatnot
17:28:11 * Nafai looks
17:28:13 <gwern> wonder if hlint could rewrite it down to the ideal? hlint can be surprisingly intelligent
17:29:35 <ddarius> Write an applyhlint program then just hlint | applyhlint unto fixpoint.
17:29:55 <gwern> ddarius: I've suggested it to ndm. apparently hlint is not trustowrthy automated
17:30:07 <gwern> forget what the problem was. destroys comments?
17:30:32 <enthropy> and it doesn't teach at that point
17:31:13 <enthropy> gwern: newer haskell-src-exts parses comments though, but if you rearrange code the comments might not have a home
17:31:59 <gwern> now to have httrack download and look through my website to tell me whether I missed any link edge cases (again)
17:35:01 * ddarius tries to collect all the implicit constraints of his scheduler in his head so he can make use of them and, no doubt, add to them.
18:05:54 <wombatticus> For learning Haskell on Windows, is the Haskell Platform the preferred download?
18:06:02 <Axman6> yup
18:06:11 <wombatticus> ok, thx.  it seems really slick.
18:06:24 <wombatticus> WinGHCi, that is.
18:08:05 <joeyh> is there an easy way to catch all exceptions except for UserInterrupt? 
18:09:16 <dmwit> joeyh: I would say just catch all of them, and rethrow if it's a UserInterrupt.
18:10:02 <joeyh> well, that was my thought, but I got a type error between SomeException and AsyncException
18:10:30 <dmwit> I guess it's time to ask your real question, then. ;-)
18:11:27 <joeyh> well, how do I tell if Left err from try is a UserInterrupt?
18:13:46 <aristid> @hoogle try
18:13:46 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
18:13:47 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
18:13:47 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
18:14:18 <dmwit> ...by pattern matching?
18:14:35 <Axman6> @instances-importing Control.Exception Exception
18:14:35 <lambdabot> ArithException, ArrayException, AssertionFailed, AsyncException, BlockedIndefinitely, BlockedOnDeadMVar, Deadlock, ErrorCall, IOException, NestedAtomically, NoMethodError, NonTermination, PatternMatch
18:14:35 <lambdabot> Fail, RecConError, RecSelError, RecUpdError, SomeException
18:15:05 <joeyh> well, I did: Left UserInterrupt -> rethrow and got the abovermentioned type mismatch
18:15:21 <dmwit> You'd better post a bit more context.
18:15:22 <Axman6> @hoogle rethrow
18:15:22 <lambdabot> No results found
18:15:25 <dmwit> hpaste.org can help
18:15:29 <Axman6> @hoogle throw
18:15:30 <lambdabot> Control.Exception throw :: Exception e => e -> a
18:15:30 <lambdabot> Control.OldException throw :: Exception e => e -> a
18:15:30 <lambdabot> Control.Exception.Base throw :: Exception e => e -> a
18:17:17 <joeyh> r <- try a:: IO (Either SomeException (IO String))
18:17:17 <joeyh> case r of
18:17:17 <joeyh>         Left UserInterrupt -> error "interrupted"
18:17:18 <joeyh>         Left err -> putStrLn "ignoring other error"
18:17:18 <joeyh>         Right result -> foo
18:17:48 <dmwit> UserInterrupt is not a value of type SomeException.
18:17:58 <dmwit> perhaps you would like
18:18:00 <dmwit> :t cast
18:18:01 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
18:18:20 <dmwit> In particular, cast :: SomeException -> Maybe AsyncException
18:19:28 <dmwit> case either (Left . cast) Right r of Left (Just UserInterrupt) -> ...; Left _ -> ...; Right result -> ...
18:25:16 <joeyh> would handleJust be a more idiomatic way to deal with it?
18:25:28 <dmwit> Probably so!
18:26:07 <joeyh> ok.. I didn't want to rewrite my code as dealing with the typing around exception handling is still very painful for me, but good to know
18:26:48 <dmwit> :t \SomeException a -> (cast a :: Maybe AsyncException)
18:26:49 <lambdabot> Not in scope: data constructor `SomeException'
18:26:49 <lambdabot>     Not in scope: type constructor or class `AsyncException'
18:27:01 <dmwit> :t \Control.Exception.SomeException a -> (cast a :: Maybe Control.Exception.AsyncException)
18:27:01 <lambdabot>     Constructor `GHC.Exception.SomeException' should have 1 argument, but has been given 0
18:27:02 <lambdabot>     In the pattern: GHC.Exception.SomeException
18:27:02 <lambdabot>     In the expression:
18:27:08 <dmwit> oh right
18:27:13 <dmwit> :t \(Control.Exception.SomeException a) -> (cast a :: Maybe Control.Exception.AsyncException)
18:27:14 <lambdabot> GHC.Exception.SomeException -> Maybe GHC.IOBase.AsyncException
18:27:28 <orlandu63> why does `putStr "prompt" >> getLine` seem to execute in reverse order?
18:27:46 <dmwit> Okay, so my claim of (cast :: SomeException -> Maybe AsyncException) before was not quite right. So also my case statement above probably wasn't quite right.
18:27:55 <dankna> try putStr "prompt" >> hFlush stdout >> getLine
18:28:10 <orlandu63> does it have something to do with newlines? putStrLn works as intended
18:28:21 <Draconx|Laptop> orlandu63, yes.
18:28:22 <dmwit> orlandu63: Yes, it does. Newlines flush the output.
18:28:32 <dmwit> But you can flush manually, as dankna suggests.
18:28:45 <orlandu63> okay
18:29:31 <Saizan> dmwit: the right thing to do is to use fromException
18:29:56 <Axman6> > let a = not a in a :: Expr
18:29:57 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
18:29:57 <lambdabot>         against inferred ...
18:30:04 <Axman6> hmm, right
18:30:12 <dmwit> ?hoogle fromException
18:30:12 <lambdabot> Control.Exception fromException :: Exception e => SomeException -> Maybe e
18:30:12 <lambdabot> Control.Exception.Base fromException :: Exception e => SomeException -> Maybe e
18:30:13 <Axman6> > let a = 1+a in a :: Expr
18:30:14 <lambdabot>   1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (...
18:30:19 <dmwit> Oh, excellent.
18:30:21 <Axman6> > let a = a+1 in a :: Expr
18:30:25 <lambdabot>   mueval-core: Time limit exceeded
18:31:06 <dmwit> > let a = 1 * a in a :: Expr
18:31:09 <lambdabot>   1 * (1 * (1 * (1 * (1 * (1 * (1 * (1 * (1 * (1 * (1 * (1 * (1 * (1 * (1 * (...
18:35:34 <bing> hi folks, i'm collecting desktop video captures of free software development in action
18:36:12 <bing> can somebody please record 1 minute of video (with recordmydesktop) for me?  I'd like to see some haskell being programmed :-)
18:39:03 <dmwit> bing: http://www.youtube.com/watch?v=gVLFGQGRsDw ?
18:39:06 <dmwit> (not me)
18:39:13 <bing> i'm not looking for demos
18:39:19 <bing> www.asselstine.com/1000minutes
18:40:18 <Cleopatra> hi, can anyone tell me if theres any literature on how to crate a wave file in haskell, either mono or stereo. im looking for something like this http://efreedom.com/Question/1-3637350/Write-Stereo-Wav-Files-Python  just for haskell
18:42:18 <dmwit> bing: http://www.youtube.com/watch?v=eLS6GHXWMpA also hacking Haskell =)
18:42:28 <dmwit> (...also not me)
18:44:18 <bing> dmwit: man that second video is tiny
18:46:01 <ClaudiusMaximus> Cleopatra: http://haskell.org/haskellwiki/Hsndfile might be useful
18:46:46 <bing> dmwit: how about you make your own video.  it's easy :-)
18:47:29 <dmwit> And risk coding until the wee morning hours? ...maaaaybe =)
18:50:01 <ClaudiusMaximus> > let ps = randoms . read $ "blaargh" in sqrt . (4*) . length . filter (\(x,y) -> x*x + y*y < 1) $ take 1000 ps
18:50:02 <lambdabot>   No instance for (System.Random.Random (t, t))
18:50:03 <lambdabot>    arising from a use of `ps'...
18:50:46 <ClaudiusMaximus> > let { ps :: [(Double, Double)] ; ps = randoms . read $ "blaargh" } in sqrt . (4*) . length . filter (\(x,y) -> x*x + y*y < 1) $ take 1000 ps
18:50:47 <lambdabot>   No instance for (System.Random.Random
18:50:47 <lambdabot>                     (GHC.Types.Double...
18:51:23 <ClaudiusMaximus> > let { ps = randoms . read $ "blaargh" ; qs = randoms . read $ "uuurgh" } in sqrt . (4*) . length . filter (\(x,y) -> x*x + y*y < 1) $ take 1000 (zip ps qs)
18:51:24 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
18:51:24 <lambdabot>    arising from a use of...
18:51:36 <ClaudiusMaximus> > let { ps = randoms . read $ "blaargh" ; qs = randoms . read $ "uuurgh" } in sqrt . (4*) . fromIntegral . length . filter (\(x,y) -> x*x + y*y < 1) $ take 1000 (zip ps qs)
18:51:38 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:51:38 <lambdabot>    `System.Random.RandomGen...
18:53:07 <ClaudiusMaximus> > let { ps = randoms (read "blaargh" :: StdGen) ; qs = randoms (read "uuurgh" :: StdGen) } in (\n -> sqrt . (* (4 / fromIntegral n)) . fromIntegral . length . filter (\(x,y) -> x*x + y*y < 1) $ take n (zip ps qs)) 1000
18:53:11 <lambdabot>   mueval-core: Time limit exceeded
18:53:25 <ClaudiusMaximus> > let { ps = randoms (read "blaargh" :: StdGen) ; qs = randoms (read "uuurgh" :: StdGen) } in (\n -> sqrt . (* (4 / fromIntegral n)) . fromIntegral . length . filter (\(x,y) -> x*x + y*y < 1) $ take n (zip ps qs)) 100
18:53:26 <lambdabot>   *Exception: Prelude.read: no parse
18:54:48 <ClaudiusMaximus> > let { ps = randoms (mkStdGen 124124) ; qs = randoms (mkStdGen 1351248) } in (\n -> sqrt . (* (4 / fromIntegral n)) . fromIntegral . length . filter (\(x,y) -> x*x + y*y < 1) $ take n (zip ps qs)) 100
18:54:49 <lambdabot>   0.0
18:55:23 <ClaudiusMaximus> > let { ps = randoms (mkStdGen 124124) ; qs = randoms (mkStdGen 1351248) :: [Double]} in (\n -> sqrt . (* (4 / fromIntegral n)) . fromIntegral . length . filter (\(x,y) -> x*x + y*y < 1) $ take n (zip ps qs)) 100
18:55:24 <lambdabot>   1.833030277982336
18:55:51 <ClaudiusMaximus> > let { ps = randoms (mkStdGen 124124) ; qs = randoms (mkStdGen 1351248) :: [Double]} in (\n -> sqrt . (* (2 / fromIntegral n)) . fromIntegral . length . filter (\(x,y) -> x*x + y*y < 1) $ take n (zip ps qs)) 1000
18:55:52 <lambdabot>   1.2521980673998823
18:56:05 <Axman6> > 1.2521980673998823 * 4
18:56:06 <lambdabot>   5.008792269599529
18:57:08 <ClaudiusMaximus> > let { ps = randoms (mkStdGen 124124) ; qs = randoms (mkStdGen 1351248) :: [Double]} in (\n -> (* (4 / fromIntegral n)) . fromIntegral . length . filter (\(x,y) -> x*x + y*y < 1) $ take n (zip ps qs)) 10000
18:57:09 <lambdabot>   3.1468000000000003
18:57:14 <ClaudiusMaximus> \o/
18:57:29 <roconnor> > pi :: CReal
18:57:30 <lambdabot>   3.1415926535897932384626433832795028841972
18:58:25 <ClaudiusMaximus> strange that StdGen's 'read' doesn't seem to live up to its documentation
18:58:44 <Cleopatra> thanks
19:00:15 <dmwit> ClaudiusMaximus: Yes, conal asked about this recently.
19:00:27 <jmcarthur> i think it was conor, not conal
19:00:32 <dmwit> ClaudiusMaximus: Clip the thing you're trying to read to at most six characters.
19:00:37 <dmwit> err... it might have been
19:00:54 <dmwit> ClaudiusMaximus: In any case, reads lives up to the documentation, but... read demands that you consume the whole string. =)
19:01:07 <ClaudiusMaximus> > read "foo" :: StdGen
19:01:08 <lambdabot>   1390 1
19:01:13 <Cleopatra> ClaudiusMaximus: http://haskell.org/haskellwiki/Hsnd doesnt seem tohave any information..
19:01:47 <jmcarthur> > read "foobar" :: StdGen
19:01:48 <lambdabot>   38791 1
19:01:50 <jmcarthur> > read "foobar!" :: StdGen
19:01:51 <lambdabot>   *Exception: Prelude.read: no parse
19:01:53 <ClaudiusMaximus> Cleopatra: that's not the link i pasted - it's Hsndfile
19:02:06 <dmwit> > reads "foobar!" :: [(StdGen, String)]
19:02:07 <lambdabot>   [(38791 1,"!")]
19:02:55 <Cleopatra> my bad :s
19:03:59 <ClaudiusMaximus> Cleopatra: no worries - this is probably the function you're looking for: http://hackage.haskell.org/packages/archive/hsndfile/latest/doc/html/Sound-File-Sndfile.html#v:writeFile
19:05:54 <ClaudiusMaximus> Cleopatra: also: http://hackage.haskell.org/packages/archive/hsndfile-vector/0.4.0/doc/html/src/Sound-File-Sndfile-Buffer-Vector-Examples.html#normalizeSoundFile
19:09:44 <drhodes> can ghc emit object files that are statically linkable by gcc? 
19:14:16 <Cleopatra> ClaudiusMaximus: this is good thanks. i also came across http://hackage.haskell.org/packages/archive/WAVE/0.1.1/doc/html/Data-WAVE.html im guessing these are similar packages..
19:19:35 <joeyh> hmm, I had thought that catching SomeException caught sigint, but that does not seem to be the case
19:31:13 <monochrom> signals are much more sinister :)
19:36:54 <joeyh> problem I'm trying to debug is that when I press ctrl-c, my program's main process dies, but it leaves a child process running doing work. since I didn't set these processes up, I don't understand why
19:43:21 <joeyh> although, if I loose the exception handling, this behavior doesn't happen..
19:44:54 <davekong> Can anyone point me to a good program to learn from written using hscurses?
19:47:33 <dmwit> davekong: http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/hscurses-1.3.0.2#direct ?
19:48:00 <monochrom> actually I now recall that catching SomeException includes catching sigint.
19:49:13 <monochrom> however, the exception is delivered to one thread only, the other threads will be ignorant of it. I forgot which thread, or whether it is determined at all.
19:50:28 <monochrom> the exact type of exception is AsyncException. the value is UserInterrupt
19:50:59 <joeyh> monochrom: these threads could appear as fullfledged os processes?
19:51:11 <monochrom> no
19:51:20 <joeyh> hmm, well, I see 2 real processes
19:51:28 <davekong> dmwit: thanks
19:51:39 <monochrom> ah, it says delivered to "the main thread of the program"
19:52:04 <monochrom> threads may be "green threads" and usually are. but not always.
19:52:50 <monochrom> if you spawn a child process, that's totally another story.
19:53:27 <joeyh> well, I am spawning shell commands, perhaps that's where the other process comes from? I see 3 total, including the running shell command
19:55:06 <joeyh> yeah, looks like parent process is seeing the sigint, and the child is just .. not
19:57:30 <tolkad> what if haskell had perl-like forking?
19:59:05 <dmwit> Can you elaborate? What's perl-like forking?
19:59:06 <byorgey> what is perl forking like?
19:59:06 <Maxdamantus> Can't you do an actual UNIX-like fork on Windows, using some hidden API or something?
19:59:09 <maurer_> An OCamlish friend of mine has complained about Haskell not having Functors (in the OCaml/SML sense). Everything I can seem to think of typeclasses work for, but does anyone have an example of where such a thing would be useful?
19:59:23 <Maxdamantus> It lets you fork on Windows, by copying everything to the new process.
19:59:34 <Maxdamantus> afaik
20:00:15 <byorgey> maurer_: IIRC it has been shown that OCaml functors and type classes are inter-encodable
20:00:26 <byorgey> but some things are much easier to express using one or the other
20:01:13 <dmwit> Huh, I thought it's also been shown that type-checking in the presence of functors is undecidable. Does that contradict the possibility of inter-encoding?
20:01:20 <dolio> http://augustss.blogspot.com/2008/12/somewhat-failed-adventure-in-haskell.html
20:01:42 <maurer_> Technically, anything is interencodable via the fact that both are turing complete, but I think I get your meaning?
20:02:23 <dolio> I don't think that's what Turing complete means. :)
20:02:34 <byorgey> dmwit: hmm, not sure.
20:03:08 <Maxdamantus> Turing completeness deals with computation.
20:03:24 <byorgey> "Modular Type Classes" by Dreyer et al is the paper I'm thinking of
20:04:09 <tolkad> dolio: well, in a way it makes sense
20:04:29 <dolio> Oleg has a demonstration of the correspondence, too, although I don't think it's something you'd want to do in practice.
20:04:33 <byorgey> also "ML Modules and Haskell Type Classes: A Constructive Comparison" by Wehr and Chakravarty
20:04:59 <dolio> You can search his stuff for "applicative translucent functors".
20:05:51 <dmwit> translucent functors
20:05:56 <dmwit> Well, it's a name, I guess. =P
20:06:12 <dolio> tolkad: It makes sense in that you could write an interpreter with the language features you want. But that's very weak.
20:06:18 <tolkad> dolio: it's possible to simulate any turing complete language in any other, so what he is saying is true, but when people are say inter-encodable, I think they mean sanely, perhaps at compile time?
20:06:58 <tolkad> sorry, don't know OCaml
20:07:18 <dolio> Yes, "inter-encodable" here means there's a relatively sane syntactic translation between the two.
20:08:24 <dolio> OCaml modules have signatures, structures, and functors, which are like module types, values and functions respectively.
20:08:32 <dolio> And structures can have names.
20:08:45 <tolkad> dolio: is whether a particular syntactic translation sane computable?
20:09:17 <dolio> Signatures correspond to classes, and structures correspond to instances.
20:09:40 <dolio> In Oleg's construction, you name your instances by doing something like "data Name" and adding a parameter to the class.
20:09:45 <tolkad> that would be an example of a syntactic translation.
20:09:53 <dmwit> tolkad: Yes, since humans do it. But "computable" and "I can write a program that computes it" are very different. ;-)
20:10:22 <dolio> I haven't studied it enough to know how he gets functors. But he does it somehow, I guess, since that's the title of his article.
20:12:34 <tolkad> dmwit: You know what's terrible about python? They say "There should be one-- and preferably only one --obvious way to do it." but that means that obviousness isn't computable.
20:13:54 <dmwit> Does it?
20:14:03 <dmwit> Perhaps the subset of "obvious Python" is not Turing complete.
20:14:43 <dmwit> I guess the "There should be one" clause precludes that.
20:14:57 <dmwit> so... cute, I like your joke =)
20:18:52 <tolkad> It would be cool if you could write instances for partially applied type synonyms
20:19:01 <tolkad> especially combined with type families
20:19:11 <dmwit> Isn't there an extension for that?
20:19:17 <tolkad> no
20:19:18 <dmwit> FlexibleInstances or something like that?
20:19:21 <tolkad> only fully applied
20:20:05 <finlayt> hello, looking for some help with a cabal problem
20:20:23 <tolkad> finlayt: what is the problem?
20:20:29 <finlayt> hi, thanks
20:20:43 <finlayt> I keep getting this error: cabal: Codec.Compression.Zlib: incorrect header check
20:21:07 <finlayt> I get it on "cabal update" and on "cabal install"
20:21:11 <lispy> hmm...haskellers.com has an entry for screen names, but I can't find IRC in the list.  I just see XMPP (whatever that is), Twitter (whatever that is), and AIM (who uses aim?)
20:21:26 <camio> Does anyone know of a fundamental limitation of Haskell that would prevent a compiler from using destructive update on a term like let x = listArray... in x // [(2,13)]?
20:21:43 <tolkad> finlayt: it looks like there's an unresolved ticket for it: http://hackage.haskell.org/trac/hackage/ticket/686
20:21:49 <finlayt> yeah, thats it
20:22:00 <finlayt> looking for a short term work around
20:22:26 <finlayt> thought I could manually reinstall cabal or something...
20:22:36 <jmcarthur> camio: have you tried using the vector library? i bet it would fuse it properly
20:23:27 <tolkad> finlayt: You seen this? http://hackage.haskell.org/trac/hackage/ticket/651
20:23:41 <dmwit> camio: No, I don't think there's a fundamental limitation that prevents pure computations from being done at compile-time. But this is often undesirable.
20:23:42 <jmcarthur> camio: even if it doesn't, i don't think there is any theoretical reason that it would be impossible
20:23:50 <tolkad> finlayt: also also http://osdir.com/ml/cabal-devel@haskell.org/2010-01/msg00000.html
20:24:03 <tolkad> finlayt: check what files it's requesting
20:24:04 <jmcarthur> dmwit: i don't think camio was asking about precomputation
20:24:18 <tolkad> finlayt: attempt the requests manually to make sure they are working
20:24:29 <jmcarthur> dmwit: i think camio was asking about whether it would be possible for the (//) to be fused into the array construction somehow
20:24:43 <dmwit> Is that not precomputation?
20:25:02 <jmcarthur> only if the array construction is precomputation, which is not necessarily
20:25:20 <dmwit> Ah, I see the distinction.
20:25:35 <finlayt> tolkad: I noticed those discussions
20:26:05 <finlayt> I think the problem is something to do with the second one, although Im using a proxy ( don't think )
20:26:25 <finlayt> the downloaded file is a gunzipped
20:26:46 * finlayt will be right back
20:27:00 <tolkad> finlayt: well, try renaming it to a txt and opening it
20:27:03 * lispy can't tell what finlayt means.  Is finlayt using a proxy or not?
20:27:11 <tolkad> finlayt: maybe it just contains some HTTP error message
20:27:45 <tolkad> lispy: he IS using a proxy but he wants us to all immediately cease engaging in thought.
20:37:32 <camio> Thanks all for the responses. I had to step out for a moment.
20:37:43 <finlayt> sorry
20:37:44 <lispy> tolkad: ah, I did read it that way and it seemed odd
20:37:46 <finlayt> back again
20:38:33 <finlayt> oops, what I meant to say was that Im *not* using a proxy
20:38:41 <finlayt> that I know off
20:41:50 <finlayt> tolkad: cabal update gets 00-index.tar.gz 
20:44:16 <ddarius> tolkad hasn't been here for the last two comments made to him.
20:44:34 <djahandarie> Last three*
20:44:43 <joeyh> oh wow, my backgrounded process problem seems to have to do with something git does to the environment when running subcommands
20:44:45 <finlayt> ddarius: I see that
20:46:37 <finlayt> anyone else using cabal on ubuntu lucid
20:46:40 <finlayt> ?
20:51:39 <byorgey> finlayt: have you tried asking in #hackage ?
20:51:45 <finlayt> oh, no
20:51:49 <finlayt> thats a good idea
20:52:02 <byorgey> you might have to wait a while for an answer, but the people who are likely to know the answer hang out in there
20:53:44 <lispy> ddarius: Some people read the logs.  so I tend to address them even if they leave, just in case.  If it's really important I use ?tell though.
21:10:04 <monochrom> I use cabal and cabal-install on ubuntu lucid
21:12:02 <monochrom> it works 100% of the time for me. and yes, I know it's just me on this.
21:12:24 <monochrom> all software works 100% of the time for me.
21:18:11 <finlayt> monochrom: lucky you
21:18:20 <finlayt> I wish it worked 100% of the time for me
21:18:27 <finlayt> anyway, got to go home
21:18:30 <finlayt> later
21:21:55 <lispy> byorgey: there is a #hackage channel now?
21:22:19 <byorgey> there is
21:29:01 <joeyh> aha, so my problem turns out to be that rawSystem blocks SIGINT
21:30:03 <joeyh> how can I run a shell command and then check if it died due to a signal? rawSystem returns just an ExitCode, which lacks that information
21:30:14 <zzing> I am trying to build yi, but I wanted a vty version (using: cabal install yi -fvty) yet it is trying to use gtk, gconf, pango, etc. Any ideas if there is anything else I can do?
21:33:34 <byorgey> zzing: try cabal install yi -f "vty -pango -cocoa -gnome"
21:33:44 <byorgey> to explicitly turn off the interfaces you don't want
21:34:24 <zzing> When I try to install this it also seems to want to recompile most dependencies too.
21:39:10 <zzing> http://www.pastebin.ca/1966550   Another error about a recursive dependency
21:45:38 <tommd> using parallel, "using xs (evalList rseq)" will stack overflow when xs is large (say, 4M elements).  This seems to be because evalList = evalTraversable = traverse and it builds a stack of cons cells.
21:45:38 <tommd> Given that, shouldn't the majority of users use "rnf" from "instance NFData [a]" in the DeepSeq package?  Very rarely do you want the whole list forced at once, typically you want each entry forced before evaluation of the next cell.
21:45:39 <tommd> Also, is there a common fix for the evalList issue?
22:02:25 <zzing> Does anyone know if there exists any simple examples of multimode programs using cmdargs? It looks more complicated than I would like at first glance.
22:06:04 <dschoepe> zzing: Did you see the one from here? http://community.haskell.org/~ndm/darcs/cmdargs/cmdargs.htm
22:06:58 <zzing> Nope, but I think it is what I probably need
22:06:59 <zzing> Thank you
22:10:22 <amibacha> PLS CAN SOMEONE HELP ME WITH SMTP
22:10:26 <amibacha> PLS CAN SOMEONE HELP ME WITH SMTP
22:10:47 <lispy> amibacha: perhaps.  What seems to be the problem?
22:11:22 <amibacha> i need SMTp
22:11:37 <amibacha> or SSH
22:11:48 <lispy> amibacha: I gathered, but in what form? You need an SMTP library?
22:12:03 <amibacha> yh
22:12:47 <amibacha> lispy : can u help me out
22:15:31 <Axman6> you're new to IRC aren't you
22:16:09 <amibacha> nope
22:16:16 <amibacha> but i am new to this server
22:16:28 <amibacha> axman6
22:16:30 <Axman6> i'd hate to see what the servers you're used to are like
22:17:22 <mjrosenb> amibacha: http://www.qdb.us/104056
22:17:33 <amibacha> axman6: pls i am not here to rattle words
22:17:44 <amibacha> pls help me if u can
22:17:58 <Axman6> mjrosenb: heh
22:18:11 <tommd> amibacha: On _this_ server it is customary to 1) Not use caps 2) Not repeat the question in such spam-like manner 3) be patient 4) Be descriptive, you haven't said what you need , an SMTP library in Haskell?
22:18:17 <Axman6> amibacha: how on earth do you expect anyone to help you without telling us what you want?
22:18:33 <Axman6> amibacha: can you help me with the problem i have? i really need help
22:18:59 <Axman6> the problem involves computers, do you know the answer?
22:19:26 * mjrosenb also appreciates it when people use english be it more colorful or colourful.
22:19:38 <monochrom> can you help me? I don't know how to describe my problem.
22:20:01 <Axman6> amibacha: well? what do you wangt?
22:20:03 <Axman6> -g
22:20:03 <tommd> monochrom: First you meet me in person at the Green Dragon and buy me a beer.  We'll go from there.
22:20:13 <tommd> ;-)
22:20:38 <monochrom> I indeed have a stuffed green dragon bought from ikea.
22:20:50 <monochrom> Drake!
22:21:48 <Axman6> hmm, maybe i'm doing it wrong
22:21:55 <Axman6> amibacha: HELLO? R U THER?
22:22:13 <amibacha> axman : yes i am here
22:22:22 <tommd> lol
22:22:22 <Axman6> ha, i worked
22:22:30 <monochrom> narcistic people make you promise to help before they disclose their oh-so-NDA question.
22:22:51 <Axman6> amibacha: CAN YOU PLEASE TELL US WHAT YOU WANT????/?/???
22:23:05 <monochrom> in fact they will make you use pm
22:23:07 <kwuxalot> is hPutStrLn atomic, or is it possible for another thread to print garbage in the middle?
22:23:30 <tommd> #haskell, where the newbies get heckled until the produce a question.
22:23:35 <tommd> s/the/they
22:23:54 <tommd> kwuxalot: Garbage is possible.
22:23:54 <amibacha> i told u before ,i need smtp of ssh (source shell hosting )
22:24:10 <tommd> Axman6: Don't bother, he's just a troll.
22:24:32 <Axman6> amibacha: no, you didn't tell us that at all
22:24:36 --- mode: ChanServ set +o jmcarthur
22:24:52 * Axman6 senses a ban coming
22:25:06 <jmcarthur> amibacha: you did this earlier today too. we toyed with you and gave you your fun
22:25:39 <kwuxalot> is there a function in the standard library that's equivalent to `mkdir -p`?
22:25:51 <monochrom> no
22:26:03 --- mode: jmcarthur set +q *!*@41.220.68.10
22:26:06 --- mode: jmcarthur set -o jmcarthur
22:26:57 <mjrosenb> kwuxalot: i suspect that it is a one-liner though :)
22:27:27 <monochrom> not that easy
22:28:15 <tommd> kwuxalot: createDirectoryIfMissing
22:28:19 <tommd> @hoogle createDirectoryIfMissing
22:28:20 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
22:28:28 <tommd> Learn hoogle, use hoogle, love hoogle.
22:28:44 <tommd> If everyone did then I predict a 30% drop in Haskell questions on the interwebs.
22:28:57 <monochrom> I be damned.
22:29:10 <tommd> :t createDirectoryIfMissing True
22:29:11 <lambdabot> Not in scope: `createDirectoryIfMissing'
22:29:16 <tommd> dumb bot
22:29:21 <lispy> ?hoogle tommd
22:29:22 <lambdabot> No results found
22:29:23 <kwuxalot> tommd: thanks :)
22:29:31 <lispy> ?hoogle hoogle
22:29:31 <lambdabot> Can't think of anything more interesting to search for?
22:29:31 <lambdabot> No results found
22:29:40 <tommd> ?go tommd
22:29:40 <lambdabot> Maybe you meant: google googleit do
22:29:44 <tommd> ?google tommd
22:29:46 <lambdabot> http://tommd.wordpress.com/
22:29:46 <lambdabot> Title: Beware the Jabberwolk
22:29:48 <tommd> yay
22:30:04 <lispy> ?. hoogle google tommd
22:30:05 <lambdabot> Parse error:
22:30:05 <lambdabot>   --count=20 "http://tommd.wordpress.com/
22:30:05 <lambdabot> Title: Beware the Jabberwolk
22:30:18 <monochrom> @do tommd
22:30:19 <lambdabot> tommd
22:30:26 <lispy> ?pl tommd
22:30:27 <lambdabot> tommd
22:30:27 <tommd> What is "do"
22:30:37 <lispy> ?free tommd
22:30:38 <monochrom> @do tommd >>= me
22:30:38 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `tommd'\n\n"
22:30:38 <lambdabot> do { a <- tommd; me a}
22:30:46 <lispy> ?djinn tommd
22:30:47 <lambdabot> -- f cannot be realized.
22:30:47 <tommd> ah, I see.
22:31:11 <lispy> ?quote tommd
22:31:12 <lambdabot> No quotes match. I am sorry.
22:31:18 <tommd> ?quote TomMD
22:31:18 <lambdabot> TomMD says: c.h.o should move to ARM... then a distributed system would be needed.
22:32:00 <tommd> Me advocating c.h.o move to a decentralized, DHT driven network of servers.
22:32:32 <monochrom> cloud.haskell.org
22:32:48 <tommd> That doesn't need moved, simply instantiated.
22:34:34 <monochrom> every cloud has a silverlining. http://despair.com/pes24x30prin.html
22:38:45 <mjrosenb> tommd: "need moved"?
22:39:00 <mjrosenb> tommd: wouldn't happen to be from pittsburgh?
22:39:30 <tommd> nope
22:39:38 <tommd> been there once for about 3 days though.
22:39:51 <tommd> Guess the lingo just rubbed off on me that quick, y'all.
22:42:02 <mjrosenb> tommd: http://en.wikipedia.org/wiki/Pittsburgh_English#Grammar
23:14:47 <mayahustle> Hi, I'm trying to learn about Arrows in Haskell, I'm having issues understanding the return type of the left function in the ArrowChoice typeclass... can someone here clarify for me? your help is greatly appreciated
23:15:50 <codolio> @type left
23:15:51 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
23:16:22 <mayahustle> why is the return type contain two Either types?
23:16:28 <codolio> (b ~> c) -> (Either b d) ~> Either c d
23:17:18 <codolio> It's the arrow generalization of 'left f (Left x) = Left (f x) ; left f (Right y) = Right y'
23:22:21 <mayahustle> So in the original definition, 'a b c', when operating in an ArrowChoice context, both b and c will have to be Either types?
23:22:40 <Psytonic> hey, how do i do the cubic root of a number?
23:23:05 <codolio> No.
23:23:28 <MasseR> Anyone experienced with hgettext? Unicode symbols don't work right when received from gettext. Unicode symbols from haskell source work ok
23:23:29 <mayahustle> argh.. and it starts again... there's somethign I'm missing and I can't seem to place my finger on it
23:23:31 <codolio> It takes an arrow from bs to cs, and returns an arrow from (Either b d)s to (Either c d)s.
23:24:34 <Ytinasni> mayahustle: using the (->) arrow, left's type is (b -> c) -> (Either b d -> Either c d)
23:25:00 <Ytinasni> the way i parenthesized should help explain.
23:25:30 <Psytonic> anyone?
23:25:47 <codolio> If you mean in Haskell, I don't think there's a cube root function.
23:26:10 <Ytinasni> Psytonic: use x ** (1/3)
23:26:24 <codolio> Oh yeah, geeze.
23:26:24 <Psytonic> Ytinasni: ta
23:26:35 <smorg> lol algebra
23:26:48 <Psytonic> I'm suprised x^(1/3) doesnt work
23:26:58 <Psytonic> you'd think it would in a language like haskell
23:27:07 <dolio> ^ is for rings, essentially.
23:27:23 <smorg> ** isn't that uncommon. Same in Python
23:27:27 <Psytonic> come again?
23:27:45 <Psytonic> for rings?
23:27:48 <dolio> ^^ is a field exponentiation.
23:28:06 <dolio> (^) assumes that only multiplication is available. Not division.
23:28:19 <dolio> (^^) uses division.
23:28:21 <Axman6> :t (^)
23:28:22 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
23:28:24 <Psytonic> i see
23:28:36 <Ytinasni> dolio: not true; a^(-1) uses division.
23:28:48 <dolio> a^(-1) is an error.
23:28:56 <Psytonic> its true
23:28:59 <Axman6> > 3^(-1)
23:29:01 <lambdabot>   *Exception: Negative exponent
23:29:07 <Axman6> @stc (^)
23:29:08 <lambdabot> x ^ 0            =  1
23:29:08 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
23:29:08 <lambdabot>   where f _ 0 y = y
23:29:08 <lambdabot>         f x n y = g x n
23:29:08 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
23:29:10 <lambdabot>                       | otherwise = f x (n-1) (x*y)
23:29:10 <Axman6> @stc (^^)
23:29:12 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
23:29:14 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
23:29:14 <Ytinasni> oops, using the wrong prelude :D
23:29:21 <Axman6> @stc (**)
23:29:21 <lambdabot> Source not found. That's something I cannot allow to happen.
23:29:28 <Psytonic> lmao
23:29:38 <dolio> And (**) is weird real number magic stuff.
23:29:46 <Psytonic> fair enough
23:29:46 <Axman6> yeah
23:29:47 <Psytonic> thanks guys
23:30:03 <Axman6> Psytonic: (^) is there to do exponentiation quickly (log n time)
23:31:24 <Psytonic> axman6: pfft
23:31:27 <Psytonic> should still work
23:31:33 <Psytonic> simple guard would do it
23:31:36 <Axman6> not if you want efficiency
23:31:59 <Axman6> well no, the reason (^) can work the way it does is because it needs integral powers
23:32:07 <Saizan> ?type (^)
23:32:08 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
23:32:18 <Axman6> it couldn't work as well if you were allowed to write x^2.5
23:32:31 <Saizan> ?type ((**), (^^))
23:32:32 <lambdabot> forall a a1 b. (Floating a, Fractional a1, Integral b) => (a -> a -> a, a1 -> b -> a1)
23:32:37 <Psytonic> a check for an integer cant be too bad
23:33:01 <Saizan> on the other hand, (^) is the only one that works for just Num
23:33:09 <Psytonic> true
23:33:14 <Axman6> there is a check for an integral value, it's enforced by the type
23:33:26 <Saizan> so it's not just efficiency
23:33:33 <Axman6> aye
23:34:46 <Axman6> Psytonic: i assume you're new to haskell? not used to the static typing?
23:35:25 <Psytonic> newish, I've done a haskell course
23:35:30 <Psytonic> but no practical usage
23:35:44 <Psytonic> I'm coding up an engineering problem atm :)
23:39:51 <path[l]> what's a ring?
23:40:58 <mjrosenb> path[l]: a group with multiplication.
23:41:32 <c_wraith> mjrosenb, given that there are multiplicative groups, that's not the greatest definition. :)
23:41:52 <mjrosenb> c_wraith: shush you.
23:42:19 <mjrosenb> it is an algebraic structure with addition, multiplication, addition has an inverse, and both have identies
23:42:24 <mjrosenb> c_wraith: happy?
23:42:39 <c_wraith> better. :P
23:42:59 <c_wraith> But you should probably say something about associativity :P
23:43:07 <c_wraith> (or not, I'm just being a jerk)
23:43:13 <pelotom> don't forget multiplication distributes over addition!
23:43:43 <path[l]> ah got it
23:43:46 <mjrosenb> and they are commutative
23:44:03 <path[l]> so if you can define a set and those operation, you have a ring?
23:44:09 <c_wraith> yes
23:44:32 <pelotom> only the addition is necessarily commutative, I think
23:44:46 <path[l]> got it
23:44:57 <pelotom> or something
23:45:03 <c_wraith> amusingly, I'm pretty sure that all the ring laws hold with a singleton set, and both operators defined the necessary way.
23:45:10 <mjrosenb> pelotom: i think there are commutative and non-commutative rings.
23:45:22 <mjrosenb> c_wraith: iirc, 0/=1
23:45:36 <c_wraith> oh, boo.  that ruins *everything*! :)
23:45:41 <Samantha> Hello
23:45:53 <dolio> No. 0 = 1 is fine for a ring.
23:46:02 <Samantha> is this the haskell channel
23:46:04 <mjrosenb> nevermind then.
23:46:05 <Samantha> ??
23:46:09 <pelotom> mjrosenb: right, addition is commutative in both, multiplication is only commutative in a commutative ring
23:46:20 <path[l]> Samantha yes it is, welcome to irc
23:46:22 <dolio> It's typically disallowed for fields, though.
23:46:24 <mjrosenb> Samantha: this channel is a tribute to haskell curry.
23:46:38 <mjrosenb> in a rather roundabout way.
23:46:43 <Samantha> ok is that mean yes
23:46:45 <Samantha> >
23:46:46 <Samantha> ?
23:47:26 <Botje> Samantha: yes, this is the haskell channel :)
23:47:26 <Samantha> Then can someone asnwer me WHY HASKELL IS SO HORRIBLE AND HARD
23:47:31 <path[l]> hahaha
23:47:32 <Samantha> ???????????
23:47:36 <zachk> its different
23:47:42 <Samantha> no no no
23:47:43 <c_wraith> because it's homework, of course.  homework is always horrible and hard.
23:47:45 <zachk> it took me 3 months to have a clue 
23:47:46 <pelotom> Samantha: it forces you to use your brain in new ways :)
23:47:49 <path[l]> that was unexpected
23:47:57 <zachk> and i had been coding for 10+ years
23:48:06 <Samantha> like a lot I hate haskell
23:48:07 <path[l]> lol c_wraith
23:48:09 <Psytonic> haskell isnt that bad
23:48:10 <c_wraith> path[l], I actually expected it all the way. :)
23:48:14 <path[l]> oh ok
23:48:19 <Psytonic> i hated it when i started, but you get used to it
23:48:26 <Samantha> U sure 
23:48:28 <mjrosenb> zachk: well you had 10 years to learn the wrong way to write code :-p
23:48:33 <path[l]> lot of people learning haskell in schools these days huh?
23:48:36 <Samantha> so thats means 
23:48:37 <Psytonic> uni
23:48:46 <Axman6> Samantha: most people find haskell hard to learn, to begin with anyway. it gets easier
23:48:47 <Samantha> you are an expert psytonic
23:48:53 <Psytonic> na
23:49:07 <Samantha> but you know some
23:49:11 <Psytonic> yeah
23:49:23 <Samantha> ok can I ask you a question
23:49:25 <zachk> an expert would be simon peyton jones, though i dont think he does irc :( 
23:49:27 <Psytonic> sure
23:49:39 <Samantha> How can i post the code 
23:49:43 <kmc> hpaste.org
23:49:44 <Psytonic> pastebin
23:49:45 <Axman6> @where hpaste
23:49:45 <lambdabot> http://hpaste.org/
23:49:49 <Psytonic> that too
23:49:50 <Samantha> so you can see what I have
23:49:57 <zachk> > "look " ++ "a " ++ "bot" 
23:49:58 <lambdabot>   "look a bot"
23:50:12 <Samantha> where?
23:50:32 <pelotom> Samantha: if you put ">" at the beginning of your message, you can paste code into here and have it evaluated
23:50:33 <mjrosenb> Samantha: 23:50 < lambdabot> http://hpaste.org/
23:50:35 <zachk> just type a > at the beginning of the  line and you can execute haskell code thats non IO 
23:50:45 <Rembane> > "these" ++ " are" ++ "not " ++ "the" ++ "droids" ++ "you're" ++ "for!"
23:50:46 <kmc> not strictly true ;)
23:50:46 <lambdabot>   "these arenot thedroidsyou'refor!"
23:50:50 <Rembane> :D:D:D
23:50:54 <Psytonic> noob :P
23:50:55 <Samantha> > like this
23:50:55 <lambdabot>   Not in scope: `like'Not in scope: `this'
23:50:57 <zachk> @type intersperse 
23:50:58 <lambdabot> forall a. a -> [a] -> [a]
23:50:58 <kmc> you can evaluate Haskell code, whether or not it contains IO types, and you can't execute anything ;)
23:51:01 <zachk> > "like this" 
23:51:02 <lambdabot>   "like this"
23:51:11 <Axman6> > 1+1
23:51:12 <lambdabot>   2
23:51:26 <kmc> but you can't use '>' to define types, etc
23:51:27 <Samantha> HELLO
23:51:28 <Psytonic> just use the pastebin already :P
23:51:36 <Samantha> here 
23:51:41 <kmc> hpaste.org will also provide style suggestions
23:51:49 <Samantha> do you an email psytonic
23:51:52 <Samantha> ?
23:52:11 <Axman6> Samantha: is english your first language?
23:52:19 <pelotom> kmc: ok, ok, you can have it EVALUATED
23:52:26 <pelotom> ;P
23:52:26 <Samantha> yeah why?
23:52:30 <mjrosenb> Samantha: you should paste your code to hpaste.org so more than just Psytonic can see it.
23:52:35 <Psytonic> Samantha:  http://hpaste.org/
23:52:37 <Samantha> why u ask that axmam6
23:52:40 <Samantha> ?
23:52:51 <Axman6> you don't write like it is :\
23:52:55 <Samantha> do you have  an email psytonic
23:53:02 <Samantha> is chat
23:53:08 <Samantha> not an engilsh class
23:53:12 <Axman6> Samantha: there's no need to ask for people's emails. just ask your questions here
23:53:20 <kmc> Samantha, http://hpaste.org/
23:53:38 <mjrosenb> Samantha: yes, but writing in english helps prevent headaches.
23:53:47 <Samantha> ok i concurr
23:53:50 <Samantha> with that
23:53:51 <path[l]> Samantha click on that link and paste youre code there. Then you can paste the link here
23:54:10 <Samantha> ok here is my code 
23:54:24 <Samantha> > mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn xin   
23:54:25 <lambdabot>   Not in scope: `mapReduce'Not in scope: `mapFn'Not in scope: `wayAheadFn'Not...
23:54:35 <Axman6> urgh
23:54:39 <Psytonic> ...
23:54:42 <mjrosenb> ...
23:54:46 <Samantha> map reduce is a function 
23:54:46 <Psytonic> right
23:55:01 <Samantha> that i can use with another functions
23:55:11 <Psytonic> seriously, paste it all into the url
23:55:14 <Psytonic> and i'll have a look
23:55:20 <Axman6> Samantha: step 1: go to hpaste.org, step 2: paste your code there, step 3: submit the code, step 4: give us the url
23:55:36 <Samantha> when i go there nothing opens 
23:55:42 <Samantha> is a blank window
23:56:00 <Samantha> so I can paste the code
23:56:01 <Axman6> open it again
23:56:04 <Axman6> it's working fine here
23:56:16 <Psytonic> fine for me
23:56:18 <path[l]> works for me
23:56:32 <Samantha> this is my code
23:56:38 <Samantha> > 
23:56:39 <lambdabot>   not an expression: `'
23:56:42 <pelotom> oh no
23:56:49 <Psytonic> ><
23:57:20 <Samantha> > mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn xin  
23:57:20 <Samantha>   | (turnAroundCond xin) = turnAroundFn xin
23:57:21 <lambdabot>   Not in scope: `mapReduce'Not in scope: `mapFn'Not in scope: `wayAheadFn'Not...
23:57:21 <Samantha>   | otherwise = 
23:57:24 <Axman6> Samantha: do you want our help or not? we're not asking you to do things that are difficult, and they will allow us to help you
23:57:55 <Samantha>      reduceFn
23:57:55 <Samantha>      (mapFn xin) 
23:57:55 <Samantha>   (mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn (wayAheadFn xin))
23:57:56 <Samantha> ok that was the main function
23:58:02 <Samantha> know here os the second part
23:58:06 <Samantha> foldr1 f p xs =
23:58:08 <pelotom> *sigh*
23:58:10 <Botje> Samantha: put it on hpaste
23:58:11 <Samantha>    mapReduce
23:58:15 <Samantha>   (\(x:xs) -> (f) p (xs)
23:58:19 <Samantha>    (\_ -> 0)
23:58:21 <Botje> Samantha: we cannot discuss the code if it's scrolling around all the time
23:58:22 <Samantha>     (\xs -> xs == [])
23:58:30 <Samantha>  xs
23:58:40 <edlinde> are list comprehensions used a lot?
23:58:45 * pelotom gives the snipers the green light
23:59:13 <Axman6> Samantha: pasting code into an IRC channel is a great way to get banned
23:59:21 <Samantha> Iwell 
23:59:25 <Samantha> what I do?
23:59:26 <Axman6> edlinde: i don;t use them much
23:59:31 <mjrosenb> Samantha: http://pastebin.com/ http://nopaste.info/ http://pastie.org/ please. choose one.
23:59:37 <edlinde> Axman6: what are the alternatives?
23:59:40 <edlinde> mjrosenb: hi
23:59:42 <edlinde> :)
23:59:48 <mjrosenb> edlinde: morning
