00:00:57 <MiggyX> http://hpaste.org/40933/datetostring_problems   
00:01:00 <MiggyX> If anyone has a moment :)
00:05:05 <Entroacceptor> MiggyX: you probably want dateToString as being (Integer, Int, Int) -> String?
00:05:27 <MiggyX> Yeah - I tried making the function definition first - but whatever I tried, it got upset :)
00:05:28 <Entroacceptor> because the way it's there you're doing IO in it
00:07:17 <Entroacceptor> you can do pattern matching for arguments of a function
00:08:16 <pelotom> does anyone know the original paper showing that type inference for rank-3 polymorphism and above was undecidable?
00:08:23 <MiggyX> I had that originally, but as I couldn't figure out which bit I'd gotten wrong - I took it out agian :)
00:09:18 <kmc> pelotom, maybe http://www.macs.hw.ac.uk/~jbw/papers/#Wells:APAL-1999-v98
00:09:42 <Entroacceptor> MiggyX: annotated ypur paste
00:10:20 <kmc> that talks about "type checking" but i think it's equivalent to what we'd call inference, since it's a Curry-style calculus where arguments don't have annotations
00:10:52 <MiggyX> Entroacceptor:  but how do I get the date into it in the first place without IO ?
00:11:50 <pelotom> kmc: yeah, that shows that System F is undecidable, and another result showed that rank-2 was decidable... I'm wondering who determined that rank-3 was the cutoff point
00:12:26 <Entroacceptor> MiggyX: from outside
00:12:33 <Entroacceptor> the main function, for example
00:12:42 <pelotom> actually it might've been the same paper that showed decidability of rank-2, maybe?
00:12:53 <kmc> i don't know
00:12:57 <kmc> does TaPL have a reference for it?
00:13:06 <Entroacceptor> main = do { theDate <- date; print (dateToString theDate) }
00:13:12 <pelotom> good question, I should check that
00:14:26 <EvanR> main = date >>= print . doToString \o/
00:14:37 <Entroacceptor> EvanR: :)
00:14:38 <EvanR> dateToString
00:14:56 <Entroacceptor> don't confuse him too much 
00:15:00 <EvanR> >>\=
00:15:06 * EvanR attempts a haskell logo
00:15:22 <Entroacceptor> what would (>>\=) do?
00:15:26 <Entroacceptor> or does that exist?
00:15:35 <kmc> >λ=
00:15:52 <EvanR> as usual lambda looks very weird in unifont ;)
00:16:05 <EvanR> a backwards h with a curvy top like an a
00:16:30 <Entroacceptor> EvanR: I think that's one of the reasons I use my current font 
00:17:00 <MiggyX> sweet
00:17:03 <EvanR> i wonder if thats really a glyph from old greek terminals or something
00:17:06 <MiggyX> new improved version works
00:17:10 <Entroacceptor> that glyph is made by someone who's never seen a lambda in real life
00:17:18 <EvanR> or yeah
00:17:19 <EvanR> that
00:17:43 <kmc> yeah that's how it looks in my terminal
00:17:49 <kmc> but xchat does a better job, despite also being monospace
00:18:02 <MiggyX> looks like a catapult here
00:18:42 <EvanR> gives me an opportunity to be eccentic when writing lambdas
00:20:32 <merijn> Looks fine in my font, but I'm not using a monospace font atm
00:22:03 <Entroacceptor> ok, I found a lambda which looks a bit like an "a" http://upload.wikimedia.org/wikipedia/commons/6/64/Greek_Handwriting.jpg
00:22:17 <Entroacceptor> but still, the defining characteristic is a triangle like shape
00:22:58 <EvanR> "a proof is a program; the formula it proves is a type for the program"
00:22:59 <MiggyX> right, next mission - filter the text :D
00:23:19 <EvanR> what does this mean?
00:23:30 <kmc> that's the curry-howard isomorphism
00:23:48 <kmc> if «e :: T» then e is a "proof" that the type T is inhabited
00:24:03 <kmc> if «e :: S → T», then e is a proof that, if the type S is inhabited, then the type T is inhabited
00:24:18 <EvanR> a type being inhabitted is significant?
00:24:27 <kmc> a (constructive) proof of S implies T is a function that takes a proof of S and produces a proof of T
00:24:50 <kmc> EvanR, yes, if types are propositions then the inhabited types are the provable propositions
00:24:56 <kmc> of course in Haskell, every type is inhabited, by ⊥
00:25:03 <kmc> Haskell's type system is an inconsistent logic
00:25:08 <kmc> fix :: (a → a) →
00:25:11 <kmc> err
00:25:12 <kmc> fix :: (a → a) → a
00:25:19 <kmc> is a blatantly absurd axiom of logic
00:25:45 <kmc> EvanR, so we know which terms correspond to proofs of S → T
00:25:54 <kmc> can you figure out what a proof of S ∧ T looks like?
00:25:58 <kmc> that's "S and T"
00:26:04 <MiggyX> is there a simple function for matching if a String contains something
00:26:05 <MiggyX> ?
00:26:18 <EvanR> Data.String.Utils
00:26:25 <EvanR> lots useful stuff
00:26:45 <dmwit> > "foo" `isInfixOf` "heyo foobar there"
00:26:45 <merijn> kmc: Why is (a -> a) -> a absurd? Looks like a tautology of intuitionist logic to me
00:26:46 <EvanR> kmc: S and T meaning... S and T are inhabitted?
00:26:46 <lambdabot>   True
00:26:47 <byorgey> MiggyX: there's isInfixOf in Data.List
00:27:05 <byorgey> merijn: no it isn't,  False -> False  holds
00:27:21 <byorgey> because False implies anything
00:27:58 <kmc> EvanR, yeah
00:28:08 <kmc> what evidence would convince you that both S and T are inhabited
00:28:21 <kmc> merijn, really?  for all a, we can prove a → a trivially
00:28:27 <kmc> λx. x :: a → a
00:28:41 <kmc> so then we can prove a
00:28:47 <dmwit> Entroacceptor: Who spells 'b' as 'w'??
00:29:00 <EvanR> kmc: terms?
00:29:04 <kmc> yes
00:29:12 <kmc> {-# LANGUAGE EmptyDataDecls #-} data NotInhabited; proof :: NotInhabited; proof = fix id
00:29:17 <kmc> that's for merijn
00:29:20 <pelotom> the existance of a polymorphic identity function does not imply all types are inhabited :)
00:29:28 <kmc> right, but it does in Haskell's logic
00:29:35 <dmwit> You would hope not, but fix makes a mash of your hopes.
00:29:41 <dolio> (False -> False) -> False
00:30:16 * byorgey writes a country song called "fix makes a mash of your hopes"
00:30:22 <kmc> so what term would prove S ∧ T EvanR?
00:30:43 <pelotom> haha
00:31:03 <EvanR> kmc: whats an example of a term
00:31:07 <Entroacceptor> dmwit: Carl Faulmann († 1894): Das Buch der Schrift. Enthaltend die Schriftzeichen und Alphabete aller Zeiten und aller Völker des Erdkreises, Vienna 1880 (2nd edition)
00:31:13 <dmwit> EvanR: Haskell terms, of course.
00:31:17 <EvanR> ok
00:31:20 <kmc> True, 3, \x -> x+x
00:31:21 <pelotom> values <=> terms
00:31:24 <EvanR> is S a term?
00:31:31 <kmc> pelotom, values are terms in normal form
00:31:35 <dmwit> EvanR: Let's say we have s :: S and t :: T.
00:31:41 <kmc> EvanR, no, S is a proposition ≡ type
00:31:52 <pelotom> ah, ok
00:31:57 <MiggyX> can list comprehensions involve IO ?
00:32:01 <EvanR> or is S a type / proof
00:32:02 <EvanR> im new
00:32:08 <kmc> S is a type
00:32:10 <merijn> kmc: Ah, I get it. We'd have to assume (a -> a) -> a to derive a using the trivial proof of a -> a, but that assumption never gets canceled using implication...
00:32:11 <kmc> meaning is a proposition
00:32:20 <kmc> if «x :: S» then x is a term that proves S
00:32:25 <EvanR> ok so s && t
00:32:35 <EvanR> hmm
00:32:41 <dmwit> Not quite. =)
00:32:41 <kmc> MiggyX, yes, values of type "IO A" are "IO recipes" and they are values like any other
00:32:46 <pelotom> (s, t)
00:32:49 <byorgey> MiggyX: in theory, list comprehensions can involve things of any type.
00:32:51 <kmc> however just building such a recipe does not perform the IO
00:32:51 <EvanR> but its an isomorphism!
00:32:52 <EvanR>  ;)
00:33:00 <byorgey> MiggyX: but I'm guessing not in the way you are thinking.
00:33:01 <kmc> EvanR, s && t has type Bool
00:33:14 <kmc> we need something with a type that "corresponds to" S ∧ T
00:33:17 <EvanR> i want something of type s ^ t ?
00:33:20 <EvanR> S ^ T?
00:33:27 <dmwit> What's (^)?
00:33:30 <kmc> ∧
00:33:32 <EvanR> have have i seen that type
00:33:34 <MiggyX> Well I'm using hGetLine to read in a line from the file and I only want to pass it on if "TDS" appears in that line
00:33:41 <kmc> EvanR, it exists in Haskell, under a different name
00:33:45 <byorgey> EvanR: you have to figure out a Haskell type which corresponds to it.
00:33:48 <dmwit> EvanR: You've got to pick a Haskell type that corresponds somehow to our idea of what (^) should mean. =)
00:33:57 <EvanR> (S,T) ?
00:34:00 <kmc> yes
00:34:01 <dmwit> exactly!
00:34:06 <byorgey> \o/
00:34:09 <kmc> and now what about S ∨ T
00:34:11 <EvanR> or Pair S T
00:34:13 <kmc> "S or T"
00:34:27 <EvanR> data SORT = S | T
00:34:33 <kmc> right
00:34:36 <kmc> or just Either S T
00:34:40 <dmwit> err
00:34:45 <dmwit> data SORT = S S | T T
00:34:46 <kmc> yeah
00:34:50 <EvanR> oh
00:34:52 <kmc> data SorT = InL S | InR T
00:34:55 <merijn> EvanR: Also, if you wanna read up on the basics of this stuff, there's reasonably good course notes on type theory on my university's web page
00:34:57 <dmwit> but that's just a syntax quibble, I think you had the idea right
00:34:59 <EvanR> then ill go with Either S T
00:35:03 <kmc> a proof of S ∧ T is a structure from which you can extract both a proof of S and a proof of T
00:35:07 <pelotom> I wish there was a co-tuple syntax like (S | T)
00:35:16 <kmc> a proof of S ∨ T is a structure from which you can extract either a proof of S or a proof of T, and a flag telling you which
00:35:39 <kmc> EvanR, now, any idea how we'd encode ¬T, "not T"?
00:35:46 <tg_> pelotom: like bracket notation < a | b >
00:35:50 <tg_> bra-ket
00:35:50 <dmwit> pelotom: I guess you mean only at the type level, or do you have a proposal for the term level, too?
00:36:00 <EvanR> kmc: a proof that T has no inhabitants?
00:36:06 <tolkad> pelotom: sort of like Either?
00:36:10 <kmc> yeah EvanR
00:36:15 <pelotom> tolkad: sugar for Either
00:36:17 <kmc> now how could we build that in a Haskell-like type system?
00:36:17 <tolkad> oh
00:36:25 <EvanR> data T =
00:36:31 <tolkad> pelotom: meh, don't really need sugar for that
00:36:36 <dmwit> kmc: Maybe "False" is a better place to start than "not T"?
00:36:38 <tolkad> pelotom: it's just going to confuse people
00:36:41 <_mpu> > sequence [ f x | f <- [putStr, putStrLn], x <- ["hi ", "I ", "do ", "junk "] ]
00:36:42 <lambdabot>   <IO [()]>
00:36:44 <kmc> maybe dmwit
00:36:51 <kmc> EvanR, you mean an empty data declaration?
00:36:54 <pelotom> tolkad: does tuple syntax confuse you? I think it makes things rather nice and readable
00:36:55 <kmc> (you'd omit the '=' in GHC)
00:36:58 <EvanR> i guess
00:37:07 <kmc> EvanR, that gives you a specific type which is not inhabited
00:37:08 <kmc> data False
00:37:18 <kmc> now, for arbitrary type T, how would we write the type that means ¬T
00:37:18 <tolkad> pelotom: yes, I stare at tuples forever trying to understand them
00:37:38 <tolkad> pelotom: it would be so much either to do something like Tuple5 a b c d e
00:37:42 <EvanR> now im wondering why the significance of a habitation proof is again
00:37:45 <kmc> i think that anonymous sums and products are already overused in Haskell
00:37:50 <pelotom> tolkad: I sincerely hope you're joking
00:38:09 <EvanR> s/why/what/
00:38:19 <dmwit> Well, related, but not the same, I've sometimes thought that (a,b,c) ought to be sugar for (a,(b,(c,())))
00:38:22 <EvanR> is this used in principle in the type checker
00:38:25 <merijn> EvanR: This should cover basic type theory/curry-howard-debruijn more in depth then IRC can: http://www.cs.vu.nl/~femke/courses/lv/notes/notes.pdf
00:38:25 <kmc> no
00:38:26 <pelotom> EvanR: habitation *is* proof
00:38:33 <_mpu> kmc: Haskell type system is not made to do theorem proving
00:38:41 <kmc> EvanR, the point of C-H is that if you write down the rules for checking that term e inhabits type T, and you write down the rules for checking that proof e is a valid proof of proposition T, you find that you've written down the same rules
00:38:44 <pelotom> if a term inhabits a type, the type is proven by that term
00:38:51 <kmc> EvanR, you can see it as an accidental "discovery" like that
00:38:53 <kmc> makes sense?
00:39:01 <tolkad> dmwit: we call that a list
00:39:04 <_mpu> I types are not present, and negated types might also not be there
00:39:11 <dmwit> tolkad: Nonsense, a, b, and c can have different types.
00:39:14 <tolkad> dmwit: well, I guess not
00:39:18 <vakosel> hi all,newbie around. what is the best setup for emacs and ghci?
00:39:20 <tolkad> dmwit: still, it's different
00:39:24 <EvanR> kmc: so type definitions are proofs in logic
00:39:32 <merijn> EvanR: Yes
00:39:35 <dmwit> tolkad: And there's no reasonable "projection" function analogous to (!!).
00:39:35 <EvanR> does that have anything to do with programming ;)
00:39:46 <tolkad> dmwit: more constructor overhead
00:39:49 <merijn> EvanR: When you extend it to predicate logic, then yes
00:39:58 <merijn> EvanR: Then you get dependent typing ala epigram
00:40:04 <_mpu> EvanR: no, showing x of type T makes x the proof of T
00:40:07 <vakosel> any help?
00:40:18 <kmc> EvanR, http://www.cis.upenn.edu/~bcpierce/sf/
00:40:19 <dmwit> tolkad: Meh, that can be an implementation detail.
00:40:20 <merijn> EvanR: Where the type of a function can rely on the types of it input
00:40:41 <kmc> vakosel, i just tab between them in 'screen'.  fancier setups are of course possible
00:40:43 <dmwit> vakosel: Have you tried the web yet?
00:41:14 <vakosel> dmwit: i found  shime and haskell-mode
00:41:24 <EvanR> kmc: so is False, a (the?) type with no inhabitants, the answer to your question of not T
00:41:29 <_mpu> Fundamental mode rocks
00:41:36 <tolkad> dmwit: no, because with a normal tuple I can't lazily pattern match on part of it, with yours I can
00:41:41 <kmc> yeah, False is a type with no inhabitants
00:41:53 <dmwit> tolkad: You find yourself using that a lot, then, do you?
00:42:08 <kmc> EvanR, but you didn't give an encoding of ¬T yet, unless i missed it
00:42:17 <kmc> type Not t = ...
00:42:20 <_mpu> kmc: not even bottom ?
00:42:32 <kmc> _mpu, no, we're ignoring ⊥ for now
00:42:35 <merijn> Does Haskell have bottom defined, then?
00:42:40 <dmwit> :t undefined
00:42:41 <lambdabot> forall a. a
00:42:44 <kmc> i said above that actually every type is inhabited
00:42:48 <merijn> dmwit: Undefined is not bottom
00:42:55 <dmwit> merijn: Why not?
00:42:58 <tolkad> dmwit: I'm saying, I'm not sure that the fact that is possible wont make it harder to optimize
00:42:59 <kmc> because of 'undefined', and because of 'fix' and ultimately recursive let
00:43:02 <merijn> Undefined is actually an inhabitant of all types in haskell
00:43:18 <dmwit> Just like bottom, no?
00:43:21 <tolkad> dmwit: tell me why I put a comma there. I don't know why I did that
00:43:23 <kmc> in some systems there's a type named ⊥, but it has not much to do with the value named ⊥
00:43:41 <kmc> the type ⊥ comes up in subtyping systems, it's a subtype of every type and typically has no inhabitants
00:43:43 <dmwit> tolkad: Yes, okay, perhaps you're right.
00:43:47 <pelotom> bottom is mr. smith... he can inhabit any denizen of the matrix
00:43:51 <EvanR> kmc: i need the question rephrased :)
00:43:53 <merijn> Bottom inhabits all types? My type theory is kinda flaky, but I didn't think it did...
00:43:53 <kmc> haha
00:44:05 <kmc> EvanR, how do you feel about «type Not t = ...»
00:44:23 <pelotom> merijn: in an inconsistent system, bottom inhabits all types
00:44:26 <kmc> EvanR, finish that definition, such that if T is inhabited then «Not T» is not inhabited
00:44:28 <EvanR> what is the ... supposed to tell me
00:44:31 <dmwit> EvanR: I've got a type 'T', and I hide it behind my back. I want you to write a type that uses 'T' somehow, and is inhabited exactly when 'T' isn't.
00:44:33 <kmc> EvanR, it means you fill in the blank
00:44:34 <EvanR> ok
00:44:34 <tolkad> does bottom inhabit all kinds?
00:44:47 <kmc> tolkad, the type ⊥? probably not
00:44:51 <merijn> pelotom: I don't use inconsistent logic normally
00:44:54 <Saizan> in a consistent system you hope you don't have a bottom :)
00:44:56 <kmc> if you had subtyping with the type ⊥, it would have kind ∗
00:44:58 <tolkad> kmc: no, some sort of type bottom
00:45:04 <pelotom> merijn: if you use a turing complete language, you use an inconsistent logic
00:45:08 <EvanR> dmwit: ok
00:45:09 <kmc> maybe you let it be kind-polymorphic
00:45:11 <tolkad> kmc: oh that's what you said
00:45:12 <dmwit> EvanR: i.e. "not T" should be inhabited when "T" is empty, and "not T" should be empty when "T" is inhabited. =)
00:45:34 <Saizan> well, there are some recent systems where you're allowed bottom in programs but not in propositions
00:45:43 <EvanR> is t :: T
00:46:01 <tolkad> you know, if the designers of GHC let us pattern match on bottom we could solve many "uncomputable" problems in computer science
00:46:16 <dmwit> EvanR: We're not writing any proofs yet, so we're working only at the type level for now.
00:46:18 <pelotom> merijn: the existence of unrestrained recursion and bottom values like undefined in haskell make it an inconsistent logic
00:46:19 <merijn> pelotom: Yes, but when I discuss type theory I'm only used to minimal intuitionist logic, the rest is scary maze of passages all alike >.>
00:46:27 <kmc> tolkad, huuurrrrrrr
00:46:29 <dmwit> EvanR: So whether "t :: T" or not is immaterial.
00:46:52 <EvanR> i thought not T was the question
00:46:57 <kmc> yeah
00:47:06 <kmc> finish this declaration: «type Not t = ...»
00:47:17 <kmc> such that if T is inhabited then «Not T» is not inhabited
00:47:21 <kmc> that's the question
00:47:25 <kmc> there are only types here, no terms
00:47:33 <EvanR> oh, t is any type?
00:47:38 <dmwit> Oh! Maybe I understand the confusion. 't' in kmc's thing is a type variable that we'll be instantiating at type 'T' later.
00:47:38 <kmc> it's just Haskell
00:47:39 <merijn> pelotom: We weren't directly discussing haskell at the start, we started with Curry-Howard. In which case we're not necessarily dealing with an inconsistent logic like haskell
00:47:41 <kmc> a type synonym in Haskell
00:48:18 <EvanR> im just wondering if i should use t or T in the answer, it doesnt seem that i can possibly use T, but if i dont, i dont see how im answering the question, about T
00:48:19 <pelotom> merijn: ok, well in a consistent system bottom doesn't inhabit any types :)
00:48:23 <dmwit> EvanR: This question will also be a little easier if you've seen encodings of "not" in terms of other stuff in logic before.
00:48:26 <EvanR> but i can obviously use t
00:48:31 <EvanR> if t :: T, that explains that
00:48:32 <tolkad> does haskell have a method of embedding assembly without the foreign function interface?
00:48:35 <merijn> pelotom: My understanding of C-H is saved \o/
00:48:43 <pelotom> yaay
00:48:48 <kmc> EvanR, how would t :: T, t is a type variable
00:48:56 <EvanR> exactly
00:48:59 <EvanR> so nevermind
00:49:01 <kmc> that makes no sense
00:49:12 <tolkad> sort of like C
00:49:14 <pelotom> merijn: coq has this sort of system
00:49:18 <kmc> i'm just asking you to write a Haskell* type synonym with a certain property
00:49:23 <EvanR> C doesnt have that feature either
00:49:23 <kmc> by Haskell* i mean Haskell without ⊥
00:49:36 <EvanR> let me think dammit!
00:49:37 <merijn> pelotom: I know, but Coq has scary verbosity of syntax :p
00:49:45 <kmc> EvanR, i'm sorry, you keep asking for clarification of the question
00:49:45 <EvanR> dmwit: good call, dont tell me
00:50:01 <pelotom> merijn: indeed... a consequence of the undecidability of type inference for such powerful type systems :(
00:50:06 <kmc> tolkad, i would show you my cheeky hack for embedding machine code, but i'm pretty sure you'd use it to troll the ghc developers and open false and spurious bugs
00:50:36 <merijn> tolkad: Why do you feel the need to embed asm in the first place?
00:50:46 <tolkad> huh: http://darcs.haskell.org/cgi-bin/darcsweb.cgi?r=ghc;a=darcs_commitdiff;h=20100714152530-e1038-7915f20bb89b26684e1e503ddf3332a9a3fc5727.gz
00:50:47 <dmwit> tolkad: You can embed Core without the FFI... is that close enough?
00:51:17 <kmc> dmwit, how?
00:51:19 <tolkad> merijn: I was just curious
00:51:36 <dmwit> kmc: Core is just "\" and "case". :nastygrin:
00:51:46 <merijn> pelotom: I'm looking into epigram now, but I'm having a hard time getting through "The view from the left" because it assumes I know stuff about Luo's UTT the only reference of which appears to be a book I can't get...
00:51:49 <kmc> tolkad, maybe you'd like http://hackage.haskell.org/package/harpy and http://hackage.haskell.org/package/llvm
00:51:54 <dmwit> ...and maybe "let".
00:52:03 <kmc> and this blog post http://augustss.blogspot.com/ tolkad
00:52:12 <tolkad> kmc: I haven't actually written spurious bug reports, only joked about it
00:52:17 <kmc> dmwit, but they have different semantics
00:52:22 <kmc> tolkad, you trolled here and in #ghc though
00:52:23 <kmc> repeatedly
00:52:28 <dolio> merijn: Read his thesis about ECC. They're relatively similar.
00:52:59 <kmc> you'll note that some of the GHC devs are rarely or never active here; they are busy people with real jobs and such
00:53:01 <pelotom> merijn: I explored coq because it has lots of excellent material to help you understand it
00:53:11 <pelotom> coq'art is a fantastic book
00:53:14 <dolio> The major difference is that UTT is presented in the logical framework, but I don't think the Epigram papers make use of that.
00:53:18 <kmc> so going to #ghc to bug them for your own jollies is particularly antisocial
00:53:42 <EvanR> psychopathic even!
00:53:47 <kmc> :D
00:53:56 <merijn> dolio: I've been told, I've got that one now. Slowly getting through it
00:54:37 <merijn> Having a hard time motivating myself through the abstrusesity (this is hereby a new word). >.>
00:55:00 <tolkad> kmc: I wasn't bugging them, I just wanted to see what they would say about th ebug
00:55:03 <tolkad> the bug*
00:55:28 <kmc> tolkad, that's what i said
00:55:37 <tolkad> and see if they could recognize the bug if I made it look different
00:55:44 <kmc> anyway i'm sick of telling you off, just don't be a dick
00:55:48 <tolkad> ok
00:56:07 <pelotom> kmc: type Not t = t -> forall a. a ?
00:56:14 <kmc> pelotom, close slash kind of right
00:56:18 <tolkad> so... can I see the hack for embedding machine code? :P
00:56:28 <kmc> pelotom, can you rewrite it using our «data False»?
00:56:31 <pelotom> forall a. all the way to the right?
00:56:39 <pelotom> oh
00:56:44 <pelotom> well just t -> False
00:56:46 <kmc> right
00:56:50 <kmc> type Not t = t -> False
00:56:53 <pelotom> I didn't see that part :)
00:57:08 <pelotom> I was trying to invent a False type on the fly
00:57:11 <kmc> now to make this useful you want a corresponding
00:57:15 <kmc> ex_falso :: False -> a
00:57:26 <kmc> Haskell is not really set up to write this
00:57:37 <kmc> False is a type with 0 constructors
00:57:38 <EvanR> ah, ->
00:57:40 <kmc> so we should write like
00:57:41 <EvanR> thats the key
00:57:42 <pelotom> right, absurdity implies anything you want
00:57:44 <kmc> ex_falso x = case x of {}
00:57:53 <kmc> but instead we need to resort to something like
00:57:55 <EvanR> union and intersection cant do it
00:57:58 <kmc> ex_falso x = undefined
00:58:06 <EvanR> i forgot about ->
00:58:17 <kmc> tolkad, doing something that annoys other people because you want to see their reaction is basically the definition of trolling
00:58:32 <merijn> What keeps tripping me up is that "(t -> False -> False) -> t" is not a tautology in intuitionist logic...
00:58:37 <tolkad> kmc: well, I didn't intend to annoy them
00:58:43 <tolkad> kmc: and they didn't seem annoyed
00:59:04 <tolkad> kmc: anyway, I promised to stop
00:59:23 <EvanR> for all values of 2 equal to 3... X is true
00:59:34 <pelotom> merijn: False -> False is a tautology, so t -> False -> False is also a tautology, and True -> t does not follow
00:59:35 <kmc> yeah well, british people are polite and slow to anger, then one day they come and empire your whole country
00:59:35 <merijn> Wait, that's wrong. I meant "((t -> False) -> False) -> t" is not inhabited.
00:59:42 <kmc> so watch out for that
00:59:48 <merijn> pelotom: Yeah, I screwed it up :p
01:00:09 <pelotom> merijn: yeah, that's the law of the excluded middle
01:00:20 <pelotom> you need to accept an axiom of classical logic to assume that
01:00:36 <kmc> EvanR, now, this one is nearly impossible to guess so i'll just tell you
01:00:41 <kmc> so far we're working in constructive logic
01:00:46 <tolkad> do most CS curriculums go through type theory?
01:00:47 <kmc> no law of the excluded middle
01:00:50 <pelotom> not not t -> t requires classical logic
01:00:51 <merijn> Yeah, which is what trips me up all the time since most people implicitly assume the law of excluded middle all their live
01:01:02 <merijn> tolkad: I fear not
01:01:07 <kmc> if we wanted classical logic, we could add LEM as an axiom
01:01:19 <kmc> or we could add something else equivalent, like Peirce's Law:
01:01:31 <kmc> ((p → q) → p) → p
01:01:32 <merijn> tolkad: At my and a bunch of other universities here it is optional
01:01:32 <EvanR> kmc: tell me what
01:01:56 <kmc> which turns out to be the type of Scheme et al's call-with-current-continuation
01:02:00 <merijn> I think there's a one or two universities here that do mandatory type theory in CS
01:02:00 <kmc> often named call/cc
01:02:02 <kmc> :t callCC
01:02:03 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
01:02:26 <kmc> now Haskell stuffs continuations into this monad, which I guess we could read as a modal operator for "classically provable", but i haven't gone very far down that train of thought
01:02:39 <kmc> anyway call/cc lets you prove LEM
01:02:42 <pelotom> kmc: yeah, that one blows my mind :)
01:02:48 <kmc> by a very cheeky proof
01:02:59 <kmc> we need to write a term of type «Either (T → False) T»
01:03:08 <merijn> There's a third proof isomorph with LEM, forgot the name
01:03:28 <_mpu> is MonadCont providing the whole power of callCC ?
01:03:44 <kmc> callCC $ \k → Left (\t → k (Right t)) :: Either (T → False) T
01:03:49 <pelotom> I wrote this question on stackoverflow which collected some interesting equivalences due to HC: http://stackoverflow.com/questions/2969140/what-are-the-most-interesting-equivalences-arising-from-the-curry-howard-isomorph
01:03:52 <kmc> (ignoring that callCC is actually monadic)
01:04:16 <kmc> pelotom, cool, you might try the CS theory stackexchange as well
01:04:27 <kmc> anyway EvanR, this proof is cheeky as hell
01:04:32 <kmc> we first claim that T → False
01:04:36 <pelotom> kmc: yeah, I wrote that before that stackexchange was up, but maybe I should repost there now
01:04:37 <kmc> returning a function of that type,wrapped in Left
01:04:44 <kmc> then if someone actually calls that function with some T
01:04:46 <kmc> we change our mind
01:04:56 <kmc> use the continuation to travel back in time and return Right with the T they gave us
01:05:21 <kmc> _mpu, not really, they're delimited continuations in a sense, because you run it with runCont
01:05:22 <kmc> :t runCont
01:05:24 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
01:05:34 <kmc> _mpu, Cont is just syntactic sugar for a CPS transform
01:06:02 <kmc> as to "do CS curriculums require type theory"... many of them don't require anything except Java
01:06:11 <EvanR> kmc: wait you were talking to me the whole time about LEM?
01:06:22 <kmc> EvanR, if you're interested sure
01:06:23 <_mpu> ok, I noticed that monads have something to do with CPS
01:06:43 <EvanR> call/cc proves law of exluded middle?
01:06:47 <kmc> yes
01:06:52 <kmc> call/cc's type is Peirce's Law
01:06:57 <kmc> which is equivalent to LEM
01:06:58 <EvanR> im not sure what that law is
01:07:01 <EvanR> what that law is
01:07:04 <merijn> Most CS curriculums are unfortunately not actually CS, but more "applied programming"
01:07:07 <kmc> A ∨ ¬A
01:07:14 <kmc> A or (not A)
01:07:21 <EvanR> either x is true, or it isnt
01:07:23 <kmc> classically, this is taken for granted
01:07:26 <dolio> @type callCC (\k -> return (Left $ \x -> k (Right x)))
01:07:26 <lambdabot> forall (m :: * -> *) b b1. (MonadCont m) => m (Either (b1 -> m b) b1)
01:07:27 <kmc> EvanR, s/true/provable/
01:07:28 <pelotom> or equivalently (not not A) implies A
01:07:37 <EvanR> classically i use this all the time against people ;)
01:07:47 <EvanR> but i always wondered if it made sense
01:07:55 <merijn> EvanR: Correct, but that is not an axiom of intuitionist logic type theory usually uses
01:07:59 <kmc> yeah
01:08:04 <kmc> in constructive logic we distrust such axioms
01:08:20 <EvanR> the universe is infinite, or it isnt
01:08:22 <kmc> because they don't give a concrete "witness" of the thing which is to be proven
01:08:23 <merijn> It is an axiom of classical logic (which is more common), though
01:08:34 <EvanR> god exists as a real thing, or doesnt
01:08:52 <kmc> it is logically impossible to have evidence of the existence of an omnipotent god
01:09:04 <kmc> because any finite amount of evidence would be more easily explained by a being of finite power
01:09:07 <merijn> EvanR: "universe is not infinite" -> "universe might be finite" in intuitionist logic
01:09:09 <kmc> "there is no god, aliens are just fucking with you"
01:09:21 <pelotom> wow, we have wandered far afield now ;)
01:09:30 <EvanR> lol
01:09:38 <EvanR> intuitionistic logic?
01:09:51 <merijn> EvanR: Also called constructive logic
01:09:52 <kmc> even if you could prove "intelligent design" it would be infinitely more plausible that we'd been designed by aliens of finite power
01:10:04 <merijn> I recommend that course notes I linked earlier (I can link them again)
01:10:10 <pelotom> intuitionistic logic is all about following your gut... whatever feels "truthy"
01:10:10 <kmc> (for my conveniently chosen notion of plausibility)
01:10:16 <kmc> haha
01:10:32 <tolkad> kmc: but God works in mysterious ways thus negating your logic
01:10:43 <kmc> o snap
01:10:45 <EvanR> negating your logic when convenient
01:10:52 <EvanR> otherwise double negating it
01:11:26 <merijn> EvanR: They cover proposition logic, constructive logic, simply typed lambda calculus, predicate logic, dependently typed lambda calculus, second order proposition logic and polymorphic lambda calculus
01:11:27 <merijn> http://www.cs.vu.nl/~femke/courses/lv/notes/notes.pdf
01:11:43 * EvanR stuffs that pdf into his bag of papers
01:11:50 <EvanR> with wget
01:12:22 <merijn> It's easier (and longer) then most papers though as they're course notes starting with the assumption you have only a minimal grasp of formal logic
01:12:25 <pelotom> I <3 my bag o' papers
01:12:41 <kmc> EvanR, if you want hands-on experience with programs-as-proofs, i highly recommend _Software Foundations_ by Pierce et al
01:12:42 <pelotom> bag o' papers + dropbox + iphone = great success
01:12:44 <kmc> http://www.cis.upenn.edu/~bcpierce/sf/
01:12:53 <kmc> Coq is like an addictive puzzle game, the exercises will captivate you
01:13:01 <kmc> i had a coq-off with a friend
01:13:01 <EvanR> eh
01:13:12 <pelotom> whoah whoah, kmc, we don't need to hear about this
01:13:15 <EvanR> actually i was looking for things that made programming easier or more reliable
01:13:16 <kmc> hehehe
01:13:27 <EvanR> or designing systems
01:13:29 <kmc> well, formal methods are used for "more reliable"
01:13:29 <EvanR> engineering
01:13:31 <merijn> EvanR: Dependent typing :p
01:13:37 <kmc> at the very high end, i.e. nuclear reactors, airplanes, medical equipment
01:14:02 <merijn> Did a course in protocol validation using mu calculus, interesting stuff
01:14:15 <kmc> if you want lightweight formal methods to help with engineering, system architecture, etc. i recommend Alloy
01:14:20 <kmc> http://alloy.mit.edu/tutorial3/alloy-tutorial.html
01:14:23 <EvanR> and if its not easy to understand or explain, then its not going to be acceptable to most engineers / code monkeys ;)
01:14:36 <kmc> i've also done model checking with Spin, which is useful for proving properties of concurrent systems of finite statem achines
01:14:40 <tolkad> is the axiom of choice true or not?
01:14:42 <merijn> EvanR: That's what epigram aims to solve in the next few years
01:14:47 <kmc> tolkad, opinions vary
01:14:58 <pelotom> the axiom of choice requires LEM, iirc
01:15:06 <merijn> EvanR: Pragmatic syntax for dependent typing
01:15:51 <merijn> The observational types and pattern matching on types stuff seems interesting, I just don't grok the theory behind it yet >.>
01:16:17 <pelotom> ah, LEM follows from AoC
01:16:27 <pelotom> and possibly vice versa
01:16:47 <pelotom> they're both disreputable fellows
01:17:00 <pelotom> shifty eyed
01:17:16 <merijn> "Coq: An industrial-strength proof assistant", I wonder which industry uses proof assistant other then mathematics which isn't really an industry >.>
01:17:54 <pelotom> merijn: http://www.galois.com/
01:17:55 <kmc> merijn, high-assurance software engineering
01:18:03 <kmc> much of which is classified of course
01:18:10 <kmc> or just difficult and unglamorous
01:18:19 <kmc> less sexy than TwitFaceTube
01:18:33 <EvanR> lol
01:18:35 <kmc> i mean it's like how everyone knows Windows is the most popular OS, even though Linux is in most devices that *aren't* desktop computers
01:18:36 <EvanR> hahaha
01:18:49 <dolio> pelotom: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.97.9535&rep=rep1&type=pdf
01:18:52 <kmc> tolkad, the Axiom of Choice is obviously true, the well-ordering principle obviously false, and who can tell about Zorn's Lemma?
01:19:02 <pelotom> it's a sad truism that truly sexy code leads to truly unsexy products, and sexy products are usually made by disgusting code
01:19:19 <kmc> or really good code made by very boring means
01:19:25 <EvanR> wait
01:19:32 <kmc> http://www.fastcompany.com/magazine/06/writestuff.html
01:19:34 <merijn> kmc: My experience with the industry so far is that the software industry seems to be mostly incompetent monkeys
01:19:51 <EvanR> pelotom: worse is better?
01:19:59 <pelotom> dolio: nice
01:19:59 <kmc> the Space Shuttle software is not written by tshirt clad nerf gun shooting red bull chugging all nighter LEET HAXORZZZ
01:20:08 <kmc> it's written by 40 year old engineers, half of them women
01:20:20 <kmc> who go to long boring meetings and triple-check very long lists of requirements
01:20:38 <EvanR> kmc: i think they hate me at work
01:20:47 <kmc> and generally Pay Attention
01:20:55 <merijn> Yes, but space shuttle software is an insignificant amount of all software :p
01:20:59 <kmc> yes
01:21:09 <kmc> but we were talking about the sort of thing where you might use Coq
01:21:10 <merijn> Even of the other software that matters
01:21:15 <EvanR> i put them through those lists of assumptions and possibly failure modes, and they just want to get shit done
01:21:21 <EvanR> broken or not
01:21:27 <EvanR> s/possibly/possible/
01:21:53 <EvanR> 'why would it be broken' is the usual defense
01:21:58 <merijn> ATM's running windows and power plants being wired to the internet...sometimes I hate the IT industry
01:22:02 <EvanR> 'why would condition X not be true'
01:22:10 <EvanR> because its php dammit
01:22:13 <EvanR> a lot of it
01:22:18 <EvanR> and a mysql database
01:22:30 <EvanR> *my* *s* *q* *l*
01:22:37 <kmc> yeah merijn
01:22:54 <merijn> kmc: I'd prefer the ATMs I use to be you know, somewhat secure and bug free, but that's apparently out of budget
01:23:02 <EvanR> maybe i should take away their nerf guns
01:23:31 <kmc> my friend was asking for a halloween costume
01:23:34 <kmc> i said "go as mysql"
01:23:36 <Entroacceptor> kmc: that remark that the AoC is true reminded me of this comic: http://www.smbc-comics.com/index.php?db=comics&id=2037#comic
01:23:38 <kmc> "get really drunk, steal people's stuff and lose it, vomit everywhere, knock over tables"
01:23:49 <merijn> And then there's the cool kids with their "Web 2.0 will replace native applications!" and "Ruby! Ruby! Ruby!", all the time (poorly) reinventing the X protocol >.>
01:23:51 <EvanR> kmc: lol
01:24:09 <merijn> NoSQL! Because who cares about ACID?!
01:24:09 * EvanR wishes he knew how to operate the quote recorder
01:24:11 <dolio> Wouldn't using the same, old, embedded software as ATMs decades ago be cheaper than running Windows?
01:24:18 <Entroacceptor> poorly reinventing X? omigawd
01:24:20 <dolio> Or is it not, because hardware that runs Windows is cheaper?
01:24:28 <merijn> dolio: You'd say so, but apparently it is not
01:24:45 <merijn> I only know because I've run into BSoD and non-full screen ATMs
01:25:03 <pelotom> the problem is, even ATMs have to gain new functionality... like those awesome check scanners
01:25:06 <EvanR> i hate that anti relational popular movements implicitly and unknowingly just hate mysql
01:25:22 <tolkad> EvanR: It just isn't web scale
01:25:29 <EvanR> >_<
01:25:39 <merijn> Speaking of terms to make me rage...
01:25:43 <EvanR> i showed that meme to the manager, and he immediately wanted to drop mysql and move to mongodb
01:26:03 <tolkad> I can't read that without hearing MON GOD B
01:26:16 <EvanR> mongoloiddb
01:26:20 <EvanR> is what i see
01:26:30 <tolkad> I wonder what happened to MON GOD A
01:26:42 <merijn> Speaking of quotes, I think #haskell has the most funny (in an extremely nerdy way) people in it
01:26:43 <kmc> EvanR, right, it's exactly like "Java sucks therefore static types suck"
01:26:54 <pelotom> http://browsertoolkit.com/fault-tolerance.png
01:27:04 <kmc> yesssss pelotom
01:27:05 <pelotom> everyone's seen that but it still makes me lawl
01:27:06 <merijn> Actually, they guy behind behind mongodb seems to know what the hell he is doing, his users just don't.
01:27:18 <tolkad> why is it important that type inference be decidable?
01:27:20 <merijn> s/they/the
01:27:32 <kmc> tolkad, well, if you like type inference
01:27:43 <kmc> then you want it to be decidable
01:27:46 <merijn> tolkad: If its not decidable we can't automate it?
01:27:49 <kmc> otherwise it can't be implemented ;P
01:27:56 <tolkad> wait I said that wrong
01:27:59 <kmc> tolkad, but I think it's important that it be decidable in the "common cases"
01:28:09 <dancor> when well Control.Concurrent start using epoll
01:28:10 <kmc> i'm fine writing an explicit type when i'm doing some rank-3 madness
01:28:13 <dancor> s/well/will/
01:28:18 <kmc> dancor, GHC 7.0
01:28:19 <tolkad> what I mean is, why isn't UndecideableInstances standard?
01:28:29 <kmc> dancor, if by that you mean the IO manager
01:28:30 <tolkad> I mean, if you write an instance that doesn't halt it's your fault
01:28:38 <merijn> btw, speaking of databases: http://howfuckedismydatabase.com/
01:28:45 <kmc> tolkad, i agree actually, plus GHC will bail out after a finite number of steps anyway
01:30:57 <pelotom> merijn: haha
01:32:44 <EvanR> kmc: youre right, people do hate java. i should bring up the similarities of java and php5 next time we have a meeting on whether or not to use php
01:32:54 <kmc> haha
01:33:36 <kmc> maybe you should quit your job
01:33:53 <EvanR> i should find a new one
01:34:02 <kmc> whereabouts?
01:34:10 <EvanR> baton rouge louisiana
01:34:22 <tolkad> @quote tolkad
01:34:22 <lambdabot> tolkad says: Haskell is a cool language, but sometimes I wish it was more type safe, like PHP
01:34:44 <dancor> if i want to try ghc 7 am i likely to have more luck with 7.0.1-rc1 or head
01:34:55 <EvanR> tolkad is mad
01:35:13 <danderson> I'm pretty sure I saw research that demonstrated a positive correlation between use of PHP and incidents of getting stabbed in the face by a rabid software engineer
01:35:23 <danderson> just saying. You should be careful.
01:35:33 <kmc> EvanR, http://www.youtube.com/watch?v=1tqxzWdKKu8
01:35:55 <EvanR> not sure if i should watch youtube over stolen wireless
01:35:59 <pelotom> look at the number of PHP-tagged questions on SO... it's staggering
01:36:01 <tolkad> lol!
01:36:06 <tolkad> I defined fix using unsafeCoerce
01:36:24 <kmc> tolkad, to fake equirecursive types?
01:36:30 <tolkad> fix = (\f -> (\x -> (unsafeCoerce f :: a -> a) ((unsafeCoerce x :: (a -> a) -> a) (unsafeCoerce x :: a -> a))) (\x -> (unsafeCoerce f :: a -> a) ((unsafeCoerce x :: (a -> a) -> a) (unsafeCoerce x :: a -> a)))) :: (a -> a) -> a
01:37:09 <tolkad> I think that's what you mean
01:37:27 <EvanR> anyone have opinion about this http://en.wikibooks.org/wiki/Haskell
01:37:27 <tolkad> might not work across all implementations
01:37:41 <tolkad> but it works in GHC
01:39:21 <Saizan> you can probably reduce that to just 2 unsafeCoerce and a single type signature
01:40:13 <tolkad> Saizan: I was getting weird type errors a lot, couldn't figure out where to put them
01:41:11 <Saizan> fix :: (a -> a) -> a
01:41:12 <Saizan> fix f = (\x -> f (unsafeCoerce x x)) (\x -> f (unsafeCoerce x x))
01:42:51 <dolio> You can also reduce it to 0 unsafeCoerces and a newtype wrapper.
01:43:10 <EvanR> > let x = x + 1 in x
01:43:14 <lambdabot>   mueval-core: Time limit exceeded
01:44:07 * hackagebot mtlparse 0.1.0 - parse library using mtl package  http://hackage.haskell.org/package/mtlparse-0.1.0 (YoshikuniJujo)
01:45:28 <McManiaC> hmmm
01:45:31 <McManiaC> how do you read this?
01:45:34 <McManiaC> h :: (r\l) => {r} => {l::Int | r}
01:45:42 <Saizan> newtype UnsafeCoerce a = UnsafeCoerce { unsafeCoerce :: UnsafeCoerce a -> a }
01:45:42 <Saizan> fix :: (a -> a) -> a
01:45:43 <Saizan> fix f = (\x -> f (unsafeCoerce x x)) (UnsafeCoerce (\x -> f (unsafeCoerce x x)))
01:46:21 <merijn> danderson: My usual design/coding methodology is to assume my replacement is murderous psychopath who knows where I live. This encourages me to stay away from languages like PHP ;p
01:46:24 <Saizan> McManiaC: looking at some proposal for extensible records?
01:46:42 <McManiaC> looking at GHC source cody (PredType)
01:46:57 <McManiaC> *code
01:47:20 <EvanR> merijn: if it werent for the 'community' it would be possible to survive pretending your are writing code in an esolang
01:47:32 <EvanR> for fun
01:47:51 <Saizan> McManiaC: well that notation usually means that h will produce a record with at least a field named l whose type is Int
01:48:05 <EvanR> php decended from lolcode, decended from intercal
01:48:09 <Saizan> McManiaC: and that the rest of the record won't contain another field named l
01:48:32 <McManiaC> Saizan: ah
01:48:34 <McManiaC> ok
01:48:41 <McManiaC> never saw that before :)
01:48:49 <Saizan> (r\l) is that last constraint
01:49:39 <McManiaC> Saizan: so h would look like "h sth { l = a } = sth { l = a + 1 }" ?
01:49:43 <Saizan> McManiaC: http://research.microsoft.com/en-us/um/people/simonpj/Haskell/records.html
01:50:04 <Saizan> McManiaC: no, h doesn't take a record as an argument, it just produces one
01:50:13 <McManiaC> Saizan: oh, I see
01:50:40 <Saizan> well, it is one, since the (r\l) => {r} => parts are like typeclass constraints, which aren't usually thought of as arguments in haskell
01:51:20 <Samantha> Hello
01:51:27 <Samantha> How is everybody?
01:51:45 <Samantha> I have a question?
01:52:06 <Saizan> McManiaC: in the link i pasted the relevant part is the "Comparison with TRex" paragraph
01:52:12 <Samantha> Hello
01:52:13 <McManiaC> Saizan: but I could write something like "newtype Foo = Foo { bar :: Int }; newFoo = h" ?
01:52:19 <Samantha>  I have a question?
01:52:21 <McManiaC> with newFoo :: Foo
01:52:24 <pelotom> Samantha: out with it
01:52:29 <Samantha> ok 
01:52:33 <Saizan> McManiaC: well, this is not actual haskell
01:52:35 <kmc> merijn, i'm not sure it works that way; if your code sucks and is in PHP they're likely to blame the language
01:52:38 <Samantha> I need help with servlets
01:52:45 <kmc> Samantha, Haskell servlets?
01:52:45 <Samantha> any website
01:52:49 <Samantha> no
01:52:53 <Samantha> Java Servlets
01:52:55 <kmc> Samantha, then why are you asking in #haskell?
01:52:58 <McManiaC> Saizan: why?
01:53:11 <EvanR> kmc: the one man army who designed the system we are now fixing definitely gets a share of the blame
01:53:19 <EvanR> he was insane
01:53:21 <kmc> Samantha, you could try ##java
01:53:25 <Samantha> kmc: Maybe someone will know
01:53:27 <Samantha> ?
01:53:31 <kmc> Samantha, but it's off topic
01:53:37 <EvanR> Samantha: try the #ubuntu channel then
01:53:42 <Samantha> they have a channel for java as well
01:53:44 <Samantha> ?
01:53:45 <kmc> yes
01:53:48 <kmc> it's called ##java
01:53:52 <Samantha> oh you see 
01:53:56 <Samantha> I didnt know
01:53:57 <Saizan> McManiaC: TRex got implemented as an extension in Hugs i think, and GHC doesn't expose anything similar
01:53:58 <Samantha> thank you
01:54:03 <kmc> no problem :)
01:54:06 <kmc> good luck with your servlets
01:54:11 <maurer_> Say I have an ADT with many options, and I want to case out on it, but group them, is there a better way to do this than cascading ifs or a long case statement with helper functions?
01:54:17 <McManiaC> Saizan: so it's not actually implemented?
01:54:25 <Samantha> kmc: Why you dont like them?
01:54:40 <kmc> don't like what?
01:54:50 <Saizan> McManiaC: i thought it wasn't
01:54:52 <Samantha> Servlets
01:54:55 <Samantha> ?
01:54:56 <McManiaC> Saizan: ok
01:55:01 <McManiaC> Saizan: thanks :)
01:55:01 <kmc> Samantha, when did I say i didn't like servlets?
01:55:04 <kmc> i said it's off topic for this channel
01:55:09 <pelotom> I agree with Samantha, there was a definite note of disdain when you mentioned servlets
01:55:10 <maurer_> e.g. say I have data Foo = One | Two | Three | Four | Five, and I want the same behavior on One and Four, and Two, Three, and Five (actual example much larger) how do I do this without writing a suuper long case statement?
01:55:18 <Samantha> yeah
01:55:23 <maurer_> The only solution I've come up with is cascading ifs using Set.member or `elem`
01:55:24 <pelotom> j/k
01:55:36 <kmc> maurer_, do they actually have no constructors like that?
01:55:38 <Saizan> McManiaC: i just recognized the notation from the papers :)
01:55:40 <merijn> Samantha: Asking in #haskell whether people like Java technology is like asking a lion whether it likes vegetables, the question is just going to result in confusion and misunderstanding >.>
01:55:41 <quicksilver> maurer_: always prefer guards to cascading ifs
01:55:50 <kmc> maurer_, rather than cascading ifs you could use guards
01:55:52 <maurer_> quicksilver: Maybe I can guard it?
01:55:56 <EvanR> merijn: and mauling
01:56:00 <Samantha> kmc: because you told me good luck with your servlets
01:56:06 <merijn> EvanR: True :p
01:56:06 <Samantha> ok ok
01:56:08 <kmc> case () of _ | is14 -> ... | is235 -> ...
01:56:13 <Samantha> Sorry guys
01:56:17 <kmc> Samantha, i wasn't being sarcastic
01:56:20 <kmc> hard to tell on the internet, i know
01:56:22 <pelotom> Samantha: what's wrong with wishing you good luck?
01:56:24 <maurer_> kmc: Yeah, they're exactly like that--they're ops, and I'd like to cluster them by type signature.
01:56:28 <quicksilver> case foo of foo | foo `elem` [One,Four] -> ....; | foo `elem` [One,Three,Five] -> ....;
01:56:32 <Samantha> nothing
01:56:37 <Samantha> Thank you gays
01:56:40 <maurer_> quicksilver: Exactly what I needed. Thanks.
01:56:41 <Samantha> opsssssssss
01:56:42 <pelotom> rofl
01:56:47 <Samantha> I am so sorryyyyyyyyyyyyyy
01:56:47 <kmc> ahaha
01:56:48 <Samantha> guys
01:56:58 <quicksilver> maurer_: in a more realistic example, you might use a helper function and case on that.
01:57:00 <Samantha> i am not that good in typing
01:57:04 <Samantha> ok
01:57:11 <Samantha> I will go to sleep now
01:57:12 * hackagebot mtlparse 0.1.1 - parse library using mtl package  http://hackage.haskell.org/package/mtlparse-0.1.1 (YoshikuniJujo)
01:57:14 <Samantha> nite nite
01:57:28 <kmc> maurer_, you could use a view pattern too
01:57:52 <kmc> data Class = C14 | C235
01:58:04 <kmc> cls :: Foo -> Class
01:58:09 <kmc> bar (cls -> C14) = ...
01:58:13 <kmc> bar (cls -> C235) = ...
01:58:29 <kmc> but in some sense you've just shoved the problem elsewhere
01:59:11 <Samantha> Hello sorry
01:59:22 <Samantha> do yuo guys know what this mean
01:59:23 <Samantha> ##Java Cannot join channel (+r) - you need to be identified with services
01:59:28 <kmc> yes
01:59:36 <kmc> Samantha, http://freenode.net/faq.shtml
01:59:44 <quicksilver> maurer_: http://hpaste.org/40935/grouping_cases
01:59:45 <Samantha> can you please tell me
01:59:48 <quicksilver> maurer_: for example.
01:59:52 <kmc> see in particular "User Registration." Samantha
02:00:08 <quicksilver> maurer_: you can actually use view patterns instead of the case (classify foo), but it doesn't work out very different.
02:00:28 <kmc> i do wish we had "or" patterns, though
02:00:34 <quicksilver> so do I, in fact.
02:00:49 <Samantha> kmc: I dont understand
02:00:51 <Samantha> ?
02:00:52 <kmc> is there a ticket for it
02:00:58 <kmc> Samantha, did you read that?
02:01:04 <quicksilver> although I'd be inclined to be pernickety and require you bind the same variables in each alternative of the or pattern.
02:01:05 <Samantha> what?
02:01:09 <kmc> Samantha, I sent you a link
02:01:11 <kmc> you need to read it
02:01:16 <Samantha> ok
02:01:22 <Samantha> dont get mad at me
02:01:23 <kmc> <kmc> see in particular "User Registration." Samantha
02:01:31 <dolio> quicksilver: Isn't that a given for or patterns?
02:01:31 <Samantha> ok
02:01:41 <kmc> you can't join ##java until you have registered your nickname
02:01:42 <maurer_> quicksilver: The "classify" function is precisely what I am attempting to avoid (too many ops :/). The guards seem useful though.
02:01:47 <kmc> basically creating an account and signing in
02:01:52 <quicksilver> kmc: I don't think so; I recall a discussion in which SPJ couldn't see a reason in principle not to allow it
02:01:57 <kmc> yeah
02:01:59 <kmc> it exists in SML iirc
02:02:00 <quicksilver> maurer_: but the point is you write classify once and once only
02:02:06 <quicksilver> maurer_: and then you use it many times
02:02:15 <quicksilver> maurer_: so you document the common structure of your constructors in one place.
02:02:25 <Nikla> can any one suggest how can i define (<) operator using foldr
02:02:29 <kmc> "document" is indeed a nice word for "boilerplate"
02:02:33 <kmc> Nikla, on what type?
02:02:44 <Nikla> integers
02:02:49 <kmc> Int?
02:02:53 <quicksilver> dolio: no; more idiomatic to the haskell report would be to bind variables which didn't get mentioned to 'error'
02:02:54 <Nikla> yes
02:03:03 <quicksilver> dolio: q.v. how it handles records etc.
02:03:06 <quicksilver> dolio: but I don't like that ;)
02:03:09 <kmc> yeah neither do i
02:03:15 <kmc> Nikla, it doesn't make much sense to me
02:03:19 <kmc> can you give context?
02:04:02 <Nikla> its just a test language where i have to recursion similar to foldr and i have to define every thing using it
02:04:21 <Nikla> ~have a recursion
02:04:24 <maurer_> quicksilver: I only use this once, and the constructors are quite literally an enumeration type.
02:04:43 <quicksilver> kmc: document is a nice word for boilerplate, yes ;) But the point is that this commonality in structure probably has a semantic meaning
02:04:58 <kmc> yeah
02:05:02 <quicksilver> kmc: so it's not a stupid thing to have it documented by an injection into a structural type.
02:05:16 <kmc> if document is a nice word for boilerplate, then Rails-ish "convention" is a nice word for undocumented magic
02:05:19 <kmc> so i'll take the former
02:05:24 <kmc> tyvm
02:06:07 * kmc doesn't trust any system where identifier binding requires consulting a list of irregular English plurals
02:08:07 <Saizan> kmc: they do that?
02:08:38 <kmc> yes
02:08:44 <quicksilver> yes, they do the whole plural/singular thing for has_many database relationships
02:08:47 <quicksilver> and similar.
02:08:52 <kmc> if you make a Rails class named 'child' it knows to look for a database table named 'children'
02:09:14 <kmc> it knows this, because there is a big list of irregular English plurals included with the Rails distribution
02:09:37 <kmc> imagine "Haskell Report, Appendix C: Irregular Plurals and Facts about Cows"
02:09:39 <dolio> Wow.
02:09:53 <merijn> Anyone mind a quick logic question here since we were discussing C-H earlier?
02:09:56 <kmc> go ahead
02:10:02 <Saizan> and here i thought python frameworks were too automagic for their own good..
02:10:43 <kmc> i don't use Rails but my friends say that the magic is not documented, period
02:10:56 <kmc> if you're not in the inner circle of devs then You Don't Need To Know That
02:11:24 <kmc> reminds me of asking mildly complicated questions in #python, actually
02:11:26 <kmc> [/rant]
02:11:31 <merijn> So, my intro to predicate logic states that we assume a countably infinite set of variables and a signature consisting of a set of function symbols and predicate symbols. How ever, I can't seem to figure out what the difference between predicates and functions are supposed to be?
02:11:55 <kmc> merijn, functions take things from your universe and return other things in the universe
02:12:03 <kmc> predicates take things from the universe and are either true or not
02:12:16 <kmc> (U,U,...) -> U versus (U,U,...) -> Bool
02:12:29 <kmc> (though "Bool" has kind of a computational vibe to it, in Coq i'd say 'Prop')
02:12:42 <kmc> so if f and g are functions we can say like
02:12:57 <kmc> f(g(x),g(f(x,x)))
02:13:02 <kmc> assuming f is 2-ary and g is 1-ary
02:13:09 <quicksilver> yeah "either True or not" is a very directly classical view.
02:13:29 <quicksilver> "predicates take things from the universe and produce propositions you can discuss the provability of"
02:13:40 <tolkad> kmc: omg that magic is terrible
02:13:41 <quicksilver> might be a more intuitionistic statment
02:13:48 <kmc> yeah
02:14:07 <tolkad> kmc: thank you. I will never attempt to learn anything about rails
02:14:54 <kmc> a predicate (applied to the appropriate arguments) is a logical term, like a propositional variable, and can be combined with other logical terms using ∨, ∧, ¬, →, etc
02:15:01 <kmc> whereas those symbols have no meaning on the objects of your universe
02:15:42 <merijn> So functions will basically be substituted by their function body (which can be any term) whereas predicates are only terms without (non-propositional) variables?
02:15:54 <kmc> no
02:16:16 <kmc> we can say 3 + 3 and we can say (3 < 4) ∨ (4 < 5)
02:16:23 <kmc> and we can say ((3 + 3) < 7)
02:16:35 <kmc> but we can't say 3 ∨ 6, or (3 < 4) + 2
02:16:44 <kmc> because < is a predicate, and + is a function
02:17:15 <kmc> when you get around to actually building models for this structure
02:17:37 <kmc> you have a universe U which is some set
02:17:37 <merijn> I can see the difference, I just can't describe it or why it's there :\
02:17:47 <kmc> each k-ary predicate is a set of k-tuples, i.e. a subset of U × U × ... × U
02:18:00 <quicksilver> "functions being substituted by their function body, which can be any term" <-- this is a computational, operational, rewrite view of a function.
02:18:02 <kmc> and each k-ary function is a function of type U × U × ... U → U
02:18:07 <quicksilver> not a logical one.
02:18:08 <kmc> and yeah, functions don't have bodies
02:18:11 <kmc> they're just mappings
02:18:27 <quicksilver> in the proof theory half of logic, a function is an opaque thing
02:18:30 <quicksilver> it just "is".
02:18:33 <kmc> in fact, they're sets of (input, output) pairs, where each input value can only appear once
02:18:34 <quicksilver> you might be able to prove stuff about it
02:18:39 <quicksilver> because you might have axioms about it
02:18:39 <kmc> but that's probably not important
02:18:45 <quicksilver> and you'd prove from those axioms.
02:18:57 <quicksilver> In the model theory half of logic, a function is the normal, mathematical meaning of funciton
02:18:58 <tolkad> predicates are functions that return true or false
02:19:00 <kmc> merijn, the distinction is there because combining two values to make a third value is different from combining two values to make a fact which might be provable
02:19:05 <quicksilver> (which is what kmc just explained)
02:19:07 <kmc> that's the difference between + and <
02:19:18 <kmc> 3 + 4 is an int, 3 < 4 is a proposition
02:19:24 <kmc> tolkad, not really but kinda
02:19:27 <abi_> I am a begineer and I have a doubt regarding Haskell vs Clojure vs Scala vs Erlang ..... Why do you choose Haskell?
02:19:40 <merijn> abi_: Prettiest syntax of those four :>
02:19:42 <quicksilver> abi_: because I like using data types to structure my programs.
02:19:43 <kmc> abi_, i'm interested in all four of those languages
02:19:46 <tolkad> (<) :: Num a => a -> a -> Proposition
02:19:50 <abi_> sorry for suddenly asking
02:19:50 <kmc> abi_, you were in here earlier yes?
02:19:56 <abi_> yes
02:20:13 <abi_> i started haskell and finished the introduction part
02:20:18 <merijn> abi_: But personally 3 of those four interest me a lot (the exception is Scala, which looks a bit too dull for me)
02:20:29 <kmc> Scala has an interesting type system
02:20:40 <abi_> i came to know that closure and scala can be run on JVM and I think that its a BIG plus plus
02:20:48 <kmc> yes
02:20:53 <merijn> Not read too much about it, I figured I'd be better of sticking with Haskell and maybe learning Lisp
02:20:57 <kmc> i've been learning clojure lately, i like it
02:21:01 <kmc> merijn, which Lisp?
02:21:08 <merijn> kmc: Racket and or Clojure
02:21:10 <kmc> CL is ugly
02:21:17 <kmc> good choices, i think
02:21:46 <kmc> abi_, Haskell will provide a lot more compile-time checking than Clojure
02:21:47 <merijn> abi_: I think you can't really go very wrong with learning any of those four
02:21:51 <kmc> abi_, you know Java already yes?
02:21:54 <abi_> yes
02:21:56 <abi_> i know java
02:22:06 <kmc> it's hard to believe coming from the Java world, but in Haskell, if your program compiles, there's a good chance it works correctly
02:22:07 <merijn> abi_: And learning any of those four will make learning the others *much* easier
02:22:29 <kmc> that's simply not true of Clojure or Erlang, it's probably even less true of Clojure than Java
02:22:33 <merijn> abi_: From Java to any of them will be hard, from one of those to the rest will be easy
02:22:34 <tolkad> kmc: the problem is it's hard to get them to compile
02:22:34 <kmc> now Clojure has a lot of other things going for it
02:22:38 <kmc> yes
02:22:52 <Botje> cd /boot/
02:22:55 <Botje> uh, oops :)
02:22:55 <kmc> but compile-time errors are much nicer to work with than inexplicable behavior at runtime
02:22:59 <abi_> okk ... got it .. since i am a beginner  i think it does not matter ... i will continue with haskell
02:23:09 <kmc> abi_, yes, #haskell told you to use Haskell ;)
02:23:16 <JN__> so I should be able to randomly generate correct programs in haskell then
02:23:42 <tolkad> abi_: the real reason you should us haskell rather than any other language is because it is the best
02:24:17 <tolkad> JN__: well, excluding some unsafe functions yes
02:24:19 <merijn> abi_: Personally I don't believe in being a "language X" programmer, I believe in learning to program independent of language. Haskell stuff applies to a lot of other languages, which as a result will then be easier to learn
02:24:27 <MiggyX> can you treat IO as sort of like an infinite list?
02:24:33 <abi_> understood ... actually I just worried because I though that JVM support of scala and clojure will be the biggest bonus for those languages and not haskell ... may be? (i am a beginner)
02:24:42 <tolkad> JN__: if you include stuff like socket interface then probably not
02:24:45 <merijn> abi_: Depends on what you want to do
02:24:56 <kmc> abi_, oh, is your goal to learn the most *popular* of the four?
02:25:14 <nlogax> clojure runs on .net too, i think
02:25:29 <kmc> i'm an advocate of just jumping in rather than asking newspaper reporter questions
02:25:32 <merijn> abi_: Do you want to master programming, quickly develop useful programs, bit of both. Web programming or systems code, etc
02:25:34 <MiggyX> abi_: I read a great doc last night which basically said that the technology you have that your competitors don't understand, is a very powerful asset
02:25:46 <kmc> MiggyX, "beating the averages"?
02:25:46 <RichardBarrell> MiggyX: please read this paper by Simon Peyton Jones. http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/
02:25:53 <abi_> _merijn : well said .. one must not learn to be a "xyz language programmer" ... thanks :)
02:25:56 <MiggyX> kmc: that's the one :D
02:25:58 <kmc> :)
02:26:03 <kmc> don't take paul graham too seriously
02:26:05 <kmc> but i do like that essay
02:26:17 <abi_> understood
02:26:19 <MiggyX> It was a good read, and he made some good points
02:26:40 <RichardBarrell> MiggyX: it's called "Tackling the awkward squad" and, among other things, it presents a couple of different ways to think about IO in Haskell.
02:26:43 <JN__> miggyx:  ahh nice argument.  so choosing obscure, difficult to learn/understand programming languages would give you a competitive edge
02:26:53 <kmc> he made one successful web app 15 years ago when there was no credible competition, and now considers himself an expert on programming language design, entrepreneurship, and 'hacker culture'
02:27:05 <tolkad> JN__: If you removed any sort of IO from Java, you could still encounter exceptions when casting or encountering null or attempting to access an index beyond the end of an array etc.
02:27:14 <tolkad> JN__: haskell doesn't have these sort of problems
02:27:16 <merijn> abi_: I mean, if your goal is to quickly develop useful programs without much learning I would recommend python if you come from Java. It will open your eyes. If you don't mind investing time and learning haskell will open your eyes even further and blow your mind while you're at it.
02:27:23 <kmc> JN__, it only works if it's actually a good language
02:27:39 <MiggyX> JN__: no, picking a language that allows you to solve your own problems most effectively gives you the edge, especially if no one else "gets it "
02:27:44 <kmc> otherwise we'd see massively successful startups using Malbolge
02:28:03 <abi_> _merijn_: thanks a lot ... got the message ... i will continue with haskell 
02:28:11 <kmc> JN__, you asked about randomly generating correct Haskell programs but you didn't say what 'correct' means
02:28:14 <merijn> kmc: Is that the one where the compiler can't be implemented in the language? Or something like that
02:28:31 <danderson> kmc: I've always operated on the assumption that some software out there is, in fact, in Malbolge.
02:28:34 <kmc> merijn, that's the one where writing 'hello world' required months of automated genetic algorithm search
02:28:35 <tolkad> kmc: I assumed he meant they don't crash (except by exausting resources)
02:28:44 <danderson> I'm dreading the day that I find the one.
02:28:45 <JN__> kmc:  yeah I was wondering if anybody would pick up on that.  :)  it's like "42".. the hard part is knowing the question
02:28:52 <McManiaC> whats the {-# SOURCE #-} pragma?
02:29:01 <kmc> McManiaC, used by GHC to handle circular imports
02:29:10 <kmc> see ghc manual
02:29:26 <danderson> merijn: it's even better than what kmc said: the major breakthrough was when someone studied Malbolge as a cryptosystem rather than a language
02:29:46 <danderson> and found a cryptographic flaw that could be exploited (short cycles in the opcode encryption scheme)
02:29:50 <kmc> JN__, i recommend http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
02:30:10 <danderson> from there, hello world was implemented
02:30:15 <McManiaC> kmc: k, thanks
02:30:16 <danderson> and much later, a loop construct and 99 bottles.
02:30:30 <merijn> >.>
02:30:43 <arcatan> danderson: was the 99 bottles really done with a loop?
02:30:47 <merijn> I'm partial to evolutionary computing myself
02:31:21 <McManiaC> kmc: ah, and that's what those .boot files are for :)
02:31:24 <kmc> yes
02:31:25 <danderson> arcatan: apparently, yeah. Not sure how you'd prove it though, but the paper that studied malbolge as a cryptosystem did suggest the way to construct a loop using the discovered weakness
02:31:26 <Maddas> JN__: The "if it compiles, it works" statement is somewhat overused (IMHO). But it's a remarkably common thing to notice when learning Haskell.
02:31:27 <kmc> it's a hack
02:31:34 <McManiaC> I see
02:31:37 <Maddas> JN__: Obviously a type does not describe the function completely :-)
02:31:39 <merijn> But I need to stop procrastinating and fight the dragon...I mean Extended Calculus of Construction...
02:32:05 <kmc> yeah, i say that well-typed Haskell code "usually works" or "works more often than Java"
02:32:08 <kmc> not that it definitely works
02:32:10 <danderson> Maddas: the way I put it is "If it compiles, any problems will be the serious kind"
02:32:21 <danderson> rather than "doh, NullPointerException" or "ugh, segfault"
02:32:24 <kmc> yes, which is why there's the moment of dread after the first compile
02:32:35 <kmc> because you know that the compiler found most of your easy bugs
02:32:42 <kmc> though a hard-to-find bug can have a trivial source
02:32:55 <kmc> i spent many hours searching for a bug that turned out to be one character
02:32:58 <JN__> I usually don't compile or run a program until I know it's correct
02:33:01 <Maddas> danderson: Indeed, it's much more frequently logical errors ("I really didn't think this algorithm through") as opposed to typos or copy/paste errors.
02:33:02 <kmc> i had "let x' = ... x ... in ..."
02:33:11 <kmc> well, x' has the same type as x, and looks nearly the same, and i used one where i should have used the other
02:33:16 <Maddas> JN__: Then, my friend, you tower above all of us.
02:33:24 <Maddas> JN__: You're right up there with Knuth :-)
02:33:24 <danderson> Maddas: exactly. And even those I find myself doing less in Haskell
02:33:30 <sbrg> Maddas: Hehe.
02:33:36 <danderson> the type system really forces me to have something that makes some kind of sense before I'm allowed to compile it.
02:33:41 <sbrg> JN__: You simulate the execution of the program in your head?
02:33:50 <danderson> and by extension, forces me to have a halfway reasonable design
02:34:01 <JN__> sbrg:  well, simulate is so.. mechanical.  but yeah, I reason that it's correct.
02:34:02 <merijn> sbrg: Formal verification using Coq and/or mu calculus :p
02:34:03 <sbrg> Maybe I am a mere mortal man, but running the stuff I'm writing is a crucial part of testing whether it works
02:34:07 <Maddas> JN__: (In case you don't catch the reference, Knuth stated "Beware of bugs in the above code; I have only proved it correct, not tried it.")
02:34:15 <dancor> simulating and proving correctness are very different!
02:34:26 <merijn> I think you can extract haskell code from Coq proofs, right?
02:34:35 <kmc> it's funny that Haskellers are considered arrogant elitists, when the emphasis on static typing is all about acknowledging that you will make mistakes
02:34:53 <Maddas> All users of obscure languages are usually considered arrogant elitists.
02:34:55 <kmc> and obviously Haskell code needs testing too, nobody seriously claims otherwise
02:35:03 <Maddas> You'll hear the same of Lisp programmers, and it's not for their use of static type systems.
02:35:05 <kmc> but you can spend a lot less time writing tests
02:35:08 <sbrg> kmc: Haskellers are considered arrogant elitists? What about freenode C++ers, then?
02:35:18 <kmc> and focus on the important ones
02:35:22 <Maddas> (You'll hear the same of Perl programmers, you just need to ask the right people)
02:35:30 <sbrg> Perhaps
02:35:32 <kmc> rather than writing 500 tests to assert that if f is passed an int it will return an int
02:35:44 <Maddas> kmc: Well, you just let QuickCheck write those :-)
02:35:44 <kmc> also, Haskell has some clever testing frameworks
02:35:48 <kmc> yeah
02:36:01 <danderson> you also have quickcheck
02:36:06 <danderson> which is really the crack of testing.
02:36:07 <Ke> you should just go where the real science is and learn FORTRAN77!
02:36:17 <sbrg> danderson: Indeed it is
02:36:18 <Jafet> @check (\x -> typeOf x == typeOf (succ x))
02:36:19 <lambdabot>   "OK, passed 500 tests."
02:36:20 <danderson> why test specific inputs when you can test thousands of them? :)
02:36:21 <Maddas> But the static type system doesn't work as well for all approaches to development. As danderson said, Haskell forces you to have an idea of the program before you're allowed to compile it. This is not necessarily an advantage, depending on how you prefer to work.
02:36:27 <dancor> i'm still waiting for agda to mature
02:36:31 <kmc> @check \xs -> xs == reverse xs
02:36:32 <lambdabot>   "OK, passed 500 tests."
02:36:35 <merijn> Ke: You think you're joking, but my dad just finished teaching a class on Fortran77 :D
02:36:46 <kmc> yes, fortran is still quite popular in scientific computing
02:36:49 <kmc> for reasons which are not crazy
02:36:52 <dancor> this haskell thing is just a stopgap
02:36:53 <Maddas> kmc: And banking.
02:36:56 <danderson> Maddas: I'm a bit of an tinkerer in my approach to software, and even for that I find that Haskell helps
02:37:08 <kmc> fortran is still a good choice for, well, a formula translator
02:37:11 <merijn> kmc: And running nuclear power plants apparently
02:37:28 <danderson> when I tinker, I'm looking for a nice solution. Whether I get there by running a buggy program or failing to compile it is really not important.
02:37:33 <kmc> if you consider it a DSL for turning mathematical expressions into very fast code, it's still filling its purpose
02:37:37 <MiggyX> merijn: better than COBOL powered nuclear power plants
02:37:42 <Maddas> danderson: I found it helps relative to things like C++, which have neither the safety nor the 'dynamicism' of other languages, but I often feel more comfortable doing REPL-style development in something like CL.
02:37:55 <danderson> but by designing the types first, I find that the resulting APIs are usually better than if I start from the implementation, like I would have to in other languages
02:37:55 <Maddas> I see the appeal to either approach, though.
02:38:03 <merijn> Maddas: Same
02:38:17 <kmc> i don't have that much trouble doing incremental development in Haskell, though I can think of dozens of ways to make it better
02:38:25 <danderson> Yeah, I like the CL REPL as well, for certain problems.
02:38:38 <kmc> again, you have to ask how much of that incremental tinkering was chasing down trivial type errors
02:38:40 <merijn> I usually start by thinking a week on the types of my global functions in Haskell, which dramatically increases my code quality
02:38:47 <danderson> I don't really have a feel about which problems are better suited to which approach though, I just sort of gravitate to one or the other.
02:39:03 <Maddas> (I agree that using something like a CL REPL to arrive at 'good' code requires more practice and/or discipline than Haskell, though.)
02:39:13 <merijn> To quote my favorite #haskell remark: mpeter: the quality of my code increased drastically when i realized i should stop telling the computer to do things which were stupid.
02:39:16 <Maddas> danderson: Yeah.
02:39:36 <sbrg> merijn: Haha.
02:39:38 <Maddas> kmc: You also have to chase down trivial type errors in Haskell.
02:39:40 <MiggyX> lol
02:39:55 <danderson> Maddas: but the compiler helps you!
02:39:58 <kmc> Maddas, but you get a line number and an explanation of the error (sort of)
02:40:08 <kmc> it's not a REPL thing
02:40:10 <Maddas> Sure, but compile-time debugging isn't free.
02:40:13 <danderson> instead of having the runtime vomiting in your face twenty call frames down
02:40:14 <kmc> yeah
02:40:24 <kmc> but it's pretty damn cheap
02:40:50 <kmc> compared to having to invent test cases, type them in, let it run for a while, see it fall over, and then try to figure out what happened
02:40:52 * Maddas is just pointing out the disadvantages to keep the discussion straight, not because he doesn't agree with the advantages :-)
02:41:23 <JN__> good talk.. must sleep now
02:41:28 <JN__> see you guys
02:41:47 <danderson> and on the topic of designing the types in haskell... Is it possible for me to hide the implementation of a typeclass from users of a module?
02:42:00 <kmc> you mean the set of methods?
02:42:16 <danderson> prevent external users from implementing their own instance of the type class.
02:42:32 <kmc> yeah, just hide the names of the methods
02:42:34 <danderson> the existence of the type class is purely an internal matter, though it'll probably unfortunately leak in the API.
02:42:36 <kmc> Data.Array.MArray does this
02:42:46 <kmc> you don't even have to export the class itself
02:43:00 <kmc> though i guess that prevents your users from writing type signatures
02:43:37 <danderson> I'm okay with that. The type class is an implementation detail of a monad type, which I'm going to newtype
02:44:06 <danderson> but I don't think I can hide the existence of the type class with that newtype. It'll have to be MyClass m => ..., right?
02:44:43 <Jafet> unsafeCoerce
02:44:56 <danderson> yeah, without being evil, I should add :)
02:45:02 <quicksilver> you can use a GADT to hide a typeclass entirely
02:45:37 <quicksilver> data HideFoo where MkHideFoo :: (MyClass m) => ... ... -> HideFoo
02:45:58 <quicksilver> (and then don't export the constructor, obviously)
02:46:00 <Jafet> Well, unsafeCoerce isn't any more evil than hiding a constraint like that
02:46:15 <Jafet> But quicksilver has the morally correct solution
02:46:36 <danderson> hmm
02:46:59 <danderson> maybe I just shouldn't hide it. There may be something to be gained from exposing it.
02:47:04 <quicksilver> you have to know what you're doing to hide a typeclass context with unsafeCoerce : some places in which a typeclass appears, unsafeCoercing it away will make code which crashes.
02:47:11 <danderson> but thanks for the pointer on how to seal it if I need to
02:47:36 <quicksilver> (because the typeclass context stands for a dictionary passed as a parameter/witness)
02:47:45 <quicksilver> you have to know which places ;)
02:47:47 <kmc> yep, that's terrible
02:48:16 <kmc> i like the GADT approach, can't you stuff the GADT value in with your newtyped monad value
02:48:22 <kmc> (not a newtype anymore, natch)
02:48:59 <danderson> possibly. I've never done GADTs, so I need to meditate on them first
02:49:00 <kmc> data Foo where MkFoo :: (MyClass m) => UnderlyingThing m -> Foo
02:49:07 <danderson> and 3am is no time to be meditating on type constructs.
02:49:20 <kmc> it's the best time!
02:50:03 <quicksilver> danderson: this is not really using GADTs
02:50:13 <quicksilver> it's a quirk of GHC that GADT syntax permits typeclass hiding
02:50:20 <quicksilver> whilst normal ADT syntax does.
02:50:22 <quicksilver> doesn't.
02:50:33 <kmc> the part where m is not mentioned in the result type makes it also an existential
02:50:46 <kmc> which might be a problem for combining these values
02:50:47 <quicksilver> true.
02:50:56 <quicksilver> but you can do
02:50:57 <kmc> i think you want to expose m to the user, but hide the constraint
02:51:01 <quicksilver> right
02:51:05 <quicksilver> you don't *have* to hide the m ;)
02:51:09 <quicksilver> as I was about to say.
02:51:40 <quicksilver> danderson: some argue it's a bug in the haskell98 spec that putting a constraint on a constructor doesn't do what you'd expect.
02:51:45 <quicksilver> certainly the haskell98 behaviour seems rather useless.
02:56:27 <merijn> Sounds like haskell needs to implement views :p
02:58:42 <kmc> GHC has view patterns
02:58:51 <kmc> but they're not as nice as some proposals
02:59:36 <merijn> I only encountered them in the Philip Wadler paper, haven't seen any implementation/proposals yet
03:00:18 <merijn> Any discussion of GHC's implementation anywhere?
03:00:25 <kmc> ah, the haskell prime trac has a big writeup of alternatives
03:00:36 <kmc> what ghc supports is documented in the user's guide
03:19:38 * hackagebot timeplot 0.2.2 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.2 (EugeneKirpichov)
03:25:41 * hackagebot AC-EasyRaster-GTK 1.1.3 - GTK+ pixel plotting.  http://hackage.haskell.org/package/AC-EasyRaster-GTK-1.1.3 (AndrewCoppin)
03:44:47 * hackagebot language-java 0.1.0 - Manipulating Java source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/language-java-0.1.0 (NiklasBroberg)
03:46:33 <Saizan> :O
03:47:05 <kmc> nice
03:47:34 <Saizan> ETA for the java compiler?
03:48:21 <kmc> zwanzig minuten
03:49:52 <Jafet> It will be just in time
03:50:52 <mornfall> How do I find out which was the last HP with GHC 6.10?
03:50:55 <mornfall> Other than trial and error...
03:51:41 <mornfall> Ok, I see (from the roadmap, saying 2010.2.x is the first to include GHC 6.12:
03:54:23 <SenseiScalps> hi new comer here and generally to haskell. this might put the cuts among the pigeons but here it is: give me 1 reason why should i choose haskell over python.
03:54:36 <mornfall> Hm. Or is 2010.1.0.0 a beta of 2010.2?
03:54:39 <mornfall> I am... confused.
03:54:40 <merijn> SenseiScalps: Depends on your goal
03:54:56 <SenseiScalps> genereally speaking and not money for sure
03:55:17 <kmc> SenseiScalps, with Haskell, if your code compiles it is likely to work correctly
03:55:18 <mornfall> Python and Haskell are... very different.
03:55:36 <merijn> SenseiScalps: The obvious answer in #haskell is going to be haskell is better. But whether it actually is better and if you should use it depends on what kind of programming you intend to do and how much you are willing/interested to learn
03:55:41 <kmc> with Python there is almost no compile-time checking, you might have some latent bug hit after hours or days
03:55:52 <kmc> that is just one reason, they're very different languages and can't be compared in simple terms
03:56:03 <merijn> Python and haskell have fundamentally different and incompatible world views, each having their own valid applications
03:56:10 <kmc> SenseiScalps, i do recommend learning Haskell even if you don't plan to use it much; it tends to expand the way you think about programming in general
03:56:38 <SenseiScalps> kmc this is a good reason
03:56:40 <mornfall> kmc: On the other hand, it might make for a lot of suffering when you end up programming python. Maybe needless, even.
03:56:55 <kmc> i don't know, Python is flexible enough to absorb most Haskelly tricks
03:56:55 <quicksilver> SenseiScalps: "Types"
03:57:09 <kmc> knowing Haskell well will make C++ and Java feel like a prison though
03:57:22 <merijn> SenseiScalps: I agree that learning haskell will teach you lots of things about programming you never realized you didn't know
03:57:32 <SenseiScalps> your commends sound interesting enough
03:57:34 <donri> SenseiScalps: The type system. The natural composability of functions.
03:57:36 <kmc> Python and Ruby fans often hate on static typing but what they're really reacting to is the general terribleness of C++ / Java type systems
03:57:37 <SenseiScalps> comments
03:57:42 <mornfall> kmc: Actually, I do a lot of C++ and it's not too bad. I prefer Haskell, but it's not really that bad. But C, that *is* bad.
03:57:50 <merijn> mornfall: You're crazy
03:57:51 <kmc> Haskell has a very different approach to static typing, shared by SML and OCaml and not much else (in the mainstream)
03:57:53 * hackagebot hamlet 0.6.0 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.6.0 (MichaelSnoyman)
03:57:55 * hackagebot persistent 0.3.0.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.3.0.1 (MichaelSnoyman)
03:57:57 * hackagebot yesod 0.6.0.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.6.0.2 (MichaelSnoyman)
03:58:03 <kmc> mornfall, i feel totally opposite, C is very minimal, what you see is what you get, but it's sane and consistent
03:58:06 <merijn> I *love* C (some warts aside), but C++ is awful >.>
03:58:21 <kmc> C++ is... madness
03:58:23 <donri> SenseiScalps: Few things haskell got wrong IMO: global imports by default, clunky record syntax
03:58:23 <SenseiScalps> ok lets put it another way. what is very good for?
03:58:33 <kmc> what is Haskell very good for?
03:58:37 <SenseiScalps> yes
03:58:42 <kmc> implementing other languages
03:58:46 <kmc> manipulating structured data
03:58:51 <kmc> concurrency and parallelism
03:58:52 <mornfall> kmc: C is very poor at expressing abstractions.
03:58:55 <SenseiScalps> i program in c++, c, python c#
03:59:02 <kmc> in GHC Haskell you can spawn 100,000 threads easily
03:59:04 <SenseiScalps> i see
03:59:04 <Jafet> Printing primes and the fibonacci sequence
03:59:05 <kmc> have them all do concurrent network IO
03:59:09 <kmc> @quote _pizza_
03:59:09 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
03:59:24 <kmc> SenseiScalps, it's a general purpose language, it doesn't have one specific niche
03:59:37 <kmc> SenseiScalps, you might like http://www.haskell.org/haskellwiki/Haskell_in_industry
03:59:43 <kmc> Google uses it to optimize layout of virtual servers
03:59:47 <kmc> Facebook uses it to refactor PHP code
03:59:55 <SenseiScalps> ok what is the best way to start?emacs user
03:59:59 <kmc> a bunch of banks use it to model financial derivatives contracts
04:00:06 <kmc> @where LYAH
04:00:06 <lambdabot> http://www.learnyouahaskell.com/
04:00:08 <kmc> ^^^^ SenseiScalps
04:00:13 <kmc> your choice of editor does not matter much
04:00:17 <SenseiScalps> cool / book?
04:00:19 <kmc> just get the haskell mode for emacs
04:00:26 <merijn> SenseiScalps: Haskell is very good at constructing abstractions and data structures, it will teach you to think at a different level of abstraction. The strong typing has relation to formal verification and related things to verify a program is correct and bug free
04:00:34 <kmc> i'd run emacs in one terminal, and ghci in another
04:00:44 <donri> You run emacs in terminal? o_O
04:00:48 <SenseiScalps> lol
04:00:54 <Jafet> Or ghci in emacs!
04:00:55 <kmc> SenseiScalps, the big thing to understand is that Haskell is very different, and learning is slow.  you won't be writing full apps from day one
04:01:01 <merijn> Learn You a Haskell and when you grok that Real World Haskell has some more practical info on stuff like sockets
04:01:04 <SenseiScalps> real world haskell is online i see.. 
04:01:07 <kmc> yeah, both are
04:01:12 <kmc> both great books, very different in style
04:01:15 <kmc> see which one you like :)
04:01:21 <kmc> and of course feel free to ask questions here
04:01:33 <merijn> donri: What's odd about that? I exclusively use terminal version of vim on OSX
04:01:38 <SenseiScalps> cool i preger turning pages though
04:01:42 <SenseiScalps> so i might buy one
04:01:44 <kmc> donri, for everything other than Agda yeah
04:01:46 <SenseiScalps> lol
04:01:55 <kmc> though, i use vim now anyway
04:02:13 <kmc> terminal is easier to manage with other things, i can detach them with screen, no change in workflow over ssh, etc
04:02:13 <SenseiScalps> nice community here .. quite crowdy here
04:02:16 <SenseiScalps> didnt expect that
04:02:19 <donri> merijn: Slapping a GUI on a terminal is a hack. I hate curses and anything like it. I use gvim with toolbars and menus disabled.
04:02:43 <merijn> SenseiScalps: Yes, though at time the conversation here can get...rather high brow
04:02:43 <kmc> yes i know emacs supports screen-like detach, it also duplicates every other feature of my OS, but i don't care to learn the less general tool
04:03:07 <Twey> donri: I run emacs in a terminal.
04:03:11 <kmc> my use of emacs was pretty primitive but i was able to switch to my own editor and then to vim (and occasionally to nano) with little disruption
04:03:29 <SenseiScalps> so thanks you guys a lot for your ideas and commnents. I definitely give it a try and feedback.
04:03:31 <merijn> SenseiScalps: Zygohistro prepromorphism this and Curry-Howard-DeBruijn isomorphism that. But as long as you ignore that people are plenty helpful to newbies
04:03:35 <donri> Twey: Xþ
04:03:45 <kmc> don't ignore it!
04:03:47 <kmc> ask questions!
04:03:49 <Twey> I run everything important in a terminal, so I can SSH in.
04:03:49 <kmc> we'll explain i promise
04:03:58 <kmc> but yeah, there can be lots of prerequisites
04:04:02 <SenseiScalps> thanks..
04:04:07 <donri> Twey: Yea because you can't do X over ssh OH WAIT
04:04:18 <Jafet> It's only the high brow people who tack on de Bruijn's name
04:04:19 <kmc> i'm always amused by the reddit trolls who don't realize that zygohistomorphic prepromorphism is a joke
04:04:22 <SenseiScalps> bye for now
04:04:29 <kmc> Jafet, by which you mean the Dutch?
04:04:31 <merijn> Jafet: Or Dutch people :p
04:04:31 <Twey> donri: It's kind of tricky from Windows.
04:04:41 <donri> Problem located. :D
04:04:51 <donri> Also: VNC?
04:04:52 <Jafet> Yeah, the dutch have a good history of wanting everyone else to program like them.
04:04:53 <kmc> nl is a pretty classy place though
04:05:00 <kmc> let's eat magic brownies and go to the rijksmuseum
04:05:01 <Twey> donri: Not allowed to install software.
04:05:09 <donri> But you have putty?
04:05:17 <Twey> donri: Doesn't need installing
04:05:21 <merijn> Who needs weed if you have lambda calculus?
04:05:22 <donri> VNC does?
04:05:30 <Twey> All the VNC clients I know of do
04:06:34 <kmc> at Bell Labs they used VNC for everything
04:06:38 <kmc> with rfid badges
04:06:45 <kmc> so you could walk up to any computer and it would bring up your session
04:06:54 <kmc> kinda magic
04:06:56 <merijn> That's awesome
04:07:08 <donri> Frustrating when you need to access a different session
04:07:09 <Twey> Clever
04:07:11 <donri> Or when someone steals your badge
04:07:12 <Twey> Heh
04:07:16 <kmc> i'm sure there was some override
04:07:28 <donri> I love it when people insist on using fingerprint scanners for security.
04:08:12 <donri> Even better that people have demonstrated that you can lift someones fingerprint *from the scanner*.
04:08:15 <kmc> vnc has that java web client that doesn't need installing but eh, java
04:08:21 <kmc> donri, from the press kind, yeah
04:08:24 <kmc> what about the swipe kind?
04:08:42 <Twey> donri: Using a Gummy Bear.
04:08:57 <donri> Sounds better. Still, fingerprints ≠ changable and hey you can just cut someone's thumb of.
04:09:15 <Twey> Of course, the only real security is based on brainwaves..
04:09:16 <kmc> donri, IBM did a study, they concluded a chopped off thumb would only be usable for ~10 min
04:09:26 <kmc> i'd hate to be the intern on that project
04:09:30 <Jafet> I wonder how many chopped off thumbs they tried
04:09:32 <haskellElephant> @pl \x xs -> xs ++ map (x: ) xs) 
04:09:32 <lambdabot> (line 1, column 28):
04:09:32 <lambdabot> unexpected ")"
04:09:32 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
04:09:33 <merijn> Twey: What if you have an epiphany and will never be the same?
04:09:35 <donri> xD
04:09:42 <haskellElephant> @pl \x xs -> xs ++ map (x: ) xs
04:09:42 <lambdabot> ap (++) . map . (:)
04:09:55 <donri> kmc: Just hit the guy so he passes out and bring his whole person?
04:10:08 <kmc> yeah
04:10:09 <donri> Or swipe a print of any surface the person have touched.
04:10:15 <kmc> or drug him
04:10:23 <Jonny> Hi
04:11:05 <donri> It's funny how they insist on high tech authorization technologies in all scifi's *and* at the same time display how easily circumvented they are when a villain/hero is faced with it.
04:11:07 <Jafet> The obvious way to prevent leaving your print around is to laminate your thumb
04:11:11 <Twey> merijn: You're screwed :þ
04:11:15 <Jonny> Is there an easy way to make haskell work in degrees not radians?
04:11:29 <kmc> donri, funny, but seems quite like the real world
04:11:31 <Twey> Jonny: No.
04:11:34 <donri> The importance is not how secure it is in practice, rather how high tech and complicated it is.
04:11:37 <Twey> Jonny: If you need degrees, convert.
04:11:53 <kmc> Jonny, i wasn't aware Haskell had an opinion about those, generally.  is there a particular function like cos you're trying to use?
04:12:20 <Jafet> Lots of degrees have gone into haskell, so there aren't many left for you to use.
04:12:41 <Twey> toDeg = (*) $ 180 / pi
04:12:43 <Jonny> yeah im trying to make something like sin 180 = 0, but haskell is giving the radians answer of -0.801...
04:12:50 <Jonny> thanks
04:12:54 <donri> Jafet: Problematic when you need to use your print for log in.
04:13:02 <kmc> @let degree = (.((pi / 180)*))
04:13:03 <lambdabot>  Defined.
04:13:06 <kmc> > degree cos 90
04:13:07 <lambdabot>   6.123233995736766e-17
04:13:10 <Twey> Jonny: But radians are better.  You should use them.  >.>
04:13:12 <kmc> > degree sin 180
04:13:13 <lambdabot>   1.2246467991473532e-16
04:13:14 <Jafet> donri: an optical scanner will work fine, you just won't leave your print on it
04:13:15 <donri> I have this great idea for authorization: how about, wait for it, pass phrases?
04:13:24 <kmc> > degree sin 0
04:13:25 <lambdabot>   0.0
04:13:28 <Twey> That's an awful lot of brackets
04:13:30 <kmc> > degree sin 90
04:13:31 <lambdabot>   1.0
04:13:32 <merijn> donri: Naah :p
04:13:39 <donri> > o_O
04:13:40 <lambdabot>   Not in scope: `o_O'
04:13:42 <donri> :(
04:13:57 <Jonny> degree sin 180
04:14:00 <merijn> Public keys in chips embedded in your body!
04:14:06 <Jonny> oh it only works for you kmc :P
04:14:11 <sbrg> > let o_0 = "*_*" in o_0
04:14:12 <lambdabot>   "*_*"
04:14:12 <kmc> no you have to use >
04:14:17 <kmc> > 2 + 3
04:14:18 <lambdabot>   5
04:14:23 <Jafet> I suspect that will have physiological security implications, merijn
04:14:25 <donri> merijn: Same issues as above.
04:14:28 <Jonny> > degree sin 180
04:14:29 <lambdabot>   1.2246467991473532e-16
04:14:31 <merijn> True
04:14:36 <Jonny> shouldnt that be 0?
04:14:47 <merijn> People are notoriously bad at remembering pass phrases, though
04:14:49 <int-e> merijn: just what we need, more incentives for dismembering people.
04:14:50 <sbrg> :t degree
04:14:50 <lambdabot> forall a b. (Floating a) => (a -> b) -> a -> b
04:14:53 <kmc> Jonny, floating point arithmetic is imprecise
04:15:02 <Jafet> > degree sin 180 :: CReal
04:15:03 <lambdabot>   0.0
04:15:05 <kmc> hehe
04:15:27 <kmc> Jonny, same as every other language
04:15:30 <Jafet> > degree sin (180 * 10**1000 - 1) :: CReal
04:15:31 <donri> merijn: Use a pass phrase manager/generator with a master.
04:15:34 <lambdabot>   mueval-core: Time limit exceeded
04:18:05 <Jonny> I wish I could use radians but the specification wont allow it :(
04:33:00 <osaunders> Hayoo is down.
04:55:15 * hackagebot hakyll 2.4 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-2.4 (JasperVanDerJeugt)
05:33:35 <chudy_michef> hello. quick question - hackage.haskell.org has Haskell Platform download for Mac OS X Leopard and Snow Leopard, but apparently not Tiger. Do I need to upgrade to Snow Leopard to use the Haskell Platform?
05:37:02 <chudy_michef> Is something wrong with my irc client? I can't see anyone talking here.
05:37:45 <dino-> chudy_michef: Can you see this?
05:38:00 <chudy_michef> dino: yes
05:38:30 <dino-> As far as your question about Haskell Platform on Mac, I don't know.
05:38:44 <chudy_michef> Dino: okay. Are we the only people here??
05:39:32 <dino-> Looks like nobody has been talking for a bit. But there's a lot of people connected.
05:39:34 * hackagebot AC-Terminal 1.0 - Trivial wrapper over ansi-terminal.  http://hackage.haskell.org/package/AC-Terminal-1.0 (AndrewCoppin)
05:40:05 <benmachine> chudy_michef: there are a lot more people in #haskell than there are people who talk
05:40:11 <silver> chudy_michef, no, but I can't afford mac
05:40:55 <benmachine> chudy_michef: and people mostly won't say anything if they can't answer your question :P
05:41:02 <chudy_michef> aha. it's just I was here the other night and the place was buzzing... (wrong time of day I guess!)
05:41:53 <Entroacceptor> yes
05:42:49 <chudy_michef> silver: I couldn't really afford one either - it was one of my more reckless decisions.
05:43:21 <Entroacceptor> I'd flame about macs, but the log is public...
05:44:04 <silver> Entroacceptor, lets go #haskell-blah  !
05:45:19 <chudy_michef> Thanks anyway. I'll try again in a few hours.
05:48:42 <gio123> f is a 1 arity symbolo which has type sigma—>sigma, f is 2 arity and has type sigmaxsigma —>sigma. if f is a constant (0 arity symbol) what ill be its type?
05:50:23 <hpc> gio123: homework?
05:50:29 <gio123> no
05:50:52 <gio123> I think it has to be sima?
05:51:03 <hpc> i would think so
05:51:16 <Entroacceptor> I don't have a clue about sigma calculous
05:51:22 <hpc> i am not especially genius at these things
06:16:50 <merijn> The calculus of constructions is reasonably the same as λP (i.e. dependently typed lambda calculations)?
06:16:59 <merijn> s/calculations/calculus
06:18:03 <arcatan> is it known bug that haddock fails with files that use quasiquoting?
06:18:09 <arcatan> is there a workaround?
06:19:32 <arcatan> hmm, my haddock is old. maybe i'll update it first.
06:20:36 * quicksilver refrains from making some joke about the smell of old haddocks.
06:20:48 <dolio> merijn: The calculus of constructions has all the features of F_omega, in addition to dependent types.
06:22:34 <arcatan> no, still happens with 2.8.1
06:23:42 <merijn> dolio: That would help if I had any idea what F_omega was :p
06:24:37 <dolio> F adds types like 'forall a. ...'
06:24:59 <dolio> F_omega adds higher-kinds.
06:25:07 <dolio> And, so, type functions.
06:25:51 <Philippa> I think I'd put it the other way round, myself
06:26:07 <Philippa> as it's possible to have higher kinds but nothing but ADTs using them
06:26:20 <merijn> dolio: My problem is that my background is extremely minimal so I have trouble figuring out what I need to know without a wild reference goose chase
06:26:35 <Philippa> whereas F_omega very definitely includes a reduction rule
06:27:14 <dolio> Reading about the lambda cube is probably a good start.
06:27:23 <Philippa> merijn: read TAPL?
06:27:32 <Philippa> if you want to skip the proofs in it, that's fine
06:27:52 <merijn> I'm familiar with dependently typed lambda calculus, but I have no clue how this relates to CoC, which I need to figure out to understand ECC which I need to understand the epigram papers >.>
06:28:20 <merijn> Philippa: No, its on my to read list, but I probably won't get around to it for a while
06:29:36 <Philippa> if you're reading papers now, you're getting close to the point where you'll have covered most of the content and get comparatively little out of it
06:30:43 <merijn> Philippa: I started with course notes on type theory and some intro to type theory papers given to me by a professor
06:31:13 <merijn> My main problem seems to be that a lot of terminology I'm used to is different from the terminology I encounter in papers
06:32:50 <EvanR-work> i couldnt sleep because i kept having visions of trying to story algebraic data in a mysql database
06:32:55 <EvanR-work> store*
06:33:40 <Philippa> EvanR-work: it ought to be easy, the algebra in question should be just another datatype...
06:33:46 <merijn> Hmm, seems I've covered only 2 of the three lambda cube axes, never seen type operators though. So looks like I need to start there and continue on the rest of my CoC -> ECC -> epigram journey from there
06:34:18 <merijn> So, any good "intro to type operators" papers? :p
06:34:30 <dino-> What does it mean if you get a zlib premature end error from `cabal update` ?
06:34:46 <EvanR-work> Philippa: what about infinite data
06:35:11 <dolio> Didn't you say you were reading View from the Left? I don't think I knew anything much about ECC or UTT when I read that.
06:35:32 <Philippa> EvanR-work: that's not algebraic, that's coalgebraic. Also, the best you can do is store the generating process, obviously :-)
06:35:47 <EvanR-work> and theres got to be no way to enforce type safety on the mysql level
06:36:18 <Philippa> merijn: F_omega is basically what happens when you use STLC as your type system, and add 'type lambdas' to fill in the blanks on polymorphic types when needed
06:36:43 <merijn> Philippa: My problem is that what you just said might as well have been Chinese :p
06:36:49 * EvanR-work looks up coalgebraic data
06:36:53 <Philippa> "STLC" is Simply Typed Lambda Calculus
06:37:23 <Philippa> I'll do the latter part first: id : forall a. a -> a = /\ a.\x:a -> a
06:37:40 <Philippa> that /\ is a "type lambda", that's a slightly sugared definition of id in System F
06:37:41 <Jafet> I wonder how type theory might be expressed in chinese
06:37:45 <merijn> dolio: Perhaps, but me and mathematical papers don't get along, so I just get stuck reading. The only solution I know is to look up the basics until I understand
06:37:56 <Philippa> then you'd call it something like this: [id Int] 1
06:38:03 <Philippa> (and get back 1 : Int)
06:38:08 <Philippa> that make sense?
06:38:13 <EvanR-work> wheres the glossary for algebraic vs coalgebraic data
06:38:21 <Philippa> the [] was "just" an application, same as function application only for the big lambda
06:38:46 <Philippa> if that /doesn't/ make sense, start reading through TAPL and skip the proofs :-)
06:38:56 <dolio> merijn: It might be worth your while to try and program a little in Coq or Agda.
06:39:04 <merijn> Philippa: Yeah, that makes sense
06:39:12 <dolio> Coq's type system is pretty close to UTT.
06:39:54 <merijn> [id Int] : Int -> Int, right?
06:39:56 <Philippa> merijn: type operators are just functions at the type level. You write lambdas in the types, you write applications in the types, and the lambdas have "kinds" which are types-of-types
06:40:06 <Philippa> merijn: right
06:40:24 <Philippa> the kind of an "ordinary type" is *. The kind of "type-level id" is * -> *
06:40:47 <Philippa> and the "kind system" turns out to just be the same as the simply-typed lambda calculus' type system, with one base kind - namely *
06:41:58 <Philippa> that's a bit more confusing because I'm gluing bits of type system together, do you need an example?
06:42:10 <Philippa> (if so I'll have to ask someone else to give it: I should be in the shower because I need to be out of the flat shortly)
06:45:22 <merijn> What has me confused is: What's the difference between this and the polymorphic lambda calculus?
06:45:40 <Philippa> which one's that?
06:45:42 <Philippa> *gone*
06:45:51 <EvanR-work> poof
06:46:09 <b0fh_ua> Hi there! I do have some sort of preexisting API which doesn't use any state. But now I need to introduce one function which definitely should maintain State in between calls. And now it looks like I have to modify all call hierarchy to introduce State monad there...
06:46:09 <b0fh_ua> am I missing something?
06:46:42 <EvanR-work> one function that has state... X -> State -> (Y,State)
06:47:12 <merijn> Well, my notes say polymorphic lambda calculus is λ2 or F (which I guess means System F)
06:47:15 <EvanR-work> what youre really saying is that you now want the api to represent a big object where all the methods have access to that state
06:47:23 <EvanR-work> ?
06:47:28 <dolio> System F essentially only has the * kind.
06:47:30 <b0fh_ua> not really
06:47:54 <mightybyte> Has anyone here installed the Haskell Platform on RHEL?
06:47:57 <b0fh_ua> I need to fill Map with values from being parsed from the stream
06:48:21 <dolio> So there are no functions from types to types.
06:48:23 <merijn> dolio: And λ_omega has...
06:48:25 <b0fh_ua> and looks like the current approach doesn't allow to pass state with Map around function chain
06:48:43 <dolio> Is that F_omega? That has any kind you can form from * and ->.
06:49:07 <EvanR-work> b0fh_ua: so you want one function defined as using state reads and writes
06:49:13 <EvanR-work> to produce its value
06:49:22 <EvanR-work> but not necessarily keeping state from one call to another?
06:49:24 <b0fh_ua> yes
06:49:43 <EvanR-work> ok so you can use State
06:49:47 <shapr> Good Morning #haskell !
06:49:47 <EvanR-work> monad
06:49:50 <merijn> dolio: Could you show an example that is valid in F_omega but not in F?
06:49:59 <merijn> Or vice versa
06:50:16 <arcatan> Good Afternoon shapr!
06:50:46 <shapr> Hyvää Huomenta arcatan!
06:51:03 <dolio> List : * -> * = \a -> forall (r : *). (a -> r -> r) -> r -> r
06:51:21 <dolio> That works in F_omega, but not F.
06:52:07 <EvanR-work> b0fh_ua: since it doesnt carry state from one use to another, you wouldnt put State in the top level signature for that function
06:52:08 <dolio> In F, all you can do is write, for any particular T: ListT = forall (r : *). (T -> r -> r) -> r -> r
06:52:27 <EvanR-work> you would just use runState or evalState or something in the definition
06:55:02 <dolio> Also consider: NatTrans = \(f g : * -> *) -> forall (a : *). f a -> g a
06:55:10 <dolio> Those f and g don't make sense in F.
06:55:39 <merijn> Need some time to figure out what those actually say
06:57:44 <b0fh_ua> EvanR-work: okay, I'll check it out. I doubt if it will work, but will see :)
06:57:54 <EvanR-work> b0fh_ua: why would it not
06:58:53 <EvanR-work> do you need more than one mutable cell, theres ST
07:05:32 <MrAI> Hey, is there a log somewhere of this channel?
07:06:08 <Saizan> see the topic
07:06:35 <EvanR-work> MrAI: see the log
07:06:37 <MrAI> THanks
07:12:16 <EvanR-work> can non exhaustive patterns be statically detected
07:12:34 <b0fh_ua> .
07:12:55 <Saizan> EvanR-work: ghc has a warning for them
07:13:05 <EvanR-work> ah, ive never seen it
07:13:38 <Saizan> though it's not 100% accurate wrt guards and sometimes GADTs 
07:13:54 <EvanR-work> it seems sensible to explicitly put _ -> error "foo" if you really want a partial case
07:14:37 <tomh> hey is there a ghci way to see which steps are performed when applying a list of functions in which order ?
07:14:47 <ccasin> EvanR-work: maybe, but that makes ghc's inexhaustive pattern match warning not very helpful
07:14:59 <EvanR-work> why?
07:15:02 <MrAI> Woop found what I was looking for, Thanks.
07:15:02 <merijn> dolio: Somehow it still refuses to all gel together in my head. Thanks for effort anyway
07:15:06 <ccasin> I find them super useful for tracking where I need to make modifications in my code when I add new cases to a datatype
07:15:25 <ccasin> but if you have a catch-all branch, adding a new case to the type being matched against won't trigger a warning
07:15:30 <EvanR-work> adding new cases sounds like the classic 
07:15:39 <EvanR-work> place to put a ad-hoc polymorphic
07:15:40 <EvanR-work> thing
07:16:04 <ccasin> I'm not sure what you mean
07:16:11 <quicksilver> the advantage of GHC's built-in error case is it has a line number and file name.
07:16:26 <EvanR-work> the point is your are sure the error never happens
07:16:39 <EvanR-work> and you explicitly say that in the code to say you knew that
07:16:50 <ccasin> As an example, I often write little compilers and then add more and more features to the abstract syntax.  I want ghc's warnings to tell me which functions I need to change when I add a new constructor
07:16:59 <EvanR-work> adding a case to many cases all over the code is a good place to use a type class
07:17:15 <EvanR-work> rather than a case
07:17:15 <Jafet> Uh, ghc's warnings do
07:17:20 <ccasin> EvanR-work: yes, I'm just saying it's better to spell out the cases you don't think you can reach individually instead of having a catch all branch
07:17:36 <EvanR-work> yes that too
07:17:37 <ccasin> Jafet: yes - I'm making the case against using a catch-all last branch in a pattern match
07:17:58 <Jafet> Well, in a correct program there is no difference in semantics. That branch is dead.
07:18:04 <EvanR-work> A -> x; B -> undefined; C -> undefined (where A B and C are all cases)
07:18:12 <Jafet> In an incorrect program... well, correct it
07:18:31 <ccasin> Jafet: right.  But if I use a catch-all branch, ghc won't warn me that I've forgotten to change this function after I expand my datatype
07:19:20 <Jafet> If you want ghc to remind you of that, then omit the branch.
07:19:25 <EvanR-work> usually though i find that i can fix the 'impossible' branches by changing something
07:19:39 <Jafet> Perhaps evanr uses that experimental stack tracing extension to catch them.
07:24:07 <y0-> Hello community*
07:32:22 <y0-> I cant make this portion of program to work
07:32:25 <y0-> http://pastebin.com/qEbS9Cnw
07:32:52 <y0-> I know the list in python is different in java
07:33:14 <y0-> any will be appreciated
07:33:21 <y0-> any help*
07:33:26 <EvanR-work> wait, thats not haskell
07:33:52 <EvanR-work> python code doesnt work in haskell
07:34:00 <y0-> EvanR-work: What do you mean?
07:34:33 <EvanR-work> theres a channel for java and for python
07:35:02 <y0-> I thought this channel is for python
07:35:08 <EvanR-work> #python ##java
07:35:13 <EvanR-work> this is #haskell
07:35:21 <y0-> Thanks
07:38:26 <Nibble> EvanR-work: no
07:38:28 <Nibble> this
07:38:30 <Nibble> is
07:38:31 <Nibble> SPAAAAARTAAA
07:38:37 <EvanR-work> ._.
07:38:39 * benmachine kicks Nibble down a well
07:38:39 <arcatan> >__>
07:38:56 <RichardBarrell> Your Colleagues Might Be In Trouble If: You can't tell which language the IRC room you just logged into is for.
07:39:32 <benmachine> maybe The Haskell programming language should be at the front of the topic list
07:39:57 <Twey> Heheh.
07:40:14 <arcatan> this channel is for English, mainly
07:40:22 <y0-> I think #python channel is not working for me
07:40:26 <y0-> any recommendation?
07:40:29 <RichardBarrell> "Haskell Platform 2010.2: ..." I think it mentions Haskell early enough.
07:40:30 <EvanR-work> try registering
07:40:41 <Twey> y0-: /msg nickserv help register
07:41:11 <RichardBarrell> Ah, yes. #python is set +r, so it only allows registered IRC users in. They probably did that to cut down on the noise.
07:41:48 <EvanR-work> rabble rabble
07:41:56 <Twey> . o O (… maybe we should do that …)
07:42:15 <quicksilver> we don't really have a rabble problem.
07:42:27 <EvanR-work> as succeess is more and more not avoided, #haskell will get more trolls
07:42:36 <quicksilver> we have put on +r a couple of times when freednoe was being affected by a particular spam problem.
07:43:04 <RichardBarrell> Twey: I think that the SnR here is already good enough.
07:43:12 <Twey> quicksilver: We do get an *awful* lot of people asking for help with their Java homework, though.
07:43:20 <Twey> Yeah, probably.
07:43:38 <y0-> I know its sound stupid but how can i register with +r ?
07:43:56 <Twey> 15:40:16 < Twey> y0-: /msg nickserv help register
07:44:21 <arcatan> Twey: how do they end up here, anyway?
07:44:47 <Twey> arcatan: I think we're the top entry on some directory of IRC channels for the ‘Programming’ category
07:44:58 <Twey> What's it called?  Googlem or something?
07:45:04 <EvanR-work> haskell is a well known misspelling of java
07:45:05 <arcatan> okay
07:45:14 <EvanR-work> the keys are right next to each other
07:45:25 <Twey> Gogloom, that's it
07:45:28 <Twey> EvanR-work: Heh.
07:46:04 <EvanR-work> maybe they just need help with static typing
07:46:24 <EvanR-work> and they figure any language with that is the same ;)
07:46:37 <EvanR-work> like going to ##slackware for help with ubuntu because its linux
07:46:39 <Twey> Haha
07:49:24 <y0-> Haha, sorry i tought haskel is a python community but uncle google says differnt
07:49:35 <Nibble> y0-: -__-
07:49:45 <EvanR-work> sure you did
07:51:16 <dixie> ?? 1+1
07:51:16 <lambdabot>  1+1
07:51:47 <dixie> > 1+1
07:51:48 <lambdabot>   2
07:56:23 <EvanR-work> the ultimate underutilization of haskell!
07:56:39 <EvanR-work> @quote calculator
07:56:39 <lambdabot> ricky_clarkson says: Sorry, I only use Haskell as a posh calculator.
07:56:43 <Twey> Haha
07:56:59 <Nibble> EvanR-work: I dare say that it is ultimate over utilisation.
07:57:36 <Twey> > ()
07:57:37 <lambdabot>   ()
07:58:17 <EvanR-work> a very zen calculation
07:58:26 <sipa1024> > "zen"
07:58:27 <lambdabot>   "zen"
07:59:05 <Jafet> > text ""
07:59:06 <lambdabot>  Terminated
07:59:08 <monochrom> @let x+y = x*y
07:59:09 <lambdabot>  Defined.
07:59:13 <monochrom> > 1+1
07:59:14 <lambdabot>   Ambiguous occurrence `+'
07:59:14 <lambdabot>  It could refer to either `L.+', defined at <local...
07:59:27 <monochrom> @undefine
07:59:52 <Jafet> > text " "
08:00:21 <monochrom> I broke it!
08:00:27 <dixie> >> [x | x <- [400..100000], 2 == (length $ Data.List.nub (show $ x*x)) ]
08:00:34 <Jafet> > ""
08:00:34 <dixie> > [x | x <- [400..100000], 2 == (length $ Data.List.nub (show $ x*x)) ]
08:00:35 <lambdabot>   ""
08:00:35 <lambdabot>   [1000,2000,3000,3114,10000,20000,30000,81619,100000]
08:00:39 <Jafet> > text " "
08:00:48 <Jafet> Ha, lambdabot is more zen than I thought.
08:00:52 * Jafet is enlightened.
08:00:52 <EvanR-work> lol
08:00:53 <dixie> :)
08:01:05 <Twey> That's confusing
08:01:07 <Twey> > text ""
08:01:08 <lambdabot>  Terminated
08:01:12 <Twey> Terminated?  Huh?
08:01:16 <monochrom> @bots
08:01:16 <lambdabot> :)
08:01:18 <EvanR-work> the only way to win is to not play
08:01:25 <monochrom> > text "x"
08:01:26 <lambdabot>   x
08:01:29 <Jafet> :t text
08:01:30 <lambdabot> String -> Doc
08:01:48 <monochrom> @check
08:01:48 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:02:07 <monochrom> @check \s -> show (text s) == s
08:02:07 <lambdabot>   "OK, passed 500 tests."
08:02:42 <Entroacceptor> @check \s -> show (text s) == s::String
08:02:43 <lambdabot>   Couldn't match expected type `GHC.Base.String'
08:03:06 <Entroacceptor> @check \s -> show (text s) == s::String->String
08:03:06 <lambdabot>   Couldn't match expected type `GHC.Base.String -> GHC.Base.String'
08:03:09 <Entroacceptor> mh
08:03:15 <Twey> @check liftM2 (==) (show . text) id
08:03:15 <lambdabot>   "OK, passed 500 tests."
08:03:18 <monochrom> against inferred type Bool
08:03:20 <Entroacceptor> it tries to match a string against nothing?
08:03:37 <monochrom> it tries to truncate error messages
08:03:43 <Entroacceptor> @check \s -> show (text s) == (s::String)
08:03:44 <lambdabot>   "OK, passed 500 tests."
08:03:54 <Twey> Is it bad that I want to write that as ‘dup show text =’?  :-\
08:04:13 <monochrom> yes
08:04:14 <mercury^> :t text
08:04:15 <lambdabot> String -> Doc
08:04:16 <Entroacceptor> @check \s -> show (text s) == (s::Float)
08:04:17 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
08:04:26 <mercury^> What type is Doc?
08:04:30 <Twey> Doc
08:04:38 <mercury^> Yes, what is it?
08:04:40 <monochrom> Text.PrettyPrinter.something
08:04:46 <mercury^> Ok.
08:04:47 <Twey> It represents a prettyprinted document
08:05:11 <EvanR-work> really now
08:05:15 <EvanR-work> is that useful for html
08:05:24 <Twey> No
08:05:28 <Twey> Text document
08:05:34 <EvanR-work> html is a text document
08:05:38 <monochrom> > "♥"
08:05:39 <lambdabot>   "\9829"
08:05:45 <quicksilver> pretty printing, in that sense, is mostly about line-wrapping text nicely
08:05:46 <monochrom> > text "♥"
08:05:46 <Twey> Not really
08:05:47 <lambdabot>   ♥
08:05:55 <Twey> Line-wrapping, line-breaking, spacing
08:05:56 <monochrom> that's the utility here
08:05:59 * quicksilver nods
08:06:17 <EvanR-work> maybe i start thinking of html as a data interchange and screw anyone who clicks view source
08:07:04 <Entroacceptor> EvanR-work: maybe look at pandoc's internal structure....
08:08:53 <Jafet> > show (text "")
08:08:54 <lambdabot>   ""
08:09:01 <Jafet> Oh, right.
08:09:06 <quicksilver> > fix (show.text)
08:09:09 <lambdabot>   mueval-core: Time limit exceeded
08:09:31 <Jafet> text $ fix (" "++)
08:09:37 <Jafet> > text $ fix (' ':)
08:09:43 <lambdabot>   mueval: ExitFailure 1
08:16:55 <Jafet> Is there a simple way to enumerate algebraic numbers?
08:17:44 <zygoloid> Jafet: enumerate polynomials, then index within them?
08:17:44 <sipa1024> algebraic numbers as in real solutions of polynomials with rational coefficients?
08:18:00 <benmachine> sipa1024: might as well make them integer coefficients
08:18:28 <sipa1024> benmachine: true
08:18:35 <Jafet> I wonder if there's a simple one-to-one definition, like there is the stern-brocot tree for rationals
08:18:48 <zygoloid> Jafet: make a list and nub it ;)
08:18:49 <quicksilver> there isn't a simple way to injectively enumerate them that I know of
08:18:56 <quicksilver> which is presumably what Jafet means
08:18:57 <benmachine> injecting stuff into naturals is easy
08:19:04 <benmachine> bijecting is trickier
08:19:11 <quicksilver> exactly
08:19:27 <benmachine> hmm
08:19:33 <Jonny> Hi
08:19:41 * zygoloid can achieve simple but not efficient :)
08:19:41 <benmachine> what if
08:19:57 <quicksilver> I don't think there is any solution to the general problem "do these two polynomials have a common root" which doesn't basically amount to solving them
08:19:58 <benmachine> you have 2^n 3^a 5^b 7^c
08:20:04 <benmachine> oh right yes
08:20:10 <benmachine> duplicates
08:20:14 <benmachine> drat
08:20:17 <sipa1024> if you can enumerate rationals, you can enumerate monic polynomials with rational coefficients
08:20:22 <benmachine> quicksilver: is that even possible in general?
08:20:34 <quicksilver> benmachine: depends what you mean by 'in general'
08:20:43 <quicksilver> there isn't a single general algorithm, no.
08:20:47 <benmachine> quicksilver: I've been told you can't solve quartics in terms of radicals
08:21:05 <quicksilver> there is more to life than radicals ;)
08:21:08 <zygoloid> benmachine: you can.
08:21:12 <quicksilver> (and it's quintics)
08:21:17 <benmachine> uh, yes
08:21:17 <Jonny> Please could someone help me understand the type error in: http://pastebin.com/sJbf2DWT
08:21:19 <benmachine> that's what I meant >_>
08:21:24 <Jonny> ERROR file:.\LSystems.hs:141 - Type error in application *** Expression     : i ts a *** Term           : i *** Type           : Char *** Does not match : a -> b -> c
08:21:31 <benmachine> so I wonder if equality between roots of degree-five polynomials is decidable or whatever
08:21:31 <zygoloid> benmachine: yeah, galois theory is awesome ;)
08:21:49 * benmachine doesn't feel qualified to use the word decidable but thinks it's right here
08:22:07 <zygoloid> benmachine: you can compute arbitrarily-precise approximations of the roots.
08:22:22 <sipa1024> arbitrary is not enough
08:22:23 <benmachine> zygoloid: right but if they *are* equal no arbitrary precision would be sufficient
08:22:24 <quicksilver> Jonny: the second parameter to "trace'" is a String
08:22:37 <quicksilver> Jonny: so "i" is a Char, on line 13 of your paste
08:22:40 <zygoloid> sipa1024: sure, but it's at least semidecidable
08:22:48 <quicksilver> Jonny: you try to apply "i" to two arguments in (i ts a)
08:23:00 <benmachine> zygoloid: inequality isn't interesting, equality is :P
08:23:00 <quicksilver> ... and that's what that error means.
08:23:29 <zygoloid> benmachine: well, if you can enumerate the algebraics then you have a semidecidable algorithm for equality too :)
08:23:47 <quicksilver> benmachine: degree-five is decidable
08:23:53 <zygoloid> (enumerate them in a manipulable form at least)
08:23:54 <quicksilver> I'm pretty sure it is for all N.
08:23:58 <sipa1024> does every algebraic number have a unique rational polynomial (up to multiplication with a constant rational) that it is the *sole* real solution of?
08:24:35 <quicksilver> but you need increasingly obscure notation to describe the roots.
08:24:43 <quicksilver> sipa1024: I doubt it, but I don't know.
08:24:58 <quicksilver> sipa1024: I imagine that, given one, you can do some obvious transformation to one of the pairs of complex roots to get another.
08:24:59 <sipa1024> obviously i'm wrong
08:25:21 <sipa1024> there is no rational polynomial of which sqrt(2) is a root but -sqrt(2) isnt
08:25:31 <monochrom> has a unique monic lowest-degree polynomial, but not sole solution.
08:25:45 <monoidal> i think one can enumerate algebraic numbers by enumerating irreducible polynomials
08:26:01 <quicksilver> I think we should probably take the math talk to -blah or -offtopic though
08:26:08 <quicksilver> since Jonny actually had a haskell question
08:26:09 <roconnor> go go conjugate roots!
08:26:11 <EvanR-work> or #math !
08:26:16 <Jonny> quicksilver: I can't see why its wrong to use i in ( fst . move ) ( i ts a )
08:26:31 <sipa1024> if two different rational polynomials share a real common root, isn't that root necessarily rational?
08:26:32 <quicksilver> Jonny: (i ts a) means 'apply the function i to the two parameters ts and a'
08:26:39 <Jonny> oh
08:26:50 <Jonny> how do I make it that i ts a are 3 params
08:26:55 <Jonny> being applied to fst . move
08:27:03 <quicksilver> (fst . move) i ts a
08:27:11 <Jonny> oh ok
08:27:22 <Jonny> thanks
08:27:27 <quicksilver> np.
08:27:30 <benmachine> sipa1024: x - 1 = 0 and x^3 - 1 = 0 both have sole real solution x = 1 :P
08:27:37 <monochrom> x^2-2 and (x^2-2)*x share sqrt(2)
08:27:42 <sipa1024> benmachine: and 1 isn't rational?
08:27:52 <benmachine> sipa1024: er, sorry, I'm late in the conversation
08:28:02 <benmachine> I was talking about your original thing
08:28:17 <sipa1024> benmachine: oh, that was about my previous assumption - nvm :)
08:28:29 <benmachine> sipa1024: but I still don't think so, e.g. x^4 - 4 = 0 and x^2 - 2 = 0
08:28:33 <benmachine> and
08:28:38 <benmachine> I'm still late because monochrom said that
08:28:40 <sipa1024> hmmm you're right
08:29:32 <monochrom> I don't know why I took the abstract algebra courses. But I know one day it would be useful. Like today. :)
08:29:46 <monoidal> quicksilver: two polynomials have a common root iff gcd(p,q)/=1
08:30:00 <Jonny_> can i check that " ( fst . move ) i ts a " means that it will calculate the first item in the result of " move i ts a "
08:30:24 <benmachine> Jonny_: the left item of the tuple, yes
08:30:30 <benmachine> er
08:30:31 <benmachine> yes
08:30:37 <benmachine> wait
08:30:40 <benmachine> no
08:30:42 <benmachine> <_<
08:30:59 <benmachine> (fst . move) i ts a = fst (move i) ts a
08:31:00 <monochrom> it does not mean that. (fst . move) i ts a = fst (move i) ts a /= fst (move i ts a)
08:31:31 <quicksilver> monoidal: good to know.
08:31:37 <quicksilver> monoidal: what are p and q?
08:31:46 <ClaudiusMaximus> > (f . g) a b :: Expr
08:31:47 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:31:47 <lambdabot>    `SimpleReflect.FromExpr ...
08:31:50 <monochrom> p,q are the two polynomials
08:31:55 <monoidal> roots of gcd (p,q) are common roots of p and q
08:32:02 <quicksilver> oh, that wasn't very helpful
08:32:05 <quicksilver> yes, I know that.
08:32:15 <quicksilver> :)
08:32:19 <quicksilver> but still, it's a good point, yes.
08:32:39 <quicksilver> you don't know if it's the one you want, though
08:33:10 <quicksilver> given that an algebraic number is only one particular root of the polynomial, and you don't know which
08:33:23 <quicksilver> you don't know if the common root is the one you cared about.
08:33:28 <monoidal> right
08:34:00 <ezyang> Hey guys, a little bit of homework help requested. I'd like to show that if Γ ⊢ M : σ is provable and S ∈ Sub (a type substitution), then I'd like to show SΓ ⊢ M : Sσ is provable. 
08:34:18 <ezyang> I think want to do induction on the typing rules 
08:34:22 <ezyang> *I 
08:35:11 <ezyang> but I'm having difficulty figuring out the formulation of (var) (the rule that lets me introduce Γ ⊢ x : τ if x is in Γ and σ > τ 
08:35:58 <ezyang> It doesn't seem possible for me to say, given σ > τ, that Sσ > Sτ 
08:40:02 <camio> @pl \(a,b) -> (b,a)
08:40:02 <lambdabot> uncurry (flip (,))
08:40:10 <camio> :(
08:40:27 <EvanR-work> ghost of undead curry
08:40:40 <EvanR-work> is in ur functions, flippin ur args
08:40:44 <monochrom> you are better off writing your own swap (a,b) = (b,a)
08:41:13 <quicksilver> or perhaps swap ~(a,b) = (b,a)
08:41:15 <ezyang> There's prolly something in Control.Arrow that'll do that. 
08:41:20 <camio> Heh, that'd be the lax version.
08:41:22 <quicksilver> if you're a level 3 zen haskeller.
08:41:31 <pumpkin> there was a proposal for that I thought
08:41:42 <pumpkin> but it never went through cause people were too busy arguing minutiae
08:41:44 <pumpkin> ;)
08:42:05 <camio> quicksilver: I'm level 4 so that should be fine.
08:42:45 <merijn> Bear with me as I try to grok this *still*
08:42:48 <merijn> In simply typed lambda calculus, given that * is the type of all concrete types then 'a' is a valid type if "a : *" and "A -> B" is a valid type if A and B are valid types. In \2 (i.e. System F) the previous are valid types, but "forall a (a : *) . A -> B" where A and B can contain "a" is also a valid type, yes?
08:43:50 <djahandarie> Does anyone have a usage example of a generalized morphism?
08:44:04 <djahandarie> (Like when you change the Algebra into a Dist and GAlgebra)
08:44:27 <ezyang> merijn: Yes. 
08:44:37 <ezyang> :t id 
08:44:38 <lambdabot> forall a. a -> a
08:44:42 <djahandarie> i.e., rather than (Functor f) => (a -> f a) -> a -> Mu f ... (Functor f, Monad m) => (forall a. m (f a) -> f (m a)) -> (a -> f (m a)) -> a -> Mu f
08:44:47 <ezyang> :t (>>=) 
08:44:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:45:36 <djahandarie> Oops, need to go to class
08:45:51 <merijn> Now my confusion is, what's the difference between \2 (System F) and \_omega (i.e. simply typed lambda calculus with type operators)?
08:46:01 <EvanR-work> whats the difference between regular algebraic data type and GADTs
08:46:32 <Twey> GADTs are more general.
08:47:25 <Twey> EvanR-work: A GADT constructor need not always result directly in a term of the type
08:47:32 <merijn> EvanR-work: Was that for me?
08:47:39 <EvanR-work> no
08:47:43 <monochrom> "data X a where C0 :: X Int" is not translatable to ADT
08:47:54 <EvanR-work> obviously gadts are epynomously more general!
08:47:55 <Twey> For example, you can have constructors like Foo :: a -> YourType (a -> a)
08:48:30 <EvanR-work> is X a type or type variable?
08:48:53 <quicksilver> it's a type of kind * -> *
08:48:55 <monochrom> X starts with capital letter, is the type I'm defining.
08:48:58 <quicksilver> also known as a 'type constructor'
08:49:09 <EvanR-work> ok
08:49:10 <quicksilver> like [] or Maybe
08:49:15 <monoidal> is there a slick way to choose all elements of the list + remainder of the list, e.g. [1,2,3] -> [(1,[2,3]),(2,[1,3]),(3,[1,2])]
08:49:16 <monochrom> you heard of "data X a = C0 | C1 a a a" right?
08:49:18 <Twey> EvanR-work: See also: http://www.haskell.org/haskellwiki/GADTs_for_dummies
08:49:29 <EvanR-work> so you can have constructors not of the form a -> b -> c -> YourType
08:49:44 <Twey> Right
08:49:46 <EvanR-work> monochrom: dont think so
08:50:02 <ezyang> Anyone know about my question? 
08:50:19 <EvanR-work> oh
08:50:24 <EvanR-work> ok
08:50:27 <monochrom> "data X a = C0 | C1 a a a" is just haskell 98
08:50:41 <EvanR-work> the X threw me, i read it as data Z X a =
08:50:56 <monochrom> "data Y a = C0 | C1 a a a" then
08:51:54 <jmcarthur> EvanR-work: GADTs basically allow different constructors to parameterize the resulting type in different ways
08:52:07 <quicksilver> The main think that GADTs gain you is the ability to (partly or completely) specialise any variables in the type for some constructors.
08:52:21 <quicksilver> that's the 'famous' part of GADTs, that's what they tend to mean in the literature.
08:52:31 <jmcarthur> e.g.  data Vec n a where Nil :: Vec Z a ; Cons :: a -> Vec n a -> Vec (S n) a
08:52:37 <quicksilver> GHC GADTs also allow you to use all the general forms of polymorphism in the constructor
08:52:43 <quicksilver> which is conceptually unrelated, I think
08:52:48 <quicksilver> but also occasionally handy.
08:52:52 <EvanR-work> so i just saw several features non GADTs dont have so am overwhelmed
08:53:09 <pumpkin> well, GADTs can be fully emulated by existentials and type equality
08:53:15 <EvanR-work> but i didnt see examples of all, so ill read the wiki
08:53:24 <jmcarthur> pumpkin: really?
08:53:25 <sproingie> so what's the relationship of GADT's and type families?
08:53:32 <jmcarthur> pumpkin: how does that work?
08:53:34 <sproingie> both seem to be about specialization
08:53:42 <pumpkin> jmcarthur: well, doing so in GHC forces you to turn on GADTs anyway, but in theory they're equivalent
08:54:00 <quicksilver> sproingie: GADTs still have some degree of uniformity
08:54:16 <pumpkin> your vec up there, for example
08:54:17 <quicksilver> sproingie: it's still one type definition - just with heterogeneity in the constructors
08:54:29 <pumpkin> Nil :: (n ~ Z) => Vec n a
08:54:32 <quicksilver> sproingie: type families let you implement a type as completely unrelated 'instances'
08:54:35 <pumpkin> (with proof of type equality)
08:54:50 <quicksilver> sproingie: so, type families are the further generalisation, at least viewed from that angle.
08:54:59 <sproingie> i like the syntax of GADT's but the power of them hasn't penetrated my brain.  type families i've yet to use at all.
08:54:59 <jmcarthur> ah i see
08:55:09 <quicksilver> in fact, since they're both modellable in the same underlying system that pumpkin has described
08:55:16 <quicksilver> they may well be equivalently expressive
08:55:25 <quicksilver> but they do feel rather different at the program/source code level
08:55:28 <pumpkin> jmcarthur: then Cons :: a -> exists n. (m ~ S n) *> Vec n a -> Vec m a
08:56:06 <pumpkin> jmcarthur: it's more obvious in a language like agda without special syntax for those things
08:56:27 <jmcarthur> yeah
08:56:35 <pumpkin> data Eq a b where Refl :: Eq a a
08:56:38 <sproingie> now we just need records that don't suck, grumblegrumble...
08:57:01 <pumpkin> data Eq a b where Refl :: (a ~ b) => Eq a b
08:57:10 <sproingie> ran into a label conflict just the other day and scratched my head over it til it dawned on me
08:57:35 <sproingie> the stupid part being i wrote both types
08:58:08 <pumpkin> TacticalGrace: did fushunpoon talk to you?
08:58:19 <agundry> ezyang: can't you prove  σ > τ implies Sσ > Sτ by structural induction on typeschemes?
09:05:23 <tromp_> :t round
09:05:24 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
09:06:17 <EvanR-work> > round 3
09:06:18 <lambdabot>   3
09:06:20 <EvanR-work> > round 3.14
09:06:21 <lambdabot>   3
09:06:24 <EvanR-work> > round 3.74
09:06:25 <lambdabot>   4
09:06:28 <EvanR-work> > round 3.5
09:06:29 <lambdabot>   4
09:06:34 <EvanR-work> > round (-3.5)
09:06:35 <lambdabot>   -4
09:06:44 <Starfire> > round 2.5
09:06:45 <lambdabot>   2
09:06:49 <EvanR-work> >_< wat
09:07:09 <monochrom> Knuth proves that round-to-even is best.
09:07:15 <notabel> EvanR-work: round to even
09:07:27 <notabel> aka unbiased rounding
09:07:54 <monochrom> You didn't know that? >_<
09:08:04 <EvanR-work> the question is, does my boss know that?
09:08:46 <EvanR-work> i heard of this rounding technique, .0 .2 .4 .6 .8 rounds one way .1 .3 .5 .7 .9 rounds another
09:08:48 <dpratt71> what do you call this construct? (->)
09:09:16 <monochrom> I call it "function"
09:09:30 <EvanR-work> no monochrom, you are not a modem
09:10:06 <zygoloid> EvanR-work: banker's rounding?
09:10:12 <dpratt71> monochrom: ok, would it then make sense to refer to the 'function instance' of the Arrow class?
09:10:22 <zygoloid> EvanR-work: hmm, no, misread :)
09:10:23 <monoidal> dpratt71: it is used in several cases: http://www.haskell.org/haskellwiki/Keywords#-.3E
09:10:46 <monochrom> yes
09:11:20 <dpratt71> monochrom: ok, great! now I have some idea how to formulate my question :)
09:12:07 <monochrom> I am a modem. I call it 00101101 00111110
09:12:49 * hackagebot ip6addr 0.3.2 - Command-line tools to deal with IPv6 Addresses text representation  http://hackage.haskell.org/package/ip6addr-0.3.2 (MichelBoucey)
09:12:49 <EvanR-work> is reminded of the song by flight of the conchords about robots
09:14:24 <dpratt71> I'm studying the 'loop' function from the function instance of ArrowLoop...and as usual, recursion causes my brain to stackoverflow
09:14:54 <monochrom> there is a stackless way of unfolding recursion
09:14:57 <EvanR-work> stackoverflow is a handy way read the bottom
09:15:05 <EvanR-work> use with cautino
09:15:07 <EvanR-work> on
09:15:33 <zygoloid> EvanR-work: binary solo!
09:16:00 <EvanR-work> lol
09:16:07 <monoidal> dpratt71: you've got a function (a,d) -> (b,d) and feed its output d into input, getting a -> b
09:16:19 <dpratt71> how the heck can 'loop' refer to 'd' when producing the value of 'd'
09:16:21 <dpratt71> ?
09:16:55 <monoidal> dpratt71: think about f (x,y) = (x, 1:y)
09:17:17 <monoidal> or maybe f (x,y) = (y, 1:x)
09:17:21 <dpratt71> monoidal: ok, I'll try to think about that, but it hurts
09:18:10 <monoidal> dpratt71: for an application of this, you can check appendix in citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.30.342
09:18:11 <dpratt71> no, actually, that doesn't hurt, but I don't see the connection, yet
09:19:05 <dpratt71> the def of loop (for functions) is: loop f b = let (c,d) = f (b,d) in c
09:19:28 <dpratt71> in the expression 'f (b,d)' where does the 'd' come from? how is it produced?
09:19:46 <EvanR-work> if you ask for d, it will evaluate f (b,d)
09:20:04 <EvanR-work> which doesnt need to know what d is yet
09:20:08 <EvanR-work> just f
09:20:15 <dpratt71> EvanR-work: I suspected as much. That clever Haskell!
09:20:40 <EvanR-work> yes, my brain exploded just now
09:20:42 <EvanR-work> good luck ;)
09:20:51 <monochrom> You have heard of "x = ():x" and "let x = ():x in x", right?
09:21:11 <monochrom> you would ask the same question "where does the x come from"
09:21:12 <dpratt71> monochrom: looks vaguely familiar
09:21:46 <roconnor> > loop (\(a,b) -> (b*2) (a+2)) 5
09:21:46 <lambdabot>   Occurs check: cannot construct the infinite type: d = t -> (c, d)
09:21:50 <roconnor> > loop (\(a,b) -> (b*2,a+2)) 5
09:21:51 <lambdabot>   14
09:22:10 <roconnor> not a very compelling use of loop
09:23:10 <dpratt71> roconnor: I kind of get it. Weird.
09:23:33 <monochrom> monoidal's example = "let (c,d) = (d, 1:b) in c" = "let {c = d; d = 1:b} in c"  just mutual recursion
09:23:52 <dpratt71> is there any rule of thumb (or several) for how one avoids strict infinite recursion?
09:23:59 <monoidal> yes, it's degenerate case
09:24:05 <EvanR-work> dont use anything strict
09:24:20 <burp> good rule of thumb :D
09:24:36 <monochrom> ensure lazy pattern matching of tuples, e.g., f ~(a,b) = (b,a)
09:24:39 <EvanR-work> youd be surprised how often you can avoid arithmetic! ;)
09:25:24 <EvanR-work> > let x = 1:x in x
09:25:24 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:25:30 <EvanR-work> > let x = 1+x in x
09:25:34 <lambdabot>   mueval-core: Time limit exceeded
09:26:10 <ezrakilty> > 1
09:26:11 <lambdabot>   1
09:26:58 <dpratt71> > loop (\(a,b) -> (a,b)) 5
09:26:59 <lambdabot>   5
09:27:01 <monoidal> dpratt71: i strongly recommend appendix in the paper http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.30.342, figure 6 shows a nice use case of this trick
09:27:14 <dpratt71> monoidal: ok, I'll check that out
09:27:25 <monoidal> see only appendix, not whole paper
09:27:33 <dpratt71> monoidal: ok
09:27:36 <EvanR-work> people think its ok and normal to use arrow loop but not fix? ;)
09:27:56 <ezyang> agundury: I don't think so. 
09:27:58 <monochrom> I use fix all the time.
09:28:06 <EvanR-work> i get groans whenever i use it
09:28:16 <ezyang> I think it only works if I assume σ and τ are unified. 
09:28:41 <erisco> > length [1..10]
09:28:42 <lambdabot>   10
09:29:13 <monochrom> you need to find out people's background before you respect their opinions
09:29:31 <erisco> @p1 \x y -> uncurry (length x, length y)
09:29:31 <lambdabot> (uncurry .) . (. length) . (,) . length
09:29:40 <erisco> hmm, not very appealing
09:29:55 <erisco> :t uncurry
09:29:56 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:30:22 <erisco> @p1 \x y -> curry (length x, length y)
09:30:22 <lambdabot> (curry .) . (. length) . (,) . length
09:30:42 <monoidal> erisco: curry a pair?
09:30:54 <erisco> monoidal: I keep confusing which is which
09:31:11 <monoidal> erisco: curry/uncurry take a function, curry returns a -> b -> c
09:31:21 <monoidal> erisco: curry (...,...) is type error
09:31:57 <erisco> monoidal: well, if I wanted to apply length to both arguments, how would I do so?
09:32:16 <erisco> monoidal: I thought if I made a tuple and then uncurried it that I'd get back to two arguments
09:32:19 <monoidal> erisco: \(x,y) -> (length x, length y), also can be written as length *** length
09:32:45 <erisco> not in my language :(
09:32:47 <erisco> :t ***
09:32:48 <lambdabot> parse error on input `***'
09:32:52 <monoidal> :t (***)
09:32:52 <erisco> :t (***)
09:32:52 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:32:53 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:33:20 <monoidal> erisco: you need to import Control.Arrow. This signature is (b -> c) -> (b' -> c') -> (b,b') -> (c,c') but a bit more general
09:33:37 <monochrom> I seem to remember that erisco is writing in miranda
09:33:38 <monoidal> (f *** g) (x,y) = (f x, g y)
09:33:40 <erisco> I cannot implement that, aw well
09:33:45 <monoidal> ah
09:34:20 <erisco> see, I want to find the maximum but I need to compare after applying a function to each argument
09:34:23 <quicksilver> miranda. Wow. Are you a 1990s computer science student from imperial college who has discovered IRC time travel? ;)
09:34:35 <monoidal> erisco: you don't have maximumBy?
09:34:42 <erisco> quicksilver: essentially :P
09:34:54 <erisco> monoidal: I am writing it right now
09:34:58 <quicksilver> > (compare `on` maximum) [1,2,3] [2,0,2]
09:34:59 <lambdabot>   GT
09:35:50 <ToRA> quicksilver: now there's an esoteric reference to my department if ever I heard one
09:35:52 <monochrom> in a class taught by a 1990s computer science student
09:36:15 <monochrom> you know how some old people who try to teach you cobol
09:36:26 <monochrom> s/who/would/
09:36:37 <erisco> monoidal: I wrote it, but I discovered that maximum can be written using foldl
09:36:47 <erisco> but I cannot figure out what the base case should be if the list is empty
09:36:54 <quicksilver> ToRA: I spent the 1990s helping IC computer science students with their homework, in between my real job.
09:37:04 <monochrom> most people write maximum as foldl1 or foldr1
09:37:07 <quicksilver> (well, not quite the *whole* decade)
09:37:13 <monoidal> erisco: it is minBound if you have smallest element, otherwise not well-defined
09:37:13 <monochrom> indeed the haskell prelude does
09:37:30 <monochrom> > maximum [] :: Int
09:37:31 <lambdabot>   *Exception: Prelude.maximum: empty list
09:37:36 <monoidal> erisco: minBound is neutral element for max, in the same way 0 is neutral element for +
09:37:51 <monochrom> @src maximum
09:37:52 <lambdabot> maximum [] = undefined
09:37:52 <lambdabot> maximum xs = foldl1 max xs
09:37:52 <erisco> ah
09:37:53 <ToRA> quicksilver: as a paid tutor or just on irc as you probably do now too...?
09:38:20 <chudy_michef> Hi. Can I ask a quick Mac question?
09:38:29 <erisco> monoidal: I will just define foldl1 then
09:38:44 <monoidal> seems it's best choice
09:38:59 <Nibble> chudy_michef: don't ask about asking
09:39:03 <Nibble> ask the question already
09:39:08 <chudy_michef> nibbles: okay
09:39:18 <monochrom> lazy stream of question
09:39:36 <chudy_michef> question is, is the haskell platform available for os x tiger, or just for (snow) leopard?
09:40:24 <quicksilver> ToRA: in person, but not paid :)
09:40:41 <quicksilver> chudy_michef: I think it has generally supported the version that existed when it came out
09:40:49 <quicksilver> so the current HPs are proabbly snow leopard only
09:40:57 <quicksilver> but there might have been a few leopard ones
09:41:03 <quicksilver> I don't remember the relative chronology.
09:41:35 <erisco> > max 5 6
09:41:35 <lambdabot>   6
09:41:47 <erisco> > foldl1 max [1..10]
09:41:47 <lambdabot>   10
09:41:54 <chudy_michef> quicksilver: thanks. I'll stop looking for a tiger one!
09:41:55 <erisco> foldl1 max [1]
09:42:05 <erisco> > foldl1 max [1]
09:42:06 <lambdabot>   1
09:42:07 <Nibble> > in max (2 + 2) 5 let 2 + 2 = 5
09:42:08 <lambdabot>   <no location info>: parse error on input `in'
09:42:23 <Nibble> > let 2 + 2 = 5 in  max (2 + 2) 5
09:42:24 <lambdabot>   5
09:42:30 <erisco> > foldl1 (+) [1]
09:42:31 <lambdabot>   1
09:42:39 <erisco> so it just returns the last element, okay
09:42:44 <quicksilver> chudy_michef: you can certainly try a more recent one and see if it works, but I suspect it won't.
09:43:02 <quicksilver> there have been a few annoying changes to the compiler / library infrasctructure on OSX versions
09:43:07 <quicksilver> (well, annoying for this kind of thing)
09:43:09 <benmachine> quicksilver: he's gone >_>
09:43:23 <erisco> > foldl1 (+) []
09:43:24 <lambdabot>   *Exception: Prelude.foldl1: empty list
09:43:27 <quicksilver> hah. He left before my response, but after the tab-complete went through
09:43:35 <quicksilver> I normally rely on tab-complete to tell me if people are still here.
09:43:49 * erisco facepalms
09:43:55 <erisco> foldl1 is already defined in miranda :D
09:44:59 <nominolo> quicksilver: current platform should work on Leopard and SL, but not Tiger
09:48:02 <Rembane> wb pastorn 
09:48:04 <Rembane> wb phyrex1an 
09:48:08 <quicksilver> nominolo: good to know, thank you.
09:48:08 <Rembane> wb Evious 
09:54:03 <gwern> > 16 * 4
09:54:04 <lambdabot>   64
09:54:33 <Rembane> > 2**5
09:54:33 <lambdabot>   32.0
09:54:39 <Rembane> > 2^5
09:54:40 <lambdabot>   32
09:54:43 <Rembane> Cool.
09:57:37 <gwern> numbers bleh
09:57:43 <gwern> can't live with'em, can't live without'em
10:01:00 <ski> > 2 ^^ 5
10:01:00 <lambdabot>   32.0
10:03:45 <pygmalion> any ideas why those first two lines are giving me parse errors? http://hpaste.org/paste/40939/parse_error#p40941
10:04:19 <Lemmih> pygmalion: Use | instead of &&.
10:12:13 <pygmalion> Lemmih: why? is that just like using a guard?
10:12:30 <pygmalion> :r
10:12:47 <Lemmih> pygmalion: It /is/ a guard.
10:12:48 <silver> @type (&&)
10:12:48 <lambdabot> Bool -> Bool -> Bool
10:13:17 <pygmalion> Lemmih: I wasn't aware guards could be used that way. thanks.
10:13:38 <shapr> danbrown: hiya!
10:14:07 <thaw> haskellers, this is a great moment in your history
10:14:18 <monoidal> anyone know a nice way to make everything except n-th element? f [1,2,3] = [[2,3],[1,3],[2,3]] I use take n xs ++ drop (n+1) xs, which seems ugly
10:14:23 <shapr> Any Haskellers in Alabama and not on the AlabamaHaskell mailing list?
10:14:27 <thaw> there is JOB for haskellers : http://www.haskellers.com/jobs/
10:15:06 <shapr> thaw: There have been jobs for Haskellers before as well :-)
10:18:51 <shapr> Any Language.C users around? I'm still looking for demonstration code.
10:23:55 <roconnor> shapr: have you checked the haskeller's map
10:24:53 <monoidal> I use now let (a,:_b) = splitAt n xs in a++b, but there might be a better solution :)
10:25:11 <roconnor> shapr: there is only one haskeller in Alabama: Jake McArthur
10:25:43 <jmcarthur> there are more than that
10:26:06 <jmcarthur> one of the ray* nicks in here belongs to somebody a couple hours from huntsville, I think
10:26:12 <jmcarthur> and there are a few more
10:26:15 <jmcarthur> but they are all spread out
10:26:17 <roconnor> :)
10:26:48 <jmcarthur> there are also a few within a couple hours of huntsville in tennessee, iirc
10:27:36 <shapr> roconnor: aww
10:27:46 <shapr> rmiller
10:27:49 <shapr> preflex: seen rmiller
10:27:50 <preflex>  rmiller was last seen on #perl 2 years, 25 days, 23 hours, 10 minutes and 13 seconds ago, saying: later, thx
10:27:52 <shapr> huh?
10:28:01 <shapr> hmm
10:32:14 <pygmalion> :r
10:32:18 <pygmalion> whoops sorry
10:32:21 <pygmalion> :r
10:32:45 <gdoteof> i am trying to go through lyahfgg however, i am having trouble getting up to the minimum requirements
10:34:04 <gdoteof> nm
10:49:04 <AnotherLomono> Haskell newbie here, could someone please tell me why the format on the top works, but the format on the bottom doesn't? http://pastebin.com/gMxEBF6n
10:49:44 <monochrom> the bottom means something else entirely
10:50:24 <Twey> I don't think that's even valid
10:50:36 <monochrom> you must use the top. there is no choice.
10:50:36 <Twey> Too many variables for an operator, and no brackets
10:51:04 <Twey> Well, there is — pattern-matching
10:51:06 <AnotherLomono> no illusion of free will? :V
10:51:54 <monochrom> rather, no illusion of "computer can guess what I mean"
10:52:09 <Twey> Or currying
10:52:19 <jmcarthur> if i saw that code in isolation i would not know what it's intended to do
10:52:23 <AnotherLomono> well, I'm learning Haskell through a mishmash of books, and in this book they've not covered the top format yet
10:52:28 <monochrom> even type inference is not about guessing what you mean
10:52:48 <monochrom> you can use a lot of if-then-else if you want
10:53:14 <AnotherLomono> let me check
10:53:17 <Twey> AnotherLomono: http://pastebin.com/BabeG1ZY
10:53:45 <Twey> (ugh, pastebin.com's Haskell highlighting is *ugly*)
10:53:54 <AnotherLomono> Twey: thanks
10:54:19 <AnotherLomono> Twey: you have the right idea - at this point in this book they've not introduced if-then-else yet
10:54:21 <jmcarthur> AnotherLomono: you could do something like this perhaps http://pastebin.com/2Jd6d0C2
10:54:33 <AnotherLomono> thanks jmcarthur 
10:54:39 <jmcarthur> oh i've been beaten to the punch
10:55:10 <AnotherLomono> I always feel bad when I can't answer a question using something that I should have learnt up to the point
10:55:32 <Twey> AnotherLomono: The dropWhile, of course, is the best solution.
10:56:04 <Twey> (and the one you'd see in real code — well, if it were worth giving a function like that a name, anyway)
10:56:12 <AnotherLomono> Twey: thanks, does that drop all spaces from a string?
10:57:22 <Twey> AnotherLomono: No, it just drops until it encounters a non-space character (which is exactly what yours did)
10:57:38 <Twey> > dropWhile (== ' ') "   baa baa black sheep  "
10:57:39 <lambdabot>   "baa baa black sheep  "
10:58:25 <AnotherLomono> Twey: oh I just tried it out for myself
10:58:28 <AnotherLomono> nice
10:58:47 <Twey> If you want to remove *all* spaces, use filter
10:58:58 <Twey> > filter (/= ' ') "    baa baa black sheep   "
10:58:59 <lambdabot>   "baabaablacksheep"
10:59:40 <AnotherLomono> the nice thing about the Kindle is that it's easy to search through the whole book
10:59:53 <AnotherLomono> well, I guess this book wouldn't have touched on dropwhile
11:00:00 <ezyang> Claim: strict data types can eliminate the majority of thunk-based memory leaks. 
11:00:36 <AnotherLomono> thanks Twey
11:00:47 <Twey> AnotherLomono: What book are you using?
11:01:15 <monochrom> foldl (+) is not solved by strict data types
11:01:34 <AnotherLomono> "Discrete Mathematics Using a Computer"
11:01:38 <ezyang> monochrom: Well, list is not strict :-) 
11:02:06 <AnotherLomono> my maths is pretty bad :(
11:02:08 <ezyang> (but yes, it would still be buggy on a deepseq'd list) 
11:02:15 <Twey> AnotherLomono: Well, if you're serious about learning *Haskell* (rather than using it as a Rather Advanced Calculator), check out Real World Haskell or something.
11:02:18 <monochrom> write foldl for strict list. makes no difference.
11:03:15 <monochrom> take 5 xs has a memory leak if xs is a strict list and take is for strict list
11:03:25 <AnotherLomono> Twey: my maths is holding me back. What I really need is to go through high school maths :<
11:03:55 <AnotherLomono> I can't do things like analysing Big O and all that
11:03:59 <Twey> AnotherLomono: It's not holding you back from Haskell
11:04:43 <ezyang> monochrom: I don't see that. 
11:05:10 <monochrom> xs = replicate 1000000 'x'
11:05:38 <AnotherLomono> Twey: You're right
11:05:49 <ezyang> monochrom: Who's holding on to the leaky memory? 
11:05:59 <monochrom> the strict list
11:06:02 <roconnor> how do you test if two church numerals are equal?
11:06:17 <sproingie> as long as you know what Big O means and you can intuit it (a loop is O(n), comparing everything to everything else is O(n^2) you're fine
11:06:34 <monochrom> it leaks 1000000-5 items for a short duration
11:07:11 <sproingie> you certainly don't need to know deep algorithmic analysis to use haskell.  heck, intuitions of complexity are often *wrong* in the face of laziness anyway
11:07:23 <ezyang> monochrom: I'm formulating the equivalent code in my head for a classic strict version of the program, and I see  1000000 elements being allocated, 5 elements being copied out, and then 1000000 elements being deallocated. 
11:07:57 <AnotherLomono> sproingie: yeah, but I'm an ambitious undereducated person who wants to be able to implement any of Okasaki's Functional Data Structures from memory and explain it :P
11:08:03 <dolio> roconnor: http://code.haskell.org/~dolio/pts/itower.pts
11:08:26 <ezyang> Perhaps you mean, lazy take is better than stict take in this situation? 
11:08:33 <monochrom> of course
11:08:51 <monochrom> or rather, lazy list better than eager list
11:08:59 <dolio> eqNat, in particular.
11:09:01 <sproingie> AnotherLomono: you can generally intuit those too.  you only really need rigor if you're doing a proof or something
11:09:10 <ezyang> Ok. I'll need to reformulate my claim then. 
11:09:15 <AnotherLomono> sproingie: oh no, I don't mean to say that you need good maths to use Haskell
11:09:24 <AnotherLomono> uh, s/you/I/
11:09:40 <ezyang> "Strict data types closely simulate stict semantics" seems close but falls prey to the foldl example. 
11:09:56 <ezyang> *strict 
11:10:04 <sproingie> ezyang: say that in Sylvester the Cat's voice and it sounds better
11:10:14 <monochrom> that is because foldl tries to be nonstrict
11:10:50 <ezyang> sproingie: hah 
11:11:18 <ezyang> Yes. 
11:11:25 <monochrom> translate haskell foldl to a strict or eager language. carefully preserve evaluation order rather than syntax while you translate. you'll be surprised.
11:11:50 <ezyang> No, I see precisely what you mean. 
11:13:02 <pygmalion> can someone walk me through making the first couple of functions recursive such that they would transform the expression in the second paste? http://hpaste.org/paste/40943/should_transform_the_below#p40944
11:14:36 <monoidal> pygmalion: as an aside: be careful with "otherwise" in case-of patterns
11:14:59 <pygmalion> monoidal: i shouldn't use t?
11:15:01 <pygmalion> it*
11:15:02 <monochrom> > sin 0
11:15:02 <lambdabot>   0.0
11:15:07 <monoidal> pygmalion: it binds the value to symbol "otherwise", hiding the default otherwise = True
11:15:13 <monochrom> > let sin = 4 in sin
11:15:14 <lambdabot>   4
11:15:31 <pygmalion> monoidal: hmm. so what's the best way to avoid errors about non exhaustive patterns
11:15:37 <monochrom> > let f otherwise = otherwise in f 'x'
11:15:38 <lambdabot>   'x'
11:15:39 <monoidal> pygmalion: use _; use "otherwise" in guards
11:15:44 <c_wraith> @hoogle Either String String -> (String -> String) -> Either String String
11:15:44 <lambdabot> No results found
11:15:59 <c_wraith> hmm.
11:16:05 <c_wraith> I'm surprised it didn't tell me "fmap"
11:16:13 <c_wraith> which would be technically correct, but not what I'm looking for
11:16:21 <monoidal> c_wraith: it's flip fmap
11:16:46 <c_wraith> except fmap is the same as right, and I want...  Both.
11:16:58 <c_wraith> I guess I could use either f f
11:17:02 <pygmalion> monoidal: ah okay. that works because haskell just uses the first argument that evaluates to true?
11:17:07 <c_wraith> except, no, those lose the constructor
11:17:50 <c_wraith> either (Left . f) (Right . f) >_>
11:17:59 <c_wraith> That seems ridiculous
11:18:01 <monochrom> either (Right . f) (Left . f)
11:18:10 <monoidal> pygmalion: yes
11:18:19 <monoidal> c_wraith: maybe (|||)?
11:18:25 <pygmalion> monoidal: thanks. any ideas as to how to make it work through more than one level?
11:18:27 <c_wraith> :t (|||)
11:18:28 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
11:18:42 <c_wraith> That doesn't look right.
11:18:47 <monoidal> pygmalion: don't understand the question
11:19:05 <monochrom> (Right . f) ||| (Left . f)
11:19:48 <c_wraith> monochrom, any particular reason you keep flipping Right and Left? :P
11:19:56 <monochrom> naughtiness
11:20:12 <c_wraith> so ||| is a generalized infix either?
11:20:16 <monochrom> yes
11:20:24 <pygmalion> monoidal: so for an expression like Operator Times [Num 0, Num 5], my multSimplify function returns Num 0. when it has multiple levels like Operator Times [Num 0, Operator Plus [ Num 10, Num 1]] it just returns the argument
11:20:30 <jmcarthur> :t (|||) `asTypeOf` either
11:20:31 <lambdabot> forall b d c. (b -> d) -> (c -> d) -> Either b c -> d
11:21:58 <monoidal> pygmalion: multSimplify (Operator Times [Num 0, Operator Plus [ Num 10, Num 1]]) is Num 0?
11:22:10 <c_wraith> :t \f -> either (Left . f) (Right . f)
11:22:11 <lambdabot> forall a a1. (a1 -> a) -> Either a1 a1 -> Either a a
11:22:41 <c_wraith> @pl \f -> either (Left . f) (Right . f)
11:22:41 <lambdabot> liftM2 either (Left .) (Right .)
11:22:49 <c_wraith> that's kind of cute.
11:22:52 <FeiRuoWa> class now, bbl!
11:26:25 <jmcarthur> if course if you have Either a a, you might as well just convert it to a
11:26:55 <monoidal> pygmalion: ah. Operator Times [x,y] -> Operator Times [multSimplify x, multSimplify y]
11:26:56 <jmcarthur> unless the tag is significant
11:27:03 <jmcarthur> in which case you could just as easily have (Bool, a)
11:27:29 <monoidal> pygmalion: this applies recursively multSimplify to leaves
11:27:35 <jmcarthur> hmm... thanks _|_ for making that actually different
11:27:37 <monoidal> pygmalion: you can join addSimplify and multSimplify into one function
11:28:07 <pygmalion> monoidal: ahhh i see. okay and then use (.) to combine them?
11:28:08 <monochrom> I don't think people use the extra ⊥s
11:28:38 <jmcarthur> then why have them? :P
11:28:56 <monoidal> pygmalion: yes; multSimplify (addSimplify x) = (multSimplify . addSimplify) x
11:28:57 <monochrom> to wear the hairshirt
11:29:29 <pygmalion> monoidal: thanks i'll take a look!
11:29:33 <monochrom> of course some people use the extra ⊥s in a few places. but not majority.
11:29:39 <jmcarthur> i wish we had more strict data types available in base
11:29:52 <jmcarthur> at least strict product and sum types
11:30:19 <pygmalion> :r
11:30:30 <jmcarthur> ha pygmalion 
11:30:57 <pygmalion> jmcarthur: i keep doing that. sorry!
11:31:06 <pygmalion> i'll close the window while i test...
11:31:38 <monochrom> it happens to people whose irc and editor both visually look like the same terminal
11:33:30 <monochrom> the proverb "window manager is just xterm launcher" applies to those people
11:34:39 <AnotherLomono> okay I'm going to try Real World Haskell
11:34:43 <burp> urxvtc launcher ;)
11:35:48 <ksf> *sigh*
11:36:13 <ksf> either machine-readable nesting specs aren't existant for html5 or I can't find them.
11:38:59 <jmcarthur> monochrom: "window manager is just emacs launcher" also applies here ;)
11:39:01 <ksf> "> There's no official formal schema for HTML5 because we have found that
11:39:01 <ksf> > providing an official formal schema leads to people using that schema even
11:39:01 <ksf> > if it is buggy, never considering writing their own."
11:39:02 <lambdabot>   Not in scope: `providing'Not in scope: `an'Not in scope: `official'Not in s...
11:39:02 <lambdabot>   <no location info>: parse error on input `,'
11:39:04 <ksf> *doublesigh*
11:39:21 <jmcarthur> ksf: ...
11:39:38 <ksf> otoh, there _is_ an idl spec for the dom
11:39:54 <jmcarthur> the solution is to not make a buggy official formal schema
11:40:06 <monochrom> extend that to: "there is no official informal schema either, same reason"
11:40:23 <ksf> well, the html5 spec is quite detailed
11:42:01 <monochrom> logical conclusion: "<title>HTML5 Spec</title> ... <body><p>This is the spec of HTML5. <p>This spec is empty because otherwise people would use this spec even if it were buggy. People should write their own HTML spec.</body>
11:42:06 <FunctorSalad_> "writing their own"? lol
11:42:16 <ksf> and then I'm sceptical when it comes to running regexen over HLists to enforce nesting invariants.
11:42:18 <FunctorSalad_> (if you interpret that as applying to every user of html5)
11:42:27 <ksf> sounds like exponential type blowup, to me.
11:42:33 <FunctorSalad_> everyone make their own dialect!
11:42:57 <EvanR-work> isnt that what html4 is
11:43:10 <ksf> nah html4 is reasonably specced.
11:43:20 <ksf> but virtually nobody is adhering to it
11:43:44 <roconnor> > (1782^12 + 1841^12)**(1/12)
11:43:45 <lambdabot>   1921.9999999558665
11:43:56 <roconnor> > (1782^12 + 1841^12)**(1/12) :: CReal
11:43:56 <lambdabot>   1921.9999999558672254029113283702950729344117
11:45:05 <ksf> anyway, the general idea I had is to take all those specs, some type magic, ghcjs and try to write a html templater that doesn't care whether it runs in the browser or on the server.
11:45:48 <monochrom> perhaps you should write a formal schema and share with us.
11:45:58 <ksf> having some guarantee that the browser isn't going to throw DOMExceptions at you is a cool thing.
11:46:11 <FunctorSalad_> or maybe they mean there should be a single schema, but they want the users to collaboratively write it for them.
11:46:21 <ksf> there isn't even a definition language that's properly expressive.
11:47:07 <ksf> http://ns.inria.fr/active-tags/active-schema/active-schema.html   comes close, but it's a) xmlbloat b) unfinished c) afaict unimplemented
11:47:15 <monochrom> write a formal schema in Haskell. perhaps more people will be forced to learn it.
11:48:31 <ksf> base = Element "base" [Metadata] (DoesNotContain base (In head)) Empty global_attrs
11:49:08 <ksf> the painful part is refactoring the informal spec to not contain such idiocities.
11:49:09 <EvanR-work> type Html = String
11:49:25 <ksf> ...head should specify itself that it can only contain one base element.
11:50:18 <ksf> hmmm I wonder if gf can help, it's got dependent types _and_ can generate GADTs
11:50:46 <pygmalion> i am trying to take a string and then an object of my type ArithExpr in IO but haskell only wants me to take characters. what's the best way to correct this? http://hpaste.org/40946/io
11:50:59 <monochrom> I think GF helps a lot.
11:51:23 <FunctorSalad_> GF?........
11:51:27 <aristid> gf.
11:51:31 <ksf> grammatical framework
11:51:37 <aristid> @where gf
11:51:37 <lambdabot> http://www.grammaticalframework.org/
11:51:41 <FunctorSalad_> ah. I keep forgetting ;)
11:51:58 <monoidal> pygmalion: x <- getLine makes x a String. You can use words x to split it into [String]
11:52:13 <monoidal> pygmalion: alternatively, you can perform getLine in a loop
11:53:10 <pygmalion> monoidal: then why is ghci giving me this-->     Couldn't match expected type `[Char]' against inferred type `Char'
11:53:52 <FunctorSalad_> ksf: looks like it's for natural language
11:53:56 <monoidal> pygmalion: String = [Char]
11:54:01 <monoidal> > zip "aaa" "cxy"
11:54:01 <lambdabot>   [('a','c'),('a','x'),('a','y')]
11:54:09 <ksf> it's powerful enough for natural language, yes.
11:54:09 <monoidal> this is the same as:
11:54:17 <monoidal> > zip ['a','a','a'] ['c','x','y']
11:54:18 <lambdabot>   [('a','c'),('a','x'),('a','y')]
11:54:39 <EvanR-work> type String = [Char]
11:54:42 <ksf> it's also bi-directional, which is _really_ cool.
11:54:58 <ksf> bi as in parsing/unparsing from the same grammar
11:55:01 <pygmalion> monoidal: i realize that String = [Char] but isn't that error saying that my code is expecting a string but receiving a Char from haskell's IO?
11:55:22 <fengshaun> Haskell: with batteries (kind of) included) -> http://john-millikin.com/articles/ride-the-snake/
11:55:28 <EvanR-work> expected and inferred isnt helping distinguish source of 'inferrence'
11:55:32 <monoidal> pygmalion: it's because of type inference
11:55:32 <EvanR-work> both are expected
11:55:34 <EvanR-work> or inferred
11:55:58 <monoidal> pygmalion: you get a string, but then zip two stings and get a list of pairs of characters
11:56:27 <pygmalion> monoidal: oh now i see. so i can make that into a list of strings how?
11:56:28 <monoidal> pygmalion: vars :: String, values :: String; assocs = zip vars values :: [(Char,Char)]
11:56:46 <FunctorSalad_> ksf: lmao. I just generated the sentence 'Do you want suspect boring coffee?' by just clicking on words. rather neat
11:56:51 <FunctorSalad_> http://www.grammaticalframework.org/demos/phrasebook/
11:56:52 <monoidal> pygmalion: do you want to split the vars and values using space?
11:57:06 <pygmalion> monoidal: yes
11:57:08 <sipa1024> use words to split your string into a list of strings, then zip to get a list of pairs of strings
11:57:09 <FunctorSalad_> apparently it only lets you form somewhat meaningful sentences
11:57:11 <monoidal> pygmalion: if so, use "words": zip (words vars) (words vals
11:57:24 <monoidal> > words "aa xc sdf23 edr"
11:57:25 <lambdabot>   ["aa","xc","sdf23","edr"]
11:57:35 <lispy1> > words "     "
11:57:36 <lambdabot>   []
11:57:36 <FunctorSalad_> (input: "Willst du langweiligen verdächtigen Kaffee?")
11:57:45 <monoidal> > zip (words "xe s2s") (words "kk ff")
11:57:46 <lambdabot>   [("xe","kk"),("s2s","ff")]
11:57:50 <sm> fengshaun: I just read it.. very cool library and article
11:58:05 <sm> someone should add john millikin to planet haskell
11:58:12 <pygmalion> monoidal: ah okay. and out of curiousity, if i wanted a different delimiter (other than spaces) what function could i use?
11:58:32 <EvanR-work> pygmalion: Data.String.Utils split :: a -> [a] -> [[a]]
11:58:50 <ksf> argh gf doesn't compile with ghc 7
11:58:55 <ksf> ...or I should update.
11:58:59 <ksf> or downgrade.
11:59:01 <aristid> FunctorSalad_: Est-ce que tu veux du café suspect ennuyeux?
11:59:02 <EvanR-work> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
11:59:09 <pygmalion> EvanR-work: okay cool, thanks
11:59:10 <monoidal> pygmalion: I don't think there's a function in standard library, there are some libraries for splitting
11:59:33 <monoidal> ah, Data.String.Utils is in MissingH
12:00:06 <EvanR-work> yes, and thats all i use in missingH ;)
12:00:13 <pygmalion> one more question: that second argument "vals" is supposed to be of type ArithExpr, is there some way for me to do that within the IO code or would the user have to type "ArithExpr "2*3"" for example 
12:00:16 <FunctorSalad_> aristid: nom nom nom
12:00:56 <pygmalion> :r
12:00:59 <pygmalion> damn sorry again
12:01:04 <aristid> pygmalion: we are not ghci :)
12:01:06 <monoidal> pygmalion: IO gives you string. You have to parse it somehow. One way is to add "deriving Read", which means you write as in "ArithExpr (Mul 2 3)" etc
12:01:43 <pygmalion> monoidal: okay. so IO deals exclusively with strings is what i've learned here
12:01:44 <monoidal> pygmalion: another, is to write a parser; see http://book.realworldhaskell.org/read/using-parsec.html
12:02:06 <EvanR-work> pygmalion: Data.ByteString has a bunch of equivalently named IO operations like getLine
12:02:22 <EvanR-work> which return ByteStrings not Strings
12:02:29 <EvanR-work> sometimes thats better
12:02:44 <EvanR-work> but no you cant or shouldnt make IO do the parsing
12:03:00 <monoidal> pygmalion: you can create your own getExpr :: IO ArithExpr using getLine :: IO String
12:03:30 <monoidal> pygmalion: only most of the standard library involve stirngs
12:04:01 <EvanR-work> or liftM parseArith getLine
12:05:04 <EvanR-work> read has the annoying property of being partial
12:08:54 <ksf> ~/.cabal should contain subdirs for different ghc versions, just like ~/.ghc
12:09:30 <sm> how timely after yesterday's game chat: http://togetter.com/li/52328 is reviewing haskell games 
12:09:49 <Heffalump>   prefix: /home/ganesh/ghc/install/$compiler/packages
12:09:59 <Heffalump> ksf: I have that in my .cabal/config
12:12:22 <sm> while I think of it, I have a question: is it expected that a very simple but smooth animation - bouncing a ball around at 60hz - with SDL is going to take about 40% cpu on a macbook ? 
12:12:44 <ksf> it shouldn't.
12:12:50 <ksf> the profiler is your friend
12:13:04 <jfischoff> anyone have any html parsing experience?
12:13:08 <sm> it shows the time is in SDL rendering afiact
12:13:09 <sm> afaict
12:13:28 <sm> I noticed the same thing in another SDL game from hackage
12:13:44 <ksf> well, sdl on osx may suck, yes.
12:14:07 <jfischoff> having trouble getting going with hxt
12:14:29 <ksf> the last time I needed to parse html, I used tagsoup.
12:14:49 <jfischoff> yeah, I like tagsoup, but don't you lose the heirarchy?
12:15:14 <ksf> I'm not sure
12:15:24 <sm> here's the code and a profile: http://gist.github.com/652112 is
12:15:37 <FunctorSalad_> jfischoff: I think that's considered a feature
12:15:43 <FunctorSalad_> since there may not *be* a welldefined hierarchy
12:15:46 <sm> hm, I'll try on another platform when I get the chance
12:16:11 <ksf> sm, DoubleBuffer etc?
12:16:27 <jfischoff> yeah
12:16:33 <sm> I'm hoping with open gl, at least, this can be done with a few percent of cpu, ie without the fan going
12:16:50 <jfischoff> which is why HXT looks nice, it can use the tagsoup as a lexer
12:16:58 <jfischoff> so it is more forgiving
12:17:08 <jfischoff> but the tutorials are out of date
12:17:17 <ksf> whole-screen painting without double buffering is asking for trouble
12:17:32 <sm> ksd: am I using that ? I don't remember how this all works. Hm.
12:17:47 <ksf> well, you clear the whole screen, so you update all of it.
12:18:11 <sm> I did try removing the whole screen clear, and saw no difference
12:18:46 <ksf> it definitely looks like something platform/sdl backend specific
12:18:53 <sm> how does double buffering help there ? Does it do smart optimisation ?
12:19:07 <sm> s/does/could/
12:19:53 <ksf> it solves contention problems in the pixel pipeline
12:20:43 <ksf> ...you don't have to wait for the gfx card to display stuff before painting, again.
12:20:55 <ksf> oh, and don't forget HWSurface
12:21:00 <roconnor> ugh
12:21:08 <roconnor> programming without laziness is a nightmare
12:21:08 <sm> interesting! Time to get acquainted with these here docs
12:21:33 <roconnor> how the hell should I know if a function will use it's argument at call time!?
12:21:39 <ksf> sdl on linux might do that automatically, which might explain that other games don't specify it.
12:22:10 <ksf> roconnor, ever heard of dynamic programming?
12:22:58 <roconnor> ksf: won't help here
12:23:08 <roconnor> will it?
12:23:09 <ksf> and don't get all smug now and say that strictness analysing is undecidable, therefore you can't do it.
12:23:40 <roconnor> let rec mapFamily f = composeT f (mapChildren (mapFamily f))
12:23:45 <roconnor> ^^ this does not work in ocaml :(
12:24:34 <ksf> seems like a thunk is missing, there.
12:24:55 <roconnor> (mapFamily f) should be delayed in case there are no children
12:25:10 <jmcarthur> roconnor: () -> a
12:25:25 <EvanR-work> wrap your strict stuff in lambdas for safety
12:25:48 <roconnor> I could do than
12:25:54 <roconnor> but then I have to rewrite mapChildren
12:25:57 <roconnor> or make a second version
12:26:20 <roconnor> if I rewrite mapChilren everyone who uses it has to thunk it, even if they don't want to thunked.
12:27:15 <jmcarthur> let foo = ... in \() -> foo   -- or whatever the correct syntax would be
12:27:24 <Guest2425> Hy everybody
12:27:26 <Guest2425> hi
12:27:27 <jmcarthur> i believe that should result in foo being strictly evaluated before thunking
12:27:29 <Guest2425> *hi
12:27:44 <Guest2425> How are you guys doing today
12:27:45 <Guest2425> ?
12:27:47 <roconnor> jmcarthur: why would I make everyone who uses mapChildren suffer through that?
12:27:59 <jmcarthur> roconnor: because you are using a language that forces you to do that
12:28:02 <EvanR-work> they are already suffering through ocaml
12:28:03 <jmcarthur> just pass the buck
12:28:10 <roconnor> jmcarthur: do you see a lot of ocaml interfaces that have (() -> foo) arguments?
12:28:18 <roconnor> heh
12:28:23 <roconnor> I should take my griping to #ocaml
12:28:24 <jmcarthur> i don't use ocaml, but i have seen lots of code that uses that idiom
12:28:31 <roconnor> I"m sure I'd get better advice :P
12:28:35 <EvanR-work> roconnor is pretrolling ;)
12:28:35 <jmcarthur> probably
12:28:43 <jmcarthur> i'm curious what they will say
12:28:52 * jmcarthur joins #ocaml
12:30:17 * EvanR-work microwaves some popcorn
12:31:17 <sm> ack.. can't test SDL in ghci
12:31:24 <jmcarthur> yeah :(
12:32:05 <sm> though, I'm not even getting that far.. ghci gives me the same unresolved _SDL_FreeSurface symbol that cabal builds do
12:32:22 <EvanR-work> are you making sure not to use 1.3
12:32:32 <ksf> ocaml.
12:32:55 <ksf> gf's syntactical awkwardness always reminds me of it.
12:32:56 <sm> there might be a stray lib.. that's something to check
12:32:57 <razvandimescu> how can I implement something like multiply 2 3 4 = 24
12:32:58 <razvandimescu> ?
12:33:16 <Zao> razvandimescu: Much like how printf is implemented.
12:33:19 <ksf> > product [2,3,4]
12:33:20 <lambdabot>   24
12:33:20 <Zao> Typeclass majick.
12:33:34 <Zao> Instead though, consider valuing your sanity and use lists.
12:33:34 <monoidal> razvandimescu: usually functions take lists, not multiple arguments
12:33:42 <ksf> in general, you can't. you can do "multiply 2 3 4 ()", though.
12:34:02 <sipa1024> > multiply 2 3 4 ()
12:34:03 <lambdabot>   Not in scope: `multiply'
12:34:04 <Zao> > let multiply a b c = a*b*c in multiply 2 3 4
12:34:05 <lambdabot>   24
12:34:07 <monoidal> razvandimescu: to implement, use fold
12:34:14 <monoidal> in list case
12:34:15 <sm> EvanR-work: yup, no 1.3 stuff installed
12:34:17 <ksf> @src product
12:34:17 <lambdabot> product = foldl (*) 1
12:34:27 <EvanR-work> sm: try installing not osx? ;)
12:34:36 <sm> ?
12:34:44 <Zao> ksf: He did never specify that any other constellation of args than "three of them" would appear though :)
12:34:46 <sm> the good thing is, I know this is solvable because ghc --make builds it fine
12:34:56 <razvandimescu> when i say 1 2 3 i mean any number of arguments
12:35:04 <Zao> razvandimescu: Know lists?
12:35:07 <jmcarthur> razvandimescu: yeah, don't do that. it's asking for trouble
12:35:15 <razvandimescu> and i don't want to use lists
12:35:16 <Zao> razvandimescu: When do you know when to stop?
12:35:22 <Zao> (hint, you don't)
12:35:25 <EvanR-work> idiomatic haskell doesnt do unlimited arguments
12:35:34 <EvanR-work> idiosyncratic haskell does though
12:35:36 <Zao> See ksf's sentinels.
12:35:44 <jmcarthur> > 1 2 3 4
12:35:45 <lambdabot>   Ambiguous type variable `t' in the constraint:
12:35:45 <lambdabot>    `GHC.Num.Num t' arising f...
12:35:51 <EvanR-work> > printf "%d %d %d %s" 1 2 3 "four"
12:35:51 <jmcarthur> duh
12:35:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:35:52 <lambdabot>    `Text.Printf.PrintfType ...
12:35:57 <jmcarthur> > 1 2 3 4 :: Int
12:35:58 <lambdabot>   1
12:36:03 <monoidal> razvandimescu: http://okmij.org/ftp/Haskell/polyvariadic.html
12:36:04 <jmcarthur> > 1 * 2 3 4 :: Int
12:36:05 <lambdabot>   2
12:36:29 <jmcarthur> > let multiply a b = a * b in multiple 1 2 3 4
12:36:30 <lambdabot>   Not in scope: `multiple'
12:36:34 <jmcarthur> > let multiply a b = a * b in multiply 1 2 3 4
12:36:35 <lambdabot>   2
12:36:40 <jmcarthur> amiguous :P
12:36:49 <monoidal> (2+2) 2
12:36:51 <jmcarthur> of course, functions aren't always an instance Num
12:36:52 <monoidal> > (2+2) 2
12:36:53 <lambdabot>   4
12:37:05 <jmcarthur> > (*2) + (+4) $ 7
12:37:06 <lambdabot>   25
12:37:08 <Philippa> razvandimescu: why don't you want to use lists?
12:37:33 <razvandimescu> i'm doing it for learning purposes
12:37:53 <ksf> wait I could use polyvariadic stuff for the html syntax
12:37:54 <razvandimescu> just to understand better how functions word in haskell
12:37:55 <jmcarthur> razvandimescu: if you *have* to, you could look at how printf works
12:37:55 <sbrg> So I wrote my own class that basically has instances for ByteString and [Char] so that I can write code that iwll work with both. A function foo :: MyClass => s -> s -> .. and, in another function bar :: MyClass s => s -> .., what do I need to do to something like: bar firstArg = foo "String literal" firstArg. It doesn't type check and my gut feeling is telling me is that it's because i'm forcing the type by using a string literal and th
12:38:01 <sbrg> I hope this makes sense o.o
12:38:18 <Martty> got cut off at "literal and "
12:38:35 <sbrg> Ah, great.
12:38:36 <ksf> html (head (title "bar") ())  (body ()) ()
12:38:43 <jmcarthur> sbrg: -XOverloadedStrings
12:39:01 <sbrg> jmcarthur: I figured that was exactly what I needed, yet it did not seem to compile
12:39:04 <azudem> hi. (sorry for my english). I read <http://learnyouahaskell.com/for-a-few-monads-more> and can't understand "[result] <- foldM foldingFunction [] (words st)". I think foldM return e.g. Maybe [1,2,3]. But what is [result] <- Maybe [1,2,3]? For full code see link.
12:39:07 <sbrg> Ah
12:39:24 <sbrg> Perhaps i Need to put it in the module where I define the function, not the type class -_-
12:39:39 <jmcarthur> yes
12:39:42 <monoidal> azudem: [result] <- Maybe [1,2,3] is the same as: x <- Maybe [1,2,3]; let [result] = x
12:39:49 <jmcarthur> sbrg: it may also require an import... Data.String i think
12:39:50 <sbrg> jmcarthur: lol, thanks. Massive brain fart
12:39:54 <sbrg> Yep
12:39:58 <jmcarthur> sbrg: because it uses a type class that's not in scope by default
12:40:00 <jmcarthur> alright cool
12:40:03 <sbrg> Thanks.
12:40:06 <jmcarthur> np
12:40:43 <jmcarthur> > Just [1,2,3] >>= return
12:40:44 <lambdabot>   Just [1,2,3]
12:41:00 <jmcarthur> > Just [1,2,3] >>= \x -> return (map (+1) x)
12:41:01 <lambdabot>   Just [2,3,4]
12:41:17 <Philippa> razvandimescu: for learning purposes, functions don't work that way in haskell, they take exactly one argument each
12:41:49 <azudem> monoidal: lambdabot: What is [result] <- Just [1,2,3]. What will be result?
12:42:12 <roconnor> jmcarthur, EvanR-work: Okay, inlining and simplying composeT works for me.  That puts the recurive call under a lambda, but it isn't very modular.
12:42:15 <monoidal> azudem: this is the same as let [result] = [1,2,3]. it fails
12:42:18 <ksf> gf's dependent types don't carry over to haskell GADTs
12:42:19 <mauke> azudem: nothing
12:42:25 <mauke> monoidal: I don't think it's the same
12:42:29 <jmcarthur> razvandimescu: i'm with Philippa. there's basically no reason to learn this, especially early. it's not considered a great idea to fiddle with semantics just for some syntactic sugar. if you want a special syntax you could look into a quasiquoter or something (but i also wouldn't recommend that for a beginner)
12:42:32 <monoidal> azudem: in Maybe monad, it is the same as Nothing
12:44:09 <razvandimescu> Philippa: but plus 2 3 it's a function that takes 2 arguments, even though haskell only allows one argument
12:44:17 <monoidal> mauke: right
12:44:24 <Philippa> sort of. Actually it's only "a function that takes 2 arguments" by isomorphism
12:44:39 <monoidal> azudem: it is not exactly the same as let, but quite close. sorry for confusion
12:44:41 <razvandimescu> Philippa: therefore it should be possible to do plus 2 3 4
12:44:46 <Philippa> taken literally, it's a call of a function that returns another function which when called finally returns the intended answer
12:44:46 <mauke> razvandimescu: no, plus only takes one argument
12:44:57 <Philippa> and your therefore doesn't follow
12:45:00 <azudem> <http://paste.org.ru/?g3dk88> So, if [result] <- Just [1], result will be 1. But if [result] <- Just [1,2,3], then result will be..? Nothing?
12:45:06 <jmcarthur> razvandimescu: plus :: a -> (a -> a)  -- one argument
12:45:22 <monoidal> azudem: the whole computation in do-block will give Nothing
12:45:34 <roconnor> EvanR-work, jmcarthur: maybe I should put force and delay around my composeT
12:45:37 <jmcarthur> razvandimescu: you could also define a *new* version of plus :: a -> (a -> (a -> b))
12:45:41 <monochrom> plus takes 1 argument, gives a function again. "plus 1" is such a function. let g = "plus 1". g takes 1 argument. g 2 gives you 3.
12:45:54 <jmcarthur> razvandimescu: but you can't just freely have two functions with the same name and different types like that
12:45:55 <monoidal> razvandimescu: do you understand typeclasses well?
12:46:02 <roconnor> strict languages are pretty crappy for higher-order functions.
12:46:23 <jmcarthur> roconnor: it's what you get when you don't wear the hair shirt
12:46:39 <Zao> Oh joy. Now it's synching my five copies of Boost.
12:46:45 <Zao> Including staged libraries and objs :(
12:46:46 <azudem> monoidal: if foldM return Just 1, then "result" will be 1?
12:46:59 <monoidal> azudem: yes
12:47:01 <monochrom> arguing "conceptually" is not how you convince a computer to work for you. computer couldn't care less about "concepts"
12:47:14 * Zao notices that this isn't channel #6.
12:47:19 <azudem> monoidal: Ok. But if foldM return Just [1,2] ?
12:47:26 <dolio> There aren't many languages where, "function f takes 2 arguments, therefore it should also be able to take 3 arguments," would be considered a sensible argument.
12:47:43 <monoidal> azudem: there will be no binding to result. The enclosing do-block will give Nothing.
12:47:51 <monoidal> azudem:
12:48:01 <mauke> .oO( perl, php, javascript )
12:48:12 <azudem> monoidal: but who return Nothing?
12:48:14 <monoidal> > x <- Just 5; (y, 2) <- Just (1,3); return (x,y)
12:48:15 <lambdabot>   <no location info>: parse error on input `;'
12:48:16 <Kaidelong> does someone know why there is nothing like replicateM in Vector.Generic.Mutable?
12:48:18 <monoidal> > do x <- Just 5; (y, 2) <- Just (1,3); return (x,y)
12:48:19 <lambdabot>   Nothing
12:48:43 <monoidal> azudem: above, (y,2) didn't match (1,3). The whole do-block "aborts"
12:48:46 <jmcarthur> Kaidelong: an interesting function for a mutable array
12:48:52 <sipa1024> :t replicate
12:48:53 <lambdabot> forall a. Int -> a -> [a]
12:48:59 <jmcarthur> Kaidelong: what if the actions it executes modify the array?
12:49:29 <AnotherLomono> yay I finished Chapter 1 of RWH
12:49:29 <monochrom> javascript takes no fixed number of arguments. it has syntax sugar for faking "2 arguments", "3 arguments", etc.
12:49:31 <azudem> monoidal: Ok. But why if do-block abort, it return Nothing? Why not error?
12:49:34 <AnotherLomono> time for a break :V
12:49:44 <monoidal> azudem: in Monad typeclass, there's a special function called "error"
12:49:48 <jmcarthur> > fail "AHH!" :: Maybe Int
12:49:49 <lambdabot>   Nothing
12:49:49 <monoidal> :i Monad
12:49:51 <mauke> monoidal: no, there isn't
12:49:54 <dolio> Really? I don't remember that about javascript at all.
12:49:55 <mauke> and there is no :i
12:49:57 <jmcarthur> monoidal: called fail
12:50:01 <monoidal> oh, sorry. fail
12:50:02 <Kaidelong> jmcarthur: the order in which they are performed should be deterministic so the same thing each time with the same startin gstate, hopefully
12:50:14 <Kaidelong> unless the actions in question are IO actions
12:50:31 <monochrom> function funny() { for (var i=0; i<arguments.length; i++) { ... use arguments[i] here ... } }
12:50:36 <Kaidelong> but you don't assume that things in IO are deterministic if your array is in IO
12:50:38 <monoidal> azudem: it is called when pattern matching fails. For Maybe monad, it gives Nothing; for IO, it throws exception.
12:50:49 <dolio> Wow, that's crazy.
12:51:05 <monochrom> and yes I painstakingly read and deciphered E262 edition 3
12:51:15 <azudem> monoidal: :) I understand. Thanks very much!
12:52:02 <dolio> I guess that makes all the "Javascript is like Lisp" talk a little more justified.
12:52:51 <jmcarthur> Kaidelong: i didn't mean it would be nondeterministic. presumably we're in the ST monad here. i do suppose it's okay though. i guess the action you are executing can't really access the array it's creating... or does ST instantiate MonadFix?
12:52:58 <jmcarthur> either way it doesn't matter
12:53:04 <jmcarthur> you could do the same things even without replicateM
12:54:06 <Kaidelong> jmcarthur: it does seem strange to me it isn't there. Even in the worst kinds of abuse you'd just end up with something like v (IO (MVector v a))
12:54:28 <Kaidelong> err
12:54:33 <Kaidelong> well not exactly
12:54:39 <jmcarthur> Kaidelong: i think mutable arrays tend not to get the nice treatment that immutable ones do :\
12:54:40 <Kaidelong> but that sort of general idea
12:55:11 <jmcarthur> granted it's a bit tougher
12:55:58 <monochrom> if your javascript function looks like "function one(x) { ... }" there is no prohibition of calls like "one()". x would just be left undefined.
12:56:41 <Kaidelong> I think I'll just use DiffArrays
12:57:06 <monochrom> therefore I use a dependent type system in my mind when I write in javascript
12:57:42 <monochrom> but I use a dependent type system in my mind when I write in Haskell anyway.
12:58:15 <EvanR-work> sounds like i need to learn this dependent type system
12:58:16 <djahandarie> Really? Isn't that kind of annoying?
12:58:26 <EvanR-work> because i use a basic polymorphic static type system when i write js ;)
12:58:31 * monochrom is not afraid of head, fromJust, unsafeDivideByANumberNotKnownToBeNonZeroAtCompileTime
12:58:51 <EvanR-work> blasphemy!
13:02:29 <alex404> Does anyone have any experience with MWC Random? Does it not return a generator when you use it? Am I supposed to use withSystemRandom everytime I want to a new number?
13:02:55 <alex404> (I'm a random newb, so maybe I'm just not getting it)
13:07:28 <Cale> alex404: one moment
13:07:41 <alex404> Cale: cheers
13:08:15 <razvandimescu> jmcarthur: so i can't override a function in haskell? just like in c++?
13:08:19 <Cale> okay, so... let's see, PrimMonad is just a class for ST and IO
13:08:26 <alex404> Indeed
13:09:33 <Cale> ah, and Gen is a reference to the state of the random number generator
13:09:37 <wlangstroth> dolio: it's said that Brendan Eich was originally planning a Lisp as the client language, and then Java became popular
13:09:57 <alex404> Cale: How does that work though. Gen is a constructor.
13:10:01 <Cale> So you shouldn't have to use withSystemRandom more than once
13:10:29 <Cale> -- | State of the pseudo-random number generator.
13:10:29 <Cale> newtype Gen s = Gen (M.MVector s Word32)
13:10:37 <Cale> MVector is a mutable array type
13:10:44 <mwc> wlangstroth: they were originally going to call it "live script" and then netscape negotiated the rights to "java" the name to hitch onto its hype as the language of the web
13:11:04 <sipa1024> razvandimescu: a function name can refer to different implementations (instances) based on its type, but there is always exactly one definition
13:11:09 <jmcarthur> razvandimescu: no overriding, correct.
13:11:28 <jmcarthur> razvandimescu: we do have a form of overloading, but that's different of course
13:11:50 <alex404> Cale: So wait, where is that declared? Because I'm looking at System.Random.MWC and all I see is a 'data Gen s' declaration
13:12:13 <monochrom> c++ is a wrong mental model for knowing haskell
13:12:13 <wlangstroth> mwc: it's sad, really - a dialect of Lisp was very close to being the most used language in the world
13:12:19 <alex404> Cale: Ah... the source code.
13:12:29 <Cale> alex404: Yeah, the data constructor isn't exported, so it doesn't show up in the documentation
13:12:57 <Cale> But if you look at the source code, you can see that the implementation is via mutable state
13:14:14 <Vanadium> monochrom: But C++ has functors, just like haskell!
13:14:16 * Vanadium hides
13:14:49 <Cale> Vanadium: It has various specific functors (like various sequence types), but not a way to generalise over them.
13:15:11 <djahandarie> I'm sure there's some way to hack in the generalization
13:15:15 <alex404> Cale: Indeed.. so somehow if I reuse the Gen, then I should have a new generator. So I use it in an appropriate monad, maintain a reference to the Gen, and if I reuse, it should be updated?
13:15:25 <Cale> yeah
13:16:00 <djahandarie> Cale, know much about generalized morphisms?
13:16:06 <djahandarie> Like what they're good for
13:16:21 <Watermind> hi guys, I thought I had understood lazy pattern matching ( ~ )  but apparently not
13:16:39 <alex404> Cale: Sweet, thanks.
13:16:44 <Watermind> so partitionEithers may not work on infinite lists
13:16:55 <Watermind> why does this version of mine work?
13:17:03 <Watermind> http://haskell.pastebin.com/5XUG81zz
13:17:38 <Watermind> I'd expect it to have the same problem, but unlike partitionEithers it runs fine... why doesn't it get stuck?
13:17:57 <Cale> Watermind: A lazy pattern always accepts (regardless of whether it actually matches or not), and only if the value of a variable bound by the pattern is evaluated will it actually check if the pattern matches.
13:18:07 <razvandimescu> can i find out if my parameter is a function or a number?
13:18:07 <Watermind> Cale: yes that I know :)
13:18:24 <Watermind> Cale: and then I was shown some examples of what it useful for
13:18:37 <Cale> djahandarie: I'm not sure what generalised morphisms means here. Moar context?
13:18:47 <Watermind> Cale: and there's partition that uses it, and partitionEither which should use it
13:18:51 <Cale> razvandimescu: You can construct a typeclass like:
13:18:56 <Cale> class Foo a where
13:18:58 <djahandarie> Cale, when you replace the Algebra with a Dist and GAlgebra
13:19:01 <Cale>   foo :: a -> Integer
13:19:08 <Cale> instance Foo Integer where
13:19:11 <Cale>   foo n = ...
13:19:17 <djahandarie> (Usually meaning you get a Monad or similar constraint in the type)
13:19:28 <Cale> instance Foo (Integer -> Integer) where
13:19:31 <Cale>   foo f = ...
13:19:32 <Watermind> Cale: partitionEithers gets stuck if you pass it an infinite list with just Lefts or Rights, because you never get a pair satisfying the required pattern matching
13:19:51 <Cale> djahandarie: Oh, so you're talking about category-extras?
13:19:52 <djahandarie> i.e., rather than (Functor f) => (a -> f a) -> a -> Mu f ... (Functor f, Monad m) => (forall a. m (f a) -> f (m a)) -> (a -> f (m a)) -> a -> Mu f
13:20:10 <Watermind> Cale: now I did another version which does work, but which I would expect to suffer from the same problem, and I don't understand why it doesn't
13:20:10 <djahandarie> I was looking at it, but not neccessarily
13:20:19 <djahandarie> (That was an anamorphism)
13:20:26 <Philippa> razvandimescu: you can't simply check at run-time (other than by using an algebraic datatype or the generalised version), but you can use type classes to do a static dispatch
13:20:46 <djahandarie> I can't think of where you would need a generalized version
13:22:07 <Cale> djahandarie: Okay, so my initial impression is that the generalised recursion schemes are just a way to let you carry out the same pattern of recursion, but with monadic computations, analogously to map -> mapM
13:22:28 <Cale> But I'd have to work out the details.
13:22:37 <djahandarie> Alright, that gives me something to think about
13:24:06 <Cale> djahandarie: Let's look at catamorphisms, since they're probably more familiar than anamorphisms...
13:24:21 <Cale> cata :: Functor f => Algebra f a -> FixF f -> a
13:24:36 <Cale> So, in the case where f = [], this is analogous to foldr
13:24:40 <djahandarie> Yep
13:25:25 <Cale> An algebra for [] being a function [A] -> A (for a specific type A)
13:27:27 <Cale> hmm, okay, so this really is different...
13:27:38 <Cale> A generalised algebra involves a comonad w
13:28:37 <Cale> hmm, yeah, I'm not sure.
13:28:49 <djahandarie> Alright
13:28:56 <djahandarie> I'll see if I can catch edwardk sometime
13:29:01 <Cale> I somehow highly doubt that anyone's actually put these things to use in real code ;)
13:29:07 <djahandarie> lol
13:29:08 <Watermind> here is a better example file:
13:29:09 <Watermind> http://haskell.pastebin.com/hWG1jM3t
13:29:16 <Cale> It's probably a case of "because we can" ;)
13:29:22 <Watermind> why does partE work and partE' gets stuck?
13:30:33 <Watermind> these are basic implementations of partitionEithers 
13:31:27 <djahandarie> It'd be nice if I could specific  a partial type signature in ghci and it'd give me the rest
13:31:28 <Cale> Because select pattern matches on the pair which must be computed from folding over the remainder of the list, and so that pair must be evaluated
13:31:32 <djahandarie> specify*
13:32:00 <Cale> pattern matching is at some level what is responsible for inducing all evaluation which happens
13:32:27 <Watermind> ok, so why does the 1st one work?
13:32:56 <Watermind> there's the same pattern matching going on in the where clauses
13:32:59 <Cale> Because pattern bindings are lazy.
13:33:25 <Cale> There's an implicit ~ before the (as,bs) pattern inside the where clause
13:33:37 <Watermind> ohhhhhhhhh
13:33:44 <Cale> Because where and let will never cause evaluation to occur.
13:34:25 <Cale> You can also fix the second version simply by adding some ~s before the (as,bs) pattern
13:35:06 <Watermind> so you mean     f ~(a,b) = ...    <=> f p = let (a,b) = p in ... ?
13:35:13 <Cale> yep
13:35:16 <Watermind> damn
13:35:22 <Watermind> this was driving me nuts
13:35:47 <Cale> Note that you could also write  select (Left a) p = (a : fst p, snd p)
13:35:55 <Cale> and that would mean the same thing
13:36:13 <Watermind> yes I am aware of that
13:37:32 <Watermind> thanks Cale! that was really tricky
13:37:33 <Cale> Oh, something to be aware of, I said that where and let don't cause evalution, but if you have bang patterns, the translation is currently such that they can transform let into case.
13:37:49 <Watermind> yes makes sense
13:37:53 <Cale> (which is something I really don't like actually)
13:37:56 <Watermind> why?
13:38:08 <Watermind> ignoring the bang would be quite akward I think
13:38:48 <Cale> Well, it's not really ignoring the bang -- it would be applying it once the thing needed to be evaluated as usual.
13:39:01 <Cale> (and if you put it at the outermost level, it would be pointless, yes)
13:39:33 <Cale> But that's more consistent with the view that let and where only serve to make definitions, not to cause evaluation. If you want evaluation, you use case.
13:39:51 <Cale> (I admit that's a rather operational view of things)
13:40:13 <EvanR-work> pass the pointer to the haskell procedure
13:40:30 <Watermind> yes I see your point, I was just thinking of outtermost bangs
13:40:39 <Cale> In fact, that's how bang patterns worked when they were first introduced, but they decided to "fix" things. :)
13:40:47 <Watermind> ah
13:40:53 <Cale> The translation was simple then, and it's really complicated now.
13:41:13 <EvanR-work> i want interrobang patterns from the next haskell spec
13:41:30 <Watermind> what would those be fore?
13:41:34 <Watermind> *for
13:41:43 <EvanR-work> for causing the operator to go wtf
13:41:54 <monochrom> Notice how the code of Control.Monad.State.Strict and Control.Monad.State.Lazy differ artificially and how their similarity and exact difference could be absolutely apparent if either (both use case, but one of them has ~) or (both use let, but one of them has !).
13:41:56 <Saizan> speculative evaluation, of course
13:42:04 <sproingie> that would be a good way to type interrobang.  <compose> w t f
13:42:21 <sproingie> (cuz <compose> ? ! is too hard to remember)
13:42:33 <monochrom> I prefer to denounce "case is for evaluation, let is for definition" for that.
13:46:33 <ksf> http://hpaste.org/40948/good_idea is that a good idea?
13:47:46 <ksf> ...with type families then compiling a remotely readable spec dsl to the gadt
13:48:53 <ksf> or should I do HList-like predicate classes?
13:49:16 <pumpkin> Struct Seq (Struct Elem Head, Struct Elem Body) ~ a => a -> Struct Nest (Html, a)
13:49:24 <pumpkin> why not just substitute for a in there?
13:49:28 <pumpkin> to avoid writing it twice?
13:49:33 <ksf> because I'm lazy.
13:49:37 <pumpkin> hah
13:49:41 <Cale> Yeah, I figured it's because he didn't want to type that thing twice
13:49:54 <pumpkin> it's kind of a cute type-level let in that sense
13:50:17 <Saizan> ksf: s/ a / e / in Nest's type?
13:50:30 * ksf would love it when ghc would be able to cse types
13:50:33 <ksf> Saizan, yes.
13:52:31 <ksf> oh, I forgot attributes.
13:53:00 <Cale> Attributes are so silly.
13:53:06 <monochrom> See also http://article.gmane.org/gmane.comp.lang.haskell.cafe/27746/  although you could say ! is not needed.
13:53:15 <pumpkin> I agree
13:53:41 <Saizan> i'm not sure why you've made Struct take 2 type parameters rather than making Elem :: * -> *; Seq, Nest :: * -> * -> *; you don't seem to be using the extra structure
13:54:26 <ksf> I need to be able to distinguish between nests and sequences in the predicates.
13:54:57 <ksf> at least I think so.
13:55:39 <ksf> err wait.
13:55:48 <ksf> I could actually get rid of elem.
13:56:10 <ksf> but then, HList could get rid of Proxy.
13:57:41 <ksf> Elem :: (TypedSequence Attr a) e -> a -> Struct Elem (e, a)
13:58:16 <Cale> ksf: I think Saizan is suggesting not to use the phantom types as such, but instead to make Nest, Seq, and Elem into proper datatypes with those constructors stolen out of your GADT
13:58:31 <ksf> I'm kinda surprised I didn't find anything about enforcing arbitrary structural invariants in GADTs
13:59:01 <ksf> but I don't want to care about whether to put one or multiple tags into a tag
14:00:33 <Saizan> Cale: actually no :) just that i didn't find a reason to separate the tags from their arguments
14:00:49 <pumpkin> ksf: sketch out your structure in agda first (keeping in mind haskell's limitations), then backport it to haskell GADTs :)
14:01:06 <Kaidelong> looks like I'm better off using pure vectors than diffarray
14:01:24 <EvanR-work> haskell is so limitted!
14:01:30 <EvanR-work> it cant do anything
14:01:43 <Ke> !
14:02:02 <Kaidelong> you could implement agda in Haskell?
14:02:07 <Kaidelong> anyway, from what I understand
14:02:12 <monochrom> http://www.vex.net/~trebla/humour/lazy-question-stream.html?q=What%20can%20Haskell%20do?
14:02:13 <sipa1024> isn't agda implemented in haskell?
14:02:19 <Kaidelong> pure vectors will sometimes do their updates in place if possible, right?
14:02:22 <ksf> that, and it even targets haskell.
14:02:23 <EvanR-work> @faq can haskell implement agda
14:02:23 <lambdabot> The answer is: Yes! Haskell can do that.
14:02:28 <ksf> lotsa unsafeCoerces, though.
14:03:12 <yitz> @vixen haskell is so limitted, it can't do anything.
14:03:12 <lambdabot> church is my favourite computer scientist.
14:03:48 <EvanR-work> @vixen haskell
14:03:48 <lambdabot> church is my favourite computer scientist.
14:03:50 <monochrom> agda is implemented in haskell. get it from hackage. cabal-install works.
14:03:51 <EvanR-work> @vixen java
14:03:51 <lambdabot> do you trust the government?
14:04:10 <EvanR-work> @vixen php
14:04:10 <lambdabot> I Think you're fake
14:04:12 <monochrom> (and yes, it did horrify me when I first knew that)
14:04:27 <Saizan> ksf: sigfpe has a blog post about abusing type families and linear algebra to encode arbitrary constraints, as long as you can specify them as a DFA
14:04:29 <monochrom> hahahaha lambdabot thinks you're fake! lambdabot has spoken!
14:04:31 <Philippa> heh. Haskell's a fairly natural choice for such things
14:04:37 <ksf> dfa is fine.
14:05:03 <yitz> agda should be implemented in agda
14:05:06 <Philippa> you might want an implementation of the core language in something that lets you do the metatheory proofs sometime, sure...
14:05:11 <ksf> http://blog.sigfpe.com/2010/08/constraining-types-with-regular.html
14:05:14 <wlangstroth> yitz: go for it
14:05:21 <Philippa> yitz: no, it shouldn't. You can hide an implementation bug that way
14:05:39 <yitz> Philippa: ?
14:05:40 <sipa1024> @vixen what is the answer to the ultimate question of life, the universe, and everything?
14:05:40 <lambdabot> let's don't talk about that
14:05:54 <AnotherLomono> is there an ML in Haskell
14:06:01 <monochrom> not yet
14:06:03 <HaskellElephant> @vixen is HaskellElephant in charge?
14:06:03 <lambdabot> Ooh, functional programmers are so hot!
14:06:12 <monochrom> but I know of ML's in Lisp
14:06:17 <HaskellElephant> damn straight!
14:06:21 <pumpkin> Haskeml
14:06:31 <Philippa> yitz: I forget the name of the paper, but the old result about being able to hide a malicious compiler (by extension, interpreter) applies
14:06:37 <AnotherLomono> I would think that SPJ wouldn't mind someone doing Haskell in F#
14:06:52 <monochrom> zomg, #haskell is becoming a zoo. haskellelephant, haskellbat, haskellfrog...
14:06:54 <AnotherLomono> didn't he put out a call for Haskell on .Net a loooong time ago
14:06:56 <HaskellElephant> @vixen is there an ML in Haskell?
14:06:56 <lambdabot> Ooh, functional programmers are so hot!
14:06:57 <Philippa> I've implemented something approximating a miniML in haskell a few times
14:07:10 <Philippa> what with it being a standard testbed for H-M derived type systems
14:07:12 * monochrom looks at the calendar, not halloween yet...
14:07:28 <monochrom> can pumpkin become haskellpumpkin?
14:07:39 <haskellpumpkin> I think so
14:07:45 <monochrom> heh thanks
14:08:13 <yitz> monochrom: then there's LazyManateeCat
14:08:25 <Philippa> Agda should, eventually, be implemented in a core logic small enough to verify by hand, no?
14:08:54 <Philippa> de bruijn criterion and all that
14:09:16 <Philippa> (so okay, I guess agda-in-agda is less vulnerable to that class of exploit than, say, C in C)
14:09:17 <yitz> Philippa: that hand will be connected to a brain, in which can be hidden a malicious compiler
14:09:20 <Kaidelong> looks like what I want is Data.Vector.Generic.New and Data.Vector.Fusion.Stream
14:09:34 <Kaidelong> anyone have experience using those libraries?
14:09:37 <AnotherLomono> whoa Haskell on .NET is even in the FAQs
14:09:39 <monochrom> I played with the theorem prover HOL 88. It was written in an old ML. So old, the theorem prover tarball had to provide the ML implementation too, in Lisp, and so it says, "you need allegro lisp or something", and then the build process first built ML and then built the theorem prover.
14:09:46 <Philippa> yitz: it's more "if someone drops a malicious binary that compiles its own exploit into things that look like a compiler..."
14:09:59 <haskellpumpkin> Philippa: I don't think it will be
14:10:04 <Saizan> Philippa: de brujin criterion has not much to do with the language in which the compiler is implemented, e.g. Coq is implemented in O'Caml but it's still translated to a small core
14:10:05 <haskellpumpkin> :P
14:10:12 <Philippa> you can introduce malice without any visible source trace of it, anyway
14:10:41 <haskellpumpkin> international underhanded c contest
14:11:16 <Philippa> Saizan: it doesn't directly, no. I suspect there's /still/ a class of exploit whereby you change the type to allow it as well, mind
14:11:37 <Philippa> bear in mind, when I get paranoid I get /really/ paranoid. And when you're playing with foundational maths... :-)
14:11:56 <Kaidelong> anyway, I suppose I have to write my final production stuff in C# anyway, so I'll just save learning the ins and outs of vectors for later
14:12:07 <Kaidelong> and do my prototype in C#
14:12:09 <monochrom> Indeed theorem provers (those before HOL, like LCF) were the origin of ML. The very name "meta language" confirms it. It was supposed to be a formal, programmable meta language for the logic of the prover.
14:12:43 <Philippa> Saizan: anyway, my point was more that you can use a /different/ core implementation that's small enough to check and with a trustable compiler (in a pinch, hand-compile it)
14:13:14 <haskellpumpkin> how small is coq's notoriously small core?
14:13:33 <Saizan> Philippa: i see, i was arguing from a quite less paranoid position :)
14:14:00 <AnotherLomono> coq-8.3.tar.gz	3.7 MB
14:14:17 <pumpkin> AnotherLomono: that's a lot more than the de-bruijn-criterion-satisfying core, though
14:14:20 <sm> ksf: oh, you sent me off on a wild yak-shaving expedition there... 
14:14:54 * pumpkin is actually going to submit some code to the agda codebase in the next few days!
14:14:56 <pumpkin> fancy that
14:15:03 <sm> it's hard to tell if HWSurface & DoubleBuf make any difference to cpu usage, since they require FullScreen as I understand it (and then I can't see activity monitor)
14:15:23 <AnotherLomono> pumpkin: I don't know how much of it is documentation
14:15:47 <sm> in windowed mode, increasing the requested screen depth from 16 to 32 reduces the cpu usage from 44% to 16%
14:15:47 <AnotherLomono> maybe the source is literate :V
14:15:51 <Saizan> AnotherLomono: i think pumpkin is not asking for the implementation, but for the formal system
14:15:59 <AnotherLomono> oh I see
14:16:23 <sm> which is acceptable
14:16:34 <pumpkin> I just mean, we occasionally get coq trolls (okay, just once in my memory) joining #agda saying "omg you don't satisfy the dBC you suck"
14:16:44 <pumpkin> how much smaller is their small core?
14:16:55 * Saizan doesn't know
14:17:21 <Philippa> it's a family of PTSes, amongst other things...
14:17:34 <Philippa> (on account of the Type hierarchy)
14:17:43 <Philippa> as a PTS it doesn't strike me as /that/ small
14:17:55 <Philippa> (I don't think I've read what Agda's core is, though?)
14:20:16 <Philippa> actually wait, I forget if there's anything in it that contradicts being a PTS ("but you can embed it as a PTS with the right terms!" is cheating, obviously)
14:20:42 <Philippa> from memory it's big enough to be slightly annoying but small enough to be reasonably quick to check, anyway
14:28:11 --- mode: asimov.freenode.net set +o ChanServ
14:29:00 <donri> 666 users, yay!
14:29:46 <EvanR-work> it should stay at 666 all day sunday
14:30:05 <copumpkin_> :t foldl
14:30:06 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:30:11 * sm seeks clues on #sdl 
14:30:17 <copumpkin_> I kind of like the view of that as (a -> b -> a) -> (a -> [b] -> [a])
14:30:24 <copumpkin_> (a -> [b] -> a) that is
14:30:26 <monochrom> McManiaC: I suggest something like http://hpaste.org/40949/parse or else restructure the whole parser.
14:31:09 <donri> > sum [1..36]
14:31:09 <lambdabot>   666
14:32:03 <EvanR-work> > replicate 3 (sqrt 36)
14:32:04 <lambdabot>   [6.0,6.0,6.0]
14:32:15 <monochrom> godawful, the haskell platform is now in ubuntu too?
14:32:21 <McManiaC> monochrom: I'd love to restructure it, but I cant see how
14:35:07 <McManiaC> monochrom: ah well, I guess I'll just make those quotes plaintext
14:35:08 <McManiaC> :)
14:35:21 <donri> > map take 1 . show $ replicate 3 (sqrt 36)::Int
14:35:22 <lambdabot>   Couldn't match expected type `a -> b'
14:35:22 <lambdabot>         against inferred type `[[a1] ...
14:35:36 <donri> > map (show . take 1) $ replicate 3 (sqrt 36)::Int
14:35:37 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:35:37 <lambdabot>         against inferred type ...
14:35:39 * donri newb
14:36:33 <McManiaC> hehe
14:37:02 <roconnor> copumpkin_: dBC is subjective and misses the point
14:37:26 <copumpkin_> oh, I'm not a fan of it, but was just wondering how small coq was
14:37:26 <roconnor> copumpkin_: as Gothier notes, the point is errors can be found in Coq, corrected, and the proofs rechecked.
14:37:34 <Saizan> donri: you need parentheses to limit the scope of type annotations
14:37:35 <copumpkin_> if you know what I mean by small coq
14:37:40 <copumpkin_> <_<
14:37:40 <roconnor> can and have been found
14:37:45 <donri> I thought that was what I did
14:37:59 <donri> > map take 1 . show $ replicate 3 ((sqrt 36)::Int)
14:38:00 <lambdabot>   Couldn't match expected type `a -> b'
14:38:00 <lambdabot>         against inferred type `[[a1] ...
14:38:02 <donri> :(
14:38:21 <roconnor> copumpkin_: http://r6.ca/blog/20061211T203500Z.html
14:38:35 <c_wraith> donri, :: is not a conversion operator.
14:38:37 <kyagrd> > map take 1 . show $ replicate 3 ((ceil $ sqrt 36)::Int)
14:38:38 <AnotherLomono> roconnor: I was told that there's a reason why any failure that had to do with AirBus was always due to pilot error
14:38:38 <lambdabot>   Not in scope: `ceil'
14:38:42 <kyagrd> > map take 1 . show $ replicate 3 ((ceiling $ sqrt 36)::Int)
14:38:43 <lambdabot>   Couldn't match expected type `a -> b'
14:38:43 <lambdabot>         against inferred type `[[a1] ...
14:38:47 <companion_cube> is there a way to import a module (with some datatype) and not the instances declared for this datatype ?
14:38:52 <kyagrd> :t cealing
14:38:53 <lambdabot> Not in scope: `cealing'
14:38:56 <copumpkin_> roconnor: :O
14:38:59 <kyagrd> :t ceil
14:39:00 <lambdabot> Not in scope: `ceil'
14:39:01 <kyagrd> :t ceiling
14:39:02 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:39:05 <kyagrd> yes this one
14:39:06 <Saizan> ?type map take 1 . show 
14:39:06 <lambdabot>     Couldn't match expected type `a -> b'
14:39:07 <lambdabot>            against inferred type `[[a1] -> [a1]]'
14:39:07 <lambdabot>     In the first argument of `(.)', namely `map take 1'
14:39:07 <roconnor> AnotherLomono: A Coq proof is still better than the alternative
14:39:08 <donri> c_wraith: nah but it kicks in the type inferrance eh?
14:39:10 <copumpkin_> so people do prove false in coq
14:39:15 <copumpkin_> very nice
14:39:17 <copumpkin_> I feel reassured
14:39:23 <Saizan> companion_cube: no
14:39:25 <kyagrd> :t ceiling (sqrt 36)
14:39:26 <lambdabot> forall b. (Integral b) => b
14:39:30 <c_wraith> donri, it only specifies the type of an expression.  If the expression you give it cannot have the type it specifies, then you get an error
14:39:31 <AnotherLomono> copumpkin_: think about it the next time you fly on an AirBus plane :v
14:39:33 <companion_cube> thanks, Saizan 
14:39:33 <roconnor> copumpkin_: Bruno is one of the developers of coq.  He has an edge
14:39:37 <kyagrd> :t (ceiling (sqrt 36) :: Int)
14:39:38 <lambdabot> Int
14:39:40 <c_wraith> > 33.5 :: Int -- donri
14:39:41 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
14:39:41 <lambdabot>    arising from the lit...
14:39:42 <donri> c_wraith: 'course
14:39:43 <kyagrd> This will work
14:39:55 <c_wraith> donri, well, the result of sqrt *cannot* be of type Int
14:40:11 <donri> Makes sense
14:40:14 <kyagrd> > show $ replicate 3 ((ceiling $ sqrt 36)::Int)
14:40:15 <lambdabot>   "[6,6,6]"
14:40:19 <copumpkin_> AnotherLomono: that's fine
14:40:42 <kyagrd> > show $ replicate 3 ((floor $ sqrt 36)::Int)
14:40:43 <lambdabot>   "[6,6,6]"
14:40:49 <donri> > map show . take 1 $ replicate 3 ((ceiling $ sqrt 36)::Int)
14:40:50 <lambdabot>   ["6"]
14:40:54 <donri> lol
14:41:11 <donri> > take 1 "6"
14:41:12 <lambdabot>   "6"
14:41:20 <donri> Oh, duh
14:41:25 <donri> > head "6"
14:41:25 <lambdabot>   '6'
14:41:26 <AnotherLomono> lol
14:41:33 <donri> > map head . show $ replicate 3 ((ceiling $ sqrt 36)::Int)
14:41:34 <lambdabot>   Couldn't match expected type `[a]'
14:41:34 <lambdabot>         against inferred type `GHC.Types...
14:41:43 <donri> > map show . head $ replicate 3 ((ceiling $ sqrt 36)::Int)
14:41:43 <lambdabot>   Couldn't match expected type `[a]'
14:41:43 <lambdabot>         against inferred type `GHC.Types...
14:41:52 * donri shoots self in head
14:42:09 <kyagrd> > map (head . show) $ replicate 3 ((ceiling $ sqrt 36)::Int)
14:42:10 <lambdabot>   "666"
14:42:14 <donri> There you go.
14:42:30 <donri> I never learn how . works with priority
14:42:58 <Saizan> oh, you thought map head . show == map (head . show) ?
14:43:02 <kyagrd> $ has the loest priority so you don't even need to think about (.)
14:43:06 <donri> I probably did
14:43:08 <kyagrd> lowest I mean
14:43:28 <Saizan> function application has higher priority of any operator
14:43:31 <Philippa> roconnor: the dBC's close enough to something that's objective-for-practical-purposes as to not be worth the effort to push a bit closer for most people, I feel. But yeah
14:43:37 * donri haven't really *used* Haskell yet
14:43:47 <Saizan> that's enough to rule out that parse
14:44:16 <donri> I don't see why :$
14:44:52 <copumpkin_> we just need a self-hosting proof language
14:45:04 <copumpkin_> with an implementation of itself proven in itself, with a small core
14:45:15 <copumpkin_> then we can be 99.999999999% sure it's good
14:45:32 <c_wraith> unless someone implemented the compiler attack against it.
14:45:35 <donri> Then we can be 99% sure we'll have skynet on our asses the next day
14:45:38 <Saizan> donri: when you see "a b" in "a b . c" you already know that has to be parsed as the application of a to b
14:45:49 <copumpkin_> donri: nah, one of the proofs will be that it is not self-aware
14:46:33 <donri> Ah because "a b" might be a function just like "b" might. I'm forgetting about currying.
14:46:52 <copumpkin_> donri: it's just syntactic
14:46:58 <roconnor> copumpkin_: epigram2 might become self hosting. ... I forget if it is one of thier goals
14:47:00 <donri> copumpkin_: But if it is maybe it's smart enough to pretend to prove that.
14:47:08 <roconnor> copumpkin_: HolLight is close to self hosting
14:47:23 <Saizan> donri: that's true, but parsing doesn't care about the types at all
14:47:38 <roconnor> these HOL systems are much simpler than Coq, especially HOLlight
14:47:45 <donri> copumpkin_: Yea but I'm reading it with a Python parser in my head. a(b . c) which makes no sense in haskelland.
14:48:07 <donri> Due to currying and laziness and everything.
14:48:22 <copumpkin_> a (b . c) could type fine
14:48:35 <copumpkin_> it just happens to not be what the parser interprets a b . c as
14:48:41 <donri> Yea but it's ≠ (a b .c) right?
14:48:53 <donri> :)
14:49:06 <sipa1024> > a (b . c)
14:49:07 <lambdabot>   Couldn't match expected type `a -> b'
14:49:07 <lambdabot>         against inferred type `Simple...
14:49:12 <sipa1024> > a (b . c) x
14:49:13 <lambdabot>   Couldn't match expected type `a -> b'
14:49:13 <lambdabot>         against inferred type `Simple...
14:49:31 <donri> Don't you mean :t
14:49:47 <Saizan> do what the compiler does, first build the abstract syntax tree, then wonder about its meaning
14:50:10 <copumpkin_> it places its right fist on its forehead
14:50:20 <copumpkin_> (after building the AST)
14:50:27 <copumpkin_> and ponders for one day and one hour
14:51:32 <sipa1024> > x
14:51:33 <lambdabot>   x
14:51:37 <sipa1024> > x y
14:51:38 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
14:51:38 <lambdabot>         against infe...
14:51:50 <sipa1024> :t a (b . c)
14:51:51 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
14:51:51 <lambdabot>     In the first argument of `(.)', namely `b'
14:51:51 <lambdabot>     In the first argument of `a', namely `(b . c)'
14:52:38 <Saizan> sipa1024: only f,g,h are available as function symbols
14:52:58 <Saizan> :t f (g . h)
14:52:59 <lambdabot> forall a b (f :: * -> *) t. (Show a, SimpleReflect.FromExpr b, SimpleReflect.FromExpr (f a), Functor f, SimpleReflect.FromExpr (f b -> t)) => t
14:54:09 <benmachine> > fun "x" $ x
14:54:10 <lambdabot>   Ambiguous type variable `b' in the constraints:
14:54:10 <lambdabot>    `SimpleReflect.FromExpr ...
14:54:14 <benmachine> > fun "x" $ x :: Expr
14:54:15 <lambdabot>   x x
14:56:27 <djahandarie> Cale, you know, I don't think the generalized catamorphism even does anything a regular catamorphism can't.
14:56:44 <copumpkin_> well, a regular catamorphism supposedly can do everything
14:57:10 <benmachine> fsvo everything
14:57:14 * ksf decides to ignore ordering invariants and have the pretty-printer care about that. not to mention that "body after head" is the only ordering I know of.
14:57:17 <benmachine> you can implement tail in foldr but it's not pretty :P
14:57:26 <copumpkin_> yeah
14:57:30 <copumpkin_> that's what I mean
14:58:07 <djahandarie> Because a FW-algebra can be transformed into an F-algebra and an F-Algebra can be transformed into an FW-Algebra
14:59:39 <djahandarie> So this really makes me wonder what the generalized morphisms are for
14:59:52 <copumpkin_> djahandarie: ask edwardk at the boston haksell meetup
15:00:13 <djahandarie> Yeah
15:03:53 <djahandarie> Someone should really write a "category-extras for the normal Haskell programmer" guide
15:04:07 <copumpkin_> I think it'd be a lot more manageable if he split it up some more
15:04:10 * tg_ nominates djahandarie
15:04:12 <copumpkin_> which he intends to do but hasn't gotten around to
15:04:41 <djahandarie> tg_, no, my category-theory-fu isn't strong enough :P
15:04:52 <djahandarie> And yeah, I know he has mentioned that before
15:06:40 <EvanR-work> whats an example of quick check
15:06:54 <copumpkin_> @check \xs -> xs == reverse xs
15:06:55 <lambdabot>   "OK, passed 500 tests."
15:07:35 <EvanR-work> what is that testing
15:07:52 <copumpkin_> that forall xs, xs == reverse xs, duh
15:07:56 <mauke> that all lists are their own reverse
15:07:56 <c_wraith> it's testing that lists are the same as their reverse
15:08:08 <EvanR-work> what kind of test is that
15:08:15 <copumpkin_> EvanR-work: a perfectly valid test
15:08:18 <AnotherLomono> boolean?
15:08:19 <EvanR-work> > reverse [1,2,3,4,5]
15:08:19 <AnotherLomono> :V
15:08:19 <lambdabot>   [5,4,3,2,1]
15:08:26 <mauke> @check \x -> x < 5
15:08:27 <lambdabot>   "Falsifiable, after 12 tests:\n5\n"
15:08:43 <mauke> @check \xs -> xs == reverse (xs :: [()])
15:08:44 <lambdabot>   "OK, passed 500 tests."
15:08:47 <mauke> @check \xs -> xs == reverse (xs :: [Char])
15:08:48 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\185442\\157963\\822365\"\n"
15:08:59 <alpounet> it uses ()
15:08:59 <alpounet> oh
15:11:51 <benmachine> @check \x -> x < 500
15:11:52 <lambdabot>   "OK, passed 500 tests."
15:12:20 <sproingie> who knew the universe was so finite
15:12:26 <AnotherLomono> @check \x -> x < 499
15:12:26 <lambdabot>   "OK, passed 500 tests."
15:12:58 <EvanR-work> ah
15:12:58 <benmachine> AnotherLomono: it also checks negatives, so you're allowed a good deal less, but what exactly is not deterministic I think
15:13:44 <AnotherLomono> benmachine: haha I just had a 'doh' moment when I realised that it should test for non-positives
15:15:36 <Kaidelong> I'm pretty sure pex is smart enough to try 501 specifically
15:15:53 <Kaidelong> hmm
15:15:58 <edlinde> hi guys, is there a way to convert a FOLDL function to a recursive one? 
15:16:06 <Kaidelong> pex is for white fox analysis though, perhaps quick check isn't?
15:16:10 <Kaidelong> box even
15:16:11 <mauke> edlinde: what
15:16:23 <EvanR-work> edlinde: apply the foldl by hand using..
15:16:25 <edlinde> I mean instead of having a foldl it is rewritten using a tail recursive function
15:16:26 <EvanR-work> @src foldl
15:16:26 <lambdabot> foldl f z []     = z
15:16:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:16:27 <EvanR-work> ?
15:16:32 <Kaidelong> edlinde: in general, yes. But why would you want to?
15:16:44 <Kaidelong> also foldl is already tail recursive, as demonstrated there
15:16:47 <mauke> edlinde: foldl is a tail recursive function
15:16:51 <AnotherLomono> eh just got an Halloween discount email from Mannings 
15:16:57 <edlinde> I know
15:16:57 <Kaidelong> if you want to get rid of the thunk you could use foldl'
15:17:20 <Kaidelong> that's probably the problem you've run into if you are under the impression foldl isn't tail recursive
15:17:30 <edlinde> its just that I want to do this in Erlang really and there I am having to spawn a lot of new processes
15:17:41 <edlinde> I have seen how its done using foldl
15:17:54 <edlinde> but I would like to know how to convert this to a normal recursive call
15:18:06 <Kaidelong> well look at the source code
15:18:20 <edlinde> ok
15:18:30 <EvanR-work> an express with foldl looks more normal to me than a set of recursive equations
15:18:34 <EvanR-work> expression*
15:18:57 <edlinde> ok
15:20:52 <EvanR-work> node.js vs haskell go
15:23:01 <notabel> haskell go?  has rob pike gone functional?
15:23:01 <notabel> ;-)
15:23:31 <sm> can I just say first.. $ ghci -package SDL -> /Users/simon/.cabal/lib/SDL-0.6.2/ghc-6.12.3/HSSDL-0.6.2.o: unknown symbol `_SDL_FreeSurface', why ?
15:23:56 <sproingie> because sdl that's why
15:25:17 <Saizan> the installed package info probably lacks some detail of what to link in
15:25:24 <osaunders> Is there anything like this already? http://hpaste.org/40950/qqq
15:26:28 <mauke> > (zipWith (+) `ap` tail) [3, 3, 5, 1]
15:26:28 <lambdabot>   [6,8,6]
15:28:04 <ray> a call to foldl is just factoring out the recursive structure
15:28:38 <ray> expressions usually look nicer with stuff factored out
15:28:42 <EvanR-work> call the foldl procedure with tail call optimization!
15:29:34 <osaunders> mauke: Thanks. I don't know how you people do it.
15:30:05 <mauke> http://mauke.ath.cx/tmp/flow.png
15:30:38 <benmachine> mauke: nice!
15:31:09 <sm> when ghci loads up packages and says "linking".. it's not running ld I take it
15:31:25 <benmachine> sm: does it help if you give it -lSDL
15:31:43 <mauke> .oO( -LSD )
15:31:51 <copumpkin_> "Thread-based networking is relatively inefficient and very difficult to use. "
15:31:54 <copumpkin_> from node.js homepage
15:32:49 <mauke> true
15:33:01 <sm> benmachine: not in that case, no. That does help in another test case I have
15:33:56 * hackagebot mutable-iter 0.3 - iteratees based upon mutable buffers  http://hackage.haskell.org/package/mutable-iter-0.3 (JohnLato)
15:36:26 <sm> benmachine: ie http://gist.github.com/652484
15:39:50 <benmachine> sm: wfm >_>
15:40:10 <benmachine> sm: on an offchance, try -package SDL-0.6.2
15:40:37 <sm> no
15:40:39 <benmachine> sm: although actually I'm not sure why you need to give -package to ghci at all
15:40:50 <benmachine> it tends to be good at working that stuff out
15:40:58 <sm> benmachine: that was just the quickest way I found to reproduce the issue
15:41:08 <sm> another way is ghci Test.hs, ghci> main
15:41:13 <benmachine> oic
15:41:44 <benmachine> sm: well, I'd try reinstalling SDL, in case you haven't already
15:41:50 <benmachine> or examining your system SDL to make sure it's sane
15:41:55 <benmachine> a recent version etc.
15:41:58 <sm> which if I do ghci -L/opt/local/lib -lSDL, main, it works
15:42:04 <sm> yup, have done that
15:42:26 <sm> it's all fresh and good and everything builds fine when you just do ghc --make
15:42:42 <benmachine> weeeeird
15:42:45 <sm> I haven't been able to see enough debug output to figure out the difference
15:42:53 <benmachine> throw -v at it?
15:43:02 <benmachine> if that doesn't work, add more
15:43:37 <ray> if -v doesn't work, use more -v
15:44:34 <sm> that doesn't add any details for ghc(i)'s linking attempt. I tried replacing the ld binary with a script, but I guess it's not calling ld
15:45:31 <benmachine> it might be calling it via gcc?
15:45:49 <benmachine> with enough -v it should tell you what it's invoking I think
15:46:00 <benmachine> wait no it's -v3
15:46:02 <benmachine> not -vvv
15:46:41 <Saizan> sm: right, ghci uses dlopen
15:46:51 <benmachine> oh right that makes more sense
15:47:00 * hackagebot sndfile-enumerators 0.5.0 - Audio file reading/writing  http://hackage.haskell.org/package/sndfile-enumerators-0.5.0 (JohnLato)
15:47:14 <sm> that explains why -v3 didn't show anything being invoked
15:47:34 <sm> I guess I could trace calls to dlopen and compare the working and not-working case
16:00:12 <osaunders> @src reverse
16:00:12 <lambdabot> reverse = foldl (flip (:)) []
16:02:06 <sipa1024> @pl reverse
16:02:06 <lambdabot> reverse
16:02:14 <sipa1024> @pl foldl (flip (:)) []
16:02:15 <lambdabot> foldl (flip (:)) []
16:03:06 * sm finds interesting tools with "apropos dtrace"
16:06:51 * McManiaC broke parsec :(
16:06:59 <McManiaC> unexpected end of input
16:06:59 <McManiaC> expecting "*", "/", "@", "@!", "$", end of input, new-line or " "
16:07:16 <copumpkin_> you mean you broke your grammar in parsec?
16:07:20 <McManiaC> yeh
16:07:36 <arnihermann> I'm working on a small compiler and I'm interested in using some kind of template mechanism for the generated code, I've looked at HStringTemplate and Bravo, can you guys think of something else I should look at?
16:08:09 <mwc> arnihermann: what output format are you generating?
16:08:28 <mwc> arnihermann: C, GHC-core, x86 assembly, ?
16:09:07 <arnihermann> mwc: actually I'm doing source to source translation
16:09:16 <arnihermann> from an imperative reactive language to erlang
16:09:44 <arnihermann> so the templates will contain erlang code with placeholder which I need the template system to insert values into
16:10:12 <arnihermann> I'm not very opinionated on which library to use, I just thought about asking if you have any preference :)
16:10:43 <dolio> preflex: seen roconnor
16:10:44 <preflex>  roconnor was last seen on #haskell 1 hour, 23 minutes and 5 seconds ago, saying: these HOL systems are much simpler than Coq, especially HOLlight
16:11:07 * hackagebot protocol-buffers-descriptor 1.8.1 - Text.DescriptorProto.Options and Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-descriptor-1.8.1 (ChrisKuklewicz)
16:11:17 <mwc> arnihermann: ahh, I was going to suggest hburg
16:11:32 <McManiaC> whats wrong with http://npaste.de/oW/ ?
16:12:04 <McManiaC> paranthesis -.-
16:12:05 <McManiaC> damn
16:12:08 * hackagebot hprotoc 1.8.1 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-1.8.1 (ChrisKuklewicz)
16:13:02 <kwuxalot> just discovered there's no default instance for (Data UTCTime). What's up with that?
16:13:56 <enthropy> kwuxalot: UTCTime contains something from Data.Fixed, which until quite recently (1 year) didn't have Data instances
16:14:27 <enthropy> kwuxalot: you have the most recent version of time?
16:14:30 <gwern> > 14 / 70
16:14:31 <lambdabot>   0.2
16:15:47 <kwuxalot> enthropy: `cabal install time` ... fixed ... :)
16:16:43 <warrenharris> can anyone suggest what might be going wrong with my use of runSTUArray here: http://pastebin.com/jnPPAacn
16:19:00 <kwuxalot> I'm experimenting with Data.JSON.Generic
16:19:06 <danr> warrenharris: hmm, just had a quick look, don't you need to use unsafeFreeze?
16:19:10 <kwuxalot> it's chocking on Map types: Exception: toJSON: not AlgRep NoRep(DataType {tycon = "Data.Map.Map", datarep = NoRep})
16:19:43 <warrenharris> I thought runSTUArray would do the unsafeFreeze
16:20:56 <danr> warrenharris: ok indeed :)
16:21:29 <arnihermann> mwc: yeah hburg is very cool, but maybe not best tool for me
16:21:31 <sm> well, I can say that ghci -L/opt/local/lib -package SDL ... never reads the SDL libs in /opt/local/lib
16:21:50 <sm> or calls dlopen
16:22:20 <kwuxalot> there's a Typeable and Data instance for Map, so it should work, right?
16:22:50 <blackcustard> i've never used a right fold, just left ones; does that mean there are parts of my code that are more complex than they need to be?
16:25:05 <warrenharris> danr: I guess you're stumped too?
16:25:06 <Cale> blackcustard: foldr is actually probably a bit more common in my code than foldl'
16:25:39 <Cale> blackcustard: foldr works on infinite lists, which is something left folds can't do.
16:26:02 <Cale> It's a more natural operation to describe as well
16:26:07 <enthropy> kwuxalot: perhaps the Data instance for Map has too many undefineds that try to preserve it's invariants
16:26:17 <Cale> foldr f z replaces each (:) in the list with f, and the [] at the end with z
16:26:40 <Cale> So I tend to find it easier to think about.
16:27:23 <kwuxalot> enthropy: hrmm... how do I fix this?
16:27:55 <blackcustard> hmm, i could see how that would be more intuative, though for some reason left fold is what i gravitated to
16:28:22 <blackcustard> i guess i need to look into the matter of "working on infinite lists" more to see the other advantages
16:28:49 <blackcustard> intuitive*
16:29:13 <Saizan> blackcustard: implement map with them as an exercise
16:29:28 <Saizan> blackcustard: and consider the lazyness differences
16:29:37 <kwuxalot> enthropy: I guess one option is just to switch from a Map to an association list, but that seems kind of lame
16:30:31 <enthropy> kwuxalot: surely there's a way to use Map with JSON that doesn't involve Data?
16:30:49 <blackcustard> Saizan: okay, i'll try that (i've also never really thought about laziness, except in as much as it lets me take from infinite lists and makes debugging such a pain)
16:32:02 <kwuxalot> enthropy: not an obvious easy way... I have a bunch of data types that can all be conveniently serialized to JSON using Data.JSON.Generic, except one of them contains a Map
16:32:26 <enthropy> kwuxalot: the way to merge the two nicely (without too much boilerplate) involves overlapping instances, which that library author may not have considered
16:33:10 <enthropy> where you have      instance Data a => GenericSerialize a;  and   instance GenericSerialize (Map a b)
16:33:54 * enthropy might be more helpful if I looked at the library you're using
16:34:02 <RoaryLion> that's an undecidable instance too isn't it?
16:35:00 <enthropy> RoaryLion: who knows :)
16:35:06 <kwuxalot> enthropy: ah, yes. I could simply serialize it as an association list
16:38:38 <kwuxalot> or even better: with toJSObject
16:38:40 <cads> hey is there any way to ask lambdabot to tell me the signature of a whole typeclass?
16:39:09 <Polarina> I am trying to decide between Takusen and HDBC for my little project. I don't have any specific reasons to use one over the other. What do you all suggest?
16:41:50 <monochrom> takusen is more cool. you can brag "I use iteratees"
16:42:11 <ddarius> Please don't brag about that.
16:46:19 <lispy1> Polarina: Takusen is able to statically guarantee resource usage
16:46:32 <lispy1> Polarina: at least in terms of when to deallocate db cursors and so on
16:46:55 <lispy1> Polarina: the down side is that Takusen can be harder for beginners due to using things like functional dependencies
16:47:59 <kwuxalot> enthropy: so far I have: instance (JSON a) => JSON (Map (String a)) where; ... -- but I'm getting the type error: `Map (String a)' is not applied to enough type arguments
16:48:16 <enthropy> kwuxalot: drop the inner parens
16:48:50 <kwuxalot> enthropy: then it's: Illegal instance declaration for `JSON (Map String a)'
16:49:40 <enthropy> just enable all the extensions it asks for
16:52:20 <ezyang> I wonder what would happen if, as a strategy for coping for stack overflow from excessive laziness, you started forcing "plausible" thunks. 
16:52:50 <benmachine> I thought about that
16:53:21 <Olathe> Can BlazeHTML be used to parse HTML?
16:53:39 <jmcarthur> ezyang: you make a mess
16:53:42 <benmachine> you could for example encode a property of functions that their RHS is no bigger than their LHS
16:53:50 <ezyang> Olathe: No, I don't think so. 
16:53:53 <ezyang> jmcarthur: Oh no! 
16:54:11 <Olathe> Thanks :)
16:54:13 <benmachine> I guess the tricky part is making sure you don't accidentally bottom anything
16:54:22 <benmachine> but if you're just about to run out of memory I guess that's not a big deal
16:54:29 <benmachine> I guess a lot of things!
16:54:39 <benmachine> I should possibly become a better guesser
16:54:42 <ezyang> Right, basically, if something bottoms you have to ignore it, because it might not have actually been evaluated if it was true laziness. 
16:55:07 <ezyang> It's the elephant in the room for laziness being more general than strictness. 
16:55:11 <benmachine> ezyang: except if your goal is avoiding stack overflows, the whole expression might be just about to kick the bucket anyways
16:56:06 <benmachine> alternatively, you could force some thunks in parallel
16:56:13 <benmachine> and then kill the threads if they bottom
16:56:25 <blackcustard> whoa, foldr gives its function an element of the list as its _first_ argument, foldl gives its function an element of the list as its _second_ argument. that threw me off for a while.
16:56:38 <ezyang> blackcustard: Follow the types :-) 
16:56:54 <dolio> The types are suboptimal.
16:56:59 <zygoloid> blackcustard: that's because...
16:57:02 <ezyang> :t foldr 
16:57:03 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:57:05 <ezyang> :t foldl 
16:57:06 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:57:07 <dolio> In foldr, the elements are type a, in foldl, the result is type a.
16:57:11 <ezyang> ya 
16:57:13 <zygoloid> > (foldl f x [a,b,c,d,e], foldr f x [a,b,c,d,e])
16:57:14 <lambdabot>   (f (f (f (f (f x a) b) c) d) e,f a (f b (f c (f d (f e x)))))
16:57:21 <blackcustard> ya, i just checked the types in the docs
16:57:30 <zygoloid> blackcustard: ^^ note that in both cases the values are in the same order
16:57:48 <benmachine> except for x
16:57:55 <zygoloid> yeah :)
16:58:22 <zygoloid> foldl versus foldr reassociates but does not reorder (commute). except for x. :)
16:58:56 <benmachine> well in foldl, x is the accumulator, in foldr it's the base case
16:59:49 <zygoloid> they're both the base case
17:00:01 <zygoloid> > (foldl undefined x [], foldr undefined x [])
17:00:02 <lambdabot>   (x,x)
17:00:08 <blackcustard> so, if you have a better understanding of folds, then the ordering of the arguments for the functions given too both folds is intuitive, even though the ordering is different for each one?
17:00:13 <blackcustard> (if that sentence made sense)
17:00:45 <zygoloid> blackcustard: yes, i think so.
17:00:56 <benmachine> the ordering of arguments given to foldr is very natural
17:01:01 <benmachine> I think in foldl it's not such a big deal
17:01:21 <benmachine> but it is a little more natural that way
17:01:45 <zygoloid> in particular, for monoidal operations, foldl mappend mempty and foldr mappend mempty are denotationally equivalent on finite lists
17:01:46 <blackcustard> okay, so hopefully that will make sense it time. for now, i'll try and come up with a mnemonic :)
17:02:05 <benmachine> foldl f z (x : xs) = foldl f (f z x) xs
17:02:19 <benmachine> it's almost like a rebracketing
17:02:55 <benmachine> blackcustard: to remember the foldr case, just remember that foldr (:) [] xs = xs
17:03:48 <RoaryLion> or that foldr replaces the constructors of the list with arbitrary function/value
17:04:07 <roconnor> @seen dolio
17:04:07 <lambdabot> Unknown command, try @list
17:04:07 <preflex>  dolio was last seen on #haskell 7 minutes ago, saying: In foldr, the elements are type a, in foldl, the result is type a.
17:04:10 <zygoloid> foldr (:) [] (foldr : []) = foldr : []
17:04:25 <dolio> roconnor: Was that comment about O(n) performance a joke? I couldn't tell.
17:04:28 <benmachine> zygoloid: heh
17:04:40 <roconnor> I was seriousish
17:06:02 <blackcustard> hmm, fold-identify-fu. less confusing to watch than type-fu :)
17:07:25 <roconnor> dolio: er, I was being sarcastic
17:07:30 <roconnor> dolio: so ya, a joke
17:07:37 <dolio> Okay.
17:07:44 <roconnor> dolio: the serious point being that the haskell performace is better
17:07:52 <dolio> Yeah.
17:07:56 <roconnor> even if it is unpredictable
17:08:02 <kwuxalot> huh... seems like the data constructor JSObect overlaps with the newtype JSObject, and it's confusing the hell out of me
17:08:10 <kwuxalot> I thought that wasn't possible
17:08:23 <roconnor> kwuxalot: you are confused
17:09:09 <roconnor> dolio: I guess the tricky problem is that you want to rely on haskell to give you O(1) but sometimes it turns onto O(n)
17:09:29 <blackcustard> so ... if the Prelude used map_, with foldl, instead of map_2, with foldr ... we couldn't map across infinite lists. http://hpaste.org/40951/map_with_foldl_and_foldr
17:09:31 <dolio> I guess.
17:09:33 <roconnor> but the same code in OCaml would simply guarentee O(n)
17:09:43 <roconnor> so you have to rewrite it in some obtuse way to get O(1) in ocaml
17:09:45 <dolio> I honestly don't have that many problems with that anymore, though.
17:09:56 <roconnor> and if you rewrote it in a similar way in Haskell you'd also guarentee O(1)
17:10:28 <roconnor> dolio: really?
17:10:35 <roconnor> I guess I need more experience in OCaml
17:11:17 <dolio> I mean with Haskell performing significantly more poorly than I want.
17:11:28 <roconnor> oh me neither
17:11:35 <dolio> I've never really written much OCaml.
17:11:44 <roconnor> on occasion it happens, but is is pretty clear and I usually know how to fix it.
17:14:08 <blackcustard> thanks for the help all, makes some more sense now
17:17:40 <cabalistik> hi, is there away around floating point approximation in haskell?  eg. sin pi = 1.22460635382238e-16, but want it to be 0.0
17:18:11 <ddarius> cabalistik: You can use different types, but, ultimately, that requires solving the halting problem .
17:18:14 <kwuxalot> roconnor: are you sure? > :t JSObject / JSObject :: JSObject JSValue -> JSValue
17:18:47 <RoaryLion> > sin pi :: CReal
17:18:48 <lambdabot>   0.0
17:18:56 <RoaryLion> cabalistik: there, that's exact
17:19:07 <RoaryLion> just don't compare two values of that type, or expect it to be fast at doing anything
17:19:29 <kwuxalot> roconnor: I guess it's just both a type and a data constructor, which is normal
17:19:56 <conal> does anyone know how far behind state-of-the-art CReal is for performance of exact real arithmetic?
17:20:43 <benmachine> last time I looked at CReal it looked like it made some suspicious design choices
17:20:49 <cabalistik> Thanks RoaryLion, but is CReal i need to import a module for it to work right?
17:20:52 <benmachine> and wasn't necessarily as exact as it claimed
17:20:53 <RoaryLion> yeah
17:20:59 <RoaryLion> benmachine: how so?
17:21:08 <RoaryLion> also available is roconnor's fewdigits
17:21:10 <benmachine> it seemed to truncate numbers in testing for equality/ordering
17:21:14 <RoaryLion> which does the same thing in a different way
17:21:26 <RoaryLion> benmachine: oh yeah, it's the only real option
17:21:36 <RoaryLion> assuming you don't like semidecidability
17:21:38 <benmachine> heh
17:21:55 <benmachine> I'm fine with semidecidability
17:21:59 <RoaryLion> :P
17:22:02 <benmachine> I mean
17:22:08 <benmachine> if I want to do the truncation myself I can do that
17:22:28 <ddarius> benmachine: There's no way for CReal to work that way with the interface.
17:22:32 <benmachine> abs (x - y) < delta or whatever
17:22:45 <benmachine> that wouldn't work would it
17:22:51 <ddarius> You can, of course, define your own comparison operators.
17:22:55 <benmachine> ddarius: I don't follow
17:23:14 <ddarius> (Also, Ord and Eq are required by Num so CReal is forced into implementing them somehow.)
17:23:26 <benmachine> ddarius: what's wrong with the semidecidable versions?
17:23:28 <RoaryLion> not Ord, is it?
17:23:32 <RoaryLion> only Show and Eq
17:23:32 <benmachine> no
17:23:44 <benmachine> but Eq isn't any easier than Ord really :P
17:24:06 <benmachine> once you've established two numbers are not equal then which is bigger is a relatively simple question
17:24:21 <ddarius> benmachine: I meant comparisons with users specifyable precision isn't able to be fit into Eq's interface.
17:24:53 <RoaryLion> dependent typeclasses!
17:25:23 <benmachine> ddarius: ah, right, that's not what I meant
17:26:01 <benmachine> ddarius: I meant rather that I could do truncate 40 x == truncate 40 y
17:26:01 <djahandarie> RoaryLion, there wasn't even a hint in your nick this time as to who you were
17:26:36 <benmachine> oh right
17:26:37 <RoaryLion> djahandarie: this is a bad time to be a pumpkin
17:26:43 <benmachine> hah
17:26:45 <RoaryLion> gotta lay low for a few days
17:26:55 <djahandarie> Haha
17:26:56 <benmachine> :D
17:27:11 <RoaryLion> was reminded in #haskell-blah that I was in danger, so I switched
17:27:26 <benmachine> is there a coRoaryLion
17:27:33 * djahandarie sharpens his pumpkin-carving knife
17:27:44 <RoaryLion> the advantage to being a lion is that nobody eats me
17:27:56 <RoaryLion> and a roary one is scarier and even less edible
17:27:57 * ddarius is 100% certain that people have eaten lion meat.
17:28:11 <RoaryLion> ddarius: nothing is certain, but I can try to reduce the probability
17:28:27 <benmachine> pretty sure not many things habitually eat lions
17:28:31 <RoaryLion> my "nothing is certain" wasn't related to your certainty statement
17:28:38 <RoaryLion> it was about my getting eaten :)
17:29:13 <jmcarthur> copumpkin: djahandarie is sharpening his knife. run
17:29:25 <RoaryLion> damn, he's not paying attention
17:29:52 <allbery_b> <benmachine> pretty sure not many things habitually eat lions
17:30:13 <allbery_b> hyenas will clean up any corpses in the area including lions
17:30:30 <ddarius> s/eat/prey on
17:30:50 <allbery_b> not much *hunts* for lions, but hyenas always have the last laugh
17:31:08 <ddarius> 'til they get shot by a human.
17:31:10 <RoaryLion> except those who happened to die and got eaten by other hyenas
17:31:28 <AnotherLomono> Chinese saying : "the Chinese eat anything on four legs except tables"
17:31:47 <ddarius> Damn straight.  You can't just -say- you're an omnivore.  You have to prove it.
17:32:24 * allbery_b is generally willing to eat anything that stands still or is moving slowly :)
17:33:12 <AnotherLomono> haha
17:37:05 <heatsink> Is there a reason not to have instance (Monad m, Monoid a) => Monoid (m a) ?
17:37:24 <heatsink> It's defined for the specific cases of [] and (->) b
17:37:54 <dolio> That's not the instance for [].
17:38:38 <heatsink> oh, right.
17:38:51 <heatsink> So overlap is the problem.
17:39:01 <RoaryLion> would you need all of Monad, anyway?
17:39:32 <heatsink> no
17:39:34 <heatsink> BUT YOU CAN
17:39:37 <RoaryLion> :P
17:39:44 <RoaryLion> seems like Applicative is sufficient
17:39:54 <RoaryLion> you could also do something with Alternative
17:40:10 <dolio> Instances of the form 'f a' are pretty questionable in my book.
17:40:19 <ezyang> Ask #haskell: when you run into a laziness induced space leak, what do you tend to do first? Profile? Randomly introduce strictness until you fix the problem? Grep for foldl? 
17:40:29 <dolio> For variables f and a.
17:40:29 <RoaryLion> grep for foldl
17:40:32 <heatsink> profile
17:41:23 <ddarius> ezyang: If I know the space leak is laziness induced, then I probably know the cause and know how to fix it.
17:41:38 <ezyang> ddarius: Ah, interesting. 
17:41:49 <ezyang> So how do you determine if a 'stack overflow' is laziness induced? :-) 
17:42:24 <heatsink> stack overflows are strictness-induced, but may be symptoms of laziness.
17:42:40 <dolio> Type classes are sort of based on recursion on the structure of types, which is why the original H98 rule was that all instances be of the form 'T a b c ...'.
17:43:18 <ezyang> heatsink: "Well, computation is strictness induced" :-) 
17:43:28 <dolio> When you write an instance like 'f a', it's like trying to treat application as part of the induction.
17:43:35 <roconnor> conal: state of the are with respect to C code?
17:45:18 <heatsink> What's bad about that?
17:45:56 <ezyang> heatsink: I feel like saying stack overflows are strictness induced is not very helpful. 
17:46:16 <heatsink> ezyang: ah, you're right
17:46:21 <heatsink> I was asking dolio though
17:47:03 <dolio> Because application is not a 'constructor' in the inductive definition of types, so to speak.
17:47:06 <ddarius> ezyang: Stack overflows are easy.  Just get a stack trace one way or another, e.g. with the -xc trick, and look at the functions causing the problem.
17:47:18 <roconnor> conal: the C programs can get approximately 100x as many decimal digits as my FewDigits code in the same amount of time.
17:47:29 <Saizan> yeah, and it gets messy when you introduce things like type families, where that kind of decomposition is not sound
17:47:50 <ezyang> ddarius: Ok. 
17:47:57 <dolio> For instance, the inductive definition of Either allows us to match on 'Left x' and 'Right y', but not 'f x'.
17:48:57 <heatsink> Since type constructors are injective (and the non-injective ones, type families, can't be matched in type classes), isn't it safe?
17:48:59 <roconnor> conal: CReal is faster than FewDigits, maybe it can produce 2 or 4 times as many digits as FewDigits in the same time I'd guess
17:49:19 <roconnor> but that is just an estimate
17:50:03 <dolio> Does FewDigits have all the optimizations discussed in the paper?
17:50:37 <roconnor> dolio: which paper?
17:50:41 <RoaryLion> roconnor: have you considered putting fewdigits onto hackage?
17:50:52 <dolio> Reals and monads and whatnot.
17:50:59 <roconnor> RoaryLion: CReal is more or less better, so I don't feel very motivated
17:51:28 <hpc> roconnor: that never stopped anyone else from reinventing the wheel ;)
17:51:30 <RoaryLion> roconnor: it's also part of a larger package, so I'm less inclined to depend on it :P
17:51:40 <RoaryLion> I don't like multi-purpose packages
17:51:47 <RoaryLion> for no justifiable reason
17:51:48 <roconnor> RoaryLion: I'd repackage CReal then
17:52:05 <roconnor> RoaryLion: after all Lennart stole the code already 
17:52:10 <RoaryLion> surely fewdigits has some advantages
17:52:14 <RoaryLion> roconnor: oh, from whom?
17:52:25 <roconnor> David Lester is the author of CReal
17:52:26 <djahandarie> Some dude
17:52:27 <djahandarie> Yeah
17:52:41 * djahandarie notes that his answer contained literally no value
17:53:03 <RoaryLion> hey, it gave me some information
17:53:05 <roconnor> RoaryLion: well, few digit fails to terminate in many cases when doing boolean comparisions instead lying
17:53:12 <gwern> 'war is a lottery in which nations ought to risk only small amounts'
17:53:12 <RoaryLion> roconnor: oh, I like that :P
17:53:15 <adu> i hear theres a hackathon?
17:53:21 <RoaryLion> adu: where?
17:53:23 <roconnor> RoaryLion: if you repackage CReal you can fix that
17:53:36 <RoaryLion> roconnor: I feel bad duplicating code in packages
17:53:37 <RoaryLion> :(
17:53:40 <dolio> heatsink: I'm sure it can work out fine, but 1) it's prone to overlap 2) I don't feel it's well motivated by my understanding of the theory underlying how type classes work, so I don't like it.
17:53:47 <adu> RoaryLion: Ghent
17:53:48 <roconnor> RoaryLion: my implementation of == returns False or bottom
17:53:55 <roconnor> RoaryLion: I'm not sure who would call it
17:53:55 <RoaryLion> roconnor: also, creal happens to be in the overlapping package name!
17:54:08 <RoaryLion> @hackage numbers
17:54:09 <lambdabot> http://hackage.haskell.org/package/numbers
17:54:11 <RoaryLion> @hackage Numbers
17:54:11 <lambdabot> http://hackage.haskell.org/package/Numbers
17:54:20 <dolio> @hackage sausages
17:54:21 <lambdabot> http://hackage.haskell.org/package/sausages
17:54:22 <RoaryLion> (fucking ridiculous)
17:54:33 <RoaryLion> dolio: is that your upcoming package?
17:54:46 <dolio> Nope.
17:55:24 <roconnor> RoaryLion: oh I think I implement the error function in FewDigits
17:56:21 <RoaryLion> aha
17:56:25 <RoaryLion> see, it's worthy of hackage!
17:57:17 <dolio> Does it give informative exceptions when you request approximation to within 2^-63?
17:59:47 <heatsink> dolio: I guess the certain overlap with any other type application tern is a good reason to not it.
18:02:17 <roconnor> RoaryLion: I have a version of CReal that does arbitrary integration.
18:02:52 <roconnor> integral01 :: (CReal -> CReal) -> CReal
18:03:24 <kwuxalot> enthropy: so I have the definition: instance (Data a) => JSON (Map String a) where; showJSON m = makeObj $ fmap (\(k, v) -> (k, toJSON v)) $ toList m
18:04:09 <kwuxalot> enthropy: but I still get the same exception when I try: toJSON $ foo", 10), ("bar", 20)]
18:04:23 <kwuxalot> enthropy: oops, there should be a "fromList" in there
18:04:31 <conal> roconnor: thx for the rough comparative perf specs on exact reals.
18:05:11 <conal> roconnor: any reason to believe we couldn't get a fairly elegant Haskell implementation that comes close to the C impls?
18:05:59 <roconnor> Norbert Muller believes so
18:06:09 <roconnor> but he isn't an functional programming expert
18:06:47 * roconnor tries to remember how Muller's program works
18:07:30 <RoaryLion> roconnor: that's nice!
18:07:52 <roconnor> IIRC all the fast implementations use foward error propogation rather than the natural backwards error progation
18:08:03 <roconnor> reminds me a bit of the issues with automatic differentiation
18:08:16 <roconnor> RoaryLion: it is very slow
18:08:24 <RoaryLion> roconnor: I'm not surprised :)
18:08:27 <RoaryLion> but it's still nice
18:11:07 <conal> kwuxalot: (\(k, v) -> (k, toJSON v)) == second toJSON
18:11:43 <conal> kwuxalot: showJSON = makeObj . fmap (second toList) . toList
18:12:23 <conal> or showJSON = makeObj . (fmap . second) toList . toList
18:12:39 <conal> or showJSON = makeObj . (fmap . fmap) toList . toList
18:13:00 <kwuxalot> @hoogle second
18:13:00 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
18:13:00 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
18:13:00 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
18:13:51 <conal> second :: Arrow (~>) => (b ~> c) -> ((a, b) ~> (a, c))
18:14:06 <hpc> that @hoogle reminds me how deficient the time libs are
18:14:12 <conal> which specializes to second :: (b -> c) -> ((a, b) -> (a, c))
18:14:41 <roconnor> ``Note: Lazy.force is not thread-safe. If you use this module in a multi-threaded program, you will need to add some locks. ''
18:14:42 <kwuxalot> @pl \f a -> \f x a
18:14:42 <lambdabot> (line 1, column 15):
18:14:42 <lambdabot> unexpected end of input
18:14:42 <lambdabot> expecting pattern or "->"
18:14:42 <roconnor> oh god
18:15:06 <kwuxalot> @pl \f a -> \x a -> f a
18:15:06 <lambdabot> const . const
18:15:16 <tehgeekmeister> anyone know why html5 label elements don't take attributes in blazehtml yet?  they're useless without them...
18:15:19 <tehgeekmeister> (or a workaround..)
18:17:23 * tehgeekmeister wonders why he always figures these things out *right* after asking publicly about them.
18:17:51 <pickles> i think that's part of murphy's law
18:17:52 <MiggyX> tehgeekmeister: I usually figure it out just as I hit the enter key ;)
18:17:58 <RoaryLion> tehgeekmeister: what's the answer?
18:18:10 <tehgeekmeister> it does take attributes
18:18:18 <tehgeekmeister> but not as an argument, you use the ! combinator
18:18:32 <tehgeekmeister> but you *have* to pass in some contents for the label.  even if it's empty.
18:18:36 <tehgeekmeister> so, as an example
18:18:56 <tehgeekmeister> H.label ! for "some_id" $ "label name"
18:19:02 <kwuxalot> conal: that is interesting, but it doesn't solve my problem. I'm trying to make a specific instance for JSON serialization of Map, because the default one is broken
18:19:05 <tehgeekmeister> but i was doing H.label ! for "some_id"
18:20:23 <conal> kwuxalot: sry. now i see the context of your def.
18:21:23 <kwuxalot> conal: when I try to apply toJSON to a Map I get: *** Exception: toJSON: not AlgRep NoRep(DataType {tycon = "Data.Map.Map", datarep = NoRep})
18:24:31 <kwuxalot> conal: would it be possible that the compiler is ignoring my instance because it's only half defined? I have a showJSON defined, but not a readJSON
18:25:04 <kwuxalot> though showJSON should be the only relevant part in this case
18:25:38 <RoaryLion> tehgeekmeister: I see
18:25:49 <conal> kwuxalot: no idea.  sry.
18:28:36 <Saizan> kwuxalot: toJSON doesn't care about the JSON typeclass at all, use showJSON
18:28:48 <djahandarie> conal, fleeing the scene
18:29:53 <kwuxalot> I'm afraid I might need to make a "instance Data (Map k v)", not a new JSON instance
18:31:06 <Saizan> kwuxalot: can't you use showJSON?
18:31:11 <kwuxalot> Saizan: ahah... but when I use showJSON I get an overlapping instance error :-P
18:31:55 <Saizan> kwuxalot: maybe because there's already an instance for Map k v in the json package, you don't need to define your own
18:32:12 <kwuxalot> Saizan: There is, but it's broken. I was hoping my instance would get magically seleceted
18:32:22 <ddarius> You can't shadow an instance.
18:32:32 <Saizan> you can only use a newtype
18:32:56 <kwuxalot> eerherhg. I should just abandon this map and use an association list. So much simpler
18:35:11 <penny> What about {-# LANGUAGE TypeSynonymIntances #
18:35:31 <penny> -}
18:37:23 <ddarius> penny: Dvorak
18:37:28 <penny> hee
18:37:56 <kwuxalot> penny: what does that do?
18:38:34 <ddarius> Not what penny thinks it does.
18:38:44 <penny> Ooops.
18:39:32 <penny> I joined late, and probably didn't catch the full context.
18:39:47 <Saizan> type synonyms are completely transparent, so if you make an instance for the synonym it's the same as making one for its body
18:40:34 <Rotaerk> like C/C++ typedefs
18:41:09 <penny> But to some extent, it allows you to play with types as proper data types.
18:41:19 <penny> In terms of class definitions.
18:41:53 <Saizan> how so?
18:42:17 <kwuxalot> Actually, it is simple enough just to wrap it in a newtype. I should stop whining
18:42:26 <hpc> can't you rearrange type parameters with 'type'?
18:42:27 <penny> You normally can't make an instance for type Foo a b c = SomethingElse a b c 
18:42:32 <hpc> type F x a = G a x
18:42:52 <penny> You'd have to make an instance for the SomethingElse
18:43:03 <Saizan> penny: ah, ok, yeah
18:43:26 <Saizan> hpc: but you can't have an "instance C (F x) where" so it's not that useful
18:43:27 <kwuxalot> what are the functional differences between data and newtype?
18:43:46 <Saizan> kwuxalot: the newtype constructor is non-existant at runtime
18:43:49 <penny> Newtype has no overhead.
18:44:03 <penny> But it's resticted one kind.
18:44:03 <hpc> newtype also is a bit picky about what you put inside it
18:44:08 <djahandarie> No runtime overhead
18:44:14 <hpc> one kind, one constructor
18:44:17 <kwuxalot> shouldn't that just be an optimization? It should be clear enough to the compiler when it's just a single constructor type
18:44:25 <penny> Heh
18:44:42 <Saizan> kwuxalot: it's not semantically equivalent
18:44:53 <kwuxalot> oh yeah, because of _|_
18:44:55 <penny> Isn't it, though?
18:45:02 <fireboot> Hello
18:45:18 <fireboot> I'm a student and I'll soon have a course about haskell
18:45:22 <penny> It always seemed kind of hacky.
18:45:28 <fireboot> so I planned to install it on my computer
18:45:38 <kwuxalot> penny: with a data type foo you can have "Foo _|_" as a value, and "_|_", but with newtype you can only have the latter
18:45:40 <penny> What kind of 'puter?
18:45:41 <Saizan> penny: all pattern matches against a newtype constructor work as if they were irrefutable
18:45:48 <fireboot> but, according to my package manager, it's a 460Mo package
18:45:55 <fireboot> why the hell is it so big ?
18:46:00 <penny> But wouldn't that be the same for a data of one constructor?
18:46:04 <fireboot> 460MB*
18:46:08 <Saizan> penny: no
18:46:17 <kwuxalot> penny: it should be
18:46:34 <RoaryLion> http://snapplr.com/a3vg
18:46:38 <kwuxalot> penny: in my opinion... but it probably leads to some logical fallacy
18:46:41 <hpc> fireboot: are you sure it's the package and not dependencies?
18:46:45 <fireboot> no
18:46:54 <ddarius> kwuxalot: With a strict data type Foo undefined === undefined, but newtype and strict data are still distinct.
18:46:54 <Saizan> penny: data A = A X; case undefined of A _ -> () == undefined; newtype B = B X; case undefined of B _ -> () == ()
18:47:00 <penny> Oh dear. I can't even figure out how to do proofs in agda.
18:47:03 <fireboot> hpc: it's only the ghc package
18:47:09 <fireboot> there is no dependencies
18:47:17 <fireboot> (or they are already installed)
18:47:41 <Saizan> fireboot: are you sure it doesn't include a lot of haskell libs too?
18:47:43 <kwuxalot> ddarius: that's opposite of what I Thought
18:47:49 <fireboot> Saizan: I have no idea
18:48:13 <fireboot> but it's not really the archlinux philosophy to change the packages 
18:48:14 <penny> I remember reading that...but that still seemed...arbitrary?
18:48:16 <RoaryLion> penny: join #agda !
18:48:25 <fireboot> so I guess it's the stock ghc
18:48:27 <Saizan> fireboot: the official linux binary from ghc's website is ~100mb
18:48:46 <fireboot> yes, but after extraction, is it still 100MB ?
18:48:48 <Saizan> fireboot: bzipped, though
18:48:52 <fireboot> yes :)
18:48:53 <penny> We're going to make java look tiny!
18:49:00 <hpc> i think ghc includes base, mtl, etc
18:49:05 <alpounet> yeah
18:49:07 <alpounet> containers etc
18:49:18 <fireboot> (my compressed package is only ~60Mo, but after extraction it takes 460MB)
18:50:09 <ddarius> My bread that I totally messed up because I fell asleep yesterday is super sweet (for something that started off with no simple sugars.)
18:50:24 <thaw> fireboot, but haskell is very powerful 
18:50:27 <Saizan> well, lots of docs, interface files
18:53:43 <penny> fireboot--It's the types that are central. Intitally a curse, but later a blessing.
18:54:08 <fireboot> ... :D
18:54:38 <Saizan> it seems static libs take quite a lot of space
18:54:54 <Saizan> -rw-r--r-- 1 root root  23M Mar  5  2010 libHSbase-4.2.0.0.a
18:55:32 <jmcarthur> kwuxalot, ddarius: newtype is still distinct from strict data. you can always pattern match a newtype. that is not the case for data, strict or lazy
18:55:51 <daryoush> I am puzzled as to why the following code works.  How does y get all attributes of the x data and only replaces the b part?  
18:55:51 <daryoush> data XXX = XXX {a::Int, b::Int} deriving Show
18:55:51 <daryoush> x = XXX 10 100
18:55:51 <daryoush> y = x { b=200}
18:56:02 <jmcarthur> case undefined of Foo _ -> "foo"   -- different depending on whether Foo is a data or a newtype
18:56:02 <fireboot> hmmmm ok Saizan
18:56:10 <fireboot> I don't have enough place on my /
18:56:13 <fireboot> :(
18:56:25 <jmcarthur> > case undefined of Sum _ -> "foo"
18:56:26 <lambdabot>   "foo"
18:56:30 <jmcarthur> > case undefined of Just _ -> "foo"
18:56:30 <copumpkin_> daryoush: that's just how it's defined to work
18:56:30 <lambdabot>   "*Exception: Prelude.undefined
18:56:41 <jmcarthur> can't think of a strict one to use on lambdabot
18:56:42 <mauke> daryoush: why does + add two numbers?
18:57:26 <daryoush> no I am puzzled as to how y gets the a from x.  Or where in the specification specifies this behaviour?
18:57:50 <jmcarthur> daryoush: x { ... } means x { with the changes in here }
18:58:02 <jmcarthur> daryoush: x serves as a template for the new value, in a sense
18:58:21 <kwuxalot> aren't arrows a type class for functions?
18:58:44 <copumpkin_> daryoush: in the haskell report
18:58:56 <copumpkin_> it's just specified behavior
18:59:54 <daryoush> any idea where I can find the spec section that talks about this?   
19:00:15 <penny> mauke: because we have foldl' (+) 0
19:00:21 <penny> aka su
19:00:23 <penny> m
19:01:42 <copumpkin_> sum is not foldl', strangely enough
19:01:54 <copumpkin_> well, not strangely, because the report doesn't mention foldl' but does mention sum
19:02:20 <penny> Wow.
19:02:26 <penny> You're right. 
19:02:31 <copumpkin_> luckily, the strictness analyzer catches it at -O2
19:02:40 <penny> The prelude is pretty crufty...
19:04:07 <penny> I mean, for numeric work, at least, the Num etc classes leave a bit to be desired.
19:06:22 <alpounet> penny, you might want to check the "numeric prelude"
19:06:42 <copumpkin_> beware, though
19:06:45 <penny> I took a look at that, and, well, it's a work of love.
19:06:58 <alpounet> haha
19:07:09 <penny> But my area is more about speed.
19:07:45 <penny> It did give me some fond rememberances of my grad abstract algebra courses.
19:08:41 <penny> But when trying to contruct something for a nice coodrinate transformation, it got me well out of my depth, between haskell type classess and ring crap.
19:14:19 <kwuxalot> @hoogle [m a] -> m [a]
19:14:20 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
19:14:20 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
19:14:20 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
19:18:35 <copumpkin_> kwuxalot: sequenceA is the most general version of that signature
19:21:01 <kwuxalot> @hoogle (a, m b) -> m (a, b)
19:21:02 <lambdabot> No results found
19:21:25 <copumpkin_> :t uncurry (fmap . (,))
19:21:26 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
19:22:04 <pickles> heh, keep that up copumpkin_ and you should change your name to colambdabot
19:22:12 <copumpkin_> :P
19:22:26 <pickles> :-D
19:22:32 <copumpkin_> @djinn Functor f => (a, f b) -> f (a, b)
19:22:33 <lambdabot> Error: Class not found: Functor
19:22:54 <kwuxalot> > (fmap . (,)) (1, Maybe 2)
19:22:54 <lambdabot>   Not in scope: data constructor `Maybe'
19:23:01 <mauke> @djinn-env
19:23:02 <lambdabot> data () = ()
19:23:02 <lambdabot> data Either a b = Left a | Right b
19:23:02 <lambdabot> data Maybe a = Nothing | Just a
19:23:02 <lambdabot> data Bool = False | True
19:23:02 <lambdabot> data Void
19:23:02 <kwuxalot> > (fmap . (,)) (1, Just 2)
19:23:04 <lambdabot> type Not x = x -> Void
19:23:06 <lambdabot>   Overlapping instances for GHC.Show.Show
19:23:08 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
19:23:10 <lambdabot>                              (f a -...
19:23:12 <lambdabot> class Eq a where (==) :: a -> a -> Bool
19:23:31 <copumpkin_> @djinn add class Functor f where fmap :: (a -> b) -> (f a -> f b)
19:23:31 <lambdabot> Cannot parse command
19:23:34 <copumpkin_> @djinn-add class Functor f where fmap :: (a -> b) -> (f a -> f b)
19:23:38 <copumpkin_> @djinn Functor f => (a, f b) -> f (a, b)
19:23:38 <lambdabot> -- f cannot be realized.
19:23:43 <copumpkin_> :(
19:24:44 <mauke> :t uncurry $ fmap . (,)
19:24:45 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => (a, f a1) -> f (a, a1)
19:25:08 <ddarius> Djinn doesn't handle higher rank types, which the encoding of constructor classes requires.
19:25:34 <kwuxalot> mauke: how the hell do you come up with that?
19:25:44 <ddarius> kwuxalot: You just follow the types.
19:25:46 <mauke> follow the types
19:25:55 <mauke> ddarius: :-)
19:26:15 <copumpkin_> is the term "diagram-chasing" standard?
19:27:10 <ddarius> copumpkin_: It's very common and understood, but I don't think I'd call it a "term" per se.
19:28:00 <roconnor> copumpkin_: see http://en.wikipedia.org/wiki/Abstract_nonsense
19:28:16 <copumpkin_> it'd be funny if that were a hyperlink to the page on category theory
19:28:34 <copumpkin_> (without commentary)
19:29:19 <copumpkin_> aha! http://en.wikipedia.org/wiki/Diagram_chasing#Diagram_chasing
19:29:47 <pickles> the preceding link was brought to you by the department of redundancy department
19:30:12 <ddarius> "Diagram chasing" usually just means verifying that a diagram commutes.  While there are some rules for it, usually one doesn't explicitly manipulate the diagrams themselves.
19:30:31 <pickles> hm
19:31:12 <mauke> "To spell out a concrete example, consider a 3-manifold M with positive Betti number."
19:32:07 <pickles> bah, too late tostart doing math
19:32:08 <pickles> nite all
19:32:57 <copumpkin_> :)
19:34:05 <copumpkin_> also, I want -XExtensibleRecordsWithScopedLabelsÀLaDaanLeijen
19:34:23 <penny> Ala Daan Leijen?
19:34:42 <copumpkin_> well, it's a language extension named after a paper reference :P
19:34:48 <copumpkin_> that's actually the title and author
19:35:16 <penny> Gak. I keep swimming, but the current...
19:35:17 <ddarius> I need some popular trichotomies like "The Good, The Bad, The Ugly"
19:35:39 <bremner> right, left, center
19:35:58 <penny> I always used up, flat, down in C..
19:36:28 <mauke> bell, book, and candle
19:36:49 <Axman6> butcher, baker candelstick maker...?
19:36:51 <penny> Hook, worm, and sinker
19:36:52 <Axman6> ,*
19:37:03 <mauke> heaven, earth, hell
19:37:13 <dankna> for what purpose do you need popular trichotomies?
19:37:26 <penny> CMP
19:37:39 <ddarius> Hook, line, and sinker is the typical one in America.
19:37:59 <dankna> red green blue
19:38:04 <dankna> cyan magenta yellow
19:38:12 <penny> Wait? Why is that an americanism?
19:38:31 <dankna> because it's a baseball----- wait, no, no it isn't :)
19:38:48 <dankna> it's amazing how many things do turn out to be baseball-related though
19:39:16 <ddarius> penny: "Hook, line, and sinker" is a more common phrase than "Hook, worm, and sinker" in America.  I didn't mean that it was an Americanism.
19:39:33 <mauke> father, son, holy ghost
19:39:43 <penny> Ah!
19:40:04 <dankna> larry moe curly
19:40:37 <mauke> animals, plants, minerals
19:40:39 <dankna> king queen jack
19:41:08 <mauke> terrans, protoss, zerg
19:41:12 <dankna> hahaahahaha
19:41:21 <dankna> oh!  duh!  we missed rock paper scissors
19:41:33 <ddarius> I think hook, line, and sinker will work for me.  Thanks.
19:41:41 <penny> up strange top
19:41:46 <dankna> penny: oooh good one
19:41:52 <dankna> bah, you aren't allowed to declare the game over
19:41:56 <dankna> we were just getting started :)
19:42:08 <mauke> hours, minutes, seconds
19:42:15 <dankna> days months years, along those lines
19:42:39 <penny> happy meh sad
19:42:42 <dankna> haha
19:42:48 <mauke> drive, directory, filename
19:43:09 <dankna> nickel dime quarter, if we really want to do Americanisms
19:43:44 <mauke> -O0, -O1, -O2
19:43:47 <dankna> haha
19:44:10 <dankna> men women children
19:44:37 <dankna> ddarius: by the way, what are you using this for?
19:45:32 <mauke> green, yellow, red
19:45:33 <penny> left, right, & center, but that sounds like the name of a tv show.
19:45:41 <dankna> so it does, haha
19:45:49 <dankna> also it was already said, wasn't it?
19:45:49 <MiggyX> okay, I have got my Haskell prog to the point where it can find the right file (it uses the system date) and prints out the contents. Next challenge is how to match particular contents of each line. I was looking at isInfixOf but not sure how to use that with IO
19:46:25 <Axman6> MiggyX: have yo9u been following any tutorials like was suggested to you?
19:46:39 <JoeyA> What are the semantics of Data.Serialize's Alternative instance for Get?
19:46:44 <mauke> nick, username, host
19:46:50 <MiggyX> Axman6: yup, I've been reading through RWH and LYAH
19:46:51 <dankna> nice one
19:46:53 <kwuxalot> wow, that's a beast: I created a newtype wrapper around (Map String a) for JSON objects. Here's how I deserialize them:
19:46:56 <kwuxalot> readJSON (JSObject j) = liftM (SMap . fromList) $ sequence $ fmap ((uncurry $ fmap . (,)) . second fromJSON) $ fromJSObject j
19:47:01 <mauke> normal, voiced, op
19:47:09 <dankna> Mac Win Lin
19:47:11 <Axman6> ,well, keep going with LYAH, and see how you de3al with IO
19:47:26 <dankna> eye/ear/nose
19:47:37 <JoeyA> The Parsec convention is that if you have a <|> b, and if a fails *without consuming input*, then it will go on to b
19:48:05 <dankna> text graphics audio
19:48:05 <JoeyA> My guess is that Data.Serialize rewinds and goes on to b if a fails.
19:48:14 <kwuxalot> how many people think that's readable Haskell?
19:48:38 <Axman6> kwuxalot: not me :\
19:48:39 <penny> head chest throat
19:48:49 <JoeyA> Parts of it are
19:49:05 <JoeyA> If I were you, I'd try to get rid of that "uncurry"
19:49:14 <dankna> space cube simplex
19:49:27 <penny> scalar vector matrix
19:49:31 <dankna> although that one's a little iffy
19:49:33 <kwuxalot> JoeyA: yeah, it's pretty ugly. It's to turn ("foo", Ok a) -> Ok ("foo", a)
19:50:41 <dankna> age sex location
19:50:46 <penny> hah
19:50:48 <dankna> hehe
19:51:26 <kwuxalot> JoeyA: the Result type (Ok a | Error String) is causing most of the ugliness: the uncurry thing, the sequence, and the liftM
19:51:33 <penny> AOL WebTV Hotmail
19:51:48 <dankna> not a true trichotomy because what about yahoo mail?
19:52:10 <dankna> you can always pick a set of three things from a set of more, like I considered noun verb adjective, but it doesn't really work
19:52:15 <penny> AOL WebTV Compuserve
19:52:18 <kwuxalot> is their a general strategy for extracting a monad out of a chain of functions like that, but in a prettier way?
19:52:19 <dankna> that's better haha
19:52:37 <dankna> ooh ooh!  Bool Maybe Either
19:52:48 <dankna> look, we're on-topic! :)
19:52:52 <kwuxalot> (But without a ton of pattern matching)
19:53:56 <penny> Well, Maybe, Either, Pair, etc. are nice. But--I still wish there was a more elegant want of selecting and operating on complex compond structures...
19:54:03 <dankna> true
19:54:46 <dankna> I only just realized today that you can (I think - I haven't actually tried yet) have multiple constructors for the same type, which are record constructors
19:55:04 <dankna> not sure if this trick is good for anything yet
19:55:37 <kwuxalot> what I want is to just say: readJSON (JSObject j) = SMap $ fromList $ fmap (second fromJSON) $ fromJSObject j
19:55:38 <ddarius> dankna: Yes you can. 
19:55:44 <dankna> ddarius: cool.
19:55:46 <penny> I'll keep it in mind.
19:55:53 <ddarius> dankna: Furthermore, the alternatives can share field names.
19:55:57 <dankna> ooh!
19:55:58 <Axman6> kwuxalot: why are you using $ instead of .?
19:56:02 <dankna> that really is nifty
19:56:05 <kwuxalot> but then magically deal with the fact that fromJSON produces an error type, and propagate that to the outside
19:56:34 <penny> I was going to say: applicative
19:57:14 <sciolizer> Hey, I'm interested in getting some experience with Haskell FFI. Are there any bindings that somebody would find helpful?
19:57:34 <penny> Qt
19:57:54 <dankna> sciolizer: all of Cocoa!
19:57:59 <penny> NoSQL
19:58:09 <sciolizer> penny: lol wut?
19:58:27 <sciolizer> dankna: I'm on linux; is that going to be a problem?
19:58:33 <dankna> sciolizer: yes :)
19:58:46 <dankna> it wasn't a serious suggestion anyway, that's not a good project for doing it by hand
19:58:49 <FeiRuoWa> oh dear.
19:58:50 <dankna> it's far too big
19:58:54 <FeiRuoWa> another nick that highlights me ><
19:58:58 <penny> If you're not making fun of me, I mean some of the newer document/distributed key databases.
19:59:02 <kwuxalot> Axman6: looks better to me
19:59:25 <MiggyX> I've been looking at the examples for pattern matching against a list, but is it feasible to do that sort of thing with a String or would it be better to look into using regex?
19:59:28 <dankna> penny: sounds interesting
19:59:35 <sciolizer> penny: oh ok. I thought you were being buzzwordy; I didn't know you mean "pick one"
19:59:46 <penny> I think there's one for mongo, but but there's also couch.
20:00:18 <kwuxalot> clearly a special case of "I want the computer to write my code for me", but I run in to this fairly frequently when writing real world Haskell code
20:00:20 <penny> It's always pick one, really?
20:00:59 <sciolizer> penny: I see libraries for both mongodb and couchdb on hackage already
20:01:00 <penny> Hah. People have been predicting that for years. But we're still in business.
20:01:15 <penny> I'm a late adopter.
20:01:43 <kwuxalot> where I write a fairly straight forward chain of functions, then realize that a couple functions return error types, and it gets 4x more complicated
20:02:07 <ddarius> kwuxalot: Stop using a pure language.
20:02:08 <penny> You know what I'd really like? I nice tensor library. Something like APL/J/K/Q, but in haskell.
20:02:18 <penny> And Repa doesn't count. Yet.
20:02:38 <kwuxalot> ddarius: but I want to appreciate my purity and eat it too
20:02:42 <sciolizer> penny: I see tensor and hTensor on hackage.
20:02:43 <dankna> I have a great pair of quotes on that topic - one is Alan Turing saying something like "... every known process will have to be taught to computers at some point.  It should be very fascinating work; any parts that are quite mechanical in nature can by that fact be turned over to the machine itself."
20:03:18 <penny> Yeah, I've looked. but they tend to be low on performance.
20:03:36 <dankna> and the other, from about five years later, is Maurice Wilkes saying something like "It wasn't as easy to get programs right as we had thought.... Debugging had to be discovered.  I remember the exact moment when I realized that a large portion of my life from then on would be spent finding and correcting mistakes in my own programs."
20:03:39 <penny> Haskell should be able to do better.
20:04:11 <dankna> regarding the "write code for me" thing.
20:04:27 <penny> Hah. The ghci debugger freaks me out. I wind up using trace...
20:04:32 <sciolizer> And here we are today, realizing that the vast majority of our time is not spent debugging, but getting the Haskell compiler to accept our programs.
20:04:36 <dankna> hahahaha
20:04:38 <dankna> true too
20:05:13 <dankna> well, new ways of having the machine write code for you are simply new ways of programming.  when the machine can /correct/ your wrong code for you, that's when I'll start worrying about my job security.
20:05:19 <kwuxalot> sciolizer: I really appreciate Haskell, but I'm far from accepting the tediousness of "getting the Haskell compiler to accept my program"
20:05:36 <MiggyX> With a pattern match (against a String) can is there a short hand for _ ?  For example, I don't care about the first 15 characters in the String.....
20:05:41 <shachaf> sciolizer: Debugging bugs caught before runtime is still debugging.
20:05:52 <ddarius> dankna: The only reason why computers don't do that now is because programmers are, naturally, control freaks.
20:06:05 <EvanR> today at work we had a meeting about whether or not to use php. when i explained as many problems i could with it, including difficulty in writing working code, verifying that its working, how there is zero expressivity of the one data structure (array) and the one control structure (for loop)... the result was to immediately look into server side javascript!
20:06:22 <sciolizer> MiggyX: I don't think so, but you could look into view patterns.
20:06:32 <dankna> ddarius: hmm. :)
20:06:35 <penny> kwuxalot: Types + Quickcheck are a heck of a lot less typing than Agile
20:06:45 <MiggyX> sciolizer: thanks :)
20:06:58 <EvanR> where is haskell when i need it
20:07:41 <EvanR> i cant be a fanboy, and if i wanted to, where are the server side 'frameworks'
20:07:42 <sciolizer> shachaf: yes, but it's "higher order" debugging
20:07:57 <dankna> EvanR: direct-fastcgi :D
20:08:03 <dankna> (of which I am the author)
20:08:07 <dankna> but it's not much of a framework really
20:08:07 <penny> EvanR: they are gestating.
20:08:11 <dankna> more the substrate of one
20:08:19 <EvanR> dankna: im using that on my personal web project
20:08:22 <EvanR> and its great
20:08:22 <sciolizer> EvanR: happs is an option
20:08:30 <dankna> oh, excellent :D good to hear!
20:08:38 <ddarius> Javascript has server-side frameworks?
20:08:46 <EvanR> but for example the management would go nuts if i told him i would have to manually add the networking before the server would work ;)
20:08:52 <EvanR> node.js
20:08:54 <dankna> haha yeah fair enough
20:09:14 <penny> sciolizer: But it's true. Lift (Hah! Like lifting is anywhere in Scala) and Rails are fantastic and horrible.
20:09:28 <EvanR> gestating, thats what i figured
20:09:37 <EvanR> 'not ready yet, put it back in'
20:11:39 <penny> Still, rails == slowness + programming with strings
20:12:21 <EvanR> but seriously js is like php with 3/5 of the wtf removed, java removed, lexical scope added, and the community removed (for the better in that case), its not really going to dramatically affect the quality of the projects
20:12:21 <penny> Lift == java with sugar
20:12:30 <penny> Better, really.
20:12:44 <dankna> js is a better choice than php, imo.  not a good choice, but a better one.
20:13:02 <Darkone> Heyall, quick question :P
20:13:04 <dankna> it's at least simple and pure for what it is
20:13:10 <penny> But you'll miss Foo :: Bar -> Baz
20:13:13 <EvanR> but it hurts doing functional in it
20:13:15 <dankna> rather than a hideous conglomerate that needs two trillion dependencies
20:13:32 <dankna> quick answer
20:13:40 <EvanR> and from what it looks like node.js has me doing as much low level scrambling as direct-fastcgi
20:13:49 <sciolizer> quick check
20:13:57 <dankna> aw
20:14:00 <dankna> ahwell
20:14:01 <Darkone> I swear I saw it before, but isn't there a function like lines that repeatedly breaks a string, but with a custom breakpoint?
20:14:11 <EvanR> so might as well use haskell in that case
20:14:12 <penny> Haskell's real problem is knowing when to use strictness annotations, etc, rather than the type system.
20:14:17 <dankna> Darkone: I don't believe so, but you can easily write one
20:14:32 <Saizan> Darkone: see the split package on hackage
20:14:34 <dankna> EvanR: well, from management's perspective, it's harder to hire Haskell programmers than JavaScript ones.
20:14:35 <sciolizer> @hoogle (Eq a) => [a] -> a -> [[a]]
20:14:36 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
20:14:36 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
20:14:36 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
20:15:00 <EvanR> dankna: true, but i think im the only one thinking of that. management doesnt think that far ahead, thinks were all going to be here next month
20:15:04 <dankna> @hoogle (Eq a) => (a -> Bool) -> [a] -> [[a]]
20:15:04 <penny> danka: True. But. Consider the quality.
20:15:04 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
20:15:04 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
20:15:04 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
20:15:15 <dankna> @hoogle (Eq a) => [a] -> (a -> Bool) -> [[a]]
20:15:15 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
20:15:15 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
20:15:15 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
20:15:37 <dankna> oh that's cool, the type match is fuzzy.  I wonder how it determines distance of type signatures.
20:15:42 <EvanR> penny: serious question, does quality matter if you cant find a mechanic for it?
20:15:42 <dankna> EvanR; yeah, oh well :(
20:16:26 <sciolizer> @src lines
20:16:26 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:16:35 <penny> I'll concede. I guess it's like the foreign car vs the domestic.
20:16:35 <EvanR> php is like garbage, you can find garbage men at 3$ per hour to pick it up no matter what
20:16:46 <dankna> heh indeed
20:16:52 <penny> Oh my god. php.
20:17:07 <penny> pretty horrible poop.
20:17:12 <Samy> <Samy> @quote lambdabot
20:17:12 <Samy> <lambdabot> lambdabot says: Plugin `quote' failed with: getRandItem: empty list
20:17:14 <Samy> ?
20:17:35 <dankna> @quote lambdabot
20:17:35 <lambdabot> lambdabot says: Occurs check: cannot construct the infinite type: a
20:17:35 <EvanR> garbage vs a space shuttle engineer ;)
20:17:38 <dankna> @quote lambdabot
20:17:38 <lambdabot> lambdabot says: Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
20:17:44 <penny> But, I get the feeling that people are moving towards Scala and away from php.
20:17:48 <Darkone> Like, foo (==';') goddamnmodfile  would take the string supplied, and make it into a list of semicolon delimited strings?
20:17:48 <Darkone> I swear I saw it  somewhere :/
20:17:48 <Darkone> split sounds familiar, thanks. Writing a short prog to read over about 600 ships in a mod text file and normalize their top speeds and accelerations ;_;
20:17:50 <EvanR> ok haskell isnt like a space shuttle
20:17:57 <jmcarthur> EvanR: :(
20:18:07 <Samy> heh
20:18:12 <EvanR> jmcarthur: that project was crap
20:18:13 <Samy> dankna, that is probably a quote, haha ;p
20:18:18 <jmcarthur> i live in a city with a lot of nasa research
20:18:21 <dankna> Samy: haha yeah I figured that out
20:18:25 <jmcarthur> i wish haskell was like a space shuttle
20:18:34 <EvanR> no you dont
20:18:40 <EvanR> it blew up twice
20:18:40 <jmcarthur> well, maybe the other way around
20:18:42 <dankna> jmcarthur: like a space shuttle in what way?  impossible to restart the assembly line of?
20:18:44 <EvanR> lol
20:18:48 <jmcarthur> i wish a space shuttle was like haskell
20:18:48 <penny> It's a logic shuttle, like drugs.
20:18:57 <EvanR> yeah
20:19:07 <jmcarthur> then it would be easy for me to get a haskell job in this city
20:19:14 <penny> Hah.
20:19:17 <jmcarthur> nasa has even researched functional languages a few times
20:19:25 <jmcarthur> but never really stuck with it
20:19:28 <EvanR> penny: scala eh
20:19:33 <dankna> that's a shame, but I see their point
20:19:40 <penny> You're going to do java, and you're going to like it.
20:19:42 <EvanR> i dare say that would probably go over better because its OOP
20:20:02 <sciolizer> ADA
20:20:09 <EvanR> yes!
20:20:10 <sciolizer> because you don't need to be functional to have a crazy type system
20:20:12 <dankna> they have the mother of all legacy code problems, because they deal with systems that /can't be upgraded/ because they're light-minutes away from the nearest screwdriver
20:20:16 <penny> Twitter/Foursquare/etc are all scala now.
20:20:20 <jmcarthur> there's a lot of ada in this city, indeed
20:20:39 <EvanR> i would so go for ada over php
20:20:42 <penny> (It's still ugly, though)
20:20:42 <Darkone> Holy sweet jesus. Looks like the cap for normalizing these ships' roll/yaw will need to be high!
20:20:42 <Darkone> Someone thought it was a good idea to give a ship a roll/yaw of .3 RPM!
20:22:16 * EvanR wonders what a space shuttle comparable in spirit to haskell would be like
20:22:23 <penny> So, as a serious question--anyone know anything about working with arrays in a high performance manner?
20:22:39 <EvanR> unboxed IO arrays right
20:22:41 <dankna> penny: use unboxed ones if at all possible, as they don't have to be garbage-collected
20:22:41 <MiggyX> When using OpenCL with Haskell, does that mean you can just call OpenCL code or can you actually write code in Haskell that will run on the GPU ?
20:23:00 <penny> Um, OpenCL is for C.
20:23:01 <fengshaun> how can I replace an element of a list at a certain index with another element?  something like: replace "hello" 3 "1" -> "hel1o"
20:23:20 <penny> Unboxed is good--but the standard Data.Array.Unboxed is bad.
20:23:22 <MiggyX> penny: I'm just looking at the binding on hackage
20:23:31 <DrSyzygy> Shoudl be possible to write an FFI to OpenCL-able code.
20:23:38 <penny> I wound up writing my own...
20:23:53 <penny> But I'd love to be wrong.
20:23:56 <DrSyzygy> Also Hackage -> OpenCLRaw. 
20:24:00 <penny> Vector seems super cool.
20:24:09 <penny> But it's linear.
20:24:15 <penny> Hmm.
20:24:23 <EvanR> time isnt linear, its cubic
20:24:24 <dankna> > let replace i e l = take i l ++ [e] ++ drop (i + 1) l in replace 5 'Z' "abcdefghijklmnopqrstuvwxyz"
20:24:25 <lambdabot>   "abcdeZghijklmnopqrstuvwxyz"
20:24:27 <penny> OpenCLRaw? Is that alpha?
20:24:40 <DrSyzygy> Possible.
20:24:50 <DrSyzygy> I only noticed it exists. Didn't look at it much.
20:25:03 <penny> Thank you...I'm glad I asked...
20:25:38 <penny> I'd personally love a proper OpenCL haskell platform...
20:26:06 * EvanR looks up scala, for the sake of it
20:26:29 <penny> EvanR: You mean, like a time cube?
20:27:47 <MiggyX> penny: me too :) I'm also talking to Tilera to see if they are interested in Haskell running on their cards
20:27:59 <penny> Hey, OpenCLRaw looks very interesting. Thank you xoxo!
20:28:16 <deech> Hi all, I've seen various articles, Awesome Prelude (http://tom.lokhorst.eu/2010/02/awesomeprelude-presentation-video) for one, that emphasize type classes over data-types? I don't get the advantage. How is that better design?
20:28:27 <EvanR> doesnt gene ray live in alabama?
20:29:03 <MiggyX> penny: if you take a look at it, I would be interested in your comments as you seem to already have some experience with OpenCL
20:29:34 <sciolizer> deech: "better design" is debatable, but part of the advantage of type classes is they are "open". That is, other modules can extend their definition, whereas you can only change a data structure if you have the original source code.
20:30:12 <penny> I'll take a closer look. You can send me an email at penelope.fraisse@gmail.com.
20:30:26 <MiggyX> penny: thanks, I appreciate that
20:30:39 <deech> sciolizer: So data structures are defined entirely by functions, is that the idea?
20:31:06 <EvanR> type classes are for a different thing than data
20:31:30 <sciolizer> deech: haven't seen the presentation
20:32:02 <deech> My understanding is that a type class is merely a list of functions that can be called on a certain data type.
20:33:45 <EvanR> one is interface, the other is concrete data
20:33:50 <EvanR> or implementation
20:34:04 <deech> sciolizer: There's a blog post here : http://tom.lokhorst.eu/2009/09/deeply-embedded-dsls
20:34:09 <EvanR> you cant do anything with just a type class
20:36:07 <EvanR> gah, if they cant name their types correctly then im already tasting this bad
20:36:19 <EvanR> scala Byte is a 2s completement signed integer
20:36:23 <EvanR> complement
20:36:51 <EvanR> something unusual about haskell is the correct naming of everything
20:36:52 <monochrom> what is a correct name?
20:37:00 <EvanR> Int8 ?
20:37:10 <monochrom> I wouldn't say that "map" is a correct name.
20:37:27 <deech> or "return"
20:37:31 <ddarius> Would you say that "mpa" is an incorrect name?
20:38:13 <EvanR> Char, 16-bit unsigned unicode character
20:38:13 <monochrom> many people testify that the three names "data", "type", "newtype" are mixed up.
20:38:22 <EvanR> ... unicode characters dont have sign, they arent numbers
20:38:25 <EvanR> they are characters
20:38:36 <ddarius> monochrom: I've never heard that.
20:38:51 <monochrom> in particular beginners.
20:39:01 <sciolizer> deech: they're basically suggesting that we could save ourselves a lot of boilerplate, and get a lot of reuse, if our standard prelude operations worked on arbitrary datatypes, and not on concrete datatypes
20:39:15 <sciolizer> deech: kind of like the ListLike library on hackage
20:39:52 <sciolizer> deech: but you still need to specialize your functions to concrete types at some point in the game, even if it is only in your main function.
20:40:07 <monochrom> But I can argue it too. When I define my own type, why isn't it always a "newtype"? And why isn't it allowed to be a "type"?
20:40:11 <EvanR> ignoring my previous point, making data a keyword eliminates a horribly name for a variable that i have to deal with every day in php
20:40:35 <ddarius> Clearly they should use 'x' instead of 'data'
20:40:48 <EvanR> if it was self contained onto one page of source then maybe
20:40:59 <EvanR> in haskell its often in scope for less than 5 lines
20:43:33 <sciolizer> EvanR: if you go pointfree, you can avoid scope entirely!
20:44:26 <EvanR> exactly
20:44:43 <deech> sciolizer: I like the readability of their approach, I can never get used to reading an AST. I'm just wondering if there any tradeoffs.
20:44:44 <EvanR> real coders dont use variables
20:46:53 <sciolizer> deech: my guess would be 1) You can't pattern match any more 2) type errors would get REALLY complicated
20:48:00 <EvanR> deech: you have to have a really good reason to define a class
20:48:13 <EvanR> otherwise you may fall into a trap
20:48:33 <EvanR> and youll get buried in boilerplate
20:49:33 <penny> I feel a tension between GADT and dissoveled type classes.
20:50:04 <penny> Is there a bettter way to do Functor -> Applicative -> Monad than typeclasses?
20:51:26 <sciolizer> penny: what do you find unsatisfactory about doing those as type classes?
20:51:43 <penny> Well, it's the way they are currently done.
20:52:01 <penny> Not orthongonal, based on history.
20:52:08 <EvanR> is that a real heirarchy?
20:52:13 <penny> It should be.
20:52:16 <c_wraith> yes, it is.
20:52:41 <EvanR> applicative is defined in terms of functor, but monad not applicative
20:52:45 <c_wraith> The interesting thing about that is that some types have alternative Applicative instances, even though their Functor and Monad instances are mechanical.
20:52:56 <penny> EvanR: but it should be!
20:53:01 <EvanR> hmm
20:53:28 <penny> It's an accident/cruft of history
20:53:44 <penny> We know more now than we did before.
20:53:47 <EvanR> this bit is actually some anti haskell propaganda ive hear
20:54:00 <penny> Hey! I heart Haskell.
20:54:01 <EvanR> because of that particular part of the standard lib, haskell sucks
20:54:18 <EvanR> scala isnt inspiring me though
20:54:23 <c_wraith> I'm not completely sure what the contents of each class should be.  because of the way do notation works, it's important for >>= to be as efficient as possible.
20:54:39 <penny> No, I'm just an idealist, and I'd like to see it fixed in the future, along with the numeric classes.
20:54:48 <penny> Scala is ugly.
20:55:02 <c_wraith> It kind of leads to tension between minimal type classes and making efficient implementations possible.
20:55:42 <EvanR> also >>= is incorporated into the logo
20:55:43 <penny> c_wraith: I don't think so. I think the real problem is that we have a fixed base, and now we have inertial.
20:55:43 <kwuxalot> is there an easy way to make a specific tuple type with all the conviences of (,)? Or do I have to just say: data Foo String Integer deriving (Read, Show, Data, Typeable); instance Funtor ....
20:55:46 <EvanR> you cant change it ;))
20:56:25 <penny> Oh, you can make your own numeric class/functor/etc
20:56:43 <penny> And have a map == fmap.
20:56:45 <penny> gg
20:56:55 <EvanR> kwuxalot: do you want Complex :+ ?
20:57:14 <sciolizer> kwuxalot: type MyType = (String,Integer)?
20:57:16 <penny> kwuxalot: it depends?
20:57:17 <c_wraith> > sqrt (-1) :: Complex Rational
20:57:18 <lambdabot>   No instance for (GHC.Float.RealFloat
20:57:18 <lambdabot>                     (GHC.Real.Ratio GH...
20:57:26 <c_wraith> > sqrt (-1) :: Complex CReal
20:57:27 <lambdabot>   0.0 :+ 1.0
20:57:32 <penny> Are you worried about efficiency?
20:57:44 <kwuxalot> penny: not efficiency, just verbosity
20:58:20 <penny> In the long run? I'd vote for a data with strictness annotations.
20:58:25 <kwuxalot> sciolizer: yes, I think that is most reasonable for now
20:58:47 <penny> Because: you can separate the external operations from the data.
20:59:23 <penny> You're going to have to write and rewrite your code as you data type changes if you don't abstract it.
21:00:30 <penny> Lists and tuples are the devil's children.
21:00:49 <sciolizer> > sqrt ((-1) :+ 0)
21:00:50 <lambdabot>   0.0 :+ 1.0
21:01:20 <dbelange> 0.0
21:01:42 <penny> srqt ((-1) :+ 2)
21:02:12 <EvanR> > sqrt (1 :+ 1)
21:02:13 <lambdabot>   1.09868411346781 :+ 0.45508986056222733
21:02:24 <penny> hee.
21:02:42 <penny> It misses the rest of the circle.
21:02:56 <Samy> :t (:+)
21:02:57 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
21:02:59 <ddarius> penny: Lisp is nothing but tuples, and it's the best programming language in the world.
21:03:16 <Samy> What is (:+)?
21:03:17 <penny> Except for scheme?
21:03:22 <sciolizer> oh lame. Why does complex need to be RealFloat?
21:03:25 <EvanR> Samy: constructor for a complex number
21:03:30 <Samy> > 1 (:+) 2
21:03:31 <lambdabot>   Ambiguous type variable `t' in the constraint:
21:03:31 <lambdabot>    `GHC.Num.Num t' arising f...
21:03:33 <Axman6> :t (:+)
21:03:34 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
21:03:36 <EvanR> > (:+) 1 2
21:03:37 <lambdabot>   1.0 :+ 2.0
21:03:41 <Samy> err
21:03:45 <Samy> > 1 :+ 2
21:03:46 <lambdabot>   1.0 :+ 2.0
21:03:54 <penny> sqrt (-2)
21:03:57 <Samy> sleep dep ;]
21:04:02 <Samy> EvanR, cool.
21:04:15 <EvanR> Samy: operators starting with : are data constructors
21:04:31 <ddarius> : is clearly an uppercase letter
21:04:40 <Samy> haha
21:04:46 <sciolizer> :)
21:04:50 <sciolizer> ^ I'm yelling at you.
21:04:53 <Axman6> @hoogle COmplex a -> a
21:04:54 <lambdabot> Did you mean: Complex a -> a /count=20
21:04:54 <lambdabot> Prelude id :: a -> a
21:04:54 <lambdabot> Data.Function id :: a -> a
21:04:58 <Axman6> @hoogle Complex a -> a
21:04:58 <lambdabot> Data.Complex imagPart :: RealFloat a => Complex a -> a
21:04:58 <lambdabot> Data.Complex magnitude :: RealFloat a => Complex a -> a
21:04:58 <lambdabot> Data.Complex phase :: RealFloat a => Complex a -> a
21:05:15 <Axman6> > magnitude (1:+1)
21:05:15 <lambdabot>   Ambiguous occurrence `magnitude'
21:05:15 <lambdabot>  It could refer to either `Data.Complex.ma...
21:05:17 <EvanR> Complex serves nicely the purpose of a 2d real vector
21:05:28 <Axman6> > Data.Complex.magnitude (1:+1)
21:05:29 <lambdabot>   1.4142135623730951
21:05:58 <EvanR> like for programming mario bros or something
21:06:08 <ddarius> Complex serves better as a 2D spinor.
21:06:21 <sciolizer> polar mario
21:06:31 <djahandarie> ddarius, by definition :P
21:06:33 <EvanR> it pattern matches into rectangular
21:08:43 <EvanR> @src Applicative
21:08:43 <lambdabot> class Functor f => Applicative f where
21:08:43 <lambdabot>     pure  :: a -> f a
21:08:43 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
21:09:02 <djahandarie> @src Functor
21:09:02 <lambdabot> class  Functor f  where
21:09:02 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
21:09:09 <EvanR> can applicative be used to carry an implicit state
21:09:11 <djahandarie> @src Pointed
21:09:11 <lambdabot> Source not found. Just try something else.
21:09:15 <djahandarie> >={
21:11:26 <bos> @pl \x -> x == x
21:11:26 <lambdabot> join (==)
21:11:34 <bos> @pl \x -> f x == x
21:11:34 <lambdabot> (==) =<< f
21:11:53 <sciolizer> EvanR: yes. StateR and StateL, for instance
21:12:01 <EvanR> how would you do a data type that is used to string together lines of text, but knows about 'current indent level', and can increment or decerement the indent level
21:12:21 <EvanR> a monad is overkill
21:12:47 * EvanR checks out StateR
21:13:13 <EvanR> @hoogle StateR
21:13:13 <lambdabot> No results found
21:13:17 <EvanR> @hoogle StateL
21:13:17 <lambdabot> No results found
21:13:24 <EvanR> sciolizer: :(
21:13:39 <sciolizer> yeah, I'm trying to find it too
21:13:42 <sciolizer> I see it here: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Applicative.html
21:14:49 <sciolizer> EvanR: just be aware that if you have Applicative and Functor, you automatically have Monad. (although nothing in the std libraries would indicate this)
21:15:02 <EvanR> hmm
21:15:46 <EvanR> i dont think i want applicative either
21:15:48 <Saizan> sciolizer: that's not true
21:16:08 <sciolizer> Saizan: oh you're right
21:16:15 <Saizan> sciolizer: in fact, Functor doesn't add anything to Applicative, being a superclass
21:16:15 <Axman6> monad adds join
21:16:17 <sciolizer> Saizan, EvanR: you need bind or join
21:16:41 <EvanR> :t join
21:16:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:17:04 <EvanR> join is like >>= i guess
21:17:14 <EvanR> it executes the programmable semicolon
21:17:18 <djahandarie> Isomorphic, in fact
21:18:17 <sciolizer> Saizan: ah yes. It was the Applicative implies Functor relationship that I guess I was thinking of.
21:18:19 <Saizan> join x = x >>= id; m >>= f = join (fmap f m)
21:18:22 <djahandarie> m >>= g = join ((fmap g) m), if I remember correctly
21:18:31 <djahandarie> Beat to it
21:20:21 <EvanR> data Typewriter = Line String | Indent | Unindent... finalizeTypewriter :: Typewriter -> String
21:20:34 <EvanR> looks fairly non generic ;)
21:22:36 <EvanR> cool, i could use State to write finalizeTypewriter
21:22:52 <EvanR> \o/
21:24:01 <EvanR> hrm i need a list or something
21:25:47 <EvanR> ReturnCarriage (Typewriter -> Typewriter)
21:25:54 <ddarius> @hoogle unsafeAt
21:25:55 <lambdabot> No results found
21:31:57 <EvanR> maybe i want StateT Int (Writer DList or something
21:39:05 <dobblego> Cale, why is there no instance Applicative MaybeT?
22:02:41 <keeperofdakeys> I have a matrix which is a list of lists of the rows of the matrix
22:03:05 <keeperofdakeys> what would be the easiest way to turn this into a list of lists of the colomn values
22:03:08 <keeperofdakeys> ?
22:03:34 <sciolizer> @info transpose
22:03:35 <lambdabot> transpose
22:03:37 <Cale> dobblego: because someone was careless?
22:03:54 <Cale> > transpose [[1,2,3],[4,5,6],[7,8,9]]
22:03:55 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
22:04:01 <dobblego> Cale, sorry , I confused the cabal fields
22:04:24 <lispy> cabal field has which axioms?
22:04:24 <keeperofdakeys> that is perfect
22:04:50 <keeperofdakeys> I should really think back to the mathematics more :P
22:04:55 <keeperofdakeys> thanks
22:04:59 <lispy> identity, associativity, multiplication, addition, inverses, and distribution, and what?
22:06:11 <Axman6> bacon
22:06:48 <lispy> Axman6: ah, that makes sense?
22:07:07 <Axman6> well, i figure maths needs more bacon
22:07:38 <lispy> What math will vegans consume?
22:08:07 <new11> @pl (\x y -> (x+y)*x )
22:08:07 <lambdabot> flip =<< ((*) .) . (+)
22:08:32 <Axman6> @pl \x y z -> x+y*z
22:08:32 <lambdabot> (. (*)) . (.) . (+)
22:08:43 <new11> @pl f x y = (x+y)*(x - y)
22:08:43 <lambdabot> f = ap (ap . ((*) .) . (+)) (-)
22:08:45 <lispy> ?pl (\x y z -> (x + y) * z)
22:08:45 <lambdabot> ((*) .) . (+)
22:10:38 <FunctorSalad_> "GHC compiles to the spineless tagless G-machine (STG). [...] 'G-machine' because it does graph reduction. 'Spineless' because it can't stand up to bullies. 'Tagless' because the graph nodes don't have 'tags' on them to say what they are. "
22:10:51 <FunctorSalad_> a gem found on http://www.haskell.org/haskellwiki/GHC_optimisations . :)
22:11:49 <new11> @pl f x y = filter y (map x) 
22:11:49 <lambdabot> f = flip filter . map
22:12:13 <new11> @pl f x y = filter y (map (x.y)) 
22:12:13 <lambdabot> f = ap filter . (map .) . (.)
22:12:14 <Gracenotes> oh, those activation-record bullies
22:12:30 <Gracenotes> they never give up do they
22:15:40 <FunctorSalad_> I took that part to mean that the writer doesn't know wtf 'spineless' refers to either :)
22:15:50 <FunctorSalad_> (activation record?)
22:16:21 <FunctorSalad_> the thing that stops other threads from evaluating a thunk that is already being evaled?
22:16:37 <Gracenotes> activation records, stack frames in languages that actually have spiney stacks
22:16:58 <jekor> How do I use a type class in a GADT? I'd like to do: data PGMsg = Something | SomethingElse [Typeable]
22:18:49 <FunctorSalad_> ah. didn't know that term in the cxt of usual stacks
22:20:25 <FunctorSalad_> jekor: that doesn't seem specific to GADTs
22:20:45 <FunctorSalad_> (do you mean how to make a heterogenous list in general?)
22:21:11 <FunctorSalad_> (in that case you need an existential type)
22:21:27 <jekor> Well, I know how to do it in a function declaration.
22:21:58 <jekor> Like, someFunc :: Typeable a => [a] -> [a] -- IIRC
22:22:25 <jekor> I tried that syntax with the GADT and it didn't work.
22:22:40 <jekor> Not in scope: type variable `a'
22:23:31 <FunctorSalad_> the 'G' in 'GADT' specifically means certain parameterised ADTs
22:23:51 <FunctorSalad_> like data Foo a where IntFoo :: Int -> Foo Int
22:24:23 <jekor> Ah.
22:24:29 <FunctorSalad_> (where constructors can have return types where the parameter takes a value other than a plain type variable)
22:24:42 <jekor> So this is just an ADT.
22:25:21 <FunctorSalad_> yeah. you can't do [Typeable] because Typeable isn't a type
22:25:49 <FunctorSalad_> but you can make a so-called existential type whose values are of "any type a such that Typeable a"
22:26:32 <FunctorSalad_> http://www.haskell.org/haskellwiki/Existential_type :)
22:27:00 <FunctorSalad_> I think the "Dynamic" type already is this Typeable-existential, not entirely sure
22:27:28 <Gracenotes> aaah.
22:27:31 <jekor> Ah, there it is. Thanks.
22:27:45 <FunctorSalad_> (Data.Dynamic)
22:27:52 <Gracenotes> case [1,2,3] of (x:xs) -> x; [] -> 4.
22:28:14 <Gracenotes> in a spineless machine, the data structure (x:xs) will not get written on the heap unless it is already there.
22:28:24 <Gracenotes> this way, the structure of the computation is not forced.
22:28:46 <Gracenotes> I was pretty sure it also had something to do with the stack being contiguous and undemarcated.. but it could be both.
22:28:49 <Gracenotes> or neither.
22:29:50 <FunctorSalad_> hmm. the x and xs get written to the stack instead?
22:30:54 <FunctorSalad_> I vaguely remember that the [1,2,3] thunk is actually passed the cons-continuation and the nil-continuation
22:31:27 <jekor> Thanks for the pointer to Data.Dynamic, I'd forgotten about it.
22:32:08 <Gracenotes> well. or heap, in the formal implementation of STG in the papers. you evaluate until you find a cons, basically, and since the only way you could have gotten there is a case statement, you don't *need* to put the (:) on the heap
22:32:22 <Gracenotes> unless you do.
22:33:42 <Gracenotes> I'm unclear about the role of the stack in GHC
22:34:25 <Gracenotes> other than what it has in common with other programming languages, unwinding computations as the code progresses
22:34:26 <FunctorSalad_> I thought the [1,2,3] invokes the cons continuation with args 1 and [2,3]
22:34:45 <FunctorSalad_> but I only read a little bit of the stg paper :)
22:34:59 <Gracenotes> oh yeah. unless you're like case [1..3] of foo@(x:xs) -> head foo, then you have to allocate for a cons
22:35:05 <FunctorSalad_> (this would imply that the stack is used)
22:37:40 <Gracenotes> the paper, at least the formal first part, uses 3 stacks. one for collecting arguments for partial application, one for thunk updates in progress, and within that another one for case statement continuations in progress
22:40:06 <Gracenotes> yeah.. and modern architectures don't exactly support 2d memory maps
22:40:09 <Gracenotes> or 3d
22:41:21 <FunctorSalad_> hmm sounds like just a sum of stacks, not a product (the latter's how I'd interpret "2d"/"3d")
22:42:15 <Gracenotes> well, return stacks exist in the context of a given thunk update
22:43:00 <Gracenotes> but well there's no reason why they can't be mixed together, besides making things a little messy, because they mutually nest.
22:43:30 <tolkad> why isn't the Identity monad defined as IdentityT with a type synonymn for Identity?
22:43:38 <tolkad> in the transformers package
22:44:18 <Gracenotes> what monad would IdentityT apply to?
22:44:27 <Gracenotes> for this type synonym
22:44:32 <tolkad> type Identity = IdentityT Identity
22:44:49 <c_wraith> Mu IdentityT
22:44:55 <c_wraith> tolkad, quit trolling.
22:45:44 <c_wraith> If your intention is to joke, please make it clearer.
22:45:54 <tolkad> it would be cool if haskell supported recursive types. Is there any reason it can't?
22:46:10 <tolkad> c_wraith: I was saying that first to point out how useful recursive types would be
22:46:17 <c_wraith> @src Mu
22:46:17 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
22:46:25 <c_wraith> haskell supports recursive types
22:46:33 <c_wraith> it just doesn't support recursive type *aliases*
22:46:39 <c_wraith> because those would have an infinite expansion
22:46:49 <flux> tolkad, ocaml supports them (without an intermediate tag) when given -rectypes, but apparently it can cause very confusing error messages
22:47:19 <tolkad> c_wraith: if haskell supported recursive types maybe it would be possible for fix to typecheck
22:47:31 <c_wraith> :t fix
22:47:32 <lambdabot> forall a. (a -> a) -> a
22:47:36 <c_wraith> Seems to typecheck
22:47:49 <tolkad> I mean defined using lambdas
22:49:01 <Gracenotes> eh, who needs simply typed lambda calculus as the basis of your type system when you can replace it with something far more mindscrewing
22:49:13 <flux> tolkad, actually here's an ocaml example that might be more nice if it just gave error: http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora209.html (at the end)
22:50:09 <djahandarie> Is there a general word for things that are Monads when you apply Mu to them?
22:50:26 <tolkad> ul = \a b -> (unsafeCoerce a b)
22:50:26 <tolkad> fix = (\f -> (\x -> f (ul x (ul x))) (\x -> f (ul x (ul x)))) :: (a -> a) -> a
22:50:51 <tolkad> it works
22:51:40 <Gracenotes> djahandarie: twould be useful?
22:52:11 <djahandarie> It would help me find other things like that :P
22:52:26 <Gracenotes> well.. how would fmap work for a few of these things, to start with..
22:52:44 <djahandarie> Magic
22:53:09 <tolkad> :t Mu
22:53:10 <lambdabot> Not in scope: data constructor `Mu'
22:53:23 <tolkad> :k Mu
22:53:24 <lambdabot> (* -> *) -> *
22:53:24 <djahandarie> More seriously, wouldn't it just apply recursively?
22:53:33 <djahandarie> Like how a catamorphism workds
22:53:39 <djahandarie> works
22:54:07 <Gracenotes> fmap undefined (someValue :: Mu []) should be valid for any someValue, and a sufficiently lazy fmap
22:54:22 <Gracenotes> so you do need some values.. eventually.. I think
22:54:26 <quicksilver> djahandarie: Mu is just a way to encode recursive datatypes without explicit recursion.
22:54:33 <quicksilver> there's nothing very special abotu it
22:54:40 <quicksilver> plenty of recursive data types are monads
22:54:45 <quicksilver> ..and plenty are not.
22:55:11 <djahandarie> Right
22:56:05 <tolkad> :k Mu (State)
22:56:06 <lambdabot>     `State' is not applied to enough type arguments
22:56:06 <lambdabot>     Expected kind `* -> *', but `State' has kind `* -> * -> *'
22:56:32 <tolkad> is there a type synonym equivalent of flip?
22:56:41 <Gracenotes> nop.
22:56:52 <Gracenotes> hm, what are some Mus with non-trivial NF values but still infinite values inhabiting?
22:57:11 <djahandarie> NF?
22:57:18 <Gracenotes> normal form, fully evaluated
22:57:43 <Gracenotes> by non-trivial I mean that (Mu T a) contains values of type a.
22:58:02 <tolkad> :k State
22:58:03 <lambdabot> * -> * -> *
22:58:07 <djahandarie> ListF f a = Cons a f | Nil, Mu NatF?
22:58:16 <djahandarie> Not sure if I understand your question correctly
22:58:31 <Gracenotes> er... yeah. I'm just not feeling very creative atm.
22:58:46 <Gracenotes> that one is branching.
22:58:53 <Axman6> :t let x = (1,In x) in x
22:58:53 <lambdabot> forall t. (Num t) => (t, Mu ((,) t))
22:59:02 <Axman6> :t let x = In (1,In x) in x
22:59:03 <lambdabot>     Couldn't match expected type `(t, Mu ((,) t))'
22:59:03 <lambdabot>            against inferred type `Mu ((,) t)'
22:59:03 <lambdabot>     In the expression: In (1, In x)
22:59:09 <Axman6> :t let x = In (1,x) in x
22:59:10 <lambdabot> forall t. (Num t) => Mu ((,) t)
22:59:18 <Axman6> > let x = In (1,x) in x
22:59:19 <lambdabot>   In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In ...
22:59:33 <tolkad> :t In (State (\s -> ((), s)))
22:59:34 <lambdabot>     Couldn't match expected type `Mu f' against inferred type `()'
22:59:34 <lambdabot>     In the expression: ()
22:59:34 <lambdabot>     In the expression: ((), s)
22:59:34 <Gracenotes> Maybe-like types are lists really
23:01:13 <dobblego> @hoogle [(p, [r])] -> [(p, r)]
23:01:13 <lambdabot> No results found
23:02:27 <tolkad> @src Mu
23:02:27 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
23:02:51 <tolkad> :k (-> Bool)
23:02:51 <lambdabot> parse error on input `Bool'
23:02:57 <tolkad> :k (->) Bool
23:02:58 <lambdabot> ? -> *
23:04:03 <tolkad> will the inliner non termination bug (http://darcs.haskell.org/download/docs/6.12.3/html/users_guide/bugs.html#bugs-ghc) affect lambdabot?
23:07:19 <tolkad> I guess not
23:07:23 <Axman6> :t let u = u in u 1 2 3
23:07:24 <lambdabot> forall t. t
23:08:01 <tolkad> > let x = x in x
23:08:05 <lambdabot>   mueval-core: Time limit exceeded
23:08:32 <tolkad> it's hard to understand what that actually compiles to
23:08:53 <tolkad> does ghc treat x as a function?
23:08:57 <djahandarie> Welcome to Haskell
23:09:06 <lispy> tolkad: it's a thunk
23:10:02 <tolkad> lispy: a very formal term I'm sure :P
23:10:11 <tolkad> oh it is
23:10:14 <tolkad> huh
23:10:19 <tolkad> silly name
23:11:12 <tolkad> I see, so it is a function in the C sense of the term
23:15:33 * hackagebot authenticate 0.7.2.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.7.2.1 (MichaelSnoyman)
23:18:48 <dobblego> do you lose record selector syntax when you make a data type abstract?
23:20:18 <Axman6> ghci
23:20:22 <Axman6> whoops
23:21:11 <turiya> how can i convert a string ["123","456"] to a tuple (123,456) :: (Int,Int)
23:21:34 <dobblego> \[a, b] -> (read a, read b)
23:22:00 <dobblego> > let k = \[a, b] -> (read a, read b) in k ["123","456"] :: (Int, Int)
23:22:01 <lambdabot>   (123,456)
23:23:23 <tolkad> dobblego: what do you mean abstract?
23:23:34 <dobblego> not-exported constructors
23:23:53 <tolkad> dobblego: you can export the selector and use it as a normal function
23:24:02 <dobblego> sure, but selector syntax?
23:24:09 <tolkad> dobblego: but yeah you can't use record selector syntax without the constructor in scope
23:24:14 <dobblego> ok ta
23:24:31 <turiya> dobbelgo: thanks, will try to understand that
23:27:25 <tolkad> dobblego: not sure what will happen if you try to modify a field using record selector syntax without the constructor in scope
23:27:49 <tolkad> like a {x = b}
23:28:10 <tolkad> I'll try it
23:30:21 <turiya> dobblego: how to parse "1000 1000" into (1000,1000)?
23:30:31 <tolkad> dobblego: you can do it without the constructor in scope
23:30:36 <tolkad> dobblego: modify fields that is
23:30:40 <dobblego> tolkad, excellent thanks
23:32:14 <kevinburke> hey there i'm new to haskell
23:32:22 <kevinburke> i typed let x = 5/0 into ghci
23:32:27 <kevinburke> and it gives me back "Infinity"
23:32:32 <kevinburke> shouldn't that return an error?
23:32:39 <dobblego> it should give you nothing
23:32:39 <Zao> Why would it?
23:32:39 <Veinor> > let x = 5/0 in 5+x
23:32:40 <lambdabot>   Infinity
23:32:50 <dobblego> you probably typed x after that
23:32:59 <Veinor> different languages handle division by zero in different ways
23:33:12 <tolkad> kevinburke: it's using floating point types
23:33:16 <Zao> Veinor: And different hardware, depending on the level of your language.
23:33:17 <kevinburke> let x = 5/0
23:33:38 <tolkad> kevinburke: this doesn't have much to do with haskell in particular and more to do with floating point type standards
23:33:45 <kevinburke> let x = 5.0/0.0 in 5+ x
23:33:55 <kevinburke> > let x = 5.0/0.0 in 5+x
23:33:56 <lambdabot>   Infinity
23:34:02 <kevinburke> ok i know a little about those
23:34:15 <Veinor> > 0.0/0.0
23:34:15 <lambdabot>   NaN
23:34:28 <tolkad> > (-0.0)/0
23:34:29 <lambdabot>   NaN
23:34:34 <tolkad> > (-0.0)/(-0)
23:34:35 <lambdabot>   NaN
23:34:59 <sciolizer> > 5 `div` 0
23:34:59 <lambdabot>   *Exception: divide by zero
23:35:10 <tolkad> kevinburke: also, haskell prefers encoding errors into return types rather than throwing error messages
23:35:41 <tolkad> kevinburke: haskell does have a means of catching exceptions but it's best to avoid them if possible
23:37:13 <kevinburke> okay
23:38:14 <kevinburke> thanks
23:49:17 <pelotom> how useful are existential types on a scale from 1 to 10?
23:49:45 <cch> @hoogle Char -> String -> [String]
23:49:45 <lambdabot> Text.XHtml.Strict renderHtmlWithLanguage :: HTML html => String -> html -> String
23:49:45 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
23:49:46 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
23:51:26 <Veinor> cch: what were you trying to do?
23:53:08 <nickela> hello #haskell, please see http://hpaste.org/40953
23:53:34 <nickela> can be closest'' rewritten more compact? maybe in one line function?
23:56:20 <Zao> Maybe zipWith with tail and do something clever around that?
23:57:17 <ski> pelotom : obviously it depends on what one's trying to do .. in general, i don't know
23:57:37 <pelotom> ski: yeah, I guess I'm wondering what a great use case is
23:58:26 <pelotom> I've seen the example of a heterogeneous list where you abstract away everything but the type class all the members are instances of
23:59:12 <nickela> or more general question, how in Haskell do folding with break conditions
23:59:41 <dmwit> nickela: Why not "closest c = minimumBy (comparing (abs . (c-))))"?
