00:00:49 <jamy23> dropdriv1: calling what specifically? 
00:04:40 <kmc> dropdriv1, you might be able to use http://hackage.haskell.org/package/MissingPy or http://hackage.haskell.org/package/cpython
00:04:55 <kmc> dropdriv1, but often the easiest way to do cross-language FFI is separate processes
00:07:00 <kmc> a GHC Haskell program can easily spawn some threads to communicate with a Python program over a socket or pipe
00:07:13 <kmc> but i guess it's harder on the Python side, due to poor support for concurrency in CPython
00:21:38 <adnap> Why isn't Complex an instance of Enum?  Is it because they couldn't decide whether to traverse the real or the imaginary axis first?
00:22:02 <adnap> I guess you would go to infinity along one axis.
00:22:04 <Axman6> well, how would you implement it?
00:22:22 <adnap> Yeah, I see why.
00:22:30 <kmc> you could spiral out from the origin
00:22:37 <adnap> Oh, that's true.
00:22:40 <Axman6> what should [0:+0..10:+10] be?
00:22:54 <kmc> but ℂ isn't countable any more than ℝ
00:23:03 <kmc> and the Enum instance for Float / Double is dumb
00:23:04 <adnap> kmc: Wait, you couldn't spiral.
00:23:26 <adnap> kmc: You could have an infinite number of complex numbers at a specific radius.
00:23:33 <adnap> kmc: Or a specific angle.
00:23:44 <kmc> there's a continuous function from ℝ to ℂ
00:23:48 <kmc> any space-filling curve
00:24:22 <kmc> a continuous function whose range is all of ℂ i mean
00:24:42 <Gilly> it can't be injective, though
00:24:52 <adnap> kmc: What is it?
00:25:51 <adnap> Wait, I know how I could implement Enum.
00:26:05 <adnap> I could just let the two numbers specify the corners of a box.
00:26:20 <adnap> Oh, wait.  I see the problem.
00:26:28 <adnap> You don't know what the granularity is.
00:27:00 <kmc> adnap, any space-filling curve
00:27:04 <Axman6> how do you implement enumFromThenTo then? how does [0:=0, -1:+3 .. 7 :+ -4
00:27:07 <Axman6> ] work*
00:27:28 <kmc> Gilly, why not?
00:27:42 <Gilly> adnap: http://en.wikipedia.org/wiki/Space-filling_curve <- they give an overview of construction there
00:28:06 <Gilly> kmc: that would mean that you could construct a homeomorphism between, say, unit interval and unit square
00:28:39 <Gilly> kmc: but if you remove one point from the unit interval it will not be connected anymore, however removing a point from the square keeps the square connected, so they are not homeomorphic
00:28:48 <kmc> i see
00:30:18 <adnap> So, with a space-filling curve that makes a box, you would never get beyond one row or column because there are an infinite number of complex numbers in that row or column, right?
00:30:51 <Gilly> adnap: what do you mean by "get beyond"?
00:31:45 <adnap> Gilly: In terms of computation, it would take infinitely long to get a number on the next row or column.
00:32:03 <adnap> Gilly: Because you never run out of elements on the first row or column.
00:32:27 <adnap> Gilly: 'Cause imaginary numbers are infinite and so are reals.
00:32:30 <Gilly> adnap: the curve (say gamma) being a curve means that for every x in the box there is some t in ]0,1[ such that gamma(t) = x, so yea you can "get" to every point
00:33:02 <adnap> Gilly: Right, the parameter t is a real number, and reals are infinite.
00:33:16 <Gilly> adnap: on the other hand you can't enumerate those points, since the reals are uncountable
00:33:29 <Jonno_FTW> @let test = "test"
00:33:30 <lambdabot>  Defined.
00:33:34 <Jonno_FTW> > test
00:33:35 <lambdabot>   "test"
00:34:06 <adnap> Gilly: I guess I'm just going to make my rect :: Complex a -> (Int, Int) -> [Complex a] function instead.
00:34:12 <Gilly> adnap: so yea, your program won't be able to go through every point in the unit square in finite time, which is not very surprising :)
00:35:16 <adnap> I guess I'll call it grid to make it sound more discrete.
00:35:31 <Gilly> heh, yea
00:50:51 * hackagebot SoccerFun 0.2.1 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.2.1 (JanRochel)
01:25:02 * hackagebot SoccerFun 0.3 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.3 (JanRochel)
01:34:04 * hackagebot SoccerFun 0.3.1 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.3.1 (JanRochel)
01:36:10 <earthy> soccerfun for haskell! schweet. ;)
01:39:05 * hackagebot todos 0.3 - Easy-to-use TODOs manager.  http://hackage.haskell.org/package/todos-0.3 (IlyaPortnov)
01:41:42 <MiggyX> okay, I have a new project that I'd like to write in Haskell - bearing in mind I'm still a beginner :)  Basically, I have a binary file with fixed size message. I need to calculate the hash for each message and see if there are any duplicates.  Should that be reasonably easy?
01:42:30 <Saizan> yep
01:43:00 <MiggyX> sweet, thanks :)
01:43:06 * hackagebot iteratee-mtl 0.5.0.0 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-mtl-0.5.0.0 (JohnLato)
01:43:33 <Saizan> you probably want to use bytestring to read the data in, and there are a few libs that provide hash functions
01:46:29 <MiggyX> Saizan: sounds good. In Python I'd just use a dictionary to track things - no idea how to handle state in Haskell yet 
01:46:36 <MiggyX> fortunately my copy of RWH arrived this morning :D
01:47:33 <Saizan> oh, well, there's Data.Map that's the standard immutable dictionary, also bytestring-trie which should be faster
01:47:47 <Saizan> when you said hash i started thinking of md5 or similar
01:50:34 <MiggyX> Saizan: Actually I do :)  Basically there should be two occurrences of each message. At the end of the file,  I want to know which messages only occurred once
01:51:38 <kmc> MiggyX, don't think of it as state.  think of it as passing a new parameter in a recursive call
01:52:13 <kmc> when you say «fact 0 = 1; fact n = n * fact (n-1)», is n 'state'?
01:52:32 <MiggyX> kmc: no, I guess not
01:52:34 <kmc> in fact, all the much-hyped State monad provides is syntactic sugar for this sort of thing
01:52:49 <kmc> that's unlike the state in IO and ST and STM, which are real in-place memory updates
01:53:08 <kmc> MiggyX, i mean, it *is* state in a sense.  but that's not the useful perspective
01:53:24 <kmc> i quite often use foldr with Data.Map.insert
01:53:38 <kmc> to build a map with a bunch of insertions
01:54:35 <pelotom> State seems mostly useful as a teaching exercise
01:55:03 <MiggyX> Yeah, so I wouldn't start off with say a dictionary for storing it all in - the state would be done in the functions but only as needed - ultimately I would probably end up with just a list 
01:55:56 <Saizan> kmc: foldl', i hope?
01:56:10 <kmc> hmm
01:56:18 <kmc> yes Saizan, you're right
01:56:23 <kmc> i usually use foldl'
01:56:30 <kmc> though i found out that forcing a map to whnf doesn't force all its values
01:56:51 <kmc> MiggyX, yeah, you can make a list of hashes, then check for duplicates
01:56:53 <Saizan> no, only the spine
01:57:36 <MiggyX> and I expect the check for duplicates would be a separate function, pretty much unrelated to the one that creates the hashes - which in turn would be separate from the function that actually pulls in the messages
02:00:06 <arcatan> is hlint supposed to fail when checking files that use quasiquoting?
02:00:23 <arcatan> fail as in eat all my memory
02:00:53 <dcoutts_> arcatan: seems unlikely it's deliberate :-) email the maintainer
02:04:42 <rejeep> Hey, can I tell QuickCheck to only test with positive numbers?
02:06:30 <kmc> \n -> n > 0 ==> f n
02:07:41 <kmc> or make a newtype for positive numbers and write an Arbitrary instance
02:07:52 <rejeep> kmc: Do I specify that on the property or when I call the quickCheck function?
02:08:37 <kmc> property
02:11:12 <rejeep> kmc: Can you give me a simple example? I don't understand how to use it...
02:12:55 <aristid> @pl \n -> n > 0 ==> f n
02:12:55 <lambdabot> ap (>) ((0 ==>) . f)
02:13:10 <aristid> @pl \n -> (n > 0) ==> f n
02:13:10 <lambdabot> liftM2 (==>) (> 0) f
02:17:58 <Yacoby> Uh, a style question: Is this sort of thing a good way to write code or not? (I haven't read any real life Haskell, so am a bit lost when it comes to "what is a good idea")
02:17:59 <Yacoby> contains n h = or $ map (prefix n) $ map (\x -> drop x h) [0.. length h]
02:20:12 <aristid> this is rather inefficient: map (\x -> drop x h) [0.. length h]
02:20:32 <aristid> > let h = "abcdefg" in map (\x -> drop x h) [0.. length h]
02:20:33 <lambdabot>   ["abcdefg","bcdefg","cdefg","defg","efg","fg","g",""]
02:20:43 <aristid> > tails "abcdefg"
02:20:43 <lambdabot>   ["abcdefg","bcdefg","cdefg","defg","efg","fg","g",""]
02:21:00 <aristid> Yacoby: plus, tails is a built-in function that does the same (efficiently)
02:21:27 <aristid> :t or
02:21:28 <lambdabot> [Bool] -> Bool
02:21:31 <aristid> :t any
02:21:32 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
02:22:04 <aristid> Yacoby: instead of or . map (prefix n) you can use any (prefix n)
02:22:10 <Yacoby> ah, ok yes
02:22:31 <aristid> so the code would become contains n = any (prefix n) . tails
02:22:36 <Yacoby> I see how that could significantly improve things
02:22:36 <aristid> :t isPrefixOf
02:22:37 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
02:23:08 <aristid> Yacoby: if prefix is a function you wrote yourself, be aware that isPrefixOf might do the same thing (perhaps different argument order)
02:23:54 <Yacoby> I wrote prefix myself, however it is a requirement I use it. (The joys of Uni)
02:24:04 <aristid> ok
02:24:40 <aristid> Yacoby: then you maybe should keep your code stupid, so the Uni will not complain that you asked for help :P
02:26:31 <Yacoby> It is fine to work with other people, as it doesn't count towards my final mark
02:26:38 <Azrael_> Hi guys, quick question about GHCi:
02:26:43 <sm> after port install libsdl_gfx, cabal install SDL-gfx says SDL_gfx lib not found. What's going on here ? http://gist.github.com/648726
02:26:57 <aristid> Yacoby: ah, great.
02:26:57 <Azrael_> If you do :s +s then you get the time and space usage of each command.
02:27:20 <Azrael_> However, if you do the same in Hugs, you get the number of reductions instead of the actual time, which I think is far more useful.
02:27:25 <Azrael_> Is there any way to do this in GHCi?
02:27:45 <aristid> @pl contains n = any (prefix n) . tails
02:27:46 <lambdabot> contains = (. tails) . any . prefix
02:27:58 <quicksilver> Azrael_: No. GHCi is not a reduction machine.
02:28:07 <quicksilver> Azrael_: so it doesn't have a useful way of counting reductions.
02:28:12 <Azrael_> I see.
02:28:18 <aristid> :t any . prefix
02:28:19 <lambdabot> Not in scope: `prefix'
02:28:27 <aristid> :t any . isPrefixOf
02:28:28 <lambdabot> forall a. (Eq a) => [a] -> [[a]] -> Bool
02:28:46 <quicksilver> sm: your paste is a bit snipped? The messages from port install don't look like libsdl_gfx *actuall* got installed.
02:29:33 <sm> quicksilver: I think just because it's already installed
02:29:35 <quicksilver> sm: assuming the paste is a bit snipped, use port contents libsdl_gfx to see if libSDL_gfx got installed
02:30:01 <quicksilver> perhaps it does into a subdir and you need another extra-lib-dir
02:30:25 <sm> port contents shows /opt/local/lib/libSDL_gfx.a etc.. no subdir apparent
02:30:34 <quicksilver> including the .so ?
02:30:57 <sm> there's no .so, just .a, .la., .dylib
02:31:04 <quicksilver> ah, yes, .dylib on OSX.
02:31:18 <sm> so it looks fine >:|
02:31:27 <quicksilver> you need to see the full configure log to see what the error was
02:31:40 <sm> ok
02:31:51 <quicksilver> the error that caused "checking for SDL_initFramerate in -lSDL_gfx... no"
02:33:01 <kmc> Yacoby, not that (map f . map g) = map (f . g)
02:33:24 <sm> quicksilver: thanks, this is helpful
02:33:40 <kmc> note that*
02:35:43 <Yacoby> kmc: I found it more clear if it was split, (Quite probably just me not being able to easily wrap my mind around map in more complex situations).
02:37:17 <Yacoby> but I suppose just using one map does reduce the line clutter a lot
02:39:29 <zmyrgel> hi, could someone explain what the commented haskell function on line 79 do: http://clojure.pastebin.com/Wbm1vXmy
02:40:07 <zmyrgel> I'm trying to convert the Hughes lazy gametree example to clojure but I'm new to both languages so it's hard
02:40:28 <tomberek> zmyrgel: one sec
02:41:32 <tomberek> erg, sorry
02:43:20 <Entroacceptor> zmyrgel: I think it makes a list consisting of one element
02:43:27 <Kaidelong> zmyrgel: looking over the paper, cons l nil is the same as [l]. So it's just saying that if you have "maximize' [l]" you get a result [l]
02:43:40 <Kaidelong> a trivial base case, basically
02:43:53 <Entroacceptor> :t cons
02:43:54 <lambdabot> Not in scope: `cons'
02:44:03 <Kaidelong> :t (:)
02:44:04 <lambdabot> forall a. a -> [a] -> [a]
02:44:24 <Kaidelong> l:[] would be cons l nil
02:44:53 <sm> quicksilver: my config log.. http://gist.github.com/648734 . When I do that gcc test by hand adding -L/opt/local/lib, it works
02:44:57 <Entroacceptor> there is no function 'cons'??
02:45:10 <Kaidelong> there is
02:45:16 <Kaidelong> it's the : operator
02:45:28 <Kaidelong> in haskell it's considered more natural because you can go x:y:z:[]
02:45:45 <Kaidelong> as opposed to (cons x (cons y (cons z nil)))
02:46:16 <sm> I guess hackage package configure scripts don't know about cabal's --extra-*-dirs options, so you have to also set LD_LIBRARY_PATH ?
02:46:33 <zmyrgel> I meant the whole function stuff starting from the line 79, the syntax of multiple = starting on 80 is confusing me
02:46:44 <dcoutts_> sm: yeah, SDL-gfx is using a configure script which does not know about that
02:47:15 <zmyrgel> the line 79 line just catches the base case where the nodes subtree is empty, if I'm not mistaken
02:47:22 <ski> zmyrgel : they're rewriting the body .. probably the last one is the one that is supposed to be used in the final version
02:47:51 * sm tries prepending LD_LIBRARY_PATH=/opt/local/lib , no joy
02:48:39 <zmyrgel> ski: so ignore all previous and just use the last one as function body
02:48:48 <ski> i think so
02:48:59 <zmyrgel> ok
02:49:31 <zmyrgel> It's pretty hard to convert the code when you don't have good skills in either of them :)
02:49:50 <ski> hm, or maybe they later want to rewrite former definitions into
02:50:06 <ski>   minimise = min . minimise'
02:50:16 <ski>   maximise = max . maximise'
02:50:51 <ski> (otherwise i don't really see why to define the "primed" versions of those)
02:51:30 <quicksilver> sm: LD_LIBRARY_PATH is something else entirely.
02:51:33 <quicksilver> I think.
02:51:39 <quicksilver> that's the runtime-loader path
02:51:42 <quicksilver> not the compile time one
02:51:51 <sm> I guess you're right
02:51:55 <sm> this worked: LDFLAGS=-L/opt/local/lib cabal install SDL-gfx
02:52:07 <sm> VICTORY
02:52:31 * hackagebot SoccerFun 0.3.2 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.3.2 (JanRochel)
02:52:36 <dcoutts_> sm: perhaps you can file a ticket in the cabal trac. It would make sense for cabal to pass this on to configure scripts.
02:52:58 <sm> ok dcoutts_
02:53:09 <dcoutts_> ta
02:53:54 <ski> (.. or maybe they only want to do that for one of the two operations ?)
02:55:10 <ski> zmyrgel : btw, in `mapmin', i think it would be good to use `let' to only compute `(min nums)' once
02:58:19 <sm> thanks all
02:59:38 <zmyrgel> ski: sure, and some other places same fixes could be done
02:59:59 <zmyrgel> I'm planning to get it to work somehow first and then tweak it for better
03:03:01 <zmyrgel> Am I correct to assume that "highfirst (node n sub) = ..." is function definition for highfirst with 2 parameters, n and sub, representing fields in node?
03:05:44 <quicksilver> zmyrgel: no.
03:06:02 <quicksilver> zmyrgel: in fact, that is illegal syntax.
03:06:19 <quicksilver> "highfirst (Node n sub) = ...", on the other hand - capital N is very important.
03:06:27 <zmyrgel> quicksilver: well, the paper is from 1984 or about that time...
03:06:33 <quicksilver> that is a function definiton for highfirst with *one* parameter (not two).
03:06:46 <quicksilver> but that parameter is matched against the constructor 'Node'
03:06:56 <quicksilver> and 'Node' is a constructor with two parameters.
03:08:10 <dcoutts_> sm: thanks (re ticket #754)
03:08:47 <zmyrgel> so highfirst gets one parameter, a Node and Node needs two parameters?
03:09:00 <quicksilver> right.
03:09:13 <quicksilver> Node is a constructor (possibly just one constructor of many for some particular type)
03:09:20 <quicksilver> and it's a constructor which take two parameters
03:09:28 <sm> np, I just sent another
03:09:32 <quicksilver> and we have named those parameters 'n' and 'sub' for future reference.
03:10:09 <MiggyX> How easy is it to parse logs in Haskell? As in beginner, intermediate or advanced? :)
03:10:22 <zmyrgel> ok
03:10:39 <earthy> miggyx: beginner
03:10:49 <MiggyX> earthy: I was hoping you'd say that ;)
03:11:13 <earthy> although it does kinda depend on the type of log and the kind of information you want out of it
03:12:05 <MiggyX> earthy: Basically there are two "streams" being written to the log file - each message in the stream is one line. I need to make sure that the two streams are the same basically
03:12:34 <ski> hm, maybe WhyFP uses Miranda ?
03:15:05 <MiggyX> earthy: I can do it pretty easily in Python, but I was hoping to give it a try in Haskell first :)
03:15:08 <earthy> but basically it starts out as   do { log <- readFile "logfile"; let loglines = lines log; let distinguished = map distinguish loglines; let untangled = unzip distinguished ; let (leftstream,rightstream) = (catMaybes . fst $ untangled, catMaybes . snd $ untangled); }
03:15:29 <_mpu> can somebody correct this :
03:15:32 <earthy> ofcourse, there's nicer ways of writing this, but I've tried to keep it simple. :)
03:15:50 <sm> boy, it can get tedious chasing down the c libs for the haskell SDL packages
03:16:05 <_mpu> nums s = (0,s) : concat [ reads x | x <- map snd (nums s) ]
03:16:06 <MiggyX> earthy: thanks :)
03:16:12 <earthy> distinguish should put the line in either the first of the second element of a tuple, wrapped in a maybe
03:16:48 <earthy> note that this is untested, typed off the top of my head and still doesn't check the streams against eachother
03:16:55 <earthy> it's just the 'parsing' bit. ;)
03:17:37 <MiggyX> earthy: I'm not sure if I should write it first in Python to truly "understand" the problem - or skip that and just try to do it in Haskell
03:17:47 <MiggyX> I'm not sure if writing it in Python first would be helpful or not to the process
03:17:55 <ski> @type partitionEithers
03:17:56 <lambdabot> forall a b. [Either a b] -> ([a], [b])
03:18:14 <ski> it would be nicer to use that, instead of `unzip'
03:20:00 <MiggyX> each message has a keyword so that should be fairly easy to do
03:20:22 <ski> @type let nums s = (0,s) : concat [ reads x | x <- map snd (nums s) ] in nums
03:20:23 <lambdabot> forall a. (Read a, Num a) => String -> [(a, String)]
03:20:25 <Jafet> liftM2 (==) stream1 stream2 . lines
03:21:04 <_mpu> ski: I found an ugly way to make it work
03:21:25 <ski> _mpu : i'm still wondering what it supposed to be for ..
03:21:29 <_mpu> nums s = (0,s) : (takeWhile (/= []) $ concat [ reads x | x <- map snd (nums s) ])
03:21:39 <_mpu> ski: just try it :)
03:22:24 <ski> i can see it (sortof) reads successive numbers from a string
03:22:28 <_mpu> I would like to make un function doing reads as much as possible
03:22:56 <ski> but i think the interaction with this and a nondeterministic `reads' can be strange
03:22:56 <_mpu> in one line
03:23:11 <_mpu> reads is ok
03:23:20 <_mpu> it does not fail
03:23:20 <ski> well, and you don't get an empty list, at the end
03:24:09 <_mpu> nums s = (0,s) : (concat $ takeWhile (/= []) [ reads x | x <- map snd (nums s) ])
03:24:28 <_mpu> there was a mistake in what I've said
03:24:42 <_mpu> this is ugly
03:24:46 <ski> your thing is similar to
03:24:46 <ski> > fix $ \ns -> 1 : [2*n + i | n <- ns , i <- [0,1]]
03:24:47 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:25:04 <ski> it is traversing an infinite tree, breadth-first
03:25:27 <ski> (but when the tree actually is finite, you get bottom as a tail, instead of the empty list)
03:25:33 <_mpu> fix ?
03:25:38 <ski> @src fix
03:25:38 <lambdabot> fix f = let x = f x in x
03:25:51 <ski> > let ns = 1 : [2*n + i | n <- ns , i <- [0,1]]  in  ns  -- the same thing
03:25:52 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:26:36 <Jafet> > unfoldr (\s -> case reads s of [(n, s')] -> Just (n, s'); _ -> Nothing) "[1,2,3][4,5,6][7,8][][9]" :: [[Int]]
03:26:37 <lambdabot>   [[1,2,3],[4,5,6],[7,8],[],[9]]
03:27:09 <ski> (btw, `concat [ reads x | x <- map snd (nums s) ]' is the same as `[ p | x <- map snd (nums s) , p <- reads x]' ..)
03:27:21 <ski> Jafet : that's cheating, since it doesn't allow branching
03:27:45 <Jafet> I don't even know what game we're playing now
03:28:14 * ski is possibly playing a different game to _mpu ..
03:30:31 <Jafet> > let nums s = (0,s) : (concat $ takeWhile (/= []) [ reads x | x <- map snd (nums s) ]) in nums "1 2 3 4 5"
03:30:32 <lambdabot>   [(0,"1 2 3 4 5"),(1," 2 3 4 5"),(2," 3 4 5"),(3," 4 5"),(4," 5"),(5,"")]
03:30:58 <_mpu> why reads returns a list and not a maybe ?
03:31:43 <ski> for ambiguous parses, afaiu
03:31:49 * hackagebot SoccerFun 0.3.3 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.3.3 (JanRochel)
03:32:07 <ski> (but i don't think this is used in any of the standard instances)
03:32:35 <Jafet> To make this rhyme: http://www.willamette.edu/~fruehr/haskell/seuss.html
03:36:28 <mklappstuhl> hey
03:37:39 <mklappstuhl> again a gitit problem: i looks like my files are cached – but this is disabled in my.conf 
03:39:24 <mklappstuhl> there is also no cache folder inside my gitit dir
03:39:48 * ski idly wonders whether mklappstuhl is in the right channel
03:40:57 <mklappstuhl> ski: gitit is based on haskell and I know that there are some people here who use it... or at least tried/used it
03:41:09 <mklappstuhl> s/based on/written in/
03:41:26 <ski> ok, i see
03:41:45 * ski knows almost nothing about git-related things
03:49:26 <mklappstuhl> ski: you solved my problem :D I almost forgot about the git backend :D
03:58:53 <ski> mklappstuhl : eh .. huh ?
03:59:06 * ski looks confused
04:09:20 <mklappstuhl> ski: i had to commit to reflect the changes in gitit... which makes kind of sense :P
04:15:25 * ski still understands nothing about it, or how it was solved ..
04:18:03 * hackagebot SoccerFun 0.3.4 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.3.4 (JanRochel)
04:21:08 * hackagebot Chart 0.14 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-0.14 (TimDocker)
04:52:02 <danr> danten: hello
04:52:41 <danten> hello dan
04:52:50 <alex404> Can anyone tell me why summing a very long list of 1s takes about twice as long as summing a very long vector of 1s?
04:53:02 <Palmik> Hi guys. Would it be correct to say, that eta-reduction is just application of partialy applied functions or currying?
04:53:30 <FauxFaux> alex404: Because the list is twice the size in memory?  Just a guess.
04:53:31 <quicksilver> alex404: memory pressure, I should thing.
04:53:39 <quicksilver> the list will be much bigger in memory
04:53:49 <quicksilver> and you have more indirections to follow as you traverse it too.
04:54:06 <quicksilver> it depends a bit if the long lists/vectors are strictly constructed in advance
04:54:12 <quicksilver> or fused/constructed lazily.
04:54:33 <alex404> All I'm doing is sum $ replicate n 1
04:54:44 <alex404> I'm just doing some speed testing
04:54:51 <Saizan> compiling with -O2 ?
04:54:54 <alex404> Yah
04:55:11 <quicksilver> ok, well replicate n 1 is a good producor, for both lists and vectors
04:55:14 <alex404> The GC does spend about 5 times as much time with the list as the vector
04:55:22 <quicksilver> so fusion can potentially kick in in both cases
04:55:39 <quicksilver> I'm not sure what fusion means with vectors
04:55:46 <Saizan> seems with the list something doesn't get fused
04:55:56 <quicksilver> but possiblye sum $ replicate n 1 will compile to a tight loop which doesn't allocate anything at all
04:56:06 <quicksilver> Saizan: I don't think lists ever fuse to zero allocation.
04:56:21 <quicksilver> Saizan: I think you always make and destroy at least one (:)-cell per iteration
04:56:27 <quicksilver> you hope it's at most one
04:56:40 <quicksilver> instead of multiple if you have a chain of maps (or whatever)
04:56:42 <quicksilver> I'm not sure though.
04:56:58 <quicksilver> a single (:)-cell of an [Int] is 24 bytes, though.
04:57:01 <quicksilver> including the Int.
04:57:03 <Jafet> @pl sum $ replicate n 1
04:57:03 <lambdabot> sum (replicate n 1)
04:57:19 <quicksilver> whereas the vector is perhaps vanishign entirely.
04:57:36 <Saizan> foldr f z (build g) = g f z <- sounds like it could get to no (:)-cell
04:57:36 <alex404> But why is the GC spending 5 times as long then?
04:58:02 <aristid> @pl \n -> sum $ replicate n 1
04:58:02 <lambdabot> sum . flip replicate 1
04:58:06 <Jafet> Because if what quicksilver says is true, it has to allocate n conses and GC them
04:58:27 <quicksilver> the other theory is that it's the Int box that's being GCed
04:58:37 <quicksilver> and the vector code manages to persaude GHC to unbox the Ints entirely
04:58:39 <alex404> Here's the code: http://codepad.org/TB9zYjZa
04:58:49 <quicksilver> whereas the list code has n boxes to GC.
04:58:49 <alex404> and the profiling: http://codepad.org/JoybPgYw
04:58:52 <alex404> For anyone interested
04:58:54 <Saizan> you could check with ghc-core
04:59:05 <quicksilver> you'll need to examine the core if you want to find out
04:59:17 <alex404> I have not reached that level of haskell fu. Perhaps it is time...
04:59:30 <quicksilver> GHC-fu really.
04:59:40 <alex404> Indeed.
04:59:42 <quicksilver> what is "n" ?
04:59:46 <Jafet> For most purposes, they are equivalent
04:59:50 <quicksilver> for that example
05:00:00 <quicksilver> zurely not 24
05:00:02 <quicksilver> 10^24 ?
05:00:06 <quicksilver> 2^24?
05:00:17 <alex404> yes
05:00:19 <alex404> 2^24
05:00:23 * hackagebot timeplot 0.1.9 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.1.9 (EugeneKirpichov)
05:00:25 <alex404> 2^n 1s
05:00:57 <quicksilver> so you have net 56 bytes alloced per list element
05:01:33 <quicksilver> that is, approx 48 for the list case and 8 for the vector case
05:01:42 <quicksilver> that sounds, to me, like a (:)-cell in the list case
05:01:53 <quicksilver> and (just) an Int-box in the vector case
05:02:13 <Jafet> > sum $ replicate (2^24) 1
05:02:17 <lambdabot>   mueval-core: Time limit exceeded
05:02:20 <Jafet> > sum $ replicate (2^20) 1
05:02:24 <lambdabot>   mueval-core: Time limit exceeded
05:02:44 <alex404> So, what is a cons cell? Just the pair of a pointer and a boxed value?
05:02:45 <Jafet> > sum $ replicate (2^16) 1 -- these timings aren't relevant, but let's pretend
05:02:47 <lambdabot>   65536
05:02:54 <alex404> (sorry for my newbishness)
05:03:02 <Jafet> > sum $ (replicate (2^16) 1 :: [!Int])
05:03:03 <lambdabot>   Unexpected strictness annotation: !GHC.Types.Int
05:03:22 <quicksilver> alex404: indirection word, constructor word, head-pointer word, tail-pointer word
05:03:47 <quicksilver> so four words excluding the actual payload
05:04:00 <alex404> Ahh... so it's not *so* light weight
05:04:02 <quicksilver> the payload itself would be two more (indirection + actual data)
05:04:16 <quicksilver> so, 6 words per cell
05:04:45 <quicksilver> not sure I have that 100% right, but it's close.
05:05:00 <quicksilver> I can't remember if everything is a machine word (in the 64-bit case) or if some are not.
05:05:01 <zygoloid> i see 1 fold/build fusion rule firing for sum $ replicate n 1, but the result is not fused at all
05:05:23 <alex404> And what were you saying, you think that fusion can reduce it to a single boxed value, or you can hope for at best a single cons cell?
05:05:59 <zygoloid> GHC 6.12.1 does not fuse it.
05:06:23 <alex404> Ahh, so a lot of the performance here is a lack of fusion?
05:06:37 <alex404> GHC 7 might catch it?
05:06:44 <quicksilver> "fusion" as an abstract remove all allocation in principle.
05:06:55 <quicksilver> I thought I understood that GHC's implementation of list fusion never does
05:07:04 <quicksilver> the best you ever get is a tight loop with one cell per iteration.
05:07:23 <quicksilver> however, I thougth the vector fusion implementation could, in fact, remove all allocation.
05:07:24 * hackagebot AspectAG 0.3 - Attribute Grammars in the form of an EDSL  http://hackage.haskell.org/package/AspectAG-0.3 (MarcosViera)
05:07:28 <quicksilver> I could be wrong on both counts ;)
05:07:33 <alex404> Heh
05:08:17 <alex404> But should there be much performance difference, assuming you're right on both counts, if fusion fully kicks in with both?
05:08:32 <Saizan> you could try with stream fusion for lists :)
05:08:45 <Saizan> there's a package on hackage
05:08:48 <alex404> Indeed
05:08:58 <alex404> I'll test it now...
05:10:30 <sm> with YACPong, cabal install --extra-lib-dirs=/opt/local/lib says /Users/simon/.cabal/lib/SDL-0.6.2/ghc-6.12.3/HSSDL-0.6.2.o: unknown symbol `_SDL_FreeSurface'. That symbol is defined in /opt/local/lib/libSDL-1.2.0.dylib. Any ideas ?
05:13:23 <zygoloid> well, here's the core: http://hpaste.org/paste/40916/uncored#p40917
05:14:10 <zygoloid> i'm not really sure what the genericDrop argument is there for...
05:15:26 <quicksilver> zygoloid: what is this "uncored" ?
05:16:04 <zygoloid> quicksilver: just a by-hand conversion from core back to haskell syntax
05:16:09 <quicksilver> ah
05:16:13 <quicksilver> I thought it was something automatic
05:16:14 <quicksilver> it's nice.
05:16:20 <zygoloid> i wish :)
05:18:06 <alex404> So for reasons unknown stream runs more slowly than both vector and standard list.
05:18:35 <alex404> Looks like that library is getting a bit old, anyway...
05:18:54 <alex404> More than a year since an update. It's dead to me.
05:19:29 <quicksilver> fusion is fragile to compiler version changes :(
05:19:32 <ManateeLazyCat> Wow, Chart package is pretty cool. (http://dockerz.net/twd/HaskellCharts)
05:19:52 <alex404> Isn't this stuff being effectively hard coded into GHC now anyway?
05:20:21 <alex404> I remember a buzzword for GHC 7 is better stream fusion.
05:21:29 * hackagebot mtl 2.0.0.0 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.0.0.0 (RossPaterson)
05:21:31 * hackagebot timeplot 0.2.0 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.0 (EugeneKirpichov)
05:27:39 <spetrea> what was that site ? haskellers.org ? pretty cool idea
05:36:32 * hackagebot timeplot 0.2.1 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.1 (EugeneKirpichov)
06:25:53 <Nebukadneza> heho
06:26:18 <Nebukadneza> if i have a function like h = let z=foo, do something, where z=bar (foo!=bar) - which one (of let and where) binds "harder"?
06:26:51 <Botje> i /think/ the let
06:27:09 <mornfall> Well, easy to try out...
06:27:12 <Nebukadneza> okay :P where could you look something like that up?
06:27:14 <Nebukadneza> mornfall: mh, right :P
06:27:19 <mornfall> But I put my bets on the let.
06:29:28 <Botje> Nebukadneza: it's the let.
06:29:36 <Botje> TIAS is sometimes the fastest way :)
06:29:40 <Botje> (try it and see)
06:29:53 <arcatan> i guess the report specifies it somewhere?
07:03:13 <EvanR-work> so i just got a system mail with error output from the haskell cron job
07:03:25 <EvanR-work> it said, segmentation fault
07:03:32 <EvanR-work> thats it
07:03:33 <EvanR-work> :S
07:03:53 <EvanR-work> must be something in an ffi lib... is there a way to instrument it to dump more info on segfault
07:04:20 <EvanR-work> first time in months...
07:09:55 <napping> Was it system F, or F-omega which can type any strongly-normalizing term in lambda calculus?
07:10:09 <dolio> Neither.
07:10:14 <tab> EvanR-work: remove the RLIMIT_CORE limit in your cron job, so you have a coredump ?
07:10:40 <napping> neither? I'm pretty sure there was some type system like that
07:11:53 <dolio> What do you mean "any strongly-normalizing term in lambda calculus"? Any term in the untyped lambda calculus?
07:12:05 <napping> any closed term whose evaluation is strongly normalizing
07:12:25 <dolio> Any closed term of the untyped lambda calculus?
07:12:39 <napping> yes
07:12:57 <dolio> Then no.
07:13:10 <dolio> Intersection types can do it.
07:13:37 <napping> pretty trivially, yes?
07:13:44 <Philippa> remind me: can't they type fix, too?
07:14:07 <dolio> I don't recall.
07:14:42 <Philippa> I /think/ there's a specific intersection system that types only the strongly-normalising terms. Inference is, of course, thoroughly undecidable
07:14:52 <dolio> Right.
07:14:59 <napping> yes, that's exactly the sort of thing I was looking for
07:15:10 <napping> typeability equivalent to strongly-normalizing, with undecidable inference
07:15:26 <dolio> That sounds like intersection typing, then.
07:15:39 <napping> someone got to talking about Rice's Theorem and type systems, but was insufficiently imaginative
07:17:00 <Philippa> yeah, Rice's Theorem is irrelevant in the presence of types
07:17:01 <napping> "Strong Normalization and Typability with Intersection Types" claims to be exactly what I want
07:17:08 <Philippa> a typed term is not a function
07:17:16 <Philippa> it's just something you can project a function from
07:17:41 <napping> well, there is that gap between extensional and intensional properties
07:18:10 <napping> but you might very well start with an untyped language, and wonder how far you can go in capturing extensional properties with a type system
07:18:33 <napping> In practice it's not worth the effort to allow nonsense in dead code that you would need to attain completeness
07:18:59 <napping> (nor clear that it is sufficiently possible in general, with the halting problem)
07:20:25 <roconnor> [10:14] <Philippa> I /think/ there's a specific intersection system that types only the strongly-normalising terms. Inference is, of course, thoroughly undecidable
07:20:33 <roconnor> I may be misundersanding but taht seems unlikely
07:20:44 <napping> Koenig's theorem
07:21:04 <napping> then just intersect every term over all the types it can actually be used at at any point in the derivation
07:21:12 <napping> something like that, anyway
07:21:13 <roconnor> It would be like having a proof system that can prove that every turning machine that does terminate in fact terminates
07:21:44 <napping> we're talking about closed terms, not functions with arguments
07:22:04 <napping> so, an evaluation trace is enough of a "proof system" for turing machines
07:22:11 <roconnor> napping: I'm talking about turning machines run on no input
07:22:20 <roconnor> same difference
07:22:23 <napping> yes, then it terminates iff the evaluation trace shows that it terminates
07:22:33 <roconnor> oh wait
07:22:35 <roconnor> you are right
07:22:40 <dolio> There are lots of papers on the subject.
07:22:47 <roconnor> I was talking about machines with inputs
07:22:54 <napping> yeah, that's much harder
07:23:12 <roconnor> that is an understatement :)
07:23:42 <roconnor> ya proving that a machine halts on no input should be trivial.
07:24:11 <roconnor> (if it does halt on no input)
07:24:45 <dolio> It should?
07:24:52 <benmachine> run it, wait?
07:24:59 <napping> semidecidable
07:25:46 <roconnor> dolio: at works the proof consists of a number n, saying how long to run the machine.
07:26:18 <roconnor> dolio: to chech the proof you run the machine for n steps to see if it halts before then.
07:26:41 <roconnor> if it halts you are happy.  If it doesn't, the aledged proof wasn't.
07:26:53 <dolio> How does this make the proof trivial?
07:27:03 <dolio> Or do you mean checking the proof?
07:27:30 <napping> deciding that there is no such proof is hard
07:27:32 <roconnor> dolio: oh ya, to find the proof you run the machine and note how many steps it took
07:27:37 <frerich5> I guess the scientific culture in the Haskell community really shows when you compare discussions in other channels (which are like "How do I print a file" or "Why does this socket connection close all of a sudden?") and this one ("Is this NP?" or "foldr . map . x is NP for all delta-equivalent problems in the quixbux domain") :-}
07:27:47 <roconnor> dolio: you will always find your proof this way
07:28:13 <roconnor> dolio: as opposed to the case where you want to prove a machine halts on all inputs (in the case it does halt on all input)
07:28:17 <napping> roconnor: if you want arguments, people will usually let you get away with sprinking in "provably" in the appropriate places
07:28:23 <roconnor> dolio: for that problem no such technique is possible.
07:29:13 <roconnor> napping: the problem is that proof is always relative to a proof system, and people never state the proof system they are considering.  It causes a lot of confusion.
07:29:31 <napping> ZFC is usually pretty standard
07:29:42 <roconnor> but in this case, essentally any proof system has this property (called Sigma_1-complete)
07:30:14 <dolio> roconnor: I guess that's true. I don't usually think about the halting problem as "does machine M halt on all inputs", though.
07:30:41 <dolio> It's either "does M halt on I" or "does M halt on \epsilon". And the two are equivalent.
07:30:50 <roconnor> napping: when arguing proof theory I'm pretty sure these people have some autonomous consistency (or even soundness) extension of ZFC in mind.
07:30:50 <napping> dolio: the hard part of the Halting problem is answering no, not answering yes
07:30:55 <dolio> Right.
07:31:03 <pumpkin> omg halting in #haksell
07:31:14 <pumpkin> just use spoon
07:31:14 <roconnor> pumpkin: it isn't very unusual
07:31:18 <pumpkin> halts = isNothing . spoon
07:31:24 <pumpkin> duh
07:31:32 <dolio> "Does M halt on all inputs" is the same as "does every machine from this infinite set halt on \epsilon."
07:31:38 <pumpkin> oh actually isJust . spoon
07:32:57 <roconnor> dolio: hmm, I usualy think of the halting problem as halting on all inputs
07:33:05 <roconnor> let's see what wikipedia says
07:33:27 <roconnor> dolio: looks like you are right
07:33:40 <napping> hmm, the standard halting problem has fixed input, or no input
07:33:46 <napping> that's why it's semidecidable
07:33:47 <dolio> I guess that means that "total" is a stronger guarantee.
07:33:47 <roconnor> dolio: well 
07:33:54 <roconnor> except that it goes on to say
07:34:04 <roconnor> oh wait
07:34:06 <roconnor> never mind
07:34:08 <napping> if you ask if a program halts on all inputs, that's not even semidecidable
07:34:08 <roconnor> dolio: you are right
07:35:19 <roconnor> so how does this magical type system work to type all halting lambda terms?
07:35:26 <roconnor> it must be bizzare
07:35:52 <roconnor> because it takes a program p and it will type it on some numeric inputs n but not other numeric inputs m
07:36:05 <frustrated> can someone help me with the installation of wxHaskell on windows 7?
07:36:08 <roconnor> and it has to do arbirarily hard computation to decide if it is type correct or not
07:36:19 <dolio> The paper I have on it is A Bargain for Intersection Types.
07:36:41 <napping> it works over untyped lambda calculus
07:36:45 <dolio> roconnor: Typeability by intersection types isn't decidable.
07:36:58 <napping> so numeric arguments would be church encoded or something
07:37:10 <napping> and different numbers have different shapes, to get different types
07:37:31 <roconnor> dolio: what does having an undecidable type system mean?
07:37:49 <napping> roconnor: usually, checking is decidable but inference is not
07:38:02 <roconnor> napping: sure, so how does type checking work here
07:38:08 <frustrated> can someone help me with the installation of wxHaskell on windows 7?
07:38:08 <roconnor> I have a well typed function f
07:38:14 <companion_cube> roconnor, it means that you're not sure your compiler will succedd in infering types
07:38:14 <roconnor> and a well typed number n
07:38:29 <roconnor> so now I want to see if f(n) is well types
07:38:33 <napping> and then you might need to make a completely different derivation for that
07:38:46 <roconnor> so what, I have to annotate the hell out if it effecitively giving a trace of the entire computation?
07:38:56 <napping> in simple types, do you want (\x -> x) to be (a -> a), or ((a -> a) -> (a -> a)), etc
07:39:14 <napping> yeah, the deriviation comes from the structure of the computation
07:39:34 <roconnor> napping: so type checking effectively happens at run time?
07:39:44 <napping> checking is not a problem
07:39:46 <roconnor> or even worse, past run time
07:39:56 <napping> it's a simple decidable structural thing
07:39:58 <roconnor> because I had to run the function first for me to write it's type
07:40:10 <napping> who knows how you come up with type derivations
07:40:30 <roconnor> hmm
07:40:32 <napping> that doesn't mean you can't check the resulting type statically
07:40:32 <roconnor> okay
07:40:36 <roconnor> it's true
07:40:49 <napping> it just means it's hard to take an untyped term, and figure out a type for it
07:40:53 <roconnor> for some function it may be more clear that f(n) eventaully terminates without having to run it
07:41:10 <napping> not necessarily
07:41:25 <napping> but there is a way to turn your evaluation trace (or tree, if you want strong normalization) into a type derivation
07:41:36 <napping> and decidable static checking if type derivations are sensible
07:42:38 <Maxdamantus> @pl f 5 = 42; f a = 2*a
07:42:39 <lambdabot> (line 1, column 9):
07:42:39 <lambdabot> unexpected ";"
07:42:39 <lambdabot> expecting digit, variable, "(", operator or end of input
07:42:54 <roconnor> napping: the lambda calculus is weakly normalizing, so there is no need for a tree AFAIK.
07:43:26 <roconnor> (also Coq isn't strongly normalizing :)
07:43:39 <zygoloid> @pl \a -> if a == 5 then 42 else 2 * a
07:43:40 <lambdabot> ap (flip if' 42 . (5 ==)) (2 *)
07:44:04 <zygoloid> @pl \a -> [2*a, 42] !! fromEnum (a == 5)
07:44:04 <lambdabot> ap ((!!) . (: [42]) . (2 *)) (fromEnum . (5 ==))
07:45:18 <Maxdamantus> @pl \a -> if a == 21 then 41 eles 2*a
07:45:18 <lambdabot> (line 1, column 34):
07:45:18 <lambdabot> unexpected end of input
07:45:18 <lambdabot> expecting letter or digit, variable, "(", operator, "*", "/", "`quot`", "`rem`", "`div`", "`mod`", ":%", "%" or "else"
07:45:29 <Maxdamantus> @pl \a -> if a == 21 then 41 else 2*a
07:45:29 <lambdabot> ap (flip if' 41 . (21 ==)) (2 *)
07:46:13 <dolio> napping: The paper I mentioned, A Bargain for Intersection Types, appears to have an example of a normalizing term that isn't typeable in F_omega.
07:48:08 <dolio> Although it does mention that all beta-normal forms are typeable in F.
07:49:30 <napping> that's considerably weaker
07:49:54 <dolio> Yes.
07:49:55 <napping> intersection types seem less compositional in practice, though
07:50:11 <Maxdamantus> @pl \a -> if a == 21 then 42 else 2*a
07:50:11 <lambdabot> ap (flip if' 42 . (21 ==)) (2 *)
07:51:58 <quicksilver> win 22
07:52:00 <quicksilver> :(
07:53:00 <pumpkin> proof that even quicksilver is capable of failure
07:53:01 <pumpkin> once.
07:56:49 <napping> There's a paper "Principal Typings for all Normalizable Terms ..." that presents a system that types the set of terms that terminate under normal-order reduction
07:57:55 <dolio> I guess this paper doesn't prove that only normalizing terms have intersection types.
07:58:12 <dolio> Just that all do.
08:00:49 <triyo> Going through a chapter on Monads in LearnYouAHaskell book, I came across this example:  Right 3 >>= \x -> return (x + 100) :: Either String Int
08:01:03 <triyo> It gives an error: No instance for (Monad (Either String))
08:01:37 <dolio> There's no instance in the base library.
08:01:52 <dolio> You'd need to import Control.Monad.Error from mtl, or one of its replacements.
08:02:42 <triyo> dolio: thank you. Confusing error though
08:03:47 <triyo> As it doesn't get to the actual cause
08:04:06 <triyo> well at least for newbie like myself.
08:05:18 <roconnor> dolio: did taht change recently?
08:05:20 <Twey> triyo: Yes it does
08:05:38 <quicksilver> roconnor: no
08:05:49 <triyo> Twey: I'm not follwong?
08:05:49 <quicksilver> roconnor: the instance isn't haskell98, so it's never been in the base set
08:05:51 <Twey> GHC error messages have many flaws, but that one tells you exactly what's going on
08:06:16 <Twey> You've used ‘Either String’ as if it's a monad (with the >>= and return), but there's no Monad instance for it
08:06:36 <roconnor> quicksilver: what am I thinking of?
08:06:38 <triyo> Right, it tells me there is no instance and that I should perhaps create my own
08:07:01 <Twey> Right
08:07:06 <quicksilver> roconnor: not sure :)
08:07:06 <Twey> That is the actual cause
08:07:14 <Twey> What more did you want it to say?  :þ
08:07:34 <roconnor> some instance was moved into or out of base in ghc 7
08:07:38 <triyo> sure, however, Error instance exists :)
08:07:49 <triyo> its should be able read my mind ;-D
08:07:54 <triyo> just kidding
08:08:02 <Twey> Heh
08:08:08 <Twey> Soon, maybe :þ
08:27:10 <roconnor> Heh, category theories have this way of sapping all motivation out of mathematics.
08:35:11 <osaunders> @pl f (x, y) g = (g x, g y)
08:35:11 <lambdabot> f = uncurry ((. flip id) . ap . ((,) .) . flip id)
08:35:22 <osaunders> There has to be a better way than that!
08:35:52 <osaunders> > (+1) <$> (1,1)
08:35:53 <lambdabot>   (1,2)
08:36:14 <pumpkin> osaunders: yeah there is
08:36:25 <pumpkin> :t let f (x, y) g = (g x, g y) in f
08:36:25 <lambdabot> forall t t1. (t, t) -> (t -> t1) -> (t1, t1)
08:36:43 <quicksilver> (g *** g) (x,y)
08:36:46 <osaunders> > (1,1) <*> (+1)
08:36:47 <lambdabot>   The section `GHC.Num.+ 1' takes one argument,
08:36:47 <lambdabot>  but its type `(t, a)' has none
08:37:03 <osaunders> :t (***)
08:37:04 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:37:05 <pumpkin> if you're willing to be slightly less flexible, you can do join (***)
08:37:09 <quicksilver> if you want to avoid duplicating the g, you can do "(join (***) g)"
08:37:11 <pumpkin> or flip (join (***))
08:37:27 <quicksilver> > (+1) (1,1)
08:37:28 <lambdabot>   (2,2)
08:37:36 <quicksilver> ^^ however, this is a trick and not what it seems
08:37:55 <osaunders> quicksilver: Lambdabot specific.
08:38:29 <osaunders> *** scares me. I'm a ways off arrows yet.
08:38:47 <pumpkin> don't think of the Arrow aspect of it
08:38:57 <quicksilver> osaunders: it's not that it's lambdabot specific.
08:39:02 <quicksilver> it's that it is a trick.
08:39:09 <pumpkin> think of it as (x -> y) -> (x' -> y') -> (x, x') -> (y, y')
08:39:12 <quicksilver> that (+1) is really (+(1,1))
08:39:20 <quicksilver> it's using a fromIntegral instance for tuples
08:39:29 <quicksilver> (that is, a Num instance for tuples)
08:39:33 <osaunders> quicksilver: Yes.
08:39:39 <quicksilver> so it's not a general g.
08:39:42 <ziman> > (1,2) * (3,4)
08:39:43 <lambdabot>   (3,8)
08:39:52 <quicksilver> > (++"hi") ("foo","bar")
08:39:52 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:39:53 <lambdabot>         against inferred ty...
08:39:58 <quicksilver> ^^ you'd want that to work
08:40:01 <quicksilver> if it was general.
08:40:06 <osaunders> Yes
08:40:11 <Twey> > ((+ 5), (* 2)) *** (3, 4)
08:40:12 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
08:40:12 <lambdabot>    arising from a use of `Control...
08:40:20 <Twey> Err.  xD
08:40:25 <Twey> > ((+ 5) *** (* 2)) (3, 4)
08:40:25 <lambdabot>   (8,8)
08:40:38 <quicksilver> > ( (++"hi") *** ("lo"++) )   ( "tee", "cal" )
08:40:38 <osaunders> pumpkin: What do the primes represent in that type sig?
08:40:42 <lambdabot>   mueval-core: Time limit exceeded
08:40:48 <quicksilver> !
08:40:50 <quicksilver> > ( (++"hi") *** ("lo"++) )   ( "tee", "cal" )
08:40:52 <lambdabot>   ("teehi","local")
08:41:01 <pumpkin> osaunders: just names cause I couldn't think of better ones
08:41:34 <Twey> I think perhaps it would be clearer to say: (x -> x') -> (y -> y') -> (x, y) -> (x', y')
08:41:41 <Twey> But maybe that's just me
08:41:51 <osaunders> Twey: Yeah, that makes a bit more sense to me.
08:41:55 <osaunders> OK, I get it now :-)
08:42:14 <pumpkin> is there a Reader + Writer + ST monad? I know of RWST but isn't that Reader, Writer, State (Transformer) ?
08:42:18 <osaunders> Do a tuple is an arrow, what other things are arrows?
08:42:20 <osaunders> *So a
08:42:36 <Twey> osaunders: Tuples aren't arrows
08:42:41 <Twey> osaunders: Functions are arrows
08:43:04 <osaunders> Ah, OK.
08:43:08 <osaunders> Nevermind then.
08:43:12 <pumpkin> maybe I just want a STOut monad actually
08:43:16 <pumpkin> very stout
08:43:30 <Twey> The fact that they work on tuples is kind of an implementation detail based on how our arrow implementation represents multiple values
08:43:34 <Twey> (well, on pairs)
08:43:56 <benmachine> pumpkin: RWST is reader writer state transformer yes
08:44:09 <pumpkin> okay
08:44:15 <benmachine> i.e. the T version of RWS
08:44:16 <pumpkin> so I'm going to write me a convenience ST + Writer monad
08:44:24 <pumpkin> cause I think it would be useful
08:44:35 <benmachine> RWST r w () ST
08:44:38 <benmachine> <_<
08:44:42 <pumpkin> ew no
08:45:18 <pumpkin> sometimes people want the ability to have mutability and output
08:45:48 <pumpkin> it seems like it'd be nice to have a monad that gives you that without being IO
08:46:01 <pumpkin> then you can run it and ignore the output
08:46:07 <pumpkin> or filter it lazily
08:52:48 <Maxdamantus> 			\state{Two}{One}{Open} & \arrow & \state{Two}{One}{Open} & \arrow & \state{Two}{One}{Closed}
08:52:51 <Maxdamantus> 		\end{tabular} \\
08:52:55 <Maxdamantus> ugh, didn't meant to do that
08:56:58 * Maddas steals Maxdamantus' secret research results and publishes them under his own name
09:00:30 <Jafet> latex looks so pointed.
09:01:12 <Twey> It's hideous.  :-\
09:01:33 <Twey> If only there were something nicer that produced comparable output quality.
09:01:43 * Maxdamantus wonders how that even got into his primary buffer
09:01:49 <Twey> Haha
09:02:29 <Twey> pumpkin: I think having more specific effect monads is a large, ongoing problem.
09:03:09 <pumpkin> Twey: I think the combination I mentioned is common enough to warrant its own monad though
09:03:28 <pumpkin> maybe not
09:04:33 <Twey> I think if we break them all up as much as possible and have a nice way of composing them back into whatever's needed, it should be solved automatically… maybe warranting an alias
09:04:53 <pumpkin> yeah, but we don't have a nice way of composing them without sticking lifts into various ugly places
09:05:52 <Twey> Also, if we take meat from flying pigs, we can classify it as fowl and make people feel healthier when eating it
09:06:12 <jmcarthur> Twey: the pandoc package has a pretty handy markdown2pdf executable
09:06:21 <jmcarthur> using latex under the hood
09:06:32 <jmcarthur> and you can also make it use your own latex template and stuff
09:06:38 <jmcarthur> so that's a start :)
09:06:42 * hackagebot yesod 0.6.0.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.6.0.1 (MichaelSnoyman)
09:07:25 <jmcarthur> still supports latex math and stuff, too
09:13:25 <sodium70mg> What are the '?'s in the kind: (->) :: ?? -> ? -> * 
09:13:44 <benmachine> sodium70mg: GHC-specific and probably not too much of an issue
09:13:53 <benmachine> you can think of them as * for most purposes
09:14:10 <sodium70mg> benmachine: Okay, thanks. Just wondering.
09:14:13 <benmachine> but I think ?? includes unboxed types and ? includes unboxed tuples as well
09:14:18 <pumpkin> sodium70mg: specifically, they're kinds that include *, but also include unboxed types
09:14:20 <pumpkin> yeah
09:14:25 <benmachine> (so ? is a superset of ?? is a superset of *)
09:15:53 <shapr> So last night's knitting & type theory meeting went well, had seven attendees.
09:15:56 <shapr> including jmcarthur
09:16:41 <jmcarthur> lol
09:17:25 <shapr> jmcarthur: So, what's different about type equality in epigram vs Sheard's Omega vs Haskell?
09:19:01 <jmcarthur> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.99.7722
09:22:42 <shapr> jmcarthur: I really want to hang out with Conor McBride for a few days... drink beer and learn some Epigram and dependently typed goodness.
09:22:51 <jmcarthur> me too
09:23:08 <shapr> We should figure out a way to fly him to Huntsville for a week.
09:23:12 <jmcarthur> heh
09:23:17 <shapr> We must have a conference.
09:23:47 <pumpkin> he does hang out on IRC, just not in here
09:23:57 <pumpkin> IRC is better than nothing, at least :)
09:24:02 <EvanR-work> council of doom
09:28:04 <EvanR-work> you both live in huntsville?
09:28:46 <merijn> shapr: When you find out how it works you can tell me ;p
09:29:02 <shapr> merijn: How what works? Type equality in Epigram vs Haskell vs Omega?
09:29:07 <shapr> EvanR-work: Yah, wanna show up?
09:29:08 <merijn> Epigram
09:29:31 <merijn> I'm reading The View from the Left now, but apparently I'm quite a bit out of my league still
09:29:44 <EvanR-work> shapr: maybe, i know nothing of dependent types
09:30:47 <jmcarthur> merijn: usually things like this are just very dense and often require more concentration and time than i am willing to devote at the time. that's when i declare it "over my head" even if that is not literally true, and i think this same situation applies to most people that call things over their heads
09:31:00 <shapr> merijn: There's an Epigram irc channel.
09:31:30 <merijn> jmcarthur: Well, I meant more that my knowledge is not sufficient for the paper yet. I only started reading up on type theory a month back or so
09:31:56 <merijn> And the paper seems to rely a lot on Luo's UTT which is only mentioned in a book which I can't seem to find :\
09:32:03 <jmcarthur> merijn: ah
09:33:03 <jmcarthur> dude, what would be awesome is if i had a script that could automatically locate and download the papers cited by papers i already have, recursively, and then build a visual to show what relies on what so i can read the papers in a logical order
09:33:19 <jmcarthur> and of course skip any that i think are already "below me" because i'm egotistical like that
09:33:48 <merijn> Mendeley.com scraping + bayesian categorization/machine learning :p
09:34:25 <jmcarthur> hmm this is neat
09:35:24 <shapr> I'm sure lispy knows all about this.
09:36:46 <Philippa> heh, often the ones that're "below you" have useful insights somewhere
09:37:22 <EvanR-work> Philippa: sorry, your remark is below me
09:37:25 <jmcarthur> Philippa: hence the quotation marks :)
09:38:13 <jmcarthur> i have found that i typically get *more* from papers that i initially thought were too basic to be interesting because they still manage to make some sort of connection between apparently disparate ideas
09:38:14 <monochrom> citeseer already locates the cited papers
09:38:26 <Philippa> EvanCarroll: below me!
09:38:48 <merijn> There seems to be a correlation between time spend in #haskell and my "to read" queue of papers >.>
09:39:01 <jmcarthur> my queue as well
09:39:13 <Philippa> naturally. The question is, is it only linear, or are you in real trouble?
09:39:20 <Jafet> So make a program to kick you off IRC when the queue grows large
09:39:34 <merijn> Jafet: I'd be offline 24/7 >.>
09:39:46 <jmcarthur> it's never linear for me
09:40:04 <merijn> Papers require references to grok, which require references to grok...
09:40:12 <merijn> It's an endless game of yak shaving :p
09:40:15 <jmcarthur> the citations at the end of each paper i queue up tends to lead to more papers, so my queue continues to grow while i'm trying to shrink it
09:40:47 <monochrom> the purpose of school is to bootstrap your paper reading
09:41:09 <mwc> monochrom: ain't that the truth
09:41:46 <monochrom> take consolation that there has only been a bounded number of papers written in the past.
09:42:00 <jmcarthur> When you're up to your neck in alligators, it's easy to forget that the initial objective was to drain the swamp.
09:42:14 <monochrom> perhaps also take consolation that while papers could cite Boole's book, they wouldn't.
09:42:22 <jmcarthur> (i never get around to reading the papers i intended to read in the first place)
09:45:10 <merijn> I like the analogy between papers and alligators :p
09:45:45 <Rembane> Ergo, burn the books?
09:49:19 <nominolo> > ((+1) `mappend` (*2)) 4
09:49:20 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:49:20 <lambdabot>    `Data.Monoid.Monoid a'
09:49:20 <lambdabot>  ...
09:49:46 <nominolo> > ((+1) `mappend` (*2) :: Int -> Int) 4 
09:49:47 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
09:49:47 <lambdabot>    arising from a use of...
09:50:29 <pumpkin> > Sum 1 + Sum 2
09:50:30 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum t))
09:50:30 <lambdabot>    arising from a use of ...
09:50:45 <nominolo> > Sum 1 `mappend` Sum 2
09:50:46 <lambdabot>   Sum {getSum = 3}
09:51:02 <joeyh> I'm writing an xarg-like thing, anyone know how to get at sysconf ARG_MAX from haskell?
09:56:10 <jmcarthur> it's a shame that some of our newtype wrappers don't have more type class instances
09:56:30 <sbrg> joeyh: tried ltrace getconf?
09:57:42 <joeyh> sbrg: it calls sysconf() of course, but I don't see any interface to it in eg, the unix libraries
09:57:50 <sbrg> joeyh: oh
09:58:15 <joeyh> actually, System.Posix.User has one, but not exported :)
09:58:28 <sbrg> Hah, that's convenient
09:58:42 <joeyh> and with only numeric parameters
09:59:16 <joeyh> I guess I could just use the "try a huge exec and back off if it fails" method
09:59:31 <sbrg> joeyh: hmm
10:00:03 <EvanR-work> not exporting stuff!
10:00:06 <EvanR-work> nice
10:00:34 <joeyh> or just the "run xargs -0" approach :)
10:03:34 <joeyh> actually, there's enough complexity around ARG_MAX (like linux reporting a lower value than modern kernels really support etc) that just using xargs is probably smart..
10:06:31 <shapr> EvanR-work: Are you in Huntsville/Alabama?
10:07:27 <EvanR-work> shapr: baton rouge
10:07:52 <shapr> EvanR-work: LA?
10:08:16 <shapr> That would be quite a drive... but if we had a conference...
10:09:07 <EvanR-work> its nothing compared to driving to warsaw or wherever they normally meet
10:10:56 <shapr> EvanR-work: Truly, driving to Poland would take much longer.
10:11:59 <EvanR-work> but what do i know about haskell
10:14:15 <EvanR-work> hmmmmmm is there a way to do an IO action for element of a Data.Set
10:14:24 <EvanR-work> you could convert to a list and forM_
10:14:38 <EvanR-work> but is there a more direct way
10:15:15 <shapr> EvanR-work: Do you know anyone else in the southeast USA who might be up for a conference?
10:15:25 <EvanR-work> im the only haskeller i know
10:15:33 <shapr> I'm getting that disorganizational urge again.
10:15:50 <EvanR-work> in RL
10:16:53 <manateeUser> Hi all. :)
10:19:06 * hackagebot hsXenCtrl 0.1.1 - FFI bindings to the Xen Control library.  http://hackage.haskell.org/package/hsXenCtrl-0.1.1 (ThomasDuBuisson)
10:22:32 <jmcarthur> shapr: whatever happened to all those people interested in humbug or whatever it was called?
10:22:51 <jmcarthur> shapr: there's a user's group that meets in chattanooga i think
10:22:55 <shapr> oh really?
10:24:47 <roconnor> [_]
10:24:48 <jmcarthur> can't find it now
10:25:09 <EvanR-work> Just _
10:26:18 <jmcarthur> shapr: mightybyte might be able to remind me about them. he's from around chattanooga iirc, although he doesn't live there now
10:26:47 <jmcarthur> i think he's the one that made me aware of the group in the first place
10:29:29 <jmcarthur> shapr: there appears to be a group in miami...
10:30:02 <jmcarthur> Subtropical Haskell Interest Group :P
10:30:12 <jmcarthur> SHIG. nice
10:32:20 <aristid> jmcarthur: that's where it all started: http://upload.wikimedia.org/wikipedia/commons/8/84/MiamiAvenue1896.jpg
10:34:10 <Twey> Shame it's not an activity group
10:34:11 <shapr> jmcarthur: Cool, I'll see if I can track him down.
10:35:05 <EvanR-work> lunch
10:37:04 <byorgey> EvanR-work: use Data.Traversable
10:37:37 <byorgey> oh, wait, Set isn't an instance of Traversable, hmm
10:37:48 <osaunders> @src fix
10:37:48 <lambdabot> fix f = let x = f x in x
10:38:31 <byorgey> oh, becaues of the Ord constraint
10:38:37 <byorgey> the traversal could destroy internal invariants
10:38:37 <osaunders> @pl f g x = g (g x)
10:38:37 <lambdabot> f = join (.)
10:39:51 <byorgey> EvanR-work: ah, but you can use traverse_  from Data.Foldable
10:46:53 * lispy1 wonders who's in charge here
10:47:05 <lispy1> President Haskell?
10:48:29 <fryguybob> @vixen Who's in charge?
10:48:30 <lambdabot> no
10:50:55 <newsham> ?faq can haskell be in charge?
10:50:55 <lambdabot> The answer is: Yes! Haskell can do that.
10:51:47 --- mode: ChanServ set +o lispy1
10:52:08 <lispy1> shapr: heh
10:52:15 * shapr grins
10:52:28 <shapr> lispy1: look to me like YOU are in charge here!
10:52:42 * lispy1 stands more pompously
10:52:44 <youngbull> @pl \(i,xs)→ (i,y:xs)
10:52:44 <lambdabot> (line 1, column 9):
10:52:44 <lambdabot> unexpected "\134"
10:52:45 <lambdabot> expecting pattern or "->"
10:53:01 <fryguybob> @vixen Is lispy1 in charge?
10:53:02 <lambdabot> first you tell me.
10:53:05 <youngbull> \(i,xs)->(i,y:xs)
10:53:13 <youngbull> @pl \(i,xs)->(i,y:xs)
10:53:14 <lambdabot> second (y :)
10:53:15 <lispy1> ?vixen I'm in charge here
10:53:15 <lambdabot> i understand
10:54:46 <youngbull> @vixen Is lispy1 in charge?
10:54:47 <lambdabot> no
10:54:55 <Twey> Haha
10:54:59 <djahandarie> byorgey, got a darcs repo setup for your type family code so I can start abusing it yet? ;)
10:55:01 <Twey> @vixen Who is in charge?
10:55:01 <lambdabot> i'll hafta plead the fifth on that one.
10:55:12 <youngbull> Ha, thats funny!!!
10:55:21 * osaunders <3s QuickCheck
10:56:11 <youngbull> @vixen can Twey be in charge?
10:56:11 <lambdabot> nevermind about that
10:56:25 <Twey> Heh.  That bad, huh.
10:57:04 <osaunders> @vixen Is Twey a good leader?
10:57:04 <lambdabot> good? not great?
10:57:14 <aristid> @vixen Is Twey a great leader?
10:57:15 <lambdabot> great is like a very good good
10:57:21 <djahandarie> Last time Twey was in charge, he was trying to talk to people but no one could parse anything he was saying because it was using all sorts of peculiar unicode characters.
10:57:35 <Twey> >.>
10:57:36 <aristid> djahandarie: łøł
10:57:51 <youngbull> @vixen Is waffles great?
10:57:52 <lambdabot> can't do much better than great
10:58:16 <osaunders> <3 waffles
10:58:26 <osaunders> Even the word is good.
10:59:10 <youngbull> @vixen does bot love waffles?
10:59:10 <lambdabot> like those damn porn spam bots?
10:59:18 <aristid> @vixen Is waffles in charge?
10:59:19 <lambdabot> no
10:59:30 <aristid> @vixen Only Twey is in charge?
10:59:30 <lambdabot> i'll hafta plead the fifth on that one.
10:59:56 <youngbull> @vixen lambdabot >>= waffles?
10:59:56 <lambdabot> no
10:59:59 <youngbull> damn
10:59:59 <osaunders> lol
11:00:08 <djahandarie> That's what > is for ;)
11:00:35 <youngbull> vixen is not my friend today... I am going home!
11:01:15 <osaunders> There's a spider in my code: ((***))
11:04:31 <alpounet> haha
11:05:49 <mwc> Ding dong the witch is dead
11:06:08 <mwc> which old witch you ask?
11:06:13 <mwc> mtl-1
11:06:20 <alej> i was wondering which witch, yes
11:06:40 <mwc> mtl-2 is finally compatible with transformers :D
11:06:55 <djahandarie> :)
11:07:16 <mwc> http://hackage.haskell.org/package/mtl-2.0.0.0
11:08:54 <tibbe> mwc: what's the migration path?
11:08:58 <tibbe> mwc: is there a wiki?
11:09:14 * tibbe thinks there should be
11:09:51 <sproingie> which old witch?  the wiki witch.
11:09:57 <mwc> tibbe: AFAICT, it's just a drop in replacement
11:10:11 <mwc> provides the mtl-1.x interface on top of transformers
11:11:27 <mwc> the migration path is probably to port away from mtl entirely towards monads-fd, or even monads-tf if you don't mind type families
11:12:05 <tibbe> mwc: so I'm not supposed to change my mtl-1.0 constraint to mtl-2.0?
11:13:31 <mwc> tibbe: I'm not sure of the official policy, but I'd test to make sure any mtl < 2 constraint is necessary
11:13:40 <sproingie> i imagine you would change it if you weren't inclined to change your code to work with monads-*
11:13:48 <sproingie> lack of time or gumption or whatever
11:14:08 <mwc> common, is monads-fd really that different from mtl?
11:14:35 <mwc> I haven't tried to port any code, but it looks fairly similar in interface
11:14:44 <mwc> I can understand not wanting to port to monads-tf
11:14:44 <sm> I think that word does not mean what you think it means!
11:15:42 <djahandarie> monads-tf is nicer than monads-fd internally
11:15:51 <mwc> mtl and monads-tf are both fundep based and provide the same monads, I can't imagine porting from mtl State to monad-tf state would be that hard
11:16:12 <djahandarie> mwc, you mean monads-fd I imagine
11:16:14 <mwc> djahandarie: a lot of people have to avoid type families to be more compatible with older GHCs or other compilers
11:16:23 <mwc> djahandarie: indeed I do
11:16:51 <djahandarie> And yeah, screw those people. Update your compiler :)
11:17:20 <sproingie> i like the idea type families but i've always liked C++ partial template specialization too
11:17:23 <mwc> I can see wanting to remain on 6.10 on a server or something
11:17:32 <sproingie> never actually used type families in anger tho
11:20:15 <sm> so, who's itching to make some haskell games ?
11:20:22 * sproingie
11:20:48 <alej> i am
11:20:59 <alej> i've been writing a small 3d library/engine 
11:21:02 <sproingie> i've wanted to write a Dwarf Fortress clone in haskell for ages
11:21:24 <alej> I used a StdGen for particles, and I tihnk that's slowing it down. Though I haven't profiled yet.
11:21:25 <roconnor> sm: I'm itching to write a geometric algebra library
11:21:27 <sproingie> maybe i'll start with an artificial life thing tho.  anyone remember a screensaver called Primordial Life?
11:21:59 <sproingie> alej: the builtin Random is godawful slow
11:22:20 <alej> sproingie: that's what I hear. I'm hoping when I plug in mersenne-prime-64 or whatever it's called, it will be awesome
11:22:28 <alej> i'm also not even sure what FPS I was trying to drive it at
11:22:55 <alej> but 500 particles was fine, and then 1000 saw some slowdown at whatever FPS I was running, fairly high
11:23:02 <alej> i should probably display that info...
11:23:06 <sm> #haskell-game died, maybe this is the place to be
11:23:25 <EvanR-work> byorgey: ah Foldable
11:23:31 <sproingie> might not be due to Stdgen.  you'd want to profile it with a null renderer
11:23:44 <alej> come again?
11:24:16 <alej> whenever i create a particle i need...i think 7 random doubles
11:24:28 <sm> http://hackage.haskell.org/package/FunGEn has the worst capitalisation ever, I am thinking of fixing that with a new package
11:24:30 <alej> and then they die/are recreated every so often
11:24:38 <sproingie> you want to find out if your slowdown comes from your scene generation or your rendering pass
11:24:47 <alej> ah yes
11:24:50 <sproingie> that many randoms per particle, it does sound like the scene generation tho
11:25:11 <EvanR-work> StdGen i heard isnt 'very fast'
11:25:27 <sproingie> my opengl knowledge is bare minimum, i only know immediate mode stuff
11:25:30 <alej> according to one of the mersenne packages, it's incredibly slow. might be a little biased, though
11:25:40 <EvanR-work> screw mersenne
11:25:49 <EvanR-work> its the php of rngs
11:25:50 <alej> whatver, i just want something from hackage
11:25:51 <sproingie> the api for vbo's and whatnot is painful compared to direct3d
11:26:13 <alej> EvanR-work is there a better generator on hackage that I should use?
11:26:15 <EvanR-work> alej: try mwc-random
11:26:41 <alej> sure ok
11:26:44 <alej> why not
11:26:47 <sproingie> i hear mwc-random is good.  mersenne is overrated, you would only use that if you needed a RNG with a ridiculously long period
11:26:47 <alej> claims to be even faster
11:27:01 <EvanR-work> sproingie: mwc is ridiculously
11:27:07 <alej> all i did was ctrl+F on hackage for random, and i must have hit it too many times and skipped over mwc
11:27:30 <sproingie> but hey mersenne at least beats lrand48
11:27:41 <sm> any votes for the current best available game written in haskell ?
11:27:46 <aristid> random-fu offers a generalised interface to mwc AND mersenne and others
11:27:48 <sproingie> i wonder if that's what System.Random uses
11:27:54 <EvanR-work> i dont the m19937 period is even comparable
11:28:17 <sproingie> sm: frag, if you can get it to work
11:28:22 <alej> random-fu you say
11:28:57 <sm> I count things that are cabal installable on at least one platform as available, I think
11:28:59 <sproingie> i managed to steal some decent stuff out of frag, like texture loading
11:29:45 <sm> looking at the list, I think it's Monadius
11:30:29 <EvanR-work> im wondering what the state of RandomGen is... seems unpopular
11:30:43 <roconnor> I found raincat ... a little disappointing.
11:30:57 <roconnor> maybe my hopes were too high
11:31:48 <pumpkin> why doesn't ST have an Applicative instance?
11:31:58 * sm tries that cabal version of raincat
11:32:35 <sm> yay, worked out of the box
11:32:53 <sm> probably because I spent the night figuring out SDL libs...
11:34:39 <alej> ugh, SDL. haven't been able to get that work properly on osx, but i dont remember what the problem was
11:34:50 <alej> i know i tried it a few months ago though
11:35:01 <EvanR-work> first things first dont use 1.3
11:35:14 <sm> alej: me too. I finally got it 
11:35:21 <EvanR-work> next things next, i wish i knew what the issues were with osx, we get a lot of reports about that
11:35:37 <alej> sm what did you have to do?
11:35:41 <sproingie> wish there were sfml bindings for haskell
11:35:44 <EvanR-work> i dont know if sdl is actually buggy or if osx is just hard
11:35:53 <sproingie> er haskell bindings for sfml 
11:36:07 <sproingie> sdl is buggier than a rain forest outhouse
11:36:07 <EvanR-work> sfml is crap
11:36:35 <sm> well I have fresh osx-sdl knowledge to dump.. let's see..
11:36:45 <sproingie> well 1.3 is anyway.  1.2 is a decent GLUT replacement.  as a 2d API it's wretched
11:36:59 <sproingie> i think even allegro can use 3d accelleration on its framebuffer now
11:37:02 <EvanR-work> annoying that everyone wants to use 1.3 now, its not beta or anything
11:37:08 <EvanR-work> bad marketting i think
11:37:16 <sproingie> 1.3 will never get out of beta
11:37:25 <EvanR-work> into?
11:37:31 <sproingie> into something stable
11:37:48 <EvanR-work> 1.3 isnt even in beta
11:38:02 <sproingie> as a finished library it's basically vapor
11:38:13 <EvanR-work> *no one should use 1.3*
11:38:20 <EvanR-work> unless they want to develop it
11:38:42 <EvanR-work> many people think bigger version numbers are better and thats what you get for it
11:39:05 <EvanR-work> we need to build our app on the version 56 numbers higher than the current stable because we dont want to be left behind in 26 years
11:39:27 <sproingie> the bigger version number means rendering to an opengl framebuffer instead of a pure RAM one
11:39:40 <EvanR-work> or, you mean, having a separate opengl mode
11:40:00 <EvanR-work> the better idea is to just use opengl
11:40:00 <sproingie> no, as in having an opengl frame buffer, which runs circles around software-only framebuffers
11:40:30 <sproingie> and i agree, using an opengl engine is probably better
11:40:30 <EvanR-work> sproingie: rephrasing yet again... as opposed to having sdl graphics mode + opengl graphics mode, you want one mode
11:41:03 <sproingie> i want the 2d graphics mode to render to an opengl framebuffer the way sfml and directdraw does
11:41:21 <sproingie> it's about a hojillion times faster and takes less CPU
11:41:27 <EvanR-work> just use opengl
11:42:07 <sproingie> is what i did.  raw opengl isnt all that appealing but any decent engine can do point sprites
11:42:20 <EvanR-work> theres no need for an engine if all you want is sprites
11:43:01 <sproingie> for me, sprites and a pathed camera animation
11:43:04 <EvanR-work> the impedance mismatch may be the fact that im assuming C
11:43:23 <EvanR-work> the haskell sdl bindings arent great
11:44:31 <sproingie> i only ever got them working through my package manager.  never succeeded in building them
11:44:47 <sproingie> the gl bindings on the other hand, smooth as buttah
11:44:57 <EvanR-work> i probably had more luck since i do a lot of sdl work in c
11:46:45 <alej> i feel so dirty programming opengl in haskell though
11:46:47 <alej> the code is so ugly
11:46:55 <alej> a million x $= y
11:47:23 <alej> not too many ways around that, though
11:47:34 <sproingie> eh, it's a stateful API, not much you can do about that
11:47:38 <EvanR-work> without having done it, seems like youd want to do all the opengl on the otherside of the ffi and pass marshalled vectors
11:47:43 <shapr> zygoloid: I love your domain name, it just occurred to me independently... 
11:47:48 <alej> sproingie: right
11:47:54 <sproingie> confine it to a manageable chunk and it's all good
11:48:03 <alej> sproingie: i'm puttint it all in its own thread
11:48:22 <EvanR-work> communication with forkOS thread is.....
11:48:25 <shapr> zygoloid: http://control.monad.st/ is just awesome :-)
11:48:34 <alej> actually that brings me to another problem i had
11:48:38 <alej> i'm compiling without -threaded
11:48:41 <alej> and using forkIO
11:48:51 <EvanR-work> i didnt think you could safely use opengl in a forkIO
11:48:53 <sm> alej, EvanR-work: here's some notes from my osx sdl setup: http://gist.github.com/649681
11:48:55 <alej> if I use -threaded, then my application is..unresponsive
11:49:13 <pumpkin> zygoloid: I hate that domain name because I can't search for control.monad.st in chrome anymore
11:49:14 <pumpkin> :P
11:50:04 <sproingie> hit ctrl-k before you search
11:50:21 <jmcarthur> opengl as a spec is not thread safe, and there is of course a ton of un thread safe things you can do, but most *practical* uses of opengl are actually pretty thread safe in current implementations
11:50:32 <sproingie> or just start it with ? i guess.  i'm used to ^K from firefox
11:50:42 <alej> i'm only ever making opengl calls from one thread
11:50:50 <jmcarthur> e.g. you can load textures in one thread while rendering in another
11:51:08 <sproingie> rendering from multiple threads is ... not wise :)
11:51:11 <mwc> jmcarthur: really, they didn't address thread safety in the newer OpenGL specs? The OpenCL specs state that all retain/release operations on objects are thread safe
11:51:18 <jmcarthur> *rendering* through multiple threads is just dumb, yes
11:51:26 <alej> seems like asking for trouble if you're rendering from multiple threads
11:51:41 <jmcarthur> mwc: i'm pretty sure about that
11:51:47 <jmcarthur> not 100% though
11:51:56 <sproingie> it actually isn't terrible if you're just flipping buffers, but it'll sure be herky-jerky
11:52:09 <sm> syntaxglitch showed a combination of sdl+opengl+graphics-drawingcombinators that seems quite decent.. let each do the part it's good at
11:52:14 <jmcarthur> there isn't much point in doing actual rendering via multiple threads
11:52:24 <sproingie> jmcarthur: it's more like something you'd do accidentally
11:52:32 <jmcarthur> how?
11:52:46 <sproingie> refactor stuff into threads, leave a call to flip in
11:53:03 <jmcarthur> sounds like a bug that would show itself almost immediately
11:53:17 <sproingie> glut in general is definitely not threadsafe
11:53:20 <mwc> with modern opengl, you shouldn't be "rendering" at all in the classic fixed-pipeline sense
11:53:27 <jmcarthur> well that's because glut sucks
11:53:39 <jmcarthur> mwc: well... that's nitpicking
11:53:42 <jmcarthur> you're still rendering
11:53:57 <jmcarthur> it's just not a black box
11:53:57 <mwc> just set up your vertex and texture buffers, load your programs, and there's actually very little work to do in your rendering loop if you're doing it correctly
11:54:23 <sproingie> one of these days i'll actually work with vbo's... still in the "hello world" phase of doing everything in immediate mode
11:54:32 <mwc> as far as updating buffers, that should be safe from multiple threads, since it's just memory access
11:54:33 <EvanR-work> that opengl api move sucked
11:54:34 <jmcarthur> sure, but there is still a piece of your program that you can label "rendering"
11:54:37 <sproingie> oh but hey i graduated to display lists, opengl 1.2 here i come
11:54:48 <EvanR-work> its not an api if it gets more low level, to cope with hardware reality
11:54:54 <mwc> jmcarthur: yeah, but it's reallly more of a "blit memory to GPU" step ;)
11:55:25 <jmcarthur> mwc: well, you also have to load and unload programs and all sorts of stuff for the actual rendering if you are doing a remotely complex scene
11:55:29 <EvanR-work> a generalize gpu assembly language is not an api
11:55:42 <EvanR-work> its like saying x86 is an api to PCs
11:55:49 <jmcarthur> rendering is largely scheduling nowadays
11:56:10 <sm> roconnor, re raincat: it seems a rather beautiful-looking kid's game, but I don't have the patience to figure out how to play it
11:56:18 <jmcarthur> sort by material, front to back, etc.
11:56:19 <sproingie> i never got raincat to compile
11:56:22 <EvanR-work> its not an interface because its super low level, and its not for applications
11:56:24 <mwc> jmcarthur: true of course
11:56:29 <sm> good proof that haskell can make a platformer though
11:56:30 <jmcarthur> a good wrapper API handles much of that for you
11:56:38 <jmcarthur> unfortunately, none of those APIs are open source :(
11:57:01 <jmcarthur> EvanR-work: a low level api is still an api
11:57:12 <EvanR-work> jmcarthur: only if you its used for application programming
11:57:25 <jmcarthur> what programming *isn't* application programming?
11:57:26 <EvanR-work> menuetOS not withstanding
11:57:47 <mwc> jmcarthur: however, the actual rendering loop should mostly be submitting rendering reqs to the GPU by binding buffers and kicking off the draw, so the actual "triangle goes here" stuff should all be out of the rendering loop anyways by this point. It's really only classical OpenGL programs that mix wakling the scene graph with rendering
11:58:08 <EvanR-work> im separating end user applications from system programs, system libraries, and libraries used for applications (which basically the only way you can write a 'modern' opengl application, through a library)
11:58:48 <jmcarthur> mwc: the only major difference in that regard is batching
11:59:20 <pumpkin> if I have a data STWrapper s a = STWrapper (ST s a)
11:59:22 <sm> sproingie: worked for me straight from hackage, after the afore-linked SDL setup work
11:59:32 <jmcarthur> the modern way is not as tightly coupled with scene walking, yes, but i don't think that fundamentaly changes what it is
11:59:35 <pumpkin> how would I write runSTWrapper :: (forall s. STWrapper s a) -> a ?
11:59:36 <sm> EvanR-work: are you on the hsSDL team ? was that info any help ?
11:59:41 <pumpkin> do I have to use the ST internals?
11:59:45 <EvanR-work> sm: no, and i dont have an osx
11:59:50 <EvanR-work> so im basically useless
12:00:01 <jmcarthur> EvanR-work: a lot of people use opengl for applications
12:00:06 <jmcarthur> directly, i mean
12:00:23 <EvanR-work> jmcarthur: i do, but not with fragment programs
12:00:29 <jmcarthur> why not?
12:00:41 <EvanR-work> cost vs benefit?
12:00:46 <EvanR-work> too low level for my high level needs
12:00:55 <Saizan> pumpkin: runSTWrapper :: (forall s. STWrapper s a) -> a; runSTWrapper x = runST (case x of STWrapper m -> m) -- maybe
12:00:58 <jmcarthur> i think the modern pipeline is a lit easier than immediate mode, personally
12:01:01 <jmcarthur> *lot
12:01:13 <EvanR-work> for graphics maybe, but not for applications
12:01:20 <jmcarthur> umm...
12:01:29 <jmcarthur> i guess i'm still missing the distinction
12:01:29 <EvanR-work> its a step in the wrong directly
12:01:31 <EvanR-work> direction
12:01:35 <pumpkin> Saizan: omg magic :)
12:01:36 <pumpkin> thanks
12:01:44 <pumpkin> I guess I can see why that works
12:01:49 <jmcarthur> opengl was never intended to be used by people who don't care to understand how graphics rendering works
12:02:05 <EvanR-work> its like if haskell said, haskell 2 will now require you to write your stuff in typed lambda calculus because of performance reasons
12:02:19 <jmcarthur> no it's not
12:02:22 <jmcarthur> opengl was always low level
12:02:26 <Saizan> pumpkin: it's weird because you've to imagine the type lambdas :)
12:02:33 <pumpkin> yeah
12:02:34 <jmcarthur> by design
12:02:43 <jmcarthur> it was always about performance
12:02:49 <EvanR-work> jmcarthur: the matrix api is easy to use
12:03:17 <jmcarthur> yeah, and the hardware of the time worked pretty similarly to the exposed API
12:03:24 <jmcarthur> the problem isn't that opengl changed, it's that hardware changed
12:03:26 <EvanR-work> great
12:03:37 <EvanR-work> i dont want to rewrite my programs when hardware changes
12:03:42 <jmcarthur> nobody is making you
12:03:46 <jmcarthur> your old stuff still works
12:03:46 <EvanR-work> what is an api for then
12:03:54 <EvanR-work> my new stuff still works
12:04:01 <jmcarthur> an api is certainly not meant to never change
12:04:13 <EvanR-work> eh?
12:04:22 <jmcarthur> you seem to be complaining about change
12:04:28 <EvanR-work> thats part of it
12:04:34 <EvanR-work> i would like programs to always work
12:04:49 <EvanR-work> i dont want time dependent programs
12:04:52 <sproingie> the matrix API is easy.  i dont even see the code.  all i see is blond, readhead, brunette...
12:05:16 <jmcarthur> EvanR-work: so how does this new API make your old programs using the old API not work?
12:05:19 <EvanR-work> by change i guess you mean revision
12:05:26 <EvanR-work> or augmentation
12:05:36 <sproingie> if there's one thing opengl does ridiculously well it's backward compatibility.  it's just broken it out into "profiles" now
12:05:42 <jmcarthur> it's not just augmentation. the classic pipeline is deprecated
12:05:49 <jmcarthur> from core anyway
12:06:01 <EvanR-work> deprecated means dont use it
12:06:24 <sproingie> there's oodles of industrial and medical apps that will continue using the old pipeline
12:06:27 <jmcarthur> no it doesn't
12:07:06 <jmcarthur> deprecated means implementations aren't required to implement it in order to meet the spec *for that version of opengl*. vendors still want to meet the spec for older versions too
12:07:16 <jmcarthur> so your old stuff will still work
12:07:20 <sproingie> good thing it's backward compatible because i've been learning from the red book
12:07:31 <EvanR-work> and theres another thing, people think nvidia must give you the implementation
12:07:37 <alpounet> jmcarthur, i remember you were thinking about a neat graphics library some time ago
12:07:40 <alpounet> how's it going ?
12:07:52 <jmcarthur> brb will answer :)
12:07:56 <EvanR-work> if its really an api there should be a an implementation in terms of the fast new low level thing
12:08:06 <EvanR-work> implementable by anyone
12:08:09 <EvanR-work> but no one does that
12:08:11 <EvanR-work> why?
12:09:32 <EvanR-work> if nvidia gives you a slow one then thats what we must use?
12:12:02 <EvanR-work> jmcarthur: another gripe is none of my video hardware supports shaders
12:12:33 <EvanR-work> so i feel like im not writing supported code
12:15:31 <scan> hello, I have an urgent cabal-related problem...
12:17:14 <scan> i've been trying to build & download packages that use network, but the build for network-2.2.1.* fails permanently... I have now installed manually but when I invoke the cabal download, it tries to build network regardless, though it is already installed
12:17:19 <scan> anyone can help
12:17:35 <gwern> scan: network should not be reinstalled
12:17:42 <gwern> it's one of the core packages, iirc
12:17:47 <gwern> dangerous to reinstall
12:17:58 <scan> why does it try to pull it anyway?
12:17:59 <dcoutts_> gwern: not actually core, but it comes with the platform
12:18:13 <scan> also, i have looked into ghc-pkg and there was not any
12:18:17 <gwern> scan: well, I'd venture that's a symptom of something being broken
12:18:29 <dcoutts_> scan: check you don't accidentally have multiple instances of the same version of the package installed
12:18:36 <gwern> that's what attempts to install core packages like that have usually meant over the past few years, anyway
12:18:38 <scan> i am using my own build of ghc on linux, so no platform
12:18:52 <gwern> dcoutts_: I feel so outdated ~-~
12:19:02 <jmcarthur> EvanR-work: the fix function pipeline is implemented on top of the programmable pipeline already nowadays
12:19:11 <dcoutts_> scan: btw, you can see why cabal wants to reinstall something if you use cabal install blah --dry-run -v
12:19:45 <dcoutts_> scan: it'll say why it wants to reinstall network, it'll probably say that it wants to rebuild it with different versions of its deps
12:19:48 <jmcarthur> EvanR-work: and anybody *could* implement the old on top of the new if they wanted, but there's no point. the old api is no easier to use, honestly, and it's much slower just inherently
12:20:12 <jmcarthur> alpounet: i've been laid off, so i put aside my game dev for a while :(
12:20:14 <dcoutts_> gwern: aye, long time no see
12:20:25 <jmcarthur> alpounet: once i have a job again and can afford to spend time on it i'll get back to it
12:20:26 <scan> it wants to reinstall network because i used a too new parsec package...
12:20:30 <gwern> dcoutts_: presumably you've been too busy to hang out in #haskell as of old
12:20:31 <scan> wtf?
12:20:56 <alex404> If you need a 2d vector of unboxed values, is it better to use a boxed vector of unboxed vectors, or to use an unbox vector an call elements by ! (i*j)
12:21:03 <sm> jmcarthur: ack
12:21:14 <dcoutts_> scan: ok, so something you're trying to install wants to use parsec 2, so cabal wants to make sure that everything is using the same version
12:21:15 <jmcarthur> alex404: the latter is what repa does
12:21:20 <EvanR-work> jmcarthur: perspective projection camera movement was pretty easy
12:21:24 <EvanR-work> i guess thats out of style
12:21:33 <alpounet> oh jmcarthur :/
12:21:35 <dcoutts_> gwern: mm, quite busy
12:21:37 <alpounet> sorry for your job
12:21:46 <jmcarthur> salright
12:21:51 <alex404> jmcarthur: Oh cool. Fancy looking pcakage. Thanks for the tip.
12:21:53 <scan> any way I can prevent that behaviour? I am always keen on the newest packages
12:22:08 <jmcarthur> alex404: very experimental, and i recommend using ghc 7 with it, not 6
12:22:09 <dcoutts_> scan: you can tell cabal you want to use parsec 3, and it'll either work or it'll say why not. use --constraint='parsec >= 3'
12:22:16 <alpounet> jmcarthur, i'm sure you'll be fine anyway heh
12:22:29 <gwern> dcoutts_: too bad in a sense - lots of package problems these days I don't know how to deal with
12:22:29 <jmcarthur> alpounet: it's okay. i was hoping to look for a more haskelly job anyway, and this just forces me to do that
12:22:37 <dcoutts_> scan: and note that parsec 3 is not the latest and greatest version as such, the default version is version 2. 
12:22:43 <jmcarthur> it still sucks, of course
12:22:46 <jmcarthur> living on savings, etc.
12:22:50 <alpounet> yeah sure
12:23:05 <alpounet> jmcarthur, is there any haskell opportunity around your area ?
12:23:08 <dcoutts_> gwern: aye, the problems change but don't go away :-)
12:23:15 <scan> cdoutts_: Thanks. I have good experience with parsec 3 , though
12:23:15 <jmcarthur> i am nonetheless still spending a lot of time on research :P
12:23:23 <jmcarthur> alpounet: none that i know of
12:23:36 <jmcarthur> i fully expect to have to move in order to get a functional programming job
12:23:39 <alex404> jmcarthur: Does it have any advantages over vector that would make me want to use it?
12:23:42 <dcoutts_> scan: but that's why many packages will specify version 2, because it is the one that is specified by the platform
12:23:59 <dcoutts_> scan: you're of course free to do whatever
12:24:13 <jmcarthur> alex404: for multidimensional arrays it's very very nice, but you have to have a good understanding of how it works and be willing to implement your own primitives for it since it's not really, IMO, complete
12:24:24 <scan> dcoutts_: thanks...
12:24:24 <alpounet> jmcarthur, don't you have a wife already ?
12:24:48 <sm> I don't have time for game dev either, so I'd like to practice making one-hour micro games. Which should be possible.
12:24:55 <jmcarthur> alpounet: yeah, she's also not working. she had been taking advantage of me working to build her portfolio. she's wanting to do concept art for games
12:25:02 <alex404> jmcarthur: Cool. I'll stick with vectors, but it's good to know about it.
12:25:07 <alpounet> oh jmcarthur that's cool then
12:25:11 <alpounet> you can move 
12:25:13 <alpounet> it's not a problem
12:25:17 <jmcarthur> yeah
12:25:26 <jmcarthur> just means we are burning through savings
12:25:31 <alpounet> yeah
12:25:46 <jmcarthur> we still have enough for me to be picky for a while
12:25:55 <alpounet> heh
12:26:11 <gwern> jmcarthur: what's your burn rate before you need more investment?
12:26:12 <alpounet> i'm sure you'll find
12:26:15 <alpounet> tried Galois ? :-P
12:26:23 <jmcarthur> interviewing for a PL research job at stanford soon
12:26:29 <pumpkin> I don't think Galois is hiring
12:26:29 <jmcarthur> galois isn't hiring, really
12:26:34 <alpounet> oh 
12:26:48 <alpounet> a position at stanford, that sounds very nice
12:27:02 <jmcarthur> gwern: i'm not sure if you are asking about $/month or number of months there...
12:27:10 <gwern> jmcarthur: # of months
12:27:33 <jmcarthur> alpounet: well, it would be in line with my interests, but wouldn't pay as well as my last job and wuld involved moving to a much more expensive area :o
12:27:38 <pumpkin> jmcarthur: if you can last for long enough, you might make the next hiring round of galois? :P
12:27:42 <pumpkin> who knows when that will be though
12:28:25 <jmcarthur> i'm not 100% sure that i want to go back into defense contracts, etc.
12:28:43 <jmcarthur> i'd would definitely be interested in an interview if the opportunity comes up though
12:28:55 <alpounet> yeah jmcarthur i saw that the area around stanford is quite expensive
12:29:10 <pumpkin> jmcarthur: do you mind if I stick a simple package implementing that mapping typeclass on hackage?
12:29:10 <jmcarthur> gwern: i have 6-9 months before things get critical
12:29:17 <alpounet> i've had a (phone) interview for a possible position in a company not far from there
12:29:18 <scan> dcoutts_: works now, thanks a lot
12:29:27 <jmcarthur> pumpkin: i don't mind at all
12:30:03 <jmcarthur> alpounet: yeah i already had a phone interview and agreed to a face-to-face interview. just waiting on word about when that could be
12:30:13 <dcoutts_> scan: there's also the --preference flag, which works similarly but is not a hard constraint, it'll try to use that version
12:31:12 <alpounet> well, i wish you luck for the interview jmcarthur 
12:31:15 <jmcarthur> thanks
12:32:06 <rracer> question about eager parsing, http://hpaste.org/40925/eager_parsing_of_http
12:33:12 <jmcarthur> pumpkin: all i really know about the current hiring situation at galois is that they kind of look over resumes the receive about once a month, probably just to look for any must-hire-immediatelys. i doubt i have anything on my resume that makes me a must-hire-immediately
12:33:24 <jmcarthur> *they receive
12:33:36 <pumpkin> ah well :/
12:34:31 <gwern> jmcarthur: might as well try. surely galois must expand at some point, feeding on defense contracts as they do - like a tick engorging with blood
12:34:51 <alpounet> so you're comparing galois to a tick ? heh
12:35:25 <jmcarthur> it's easy to associate government contractors with ticks sometimes
12:35:47 <jmcarthur> not that galois is one! *looks back and forth*
12:35:52 <gwern> (and jmcarthur would know)
12:36:20 <jmcarthur> but seriously, the last company i worked for was a defense contractor and i actually enjoyed it for the most part
12:36:56 <jmcarthur> in fact, the vast majority of programming work in my area is defense contracting
12:37:07 <jmcarthur> but most of it looks really boring/excruciating to me
12:37:25 <jmcarthur> the work at galois at least is very much along the lines of my interests
12:42:27 <xs> why is a rose tree called a rose tree?
12:43:19 <nschoe> Hi everyone.
12:44:38 <nschoe> Is there anyone who could answer few questions about code I wrote (tried to use the State monad efficiently, but not sure I succedeed)?
12:44:58 <benmachine> nschoe: generally people don't know if they can answer a question until it's been asked :)
12:45:16 <rracer> question about eager parsing, http://hpaste.org/40925/eager_parsing_of_http
12:45:33 <_Cactus_> hi
12:45:52 <_Cactus_> I've just realized that mplus is not left-catch for []/ListT
12:45:56 <nschoe> benmachine: True, but it's kinda hard to simply "ask"?
12:46:02 <nschoe> I'll try though ^^
12:46:16 <benmachine> rracer: at a guess network-curl is not ideal for your use
12:46:20 <jmcarthur> rracer: you are looking for either lazy IO or something like iteratee, i think
12:46:41 <benmachine> rracer: how afraid are you of big scary libraries? http-enumerator might do what you want but I'm not sure how easy it is to use
12:46:49 <_Cactus_> so what's the cleanest way with ListT to do "extendSolutionByRecursing `mplus` return x" that doesn't return intermediate x's
12:47:25 <jmcarthur> the former is easier to get started with but can lead to frustrating issues sometimes, and the latter is (much, IMO) harder to learn but will be nicer in the long run
12:47:30 <rracer> not scary if I'm on the right track
12:48:14 <jmcarthur> rracer: the http-enumerator package that benmachine suggested is an example of the latter
12:48:35 <jmcarthur> it's what i would use if i wanted to do it "right", but like i said, it involved learning quite a bit
12:48:42 <jmcarthur> *involves
12:48:56 <rracer> cool, I'll try that, thanks
12:49:38 <nschoe> I'm trying to implement some (ftm very basic) "AI" functions in Haskell, the AI is a vacuum cleaner whose goal is to clean a room. I wrote a map interface (simple text files and a parser to read it). The tough part (for me) comes when I want to test my function on one of those maps.
12:51:19 <nschoe> I created a custom World type which is composed of a Map (previously parsed by my function, no problems here) and the position of the "robot". For my ai function to operate on this World variable, I thought of using the State monad. Here comes the tough part.
12:53:39 <nschoe> First thing I wonder is: is it normal that all my functions need a World variable to operate on? I mean: isn't the State monad supposed to avoid that?
12:54:13 <roconnor> if you are using the state monad, then your functions won't need a World parameter
12:54:29 <jmcarthur> nschoe: you could paste your code at hpaste.org
12:54:34 <Twey> ‘Functions’; they'll probably mostly end up as State values
12:55:22 <nschoe> jmcarthur: okay, thought it was a bit rude to just paste the code that way^^
12:55:24 <jmcarthur> nschoe: the State monad should turn all your functions having to form  World -> (a, Word)  into functions having the form  State World a
12:55:35 <jmcarthur> nschoe: just don't paste the code into the channel ;)
12:56:25 <djahandarie> gdoteof, greetings
12:56:28 <gdoteof> :)
12:56:29 <djahandarie> @where LYAH
12:56:29 <lambdabot> http://www.learnyouahaskell.com/
12:56:39 <djahandarie> Start off with that
12:56:47 <gdoteof> djahandarie: i was just going to ask if that was the recommended source
12:56:54 <djahandarie> For starting
12:56:54 <jmcarthur> nschoe: State is "best" used inside a newtype wrapper in a module that exposes only the operations you actually need, e.g. move :: Direction -> MyMonad (), or position :: MyMonad Position
12:57:01 <djahandarie> After that it depends on what you're interested
12:57:09 <jmcarthur> nschoe: so you should really never have to look at its internals in idiomatic usage
12:57:11 <djahandarie> interested in*
12:57:17 <jmcarthur> except in that one module
12:57:46 <jmcarthur> nschoe: i say that only just in case that's what your question was about
12:57:49 <gdoteof> got it.  what do you use for development?  
12:57:51 <jmcarthur> i'm not 100% though, actually
12:58:02 <gdoteof> a terminal at the repl and text editor
12:58:02 <gdoteof> ?
12:58:15 <djahandarie> gdoteof, a lot of people just use emacs or vi. There is an IDE called Leksah though
12:58:43 <nschoe> jmcarthur: Okay, then. what I was afraid of happened: I misundertood the use of the State Monad.
12:58:53 <nschoe> (I'm puttin the ocde on hpaste right now)
12:59:06 <jmcarthur> nschoe: okay. we can probably give you some design tips once we see it
13:00:58 <nschoe> jmcarthur: yeah, thanks in advance^^
13:01:02 * hackagebot operational 0.2.0.1 - Implement monads by specifying operational semantics.  http://hackage.haskell.org/package/operational-0.2.0.1 (HeinrichApfelmus)
13:02:15 <djahandarie> gdoteof, after LYAH, I'd probably recommend Real World Haskell (RWH)
13:02:17 <djahandarie> @where RWH
13:02:17 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:02:33 <djahandarie> Which applies the concepts and such in LYAH to some real world stuff
13:04:27 <nschoe> Here is the code : http://hpaste.org/40926/questions_about_state_monad sorry it's sort of a big whole (I put the two useful files).
13:05:32 * jmcarthur looks
13:05:57 <alpounet> i was sure you would look at some haskell AI code jmcarthur :P
13:06:04 * hackagebot yaml-light 0.1.4 - A light-weight wrapper with utility functions around HsSyck  http://hackage.haskell.org/package/yaml-light-0.1.4 (MichaelIlseman)
13:06:22 <jmcarthur> nschoe: yeah, first warning sign: "return world'"
13:06:22 <nschoe> alpounet: Well actually you gotta have a big imagination to call that "AI" but that's a start.
13:06:48 <nschoe> jmcarthur: Why is it a warning? I should not return my updated world?
13:06:58 <jmcarthur> nschoe: i would have expected     updatePosition ∷ Position → WState ()
13:07:16 <jmcarthur> nschoe: you already updated the state. that state will be available later without returning it
13:07:57 <jmcarthur> @unmtl Position -> State World ()
13:07:58 <lambdabot> Position -> State World ()
13:08:01 <nschoe> Hum okay, so I only have to "put world'" but not returning it.
13:08:03 <jmcarthur> bleh
13:08:08 <jmcarthur> @unmtl State World ()
13:08:08 <lambdabot> World -> ((), World)
13:08:22 <alpounet> yes nschoe 
13:08:23 <jmcarthur> see, World is passed along fine even with a () "return type"
13:08:33 <alpounet> return is for the value you'll attach to your "state"
13:08:40 <_Cactus_> http://hpaste.org/40927/leftcatch_mplus_for_listt <- is there a better way to write the second variant of 'foo'?
13:08:52 <roconnor> @src return State
13:08:53 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:08:58 <roconnor> @src State return
13:08:58 <lambdabot> Source not found. My brain just exploded
13:08:59 <gdoteof> djahandarie: thanks.  i have these things bookmarked too.  i first want to learn enough haskell to pimp my xmonad out.  i keep breaking it
13:09:13 <nschoe> okay, in this case, my "actuatorSetPosition" function is useless, right?
13:09:17 <jmcarthur> nschoe: okay, i'm not going to pick your code apart. i'll instead explain a design process that i would recommend
13:09:56 <jmcarthur> nschoe: before i do that, i'll pick one more thing apart
13:10:01 <nschoe> jmcarthur: okay, that's fine (that was what I was looking for when I came here, but hard to ask "how would you guys do ..." ^^)
13:10:05 <nschoe> Yea?
13:10:07 <jmcarthur> nschoe: here's another warning sign:    actuatorPerform ∷ World → RobotAction → World
13:10:28 <jmcarthur> nschoe: that looks a lot like  RobotAction -> State World (), to me
13:10:47 <jmcarthur> nschoe: so it looks like you are inconsistently using your monad
13:11:17 <jmcarthur> or is that perhaps just old code?
13:11:31 <jmcarthur> oh, no, you are using evalState in that
13:11:39 <jmcarthur> why unwrap the state monad?
13:11:58 <jmcarthur> anyway, enough of that
13:12:07 <nschoe> jmcarthur: truth is:
13:12:21 <jmcarthur> nschoe: the first thing i would do is figure out what API i want to expose from this module
13:12:28 <nschoe> I'm not very familiar with the State monad (or... Monads at all :/) so that piece of code was a way for me to test.
13:12:47 <nschoe> jmcarthur: Okay.
13:12:50 <jmcarthur> nschoe: let's assume you have a magical type constructor that represents your own special language
13:12:57 <jmcarthur> nschoe: what does this language allow you to do?
13:13:21 <jmcarthur> if you aren't sure how to answer that question (perhaps it's vague) i can answer it
13:13:40 <jmcarthur> but i can only answer it with a *possibility*. there are many possibilities here
13:13:47 <nschoe> jmcarthur: Well... yes, please do (I don't really see what you meant with the question)
13:14:17 <nschoe> jmcarthur: please tell me your answer, maybe I'll understand and be able to give one too.
13:14:23 <jmcarthur> nschoe: to be clear, this is the "language" that your AI will "use", if i'm understanding your architecture correctly
13:14:46 <jmcarthur> as though the AI was sitting at a repl and typing things out, seeing what the result it, etc.
13:14:52 <jmcarthur> *is
13:14:59 <djahandarie> gdoteof, heh, yeah, a lot of people end up here via xmonad configs
13:15:14 <nschoe> jmcarthur: Sorry to interrupt, but I don't really see why you talk about a language? The "AI" is supposed ot be a vacuum cleaner, so maybe I'm missing something here.
13:15:14 <djahandarie> There is a lot of weird stuff in that xmonad config file though
13:15:26 <jmcarthur> nchaimov: okay, i'd say that this language you want would expose ways for you to move, look around, etc.
13:15:29 <jmcarthur> dang
13:15:32 <jmcarthur> nschoe: ^^
13:15:36 <jmcarthur> sorry nchaimov 
13:15:41 <djahandarie> Best to start from the other end and then realize you know enough to do the xmonad config somewhere along the way :)
13:16:38 <djahandarie> Is there an unimplemented-in-Haskell Okasaki paper somewhere?
13:16:40 <jmcarthur> nschoe: so for example, your AI might want to say things like "move left; is there some junk to pick up in front of me?; if so, suck it up, otherwise just move forward; " etc.
13:16:59 <jmcarthur> nschoe: i'm not entirely sure what your AI expects though, so i'd hate to be presumptious enough to guess
13:17:03 <jmcarthur> those are just possibilities
13:17:27 <alpounet> jmcarthur, it's correct, AFAIU
13:17:30 <jmcarthur> nschoe: i'm using the word "language" here in place of "API" because that's really want an API is, after all
13:17:34 <nschoe> jmcarthur: yeah okay I see. A way to communicate with my AI? Just like a sort of protocol, right?
13:17:36 <jmcarthur> *what
13:17:43 <jmcarthur> nschoe: you could say that, yeah
13:17:51 <nschoe> jmcarthur: Okay, then I think I get the idea.
13:17:54 <jmcarthur> nschoe: so could you list off what you need here?
13:18:02 <jmcarthur> once you do that we can work on implementing that
13:18:16 <gdoteof> list comprehensions are cool
13:18:23 <jmcarthur> list only the things your AI needs to see and nothing else. anything else is going to be an implementation detail
13:18:49 <nschoe> jmcarthur: (Just for you to know : I'm reading "AI : A Modern Approach" from Stuart Russle and Peter Norvig and trying to implement thei exemples in Haskell, maybe you have that book to and will understand what I want to do a bit more).
13:18:59 <jmcarthur> no, i don't, sorry
13:19:04 <jmcarthur> alpounet: might you, by chance?
13:19:09 <alpounet> yup
13:19:09 <nschoe> Okay it was just in case.
13:19:16 <nschoe> alpounet: yes he does, he made me buy it :P
13:19:20 <jmcarthur> heh
13:19:25 <jmcarthur> i could have guessed :P
13:19:41 <nschoe> ^^
13:19:44 <alpounet> but that's just a "dumb" AI jmcarthur 
13:20:17 <jmcarthur> alpounet: my understanding is that this module is defining what the AI interacts with, correct?
13:20:23 <alpounet> yeah
13:20:24 <alpounet> there's a grid
13:20:28 <jmcarthur> okay
13:20:33 <alpounet> you have a cleaning robot
13:20:50 <alpounet> and nschoe wants to implement a little AI for this robot
13:20:54 <jmcarthur> right
13:21:22 <alpounet> moving around, cleaning when appropriate, etc
13:21:30 <nschoe> jmcarthur: So, to list things that AI would need I'd say : check whether the case it is on has dust to clean, move to the (left,right, up, down), check his position on the map (I'll assume for now that the map is know entirely, I'll try exploration later).
13:21:51 <nschoe>  s/case/square
13:22:00 <jmcarthur> nschoe: so the AI is aware of the entire layout of the world?
13:22:19 <jmcarthur> i'm guessing except for where there are dirty cells?
13:22:31 <nschoe> For now yeah, I guess it's easier (as I already have difficulties dealing with that simple thing in Haskell).
13:22:39 <jmcarthur> okay
13:22:48 <jmcarthur> so let's look at each of those actions in turn
13:23:01 <nschoe> Okay.
13:23:05 <jmcarthur> first, the one where it checks to see if the cell it's on is clean
13:23:15 <jmcarthur> what type would you like for that to have?
13:23:19 <jmcarthur> just, ideally
13:23:26 <Martty> BONUS: http://s3.amazonaws.com/lyah/rpn.png isnt this inconsistent? basically you are popping for rhs and then for lhs when an operator is found but for the last operator it does 10-14 instead of 14-10
13:23:41 <nschoe> jmcarthur: you mean the type of the function?
13:24:05 <jmcarthur> nschoe: don't think too hard about being "pure" in this case. we can capture any necessary side effects in our monad later (assuming of course that we actually make a monad)
13:24:18 <jmcarthur> nschoe: but yes, the type of the function
13:24:33 <jmcarthur> nschoe: the important thing is that the type should *not* expose anything we don't expect the AI to know already
13:24:48 <jmcarthur> so no parameters the AI can't have access to
13:24:56 <nschoe> jmcarthur: okay, I can think of different schemes:
13:25:06 <Martty> anyone care to corroborate?
13:25:44 <Eridius> has anyone heard of a C99 parser that uses Parsec? I'm aware of Language.C, but that uses Happy, and apparently my friend (the guy who wants this) wants Parsec
13:26:29 <roconnor> Martty: yes
13:26:45 <nschoe> 1/ it could be smth like World -> Bool (it means the position of the robot is included in the World type). 2/ Position -> Bool (but then I wonder how can the robot know if there's dust jsut based on a Position). I'm being stuck here because I'm trying to think about how things should be in the real life: a robot would just chekc with sensors, so ...
13:27:15 <jmcarthur> nschoe: okay, i disagree with both options, and here's why:
13:27:40 <alpounet> nschoe, i guess it'd need both the *World* and a *Position*
13:27:45 <jmcarthur> nschoe: the first one assumes that the AI is holding onto a World object. even an opaque object is breaking our abstraction with details the AI doesn't care about
13:27:46 <alpounet> to check that position in your grid
13:27:48 <nschoe> jmcarthur: Sorry I'm not being clear here. What I meant is that it is a bit difficult for me to reason because there are two different problems here: emulating the outside world (because I don't have an actual robot, with actual sensors) and creating an AI function that works on that world emulation, do you see what I mean?
13:27:59 <jmcarthur> nschoe: the second one seems to imply that the AI can check anywhere on the map, and we don't want that
13:28:25 <jmcarthur> nschoe: i see what you mean. i'm suggesting that you don't even try to juggle both at once. we only care about what the AI can see at this particular moment
13:28:36 <jmcarthur> nschoe: here's what i would suggest:
13:28:40 <jmcarthur> nschoe: Bool
13:28:48 <jmcarthur> nschoe: remember i said not to worry about purity for now
13:28:54 <nschoe> jmcarthur: Yes
13:28:57 <jmcarthur> so we can assume that the Bool depends on context
13:29:01 <nschoe> So just Bool?
13:29:04 <jmcarthur> and what must that context be?
13:29:12 <jmcarthur> well, that won't be our final type
13:29:20 <jmcarthur> we're just thinking from the AI's (stateful!) point of view
13:29:33 <nschoe> Okay.
13:30:02 <nschoe> So, the AI actually gets information from the robots sensors, right?
13:30:16 <alpounet> nschoe, he means "what do the AI need to know about a cell to know it it's clean ?"
13:30:19 <jmcarthur> well, we're implementing the API that those sensors provide
13:30:19 <alpounet> (i guess)
13:30:31 <jmcarthur> no, i'm not alpounet 
13:30:47 <alpounet> oh
13:30:52 <jmcarthur> i'm assuming that there is some opaque "sensor" that just knows magically and can tell the bot
13:30:54 <alpounet> i'll let you talk then hhe
13:31:00 <jmcarthur> but that sensor depends on context
13:31:23 <fryguybob> Martty: If I do "10 14 -" on my calculator I would expect -4.
13:31:30 <jmcarthur> nschoe: we have determined what the type of the information the bot needs is. we're just informally trying to define what the context for obtaining that information is
13:31:30 <nschoe> jmcarthur: hum okay, so the AI just receives "yes there is dust where you are" or "no there is nothing here", right?
13:31:35 <jmcarthur> exactly
13:31:51 <jmcarthur> the AI is not aware of this context we're talking about now
13:31:59 <nschoe> jmcarthur: okay, we're defering the actual details for later. Okay.
13:32:02 <jmcarthur> it's only able to see the output from this virtual sensor
13:32:04 <jmcarthur> right
13:32:28 <jmcarthur> let's just leave context alone. we'll go over the other operations first
13:32:37 <Martty> fryguybob: if i do 4 3 + id expect 4 + 3 
13:32:37 <nschoe> jmcarthur: Okay, I get it. I'ts even better because it means hte AI can be used in any context, given that some function gives him a Bool.
13:32:39 <jmcarthur> movement
13:32:46 <jmcarthur> nschoe: yes!
13:32:55 <nschoe> jmcarthur: ok.
13:33:07 <jmcarthur> we're only defining an API independent of implementation
13:33:22 <jmcarthur> at least at the moment
13:33:25 <jmcarthur> we'll get to implementation
13:33:48 <jmcarthur> okay, so what kind of API would your AI want for movement?
13:33:52 <jmcarthur> i can think of two ways to do it
13:34:02 <jmcarthur> there are surely more, but two "obvious" ways
13:34:12 <nschoe> jmcarthur: okay, which one do you think of?
13:35:03 <jmcarthur> i would say we could either do it like this:    move :: Direction -> ()      or like this:    moveUp :: (); moveRight :: (), moveDown :: (), moveLeft :: ()
13:35:15 <jmcarthur> where we have data Direction = Up | Down | Left | Right
13:35:31 <jmcarthur> oh but something occurs to me about this API
13:35:45 <jmcarthur> i'll see if you catch it, but only after making sure you're following right now
13:36:03 <pumpkin> x -> () ? :O
13:36:21 <nschoe> ok
13:36:31 <nschoe> I think the first one is best.
13:36:32 <jmcarthur> pumpkin: we're ignore monads and effects for now
13:36:35 <jmcarthur> *ignoring
13:36:40 <pygmalion> i'm having some trouble with partial application. http://hpaste.org/40928/partial_application i was under the impression that i should be able to use that second case with the others as is, but am having some issues with the number of args
13:36:58 <jmcarthur> nschoe: okay, do you see the problem i hinted at?
13:37:01 <alpounet> shhhhh pufuwozu 
13:37:04 <alpounet> pumpkin*
13:37:05 <alpounet> :P
13:37:09 <pumpkin> :P
13:37:20 <nschoe> jmcarthur: hum
13:37:27 <jmcarthur> nschoe: is the AI allowed to move beyond the boundaries of the map?
13:38:23 <nschoe> jmcarthur: Damn I'm an idiot. Okay sorry didn't think of that.
13:38:28 <jmcarthur> nah it's fine
13:38:30 <nschoe> But isn;t it implementation detail?
13:38:52 <jmcarthur> nschoe: is it permissible for the AI to try and fail to move beyond the map?
13:39:11 <jmcarthur> without even realizing?
13:39:17 <nschoe> jmcarthur: Because in this case, we should check that 1/ the AI doesn't try to go out of the map, 2/ he doesn't try to move on a Wall.
13:39:37 <jmcarthur> nschoe: should the AI be aware if it makes this mistake?
13:40:09 <nschoe> jmcarthur: Well, I guess no. I had not thought about that before, but let's assume every map is "closed" (in the sense that you design a map then puts Walls all aroudn the map to be sure).
13:40:13 <EvanR-work> jmcarthur: is there such an alternative that it never tries to go beyond the map, and is aware of it?
13:40:19 <jmcarthur> and what happens if it does make that mistake? should it be a runtime error? should the order be discarded?
13:40:45 <jmcarthur> nschoe: okay, so if the AI attempt to move into a wall we will just silently discard the order?
13:40:56 <jmcarthur> if that's the case then the API as proposed is still okay
13:41:18 <jmcarthur> EvanR-work: you mean where it's statically prevented from doing it?
13:41:20 <gwern> the AI has no mouth and must scream
13:41:55 <nschoe> jmcarthur: in the way I did things,
13:41:57 <EvanR-work> jmcarthur: is that what that means?
13:42:09 <nschoe> jmcarthur: when the AI was to move to a wall, I just made it stay where it was
13:42:29 <EvanR-work> prevented at run time means it must make an attempt 
13:42:30 <jmcarthur> nschoe: alright, and the last thing you mentioned it should be able to do is get its current position on the map. i see two necessary primitives for this work
13:42:35 <jmcarthur> EvanR-work: right
13:42:41 <EvanR-work> doesnt seem logical
13:42:48 <jmcarthur> EvanR-work: i think statically preventing it might be a bit too complex for the time being
13:42:49 <monochrom> haha gwern
13:42:50 <EvanR-work> but the opposite doesnt either
13:42:57 <nschoe> jmcarthur: you can see it in the line 41/42 of the hpaste file.
13:43:13 <jmcarthur> nschoe: okay i see
13:43:31 <jmcarthur> nschoe: what API would the AI like for getting its position in the map?
13:43:58 <nschoe> jmcarthur: (same question than for know whethere there was dust?)
13:44:09 <jmcarthur> it's pretty similar, yeah
13:44:53 <nschoe> jmcarthur: But would a simple Position be useful? how would (3,5) mean anything to the AI?
13:45:00 <jmcarthur> right! you caught it
13:45:11 <jmcarthur> our API doesn't seem to provide enough information to the AI
13:45:33 <jmcarthur> or perhaps the wrong information, even, but given your goals i think that's not the case here
13:45:47 <jmcarthur> nschoe: so you tell me. we else does it need?
13:45:50 <jmcarthur> *what else
13:46:20 <nschoe> In addition to the position?
13:46:43 <jmcarthur> i'm leaving the answer to that question as a mental exercise
13:47:09 <jmcarthur> what is necessary for that position to be useful?
13:47:21 <gwern> perhaps you coud provide the map as a zipper
13:47:36 <jmcarthur> gwern: he said he wants to do exploring in a later version but not this one
13:47:41 <gwern> 2d; with entries being an ADT
13:47:50 <jmcarthur> gwern: he said the AI should be aware of the entire map
13:47:59 <jmcarthur> gwern: just not where on the map is dirty
13:48:13 <jmcarthur> nschoe: i've kind of answered the question now
13:48:14 <gwern> this might let you statically ensure the AI can't move into a wall
13:48:19 <jmcarthur> gwern: agreed
13:48:36 <gwern> jmcarthur: well, the bot could always be at the focus, the origin, 0,0
13:48:37 <nschoe> jmcarthur: okay, so I try to act as if I was the robot: I have my eyes almost closed. So maybe that nformation could be useful: my position, the nature(Wall, Clean Square, Dirty Square) of the square which is up to me, down to me, on the left and on the right. No?
13:48:55 <gwern> jmcarthur: the map shifts and moves around the bot. the bot just decides which direction to move 1 unit in this turn
13:48:57 <jmcarthur> nschoe: aha! so you're changing the model of your AI now
13:49:10 <jmcarthur> nschoe: earlier you were saying that the AI could be aware of the whole map. do you want to change that?
13:49:10 <nschoe> jmcarthur: Damn. you're right I figured that out the moment I pressed Enter.
13:49:21 <wlangstroth> are we describing the classic Wumpus exercise?
13:49:43 <alpounet> yup wlangstroth 
13:49:48 <nschoe> jmcarthur: Well I did not read the chapter over Exploration for now, so now don't change. The AI should be aware of the whole map.
13:50:11 <jmcarthur> nschoe: okay, then we will not take gwern's advice yet :)
13:50:28 <gwern> nooo
13:50:57 <jmcarthur> gwern: i want to leave the opportunity open for the bot to make a poor design choice and hold on to the map indefinitely instead of treating it as something contextual
13:51:02 <nschoe> jmcarthur: Hum is it too late to change just one thing: could we make the AI aware of the "shapre" of the map, but it cannot tell in advance which squares are dirty or clean?
13:51:09 <jmcarthur> gwern: as i think that is the different between being exploratory and not
13:51:12 <jmcarthur> *difference
13:51:24 <jmcarthur> nschoe: i was making that assumption, sure
13:52:03 <nschoe> Okay, so it's the model that fits the best what I read on the book: the robot know how the map is, but doesn't know if the square at (x,y) needs to be washed or not.
13:52:14 <jmcarthur> great
13:52:15 <alpounet> gwern, moreover it's not Zipper time for nschoe yet :p
13:52:17 <jmcarthur> nschoe: okay, so we're talking about what the AI is aware of... how is it aware of it?
13:52:27 <gwern> alpounet: throw him in the deep end! good way to learn
13:52:34 <nschoe> alpounet: "He's still so young" :P ^^
13:52:41 <alpounet> yeah
13:52:44 <jmcarthur> nschoe: i say we need one of two things
13:52:52 <alpounet> too pure for diving into Zippers
13:52:58 <jmcarthur> nschoe: either we need another action that gives the AI the map...
13:53:04 <EvanR-work> zipper diver
13:53:27 <pygmalion> :r
13:53:30 <jmcarthur> nschoe: or we need the change out getPosition action to also give the map along with the position (or perhaps integrate both of those into one cohesive type)
13:53:41 <jmcarthur> *change our
13:53:52 <gwern> nschoe just wanted to pick up some spare functions at Tosche Station, eh
13:53:58 <wlangstroth> aw! the wumpus is a "zipper diver" now?
13:54:09 <jmcarthur> nschoe: which sounds better to you?
13:54:54 <alpounet> wlangstroth, from gwern's eyes yeah
13:55:48 <wlangstroth> Such fond memories sullied
13:55:48 <nschoe> jmcarthur: Hum maybe I'm a bit idiotic here, but the second doesn't sound good to me, because generally when I program I like when one function does what it's been created for: for instance getPosition should give the position, not the positibe, plus the map, plus the weather, plus the amount of battery left in the robot etc. You see what I mean?
13:56:17 <nschoe> So I don't realy like the idea of a function that gives the map along with the position. But... maybe I'm being a noob on that one...
13:56:45 <jmcarthur> nschoe: i don't think you're being a noob. however, are either the map or the position useful in isolation?
13:57:40 <jmcarthur> i mean, sure, you could get each piece of data individually, but are you *ever* going to use one without the other?
13:57:43 <nschoe> jmcarthur: you're right, so hte second choice was the wisdom one?
13:57:53 <jmcarthur> i will not claim to be wise
13:57:58 <jmcarthur> but it's what i would choose
13:58:20 <alpounet> old wise jmcarthur 
13:58:21 <alpounet> heh
13:58:22 <nschoe> jmcarthur: yeah okay, let's follow your decision. I'm here to learn afterall.
13:58:23 <jmcarthur> it also opens the opportunity for making a specialized data structure if we ever want to (but i don't think we care)
13:58:44 <jmcarthur> say, a zipper like gwern was talking about
13:58:56 <jmcarthur> a zipper is precisely this idea of a position with a context
13:59:06 <jmcarthur> but like i said earlier, that's something for another day
13:59:10 <wlangstroth> aplounet: yes, but at 0,0, it seems like gwern's going nowhere; maybe it's relative ... okay, I'll stop
13:59:39 <EvanR-work> is a zipper interesting only because its functional
13:59:41 <nschoe> jmcarthur: yeah okay, I have no idea what a zipper is.... (yet^^).
13:59:49 <jmcarthur> nschoe: okay, so we have everything that we want to AI to have available to it now?
13:59:50 <alpounet> wlangstroth, well maybe he doesn't want to go anywhere
14:00:41 <nschoe> jmcarthur: just to be sure, so to deal with the position, the AI will need to have the position and the map, is that it?
14:00:45 <jmcarthur> nschoe: isClean :: Bool, move :: Direction -> (), getPosition :: (Position, Map)
14:00:58 <nschoe> Oklay, perfect.
14:01:00 <jmcarthur> nschoe: i would assume so
14:01:04 <jmcarthur> okay
14:01:30 <jmcarthur> for now, we'll assume that's our API (we will want at least one or two more things later)
14:01:51 <jmcarthur> nschoe: now... this API is very contextual, would you agree?
14:01:51 <nschoe> jmcarthur: okay. I've noted that.
14:02:16 <nschoe> jmcarthur: well it's very vague yeah.
14:02:32 <gwern> if the bot is always at 0,0, it's not hard to move. you just do something like 'getDistanceToEnemy' on each of the 4 directions, say, and then your strategy is move towards/away
14:02:37 <gwern> or whatever strategy you want
14:02:44 <EvanR-work> Stack space overflow: current size 8388608 bytes.
14:02:45 <EvanR-work> Use `+RTS -Ksize -RTS' to increase it.
14:02:47 <EvanR-work> >_<
14:02:50 <gwern> it's isomorphic to a board that doesn't move, but your position does
14:02:51 <jmcarthur> nschoe: still on an API level, not implementation, we can "hide" context like that under some sort of type constructor
14:03:01 <jmcarthur> nschoe: so that will turn our types into:
14:03:25 <jmcarthur> nschoe: isClean :: t Bool; move :: Direction -> t (); getPosition :: t (Position, Map)
14:03:27 <jmcarthur> for some t
14:04:10 <nschoe> ok.
14:04:31 <jmcarthur> nschoe: in the case of move, we could also have said:   move :: t (Direction -> ()), but that would mean we can't apply it to an argument directly!
14:04:43 <jmcarthur> because the function would have been hidden :\
14:05:06 <jmcarthur> nschoe: what do you think we should call t?
14:05:15 <nschoe> jmcarthur: yeah ok I see.
14:05:35 <nschoe> hum maybe ... "Info" ?
14:06:10 <jmcarthur> hmm.... it's up to you. we'll run with it for now. not sure what i would go with ATM
14:06:30 <nschoe> jmcarthur: I was just trying to guess. What would you call it?
14:06:51 <jmcarthur> maybe Room or something. i have no idea. names are pretty arbitrary
14:06:57 <jmcarthur> Info works if that's what you want
14:07:29 <nschoe> jmcarthur: Well I don't know it that's what I want. I like the way you think, how you put things so my goal is at least no to make nonsense.
14:07:32 <jmcarthur> it might be a slight misnomer in that we aren't getting any information when we move
14:07:43 <nschoe> Isn't "Info" a nonsense?
14:07:50 <jmcarthur> names are nonsense
14:08:06 <jmcarthur> it's good to come up with good names for things, but names are easy to change later. APIs aren't
14:08:07 <nschoe> I agree with that, but they reflect the way we think.
14:08:18 <nschoe> Okay. So le'ts call it Info for now
14:08:21 <jmcarthur> sure
14:09:07 <jmcarthur> nschoe: okay, normally at this point i would start asking about coming up with a model for Info
14:09:17 <jmcarthur> nschoe: i'm not completely sure whether you are ready for that yet
14:09:45 <jmcarthur> we have done a little modelling simply by virtue of coming up with an API already, but it has been very informal
14:09:51 <nschoe> jmcarthur: Well I'm sure I'm not :/ (sorry it seems it's as easy to make me understand than climbing a mountain ^^)
14:10:11 <nschoe> than -> as*
14:10:24 <jmcarthur> nschoe: you seem to be doing great to me
14:10:46 <nschoe> I'm doing my best ;)
14:11:01 <jmcarthur> nschoe: the ability to remove clutter from your head and think about very simple, abstract concepts the way i'm encouraging you to is difficult to learn
14:11:47 <jmcarthur> nschoe: i'm just going to propose a model for Info without explaining how i got there. this model will turn out to be a great implementation, too, but our actual implementation will be a bit more convenient
14:11:55 <jmcarthur> nschoe: to recap:
14:12:02 <nschoe> ok
14:12:17 <jmcarthur> nschoe: isClean :: Info Bool; move :: Direction -> Info (); getPosition :: Info (Position, Map)
14:12:29 <jmcarthur> nschoe: first, i'd like a little information about your World type? what's in it?
14:14:07 <nschoe> I defined the World as : World = World { wMap :: Map, wPosition :: Position }, Position being just a (Int, Int) and Map being newtype Map = Map {unMap ∷ Array Position Square}
14:14:42 <jmcarthur> and i assume Square has whether it's dirty/clean/wall?
14:15:36 <nschoe> jmcarthur: Yeah, Square = Wall | DirtySquare | CleanSquare.
14:15:39 <jmcarthur> okay
14:15:54 <nschoe> But I'm opend to any suggestion if you think about something better fitted.
14:16:01 <jmcarthur> so we can't give the AI your map type because it exposes which cells are dirty
14:16:32 <nschoe> jmcarthur: defintely.
14:17:25 <jmcarthur> let's assume we have a Position type and a Room type (renaming from Map because that keeps reminding me of Data.Map)
14:17:56 <jmcarthur> and we also need to know which cells are dirty. how about type DirtyCells = Set Position
14:18:04 <nschoe> So maybe change the Square type? Such as Square = Square {type :: Type, status :: Status} with Type = Wall | Other and Status = Clean | Dirty, no?
14:18:39 <jmcarthur> that'd be one way
14:18:49 <jmcarthur> can a wall be dirty?
14:18:56 <jmcarthur> can a wall even be clean?
14:18:59 <nschoe> jmcarthur: nope.
14:18:59 <alpounet> jmcarthur, :D
14:19:13 <alpounet> i know of some people's flat where they are
14:19:21 <nschoe> alpounet: xD :p
14:19:31 <jmcarthur> nschoe: okay. it's not that what you suggest is bad, but it's not absolutely perfect, so in the interest of simplicity i think we should go with something else
14:19:34 <alpounet> better not send your robot there for the moment
14:19:52 <nschoe> alpounet: lol sure you don't want one? I can cut my price ^^ :P
14:19:55 <jmcarthur> nschoe: how about type Walls = Set Position and type DirtySquares = Set Position?
14:19:58 <nschoe> jmcarthur: Yeha okay, no problem, I wa just asking.
14:20:04 <jmcarthur> nschoe: then we don't even have to store an array anywhere
14:20:16 <jmcarthur> an array which i assume is mostly empty squares
14:20:32 <nschoe> jmcarthur: erfh, I don't know "Set". Is it a Haskell type?
14:20:35 <jmcarthur> yeah
14:20:43 <jmcarthur> actually, my suggestion has the same issue that yours did
14:21:22 <jmcarthur> but it has the benefit of separating cleanliness from walls at least. we can give the AI the Walls type (in place of Map/Room) and choose not to give it the DirtySquares type
14:21:47 <EvanR-work> bitten by my first haskell memory leak
14:21:56 <EvanR-work> and i have no idea what to do about it
14:22:10 <jmcarthur> nschoe: basically Set it good for denoting membership. "Is this position in the set of dirty squares?" "Remove this position from the set of dirty squares" etc.
14:22:22 <alpounet> EvanR-work, run the space profiling tool
14:22:30 <nschoe> jmcarthur: okay, so it's basically the same notion than in Maths, right?
14:22:33 <EvanR-work> which one is that
14:22:40 <alpounet> i don't remember the name
14:22:41 <alpounet> wait
14:23:02 <jmcarthur> nschoe: pretty much (with an ugly wart that it requires members to instantiate the Ord type class, which is not very much like sets from math)
14:23:27 <jmcarthur> nschoe: but let's just pretend it's like in math
14:23:32 <nschoe> jmcarthur: okay.
14:24:00 <jmcarthur> so our api has changed slightly in naming, for clarity:
14:24:02 <aristid> jmcarthur: if you accept very slow sets, Eq would suffice, right?
14:24:17 <aristid> i don't see how sets without Eq would be possible tho
14:24:17 <jmcarthur> nschoe: isClean :: Info Bool; move :: Direction -> Info (); getPosition :: Info (Position, Walls)
14:24:23 <jmcarthur> aristid: correct
14:24:49 <nschoe> jmcarthur: okay. I wrote that.
14:25:00 <nschoe> (I mean I took note of that)
14:25:08 <jmcarthur> nschoe: looking at each action in turn now...
14:25:20 <EvanR-work> ill paste the code im thinking is the problem
14:25:20 <alpounet> EvanR-work, got it!
14:25:22 <alpounet> hp2any
14:25:47 <alpounet> there was an article in TMR about it EvanR-work 
14:26:10 <jmcarthur> nschoe: isClean will require our DirtySquares and Position information, i think
14:26:13 <EvanR-work> it reads a file and produces a Data.Map
14:26:23 <jmcarthur> that way we can check the DirtySquares and see if the Position is a member
14:26:33 <jmcarthur> agreed? does it need more or less?
14:26:40 <pumpkin> preflex: seen zygoloid 
14:26:41 <preflex>  zygoloid was last seen on #haskell 6 hours, 42 minutes and 36 seconds ago, saying: @pl \a -> [2*a, 42] !! fromEnum (a == 5)
14:26:42 <EvanR-work> the file eventually got large enough that it caused a stack overflow, but the file is only 250k
14:26:50 <EvanR-work> http://codepad.org/MJzlX22H
14:27:21 <nschoe> jmcarthur: We just need to be sure we're checking a square which is inside the room
14:27:39 <nschoe> Two possibilities here:
14:27:49 <jmcarthur> nschoe: i believe that is is impossible to do otherwise because we are not allowing the AI to move to an outside location already, right?
14:28:05 <jmcarthur> i want to hear what you are thinking though
14:28:59 <nschoe> 1/ the robot can only check his current position for dust, this way we don't need extra info (we ssume the robot cannot move outside the map) 2/ we have a sensor that can check a square just next to our position (and if we're just near one end of the map, we must chekc that we don't try to inspect outside)
14:29:17 <jmcarthur> oh i was making an assumption about how the sensor worked
14:29:38 <youngbull> @pl \x y z -> x && y || not z
14:29:38 <lambdabot> flip flip not . (((.) . (||)) .) . (&&)
14:29:44 <jmcarthur> for your second suggestion, or isClean action has the wrong interface
14:29:46 <EvanR-work> guess i could rewrite this section with ByteString
14:30:02 <youngbull> @hotsnack
14:30:02 <lambdabot> :)
14:30:15 <nschoe> jmcarthur: I think you were making the good assumption, I think we can only check the current square, it was just ... I don't know an extension. Maybe one day I'll try something that works that way.
14:30:27 <jmcarthur> nschoe: because we can't be sure which adjacent square we're checking
14:30:32 <jmcarthur> with the current interface
14:30:51 <jmcarthur> okay, so we agree that the AI can only check the current square?
14:31:05 <jmcarthur> *current position
14:31:05 <nschoe> But I think it's good for now to assume we can only check the current square. Yep
14:31:18 <jmcarthur> let's call squares "positions" for consistency
14:31:25 <jmcarthur> i keep having to check myself
14:31:35 <nschoe> ok np^^
14:31:37 <nschoe> Just a question.
14:31:38 <jmcarthur> so DirtySquares is DirtyPositions
14:31:42 <jmcarthur> shoot
14:32:37 <nschoe> We have type DirtyPositions = Set Position, right? But, how is DirtyPositions filled in? I mean the AI cannot know in advance which positions are dirty.
14:32:47 <jmcarthur> nschoe: great question
14:32:58 <alpounet> EvanR-work, yeah i'd recommend rewriting your code with ByteString -- or Text maybe ?
14:33:02 <jmcarthur> nschoe: the answer is that our AI isn't complete yet
14:33:15 <nschoe> AI ou API?
14:33:16 <jmcarthur> nschoe: we will also need to expose functions for the shell to run it
14:33:22 <jmcarthur> API yes sorry
14:33:42 <jmcarthur> nschoe: our "run" function will be responsible for supplying this information
14:34:00 <nschoe> jmcarthur: oh okay.
14:34:05 <EvanR-work> alpounet: its domain names, so Word8 is ok
14:34:15 <nschoe> Well then another question.
14:34:26 <jmcarthur> ask as many as you need
14:34:36 <alpounet> oh, yeah then ok EvanR-work 
14:36:07 <nschoe> (lol that's a very dangerous thing to tell me: I really love learning so I ask dozens of questions) : If I understand correctly, when the AI is on a square, when it wants to chekc fo dust it will test whether its current Position is in hte Set os DirtyPositions, right? But, if (later, not now) we want to be a bit more realistic, and allow our sensor to be wrong let's say 5% of the time, will we have a lot of work to implement that?
14:36:44 <jmcarthur> nschoe: are you asking about extending the API or extending the implementation?
14:37:20 <jmcarthur> if you mean the latter, i don't believe that it would be too much extra work
14:37:42 <jmcarthur> changing an API we are already using tends to be tougher than changing an implementation
14:37:49 <jmcarthur> that's why we are spending so much effort up front on the API
14:38:26 <jmcarthur> another reason we are doing it is because there's nothing like the warm fuzzy feeling of an elegant API :)
14:38:31 <nschoe> jmcarthur: I don't think it means changing the API. It's just that instead of just checkin for membership in a Set, it would give the wrong answer 5 times out of 100.
14:38:49 <jmcarthur> okay. what you describe doesn't sounds like a difficult extension
14:38:51 <nschoe> jmcarthur: Yeah I begin to understand what you mean^^
14:39:05 <nschoe> jmcarthur: That's what I thought, Okay thanks, yo ucna go on ^^
14:39:17 <jmcarthur> nschoe: it would potentially change the run function's interface, but as far as the AI is concerned there is no interface difference
14:39:37 <jmcarthur> as for the implementation, you'll see
14:39:53 <jmcarthur> nschoe: okay, so you're with me that isClean will require the Position and the DirtyPositions?
14:39:55 <nschoe> jmcarthur: okay. Wow that API thing, I'd have never thought of beginning by that. I do lack *years* of experience ^^
14:40:02 <dankna> so.  I have the dubious pleasure of needing to upgrade to ghc 7.0 because of an obscure Template Haskell feature that went in it six weeks ago.
14:40:04 <nschoe> Yes, I agree.
14:40:20 <dankna> is it possible - I'm on a Mac - to do this and keep my current installation as well?
14:40:22 <kmc> dankna, ah, the joys of Template Haskell
14:40:29 <dankna> yeah, indeed
14:40:37 <jmcarthur> nschoe: if we were to implement isClean as a "pure" function using this information that the AI will not have access to, can you suggest what type signature it would have?
14:40:39 <kmc> dankna, probably, just pick a new prefix and pass --prefix to configure
14:40:44 <dankna> ah!  good idea
14:40:47 <dankna> thanks :)
14:41:49 <pumpkin> dankna: or just use the .pkg installer
14:42:00 <nschoe> jmcarthur: I didn't understand fully the question, what do you bean by "using the information that hte AI will not have access to" ?
14:42:01 <pumpkin>  /Library/Frameworks/GHC.framework/Versions contains the various ones you have
14:42:10 <pumpkin> cabal keeps them separate
14:42:16 <dankna> oh!  right, unlike the last time I did this, they will have different version numbers.  good.
14:42:26 <jmcarthur> nschoe: i will just give the answer to this one and you can answer this question for the other actions once we get to them
14:42:28 <dankna> (last time was a stable 6.12 and a development one, or something along those lines)
14:42:39 <nschoe> Ok, sry :/
14:42:40 <dankna> I like that solution better than using a prefix
14:42:44 <jmcarthur> nschoe: let's call the "pure" version of this function, isClean' to distinuigh it from the version we plan to expose
14:42:52 <nschoe> It's just all pretty new to me.
14:42:57 <nschoe> ok
14:43:01 <jmcarthur> nschoe: no don't apologize. when you are learning it's often as hard to understand the questions as it is the answers
14:43:15 <nschoe> That's definitely right.
14:43:27 <jmcarthur> nschoe: isClean' :: Position -> DirtyPositions -> Bool
14:43:50 <jmcarthur> nschoe: you should note that for later
14:43:54 <nschoe> Okay, simple enough atually. I could have answered that
14:44:01 <jmcarthur> yeah. that's usually how it works ;)
14:44:07 * magicman sees a job for Control.Monad.Prompt, but also sees how that would be pushing it.
14:44:15 <jmcarthur> magicman: i saw that too ;)
14:44:16 <nschoe> Hum just a tweakL shouldn't we flip the Position and DirtyPosition arguments?
14:44:25 <jmcarthur> nschoe: i'm curious. why?
14:44:51 <magicman> Interesting discussion, though. Don't mind if I sit in the back of the classroom making notes :)
14:45:03 <jmcarthur> magicman: :)
14:45:33 * hackagebot network 2.2.1.10 - Networking-related facilities  http://hackage.haskell.org/package/network-2.2.1.10 (JohanTibell)
14:45:33 <nschoe> I mean for partial applications sake, I think it's better to partially applu isClean' mySetofDirtyPos to check other positions?
14:45:57 <nschoe> When I create function I always think about the order carefully : what would make the more sense.
14:46:30 <jmcarthur> nschoe: astute!
14:46:45 <jmcarthur> nschoe: however, i have two points to make
14:47:00 <pumpkin> how does monadprompt differ from the operational monad?
14:47:00 <jmcarthur> nschoe: (1) this function will not be exposed, so client code won't touch it
14:47:30 <jmcarthur> nschoe: (2) even if this function was exposed, this isn't something we intend for the AI to have access to, right?
14:47:50 <jmcarthur> nschoe: surprise (3) this type signature works out well for our implementation
14:48:06 <nschoe> yeah totally, it was just... that it seemed more logical. But okay, let's go with it^^
14:48:13 <jmcarthur> nschoe: isClean' = Data.Set.member
14:48:24 <alpounet> @type Data.Set.member
14:48:25 <lambdabot> forall a. (Ord a) => a -> S.Set a -> Bool
14:49:02 <jmcarthur> nschoe: i do like that you thought of that though, and if it was ever going to be exposed in the API it would be very important to consider that
14:49:22 <nschoe> jmcarthur: okay. Thanks
14:49:50 <jmcarthur> nschoe: anyway, isClean' :: Position -> DirtyPositions -> Bool suggests something about our Info type constructor
14:49:54 <jmcarthur> can you see it?
14:50:01 <c_wraith> Hm.  mtl 2 is out, and depends on monads-fd.  Let the great mtl purge begin!
14:50:28 <jmcarthur> nschoe: it's a vague question, i know
14:50:45 <benmachine> c_wraith: iiiinteresting
14:51:02 <kmc> it depends on transformers
14:51:02 <jmcarthur> nschoe: but just compare   isClean' :: Position -> DirtyPositions -> Bool   to   isClean :: Info Bool
14:51:03 <benmachine> c_wraith: but when do we switch to monads-tf :P
14:51:08 <wlangstroth> c_wraith: sweet!
14:51:09 <kmc> not monads-fd or monads-tf
14:51:15 <c_wraith> oh, so it does.
14:51:16 <pumpkin> oh I guess the operational monad and monadprompt are known to be pretty similar
14:51:17 <nschoe> it must implement Eq typeclass, no?
14:51:35 <jmcarthur> nschoe: you mean Position?
14:52:13 <nschoe> jmcarthur: Yep. But that's not Info, discard what I've jsut said.
14:52:17 <jmcarthur> nschoe: even stronger, Position must implement Ord (due to that ugly thing about Set that i mentioned earlier)
14:52:30 <jmcarthur> nschoe: anyway, but yeah, that's not quite what i meant
14:52:53 <nschoe> jmcarthur: hum. Sorry I don't really see the problem here.
14:52:53 <c_wraith> In any case, no more conflicting definitions, once everything that uses mtl upgrades to mtl 2. :)
14:52:54 <jmcarthur> nschoe: shall i just say it? you will have opportunity to answer the same question for later actions
14:53:04 <benmachine> c_wraith: not no more, I think, but fewer :)
14:53:06 <jmcarthur> nschoe: well, it's not a problem. it's an interesting observation
14:53:10 <nschoe> jmcarthur: I hate giving up, but yes say it :/
14:53:12 <pumpkin> both seem to just be free monads with helper APIs?
14:54:03 * benmachine wonders if there are any actually major changes to mtl
14:54:09 <jmcarthur> nschoe: we could define isClean pretty trivially if Info was defined like this:    type Info a = Position -> DirtyPositions -> a
14:54:26 <kmc> well, in mtl2, (State s) is a synonym for (StateT s Identity)
14:54:43 <benmachine> kmc: but that's more or less transparent, right?
14:54:53 <benmachine> also, mtl2 depends on base < 6, ew
14:54:59 <kmc> well, it will certainly allow some new code to work that wouldn't before
14:55:03 <kmc> i don't know if it can break old code
14:55:05 <jmcarthur> nschoe: and i await a reaction before moving on :)
14:55:21 <nschoe> jmcarthur: That would be pointless to define "move"
14:55:31 <jmcarthur> nschoe: agreed. we haven't looked at move yet ;)
14:55:49 * benmachine tries to work out if mtl is now entirely re-exports
14:56:23 <benmachine> does rather seem so.
14:56:35 <benmachine> oh no wait
14:56:48 <benmachine> it still defines class MonadRWS
14:56:57 <nschoe> jmcarthur: So we're facing something here: either we define Info the way you offered, and accept the fct that move is passed down useless information, or we don't and add some extra work at each function.
14:57:02 <kmc> yeah, it's still defining the monads-fd-like classes
14:57:04 <jmcarthur> nschoe: i just want you to see that if we *only* cared about isClean, this would be trivial, right?
14:57:08 <benmachine> mm
14:57:13 <nschoe> I would recommend the latter because it makes more sens,e it seems logical to me.
14:57:38 <nschoe> jmcarthur: yeah, I understand that.
14:57:55 <jmcarthur> nschoe: i'm suggesting that in isolation we would be done, but later we will have to make Info more powerful
14:58:06 <jmcarthur> nschoe: consider this definition of Info to be a starting point
14:58:21 <nschoe> type Info a = Position -> DirtyPositions -> a <--- this one?
14:58:34 <jmcarthur> yes
14:58:38 <jmcarthur> we will have to add to it later
14:59:00 <jmcarthur> and yes, move doesn't need DirtyPositions, you're right
14:59:10 <jmcarthur> we will discuss that when it's time to
14:59:12 <pumpkin> I want GADTs in haskell 2011
14:59:14 <pumpkin> is it too late? :P
14:59:25 <c_wraith> probably.  campaign for 2012.
14:59:33 <nschoe> Ok I wrote the Info definition.
14:59:38 <jmcarthur> alright
15:00:03 <jmcarthur> so, like i said, if we only needed isClean, we'd be done, but we need more. we can move on to the "move" action now
15:00:28 <nschoe> ok
15:00:42 <jmcarthur> nschoe: what would be the type of the pure version of move (call it move' for the distinction)
15:00:47 <jmcarthur> ?
15:01:18 <jmcarthur> this one is a bit tougher than it was for isClean'
15:01:24 <jmcarthur> but not too bad
15:01:49 <xxxxxx_> (for all x p(x)) =>q(a) is equivalent of (there exist x p(x)) =>q(a) 
15:01:51 <xxxxxx_> ?
15:02:12 <monochrom> no, but I suspect you're just typoing.
15:02:25 <nschoe> I'd say : move :: Position -> Direction -> (DirtyPositions, Walls) -> ()
15:02:46 <jmcarthur> nschoe: okay, that was not the answer i was hoping for
15:02:50 <Twey> Um, functions to () are not generally very useful — what's going on here?
15:03:00 <jmcarthur> Twey: we were talking about impure functions earlier
15:03:03 <jmcarthur> Twey: don't worry about it :)
15:03:07 <Twey> Oh, okay.
15:03:12 * Twey potters off.
15:03:22 <jmcarthur> nschoe: the move function has to change something
15:03:23 <monochrom> (∀x. p(x) ⇒ q) is (∃x.p(x)) ⇒ q. (∀x. p(x)) ⇒ q is (∃x.p(x) ⇒  q).
15:03:29 <nschoe> Twey: (I'm just learning, so jmcarthur is explaing for me ^^)
15:03:30 * benmachine harries Twey 
15:03:32 <jmcarthur> nschoe: therefore the move' function needs to return something
15:03:52 <nschoe> jmcarthur: oh yeah I forgot it was the prime function. Sry.
15:03:53 <EvanR-work> alpounet: that seems to have fixed it, i wonder if the profile would show that it is much better
15:03:54 <jmcarthur> nschoe: specifically, it needs to return new version(s) of whatever it changes
15:04:10 <nschoe> But it does need the position and the direction to know where to start from, right?
15:04:18 <jmcarthur> i would say so
15:04:35 <Philippa> pumpkin: It looks like there's a major tradeoff to be made for GADTs, at this point
15:04:39 <monochrom> http://www.umsu.de/logik/trees/ is a very useful logic checker
15:04:43 <nschoe> jmcarthur: yeah I see what you mean, the primes functions are the function I pasted on hpaste : hte "bad" ones.
15:04:44 <alpounet> EvanR-work, i suggest you test out hp2any
15:04:44 <Philippa> namely local generalisation
15:04:46 <pumpkin> Philippa: what's that?
15:04:50 <jmcarthur> nschoe: recall that move :: Direction -> Info (), so we know already that it needs Direction
15:04:53 <Philippa> (to be fair, "major" depends on your POV)
15:04:59 <pumpkin> ah
15:05:04 <Philippa> see "Let Should Not Be Generalised"
15:05:06 <pumpkin> yeah
15:05:11 <pumpkin> I wonder who actually cares
15:05:40 <dankna> hmm
15:05:43 <nschoe> yeah?
15:05:49 <jmcarthur> nschoe: well, i'm going to make a change to my wording about those functions. they are not "bad" to exist, just bad to expose :)
15:06:02 <dankna> I just figured out that the reason GHC's ./configure always tells me DocBook XSL isn't found is that my version is newer than the one it's expecting
15:06:11 <dankna> I suppose I ought to fix that in aclocal.m4 and submit a patch :/
15:06:13 <dankna> yay, work
15:06:13 <xxxxxx_> monochrom: did not get :(
15:06:33 <EvanR-work> alpounet: ill have to do that
15:06:35 <nschoe> yeah, okay. Not the ones we would choose in our API.
15:06:38 <dankna> honestly, DocBook is an abomination.  (Unfortunately the best abomination of its kind.)
15:06:40 <EvanR-work> but not on the production 'script' ;)
15:06:48 <jmcarthur> nschoe: so my question is: if you were to write move' with no fancy Info constructor, you would have to parameterize it on all the necessary data and also return anything that's changed
15:06:54 <monochrom> did not get what?
15:06:54 <jmcarthur> nschoe: so what type is move' ?
15:07:31 <jmcarthur> nschoe: i'm not expecting a type signature that has () at all because that's just not very meaningful in a pure function like this
15:08:16 <EvanR-work> alpounet: hp2any is specifically for haskell? is better than hp2ps, which isnt just for haskell?
15:08:30 <EvanR-work> or whats the standard memory profiler for haskell
15:08:35 <nschoe> jmcarthur: Well, the necessary data is : the position, the direction, the room, and it should return... hum the "new" room? Well that doesn't really make sense because we don't modify the room itself.
15:08:47 <jmcarthur> nschoe: room = walls?
15:09:05 <jmcarthur> trying to stick with a common terminology
15:09:05 <nschoe> no by room I meant walls + dirtypositions
15:09:08 <jmcarthur> ah
15:09:16 <jmcarthur> well, no, that didn't really change
15:09:42 <jmcarthur> only one thing actually changed
15:10:16 <nschoe> Well to be honest there's something I don't totally understand: how do we represent the room? I mean we have a set of dirtypositions, a set of walls, but what about the others?
15:10:26 <jmcarthur> other whats?
15:10:33 <jmcarthur> the other positions?
15:10:35 <nschoe> the squares that are clean
15:10:38 <nschoe> Yeah the positiosn sorry.
15:10:43 <jmcarthur> do we have to repreent them?
15:10:47 <jmcarthur> *represent
15:10:48 <xxxxxx_> monochrom: what u wrote? is they equivalent what I wrote?
15:11:16 <jmcarthur> nschoe: that is actually an excellent question
15:11:26 <jmcarthur> nschoe: what *is* a room?
15:11:38 <monochrom> no. here: http://www.vex.net/~trebla/humour/lmcify.html?t=%28%E2%88%80x.+p%28x%29+%E2%87%92+q%29+is+%28%E2%88%83x.p%28x%29%29+%E2%87%92+q.+%28%E2%88%80x.+p%28x%29%29+%E2%87%92+q+is+%28%E2%88%83x.p%28x%29+%E2%87%92++q%29.
15:11:45 <jmcarthur> this is a bit tangential, but good to get the feeling of
15:11:53 <nschoe> jmcarthur: Well we could get rid of them : assuming that everything is either a wall, a dirty position or a clean one
15:12:23 <jmcarthur> nschoe: i would say that a room is whatever you can observe about it
15:12:33 <jmcarthur> what can you observe about a room?
15:12:52 <nschoe> Hum its positions?
15:13:01 <hpc> probability of being eaten by a grue ;)
15:13:10 <jmcarthur> so you would like to say that a room is a set of positions?
15:13:27 <jmcarthur> if so, then this is a different model than i have been using
15:13:35 <jmcarthur> note that i'm saying "set" and not Set
15:13:43 <jmcarthur> i really want to emphasize that we are talking maths here
15:13:53 <nschoe> I mean you can say : room A is a 5x5 square, with every peripheral positions being a wall, and all the other ones being dirty.
15:14:16 <xxxxxx_> monochrom: could u give me an example where they are not equivalent?
15:14:19 <jmcarthur> that is a definition, but i'm looking for a semantics
15:14:30 <nschoe> (I love maths and study them so every time you can compare something to Maths pease do: I get it more easyly). 
15:14:36 <jmcarthur> nschoe: i'm looking specifically for the things that are observable about a room
15:14:37 <nschoe> yeah a room is a set of positions.
15:14:57 <jmcarthur> nschoe: if a room is a set of positions, that implies a few things:
15:14:57 * shapr hugs jmcarthur
15:15:32 <jmcarthur> nschoe: your denotation makes it possible to have a room containing sparse positions
15:15:43 <jmcarthur> nschoe: is that, in your mind, a valid scenario?
15:15:53 <jmcarthur> by "sparse" i mean "unconnected"
15:15:59 <nschoe> Yeah.
15:16:03 <nschoe> Well actually it doesnt.
15:16:15 <nschoe> By... how to model that then?
15:16:32 <jmcarthur> model what? sparse positions?
15:16:43 <jmcarthur> {(1,1), (5,5)}  <-- is that a valid room?
15:16:44 * hackagebot websockets 0.1.1.5 - Implements the WebSocket protocol.  http://hackage.haskell.org/package/websockets-0.1.1.5 (SinisaBidin)
15:16:49 <nschoe> No model the fact that a room doesn't contain sparse positions.
15:16:53 <jmcarthur> ah!
15:17:05 <nschoe> I can think of one way but it's pretty "heavy".
15:17:18 <shapr> jmcarthur: You gonna bring your redux0r interpreter to the shop tonight?
15:17:40 <monochrom> this gives an example: http://www.umsu.de/logik/trees/?f=%28%28\forall%20x%20Px%29%20\to%20Q%29%20\leftrightarrow%20%28%28\exists%20x%20P%20x%29%20\to%20Q%29
15:18:08 <jmcarthur> nschoe: the model i was working with is Position->(IsWall,IsDirty)      and yes, that includes the meaningless possibility that a wall can be clean or dirty
15:18:14 <jmcarthur> shapr: tonight?
15:18:20 <jmcarthur> shapr: it's not working yet anyway
15:18:58 <shapr> jmcarthur: Well, I was going to knit... but if you want to show up and talk code...
15:19:24 <nschoe> Position->(IsWall,IsDirty) <-- it is the model of a room?
15:19:29 <jmcarthur> nschoe: so assuming that Position=(Integer,Integer), that means my model for Room is that it is infinite along both directions and contains walls and dirty spots
15:19:55 <EvanR-work> redux0r? shop?
15:19:58 <jmcarthur> where the walls and dirty positions may be sparse, but the positions themselves are in fact dense
15:20:09 <nschoe> okay but how do we set the "range" of the room (the AI cannot go out of the room).
15:20:18 <benmachine> nschoe: can walls be dirty?
15:20:35 <jmcarthur> nschoe: my intent was to say that the AI can simply not walk onto walls, and if the walls happen to enclose the AI then that works for our purposes
15:20:44 <jmcarthur> benmachine: the answer is no
15:20:46 <shapr> EvanR-work: jmcarthur and I are physically near a hackerspace here in Huntsville Alabama. I was wondering if he wanted some in-person input on whatever code he's doing.
15:20:48 <jmcarthur> benmachine: that is a flaw in my model
15:20:51 <nschoe> benmachine: well as a robot cannot go on a wall, it's pointless to say it can be dirty.
15:21:04 <EvanR-work> shapr: code?! in person!? unheard of
15:21:08 <benmachine> jmcarthur: oh right, yes, sorry
15:21:12 * benmachine didn't read up
15:21:37 <nschoe> jmcarthur: yes okay, so we just have ot be careful to enclose every "map" we draw with walls.
15:21:41 <nschoe> That's fine with me.
15:21:48 <jmcarthur> nschoe: there is in fact a nicer model that eliminates that whole clean/dirty walls thing
15:21:57 <nschoe> oh?
15:22:33 <jmcarthur> Position -> Maybe IsClean
15:22:37 <jmcarthur> where Nothing means it's a wall
15:23:48 <nschoe> Hum why not : Position -> (IsWall, Maybe IsClean) ?
15:23:53 <jmcarthur> nschoe: but yes, depending on what we actually want, the burden of ensuring that the AI is fully enclosed by walls may be an annoyance
15:23:58 <EvanR-work> no, no bools!
15:24:12 <jmcarthur> nschoe: consider (True, Just False)
15:24:32 <jmcarthur> nschoe: that would denote a wall that is dirty
15:24:56 <nschoe> jmcarthur: Just assume that we discard the second element when the first is True?
15:25:18 <jmcarthur> nschoe: then why bother with the Maybe at all?
15:25:30 <jmcarthur> nschoe: without the Maybe that degenerates into the model i've been working with the whole time ;)
15:25:49 <nschoe> It reminds me of "implication" in Maths: you can say : (Pi = 8,5) => (2+5 = 9) That proposition is right, because the first member if fals.e Se what I mean?
15:26:04 <nschoe> jmcarthur: Yeah you're right.
15:26:19 <jmcarthur> nschoe: implication at the type level is (->) :)
15:26:20 <nschoe> jmcarthur: I think the former model you gave was the best one.
15:26:36 <jmcarthur> nschoe: i disagree. it is not the best model
15:26:43 <nschoe> jmcarthur: Well I was just talking Maths here, not haskell^^
15:26:45 <nschoe> Oh ? Okay.
15:26:53 <nschoe> So you'd rather use the latter?
15:27:00 <jmcarthur> nschoe: the Position -> Maybe IsClean, IMO, is the best model we have discussed so far
15:27:19 <jmcarthur> nschoe: i just would rather not use that as our implementation
15:27:38 <nschoe> Okay, let's use that then..
15:27:39 <jmcarthur> nschoe: Position -> (IsWall, IsClean) will turn out to be a slightly nicer implementation
15:27:41 <nschoe> then. *
15:27:48 <nschoe> ?
15:27:55 <jmcarthur> nschoe: or, equivalently, (Position->IsWall,Position->IsClean)
15:28:03 <nschoe> But you said it wa not the best model.
15:28:09 <jmcarthur> nschoe: in other words, (Walls, DirtyPositions) ;)
15:28:21 <jmcarthur> perhaps that should be CleanPositions
15:28:29 <jmcarthur> that would be rather dense though
15:28:40 <hpc> it occurred to me that this conversation would be hilarious, taken out of context
15:28:45 <wlangstroth> jmcarthur: I'm confused - walls are places where the agent can't go, correct?
15:28:52 <nschoe> hpc: lol
15:28:57 <nschoe> wlangstroth: yes, that's it.
15:29:01 <jmcarthur> isClean' p = not . Data.Set.member p
15:29:03 <jmcarthur> nschoe: ^^
15:29:09 <jmcarthur> nschoe: i gave the wrong definition earlier
15:29:22 <jmcarthur> it's clean if it's not a member of our DirtyPositions
15:29:23 <nschoe> jmcarthur: now you confused me xD.
15:29:36 <jmcarthur> wlangstroth: correct
15:29:53 <jmcarthur> nschoe: where are you confused? i would like to clear this back up so we can get back on track
15:29:56 <wlangstroth> jmcarthur: so ... you only need to define squares/positions/whatever that aren't walls
15:30:07 <jmcarthur> wlangstroth: how would you do that?
15:30:15 <nschoe> jmcarthur: at the end, what model would you use?
15:30:29 <jmcarthur> nschoe: i would say there is no "one true way"
15:30:49 <nschoe> jmcarthur: yes I guess so, but what do *you* think is the best?
15:30:55 <jmcarthur> nschoe: different models denote different things. i think we have not come up with a perfect one, nor am i certain that it would be worth spending too much time on right now
15:31:37 <wlangstroth> jmcarthur: maybe I missed something, because it seems like if you only store coordinates that can be traversed, and they're either clean or dirty, you're done - were there other requirements?
15:31:45 <jmcarthur> nschoe: a perfect model would have the agent in an enclosed room by construction without the possibility of sparse positions
15:32:01 <jmcarthur> wlangstroth: you are suggesting something like Map Position IsClean?
15:32:27 <jmcarthur> that is, a finite map?
15:32:43 <benmachine> if you can only go one position to another, maybe a tree-like structure is what you want
15:32:46 <jmcarthur> nschoe: and also without the possibility of a wall being associated with cleanliness
15:32:48 <benmachine> actually
15:32:56 <benmachine> that would involve lots of knot-tying, might be a bit unpleasant
15:33:16 <jmcarthur> nschoe: i believe we have digressed too far from our original discussion. i would like to get back on topic
15:33:17 <benmachine> it's not a tree it's a graph
15:33:18 <nschoe> jmcarthur: I agree with that. But maybe we can deal with a not totally perfect model.
15:33:27 <jmcarthur> nschoe: that's what i'd like to do
15:33:39 <nschoe> jmcarthur: yeah definitely.
15:33:46 <jmcarthur> nschoe: okay, so... have you come up with a type for move' in the meantime?
15:33:49 <nschoe> jmcarthur: So, what are we using (just ot be clear)?
15:34:08 <wlangstroth> jmcarthur: yes
15:34:19 <jmcarthur> nschoe: we're in a way still defining that
15:34:26 <nschoe> ok.
15:34:28 <benmachine> (I was thinking of data Position = Position { clean :: Bool, left :: Maybe Position, right :: Maybe Position, ... })
15:34:33 <jmcarthur> wlangstroth: arguable, Map k a = k -> Maybe a ;)
15:34:49 <wlangstroth> benmachine: oh dear god
15:35:18 <benmachine> wlangstroth: it encodes the fact you only have local knowledge
15:35:29 <nschoe> jmcarthur: so... I'm not sure I can answer the question about move function.
15:35:32 <benmachine> there are some nasty tricks you could use to avoid the really tangly recursion I'm sure
15:35:32 <jmcarthur> nschoe: to catch back up, we had isClean' :: Position -> DirtyPositions -> Bool, and we are trying to come up with something for move'
15:35:34 <jmcarthur> nschoe: okay
15:35:38 <jmcarthur> nschoe: here's what i would say:
15:35:50 <jmcarthur> nschoe: move' :: Position -> Walls -> Position
15:35:56 <jmcarthur> oops
15:36:07 <jmcarthur> nschoe: move' :: Direction -> Position -> Walls -> Position
15:36:17 <jmcarthur> an important part ^_^
15:36:49 <jmcarthur> nschoe: what i had in mind was that when you move it checks to make sure that the position you want to move to is not a wall
15:36:54 <wlangstroth> benmachine: ahem ... I mean, for an explicit grid, that might be overkill
15:37:05 <nschoe> Oh yeah what didn't I think of that: we actually modify what? the position so it is what should be returned.
15:37:08 <nschoe> Damn...
15:37:10 <jmcarthur> so it needs direction, position, and walls, and it results in a (possibly) new position
15:37:10 <benmachine> wlangstroth: might be!
15:37:23 <jmcarthur> it can just return the old position if we don't actually move
15:37:30 <benmachine> wlangstroth: it's also invalid if you actually know what the whole room looks like, instead of just what's near you
15:37:32 <nschoe> jmcarthur: yeah, you're right...
15:37:39 <benmachine> but it's kinda neat anyways :P
15:37:42 <jmcarthur> because we are not going to actually tell the AI the it didn't move, as we agreed
15:38:01 <nschoe> yep.
15:38:25 <jmcarthur> nschoe: okay, now recall how we related the type of move' with the type of move to come up with a candidate for Info?
15:38:32 <jmcarthur> duh
15:38:32 <wlangstroth> jmcarthur: right, then you're only dealing with the agent and the environment
15:38:36 <jmcarthur> isClean and isClean'
15:38:43 <nschoe> yes.
15:38:49 <jmcarthur> nschoe: we're going to do the same thing for move and move' now
15:39:01 <jmcarthur> nschoe: ignore what we came up with in the case of isClean
15:39:10 <jmcarthur> nschoe: we will merge our two notions of Info in a sec
15:39:20 <nschoe> hum.
15:39:34 <jmcarthur> nschoe: can you fill in the blank here: type Info a = <blank> ?
15:39:52 <jmcarthur> nschoe: such that it's exactly what we need to turn move' into move :: Position -> Info ()
15:40:04 <jmcarthur> almost exactly, ayway
15:40:06 <jmcarthur> *anyway
15:40:09 <byorgey> djahandarie: nope, not yet =)
15:40:20 <nschoe> jmcarthur: wow, hum gimem a second ^^
15:40:28 <jmcarthur> k
15:40:37 <jmcarthur> nschoe: i'm going to take a quick break and be back in a minute
15:40:45 <nschoe> jmcarthur: np.
15:40:50 <jmcarthur> nschoe: feel free to flood #haskell with thoughts. i will read back when i return
15:43:48 <jmcarthur> nschoe: okay, i'm going to eat with my wife fairly soon, but we have a little time yet
15:44:26 <nschoe> jmcarthur: yeah no problem. Just tell me when you have to go.
15:44:29 <jmcarthur> sure
15:44:37 <nschoe> (Anyway I'll have to go to sleep eventually^^)
15:44:46 <jmcarthur> if this conversation gets cut short i don't mind starting it back again at some later point
15:44:59 <nschoe> jmcarthur: well in the case of isClean we used Data.Set.member.
15:45:10 <jmcarthur> oh i'm not asking for an implementation
15:45:17 <nschoe> I think we would use something with Data.Set.insert for "move". But I'm not sure how.
15:45:26 <djahandarie> :(
15:45:33 <jmcarthur> i'm only asking for a candidate type alias for Info
15:45:48 <jmcarthur> if we compare these two type signatures it can give us an idea:
15:45:52 <nschoe> jmcarthur: yeah I know, it's just it seems very logical in the case of isClean.
15:45:56 <jmcarthur> move :: Direction -> Info ()
15:46:06 <jmcarthur> move' :: Direction -> Position -> Walls -> Position
15:46:29 <nschoe> how idiot is it to say : Info a = Direction → Position → Wall -> a ?
15:46:38 <jmcarthur> not idiotic
15:46:47 <jmcarthur> incorrect, but close
15:47:06 <jmcarthur> let's expand that into the type of move and see what that gave us
15:47:37 <jmcarthur> move :: Direction -> Info ()  ==>  move :: Direction -> Direction -> Position -> Walls -> ()
15:47:46 <jmcarthur> so there's a couple things wrong with that
15:47:53 <jmcarthur> one is that we duplicated the Direction parameter
15:48:04 <jmcarthur> the other is that the new Position didn't work its way into that at all
15:48:16 <nschoe> Hum...
15:48:29 <Veinor> i think I'm going to write a haskell newbie's guide to text.json
15:48:29 <nschoe> okay so...
15:48:40 <nschoe> wait a second...
15:48:41 <jmcarthur> our goals is something that looks similar to Direction -> Position -> Walls -> Position
15:48:44 <jmcarthur> *goal
15:49:03 <nschoe> Info a = Position -> Walls -> Position -> a ?
15:49:17 <jmcarthur> that's taking two Position parameters rather than returning one
15:49:23 <jmcarthur> i can spoil it
15:49:27 <jmcarthur> if you'd like
15:49:38 <jmcarthur> actually, i'll just offer a hint
15:49:50 <adimit> erhm... does Cabal-Install have trouble with Unicode in module/path names now, or is that just my system?
15:50:11 <jmcarthur> nschoe: how would you normally return two values from a single function?
15:50:33 <jmcarthur> nschoe: we want to return both the 'a' type and the 'Position' type
15:50:53 <nschoe> type Info a = Position -> Walls -> a then?
15:51:00 <jmcarthur> close
15:51:07 <jmcarthur> we still aren't getting that new position though
15:51:13 <nschoe> Why?
15:51:23 <nschoe> In this case, move :: Direction -> Info Position no?
15:51:25 <jmcarthur> we are returning an a
15:51:31 <alpounet> nschoe, we *always* want a position
15:51:34 <alpounet> and something else along
15:51:39 <jmcarthur> alpounet: ssh :P
15:51:43 <alpounet> (yeah, i'm still around)
15:51:49 <nschoe> Damn.
15:51:57 <jmcarthur> nschoe: okay check out that type signature you just gave
15:52:03 <nschoe> yeah?
15:52:07 <jmcarthur> nschoe: you are making the AI have to keep up with its own Position now!
15:52:45 <jmcarthur> we were going to handle that for it (and in fact offer a getPosition action)
15:53:08 <nschoe> The only thing that solves it (and that I can think of) involves returning a tuple
15:53:13 <jmcarthur> nschoe: yes!
15:53:18 <nschoe> of (Position, a), but tha'ts innapropriate, right?
15:53:24 <jmcarthur> nope, that's exactly what we want
15:53:42 <nschoe> Hum..
15:53:51 <Cale> @bot
15:53:51 <lambdabot> :)
15:53:55 <nschoe> type Info a = Position -> Walls -> (Position, a) so?
15:53:58 <jmcarthur> nschoe: remember, Info is ultimately going to be abstract. that means client code won't be able to see inside, so it doesn't matter if it's a tuple inside. outside we only see the a
15:54:02 <jmcarthur> nschoe: perfect
15:54:18 <nschoe> Hum okay...
15:54:35 <nschoe> S now we have to create Info type that suits both move and isClean ?
15:54:35 <jmcarthur> that means when we expand it into move, we get  Direction -> Position -> Walls -> (Position, ())
15:54:41 <jmcarthur> yeah
15:54:54 <xxxxxx_> for all x g(x)->p <=====>  (there exist x g(x)) ->p?
15:55:28 <jmcarthur> if my memory serves me well, our previous definition for Info was Position -> DirtyPositions -> a ?
15:55:43 <nschoe> yep.
15:56:08 <jmcarthur> i think it should be a simple matter to merge these two things into an appropriately powerful type alias
15:56:21 <nschoe> Is it simply a merging thing ?
15:56:22 <jmcarthur> (it's only a type alias for now. eventually it will be a newtype so we can hide how it works)
15:56:24 <jmcarthur> yeah
15:56:36 <jmcarthur> we just want to have the powers of both
15:56:44 <byorgey> xxxxxx_: yes
15:56:49 <jmcarthur> even if it means individual operations don't need all that power at once
15:56:54 <nschoe> Smth like : type Info a = Position -< DirtyPositions -> Walls -> (Position, a) ? 
15:57:04 <byorgey> xxxxxx_: http://blog.ezyang.com/2010/10/existential-type-curry/
15:57:11 <jmcarthur> looks good to me, modulo typos ;)
15:57:31 <nschoe> yeahs sorry finger hit the wrong key^^
15:57:47 <jmcarthur> so that covers both isClean and move. is getPosition the only one left?
15:58:21 <nschoe> yeah we defined three things in our API.
15:58:43 <nschoe> We I think we have to come back on it since we had defined it as : getPosition ∷ Info (Position, Map)
15:58:53 <nschoe> We got rid of the Map type so...
15:59:02 <jmcarthur> there was a reason we did that
15:59:10 <hpc> nschoe: is it just me, or are those last two colons wonky?
15:59:15 <jmcarthur> we wanted to separate Walls from DirtyPositions
15:59:35 <jmcarthur> hpc: it a common abuse of the ratio symbol
15:59:40 <gwern> oh my god, are you guys still going over this AI thing?
15:59:49 <jmcarthur> gwern: it's slow paced, yes :)
16:00:00 <gwern> it really didn't sound like something that needed 6 or 8 hours of discussion
16:00:01 <nschoe> gwern: Yeah, I'm pretty slow on that :p
16:00:15 <gwern> especially with no running code or anything
16:00:19 <jmcarthur> gwern: this is more about design process than this particular problem
16:00:20 <alpounet> not for you gwern 
16:00:20 <ddarius> gwern: Now you know better.
16:00:30 <alpounet> that's more of a thought process course
16:00:33 <gwern> ddarius: I cherished my illusions
16:00:41 <nschoe> gwern: Well it turns out that I'm getting information on a larger scale that I usually thought.
16:00:46 <ddarius> gwern: We all do.
16:01:31 <jmcarthur> nschoe: anyway, we separated Walls from DirtyPositions so that we could give one to the AI in isolation from the other
16:01:54 <jmcarthur> nschoe: so i would propose that it should be getPosition :: (Position, Walls)
16:02:14 <jmcarthur> nschoe: basically that's just saying "here's where you are and here's where you are not allowed to be"
16:02:28 <nschoe> yeah that's fine with me.
16:03:05 <jmcarthur> nschoe: i believe Info is already sufficient to provide this information
16:03:20 <jmcarthur> nschoe: all we need to do is give the type for our pure getPosition' function
16:03:27 <jmcarthur> just for clarity
16:05:40 <nschoe> jmcarthur: Yeah, but that's weird: isClean' returned its answer based on comparing the current position with the dirty ones, move needed a directoin, the current position and the set of not allowed ones, but what does getPosition need?
16:06:23 <jmcarthur> nschoe: well, it doesn't need to do any real computation, but it still needs the information it's returning
16:07:58 <nschoe> But getPosition :: Position -> Walls -> (Position, Walls) would not be of much sense...
16:08:08 <jmcarthur> why not?
16:08:15 <nschoe> We can't give "getPosition" the position we'd like it to give us oO
16:08:30 <jmcarthur> we aren't exposing that function
16:08:38 <jmcarthur> this is getPosition', not getPosition
16:08:53 <nschoe> Oh yeah...
16:09:07 <jmcarthur> but that's a good kind of suspicion. i'm glad you've caught on to it
16:09:31 <jmcarthur> recall that Position and Walls are already being provided in Info
16:09:47 <jmcarthur> so we can just use our existing definition for it
16:09:54 <nschoe> Hum okay.
16:10:28 <jmcarthur> so if we expand the type of getPosition, we get   Position -> DirtyPositions -> Walls -> (Position, (Position, Walls))
16:10:37 <nschoe> It makes sense: getPosition and isClean both share the same kind of signature: Info (X) whereas move is more of Y -> Info (X)
16:10:49 <jmcarthur> yeah!
16:11:07 <nschoe> is the redudance of Position in the return type a problem?
16:11:11 <jmcarthur> not at all
16:11:16 <jmcarthur> i was just about to say something about this
16:11:33 <jmcarthur> all three of our actions have redundancies in their fully expanded type signatures now
16:11:49 <jmcarthur> this is *entirely* the point, in fact
16:12:24 <jmcarthur> by creating this Info abstraction, we will be handling all these extra parameters on behalf of the AI
16:12:56 <jmcarthur> whenever the AI uses any particular action, we will be taking care of which parameters and return values the action really needs and ignoring the rest
16:13:27 <jmcarthur> this means the AI doesn't have to pass these parameters or plumb results from the last use of "move" to all the other actions itself
16:13:50 <nschoe> I see. Does it mean that, our implementation will be more modular: if we design another AI that use some additional information, we can still relie on the Info abstraction?
16:14:08 <jmcarthur> sure, we could wrap Info in something else, for example
16:14:19 <nschoe> hum kay.
16:14:31 <jmcarthur> in fact, we're going to get to exactly that idea now
16:14:53 <jmcarthur> this implementation for Info is... large, wouldn't you say?
16:15:17 <nschoe> yep^^
16:15:17 <jmcarthur> type Info a = Position -> DirtyPositions -> Walls -> (Position, a)
16:15:48 <nschoe> You mean we can do something about that?
16:15:48 <jmcarthur> manipulating all this stuff manually would be a pain
16:15:52 <jmcarthur> we should use some existing code
16:15:59 <nschoe> okay
16:16:20 <jmcarthur> you were already using a good candidate in your original code
16:16:32 <jmcarthur> State!
16:16:32 <nschoe> The State monad?
16:16:35 <jmcarthur> indeed
16:16:45 <jmcarthur> @unmtl State s a
16:16:45 <lambdabot> s -> (a, s)
16:16:51 <jmcarthur> that should look familiar now :)
16:17:01 <nschoe> Wow now comes the fun part...
16:17:07 <nschoe> Yeah it does.
16:17:43 <jmcarthur> i'm going to have to speed up now, so my approach will be a little less socratic
16:17:49 <jmcarthur> i apologize for that
16:18:28 <jmcarthur> if we substitute Position in place of s, we have captured one pattern in Info
16:18:35 <nschoe> jmcarthur: if you need to leave, please do. You've already explained a loooot to me tonight, so we can start the talk again later (if you're okay).
16:18:40 <jmcarthur> @unmtl State Position a
16:18:40 <lambdabot> Position -> (a, Position)
16:18:45 <nschoe> ok
16:18:58 <dobblego> is there a equalIgnoringCase :: String -> String -> Bool ?
16:18:59 <jmcarthur> now we still have that DirtyPositions -> Walls -> stuff
16:19:16 <jmcarthur> if we rearrange slightly:
16:19:37 <jmcarthur> DirtyPositions -> Walls -> Position -> (a, Position)
16:19:47 <nschoe> yep
16:19:49 <jmcarthur> do you agree that we still have effectively the same thing so far?
16:19:51 <jmcarthur> okay
16:20:00 <jmcarthur> now we see that we can call this:
16:20:09 <jmcarthur> DirtyPositions -> Walls -> State Position a
16:20:16 <kmc> :t (==) `on` map toLower
16:20:17 <lambdabot> [Char] -> [Char] -> Bool
16:20:21 <kmc> dobblego, ^^
16:20:22 <jmcarthur> thats what leaves us with DirtyPositions -> Walls ->
16:20:24 <Sgeo> Are there any good zipper tutorials that aren't http://en.wikibooks.org/wiki/Haskell/Zippers ?
16:20:28 <dobblego> kmc, ok cheers
16:20:29 <jmcarthur> we can capture that too
16:20:35 <nschoe> yes
16:20:43 <jmcarthur> @unmtl Reader r a
16:20:44 <lambdabot> r -> a
16:20:44 <gwern> dobblego: wouldn't be hard to write. do zipWith (== . toLower), if you follow
16:20:58 <jmcarthur> nschoe: Reader captures the pattern of taking a parameter, but not returning a new version of it
16:21:06 <jmcarthur> does that make sense?
16:21:06 <Twey> ((==) . toLower)
16:21:08 <nschoe> jmcarthur: ok.
16:21:16 <nschoe> We're going to stakc two Monadsm right?
16:21:17 <dobblego> sure
16:21:41 <jmcarthur> nschoe: well, ultimately, we will transform the State monad
16:21:53 <jmcarthur> nschoe: there is an alternative to this
16:22:08 <gwern> er, more like 'and . zipWith (\(a,b) -> toLower a == toLower b)', I suppose. forgot to turn the [Bool] into a Bool
16:22:13 <jmcarthur> nschoe: we could always return new DirtyPositions and Wall each time, even though they would always be the same
16:22:19 <jmcarthur> nschoe: that would mean we only have to use State
16:22:24 <gwern> @pl \(a,b) -> f a == f b
16:22:24 <lambdabot> uncurry ((. f) . (==) . f)
16:22:28 <gwern> blech
16:22:28 <jmcarthur> nschoe: and that would be somewhat like what you had before
16:22:31 <dobblego> @hoogle unionBy
16:22:34 <lambdabot> Data.List unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
16:22:35 <jmcarthur> except this time with a better defined API :)
16:22:39 <nschoe> jmcarthur: ok I get the similarityReader captures the pattern of taking a parameter, but not returning a new version of it.
16:22:44 <jmcarthur> okay
16:22:55 <jmcarthur> so here's another transformation:
16:22:55 <nschoe> ops sorry for pasting :/
16:23:15 <jmcarthur> (DirtyPositions, Walls) -> State Position a
16:23:24 <jmcarthur> still agree that this is the same?
16:23:26 * hackagebot regexpr 0.5.3 - regular expression like Perl/Ruby in Haskell  http://hackage.haskell.org/package/regexpr-0.5.3 (YoshikuniJujo)
16:23:36 <nschoe> yeah.
16:23:46 <jmcarthur> @mtl (DirtyPositions, Walls) -> State Position a
16:23:46 <lambdabot> Maybe you meant: ft map msg pl unmtl url
16:23:51 <jmcarthur> oh that should exist :P
16:23:53 <jmcarthur> oh well
16:24:06 <jmcarthur> nschoe: so i take it you are aware, roughly, of what a monad transformer is?
16:24:22 <nschoe> jmcarthur: roughly is the term, yeah :/
16:24:43 <jmcarthur> @unmtl ReaderT (DirtyPositions, Walls) (State Position) a
16:24:43 <lambdabot> DirtyPositions -> Walls -> Position -> (a, Position)
16:25:03 <nschoe> Wow... "magic" ^^
16:25:07 <jmcarthur> nschoe: okay, i admit, that's still pretty long, but it comes with benefits :)
16:25:16 <nschoe> lol
16:25:29 <jmcarthur> nschoe: that's a monad automatically, and it can handle a lot of "plumbing" on our behalf
16:25:46 <nschoe> Okay.
16:25:51 <jmcarthur> nschoe: before moving on i want to say one more thing about adapting this to a monad stack like this
16:26:03 <jmcarthur> nschoe: we could have just used state, like i said earlier
16:26:15 <nschoe> ... but?
16:26:21 <jmcarthur> @unmtl State (Position, DirtyPositions, Walls) a
16:26:21 <lambdabot> Position -> DirtyPositions -> Walls -> (a, Position, DirtyPositions, Walls)
16:26:31 <jmcarthur> it's more powerful than we need
16:26:35 <jmcarthur> that may be okay
16:26:46 <jmcarthur> you can use State if you feel that using ReaderT in addition is too much work
16:26:53 <jmcarthur> i will leave the choice up to you
16:27:17 <jmcarthur> if you squint, (Position, DirtyPositions, Walls) is equivalent to your original World type
16:27:20 <nschoe> jmcarthur: ReaderT seems more Haskellish, I'll stick to that.
16:27:24 <jmcarthur> giving you State World a
16:27:40 <dobblego> @hoogle intersectionBy
16:27:41 <lambdabot> No results found
16:27:53 <jmcarthur> nschoe: i would say that neither is more Haskellish. State simply leaves a little more room for error because it's a little more powerful than we need
16:28:37 <nschoe> ok, so let's use ReaderT: I'm here to learn afterall. I'll have to read again the chapter in RWH over monad transformers.
16:28:37 <jmcarthur> nschoe: we are down to raw implementation details now, and whatever ugly things you do here won't affect your API
16:28:43 <jmcarthur> okay
16:29:19 <jmcarthur> so type Info = ReaderT (DirtyPositions, Walls) (State Position)
16:29:31 <nschoe> noted.
16:29:42 <jmcarthur> nschoe: now all we have to do is hide the implementation
16:29:55 <jmcarthur> nschoe: step one: turn the type alias into a newtype
16:30:16 <jmcarthur> newtype Info a = Info { unInfo :: ReaderT (DirtyPositions, Walls) (State Position) a }
16:30:27 <nschoe> (he he it gets even longer :P )
16:30:39 <jmcarthur> nschoe: i'm using the record syntax as an idiom for unwrapping the newtype wrapper
16:30:56 <jmcarthur> nschoe: step two: only export the type constructor, *not* the value constructor:
16:31:09 <jmcarthur> module Whatever (Info ()) where ...
16:31:20 <nschoe> okay
16:31:33 <jmcarthur> nschoe: so already, all that monad transformer stuff is hidden
16:31:49 <jmcarthur> nschoe: step three: define your actions
16:32:30 <jmcarthur> nschoe: so you will need to define isClean :: Info Bool, move :: Direction -> Info (), and getPosition :: Info (Position, Walls)
16:32:45 <jmcarthur> nschoe: we'll either come back to that or skip it because i'm short on time
16:32:53 <jmcarthur> nschoe: step four: expose your actions
16:33:08 <jmcarthur> module Whatever (Info (), isClean, move, getPosition) where ...
16:33:14 <nschoe> (skip them for now, I'll try to do that on my own)
16:33:20 <jmcarthur> nschoe: step five: create your "run" function
16:33:46 <nschoe> okay.
16:33:47 <jmcarthur> okay, this is the part where we answer your questions about where all this data actually comes from
16:34:02 <nschoe> ^^
16:34:06 <jmcarthur> the run function will take this data as parameters!
16:34:33 <jmcarthur> and in fact, it will look a hell of a lot like our unwrapped Info type (before the transformer stack)
16:34:33 <nschoe> Lol, just... like that? ^^
16:35:10 <jmcarthur> @unmtl ReaderT (DirtyPositions, Walls) (State Position) a
16:35:10 <lambdabot> DirtyPositions -> Walls -> Position -> (a, Position)
16:35:18 <jmcarthur> now...
16:35:31 <jmcarthur> it's not *quite* like that
16:35:39 <jmcarthur> it has to take Info a as a parameter too
16:35:56 <jmcarthur> runInfo :: Info a -> DirtyPositions -> Walls -> Position -> (a, Position)
16:35:58 <jmcarthur> also...
16:36:24 <jmcarthur> we might choose not to return the final Positions, or perhaps not return the a, or perhaps not even return anything (although then what's the point?)
16:36:47 <jmcarthur> but the point is, that's how we run the whole thing
16:36:52 <nschoe> hum that runInfo function, is it the one thatwill "loop"?
16:37:02 <gwern> '30. In programming, everything we do is a special case of something more general &mdash; and often we know it too quickly.'
16:37:39 <jmcarthur> nschoe: i believe your AI will loop
16:37:55 <jmcarthur> nschoe: or do you mean you want to get the position after each step?
16:38:01 <jmcarthur> nschoe: it can be used either way
16:38:29 <nschoe> Hum yeah that would be useful: for instance to display the whole thing on the terminal: in order to keep track of the AI movements.
16:38:32 <jmcarthur> the loop can be external or it can be a part of the AI. if it's external, you can observe the change in position over time
16:38:39 <jmcarthur> aha
16:38:47 <jmcarthur> there are many ways to do it
16:38:58 <jmcarthur> you could even change the implementation of Info to do that for you!
16:39:16 <nschoe> xD
16:39:26 <jmcarthur> nschoe: for example, if you change the transformer stack such that it's on top of IO, you can output the AI's actions as it goes
16:39:37 <jmcarthur> nschoe: without changing the API (except for the run function)
16:39:55 <nschoe> it involves putting a third "stage" on the monad stack?
16:39:56 <jmcarthur> anyway, the final step is to export your run function
16:40:09 <jmcarthur> nschoe: well, you would have to put IO at the bottom because it has no transformer
16:40:23 <nschoe> Yeah I rememebr reading it on RWH
16:40:56 <jmcarthur> nschoe: so it would be a slightly more major change, but if you are using the type classes for those transformers in the first place, most of the code you already wrote should still work as written
16:41:07 <wlangstroth> gwern: too true
16:41:49 <jmcarthur> nschoe: so now you have created a language for your AI to use, and you can change how it's interpreted however you want (by changing the implementation and exposed run function)
16:42:08 <jmcarthur> nschoe: there are yet more cool things we could do to it, but i must go now
16:42:12 <nschoe> jmcarthur: Hum that seems very powerful when you master it.
16:42:16 <jmcarthur> nschoe: and you have some code to write :)
16:42:34 <nschoe> jmcarthur: yeah but before... I must sleep, it's two in the morning here^^
16:42:39 <gwern> nschoe: '56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.'
16:42:42 <jmcarthur> nschoe: yes indeed. this is very generic code for a very specific interface. it means we have a lot of flexibility while still conforming to a contract
16:42:49 <nschoe> But thanks * a lot* for the help (well, the lesson even).
16:43:07 <jmcarthur> you're welcome
16:43:19 <jmcarthur> you are open minded. easy to teach :)
16:43:21 <nschoe> jmcarthur: That's exactly the kind of code I like -and wish I was able to produce :/ ^^)
16:43:27 <jmcarthur> you'll get there
16:43:40 <jmcarthur> anyway, g'night
16:43:48 <nschoe> You too, thanks again.
16:48:26 <zachattack283> read in an integer number and display it in the style of a digital display, using onl the space,underscore and vertical bar characters 
16:48:37 <zachattack283> hwo can i do that in Ada
16:51:59 <gwern> zachattack283: you are asking this in #haskell?
16:53:09 <zachattack283> is there an Ada one?
16:53:43 <gwern> dunno. go look.
16:55:37 <pumpkin> zachattack283: his point is that you're asking a knitting convention how to cook beef wellington
16:56:03 <pumpkin> zachattack283: it has nothing to do with us, and although some of us may know an answer to your question (I don't), it's not a good place to ask
16:57:58 <koninkje> wires: no worries :)
17:06:49 <alex404> Is there a 'best' random generator for haskell?
17:07:11 <koninkje> define "best"?
17:07:26 <alex404> Umm... I've got a lot of options and not sure how to choose ;P
17:07:38 <alex404> I'm not doing anything fancy
17:07:48 <alex404> Just check whether an event with a given probability occurs
17:08:15 <alex404> Speed and ease of use are the key criterion
17:08:22 <koninkje> What I mean is, different algorithms have a bunch of different properties: how pseudorandom/cryptographic they are, how fast, ...
17:08:24 <alex404> *a
17:09:04 <osaunders> preflex: seen Cale
17:09:04 <preflex>  Cale was last seen on #haskell 1 hour, 15 minutes and 13 seconds ago, saying: @bot
17:09:10 <alex404> Cryptographics don't matter too much
17:09:30 <alex404> I mean, I guess, not at all, as long as the numbers are good
17:09:47 <osaunders> Anyone heard of QuickSpec?
17:09:58 <pumpkin> osaunders: sure
17:10:04 <koninkje> alex404: try taking a look at the statistics package (used by criterion)
17:10:13 <osaunders> pumpkin: Is there a Haskell implementation?
17:10:19 <pumpkin> @hackage mwc-random
17:10:19 <lambdabot> http://hackage.haskell.org/package/mwc-random
17:10:26 <pumpkin> osaunders: I thought it was only in haskell
17:10:45 <pumpkin> http://code.haskell.org/QuickSpec/
17:10:54 <pumpkin> don't think it's officially been "released" as code yet
17:11:14 <osaunders> Yeah, I saw that directory index page.
17:11:24 <osaunders> I thought QuickSpec was Erlang only you see.
17:11:41 <osaunders> I thought John Hughes's company might be charging for it.
17:11:43 <alex404> koninkje: Cool. Thanks. I need to learn how to use that package in general, anyway.
17:12:32 <osaunders> pumpkin: Have you used this?
17:12:37 <pumpkin> nope, just read the paper
17:12:43 <koninkje> alex404: if you're programming with probabilities (instead of just doing stats), you may also want to check out logfloat
17:12:56 <koninkje> no randomness there though
17:13:17 <osaunders> Damn. I really want to use this.
17:13:22 <osaunders> Seems so cool.
17:14:01 <pumpkin> koninkje: any updates on your HMM/graphical models work btw? :) :)
17:14:25 <alex404> koninkje: Woah, that's awesome. I'm implementing some machine learning algorithms... so yah!
17:14:31 <koninkje> pumpkin: http://winterkoninkje.dreamwidth.org/68746.html
17:14:39 <pumpkin> ooh
17:15:27 <koninkje> pumpkin: there's a demo deadline tomorrow, so I've been trying to crank out a multithreaded IPC server for it
17:15:33 <pumpkin> aha
17:15:49 <koninkje> alas, haven't had much time for generalizing the internal algorithms though :(
17:16:01 <pumpkin> still excited to see what you come up with :)
17:16:11 <pumpkin> I've spent a lot of time staring at BP and related algorithms
17:16:38 <alex404> koninkje: What are you working on, exactly?
17:16:54 <pumpkin> might take another shot at sum-product at some point, now that I know more haskell
17:16:58 <koninkje> My stuff is currently more HMM based than general graphical models
17:17:06 <pumpkin> koninkje: yeah, I remember you mentioning that
17:17:09 <pumpkin> still interesting though
17:17:26 * osaunders looks up IPC
17:17:42 <pumpkin> osaunders: interprocess communication
17:17:45 <koninkje> indeed. There've been a few more GM or HHMM type models I've been thinking about lately though
17:17:52 <osaunders> Oh, OK.
17:18:12 <pumpkin> koninkje: have you come across markov logic networks?
17:18:14 <osaunders> pumpkin: You know so much stuff.
17:18:17 <osaunders> :)
17:18:29 <pumpkin> osaunders: hah, I may know names for lots of things... ;)
17:18:45 <koninkje> e.g., some of my colleagues' recent work on using speaker role and dialogue moves for improving HMM on conversational text
17:19:05 <pumpkin> ah, cool
17:19:14 <koninkje> pumpkin: I've come across them, but haven't looked into them too much
17:19:18 <pumpkin> ah
17:19:33 <pumpkin> I kind of like the idea but my experiments with them took forever to run so I was sad :(
17:20:25 <koninkje> alex404: I'm working on using HMMs (and similar models) for part of speech tagging and CCG supertagging, focusing on online/interactive algorithms
17:20:29 <alex404> pumpkin: They look pretty cool
17:20:40 <alex404> pumpkin: Couldn't get anything effecient out of it though?
17:21:10 <alex404> koninkje: And you were pondering some more general GM library or something as well?
17:21:47 <pumpkin> alex404: the few test problems I threw at them took hours to days to infer, but seemed to give reasonable results when they finally worked
17:21:49 <koninkje> alex404: not at the moment
17:22:01 <pumpkin> I may have not been picking the most ideal parameters to the tools though
17:22:10 <pumpkin> the documentation wasn't as clear as I'd have liked
17:22:28 <koninkje> pumpkin: were you using the UW implementation?
17:22:36 <pumpkin> but a lot better than no documentation at all, which is pretty common in academia (beyond a paper)
17:22:37 <pumpkin> koninkje: yeah
17:23:03 <alex404> I remember reading about some group of people who wanted to redevelop some machine learning / NN libraries. A google SOC was involved I think. Do you guys know if anything came of that?
17:23:45 <fushunpoon> Hey
17:24:03 <pumpkin> fushunpoon: hi!
17:24:19 <fushunpoon> I'm interested in improving  Data Parallel Haskell, any one know much about the current status?
17:24:48 <pumpkin> fushunpoon: best person in this channel (who isn't currently, unfortunately) is ChilliX/TacticalGrace, who runs the project
17:25:16 <pumpkin> fushunpoon: but my impression of the project is that it's temporarily on hold as the researchers work on smaller chunks of the same problem (vector, repa, and accelerate)
17:25:52 <fushunpoon> pumpkin: That's kind of what I was thinking. 
17:26:15 <fushunpoon> pumpkin: are they, by any chance, Roman, and Manuel Chak.?
17:26:40 <pumpkin> yeah, the person I mentioned is Manuel Chakravarty 
17:26:45 <fushunpoon> I know of those two (at least they're listed on the wiki...), and I find it rather embarrasing to ask them questions about it
17:26:53 <fushunpoon> but sure, he's working on accelerate
17:27:01 <fushunpoon> indeed, I'm looking for an interesting masters' project
17:27:32 <fushunpoon> and I asked him about how I could help- he mentioned that an openCL backend to accelerate would be interesting
17:27:33 <pumpkin> he's very friendly :) and is often in here, so I'd just wait around and ping him when he shows up again
17:27:54 <pumpkin> preflex: seen ChilliX
17:27:54 <preflex>  ChilliX was last seen on #ghc 319 days, 12 hours, 26 minutes and 30 seconds ago, saying: sorry, bundled with gmp
17:27:58 <pumpkin> preflex: seen TacticalGrace
17:27:58 <preflex>  TacticalGrace was last seen on #ghc 35 days, 22 hours, 23 minutes and 52 seconds ago, saying: at UNSW, there is a deadline, but in practice, they still accept later submissions as they are keen on completions
17:28:04 <pumpkin> hmm
17:28:09 <pumpkin> :P
17:28:13 <fushunpoon> pumpkin: you think? haha, it'd be the morning in Aussieland, i'd imagine. I'm a relative n00b to this channel
17:28:28 <fushunpoon> and know not of what people's log-on patterns are, haha!
17:28:37 <fushunpoon> but I should definitely watch this space then.
17:29:00 <fushunpoon> what the... what's preflex :P
17:29:03 <pumpkin> apparently not, since he seems to not be around much these days
17:29:11 <fushunpoon> well that is a shame. lol
17:29:17 <fushunpoon> 35 days is kind of long.
17:29:23 <pumpkin> he just tweeted 6 minutes ago though :)
17:29:26 <fushunpoon> I shan't stay up that long to wait lol
17:29:32 <fushunpoon> ah... good point
17:29:35 <fushunpoon> I should probably follow the dude.
17:29:49 <pumpkin> maybe he just decided IRC was a big time waster <_<
17:30:08 <fushunpoon> does he go by the same name on twitter? 
17:30:16 <pumpkin> TacticalGrace
17:31:06 <fushunpoon> cool found him =]
17:31:58 <fushunpoon> I wouldn't think SPJ would tweet, right :P
17:32:12 <pumpkin> nope, but the other simon is on there, as are many other haskellers
17:34:37 <Mitar> for ffi: if i mark a foreign function safe then it is executed in separate OS thread so even if it blocks whole haskell program does not block?
17:47:51 <Veinor> if I have a polymorphic value, like... thing :: (MyClass a) => a
17:48:42 <Veinor> and I force ghc to decide on a type to use for 'thing' so it can print it
17:48:45 <Veinor> how does it decide what type to use?
17:48:54 <pumpkin> defaulting
17:49:14 <Veinor> and how does that work?
17:49:14 <pumpkin> but only if MyClass is a built-in class
17:49:19 <pumpkin> not very elegantly
17:49:26 <pumpkin> and it's only certain built-in classes
17:49:35 <pumpkin> by built-in, I mean standard
17:50:05 <Veinor> pumpkin: I made a class MyClass where the only thing that uses MyClass is thing :: (MyClass a) => a
17:50:06 <fushunpoon> like Num and stuff right :S
17:50:31 <Veinor> then I made MyClass instances for Char, Integer, and (). when I tell ghci 'hey, print out thing', it gives me ()
17:50:41 <pumpkin> oh yeah, ghci has additional defaulting
17:50:45 <Veinor> ah
17:50:47 <pumpkin> and will tend to pick () if it's available
17:51:14 <koninkje> > show ((undefined :: (Num a) => a) :: Int)
17:51:14 <lambdabot>   "*Exception: Prelude.undefined
17:51:43 <Veinor> basically, the question is, what order does ghci default in?
17:51:47 <koninkje> > show ((42 :: (Num a) => a) :: Int)
17:51:48 <lambdabot>   "42"
17:51:52 <pumpkin> http://www.haskell.org/ghc/docs/6.6/html/users_guide/ch03s04.html#extended-default-rules
17:51:59 <pumpkin> that's 6.6, but it hasn't changed much afaik
17:52:13 <pumpkin> @check \xs -> xs == reverse xs
17:52:14 <lambdabot>   "OK, passed 500 tests."
17:52:15 <pumpkin> ;)
17:52:21 <enthropy> defaulting could help instance selection
17:52:22 <Veinor> :D
17:52:22 <pumpkin> ^ also defaulting
17:52:27 <enthropy> but it doesn't
17:54:07 <Veinor> @undo do {j <- m r; mapM mak j}
17:54:07 <lambdabot> m r >>= \ j -> mapM mak j
17:54:17 <Veinor> nah.
17:54:32 <Veinor> @do \r -> m r ==> \j -> mapM mak j
17:54:33 <lambdabot> \ r -> m r ==> \ j -> mapM mak j
17:54:51 <pumpkin> ==> ?
17:54:55 <pumpkin> you want the quickcheck operator?
17:55:03 <Veinor> @do \r -> m r >>= \j -> mapM mak j
17:55:04 <lambdabot> \ r -> do { j <- m r; mapM mak j}
17:55:07 <enthropy> @do x >>= y
17:55:07 <lambdabot> do { a <- x; y a}
17:55:08 <Veinor> nah, I just got lysdexic for a moment
17:55:24 <enthropy> @info do x; y; z
17:55:24 <lambdabot> x >> y >> z
17:55:26 <pumpkin> m >=> mapM mak
17:56:05 <pumpkin> fushunpoon: you're in luck!
17:56:30 <Veinor> pumpkin: whoo
17:56:32 <pumpkin> TacticalGrace: you're back!
17:56:47 <Veinor> parseTimeline :: handleErrors $ makeJSON >=> mapM makeStatus
17:56:51 <Veinor> er, =, not ::
17:56:53 <fushunpoon> ??
17:56:55 <fushunpoon> wow
17:57:00 <fushunpoon> hello there
17:58:18 <Veinor> so, that used to be four lines of code. now it's one.
17:58:29 <TacticalGrace> pumpkin: :)
17:58:31 <Mitar> how can i get from FFI function call a haskell list as a result?
17:59:07 <pumpkin> Mitar: agree on a "protocol" for how the list will be represented
17:59:12 <pumpkin> and decode it on the haskell side, probably
17:59:58 <Mitar> hmm
18:00:08 <Mitar> there is no demarshaling of linekd lists ;-)
18:00:09 <adu> Mitar: or you can get your hands dirty doing STG/RTS stuff 
18:00:22 <Mitar> link?
18:00:25 <adu> i can never remember what those 3 letters are
18:01:21 <pumpkin> Mitar: there's no marshalling at all. The FFI only lets you use simple types (which could be pointers to Storable things)
18:01:29 <gwern> > 4 * 14.95
18:01:30 <lambdabot>   59.8
18:01:44 <adu> Mitar: if the data you're passing is JSONic, then you might just pass a string with commas
18:01:55 <adu> Mitar: then parse it in Haskell
18:02:10 <kmc> Mitar, look at http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Foreign-Marshal-Array.html for converting between C arrays and Haskell lists
18:02:36 <pumpkin> oh, that's nice!
18:03:45 <kmc> Mitar, what you said about threads is roughly correct
18:04:02 <kmc> you should only use unsafe foreign imports for fast C functions that can't block
18:04:02 <Mitar> in which situation is it not?
18:04:12 <Mitar> i have some OpenCV code
18:04:17 <Mitar> i would like to call
18:04:23 <kmc> well, you said "separate OS thread"
18:04:25 <kmc> separate from what?
18:04:32 <kmc> the RTS can keep a pool of FFI threads running
18:04:32 <Mitar> real OS thread ;-)
18:04:36 <kmc> and farm safe FFI calls out to them
18:04:40 <kmc> but yes, it won't block other Haskell threads
18:05:01 <Mitar> so one init call, then multiple calls to another FFI call which returns a list of results, and not deinit call
18:05:13 <kmc> an unsafe call won't block all Haskell threads immediately, if you're using -threaded and -N >1.  but it will prevent any thread from garbage-collecting, so eventually everything gets stuck
18:05:30 <kmc> does OpenCV care that successive calls come from the same OS thread?
18:05:39 <Mitar> probably ;-)
18:06:04 <Mitar> at least my program uses some global variables ;-)
18:06:10 <Mitar> (the one I want to call)
18:06:22 <kmc> C global variables?
18:06:26 <Mitar> yes
18:06:26 <Veinor> i'm convinced that once I actually 'understand' monads I'm going to start writing code impenetrable to anybody who doesn't also understand them
18:06:29 <kmc> those are shared between threads
18:06:36 <kmc> you'll have a synchronization issue of course
18:06:43 <kmc> Veinor, what does it mean to "understand monads"?
18:06:45 <Mitar> hmm
18:06:51 <kmc> it's just an API
18:06:55 <kmc> "today I finally understood Show"
18:07:02 <Veinor> well, to understand the concepts behind them
18:07:02 <Mitar> i have a while (true) loop currently in C
18:07:03 <monochrom> I understand haskell and my haskell code is impenetrable to those who don't understand haskell.
18:07:05 <kmc> "today I grokked IEnumerable and was enlightened"
18:07:08 <Mitar> i would like to put it into a haskell
18:07:12 <pumpkin> albeit a more abstract one than usual APIs
18:07:26 <Mitar> so probably there will not be sync issues as only one call will be active at one time from haskell?
18:07:34 <kmc> Mitar, if you do it that way, sure
18:07:36 <Veinor> anyway, I keep golfing my monadic code to use >>=, >=>, and friends instead of do notation
18:07:50 <monochrom> in fact, those who expect function calls to be like f(x,y) rather than f x y are already thrown off
18:07:58 <Mitar> ok, but should i still care that things could be run from different os threads?
18:08:00 <Veinor> this is a good thing, right?
18:08:18 <kmc> anyway Mitar, if you need to ensure successive FFI calls come from the same OS thread, you need to use forkOS or one of the other "bound thread" mechanisms
18:08:28 <pumpkin> Veinor: certainly! you're on your way up the steps of the ivory tower, and the view is good from the top, I hear
18:08:29 <kmc> Mitar, i don't know, should you? it depends on the code you're writing and the library you're using
18:08:35 <kmc> Veinor, within reason...
18:08:43 <Mitar> so currently i have a working standalone C program
18:08:44 <pumpkin> Veinor: then you can laugh at those below you like we do, once you're higher up
18:09:05 <Mitar> what i did until now is that I printf-ed output of the program in read-compatibile manner
18:09:07 <Veinor> pumpkin: :D
18:09:14 <Mitar> and then I read that in Haskell using read
18:09:27 <Mitar> the problem is that the whole process for one dataset takes more than 100 ms
18:09:53 <monochrom> and I understand the javascript oo model too, and my javascript code is impenetrable to those who don't understand the javascript oo model
18:09:55 <Mitar> dataset = results of evaluation of one frame
18:10:04 <Mitar> and i need it to be under 10 ms
18:10:14 <Mitar> so i think it is too much just to get data from C to haskell
18:10:16 <monochrom> only the nipple is intuitive. all else is learned.
18:10:19 <Mitar> and this is why i would like to use FFI
18:10:41 <kmc> Mitar, you could also use a faster format
18:11:10 <Veinor> monochrom: I get your point
18:11:13 <monochrom> people keep underestimating how much more they can learn if the teacher cares to motivate and exemplify
18:11:33 <Mitar> kmc: like?
18:11:41 <Veinor> right
18:11:43 <Mitar> it would be great if there would be a C lib for binary module
18:11:48 <Mitar> ;-)
18:12:00 <Mitar> so that I could use binary on Haskell side and something else on C side
18:12:01 <Veinor> see: http://github.com/veinor/askitter/commit/f47f685b4c5bd6c9e2054606eb94e950b09d5bcb
18:12:24 <koninkje> What's the accepted way for an STM () to maintain some internal state? Using TVars seems like too much overhead since no other transactions can access the variables, but using IORefs would break if the transaction retries
18:12:26 <dobblego> why isn't interact printing out the result of the previous line?
18:14:54 <monochrom> because problem exists between beginning and end of your code
18:15:44 <Veinor> argh, I was going to write a thing about text.json for beginners
18:15:51 <Veinor> but now I cannot remember what I was having problems with in the first place :(
18:16:20 <monochrom> I would still use TVar for STM internal state initially. Until things prove to be slow.
18:17:23 <gwern> hm. I wonder what's a good way to ping a domain in haskell
18:18:36 <kmc> Mitar, you could dump native C structs and read them with Storable
18:18:37 <monochrom> I would FFI-call ICBM functions. Err, ICMP.
18:18:54 <kmc> i would shell out to /bin/ping
18:19:12 <gwern> http://hackage.haskell.org/packages/archive/network/2.2.1.7/doc/html/Network-BSD.html#t:HostEntry looks promising but I distrust the lack of any apparent error reporting
18:19:22 <kmc> koninkje, did you quantify the overhead?
18:19:24 <koninkje> foreign unsafe launchMissiles :: ICBM() ?
18:19:33 <dobblego> monochrom, what problem is there? interact reverse
18:19:36 <gwern> kmc: wouldn't I have to parse ping's output? also, shelling out is no fun and is troublesome
18:19:43 <kmc> true on both
18:19:47 <kmc> though if you just want to know if it's up
18:19:48 <monochrom> reverse is too strict for interact
18:19:49 <kmc> you can use the return code
18:20:04 <koninkje> kmc: I haven't benchmarked it yet, it just seems like a not-uncommon situation so I was seeking communal wisdom
18:20:11 <dobblego> oh bugger
18:20:32 <kmc> koninkje, my advice is to use a TVar until you have some hard data indicating it's a performance problem
18:20:34 <Mitar> the problem is that i have a linked list
18:20:44 <koninkje> the application as a whole is definitely performance-centric, though I haven't done STM before to know how much overhead the logging etc has
18:20:48 <monochrom> of course reverse needs to see the absolute end of input before it even knows what's the absolute beginning of output. it is not psychic.
18:20:49 <gwern> I guess I could just use simpleHTTP and check for Left Connerror
18:20:50 <Mitar> i do not know in advance how big my data will be
18:20:54 <kmc> koninkje, but i'm no STM expert
18:21:02 <kmc> remember that STM will perform poorly under high contention
18:22:22 <monochrom> interact (unlines . map reverse . lines)  is more responsive. but does a different thing.
18:23:05 <Axman6> koninkje: premature optimisation and all that...
18:23:12 <Rotaerk> premature what?
18:23:15 <pumpkin> there are creams for that
18:23:54 <kmc> just think about margaret thatcher
18:24:16 <pumpkin> kmc: better hope none of your future mates read the logs to this channel
18:24:29 <kmc> :O
18:28:37 <gwern> kmc: lie back and think of Thatcher?
18:28:51 <monochrom> there are creams for premature optimization?
18:28:51 <kmc> something like that
18:32:03 <enthropy> what does the slash mean in    \a -> t'[t/a], where a is a type?
18:32:20 <Axman6> o.O
18:32:42 <kmc> that's not haskell
18:32:48 <kmc> but that syntax usually means substitution
18:32:55 <enthropy> it's in a paper on haskell
18:33:01 <notabel> enthropy: for type a, produce type t' with parameter t substituted for a
18:35:05 <enthropy> notabel: thanks
18:37:17 <dankna> my stopwatch says I've been working on building ghc for three hours, twenty-six minutes :(
18:37:41 <monochrom> it takes months for a human to build ghc. try a computer instead. XD
18:37:44 <dankna> that counts two attempts from a snapshot, a download of the darcs HEAD, ...
18:37:45 <dankna> hahaha
18:37:46 <dankna> point :D
18:37:57 <dankna> I think my brain has an incompatible version anyway :D
18:41:50 <jmcarthur> i wonder if there is anybody out there that would be willing to pay a non-phd who thinks he's fairly good at teaching to offer an online course of some sort on haskell programming
18:42:22 <gwern> jmcarthur: I wouldn't. 'I'll just point them at real world haskell1'
18:42:25 <jmcarthur> i'm probably just reaching because i am jobless
18:43:06 <jmcarthur> gwern: i mean, of course, that those who are taking the course would be the ones paying
18:43:23 <jmcarthur> but you are right that there are plenty of free ways to learn
18:43:37 * hackagebot JSON-Combinator 0.0.1 - A combinator library on top of Text.JSON  http://hackage.haskell.org/package/JSON-Combinator-0.0.1 (TonyMorris)
18:43:56 <jmcarthur> it's just no guarantee that somebody in #haskell would want to take the time to guide you through something
18:44:22 <monochrom> you are more interactive and flexible than RWH
18:44:34 <jmcarthur> right
18:44:37 <gwern> jmcarthur: one of those hard to pay for things
18:44:50 <gwern> jmcarthur: people don't want to pay. they don't even want to learn. look at SICP
18:45:15 <gwern> jmcarthur: MIT gives away the textbook, the lecture videos, the exercises. hell, they even provide an online quiz server! and there's no shortage of schemers to explain.
18:45:20 <gwern> yet...
18:45:49 <enthropy> people are motivated when they take courses
18:45:52 <kmc> tons of people pay to learn PHP
18:45:56 <kmc> and Java
18:45:57 <Rotaerk> the Society of Invasive Cardiovascular Professionals?!
18:46:02 <Rotaerk> they're invading!
18:46:04 <kmc> you're more likely to pay for something if you see a direct economic benefit
18:46:08 <kmc> e.g. teaching you a marketable skill
18:46:10 <gwern> enthropy: I dunno. in the CS courses I've taken, there has been a significant segment of students that just don't do the work
18:46:42 <enthropy> gwern: you can still profit from those
18:46:43 <jmcarthur> there are those who enrolled to make big bucks later and there are those who are enrolled because they are academically interested
18:46:49 <gwern> enthropy: :)
18:47:08 <jmcarthur> usually there's some combination
18:47:23 <gwern> hard to sell online courses to universities you're not part of
18:47:44 <gwern> @wn clepe
18:47:46 <lambdabot> No match for "clepe".
18:47:57 <gwern> stupid wordnet, not covering obsolete Middle English verbs
18:48:05 * kmc clepes gwern
18:48:15 <gwern> kmc: yes, but *who* do you clepe gwern?
18:48:39 * hackagebot JSON-Combinator 0.0.2 - A combinator library on top of Text.JSONb  http://hackage.haskell.org/package/JSON-Combinator-0.0.2 (TonyMorris)
18:48:41 <monochrom> what? clepe takes 3 arguments?
18:49:31 <gwern> monochrom: it's a rough synonym for 'to call, to name, to term'. so you would 'clepe foo bar', 'clepe this stone gwern'
18:49:51 <monochrom> this must be some middle english threesome awesomeness that goes beyond transitive verbs
18:49:55 <jmcarthur> this guy that was teaching programming stuff online for free considered charging for it and got a lot of support http://www.reddit.com/r/carlhprogramming/comments/baabh/future_plans_for_carlhprogramming_please_read_and/
18:50:01 <jmcarthur> he ended up not charging anyway
18:50:04 <gwern> monochrom: oh, the past tense of clepe is even more awesome - yclept
18:50:05 <jmcarthur> but still
18:50:30 <gwern> monochrom: as for me, 'gwern yclept maru' - 'gwern used to be named maru'
18:50:58 <monochrom> ancient languages are closer to functional languages
18:51:03 <gwern> 'the artist yclept Prince'
18:51:13 <erisco> is there a bot here that simplifies functions? or is there a bot that takes a lambda function and rewrites it without a lambda function? I swore I saw such a thing demo'd here
18:51:16 <gwern> notice that yclept is more precise than 'called'
18:51:19 <erisco> monochrom: are you on every channel? :P
18:51:24 <dobblego> erisco, @pl
18:51:26 <gwern> erisco: @pl sort of does that
18:51:28 <jmcarthur> @pl \x -> x
18:51:28 <lambdabot> id
18:51:38 <monochrom> I am not on every channel.
18:51:40 <erisco> @pl \x -> x
18:51:41 <lambdabot> id
18:52:25 * gwern likes the verb clepe and wishes I could use it more oft
18:52:37 <erisco> @pl \x y -> x:(y:[])
18:52:37 <lambdabot> (. return) . (:)
18:53:08 <erisco> I had converse(converse (:) . (:[])) which looks terrible
18:53:14 <erisco> converse is the same as flip
18:53:25 <pumpkin> pure is nicer than (:[]) in my opinion
18:53:28 <pumpkin> if you have other constraints
18:53:49 <erisco> what is pure?
18:53:56 <pumpkin> like return, but more general
18:54:03 <c_wraith> > pure 5 :: [Int]
18:54:04 <lambdabot>   [5]
18:54:14 <pumpkin> > pure 5 :: Maybe Int
18:54:15 <lambdabot>   Just 5
18:54:17 <erisco> I have to see if it is defined in Miranda... how can I ask lambdabot for the source of return?
18:54:25 <pumpkin> oh, maybe not in Miranda
18:54:29 <jmcarthur> not in miranda
18:54:35 <jmcarthur> Applicative is pretty new, actually
18:54:39 <jmcarthur> relatively
18:54:39 <gwern> > return 5 :: Maybe Int
18:54:40 <lambdabot>   Just 5
18:54:53 <gwern> > return 5 :: [Int]
18:54:53 <lambdabot>   [5]
18:54:58 <gwern> so pure == return?
18:55:16 <jmcarthur> > pure 5 :: ZipList Int
18:55:17 <lambdabot>   No instance for (GHC.Show.Show
18:55:17 <lambdabot>                     (Control.Applicative.Zip...
18:55:23 <jmcarthur> stupid Show
18:55:23 <gwern> strange name, anyway
18:55:26 <erisco> so I cannot even define return in Miranda
18:55:27 <pumpkin> > runZipList . pure $ 5
18:55:28 <lambdabot>   Not in scope: `runZipList'
18:55:28 <erisco> hmm
18:55:37 <jmcarthur> > getZipList (pure 5 :: ZipList Int)
18:55:38 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
18:55:41 <pumpkin> oh
18:55:44 <jmcarthur> > getZipList (return 5 :: ZipList Int)
18:55:45 <lambdabot>   No instance for (GHC.Base.Monad Control.Applicative.ZipList)
18:55:45 <lambdabot>    arising fro...
18:55:49 <jmcarthur> not the same :P
18:56:04 <enthropy> base and precious monads
18:56:06 <pumpkin> return -> pure, pure -/> return
18:56:29 <jmcarthur> they *should* be the same
18:56:35 <jmcarthur> as in, return shouldn't exist
18:56:39 <jmcarthur> and pure should be in its own type class
18:56:45 <djahandarie> Called pointed
18:56:47 <djahandarie> And point
18:56:49 <jmcarthur> indeed
18:56:49 <pumpkin> Pointy!
18:56:53 <jmcarthur> lol
18:57:04 <pumpkin> so much cuter lol ^_^
18:57:08 <djahandarie> ^_^
18:57:12 <jmcarthur> Monady!
18:57:13 <jmcarthur> not as cutre
18:57:15 <jmcarthur> *cute
18:57:26 <pumpkin> hehehehe kawaiiii
18:57:36 <djahandarie> ( ´・‿-) ~ ♥ 
18:58:06 <monochrom> the return of the pointy hair boss
19:00:08 <kmc> erisco, return is defined differently for each instance of the type class "Monad"
19:00:13 <kmc> @src [] return
19:00:13 <lambdabot> return x    = [x]
19:00:15 <kmc> @src Maybe return
19:00:15 <lambdabot> return              = Just
19:00:18 <kmc> @src (->) return
19:00:18 <lambdabot> return = const
19:00:31 <erisco> kmc: yes, and there are no type classes in Miranda
19:00:46 <erisco> it'll be nice when I move back to Haskell and have some more flexibility
19:01:19 <kmc> yeah
19:03:02 <dobblego> newtype Return = R (forall a m. a -> m a)
19:03:19 <kmc> yeah
19:03:24 <kmc> you can do monads without type classes, but it gets ugly
19:04:05 <enthropy> dobblego: where is that legal?
19:04:11 <dobblego> GHC
19:04:16 <dobblego> -XRankNTypes
19:04:44 <pumpkin> just don't put a constraint in or you lose your newtypeyness (?)
19:06:14 <enthropy> dobblego: what do you do to ensure you're combining the same 'm' then?
19:06:32 <pumpkin> I'd parametrize it by the m
19:06:47 <enthropy> and the 'a'?
19:06:51 <pumpkin> but I haven't exactly thought it through very well
19:06:55 <pumpkin> it needs to be polymorphic in the a
19:06:57 <dobblego> newtype Return m = R (forall a. a -> m a) -- better
19:07:28 <pumpkin> but I guess you still need to be able to tell what's "inside"
19:07:30 <pumpkin> hmm
19:07:52 <pumpkin> oh I guess not
19:08:11 <enthropy> at some point it's important to calculate with concrete types?
19:09:07 <pumpkin> I'd do more of data Monad m = M (forall a. a -> m a) (forall a b. m a -> (a -> m b) -> m b)
19:09:14 <pumpkin> (basically building the dictionary yourself)
19:10:23 <pumpkin> data MonadicValue m a = MonadicValue (Monad m) (m a)
19:10:24 * enthropy wonders about the bind :: forall a. m a -> (forall b. (a -> m b) -> m b)
19:12:17 <pumpkin> although what I wrote above wouldn't prevent you from combining different Monad "instances" on the same higher-ranked type
19:12:25 <gwern> @quote ya
19:12:25 <lambdabot> skorpan says: i love the layout of lyah. makes me feel like having some chunky bacon.
19:13:14 * camio raises eyebrow.
19:14:31 <jmcarthur> camio: it's a reference to _why's poignant guide to ruby which has a quirky style that i think may have somewhat influenced LYAH
19:14:54 <camio> ah, thanks.
19:14:58 <kmc> lol internet, bacon and pirates and zombies
19:19:41 <gwern> kmc: '"Pirates are perhaps the greatest invention of Earth people," Elizabeth interrupted loftily, "and their pirate stories are wonderful entertainment for small children. We have to give Earth people credit for that, they invented pirates."' --R.A. Lafferty, _The Reefs of Earth_
19:27:09 <dropdrive> Hi, I asked last night about calling Haskell from Python.  An example use case would be to pass a binary blob of data (without copying) and Haskell would modify it in place.  Is MissingPy right for this?
19:28:03 <kmc> why not just send it over a pipe or socket
19:28:06 <kmc> oh, in-place
19:28:11 <kmc> sorry, i should read things before i respond to them
19:28:30 <Axman6> why use haskell for that? that's a pretty unhaskell like thing to do
19:28:56 <kmc> eh, Haskell's a decent language even for "un-Haskelly" things
19:29:14 <camio> :(
19:29:29 <Axman6> sure, but modifying things in place isn't exactly easy in general
19:29:58 <kmc> you'd use Foreign
19:30:31 <dropdrive> Axman6: So the toy function that I want to try writing is: take a blob of 8000 bytes, interpreted as 1000 doubles.  Increment each of them in place, by 1.  Will this be a huge pain?
19:30:48 <kmc> how is that blob stored in Python?
19:30:50 <Axman6> that would be fairly easy
19:31:42 <dropdrive> kmc: Say, in a NumPy array (which contains a buffer of 8000 bytes).
19:31:48 <Axman6> should be pretty easy isng storable i think
19:32:02 <Axman6> using*
19:32:21 <kmc> hmm actually
19:32:30 <kmc> Python can call C functions easily, by ctypes
19:32:41 <kmc> so you could "foreign export" your Haskell code, and call it from Python that way
19:32:53 <kmc> presuming you have a way to get a pointer to the NumPy buffer in a ctypes-compatible way
19:33:25 <dropdrive> kmc: That sounds reasonable (though I was hoping MissingPy or CPython had a better/easier way).
19:34:00 <Axman6> dropdrive: they may do, but i've never looked at them, and i'm guessing kmc  hasn't either
19:34:59 <dropdrive> I see, thanks.  Final question...recommended package for multidimensional arrays of unboxed doubles?
19:35:22 <kmc> maybe Repa
19:35:26 <kmc> not sure really
19:35:26 <Axman6> Data.Array.Unboxed? :\
19:36:19 <dropdrive> Will look, thanks.
19:36:41 <kmc> dropdrive, as i see it there's a few architectural questions
19:36:48 <kmc> one is, will you have Python call a Haskell function or vice versa
19:36:53 <kmc> (or both, if you have to)
19:37:13 <jmcarthur> dropdrive: you want Data.Array.Storable, not Data.Array.Unboxed
19:37:25 <jmcarthur> dropdrive: Storable means you can operate on foreign arrays
19:37:43 <kmc> another is, will you present the Haskell code to Python as a custom "C" library, or will you use something more generic like ctypes
19:38:03 <kmc> the cpython library would help with the former
19:38:17 <kmc> at that point you're getting your hands dirty in the guts of the CPython interpreter's implementation
19:38:20 <kmc> which is not pretty
19:38:33 <kmc> i've not used ctypes much, but it looks really easy
19:40:13 <kmc> for writing Python extensions, I've found Boost.Python much nicer than using the CPython C API directly
19:40:21 <kmc> even though it involves C++
19:40:31 <kmc> i'm not sure if it would fit here, though
19:50:14 <erisco> @p1 \(x, y) -> x < y
19:50:14 <lambdabot> uncurry (<)
19:50:21 <erisco> duh
19:50:27 <sbahra> heh
19:53:55 <kmc> :t uncurry3
19:53:56 <lambdabot> Not in scope: `uncurry3'
19:58:18 <dropdrive> kmc: I want to call Haskell from Python.
19:58:27 <dropdrive> jmcarthur: Thanks, will take a look!
20:03:15 <gwern> @hoogle uncurry
20:03:15 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
20:03:15 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
20:03:54 <erisco> the word True is starting to look funny
20:04:06 <Martty> why's that
20:04:13 <erisco> been looking at it forever
20:04:29 <jmcarthur> i understand
20:04:40 <jmcarthur> words look funny when you look at them for too long
20:04:47 <erisco> I want to take a list that looks like [True, True, True, False, False, True, False, True, True] and arrive at [[True, True, True], [True], [True, True]]
20:05:17 <gwern> erisco: so, use group and drop anything with head == False?
20:05:26 <erisco> so I defined a function that takes an element and a list and only cons if the element is equal to True
20:05:33 <gwern> > group [True, True, True, False, False, True, False, True, True]
20:05:34 <lambdabot>   [[True,True,True],[False,False],[True],[False],[True,True]]
20:05:41 <erisco> gwern: I figured there had to be a group function :P
20:05:48 <erisco> but there isn't one in Miranda :(
20:05:54 <jmcarthur> :t filter (not . head) . group
20:05:55 <gwern> > filter (\x -> not $ take 1 x) $ group [True, True, True, False, False, True, False, True, True]
20:05:55 <lambdabot> [Bool] -> [[Bool]]
20:05:55 <erisco> and defining group without recursion seems tricky
20:05:56 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:05:56 <lambdabot>         against inferred type ...
20:06:27 <jmcarthur> take 1 is unnecessary i think. there should always be at least one in each list
20:06:31 <erisco> and I am avoiding recursion just because I feel like trying without it
20:06:35 <jmcarthur> hmm
20:06:38 <jmcarthur> > group []
20:06:39 <lambdabot>   []
20:06:43 <jmcarthur> right
20:06:48 <gwern> > filter (\x -> not $ head x) $ group [True, True, True, False, False, True, False, True, True]
20:06:49 <lambdabot>   [[False,False],[False]]
20:06:58 <gwern> > filter (\x -> head x) $ group [True, True, True, False, False, True, False, True, True] -- oh duh
20:06:59 <lambdabot>   [[True,True,True],[True],[True,True]]
20:07:03 <erisco> its okay guys, I can solve it after I get the grouping done
20:07:17 <erisco> I just don't have a group function
20:07:19 <gwern> > filter head $ group [True, True, True, False, False, True, False, True, True]
20:07:20 <lambdabot>   [[True,True,True],[True],[True,True]]
20:07:26 <gwern> heh. that's kind of opaque
20:07:27 <jmcarthur> erisco: you can cheat with @src ;)
20:07:37 <erisco> @src group
20:07:37 <lambdabot> group = groupBy (==)
20:07:43 <erisco> @src groupBy
20:07:43 <lambdabot> groupBy _  []       =  []
20:07:43 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
20:07:43 <lambdabot>     where (ys,zs) = span (eq x) xs
20:07:55 <jmcarthur> @src span
20:07:55 <lambdabot> span _ xs@[]                     =  (xs, xs)
20:07:55 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
20:07:56 <lambdabot>                   | otherwise    =  ([],xs)
20:07:56 <erisco> recursive, bleh
20:08:11 <erisco> I guess I may have to make an exception for this one
20:08:16 <jmcarthur> if you have to roll your own i'm not sure how to avoid it
20:08:21 <gwern> no no do it iteratively
20:08:45 <Axman6> unfoldr?
20:08:46 <gwern> it'll be good practice for doing SICP, the first 3 chapters of which consist solely of writing functions recursively and then rewriting them iteratively
20:09:05 <jmcarthur> ...
20:09:18 <erisco> what do you mean by iteratively?
20:10:02 <erisco> span (==) [1,2,3,4,5]
20:10:11 <erisco> > span (==) [1,1,2,2,3,3,3,3,1]
20:10:12 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:10:12 <lambdabot>         against inferred type ...
20:10:35 <erisco> :t span
20:10:36 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:10:50 <erisco> beats me
20:10:57 <gwern> erisco: do SICP and you will find out in painful detail
20:11:12 <erisco> I might avoid it
20:11:25 <gwern> erisco: the basic difference is the state is stored in variables passed between functions, rather than as function-call chains
20:11:56 <erisco> are you still writing it functionally?
20:12:12 <erisco> or do you mean passing a tuple around with the relevant parameters?
20:12:19 <gwern> erisco: the latter, pretty much
20:12:25 <gwern> impurity is a more advanced topic
20:12:52 <kmc> "iteratively" ≈ "tail-recursively"
20:13:23 <erisco> lets not punish my brain more than necessary for the time being
20:13:48 <kmc> yep, when i helped teach a course using SICP, the students had no trouble until we introduced mutation and environment scoping
20:13:51 <kmc> then half of them hit a brick wall
20:14:38 <kmc> now, they have no trouble with mutation in the Java course
20:14:56 <kmc> because nobody forces them to really understand what's going on
20:15:04 <kmc> they're just required to produce code which works by accident
20:15:26 <erisco> that's how I felt trying to compile my C program yesterday
20:15:27 <kmc> @src unfoldr
20:15:27 <lambdabot> unfoldr f b  = case f b of
20:15:27 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
20:15:27 <lambdabot>    Nothing        -> []
20:24:51 <erisco> > group []
20:24:52 <lambdabot>   []
20:25:50 <erisco> well, my group isn't as abstract but it works
20:26:04 <Mitar> can I allocate an array in FFI function which is then used and freed by haskel?
20:29:09 <erisco> kmc: in fact my group just accidentally worked ;)
20:29:17 <kmc> haha
20:29:43 <erisco> I took a stab at what one of the recursive calls might be and got it right
20:29:45 <kmc> good question Mitar
20:29:50 <erisco> too tired to think about it =\
20:30:00 <kmc> i'm not sure if Foreign.Marshall.Alloc.malloc is compatible with C's malloc()
20:30:05 <kmc> but you can FFI-call C's free()
20:30:15 <kmc> and even attach a finalizer which does so
20:30:45 <Mitar> hmm
20:31:37 <kmc> from reading the source, looks like it does just call the C malloc
20:31:41 <kmc> but i don't know if this is guaranteed
20:31:49 <kmc> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Foreign-Marshal-Alloc.html see the import of _malloc
20:33:36 <Mitar> what about free?
20:33:42 <Mitar> I will call malloc in FFI
20:33:48 <Mitar> i would like to free in haskell
20:33:56 <kmc> likewise
20:36:55 <erisco> my solution to the greatest ascending sub-sequence is perhaps not the most elegant looking
20:38:34 <erisco> http://pastebin.com/WnhXHeiC
20:38:39 <erisco> but at least it is logical
20:39:06 <kmc> what's (#) ?
20:39:09 <kmc> is that a Mirandaism?
20:39:17 <erisco> yes, it counts the number of elements in a list
20:39:27 <kmc> ok
20:39:34 <kmc> it's an unary operator, but written infix?
20:39:38 <erisco> I just need to get it off of one line
20:39:53 <erisco> I might not have needed the parens
20:40:16 <erisco> no, I need the parens or else a syntax error
20:40:59 <kmc> yeah
20:41:08 <kmc> but usually (+) means the prefix equivalent of an infix operator +
20:41:13 <erisco> yeah
20:41:19 <kmc> how would you use it in Miranda without the parens?
20:41:20 <erisco> no idea how # is implemented
20:41:24 <kmc> # [1,2,3]  -- like this?
20:41:26 <erisco> you would just say #xs
20:41:28 <kmc> ok
20:41:29 <erisco> yeah
20:41:31 <kmc> weird
20:41:33 <kmc> what a country
20:41:58 <erisco> I defined greatest to return the largest element in a list
20:42:05 <erisco> didn't seem to be a predefined function
20:42:23 <fengshaun> erisco, maximum?
20:42:52 <erisco> I could have solved the problem more directly with recursion but, meh, felt like trying to abstract a bit
20:42:58 <erisco> fengshaun: thanks, max happens to be defined
20:43:11 <Axman6> > maximum [1..10]
20:43:12 <lambdabot>   10
20:44:13 <erisco> I think a recursive solution might have involved passing a tuple along to keep track of the currently largest subsequence plus an accumulator
20:44:20 <erisco> and that sounded mucky
20:44:41 <ologNation> Hey, I'm having some trouble writing a basic average function. 
20:44:47 <ologNation> Having trouble with the type conversion. 
20:45:08 <ologNation> I'm googling a bit and can't find something that works, but I'm in a hurry to finish this up. 
20:46:22 <ologNation> Any ideas?  references? 
20:46:57 <Axman6> well, the traditional version is ave xs = sum xs /  fromIntegral (length xs)
20:47:10 <Axman6> you can't write one that works for all Num types
20:47:12 <djahandarie> Does anyone have an example of the usage of a generalized anamorphism?
20:48:00 <ologNation> Axman6, This is one that I found online. 
20:48:14 <Axman6> it's not very efficient though
20:48:19 <ologNation> But then "ave [1..10]" gives me an error. 
20:48:26 <ologNation> I'm not looking for efficient right now. 
20:48:36 <Zao> What error? And what definition?
20:48:41 * Zao points at hpaste
20:48:41 <Axman6> > let ave xs = sum xs / fromIntegral (length xs) in ave [1..10]
20:48:42 <lambdabot>   5.5
20:49:00 <djahandarie> i.e., rather than (Functor f) => (a -> f a) -> a -> Mu f ... (Functor f, Monad m) => (forall a. m (f a) -> f (m a)) -> (a -> f (m a)) -> a -> Mu f
20:49:09 <Zao> ave caesar
20:49:09 <ologNation> "Couldn't match expected double against inferred integer"
20:49:14 <erisco> is this a bit more clear kmc? http://pastebin.com/EyAPycxS
20:49:25 <ologNation> Couldn't match expected type `Double'
20:49:25 <ologNation>            against inferred type `Integer'
20:49:25 <ologNation>       Expected type: [Double]
20:49:25 <ologNation>       Inferred type: [Integer]
20:49:30 <Axman6> well, you're probably giving it a list of Ints
20:49:32 <erisco> it just divides where I reduce the problem to the longest sequence of true values
20:49:34 <Axman6> or Integers
20:49:48 <ologNation> isn't that what [1..10] is. 
20:49:50 <ologNation> ? 
20:49:58 <Axman6> not necessarilly
20:50:04 <Axman6> it's a list of Num
20:50:07 <Axman6> :t [1..10]
20:50:08 <lambdabot> forall t. (Num t, Enum t) => [t]
20:51:18 <ologNation> It seems funny that it worked on [1..10] here on the channel, but not over here on my machine. 
20:51:49 <djahandarie> Really, of any generalized morphism. They all follow the same pattern of using the Dist and GAlgebra in place of the Algebra
20:52:31 <ologNation> Well, I got it to work by converting everything in the list to a Double, but I remain stumped regarding how to take the average of a list of Integers. 
20:52:35 <ologNation> Maybe this is the best way to do it. 
20:53:25 <Axman6> well, then you can't use (/), you need to use div instead
20:54:53 <alej> Does anyone know why when I switch from using cooperative threading (without -threaded) to preemptive (with -threaded), I see a noticeable performance hit?
20:55:12 <Axman6> which version of GHC are you using?
20:55:13 <alej> that is, are there any generic issues that i should be aware of?
20:55:24 <alej> 6.12.1
20:55:32 <alej> on os x, if that matters
20:56:25 <Axman6> and what are you actually running?
20:56:48 <alej> i fork off one thread with opengl
20:57:06 <alej> and the 'main' thread loops and periodically tells the opengl thread to render a scene that it sends with an MVar
20:57:13 <Axman6> when compiled without -threaded, many operations relate3d to threading become no-ops basically
20:57:40 <Axman6> hmm, that may be your problem
20:57:51 <Axman6> is the opengl thread forkIO'd or forkOS'd?
20:58:06 <alej> forkIO without -thread, and i ahve tried both forkIO and forkOS in the -threaded case
20:58:39 <alej> the rendering is very very smooth without -threaded, extremely choppy with -threaded
20:58:48 <alej> i haven't built in a mechanism to quantify that yet
20:58:53 <Axman6> i'd make the operations you're looping in main run in another forkIO'd thread, and have main wait on an MVar to be filled by that thread to exit
20:59:44 <alej> is there a reason why that should work?
20:59:45 <Axman6> so, main = do vart <- newEmptyMVar; forkIO (loop var); takeMVar var
20:59:48 <Axman6> -t
21:02:10 <MiggyX> man, thinking recursively is hard when you're starting out
21:02:32 <dobblego> my experience teaching others is that it is easy (easiest?) when starting out
21:03:17 <MiggyX> dobblego: maybe it's the problem I'm starting with lol
21:03:36 <dobblego> are you *really* starting out or have you been exposed to other forms of programming?
21:03:39 <alej> Axman6: didn't see any difference there
21:04:11 <MiggyX> dobblego: Sadly I'm well versed in imperative languages
21:04:21 <dobblego> then you're not starting out :)
21:04:27 <Axman6> thar's ya problem
21:04:39 <MiggyX> dobblego: I meant starting out with recursive languages :)
21:04:40 <alej> ?
21:04:48 <dobblego> Java has recursion
21:05:00 <Axman6> any language worth its salt should be "recursive"
21:05:07 <Axman6> C has recursion
21:05:14 <alej> oh, them =/
21:05:18 <dobblego> what about Coq? it has no recursion but lots of salt
21:05:19 <MiggyX> okay bad choice of words - functional not imperative languages
21:05:26 <MiggyX> is that closer? :)
21:05:31 <dobblego> Java is purely functional at the language level :)
21:05:33 <MiggyX> s/notnon
21:05:55 <pelotom> coq has *principled* recursion
21:06:29 <MiggyX> See, normally I would solve this problem by using state. In the log file, for every line, there should be a matching identical line further down. I need to find the ones that don't have two entries
21:06:44 <dobblego> @hoogle State
21:06:44 <lambdabot> module Control.Monad.State
21:06:44 <lambdabot> Test.HUnit.Base data State
21:06:44 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
21:06:50 <Codex_> C++ can actually prove on compile-time that stack will not run out... Except for recursive functions. So recursion is special in some ways.
21:06:57 <alej> Axman6: any idears?
21:07:10 <Axman6> i'd ask in #ghc
21:07:16 <alej> oh hm good idea
21:07:17 <alej> thx
21:20:47 <MiggyX> dobblego: I was hoping to do it without state - or at least try to figure out if there is a better way to do it in Haskell
21:23:12 <tolkad> instead of state you could use MonadCont
21:23:12 <tolkad> the continuation monad lets you do lots of cool things
21:23:27 <tolkad> it allows you to forget about seperation of concerns and just have your functions do whatever you want them to do
21:25:12 <jmcarthur> falling back onto Cont is a lot like falling back onto goto
21:25:25 <tolkad> combine it with OverlappingInstances for more fun
21:25:33 <jmcarthur> :o
21:26:01 <tolkad> polymorphic on the type of function passed to your function
21:26:37 <tolkad> jmcarthur: good idea?
21:28:14 <kmc> best idea
21:28:23 <jmcarthur> you make me hurt deep inside my heart
21:28:48 <kmc> Codex_, won't every set of non-recursive functions provably use bounded stack?
21:29:20 <kmc> i don't see how this is some property of the language "C++" as opposed to something a compiler for any language could do
21:30:11 <Codex_> kmc: it's property of c++ because of how sizeof's return value is calculated on compile-time only. And stack frames can only contain variables that support sizeof().
21:30:15 <Zao> As a long-time C++ developer, this behaviour is news to me.
21:30:32 <Zao> Codex_: And if someone uses alloca?
21:31:01 <Codex_> zao: if you don't use c++'s features, obviously you don't get the same guarantees.
21:31:18 <jmcarthur> c compatibility is a c++ feature
21:31:19 <kmc> what about C99 VLAs
21:31:20 <Zao> I am not aware of any compiler that has any such tests, anyway.
21:31:23 <kmc> those are in C++ aren't they?
21:31:26 <Zao> kmc: Nope.
21:31:32 <kmc> oh
21:31:34 <kmc> that's probably good
21:31:47 <jmcarthur> heh
21:31:53 <kmc> and alloca is not part of the C++ standard library?
21:32:02 <Zao> kmc: Sadly, no.
21:32:04 <kmc> i got flamed out of ##c because i answered a question about VLAs incorrectly
21:32:19 <kmc> after answering like two dozen beginner questions
21:32:29 <jmcarthur> kmc: they care about correctness in ##c more than we do here, obviously
21:32:29 <Zao> As he is talking about implementations doing additional diagnostics, he's out of standard territory anyway.
21:32:48 <Zao> jmcarthur: No, they care about being power-crazy ops.
21:32:55 <jmcarthur> Zao: it was a joke
21:33:12 <Zao> Codex_: Out of curiousity, which compilers have such diagnostics?
21:33:14 <dankna> hm
21:33:16 <dankna> interesting
21:33:20 <Codex_> zao: none that I know of
21:33:35 <dankna> mtl >= 2 has State as a synonym for StateT Identity
21:33:40 <Zao> So your phrasing was quite off.
21:33:42 <dankna> this means I need fewer instances
21:33:45 <dankna> I am happy
21:33:58 <jmcarthur> <@jmcarthur> Zao: you're wrong. STAND DOWN OR I WILL BAN YOU
21:34:04 <jmcarthur> :)
21:34:44 <Zao> Codex_: What about functions where you have block-local variables? What would the "stack size" of such a function be?
21:34:48 <Zao> Maximum?
21:35:06 <Zao> Also, with dynamic dispatch, I can't see you prove anything.
21:35:40 <Zao> { T* p = new D; p->f(); } // what's the stack size of f? No-one knows.
21:36:24 <Codex_> zao: it's just that it's possible to calculate the size of every stack frame on compile time. It doesnt say anything about how many bytes it really is. Once you combine that to the limited length of the call stack, then you get guarantee for maximum stack size. There exists such a number, but you just don't know what it is.
21:36:42 <kmc> there also exists a bound on how many steps your program can run, if it terminates
21:36:45 <kmc> but it's uncomputable
21:37:27 <jmcarthur> i think Codex_'s claim is a bit stronger than that
21:37:46 <jmcarthur> i believe the claim is that the compiler could, if it wanted to, report a concrete number at compile time
21:37:52 <jmcarthur> as an upper bound
21:37:53 <Codex_> but obviously recursive functions do not follow it. So it's an exception.
21:37:56 <kmc> but that's not possible with dynamic dispatch
21:37:59 <kmc> even without recursion
21:38:06 <kmc> or with alloca, or lots of other things
21:38:11 <kmc> so you have the usual situation with C and C++
21:38:27 <jmcarthur> wait, how does dynamic dispatch prevent it?
21:38:28 <kmc> which is that static analysis is possible, unless you use any of a large set of features which are indispensable in real code
21:38:39 <kmc> jmcarthur, you don't know statically which function will get called
21:38:39 <Codex_> kmc: dynamic dispatch doesnt prevent it
21:38:51 <Rotaerk> I want a compiler than can predict all inputs that all future users will choose for a given build
21:38:59 <jmcarthur> kmc: you don't have to know that given the precondition: no recursion
21:38:59 <Codex_> kmc: it doesnt matter unless you get a recursion on runtime
21:39:02 <kmc> i want a god that stays dead, not plays dead
21:39:11 <jmcarthur> kmc: that would imply no mutual recursion either, i assume
21:39:44 <kmc> jmcarthur, if you report a max stack size of k, then i make a new compilation unit and make my function use k+1 stack, then arrange for it to be dynamically called
21:39:55 <kmc> what you're talking about at the very least requires whole-program analysis
21:40:01 <jmcarthur> we're talking after link time
21:40:03 <kmc> to determine the scope of *possible* dynamic calls
21:40:05 <jmcarthur> yeah
21:40:10 <kmc> and even then it's super difficult
21:40:14 <kmc> because of course there's no memory safety
21:40:52 <jmcarthur> it's not a very interesting property, IMO, but i think it doesn't sound too difficult to do
21:41:44 <jmcarthur> even naively, you could say an upper bound on the runtime stack size of a C++ program with certain preconditions is the sum of the max stack sizes created by every function compiled into the binary
21:41:59 <kmc> that's true
21:42:30 <jmcarthur> a tighter upper bound is of course more difficult
21:47:11 <kmc> glad that's settled
21:50:26 <tolkad> is the subset of haskell without recursive function calls turing complete?
21:50:51 <tolkad> that would include indirect recursion
21:51:01 <kmc> i suspect so, on a technicality, because you can make recursive structures that aren't functions
21:51:11 <kmc> but suppose we ask "is Haskell turing-complete if 'let' is not recursive"
21:51:23 <kmc> (and the module top level is not recursive)
21:51:43 <EvanR> then youre screwed because you can implement fix
21:51:45 <EvanR> cant*
21:51:58 <tolkad> where comes to save the day!
21:52:00 <kmc> well i'm reminded of oleg's fix paper
21:52:01 <kmc> ;P
21:52:26 <kmc> http://okmij.org/ftp/Haskell/Fix.hs
21:52:58 <tolkad> @let fix x = f x where f x = x (f x)
21:53:00 <lambdabot>  Defined.
21:53:16 <kmc> :t fix
21:53:17 <lambdabot>     Ambiguous occurrence `fix'
21:53:17 <lambdabot>     It could refer to either `L.fix', defined at <local>:15:0
21:53:17 <lambdabot>                           or `Control.Monad.Error.fix', imported from Control.Monad.Error
21:53:18 <kmc> ;P
21:53:27 <kmc> oleg's fix1 doesn't require recursive let
21:53:27 <EvanR> today at work my haskell program crapped out because it read a 200k text file and converted to a data.map, it ran out of stack. i changed the loader to use ByteString and now it works fine. now im looking at my hobby program, and im building a large output string with ++, is there a better way?
21:53:28 <tolkad> > take 5 $ L.fix (1:)
21:53:29 <lambdabot>   [1,1,1,1,1]
21:53:53 <EvanR> like lots of nested ++
21:53:56 <tolkad> kmc: my fix doesn't either
21:54:00 <kmc> ;P
21:54:00 <tolkad> kmc: it uses a where
21:54:04 <kmc> yes i see what you did there
21:54:12 <kmc> but suppose we ban where, to make the question more interesting
21:54:15 <kmc> i think you'd have to forbid recursive types too
21:54:33 <kmc> yes EvanR
21:54:37 <kmc> use a datastructure with efficient concat
21:54:50 <EvanR> i remember this thing about ShowS but i didnt understand it...
21:54:53 <kmc> like Data.Sequence, DList, or Text.PrettyPrint
21:55:02 <kmc> http://hackage.haskell.org/package/dlist EvanR
21:55:17 <kmc> newtype DList a = DL ([a] -> [a])
21:55:45 <tolkad> I'm pretty sure untyped lambda calculus is turing complete
21:55:49 <kmc> yeah tolkad
21:55:53 <kmc> but not simply-typed lambda calculus
21:56:09 <kmc> the fixed point combinators from untyped λc don't type in STλC
21:56:09 <tolkad> so just define fix using usafeCoerce
21:56:11 <EvanR> tolkad: you cant define the fixed point combinator non recursively in haskell
21:56:24 <kmc> EvanR, the list xs is represented by the function (xs++)
21:56:40 <kmc> and (++) is implemented by (.)
21:56:44 <EvanR> ok
21:56:55 <kmc> which means you build an inert tree of (.), rather than the explicit traversal of (++)
21:57:00 <kmc> then you can flatten that tree in one pass
21:57:15 <EvanR> and thats going to be efficient with [Char]
21:57:17 <kmc> anyway the dlist library abstracts this and provides a list-like API
21:57:34 <kmc> ShowS is the same thing for Char only, and not abstracted
21:57:35 <c_wraith> most of the time, I don't use dlist unless I need one of its handy instances.
21:57:52 <c_wraith> It's easy enough to use a ShowS-type of interface
21:58:13 <EvanR> :t ShowS
21:58:14 <lambdabot> Not in scope: data constructor `ShowS'
21:58:17 <EvanR> :info ShowS
21:58:45 <c_wraith> it's a type alias for String -> String
21:59:08 <tolkad> wait so you can't define fix in untyped lambda calculus either?
21:59:19 <kmc> tolkad, you can
21:59:20 <EvanR> so to do the final flattening you do...  tree lastPart?
21:59:30 <kmc> the Y combinator is an example of a fixed-point combinator for simply typed lambda calculus
21:59:33 <kmc> but there are very many of them
21:59:37 <kmc> (an infinite, though r.e. set, iirc)
22:00:46 <c_wraith> EvanR, to do the flattening, you apply it to ""
22:00:48 <jmcarthur> you mean for untyped lambda calculus
22:00:53 <kmc> yeah sorry
22:01:02 <kmc> i meant for untyped lambda calculus, the one tolkad was asking about
22:01:05 <kmc> it does not type check in STLC
22:01:34 <EvanR> c_wraith: seems simple enough, though feels kind of like writing functional equivalent of assembly language ;)
22:01:37 <kmc> :t \f -> (\x -> f (x x)) (\x -> f (x x))
22:01:38 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
22:01:38 <lambdabot>     Probable cause: `x' is applied to too many arguments
22:01:38 <lambdabot>     In the first argument of `f', namely `(x x)'
22:01:50 <c_wraith> EvanR, it is... slightly like that :)
22:01:50 <EvanR> a funny spelling to get more performance
22:02:00 <tolkad> @let fix = \f -> (\x -> f (x x)) (\x -> f (x x))
22:02:00 <lambdabot>  <local>:15:0:
22:02:00 <lambdabot>      Equations for `L.fix' have different numbers of arguments...
22:02:05 <tolkad> @undef
22:02:07 <tolkad> @let fix = \f -> (\x -> f (x x)) (\x -> f (x x))
22:02:08 <lambdabot>  <local>:1:22:
22:02:08 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -...
22:02:15 <tolkad> what was it again...
22:02:26 <tolkad> @undefine
22:02:29 <tolkad> @help
22:02:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:02:31 <tolkad> @list
22:02:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:02:45 <tolkad> @let fix = \f -> (\x -> f (x x)) (\x -> f (x x))
22:02:45 <lambdabot>  <local>:1:22:
22:02:45 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -...
22:02:48 <jmcarthur> it was an error. it never got defined in the first place
22:02:58 <jmcarthur> it will never work no matter how many times you try ;)
22:02:59 <tolkad> oh it was undefined, that was the type error
22:03:08 <tolkad> didn't notice it was a different error
22:03:31 <kmc> anyway Oleg's fix1 uses an explicit recursive type wrapper to implement this
22:03:55 <kmc> the Y combinator would type in a typed lambda calculus with equirecursive types
22:03:59 <jmcarthur> which just uses a different fix. doesn't really create fix from nowhere
22:04:15 <kmc> i'm not sure i agree jmcarthur
22:05:18 <jmcarthur> my point is that the type system explicitly supports fix by supporting recursive type wrappers like that
22:05:26 <kmc> kind of
22:05:27 <erisco> kmc, just discovered that I need to return the subsequence rather than just the length of it
22:05:29 <jmcarthur> it's just fix at the type level
22:05:32 <erisco> *sadface*
22:05:42 <jmcarthur> it's a principled way of creating what would otherwise be infinite types
22:05:48 <kmc> jmcarthur, but you still end up needing a somewhat "magical" fixed-point combinator, like you would in untyped LC
22:05:51 <tolkad> hmm, I don't think I can define fix using unsafeCoerce
22:06:02 <kmc> fix1 f = let aux g = g (Wrap g) in aux (\x -> f (unwrap x x))
22:06:18 <kmc> fix1 f = (\x -> f (unwrap x x)) (Wrap (\x -> f (unwrap x x)))
22:06:28 <kmc> which is the iso-recursive embedding of Y
22:06:58 <EvanR> is concat literally implemented as
22:07:01 <EvanR> @src concat
22:07:01 <lambdabot> concat = foldr (++) []
22:07:06 <EvanR> or optimized
22:07:11 <jmcarthur> kmc: right. my point was that it's still magical
22:07:16 <kmc> EvanR, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-Base.html#%2B%2B
22:07:26 <kmc> but there's fusion rules
22:07:35 <kmc> xs ++ ys = augment (\c n -> foldr c n xs) ys
22:07:38 <kmc> whatever 'augment' is
22:08:01 <jmcarthur> the need for fusion rules at all is unfortunate, IMO
22:08:38 * Saizan thought concat = foldr (++) [] would fuse better than the explicitly recursive version
22:08:42 <kmc> rewrite rules in general, or list fusion specifically?
22:09:29 <kyle08> Hello, I know the basic haskell language, but need to look at it a little still. Could someone reccomend a book that covers advanced features
22:09:31 <jmcarthur> well both, but i meant all cases where code has to be obfuscated in order to fuse recursive loops
22:09:44 <kyle08> perhaps a book a little bit more oriented toward software engineering
22:09:48 <kmc> kyle08, RWH
22:09:49 <kmc> @where RWH
22:09:50 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:10:01 <kmc> yeah jmcarthur 
22:10:07 <kmc> rewrite rules are really brittle at current
22:10:12 <jmcarthur> (arguably some of the tricks actually decompose the code into more manageable chunks, but not in a very principled way as it exists today at least)
22:10:18 <EvanR> so to concat a list of strings, id want to first lift them into a (xs++) and then . them all
22:10:28 <kyle08> kmc: good. Because that is the book I have had on my roomate's shelf :-)
22:10:39 <kmc> EvanR, concat on a list of strings once is probably not so bad, since it will be right-associative
22:10:46 <kmc> a ++ (b ++ c) is much better than (a ++ b) ++ c
22:10:49 <kmc> (if deeply nested)
22:10:55 <EvanR> thats effectively what i have
22:11:01 <Saizan> concat is O(n)
22:11:03 <kmc> however if you're recursively concating lists of strings, and then concatting those, etc
22:11:23 <kmc> yes, (++) is O(n), however the output has length n so obviously whatever you're doing with it is already O(n)
22:11:38 <kmc> it's a lot more subtle than simple asymptotics
22:12:02 <kmc> i think it comes down to ((a ++ b) ++ c) requires entering more thunks at once (to get the next char)
22:12:14 <kmc> while (a ++ (b ++ c)) doesn't touch the (b ++ c) thunk until the (a ++ ...) thunk is burned out
22:12:49 <EvanR> some of the expressions in the list are further concats so its like (a ++ ((something) ++ c))
22:13:07 <kmc> yeah
22:13:10 <EvanR> if something is ++, then you can your bad thing
22:13:11 <kmc> could be bad
22:13:12 <kmc> yes
22:13:18 <EvanR> /can/get/
22:14:38 <EvanR> newtype Html = Html (String -> String), Monoid Html where mempty = id, mappend = (.), mconcat = ? or the default is ok
22:15:03 * EvanR throws in a few constructors
22:15:18 <kmc> default is ok probs
22:15:23 <kmc> @src mconcat
22:15:23 <lambdabot> Source not found. Just try something else.
22:15:26 <kmc> :/
22:15:32 <kmc> i'd guess it's foldr
22:15:45 <kmc> but even if foldl, the dlist trick should make that not an issue
22:16:10 <kmc> it's kind of funny to say that a data structure has O(1) append in a lazy language
22:16:25 <kmc> (++) is O(1), if you never demand the result
22:16:32 <kmc> and demanding the whole result is O(n)
22:16:42 <EvanR> yes
22:16:52 <EvanR> lazy means everything is O(1), writing the source code!
22:17:06 <kmc> i think it's better to say "this structure has O(n) append+produce"
22:17:11 <kmc> whereas (++) used improperly is O(n^2)
22:17:14 <EvanR> where 1 = mythical man month
22:17:50 <kmc> or "a structure built from appends will lazily produce chars at O(1) per char"
22:17:55 <kmc> s/char/elem/
22:18:46 <byorgey> mconcat = foldr mappend mempty
22:18:47 <Mitar> if i want constant stack space and process a list with accumulator - is there a way not to get result in reverse order?
22:19:10 <EvanR> im sort of confused about how (.) avoids the problems of (++)
22:19:10 <EvanR> seems like the same number of ++
22:19:10 <EvanR> in the same structure?
22:20:01 <kmc> Mitar, accumulate a "difference list", the thing we were just talking about ;)
22:20:17 <Mitar> let me see up ;-)
22:20:21 <Mitar> i know difference list from prolog
22:20:23 <Mitar> ;-)
22:20:28 <kmc> Mitar, http://hackage.haskell.org/package/dlist
22:20:48 <Mitar> got one mark less on an exam because i didn't know it then ;-)
22:21:46 <Mitar> i am checking how http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Foreign-Marshal-Array.html#peekArray is doing
22:22:10 <kmc> "constant stack space" is weird in haskell
22:22:19 <kmc> GHC's stack is not used for the same thing as the stack in strict languages
22:22:24 <Mitar> aha
22:22:28 <Mitar> it goes backwards
22:22:31 <Mitar> this is why it works
22:22:46 <Mitar> yes, i know it is not the right thing to say
22:22:49 <Mitar> i have a linked list
22:22:55 <Mitar> and i am converting it to haskell list
22:23:04 <kmc> 'map' looks like it would use lots of stack, but it lazily produces constructors one at a time, which can be consumed and collected
22:23:05 <EvanR> reverse the list, then run the algorithm on it ;)
22:23:25 <EvanR> as a hilarious alternative to reversing the result
22:23:27 <Mitar> so i am traversing pointers and adding it to the list, but to be O(1) I add with conc at the beginning, thus getting result in reverse
22:24:23 <Mitar> hmm, is there any benefit of having an accumulator or could i just use recursion?
22:24:51 <EvanR> accumulator? what about fold
22:25:12 <EvanR> use recursion == fold
22:25:52 <kmc> Mitar, if your accumulating function is 'productive', you probably want foldr
22:26:03 <kmc> if it only produces a result at the end, you probably want foldl'
22:26:21 <kmc> by 'productive' i mean that it can produce a constructor before forcing the result of the right hand side
22:26:36 <kmc> map f = foldr (\x xs -> f x : xs) []
22:26:38 <kmc> is an example
22:27:14 <kmc> because we can produce the constructor (:) before forcing the result of the rest of the fold in xs
22:27:28 <kmc> sum = foldl' (+) 0
22:27:31 <kmc> is the other case
22:27:38 <Mitar> http://hpaste.org/40931/mitar
22:27:40 <Mitar> like that
22:27:42 <kmc> we can't evaluate (x + y) without evaluating both x and y
22:27:43 <Mitar> this is my current version
22:27:49 <Mitar> any suggestion to improvements?
22:27:50 <kmc> in the case of Int or other primitive numeric types
22:28:00 <EvanR> its so primitive
22:28:07 <kmc> don't put your guards 500 characters to the right like that
22:28:16 <kmc>   where convertList' ptr list
22:28:19 <kmc>     | foo = ...
22:29:11 <Mitar> i have a wide screen ;-)
22:29:17 <kmc> it's still ugly
22:29:19 <EvanR> i dont
22:29:24 <kmc> i never let the indentation of anything depend on the length of a name
22:29:31 <kmc> it's annoying to edit too
22:29:43 <EvanR> i fix php code all day written like this
22:29:49 <EvanR> in my 80 char term ;)
22:29:53 <Mitar> ;-)
22:29:53 <kmc> i'm so sorry
22:29:53 <tolkad> I tried this:
22:29:55 <tolkad> fix = (\f -> (\x -> (f :: a -> a) ((x :: (a -> a) -> a) (unsafeCoerce x :: a -> a))) (\x -> (f :: a -> a) ((x :: (a -> a) -> a) (unsafeCoerce x :: a -> a)))) :: (a -> a) -> a
22:30:00 <byorgey> kmc: ah, I do that too, but had never heard the principle stated in such a concise way
22:30:07 <tolkad> but it says inferred type is less polymorphic than expected
22:30:18 <byorgey> Indeed, I hadn't realized that's what I do =)
22:30:28 <Mitar> so it seems for me that my version reverses the result
22:30:30 <kmc> tolkad, dear god
22:30:32 <tolkad> Quantified type variable `a' is mentioned in the environment: x :: (a -> a) -> a 
22:30:44 <Mitar> and that it has list accumulator there but i am not really sure that it needs it ;-)
22:30:44 <byorgey> tolkad: do you have ScopedTypeVariables turned on?
22:30:51 <tolkad> byorgey: no extensions
22:31:00 <byorgey> tolkad: I think you will need it
22:31:05 <Mitar> i made it like automatically like that ;-)
22:31:35 <tolkad> byorgey: all the type annotations besides the one after unsafeCoerce x are just to figure out where the problem is
22:31:36 <pelotom> poll: what do people in here use to edit haskell code?
22:31:42 <kmc> vim
22:31:47 <EvanR> Mitar: im confused why you have a list, and you need to produce a list from the list, and that list either has 'the reverse order' (in which case you should use map instead) or if not why the order matters
22:31:54 <tolkad> what is the problem anyway? these should all be polymorphic enough
22:32:17 <EvanR> Mitar: if the result list depends on all elements of the list (fold) then why does the order matter?
22:32:18 <tolkad> byorgey: I understand that those are not the same "a"
22:32:24 <tolkad> byorgey: between each annotation
22:32:45 <byorgey> tolkad: OK. That's what I was worried about.
22:32:53 <byorgey> tolkad: I don't know then.
22:33:08 <Mitar> true, order probably does not matter, but it is easier to debug ;-)
22:33:10 <Mitar> but true
22:33:17 <Mitar> what about that accumulator list there?
22:33:19 <Mitar> is this needed?
22:33:35 <ulfdoz> ansonsten, ist es bei postgresql unter garantie dabei. Ich kenn allerdings nur den full installer, der dir gleich 'nen ganzen DB-Server installiert.
22:33:40 <ulfdoz> ewin, sorry.
22:33:45 <EvanR> if you need to accumulate a list as a result, then yes ;)
22:33:56 <EvanR> that being said, maybe i should ask what youre trying to accomplish
22:34:05 <Mitar> i could have like (Obstacle { ... }):(convertList' next)
22:34:16 <Mitar> but this would be not tail recursive
22:34:17 <EvanR> higher level
22:34:23 <Mitar> and current version is tail recursive
22:34:25 <Mitar> is this right?
22:34:26 <tolkad> <ulfdoz> otherwise, it is under warranty it in postgresql. I know only the full installer, which you installed the same 'nen all DB server.
22:34:26 <tolkad>  <ulfdoz> Lewin, sorry.
22:34:29 <EvanR> tail recursive...
22:34:41 <pelotom> 100% of haskellers who responded to this poll use vim! It's a landslide!
22:34:54 <tolkad> ulfdoz: try a different 'nen
22:35:01 <tolkad> oh wait let me run that through translator
22:35:12 <Mitar> EvanR: I am trying to get a lined-list structure from C into Haskell
22:35:24 <tolkad> <tolkad> ulfdoz: versuchen Sie eine andere 'nen
22:35:24 <tolkad>  <tolkad> oh warte lass mich laufen, die durch Übersetzer
22:35:25 <Mitar> FFI
22:35:29 <EvanR> Mitar: interesting
22:35:49 <EvanR> i wonder how one does that sanely ;)
22:35:54 <jmcarthur> pelotom: heh
22:35:57 <Mitar> i am just doing it ;-)
22:35:58 <Mitar> i hope ;-)
22:35:59 <jmcarthur> pelotom: emacs here
22:36:13 <EvanR> obviously traversing the list and prepending will reverse it
22:36:21 <Mitar> yes
22:36:22 <tolkad> you know, it used to be that people who spoke different languages couldn't communicate with eachother
22:36:29 <tolkad> but now with google translator it's easy
22:36:33 <kmc> i don't think it matters much what editor you use with haskell
22:36:34 <Mitar> but prepending is O(1) without difference lists
22:36:38 <kmc> use whatever editor you are otherwise comfortable with
22:36:40 <EvanR> tolkad: well the west contacted china somehow...
22:36:55 <kmc> if you don't know any good editors, learn a good editor; it will help you outside of haskell
22:37:07 <pelotom> I use emacs but am annoyed by its behavior when pasting code into it
22:37:20 <pelotom> it fucks up the indentation
22:37:33 <pelotom> the haskell emacs binding does, that is
22:37:41 <EvanR> Mitar: there is Data.Sequence you can use to accumulate in order, then convert to list
22:37:41 <MiggyX> so, if you wanted to match up lines in a log file, what about the Haskell-esque way to do it?
22:37:47 <EvanR> off the top of my head
22:38:10 <tolkad> EvanR: when learning a language for the first time anthropologists go live with the people until they pick it up
22:38:26 <tolkad> EvanR: I'm speaking of people who don't know eachothers language
22:38:27 <kmc> pelotom, you have to disable indentation somehow
22:38:29 <kmc> in vim :setl noai
22:38:35 <kmc> don't know about emacs but i think i did it before
22:38:39 <EvanR> maybe a structure of the form [a] -> [a] would help
22:38:41 <kmc> or, paste with cat >> foo.hs
22:39:01 <pelotom> kmc: ah, ok, I'll try that
22:39:07 <kmc> (not  while it's open, of course)
22:39:12 <EvanR> tolkad: anthropology decidedly post-dated the west contacting china ;)
22:39:57 <pelotom> I'm also surprised no one seems to care much about refactoring in haskell
22:40:07 <EvanR> i have never had a problem refactoring
22:40:19 <kmc> pelotom, there is HaRe
22:40:21 <EvanR> after learning the style guide
22:40:29 <kmc> it's not widely used though
22:40:38 <pelotom> kmc: I have seen that
22:40:43 <pelotom> yeah, that was my impression
22:40:49 <kmc> the main trick to refactoring in Haskell is to start with a change which will break all your code's types until you've touched every bit
22:41:02 <tolkad> EvanR: the "west" has contacted china many times for thousands of years
22:41:08 <pelotom> kmc: right :)
22:41:13 <tolkad> EvanR: So I'm not sure exactly what you are referring to
22:41:17 <kmc> but yeah, automated tools are not much used
22:41:26 * MiggyX lives in China :)
22:41:41 <tolkad> hmm, I wonder if there are any good haskell IDEs
22:41:51 <tolkad> they could automatically write type signatures for me
22:41:51 <EvanR> Mitar: if you ++ [x] each time, it will turn out in order. to avoid the eventual cost of doing ++ you could do like we were talking about about (.) (x++) instead
22:42:00 <pelotom> leksah seems decent
22:42:02 <EvanR> tolkad: yes im dramatically over simplifying
22:42:03 <byorgey> MiggyX: what do you mean by "match up lines in a log file"? Can you give an example?
22:42:15 <pelotom> but I didn't see any refactoring features in it
22:42:20 <EvanR> the idea being thousands of years ago we didnt know chinese
22:42:37 <EvanR> also making a joke about anachronistic anthropology
22:42:50 <kmc> tolkad, http://hackage.haskell.org/package/scion
22:42:59 <pelotom> it would seem to me that the availability and power of refactorings increases with the power of the static type system
22:43:01 <tolkad> EvanR: maybe the europeans didn't but they knew merchants who knew merchants who did
22:43:08 <Mitar> (.) (x++) will then just prepare everything and when i will force the result at the end everything will be concatenated, yes?
22:43:30 <EvanR> Mitar: in the form (a ++ (b ++ (c ++ (..., i think
22:43:35 <EvanR> er
22:43:43 <EvanR> ([a] ++ ([b] ++ ([c] ++...
22:43:46 <MiggyX> byorgey: basically in this log file each line is a message. That message should show up twice in the log. I need to match up the pairs and determine whether or not there any any single entries
22:44:06 <tolkad> kmc: apparently doesn't support GHC 6.12.3
22:44:19 <tolkad> kmc: it has a <= 6.12 restriction on it
22:44:26 <tolkad> wait make that a <
22:44:31 <EvanR> MiggyX: are you chinese?
22:44:43 <MiggyX> EvanR: no
22:44:56 <tolkad> MiggyX: they let you on freenode there?
22:45:00 <EvanR> heh
22:45:02 <tolkad> MiggyX: it has a politics channel
22:45:03 <byorgey> MiggyX: ok, maybe something like  filter ((==1) . length) . group . sort . lines
22:45:18 <EvanR> tolkad: and the police are now on the way to MiggyX's apartment, good job ;)
22:45:21 <byorgey> with appropriate additions if you need to parse the lines at all
22:45:31 <MiggyX> at the moment I'm in Hong Kong which has no restrictions at all on Internet use - but SSL vpns work fine in China.
22:45:52 <MiggyX> The great firewall has more holes than a sieve but it stops 99% of the population - and the other 1% know what they're not supposed to anyway so it's of little concern :)
22:46:18 <MiggyX> byorgey: thanks :)
22:48:04 <kmc> yeah
22:48:26 <EvanR> Mitar: and when you lazy evaluate (['x'] ++ (['y'] ++ (['z'] ++... it has the effect of prepending from the right
22:48:42 <kmc> i get the feeling the communist party doesn't so much mind dissent among the intellectual elite, as long as it can't reach the masses and become a popular movement
22:49:10 <kmc> they know that reforms are inevitable but they want to control and rate-limit and make sure that all the ideas come through them
22:49:23 <EvanR> Mitar: im figuring this out myself at the moment ;)
22:49:57 <tolkad> MiggyX: I don't know much about china politics but if a case ever goes to the supreme court wont the censorship be ruled unconstitutional under the first amendment?
22:50:18 <kmc> tolkad, you have the weirdest sense of humor of anyone in this channel
22:50:27 <Mitar> ;-)
22:50:28 * EvanR looks at tolkad 
22:50:32 <EvanR> ?_?
22:50:54 <EvanR> china isnt one of the 50 states
22:50:58 <MiggyX> tolkad: yup - and then it will carry on as it alway has ;)
22:51:00 <kmc> joking? trolling? confused? who can tell
22:51:04 <EvanR> yet
22:53:46 <tolkad> EvanR: oh you're right, the first amendment makes a specific reference to congress, which china doesn't have
22:54:03 <EvanR> the first amendment to what
22:54:07 <kmc> sure it does tolkad 
22:54:08 <tolkad> EvanR: some of the constitutional amendments don't just apply to US citizens though
22:54:13 <kmc> http://en.wikipedia.org/wiki/National_People%27s_Congress
22:54:22 <kmc> "is the highest state body and the only legislative house in the People's Republic of China"
22:54:53 <tolkad> kmc: it does say "Congress", not "a Congress" but I think your argument is valid
22:55:03 <tolkad> kmc: I guess it does apply to China
22:55:12 <tolkad> MiggyX: It appears you have a case!
22:55:27 <kmc> yup, sue in the ICJ
22:55:42 <MiggyX> tolkad: heh
22:56:48 <tolkad> but honestly, I don't understand why China isn't annexed yet. Whatever happened to manifest destiny? did we just stop at the pacific?
22:56:57 <EvanR> lol
22:57:14 <EvanR> ww2 happened, we stopped at japan
22:57:17 <kmc> tolkad, no, we didn't
22:57:29 <jmcarthur> okay, my reality just flipped onto its head
22:57:35 <kmc> yeah and the Philippines were a US colony for a while
22:58:13 <kmc> 1898 to 1946?
22:58:43 <EvanR> woulda had china if it werent for those pesky guns and tanks ;)
23:00:05 <tolkad> China could learn a lot from the US
23:00:16 <kmc> pesky guns / tanks / USSR's nukes / their own nukes
23:00:24 <tolkad> for example, we don't pollute our own country noticebly
23:00:30 <kmc> hahahahaha
23:00:42 <tolkad> we pollute other countries or do it in a way such that the public doesn't notice
23:00:53 <kmc> we pollute the fuck out of the US
23:01:06 <kmc> and did so way more when we were at the same stage of capitalist growth that the PRC is now
23:01:13 <kmc> and we also sold tainted food and pirated books
23:01:19 <kmc> and had terrible workers' conditions
23:01:35 <kmc> anyway, #haskell-blah?
23:02:00 <tolkad> join #haskell-haskell if you wanto to talk about haskell
23:03:48 <tolkad> kmc: I guess we did
23:08:02 <MiggyX> hmm,   Expected kind `?' but `IO' has kind ` *-> *'    is that an obvious newbie mistake? :)
23:08:40 <lispy> MiggyX: maybe you need more parens somewhere
23:08:51 <lispy> MiggyX: hard to say without seeing the code
23:09:08 <MiggyX> is there a preferred pastie?
23:09:24 <kmc> hpaste.org
23:09:27 <kmc> MiggyX, it probably means you tried to use IO as a type
23:09:32 <kmc> rather than (IO Char) or (IO ()) or something
23:10:23 <MiggyX> http://hpaste.org/40932/newbie_mistake
23:11:31 <lispy> MiggyX: mainloop :: Handle -> IO
23:11:47 <lispy> MiggyX: IO needs a parameter
23:12:11 <MiggyX> right, got it
23:12:17 <MiggyX> dammit I can't even copy code right :/
23:12:23 <MiggyX> thanks guys :)
23:12:30 <lispy> You're welcome!
23:20:59 <MiggyX> now to convert an Int to a String
23:21:02 <MiggyX> slowly but surely....
23:21:15 <Axman6> @hoogle a -> String
23:21:16 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
23:21:16 <lambdabot> Prelude show :: Show a => a -> String
23:21:16 <lambdabot> Text.Show show :: Show a => a -> String
23:23:30 <pelotom> > show 119283
23:23:31 <lambdabot>   "119283"
23:23:49 <MiggyX> I'm using the date function from the haskelwiki which I need as part of a file name
23:23:57 <McManiaC> > show 5e2
23:23:58 <lambdabot>   "500.0"
23:24:16 <Entroacceptor> > show [1, 2, 3]
23:24:17 <lambdabot>   "[1,2,3]"
23:24:25 <McManiaC> :)
23:24:39 <MiggyX> date returns (Integer, Int, Int)
23:25:47 <abi_> helo
23:25:52 <abi_> anybody
23:26:00 <pelotom> hi
23:26:16 <abi_> want to know something abou haskel
23:26:19 <abi_> can you help?
23:26:30 <McManiaC> just ask
23:26:56 <abi_> i am about to start haskell ...what type of applications do haskell cover
23:27:00 <abi_> can i do web programming too
23:27:09 <abi_> or just stand alone applications?
23:27:10 <McManiaC> yes
23:27:10 <Axman6> of course
23:27:17 <Axman6> you can do anything you want
23:27:35 <Axman6> there's plenty of web frameworks for haskell
23:27:37 <McManiaC> @faq can haskell do web programming?
23:27:37 <lambdabot> The answer is: Yes! Haskell can do that.
23:27:50 <abi_> i mean ... can haskell "replace" Java, PHP perl etc?
23:27:56 <McManiaC> yes
23:28:02 <abi_> wow
23:28:08 <Axman6> wow? :\
23:28:23 <abi_> and what are the advantages of using haskell .... why not use java, php or python?
23:28:28 <kmc> abi_, http://snapframework.com/ http://docs.yesodweb.com/ http://happstack.com/index.html
23:28:28 <pelotom> @faq can haskell get that gravy stain out of my trousers?
23:28:28 <lambdabot> The answer is: Yes! Haskell can do that.
23:28:43 <kmc> abi_, Haskell allows you to catch more errors at compile time
23:28:52 <kmc> GHC-compiled code is much faster than typical PHP or Python interpreters
23:28:56 <pelotom> abi_: more static assurances of correctness
23:29:03 <kmc> Haskell is far more expressive than Java, producing much more compact, elegant code
23:29:12 <McManiaC> and a cleaner language design ;)
23:29:13 <Axman6> abi_: you write less code
23:29:14 <kmc> in Haskell you think a lot and write very little
23:29:21 <kmc> in Java you write loads of boilerplate without thinking
23:29:26 <kmc> and drown in it
23:29:49 <Axman6> which makes you think you're doing more, but you're just writi9ng more
23:29:49 <kmc> abi_, writing correct programs is hard in any language.  Haskell makes it also hard to write incorrect programs
23:29:52 <shachaf> kmc: "You have a sense on déjà vu."
23:30:20 <abi_> nice to read your comments ... i come from java (procedural )background ... i wanted to learn a new language (i do it every 2 years) 
23:30:31 <abi_> i think haskel is a nice choice
23:30:34 <kmc> abi_, and yes it can replace Java, PHP, Perl etc.  those are all general-purpose languages, they can all do the same sets of things.  now, picking which is *best* for some job is harder
23:30:44 <kmc> yes, learning Haskell will expand your mind and make you a better programmer in every language
23:30:55 <kmc> it's tough to learn and you will spend a lot of time frustrated
23:31:18 <kmc> but i think it's worth it
23:31:21 <Axman6> ...not to scare you or anything
23:31:28 <kmc> it may also make you hate Java, which could be bad if you need to program Java for your job
23:31:41 <McManiaC> haha yeh
23:31:48 <pelotom> abi_: I come from Java too... haskell will be painful for your brain at first, but it's well worth it
23:31:57 <kmc> maybe the best thing about learning Haskell is that you can read most statements about programming languages on Reddit and explain why they're wrong ;)
23:32:04 <McManiaC> there have been serious discussions about the "i started to hate my job because I learned haskell" posts on the mailinglist
23:32:17 <abi_> thanks ... I will surely try... in fact after learning python i started hating java ... but have no idea of haskell ...have you heard of any web application developed using pure haskell ... or a GUI stand alone program using pure haskell
23:32:32 <tg_> abi_: there are many examples of both
23:32:33 <pelotom> abi_: learning haskell will make you sneer at python too :)
23:32:34 <tolkad> abi_: haskell doesn't have inheritanc
23:32:37 <tolkad> inheritance*
23:33:05 <Axman6> abi_: there's plenty. most haskell programs come with their own servers, so you don't need apache or anything
23:33:07 <McManiaC> my website npaste.de is 100% haskell :)
23:33:08 <kmc> abi_, xmonad is a window manager
23:33:12 <kmc> so is hpaste.org
23:33:17 <kmc> so is haskellers.com
23:33:18 <McManiaC> yep
23:33:28 <tg_> gitit
23:33:30 <tg_> yesod, snap
23:33:33 <tg_> etc etc
23:33:33 <kmc> other GUI haskell apps... threadscope
23:33:37 <kmc> some of the examples in RWH
23:33:45 <tolkad> abi_: you might miss inheritance though
23:33:53 <kmc> yes, it is hard to program Java in Haskell
23:33:57 <MiggyX> okay, so how does one extract the contents of a tuple
23:34:05 <kmc> if you want to write Java code in Haskell you are in for a bad day
23:34:09 <MiggyX> I've got the code for handling a pair but this one has three items :)
23:34:09 <tolkad> MiggyX: pattern matching
23:34:09 <McManiaC> MiggyX: pattern matching
23:34:10 <kmc> MiggyX, by pattern-matching
23:34:11 <kmc> haha
23:34:13 <McManiaC> tolkad: :D
23:34:15 <kmc> @quote contrapuntal
23:34:15 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
23:34:15 <tolkad> MiggyX: let (a, b) = t
23:34:23 <tolkad> MiggyX: where t is a tuple
23:34:24 <abi_> how is the learning curve? i read somebody say its hard to learn ...!?!
23:34:30 <kmc> > let f (x,y,z) = show x ++ show y ++ show z in f (1,2,3)
23:34:31 <lambdabot>   "123"
23:34:35 <kmc> abi_, it's hard but doable
23:34:50 <kmc> abi_, the biggest thing is you need to delay gratification.  you won't be writing full gui apps and websites right away
23:34:52 <MiggyX> abi_: it's fairly hard - I think it's mostly because it's so different
23:34:56 <tolkad> MiggyX: also, because a tuple only has one constructor, you can control the order of evaluation here by lazy pattern matching
23:35:00 <kmc> spend a lot of time just playing with the interpreter before you get to whole programs
23:35:07 <Axman6> abi_: start with LYAH and see what you think:
23:35:09 <Axman6> @where lyah
23:35:09 <lambdabot> http://www.learnyouahaskell.com/
23:35:15 <Axman6> abi_: ^^^^^^^^^^^^^^^^^^^^
23:35:26 <abi_> okk got that
23:36:28 <abi_> one more thing ... what do you think about the future of haskell? (not for hobby or trying sth different just for the sake of it ... but professionally)
23:36:29 <Entroacceptor> kmc: that's wrong, you can start by building websites
23:36:34 <Entroacceptor> your brain will just melt more
23:36:44 <tolkad> abi_: it's really not that hard to learn the semantics, I learned the basics in few months spending only a few hours a week
23:36:56 <Axman6> abi_: it's getting better every day
23:37:06 <tolkad> abi_: but I'm not that good at writing maintainable code yet :P
23:37:13 <pelotom> I think the next decade will see a huge rise in haskell's use
23:37:19 <Axman6> indeed
23:37:31 <MiggyX> me too - that's why I'm here :D
23:37:33 <tolkad> abi_: and don't even make me think about what the space complexity of my code is
23:38:15 <MiggyX> blast, date returns an IO, not a tuple
23:38:20 <MiggyX> thank god for the Internet
23:38:30 <abi_> thangs guys ...i think that among all the functional programming languages, haskell is a good choice to dive in
23:38:58 <McManiaC> MiggyX: do { ...; (x,y,z) <- date; ... } ?
23:39:02 <pelotom> abi_: good luck and have fun!
23:39:12 <abi_> thanks to all of you
23:39:18 <tolkad> abi_: haskell has a backup method incase you can't easily write something functionally with a certain space complexity, it's a bit advanced though
23:39:24 <Axman6> abi_: remember, this is by far the best place to ask questions
23:39:26 <McManiaC> abi_: oh, and did we mention the awesome haskell community? :)
23:39:43 <Axman6> not just questions about haskell, but the best place that exists to ask questions at all ;)
23:39:54 <abi_> can i ask questions here?
23:40:02 <pelotom> any time
23:40:03 <abi_> and what about the community?
23:40:07 <pelotom> that's what this place is for
23:40:09 <Axman6> abi_: it is strongly encouraged
23:40:14 <abi_> can i join some forum etc?
23:40:20 <kmc> abi_, stackoverflow.com
23:40:23 <kmc> has some Haskell questions
23:40:29 <abi_> okk
23:40:33 <pelotom> abi_: you can also ask questions on www.stackoverflow.com
23:40:34 <McManiaC> the mailing list is also very active
23:40:35 <Axman6> this is the community, all 600 of us, plus all the poeple on the mailing lists, on stack overflow etc
23:40:47 <MiggyX> abi_: I've only been at this a couple of days, and the people in here have been awesome. They've answered questions about Haskell in general as well as specific problems (as you have just seen)
23:40:50 <abi_> okk ... thats a great help
23:40:54 <kmc> tolkad, but a few months is a long time; people expect to jump in over one weekend because they're used to learning trivial new syntax for some familiar OOP concepts
23:41:00 <kmc> if you know Python and Perl you can learn Ruby in a weekend
23:41:11 <Axman6> abi_: the haskell community ios possibly the best thing about haskell
23:41:15 <Axman6> is*
23:41:33 <kmc> yes, we're so awesome
23:41:38 <abi_> :)
23:41:41 <Axman6> go team!
23:42:06 <abi_> i have already started to get a good feeling about haskell
23:42:08 <abi_> :)
23:42:16 <McManiaC> kmc: a friend of mine learned basic haskell in a couple of days just this week :)
23:42:24 <pelotom> ok, go learn! and come back with questions
23:42:29 <kmc> i'm impressed McManiaC
23:42:32 <kmc> though also, what is "basic"?
23:42:39 <McManiaC> (then again he has a degree in computational physics... :D )
23:42:42 <kmc> you can learn to write 'fact' recursively because it's just how you'd write it in plain text ;)
23:42:49 <abi_> do you recommend any basic books?
23:42:54 <shachaf> kmc: "basic" is a programming language.
23:43:03 <shachaf> kmc: "basic Haskell" is an abomination.
23:43:11 <McManiaC> kmc: pure functions, do notation, pattern matching etc
23:43:18 <McManiaC> some data definitions
23:43:25 <abi_> i mean haskell book for beginners?
23:43:25 * shachaf wonders if someone's made a line-numbered GOTO monad.
23:43:55 <McManiaC> shachaf: http://hackage.haskell.org/package/GotoT-transformers
23:44:04 <pelotom> abi_: http://www.realworldhaskell.org/ is a book that you can buy physically, download on kindle, or read online
23:44:32 <pelotom> and same goes for http://learnyouahaskell.com/ I believe
23:44:50 <pelotom> I'd start with LYAH
23:44:55 <pelotom> just read it online
23:45:10 <Axman6> abi_: lyah is _the_ haskell book for beginners
23:45:11 <abi_> okk thanks :)
23:46:19 <kmc> shachaf, http://hackage.haskell.org/package/BASIC
23:46:54 <abi_> I will start haskell from today ... and let you all know about my progress
23:47:21 <kmc> cool :)
23:47:23 <kmc> good luck
23:47:44 <kmc> McManiaC, interesting lib
23:47:50 <kmc> i'm trying to figure out how this compares to ContT
23:48:07 <kmc> i think it's not as powerful
23:48:19 <kmc> (which isn't to say it's never preferable)
23:49:36 <bonii> import Parsec gives me a not found error 
23:49:39 <shachaf> kmc: Wow, that's horrible.
23:49:46 <kmc> bonii, it hasn't been called that for a long time
23:49:48 <kmc> Text.Parsec
23:49:55 <kmc> http://hackage.haskell.org/package/parsec bonii
23:51:12 <bonii> kmc: Thanks 
23:52:27 <McManiaC> kmc: I never used it :)
23:52:33 <MiggyX> hmm, my first simple function "just worked"  - then I upgraded it to accept input - now it's dead lol
23:52:57 <McManiaC> bonii: probably even Text.ParserCombinators.Parsec
23:55:35 <MiggyX> okay, I just need more parentheses :D
23:58:01 <Entroacceptor> or more dollars?
