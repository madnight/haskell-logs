01:06:57 * hackagebot test-framework-quickcheck2 0.2.8 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.2.8 (MaxBolingbroke)
01:41:07 * hackagebot vision 0.0.4.0 - An XMMS2 client.  http://hackage.haskell.org/package/vision-0.0.4.0 (OlegBelozeorov)
02:00:33 --- mode: kornbluth.freenode.net set +o ChanServ
02:01:03 <Maxdamantus> O_o
02:01:10 <EvanR> o_O
02:01:13 <kmc> merijn, the Haskell 98 type system is close to System Fω, typed lambda calculus with polymorphism and type constructors
02:01:31 <kmc> however there are further restrictions in order to have decidable type inference
02:01:59 <kmc> which roughly follow Hindley-Milner
02:02:14 <merijn> That's slightly deeper then I've gotten so far ;)
02:02:22 <kmc> unlike the System F family, you don't write explicit type applications
02:02:38 <kmc> but you will see them in GHC's intermediate language Core
02:03:34 <kmc> enabling the RankNTypes extension allows you use more of the polymorphism from System Fω, though you can't infer types for all of it
02:04:12 <merijn> As far as I understand simply-typed lambda-calculus and polymorphic calculus are equivalently expressive, but I figure the latter is less verbose/more convenient for the sort of types programmers usually want to write?
02:05:06 <kmc> some other extensions (GADTs, TypeFamilies) add "coercion kinds", which are described in http://www.cse.unsw.edu.au/~chak/papers/SCPD07.html
02:05:13 <kmc> though not visible at source level
02:05:20 <Jafet> > map length . group . map fst $ map (randomR (0,1) . mkStdGen) [0..]
02:05:23 <kmc> merijn, what do you mean by "equivalently expressive"?
02:05:24 <lambdabot>   mueval-core: Time limit exceeded
02:05:52 <kmc> you can't write Haskell's 'id' in STLC
02:06:01 <kmc> only a family of separate identity functions, one for each type
02:06:15 <kmc> merijn, do you have a copy of TaPL?
02:06:20 <Maxdamantus> :t randomR
02:06:21 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
02:06:36 <EvanR> Jafet: the std gen isnt very random in the seed dimensions
02:07:01 <EvanR> dunno if any rngs are
02:07:44 <kmc> merijn, you could implement polymorphism by expanding out to such families at compile time.  this is how C++ templates are typically implemented
02:07:48 <kmc> you duplicate a lot of code that way
02:08:01 <kmc> but it does show equivalent expressiveness in some sense
02:08:13 <EvanR> so what youre saying is that c++ is a turing tarpit
02:08:17 <kmc> hehe
02:08:24 <kmc> C++ is like three or four Turing tarpits
02:08:30 <Starfire> Haha.
02:08:30 <merijn> kmc: Yeah, that occurred to me, but on the other hand that seems strange. With Curry-Howard-DeBruin we have simply-typed is isomorphic with first order propositional logic and polymorphic is isomorphic with second order propositional logic. First and second order propositional logic are equivalently expressive (i.e. anything expressible in one is expressible in the other)
02:09:20 <kmc> merijn, I can tell you're Dutch because nobody else tags de Bruijn's name onto that isomorphism ;)
02:09:24 <merijn> kmc: No, TaPL is still on my to read list. Doing a crash course in type theory for my literature study.
02:09:29 <kmc> cool
02:09:54 <kmc> what do you quantify over in second-order propositional logic?
02:09:55 <ddarius> kmc: I've seen Lambek's and Lawvere's also added.
02:10:05 <merijn> Probably gonna go into Epigram and dependent typing after I finish the basics
02:10:55 <kmc> i thought STLC was plain old (intuitionistic) propositional logic
02:11:06 <kmc> can you call it "first-order" when there are no quantifiers and no predicates?
02:11:53 <Jafet> EvanR: hrm
02:11:59 <kmc> System F quantifies over types, which correspond to propositions
02:12:06 <merijn> We quantify over propositional variables in second order propositional logic
02:12:07 <Jafet> I'd have to rewrite this in IO, then
02:12:07 <kmc> so it is like second-order logic
02:12:15 <kmc> but you only have universal quantifiers
02:12:29 <kmc> though, on the programming side, you can encode existentials with universals in a CPS transform
02:12:34 <kmc> i'm not sure what that means logically
02:12:38 <EvanR> Jafet: what exactly
02:12:42 <kmc> i know CPS can be used to eliminate classical reasoning from certain classical proofs
02:13:22 <ddarius> kmc: It's Kolmogorov's embedding of classical propositional logic and proofs into intuitionistic propositional logic and proofs.
02:14:04 <kmc> so what's the type-theory correspondence of first-order quantification?
02:14:19 <merijn> kmc: The informal comparison I was given that it is similar to first order predicate logic but with all predicates having arity 0
02:14:27 <EvanR> the safest way to get random numbers is to save the state on shutdown and restore on reload
02:14:42 <EvanR> 'random seed' isnt sufficient
02:17:58 <kmc> the safest way to get random numbers is to point a gamma ray source at your CPU
02:18:16 <kmc> fsvo safest
02:18:37 <merijn> If you need truly random data there was a website for scientists which let you query *extremely* random data
02:18:44 <ddarius> You'll turn into the Hulk and be immune to bullets, what could be safer?
02:18:46 <merijn> Something like 7.9 bits of entropy per byte
02:19:18 <kmc> i like the lava lamp approach
02:19:34 <kmc> sure, it's not as theoretically pure as radioactive decay
02:19:38 <kmc> but who can resist that retro style
02:20:08 <merijn> I think they were using a device using the photo-electric effect and quantum chromo-dynamics for their random numbers
02:20:54 <kmc> some microprocessors have RNG hardware now
02:20:58 <kmc> noisy diode junction or somesuch
02:22:34 <Maxdamantus> mknod /dev/null p; mknod /dev/urandom p; cat /dev/null >/dev/urandom
02:27:16 <ddarius> At any rate, FOL would be like a restricted form of dependent typing.  You can't write ∀n∈N.n → n in FOL, that doesn't even make sense.  System F is more like second order logic without the first order part.
02:28:35 <ddarius> And STLC is indeed like the plain propositional logic.
02:32:52 <__yhvh__> hey, having trouble using cabal on windows. cpp is required for the package, which is aliased in cygwin/bin as cpp.exe.lnk (a shortcut) but this seems broken in if I use cmd as admin (required). Advice?
02:33:55 <__yhvh__> ie, cmd as admin doesn't handle shortcuts for some reason
02:50:28 <merijn> __yhvh__: Why not use cpp.exe directly?
02:58:49 <__yhvh__> cabal expects cpp to be on path
02:59:15 <earthy> then change the path :)
02:59:16 <merijn> __yhvh__: So add cpp to your path? :)
03:00:16 <merijn> My windows is a bit rusty, but: Right-click "My Computer" -> Properties -> Something or other  tab -> Click "Environment Variables" -> Select PATH -> Edit to add cpp's directory
03:00:38 <__yhvh__> sorry no. The path is correct, for example I can run cpp-3, which is the pointed to exe, fine
03:00:52 <__yhvh__> in the same directory
03:04:28 <ClaudiusMaximus> ah, hlint annoyment: i have  'not (a < b)' because of NaN risks, but hlint say "error: use >="
03:06:28 <ClaudiusMaximus> > let nan = 0.0 / 0.0 in (not (nan < 42), nan >= 42)
03:06:29 <lambdabot>   (True,False)
03:07:28 <kmc> ClaudiusMaximus, that's to be expected with lint tools :/
03:07:39 <kmc> but fwiw, ndm was very responsive about a bug i filed on another project of his
03:07:42 <kmc> so you could at least bring it up
03:13:12 <ClaudiusMaximus> @seen ndm
03:13:12 <preflex>  ndm was last seen on #haskell 1 year, 157 days, 23 hours, 54 minutes and 31 seconds ago, saying: plus with current compiler technology, it would be slower
03:13:12 <lambdabot> Unknown command, try @list
03:14:04 <quicksilver> he uses a different nick these days, ClaudiusMaximus 
03:14:14 <quicksilver> but certainly he IRCs less now he had to get a real job in the real world :)
03:15:12 <ClaudiusMaximus> ok, i'll file a report on the tracker thing anyway
03:16:06 <merijn> Real jobs ruin open source ;)
03:28:53 <augur> are there any metrics for matrix similarity?
03:32:48 * hackagebot polyToMonoid 0.1 - Polyvariadic functions mapping to a given monoid  http://hackage.haskell.org/package/polyToMonoid-0.1 (KevinJardine)
03:38:51 * hackagebot hexpat 0.19.3 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.19.3 (StephenBlackheath)
03:47:18 <Maxdamantus> > join (==) (0.0/0.0)
03:47:19 <lambdabot>   False
03:47:47 <sipa> :t join
03:47:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:48:00 <Maxdamantus> > join (*) 5
03:48:01 <lambdabot>   25
03:48:23 <sipa> @src join
03:48:23 <lambdabot> join x =  x >>= id
03:48:39 <Maxdamantus> @pl \x -> ap x id
03:48:39 <lambdabot> join
03:50:05 <Maxdamantus> @pl 5 == 5
03:50:05 <lambdabot> True
03:50:16 <Maxdamantus> @pl join (==) 5
03:50:17 <lambdabot> True
03:50:21 <Maxdamantus> @pl join (==) (0.0/0.0)
03:50:22 <lambdabot> join (==) (0 . 0 / 0 . 0)
03:50:25 <Maxdamantus> O_o
03:50:31 <Maxdamantus> Oh, :\
03:50:36 <Maxdamantus> @pl join (==) (0/0)
03:50:36 <lambdabot> 0 / 0 == 0 / 0
03:50:48 <Maxdamantus> :t 0/0
03:50:49 <lambdabot> forall t. (Fractional t) => t
03:51:12 <Maxdamantus> @pl (join .) . (==)
03:51:12 <lambdabot> (join .) . (==)
03:51:53 <Maxdamantus> @pl ((join .) . (==)) 5
03:51:54 <lambdabot> join . (5 ==)
03:52:11 <Maxdamantus> @pl (join . (==)) 5
03:52:11 <lambdabot> join (5 ==)
03:52:26 <Maxdamantus> O_o
03:52:37 <Maxdamantus> > join (5 ==)
03:52:38 <lambdabot>   Couldn't match expected type `t -> a'
03:52:39 <lambdabot>         against inferred type `GHC.Bo...
03:52:44 <Maxdamantus> > (join . (==)) 5
03:52:45 <lambdabot>   Couldn't match expected type `a1 -> a'
03:52:45 <lambdabot>         against inferred type `GHC.B...
03:52:56 <Maxdamantus> Oh, nvm
04:07:52 <orlandu63> Maxdamantus: /query lambdabot
04:51:28 <tomh> hey, what is meant with tying a recursive knot in functional programming?
04:51:39 <bss03> :t join (5 ==)
04:51:40 <lambdabot>     Couldn't match expected type `t -> a' against inferred type `Bool'
04:51:41 <lambdabot>     Probable cause: `==' is applied to too many arguments
04:51:41 <lambdabot>     In the first argument of `join', namely `(5 ==)'
04:53:31 <bss03> :t join compare (0/0)
04:53:32 <lambdabot> Ordering
04:53:37 <bss03> > join compare (0/0)
04:53:38 <lambdabot>   GT
04:53:51 <bss03> > join compare (1/0)
04:53:52 <lambdabot>   EQ
04:53:55 <bss03> > join compare (-1/0)
04:53:56 <lambdabot>   EQ
04:55:53 <bss03> tomh: http://www.haskell.org/haskellwiki/Tying_the_Knot
04:57:16 <tomh> ok thanks
05:10:52 <bss03> "class Monoid v => Measured v a | a -> v where" -- What's the thing that looks like a guard there?
05:10:58 <Botje> functional dependency
05:11:22 <Botje> it tells haskell that if you find a binding for a, it gives a unique binding for v
05:11:39 <Botje> so it only has to search for bindings to a
05:13:24 <bss03> Thanks.
05:18:01 <Blkt> good day everyone
05:18:10 <dmwit> how
05:19:35 <jhenny_> hi..
05:20:23 <jhenny_> i want to know if how to make a running program using haskell
05:21:34 <dmwit> echo 'main = print "Hello, world!"' >> hello.hs && ghc --make hello.hs && ./hello
05:22:15 <Palmik> Yay! My prof. allowed me to use data.Binary :D
05:27:33 <jhenny_> what
05:49:41 <Axius> How do I open a file for reading in haskell?
05:50:23 <sipa> @hoogle open
05:50:23 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
05:50:24 <lambdabot> System.IO openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
05:50:24 <lambdabot> Network.Browser OpenConnection :: BrowserEventType ty
05:50:26 <sioraiocht> :t readFile
05:50:27 <lambdabot> FilePath -> IO String
05:50:59 <sioraiocht> Axius: you have many choices
05:51:06 <ddarius> @hoogle openFile
05:51:06 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
05:51:32 <dmwit> readFile, writeFile, appendFile, withFile are my favorites
05:51:57 <dmwit> (In roughly that order, in fact.)
05:52:38 <ddarius> dmwit: You can't really substitute one of those for the other.
05:53:23 <dmwit> A meaningless objection. I like cheerios more than broken glass, even though broken glass is not a substitute for cheerios.
05:54:06 <koala_man> it doesn't get soggy if you leave it in milk for too long though
05:54:41 <sipa> it's a significantly better cutting utensil
05:55:02 <dmwit> Hey, you can form any preferences you like. I'm only telling you mine.
05:57:50 * ddarius watches dmwit embed Cheerios in the top of his fence to keep intruders out.
06:04:43 * hackagebot http-enumerator 0.2.0.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.2.0.1 (MichaelSnoyman)
06:16:26 <quicksilver> is enumerator the new word for iteratee?
06:20:42 <hpc> @hoogle FilePath
06:20:42 <lambdabot> module System.FilePath
06:20:42 <lambdabot> Prelude type FilePath = String
06:20:43 <lambdabot> System.IO type FilePath = String
06:23:37 <shapr> Are there any other people who are currently, or would like to analyze C codebases with Haskell?
06:25:00 <zygoloid> o/ (hooray for Language.C)
06:25:26 <shapr> zygoloid: Yah, just curious if anyone has done anything with it since the Galois blog post that talked about parsing the Linux kernel?
06:26:30 <zygoloid> shapr: http://control.monad.st/repos/hades/file/tip/hades-lib/Hades/Struct/Generate/Extract.hs
06:27:50 <shapr> zygoloid: I think I got hg installed, but could not figure out how to grab a copy of that code. Any advice?
06:30:00 <zygoloid> shapr: i can grab it with: "hg clone http://control.monad.st/repos/hades" with hg 1.0.2
06:30:19 <shapr> Aha, thanks...
06:30:37 <shapr> Silly me, I could have just taken "summary" off the end.
06:33:12 <shapr> @google filetype:hs "Language.C" -- doesn't turn up as much as I'd hoped
06:34:45 <shapr> Clearly Language.C needs more lovin'
06:35:02 <EvanR-work> i gotta try hades at some point
06:35:16 <zygoloid> i gotta get back to developing it ;)
06:35:20 <EvanR-work> the name sells it all
06:36:19 <zygoloid> i feel like i'm pretty close to being able to implement the 'find my space leak' feature, which'd be awesome
06:36:49 <EvanR-work> heh
06:36:57 <shapr> Hm, I can totally hack the Aaron Tomb's demo code to see if there are any problems parsing Asterisk...
06:40:29 <sioraiocht> Hrm, are there any plans to patch lhs2TeX to work with GHC 6.12 and unicode characters?
06:40:29 <sioraiocht> or do I need to do this> ;)
06:40:29 <lambdabot> No Result Found.
06:40:47 <ddarius> It will probably happen sooner if you do it.
06:41:24 <shapr> So now just need to figure out how to preprocess a bunch of C source so Language.C can read it...
06:41:43 <EvanR-work> @src Monad
06:41:43 <lambdabot> class  Monad m  where
06:41:43 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
06:41:43 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
06:41:43 <lambdabot>     return      :: a -> m a
06:41:43 <lambdabot>     fail        :: String -> m a
06:42:13 <shapr> Is Aaron Tomb on #haskell?
06:42:18 <ddarius> cpp foo.c | myLanguageDotCProgram
06:42:19 <sjoerd_visscher> hi, could somebody check for me if this hangs GHC 7 too: http://gist.github.com/626056
06:42:22 * benmachine wonders why two of those signatures are foralled
06:43:05 <quicksilver> benmachine: @src is a work of fiction perpetuated by human beings.
06:43:13 <benmachine> quicksilver: I'm aware
06:43:30 <benmachine> but I wonder why said human beings made those design choices sometimes
06:44:21 <benmachine> shapr: cpphs does that, doesn't it?
06:45:03 <EvanR-work> is Monad restricted with only return and >> somehow a monoid?
06:45:21 <benmachine> EvanR-work: (Monad m) => m () is a monoid
06:45:24 <shapr> benmachine: I think so, but this demo from two years ago said GCC's preproc is required.
06:45:33 <benmachine> (Monad m) => a -> m a is also a monoid
06:45:36 <ddarius> benmachine: Or even m a if you return undefined.
06:46:03 <EvanR-work> a monad restricted to a single type is a monoid?
06:46:48 <EvanR-work> whats zero?
06:47:05 <quicksilver> return () in the first case; return in the second.
06:47:45 <EvanR-work> im guessing m () and m a are both devoid of content?
06:48:09 <quicksilver> (a -> m a) is not devoid of content.
06:48:17 <EvanR-work> yeah
06:48:21 <quicksilver> in fact, neither is m ()
06:48:25 <quicksilver> it just depends what you mean by content.
06:48:42 <ddarius> instance Monad m => Monoid (m a) where mempty = return undefined; mappend = (>>)
06:48:50 <ddarius> Or set a to () and return ().
06:48:55 <quicksilver> yes, I reject ddarius's first instance.
06:49:12 <quicksilver> return undefined is not a good zero.
06:49:18 <ddarius> Sure it is.
06:49:28 <quicksilver> I am making a subjective judgement.
06:49:38 <ddarius> So it's an evil zero.
06:49:56 <quicksilver> the proof that these monoids are indeed monoids involves the monad laws.
06:50:01 <quicksilver> since the monad laws only hold for total values
06:50:05 <fryguybob> sjoerd_visscher: It appears to for me: http://hpaste.org/40569/hang
06:50:09 <ddarius> The monad laws hold for all values.
06:50:21 <quicksilver> it seems inappropriate to include _|_ in one.
06:50:46 <sjoerd_visscher> fryguybob: thanks!
06:50:53 <quicksilver> even the monoid laws fail for _|_ values.
06:51:06 <quicksilver> or maybe not, actually.
06:51:21 <fryguybob> sjoerd_visscher: Seems to do the same on 6.12.3, but I can't ^C out of it then :D.
06:51:36 <EvanR-work> yall need to clear up that monad law _|_ thing ;)
06:51:39 <quicksilver> ddarius: you were here in the discussion yesterday during which we showed that the monad laws don't hold for _|_.
06:51:58 <ddarius> quicksilver: No, all that was shown is that some instances fail to satisfy the monad laws.
06:52:16 <quicksilver> almost all of them, IIRC
06:52:30 <quicksilver> so that's not a notion of law I find interesting.
06:52:37 <quicksilver> I want the laws which all the monads I use actually pass
06:52:46 <quicksilver> and I acheive that by excluding _|_.
06:52:58 <ddarius> Uh, most monad instances satisfy the monad laws, or can be made to satisfy the monad laws.
06:56:02 <quicksilver> my memory is that both State and Reader, as well as IO, fail the laws because, basically, return undefined != undefined.
06:56:04 <kosmikus> sioraiocht: (lhs2tex) isn't this working?
06:56:11 <quicksilver> which is, in turn, because \_ -> undefined != undefined.
06:56:29 <quicksilver> I could have the details muddled, but for this reason I take the laws over total values only.
06:56:35 <sioraiocht> kosmikus: aye, with 6.12, if you have non-ASCII characters in your source (a ralfh favourite), it bails when trying to read the file
06:56:47 <sioraiocht> I assume this is because of the change to locale-aware file I/O
06:57:19 <sioraiocht> It is not a problem for such characters in the LaTeX source, but if they appear in source code environments it is
07:01:32 <sioraiocht> kosmikus: I am happy to try and make a patch if you like..
07:01:52 * shapr hugs kosmikus 
07:02:37 <shapr> hiya jkoshy, how's code?
07:05:08 <quicksilver> it fails for state, reader, writer and continuation.
07:05:08 <jkoshy> shapr: no code yet in haskell
07:05:14 <quicksilver> almost everything in other words :)
07:05:18 <quicksilver> http://www.mail-archive.com/haskell@haskell.org/msg10869.html
07:06:26 <shapr> jkoshy: Working on anything interesting?
07:06:38 <jkoshy> shapr: http://elftoolchain.sf.net/
07:06:52 <benmachine> quicksilver: interesting. but couldn't you just disqualify seq, instead of all partiality?
07:06:59 <benmachine> that would seem "safer" to me
07:07:01 <shapr> jkoshy: interesting
07:07:09 <benmachine> and more logical since seq is a bit of a hack in any case >_>
07:07:40 <quicksilver> benmachine: yes, you can do something like that.
07:07:54 <benmachine> quicksilver: but *you* don't :P
07:07:54 <shapr> jkoshy: Is there already an ELF parser written in Haskell?
07:08:01 <ray> icfp '11 will have a contest i hope
07:08:25 <jkoshy> shapr: not that I know of, but its an interesting idea
07:08:46 <quicksilver> benmachine: yes, because it's not the only reason I have to dislike constructs like 'return undefined'.
07:08:55 <quicksilver> benmachine: they also break parametricity / theorems for free.
07:08:57 <ddarius> ray: As far as I know, they all have for the past ten or so years.
07:09:14 <ray> will they fly me out there if i win? :)
07:09:22 <benmachine> quicksilver: they do? that surprises me
07:09:22 <quicksilver> benmachine: there is only one possible type correct definition of fst.
07:09:29 <benmachine> ah
07:09:30 <quicksilver> @djinn (a,b) -> a
07:09:30 <lambdabot> f (a, _) = a
07:09:36 <quicksilver> benmachine: unless you permit undefined.
07:09:40 <quicksilver> benmachine: in which case there are in infinity
07:09:45 <benmachine> huh?
07:09:46 <quicksilver> well, a syntactic infinity. 
07:09:56 <benmachine> yes but it's usual to consider all bottoms equivalent
07:10:18 <quicksilver> in more complex examples it's not immediately clear what is bottom
07:10:19 <ddarius> There is a syntactic infinity of ways to write the above definition of fst.
07:10:37 <quicksilver> benmachine: if you take, for a more interesting example, map
07:10:45 <quicksilver> benmachine: then you have a parameter which is a function
07:10:57 <quicksilver> benmachine: "f undefined" is not, in general, _|_
07:11:05 <benmachine> quicksilver: right
07:11:20 <quicksilver> although undefined undefined is _|_.
07:11:22 <quicksilver> etc.
07:11:28 * benmachine blinks
07:11:33 <quicksilver> > undefined undefined
07:11:34 <lambdabot>   *Exception: Prelude.undefined
07:11:37 <benmachine> well yes
07:11:44 <benmachine> undefined is strict >_>
07:11:51 <benmachine> what relevance does that have
07:12:09 <quicksilver> @djinn (a -> b) -> Maybe a -> Maybe b
07:12:09 <lambdabot> f a b =
07:12:09 <lambdabot>     case b of
07:12:09 <lambdabot>     Nothing -> Nothing
07:12:09 <lambdabot>     Just c -> Just (a c)
07:12:38 <quicksilver> ^^ if I'm allowed _|_ I can replace various parts of that expression with _|_
07:12:51 <quicksilver> which ones are equivalent is not immediately clear.
07:12:59 * quicksilver shrugs.
07:13:06 <quicksilver> it's not an important point I'm making, here.
07:13:19 <quicksilver> the important point is that I like there to be only one answer for these types - I like parametricity.
07:13:21 <benmachine> quicksilver: I don't think it ruins parametricity though; I think the number of possibilities it adds is finite and usually quite small
07:13:23 <quicksilver> _|_ breaks it.
07:13:40 <benmachine> except in the presence of seq, where there are often quite a lot of possibilities - but still, I think, finitely many
07:13:44 <ddarius> Parametricity doesn't guarantee only one answer for a type.
07:14:07 <benmachine> parametricity also tells you that, e.g, "a -> a -> a" has two answers
07:14:20 <benmachine> in the presence of bottoms-but-not-seq, that becomes three
07:14:38 <benmachine> in the presence of seq it's about six I think
07:15:42 <quicksilver> ddarius: sure, but it's one answer for these particular examples
07:15:54 <quicksilver> and two for benmachine's, and so on and so on.
07:16:05 <quicksilver> I'm sure we're pointlessly picking apart a point all three of us understand :)
07:16:08 <zygoloid> ddarius: your 'instance Monad m => Monoid (m a) where mempty = return undefined; mappend = (>>)' is not a monoid. return 42 >> return undefined != return 42.
07:16:36 <quicksilver> zygoloid++ # a better objection ;)
07:16:41 <kosmikus> sioraiocht: you are using 1.16, right?
07:16:49 <sioraiocht> kosmikus: yep!
07:17:01 <benmachine> zygoloid: if it was someting like (exists a. m a), you couldn't extract the 42 so you wouldn't be able to tell
07:17:04 <sioraiocht> kosmikus: wait a second
07:17:07 <sioraiocht> kosmikus: let me check
07:17:18 <benmachine> but yeah I did think there was a reason why I used () instead of a
07:17:29 <quicksilver> benmachine: right, and exists a . m a is pretty much m ()
07:17:33 <ddarius> m (forall a. a) then, even better than ()
07:17:49 <benmachine> m Void >_>
07:18:18 <ddarius> Actually, (>>) :: (forall a. m a) -> (forall a. m a) -> (forall a. m a) in my example.
07:18:31 <ddarius> Er mappend
07:19:19 <ddarius> So, return 42 >> return undefined would be a type error.
07:19:34 <kosmikus> sioraiocht: if there's really a problem with 1.16, then I need a minimal example file that shows the problem. Please mail it to me.
07:19:40 <zygoloid> ddarius: or i think you can fix it with: mempty = return undefined; mappend = liftM2 seq.
07:19:42 <sioraiocht> kosmikus: will do
07:20:18 <kosmikus> I'm just surprised, because I'm using lhs2tex in Agda mode with Unicode and 6.12 all the time. So it must be something that only breaks in Haskell mode ...
07:20:35 <sioraiocht> kosmikus: okay
07:20:46 <sioraiocht> it was definitely broken in 1.15
07:20:49 <ddarius> zygoloid: Strictness had nothing to do with it.
07:21:11 <kosmikus> sioraiocht: I know. That's why there is 1.16.
07:21:15 <sioraiocht> :)
07:21:17 <benmachine> return 42 >> return undefined in the list monad is [undefined]
07:21:29 <benmachine> if you set up the types so you can't inspect the elements of the list, then it's fine
07:21:32 <sioraiocht> kosmikus: okay, it does appear to be working in 1.16
07:21:41 <sioraiocht> so sorry for the false alarm =)
07:23:12 <EvanR-work> :t let x = x in x
07:23:12 <lambdabot> forall t. t
07:23:26 <kosmikus> sioraiocht: well, good news then :)
07:23:27 <EvanR-work> > length (let x = in x in x)
07:23:29 <lambdabot>   <no location info>: parse error on input `in'
07:23:34 <EvanR-work> > length (let x = x in x)
07:23:38 <lambdabot>   mueval-core: Time limit exceeded
07:23:46 <EvanR-work> > 1+(let x = x in x)
07:23:50 <lambdabot>   mueval-core: Time limit exceeded
07:24:04 <EvanR-work> compiler defeated!
07:24:10 <zygoloid> ddarius: hmm, no, you're right. :)
07:30:45 <EvanR-work> does Applicative f require that f be able to 'contain' any function?
07:30:50 <EvanR-work> between any two types
07:31:40 <benmachine> Functor f does
07:31:45 <benmachine> (so yes)
07:32:32 <EvanR-work> data T a = ... requires T to 'contain' any function between any two types?
07:32:40 <EvanR-work> so i guess it has nothing to do with applicative or functor
07:32:52 <EvanR-work> be able to contain*
07:34:22 <zygoloid> EvanR-work: yeah, f :: * -> * requires f to accept any type :: *, including (a -> b)
07:35:36 <EvanR-work> so what happens if you try to x <*> y where x doesnt have a function, type error?
07:36:14 <zygoloid> @type (<*>)
07:36:15 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:36:16 <zygoloid> ^^ yeah.
07:36:56 <co_dh> what's the best way to do string interpolation in haskell? 
07:37:08 <EvanR-work> ok and the compiler knows at compile time whether this particular f has a (->)
07:37:16 <sipa> EvanR-work: yes
07:37:28 <sipa> it needs to
07:37:29 <EvanR-work> funky
07:39:27 <quicksilver> co_dh: the simplest idiom is just to use concat, in my opinion
07:39:57 <EvanR-work> > let x = "bar" in concat ["foo ", x, " baz"]
07:39:58 <lambdabot>   "foo bar baz"
07:39:59 <quicksilver> > let name = "co_dh" in concat [ "Hello and welcome, ", name, " to our friendly IRC channel"]
07:40:00 <lambdabot>   "Hello and welcome, co_dh to our friendly IRC channel"
07:40:08 <co_dh> "abcd " ++ ( show i ) ++ "def" is kind of ugly
07:40:18 <EvanR-work> :t concat
07:40:19 <lambdabot> forall a. [[a]] -> [a]
07:40:22 <EvanR-work> :t (++)
07:40:23 <lambdabot> forall m. (Monoid m) => m -> m -> m
07:40:49 <quicksilver> > let age=25 in concat [ "Today is my birthday, I just turned", show age, ", lucky me!"]
07:40:50 <lambdabot>   "Today is my birthday, I just turned25, lucky me!"
07:41:06 <alex404> God damn if it isn't possible to do some spooky magic with the list monad.
07:41:12 <quicksilver> co_dh: I find the commas (and syntax highlighting) less ugly than ++
07:41:18 <co_dh> quicksilver, thanks, seems better than ++
07:41:19 <quicksilver> co_dh: but I agree it's not a huge improvement.
07:41:45 <EvanR-work> you if really must insist, theres Text.Printf
07:41:53 <co_dh> I miss python's multiline string 
07:42:03 <EvanR-work> but its overkill at the same time as not much more functional
07:42:12 <EvanR-work> haskell has multiline strings
07:42:19 <benmachine> co_dh: quasiquoters are useful for this sort of thing if you're not afraid of extensions
07:42:33 <benmachine> haskell's multiline strings are a bit crude
07:42:52 <EvanR-work> i dont know how else you could do it without messing up layout
07:43:38 <EvanR-work> i guess however python does it, since it also has layout
07:43:45 <co_dh> for multiline string , you can indent all the lines  of string .
07:44:02 <EvanR-work> it ignores your indentation?
07:44:10 <EvanR-work> how do you specify not to ignore ?
07:44:10 <co_dh> yaml 's string literal has both multline and indent. 
07:44:24 <co_dh> EvanR-work : yes , ignore identation , and join the lines. 
07:45:01 <quicksilver> haskell's multiline strings can ignore indents too but they're seriously ugly
07:45:04 <quicksilver> (to my eyes)
07:45:21 <quicksilver> I just use concat or unlines + a big list of string literals.
07:45:22 <EvanR-work> im using them for snippets of sql code, for larger text i would use a text file
07:45:30 <quicksilver> if it gets reallly big I would use an external file
07:45:31 <quicksilver> right.
07:46:42 <EvanR-work> funny because i did this concat thing in javascript way before i got into haskell, because js has the same nonexistence 'string interpolation feature'
07:46:48 <EvanR-work> and it works out great
07:47:11 <EvanR-work> about 25% as much code as prototype builder
07:47:34 <EvanR-work> looks better in haskell
07:47:35 <co_dh> about 80% code are thrown away.
07:48:33 <EvanR-work> > printf "insert $d coin(s)" 1
07:48:34 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:48:34 <lambdabot>    `Text.Printf.PrintfType ...
07:48:39 <EvanR-work> > printf "insert $d coin(s)" 1 :: String
07:48:40 <lambdabot>   "insert $d coin(s)*Exception: Printf.printf: formatting string ended premat...
07:48:46 <EvanR-work> > printf "insert %d coin(s)" 1 :: String
07:48:47 <lambdabot>   "insert 1 coin(s)"
07:49:10 <co_dh> the %d stuff is kind of messy when you have 5 or 6 %d inside. 
07:49:53 <EvanR-work> do you really have a giant monolithic template you need to substitute 6 single atomic values?
07:52:17 <co_dh> EvanR: in my last job, we have sql statement of about 40 %s 
07:52:31 <co_dh> mapping an object to a sql. 
07:52:39 <quicksilver> co_dh: did your last company go out of business due to a terrible computer security incident?
07:52:44 <quicksilver> (caused by an SQL injection)
07:52:51 <EvanR-work> well object mapping to sql is a mistake in general
07:52:55 <quicksilver> nobody should be creating SQL that way :)
07:53:00 <co_dh> quicksilver: no , have have sql injection check. 
07:53:12 <quicksilver> I was, mostly, joking. But that's horrible design.
07:53:28 <co_dh> EvanR: I agree ORM is a mistake, but not all programmer agree. 
07:53:38 <EvanR-work> of course they dont...
07:53:41 <quicksilver> anyhow if you do want to do things along those lines I'd suggest a proper templating language
07:53:53 <quicksilver> I've no used any of the haskell ones but there are a few.
07:54:28 <quicksilver> I liked the sound of this one : http://fmapfixreturn.wordpress.com/2008/01/14/hstringtemplate-an-elegant-functional-nifty-templating-engine-for-haskell/
07:54:34 <co_dh> template language is an overkill. when there is a bug in the template language, oh my god. 
07:54:34 <quicksilver> (but I've only read the blog post, not actually used it)
07:55:01 <quicksilver> a simple template language is OK. The trick is keeping it simple.
07:55:08 <quicksilver> and being careful what you use it for.
07:55:23 <quicksilver> for what your'e talking about - simple substitutions into lengthy text - it's handy.
07:55:43 <Vitka> :t >>= >>=
07:55:44 <lambdabot> parse error on input `>>='
07:56:21 <EvanR-work> functional programming is already its own template language
07:56:51 <EvanR-work> concat can be hidden by combinators
07:57:54 <quicksilver> EvanR-work: true but for large tracts of text it's not necessarily attractive to have them inlined in your haskell.
07:59:09 <EvanR-work> missingH, replace :: Eq a => [a] -> [a] -> [a] -> [a] ;)
07:59:28 <EvanR-work> replace old new l = join new . split old $ l
08:00:26 * quicksilver shrugs
08:00:31 <quicksilver> that's writing your own simple template language.
08:00:34 <quicksilver> fine, if you like ;)
08:00:56 <quicksilver> I've written several over the years but now I mostly use prewritten ones.
08:01:32 <EvanR-work> if his team is already used to $foo, replace "$foo" (show x) l isnt inventing anything
08:01:52 <EvanR-work> import Data.String.Utils
08:02:59 <quicksilver> except that breaks if there is also a variable called $fooble.
08:03:06 * quicksilver shrugs.
08:03:14 <EvanR-work> go use php! *storms off*
08:04:44 <co_dh> There is no document in Language.Haskell.Meta.QQ , sigh
08:07:11 <EvanR-work> co_dh: hamlet
08:07:12 * EvanR-work runs
08:07:20 <co_dh> I can't install interpolation , because  haskell-src-meta-0.0.0 requries base == 4.2.*
08:11:28 <co_dh> :t parseAbsoluteURI
08:11:28 <lambdabot> Not in scope: `parseAbsoluteURI'
08:12:11 <osaunders> Any idea how I might go about fixing this? <http://hpaste.org/40570/cabal_install_problem>
08:12:49 <co_dh> lol
08:14:47 <co_dh> there is a bug in parseAbsoluteURI , 
08:14:51 <agundry> osaunders: check out http://www.haskell.org/cabal/FAQ.html#dependencies-conflict
08:15:28 <co_dh> it won't parse "usr%40abc.com:pass@abc.com"
08:15:56 <co_dh> my company use something like usr@abc.com as user name . 
08:16:15 <EvanR-work> why escape @ ?
08:16:19 <co_dh> parseAbsoluteURI can't parse %40, 
08:16:40 <co_dh> because @ is used to split the usr:pass with abc.com:8080
08:16:53 <EvanR-work> why %40
08:17:29 <co_dh> %40 is @ 
08:17:34 <EvanR-work> why %40
08:17:38 <EvanR-work> why escape @
08:17:58 <sipa> otherwise it would be usr@abc.com:pass@abc.com
08:18:01 <co_dh> rfc3986,  3.2.1    userinfo = * ( unreserved /pct-encoded / sub-delims / ":")
08:18:05 <osaunders> agundry: Thanks I'm reading now.
08:18:13 <co_dh> > ord '@'
08:18:13 <lambdabot>   64
08:18:23 <EvanR-work> isnt it supposed to be user:pass@domain:port/ ?
08:18:41 <co_dh> pct-encoded   = "%" HEXDIG HEXDIG
08:18:58 <co_dh> I have @ in user
08:19:03 <EvanR-work> oh
08:19:51 <EvanR-work> there may be more than one url function in several packages
08:20:06 <EvanR-work> or write your own using splitOn
08:20:39 <co_dh> cabal update use that function . 
08:21:51 <co_dh> good night , guys :)
08:29:55 <Guest86956> hi
08:30:48 <Guest86956> is this the place to ask simple question about something I want to do in Haskell XD?
08:31:04 <flux> yes, #haskell can do that
08:32:08 <EvanR-work> simple questions will get category theoretic answers
08:32:30 <Guest86956> Okay thanks!
08:32:41 <sipa> Guest86956: just ask it :)
08:32:59 <Guest86956> I have a small actually not really a problem but, something I want to do. It goes like this: I a type named Person, which consist of Female and Male. Very simple. I want to do is make an instance of Eq so I can compare them.
08:33:05 <Guest86956> It all works well however, there is a catch
08:33:16 <Guest86956> if I try this: Female == Female
08:33:27 <Guest86956> it will say my definition of == is ambiguous
08:33:38 <Guest86956> I have to do Programname.== to get it work
08:33:57 <Guest86956> but there is in the Prelude no instance of Eq Person
08:34:10 <EvanR-work> you must not have defined the instance correctly
08:34:12 <Guest86956> so the only instance is defined in my program
08:34:23 <Guest86956> if Female programname.== Female
08:34:28 <Guest86956> then it will return correctly yes
08:34:37 <ray> http://hpaste.org/ paste code
08:35:24 <Guest86956> okay hold on
08:36:37 <ahihi> what about people who fall outside the gender binary? :(
08:37:04 <EvanR-work> like stay at home dads?
08:37:29 <ray> then you use data Person = Female | Male | FileNotFound
08:37:51 <EvanR-work> Abort | Retry | Ignore
08:38:09 <Guest86956> Okay
08:38:12 <Guest86956> http://hpaste.org/40571/test
08:38:15 <Guest86956> here can you see this?
08:38:43 <ray> indent your lines after instance
08:38:54 <Guest86956> okay
08:39:10 <ray> i figured that was probably what was up
08:39:24 <Guest86956> yes, thanks!
08:39:31 <Guest86956> such a stupid simple mistake!
08:39:42 <Guest86956> unbelieveable XD
08:39:45 <EvanR-work> does lambdabot have instances like Monad Maybe ?
08:39:56 <ray> @instances Monad
08:39:56 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:40:06 <EvanR-work> instance defs
08:40:12 <Guest86956> Thanks guys!
08:40:14 <ray> you mean in @src?
08:40:17 <ray> it has some
08:40:23 <EvanR-work> @src Monad Maybe
08:40:23 <lambdabot> Source not found. My mind is going. I can feel it.
08:40:55 <Guest86956> @Ray you're awesome thanks!
08:40:56 <lambdabot> Maybe you meant: faq map
08:41:02 <ray> np
08:41:10 <EvanR-work> @map
08:41:10 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
08:41:24 <ray> =o
08:41:39 <EvanR-work> i knew it
08:41:43 <EvanR-work> ghc has spyware
08:41:54 <Guest86956> Okay, now another question, if I have like 1000 Gender types like: Male, Female, Doesnotexist, something, something2 etc.
08:42:02 <Guest86956> do I really need to define each Male == Male
08:42:06 <Guest86956> and Male == __
08:42:09 <ray> in a real program you'd derive Eq
08:42:10 <EvanR-work> deriving (Eq)
08:42:12 <Guest86956> Male == _
08:42:15 <Guest86956> to get it all working?
08:42:20 <Guest86956> or can it be "easier"?
08:42:38 <EvanR-work> data Gender = A | B | C deriving (Eq)
08:43:21 <EvanR-work> now x==y if and only if x is the same constructor as y
08:43:40 <sipa> and all members of the constructor are comparable as well
08:43:54 <EvanR-work> if there are members, compares members
08:48:45 <freiksenet> is there a way to create a closure in haskell that will somehow capture local state? Simplest example is just counter which increments itself at every call and return incremented result
08:50:26 <Lemmih> freiksenet: do ref <- newIORef 0; return (do modifyIORef ref succ; readIORef ref)
08:50:49 <roconnor> do ref <- newSTRef 0; return (do modifySTRef ref succ; readSTRef ref)
08:50:51 <roconnor> :)
08:51:49 <freiksenet> thanks
08:55:03 <EvanR-work> gross!
08:55:21 <EvanR-work> (the object oriented counter, not the haskell)
08:57:07 <tolkad> are there any plans to allow partial application of type synonyms in instance declarations?
08:57:18 <EvanR-work> isnt that an extension
08:57:44 <tolkad> no
08:57:50 <tolkad> not that I know of
08:58:38 <pumpkin> no
08:59:18 <gigabytes> a little question please: will it work if I connect a signal(bool) to a slot(int), assuming I want to convert false to zero and true to one, as happens in normal C++ type conversion?
08:59:34 <tolkad> also it's kind of annoying that intance deduction doesn't detect when the set of instances for a type family makes it  impossible for some type to not have an instance
08:59:44 <tolkad> of a class that is
08:59:49 <gigabytes> aaah
08:59:50 <gigabytes> sorry
08:59:52 <gigabytes> wrong channel :P
08:59:55 <pumpkin> tolkad: how would it do that?
09:00:12 <tolkad> pumpkin: I'm not sure, I know that I can do it for a simple case
09:00:19 <pumpkin> tolkad: the issue is that type families are open
09:00:22 <pumpkin> anyone can add instances later
09:00:46 <pumpkin> you can join the huge list of people (including me) clamoring for closed type families
09:00:48 <pumpkin> :)
09:00:57 <tolkad> heh
09:01:13 <tolkad> that would be nice
09:01:55 <tolkad> also, this is kind of cool:
09:01:56 <tolkad> class EquivalentTypes a b
09:01:56 <tolkad> instance EquivalentTypes a a
09:02:49 <tolkad> will that actually work?
09:02:57 <lispy> you'd need flexible instances
09:03:26 <lispy> But, I don't really see how it's going to work...
09:04:34 <tolkad> I could put it on a function that uses type synonyms to ensure stuff is resolving like I want it to
09:08:04 <pumpkin> why not use GADTs and/or ~ ?
09:08:11 <pumpkin> (they're almost equivalent)
09:09:20 <tolkad> I thought ~ is for lazy pattern matching?
09:09:54 <dolio> ~ is also used in GHC for type equality constraints.
09:10:00 <dolio> (a ~ b) => ...
09:10:48 <mxc> > [read "2009-02-26" .. read "2009-03-01"] :: [Day]
09:10:48 <aristid> hackagebot: go!
09:10:49 <lambdabot>   Not in scope: type constructor or class `Day'
09:11:03 <mxc> > [read "2009-02-26" .. read "2009-03-01"] :: [Data.Time.Calendar.Day]
09:11:04 <lambdabot>   Not in scope: type constructor or class `Data.Time.Calendar.Day'
09:11:07 <pumpkin> tolkad: and you can write a GADT for what you're after (and it actually reduces down to a use of ~, sort of
09:11:32 * hackagebot shortcircuit 0.1 - Short-circuit values and expressions.  http://hackage.haskell.org/package/shortcircuit-0.1 (AristidBreitkreuz)
09:11:40 <tolkad> cool, thanks
09:11:40 <aristid> hackagebot: *cookie*
09:11:51 <tolkad> dolio: does that require an extension?
09:12:00 <dolio> TypeFamilies
09:12:33 <mxc> is it a known bug that the Enum instance for Day doesn't know about leap years?
09:12:41 <aristid> zygoloid: iirc we were talking about orElse :: Monad m => m (Maybe a) -> m (Maybe a) -> m (Maybe a) yesterday. i generalised it, and made a new package :)
09:12:50 <tolkad> "The current implementation of type families does not support equality constraints in superclass contexts." : (
09:13:01 <dolio> They work in 7.0
09:16:19 <dolio> They work everywhere but superclass contexts in 6.12, I believe.
09:19:06 <pumpkin> oh wow, they added them in superclass constraints in 7?
09:19:17 <pumpkin> ivanm will be please
09:19:17 <pumpkin> d
09:20:31 <dolio> I imagine finally getting them working was one of the points of the rewrite.
09:21:58 <pumpkin> yeah, but I remember TacticalGrace mentioning that they needed some changes in the core language too
09:22:25 <tolkad> why do they require changes if you can just do the instance hack I mentioned before?
09:22:29 <tolkad> or does it not work?
09:23:38 <tolkad> it seems to work
09:23:57 <tolkad> they could have just implemented it as that hack :P
09:24:28 <monochrom> you could have just forked ghc and done exactly that.
09:24:42 <pumpkin> tolkad: as I said, type families are not closed
09:24:59 <pumpkin> tolkad: what's stopping someone else from making an instance for something else?
09:25:14 <tolkad> pumpkin: it was a class not a type family
09:25:31 <tolkad> class EquivalentTypes a b; instance EquivalentTypes a a
09:25:42 <pumpkin> you can still make other instances
09:25:47 <pumpkin> and GHC doesn't know you can't
09:25:48 <pumpkin> even if you hide it
09:25:53 <aristid> pumpkin: you can limit typeclasses with bijectional fundeps :)
09:26:00 <tolkad> pumpkin: why does that matter?
09:26:03 <aristid> *bijective (i think)
09:26:11 <pumpkin> aristid: GHC still doesn't know it's limited that way
09:26:19 <tolkad> aristid: 0_0
09:26:21 <aristid> hmm. but it is limited
09:26:48 <pumpkin> tolkad: it will still let you write (EquivalentTypes Int Bool) =>
09:26:59 <pumpkin> because it doesn't know that Int and Bool don't have an instance
09:27:14 <aristid> hm there should be a way to make closed classes
09:27:26 <tolkad> pumpkin: BUt it would fail when it looked and there wasn't an instance right?
09:27:40 <pumpkin> tolkad: no, because someone could always go and add an instance down the line
09:27:46 <pumpkin> that's the issue with open vs. closed
09:28:00 <alin_> any help for this? explain and correct the 3 syntactic errors in the script: N = a 'div' length xs where a = 10 xs = [1,2,3,4,5]
09:28:05 <tolkad> pumpkin: if they tried to USE it then it would fail though right?
09:28:28 <pumpkin> tolkad: depends, it could just add the constraint to the function
09:28:35 <monochrom> N is an uppercase letter
09:28:41 <pumpkin> userFunction :: EquivalentTypes Int Bool => x -> y
09:28:46 <alin_> ok
09:28:48 <tolkad> pumpkin: yeah but if you ever want to use that function you will run into a problem
09:28:52 <pumpkin> alin_: '' vs ``
09:29:06 <pumpkin> tolkad: sure
09:29:13 <pumpkin> that isn't desirable behavior though
09:29:17 <monochrom> the rest should be obvious
09:29:19 <pumpkin> it's pushing the error away from where it actually is
09:29:19 <tolkad> pumpkin: I get the point though, it's not as powerful as ~
09:29:52 <tolkad> I want ~ for superclasses
09:29:54 <monochrom> you can always enter it into a file, compile, and see errors
09:29:56 <pumpkin> use GHC 7 :)
09:30:20 <tolkad> pumpkin: idk... last time I upgraded GHC everything broke and it took forever messing with cabal to fix it
09:30:28 <pumpkin> tolkad: aw, okay :P
09:30:40 <shortcircuit> Oi.
09:30:56 <shortcircuit> This is going to be fun... 16:11  * hackagebot shortcircuit 0.1 - Short-circuit values and expressions.  http://hackage.haskell.org/package/shortcircuit-0.1 (AristidBreitkreuz)
09:31:00 <shortcircuit> :)
09:31:48 <tolkad> if you use an unpack pragma on a newtype will it unpack the underlying type?
09:32:11 <pumpkin> newtype wouldn't need it
09:32:22 <monochrom> yes
09:32:35 <pumpkin> what would it mean to unpack the underlying type?
09:32:38 <pumpkin> you unpack fields
09:32:52 <pumpkin> and newtypes have one field that's already "unpacked"
09:33:11 <monochrom> newtype X = X { this'is'a'field: X }   now you see the field
09:33:35 <tolkad> I mean newtype MyFloat = MyFloat Float; data T = T {-# UNPACK #-} !MyFloat
09:33:48 <tolkad> will T hold an unboxed float?
09:34:14 <monochrom> yes
09:35:53 <pumpkin> it will?
09:36:49 <pumpkin> use ghc-core and find out
09:36:52 <pumpkin> I'd have guessed not
09:37:12 <tolkad> uh not sure what ghc-core is
09:37:36 <tolkad> oh http://hackage.haskell.org/package/ghc-core
09:37:54 <monochrom> it is another thing to break and need forever fixing when you upgrade ghc
09:37:55 <pumpkin> it spits out GHC's intermediate compilation language
09:37:59 <maurer_> Prelude> -9 `mod` (-4)
09:37:59 <maurer_> 3
09:38:05 <maurer_> ^What is this nonsense?
09:38:12 <pumpkin> maurer_: makes sense to me
09:38:25 <pumpkin> -9 = -4 * 3 + 3
09:38:32 <Twey> Distanec between -12 and -9 is 3
09:38:36 <Twey> Distance**
09:38:48 <Twey> If you want one that goes towards zero, use ‘quot’
09:38:52 <tolkad> oh well tha's great: pcre-light-0.4 failed during the configure step. The exception was: exit: ExitFailure 1
09:38:55 <Twey> > -9 `quot` (-4)
09:38:56 <maurer_> I guess I just assumed `mod` acted like the modulus operation on the cpu
09:38:56 <lambdabot>   2
09:39:17 <tolkad> -v offers no more information
09:39:25 <Twey> Hm, no, that's not right
09:39:26 <maurer_> Hm. quot doesn't quite do what I want either, but I guess I'll just write a custom function.
09:39:46 <pumpkin> > -9 `rem` (-4)
09:39:47 <lambdabot>   -1
09:39:48 <Twey> No, there's one already around.  I can just never remember what they all do.
09:39:51 <Twey> rem, that's the one.
09:40:00 <pumpkin> maurer_?
09:40:05 <Twey> What's quot doing there, then?
09:40:15 <pumpkin> quot <=> div
09:40:17 <monochrom> quot = quotient
09:40:21 <Twey> Oh, right
09:40:22 <pumpkin> rem <=> mod
09:40:23 <FunctorSalad_> quot:div :: rem:mod
09:40:24 <Twey> Okay
09:40:50 <benmachine> :t quotDiv
09:40:51 <benmachine> er
09:40:51 <lambdabot> Not in scope: `quotDiv'
09:40:53 <monochrom> the exact sign behaviour of quot,rem, div,mod are carefully spec'ed out in the report
09:40:54 <benmachine> :t quotRem
09:40:54 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
09:40:56 <benmachine> :t divMod
09:40:57 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
09:40:58 <tolkad> > -9 `rem` (-4)
09:40:59 <lambdabot>   -1
09:41:13 <benmachine> > -(9 `mod` (-4))
09:41:14 <lambdabot>   3
09:41:16 <benmachine> > -9 `mod` (-4)
09:41:17 <lambdabot>   3
09:41:20 * benmachine confuses self
09:41:27 <Twey> maurer_: P.S. modulus ≠ modulo
09:41:45 <monochrom> but I personally avoid negative divisors to begin with
09:41:51 <FunctorSalad_> does this hold for analogies in general? a:b :: c:d   <=>    a:c  ::  b:d
09:42:04 <monochrom> yes
09:42:08 <pumpkin> FunctorSalad_: yeah
09:42:19 <FunctorSalad_> :)
09:43:14 <FunctorSalad_> hmm, analogies are like division? :o
09:43:27 <tolkad> umm... how can I get ghc-core to install?
09:43:33 <tolkad> "pcre-light-0.4 failed during the configure step. The exception was: exit: ExitFailure 1"
09:44:02 <monochrom> analogy:colon :: division:slash = analogy:division :: colon:slash
09:44:06 <pumpkin> it probably has bindings to a native library you don't have
09:44:10 <pumpkin> or it can't find it
09:46:00 <FunctorSalad_> kinda looks like the exchange law for natural transformations too :o
09:46:09 <FunctorSalad_> *head splosion*
09:46:15 <EvanR-work> burritos
09:46:27 <maurer_> Is there a round-towards-zero division?
09:46:44 <EvanR-work> > (-5) `quot` 2
09:46:45 <lambdabot>   -2
09:46:48 <maurer_> So that -9 `otherdiv` 4 would yield -2?
09:47:18 <maurer_> Ah, my bad.
09:48:26 <monochrom> truncate (fromIntegral x / fromIntegral y)
09:49:06 <FunctorSalad_> hmm I guess it is less confusing if you use indices to show that the : and :: on the left hand side of the <=> aren't really the same as on the right hand side
09:49:10 <EvanR-work> > (-9) `quot` 4
09:49:11 <lambdabot>   -2
09:49:42 <FunctorSalad_> "if a is to b as c is to d, then a is to c (but in a different way than before) as b is to d"
09:50:44 <FunctorSalad_> *shuts up now*
09:51:56 <FunctorSalad_> hmm about the "shortcircuit" package, it seems like everything is shortcircuit already by default in haskell
09:54:12 <monochrom> all analogies are religiously automatically correct.
09:55:27 <c_wraith> ok, I hate glibc
09:55:41 <monochrom> people hate too much. hate is overrated.
09:56:21 <tolkad> so... would anyone mind testing whether putting an unpack pragma before a newtype will unbox the underlying type?
09:56:26 <zygoloid> > ((-9) `mod` (-4), -9 `mod` (-4)) -- maurer_: you were missing ()
09:56:27 <lambdabot>   (-1,3)
09:56:35 <tolkad> like newtype MyFloat = MyFloat Float; data T = T {-# UNPACK #-} !MyFloat
09:56:45 <tolkad> will T hold an unboxed float?
09:56:52 <c_wraith> What is the correct way to define _GNU_SOURCE in an .hsc file?
09:56:58 <zygoloid> hah, i go to lambdabot privmsg to make sure, get distracted, and when i come back i'm too late ;(
09:57:19 <tolkad> what does RMS have to say about haskell?
09:57:40 <c_wraith> tolkad, he liked it, but he had a few misunderstandings about what it is.
09:58:00 <c_wraith> But he hung out in here for a couple days while he was making up his mind about it
09:58:23 <c_wraith> err, no, I'm thinking esr.
09:58:24 <c_wraith> whoops
09:58:29 <c_wraith> too many initial people
10:00:58 <zygoloid> tolkad: go = T (MyFloat 0.1) translates into this core: go_rdD = T __float 0.1
10:03:03 <c_wraith> ok, so I need to define a macro on the command line for gcc, when invoked by hsc2hs
10:03:11 <c_wraith> How do I do that?
10:03:17 <c_wraith> from a .cabal file?
10:04:35 <benmachine> c_wraith: http://haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#buildinfo suggests that cc-options might be helpful
10:05:03 <benmachine> (see also the examples on that page)
10:05:45 <c_wraith> the documentation for that option is unclear whether it works with gcc as invoked by hsc2hs
10:07:14 <tolkad> zygoloid: uh I'm not sure what that means. is that unboxed?
10:07:37 <tolkad> zygoloid: thanks btw
10:07:44 <benmachine> c_wraith: so find out?
10:09:19 <c_wraith> hm.  it did pass the argument, but glibc is still lying to me about how to actually use this function.
10:10:12 <c_wraith> I wonder if anyone has ever successfully used this function.
10:11:31 <benmachine> c_wraith: which
10:11:38 <c_wraith> crypt_r
10:11:44 <c_wraith> the man page lies horribly
10:12:14 <benmachine> lies?
10:13:22 <c_wraith> It lies about what header file you need to include, and what macros you need to define to convince the header file to actually expose the function
10:13:40 <c_wraith> I still haven't figured out the latter, but I've tried everything it's suggested
10:15:35 <benmachine> c_wraith: try _GNU_SOURCE
10:15:41 <c_wraith> I did
10:15:43 <c_wraith> no help
10:16:02 <benmachine> with crypt.h?
10:16:32 <c_wraith> yes
10:16:47 <benmachine> oh
10:16:49 <c_wraith> And I've verified that GCC is being called with -D_GNU_SOURCE
10:17:03 <benmachine> just put the #define in the source?
10:17:39 <c_wraith> It's too late.  hsc2hs generates an include as its first line of output, and that include then pulls in a bunch of libc stuff
10:17:50 <benmachine> hmph
10:18:06 <c_wraith> Since those macros need to be defined before libc headers are included, it needs to be defined on the command line
10:19:35 <__yhvh__> ok, baby question time. I want to chart the output of a function which returns Ints, the charting lib wants doubles, what now
10:19:55 <c_wraith> __yhvh__, use fromIntegral
10:21:39 <__yhvh__> c_wraith: sweet
10:21:59 <benmachine> @quote you.want.a.Double
10:21:59 <lambdabot> No quotes match. Are you on drugs?
10:22:02 <benmachine> hmph
10:22:18 <benmachine> @quote you.want.Double
10:22:18 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
10:23:06 <__yhvh__> so this kind of type coersion is normal day to day haskell?
10:23:30 <c_wraith> It's explicit conversion, not coercion. :)
10:23:44 <c_wraith> And usually, you don't need to do it very much
10:23:55 <__yhvh__> ok
10:38:50 <tolkad> go = T (MyFloat 0.1) translates into this core: go_rdD = T __float 0.1
10:38:51 <tolkad> is the float unboxed?
10:39:21 <tolkad> I'm trying to figure out if unpack pragma goes through newtypes
10:41:40 <ezyang> I'm so terribly torn about cmdargs. On the one hand it's a nice API. On the other hand it totally butchers referential transparency. 
10:41:47 <benmachine> tolkad: according to the manual it does
10:41:54 <benmachine> ezyang: kill it with fire
10:41:56 <Lemmih> ezyang: I feel ya.
10:42:11 <ezyang> benmachine: What do you use, again/ 
10:42:13 <benmachine> tolkad: the type itself will be more informative than that
10:42:22 <benmachine> ezyang: uhm, for parsing command arguments?
10:42:33 <dolio> ezyang: Is that ndm's library?
10:42:36 <lispy> ezyang: yeah...there a similar library by mornfall, but I don't think the API is as nice.  His is like cmdlib, IIRC
10:42:39 <benmachine> ezyang:   if "--gen" `elem` args
10:42:49 <benmachine> <_<
10:42:53 <ezyang> dolio: Yes. 
10:42:55 <lispy> ezyang: but it only butchers it for the  verbose flag, right?
10:42:58 <Lemmih> ezyang: getopt isn't that bad, imo.
10:43:03 <ezyang> benmachine: Haha 
10:43:06 * lispy agrees with Lemmih
10:43:22 <ezyang> Ok, maybe I'll go look at that again. 
10:43:55 <ezyang> I'm writing another multi-modal cli tool *gasp* 
10:43:58 <Lemmih> I changed LHC to use getopt instead of cmdargs and the code feels a lot better even though it is a bit longer.
10:45:17 <zygoloid> tolkad: sorry for the delay. workstuff. yes, the Float# is on only one box (the T box).
10:45:37 <zygoloid> tolkad: (the Float is unpacked into the T box, and there is no MyFloat box because it's a newtype)
10:46:25 <tolkad> I was wondering if you could make unpacked type level vectors as in this package http://hackage.haskell.org/packages/archive/Vec/0.9.8/doc/html/Data-Vec-Base.html unpacked like this:
10:46:26 <tolkad> « data family a :. b :: *; data instance a :. () = VecEnd !a; newtype instance a :. b = (!a, {-# UNPACK #-} !b)»
10:46:35 <tolkad> using that principle
10:46:57 <tolkad> err wait
10:47:04 <quicksilver> Lemmih: what does cmdargs do which butchers r.t.?
10:47:11 <tolkad> « data family a :. b :: *; data instance a :. () = VecEnd !a; newtype instance a :. (b :. c) = (!a, {-# UNPACK #-} !(b :. c))»
10:47:12 <tolkad> heh
10:47:16 <zygoloid> tolkad: if you omit the {-# UNPACK #-}, you get: go_rdl = T (a_rjt `cast` (sym NTCo:MyFloat :: Float ~ MyFloat))
10:47:32 <Lemmih> quicksilver >>= ezyang 
10:48:19 <zygoloid> tolkad: where a_rjt = F# __float 0.1
10:48:45 <zygoloid> tolkad: so modulo casts, that's: T (F# __float 0.1), which has two boxes, a T and an F#
10:49:05 <tolkad> zygoloid: thanks
10:50:05 <ezyang> quicksilver: http://hackage.haskell.org/packages/archive/cmdargs/latest/doc/html/System-Console-CmdArgs-Implicit.html 
10:50:08 <ezyang> See the purity section. 
10:50:34 <tolkad> the instances would be an even bigger pain to write
10:50:46 <ezyang> Like, it's not a problem in /practice/ but it makes me go rehhhh 
10:52:59 <mornfall> lispy: cmdargs butchers referential for collecting annotations, actually
10:55:05 <mornfall> Right, cmdlib actually was a bid to get a very similar API without the unsafePerformIOs.
10:55:19 <mornfall> And use getopt in the backend at the same time.
10:55:34 <lispy> mornfall: Hmm...looking at the source of the link ezyang pasted I don't see the violation.  How does it violate it?
10:55:43 <ezyang> lispy: It's in submodules, I think. 
10:57:44 <lispy> mornfall, ezyang: oh, I see it now http://hackage.haskell.org/packages/archive/cmdargs/latest/doc/html/src/System-Console-CmdArgs-Annotate.html
10:58:22 <ezyang> maybe we should'a used TH 
10:58:43 <mornfall> cmdlib uses syb
11:00:13 <mornfall> And cmdlib annotations are compositional.
11:00:48 <EvanR-work> anti-haskell propaganda: the types get in the way, its too hard to satisfy the type checker, sometimes the hoops it makes you jump through seem arbitrary
11:01:19 <mornfall> EvanR-work: Same story with referential transparency.
11:01:25 <mornfall> It just keeps getting in your way.
11:01:26 <mornfall> : - )
11:01:49 <c_wraith> arghh.  my problem was...  C.  I forgot that structs aren't in the same namespace as anything else, without a typedef
11:02:03 <EvanR-work> struct foo;
11:02:30 <EvanR-work> struct mystruct_foo_struct;
11:02:31 <mornfall> c_wraith: Cool, uh? :)
11:02:59 <c_wraith> exciting, yes.
11:03:06 <ezyang> oh, other question: how do I do a password prompt from Haskell? 
11:03:08 <EvanR-work> typedef struct mystruct_foo_struct mystruct_foo_struct;
11:03:14 <ezyang> (what library does this for me) 
11:04:03 <EvanR-work> mornfall: anything else to add about my propaganda?
11:04:57 <mornfall> EvanR-work: Yeah. Never forget to mention that it sucks.
11:05:33 <EvanR-work> i usually disregard that one
11:06:38 <EvanR-work> how does referencital transparency get in the way?
11:06:42 <EvanR-work> referential
11:07:13 <dolio> EvanR-work: Haskell's syntax is too complex and confusing.
11:07:25 <dolio> Haskell is slow.
11:07:32 <lispy> Laziness is broken because it allows programs like ones = 1 : ones
11:07:35 <benmachine> it keeps making you declare all these "modular" and "re-entrant" things, what a pain in the ass
11:07:38 <dolio> Laziness makes programming too hard.
11:07:48 <lispy> Sections are confusing
11:07:58 <aristid> lispy: no they're not
11:08:04 <benmachine> are we going for specifically baseless criticism
11:08:10 <mornfall> aristid: That's not the right spirit.
11:08:12 <lispy> List comprehensions lead to incomprehensible code
11:08:26 <benmachine> lispy: I actually don't like list comprehensions >_>
11:08:26 <aristid> and what are monads good for anyways?
11:08:29 <lispy> n+k patterns are cool!
11:08:29 * ddarius rarely uses list comprehensions.
11:08:30 <benmachine> except in their simplest form
11:08:32 <EvanR-work> oh, so my thing about types getting in the way is baseless?
11:08:35 <aristid> mornfall: is that better spirit now?
11:08:39 <EvanR-work> im looking for real rebuttals
11:08:44 <mornfall> aristid: Indeed.
11:09:06 <benmachine> the things that I *actually* don't like about haskell are hmm
11:09:11 <lispy> (nevermind the obstacle of figuring out the semantics of subtract in n+k patterns!)
11:09:15 <benmachine> the record syntax is a bit weaksauce
11:09:28 <mornfall> Yeah, no first-class record update.
11:09:48 <mornfall> And type families don't work that well yet. (Hopefully fixed in future GHC.)
11:10:29 <lispy> benmachine: all instances are automatically imported is a weakspot, but the alternative seems a heavy weight
11:10:41 <benmachine> lispy: I don't think that's a weak spot as such
11:10:43 <dolio> EvanR-work: I don't know how to rebut that one, except to say that types don't get in the way anymore for me.
11:10:43 <ddarius> "I don't like that Haskell doesn't have features that few other languages have and that some of the features it has that exist in no other language aren't as complete as possible yet."
11:10:48 <benmachine> I think it's a controversial design decision, sure
11:10:55 <benmachine> ddarius: precisely.
11:11:22 <benmachine> types get in the way of you writing broken code, python lets you do that just fine
11:11:29 <dolio> Like, you can read the guy asking about heterogeneous lists on haskell-cafe, and all I can say is, I don't miss them. I never want them.
11:11:29 <EvanR-work> ^^
11:11:33 <EvanR-work> nice
11:12:38 <roconnor> @quote heterogeneous
11:12:38 <lambdabot> No quotes match. You untyped fool!
11:12:39 <EvanR-work> ive been trying to formalize some reason why hetero lists are so useless, and a heuristic for why everyone wants them
11:12:48 <dolio> GHC can cover some of his uses with existential wrappers, but I never need to write those, because the uses for them don't come up.
11:13:14 <roconnor> EvanR-work: people want them because they don't know about sum types, which essentially don't exist in C or Java.
11:13:39 <benmachine> I miss ADTs so much when I'm using other languages
11:13:56 <mornfall> EvanR-work: Because they are homophobics.
11:14:06 <olsner> one of the first things I did in haskell was "ok, Haskell, let's make a list of some stuff" and it didn't work because lists are homogenous :)
11:14:07 <EvanR-work> yeah i used to design languages for fun, now i cant because i realize it either wont have algebraic types or it will basically be haskell
11:14:10 <Philippa> I never want completely heterogenous lists, but I do sometimes want something that I'd encode in another language as a heterogenous list and a bit of testing or casting
11:14:35 <mornfall> We have existential types, anyway.
11:14:40 <Philippa> EvanR: don't worry, you'll get to a stage where you want to design things that aren't basically just haskell again, even if they're haskell-with-stuff
11:14:41 <EvanR-work> olsner: lets make a tuple of stuff instead ;)
11:14:47 <Philippa> yeah, but existentials alone aren't enough to be convenient
11:14:56 <mornfall> Good enough for heterogeneity as far as I am concerned.
11:15:06 <mornfall> Use a Typeable, Data constraint for real funk.
11:15:18 <Philippa> not if you've got a crowd of things where you're going to need to test specific properties, for example
11:15:30 <Philippa> especially if you don't want to have to keep a central repository of said properties
11:15:32 <tolkad> [(forall a. a)]
11:15:48 <EvanR-work> :t []
11:15:49 <lambdabot> forall a. [a]
11:15:49 <mornfall> tolkad: Not much useful stuff can be done with that, you know. ;“
11:16:05 <Philippa> (pick up an RPG or other tabletop game's rulebook and start encoding it complete with all the exceptions, you'll start to see the sorts of things I mean)
11:16:39 <roconnor> Philippa: I've tried doing that
11:16:41 <EvanR-work> gah i cant stand rule heavy rpgs ;)
11:16:47 <EvanR-work> they are business oriented
11:17:06 <Philippa> roconnor: gets awfully tedious if all you've got is algebraic datatypes, doesn't it? :-(
11:17:10 <mornfall> EvanR-work: Not enough slashing? :)
11:17:11 <benmachine> I tried writing a haskell chess program and found it painful
11:17:19 <alexbobP> EvanR-work: the only rules on my RPG are little arrows telling me which end the rocket comes out
11:17:24 <EvanR-work> lol
11:17:25 <benmachine> but I think that's just because chess is painful and writing in haskell makes you aware of that
11:17:31 <roconnor> Philippa: I did use a GADT at one point.  But that was partly cause I wanted  to try them out.
11:18:05 <EvanR-work> benmachine: good call, it annoys me when people refuse to believe what we are doing is non trivial and must be done carefully
11:18:05 <benmachine> you're like, I want to parse the command and then apply it to the board! but actually you need the board to parse the command
11:18:21 <roconnor> Philippa: I didn't get all that far.  I noted that you have to handel *all cases* not just the cases that come up in practice.
11:18:28 <roconnor> Philippa: I read rules that I didn't even know existed.
11:18:34 <benmachine> it makes you aware of all the horrible creepy bits of global variables and stuff that you'd normally sweep under the carpet
11:18:45 <roconnor> And some of the rules for handleing exceptional cases are kinda dumb
11:18:57 <Philippa> roconnor: *nod*. The best scheme I've got so far involves a record full of GADT stuff that's the central repository of predicates, and a phantom type variable on every entity
11:19:15 <Philippa> *nod*. Hi, I'm Games Workshop, I resolve rules conflicts with an argument between players and a D2!
11:19:35 <roconnor> Philippa: exactly!
11:19:52 <roconnor> Philippa: I hesistate to pipe MonadRandom into the middle of my nice code.
11:20:23 <aristid> the best random package is random-fu IMHO
11:21:03 <Philippa> *nod*. Even if you've got a saner ruleset (suppose you're doing something like Unreal Tournament), there's still a lot of of test-and-cast to do
11:21:26 <EvanR-work> test-and-cast?
11:21:26 <roconnor> aristid: is that an abstract interfrace to Randomness or an implementation of (pseuo)randomness
11:21:51 <aristid> roconnor: both, it includes a couple of randomness generators and a totally abstract interface
11:22:01 <roconnor> Philippa: sometimes I think I can prove some of these exceptional cases are impossible.
11:22:09 <aristid> the interface of random-fu is monadic too
11:22:13 <roconnor> aristid: I'll try to keep that in mind
11:22:36 <Philippa> EvanR: what happens when you have a rule that needs to be kept external to the original entity that says "behave like this for type X, like that for type Y and like the other for everything else"
11:22:51 <aristid> originally i based my own random-extras on MonadRandom... but then i found MonadRandom to be limited (it doesn't work together with mwc, for example), so i switched to random-fu
11:23:15 <EvanR-work> Philippa: type X and type Y are constructors for a 'master type' U ?
11:23:55 <EvanR-work> Entity -> U -> Rule
11:24:07 <Philippa> EvanR-work: I would strongly prefer to avoid having to have a central repository
11:24:11 <Philippa> which is what U is
11:24:25 <Philippa> if I have to, I would /far/ rather it's a repository of predicates about entities than one about entities
11:24:43 <mornfall> Philippa: Typeable?
11:24:49 <EvanR-work> Dynamic?
11:25:00 <Philippa> can you ask them about typeclass instances rather than about concrete types?
11:25:12 <mornfall> Tricky. :)
11:25:21 <mornfall> I guess not.
11:25:31 <EvanR-work> typeclass, throwing some complexity in there ;)
11:25:37 <Philippa> because the domain problem is to at least do something analogous to that
11:25:41 <roconnor> Philippa: a  central repository of predicates?
11:25:47 <roconnor> predicates over what?
11:26:02 <mornfall> You'd need to keep everything in its typeclass-existential for that to work with Typeable/Dynamic, I guess.
11:26:18 <mornfall> Which will break down for multi-class types.
11:26:24 <Philippa> roconnor: over entity types. Things like Damageable or Burnable or x `Hates` y
11:26:28 <Tarrasch> Hello! I'm interesting in using the emacs haskell mode, but I'm not interested in using emacs/vim. Is there any way to have "normal" key-bindings in emacs? (I'm to afraid asking this in #emacs of course :))
11:26:50 <mornfall> Tarrasch: You could try yi. :)
11:26:52 <Philippa> (I'd also, again, strongly prefer not to have to put all the instance info in that central repository...)
11:26:54 <roconnor> Philippa: hmm.  I didn't have anything like that.  But maybe I didn't get that far.
11:27:18 <mornfall> Philippa: You clearly want objects here. :)
11:27:22 <mornfall> OOHaskell? :)
11:27:23 <Philippa> roconnor: you end up needing predicates like that if you're going to get a straight-up domain-level description of things
11:27:34 <Philippa> mornfall: what I actually want is something smarter than most OO langs too, FWIW
11:27:46 <mornfall> Philippa: How come?
11:28:03 <Philippa> consider what happens for the multi-parameter predicate/MPTC-analogue case
11:28:15 <ddarius> Philippa: You clearly want a logic language ...
11:28:22 <mornfall> Philippa: Ok, then you maybe want CLOS. :P
11:28:24 <Philippa> and I might have to check a conjunction
11:28:29 <EvanR-work> screw clos
11:28:29 <Philippa> mornfall: nope, want static typing
11:28:31 <monochrom> emacs these days have "normal" key-bindings.
11:28:45 <mornfall> Philippa: There's no static typing in what you ask for above.
11:28:47 <tolkad> Philippa: interface Burnable {public void burn();}
11:29:27 <Philippa> mornfall: yeah, because I missed a detail - there are things you can only do to entities that meet certain predicates. Like, say, you can only damage the damageable
11:29:37 <Tarrasch> About using cabal (when using ubuntu); should i prepend cabal commands with 'sudo' (to act as root) or should I not?
11:29:44 <mornfall> Philippa: That's not static at all, though.
11:29:45 <monochrom> dependent predicate subtype
11:29:59 <mornfall> Philippa: Since you know zilch statically about something being or not being damageable.
11:30:01 <EvanR-work> mornfall: everything is static!
11:30:12 <Philippa> mornfall: it's perfectly statically typeable. The types force you to make all the appropriate checks
11:30:32 <monochrom> add sudo iff you want cabal to write to /usr/local/ etc
11:30:56 <monochrom> it is harmless to try without sudo first
11:31:11 <Philippa> ddarius: what I want definitely involves a logic fragment, yeah. But I'd be just as pissed off encoding the rest of it into one, and I've not looked at what the good statically-typed ones look like
11:31:23 <ddarius> mornfall: It is not hard to make a class IsDamageable that has a single method that returns a proof that something is in the Damageable type class.
11:31:47 <Saizan> Tarrasch: you need sudo only if you use --global, and it's better to use --root-cmd=sudo rather than calling cabal with sudo
11:32:02 <Philippa> ddarius: exactly. Take a big product of those and that's the 'central repository' I was talking about - you force everything in your entity collection to be an instance of it
11:32:16 <Tarrasch> Saizan, ah ok thanks
11:32:28 <ddarius> Philippa: I didn't suggest it to you.
11:32:48 <Tarrasch> Do anyone have yi installed? Is it still instalable via cabal? I can't seem to get it to install :-/
11:33:00 <Philippa> ddarius: I know :-) But the best typesafe encodings I've come up with are along those lines so far
11:33:09 <ddarius> Philippa: lambdaProlog is probably the best one out there that has a serious implementation, also some attributes of it would be helpful for what you want.
11:33:17 <mornfall> ddarius: As Philippa points out, that falls out with the requirements.
11:33:27 <mornfall> Philippa: And you contradict yourself. :)
11:33:30 <Tarrasch> hold the phone, seems to work now, I'm so confused :-/
11:33:32 <ddarius> Philippa: Mercury may also be something to look at, but I don't find it a very appealing language, but that's me.
11:33:49 <mornfall> Philippa: http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf -- if you don't mind Oleg, anyway.
11:33:52 <tolkad> you could also try VB
11:33:58 <Philippa> mornfall: if you can't meet the original problem spec, you have to decide where to compromise!
11:34:47 <ddarius> Philippa: Clearly the solution is to throw out this restrictive static typing.
11:35:02 <mornfall> Yeah. Go CLOS.
11:35:11 <Philippa> anyway, this is something you want 'on top of' an OO or OO-like-Reactive layer, which is one of the things that makes me wary about logic languages per se
11:35:19 <ddarius> Philippa: lambdaProlog like most Prologs allows you to add to predicates after the fact.
11:35:40 <conal> ddarius: even dynamically, via explicit implication
11:35:42 <ddarius> I really want a serious linear logic programming language.
11:35:46 <ddarius> conal: Yep.
11:36:36 <Philippa> ddarius: it's not "I can't write code for this problem in practice", it's just that so far, all the options suck in some way!
11:36:43 <Philippa> and it ought to be doable
11:37:02 <Philippa> I could definitely rig up something in Agda that'd do nicely if I spent long enough
11:37:05 <ddarius> Philippa: Welcome to the reality of modern programming.
11:37:11 <Philippa> no, really?!
11:37:36 <ddarius> conal: Your paper with Frank Pfenning is a great introduction to logic programming implementation, by the way.
11:37:46 <conal> ddarius: :)
11:37:51 <tolkad> Philippa: what was the problem with typeclasses as predicates?
11:37:54 <Philippa> just saying, Haskell's not got the solution for /everything/ yet, even without having to dig into realms that're typically left to dependently-typed langs
11:38:40 <Philippa> tolkad: you can rig up something that works with a fugly encoding, but you're forced to have a 'central repository' for predicates that might get used so you can have everything carry around their term-level equivalents to test/cast with
11:39:20 <Philippa> or to put it another way, Haskell doesn't do dynamic instance tests
11:39:35 <mornfall> Philippa: Given type erasure, it can't. :)
11:39:53 <mornfall> And no erasure = performance problem.
11:40:05 <Philippa> mornfall: you could do it on stuff in Typeable
11:40:12 <aristid> @hoogle a -> Bool
11:40:14 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
11:40:14 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
11:40:14 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
11:40:17 <mornfall> Philippa: That's still type-erased.
11:40:24 <mornfall> Philippa: Typeable is still static.
11:40:29 <aristid> isBottom <- oO
11:40:47 <tolkad> 0_o
11:40:49 <mornfall> Even Dynamic is pretty static. :)
11:40:51 <benmachine> aristid: yeah, it's unreliable and impure
11:40:51 <tolkad> that's useful
11:40:54 <Philippa> mornfall: no, conceptually you can put your typerep into a big LUT and that'd be sufficient
11:40:56 <ddarius> If you're clever enough with unsafeCoerce ...
11:41:04 <tolkad> benmachine: actually it's impossible
11:41:15 <aristid> tolkad: of course :)
11:41:20 <benmachine> aristid: it's not impossible to have that name, just impossible for it to be true :P
11:41:24 <Philippa> you'd get back the GADT equivalent of a Maybe with the instance in it
11:41:29 <benmachine> it tests for some kinds of bottom
11:41:29 <aristid> tolkad: no way it could catch an infinite loop without solving the halting problem
11:41:41 <aristid> benmachine: yeah
11:41:47 <benmachine> aristid: no, no way it could catch *every* infinite loop without...
11:41:59 <aristid> benmachine: uh yeah, sloppy wording sorry
11:42:19 <mornfall> aristid: Who says it doesn't solve the halting problem?
11:42:26 <mornfall> You are such a pessimist.
11:42:32 <benmachine> import GHC.Exts.Oracle
11:42:43 <mornfall> Yeah. Arithmetic hierarchy FTW.
11:42:56 <Philippa> mornfall: FWIW, I wouldn't want to have to actually implement that lookup across all classes!
11:43:25 <Philippa> it'd be a right bugger if you're running something like yi, for one
11:43:27 <mornfall> Philippa: Well, you can always code up dynamic dispatch.
11:43:46 <mornfall> But it probably won't be as typesafe as you'd like.
11:43:56 <mornfall> I.e. you'd end up with CLOS in Haskell. :)
11:44:24 <mornfall> You might still have typeclasses and all, but as soon as you need dynamic dispatch, you lose static safety. I.e. the calls may fail due to something not being the right instance.
11:44:25 <Philippa> mornfall: exactly. If I have to accept brokenness, I've got a choice between the central repository and losing typesafety. I know this. I wasn't actually asking for help, I'm just saying that I've got a non-crazy problem that haskell's type system can't solve yet
11:44:29 <mornfall> (The failure does not have to be catastrophic.)
11:45:02 <mornfall> Philippa: I sort of don't think it's haskell's type system. I suspect that there aren't decidable type systems that can solve it. :)
11:45:06 <Philippa> and which, incidentally, it'd be at least somewhat beneficial to at least one industry to be able to solve. In a "solve this and add STM or similar and you can probably sell it"
11:45:17 <FunctorSalad_> what is this central repository?
11:45:25 <roconnor> Philippa: too bad it is hard to describe over IRC.  I'd love to learn more, esp since I never encountered this (perhaps because my project didn't get very far).
11:45:31 <Philippa> FunctorSalad_: depends on your encoding
11:45:41 <tolkad> I don't want to hear about your "halting problem" give me solutions not problems
11:45:50 * mornfall gives tolkad a halting solution.
11:46:05 <FunctorSalad_> (maybe I should ask what exactly the problem is)
11:46:09 <Philippa> mornfall: I could probably build a type system to handle it fine. It just needs some very different basic assumptions to Haskell's - it won't be a conventional FPL in that regard
11:46:28 <aristid> FunctorSalad_: what the solution is. no problems allowed here, sez tolkad
11:46:29 <tolkad> when programmers tell you something is impossible, they are just being lazy
11:46:50 <mornfall> tolkad: Do they teach that in management courses? :)
11:47:08 <FunctorSalad_> together with a crackpot disproof of the halting theorem? ;)
11:47:14 <Philippa> FunctorSalad_: ever toy with QuakeC or UnrealScript? The casting problems you get in those due to game rules like "shamblers take half damage" or more simply "if something is damageable, damage it", done in a typesafe manner and preferably without a central repository where you have to declare all the predicates that might get checked to cast on
11:47:25 <Tarrasch> Is there any good cabal tutorial available? I seem to screw up all the time when I use cabal intall
11:48:04 <FunctorSalad_> Philippa: "no" on the QuakeC or UnrealScript :) (but at least I now know that you aren't talking about damaging windows)
11:48:06 <mornfall> Philippa: I still don't see how you can statically know that some object is damageable if you don't know anything about the object a-priori (since you don't have it in your nonexistent central repo).
11:48:11 <Philippa> roconnor: to be fair, the thing that /really/ makes you need it is a combination of having to scale big and having to deal with game designers who don't want to have to describe their conceptually non-crazy domain in terms of your coding environment
11:48:18 <Lemmih> Tarrasch: How do you screw it up?
11:48:19 <Philippa> mornfall: you statically know whether you've checked
11:48:37 <Philippa> mornfall: that's all it has to do, make you do all the checks
11:48:38 <mornfall> I see. Does that actually buy you anything? :)
11:48:46 <Philippa> yes. It buys you not forgetting to check
11:48:53 <Tarrasch> Lemmih, Every time I try to install something, there is always something sub-package who won't install
11:48:56 <mornfall> You can make the failures idempotent.
11:49:01 <Tarrasch> some sub-package*
11:49:02 <mornfall> Wouldn't that be enough?
11:49:19 <mornfall> foo -> bar: take damage
11:49:24 <EvanR-work> dynamic typing and dynamic dispatch talk is hurting my feelings
11:49:27 <mornfall> bar (mumbling): i don't take damage...
11:49:41 <Lemmih> Tarrasch: That's an issue with the package, not cabal-install.
11:49:46 <Philippa> nope. Next thing you know, you've accidentally made something take double damage for something it's not vulnerable to
11:50:00 <Philippa> (yes, that requires a type declaration somewhere, but even so)
11:50:23 <Lemmih> Tarrasch: Look at the error message and act accordingly.
11:50:26 <Tarrasch> Lemmih, ok, with the sub-package or the original?
11:50:33 <Philippa> also, it's a problem if you're checking more than one predicate and you need the whole action to be a nop if one of them fails
11:50:59 <Lemmih> Tarrasch: With the package that fails to install.
11:51:08 <mornfall> I see. :)
11:51:21 <FunctorSalad_> Philippa: hmm and a typeclass or explicit dictionary 'DamageableD' is what isn't typesafe enough?
11:51:28 <Tarrasch> Lemmih, I must flame on cabal for this error message:
11:51:33 <Tarrasch> terminfo-0.3.1.3 failed during the configure step. The exception was:
11:51:33 <Tarrasch> ExitFailure 1
11:51:36 <Philippa> FunctorSalad_: the problem is you've got to check if the sodding thing exists first
11:51:36 <FunctorSalad_> (taking half damage should be represented in the types?)
11:51:37 <Lemmih> Tarrasch: cabal install tries to install everything it can so the error message may not be at the bottom.
11:51:48 <mornfall> FunctorSalad_: It's too centralised. Can't add new predicates without modifying the "engine".
11:52:07 <Philippa> in the middle of a significantly-heterogenous (you can write down a type subsuming all entities, but it shouldn't be an algebraic datatype) environment
11:52:17 <Lemmih> Tarrasch: That's not the error message. Cabal-install is being somewhat silly here. The error message is above that.
11:52:48 <Tarrasch> Lemmih, ah thanks
11:52:48 <Philippa> and you want the code to grow linearly with the size of the game designer's 'native' description
11:53:09 <Philippa> so eg you must /not/ have blow-ups when you have to check multiple predicates
11:53:41 <Philippa> to put it another way, you should be able to show the code to the guy who came up with the rules in the first place without getting too much WTF :-)
11:53:58 <FunctorSalad_> seems like I know too little about the context to see why you might try to damage some thunk ;) that may or may not be damageable
11:54:35 <Philippa> FunctorSalad_: it's a game. A rocket just hit an entity, is now exploding and needs to damage both the thing it hit and everything in its blast radius...
11:54:51 <Philippa> except "everything in its blast radius" doesn't quite mean that :-)
11:55:02 <Tarrasch> Having difficulties with cabal, to get me started, what would you suggest as a cure against these error messages? http://pastebin.com/91dr3hnb
11:55:11 <FunctorSalad_> hmm sounds like it'd be efficient to have a space-indexed data structure that holds only damageable things
11:55:12 <Philippa> because, y'know, that thing over there's not damageable, and that other thing over there is technically damageable but currently doesn't take any damage, and...
11:55:13 <mornfall> Philippa: That's so far the best description of your problem, actually. :))
11:55:15 <solidsnack> Philippa: So why do you get casting problems from rules like "Shamblers take half damage."?
11:55:19 <FunctorSalad_> (no predicate)
11:55:24 <Lemmih> Tarrasch: Install libcurses-dev.
11:55:50 <Philippa> solidsnack: I left something implicit by accident. Shamblers take half damage /from rockets/
11:56:03 <solidsnack> Philippa: Still, why is there casting?
11:56:08 <Tarrasch> Lemmih, only have libcurses-ocamel-dev , or do you mean from cabal?
11:56:13 <EvanR-work> Philippa: great so everything is an instance of RocketDamage
11:56:14 <solidsnack> I don't understand how that would look.
11:56:17 <Philippa> to check "is this thing a shambler?"/"is this thing a rocket?"...
11:56:26 <EvanR-work> which in some cases has no effect
11:56:27 <Philippa> EvanR-work: is exactly the wrong solution
11:56:36 <solidsnack> Philippa: There is a cast there?
11:56:38 <EvanR-work> the alternative is dynamic typing
11:56:39 <monochrom> "curses headers could not be found" => apt-get install libncurses5-dev
11:56:39 <Philippa> you just introduced a global transformation for a local rule
11:56:40 <Lemmih> Tarrasch: It might be called something else. Look for *curses*dev.
11:56:49 <EvanR-work> how is it a local rule
11:57:00 <EvanR-work> when did rules have namespaces
11:57:02 <Philippa> solidsnack: using the term a little loosely. You'd use a cast or something close to it in C++ or Java
11:57:07 <mornfall> Philippa: I guess you really want a non-turing-powerful language for the rules. :)
11:57:09 <Philippa> but one that can fail
11:57:20 <mornfall> dynamic_cast, yah
11:57:29 <solidsnack> Like, you have a thing and you want to know if it's a Shambler so you cast it to a Shambler?
11:57:35 <Tarrasch> Lemmih, ah, you looked at the missing files, well I think I've learned something now. :)
11:57:41 <Philippa> EvanR: it applies to Shamblers and Rockets, not to 'everything'
11:57:51 <mornfall> if ( dynamic_cast< Shambler >( foo ) && dynamic_cast< Rocket >( bar ) ) { damage /= 2; }
11:57:52 <Philippa> and if 'everything' has to know about Shamblers and Rockets, you get code blowup
11:58:13 <EvanR-work> Philippa: yes
11:58:16 <Philippa> to the point where for some quite common styles of game, the codebase rapidly becomes unmaintainable
11:58:17 <EvanR-work> it does
11:58:18 <solidsnack> mornfall: Interesting. So a _dynamic_ cast.
11:58:24 <FunctorSalad_> how about giving everything a damage() method, which is a no op in some cases?
11:58:24 <solidsnack> Which can fail.
11:58:32 <EvanR-work> FunctorSalad_: just said that
11:58:36 <mornfall> FunctorSalad_: I suggested that about a screen and a half back. ;)
11:58:37 <FunctorSalad_> sorry :)
11:58:46 <FunctorSalad_> moving quickly, this channel is
11:58:51 <EvanR-work> Philippa: because you will be collecting everything in the blast radius, it does need to know about 'everything'
11:59:30 <EvanR-work> are you saying what i said will happen, just the code shouldnt look that way
11:59:31 * frerich3 wishes this IRC client would let him search the backlog so he could check whether anybody suggested to google for 'double dispatch' yet
11:59:41 <Philippa> EvanR: *sigh*. From my POV, you appear to be almost wilfully misinterpreting me. *It is imperative* that objects other than Rockets and Shamblers not need to know about how Rockets and Shamblers interact
11:59:41 <FunctorSalad_> but I find the problem hard to think about because I don't have any experience with the ways in which you want a game engine to be extensible
11:59:42 <EvanR-work> clos was suggested
11:59:44 <zygoloid> Philippa: sounds like you want a global list of rules which some engine optimizes into a sensible algorithm
11:59:51 <Philippa> zygoloid: no, I don't
11:59:54 <roconnor> what is clos?
11:59:59 <mornfall> Right, so you want isDamageable :: a -> Maybe (forall b. Damageable b => b.) Or so.
12:00:02 <FunctorSalad_> (for what things you may want an extra layer of indirection, and which should be directly represented in methods)
12:00:04 <Philippa> roconnor: the Common Lisp Object Scheme
12:00:07 <zygoloid> Philippa: why not?
12:00:10 <EvanR-work> Philippa: but then how does a rocket know not to do something to something thats not a shambler
12:00:19 <roconnor> Philippa: I know each of those words ...
12:00:22 <EvanR-work> it at least needs to be able to find shamblers from a group of everything
12:00:28 <Philippa> EvanR: by asking if it's a shambler, which is a much more general concept
12:00:49 <Philippa> (alternatively, the shambler asks if the thing damaging it's a rocket)
12:00:50 <EvanR-work> isShamber im guessing is also not an option
12:01:06 <Philippa> isShambler is fine, but I don't want to have to make everything else explicitly an instance of it
12:01:16 <roconnor> this is making me want to resume working on my implemenation
12:01:18 <solidsnack> roconnor: It's a tool for extensible definitions of object systems.
12:01:24 <Philippa> I've already said, Haskell sucks at this problem
12:01:26 <EvanR-work> right so everything is not a shambler but a shambler
12:01:32 <Philippa> so do most languages
12:01:34 <FunctorSalad_> make a DamageRule record that holds both the damagor and the damagee?
12:01:40 <FunctorSalad_> :)
12:01:55 <FunctorSalad_> these would be stored in a central repo, I guess
12:01:56 <zygoloid> FunctorSalad_: Philippa just said no to that, and i don't know why...
12:02:11 <mauke> probably because of the central repo
12:02:27 <zygoloid> nothing in that description says it has to be a list written in one place in the code
12:02:30 <Philippa> well for one, I don't want to have to manually translate the entire game's rules into 3NF just to write them down :-)
12:02:41 <solidsnack> This is an interesting discussion.
12:02:41 <zygoloid> you can build the central repo at runtime in any way you like
12:02:45 <EvanR-work> if were going to write abstract rules about things, then to make it work it seems like rules and things will be need to be clearly defined
12:03:02 <EvanR-work> sounds like Philippa wants to not clearly define them because it would be considered either global or central or both
12:03:02 <Tarrasch> Lemmih, thanks, I feel much more comfortable using cabal now! :)
12:03:09 <mornfall> EvanR-work: Well, if you turn rules into data, there's nothing too hard about this.
12:03:10 <Philippa> zygoloid: okay, fair enough, we have a miscommunication. Yes, at run-time there needs to be a central mechanism. It's absolutely required that said central mechanism not all be fully defined in one location though
12:03:16 <mornfall> EvanR-work: I guess the problem is that the rules want to be turing-complete.
12:03:27 <monochrom> when CLOS was mentioned, it already subsumed double dispatch. you need a semantic search of irc log, i.e., suppose "x>10" was mentioned, and you search "has x>2 been mentioned", the answer is "yes".
12:03:27 <EvanR-work> the problem is that you dont want to define what a thing is
12:03:36 <EvanR-work> because it would be global and central
12:03:36 <FunctorSalad_> hmm I thought it'd be a good thing to have all the damage rules in one place
12:03:49 <Philippa> EvanR: the problem is that I want the definition of what a thing is to be collected from all the definitions of things
12:03:51 <FunctorSalad_> disentangled from non-game-mechanics-specific control or data stuff
12:03:58 <zygoloid> Philippa: ok, that sounds fair to me. i don't like that haskell lacks any "run this code at startup" functionality -- that sort of thing is very nice for these problems
12:04:07 <mornfall> monochrom: Yeah, I mentioned CLOS because it does everything that was wanted. With the exception of static type safety. :)
12:04:55 <Philippa> FunctorSalad_: nope, the game designer thinks of the damage rule as a property of one or both of the entities involved, not as a property of damage
12:04:57 <mornfall> FunctorSalad_: Well, I guess the use case is that you have rule books.
12:05:06 <solidsnack> zygoloid: However, once you have worked with Ruby modules that try to connect to a database when you load them into your interpreter to inspect some of their definitions, you will be glad for the absence of this functionality :)
12:05:07 <EvanR-work> i dont like that
12:05:07 <Lemmih> Tarrasch: Great, feel free to ask more questions if problems arise.
12:05:09 <mornfall> FunctorSalad_: You have some that are part of the game, and you can plug in some extra later.
12:05:11 <Philippa> FunctorSalad_: also, multiple such rules might apply to one pair of entities
12:05:15 <EvanR-work> the rule isnt associated with either of them
12:05:19 <zygoloid> in c++ you could write "DamageRule<Rocket, Shambler, HalfDamage> specialRule;" and slam that into any translation unit that can see Rocket and Shambler and you could get it working
12:05:23 <tolkad> you could use a type
12:05:26 <tolkad> family
12:05:28 <zygoloid> solidsnack: yeah, it's a solution with hefty disadvantages
12:05:30 <EvanR-work> its like saying addition is a method on the left addend object
12:05:39 <Philippa> mornfall: yeah, it's even more blatant a need if you support mods
12:06:08 <Philippa> zygoloid: give or take having to figure out how you're going to decide on rule precedence anyway, yeah
12:06:14 <tolkad> class Damagable a where
12:06:23 <Philippa> but that's something you very pointedly ask the game designer anyway
12:06:25 <monochrom> somehow I see much commonality between answering "has anything been mentioned that implies x>2" and answering "who is being damaged".
12:06:27 <zygoloid> Philippa: you mean 'undefined between translation units' isn't good enough? ;)
12:06:45 <EvanR-work> tolkad: not without a 'isInstanceOf' 
12:06:53 <tolkad> hmm
12:06:56 <Tarrasch> Just installed yi with cabal, appearntly succesfully, but just running "yi" in a terminal won't work. Any ideas?
12:06:59 <Philippa> monochrom: x?
12:07:04 <mornfall> isInstanceOf would probably solve it, yes...
12:07:10 <monochrom> x is a free variable
12:07:14 <Tarrasch> (Command not found)
12:07:24 <byorgey> Tarrasch: by default, cabal installs executables in .cabal/bin
12:07:27 <FunctorSalad_> "<zygoloid> FunctorSalad_: Philippa just said no to that, and i don't know why..." -- is this referring to: -- "*It is imperative* that objects other than Rockets and Shamblers not need to know about how Rockets and Shamblers interact"?
12:07:31 <tolkad> EvanR: if there were closed type families haskell could support a default instance
12:07:31 <zygoloid> Philippa: i think i'd write rules in separate files, and parse those files to build the rule repository at runtime
12:07:44 <byorgey> Tarrasch: you can either change that by editing .cabal/config, or add .cabal/bin to your $PATH
12:07:44 <monochrom> anyway I would just slap a SAT solver or a SMT solver on both
12:07:46 <mornfall> But can't even type that one, not to mention implementing it.
12:07:55 <mornfall> SMT's ugly.
12:08:02 <Philippa> zygoloid: well yeah, it seems that the solution's a DSL of some sort
12:08:09 <FunctorSalad_> (in that case I failed to read the "objects other than" part)
12:08:18 <mornfall> Philippa: Do you have a case for turing-complete rules?
12:08:25 <monochrom> if things are to be done at the type level, I would put a SMT solver in the type-checker.
12:08:28 <zygoloid> FunctorSalad_: that was referring to "use a central repository" (where Philippa and I had a miscommunication) -- /writing/ a central repo in the code literally is unacceptable
12:08:50 <Philippa> monochrom: we don't actually need to do that part. Assume you've got an OO or Reactive framework driving entity interactions still
12:08:57 * Tarrasch runs yi, thinks: I hope I didn't put all my time on this! :p
12:09:12 <Philippa> mornfall: don't know, don't want to get in the shit when it turns out I did ;-)
12:09:31 <monochrom> I don't like OO. or rather, I use "undecidable" predicate subtype to replace OO.
12:09:35 <Philippa> mornfall: 99% of rules're pretty simple
12:09:45 <FunctorSalad_> "<Philippa> FunctorSalad_: also, multiple such rules might apply to one pair of entities" <-- so DamageRule must be a monoid :D
12:09:54 <mornfall> Philippa: Well, YAGNI then. The rules that aren't can be handled out of band. :)
12:10:09 <Philippa> FunctorSalad_: there're probably multiple applicable monoids. For example, do we have 'base damage' and 'multiplier' involved?
12:10:28 <zygoloid> Philippa: once you have a rules DSL, you're back to the problem of globally registering the ones you're interested in. which of those two problems is more interesting to you?
12:10:50 <FunctorSalad_> hmm yes, I mean the monoid would implement the arbitrary choice of how multipliers etc. stack
12:10:57 <FunctorSalad_> (which you have anywhere at some location)
12:11:35 <zygoloid> it just struck me that the registration problem can probably be solved with some sufficiently-cunning TH magic
12:11:39 <Philippa> mornfall: IAGN the OO-or-Reactive framework, so presumably that's the out-of-band that you have in mind. I don't actually /need/ anything more than individual predicates checked and appropriate casts applied, so long as I can keep the appropriate number of qualifications around when I've encoded a conjunction
12:12:07 <Philippa> zygoloid: if global registration is done by running a makefile or something similar, that's fine
12:12:45 <Philippa> oh, one thing that does get nasty: your rules may well want to involve parametric polymorphism
12:13:02 <Philippa> you end up wanting that kinda bad if you're going to support some of the stuff that could hypothetically be done with something like UT's mutators
12:13:14 <Philippa> because someone's going to want to encode mix-ins
12:14:37 <zygoloid> polymorphism makes the runtime rule analysis a bit tricky...
12:14:40 <Philippa> AFAIK nobody's got a scripting language for games that tackles this level of stuff yet (BICBW, of course)
12:15:22 <Philippa> zygoloid: thankfully it ought to be erasable in practice, but even so
12:15:59 <sinelaw> any emacs +scion users around?
12:16:02 <sinelaw> or devs :)
12:16:36 <Raevel> \o
12:16:41 <Raevel> user extraordinaire
12:17:55 <Philippa> zygoloid: you'll get things like DoubleJumping<PlayerCharacter>, or DoubleJumping<HadokenThrowing<PlayerCharacter>>
12:18:00 <zygoloid> Philippa: if it's just (forall Damager d. d) or some specific type then i can imagine that being fairly straighforward. but more complex cases...
12:18:57 <zygoloid> do d <- damager; d' <- doubleJumping d; d'' <- hadokenThrowing d'; ...
12:19:20 * benmachine throws a >=> at zygoloid 
12:19:23 <zygoloid> ^^ i'm imagining building an ADT where you can statically analyze these restrictions and build efficient 'compute damage' functions from them
12:19:28 <benmachine> or a <=< more likely
12:19:37 <sinelaw> Raevel, you use emacs + scion?
12:19:41 <sinelaw> i can't get it to work properly
12:20:05 <zygoloid> benmachine: d <- hadokenThrowing =<< doubleJumping =<< damager :)
12:20:07 <sinelaw> zygoloid, for World Of Lambdas?
12:20:26 <benmachine> :)
12:20:37 <zygoloid> sinelaw: Crouching Type, Hidden Lambda
12:20:59 <Raevel> sinelaw: yeah i do
12:21:25 <sinelaw> Raevel, how do you get it to work? i try loading cabal project and it gives weird errors
12:21:33 <Raevel> i have a few issues with it as well... but it starts up okay
12:21:36 <EvanR-work> ↓↘→ + P
12:21:45 <sipa> loi
12:21:56 <monochrom> zygoloid++
12:22:13 <sinelaw> Raevel, "Scion Eval Async: The requested method is not supported"
12:22:28 <sinelaw> when i do C-c C-o (open cabal project)
12:22:46 <Raevel> okay ill check...
12:23:26 <Raevel> sinelaw: ah, yeah, i get that too
12:23:42 <sinelaw> Raevel, so how do you use scion? 
12:23:47 <sinelaw> what should i do
12:23:51 <Raevel> hmmm
12:23:57 <Raevel> been a while...
12:24:01 <Raevel> i think i use M-x scion-load
12:24:18 <sinelaw> then it asks "library" or "file"
12:24:53 <sinelaw> file seems to work
12:25:04 <Raevel> okay, yeah, i've had issues since i switched computers, i use load file now
12:26:03 <Raevel> sinelaw: are you running the hackage version or from the git repo?
12:26:13 <sinelaw> git i think
12:27:01 <Raevel> there were some updates a few days ago iirc, not sure what was changed.. i'm running some old version off the devel branch
12:27:05 <benmachine> :t id <=< id
12:27:06 <lambdabot> forall (m :: * -> *) c. (Monad m) => m (m c) -> m c
12:27:08 <benmachine> neat
12:27:15 <sinelaw> ah
12:27:35 <aristid> :t (<=<)
12:27:36 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
12:27:40 <Raevel> http://github.com/nominolo/scion/network
12:28:02 <Raevel> oh right... bos :-)
12:28:36 <bos> wut?
12:28:58 <Raevel> oh sorry, didn't mean to highlight you, just commented on your commits to scion
12:30:36 <sinelaw> i'm running the most up-to-date version already
12:32:00 <ajnsit> I just discovered the ST Monad and it seems like an imperative language buried inside Haskell!
12:32:19 <earthy> in a sense it is.
12:32:27 <ajnsit> but I'm not sure what the description "strict state threads" means
12:32:30 <roconnor> ajnsit: haskell is the best imperative language
12:32:58 <mauke> ajnsit: I'd just ignore that
12:33:02 <FunctorSalad_> hehe
12:33:07 <sipa> ajnsit: i think that's the best description for it :)
12:33:12 <FunctorSalad_> "strict" in the semantics sense I think
12:33:40 <FunctorSalad_> i.e. "f is strict" = "f undefined = undefined"
12:34:17 <EvanR-work> > let f (x:xs) = 4 in f undefined
12:34:18 <lambdabot>   *Exception: Prelude.undefined
12:34:27 <sipa> is undefined technically the same as bottom?
12:34:41 <EvanR-work> > let f x = 4 in f undefined
12:34:42 <lambdabot>   4
12:34:48 <c_wraith> undefined is a bottom, but it's not the only one
12:34:52 <EvanR-work> > let f undefined = undefined; f x = 4 in f undefined
12:34:53 <lambdabot>   *Exception: Prelude.undefined
12:34:54 <sipa> c_wraith: that's what i though :)
12:35:01 <FunctorSalad_> yeah, an infinite loop as the semantics _|_ too
12:35:03 <roconnor> c_wraith: there are other bottoms?
12:35:08 <ajnsit> so why is this monad strict
12:35:10 <FunctorSalad_> I really meant _|_, not undefined
12:35:11 <sipa> > error "blup"
12:35:12 <lambdabot>   *Exception: blup
12:35:18 <sipa> that's not undefined either :)
12:35:19 <ajnsit> I understand state threads in a way
12:35:21 <conal> > let f ~(x:xs) = 4 in f undefined
12:35:21 <lambdabot>   4
12:35:23 <ajnsit> but why strict
12:35:28 <FunctorSalad_> ajnsit: I think it's referring to the behaviour of writeSTRef etc
12:35:35 <EvanR-work> conal: ah
12:35:45 <conal> EvanR-work: yeah.  subtle.
12:35:53 <FunctorSalad_> (writeSTRef r _|_ = _|_)
12:35:58 <FunctorSalad_> (if that's even true)
12:36:21 <Raevel> sinelaw: okay :-/
12:36:23 <roconnor> FunctorSalad_: is that true?
12:36:34 <dolio> Doubtful.
12:36:34 <c_wraith> roconnor, "let x = x in x"
12:36:35 <Raevel> sinelaw: last time it worked properly was back on 6.10 iirc
12:36:44 <Raevel> for me... that is
12:36:45 <sinelaw> :(
12:36:52 <sinelaw> too bad, it looks like a nice thing
12:36:54 <conal> EvanR-work: i'm nearly done writing a blog post that contents with a few of these subtleties.
12:36:58 <sinelaw> it half-works here
12:37:00 <c_wraith> roconnor, that's operationally different from undefined, but both are denotationally bottom
12:37:01 <Raevel> it's friggin awesome
12:37:14 <roconnor> c_wraith: fair
12:37:22 <FunctorSalad_> dolio: hmm not? :(
12:37:36 <roconnor> c_wraith: fair.  I feel code shouldn't distiguish between those bottoms.
12:37:46 * roconnor glares at IO exceptions
12:37:51 <dolio> > writeSTRef undefined undefined `seq` ()
12:37:52 <lambdabot>   ()
12:38:03 <Raevel> sinelaw: submit a ticket perhaps?
12:38:16 <sipa> > writeSTRef undefined undefined
12:38:17 <lambdabot>   <<ST action>>
12:38:30 <sipa> > runST (writeSTRef undefined undefined) `seq` ()
12:38:31 <lambdabot>   *Exception: Prelude.undefined
12:38:43 <FunctorSalad_> ok what's strict about it then?
12:39:04 <c_wraith> runST.
12:39:12 <roconnor> > runST (newIORef 7 >>= \a -> writeSTRef a undefined) `seq` ()
12:39:13 <lambdabot>   Not in scope: `newIORef'
12:39:16 <c_wraith> the lazy variant wouldn't have exploded in that case
12:39:18 <roconnor> > runST (newSTRef 7 >>= \a -> writeSTRef a undefined) `seq` ()
12:39:19 <lambdabot>   ()
12:39:20 <FunctorSalad_> ah
12:39:25 <roconnor> ^^ not strict
12:39:38 <monochrom> "strict state thread": state means what you think. thread means in addition you can't transfer state from one "runST myprog" to another "runST prog2" --- they are in "two different threads". strict means "undefined >> return ()" is undefined. But there is Control.Monad.ST.Lazy! "undefined >> return ()" finishes normally there.
12:39:49 <FunctorSalad_> don't know what I was thinking :) apparently I implicitly assumed the runST
12:39:58 <roconnor> monochrom++
12:41:11 <roconnor> aww, grepping my code for ST.Lazy returns nothing.
12:41:12 <monochrom> of course "undefined" is boring. but consider "myprog = myprog >> ..."
12:41:16 <roconnor> I swear I've used it somewhere
12:41:57 <roconnor> monochrom: I love monadic code like that
12:42:25 <roconnor> check out my definition of unitInterval
12:42:28 <roconnor> unitInterval :: Set CReal
12:42:29 <roconnor> unitInterval = do
12:42:31 <roconnor>   x <- unitInterval
12:42:32 <roconnor>   doubleton (left x) (right x)
12:42:38 <FunctorSalad_> lol 'doubleton'
12:42:54 <dolio> > let m = newSTRef [] >>= \r -> let loop = loop >> modifySTRef r (1:) in loop >> readSTRef r in runST m
12:42:55 <lambdabot>   *Exception: stack overflow
12:43:02 <roconnor> left ~(CR p) = CR (\n -> if n==0 then 0 else p (n-1))
12:43:08 <roconnor> right ~(CR p) = CR (\n -> if n==0 then 0 else p (n-1) + 2^(n-1))
12:43:28 <FunctorSalad_> roconnor: your Set is a monad?
12:43:43 <roconnor> FunctorSalad_: import Data.Searchable
12:43:50 <roconnor> Martin's Set is a Monad
12:44:18 <roconnor> FunctorSalad_: Not Data.Set
12:44:29 <roconnor> Which is nice, cause Set ought to be a monad.
12:45:19 <dolio> FYI: that code doesn't work with STRef.Lazy.
12:45:25 <roconnor> anyhow left x is effectively x/2 and right x is effectively (x+1)/2
12:45:31 <roconnor> just written in a suitablly lazy way
12:46:11 <roconnor> oh awesome
12:46:17 <dolio> So you can't play the same tricks as State.Lazy.
12:46:17 <roconnor> icfp2009/ExtraBase.hs:import qualified Control.Monad.ST.Lazy as Lazy
12:46:40 <FunctorSalad_> so you're generating [0,1[
12:47:09 <FunctorSalad_> assuming it somehow conjures up a 'base base' of zero :o
12:47:13 <FunctorSalad_> *base case
12:47:25 <roconnor> FunctorSalad_: the intervals are implicitly closed
12:47:28 <EvanR-work> all your case
12:47:57 <roconnor> FunctorSalad_: there is no base case
12:48:00 <roconnor> <3 codata
12:49:15 <FunctorSalad_> roconnor: hmm
12:49:42 <roconnor> FunctorSalad_: the binary expansion of real numbers goes on forever.
12:49:49 <FunctorSalad_> (it'd probably help to know about the internals of CReal first)
12:50:09 <roconnor> FunctorSalad_: the left and right functions introduce a bit of information.
12:50:10 <siracusa> hlint-1.8 seems to be broken for GHC 6.10. The error is `src\Util.hs:21:7: Could not find module `GHC.IO.Handle''. Is there a way to fix this?
12:50:53 <FunctorSalad_> roconnor: is the thing inside the CR ctor a function that maps n to an 1/n-approximation (or 2^-n or whatever)?
12:51:10 <roconnor> yes
12:51:17 <roconnor> a 2^-n approximation
12:51:36 <roconnor> techinically an integer that when divided by 2^n gives a 2^-n approximation
12:51:47 <roconnor> +/- 1 on all those n's
12:51:58 <FunctorSalad_> ah, that makes more sense :)
12:52:06 <FunctorSalad_> wondered where the /2 for left comes in
12:52:11 <FunctorSalad_> so it's just the shift
12:52:15 <Nopik> newsham: are you there?
12:52:17 <roconnor> yep
12:53:35 <FunctorSalad_> roconnor: hmm but thinking inductively, you seem to be generating the set obtained by closing {0} under left and right
12:54:07 <FunctorSalad_> wondering where the implicit 0 comes from :) maybe the "if n==0 then 0"
12:55:05 <roconnor> I *think* it is more like closing {undefined} under left and right.
12:55:23 <roconnor> just cause I wrote the code doesn't mean I understand it :P
12:55:30 <FunctorSalad_> hehe
12:55:31 <roconnor> recursion is confusing
12:56:16 <roconnor> but I don't think that is right either
12:56:32 <FunctorSalad_> I do think it's the 'if n==0 then 0' that gets it going
12:56:39 <FunctorSalad_> as far as I understand it so far at least
12:56:42 <roconnor> it implies the points are going to be {undefined, right undefined, left undefined, right (right undefined), ...}
12:56:46 <EvanR-work> fix ("recursion is... "++)
12:56:50 <EvanR-work> > fix ("recursion is... "++)
12:56:51 <lambdabot>   "recursion is... recursion is... recursion is... recursion is... recursion ...
12:56:57 <FunctorSalad_> (ffs, there aren't any other number literals here ;) excluding the indices)
12:56:57 <sipa> @google recursion
12:56:58 <lambdabot> http://en.wikipedia.org/wiki/Recursion
12:56:58 <lambdabot> Title: Recursion - Wikipedia, the free encyclopedia
12:57:01 <sipa> bah
12:57:02 <roconnor> EvanR-work: now do the section the other way
12:57:16 <EvanR-work> > fix (++"..confusing")
12:57:20 <lambdabot>   mueval-core: Time limit exceeded
12:57:20 <roconnor> FunctorSalad_: but that isn't the result because undefined never appears in the set
12:57:58 <roconnor> FunctorSalad_: the resulting set is really {right (right (right ...), left (right (right ...), right (left (right (right ....))), left (left (right (right ....)), ....}
12:58:07 <FunctorSalad_> roconnor: I can see how you can get started by taking taking an undefined sequence of bits and rightshifting it, adding a 0 in front
12:58:13 <roconnor> where the .... goes on an *uncountable?!* number of times
12:58:40 <EvanR-work> if its uncountable how is it even getting anywhere
12:58:50 <roconnor> *where the (final ....) goes on an uncountable number of times*
12:58:56 <roconnor> EvanR-work: magic
12:58:58 <FunctorSalad_> EvanR-work: it's the costuff somehow
12:59:01 <FunctorSalad_> ;)
12:59:28 <roconnor> EvanR-work: as long as you only ask for a finite amount of the uncountable set, you are fine :D
12:59:38 <FunctorSalad_> (related to how you can't actually consume infinitely many bits of a result, I think)
13:00:04 <monochrom> Hrm, so ST.Lazy is still a bit stricter than I would like. I now wonder what to do with it.
13:00:15 <EvanR-work> so it can only show you maximum countable steps
13:00:18 <roconnor> EvanR-work: more specifically you can only use some finite prefix of each real number in that uncountable set, and there are only a finite number of such prefixes of a given depth
13:00:55 <roconnor> monochrom: I used it in my icfp2009 virtual machine ... for some reason I don't remember.
13:01:28 <dolio> monochrom: m = m >> return () works, but that's useless.
13:01:36 <roconnor> monochrom: but I think I must have only used it's operational properties, not it's denotational properties.
13:01:42 <roconnor> so it isn't that interesting
13:02:17 <dolio> I suspect that sort of thing will only work if the result doesn't depend on any of the side effects in the recursive call.
13:02:50 <dolio> Or, that is, doesn't involve reading from the mutable store.
13:03:08 <dolio> But that isn't really very interesting.
13:03:40 <roconnor> dolio: conditionally depending on the mutable store?
13:05:16 <alexsuraci> if I have a function (hint's interpret, in this case) that returns "Typeable a => a", how can I convert that into a Dynamic? (toDyn doesn't typecheck: "Ambiguous type variable `a' in the constraint: `Typeable a' [...]")
13:06:25 <sipa> what else do you do with the return of that function?
13:06:28 <sipa> *result
13:06:40 <kmc> alexsuraci, i don't think you can directly
13:06:49 <benmachine> alexsuraci: you still need a concrete type, even if all you want to do is put it in a Dynamic
13:06:51 <kmc> Dynamic is like ∃a. (Typeable a) => a
13:06:57 <alexsuraci> it'll just be used as a Dynamic (it's part of my language)
13:07:01 <FunctorSalad_> alexsuraci: there are many possible intermediate types 'a' for going AnyTypeable -> a -> Dynamic
13:07:02 <kmc> i would push the toDyn into hint
13:07:07 <FunctorSalad_> err sorry, bad notation
13:07:09 <sipa> alexsuraci: still it needs to be some type at runtime
13:07:16 <FunctorSalad_> AnyTypeable -> a, and then a -> Dynamic
13:07:20 <alexsuraci> hrm
13:07:28 <benmachine> (in fact, arguably especially if you want to put it in a Dynamic, since a Dynamic probably stores the TypeRep of the contained thing in itself)
13:07:31 <kmc> but iterpret doesn't return AnyTypeable
13:07:35 <FunctorSalad_> (where by AnyTypeable I mean the existential kmc just wrote)
13:07:38 <sipa> benmachine: correct
13:07:47 <alexsuraci> kmc: right, it uses a witness
13:07:51 <kmc> it returns a value of a particular type that you, the caller choose
13:07:57 <sipa> alexsuraci: if you just request any value from that function, and store it in a dynamic, something has to decide which type it is going to be
13:08:00 <FunctorSalad_> oh right
13:08:05 <kmc> so, push toDyn into the interpreted program
13:08:09 <FunctorSalad_> AllTypeable then :)
13:08:24 <alexsuraci> kmc: was hoping it wouldn't come to that. oh well. ;)
13:08:40 <alexsuraci> thanks!
13:08:45 <kmc> > toDyn (toDyn 3)
13:08:46 <lambdabot>   <<Dynamic>>
13:08:52 <alexsuraci> how meta
13:08:53 <kmc> > toDyn (toDyn (toDyn 3))
13:08:54 <lambdabot>   <<Dynamic>>
13:08:58 <kmc> > fix toDyn
13:08:59 <lambdabot>   <<Dynamic>>
13:09:00 <FunctorSalad_> alexsuraci: hmm doesn't hint have an 'infer' function too?
13:09:13 <alexsuraci> FunctorSalad_: yeah, that's what I was using. doesn't help much though.
13:09:26 <benmachine> > fix typeOf
13:09:27 <lambdabot>   TypeRep
13:09:38 <FunctorSalad_> IIRC Dynamic is a pair of a (TypeRep,Any)?
13:09:40 <alexsuraci> just introduces ambiguity. it's just undefined with the Typeable constraint, exactly the same as `as'
13:09:44 <alexsuraci> FunctorSalad_: yep
13:09:57 <FunctorSalad_> maybe you can get the TypeRep from infer to make the Dynamic manually
13:10:56 <FunctorSalad_> hmm 'infer' doesn't quite seem to do what I thought it does :)
13:12:01 <FunctorSalad_> typeOf seems more like it, but it just returns a string, not a TypeRep
13:12:27 <benmachine> :t typeOf
13:12:28 <lambdabot> forall a. (Typeable a) => a -> TypeRep
13:12:44 <sinelaw> ugh
13:12:47 <sinelaw> writing convolution is a pain
13:12:52 <FunctorSalad_> benmachine: no, this one http://hackage.haskell.org/packages/archive/hint/latest/doc/html/Language-Haskell-Interpreter.html#7
13:13:09 <benmachine> k
13:13:21 <alexsuraci> > "1 + 1" eval-haskell
13:13:21 <alexsuraci> <haskell <<Integer>>>
13:13:22 <lambdabot>   Not in scope: `eval'Not in scope: `haskell'
13:13:23 <alexsuraci> hooray
13:13:27 <alexsuraci> er, sorry lambdabot
13:14:06 <FunctorSalad_> alexsuraci: seems like you could change hint's typeOf function and prevent it from stringifying the thing
13:14:17 <FunctorSalad_>        ty <- mayFail $ runGhc1 Compat.exprType expr
13:14:17 <FunctorSalad_>        --
13:14:17 <FunctorSalad_>        fromGhcRep ty
13:14:48 <djahandarie> I forget, where is Expr from again?
13:14:48 <FunctorSalad_> now I have no idea what type 'ty' has, but maybe you can convert it to a TypeRep
13:15:06 <djahandarie> :t x
13:15:07 <lambdabot> Expr
13:15:09 <roconnor> sinelaw:
13:15:10 <roconnor> polyMult [] b = []
13:15:12 <roconnor> polyMult a [] = []
13:15:13 <roconnor> polyMult a (b:bs) = z:polySum zs (polyMult a bs)
13:15:15 <roconnor>  where
13:15:16 <roconnor>   z:zs = map (*b) a
13:15:29 <sinelaw> roconnor, i'm doing it on Vectors
13:15:33 <roconnor> :(
13:15:42 <sinelaw> roconnor, is it worth doing it on vectors?
13:15:48 <roconnor> probably
13:15:50 <sinelaw> will i see better performance
13:15:56 <roconnor> hopefully
13:16:03 <FunctorSalad_> alexsuraci: hurr hurr I have an idea how to get the typerep from the string
13:16:17 <alexsuraci> uh oh
13:16:17 <medfly`> sinelaw, hi!
13:16:18 <roconnor> sinelaw: I was computing confidence intervals so laziness saves some work.
13:16:37 <FunctorSalad_> interpret ("Data.Typeable.typeOf (undefined :: "++typeName++")") :: m TypeRep
13:16:47 <alexsuraci> haha, oh man
13:16:57 <djahandarie> Ah right, simplereflect
13:17:03 <roconnor> sinelaw: once you compute the interval there is no need to complete the computation of the distribution
13:17:12 <alexsuraci> FunctorSalad_: just tossing toDyn in the expression to evaluate seems to be working well enough :P
13:17:25 <FunctorSalad_> ok ;)
13:17:48 <alexsuraci> oh nice, hint exports parens!
13:20:00 <newsham> Nopik: hi.
13:20:45 <sinelaw> roconnor, sorry but i don't understand what you're talking about
13:20:52 <sinelaw> what's a confidence interval?
13:20:56 <sinelaw> hey medfly` 
13:22:18 <FunctorSalad_> fwiw this seems to work though runInterpreter (setImports ["Prelude","Data.Typeable"]>>interpret "typeOf (undefined::String)" (undefined :: TypeRep))
13:22:39 <FunctorSalad_> where "String" could be replaced by the string you received from hint's typeOf
13:23:00 <djahandarie> Hm, it'd be nice if SimpleReflect knew nicer ways to reduce nums
13:23:35 <cathper> I admit that I do some rather heavy calculations on rather large lists, but when I run my program I get this:
13:23:38 <cathper> Main: internal error: evacuate: strange closure type 55528 (GHC version 6.10.4 for i386_apple_darwin) Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
13:23:38 <FunctorSalad_> hmm that String may represent a polymorphic type though
13:23:43 <ddarius> djahandarie: You can make NotSimpleReflect
13:23:53 <FunctorSalad_> heh
13:24:05 <cathper> Any idea what "strange closure type 55528" means?
13:24:15 <FunctorSalad_> HardReflect ("yes, it's called like this because it's hard to use")
13:24:15 <djahandarie> Actually
13:24:26 <djahandarie> What I want to do isn't even difficult
13:24:34 <djahandarie> It's just to assume that an expr is a number
13:24:39 <djahandarie> so b * 1 == b
13:24:40 <sinelaw> roconnor, i'm not used to thinking about conv. in polynomial terms. FT is my usual way of looking at it :\
13:24:41 <Nopik> newsham: i just wanted to say hi to you ;) several years ago i had few free days where i started to get basic haskell knowledge, was chatting here as well. i remember that someone gave me very nice example of haskell powerful type system.. i had logged it but lost the log in hdd damage.. now i'm returning to haskell and tried to remember that example i've seen long time ago.. fortunately there are some logs of #haskell available around, so i searched through t
13:24:41 <Nopik> which was hard, since i did not knew even which year it was.. but some wget+grep found it that it was on on 07.07.16 around 14:00, and it was you ;) nice to still see you there ;)
13:24:44 <djahandarie> And b + 0 == b
13:25:12 <sipa> Nopik: "so i search through t[...]"
13:25:17 <djahandarie> And b+b+b = 3*b
13:25:24 <djahandarie> > reduce $ b + 0
13:25:25 <lambdabot>   b + 0
13:25:30 <sipa> :t reduce
13:25:31 <lambdabot> Expr -> Expr
13:25:41 <djahandarie> > reduce $ 10 + 5
13:25:42 <FunctorSalad_> djahandarie: that's getting into term rewriting
13:25:42 <lambdabot>   15
13:25:56 <FunctorSalad_> maybe there are some haskell packages for that
13:26:00 <newsham> nopik: glad to be helpful.  how are your haskell journeys?
13:26:18 <EvanR-work> haskell non IO is already term rewriting!
13:26:26 <Nopik> sipa: hm, was my text cut? it is new irc client for me
13:26:33 <sipa> Nopik: yes
13:26:39 <sipa> which client are you using?
13:26:50 <Nopik> colloquy for macosx
13:27:03 <sipa> ah, colloqui - no idea how to prevent cutting long lines there
13:27:04 <Nopik> ... so i searched through them.. which was hard, since i did not knew even which year it was.. but some wget+grep found it that it was on on 07.07.16 around 14:00, and it was you  nice to still see you there 
13:27:19 <Nopik> this is the rest ;)
13:27:25 <EvanR-work> i already saw that
13:27:29 <sipa> Nopik: ok, we lost 4 bytes
13:27:44 <sipa> maybe 6
13:27:51 <Nopik> hm, ok
13:27:52 <EvanR-work> Just 6
13:27:59 <EvanR-work> AtLeast 6
13:28:02 <jedai> Nopik: we just lost "hem..", the rest made its way here though in two pieces
13:28:03 <sipa> :t maybe 6
13:28:04 <lambdabot> forall t a. (Num t) => (a -> t) -> Maybe a -> t
13:28:11 <EvanR-work> GiveOrTake 6
13:28:20 <Nopik> ok, i'll see it logs tomorrow ;D
13:28:47 <EvanR-work> the tubes ate 5 bytes
13:28:55 <sipa> the tubes are clogged!
13:29:10 <FunctorSalad_> djahandarie: make a maude binding for haskell :D
13:29:27 <FunctorSalad_> (free term rewriting application)
13:29:39 <Nopik> newsham: anyway, i was away from haskell for long time, but still was thinking about it.. recently i decided to try to code some program which i had in mind for long time as well, and decided that i can try to do it in haskell.. so i bought some book and now reading through it, trying to learn as much fp as possible ;p
13:29:52 <djahandarie> FunctorSalad_, http://hpaste.org/40576/term_rewriting This is what I want to look a little nicer ;)
13:30:03 <djahandarie> And ugh, hpaste doesn't wrap
13:30:43 <FunctorSalad_> well, one gets the idea ;)
13:31:08 <sipa> hmmm, i have some ad-hoc simplification rules for integer expressions in my code, but i'm not sure how much they'll do with that :)
13:31:16 * djahandarie is investigating maude
13:32:44 <FunctorSalad_> djahandarie: actually I think it has hardwired support for operations with neutral elements (such as +,0) so you don't even need a real rewriting rule ;)
13:33:15 <sipa> @hoogle maude
13:33:15 <lambdabot> No results found
13:36:22 <EvanR-work> "Thinking of Maud you forget everything else."
13:36:36 <sinelaw> how's Array performance?
13:37:10 <sinelaw> there are lists, Vectors, arrays, - what to choose? each library that i need uses a different one :(
13:37:13 <sinelaw> i'm stuck
13:37:43 <sinelaw> the main one uses Array
13:38:27 <EvanR-work> Arrays are great!
13:38:29 <newsham> nopik: sounds like the way to do it
13:38:42 <EvanR-work> if you dont want to update individual cells very often
13:38:53 <Cale> sinelaw: There are a lot of performance considerations to be made about choice of datastructure, as always. Lists are good mainly for sequential access. If you're familiar with imperative languages, think of lists as if they were loops.
13:39:23 <sinelaw> ok, what about vectors?
13:39:28 <Cale> Lists can also behave like stacks though, since operations on the front of a list are fast.
13:40:01 <erisco> without using a lambda function and without naming a new function, is it possible to write a function that takes two arguments, multiples the first by 2, and then returns their sum?
13:40:12 <EvanR-work> pl
13:40:15 <erisco> for some reason I wrote (+) (*2) (*1) and just thought it should work
13:40:34 <EvanR-work> @pl (\x y -> 2*x + y)
13:40:34 <lambdabot> (+) . (2 *)
13:40:35 <sipa>  If someone claims to have the perfect language he is either a fool or a salesman or both. --  Bjarne Stroustrup
13:40:45 <newsham> ?type liftM (+) (*2) (*1)
13:40:46 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
13:40:51 * erisco reminds that he cannot use lambda functions
13:40:53 <Cale> sinelaw: You're referring to the vector package (Data.Vector)?
13:40:55 <newsham> ?type liftM2 (+) (*2) (*1)
13:40:56 <lambdabot> forall a. (Num a) => a -> a
13:41:03 <EvanR-work> erisco: see the pl output
13:41:22 <sinelaw> Cale, yes
13:41:39 <erisco> EvanR-work: ah ha, that makes more sense... function composition
13:41:46 <erisco> EvanR-work: thanks
13:41:47 <Cale> Okay, that's a somewhat experimental new array library with lots of fusion.
13:41:56 <newsham> sipa: "ignorance is bliss" -thomas gray
13:42:15 <Cale> It's supposedly faster, but only allows for Int-indexed arrays
13:42:16 <sinelaw> Cale, I need the dsp package
13:42:19 <sinelaw> it's based on Array
13:43:04 <dons> Cale: the vector library?
13:43:12 <Cale> dons: yeah
13:43:21 <dons> significantly faster, yep. also, relatively stable now, imo. (in the top 20 packages on hackage)
13:43:27 <c_wraith> What would be an appropriate module name for a binding to glibc's crypt_r?
13:43:41 <benmachine> c_wraith: why would you *want* to bind to such a thing? :P
13:43:52 <c_wraith> benmachine, backwards compatibility, sadly.
13:43:54 <dons> nano-cryptr ? (if it is just a one-off binding)
13:44:04 <Nopik> newsham: yeah, we'll see.. the project is actually huge (more complex than writing compiler), so probably first approach will fail, since i'm haskell newbie.. but i'll see how much i'll go
13:44:05 <sipa> crypt-underscore-r-binding-for-haskell
13:44:15 <dons> or merge it into a general libc-crypt package
13:44:17 <c_wraith> not a package name, a module name
13:44:39 <ClaudiusMaximus> M
13:44:39 <benmachine> http://haskell.org/haskellwiki/Hierarchical_module_names good place for ideas
13:45:01 <benmachine> well, okay place for ideas
13:45:04 <benmachine> pretty patchy in places
13:45:21 <ClaudiusMaximus> there was that landscape list somewhere...
13:45:27 <c_wraith> Yeah, not seeing anything there that stands out as a good idea
13:45:36 <ClaudiusMaximus> http://gist.github.com/raw/463423/f8458d83b1a7cc26cdbf812747188993e50cd8a2/The%20Haskell%20module%20landscape
13:45:40 <sinelaw> dons, shame that a library like DSP might become unusable because it doesn't use Vector, and there's no way to change it from Array to Vector without rewriting it
13:45:47 <erisco> EvanR-work: that makes for quite a nifty one-line binary to decimal converter
13:46:00 <erisco> EvanR-work: foldl ((+) . (*2)) 0
13:46:10 <c_wraith> ClaudiusMaximus, that is *entirely* too much information to be useful. :)
13:46:24 <Cale> sinelaw: Arrays come in a bunch of flavours. There's boxed and unboxed, immutable and mutable. Boxedness has to do with how the elements of the array are stored. Boxed arrays are stored as bunches of pointers to elements (boxes), which permit lazy evaluation.
13:46:30 <Cale> (and more polymorphism)
13:46:57 <Cale> Unboxed arrays pack the elements in side by side, but this means that if any element of the array is evaluated, all of them must be.
13:47:00 <benmachine> boxed arrays can carry any normal type
13:47:09 <benmachine> unboxed arrays, only a few
13:47:14 <djahandarie> Have there been any interesting developments in supercompliation recently?
13:47:14 <Cale> and it means they can only fit certain types of data, yeah
13:47:41 <Cale> Unboxed arrays of Bool for example will be stored as large bitfields in memory
13:47:41 <EvanR-work> erisco: it doesnt convert from binary to decimal
13:47:56 <EvanR-work> it converts from a list of bits to an integer (not in any particular base)
13:48:06 <erisco> EvanR-work: I realize it is more general than that
13:48:08 <sinelaw> I see
13:48:27 <Cale> The difference between mutable and immutable should be fairly obvious, but there are boxed and unboxed versions of both.
13:49:41 <sipa> erisco: foldl ((+) . (*2) . fromEnum) 0
13:49:59 <Cale> The normal Data.Array.* package permits arrays which are indexed by a relatively arbitrary type (the requirement being that the type is an instance of the Ix class)
13:50:01 <sipa> > foldl ((+) . (*2) . fromEnum) 0 [1,0,1,0]
13:50:02 <lambdabot>   10
13:50:07 <erisco> sipa: I am using Miranda so the features available to me are less
13:50:22 <EvanR-work> miranda?!
13:50:28 <sipa> @hoogle miranda
13:50:28 <lambdabot> No results found
13:50:31 <Cale> For instance, this is convenient for 2-D arrays, since you can just index using pairs.
13:50:42 <sipa> what's Miranda?
13:50:47 <erisco> sipa: why is fromEnum needed in Haskell?
13:50:48 <sipa> or worse, who's Miranda?
13:50:52 <erisco> miranda is the predecessor of haskell
13:50:53 <EvanR-work> erisco: its not
13:51:06 <sipa> erisco: it's just one way of converting a boolean to an integer
13:51:15 <sipa> :t fromEnum
13:51:16 <lambdabot> forall a. (Enum a) => a -> Int
13:51:21 <erisco> ah, I see
13:51:31 * sipa picked that up a few days ago on this channel
13:51:34 <Philippa> erisco: well, /a/ predecessor
13:51:47 <sinelaw> Cale, how would you efficiently downsample an array?
13:51:59 <sinelaw> (keep only every n'th element)
13:52:02 <EvanR-work> erisco: do you have to pay for miranda?
13:52:23 <erisco> EvanR-work: no idea... I run the interactive shell on the school's servers
13:52:35 <erisco> we use it in our first year comp sci course
13:52:36 <sipa> sinelaw: work backwards and copy inside the array?
13:52:42 <EvanR-work> man, install ghc now ;)
13:52:53 <sinelaw> sipa, immutable
13:53:04 <gwern> is miranda even maintained anymore?
13:53:13 <erisco> haha, no gwern
13:53:13 <Cale> Well, all the array types have efficent "O(1)" random access. So I'd just define a new array with m `div` n elements whose elements were lookups into the old array
13:53:17 <ddarius> gwern: Possibly.
13:53:24 <gwern> ddarius: how very helpful
13:53:25 <sipa> sinelaw: depends, how do you represent arrays?
13:53:34 <Cale> The behaviour here would be quite different for boxed and unboxed arrays.
13:53:45 <ddarius> gwern: The last release was a few years ago, but the releases are a few years apart anyway so...
13:53:59 <gwern> sounds like nethack
13:54:01 <sinelaw> sipa, the same way the dsp package expects them :) trying to figure out what that is
13:54:08 <erisco> when you want to associate two lists you zip them... is there any builtin function to reduce a 2-tuple to a single value?
13:54:11 <gwern> (every release is a surprise that there was development going on)
13:54:15 <sinelaw> http://hackage.haskell.org/package/dsp-0.2.1
13:54:27 <Cale> With boxed arrays, what will happen is that the old array will stick around and lookups in the new boxed array will trigger a lookup into the old one, the first time, until all the elements are used (at which point the old array may become garbage)
13:54:29 <sipa> erisco: unzip?
13:54:30 <kmc> erisco, fst or snd?
13:54:32 <benmachine> there were twelve years between consecutive versions of haskell after all
13:54:39 <sinelaw> for example, Array Int (Complex b)
13:54:46 <Cale> With unboxed arrays, a single lookup into the new small array will force all the elements to be copied.
13:54:48 <erisco> unzip? darn, I guess miranda just doesn't have it :(
13:54:52 <benmachine> until not all that long ago, C had been more recently updated than haskell >_>
13:54:57 <gwern> on the other hand, with nethack it may well be dead now. 7 years is a long time between releases even for nethack
13:55:06 <sinelaw> Cale, i think they are boxed
13:55:11 <erisco> sipa: wait, wouldn't unzip return a list of the two original lists?
13:55:18 <EvanR-work> erisco: define it
13:55:21 <EvanR-work> @src unzip
13:55:21 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
13:55:23 <sipa> erisco: can you give an example of what you want?
13:55:24 <kmc> > unzip [(1,'a'),(2,'b')]
13:55:25 <lambdabot>   ([1,2],"ab")
13:55:39 <erisco> yeah, I figured... not what I want at all
13:55:50 <sipa> > fst (5,3)
13:55:51 <lambdabot>   5
13:56:16 <kmc> :t unzipWith
13:56:17 <lambdabot> Not in scope: `unzipWith'
13:56:18 <erisco> I want to take [(1, 1), (0, 2)] for example and reduce it to [1, 0] by multiplying the elements of the 2-tuples together
13:56:28 <erisco> and I am just curious if there is some sort of standard reduce function for it
13:56:41 <kmc> erisco, map (uncurry (*))
13:56:52 <kmc> > map (uncurry (*)) [(1,1), (0,2), (3,5)]
13:56:53 <lambdabot>   [1,0,15]
13:57:13 <erisco> @src uncurry
13:57:14 <lambdabot> uncurry f p = f (fst p) (snd p)
13:57:23 <kmc> :t (+)
13:57:24 <lambdabot> forall a. (Num a) => a -> a -> a
13:57:25 <kmc> :t uncurry (+)
13:57:26 <lambdabot> forall a. (Num a) => (a, a) -> a
13:57:29 <sinelaw> what in the world do ixmap do
13:57:29 <kmc> > uncurry (+) (2,3)
13:57:30 <lambdabot>   5
13:57:39 <benmachine> > uncurry (\x y -> ()) undefined
13:57:40 <djahandarie> Using uncurry and curry always feels weird to me for some reason
13:57:40 <lambdabot>   ()
13:57:42 <sipa> sinelaw: i think copying will be your only option
13:57:44 <erisco> I might be forgetting some terminology but why is that function called uncurry?
13:57:56 <sinelaw> sipa, probably
13:57:58 <gwern> because it is the inverse of currying
13:58:03 <kmc> erisco, because it converts a function from the "curried convention" to the "uncurried convention"
13:58:06 <Cale> sinelaw: Applies a function to each of the indices of the original array to construct a new one
13:58:08 <gwern> dual? opposote? whatever
13:58:09 <kmc> these being two conventions for multi-argument functions
13:58:10 <djahandarie> erisco, because it has to do with currying. :P A x A -> A curried is A -> A -> A
13:58:15 <FunctorSalad_> inverse
13:58:22 <sinelaw> :t ixmap
13:58:23 <lambdabot> forall i j e. (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
13:58:24 <Cale> sinelaw: having elements stolen from the original array
13:58:27 <sinelaw> Cale,  what's the first arg
13:58:33 <Cale> sinelaw: Actually, that's a perfect way to downsample
13:58:39 <sinelaw> Cale, i was suspecting that
13:58:41 <sipa> erisco: (*) takes two arguments, (uncurry (*)) takes a tuple containing the two arguments
13:58:45 <Cale> sinelaw: The bounds of the new array
13:58:45 <sipa> > (*) 3 5
13:58:46 <lambdabot>   15
13:58:50 <sinelaw> Cale, ah great
13:58:51 <erisco> @src curry
13:58:51 <lambdabot> curry f x y = f (x, y)
13:58:57 <sipa> > (uncurry (*)) (3,5)
13:58:58 <lambdabot>   15
13:58:59 <kmc> (*) takes a number x and returns a function which takes a number y and returns x*y
13:59:08 <kmc> uncurry (*) takes a tuple (x,y) and returns x*y
13:59:11 <ddarius> djahandarie: Currying happens to values.  f : AxA -> A curried has type A -> A -> A
13:59:27 <Cale> sinelaw: Actually, it's the other way, you apply a function to the indices of the new array to get which indices in the old one to use.
13:59:30 <sinelaw> Cale, isn't the type of the function reversed
13:59:31 <sinelaw> yeah
13:59:36 <sinelaw> ok
13:59:40 <FunctorSalad_> djahandarie: "feels weird" maybe because it's a rather long name for the in-hindsight trivial thing it does?
13:59:43 <sinelaw> so it's what i need
13:59:45 <djahandarie> ddarius, huh
13:59:52 <erisco> ah, I understand everything now
13:59:54 <sinelaw> ixmap (n/2, n/2) (\i -> i/2)
13:59:57 <sinelaw> Cale, ^^^
14:00:05 <FunctorSalad_> 'c' and 'uc' would be shorter.
14:00:09 <Cale> sinelaw: Probably (0,n `div` 2)
14:00:10 <djahandarie> FunctorSalad_, I guess
14:00:11 <erisco> curry/uncurry essentially allows you to specify function arguments by tuples
14:00:18 <erisco> gotcha
14:00:20 <sinelaw> Cale, oh right :#
14:00:36 <djahandarie> erisco, they are defined by tuples in all of math and most of programming
14:00:49 <kmc> erisco, they take you between "multiple args in tuples" and "multiple args by returning functions"
14:00:51 <Cale> sinelaw: There's a choice of lower bound as well -- the array library is agnostic about whether to be 0-indexed or 1-indexed (or 2-indexed ;)
14:00:52 <sinelaw> ixmap (0, n `div` 2)  (`div` 2)
14:00:53 <djahandarie> erisco, only in Haskell and some of its friends are they curried by default
14:01:00 <kmc> really, describing what uncurry and curry do in prose is useless;  just look at the types
14:01:01 <kmc> :t curry
14:01:02 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:01:03 <kmc> :t uncurry
14:01:04 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:01:08 <Cale> sinelaw: Probably (*2)
14:01:13 <ddarius> FunctorSalad_: It only seems trivial because it is built into the semantics so to speak.  At any rate, people rarely write curry/uncurry.
14:01:23 <sinelaw> Cale, right, new to old :)
14:01:28 <djahandarie> Extra parenthesis sometimes help for reading those functions
14:01:34 <sinelaw> downsample k = ixmap (0, n `div` k) (*k)
14:01:46 <sinelaw> where n = ....
14:01:57 <Cale> yeah
14:01:58 <kmc> Haskell functions are "curried by default" only in that the syntax and standard libraries encourage curried style
14:02:06 <sipa> map (\(x,y) -> x*y) [(1,1), (0,2), (3,5)] also works
14:02:11 * ddarius agrees with kmc.
14:02:21 <djahandarie> I suppose
14:02:26 <sipa> > map (\(x,y) -> x*y) [(1,1), (0,2), (3,5)]
14:02:27 <lambdabot>   [1,0,15]
14:02:33 <FunctorSalad_> ddarius: didn't mean to say that the general concept is trivial
14:02:42 <sipa> @pl \(x,y) -> x*y
14:02:42 <lambdabot> uncurry (*)
14:02:51 <sipa> @pl map (\(x,y) -> x*y)
14:02:52 <lambdabot> map (uncurry (*))
14:03:07 <Tarrasch> what does pl do?
14:03:17 <sipa> Tarrasch: compute pointless form
14:03:27 <FunctorSalad_> just that any particular application of 'curry' or 'uncurry' usually doesn't actually "do" anything regarding the problem at hand
14:03:46 <djahandarie> kmc, then again, couldn't that be said about... anything in the language?
14:03:47 <ddarius> FunctorSalad_: That's to be expected.
14:03:47 <Tarrasch> sipa, is it always doable, and can lambdabot always do it?
14:03:51 <monochrom> you can write curried functions in sml too. but you look at their libs and they are full of uncurried functions.
14:03:52 <FunctorSalad_> (it just adapts different conventions to each other)
14:03:54 <EvanR-work> Tarrasch: no variables
14:04:05 <wjtk> data NewTrie = NewTrie (Maybe (Array Int NewTrie)) Bool
14:04:10 <sinelaw> @pl (\x -> snd (f x) - fst (f x))
14:04:10 <lambdabot> ap ((-) . snd . f) (fst . f)
14:04:12 <sipa> and no list comprehensions
14:04:18 <sinelaw> :t on
14:04:19 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:04:27 <Tarrasch> @pl [1..0]
14:04:28 <lambdabot> [1..0]
14:04:36 <monochrom> however, there are two things in the language you can see, and they tell you a bias.
14:04:38 <Tarrasch> ah right, comprehensions you said..
14:04:39 <sipa> @pl \z -> [x+y | x <- [1..z] ]
14:04:40 <lambdabot> return . (x +) . ((y | x) <-) . enumFromTo 1
14:04:45 <ddarius> monochrom: Their ADTs
14:04:51 <sipa> @pl \z -> [x | x <- [1..z] ]
14:04:52 <lambdabot> return . ((x | x) <-) . enumFromTo 1
14:04:54 <djahandarie> Whoa
14:05:03 <sipa> @pl \z -> [x | (x <- [1..z]) ]
14:05:03 <lambdabot> return . (x |) . (x <-) . enumFromTo 1
14:05:10 <monochrom> and what happens to (+)
14:05:13 <Raevel> @type (<-)
14:05:13 <ddarius>  @pl doesn't understand list comprehensions.
14:05:13 <wjtk>   `Maybe' is not applied to enough type arguments
14:05:14 <lambdabot> parse error on input `<-'
14:05:15 <wjtk>     Expected kind `?', but `Maybe' has kind `* -> *'
14:05:18 <djahandarie> pl sure does some funky stuff with list comprehensions
14:05:19 <wjtk> I beg for some help
14:05:33 <sipa> wjtk: paste your code, hpaste.org ?
14:05:43 <monochrom> haskell (+) is curried, sml (+) is uncurried
14:05:44 <erisco> thanks for all the help guys
14:05:45 <wjtk> will do
14:05:55 <dolio> @. pl undo [ x +  y | x <- [1..z]]
14:05:55 <lambdabot> (y +) `fmap` [1..z]
14:06:11 <djahandarie> Heh
14:06:31 <djahandarie> Why were monad comprehensions removed again?
14:07:40 <Tarrasch> @pl 1:1: (zipWith (+) fibs $ tail fibs)
14:07:40 <lambdabot> 1 : 1 : zipWith (+) fibs (tail fibs)
14:07:42 <sinelaw> @pl (\x -> snd x - fst x)
14:07:42 <lambdabot> liftM2 (-) snd fst
14:07:50 <wjtk> pasted
14:07:54 <Tarrasch> ah, it's already pointless
14:07:55 <sipa> wjtk: url? :)
14:08:08 <wjtk> http://hpaste.org/40577/maybe_is_not_applied_to_eno
14:08:11 <Tarrasch> lol, pointless indeed :p
14:08:14 <djahandarie> Tarrasch, except the $
14:08:22 <sinelaw> @hoogle liftA2
14:08:22 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
14:08:25 <Cale> wjtk: Perhaps you wanted parens around (Maybe Bool)
14:08:31 <monochrom> (Maybe Bool)
14:08:50 <djahandarie> Tarrasch, but you probably meant @pl (\fibs -> ...)   didn't you?
14:08:52 <Tarrasch> djahandarie, you're right! $ counts as a "variable" in this sense I guess
14:08:53 <Cale> wjtk: It looks like Maybe and Bool are separate parameters to NewTrie there
14:08:59 <Shamar> hi, there a version of the "read" function that return a Maybe?
14:09:02 <sipa> wjtk: now NewTrie is given 3 arguments, of which the second is Maybe and the third is Bool
14:09:07 <monochrom> Everyone loves my Maybe, but my Maybe loves only me.
14:09:12 <sipa> wjtk: you probably only want to give it 2
14:09:15 <ddarius> Tarrasch: No, @pl just "optimizes" it away.
14:09:17 <djahandarie> Tarrasch, I was just kidding lol
14:09:18 <Cale> Shamar: Sadly not in the libraries, but it's easy to make one with reads
14:09:34 <Cale> > reads "abc" :: [(Integer, String)]
14:09:35 <lambdabot>   []
14:09:39 <Cale> > reads "123abc" :: [(Integer, String)]
14:09:40 <ddarius> @pl map f . map g
14:09:40 <lambdabot> map (f . g)
14:09:40 <lambdabot>   [(123,"abc")]
14:09:44 <Cale> > reads "123" :: [(Integer, String)]
14:09:45 <lambdabot>   [(123,"")]
14:09:56 <wjtk> sipa: it is not that simple, even without the second maybe it does not compile
14:09:58 <Cale> No element -> no parse
14:10:00 <Tarrasch> ddarius, oh, how does it know that?
14:10:06 <Tarrasch> ddarius, it's "smart"? 
14:10:19 <Tarrasch> @pl fmap f . fmap g
14:10:19 <lambdabot> fmap (f . g)
14:10:29 <Tarrasch> So it assumed the laws are right?
14:10:29 <ddarius> Tarrasch: There are rules built into it.  The whole thing is a mass of ad-hoc rules.
14:10:31 <cathper> Hmm, if I use 6.12.1 on a linux box, my problem disappears.
14:10:36 <sipa> wjtk: if it was just a single line, you could have copied it here; but the nice thing about hpaste is that you can give a lot more context
14:10:44 <Tarrasch> @pl fmap id
14:10:45 <lambdabot> id
14:10:47 <Tarrasch> cool
14:10:55 <monochrom> The smartest mind is just a bigger mass of ad-hoc rules.
14:10:58 <ddarius> @pl (+3)
14:10:58 <lambdabot> (3 +)
14:11:00 <Tarrasch> @pl f >=> return
14:11:00 <djahandarie> @pl curry . uncurry
14:11:00 <lambdabot> f >=> return
14:11:01 <lambdabot> id
14:11:13 <djahandarie> @pl sort . sort
14:11:13 <lambdabot> sort . sort
14:11:16 <wjtk> data NewTrie = NewTrie (Maybe (Array Int NewTrie))
14:11:19 <djahandarie> Aw
14:11:21 <Tarrasch> what an jackass it is :p
14:11:22 <sipa> wjtk: but does it still give an error with this: data NewTrie = NewTrie (Maybe (Array Int NewTrie)) (Maybe Bool)
14:11:38 <wjtk> compiler says `Maybe' is not applied to enough type arguments
14:11:40 <wjtk>     Expected kind `?', but `Maybe' has kind `* -> *'
14:11:45 <dolio> @pl uncurry . curry
14:11:46 <lambdabot> id
14:11:48 <dolio> Wrong.
14:11:53 <djahandarie> Heh
14:11:55 <Tarrasch> dolio, orly?
14:11:56 <sipa> wjtk: yes, you already said that
14:11:57 <djahandarie> Strictness
14:12:01 <ddarius> dolio: A lot of what was just produced was wrong.
14:12:15 <sipa> wjtk: but have you put parenthesis around Maybe Bool?
14:12:20 <ddarius> dolio: The switching of (+ 3) (or (* 3)) to (3 +) is rather wrong as well.
14:12:26 <sinelaw> @hoogle on
14:12:26 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:12:26 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
14:12:26 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
14:12:31 <Tarrasch> why is it wrong?
14:12:36 <dolio> Yeah. I don't really understand why it does that.
14:12:40 <Tarrasch> ddarius, why? + is commutative
14:12:42 <wjtk> even if I remove Maybe Bool the error is still the same
14:12:46 <ddarius> Tarrasch: No it isn't.
14:12:52 <Tarrasch> ddarius, counter-example?
14:12:59 <ddarius> > x + y
14:12:59 <lambdabot>   x + y
14:13:00 <monochrom> data NewTrie = NewTrie (Maybe (Array Int NewTrie)) (Maybe Bool)  works for me, no error.
14:13:02 <ddarius> > y + x
14:13:03 <lambdabot>   y + x
14:13:25 <Tarrasch> ddarius, that doesn't disprove commutativity
14:13:33 <sipa> wjtk: and that particular line is the one that the compiler complains about?
14:13:34 <sinelaw> ooh, discrete wavelet transform is a one liner!
14:13:35 <dolio> Yes, it does.
14:13:37 <ddarius> Yes it does.  You just don't realize it.
14:13:43 <Tarrasch> eh..
14:14:00 <Tarrasch> what subject should I read up on to realize it?
14:14:01 <dolio> In one case it resulted in something that printed as x + y, in the other y + x.
14:14:16 <sinelaw> dwt x = (,) `on` (downsample 2 . fast_conv x)
14:14:25 <sinelaw> :) :) :)
14:14:31 <sinelaw> \o/
14:14:45 <ddarius> Tarrasch: x and y are free variables, where are they bound and what are they bound to?
14:14:46 <wjtk> Ok, thanks... I am a moron
14:15:13 <sinelaw> gotta check that this beauty works though
14:15:19 <Tarrasch> But if you're proving commutativity wrong by example, you should show something going wrong by using the fact. I don't see anything has gone wrong. (like a+b != a+b)
14:15:26 <monochrom> define +
14:15:26 <Tarrasch> != b+a
14:15:37 <Shamar> thanks a lot Cale 
14:15:38 <sipa> depends what (+) you are considering
14:15:52 <djahandarie> Tarrasch, consider that (+) can be defined for more than just the real numbers
14:15:54 <ddarius> Tarrasch: You asked for a counter-example, I gave you a counter-example.
14:16:30 <monochrom> > x+y == y+x
14:16:30 <lambdabot>   False
14:16:35 <monochrom> THE END
14:16:36 <djahandarie> lol
14:16:38 <Tarrasch> lol
14:16:41 <sipa> one that builds an expression tree for example, is definitely not commutative
14:16:48 <Tarrasch> > x+y == x+y
14:16:49 <lambdabot>   True
14:16:51 <Tarrasch> damit :p
14:17:13 <djahandarie> Although
14:17:13 <Tarrasch> sipa, ok, but can you make that an instance of Num?
14:17:23 <djahandarie> There is the (Num a) restriction on (+)
14:17:26 <djahandarie> Which means its a field
14:17:34 <djahandarie> Which means it SHOULD be commutative
14:17:42 <benmachine> it's not a field
14:17:52 <benmachine> might be a ring, not sure if the docs demand it
14:17:53 <sipa> Tarrasch: i think that's actually what happened in lambdabot
14:17:57 <djahandarie> Oh
14:18:09 <monochrom> the docs demands are vague
14:18:37 <benmachine> the docs don't seem to demand anything
14:18:39 <djahandarie> Anyways
14:18:40 <sipa> there is no guarantee that any implementation of (+) is commutative
14:18:45 <benmachine> so we can't necessarily assume that (+) is commutative
14:18:48 <djahandarie> Isn't ring addition commutative?
14:18:49 <benmachine> in practice it tends to be
14:19:01 <benmachine> djahandarie: yes, but Num isn't required to be a ring
14:19:07 <benmachine> it doesn't seem to have any laws at all
14:19:15 <djahandarie> You can't enforce laws, so yeah
14:19:17 <benmachine> which is rather upsetting
14:19:19 <Tarrasch> ok, is it a law (like fmap id == id)
14:19:23 <Tarrasch> ?
14:19:24 <benmachine> djahandarie: sure you can
14:19:33 <benmachine> just not inside the language
14:19:45 * benmachine grabs a bat and looks up the address of pepole on hackage
14:20:10 <ddarius> The Report says exactly nothing about what laws instances of Num should satisfy.
14:20:37 <djahandarie> I don't think I would like anyone who would define a Num instance that isn't a ring
14:20:43 <monochrom> whereas the report states explicitly fmap id = id etc
14:20:44 * djahandarie looks around
14:20:47 <ddarius> djahandarie: Then you don't like Expr.
14:20:56 <monochrom> or rather, s/states/demands/
14:21:24 <djahandarie> ddarius, in that regard, sure ;)
14:22:02 <benmachine> ddarius: I would be interested in an Expr type that tried to preserve laws like that
14:22:14 * benmachine wonders what a free ring looks like
14:22:22 <sipa> benmachine: i think it is possible
14:22:31 <benmachine> sipa: I'm sure it is
14:22:35 <sipa> if you normalize expressions and define a total order
14:22:36 <benmachine> I don't know if it's still useful, mind
14:22:38 <monochrom> you could prove the binomial theorem with a type like that, you know
14:23:09 <sipa> you could rewrite a+b to b+a if a _>_ b
14:23:13 <monochrom> the flip side: a type like that would need instance code that can prove the binomial thoerem
14:23:14 <benmachine> you probably actually don't want identities, or indeed inverses, to exist with Expr
14:23:38 <djahandarie> You can get a ring from an abelian group I think
14:23:41 <benmachine> both are "forgetful"
14:24:54 <monochrom> I guess the binomial theorem is too easy.
14:25:15 <kmc> djahandarie, Double isn't a ring is it?
14:25:24 <benmachine> Double isn't an anything
14:25:34 <benmachine> apart from a mess, perhaps
14:25:49 <monochrom> at corner cases Double + is not associative
14:26:00 <monochrom> you can say "Double + ungood" now. :)
14:26:04 <benmachine> :D
14:26:13 * benmachine hugs monochrom 
14:26:47 <monochrom> this proves that Orwell foresaw a future world where everyone used Haskell
14:26:52 <sinelaw> ...so maybe my one-liner dwt is wrong
14:26:58 <djahandarie> kmc, oh, that's true
14:27:47 <Tarrasch> http://hpaste.org/40578/not_commutative?pid=40578&lang_40578=Haskell
14:28:08 <Tarrasch> Felt weird that I neeeded (Eq a, Show a) constraint though
14:28:14 <monochrom> too many 40578
14:28:19 <kmc> Tarrasch, hlint has some good suggestions there
14:28:29 <Tarrasch> kmc, Yea, I actually learned from tht
14:28:42 <kmc> Tarrasch, you need that because Num has Eq and Show as superclasses
14:28:42 <Tarrasch> Don't know how to change though
14:28:51 <sinelaw> it's almost midnight and my neighbor is renovating
14:28:53 <sinelaw> :(
14:28:59 <kmc> and no, Num probably *shouldn't* have those subclasses
14:29:01 <medfly`> call the police?
14:29:02 <kmc> Tarrasch, don't know how to change what?
14:29:07 <sinelaw> medfly`, he's also my landlord
14:29:10 <medfly`> oh
14:29:11 <kmc> talk to him nicely?
14:29:18 <kmc> Tarrasch, i also recommend putting type signatures on all top-level bindings
14:29:19 <medfly`> sinelaw, earplugs?
14:29:20 <sinelaw> it's not actually him , it's his workers
14:29:20 <Tarrasch> kmc, change the uploaded paste
14:29:22 <monochrom> call the police anonymously
14:29:24 <kmc> oh
14:29:31 <sipa> Tarrasch: just do what it says
14:29:33 <sinelaw> i think
14:29:34 <sipa> Tarrasch: remove the do
14:29:36 <sinelaw> maybe it is him :)
14:29:50 <sinelaw> nvm, nothing a bowl of sunflower seeds can't solve!
14:29:57 <sinelaw> + raisins
14:29:58 <sipa> Tarrasch: and turn "putStrLn . show" into "print"
14:30:02 <Tarrasch> sipa, I know that's a very good idea
14:30:09 <monochrom> + sleep pills
14:30:16 <Tarrasch> sipa, but can I change the uploaded paste?
14:30:28 <sinelaw> monochrom, not trying to sleep just yet. need to get my one-liner dwt to work
14:30:37 <monochrom> for the noise maker
14:30:50 <kmc> Tarrasch, you can paste a new one or an "annotation", but it doesn't matter, i just wanted to know if you saw the suggestions
14:30:57 <monochrom> sneak sedatives into whatever nice food you offer to the noise makers
14:31:01 <kmc> imo chrisdone wiring HLint into hpaste is absolutely brilliant
14:31:07 <Tarrasch> kmc, yep, didn't know of print actually
14:31:10 <kmc> i was reading ndm's article about how hlint should be used, and it's right in line
14:31:11 <ddarius> kmc: Agreed.
14:31:18 <quicksilver> ezrakilty: rehhhhh
14:31:25 <quicksilver> ezyang: rehhhhh
14:31:28 <Tarrasch> Is there any easy way to HLint your own cod?
14:31:29 <Tarrasch> code*
14:31:29 <sinelaw> monochrom, that food was for me
14:31:33 <monochrom> I was originally thinking fatal poison
14:31:36 <sipa> hlint Source.hs
14:31:37 <kmc> Tarrasch, the command line tool 'hlint'
14:31:40 <quicksilver> ezrakilty: sorry, wrong nick completion.
14:31:42 <kmc> cabal install hlint
14:31:44 <ezrakilty> whew
14:31:51 <ezrakilty> had me scared!
14:31:52 <Tarrasch> ah ok
14:31:54 <ddarius> monochrom: Then he'd have to move or renegotiate his lease.
14:32:08 <kmc> not necessarily
14:32:17 <kmc> fatal poison ⇒ landlord dies ⇒ no heirs ⇒ bank auction ⇒ buy the house cheap
14:32:24 <djahandarie> How exactly would you prove the communitivity of addition on real numbers? I think it has to do with the limit of a cauchy sequence of rationals but I'm not sure past that
14:32:25 <kmc> (you might have to poison his heirs, too)
14:32:32 <monochrom> yeah, sedative is a good compromise between ideal and reality
14:32:42 <sinelaw> ok we're losing focus here. the real problem is why doesn't my wavelet thing work
14:32:44 <kmc> djahandarie, that's a definition of the reals, yeah
14:32:54 <sinelaw> not the noise, which, btw, has stopped.
14:33:05 <djahandarie> kmc, right, but I odn't know how that helps prove any property of addition
14:33:21 <kmc> hmm, let's see
14:33:28 <kmc> how do you define real addition then?
14:33:36 <kmc> is it just pointwise addition of cauchy sequences?
14:33:39 <ddarius> djahandarie: You can add Cauchy sequences and then you can show that that addition corresponds to the addition we want on reals.
14:33:44 <ddarius> kmc: Yep.
14:33:52 <kmc> the pointwise sum of cauchy sequences is cauchy?
14:33:54 <ddarius> You may need to adjust the Ns though.
14:34:04 <djahandarie> You need to adjust the ns?
14:34:08 <monochrom> yes, pointwise works. just long proof.
14:34:11 <Tarrasch> Just one annotation about the (+3) commutativity
14:34:32 <Tarrasch> lambdabot can surely do (+3) to (3+) if it wants, it's commutative for Num at least? 
14:34:37 <ddarius> djahandarie: I think rather constructively.
14:34:46 <djahandarie> Tarrasch, we were just discussing that. Num doesn't guarentee that
14:34:49 <kmc> Tarrasch, there's plenty of Num instances where (+) is not commutative
14:34:51 <kmc> you just wrote one
14:34:57 <monochrom> but it's similar to lim x + lim y = lim (x+y) whenever lim x, lim y are good
14:35:07 <Tarrasch> Sorry, not for num, for anything inbuilt as numbers
14:35:20 <djahandarie> Tarrasch, kmc just brought up Double
14:35:21 <kmc> it might not hold for floating point in corner cases
14:35:24 <Tarrasch> and 3 is a number
14:35:27 <Tarrasch> ah ok
14:35:27 <kmc> i don't know
14:35:30 <monochrom> s/x+y/x `pointwise +` y
14:35:32 <sipa> djahandarie: a real number is defined as a set of cauchy sequences with the same limit, and the sum of two real numbers is the set of cauchy sequences that are the pointwise sum of a sequence in the first set with a sequence in the second; so if you want to know whether (a+b)==(b+a) you should wonder if the limit of the pointwise sum remains equal, which it clearly is, since (+) on rationals is commutative as well
14:35:34 <ddarius> :t 3
14:35:34 <kmc> Tarrasch, the literal 3 has type (Num a) ⇒ a
14:35:35 <lambdabot> forall t. (Num t) => t
14:35:44 <dolio> > x + 3 == 3 + x
14:35:45 <lambdabot>   False
14:35:52 <monochrom> I personally prefer dedekind cuts though
14:35:57 <kmc> Tarrasch, with your code, you can write (3 :: Tree Char)
14:36:07 <Tarrasch> Yea
14:36:08 <kmc> (it's a runtime error, because you underspecified your Num instance)
14:36:11 <Tarrasch> you're compltely right
14:36:16 <kmc> you can use -Wall to get a warning on that
14:36:21 <ddarius> Dedekind cuts have nice relations to sober spaces.
14:36:27 <ezyang> quicksilver: Wassup 
14:36:28 <Tarrasch> it just uses fromInteger :p
14:36:29 <djahandarie> monochrom, what about adding signed integers?
14:36:36 <Cale> I prefer the one-sided Dedekind cuts over the two-sided ones.
14:36:36 <dolio> > 1 + 2 == (2 + 1 :: Expr)
14:36:37 <lambdabot>   True
14:36:45 <kmc> i prefer my spaces drunk
14:36:49 <Tarrasch> djahandarie, would be scary if it didn't hold for that!
14:36:55 <sipa> djahandarie: you wonder how to derfine that?
14:36:57 <sipa> define
14:37:00 <djahandarie> No.
14:37:02 <dolio> > [1 + 2, 2 + 1] :: [Expr]
14:37:03 <lambdabot>   [1 + 2,2 + 1]
14:37:04 <ddarius> Cale: Have you ever looked at Paul Taylor's Abstract Stone Duality stuff?
14:37:05 <monochrom> adding signed integers work fine
14:37:20 <monochrom> abstract stoned duality XD
14:37:31 <djahandarie> Err
14:37:33 <djahandarie> Maybe it wasn't that
14:37:37 <djahandarie> Multiplication?
14:37:39 <Cale> ddarius: It rings a bell, but at the moment I can't recall.
14:37:42 <monochrom> do you still remember the good old days of the "your pc is stoned!" virus? :)
14:37:50 <djahandarie> I remember there is something weird about using Dedekind cuts
14:38:00 <sinelaw> monochrom, yeah! i was just joking about that with someone yesterday
14:38:01 <monochrom> multiplication of signed integers work fine.
14:38:23 <Tarrasch> kmc, is there any sensible Num where (+) isn't commutative? Surely the Tree isn't ;)
14:38:36 <sipa> Tarrasch: define sensible
14:38:43 <kmc> Tarrasch, if you add the law "Num should be a ring", then no
14:38:59 <sipa> expression trees are a perfectly sensible instance to me
14:39:07 <kmc> they are useful anyway
14:39:22 <kmc> but you could define extensional equality of expression trees
14:39:27 <Tarrasch> bah, no it isn't sipa
14:39:28 <kmc> interpreted as functions
14:39:36 <Tarrasch> what on earth would (*) mean?
14:39:48 <sipa> multiplication?
14:39:51 <kmc> data Exp a = Add (Exp a) (Exp a) | Mul (Exp a) (Exp a) | Lit Integer
14:39:58 <sipa> exactly
14:40:03 <kmc> err, the a's there are kinda useless
14:40:05 <Tarrasch> kmc, Yea that one is actually true
14:40:11 <kmc> data Exp = Add Exp Exp | Mul Exp Exp | Lit Integer
14:40:17 <sipa> and since you need negate and abs as well:
14:40:20 <Cale> ddarius: This is interesting stuff. I don't think I have seen this.
14:40:28 <kmc> instance Num Exp where (+) = Add; (*) = Mul; fromInteger = Lit
14:40:28 <Tarrasch> Num is really sensible there
14:40:31 <sipa> data Exp = Add Exp Exp | Mul Exp Exp | Abs Exp | Neg Exp | Lit Integer 
14:40:44 <Tarrasch> can't believe I never thought of it myself
14:40:53 <ezyang> Heh, cute. 
14:41:02 <kmc> that's a common trick for EDSLs
14:41:08 <Tarrasch> Lit 4 + Lit 5 == Add (Lit 4) (Lit 5), I guess you meant then
14:41:15 <ezyang> I thought tagless was in fashion these days :-) 
14:41:16 <Tarrasch> or simply (+) = Add
14:41:35 <monochrom> If you don't include free variables in Exp, you don't even need extensional equality.
14:42:00 <augustss> ezyang: depends what you wanna do
14:42:19 <djahandarie> augustss, hey!
14:42:32 <djahandarie> augustss, there is a problem in CReal
14:42:41 <Tarrasch> well, goodnight, Nice talking to you all ^^
14:42:43 <tg_> this... abstract stone duality...
14:42:43 <augustss> Which one?
14:42:47 <tg_> is this.. real?
14:42:51 <monochrom> haha
14:42:58 <monochrom> but yes
14:43:07 <tg_> i mean, if someone smarter than me read all of these links, would they think this is a crazy person or not?
14:43:14 <djahandarie> augustss, the one in numbers
14:43:18 <sipa> :t Real
14:43:19 <lambdabot> Not in scope: data constructor `Real'
14:43:25 <tg_> not Real
14:43:28 <augustss> djahandarie: yes, but which problem?
14:43:30 <tg_> http://www.paultaylor.eu/ASD/
14:43:32 <tg_> this
14:43:33 <monochrom> not crazy person
14:43:44 <djahandarie> augustss, digitsToBits has weird overflowing issues
14:43:49 <tg_> ok cool
14:44:13 <augustss> djahandarie: oh, well, I didn't write the code, i only packaged it
14:44:42 <tg_> I suppose I should be interested in this since my goal is to understand some fractal geometries in haskell :o
14:44:42 <djahandarie> Okay, would you accept a patch if I wrote one (that works)?
14:44:49 <augustss> sure
14:44:50 <tg_> and I see a mention of Hausdorff space her e:o
14:45:01 <sinelaw> package maintainers: absolving responsibility since 1983
14:45:25 <ddarius> tg_: Paul Taylor is well known.
14:45:42 <tg_> ddarius: ok
14:46:11 <monochrom> this is not crazy. this is what I have always looked for!
14:46:28 <tg_> monochrom: so then you can describe what it does/how to use it?
14:46:37 <monochrom> no.
14:46:52 <tg_> aw, shucks.
14:47:00 <roconnor> djahandarie: what is the overflowing issues?
14:47:07 <gwern> sinelaw: I think 'abdicating' would be a more apposite term
14:47:08 <ddarius> tg_: Hausdorff dimension and Hausdorff space are not very related.
14:47:19 <gwern> @wn absolve
14:47:23 <sinelaw> gwern, fair enough
14:47:34 <lambdabot> Error: thread killed
14:47:43 <sinelaw> lambdabot is absolving
14:47:45 <tg_> ddarius: a fact which I just learned :o
14:47:46 <djahandarie> roconnor, just the fact that it's defined over Int
14:48:03 <dolio> That's not a realistic issue.
14:48:49 <djahandarie> It results in some weird as hell bugs though
14:48:50 <Cale> " a purely recursive theory of elementary real analysis in which, unlike in previous approaches, the real closed interval [0,1] is compact." -- That seems like it would be an important property for the unit interval to satisfy ;)
14:49:24 <roconnor> djahandarie: you are after the 66000th bit?
14:49:40 <ddarius> Cale: There can't be -that- much math that depends on the local compactness of the reals.
14:50:08 <djahandarie> ...not sure if it is the 66000th, but whatever range at the end of Int that fails to map to an Int representation of the amount of bits
14:50:23 <djahandarie> Err
14:50:24 <roconnor> > maxBound :: Int
14:50:24 <lambdabot>   9223372036854775807
14:50:46 <roconnor> djahandarie: you are after the 9223372036854775808th bit?
14:50:54 <djahandarie> No
14:51:21 <djahandarie> Oh
14:51:22 <djahandarie> Yeah
14:51:34 <ddarius> Cale: One of the interesting things that isn't showcased as much is the generalized notion of "definition by description" that is developed.
14:51:35 <roconnor> Cale: depends on the definition of compact
14:51:38 <djahandarie> > showCReal (maxBound `div` 2 :: Int)
14:51:38 <lambdabot>   Overlapping instances for GHC.Show.Show
14:51:39 <lambdabot>                              (Data....
14:51:42 <djahandarie> > showCReal (maxBound `div` 2 :: Int) 1000
14:51:43 <lambdabot>   "*Exception: Negative exponent
14:52:11 <djahandarie> I think there should just be some sort of check to not end up breaking like that
14:52:33 <roconnor> > showCReal (maxBound `div` 8 :: Int) 1000
14:52:38 <lambdabot>   mueval: ExitFailure 1
14:52:55 <roconnor> djahandarie: some sort of check?
14:53:15 <roconnor> djahandarie: you want to change the error message?
14:53:19 <djahandarie> Basically
14:53:43 <benmachine> > maxBound `div` 2 :: Int
14:53:44 <lambdabot>   4611686018427387903
14:53:48 <benmachine> hmm
14:54:00 <roconnor> > showCReal (maxBound `div` 4 :: Int) (1000)
14:54:03 <ddarius> benmachine: What were you expecting?
14:54:05 <lambdabot>   mueval: ExitFailure 1
14:54:11 <roconnor> > showCReal (maxBound `div` 4 :: Int) (1000+1000+1000+1000+1000+1000+1000+1000+1000+1000+1000+1000+1000+1000)
14:54:11 <djahandarie> It'd be nice if was enforced in the type system, but ;)
14:54:16 <lambdabot>   mueval: ExitFailure 1
14:54:25 <djahandarie> I think that is too much for lambdabot to processes
14:54:27 <djahandarie> process
14:54:38 <roconnor> oh god
14:54:39 <benmachine> ddarius: that was the logical thing for it to be, I was just wondering if I'd be surprised by something overflowy
14:54:55 <roconnor> digitsToBits d = ceiling (fromIntegral d * (logBase 2.0 10.0 :: Double)) + 4
14:55:02 <roconnor> logBase!
14:55:08 <roconnor> :: Double!!
14:55:20 <roconnor> that doesn't seem safe
14:55:41 <djahandarie> I wasn't 100% sure what it was doing and if I'd be able to replicate it a different way though, roconnor 
14:56:02 <roconnor> djahandarie: I 102% support any change that would get rid of logBase and Double
14:56:11 <djahandarie> lol
14:56:15 <ddarius> The logBase 2.0 10.0 is just a constant.
14:56:22 <benmachine> > logBase 2 10
14:56:23 <lambdabot>   3.3219280948873626
14:56:24 <roconnor> ddarius: an approximation
14:56:52 <sioraiocht> roconnor: still a constant =p
14:57:01 <sioraiocht> you can't apply it to anything
14:57:12 <ddarius> > logBase 2 10 ()
14:57:13 <lambdabot>   3.3219280948873626
14:57:16 <djahandarie> Haha
14:57:19 <roconnor> > showCReal 0 (fromIntegral maxBound `div` 4)
14:57:20 <lambdabot>   No instance for (GHC.Real.Integral Data.Number.CReal.CReal)
14:57:20 <lambdabot>    arising from...
14:57:25 <djahandarie> vector-space, proving you wrong!
14:57:28 <roconnor> > showCReal 0 (fromIntegral maxBound)
14:57:29 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:57:29 <lambdabot>    `GHC.Real.Integral a'
14:57:29 <lambdabot>   ...
14:57:46 <roconnor> > showCReal 0 (fromIntegral (maxBound ::Int))
14:57:47 <lambdabot>   "9223372036854775807"
14:57:54 <djahandarie> Haha
14:58:03 <roconnor> > showCReal 0 (fromIntegral (maxBound ::Int)^2)
14:58:04 <lambdabot>   "85070591730234615847396907784232501249"
14:58:33 <roconnor> > let x = fromIntegral (maxBound ::Int)^2 ::Integer in (x,showCReal 0 (fromIntegral x))
14:58:34 <lambdabot>   (85070591730234615847396907784232501249,"8507059173023461584739690778423250...
14:58:41 <ddarius> roconnor: Does it matter if digitsToBits returns a number a little bit too high?
14:59:04 <sipa> :t digitsToBits
14:59:05 <lambdabot> Not in scope: `digitsToBits'
14:59:15 <djahandarie> sipa, in Data.Number.CReal
14:59:19 <djahandarie> Not exported though
14:59:40 <roconnor> ddarius: shouldn't it?
15:00:08 <ddarius> I would have to look at what CReal is doing with it, but if it is doing what I think it's doing, I doubt it matters.
15:00:23 <roconnor> ddarius: oh wait I see
15:00:23 <ddarius> It would just lead to a little more work done, but the result would look the same.
15:00:32 <roconnor> ok
15:00:33 <djahandarie> It uses it for a lot of stuff
15:00:56 <djahandarie> I think it could introduce inaccuracies
15:01:09 <roconnor> ddarius: I thought it was being used to convert numbers to decimal
15:01:29 <roconnor> ddarius: it's just used to compute the number of bits to show a string of lenght something
15:01:33 <roconnor> whew
15:01:40 <djahandarie> No, it is being used for a bunch of the instances
15:01:49 <djahandarie> x >= y = s' (digitsToBits digits) >= 0 where (CR s') = x-y
15:02:09 <roconnor> djahandarie: oh well, those functions are stupid.  You shouldn't use (those implementations)
15:02:21 <roconnor> and probably shouldn't use them at all
15:02:39 <roconnor> they are full of lies
15:02:50 <djahandarie> lol
15:02:53 <roconnor> > (-10^-200) >= (0::CReal)
15:02:54 <lambdabot>   Not in scope: `^-'
15:03:04 <roconnor> > (-(10^(-200))) >= (0::CReal)
15:03:05 <lambdabot>   *Exception: Negative exponent
15:03:09 <roconnor> > (-(10^^(-200))) >= (0::CReal)
15:03:10 <lambdabot>   True
15:03:12 <roconnor> see
15:03:15 <roconnor> lies!
15:03:23 <ddarius> djahandarie: Actually, if digitsToBits over-estimates, it will make those -more- accurate.
15:04:08 <roconnor> djahandarie: besizes thoses instances only ever calls digitsToBits with 40
15:04:33 <djahandarie> Yeah, that's true
15:04:37 <roconnor> djahandarie: the only place digitsToBits isn't applied to 40 is showCReal
15:04:53 <djahandarie> This file just feels like a big hack, I think that is my issue :P
15:04:54 <roconnor> djahandarie: and you only get your error when you start asking for obscene number of digits
15:05:39 <roconnor> djahandarie: the fact we are using Int means it is going to fail at some number.
15:05:53 <djahandarie> But at least then it is expressed in the type
15:06:36 <roconnor> djahandarie: you want digitToBits to work for all valid Ints?
15:06:52 <djahandarie> I just don't want it to overflow
15:07:29 <roconnor> > logBase 2.0 10.0 :: Double
15:07:30 <lambdabot>   3.3219280948873626
15:07:38 <sinelaw> is there something like `div` that will give 5/2 = 3?
15:07:45 <sinelaw> (same as div but picks the ceiling)
15:07:46 <roconnor> > 5 `div` 2
15:07:46 <lambdabot>   2
15:07:57 <roconnor> > -((-5) `div` 2)
15:07:58 <lambdabot>   3
15:08:08 <sinelaw> ugggh
15:08:39 <sinelaw> @pl \x y -> -((-x) `div` y)
15:08:39 <lambdabot> (line 1, column 9):
15:08:39 <lambdabot> unexpected "-"
15:08:39 <lambdabot> expecting lambda abstraction or expression
15:08:52 <roconnor> djahandarie: what type would you give to digitsToBits?
15:09:21 <sinelaw> @pl \x y -> (-((-x) `div` y))
15:09:21 <lambdabot> (negate .) . div . negate
15:09:21 <aristid> :t fmap ceiling . (/)
15:09:22 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> a -> b
15:09:55 <aristid> :t let (.:) = (.).(.) in ceiling .: (/)
15:09:56 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> a -> b
15:10:01 <dolio> Overflowing is bad. Using all my memory is good. :)
15:10:39 <ddarius> dolio: What if you want to fill your hard drive with the digits of pi?
15:11:00 <dolio> You mean, accidentally?
15:11:05 <aristid> ddarius: then he will do so
15:11:12 <djahandarie> roconnor, I wouldn't change the type, but I'd make the runtime error happen in that function
15:11:58 <roconnor> djahandarie: This is a general problem with GHC
15:12:31 <roconnor> djahandarie: I'm surprised you want to put an bandaid here in CReal and not all the other places in the world where overflow happens.
15:13:01 <djahandarie> I want to put a bandaid here because it results in inintelligable errors
15:13:39 <roconnor> djahandarie: yes, but the same problem occurs everywhere
15:14:04 <roconnor> djahandarie: every time someone gets an *** Exception: Prelude.head: empty list
15:14:35 <roconnor> every time someone gets an *** Exception: divide by zero
15:14:47 <roconnor> heck this isn't even really haskell specific
15:15:02 <roconnor> everytime someone gets Segmenation Fault in their C or Ocaml program
15:15:12 <sipa> they start valgrind
15:15:14 <sinelaw> :t fmap ceil
15:15:15 <lambdabot> Not in scope: `ceil'
15:15:19 <roconnor> sipa: exactly
15:15:19 <sinelaw> :t fmap ceiling
15:15:20 <lambdabot> forall a b (f :: * -> *). (RealFrac a, Integral b, Functor f) => f a -> f b
15:15:36 <sinelaw> ooh
15:15:49 <sinelaw> I didn't think of using the functor instances like that
15:16:13 <djahandarie> roconnor, well, then I use GADTs and Peano numbers ;)
15:16:15 <sinelaw> :t ceiling . (/)
15:16:16 <lambdabot> forall b a. (RealFrac (a -> a), Integral b, Fractional a) => a -> b
15:16:37 <ddarius> djahandarie: That will just change to out of memory exceptions.
15:16:49 <djahandarie> Details
15:16:49 <roconnor> djahandarie: anyhow, I guess putting a bandaid here is fine.  Just be aware there are a million other hole in the code in Hackage.
15:16:56 <sinelaw> > fmap ceiling . (/) 2 3
15:16:57 <lambdabot>   No instance for (GHC.Show.Show (f (f1 b)))
15:16:57 <lambdabot>    arising from a use of `M14812...
15:17:12 <roconnor> ddarius: not that.  djahandarie just wants to change the error message.
15:17:26 <Kaidelong> any particular reason why Mercury uses uniqueness types
15:17:30 <Kaidelong> they seem clunky
15:17:41 <sinelaw> > (fmap ceiling . (/)) 2 3
15:17:42 <lambdabot>   1
15:17:56 <sinelaw> :t (fmap ceiling . (/)) 2 
15:17:57 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:18:15 <roconnor> ddarius: from Exception: Negative exponent to Exception: Cannot CRealShow so many digits
15:18:55 <ddarius> roconnor: I was talking about switching to Peano numbers.
15:19:04 <roconnor> oh
15:19:06 <roconnor> right
15:19:28 <ezyang> Can I write an evil function (forall a. a) -> Int that is not just const? 
15:19:38 <ezyang> erm, I mean (forall a. a -> Int) 
15:19:56 <aristid> ezyang: unsafe*?
15:19:57 <sipa> yes, undefined
15:20:22 <ezyang> aristid: Maybe unsafeCoerce would do the trick. 
15:20:31 <aristid> ezyang: yes, possibly
15:20:38 <Saizan> ezyang: you can do funny things with the underlying memory representation through unsafeCoerce/unsafePerformIO
15:20:48 <ezyang> Basically, I want to be able to smush together an Int -> Int and a Bool -> Int function, and make everything else undefined or some default value. 
15:21:14 <sipa> without any unsafe things, i'd say you can only have it: undefined, const undefined, or const someInt (or other bottom types)
15:21:55 <performance> hi, which patterns am i not matching here? http://hpaste.org/40580/non_exhaustive_patterns
15:22:06 <ddarius> class Eval a where seq' :: a -> b -> b; instance Eval a where seq' = seq
15:22:13 <kmc> performance, doesn't GHC tell you?
15:22:50 <ezyang> performance: c:cs and x:y:zs are not complete. 
15:22:52 <benmachine> ezyang: Typeable, and cast?
15:23:17 <ezyang> benmachine: Yeah, that sounds like it'd do the job. 
15:23:20 <benmachine> depending on how pedantic you are about "everything else"
15:23:26 <kmc>              In the definition of `merge': Patterns not matched: (_ : _) [_]
15:23:27 <sipa> performance: merge [a] [b]
15:23:28 <monochrom> if input is 'x':'x':[], it doesn't match anything
15:23:29 <ezyang> I wonder if someone's coded up this pattern already and put it on Hackage. 
15:23:33 * hackagebot nano-cryptr 0.1 - A threadsafe binding to glibc's crypt_r function  http://hackage.haskell.org/package/nano-cryptr-0.1 (CarlHowells)
15:23:35 <benmachine> not really pedantic but whatever
15:23:37 <TeachmeHaskell> Hello folkz
15:23:44 <monochrom> err, if input is 'x':[], it doesn't match anything
15:23:51 <c_wraith> sorry, folks.  I wrote it, I had to put it on hackage. :)
15:23:54 <benmachine> ezyang: it sounds like Data.Generics
15:23:58 <benmachine> :t mkQ
15:24:00 <lambdabot> forall r b a. (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
15:24:38 <ezyang> Ah, that's not unsafe enough for me >:-) 
15:24:44 <benmachine> ah
15:24:52 <benmachine> k
15:24:56 <benmachine> unsafeCoerce it is
15:24:59 <benmachine> <_<
15:25:01 <benmachine> good luck with that
15:25:14 * ezyang wants to grep hackage for unsafeCoerce now... 
15:25:37 <ddarius> You wouldn't actually be able to distinguish between Bool and Int and other types necessarily.
15:26:00 <ezyang> ddarius: Oh, do we erase all that info? 
15:26:11 <benmachine> all types are erased at runtime I think
15:26:12 <monochrom> f :: Dynamic -> Int
15:26:41 <ezyang> I'm not quite sure I believe that. 
15:26:53 * benmachine wonders if OverlappingInstances is sufficiently evil
15:26:55 <roconnor> reverse $ dropWhile (== '0') $ reverse fs
15:27:01 * roconnor sighs at CReal
15:27:05 <monochrom> forall a. (Show a) => a -> Int.  use the show method and a parser to determine if it looks like a number or a bool or unrecognized
15:27:27 <alexsuraci> how does hackage handle package ownership? say I upload "foo", could anyone else update "foo" if I were to disappear?
15:27:32 <ezyang> monochrom: If I'm going to add a type constraint, Typeable would be what I'd want. 
15:27:38 <roconnor> ddarius, djahandarie: indeed I think I could get showCReal to print out lies if that code wasn't there
15:27:39 <ddarius> alexsuraci: Currently, yes.
15:27:49 <monochrom> Typeable is not evil enough :)
15:28:40 <alexsuraci> ddarius: how does that work?
15:29:09 <benmachine> alexsuraci: it works because no-one tries to break it
15:29:10 <ezyang> ok, I don't think I can achieve my goal of forall a. a -> Int 
15:29:11 <alexsuraci> honor system? or does the original owner have to, say, specify a different maintainer in the cabal file?
15:29:16 <c_wraith> honor system
15:29:19 <ezyang> because of type erasure, dangit! 
15:29:32 <c_wraith> Part of why you have to request an account from a real human
15:29:53 <alexsuraci> c_wraith: ah, alright. just curious since I may upload a monads-fd version of another package.
15:29:53 <benmachine> ezyang: have you tried OverlappingInstances? instance Foo Int, instance Foo Bool, instance Foo a?
15:30:00 <dcoutts> alexsuraci: the new server has a permission system, so not anyone with an upload account can upload to any package name
15:30:10 <benmachine> I'm not sure if that even works but if it does presumably the constraint could be erased
15:30:29 <ezyang> benmachine: Oh, interesting. It'd be worth a try. 
15:30:39 <alexsuraci> dcoutts: sounds good
15:30:42 <roconnor> ddarius, djahandarie: I believe " showCReal  (1000 + ceiling (fromIntegral (maxBound ::Int) * 2/(logBase 2.0 10.0)) :: Int) pi " will be wrong if it ever gets around to printing something
15:30:50 <benmachine> overlappinginstances: useful for all sorts of high evil.
15:31:04 <roconnor> djahandarie: so perhaps a check is warrented :)
15:31:46 <Saizan> benmachine: if you have (forall a. Foo a => a -> Int) and you force it to be (forall a. a -> Int) it'll use the dictionary for the generic instance
15:32:08 <benmachine> Saizan: drat it
15:32:37 <Saizan> though i guess "forall a. Foo a => a -> Int" is not problematic if users never have to write a Foo instance
15:32:57 <ddarius> roconnor: Why do you think that?
15:33:20 <ezyang> Yeah, I should be able to project any forall a. to a forall a. Foo a => 
15:34:58 <monochrom> oohhh, unsafeCoerce the function not the data, that's clever.
15:35:10 <ddarius> That would just crash.
15:39:10 <lispy> When you write it as (forall a. Foo a => a -> Int), is that a rank2 type?
15:39:27 <lispy> Or are the brackets just there to separate it from the sentence?
15:39:44 <ezyang> It's not Rank2, though you'd probably need the extension to say that. 
15:40:40 <lispy> Ah okay.  I only asked because with type classes in the right spot of a Rank2 type you can do some funky stuff
15:40:59 <lispy> See for example, Oleg's law of excluded middle using the Monad type class and Rank2 types
15:49:09 <adimit> Can I do a qualified import in the new ghci? I know that import works now, but import qualified .. as .. doesn't seem to...
15:50:14 <Saizan> that should work with ghc 7
15:50:39 <adimit> Ah, so doesn't yet with 6.12.1, eh? Thanks for the info.
15:51:24 <Saizan> np
16:03:12 <ezyang> Fact check: the types of Haskell polymorphic functions correspond to statements in first order logic. 
16:03:12 <ezyang> (no extensions) 
16:04:49 <dibblego> why only polymorphic functions?
16:05:21 <ezyang> well, all functions 
16:05:31 <ezyang> but the non-polymorphic functions are statements in propositional logic too 
16:05:57 <monochrom> I don't know what FOL statement "Int" becomes
16:06:46 <ezyang> A propositional symbol. Alternatively, #t >:-) 
16:08:05 <Saizan> and if you have an higher-kinded type variable?
16:08:39 <ezyang> Yeah, that's the worrying bit. 
16:08:57 <ezyang> I think it's not a problem as long as it's not a type function, but I'm not sure. 
16:09:19 <Saizan> how would you translate it?
16:09:46 <Saizan> since the most natural translation would lead to higher order logic
16:10:48 <ezyang> Saizan: I think I can safely drop the higher kinded variables and conjunct the *s that were involved. 
16:11:50 <monochrom> higher-order logic is awesome
16:12:20 <roconnor> monochrom: it is?
16:12:47 <monochrom> yes
16:12:52 <Saizan> ezyang: not sure what you mean by that, though e.g. what would "forall (a :: *) (m :: * -> *). a -> m a" become?
16:13:10 <ezyang> a -> a 
16:13:30 <ezyang> which isn't very satisfying >:-) 
16:14:04 <ezyang> I claim the isomorphism defense. 
16:14:28 <ezyang> Also, I think when we add typeclasses I can't argue this anymore. 
16:15:30 <zygoloid> ezyang: http://hpaste.org/40582/isbool_with_maximum_evil
16:16:02 <ezyang> yarrr 
16:16:07 <erisco> http://pastebin.com/wm3GwSGJ is the second version improved over the first? is there any other way, without changing the algorithm, to write this?
16:16:15 <ezyang> that's pretty excellent. 
16:16:18 <zygoloid> ezyang: that's probably not entirely reliable, and i feel dirty for just having typed it, but it works for me ;)
16:17:03 <ezyang> erico: What does it do? 
16:17:25 <ezyang> I think you want zipWith 
16:17:47 <ezyang> that'll get rid of the uncurry 
16:18:36 <erisco> @src zipWith
16:18:36 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
16:18:36 <lambdabot> zipWith _ _      _      = []
16:18:59 <erisco> @src zip
16:19:00 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
16:19:00 <lambdabot> zip _      _      = []
16:19:14 <ezyang> and of course, foldl (+) 0 can become sum 
16:19:29 <erisco> ezyang: thanks
16:20:10 <mreh> what are we in haskell, 4 or 8 spaces?
16:20:33 <zygoloid> mreh: for a tab? 8
16:23:39 <mreh> http://hackage.haskell.org/trac/haskell-prime/wiki/Tabs
16:23:43 <mreh> that's rather drastic
16:24:05 <mreh> but rational I suppose
16:24:40 <ezyang> Oh, I can make typeclasses work with an easy implication. 
16:24:50 <dibblego> mreh, I use 2, I've seen others use 3
16:25:35 <zygoloid> a tab in haskell code is 8 spaces. there is no debate on this. indentation width, on the other hand, is entirely up to you :)
16:26:05 * zygoloid prefers to indent by 2 spaces. some people like to indent to the width of the thing on the previous line.
16:26:10 <Cale> mreh: Ideally, tab characters should not occur in source code.
16:26:27 <mreh> I'm perfectly aware of that :D
16:26:39 <arw> ideally, an indent should be 1 tab and everybody configures tabwidth to his preference.
16:26:40 <mreh> I'm trying to fix some code and not... er break it
16:26:50 <adimit> that's a religious debate. I like tabs as indentation in Java. But in Haskell, tabs should just never occur.
16:26:59 <Cale> arw: Doesn't work when you want to line things up vertically.
16:27:16 <zygoloid> Cale: sure it does, if you use tabs "right" (only at the start of a line)
16:27:23 <Cale> zygoloid: Nope.
16:27:26 <arw> Cale: right. thats the only downside. but its still better than 2 spaces.
16:27:26 <adimit> yeah, Haskell has way to many vertical alignment points for that.
16:27:34 <zygoloid> also, only for indentation, not for spacing
16:28:03 <adimit> Say, you wanna align the equality signs of a guard with the equality sign of a later where clause...
16:28:15 <Cale> zygoloid: Consider the case where you need the start of a line to begin at the same point as a specific piece of text on the previous line.
16:28:17 <ddarius> zygoloid: You don't need the existential.
16:28:18 <zygoloid> Cale: seriously, it does work, but it's a lot of work to get right (you basically need an editor which can show you what's a tab and what's a space)
16:28:23 <caelan> i favor the tabs-as-indentation, spaces-as-alignment usage
16:28:26 <adimit> if you use tabs in the beginning, a different tabwidth would screw it up.
16:28:32 <zygoloid> Cale: tabs to indent, spaces to align
16:28:51 <ddarius> zygoloid: And, unfortunately, isInt won't be so easy.
16:28:57 <mreh> there can only be one!
16:29:01 <zygoloid> ddarius: right. the whole thing is an evil hack.
16:29:14 <arw> adimit: depends, not if each to-be-aligned element is on its own line, including the first one.
16:29:29 <mreh> meanwhile, back at my editor
16:29:34 <Cale> foo x y z = do w <- getLine
16:30:06 <Cale> Here, you need to align the following line with spaces, or it'll be fragile.
16:30:52 <mreh> I write that: foo x y z = do\n   w <- getLine
16:30:55 <Cale> You could use a tab to get to column 8 and then a few spaces, but
16:30:58 <mreh> for that reason
16:31:06 <Cale> There's no reason to do that :)
16:31:08 <mreh> otherwise your code ends up in the margin
16:31:21 <mikeg> Any suggestions for a *fast* XML parser for traversing (not searching) a 100GB+ file? I have hexpat at the moment, and I'm looking into alternatives before I start optimizing
16:31:23 <Cale> I'll usually break my line before the do in that case
16:31:26 <Cale> foo x y z =
16:31:28 <ddarius> zygoloid: Also, codePtr is not referentially transparent, though that's probably beside the point.
16:31:31 <Cale>   do w <- getLine
16:31:39 <dibblego> mikeg, I use HXT to parse a 7.6GB file
16:31:40 <Cale>      otherStuff
16:31:51 <mreh> anyway, haskell is the pretiest I've used
16:31:59 <mikeg> Okay, I'll try HXT too :)
16:32:12 <zygoloid> ddarius: you don't say. you did notice the "maximum evil" in the title, right? ;)
16:32:27 <zygoloid> ddarius: incidentally, it's not as reliable without the existential: try codePtr (:) == codePtr Just
16:32:43 <Cale> With the exception of 'of', and the 'where' in module declarations, I usually don't put a linebreak after layout keywords
16:32:54 <c_wraith> Uh.  Hmm.  Why does this require Rank2Types?  data X = X { runX :: RandomGen g => g -> Int }
16:32:56 <adimit> dibblego: how did it work out for you? I found HXT's reliance on String (over BS) to be quite a showstopper.
16:33:02 <ddarius> zygoloid: It's not immediately obvious that codePtr 5 /= codePtr 5.
16:33:13 <dibblego> adimit, fine, but performance is not critical
16:33:26 <Cale> c_wraith: You're demanding that the field be polymorphic.
16:33:46 <Cale> c_wraith: Hence, the X data constructor has a polymorphic parameter.
16:33:53 <mreh> > (a -> b where b = a) 3
16:33:54 <lambdabot>   <no location info>: parse error on input `where'
16:33:58 <c_wraith> Cale, Oh, I think I'm seeing it now.  I had things backwards in my head.
16:33:59 <adimit> dibblego: ah, yeah. I gotta use hexpat's SAX, and I *long* for some of HXT's arrows or HaXml's combinators. It's such a PITA.
16:34:03 <Cale> X :: (forall g. RandomGen g => g -> Int) -> X
16:34:18 <c_wraith> yeah
16:34:19 <c_wraith> thanks
16:34:21 <zygoloid> ddarius: you can even get codePtr 5 == codePtr 6 if you're really unlucky with the timing of a GC :)
16:34:23 <mreh> > (\a -> b where b = a) 3
16:34:23 <lambdabot>   <no location info>: parse error on input `where'
16:34:40 <ddarius> zygoloid: That would be fine for your purpose.
16:35:01 <zygoloid> ddarius: *i know*. all of your objections are fine for my purpose ;)
16:35:40 <ddarius> zygoloid: The fact that codePtr (5 :: Int) /= codePtr (5 :: Int) is a problem for your purpose.
16:35:46 <mreh> f
16:35:54 <mreh> bah
16:36:01 <zygoloid> nope, my purpose was to write isBool. nothing more. hence the title of the paste.
16:36:33 <zygoloid> this technique can't work for heap-allocated objects at all.
16:37:07 <mreh> why doesn't that parse then?
16:37:49 <caelan> > \a -> (b where b = a)
16:37:50 <lambdabot>   <no location info>: parse error on input `where'
16:38:02 <zygoloid> mreh: where is declaration syntax. lambda is an expression not a declaration.
16:38:21 <caelan> > \a -> (let b = a in b)
16:38:22 <ddarius> where is part of declaration syntax
16:38:23 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
16:38:23 <lambdabot>    arising from a use of `...
16:38:49 <mreh> so If I declare a function, then that's okay then
16:39:12 <caelan> > (\a -> (let b = a in b)) 10
16:39:13 <lambdabot>   10
16:39:33 <caelan> mreh: or use let-in
16:39:58 <ddarius> > (\a -> let in a) 10
16:39:58 <lambdabot>   10
16:40:17 <mreh> caelan: already doing that, I've got a Reader than returns a function, and want to define the function inside a complex let expression
16:40:22 <mreh> without mixing the two contexts
16:41:03 <caelan> would a nested let be too ugly?
16:41:23 <lispy> hmm...I never realized an empty declaration was allowed in a let
16:41:32 <lispy> > let in 1
16:41:32 <mreh> caelan: no, same difference
16:41:33 <lambdabot>   1
16:41:41 <lispy> > let in = 1 in in
16:41:42 <lambdabot>   <no location info>: parse error on input `='
16:41:55 <lispy> > let in = 2 in 2
16:41:56 <lambdabot>   <no location info>: parse error on input `='
16:42:01 <mreh> > let in let in let in let in let in let in 1
16:42:01 <lambdabot>   1
16:42:16 <mreh> I win
16:42:24 <lispy> > let in let in let out = 2 in out
16:42:25 <lambdabot>   2
16:42:31 <zygoloid> > (\a -> let r = b where b = a in r) 0
16:42:32 <lambdabot>   0
16:42:45 <monochrom> catacatacatacatacatacatamorphism?
16:43:02 <lispy> long catacatacatacatacatacatamorphism is loooong.
16:43:13 <donri> What's the reasoning behind functions like getEnv throwing exceptions instead of returning a Maybe?
16:43:24 <caelan> i want a definition of a pult, so we can discuss catapults with straight faces
16:43:25 <mreh> zygoloid: are you a wizard?
16:43:43 <lispy> donri: hmm...I thought there was a version that returns Maybe String
16:43:52 <mreh> oh, b is a declaration
16:43:54 <lispy> ?hoogle getEnv
16:43:54 <lambdabot> System.Environment getEnv :: String -> IO String
16:43:54 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
16:44:16 <monochrom> exceptions are awesome
16:44:26 <zygoloid> mreh: it's a binding group for r, so you can put a where on it :)
16:44:30 <mreh> > fix exception
16:44:31 <lambdabot>   Not in scope: `exception'
16:45:35 <lispy> donri: getEnvironment >>= return .fromList
16:45:54 <lispy> donri: you need to import Data.Map and System.Environment first
16:46:11 <lispy> donri: then you can use the normal Data.Map.lookup
16:46:27 <monochrom> has it been raised that "any reason why hPutStrLn throwing exceptions instead of returning a Maybe?"?
16:46:49 <lispy> monochrom: with getEnv I think the question is totally justified
16:47:07 <donri> lispy: Yea I already figured that out; my question is more about the reason it's not a Maybe to begin with. What are the benefits and downsides of Maybe vs exception, when to use what etc
16:47:09 <monochrom> perhaps it's justified for hGetChar too
16:53:44 <roconnor> since hGetChar is in IO and there are many reasons for failure, I don't see why not use IO exceptions
17:02:16 <FunctorSalad_> what kind of gadget is this, in abstract nonsense terms? newtype Sink a = Sink (a -> IO ())
17:02:23 <FunctorSalad_> clearly a cofunctor
17:02:41 <FunctorSalad_> but not quite a comonad (no extract :: Sink a -> a)
17:03:11 <edwardk> FunctorSalad_: erm comonads are not contravunctors
17:03:15 <edwardk> er functors even
17:03:42 <FunctorSalad_> hmm true. I has the dumb
17:04:06 <edwardk> sok. i has the typo ;)
17:04:06 <kmc> "contravunctor" is a nice contraction
17:05:57 <FunctorSalad_> edwardk: hmm I thought the function of this type was peculiar: (a -> (b1,b2)) -> Sink b1 -> Sink b2 -> Sink a
17:06:37 <FunctorSalad_> but it's just cofmap followed by the (Sink b1, Sink b2) -> Sink (b1,b2) function given by writing one after the other
17:07:44 <FunctorSalad_> nothing much to see here I guess :)
17:07:50 <conal> i'm having trouble with the text package (http://hackage.haskell.org/package/text) on mac os x.  i'm process a utf-8 file containing a single character, "⊤".  i get "*** Exception: bar.html: hGetContents: invalid argument (Illegal byte sequence)".  and then "ghc(39504,0xb0103000) malloc: *** error for object 0x2203460: pointer being freed was not allocated".
17:07:58 <conal> any ideas?
17:08:57 <kmc> conal, GHC 6.12?
17:09:13 <kmc> what's the setting of your $LANG env var?
17:09:16 <conal> kmc: 6.12.3
17:09:43 <conal> kmc: not set.  what's LANG?
17:10:09 <conal> googling
17:10:13 <kmc> sets the locale
17:10:21 <kmc> try en_US.UTF-8
17:10:33 <kmc> i'm extrapolating from Linux stuff; i don't know if it's applicable to OS X
17:11:02 <conal> kmc: thanks a bunch.  i'll look into it.
17:11:06 <kmc> :)
17:11:41 <kmc> as a workaround, you could do ByteString IO and then use Data.Text.Encoding
17:12:00 <kmc> also i'd double-check with hexdump that your file is UTF-8
17:12:58 <conal> cool
17:13:55 <tehgeek> For some reason every predicate I write, instead of saying "yes" like my homework says it's supposed to, prompts the user "true?" and then if the user hits semicolon, boots out to "no."  Can anyone explain to me why that is and what I'm doing wrong?  TIA
17:14:09 <tehgeek> (obviously, that's if the predicate is supposed to return true)
17:14:11 <conal> kmc: how might i verify utf-8-ness with hexdump?
17:14:35 <kmc> it'll tell you the bytes in the file
17:14:41 <kmc> and you can look up how UTF-8 works
17:14:42 <conal> i see: 0000000 e2 8a a4 0a
17:14:46 <conal> ah!
17:16:51 <kmc> tehgeek, wrong channel?
17:16:57 <kmc> sounds like Prolog
17:17:07 <tehgeek> oh shit, yep.  my apologies
17:17:32 <tehgeek> my brain is mush
17:17:46 <kmc> no worries :)
17:17:56 <kmc> clearly you should do you Prolog homework using Haskell's LogicT instead :)
17:18:03 <tehgeek> I'd probably like that a lot better
17:18:08 <tehgeek> I actually enjoyed Haskell quite a bit
17:18:17 <tehgeek> now we've moved on in my class to Prolog, and I'm ready to punch things
17:18:27 <dibblego> @unmtl LogicT
17:18:27 <lambdabot> LogicT
17:18:36 <kmc> @hackage logict
17:18:37 <lambdabot> http://hackage.haskell.org/package/logict
17:18:47 <dibblego> ta
17:19:29 <kmc> dibblego, ∀ans. (a → m ans → m ans) → m ans → m ans
17:19:43 <dibblego> I wonder what you just said
17:19:55 <kmc> it's in CPS to avoid an interpretive overhead that you get with list-like implementations of backtracking
17:19:59 <kmc> there's a good paper on this
17:20:04 <dibblego> the Oleg one?
17:20:58 <ezyang> logict 
17:21:04 <kmc> Backtracking, Interleaving, and Terminating Monad Transformers
17:21:08 <kmc> Oleg et al
17:21:12 <dibblego> ok cheers
17:21:17 <ezyang> oh, *reads scrollback* :o) 
17:21:18 <kmc> linked from the logict hackage page
17:21:27 <dibblego> right
17:24:07 <conal> kmc: $LANG fixes both problems.  :) !
17:24:13 <kmc> yay
17:24:38 <kmc> it is unfortunate that you can get an internal malloc error by having the wrong encoding
17:24:40 <kmc> wonder if that's a bug
17:24:47 <conal> yeah.  wow.
17:29:32 <kfish> hi conal :)
17:29:48 <conal> kfish: hi :)
17:29:55 <conal> kfish: how's life?
17:30:35 <kfish> not too bad, been making use of the spa here :)
17:31:23 <kfish> and soon the leaves will change colour etc.
17:31:41 <conal> kfish: sweet :)
17:31:53 <conal> kfish: i miss that spa.  was my twice-daily bliss time.
17:32:09 <kfish> hehe
17:32:26 <conal> usually four times -- before & after swimming each morning & eve.
17:32:32 <kfish> nice
17:32:54 <conal> i saw a bear walk the house last week.
17:33:09 <conal> looked out my office window, and there it was.  a beautiful black bear.
17:33:17 <kfish> wow
17:33:48 <c_wraith> @hoogle (a -> Bool) -> [a] -> Bool
17:33:48 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
17:33:48 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
17:33:48 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
17:34:00 <c_wraith> bah, I want none. :)
17:34:09 <kfish> conal: like http://www.bbc.co.uk/news/world-asia-pacific-11539338 or http://www.27bslash6.com/trash.html ?
17:34:48 * conal looks
17:35:20 <conal> kfish: hah.  no, not like that one.
17:38:41 <conal> kfish: you'd be proud of me.  i opened a github account and created my first project: http://github.com/conal/fix-symbols-gitit .  thanks for introducing me to git.
17:39:08 <kfish> oh cool :)
17:40:40 <conal> i've switched over to gitit for all my journaling.  lots of fun.  now working on automatically sending gitit/pandoc-rendered posts to my blog.
17:40:55 <kmc> nice
17:41:17 <kmc> i've been blogging with pandoc
17:41:24 <kmc> i wonder if BlogLiterately offers some advantage
17:41:46 <conal> oh, hm.  never heard of it.  googling
17:41:51 <kmc> it's on hackage
17:41:57 <alej> i am trying to reinstall a package with profiling. is there a way to automatically have cabal reinstall the necessary packages, also with profiling?
17:42:15 <conal> oh, awesome!
17:42:26 <alej> as it stands i have to run cabal install —reinstall -p <pkg>, which fails because it depends on a package that needs profiling installed…etc
17:42:29 <kmc> alej, not that i've found :/
17:42:44 <blackdog> alej: it'd be nice, hey.
17:42:45 <alej> :(
17:42:48 <alej> hehe
17:43:05 <alej> i guess most poeple end up thinkging "hm i could probably do that…but i'm busy right now"
17:43:13 <kmc> write a script to wrap cabal's failures? ;/
17:43:43 <Saizan> write a script that uses ghc-pkg to find which packages need that
17:43:59 <alej> yeah…maybe one day :)
17:44:28 <Saizan> or delete .ghc, add documentation: True to ~/.cabal/config and then cabal install thepackageyoucareabout
17:44:58 <alej> hmmm
17:45:03 <alej> documentation?
17:45:14 <Saizan> err, sorry
17:45:26 <alej> oh ok i just wasn't sure if documentation included that for some reason
17:45:30 <alej> i imagine it's profiling?
17:45:36 <Saizan> library-profiling
17:46:55 <Saizan> anyhow, the idea is that "rm -fr ~/.ghc" will remove all the packages installed in the user db
17:47:00 <alej> right
17:47:07 <Saizan> which is where cabal installs the packages by default
17:47:12 <alej> no i understand that, just didn't think of it
17:47:19 <alej> yeah. also not sure where the haskell platform put everything
17:47:26 <alej> could be in .ghc, never investigated
17:47:36 <alej> something makes me think it's in /Library (i'm on os x)
17:47:40 <alej> but it could be easily found out
17:47:45 <Runar> @djinn (c, (a, b)) -> (c, a)) -> (c, b)
17:47:45 <lambdabot> Cannot parse command
17:47:47 <roconnor> why are Linux kernel developers such asses?
17:47:58 <alej> roconnor surely not all of them
17:48:04 <Saizan> alej: "ghc-pkg list" tells you in which package db each package is
17:48:07 <roconnor> surely
17:48:19 <roconnor> alej: you are probably right
17:48:27 <alej> roconnor: hehe, i know the feeling tho
17:48:33 <roconnor> alej: now I wonder if less than half of them are asses
17:48:46 <alej> roconnor: similar is when you ask a bunch of IT/programmers a question. the response almost always is: "why do you want to do that?"
17:48:47 <Saizan> roconnor: what happened?
17:49:12 <roconnor> Saizan: actually I'm reading comments on /r/programming
17:50:21 <roconnor> alej: IT are pretty bad, but not as bad as the kernel developer mailing list
17:50:41 <kmc> heh proggit
17:50:58 <roconnor> alej: when you ask a question on the kernel dev list the typical response is "you are a shitty programmer"
17:51:12 <roconnor> ... so I'm told
17:51:15 <roconnor> :)
17:51:18 <alej> oof
17:52:05 <Philippa> alej: to be fair, sometimes "why do you want to do that?" is an attempt to understand the whole of someone's problem
17:52:21 <kmc> yeah, it can be a response to an XY problem
17:52:56 <kmc> this is what put me off a lot of channels on Freenode
17:53:11 <kmc> i'd ask a specific question, and they'd say "you're dumb for wanting to do that; there's a simpler way"
17:53:32 <kmc> but i'd be asking because the simpler way is unsuitable for my particular problem
17:53:34 <Philippa> *nod*. You shouldn't assume the other party's dumb until you /fully/ understand their problem
17:53:40 <roconnor> kmc: ... aren't you on freenode right now?
17:53:45 <roconnor> oh
17:53:46 <kmc> yes
17:53:50 <systemfault> Reading Linus's typedef BS? :/
17:53:52 <roconnor> *a lot of channels*
17:53:53 <kmc> but i'm not asking questions in #python or ##c am i ;)
17:53:54 <alej> Philippa: right, but most of the time it's obnoxious
17:53:54 <roconnor> sorry
17:53:57 <roconnor> systemfault: indeed
17:53:57 <kmc> :)
17:54:07 <alej> systemfault: i dont think that e-mail was all BS
17:54:19 <kmc> #haskell is great, and my experience so far in #clojure has been pleasant too
17:54:20 <roconnor> alej: ya, but try the reddit comments
17:54:30 <alej> oh i see
17:54:31 <alej> hehe
17:54:33 <roconnor> kmc: you are also welcome in nixos
17:54:36 <roconnor> #nixos
17:54:39 <alej> not linus, but the discussion that followed?
17:54:43 <kmc> cool, i've been thinking of trying NixOS
17:54:43 <Philippa> alej: sure. To be fair, most of the time it's /done obnoxiously/ too. I do it, but I try not to be...
17:55:02 <alej> Philippa: I'm sure those obnoxious people aren't haskellers :)
17:55:16 <systemfault> alej: It not really the email itself or Linus's opinion that bothers me... it's more the fact that because _that_guy_ said it, some people are going to say that it's true without any criticism
17:55:52 <systemfault> Linus has always been an asshole, it's nothing new. 
17:55:59 <kmc> i like ##electronics; they've answered some questions for me, and every time i peek my head in, there's some kind of mad science going on
17:57:29 <Philippa> systemfault: butbutbut geekdom is a meritocracy! We need no social skills here!
17:57:58 <systemfault> Haha :)
17:58:05 <kmc> people with social skills are useless suits, am i rite
17:58:21 <ninly> not the suits i know
17:58:25 <systemfault> All you need is haskell + porn.
17:58:54 <Philippa> ninly: *nod*, schmoozing with other suits isn't the same as social skills...
17:58:55 <djahandarie> Or alternatively, haskell porn.
17:59:01 <kmc> hackers are better than normal programmers and are just better as people generally.  a hacker is defined as anyone who agrees with ESR
17:59:21 <djahandarie> He was in here awhile back
17:59:25 <kmc> hahaha
17:59:32 <dolio> ddarius: Did you see Higher-order Representations of Substructural Logics?
17:59:39 <kmc> back when he wrote his "Haskell is pretty cool, but I don't understand it, so Lisp is better" article?
17:59:52 <djahandarie> Yep, though I don't think he said Lisp is better really
18:00:03 <djahandarie> He just seemed to say "Haskell is cool, that is all."
18:00:05 <kmc> well he got a bunch of stuff about Haskell wrong
18:00:32 <systemfault> Anyway.. for me, LISP will never be more than a toy.
18:00:40 <djahandarie> Same here
18:00:49 <djahandarie> Until I'm forced to use it for my AI course somewhere down the line
18:01:08 <systemfault> Haskell is where the cool stuff is :P
18:01:31 <ninly> the cool kids ;)
18:01:45 <djahandarie> There isn't much being done on the AI front for Haskell though
18:01:50 <ninly> by which i mean the ones with merit
18:02:12 <kmc> i really wish Haskell had metaprogramming features as slick as the Lisp family has
18:02:36 <kmc> i think Clojure has the potential to be much more than a toy
18:02:47 <ville> *krhm* C+ template metaprogrammin *krhm*
18:02:49 <kmc> and it's philosophically close to Haskell, though technically quite different
18:03:01 <systemfault> kmc: We'll see, imho Scala has more chance to become more than a toy.
18:03:17 <systemfault> (As an alternative JVM language)
18:03:17 <roconnor> kmc: do you need dependent types to do metaprogramming?
18:03:31 <kmc> roconnor, it depends on when you want your checking
18:03:42 <roconnor> kmc: compile time
18:03:45 <kmc> i'm fine with TH's staging; in fact, i wish it were looser
18:03:59 <kmc> define "compile time"; TH splices are evaluated and the output type checked at compile time
18:04:10 <kmc> but there's no checking that the splice will produce correct code before its compile-time execution
18:04:12 <kmc> MetaML does that
18:04:17 <kmc> but also has a loophole out
18:04:20 <djahandarie> I haven't really done much of anything with TH
18:04:27 <djahandarie> I pretty much avoid it
18:04:27 <kmc> which you need to implement a lot of the useful metaprograms
18:04:31 <kmc> unless you have dependent types
18:04:33 <kmc> yes, TH is a mess
18:04:45 <kmc> it would be nice if GHC actually implemented all the stuff in the paper
18:05:00 <kmc> i'm kicking around at least two ideas for improved Haskell metaprogramming
18:05:06 <kmc> neither of which looks like TH
18:05:25 * djahandarie kicks kmc
18:06:13 <Mathnerd314> TH is a mess? O_O then how can I claim Haskell is better than Lisp?
18:06:23 <kmc> haha
18:06:27 <kmc> clearly languages exist in a total order
18:06:32 <kmc> and Haskell is the best
18:08:23 <dolio> Not the best. Just better than Lisp. :)
18:09:30 <Mathnerd314> but all these Lisp people have been saying macros beat Haskell, and I've been saying TH >= macros...
18:10:49 <Saizan> have you tried TH at least?
18:10:51 <Philippa> I'd still like a lighterweight way to add new binding constructs to the lang myself, but I'm awfully lazy about these things
18:11:02 <blackdog> Mathnerd314: again with the total ordering
18:11:39 <Mathnerd314> Saizan: I read a couple tutorials and wrote a toy function...
18:12:34 <Mathnerd314> blackdog: language features are totally ordered
18:12:50 <dolio> Using higher-order constructs instead of binders tends to not be too bad in Haskell, in my experience.
18:13:32 <kmc> i have sometimes used RecordWildCards to introduce new binding forms
18:14:13 <dolio> Due in part to the syntax that lispers like to brag about "not having".
18:14:21 <kmc> yeah, that's such a lie
18:14:24 <kmc> that lisp has no syntax
18:14:55 <kmc> do i write (defun f (x y) …) or do i write (define (f x y) …)
18:15:02 <blackdog> kmc: been working my way through On Lisp and have been a bit shocked at that, actually. quotes and sharps everywhere
18:15:24 <dolio> It's not just that.
18:15:32 <blackdog> not even gonna get started on the artificial split between functions and concrete values
18:15:32 <kmc> every special form is syntax, and arguably every macro
18:15:50 <blackdog> (although that's CL, not Scheme etc)
18:15:52 <kmc> blackdog, yeah, i read On Lisp and it pretty well turned me off of Common Lisp
18:15:54 <ezyang> Blagh 
18:15:57 <kyagrd> What's the widely used library that has a forget operation overloaded for forgetful monads (monad that can be converted to Identity monad by throwing away some information such as State s a -> Identity a)?
18:16:04 <kmc> Scheme and Clojure are both a lot nicer in that way
18:16:19 <ezyang> I can't prove (using sequent calculus) that (\forall x\ A[x]) \to B \equiv \exists x\ (A[x] \to B). 
18:16:40 <kyagrd> Or do people write their own forget operation now?
18:17:18 <kmc> (∀x. A[x]) → B   ≡   ∃x. (A[x] → B)
18:17:20 <kmc> like so?
18:17:27 <ezyang> Yeah. 
18:17:59 <ezyang> I've been trying for the better part of an hour, but I keep ending up with contradictions on the left side of the turnstile 
18:18:42 <ezyang> (fwiw, I've been trying to prove a weaker result, that is, the lhs implies the rhs) 
18:18:57 * kmc fires up coqide
18:19:03 <Saizan> "rhs -> lhs" should be easy
18:19:15 <Saizan> lhs -> rhs requires exluded middle
18:19:19 <dolio> ezyang: Classical or intuitionistic logic?
18:19:24 <ezyang> Saizan: Huhhh 
18:19:27 <monochrom> one direction requires non-constructiveness. but since you use full sequent calculus, you have it.
18:19:38 <ezyang> That might be why I'm having a hard time :-) 
18:20:10 <Saizan> try "lhs -> Not (Not rhs)"
18:20:34 <ezyang> Oh! 
18:20:46 <roconnor> Saizan: it likely also requires that forall x, ~~A[x] -> A[x]
18:20:54 <ezyang> So I guess this implies that we can't simulate forall. with exists. in an intuitionistic language like Haskell. 
18:21:24 <dolio> blackdog: The "no syntax" that people talk about with lisp is superficial. It's because they write down concrete parse trees instead of having them produced by rules for a character string (more or less).
18:22:10 <kmc> yes
18:22:19 <kmc> there are still arbitrary decisions about how nested lists of atoms become programs
18:22:29 <kmc> if you write (let (x 3 y 4) …) in drscheme
18:22:31 <dolio> But there's still the step from concrete parse trees to abstract syntax trees.
18:22:32 <kmc> it says "syntax error"
18:22:48 <kmc> sometimes people try to argue that these are semantics
18:23:07 <dolio> And the latter correspond to (rather ad-hoc) shapes in the former.
18:23:14 <kmc> but i think that's silly; there's a bijection between CL and Scheme "define" syntax, or Scheme and Clojure "let" syntax, and it's realizable at compile time
18:23:31 <dolio> So instead of writing the correct character string, you have to write down the correct shape of tree, or else it's a syntax error.
18:23:39 <Philippa> dolio: FWIW, I still end up wanting things like applicative do where the version with lambdas looks and reads a bit fugly
18:24:02 <dolio> Philippa: Ah, yes, that's true.
18:24:06 <roconnor> wake me up when lisp has nominal s-expressions 
18:24:27 <Philippa> or wanting to do pattern-matching with something other than the standard semantics
18:24:28 <dolio> I should bug Conor McBride to implement that in SHE some more.
18:24:29 <Saizan> nominal s-expressions?
18:24:39 <roconnor> heck what am I saying,  Lisp doesn't even do it's own binders properly
18:25:00 <roconnor> Saizan: Fresh-lisp ... s-expressions with binders
18:25:16 <roconnor> you can't write a langauge without binders
18:26:40 <Saizan> so lispers should say "we have a very regular lexical syntax"
18:27:12 <kmc> but that wouldn't be nearly as good as propaganda
18:34:59 <monochrom> http://hpaste.org/40584/x_ax__b__x_ax__b
18:35:20 <monochrom> sequent proof of (∀x. A[x]) → B ⊢ (∃x. A[x] → B)
18:37:18 <ezyang> monochrom: Wait, you're allowed to float free variables like that? 
18:37:42 <kmc> i'm trying to work it out in Coq
18:37:47 <kmc> (with some classical axiom, presumably)
18:37:59 <monochrom> where? what?  when I use "∀ on the right"? that is required
18:38:16 <ezyang> I've been attempting to prove it w/o introducing a free variable... 
18:38:21 <ezyang> mumble Skolem variable mumble? 
18:38:55 <monochrom> proving ∀ on the right absolutely requires stripping the ∀ and introducing a fresh free variable. the key is it's fresh.
18:38:57 * hackagebot fix-symbols-gitit 0.0.1 -   http://hackage.haskell.org/package/fix-symbols-gitit-0.0.1 (ConalElliott)
18:39:19 <monochrom> it is indeed called skolem variable in some theorem provers (e.g. PVS)
18:39:21 <ezyang> ok... I need to convince myself this move is kosher. 
18:39:41 <kmc> so you assume the universe over which x ranges is non-empty?
18:39:45 <monochrom> just look at wikipedia. http://en.wikipedia.org/wiki/Sequent_calculus
18:40:08 <ezyang> monochrom: Looking. 
18:40:15 <monochrom> If the universe is empty, there are counterexamples to even (∃x. P(x)→P(x))
18:40:32 <kmc> yes
18:40:38 <kmc> but the antecedent would be true
18:40:58 * hackagebot fix-symbols-gitit 0.0.2 - Gitit plugin: Turn some Haskell symbols into pretty math symbols.  http://hackage.haskell.org/package/fix-symbols-gitit-0.0.2 (ConalElliott)
18:41:00 <kmc> i think i'm pretty good at constructive logic; i'm trying to figure out where i need to apply classical reasoning here
18:42:17 <monochrom> all logic teaching material (all those for untyped first-order logic anyway) I have seen assert non-empty universes.
18:42:24 <ezyang> monochrom: Ok, I think I believe it. 
18:42:56 <ezyang> I was interpreting term = {function, bound variables} 
18:43:04 <Adamant> http://www.paultaylor.eu/stable/Proofs%2BTypes.html
18:43:05 <ezyang> but I guess it's actually {functions, bound variables, free variables} 
18:43:08 <Adamant> interesting book
18:43:18 <Adamant> interesting-looking, anyway.
18:43:28 <ezyang> Ooh, that looks like fun. 
18:43:42 <monochrom> hell, even 50% of typed first-order logic teaching materials assume so too, e.g., the HOL theorem prover asserts "all types are non-empty". if you define user-defined type, it makes you prove non-emptiness first.
18:45:07 <kmc> so, assuming non-empty universe, then either (∀x. A[x]) holds, in which case we have B immediately, and pick any x we like for the ∃
18:45:46 <ezyang> Huh, if I use free variables, I don't seem to need classical logic. That seems not right. 
18:45:56 <kmc> or we have ¬(∀x. A[x])  ⇒  ∃x. ¬A[x]  ⇒  ∃x. (A[x] → False)  ⇒ ∃x. (A[x] → B)
18:46:04 <kmc> is that the right line of reasoning?
18:46:46 * ezyang doesn't know :^) 
18:47:05 <dolio> That looks okay to me.
18:47:27 <monochrom> ezyang: the only place where you can add an extra free variable is when you invoke the ∀R law or the ∃L law. At all other places, you can only use "already known variables" in terms.
18:47:48 <dolio> Although "pick any x you like" is weird, but I guess you probably know at least one object in the domain of discourse.
18:48:44 <ezyang> monochrom: Huh. Why wouldn't ∀L range over the free variables too? 
18:49:04 <ezyang> oh, I can't /add/ free variables. nvm. 
18:49:50 <monochrom> there is a way explicitly list a kind of "environment of known variables" in sequents (and in natural deduction too). at all times, terms must not step outside of that environment. ∀R and ∃L are the only laws that let you enlarge the environment.
18:50:59 <ezyang> monochrom: Ok, studying your proof some more, where is the classical step, again? 
18:51:06 <monochrom> or rather shrink the environment if you read the rules in the wrong direction
18:51:08 <ezyang> is it the implicit non-empty universe step? 
18:51:44 <monochrom> not so much as having "⊢ X,Y" appear somewhere in the proof
18:52:14 <ezyang> Ah, I see. 
18:52:31 <ezyang> Ooh, and my alternate direction proof avoids that. Useful. 
18:52:43 <monochrom> constructive sequent calculus disallows multiple things on the right, and that is quite enough to enforce constructiveness.
18:53:52 <monochrom> which is kind of not nice in that in a classical sequent calculus proof hides non-constructiveness in the commas.
18:54:39 <ezyang> yeah... 
18:55:23 <monochrom> classical natural deduction exposes the exact non-constructive steps you invoke.
18:56:02 <monochrom> to the point it even pinpoints which sub-statement you're proving non-constructively, and all else is constructive
18:57:23 <augur> monochrom: logic! :D
18:57:35 <djahandarie> I should learn this stuff at some point...
18:57:47 <monochrom> "to prove X, try proving (assume ¬A, get ⊥)"  so you see it clearly
18:57:51 <monochrom> err
18:57:52 <augur> djahandarie: which sort, natural deduction?
18:57:57 <monochrom> "to prove X, try proving (assume ¬X, get ⊥)"  so you see it clearly
18:58:05 <djahandarie> augur, just logic in general, don't really know much of it
18:58:11 <augur> ahh
18:58:21 <augur> well, i can maybe help you :D
18:58:59 <djahandarie> If you want :o)
18:59:10 <ezyang> Other direction: http://blog.ezyang.com/img/sequent.png 
18:59:26 <augur> ezyang: now THAT is natural deduction
18:59:37 <djahandarie> ezyang, man, your handwriting is good
18:59:45 <djahandarie> Is that with a tablet?
19:00:00 <ezyang> djahandarie: Yes. 
19:00:09 * djahandarie jealous
19:00:28 <dolio> It's no Dijkstra.
19:00:36 <ezyang> Though, it's not much good if it's wrong :-) 
19:01:42 <monochrom> Dijkstra writes A for ∀ anyway :)
19:02:15 <dolio> He has exquisite handwriting, though.
19:03:51 <dolio> http://www.cs.utexas.edu/users/EWD/ewd10xx/EWD1094.PDF
19:03:56 <djahandarie> Reading it already :P
19:04:00 <djahandarie> The handwriting is nice
19:04:01 <dolio> Look at those Gs and fs.
19:04:03 <djahandarie> Not sure I like the fs
19:04:04 <djahandarie> Yea
19:04:35 <monochrom> 1094 is one of my favourites
19:04:58 <dolio> I got it off your page.
19:05:01 <monochrom> http://www.vex.net/~trebla/homework/pigeonhole.html :)
19:05:05 <monochrom> oh haha
19:06:00 <kmc> ezyang, http://hpaste.org/40585/ezyangs_theorem
19:07:13 <kmc> follows the above reasoning
19:08:25 <ezyang> Sweeet 
19:08:58 <Saizan> except that coq tactics are made to be stepped through rather than read, it seems
19:09:03 <kmc> yup
19:09:07 <kmc> Coq proofs are quite unreadable
19:09:24 <kmc> i'm certainly not implying you could extract a sequent proof without lots of headache :)
19:10:01 <kmc> also i am a coq noob
19:10:29 <djahandarie> #haskell : Getting your homework done 5 different ways, and more probably creatively than your professor could.
19:10:42 <kmc> turn them all in
19:10:46 <djahandarie> ... grammar fail in that
19:10:59 <djahandarie> can sum1 help w/ grammer
19:11:09 <ninly> that's an exquisite grammar fail, tho
19:11:19 <kmc> NE1 KNO PHP I HAVE WEBSIET PROBLEM?!?!?!?
19:11:37 <kmc> @quote ubuntu.freebsd
19:11:37 <lambdabot> NIXDAEMON-COOL says: how to uncompile make into java gcc 3.3 under ubuntu freebsd ??
19:11:49 <djahandarie> Hahaha
19:11:56 <kmc> @quote unhelps
19:11:56 <lambdabot> NIXDAEMON-COOL says: unhelps you are large
19:12:06 <osaunders> Literally 50% of the time I try to install something with cabal, it doesn't work.
19:12:40 <osaunders> This leaves me very dissatisfied.
19:12:43 <wlangstroth> am I the only one for whom cabal works 100% of the time?
19:12:54 <osaunders> I have problems all the time.
19:12:56 <wlangstroth> any more details?
19:13:01 <dolio> Nope. Works every time here, too. :)
19:13:04 <monochrom> cabal works 100% of the time
19:13:31 <osaunders> I barely believe this.
19:13:39 <wlangstroth> and I don't mean in the Ron Burgundy "40% of the time it works all the time" I mean it really does.
19:13:43 <monochrom> but if you extend that to "100% of software works 100% of the time", I am the only one.
19:13:52 <wlangstroth> haha
19:14:08 <wlangstroth> I call shenanigans
19:14:26 <wlangstroth> osaunders: are you on a mac?
19:14:29 <osaunders> Yes.
19:14:32 <kmc> osaunders, can you give us more details?
19:14:41 <Vanadium> cabal works 100% of the time for me, just sometimes it does not do what I want :<
19:14:45 <wlangstroth> what version of GHC, cabal, etc?
19:14:50 <kmc> the main causes of cabal-install failing for me are fixable
19:15:01 <kmc> a) reinstall with profiling enabled, b) install some C lib
19:15:12 <osaunders> Earlier today I had a problem with Quickcheck, some conflict involving having two copies of directory. I tried to fix it but I made it worse so I tried to reinstall Haskell Platform.
19:15:23 <osaunders> I did uninstall and then an install, install failed.
19:15:41 <osaunders> So I did uninstall again and installed an old Haskell platform from macports.
19:16:02 <ezyang> ...wagggh 
19:16:09 <ezyang> I proved the wrong equivalence! :o) 
19:16:12 <wlangstroth> what ezyang said
19:16:13 <osaunders> Now I just updated cabal with cabal install cabal-installer and it tried to install the exectuable to the wrong place and I had to manually link it.
19:16:38 <osaunders> And I'm having problems installing yi.
19:16:42 <darrint> I'm doing some profiling of my program and all the time/alloc is spent in a single top level CAF. What does that mean?
19:16:50 <osaunders> The problems are just endless.
19:17:04 <kmc> it means that all the time/alloc is spent computing the value of that CAF
19:17:07 <kmc> do you know what a CAF is?
19:17:29 <darrint> kmc: kinda. Any way I can determine what part of my program the CAF represents?
19:17:36 <kmc> it doesn't tell you the name?
19:17:37 <osaunders> wlangstroth: GHC 6.10.4, cabal 1.8.0.6
19:17:45 <kmc> did you build with ghc -prof -auto-all -caf-all ?
19:17:57 <wlangstroth> osaunders: sorry, I'm not familiar enough with the macports install
19:17:57 <darrint> kmc: I thought I did just that... Let me try again.
19:17:58 <Saizan> osaunders: if you don't use --global you could've just rm -fr ~/.ghc rather than reinstalling the haskell platform, which actually probably left your user installed packages where they were
19:18:03 <kmc> darrint, -fforce-recomp too
19:18:05 <kmc> to be sure
19:18:14 <monochrom> oh w00t, you want to prove (∃x. A[x]→B) ≡ (∀x.A[x])→B instead? :)
19:18:21 <Saizan> osaunders: i.e. you refreshed the wrong thing
19:18:58 <monochrom> oh darn. (∀x. A[x]→B) ≡ (∃x.A[x])→B
19:19:29 <darrint> kmc: I bet my use of --make caused me to not recompile. Ok. Now I see CAF:go_parseTags is the one.
19:19:30 <osaunders> Saizan: What about the binaries?
19:19:56 <kmc> yeah, arguably --make should stuff the compile flags in .hi files and check them
19:20:09 <wlangstroth> osaunders: pure guess, but are there conflicting Frameworks?
19:20:27 <Saizan> osaunders: i usually just change my $PATH, but you can configure where they are installed and/or linked via ~/.cabal/config
19:21:02 <Saizan> s/via/in/
19:25:12 * hackagebot mtlx 0.1.5 - Monad transformer library with type indexes,  providing 'free' copies.  http://hackage.haskell.org/package/mtlx-0.1.5 (MarkSnyder)
19:29:13 * hackagebot deunicode 0.1 - Get rid of unicode (utf-8) symbols in Haskell sources  http://hackage.haskell.org/package/deunicode-0.1 (BenFranksen)
19:31:06 <Saizan> too bad we don't have an "unicode" package for the inverse 
19:33:20 <ngochai> Hi guys, is there a way to uninstall a cabal package?
19:33:46 <ezyang> Not really, but ghc-pkg hide or unregister will do what you want. 
19:33:50 <blackh> ngochai: The only way is to do ghc-pkg unregister <package_name>
19:33:57 <kmc> hide won't prevent something else from cabal-depending on it
19:34:00 <ngochai> now I have booth leksah-server-0.8.0.6 and leksah-server-0.8.0.8
19:34:01 <kmc> unregister is a good bet
19:34:12 <kmc> it's safe to keep multiple versions around, i think
19:34:18 <ngochai> kmc, ok I'll try that
19:34:33 <kmc> you can unregister, and then go digging and rm the .a files etc
19:35:57 <monochrom> why do people hate unicode
19:36:05 <kmc> cultural imperialism
19:36:11 <monochrom> nevermind. forget that I asked.
19:36:25 <monochrom> I already know the answer:
19:36:29 <monochrom> @quote ray 1970s
19:36:29 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
19:36:33 <kmc> dey tek er jerbs
19:37:32 <blackdog> apparently it's not great for japanese...
19:38:20 <monochrom> I mean the deunicode package. unicode symbols in haskell code is not bad for japanese.
19:39:02 <Jafet> The answer is obvious. 1970s terminals cannot display Unicode.
19:45:21 <ezyang> One last question, then it's bedtime for me. 
19:45:56 <ezyang> Can I assume exists x. A(x) in the non empty universe case? 
19:46:33 <kmc> for arbitrary A?
19:47:16 <ezyang> yeah. 
19:47:19 <ezyang> Doesn't seem quite right. 
19:47:25 <ezyang> (I'm working the other equivalence now) 
19:47:32 <dolio> A(x) = false
19:47:36 <dolio> No.
19:48:14 <ezyang> Ok. I wonder which direction is intuitionistic. 
19:48:28 <kmc> what are you trying to prove now?
19:48:57 <Rotaerk> what kind of man he is !
19:49:02 <ezyang> (exists x. A(x)) -> B entails forall x. (A(x) -> B) 
19:49:28 <ezyang> or maybe the other direction. Whichever one is intuitionistic. 
19:49:36 <dolio> That's currying.
19:50:04 <ezyang> dolio: Oh? 
19:50:15 <roconnor> they are equivalent
19:50:17 <dolio> Both directions are constructively valid.
19:50:31 <ezyang> Oh, that's fascinating. 
19:50:39 <roconnor> it is
19:51:07 <ezyang> So I want to do Left Implication 
19:51:41 <kmc> so it's the quantifiers swapped from the previous thing?
19:51:49 <monochrom> don't do that first. deal with ∀ and → on the right first
19:51:54 <roconnor> ezyang: take x and h:A(x) and pair them together into (x,h) : exists x. A(x)
19:51:55 <ezyang> yup. 
19:51:59 <ezyang> Ok. 
19:52:25 <monochrom> or s/first/last/ if you use the wrong order
19:53:42 <ezyang> I'm still a bit confused about how to apply the right forall and the left exists rule, I guess. 
19:53:45 <kmc> oh, that's much easier
19:53:53 <kmc> eek, hpaste.org down
19:54:01 <kmc> preflex, seen chrisdone
19:54:01 <preflex>  chrisdone was last seen on #haskell 1 day, 6 hours, 32 minutes and 20 seconds ago, saying: I'm so happy that haskell weekly news is back
19:54:42 <Saizan> every incarnation of hpaste seem to have problems with the db
19:54:44 <ezyang> I can introduce free variables in that. 
19:55:02 <djahandarie> Has anyone made a serious Haskell DB?
19:55:05 <ezyang> Wait. I can introduce free variables on the left and right. 
19:55:21 <ezyang> or is it only on the right? Tough to say... 
19:55:57 <ezyang> oh, and if I do that it's trivial 8) 
19:56:14 <monochrom> ∀-right and ∃-left let you and require you to add (remove) free variables
19:56:30 <kmc> http://codepad.org/vr1wO4O3 ezyang
19:57:09 <djahandarie> If databases are the reason shit is breaking, let's make a better one ;)
19:57:14 <monochrom> ∀-right is particularly similar to the type rule for λ-abstraction.  (λ x::Int . True) :: Int→True because...
19:57:54 <monochrom> or a better example (λ x::Int . x) :: Int→Int
19:58:31 <monochrom> notice that x suddenly becomes a free variable by the type rule
19:59:06 <monochrom> compare (∀x. blah) with (λx. blah)
19:59:22 <ezyang> oh hmmm 
19:59:50 <roconnor> djahandarie: a pure haskell DB?
20:00:32 <djahandarie> Yes
20:00:45 <djahandarie> And one with the purpose of actually being a DB, not a nifty little thing
20:04:40 <gwern> some people, when faced with a DB problem, say, I know, I'll write a Serious Database in Haskell...
20:05:15 * djahandarie senses a bad end
20:05:18 <monochrom> a haskell db can be made easily for just hpaste. but uphill battle for public use. people are picky and whiny.
20:07:03 <sipa> what benefit would a pure haskell db provide?
20:07:15 <djahandarie> The same benefit that writing anything in Haskell provides
20:07:19 <JoeyA> not having to convert everything
20:07:35 <JoeyA> Being able to extend the lazy abstraction to disk.
20:07:37 <monochrom> not going through sql parsing is a benefit
20:08:04 <JoeyA> with immutable data structures in a DB, lazy IO can make more sense.
20:08:22 <monochrom> no personal gripe with sql. all parsings are evil.
20:08:59 <sipa> i'd love to discuss this, but it's 5am and i need sleep :)
20:09:33 <djahandarie> What I'd be really interested is complete type-safety with your database
20:09:38 <drhodes> typeclass Databaseable
20:09:55 <djahandarie> Down with -able!
20:10:05 <monochrom> Databasish
20:13:35 <edwardk> gwern: and now they have two problems ;)
20:14:09 <gwern> edwardk: the quote is sufficiently well-known that it serves as a group injoke to leave the conclusion unstated -_-
20:14:24 <edwardk> gwern: =)
20:14:42 <kmc> class Thingable a where thing :: a
20:16:05 <edwardk> kmc: nah, you haven't been using the numeric prelude enough. the class is C.
20:16:19 <roconnor> kmc: Pointed
20:16:22 <kmc> haha
20:16:37 <kmc> but, it would be so great
20:16:41 <kmc> to not have to remember all these names
20:16:55 <edwardk> kmc: there is a data-default that has class Default a where def :: a
20:16:59 <kmc> yeah
20:27:10 <ClaudiusMaximus> has anyone implemented double-double or quad-double arithmetic yet?  i found libqd but it's C++
20:27:27 <roconnor> ClaudiusMaximus: floating or integer?
20:27:31 <ClaudiusMaximus> floating
20:27:32 <kmc> if you implement a double double library for Haskell, please call it animal-style
20:27:34 <kmc> thanks in advance
20:29:33 <ClaudiusMaximus> kmc: i hope that's a muppet show reference..
20:30:16 <kmc> in-n-out burger
20:30:39 <monochrom> aminals
20:31:12 <alej> hehe
20:44:02 <zomg> Man
20:44:11 <zomg> Haskell is such a pain in the ass when you're a noob in it
20:44:27 <zomg> but it makes you feel really smart when you actually figure it out to some degree
20:44:30 <zomg> :D
20:44:34 <blackdog> yep. the whole point is to frontload the pain.
20:44:50 <blackdog> better to have the compiler tell you you're an idiot than your users.
20:45:03 <dibblego> not according to the Scala compiler
20:45:07 <Vanadium> It mostly makes me feel really dumb when it takes me two hours to get some type trickery to compile and then I still have no idea how people actually write useful software in this.
20:45:11 <dibblego> http://harrah.github.com/browse/samples/compiler/scala/tools/nsc/typechecker/ConstantFolder.scala.html#65760
20:45:21 <zomg> I've been trying to sink in the concept of monads, monoids and whatnot for the past few hours
20:45:33 <zomg> I think I forgot half of it already... 
20:45:38 <zomg> =)
20:45:44 <blackdog> dibblego: jeez. that's really bad.
20:46:04 <dibblego> sad, but predictable
20:46:30 <blackdog> by crash - he means an exception, right?
20:46:43 <dibblego> I assume so yes, non-exhaustive pattern match
20:46:55 <dibblego> no wait, the exception
20:46:57 <blackdog> I guess if you're going to do it on an untyped tree, i guess there's not much you can do.
20:47:53 <blackdog> actually, no. i see what he's doing there now. hm. why on earth wouldn't you error out with a message? that's crazy.
20:48:37 <blackdog> if you're in a strict language and you can work out that there's a div by zero in there, you should definitely catch that as early as you can
20:48:44 <zomg> I wonder if it's time for a pause.. I was just chuckling to myself how the pattern match for (_, _) looked sort of like an ascii butt..
20:48:47 <zomg> =)
20:48:59 <djahandarie> Wait until you get to strictness
20:49:06 <wlangstroth> "frontload the pain" - may I quote you?
20:49:21 <sodium70mg> What happens when you get to strictness?
20:49:40 <djahandarie> sodium70mg, you get an even funnier symbol!
20:49:45 <blackdog> wlangstroth: of course
20:50:36 <wlangstroth> excellent. Yeaaagh - is that what Scala looks like? That code looks like assembly
20:51:57 <dibblego> wait until you see Java
20:52:22 <dibblego> though that particular code looks very much like haskell
20:52:44 <wlangstroth> Who hasn't seen Java? Scala looks like Python, Java and ML had rough sex, and nobody knows who the daddy is
20:54:12 <wlangstroth> hmm ... maybe too harsh - I think I'm getting it now.
20:56:00 <wlangstroth> I'd still be partial to Clojure on the JVM
20:56:11 <dibblego> sympathies
20:56:46 <wlangstroth> ... over Scala
20:56:59 <dibblego> deepest
20:57:54 <wlangstroth> I'm sensing a lack of love for lisp
20:58:05 <blackdog> couldn't quite see the point of clojure. another lisp language on the JVM? whatat's the attraction?
20:58:40 <monochrom> you can write useful software without type trickery
20:58:56 <kmc> wlangstroth, i really want to @remember that
20:59:53 <kmc> blackdog, this one is actually a little popular
20:59:58 <kmc> what else does JVM have Lisp-wise
21:00:02 <monochrom> and nobody knows who the mother of Scala is, either.
21:00:04 <kmc> Kawa Scheme?
21:00:07 <blackdog> wlangstroth: just been done before. kawa's been around for donkey's years.
21:00:18 <kmc> Clojure is more purity- and concurrency-focused that any other Lisp i know
21:00:37 <Saizan> is it a pragmatic alternative to haskell?
21:00:49 <Pseudonym> Clojure and Haskell occupy different spaces.
21:00:53 <kmc> Haskell is the pragmatic alternative to Haskell
21:00:54 <wlangstroth> blackdog: yes, but Clojure is developed by fanatics who want to replace Java, so I support them wholeheartedly
21:01:00 <wlangstroth> haha
21:01:24 <kmc> Clojure could be more like Scheme, syntactically, and be just as good
21:01:27 <Pseudonym> If you need to use the Java platform, Clojure and/or Scala would be the tool of choice for someone like me.
21:01:28 <kmc> but it's just not a big deal
21:01:35 <blackdog> kmc: was it your idea to rename Haskell and market it as the pragmatic version?
21:01:39 <kmc> yes blackdog
21:01:49 <Pseudonym> Because, as we keep pointing out, the value of using Java is not the language, it's the platform.
21:02:10 <Pseudonym> Professional Software Engineers(tm) use Java despite the language, not because of it.
21:02:17 <alej> hehe
21:02:19 <wlangstroth> and the value of using the platform is ... wait, what was it again?
21:02:30 <kmc> "All the theoretical beauty of Haskell, combined with practical real-world features like full Unicode support, bidirectional C compatibility, powerful concurrency primitives, and a state-of-the-art optimizing compiler"
21:02:53 <Pseudonym> wlangstroth: More platform independence than most systems, lots of libraries and frameworks, lots of tools.
21:02:57 <alej> what is the name of the practical language
21:03:22 <wlangstroth> Pseudonym: that's C - we're talking about the JVM
21:03:22 <monochrom> kmc wants to say it's haskell and I fully agree :)
21:03:30 <alej> no i mean what's the rename
21:03:36 <blackdog> it's not actually such a silly idea. every time i mention haskell, people have flashpbacks to using Miranda, and not being able to do IO etc
21:03:37 <kmc> Raskell?
21:03:38 <Pseudonym> wlangstroth: I dare you to try to write for Android in C.
21:03:39 <wlangstroth> (hehe)
21:03:41 <kmc> inspired by Racket
21:03:52 <kmc> blackdog, wow, you know people who know Miranda?
21:04:06 <Saizan> yeah, same surprise here
21:04:11 <dibblego> Miranda was taught at a few universities around these ways down under
21:04:11 <blackdog> I was going to call Hubris Raskell, actually. someone namesquatted it firsted
21:04:26 <Pseudonym> And anyone who thinks C is platform independent should spend a week debugging #ifdefs.
21:04:30 <wlangstroth> Pseudonym: would that be so bad? Oh, wait ...
21:04:35 <monochrom> I am glad I do not have flashbacks to Miranda
21:04:37 <Pseudonym> kmc: I named a child "Miranda" after the language.
21:04:41 <blackdog> kmc: yeah, my workmate Justin. 
21:04:42 <kmc> wow
21:04:51 * Pseudonym is only half kidding about that
21:04:55 <kmc> Pseudonym, your child or someone else's?
21:04:56 <shachaf> Pseudonym: *Your* child?
21:05:01 <dibblego> anyone who thinks Java is platform independent should come sit next to myself and 7 others who are reeling from the _22 JDK update 
21:05:01 <Pseudonym> Yes, mine.
21:05:45 <Pseudonym> dibblego: Right, which is why I said "more platform independence".
21:06:01 <dibblego> no qualms from me
21:06:04 <Pseudonym> Write once run anywhere is a lie, but it's a white lie.
21:06:45 <wlangstroth> with C, there are no lies, only the predictable furrowing of the serious brow
21:07:02 <alej> i should take a picture of my furrowing my brow tomorrow
21:07:03 <alej> at work
21:07:08 <alej> my serious brow
21:07:17 <Pseudonym> Indeed.  Nobody kids themselves that C is platform independent.  It's just a more portable assembler.
21:07:37 <Martty> no language is portable
21:08:01 <Pseudonym> Martty: xslt
21:08:07 <wlangstroth> alej: absolutely. If you're writing in C++, doubly so
21:08:21 <Pseudonym> It's more correct to say that no sufficiently general-purpose language is portable.
21:08:29 <alej> alej: ew no i am not writing c++
21:08:32 <alej> woops
21:08:33 <alej> that's me
21:08:46 <Pseudonym> Or, to put it another way, a portable language is not sufficiently general.
21:08:49 <alej> i guess that counts as my daily affirmation
21:08:49 <wlangstroth> alej: it was so horrible a thought that you had to remind yourself
21:09:23 <alej> why you would want to make an OOP language like C...
21:09:27 <alej> "OOP"
21:09:39 <wlangstroth> ask Bjarne
21:09:47 <Pseudonym> In 1984, it made sense.
21:10:09 <Pseudonym> But actually, nobody thinks C++ is an OOP these days.
21:10:13 <wlangstroth> I dunno, I think the guy just has a sense of humour
21:10:13 <sodium70mg> Isn't C++ approximately 25 now?
21:10:15 <Pseudonym> At least nobody who actually uses C++ in anger.
21:10:19 <alej> hehe
21:10:24 <alej> dunno they had smalltalk in 84
21:10:40 <wlangstroth> what? are there people who don't use C++ in anger?
21:10:43 <alej> when is CLOS from?
21:10:47 <alej> nah people love C++
21:10:55 <monochrom> I don't use c++ in anger
21:11:01 <alej> probably because they used to use java
21:11:26 <monochrom> where anger = seriousness
21:11:31 <Pseudonym> I used to have lots of horrible things to say about C++ until I first used it seriously.
21:11:51 <kmc> yes, i hated C++ until i started learning it for real, then i liked it, then when i mostly knew it for real, i hated it again
21:11:53 <kmc> you know why?
21:12:01 <kmc> because C++, like any esolang, is fun to learn but not fun to use
21:12:02 <wlangstroth> do tell
21:12:16 <alej> yeah i didn't like it until i used it for Serious Work
21:12:17 <kmc> once you know C++ well
21:12:19 <alej> err
21:12:21 <alej> other way around
21:12:27 <kmc> you know a bunch of 30-200 line boilerplate tricks for doing trivial things
21:12:38 <kmc> and figuring out how each trick works is kind of intellectually satisfying
21:12:38 <wlangstroth> concurrency in C++ is where I've seen actual anger
21:12:39 <zomg> If I have nested Either's, is there some way to get the first occurence of Left or the last Right out from it? Besides multiple case x of Left ... Right ... 
21:12:46 <Philippa> alej: smalltalk in 1984 on mainstream micros was, er, not exactly good for tasks one might've considered C for. C++ very much had a reason to exist
21:12:55 <monochrom> I liked c++ until I saw sml. I used c++ seriously before and after.
21:13:02 <zomg> Just saw something like that being done with Maybe in LYAH but couldn't quite wrap my brain around that just yet...
21:13:03 <kmc> zomg, join :: Either e (Either e a) → Either e a
21:13:06 <zomg> =)
21:13:11 <kmc> will get Right
21:13:13 <kmc> but subject to a silly constraint on 'e'
21:13:14 <alej> Philippa: seems reasonable
21:13:20 <kmc> :t either
21:13:21 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
21:14:21 <kmc> zomg, you wouldn't need to write "case" multiple times.  just write the function to do one layer, and apply it more than once
21:14:28 <kmc> > join (Left "foo")
21:14:29 <lambdabot>   Left "foo"
21:14:36 <kmc> > join (Right (Left "foo"))
21:14:37 <lambdabot>   Left "foo"
21:14:41 <kmc> > join (Right (Right 7)
21:14:42 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:14:48 <kmc> > join (Right (Right 7))
21:14:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:14:49 <lambdabot>    `Control.Monad.Error.Cla...
21:14:50 <zomg> True
21:14:55 <kmc> > join (Right (Right 7)) :: Int
21:14:56 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:14:56 <lambdabot>         against inferred type ...
21:14:57 <Pseudonym> You have to remember that C still doesn't have a module system.  Objects are modules.  Therefore C++ is an improvement right there.
21:14:58 <kmc> hrm
21:15:15 <zomg> In this case it's Either IOError (Either Failure [Database])
21:15:20 <kmc> yeah, 'join' here is encumbered by some irrelevant crap
21:15:29 <shachaf> > join (Right (Right 7)) :: Either String Int
21:15:30 <lambdabot>   Right 7
21:15:47 <kmc> :t either throw (either (error . show) id)
21:15:48 <lambdabot> Not in scope: `throw'
21:15:53 <Pseudonym> kmc: I wouldn't say that C++ is fun to use.  But I would say that it's useful to use.
21:16:01 <kmc> :t either Control.Exception.throw (either (error . show) id)
21:16:02 <lambdabot> forall a a1 b. (GHC.Exception.Exception a, Show a1) => Either a (Either a1 b) -> b
21:16:04 <monochrom> c++ also added exceptions
21:16:06 <edwardk>  kmc: are you just chatting with zomg, so you can preface every sentence with an expression of bemused surprise?
21:16:13 <kmc> zomg, yes
21:16:17 <kmc> ;)
21:16:34 <wlangstroth> zomg, I was totally waiting for that
21:16:45 <zomg> hehe
21:17:18 <edwardk> was waiting for pumpkin: zomg, its a zomg!
21:17:20 <monochrom> kmc wrote 10 lines without "zomg"
21:17:48 <wlangstroth> monochrom: a paragon of self-restraint
21:18:13 <notnotpumpkin> zomg, it is not not zomg!
21:18:46 <kmc> c++ added exceptions.  now half of all C++ shops have a style document forbidding the use of exceptions
21:19:01 <wlangstroth> kmc ftw
21:19:18 <wlangstroth> so many reasons to prefer coding in Haskell
21:19:18 <edwardk> kmc: mostly because a very large subset of the libraries including everything from google isn't exception safe
21:19:20 <kmc> they tend to perform poorly, and they force you to write most code in this verbose bizarre inverted style known as RAII
21:19:38 <edwardk> RAII is okay, its the containers not being exception-aware that drives me nuts
21:19:44 <kmc> i mean if they had halfway decent first-class functions, even without upward closure, you could replace most uses of RAII with simple "with" functions
21:20:40 <min_> In GHC, hGetContents returns a String; but it's type is Handle -> IO String. When I try to liftM a function onto the result of hGetContents, I get a type error: inferred String, expected IO String. What is going on here?
21:20:48 <kmc> it doesn't return a string
21:20:54 <kmc> i mean you just said it
21:20:54 <Pseudonym> Which containers are not exception-aware?
21:20:58 <kmc> its type is Handle -> IO String
21:20:59 <Pseudonym> Certainly not the STL ones.
21:21:03 <Pseudonym> If they're compliant.
21:21:03 <kmc> it returns an IO String
21:21:12 <edwardk> Pseudonym: many of the ones implemented by third parties
21:21:15 <Pseudonym> Right.
21:21:20 <Pseudonym> Including Qt until quite recently.
21:21:25 <wlangstroth> I don't see what any of this has to do with data parallel haskell
21:21:39 <kmc> min_, what's the type of the function you're trying to liftM
21:21:49 <min_> Is there a reason why lifting a function of type String -> String would return that type of error?
21:21:52 <edwardk> wlangstroth: nothing at all ;)
21:22:00 <min_> (well, that's the type)
21:22:04 <kmc> liftM f (hGetContents hdl)  -- should work
21:22:08 <kmc> if f :: String -> String
21:22:14 <kmc> perhaps you could hpaste more of your code
21:22:30 <wlangstroth> edwardk: can't blame a guy for trying
21:25:29 <min_> well, this is the code. http://hpaste.org/40586/lift    The example (liftM f (hGetContents hdl)) you gave made me realize that lifting into x where x <- f is a type error
21:26:14 <kmc> yes, that would be just "let unRaw = unComment raw"
21:26:32 <kmc> or, "unRaw <- unComment `liftM` hGetContents h"
21:26:59 <wlangstroth> I never worked in Fortran, so data parallel haskell is one of the coolest things ever, as far as I'm concerned
21:27:45 <kmc> :D
21:32:53 * hackagebot CHXHtml 0.1.2 - A W3C compliant (X)HTML generating library  http://hackage.haskell.org/package/CHXHtml-0.1.2 (PaulTalaga)
21:32:55 <wlangstroth> ah! I looked at the Scala code again! My eyes!
21:36:43 <kmc> do the goggles do anything?
21:37:41 <wlangstroth> kmc: the beer goggles?
21:37:51 <min_> (this is late, and thanks for the help, kmc). In GHC, returning hGetContents gives a string (i.e., I can run functions of type String -> ... on them). Is that just a convenience, then?
21:38:15 <kmc> i don't know what you mean by "in GHC"
21:38:19 <kmc> do you mean ghci?
21:38:57 <min_> Yes, I meant in ghci.
21:39:07 <kmc> in ghci when you do "x <- getChar"
21:39:18 <kmc> it's the same as doing "x <- getChar" in an IO do-block
21:39:22 <kmc> after that, x :: String
21:40:23 <min_> wait, so ghci is a gigantic io monad?
21:40:59 <kmc> yeah
21:41:04 <kmc> though your terminology is off
21:41:27 <kmc> if "Foo is a monad" then "Foo" is a type
21:41:28 <Pseudonym> So what ever happened to SISAL?
21:41:50 <kmc> a value of type (IO T) might be called an "IO action" or (my slightly more evocative name) "IO recipe"
21:42:04 <kmc> ghci does a few things that a vanilla "do" block won't, though
21:42:39 <kmc> if you type some x of type (IO T), where T is an instance of Show, it executes:  x >>= print
21:42:45 <kmc> if T is not an instance of Show, it just executes x
21:43:10 <kmc> and if you type some x whose type isn't built with IO, it executes:   print x
21:43:30 <kmc> (oh, the exception is that T = () doesn't count for the first rule)
21:45:14 <alej> um wow…i've been using haskell for quite a while
21:45:21 <alej> but for some reason was unaware of the print function
21:45:30 <Pseudonym> Perhaps because you didn't need it?
21:45:33 <alej> i guess so
21:45:38 <alej> i only use putStrLn for debugging
21:45:39 <monochrom> I use exceptions liberally in my IO code. Pure code is automatically exception-safe; I don't add my own async exceptions to pure code.
21:46:06 <min_> That makes sense: ghci executes IO actions and prints their result; executes IO actions for which there is no Show instance; and prints values that are not IO actions.
21:46:10 <Pseudonym> IMO, that's one of the strengths of Haskell: You rarely need a general-purpose "print" operation.
21:46:18 <min_> (among other things).
21:46:34 <alej> also indicative of the fact that my programs haven't done a whole lot, or that i haven't finished many projects
21:46:45 <alej> since you'd think i'd do some output to stdout
21:46:53 <alej> but i always did putStrLn . show
21:47:27 <alej> crap almost 1
21:47:30 <alej> need to go to sleep
21:47:37 <Pseudonym> Night.
21:47:40 <alej> so that i can debug kernel panics tomorrow :(
21:47:42 <alej> nite
21:56:55 <kmc> print = putStrLn . show
21:57:00 <kmc> but he left
21:57:54 <Pseudonym> @src print
21:57:55 <lambdabot> print x = putStrLn (show x)
21:58:05 <Pseudonym> kmc is wrong!
21:58:29 <Pseudonym> Strong equality, I guess.
21:58:41 <kmc> i'm always wrong
21:59:02 <Adamant> because if loving Haskell is wrong, then he doesn't want to be right
21:59:50 <monochrom> hahahahaha
22:01:54 <icedane> Is it possible to suppress certain warnings via pragmas in ghc?
22:02:18 <kmc> yes
22:02:26 <kmc> {-# OPTIONS_GHC -fno-warn-orphans #-}
22:02:31 <kmc> unfortunately, only per-file
22:02:42 <icedane> Thanks!
22:05:38 <dibblego> is there a typical reason why GHC is crashing with undefined reference to a particular library?
22:06:05 <kmc> the typical reason is that you didn't pass --make
22:06:15 <dibblego> haha
22:11:12 <ClaudiusMaximus> @src Complex
22:11:12 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
22:11:33 <ClaudiusMaximus> why that constraint?  do not want
22:15:33 <kmc> funny that it's strict
22:15:35 <ClaudiusMaximus> just want to add and multiply some complex numbers, guess i'll do it the dumb way..
22:15:46 <kmc> your numbers aren't in RealFloat?
22:16:13 <ClaudiusMaximus> they could be, but i don't feel like implementing all the methods i'll never need
22:16:14 <edwardk> ClaudiusMaximus: that constraint is annoying as hell, agreed
22:16:22 <kmc> ah
22:16:25 <kmc> custom type, i see
22:16:47 <ClaudiusMaximus> kmc: yeah, this quad-double thing...
22:16:49 <ClaudiusMaximus> (product [1..50], product [1..50]) :: (Integer, QDouble)
22:16:49 <ClaudiusMaximus> (30414093201713378043612608166064768844377641568960512000000000000,QDouble 3.0414093201713376e64 2.467245641759317e48 (-1.286419784669342e32) 2.11106232532992e15)
22:16:54 <edwardk> ClaudiusMaximus: and it doesn't do anything except limit the usability of the built-in complex type, since constraints on data like that have no 'teeth' other than to prevent others from using it
22:16:57 <ClaudiusMaximus> dunno if it is correct yet
22:17:00 <kmc> nice
22:17:22 <Saizan> though RealFloat a => Num (Complex a), no?
22:18:40 <edwardk> saizan: yes, but it even prevents you from using the constructor, etc. i know why (with signum, etc)
22:18:46 <edwardk> but its still annoying
22:19:16 <edwardk> it'd be nice to be able to use the gaussian integers, etc.
22:19:56 <Saizan> i guess it all comes from Num being too large
22:20:05 <edwardk> like many problems in this world ;)
22:20:09 <ClaudiusMaximus> luckily i used a type synonym in the rest of the code, so i should be able to swap it with my own Complex type
22:20:56 <edwardk> mostly complex annoys me because i can't make complex AD variables with complex derivatives
22:21:25 <edwardk> at least not for all such functions
22:22:47 <edwardk> (e.g. for holomorphic functions)
22:24:06 <kmc> i'm feeling quite holomorphic today
22:24:57 <dibblego> has anyone written a combinator library on top of Text.JSON?
22:25:13 <kmc> combinators for what?
22:25:23 <kmc> i wrote a little lib for traversing JSONb
22:25:26 <kmc> http://hackage.haskell.org/package/jspath
22:25:28 <kmc> there's a few others like it
22:31:10 <dibblego> things like JSValue -> Maybe JSString
22:31:18 <dibblego> instead of having to pattern match
22:31:35 <dibblego> or perhaps JSValue -> (JSString -> a) -> a -> a
22:33:19 <Saizan> i wrote a few of those on the spot the last time i worked with JSON
22:33:50 <dibblego> ok so it's not just me missing the obvious 
22:33:58 <dibblego> I shall write this library some time very soon
22:34:20 <kmc> jspath does that
22:34:23 <kmc> for JSONb
22:34:28 <Saizan> http://hpaste.org/40588/json_combinators
22:34:29 <kmc> well actually, no
22:34:41 <kmc> maybe i should add that stuff
22:35:20 <dibblego> is Text.JSON yours?
22:35:31 <dibblego> if you don't write it, I will be writing it
22:36:29 <kmc> i did not write Text.JSON
22:36:35 <dibblego> ok
22:36:48 <Saizan> "ReaderT JValue Maybe" would have saved me the double liftM2
22:36:58 <kmc> if you're not using JSONb i probably won't adapt jspath unless you need the rest of its functionality
22:37:47 <dibblego> JSONb?
22:38:05 <dibblego> oh bytestrings
22:40:22 <kmc> bytestrings and tries
22:40:26 <kmc> rather than String and assoc lists
22:41:28 <dibblego> ah interesting
22:41:40 <dibblego> why not construct the trie from the assoc list?
22:41:58 <kmc> *shrug*
22:42:07 <kmc> maybe it doesn't matter
22:42:14 <kmc> maybe the tries are worse for typical json
22:42:24 <kmc> but assoc list seems kind of terrible generally
22:42:28 <dibblego> I mean, it seems like a function you would probably expose 
22:42:35 <kmc> well, you /= me
22:42:39 <kmc> i didn't write JSONb, to be clear
22:46:54 <ClaudiusMaximus> hmm, my QDouble thing actually seems to work - pretty slow though!
22:47:38 <kmc> is it strict and unboxed?
22:48:03 <ClaudiusMaximus> should be, apart from one function
22:48:10 <ClaudiusMaximus> which is kinda crucial
22:48:26 <kmc> i mean the type itself
22:48:44 <ClaudiusMaximus> the renormalisation currently uses lists because the algorithm was written in a mutative imperative style
22:48:56 <ClaudiusMaximus> and i couldn't be bothered to unroll it manually
22:48:59 <kmc> a QDouble is four doubles?
22:49:02 <ClaudiusMaximus> yes
22:49:16 <kmc> is it like data QDouble = QDouble {-# UNPACK #-} !Double {-# UNPACK #-} !Double {-# UNPACK #-} !Double {-# UNPACK #-} !Double
22:49:38 <quicksilver> ezyang: I was just belatedly agreeing with you abotu cmdargs + purity
22:49:40 <ClaudiusMaximus> i didn't put the unpacks in, but i compiled with -funbox-strict-fields - is that not hte same thing?
22:49:42 <kmc> or data QDouble = QDouble Double# Double# Double# Double#
22:49:51 <kmc> ClaudiusMaximus, i think it is.  did you check the Core?
22:50:06 <ClaudiusMaximus> nope!  i've not started profiling yet even
22:50:55 <kmc> ah
22:51:17 <kmc> i recommend optimizing with -fvia-stack-overflow
22:51:22 <ClaudiusMaximus> :)
22:51:43 <ClaudiusMaximus> i basically need to unroll this line:       (b0:b1:b2:b3:_) = (++ [0,0,0,0]) . dropWhile (== 0) . reverse . getRN . foldr step (RN t0 []) $ [t4, t3, t2, t1]
22:51:49 <kmc> urk
22:51:52 <ClaudiusMaximus> which is pretty terrible
22:52:05 <kmc> it's nice and pointless :)
22:52:27 <kmc> you could make the compiler unroll it for you
22:52:31 <kmc> by writing something similar in TH
22:52:36 <kmc> but i suspect the cure is worse than the disease
22:55:29 <edwardk> ClaudiusMaximus: your qdoubles are using the usual chicanery to get ~4x the mantissa bits by chaining with the same range?
22:55:55 <edwardk> ClaudiusMaximus: how are you enforcing the lack of fpu intermediate value expansion?
22:57:20 <ClaudiusMaximus> edwardk: yes to the first question, and i'm not (yet) for the second...
22:57:28 <ClaudiusMaximus> so it's probably going to explode 
22:57:31 <edwardk> ClaudiusMaximus: i have some old quad double (and double double) code lying around in c/c++
22:57:32 <edwardk> yeah
22:57:33 <jamy> hi all
22:57:34 <edwardk> it will
22:57:46 <kmc> hi jamy
22:57:58 <kmc> what are these two tricks?
22:58:39 <edwardk> kmc: oh basically you set up lower doubles to catch the lesser significant bits of the mantissa
22:58:40 <ClaudiusMaximus> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.23.2124&rep=rep1&type=pdf is the paper i followed (it has a typo, e/=0 should be s/=0)
22:59:26 <ClaudiusMaximus> x86 fpu has 80 bits, but i didn't compile with -fexcess-precision (unless it's enabled by -O2)
22:59:47 <ClaudiusMaximus> the algorithm assumes 64bits
23:01:44 <edwardk> ClaudiusMaximus: well you should be able to be paranoid and use -fno-excess-precision, but if you're a library that doesn't make the guarantees for user code and the resulting inlined snippets, 
23:03:40 <ClaudiusMaximus> edwardk: true, but this is just toy code for the moment...
23:03:53 <edwardk> ClaudiusMaximus: fair nuff
23:04:20 <ClaudiusMaximus> edwardk: and i imagine setting FPU flags would get really ugly in the presence of multiple OS threads..
23:04:27 <edwardk> ClaudiusMaximus: it is =/
23:04:42 <kmc> edwardk knows about that...
23:05:04 <kmc> isn't FPU state saved by an OS context switch?
23:05:14 <edwardk> ClaudiusMaximus: i have a library for intervals that got bitten pretty hard by flag woes (even being careful to set them properly within a single context)
23:05:23 <edwardk> kmc: yes, but remember haskell threads hop cpus
23:05:29 <edwardk> they are green threads
23:05:44 <edwardk> so even within an os context switch you can lose your fpu settings
23:06:36 <kmc> mm
23:06:50 <edwardk> the best i could do for tweaking them was to do things like wrap the fpu context i wanted to switch in an ffi wrapper that also did the operation i wanted and then undid the switch
23:07:15 <kmc> and that inhibits a context switch on that capability by being an unsafe ffi call?
23:07:27 <edwardk> but then i ran afoul of the fact that glibc, even though they provide all the machinery for _setting_ the rounding modes, doesn't let almost any interesting function work properly when they are set
23:07:51 <kmc> you mean the various math lib functions?
23:07:55 <edwardk> yeah
23:08:14 <edwardk> e.g. round up then can cos. you get nigh random results
23:08:17 <edwardk> er then call
23:08:30 <edwardk> only works with truncate to zero
23:08:56 <edwardk> drove me nuts
23:09:05 <edwardk> and its a classic drepper wontfix
23:09:10 <kmc> haha
23:09:14 <kmc> use a different libm then?
23:09:29 <kmc> glibc is weird
23:09:34 <edwardk> find me one i can rely on having installed in a way that'll let me use hackage ;)
23:10:02 <kmc> we learned the other day that you can't statically link glibc if you want to call gethostbyname(), getpwent(), or lots of other functions
23:10:12 <edwardk> the usual devil's advocate is to give up and use MPFR, but that doesn't work with haskell
23:10:42 <edwardk> because the hmpfr bindings are busted, and mpfr internally uses allocators in a way that runs afoul of the way ghc rewires gmp
23:10:45 <kmc> edwardk, maybe there's some BSD3 or public-domain libm which you could just bundle
23:10:54 <kmc> mm
23:10:58 <kmc> yeah, ghc uses a patched libgmp doesn't it?
23:11:06 <edwardk> i looked around. i found a couple of things, but nothing easily packaged
23:11:09 <edwardk> well
23:11:11 <edwardk> it doesn't patch it
23:11:20 <edwardk> it uses a common library function to rebind the global allocator
23:11:25 <edwardk> which is fine insofar as it goes
23:11:38 <edwardk> but it means that any 3rd arty library that uses gmp gets busted
23:11:50 <kmc> right
23:12:18 <edwardk> because any local allocations they do get managed by the ghc allocator, which means ghc starts moving the limbs around
23:12:47 <kmc> and gmp is not set up to be used this way?
23:12:53 <kmc> with multiple allocators?
23:12:56 <edwardk> sadly the later versionf of mpfr use local allocation inside almost everything because there are cases they discovered where to get proper rounding mode support they needed more bits than they were getting
23:13:30 <kmc> maybe with some linker tricks you could load two copies of gmp
23:13:34 <edwardk> well, its more the api provided by gmp isn't flexible enough for there to be something that ghc could do better to allow these 3rd party libs to work
23:14:03 <edwardk> hardly portable though
23:14:42 <edwardk> i do wish i hadn't wasted a week or so trompling around in this space before realizing how horrible of a mess it was
23:15:11 <edwardk> i just wanted  some form of floating point number with some precision that i could use with upward and downward rounding
23:15:30 <edwardk> so i could properly support interval arithmetic, and hence, build up taylor models using my ad library
23:16:09 <edwardk> which would let me build a nice ode/pde solver that deals with fuzzy initial conditions without exploding
23:17:06 <edwardk> i've got all the hard bits needed for that licked
23:17:29 <edwardk> or rather all the interesting bits
23:34:06 <bos> whee! http://www.reddit.com/r/haskell/comments/drinz/unicode_text_performance_improvements/
23:34:33 <kmc> nice
23:34:36 <kmc> 853%
23:34:57 <kmc> it seems like there's still a ton of optimization potential in core Haskell stuff
23:35:09 <kmc> like doing worker/wrapper in Data.Map after all these years
23:35:38 <bos> right
23:36:05 <kmc> it's exciting, because GHC Haskell is already one of the fastest HLL implementations around
23:37:21 <kmc> it's actually funny how un-contested the space of AOT-native-compiled HLLs is
23:41:43 <mtnviewmark> bos - that rocks
23:42:19 <jamy> kmc: how are you?
23:42:19 <mtnviewmark> I *just* coded a call to Data.Text.Encoding.encodeUtf8 
23:42:43 <kmc> i'm good
23:42:45 <kmc> how're you?
23:43:43 <jamy> i am normal
23:44:14 <kmc> that's... good?
23:44:50 <jamy> little more :)
23:46:38 <bos> mtnviewmark: well, soon it should be fast! :-)
23:46:51 <mtnviewmark> woot
23:47:16 <mtnviewmark> now if we only had an HTML combintor library that didn't make me cry....
23:48:25 <jamy> mtnviewmark: what you talking about?
23:48:46 <mtnviewmark> oh - I spent some time fighting Text.Html and Text.Xhtml tonight
23:49:21 <kyagrd> Ah, is there any hope that we standardize all those monad and monad transformer class libraries?
23:49:41 <mtnviewmark> for example, the efficient rendering function wraps things in an outer HTML element -- which I didn't want since I needed to supply my own
23:49:51 <kyagrd> I found out what I need was RunM in MonadLib but the library I am using uses mtl :(
23:50:21 <mtnviewmark> and the naming conventions seem a bit random
23:50:22 <jamy> anybody in this room use haskell for web?
23:50:25 <mtnviewmark> ME
23:50:43 <jamy> its hardly?
23:50:43 * mtnviewmark <-- wrote the new XHTML backend for Haddock....
23:50:51 <jamy> *hurdly?
23:52:32 <kyagrd> Maybe write another library like mtl-missing-MonadLib (lol) will fix the problem or should it make worse 
23:52:58 <mtnviewmark> "hurdly"?
23:53:34 <jamy> mtnviewmark: yes. difficult?
23:53:35 <lispy> full of hurdels?
23:53:39 <lispy> hurdles*
23:53:54 <dmwit> kmc: Hm. Ocaml doesn't count as a fast compiled HLL?
23:53:58 <lispy> hurdle-y is how I would spell that FWIW
23:53:59 <kmc> it does
23:54:13 <lispy> Isn't Ocaml slower than Haskell though?
23:54:23 <kmc> it's just shocking to think that Haskell arguably the most mainstream language in this category
23:54:28 <mtnviewmark> well, those libs are tricky... I keep meaning to write a blog post about 'em
23:54:30 <lispy> Lack of purity == fewer transformation opportunities
23:54:39 <kmc> lispy, on the other hand, strictness
23:54:39 <mtnviewmark> suppose I shouldl get off my butt and do it... but I'm lazy
23:54:57 <kmc> i'm also told that the ocaml compiler is not terribly sophisticated
23:55:00 <kmc> but it still does pretty well
23:55:01 <flux> lispy, it depends on how many transformation opportunities the code has in the first place
23:55:07 <lispy> kmc: yeah, I often wonder how a strict RTS would fair for GHC
23:55:16 <flux> in other words, ocaml doesn't realyl optimize. but it has a good code generator.
23:55:18 <dmwit> Ocaml can be quite fast.
23:55:51 <kmc> now, this idea of AOT native-compiled is kind of arbitrary, because JVM and .NET especially are compiled to native code, and arguably a sophisticated JIT is better than an AOT compiler, even for non-managed code
23:55:57 <lispy> STG keeps the lazy overhead pretty damn low, as I understand it
23:56:03 <jamy> mtnviewmark: hello! difficult?
23:56:05 <kmc> lispy, *shrug*
23:56:10 <kmc> i think more strictness ⇒ more unboxing exposed
23:56:14 <dmwit> What does AOT stand for?
23:56:14 <kmc> you see this in Haskell directly, of course
23:56:17 <kmc> ahead-of-time
23:56:23 <kmc> meant as an antonym to JIT
23:56:27 <dmwit> Ah, to contrast JIT.
23:56:29 <dmwit> yeah
23:56:30 <kmc> though of course JIT describes a broad spectrum of technologies
23:56:44 <kmc> some of which are naive and crappy, some of which do things an AOT compiler could never hope to do
23:56:54 <kmc> it reminds me of IA64
23:57:00 <kmc> optimizing ahead of time is just a lot harder
23:57:04 <mtnviewmark> jamy  - it isn't difficult - just "lumpy"  
23:57:16 <kmc> and optimizing at runtime lets you focus on where it's really needed
23:57:23 <kmc> the ultimate in profile-directed optimization ;)
23:57:59 <mtnviewmark> things like    div ! [theclass "gadget-box"]    but    div ! [identifier "nav-bar"]
23:58:08 <mtnviewmark> so, funny exceptional naming
23:58:16 <jamy> and what modules needed to web app?
23:58:35 <mtnviewmark> and the rendering (to string) options are not orthognal
23:58:43 <lispy> kmc: Well, AOT binaries can be reoptimized at run-time too.  You just need a symbolic trace
23:59:18 <lispy> I don't think many people have put effort in to it
23:59:33 <mtnviewmark> jamy: http://www.haskell.org/haskellwiki/Web
23:59:37 <mtnviewmark> there are many options
23:59:38 <lispy> Writing a binary re-optimizer in Haskell would be an interesting project
