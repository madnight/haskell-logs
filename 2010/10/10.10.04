11:54:49 --- topic: '["Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
11:54:49 --- topic: set by copumpkin on [Thu Aug 12 05:05:07 2010]
11:54:49 --- names: list (clog proq comak killown kuribas malorie Jantaro arcatan contextfree1 ulfdoz_ pcapriotti dcoutts__ gamefreak264 wioux ragloublog _unK Codex_ Zephyrus Itkovian _nickel Ziphilt brntbeer brachiel anRch lsthemes Zol dimmy bos twanvl sidek ClaudiusMaximus bohanlon Gracenotes emmanueloga nej|LUNCH hoknamahn MrFahrenheit danvet Twey FunctorSalad eno tehgeekmeister paper_cc joerisamson maxter macron JoeyA fusion5 dsouza amiri vishnix Yacoby Walt Amadiro ybit2 conal)
11:54:49 --- names: list (Philonous Starfire eevar Aune thou arjanb Axman6 Icewing wto anders_ rubendv dcoutts ccasin nomemory ceii_ Shown jutaro jonrafkind stroan chrisdone psychicist_ netcat jonafan shintah| Jafet jsgf nniro babusri c_wraith Mowah Yvemath gwern mrsolo aconbere monochrom RyanT5000 takeda mceier rovar t3eblinder MayDaniel augur olsner zax FireFly sioraiocht dom96 mightybyte gbeshers ologNation freik mwc MigoMipo mattrepl dsdeiz buntfalke `0660 fryguybob ankit9)
11:54:49 --- names: list (kmels roconnor zaphar_home bitrot donri danten sonnym shapr hgolden flazz wuj perspectival basti_ iFire jendap PhilRod Nibble phenom_ jem777 phyrex1an Athas jaspervdj toothbrush jmreardon welterde bo0ts__ MoALTz dmwit frerich3 Blkt Lycurgus Taejo novas0x2a lopex Rutix kniu adnap Palmik edon dancor Nshag qz mortberg kstt gehmehgeh dogmaT perlite lyn ExtraSpice yitz insomniaSalt nasloc__ janbanan siracusa hackagebot pastorn zomg bezik Sisu zakwilson shintah)
11:54:49 --- names: list (vili ddarius Fullma scm pantski klugez dolio TacticalGrace KaneTW cjf sbahra otto_s alexbobP ps-auxw LeoD Mathnerd314 winxordie tredontho Draconx|Laptop mm_freak ksf_ nimred ernst_ Raynes hamishmack Bassetts theorbtwo copumpkin Cobra__ mafs rothwell fihi09 mux And[y] akosch gds bremner` saurik ibt mornfall Rooz shawn jamwt TML identity sajkr Blub\0 alip ToRA Davsebamse arkx go|dfish edwtjo_ tilman majoh mee_ pettter_ skaar_ wjt erk_ encryptio_ srcerer)
11:54:49 --- names: list (cow-orke1 Draconx mun__ tomaw cathper dino- s76 tomh poliquin angstrom Macha snorble Philippa norm2782 BONUS jon_of_arc res99 hrmlgon2 CompanionCube clanehin Counter-Strike tg_ kadoban dual Sunhay The_third_man peterhil araujo KitB_ Ytinasni jedai drbean slabanja bbee enigmus muep Apocalisp Gilly EvanR-work m3ga dobblego pr rraval cozmic_ preflex jlaire Fingerzam pikhq flippo aep Boney_ jmcarthur isionous PepeSilvia alec otulp untwisted islands kermit)
11:54:49 --- names: list (cobra lostman cognominal sophacles joed blalb sid3k agemo_ ville benmachine b4taylor mrh0057 endojelly dleslie Muad_Dibber joeytwiddle smorg birkenfeld mgsloan kmc waterlaz fserb easy4 greap emma eyck knobo tmuki Cale zackham maurer_ ortmage andersk HugoDaniel marienz dayz aluink sipa Valodim ivan dilinger levitation_ dstcruz JHoglund micro nchaimov_ jql CosmicRay xinming_ sshc andrewsw LionMadeOfLions eregon orbitz gyim CodeScreen dMazz Ornedan DrSyzygy)
11:54:49 --- names: list (tensorpudding Maxdamantus electrogeek zygoloid hc stepnem obraun regalia bnonym shutdown_-h_now snr idoru michie1_ helgikrs StoneToad davean steve_himself Igloo Aisling Carneus kaol epokal ray lispy mundkur Vq PsiOmega rajeshsr jmv_ Nereid rdd twn alexsuraci emias rdrake` drakko mjrosenb mauke Saizan luite MrDomino Botje suiside Belgarion0 `0660_ pumpkin jix mun aiko_ jbauman Innominate canvon geekounet Paradox924X felipe_ hvr QtPlatypus thetallguy1)
11:54:49 --- names: list (Colours Zao tessier inr quicksilver faj_ Ke cjay infoe ath reinroux_ aleator OnionKnight opqdonut flux Baughn ehamberg Eelis niko sohum wagle linolium jayne xcvii alios Vorpal kolmodin ikonia Deewiant quuxman yrlnry tafryn pielgrzym delYsid earthy aristid burp lantti Razz HalfWayMan Bleadof palmje Tomas derekwright mikeg tridactyla mapreduce dqd Veinor mercury^ lusory byorgey endeavormac Ferdirand Liskni_si npouillard ace2001ac jre2 boyscared SimonRC)
11:54:49 --- names: list (dcoutts_ malthe Entroacceptor tamiko inimino yahooooo ricky aasmith__ flori jcapper thetallguy Khisanth elliottcable shachaf jml Martty taruti sfvisser McManiaC robinsmidsrod dho m4thrick hyko cyanoacry ziman noj dons qebab firegolfer dobie_gillis baaba mq cYmen guybrush profmakx deavid dreixel mrd xplat duairc d-snp tehgeek Jonno_FTW bss03-AFK Mitar joni6128 Raku^ Samy EvanCarroll koala_man teukka koninkje_away AnAdorableNick int-e ezrakilty ksandstr)
11:54:49 --- names: list (dumael aavogt p_l lucca hiredman gereedy Vanadium lambdabot aempirei ibid davidL djahandarie trez Cthulhon mattam ahihi ixzkn dropdrive duckinator pkrumins newsham gdsx_ Lemmih DustyDingo alexsdutton regulate da-x Gabbie bqf iratsu slaye dfeuer Jaak MasseR osfameron _2x2l shortcircuit sbok svk_ epmf FauxFaux nominolo harlekin tab Jiten thorkilnaur companion_square bremner chitragupt Nanar tromp dixie b52 kosmikus mrshoe_ cncl_ magicman creichen jvogel)
11:54:49 --- names: list (nornagon quaestor_ ido johs bd_ absentia noddy edwinb jpatota dcolish mietek nothingmuch MacCoaster guerrilla samulihs Reisen thoughtpolice mindwarp integral rokoteko benc__ saccade_ ahf Jon Heffalump _br_ impl mvid arw dionoea BrianHV defn adimit saiam SubStack dax_ solidsnack Obfuscate nlogax @ChanServ cynick idnar Vulpyne sproingie deadguys kalven jdsc allbery_b jrockway soeren franksh_ chromakode Stephan202 milli ptrf jlouis Laney jd10 cuba)
11:56:23 <malorie> ah. now I have to "unpack" the tuples, though.
11:56:42 <xplat> well, yes, map snd . filter ((0==) . (`mod` 3) . fst) . zip [1..] works but it doesn't offer as much insight :)
11:57:42 <malorie> xplat: to come up with such a solution seems close to impossible for me, right now ...
11:58:01 <JoeyA> [1,2,3,4,5,6]
11:58:10 <JoeyA> If we're dropping every 3, which ones go?
11:58:11 <xplat> malorie: that was me a couple of months ago
12:00:32 <malorie> JoeyA: 3 and 6
12:01:43 <Ke> for small constant n you can just f (x:y:z:zs) = x:y:(f zs)
12:02:07 <xplat> map snd . filter fst . zip (tail $ cycle $ False : replicate k True)
12:03:29 <xplat> Ke: f (x:y:_:zs) = x:y:(f zs) makes it more obvious what is happening
12:03:40 <Ke> true
12:04:35 <dstcruz> is there a cabal way of removing multiple versions of the same package installed in --user? This seems bad to me: rm -fr .cabal/lib/package-1.2.3; cabal --force unregister package-1.2.3; cabal upgrade <all-broken-packages>
12:05:07 <dcoutts> dstcruz: the rm bit is not necessary, just the ghc-pkg unregister
12:05:27 <malorie> xplat: thanks for your hints, btw
12:05:27 <dcoutts> dstcruz: and don't use upgrade
12:05:47 <dstcruz> dcoutts: what should I use instead of upgrade?
12:05:53 <dcoutts> install
12:06:20 <dstcruz> is there a way to re-install all broken packages? (i.e. the ones broken by the unregister)
12:06:58 <dcoutts> dstcruz: not in the current version, you just have to list the ones you're interested in
12:07:17 <dstcruz> gotcha, thanks
12:07:22 <dcoutts> dstcruz: you only need to mention the top level "interesting" ones of course, since deps get installed automatically
12:07:42 <dcoutts> cabal ignores packages that are broken due to missing deps, so it'll happily reinstall them
12:07:52 <dstcruz> is it normal for cabal install to install more than one version of a package?
12:08:16 <dcoutts> dstcruz: in a single invocation it never does that, in multiple invocations that's possible
12:08:27 <dcoutts> cabal install foo bar /= cabal install foo; cabal install bar
12:09:48 <xplat> malorie: i wish i could remember the really helpful blog post i read about point-free programming
12:11:17 <malorie> xplat: didn't bookmark it?
12:13:58 <dstcruz> is it more correct to say Maybe implements Functor? or to say Maybe is a Functor?
12:14:13 <xplat> malorie: sadly, no.  i only realized the importance in retrospect...
12:15:28 <xplat> Maybe implements Functor (informally); Maybe has a Functor instance (formally); Maybe is a functor (mathically)
12:15:31 <Lycurgus> the tunes problem is not one for #lisp because they have started building them at clozure.com. Is there also a tunes alt here?
12:15:50 <xplat> note the lowercase f in the mathic version
12:16:48 <benmachine> but some things are a mathematical functor but can't have a Functor instance
12:17:30 <mornfall> Like Set.
12:17:43 <xplat> benmachine: but if they have a (correct) Functor instance they are mathematical functors
12:17:45 <mornfall> (Which really sucks, doesn't it.)
12:17:54 <copumpkin> Set isn't a Hask Functor
12:17:59 <copumpkin> it's an OrdHask Functor :P
12:18:29 <xplat> right, Functor instances always go with functors on full Hask
12:18:46 <mornfall> Well, it could even be a EqHask functor, if there was a Eq set. But without Eq, it's not going to fly.
12:18:48 <xplat> not on, say, reflective subcategories of Hask
12:19:56 <xplat> mornfall: technically there isn't even a difference between a set and a bag unless you have Eq
12:20:39 <mornfall> And a bag is a list.
12:20:47 <mornfall> Well, can be implemented as one.
12:21:15 <xplat> although you have to prevent functions that can observe cardinality since they are incoherent without Eq
12:22:16 * dstcruz thinks he must have forgotten his babel fish at home, things went from English to, well...
12:22:41 <xplat> i think that data Set a = a -> Bool works okay with no Eq ...
12:23:07 <benmachine> it does but I don't think operations on it are very efficient
12:23:34 <benmachine> (also, itym type Set a = a -> Bool :P)
12:23:43 <xplat> yeah, they are even slower than set ops with Eq only
12:25:28 <xplat> benmachine: actually i meant newtype Set a = Set { hasMember :: a -> Bool } but yeah
12:27:38 <tomh> anyone here knows where to find more information about the ~ (at type level) operator?
12:29:38 <copumpkin> tomh: it states that two types are equal :P
12:29:45 <copumpkin> Int ~ Int
12:29:55 <tomh> thats all?
12:29:59 <tomh> doesn't do anything else?
12:30:06 <copumpkin> nope
12:30:10 <xplat> it's basically 'delayed unification'
12:30:20 <tomh> I see
12:30:32 <tomh> ah now I see how its usefull :>
12:30:43 <tomh> thanks
12:32:03 <_linuxftw> How do I convert a String to a ByteString?
12:34:33 <siracusa> @hoogle pack
12:34:33 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
12:34:33 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
12:34:33 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
12:35:00 <benmachine> _linuxftw: note that Data.ByteString.Char8.pack will lose information if any character in the string is not ASCII
12:35:06 <benmachine> @hoogle String -> ByteString
12:35:07 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
12:35:07 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
12:35:07 <lambdabot> Prelude read :: Read a => String -> a
12:35:11 <benmachine> hmm
12:35:11 <_linuxftw> that's fine in this case
12:35:23 <siracusa> @hoogle fromString
12:35:23 <lambdabot> Data.String fromString :: IsString a => String -> a
12:35:23 <ksf_> instance (Monad IO, ListLike ll el) => Monad (Iteratee tmsg ll hmsg IO) where
12:35:26 <benmachine> there are ways of encoding strings, anyway
12:35:36 <ksf_> how do I get rid of that UndecidableInstances arising from el?
12:35:58 <benmachine> ksf_: do you really need to? :P
12:36:14 <ksf_> strictly speaking, no.
12:37:00 <ksf_> I was wordering if there's some neat trick to forall the variable.
12:37:26 <benmachine> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/type-class-extensions.html#undecidable-instances <-- there is an example here about why that sort of thing is undecidable, if that helps
12:37:33 <benmachine> the second example
12:38:15 <xplat> BSC.pack seems to work fine for latin1 characters too
12:38:35 <identity> _linuxftw: You might want Data.ByteString.UTF8.fromString 
12:38:40 <identity> oh, already been mentioned
12:38:41 <benmachine> xplat: mm, close enough >_>
12:38:41 <identity> ignore me
12:38:58 <benmachine> identity: Data.String.fromString was mentioned, not sure if it's the same
12:39:12 <_linuxftw> benmachine, I get this error when I use Data.ByteString.Char8 pack: "Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString' against inferred type `B.ByteString'"
12:39:29 <identity> _linuxftw: Lazy bytestring /= ByteString
12:39:40 <identity> (I thin)
12:39:41 <identity> k*
12:39:45 <benmachine> you are correct
12:39:55 <benmachine> 20:34:43 < lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
12:39:57 <identity> Anyway, you want Data.BS.Char8.pack
12:40:00 <benmachine> you want that one
12:40:02 <identity> yeah
12:40:22 <ksf_> well, it's class ListLike full item | full -> item
12:40:32 <_linuxftw> is Data.ByteString the lazy type?
12:40:38 <identity> benmachine: So Char8.pack is just truncating all Chars to a byte? 
12:40:39 <ksf_> ...so el is fully specified anyway, even if I don't mention it.
12:40:45 <benmachine> identity: I believe so
12:40:48 <identity> benmachine: I see
12:40:59 <benmachine> also,     No instance for (IsString ByteString)
12:41:05 * benmachine is vaguely surprised by this
12:41:23 <_linuxftw> Can somebody explain the difference between a lazy and a normal bytestring?
12:41:54 <benmachine> _linuxftw: lazy bytestrings are similar to lists of strict bytestrings
12:42:13 <benmachine> at least in implementation
12:42:18 <_linuxftw> what does that mean in practice?
12:42:19 <ksf_> and strict bytestrings are flat arrays
12:42:24 <benmachine> so you could in theory have infinite lazy bytestrings
12:42:36 <benmachine> a strict bytestring is either not evaluated at all or completely evaluated
12:42:38 <_linuxftw> Ah ok, so they might be slower in some situations then?
12:42:53 <_linuxftw> (the lazy type I mean)
12:42:54 <benmachine> either could be slower I guess
12:42:57 <ksf_> strict ones can definitely gobble up way more memory
12:43:01 <benmachine> depending on what you're doing with them
12:43:33 <ksf_> using lazy ones is usually safe and not too slow, because the chunk sizes are quite big
12:43:50 <ksf_> (think > 512 bytes)
12:44:06 <benmachine> lazy ones come free with lazy IO though, ew :)
12:44:57 <ksf_> well... if listlike would'nt be using fundeps but typefams, my instance would be decidable.
12:46:43 <xplat> it's kind of weird how ByteString iteratees in 'enumerator' have two levels of chunking
12:46:57 <xplat> 3 if you use lazy ByteStrings ... :-7
12:47:28 <xplat> one nice thing about the other iteratee package and its numerous typeclasses is you can collapse that to one level ...
12:47:31 <ksf_> yeah using Chunk [a] is a mistake
12:48:21 <benmachine> ksf_: hmm, the parameter that doesn't appear in the head doesn't appear anywhere else either, so it seems like GHC could be fixed to recognise your instance can't loop
12:48:29 <ksf_> I'm considering using Yield a [Chunk el], though.
12:48:51 <copumpkin> :t quot
12:48:52 <lambdabot> forall a. (Integral a) => a -> a -> a
12:49:29 <ksf_> ...but that's mainly useful for injecting stuff into the stream from inside an iteratee.
12:49:43 <ksf_> making each bind a potential enumerator.
12:55:10 <identity> har har
12:55:20 <identity> I just crashed ghc playing with unsafeCoerce
12:55:23 <gwern> http://hpaste.org/40374/link_munging
12:55:28 <gwern> thoughts besides hlint comments?
12:55:34 <gwern> did I miss some link case?
12:55:39 <mm_freak> identity: you can crash it more easily and without "unsafe" stuff
12:55:51 <identity> mm_freak: yeah?
12:56:00 <mm_freak> > peek nullPtr
12:56:00 <mm_freak> [1]    30926 segmentation fault  ghci
12:56:01 <lambdabot>   Not in scope: `peek'Not in scope: `nullPtr'
12:56:06 <identity> (I just found out about unsafeCoerce.. Kind of anti-haskell that it exists)
12:56:09 <identity> mm_freak: lmao.
12:56:15 <copumpkin> mm_freak: that's in IO though
12:56:38 <identity> Is unsafeCoerce to help people with FFI?
12:56:42 <mm_freak> copumpkin: i wouldn't know how to crash GHCi without IO or unsafe stuff
12:56:56 <gwern> huh. I've never heard of notElem
12:57:05 <ksf_> identity, its full name is thereIsAProofButTheTypeSystemIsTooNarrowToContainItCoerce
12:57:08 <copumpkin> gwern: it's faster than not . elem
12:57:24 <gwern> @src notElem
12:57:24 <lambdabot> notElem x =  all (/= x)
12:57:48 <ksf_> identity, frisby e.g. uses it to safe differently-typed stuff in arrays.
12:57:52 <mm_freak> copumpkin: not necessarily
12:58:00 <identity> ksf_: hmm
12:58:13 <identity> > unsafeCoerce
12:58:14 <lambdabot>   Not in scope: `unsafeCoerce'
12:58:17 <identity> meh
12:58:35 <identity> I thought lambadbot didn't have any IO stuff at all?
12:58:37 <identity> @ peek
12:58:39 <identity> @hoogle peek
12:58:39 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
12:58:39 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
12:58:39 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
12:58:59 <identity> @hoogle nullPtr
12:58:59 <lambdabot> Foreign.Ptr nullPtr :: Ptr a
12:59:00 <mm_freak> identity: it has all the usual IO stuff, but it doesn't run IO actions
12:59:04 <identity> ah.
12:59:07 <mm_freak> > putStrLn "Hello world."
12:59:08 <lambdabot>   <IO ()>
12:59:19 <xplat> > flip [f, g, h] x :: [Expr]
12:59:20 <lambdabot>   [f x,g x,h x]
12:59:35 <benmachine> you can crash stuff easily with the FFI if that counts :P
12:59:51 <benmachine> but I suppose FFI is about as unsafe as unsafePerformIO
12:59:52 <identity> Yeah I assumed you could
12:59:55 <copumpkin> :t Test.IOSpec.Teletype.putStrLn
12:59:56 <lambdabot> forall (f :: * -> *). (IOSpec.Teletype IOSpec.:<: f) => String -> IOSpec.IOSpec f ()
12:59:57 <mm_freak> well, there is one way to crash GHC, but i don't count that as crashing
13:00:05 <mm_freak> > sort [1..]
13:00:08 <benmachine> :t IOSpec.putStrLn
13:00:12 <lambdabot>   mueval: ExitFailure 1
13:00:25 <lambdabot> forall (f :: * -> *). (IOSpec.Teletype IOSpec.:<: f) => String -> IOSpec.IOSpec f ()
13:00:31 <benmachine> mm_freak: won't that eventually run out of memory?
13:00:51 <benmachine> if it runs out of stack then GHC doesn't crash as such
13:00:52 <mm_freak> benmachine: that's the point
13:01:04 <mm_freak> sort [1..] shouldn't stack-overflow
13:01:06 <benmachine> but it probably runs out of heap instead
13:01:10 <benmachine> and thus
13:01:11 <mm_freak> it should heap-overflow
13:01:16 <benmachine> gets oom-killed or something
13:01:36 <mm_freak> or RTS-killed, if you call with suitable options
13:01:37 <identity> Since haskell is magic, OOM = out of mana :P
13:02:40 <xplat> ksf_: actually the full name of the function is eitherThereIsAProofButTheTypeSystemIsTooNarrowToContainItOrThereIsAMistakeButMyBrainIsTooSquishyToRestrainItCoerce
13:03:03 * benmachine squishes xplat's brain
13:05:21 <gwern> whew. so I have an apparently working function which passes hlint and -wall as well
13:05:30 <gwern> it's neat that hlint can rewrite conditionals for ypou
13:12:37 <identity> gwern: brain workshop is yours?
13:12:41 <identity> Or well, did you develop it?
13:13:03 <gwern> identity: 'tis not
13:13:06 <gwern> python, for one thing
13:13:34 <identity> gwern: ah
13:13:38 <gwern> identity: my chief contribution is writing the FAQ, is all
13:13:46 <identity> Alright
13:13:57 <gwern> (not that I'm not very proud of my FAQ, but writing brain workshop is a greater and more useful feat.)
13:16:43 <monoidal> is it OK to "take over" a hackage package if the maintainer doesn't answer after some time?
13:17:38 <monoidal> the package is http://hackage.haskell.org/package/bloxorz and I'd like to submit minor changes allowing it to build with newer libraries
13:18:03 <root__> http://pastebin.com/sas0Ht6V
13:18:20 <NotRoot> why doesn't that match for
13:18:32 <NotRoot> "(1 and 1)" and not for "(1 and (1 or 0))"?
13:18:40 * hackagebot hws 1.1.0.1 - Simple Haskell Web Server  http://hackage.haskell.org/package/hws-1.1.0.1 (SimonMarlow)
13:18:42 <NotRoot> It actually matches nothing correct :(
13:19:15 <NotRoot> Im trying to parse (<digit> <word> (<digit> <word> <digit>))
13:22:55 <firegolfer> and so on
13:24:15 <byorgey> preflex: seen edwardk
13:24:16 <preflex>  edwardk was last seen on #haskell 4 days, 28 minutes and 43 seconds ago, saying: chrisdone: hah. i think that has happened to a lot of us at different points
13:25:51 <byorgey> monoidal: although it seems harmless in this case, I'd say it isn't OK.  It's not clear where to draw the line.
13:25:56 <Kaidelong> could someone tell me how to write an equivalent to the PAUSE program in haskell?
13:25:59 <benmachine> monoidal: yeah, I've done it, but there's no official policy as to how long that time should be; I recommend posting to the mailing list to ask what people think
13:26:05 <Kaidelong> getChar seems to wait for an entire line
13:26:09 <byorgey> I think the new Hackage server implementation will not allow that sort of thing anyway, since package uploads will be authenticated.
13:26:13 <benmachine> I took over a package, after discussion, of someone who's now been missing for more than six months
13:26:22 <Botje> NotRoot: the third case will /never/ be used
13:26:47 <Firegolfer> because the second case matches the digit?
13:26:54 <Botje> yes
13:26:58 <benmachine> monoidal: one alternative guaranteed not to step on any toes is just to upload a new package with a similar name
13:27:00 <Firegolfer> ic.
13:27:05 <benmachine> monoidal: obviously not ideal though
13:27:11 <Firegolfer> how can I workaround that?
13:27:43 <byorgey> @tell edwardk bug in categories package: type of 'uncurry' in CCC class should have a (<=) instead of (<=>)
13:27:43 <lambdabot> Consider it noted.
13:27:50 <Botje> wait, are you notroot? :p
13:27:54 <Firegolfer> yes
13:28:02 <Botje> okay.
13:28:06 <Firegolfer> my nick magically got changed
13:28:18 <Heffalump> benmachine/monoidal: please don't do that! hackage has enough detritus already.
13:28:25 <Botje> but there's still a notroot lurking around? O_o
13:28:32 <xplat> NotRoot: actually none of the cases will finish matching because the third case is the only 'ground' case and it is shadowed by the second case
13:28:47 <Botje> is (1) valid?
13:29:01 <Firegolfer> no
13:29:05 <Firegolfer> unexpected ")"
13:29:06 <Botje> good
13:29:09 <Firegolfer> expecting " "
13:29:12 <Firegolfer> Literal ""
13:29:21 <benmachine> Firegolfer: combine the second and third alternatives
13:29:33 <gwern> dammit, 7 or 8 examples, and my linking function *still* had a bug - it didn't handle self-section links like [foo](#Benfits)
13:29:34 <benmachine> they're exactly the same except for what gets assigned to b
13:29:42 <gwern> truly, testing cannot prove the absence of bugs
13:30:07 <Botje> Firegolfer: you want something like expression = many1 digit <|> (expression ; many1 letter; expression)
13:30:15 <Botje> except with more plumbing inbetween
13:30:22 <Firegolfer> ic.
13:30:28 <Firegolfer> I'll try that
13:34:58 <Kaidelong> reading up on it, there is no cross platform way to implement PAUSE in haskell?
13:35:03 <Kaidelong> or does someone know?
13:36:10 <benmachine> Kaidelong: what's PAUSE?
13:36:18 <Kaidelong> "Press any key to continue..."
13:36:25 <benmachine> oh
13:36:48 <benmachine> on a textual interface?
13:37:06 <Kaidelong> basically waiting for a single key press from the console
13:39:14 <benmachine> Kaidelong: hSetBuffering stdin NoBuffering doesn't help?
13:39:54 <Firegolfer> getChar actually returns on one char
13:40:12 <Firegolfer> (works for me)
13:41:04 <benmachine> Firegolfer: in ghci, buffering is already disabled
13:41:07 <benmachine> if that's how you're testing
13:41:33 <Kaidelong> benmachine: doesn't seem to, at least not in GHCi
13:41:36 <Firegolfer> oh
13:41:46 <Firegolfer> hSetBuffering stdin NoBuffering?
13:41:58 <Nibble> in soviet russie, buffering disable you
13:42:08 <Kaidelong> tried "hSetBuffering stdin NoBuffering >> getChar" and it still waited for me to press enter
13:42:38 <Kaidelong> err well
13:42:42 <Kaidelong> playAgain
13:42:46 <Kaidelong> which is
13:42:50 <Kaidelong> fmap isY getChar
13:42:59 <Kaidelong> and isY just tests if something is 'y' or 'Y'
13:43:19 <benmachine> Kaidelong: I'd advise you to test not-in-GHCi
13:43:36 <Firegolfer> http://pastebin.com/82R9JCbW <- @getChar
13:43:42 <Firegolfer> works in runhaskell
13:43:58 <benmachine> runhaskell basically uses ghci :P
13:44:02 <Firegolfer> and
13:44:08 <Firegolfer> it works with ghc test.hs --make
13:44:18 <Firegolfer> && ./test
13:44:20 <benmachine> yeah works for me too
13:44:40 <benmachine> question is, does it work on windows
13:44:55 <benmachine> I know the code for hSetBuffering accommodates terminals on windows
13:45:18 <benmachine> also every time I try to type hSetBuffering I end up typing hSetBuggering this worries me slightly
13:46:19 <Kaidelong> doing runhaskell makes that work together and breaks other things
13:46:23 <Kaidelong> correctly*
13:47:11 <Kaidelong> stuff starts printing out of order
13:48:27 <Kaidelong> let me try writing pause like that
13:48:46 <benmachine> stuff printing out of order sounds like more buffering woes
13:51:03 <Kaidelong> tried:
13:51:17 <Kaidelong> main = hSetBuffering stdin NoBuffering >> putStrLn "Press any key to continue..." >> getChar >> return ()
13:51:25 <Kaidelong> using runhaskell on it
13:51:29 <Kaidelong> it waits for enter to be pressed
13:54:47 <benmachine> Kaidelong: are you on windows? also, try compiling
13:54:52 <monoidal> i think this might be http://hackage.haskell.org/trac/ghc/ticket/2189
13:55:02 <Twey> benmachine: Eeeevery time.  On QWERTY and Dvorak alike.
13:55:04 * hackagebot smartGroup 0.2.0 - group strings by words in common  http://hackage.haskell.org/package/smartGroup-0.2.0 (SamAnklesaria)
13:56:46 <Kaidelong> so I'd have to do something with conio to get this working on windows then?
13:56:52 <Kaidelong> until the bug is fixed?
14:00:35 <nxn> is it a bug that 'happy' is required to build 'happy'?
14:00:53 <nxn> can't seem to build the platform because of this
14:01:14 <Twey> Obviously, you should just build happy first… :þ
14:01:30 <nxn> Twey: yeah, when I try it fails because it can't find 'happy'
14:01:46 <Twey> nxn: So obviously, you should… :þ
14:01:51 <nxn> :|
14:01:52 <Twey> On a more serious note, doesn't happy come with ghc?
14:02:10 <Twey> Perhaps the Platform would be a good place to start
14:02:31 <nxn> I compiled ghc myself, didsn't seem to come with it
14:02:45 <mauke> what did you use to compile ghc?
14:02:55 <ksf_> byte : nibble :: chunk : ?
14:03:16 <alej> slab
14:03:18 <alej> ...
14:03:21 <ksf_> er no. actually, byte : bit :: chunk : ?
14:03:25 <Twey> slice?
14:03:27 <nxn> erm, I just got http://darcs.haskell.org/download/dist/6.12.3/ghc-6.12.3-src.tar.bz2
14:03:32 <mauke> piece
14:03:33 <Nibble> ksf_: I love getting highlighted when someone mentions "nibble"
14:03:39 <nxn> and followed with ./configure, make, make install
14:03:47 <Twey> There's a guy in one of my other channels called ‘name’
14:03:50 <mauke> nxn: that doesn't work unless you already have ghc
14:03:55 <Twey> And a chap in #lojban called ‘cizra’
14:03:55 <alej> anyone know a good channel to ask compsci related questions?
14:03:59 <mauke> ghc is required to build ghc
14:04:05 <fserb> hey guys. I'm trying to limit some computation to 1s. I've tried to use System.Timeout.timeout but I keep exceeding the actual time limit.
14:04:17 <nxn> heh, this is sort of amusing
14:04:23 <monoidal> Kaidelong: i'm afraid so. maybe it will be fixed in 7.0
14:04:25 <nxn> you're right, I did have ghc when I compiled ghc
14:04:28 <nxn> but then I removed the old one
14:04:35 <nxn> I guess I did that prematurely
14:04:40 <nxn> thanks
14:04:40 <Twey> nxn: Lesson: use the Platform.  :þ
14:05:56 <fserb> It's basic a cpu-bound app, but I can
14:06:05 <fserb> ... but I can't get it to timeout properly...
14:06:23 <donri> <Twey> And a chap in #lojban called ‘cizra’  -- Yea people here will so get that.
14:06:29 <benmachine> fserb: do you exceed the limit by much?
14:06:34 <benmachine> donri: we can hazard a guess :P
14:06:38 <xplat> byte : bit :: chunk : crumb
14:07:10 <Twey> donri: You'd be surprised
14:07:29 <ksf_> Sigma is the right name.
14:07:41 <fserb> benmachine: very much. Just to be sure, I've tried timeout 10, which should go super fast, right? And I still timeout.
14:07:46 <Twey> There actually is a right name?
14:08:04 <Twey> fserb: Heed the warning on timeout
14:08:12 <Twey> (see the Haddock)
14:08:34 <monoidal> fserb: by the way, did you get answer from bloxorz maintainer about GLfloat patch?
14:08:42 <fserb> monoidal, nope.
14:09:15 <fserb> (regarding the time limit, nevermind, it seems to be an unrelated problem)
14:09:57 <benmachine> I got bloxorz to compile once and then it didn't work
14:10:11 <benmachine> I seem to have deleted it though
14:10:12 <benmachine> oh well
14:10:23 <monoidal> benmachine: after compiling, I used "cabal install" and run from ~/.cabal/bin
14:10:38 <monoidal> benmachine: I can send you the fixed version
14:11:14 <identity> woot @ bloxorz in haskell
14:11:26 <Ke> what is this: getLoginName: does not exist (No such file or directory)
14:11:49 <Twey> Missing /etc/passwd?
14:12:08 <Ke> it was like getLoginName was trying to call to some external command instead of getlogin
14:12:09 <benmachine> monoidal: by didn't work I mean, the rotating block had a vague sort of HOM effect that suggested the frame wasn't being cleared properly, or something
14:12:36 <ksf_> Main.head :: (Chunk c, Monad m) => Iteratee tmsg c hmsg m (Sigma c)
14:12:49 <ksf_> I'm still unsure how to do the forward and backward messages.
14:15:26 <monoidal> benmachine: it works rather smoothly on my hardware; do you see the effect on this video? http://www.youtube.com/watch?v=AJQZg3Po-Ag
14:17:23 <Ke> Twey: it's not that, though getlogin returns NULL
14:18:02 <benmachine> monoidal: no
14:18:30 <Ke> Twey: looking at BUGS getlogin seems extra useless
14:18:43 <benmachine> monoidal: when the block moved, it left behind a trail of old images, that got cleared occasionally and unpredictably
14:19:53 <monoidal> benmachine: understood; don't know what could be cause
14:21:05 <benmachine> monoidal: it might just be something to do with my graphics hardware or setup; I've noticed glut apps don't work at all
14:21:42 <benmachine> (even non-haskell ones; freeglut immediately segfaults any time anyone tries to initialise it, iirc)
14:22:24 <JoeyA> Hmm, is bloxorz an original game, or is it a clone?
14:23:12 <byorgey> JoeyA: pretty sure it's a clone
14:23:54 <Botje> everythign is a derivative of pong somehow.
14:24:52 <benmachine> I remember a flash game with an identical premise and similar graphics
14:27:12 <identity> It's a clone
14:27:20 <identity> It's practically identical
14:27:27 <identity> (The flash game looks better on my machine though)
14:27:35 <identity> http://www.miniclip.com/games/bloxorz/en/
14:28:15 <ksf_> why do I need variadic option types for virtually everything I want to do?
14:29:28 <roconnor> ksf_: what do you want to do?
14:30:28 <Cale> .oO(why aren't lists enough?)
14:32:15 <ksf_> roconnor, provide a way for iteratees to send messages back to the enumerator without fixing the message type.
14:33:04 <pumpkin> ksf_: not fixing the * type in haskell is typically done by parametrizing on the type
14:33:09 <Cale> ksf_: As in Typeable/Dynamic?
14:33:10 <pumpkin> doesn't mean you need variants
14:33:45 <Cale> I suppose the main question you'd have to ask is: how is the enumerator supposed to be able to do anything with the messages if it doesn't know what type they have?
14:34:07 <ksf_> well, one enumerator might understand seeks, the other splice commands, the third buffer size changes, and many more I didn't think of just yet.
14:34:21 <pumpkin> so why not just parametrize it on the type of command?
14:34:37 <ksf_> yeah I can typeclass the whole thing
14:34:41 <pumpkin> no, I don't mean that
14:34:51 <pumpkin> I just mean a type parameter :P
14:35:16 <roconnor> it does sound like you need a type parameter
14:35:36 <ksf_> well, an iteratee that can generate splice commands should be able to use an enumerator that can't splice.
14:35:49 <ksf_> I _do_ have a type parameter.
14:35:58 <ksf_> I'm wondering what to put in it.
14:36:30 <pumpkin> what does an enumerator that can't splice look like?
14:36:33 <pumpkin> type-wise?
14:37:03 <roconnor> ksf_: oh maybe you do want type classes
14:37:21 * roconnor thinks
14:37:34 <pumpkin> ksf_: I'd imagine one that can't splice is represented by an enumerator over something like () maybe?
14:37:42 <ksf_> ...a couple of them, each saying "suchandsuch data type can carry an optional message of type foo"
14:37:51 <pumpkin> if so, you can write a function to "promote" one over () to one over an arbitrary type
14:37:52 <roconnor> ya
14:37:54 <pumpkin> since it doesn't do anything
14:38:16 <ksf_> ...which is basically an variadic option type.
14:38:21 <ksf_> encoded manually.
14:38:55 <ksf_> an enumerator that can't splice would just ignore the message. iteratees have to provide a fallback, anyway
14:39:24 <ksf_> (as you can't put back an already read chunk into the kernel and then splice it)
14:39:51 <roconnor> ksf_: with a la carte style injections perhaps
14:40:23 <ksf_> an enumerator that can't seek, however, would need a backtrack buffer to use an iteratee that seeks.
14:40:26 <roconnor> ugh, overlapping instances :(
14:40:42 <pumpkin> I don't see why you'd want to complicate it more than () -> a
14:40:54 <pumpkin> even if it is manually encoding something more complex
14:40:56 <ksf_> there's no way in hell anything like hlist will work without overlapping instances or TypeEq magic, right now.
14:41:08 <pumpkin> it seems like a fairly simple way to deal with it
14:41:21 <FunctorSalad> GADTs and explicit proofs?
14:41:33 <FunctorSalad> only read the last msg ksf_ 
14:42:01 <ksf_> FunctorSalad, go for it.
14:42:09 <ksf_> I've got no idea how you'd do it, but do it.
14:42:37 <FunctorSalad> sorry, didn't think it through, just went "GADTs are teh better than typeclass contortions1111"
14:42:58 <cobra> does the unit type () have an equivalent in math?
14:43:17 <ksf_> it is a quite mathy type.
14:43:21 <ksf_> it's called unit.
14:43:31 <Cale> cobra: A set with one element, or in an arbitrary category, a terminal object.
14:43:40 <FunctorSalad> depends on what you mean by "equivalent" exactly ;)
14:43:45 <Cale> Well, yeah.
14:44:07 <Tomsik> honestly, GADTs seem cool to me, but I haven't seen a real use for them in my code
14:44:10 <FunctorSalad> Cale: "one"? more like the total order on two elements ;)
14:44:17 <pumpkin> Tomsik: really? I use them all the time!
14:44:37 <Cale> Well, yeah, it's really the Sierpinski space with two elements, if you include _|_
14:44:44 <FunctorSalad> ksf_: I don't know HList well enough to say, anyway
14:44:49 <Tomsik> Well, monad transformers are cool and useful, GADTs, I'm not sure
14:45:17 <FunctorSalad> right, that was the name...
14:45:31 <ksf_> "sierpinski space"
14:45:44 <pumpkin> Tomsik: ...
14:45:44 <ksf_> last night I was flying through a 4d fractal.
14:46:02 <Tomsik> what?
14:46:15 <ksf_> the cool thing was that I could actually rotate the 4th axis and see it represented in 3d.
14:46:44 <pumpkin> they serve a completely different purpose, and let you encode much more precise constraints on types of things :)
14:46:55 <pumpkin> so are mostly useful for correctness
14:46:56 <Cale> Tomsik: I've found GADTs to be quite useful for fleshing out the details of a library and experiment with how code will look without having to provide an implementation straight away.
14:47:29 <pumpkin> furthermore, they also let you carry typeclass constraints around on constructors
14:47:32 <pumpkin> which regular ADTs don't
14:47:46 <Cale> experimenting*
14:48:11 <Philippa> pumpkin: that's been implemented now? Cool
14:48:26 <Philippa> (not that I'm all that up-to-date with what's going on these days)
14:48:43 <Tomsik> Maybe just I'm not using that many algebraic datatypes :p
14:48:48 <Tomsik> (Maybe Just, heh heh
14:48:49 <Heffalump> existentials have always done that
14:49:58 <Cale> Heffalump: hmm, are you sure they've always had the ability to discharge class constraints when pattern matching?
14:50:21 <Heffalump> fairly
14:50:33 <Cale> Well, hmm, on the existentially quantified type itself of course.
14:50:37 <Heffalump> they wouldn't be much use if not
14:50:50 <Cale> But on type parameters, I'm less sure.
14:50:55 <Heffalump> oh, I see the distinction. Yeah.
14:51:32 <FunctorSalad> heh, it'd be rather silly if only ctors using existentials could have constraints on the parameters ;)
14:51:53 <FunctorSalad> (isn't it irrelevant?)
14:52:45 <copumpkin> wtf
14:53:07 <FunctorSalad> (containing existentials vs having constraints on parameters, that is)
14:53:08 <copumpkin> parse :: Strict a => Parser a -> String -> IO a
14:53:21 <copumpkin> the underlying parser is pure, but they wrap it in IO o.O
14:53:43 <FunctorSalad> why'd you do such a thing?
14:53:48 <sipa> @hoogle Parser
14:53:49 <lambdabot> module Language.Haskell.Parser
14:53:49 <lambdabot> Text.Parsec.ByteString type Parser = Parsec ByteString ()
14:53:49 <lambdabot> Text.Parsec.String type Parser = Parsec String ()
14:53:59 <ksf_> the typeclass approach has an ugly consequence: each concrete data type that carries any message has to implement stubs for all the message types used somewhere.
14:54:21 * copumpkin still hasn't heard a good counterargument to what he proposed :P
14:54:37 <chrisdone> tada! http://hpaste.org/40375/typesafe_web_links_with_typea
14:54:37 <chrisdone> someone feel like writing fromLink?
14:55:14 <copumpkin> chrisdone: you could write S a lot more in there :)
14:55:22 <copumpkin> toLink :: (Link a) => S a
14:55:23 <copumpkin> :P
14:55:41 <ksf_> something like HasField f adt a => f -> adt -> Maybe a is just way nicer.
14:55:55 <chrisdone> copumpkin: I know, dufus. those are for external api v_v
14:55:57 <copumpkin> I disagree :P
14:56:55 <FunctorSalad> what is a "typesafe weblink"?
14:57:31 <Tomsik> is there any kind of explicit "exists a . a" or is it always just wrapped around "forall a . a"
14:57:42 <chrisdone> a link that is always correct
14:57:50 <copumpkin> Tomsik: only with a wrapper type, sadly :/
14:58:06 <ksf_> Tomsik, uhc knows an exists keyword.
14:58:57 <Tomsik> hmm, I've always wondered what other than GHC compilers/interpreters/whatever they are do, besides existing
14:59:08 <FunctorSalad> is it about getting the addresses right or about somehow linking values of a certain type?
14:59:11 <Tomsik> I mean, GHC seems to be the most advanced one, what do other ones have to offer/
14:59:17 <benmachine> jhc is supposed to be good at whole-program optimisation
15:00:21 <ksf_> the others are there so spj has a source to steal ideas from.
15:00:38 <chrisdone> FunctorSalad: well it's both in one. you can't misspell it, or compile the program with an out of date link, nor can you compile a program with links containing the wrong types. 'cause it's just a record. compare this to generating links with text
15:01:27 <FunctorSalad> chrisdone: you're generating both the linker and the linkee here, I suppose
15:01:39 <FunctorSalad> (otherwise I see no way how it could be possible :))
15:01:49 <chrisdone> toLink and fromLink, yes
15:02:00 <chrisdone> I started on fromLink but haven't finished because it's hard :(
15:03:16 <FunctorSalad> it'd have to have an existential type if I understand what you're doing correctly
15:04:09 <FunctorSalad> your current toLink isn't injective as a function of both type and value btw (Int and Integer's "show" clash)
15:04:59 <FunctorSalad> hmm or do you encode the type too?
15:05:01 <chrisdone> why is that a problem?
15:05:47 <FunctorSalad> for writing fromLink :)
15:05:55 <chrisdone> no I don't, the links are for human beings to use
15:05:59 <FunctorSalad> unless you simply don't care that an Int will end up as Integer
15:06:29 <FunctorSalad> (I mean the (fromLink . toLink) direction)
15:07:07 <chrisdone> fromLink and toLink will never recieve an ambiguous int/integer argument
15:07:19 <chrisdone> 'cause they're called for the fields of a link, which are concrete
15:07:51 <chrisdone> it's only the browse/home/etc *links* which are ambiguous
15:08:14 <FunctorSalad> fromLink should have type String -> (forall a. Data a => a -> r) -> r, rights?
15:08:24 <chrisdone> but that's why fromLink will be String -> Failing a
15:08:39 <chrisdone> no, Data a => String -> Failing a
15:08:40 <FunctorSalad> ah yes, and fail
15:09:21 <chrisdone> the `a' will be inferred from the call's type
15:09:35 <FunctorSalad> I see
15:09:49 <chrisdone> FunctorSalad: existentials could be used for a list of links. or I could pattern match manually. the Web.Routes seems to pattern match manually
15:10:14 <chrisdone> but that kinda sucks when you have 30 functional pages
15:10:21 <FunctorSalad> pattern match manually on what?
15:10:33 <FunctorSalad> don't you have an open-ended universe of Data instances?
15:11:14 <chrisdone> if the page is "browse" then call browsePage :: Browse -> CGI ... with fromLink l >>= browsePage l or some such
15:11:50 <chrisdone> that's how Web.Routes does it but..
15:12:20 <chrisdone> I'd prefer an existential list of [Link link => Page link] which can just do it for me
15:12:28 <chrisdone> that'll work right?
15:15:30 <FunctorSalad> hmm I don't think that's a legal type
15:15:38 <FunctorSalad> :)
15:16:03 <chrisdone> it isn't? the forall link. is implicit, no?
15:16:22 <chrisdone> oh, sorry
15:16:27 <chrisdone> that's impredicative, I guess
15:16:39 <sipa> so you have the type of list of implications that ...
15:16:47 <chrisdone> data PageLink = forall link. PL { unPL :: Page link } etc
15:17:03 <ksf_>    Could not deduce (Record (K style) record2)
15:17:03 <ksf_>       from the context (Style style,
15:17:03 <ksf_>                         Record (K style) record1,
15:17:03 <ksf_>                         Record (K style) record2)
15:17:06 <ksf_> errr... wut?
15:18:37 <FunctorSalad> do you mean [forall link. Link link => Page link] or exists?
15:19:16 <chrisdone> I did but that'd be impredicative, I think. I meant an existential as above with PageLink and then [PageLink]
15:19:55 <FunctorSalad> you can avoid the impredicativity with a newtype
15:20:15 <chrisdone> data/newtype w/e
15:23:38 <chrisdone> anyhoo I'm basically trying to steal from the Text.JSON.Generic
15:24:59 <chrisdone> for fromLink. it's hard to experiment with though because it's feels kinda all or nothing
15:25:20 <chrisdone> you know when sometimes the type system wants you to write the whole implementation of the function before it'll type check?
15:25:48 <FunctorSalad> you mean 'undefined' won't work?
15:26:07 <chrisdone> yeah, that mostly
15:26:36 <FunctorSalad> hmm, I guess it can happen with higher ranks
15:27:00 <chrisdone> yeah
15:27:58 <FunctorSalad> fold or eliminator functions for existential datas are a common case too...
15:28:43 <FunctorSalad> \k (AnyShow x) -> k x :: (a -> r) -> r
15:29:16 <FunctorSalad> err, (forall a. a -> r) -> r
15:29:21 <FunctorSalad> but not sure it even infers that much
15:29:50 <chrisdone> stuff like this: fromConstrM :: (Monad m, Data a) => (forall d. Data d => m d) -> Constr -> m a
15:30:18 <chrisdone> gunfold :: (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
15:30:21 <chrisdone> this type just makes me laugh
15:30:26 <chrisdone> cannot wrap head around
15:30:47 <FunctorSalad> yeah
15:30:53 <chrisdone> :t unfoldr
15:30:54 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
15:30:57 <chrisdone> lets compare
15:31:40 <copumpkin> chrisdone: uniplate has nicer types :)
15:31:46 <chrisdone> and on that bombshell, I'm going to bed
15:31:52 <chrisdone> copumpkin: uniplate, haven't seen that
15:31:57 <FunctorSalad> I usually just c&p the -ddump-deriv output ;)
15:32:05 <FunctorSalad> for gunfold
15:32:13 <FunctorSalad> (and gfoldl)
15:32:31 <FunctorSalad> the *value* for the typical gfoldl is rather simple
15:32:45 <Tomsik> gunfold :: Gun g => (a -> g -> a) -> a -> [g] -> a
15:33:04 <FunctorSalad> gfoldl c z (Foo x1 x2 x3) = z `c` x1 `c` x2 `c` x3 or so
15:34:08 <chrisdone> hmm nice, uniplate has my interest, I'll check it out tomorrow
15:34:11 <FunctorSalad> Tomsik: I read it as gun-fold too :o
15:34:18 <copumpkin> chrisdone: from his blog
15:34:21 <copumpkin> chrisdone: extractLits x = [y | Lit y <- universeBi x]
15:34:25 <copumpkin> will extract all Lits from a type
15:34:30 <copumpkin> it's really nice :)
15:34:35 <chrisdone> a Lit is what?
15:34:42 <copumpkin> just an ADT he defined
15:34:46 <copumpkin> that uniplate will traverse
15:34:54 <copumpkin> and let you pull arbitrary values out of
15:34:55 <chrisdone> ahh
15:35:38 <chrisdone> I can see that being useful for day-to-day programming
15:36:07 <copumpkin> it's also supposedly faster than syb
15:36:18 <chrisdone> like for this http://hpaste.org/40300/constructor_matching
15:36:52 <chrisdone> lol
15:36:52 <chrisdone> ERROR line 1 - Undefined type constructor "Event"
15:36:52 <chrisdone> is there some guy going around hitting Run on every paste hoping something unexpected will happen?
15:37:37 <chrisdone> oh wow
15:37:39 <chrisdone> http://community.haskell.org/~ndm/uniplate/
15:37:52 <chrisdone> that's exactly the use case I had in my paste
15:39:02 <chrisdone> except his example is kinda awesome
15:39:32 * sipa reads
15:40:33 <sipa> that looks indeed awesome
15:40:34 <chrisdone> copumpkin: variables x = [y | Var y <- universe x] is really the same as the example above it?
15:40:56 <copumpkin> yeah
15:41:00 <chrisdone> it looks like the one above will resolve Neg to Var
15:41:04 <chrisdone> how does the variables one do it?
15:41:11 <sipa> how, i links to a blogpost of my advisor :o
15:41:11 <chrisdone> it can't be the same...
15:41:15 <sipa> and i've never read it
15:41:23 <copumpkin> chrisdone: how come?
15:41:25 <chrisdone> unless universe is a class that you implement
15:41:35 <copumpkin> it builds off Data.Data
15:41:45 <chrisdone> copumpkin: but now does it know to add up the x and y in Add?
15:41:54 <copumpkin> it doesn't
15:42:04 <copumpkin> it just makes sure to give you everything in the "tree"
15:42:15 <copumpkin> and your pattern match (guard) makes sure to grab what you want
15:42:21 <copumpkin> the ++ was a result of traversing the tree manually
15:42:45 <chrisdone> ah, good point, I misread it as something else
15:42:54 <chrisdone> that's why I should be going to bed. you keep-me-up-er
15:42:58 <copumpkin> :P
15:43:01 <copumpkin> g'night!
15:43:05 <chrisdone> nightnight
15:46:46 <copumpkin> I love the zip approach to dropping the last N characters of a list
15:54:20 <copumpkin> really? it seems like the opposite is true (about the legal): http://snapplr.com/z2ye
15:54:41 <copumpkin> (at least, without impredicative types)
16:00:41 <ddarius> > let dropLast n xs = map fst (zip xs (drop n xs)) in dropLast 3 ['a'..'z']
16:00:42 <lambdabot>   "abcdefghijklmnopqrstuvw"
16:00:55 <pumpkin> yep, that one :)
16:01:04 <pumpkin> it's so pretty
16:01:28 <ddarius> > map fst . ap zip (drop 3) $  ['a'..'z']
16:01:29 <lambdabot>   "abcdefghijklmnopqrstuvw"
16:02:16 <ddarius> > let dropLast = (map fst .) . ap zip . drop in dropLast 3 ['a'..'z']
16:02:17 <lambdabot>   "abcdefghijklmnopqrstuvw"
16:02:34 <hpc> ew
16:02:48 <hpc> that's some pointless pointfree code
16:03:14 <Twey> dropLast n = zipWith const `ap` drop n
16:03:43 <Twey> dropLast = (ap $ zipWith const) . drop
16:03:54 <Twey> Hm
16:04:10 <Twey> > let dropLast = ap (zipWith const) . drop in dropLast 3 ['a' .. 'z']
16:04:11 <lambdabot>   "abcdefghijklmnopqrstuvw"
16:04:16 <hpc> that's as nice as it gets, i suspect
16:04:20 <Twey> Likely
16:04:45 <hpc> zipWith const is a funny trick
16:04:55 <hpc> :t zipWith
16:04:56 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
16:05:12 <sipa> :t zipWith const
16:05:13 <lambdabot> forall a b. [a] -> [b] -> [a]
16:05:40 <hpc> it truncates [a] to the length of [b] :D
16:05:49 <sipa> nice
16:06:34 <Peaker> > let dropLast n = reverse . drop n . reverse in dropLast 3 "abcdef"
16:06:35 <lambdabot>   "abc"
16:06:35 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
16:06:47 <hpc> that one isn't lazy though
16:07:28 <Peaker> yeah
16:10:17 <Peaker> chrisdone, hey, you there?
16:12:00 <sipa> i think he's asleep
16:16:01 * ksf_ decides against type hacks and is just going to provide some th and default input to generate a suitable sum type and typeclass instances.
16:16:58 <ksf_> ...so the end-user overhead reduces to a th invocation and one or two signatures to fix their code to the generated adt.
16:17:26 <ksf_> while libraries can just provide additional info for the generator
16:54:32 <Maxdamantus> @pl \a b c -> a c (b c)
16:54:32 <lambdabot> ap
16:59:20 <dibblego> prefer [ f . g $ x | f (g x) ] ?
17:00:36 <res> I'd prefer f (g x)
17:00:44 <res> but that's mostly because it's shorter here
17:01:10 <dibblego> and then [ f . g .h $ x | f (g (h x)) ] and so on
17:01:34 <benmachine> there's also the option of f $ g x
17:01:44 <res> for long chains
17:02:07 <res> it might be prettier to just define a funtion in a where, really
17:02:22 <benmachine> I don't see why
17:02:32 <benmachine> as long as you're sensible about it
17:02:50 <res> it's hard to be sensible after a point
17:03:09 <benmachine> it can be
17:03:28 <benmachine> but I don't think there's anything necessarily intrinsically wrong with writing a long chain of compositions if you format it nicely
17:03:28 <res> you don't want to see something like
17:03:50 <res> unlines . lines . intercalate "\n" . lines
17:04:04 <res> (with stuff in between, of course)
17:04:21 <benmachine> umm, why not >_>
17:04:36 <res> wait, let me get an example
17:06:44 <ddarius> Many people format longer chains vertically.
17:07:11 <res> ('[':) . (++ "]") . intercalate "] [" . map (maybePad . show)
17:07:59 <res> although when you're doing '[': and ++"]" in the same chain, something's probably horribly wrong
17:08:23 <ddarius> The solution, more composition.
17:08:53 <benmachine> dlists :o
17:09:15 * ddarius hates the name "difference lists."
17:09:44 <dolio> Because [a] -> [a] is not a difference list?
17:09:49 <dolio> Or just the name in general?
17:09:54 <ddarius> dolio: The former.
17:10:10 <ddarius> It's not even -like- a difference list.
17:10:14 <dolio> Yeah.
17:11:08 <dolio> Difference lists are rather tied to logic programming, are they not?
17:11:18 <dolio> Or something comparable.
17:11:22 <ddarius> dolio: To single assignment variables, yes.
17:15:27 <donri> Is there something simple like timeout x $ readProcessWithExitCode, that kills the process if it times out?
17:16:18 * ddarius moves his dough over the pilot light so hopefully it will wake up faster.
17:21:23 <c_wraith> donri, look at System.Timeout
17:22:26 <donri> c_wraith: That doesn't kill external processes
17:22:48 <c_wraith> donri, oh.  totally missed that it was an external process.  Hmm.
17:24:32 * hackagebot haskell-src-meta 0.2 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.2 (BenMillwood)
17:26:27 <pufuwozu> I'm having trouble understanding the use of `pseq` in parallel programs
17:26:55 <pufuwozu> Why a `par` (b `pseq` (a + b)) instead of a `par` (a + b)?
17:27:06 <donri> pseq forces strict evaluation
17:27:22 <copumpkin> I wouldn't say that
17:27:43 <dolio> It forces a particular order of evaluation.
17:27:53 <dolio> Which is even more than 'strict' can guarantee.
17:28:00 <copumpkin> pufuwozu: your option would evaluate "in parallel" a and (a + b)
17:28:03 <copumpkin> but a + b depends on a
17:28:10 <copumpkin> so can't really happen in parallel
17:28:26 <copumpkin> pufuwozu: what you really want is a and b to be evaluated in parallel, then to return the result
17:29:08 <dibblego> anyone happen to have an example of using Network.HTTP to send a request with basic auth?
17:29:41 <copumpkin> dibblego: hmm, I did it using the Browser the other day
17:30:15 <dibblego> copumpkin, any idea which of the zillion functions?
17:30:35 <copumpkin> well in the Browser, you have a "callback" that provides credentials
17:30:38 <dibblego> I also have to set a couple of headers
17:30:39 <copumpkin> if you want I can give you that code
17:30:45 <dibblego> that'd be handy cheers
17:32:01 <kmc> pufuwozu, (a `par` (a + b)) will make a "spark" to evaluate a.  but there's a good chance that evaluating (a + b) will force evaluating a, before the spark gets converted to a thread
17:32:11 <kmc> in that case the spark "fizzles" and is useless
17:32:32 <pumpkin> dibblego: http://hpaste.org/40377/browser
17:32:35 <kmc> basically whether or not (a `par` (a+b)) has good parallelism would come down to the order in which (+) evaluates its arguments
17:32:36 <pufuwozu> kmc: and that means that a would have to be evaluated in two threads?
17:32:59 <kmc> no, the spark is just dropped
17:33:08 <ddarius> And you get no parallelism.
17:33:27 <kmc> if a spark comes up for conversion, but the thunk it refers to has already started being evaluated, the spark fizzles and does nothing
17:33:42 <pumpkin> poor sparky
17:33:48 <pufuwozu> lol ok
17:33:50 <kmc> so to avoid caring about the evaluation order of (+), we do (a `par` (b `pseq (a+b)))
17:34:05 <kmc> so that (+) doesn't come into play until b is evaluated, by which time hopefully a has made some progress too
17:34:13 <dibblego> pumpkin, ta
17:34:33 <pufuwozu> What if b is very small and a hasn't finished?
17:34:44 <benmachine> yeah I was wondering that
17:34:51 <benmachine> do we just wait for the thread to finish?
17:34:54 <pufuwozu> Won't it still evaluate (a + b)?
17:35:02 <pufuwozu> And cause the a spark to fizzle?
17:35:36 <kmc> it's not about a finishing
17:35:47 <kmc> it's about the spark on 'a' becoming a thread
17:35:56 <ddarius> pufuwozu: A spark fizzles if the expression is already being evaluated when it begins.
17:36:09 <kmc> once it's a thread, the closure for 'a' is "blackholed" and any other thread forcing 'a' will simply wait
17:36:12 <ddarius> If a has already begun, a + b will wait for it to finish.
17:36:32 <dolio> a `par` (a + b) could conceivably work, but it'd rely on the second expression choosing b to be evaluated first, which isn't remotely guaranteed.
17:36:33 <kmc> this doesn't avoid the fact that, if 'a' is much more work than 'b', (a `par` b `pseq` (a+b)) will not have good parallelism
17:36:37 <kmc> there's really no way around that
17:37:04 <kmc> (the way around is to divide at a finer level.  sparks are cheap to encourage this)
17:38:11 <pufuwozu> Wow, I think I finally get it
17:38:18 <kmc> the problem with (a `par` (a+b)) is that (a+b) might cause 'a' to fizzle, even if 'a' and 'b' are roughly equal amounts of work
17:38:23 <kmc> :)
17:38:57 <dibblego> copumpkin, can I not set headers with the browser?
17:38:59 <pufuwozu> Thanks, I'm giving a presentation at Uni on Haskell so this will come in handy ;)
17:39:05 <kmc> cool :D
17:39:44 <pumpkin> dibblego: you may have to use alterBS directly
17:40:02 <pumpkin> oh actually
17:40:04 <pumpkin> you may not be able to
17:40:25 <dibblego> I'm happy to peel off the browser layer, using Network.HTTP
17:41:54 <dibblego> I can't see how to set basic auth information in a Request
17:42:19 <pumpkin> man, what's with the good SMT solvers all being closed-source
17:42:23 <pumpkin> I guess it's that fucking competition
17:45:32 <gwern> SMT?
17:45:36 <gwern> not SAT?
17:46:03 <pumpkin> SMT is more general than SAT
17:46:36 <gwern> ah. maybe it's because SMT solving is very valuable commercially
17:47:11 <gwern> too much temptation
17:49:37 <pumpkin> I guess
17:50:44 <dstcruz> is the location for ICFP 2011 known yet?
17:51:00 <pumpkin> japan I think
17:51:04 <pumpkin> tokyo?
17:53:11 <kmc> what are some commercial applications of SMT solving?
17:53:17 <kmc> hardware verification
17:54:18 <gwern> pumpkin: that doesn't sound like a great location
17:54:38 <gwern> kmc: from edwardk's blog or something, apparently smt solving is applicable to tons of things
17:55:23 <kmc> yeah, i mean, every problem in NP reduces to SAT ;)
17:55:33 <kmc> i'm just wondering what the real-life practical uses are
17:55:47 <kmc> i'd wager there's a lot it would be useful for that it's not actually used for
17:56:08 <pumpkin> traveling salesmen will be happy
17:57:12 <kmc> traveling salesmen should maximize distance
17:57:13 <bremner> or not. Maybe they like long road trips
17:57:17 <kmc> for frequent flier miles
17:58:00 <pumpkin> also, what if I have small bag and found a huge treasure chamber, but the ceiling is moving down slowly
17:58:07 <pumpkin> and I need to decide what's worth taking with me
17:58:18 <kmc> i hate it when that happens to me
17:58:19 <pumpkin> before I get crushed under the ceiling
17:58:26 <pumpkin> then I would want an efficient solver
17:58:50 <bremner> you kids, we never had calculators on our quests
17:59:10 <zygoloid> pumpkin: that sounds like an interesting combination of TSP and 0-1 Knapsack
17:59:56 <pumpkin> mm
18:00:21 <pumpkin> and anyway, yices can advertise "we led to the crushing of fewer adventurers than Z3 did last year!"
18:00:33 <pumpkin> ...even though most of them still got crushed
18:01:00 <kmc> make it an online problem, a dark room and you only have a little torch so you can only look around a bit at a time
18:01:07 <kmc> Z3 reminds me of http://en.wikipedia.org/wiki/Z1_(computer)
18:01:48 <kmc> or for that matter http://en.wikipedia.org/wiki/Z3_(computer)
18:01:53 * ddarius considers using dual continuations in his assembly strtol function.
18:02:47 <pumpkin> ddarius: what are you making?
18:02:56 <pumpkin> apart from a strtol function
18:04:39 <ddarius> pumpkin: That's a good question.
18:05:14 <pumpkin> (and I'm pretty sure the SMT closed-sourceness is due to that fucking competition)
18:05:25 <pumpkin> I've seen three closed-source ones so far
18:06:04 <ddarius> pumpkin: Make your own and make it closed-source.
18:06:12 <pumpkin> I'm considering it!
18:07:10 <res> dammit yi has lots of deps~
18:07:12 <pumpkin> this one has source: http://www.verit-solver.org/veriT-download.php
18:08:15 <gwern> res: as it should
18:09:56 <ddarius> pumpkin: What are you going to use an SMT solver for anyway?
18:10:09 <res> gwern: and I was unprepared!
18:11:23 <pumpkin> ddarius: one application I had in mind was when "exploring" obfuscated binaries during a disassembly, to avoid being confused by fake (impossible) branches that people like to stick places
18:11:48 <pumpkin> since you don't want to disassemble everything, and generally want to try to approximate real control flow in deciding what to disassemble
18:11:48 * hackagebot extemp 0.0.1 - automated printing for extemp speakers  http://hackage.haskell.org/package/extemp-0.0.1 (SamAnklesaria)
18:12:19 <ddarius> pumpkin: Have you looked at BitBlaze?
18:12:39 <res> what does it require glib for?
18:13:02 <pumpkin> ddarius: nope, but it looks interesting
18:14:33 <ddarius> pumpkin: You should look at the Sting subproject.  It isn't directly related to what you wanted, but it's pretty cool.
18:14:39 <pumpkin> probably geared towards x86 still?
18:15:02 <pumpkin> (as all major static analysis projects I've found seem to be)
18:15:33 <kmc> pumpkin, sounds like they have an intermediate language
18:16:04 <kmc> KLEE is another symbolic execution project i've heard of
18:17:23 <res> where do I get gtk2hsC2hs?
18:17:55 <pumpkin> I also have slightly different interests than it seems these projects have
18:18:01 <aavogt> res: there's a package named something like gtk2hs build tools
18:18:02 <pumpkin> but I should read more
18:18:05 <kmc> res, cabal install gtk2hs-buildtools
18:20:30 <kmc> pumpkin, KLEE uses STP to preprocess models including bitvectors and arrays into pure SAT, then uses MiniSAT
18:20:37 <kmc> MiniSAT is open source and i think STP is as well
18:20:44 <pumpkin> yeah, I've come across MiniSAT
18:23:15 <sclv> hey all! looking for experiences with long running haskell server processes. report them here: http://www.reddit.com/r/haskell/comments/dmpa5/real_world_experiences_with_long_running_haskell/
18:26:00 <jmcarthur> i love how dph uses vector now. means i can integrate repa and vector code seamlessly :D
18:27:12 <pumpkin> I wonder if my vector patch made it in
18:27:27 <lispy> ?unmtl ReaderT r a
18:27:27 <lambdabot> err: `ReaderT r a' is not applied to enough arguments, giving `/\A. r -> a A'
18:27:35 <lispy> ?unmtl Reader r a
18:27:35 <lambdabot> r -> a
18:28:00 <pumpkin> yay
18:28:04 <pumpkin> actually maybe it didn't
18:28:32 <lispy> :t join
18:28:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:28:36 <lispy> :t liftM2
18:28:37 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:28:51 <lispy> :t join . liftM2
18:28:52 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => (a2 -> a2 -> r) -> m a2 -> m r
18:28:58 <pumpkin> guess not
18:29:04 <lispy> davidL: does that help?
18:29:50 <pumpkin> :t ((join .) .) . liftM2
18:29:51 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
18:30:51 <identity> Okay, so I have two functions and a list of n items and I need to create a list of all different lists after applying both functions on each element separately.. Eh, as in, fn [(+1), (-1)] [1,2] would create [[2, 2], [1, 3], [0, 2], [1, 1]].. Any ideas?
18:31:12 <lispy> Is there an infix version of join?
18:31:25 <lispy> er wait, I guess that doesn't make sense
18:31:33 <pumpkin> > liftM2 id [(+1), (subtract 1)] [1,2]
18:31:34 <lambdabot>   [2,3,0,1]
18:32:26 <Cale> > (*) `join` 5
18:32:27 <lambdabot>   25
18:32:42 <identity> pumpkin: Hmm
18:32:56 <pumpkin> identity: use replicateM on the function list
18:33:02 <lispy> Cale: yeah, that's why I asked about it, but then I convinced myself that the type doesn't make sense...I guess it does :)
18:33:25 <lispy> :t join (liftM2 (+))
18:33:25 <Cale> Well, it only really makes sense when specialised to function types.
18:33:26 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1
18:33:46 <lispy> :t join . liftM2 $ (+)
18:33:46 <lambdabot> forall a2 (m :: * -> *). (Monad m, Num a2) => m a2 -> m a2
18:35:39 <pumpkin> > (flip (zipWith id) [1,2]) <$> replicateM 2 [(+1), (subtract 1)]
18:35:40 <lambdabot>   [[2,3],[2,1],[0,3],[0,1]]
18:35:52 <identity> pumpkin: Wow, nice.
18:35:54 <pumpkin> doesn't seem to be what you want
18:35:55 <identity> I'll have to grok that
18:35:57 <identity> wait
18:36:00 <pumpkin> or rather, doesn't give the same results
18:36:09 <identity> ah, no
18:36:11 <identity> unfortunately
18:36:18 <identity> I'll take a crack at it though, you've given me some insight
18:36:19 <identity> thanks
18:37:22 <lispy> ?hoogle valFromObj
18:37:22 <lambdabot> No results found
18:37:52 <davidL> @type \f -> join (liftM2 f)
18:37:54 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => (a2 -> a2 -> r) -> m a2 -> m r
18:39:19 <magicman> > let perElem f l = case l of {[] -> []; (x:xs) -> (f x : xs):(map (x:) $ perElem f xs)} in perElem (*2) [1..5]
18:39:20 <lambdabot>   [[2,2,3,4,5],[1,4,3,4,5],[1,2,6,4,5],[1,2,3,8,5],[1,2,3,4,10]]
18:44:56 <identity> magicman: thank yoU!
18:45:51 <ddarius> pumpkin: BitScope, if you didn't look at it, seems closer to your application.
18:46:46 <pumpkin> yeah
19:00:15 <yoavg> Hi, I'm new to haskell (actually I'm just an xmonad user..) but I've got into a wired situation.
19:00:44 <yoavg> I wanted some packages which were in the newest xmonad-contrib
19:01:09 <yoavg> so I got xmonad and xmonad-contrib from darcs, and installed with cabal install --user
19:01:39 <yoavg> and then my previous config stopped working.
19:02:02 <yoavg> apparently, both my current and the newer version are 0.9.1
19:02:18 <yoavg> (but the newer is 0.9.1.4 or something like that, it just does not appear anywhere)
19:02:28 <yoavg> when I run ghci -v, I get
19:02:32 <yoavg> http://pastebin.com/jgD94Qch
19:02:51 <yoavg> this finds some weired circular dependency.
19:03:24 <maurer_> ghc-pkg unregister xmonad-contrib-0.9.1-7f6a27723ca8ab844928662c1691d0ec
19:03:26 <yoavg> the old xmonad is shadowing the new one, and the new contrib is shadowing the old one.
19:03:38 <yoavg> ah. 
19:03:42 <maurer_> Or whichever one is newer
19:03:47 <maurer_> (I don't know based on the hashes :P)
19:03:53 <maurer_> err, whichever is older
19:04:57 <yoavg> I'll try that, thanks!
19:07:49 <yoavg> yoavg@yoavg-laptop:~/.xmonad$ ghc-pkg unregister xmonad-contrib-0.9.1-06edb014e7d72cf36fbb4c0712f58e0f
19:07:49 <yoavg> ghc-pkg: cannot find package xmonad-contrib-0.9.1
19:13:35 <Saizan> yoavg: check what "ghc-pkg list" says
19:13:50 * ddarius thinks his new over rack layout worked better.
19:14:25 <Saizan> maybe the database cache needs to be refreshed? that should be "ghc-pkg recache" iirc, see ghc-pkg --help
19:18:18 <yoavg> ghc-list is looking at /var/lib/ghc-6.12.1
19:18:30 <yoavg> but ghci -v is looking at
19:18:45 <yoavg> /usr/lib/ghc...
19:22:01 <Saizan> ah, i see, it seems you've two installations of ghc that kind of mess with each other
19:22:47 <Saizan> maybe somewhere else you've another ghc-pkg that fits your ghci
19:23:40 <yoavg> any idea how to find it? (I'm using ubuntu lucid)
19:24:33 <Saizan> try "locate ghc-pkg"
19:25:46 <yoavg> it found a few:
19:25:48 <yoavg> yoavg@yoavg-laptop:~/.xmonad$ locate ghc-pkg
19:25:49 <yoavg> /etc/alternatives/ghc-pkg
19:25:49 <yoavg> /etc/alternatives/ghc-pkg.1.gz
19:25:49 <yoavg> /usr/bin/ghc-pkg
19:25:49 <yoavg> /usr/bin/ghc-pkg-6.12.1
19:25:49 <yoavg> /usr/bin/ghc-pkg6
19:25:51 <yoavg> /usr/lib/ghc-6.12.1/bin/ghc-pkg
19:25:53 <yoavg> /usr/lib/ghc-6.12.1/bin/ghc-pkg-6.12.1
19:25:55 <yoavg> /usr/lib/ghc-6.12.1/lib/ghc-pkg
19:25:57 <yoavg> /usr/share/man/man1/ghc-pkg.1.gz
19:25:59 <yoavg> /usr/share/man/man1/ghc-pkg6.1.gz
19:26:10 <yoavg> but they all seem to look at /var/lib and not /usr/lib 
19:27:37 <yoavg> actually, they are all symlinked to the same file..
19:28:16 <Saizan> and your ghci is in /usr/bin too?
19:28:30 <yoavg> yes
19:29:04 <yoavg> got them all automatically with apt (when installing xmonad)
19:29:27 <Saizan> not sure what's happening then
19:29:50 <Saizan> i tend to stick to the generic linux tarball on ghc's website rather than distro packages
19:34:00 <yoavg> thanks anyways..
19:35:30 <Saizan> yoavg: oh, you can use --global-conf= to point ghc-pkg to the right file/directory
19:37:59 <yoavg> Saizan: thanks. but where should I point it to? 
19:39:28 <Saizan> /usr/lib/ghc-6.12.1/package.conf.d/ i think
19:43:28 <yoavg> Saizan: Yes! I think it worked! great. thanks!
20:04:09 <mm_freak> what's the eldoc mode in emacs?  i don't see a difference
20:24:41 <gwern> this mirage paper on LtU is interesting
20:24:49 <gwern> it's like they reinvented exokernels using ocaml
20:26:34 <JoeyA> Has anyone made a Haskell library that implements an insane number of functions and instances for when, say, liftM..liftM5 isn't enough?
20:26:39 <JoeyA> e.g.:
20:26:47 <dibblego> JoeyA, yes, see Control.Applicative
20:26:50 <JoeyA> import Moar.LiftM (liftM 100)
20:27:37 <JoeyA> oh yeah, there's the <$> <*> <*> pattern.
20:28:00 <JoeyA> Or maybe you want an insane number of tuple instances for Data.Binary (e.g. up to 100 items)
20:28:11 <JoeyA> import Moar.Binary
20:28:12 <copumpkin> 62
20:28:15 <kmc> which was recognized before Applicative -- that's why Control.Monad.ap exists
20:28:17 <JoeyA> I wonder if it would be a good idea or not.
20:28:52 <kmc> nobody's actually going to make a 100-tuple
20:29:08 <JoeyA> they might make a 20-tuple
20:29:14 <kmc> i hope not
20:29:22 <kmc> you might make a custom type with 20 or 100 fields
20:29:23 <lucca> large tuples can appear from machine-generated code
20:29:25 <JoeyA> right
20:29:26 <magicman> This tool might generate 100-tuples >_>
20:29:36 <magicman> Argh, ninja'd by lucca XD
20:29:45 <lucca> ^_^
20:29:48 <aavogt> like copumpkin said, there's a limit for flat tuples
20:29:50 <kmc> so i think this is a question of generic programming
20:30:01 <kmc> "how do I make Binary work for arbitrary product types"
20:30:03 <kmc> which is much studied
20:30:07 <magicman> But 62 is the limit? Oy.
20:30:31 <magicman> But yes, that's definitely generic programming stuff.
20:30:51 * magicman must admit to usually THing it >_>
20:31:09 <copumpkin> ew TH
20:31:13 <copumpkin> why not just use a custom type
20:31:29 <copumpkin> I generally barf at anything higher than a 3-tuple
20:31:45 <aavogt> > (,,,) 1 2 3 4
20:31:46 <lambdabot>   (1,2,3,4)
20:31:52 * aavogt waits
20:31:54 * copumpkin barfs
20:34:12 * adu <3 .
20:39:31 * Saizan cleans the channel with a mop
20:39:38 <Saizan> you kids..
20:42:32 <mm_freak> sorry, my connection dropped, but i already figured it out myself, thanks
20:42:43 <mm_freak> eldoc doesn't seem to be haskell-related
20:46:10 <dibblego> how do you set a header on a Network.Browser request?
20:49:51 <adnap> When I run cabal update, it keeps saying there is a new version of cabal no matter how many times I do "cabal install cabal-install".
20:51:08 * ddarius should make a boule of pain a la'ancienne.
20:57:26 <aavogt> adnap: does cabal install install into your $PATH?
20:58:12 <ddarius> gwern: Hmm, I hadn't considered their project.  I might finagle a use out of my completely arbitrary project.
21:04:25 <adnap> aavogt: It installs to .cabal--the default.
21:04:45 <adnap> aavogt: To clarify, that's ~/.cabal.
21:05:06 <aavogt> which cabal
21:05:24 <adnap> aavogt: 0.8.2
21:05:33 <aavogt> no, run that command
21:05:39 <adnap> aavogt: oh
21:05:52 <adnap> aavogt: /usr/bin/cabal
21:06:11 <aavogt> you understand what's going on now?
21:06:20 <adnap> aavogt: nope
21:06:38 <adnap> aavogt: What's going on?
21:06:47 <aavogt> you're installing the newer cabal into   ~/.cabal/bin, but the one you run is in /usr/bin/cabal
21:07:01 <adnap> aavogt: I'm not sure of that.
21:07:17 <adnap> aavogt: I didn't specify anything when I installed cabal.  Shouldn't it just work?
21:07:27 <aavogt> did you lie about the output of which?
21:07:44 <adnap> aavogt: I may be misleading you by accident.
21:07:45 <adnap> aavogt: No
21:07:58 <adnap> aavogt: But I guess I'm not sure about the .cabal thing.  I mean, I have a directory ~/.cabal, and my libs are in there.
21:08:15 <adnap> aavogt: It just seems strange that it wouldn't work out-of-the-box.
21:08:22 <aavogt> fix your $PATH, or explicitly run the one in ~/.cabal/bin
21:08:26 <Saizan> it won't just work if you don't have $HOME/.cabal/bin in your $PATH in front of /usr/bin
21:09:23 <adnap> Saizan: But the binary is in usr/bin, which is in my PATH.
21:09:25 <Saizan> you're not the first one bitten by this, but you also don't really want cabal-install to start writing to /usr/bin
21:09:29 <dibblego> copumpkin, your example is not sending basic authentication information
21:09:32 <Saizan> adnap: the old version is
21:09:43 <Saizan> adnap: the new version is at ~/.cabal/bin/cabal
21:09:47 <pumpkin> dibblego: it was enough for me to log into the site I was testing on
21:09:51 <adnap> Saizan: You're saying somewhere down the line they changed things?
21:09:58 <Saizan> adnap: no.
21:10:15 <adnap> Saizan: Then why would I have an old version in /usr/bin?
21:10:29 <dibblego> pumpkin, yes, it doesn't need authentication
21:10:35 <Saizan> adnap: i'm saying that the binary you have in /usr/bin came from your package manager, or from you using --global --prefix=/usr
21:10:43 <pumpkin> dibblego: the site I logged into did, using that code
21:10:48 <adnap> Saizan: I guess so.
21:11:01 <adnap> Saizan: Isn't it better to install to /usr/bin, so other users can use cabal?
21:11:10 <dibblego> pumpkin, I can remove the setAuthorityGen line of code and get the same 200 response
21:11:16 * pumpkin shrugs
21:11:27 <dibblego> pumpkin, basic auth information is not sent
21:11:36 <pumpkin> all I know is that I was going to a secured site that rejected me before I put that in
21:11:44 <pumpkin> and then when I set that function with the correct username and password
21:11:45 <pumpkin> it worked :P
21:11:47 <Saizan> adnap: /usr/bin is generally best left to your distro package manager, though /usr/local/bin would make sense, which is the default for --global
21:11:49 <pumpkin> must be magic
21:12:34 <Saizan> adnap: btw, if you use --global you'll probably also want --root-cmd=sudo
21:12:45 <dibblego> pumpkin, why would haskell.org need authentication information anyway?
21:12:59 <pumpkin> dibblego: I changed the URL and username/password before sending it to you :P
21:13:01 <pumpkin> the URL was private
21:13:08 <dibblego> ok
21:13:25 <dibblego> I didn't realise you changed the URL
21:13:32 <pumpkin> could be I removed another crucial ingredient accidentally, but I'm pretty sure I just killed the string
21:21:18 <adnap> Saizan: I modified my .profile.  Is this the best place to add ~/.cabal/bin to my PATH?
21:22:06 <Zao> Possibly.
21:22:15 <Zao> I tend to symlink ~/.cabal/bin to ~/bin, or vice versa.
21:22:49 <Zao> Somewhat annoying when on multiple architectures though, as it doesn't separate things by architecture like xmonad does.
21:23:06 <adnap> wtf
21:23:15 <adnap> It is still saying there is a new version of cabal-install.
21:24:42 * hackagebot Fungi 1.0.4 - An interpreter for Funge-98 programming languages, including Befunge.  http://hackage.haskell.org/package/Fungi-1.0.4 (ThomasEding)
21:26:33 <adnap> That's weird.  If I do ~/.cabal/bin/cabal update, it doesn't complain.  It looks like even though I have ~/.cabal/bin in my PATH now, it's still picking the old cabal when I just type 'cabal'.
21:31:29 <aavogt> adnap: then switch the order of  ~/.cabal/bin  and /usr/bin in your $PATH
21:33:24 <adnap> aavogt: So, it is unable to determine which cabal is newer?
21:34:31 <aavogt> adnap: this is your shell picking the wrong executable because of your $PATH
21:38:11 <adnap> aavogt: Can I get you to try compiling something?  I have this library installed, but I'm still having trouble compiling an example that compiled fine on my laptop.
21:38:56 <aavogt> what does it say went wrong?
21:39:52 <adnap> aavogt: It just says two different data constructors aren't in scope.
21:39:56 <adnap> aavogt: But I checked to see what module they're in, and they should be in scope due to the imports.
21:40:00 <Maxdamantus> Can an efficient factorial list expression be written using only the functions ap, iterate, id, const, zipWith?
21:40:07 <Maxdamantus> (and all the normal operators)
21:40:43 <Maxdamantus> er, and point-free
21:40:43 <aavogt> Maxdamantus: can you use numbers?
21:40:48 <Maxdamantus> Yes.
21:41:07 <aavogt> no  enumFromTo?
21:41:24 <Maxdamantus> Yes.. or just [1..] or something
21:41:31 <adnap> omg Haskell 2010
21:41:32 <Maxdamantus> Just limited to those said functions
21:41:32 <aavogt> > (product . enumFromTo 1) 50
21:41:33 <lambdabot>   30414093201713378043612608166064768844377641568960512000000000000
21:41:34 <adnap> How long has that been out?
21:41:44 <Maxdamantus> :t enumFromTo
21:41:45 <lambdabot> forall a. (Enum a) => a -> a -> [a]
21:41:53 <dibblego> copumpkin, http://paste.pocoo.org/show/271188/ I can't see how this is different to your code and this code does not send authentication information
21:41:55 <aavogt> I guess that one's too easy
21:41:57 <Maxdamantus> > enumFromTo 1 (1/0)
21:41:58 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
21:42:10 <Maxdamantus> > enumFromTo 'a' 'z'
21:42:11 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
21:42:21 <pumpkin> dibblego: well, it'll only sent auth info if the page gives it a not-authorized response first
21:42:24 <aavogt> it's exactly the same as   [x .. y]
21:42:33 <Maxdamantus> Yeah.
21:42:45 <dibblego> pumpkin, I'm receiving a 403 response from my real host
21:42:48 <pumpkin> hmm
21:42:49 <pumpkin> weird
21:43:02 <Maxdamantus> I wanted a list though.
21:43:07 <adnap> :t iterate
21:43:08 <lambdabot> forall a. (a -> a) -> a -> [a]
21:43:22 <adnap> iterate (+1) 0
21:43:25 <adnap> > iterate (+1) 0
21:43:26 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
21:43:26 <Maxdamantus> > let a = 1 : zipWith (*) [1..] a in a
21:43:27 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
21:43:28 <dibblego> the only difference in traffic to my curl script is the Authenticate header
21:43:31 <Maxdamantus> eh
21:43:38 <adnap> :t ap
21:43:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:44:02 <adnap> > ap (+1) 2
21:44:03 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> b)
21:44:03 <lambdabot>    arising from a u...
21:44:05 <dibblego> the curl script works fine (and sends an Authenticate header)
21:44:39 <adnap> > ap [(+1)] [2]
21:44:40 <lambdabot>   [3]
21:44:55 <Maxdamantus> ehO_o
21:45:06 <Maxdamantus> > ap [(+1)] [1..]
21:45:07 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
21:45:13 <pumpkin> dibblego: not sure :/
21:45:19 <dibblego> neither, thanks
21:45:36 <Maxdamantus> > ap [(+1), (*2)] [1..]
21:45:36 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
21:45:41 <adnap> > ap [(*3),(*2)] [1..10]
21:45:42 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,2,4,6,8,10,12,14,16,18,20]
21:46:06 <adnap> aavogt: So, can you try compiling?
21:46:46 <adnap> :t const
21:46:47 <lambdabot> forall a b. a -> b -> a
21:46:53 <aavogt> adnap: this is probably an issue you can address yourself, by looking at what library versions you have involved
21:47:21 <adnap> > const 2 bottom
21:47:22 <lambdabot>   Not in scope: `bottom'
21:47:40 <adnap> aavogt: I swear I have the latest library.  I have no idea what's going on.
21:48:26 <adnap> aavogt: I've even tried doing a --reinstall.
21:48:31 <adnap> > let bottom = bottom in const 2 bottom
21:48:31 <lambdabot>   2
21:48:52 <adnap> > let bottom = bottom in const bottom 2
21:48:54 <adnap> :)
21:48:56 <lambdabot>   mueval-core: Time limit exceeded
21:49:51 <aavogt> adnap: you can compile with  -package foo-1.3.4
21:50:44 <adnap> Wait, if you add a module in ghci, is there a way to see all types associated with that module?
21:51:34 <aavogt> ghc has a manual :)
21:51:38 <adnap> aavogt: Where do I specify that?  I let cabal-install compile the library.  Could I specify it there?
21:51:50 <adnap> Okay, here's something strange.
21:52:34 <adnap> I can run ghci, add the module, and then start to type the name of the data contructor, and then tab, and I see it.  However when I do :t Foo, it says it's not in scope!
21:52:51 <dibblego> does there exist code that uses Network.Browser and sets the Authorization request header?
21:53:13 <adnap> aavogt: maaaaaaanuals
21:54:24 <aavogt> adnap: in the process of finding :browse, you'll see other things you ought to know
21:55:28 <adnap> aavogt: Can I grep somehow in ghci?
21:56:54 <adnap> aavogt: Actually, neither the man page for ghc nor ghci contain anything about :browse.
21:57:37 <aavogt> yeah, you gotta look in here: http://haskell.org/haskellwiki/GHC
21:58:33 <adnap> aavogt: Did you read what I said about the data constructor showing up in tab-complete, but not responding to :t?
21:58:42 <adnap> aavogt: Does that make any sensE?
21:59:12 <aavogt> I dunno how specific ghci is with tab completion
21:59:14 <dibblego> pumpkin, got something working with setAuthorities instead of setAuthorityGen *wipes brow*
21:59:31 <aavogt> whether it will complete a type when the context is a value
22:00:53 <aavogt> adnap: it would be easier to address your problem if I could see said source files
22:01:14 <adnap> aavogt: How?
22:01:45 <aavogt> then I could see for myself
22:03:18 <adnap> aavogt: You can get them by installing the same library I did.
22:04:49 <mm_freak> in lambda calculus, does (x y)[x := y] yield (y y)?
22:05:31 <mm_freak> or does it need to rename the existing y?
22:05:45 <adnap> mm_freak!
22:05:52 <mm_freak> adnap!
22:06:02 <glguy> glguy!
22:06:19 <adnap> glguy!
22:06:27 <adnap> mm_freak: We talked about Algebra once.
22:07:07 <mm_freak> i remember
22:07:27 <kmc> mm_freak, is the y in (x y) bound or free?
22:08:05 <mm_freak> kmc: free
22:11:14 <mm_freak> but does that make a difference anyway?
22:12:26 <adnap> So, how can I debug this problem?  I can see the package in ~/.cabal/libs, and the type shows up in ghci when I do tab-completion.  Why can't it find the data constructor?  I did notice that there are only '.hi' files in my lib folder.  Is that normal?
22:13:24 <mm_freak> adnap: there should be .o and .a files
22:13:59 <mm_freak> otherwise you have only an interface description, but no actual implementation
22:14:06 <adnap> mm_freak: Okay, there aren't.
22:14:15 <mm_freak> then reinstall the library in question
22:14:29 <adnap> mm_freak: I have, many times.
22:14:55 <adnap> mm_freak: There is one .o in the root of the folder, but I'm not sure whether that accounts for all of the modules.
22:15:13 <mm_freak> looks like it does
22:15:16 <adnap> mm_freak: Perhaps it does.  It does have a very general name.
22:15:30 <mm_freak> i have only one .o per module, too
22:15:40 <adnap> mm_freak: Okay
22:15:57 <mm_freak> uhm
22:15:59 <adnap> mm_freak: Do you have any other ideas?  Is there a way to have ghc tell me where it searched when it tried to make the file?
22:16:01 <mm_freak> per package, not per module
22:16:12 <adnap> mm_freak: Right
22:16:19 <mm_freak> well, how do you install?
22:16:23 <mm_freak> setup script or cabal?
22:16:29 <adnap> mm_freak: cabal install X
22:16:33 <mm_freak> as which user?
22:16:41 <adnap> mm_freak: myself
22:16:43 <adnap> mm_freak: (not root)
22:17:19 <mm_freak> is it a certain package, or do you have the same problem with all of them?
22:17:45 <adnap> mm_freak: It's a certain package, however, I've installed in successfully on a different computer using the same process.
22:18:10 <ksf> where's the rest of the icfp videos?
22:18:23 <ksf> only the haskell workshop ones are out
22:19:06 <mm_freak> then i have no idea…  if the package links to some C library, maybe that linking failed for some reason, or maybe being more explicit about installation paths helps
22:19:27 <mm_freak> perhaps have a look at ~/.cabal/config for oddities
22:19:36 <adnap> mm_freak: It does link to a C library.
22:20:19 <mm_freak> adnap: try to build the package manually
22:20:31 <adnap> mm_freak: Okay
22:24:04 <mm_freak> hmm, i need a good variable renaming scheme for lambda calculus
22:24:19 <adnap> mm_freak: That's weird.  When I do runhaskell Setup.lhs configure, it gives me a handful of dependecies that it says are missing, but when I try to install any of them with cabal, it says they've already been installed.
22:24:47 <mm_freak> adnap: use cabal to build the package
22:24:57 <mm_freak> go into its directory and do:  cabal configure
22:24:59 <mm_freak> cabal build
22:24:59 <mm_freak> etc.
22:25:41 <mm_freak> "use cabal" = "use the 'cabal' command line utility"
22:26:57 <adnap> mm_freak: What directory do you mean when you say "its"?  The directories specfic to each dependency?
22:27:46 <adnap> mm_freak: Ah, I guess you meant that one for the package I'm trying to install.
22:28:23 <ivanm> mm_freak: dammit, you had to qualify yourself so that I couldn't bitch, didn't you ... ;)
22:28:32 <adnap> mm_freak: Okay, well configurer and build went smoothly for the package I'm trying to get working, but it's still giving me the same issues with not being able to find data constructors.
22:29:08 <adnap> mm_freak: The output to my console when I did build looked exactly the same as when I did it with cabal.
22:29:51 <applicative> adnap, the default for cabal install blah from hackage is --user, but when you build inside the package, the default is global
22:30:02 <adnap> mm_freak: Here's something I'm not sure of though: when it is compiling, it says the .o files are in /dist/build.  Is that normal?
22:30:35 <inbuninbu> i'm trying to understand haskell compilation, with the eventual goal of being able to write a simple compiler capable of handling fibonacci, for example. i've been reading up on the STG, but is that the best place to start? should i focus more on the RTS? and is there a better/simpler compiler to study (for these purposes) than GHC?
22:30:40 <adnap> applicative: Okay, so that might explain it.  However, when I try doing it through cabal, it says the same thing about the .o files being in /dist/build.
22:31:43 <kmc> inbuninbu, read http://research.microsoft.com/apps/pubs/default.aspx?id=67083 and also www.haskell.org/~simonmar/papers/evalapplyjfp06.pdf
22:32:41 <kmc> i would focus on that side; you don't need a very complicated RTS for a basic Haskell system
22:33:40 <mm_freak> express qualified mm_freak
22:34:02 <inbuninbu> kmc: thanks. i've been reading through the STG paper, but not the eval/apply paper yet
22:34:05 <mm_freak> adnap: yes, that's normal
22:34:30 * ddarius imagines that every other Haskell compiler is simpler than GHC.
22:34:31 <mm_freak> applicative: btw, the default under windows is --global
22:35:03 <mm_freak> adnap: wait, do you mean dist/build or /dist/build
22:35:04 <mm_freak> ?
22:35:11 <mm_freak> the latter wouldn't be normal
22:35:31 <adnap> mm_freak: It's the first.
22:35:41 <mm_freak> then yes, that's normal
22:35:42 <ivanm> ddarius: isn't that the only reason to write a new one?
22:35:42 <ddarius> http://www.cs.uu.nl/wiki/Ehc/WebHome
22:44:41 <dibblego> http://hackage.haskell.org/packages/archive/tagsoup/0.11.1/doc/html/src/Text-HTML-TagSoup-Tree.html#universeTree I believe there is an error in this code example (data constructor TagTree does not exist)
22:52:16 <chrisdone> Peaker: moin
22:52:27 <ivanm> dibblego: ping ndm about it, he's the maintainer
22:52:33 <dibblego> yes I will
22:52:34 <ivanm> ping == email
22:56:04 <inbuninbu> ddarius: EHC seems interesting... incrementalicious...
22:58:39 <jamy> hi haskell people!
22:58:57 <ddarius> My compiler is theoretically complete modulo some things that can be put off until later.  Though, because I just shat a 300 line assembly brick, I don't have much faith that it actually works.
22:59:51 * ivanm waves idly in jamy's general direction
22:59:55 <ivanm> ddarius: oh, EHC is yours?
23:00:07 <ddarius> ivanm: No.
23:05:07 <ivanm> oh, you provided the link and then mentioned your compiler...
23:07:03 <kmc> ddarius, what will yours be called?
23:09:22 <ivanm> DHC of course!
23:09:42 <ivanm> it started off as a fork of LHC, but then he decided to make it an optimising backend for UHC
23:09:43 <ivanm> ;)
23:10:14 <ddarius> kmc: It's not a Haskell compiler.  I doubt anyone could write a Haskell compiler in 300 lines of assembly.
23:11:05 <kmc> ah, i thought you were talking about its output
23:11:09 <kmc> what do your 300 lines of assembly compile?
23:11:57 <ivanm> "hello world"
23:12:04 <ivanm> what else?
23:12:07 <ddarius> A Joy-like language with restricted quotations.
23:12:27 <ddarius> (Or rather, quotations that are quotations and not lists.)
23:14:36 <kmc> cool
23:16:35 <chrisdone> joy is fun
23:21:01 <ivanm> the wiki page on joy is a bit weird: it says that it's unusual because it has no lambda operator, but Java, etc. don't have one either...
23:22:23 <kmc> but Java has named functions with formal parameters
23:22:34 <kmc> i think that's what the paragraph is getting at, though it could be clearer
23:22:36 <ivanm> oh, so it's just worded weirdly then?
23:22:39 <ivanm> *nod*
23:23:54 <ddarius> It's also "weird" if you restrict the scope to (purel) functional languages.
23:24:22 <kmc> anyway java is scheduled to get lambda by late 2012
23:24:23 <ddarius> Which might also have been the intent of the wording.  At any rate, it is not the clearest sentence ever.
23:24:42 <ddarius> kmc: I'm sure they'll find an excuse to put it off before then.
23:24:52 <kmc> at this rate they'll miss the 75th birthday of the lambda calculus
23:25:41 <ivanm> kmc: I thought Java was going to get lambda after Duke Nukem Forever came out
23:25:42 <chrisdone> JavaScript took all the best features of Java and added prototypes and closures
23:26:05 <ivanm> Java had good features?
23:26:10 <kmc> and removed a bunch of other stuff
23:26:17 <kmc> JavaScript is not descended from Java
23:26:20 <chrisdone> I don't know any good features
23:26:23 <kmc> the similarity in naming is a marketing stunt
23:26:40 <ivanm> kmc: yup
23:26:44 <chrisdone> yes, we know, by virtue of not being retarded :P
23:26:44 <kmc> it could be argued that Java has closures (through anonymous inner classes) but no convenient syntax for creating them
23:27:08 <kmc> i'm not perfectly clear on the closure rules for inner classes though
23:27:15 <dibblego> I am
23:27:29 <dibblego> in summary, only access to fields and final locals 
23:28:06 <c_wraith> a way to sidestep the issue of mutability and scope, really
23:28:11 <kmc> but i can take some non-final function args, calculate on them, save that in a final local, and then close over it?
23:28:21 <c_wraith> yes
23:28:23 <dibblego> kmc, yes
23:28:46 <c_wraith> they really just didn't want to have to specify semantics for mutating locals
23:29:04 <kmc> ivanm, i hear DNF is scheduled for release in 2011 and can be preordered on Amazon
23:29:14 <kmc> Feb 1
23:29:29 <ivanm> kmc: oh, I heard Feb 29
23:29:33 <kmc> hehe
23:29:42 <kmc> the cycle begins again
23:37:39 <ivanm> out of all the extensions that let you use forall, what's the difference between them?
23:37:55 <jamy> hello brothers!
23:38:21 * ivanm once again waves idly in jamy's general direction
23:38:53 <ivanm> jamy: which part of Ukraine are you from?
23:39:43 <jamy> west
23:39:52 <ivanm> which oblast?
23:39:55 <kmc> ivanm, ScopedTypeVariables allows use of ∀ to bring type vars into scope
23:40:07 <jamy> Donetsk
23:40:12 <kmc> PolymorphicComponents allows use of ∀ to specify that a data constructor's field has polymorphic type
23:40:22 <ivanm> jamy: nope, don't think I have any relatives there...
23:40:27 <kmc> RankNTypes allows use of ∀ to specify that a function requires a polymorphic argument
23:40:34 <kmc> Rank2Types allows this but only "one level" deep
23:40:36 <ivanm> kmc: I'm trying to say "for all functions"
23:40:57 <kmc> ExistentialQuantification allows use of ∀ to specify, well, existential quantification
23:41:11 <ivanm> as in: there is an instance "Suitable f (a -> b)" for all a and b
23:41:17 <ivanm> but nothing I do seems to work :s
23:41:20 <kmc> oh, instances?
23:41:25 <luite> do all those things imply ScopedTypeVariables ?
23:41:27 <kmc> i wrote about this a while ago
23:41:29 <jamy> ivanm: ha ha! very smart! :(
23:41:39 <kmc> ivanm, http://mainisusuallyafunction.blogspot.com/2010/09/higher-rank-type-constraints.html like so?
23:41:50 <ivanm> jamy: also, isn't donetsk in the east, not the west? :p
23:42:01 <ivanm> kmc: oh, that's your blog?
23:42:05 * ivanm still doesn't get the title
23:42:08 <kmc> in that post i explain a way to fake the constraint (∀s. MArray (STUArray s) a (ST s)) ⇒ ...
23:42:11 <ivanm> main is quite clearly an IO _action_
23:42:25 <kmc> ivanm, it's a warning produced by gcc
23:42:32 <ivanm> ahhh
23:42:32 <kmc> if you write like "int x = 7;"
23:42:34 <kmc> err
23:42:37 <jamy> ivanm: i mean so!
23:42:37 <kmc> if you write like "int main = 7;"
23:42:45 <kmc> and i think it's a funny warning
23:42:54 <kmc> and yes the title is ironic in a haskell context
23:42:56 <ivanm> heh
23:43:03 <kmc> but i don't intend to write only about Haskell
23:43:22 <kmc> one might say that most "usually" statements about programming languages are violated by haskell
23:43:43 <ivanm> heh
23:44:03 <ivanm> "usually, programming languages are not named after someone's given name"
23:44:05 <ivanm> :p
23:44:37 <ivanm> kmc: yeah, Heffalump was trying to show me how to do something like your hack; but it isn't working :s
23:45:32 <ivanm> but if it needs an extra param to be passed around, that's not going to work
23:45:47 <ivanm> especially since I'm only doing this to avoid having to write such long type sigs :p
23:55:18 <ivanm> kmc: is there any way of wrapping your ElemType value in a class, such that by listing it as a class restriction avoids having to pass the ElemType around as a parameter>
23:55:21 <ivanm> s/>/?/
23:58:22 <sinelaw> hey
23:58:37 <sinelaw> > id id
23:58:38 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
23:58:38 <lambdabot>    arising from a use of `...
23:58:47 <sinelaw> > id id == id
23:58:48 <lambdabot>   *Exception: (==): No overloading for function
23:58:56 <sinelaw> :t id id
23:58:57 <lambdabot> forall a. a -> a
23:59:24 <ivanm> hey sinelaw
23:59:30 <sinelaw> in simply-typed LC, is there a problem to evaluate "id id" ?
23:59:41 <sinelaw> ivan, yo, sup? long time
23:59:58 <ivanm> hey, I'm usually here; you're the one that's not around :p
