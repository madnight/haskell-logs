00:00:04 <mtnviewmark> anyhow all - night time for me
00:00:17 <lispy> Why do people care about Node.js?
00:00:26 <jamy> and what web server is needed?
00:02:00 <dons> lispy: you can write new kinds of programs in javascript, and people use javascript
00:03:50 <lispy> dons: what kinds of programs become available now?
00:04:13 <lispy> dons: JavaScript has virtually no support for IO other that to a remote webserver and layout within a webpage, right?
00:04:25 <lispy> dons: No file based IO, right?
00:04:41 <dons> well, you can write async programs.
00:05:44 * shachaf has been writing some JavaScript recently, and wishing that it had monads of some sort.
00:06:12 <kmc> people care about Node.js because the idea of a language with first-class functions and a not-terrible implementation is still revolutionary, apparently
00:07:04 <kmc> lispy, Javascript the language is not limited as such.  in browsers it's deployed in environments that lack such libraries
00:07:40 <kmc> Node.js provides asynchronous socket IO for Javascript
00:07:47 <kmc> also like three dozen web frameworks
00:08:07 <kmc> access to every database you'd want
00:08:11 <shachaf> kmc: What about Ruby/Python? Does the implementation count as "terrible"?
00:08:14 <kmc> even GT.M Mumps
00:08:18 <kmc> shachaf, CPython is terrible
00:08:25 <kmc> especially if you care about concurrency
00:08:28 <kmc> i don't know much about Ruby
00:08:51 <kmc> lispy, Mozilla is working on allowing Javascript to call arbitrary C functions
00:09:06 <kmc> only from the privileged part of the browser, let's hope!
00:09:12 <shachaf> kmc: Is JavaScript any better about concurrency?
00:09:24 <kmc> Javascript, the language, says little to nothing about concurrency
00:09:33 * shachaf looks at the language shootout. V8 is surprisingly far up the list.
00:10:00 <kmc> Node.js, and the V8 tracing JIT it's built on, have good support for concurrent event-based IO
00:10:08 <kmc> i don't know how well they support threads-as-such
00:10:24 <kmc> to me event-based async is a workaround for not having good threads, and is something you'd implement on top of threads if you had them
00:11:24 <kmc> arguably there's a context-switching cost to making developers use multiple languages
00:11:36 <kmc> so if you're already writing client-side Javascript, using it on the server side has an advantage
00:11:42 <kmc> similarly GWT uses Java for client and server side
00:12:49 <shachaf> kmc: Arguably there's a context-switch regardless, though. You have to do things pretty differently on the client and on the server.
00:12:55 <kmc> true
00:13:26 <shachaf> And it seems strange to constrain your server-side language to be only as good as you client-side language.
00:13:44 <kmc> yes, but i said it's an advantage not an absolute constraint
00:14:02 <kmc> and Javascript is, in other ways, an attractive alternative to PHP or Python or Ruby
00:14:18 <kmc> or Perl ;P
00:14:46 <shachaf> Or sh!
00:15:17 <kmc> it helps that browsers drove the development of good fast JS implementations
00:15:28 <kmc> this is a historical accident; someone could have done the same for Python
00:15:32 <kmc> Google is working on it, sort of
00:15:47 <kmc> i hear LuaJIT is amazing; maybe we should all use Lua for web development
00:17:01 <lispy> At this point, I think the main complaint I can really hold on to about javascript is that it doesn't get enough competition
00:17:27 <shachaf> lispy: Really? Nothing about the language itself?
00:17:31 <lispy> There should be some other language (oh, a minihaskell?  haskellscript?) that is supported by the browsers that we can use instead
00:17:48 <kmc> Javascript has dumb scoping rules
00:17:52 <danblick> i know i won't be popular for saying this, i'm still skeptical about haskell's multicore story... it seems like the most elegant parts of haskell involve types and the lambda calculus; the parallel stuff seems kind of bolted on.  if anyone could point me to some reading that would help convince me otherwise, that would be awesome.
00:18:09 <dmwit> danblick: Read about STM.
00:18:11 <kmc> and it has ill-fitting C-like syntax for reasons that are political / marketing-based, and false at that
00:18:16 <kmc> nah
00:18:19 <kmc> read about pure parallelism
00:18:23 <lispy> shachaf: Well, js is "working".  If we had competitors, maybe we could debate the language features more realistically.  Right now I just have opinions and not enough evidence.
00:18:23 <kmc> parallelism *without* threads
00:18:26 <Twey> danblick: Haskell isn't designed for parallelism, but its design makes it good for parallelism.
00:18:33 <kmc> danblick, read the paper about the new Strategies framework
00:18:45 <kmc> Seq no more: Better Strategies for Parallel Haskell
00:18:46 <lispy> danblick: http://stackoverflow.com/questions/3847108/what-is-the-haskell-response-to-node-js
00:18:49 <shachaf> lispy: Well, on the server side you *do* have competition. :-)
00:18:55 <kmc> danblick, also read about DPH
00:19:02 <kmc> danblick, it's important to distinguish between concurrency and parallelism here
00:19:07 <Twey> So while existing parallelism features may indeed be bolted on, it's because of fundamental Haskell features that they're possible
00:19:08 <lispy> danblick: the answers to that question have links to tons of papers about parallel haskell
00:19:25 <danblick> hm. i guess i mean concurrency and not parallelism, then.
00:19:34 <kmc> ok
00:19:38 <Twey> lispy: What you really want in the browser is a standardised bytecode or some sort of minimal Scheme that makes a good compilation target.
00:19:50 <kmc> danblick, then you're in the IO world, which yes is less pretty than types and lambda calculus
00:20:02 <kmc> but i still find Control.Concurrent worlds ahead of C++ or Java or Python  threading
00:20:03 <Twey> Then we can use any language we like.
00:20:05 <kmc> first-class everything
00:20:16 <kmc> first class channels, first-class partially-applied methods on channels...
00:20:23 <lispy> Twey: yeah, it seems that using a language that is as dynamic as js hinders many optimization opportunities
00:20:33 <kmc> you can implement surprisingly complicated concurrent control-flow primitives in a few lines
00:20:50 <danblick> kmc: what does DPH stand for?
00:21:00 <lispy> danblick: data parallel haskell
00:21:16 <Twey> lispy: http://inglorion.net/documents/designs/jungle/ — this sort of thing
00:21:31 <danblick> thanks all for the suggestions, i'll look around.
00:21:54 <kmc> and yeah STM too
00:21:58 <kmc> if you're talking about explicit concurrency
00:22:00 <kmc> making it composable
00:22:09 <kmc> read "Beautiful Concurrency"
00:22:13 <kmc> also the last chapter in RWH
00:23:59 <danblick> i liked "the art of multiprocessor programming" by nir shavit; it builds up a case for software transactional memory near the end
01:08:00 <ManateeLazyCat> Hi all. :)
01:08:27 <kmc> hi ManateeLazyCat
01:08:32 <ManateeLazyCat> kmc: :)
01:10:54 <ManateeLazyCat> Hi, guys, do you want "Graphics Multi-thread curl client" ? 
01:51:18 <ketil> Anybody know which binary GHC distributions work with RHEL 5.5?  (The ghc-7 rc doesn't, as it requires a newish glibc.)
01:54:18 <jamy> ketil: rpmbuild for what?
01:57:53 <ketil> jamy: I'm sorry?
01:59:14 <jamy> you can build GHC himself.
02:11:39 <quicksilver> ketil: I think I would search for rpms.
02:12:09 * ketil has no root.  Can rpms be installed in a user directory?
02:12:22 <jamy> sure
02:12:42 <quicksilver> generally, no
02:12:50 <quicksilver> hard coded paths etc.
02:13:03 <quicksilver> would probably be some manual fixing-up required.
02:13:29 <jamy> but run him from full link (home/user/bin/ghc)
02:13:34 <quicksilver> I mean, you can *physically* install an rpm in a home directory, but some stuff probably won't work.
02:13:43 <ketil> I just grabbed 6.12.3, let's hope it works out.
02:13:54 <ketil> quicksilver, I guess I can chroot everything :-)
02:14:04 <quicksilver> possibly :)
02:15:30 * jamy installing ghc in /opt and he working
02:16:26 <kmc> ah, /opt
02:16:30 <kmc> "it's like /usr, but more so"
02:17:59 <quicksilver> jamy: if ketil doesn't have root, he probably doesn't have perms to /opt
02:18:11 <quicksilver> anyway installing GHC is different from installing an RPM
02:18:15 <quicksilver> you can install GHC anywhere
02:18:21 <quicksilver> but we were talking about the rpms, just then
02:19:36 <jamy> i mean not that. Course he dont install in /opt without root access, but its says what GHC can work out from /usr
02:19:50 <quicksilver> yes. GHC can work from anywhere.
02:19:57 <quicksilver> but the RPMs will be build with paths built in
02:20:03 <quicksilver> and I don't know how much work it is to fix that.
02:21:24 <jamy> RHELs rpm has key and value what say where install RPM
02:24:20 <ketil> The binary dist of 6.12.3 worked, so I'm okay.
02:24:48 <ketil> The binaries are static executables, but of course they manually load so's anyway.  Sigh.
02:25:08 * hackagebot DTC 1.0.1 - Data To Class transformation.  http://hackage.haskell.org/package/DTC-1.0.1 (DanielDiaz)
02:25:46 <ketil> I'm sure there's a very good reason for libc sabotaging static linking like this - I just can't remember it right now.
02:26:17 <kmc> ketil, i know glibc does this in order to rewire gethostbyname(), getpwent(), etc. with nsswitch
02:26:26 <kmc> ran into this problem here the other day
02:26:33 <kmc> you can custom build a glibc that doesn't
02:32:19 <quicksilver> ketil: I don't think enough people really care about static linking for it to be well supported in general.
02:32:36 <quicksilver> ketil: (except for particular special cases like initial ramdisks and boot devices etc)
02:33:25 <ketil> It's sometimes easier to ship binary executables to people, but I'm starting to tell them to get ghc and cabal-install and get stuff off Hackage instead.  It's a barrier, though.
02:35:13 <quicksilver> ketil: yeah, I know why it's useful. When I said "enough people really care" I meant the people who would need to provide the supporting infrastructure (distributions, compilers, library authors)
02:38:03 <kmc> well, the Haskell side supports static linking since forever
02:38:11 <kmc> there it's dynamic linking that's new
02:38:58 <kmc> ghc will easily build executables that will run fine on another machine with no Haskell dev environment
02:39:13 <kmc> so long as that machine runs the "same OS"
02:39:23 <kmc> which for Linux means close libc version and maybe a few other things
02:39:31 <kmc> i'm not sure if you can make it load libc.so from a local directory
02:39:42 <kmc> that may be a special case where you can't, if libc is involved in the dynamic loader itself
02:44:51 <jamy> if make ghc dynamicly, he lost its beauty  
02:46:35 <Maxdamantus> How much bigger is the binary after statically linking all the Haskell stuff?
02:46:43 <Maxdamantus> GHC*
02:48:09 * Maxdamantus has all his Haskell stuff in ~/hsr (Haskell system resources)
02:49:12 <jamy> what point think how much bigger?
02:49:44 <kmc> Maxdamantus, it's the default linking mode in GHC forever
02:50:00 <kmc> it depends on which libs you actually use
02:50:08 <jkff> My statically-linked application's executable was about 7mb in size. It used gtk2hs, cairo, Chart, bytestring-lexing and a couple more.
02:50:24 <Maxdamantus> Oh,interesting.
02:52:49 <sipa> kmc: i don't think libc is in any way special to the linker/loader
02:53:53 <kmc> ok
02:54:12 <Maxdamantus> You could always statically link libc
02:54:36 <kmc> no, you can't
02:54:41 <Maxdamantus> Hm. Why?
02:54:53 <kmc> <ketil> The binaries are static executables, but of course they manually load so's anyway.  Sigh.
02:54:58 <kmc> <kmc> ketil, i know glibc does this in order to rewire gethostbyname(), getpwent(), etc. with nsswitch
02:55:08 <Maxdamantus> Ah.
02:55:11 <kmc> there's a linker warning to this effect
02:55:17 <kmc> you can build a glibc that does not behave this way, though
02:55:23 <kmc> but you lose nsswitch functionality
02:56:13 <kmc> some friends of mine wrote an OpenID module for nsswitch / PAM
02:56:21 <kmc> so you could log into your UNIX machine with your Facebook account or whatever
02:56:53 <kmc> might be cool for public kiosks etc
02:56:58 <Zao> Heh.
02:57:06 <kmc> log in with OpenID, mount /home/you from S3
02:57:35 <kmc> the Server is my Mainframe and the Cloud is my Server
02:58:09 <kmc> funny how IT keeps moving between centralized and decentralized
02:58:21 <kmc> "Awesome, my very own computer on my desk, that I don't have to share with anyone!"
02:58:35 <kmc> "Wait, this sucks, an entire computer I have to run for one person?!?"
02:59:45 <kmc> the phrase "personal computer" used to have the same kind of ring as "personal island" or "personal satellite"
03:00:48 <Maxdamantus> I see no reason why anyone would need a computer in their home.
03:01:45 <Maxdamantus> Meh
03:01:49 <Maxdamantus> "There is no reason for any individual to have a computer in his home."
03:02:20 <kmc> arguably still true
03:02:23 <hiredman> if I didn't have a computer at home how I would I work from home?
03:02:33 <Maxdamantus> You'd use a terminal.
03:02:36 <kmc> you'd have a terminal at home
03:02:43 <Maxdamantus> Just have a wire going to your work.
03:02:52 <kmc> now, today's terminal has massively more power than a full computer at that time had
03:02:55 <hiredman> oh, you mean the macbook I use to ssh into a machine on ec2?
03:02:56 <Maxdamantus> Hm. Or phoneline :\
03:03:03 <kmc> today's terminal actually runs a full operating system and a web browser
03:03:11 <kmc> these are the firmware of a modern terminal
03:03:32 <hiredman> actually I run a linux vm on my macbook, ssh to the linux vm and ssh to ec2 nodes from there
03:03:35 <kmc> haha
03:04:04 <maurer_> I would suggest that many people don't have internet access from time to time, and would still like their files available. Caching offline filesystems have a ways to go before we can do this.
03:04:08 <kmc> Apple is betting that some fraction of people don't want a computer in their home, they want an Internet
03:04:13 <maurer_> The only one I know of that sort of works is Coda, and that's super broken.
03:04:40 <kmc> a sleek shiny black box with no user serviceable parts which has all the Facebooks and the Twitters inside
03:04:49 <Maxdamantus> I would suggest that people work on making that situation impossible.
03:05:03 <maurer_> kmc: You mean taking the iPad, adding 3 more iPads, and putting a kickstand on it?
03:05:03 <kmc> i agree with maurer_
03:05:07 <kmc> haha
03:05:10 <kmc> yeah
03:05:18 <kmc> eating one ipad, eating five ipads
03:05:22 <ketil> How do I tell ghc to find installed packages in a non-standard location?
03:05:34 <kmc> ghc -package-conf foo
03:05:54 <kmc> where foo is the name of your package.conf directory
03:06:17 <kmc> see for example http://mainisusuallyafunction.blogspot.com/2010/09/ghci-and-cabal.html
03:06:56 <ketil> Ah, right.  Thanks.
03:18:02 <kmc> Oleg works/worked for the Navy?!?!?
03:18:27 <kmc> on one of his papers his institution is listed simply as "FNMOC"
03:18:50 <kmc> which is apparently the United States Navy's Fleet Numerical Meteorology and Oceanography Center
03:19:30 <kmc> i'm not sure what the Navy needs delimited continuations for
03:19:42 <kmc> but i'm confident that this increases the overall effectiveness of my country's military by at least 25%
03:19:51 <FunctorSalad_> kmc: Numerical Meteorology and Oceanography
03:19:54 <FunctorSalad_> :p
03:19:54 <Zao> kmc: Judging by the name, it seems to be a weather service.
03:20:06 <Zao> Meterologists love to mangle data.
03:20:18 <kmc> so, like, they can prevent hurricanes by capturing the enclosing continuation
03:20:22 <ZtdCk9PF4NrUuHXh> OS-independent way to get name of current computer (e.g. uname in UNIX)
03:20:26 <kmc> makes sense
03:20:41 <kmc> ZtdCk9PF4NrUuHXh, none i know of.  do computers *have* names in general?
03:20:54 <ZtdCk9PF4NrUuHXh> all the ones I use
03:21:07 <Zao> kmc: Most do.
03:21:13 <kmc> i know Windows boxes in theory have names
03:21:16 <ZtdCk9PF4NrUuHXh> System.Posix.Unistd has the info, but only for UNIX machines
03:21:30 <ZtdCk9PF4NrUuHXh> there is undoubtedly a win32 call for the info
03:21:32 <kmc> does cygwin or msys provide uname.exe?
03:24:13 <Zao> kmc: That sounds like a dependency that no sane Windows user has.
03:25:16 <kmc> yeah, well, using Windows is insane ;P
03:25:47 <ZtdCk9PF4NrUuHXh> looks like win32 call is GetComputerNameEx
03:26:03 <ZtdCk9PF4NrUuHXh> I'm amazed this is not in a base library somewhere
03:26:10 <kmc> it's not in Win32?
03:26:14 <Zao> You can FFI to GetComputerName.
03:26:27 * kmc suspects it's GetComputerNameExW / GetComputerNameExA
03:26:33 <ZtdCk9PF4NrUuHXh> looks like I am about to roll my own first use of FFI
03:26:39 <kmc> on the grounds that Windows is just that cool
03:26:46 <kmc> cool ZtdCk9PF4NrUuHXh
03:26:48 <Zao> Make a patch to the Win32 package and submit it upstream.
03:26:50 <kmc> need some tips?
03:26:58 <ZtdCk9PF4NrUuHXh> tips!! I need the code!!
03:27:03 <Zao> kmc: Win32 is rather incomplete in some regards.
03:27:11 <FunctorSalad_> "kmc: do computers *have* names in general?" seconded
03:27:17 <Zao> kmc: It's missing fundamental things like PeekMessage.
03:27:19 <quicksilver> ZtdCk9PF4NrUuHXh: http://gbacon.blogspot.com/2009/06/ffi-calling-into-kernel32dll.html
03:27:20 <kmc> eek
03:27:28 <kmc> woah
03:27:31 <kmc> that's the function all right
03:27:58 <kmc> Hungarian notation is great
03:28:06 <ZtdCk9PF4NrUuHXh> perfect thx
03:28:08 <kmc> let's take static types
03:28:15 <kmc> and then let's make them manifest so they're maximally annoying
03:28:19 <kmc> and then let's remove the typeiness
03:28:20 <quicksilver> kmc: in hungarian notation you're a constant. So there.
03:28:24 <FunctorSalad_> I mean... for something to be "made portable", you want a well-defined functionality in the first place, no? not just a loose collection of ones called 'name'
03:28:29 <kmc> so it's *only* documentation and can be wrong
03:28:35 <kmc> quicksilver, fair enough
03:28:43 <kmc> i'm a constant message character
03:28:54 <kmc> lpkmc
03:29:08 <kmc> is a long pointer longer or shorter than a far pointer?
03:30:02 * kmc used a far pointer in DOS recently but it was only this long: |------------------|
03:31:14 <FunctorSalad_> "Having nice error messages can be sort of helpful with programming errors  [...]"
03:32:14 <BorisL> why is not Data.Ratio an instance of Num?
03:33:03 <FunctorSalad_> instance (Integral a) => Num (Ratio a) -- Defined in GHC.Real
03:33:15 <FunctorSalad_> @ BorisL:
03:36:15 <BorisL> thanks, I expected to see it in the Data.Ratio module
03:39:26 <Guest86956> I have a small question, it's more about the idea of how to do it then actually doing it. I want to create a breadth first search algorithm. I have the following already: the datastructure is a tree as usual and I can generate successors and I will compare those successors with my goal state. However how do I "backtrack" the road to the beginning?
03:39:35 <Guest86956> Anyone have a great idea?
03:40:20 <Guest86956> So in theory: initial state -> successors, if successors = goal state, then FOUND GOAL STATE. But now I need to "road" from initial state to goal state...
03:40:53 <kmc> your traversal turns a tree into a list of nodes?
03:41:50 <Guest86956> no, actually the only thing I get is the tree...
03:41:58 <Guest86956> the complete tree...
03:42:20 <Guest86956> maybe my approach is a bit imperative, which is wrong. But can you help me on what idea is in doing this functional?
03:42:33 <kmc> as you recursively traverse, you can build an extra argument which contains the path to the current node
03:43:10 <Guest86956> but then I will get a whole lot of paths... as each node has it's path...
03:43:30 <Guest86956> but can't I get "back" to the parent of that node?
03:43:33 <Rutix> You mean you want to trace the way to the solution?
03:43:38 <Guest86956> yes!
03:44:08 <Guest86956> I can do this imperatively, as each node has a parent and I can refer to that parent.
03:44:19 <Guest86956> but I can't seem to figure out how to do this imperatively...
03:44:51 <Guest86956> functionally *
03:44:54 <Guest86956> I mean functionally *
03:45:08 <kmc> you can build a tree with nodes that have parents functionally
03:45:17 <kmc> it looks a bit like an infinite data structure
03:45:48 <Botje> Guest86956: why not keep the path you took when going down?
03:46:05 <Guest86956> I will keep 10000 paths?
03:46:09 <Guest86956> or even more?
03:46:21 <kmc> you keep as much path as you kept function-call stack
03:46:43 <Rutix> Guest86956
03:46:45 <Guest86956> so the best way is actually keeping the path I took to go down?
03:46:46 <Rutix> shouldn't be
03:46:55 <Rutix> dont you check the move you take next based on whats best?
03:47:05 <Guest86956> no I don't
03:47:29 <Guest86956> because I really want to get the "base" idea first
03:47:38 <Guest86956> then I can make improvements about now allowing cycles
03:47:43 <Guest86956> etcetera.
03:47:47 <Guest86956> not *
03:48:46 <Botje> it's not a tree if you allow cycles
03:48:57 <Guest86956> yes it is a tree
03:49:00 <Guest86956> because if I generate
03:49:03 <Guest86956> the next successor
03:49:11 <Guest86956> and the next successor is equal to previous node
03:49:19 <Botje> oh, cycles in your successors
03:49:19 <Guest86956> then you have a cycle. But it is still a tree right?
03:49:39 <Botje> yeah
03:49:41 <Guest86956> as a matter of fact, what I now want is an efficient / good idea how to do this functionally. (breadth first search) As I have figured that if I use the imperative approach (meaning having nodes and those nodes have the parents) isn't really pretty in Haskell
03:51:33 <Guest86956> it isn't really a bad idea of forgetting the tree and just keeping the "paths" to the end nodes
03:51:49 <Guest86956> it's actually pretty good I think...
03:52:03 <Rutix> wouldnt it be better to do a depth first without backtracking
03:52:17 <Rutix> depth first search*
03:53:07 <Guest86956> @Rutix I have no idea of how to do that in Haskell, second I need the shortest path.
03:53:08 <lambdabot> Unknown command, try @list
03:53:27 <Rutix> oh
03:53:42 <Guest86956> I can do iterative deepening though
03:54:00 <Guest86956> which is indeed more efficient than BFS
03:54:46 <Guest86956> but then again, that's a whole other level of Haskell programming in which I don't think I'm at.
03:55:06 <Rutix> Fair enough
03:56:14 <Guest86956> let me try forgetting the whole tree and try implementing only paths, thanks for the idea guys!
03:56:36 <Rutix> no problem and good luck with solving whatever you are trying to solve :p
03:57:08 <Guest86956> uhm I am actually solving something really simple :P an 8 puzzle XD haha!
03:57:49 <Rutix> Hehe
03:57:52 <Guest86956> (I know there are a lot more efficient ways to solve this, but I want also to be able to generalize this to other problems)
03:58:17 <Rutix> Yea if you generalize it you could also use it for other puzzles like river crossing or w/e
04:18:50 <chrisdone> Saizan: you know your json combinators kind of duplicate what's already in the JSON library? http://hpaste.org/40588/json_combinators
04:20:45 <chrisdone> Saizan: the Result type is an instance of Monad, Functor, MonadPlus, Applicative, Alternative, MonadError String
04:22:08 <chrisdone> Saizan: your `field' is: valFromObj :: (JSON a) => String -> JSObject JSValue -> Result a
04:24:09 <chrisdone> Saizan: then the rest is readJSON
04:25:51 <chrisdone> I defined the same things, field lookup, string, etc. but the library already has this. makes defining JSON instances really easy
04:27:33 <chrisdone> e.g. http://hpaste.org/paste/40588/result_applicative_instance#p40592
04:28:25 <sinelaw> hey chrisdone 
04:28:28 <sinelaw> howzit!
04:29:48 * chrisdone salutes
04:30:08 <sinelaw> chrisdone, i'm trying to implement wavelet transforms :)
04:30:58 <sinelaw> the discrete wavelet transform is a one-liner, thanks to the dsp package 
04:31:45 <ddarius> kmc: Chris Okasaki teaches at West Point.
04:31:47 <kmc> fucking wavelets, how do they work
04:31:51 <kmc> ddarius, cool
04:32:05 <deteego> what is the easiest way to do a monadic action x times
04:32:08 <sinelaw> kmc, the intuition not to complicated actually
04:32:11 <kmc> :t replicateM
04:32:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
04:32:20 <kmc> deteego, that, also replicateM_ if you don't need the results
04:32:37 <deteego> thanks perfect
04:32:39 <sinelaw> kmc, fourier is basically correlation of your function with a cosine of each frequency
04:32:42 <chrisdone> I find it funny that that's an Int and not an Integer
04:32:48 <kmc> right
04:33:09 <sinelaw> kmc, wavelets are basically correlation of an arbitrary wavelet function with your function at each scale and each translation
04:33:21 <kmc> ok
04:33:25 <kmc> so you pick only one basic wavelet
04:33:29 <kmc> and build the whole basis out of that?
04:33:32 <sipa> yes
04:33:32 <sinelaw> yes
04:33:35 <kmc> strange
04:33:37 <sipa> by scaling and moving
04:33:41 <kmc> you don't need multiple "frequencies"?
04:33:45 <sinelaw> kmc, and they have certain properties to make that thing behave nicely
04:33:49 <kmc> ok
04:33:55 <sinelaw> kmc, so that they are actually a basis when you scale them
04:34:01 <sinelaw> by integer factors
04:34:19 <sipa> i thought exponential factors
04:34:32 <sinelaw> sipa, well yes
04:34:34 <sinelaw> 2^n
04:34:38 <sipa> yes
04:34:59 <sinelaw> kmc, they satisfy some equation where the wavelet function can be expressed as a linear combination of the same function at the next scale
04:35:04 <kmc> oh, cool
04:35:15 <sipa> kmc: cosines only capture frequency information, but no locality
04:35:19 <ddarius> In general, a wavelet basis does not need to be the same function at every scale, though certainly this is the most common situation.
04:35:19 <kmc> right
04:35:24 <sipa> wavelets capture a bit of both
04:35:30 <sinelaw> phi(x) = a * phi(2x + k) + ...
04:35:34 <sinelaw> kmc, something like that
04:36:05 <kmc> so if i input a 1D signal, the output of the discrete wavelet transform is a matrix of coefficients at different scales (on one axis) and translation (on another)?
04:36:21 <sinelaw> kmc for the continuous wavelet transform, yes
04:36:28 <sinelaw> the output is a function of 2 parameters
04:36:39 <kmc> ok
04:36:39 <sinelaw> scale and translation, roughly corresponing to freq and time
04:36:40 <ddarius> The multiresolution analysis view of wavelets is the most intuitive/useful in my opinion.
04:36:42 <kmc> right
04:36:49 <sinelaw> (scale is roughly inverse frequency for some wavelets)
04:37:33 <sinelaw> kmc, now one of the advantages is that you automatically get logarithmic scaling of resolution
04:37:48 <sinelaw> meaning, for low freqs. you get high freq resolution and bad time resolution
04:37:58 <sinelaw> and for high freqs you get high time resolution and low freq resolution
04:38:01 <sinelaw> much like human perception
04:38:12 <kmc> ok
04:38:17 <kmc> sure
04:38:20 <sinelaw> you're making the best of what's possible with the uncertainty principle
04:38:40 <ddarius> s/uncertainty principle/bandwidth theorem/
04:38:43 <sinelaw> whereas windowed fourier transforms use the same resolution for all freqs
04:38:55 <sipa> indeed, doesn't have anything to do with uncertainty
04:39:07 <sinelaw> sipa, ddarius well yes, but it's the same thing.
04:39:27 <ddarius> sinelaw: I agree, but one is a more loaded phrase and is somewhat silly.
04:39:42 <sinelaw> although the physical phrase does give a nice intuition 
04:40:23 <kmc> so what's a practical advantage of wavelets over fourier transform?
04:40:52 <sinelaw> kmc the logarithmic scale resolution is one
04:41:00 <ddarius> They can also be faster to compute.
04:41:02 <sinelaw> no need to guess window sizes 
04:41:10 <ddarius> And they are much more flexible.
04:41:15 <sinelaw> (w.r.t to short time fourier transforms)
04:41:47 <sipa> kmc: JPEG uses fourier transform, but they do it only on 8x8 pixel blocks - it would not work/help if you'd do it on the whole image
04:42:08 <mreh> @where paste
04:42:08 <lambdabot> http://hpaste.org/ http://codepad.org/
04:42:11 <kmc> because there's no locality?
04:42:39 <sipa> kmc: yes, discontinuities in the image result in many peaks in the fourier transform iirc
04:42:47 <jamy> @where server
04:42:47 <lambdabot> I know nothing about server.
04:43:06 <jamy> @where kmc
04:43:06 <lambdabot> I know nothing about kmc.
04:44:20 <mreh> this is ugly: http://codepad.org/MRwpF4xP, suggestions?
04:44:23 <sipa> kmc: but more intuitively: we view images not as frequencies, but as something that has at least some locality ("there is house on the left, and a man on the right")... fourier would force you to view everything as a single combination of sines and cosines
04:44:54 <mreh> I wanted to write an annoymous funcion after the in, but you can't use a "where" in an expression
04:45:04 <ddarius> (JPEG uses the discrete cosine transform ...)
04:45:35 <kmc> hrm
04:45:53 <sipa> ddarius: yes, not exactly the same as a discrete fourier transform, but close enough
04:46:11 <kmc> mreh, tf (tf10 &&& tf20 -> ((sf1,b0),(sf2,c0))) = (cpXX sf1 sf2, c0)
04:46:13 <kmc> maybe?
04:46:16 <kmc> ViewPatterns
04:46:29 <kmc> err that's not right
04:46:59 <kmc> i can't tell what anything actually is here
04:47:23 <mreh> kmc: I put the type in there to help
04:47:24 <quicksilver> mreh: I don't understand your complaint
04:47:58 <mreh> quicksilver: I wanted to make the Reader parts quite separate from the function it excapsulates
04:48:05 <mreh> encapsulates*
04:48:06 <kmc> you can't use "where" in an expression, but you can always use "let" instead
04:48:37 <ddarius> quicksilver: Clearly he wants a named anonymous function.
04:48:48 <quicksilver> you could do "...in \a0 -> let (sf1,d0) = tf10 a0; (sf2,c0) = tf20 b0 in (cpXX sf1 sf2, c0)
04:48:57 <quicksilver> that stops you having to name 'tf'
04:48:59 <quicksilver> is that what you meant?
04:49:23 <mreh> yeah, that's what I want
04:49:50 <quicksilver> I would personally inline tf10 and tf20 as well
04:50:10 <mreh> I forget what that means, but that's efficiency not semantics right?
04:50:18 <quicksilver> no, it's style.
04:50:21 <quicksilver> I mean not bother to give them names
04:50:31 <mreh> pointless?
04:50:38 <quicksilver> since (a) they're only used once and (b) the names don't appear to have much documentation value
04:50:42 <mreh> yeah
04:50:46 <quicksilver> same reason you didn't want to name 'tf', I suppose.
04:51:16 <quicksilver> there are basically two reasons to name values; sharing between multiple uses, and the documentation value of naming part of a computation.
04:51:22 <mreh> they do have value in comprehending the code I think
04:52:40 <quicksilver> you're the best judge of that. Leave them if so ;)
04:55:04 * hackagebot data-object-yaml 0.3.3 - Serialize data to and from Yaml files  http://hackage.haskell.org/package/data-object-yaml-0.3.3 (MichaelSnoyman)
04:55:06 * hackagebot yaml 0.4.1 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.4.1 (MichaelSnoyman)
05:18:20 <hatds> Does anyone know if the language 'Cayenne' is still around?
05:20:12 <sinelaw> > let momo x | x < 1 = 0; momo x  = 3 in momo 2
05:20:13 <lambdabot>   3
05:20:18 <sinelaw> > let momo x | x < 1 = 0; momo x  = 3 in momo 0
05:20:19 <lambdabot>   0
05:20:21 <sinelaw> > let momo x | x < 1 = 0; momo x  = 3 in momo -1
05:20:22 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> t)
05:20:22 <lambdabot>    arising from a use of `...
05:20:27 <sinelaw> > let momo x | x < 1 = 0; momo x  = 3 in momo (-2)
05:20:28 <lambdabot>   0
05:20:36 <sinelaw> hooray pattern guards
05:20:40 <Philippa> hatds: not really. I don't know if it's too bitrotten to compile readily or not, but I don't think it got much use
05:21:15 <hatds> what's a good alternative if I want a haskell-like language to play around with dep. types?
05:22:55 <ddarius> Agda is the typical recommendation.
05:24:57 <ddarius> sinelaw: Those are just guards.  Pattern guards are something else.
05:25:47 <kmc> hatds, Agda is more Haskell-like.  Coq is more mature and has better introductory materials, imo
05:26:04 <kmc> i really enjoyed _Software Foundations_ by Pierce et al
05:26:22 <kmc> it is both a good Coq tutorial and an introduction to mechanized metatheory of programming languages
05:26:37 <kmc> doing the exercises is so much fun, each is like a level of a puzzle game
05:27:18 <kmc> the beauty of proof assistants is that they have the same reward structure as a puzzle game
05:27:30 <kmc> unlike doing proofs on paper and then waiting a week to see if the TA maybe happened to find any errors
05:27:48 <ddarius> @google lambda the ultimate ta
05:27:48 <lambdabot> No Result Found.
05:27:57 <hatds> heh
05:28:07 <ddarius> http://lambda-the-ultimate.org/node/2809
05:29:03 <sinelaw> ddarius, so what's an example for pattern guards?
05:29:07 <sinelaw> mister party pooper
05:29:16 <sinelaw> says me
05:29:43 <sinelaw> @hoogle (a,a) -> [a]
05:29:44 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
05:29:44 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
05:29:44 <lambdabot> Prelude snd :: (a, b) -> b
05:29:59 <sinelaw> @pl \(a,b)  -> [a,b]
05:29:59 <lambdabot> uncurry ((. return) . (:))
05:31:41 <ddarius> sinelaw: foo dict key1 key2 | Just val1 <- lookup key1 dict, Just val2 <- lookup key2 dict = val1 + val2 | otherwise = 0
05:32:11 <sinelaw> ah
05:35:55 <sinelaw> @pl (a,b) -> (b,a)
05:35:55 <lambdabot> (line 1, column 7):
05:35:55 <lambdabot> unexpected ">" or "-"
05:35:55 <lambdabot> expecting variable, "(", operator or end of input
05:35:59 <sinelaw> @pl \(a,b) -> (b,a)
05:35:59 <lambdabot> uncurry (flip (,))
05:37:41 <hatds> So Coq is based around iteractive theorem proving and tactics.. is *everything* in Coq like a proof script?  Does it have a subset that's more program-like?
05:38:00 <Philippa> it does, yes
05:38:20 <Philippa> the language fully-generated proofs're written in
05:38:40 <Philippa> tactics're 'just' metacode
05:38:43 <hatds> ah
05:39:18 <ddarius> Tactics are just really powerful, but inscrutable macros.
05:51:05 <Maxdamantus> @pl \a -> [a]
05:51:06 <lambdabot> return
05:51:45 <Jafet> Maybe pl should give type annotations
05:52:18 <Maxdamantus> @pl \a -> [[a]]
05:52:19 <lambdabot> return . return
05:52:43 <siracusa> > pure 1 :: [Int]
05:52:44 <lambdabot>   [1]
06:02:25 <Maxdamantus> @pl \[[[a,b]],[[c],[],[e,f]],[[g]]] -> [g,f,e,c,b,a]
06:02:25 <lambdabot> (line 1, column 2):
06:02:25 <lambdabot> unexpected "["
06:02:25 <lambdabot> expecting pattern
06:02:36 <Maxdamantus> @pl [a] -> a
06:02:36 <lambdabot> (line 1, column 5):
06:02:36 <lambdabot> unexpected ">" or "-"
06:02:36 <lambdabot> expecting variable, "(", operator or end of input
06:03:03 <ddarius> Jafet: @pl ignores types completely.
06:03:10 <ezyang> I just read Snoyman's latest post <http://docs.yesodweb.com/blog/invertible-monads-exceptions-allocations/> and it reminded me of Anders' MonadMorphIO. Did that previous proposal ever go in? 
06:03:16 <ddarius> @pl \x -> not "foo" x
06:03:16 <lambdabot> not "foo"
06:03:46 <Jafet> Rewrite rules all the way?
06:04:38 <Jafet> ddarius: do you know any document describing how it's implemented?
06:05:04 <Maxdamantus> It uses some db of reductions I think
06:05:36 <Maxdamantus> Hm. That's probably just obvious, nvm.
06:06:15 <Maxdamantus> I'm thinking "hare"
06:06:43 <Maxdamantus> Yeah, that's where it gets its stuff from.. http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html
06:06:58 <ddarius> Jafet: The source.
06:07:28 * Jafet quietly takes the door to his right.
06:50:11 <Tennon> What are some Windows applications that have been written with Haskell?
06:51:19 <Jonno_FTW> what would be the fastest way to check if all the elements in a list are equal?
06:51:55 <ezyang> Jonno_FTW: fold on the tail? 
06:52:02 <Jonno_FTW> I was thinking that
06:52:03 <ezyang> Tennon: Cryptol runs on Windows. 
06:52:50 <Jonno_FTW> > and $ foldl1 (==) [1,1,1]
06:52:52 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
06:52:52 <lambdabot>         against inferred typ...
06:52:54 <Twey> Doesn't darcs run on Windows?
06:53:03 <Jonno_FTW> ghc runs on windows
06:53:04 <Twey> GHC runs on Windows. ☺
06:53:05 <Twey> Haha
06:53:09 <Twey> ⁵
06:53:37 <Jonno_FTW> > foldl1 (==) [1,1,1]
06:53:38 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
06:53:39 <lambdabot>    arising from the literal `1'...
06:53:42 <Jonno_FTW> :(
06:54:08 <Twey> Sadly no.  :-\
06:55:08 <Twey> homogeneous [] = True; homogeneous (x : xs) = all (== x) xs
06:55:27 <Jonno_FTW> > let x = [1,1,1,1] in and $ map (\x -> x== head xs) xs
06:55:28 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
06:55:48 <Jonno_FTW> > let xs = [1,1,1,1] in and $ map (\x -> x== head xs) xs
06:55:49 <lambdabot>   True
06:56:47 <ddarius> Most Haskell programs should run fine on Windows or Linux with no changes.
07:00:34 <ezyang> ddarius: Is a suitable fix for your comment to restrict the domain set of individuals to types? 
07:01:08 <ezyang> I think attempting to rephrase everything in terms of propositional second order logic will confuse things (or, at least, make me rewrite all of my notation :-) 
07:01:44 * hackagebot darcs-beta 2.4.99.1 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-beta-2.4.99.1 (ReinierLamers)
07:02:48 <ddarius> ezyang: The point is that the type of things forall quantifies over in first order logic is not the same type of thing that ->, say, takes.  So unless you are going to have an explicit conversion from "types" to propositions, you are no longer working in FOL if you do that.
07:03:19 <ddarius> Of course, saying that the domain set is types is pretty much what propositional second order logic does.
07:04:11 <ezyang> Ok. So if I fix anywhere I use \forall x. x -> x to be something like, hm, \forall x. I(x) -> I(x), and restrict the domain, I'd be scott free? 
07:04:20 <ddarius> ezyang: (Incidentally, set theory is nothing other than higher order logic implemented in terms of first order logic exactly through explicit conversion to/from sets from/to propositions.)
07:04:38 <gal_bolle> is there a way to use cabal to make a TAGS file?
07:04:38 <ezyang> Hah, classy. 
07:04:48 <ezyang> gal_bolle: Not really. Use hasktags. 
07:05:08 <gal_bolle> k thanks, i was thinking of using cabal to drive hasktags
07:06:24 <ddarius> ezyang: If you are going to appeal to Curry-Howard, it makes more sense to use the natural/standard correspondence with the polymorphic lambda calculus.
07:06:34 <roconnor> ddarius: what about the axiom of replacement?
07:06:55 <ddarius> ezyang: Using propositional second order logic shouldn't really change too much or make things much more complicated.
07:07:54 <ezyang> ddarius: Well, my first concern is whether or not I can safely apply the sequent calculus to propositional second order logic. I think I can, but I guess I'm not using the LK system anymore. 
07:09:25 <EvanR-work> http://unqualified-reservations.blogspot.com/2007/08/whats-wrong-with-cs-research.html
07:13:36 <ezyang> Ok, new plan: push everything to propositional second order and tell people that x,y,z vary over propositions, not individuals. 
07:14:11 <ezyang> With a temporary foray in first order logic to get some intuition about the quantifiers. 
07:18:37 <ezyang> ddarius: Ok, I think it's fixed. 
07:20:11 <Jonno_FTW> how would I check if a list contains only consecutive elements?
07:20:46 <EvanR-work> last - first = length and nub x == x ;)
07:20:50 <EvanR-work> hmm
07:21:00 <EvanR-work> and sort x = x
07:21:30 <blackh> all (\(a, b) -> succ a == b) (zip xs (tail xs))
07:21:30 <Jonno_FTW> thanks
07:21:42 <EvanR-work> i just threw that together on the spot
07:22:20 <Jonno_FTW> I take it the last one would be fastest?
07:22:22 <EvanR-work> blackh looks nicer
07:22:30 <EvanR-work> an iterative approach
07:26:48 <nostard> is "filter f $ filter g" fused with -O2 ?
07:28:07 <dolio> If you mean 'filter f $ filter g l', then yes, it should be.
07:30:59 <nostard> dolio: yeah, thanks =)
07:32:44 <Twey> all (uncurry (==) . first succ) . zip `ap` tail
07:33:14 <Twey> all (uncurry (==) . first succ) . ap zip tail
07:41:33 <Jonno_FTW> if I declare a data and use deriving (Eq,Ord,Show)
07:41:42 <Jonno_FTW> is the Eq redundant?
07:41:55 <dolio> No.
07:42:10 <Jonno_FTW> how come?
07:42:29 <dolio> Why would it be?
07:42:40 <roconnor> because Ord requires Eq
07:42:55 <Jonno_FTW> can't GHC figure that out though?
07:43:10 <roconnor> my response was for dolio
07:43:38 <dolio> How does GHC know you don't just want to write your own Eq instance?
07:43:49 <roconnor> Jonno_FTW: I *think* the trick is that you might want to write you own Eq instance
07:44:00 <roconnor> ya
07:44:02 <roconnor> what dolio said
07:44:09 <Jonno_FTW> ok, well I want the properties of both Eq and Ord
07:44:13 <Jonno_FTW> and Enum too
07:57:58 <aristid> feedback on my newest package (now with haddock documentation)? http://hackage.haskell.org/package/shortcircuit-0.1
08:08:50 <ezyang> Hm. That's an interesting typeclass. 
08:09:06 <ezyang> Why wouldn't `par` work? 
08:09:36 <Paczesiowa> I have created a simple expression data type (with derived Eq), I've used derive tool to create Arbitrary instance, but QC is crazy, even testing \x -> x == x fails to terminate in a reasonable time, it generates terms that are so huge, there's no point to even wait for them to print. is it a known feature?
08:10:08 <ezyang> Paczesiowa: That seems fairly poor. 
08:10:29 <ezyang> I know when I've crafted arbitrary instances, I've needed to carefully adjust down the probabilities upon recursion. 
08:11:22 <Paczesiowa> ezyang: the generated instances seems to favor smaller terms
08:11:49 <ezyang> Does derive use the standard mechanism? If so, you can probably make the structures smaller with sized 
08:12:43 <Paczesiowa> http://hpaste.org/40595/qc_arbitrary_instance
08:13:03 <ezyang> uh, yeah, that's highly unlikely to terminate. 
08:13:23 <Paczesiowa> why?
08:13:45 <ezyang> 3/8 are terminals 
08:14:02 <ezyang> So every step of the recursion, you have a greater than 50% probability of continuing on the generation 
08:14:25 <aristid> ezyang: was that question with `par` directed to me?
08:14:41 <ezyang> aristid: Yeah. 
08:14:51 <aristid> ezyang: because par does something completely different?
08:14:59 <aristid> @hoogle par
08:14:59 <lambdabot> Control.Parallel par :: a -> b -> b
08:14:59 <lambdabot> Text.Html paragraph :: Html -> Html
08:14:59 <lambdabot> Text.XHtml.Frameset paragraph :: Html -> Html
08:15:00 <ezyang> par mightnot be quite appropriate, maybe something like the lub library. 
08:15:14 <aristid> ezyang: ???
08:15:28 <Paczesiowa> ezyang: what % would be good?
08:15:31 <ezyang> Basically, for pure short-circuiting computation, we can do one better: 
08:15:43 <aristid> ezyang: shortcircuit is completely deterministic and single-threaded
08:15:47 <aristid> @hackage lub
08:15:47 <ezyang> Paczesiowa: It needs to be at least over 50% 
08:15:47 <lambdabot> http://hackage.haskell.org/package/lub
08:16:00 <ezyang> aristid: Ah, ok, you want determinism. Nevermind then :-) 
08:16:34 <ezyang> I've actually just finitely bounded the number of recursions I allow. 
08:16:35 <aristid> ezyang: i started it, because i had two IO (Maybe a), and i wanted to execute the second action only if the first returned Nothing
08:17:05 <aristid> ezyang: so i wrote a function for that, but that didn't satisfy me because it didn't feel general enough. so i wrote a generalised package.
08:18:02 * ezyang nods 
08:18:04 <aristid> x `orM` y only performs y if x fails; x `andM` y only performs y if x succeeds
08:18:29 <aristid> it's like liftM2 (||) and liftM2 (&&), but actually lazy and generalised to Maybe and Either
08:18:43 <ezyang> Oh! 
08:18:50 <ezyang> I realized you want the Monoid instance of Maybe. 
08:19:18 <ezyang> Nothing ⊕ Nothing = Nothing 
08:19:20 <aristid> no, Monoid does not suffice for short-circuiting
08:19:30 <ezyang> Ah, ok. 
08:19:37 <aristid> because there is no isNothing function that allows me to tell whether i can skip the second action
08:20:20 <Twey> aristid: Monad m => m x -> m y -> m (Either x y)?
08:20:32 <aristid> Twey: huh?
08:20:36 <ezyang> oh, you need specifically First. 
08:20:50 <ezyang> for at least the pure case. Lemme think if it projects correctly into the monadic world 
08:21:11 <aristid> ezyang: that does not generalise to Bool and Either, which my package does support
08:21:34 <ezyang> (First (Just a)) ⊕ _|_ = (First (Just a)) 
08:21:38 <ezyang> Yeah, lessee 
08:21:40 <aristid> ezyang: it also does not support andM
08:22:06 <aristid> ezyang: liftM2 mappend DOES always evaluate both actions
08:22:19 <Paczesiowa> ezyang: http://hpaste.org/paste/40595/now_with_more#p40596 seems to work
08:22:32 <Paczesiowa> ezyang: shouldn't that be considered a bug?
08:23:05 <ezyang> If the original code was generated by derives, yes. 
08:23:20 <ezyang> Although, probability shaping is a subtle art. 
08:23:43 <ezyang> In particular, it will define what generated instances of your data structure will look like, and that may be important for your test coverage. 
08:24:31 <Paczesiowa> ezyang: thank you
08:25:13 <ezyang> Oh, and I lied earlier. The probability you need is dependent on how many subexpressions get generated. 
08:25:51 <ezyang> So the relevant quantity is how many subexpressions are being generated versus are being clipped. The weighted average should be less than 1. 
08:26:53 <ezyang> aristid: Oh! I think I did something like this in some code I wrote a few months ago. 
08:28:26 <ezyang> What you actually want is MonadPlus. 
08:29:20 <ezyang> It's probably not as general as you're looking for 
08:29:23 <ezyang> but it did the trick for me. 
08:29:42 <ezyang> http://hpaste.org/40597/mplus_to_short_circuit 
08:31:51 <aristid> ezyang: MaybeT is a bit of a rather high overhead
08:32:18 <ezyang> yeah 
08:32:27 <ezyang> I wasn't super happy about that dependency. 
08:32:39 <aristid> ezyang: i just want to do action1 `orM` action2, not runMaybeT (lift action1 `mplus` lift action2) or whatever
08:32:58 <aristid> oh it's not so much the code dependency but that it blows up the code
08:33:07 <aristid> -code dependency+package dependency
08:33:16 <byorgey> Paczesiowa, ezyang: this is a well-known problem with QuickCheck.
08:33:21 <Twey> orM = runMaybeT . on mplus lift
08:33:29 <ezyang> aristid: Oh, really? I didn't realize that. 
08:33:33 <Twey> :þ
08:33:46 <ezyang> That's really interesting. 
08:34:00 <aristid> Twey: then i can as well write a specialized orM for Monad m => m (Maybe a) -> m (Maybe a) -> m (Maybe a)
08:34:03 <aristid> which is easy too
08:34:04 <byorgey> the mathematics behind generating structures of a given size uniformly at random has been known for almost 20 years, but is only slowly making its way into the FP mainstream.
08:34:34 <aristid> orMOnlyMaybe a b = a >>= \x -> if isJust x then return x else b
08:34:54 <aristid> really that is actually all there is to orM in shortcircuit too, only more generalised
08:35:03 <Twey> Yeah
08:35:11 <byorgey> Paczesiowa, ezyang: fortunately I think Jacques Carette's PhD student Gordon Uzskay is working on a successor to QuickCheck + SmallCheck which can do exactly what you want, and do it the right way
08:35:22 <byorgey> but I don't know when it will be released.
08:35:42 <aristid> i also have generalised if-then-else in shortcircuit, btw :D
08:35:52 <aristid> if' Nothing 1 2 == 2
08:35:54 <ezyang> byorgey: Tell him to release it early and often! 
08:35:54 <Twey> So you basically just want a standard way to test whether something is mzero
08:36:17 <byorgey> ezyang: well, indeed =)
08:36:37 <aristid> Twey: no, whether something is invalid/false/whatever
08:36:48 <aristid> Twey: it need not be limited to MonadPlus
08:37:12 * ezyang so looks forward to integrated QuickCheck and SmallCheck 
08:37:16 <aristid> Twey: which is exactly what the class Shortcircuit is. only one method: isTrue
08:37:18 <Twey> aristid: So Monoid?
08:37:32 <ezyang> Twey: Not if the monoids are living in monads. 
08:37:36 <dmbarbour> I have a question: for StateT monad with IO and a large record of state, would it be better (for performance) to favor lazy state updates or to use IORef or STRef?
08:37:39 <Twey> >.-
08:37:39 <ezyang> "we all live in a yellow submarine" 
08:38:03 <ezyang> dmbarbour: What kind of operations do you expect? 
08:38:14 <Paczesiowa> byorgey: great!
08:38:21 <aristid> Twey: no, not Monoid. monoid has no "is it mempty?"
08:38:54 <aristid> Twey: and Monoid + Eq would be disastrous, for that requires an Eq a on the a in Maybe a
08:38:58 <ezyang> Is there a field of something, like, the observational properties of algebras? :-) 
08:39:15 <aristid> Twey: MonadPlus + Eq would work, but be rather ugly and also less general
08:39:36 <dmbarbour> ezyang: List additions, mostly, but a lot of small ones on individual elements. (The record has a total seven different queues, for different aspects of flow-based programming.)
08:39:55 <Twey> aristid: Yes, but you want Monoid *plus* isEmpty
08:39:56 <byorgey> dmbarbour: IORefs and STRefs are lazy too, so laziness is not really the issue.
08:40:27 <byorgey> dmbarbour: if I were you I would stick to the State monad, but for performance you may need to introduce some strictness
08:40:28 <aristid> Twey: no. i do not need Monoid.
08:40:37 <ezyang> Specializing the state monad is one of the first things people do to get extra performance. 
08:40:42 <byorgey> i.e. make all the fields of the state record strict, use the strict state monad, that sort of thing.
08:40:47 <aristid> Twey: isEmpty is enough.
08:40:49 <Twey> aristid: Minus mplus?
08:40:57 <Twey> Yeah
08:41:00 <ezyang> aristid: I think you're running into the "if it's not from category theory, you're using the wrong abstraction" mentality :-) 
08:41:03 <aristid> Twey: i do not need mappend anywhere
08:41:34 <aristid> ezyang: at least you admit your faults :)
08:41:38 <dmbarbour> byorgey: the question, I guess, is whether functionally updating a very large record (of 10 elements at the moment) will be more or less expensive than updating a smallish IORef.
08:42:03 <ezyang> dmbarbour: Haskell will be able to share most of the old results. 
08:42:31 <ezyang> if you have a record of 10 IORefs, you can avoid having to copy pointers, but I don't know if that will actually win you things. 
08:42:35 <ezyang> as opposed to introducing strictness. 
08:42:36 <aristid> ezyang: but i think there's something similar in algebra. maybe it's a boolean algebra, except that i don't always have the True and False elements?
08:43:20 <dmbarbour> I agree, ezyang. How is Haskell's allocator and GC performance for those large records?
08:43:30 <aristid> ezyang: i mean, i call my operations true, false, isTrue, isFalse, if', unless', (&&), (||)...
08:44:04 <aristid> the original name of the package was exclusive-monoid by the way
08:44:06 <ezyang> Maybe the term we're looking for is "generalized truth values". But that's not quite right, because true (&&) doesn't favor the left or right side. 
08:44:07 <aristid> but that name sucked :P
08:44:45 <aristid> > False && undefined
08:44:46 <lambdabot>   False
08:44:50 <quicksilver> dmbarbour: they're not really large records
08:44:52 <aristid> > True || undefined
08:44:53 <lambdabot>   True
08:44:55 <quicksilver> dmbarbour: or rather, that's not how they're allocated.
08:44:59 <ezyang> > undefined && False 
08:45:00 <lambdabot>   *Exception: Prelude.undefined
08:45:10 <ezyang> With lub, you can make that also work, I think. 
08:45:12 <quicksilver> dmbarbour: they're allocated as lots of pointers and small bits of data which is, generally, what haskell's GC is good at.
08:45:13 <dmbarbour> please enlighten me, quicksilver.
08:45:30 <quicksilver> dmbarbour: further more that arrangement means that unchanged bits can be shared
08:45:42 <quicksilver> which makes changing small parts of large records relatively efficient
08:45:51 <dmbarbour> So should I arrange the fast-updating bits at the front or the back?
08:45:56 <aristid> ezyang: i called my package shortcircuit because the whole point is favoring the left side
08:46:00 <quicksilver> doesn't matter as far as I know
08:46:02 <ezyang> dmbarbour: Doesn't matter. 
08:46:05 <quicksilver> interesting question though :)
08:46:13 <ezyang> aristid: Yeah. 
08:46:56 <quicksilver> aristid: the 'or' part is just like some MonadPlus instances; the so-called "MonadOrElse" type of instance.
08:47:27 <quicksilver> aristid: ...in those cases though you don't need 'and' at all. It's just (>>)
08:48:25 <dmbarbour> So the basic consensus is to stick with the State-monad state where possible for now? That is the answer I was hoping for, since it seems cleaner.
08:48:34 <dmbarbour> Thanks.
08:48:49 <frerich3> I recently read that when evaluating 'take 3 (sort [5,8,2,5,1,9,7])' the 'sort' invocation will actually terminate as soon as the first three elements have been determined? If this true? If so - how does that work?
08:48:57 <aristid> quicksilver: which instances are of the MonadOrElse type?
08:49:33 <aristid> quicksilver: is Either XYZErr of such?
08:50:07 <Jafet> frerich3: imagine the recursive merge steps as forming a heap. Then you can lazily extract the top of the heap.
08:51:32 <quicksilver> aristid: IO, Maybe, MaybeT
08:51:46 <quicksilver> > Left "failed" `mplus` Right 4
08:51:47 <lambdabot>   Right 4
08:51:56 <quicksilver> aristid: yes, the Either one too
08:52:09 <aristid> IO is in MonadPlus? oO
08:52:11 <Jafet> frerich3: http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Data-List.html#line-780
08:52:25 <quicksilver> aristid: yes, it's catching exceptions
08:52:36 <quicksilver> although it's not particularly good style because it's catching all exceptions.
08:53:11 <frerich3> Jafet: hmm
08:53:17 <aristid> hmm in haskell there are so incredibly many options for error handling :D
08:53:49 <Quadrescence> who does error handling these days?
08:53:59 <monochrom> I use exceptions when in IO, maybe/either/myown when in pure functions
08:54:37 <aristid> monochrom: was it you who proposed orElse?
08:54:42 <monochrom> no
08:55:23 <aristid> hmm
08:55:49 <aristid> monochrom: sorry, i recall having a conversation two days ago or so, but am not sure with who exactly :D
08:56:17 <osaunders> Is it possible to import from a parent directory
08:56:18 <osaunders> ?
08:56:42 <blackh> osaunders: Yes
08:57:09 <osaunders> How?
08:57:27 <EvanR-work> > replicate 10 1
08:57:28 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
08:57:35 <quicksilver> osaunders: source files don't know about the directory structure you keep your files in
08:57:44 <quicksilver> osaunders: you tell GHC where they are with commandline options
08:57:47 <quicksilver> if you need to.
08:58:00 <quicksilver> the vast majority of the time it sufficies to use the normal method though
08:58:17 <EvanR-work>  [1] >>= ?
08:58:27 <osaunders> quicksilver: Yeah, OK. TY
08:58:33 <osaunders> :t (>>=)
08:58:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:58:53 <EvanR-work> > [1] >>= replicate 10
08:58:53 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
08:59:02 <quicksilver> > [(),(),(),(),(),(),(),(),()]>>=[1]
08:59:03 <lambdabot>   Couldn't match expected type `() -> [b]'
08:59:03 <lambdabot>         against inferred type `[a]'
08:59:14 <osaunders> > [1,2] >>= replicate 4
08:59:14 <quicksilver> > [(),(),(),(),(),(),(),(),()]>>=\_->[1]
08:59:15 <lambdabot>   <no location info>: parse error on input `->'
08:59:15 <lambdabot>   [1,1,1,1,2,2,2,2]
08:59:51 <quicksilver> > [(),(),(),(),(),(),(),(),()]>>=(\_->[1])
08:59:52 <lambdabot>   [1,1,1,1,1,1,1,1,1]
09:00:40 <dmbarbour> I have another question: I'd rather not the regular users of my StateT monad have access to its state, What is haskell idiom for preventing this?
09:01:03 <quicksilver> newtype it
09:01:14 <quicksilver> and don't expose the constructor
09:01:31 <quicksilver> just expose some useful functions which do stuff.
09:01:42 <dmbarbour> so something like 'newtype R = R (StateT ...)'?
09:01:59 <blackh> dmbarbour: You can be lazy and say {-# LANGUAGE GeneralizedNewTypeDeriving #-} then ... newtype .. deriving (Functor, Applicative, Monad)
09:02:01 <quicksilver> newType MyFunkyMonad a = MkMFM (StateT IO a)
09:02:04 <quicksilver> or similar.
09:02:18 <dmbarbour> Thanks blackh
09:02:37 <quicksilver> as blackh says you probably want to derive Functor/Applicative/Monad but you probably *don't* want to derive MonadState
09:02:52 <EvanR-work> MyFunkyMonad = MkMFM . StateT IO
09:03:24 <dmbarbour> Thanks too, quicksilver and EvanR-work
09:03:31 <EvanR-work> what i said i dont think is valid
09:03:36 <quicksilver> EvanR-work: no, not really. MkMFM is a function, not a type. you can't compose it with StateT IO
09:04:02 <EvanR-work> quicksilver: well thats mighty suggestive anyway!
09:04:39 <dmbarbour> What is MkMFM here? just a new constructor?
09:05:25 <dmbarbour> (I thought that was for 'data' only.)
09:05:50 <EvanR-work> newtype and the requires wrapper constructor reminds me of declaring types explicitly for the compiler in C
09:05:54 <EvanR-work> required
09:06:38 <EvanR-work> dmbarbour: data can have more than one constructor newtype only 1
09:06:50 <EvanR-work> with one argument
09:07:58 <dmbarbour> Ah, thanks EvanR-work. I was under the impression that the constructor for newtype had always to be the same as the typename.
09:08:28 <EvanR-work> might as well be
09:08:45 <EvanR-work> would be silly for you to use that name for something else
09:09:02 <dmbarbour> quicksilver suggested using another name in order to hide the constructor.
09:09:07 <quicksilver> dmbarbour: it might as well be but sometimes it's confusing - especially in examples - to use the same name for two different things.
09:09:16 <dmbarbour> (or was my impression)
09:09:21 <quicksilver> you actually still can expose the type and hide the constructor, even if they have the same name
09:09:22 <EvanR-work> dmbarbour: the constructor for StateT
09:09:32 <EvanR-work> or
09:09:35 <EvanR-work> ?
09:09:48 <quicksilver> module Foo ( MyFunkyMonad(MyFunkyMonad) ... ) -- expose constructor
09:09:51 <EvanR-work> ah hide the constructor just to make it an abstract state monad
09:09:56 <quicksilver> module Foo ( MyFunkyMonad() ... ) -- hide constructor
09:09:59 <dmbarbour> Thanks quicksilver
09:10:17 <quicksilver> my choice of different name was only for clarity. It may not actually have been clearer :)
09:10:20 <dmbarbour> If you don't use empty parens, does it still hide constructor?
09:10:35 <dmbarbour> module Foo (MyFunkyMonad, ...)
09:10:41 <EvanR-work> beware hiding stuff in your export list
09:11:02 <EvanR-work> users may hate your guts because they can clearly see the code, but cant use it ;)
09:11:31 <Twey> Yes T_T
09:11:56 <dmbarbour> It also means I can change it without compatibility issues. The main reason I'd beware is for debugging - which, as I understand it, is why a lot of 'Internal' directories are all over the place in Haskell.
09:12:02 <dmbarbour> (or Hackage)
09:15:14 <EvanR-work> public protected private
09:24:24 <dmbarbour> Hmmm... another question: if I know they're going to be small (typically 10 elements or fewer), and cleared regularly, should I favor association lists or should I haul in Data.Map?
09:30:41 <Tennon> Byebye
09:31:12 <jbman> hi
09:31:20 <EvanR-work> dmbarbour: yes
09:31:24 <jbman> i need help with programming
09:31:35 <EvanR-work> you and most of the IT sector
09:31:41 <djahandarie> Heh
09:31:43 <osaunders> I'm finding "cabal install" a bit slow compared to "ghc --make" for building my small Haskell project. Guess I'm used to interpreted languages. Any suggestions on getting a speed boost?
09:31:47 <djahandarie> jbman, programming in Haskell?
09:31:58 <osaunders> jbman: Just ask your question, we'll help if we can.
09:32:13 <dmbarbour> EvanR-work: answering 'yes' to an 'or' question is the sort of thing a computer would do. 
09:32:19 <Paczesiowa> osaunders: disable -O in cabal config?
09:32:21 <jbman> Suppose that the class Pet has a variable/field called name that is of type String. in bluej actually
09:32:28 <EvanR-work> dmbarbour: im *am* turing complete
09:32:40 <djahandarie> jbman, this channel isn't for Java programming, it is for Haskell programming
09:32:41 <monochrom> I am a computer.
09:32:48 <djahandarie> jbman, try #java
09:32:51 <EvanR-work> monochrom is a modem
09:32:54 <dmbarbour> Most people aren't. I'm told that Turing complete means you can compute any function. ;-)
09:33:06 <EvanR-work> any computable function
09:33:10 <EvanR-work> given enough time and space
09:33:11 <osaunders> Paczesiowa: Hm OK. The main slow bit seems to be the configuring and stuff it does before it hits GHC even if no files have changed.
09:33:24 <dmbarbour> You must have done well in your math courses.
09:33:31 <EvanR-work> engineering actually
09:33:39 <Jafet> The instructions for EvanR are: increment register n, decrement register n, test register n, consume coffee
09:34:10 <Paczesiowa> osaunders: maybe don't use cabal-install?
09:34:20 <Paczesiowa> osaunders: compile Setup.hs and use that
09:34:34 <aristid> how do you model record structures where some fields occur in many different record types? move that field into a polymorphic record type? something else?
09:34:37 <dmbarbour> You don't have math courses in engineering anymore?  Anyhow, which would you favor - small association lists vs. small Data.Map?
09:34:49 <monochrom> "cabal build" is very fast
09:35:09 <EvanR-work> dmbarbour: not many *math* courses, but i did do a lot of computations
09:35:38 <dmbarbour> The question is whether you compute the function they give you. ;-)
09:35:58 <EvanR-work> dmbarbour: in C i would say lists, but its exactly the same haskell interface wise
09:36:09 <EvanR-work> lists or more sophisticated structure
09:36:52 <EvanR-work> dmbarbour: computing machinery can also fail
09:37:00 <monochrom> you can't have the same field name in two different types. there is an extension for that, but I hold it in contempt
09:37:03 <osaunders> monochrom: Ah, nice. Thanks.
09:38:33 <monochrom> but within the same type, you can have the same field in different variants. data Funny = I { john::Int } | IB { john::Int, mono::Bool } | B { mono::Bool }
09:39:05 <dmbarbour> I'm hoping Haskell' will have proper records, so we can reuse the names among different records. It's a little irritating, as is.
09:39:18 <EvanR-work> use a namespace
09:39:33 <EvanR-work> User.name Pet.name Car.name
09:39:48 <monochrom> I just want extensible records. Then we have OO.
09:40:51 <HugoDaniel> are there guidelines for haskell coding ?
09:41:12 <monochrom> yes. go with your heart.
09:41:38 <mornfall> monochrom: Of sorts, anyway.
09:41:56 <dmbarbour> Namespace doesn't make it any less irritating. I agree on extensible records. I'd rather not pull out Oleg's HList every time I want these features - I hate adding unnecessary dependencies.
09:42:07 <mornfall> monochrom: But you know about HList, don't you. :)
09:42:19 <monochrom> HList lacks subtyping.
09:42:31 <mornfall> monochrom: It has extensible records. That's what you asked for. :)
09:42:46 <quicksilver> I would not like to be able to re-use fields among records by any mechanism other than typeclasses
09:42:54 <monochrom> HList is yucky.
09:42:58 <dmbarbour> Oleg's "Overlooked Type System" does subtyping with records.
09:42:59 <quicksilver> the goal of a good record system, IMO, is for fields to be first class.
09:43:07 <dmbarbour> oops, Overlooked Object System
09:43:09 <quicksilver> that is a field should be a value and have a type.
09:43:23 <quicksilver> that means they could only belong to two records if overloaded
09:43:26 <quicksilver> (which would be fine)
09:43:42 <mornfall> quicksilver: Right.
09:43:42 <quicksilver> you can do most of I want with a decent package like fclabels or data-accessor
09:44:05 <monochrom> perhaps I should try HList
09:44:08 <mornfall> Presumably you still can't put the labels in a typeclass, can you?
09:44:09 <quicksilver> the existing haskell record notation I dislike precisely because it is not first class
09:44:26 <quicksilver> mornfall: well you have to give the real ones different names from the typeclass method, but that's OK.
09:44:34 <dmbarbour> quicksilver: what are your thoughts on small association list vs. small Data.Map?
09:44:40 <quicksilver> dmbarbour: Data.Map
09:44:44 <quicksilver> more convenient API
09:44:56 <quicksilver> dont' worry about speed until you've measured
09:45:02 <quicksilver> start with the thing which is easiest to program
09:45:05 <quicksilver> which, IMO, is Data.Map
09:45:15 <Twey> Unless you only need to do a lookup…
09:45:34 <quicksilver> yes, if you only ever need to lookup then the APIs are the same ;)
09:45:45 <Twey> Except that the assoclist has less creation noise
09:49:17 <mornfall> quicksilver: Well, overloading may be a bit tedious I guess.
09:49:42 <quicksilver> mornfall: a little. It's a one-off job and could be automated.
09:50:01 <quicksilver> I need more experience writing big programs using this stuff to have a more confident opinion ;)
09:50:08 <quicksilver> but I'm sure I want fields to be first-class values and have types.
09:51:56 <mornfall> Well, they don't have to be exactly fields. : - )) Lenses are a bit more general than fields.
09:52:32 <icedane> I'm writing a small convenience application for own use and it involves pasting links en mass into the shell, then doing some stuff with those links and then printing out the result. The problem is that if I paste say, 10 links, I will have to hit ctrl + z to make getContents realize that it's end of input. Is there any easy way to handle this differently?
09:53:18 <mornfall> icedane: You mean ^D (as opposed to ^Z)?
09:53:22 <icedane> mornfall: or that
09:53:27 <mornfall> Then, no.
09:53:53 <identity> Hahaha, I ctrl + z'd myself
09:53:59 <identity> well, it's ctrl + z on windows, I think
09:54:06 <identity> (that works on windows, anyway)
09:54:10 <mornfall> Well, if you know there are going to be exactly 10 lines, you can.
09:54:12 <mornfall> But in general, no.
09:54:24 <identity> That's inconvenient
09:54:27 <mornfall> (Or you can use a timeout, say, no new links for 5 seconds -> be done.)
09:54:45 <quicksilver> icedane: how else would you signal end of input?
09:54:45 <identity> I see. 
09:54:53 <identity> quicksilver: Meh, I don't know
09:55:00 <dmbarbour> I thought Lenses were more specialized than fields. (I'm thinking of Boomerang style Lenses.)
09:55:08 <mornfall> identity: you can fg your suspended client btw : - P
09:55:28 <quicksilver> dmbarbour: I think a lense is just a setter and a getter
09:55:31 <identity> mornfall: Haha, oops
09:55:35 <quicksilver> dmbarbour: which is, really, what a field should be.
09:56:02 <quicksilver> icedane: line at a time and signal with a timeout or an empty line seems possibly
09:56:07 <mornfall> quicksilver: Yes, but the getter/setter pair does not have to correspond to any data field in the record.
09:56:14 <quicksilver> in general, getContents is a force for evil.
09:56:18 <quicksilver> mornfall: yes, certainly.
09:56:27 <quicksilver> mornfall: fields are lenses but not all lenses are simple fields.
09:56:27 <identity> better.
09:56:28 <mornfall> Which is often quite useful, in fact.
09:56:49 <quicksilver> mornfall: however I think they subsume fields and this is precisely one of the godo things about them
09:57:01 <quicksilver> mornfall: if you had (non-first-class) fields you'd presumably have some operations you could do with fields
09:57:08 <quicksilver> which you couldn't do with arbitrary lenses
09:57:11 <quicksilver> and that would be a shame
09:57:17 <mornfall> quicksilver: Yes, acknowledged. The bad thing is that to get a setter or getter out of a lens, you need to apply them to something.
09:57:23 <quicksilver> that's part of the firstclass argument.
09:57:28 <mornfall> So you need to write get lens record, set lens record.
09:57:48 <quicksilver> mornfall: yes, or devise and then get comfortable with a set of infix operators which make you happy
09:57:58 <dmbarbour> thanks for the help, guys.
09:58:15 <mornfall> quicksilver: Well, the operations are ternary in nature, though.
09:58:20 <mornfall> quicksilver: The set one I mean.
09:58:27 <mornfall> (lens, record, new value)
09:59:27 <quicksilver> record^.field $= newvalue
09:59:29 <quicksilver> or some such.
09:59:37 <mornfall> Yeah.
09:59:43 <quicksilver> I've experimented with a variety of possible syntaxes
09:59:47 <quicksilver> can't decide what I like yet.
10:00:11 <mornfall> quicksilver: Well, I suppose making newvalue sectionable is important.
10:01:08 <EvanR-work> isnt there some record of the drawing boards the original 'designers' of record update syntax went through, and discarded, to come to their current form ;)
10:01:59 <mornfall> ...  This lets us write field^:subfield^:(2*) $ record, record$%field^:subfield^:(2*) or record$%field^:subfield^:(const 1).
10:02:06 <mornfall> Does this look like perl to anyone else?
10:16:46 <osaunders> http://chat.stackoverflow.com/rooms/61/haskell
10:34:40 <edon> how would you guys implement e function :: a -> [a] -> [[a]] that works like this: function 2 [1,2,3,2,4,5,6] = [[1],[2],[3],[2],[4,5,6]], finds the element given as the first argument and puts it in a list of its own, and so does to the elemnts that are before and after it
10:35:09 <edon> i've got a not so elegant solution with a takedrop p ls = (takeWhile p ls, dropWhile p ls), was wondering if there is something better
10:36:37 <ddarius> edon: I'd use the split package.
10:37:38 <siki> Anyone using haskellDB?
10:38:43 <kw317> Hello
10:38:48 <edon> ddarius: ok thanks, i've never used that before
10:39:16 <kw317> I've got a problem with iteratees
10:40:17 <c_wraith> cabal update takes a while to download package listings these days.  I wonder if it's time to start breaking the listing into diffs.
10:40:18 <kw317> I have an iteratee that reads a response from a socket, Iteratee :: ByteString m Response
10:41:08 <tolkad> Is the BSD license compatible with GPLv3?
10:41:16 <kw317> Problem is that when I use enumHandle with buffer set to 1024 or anything more than 1 byte, it's hanging on select
10:41:30 <kw317> Since the socket is blocking
10:41:46 <tolkad> nvm, I'll ask in #fsf
10:41:51 <FauxFaux> tolkad: BSD is free software; it's compatiable with pretty much everything.
10:43:01 <kw317> How to signal enumeratee that iteratee finished and it doesn't have to wait for more data?
10:43:02 <tolkad> the GPL explanaion page says it's only compatible with modified BSD
10:43:10 <maltem> kw317, is there, by accident, line buffering or some such set on the handle?
10:43:17 <tolkad> most haskell packages just say "BSD" in the cabal description
10:43:31 <FauxFaux> tolkad: There's a four-clause BSD license that literally nobody has used since 1990.
10:43:41 <kw317> maltem: I don't think so
10:43:48 <FauxFaux> Everything since then is the "modified".
10:44:09 <kw317> maltem: The server does not close the connection after sending the reply
10:44:21 <kw317> But there's nothing to read
10:44:35 <kw317> So I have to wait for timeout
10:45:17 <FauxFaux> tolkad: Apparently it was 1999, but, still, nobody has used it for ten years.
10:45:30 <maltem> Hmm, I don't think enumHandle "should" block when there's too little data to fill the buffer
10:45:39 <tolkad> FauxFaux: ah, thanks
10:46:18 <maltem> But it's hard to take a guess at what is going wrong here.
10:46:27 <kw317> strace shows it hangs in select
10:46:31 <siki> Does anyone have experience using HaskellDB? I've used it for a while now but I'm stuck trying to do a "GROUP BY" type of select now.
10:47:13 <shortcircuit> aristid: Feedback on you new package. It pings me a lot. Not that that's a legit complaint... :-|
10:47:36 <zygoloid> > let function e = groupBy ((==) `on` (== e)) in function 2 [1,2,3,2,4,5,6] -- edon
10:47:37 <lambdabot>   [[1],[2],[3],[2],[4,5,6]]
10:48:23 <edon> zygoloid: thanks, that's much neater
10:48:28 <zygoloid> edon: i'm not sure what you want to do with [1,2,2,3], though. that'll give [[1],[2,2],[3]]
10:49:13 <edon> zygoloid: ah, i want [[1],[2],[2],[3]]
10:51:20 <joe1> i have this script that takes a string and writes out all permutations of the string at http://pastebin.com/kgfXQwKN
10:51:32 <joe1> just wondering if you have any suggestions/improvements.
10:54:50 <joe1> it is basically  (unlines.map concat.concat.map permutationsOf .tail . powerset. splitEvery 1 ) (head.lines $ input)
10:54:55 <joe1> > (unlines.map concat.concat.map permutationsOf .tail . powerset. splitEvery 1 ) (head.lines $ input)
10:54:56 <lambdabot>   Not in scope: `permutationsOf'Not in scope: `powerset'Not in scope: `splitE...
11:00:49 <aristid> shortcircuit: lol, sorry. should have consulted you for the naming ;)
11:04:57 <HugoDaniel> i dont like list comprehensions
11:05:07 <HugoDaniel> ...there, i said it...
11:08:00 <mm_freak> me neither
11:09:19 * hackagebot todos 0.2 - Easy-to-use TODOs manager.  http://hackage.haskell.org/package/todos-0.2 (IlyaPortnov)
11:10:59 <HugoDaniel> ahah
11:11:02 <HugoDaniel> this must be a feat!
11:11:07 <HugoDaniel> Easy-to-use TODOs manager!!
11:11:33 <aristid> everybody writes todo managers
11:11:45 <HugoDaniel> really ?
11:11:51 <HugoDaniel> my todo manager is /TODO in vim 
11:11:52 <HugoDaniel> :P
11:12:05 <mm_freak> my todo manager is
11:12:09 <mm_freak> i could use a better one
11:12:32 <HugoDaniel> ok, so about list comprehensions
11:12:45 <HugoDaniel> i dont know what did the python guys saw in it :/
11:12:55 <mauke> well, it's python
11:12:58 <mauke> what did you expect
11:13:13 <HugoDaniel> hmm
11:13:25 <HugoDaniel> im not sure if i get your point mauke :)
11:13:31 <aristid> list comprehensions are nice for some things :)
11:13:51 <aristid> but in haskell they are not all that ubiquitous
11:13:55 <HugoDaniel> yes, i have used them once or twice, where i wanted a 2D array filled
11:14:36 <mm_freak> aristid: i found that i would always either prefer list function composition or do notation
11:16:32 <aristid> mm_freak: there's something list comprehensions can do that do notation + Monad functions cannot directly :)
11:16:40 <aristid> the zip thing
11:17:17 <HugoDaniel> the next thing i want to adop is
11:17:39 <HugoDaniel> having the name of all of my functions arguments start with an _
11:17:54 <HugoDaniel> so that while im reading the code, i know that the name refers to a function argument
11:18:05 <HugoDaniel> and not some let or where defined stuff
11:18:06 <joe1> is there a function to sort a list of lists by the length of each sublist?
11:18:19 <joe1> ["1","14","145","15","154","4","41"]
11:18:30 <zygoloid> > let function e = (\vs -> [[vs], map (:[]) vs]!!fromEnum (head vs == e)) <=< groupBy ((==) `on` (== e)) in function 2 [1,2,2,3,6,2,3,2,4,5,6]
11:18:31 <lambdabot>   [[1],[2],[2],[3,6],[2],[3],[2],[4,5,6]]
11:18:32 <joe1> sort the above as ["1","4",
11:18:55 <zygoloid> > sortBy (comparing length)  ["1","14","145","15","154","4","41"]
11:18:56 <lambdabot>   ["1","4","14","15","41","145","154"]
11:18:59 <joe1> sort the above as ["1","4","14","15"]
11:19:14 <joe1> cool, thanks a lot.
11:19:45 <HugoDaniel> bye
11:20:02 <joe1> where did you get the "comparing" function?
11:20:11 <aristid> @index comparing
11:20:11 <lambdabot> bzzt
11:20:15 <mm_freak> > do x <- [1,2,3]; y <- [4,5,6]; [(x,y)]
11:20:16 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
11:20:20 <mauke> @hoogle comparing
11:20:21 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
11:20:24 <mm_freak> @ aristid 
11:20:28 <joe1> thanks
11:20:32 <aristid> :t on compare
11:20:33 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
11:21:49 <ezrakilty> :t (compare `on` fst)
11:21:50 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
11:22:45 <adimit> If I want several ADTs to share 2 constructors, but differ in the other constructors, is there a way to do it, or should I rethink my problem?
11:25:46 <maltem> data SameConstructors = ; data TheOneType = One | SameConstructors; data TheOtherType = Other | SameConstructors -- ?
11:26:25 <identity> If I need a monad that allows me to report errors by appending an error to the current list of errors, is Writer the appropriate monad?
11:26:56 <writer> at least they use me for that purpose in examples
11:26:59 <maltem> (I forgot some constructor names there, hope nobody minds)
11:27:08 <identity> I need State(T), don't I? To modify the current state?
11:27:35 <adimit> maltem: sometimes, I'm blind. thanks.
11:28:10 <maltem> identity, the writer monad is specifically for appending / accumulating
11:28:40 <identity> maltem: ah
11:28:41 <identity> Thanks
11:29:21 <maltem> The terminology is a little confusing here, considering that the reader monad is not for incremental reading
11:29:51 <identity> I'll experiment, thanks :P
11:29:51 <Botje> it's also called the environment monad
11:30:57 <sioraiocht> you can define bind in terms of join, right?
11:31:32 <c_wraith> well, join and fmap
11:31:46 <sioraiocht> ah
11:32:18 <c_wraith> :t \x f -> join (fmap f x) 
11:32:19 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => m a -> (a -> m a1) -> m a1
11:32:20 <Twey> (>>=) = (join .) . fmap
11:32:22 <sioraiocht> cheers
11:32:43 <Twey> join = (>>= id)
11:32:56 <joe1> > filter (1 < length) [11,22]
11:32:57 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
11:32:57 <lambdabot>         against inferred ...
11:33:25 <joe1> > filter (1 < length) ["11","22"]
11:33:26 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
11:33:26 <lambdabot>         against inferred ...
11:34:19 <sioraiocht> why doesn't haskell have class Functor m => Monad m where?
11:34:29 <sioraiocht> (I know, this is probably a cliché question)
11:34:33 <c_wraith> it used to
11:34:47 <sioraiocht> people rebelled?
11:34:55 <c_wraith> I'm really not sure why it was removed.
11:35:03 <c_wraith> I think everyone wishes it wasn't
11:35:34 <nlogax> > filter ((> 1) . length) ["11", "22", "3"] -- @ joe1 
11:35:35 <lambdabot>   ["11","22"]
11:35:49 <ezrakilty> It forces you to define fmap for every monad.
11:36:18 <c_wraith> if you're really lazy, you can define it as liftM
11:36:33 <c_wraith> If there's a more efficient implementation, you can use that instead
11:36:33 <joe1> nlogax: thanks.
11:36:51 <sioraiocht> also, who finds defining "fmap" difficult/time-consuming
11:36:57 <sioraiocht> if they are building a monad?
11:36:59 <joe1> > filter (\x -> length x > 2) ["11","223"]
11:36:59 <lambdabot>   ["223"]
11:37:10 <nlogax> joe1: @pl is excellent for that stuff, if you write it like that first
11:37:12 <c_wraith> hell.  as of 6.12, GHC has an extension to derive Functor automatically
11:37:18 <nlogax> @pl \x -> length x > 2
11:37:18 <lambdabot> (> 2) . length
11:37:48 <c_wraith> Functor is not an interesting typeclass.  There's one correct implementation for anything of the correct kind.
11:38:06 <sioraiocht> does it? interesting
11:38:07 <joe1> nlogax: thanks, I use haskell once a month and it gets pretty confusing when I just look at the syntax for the first time.
11:38:22 <joe1> @pl is cool..
11:38:22 <lambdabot> (line 1, column 8):
11:38:22 <lambdabot> unexpected "."
11:38:23 <lambdabot> expecting variable, "(", operator or end of input
11:38:48 <nlogax> joe1: yeah. my haskell is weak. i have this in my .ghci file: :def pl return . (":!pointfree " ++) . show  
11:39:01 <nlogax> cabal install pointfree + that and you can :pl in ghci
11:39:17 <joe1> nlogax: thanks a lot.
11:39:59 <maltem> I thought @pl was just for having fun on #haskell
11:40:36 <nlogax> it's helpful for a noob :)
11:40:56 <nlogax>  @unpl too, of course
11:42:07 <maltem>  @unpl more so, I suppose. @pl gives you incomprehensible gibberish most of the time (unless you really missed an obvious opportunity to abbreviate)
11:42:29 <maltem> Btw "my haskell is weak" sounds like a movie quote
11:42:31 <joe1> > @unpl (unlines.sortBy (comparing length).filter (\x -> length x > 1). map concat.concat.map permutationsOf .tail . powerset. splitEvery 1 ) (head.lines $ input )
11:42:32 <lambdabot>   <no location info>: parse error on input `@'
11:42:39 <joe1> @unpl (unlines.sortBy (comparing length).filter (\x -> length x > 1). map concat.concat.map permutationsOf .tail . powerset. splitEvery 1 ) (head.lines $ input )
11:42:39 <lambdabot> (unlines (sortBy (comparing length) (filter (\ x -> (length x) > 1) (map concat (concat (map permutationsOf (tail (powerset (splitEvery 1 (head (lines input)))))))))))
11:42:45 <nlogax> eeek
11:43:17 <joe1> @pl (unlines (sortBy (comparing length) (filter (\ x -> (length x) > 1) (map concat (concat (map permutationsOf (tail  (powerset (splitEvery 1 (head (lines input)))))))))))
11:43:18 <lambdabot> unlines (sortBy (comparing length) (filter ((> 1) . length) (map join (permutationsOf =<< tail (powerset (splitEvery 1 (head (lines input))))))))
11:43:45 <Twey> Arrrgh
11:43:52 <nlogax> maltem: i often miss opportunities to use "obvious" functions, but things like \x -> omg x are easy of course :)
11:43:56 <Twey> That function is way, way too long
11:44:02 <nlogax> unpl shows those functions sometimes
11:44:12 <nlogax> uhh, pl i mean
11:44:35 <Twey> @unpl unlines (sortBy (comparing length) (filter ((> 1) . length) (map join (permutationsOf =<< tail (powerset (splitEvery 1 (head (lines input))))))))
11:44:35 <lambdabot> unlines (sortBy (comparing length) (filter (\ d -> (length d) > 1) (map (\ f -> f >>= \ e -> e) ((tail (powerset (splitEvery 1 (head (lines input))))) >>= permutationsOf))))
11:44:50 <Twey> That was not as bad as I thought it would be.
11:45:17 <joe1> i do not know where that =<< came from..
11:45:34 <joe1> @pl (unlines.sortBy (comparing length).filter (\x -> length x > 1). map concat.concat.map permutationsOf .tail . powerset. splitEvery 1 ) (head.lines $ input )
11:45:34 <lambdabot> unlines (sortBy (comparing length) (filter ((> 1) . length) (map join (permutationsOf =<< tail (powerset (splitEvery 1 (head (lines input))))))))
11:45:42 <mauke> joe1: concatMap
11:46:13 <mauke> also, not . null . drop 1
11:47:06 <robogeoff> trying to convert a string-based module to one that uses bytestring, is there an equivalent to read?  i.e. something like readBS :: Read a => ByteString -> a
11:47:18 <identity> Aah, I have replicated "comparing" way too often
11:47:20 <joe1> i like my function better, easier to understand
11:47:26 <shachaf> "length" isn't is as bad as "head" and "tail", but it should still have a name to reflect that it's often not a good idea.
11:47:33 <identity> robogeoff: try hoogle
11:47:33 <shachaf> Maybe "unwiseLength".
11:47:54 <adimit> maltem: Your solution unfortunately doesn't work here. GHCi will complain of multiple declarations. So, you can have data SameConst = A | B; data One = One | SameConst. But when you add data Two = Two | SameConst, GHC doesn't like it :-|
11:48:09 <djahandarie> shachaf, what's unwise about length?
11:48:17 <Twey> unlines . sortBy (comparing length) . filter ((> 1) . length) . map concat . concatMap permutationsOf . tail . powerset . splitEvery 1 . head . lines $ input
11:48:23 <shachaf> djahandarie: In a context like "(\x -> length x > 1)"?
11:48:28 <osaunders> http://stackoverflow.com/questions/3945112/polymorphic-class-constrained-instances
11:48:46 <djahandarie> @type (\x -> length x > 1)
11:48:47 <lambdabot> forall a. [a] -> Bool
11:49:08 <nlogax> would take a long time on infinite lists
11:49:27 <djahandarie> That's like saying any > O(1) operation on an infinite structure is "unwise"
11:49:27 <shachaf> nlogax: And would take a logn time on finite lists.
11:49:41 <shachaf> Er, n.
11:50:03 <shachaf> Anyway.
11:50:23 <shachaf> djahandarie: I meant "unwise" because people often misuse it.
11:51:04 <Twey> joe1: But frankly, it's too damn long.
11:51:06 <shachaf> Obviously it does have its uses. And with Nat it would even do what you want.
11:51:07 <Twey> joe1: Break it up.
11:51:10 <djahandarie> People need to understand the data structures they are using otherwise they are going to have bigger problems.
11:51:41 * hackagebot haskelldb 2.0.1 - A library of combinators for generating and executing SQL statements.  http://hackage.haskell.org/package/haskelldb-2.0.1 (JustinBailey)
11:53:04 <joe1> Twey: thanks for your suggestion. I like your version better. 
11:53:38 <joe1> Twey: i incrementally built it up using ghci.
11:53:52 <Twey> joe1: Needs more helper functions
11:54:34 <maltem> adimit, yeah I was being sloppy (aka wrong) there, the right syntax would be  data One = One | OneSame SameConst; data Two = Two | TwoSame SameConst
11:54:36 <Twey> ((> 1) . length) is better written as (not . null . drop 1), too, as I think someone else said earlier
11:54:48 <Twey> length will traverse the whole list
11:55:39 <adimit> maltem: yeah, that was the kind of thing I wanted to do differently :-P I guess I'm overly afraid of boilerplate. Probably no biggie to just do it that way.
11:55:43 * hackagebot hlint 1.8.1 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.1 (NeilMitchell)
11:55:51 <joe1> Twey: oh, ok. that was what mauke was pointing out earlier. I had no clue what he wast talking about.
11:56:22 <aristid> why does Read make it so confusing to write instances for it? oO
11:56:26 <joe1> mauke: thanks, I did not get what you were saying earlier.
11:57:50 <maltem> aristid, the Read interface is fairly antique compared to the monadic parsers we are used to today
12:01:08 <res> @unpl \a -> map (f a)
12:01:08 <lambdabot> \ a -> map (f a)
12:01:29 <Funktorsalat> hmm ReadP?
12:05:18 <aristid> Funktorsalat: oh, i just want to write a Read instance for something very simple.
12:06:03 <Funktorsalat> (apparently what I meant is called ReadPrec)
12:06:21 <Funktorsalat> never used it though
12:15:53 * hackagebot language-c-comments 0.2 - Extracting comments from C code  http://hackage.haskell.org/package/language-c-comments-0.2 (GeoffHulette)
12:21:04 <identity> Every time I delve deeper into haskell by using some of the more advanced features, I am amazed by how awesome everything is and how.. much sense it makes
12:21:07 <identity> it's hard to explain
12:21:19 <identity> But I just used the writerT on IO to report errors and so on, and it just works out so incredibly well
12:26:29 <djahandarie> byorgey, do you have a repo or something somewhere where your changes to GHC are being made? I'd be fairly interested in following that
12:36:30 <conal> i have a character-set-newbie question.  when i use simpleHttp from the http package, my special utf-8 chars turn into 3 chars.  how might i keep them in utf8, or convert back after my processing?
12:36:49 <Twey> conal: They are already in UTF-8
12:37:02 <Twey> conal: (UTF-8 uses three bytes for a lot of characters)
12:37:23 <Twey> However, whatever you're using to view/analyse them, the thing that *says* they're three characters, is not interpreting the text as UTF-8
12:37:53 <conal> Twey: yeah.  unlike readFile on similar text.
12:37:57 <Twey> If you're viewing them in a Web browser and they show up as three characters, it's likely that you've not sent the Content-Type header properly
12:38:13 <Twey> Otherwise, there's probably a library function to tell it what encoding to use
12:38:17 <byorgey> djahandarie: there is, but I haven't pushed anything of much interest to it yet
12:38:31 <byorgey> djahandarie: keep poking me periodically =)
12:38:40 <djahandarie> byorgey, hehe okay, thanks
12:38:42 <byorgey> identity: =)  I know the feeling you mean
12:38:53 <conal> Twey: they show up fine in my browser before my haskell-based processing.  
12:39:01 <McManiaC> Twey: you can use bytestring converting: toString . pack (from Data.ByteString & Data.ByteString.UTF8)
12:39:17 <McManiaC> works for me
12:39:17 <McManiaC> :
12:39:18 <McManiaC> :)
12:39:44 <Twey> conal: You need to describe your setup in a bit more detail: what processing are you doing?  How are you viewing them ‘without processing’, exactly?  Accessing the file directly, or still passing them through simpleHttp?
12:39:58 <McManiaC> * conal I meant, sorry
12:40:49 <conal> darn.  i have to go.  will be back later.  thanks much for the help so far.
12:41:04 <conal> Twey: yeah, and sry for not explaining more clearly the first time.
12:41:20 <Twey> That's okay
12:43:52 <identity> byorgey: Hehe, it is simply awesome
12:44:19 <identity> I find that some problems' solutions are really inelegant until you recognize that you need some monad/transformer and then it's all smooth sailing
12:58:41 <joe1> is there a tool that you use for pastebin?
12:58:55 <joe1> i notice that hpaste had some compilation warnings.
12:59:09 <joe1> and pastebinit does not have syntax highlighting
13:02:30 <identity> joe1: what do you mean by 'compilation warnings'? The warnings at the bottom?
13:02:35 <identity> and what's so bad about using hpaste?
13:03:14 <c_wraith> identity, hpaste runs hlint, and shows its output on the bottom of pastes.  I don't know why you'd dislike that, though
13:03:31 <identity> c_wraith: Yes, I know, I was just making sure that's what he meant
13:03:59 <identity> or if he was referring to some errors hpaste was giving him as "compilation errors"(As hpaste has been down relatively often recently)
13:06:39 <ezyang> Hmm, I wonder how you add to the common args set. 
13:07:03 <ezyang> (in cmdargs) 
13:08:59 <c_wraith> uh-oh.  I've just got this brilliant idea to reinvent factories in haskell.
13:09:30 <Twey> Oh-oh
13:09:58 <aristid> c_wraith: quick, drown it in... alcohol, water, whatever
13:10:20 <monochrom> factory = smart constructor.
13:10:25 <c_wraith> I think it's really what this problem requires, though.  I'll be careful not to name it FactoryFactory anywhere.
13:10:53 <Twey> >.>
13:11:21 <Raghs> my ghci crashes with getMBlocks: VirtualAlloc MEM_COMMIT failed
13:11:29 <Raghs> hwo can i extend the allocation?
13:12:29 <c_wraith> uh.  That failing generally means your system is out of RAM *and* swap, if I'm reading it right.
13:13:16 <ezyang> Is Hackage 2 chilling out somewhere right now? 
13:13:22 <identity> something like that, yeah @ error
13:13:42 <Raghs> hmm. i have 4gb ram
13:13:42 <c_wraith> ezyang, yes there's a public beta of it *somewhere*, though I don't recall where.
13:13:51 <aristid> @hoogle count
13:13:52 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
13:13:52 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
13:13:52 <lambdabot> Data.ByteString.Lazy count :: Word8 -> ByteString -> Int64
13:14:08 <identity> Raghs: ghci isn't quite perfect. It has the tendency to continue taking up ram after Ctrl+c'ing computations that are heavy and so on
13:14:15 <djahandarie> ezyang, http://sparky.haskell.org:8080
13:17:28 <joe1> identity: yes, no while doing cabal install
13:18:52 <joe1> identity: sorry it was haste with all those errros
13:19:37 <mariano|godot> what's the envvar to set the editor used by :e in ghci?
13:20:26 <kmc> $EDITOR probs
13:20:31 <joe1> There is no available version of HAppS that satisfies >0.8.4
13:20:41 <caelan> ghc(1) may help
13:20:42 <joe1> the above is what i get with hpaste on debian testing
13:21:29 <joe1> donot bother. did not have happstack.
13:21:33 <joe1> just installing it.
13:21:47 <mariano|godot> caelan, I did look there before asking :)
13:22:18 <caelan> mariano|godot: okay, it was just my instinctive answer :)
13:27:01 <joe1> how do i install HApps 0.8.4 on debian. happstack does not seem to satisfy the requirement. any suggestions, please?
13:29:51 <kmc> there's a bunch of packages named HAppS-* on hackage
13:29:53 <kmc> but not going back to 0.8.4
13:29:59 <kmc> it might not have been cabalized back then
13:30:18 <kmc> in which case you'd have to find an old tarball or a darcs repo or something
13:30:52 <byorgey> joe1: out of curiosity, why are you trying to install hpaste?
13:31:39 <kmc> 'hpaste' is the old hpaste codebase
13:31:52 <kmc> the new one is http://github.com/chrisdone/amelie
13:32:06 <byorgey> indeed, the current hpaste was just put up by chrisdone a few weeks ago
13:32:09 <joe1> i am trying to get some decent utility to paste code to pastebin.com or hpaste.org
13:32:26 <kmc> ah, then why are you trying to set up your own pastebin?
13:32:27 <djahandarie> A web browser? ;)
13:32:31 <joe1> i used pastebinit, but it does not support many options.
13:32:40 <kmc> there's a couple of those on hackage
13:32:54 <joe1> sorry, I did not realise that hpaste is used to setup pastebin.
13:32:54 <kmc> pb, haste, PastePipe, codepad
13:33:03 <kmc> yes
13:33:06 <kmc> HAppS is a web framework
13:33:59 <joe1> haste thrws up a bunch of compilation warnings
13:34:14 <joe1> while doing cabal install haste
13:34:18 <byorgey> unfortunately it looks like neither haste nor PastePipe have been updated in a while
13:34:38 <byorgey> joe1: just wait a few weeks, I bet someone will come out with a program for pasting to the new hpaste.org
13:34:39 <kmc> maybe fixing one of them up would be a good project?
13:34:42 <byorgey> or write it yourself
13:34:44 <byorgey> yeah =)
13:35:14 <byorgey> there used to be an emacs plugin for posting to hpaste too
13:35:19 <joe1> byorgey: yes, i am having errors from haste and pastepipe
13:35:33 <kmc> i won't be happy until i can tweet pastes from my facebook wall
13:35:51 <joe1> pastebinit, a python script, works but does not support any options.
13:36:10 <djahandarie> kmc, brilliant!
13:36:39 * byorgey tries installing PastePipe
13:37:56 <byorgey> ah, I think it has not been updated to work with the newest version of cmdargs
13:38:15 <byorgey> and it naughtily does not specify a version upper bound for its dependence on cmdargs
13:38:20 <joe1> this is what it says: HTTP/1.1 404 Not Found
13:38:34 <byorgey> it probably wouldn't be too hard to fix up.
13:38:55 <byorgey> joe1: that's what what says?
13:39:42 <identity> joe1: The simpleHTTP lib would let you write an app for that pretty easily
13:40:05 <joe1> byorgey: when I try pastepipe from the command line
13:40:18 <byorgey> joe1: oh, you got it to compile?
13:40:26 <joe1> using cat <filename.hs>| pastepipe -v -l haskell
13:40:36 <joe1> yes, with cabal install pastepipe
13:40:48 <mariano|godot> pastepipe -v -l haskell < filename.sh
13:40:51 <byorgey> ok, perhaps you already had an older version of cmdargs installed
13:40:58 <mariano|godot> otherwise you get a Useless Use of Cat mention
13:41:37 <joe1> mariano|godot; does not work, still
13:41:38 <aristid> have i ever ranted that curl is the only usable http library because none other supports SSL and more than mere URL downloading?
13:41:48 <joe1> Creating new connection to hpaste.orgReceived:
13:41:48 <joe1> HTTP/1.1 404 Not Found
13:42:13 <mariano|godot> joe1, I was only commenting on the way you used a pipe, not suggesting a solution! see <http://partmaps.org/era/unix/award.html>
13:42:33 <joe1> oh, ok.
13:42:57 <joe1> identity: looks like that is the only option. will get to it in the next few days.
13:44:04 <byorgey> joe1: I think your best option is to help fix up PastePipe, not write something new from scratch.
13:45:41 <byorgey> mariano|godot: that's ridiculous.  As if the goal of shell scripting is to minimize keystrokes and processes.
13:46:11 <byorgey> cat filename | foo  is perfectly reasonable, and corresponds nicely to a left-right compositional style
13:46:24 <byorgey> "first get the contents of filename; then process it using foo; then ..."
13:46:54 <monochrom> I like my hair colour to be monochrome
13:47:04 <aristid> byorgey: it uses lazy strings too ;)
13:47:21 <byorgey> indeed =)
13:48:33 <maltem> And it does not suffer the resource exhaustion problem as typical of interleaved IO.
13:51:12 <mariano|godot> aristid, < is not strict...
13:51:29 <aristid> mariano|godot: huh? did i claim that?
13:51:59 <mariano|godot> in any case, this is a standard joke so old to be reasonably considered ancient
13:52:10 <mariano|godot> thatpeople take the objection seriously is a testament to that
13:55:41 <ezyang> What's the most compact way to get a record update function? 
13:55:58 <ezyang> (without using any of the fancy record libraries. GHC extensions are ok.) 
13:56:23 <Saizan> write one?
13:56:36 <monochrom> type-class it yourself
13:56:44 <ezyang> I'm thinking maybe \r varName -> r {..} 
13:56:45 <monochrom> or TH it yourself
13:57:29 <monochrom> \r f x -> r{f=x}  does not work
13:57:31 <ezyang> TH might not be a bad idea. 
13:58:28 <kmc> err, if you're rolling your own TH, why not use an existing fancy record library like fclabels instead
13:58:53 <monochrom> my sentiment too but I don't want to be pushy
13:58:53 <ezyang> I don't need anything fancy; it's a one shot deal. 
13:59:08 <kmc> i suspect that this is yet another case where a little dumb text-expanding macro preprocessor would be a lot nicer to use than some gruesome TH AST-munger
13:59:31 <ezyang> plausible 
13:59:47 <monochrom> slap m4 on it :)
14:00:07 <kmc> yup
14:00:23 <kmc> {-# OPTIONS_GHC -F -pgmF m4 #-}
14:00:32 <ezyang> yarrr. 
14:00:35 <kmc> but, maybe CPP is good enough
14:00:42 <monochrom> m4 is the macro language of choice of discriminating ocaml programmers :)
14:00:43 <kmc> i'm trying to figure out what people need from a preprocessor
14:00:46 <kmc> and then maybe implement it
14:00:53 <kmc> monochrom, really?
14:01:04 <monochrom> 70% certainty
14:04:45 <ezyang> Ok, wrote a nice #define PUT(field) (\x r -> return (r {field = x})) 
14:05:06 <osaunders> Is there anything about -XGeneralizedNewtypeDeriving or -XDeriveFunctor that is frowned upon?
14:05:18 <ezyang> osaunders: No, it's fine. 
14:05:24 <osaunders> Schweet
14:05:25 <kmc> i'm fine with those
14:05:46 <osaunders> Writing out functors gets kinda boring.
14:05:49 <kmc> there is http://hackage.haskell.org/trac/ghc/ticket/1496
14:08:00 <ezyang> @hoogle a -> (a -> b) -> b 
14:08:01 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:08:01 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
14:08:01 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
14:08:07 <ezyang> bah, humbug 
14:08:21 <aristid> @src transpose
14:08:22 <lambdabot> transpose []             = []
14:08:22 <lambdabot> transpose ([]   : xss)   = transpose xss
14:08:22 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
14:08:46 <monochrom> sorry, I mixed up m4 and camlp4. camlp4 is the macro language of choice of discriminating ocaml programmers.
14:08:59 <monochrom> (why do they like the number 4 so much?)
14:10:27 <monochrom> @quote monochrom macro
14:10:28 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
14:11:19 <aristid> @hoogle [a] -> Maybe a
14:11:19 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
14:11:19 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
14:11:19 <lambdabot> Prelude head :: [a] -> a
14:12:10 <ezyang> Does Haskell seriously not have a getpass function... 
14:12:32 <aristid> @src last
14:12:32 <lambdabot> last [x]    = x
14:12:33 <lambdabot> last (_:xs) = last xs
14:12:33 <lambdabot> last []     = undefined
14:12:48 <monochrom> haskell seriously does not have a getpass function. but I fake one with setEcho or something anyway
14:13:05 <monochrom> hSetEcho
14:13:47 <identity> What about clipboard support?
14:13:50 <identity> I found clipboard
14:14:07 <identity> it crashes with some obscure FFI error regarding a handle when I use setClipboardString
14:14:15 <monochrom> you need X binding or GUI lib for clipboard
14:14:25 <identity> I'm using windows
14:14:31 <identity> though I would very much like it to be cross plaftorm
14:14:35 <identity> as everything else is
14:14:58 <monochrom> is setClipboardString a binding to win32?
14:15:21 <identity> Yep
14:16:40 <identity> getClipboardString works
14:16:41 <monochrom> sorry, I don't know how to use win32
14:16:44 <identity> kk
14:23:39 <tedm> Has anyone tried building ghc for amd64 on OS X lately?
14:25:34 <tedm> ...I guess not 
14:32:48 <rubendv> tedm: I just got the binary with the haskell platform
14:32:52 <ezyang> This ought to be a lib function somewhere. http://hpaste.org/40610/getpass 
14:33:05 <rubendv> if you want 64 bit code generation, that doesn't exist for OS X yet.
14:34:21 <tedm> rubendv: Ya - that's only the i386 build though. There are a couple of tracker bugs ( #2965 and #4163 ) that relate to getting the 64-bit build working...
14:34:49 <rubendv> afaik the 64 bit build still does 32 bit code generation only
14:35:01 <tedm> but I was wondering how that might be going. #ghc seems to be pretty dead right now. I was actually wondering whether they needed anyone to help get it working
14:35:52 <tedm> The haskell package that I have (6.12.3) is both i386 executables, and generates i386 executables. It's 32-bit across the board
14:37:12 <tedm> I'd like to help out, but I don't want to generate noise with naive questions/suggestions on the mailing lists if someone is already working on it.
14:41:03 <Martty> > "hi" `isInfixOf` "ahio"
14:41:04 <lambdabot>   True
14:41:18 <Martty> i used haskell today at the interview \m/
14:42:57 <aristid> Martty: but it's not a haskell shop?
14:43:15 <Martty> no
14:43:55 <taktoa> I have a question
14:44:03 <taktoa> let's say I have a list of bools
14:44:12 <taktoa> that follows the format
14:44:33 <aristid> *patiently waiting for taktoa*
14:44:37 <taktoa> (repeat n False ++ infinity of trues
14:44:47 <aristid> ok
14:44:53 <taktoa> how can I extract n
14:45:03 <aristid> length . takeWhile not
14:45:09 <taktoa> thanks
14:45:35 <aristid> wow, i was pretty fast
14:45:42 <monochrom> you have flooded off augustss
14:45:48 <aristid> yes :/
14:46:22 <monochrom> you and your twitter habit of "every line must be shorter than 10 words"
14:47:50 <quuxman> are there any dynamically typed implementations of Haskell?
14:48:08 <dolio> That wouldn't be Haskell.
14:48:39 <wlangstroth> if I say "Clojure", I'm pretty sure I'll get fruit thrown at me
14:48:50 <dolio> Clojure isn't Haskell.
14:49:00 <quuxman> I want the benefits of Python and Haskell at the same time :)
14:49:06 * EvanR-work throws fruit at wlangstroth 
14:49:07 <monochrom> just add #! /usr/bin/runghc to your haskell file. then type errors occur at runtime only.
14:49:16 <EvanR-work> wait python has benefits?
14:49:21 <quuxman> wlangstroth: clearly I'm suffering from a Python / Haskell decision crisis right now
14:49:30 <wlangstroth> quuxman: clearly
14:49:30 <arw> EvanR-work: yes, your code is always properly indented.
14:49:36 <EvanR-work> oh right
14:49:42 <Martty> you can code haskellish code in python
14:49:43 <wlangstroth> dolio: really?
14:49:45 <dobblego> @remember monochrom just add #! /usr/bin/runghc to your haskell file. then type errors occur at runtime only.
14:49:45 <lambdabot> Done.
14:49:48 <monochrom> adga and epigram etc have the benefits of python and haskell at the same time
14:49:53 <zakwilson> Erlang and Clojure are languages with dynamic typing and some of the features of Haskell, but if it has dynamic typing, it isn't Haskell.
14:49:56 <monochrom> agda
14:49:58 <EvanR-work> Martty: not without pattern matching and algebraic data types
14:50:05 <Martty> ish 
14:50:07 <Martty> ish!!
14:50:10 <EvanR-work> and type safety
14:50:18 <zakwilson> (well, dynamic typing not encapsulated in a static type system, anyway)
14:50:40 <dobblego> I once tried to code haskellish in python, but I gave up and kept doing it in java -- it's not even close to possible
14:50:43 <EvanR-work> why do you want dynamic typing
14:50:46 <quuxman> dolio: I think what I was really asking is if there's a language like Python that has algebraic data types and pattern matching
14:50:51 <aristid> zakwilson: c++ doesn't have dynamic typing. is it haskell?
14:50:58 <monochrom> dynamic type is poor man's dependent type
14:51:09 <EvanR-work> dynamic typing gets in the way
14:51:22 <aristid> it lets you write a better on tho
14:51:42 <dolio> quuxman: There probably is. I'm not sure I can name any, though.
14:52:01 <monochrom> people hate algebra. that's why they go oo
14:52:18 <wlangstroth> monochrom: haha!
14:52:19 <dolio> I don't really consider "dynamic typing" to be a benefit, though. Getting rid of the type system would be eliminating a benefit of Haskell.
14:52:23 <monochrom> they and their overrated obsession with extensibility
14:52:30 <quuxman> monochrom: yeah, a very unfortunate influence on Computer Science
14:52:41 <quuxman> monochrom: er, I mean software engineering
14:52:43 <zakwilson> aristid: that wolud be affirming the consequent.
14:53:27 <monochrom> they say, "oh, what if I will add an extra case next year?" my answer, "next year you will be laid off anyway"
14:53:29 <wlangstroth> dolio: the funny thing about dynamic typing (and I'm thinking of Clojure) is that performance is always made into an issue, so then type coercion, and ...
14:54:22 <dolio> It's not immediately clear to me how algebraic types translate into dynamic typing, either.
14:54:35 <EvanR-work> dynamic typing seems to me to be a design choice based on the inability of the designer to come up with a way to get the types straight at compile time / run time
14:54:43 <dolio> What do you get to match on in a particular case statement? Any constructor from any type anywhere?
14:55:38 <EvanR-work> you obviously only match on constructors of a single type, because otherwise youre getting mixed up
14:55:58 <zakwilson> Dynamic typing is useful for things when the type can't be known until run time. I don't have a proof, but I believe there are situations where it's equivalent to the halting problem.
14:55:58 <EvanR-work> you usually really want to handle 1 type
14:56:18 <EvanR-work> or a type that satisfies 1 or more interfaces
14:56:26 <EvanR-work> but thats not pattern matching
14:56:34 <nimred> what emacs mode do you suggest ?
14:56:42 <devinus> could anybody tell me how close ghc 7 is to being released? (curious :D)
14:57:12 <kmc> devinus, there are release candidates out
14:57:17 <petafile> I want to print multiple things in my main function.  How do I do that?  I just tried print thing1 \n\t\t print thing2 ... and I get type errors thinking that I'm giving more arguments to print (I think)
14:57:22 <dolio> I suspect there'll be at least one more release candidate before it's released for real.
14:57:42 <devinus> dolio: how long do releases between rc's usually last?
14:57:42 <kmc> quuxman, any Lisp can support arbitrarily fancy pattern-matching syntax via macros
14:57:55 <kmc> there's some articles about pattern-matching macros for Clojure
14:58:01 <EvanR-work> in which case the question is whats the point of dynamic typing... and it turns out to be 'i cant tell whether the correct type will show up here until runtime, for whatever reason'
14:58:03 <quuxman> kmc: good poni :)
14:58:09 <quuxman> kmc: er, point
14:58:28 <kmc> and, as someone else pointed out, Erlang has pattern matching and is essentially dynamically typed
14:58:30 <EvanR-work> if its right, pattern match, if its not runtime error we typically see from these systems
14:58:36 <EvanR-work> 'you tried to lookup a property in a non object'
14:58:48 <kmc> of course dynamic typing is just a degenerate case of static typing
14:59:15 <monochrom> http://www.vex.net/~trebla/humour/Nightmare.java
14:59:19 <kmc> a type system like Haskell's lets you do dynamic typing when you need to, which is not very often
14:59:37 <kmc> quuxman, most supposed use cases for dynamic typing are handled either by polymorphism or by sum types
14:59:40 <sioraiocht> are you referring to unsafeCoerce?
14:59:41 <quuxman> kmc: yep... at some point, you need to know what opcodes to call
14:59:48 <EvanR-work> we think of expecting a certain type in our scripts, be it a type representable in haskell or not, *that* is static, so whats the point of the dynamic
14:59:55 <kmc> it's kind of gross to use the type system itself as a single, global, ad-hoc sum type
15:00:13 <kmc> sioraiocht, no, I'm referring to Typeable, Dynamic, existentials, etc.
15:00:17 <kmc> some of which is implemented with unsafeCoerce
15:00:21 <sioraiocht> kmc: ah, I understand
15:00:21 <kmc> but provides a safe API
15:00:33 <kmc> (the Typeable API is not as safe as I'd like, though)
15:00:46 <EvanR-work> how so, the representation of types?
15:01:12 <kmc> if you write your own Typeable instance and screw up
15:01:16 <EvanR-work> ah yeah
15:01:20 <kmc> then you can do things as bad as arbitrary unsafeCoerce
15:01:26 <kmc> this is why you should only derive Typeable
15:01:34 <EvanR-work> its derivable?
15:01:45 <kmc> -XDeriveDataTypeable
15:01:53 <EvanR-work> cool
15:02:00 <zakwilson> I sometimes find static typing annoying. As an example, I had some code that used both Data.Map and Data.IntMap. They mostly support the same operations, but I had to either handle them separately or create a typeclass. A language with dynamic typing would not require the extra effort.
15:02:03 <nimred> what haskell mode do you suggest for emacs ?
15:02:16 <kmc> zakwilson, but there's ways to handle that in a statically-typed language
15:02:19 <EvanR-work> so haskell is now the best imperative dynamically typed language ;)
15:02:22 <kmc> for example first-class modules
15:02:38 <kmc> i'm not sure a typeclass is the best solution
15:02:40 <EvanR-work> define new dynamic types
15:03:00 <monochrom> emacs mode for haskell: http://projects.haskell.org/haskellmode-emacs/
15:03:04 <kmc> you can just make a record full of their functions
15:03:09 <kmc> which is like a poor man's first class module
15:03:16 <kmc> (more so if you allow existential quantification)
15:03:17 <zakwilson> On the other hand, I ported some Haskell code to Clojure and spent a lot of mental effort reasoning about whether things were the correct type. The Haskell compiler would have just told me.
15:03:46 <nimred> monochrom i am trying it at the moment but can not figure out wich way to indent...
15:04:32 <EvanR-work> zakwilson: see, we think about static types (perhaps polymorphically in your example) and we strive to ensure that despite lack of compiler support
15:04:59 <EvanR-work> so i think dynamic typing is just lack of static type support, not a feature
15:05:11 <EvanR-work> its a missing feature
15:05:12 <monochrom> tutorial at http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
15:05:44 <monochrom> choose 'turn-on-haskell-indentation
15:06:24 <kmc> there is a tendency to use type classes when they're not necessary
15:06:26 <nimred> monochrom yes i already set ti : (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
15:06:35 <nimred> but indentation is stragne
15:06:51 <EvanR-work> kmc: im trying to understand how to do what zakwilson without a type class
15:06:59 <zakwilson> I find that whichever sort of type system I'm using, I miss aspects of the other on occasion. Before finding Haskell, I was a bit religious as a fan of dynamic typing. Now, I don't think one is better than the other. Haskell "feels right" to me for certain problems, and the type system is part of the reason for that. It also feels wrong for certain problems, which I'm sure is partially due to my lack of expertise.
15:08:12 <EvanR-work> kmc: a record with the operations on a polymorphic type, and a field of that type?
15:08:13 <kmc> data MapStuff k v = forall m. MapStuff { empty :: m; insert :: k -> v -> m -> m; lookup :: k -> m -> Maybe v }
15:08:19 <kmc> yeah
15:08:33 <kmc> it gets harder to do things like "union"
15:08:33 <EvanR-work> and this is where existentials are supposedly better
15:09:07 <EvanR-work> is what you wrote valid haskell? or valid with extensions?
15:09:18 <kmc> valid GHC Haskell
15:09:23 <kmc> -XExistentialQuantification
15:09:31 <monochrom> in a new empty file, start typing: main = do <enter> x <- getLine <enter> case x of [] -> return () <enter> _ -> putStrLn x <enter> <backspace> <backspace> putStrLn "bye"
15:09:40 <kmc> MapStuff :: m -> (k -> v -> m -> m) -> (k -> m -> Maybe v) -> MapStuff k v
15:09:44 <kmc> note that 'm' does not appear in the return type
15:09:53 <kmc> (it might be better to define it that way, with GADT syntax)
15:10:15 <monochrom> observe that the computer is almost psychic
15:10:15 <raghs> how can i split a large string into substrings - substrs :: Integer -> String -> [String] 
15:10:38 <bblum> there is nobody from the <$>/<*> family whose type is f(a -> b) -> a -> fb, is there?
15:10:40 <EvanR-work> raghs: chunk?
15:10:46 <bblum> hoogle didn't help me
15:10:57 <dolio> bblum: Not predefined.
15:11:10 <hpc> it can be constructed
15:11:13 <EvanR-work> @pl (\f g -> pure f <*> g)
15:11:13 <lambdabot> (<*>) . pure
15:11:18 <EvanR-work> bblum: ^ ?
15:11:31 <EvanR-work> i misread the types 
15:11:33 <EvanR-work> oh well
15:11:35 <dolio> In lambdabot, it's actually called flip.
15:11:41 <dolio> But I wouldn't recommend that.
15:11:50 <dolio> I like eta, but that's me.
15:12:00 <EvanR-work> @pl (\f g -> f <*> pure g)
15:12:01 <lambdabot> (. pure) . (<*>)
15:12:10 <hpc> :t pure
15:12:10 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
15:12:15 <bblum> yeah, i mean, i'll just use a 'do' construct
15:12:40 <ddarius> dolio: Why eta?
15:12:48 <bblum> but it would be nice to like. foo <$> bar <&> baz <*> quux
15:13:04 <dolio> ddarius: Because it corresponds to eta expansion in impure languages.
15:13:08 <EvanR-work> looks like heiroglyphs now ;)
15:13:42 <ddarius> monochrom: I'm looking at this Nightmare.java and the first line is class Nil extends Exception and I'm already liking it.
15:14:00 <monochrom> I'm glad you like it.
15:14:26 <EvanR-work> :t (. pure) . (<*>)
15:14:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
15:14:47 <dolio> You can actually write it with just Functor.
15:15:04 <dolio> :t \f x -> ($x) <$> f
15:15:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
15:15:32 <monochrom> next year I'll scam all of you for money so I can buy a fancy video camera so I can shoot a video of how easy it's to use haskell emacs mode indentation and upload to youtube so all of you see it's PEBKAC if you can't "get it to work" as in you probably just overcomplicate things.
15:16:09 <hpc> @let f <&> x = ($ x) <$> f
15:16:11 <lambdabot>  Defined.
15:16:33 <ddarius> monochrom: Indeed, anyone using emacs has already overcomplicated things.
15:16:37 <monochrom> I mean, really, 90% of the time you just hit <enter> and it's already at the right indentation; the other 10% of the time you hit <backspace> 1-3 times and it's right again.
15:16:55 <Adamant> uh, wat?
15:17:30 <Adamant> ddarius: the same argument applies to anyone using vim and not vi or ed :P
15:17:44 <ddarius> Adamant: ed is too complicated.
15:18:14 <Adamant> ddarius: feckin' butterflies focusing cosmic rays, how does that work
15:18:15 <hpc> computers are too complicated :P
15:18:23 <ddarius> hpc: Agreed.
15:18:27 <monochrom> it's "simple" to shake a piece of magnet near the hard disk, but I am not sure I want to do that.
15:18:32 <Adamant> I'm totally going back to PLC
15:18:40 <hpc> rocks in an infinite desert, all the way
15:18:46 <hpc> (across the sky)
15:18:55 * EvanR-work makes a text editor of the form used at game over screen on arcades, left right moves the cursor, up down changes characters
15:19:07 <EvanR-work> cant go wrong
15:19:25 <hpc> EvanR-work: konami combo!
15:20:05 <EvanR-work> hpc: i dont remember it but my old room mate from the uni started each day by repeating that code religiously
15:20:10 <ddarius> EvanR-work: That has twice the interface elements than seems necessary.
15:20:45 <EvanR-work> ddarius: extra features
15:20:48 <Adamant> note: the editor you use totally defines the size or smallness of your e-genitalia, depending on your preference
15:20:51 <EvanR-work> for convenience
15:21:13 <Adamant> ddarius: are you sure you didn't start out as an EE?
15:21:15 <EvanR-work> Adamant: kinky
15:21:50 <ddarius> Adamant: Yep, though I like EE.
15:22:02 <ddarius> Incidentally, I ran cat --help for the first time today.
15:22:18 <ddarius> -u (ignored)
15:22:18 <Adamant> ddarius: that's totally something an EE would do to save on BOM
15:22:52 <Adamant> multiplex a single button in new and disturbing ways
15:23:08 <Adamant> that any UI/UX person would beat them for, if only they could beat an EE
15:23:44 <monochrom> just generalize morse code. if you hold it down for 0.1-0.2 seconds, you mean X. if you hold it down for 0.2-0.3 seconds, you mean Y.
15:23:57 <Adamant> yes, some of the hacks are along those lines.
15:24:19 <EvanR-work> nah
15:24:40 <EvanR-work> use the time between press/release rise/fall signal
15:24:43 <Adamant> not Morse, but time -based stuff
15:24:58 <ezyang> aw, there's no MonadPlus IO instance? 
15:25:13 <ddarius> I considered but decided against going that far.  But you certainly don't need both up AND down.  Don't really need both left and right either.
15:25:13 <monochrom> generalize the above generalized morse code. if your holding and releasing matches timing diagram #1, you mean X. if it matches timing diagram #2, you mean Y.
15:25:38 <EvanR-work> you just invented the emacs of the single button paradigm
15:25:44 <Adamant> when keeping it simple by using math theory goes wrong
15:27:02 <monochrom> the computer generates strings randomly and shows them to you one by one. when you see the one you want to enter, press <enter>
15:27:34 <EvanR-work> this is a digital interface requiring electronics... just hold your hand a certain distance from a capacitor plate to change the frequency of the oscillator, and the time progression of that function is the text
15:27:47 <EvanR-work> i mean, do that instead of having a digital button
15:27:59 <ddarius> User input via theremin... interesting.
15:28:21 <Adamant> Theramin would totally have used that for sneaky spy stuff
15:29:20 <bblum> how does one convert among Num types? specifically, i'd like to go between Word32 -> Int
15:29:27 <ddarius> fromIntegral
15:29:35 <nimred> monochrom "C-c C-w is undefined" in minibuffer o_O
15:29:39 <nimred> C-c C-w inserts a where keyword
15:29:43 <ddarius> fromIntegral and realToFrac are the only numerical conversion things you need to remember.
15:29:49 <nimred> seen on http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
15:29:53 <EvanR-work> > fromIntegral (45 :: Word32) :: Int
15:29:53 <lambdabot>   45
15:30:03 <bblum> thanks
15:30:07 <monochrom> I have never used C-c C-w.
15:30:21 <monochrom> all I can say is the tutorial is outdated.
15:30:42 <kmc> http://www.inference.phy.cam.ac.uk/dasher/ is a reasonable text input mode
15:30:51 <EvanR-work> bblum: *ghost of C says* beware Word32 with more bits than the minimum required by Int to support
15:31:13 <ddarius> > 90812789002318973790813490781325789023462470898 :: Int32
15:31:14 <lambdabot>   1317516530
15:31:21 <Adamant> kmc: dasher is kinda odd, but not horrible
15:31:43 <EvanR-work> oh yeah, and signed ness
15:32:07 <ddarius> > -1 :: Word32
15:32:08 <lambdabot>   4294967295
15:32:16 <Adamant> kmc: and I'm sure it's a godsend for the folks it's originally intended for
15:32:18 <bblum> yeah, i am aware of the dangers
15:32:22 <nimred> monochrom looks like yeah
15:32:28 <EvanR-work> > fromIntegral (maxBound :: Word32) :: Int32
15:32:29 <lambdabot>   -1
15:34:45 <nimred> what do you use other emacs users here ?
15:41:45 <ezyang> Hey guys, how bad a person am I if I use a global reference to store a debug flag? 
15:41:54 <kmc> shrug
15:42:02 <monochrom> angelic
15:42:29 <aristid> ezyang: you will get into the Hell of Perl
15:42:48 <monochrom> not until you use a lot of $ signs
15:42:50 <ezyang> oh no! 
15:43:18 <Shamar> men, how do you debug stack overflow?
15:43:51 <monochrom> main = id $withSocketsDo $runGhc $withFile "xxx" ReadMode $do ...
15:43:57 <monochrom> is like perl
15:44:02 <kmc> Shamar, ghci debugger, -fbreak-on-exception
15:44:04 <kmc> might work?
15:45:25 <Axman6> Shamar: by showing us the code, so we can explain what you're doing wrong, and how to avoid them in the future
15:46:04 <Shamar> wow... :-) well my code is quite arcaic...
15:46:10 <Shamar> just a momento
15:46:19 <Axman6> @where hpaste
15:46:19 <lambdabot> http://hpaste.org/
15:46:27 <kmc> Shamar, do you know what stack overflow means in GHC Haskell, as opposed to other languages?
15:46:29 <kmc> it's a bit different
15:47:10 <monochrom> it's many bits different
15:49:00 <Shamar> i'm putting on git
15:50:09 <Shamar> ehm... since haskell it's all about functions I think a stack overflow means an infinite recursion
15:51:41 <identity> Is there any way to easily add "tell [str]" on when Nothing to the following: return . join $ either (const Nothing) (Just . process) variable :: WriterT [String] IO (Maybe String)
15:52:17 <kmc> what?
15:52:46 <kmc> Shamar, sometimes.  but due to laziness, the stack is not a stack of function calls, but of forcing and pattern-matching
15:53:01 <kmc> forcing x executes some code which forces y which forces z etc.
15:53:02 <ezyang> Protip: Even when you're writing in Haskell, designing good user interfaces is hard. 
15:53:08 <mux> if I don't see any signals listed for an object in gtk2hs, does it mean I should use connectGeneric? I tried to do that to attach to the "toggled" signal of CheckMenuItem but enjoy a segfault when it's fired.
15:53:35 <identity> kmc: Well, in the case where variable is Left (I handle it with const Nothing) I want to 'call' tell first; is this possible or am I not 'in the writerT' monad inisde either's left handler there? I tried doing it the way I thought it would work, but it doesn't type check
15:53:35 <kmc> you can have a deep recursion but set it up so that each individual pattern-match has only constant stack
15:53:41 <kmc> like a foldr over an infinite list
15:54:09 <identity> i.e. something like: return . join $ either (const (tell "foo" >> return Nothing)) (Just . process) r
15:54:10 <kmc> identity, you'll have to drop the "return"
15:54:22 <kmc> because you now want "either" to return a WriterT action
15:54:35 <identity> Aah
15:54:45 <identity> but then the join is no good, either
15:54:47 <identity> right?
15:54:52 <kmc> just work out the types
15:54:53 <kmc> but it might be clearer to use "case" instead of "either"
15:54:56 <identity> alright
15:54:57 <identity> thanks
15:57:04 <identity> kmc: Thanks, that did it, I believe
15:57:39 <kmc> :)
15:57:48 <Shamar> here is the stack overflow: http://github.com/Shamar/RPNCalculator
15:58:47 <Shamar> It's a rpn calculator far more complex than required (it's an hack for learning purpouse)
15:59:23 <identity> Shamar: fyi, your applyUntil is until
15:59:24 <identity> :t until
15:59:25 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
15:59:36 <Shamar> ehm... :-D
15:59:41 <Shamar> thaks...
15:59:50 <identity> doesn't have anything to do with your problem, I know, but meh
16:00:28 <Shamar> the constraint I put to that hack is to avoid the use of a stack (a part from the call stack)
16:01:27 <Shamar> take it as a requirement...
16:01:30 <Shamar> :-)
16:02:07 * sipa recognizes his idea still
16:04:33 <sipa> Shamar: why does apply (Function f) (Function g) give an error?
16:05:11 <ezyang> Lovely parsing hacks! http://hpaste.org/40612/parsing_hacks 
16:07:27 <Shamar> sipa, it should never happen... a function is applied to a value once it's found...
16:07:29 <Saizan> there's noting lovely in that paste
16:07:41 <Saizan> +h
16:07:56 <Shamar> ehm... may be this is the error btw... let me take a look
16:10:15 <sipa> no it's not
16:11:17 <Shamar> are you sure sipa?
16:11:36 <sipa> well it would result in an exception, not a stack overflow
16:11:55 <monochrom> I think evaluateExpression is an infinite loop
16:12:24 <sipa> yes it is
16:12:30 <sipa> exp = evaluateExpression parse $ Expression Empty otherTokens
16:13:17 <sipa> results in an identical call
16:13:32 <monochrom> maybe I should learn ghci-debugger one day
16:13:56 <Shamar> sipa why?
16:14:22 <sipa> well you call yourself with identical arguments
16:14:30 <sipa> if result was already Empty
16:14:38 <sipa> and otherwise it becomes that
16:14:50 <Shamar> sure ! ! ! ! ! 
16:15:21 <monochrom> I am still surprised how much I can deduce without a debugger.
16:15:41 <Saizan> also, it doesn't use parse at all
16:15:56 <Saizan> which would have been evident in the type inferred
16:17:08 <sipa> Shamar: apply (value 3) (apply (value 5) (apply (value 2) (apply (binary (+)) (binary (+)))))
16:17:22 <sipa> for (5+2)+3
16:17:28 <Shamar> right
16:17:31 <sipa> that's a function applied to a function
16:17:39 <sipa> you could order it differently
16:17:45 <sipa> but there's no need to
16:24:53 <Shamar> sipa all the instrumentation should build something like: 
16:25:00 <Shamar> apply (value 3) $ apply (apply (value 5) $ apply (value 2) $ binary (+)) $ binary (+)
16:25:43 <Shamar> it has just a problem... it don't works! :-)
16:25:58 <Shamar> may be becouse I'm sleeping to few
16:26:37 <Shamar> for example not using the parse is quite emblematic that I need to sleep :-)
16:26:49 <sipa> Shamar: you don't have brackets
16:26:57 <sipa> or, well, you could have
16:27:02 <sipa> but you don't need to
16:27:26 <sipa> in a shorter notation
16:28:04 <sipa> (5 2 + 3 +) is identical to (3 5 2 + +)
16:28:11 <Shamar> the Expression works like brackets
16:28:28 <sipa> but the nice thins about RPN is that you don't need brackets
16:28:32 <sipa> i mean
16:28:36 <sipa> you could add it
16:28:50 <Shamar> ah ok.. I know...
16:28:55 <sipa> but why prevent people from writing (3 5 2 + +)
16:29:05 <Shamar> I dont
16:29:11 <aristid> sipa: that would defeat the purpose of rpn
16:29:36 <sipa> Shamar: well, 3 5 2 + + will result in a plus applied to a plus
16:29:58 <aristid> sipa: then it's not RPN.
16:30:16 <sipa> ?
16:30:33 <ray> huh? if you push 3 5 2 on the stack then execute 2 adds it works
16:30:47 <sipa> yes, it's perfectly valid rpn
16:31:00 <aristid> sipa: i mean the evaluator is not valid rpn
16:31:05 <sipa> why not?
16:31:11 <ray> rpn never needs brackets that is the usefulness
16:31:17 <aristid> "a plus applied to a plus"
16:31:30 <sipa> aristid: read the code
16:31:36 <ray> you don't apply to parts of the expression, you apply to the stack
16:31:49 <ray> plusses don't go on the stack, they're executed
16:31:53 <aristid> sipa: where is the code?
16:32:01 <sipa> http://github.com/Shamar/RPNCalculator/blob/master/src/Computation.hs
16:32:40 <sipa> Shamar: i think you're basically trying to push the detection of which arguments need to go to what operator to your parser
16:33:09 <sipa> while the strength of that Value/Expression trick is exactly that you don't need to
16:33:26 <sipa> if you implement apply Function Function which reorders them
16:33:29 <ray> hmm
16:33:36 <ray> i've forgotten
16:33:43 <ray> if i import qualified Prelude as P
16:33:49 <ray> that gets rid of the implicit prelude right?
16:34:33 <Shamar> sipa, what you mean?
16:35:00 <sipa> Shamar: if i write (1 2 3 + +), i want it to evaluate as 1+(2+3)
16:35:19 <Shamar> right
16:35:28 <Shamar> so?
16:36:28 <sipa> you could just convert it to 1 `apply` (2 `apply` (3 `apply` (plus `apply` plus)))
16:36:52 <ray> if you associate the other way it works though
16:37:00 <sipa> if you implement apply (Function a) (Function b)
16:37:03 <sipa> as i did
16:38:17 <sipa> ray: no, it will not, there is no stack, so there is no way to make (1 `apply 2) evaluate to something that maintains two numbers
16:40:06 <Shamar> mmm... I cant immagine how to apply a function to a function (eventually to a function again and so on)
16:40:14 <sipa> Shamar: i just did
16:40:18 <sipa> (plus `apply` plus)
16:40:50 <sipa> apply means: feed the resulting value from the first expression as argument to the second
16:41:10 <sipa> if the first is not a value but a function, that means that it will result in another function
16:41:19 <sipa> in a way that's partial evaluation
16:42:11 <sipa> but just write: apply (Function f) g = Function (\x -> apply (f x) g)
16:42:14 <sipa> and you're there
16:45:31 <sipa> sorry for being so loud about it, but that single line was imho the nicest thing about the whole idea of using functions and values, and all you needed to make RPN work, and i think you didn't get it :)
16:49:01 <heatsink> Do pattern guards get CSEd?
16:49:03 <Shamar> sipa, may be that was actually what I needed ... that could even make the Computation a Monad I think... 
16:49:30 <Shamar> but actally I still need to undestand something about monads...
16:51:16 <Axman6> heatsink: i'm not sure ghc doesn much CSE at all
16:53:14 <pickles1> why doesn't the (.) operator ever work for me
16:53:21 <heatsink> Huh, that significantly reduces the utility of pattern guards .
16:53:51 <pickles1> checkUsing fn xs = foldl' (flip (?:)) [] (map fn xs)
16:53:55 <monochrom> what pattern guard cse do you wish?
16:54:04 <pickles1> checkUsing fn xs = (foldl' (flip (?:)) [])  .  map
16:54:25 <monochrom> checkUsing fn = (foldl' (flip (?:)) [])  .  map fn
16:54:34 <kmc> pickles1, it composes a 1-arg function with a 1-arg function
16:54:39 <pickles1> aha
16:54:43 <kmc> just pay attention to the types
16:54:57 * pickles1 needs to start checking the types....
16:55:00 <heatsink> pickles1: Rembmeber to use unicode character 002E, not unicode character 2024
16:55:09 <monochrom> heh
16:55:10 <kmc> yes, i don't know how you could learn Haskell without checking the types
16:55:14 <kmc> ghci's :t is your friend
16:55:34 <pickles1> kmc: yes, i am acquainted with it :)
16:55:40 <pickles1> and :i
16:55:40 <lispy1> heatsink: Well, automatic CSE leads to space leaks :(  Where was designed to help with adding sharing to patterns
16:55:51 <pickles1> thx guys
16:55:56 <kmc> ghc guarantees some amount of CSE for view patterns
16:56:03 <heatsink> lispy1: The motivation for pattern guards is to get rid of clunky use of 'where' though :/ 
16:56:11 <lispy1> heatsink: ah
16:57:13 * heatsink wants pattern1 [| Just x <- foo a, x < y |], pattern 2 [| Just _ <- foo a |]
16:57:55 <heatsink> I can use 'if' anyway.
16:58:42 <identity> So, which one of you wizards has experience using SetClipboardData from Graphics.Win32.GDI ?
16:59:41 <identity> And could possibly shed light on why withCString "string" (\s -> setClipboardData cF_TEXT . castPtr $ s) crashes with *** Exception: SetClipboardData: invalid argument (The handle is invalid.)?
17:02:59 <conal> i wonder if someone here could help unconfuse me about utf8 & haskell.  i'm pulling some text in with simpleHttp in the http package, and the special utf8 characters turn into three characters, and then get written out that way.  i want to end up with the sort of encoding that i started with.
17:04:11 <monochrom> the point of pattern guard is not to eliminate "where" completely. even with boolean guard, I write "f x | y>0 = 0 | y<0 = 1 | y==0 = 2  where y = sin x" all the time.
17:04:51 <identity> conal: Have you tried converting it to ByteString and then back to utf8?
17:04:57 <identity> @hoogle pack
17:04:58 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
17:04:58 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
17:04:58 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
17:05:08 <identity> @hoogle utf8
17:05:09 <lambdabot> No results found
17:05:12 <identity> @hoogle UTF8
17:05:12 <lambdabot> No results found
17:05:28 <conal> identity: i've been playing with some variations.  maybe i haven't found the right one.
17:06:04 <identity> Hmm
17:06:08 <conal> i'm confused about what the various packages & types are
17:06:08 <identity> @hoogle fromString
17:06:08 <lambdabot> Data.String fromString :: IsString a => String -> a
17:06:38 <identity> conal: It seems that this may do what you want: Data.ByteString.UTF8.fromString and toString
17:06:52 <identity> fromString = converts a haskell string into a utf8 encoded bytestring
17:06:53 <nominolo> preflex: seen chrisdone
17:06:53 <preflex>  chrisdone was last seen on #haskell 12 hours, 34 minutes and 11 seconds ago, saying: I find it funny that that's an Int and not an Integer
17:07:00 <heatsink> monochrom: Do you do that for readability or for efficiency?
17:07:03 <identity> and then converting it back will probably fix your encoding
17:07:10 <monochrom> both
17:07:40 <conal> identity: thx.  i'll try it right now
17:07:46 <identity> conal: alright
17:08:30 <heatsink> When the expression is syntactically simple, the CSE'd form seems less readable to me.  The expression is now distributed across multiple places.
17:09:09 <monochrom> "sin x" cannot be syntactically simpler than "y"
17:09:34 <conal> @hoogle toString
17:09:34 <lambdabot> System.Time calendarTimeToString :: CalendarTime -> String
17:09:34 <lambdabot> System.Time timeDiffToString :: TimeDiff -> String
17:09:35 <lambdabot> Network.HTTP.Base uriAuthToString :: URIAuth -> String
17:09:47 <conal> identity: do you know where toString is?
17:10:02 <heatsink> But where before you had "sin x > 0"
17:10:02 <identity> conal: The one I was referring to was supposed to be @ Data.ByteString.UTF8
17:10:06 <monochrom> suppose I repeat "sin x" 3 times. every time I read it, I have to verify (again!) that they are really 3 repetitions of "sin x". that is counterproductive.
17:10:11 <conal> identity: ah.  thx.
17:10:12 <heatsink> you now have "y > 0" ......
17:10:29 <heatsink> ..... some code .....
17:10:35 <heatsink> ..... "y = sin x"
17:11:37 <monochrom> that can be mitigated by a futuristic code browser that does elliding, hovering hints, etc.
17:11:52 <monochrom> imagine I hover over "y" and I see a box saying "sin x"
17:12:01 <heatsink> That would be nice
17:13:06 <monochrom> the real problem is you know how programmers --- humans --- don't really read. they presume what the code says, then they think they read the code did say that.
17:13:44 <joe1> [6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~
17:13:47 <monochrom> suppose you expect 3 occurences of "sin x". suppose the actual code has one of them as "sim x". you will not spot it. never.
17:14:12 <heatsink> yeah
17:14:21 <monochrom> and in reality the real expression is not going to be as short as "sin x".
17:14:46 <identity> What is everyone's favorite gui binding, if any, for haskell? 
17:15:58 <conal> identity: for low-level/imperative, i like wxHaskell.  relatively elegant (considering imperative), and native look.
17:16:46 <identity> conal: It seems to be mentioned a lot; I'll check it out, thanks. Did you manage to fix the encoding?
17:16:59 <conal> identity: i'm ending up with the three chars: http://hpaste.org/40615/utf8_confusion
17:17:17 <conal> identity: for guis, which oses?
17:17:57 <aristid> conal: where is postUrl from?
17:17:59 <conal> wxhaskell has one serious flaw, which keeps me from using it: it kills its host process the second time a top-level window is created.
17:18:07 <blackcustard> hey guys, is there any alternative to "fromInteger $ toInteger" for casting between numerics? it seems like a really indirect way of doing things ...
17:18:16 <aristid> oh, postUrl is not a method for making POST requests
17:18:19 <aristid> but something else
17:18:23 <identity> conal: I would like cross platform, to be honest. I don't think that flaw will hinder me
17:18:27 <conal> aristid: yeah, right.  a pure function that builds the url
17:18:55 <ddarius> blackcustard: Remember fromIntegral and realToFrac.  Forget all other numeric "conversion" functions.
17:19:28 <aristid> conal: i use xml (the package) for something, and i convert everything before passing it to the xml parser. maybe you should do that too
17:19:32 <conal> getHtml = simpleHTTP . getRequest >=> getResponseBody
17:20:07 <aristid> conal: simpleHTTP_ supports ByteString i think
17:20:16 <conal> aristid: oh?!
17:20:24 <aristid> but you can also use curl
17:20:29 <conal> might be the fix i'm looking for
17:20:56 <aristid> conal: yeah i was researching HTTP libraries the other day. curl won.
17:21:10 <aristid> but HTTP does support ByteString
17:21:16 <aristid> it just lacks SSL /o\
17:22:56 <blackcustard> ddarius: would you still use toInteger to go from e.g. a Float to an Integer (after rounding), or to an Int?
17:23:08 <conal> aristid: thanks.  i'll do some more digging into HTTP and curl
17:23:15 <ddarius> blackcustard: No.
17:23:43 <aristid> conal: there are some other libraries which might be easier to use if all you need is HTTP GET
17:23:57 <aristid> download, and i-forgot-the-name
17:24:22 <conal> aristid: if you think of the other, please let me know.  so far i just need a GET
17:24:47 <conal> i'm pulling content from my gitit wiki for tweaking and posting to my blog
17:25:36 <conal> oh wow.  download looks very simple
17:26:52 <identity> I wish I had thought of using curl before I got acquainted with simpleHTTP
17:27:01 <blackcustard> hmm, i see, there's also a fromRational ... anyway, i had forgotten about fromIntegral. thanks for the help :)
17:27:19 <ddarius> blackcustard: Don't use fromRational.
17:27:32 <aristid> conal: download, download-curl, http-wget
17:27:43 <conal> aristid: thx! :)
17:33:09 <conal> wow.  the download package on hackage won't build: "`TagSoup.Tag' is not applied to enough type arguments"
17:34:00 <Saizan> heh, unconstrained dep on tagsoup
17:34:29 <conal> ah.  i'll tell dons and try download-curl
17:34:41 <conal> dons: ping
17:35:10 <Saizan> --constraint="tagsoup == 0.10.*" might do the trick, considering the dates
17:36:00 <Saizan> 0.6.* actually
17:36:22 <blackcustard> ah, alright ... i found this: http://www.haskell.org/onlinereport/basic.html which includes a good diagram of the numerics, and i think i understand. your right, just fromIntegral and realToFrac, and float/double -> int/integer is provided by the rounding functions, cast free (afterall you wouldn't cast that way _without_ rounding)
17:37:15 <conal> Saizan: thx.  got past the first error.  ran into some others.
17:47:58 <identity> What is the policy on 'overwriting' some library on hackage? The Clipboard library is simply bugged; doesn't follow the API specifications. 
17:48:10 <identity> Do I upload a new one, or do I just 'take it over'?
17:48:21 <ddarius> identity: Talk to the maintainer.
17:48:24 <identity> alright
17:48:28 <identity> (duh)
17:48:31 <identity> good idea.
17:48:55 <identity> @seen danieldiaz
17:48:55 <lambdabot> Unknown command, try @list
17:48:55 <preflex>  danieldiaz was last seen on #haskell 33 days, 49 minutes and 59 seconds ago, saying: > let loop = loop in loop
17:49:07 <identity> Ah.
17:49:10 <identity> email it is.
17:49:37 <Lemmih> Oh dear. danieldiaz entered an infinite loop 33 days ago.
17:49:53 <aristid> Lemmih: hahaha
17:50:56 <identity> hahaha.
17:51:12 <identity> lambdabot needs to be able to grab some context :P
17:51:44 <aristid> yes
17:54:04 <conal> okay, I have download-curl going now.  i'm getting a ByteString, and my utf-8 special char comes out as 3 chars.  is that as expected?
17:54:17 <identity> conal: 3 bytestring characters?
17:54:23 <conal> identity: yes
17:54:24 <identity> i.e. 3 bytes?
17:54:29 <identity> yes
17:54:39 <identity> try the UTF8.toString now
17:54:42 <conal> the bytestring length function says they're three chars.
17:54:46 <conal> ok.
17:56:12 <c_wraith> conal, it says they're three *bytes*.
17:56:21 <c_wraith> bytestring doesn't know anything about characters.
17:56:30 <conal> c_wraith: ah!  thanks :)
17:57:03 <conal> oh, sweet!  UTF8.toString does the trick.  phew!
17:57:30 <identity> Good to know; I'll know what to do if(when) I run into that
17:58:44 <conal> wow.  i was sweating bullets on this one.  thanks for all the help.
17:59:11 <c_wraith> let's all remember that bytes /= characters :)
17:59:23 <aristid> and that Char = unicode codepoint
17:59:43 <conal> yeah.  i'm a little more clueful now than i was.
17:59:54 <aristid> > (ord minBound, ord maxBound)
17:59:55 <lambdabot>   (0,1114111)
18:00:06 <aristid> hey that is a palindrome
18:00:35 <Shamar> men, I got it!
18:00:55 <conal> aristid: cool
18:01:17 <Shamar> sipa, take a look at the latest http://github.com/Shamar/RPNCalculator/blob/master/src/Computation.hs
18:01:54 <quuxman> what's the most excepted way to format strings with arguments implementing Show?
18:02:02 <quuxman> s/excepted/accepted/
18:02:52 <Shamar> I can not find an expression it can not evaluate right now...
18:03:59 <ddarius> Shamar: You should make a formal proof that it correctly evaluates all expressions.
18:04:30 <Shamar> ehm... I would not know how to do that!
18:04:34 <quuxman> foo ++ "blah" ++ (show baz) ++ "wank" ++ ... doesn't look so pretty
18:04:51 <aristid> quicksilver: you could use printf
18:04:57 <ddarius> Shamar: So now you have a learning opportunity.
18:05:00 <aristid> arrrg
18:05:06 <aristid> quuxman: i mean you
18:05:16 <quuxman> aristid: I figured ;)... that should be a "duh" in my case
18:05:24 <Shamar> sure ddarius, where to start from?
18:05:26 <identity> printf = awesome
18:05:37 <quuxman> @hoogle printf
18:05:38 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
18:05:38 <lambdabot> module Text.Printf
18:05:38 <lambdabot> Text.Printf class PrintfArg a
18:05:42 * Shamar currently just need to sleep
18:06:26 <quuxman> :t printf
18:06:27 <lambdabot> forall r. (PrintfType r) => String -> r
18:06:35 <quuxman> but wha? That's backwards... it should return a String
18:06:38 <aristid> quuxman: i make such mistakes too often :(
18:06:51 <ddarius> aristid: Turn off tab completion.
18:07:14 <quuxman> ddarius: I love it (dd<tab>: ...)
18:07:17 <aristid> ddarius: but i love my tab companion_square
18:07:20 <c_wraith> quuxman, String is an instance of PrintfType
18:07:48 <quuxman> c_wraith: oh of course, it's a recursive type
18:07:59 <quuxman> :info PrintfType
18:08:04 <c_wraith> quuxman, well, some of its instances are, anyway.
18:08:11 <c_wraith> lambdabot doesn't support that one
18:08:13 <quuxman> c_wraith: right, You can't have a plain old recursive type
18:08:38 <quuxman> c_wraith: well you can, but not one that would work for printf
18:08:41 <c_wraith> There are actually a bunch of instances.  It's funky.
18:09:00 <aristid> quuxman: PrintfType is a class
18:10:58 <quuxman> > printf "here is a %s test" (show 42)
18:10:59 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:10:59 <lambdabot>    `Text.Printf.PrintfType ...
18:11:05 <quuxman> > printf "here is a %s test" (show 42) :: String
18:11:06 <lambdabot>   "here is a 42 test"
18:11:43 <quuxman> > printf "here is a %d" 42 :: String
18:11:44 <lambdabot>   "here is a 42"
18:11:47 <quuxman> nifty
18:12:24 <c_wraith> there are some stranger instances
18:12:33 <c_wraith> > printf "here is a %d" 42 :: IO ()
18:12:34 <lambdabot>   <IO ()>
18:12:42 <c_wraith> I don't like that instance, particularly
18:13:03 <c_wraith> it's confusing that the same expression can be an IO expression or not, depending on context
18:13:20 <c_wraith> err, IO action
18:15:50 <identity> Is there any go-to material on cabal best practices, do-nots and so on?
18:16:01 <identity> For someone who might be uploading his first contribution
18:16:14 * identity feels proud
18:17:31 <quuxman> c_wraith: yeah that is weird that there's an IO instance. When is that useful?
18:17:50 <c_wraith> quuxman, for acting like C's printf, rather than sprintf
18:18:06 <quuxman> c
18:18:12 <identity> It's funny because print/putStrLn $ printf "foo" will do the job
18:18:13 <quuxman> c_wraith: I like having two function names
18:18:19 <c_wraith> identity, hackage itself makes plenty of recommendations.
18:18:44 <c_wraith> identity, look at the package versioning policy, consider what bounds you're putting on your build-depends packages
18:19:04 <c_wraith> quuxman, like I said, I don't like that it works that particularly, either.
18:19:13 <identity> c_wraith: hmm
18:19:18 <identity> i'll read up on hackage then, thanks.
18:19:36 <c_wraith> identity, also, don't forget to preview your submission! :)
18:19:51 <quuxman> c_wraith: it wouldn't have been that confusing if printf was actually like sprintf, and there was another printfs for printf stdout
18:20:26 <c_wraith> quuxman, yeah.  Someone just got excited about the polyvariadic design pattern they discovered, and went overboard :)
18:20:30 <identity> I shall be as detailed as humanly possible, then go beyond that and be on the edge of my life in order to secure the quality of my contribution
18:20:51 <quuxman> c_wraith: heh. Maybe it'll get fixed in a later GHC version... that's part of the standard lib, right?
18:21:27 <c_wraith> quuxman: eh, that one probably won't get changed.  the cost to change it is higher than the cost to leave it alone, at this point.
18:22:27 <Shamar> good night men! see you soon and thanks a lot!
18:24:12 <identity> github vs darcs?
18:24:32 <res> you mean git vs darcs?
18:24:38 <McManiaC> haskell vs http?
18:24:40 <McManiaC> :D
18:24:40 <c_wraith> one's a website, the other a program :)
18:25:08 <identity> Ah -- it seemed to distinguish between the two.. Figured they were forked versions of the same system
18:25:18 <identity> (git and github that is)
18:26:04 <identity> so, git vs darcs?
18:26:26 <McManiaC> matter of taste :P
18:26:45 * mjrosenb groks darc' workflow
18:27:00 <mjrosenb> but i have had some serious issues with speed
18:27:03 <mjrosenb> *darcs'
18:27:07 <McManiaC> git feels more "lowlevel" like C, wheras darcs is more "usable"
18:27:29 <c_wraith> darcs definitely has a friendlier UI, but it gets painfully slow rather quickly
18:27:48 <McManiaC> ...and that speed issue, yeah
18:27:56 * hackagebot CHXHtml 0.1.3 - A W3C compliant (X)HTML generating library  http://hackage.haskell.org/package/CHXHtml-0.1.3 (PaulTalaga)
18:28:15 <identity> I shall try my luck with git
18:28:29 <mjrosenb> like
18:28:38 <kwuxalot> hm, I like this better than quuxman
18:28:51 <mjrosenb> i spent a solid 5 hours trying to get changes from my local repository to a remote repository in git
18:29:15 <McManiaC> hu?
18:29:24 <McManiaC> never heard of git add/commit/push? :D
18:29:38 <mjrosenb> the git push step was the wrong one
18:29:52 <McManiaC> missing remote entry in .git/config ?
18:30:02 <mjrosenb> evidently there is a special way that you need to create a repository in order to be able to push to it.
18:30:31 <mjrosenb> and there is no good way to change this property once it has been created
18:30:39 <McManiaC> you can just do "git add remote foo" (or something like that) and then "git push foo"
18:30:51 <mjrosenb> McManiaC: nope.
18:30:56 <McManiaC> sure :>
18:31:04 <mjrosenb> the issue was that the repository was un-pushable
18:31:14 <mjrosenb> not that i did not know where it was / how to access it.
18:31:44 <McManiaC> oh you mean that bare-repo stuff?
18:31:50 <mjrosenb> yeah.
18:31:57 <McManiaC> ah right, that's been buffering me aswell
18:32:03 <McManiaC> buffern? lol bothering
18:32:17 <mjrosenb> or buffaloing
18:32:22 <McManiaC> :D
18:32:38 <McManiaC> yes ok, but once you think about it it makes kind of sense
18:33:26 <McManiaC> imaging you're working on something and all of the sudden your roommate pushes into your working directory, shouting "hey, I just removed all the files you were working on"
18:33:26 <mjrosenb> the fact that any two empty repos are interchangable is kind of disconcerting.
18:33:51 <McManiaC> you can always pull :)
18:33:54 <mjrosenb> McManiaC: why does that person have write access to your stuff?
18:34:16 <McManiaC> mjrosenb: thats how non-bare-repos are supposed to be used
18:34:29 <McManiaC> non-bare = working directory
18:34:33 <mjrosenb> everyone has write access?
18:34:37 <McManiaC> no
18:34:46 <McManiaC> but if you want to push to something you need write access
18:35:00 <mjrosenb> yeah, but in all of the tutorials, there was *no* mention of this second kind of repo.
18:35:14 <McManiaC> yup
18:35:19 <mjrosenb> and no mention that you couldn't just push to any repo that shares a common ancestry
18:35:22 <McManiaC> totally agree on that point
18:35:26 <mjrosenb> and when i discovered the problem
18:35:40 <McManiaC> just sayin' it kind of makes sense once you think about it :)
18:35:41 <mjrosenb> there was very little saying that you can just push to an empty bare repo
18:35:50 <mjrosenb> because any two empty repos are identical.
18:36:49 <McManiaC> blah
18:36:51 <Ytinasni> the fact that they're empty has nothing to do with it, though.
18:37:03 <McManiaC> been reading GHCs commentary/source all evening :S
18:37:36 <mjrosenb> Ytinasni: oh?
18:37:56 <Ytinasni> you can push to any bare repo, and not to any non-bare repo.
18:38:37 <mjrosenb> right
18:38:50 <McManiaC> you can force to push it tho :D
18:38:54 <mjrosenb> however, i was in the mindset that i needed to push to a repo that looked like mine
18:39:17 <Ytinasni> ah.
18:39:21 <mjrosenb> e.g. i could not push to a repo that was just created with git init
18:39:34 <McManiaC> ssh myhost "cd foo; git pull mycurrenthost"
18:39:35 <McManiaC> :D
18:39:36 <mjrosenb> because it is a different repo (presumably from a different project)
18:40:09 <mjrosenb> McManiaC: "mycurrenthost" is frequently on the wrong side of a nat.
18:42:43 <McManiaC> mjrosenb: yeah :>
18:45:44 <mjrosenb> although i do like the emacs interface to git more than the darcs one.
18:46:01 <McManiaC> <3 gitk
18:47:21 <mjrosenb> kde interface to git?
18:47:52 <Draconx|Laptop> tk
18:50:00 <mjrosenb> well that is a step in the rigt direction
18:50:58 <McManiaC> mjrosenb: basicly a gui for git history
18:51:06 <Draconx|Laptop> it's not really a full-featured frontend per-se.
18:51:45 <McManiaC> nope, but its way easier to keep track than with git diff etc
18:51:50 <alpounet> we need something similar for darcs
18:52:31 <McManiaC> I would *love* if you could actually get a useable darcs *library*
18:52:39 <McManiaC> but its a pain in the .. :)
18:53:38 <mjrosenb> yeah
18:53:47 <mjrosenb> i was hoping darcs-graph would do something
18:53:52 <mjrosenb> well, more useful
19:04:40 <megajosh2> Hey, is anyone here familliar working with dynamically loaded Haskell code?
19:05:43 <megajosh2> I'm trying to get a function in a module I made to test with load_, but the resulting type is GHC.Prim.Any or something like that
19:05:59 <megajosh2> I don't know how to convert it to something I can use
19:17:14 <Saizan> unsafeCoerce
19:17:35 <megajosh2> Alright, I'll look that up; thanks
19:18:00 <Saizan> you could also use hint which at least will do a dynamic check
20:38:21 <identity> Query: Is there any standard way to place modules within the module hierarchy?
20:39:35 <identity> i.e. System.Foo.Bar ?
20:47:21 <kmc> identity, what do you mean?
20:49:30 <identity> kmc: So I'm writing a clipboard library
20:49:32 <identity> for windows
20:49:47 <identity> The one that's already there is bugged and 'places itself' @ System.Windows.Clipboard
20:50:00 <identity> Why does it place itself there as opposed to "System.Win32.Clipboard" or some such?
20:50:31 <enthropy> why is it bugged?
20:50:52 <identity> It doesn't follow the API specification
20:50:58 <identity> doesn't allocate global memory and so on
20:51:09 <identity> I've contacted the author, just waiting for his reply
20:51:31 <identity> I may just end up handing him source that does it properly, but I need to learn to use cabal and set up package et al anyway
20:51:52 <kmc> what percentage of windows program follow the API specifications, anyway?
20:52:31 <identity> Is there something wrong with me trying to contribute? It's bugged to the point where it simply doesn't function
20:52:38 <identity> crashes with an exception every time
20:54:29 <Saizan> identity: there's no written down way to use the module hierarchy namespace, do what makes most sense :)
20:55:26 <identity> Alright, thanks.
20:55:53 <Saizan> System.Win32.* is probably more appropriate since that's what the standard windows api bindings use
20:56:15 * ddarius suspects that the clipboard works the same in Win32 and Win64
21:00:26 <identity> ddarius: I figured that was why
21:02:34 <Saizan> uh, so they have a separate Win64 api?
21:02:51 <identity> For some functions, yes
21:03:02 <identity> It's rather nasty to use
21:05:50 <kmc> windows API is nasty to use?
21:05:52 <kmc> perish the thought
21:08:25 <identity> kmc: The Wow64 is nastier.
21:08:54 <identity> I think I may even have found a bug in it, though the MSDN MVPs didn't really have any suggestions when I asked on MSDN
21:11:02 <Jonno_FTW> how would I define a datatype for the face value of a deck of cards? I have the following but it won't parse: 
21:11:08 <Jonno_FTW> data Value = 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | T | J | Q | A deriving (Ord, Show, Eq, Enum)
21:12:00 <JoeyA> Data constructors can't be named numbers (unless there's an extension for that)
21:12:16 <Jonno_FTW> I tried to use chars but that didn't parse either
21:12:41 <sodium70mg> chars like '2' | '3' | ...?
21:12:43 <bill> you need a constructor name ahead of all candidate values
21:12:46 <Jonno_FTW> yes
21:13:16 <Jonno_FTW> so how would I do it?
21:14:13 <JoeyA> you might have to just have to prefix the names
21:14:21 <c_wraith> data Vale = Two | Three | .. | Jack | Queen | King | Ace
21:14:38 <c_wraith> the names need to start with capital letters
21:14:41 <Jonno_FTW> ok
21:15:13 <JoeyA> Is it possible (possibly as an extension) for data constructors to specify predicates that result in run-time errors when they fail?
21:16:05 <Saizan> when you need that you usually hide the real constructors and export only functions that perform such checks before building the value
21:16:29 <JoeyA> e.g. data Value = N (Int x | x >= 2 && x <= 9) | T | J | Q | A
21:17:06 <c_wraith> Uh, 10 is a number like the rest :P
21:17:23 <c_wraith> It's just that if you're going with 1-character abbreviations, it becomes T
21:17:27 <Jonno_FTW> also, thee is a King value as well
21:17:38 <Jonno_FTW> *there
21:18:02 <JoeyA> don't worry about it unless the customer asks for it
21:18:44 <Jonno_FTW> what kind of casino are you running here?
21:18:50 <JoeyA> heh
21:22:13 <kmc> the house always wins
21:25:58 <Jonno_FTW> And that's why I will never go to a casino
21:26:37 <sodium70mg> Just make your own in haskell :)
21:27:39 <Jonno_FTW> I'm making a poker game at the moment
21:27:50 <Jonno_FTW> But the type system is getting to me
21:33:29 <djahandarie> A poker game sounds like it'd be fun to make
21:36:55 <Jafet> > map(show=<<)$let(%)=mod;(/)=div;p '.'=0;p x=digitToInt x;s g=case elemIndices 0 g of[]->[g];(f:_)->(\m->if or$(\i->(m==).(g!!).[f-f%27+f%9/3*3+i/3*9+i%3,f%9+i*9,f-f%9+i])=<<[0..8]then[]else s$take f g++[m]++drop(f+1)g)=<<[1..9]in s.(p.).filter(/='|')$"645.238.1|7.2.1.4..|......36.|..6.84753|...1.6...|28379.6..|.74......|....5.2.7|5.......6" -- Fore!
21:36:56 <lambdabot>   ["6459238717326184958915473629162847534571369282837956141743625893698512475...
21:48:47 <identity> Jafet: wat
21:48:56 <identity> Madness?!
21:48:58 <identity> This is #haskell!
21:48:59 <identity> etc
21:54:50 <kmc> Jonno_FTW, well, you can reliably win money playing poker at a casino
21:54:53 <kmc> if you are good at poker
21:56:58 <Jafet> Some MIT alumni undertook serious, purely academic research into blackjack
21:56:58 <Jonno_FTW> kmc: I'm assuming they would kick you out eventually if you were good
21:57:12 <dobblego> a friend of mine used to do that
21:57:18 <Jafet> Not at poker -- the house takes a cut of the pot all the time.
21:57:21 <kmc> Jonno_FTW, what's their incentive?
21:57:28 <kmc> the house simply takes a cut of all bets placed
21:57:36 <kmc> you're not winning their money; you're winning money from the other dumber players
21:57:46 <Jonno_FTW> hmk
21:57:52 <kmc> they might kick you out if you're so good that you make other players leave
21:57:56 <kmc> but that's against your incentive too
21:58:05 <kmc> because you want them to stay and lose money to you
21:58:53 <Jafet> That's sort of a metametastrategy, huh
21:59:07 <c_wraith> there are a good number of people who make money playing poker at casinos.
21:59:19 <djahandarie> A meta within a meta
22:00:26 <kmc> there's also people who make money playing poker online
22:00:48 <kmc> there you have more control -- for example, you can run odds calculators on your side, and tools that remember other players you've seen and what their playing style is
22:01:08 <djahandarie> I wonder how good of a bot you could make for that
22:01:22 <dobblego> many people write bots to do it
22:01:59 <Jafet> You could write a bot to detect whether your opponents are also using bots
22:02:31 <kmc> yeah, there have been popular bots that recognize each other and collude
22:03:11 <Jafet> Heh
22:03:28 <Jafet> That reminds me of the tit-for-tat program contest
22:03:40 <kmc> you can do really well at a poker table if you secretly occupy 7 seats and some sucker has the 8th
22:03:41 <Jonno_FTW> oh wow
22:04:13 <mm_freak> i just calculated the first 10^9 primes using the sieve of eratosthenes in 97 seconds…  in haskell =)
22:04:37 <Jonno_FTW> mm_freak: have you looked at the primes package available on hackage?
22:04:46 <mm_freak> Jonno_FTW: sure
22:04:53 <Jonno_FTW> and there was another one I found
22:05:01 <Jonno_FTW> that uses a probabilistic methofd
22:05:13 <mm_freak> there are quite a few, since every haskell newbie implements the SOE at some point =)
22:05:39 <mm_freak> but i've written an optimized variant for a program i'm about to write
22:05:45 <Jafet> primes 1 1000000000 > /dev/null  10.25s user 0.01s system 99% cpu 10.341 total
22:06:00 <mm_freak> Jafet: haskell program?
22:06:31 <Jafet> Although, bsd primes cheats by embedding the whole sieve up to 2^16.
22:06:42 <tolkad> How do I enable this extension? http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions/TotalFamilies
22:06:47 <Jafet> And they sieve using memcpy or something. Weird stuff.
22:07:14 <mm_freak> well, up to 2^16 isn't that much of a cheating, since sieving up to 2^16 is very cheap
22:07:28 <kmc> woah
22:07:33 <mm_freak> anyway, i'm using the bare SOE in haskell, so 97 seconds seems impressive to me
22:07:35 <kmc> i've never seen this tolkad, i don't think it's implemented
22:07:49 <dark> here there is a lot of files like darcs3107-new_65a126b1832953999326c7e599a09782, darcs3461-new_44afc411b2433d447b5d669d1a400dcf .. on the gentoo-haskell overlay. they were created by darcs pull. and all of that is empty files. why is that?
22:07:56 <dark> might be related on how darcs works
22:09:23 <djahandarie> tolkad, yeah, that isn't implemented yet
22:10:48 <tolkad> I went here: http://www.haskell.org/ghc/download.html
22:10:57 <tolkad> and I clicked "Check build status"
22:11:01 <tolkad> and it was a 404
22:11:13 <tolkad> http://darcs.haskell.org/buildbot/head/
22:11:27 <djahandarie> buildbot is apparently just not there at all
22:13:00 <djahandarie> Okay, looks like they moved off of buildbot onto a new system thew wrote
22:13:03 <djahandarie> they
22:13:37 <djahandarie> tolkad, see http://darcs.haskell.org/ghcBuilder/builders/ for the build results
22:14:43 <djahandarie> I'm not sure who should be contacted to fix that other link
22:15:04 <djahandarie> Nor where it should link to now, since the new system is distributed
22:21:38 <Jonno_FTW> > ((== 2) . length)  $ filter ((== 2) . length) ["ab","cd","e"]
22:21:39 <lambdabot>   True
22:22:00 <Jonno_FTW> could that be shortened at all?
22:22:14 <Jonno_FTW> @pl ((== 2) . length)  $ filter ((== 2) . length) ["ab","cd","e"]
22:22:14 <lambdabot> length (filter ((2 ==) . length) ["ab", "cd", "e"]) == 2
22:22:45 <Jonno_FTW> @pf ((== 2) . length)  $ filter ((== 2) . length) ["ab","cd","e"]
22:22:45 <lambdabot> Maybe you meant: bf pl
22:28:19 <djahandarie> Jonno_FTW, f = let g = ((== 2) . length) in g . filter g
22:28:23 <kmc> Jonno_FTW, weird, you're applying the same predicate to the elements of the list and to the filtered list itself
22:28:41 <djahandarie> There is probably some generalization of this pattern but I don't know it
22:29:06 <kmc> what's the use case for this code?
22:32:22 <Jafet> @pl \p x -> p $ filter p x
22:32:23 <lambdabot> ap (.) filter
22:32:55 <Jonno_FTW> to check if there is 2 pairs in a hand of poker
22:35:57 <dobblego> http://paste.pocoo.org/show/276106/
22:39:32 <Jonno_FTW> Any comments to be made on this? I don't really know how to give a maybe value to the Hands http://hpaste.org/40616/poker
22:41:53 <Zao> Jonno_FTW: I don't see any maybeness about it.
22:42:30 <Zao> Jonno_FTW: If you're by happenstance doing #54, you need the hand to disambiguate ties too.
22:42:43 <Jonno_FTW> this is true
22:43:07 <Zao> Also, pay particular care to the full house example :D
22:43:31 <Zao> As for value, pick a "representative" card for that scoring combination.
22:43:34 <Jonno_FTW> yeah
22:44:08 <Jonno_FTW> yep
22:44:32 <Zao> Your ctors on 19-20 and lines 24-25 seem to disagree somewhat.
22:45:01 <Zao> Make  HRoyalF Value  into  HRoyalF (Maybe Value)?
22:45:15 <Zao> Or simply HRoyalF
22:45:18 <dmwit> Aces can be high or low, mate.
22:45:31 <Jonno_FTW> this is pretty much my first proper use of data
22:45:35 <Zao> dmwit: Isn't it nice that everyone has different rules for Poker?
22:45:52 <Zao> dmwit: In the case of Project Euler #54, aces are always high.
22:45:53 <dmwit> Really?
22:45:59 <dmwit> okay then =)
22:49:16 <ManateeLazyCat> I wonder System package use withCString, it's wrong binding for low-level C function, when your filepath is not same encode as locate.
22:49:20 <Zao> @type [Just (Just 9001), Nothing, Just Nothing]
22:49:21 <lambdabot> forall a. (Num a) => [Maybe (Maybe a)]
22:49:44 <dmwit> Jonno_FTW: My biggest comment is that your "Hand" has the same data in every constructor, so you could just factor that out.
22:50:00 <dmwit> data Hand = HHigh | HOne | HTwo | ...; type HandValue = (Hand, Value)
22:50:14 <ManateeLazyCat> Right thing should use ByteString as fielpath argument pass to C function, then use other package handle encode with ByteString.
22:50:32 <dmwit> locale--
22:50:40 <dmwit> Just everybody use UTF8 already.
22:50:52 <ManateeLazyCat> dmwit: Not true.
22:51:08 <c_wraith> ManateeLazyCat, that was an order, not a description of the current state.
22:51:09 <ManateeLazyCat> dmwit: IIRC, windows xp Chinese version use GB2312
22:51:43 <dmwit> Everybody who is not currently using UTF8 should switch to UTF8.
22:51:53 <dmwit> (Hopefully that sentence is less ambiguous. =)
22:52:27 <ManateeLazyCat> dmwit: Yes, if everybody's UTF8, withCString will do right thing.
22:52:39 <ManateeLazyCat> s/everybody's/everybody use
22:53:59 <Zao> dmwit: Good luck switching OSes where narrow codepages are next to deprecated.
22:54:02 <Zao> +on
22:54:22 <Zao> If you want to be an unicodey person on Windows, you use UTF-16 at the surface.
22:54:24 <ManateeLazyCat> Now i need write ByteString version file/directory function to handle variant encoding filepath.
22:54:52 <ManateeLazyCat> All withCString binding in System package can't work for me now.
22:55:52 <dmwit> ManateeLazyCat: =/
22:57:24 <ManateeLazyCat> dmwit: Infact, i write batch GTK+/GIO file/directory functions to replace function in System package, including gtk2hs interface to ByteString.
22:57:38 <digitteknohippie> quick question:   could someone tell me what <+> means?     (or point me in the direction of where to paruse and learn such things?
22:57:39 <ManateeLazyCat> dmwit: I hope System package author will switch to ByteString someday.
22:57:54 <dmwit> digitteknohippie: Come join us in #xmonad!
22:58:03 <digitteknohippie> lol.
22:58:06 <ManateeLazyCat> dmwit: ByteString always can work even you don't know the encoding of filepath.
22:58:08 <digitteknohippie> just came from there. XD
22:58:12 <SubStack> :t (<+>)
22:58:13 <lambdabot>     Ambiguous occurrence `<+>'
22:58:13 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
22:58:13 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
22:58:17 <digitteknohippie> thought i'd ask my question here too.  XD
22:58:21 <SubStack> o_O
22:58:33 <dmwit> digitteknohippie: (<+>) is mappend
22:59:08 <dmwit> digitteknohippie: For types that have an associative binary operator, (<+>) does that operation.
22:59:49 <dmwit> digitteknohippie: For example, for lists, (<+>) is list-append; for (a -> a) functions, (<+>) is function composition; for numbers, (<+>) can be addition or multiplication, depending.
22:59:56 <digitteknohippie> ah.  ok.  thnx for the clarification dmwit
23:00:11 <dmwit> digitteknohippie: ...and for ManageHooks, (<+>) runs them both in sequence. =)
23:01:13 * digitteknohippie ponders the implications for his next move in his xmonad.hs frankensteinesq laboratory 
23:01:57 <dmwit> digitteknohippie: As for getting more information yourself in the future, here's a tip.
23:02:08 * digitteknohippie is all ears
23:02:18 <dmwit> You can find out which module exports a function by loading your config in ghci, and typing ":i functionname".
23:02:40 <dmwit> So, for example, ":i <+>" says "-- Defined in XMonad.ManageHook"
23:02:51 <dmwit> Then you can check out the documentation for that module to learn more.
23:03:39 <dmwit> docs for xmonad modules are available either under "xmonad api docs" or "xmonad-contrib api docs" here: http://xmonad.org/documentation.html
23:07:48 <mjrosenb> shouldn't that be :i (<+>)?
23:11:13 <digitteknohippie> neither seems to give the result 
23:12:25 <mjrosenb> digitteknohippie: did you import Control.Arrow or Text.PrettyPrint.HighesPJ?
23:12:47 <digitteknohippie> not unless i could have done that without knowing
23:14:00 <mjrosenb> i believe :i only searches libraries that have been imported
23:16:58 <digitteknohippie> ah, that'd be the "by loading your config in ghci" i overlooked...  hehe, almost had to ask how.   ... what little i learned a while back is starting to come back to me.  ^_^
23:18:06 <Axman6> time to learn more!
23:18:22 <digitteknohippie> :)   totally.   i'm on it.
23:18:38 <digitteknohippie> though, it's always that time Axman6. ;)
23:25:15 <kwuxalot> Is there a way to specify default implementation for part of a type class?
23:26:55 <shachaf> kwuxalot: Sure. Just put it in the class definition.
23:27:15 <copumpkin> unless it's an associated type
23:27:19 <mjrosenb> shachaf: i assume he meant the one that you get with deriving.
23:27:32 <copumpkin> if you use UHC :)
23:27:58 <shachaf> mjrosenb: What do you mean?
23:28:24 * mjrosenb now thinks he misread the original statement.
23:28:31 <kwuxalot> shachaf: how do you like my new name?
23:28:58 * mjrosenb was thinking of overriding Show where i frequently want to print everything as the derived instance prints it, but change one case
23:28:59 <shachaf> kwuxalot: About as sensical as the old one.
23:29:03 <kwuxalot> shachaf: :-P
23:29:12 <kwuxalot> shachaf: I like it because it's more gender neutral
23:30:28 <kwuxalot> I think it was more like a "it's late and I was tired" sort of question
23:30:48 <kwuxalot> then an intelligent query
23:30:56 <kwuxalot> s/then/than/
23:30:59 * shachaf awaits the intelligent query. :-)
23:31:00 <shachaf> Aw.
23:31:53 <shachaf> kwuxalot: At any rate, it's used pretty often, if I understood your question (which maybe I don't).
23:32:29 <kwuxalot> shachaf: I think you did, and that's approximately what I was wondering: if you could just put definitions straight in the class... but how's that different from making a top level definition?
23:32:44 <shachaf> kwuxalot: Well, it can be overridden by instances.
23:33:00 <kwuxalot> shachaf: ah, without producing a compile error
23:33:05 <kwuxalot> got it
23:33:05 <shachaf> @src Eq
23:33:05 <lambdabot> class  Eq a  where
23:33:06 <lambdabot>     (==), (/=)   :: a -> a -> Bool
23:33:34 <shachaf> Hmm. Not a complete definition.
23:33:41 <kwuxalot> yeah, that's a weir dsyntax
23:33:46 <shachaf> ?
23:34:03 <kwuxalot> "(==), (/=) :: ..."?
23:34:29 <kwuxalot> I didn't know you could do that
23:34:30 <shachaf> Pretty standard syntax. "f, g :: a" means "f :: a; g :: a".
23:34:39 <kwuxalot> cool
23:34:52 <kwuxalot> is that Haskell 98?
23:35:02 <shachaf> Yes.
23:35:05 <kwuxalot> oh :-P
23:35:11 <shachaf> Anyway, normally there's a "x /= y = not (x == y); x == y = not (x /= y)" there. So you can override one or the other or both.
23:35:51 <kwuxalot> right, that's basically what I want to do in my specific case
23:36:05 <kwuxalot> :-}}
23:36:13 <shachaf> Same thing with (>>) in Monad. Though in both cases it's really just for optimization.
23:37:15 <mjrosenb> did someone think that declaring multiple variable with a single type was a good feature of C?
23:37:46 <shachaf> mjrosenb: It's a great feature of C! Especially when you put the '*' next to the type for clarity.
23:38:12 <mjrosenb> yes, because the * is so very much part of the type
23:38:13 <Cale> http://www.flickr.com/photos/cgibbard/ -- magnetsmagnetsmagnets
23:38:15 <mjrosenb> oh god
23:38:38 <mjrosenb> i bet that means you can do int x, (*y)(int)
23:38:41 <mjrosenb> can't you.
23:39:22 <kwuxalot> mjrosenb: I refuse to parse such scary C
23:39:40 <kwuxalot> mjrosenb: it's my form of lazy evaluation
23:39:56 <shachaf> mjrosenb: Recently JSLint was telling me that all variable declarations *must* be in one statement.
23:40:11 <Jafet> Cale: did they make you more attractive?
23:40:18 <shachaf> (Which you can argue makes sense with JavaScript's ridiculous scoping rules.)
23:40:58 * mjrosenb could write a very thorough jslint program
23:41:02 <Cale> Jafet: Maybe if I ate a bunch... nah, that'd probably just require a visit to the hospital.
23:41:03 <Jafet> I've never written a variable declaration in javascript
23:41:08 <mjrosenb> it would just print out WARNING: you are using javascript
23:41:35 <kwuxalot> mjrosenb: lol
23:41:47 <shachaf> mjrosenb: That would be surprisingly effective.
23:42:01 <kwuxalot> mjrosenb: WARNING: you are probably not being paid a high enough sallary for this shit
23:52:03 <monadwr> :)
23:52:39 <monadwar> ltns, #haskell :)
23:53:02 <monadwar> (and it's dead when I arrive)
23:53:04 <ski> mjrosenb : that C notation is not *that* far from `data Foo = Frob Int String | Barf Bool' ..
23:53:44 <mjrosenb> ski: wait, what now?
23:54:02 <mjrosenb> also oh god
23:54:05 <ski> mjrosenb : one could easily imagine notation like `length (_ :: [a]) :: Int' as an alternative form to `length :: [a] -> Int'
23:54:12 <mjrosenb> http://laughingsquid.com/benoit-b-mandelbrot-1924-2010-father-of-fractal-geometry/
23:54:26 * monadwar wonders whether to recommend haskell as a first language, or x86-asm.
23:54:44 <ski> then one could say `columns,length (_ :: [a]) :: Int' (as a bad example)
23:54:51 <shachaf> ski: Or length (_ :: [Int]) x y :: Int = x + y
23:54:52 <SubStack> I don't think haskell is a good first language, as awesome as it is
23:55:05 <monadwar> SubStack: yeah, probably not
23:55:05 <dobblego> nonsense
23:55:09 <shachaf> ski: Which has the advantage that you can write only part of a type signature.
23:55:12 <monadwar> SubStack: The paradigm shift might confuse one.
23:55:25 <mjrosenb> shachaf: and that would declare columns as an Int and length as [a] -> Int
23:55:25 <ski> shachaf : well, that `length' is not the standard one, then
23:55:27 <dobblego> there is no "paradigm shift" as a first language
23:55:27 <mjrosenb> err
23:55:30 <mjrosenb> ski: ^
23:55:36 <monadwar> dobblego: from haskell onwards.
23:55:37 <shachaf> ski: Er, not length.
23:55:40 <SubStack> it's like teaching a child mathematics by starting with category theory
23:55:40 <monadwar> dobblego: duh :)
23:55:41 <shachaf> s/length/f/g/
23:55:44 <shachaf> s/.$//
23:55:49 <SubStack> instead of arithmeti
23:55:50 <SubStack> c
23:55:51 <monadwar> SubStack: well, what's hard about haskell?
23:56:00 <dobblego> both my children use haskell daily; non-programmers find it easy
23:56:09 <monadwar> dobblego: how old are your children?
23:56:11 <shachaf> SubStack: I'm not certain about category theory, but is arithmetic the best way to teach mathematics?
23:56:12 <dobblego> 7 and 9
23:56:15 <ski> mjrosenb : yes
23:56:18 <monadwar> dobblego: what do they code ?
23:56:29 <dobblego> it's like teaching children mathematics, by teaching mathematics
23:56:41 <monadwar> blergh.
23:56:41 <SubStack> dobblego: for calculator type one-liners I can see it being pretty easy for some stuff
23:56:43 <dobblego> monadwar, beginner exercises
23:56:49 <monadwar> dobblego: lyah?
23:57:06 <dobblego> SubStack, I've been teaching programming for years -- I've not seen any language come anywhere near as appropriate for a first language as haskell
23:57:16 <dobblego> monadwar, no, they just write their own things
23:57:19 <monadwar> dobblego: i'll take your advice.
23:57:21 <kwuxalot> why doesn't ghci have a :src command like lambdabot?
23:57:29 <monadwar> dobblego: Yeah, I'll just recommend hs/lyah 
23:57:29 <ski> SubStack : you should check out the book "Conceptual Mathematics", which is about teaching category theory concepts, instead of the traditional set theory
23:57:43 <monadwar> The person in question isn't good with mathematics.
23:57:48 <shachaf> @where goa
23:57:49 <lambdabot> http://haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
23:58:02 <kwuxalot> also, is there a way to set up a control key or a function key to ":reload Main" or something?
23:58:07 <monadwar> dobblego: thanks.
23:58:13 <dobblego> no worries
23:58:17 <shachaf> kwuxalot: Just ":r"?
23:58:25 <SubStack> > const . (flip =<< ((+) .) . (. join (*)) . (+) . (2 *)) $ 1 2 3
23:58:26 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a -> a)
23:58:27 <lambdabot>    arising from a use...
23:58:28 <SubStack> er
23:58:38 <kwuxalot> shachaf: that's THREE KEY PRESSES: shift, ':', 'r' :'(
23:58:55 <SubStack> > (const . (flip =<< ((+) .) . (. join (*)) . (+) . (2 *))) 1 2 3
23:58:56 <lambdabot>   12
23:59:00 <kwuxalot> I could make it app. 3x faster if it was just F1
23:59:01 <shachaf> kwuxalot: And newline.
23:59:13 <shachaf> Not to mention carriage return!
23:59:17 <SubStack> figuring out what stuff like that does is hard
23:59:37 <shachaf> Anyway, I'm sure you can use some external macro tool to script typing ":r" for you.
23:59:40 <SubStack> there is less machinery at work than an equally horrible piece of stateful C code
23:59:47 <kwuxalot> shachaf: thanks for the GHCi on acid link though... I've been wanting that for months
23:59:55 <shachaf> kwuxalot: Good luck getting it working.
23:59:57 <dobblego> SubStack, write the same in another language and proclaim it to be easier
23:59:57 <kwuxalot> shachaf: to the point of almost trying to do it myself half-assedly
