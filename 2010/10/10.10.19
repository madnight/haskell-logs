00:00:06 <Axman6> Samantha: you do what we told you, find a paste bin site, like any of the ones mjrosenb just showed you, and paste all your code there, and then ask us your questions, ok?
00:00:19 <edlinde> mjrosenb: I am done with the ML exam and guess what.. you know how you were talking about breaking a list into a pair like (element, list before, list after)?
00:00:29 <Botje> 2http://hpaste.org/40703/stuff_from_samantha
00:00:32 <Samantha> I did i paste the code in pastebin
00:00:32 <edlinde> mjrosenb: something similar popped up on the exam :)
00:00:33 <Botje> http://hpaste.org/40703/stuff_from_samantha
00:00:59 <Botje> Samantha: is the code there correct?
00:01:04 <Samantha> yeah u guys got it
00:01:15 <Samantha> I am getting an error message 
00:01:34 <Samantha> :108:0: parse error (possibly incorrect indentation)
00:01:43 <Samantha> hello
00:01:52 <edlinde> mjrosenb: no response to that? :)
00:01:53 <Axman6> the guards (the |'s) need to have at least one space before them
00:01:58 <Samantha> can you guys guide me
00:02:02 <Samantha> which one 
00:02:09 <Samantha> ones?
00:02:09 <Axman6> Samantha: have some patience >_<
00:02:13 <Axman6> both of them
00:02:16 <mjrosenb> edlinde: good to hear.
00:02:26 <Samantha> i am patient
00:02:30 <Axman6> no you're not
00:02:38 <Samantha> ok i am not
00:03:07 <Samantha> ok the first part is ok it works with other functions 
00:03:25 <Samantha> but that second part is the one with the problems?
00:03:37 <Botje> Samantha: note that I reformatted your code. It might just work as pasted
00:03:37 <Axman6> you're missing a closing ) after (\xs -> xs == []) i think
00:04:04 <Samantha> no is ()
00:04:14 <Samantha> only 2 parenthesis
00:04:25 <edlinde> mjrosenb: you use a lot of list comprehensions yourself? I am trying to get the hang of it a bit now
00:04:27 <Axman6> ah, (\(x:xs) -> (f) p (xs) should be (\(x:xs) -> (f) p (xs))
00:04:37 <zachk> samantha use ghc and emacs or vim 
00:04:46 <Axman6> though, i have no idea if that even makes sense
00:04:57 <path[l]> huh? foldr1 is being defined there?
00:05:01 <mjrosenb> edlinde: i use them when they are convenient.
00:05:19 <Axman6> suggestion using emacs or vim... o.O?
00:05:23 <Axman6> ing*
00:05:32 <edlinde> mjrosenb: ok it seems like you can use other things instead to do the same
00:05:48 <edlinde> mjrosenb: last night I got told off for asking questions in the SML channel :)
00:05:50 <zachk> yea something with parentheses matching 
00:05:50 <mjrosenb> edlinde: this is true, but the comprehensions are usually more concise.
00:06:30 <edlinde> mjrosenb: I am glad I learned SML first and then find that haskell provides some pretty nifty features for lists out of the box
00:06:38 <mjrosenb> edlinde: i think there was a bit of confusion as to the meaning of the phrase "stuff it"
00:06:55 <edlinde> mjrosenb: :)
00:07:03 <zachk> @src foldr1 
00:07:03 <lambdabot> Source not found. It can only be attributed to human error.
00:07:17 <edlinde> mjrosenb: I don't think I will be posing any more questions in the SML channel anymore
00:07:28 <Samantha> Yeah i need to define that function
00:07:35 <Samantha> even do is built in
00:07:41 <Samantha> in haskell library
00:08:15 <edlinde> I mean yeah ofcourse you spend some time on the problem trying to figure it out, but its awesome to have someone else who understands SML much better help get some more insight into the problem and getting some concepts cleared
00:08:28 <Samantha> yeah 
00:08:33 <Samantha> is true
00:09:04 <mjrosenb> edlinde: to be fair, a bunch of the stuff that you were asking should have been covered in a basic language independent algorithms course
00:09:06 <Axman6> SML?
00:09:17 <edlinde> mjrosenb: like?
00:09:23 <Samantha> so Axman6 what is my problem?
00:09:23 <mjrosenb> Axman6: yeah, that other functional, statically typed language.
00:09:35 <edlinde> I asked about the infix operator not working on a curried function
00:09:38 <Botje> Samantha: with the obvious corrections, you only give 4 arguments to mapreduce
00:09:46 <edlinde> that to me is pretty SML specific
00:09:52 <mjrosenb> Samantha: you have 6 open parenthses, and 5 closing parentheses.
00:09:54 <Axman6> ah, i missed where SML was first mentioned. (i know what SML is)
00:09:56 <Samantha> ok
00:10:10 <Botje> Samantha: have you tried writing foldr1 recursively first, without the mapReduce?
00:10:30 <mjrosenb> edlinde: the error message had been pretty clear there.
00:10:35 <Samantha> yeah
00:10:48 <Samantha> but I need to implement that with mapreduce
00:11:02 <Botje> Samantha: yes, but mapreduce implements a very common recursion pattern
00:11:18 <Botje> if you look at the similarities, you can deduce at least some of the functions you have to give to mapreduce
00:11:21 <Samantha> i dont get it
00:11:33 <Samantha> i trying my best to understand 
00:11:41 <Samantha> and I really need help
00:11:46 <Botje> for example, the first clause of mapReduce
00:11:51 <Botje> that turnaround stuff
00:11:51 <Samantha> ok 
00:11:54 <Samantha> ok
00:11:58 <Botje> if you look at the definition of foldr1:
00:11:59 <Botje> @src foldr1
00:11:59 <lambdabot> foldr1 _ [x]    = x
00:11:59 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
00:12:00 <lambdabot> foldr1 _ []     = undefined
00:12:20 <Samantha> yeah
00:12:24 <Axman6> > foldr1 show []
00:12:25 <lambdabot>   Couldn't match expected type `a -> a'
00:12:25 <lambdabot>         against inferred type `GHC.Ba...
00:12:27 <Botje> the first clause there (with the [x]) should be the turnaround stuff
00:12:34 <Axman6> > foldr1 id []
00:12:35 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
00:12:37 <Botje> so turnaroundcond should check if xin is a list of length 1
00:12:41 <bos> http://www.reddit.com/r/haskell/comments/dt76u/a_brief_tale_of_faster_equality/
00:12:43 <Axman6> > foldr1 const []
00:12:44 <lambdabot>   *Exception: Prelude.foldr1: empty list
00:12:49 <Axman6> there we go
00:12:50 <Botje> (or, equivalently, check if the tail of xin is null)
00:13:00 <Maxdamantus> > undefined == undefined
00:13:01 <lambdabot>   *Exception: Prelude.undefined
00:13:02 <Samantha> ok
00:13:05 <Botje> and the turnaroundfn should return the first element of the list
00:13:24 <Samantha> which is x
00:13:24 <Maxdamantus> Any forced evaluation of undefined causes an error?
00:13:46 <mjrosenb> Maxdamantus: i should hope so.
00:13:48 <Botje> yes, in the original definition
00:13:53 <Samantha> ok
00:13:56 <pelotom> Maxdamantus: any evaluation whatsoever
00:14:03 <Botje> but you only have access to a list of length one
00:14:11 <Samantha> ok
00:14:15 <Samantha> where?
00:14:17 <Botje> so your turnaroundfn should return the first element of the list is receives
00:14:34 <Maxdamantus> Meh, I was being fairly lax about "evaluation"
00:14:50 <Samantha> is X again?
00:14:57 <Samantha> not the list 
00:15:00 <Samantha> rite?
00:15:00 <Maxdamantus> > snd (undefined, 42)
00:15:01 <Botje> what?
00:15:01 <lambdabot>   42
00:15:05 <Samantha> the list 
00:15:13 <Samantha> [1,2,3]
00:16:04 <Samantha> hello
00:16:05 <mjrosenb> > case undefined of _ -> 2
00:16:06 <lambdabot>   2
00:16:08 <Botje> in the first clause of the mapreduce, you'll only ever see lists of one element
00:16:47 <Maxdamantus> :t undefined
00:16:48 <lambdabot> forall a. a
00:17:04 <Maxdamantus> > case undefined of 42 -> 2
00:17:05 <lambdabot>   *Exception: Prelude.undefined
00:17:25 <mjrosenb> > case undefined of !42 -> 2
00:17:26 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
00:17:47 <mjrosenb> > (\!42 -> 2) undefined
00:17:48 <lambdabot>   <no location info>: parse error on input `->'
00:17:53 <Axman6> > case undefined of 42 -> 2
00:17:54 <lambdabot>   *Exception: Prelude.undefined
00:17:55 <Botje> Samantha: http://hpaste.org/paste/40703/solution_skeleton#p40705
00:18:09 <Botje> you should start with this as a skeleton for solving your assignment
00:18:10 * mjrosenb fails at remembering syntax
00:18:18 <Botje> it makes the mapping a lot more clar
00:18:21 <Botje> *clear
00:18:35 <Botje> turnAroundCond should check if it receives lists of length 1
00:18:48 <Botje> so for now you can use something like turnAroundCond xs = length xs == 1
00:19:00 <pelotom> > const 1 undefined
00:19:01 <lambdabot>   1
00:19:01 <Botje> that's not entirely good, but good enough for now
00:19:25 <Samantha> ok 
00:19:29 <mjrosenb> > const const undefined 1
00:19:30 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a)
00:19:30 <lambdabot>    arising from a use of `...
00:19:41 <Botje> so, in the turnAround case
00:19:43 <mjrosenb> err... whatnow?
00:19:44 <pelotom> > :t [undefined, undefined, undefined]
00:19:45 <lambdabot>   <no location info>: parse error on input `:'
00:19:51 <pelotom> :t [undefined, undefined, undefined]
00:19:52 <lambdabot> forall a. [a]
00:19:52 <Botje> turnAroundCond has decided your list has length one
00:19:59 <Botje> turnAroundFn shouuld return the first element of that list
00:20:04 <Botje> how would you write that?
00:20:05 <Samantha> ok 
00:20:07 <Maxdamantus> > snd $ (undefined . id, 42)
00:20:08 <lambdabot>   42
00:20:11 <pelotom> :t [undefined, undefined, undefined]::[forall a.a]
00:20:12 <lambdabot> [forall a. a]
00:20:16 <mjrosenb> :t const const
00:20:17 <lambdabot> forall a b b1. b1 -> a -> b -> a
00:20:20 <Maxdamantus> > fix undefined
00:20:21 <lambdabot>   *Exception: Prelude.undefined
00:20:27 <Samantha> turnaroud x = x
00:20:28 <mjrosenb> :t const const undefined 1
00:20:29 <lambdabot> forall a b. (Num a) => b -> a
00:20:42 * mjrosenb seems to have forgotten an argument?
00:20:42 <Samantha> like that
00:20:59 <Botje> Samantha: no, that returns the whole list
00:21:00 <Axman6> :t [undefined::Int, undefined::String] :: [forall a. a]
00:21:01 <lambdabot>     Couldn't match expected type `a' against inferred type `Int'
00:21:01 <lambdabot>       `a' is a rigid type variable bound by
00:21:01 <lambdabot>           the polymorphic type `forall a. a' at <interactive>:1:0
00:21:10 <Botje> > let turnaround x = x in turnaround [5]
00:21:11 <lambdabot>   [5]
00:21:14 <Maxdamantus> > let f undefined = 42; f n = n*4 in [f 10, f undefined]
00:21:15 <lambdabot>   [42,42]
00:21:18 <Samantha> so turnaround (x:xs) = x
00:21:20 <Maxdamantus> O_o
00:21:24 <Samantha> like that
00:21:35 <Maxdamantus> Oh, right
00:21:37 <Axman6> Maxdamantus: undefined just becomes a variable name there
00:21:39 <Botje> yes
00:21:41 <Maxdamantus> undefined's jjust a symbol.
00:21:52 <pelotom> Maxdamantus: in that case you're shadowing "undefined" with another variable
00:21:57 <Botje> that's two down
00:22:09 <Samantha> Botje all the chats are getting mix 
00:22:13 <Samantha> no I am lost 
00:22:34 <Samantha> since everybody is typing at the same time
00:22:42 <pelotom> Samantha: welcome to IRC :)
00:22:46 <Botje> Samantha: i sent you a private message
00:22:50 <Samantha> where?
00:22:54 <Botje> it should be a tab or a button somewhere
00:23:34 <pelotom> :t [undefined, 3]
00:23:35 <lambdabot> forall a. (Num a) => [a]
00:25:50 <periodic> I'm having an issue where cabal/ghc-pkg doesn't seem to be registering my install of happy through cabal-install.  Would anyone have any ideas?
00:26:09 <dcoutts> periodic: happy is a program, so it does not get registered
00:26:17 <dcoutts> it just gets found on the $PATH
00:26:39 <dcoutts> periodic: ghc-pkg manages the registration of libraries
00:26:41 <periodic> So why does haskell-src-exts depend on it on hackage?
00:27:14 <periodic> oooh.
00:27:15 <dcoutts> periodic: because haskell-src-exts uses happy
00:27:17 <periodic> ooooooooh!
00:27:31 <dcoutts> because it has a .ly grammar file
00:27:46 <periodic> right... I didn't have happy in my path.
00:27:57 <Botje> no happy makes ghc something something
00:27:58 <periodic> :)
00:27:59 <periodic> thanks.
00:28:20 <dcoutts> periodic: could the error message have been better do you think? any suggestions?
00:28:44 <mjrosenb> dcoutts: long time, no see.
00:28:57 <periodic> It's "happy version >=1.17 is required but it could not be found." which made me think it was looking for another haskell package for some reason.
00:29:26 <dcoutts> mjrosenb: I've been in thesis writing mode :-)
00:29:27 <periodic> Perhaps if it said that happy "could not be found in your path"
00:29:34 <dcoutts> periodic: ah right, ok
00:29:40 <nickela> hello, any body using HaXml with different encodings?
00:30:01 <periodic> Good idea about getting a better message.
00:31:19 <nickela> I can't parse xml with differenet encoding than system (under Linux onyl utf-8 xml files parsed normally, under WinXP only current codepage encoding works ok)
00:32:23 <nickela> but if I try parse valid xml with different encoding than system default, I get garbage in text nodes, or parsing can fail at all
00:33:47 <nickela> libxml (under C++) parse this files ok, and alway return UTF8, 
00:34:40 <nickela> as I see HaXml doesn't perform any encoding conversions, or I am wrong?
00:34:42 <pelotom> one thing I think would be neat to have in haskell is a way to make functions by punching holes in expressions, like "3 * _ + 4", which would be sugar for "\x -> 3 * x + 4"
00:34:49 <pelotom> thoughts?
00:34:55 <periodic> dcoutts: maybe the newer version of Cabal has a better message.  I'm a few minor versions behind. :)
00:35:06 <periodic> if not, where do I submit a patch?
00:35:26 <lantti> pelotom: Try a logic-language.
00:35:31 <mjrosenb> pelotom: where do you define the beginning and end of it?
00:35:40 <dcoutts> periodic: don't worry, I'm taking a quick look at the code
00:35:50 <pelotom> mjrosenb: hrm... good question
00:36:11 <mjrosenb> dcoutts: but if you graduate, then where will you get money from?
00:36:17 <pelotom> veeery good question :)
00:36:37 <periodic> dcoutts: oh, thanks.  Glad I could help make things better.
00:37:03 <mjrosenb> every once in a while, i want to write something like ((^3).)
00:37:09 <mjrosenb> err
00:37:10 <dcoutts> mjrosenb: heh, I don't get any money from being a student
00:37:14 <mjrosenb> no, that works...
00:37:24 <mjrosenb> what was the one that *doesn't* work
00:38:50 <mjrosenb> (3+4*)
00:38:54 <mjrosenb> there we go...
00:40:43 <pelotom> mjrosenb: maybe make parens delimit it
00:40:53 <pelotom> and anything more complex you'd have to use lambda notation
00:41:06 <pelotom> (3+4*_)
00:43:34 <dcoutts> periodic: so I can make it say "The program happy version >=1.17 is required but it could not be found."
00:44:17 <dcoutts> periodic:  but mentioning something about the path is hard because at the point where we generate the error message we do not know if we looked for that program on the path or somewhere else (each known program has method for finding it, the default is the path but it can do anything else)
00:45:47 <mjrosenb> pelotom: i imagine there will still be hideous abuses such as (_ . (_ * _) . (_ + _))
00:46:01 <mjrosenb> pelotom: then again, than's what ghc is for, isn't it?
00:46:20 <pelotom> mjrosenb: that's part of the fun :)
00:48:16 * dcoutts wonders why people are so afraid of lambdas that they invent horrible section syntax
00:48:52 <mjrosenb> dcoutts: point free.
00:49:00 <mjrosenb> dcoutts: poooooiiiinnnnnnnnntt freeeeeeee!
00:49:09 * mjrosenb does not know
00:49:14 <dcoutts> :-)
00:49:58 <pelotom> dcoutts: it's not out of fear... isn't economy of expression one of the maxims of haskell?
00:50:06 <pelotom> and yes, point-free :)
00:50:15 <mjrosenb> dcoutts: tbf, i usually use the one with fewer parentheses.
00:51:43 <Saizan> if economy of expression was so important we'd use perl :)
00:51:56 <Saizan> *were, i guess
00:52:22 <mjrosenb> lisp used up all of our parentheses decades ago, now they're as scarce as uranium
00:52:48 <pelotom> hehe
00:53:03 <pelotom> lisp really overdid it with the parens
00:54:06 <mjrosenb> and now we are paying the price for our forefathers' shortsightedness!
00:54:59 <koala_man> I heard that the parentheses you buy on the black market are often just O's split in two, or poorly straightened {}s
00:57:46 <pelotom> I try to conserve by using $'s, but they're so damn expensive
00:59:06 <mjrosenb> :k fix
00:59:07 <lambdabot> Not in scope: type variable `fix'
00:59:16 <mjrosenb> :k Fix
00:59:17 <lambdabot> Not in scope: type constructor or class `Fix'
00:59:22 <mjrosenb> grr....
01:01:16 <gju> hi
01:01:59 <pelotom> > let fix f = f (fix f)
01:02:00 <lambdabot>   not an expression: `let fix f = f (fix f)'
01:02:11 <sipa> @let fix f = f (fix f)
01:02:12 <lambdabot>  <local>:1:11:
01:02:12 <lambdabot>      Ambiguous occurrence `fix'
01:02:12 <lambdabot>      It could refer to either ...
01:02:47 <pelotom> :t fix
01:02:48 <lambdabot> forall a. (a -> a) -> a
01:04:07 <pelotom> > fix (scanl (+) 0 . (1:))
01:04:08 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:04:12 <act_as_coder> Hi All, I'm a totally beginner, how I can read from stdin a sentence of numbers, for example 123456789 and threat them as a list ?
01:05:36 <mjrosenb> act_as_coder: how do you want "123456789" to be parsed?
01:05:36 <periodic> dcoutts: What about "Unable to locate executable for happy. Version >= 1.17 is required but could not be found"?
01:05:50 <sipa> > fix $ scanl (+) 0 . (:)
01:05:51 <lambdabot>   Couldn't match expected type `[a]'
01:05:51 <lambdabot>         against inferred type `[[a]] -> ...
01:05:55 <sipa> meg
01:05:56 <sipa> meh
01:06:24 <act_as_coder> mjrosenb: I want to have a list of integers
01:06:40 <pelotom> act_as_coder: a string is just a list of characters
01:06:50 <mjrosenb> act_as_coder: so you want [12,34,567,8,9]?
01:07:04 <act_as_coder> mjrosenb: [1,2,3,4,5,6,7,8,9]
01:07:20 <dschoepe> > map digitToInt "123456789"
01:07:21 <lambdabot>   [1,2,3,4,5,6,7,8,9]
01:07:30 <sipa> :t digitToInt
01:07:31 <lambdabot> Char -> Int
01:07:37 <sipa> right :D
01:07:43 <mjrosenb> stupid type synonyms :(
01:09:49 <mjrosenb> data LT m a = Node a (m (LT m a))
01:10:09 <act_as_coder> mjrosenb: line <- getLine
01:10:19 <act_as_coder> mjrosenb: line gives me "123456789"
01:10:22 <mjrosenb> how can i require that (Show (m b)) for this?
01:10:47 <act_as_coder> mjrosenb: what next ?
01:10:49 <pelotom> act_as_coder: fmap (\l -> map digitToInt l) getLine
01:11:28 <act_as_coder> pelotom: Not in scope: `digitToInt'
01:11:38 <pelotom> act_as_coder: import Data.Char
01:12:49 <act_as_coder> pelotom: Thank, as a noob, how I can know which library should I import to which function ?
01:13:02 <pelotom> act_as_coder: hoogle
01:13:17 <pelotom> http://www.haskell.org/hoogle/
01:13:25 <act_as_coder> pelotom: nice, thanks :)
01:13:29 <act_as_coder> bye
01:14:47 <mjrosenb> http://hpaste.org/40708/what_now
01:14:55 <mjrosenb> i'm sure i can do something cool with that
01:15:00 <mjrosenb> but i can't think of anything
01:16:11 <mjrosenb> also, i am not sure how to write/derive a Show instance for this.
01:23:36 <quicksilver> you can't, in general.
01:23:54 <quicksilver> you can write a show instance conditional on (m a) having a show instance, I'm sure.
01:25:21 <mjrosenb> m a, or m b and b?
01:26:01 <mjrosenb> or rather m b for any given b?
01:27:31 <sipa> deriving instance (Show a, Show (m (LT m a))) => Show LT m a
01:27:34 <sipa> does that work?
01:27:44 <sipa> Show (LT m a)
01:29:18 <quicksilver> logically it should be (Show a, forall b . Show b => Show m b)
01:29:29 <quicksilver> but you can't have higher-order contexts
01:29:39 <quicksilver> however, there is a way to do this - that's how there is a Show instance for Mu
01:29:42 <quicksilver> I just forget how it works.
01:29:59 <quicksilver> mjrosenb's type is a special case of Mu
01:30:36 <quicksilver> data LT' m a b = Node' a (m b)
01:30:49 <quicksilver> then Mu (LT' m a) is isomorphic to mjrosenb's LT
01:31:22 <sipa> haha http://www.willamette.edu/~fruehr/haskell/evolution.html
01:31:39 <mjrosenb> sipa: parse  error.
01:31:58 <sipa> mjrosenb: yes, i suppose you'll have to do it quicksilver's way :)
01:48:16 <mikihito> hi!
01:48:40 <mikihito> anybody is it?
01:49:00 <Raevel> i... i might be it?
01:49:40 <mikihito> sorry , i'm japanese.english week.
01:50:49 <mikihito> i wanted to say "Someone?".
01:51:35 <pelotom> someone is in here?
01:51:39 <pelotom> yes
01:51:48 <pelotom> people are in here
01:52:24 <mikihito> pelotom,do you from
01:53:20 <pelotom> I've been known to from on occasion
01:53:56 <Raevel> okay let's be nice :-)
01:55:29 <sipa> hajimemashite!
01:56:51 <pelotom> ohayougozaimasu ^_^
01:56:58 <Jafet> (Isn't ruby the native japanese programming language?)
01:57:08 <Lemmih> I'm from the Glorious Empire of Denmark.
01:57:13 <pelotom> gomene
02:01:29 <jamy> ruby is international
02:02:12 <Lemmih> Rubyは国際的です。
02:02:16 <mikihito> greate!! arigatou!!thx (^_^)/^^
02:03:22 <Guest11055> kowaii ><
02:03:28 <pelotom> mikihito: haskell ga suki desuka?
02:03:52 <pelotom> ichiban suki desune
02:04:34 <Jafet> Or maybe it's perl... http://uguu.org/sources.html
02:04:44 <mikihito> i think haskell is defficult. but , i wll charenge 
02:05:10 <mikihito> nihonngo jouzu desune!!
02:05:13 <mikihito> bye
02:05:13 <pelotom> hai, taihen desu
02:05:20 <Guest11055> how do you pronounce "haskell" in Japan? :-)
02:05:28 <Guest11055> awww :(
02:05:29 <pelotom> hasukeru
02:05:33 <Guest11055> hehe
02:08:06 <mrdk> How can I easily get the "unix timestamp" in microseconds using haskell?
02:09:05 <pelotom> oops, I said "taihen" and I meant "muzukashii"
02:09:30 <pelotom> I'm a bad embassador
02:09:40 <Jafet> Rather easily, I suppose, if you're on a unix.
02:13:01 <siracusa> mrdk: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/time-1.1.4/Data-Time-Clock-POSIX.html
02:15:39 <mrdk> siracusa: thank you, I'll take a look at it
02:17:11 <siracusa> Oh wait, you want the number of microseconds?
02:17:30 <mrdk> siracusa: yes
02:19:46 <mrdk> siracusa: I tried with getClockTime from System.Time
02:22:05 <siracusa> mrdk: Then try Data.Time.Clock.getCurrentTime and do a diffUTCTime with the start of the real unix time. You'll get a NominalDiffTime wich has a precision of 10^(-12) according to the docs, not sure how to get the number of microseconds though.
02:23:01 <siracusa> * 10^(-12) sec
02:23:42 <sipa> does anyone know whether there exists something like WinGHCi, but for other platforms?
02:23:53 <mrdk> siracusa: hmm well, that ain't bad I guess. Basically I just need a good unique number, dependent on time
02:48:37 <ketil> bastl: line 4 +5 : Configuration config <- readConfig `fmap` readFile rulefile
02:48:53 <ketil> Oops. that was old.
02:52:52 <finlaytt> hi
02:53:32 <finlaytt> still struggling with a Codec.Compression.Zlib + cabal problem.
02:53:43 <finlaytt> Im thinking of a fresh install
02:54:08 <finlaytt> is the right way to install from ubuntu packages ? or from tar.gz files...
03:24:00 * hackagebot wordsetdiff 0.0.2 - Compare two files as sets of words or sets of N-tuples of words.  http://hackage.haskell.org/package/wordsetdiff-0.0.2 (RyanNewton)
03:24:13 <Samantha> Hello
03:24:19 <Samantha> is people still here
03:24:31 <Samantha> is late
03:24:42 <Taejo> Samantha: or early
03:24:47 <Taejo> or midday (in my case)
03:24:49 <wto> Or mid-day!
03:24:54 <wto> ah
03:24:58 <Samantha> yeah is true
03:25:17 <Samantha> is Botje here?
03:27:34 <Samantha> ll
03:39:28 <Maxdamantus> :t fix id $ fix id
03:39:29 <lambdabot> forall b. b
03:41:24 <sipa> :t fix id
03:41:25 <lambdabot> forall a. a
03:42:42 <Maxdamantus> Can anyone think of a statically-non-inferred-typed purely functional language?
03:43:12 <zygoloid> Maxdamantus: c++'s template language.
03:43:34 <Maxdamantus> Hm :\
03:43:34 <Cale> zygoloid: Can that really be said to be typed at all?
03:44:14 <Jaak> on related note, were concepts dropped from new C++ standard?
03:44:48 <Cale> Maxdamantus: most dependently typed languages have little or no type inference.
03:44:59 <Cale> Jaak: That's what I heard.
03:45:22 <Cale> Personally, I don't think people should be putting effort into changing C or C++ in any way.
03:45:56 <zygoloid> Jaak: yeah, iiuc the committee couldn't decide whether they should be implicit (as per current templates) or explicit (as per haskell type classes)
03:46:09 <Jaak> yeah, C++ kind of is a frankenstein already
03:46:29 <zygoloid> Cale: think of the legacy codebases! i'm really looking forward to some of the 0x features
03:46:37 <smorg> needs a viable replacement that everyone can agree upon.
03:46:58 <Cale> There are lots of viable replacements that nobody needs to agree upon :)
03:46:59 <kamatsu> i want to sha1 hash a String, not a ByteString
03:47:13 <smorg> Cale: indeed :)
03:47:21 <kamatsu> it looks like the best approach is to pack the string into a bytestring and hash that because no libraries support standard String anymore :(
03:47:55 <Cale> kamatsu: Well, if you have a SHA-1 hash which operates on ByteString, then you can simply encode the String first in some way.
03:48:28 <Maxdamantus> Cale: but it seems difficult to have a dependently typed purely functional language that's not inferred.
03:48:30 <Cale> kamatsu: If you're afraid of losing unicode characters, don't use Data.ByteString.Char8, instead use a UTF-8 (or other unicode) encoding
03:48:49 <kamatsu> as i'm hashing it anyway
03:48:52 <kamatsu> i suppose it doesn't matter
03:49:16 <Cale> Maxdamantus: Anything much more complicated than HM, and type inference starts to break down.
03:49:19 <kamatsu> it just feels like i'm pulling in alot of machinery to do something that should be cheap
03:49:47 <Cale> Maxdamantus: Even in Haskell, type inference isn't complete, since we have typeclasses.
03:49:58 <ski> also polymorphic recursion
03:50:43 * ski wonders what Cale is thinking of ..
03:51:02 <zygoloid> haskell seems to make a very good tradeoff between inference and expressivity
03:51:08 <zygoloid> ghc haskell specifically
03:51:15 <Cale> ski: In what regard?
03:52:01 <ski> Cale : i was wondering which incompleteness of type inference wrt type classes you were thinking of ..
03:52:30 <edlinde> I was just reading the haskell tutorial and came across a function called "elem"... is there a way to quickly read it's reference/
03:52:31 <edlinde> ?
03:52:35 <edlinde> like a manpage in GHC?
03:52:35 <ski> what is an example of where types can't be inferred, when using type classes ?
03:52:39 <edlinde> or a site that you refer to
03:52:43 <ski> @src elem
03:52:43 <lambdabot> elem x    =  any (== x)
03:52:52 <Cale> ski: Ambiguous types
03:53:04 <quicksilver> ski: read.show
03:53:08 <edlinde> nah I meant like a manpage or something
03:53:15 <ski> ah, right. ty
03:53:23 <quicksilver> ski: or, actually, just (read "Foo")
03:53:29 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/index.html
03:53:32 <Cale> edlinde: ^^
03:53:37 <quicksilver> no, that does have a type ;)
03:53:48 <edlinde> yeah got that
03:53:51 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Prelude.html#v%3Aelem
03:53:52 <zygoloid> edlinde: if you look it up on the hoogle website, it'll provide a link to the documentation
03:53:56 <edlinde> but I don't know where elem belongs to
03:54:03 <Maxdamantus> :t read
03:54:03 <lambdabot> forall a. (Read a) => String -> a
03:54:05 <Cale> It belongs to the Prelude
03:54:08 <edlinde> hoogle?
03:54:25 <Cale> also there's an index
03:54:32 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/doc-index.html
03:54:34 <ski> edlinde : see `elem' a bit under <http://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1720009.1> in the language report
03:54:36 <zygoloid> edlinde: http://www.haskell.org/hoogle/?hoogle=elem
03:54:59 <cathper> edlinde: Yep, hoogle is nice :-)
03:55:31 <ski> @index elem
03:55:31 <lambdabot> Data.List, Prelude
03:55:49 <edlinde> hoogle looks cool
03:55:59 <ski> @hoogle elem
03:56:00 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
03:56:00 <lambdabot> Data.ByteString elem :: Word8 -> ByteString -> Bool
03:56:00 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
03:56:04 <zygoloid> edlinde: hoogle can also search for functions by type, so if you know what you want and think it should probably exist, it can help you find it
03:56:08 <edlinde> when it takes me to the prelude page... does it show me examples of how to use elem?
03:56:11 <zygoloid> @hoogle Eq a => a -> [a] -> Bool
03:56:12 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
03:56:12 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
03:56:12 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
03:56:36 <sharat87> hello everyone, I am new to haskell and am loving it :), I have a string like '12 34 56' and I want to split it into a list of numbers, something like `map (stringToInt) (split myString)` and I am missing the stringToInt and the split function, or is there another way of doing this? any help?
03:56:50 <PatrickRobotham> words?
03:56:51 <zygoloid> sharat87: words and read
03:56:52 <Cale> sharat87: map read . words
03:57:09 <Cale> > map read . words $ "12 34 56" :: [Integer]
03:57:10 <lambdabot>   [12,34,56]
03:57:12 <sharat87> ah right, perfecto thanks a lot guys :)
03:57:15 <PatrickRobotham> There we go. Cale solves all our problems. 
03:57:43 <edlinde> zygoloid: what was the answer to finding some sample usage with say elem?
03:57:49 <sharat87> where can I get more detailed documentation on these functions?
03:58:20 <ClaudiusMaximus> @where Prelude
03:58:21 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
03:58:40 <zygoloid> edlinde: i think zvon.org has usage examples for most of the prelude.
03:58:54 <sharat87> ah thanks
03:58:54 <zygoloid> edlinde: http://zvon.org/other/haskell/Outputprelude/elem_f.html
03:59:36 <edlinde> Ah I see
04:01:20 <edlinde> cool thanks
04:01:31 <edlinde> there is quite a lot of documentation online for Hasell
04:02:02 <edlinde> Haskell
04:04:47 <edlinde> do you guys use list comprehensions a lot?
04:04:56 <edlinde> is this just a way to filter the data in a list?
04:05:07 <Taejo> my impression is that most people prefer to use map and filter
04:05:15 <edlinde> ah i see
04:05:27 <edlinde> yeah I come from a ML background
04:05:29 <smorg> It basically combines map and filter but is much more versitile than that
04:05:42 <quicksilver> I mostly use list comps when I want the neat pattern selection effect
04:05:43 <edlinde> so I am more accustomed to map and filter, foldr, foldl etc
04:06:00 <smorg> It seems possible to overuse in Haskell since there are a lot of built in functions which can often replace list comprehensions
04:06:02 <edlinde> so its better than using map?
04:06:22 <quicksilver> > let getLefts xs = [Left a | a <- xs] in [Left 1, Right "hi", Left 2, Right "there"]
04:06:23 <lambdabot>   [Left 1,Right "hi",Left 2,Right "there"]
04:06:31 <quicksilver> > let getLefts xs = [Left a | a <- xs] in getLefts [Left 1, Right "hi", Left 2, Right "there"]
04:06:32 <lambdabot>   [Left (Left 1),Left (Right "hi"),Left (Left 2),Left (Right "there")]
04:06:33 <edlinde> I am looking at the haskell tute. and it looks like a lot of syntax to remember
04:06:34 <edlinde> :)
04:06:37 <quicksilver> edlinde: no, it's not better.
04:06:41 <quicksilver> (!)
04:06:48 <quicksilver> > let getLefts xs = [a | Left a <- xs] in getLefts [Left 1, Right "hi", Left 2, Right "there"]
04:06:49 <lambdabot>   [1,2]
04:06:50 <smorg> edlinde: map is probably better if all you're doing is map
04:06:54 <quicksilver> sorry that took three atempts.
04:07:03 <quicksilver> smorg: list comprehensions can always be replaced.
04:07:07 <quicksilver> they're entirely optional.
04:07:13 <edlinde> yeah it looks like it
04:07:29 <smorg> [f(x) | x <- foo] in itself is pointless
04:07:34 <edlinde> It just takes some getting used to the list comprehension syntax
04:07:57 <edlinde> smorg: what does that do?
04:08:12 <smorg> applies f to x for each member of foo
04:08:21 <smorg> same as map
04:08:25 <edlinde> ok
04:08:32 <edlinde> so foo isn't a function
04:08:41 <edlinde> I thought it was probably a function that returned a list
04:08:42 <edlinde> ?
04:08:48 <edlinde> I suppose it can be ... can't it?
04:08:50 <smorg> foo is everything :)
04:11:07 <Taejo> edlinde: correct, it must be a list
04:11:15 <edlinde> ok cool
04:11:26 <edlinde> I suppose its good to learn something like ML to start off with
04:11:31 <edlinde> and then get to haskell
04:11:43 <edlinde> coz Haskell seems to provide quite a lot of primitives
04:11:46 <smorg> edlinde: haskell doesn't have iterators/generators exactly so it can't be literally a function
04:11:48 <Taejo> I don't know of a good reason to do that
04:12:00 <Taejo> I found ML more confusing when I was trying to learn
04:12:16 <edlinde> Taejo: I thought it was quite straightforward
04:12:19 <Taejo> you can ignore list comprehensions at first if you don't like them
04:12:26 <Taejo> edlinde: so is Haskell :)
04:12:27 <edlinde> yeah I am about to do that :)
04:12:32 * hackagebot splot 0.1.0 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.0 (EugeneKirpichov)
04:12:35 <edlinde> Yeah haskell is cool too
04:16:21 <chrisdone> anyone know how to query at an offset with haskelldb?
04:16:39 <ManateeLazyCat> What's mean of "darcs: Pushing to http URLs is not supported. You may be able to hack this to work using DARCS_APPLY_HTTP" ?
04:16:39 <ManateeLazyCat>  
04:16:40 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
04:17:04 <Entroacceptor> ManateeLazyCat: well, I guess push over http is not supported ;)
04:17:32 <ManateeLazyCat> Entroacceptor: I did something wrong? It always push successful. 
04:18:28 <Entroacceptor> are you sure?
04:18:52 <Entroacceptor> I've given up on darcs because I didn't get it to do a remote push reliably
04:19:25 <ManateeLazyCat> Entroacceptor: Use git?
04:19:29 <Entroacceptor> yes...
04:19:52 <Entroacceptor> http://www.equational.org/darcs-server/documentation.html seems to suggest you need a special darcs-client to push over http
04:20:20 <ManateeLazyCat> Entroacceptor: special darcs-client ?
04:20:26 <Entroacceptor> and the server side has to support it...
04:20:30 <Entroacceptor> where do you want to push to?
04:20:37 <chrisdone> ah, n/m. I can patch it
04:20:40 <ManateeLazyCat> Entroacceptor: patch-tag.com
04:20:51 <ManateeLazyCat> Entroacceptor: Maybe i need upgrade darcs now.
04:21:11 <Entroacceptor> ManateeLazyCat: doesn't that work only with SSH push?
04:21:37 <ManateeLazyCat> Entroacceptor: Before today, always works, don't know why can't push today. :(
04:22:49 <ManateeLazyCat> Entroacceptor: I use darcs just because it's features enough for me. :)
04:22:52 <Entroacceptor> well, it looks like, for some reason, it tries to push to http
04:24:48 <ManateeLazyCat> Entroacceptor: Hmm, looks strange, when i use "darcs push -a" can't work but i use "darcs push AndyStewart@patch-tag.com:/r/AndyStewart/manatee-pdfviewer" instead, works fine.
04:25:43 <Entroacceptor> ManateeLazyCat: you didn't darcs get it again, did you?
04:26:07 <ManateeLazyCat> Entroacceptor: Yes, i darcs get it again. 
04:26:15 <Entroacceptor> maybe try editing _darcs/prefs/defaultrepo
04:26:35 <Entroacceptor> to point to the AndyS...@ stuff 
04:27:11 <Entroacceptor> if you got it again, it wouldn't know how to ssh, would it?
04:27:18 <ManateeLazyCat> Entroacceptor: I think i it's better modified my script ./repos.sh use AndyStewart...@ explicitly. :)
04:27:30 <ManateeLazyCat> Entroacceptor: Looks like that, thanks for help! :)
04:27:44 * ManateeLazyCat pasted "./repos.sh" at http://paste2.org/get/1044813
04:27:49 <ManateeLazyCat> Above is my ./repos.sh 
04:28:16 <Entroacceptor> yeah, I have that, too ,)
04:29:03 <ManateeLazyCat> Entroacceptor: Are you play it ? :)
04:29:14 <ManateeLazyCat> Entroacceptor: I send many patches fix bug recently. :)
04:29:39 <ManateeLazyCat> Hmm, looks great now. :)
04:30:17 <medfly> :t f
04:30:17 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
04:30:21 <ManateeLazyCat> Entroacceptor: I just push new patch make "Pdf viewer" can view documentation with smooth scroll. :)
04:31:35 <ski> > 2 * f (x + 1) :: Expr
04:31:36 <lambdabot>   2 * f (x + 1)
04:31:52 <Entroacceptor> ManateeLazyCat: I'll try it again 
04:32:18 <Maxdamantus> > join ((*) :: Expr) 4
04:32:19 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:32:20 <lambdabot>         against inferred ...
04:32:30 <Maxdamantus> > ((*) :: Expr) 4 4
04:32:31 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:32:31 <lambdabot>         against inferred ...
04:32:32 <Maxdamantus> er
04:32:34 <ManateeLazyCat> Entroacceptor: I recommend you press F3 (RSS/Atom reader) when start it.
04:32:50 <Maxdamantus> > join ((*) :: Expr -> Expr -> Expr) 4
04:32:51 <lambdabot>   4 * 4
04:33:40 <ManateeLazyCat> Entroacceptor: F2 : process manager, F3 : RSS/Atom reader, F4 : file manager. F5 : webkit browser. F6 : login #haskell 
04:33:53 <Maxdamantus> > (join (*) :: Expr -> Expr -> Expr -> Expr) 3
04:33:53 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
04:33:54 <lambdabot>                           ...
04:34:16 <Maxdamantus> > let a = (4 * a :: Expr) in a
04:34:17 <lambdabot>   4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (...
04:34:28 <medfly> if I have something of type [IO ()] how do I... uh, do each thing?
04:34:38 <sipa> @t sequence
04:34:39 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
04:34:41 <sipa> :t sequence
04:34:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:34:43 <Maxdamantus> > fix ((4*) :: Expr -> Expr)
04:34:44 <lambdabot>   4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (4 * (...
04:34:50 <medfly> hmm...
04:34:53 <medfly> it's still weird-ish
04:34:57 <ManateeLazyCat> medfly: forM [IO()] id
04:35:05 <medfly> :t forM
04:35:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
04:35:17 <sipa> or
04:35:20 <ski> medfly : if you did `map foo xs' to get something of type `[IO ()]', try using `mapM_ foo xs' instead
04:35:20 <sipa> :t sequence_
04:35:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
04:35:25 <ManateeLazyCat> > forM [putStrLn "hello", putStrLn "andy"] id
04:35:26 <lambdabot>   <IO [()]>
04:35:27 <Maxdamantus> > ap (+) (4*) 5 :: Expr
04:35:28 <lambdabot>   5 + 4 * 5
04:35:30 <medfly> scary
04:35:32 <medfly> :t mapM_
04:35:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:35:37 <medfly> TOO MANY CHOICES!1
04:35:42 <medfly> yes, I did do map.
04:35:48 <medfly> wait, no, I did zipWith.
04:35:48 <sipa> medfly: if you just want to run it all, sequence_
04:35:49 <medfly> :-D
04:36:02 <Maxdamantus> > sum [1..] :: Expr
04:36:03 <medfly> thank you
04:36:05 <lambdabot>   mueval-core: Time limit exceeded
04:36:23 <medfly> > map f [1..] :: Expr
04:36:25 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:36:25 <lambdabot>         against inferred ...
04:36:36 <ski> medfly : `mapM' is for executing (in order) an action on each element of a list. `mapM_' is for when you only care about the effects, not the return values
04:36:38 <medfly> > map f [1..] :: [Expr]
04:36:40 <lambdabot>   [f 1,f 2,f 3,f 4,f 5,f 6,f 7,f 8,f 9,f 10,f 11,f 12,f 13,f 14,f 15,f 16,f 1...
04:37:05 <Maxdamantus> > fix (f.)
04:37:06 <lambdabot>   No instance for (GHC.Show.Show (f b))
04:37:06 <lambdabot>    arising from a use of `M5550636528...
04:37:07 <ski> medfly : generally, `sequence' runs the actions in a list (in order), while `sequence_' also does that, but does not collect the results
04:37:10 <Maxdamantus> > fix (f .)
04:37:11 <lambdabot>   No instance for (GHC.Show.Show (f b))
04:37:11 <lambdabot>    arising from a use of `M3155115912...
04:37:14 <Maxdamantus> > fix (f .) :: Expr
04:37:15 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:37:15 <lambdabot>         against inferred ...
04:37:36 <ski> medfly : so `mapM f xs = sequence (map f xs)' and `mapM_ f xs = sequence_ (map f xs)'
04:37:37 <Maxdamantus> > fix (f .) $ 5 :: Expr
04:37:39 <ManateeLazyCat> medfly: forM_ [putStrLn "hello", putStrLn "andy"] id can work
04:37:40 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
04:37:47 <medfly> scary.
04:37:48 <medfly> okay, thanks
04:37:52 <ManateeLazyCat> medfly: Just replace with your [IO()]
04:38:35 <ski> medfly : `forM' and `forM_' are just `mapM' and `mapM_' with the argument order flipped .. sometimes this is nicer, to make your code look more like "imperative loops" (especially nested loops)
04:39:14 <medfly> thanks
04:39:17 <ManateeLazyCat> ski: Yes, i use forM_ always, less bracket.
04:39:41 <ski>   forM [0 .. 9] $ \y ->
04:39:48 <ManateeLazyCat> medfly: You can write like this "forM_ list $ \element -> do", less indent.
04:39:50 <ski>     forM [0 .. y] $ \x -> do
04:40:00 <ski>       .. do something with `x' and `y' ..
04:40:03 <ski> e.g.
04:40:25 <Maxdamantus> > fix f
04:40:27 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:40:27 <lambdabot>    `GHC.Show.Show a'
04:40:27 <lambdabot>      a...
04:40:34 <Maxdamantus> > fix f :: Expr
04:40:34 <ski> (though i suppose "usually" `forM_' would be more appropriate there)
04:40:34 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
04:41:24 <ski> medfly : anyway, that last example is the same as `mapM (\y -> mapM (\x -> do .. do something with `x' and `y' ..) [0 .. y]) [0 .. 9]'
04:41:45 <Maxdamantus> > scanl (*) 1 [1..] :: [Expr]
04:41:46 <lambdabot>   [1,1 * 1,1 * 1 * 2,1 * 1 * 2 * 3,1 * 1 * 2 * 3 * 4,1 * 1 * 2 * 3 * 4 * 5,1 ...
04:41:57 <ManateeLazyCat> Entroacceptor: If you install festival in your box, move your cursor to IRC message, and press C-K, my irc client will read message for you. :)
04:42:00 <Maxdamantus> This Expr stuff's actually pretty fun.
04:42:19 <Maxdamantus> > fix $ scanl (+) 1 [1..] :: [Expr]
04:42:20 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
04:42:32 <Maxdamantus> > fix $ (1:) . scanl (+) 1 [1..] :: [Expr]
04:42:33 <lambdabot>   Couldn't match expected type `[t] -> [t]'
04:42:33 <lambdabot>         against inferred type `[a]'
04:42:36 <Entroacceptor> ManateeLazyCat: lol
04:43:37 <ManateeLazyCat> Entroacceptor: Irc client is most complete sub-module in my project now. :)
04:44:05 <Maxdamantus> > fix $ (1:) . scanl (+) 1 :: [Expr]
04:44:06 <lambdabot>   [1,1,1 + 1,1 + 1 + 1,1 + 1 + 1 + (1 + 1),1 + 1 + 1 + (1 + 1) + (1 + 1 + 1),...
04:45:15 <Maxdamantus> > filter (/= ' ') . show . drop 10 $ (fix $ (1:) . scanl (+) 1 :: [Expr])
04:45:16 <lambdabot>   "[1+1+1+(1+1)+(1+1+1)+(1+1+1+(1+1))+(1+1+1+(1+1)+(1+1+1))+(1+1+1+(1+1)+(1+1...
04:45:20 <ManateeLazyCat> Entroacceptor: You can start manatee, and type "irc:[//[user@][server[:port]][/]][#channel]" to login any channel. Support multiple server default. :)
04:45:39 <azaq231> > (log $ 2005^2004+2^2006) / (log 10)
04:45:40 <lambdabot>   Infinity
04:45:55 <ManateeLazyCat> Entroacceptor: Something like "irc://Entroacceptor@irc.freenode.net:6667/#emacs" will login #emacs.
04:46:01 <Maxdamantus> > logBase 10 $ 2005^2004+2^2006
04:46:02 <lambdabot>   Infinity
04:46:08 <gju> hi. i'm using haskell-mode in emacs to edit my haskell files but somehow the indention doesn't seem to work. is there an option i need to turn on to make it work?
04:46:11 <ManateeLazyCat> Entroacceptor: "irc://" default for login #haskell. :)
04:46:53 <ManateeLazyCat> Entroacceptor: Of course, you can type url to browse. :)
04:47:16 <ManateeLazyCat> Entroacceptor: Commander is smart adjust result for your input. :)
04:47:46 <benmachine> > logBase 10 2005
04:47:47 <lambdabot>   3.302114376956201
04:48:35 <benmachine> > logBase 10 2005 * 2004
04:48:36 <lambdabot>   6617.437211420227
04:49:06 <benmachine> ^ is probably a pretty good approximation
04:49:30 <benmachine> (2^2006 ~ 10^700, so pretty small by comparison)
04:51:34 <cathper> Has anyone been using dtrace on non-macosx (say, ubuntu)? http://hackage.haskell.org/trac/ghc/wiki/DTrace
04:53:20 <azaq231> Wouldn't a behaviour different from giving back "Infinity" be saner?
04:53:23 <Unforgivable^> Is there any way to replace double spaces and tabs and other whitespace characters to just a single space?
04:53:29 <Unforgivable^> with a default function?
04:54:04 <ManateeL`> Unforgivable^: Regexp replace.
04:54:23 <Unforgivable^> i don't really understand regexp :(
04:54:54 <quicksilver> no need to use regexps for that
04:54:59 <quicksilver> or, in fact, for anything, ever.
04:55:08 <benmachine> now you have two problems etc.
04:55:14 <quicksilver> but it's true that the standard lib lacks a replace function.
04:55:46 <Unforgivable^> hm
04:55:56 <magicman> > unlines . map (unwords . words) . lines $ "    Hello,\tworld!\n \nHow are  you?" -- Watch out, not pretty.
04:55:57 <lambdabot>   "Hello, world!\n\nHow are you?\n"
04:56:24 <smorg> What if I need to specify my regular language?
04:56:27 <magicman> A replace function is indeed way better <_<
04:56:47 <ManateeL`> magicman: Your solution not efficient. :)
04:56:57 <benmachine> :t let mergeSpaces s = case break isSpace s of (notSpace, rest) -> notSpace ++ ' ' : mergeSpaces (dropWhile isSpace s)
04:56:58 <lambdabot> <no location info>:
04:56:58 <lambdabot>     not an expression: `let mergeSpaces s = case break isSpace s of (notSpace, rest) -> notSpace ++ ' ' : mergeSpaces (dropWhile isSpace s)'
04:57:00 <benmachine> er
04:57:03 <benmachine> :t let mergeSpaces s = case break isSpace s of (notSpace, rest) -> notSpace ++ ' ' : mergeSpaces (dropWhile isSpace s) in mergeSpaces
04:57:04 <lambdabot> [Char] -> [Char]
04:57:05 <Unforgivable^> yeah but like a string as this: "two three <tab here> four"
04:57:06 <Entroacceptor> ManateeL`: still need gtk2h-darcs?
04:57:12 <ManateeL`> Entroacceptor: yes.
04:57:15 <Unforgivable^> hm irc replaces the spaces already
04:57:36 <ManateeL`> Entroacceptor: Now, we still have one patch haven't apply
04:57:37 <Unforgivable^> but lets say "two__three___four____five<tab here>"
04:57:38 <benmachine> > let mergeSpaces s = case break isSpace s of (notSpace, rest) -> notSpace ++ ' ' : mergeSpaces (dropWhile isSpace s) in mergeSpaces "Hello,\tworld, \t \t    \t I am \n\n\t\n\v  merging some spaces."
04:57:40 <lambdabot>   "Hello, Hello, Hello, Hello, Hello, Hello, Hello, Hello, Hello, Hello, Hell...
04:57:42 <benmachine> um
04:57:43 <benmachine> oops
04:57:44 <Unforgivable^> and I wnat "two three four five"
04:57:44 <ManateeL`> Entroacceptor: After then, we can release gtk2hs-0.12.0
04:57:54 <ManateeL`> Entroacceptor: John has working on it. 
04:57:55 <benmachine> > let mergeSpaces s = case break isSpace s of (notSpace, rest) -> notSpace ++ ' ' : mergeSpaces (dropWhile isSpace rest) in mergeSpaces "Hello,\tworld, \t \t    \t I am \n\n\t\n\v  merging some spaces."
04:57:56 <lambdabot>   "Hello, world, I am merging some spaces.                                   ...
04:58:02 <benmachine> 'sbetter
04:58:21 <benmachine> > let mergeSpaces s = case break isSpace s of (notSpace, "") -> notSpace; (notSpace, rest) -> notSpace ++ ' ' : mergeSpaces (dropWhile isSpace rest) in mergeSpaces "Hello,\tworld, \t \t    \t I am \n\n\t\n\v  merging some spaces."
04:58:23 <lambdabot>   "Hello, world, I am merging some spaces."
04:58:27 <ManateeL`> Entroacceptor: But no worried gtk2hs-darcs, let me if you have any problem, i can fix it. :)
04:58:36 <ManateeL`> s/me/me know
04:59:02 <Unforgivable^> i see benmachine
04:59:05 <Unforgivable^> ill check :)
04:59:19 <benmachine> Unforgivable^: break is a nice function for doing this sort of thing, I think
04:59:42 <Unforgivable^> i didnt know that function
04:59:47 <Unforgivable^> ill first check what it does :)
05:00:06 <benmachine> it's the opposite of span, if you've ever used span
05:00:36 <Unforgivable^> no havent used span as well
05:00:41 <Unforgivable^> but I understand what it does
05:00:45 <Unforgivable^> so no problem :)
05:00:45 <benmachine> span p xs = (takeWhile p xs, dropWhile p xs)
05:01:03 <benmachine> break p xs = span (not . p) xs
05:01:27 <ski> gju : what do you mean by "doesn't seem to work" ?
05:01:38 <Unforgivable^> aha benmachine
05:01:38 <Unforgivable^> :)
05:03:18 <ski> gju : if you have some code which you're not sure why it is not working, you could paste it so that we could get a look at it ..
05:05:39 <ManateeL`> Bye all. :)
05:05:59 <gju> no. i thought mod-haskell would indent = signs so that there are all aligned in the same column.
05:06:11 <ski> ok
05:06:17 <gju> also things like C-c C-= don't work.
05:06:37 <ski> sadly it doesn't do that, so you have to do it manually (if you want it)
05:06:57 <ski> (i suppose there could be some more advanced commands in haskell-mode i've missed ..)
05:07:13 * Maxdamantus dislikes any auto indentation, other than copy indentation
05:07:23 * benmachine dislikes all auto indentation
05:07:28 <benmachine> what's copy indentation?
05:07:41 <Maxdamantus> Where spacing is copied from the previous line to the new one.
05:07:47 <benmachine> ok I don't dislike autoindentation in principle but I generally find it simpler to do my own
05:18:35 <quicksilver> haskell mode used to automatically align = signs with a special command
05:18:40 <quicksilver> but that got lost with the other new stuff
05:18:54 <quicksilver> the other new stuff is worth it, though, and all emacs users should know 'align-regexp'
05:19:02 <Jafet> Well, is there an indent for haskell?
05:20:19 <quicksilver> haskell-mode lets you choose between the possibly multiple valid indentations for the current line.
05:22:01 <Jafet> If programming languages allowed no possible variation in formatting, why we could allocate more of our resources to combat world hunger
05:23:08 <Maxdamantus> Like Malbolge?
05:24:04 * ski recalls assemblers which didn't allow variations in spacing
05:25:31 <alvivi> Does anybody know what means "default(Int)" at the beginning of a module?
05:26:36 <dmwit_> http://www.haskell.org/onlinereport/decls.html#overloading
05:26:46 <ski> that any ambiguities in class resolving should try resolving the ambiguity by trying `Int'
05:27:24 <dmwit_> Whoops, wrong section.
05:28:08 <dmwit_> Anyway, 4.3.4 discusses it.
05:28:33 <alvivi> Its the first time that I see it :P Thanks
05:29:11 <ski> it is not commonly used
05:36:36 <Entroacceptor> ManateeL`: http://pastie.org/1232497
05:36:56 <Entroacceptor> oh, he's gone, anyone else can help me with that dependency problem?
05:46:29 <dmwit> Entroacceptor: Uh, can you just change tagsoup's cabal file to be less demanding?
05:47:19 <quicksilver> RIP mandelbrot...
05:47:21 <dmwit> I mean, does it compile if you use QuickCheck == 2.3.* instead?
05:47:35 <dmwit> quicksilver: yeah, it's always sad to hear about these things
05:48:37 <medfly> quicksilver: I always find out that certain mathematicians were alive until recently by hearing about them dying
05:49:09 <gju> like mandelbrot?
05:49:14 <medfly> apparently.
05:51:52 <Guest11055> same thing for me
05:54:17 <PatrickB> hi guys, I've got a little question about my homework
05:54:46 <PatrickB> we are trying to solve a "particular silly instance of a river game" (as my teacher describes it), and we got the advice to use MultiSet
05:55:00 <PatrickB> the only problem is that we have no idea how to use MultiSet in a data definition
05:55:25 <ray> omg patrick
05:55:44 <ski> `MultiSet' is already defined ?
05:55:46 <PatrickB> we are currently using "data River = River {farPeople :: [Person], nearPeople :: [Person], raft :: Side} deriving (Eq)", so we want to substitute the [Person] with a MultiSet containing persons
05:56:11 <PatrickB> we did already do a import Data.MultiSet, so MultiSet is indeed already defined
05:56:17 <ski> `[Person]' (also written as `[] Person') is the type of lists of things of type `Person'
05:56:18 <PatrickB> but we want to use a MultiSet in our own data type
05:56:32 <ski> `MultiSet Person' is the type of multi-sets of things of type `Person'
05:56:56 <ski> (assuming `MultiSet' is a one-parameter type function)
05:58:04 <PatrickB> could you please give a working example? It keeps saying here that the data constructor MultiSet is not defined :(
05:58:07 <ray> what is this, sets with quantities?
05:58:29 <ski> PatrickB : ok, i assumed `MultiSet' was defined, here
05:58:44 <ski> (i asked about it, but you didn't answer)
05:58:57 <PatrickB> MultiSet is imported, but I didn't define anything yet @ski
05:59:14 <ski> is `MultiSet' a module, or a type (constructor), or both ?
05:59:23 <ski> s/@ski/, ski/
05:59:37 <PatrickB> as far as I can see in the documentation it should be both: http://hackage.haskell.org/packages/archive/multiset/0.2.1/doc/html/Data-MultiSet.html#t:MultiSet
06:00:02 <ski> ok
06:00:24 <PatrickB> ray: the meaning we are using multiset is because of some persons there are 2, so it is indeed used to keep track of the quantity of the persons
06:00:35 <ski> so, what exactly did you try, to get `the data constructor MultiSet is not defined' ?
06:01:31 <ski> @where paste
06:01:32 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
06:01:57 <Entroacceptor> dmwit: maybe, but why doesn't he have that problem...
06:02:01 <PatrickB> i dumped the interpreter session at http://metadirc.nl/MetaBin/show/842
06:02:34 <PatrickB> so essentially, it is saying "Not in scope: data constructor `MultiSet'"
06:02:54 <ski> PatrickB : `x = MultiSet Char' is not a valid (value) definition
06:03:23 <ski> try using `MultiSet' in the `data' definition, as you said you wanted to do, initially
06:03:40 <PatrickB> so data Something = MultiSet Char?
06:04:07 <ski> in `x = ...', it expects `...' to be a (value) expression, while `MultiSet' and `Char are types ..
06:04:32 <ski> (so, it tried to interpret `MultiSet' and `Char' as values, and found that there is no such values defined)
06:04:45 <PatrickB> alright...
06:05:00 <ManateeLazyCat> Has anyone working on binding libspectre? ask for avoid duplicate work. :)
06:05:02 <ski> PatrickB : well, more like changing your original definition of `River', as i suggested by
06:05:04 <PatrickB> well, I tried it in a fairly simple data definition and it seems to work (the data Something I mentioned)
06:05:15 <PatrickB> so now I'm going to try River
06:05:15 <ski> <ski> `[Person]' (also written as `[] Person') is the type of lists of things of type `Person'
06:05:18 <ski> <ski> `MultiSet Person' is the type of multi-sets of things of type `Person'
06:05:57 <ski> (if you tried exatly `data Something = MultiSet Char', then that doesn't mean what you probably thinks it means)
06:06:31 <PatrickB> alright, so I tried it directly assuming this would create a MultiSet of Char's, that's not gonna work?
06:07:07 <PatrickB> I modified the river like this: http://metadirc.nl/MetaBin/show/843
06:07:20 <PatrickB> and the type seems ok to me (River :: MultiSet Person -> MultiSet Person -> Side -> River)
06:07:45 <Entroacceptor> ManateeLazyCat: http://pastie.org/1232497
06:07:50 <Entroacceptor> did you have that?
06:08:27 <ski> PatrickB : yes, that looks good
06:08:32 <ManateeLazyCat> Entroacceptor: I can't access pastie.org
06:08:39 <ski> (btw, "deriving (Eq)" could be written as "deriving Eq")
06:09:03 <PatrickB> thanks ski!
06:09:18 <Entroacceptor> oh
06:09:22 <PatrickB> and the deriving (Eq) was suggested by someone else, I had no idea how to use that for about a day ago :)
06:09:28 <PatrickB> I'm gonna change that to
06:09:29 <Entroacceptor> cabal: cannot configure tagsoup-0.8. It requires QuickCheck ==2.1.*
06:09:36 <Entroacceptor> but other stuff requires 2.3
06:10:08 <ski> PatrickB : my point was just that the format for a `data' definition is (simplifying a little), `data TypeName = DataConstructorName_0 ArgumentTypeExpression_0,0 ... | ...'
06:10:37 <PatrickB> I should have known that... :)
06:11:31 <ManateeLazyCat> Entroacceptor: Got it (in GFW filter list).
06:11:36 <ski> PatrickB : here `TypeName' is a single name of a type (the one being defined), while `ArgumentTypeExpression_i,j' are type expressions .. but `DataConstructorName_i' is a single name of a *value* (not a type), which will be the data constructor(s) of the type
06:12:27 <ski> PatrickB : so if you write `data Something = MultiSet Char', then `Something' in there is a type, and `Char' is of course a type, but `MultiSet' is interpreted as a value, more specifically a data constructor for `Something' : `MultiSet :: Char -> Something'
06:12:52 <PatrickB> ah
06:12:59 <ManateeLazyCat> Entroacceptor: Hmm, looks cabal conflict...
06:13:13 <PatrickB> well, I got MultiSet to load and it appears to be working fine, now to get all the functions to work with multiset :D
06:13:20 <ski> PatrickB : it is possible to use the same name for a data constructor (which is a value) and for a type constructor (like `Char',`MultiSet',`Something'), since "they live in different namespaces"
06:13:26 <ManateeLazyCat> Entroacceptor: I use QuickCheck-2.3.0.2 no problem.
06:13:54 <PatrickB> My current River.hs is this: http://metadirc.nl/MetaBin/show/844 which seems to load and work just fine
06:13:56 <Entroacceptor> ManateeLazyCat: so your tagsoup doesn't depend on QC-2.1?
06:14:01 <ski> PatrickB : i.e., in each circumstance, either a type, or a value (or neither) is expected, never both, so there is no ambiguity
06:14:20 <ManateeLazyCat> Entroacceptor: Infact, manatee-core not use tagsoup directly.
06:14:41 <ski> PatrickB : nevertheless, it can be confusing to reuse the name of a type constructor as the name of a data constructor (or vice versa) (especially for beginners)
06:15:19 <PatrickB> the teacher said to use it this way to make sure we wouldn't mix up :P
06:15:28 <ski> PatrickB : the only time it is common to do this is when you have a type which will have only one data constructor, and you can't think of any better name .. like `data Person = Person Name Age'
06:15:34 <ManateeLazyCat> Entroacceptor: There is no tagsoup code in manatee-core
06:15:58 <ManateeLazyCat> Entroacceptor: I think you can upgrade your QuickCheck, maybe help. :)
06:16:11 <quicksilver> ski: if you're used to it as a universal convention it then becomes confusing when you *don't* ;) But I agree with you of course.
06:16:28 <ski> quicksilver : "it" being ?
06:16:53 <quicksilver> ski: type name == constructor name.
06:17:40 <Entroacceptor> ManateeLazyCat: I already have qc-2.3 installed ^^
06:17:47 * ski generally prefers `MkFoo' to `Foo', for data constructors of a type `Foo', when no better name suggests itself
06:18:00 * quicksilver generally agrees.
06:18:08 <PatrickB> nice... now it is giving errors in my show function :( >> http://metadirc.nl/MetaBin/show/845
06:18:10 <ManateeLazyCat> Entroacceptor: ghc-pkg check?
06:18:25 <ski> (e.g. as in `data CoYoneda f b = forall a. FmapIncl (a -> b) (f b)' ..)
06:18:32 <Entroacceptor> lots of troubles in manatee stuff..
06:18:34 <PatrickB> I can understand that "MultiSet Person" is not quite valid in a type definition, but how am I going to use this then?
06:18:35 <Entroacceptor> maybe I should remove that
06:19:00 <Entroacceptor> now I want a cabal remove!
06:19:16 * ski also generally prefers using `=' to `==', for semantic equality :)
06:19:16 <ManateeLazyCat> Entroacceptor: I have clean cabal.
06:19:32 <ManateeLazyCat> Entroacceptor: I think problem is tagsoup that need QuickChec==2.1
06:20:24 <ski> PatrickB : `MultiSet Person' *is* valid in a type signature as well as in a type definition (`type',`newtype',`data')
06:20:25 <ManateeLazyCat> Entroacceptor: I have check, you can upgrade newest tagsoup, then won't conflict
06:20:54 <ddarius> (x^) is a monoid homomorphism from the naturals under addition to any monoid.
06:20:56 <PatrickB> alright, but then I have absolutely no clue how to make this work :(
06:22:00 <ski> PatrickB : .. maybe you could paste the error message, as well ?
06:22:23 <PatrickB> ah, right ;)
06:23:26 <PatrickB> the error message is this: http://metadirc.nl/MetaBin/show/846
06:23:36 <ManateeLazyCat> Entroacceptor: Well, since manatee do many work, it's cabal depend monster sometimes. :)
06:24:15 <PatrickB> the problem at River.hs:11:36 is something I'm doing stupid (most likely) but the one at River.hs:18:10 is a mistery to me
06:25:00 <ski> the first error is because you have `""' and the end of line 11, and then no `++' on the next line
06:25:06 <ski> just remove the `""', probably
06:25:21 <PatrickB> ah, that was a bit of problem fixing I had earlier :)
06:25:24 <PatrickB> removed that, thanks
06:25:56 <PatrickB> then the other error remains: http://metadirc.nl/MetaBin/show/847
06:26:07 <ski> the second error is because a list is not a multi-set : you can't match a multi-set on `p:ps', since that is always a list
06:26:18 <PatrickB> which apparently is because of the fact that I treat it like a list :)
06:26:29 <PatrickB> damn... I should learn to read error messages...
06:26:38 <ski> so, either use some operations on multi-sets instead of this matching .. or maybe you can convert to a list, and match on that list ?
06:27:38 <ski>   toList :: MultiSet a -> [a]
06:27:45 <ski>   toAscList :: MultiSet a -> [a]
06:27:51 <ski> those two looks relevant
06:28:00 <PatrickB> I think the toList option is the way to go
06:28:06 <PatrickB> let me just try that...
06:28:11 <ClaudiusMaximus> :-o my executable is 24MB, and it's hardly fancy...
06:28:43 <ski> PatrickB : probably you want `toAscList', i think ..
06:29:02 <quicksilver> converting everything to multisets and then using list operations seems a bit ass-backwards?
06:29:12 <quicksilver> once you've converted ot multisets don't you hope for multiset operations?
06:29:22 <ski> (btw, that should really be `toAscList :: Ord a => MultiSet a -> [a]')
06:29:25 <PatrickB> it is just a simple show function, so here it doesn't really matter all that much imo
06:29:30 <quicksilver> ah, OK.
06:29:39 <quicksilver> I should read the paste before alleging inverted donkeys.
06:30:00 <ski> quicksilver : also, if you want to get consistent `show', then i think you need to sort, anyway
06:30:18 <quicksilver> yes.
06:30:30 <quicksilver> I wonder if it is required that show be consistent?
06:30:31 <ski> ("inverted donkeys" .. is that like some kind of inversion of anaphora ?)
06:30:35 <benmachine> consistent as in, xs == ys => show xs == show ys?
06:30:42 <quicksilver> ski: "ass-backwards" = you have your donkey inverted.
06:30:50 <ski> benmachine : yes
06:31:02 <quicksilver> benmachine: yes.
06:31:09 <quicksilver> FSOV ==.
06:31:25 <ski> imo, `forall a0 a1.  a0 == a1 = True  =>  a0 = a1' is an axiom/law of `Eq'
06:31:39 <PatrickB> it isn't specified in the assignment that it should be ordered, so I don't really care all that much
06:31:53 <PatrickB> but toAscList is nicer and makes it easier to find a specific person
06:32:21 <benmachine> ski: you think == should be intensional? (if I'm using that word correctly)
06:32:32 <ski> PatrickB : hm .. btw, it occurs to me that using `show' at all for this is (imho) a misuse of `show'/`Show'
06:32:36 <identity> In RWH, in one of his examples, he writes a module called ApplicativeParsec, where he makes GenParser s a an instance of Applicative. I'm now trying to compile some of my code that uses it and it's giving me an error about the instances. First I had to use the TypeSynonymInstances pragma and then it talked about duplicate instances. Is it already an instance?
06:32:47 <benmachine> quicksilver: the docs of Text.Show seem to suggest no laws whatsoever
06:32:47 <ddarius> benmachine: That's not necessary.
06:33:10 <PatrickB> why is this a misuse of show then? it is actually used to show the contents to the user
06:33:29 <benmachine> therefore there are no misuses of show :P
06:33:43 <ddarius> (Well, unless you start requiring observational equality in the face of abstraction violating things, in which case no Eq instance is correct.)
06:33:52 <ski> PatrickB : many people argue that the point of `show' is to generate a string which is a valid haskell expression, which will evaluate to the original value
06:34:12 <quicksilver> benmachine: on the contrary. Show has laws, it's just they're not written down.
06:34:23 <quicksilver> benmachine: generally speaking, the law is defined by the loudest speaker in #haskell.
06:34:27 <benmachine> :P
06:34:34 <benmachine> the law tends to be non-constant in that case
06:34:37 <quicksilver> it's our beneficient loquacracy
06:34:38 <PatrickB> ski, acceptable and understandable, but in this case it is a right use for me :)
06:34:43 <PatrickB> thanks for all the help!
06:34:43 <EvanR-work> SHOW IS FOR MAKING BACON AND EGGS FOR BREAKFAST
06:34:45 <ski> PatrickB : so, if you want to follow this, then you should just make some other function (call it `displayPersons' or whatever you like), instead of making an instance of `Show', defining `show'
06:35:00 * benmachine devises some elaborate template-haskell to ask the channel what the "in thing" is at compile time
06:35:23 <benmachine> ddarius: did you mean, intensionality is not necessary for Eq, or not necessary for ski's suggested law?
06:35:37 <PatrickB> ski, it is specified that the show function is to be used to pretty print the contents of the River
06:35:38 <ddarius> benmachine: Both statements are true.
06:35:57 <PatrickB> if you want to see for yourself, the assignment is here: http://www.cs.uu.nl/wiki/pub/FP/PracticalExercises/river.pdf
06:35:57 <ski> PatrickB : in your assignment specification ?
06:36:15 <dmead> ?seen byorgey
06:36:15 <lambdabot> Unknown command, try @list
06:36:17 <PatrickB> yes
06:36:22 <byorgey> hi dmead 
06:36:22 <dmead> @list
06:36:23 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:36:25 <dmead> hey brent
06:36:36 <benmachine> ddarius: hmm, I think I had the wrong idea of what intensionality is (hence the parenthised comment)
06:36:56 <ski> PatrickB : ok, so you would probably not get away with not defining this pretty-printing operation under the name `show', then ;)
06:36:59 <dmead> byorgey, i was going to ask to pick your brain about ghc if you have the time
06:37:39 <byorgey> dmead: sure, although I still don't really know all that much.
06:37:42 <ski> PatrickB : if you want, you could still write a comment that it is considered (or #haskell (mostly) considers it) inappropriate to use `Show' for pretty-printing :)
06:38:18 <dmead> byorgey, well i'm not trying to anything complicated
06:38:33 <byorgey> ok
06:38:36 <dmead> i've been using haskell-src-exts from hackage to get ASTs
06:38:38 <ski> PatrickB : anyway, afaik, there is no real reason for you to name your function `show' here, except for what the specification wants
06:38:53 <dmead> but it really lacks any type information, which i assume ghc can give back
06:38:56 <dmead> but i'm not sure where to look
06:39:16 <benmachine> someone should write a type-checker for an annotated HSE AST
06:39:37 <dmead> i figured you be the one to ask, having done work on types etc etc
06:39:38 <benmachine> by someone I mean it's something I plan to do if I get the time and, knowledge
06:39:38 * ski hopes that with enough people convinced that `Show' is for "valid haskell code", we could at some point later specify that expectation in the documentation of `Show'
06:39:51 <byorgey> dmead: nope, I have no idea =P
06:39:59 <ski> (.. and other code could then depend on it)
06:40:03 <benmachine> ski: seems like it would be faster to do it the other way around >_>
06:40:25 <ski> benmachine : well, maybe .. but there might be loud complaints then
06:40:26 <byorgey> dmead: I guess you should look at the GHC API
06:40:32 <benmachine> but I'm not sure that valid haskell code is that useful except in the presence of hint or whatever
06:40:33 <Entroacceptor> ManateeLazyCat: my cabal seems broken.
06:40:34 <Entroacceptor> again
06:40:34 <byorgey> I've never used it though
06:40:42 <dmead> hmm ok
06:40:43 <sipa> ski: then is there an alternative (some extended Show, which does not have this requirement) for just showing things in a meaningful way?
06:40:54 <benmachine> sipa: just define a function Thing -> String?
06:41:07 <pumpkin> ski: like the Show instance for Random stuff? :P
06:41:13 <ski> benmachine : well, there is some problems wrt which namespace names are to be resolved in ..
06:41:24 <ManateeLazyCat> Entroacceptor: Can you paste the result of "ghc-pkg check" ?
06:41:39 <benmachine> ski: even less useful then :P I'm happy with just show being something that can be readed
06:41:43 <EvanR-work> functions need a Show instance
06:41:59 <Entroacceptor> where?
06:41:59 <ski> sipa : i suppose there could be .. but would there be any use of having an overloaded operation for it ?
06:42:04 <Entroacceptor> wow, it got worse now
06:42:09 <benmachine> read (show x) == x should hold, imo
06:42:28 <dmead> byorgey, i liked your talk from icfp btw
06:42:37 <ski> benmachine : at least if both `Show' and `Read' are instanced, yes
06:42:57 <ski> (but i'd s/==/=/)
06:43:05 <byorgey> dmead: thanks.  You mean the one about my work hacking on GHC?
06:43:14 <dmead> indeed
06:43:17 <ski> (there's also some considerations about infinite data)
06:43:36 <EvanR-work> ski: function instance!
06:43:50 <benmachine> an infinite tree would be tricky
06:44:03 <quicksilver> dmead: haskell-src-exts is a parser only, as far as I am aware
06:44:05 <ski> > read (show [0 ..]) :: [Integer]
06:44:05 <benmachine> you could have something like, read (show x) and x don't disagree
06:44:09 <lambdabot>   mueval-core: Time limit exceeded
06:44:17 <Entroacceptor> ManateeLazyCat: which paste can you access
06:44:18 <Entroacceptor> ?
06:44:21 <ski> the problem there is that parsing is strict
06:44:21 <quicksilver> dmead: I don't think there is any implementation of a haskell type-inferrer except for, well, the various haskell implementations.
06:44:37 <dmead> quicksilver, indeed i was just using that packaged before diving into ghc
06:44:42 <ski> EvanR-work : what about function instances (of `Read' or `Show' ?) ?
06:44:43 <ManateeLazyCat> Entroacceptor: Well, i can access pastie.org by proxy tool 
06:44:55 <EvanR-work> ski: to help with infinite dta
06:44:59 <dmead> quicksilver, obviously to do anything else i'll have to switch to ghc
06:45:03 <quicksilver> dmead: what you can do, is use haskell-src-exts to massage your data into a form that you can then send to ghci
06:45:08 <Entroacceptor> ManateeLazyCat: http://pastie.org/private/57jyfbklsopkkrx1k2a
06:45:12 <benmachine> ski: why would you s/==/=/?
06:45:37 <benmachine> I maintain a package that translates HSE into TH-speak
06:45:38 <quicksilver> dmead: e.g. if you want the type of 'foo' inside some deep expression, you pivot the whole expression into the form "let .... lots of setup expressions ... in foo" and ask ghc for the type.
06:45:42 <ski> EvanR-work : well, it is possible to have `instance (Finite a,Show a,Show b) => Show (a -> b)' ..
06:46:11 <benmachine> ski: hmm, could you show a function with an infinite domain as long as it was enumerable? :P
06:46:19 <dmead> quicksilver, well i really just need any arbitrary program parsed and typechecked
06:46:26 <ski> benmachine : well, i was thinking `x' and `read (show x)' might be equal, but that calling `(==)' on them wouldn't terminate .. but maybe in such cases, the `read' call wouldn't terminate either ?
06:46:37 <ski> benmachine : yes
06:46:43 <dmead> quicksilver, i'm building a translator to go from haskell and s-expressions
06:46:45 <EvanR-work> Finite eh
06:46:52 <ski> (i was just doing `Finite' for simplicity)
06:46:52 <dmead> probably clojure specifically
06:47:01 <dmead> *haskell to s-expressions
06:47:07 <EvanR-work> what is the interface to Finite ;)
06:47:07 <benmachine> ski: oh, yes, hence my refinement to "don't disagree"
06:47:11 <pumpkin> http://www.liskell.org/
06:47:17 <ManateeLazyCat> Entroacceptor: Well, you need install gtk2hs-darcs first (glib, cairo, pango, gio, gtk), then other package can install by Cabal, i have upload them to hackage.
06:47:21 <ski> there's also things like `instance (Compact a,Eq b) => Eq (a -> b)' :)
06:47:34 <EvanR-work> dmead: special form for pattern matching?
06:47:37 <Entroacceptor> ManateeLazyCat: yes, I tried that
06:47:54 <ManateeLazyCat> Entroacceptor: Just two packages need care : install dbus-client-0.3 and newest dbus-core. 
06:47:54 <dmead> pumpkin, i'm aware of that
06:48:13 <Entroacceptor> ManateeLazyCat: just reinstalled gtk2hs, and now I'm getting cannot satisfy -package-id cairo-0.11.1-1aab75dd9734c5870edaf6c9aa77eaa4: 
06:48:21 <benmachine> ski: what does Compact mean in the context of a haskell type? I vaguely recall being told the discrete topology was usual, in which case that would just mean Finite, right?
06:48:30 <dmead> EvanR-work, hmm?
06:48:45 <Entroacceptor> I never got dpkg broken that hard, and I tried!
06:48:58 <EvanR-work> dmead: doesn lisp have no pattern matching form, are you defining one?
06:49:07 <ski> benmachine : `class Compact a where forAll :: (a -> Bool) -> Bool', more or less
06:49:15 <dmead> yes, i have to do a bunch of work on lisp to get special features working
06:49:22 <Entroacceptor> is there a tutorial on how to care for your cabal install so that it doesn't break every two weeks?
06:49:24 <benmachine> ski: ah, I guess that makes sense
06:49:25 <dmead> ie pattern matching, some lazy evaluation
06:49:32 <EvanR-work> ah lazy lisp!
06:49:39 <ski> benmachine : so, `Compact a' means that it is possible to compute a universal quantification over `a', in finite time
06:49:41 <EvanR-work> "it just makes sense" ;)
06:49:47 <ManateeLazyCat> Entroacceptor: dbus-client and dbus-core is all need care.
06:50:05 <ManateeLazyCat> Entroacceptor: Your problem looks you need reinstall manatee again after you install newest gtk2hs.
06:50:18 <Entroacceptor> ManateeLazyCat: I tried
06:51:08 <ski> benmachine : see <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/> and <http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
06:51:14 <ManateeLazyCat> Entroacceptor: How do you install gtk2hs darcs?
06:51:17 <dmead> EvanR-work, is that a thing?
06:51:33 <ManateeLazyCat> Entroacceptor: Download gtk2hs darcs, then do "./bootstrap.sh" is right way.
06:51:38 <Entroacceptor> darcs pull; sh bootstrap.sh
06:51:56 <EvanR-work> dmead: it seems lazy lisp is a marginally popular niche
06:51:59 <Entroacceptor> I updated dbus, and cleaned manatee, let's try again
06:53:18 <AngelaHarms> Greetings
06:53:30 <ski> benmachine : also <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.p(df|(ps|dvi)[.gz])> "Synthetic topology of data types and classical spaces" by Martín Escardó
06:53:37 <AngelaHarms> Anybody want to answer a n00b questions?
06:53:49 <ManateeLazyCat> Entroacceptor: Manatee just can work with dbus-client-0.3 and newest dbus-core
06:53:56 <ski> AngelaHarms : let's hear the question :)
06:54:01 <dmead> i'll take, what is proper grammar for a thousand 
06:54:01 <AngelaHarms> (Or recommend another room for such things?)
06:54:23 <dmead> AngelaHarms, shoot
06:54:28 <ManateeLazyCat> Entroacceptor: Well, if it's still have problem, you can use "ghc-pkg unregister" manatee package to fix your system.
06:54:45 <AngelaHarms> I in the process of  Learn(ing) (me) a Haskell and I fired up the pretty version of ghci.
06:54:50 <ski> AngelaHarms : well, if it's a Haskell question, then you've come to the right place .. if it is about some other programming language, then maybe we can suggest an appropriate channel for you
06:55:13 <EvanR-work> AngelaHarms: which version is that
06:55:17 <Entroacceptor> <command line>: cannot satisfy -package-id cairo-0.11.1-1aab75dd9734c5870edaf6c9aa77eaa4: 
06:55:20 <Entroacceptor>     cairo-0.11.1-1aab75dd9734c5870edaf6c9aa77eaa4 is unusable due to missing or recursive dependencies:
06:55:23 <Entroacceptor>       haskell98-1.0.1.1-ca51ba62fed9074ccb8001cd642eb101
06:55:26 <AngelaHarms> When I mistyped something, the most horrendous beep came out my headphones. Is there a way to fix the settings? I haven't heard such a beep since probably 1987. :P
06:55:26 <Entroacceptor> lol
06:55:31 <dmead> cabal is great
06:55:38 <dmead> and by great, i mean the worst.
06:55:43 <AngelaHarms> Version: just downloaded today. not sure.
06:55:51 <HugoDaniel> :)
06:56:04 <EvanR-work> AngelaHarms: thats haskells bondage and discipline in action, not only can you not make programming mistakes, you cant make typos either
06:56:09 <ski> AngelaHarms : you can possibly disable beeps in your terminal configuration ..
06:56:30 <dmead> AngelaHarms, that isn't haskell
06:56:40 <ski> (maybe one can do it with `stty' as well, but i don't know it)
06:57:03 <AngelaHarms> I've never seen this pretty version of terminal before. Maybe I should just use the green one...
06:57:11 <dmead> clearly it's a feature to jolt the tired programmer wide awake
06:57:38 <AngelaHarms> It was actually painful... that's why I came here instead of trying to find it myself.
06:57:40 <EvanR-work> like those posts on the side of the highway
06:57:50 <AngelaHarms> Thought maybe there was an easy answer.
06:57:57 <EvanR-work> yes, unplug your headphones
06:58:01 <benmachine> <_<
06:58:02 <AngelaHarms> (Sorry it's not an interesting question about FP thinking)
06:58:05 <dmead> or volume
06:58:07 <benmachine> AngelaHarms: is this on windows?
06:58:08 <dmead> def volume.
06:58:12 <AngelaHarms> Yeah, windows.
06:58:18 <ski> AngelaHarms : just typing `ghci' into a shell in any terminal should probably work as well
06:58:24 <ski> oh, windows
06:58:26 <ManateeLazyCat> Entroacceptor: Yep, from your error, cairo broken everywhere.
06:58:45 <AngelaHarms> And the beep was about a zillion decibles (sp?) louder than the music. Grr.
06:58:47 <ski> preflex: xseen ndm
06:58:47 <preflex>  Sorry, I haven't seen ndm
06:58:55 <Martty> decibels
06:59:14 <dmead> AngelaHarms, go in the device manager, find the system beep and disable it
06:59:20 <dmead> at least, thats how do you do it in xp
06:59:21 * ski str ndm was responsible for the WinHaskell(?) thing
06:59:27 <AngelaHarms> YAY I bet you are right, dmead
06:59:31 <ManateeLazyCat> Entroacceptor: Have you did "cabal upgrade" ? Some i doubt you upgrade some package got terrible broken. :)
07:00:09 <sharat87> hello, I have a list of two-tuples of numbers, like [(0,12),(1,100)...] and I want to the get the tuple whose (!! 1) is the max among all the (!! 1) 's, how do I do this?
07:00:34 <dmead> max . snd?
07:00:43 <dmead> > snd (1,2)
07:00:44 <lambdabot>   2
07:00:54 <ManateeLazyCat> Entroacceptor: haskell98-1.0.1.1-ca51ba62fed9074ccb8001cd642eb101 looks a bad package broken everything... 
07:01:06 <dmead> > max . snd [(1,2),(3,4)]
07:01:06 <EvanR-work> :t max . snd
07:01:06 <ski> @type maximumBy
07:01:07 <lambdabot>   Couldn't match expected type `(a, b)' against inferred type `[a1]'
07:01:07 <lambdabot> forall a a1. (Ord a) => (a1, a) -> a -> a
07:01:07 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
07:01:15 <dmead> > max . snd  $ [(1,2),(3,4)]
07:01:16 <lambdabot>   Couldn't match expected type `(a, b)' against inferred type `[a1]'
07:01:18 <sipa> sharat87: !! is list indexing, not tuple indexing
07:01:28 <Entroacceptor> ManateeLazyCat: I just upgraded some packages, yes
07:01:32 <sharat87> sipa: oh ok :)
07:01:35 <ski> > maximumBy (compare `on` snd) [(0,12),(1,100)]
07:01:36 <lambdabot>   (1,100)
07:01:39 <dmead> > map snd [(1,2),(3,4)]
07:01:40 <lambdabot>   [2,4]
07:01:41 <ManateeLazyCat> Entroacceptor: Oh, no.
07:01:43 <ski> sharat87 : ^
07:01:46 <dmead> > max map snd [(1,2),(3,4)]
07:01:47 <lambdabot>   Couldn't match expected type `a -> b'
07:01:47 <lambdabot>         against inferred type `(a1, b...
07:01:50 <Entroacceptor> ManateeLazyCat: AFTER the problems started
07:01:52 <dmead> > maximum map snd [(1,2),(3,4)]
07:01:53 <lambdabot>   Couldn't match expected type `[a]'
07:01:53 <lambdabot>         against inferred type `(a1 -> b)...
07:01:59 <dmead> > maximum $ map snd [(1,2),(3,4)]
07:02:00 <lambdabot>   4
07:02:10 <ski> dmead : `maximumBy', man/woman !
07:02:23 <dmead> > maximum  . snd  $ [(1,2),(3,4)]
07:02:24 <lambdabot>   Couldn't match expected type `(a1, [a])'
07:02:24 <lambdabot>         against inferred type `[a2]'
07:02:29 <sharat87> dmead: yes, but I want the whole tuple
07:02:33 <dmead> ah
07:02:37 <dmead> then what ski said
07:02:38 <ManateeLazyCat> Entroacceptor: I won't use cabal upgrade explicitly, i found it some package (HTTP, directory) will broken all packages in your system.
07:02:45 <ManateeLazyCat> Entroacceptor: Special after you install lots packages.
07:02:48 <dmead> :t maximumBy
07:02:49 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
07:02:53 <dmead> yea that
07:02:59 <dmead> ?src maximumBy
07:02:59 <lambdabot> Source not found. Where did you learn to type?
07:03:03 <dmead> ruh roh
07:03:14 <sharat87> ah great, thanks ski and dmead 
07:03:46 <ManateeLazyCat> Entroacceptor: My suggest is after you build ghc and cabal, don't upgrade any packages, and install gtk2hs-darcs and other package, i promise it will install smooth (I have did it in Ubuntu-10.10)
07:03:46 <dmead> no prob
07:04:37 <ManateeLazyCat> Entroacceptor: From current situation, it's not fault of manatee, is "cabal upgrade".
07:05:31 <Nibble> ManateeLazyCat: has gtk2hs got fixed yet?
07:05:52 <ManateeLazyCat> Nibble: There is last patch in building, John has working on it.
07:06:00 <Nibble>  ok
07:06:02 <Nibble> so soon
07:06:11 <Nibble> ManateeLazyCat: third time I am asking this, but a link to your album :P
07:06:19 <Nibble> I should have a bookmark of it.
07:06:21 <ManateeLazyCat> Nibble: I know you want it, but you know quality is most important. :)
07:06:29 <Nibble> ManateeLazyCat: :P
07:06:42 <ManateeLazyCat> Nibble: I give you short url : http://goo.gl/MkVw   :)
07:06:51 <ManateeLazyCat> Nibble: Easy to remember, auh?
07:07:16 <Nibble> easy enough :)
07:07:29 <Nibble> If I have understood things correctly
07:07:36 <Nibble> manatee is some sort of what?
07:07:41 <Entroacceptor> ManateeLazyCat: I only tried that upgrade after the troubles..
07:07:46 <Nibble> I have seen that the browser and that are extensions to it.
07:07:58 <ManateeLazyCat> Entroacceptor: Well, it's easy to fix if you don't do upgrade.
07:08:03 <AngelaHarms> Here's the answer to disabling the beep in Vista for posterity: http://www.vista4beginners.com/Disable-System-Beep
07:08:19 <AngelaHarms> Thanks for the help. Next time I'll ask a real Haskell question. :) Bye
07:08:29 <ManateeLazyCat> Entroacceptor: But now, it's looks break all package from haskell98 ... and haskell98 is really bad broken.
07:09:46 <ManateeLazyCat> Nibble: You can consider manatee is : Graphic environment like Gnome, efficient work design (keyboard) like Emacs style, and safe like Chrome multi-processes framework. :)
07:10:07 <Nibble> ManateeLazyCat: wut wut, that sounds nice
07:10:15 <ManateeLazyCat> Nibble: Simple is mix gnome/emacs/chrome, but design for do everything...
07:10:25 <ManateeLazyCat> Nibble: Of course, base on extension. 
07:10:44 <ManateeLazyCat> Nibble: Maybe be add : extension install like firefox.
07:10:52 <ski> AngelaHarms : btw, if you want you could stay in this channel and lurk .. often one can learn new things by watching other discussions in here
07:11:43 <Nibble> ManateeLazyCat: dumb  question warning, but what is a TVar
07:11:50 <ski> (AngelaHarms : fyi, it is also possible to use a separate IRC client, pointed to `irc.freenode.net', and `#haskell', instead of using a webchat thing in a browser)
07:12:02 <ManateeLazyCat> Nibble: It's like IORef but use STM design.
07:12:11 <Nibble> STM?
07:12:15 <Nibble> state management?
07:12:24 <ski> @whatis STM
07:12:24 <lambdabot> http://haskell.org/haskellwiki/Software_transactional_memory
07:12:24 <ManateeLazyCat> Nibble: You can use TVar to share state in multi-threads, but no lock like MVar.
07:12:25 <benmachine> software transactional memory
07:12:37 <Nibble> well, I bbiab
07:12:57 <ManateeLazyCat> Nibble: STM is favourites i like haskell.
07:14:15 <AngelaHarms> ski: thanks. It's been a long time since I had an irc client. Should probably get one. :) Is there a haskell beginners channel, or is this the place to be?
07:14:56 <ManateeLazyCat> Entroacceptor: From current situation, i suggest you re-install ghc/cabal, no upgrade, and install gtk2hs-darcs, dbus-client-0.3, other package use newest version.
07:15:03 <ski> AngelaHarms : i would say this is the channel .. there's a mix of advanced and beginner questions, most of the time
07:15:44 <ManateeLazyCat> Entroacceptor: I have reinstall those on Ubuntu-10.10/GHC-6.12.3, no problem.
07:15:45 <blackh> AngelaHarms: This is definitely the right channel for Haskell beginners.
07:16:24 <AngelaHarms> Cool. I'm not sure I'm even a beginner yet. I just downloaded haskell, like, 15 minutes ago. :)
07:16:36 <ski> that's "beginner", sure :)
07:17:57 <ManateeLazyCat> Nibble: Here is framework for manatee : http://www.flickr.com/photos/48809572@N02/5031811365/lightbox/
07:18:30 <blackh> AngelaHarms: Well then... welcome, and I hope you enjoy yourself!
07:25:57 <Nibble> ManateeLazyCat: dude
07:26:00 <Nibble> you have too much spare time
07:26:03 <Nibble> :P
07:26:05 <Nibble> but me like
07:26:18 <ManateeLazyCat> Nibble: Not too much for my aim. :)
07:26:30 <ManateeLazyCat> Nibble: I hope i have 100 hours one day. :)
07:30:05 <EvanR-work> im looking for a monad which can end early and do IO at the same time
07:30:24 <EvanR-work> and reports a message for why it ended early
07:31:04 <EvanR-work> EitherT Message IO a ?
07:31:26 <Nibble> EvanR-work: you do haskell at work?
07:31:39 <EvanR-work> yes
07:31:55 <pumpkin> ContT IO
07:32:02 <ski> EvanR-work : looks ok
07:32:15 <EvanR-work> EitherT exists?
07:32:27 <ski> possibly not with that name
07:32:38 <ddarius> @hoogle ErrorT
07:32:39 <lambdabot> Control.Monad.Error newtype ErrorT e m a
07:32:39 <lambdabot> Control.Monad.Error ErrorT :: m (Either e a) -> ErrorT e m a
07:32:39 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
07:32:50 <identity> EvanR-work: WriterT with MaybeT
07:32:51 <identity> ?
07:32:52 <quicksilver> EvanR-work: ExitT from http://www.haskell.org/haskellwiki/New_monads/MonadExit has that intended use
07:32:53 <identity> or errorT
07:32:56 <sipa> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Error.html ?
07:32:59 <EvanR-work> i made a form validator monad from scratch which could reader a field, writer form errors, and end early, that was very interesting
07:33:05 <ski> the `Monad' instance of `ErrorT' is contaminated with spurious `Error' constraints :/
07:33:12 <EvanR-work> but this is IO now and im scared
07:33:25 <quicksilver> ErrorT is fine if you can work aruond the error constraint
07:33:39 * EvanR-work checks ExitT
07:33:58 <ski> Evan-work : if you want to no `IO'-effects to happen in case of error, then it will not work, though
07:34:23 <quicksilver> you need TardisT for that.
07:34:27 <EvanR-work> no, in this case the only way i know to stop is by using IO (for input)
07:34:47 <ski> @index TardisT
07:34:47 <lambdabot> bzzt
07:35:08 <dmead> bzzzzzzzzzzzzzzzzt
07:35:22 <EvanR-work> so im supposed to copy and pasta this exit monad?
07:36:23 <helge__> anyone know any simple interperters with closures implemented in Haskell? I've no idea how to implement it..
07:36:39 <helge__> like, a toy interperter of sorts
07:36:51 <EvanR-work> mutable closures?
07:36:59 <EvanR-work> spooky
07:37:06 <helge__> yes, mutable
07:37:15 <dmead> why would you want that?
07:37:18 <helge__> atm I can only create a snapshot of the env before the function declaration :)
07:37:34 <helge__> so nfac = function(n) { .. * nfac(n-1) } gives "nfac not found"
07:38:24 <ddarius> helge__: Simply pass in the final environment as the initial environment.
07:38:39 <helge__> ddarius: then what if I call the function from a totally different env?
07:38:46 <helge__> functions are first class
07:38:50 <helge__> or whatever the term is :)
07:39:09 <dmead> first class, giants among men
07:39:24 <helge__> I have thought of one solution, to give every block enviroment a unique name
07:39:28 <helge__> liek a map of envs
07:40:15 <dmead> sounds inefficient
07:43:36 <sajkr> @pl \a b -> compare (fitness a) (fitness b)
07:43:37 <lambdabot> (. fitness) . compare . fitness
07:44:06 <dmwit> comparing fitness
07:44:18 <Entroacceptor> finally it looks like it's compiling
07:44:43 <edlinde> Prelude> factorial n = product [1..n]
07:44:43 <edlinde> <interactive>:1:12: parse error on input `='
07:44:44 <dmwit> :t Data.Ord.comparing
07:44:45 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
07:44:50 <edlinde> I don't get this one
07:45:05 <edlinde> I just copied this from the tutorial onto the ghc prompt and it gave me that error
07:45:06 <dmwit> edlinde: If you're in ghci, you must use "let".
07:45:14 <bderooms> good evening
07:45:30 <edlinde> dmwit: let for a function declaration?
07:45:37 <dmwit> Yes. e.g.
07:45:46 <dmwit> > let factorial n = product [1..n] in factorial 32
07:45:47 <lambdabot>   263130836933693530167218012160000000
07:45:59 <edlinde> hmm
07:46:02 <edlinde> weird
07:46:02 <dmwit> In ghci, you can leave off the "in factorial 32" bit and use it later.
07:46:04 <edlinde> :)
07:46:22 <dmwit> edlinde: It has a perfectly logical explanation, but it is probably best to leave that explanation for a bit later.
07:46:31 <edlinde> ok
07:46:36 <dmwit> edlinde: For now, just follow this rule: use "let" to define things in ghci, but not in a file.
07:46:49 <edlinde> I haven't tried out a file
07:47:14 <edlinde> I have the habit of just writing stuff in a file and then copying pasting my functions onto the interactive prompt
07:47:18 <edlinde> to see if they work
07:47:25 <edlinde> but I suppose that won't work on ghci
07:47:33 <edlinde> as it doesn't let me copy over multiple lines?
07:47:37 <dmwit> No, but you can do ":r" in ghci to reload the file with your new stuff in.
07:47:54 <edlinde> ok
07:48:01 <edlinde> I couldn't do for example --> factorial :: Integer -> Integer 
07:48:07 <dmwit> There is also :{ and :} to do multi-line entry, but again, the exact form you're allowed to use will probably mysterious until you've had a bit of experience with do-blocks.
07:48:13 <edlinde> it didn't like the type definition there by itself
07:48:16 <dmwit> edlinde: Yes, you can do that; e.g.
07:48:25 <dmwit> let factorial :: Integer -> Integer; factorial n = product [1..n]
07:48:41 <edlinde> ok 
07:48:45 <edlinde> thanks
07:50:23 <dmwit> Also possible: :{\nlet factorial :: Integer -> Integer\n    factorial n = product [1..n]\n:}
07:50:30 <dmwit> (note the indentation on the third line)
07:51:23 <dmwit> um
07:51:32 <dmwit> Actually that doesn't seem to be possible, so skip that one. =P
07:57:44 <ClaudiusMaximus> hmm, using {-# SPECIALIZE ... #-} seems to make everything get inlined which makes profiling tricky...
07:57:53 * hackagebot bindings-audiofile 0.1 - Low level bindings to audiofile  http://hackage.haskell.org/package/bindings-audiofile-0.1 (MasatakeDaimon)
07:58:34 <ClaudiusMaximus> should i be worried about "Alloc rate    1,307,620,291 bytes per MUT second" ?  GC time is 2%, which is reasonable
07:59:01 <edlinde> Prelude> :t (==)
07:59:01 <edlinde> (==) :: (Eq a) => a -> a -> Bool
07:59:12 <edlinde> I was wondering what the "Eq" stood for?
07:59:14 <ddarius> ClaudiusMaximus: No.
07:59:22 <edlinde> is this an equality type?
07:59:30 <ClaudiusMaximus> @src Eq
07:59:30 <lambdabot> class  Eq a  where
07:59:30 <lambdabot>     (==), (/=)   :: a -> a -> Bool
07:59:32 <dmead> yes
07:59:40 <edlinde> any type on which == is defined
07:59:49 <edlinde> ok 
08:00:05 <edlinde> can someone give some more examples?
08:00:14 <dmead> of what?
08:00:24 <dmead> types that derive Eq?
08:00:26 <edlinde> equality type functions
08:00:29 <edlinde> yeah
08:00:40 <dstcruz> do :info Eq
08:00:53 <dstcruz> and you'll see what types implement the Eq typeclass
08:01:16 <edlinde> ah cool ok
08:01:18 <dstcruz> then, if you have 2 values of any of those types, you can do a == b, and get True/False
08:01:26 <edlinde> I thought it wouldn't work on string
08:01:35 <pumpkin> any context-free type supports it
08:01:38 <edlinde> but didn't know if it would or not in Haskell
08:02:05 <pumpkin> well, any finite type definitely supports it
08:02:12 <dmead> typically equality functions break down composite types into their primative values for comparison
08:02:14 <pumpkin> a context-free type can partially support it
08:02:18 <dmead> or compare ADTs for structure
08:02:31 <edlinde> okie
08:02:59 <edlinde> I am reading about Typeclasses now 
08:03:10 <edlinde> it says its more like a signature... 
08:03:15 <edlinde> so have a bit to understand 
08:03:16 <edlinde> :)
08:03:17 <dmead> it's just like inferfaces in java
08:03:26 <edlinde> ok
08:03:40 <edlinde> whats the advantage of Type classes?
08:03:51 <edlinde> I heard its supposed to be a neat feature in Haskell
08:04:00 <dmead> it's how haskell supports overloading
08:04:05 <edlinde> unless I am thinking of something else
08:04:22 <edlinde> overloading operators you mean?
08:04:27 <sipa> both
08:04:29 <dmead> overloading in general
08:04:31 <pumpkin> overloading anything
08:04:32 <adimit> mates, what's the difference between mtl and transformers? Is it important which one to choose? I seem to recall you can't use both in the same code.
08:04:35 <pumpkin> even constants
08:04:43 <sipa> edlinde: operators and functions are essentially the same thing in Haskell
08:04:55 <sipa> for example the (+) function is defined in the Num typeclass
08:05:01 <pumpkin> overloading values uniquely determined by a combination of types
08:05:06 <edlinde> hmm but if I just wrote a general function that gave back say the head of a list... this would work for any type yeah?
08:05:08 <pumpkin> where those values can be funtions
08:05:20 <dmead> though overloading constants can give you some weird behaviors
08:05:32 <pumpkin> how so?
08:05:38 <benmachine> > 1 1 2 3 2 1 3
08:05:39 <lambdabot>   Ambiguous type variable `t' in the constraint:
08:05:39 <lambdabot>    `GHC.Num.Num t' arising f...
08:05:43 <benmachine> > 1 1 2 3 2 1 3 :: Integer
08:05:44 <lambdabot>   1
08:05:53 <pumpkin> I don't think that's that weird
08:05:54 <benmachine> I don't know what you mean, that looks perfectly normal to me
08:05:55 * hackagebot bindings-EsounD 0.1 - Low level bindings to EsounD (ESD; Enlightened Sound Daemon)  http://hackage.haskell.org/package/bindings-EsounD-0.1 (MasatakeDaimon)
08:05:56 <edlinde> I mean is there a need for overloading in polymorphic functions?
08:06:03 <sipa> edlinde: it would work on any list, but it requires a type [a] still
08:06:20 <edlinde> a is a polymorphic type yeah?
08:06:28 <dmead> pumpkin, because you can make comparison that are wrong?
08:06:35 <pumpkin> dmead?
08:06:41 <sipa> image you would want a function that gives the head of a list, or the smallest element of a set
08:06:51 <AngelaHarms> Question: Tutorial says doublePair x y = double x + double y should work, but it actually seems to require parentheses. Is it a version difference or something?
08:06:54 <sipa> edlinde: what type are you going to give that function?
08:07:14 <sipa> it can't be [a] -> a
08:07:27 <AngelaHarms> Er, nevermind. I don't know what it was, but now it works without parens. :0/
08:07:27 <edlinde> yeah but ideally you want two seperate functions for that yeah?
08:07:48 <edlinde> I mean is it safe to say that this one function will handle both working on a list and a set?
08:07:53 <edlinde> just wondering
08:07:56 <dmead> pumpkin, it came up on reddit earlier in the year. someone pointed out that you can have weird bindings like 2+2  = 5
08:07:58 <sipa> yes, it's possible
08:08:01 <dmead> or make 1+1 == 3 true
08:08:04 <sipa> but let me think of a better example
08:08:09 <edlinde> ok
08:08:13 <pumpkin> dmead: that's not what I meant, and that isn't overloading constants
08:08:30 <pumpkin> that's shadowing bindings for (+)
08:08:36 <dmead> sure, but still
08:08:46 <sipa> edlinde: what type would a function have that takes any number, and doubles it?
08:09:08 <edlinde> I don't know the types 
08:09:09 <EvanR-work> "cut it in half... and double it"
08:09:12 <bderooms> Num -> Num ? :P
08:09:17 <sipa> bderooms: Num is not a type
08:09:22 <EvanR-work> Num a => a -> a
08:09:26 <edlinde> thats what I thought
08:09:37 <sipa> edlinde: what EvanR-work said
08:09:38 <edlinde> I thought you got Int, Integer, Float 
08:09:44 <Unforgivable^> just reading in :p Num a => a, means that a is of type Num?
08:09:44 <sipa> wel yes
08:09:55 <EvanR-work> Unforgivable^: yes
08:09:56 <pumpkin> Unforgivable^: "is an instance of the typeclass Num"
08:10:02 <sipa> Unforgivable^: no, it means a belongs to the class Num
08:10:18 <sipa> edlinde: you could write doubleIt :: Int -> Int
08:10:18 <edlinde> ok that didn't make sense 
08:10:20 <edlinde> :)
08:10:20 <Unforgivable^> so what is it
08:10:25 <sipa> or you could write doubleIt :: Float -> Float
08:10:26 <Unforgivable^> 3 people have different meaning :p
08:10:27 <edlinde> I will read up about it a bit more maybe
08:10:30 <edlinde> yeah
08:10:31 <sipa> but you can't have both
08:10:32 <edlinde> :)
08:10:43 <Unforgivable^> isnt it the instance of ?
08:10:44 <edlinde> sipa: k
08:10:48 <Unforgivable^> that seems the most logical thing to me
08:11:00 <Unforgivable^> as pumpkin said :p
08:11:11 <edlinde> so what was the overloading solution to this doubling problem?
08:11:14 <sipa> there is no overloading in the C++/Java sense that you can give different function declarations with different argument types, and give separate definitions for them
08:11:26 <edlinde> ok 
08:11:30 <bderooms> sipa: I somehow thought ur first example was good enough with the list.. equality has to be defined on all items you are putting in the list then right?
08:11:59 <sipa> edlinde: but you do agree that a single function that works for both Ints and Floats would be useful in this case?
08:12:10 <edlinde> yeah I do
08:12:23 <edlinde> but I don't see how you do it in Haskell
08:12:25 <edlinde> :)
08:12:29 <sipa> bderooms: the example is equally good, except people may not agree that it is useful to have a single function that does this for both lists and sets
08:12:37 <sipa> edlinde: so, what alternatives are there
08:12:44 <sipa> you could say: doubleIt :: a -> a
08:12:45 <dmead> you don't need to have equality to list things
08:13:01 <edlinde> sipa: but that would mean people could pass in strings
08:13:05 <edlinde> or something
08:13:06 <sipa> edlinde: and say that it needs to works for each and every type
08:13:10 <sipa> yup
08:13:17 <EvanR-work> Unforgivable^: i was wrong earlier, Num is not a type
08:13:21 <edlinde> ok we want something more restrictive
08:13:32 <sipa> no, you *need* it to be more restrictive
08:13:38 <edlinde> sipa: ok
08:13:42 <Unforgivable^> aha
08:13:44 <Entroacceptor> manateeUser: test
08:13:47 <sipa> the point is, how would you write this doubleIt?
08:13:57 <Unforgivable^> but it is the belongs to or is an instance of then?
08:14:02 <edlinde> sipa: ok  
08:14:04 <sipa> if the type is a -> a, you know absolutely *nothing* about the type a
08:14:08 <EvanR-work> doubleIt :: Monoid a => a -> a
08:14:11 <edlinde> sipa: aha
08:14:13 <Unforgivable^> I also see a lot bla :: Eq a => a -> a
08:14:18 <EvanR-work> doubtlIt x = mappend x x
08:14:33 <sipa> EvanR-work: yeah that all works, try not to confuse him for now :)
08:14:46 <edlinde> sipa: just blurt it out now :)
08:14:55 <sipa> edlinde: and clearly you'll need the (*) operator
08:15:01 <edlinde> yeah I agree
08:15:07 <edlinde> ah wait
08:15:15 <edlinde> ah yeah
08:15:20 <sipa> if you're going to implement it
08:15:23 <EvanR-work> if you need * you need Num, if you need mappend you need Monoid
08:15:44 <sipa> so, you can make it doubleIt :: Num a => a -> a
08:15:48 <EvanR-work> (mappend is basically ++)
08:15:58 <edlinde> so whats Num?
08:16:01 <sipa> that means, it works for every a, but you require a to be in the class Num
08:16:02 <EvanR-work> @src Num
08:16:03 <lambdabot> class  (Eq a, Show a) => Num a  where
08:16:03 <lambdabot>     (+), (-), (*)           :: a -> a -> a
08:16:03 <lambdabot>     negate, abs, signum     :: a -> a
08:16:03 <lambdabot>     fromInteger             :: Integer -> a
08:16:12 <sipa> Num is just some predefined class for numeric-like types
08:16:15 <ski> edlinde : unfortunately, neither Hugs nor GHCi supports defining types (or classes, or making instances) in the interactor
08:16:30 <ski> edlinde : type classes are, sortof, the generalization of equality type variables
08:16:44 <edlinde> ah I see
08:16:57 <edlinde> so these names for types.. are they called Monoids?
08:17:07 <sipa> Monoid is just another Class
08:17:12 <sipa> class
08:17:12 <EvanR-work> @src Monoid
08:17:12 <lambdabot> class Monoid a where
08:17:13 <lambdabot>     mempty  :: a
08:17:13 <lambdabot>     mappend :: a -> a -> a
08:17:13 <lambdabot>     mconcat :: [a] -> a
08:17:27 <sipa> Num is the class of number-like types
08:17:28 <edlinde> I suppose there are more such typeclasses depending on your operations and overloading?
08:17:40 <diPython> why does it require the mconcat as well?
08:17:50 <EvanR-work> mconcat has a default definition in terms of append
08:18:00 <sipa> Monoid is the class of appendable types (that that can be concatenated)
08:18:22 <sipa> Eq is the class of types whose values can be tested for equality
08:18:23 <EvanR-work> you can make a custom definition for mconcat for performance
08:18:26 <edlinde> yeah its just that I heard a lot of talk about Monoids
08:18:26 <dstcruz> I didn't think that mconcat was a requirement for a true Monoid, but it is a convenience function
08:18:32 <edlinde> didn't know what they were
08:18:34 <EvanR-work> edlinde: probably Monads
08:18:38 <dstcruz> @where lyah
08:18:38 <lambdabot> http://www.learnyouahaskell.com/
08:18:46 <edlinde> Ah yeah Monads sorry
08:18:47 <dstcruz> edlinde: I strongly suggest reading that
08:18:56 <EvanR-work> @src Monad
08:18:56 <lambdabot> class  Monad m  where
08:18:57 <edlinde> I am reading that now
08:18:57 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
08:18:57 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
08:18:57 <lambdabot>     return      :: a -> m a
08:18:57 <lambdabot>     fail        :: String -> m a
08:19:06 <dstcruz> specially the chapters on Functors, Applicative, Monoids and Monads.  Awesome intro to the topic, IMHO
08:19:07 <edlinde> am on types and typeclasses now
08:19:16 <diPython> dstcruz mconcat is not a requirement for a math. def. of a monoid 
08:19:22 <edlinde> dstcruz: yeah I started last night mate
08:19:23 <edlinde> :)
08:19:24 <itsjar> btw.. sipa, does the haskell interpreter just check if the type of the argument has a (+), (-), (*) .. in order to be a Num?
08:19:24 <dstcruz> diPython: yeah
08:19:35 <edlinde> ok back at it
08:19:37 <edlinde> cheers
08:19:42 <edlinde> thanks for the explanations guys
08:19:56 <dstcruz> edlinde: awesoe, read a bit more, Monoids, Functors, Monads, etc, are typeclasses, and you'll see how cool they are
08:20:13 <ray> itsjar: they have to be in an instance definition
08:20:28 <ray> instance Num T where a + b = ... etc
08:20:48 <itsjar> I'll reread it :)
08:21:00 <EvanR-work> dstcruz: i know, they are so cool
08:21:02 <ski> edlinde : mathematically, a monoid is any set `M', together with operations `1 : 1 >-> M' and `(*) : M * M >-> M', such that `1' is left and right unit of `(*)', and `(*)' is associative
08:21:26 <benmachine> diPython: if you have mconcat you can make a monoid and if you have a monoid you can make mconcat, so it might as well be
08:21:41 <ski> edlinde : e.g. natural numbers with one and multiplication forms a monoid .. as well as natural numbers with zero and addition
08:21:49 <benmachine> in fact having mconcat will give you mempty as well
08:22:00 <EvanR-work> > mappend [] [1,2,3]
08:22:01 <lambdabot>   [1,2,3]
08:22:10 <ski> edlinde : also, for any type `a', the type of list of elements of type `a', i.e. `[a]' forms a monoid, with the empty list, and list concatenation
08:22:14 <EvanR-work> > mconcat []
08:22:15 <lambdabot>   ()
08:22:19 <EvanR-work> :o
08:22:20 <benmachine> free monoid woo
08:22:25 <benmachine> EvanR-work: super-defaulting
08:22:28 <EvanR-work> lol
08:22:45 <edlinde> ski: ok
08:22:45 <dstcruz> EvanR-work: the first time I saw those typeclasses in detail I knew these peeps where on to something :)
08:23:34 <EvanR-work> antihaskell propaganda: haskell is made by people who like math, for people who like math. its academic only.
08:24:19 <Botje> by contrast, only people who can prove they have no math skills whatsoever can write code in java!
08:24:36 <diPython> benmachine yeah mconcat = folder mappend mempty
08:24:42 <diPython> foldr
08:24:46 <adimit> ... without slowly going insane, at least.
08:25:13 <dstcruz> Botje: ouch, merciless
08:25:17 <Entroacceptor> EvanR-work: that can't be. Function application by SPACE? common!
08:25:46 <EvanR-work> syntax
08:25:52 <benmachine> diPython: mmhm. mathematically, [a] is the free monoid on a, so I think there's actually something sensible in saying that a function from lists to your monoid (satisfying sensible properties) is mathematically defining a monoid
08:26:20 <ray> uh
08:26:31 <ray> isn't that pro-haskell propaganda
08:27:05 <Nibble> what is a monoid?
08:27:12 <EvanR-work> Nibble: you missed the bus
08:27:44 <benmachine> Nibble: in haskell, or in maths? ski gave the mathematical definition up there a bit ^^
08:27:45 <EvanR-work> ray: well imagine i am someone who does not like math and am explaining why im not going to use haskell for something
08:28:23 <Nibble> in haskell
08:28:33 <benmachine> in haskell it's a typeclass of things that can be combined in some way
08:28:44 <sipa> @src Monoid
08:28:44 <lambdabot> class Monoid a where
08:28:44 <lambdabot>     mempty  :: a
08:28:44 <lambdabot>     mappend :: a -> a -> a
08:28:44 <lambdabot>     mconcat :: [a] -> a
08:29:23 <Entroacceptor> and you can easily see how the mathematical definition fits :)
08:29:24 <EvanR-work> not just some way
08:29:29 <benmachine> such that the combining operation is associative (basically, it doesn't matter whether you foldl or foldr it), and has an identity element (which is useful for folds ands tuff)
08:29:32 <EvanR-work> they have to be combined in an associative way
08:29:47 <ski> edlinde,Nibble : well, in Haskell, a monoid is basically any instance of the class `Monoid' which satisfies the laws .. and this is basically the same as the math definition
08:29:49 <diPython> benmachine i didnt get your point. what is that something sensible that you are referring to?
08:29:49 <EvanR-work> and can possibly be combined with a identity element for no effect
08:30:02 <ray> mconcat should be unnecessary
08:30:11 <ski> edlinde : though, in category theory, the definition of monoid can be generalized to not only work on sets ..
08:30:23 <benmachine> diPython: I mean, you could define a monoid on a set by defining a function from lists of that set to that set
08:30:28 <dstcruz> Nibble: it is a typeclass
08:30:28 <EvanR-work> a minimal complete defintion for Monoid is mempty and mappend
08:30:32 <Nibble> Sounds simple enough
08:30:43 <ray> it's a method to let you define it more efficiently i guess
08:30:49 <benmachine> diPython: I'm not really sure I haven't thought about this too much (and haven't done very much abstract algebra yet) but I think there'd be a fairly natural way to do it
08:31:06 <ray> methods can have defaults
08:31:26 <wlangstroth> I think "academic" is when all of your variables look like "ll" or "lfr", and you don't use type signatures, because "everybody" knows the Jones-Franklin-Michelin algorithm
08:31:48 <EvanR-work> hah
08:31:52 <quicksilver> the Michelin algorithm is how haskell programmers choose where to eat?
08:32:01 <quicksilver> On a Friday is must be at least one rosette.
08:32:33 <ray> it is clear that
08:32:37 <ray> trivially
08:33:04 <EvanR-work> it obviously follows that
08:33:12 <ray> proof omitted because of lack of margin space
08:34:01 <EvanR-work> unless you are a bumbling buffoon it should be obvious that
08:34:03 <ski> ray : `mconcat' is the initial morphism :)
08:34:11 <ray> proving that P=NP is trivial and left as an exercise for the reader
08:34:18 <Nibble> ray: actually
08:34:23 <Nibble> I heard some dude was working on that
08:35:14 <diPython> benmachine i think you could but thats not necessarily true. i think you can define a function from a list of that set to that set without truly defining the monoid (i.e. the identity element and the assoc. op)
08:35:14 <EvanR-work> some dude published a proof
08:35:19 <EvanR-work> and it was wrong
08:35:29 <pumpkin> many dudes have tried proofs
08:35:42 <EvanR-work> and probably some dudettes
08:36:14 <wlangstroth> magnificent
08:36:38 <Nibble> what is the status of ghc with llvm?
08:37:02 <astroboy> Nibble: quite good
08:37:03 <benmachine> diPython: sure, if you don't place any restrictions on the function
08:37:27 <astroboy> Nibble: http://hackage.haskell.org/package/llvm
08:37:33 <benmachine> diPython: I'm now wondering if there aren't some corresponding sensible restrictions you can put on the function such that the laws arise naturally
08:37:45 <diPython> benmachine i was thinking about that
08:37:48 <shapr> I wish I could attend BostonHaskell at MIT on the 29th, I wanna see ddarius and pumpkin talk about Haskell!
08:39:07 <benmachine> so do I
08:39:13 <benmachine> damn you atlantic, always getting in the way
08:39:39 <benmachine> diPython: I'm a bit confused about this whole issue, I think I need to learn more category theory :P
08:39:47 <quicksilver> benmachine: I think no restrictions are required.
08:40:30 <quicksilver> I think any function [a] -> a defines a monoid structure on a.
08:40:49 * benmachine thinks about this
08:41:01 <quicksilver> that's really what it means for [] to be the free monoid.
08:41:09 <benmachine> yeah I thought it was something like that
08:41:17 <quicksilver> all monoid structures on a factor (uniquely) through [a].
08:41:23 <benmachine> right, ok
08:42:11 <benmachine> but if a is Int, what kind of structure would mconcat = length get you?
08:42:28 <quicksilver> ah.
08:42:29 <diPython> exactly
08:42:30 <itsjar> I wonder why I just can't type (4:5) to 'cons' 2 values together
08:42:39 <quicksilver> you need mconcat [x] = x
08:42:46 <quicksilver> you need to fix it on single elements
08:42:50 <benmachine> oh right
08:42:52 <pumpkin> or you need to keep it polymorphic?
08:42:53 <quicksilver> otherwise it's a monoid homomorphism.
08:43:21 <sipa> itsjar: (4:[5]) works
08:43:25 <sipa> > 4:[5]
08:43:26 <lambdabot>   [4,5]
08:43:32 <sipa> > 4:5:[]
08:43:32 <nlogax> is there something like partsOf 2 "hello!" -> ["he", "ll", "o!"] ?
08:43:33 <lambdabot>   [4,5]
08:43:35 <itsjar> yup, but 'why' doesnt it?
08:43:42 <quicksilver> (mconcat = length is a perfectly sensible monoid homomorphism)
08:43:42 <itsjar> I thought : was like the 'cons' of scheme
08:43:44 <sipa> itsjar: look at the type
08:43:48 <sipa> :t (:)
08:43:49 <roconnor> @hoogle chunk
08:43:49 <lambdabot> forall a. a -> [a] -> [a]
08:43:50 <lambdabot> Data.ByteString.Lazy.Internal chunk :: ByteString -> ByteString -> ByteString
08:43:50 <lambdabot> Data.ByteString.Lazy.Internal Chunk :: ByteString -> ByteString -> ByteString
08:43:50 <lambdabot> Network.HTTP.Base chunkedTransfer :: BufferOp a -> IO (Result a) -> (Int -> IO (Result a)) -> IO (Result ([Header], a))
08:43:53 <quicksilver> nlogax: no
08:43:53 <benmachine> itsjar: because : glues an element on to a list, not an element on to an element
08:44:15 <sipa> itsjar: it takes something of type a, and something of type list of a, and gives you something of type list of a
08:44:17 <quicksilver> nlogax: I favour "chunksOf n = takeWhile (not.null) . map (take n) . iterate (drop n)
08:44:21 <benmachine> nlogax: you can do something clever with splitAt and unfoldr
08:44:24 <quicksilver> nlogax: as name and definition.
08:44:26 <roconnor> nlogax: look for Data.Split
08:44:32 <itsjar> okayz, thanks
08:44:51 <nlogax> quicksilver, benmachine, roconnor, thanks :)
08:44:55 <sipa> itsjar: however:
08:44:57 <sipa> :t (,)
08:44:58 <lambdabot> forall a b. a -> b -> (a, b)
08:45:14 <sipa> that just combines two elements of any type, and creates a tuple from them
08:45:22 <nlogax> roconnor: that's Data.List.Split i take it
08:45:42 <itsjar> yup, I knew about tuples. I just got confused cause my teacher said : is like cons :P
08:45:54 <nlogax> roconnor: that's the stuff!
08:46:00 <nlogax> just what i needed
08:46:33 <benmachine> > getDual . foldMap (Dual . pure) $ [1,2,3,4,5]
08:46:34 <lambdabot>   Not in scope: `foldMap'
08:46:36 <benmachine> grr
08:46:41 <benmachine> > getDual . Data.Foldable.foldMap (Dual . pure) $ [1,2,3,4,5]
08:46:42 <lambdabot>   No instance for (GHC.Show.Show (f a))
08:46:42 <lambdabot>    arising from a use of `M4931945396...
08:46:46 <benmachine> grrrr
08:46:55 <benmachine> > getDual . Data.Foldable.foldMap (Dual . pure) $ [1,2,3,4,5] :: [Integer]
08:46:56 <lambdabot>   [5,4,3,2,1]
08:47:02 <benmachine> neat :D
08:47:19 <identity> Query: If I had a ReaderT running on top of a StateT on top of IO the WriterT could modify the state and lift to io, right?
08:47:34 <sipa> itsjar: cons is more like (,)
08:47:57 <sipa> when using cons to create a linked list, the second argument to it will always be another list
08:48:08 <quicksilver> LISP cons is like (:) when you consider the way to implement lists in lisp
08:48:12 <Nibble> what does a type like this mean
08:48:18 <quicksilver> but LISP cons is also like (,) when you consider the way to implement pairs in lisp
08:48:20 <Nibble> ReaderT Something IO
08:48:27 <quicksilver> since, in lisp, lists are pairs
08:48:56 <itsjar> hehe, perfect quicksilver :P
08:49:19 <pumpkin> if if ExpFunctor carries xmap :: (a -> b) -> (b -> a) -> f a -> f b, what would carry (a -> f b) -> (b -> f a) -> f a -> f b?
08:49:21 <sipa> Nibble: it's the IO monad transformed using ReaderT to read from type Something
08:49:28 <pumpkin> the type sig seems closest to bind
08:50:55 <benmachine> Cale: can you pretty please import some of Data.Foldable and Traversable unqualified? I would be happy with just foldMap but there are some other nice things in there like sequenceA too
08:52:24 <ski> itsjar : `(:)' is like `cons' in Scheme, *when*used*for*lists*
08:52:37 <itsjar> hehe :)
08:53:16 <ski> (itsjar : btw, iirc, there has been suggestions for PLT Scheme^WRacket to make the default `cons' only work for lists (they already made it immutable) .. but i'm not sure whether they did this or not)
08:53:46 <itsjar> yes, but for some reason I think they are doing strange things with scheme
08:53:57 <ski> like Typed Scheme ?
08:54:03 <ski> (or what ?)
08:54:13 <itsjar> the thing that you have a mutable and an immutable cons now
08:54:20 <ski> ok, right
08:54:20 <ski> t
08:54:31 <itsjar> there were other things that I don't recall anymore since it's been 2 years for me
08:54:33 <benmachine> quicksilver: now I'm thinking of almostLength [x] = x; almostLength xs = length xs
08:55:06 <benmachine> quicksilver: I think any foldr with f [x] = x would do it, but that's too restrictive, because we can fold in any direction we like
08:55:23 <benmachine> oh no it wouldn't do it because all list functions can be defined in terms of foldr >_>
08:55:34 <ski> benmachine : fails `almostLength (xs0 ++ xs1) = almostLength xs0 `mappend` almostLength xs1', does it not ?
08:55:56 <benmachine> ski: we're trying to use this function to define mappend and mempty, is my understanding
08:56:51 <EvanR-work> > Sum 4 `mappend` Sum 5
08:56:52 <lambdabot>   Sum {getSum = 9}
08:56:59 <benmachine> ski: well, either way, the upshot is the almostLength doesn't define a monoid structure
08:56:59 <EvanR-work> come get sum
08:57:26 <EvanR-work> > mconcat [] :: Sum Int
08:57:27 <lambdabot>   Sum {getSum = 0}
08:58:07 <McManiaC> http://npaste.de/n7/ whats wrong with line 25? why can't I just call import?
08:58:24 <McManiaC> oh the error:
08:58:31 <McManiaC> integral.hs:25:15: parse error on input `"'
08:59:41 <Lemmih> McManiaC: foreign import ccall?
08:59:45 <ski> benmachine : is `almostLength' supposed to be a monoid homomorphism, then ?
09:00:14 <McManiaC> Lemmih: damn -.- right, thank you
09:00:16 <benmachine> ski: I dunno. I'm wondering what kinds of definitions for mconcat lead to a monoid
09:00:47 <ski> with `mconcat = almostLength' being one alternative ? 
09:01:24 <benmachine> ski: mconcat = almostLength doesn't seem to form a monoid, even though it follows quicksilver's rule
09:01:37 <benmachine> so I'm wondering what does
09:02:17 * ski is wondering what exactly is quicksilver's condition
09:02:45 <quicksilver> hmm
09:03:26 <quicksilver> benmachine: it does form a monoid, doesn't it?
09:03:28 <ski> we can easily imagine `mempty = mconcat []; mappend a0 a1 = mconcat [a0,a1]', given a definition of `mconcat'
09:03:56 <ski> and then we want to require at least that `mempty' is left and right unit to `mappend', which is associative
09:04:06 <benmachine> yes
09:04:22 <benmachine> quicksilver: um, maybe?
09:04:57 <ski> so, we want to require `mappend mempty a = a', which is then equivalent to `mconcat [mconcat [],a] = a' .. mutatis mutandis for the right unit law
09:05:31 <benmachine> mm
09:05:39 <McManiaC> how do you turn a CDouble into a haskell float/double?
09:05:57 <pumpkin> realToFloat?
09:06:08 * ski isn't quite clear on what quicksilver meant by "all monoid structures on a factor (uniquely) through [a]."
09:06:55 <benmachine> but almostLength [almostLength [], a] = 2
09:07:09 <McManiaC> pumpkin: from what lib?
09:07:16 <pumpkin> McManiaC: standard :P
09:07:21 <pumpkin> realToFrac, sorry
09:07:22 <benmachine> realToFrac
09:07:35 <benmachine> you cross your fingers and hope there's a RULE
09:07:41 <quicksilver> benmachine: no, it's not.
09:07:50 <ski> > realToFrac (pi :: CReal) :: Float
09:07:51 <lambdabot>   *Exception: CReal.toRational
09:07:56 <quicksilver> benmachine: the condition you need is the following:
09:08:24 <quicksilver> mconcat(xs ++ ys) == mconcat [mconcat xs,mconcat ys]
09:08:31 <benmachine> oh, ok
09:08:34 <benmachine> that would make a lot of sense
09:08:43 <quicksilver> benmachine: (actually the n-ary version of that not just the binary, but perhaps the former implies the latter?)
09:08:47 <quicksilver> benmachine: apologies for misleading you ;)
09:08:58 <benmachine> that's fine :)
09:09:11 <ski>   mconcat . concat = mconcat . map mconcat  -- ?
09:09:14 <benmachine> if you lead me twice and only the first is misleading I reckon I'm still ahead
09:09:23 <quicksilver> ski: all monoid homomorphism from a set A to a monoid M factor uniquely through the set of 'lists of A' [A]
09:09:54 <quicksilver> ski: and a monoid *structure* on A is a monoid homomorphism from A to A such that elements go to elements.
09:10:21 <benmachine> ski: hmm, reminds me of the associativity law for join
09:10:35 * ski tries to figure out why this should be the case ..
09:12:07 <benmachine> quicksilver: wait, you need mconcat . concat = mconcat . map mconcat, *and* mconcat [x] = x?
09:12:23 <itsjar> weird.. I had an infinite computation on a factorial funciton I made. tried it 3 times.. reloaded WinGHCI and it works..
09:12:46 <EvanR-work> you finished an infinite computation? that is weird
09:12:50 <itsjar> no i didn't
09:12:56 <itsjar> I had to break it 3 times
09:13:07 <itsjar> I didn't see anything wrong so I restarted ghci, loaded same file
09:13:13 <quicksilver> benmachine: well mconcat[x] = x makes it a monoid structure on A rather than a homomorphism to a different monoid
09:13:22 <benmachine> quicksilver: ah, right
09:13:25 <ski> @quote impossible.just
09:13:25 <lambdabot> <autrijus> says: Perl: "Easy things are easy, hard things are possible" <autrijus> Haskell: "Hard things are easy, the impossible just happened"
09:13:51 <benmachine> itsjar: is there any possibility you are giving negative inputs, or non-integer inputs
09:13:59 <itsjar> nope
09:14:07 <EvanR-work> lol
09:14:21 <itsjar> well it's the second weird behaviour I have with winGHCi
09:14:22 <quicksilver> ski: basically it's saying that (abcd)(efgh) = (abcdefgh)
09:14:26 <itsjar> before today I had something that didn't parse
09:14:30 <itsjar> restarted it.. it parsed..
09:14:42 <quicksilver> ski: i.e. it's an N-ary way to specify associativity 
09:14:49 <itsjar> my pc is pulling jokes with me.. :)
09:15:13 <ski> quicksilver : oh, right .. for some reason i've always thought of that as `(+ a ... (+ b ...) c ...) = (+ a ... b ... c ...)' before
09:15:13 <quicksilver> (a,b,c,d,e,f,g,h being different elements of the set/monoid)
09:15:21 <itsjar> anyway, problem solved, we'll see if it still acts weird later
09:15:50 <ski> quicksilver : i suppose the `(+ (+ a ...) ...) = (+ a ... ...)' view could be useful, as well
09:18:16 <quicksilver> ski: yes, we were emphasising the n-ary view because benmachine's initial query was "to define a monoid solely using mconcat, what conditions must it satisfy"
09:18:26 <quicksilver> which is of course the n-ary approach.
09:19:25 <benmachine> I kind of think the n-ary approach makes it more obvious why it's interesting as opposed to (x + y) + z = x + (y + z)
09:19:30 <benmachine> but maybe that's just me
09:19:42 <ski> quicksilver : well, but `mconcat (as0 ++ [mconcat as] ++ as1) = mconcat (as0 ++ as ++ as1)' is also possible, using solely `mconcat'
09:20:04 <quicksilver> benmachine: you may be interested to reflect on the fact that Foldable is the dual of Monoid in some sense
09:20:19 <quicksilver> benmachine: and just like 'mconcat' is sufficient to define Monoid, 'toList' is sufficient to define Foldable.
09:20:36 <benmachine> quicksilver: that's pretty neat
09:21:08 <quicksilver> ski: ok, right, I think I didn't understand what your ...s denoted ;)
09:21:11 <quicksilver> ski: I do now.
09:21:38 <ski> benmachine : well, turning it on its head, `(x + y) + z = x + (y + z)' is the *reason* why there is such a thing as "`n'-ary view" :)
09:22:00 <benmachine> ski: hmm?
09:22:14 <ski> quicksilver : sorry, it was the "repeatedly" notation from `syntax-rules' macro definitions in Scheme
09:22:23 * quicksilver nods at ski 
09:22:38 <ski> benmachine : `a + b + c + d + e' is meaningful, because of asssociativity
09:22:43 <ski> s/sss/ss/
09:22:53 <Nibble> hmm
09:23:01 <benmachine> ski: ah, right, yes
09:23:14 <ski> i.e. "it doesn't matter how you bracket"
09:23:19 <benmachine> mm
09:25:16 <coppro> Hey, with parsec, sepEndBy seems to attempt to consume a minimal number of items rather than the maximum number - I'm using spaces as the separator if it matters - how do I make it consume as many items as it can
09:25:45 <ski> benmachine : btw, in e.g. <http://en.wikipedia.org/wiki/Alternative_algebra>, which need not be associative, one still has that `x * x * x * ... * x' is unambiguous : this is known as "power-associativity"
09:26:14 <benmachine> ski: oh right
09:26:59 <ski> (there's also "di-associativity")
09:32:50 <Unforgivable> test
09:32:52 <Unforgivable> 123
09:32:52 <Unforgivable> test
09:32:57 <EvanR-work> i cant hear you
09:33:05 <Unforgivable> seems it works :d
09:33:52 <nus> @untest
09:33:52 <lambdabot> Unknown command, try @list
09:33:56 <nus> :-P
09:34:01 <Unforgivable> @test
09:34:01 <lambdabot> Maybe you meant: let list tell
09:34:20 <Unforgivable> let list tell nus @untest
09:36:16 <ski> that's .. unforgivable !
09:36:26 <Unforgivable> hahaha
09:36:43 <ski> (you must get these a lot ..)
09:37:11 <Unforgivable> yep
09:37:13 <Unforgivable> indeed :p
09:37:18 <Unforgivable> heard them all lol
09:37:34 * nus hums "The unforgiven"
09:38:12 <nus> @botsnack
09:38:13 <lambdabot> :)
09:38:17 * EvanR-work sues nus 
09:38:34 * nus hires a haskelloyer
09:39:02 <AngelaHarms> Question? (Should I ask first, or just blurt it out?)
09:39:15 <EvanR-work> dont ask to ask
09:39:23 <benmachine> AngelaHarms: blurting's cool
09:40:20 <AngelaHarms> Wassat arrow symbol here? x <- xs ... and more importantly, is there a way to google such things? it seems to ignore the punctuation-looking things.
09:40:30 <AngelaHarms> (thanks)
09:40:38 <ski> AngelaHarms : is that in a list comprehension, or in a `do'-block ?
09:40:53 <AngelaHarms> In a list comprehension
09:40:55 * ski presumes list comprehension
09:40:57 <ski> ok
09:41:02 <AngelaHarms> I've never heard of a 'do'-block :)
09:41:12 <ski> never mind that yet, then :)
09:41:23 <nus> @where tourofsyntax
09:41:24 <lambdabot> I know nothing about tourofsyntax.
09:41:24 <ski> > [ 2*x | x <- [0,2,4,6,5,3,1] ]
09:41:25 <lambdabot>   [0,4,8,12,10,6,2]
09:41:35 <AngelaHarms> it just showed up in Learn You a Haskell
09:41:35 <EvanR-work> > "dont" ++ (fix ("ask to" ++))
09:41:37 <lambdabot>   "dontask toask toask toask toask toask toask toask toask toask toask toask ...
09:41:42 <EvanR-work> dammit
09:41:42 <nus> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
09:41:46 <ski> AngelaHarms : the `x <- xs' can be read "draw each `x' from the list `xs'"
09:42:11 <edlinde> if I wanted to test out functions do I have to have them in a file first?
09:42:12 <ski> AngelaHarms : the above lambdabot example should show you a simple use of it
09:42:22 <edlinde> can it not be check interactively on ghci?
09:42:39 <ski> edlinde : you can define with `let' in GHCi (only, not in Hugs)
09:43:17 <AngelaHarms> I don't see an above exxample, but it seems clear enough.
09:43:27 <edlinde> I wanted to try
09:43:28 <edlinde> lucky :: (Integral a) => a -> String  
09:43:28 <edlinde> lucky 7 = "LUCKY NUMBER SEVEN!"  
09:43:28 <edlinde> lucky x = "Sorry, you're out of luck, pal!"   
09:43:33 <edlinde> something from pattern matching
09:43:42 <edlinde> but I cannot use let with this can I?
09:43:46 <ski> AngelaHarms : so `[ 2*x | x <- [0,2,4,6,5,3,1] ]' is "construct the list of every `2*x', where each `x' is drawn from the list `[0,2,4,6,5,3,1]'"
09:43:54 <edlinde> is there a haskell IDE ? :)
09:44:03 <AngelaHarms> Oh, right. 
09:44:04 <ezyang> I'm trying to imagine what {-# LANGUAGE StrictByDefault #-} per module would do. 
09:44:04 <lambdabot> ezyang: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:44:12 <ezyang> @messages 
09:44:12 <lambdabot> lispy said 11h 47m 8s ago: I thought haskellers.com was going to be a site cannonicalize identities for haskellers. It seems to be turning into linkedin for haskellers, which to me is much less
09:44:12 <lambdabot> useful.
09:44:12 <lambdabot> lispy said 11h 43m 39s ago: I'd like my packages on hackage to link back to my haskeller's profile and then have it link to patch-tag, community.haskell.org, github, my blog, etc. Right now it just
09:44:12 <lambdabot> seems to hold my skills and some of the aliases I use (but not even my hackage ID)
09:44:12 <lambdabot> lispy said 11h 42m 50s ago: so I'm a bit confused about the site. Either I had the wrong impression or the focus changed.
09:44:24 <ski> edlinde : use `let lucky :: ...; lucky 7 = ...; lucky x = ...' .. or `:{' and `:}' to enter multiple lines at once
09:44:27 <AngelaHarms> Now I remember I got that, then apparently lost it again. :) Such is learning. 
09:44:33 <edlinde> ah ok
09:44:34 <AngelaHarms> Thank you! (again)
09:44:46 <ski> AngelaHarms : np, yw :)
09:45:17 <PeakerWork> > unwords $ "dont" : cycle ["ask", "to"]
09:45:18 <lambdabot>   "dont ask to ask to ask to ask to ask to ask to ask to ask to ask to ask to...
09:45:21 <ezyang> Would it fundamentally require changing the way GHC works? Or could we do it on a per module basis? 
09:45:26 <ski> AngelaHarms : incidentally, list comprehensions is similar to *set* comprehensions, in math, if you've heard about those
09:45:28 <PeakerWork> EvanR-work: easier than getting spaces right..
09:45:46 <AngelaHarms> Oh, hey. He uses _ in place of a name. Is that a special case? Reusable indefinitely?
09:45:48 <EvanR-work> never!
09:45:55 <EvanR-work> :t fix fix
09:45:55 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
09:45:56 <lambdabot>     Probable cause: `fix' is applied to too many arguments
09:45:56 <lambdabot>     In the first argument of `fix', namely `fix'
09:45:56 <AngelaHarms> He being Learn You a Haskell person.
09:46:09 <edlinde> ski: when you write longer functions do you place them in a file and compile all the time to check the output?
09:46:40 <ski> AngelaHarms : `_' is the "anonymous variable name". using it in a pattern means that you don't care about what that thing is, so you don't even bother to give it a name
09:47:07 <EvanR-work> can you refer to _ ?
09:47:14 <ski> edlinde : usually, though i test much in GHCi (or Hugs), interactively
09:47:26 <ski> EvanR-work : what do you mean ?
09:47:27 <AngelaHarms> Ok, so it is embedded in the language, and not just convention, and so is reusable (unlike other names) right?
09:47:28 <edlinde> ok so there is no other way?
09:47:36 <ski> AngelaHarms : you got it ! :)
09:47:40 <edlinde> like how lispers check out their stuff in emacs?
09:47:44 <zygoloid> EvanR-work: no, it's fully magical, you can even use it twice in the same pattern.
09:47:48 <EvanR-work> ski: i could try it myself, guess now it would be faster than explaining what i meant ;)
09:47:49 <AngelaHarms> edlinde does it count as compiling if you just save the file and then :l load it?
09:48:05 <AngelaHarms> edlinde: seems pretty easy to me.
09:48:07 <EvanR-work> f _ = _ + 3
09:48:11 <EvanR-work> zygoloid says no
09:48:16 <EvanR-work> makes sense
09:48:36 <EvanR-work> its not an identifier like in js
09:48:51 <zygoloid> nope, it's syntax. _foo is an identifier, though.
09:49:01 <AngelaHarms> Just to be clear, Haskell doesn't have any variables, right? (except maybe that one)?
09:49:24 <quicksilver> AngelaHarms: haskell has variables, but it's a subtly different sense of the word.
09:49:24 <EvanR-work> f x = x + 3
09:49:27 <EvanR-work> x is a variable
09:49:27 <quicksilver> and older sense.
09:49:37 <nus> @let f _ = _ + 3
09:49:37 <lambdabot>   Parse error in expression: WildCard
09:49:59 <zygoloid> AngelaHarms: well, there are IORef and STRef if you want mutable boxes, but normal identifiers don't refer to values which are mutable.
09:50:02 <AngelaHarms> I woulda called that a parameter. Best learn to talk like a Haskeller, though, huh?
09:50:14 * AngelaHarms waves
09:50:14 <ski> edlinde : there is probably a haskell-mode command for sending a buffer to GHCi/Hugs, but the "everything is per default mutually recursive" model of declarations in Haskell means that there is less use for sending definitions interactively
09:50:15 <quicksilver> x is a variable in a mathematical sense - on different invocations of 'f', 'x' may take varying values.
09:50:19 <akamaus> hi, does anybody know encoding in which paths from file chooser returned by Gtk2hs?
09:50:23 <quicksilver> AngelaHarms: you can call it a parameter too. That's fine.
09:50:41 <zygoloid> AngelaHarms: i think mutable versus immutable is a more clear distinction than variable versus constant (or whatever else)
09:50:58 <AngelaHarms> conal: I am Learn (me) a Haskell
09:50:58 <ski> AngelaHarms : Haskell has variables in the same sense math has variables .. but not in the sense of mutable boxes, like in imperative programming (but if you really want mutable boxes in Haskell, you can get them, as well)
09:51:26 <AngelaHarms> ski: If I wanted them, I wouldn't be playing Haskell :)
09:51:26 <conal> AngelaHarms: sweet.
09:51:43 <AngelaHarms> conal: God, it's pretty.
09:51:52 <conal> :)
09:53:33 <nus> akamaus, the one $LANG defaults to, no?
09:53:56 <EvanR-work> mutable boxes is nice if you are writing a very self contained algorithm, or putting caution tape around a large subsystem specifically designed for storing data imperatively like a database
09:54:13 <akamaus> nus, Looks like it's G_FILENAME_ENCODING
09:54:13 <EvanR-work> warning mutable zone
09:54:26 <ksf> are there any hard theoretical reasons why there's no (->) instances for TH's Lift? 
09:54:31 <akamaus> at least gtk does so
09:54:49 <ski> AngelaHarms : btw, one point of using `_' instead of a variable name for a formal parameter in a function, is that that way you're upfront to the reader about not needing to use that parameter, instead of letting the reading having to figure that out for themselves, by scanning the body and finding no use of the variable name
09:55:26 <EvanR-work> ski: i like the feature that you *cant* use it accidentally, because you forgot that you dont need that param
09:55:31 <AngelaHarms> plus it doesn't use up a name, yes? 
09:55:36 <ski> yes
09:55:38 <ski> (AngelaHarms : there's also a warning that you can enable, which warns about unused variables)
09:55:52 <AngelaHarms> a warning in the interpreter?
09:56:06 <ksf> I'd be perfectly happy with the stage restrictions, but not being able to snatch a function out of my GADT would mean that I have to quote a _hell_ a lot of code.
09:56:15 <ski> AngelaHarms : if you really want to use a name for documentation, but still don't want to get that warning, you can name it like `_carrot' instead of `carrot'
09:56:21 <AngelaHarms> I really need an "I'm too stupid to do this" jar. I'd be rich.
09:56:23 <edlinde> http://www.leksah.org/
09:56:30 <Nibble> What are the possibilities of using haskell as a scripting language to be integrated in, lets say C
09:56:31 <ski> AngelaHarms : i think one can enable the warning in the interactor, yes
09:56:31 <edlinde> does anyone use this IDE for haskell?
09:56:35 <ksf> ...and do a lot of processing just to separate functions from my GADT
09:56:49 <Nibble> edlinde: not really
09:56:53 <Nibble> most people use emacs or vim
09:57:05 <EvanR-work> Nibble: use the C api?
09:57:07 <edlinde> ok
09:57:12 <Nibble> EvanR-work: what is the C api
09:57:18 <EvanR-work> keyword ffi
09:57:19 <ksf> ...he means the FFI
09:57:36 <ksf> you'd have to ship the whole ghc runtime, of course.
09:57:56 <ksf> ...which is _big_.
09:58:01 <EvanR-work> GIANT
09:58:05 <ksf> if you're looking for a scripting language, I recommend lua.
09:58:14 <AngelaHarms> tryina figure out why this; [ [ x | x <- xs, even x ] | xs <- xxs] isn't the same as this [ x | x <- xxs, even x ] ... thinking it will be clear once those constructions stop looking weird.
09:58:31 <EvanR-work> and uses enormous amounts of MEMORY
09:58:34 <AngelaHarms> Oh. Because xs is lists.
09:58:46 <Nibble> So I am out of luck
09:58:47 <EvanR-work> its basically java
09:59:00 <EvanR-work> antihaskell propaganda
09:59:15 <ksf> implementations weigh at <500k, it's the fastest scripting language there is (at least luajit, think comparable to java) and it's very, very lispy.
09:59:20 <Itkovian> Yeah! haskell being brought up at splashcon
09:59:38 <ski> > let xss = [[],[0],[1,2],[3,4,5],[6,7,8,9]] in [ [ x | x <- xs, even x ] | xs <- xxs]
09:59:39 <lambdabot>   Not in scope: `xxs'
09:59:47 <ski> > let xss = [[],[0],[1,2],[3,4,5],[6,7,8,9]] in [ [ x | x <- xs, even x ] | xs <- xss]
09:59:48 <lambdabot>   [[],[0],[2],[4],[6,8]]
09:59:59 <ski> > let xss = [[],[0],[1,2],[3,4,5],[6,7,8,9]] in [ x | x <- xxs, even x ]
10:00:00 <lambdabot>   Not in scope: `xxs'
10:00:12 <AngelaHarms> I could paste the example from the tutorial
10:00:14 <ski> > let xss = [[],[0],[1,2],[3,4,5],[6,7,8,9]] in [ x | x <- xss, even x ]
10:00:15 <lambdabot>   No instance for (GHC.Real.Integral [a])
10:00:15 <lambdabot>    arising from a use of `e_1012345...
10:00:18 <EvanR-work> mmmm list incomprehension
10:00:26 <ski> .. oh, right
10:00:32 * ski was thinking of
10:00:39 <ski> > let xss = [[],[0],[1,2],[3,4,5],[6,7,8,9]] in [ x | xs <- xss, x <- xs, even x ]
10:00:40 <lambdabot>   [0,2,4,6,8]
10:00:46 <AngelaHarms> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
10:00:48 <AngelaHarms> oops
10:01:16 <nus> ksf, "scripting languages" don't need speed
10:01:31 <ksf> well, but it's nice to have.
10:01:32 <ski> AngelaHarms : in the former of your list comprehensions, `xxs' is a list of lists of numbers. in the latter, `xxs' must be a list of numbers
10:01:38 <ski> but see
10:01:47 <ski> > let xss = [[],[0],[1,2],[3,4,5],[6,7,8,9]] in [ [ x | x <- xs, even x ] | xs <- xss]
10:01:48 <lambdabot>   [[],[0],[2],[4],[6,8]]
10:01:48 <ski> vs,
10:01:53 <ski> > let xss = [[],[0],[1,2],[3,4,5],[6,7,8,9]] in [ x | xs <- xss, x <- xs, even x ]
10:01:54 <lambdabot>   [0,2,4,6,8]
10:02:06 <ski> here `xss' is a list of lists of numbers, in both cases
10:02:25 * ski hopes this is not confusing AngelaHarms with too much detail at once ..
10:02:27 <AngelaHarms> Yep. 
10:02:36 <EvanR-work> go ahead and use list monads now ;)
10:03:00 <ksf> oh. otoh, there's hugs, which is quite small, compared to ghci
10:04:05 <EvanR-work> > [0,2,4,6,8] >>= replicate 3 . (`div` 2)
10:04:06 <lambdabot>   [0,0,0,1,1,1,2,2,2,3,3,3,4,4,4]
10:04:15 <nus> ksf, what matters for scripting is ubiquity
10:04:15 <EvanR-work> > [0,2,4,6,8] >>= cycle
10:04:16 <lambdabot>   No instance for (GHC.Num.Num [b])
10:04:16 <lambdabot>    arising from a use of `e_102468' at <i...
10:04:27 <ksf> ...and then there's always the possibility to use shell hooks.
10:04:33 <ski> AngelaHarms : btw .. in case it isn't apparent, `xs' is meant to be read as the plural of `x', i.e. "(possibly) many `x's" .. and then "xss" is "the plural of the plural of `x'" :)
10:04:43 <ski> that's just a common naming convention
10:05:11 <Nibble> I thought it meant x string :(
10:05:57 <nus> xsss
10:05:58 <EvanR-work> > [0,2,4,6,8] >>= repeat
10:05:59 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:06:19 <ksf> lua is about as ubiquious as it gets, if you disregard scripting languages that are also used as general purpose or glue laguages like python or perl
10:06:28 <ski> > [0,2,4,6,8] >>- repeat
10:06:29 <lambdabot>   [0,2,0,4,0,2,0,6,0,2,0,4,0,2,0,8,0,2,0,4,0,2,0,6,0,2,0,4,0,2,0,8,0,2,0,4,0,...
10:06:34 <EvanR-work> or as java wanna bes like php
10:06:37 <manateeUser> Bye all, night. :)
10:06:47 <ski> night, manateeUser
10:06:47 <ksf> it's also a charm to integrate into C
10:06:48 <nus> @type (>>-)
10:06:49 <EvanR-work> holy crap what is >>-
10:06:49 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
10:06:57 <ksf> also, there's a hackage package.
10:07:09 <nus> @index MonadLogic
10:07:09 <lambdabot> bzzt
10:07:15 <ski> `(>>-)' is a fair replacement to `(>>=)'
10:07:18 <EvanR-work> @src MonadLogic
10:07:18 <lambdabot> Source not found. It can only be attributed to human error.
10:07:59 <ksf> lisp might still have a greater share when it comes to scripting, but then lisp is divided into thousands of dialects of which the most common one (emacs) is abysmal beyond comparison.
10:08:54 <nus> ksf, your point is as moot as the term 'scripting' is
10:09:22 <ksf> ...I wish the w3c would bury ecmascript and go for lua, instead.
10:11:03 <ClaudiusMaximus> is there any easy way to figure out what is making my executable so HUGE (24MB)
10:11:18 <EvanR-work> static linking
10:11:41 <Jafet> Name it Tiny.
10:12:23 <ski> > fix $ \numbers -> 1 : [2 * number + offset | number <- numbers , offset <- [0,1]]
10:12:24 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:12:45 <Jafet> Heh.
10:12:45 <Honeyman> Hello. Any hint if a module for whole-list arithmetics easily comes to mind? Which has the operators similar to "(+++) a b = map (+ a) b" and "(++++) a b = zipWith (+) a b". I wasn't able to hoogle any.
10:12:46 <zygoloid> haha nice
10:13:07 <ski> (that's traversing an infinite binary tree, breadth-first)
10:13:27 <zygoloid> Honeyman: iirc there's an applicative numbers package around somewhere
10:13:47 <Jafet> > 1 + [2,3,4]
10:13:47 <lambdabot>   No instance for (GHC.Num.Num [t])
10:13:48 <lambdabot>    arising from a use of `e_11234' at <in...
10:13:56 <Jafet> > (1+) . [2,3,4]
10:13:57 <lambdabot>   [3,4,5]
10:14:12 <edlinde> this leksah editor makes no sense to me
10:14:41 <edlinde> I use textmate on macosx... but wondering what the best way to run the functions is?
10:14:50 <zygoloid> Honeyman: applicative-numbers on hackage looks to be the thing you want
10:15:09 <edlinde> I mean there are some things I cannot do so well interactively... so I want a way of being able to do this with files
10:15:12 <Honeyman> zygoloid: Yes, I've googled it by your keyword, thanks; will try to understand it :)
10:15:30 <edlinde> do I save my function as a .hc file?
10:15:35 <edlinde> .hs
10:15:37 <Honeyman> Jafet: I see, but I would prefer to have some more transparency in the arithmetics.
10:15:40 <zygoloid> it looks like you'll also want to use ZipList
10:15:48 <ski> edlinde : that is common, yes
10:16:00 <zygoloid> otherwise you'll get the [] applicative rather than a pairwise one
10:16:40 <edlinde> ski: its just that with ML I am used to writing a bunch of functions in a text file and then testing each one individually in the ML prompt 
10:16:59 * ski sometimes wants to define a type with record syntax, `deriving Show', but to get it to not use the record syntax for `Show' ..
10:17:05 <edlinde> so in this case I would need a seperate file for each new function I want to write?
10:17:15 <ski> edlinde : yes, i do that with Hugs/GHCi, as well
10:17:23 <ski> nonono
10:17:28 <ddarius> ski: You could try gshow or other things.
10:17:37 <ski> edlinde : you don't need a separate file for each function
10:17:51 <ddarius> > show (Sum 1)
10:17:52 <lambdabot>   "Sum {getSum = 1}"
10:17:54 <ski> (that's Matlab which requires such nonsense (well, afaict, anyway))
10:17:56 <ddarius> > gshow (Sum 1)
10:17:57 <lambdabot>   No instance for (Data.Data.Data (Data.Monoid.Sum t))
10:17:57 <lambdabot>    arising from a use ...
10:17:57 <edlinde> ski: but then you got to always have the let syntax? and then have each line seperated by a ; ?
10:18:19 <edlinde> ski: just wondering if there is a good way to do this
10:18:24 <ski> edlinde : nono, that's just to define values in GHCi, you don't use that in source files
10:18:43 <ski> "that" being the `let' syntax
10:18:46 <edlinde> ski: i am a bit confused then
10:19:01 <edlinde> ski: can you show me an example?
10:19:05 <ddarius> > gshow (First (Just 2))
10:19:06 <lambdabot>   No instance for (Data.Data.Data (Data.Monoid.First t))
10:19:06 <lambdabot>    arising from a us...
10:19:10 <ddarius> Bloody heck.
10:19:13 <EvanR-work> > mappend (Sum 4) (Product 3)
10:19:14 <lambdabot>   Couldn't match expected type `Data.Monoid.Sum t'
10:19:15 <lambdabot>         against inferred t...
10:19:20 <edlinde> ski: say I had something like
10:19:21 <edlinde> factorial :: (Integral a) => a -> a  
10:19:22 <edlinde> factorial 0 = 1  
10:19:22 <edlinde> factorial n = n * factorial (n - 1) 
10:19:23 <ski> edlinde : just define functions in a file, not using `let', load it into the interactor, test, modify file, reload, test, rinse, repeat
10:19:26 <EvanR-work> > mappend (Product 3) (Product 3)
10:19:27 <lambdabot>   Product {getProduct = 9}
10:19:36 <ski> that's what i use, anyway
10:19:39 * hackagebot yesod 0.5.4.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.5.4.2 (MichaelSnoyman)
10:20:10 <edlinde> ski: yeah but this would mean you would reload your file with ALL functions all the time yeah?
10:20:15 <edlinde> is that what you meant?
10:20:21 <ski> (edlinde : aside, `(Integral a) =>' there can be written as `Integral a =>')
10:20:24 <edlinde> and how do you load a file sorry?
10:20:38 <ski> yes, you reload the whole file at once
10:20:46 <edlinde> hmmm
10:21:00 <ski> i'm not aware of any way to reload incrementally, currently
10:21:01 <edlinde> coz sometimes I keep a lot of crap code in there too... 
10:21:07 <edlinde> :)
10:21:18 <edlinde> how do you comment out code in Haskell?
10:21:22 <ddarius> > gshow (ZipList [])
10:21:23 <lambdabot>   No instance for (Data.Data.Data (Control.Applicative.ZipList a))
10:21:23 <lambdabot>    arising...
10:21:34 <EvanR-work> > --comment
10:21:35 <lambdabot>   not an expression: `--comment'
10:21:40 <EvanR-work> > 3 --comment
10:21:40 <ddarius> At any rate, gshow is somewhat fugly but it doesn't show the fields.
10:21:41 <lambdabot>   3
10:21:42 <edlinde> and ":r filename" to load interactively?
10:21:50 <edlinde> ski: is that the command to load a file?
10:22:02 <ski> edlinde : in the MLs, succedent declarations are to be elaborated sequentially .. but in haskell, they are to be elaborated mutually recursively
10:22:05 <edlinde> ski: I remember seeing it somewhere but cannot remember off the top of my head
10:22:14 <ski> edlinde : well, just `:r' to reload
10:22:34 <edlinde> don't you need to mention the .hs file from which to load ?
10:22:43 <ski> edlinde : {- this is a block comment {- which nests -} -} -- this is a line comment
10:23:01 <edlinde> ski: ok gotcha
10:23:09 <EvanR-work> > 3 {- does it? {- -} 4-}
10:23:10 <lambdabot>   3
10:23:17 <ski> it recalls the current context, checking whether any files have been updated
10:23:25 <EvanR-work> i thought you needed more --}
10:23:51 <edlinde> ski: yeah but how do I load it into ghci in the first place? what is the command to do that?
10:24:02 <ski> well, `:l FileName.hs'
10:24:05 <ddarius> > let x --> y = x ^ y in x --> y
10:24:12 <lambdabot>   mueval: ExitFailure 1
10:24:24 <ski> (you can also type `:load' and `:reload' instead of `:l' and `:r', the latter are shorthands)
10:24:27 <ddarius> > let x --> y = x ^ y in x --> 3
10:24:32 <lambdabot>   mueval-core: Time limit exceeded
10:25:41 <edlinde> ski: thanks
10:25:43 <ski> edlinde : when you initially start Hugs or GHCi, you can also pass filename(s) as command line arguments
10:25:48 <edlinde> will give it a shot
10:25:53 <edlinde> ah ok
10:27:45 <edlinde> ski: thanks that works great
10:27:46 <Honeyman> zygoloid: Maybe I am not getting the idea of applicative numbers or how to use it, but it seems to be different from what I am looking for.
10:27:46 <ski> edlinde : oh, in case it's not clear, doing (re)loading a file entails recursively loading all its dependants -- you don't have to keep track of loading your files in the correct order yourself
10:27:53 <ski> s/doing //
10:27:56 <Honeyman> zygoloid: Maybe I am not getting the idea of applicative numbers or how to use it, but it seems to be different from what I am looking for.
10:30:29 <ski> ddarius : hm .. isn't that a bug ?
10:30:31 <Honeyman> I'd be ok with having separate operators, but with the module which still has the basic set of "list `op` constant" and "list `op` list" arithmetic operations (assuming that both lists are the same size);
10:31:18 <ski> > let x --> y = x ^ y in x --> 3
10:31:19 <lambdabot>   x * x * x
10:31:28 <ski> .. oh, just lambdabot being lazy, before
10:31:31 <ski> @botsmack
10:31:31 <lambdabot> :)
10:31:41 <Honeyman> But the documentation on applicative numbers package doesn't hint me how can I achieve it with them.
10:39:10 <akamaus> in which encoding should I provide path for, say, readFile? On linux with utf-8 locale, should I encode it in utf-8, or haskell's plain ucs-4 string will be enough?
10:44:57 <mreh> what should I call my signal function? It adds a random initial value to every value in the stream
10:46:19 <Veinor> bleh
10:46:38 <mreh> not very imaginative
10:46:45 <Veinor> right now it looks like that this twitter API is going to require the user to supply the consumer and the token for each API call
10:46:58 <Veinor> mreh: munge?
10:47:59 <mreh> not widely known enough
10:48:09 <Veinor> noiseify?
10:48:11 <Veinor> (noisify)
10:48:16 <mreh> I had randomInit, and use Monoids
10:50:59 <Veinor> randomStart
10:51:19 <roconnor> what is the point of DDC?
10:51:25 <mreh> randomFloor
10:51:37 <ski> `\initial -> fmap (initial +)' ?
10:51:44 <ski> or `scanl (+)' ?
10:51:54 <mreh> ski: it's in Yampa
10:52:12 * ski wonders exactly what it does
10:52:18 <ski> is it a running sum ?
10:52:36 <mreh> it's not a sum, it's like intialising velocity of a moving object
10:52:52 <ezyang> distortion? 
10:52:54 <mreh> so when you integrate the accelerations you get the right velocity
10:53:20 <jmcarthur> roconnor: i think ddc is an experiment with a new kind of effect typing or something. like you are supposed to be able to define a normal function and get a monadic version of it for free, e.g. we have to define map and mapM separately in haskell, at least with our definition of Monad
10:53:57 <jmcarthur> i don't know if that's the whole point, but it's an interesting part of it at least
10:54:20 <jmcarthur> overall i'm not a big fan of it though. i can't stand mixing pure and impure code so implicitly
10:54:42 <roconnor> jmcarthur: granted in Haskell we could define map = runIdentity mapM
10:54:48 <jmcarthur> yes
10:54:51 <roconnor> ^^pseduo code
10:54:54 <jmcarthur> or have a kleisli version of it
10:55:17 <roconnor> and for trees we need different mapM functions for different traversal orders
10:55:19 <jmcarthur> well, kleisli being the mapM version and (->) being the map version
10:55:35 <jmcarthur> a category/arrow version is what i meant
10:55:38 <roconnor> anyhow, I guess you are not really one to defend DDC.
10:55:39 <jmcarthur> categorical functor
10:55:56 <roconnor> I'm tempted to join #disciple and ask "hey, what is the point of DDC?"
10:56:01 <roconnor> but that would sound like trolling
10:56:07 <jmcarthur> not necessarily
10:56:33 <mreh> it looks like: integral >>> arr (x0+)
10:57:29 <roconnor> I mean #disciplined
10:57:52 <ezyang> Thanks. :-) 
11:00:15 <benmachine> @arr
11:00:15 <lambdabot> I'll keel haul ya fer that!
11:00:20 <roconnor> jmcarthur: Andrej's EFF seems better than DDC, but I don't really know either very well
11:00:44 <ski> Bauer ?
11:02:13 <roconnor> yes
11:03:08 * ski waits for someone to create "HGH"
11:03:38 <roconnor> this slide from a DDC talks says that State monads over sequence non-interfering computations
11:03:54 <roconnor> I'm not sure I really believe it.
11:04:05 <sproingie> overuse of the state monad may lead to that, sure
11:04:43 <mreh> over sequence?
11:04:48 <roconnor> if it really oversequenced things, my lazy stateness wouldn't work
11:05:05 <roconnor> mreh: those are the words on the slides
11:05:19 <mreh> over->>=?
11:05:29 <mreh> that's bind
11:05:32 <nus> @src sequence
11:05:33 <lambdabot> sequence []     = return []
11:05:33 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:05:33 <lambdabot> --OR
11:05:33 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
11:05:39 <mreh> that's the one
11:05:52 <roconnor> mreh: the slide also says that every semi-colon becomes a function call.
11:05:57 <nus> so ; .. ;... ;
11:05:58 <roconnor> mreh: so you may be on to something
11:06:15 <roconnor> OTOH, a function call in Haskell is unlike a function call in any other language
11:06:27 <gwern> whups. I just broke every single interwiki link on my wiki. despite having 10 test cases or so
11:06:28 <ski> > snd (do {modify (first (fix (. succ))); modify (second not)} `execState` (0,False))
11:06:35 <lambdabot>   mueval-core: Time limit exceeded
11:06:40 <gwern> just goes to show, testing can show the presence of bugs, but not there absence
11:06:58 <mreh> gwern: and yet the software engineer gleefully goes back to work!
11:07:31 <benmachine> testing could fairly easily show the absence of bugs in the (&&) function >_>
11:07:33 <mreh> roconnor: I was just questioning the meaning of that work
11:07:35 <ski> > snd (do {modify (first (fix (. succ))); modify (second not)} `execState` (0,False))
11:07:36 <lambdabot>   True
11:08:23 <mreh> is there a software engineering random paper generator yet?
11:08:54 <nus> roconnor, iow, they claim they found a better way to describe "non-interfering" (sic?) computations?
11:09:45 <EvanCarroll> how would you write this as fold' foldr ((+).digitToInt) 0 "1234"
11:09:59 <EvanCarroll> foldl'
11:10:15 <EvanCarroll> Obviously you have to flip and cast to interger or something
11:10:28 <Saizan> > foldl' (flip ((+).digitToInt)) 0 "1234"
11:10:30 <lambdabot>   10
11:10:43 <EvanCarroll> cool!!!
11:10:52 <byorgey> > foldl' (+) 0 . map digitToInt $ "1234"
11:10:53 <EvanCarroll> do you have to flip the (+) ?
11:10:53 <lambdabot>   10
11:11:02 <EvanCarroll> byorgey-- # that's two passes over the input
11:11:06 <byorgey> who cares?
11:11:10 <EvanCarroll> me!
11:11:18 <byorgey> why?
11:11:31 <gwern> lovely, all I need to do to fix it is add another if-then, for a 4-level if-then nesting
11:11:38 <benmachine> byorgey++ # subtle knowledge of fusion
11:11:41 <sproingie> the map is lazy anyway
11:11:44 <byorgey> it's exactly the same time complexity.  with luck it will get compiled into the same code anyway.
11:11:59 <EvanCarroll> with luck
11:11:59 <roconnor> > foldl' ((((+).).digitToInt)) 0 "1234"
11:12:00 <lambdabot>   Couldn't match expected type `a -> a'
11:12:00 <lambdabot>         against inferred type `GHC.Ty...
11:12:10 <sproingie> that's way too many parenthesis buster
11:12:13 <zygoloid> byorgey++ # nice composable solution with no asymptotic cost
11:12:27 <benmachine> byorgey++ # no real reason
11:13:00 <gwern> maybe with a 4-level conditional I'm allowed to add a comment like -- you are not expected to understand this
11:13:39 <nus> gwern, now you know why they changed the proportion to 16:9 (-;
11:13:50 <gwern> for anime?
11:13:55 <ski> @type let mix = (fst *** fst) &&& (snd *** snd) in \ma mb -> State (mix . (runState ma *** runState mb))
11:13:56 <lambdabot> forall c b a b1. State b c -> State b1 a -> State (b, b1) (c, a)
11:13:57 <ski> @type let mix = (fst *** fst) &&& (snd *** snd) in curry (State . (mix .) . uncurry (***) . (runState *** runState))
11:13:58 <lambdabot> forall b b' a a1. State b a -> State b' a1 -> State (b, b') (a, a1)
11:14:04 <roconnor> > foldl' ((. digitToInt).(+)) 0 "1234"
11:14:05 <lambdabot>   10
11:14:08 <nus> gwern, nah, to give the testers more slack
11:14:24 <zygoloid> gwern: case (expr1, expr2, expr3, expr4) of (False, _, _, _) -> ...
11:14:32 <ski> hmm
11:14:38 <sproingie> @pl foldl' ((. digitToInt).(+)) 0
11:14:39 <lambdabot> foldl' ((. digitToInt) . (+)) 0
11:14:45 <gwern> zygoloid: that's an interesting idiom
11:14:45 <sproingie> fooey
11:15:17 <sproingie> @pointy foldl' ((. digitToInt).(+)) 0
11:15:17 <lambdabot> foldl' (\ d g -> d + (digitToInt g)) 0
11:15:26 <zygoloid> gwern: or, thingy = v where v | expr1 = ... | expr2 = ... | expr3 = ... | expr4 = ...
11:16:21 <EvanR-work> i like the idea of 4 level if then else, reminds me of way back when i started learning visual basic or "visual" c++
11:16:33 <EvanR-work> or yesterday when i had to write python code
11:17:05 <Nibble> EvanR-work: there are many people learning "visual" C++
11:17:07 <Nibble> :P
11:17:43 <EvanR-work> visual c++, audible cursing
11:17:44 <benmachine> zygoloid: surely, thingy | expr1 = ...
11:18:33 <zygoloid> benmachine: well, i was imagining thingy = some function involving v where v = ...
11:18:42 <benmachine> oh
11:18:44 <zygoloid> but yeah :)
11:19:15 <ski> @type \lens ma -> State (modifyLens lens (runState ma))
11:19:16 <lambdabot> forall s b a. (s -> (b, b -> s)) -> State b a -> State s a
11:22:11 <roconnor> ski: data-accessor!
11:22:45 <ski> yes .. i was pondering whether this operation was in data-accessor .. (or fclabels, or ..)
11:22:52 <EvanR-work> wait
11:22:55 <EvanR-work> oh
11:23:07 <EvanR-work> was wondering what type b, b -> s is ;)
11:23:20 <roconnor> ski: for me, it is effectively the rasion-d'etre for data-accessor
11:23:29 <ski> EvanR-work : well, lambdabot doesn't let me define type synonyms ..
11:24:20 <ski> (s/rasion/raison/, no ?)
11:24:28 <roconnor> ski: ya sorry
11:24:44 <EvanR-work> hysterical raisens
11:25:14 * ski has wanted compositional composable continuations ..
11:25:27 <roconnor> Data.Accessor.MonadState.lift is more or less the operation
11:25:35 <EvanR-work> continuable composible compositions
11:25:42 <roconnor> lift :: Monad m => T r s -> State s a -> StateT r m a
11:25:43 <ski> i.e. something like `Cont o a -> Cont p b -> Cont (o,p) (a,b)'
11:26:44 <ski> @djinn Cont o a -> Cont p b -> Cont (o,p) (a,b)
11:26:45 <lambdabot> -- f cannot be realized.
11:26:50 <ski> (sadly)
11:27:04 <sipa> @djinn a -> b
11:27:04 <lambdabot> -- f cannot be realized.
11:27:14 <sipa> :t const undefined
11:27:15 <lambdabot> forall a b. b -> a
11:27:19 <McManiaC> if I have many directories and I mapM over that list to get the directoryContents - just to see if any of them contains one file - can I rely on haskells lazyness to stop as soon as the file is found or should I do more "optimized" implementation?
11:27:28 <infinity0> is it possible to use haskell libraries from within java?
11:27:32 <Jafet> :t unsafeCoerce
11:27:33 <lambdabot> Not in scope: `unsafeCoerce'
11:27:44 <roconnor> ooh, how can Nixpkgs get in on the Hackage Distribution fields action?
11:28:05 <sipa> McManiaC: you're running in the IO monad?
11:28:06 <ski> McManiaC : `mapM' is as strict as the monad is
11:28:17 <EvanR-work> :t mapM
11:28:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:28:25 <McManiaC> yes, IO
11:28:37 <ski> McManiaC : i.e., in the `IO' monad, it will traverse the whole of the list, before producing any result
11:28:49 <EvanR-work> it returns IO [a], so it has to get the entire list at once
11:28:51 <roconnor> Honestly I'd use Data.Accessor.MonadLib.lift myself
11:29:09 <McManiaC> ok
11:29:13 <EvanR-work> because its IO
11:29:13 <Jafet> unsafeReadDir
11:29:18 <ski> @type Data.Accessor.MonadLib.lift
11:29:20 <sipa> McManiaC: since an IO action can have side effects, it would be very dangerous if it were possible that only part of it were executed
11:29:20 <lambdabot> Couldn't find qualified module.
11:29:28 <McManiaC> I never know when I can trust haskell and when it's cheating on me :(
11:29:39 <EvanR-work> unsafeTrustHaskell
11:29:46 <McManiaC> sipa: ok, point taken :)
11:29:48 <sipa> using IO basically makes it an imperative language
11:29:57 <hrmlgon2> McManiaC: it's always cheating on you.
11:30:10 <EvanR-work> yeah you could run out of memory at any moment
11:30:16 <McManiaC> sipa: what about readFile? it isn't strict
11:30:18 <hrmlgon2> McManiaC: it really only pretends to do what you want it to.
11:30:31 <hrmlgon2> McManiaC: strict /= imperative
11:30:36 <ski> McManiaC : possibly you could use `unsafeInterleaveIO', if you wanted
11:31:03 <EvanR-work> readFile an example of lazy input
11:31:03 * ski thinks the `unsafe' there is unfair
11:31:27 <sproingie> unfairInterleaveIO
11:31:32 <Veinor> haha
11:32:14 <EvanR-work> untamed
11:32:23 <EvanR-work> unabashed
11:32:23 <sipa> :t unsafeInterleaveIO
11:32:24 <lambdabot> Not in scope: `unsafeInterleaveIO'
11:32:28 <ski> hehe, would that be if it didn't execute the I/O on demand, instead doing some arbitrary order ?
11:32:34 <sproingie> unwiseInterleaveIO
11:32:47 <McManiaC> ski: when could unsafeInterleaveIO become "unsafe"?
11:33:00 <EvanR-work> unleavened
11:33:02 <ski> @type System.IO.Unsafe.unsafeInterleaveIO
11:33:03 <lambdabot> forall a. IO a -> IO a
11:33:14 <ski> McManiaC : imo, never
11:33:25 <McManiaC> hm ok
11:33:27 <ski> McManiaC : however, it could easily become unpredictable
11:33:35 <zygoloid> McManiaC: it's unsafe in that it can make order of evaluation of pure code observable
11:33:43 <ski> McManiaC : just like concurrency easily becomes unpredictable
11:33:54 <EvanR-work> what about errors
11:34:02 <McManiaC> ski: true
11:34:03 <sipa> unpredictableInterlieveIO ?
11:34:28 <ski> `unrepententInterbeliveIO' ?
11:34:37 <Itkovian> Seems like the OOPSLA people perceive haskellers are bein unrational :-/
11:34:42 <ski> sorry, s/belive/believe/
11:35:12 <ski> (Itkovian : .. is there a reason given ?)
11:35:19 <aristid> Itkovian: what's oopsla?
11:35:38 <EvanR-work> a cult
11:35:43 <Itkovian> lol@aristid
11:35:48 <byorgey> @go oopsla
11:35:48 <lambdabot> Maybe you meant: google googleit do
11:35:56 <byorgey> @google oopsla
11:35:58 <lambdabot> http://splashcon.org/
11:35:58 <lambdabot> Title: SPLASH 2010
11:35:58 <EvanR-work> @chess oopsla
11:35:59 <lambdabot>   Not in scope: `oopsla'
11:36:11 <byorgey> oh, that's right, it's not OOPSLA anymore, it's SPLASH
11:36:14 <sipa> object-oriented programmers with a service-level agreement?
11:36:15 <Itkovian> ski: somebody mentioned using types and gave the example of haskell in the context of using genetic algorithm to find and solve bugs in code.
11:36:34 <ski> .. ok ?
11:36:35 <aristid> "OOPSLA is an annual conference covering topics on object-oriented programming systems, languages and applications. Like other conferences, OOPSLA offers various tracks and many simultaneous sessions, and thus has a different meaning to different people. It is more academic than some conferences, with doctoral students presenting papers for credit, and less academic than others."
11:36:41 <Itkovian> I tweeted about it and the respons was that they had dropped the H-bomb making rational discussion impossible :-)
11:37:05 <ski> that's not a rational response
11:37:09 <Itkovian> pretty much scheme/lisp stuff going on though this year
11:37:21 <Itkovian> ski: indeed it is not
11:37:37 <EvanR-work> why is oopsla talking about haskell
11:37:43 <aristid> why not
11:37:43 <EvanR-work> at all
11:37:48 <ski> .. but maybe their point was that they no longer were able to stay rational ?
11:38:11 <EvanR-work> its about as far from oops as you can get
11:38:25 <ski> (and giving evidence for it, but providing a sample irrationality)
11:38:51 <McManiaC> ski: ah, hGetContents even uses unsafeInterleaveIO
11:38:55 <ski> yes
11:39:01 <aristid> EvanR-work: if they are smart, they look at things outside the narrow official scope, too
11:39:05 <sipa> @src hGetContents
11:39:05 <lambdabot> Source not found. You untyped fool!
11:39:22 <McManiaC> ski: ok, then it makes sense
11:39:23 <aristid> :t hGetContents
11:39:24 <lambdabot> Not in scope: `hGetContents'
11:39:28 <Itkovian> EvanR-work: it's not. the talk was on GA for bug fixing and software evolving. the question came what to do with things like array bounds crossing where enlarging the array bounds might require changes in the rest of the program, then somebody asked a question if types might be helpful to keep track of bugs and fix higher-level things than simply moving statements around.
11:39:38 <ski> @index hGetContents
11:39:38 <lambdabot> System.IO
11:39:45 <ski> @type System.IO.hGetContents
11:39:46 <lambdabot> GHC.IOBase.Handle -> IO String
11:39:48 <Veinor> is there a better way to write do {x <- y; return $ f x}
11:39:50 <Veinor> ?
11:39:50 <Itkovian> anyway
11:40:03 <ski> Veinor : `liftM f y' or `fmap f y'
11:40:08 <EvanR-work> Itkovian: smart
11:40:13 <Veinor> oh yeah
11:40:18 <McManiaC> Veinor: f <$> y
11:40:20 <ski> Veinor : .. or `f <$> y'
11:40:24 <sipa> @undo {x <- y; return $ f x}
11:40:24 <lambdabot>  Parse error at "{x" (column 1)
11:40:28 <sipa> @undo x <- y; return $ f x
11:40:28 <lambdabot>  Parse error at "<-" (column 3)
11:40:34 <sipa> @undo do { x <- y; return $ f x }
11:40:34 <lambdabot> y >>= \ x -> return $ f x
11:40:39 <aristid> Itkovian: haskell isn't even that good at incorporating array bounds in types :/
11:40:42 <ski> @. pl undo do { x <- y; return $ f x }
11:40:42 <lambdabot> f `fmap` y
11:40:44 <sipa> @pl y >>= \ x -> return $ f x
11:40:44 <lambdabot> f `fmap` y
11:40:56 <McManiaC> lol lambdabot has @. ?
11:40:56 <Itkovian> well, no but that was the sequence of the questions
11:40:59 <Itkovian> i am merely quoting
11:41:21 <McManiaC> how awesome is that? :)
11:41:30 <sipa> this awesome: <--------->
11:41:36 <McManiaC> \o/
11:41:49 <aristid> @pl \s -> lift (runReaderT s inner)
11:41:49 <lambdabot> lift . flip runReaderT inner
11:42:27 * ski . o O ( "this way >=={<--<}==> !" )
11:42:33 <aristid> @pl \s -> lift (runM inner s)
11:42:33 <lambdabot> lift . runM inner
11:42:38 <EvanR-work> for the frequency of using flip run*T, seems like they should have chosen a different parameter order
11:43:02 <ski>   foo `runState` s
11:43:33 <EvanR-work> great so you can put the runState all the way at the end of the inline action ;)
11:43:50 <ski>   > (`runState` 2) $ do x <- get; modify (^2); modify (x +); get
11:43:52 <EvanR-work> reminds of "COMEFROM"
11:43:53 <ski> > (`runState` 2) $ do x <- get; modify (^2); modify (x +); get
11:43:55 <lambdabot>   (6,6)
11:44:21 <EvanR-work> great now it looks like perl!
11:44:26 <EvanR-work> you cant win
11:44:28 * ski grins
11:44:56 <ski> @type runState
11:44:57 <lambdabot> forall s a. State s a -> s -> (a, s)
11:44:59 <ski> @type State
11:45:00 <lambdabot> forall s a. (s -> (a, s)) -> State s a
11:45:01 <sipa> > (`runState` 2) do x <- get; modify (^2); modify (x +); get
11:45:02 <lambdabot>   <no location info>: parse error on input `do'
11:45:05 <ski> @type State . runState
11:45:06 <lambdabot> forall s a. State s a -> State s a
11:45:09 <ski> @type runState . State
11:45:10 <lambdabot> forall s a. (s -> (a, s)) -> s -> (a, s)
11:45:31 <ski> imo, the type of `runState' is what it is, to make it possible to write those compositions
11:45:54 <Veinor> also, is abbreviating a <- l g; m a to m =<< l g in a do-block 'acceptable'?
11:45:54 <ski> though .. i wouldn't really mind if `runState' was renamed into `unState', and `runState' used the other argument order
11:45:58 <kmc> if i'm writing a type checker for System F, do i need to compare types up to alpha renaming of type variables?
11:46:06 <ski> Veinor : sure
11:46:12 <mreh> runState is just type foo
11:46:12 <roconnor> kmc: Likely
11:46:45 <Botje> Veinor: yeah.
11:46:50 <roconnor> kmc: forall a. a and forall b. b are the same types
11:46:57 <ski> Veinor : especially if you then say `x <- m =<< l g'
11:47:00 <Botje> it beats cluttering up the scope with extra variables
11:47:15 <Botje> pointy!
11:47:18 <mreh> would it be too hard to make a Monad instance of (s -> (s,a))?
11:47:29 <mauke> mreh: that has the wrong kind
11:47:42 <mreh> yes
11:47:43 <ski> mreh : impossible, under the current scheme (assuming `\a -> ' in front of it)
11:48:13 <mreh> that was a major sticking point in learning Monads for me, to see past the types
11:48:49 <ski> when `m a' is matched against `(->) s ((,) s a)', it insists on matching `m' against `(->) s', instead of doing proper higher-order unification/matching
11:49:14 <roconnor> (s ->) :o (s,)
11:49:32 <roconnor> (s ->) `O` (s,)
11:49:43 <ski> (which would alternatively match `m' to `\a -> a' and `\a -> (->) s ((,) a)', not just `(->) s')
11:50:19 * ski wonders if it would be feasible to get some kind of L-lambda unification (or similar) into Haskell's type system
11:51:17 <ski> (i suppose it would probably introduce a lot more ambiguity, in any case)
11:51:35 <ski> (or at least some more .. not sure how much)
11:57:18 <ddarius> ski: There has been at least one proposal to do something like that.
11:57:39 <ski> any name ?
11:59:18 <Hous> Hi
11:59:36 * Veinor is writing haddock documentation, whee!
11:59:37 <Hous> someone's french ?
11:59:52 <mreh> is there a french haskell channel?
12:00:17 <EvanR-work> no i dont think there are any french people anymore
12:00:29 <Botje> aren't they all striking? :)
12:00:30 <Hous> lol
12:00:45 <Veinor> je parle un petit peu francais, mais je prefere l'anglais
12:01:01 <mreh> you prefer english?
12:01:15 <Veinor> yeah, it's my native language :P
12:01:19 <ski> mreh : possibly #haskell.fr
12:01:23 <wlangstroth> who prefers English?
12:01:24 <ddarius> @google "Type classes with more higher-order polymorphism"
12:01:27 <wlangstroth> that's crazy
12:01:28 <lambdabot> http://portal.acm.org/citation.cfm?id=581496
12:01:28 <lambdabot> Title: Type classes with more higher-order polymorphism
12:01:34 <EvanR-work> speak in haskell
12:02:30 <sipa> moi je parle aussi un peu de francais, mais mon anglais est mieux :)
12:03:16 <wlangstroth> bien sur
12:04:03 * ski . o O ( inte prata utrikiska ! )
12:06:58 <edlinde> is there a concept of a value in haskell
12:07:09 <edlinde> like in ML you can say something like --> val x = 120
12:07:19 <sipa> x = 5
12:07:23 <ddarius> Everything is a value.
12:07:45 <edlinde> I just typed x = 5 on ghci and it gave me an error
12:07:50 <Nibble> edlinde: let x = 5
12:07:51 <sipa> not in ghci
12:07:57 <dolio> ML does that, presumably, due to the value restriction. It has to distinguish values from functions.
12:08:08 <cts> Hey, everything is a function, isn't it?
12:08:11 <edlinde> ok done
12:08:12 <edlinde> thx
12:08:13 <pumpkin> cts: NO!
12:08:14 <ddarius> cts: No.
12:08:19 <sipa> 5 is not a function
12:08:23 <wlangstroth> right, in ghci, let x = 5
12:08:29 <pumpkin> unless you want to see everything as a morphism from the initial object
12:08:32 <Nibble> everything has a type, more correct
12:08:34 <ddarius> > 5 ()
12:08:35 <lambdabot>   5
12:08:35 <ski> > 5 2
12:08:36 <lambdabot>   Ambiguous type variable `t' in the constraint:
12:08:36 <lambdabot>    `GHC.Num.Num t' arising f...
12:08:48 <ddarius> pumpkin: Terminal.
12:08:48 <dolio> Well, 5 is sort of a function. From dictionaries to values.
12:09:02 <pumpkin> ddarius: oh yeah :)
12:09:03 <sipa> dolio: true, but not completely on the expression level
12:09:08 <dolio> Yeah.
12:09:12 <wlangstroth> pumpkin: then what do you call the initial object?
12:09:15 <conal>  @where+ everything-is-a-function http://conal.net/blog/posts/everything-is-a-function-in-haskell/
12:09:23 <pumpkin> wlangstroth: _|_ ?
12:09:26 <pumpkin> I was wrong though
12:09:37 <ski> edlinde : per default, you get a declaration corresponding to `val' and `fun' if you don't start with any special keyword
12:09:40 <pumpkin> (the empty type, which isn't empty in haskell)
12:09:41 <conal> @where everything-is-a-function
12:09:42 <lambdabot> I know nothing about everything-is-a-function.
12:09:48 <dolio> Haskell has no initial object, really.
12:09:58 <ski> (or rather `val rec' and `fun', i suppose)
12:10:01 <conal> hm. did i mess up the @where+ command?
12:10:03 <edlinde> ski: ok get you
12:10:12 <dolio> conal: You put a check mark in front of it.
12:10:16 <dolio> At least, that's how it looks here.
12:10:19 <EvanR-work> will people stop feeding conal 
12:10:23 <edlinde> I find a lot of things are very similar
12:10:23 <conal> wow
12:10:24 <ski> edlinde : and *everything* is mutually recursive
12:10:26 <edlinde> which is good
12:10:33 <pumpkin> wlangstroth: but try in agda and you get a real initial object
12:10:47 <EvanR-work> everything is obviously not a function, numbers are especially not functions
12:10:48 <wlangstroth> I *was* going to say "and everything is a function", but I've done enough evil today
12:11:00 <edlinde> ski: in ML for mutual recursion you have to use the "and" keyword between function declarations
12:11:03 <ski> everyfunction is a thing
12:11:13 <conal> @where+ everything-is-a-function http://conal.net/blog/posts/everything-is-a-function-in-haskell/
12:11:15 <ddarius> > ord ' '
12:11:16 <lambdabot>   32
12:11:19 <conal> dolio: thx!
12:11:20 <ski> edlinde : yes, i know :)
12:11:21 <edlinde> ski: do you have to do something of that sort in Haskell? Or you saying its done automatically?
12:11:24 <dolio> conal: That also had a check mark.
12:11:25 <ddarius> Just looks like he has a blank here.
12:11:29 <sipa> the special thing is that every function is a value, not that every value is a function
12:11:31 <conal> oh, weird.
12:11:32 * pumpkin sees no check mark
12:11:34 <wlangstroth> pumpkin: I have yet to try anything in agda, but starting at the initial object seems appropriate
12:11:35 <benmachine> strings and numbers can be functions, but character literals can't (yet)
12:11:35 <ski> edlinde : automatic, and you can't avoid it
12:11:38 <ddarius> dolio is insane.
12:11:43 <edlinde> ski: hmm ok
12:11:55 <dolio> @where everything-is-a-function
12:11:55 <lambdabot> I know nothing about everything-is-a-function.
12:11:59 <dolio> So is lambdabot.
12:12:02 <pumpkin> wlangstroth: no, the initial object is the empty type, so you have a unique function _|_ -> a for any a
12:12:04 <edlinde> ski: I don't see anything going wrong coz of that :)
12:12:04 <EvanR-work> benmachine: if character literals are enumerated, then can
12:12:09 <edlinde> ski: I hope so
12:12:11 <conal> would someone else please try?  i don't trust my irc client
12:12:12 <benmachine> EvanR-work: wat
12:12:14 <ski> edlinde : you can shadow, though, like `let x = 0 in let y = x+1 in let x = y+y+y in ..x..y..'
12:12:20 <sipa> conal: tryh
12:12:20 <pumpkin> wlangstroth: a terminal object is any singleton set
12:12:25 <wlangstroth> pumpkin: is your humour chip malfunctioning again?
12:12:26 <sipa> @where+ everything-is-a-function http://conal.net/blog/posts/everything-is-a-function-in-haskell/
12:12:26 <lambdabot> Good to know.
12:12:33 <pumpkin> wlangstroth: probably :)
12:12:34 <edlinde> ski: yeah same in ML too
12:12:36 <EvanR-work> benmachine: data Char = Char Integer
12:12:38 <edlinde> you can shadow there
12:12:50 <conal> @where everything-is-a-function
12:12:50 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell/
12:12:50 <dolio> 
12:12:52 <edlinde> nested lets is allowed I believe
12:13:03 <sipa> edlinde: yes
12:13:07 <conal> sipa: thx.
12:13:08 <benmachine> EvanR-work: character literals still can't be functions
12:13:10 <ski> (edlinde : hehe, i have used SML a little, so i know this well)
12:13:12 <sipa> (let a in b) is just an expression
12:13:15 <Veinor> 15:08:33   <Hous> http://pastebin.com/zGcJ0a9S
12:13:22 <pumpkin> omg a Veinor 
12:13:23 <edlinde> ski: I know you do :)
12:13:24 <ski> (well, SML some, and O'Caml a little)
12:13:24 <EvanR-work> benmachine: why not
12:13:27 <Veinor> pumpkin: :o
12:13:34 <benmachine> EvanR-work: because 'x' () is never well-typed
12:13:48 <Veinor> so... hm. Hous: what do you want a value of type OCL to represent, a constraint?
12:13:49 <EvanR-work> why is 4 f well typed
12:13:59 <benmachine> EvanR-work: because of instance Num (a -> b)
12:14:06 <EvanR-work> >_<
12:14:15 <benmachine> and ghc does overloadedstrings
12:14:18 <benmachine> but not overloadedchars :P
12:14:31 <EvanR-work> i dont like where this ship is going!
12:14:40 <EvanR-work> :t 'a'
12:14:41 <lambdabot> Char
12:14:42 <benmachine> it should do overloadedlists, and overloadedunits >_>
12:14:45 <benmachine> overloadedtuples
12:14:46 <EvanR-work> ^ good
12:14:51 <ddarius> There's a preprocessor to give you overloaded whitespace.
12:14:59 <benmachine> overloadedextensions
12:15:08 <Veinor> overloadedoverloading
12:15:10 <Veinor> ddarius: wha?
12:15:17 <benmachine> overninethousand
12:15:18 <ski> @type case 'a' of GHC.Exts.C# a -> a
12:15:18 <benmachine> etc.
12:15:19 <lambdabot> GHC.Prim.Char#
12:15:23 <ski> @. kind type case 'a' of GHC.Exts.C# a -> a
12:15:24 <lambdabot> #
12:15:37 <edlinde> ski: there are slight differences like in ML @ means to append, while in Haskell it seems to mean an "as" construct like X as x::xs?
12:15:37 <EvanR-work> fix (\x -> "over"++x++"loaded")
12:15:39 <EvanR-work> > fix (\x -> "over"++x++"loaded")
12:15:41 <lambdabot>   "overoveroveroveroveroveroveroveroveroveroveroveroveroveroveroveroveroverov...
12:15:48 <edlinde> ski: things I got to keep track of
12:15:50 <ski> edlinde : yes
12:16:04 <ibt> what's up with hpaste?
12:16:17 <EvanR-work> ML must have more than slight differences to haskell
12:16:34 <sipa> > case "abc" of x@(a:b) -> "x="++ show x ++" a="++ show a ++ " b=" ++ show b
12:16:35 <lambdabot>   "x=\"abc\" a='a' b=\"bc\""
12:16:55 <sipa> > case "abc" of x@(a:b) -> "x="++ x ++" a="++ a ++ " b=" ++ b
12:16:56 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:16:56 <lambdabot>         against inferred type...
12:17:03 <sipa> > case "abc" of x@(a:b) -> "x="++ x ++" a="++ [a] ++ " b=" ++ b
12:17:04 <lambdabot>   "x=abc a=a b=bc"
12:17:17 <aristid> > printf "%d" 4 :: String
12:17:18 <lambdabot>   "4"
12:17:24 <identity> ibt: hpaste has a nasty habit of going down
12:17:36 <identity> hmm
12:17:37 <ski> edlinde : also, constructors always start with a upper case letter (or with `:' if it is an infix symbol operator), and variables always start with lower case (or `_') (or with "symbols", except `:', if it is an infix symbol operator)
12:17:46 <identity> > printf "%d" 4 :: Maybe String
12:17:47 <lambdabot>   No instance for (Text.Printf.PrintfType
12:17:47 <lambdabot>                     (Data.Maybe.May...
12:17:51 <identity> ah
12:17:55 <aristid> > case "abc" of x@(a:b) -> printf "x=%s a=%c b=%s" x a b
12:17:56 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:17:56 <lambdabot>    `GHC.Show.Show a'
12:17:57 <lambdabot>      a...
12:18:02 <aristid> > case "abc" of x@(a:b) -> printf "x=%s a=%c b=%s" x a b :: String
12:18:03 <lambdabot>   "x=abc a=a b=bc"
12:18:11 <ski> EvanR-work : the type system is similar to Haskell98 minus the type classes
12:18:19 <edlinde> ski: ok thanks
12:18:45 <edlinde> ski: so you call function clauses --> guards?
12:18:49 <edlinde> its the same thing?
12:18:55 <edlinde> just the | yeah?
12:18:56 <ibt> identity: so much for haskell
12:19:00 <EvanR-work> ski: so no monads, so no monadic IO, so arbitrary side effects?
12:19:07 <ski> guards is when you have `| ..condition..', yes
12:19:24 <ski> i believe O'Caml has `with', or something like that
12:19:45 * ski often call definition clauses "(defining) equations"
12:19:48 <edlinde> ski: hmm I notice that you don't say ...   fun  fname pat1 = ... | fname pat2 
12:19:52 <sipa> ski: yes, for type variables, no?
12:19:55 <identity> ibt: I refuse to blame it on haskell(Does it run on Haskell?) and I blame it on it being the victim of concentrated cosmic rays due to its data center being positioned under a magical weakspot in the atmosphere.
12:20:17 <ski> sipa : sorry, what was that in response to ?
12:20:18 <edlinde> ski: like you don't repeat the function name in the | clauses
12:20:20 <benmachine> EvanR-work: you don't need type classes for purity
12:20:33 <sipa> ski: something i misread :)
12:20:35 <benmachine> EvanR-work: you'd have a function called bindIO :: IO a -> (a -> IO b) -> IO b
12:20:35 <benmachine> sorted
12:20:36 <ski> edlinde : oh, `|' in SML is very different from `|' in Haskell
12:20:41 <dolio> It also lacks higher-order kinds, which is kind of annoying.
12:20:44 <ski> @src length
12:20:44 <lambdabot> Source not found.
12:20:45 <EvanR-work> benmachine: ah 
12:20:49 <ski> @src take
12:20:50 <lambdabot> take n _      | n <= 0 =  []
12:20:50 <lambdabot> take _ []              =  []
12:20:50 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:20:52 <edlinde> ski: actually I just noticed
12:20:53 <EvanR-work> benmachine: of course i figured there were other ways
12:20:53 <ibt> identity: :)
12:20:54 <ddarius> :k Mu
12:20:55 <lambdabot> (* -> *) -> *
12:21:01 <benmachine> EvanR-work: it's much uglier and less generic which is why no-one does it >_>
12:21:02 <ski> the `| n <= 0' there is a guard
12:21:07 <benmachine> but in principle it's possible
12:21:12 <edlinde> ski: it seems like | is for a boolean predicate huh
12:21:20 <ski> yes
12:21:20 <sipa> edlinde: it is
12:21:25 <edlinde> hmm ok
12:21:30 <sipa> what's it for in ML?
12:21:43 <benmachine> you can simulate type-classes with records of functions, but it's a little crude
12:21:50 <Hous> Here is my problem : http://pastebin.com/90CbgvKn , the comments explain what i want to do 
12:21:50 <ski> edlinde : if the condition is false, the next guard is tried, or if there is no more guard on the current equation/clause, the next one is tried
12:21:54 <edlinde> for giving alternate pattern matching in your function clauses
12:22:03 <edlinde> ok
12:22:15 <sipa> ah right, i don't think haskell has that
12:22:15 <edlinde> so it seems like the | of ML is basically just ommited in Haskell
12:22:19 <ski>   fun length [     ] = 0
12:22:21 <ddarius> Make nice syntax for the Reader monad and then all other monads follow.
12:22:32 <ski>     | length (_::xs) = 1 + lenth xs
12:22:32 <edlinde> you basically just write out the patterns for the function one after the other
12:22:40 <ski> sipa : ^
12:22:47 <pumpkin> @pl uncurry parse <=< fmap (first f) . parse t
12:22:47 <lambdabot> (line 1, column 34):
12:22:47 <lambdabot> unexpected "."
12:22:48 <lambdabot> expecting variable, "(", "!!", space, operator or end of input
12:22:48 <lambdabot> ambiguous use of a right associative operator
12:22:57 <EvanR-work> benmachine: the way you just described is basically monads without type classes
12:22:58 <identity> Hous: filter ((< 18) . age) listOfPersons
12:23:04 <benmachine> EvanR-work: right
12:23:05 <pumpkin> @unpl uncurry parse <=< fmap (first f) . parse t
12:23:06 <lambdabot> (\ c -> ((uncurry parse) <=< (fmap (first f))) (parse t c))
12:23:13 <pumpkin> @@ @pl @unpl uncurry parse <=< fmap (first f) . parse t
12:23:14 <lambdabot>  (uncurry parse <=< fmap (first f)) . parse t
12:23:15 <benmachine> EvanR-work: that was my aim :P
12:23:22 <EvanR-work> benmachine: im guess ML doesnt do it like that xD
12:23:29 <benmachine> yeah ML is impure I think
12:23:36 <ddarius> Yes.
12:23:41 <edlinde> ski: the guard seems to be almost like a case statement huh?
12:23:43 <Hous> identity, i have to define a list of persons first ?
12:23:46 <ddarius> There are monad libraries in ML though.
12:23:48 <identity> Hous: Yes.
12:23:51 * ski idly wonders whether LML was impure ..
12:24:02 <EvanR-work> ML is strict?
12:24:08 <ddarius> Yes.
12:24:11 <ski> edlinde : you can use guards in `case' expressions as well
12:24:12 <conal> pumpkin: (result.fmap.first) f (parse t)
12:24:16 <EvanR-work> i guess that makes reasoning about side effects easier
12:24:18 <edlinde> ski: ok
12:24:21 <pumpkin> I reduced it to uncurry (parse . f) <=< parse t
12:24:47 <identity> Hous: Well, I may have misunderstood, but that seems like what you want to do
12:25:03 <ski> > case (42,"x") of (0,_) -> "zero"; (n,_) | n < 10 -> "foo"; (_,s) -> s
12:25:03 <lambdabot>   "x"
12:25:10 <pumpkin> conal: those combinators of yours should go into a standard library :)
12:25:25 <dolio> It's called category-extras.
12:25:28 <pumpkin> lol
12:25:28 <Hous> identity, thank you, i already know this fonction filter, but how can I make the (<18) becoming a variable ? So that the user can type directly the following line :  "Forall Person age<16"
12:25:30 <dolio> And they're all named foomap.
12:25:44 <pumpkin> I'd like category-extras to be split up some more
12:25:49 <pumpkin> I know edwardk was planning to
12:25:53 <conal> also DeepArrow.  also TypeCompose
12:26:25 <edlinde> but it does seem like Haskell has a lot of syntax to remember
12:26:31 <pumpkin> a lot of syntax?
12:26:32 <pumpkin> :O
12:26:35 <edlinde> will take some time to remember all that stuff
12:26:38 <EvanR-work> edlinde: never!
12:26:48 <pumpkin> I wonder how many keywords haskell has
12:26:50 <identity> > let lessThan18 = (< 18) in filter lessThan18 [1,10,16,100,3,17,14,42] -- Truly random numbers :P
12:26:51 <lambdabot>   [1,10,16,3,17,14]
12:26:51 <edlinde> yeah theres lots of rule
12:26:53 <edlinde> rules
12:26:58 <pumpkin> edlinde: really?
12:26:59 <identity> Hous: Is that what you mean?
12:27:07 <edlinde> if using guards then don't put a = behind the function
12:27:12 <edlinde> things like that
12:27:19 <dstcruz> is there anyway of doing pre/post conditions in haskell?
12:27:23 <edlinde> if you use a list and say [20..1] it wont work
12:27:24 <sipa> class, instance, deriving, type, data, import, module, ...
12:27:30 <sipa> any more keywords?
12:27:31 <EvanR-work> > [20..1]
12:27:32 <lambdabot>   []
12:27:36 <edlinde> you got to say [20,19..]
12:27:36 <EvanR-work> it worked
12:27:42 <identity> Hous: The problem is that your code isn't valid haskell for the most part so it's hard to say what you're trying to do.
12:27:43 <edlinde> sorry
12:27:52 <edlinde> [20,19..1]
12:27:55 <EvanR-work> [x..y] and [x,y..z] are syntactic sugar
12:28:02 <EvanR-work> you should learn whats syntactic sugar
12:28:12 <EvanR-work> :t enumFromTo
12:28:13 <lambdabot> forall a. (Enum a) => a -> a -> [a]
12:28:16 <ski> edlinde : well, one `=' for each guard on a single equation (using `->' instead if it's in a `case')
12:28:18 <identity> [x .. y] is enumFromTo right?
12:28:19 <identity> oh.
12:28:20 <identity> yeah
12:28:32 <benmachine> edlinde: there's a cheat sheet somewhere around that can be useful
12:28:33 <identity> > enumFromTo 5 1
12:28:34 <lambdabot>   []
12:28:48 <ski> > enumFromThenTo 5 4 1
12:28:49 <lambdabot>   [5,4,3,2,1]
12:28:49 <identity> How is [20, 19 ..] implemented?
12:28:50 <edlinde> benmachine: I think someone pasted that last night
12:28:53 <identity> aah.
12:28:53 <ddarius> ski: It looks like it used stream IO but had exceptions.  It doesn't look like it had mutation.
12:28:55 <ski> > enumFromThen 5 4
12:28:56 <lambdabot>   [5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18...
12:28:57 <edlinde> I can use it while coding
12:29:01 <identity> :t enumFromThenTo
12:29:02 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
12:29:07 <Olathe> > let f (x:xs) = flip (case x of { '<' -> (<); '=' -> (==); '>' -> (>) }) (read xs :: Integer) in map (f ">16") [15..17]
12:29:08 <lambdabot>   [False,False,True]
12:29:15 <benmachine> edlinde: wrt the guards thing, you can think of it as, when you're going through a function definition you pass one equals sigh
12:29:18 <identity> > enumFromThen 10 8 0
12:29:19 <benmachine> *sign
12:29:19 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[t2]'
12:29:26 <ski> ddarius : the `Dialogue' thing ?
12:29:28 <identity> > enumFromThenTo 10 8 0
12:29:29 <lambdabot>   [10,8,6,4,2,0]
12:29:34 <benmachine> edlinde: you need an equals on each guard, so there isn't one at the top
12:29:35 <edlinde> at the moment I am just going through the learn you a haskell tutorial
12:29:38 * pumpkin tries to figure out what he wanted from (a -> f b) -> (b -> f a) -> f a -> f b
12:29:56 <edlinde> yeah I get it.... but its certainly something to remember when starting to code
12:30:01 <identity> @src enumFromTo
12:30:01 <lambdabot> Source not found. Sorry.
12:30:23 <benmachine> pumpkin: you wanted to know what it was called, I vaguely remember >_>
12:30:36 <ski> edlinde : just ask, if you wonder about anything more with Haskell vs. the MLs
12:30:37 <pumpkin> benmachine: I wanted to know if anyone had named it and if so, where
12:30:38 <pumpkin> :P
12:30:43 <benmachine> oh
12:30:47 <pumpkin> now I'm trying to figure out why I was wondering that
12:30:50 <Hous> identity, age<18 is just an example, the user will type : "Forall Person age<18" or "Forall Person name=Houss", i just want to stock the predicate gived by the user in "Pred"
12:30:52 <edlinde> ski: sure thing
12:30:53 <benmachine> hah
12:31:27 <pumpkin> it's really (a -> f b) -> (b -> f a) -> (f a <-> f b) where <-> is a pair of functions
12:31:36 <ski> Hous : is `Forall Person age<18' supposed to be Haskell code, or some arbitrary user string input, that you will parse ?
12:31:41 <benmachine> that's just bind twice, isn't it?
12:31:41 <identity> Hous: Then you will need to parse the input from the user to realize what he's asking
12:32:03 <milaz> Hi all!
12:32:23 <ski> pumpkin : biimplication/equivalence, or isomorphism ? (or retract situtation, (but i doubt it) ?)
12:32:32 <ddarius> ski: As far as I can tell, stdin was reified as a (presumably lazy) string and the top-level was a string that would be displayed.
12:32:38 <EvanR-work> edlinde: also forget the syntax for list comprehensions, they are useless ;)
12:32:56 <pumpkin> ski: isomorphism, I was hoping
12:32:57 <edlinde> EvanR-work: never remembered them so much anyway
12:33:05 <sipa> Hous: let me change it to what i think you want
12:33:06 <EvanR-work> and n+k patterns
12:33:09 <ski> ddarius : ok .. even simpler than `type Dialogue = [Response] -> [Request]', then
12:33:27 <dstcruz> EvanR-work: you suggest using guards instead of list comprehensions?
12:33:32 <Hous> sipa u can ?
12:33:37 <EvanR-work> dstcruz: for what?
12:33:44 <dstcruz> EvanR-work: just in general
12:33:48 * ski suggests an `n*k + l' pattern to EvanR-work
12:33:53 <EvanR-work> in general i dont use LC
12:34:13 <milaz> Sorry for dumb question, I want to repeat some IO action for a reasonable amount of times. Is replicateM_ suitable for that?
12:34:13 <EvanR-work> what on earth ski is that
12:34:26 <sipa> Hous: this 'Set' type is supposed to be something that represents a set of persons?
12:34:32 <edlinde> can someone explain how this works
12:34:33 <edlinde> initials :: String -> String -> String  
12:34:34 <edlinde> initials firstname lastname = [f] ++ ". " ++ [l] ++ "."  
12:34:34 <edlinde>     where (f:_) = firstname  
12:34:34 <edlinde>           (l:_) = lastname 
12:34:40 <Hous> sipa yes
12:34:46 <Hous> exactly
12:34:49 <edlinde> I understand the where bit is doing a pattern match
12:35:03 <ski> EvanR-work : `k' must be a literal, `l' will become the least natural number less than `k' such that the pattern matches
12:35:10 <edlinde> ah I get it... never mind
12:35:12 <edlinde> :)
12:35:12 <EvanR-work> edlinde: its basically doing head firstname and head lastname
12:35:18 <edlinde> yeah
12:35:26 <dstcruz> edlinde: remember that String = [Char]
12:35:31 <edlinde> I was confused by the [f] ++ ... stuff
12:35:44 <edlinde> its just converting f back to a list to append the rest on yeah?
12:35:47 <EvanR-work> ski: wheres n then
12:35:52 <dstcruz> edlinde: yeah
12:36:05 <edlinde> ok
12:36:44 <dstcruz> that would be the same as: [f] ++ ['.', ' '] ++ [l] ++ ['.']
12:36:45 <ski> edlinde : `foo p ... = e where d' is basically like `fun p ... = let d in e end', except that conditions in guards can use variables bound in `where' (and so you can make the guard fail and the next guard/equation be tried)
12:36:50 <EvanR-work> edlinde: warning that function doesnt work on some input, crashes ;)
12:36:52 <Olathe> initials (f:_) (l:_) = f:'.':' ':l:"."
12:37:08 <sipa> Hous: what does the s on line 10 refer to?
12:37:25 <ski> EvanR-work : matching `x' with `n * k + l' is the same as matching `divMod n k' with `(n,l)'
12:37:50 <Hous> sipa to the set
12:37:56 <Hous> it's an error :s
12:37:56 <EvanR-work> ski: did you mean to use the letter n somewhere in your explanation earlier
12:38:22 <ski> i figured you'd determine what `n' would be yourself :)
12:38:44 <ski> (to make the pattern cohere, as an expression)
12:38:44 <sipa> Hous: http://pastebin.com/xqwpwp1h
12:38:54 <edlinde> let bindings don't span across guards?
12:38:57 <edlinde> but the where does?
12:39:01 <ski> right
12:39:06 <edlinde> hmm 
12:39:11 <EvanR-work> ski: so n and l are variables?
12:39:16 <EvanR-work> as in (n,l)
12:39:23 <EvanR-work> use said l was a literal
12:39:28 <ski> edlinde : `let' forms an expression, while `where' attaches to equations/clauses
12:39:30 <edlinde> I think I would be inclined to use a let and a case statement
12:39:31 <edlinde> :)
12:39:42 <ski> EvanR-work : `n' and `l' being any patterns, yes
12:39:47 <sipa> edlinde: (let a = c in b) is an expression in which every occurence of a in b is replaced by c
12:40:05 <ski> EvanR-work : no, i said `k' is a literal
12:40:06 <sipa> "replaced" is not the correct word, it should be 'refers to the same value as'
12:40:09 <EvanR-work> oh
12:40:23 <EvanR-work> sipa: semantically replaced
12:40:24 <edlinde> sipa: or bound in that expression
12:40:30 <EvanR-work> like if you were calculating it on paper
12:40:31 <edlinde> :)
12:40:44 <sipa> edlinde: yes, but it has no effect whatsoever outside of c
12:40:47 <EvanR-work> or a very simple graph reducer ;)
12:40:47 <sipa> eh b
12:40:52 <ski> edlinde : `let <decl>; ... in <expr>' corresponds to `let <decl>; ... in <expr> end', of course
12:41:14 <edlinde> yep get that
12:41:50 <edlinde> you could do a let <expr>, variables etc in  case x of ... 
12:42:04 <edlinde> would amount to the same thing as the guard/where syntax ?
12:42:28 <edlinde> or did I miss something?
12:42:32 <ski> it wouldn't
12:42:39 <sipa> not really, but you could still use a guard in the case
12:43:01 <ski> edlinde : the declarations inside the `where' can refer to the variables bound by the patterns in the definition equations
12:43:22 <EvanR-work> dont mix let and where1
12:43:49 <ski> @src scanr
12:43:49 <lambdabot> scanr _ q0 []     =  [q0]
12:43:49 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
12:43:49 <lambdabot>     where qs@(q:_) = scanr f q0 xs
12:44:02 <Hous> sipa it seems to be what i need  but i have to precise an example in haskell ( age<18) verifying this, and what means the $ before map ?
12:44:11 <ski> here `f',`q0',`xs' is used in the `where'-clause
12:44:31 <sipa> Hous: "and $ map f persons" is the same as "and (map f persons)", just shorter
12:44:38 <Hous> ah
12:44:40 <Hous> cool
12:44:52 <edlinde> ok
12:44:54 <ski> Hous,sipa : or just `all f persons' :)
12:45:02 <ski> > all even [0,2,4,6]
12:45:03 <lambdabot>   True
12:45:06 <ski> > all even [0,2,4,5,6]
12:45:07 <lambdabot>   False
12:45:18 <ski> @src all
12:45:19 <lambdabot> all p =  and . map p
12:45:21 <ski> @src any
12:45:21 <lambdabot> any p =  or . map p
12:45:34 <sioraiocht> wait WHAT?
12:45:45 <pumpkin> sioraiocht?
12:45:49 <Jafet> @pl \f -> and . map f
12:45:49 <lambdabot> all
12:45:49 * ski peers around nerveously
12:46:01 <ski> sioraiocht : what What WHAT ?
12:46:11 <sipa> Hous: if p1 and p2 are persons, then "Forall [p1,p2] (Pred (\person -> age person > 18))" is an example
12:46:21 <sioraiocht> I'm just...surprised that all/any don't have recursive definitions
12:46:21 <pumpkin> samwell has something to say about what what
12:46:28 <pumpkin> sioraiocht: they don't need them!
12:46:35 <sioraiocht> @src and
12:46:36 <lambdabot> and   =  foldr (&&) True
12:46:39 <benmachine> sioraiocht: that's all done by and/map
12:46:46 <sioraiocht> -_-
12:46:49 <EvanR-work> sipa: because its defined in terms of something else
12:46:58 <sioraiocht> and you just TRUST the fusion machinery
12:47:00 <sioraiocht> interesting
12:47:02 <EvanR-work> @src map
12:47:03 <lambdabot> map _ []     = []
12:47:03 <lambdabot> map f (x:xs) = f x : map f xs
12:47:05 <djahandarie> Of course
12:47:06 <pumpkin> sioraiocht: foldr will short circuit magically!
12:47:14 <EvanR-work> @src foldr
12:47:15 <lambdabot> foldr f z []     = z
12:47:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:47:19 <pumpkin> sioraiocht: also, the lambdabot definitions aren't necessarily the ones in GHC :)
12:47:21 * sioraiocht does not trust the simplifier that much.
12:47:30 <Hous> i'll try this
12:47:34 <djahandarie> If we didn't trust fusion, Haskell would be much less practical of a language, imo
12:47:35 <EvanR-work> in abstraction we trust
12:48:00 <ski> @google "Abstracting Trust"
12:48:02 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
12:48:05 <sioraiocht> djahandarie: It's not about the semantics preservation 
12:48:20 <edlinde> ski: in learn you a h... is there going to be mention of how to setup tree structures in haskell, doing walks of the tree, etc?
12:48:24 <sipa> EvanR-work: ?
12:48:41 <ski> edlinde : i have never read LYAH, so i don't know :)
12:48:52 <edlinde> ski: ah ok
12:49:05 <edlinde> and I thought it was a "must read"
12:49:13 <EvanR-work> as easy as it sounds ive never built a tree or walked a custom tree yet
12:49:14 <edlinde> ski: have you read that Real world one?
12:49:14 <djahandarie> edlinde, not when you learned like 10 years before it was written
12:49:36 <EvanR-work> i use libraries that do it for me ;)
12:50:04 * ski learned from "Haskell: The Craft of Functional Programming" by Thompson (and from comp.lang.functional, and from hawiki and from #haskell :) some 10 years ago
12:50:10 <ski> edlinde : i have not
12:50:28 <edlinde> okie
12:50:44 <djahandarie> You know you're old when you learned something from usenet
12:51:45 <milaz> @src replicate
12:51:45 <lambdabot> replicate n x = take n (repeat x)
12:52:00 <milaz> @src take
12:52:00 <lambdabot> take n _      | n <= 0 =  []
12:52:00 <lambdabot> take _ []              =  []
12:52:00 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:52:08 <milaz> @src repeat
12:52:09 <lambdabot> repeat x = xs where xs = x : xs
12:52:26 * ski likes that definition of `repeat'
12:52:56 <stepkut> according to the haddock documention, I can hyperlink to an identifier that is not imported by giving the fully qualified name of the entity. But it doesn't seem to work for me when I do something like, see also: 'Foo.Bar.baz'. What am I doing wrong ?
12:52:57 * benmachine likes repeat x@(repeat -> xs) = x : xs for pure silliness
12:53:01 <sipa> is that more efficient than 'repeat x = x : repeat x' ?
12:53:09 <benmachine> sipa: I believe so yes
12:53:18 <ski> edlinde : btw, if you're wondering, sadly there is no `local <decls> in <decls> end' construct in Haskell :/
12:53:36 <edlinde> okie
12:53:38 <mercury^> sipa: yes.
12:53:44 <edlinde> I usually don't use local too much
12:53:54 <edlinde> I tend to just stick with helper functions
12:54:03 <edlinde> seems to work ok
12:54:07 <benmachine> sipa: it's the difference between calling repeat repeatedly and making a genuinely cyclic data structure
12:54:10 <ddarius> let ones@(head -> one) = 1:ones in one
12:54:14 <ddarius> > let ones@(head -> one) = 1:ones in one
12:54:14 <ski> benmachine : i would prefer `xs@(repeat x) = x : xs' ..
12:54:15 <lambdabot>   1
12:54:36 <benmachine> ski: haha o_o
12:54:39 <Twey> > fix ('x' :)
12:54:40 <milaz> so, the riddle is, why do I get stack overflow on replicateM_ in IO monad...
12:54:40 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
12:54:53 <Twey> repeat = fix . (:)
12:54:55 <benmachine> Twey: I like that it smiles at me
12:55:02 <Twey> Hehe
12:55:04 <EvanR-work> :t (:[])
12:55:05 <lambdabot> forall a. a -> [a]
12:55:11 <ski> benmachine : possibly `repeat x = xs @ (x : xs)' should be allowed, as well
12:55:47 <Twey> Meaning let xs = x : xs in xs?
12:55:51 <ddarius> repeat = concat . cycle, cycle = fix . (++), concat = foldr (++) [], (++) = flip (foldr (:))
12:56:07 <ski> s/,/;/
12:56:12 <EvanR-work> > (let xs = x : xs in xs) 6
12:56:13 <lambdabot>   Couldn't match expected type `t1 -> t'
12:56:13 <lambdabot>         against inferred type `[Simp...
12:56:29 <Twey> s/,/;/g
12:56:35 <EvanR-work> > (\x -> let xs = x : xs in xs) 6
12:56:35 <lambdabot>   [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,...
12:57:34 <benmachine> :t flip (foldr (:))
12:57:35 <lambdabot> forall a. [a] -> [a] -> [a]
12:57:49 <benmachine> oh right yes
12:58:09 <edlinde> hi guys, just a statement from my prof for this advanced FP course I will be taking soon --> I'll teach the programming languages Erlang, Lisp and Haskell, higher-order functions, lazy evaluation, communicating processes,
12:58:09 <edlinde> program as data (meta programming)
12:58:30 <edlinde> was wondering about the lazy evaluation, comm.. and meta programming bits
12:58:35 <Botje> makes sense
12:58:43 <edlinde> are these related to Haskell?
12:58:48 <EvanR-work> eww meta programing
12:58:49 <edlinde> I know lazy is
12:58:56 <Botje> haskell can do at least the first two
12:58:58 <djahandarie> lazy evaluation definitely is.
12:59:00 <djahandarie> And yeah
12:59:01 <EvanR-work> programming should already be meta
12:59:02 <Botje> not sure about metaprogramming
12:59:04 <Botje> does TH count?
12:59:06 <edlinde> hmm
12:59:24 <edlinde> maybe with the communicating processes he will mention Erlang
12:59:33 <edlinde> I want to stay away from Lisp
12:59:34 <ddarius> Botje: Yes.
12:59:38 <edlinde> :)
12:59:42 <djahandarie> Botje, yeah, that's what it is
12:59:45 <EvanR-work> haskell ghc concurrent runtime can communicate processes
12:59:53 <benmachine> communicating processes is basically what erlang is *for* isn't it? but haskell has nice things in that department too
12:59:53 <ddarius> All of them can be done in Haskell, though others more focus on some.
12:59:56 <benmachine> DSTM looks like fun
13:00:15 <edlinde> benmachine: yeah thats what I thought
13:00:18 <djahandarie> ddarius, you totally stole my idea for a Boston Haskell presentation ;)
13:00:35 <djahandarie> But that's okay, because you can do a far better job at it than I could possibly
13:01:01 <ddarius> djahandarie: ... Indeed... (*runs away*)
13:01:15 * djahandarie glares
13:01:21 <pumpkin> djahandarie: you coming?
13:01:31 <djahandarie> Yes, the date seems to work for me good
13:01:47 <pumpkin> two darii in one room!
13:01:48 <pumpkin> zomg
13:01:51 <djahandarie> So unless there is some sort of divine intervention
13:01:54 <djahandarie> lol
13:02:32 <zomg> pumpkin: <interactive>:1:0: Not in scope: `zomg'
13:02:42 <jmcarthur> it occurs to me that when you are using an embedded dsl in haskell, when you write more general haskell to manipulate a term of the dsl you are doing metaprogramming
13:02:43 <pumpkin> zomg!
13:03:08 <djahandarie> jmcarthur, wouldn't that make... a lot of things metaprogramming?
13:03:12 <jmcarthur> djahandarie: yes
13:03:22 <EvanR-work> thats what i mean
13:03:23 <djahandarie> zomg, wtf
13:03:24 <djahandarie> Damn it
13:03:25 <jmcarthur> but it fits the definition doesn't it?
13:03:35 <ski> > let (memo (0,12) -> fib) = \n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2) in fib 12
13:03:36 <lambdabot>   144
13:03:58 <EvanR-work> as soon as you stop worrying about where in an array to write a 32bit word, a lot of things are 'meta'
13:04:10 <djahandarie> jmcarthur, dunno, it's need to be a fairly loose version of the definition
13:04:14 <djahandarie> it'd*
13:04:28 <jmcarthur> EvanR-work: well, merely higher level programming isn't necessarily metaprogramming unless you view a library as a dsl, i think
13:04:57 <ddarius> djahandarie: Edward somewhat misinterpreted/mistated/missomething what I am aiming for, though I'll probably cover a bit of type level programming.
13:05:00 <jmcarthur> djahandarie: it's common to refer to the general languages as the "meta-language" in the context of the dsl at least
13:05:07 <EvanR-work> then i would say 'truely meta' isnt that useful, or 'too powerful'
13:05:08 <jmcarthur> *general language
13:05:24 <EvanR-work> source rewriting
13:05:55 <EvanR-work> $$ in php, macros in lisp
13:05:55 <djahandarie> jmcarthur, I guess if you're writing in "My Generic DSL" then Haskell would be metaprogramming, but we're writing in Haskell
13:06:02 <jmcarthur> djahandarie: would you say that "metaprogramming" as commonly used refers strictly to manipulating an AST?
13:06:17 <djahandarie> Pretty much
13:06:23 <ski> (self-modifying source programs, yay !)
13:06:26 <jmcarthur> i would agree
13:06:32 <jmcarthur> of course then we have to define "AST" i guess
13:06:40 <jmcarthur> gets very ambiguous
13:07:02 <djahandarie> ddarius, what is your presentation about then?
13:07:04 <monochrom> meta is when you press the alt key
13:07:17 <jmcarthur> monochrom is always so helpful
13:07:18 <benmachine> monochrom: and alt is when you press the meta key?
13:07:34 <benmachine> jmcarthur is always so unsarcastic
13:07:37 <monochrom> fortunately I don't have the meta key
13:08:06 <dolio> copumpkin: The version of bind you want doesn't arise in the same way as expfunctor.
13:08:08 <nus> (mutually modifiying source programs/interpreters) modifying humans
13:08:12 * ski has a keyboard with a Meta key ..
13:08:18 <ski> .. no Alt key, though
13:08:24 <copumpkin> dolio: yeah, it is rather ugly I realize, after playing with it for a while
13:08:27 <copumpkin> dolio: is there something more natural?
13:08:31 * Veinor is being productive!
13:08:35 * benmachine has a keybaord with a volume-up key and is a little embarassed about it
13:08:41 <copumpkin> Veinor: agda will accept you then
13:08:45 <EvanR-work> wow benmachine. wow
13:08:47 * ski is being conductive
13:08:56 * benmachine is being inductive
13:08:59 <Veinor> copumpkin: haha
13:09:08 <Veinor> copumpkin: I'm working on my oauth twitter library
13:09:09 <EvanR-work> induction on the conductive production
13:09:11 <ddarius> djahandarie: Typeful programming.  Enforcing invariants with types particularly in ways that would be unreasonable to do in a dynamically typed language.  So, for example, stuff like runST and Oleg's branding.  Also, stuff like type-directed code generation and similar things.
13:09:23 <dolio> Expfunctor comes from a category C', where objects are the same as C, and arrows are A <-> B = (A -> B) * (B -> A). Then map : (A <-> B) -> (F A -> F B).
13:09:23 <nus> EvanR-work, coproduction?
13:09:29 * milaz is being deductive
13:09:32 <ski> (benmachine : you should be ashamed, yes)
13:09:41 <dolio> Which can be turned into an endofunctor (A <-> B) -> (F A <-> F B).
13:09:42 <copumpkin> Veinor: in haskell? nice! I want something that deals nicely with the pagination and will allow me to ask for e.g., all followers of a given user
13:09:44 <djahandarie> ddarius, ah, okay, that is a little different... probably more useful too :)
13:09:57 <Veinor> copumpkin: well, there's also the problem that none of the other ones work
13:10:05 <Veinor> because they all use basic auth :D
13:10:07 <copumpkin> yeah
13:10:17 <dolio> But, if you write bind for a monad based on such an endofunctor, it's (A <-> F B) -> (F A <-> F B), which is (A -> F B) -> (F B -> A) -> (F A <-> F B)
13:10:21 <ski> dolio : arrows being isomorphims ? retract situations ? biimplications ?
13:10:29 <Veinor> but I think I've figured out oauth, I've successfully posted a tweet
13:10:35 <dolio> ski: Any two arrows in C with the right type.
13:10:38 <copumpkin> dolio: isn't that what I had?
13:10:42 <ski> ok, the latter, then
13:10:55 <copumpkin> dolio: oh I see
13:10:58 <dolio> copumpkin: I thought you had (A -> F B) -> (B -> F A) -> (F A <-> F B)
13:11:00 <copumpkin> yeah
13:11:48 <copumpkin> dolio: so (A <-> F B) -> (F A <-> F B) ?
13:12:12 <copumpkin> seems rather nice and symmetrical :P
13:12:13 <milaz> is this definition strict enough:
13:12:14 <milaz> strictInc !a = let !w = a + 1 in w `seq` w
13:12:16 <milaz> :)
13:12:27 <dolio> That would be a bind for such an endofunctor.
13:12:28 <copumpkin> w `seq` w never does anything
13:12:47 <benmachine> yeah w `seq` w means "when evaluating w, evaluate w"
13:13:06 <milaz> not evaluate w, then w?
13:13:10 <benmachine> actually it's an expression which is bottom if w is bottom, or w otherwise
13:13:19 <djahandarie> IIRC there is no enforced order
13:13:23 <djahandarie> You would need pseq for that
13:13:29 <copumpkin> dolio: damn, the issue is that now I can't write my instance :/
13:13:34 <benmachine> w `pseq` w probably still doesn't do anything
13:13:41 <copumpkin> I seem to have something closer to (a -> f b) -> (b -> a) -> f a -> f b
13:13:42 <benmachine> it's hard to imagine what it would do
13:13:50 <benmachine> unless it just hung which sounds unlikely
13:13:54 <milaz> ok, tht was overkill
13:14:03 <milaz> what about strictInc !a = let !w = a + 1 in w
13:14:14 <dolio> copumpkin: It's not clear to me how to get (a -> f b) -> (b -> f a) -> (f a -> f b).
13:14:14 <EvanR-work> + is already strict
13:14:27 <EvanR-work> (+1)
13:14:30 <Veinor> copumpkin: pagination?
13:14:58 <EvanR-work> (+1) 9 will be evaluated just as soon as strictInt 9
13:15:23 <copumpkin> Veinor: the API only gives you a fixed number of follows/followers/tweets at a time
13:15:31 <copumpkin> you have a method to request more "lazily"
13:15:58 <milaz> EvanR-work: so, when I'm writing somehting like foldr (+) 1 [1..1000000000] it's foldr that causes stack overflow, not +
13:15:59 <Veinor> ah
13:16:16 * Veinor will see what he can do :D
13:16:17 <ski> milaz : `let !w = ... in w' is still the same as `...'
13:16:22 <aristid> @hoogle raises
13:16:22 <lambdabot> No results found
13:16:37 <aristid> hoogle doesn't index monadLib?!
13:16:59 <ski> @type foldl'
13:17:00 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:17:04 <EvanR-work> milaz: right thats why theres foldl'
13:17:09 <ski> milaz : try using that ^ instead ?
13:17:47 <milaz> ski: so, I must impose strictness in consumer of (+1), not in it instead
13:18:02 <ski> > let !xs = 1:xs in xs
13:18:03 <lambdabot>   Recursive bang-pattern bindings aren't allowed:
13:18:04 <lambdabot>      { !xs = (GHC.Types.:) ...
13:18:06 <ski> bah !
13:18:52 <milaz> laziness requires such a hard work to wrap one's head around it...
13:18:54 <djahandarie> aristid, I think there can't be module conflicts in it
13:18:56 <Twey> Well, it would of course explode.
13:19:09 <EvanR-work> milaz: if youre trying to add up a bunch of numbers, use foldl', otherwise dont worry about strictness ;)
13:19:56 <copumpkin> "patch applied (ghc-7.0/testsuite): GHC 7.0 now rejects superclass equalities"
13:19:58 <copumpkin> lol
13:20:12 <dolio> > let xs = case xs of !ys -> 1:ys in xs
13:20:13 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
13:20:20 <copumpkin> "(rather than behaving inconsistently)"
13:20:22 <jmcarthur> superclass equalities?
13:20:38 <copumpkin> class (a ~ b) => Moo ...
13:20:38 <c_wraith> So does that mean type families are weaker again?
13:20:43 <jmcarthur> oh
13:20:51 <milaz> EvanR-work: in fact, I've almost understood fold... examples. I actually trying this: replicateM_ 4000000 $ modifyIORef' r (+1)
13:20:52 <jmcarthur> i thought that was implemented finally :(
13:20:53 <copumpkin> it means it was doing the wrong thing before but accepting them
13:21:08 <dolio> Wait, what?
13:21:19 <dolio> They turned it off again?
13:21:24 <jmcarthur> that sucks
13:21:25 <aristid> djahandarie: monadLib has no module conflicts with anything
13:21:37 <jmcarthur> so TF are not on par with FD yet again?
13:21:40 <benmachine> because it has silly names
13:21:48 <milaz> EvanR-work: I found out that replicateM_ 4000000 $ writeIORef r 1 doesn't cause stack verflow, while the former does...
13:21:50 <copumpkin> dolio: looks like it
13:21:52 <dolio> I thought I tried them and they worked.
13:21:57 <dolio> Like, actually worked.
13:22:01 <Veinor> @pl f x y z = g $ h x y z
13:22:02 <lambdabot> f = ((g .) .) . h
13:22:02 <copumpkin> the patch said they behaved inconsistently
13:22:09 <djahandarie> aristid, oh, probably jusy because lambdabot doesn't import it then
13:22:13 <djahandarie> just
13:22:16 <EvanR-work> milaz: write four million iorefs
13:22:16 <aristid> djahandarie: it was @hoogle
13:22:25 <EvanR-work> milaz: are you sure you dont want an array instead?
13:22:28 <djahandarie> aristid, which I think builds from what lambdabot imports
13:22:33 <aristid> djahandarie: it is totally mysterious to me what hoogle indexes
13:22:36 <copumpkin> Tue Oct 19 02:01:40 PDT 2010  simonpj@microsoft.com
13:22:36 <copumpkin>  * Reject programs with equality superclasses for now
13:22:37 <ski> @hoogle modifyIORef'
13:22:37 <lambdabot> No results found
13:22:44 <djahandarie> For now ;)
13:22:46 <aristid> @hoogle print
13:22:47 <lambdabot> Prelude print :: Show a => a -> IO ()
13:22:47 <lambdabot> System.IO print :: Show a => a -> IO ()
13:22:47 <lambdabot> module Text.Printf
13:22:48 <copumpkin> well yeah
13:22:56 <copumpkin> pretty sure TacticalGrace said it needed a change in core
13:22:58 <aristid> hmm
13:23:01 <milaz> EvanR-work: I thought it is just four million of assignments to one 'variable'
13:23:10 <aristid> hayoo is more flexible than that
13:23:12 <ski> Veinor : sometimes written as `f = g .:: h'
13:23:27 <jmcarthur> "for now" is reassuring :)
13:23:29 <djahandarie> aristid, I don't think even the online hoogle index indexes all of hackage
13:23:29 <EvanR-work> milaz: oh
13:23:31 <ski> (`(.::) = (.) . (.) . (.)')
13:23:33 <EvanR-work> milaz: so its even more useless ;)
13:23:34 <milaz> ski: sorry, that was plain modifyIORef, not one with prime
13:23:49 <jmcarthur> but still. i thought it had been declared "working"
13:23:53 <jmcarthur> oh well
13:24:06 * djahandarie prefers (...) and (.....), probably
13:24:09 <milaz> EvanR-work: right. It's how I'm trying to comprehend benchmarking of IO on Haskell
13:24:22 <EvanR-work> thats a pretty bad benchmark of IO because its not really IO
13:24:51 <EvanR-work> iorefs arent external
13:24:53 <Veinor> copumpkin: for the public timeline, should I just grab out username/tweet, or should I just return the raw JSON?
13:25:13 <Veinor> well... technically right now it's returning the raw Response, which contains headers and JSON
13:25:21 <milaz> It had file IO in previous iteration, but since I didn't figure out a lot about it, I tried to substitute it with some dumber action
13:25:29 <EvanR-work> milaz: try writing four million '1's to a file 
13:25:35 <copumpkin> Veinor: not sure :)
13:25:49 <milaz> EvanR-work: that's exactly what I did before :)
13:26:07 <Veinor> I feel like maybe there should be raw versions of each function
13:26:13 * ski tries to imagine an OS where `writeFile' would be lazy ..
13:26:13 <EvanR-work> thats the dumbest IO i know of
13:26:37 <Veinor> or... maybe I should write a thing that tkaes the JSON and packages it into Tweet objects
13:26:48 <EvanR-work> milaz: you would probably get better performance from writing ByteStrings though, rather than [Char]
13:26:50 <milaz> EvanR-work: but in this case, if buffering is not working, I'll get huge IOWait that will distort the benchmark.
13:26:55 <djahandarie> @hoogle (a -> b) -> ((a -> b) -> c -> d) -> c -> d
13:26:56 <lambdabot> No results found
13:26:57 <JoeyA> I think such an IO would have to be implemented at the file system and OS level, too.
13:27:15 <EvanR-work> milaz: benchmarks are meant to be distorted ;)
13:27:24 <ski> djahandarie : `flip ($)' ?
13:27:25 <milaz> To files, one should write blocks sized about one disk sector, 512 bytes.
13:27:39 <djahandarie> @hoogle (a -> b) -> (c -> d) -> (b -> c) -> a -> d
13:27:39 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
13:27:39 <lambdabot> Control.Parallel.Strategies (.||) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
13:27:39 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
13:27:49 <djahandarie> ski, yeah
13:28:00 <milaz> JoeyA: in fact, I dream of GC hardwired into OS :)
13:28:02 <EvanR-work> milaz: yeah so bytestring of length 512
13:28:10 <djahandarie> This one being (. f) . (g .)
13:28:23 <EvanR-work> but in real life no one manually splits it into 512 byte chunks
13:28:36 <djahandarie> Just wondering if a library somewhere has defined symbol operators for these functions
13:28:50 <jmcarthur> ski: you could consider writeFile to be lazy in that on some filesystems it waits to be forced by a filesystem sync later, perhaps
13:29:05 <milaz> EvanR-work: ok. This test was to check if I do something wrong with monads by itself, like replicateM nstead of replicateM_
13:29:11 <jmcarthur> but technically the writeFile action performs some IO anyway, even if its only to push the data to some sort of queue
13:29:17 <jmcarthur> *it's
13:29:21 <EvanR-work> milaz: are you using -O2
13:29:41 <milaz> EvanR-work: no
13:29:47 <ski> @type \h f -> (h .) . (. f)
13:29:48 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => (b1 -> b) -> f a -> (a -> b1) -> f b
13:29:54 <EvanR-work> well remind me not to use your benchmarks as reference ;)
13:30:00 <ski> @type let (.) = (Prelude..) in \h f -> (h .) . (. f)
13:30:01 <lambdabot> forall c a b c1. (c1 -> c) -> (a -> b) -> (b -> c1) -> a -> c
13:30:19 <ski> @type let (.) = (<<<) in \h f -> (h .) . (. f)
13:30:20 <lambdabot> forall (cat :: * -> * -> *) b c a b1. (Control.Category.Category cat) => cat b c -> cat a b1 -> cat b1 b -> cat a c
13:30:51 <milaz> EvanR-work: ok, I'll redo it now by writing strict bytestrings...
13:31:22 <EvanR-work> milaz: are you trying to make haskell code go as fast as possible, or... ;)
13:32:12 <milaz> EvanR-work: I have a dilemma. I have to serialize dome data to file with fastest possible speed, and also to operate on them.
13:32:35 <djahandarie> Man, sometimes there is such cool stuff in category-extras, but I don't want to import that thing :(
13:32:42 <copumpkin> djahandarie: I agree
13:32:44 <milaz> EvanR-work: I discovered that Haskell is perfect for the logic of this software, but I can't figure out the IO part
13:33:00 <EvanR-work> ah yeah then you want the various bytestring utility packages
13:33:02 <ski> @let (<-<) :: Category ar => ar a1 b1 -> ar b0 a0 -> (ar a0 a1 -> ar b0 a1); h <-< f = (h <<<) . (<<< f)
13:33:03 <lambdabot>  <local>:6:9: Not in scope: type constructor or class `Category'
13:33:15 <ski> @let (<-<) :: Control.Category.Category ar => ar a1 b1 -> ar b0 a0 -> (ar a0 a1 -> ar b0 a1); h <-< f = (h <<<) . (<<< f)
13:33:15 <lambdabot>  <local>:6:9:
13:33:16 <lambdabot>      Not in scope: type constructor or class `Control.Category....
13:33:27 <ski> @let (<-<) :: Arrow ar => ar a1 b1 -> ar b0 a0 -> (ar a0 a1 -> ar b0 a1); h <-< f = (h <<<) . (<<< f)
13:33:28 <lambdabot>  <local>:6:80:
13:33:28 <lambdabot>      Couldn't match expected type `a1' against inferred type `...
13:33:35 * ski sighs
13:33:46 <ski> @let (<-<) :: Arrow ar => ar a1 b1 -> ar b0 a0 -> (ar a0 a1 -> ar b0 b1); h <-< f = (h <<<) . (<<< f)
13:33:47 <lambdabot>  Defined.
13:34:19 <Veinor> copumpkin: http://github.com/veinor/askitter
13:34:25 <EvanR-work> milaz: text data? or
13:35:32 <EvanR-work> milaz: ive been having success with Data.ByteString.Search for what seems like high end splitting on and replacing of byte patterns
13:35:45 <milaz> EvanR-work: quadruples like (Word64, Word64, Word64, String)
13:36:02 <EvanR-work> String as in arbitrary unicode text
13:36:43 <milaz> EvanR-work: I planned to use 'binary' package for further work
13:37:40 <EvanR-work> if its ascii text you want ByteString rather than String, and Data.ByteString.Char stuff so you dont have to mess with Word8
13:37:58 <EvanR-work> Char8 i mean
13:38:34 <milaz> In 'String' part there must be some representation of unicode characters
13:39:07 <EvanR-work> then forget the Char8 thing, but you still can have unicode text in the ByteString
13:39:13 <EvanR-work> no need for String
13:39:24 <milaz> ok, thanks
13:39:46 <EvanR-work> for that, theres the Data.ByteString.UTF8
13:39:46 <milaz> I just put it into the type as a placeholder, because there's no real code for that part yet :)
13:40:42 * hackagebot wordsetdiff 0.0.3 - Compare two files as sets of N-tuples of words.  http://hackage.haskell.org/package/wordsetdiff-0.0.3 (RyanNewton)
13:42:08 <Veinor> hmm
13:42:26 <Veinor> the user_timeline api doesn't have to be auth'd, but you can't get protected timelines if you aren't
13:43:01 <Veinor> should I have userTimeline :: Maybe Token -> [(String, String)] -> whatever?
13:43:50 <milaz> EvanR-work: should I use -O2 as you suggested above?
13:43:53 <EvanR-work> yes
13:44:17 <EvanR-work> Veinor: if it does two different things, should it be two different functions, one which takes Token and one doesnt
13:44:23 <EvanR-work> possibly sharing implementation parts
13:44:35 <Veinor> EvanR-work: it does the same thing, fundamentally
13:45:09 <Veinor> ... also, how should I handle the 8 or so different optional parameters? a list like [("since_id", 2345)]?
13:45:35 <dschoepe> Veinor: How about a record?
13:45:56 <Veinor> I think I'd need different records for each API call, though
13:46:25 * milaz preformed the new IO test
13:46:26 <milaz> ... aha, 12 seconds for one million write operations of 1024 bytes buffer
13:46:32 <milaz> it's like C
13:46:48 <milaz> ... by speed, not by code :)
13:47:57 <Veinor> like, statuses/user_timeline uses user_id, screen_name, since_id, count, page, but not all of those are valid for other things
13:51:05 <Veinor> this is why I like variadic functions and stuff :P
13:52:18 <dschoepe> Perhaps there's already something in liboleg that implements optional parameters through scary type system acrobatics :)
13:52:47 <Veinor> well, Text.Printf exists....
13:57:32 <mauke> of course there is
13:57:49 <Veinor> hm. how do you go from bytestrings to strings?
13:58:00 <mauke> @hoogle unpack
13:58:00 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
13:58:00 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
13:58:01 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
13:58:52 <Veinor>     Couldn't match expected type `ByteString'
13:58:54 <Veinor>            against inferred type `Data.ByteString.Lazy.Internal.ByteString'
13:58:58 <Veinor> :|
13:59:11 <djahandarie> \o/
13:59:18 <Veinor> what do
13:59:39 <copumpkin> Veinor: import Data.ByteString.Lazy instead of Data.ByteString
14:01:00 <Veinor> ah
14:02:40 <Veinor> okay, I'm going to try something cool, wish me luck
14:04:30 <copumpkin> Veinor: good luck!
14:05:26 <Veinor> I'm going to try a lazy array of tweets
14:05:29 <deadguys> hi all.  I'm looking for a function f :: (a -> b -> c) -> (a' -> a) -> (b' -> b) -> a' -> b' -> c, that can be generalized to n args.  I feel like it exists, but I can't find it.  any ideas?
14:05:45 <Veinor> @djinn (a -> b -> c) -> (a' -> a) -> (b' -> b) -> a' -> b' -> c
14:05:45 <lambdabot> f a b c d e = a (b d) (c e)
14:06:29 <benmachine> deadguys: variadic functions in haskell tend to be a bad idea
14:06:33 <benmachine> sort of
14:06:53 <benmachine> but people are always coming up with ingenious things with continuations and type classes
14:08:18 <copumpkin> Veinor: the issue with that is that you'll have unsafeInterleaveIO
14:08:28 <copumpkin> Veinor: you should have a tweet iteratee!
14:08:39 <copumpkin> tweeteratee, even
14:09:06 <Veinor> copumpkin: :O
14:09:18 <Veinor> what I was thinking was something considerably sillier
14:09:38 <Veinor> tweets = map getNthTweet [1..]
14:09:48 <jmcarthur> deadguys: it has more limited types, but maybe you could use something like this instead?     (b -> b -> b) -> [a -> b] -> [a] -> b
14:10:16 <copumpkin> data Tweeteratee a = Done a | NeedMoarTweetz (a -> Tweeteratee a)
14:10:22 <ski> benmachine : continuations seems better than type classes, imo
14:10:47 <copumpkin> oh wait
14:10:48 <benmachine> ski: sure, but you can do different stuff with each
14:10:56 <copumpkin> NeedMoarTweetz (Tweet -> Tweeteratee a)
14:11:01 <Veinor> keep in mind
14:11:06 <Veinor> I don't know what iteratees are :O
14:11:17 <benmachine> they're a free monad over something or other
14:11:20 <benmachine> I vaguely remember hearing
14:11:21 <deadguys> alright thanks guys
14:11:22 <benmachine> or a free something
14:11:25 <benmachine> over something else
14:11:27 <jmcarthur> :t \f fs xs -> foldl1 f $ zipWith ($) fs xs
14:11:28 <benmachine> I can't remember
14:11:28 <lambdabot> forall b b1. (b1 -> b1 -> b1) -> [b -> b1] -> [b] -> b1
14:11:31 <copumpkin> Free ((->) Tweet)
14:11:36 <benmachine> oic
14:11:40 <Veinor> well that's helpful
14:11:52 <copumpkin> Veinor: yeah, you get a monad without even paying for it!
14:12:03 <Veinor> but seriously
14:12:23 <Veinor> I think right now I'm going to figure out a: how to pass arguments in a sane way, and b: how to extract the data people probably care about from the huge mess of JSON
14:14:21 <Veinor> ... ew, Text.JSON is horrible
14:14:50 <Veinor> halp me
14:14:54 <djahandarie> Someone wrote a nice JSON lib
14:15:21 <ski> @type \f (Reader ma) -> Reader (ma . f)
14:15:22 <lambdabot> forall t t1 r. (r -> t) -> Reader t t1 -> Reader r t1
14:15:32 <ski> @type local
14:15:32 <djahandarie> Though the galios one isn't aful
14:15:33 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
14:15:34 <djahandarie> awful
14:15:45 <benmachine> aren't there like ten JSON libraries now
14:15:50 <ski> @type \f -> local f . (Reader . runReader)
14:15:51 <lambdabot> forall a r. (r -> r) -> Reader r a -> Reader r a
14:15:58 <Veinor> djahandarie: maybe I'm just using it wrong then
14:17:01 <Veinor> I have a Result JSValue. I know it's an array of objects.
14:17:06 <Veinor> how do I get at the objects?
14:18:21 <Veinor> do I have to do some kind of (\(Ok (JSArray xs)) -> xs) thing?
14:19:32 <djahandarie> Result has a functor instance
14:20:35 <Modius> Leksah IDE - I see on the tutorial video he has autocomplete; but I don't see it - what do I have to configure to make that work?
14:21:41 <Hous> sipa still here ?
14:22:29 <Veinor> djahandarie: hm. stupid type system.
14:24:46 <roconnor> Veinor: how do you know it is an array of objects?
14:25:00 <Veinor> because that's what the API says it'll return
14:25:09 <djahandarie> It should be in the type
14:25:23 <djahandarie> Err
14:25:24 <copumpkin> it'd be nice if I could take apart partially applied data constructors without fully applying them
14:25:26 <djahandarie> Maybe I lied :)
14:25:33 <nomothetis> What could be causing ghc to not find hunit if ghc-list shows it is installed? I have a declared import statement ("import Hunit"), and ghc fails saying it cannot find the module.
14:26:07 <Veinor> djahandarie: yeah, I get a Result JSValue... maybe I should use xml instead
14:26:11 <roconnor> Veinor: what a crappy API.  Yes you can use that lambda pattern matching thing, a let/where pattern is usually more clear.
14:26:21 <Veinor> it seems like xml would be easier to deal with
14:27:17 <roconnor> foo :: Int -> [Int] -- result guarenteed always to be a list of length 1.
14:27:24 <copumpkin> like what if I have 
14:27:25 <copumpkin> data Baa = Baa Int !(forall a. a)
14:27:35 <benmachine> copumpkin: what like, case (,) m of (,) (Just x) -> ?
14:27:35 <copumpkin> and then someone gives me a (forall a. a) -> Baa
14:27:50 <copumpkin> I want to pull out the Int
14:27:53 <copumpkin> and have no way to do it!
14:27:55 <copumpkin> :(
14:28:00 <roconnor> copumpkin: then I'm the queen of England.
14:28:03 <copumpkin> lol
14:28:11 <JoeyA> data List a = Nil | Cons a (List a) <- What are these kinds of types called?
14:28:20 * benmachine is a republican
14:28:21 <copumpkin> JoeyA: algebraic? recursive?
14:28:22 <Veinor> recursive types?
14:28:26 <roconnor> copumpkin: (forall a. a) is Void
14:28:26 <copumpkin> but seriously
14:28:36 <JoeyA> or just any type that takes parameters
14:28:45 <Veinor> parametric
14:28:45 <copumpkin> roconnor: yeah, but I can produce a value of it in Haskell, and regardless, the Int has still been passed and is in the closure
14:28:50 <djahandarie> A type with kind * -> *? :P
14:29:03 <roconnor> copumpkin: you can't get it out.
14:29:04 <djahandarie> Type constructor
14:29:05 <JoeyA> right
14:29:14 <copumpkin> roconnor: wah
14:29:19 <JoeyA> What are types with kind k1 -> k2 called?  :P
14:29:26 <roconnor> wait
14:29:31 <roconnor> how did you produce a value of it
14:29:33 <djahandarie> Not in Haskell kind
14:29:39 <roconnor> copumpkin: are you sure you don't mean (exists a. a) ?
14:29:41 <benmachine> copumpkin: fst . unsafeCoerce ?
14:29:43 <Veinor> :t undefined
14:29:44 <lambdabot> forall a. a
14:29:48 <Veinor> :o
14:29:49 <copumpkin> roconnor: yeah
14:29:59 <copumpkin> I'm sure I don't mean that :P
14:30:05 <aristid> @hoogle asks
14:30:06 <lambdabot> Control.Monad.Reader.Class asks :: MonadReader r m => (r -> a) -> m a
14:30:08 <roconnor> copumpkin: how do you put a 7 into that type?
14:30:15 <aristid> :t (asks, arr)
14:30:16 <lambdabot> forall r a (m :: * -> *) b c (a1 :: * -> * -> *). (MonadReader r m, Arrow a1) => ((r -> a) -> m a, (b -> c) -> a1 b c)
14:30:17 <copumpkin> roconnor: x = Baa 7
14:30:20 <ccasin> JoeyA: type constructors, usually
14:30:21 <copumpkin> gives (forall a. a) -> Baa
14:30:25 <JoeyA> so I guess algebraic data type is sort of accurate, but doesn't capture the notion I'm talking about
14:30:27 <copumpkin> roconnor: it's partially applied
14:30:31 <JoeyA> the idea of a type having parameters
14:30:43 <copumpkin> I want to pull the Int back out of the partially applied constructor without applying the (obviously impsosible) rest
14:31:01 <roconnor> copumpkin: including the strictness annotation?
14:31:17 <ccasin> JoeyA: When one wants to distinguish between proper types (of kind *) and things with arrow kinds, one often reserves "types" for the kind * things and calls the others "constructors" or "type constructors"
14:31:22 <roconnor> copumpkin: your type is an unlazy pair (Int,Void) which isomorphic to Void.
14:31:24 <copumpkin> well the strictness annotation is on the (forall a. a) to make it impossible to just pass it bottom and pattern match on only the first
14:31:45 <copumpkin> roconnor: I know, but the information is there, just hiding from me :P
14:31:45 <JoeyA> ccasin: thanks
14:32:00 <roconnor> copumpkin: If I were GHC I'd optimize that information away
14:32:05 <copumpkin> fair enough :)
14:33:31 <dolio> The information has probably been garbage collected.
14:33:55 <dolio> Because Baa 5 undefined evaluates to undefined.
14:33:59 <roconnor> go strictness analyser!
14:34:50 <chowder> when using cabal do you have to add the libraries under .cabal/lib to the /etc/ld.so.conf?
14:35:25 <aristid> if i want to show a link to Control.Category.id in haddock documentation, is 'Control.Category.id' the right syntax? it doesn't work although the documentation is installed (a link to just 'id' works, and that's the same package)
14:35:57 <dcoutts> chowder: no, they're static libs, not dynamic
14:36:10 <chowder> dcoutts: ok, thanks
14:36:29 <benmachine> dcoutts: what if you used --shared or whatever it is?
14:36:35 <Veinor> hm, I seriously think xml might be simpler to do than json
14:36:57 <Veinor> annoying.
14:37:00 <dcoutts> benmachine: still no, the default setup we use for locating shared libs is to use -rpath
14:37:02 <aristid> Veinor: you don't really think that.
14:37:12 <benmachine> dcoutts: oh ok, neat
14:37:19 <Veinor> aristid: well, I don't have to fight the type system with xml as much
14:37:23 <nomothetis> anyone have any ideas? :-/ I really would like to compile my test file... :-)
14:37:31 <aristid> Veinor: you have to fight hxt/HaXml/xml tho.
14:37:40 <Veinor> nomothetis: could you pastebin it?
14:37:43 <dcoutts> benmachine: and you can ignore the anti-rpath FUD :-)
14:37:44 <Veinor> the error you're getting
14:37:45 <nomothetis> sure.
14:38:04 <benmachine> dcoutts: heh, you're tempting me to go look up what it is so I can ignore it properly
14:38:06 <Botje> nomothetis: are you doing ghc --make?
14:38:15 <nomothetis> Botje: yes.
14:38:20 <Veinor> aristid: truuue
14:38:25 <nomothetis> in fact, ghc --make -Wall filename.sh
14:38:27 <dolio> Of course, if the undefined is an infinite loop, there probably won't be opportunities for garbage collection.
14:38:29 <nomothetis> I mean hs
14:38:50 <aristid> Veinor: i'm writing a monadic interface for xml tho. hoping that that will make life easier in another package of mine :D
14:38:52 <dcoutts> benmachine: debian has some policy against rpath, which makes some sense in their situation but which some people have interpreted as a universal "omg rpath is bad!!"
14:39:01 <benmachine> dcoutts: oh ok
14:39:03 <Veinor> aristid: well, I need to figure out how to use Text.JSON then
14:39:10 <ski> JoeyA : type functions ?
14:39:12 <nomothetis> This is the code:
14:39:13 <nomothetis> http://pastie.org/1233813
14:39:36 <aristid> Veinor: uh, if you don't want to write JSON instances for everything, you can just use JSValue
14:39:36 <nomothetis> the command I run is:
14:39:39 <davidL> Veinor: make your types instances of JSON. use generics if it makes it easier
14:39:46 <benmachine> dcoutts: oh, did I ever thank you for using my cabal doc patch? I feel like a real contributor now :P
14:39:58 <nomothetis>  ghc --make -Wall -package HUnit causes_test.hs -i..
14:39:58 <Veinor> you're misunderstanding
14:40:00 <dcoutts> benmachine: :-)
14:40:03 <Veinor> I'm not forming JSON here, I just have to parse it
14:40:07 <Veinor> http://dev.twitter.com/doc/get/statuses/friends_timeline
14:40:09 <djahandarie> Dynamic -> Dynamic -- takes an integer and returns a list of length 1
14:40:17 <Veinor> nomothetis: could you pastebin the error you're getting?
14:40:21 <roconnor> djahandarie: :O
14:40:26 <aristid> Veinor: right, and Text.JSON can parse JSON into JSValue
14:40:30 <Veinor> right
14:40:38 <Veinor> (well, Result JSValue, but functors).
14:40:45 <monochrom>  ("pear", "par") -- Must check for symmetry    ("par", "per")
14:40:57 <monochrom> you see you need a comma there?
14:41:10 <aristid> Veinor: Result is just an error type :)
14:41:19 <Veinor> so... I have a JSValue, that I'm guaranteed by the spec is going to represent a list of arrays
14:41:24 <Veinor> er, list of objects
14:41:26 <roconnor> Veinor: parsing Json to a JSValue is only half of the parsing you need to do (maybe less than half the parsing)
14:41:30 <nomothetis> Veinor: http://pastie.org/1233822
14:41:40 <nomothetis> Veinor: ran with -v appended as well.
14:41:48 <djahandarie> What data structure is used for cases?
14:41:52 <dolio> Anyhow, insisting that the information is "in there" would be kind of like saying that '(,) <$> Right 5 <$> Left "blorf"' has 5 "in there".
14:41:58 <roconnor> Veinor: You still have to "parse" the JSValue into your internal data types  And you should be ready to allow that to fail too
14:42:38 <roconnor> "parsing JSon" is more like lexing than yaccing :)
14:43:03 <Veinor> nomothetis: so you're running 'ghc --make -Wall -package Hunit'?
14:43:18 <Veinor> roconnor: right now I don't have any internal data types :O
14:43:35 <roconnor> Veinor: you should create one based on the spec
14:43:46 <Veinor> yes, but that will come later
14:43:54 <roconnor> nope now. :D
14:43:55 <nomothetis> Veinor: I tried that, but I also tried without the -package flag.
14:44:04 <Veinor> nomothetis: same error without the package flag?
14:44:18 <nomothetis> Veinor: yes
14:44:30 <Veinor> and ghc-pkg is definitely showing it as installed?
14:45:15 <mietek> What's the best way of doing Erlang-style shared-nothing message passing in Haskell?
14:45:22 <nomothetis> Veinor: Yes. This is the output: http://pastie.org/1233841
14:45:29 <roconnor> TChan?
14:45:39 <Botje> mietek: there's CHP
14:46:08 <Veinor> nomothetis: that's... really weird
14:46:28 <nomothetis> Veinor: Good, I'm glad I"m not missing something really obvious. Could it be because it's installed twice?
14:46:53 <Veinor> I don't think so...
14:47:41 <Veinor> roconnor: but if the parsing into my internal data type fails, then it's not my fault
14:47:53 <nomothetis> Veinor: I can commit to github if you want to look at the entire code... shouldn't matter, but who knows.
14:48:20 <Veinor> nomothetis: if you just write up a dummy .hs that's 'import HUnit; main = putStrLn "yo"' or something
14:48:20 <mietek> roconnor, Botje: thanks
14:48:27 <Veinor> do you still get the error?
14:48:39 <nomothetis> Veinor: let me try that.
14:48:39 <roconnor> Veinor: same as if Result JSValue is fail.  I'd be inclined reuse the Result Monad
14:48:44 <mietek> Botje: do you know if CHP supports process linking/monitoring?
14:48:58 <djahandarie> Cases are a list in core apparently
14:49:03 <Botje> no idea
14:49:10 <Botje> i just read some blog posts, it looked interesting
14:49:18 <mietek> Cool
14:49:20 <benmachine> nomothetis: uh, HUnit doesn't export a module called HUnit
14:49:26 <benmachine> nomothetis: try Test.HUnit
14:49:34 <roconnor> benmachine++
14:49:39 <nomothetis> benmachine: thanks, I'll try that.
14:50:20 <nomothetis> benmachine++
14:50:27 <benmachine> :)
14:50:29 <nomothetis> benmachine: thanks, that worked!
14:50:43 <nomothetis> The online docs said import HUnit was the way to go, though.
14:50:45 <nomothetis> Must be out of day.
14:50:49 <nomothetis> s/day/date
14:50:53 <Veinor> ...
14:50:58 <Veinor> oh, derp
14:51:06 <benmachine> ghc-pkg field HUnit exposed-modules is the authoritative source
14:51:27 <benmachine> if you got it from hackage there are also module docs here http://hackage.haskell.org/package/HUnit
14:51:44 <Veinor> oh, cool, Result is a monad
14:52:28 <Veinor> that makes things easier
14:52:54 <nomothetis> benmachine: thank you.
14:53:03 * roconnor is assuming Result is a monad
14:53:36 <Veinor> yeah, it's a monad, functor, applicative, mplus, everything sensible
14:53:37 <benmachine> np :)
15:01:07 <roconnor> Veinor: oh good.  then you can "guard" against failure
15:01:13 <roconnor> @type guard
15:01:14 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:02:02 <roconnor> Veinor: you can also use patterns in your do notation which will call fail if the pattern match fails.
15:03:05 <roconnor> do { (JSArray x) <- parsedJson; ...; return (myWonderfulParsedData ...) }
15:04:57 <ski>   do { JSArray x <- parsedJson; ...; return (myWonderfulParsedData ...) }
15:05:27 * ski GCs unneeded brackets ..
15:05:39 <roconnor> ski: send them to #lisp
15:07:39 <c_wraith> I'm a little sad that do block can have non-monadic results.
15:07:42 <c_wraith> > do 5
15:07:43 <lambdabot>   5
15:07:54 <ezyang> oh, that's pretty amusing. 
15:08:01 <ezyang> "Go go syntax sugar". 
15:08:18 <RichardBarrell> Go go gadget syntax sugar!
15:08:20 <roconnor> I'm going to use that more in my haskell
15:08:24 <c_wraith> > do do do do 5
15:08:25 <lambdabot>   5
15:08:37 <c_wraith> ok, that's enough of that
15:08:43 <RichardBarrell> > :t let ron = const in do do ron ron ron do do ron ron
15:08:44 <Veinor> > (do 5) (do (+)) (do 5)
15:08:44 <lambdabot>   <no location info>: parse error on input `:'
15:08:45 <lambdabot>   Ambiguous type variable `t' in the constraint:
15:08:45 <lambdabot>    `GHC.Num.Num t' arising f...
15:08:52 <Veinor> :t (do 5) (do (+)) (do 5)
15:08:53 <lambdabot>     Ambiguous type variable `t' in the constraint:
15:08:53 <lambdabot>       `Num t' arising from the literal `5' at <interactive>:1:20
15:08:53 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
15:09:02 <RichardBarrell> @type let ron = const in do do ron ron ron do do ron ron
15:09:03 <lambdabot> parse error on input `do'
15:09:03 <milaz> c_wraith: but what's the use of do's without monadic resuts?
15:09:08 <RichardBarrell> Buglit.
15:09:51 <c_wraith> milaz, generally, it's something you see in beginner code that indicates a misunderstanding of the language.  Hence I wish it wasn't allowed.
15:10:12 <milaz> :t (do 5) `(do (+))` (do 5)
15:10:13 <lambdabot> parse error on input `('
15:10:35 <c_wraith> arbitrary expressions not allowed inside backticks :)
15:10:38 <milaz> :t (do (+)) (do 5) (do 5)
15:10:39 <lambdabot> forall a. (Num a) => a
15:10:44 <milaz> yay!
15:10:56 <milaz> (do (+)) (do 5) (do 5)
15:11:19 <milaz> > (do (+)) (do 5) (do 5)
15:11:20 <lambdabot>   10
15:12:08 <milaz> I didn't even know that :)
15:12:30 <c_wraith> milaz, in particular, I see a lot of code that looks like f x = do { let y = x * 4 ; y - 5 }
15:12:31 <EvanR-work> Exit and ExitT is amazing!
15:12:34 <EvanR-work> and MonadExit
15:13:00 <milaz> c_wraith: let me guess, you teach Haskell at some university?
15:13:12 <ski>   concatMap f as = do concat (do map f as)
15:13:37 <c_wraith> milaz, nope.  Just to coworkers and online when I'm feeling charitable :)
15:13:52 <djahandarie> c_wraith, maybe this is a career calling
15:13:57 <djahandarie> Along with the rest of #haskell ;)
15:14:00 <ski> @where Charity
15:14:00 <lambdabot> http://pll.cpsc.ucalgary.ca/charity1/www/home.html
15:14:11 <EvanR-work> :t (do 5)
15:14:12 <lambdabot> forall t. (Num t) => t
15:14:30 <c_wraith> djahandarie, in the long-term, teaching is my goal.  I just want some money first.  Or at least to get out of debt. :)
15:14:36 <EvanR-work> :t \x -> do x
15:14:37 <lambdabot> forall t. t -> t
15:14:42 <EvanR-work> :t do
15:14:43 <lambdabot> Empty 'do' construct
15:14:46 <EvanR-work> >_<
15:14:53 <ski> @pl \x -> do x
15:14:53 <lambdabot> do
15:14:57 * ski grins
15:14:58 <EvanR-work> >_<
15:15:01 <djahandarie> lol pl
15:15:06 <milaz> ski: oh, so, even charity is the programming language...
15:15:20 <djahandarie> @pl \x -> do {x}
15:15:20 <lambdabot> (line 1, column 10):
15:15:20 <lambdabot> unexpected "{"
15:15:20 <lambdabot> expecting variable, "(", operator or end of input
15:15:34 <djahandarie> @undo do {x}
15:15:35 <lambdabot> x
15:15:50 <ski> @. pl undo \x -> do {x}
15:15:50 <lambdabot> id
15:15:55 <djahandarie> :P
15:16:18 * milaz thanks God he's teaching students mainly Python :P
15:16:33 <djahandarie> I think Haskell would be more fun to teach
15:16:36 <benmachine> @. . run pl undo \x -> do {x}
15:16:37 <lambdabot> Plugin `compose' failed with: Unknown command: ""
15:16:39 <benmachine> :(
15:16:45 <djahandarie> It also makes... more sense than most other programming languages
15:16:58 <milaz> djahandarie: not to construction engineers :)
15:17:03 <Cale> Haskell is pretty fun to teach. I helped teach it to some 11 year old kids at one point.
15:17:07 <ski> @. run . pl undo \x -> do {x}
15:17:08 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
15:17:09 <lambdabot>    arising from a use of `...
15:17:13 * benmachine envies Cale 
15:17:24 * milaz too
15:17:32 <djahandarie> Cale, I feel like motivation would be more difficult in that case
15:17:42 <djahandarie> I taught young kids HTML because then they could make cool webpages
15:17:54 <benmachine> you can make cool webpages with haskell >_>
15:18:00 <benmachine> "now kids, this is a bytestring"
15:18:04 <djahandarie> After 10 years of laboring
15:18:23 <djahandarie> I did teach them some Javascript while I was there though
15:18:29 <benmachine> or, was it tryhaskell that had a drawing monad
15:18:31 <EvanR-work> Cale: hrm how did *that* go ;)
15:18:33 <benmachine> that was a bit logo-ish
15:18:34 <Cale> They were going through the book called "The Haskell Road"
15:18:42 <benmachine> I did logo when I was 11
15:18:44 <benmachine> sorta
15:19:01 <benmachine> tryhaskell isn't responding to me :(
15:19:06 <Cale> EvanR-work: It went well, at least, the little parts of it which I was involved in did. :)
15:19:06 * ski did as well .. but the computers got stolen :(
15:19:12 <benmachine> :(
15:19:18 <milaz> aha, take, kids this applicative functor and convert it into monad and after you'll apply this to this nice monoids you'll get a nice html :P
15:19:19 <djahandarie> benmachine, working fine here
15:19:25 <milaz> hilbertian dream :)
15:19:35 <EvanR-work> lol
15:19:38 <djahandarie> I don't think the weird terms would be very weird to kids
15:19:38 <Cale> I taught them about monads, but applicative functors weren't around back then.
15:19:39 <benmachine> ski: you should've just poked the weird kid into walking in lines for you
15:19:39 <ski> (why Hilbert ?)
15:19:51 <c_wraith> oh, hey.
15:19:52 <c_wraith> http://hackage.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal
15:19:54 <ski> benmachine : huh ?
15:19:59 <benmachine> ski: never mind >_>
15:20:00 <djahandarie> c_wraith, yeah
15:20:08 * ski was the weird kid, fwiw
15:20:12 <djahandarie> c_wraith, was it you who was asking about that the other day?
15:20:17 <benmachine> ski: yeah me too, I feel bad about making that sort of joke
15:20:18 <milaz> it was his famous quote that mathematical objects must be regarded as chairs, forks, spoons and so so
15:20:20 <djahandarie> (If there was any movement in TH)
15:20:25 * benmachine rescinds it
15:20:43 <c_wraith> I don't think I was.  I was helping with some TH work, but I wasn't actually thinking about the future of it.
15:20:53 <milaz> in fact, I quoted it here badly, but I can find it :)
15:22:00 <benmachine> (if I wasn't so 19 I probably still would be the weird kid)
15:22:13 <EvanR-work> class Monad m => MonadExit e m | m -> e where
15:22:19 <EvanR-work> what is this | m -> e thing
15:22:23 <djahandarie> I feel like I'm getting too old these days
15:22:25 <ski> functional dependency
15:22:27 <ezyang> functional dependency 
15:22:28 <benmachine> functional dependency
15:22:30 <EvanR-work> oh crap
15:22:34 <EvanR-work> wtf is that
15:22:34 <milaz> lol
15:22:50 <milaz> what a cascade of answers :)
15:22:55 <djahandarie> echo
15:22:57 <EvanR-work> do i need extensions
15:23:02 <ezyang> EvanR-work: Do you want the short answer or long answer? :-) 
15:23:09 <ddarius> djahandarie: Hang around older people.
15:23:12 * EvanR-work goes insane
15:23:14 <ski> EvanR-work : it means `forall m. Monad m => unique e. MonadExit e m' must hold
15:23:17 <McManiaC> and none of them made a typo :O
15:23:31 <benmachine> EvanR-work: fwiw, this page is good for ungoogleable things: http://haskell.org/haskellwiki/Keywords#.7C
15:23:41 <milaz> ski: zOMG all these quantifiers :)
15:23:55 <djahandarie> ddarius, it's hard to discriminate by age on the internet :(
15:23:57 <ski> EvanR-work : which means `'forall m e0 e1. (Monad m,MonadExit e0 m,MonadExit e1 m) => e0 = e1'
15:23:57 <McManiaC> ski: never saw it that way. cool!
15:23:58 <McManiaC> :)
15:24:06 <EvanR-work> benmachine: its really going to be ungooglable in 7 minutes when i go home to no internet ;)
15:24:07 <milaz> functional dependency makes compiler believe that there can be only one e for the given m
15:24:19 * hackagebot monadLib-compose 0.1 - Arrow-like monad composition for monadLib.  http://hackage.haskell.org/package/monadLib-compose-0.1 (AristidBreitkreuz)
15:24:20 <benmachine> EvanR-work: daaang, save it to your hard drive :O
15:24:22 <milaz> hence m -> e
15:24:37 <ski> EvanR-work : i.e., there can be at most one `e' such that `MonadExit e m', for any `m'
15:24:46 <ddarius> djahandarie: So stop hanging around on the internet.  It probably isn't worth it anyway.
15:24:55 <djahandarie> Haha
15:25:12 <djahandarie> I don't know what my life would be like without the internet
15:25:22 <EvanR-work> ski: so for each m there is only one MonadExit e m ?
15:25:30 <ddarius> djahandarie: Find out!
15:25:40 <EvanR-work> erm
15:25:51 <ski> EvanR-work : there doesn't have to be one for every `m' (such that `Monad m') .. there can be at *most* one, though
15:25:57 <ddarius> "Shipping: $27.12, Tax: $0.00, Total: $13.56" ...
15:26:03 <milaz> ski: one can write '=' in type signature?
15:26:11 <aristid> new module (see hackagebot announcment): http://github.com/aristidb/monadLib-compose/blob/master/MonadLib/Compose.hs :)
15:26:17 <benmachine> -$14 tax
15:26:19 <EvanR-work> ski: so i cant make two MonadExit instances with two different e for a given m
15:26:27 <benmachine> the government just decided to give you some money
15:26:34 <benmachine> they know it's been hard lately and thought you needed a break
15:26:38 <EvanR-work> whats the point of this 'restriction'
15:26:40 <ski> milaz : unfortunately, GHC choose `~' instead of `=' .. but that's non-actual-Haskell, anyway
15:26:41 * ddarius wishes the government would give him the money it owes him.
15:26:50 <benmachine> EvanR-work: if the type inference machine works out m, then it can work out e
15:27:12 <milaz> ok
15:27:23 <benmachine> EvanR-work: this basically vastly reduces the number of type annotations you need, and additionally makes some type-function-like things possible
15:27:33 <ski> (milaz : i.e. the formulae i wrote is non-actual-Haskell)
15:27:55 <EvanR-work> is this only needed for transformers, or will the MonadExit instance for Exit still work
15:28:00 <EvanR-work> without it
15:28:00 <milaz> ski: ok, it's some kind of type-calculus :)
15:28:05 <EvanR-work> is there something illegal going on without i
15:28:20 <aristid> EvanR-work: instances never contain fundeps, they are on the class
15:28:34 <ski> EvanR-work : yes. the point it to reduce ambiguity
15:28:51 <EvanR-work> i wrote down as much notes as i could on paper ;)
15:28:57 <EvanR-work> ive been doing a lot of haskell lately offline
15:29:05 <EvanR-work> inventing monads and transformers on my own
15:29:29 <milaz> EvanR-work: these functional dependencies got lot of criticizm lately, and they recommend using type families instead, as I understand
15:29:43 <aristid> milaz: meh, i prefer my fundeps :P
15:30:13 <ski> EvanR-work : if you use `liftM2 (,) get get', you'd get `(MonadReader r0 m,MonadReader r1 m) => m (r0,r1)' with no fun.dep. .. with the fun.dep. it knows `r0' must be the same as `r1', so you get `MonadReader r m => m (r,r)'
15:30:19 <milaz> aristid: eh, I'm noob. I didn't do any fundep and any type family yet. Only classes and instances :)
15:30:24 <ddarius> I doubt functional dependencies will be going anywhere for the next, at least five years.
15:30:35 <ski> EvanR-work : similar for `MonadExit', except i don't recall what the operations on that is
15:30:39 <ddarius> They'll probably never go away.
15:30:51 <aristid> i don't see what's so evil about them, but then i'm not that experienced either
15:30:59 <EvanR-work> ski: exitWith :: e -> m a
15:31:14 <cts> conal: Thank you for the blog entry about everything is a function.
15:31:20 <aristid> EvanR-work: this looks like ExceptionM from monadLib :>
15:31:23 <benmachine> aristid: I don't think they're evil as such, it's just that explicit type functions tend to be more natural as concept
15:31:27 <benmachine> *s
15:31:31 <conal> cts: :)
15:31:37 <EvanR-work> aristid: does that use fundeps?
15:31:41 <aristid> EvanR-work: yes.
15:32:22 * hackagebot hamlet 0.5.1.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.5.1.1 (MichaelSnoyman)
15:32:29 <ski> EvanR-work : ok, so `exitWith ||| exitWith' gets type `MonadExit e m => Either e e -> m a' instead of `(MonadExit e0 m,MonadExit e1 m) => Either e0 e1 -> m a'
15:32:43 <milaz> aristid: probably it's because you have to have not more than one e for m, while you may want more than one
15:33:03 <aristid> EvanR-work: look at what kind of evil fundeps i made: class (Monad m, Monad n) => ComposeM m n s t | m -> s, n -> t, n s -> m 
15:33:20 <djahandarie> Fun deps can be abused pretty badly
15:33:30 * EvanR-work runs screaming into nearby foothills
15:33:37 <aristid> djahandarie: then again, type families can be abused too. or not?
15:33:44 <djahandarie> aristid, I wouldn't consider it abuse in that case
15:33:51 <ski> aristid : looks interesting .. what's the operation(s) ?
15:34:00 <EvanR-work> ski: ||| ?
15:34:03 <ddarius> djahandarie: That's doesn't seem very fair.
15:34:15 <ski> EvanR-work : oh .. imagine i had written `either'
15:34:19 <ski> @type either
15:34:20 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
15:34:36 <ddarius> Functional dependencies give you logic programming at the type level, associated types give you functional programming at the type level.  In some cases LP is cleaner, in some cases FP is cleaner.
15:34:39 <aristid> ski: a compose for monads, like (<<<) from Control.Category, http://github.com/aristidb/monadLib-compose/blob/master/MonadLib/Compose.hs
15:34:39 <EvanR-work> ski: ok got that. now. why did you write it? :)
15:34:41 <ski>   either exitWith exitWith -- i.e.
15:35:06 <ski> EvanR-work : simplest example that came to mind that used `exitWith' more than once
15:35:18 <ski> you can probably imagine more complicated examples
15:35:27 <aristid> :t on either
15:35:28 <lambdabot> forall a c a1. (a1 -> a -> c) -> a1 -> a1 -> Either a a -> c
15:35:37 <milaz> ski: looks exactly like the tubing in my bathroom :)
15:35:44 <ski> they'd just need to use `exitWith' more than once for the fun.dep. to kick in
15:35:52 <ski> milaz : what does ?
15:35:54 <aristid> :t (`on` either)
15:35:55 <lambdabot> forall c a c1 b. (((b -> c1) -> Either a b -> c1) -> ((b -> c1) -> Either a b -> c1) -> c) -> (a -> c1) -> (a -> c1) -> c
15:36:07 <milaz> either exitWith exitWith
15:36:16 <aristid> :t join either
15:36:17 <lambdabot> forall a c. (a -> c) -> Either a a -> c
15:36:23 <milaz> looks like a vary familiar construction :)
15:36:49 * EvanR-work goes home
15:37:04 <sipa> /nick EvanR-home
15:37:05 <sipa> ?
15:37:12 <djahandarie> Maybe I wouldn't consider it abuse if the syntax weren't so ugly... then again I don't really like type family's syntax either
15:37:17 <EvanR-work> sipa: i use the nick EvanR
15:37:18 * ski is tired, and doesn't understand what milaz is talking about ..
15:37:18 <milaz> EvanR-work: thanks for help with IO!
15:37:27 <EvanR-work> when i have internet
15:37:31 <djahandarie> Maybe things will be better when things are (hopefully) automatically lifted to the type level
15:37:52 <milaz> ski: sorry, it's just that analogy I have to see functions many times.
15:38:15 * ski stares blankly
15:38:17 <milaz> ski: especially in Haskell. I see functions like some devices connected with tubes.
15:38:53 <aristid> djahandarie: i think the fundep syntax is quite acceptable
15:39:05 <Itkovian> dons: do it _was_ you :-)
15:39:08 <Itkovian> s/do/so
15:39:58 <ski> FDs are a bit similar to mode declarations on predicates in Mercury
15:40:17 <djahandarie> aristid, consider class Add l m n | l m -> n where  { add :: l -> m -> n } instance Add Z n n ... instance Add l m n => Add (S l) m (S n) where ...
15:40:17 <milaz> ski: and then some functions look like not devices, but like T-joints, and other kinds of tubing.
15:40:42 <milaz> That's probably ok, but it looks like I'm tired too and talk silly things :)
15:40:46 <aristid> djahandarie: that instance looks invalid
15:41:05 <aristid> djahandarie: not sure if it is, but the stray m scares me
15:41:17 <ski> milaz : you might like the graphical "syntax" at
15:41:19 <ski> @where arrows
15:41:20 <lambdabot> http://www.haskell.org/arrows/
15:41:20 <ski> then
15:41:41 <djahandarie> aristid, it's valid
15:42:03 <aristid> djahandarie: and it works if you use it?
15:42:10 <milaz> ski: ah, exactly the way I see them. Thanks.
15:42:14 <aristid> djahandarie: which list of extensions does it need?
15:42:22 <djahandarie> MPTC + fun deps
15:42:47 <aristid> djahandarie: no UndecidableInstances and FlexibleContexts and FlexibleInstances?
15:42:52 <ski> milaz : also click the "Arrow syntax" link for a few more (possibly there's more in the papers referenced)
15:43:14 <djahandarie> Don't think so, but I've never actually tried running this before
15:43:23 * benmachine thought that second instance would require undecidable, but maybe GHC is clever
15:43:46 <milaz> ski: ok, that's interesting, thanks :)
15:44:22 <aristid> benmachine: GHC usually is clever enough to tell me which extensions i need to enable :D
15:44:28 * hackagebot monadLib-compose 0.1.1 - Arrow-like monad composition for monadLib.  http://hackage.haskell.org/package/monadLib-compose-0.1.1 (AristidBreitkreuz)
15:44:33 <milaz> ski: there's a special kind of do syntax for arrows in Haskell?
15:44:37 <benmachine> I think addition doesn't need undecidable
15:44:45 <ski> milaz : yes
15:44:51 <benmachine> my type-family version of multiplication does though
15:44:54 <ski> `ComposeM m n s t | m -> s, n -> t, n s -> m' would correspond to
15:44:57 <ski>   :- mode compose_m(in,unused,out,unused) is semidet.
15:45:03 <ski>   :- mode compose_m(unused,in,unused,out) is semidet.
15:45:08 <ski>   :- mode compose_m(out,in,in,unused) is semidet.
15:45:13 <[mth]> ls
15:45:14 <ski> assuming `compose_m(M,N,S,T)' for parameter order
15:45:17 <milaz> ... and that <- and -< are really part of that syntax, not an operators?
15:45:23 <ski> milaz : yes
15:45:33 <milaz> aha, now I got it :)
15:45:36 <aristid> ski: is that prolog?
15:45:38 <benmachine> milaz: <- is already syntax, cf. do
15:46:04 <ski> aristid : "almost". it is Mercury, which is a statically typed and moded logic (and functional) programming language
15:46:16 <milaz> eh, shame on me, I remember myself long ago making fun of a person asking for definition of (->) and (<-) :( 
15:46:19 <aristid> ski: uh, ok
15:46:39 <aristid> ski: i wonder how the same would look with type families
15:46:39 <ski> aristid : it has parametric polymorphism, existentials, and even multi-parameter type classes (only first-order ones, though) !
15:46:43 <aristid> in haskell
15:46:49 <aristid> hmm
15:47:20 <aristid> ski: do you know the fp-logic language "curry"? i haven't used that either, but it just comes to mind
15:47:29 * hackagebot mime-mail 0.0.0 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.0.0 (MichaelSnoyman)
15:48:08 <aristid> 0.0.0 is such an uncomforting version number
15:48:46 <ski> aristid : see e.g. <http://www.mercury.csse.unimelb.edu.au/information/features.html>
15:48:52 * benmachine tends to start from 0.1
15:49:11 <aristid> benmachine: yeah, and that's also the cabal default
15:49:12 <RichardBarrell> aristid: I'd feel happier seeing 0.0.0 on security software than 1.0
15:49:13 <ski> benmachine : `0.0' being the empty file ?
15:49:33 <RichardBarrell> aristid: at least it doesn't guarantee that the author is overconfident! :)
15:50:34 <milaz> wow, Michael Snoyman did a next separate package for mail!
15:50:46 <ski> aristid : btw, note that the above translation was from type predicates in Haskell to value predicates in Mercury. if you want to translate type functions (i.e. families), then they'd translate to value functions
15:51:00 <benmachine> ski: presumably :P
15:51:05 <benmachine> or, I haven't released yet, maybe
15:51:35 <ski> one of the nice things with predicates is that often one predicate can do the work of several functions
15:52:13 <ski> imagine if `(++)' and `stripPrefix' was done by the same function
15:52:28 <aristid> :t (++)
15:52:29 <lambdabot> forall m. (Monoid m) => m -> m -> m
15:52:34 <aristid> :t stripPrefix
15:52:35 <ski> @type (Prelude.++)
15:52:35 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
15:52:36 <lambdabot> forall a. [a] -> [a] -> [a]
15:52:42 <Boney_> oh, people talking about Mercury in #haskell, And I didn't start the conversation!
15:52:59 <ski>   stripPrefix front (front ++ back) = back
15:53:08 <gwern> ok! 18 test cases later, I think I've covered all the hyperlinkin possibilities in my pandoc-based wiki. and to think, I used to consider pandoc markdown *simple*
15:53:12 <aristid> ski: (++) is semidet? :D
15:53:24 <ski> aristid : in a backward mode, it would be
15:53:46 <aristid> stripPrefix is semidet?
15:53:47 <ski>   :- mode in ++ out = in is semidet.  % in Mercury, iirc
15:54:02 <ski>   :- mode in ++ in = out is det.
15:54:16 <aristid> hmm.
15:54:19 <gwern> lambdabot: @join #lesswrong
15:54:33 <ski> aristid : `stripPrefix' would correspond to the first of those two modes of `(++)', and `(++)' in Haskell to the second one
15:55:10 <aristid> ski: right.
15:55:29 <aristid> ski: the syntax of mercury somehow manages to be very verbose, or it feels like that
15:56:23 <ddarius> aristid: Agreed.
15:56:43 <ski>   (++) ~ in -> out -> in | semidet  -- or something, might be a more Haskelly syntax
15:57:11 <Boney_> aristid: I agree, 90% of my programming in the last few years has been in Mercury,
15:57:22 <Boney_> I find the syntax a bit clumbsy.
15:57:33 <aristid> Boney_: do you do a PhD? :P
15:57:40 <Boney_> aristid: yep.
15:57:54 <gwern> mercury continues to avoid success more successfully than haskell
15:58:02 <Boney_> Plus we use it in a mode where all declarations are required.
15:58:04 <gwern> we who are about to succeed salute you!
15:58:19 <Boney_> gwern: :-)
15:58:23 <aristid> gwern: oO that is one weird phrase :D
15:58:31 <ski> gwern : hm, what's the latin of that ?
15:58:51 <Boney_> So Mercury has far less recources than ghc.
15:59:01 <gwern> ski: the romans were so hardcore that they only had one word - victory
15:59:08 <aristid> oh, "about to VERB" is a latin verb form, right?
15:59:18 <Boney_> I think this is why it's less popular/ploshed and lacks some features.
15:59:22 <ski> gwern : i mean, the latin for the whole phrase
15:59:34 <gwern> ski: program exited successfully? it exited with VICTORY. language succeeded? VICTORIOUS. etc
16:00:21 <aristid> gwern: man, we should use that in the most mundane of software to make it more glorious
16:00:32 <gwern> aristid: first, we rename gitorious, victorious
16:01:00 <gwern> ski: http://en.wikipedia.org/wiki/Ave_Imperator,_morituri_te_salutant
16:01:33 <ski> "Victuri te salutamus" ?
16:01:40 <aristid> "Ave Imperator, victoritutititi [correct verb form please] te salutant"
16:01:47 <ski> @babel en la we who are about to succeed salute you
16:01:47 <lambdabot> Plugin `babel' failed with: Error: Language la not supported
16:01:56 <milaz> succedituri te salutant
16:01:57 <aristid> babel fail
16:02:07 <aristid> but google translate does not support it either
16:03:46 <ski> Boney_ : .. i wonder whether it would make sense to declare functional dependencies for type classes (in Mercury) as mode declarations
16:04:43 * ski looks up <http://www.mercury.csse.unimelb.edu.au/information/doc-latest/mercury_ref/Functional-dependencies.html> to check the current syntax
16:05:30 <ski> ok, like Haskell, i see
16:06:38 <milaz> Looks like it will be "Ave argentum vivum, progredituri te salutant."
16:06:52 <milaz> Nice latin naming for mercury, btw
16:07:29 <ski> (where ?)
16:07:58 <sipa> argentum vivum?
16:08:02 <milaz> in latin books, mercury was called argentum vivum (living silver)
16:08:09 <aristid> hydrargyrum?
16:08:24 <milaz> it's another name, water silver
16:08:31 <ski> (it is still called "kvicksilver" in swedish, cf. quicksilver)
16:08:47 <aristid> and Quecksilber in german
16:09:02 <roconnor> kvickcheque?
16:09:05 <milaz> hmm... i never understood until now what does quicksilver stands for
16:09:26 <milaz> i always thought it's like easy money :)
16:10:21 <sipa> in dutch it's simply 'kwik'
16:10:51 <aristid> milaz: right, if you convert quicksilver into gold, that's easy money
16:11:08 <milaz> eh, in russian it's ртуть (rtoot') and has no relation to silver (serebro)
16:11:11 * roconnor only knows how to turn lead into gold :(
16:12:02 <ddarius> Don't worry, both mercury and lead are poisonous.
16:12:20 <sipa> and gold?
16:12:48 <mercury^> :(
16:12:57 <roconnor> > There is an earlier report (1972) in which Soviet physicists at a nuclear research facility near Lake Baikal in Siberia accidentally discovered a reaction for turning lead into gold when they found the lead shielding of an experimental reactor had changed to gold. 
16:12:57 <lambdabot>   <no location info>: parse error on input `in'
16:14:16 <sipa> so, through currying you could change (mercury^) into (gold^) ?
16:14:19 <aristid> roconnor: make your quotes syntactically correct haskell, man
16:14:32 <roconnor> > do There is an earlier report (1972) in which Soviet physicists at a nuclear research facility near Lake Baikal in Siberia accidentally discovered a reaction for turning lead into gold when they found the lead shielding of an experimental reactor had changed to gold. 
16:14:33 <lambdabot>   <no location info>: parse error on input `in'
16:14:35 <roconnor> :(
16:14:41 <Boney_> ski: I havn't read up about functional dependencies enough to comment.
16:14:50 <robogeoff> i am trying to define a category instance for a product, but i am getting a kind error (http://gist.github.com/635236).  any ideas?
16:14:51 <ski> ok
16:14:58 <sipa> > -- There is an earlier report (1972) in which
16:14:59 <lambdabot>   not an expression: `-- There is an earlier report (1972) in which'
16:15:05 <aristid> > const () "There is an earlier report (1972) in which Soviet physicists at a nuclear research facility near Lake Baikal in Siberia accidentally discovered a reaction for turning lead into gold when they found the lead shielding of an experimental reactor had changed to gold."
16:15:06 <lambdabot>   ()
16:15:14 <milaz> tada!
16:15:22 <milaz> can anybody advice me, please, is replicateM (without underscore) a sure way to memory leak when used with IO and large numbers?
16:15:38 <Lemmih> milaz: Yes.
16:15:49 <Boney_> ski: but I think, (and this probably isn't the oppionion of the other developers) that the mode, determinism and purity systems should not be seperate.
16:16:11 <Boney_> every constraint, including the type system should be all part of the one system.
16:16:25 <Boney_> any other arrangement can make things difficult.
16:16:33 <aristid> milaz: depends how you define leak
16:16:40 <ski> robogeoff : `instance (Category c1,Category c2) => Category (c1,c2)' is a kind error, `c1,c2 :: * -> * -> *', and `(,) :: * -> * -> *'. `* -> * -> *' does not match `*'
16:16:49 <Boney_> for example Predicates as higher order values (packed into structures) are clumbsy wrt the mode system.
16:17:06 <copumpkin> robogeoff: you can write a product though
16:17:07 <Boney_> since modes don't usually apply to data strctures (only types do).
16:17:21 <Boney_> but modes have to in order to allow predicates to be first class,
16:17:22 <roconnor> @src replicateM
16:17:22 <lambdabot> replicateM n x = sequence (replicate n x)
16:17:24 <ski> Boney_ : i was pondering termination the other day too .. thinking it possibly should be part of mode declarations
16:17:35 <Boney_> but they're clumbsy first class citizens.
16:17:38 <roconnor> @src sequence
16:17:38 <lambdabot> sequence []     = return []
16:17:38 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:17:38 <lambdabot> --OR
16:17:38 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
16:17:39 <robogeoff> hmm, i think i understand why the type system doesn't like it, but i am not sure how to fix it :/
16:17:43 <copumpkin> data Product c d x y = Product (c x y) (d x y)
16:18:09 <copumpkin> instance (Category c, Category d) => Category (Product c d)
16:18:11 <milaz> aristid: huge increase of memory occupied by program when I use replicateM 1024^2 (fmap B.length $ B.hGet h 1024)
16:18:29 <robogeoff> copumpkin: i see why that would work, but it isn't general enough right?
16:18:37 <milaz> where B is ByteString
16:18:50 <copumpkin> robogeoff: it's as general as what I'd interpret your intent in the original as being?
16:18:53 <ski> Boney_ : another thing which i pondered is that maybe we should be able to have different modes for a type class, each specifying differing modes for the operations
16:18:58 <aristid> milaz: well that's logical. it evaluates all actions and puts them into a list, before proceeding
16:19:02 <roconnor> milaz: looks like a good way to leak memory.  If the output was discarded it'd be nice if GHC were smart enough not to allocate it at all, but I fear it isn't that wise
16:19:02 <milaz> in fact, I just want to calculate sum of these lengths. I did 5 variants of the code, and all of the are ugly :(
16:19:03 <ddarius> The Category type class is a good example of where kind polymorphism and kind products would be useful.
16:19:07 <Boney_> Yeah, "quicksilver" is a nick-name for Mercury in english.
16:19:08 <copumpkin> yeah :/
16:19:44 <ski> ddarius : seconded
16:19:50 <robogeoff> doesn't that Product restrict the product category to A x A
16:19:55 <robogeoff> but i want A x B
16:20:17 <roconnor> milaz: sounds like an interseting problem.
16:20:18 <milaz> roconnor: to discard the result I use replicateM_ and it works. But in this case, I have to calculate the sum.
16:20:29 <ski> robogeoff : the categories are already restricted to `*' (or any two specific kinds)
16:20:40 <ski> robogeoff : we want kind polymorphism
16:20:57 <robogeoff> oh i see
16:21:00 <copumpkin> and constraint families
16:21:13 <robogeoff> actually, that is really interesting
16:21:19 <robogeoff> ok
16:21:21 <roconnor> I wonder if this is a job for hyloM
16:21:24 <ski> and something to be able to say `x :: t' where `t' doesn't have kind `*', i think
16:21:25 <Boney_> ski: that sounds confusing (different modes for a type class).
16:21:27 <robogeoff> thanks ski and copumpkin!
16:21:46 <copumpkin> np :)
16:22:27 <ski> Boney_ : the idea occured to me when i was considering a `monoid' typeclass .. in some cases, one'd like to be able to run the monoid operations backwards, but that might not be possible in all instances
16:22:31 <roconnor> hyloM :: (T.Traversable f, Monad m) => (a -> m (f a)) -> (f b -> m b) -> a -> m b
16:22:32 <roconnor> hyloM g f = f <=< T.mapM (hyloM g f) <=< g
16:22:54 <djahandarie> Haha
16:22:59 <ski> Boney_ : i'm not sure how generally useful the idea would be .. it was just something to consider
16:23:04 <Boney_> ski: you can certainly require the predicates within the typeclass to have multiple modes.
16:23:18 <djahandarie> Doesn't flow as nice as cata g . ana h for some reason
16:23:31 <ski> Boney_ : yeah, but then every instance must support every mode (afaiu)
16:23:39 <Boney_> but are you asking about parametising the typeclass with modes?.
16:23:48 <milaz> roconnor: wow, I need a couple of minutes to understand how it work, thanks.
16:24:01 <ddarius> @where evolution
16:24:01 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
16:24:07 <ddarius> That might help.
16:24:23 <Boney_> ski: so I think I understand, but I'm going to go make a coffee :-)
16:24:42 <milaz> roconnor: the prettiest idea I came to was to create a function Int -> IO Int and chain then 1024^2 times, and give zero on the starting end of the chain.
16:24:44 <roconnor> @type let hyloM :: (a -> IO [a]) -> ([b] -> IO b) -> a -> IO b in hyloM (flip replicateM) (return . sum)
16:24:45 <lambdabot>     The type signature for `hyloM' lacks an accompanying binding
16:24:45 <lambdabot> Not in scope: `hyloM'
16:24:52 * ski . o O ( "(kata k .) . ana" )
16:24:55 <roconnor> @type let hyloM :: (a -> IO [a]) -> ([b] -> IO b) -> a -> IO b; hyloM = undefined in hyloM (flip replicateM) (return . sum)
16:24:56 <lambdabot>     Couldn't match expected type `IO (a -> [a])'
16:24:56 <lambdabot>            against inferred type `Int -> m a1 -> m [a1]'
16:24:57 <lambdabot>     In the first argument of `flip', namely `replicateM'
16:25:12 <ski> Boney_ : and i should be going to bed :)
16:25:15 <milaz> roconnor: these functions would add their input number to the length of the read buffer
16:25:20 <roconnor> @type let hyloM :: (a -> IO [a]) -> ([b] -> IO b) -> a -> IO b; hyloM = undefined in hyloM (replicateM 1000) (return . sum)
16:25:20 <lambdabot>     Occurs check: cannot construct the infinite type: a = IO a
16:25:21 <lambdabot>       Expected type: a
16:25:21 <lambdabot>       Inferred type: IO a
16:25:59 <Boney_> ski: ah, 10:30 in the morning here, time to begin work.
16:26:17 <Boney_> ski: do you follow the mailing lists?  mercury-reviews?
16:26:41 <milaz> roconnor: I did like this: (chain 1024^2 f) 0
16:26:49 <milaz> f :: Int -> IO Int
16:27:11 <ski> Boney_ : not continuously, but i try to look into them from time to time, to see if there's anything interesting that has been discussed in the last 2-3 months
16:27:40 <roconnor> hmm, these hyloM types are not working out for me.
16:27:50 <ski> (including `developers', and sometimes `reviews' as well)
16:27:51 <roconnor> milaz: what is chain?
16:27:59 <copumpkin> do IEEE floats have different endiannesses?
16:28:09 <Boney_> ski: cool, well hopefully peole can begin to play with auto-parallelism by our next release, no promises though..
16:28:23 <milaz> something like this: chain 0 f = f
16:28:24 <ski> sounds cool !
16:28:29 <djahandarie> Is Mu in lambdabot?
16:28:32 <ski> yes
16:28:33 <copumpkin> djahandarie: yeah
16:28:33 <djahandarie> @type Mu
16:28:34 <lambdabot> Not in scope: data constructor `Mu'
16:28:36 <milaz> chain n f = f >=> chain (n-1) f
16:28:37 <copumpkin> :k Mu
16:28:38 <lambdabot> (* -> *) -> *
16:28:38 <djahandarie> err
16:28:39 <djahandarie> lol
16:28:40 <djahandarie> Yeah
16:28:41 <copumpkin> :t In
16:28:42 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
16:28:43 <ski> > fix (In . Just)
16:28:44 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
16:28:47 <djahandarie> Nice
16:28:51 * ddarius thinks he'll pursue a solution using recursive helping.
16:28:51 <Boney_> copumpkin: I thinkthe endianness is always the same.
16:28:57 <milaz> roconnor: after I added strictness, it started to work
16:28:58 <aristid> :t In . Just
16:28:59 <lambdabot> Mu Maybe -> Mu Maybe
16:29:04 <copumpkin> Boney_: I thought so too, but then I remember someone telling me it wasn't
16:29:10 <roconnor> @type iterateM
16:29:11 <lambdabot> Not in scope: `iterateM'
16:29:13 <roconnor> :)
16:29:16 <milaz> roconnor: in fact, it's uglier than written here
16:29:19 <djahandarie> @type in
16:29:20 <lambdabot> parse error on input `in'
16:29:28 <ski> (ddarius : recursively help yourself to the nearest donuts ? ;)
16:29:39 <copumpkin> :t out
16:29:40 <lambdabot> forall (t :: * -> *). Mu t -> t (Mu t)
16:29:41 <roconnor> milaz: it is a fine solution
16:29:44 <Boney_> copumpkin: I have also heard statements to the contrary, so I'm not sure.
16:30:04 <roconnor> @type unfoldr
16:30:05 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:30:45 <roconnor> I wish there was a type for /\ x -> Maybe (a,x)
16:31:05 <roconnor> OpenList
16:31:28 <ski> @unmtl StateT s Maybe a
16:31:28 <lambdabot> s -> Maybe (a, s)
16:31:35 <Psytonic> anyone here have experience with complex numbers in haskell
16:31:37 <roconnor> milaz: there are ways of modularizing your code, but they appear to be a little tricker than would be worth while.
16:31:38 <aristid> roconnor: but what would you be able to use that for?
16:31:46 <roconnor> aristid: hyloM
16:31:49 <djahandarie> Psytonic, probably a bunch of people
16:31:55 <ski> @type unfoldr . runStateT
16:31:56 <lambdabot> forall b a. StateT b Maybe a -> b -> [a]
16:32:06 <ski> @type Reader . unfoldr . runStateT
16:32:07 <lambdabot> forall r a. StateT r Maybe a -> Reader r [a]
16:32:25 <McManiaC> @. type pl \x -> x*x
16:32:26 <lambdabot> forall a. (Num a) => a -> a
16:32:28 <aristid> ski: nice
16:32:29 <McManiaC> :D
16:32:57 <ski> you can also write an `State rs a -> Reader rs [a]'
16:33:10 <milaz> roconnor: thanks
16:33:16 <ski> roconnor : ^ ?
16:33:40 <roconnor> ski: what am I looking at?
16:33:44 <milaz> roconnor: I'll post into some pastebin in several minues :)
16:34:30 <ski> roconnor : hm, sorry, you had `/\ s -> Maybe (a,s)', not `/\ a -> Maybe (a,s)' .. nevermind :/
16:34:48 <ski> (though maybe you can swap your pairs ?)
16:34:58 <roconnor> ski: either way si fine
16:36:09 * ski wonders what roconnor wanted `/\ x -> Maybe (a,x)' for ..
16:36:44 <copumpkin> @hackage macho
16:36:44 <lambdabot> http://hackage.haskell.org/package/macho
16:38:04 <roconnor> @type let hyloM :: (a -> IO (Maybe (x,a)) -> (Maybe (x,b) -> IO b) -> a -> IO b; hyloM = undefined in hyloM (\l -> case l of [] -> return Nothing | (h:t) -> h >>= \x -> (x,t)) (return . maybe 0 (uncurry (+)))
16:38:05 <lambdabot> parse error on input `;'
16:38:14 <roconnor> ski: either way is fine
16:38:23 <copumpkin> (a -> b -> c), (c -> (a, b))
16:38:26 <ski> @hackage wimp
16:38:26 <lambdabot> http://hackage.haskell.org/package/wimp
16:38:27 <copumpkin> the lack of symmetry there bothers me
16:38:42 <copumpkin> I could make it (a, b) -> c and c -> (a, b)
16:39:05 <copumpkin> but it feels like there should be a counterpart to the curried form for the c -> (a, b) one
16:39:08 <Psytonic> how do I make a complex number from polar form instead of cartesian?
16:39:08 <kwikness> what is haskell useful for?
16:39:09 <copumpkin> not that I know what it would be
16:39:10 <djahandarie> ski, there are no wimps using Haskell!
16:39:12 <copumpkin> kwikness: programming
16:39:23 <kwikness> copumpkin, i was looking for a more specific answer
16:39:30 <aristid> ski: i really gotta keep that unfoldr . runStateT trick in mind
16:39:36 <copumpkin> kwikness: it's a general-purpose programming language. What is java good for?
16:39:36 <ski> djahandarie : maybe LHC will introduce them !?
16:39:40 <kwikness> copumpkin, what's the advantage over other languages (java, c++)
16:39:41 <djahandarie> kwikness, high-assurance programming
16:39:55 <ski> (<http://en.wikipedia.org/wiki/MACHO> and <http://en.wikipedia.org/wiki/WIMP>)
16:39:55 <Psytonic> kwikness: also very good for maths based programming
16:40:11 <roconnor> @type let hyloM :: (a -> IO (Maybe (x,a))) -> (Maybe (x,b) -> IO b) -> a -> IO b; hyloM = undefined in hyloM (\l -> case l of [] -> return Nothing; (h:t) -> h >>= \x -> return (return (x,t))) (return . maybe 0 (uncurry (+)))
16:40:12 <lambdabot> forall a. (Num a) => [IO a] -> IO a
16:40:13 <copumpkin> kwikness: good compile-time guarantees of correctness (if you choose to specify them), amazing capacity for abstraction, enforced separation of concerns
16:40:17 <milaz> roconnor: here's the code: http://pastie.org/1234093
16:40:19 <roconnor> there we go!!
16:40:26 <djahandarie> kwikness, all sorts of neat optimizations can be done as well as everything copumpkin said
16:40:29 <copumpkin> kwikness: easier parallelism, concurrency (lots of different models)
16:40:42 <ddarius> copumpkin: (c -> a, c -> b)
16:40:56 <milaz> for me it looks dirty, I used that in Haskell there's the cycle for everyting
16:41:01 <kwikness> i can't believe this channel is so huge and i'd never heard of haskell until recently
16:41:06 <roconnor> milaz: but it works?
16:41:09 <ski> kwikness : can be prototyping
16:41:19 <milaz> roconnor: yes :)
16:41:27 <milaz> roconnor: in constant space
16:41:44 <roconnor> milaz: let me try my crazy hylomorphism
16:41:45 <ski> copumpkin : well, there's cocurrying ..
16:41:47 <djahandarie> kwikness, http://tryhaskell.org if you haven't yet :)
16:41:57 <Psytonic> how do I make a complex number from polar form
16:42:01 <kwikness> can i name my variables 'numults' if i want to?
16:42:10 <kwikness> its really important to me
16:42:17 <djahandarie> Psytonic, I don't think there is a function in the library for that
16:42:22 <copumpkin> kwikness: uh, sure
16:42:23 <djahandarie> Psytonic, you could write it yourself obviously
16:42:28 <kwikness> phew..
16:42:32 <Psytonic> djahandarie: disapointing ><
16:42:33 <ddarius> djahandarie: There are a couple that come close.
16:42:36 <milaz> I came from Lisp, and when I had to check some Lisp code back, I was surprised: where's these cozy folds and sums, and so on. Why do I have to write all these lengthy loops :)
16:42:40 <ddarius> > cis (pi/2)
16:42:41 <lambdabot>   6.123233995736766e-17 :+ 1.0
16:42:41 <copumpkin> ddarius: hmm, okay
16:42:47 <copumpkin> ski: what's that?
16:42:56 <milaz> I believe, there's some short operator in Haskell for what I've written :)
16:43:03 <ddarius> > exp (0 :+ pi/2 )
16:43:04 <lambdabot>   6.123233995736766e-17 :+ 1.0
16:43:06 <Psytonic> ddarius: aaah
16:43:42 <Psytonic> so something like a e^ (b*i) would be a * cis(b)?
16:43:42 <ski> copumpkin : `Either a b -> c  ~=  a -> (b -< c)'
16:43:47 <djahandarie> Wait, there is mkPolar
16:43:53 <aristid> :t cis
16:43:54 <lambdabot> forall a. (RealFloat a) => a -> Complex a
16:43:55 <ddarius> @hoogle a -> a -> Complex a
16:43:56 <lambdabot> Data.Complex (:+) :: a -> a -> Complex a
16:43:56 <lambdabot> Data.Complex mkPolar :: RealFloat a => a -> a -> Complex a
16:43:56 <lambdabot> Prelude asTypeOf :: a -> a -> a
16:44:19 <Psytonic> djahandarie: I missed that...how did i miss that
16:44:26 <copumpkin> ski: what's -< ? :P
16:44:29 <ski> copumpkin : `b -< c' being the "subtraction" type of "function contexts" to `b' from `c'
16:44:55 <ski> copumpkin : each value of type `b <- c' contains a value of type `c', and a continuation accepting a value of type `b'
16:44:56 <aristid> ski: wut
16:45:07 <ski> er, of type `b -< c', i meant
16:45:25 <ddarius> @src mkPolar
16:45:25 <lambdabot> mkPolar r theta  =  r * cos theta :+ r * sin theta
16:45:33 <ski> @src cis
16:45:33 <lambdabot> cis theta    =  cos theta :+ sin theta
16:45:44 * djahandarie -> home, rather than chatting on IRC till eternity
16:46:06 <copumpkin> djahandarie: you mentioned wanting to do a talk at boston haskell
16:46:23 <copumpkin> djahandarie: you can take my slot for next time if you want :P there'll be lots of types if ddarius does type-level haskell and I do agda
16:46:27 <ZloiKotFAQ> heeeeeelp!!!!!!!!!!!!!!
16:46:27 <copumpkin> I can take the next one
16:46:33 <ZloiKotFAQ> people!!!!!!!! 
16:46:42 <ddarius> copumpkin: I'm not doing type-level Haskell.
16:46:44 <djahandarie> copumpkin, I was planning on doing one on types actually
16:46:48 <copumpkin> ddarius: oh?
16:46:57 <aristid> @faq people!!!
16:46:57 <ddarius> copumpkin: However, my talk should dovetail into yours fairly well.
16:46:57 <lambdabot> The answer is: Yes! Haskell can do that.
16:47:03 <copumpkin> ooh okay
16:47:08 <ski> ZloiKotFAQ : what's going on ? what's you'r haskell question ?
16:47:19 <ddarius> copumpkin: Assuming of course I get my shit together.
16:47:19 <Psytonic> all i want to do is solve a cubic function, whys it so fking complicated!
16:47:19 <ski> s/you'r/your/
16:47:21 <Psytonic> lol
16:47:29 <ZloiKotFAQ> Does anyone know a little bit assembler?
16:47:32 <copumpkin> ddarius: "Derek Elkins (ddarius on #haskell) will be giving a talk introducing type-level programming in Haskell."
16:47:32 <djahandarie> Now before anything else distracts me
16:47:36 * djahandarie gone
16:47:36 <ddarius> Psytonic: It could be worse, you could be trying to solve a quintic function.
16:47:42 <copumpkin> ddarius: what will it be, instead?
16:47:46 <Psytonic> ddarius: i suppose
16:47:48 <ddarius> copumpkin: Yes, Ed misheard/misunderstood what I said.
16:47:55 <astroboy> I am trying to figure out how indentation works in haskell-mode but I'm not able to
16:47:57 <copumpkin> aha
16:48:14 <ddarius> copumpkin: Type-ful- programming.  I.e. enforcing invariants with types, type-directed code generation, and similar things.
16:48:14 <aristid> astroboy: just hit TAB until it is remotely acceptable
16:48:17 <ZloiKotFAQ> ??????
16:48:19 <Psytonic> PLEASE pass type checking
16:48:20 <ski> ZloiKotFAQ : i know a bit of 6502 assembler, if that helps .. but i still fail to see how this has anything to do with Haskell
16:48:29 <copumpkin> ddarius: sounds great
16:48:29 <ZloiKotFAQ> T_T 
16:48:45 <ski> ZloiKotFAQ : are you maybe writing a compiler in Haskell ?
16:48:49 <milaz> ZloiKotFAQ: there's also #asm channel, full of people who definitely know it
16:48:51 <copumpkin> ZloiKotFAQ: this is #haskell, we talk about the haskell programming language and related topics :)
16:49:26 <mietek> roconnor, Botje: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.6.7806
16:49:46 <ZloiKotFAQ> simply help T_T  please
16:49:56 <mietek> Erlang-Style Distributed Haskell (1999) by Frank Huch Lehrstuhl, Frank Huch
16:50:06 <copumpkin> ZloiKotFAQ: can you tell me how to fix my renault deux cheveux? the engine doesn't start and I don't know what to do
16:50:35 <aristid> mietek: 1999 oO
16:50:36 <copumpkin> ZloiKotFAQ: if you go to the right place and ask the right people, they can help better than going to the wrong place and asking the wrong people
16:50:44 <mietek> aristid: hm?
16:50:54 <aristid> mietek: that's old :D
16:50:56 <ZloiKotFAQ> I'm just learning
16:51:08 <ski> learning Haskell ?
16:51:12 <ski> @where lyah
16:51:12 <lambdabot> http://www.learnyouahaskell.com/
16:51:15 <ski> see that ^
16:51:18 <copumpkin> ZloiKotFAQ: and we've told you that #asm is a better place to learn the stuff you seem to be after
16:51:22 <roconnor> milaz: still here?
16:51:29 <milaz> roconnor: yes
16:51:31 <copumpkin> ZloiKotFAQ: type /join #asm and you will find people who can answer your questions
16:51:37 <mietek> aristid: Haskell and Erlang are both >20 years old
16:51:42 <roconnor> milaz: you have a test file called "0" ?
16:51:55 <milaz> yes, 1 Gb of size
16:52:06 <roconnor> milaz: what is in it?
16:52:08 <aristid> roconnor: btw. i have another idea for your forall x. a -> (a, x) thing
16:52:09 <mreh> they see me codin'
16:52:15 <copumpkin> dd if=/dev/zero of=/0 bs=1024 count=1024
16:52:27 <aristid> roconnor: ChoiceT from monadLib looks pretty similar
16:52:31 <ddarius> copumpkin: /0 ?
16:52:32 <ZloiKotFAQ> Processor i8080, number 100 (1100100) podchitat in this number of zeros and ones
16:52:39 <milaz> roconnor: I made it with previous haskell program which tested speed of writing data into file
16:52:40 <ski> aristid : s/forall x./\/\\ x./
16:52:40 <copumpkin> ddarius: a file called 0 apparently!
16:52:45 <roconnor> aristid: possibly
16:52:48 <ddarius> copumpkin: In the root directory?
16:52:51 <copumpkin> why not
16:52:57 <aristid> ski: is that different?
16:53:06 <roconnor> copumpkin: that is only 1 MB
16:53:11 <copumpkin> roconnor: yeah, I misread
16:53:16 <milaz> roconnor: there's full file of zeroes
16:53:24 <copumpkin> make yourself 1048576 or whatever 2^20 is in count
16:53:25 <roconnor> 1024^2
16:53:30 <roconnor> > 1024^2
16:53:30 <ski> aristid : yes. `(forall a. Maybe a) :: *' while `(/\ a. Maybe a) :: * -> *', e.g.
16:53:31 <lambdabot>   1048576
16:53:36 <milaz> dd if=/dev/zero of=/0 bs=1024 count=1024k
16:53:46 <milaz> or K...
16:53:49 <milaz> hmmm....
16:53:51 * ddarius probably would have raised bs not coun...
16:53:58 <aristid> ski: the latter is not valid haskell tho :P
16:53:59 <ski> aristid : the `/\' that roconnor wrote is just a type-level lambda
16:54:04 <ZloiKotFAQ> I understand very little English to the same))
16:54:31 <ZloiKotFAQ>  
16:54:45 <ZloiKotFAQ> help 
16:54:49 <milaz> ddarius: startup disc creator's developers raised bs once, with count=1. The killed my computer :)
16:55:04 <ddarius> milaz: 1MB blocks shouldn't be too bad.
16:55:17 <milaz> ddarius: yes, that's fine
16:55:59 <milaz> ZloiKotFAQ: эй, чувак! там есть канал #asm, по ассемблеру. Тут говорят про Хаскелл, совсем другой язык программирования.
16:56:31 <ZloiKotFAQ> milaz: , ^^ 
16:56:38 <mreh> whatever happened to those guys making games with FRP?
16:56:41 <roconnor> milaz: how long doest your readTest take?
16:56:58 <mreh> they were looking for recruits not long ago
16:57:55 <mreh> preflex seen luiqui
16:57:57 <preflex>  Sorry, I haven't seen luiqui
16:58:00 <mreh> preflex seen luqui
16:58:01 <preflex>  luqui was last seen on #haskell 132 days, 14 hours, 20 minutes and 8 seconds ago, saying: Hi.  Is there a LANGUAGE parameter to enable all Haskell 2010 features?
16:58:02 <HugoDaniel2> hpaste is down :8
16:58:03 <HugoDaniel2> :(
16:58:15 <mreh> HugoDaniel2: glad you could make the party
16:58:17 <milaz> roconnor: about 11 seconds
16:58:41 <milaz> roconnor: that's average speed of my hard drive :)
16:59:01 <mreh> 11 meters per second?
16:59:23 <sipa> that's like 1/1000 of the escape velocity of the earth
16:59:24 <sipa> wow!
16:59:27 <milaz> mreh: 1Gb per 11 seconds
16:59:49 <Psytonic> W00T!!!!!
16:59:53 <Psytonic> damn I'm good
16:59:57 <ski> > 1024^2 * 8 / 11
16:59:58 <lambdabot>   762600.7272727273
17:00:19 <ski> er
17:00:24 <ski> > 1024^3 * 8 / 11
17:00:25 <lambdabot>   7.809031447272727e8
17:00:57 <Psytonic> foldl (++) (reverse ["good", "I\'m", "damn"])
17:01:01 <Psytonic> > foldl (++) (reverse ["good", "I\'m", "damn"])
17:01:02 <lambdabot>   Overlapping instances for GHC.Show.Show
17:01:02 <lambdabot>                              ([[[GH...
17:01:05 <Psytonic> aw
17:01:26 * ski hands Psytonic a `foldl1'
17:01:30 <copumpkin> or a []
17:01:34 <sipa> foldl (++) "" (reverse ["good", "I\'m", "damn"])
17:01:37 <sipa> > foldl (++) "" (reverse ["good", "I\'m", "damn"])
17:01:38 <lambdabot>   "damnI'mgood"
17:01:41 <Psytonic> yeah my bad
17:01:43 <Psytonic> :P
17:01:50 <milaz>  > 1024^2 / 11
17:01:55 <ddarius> Please don't foldl (++).
17:01:58 <Psytonic> > foldl1 (++) (reverse [" good", " I\'m", "damn"])
17:01:59 <lambdabot>   "damn I'm good"
17:02:05 <milaz> > 1024^2 / 11
17:02:06 <lambdabot>   95325.09090909091
17:02:06 <Psytonic> thats the one
17:02:08 <sipa> @pl \x y -> x ++ " " ++ y
17:02:09 <lambdabot> (. (' ' :)) . (++)
17:02:15 <milaz> 95 Mbps
17:02:22 <ski> > foldl1 (++) (repeat "!")
17:02:29 <sipa> > foldl ((. (' ' :)) . (++)) "" (reverse ["good", "I\'m", "damn"])
17:02:42 <lambdabot>   mueval: ExitFailure 1
17:02:46 <lambdabot>   mueval-core: Time limit exceeded
17:02:48 <milaz> Since the file was read several times, its somehow cached all the way down. In hardware, in OS...
17:03:14 <sipa> most likely your OS's io cache
17:05:10 <milaz> but I'm sure OS has no place to cache a whole gigabyte of data, if only it deminstrated its intellect and recorded it as 1024^3 * '\0'
17:05:29 <milaz> *demonstrated
17:05:43 <sipa> how much memory do you have, and what OS?
17:06:22 <dancor> is there work on version controlling data structures
17:06:27 <milaz> 512 Mb RAM on Ubuntu 10.10 (2.6.35-22)
17:06:44 <sipa> in that case, no :D
17:06:51 <copumpkin> dancor: with immutability, you get that for free ;)
17:07:13 <milaz> spia: and there's any cases when taht will happen?
17:07:25 <milaz> *that
17:07:36 <milaz> sorry, fingers are interweaving :)
17:07:38 <dancor> copumpkin: but i want to let a user modify a graph, save the whole history to disk, and deal with merging with interactive conflict resolution
17:07:53 <ddarius> dancor: There's quite a bit of old work on that for making data structures persistent.  Image-based systems like Smalltalk might also have a different perspective on that problem.
17:08:31 <roconnor> milaz: ah my hylomorphism failed :(
17:08:45 <ddarius> roconnor: Stack overflow?
17:09:00 <milaz> roconnor: my condolescences :(
17:09:10 <roconnor> ddarius: I killed it as it started gobbling up memory
17:09:37 <dancor> i'm thinking about a method where i rely on a git repo with a custom merge driver.  but i guess touching disk that often is a potential weakness of the method.
17:09:40 <milaz> roconnor: the pattern looks so familiar to me
17:09:55 <milaz> roconnor: I can't believe there's no such construct
17:10:21 <roconnor> milaz: I could just suck at making hyloMs
17:11:07 <ddarius> milaz: The Iteratee stuff that everyone has their knickers in a bunch about handle the kind of scenario you describe.
17:11:17 <milaz> roconnor: actually I don'e even know anything about *morphisms beyondt some of their names.
17:12:08 <milaz> ddarius: that is a good idea.
17:12:42 <milaz> ddarius: I saw there's a tutorial by Michael Snoyman on them, I will see it soon
17:17:31 <roconnor> @src foldl'
17:17:31 <lambdabot> foldl' f a []     = a
17:17:32 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:17:59 <roconnor> aww crap 
17:18:06 <roconnor> hylomorphims give me foldrf
17:18:08 <roconnor> foldr
17:18:12 <ddarius> Indeed.
17:18:25 <roconnor> this idea was doomed from the start
17:19:40 <djahandarie> lol
17:20:06 <djahandarie> "Look at all this neat abstract code!!" (20 minute later) "Damn. This doesn't work at all."
17:21:32 <roconnor> @src forM
17:21:32 <lambdabot> forM = flip mapM
17:21:55 <roconnor> @type foldMap
17:21:56 <lambdabot> Not in scope: `foldMap'
17:22:14 * roconnor doesn't know any monadic left fold, but it feels familiar
17:23:12 <roconnor> @hoogle foldM
17:23:13 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
17:23:13 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
17:23:13 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
17:23:17 <ddarius> djahandarie: And the other suggestion is left-fold enumerators based on delimited continuations.
17:23:22 <roconnor> @src foldM
17:23:23 <lambdabot> foldM _ a []     = return a
17:23:23 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
17:23:31 <ddarius> djahandarie: I thought you were gone though?
17:23:40 <djahandarie> I'm back now!
17:23:46 <roconnor> @src foldl
17:23:46 <lambdabot> foldl f z []     = z
17:23:46 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:23:51 <roconnor> @src foldl'
17:23:52 <lambdabot> foldl' f a []     = a
17:23:52 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:24:05 <Saizan> yes, foldM is a left fold
17:24:24 <roconnor> Saizan: can we use it to solve milaz's problem somehow?
17:24:53 <ddarius> Concurrent code is hard when you don't allocate.
17:25:50 <Saizan> roconnor: i wasn't following
17:27:22 <milaz> Saizan: in short, in http://pastie.org/1234093 there's function 'chain'
17:27:43 <milaz> it looks very familiar, but I don't remember what it should be
17:28:15 <roconnor> Saizan: milaz has an [IO Int] and want to return IO Int which contains the sum of the results of each action
17:28:46 <milaz> I could use sum with replicateM, it works, but eats lot of memory
17:28:51 <fxr> ?pl \a b -> a:b:[]
17:28:52 <lambdabot> (. return) . (:)
17:28:57 <ezyang> :t foldM 
17:28:58 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:29:10 <ezyang> That should work. 
17:29:56 <Saizan> yep
17:30:08 <roconnor> foldM (\a m -> m >>= \b -> let !c = (a + b) in return c) 0 
17:30:12 <roconnor> ^^ needs strictness
17:30:19 <ezyang> > foldM (\a m -> m >>= (a+)) 0 [return 12, return 13, []] 
17:30:20 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
17:30:27 <roconnor> milaz: ioSum = foldM (\a m -> m >>= \b -> let !c = (a + b) in return c) 0 
17:30:31 <ezyang> ah right 
17:30:35 <ddarius> roconnor: evaluate (a+b)
17:30:43 <roconnor> ddarius: even better 
17:30:44 <ezyang> > foldM (\a m -> m >>= (return . (a+))) 0 [return 12, return 13, []] 
17:30:45 <lambdabot>   []
17:30:57 <roconnor> milaz: ioSum = foldM (\a m -> m >>= \b -> let c = (a + b) in evaluate c >> return c) 0 
17:30:57 <ezyang> ah, yeah, good one. 
17:30:58 <Saizan> ?type evaluate
17:30:59 <lambdabot> Not in scope: `evaluate'
17:31:09 <Saizan> ?type Control.Exception.evaluate
17:31:10 <lambdabot> forall a. a -> IO a
17:31:32 <Saizan> so just "evaluate (a+b)" or "return (a+b)"
17:31:42 <Saizan> "return $! a + b" i meant
17:31:44 <milaz> evaluate is something like monadic seq?
17:32:12 <Saizan> sort of
17:32:16 <roconnor> djahandarie: once you learn about hyloM every problem looks like open recrusion ...
17:32:16 <ezyang> milaz: Stronger then that, IMO 
17:32:30 <Saizan> ezyang: in what way?
17:32:31 <roconnor> djahandarie: who would have thought of familiar foldM
17:32:31 <djahandarie> :P
17:32:54 <Saizan> roconnor: someone who knew sum is better written with foldl' ?:)
17:33:19 <roconnor> someone was trying to convince me only to use evaluate for controling exceptions.   I'm not entirely convinced yet.
17:33:35 <roconnor> Saizan: where is foldM' ?
17:33:40 <ezyang> erm, actually, more like weaker :o) 
17:34:05 <ezyang> (hnf versus whnf, I think) 
17:34:13 <Saizan> no, it's still whnf
17:34:15 <roconnor> oh wait my sumIO was more polymorphic before I used evaluate ...
17:34:17 <milaz> roconnor, ezyang, Saizan: thanks, I'm now checking it :)
17:34:54 <Saizan> the only difference between "return $! x" and "evaluate x" is that the latter only forces x when the action is executed, while the former when the action is evaluated
17:35:03 <djahandarie> roconnor, no, it had IO in the function name ;)
17:35:16 <Saizan> so i usually just stick with "return $! x"
17:35:43 <roconnor> djahandarie: should have been called sumM
17:35:49 <roconnor> or suMmmmm
17:36:33 <roconnor> sumM = foldM (\a m -> m >>= \b -> return $! (a + b)) 0 
17:36:37 <milaz> wow, monomorphism...
17:36:44 <roconnor> @type let sumM = foldM (\a m -> m >>= \b -> return $! (a + b)) 0  in sumM
17:36:45 <lambdabot> forall (m :: * -> *) a. (Num a, Monad m) => [m a] -> m a
17:37:19 <ddarius> @pl \a m -> m >>= \b -> return $! a + b
17:37:19 <lambdabot> (=<<) . ((return $!) .) . (+)
17:38:01 <copumpkin> mmm
17:38:14 <roconnor> why didn't I write that?
17:38:50 <roconnor> @type let sumM = foldM  (  0  in sumM
17:38:51 <lambdabot> parse error on input `in'
17:39:14 <Saizan> milaz: btw the ! in chain's definition wasn't needed, pattern matching with 0 already makes it strict in that parameter
17:39:23 <roconnor> @type let sumM = foldM ((=<<) . ((return $!) .) . (+))  0  in sumM
17:39:24 <lambdabot> forall (m :: * -> *) a. (Num a, Monad m) => [m a] -> m a
17:39:30 <mercury^> Why the ``let a = b in a'' if b contains no reference to a?
17:40:22 <Saizan> that exact expression is equivalnt to just b
17:40:31 <roconnor> mercury^: because I'm to lazy to erase (sumM = )
17:40:44 <djahandarie> Why let a = b in a if b contains a reference to a? ;)
17:41:15 <milaz> Saizan: !n -- yes, that was overkill
17:41:17 <mercury^> Because fix is ugly.
17:41:26 <roconnor> let sumM = foldM ((=<<) . ((return $!) .) . (+))  0  in runIdenity (sumM (map return [1..1000000]))
17:41:31 <roconnor> > let sumM = foldM ((=<<) . ((return $!) .) . (+))  0  in runIdenity (sumM (map return [1..1000000]))
17:41:32 <lambdabot>   Not in scope: `runIdenity'
17:41:39 <roconnor> > let sumM = foldM ((=<<) . ((return $!) .) . (+))  0  in runIdentity (sumM (map return [1..1000000]))
17:41:41 <lambdabot>   *Exception: stack overflow
17:41:46 <djahandarie> Typing-fu dropping to dangerously low levels
17:41:47 <roconnor> :(
17:41:48 <milaz> So, this works in constant space too:
17:41:49 <milaz> ioSum $ replicate (1024^2) (fmap B.length $ B.hGet h 1024)
17:41:59 <roconnor> milaz: yes
17:42:26 <milaz> roconnor: ok, I checked, it works nice
17:42:26 <roconnor> Saizan: why does my stack overflowith?
17:42:49 <roconnor> milaz: too bad the fancy smancy hyloM distracted me for so long
17:43:14 <Saizan> roconnor: Identity is a newtype
17:43:43 <roconnor> Saizan: shouldn't that make it more likely to work?
17:43:56 <milaz> roconnor: that's fine, thanks for help :)
17:43:58 <Saizan> return $! == \x -> x `seq` x for Identity, which is useless
17:44:15 <roconnor> @src foldl
17:44:15 <lambdabot> foldl f z []     = z
17:44:16 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:44:18 <roconnor> @src foldl'
17:44:18 <lambdabot> foldl' f a []     = a
17:44:18 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:44:35 <roconnor> hmm
17:44:44 <milaz> roconnor: In fact, I was looking on foldM signature in documentation, and thinking: "I won't trust it, I won't trust it" :)
17:44:45 <roconnor> @src foldM
17:44:46 <lambdabot> foldM _ a []     = return a
17:44:46 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
17:45:02 <Saizan> > let sumM = foldM ((=<<) . ((return $!) .) . (+))  0  in fromJust (sumM (map return [1..1000000]))
17:45:04 <lambdabot>   500000500000
17:45:35 <roconnor> foldl (+) 0 [1..1000000]
17:45:37 <roconnor> > foldl (+) 0 [1..1000000]
17:45:39 <lambdabot>   *Exception: stack overflow
17:45:50 <roconnor> Saizan: I'm a little confused
17:46:14 <milaz> ... that's because I still don't clearly understand how laziness and IO are matched together.
17:46:19 <milaz> foldl'  maybe
17:46:19 <Saizan> > let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM f fax xs; sumM' = foldM ((=<<) . ((return $!) .) . (+))  0 in runIdentity (sumM (map return [1..1000000]))
17:46:20 <lambdabot>   Not in scope: `sumM'
17:46:34 <Saizan> > let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM f fax xs; sumM = foldM' ((=<<) . ((return $!) .) . (+))  0 in runIdentity (sumM (map return [1..1000000]))
17:46:38 <lambdabot>   *Exc
17:46:45 <roconnor> milaz: it is not easy
17:46:49 <Saizan> ugh, wrong recursion
17:46:57 <Saizan> > let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM' f fax xs; sumM = foldM' ((=<<) . ((return $!) .) . (+))  0 in runIdentity (sumM (map return [1..1000000]))
17:46:59 <lambdabot>   500000500000
17:47:03 <ddarius> The ' convention has its problems.
17:47:12 <milaz> ... I try to unwrap all definitions mentally, but when I come to IO, which s black box, and I cannot unwrap anything
17:47:17 <roconnor> milaz: honestly, I'm a little surprised foldM works
17:47:40 <roconnor> milaz: think of IO as a free monad of FFI calls :)
17:47:47 <milaz> so, I guess, this kind of intuition will come to me with experience, I hope
17:48:02 <ddarius> milaz: IO actions don't touch their argument and results unless they do.
17:48:10 <roconnor> milaz: wait no, that won't help you understand space usage :D
17:48:12 <milaz> ddarius: lol
17:48:23 <ddarius> Certainly, if they are polymorphic in the argument/result they don't (modulo seq) which most IO actions don't use.
17:48:44 <milaz> ddarius: so, they keep them unchanged?
17:49:02 <roconnor> Saizan: ya, so that is the foldM' I was thinking of I guess.  I'm surprised that regular foldM works for milaz
17:50:15 <milaz> roconnor: probably, foldM' will work with summing function that's not strict?
17:50:37 <milaz> line sumM, but without $! 
17:50:39 <Saizan> roconnor: it works because IO's return is building some structure which will need to be evaluated before foldM can continue with the recursive call
17:50:54 <roconnor> Saizan: IO is lazy!
17:50:59 <ddarius> ioError
17:51:10 <Saizan> roconnor: _|_ >>= f = _|_
17:51:14 <roconnor> Saizan: IO Int is a lazy int.
17:51:32 <Saizan> roconnor: i'm not saying return forces the value
17:51:42 <ddarius> The question is whether (>>=) is lazy in the first argument or not.
17:52:01 <roconnor> ddarius: it is lazy in IO?
17:52:05 <Saizan> we use "return $!" to force the value when the result of return is forced
17:52:27 <Saizan> roconnor: no, it isn't, that's my point
17:52:32 <ddarius> roconnor: No, but it is for Identity.
17:52:56 <roconnor> ddarius: >>= is lazy in it's first argument for Idenity
17:53:05 <roconnor> ddarius: because Identity has a strict constructor?
17:53:42 <ddarius> roconnor: No because bind doesn't need to know anything about the first argument to continue.
17:53:55 <roconnor> hmm
17:54:02 <ddarius> @src Identity (>>=)
17:54:03 <lambdabot> m >>= k  = k (runIdentity m)
17:54:08 <wavewave> Does anyone know whether grapefruit is still being developed?
17:54:45 <wavewave> it is not update since Feb last year. 
17:54:49 <wavewave> updated.
17:55:02 <roconnor> ddarius: okay, and for IO >>= needs to traverse the IO tree to do subsitution at the leaves.
17:55:36 <roconnor> ddarius: in particular it needs to check to see if m is a leaf node or not
17:55:40 <ddarius> roconnor: If you want to take that view, or, you can just say it has to verify that its first argument isn't an exception to know whether it should continue or not.
17:57:38 <roconnor> > let sumM = foldM ((=<<) . ((return $!) .) . (+))  0  in  (sumM (map return [1..1000000])) 7
17:57:45 <lambdabot>   mueval: ExitFailure 1
17:58:09 <roconnor> let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM' f fax xs; sumM = foldM' ((=<<) . ((return $!) .) . (+))  0 in (sumM (map return [1..1000000])) 8
17:58:26 <roconnor> > let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM' f fax xs; sumM = foldM' ((=<<) . ((return $!) .) . (+))  0 in (sumM (map return [1..1000000])) 8
17:58:32 <lambdabot>   mueval-core: Time limit exceeded
17:58:36 <roconnor> :(
17:58:53 <roconnor> > let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM' f fax xs; sumM = foldM' ((=<<) . ((return $!) .) . (+))  0 in runIdenity (sumM (map return [1..1000000]))
17:58:55 <lambdabot>   Not in scope: `runIdenity'
17:58:58 <sipa> :t ($!)
17:59:00 <roconnor> > let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM' f fax xs; sumM = foldM' ((=<<) . ((return $!) .) . (+))  0 in runIdentity (sumM (map return [1..1000000]))
17:59:01 <lambdabot> forall a b. (a -> b) -> a -> b
17:59:04 <lambdabot>   50000
17:59:19 <roconnor> > let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM' f fax xs; sumM = foldM' ((=<<) . ((return $!) .) . (+))  0 in runIdentity (sumM (map return [1..1000000]))
17:59:22 <lambdabot>   500000500000
17:59:31 <roconnor> stupid weak head normal form
18:00:07 <ddarius>  > let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM' f fax xs; sumM = foldM' ((=<<) . (return .) . (+))  0 in runIdentity (sumM (map return [1..1000000]))
18:00:15 <ddarius> > let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM' f fax xs; sumM = foldM' ((=<<) . (return .) . (+))  0 in runIdentity (sumM (map return [1..1000000]))
18:00:17 <lambdabot>   500000500000
18:01:23 <roconnor> > let sumM = foldM ((=<<) . ((return $!) .) . (+))  0  in  runWriter (sumM (map return [1..1000000]))
18:01:29 <lambdabot>  Terminated
18:01:35 <roconnor> > let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM' f fax xs; sumM = foldM' ((=<<) . ((return $!) .) . (+))  0 in runWriter (sumM (map return [1..1000000]))
18:01:40 <lambdabot>   mueval-core: Time limit exceeded
18:01:50 <roconnor> :O
18:02:20 <milaz> that's surprising how lambdabot maintains itself in living state :)
18:02:22 <roconnor> > let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM' f fax xs; sumM = foldM' ((=<<) . ((return .) .) . (+))  0 in runWriter (sumM (map return [1..1000000]))
18:02:24 <lambdabot>   No instances for (GHC.Num.Num
18:02:24 <lambdabot>                      (Control.Monad.Writer.La...
18:02:37 <roconnor> > let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM' f fax xs; sumM = foldM' ((=<<) . ((return .) . (+))  0 in runWriter (sumM (map return [1..1000000]))
18:02:38 <lambdabot>   <no location info>: parse error on input `in'
18:03:03 <roconnor> > (7 $)
18:03:04 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
18:03:04 <lambdabot>    arising from a use of `...
18:07:38 <milaz> Again, thanks everybody, that was my most enlightening IRC session. :) Good bye.
18:10:23 <ezyang> good bye. Come back soon. 
18:11:06 <Veinor> is there a way to combine an m [a] and an (a -> m b) to get an m [b]?
18:11:30 <ezyang> i,i "list transformer" 
18:11:36 <Pseudonym> @hoogle m [a] -> (a -> m b) -> m [b]
18:11:37 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
18:11:37 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
18:11:37 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
18:11:42 <Pseudonym> forM
18:11:46 <roconnor> mapM!
18:11:50 <Pseudonym> Or mapM.
18:12:00 <Pseudonym> List transformer is argued, by some, to be broken.
18:12:03 <ezyang> but you'll need to =<< it in. 
18:12:09 <Pseudonym> As in it's not a real transformer.
18:12:14 <Veinor> oh wait, I'm in the monad, so I have an [a], not a m a
18:12:19 <Veinor> so forM/mapM works
18:12:19 <roconnor> Pseudonym: it only works on commutative monads, so I'm told.
18:12:26 <Pseudonym> Right.
18:12:53 <Pseudonym> NondetT or LogicT are better choices in general.
18:15:59 <Veinor> gah
18:16:22 <roconnor> Pseudonym: are they different?
18:16:37 <roconnor> Pseudonym: oh maybe some are continuation based?
18:17:07 <Pseudonym> LogicT allows for different search strategies.
18:17:22 <Pseudonym> And also has soft cut.
18:17:37 <dolio> LogicT doesn't do anything that [] can't.
18:17:46 <Pseudonym> Yes it does.
18:17:48 <dolio> Except perform better.
18:17:52 <Pseudonym> It's a transformer.
18:18:25 <dolio> Yeah, there's a corresponding ListT that isn't broken.
18:18:35 <Pseudonym> Right.
18:19:01 <dolio> I'm not even certain that LogicT is much faster anymore.
18:19:19 <dolio> Although, it's asymptotically faster for certain operations.
18:19:33 <dolio> Like left-nested appends.
18:19:34 <Pseudonym> It is more flexible, which is the main reason why you'd choose it.
18:21:12 <dolio> Anyhow, there's a MonadLogic instance for [].
18:21:14 <dolio> So it does all the interleaving and cut and whatnot.
18:24:12 * ddarius hasn't been singing enough lately.
20:27:00 --- topic: '["Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
20:27:00 --- topic: set by copumpkin on [Thu Aug 12 05:05:07 2010]
20:27:00 --- names: list (clog trin_cz Itkovian jayne amuck blackh jutaro bos xnyhps smorg tsbo otto_s_ JoeyA deech coolq s76 ablokzijl tg_ blbrown_win3 avicenna novas0x2a mac01021 dnolen _nickel conal amiri chessguy jlouis smadge_ jethomas Zeiris miclorb thetallguy kamatsu baldo1 dv- Draconx|Laptop ibid koninkje_away shachaf jcapper dqd ortmage muep klugez steve_himself Mitar alexsuraci zygoloid mornfall Boney_ Belgarion0 jpatota_ eyck Colours quaestor trez jlaire jrockway zaphar_ps)
20:27:00 --- names: list (maskd dionoea bezik DrSyzygy solidsnack dhouthoo adnap Nanar blackdog zakwilson_ ehamberg Ferdirand companion_square alek_br [mth] Jiten_ megajosh2 ninly emias Cobra tomaw dino- azaq23 companion_cube benmachine wuj LionMadeOfLions sonnym jmcarthur wisemanby cognominal killown Olathe path[l]2 Rembane2 dumael schroedi1bug Country-Strike guybrush FunctorSalad The_third_bug res_ majoh dMazzz Aisling_ slaye_ Fingerzm Unforgivable^ rdd` int-e_ eevar sipa_ wolf__)
20:27:00 --- names: list (srcerer hgolden Kanako helgikrs_ anyfoo jd10_ Firegolf1r wto_ Starfire_ Cale_ willb1 erk_ Muad_Dibber_ ernst ankit9_ edwtjo mietek_ gju_ hc_ mundkur_ kwuxalot_ skaar mauke frerich4 Vulpyne ski_ MoALTz_ mjonsson Mathnerd314 dolio banjiewen jonafan_ Pseudonym dju QinGW2 jad00 elpolloloco caligula_ bens Apocalisp dancor theorbtwo k7_ gbeshers u_quark saccade TacticalGrace Biggles Rotaerk kniu brushbox bremner nkpart kfish Dawgmatix mikeg EvanR-work adu anders^^)
20:27:00 --- names: list (tltstc danharaj bwr ikonia m3ga Kruppe perlite npouilla1d Sunhay_ kyagrd grahamalot JaffaCake1 Eridius And[y] Philonous siplux saurik stepkut waern snorble bremner` lsthemes medfly emmanueloga QtPlatypus regalia Rooz LouisJB LeoD woodworm fengshaun norm2782 niko infinity0 profmakx maurer_ ksf_ Draconx Jantaro PeakerWork Jafet tapwater ketil winxordie RyanT5000 araujo allbery_b angstrom malorie ptrf docl itsjar cozmic mun xinming Sup3rkiddo jpd hrmlgon2 boscop)
20:27:00 --- names: list (Vorpal pigoz andrewsw tensorpudding insomniaSalt dho ooooPsss rbarraud Ytinasni srh derekwright Gilly Carneus kadoban tromp_ regulate aristid jystic mun__ pikhq m4thrick ahf osfameron malthe bqf kolmodin byorgey toothbrush Valodim dmwit flori_ michie1_ Laney ksandstr dons Nshag pantski nchaimov ngochai nathanic kermit scm hackagebot CoryDambach Amadiro Modius rdrake sbahra duckinator PepeSilvia camio qz iFire ps-auxw ninegrid siracusa Sunhay HugoDaniel zachk)
20:27:00 --- names: list (Maxdamantus lispy ricky proq emma Axman6 wagle akosch g_cross KitB drhodes ray ville orlandu63 Innominate liesen Polarina rks Jaak jamwt_ tataa bd_ Raynes sidke wqe23 ClaudiusMaximus dcoutts_ cads augustss Berengal geekounet pettter Zao sproingie canvon peterhil tmuki Lemmih xmikedavis mattam impl lyn jjong Khisanth mjl dreixel Evanlec guerrilla FeiRuoWa Cthulhon| Paradox924X hamishmack andersk tcatipax int80_h janne nornagon PsiOmega chitragupt uber_mort)
20:27:00 --- names: list (saiam raek orbitz wjt scott_ dual sophacles gjl hvr shortcircuit luite alip DRMacIver ddarius Macha jedai_ joeytwiddle mindwarp Davsebamse aasmith__ Apocalisp_ palyboy Entroacceptor mwc aiko_ d-snp aluink monochrom dfeuer sshc dleslie ixzkn systemfault alexbobP mgsloan Xorlev poliquin svk_ mjgoins tafryn sajkr zomg `0660 vili devinus Philippa fserb dobblego hiredman jmv_ leoncamel dropdrive da-x integral mortberg gdsx Veinor dom96 Fullma res99 agemo boris``)
20:27:00 --- names: list (isionous teukka gwern dbelange fihi09 Twey TML _br__ alpounet marienz drbean nlogax andern helge__ encryptio_ noddy sShintah infoe Gabbie jql mkurkov tilman `0660__ Liskni_si go|dfish cncl electrogeek earthy snr burp lusory robinsmidsrod Saizan FauxFaux McManiaC lambdabot suiside MrDomino mrd bbee sohum miasma mrshoe KaneTW alios CompanionCube jix magicman dixie stepnem taruti welterde iratsu epmf MasseR eno netcat nasloc__ Sisu gds islands waterlaz CosmicRay)
20:27:00 --- names: list (shutdown_-h_now kaol Vq inr faj_ Ke cjay ath aleator OnionKnight opqdonut flux tridactyla tamiko hyko noj mq deavid EvanCarroll sbok MacCoaster rokoteko defn SubStack dax_ spetrea joni6128 jvogel tessier Nereid lucca csg harlekin palmje freedrull Miciah twn_ mercury^ clanehin sfvisser preflex fxr otulp ToRA emph jdsc StoneToad nimred Vanadium Raku^ johs Obfuscate absentia arkx lantti mlh qebab pkrumins _2x2l DustyDingo ibt stroan_ Deewiant ivan eregon)
20:27:00 --- names: list (spinlock kalven |marius| etpace quicksilver Tomas gereedy_ Zol olsner BONUS NotRoot pastorn Bassetts mafs mux shawn Blub\0 cathper slabanja lostman sid3k birkenfeld dilinger Ornedan obraun idoru davean Igloo epokal mjrosenb Botje jbauman Eelis xcvii HalfWayMan boyscared SimonRC inimino yahooooo elliottcable jml Martty ziman baaba cYmen duairc koala_man AnAdorableNick enthropy aempirei davidL djahandarie ahihi newsham alexsdutton nominolo tab thorkilnaur)
20:27:00 --- names: list (kosmikus creichen ido dcolish nothingmuch samulihs Reisen mvid BrianHV milli Stephan202 chromakode franksh_ @ChanServ cynick idnar deadguys)
20:28:27 <FunctorSalad> conal's tries use type families IIRC, as an example of "generic data structures with specialized reps"
20:29:13 <conal> right.  like linear maps.
20:29:22 <conal> and tries
20:29:26 <jmcarthur> yeah, and vector is actually an example of that too
20:29:38 <jmcarthur> although the memo tries are a cooler example
20:29:39 <conal> it is?
20:30:00 <jmcarthur> conal: for example, a vector of tuples is actually a tuple of vectors
20:30:04 <danharaj> are the metamathematics of type families worked out to a satisfactory degree yet?
20:30:31 <conal> jmcarthur: are you talking about a data parallel package?
20:30:56 <jmcarthur> conal: the vector package, which is now the basis of dph in ghc head
20:31:07 <conal> jmcarthur: ah.  i think that trick was the early motivating/driving example, from manuel.
20:31:14 * hackagebot text 0.9.1.0 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.9.1.0 (BryanOSullivan)
20:31:16 <conal> (example of assoc'd types)
20:31:20 <jmcarthur> yes
20:31:56 <dmwit> bos: your bitbucket links look broken from here
20:32:27 <bos> dmwit: yeah, i'm not ready with that yet
20:32:48 <dmwit> ah, shucks, I was hoping for a convenient changelog
20:32:49 <dolio> Any class with a fundep '<t> -> u' is an example of a type family, too.
20:32:54 <dolio> So, mtl.
20:33:20 <jmcarthur> or, more directly, monads-tf
20:33:29 <dolio> Right.
20:34:02 <dolio> Lots of collection classes use them, too.
20:34:16 <dolio> class Collection c where type Element c :: * ; ...
20:34:54 <jmcarthur> ah, that reminds me of the monoids package, which also uses associated data types for collections' element types
20:36:11 <bos> dmwit: http://bitbucket.org/bos/text
20:36:39 <bos> or http://github.com/bos/text
20:39:03 <dmwit> bos: Great!
21:36:08 <nomothetis> Out of curiosity, is there a way to turn off warnings when one uses -Wall?
21:36:34 <nomothetis> right now I'm getting a lot of warnings about values that are not functions being declared without type, but isn't that the point of type inference?
21:36:36 <bos> yes, -fno-whatever
21:37:04 <bos> you turn on -Wall first, then -fno-whatever to selectively disable things you turned on afterwards
21:37:55 <nomothetis> where can I find a list for the options that can be disabled?
21:40:08 <bos> the man page
21:40:32 <kyagrd> What would be a good solution for regexp and utf8 problems?
21:41:03 <kyagrd> I have to do like this ... mapM_ (mapM (putStrLn . decodeString)) (str =~ (encodeString multibytepattern) :: [[String]])
21:41:56 <nomothetis> bos ++ thanks.
22:25:34 <ologNation> With yi, I feel as though I ought to be able to precisely control the color of each character on the screen.  But can I?
22:28:48 * hackagebot web-encodings 0.3.0.2 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.3.0.2 (MichaelSnoyman)
22:39:58 <Samantha> Hello
22:40:38 <Samantha> Hello Notje are you there
22:41:18 <Samantha> hello
22:41:50 <Samantha> hello
22:42:16 <mtnviewmark> strangely quiet here tonight
22:42:31 <Samantha> Yeah so weird
22:42:41 <Samantha> this is not Haskell
22:42:47 <Samantha> channel
22:43:02 <Samantha> is everybody zzzzzzzz
22:43:16 <mtnviewmark> *I'm* coding Haskell
22:43:32 <Samantha> Good luck 
22:43:59 <Samantha> Hello
22:44:16 <Samantha> I want to talk to Botje
22:44:20 <RayNbow`TU> hmm... 7:43 AM already...
22:44:31 <Samantha> Are you here?
22:44:34 <Samantha> uhhhhhhh
22:44:50 <Samantha> hmm... 7:43 AM already...  where do you live?
22:45:02 <RayNbow`TU> The Netherlands
22:45:09 <Samantha> oh ok
22:45:12 <Samantha> no wonder
22:46:20 <Samantha> oh my 
22:46:26 <Samantha> god Haskell is good 
22:47:12 <Samantha> hi
22:47:34 <mtnviewmark> indeed...
23:00:06 <Axman6> Samantha: i thought you hated haskell?
23:00:49 <Samantha> I do
23:01:00 <Samantha> I am just kidding
23:01:17 <Samantha> i am still a hater
23:03:49 <Samantha> Why the traffic is  slow 
23:04:01 <Samantha> where is everybody???
23:04:05 <Itkovian> here
23:04:14 <Samantha> ok
23:06:28 <mjrosenb> Samantha: normally if you want someone's attention, you start a line with their handle, since that is what most clients will hilight on by default
23:06:47 <Samantha> oh ok
23:07:09 <Samantha> Botje: I am looking for 
23:07:29 <Samantha> mjrosenb:  Thank you like this
23:11:26 <ologNation> Is what I'm trying to do here: http://paste.lisp.org/display/115732
23:11:46 <mjrosenb> Samantha: yes.
23:11:54 <ologNation> unreasonable?  Is there a correct way to do it, or should I just avoid trying to assign local variables in daisy chains like this?
23:12:05 <Samantha> mjrosenb : Thank you
23:12:24 <mjrosenb> ologNation: err, that does not look like haskell
23:12:27 <bos> ologNation: wrong channel
23:12:33 <mjrosenb> ologNation: and i think you want let*
23:13:02 <ologNation> heh heh.  Sorry. 
23:26:48 <bos> preflex: seen dons
23:26:48 <preflex>  dons was last seen on #ghc 1 day, 9 hours, 24 minutes and 57 seconds ago, saying: ?
23:32:27 <mjrosenb> clearly a man of many words.
23:33:22 <blueonyx> hi, i want to read a png file into a String to pass it to a webserver, why does readFile error with: Exception: images-01.png: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)?
23:34:34 <blueonyx> furthermore withBinaryFile "bla.png" ReadMode hGetContents returns ""
23:36:59 <Saizan> the first error is because readFile opens it in text mode and tries to decode the text according to your locale
23:37:56 <Saizan> withBinaryFile "bla.png" ReadMode hGetContents returns "" because hGetContents uses lazy I/O and has not yet read anything before withBinaryFile closes the Handle
23:38:18 <blueonyx> aye
23:38:33 <Saizan> so, openBinaryFile would work here
23:38:42 <Saizan> hGetContents will close the Handle at the end
23:39:30 <Saizan> though for binary data Data.ByteString or Data.ByteString.Lazy are more appropriate
23:40:08 <blueonyx> ya thanks
23:42:16 <ski> @type let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM f fax xs in foldM'
23:42:17 <lambdabot> forall a t (m :: * -> *). (Monad m) => (a -> t -> m a) -> a -> [t] -> m a
23:42:19 <ski> @type \f -> flip (foldl (\r x a -> f a x >>= \fax -> fax `seq` r fax) return)
23:42:20 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
23:42:39 <ski> (Saizan,roconnor)
23:42:59 <ski> FunctorSalad : i'd say it is an associative fold
23:43:20 <Samantha> NO
23:43:24 <Samantha> no
23:43:47 <ski> FunctorSalad : one could also consider a version which would work with infinite lists ..
23:43:52 <Saizan> ski: that consumes the whole list before anything happens, not sure whether it's relevant though
23:44:11 <ski> hm .. so it does
23:44:32 <dolio> It doesn't necessarily.
23:44:46 <dolio> Or, the foldl one does.
23:44:57 <dolio> foldM' doesn't.
23:45:15 <ski> right, i should have used `foldr' anyway (first i thought the other one was a fold-right operation)
23:45:59 * jamy23 was formerly known as jamy
23:46:11 <ski> @type \f -> flip (foldr (\x r a -> f a x >>= \fax -> fax `seq` r fax) return)
23:46:12 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a -> m a1) -> a1 -> [a] -> m a1
23:46:22 <ski> that's better, i think
23:47:07 <ski> @src foldM
23:47:07 <lambdabot> foldM _ a []     = return a
23:47:08 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
23:47:34 <ski> my original point was that that, and hence the strict variant, are both `foldr's
23:48:09 <d34df00d> Hi!
23:48:17 <ski> hello there
23:48:35 <d34df00d> I'm trying to parallelize some parts of my app, starting from the 24 chapter in Real World Haskell book.
23:48:51 <ski> (i.e., even though it is a "monadic `foldl'", it is a `foldr')
23:48:56 <d34df00d> It suggests writing something like force list1 `par` force list2 `pseq` (list1, list2)
23:49:21 <d34df00d> But force is deprecated, according to hackage, and it is absent in my GHC 6.12.
23:50:21 <d34df00d> So, as far as I could understand already, stuff from Control.Parallel.Strategies is suggested instead, but links to the docs are mostly broken, so I can only try to guess meaning of various functions from their desciptions on hackage.
23:51:47 <d34df00d> So several questions arise. First, what is suggested to be used instead of 'force'? 'rnf', right?
23:52:21 <blackh> d34df00d: Start by using the latest version of the parallel package, because that's the best.  Lots of good stuff has been done on it.
23:52:28 <ski> @hoogle force
23:52:29 <lambdabot> Control.Parallel.Strategies force :: NFData a => a -> a
23:52:29 <lambdabot> Control.Parallel.Strategies sforce :: NFData a => a -> b -> b
23:52:49 <ski> @hoogle rnf
23:52:50 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
23:53:03 <ski> @hoogle Strategy a -> a -> Done
23:53:04 <lambdabot> Control.Parallel.Strategies using :: a -> Strategy a -> a
23:53:04 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
23:53:04 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
23:53:06 <blackh> d34df00d: The older versions are slightly simpler, but the thing is, the new one will be standard very soon and you are going to have to learn it anyway.
23:53:29 <blackh> d34df00d: Some of the changes are needed to achieve high performance in newer versions of GHC.
23:53:37 <d34df00d> blackh: and I try to, but I can't find the docs, and my haskell-fu is too low to study it without them.
23:53:41 <ski> @type (`using` rnf)
23:53:42 <lambdabot> forall a. (NFData a) => a -> a
23:53:56 <ski> d34df00d : ^ that might be your `force' ..
23:53:57 <blackh> d34df00d: The easiest thing to do is just read the docs on hackage.
23:53:57 <d34df00d> ski: Module `Control.Parallel.Strategies' does not export `force' ← on my system.
23:54:11 <blackh> d34df00d: If you want local docs, I can tell you how to set that up.
23:54:14 <ski> note that i have never used strategies, so i might be wrong
23:54:47 <Samantha> Botje : Are you here?
23:54:50 <d34df00d> blackh: the only thing I've found on hackage is http://hackage.haskell.org/packages/archive/parallel/1.1.0.1/doc/html/Control-Parallel-Strategies.html
23:54:53 <blackh> d34df00d, ski: I don't know about force.  'deepseq' is the new name for it.
23:55:03 <d34df00d> Are there more docs about strategies?
23:55:04 <ski> d34df00d : yeah, i was suggesting you could possibly define `force = (`using` rnf)'
23:55:14 <d34df00d> ski: ah, ok.
23:55:16 <ski> @hoogle deepseq
23:55:17 <lambdabot> No results found
23:55:28 <blackh> d34df00d: That's the old one.  Use this one: http://hackage.haskell.org/package/parallel-3.1.0.1
23:55:35 <ski> d34df00d : blackh suggests the new name is `deepseq'
23:55:44 <d34df00d> Oh, nice.
23:56:01 <blackh> d34df00d: You may also need to look at the deepseq package.
23:56:30 <d34df00d> blackh: isn't `rdeepseq' the same?
23:56:43 <d34df00d> I mean, won't it evaluate my list as old `force' would?
23:57:24 <blackh> d34df00d: Yes, that's right.  That's the name of the strategy that give you full evaluation.
23:57:31 <d34df00d> Oh, great.
23:58:05 <d34df00d> So, instead the expression I've written at the beginning, something like the following should be used:
23:58:15 <blackh> d34df00d: For example: If you have a list of strings called strings, you can say  ... strings `using` rdeepseq
23:58:27 <d34df00d> list1 `using` rdeepseq $|| list2 `using` rdeepseq $| (list1, list2)
23:58:30 <d34df00d> Right?
23:59:19 <blackh> I'm not all that familiar with $|| and $|
23:59:51 <blackh> That's probably not quite right because it's for function application, which you're not doing in your example there.
