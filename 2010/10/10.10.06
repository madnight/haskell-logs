00:00:02 <nejucomo> I should be asleep.
00:00:29 <identity> I tried that
00:00:38 <identity> haskell follows me into my dreams
00:00:41 <Maxdamantus> > ⊥
00:00:42 <lambdabot>   <no location info>: parse error on input `⊥'
00:00:42 <dibblego> http://paste.pocoo.org/show/271613/
00:00:47 <kmc> nejucomo, in a bounded lattice (a type of poset) you have an element ⊥ such that ⊥ ≤ x for all x
00:01:11 <Maxdamantus> > (1,2) < (3,4)
00:01:12 <lambdabot>   True
00:01:15 <kmc> in domain theory this corresponds to the value with the least information, i.e. something that doesn't produce any value
00:01:21 <identity> The other day, before I got help in here with grokking the state monad, I woke up for a moment after actually dreaming about haskell, and for a second I felt like I had had an epiphany about the state monad
00:01:28 <kmc> (2,⊥) has more information than ⊥ because you can pattern-match out only the first value and see 2
00:01:34 <identity> When I finally woke up later I was furious because I was so sure I had grokked it in that moment of clarity
00:01:40 <identity> but forgotten it when I fell asleep again
00:01:54 <kmc> conal has some neat blog posts about this, and he wrote the libraries 'unamb' and 'lub' that let you do very cool things
00:01:55 <Jafet> > let (⊥) = undefined in (⊥) -- didn't know this was syntactically valid
00:01:56 <lambdabot>   *Exception: Prelude.undefined
00:02:04 <kmc> it's a symbol character
00:02:39 <kmc> for example, lub defines an operator 'lub' such that:   (2,undefined) `lub` (undefined,3)  == (2,3)
00:02:41 <Jafet> Well, I thought symbols could only be used for operators.
00:02:41 <kmc> which is pretty magical
00:02:47 <kmc> Jafet, it is an operator there
00:02:51 <kmc> that's why you had to put it in parentheses
00:02:54 <kmc> > let (+) = undefined in (+)
00:02:55 <lambdabot>   *Exception: Prelude.undefined
00:02:58 <Jafet> Yeah, but I didn't give it arguments
00:03:10 <kmc> > let (+) = (*) in 2 + 3
00:03:11 <lambdabot>   6
00:03:12 <Jafet> I guess that's nothing to do with the syntax though
00:03:32 <kmc> yeah, even if you required that operators have type a -> b -> c, undefined will happily take that type
00:03:53 <kmc> > let x ⊥ y = undefined in (⊥) `seq` ()
00:03:53 <lambdabot>   ()
00:04:04 <Jafet> Good point
00:04:24 <Jafet> > let (+) = "plus" in (+)
00:04:25 <lambdabot>   "plus"
00:04:31 <Jafet> That settles it then
00:06:14 <Maxdamantus> > let p = (+) in let (+) = (-) in let (-) = p in 5 + 4 - 2
00:06:15 <lambdabot>   3
00:08:28 <nejucomo> Woah…  defining (+) as a kind other than (* -> * -> *) surprises me.
00:08:42 <nejucomo> I thought all operator symbols had to have binary operator kind.
00:08:59 <opqdonut> nope
00:09:01 <Maxdamantus> Why does everyone use that silly … character?
00:09:17 <Jafet> kmc is everyone?
00:09:21 <opqdonut> > let (!) x = product [1..x] in (5!)
00:09:21 <Jafet> I guess he could be.
00:09:21 <lambdabot>   120
00:09:29 <Maxdamantus> and nejucomo
00:09:34 <Maxdamantus> This is IRC.
00:09:36 <identity> Maxdamantus: technically, "..." isn't an ellipsis like 'that character' is
00:09:41 <Maxdamantus> Everyone should use monospace on IRC.
00:09:48 <identity> It's not a series of charqacters but a character afaik
00:09:49 <Maxdamantus> … looks silly in monospace.
00:09:54 <identity> No it doesn't
00:09:58 <opqdonut> yes it does :)
00:10:04 <identity> Looks fine here.
00:10:07 <kmc> nejucomo, operators don't have kind
00:10:08 <identity> Not sure what you mean by silly
00:10:10 <kmc> they're values, they have types
00:10:15 <kmc> unless you mean type operators
00:10:23 <kmc> (you can use (+) as a type variable, but you probably shouldn't)
00:10:28 <opqdonut> luckily I am on a vintage charset so the ellipsis gets translated to "..."
00:10:48 <kmc> > text $ replicate 30 '…'
00:10:49 <lambdabot>   …………………………………………………………………...
00:10:57 <Maxdamantus> O_o
00:11:10 <Maxdamantus> Oh.
00:11:33 <kmc> Jafet, i am he as you are he as you are me and we are all together?
00:11:34 <identity> I would probably use the ellipsis if there was a way for me to input it on my keyboard without doing finger gymnastics
00:11:49 <nejucomo> Maxdamantus: Sorry about the ellipse.  My client translates three periods automatically.
00:11:56 <kmc> identity, Compose . .  for me
00:11:59 <kmc> do you have a compose key/
00:12:11 <identity> kmc: What do you mean by compose?
00:12:15 <nejucomo> It also was translating various emoticons into silly images, which makes reading haskell types hellishly smiley.
00:12:19 <kmc> identity, http://en.wikipedia.org/wiki/Compose_key
00:12:31 <identity> kmc: Ah.
00:12:40 <identity> Didn't know about that.
00:12:44 <kmc> i've got some custom bindings for mine which is why i can type cool shit like Γ ⊢ e₁ : τ₁ easily
00:12:53 <kmc> will share if you like
00:13:00 <kmc> on Thinkpads Fn makes an ideal compose key
00:13:23 <identity> I have Alt Gr which it mentions there, but it must not be configured to do that or some such
00:13:32 <Maxdamantus> Their Fn is a software key?
00:13:46 <kmc> Maxdamantus, if you press and release Fn without pressing anything else, it sends a keycode
00:13:48 <kmc> otherwise it does not
00:13:55 <Maxdamantus> Ah.
00:13:59 <kmc> so in software, it's usable for Compose and not much else
00:14:06 <kmc> and this does not interfere with the hardware use
00:14:27 <Maxdamantus> Hm. This reminds me of mechanisms like that "sticky keys" thing Windows has.
00:14:40 <nejucomo> Ok, next question on my laundry list:  the ST monad.  When using runST, the middle parameter is "an uninstantiated type variable".  So why does it exist?
00:14:44 <kmc> compose is cool because it's visually mnemonic.  if you don't know the combo you can just guess
00:14:48 <Maxdamantus> Where pressing a modifier actually does something if you don't use it as a modifier.
00:14:56 <kmc> nejucomo, it ensures that your STRefs and such don't escape the invocation of runST
00:14:58 <nejucomo> Is this a type-system trick to distinguish between RealWorld and not RealWorld?
00:15:05 <kmc> yes
00:15:07 <Maxdamantus> Wait, maybe I should see what the compose key's meant to do.
00:15:21 <Maxdamantus> Ah, I see.
00:15:26 <Maxdamantus> So it uses those digraphs?
00:15:35 <kmc> digraphs, trigraphs, etc
00:15:40 <kmc> ø = Compose / o
00:15:50 <kmc> → = Compose - >
00:15:51 <kmc> etc
00:16:03 <kmc> nejucomo, consider runST (newSTRef ())
00:16:05 <nejucomo> kmc: What do you mean by "escapes" the invocation of runST?
00:16:08 <kmc> this should be forbidden
00:16:08 <Maxdamantus> Never knew that. That can be my new right windows key.
00:16:20 <kmc> if runST :: ST s a → a, it would be allowed
00:16:21 <Maxdamantus> Hm. Or that context menu key O_o
00:16:41 <kmc> it would have type «STRef s ()» and we could use it in the action of another runST
00:16:55 <kmc> and this would break purity, because the result of runST now comes to depend on which runST was evaluated first
00:16:57 <kmc> so, that's bad
00:16:58 <identity> I need to get in on this compose key business
00:17:09 <kmc> but runST's actual type prevents this
00:17:19 <kmc> runST :: (∀s. ST s a) → a
00:17:33 <kmc> if you set «a = STRef s ()»
00:18:01 <kmc> then you can no longer satisfy the requirement of that polymorphic argument
00:18:10 <Maxdamantus> ø
00:18:13 <Maxdamantus> O_o cool.
00:18:35 <Maxdamantus> Was looking for a mechanism to do that the other day, but thought I'd need to do it separately for Gtk/urxvt
00:18:57 <Maxdamantus> →
00:19:12 <nejucomo> I don't follow.  If (runST :: ST s a → a) then (runST (newSTRef ())) would be (), would it not?
00:19:18 <kmc> no
00:19:22 <nejucomo> Oh, oops.
00:19:25 <nejucomo> :t newSTRef
00:19:26 <lambdabot> forall a s. a -> ST s (STRef s a)
00:19:27 <kmc> it would be a value of type «STRef ()»
00:19:30 <nejucomo> Right.
00:19:53 <nejucomo> Wait, wouldn't it be (STRef s ()) for an ambiguous s?
00:20:00 <kmc> right
00:20:02 <kmc> sorry
00:20:10 <nejucomo> I'm a bit tired to think straight right now.
00:20:16 <kmc> it would be «STRef s ()» for any s the caller chooses
00:20:51 <kmc> but precisely because the caller chooses s, the action m in (runST m) can't leak anything with an 's' in the type
00:20:56 <kmc> using the real type of runST
00:22:21 <kmc> if the caller chooses some concrete type s = T
00:22:24 <identity> …
00:22:25 <identity> Hah.
00:22:39 <kmc> then they want to specialize runST :: ST T a → a
00:22:42 <nejucomo> So…  I'm trying to grok how runST is implemented (neglecting the RealWorld case).
00:22:48 <kmc> oh, *implemented*?
00:22:49 <kmc> in GHC?
00:22:53 <kmc> it's just unsafePerformIO in disguise
00:23:18 <kmc> all of the safety and trickery of ST is at compile time, in the type system. at runtime it's isomorphic to IO and runST is unsafePerformIO
00:23:39 <kmc> IO = ST RealWorld basically
00:25:07 <kmc> in GHC, ST and IO are both implemented by impure (side-effect-having) functions that pass and return a "state" parameter
00:25:32 <kmc> this parameter has no runtime representation (it's the 'v' or 'void' data type in the STG machine) and carries no informational content
00:25:47 <kmc> it's just there to introduce an artificial data dependency, to implement order-of-execution by order-of-evaluation
00:26:10 <kmc> runST and unsafePerformIO both invent such a state parameter out of thin air, run an action, then discard the "resulting" state value
00:26:12 <Blkt> good morning everyone
00:26:26 <kmc> this is only one possible way to implement IO and ST, and a fairly distasteful one at that
00:26:31 * nejucomo googles STG.  Is that part of the type system?
00:26:38 <kmc> but it's what GHC does
00:26:58 <kmc> nejucomo, the Spineless Tagless G-machine is an abstract machine which is used in the backend of several Haskell compilers
00:27:14 <kmc> the original paper is http://research.microsoft.com/apps/pubs/default.aspx?id=67083
00:27:34 <kmc> and i recommend also http://www.haskell.org/~simonmar/bib/evalapply04_abstract.html
00:29:23 <nejucomo> Huh.  I wasn't aware of push/enter.  I'm inventing a strict functional duck-typed language which uses eval/apply.
00:29:43 <kmc> my comment about the 'v' type is probably specific to how GHC implements STG
00:29:47 <nejucomo> I'm certainly on the amateur hobbyist end of language theory.  :-)
00:31:05 <nejucomo> I should probably learn how type checking works in haskell before reading about compiler backend abstractions.
00:31:16 <kmc> then you should read "Typing Haskell in Haskell"
00:31:25 <kmc> and probably TaPL if you haven't already
00:32:13 <kmc> implementing type inference for simply-typed lambda calculus is a good first step
00:34:31 <kmc> it can be done in 100 lines of Haskell, and probably much less
00:38:09 <nejucomo> kmc: Thanks for all the leads.  Goodnight.
00:41:07 <Saizan> i always have a bad reaction when someone mentions type inference for STLC, with curry style terms it's impossible, with church-style ones it doesn't feel like inference anymore
00:41:24 <kmc> can you explain the difference between the two styles?
00:41:47 <Saizan> in the latter you annotate lambdas with the type of the argument
00:42:21 <kmc> i don't see how you'd do inference at all, then
00:43:28 <kmc> why is it impossible in the former case
00:43:47 <Saizan> i guess it's not completely trivial to recover the type A -> B -> B from a term like (\(x : A) (y : B) -> y) 
00:44:03 <kmc> inference is impossible for full SysF; i thought it was decidable for STLC
00:44:21 <Saizan> STLC doesn't have enough polymorphism :)
00:44:26 <kmc> it seems like a clear finite unification problem and unification is total afaik
00:44:29 <kmc> enough for what?
00:44:38 <Saizan> "\x -> x" has infinite incomparable types in STLC
00:44:41 <kmc> STLC is not a usable language for real programming, i agree
00:44:48 <kmc> ah
00:45:04 <kmc> so it doesn't have principal typing
00:45:05 <Saizan> so you don't get a principal type, you only get principal type _schemes_
00:45:11 <kmc> right
00:45:20 <kmc> or (equivalently?) types that still contain unification variables
00:45:35 <kmc> i suppose that's what you have in ML-like languages, just before the generalization step
00:45:38 * hackagebot uni-graphs 2.2.0.0 - Graphs  http://hackage.haskell.org/package/uni-graphs-2.2.0.0 (ChristianMaeder)
00:45:43 <Saizan> yep
00:46:38 * hackagebot uni-uDrawGraph 2.2.0.0 - Graphs binding  http://hackage.haskell.org/package/uni-uDrawGraph-2.2.0.0 (ChristianMaeder)
00:47:03 <kmc> the fragment of SysF which is inferable is precisely the fragment stratified into monotypes and polytypes, where lambda variables have monotype?
00:50:54 <Saizan> not sure, Hindley-Milner is quite close to that description, but it adds let
00:51:28 <Saizan> let x = e in b ~~ (\x -> b) e -- but then x should have a polytype there
00:53:24 <kmc> hmm
00:53:34 <kmc> i don't think of H-M as implementing let by desugaring to λ
00:53:41 <kmc> but rather thought that "let" was somewhat special in HM
00:54:03 <kmc> but i don't think wikipedia agrees with me
00:54:43 <kmc> no it's just describing the algorithm for STLC in a section titled "Hindley–Milner type inference algorithm"
00:54:44 <kmc> sigh
00:54:55 <Saizan> well, i'd tend to agree with your feeling, that equivalence was me trying to get SysF and HM to play in the same field
00:55:10 <kmc> right
00:55:20 <kmc> so i was wrong in describing H-M as a fragment of SysF
00:55:27 <kmc> because it adds new syntactic constructs
00:55:32 <kmc> which aren't purely sugar
00:56:54 <kmc> on an unrelated note
00:56:59 <kmc> " -} " is a valid Haskell expression
00:57:05 <kmc> but {- " -} " -} is not a valid comment
00:57:07 <kmc> which is sad
00:57:54 <kmc> it seems hard to implement nested multi-line comments in such a way that {- " -} " -} and {- " -} are both valid comments
00:58:14 <sipa> i was just typing that :)
00:58:37 <jamy> @quote haskell
00:58:37 <lambdabot> haskell says: Haskell - it's like a Lamborghini in the village. A little jerk - and went to work on the tractor.
00:58:56 <sipa> @quote
00:58:56 <lambdabot> Famous_Last_Words says: Read error: 110 (Connection timed out)
01:00:37 <kmc> pointless philosophy time
01:00:39 <Saizan> maybe in a few years let generalization will just die out
01:00:42 <kmc> people say that OCaml is a language
01:00:48 <kmc> but "The Objective Caml system is the main implementation of the Caml language."
01:00:59 <kmc> straight from the caml's mouth
01:01:05 <Adamant> Caml is a language. So is Ocaml.
01:01:12 <kmc> so is GHC 6.12.1, then?
01:01:26 <Adamant> numerics are not strings
01:02:10 <Adamant> also, the extended language ghc implements on top of Haskell 98 and 2010 is arguable a language, just a unnamed one
01:02:21 * sipa introduces the word 'dialect' in this discussion
01:02:24 <kmc> it seems like to be maximally pedantic we should talk about the Caml language, and treat the O bits as compiler-specific extensions, like the many extensions in GHC
01:02:42 <kmc> and yeah, every compiler / version / set of flags induces an implied language
01:02:50 <Adamant> this whole discussion is pretty pedantic, I didn't know that was disallowed :P
01:03:01 <kmc> also every program with a user interface is a language
01:03:03 <kmc> and every machine
01:03:07 <kmc> and the very universe itself
01:03:10 <kmc> merry christmas
01:03:11 <sipa> is the standard library in a particular implementation part of the language it implies?
01:03:25 <Adamant> good question.
01:03:43 <kmc> Adamant, i expected pedantic, it's where i started :)
01:03:57 <Adamant> kmc: "study math, kids. it's the language of the universe." - Gabriel, The Prophecy
01:04:27 <sipa> i'd say it's the language of human reasoning
01:04:39 <Adamant> a language of human reasoning, at least
01:04:43 <sipa> yes
01:05:08 <dolio> You're not allowed to argue with Christopher Walken.
01:05:11 <Adamant> hu-man reason many other ways. Morbo not impressed by them.
01:05:11 <sipa> we assume the universe is somehow reasonable, and that phycisists will find some not too awkward math-based description of it
01:05:16 <jamy> @remember windows Keyboard doesn't found. To rescan - press any key
01:05:16 <lambdabot> Nice!
01:05:37 <kmc> it's only a small subset of human reasoning, yet it's the subset which has been disproportionately useful in our weird little bootstrapped endeavor to describe the universe apart from ourselves
01:05:52 <Adamant> true
01:06:12 <Adamant> of course, we don't know if that trend is gonna last
01:06:33 <sipa> which part of reasoning (and by that i exclude 'intuition' or 'feeling') cannot be described by math?
01:06:54 <kmc> it is really strange, to think of coming into the world with only incredibly flawed subjective sensory data, and gradually building tools and modes of thought and externalizing the self to discover this thing, outside the self, which has some external consistency
01:06:55 <Adamant> who says intuition and feeling aren't part of reason?
01:07:13 <jamy> @map windows
01:07:13 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
01:07:50 <kmc> what part of reasoning (and by that i exclude things which aren't math) cannot be described by math?
01:08:04 <Adamant> even Morbo's good friend Richard Nixon knows that.
01:08:05 <sipa> haha, of course
01:08:12 <jamy> @type windows
01:08:13 <lambdabot> Not in scope: `windows'
01:08:23 <kmc> i would accuse you of begging the question but i think that phrase has jumped the shark
01:08:38 <Adamant> jump the shark has jumped the shark has jumped the shark
01:08:55 <Adamant> go ahead and use that phrase!
01:09:17 <Jafet> Where is this math from and why won't its speakers just learn english?
01:09:37 <Adamant> Jafet: we must purge it of impure German elements
01:09:53 <Adamant> from now on, Integers are I
01:10:16 <Adamant> forget this "Zahlen" stuff
01:10:23 <sipa> Jafet: english is too imprecise - see what problem we already have about defining the word 'reason'
01:10:48 <Adamant> imprecision source of ambiguity and power
01:16:01 <dolio> Next time some conversation in here digresses for 15 minutes because people are misunderstanding the way each is using the word "any," I'll remember it's because we're lucky that English is so powerful.
01:16:36 <kmc> any = ∀  vs  any = ∃ ?
01:16:53 <dolio> That, and nesting.
01:17:05 <sipa> we need parenthesis in english?
01:17:44 <kmc> i believe Lojban has the necessary particles to unambiguously encode sentences of first-order logic
01:18:30 <Jafet> I believe that sort of thing is why we'd never want to use lojban
01:19:02 <kmc> nah i really hope lojban catches on enough to have native first-language speakers
01:19:15 <kmc> because in one generation they would completely ruin the nice clean logic of it
01:19:27 <kmc> and the result would be incredibly strange and wonderful
01:19:27 <sipa> haha
01:20:17 <kmc> i'm sure half the language would become archaic in one generation, and i doubt anyone today can tell you which half
01:20:33 <Jafet> Is it cruel to get children and teach them lojban, in order to facilitate this cultural development?
01:20:59 <Adamant> yes, unless lojban is only one of the native languages taught to them
01:21:26 <kmc> but in that case they'll probably ignore it
01:21:33 <Adamant> true
01:21:35 <kmc> and just speak English or Mandarin
01:21:50 * Jafet imagines a controlled Clarkesean environment where this is carried out
01:22:28 <Adamant> sounds more like Skinnerian
01:23:26 <sipa> who are Clarkes and Skinner?
01:23:40 <Jafet> Then perhaps you can finally indoctrinate people with the three laws
01:23:47 <Adamant> sipa: Skinner is B.F. Skinner, behavorist psychologist
01:23:48 * hackagebot certificate 0.3 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.3 (VincentHanquez)
01:24:04 <kmc> eh trains pigeons to guide missiles and doesn't afraid of anything
01:24:18 <sipa> Adamant: aha, i vagely remeber that name from psychology class
01:27:12 <Adamant> sipa: he was reputed to have raised his kids in a behavorist-influenced box to train them. It wasn't actually true, but given the weird cradle his kids played in that was someone's prototype for a "modern" cradle and it's resemblance to a box for psychology lab rats, it was a semi-reasonable assumption to draw.
01:39:53 * hackagebot plot 0.1.2.1 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.2.1 (VivianMcPhail)
01:46:09 <identity> I've been looking at the ST monad and it says in various places that it really is pure, but how can it be pure if we're modifying state? Or is it just 'faking it' like the state monad?
01:47:55 * hackagebot plot 0.1.2.2 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.2.2 (VivianMcPhail)
01:48:17 <kmc> identity, it is really modifying state, unlike the State monad
01:48:29 <kmc> it has a pure interface
01:48:58 <kmc> runST allows you to turn an ST action into a result value
01:49:16 <kmc> it uses the type system to guarantee that the result is deterministic, and that its computation has no observable effects
01:49:33 <identity> Hmm
01:49:41 <kmc> this is a static type-system property only; the runtime implementation of runST in GHC is identical to unsafePerformIO
01:49:49 <identity> ah, yeah you said that
01:49:55 <kmc> so ST is "pure if you trust the library author"
01:50:01 <kmc> much like ByteString and many other libs
02:00:24 <quicksilver> kmc: on the other hand, the interface of ST doesn't exclude the existence of a fully pure implementation
02:00:35 <quicksilver> it just happens that's not how the GHC implementation works
02:00:56 <quicksilver> (and it also appears to be impossible to do in pure haskell, but that's arguably an expressibility gap)
02:04:44 <kmc> yeah
02:05:13 <kmc> but a fully pure implementation arguably defeats the point of ST
02:05:22 <jamy> > 20000 * (2^10)
02:05:23 <lambdabot>   20480000
02:06:36 <quicksilver> but its existence - even in theory - gives weight to the idea of describing ST as pure :)
02:07:51 <Jafet> So, is there a separation between Church and State?
02:08:14 <kmc> ;P ;P ;P
02:08:32 <kmc> quicksilver, yeah.  now can you prove that GHC's implementation and the pure implementation are equivalent? ;)
02:09:08 <quicksilver> it's not a very hard exercise to give a denotational semantics to ST
02:09:22 <quicksilver> it's just like a small typed imperative programming language
02:09:33 <quicksilver> (with haskell as its expression language)
02:19:25 <kw317> Hello
02:21:04 * hackagebot plot 0.1.2.3 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.2.3 (VivianMcPhail)
02:27:06 * hackagebot aterm 0.1.0.0 - serialisation for Haskell values with sharing support  http://hackage.haskell.org/package/aterm-0.1.0.0 (ChristianMaeder)
02:30:16 * ivanm waves idly in kw317's general direction
02:31:14 <teetoo> help
02:32:47 <identity> I just accidentally /list'd on here, forgot to switch servers in the server window.
02:32:49 <kw317> ivanm: Hi
02:32:51 <identity> I saw my life flash before my eyes.
02:33:29 <ivanm> wow, teetoo really must have been desperate for help...
02:34:45 <Entroacceptor> I guess he died?
02:36:54 <ivanm> yeah
02:43:10 * hackagebot haskell-src-exts 1.9.4 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.9.4 (NiklasBroberg)
02:46:09 <ivanm> ooohhh, haven't seen an hsx bump for a while
02:48:50 <jamy> ivanm: bump? 
02:48:57 <ivanm> version bump
02:49:06 <ivanm> @wn bump
02:49:07 <lambdabot> *** "bump" wn "WordNet (r) 2.0"
02:49:08 <lambdabot> bump
02:49:08 <lambdabot>      n 1: a lump on the body caused by a blow
02:49:08 <lambdabot>      2: something that bulges out or is protuberant or projects from
02:49:08 <lambdabot>         a form [syn: {bulge}, {hump}, {gibbosity}, {gibbousness},
02:49:09 <lambdabot> [20 @more lines]
02:49:15 <ivanm> @more
02:49:15 <lambdabot>         {jut}, {prominence}, {protuberance}, {protrusion}, {extrusion},
02:49:15 <lambdabot>          {excrescence}]
02:49:15 <lambdabot>      3: an impact (as from a collision); "the bump threw him off the
02:49:17 <lambdabot>         bicycle" [syn: {blow}]
02:49:19 <lambdabot>      v 1: knock against with force or violence; "My car bumped into
02:49:21 <lambdabot> [15 @more lines]
02:49:25 <ivanm> @more
02:49:25 <lambdabot>           the tree" [syn: {knock}]
02:49:25 <lambdabot>      2: come upon, as if by accident; meet with; "We find this idea
02:49:27 <lambdabot>         in Plato"; "I happened upon the most wonderful bakery not
02:49:29 <lambdabot>         very far from here"; "She chanced upon an interesting book
02:49:31 <lambdabot>         in the bookstore the other day" [syn: {find}, {happen}, {chance},
02:49:33 <lambdabot> [10 @more lines]
02:49:38 <ivanm> bah, none of these are right!
02:49:55 <jamy> @help wn
02:49:55 <lambdabot> I perform dictionary lookups via the following 13 commands:
02:49:55 <lambdabot> all-dicts ... Query all databases on dict.org
02:49:55 <lambdabot> devils ...... The Devil's Dictionary
02:49:55 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
02:49:55 <lambdabot> elements .... Elements database
02:49:57 <lambdabot> [9 @more lines]
02:51:24 <endojelly> cabal: dependencies conflict: ghc-6.10.4 requires Cabal ==1.6.0.3 however
02:51:24 <endojelly> Cabal-1.6.0.3 was excluded because Agda-2.2.8 requires Cabal >=1.8.0.2 && <1.9
02:51:26 <endojelly> really now?
02:51:35 <endojelly> ghc-6.10.4 requires Cabal ==1.6.0.3?
02:51:45 <ivanm> endojelly: how did you install Cabal-1.8?
02:51:53 <ivanm> did you do a "cabal upgrade"?
02:51:55 <endojelly> ivanm, cabal install cabal-install
02:52:08 <ivanm> endojelly: cabal /= cabal-install
02:52:14 <ivanm> endojelly: "ghc-pkg list Cabal"
02:52:19 <endojelly> then I probably got it out of haskell-platform
02:52:38 <ivanm> endojelly: that error is referring to the ghc _library_, not the compiler itself
02:52:52 <endojelly> /home/osterj/local/lib/ghc-6.10.4/./package.conf: Cabal-1.6.0.3
02:52:52 <endojelly> /home/osterj/.ghc/i386-linux-6.10.4/package.conf: Cabal-1.8.0.6
02:52:56 <endojelly> ahah.
02:52:56 <ivanm> and it needs that version of Cabal because that's the version that GHC-6.10.4 (the compiler) comes with
02:53:05 <ivanm> OK, no ideas why it's bitching
02:53:15 <ivanm> unless it's because of a diamond dependency
02:53:20 <endojelly> so, hm, any idea how to resolve that? :/
02:53:25 <ivanm> endojelly: any particular reason you can't upgrade GHC?
02:53:30 <ivanm> there are newer versions of the platform...
02:53:57 <endojelly> I guess I can... ok, I'll upgrade ghc.
02:54:11 <chrisdone> I have some code In.Submission { track = ... } and I get Ambiguous occurrence `track'
02:54:11 <chrisdone> (1) how can this be ambiguous? (2) DisambiguateRecordFields doesn't disambiguate this
02:54:46 <Saizan> endojelly: otherwise you can cabal unpack Agda; cd Agda-*; and use cabal configure; cabal build; cabal install --only
02:55:01 <Saizan> endojelly: cabal configure will give you a warning but it should still built
02:55:17 <endojelly> ivanm, any particular way which I should use to upgrade ghc? or is fetching the binary tar.bz2 okay?
02:55:29 <ivanm> endojelly: which OS/distro ?
02:55:32 <endojelly> Saizan, that's nice, thanks. if I run into problems with upgrading ghc I'll try that
02:55:55 <endojelly> ivanm, distro doesn't really matter, I'm doing everything in my home. and OS is linux.
02:56:04 <ivanm> endojelly: you installed by hand?
02:56:08 <endojelly> I did
02:56:21 <ivanm> how? generic ghc binary?
02:56:25 <endojelly> yes
02:56:39 <endojelly> and haskell-platform archive
02:57:12 <ivanm> hmmm... I _think_ just rm'ing the old local/<ghc stuff> and the old .ghc/i386-linux-6.10.4 directories should do it
02:57:17 <ivanm> and then unpack the new ones
02:57:49 <endojelly> I'll just try...
02:58:18 <ivanm> hey sinelaw 
02:58:40 <ivanm> endojelly: Agda-2.2.8 needs GHC-6.12 anyway
02:58:50 <ivanm> don't know why cabal-install didn't bitch about base...
02:58:53 <endojelly> oh okay, then
03:01:19 <sinelaw> hey ivan 
03:01:23 <sinelaw> anyone here use scion + emacs?
03:01:56 <sinelaw> ah never mind, i just found the installation instructions
03:02:29 <ivanm> I was going to try scion; then I saw that the package on hackage was out of date
03:02:41 <ivanm> and couldn't be bothered working out how to use git + github to get a live version
03:03:57 <Veinor> !lm * br.end=Zot -tv:<0:>$
03:04:05 <Veinor> wrong channel :D
03:05:19 * ivanm wonders in which channel that makes sense
03:07:55 <Veinor> ##crawl
03:08:11 <Veinor> it's a command for the ttyrec playing bot
03:09:24 <kmc> what?
03:10:16 <Jafet> @faq can Haskell embark on a dungeon expedition and retrieve the legendary Orb of Zot?
03:10:16 <lambdabot> The answer is: Yes! Haskell can do that.
03:10:24 <Veinor> oh, you can watch old games, like... if you die in a particularly amusing way you can tell it 'show me how I died'
03:11:24 <sipa> @faq Can you answer metaphysical questions?
03:11:24 <lambdabot> The answer is: Yes! Haskell can do that.
03:11:52 <endojelly> ivanm, thanks, that seems to have worked so far, it's now upgrading various libraries.
03:12:06 <sinelaw> when running scion + emacs i get a "versions differ" error
03:12:10 <sinelaw> any clues?
03:12:14 <endojelly> don't know why I still had 6.10.x on that machine anway
03:14:21 <endojelly> Building Agda-2.2.8...
03:14:22 <endojelly> src/full/Agda/TypeChecking/Rules/Data.hs:291:0: Fehler: Kein Newline am Dateiende
03:14:25 <endojelly> oh come on.
03:14:31 <endojelly> (that error means "no newline at end of file")
03:14:43 <endojelly> why is that broken?
03:15:59 <ivanm> *shrug*
03:17:23 <Saizan> i wouldn't expect that to be an error..
03:18:00 <endojelly> me too, but apparently it is
03:19:06 <endojelly> okay, I added the newline by hand
03:19:09 <endojelly> (cabal unpack etc.)
03:19:12 <mjk> does learning haskell must learn monad?
03:20:03 <ivanm> mjk: eventually you'll pick up using monads
03:20:09 <ivanm> but don't worry about it
03:20:26 <Saizan> mjk: not necessarily at the start, nor to do I\O, but eventually you'll bump into a library that uses them
03:20:27 <ivanm> the latest trend is to teach I/O and then say "oh, btw, guess what: you just used a monad!!!"
03:21:31 <mjk> thanks
03:21:36 <dobblego> that's the worst possible approach
03:22:18 <benmachine> mjk: learn types in general, once you get really good at polymorphism (hard but necessary) monads shouldn't be too hard
03:22:30 <kmc> mjk, what they said.  don't worry too much about monads; "Monad" is just a common API to a bunch of different stuff.  you'll see a lot of specific examples before you need to care about the generality
03:23:47 <mjk> understand monad is too difficult!
03:23:55 <kmc> mjk, where are you stuck?
03:24:05 <ivanm> dobblego: why is that?
03:24:06 <kmc> mjk, you need to understand first-class functions and type classes first
03:24:27 <ivanm> especially since one of the biggest perceived drawbacks of Haskell is how hard monads are and how you have to use them everywhere
03:24:33 <kmc> mjk, and what are you reading?
03:24:43 <ivanm> if you sucker them into learning how to use monads and they realise that they're not that hard...
03:24:58 <ivanm> also, I/O acts rather differently from say the list monad, so it doesn't hurt to teach it separately
03:25:03 <mjk> I can understand Maybe, [], but understand State is difficult
03:25:10 <dobblego> that's precisely what you do, without the I/O part, which completely destroys the endeavour
03:25:12 <kmc> mjk, ok
03:25:16 <kmc> you can implement State yourself in a few lines
03:25:23 <kmc> mjk, in fact BONUS just released another Monad chapter for LYAH
03:25:29 <kmc> which does just that
03:25:29 <mjk> kmc: real world haskell
03:25:43 <kmc> after covering Reader and Writer, which are each kinda like a subset of State
03:25:47 <dobblego> I am 5 months into a Haskell course, we are well beyond monads, but we still haven't looked at the signature for readFile
03:25:58 <ivanm> huh, I don't remember RWH's moand approach being that difficult
03:26:05 <ivanm> mjk: are you doing it in order or skipping ahead?
03:26:51 <mjk> ivanm: I try to programming with State and other monad
03:27:32 <kmc> mjk, http://learnyouahaskell.com/for-a-few-monads-more
03:28:41 <mjk> kmc: thanks, I'll go to there
03:32:59 * ski . o O ( `(forall b. (a -> b) ~= f b) -> Functor f *> ()' )
03:35:29 <ivanm> ski: are you showing off your wanted syntax again? :p
03:35:38 <ski> .. not really
03:35:58 <ski> just noting a fact i discovered/noted a few hours ago
03:35:58 <ivanm> that reminds me: is there any way of doing something like" :: (map (Suitable f) [a,b,a->b]) => ... ?
03:36:05 * ivanm doubts it, but it'd be nice...
03:36:10 <ezyang> I wonder if all the "interesting" monads have already been invented, and everything else is just permutations of the rest... 
03:36:44 <kmc> i've written a lot of domain-specific monads for particular projects
03:36:48 <ski> `forall b. (a =< b) <-> P b' can be read roughly as "`a' is the least `b' satisfying `P b'"
03:36:49 <kmc> maybe that makes them uninteresting
03:37:03 <kmc> they are usually a wrapper on some of the generic stuff from mtl, but with a different set of primitives exposed
03:37:08 <ski> the interesting point being that if there exists such an `a' at all, then `P' must be monotone/upper
03:37:39 <ezyang> kmc: Yeah, that's probably just a permutation. 
03:37:49 <kmc> i am reading now about LogicT, from a functional pearl from '05
03:37:49 <ski> (ivanm : .. but yes, i had to use that syntax to express what i wanted to express)
03:37:57 <kmc> which makes it significantly newer than the basic mtl stuff
03:39:34 <ski> ivanm : i'm not even sure what you want to express ..
03:40:13 <ivanm> syntax like that would make it easier to express something like this: defLiftA3 :: (Applicative f, Suitable f a, Suitable f (b -> c -> d), Suitable f b, Suitable f (c -> d), Suitable f c, Suitable f d) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
03:40:23 <ivanm> i.e. I'd like to be able to map over types
03:40:29 <ivanm> I doubt it's possible, but still...
03:40:34 <ski> .. oh
03:41:02 <ski> yeah, type lists, as well as type tuples (and records) would be useful
03:42:01 * ski supposes one might be able to kludge something with `data Nil' and `data Cons :: * -> * -> *'
03:42:08 <Saizan> type lists and map for them is easy, but classes aren't types
03:42:21 <ski> *nod* .. that too
03:43:51 <ski>   class Map (c :: * -> instance) ts  -- &c.
03:44:04 * ski has no idea whether this would work out
03:44:16 <ivanm> heh
03:45:54 <kmc> you can make your classes into types
04:07:34 <endojelly> hm. I don't even really know what universe polymorphism is.
04:20:17 * hackagebot hsc3-process 0.3.1 - Create and control scsynth processes  http://hackage.haskell.org/package/hsc3-process-0.3.1 (StefanKersten)
04:48:14 <kmc> git can't add empty directories
04:48:42 <benmachine> it doesn't handle directories at all iirc
04:48:44 <kmc> i feel so betrayed
04:49:01 <benmachine> just put a .lolhi file in there :P
04:49:05 <kmc> no, CVS doesn't handle directories ;P
04:59:28 <jamy> @where lambdabot
04:59:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
05:02:18 <jamy> @hakage lambdabot
05:02:18 <lambdabot> http://hackage.haskell.org/package/lambdabot
05:11:57 <roconnor> I wonder if I can get a job at the Institute for Advanced Study
05:12:58 <ivanm> you'd probably have to apply first...
05:16:51 <Jafet> I can tell from here that you'd make an outstanding Registered Laborer.
05:22:09 <kamatsu> aw
05:22:15 <kamatsu> haskell doesn't support unicode subscripts?
05:22:16 <kamatsu> waaah
05:22:18 <kamatsu> :(
05:22:32 <roconnor> doesn't it?
05:22:35 <kamatsu> nope
05:22:36 <Taejo> kamatsu: what do you mean by unicode subscripts?
05:22:45 <kamatsu> Id v₁ `unify` Id v₂ 
05:22:59 <roconnor> ah
05:23:05 <kmc> they're probably symbol characters
05:23:12 <kmc> > let (₂) = (+) in 1 ₂ 3
05:23:13 <lambdabot>   <no location info>: lexical error at character '\8322'
05:23:16 <sipa> and you'd expect it to mean what?
05:23:33 <Taejo> '₂' is Subscript Two (U+2082), a number with European number directionality
05:23:47 <Taejo> so it shouldn't be a symbol
05:23:49 <kmc> ok
05:23:56 <kmc> it's not, apparently
05:23:59 <kamatsu> Taejo: it says 8322 there, not 2082
05:24:06 <kamatsu> am i using the wrong one?
05:24:13 <Taejo> I think that's octal
05:24:18 <kamatsu> oh
05:24:24 <roconnor> > let v₂ = (+) in v₂ 1 3
05:24:25 <lambdabot>   <no location info>: lexical error at character '\8322'
05:24:31 <roconnor> poo
05:24:56 <sipa> > let v₂ = (+) in (1 `v₂` 3)
05:24:57 <lambdabot>   <no location info>: lexical error at character '\8322'
05:25:05 <kamatsu> Taejo: 8 isn't in octal?
05:25:10 <Taejo> right
05:25:11 <Taejo> doh
05:25:19 <sipa> number base fail
05:25:50 <kamatsu> let v₂ = 5;
05:25:54 <kamatsu> > let v₂ = 5
05:25:55 <lambdabot>   <no location info>: lexical error at character '\8322'
05:25:59 <kamatsu> hmm
05:26:10 <kamatsu> i copied that straight from the unicode page for 2082..
05:26:19 <Taejo> 8322 is decimal for 2082
05:26:23 <sipa> kamatsu: hex 2082 = ocy 8322
05:26:24 <sipa> oct
05:26:31 <sipa> > 0x2082
05:26:32 <lambdabot>   8322
05:26:37 <kamatsu> sipa: 8 isn't a digit in oct.
05:26:39 <Taejo> sipa: dec
05:26:41 <sipa> dec
05:26:42 <sipa> dec!
05:26:50 <kamatsu> ah, right.
05:27:05 <kamatsu> sigh, so haskell won't support my pretty subscripts?
05:27:07 <sipa> > "v₂"
05:27:08 <lambdabot>   "v\8322"
05:27:30 <sipa> > let x = 5 in x -- v₂
05:27:30 <Taejo> kamatsu: it seems to me like it *should*
05:27:30 <lambdabot>   5
05:27:35 <kamatsu> maybe i should file a bug in GHC.. not like they'd fix that soon. Maybe i shall fix it myself
05:27:37 <quicksilver> > isAlpha '\8322'
05:27:38 <lambdabot>   False
05:27:40 <kamatsu> i'm sure such a fix is trivial
05:27:46 <sipa> apparently it only allows that character inside strings and comments
05:27:51 <Taejo> > isDigit '\8322'
05:27:51 <lambdabot>   False
05:28:06 <Taejo> it should be a digit
05:28:08 <quicksilver> if it's not Alpha or Digit it's not valid in a variable, right?
05:28:16 <sipa> a digit?
05:28:19 <quicksilver> if it's a symbol you can use it as an operator.
05:28:21 <Taejo> _ and ' are neither
05:28:27 <quicksilver> Taejo: they're special cases though.
05:28:31 <quicksilver> exceptions to the general rule.
05:28:36 <Taejo> ok
05:28:37 <kamatsu> it's in the unicode "subscripts and superscripts" category
05:29:15 <Taejo> kamatsu: I think that's the *area* -- the category is "number" as far as I can see
05:29:43 <kamatsu> right, well, we want  GHC (and preferably the runtime) to treat these as digits and for the alphabetic subscripts to be treated as letters.
05:29:47 <Taejo> s/agea/range
05:29:57 <kamatsu> s/runtime/char library/g
05:30:28 <sipa> i'd say allow them as non-first character of symbol names
05:30:32 <kamatsu> yeah
05:30:59 <kamatsu> okay, i will probably do that myself
05:31:04 <kamatsu> time to check out ghc source
05:31:11 <kamatsu> or darcs get it
05:31:55 <quicksilver> it's WCsubst.c
05:31:58 <quicksilver> that contains the char classes
05:32:00 <kamatsu> in the meantime, i'll rewrite my algorithm in agda to preserve it's notational beauty.
05:32:20 <kamatsu> quicksilver: does GHC just use those or will i have to modify GHC's lexer?
05:32:29 <quicksilver> GHC just uses those I believe
05:32:47 <quicksilver> I had a quick look but couldn't find the right bit of lexer source
05:32:53 <kamatsu> okay
05:34:33 <merijn> Anyone here aware of any freenode channels dedicated to language theory (type theory, etc.)?
05:35:24 <hpc> you would probably get good discussion out of #haskell-in-depth
05:35:41 <kmc> it was really dead when i used to lurk there
05:35:44 <kmc> maybe it's livelier now
05:35:56 <hpc> it's still dead, but lots of people lurk
05:36:11 <hpc> speak and they will come
05:36:45 <pumpkin_> I just stopped going due to the deadness
05:37:20 <merijn> Usually I just start in here, since a lot of theory people hang around here anyway. But that seems rather off-topic for theory bits which haskell doesn't even support. (Like dependent typing and friends)
05:37:45 <hpc> dependent typing is done through an extension, so it would still be on topic here
05:37:46 <pumpkin_> merijn: there's some more esoteric types in #agda or #epigram
05:37:57 <pumpkin_> hpc: not any extension I know of :)
05:38:12 <pumpkin_> but I agree, it's mostly on-topic in here anyway
05:38:21 <merijn> pumpkin_: Yeah, but those are not especially busy either :p
05:38:35 <sipa> not sure whether agda people will like their language to be called an extension of haskell :)
05:38:38 <pumpkin_> hey, #agda is approaching 40 users now
05:38:42 <hpc> oh no, fundeps is the extension, my bad
05:38:56 <sipa> that's something else entirely :)
05:41:17 <merijn> As I understand the main use of Curry-Howard and dependent typing is the ability to encode predicated statements into the types, right? (i.e. stuff like head not accepting empty lists and the type system being able to proof lists given to head are never empty)
05:41:20 <ManateeLazyCat> Have ByteString version isURI ?
05:41:20 <lambdabot> ManateeLazyCat: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:41:24 <ManateeLazyCat> @hoogle isURI
05:41:24 <lambdabot> Network.URI isURI :: String -> Bool
05:41:24 <lambdabot> Network.URI isURIReference :: String -> Bool
05:44:23 <kmc> yeah merijn
05:46:13 <ManateeLazyCat> > isURI "lines:"
05:46:13 <lambdabot>   Not in scope: `isURI'
05:46:25 <ManateeLazyCat> > Network.URI.isURI "lines:"
05:46:26 <lambdabot>   Not in scope: `Network.URI.isURI'
05:47:13 <ManateeLazyCat> isURI "lines:" return True?
05:47:54 <ManateeLazyCat> Have any function match valid uri scheme?
05:48:11 <ManateeLazyCat> Like just http:// ftp:// can pass?
05:49:41 <Jonno_FTW> > let isURI = any `isPrefixOf` ["http://","ftp://"] in isURI "http://google.com"
05:49:42 <lambdabot>   Couldn't match expected type `[a]'
05:49:42 <lambdabot>         against inferred type `(a1 -> GH...
05:50:49 <ManateeLazyCat> Jonno_FTW: I want remove ["http://", "ftp://"]
05:51:20 <ManateeLazyCat> Jonno_FTW: Any list match those schemes? 
05:51:39 <Jonno_FTW> what?
05:51:49 <ski> > let isURI = (`any` ["http://","ftp://"]) . flip isPrefixOf in isURI "http://google.com"
05:51:50 <lambdabot>   True
05:52:25 <Jonno_FTW> I have a test somewhere
05:52:36 <Jonno_FTW> to see if a string is 'nearly' a url
05:52:53 <ski> > let frob = catMaybes . (`map` ["http://","ftp://"]) . flip stripPrefix in frob "http://google.com"
05:52:54 <lambdabot>   ["google.com"]
05:53:31 <Jonno_FTW> isUrl x = (length x > 4) && (any (== True) $ (map (\z-> z `elem` tlds)) $ map (\y -> takeWhile (/= '/') y) $ splitOn "." x)
05:53:39 <donri> http://hackage.haskell.org/packages/archive/url/2.1.2/doc/html/Network-URL.html
05:53:55 <Jonno_FTW> where tlds is all the top level domains
05:54:02 <kw317> I've got a design problem and I'm not sure how to approach it. I've got a large data structure for which I would like to have parameterized equality comparisons
05:54:41 <hpc> so like data Foo = Bar x | Baz y | Quux z?
05:55:01 <ManateeLazyCat> @package uri
05:55:01 <lambdabot> http://hackage.haskell.org/package/uri
05:55:24 <kw317> Threading some function that I can use to compare substructures is OK, but it can be quite deep and it gets really ugly
05:55:57 <Jonno_FTW> Network.URI
05:56:17 <Twey> Jonno_FTW: any (== True) = or
05:56:34 <ManateeLazyCat> Jonno_FTW: Well, i think i need write ["http", "ftp", "https"....] to match uri scheme
05:56:58 <Jonno_FTW> don't forget irc://
05:57:01 <kw317> For example, If I had a record with three fields, a b and c, sometimes I want to consider r1 == r2 if alll fields are equal, sometimes only if a and b are equal, and so on
05:57:21 <kw317> This really should depend on user input
05:57:33 <merijn> kw317: So write your own implementation of the Eq typeclass for said data type?
05:57:39 <kw317> How to go about this?
05:57:45 <ManateeLazyCat> Jonno_FTW: Well, best don't filter those, throw URI from irc client to browser. :)
05:57:52 <kw317> merijn: But that's fixed
05:58:21 <Twey> isUrl x = liftM2 (&&) ((> 4) . length) $ any ((`elem` tlds) . takeWhile (/= '/')) . splitOn "."
05:58:28 <Twey> Err
05:58:31 <Twey> isUrl = liftM2 (&&) ((> 4) . length) $ any ((`elem` tlds) . takeWhile (/= '/')) . splitOn "."
05:58:41 <ManateeLazyCat> > isUrl "lines:"
05:58:42 <lambdabot>   Not in scope: `isUrl'
05:58:47 <kw317> merijn: Essentially what I'd like to do is to choose an impl of Eq depending on user input
05:59:00 <kmc> kw317, so that user input would be the value you thread through?
05:59:07 <ManateeLazyCat> > isUrl = liftM2 (&&) ((> 4) . length) $ any ((`elem` tlds) . takeWhile (/= '/')) . splitOn "."
05:59:08 <lambdabot>   <no location info>: parse error on input `='
05:59:18 <ManateeLazyCat> isUrl x = (length x > 4) && (any (== True) $ (map (\z-> z `elem` tlds)) $ map (\y -> takeWhile (/= '/') y) $ splitOn "." x)
05:59:20 <hpc> @let isUrl = liftM2 (&&) ((> 4) . length) $ any ((`elem` tlds) . takeWhile (/= '/')) . splitOn "."
05:59:20 <lambdabot>  <local>:4:52: Not in scope: `tlds'
05:59:20 <lambdabot>  
05:59:21 <lambdabot>  <local>:4:82: Not in scope: `splitOn'
05:59:25 <ManateeLazyCat> @let isUrl x = (length x > 4) && (any (== True) $ (map (\z-> z `elem` tlds)) $ map (\y -> takeWhile (/= '/') y) $ splitOn "." x)
05:59:26 <lambdabot>  <local>:4:65: Not in scope: `tlds'
05:59:26 <lambdabot>  
05:59:26 <lambdabot>  <local>:4:109: Not in scope: `splitOn'
05:59:26 <kmc> kw317, perhaps you could use http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/other-type-extensions.html#implicit-parameters
05:59:33 <Jonno_FTW> > parseURI "http://google.com"
05:59:34 <lambdabot>   Not in scope: `parseURI'
05:59:39 <ManateeLazyCat> @hoogle splitOn
05:59:39 <lambdabot> No results found
05:59:45 <kmc> implicit parameters are much like class constraints, but you can bind them locally with "let"
05:59:53 <hpc> @hoogle splitAt
05:59:53 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
05:59:54 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
05:59:54 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
06:00:04 <Jonno_FTW> I think I used Data.Split
06:00:47 <ManateeLazyCat> @hoogle parseURI
06:00:47 <lambdabot> Network.URI parseURI :: String -> Maybe URI
06:00:47 <lambdabot> Network.HTTP.Base parseURIAuthority :: String -> Maybe URIAuthority
06:00:47 <lambdabot> Network.URI parseURIReference :: String -> Maybe URI
06:00:59 <kw317> kmc: Thanks, I'll have a look
06:01:04 <Jonno_FTW> http://hackage.haskell.org/packages/archive/network/2.2.1.8/doc/html/Network-URI.html
06:01:10 <kmc> kw317, there's also the Reader monad
06:01:33 <kw317> How does that help?
06:01:50 <kmc> it lessens the syntactic burden of passing a value through a bunch of function calls
06:02:42 <kw317> Thanks, I'll check both
06:06:28 <kmc> so what would you think of a compiler where warnings are mandatory and fatal, but can be documented and excused in the program source?
06:06:42 <hpc> that would be win
06:07:10 <hpc> you can do that in haskell, i think, with pragmas
06:07:10 <ski> warnings are mandatory what ?
06:07:20 <hpc> ski: -Werr
06:07:30 <hpc> and -Wall
06:08:12 <kmc> i don't think GHC has a fine-grained way to excuse warnings
06:08:16 <kmc> only per-file
06:08:39 <andern> if i have a function getNumber(x:xs) = read (takeWhile isNumber xs) :: Int, that would read an int from a string even with leading zeros, or characters after it right? but i need to have the first digit in the string aswell, simply doing x : at the beginning of the function wont work, any ideas? i'm pretty new to haskell
06:08:46 <hpc> i hate that i know this, but perl can do it...
06:09:12 <hpc> you can even do it inside loops, or conditionally ignore a warning
06:09:47 * ski thinks it could be nice to allow compilation of an erronous program, "isolating" the errors and compiling them as run-time abortion (or better, start a debugger ..), clearly stating that there are errors
06:10:16 <kmc> andern, what are you trying to do?
06:10:16 <Botje> andern: you can use (x:xs) in the body of your function as well
06:10:23 <kmc> first of all, you're dropping a character x
06:10:25 <ski> > read "123foo" :: Int -- andern
06:10:26 <lambdabot>   *Exception: Prelude.read: no parse
06:10:30 <hpc> that would be cool; so it makes an executable, but the erroneous function calls are == _|_
06:10:38 <kmc> why not getNumber xs = read (takeWhile isNumber xs)
06:11:00 <hpc> or fst . head . reads
06:11:12 <ski> > span isNumber "123foo"
06:11:13 <lambdabot>   ("123","foo")
06:11:26 <ski> > span isNumber "-123foo"
06:11:27 <lambdabot>   ("","-123foo")
06:11:36 <andern> kmc: haha, thanks, i can't believe i didnt think of that
06:11:56 <hpc> that doesn't handle negatives, if it matters
06:12:58 <ski> hpc : i suppose one problem is that often, type errors aren't really located in a single location .. you'd need something like type error slicing, and then deciding which of the locations (all of them ?) to compile as abortions
06:13:48 <ManateeLazyCat> @hoogle ok_url 
06:13:48 <lambdabot> No results found
06:14:34 <hpc> it would be better suited for a more dynamic language than haskell too
06:14:47 <kmc> an easier and perhaps more reasonable extension would be to fill in missing names with (error "<name of thing>")
06:14:49 <hpc> possibly lisp, because you can fix bad functions at runtime
06:16:05 <ManateeLazyCat> hpc: lisp can crash itself at runtime .... :)
06:17:10 <ray> we should have a Set that doesn't require Ord but can still use the efficient implementation for types in Ord
06:20:36 <ManateeLazyCat> > [a..Z]
06:20:37 <lambdabot>   Not in scope: data constructor `Z'
06:20:52 <hpc> > ['a'..'Z']
06:20:53 <lambdabot>   ""
06:21:04 <hpc> ^^
06:21:07 <ManateeLazyCat> Which version return all ASCII characters?
06:21:14 <dschoepe> > ['A'..'z']
06:21:15 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
06:21:16 <ski> ray : .. and for `exists x. (Foo x,Set x)' ?
06:21:40 <ManateeLazyCat> > map ok_url ['A'..'z']
06:21:41 <lambdabot>   Not in scope: `ok_url'
06:22:11 <ManateeLazyCat> > filter ok_url ['A'..'z']
06:22:12 <lambdabot>   Not in scope: `ok_url'
06:22:16 <ski> > isAlpha `isAlpha` [minBound ..]
06:22:17 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:22:17 <lambdabot>         against inferred type...
06:22:25 <ski> > isAlpha `filter` [minBound ..]  -- doh
06:22:26 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\1...
06:22:47 <ray> > map chr (enumFromTo 0 127)
06:22:47 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
06:23:17 <ray> ski: yes :(
06:23:25 <hpc> > length . filter isAlpha [minBound ..]
06:23:26 <lambdabot>   Couldn't match expected type `[a]'
06:23:26 <lambdabot>         against inferred type `GHC.Types...
06:23:30 <ray> i just want math sets :(
06:23:41 <hpc> :t isAlpha
06:23:42 <lambdabot> Char -> Bool
06:23:52 <hpc> :t filter
06:23:52 <Botje> type GenericSet a = [a] -- fixed
06:23:53 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:24:04 <hpc> > length $ filter isAlpha [minBound ..]
06:24:04 <lambdabot>   93455
06:24:08 <ManateeLazyCat> filter (not . ok_url) ['A'..'z'] ==> "[\\]^`"
06:24:21 <hpc> that's a lot of alphabetical characters
06:25:09 <ray> i mainly like Data.Set for the ability to insert things without checking if they're already there
06:25:10 <ManateeLazyCat> Hmm, also should filter character '"' '\t' '\n' ' '
06:33:06 <kmc> type GenericSet a = a -> Bool
06:35:00 * hackagebot yesod-auth 0.1.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.1.1 (MichaelSnoyman)
06:36:22 <ski>   type StrangeSet a = (a -> Bool) -> a
06:38:08 <kmc> selection functions eh
06:38:40 <kmc> that type shows up in "What Sequential Games, the Tychonoff Theorem and the Double-Negation Shift have in Common" and such papers
06:40:47 <andern> what would be the easiest way to parse a number from a string that would stop parsing as soon as it saw a non-number? you can assume that the first char in the string is a number
06:41:05 <kmc> > reads "123abcd" :: [(Int,String)]
06:41:06 <lambdabot>   [(123,"abcd")]
06:42:27 <andern> oh, that was... easy
06:42:39 <andern> thanks!
06:42:56 <ray> disclaimer: Read is not a good parser blah blah
06:43:21 <contrapumpkin> it's one of the best
06:43:48 <ray> nope you are contravariant and therefore wrong
06:44:12 <contrapumpkin> :(
06:49:53 <nickela> @pl \x -> (guard.even) x >> return x
06:49:54 <lambdabot> ap ((>>) . guard . even) return
06:50:10 <nickela> @pl \x -> guard (even x) >> return x
06:50:10 <lambdabot> ap ((>>) . guard . even) return
06:50:50 <contrapumpkin> :t uncurry (>>) . (guard . even &&& pure)
06:50:51 <lambdabot> forall (m :: * -> *) b. (MonadPlus m, Integral b, Applicative m) => b -> m b
06:51:36 <nickela> contrapumkin: Oh, fine. Thanks :)
06:53:13 <kmc> hmm there should be a std lib function for \p x -> guard (even x) >> return x
06:53:15 <kmc> err
06:53:20 <kmc> \p x -> guard (p x) >> return x
06:53:28 <contrapumpkin> yeah
06:53:37 <contrapumpkin> would be awesome for unfoldr
06:53:43 <kmc> :O
06:54:27 * kmc makes ld cry by handing it 92 MB of object code
06:54:30 <contrapumpkin> or maybe even \x y -> guard x >> return y
06:55:53 <idnar> @pl \x y -> guard x >> return y
06:55:53 <lambdabot> (. return) . (>>) . guard
06:56:05 <idnar> hmmph
06:58:41 <Twey> Hm… I prefer curry $ uncurry (>>) . (guard *** return)
06:59:13 <ray> @unpl (>>) $ curry *** delicious
06:59:13 <lambdabot> ((>>) (curry *** delicious))
06:59:26 <ray> @botsmack
06:59:26 <lambdabot> :)
07:00:23 <kmc> @. elite nixon
07:00:23 <lambdabot> +|-|3 Pr3sId3ncy hAS mAny PRoBLEM$, buT BOReDO/\/\ Is THE L3aS+ 0F 7HE/\/\.
07:00:30 <kmc> that's basically my favorite command
07:00:46 <ray> @. pl nixon
07:00:46 <lambdabot> (line 1, column 39):
07:00:47 <lambdabot> unexpected ";"
07:00:47 <lambdabot> expecting variable, "(", operator or end of input
07:00:53 <nickela> @pl \a -> "true" `isInfixOf` a || "false" `isInfixOf` a
07:00:53 <lambdabot> liftM2 (||) ("true" `isInfixOf`) ("false" `isInfixOf`)
07:01:26 <ray> @. djinn nixon
07:01:26 <lambdabot> Error: Undefined type I
07:01:36 <kmc> haha
07:01:47 <kmc> @. show nixon
07:01:47 <lambdabot> "Voters quickly forget what a man says.\n"
07:02:08 <Twey> on (liftM2 (||)) isInfixOf "true" "false"
07:02:44 <nickela> hmm, initial expression looks more clear for me :)
07:02:52 <Twey> The output of @pl is not always optimal
07:03:16 <ray> just like its namesake, perl
07:03:21 <Twey> Heh
07:08:29 <ManateeLazyCat> How to include char ']' in regexp "[^\\ \t\n`\\[\"^]+" ?
07:08:51 <ray> probably count your backslashes carefully
07:09:13 <fasta> Or don't use regexps at all.
07:09:19 <ManateeLazyCat> ray: I tried use \\], but failed.
07:09:35 <fasta> ManateeLazyCat, \\ means \
07:09:41 <ManateeLazyCat> fasta: I know
07:09:47 <ray> hmm
07:09:55 <fasta> ManateeLazyCat, so \\\] probably works.
07:10:09 <fasta> ManateeLazyCat, if you also want \, that is. 
07:10:12 <ManateeLazyCat> fasta: Can't wrok ,i have try.
07:10:16 <ray> once for the string and once for the regex
07:10:40 <ray> maybe 4
07:10:59 <ManateeLazyCat> "[^\\ \t\n`\\[\"^]+" mean don't inclue char: \ \t \n ` [ " ^
07:11:18 <ManateeLazyCat> ray: 2 3 4 , i have tried.
07:11:37 <fasta> ManateeLazyCat, tried this "\\\\]", really?
07:11:39 <ManateeLazyCat> Now just not include char ] in regexp.
07:12:07 <ManateeLazyCat> fasta: Yes, regexp can compile, but looks can't work.
07:12:10 <ray> since it's #haskell i'd use a parser anyway
07:12:35 <klugez> ManateeLazyCat: "You can put the closing bracket right after the opening bracket, or the negating caret. []x] matches a closing bracket or an x. [^]x] matches any character that is not a closing bracket or an x."
07:13:18 <klugez> If that isn't done with a backslash, closing bracket might not be either.
07:13:21 <ray> fancy
07:13:30 <ManateeLazyCat> klugez: Oh, yeah
07:13:36 <ManateeLazyCat> klugez: Works.
07:14:01 <ManateeLazyCat> klugez: In Emacs, i can put closing bracket in any place.
07:14:45 <ray> why can't people make up their minds on regex syntax :(
07:15:04 <ManateeLazyCat> klugez: I wonder put closing bracket right after opening bracket can work.
07:15:11 <gwern> ray: because every regex lang put to wide use slowly evolves into something more powerful
07:15:19 <gwern> no one wants to use just classic true regexs
07:15:39 <ray> it's a complaint, not a question :)
07:15:41 <ManateeLazyCat> klugez: But your solution works well, thanks for tips. :)
07:15:55 <ManateeLazyCat> ray: I love regexp solution sometimes. :)
07:16:05 <ManateeLazyCat> ray: Write many regexp elisp code before.
07:16:09 <sipa1024> gwern: people who use lexer-generators sometimes write real regexps still :)
07:16:12 <ray> i pretty much use them with grep only
07:16:14 <gwern> ray: oh. so what was your answer to the question I presupposed?
07:16:20 <ManateeLazyCat> ray: Like this http://www.emacswiki.org/emacs/gtk2hs.el
07:17:01 <ray> gwern: feature creep!
07:17:19 <gwern> so we agree. great! aumann beams down from rationalist heaven at us
07:17:29 <ray> lol
07:18:35 <frerich3> "Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems." - J. Zawinski
07:18:54 <gwern> frerich3: I was persoanlly thinking of zawinski's email-browser law
07:19:08 <Vanadium> It is a great line because you can substitute pretty much anything for "regular expressions"
07:19:30 <frerich3> gwern: I'm a vim use, so I can't really support that law ;-)
07:19:31 <ray> i think the advantage of regular expressions is that you can tell at a glance what simple ones do
07:19:35 <sipa1024> http://xkcd.com/208/
07:19:51 <ManateeLazyCat> ray: "[^]\\ \t\n`\\[\"^]+" regexp can match valid url character. :)
07:20:19 <ManateeLazyCat> ray: I use (matchAllText (makeRegex (B.pack "[^]\\ \t\n`\\[\"^]+") :: Regex) msg) can return [(String, (StartOffset, EndOffset))] 
07:20:34 <sipa1024> ManateeLazyCat: sure that's not \\t\\n ?
07:21:02 <ray> and actually, the place to stop using regex is exactly where a regex-familiar reader can't figure it out right away
07:21:05 <sipa1024> or does having a tab and a newline inside the regexp string work?
07:21:08 <Cale> This tendency to want to use "regexes" for non-regular languages is sad because if your language isn't regular, your parser would probably be clearer and easier to write using a more sensible syntax for parsers.
07:21:45 <Vanadium> Just extend regexes to cleanly handle non-regular languages
07:21:48 <ManateeLazyCat> Cale: Regexp is lazy. :)
07:21:51 <Vanadium> Cannot be that hard, right?
07:22:04 <kmc> but writing a parser requires me to learn flex and bison and have extra build dependencies and edit the makefile etc
07:22:06 <kmc> ;)
07:22:09 <ray> contextfreexps
07:22:14 <Cale> Vanadium: It's possible, but the end result always looks bad.
07:22:19 <ManateeLazyCat> kmc: Yes, you got . :)
07:22:21 * roconnor writes an extended regular expression to match the true theorems of arithmetic.
07:22:34 <gwern> roconnor: *all* of them and just them?
07:22:39 <roconnor> yes
07:22:39 <ManateeLazyCat> kmc: And regexp just one regexp string can work. :)
07:22:41 <sipa1024> kmc: nah, just use it once, generate the C code from it, and include that C code als source in your project, and hopefully never look back to it ;)
07:23:09 <ManateeLazyCat> sipa1024: \t and \n not valid url character.
07:23:11 <Cale> Vanadium: Because as soon as your language isn't regular, you're better off giving names to bits of the syntax which can then recursively refer to one another.
07:23:14 <gwern> sipa1024: murphy's law says you will look back
07:23:36 <Vanadium> hm
07:23:58 <sipa1024> http://www.noulakaz.net/weblog/2007/03/18/a-regular-expression-to-check-for-prime-numbers/
07:24:07 <Twey> o.@
07:24:37 <ray> just use bnfc to generate that other stuff
07:25:05 <roconnor> gwern: I think I'll need infinite look ahead
07:25:12 <Cale> The only reason we care about regular expressions over more general ways of constructing parsers in the first place is that they have an extremely efficient implementation in terms of finite automata. If you want to generalise your parsers, you lose that benefit.
07:25:47 <roconnor> Cale: I thought the size of the DFA grows exponentally in the size of the RE?
07:26:37 <Cale> roconnor: Well, probably. I'm thinking of implementations in terms of NFAs myself.
07:26:42 <sipa1024> roconnor: i believe only in the worst case
07:27:13 <tomberek> ivanm: hey hey
07:27:16 <roconnor> Cale: let me know when your computer comes with an NFA co processor :D
07:27:34 <Cale> roconnor: Data.Set or Data.IntSet work well enough :)
07:27:37 <sipa1024> a simple nondeterminstic turing machine would suffice :p
07:28:04 <Cale> Now, we just need to get the operations on them parallelised :)
07:28:06 <roconnor> requisition request: one roll of infinite nondeterministic tape
07:28:20 <roconnor> scratch that, make it two rolls
07:28:25 <Ke> !
07:28:41 <dstcruz> does anyone know if Simon Marlow's account in vimeo is Malcolm Wallace?
07:28:42 <roconnor> Ke: I will splice them together
07:28:55 <Cale> requisition request: one roll of infinite nondeterministic fruit roll-ups
07:29:17 <roconnor> (mm)
07:32:30 <kamatsu> there http://hackage.haskell.org/trac/ghc/ticket/4373
07:33:25 <gwern> infinite diabetes
07:33:30 <gwern> I CAN SEE TEH CONSING
07:34:33 <manman> hello everybody
07:34:35 <manateeUser> Emacs' regexp library is awesome. :)
07:34:40 <manateeUser> manman: Hello. :)
07:35:16 <mun_> does anyone know what the difference is between higher-order matching and higher-order unification? how come one's decidable and the other is not?
07:35:40 <gwern> does anyone know of a project which makes heavy use of automatically generated source files etc and also controls them in its repo (rather than let all devs regenerate them locally)?
07:35:53 <ray> every time i see elisp i wish emacs used scheme
07:36:22 <manman> I'm forced by my school to learn haskell, so I'm new to it
07:36:22 <manateeUser> ray: Yes, elisp is not powerful enough.
07:36:33 <cpressey> mun_: I don't know about higher-order (I assume it's not much different) -- the main difference between matching and unification is that, in matching, there are only variables one side.  In unification there can be variables in both terms.
07:37:01 <contrapumpkin> manman: that's a good attitude
07:37:12 <contrapumpkin> :)
07:37:21 <alej> cpressey, in unification, part of the point is that there are variables in both terms, right?
07:37:30 <manman> can someone give some tips to a haskell noob? :)
07:37:33 <alej> cpressey not merely that there 'can be'
07:37:41 <alej> manman ghc --make
07:37:44 <contrapumpkin> @where lyah
07:37:44 <lambdabot> http://www.learnyouahaskell.com/
07:37:49 <contrapumpkin> that's supposed to be quite good :)
07:37:49 <alej> manman ghc specific
07:37:51 <contrapumpkin> @where rwh
07:37:51 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:38:02 <ray> don't read monad tutorials
07:38:02 <alej> o contrapumpkin is more helpful
07:38:07 <alej> ^^^
07:38:09 <cpressey> alej: Well, no one is forcing you to put variables on both sides :)  But yes, supporting that is generally why you'd implement unification instead of just matching.
07:38:15 <mun_> cpressey, what do you mean variables in both terms?
07:38:16 <contrapumpkin> manman: also, don't try to learn monads until you've already written plenty of basic programs in it
07:38:37 <contrapumpkin> mun__: AType a Int unified with AType Bool b is AType Bool Int
07:38:40 <ray> writing one is ok though, but do not post it you'll conuse more newbies
07:39:00 <identity> Hmm, "Tackling the Awkward squad" would actually be a really good introductory paper for people that are trying to grok monads I think
07:39:06 <identity> I know that it would have benefitted me
07:39:33 <mun_> contrapumpkin, right...
07:39:57 <ManateeLazyCat> Hmm, URL regexp works well : http://www.flickr.com/photos/48809572@N02/5056783043/lightbox/
07:40:00 <contrapumpkin> mun__: there are two terms being unified there, each has a variable
07:40:01 <cpressey> mun_: Yes, like:  foo(A,1) unifies with foo(2,B) with unifier {A=2,B=1}
07:40:04 <kmc> does "Awkward Squad" discuss monads?
07:40:11 <kmc> istr it focuses mostly on IO-related stuff
07:40:19 <kmc> IO is a monad, sure, but this fact is secondary, and IO is a bad example of a monad
07:40:27 <mun_> cpressey, and why is that undecidable?
07:40:39 <cpressey> mun_: I assume the undecidability comes with the HO part
07:41:02 <mun_> contrapumpkin, do you know why that is undecidable while matching is not?
07:41:59 <manman> ok...I'll look into that...thanks a lot
07:42:22 <mun_> cpressey, is it because you could have an arbitrary lambda expression for one of the variables?
07:43:56 <contrapumpkin> mun__: you can have arbitrary notions of equivalence in HO
07:44:14 <mun_> contrapumpkin, what do you mean by that?
07:44:38 <roconnor> From: http://math.andrej.com/2010/09/27/programming-with-effects-i-theory/  We think of t as a piece of inert source code of type X with unhandled operations f1,…,fk. In order to give t a computational interpretation we need to explain how the operations fi are interpreted. 
07:44:42 <contrapumpkin> so say you have an addition operation, ideally you want x + y to unify with y + x
07:44:45 <roconnor> this is exactly how I think of IO
07:44:54 <identity> > let foo f1 f2 i = (f1 i, f2 i) in foo succ pred 3
07:44:55 <lambdabot>   (4,2)
07:44:55 <contrapumpkin> mun__: despite not being definitionally equivalent
07:45:27 <contrapumpkin> mun__: this is a rather painful issue in things like agda and coq already
07:46:14 <Cale> The embedded math in that page looks pretty good as far as math embedded in web sites goes.
07:46:36 <contrapumpkin> I love mathjax
07:46:48 <ManateeLazyCat> chromakode: mathjax?
07:47:04 <contrapumpkin> http://www.mathjax.org/
07:47:16 <roconnor> ya this is mathjax
07:47:29 <contrapumpkin> yeah :)
07:47:52 <ManateeLazyCat> chromakode: Looks cool. :)
07:47:54 <Cale> Now we just need browser support for all those LaTeX packages ;)
07:47:57 <sinelaw> anyone using scion on emacs?
07:48:01 <ManateeLazyCat> contrapumpkin: Looks cool. :)
07:48:22 <ManateeLazyCat> Cale: I have one ;)
07:48:28 <mun_> contrapumpkin, but why is equivalence arbitrary in HOL?
07:49:14 <Cale> I want TikZ in the browser :)
07:49:53 <ManateeLazyCat> Cale: TikZ ? :)
07:49:59 <ManateeLazyCat> http://www.texample.net/tikz/examples/ ?
07:50:11 <Cale> ManateeLazyCat: Yeah, those are examples made with it
07:50:16 <ski> ray : "guile and emacs and elisp, oh my!" by wingo at <http://lists.gnu.org/archive/html/emacs-devel/2010-04/msg00665.html> ?
07:50:40 <ManateeLazyCat> Cale: Looks cute. :)
07:50:48 <Cale> http://www.ctan.org/tex-archive/graphics/pgf/base/doc/generic/pgf/pgfmanual.pdf
07:51:41 <contrapumpkin> mun__: what does the HO mean in unification?
07:51:49 <ManateeLazyCat> Cale: Wow, so many beautiful picture. I love it. :)
07:52:50 <Cale> Yeah, it's pretty great for professional looking general diagrams. It's unfortunately not so easy to use for category theoretic diagrams, and I still end up using xypic for that.
07:53:29 <ski> contrapumpkin : "Higher-Order"
07:53:39 <contrapumpkin> ski: it was a rhetorical question :P
07:53:56 <contrapumpkin> ski: also, I was asking more specifically what the higher-order referred to :P
07:55:31 <identity> Cale: wow, tikz seems nice.
07:56:47 <ManateeLazyCat> Hope goo.gl will open API service soon. :)
07:57:49 <identity> ManateeLazyCat: ah, that could be a fun project
07:58:43 <ManateeLazyCat> identity: Yep, useful for twitter. :)
07:59:09 <contrapumpkin> mun__: but yeah, it's basically because you could have functions
08:00:11 <contrapumpkin> "Simon Peyton Jones has not entered any skills."
08:00:29 <ManateeLazyCat> identity: goo.gl/four easy to remember. :)
08:02:15 <cpressey> contrapumpkin: The single paragraph on HOU on Wikipedia is *completely* opaque.
08:02:23 <contrapumpkin> I agree :P
08:02:48 <kmc> "20 years Haskell experience"
08:03:09 <contrapumpkin> as far as I've seen, it's unification of arbitrary terms taking alpha- and beta-equivalence into account
08:03:44 <contrapumpkin> kmc: that's not too shabby
08:03:52 <contrapumpkin> I'd hire him
08:04:47 <roconnor> is Simon looking for work?
08:04:53 <andern> can someone tell my why i get non-exhaustive function on parse, but not parseExpr here? http://hpaste.org/40407/x - horrible code, but that's they way we're supposed to do it(assignment)
08:05:01 <contrapumpkin> roconnor: I don't think so :P
08:05:23 <contrapumpkin> andern: what does parse do with a list of length 1?
08:05:57 <contrapumpkin> parseExpr is nicer, in my opinion, btw :P
08:06:41 <andern> really? i prefer the latter, but maybe that's just me
08:07:22 <contrapumpkin> pattern matching is nice
08:07:38 <benmachine> you just skip unused characters? >_>
08:07:54 <contrapumpkin> I'd also parse it to an abstract representation :P
08:07:59 <benmachine> and yes pattern matching is nice
08:09:07 <roconnor> Cale: how do I make pretty diagrams?
08:10:44 <kmc> aww yeah
08:10:50 <kmc> i'm some kind of orange hexagonal gear
08:11:07 <contrapumpkin> oh nice
08:11:20 <andern> contrapumpkin: thanks. that question brought me to an answer :-)
08:11:53 <contrapumpkin> http://www.gravatar.com/avatar/ac0ed9efe05910cd536b5022b005c80a?d=wavatar&s=120
08:12:27 <contrapumpkin> anyway, I'm sad that I lost my super-low user id!
08:12:30 <sinelaw> any gtk2hs maintainers here?
08:12:36 <contrapumpkin> I signed up last night but I guess he dumped the old database
08:12:51 <contrapumpkin> I should ask for my money back
08:13:06 <medfly> :S
08:13:11 <contrapumpkin> I'm surprised SPJ wasn't too busy being awesome to sign up
08:23:20 <sinelaw> how can i tell cabal to use a different ghc executable?
08:23:35 <dcoutts> configure --with-ghc=
08:23:49 <sinelaw> thx
08:27:37 <roconnor> @quote heels
08:27:37 <lambdabot> musasabi says: <musasabi> no reason to reinvent the whole wheel  <musasabi> (usually reinvented wheels end up square)
08:27:54 <roconnor> @quote binding
08:27:54 <lambdabot> quicksilver says: I heard you like binding so I put a language in your language so you can let_ while you let?
08:28:06 <roconnor> @quote appear
08:28:06 <lambdabot> Olin_Shivers says: Who should I thank? My so-called ``colleagues,'' who laugh at me behind my back, all the while becoming famous on my work? My worthless graduate students, whose computer skills
08:28:06 <lambdabot> appear to be limited to downloading bitmaps off of netnews?
08:28:10 <roconnor> :(
08:28:59 * shapr hacks Parsec code for work purposes
08:28:59 <lambdabot> shapr: You have 4 new messages. '/msg lambdabot @messages' to read them.
08:29:02 <shapr> whoaa
08:29:35 <contrapumpkin> Cale: did you try calling mmorrow?
08:33:04 <endojelly> "Sometimes a data type is needed on several levels (both equality on the level of Set and Set1, for instance). Or a function (like composition) may be needed on several levels. These different uses may occur in the same program. "
08:33:13 <endojelly> oh, I think that explains what universe polymorphism is.
08:37:09 <ccasin> endojelly: yep!  In coq you just never write a universe level and the typechecker finds a good one, in agda you actually explicitly quantify over the universes and instantiate them where needed
08:37:22 <ccasin> but both are just hacks so you can use Eq for Set 0s and Set 1s
08:40:03 <contrapumpkin> ccasin: I thought it finds a good _one_
08:40:12 <contrapumpkin> can the same datatype work at multiple universe levels?
08:41:27 <fasta> In Coq you have universe constraints, so it simply computes the lowest index required, AFAIK. 
08:41:35 <roconnor> contrapumpkin: (now) in Coq, inductive types are polymorphic over universe levels, so each time you use an inductive data type could be instantiated at a new level
08:41:37 <ccasin> contrapumpkin: yes. though not twice in the same definition (though this is just an efficiency restriction)
08:42:06 <roconnor> contrapumpkin: OTOH definitions are not universe polymorphic and definitions will fix a universe level
08:42:12 <contrapumpkin> I see
08:42:23 <roconnor> inductive types used to be this way too.
08:42:28 <contrapumpkin> seems like it would be hard to infer that a definition is polymorphic
08:42:42 <contrapumpkin> on the other hand, in agda you can pattern match on universe levels
08:42:43 <roconnor> contrapumpkin: I don't think there is an inference problem.
08:43:03 <ccasin> roconnor: are you sure about this last bit?  For example I can use "map" on lists that contains Sets or Props or Type 5s
08:43:04 <roconnor> contrapumpkin: there is a practical problem of solving a huge number of universe constraints when everything is polymorphic
08:43:15 <contrapumpkin> ah
08:43:15 <endojelly> I'm just looking at how Agda does it
08:43:24 <endojelly> seems pretty nice actually
08:43:36 <contrapumpkin> it gets a little ugly to put the universe levels in after a while
08:43:54 <contrapumpkin> mostly cause they steal the valuable first positions of implicit arguments :P
08:44:09 <endojelly> yeah 8)
08:44:17 <contrapumpkin> also, not having cumulative universes is a bit of a pain too
08:44:38 <roconnor> ccasin: I *think* that works because Coq's universes are cumlative.
08:44:43 <ccasin> roconnor: or, a simpler example.  "Definition id (x : Type) := x." will work at any type level.
08:44:51 <roconnor> ccasin: but this is getting into pretty hairy territory
08:45:01 <ccasin> roconnor: I was thinking about that, but still that doesn't really explain id
08:45:25 <ccasin> if its argument type had a fixed level, you couldn't apply it to higher Types
08:45:37 <roconnor> ccasin: with a high enough type level, that id will operatat at that level *and everything below it* due to cumlativity
08:45:51 <roconnor> *I think*
08:46:20 <ccasin> roconnor: yes, that's right, but no higher.  and I find it hard to believe that the function really just can't be applied higher than Type 4945 or something
08:46:36 <contrapumpkin> lol
08:46:55 <contrapumpkin> I'm not sure what bothers me more though, the lack of cumulativity or the fact that we can pattern match on levels
08:47:02 <roconnor> ccasin: well, coq doesn't actually explicity give type level numbers to things.  It just solves the contraints and says "yes a consistent set of universe levels *could* be assigned"
08:47:06 <ccasin> contrapumpkin: you can't in the new agda
08:47:21 <contrapumpkin> ccasin: oh? I could've sworn I tried it a week or two ago
08:47:31 <contrapumpkin> more recent than that?
08:47:40 <mornfall> contrapumpkin: What have you done to copumpkin!?
08:47:41 * contrapumpkin tries with the latest
08:48:09 <hrmlgon2> are there any ghc ports for openbsd?
08:48:17 <burp> sure
08:48:35 <hrmlgon2> that don't install globally, I mean
08:48:36 <contrapumpkin> mornfall: I ate him
08:48:39 <shapr> QuickCheck SmallCheck and ... what am I missing?
08:48:40 <burp> openbsd has ghc 6.12 for some architecture
08:48:48 <shapr> Isn't there a third lib along the same lines?
08:48:53 <sproingie> what's the type of a contrapumpkin?
08:49:03 <contrapumpkin> (a -> b) -> (f b -> f a)
08:49:10 <burp> mhm, that don't install globally? then you need to install it yourself I guess
08:49:13 <burp> http://openports.se/lang/ghc
08:49:14 <shapr> I keep thinking it's tinycheck or something... ContraCheck?
08:49:18 <ccasin> roconnor: yes, exactly, which seems more like polymorphism than picking a fixed level
08:49:19 <ccasin> contrapumpkin: in the threads which explained the new changes for version 2.2.8, it was claimed that they are now making sure you can't inspect levels
08:49:19 <ccasin> but I confess I haven't tried it
08:49:25 <hrmlgon2> burp: I can find one 6.4
08:49:26 <Twey> contrapumpkin = fmap?
08:49:33 <contrapumpkin> Twey: nope
08:49:35 <mornfall> Twey: Reversed.
08:49:42 <Twey> Oh, right.  Haha.
08:49:47 <burp> hrmlgon2: in the newest ports tree there should be 6.12 according to this site
08:49:48 <hrmlgon2> what version does 6.12 need to compile?
08:49:49 <Twey> Magic!
08:49:50 <mornfall> I.e. contravariant.
08:49:59 <Twey> *nod*
08:50:08 <roconnor> ccasin: I think thinking of fixed levels helps understanding the denotation
08:50:24 <Twey> Did half the IPv6'ers on Freenode just die?
08:50:34 <roconnor> granted universe levels are really kinda confusing
08:50:35 <mornfall> Twey: They all have.
08:50:36 <contrapumpkin> ccasin: http://snapplr.com/vgjz
08:50:39 <mornfall> : - P
08:50:40 <Claudius1aximus> shapr: StrictCheck perhaps?
08:50:43 <mornfall> There just aren't many.
08:50:46 <Twey> Heheh.
08:51:41 <contrapumpkin> ccasin: or for a slightly more interesting example: http://snapplr.com/cmrz
08:51:54 <shapr> Claudius1aximus: Seems to be StrictBench, but I'll check it out, thanks.
08:52:04 <mornfall> Pumpkin -> Pie -> (Eaten Pie -> Eaten Pumpkin)
08:52:14 <ccasin> contrapumpkin: yes, scary.  let me see if I can find the thread I was thinking of
08:52:30 <ClaudiusMaximus> shapr: i meant the one here http://www.cs.kent.ac.uk/people/staff/oc/
08:53:13 <shapr> hm, not cabalized?
08:53:30 <ClaudiusMaximus> doesn't appear so - i've not tried it
08:53:49 * hackagebot shaker 0.4.3 - simple and interactive command-line build tool  http://hackage.haskell.org/package/shaker-0.4.3 (AnthoninBonnefoy)
08:54:29 <mornfall> contrapumpkin: What is that snapshot of?
08:54:43 <contrapumpkin> mornfall: an example of something that feels wrong in agda
08:55:31 <mornfall> I have no idea what it's supposed to mean, I guess. (Is that what's wrong with it? :D)
08:55:42 <ccasin> contrapumpkin: I can't seem to find it, so maybe I'm mixing it up with the discussion of the new erased arguments.  Still, I thought I remember reading somewhere a discussion of this scariness
08:56:12 <contrapumpkin> mornfall: how would you feel if id :: a -> a did something special if you fed it an Int, and otherwise returned the input
08:56:46 <mornfall> contrapumpkin: Insecure.
08:56:57 <contrapumpkin> ccasin: yeah, seems like something pretty obvious :) I'm sure the creators know it's bad
08:57:04 * shapr is tempted to NMU complexity on hackage
08:57:05 <contrapumpkin> I'm just not sure what to do about it
08:57:18 <contrapumpkin> {-# BUILTIN PLEASEDON'TPATTERNMATCH Level #-}
08:57:51 * hackagebot xilinx-lava 5.0.1.3 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.1.3 (SatnamSingh)
08:57:51 <contrapumpkin> mornfall: the example I gave is similar
08:58:20 <contrapumpkin> mornfall: agda doesn't let you pattern match on types, but it does let you pattern match on universe levels (which is a bit like a generalization of the type/kind distinction in haskell)
08:58:29 <Veinor> argh
08:58:31 <Veinor> lambdacats is gone
08:58:51 <geheimdienst> @where lambdacats
08:58:51 <lambdabot> http://tinyurl.com/lambdacats
08:59:20 <geheimdienst> veinor, the link works for me
08:59:21 <Veinor> oh awesome
08:59:26 <Veinor> I was using the arcanux link
09:00:41 <ccasin> contrapumpkin: one option is to extend the new support for irrelevant function spaces to include dependent functions and check that levels are always quantified over irrelevantly
09:00:41 <mornfall> contrapumpkin: I don't think there's anything wrong with that per se.
09:00:48 <mornfall> contrapumpkin: You have type classes in Haskell afterall.
09:00:50 <aristid> damn where is chrisdone
09:01:03 <contrapumpkin> mornfall: your typeclasses are explicitly reflected in the type
09:01:05 <aristid> how does the lambdabot command to ask people something work?
09:01:11 <contrapumpkin> they're basically an additional parameter that gives you "knowledge" about the type
09:01:17 <geheimdienst> @help ask
09:01:17 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
09:01:23 <contrapumpkin> I'm quite fine with Typeable a => a -> a doing weird shit
09:01:59 <contrapumpkin> umYeahI'mIdTrustMe :: Typeable a => a -> a
09:01:59 <mornfall> contrapumpkin: You still have unsafeCoerce. :D
09:02:30 <contrapumpkin> mornfall: you can do weird shit with unsafeCoerce, but you still can't do something different depending on the type of the input
09:02:46 <contrapumpkin> @free id :: a -> a
09:02:46 <lambdabot> f . id = id . f
09:02:48 <contrapumpkin> :P
09:03:12 <mornfall> Well, yeah.
09:03:38 <mornfall> A feature I sometimes miss. :))
09:03:43 <Twey> @djinn (a -> b) -> f b -> f a
09:03:43 <lambdabot> -- f cannot be realized.
09:03:45 <mornfall> But I agree it would be dangerous.
09:04:29 <aristid> @ask chrisdone How does the "run paste" thing work?
09:04:29 <lambdabot> Consider it noted.
09:04:33 <contrapumpkin> @djinn (a -> b) -> f a -> f b
09:04:33 <lambdabot> -- f cannot be realized.
09:04:35 <contrapumpkin> :P
09:04:47 <contrapumpkin> doesn't mean it isn't possible on a certain class of `f`
09:05:10 <gwern> @seen jaspervdj 
09:05:10 <preflex>  jaspervdj was last seen on #haskell 22 hours, 22 minutes and 37 seconds ago, saying: preflex: seen chrisdone
09:05:11 <lambdabot> Unknown command, try @list
09:05:18 <quicksilver> aristid: same technology as tryhaskell, I imagine
09:05:54 <aristid> quicksilver: tryhaskell is much faster
09:05:58 <kmc> contrapumpkin, i can unsafeCoerce to Addr#, then use that to get at the info table and inspect the type
09:06:09 <kmc> basically what vacuum does
09:06:51 <identity> Oh, the IO monad is actually World -> (a, World)? I had no idea
09:07:00 <kmc> in fact lookee here, getInfoTab :: a -> IO InfoTab
09:07:02 <kmc> identity, "actually"?
09:07:06 <kmc> in the spec, or in GHC?
09:07:13 <quicksilver> identity: nope.
09:07:19 <identity> kmc: Oh, it's not specified like that?
09:07:23 <kmc> definitely not
09:07:27 <kmc> the language spec treats IO abstractly
09:07:33 <quicksilver> it would be an incorrect specification, anyway
09:07:37 <identity> I mean I just automatically assumed that it was some internal copmiler thing or some such
09:07:38 <quicksilver> that suggests you always get the same world out
09:07:48 <quicksilver> actually the world can change non-deterministically
09:07:55 <quicksilver> it evolves in parallel with your program
09:07:59 <kmc> GHC uses an implementation a bit like that
09:08:07 <kmc> except the World value has a 0-byte representation ;P
09:08:11 <quicksilver> GHC uses an implementation which *appears* like that syntactically
09:08:15 <identity> oh, lol.
09:08:16 <quicksilver> semantically it's nothing like that
09:08:18 <quicksilver> it's just a trick
09:08:21 <kmc> yeah
09:08:22 <identity> I see
09:08:23 <quicksilver> a trick to get the right evaluation order
09:08:24 <kmc> "a bit like"
09:08:29 <identity> So there's still a 'trick' to it internally?
09:08:32 <quicksilver> sure
09:08:35 <identity> Alright
09:08:38 <quicksilver> internally GHC has side-effects
09:08:44 <quicksilver> the translation is such that they happen at the right times
09:08:47 <contrapumpkin> kmc: the info table contains the type? :O
09:08:58 <kmc> contrapumpkin, enough to recover part of the type
09:09:00 <kmc> for constructors anyway
09:09:07 <quicksilver> that State# RealWorld# is a trick used to drive the evaluator
09:09:13 <quicksilver> into performing the side effects at the correct point
09:09:15 <quicksilver> it's quite clever
09:09:21 <quicksilver> but it's not quite what it appears at first glance
09:09:28 <pr> meaning ghc may launch an ICBM, like when the time is right?
09:09:31 <pr> ;o
09:09:34 <quicksilver> of course.
09:09:38 <quicksilver> a semantically sound ICBM.
09:09:39 <kmc> identity, the trick is just that GHC provides a bunch of impure (side-effecting) functions as primitives, then passes this fictitious State# value around to introduce an artificial data dependency, thereby implementing execution order using evaluation order
09:10:00 <identity> kmc: I think I understand that
09:10:15 <identity> Are their other implementationst hat differ drastically?
09:10:16 <identity> Like, hugs?
09:10:48 <kmc> i'm not sure what hugs does.  since it's an interpreter it'd be easy for IO actions to *really* be descriptive values which are interpreted
09:11:24 <kmc> GHC could do this too, but it would introduce an interpretive overhead to IO.  the RealWorld hack is nice on the backend -- everything can be inlined, etc.
09:11:52 <identity> ah.
09:12:12 <kmc> perhaps you can consider it as a deforestation / fusing of the IO-action with the IO-interpreter
09:12:57 <contrapumpkin> hlj_ :O
09:14:02 <kmc> identity, you can think of an IO implementation that works like this: http://hpaste.org/40413/gadt_io
09:14:18 <kmc> now we can expose the constructors of the IO type, without compromising safety
09:14:40 <kmc> now it's easy to see that the monadic API is secondary
09:14:47 <identity> I can actually understand that, 
09:14:57 <identity> since I read about GADTs a couple of days ago
09:15:34 <kmc> it's also close to the idea of IO as a mini imperative language that we metaprogram with Haskell
09:15:48 <kmc> this language has higher-order syntax, thanks to the type of Bind
09:16:00 <kmc> and there'd be a part of the runtime system (not written in Haskell, presumably) which has to traverse these trees of IO values, and perform the actions thus described
09:16:32 <identity> Yeah
09:16:33 <identity> naturally
09:17:11 <ski> kmc : iirc, Hugs has `IO a' being `(a -> IOResult) -> (IOError -> IOResult) -> IOResult' where `IOResult' was interpreted by the run-time
09:17:17 <kmc> interesting to note that Bind gets an existential type
09:17:23 <kmc> not sure what deeper significance that has
09:17:34 <shapr> Which hackage has the MOST dependencies?
09:17:38 <kmc> ski, cool
09:18:51 <Twey> Direct or indirect?
09:19:04 <ski> kmc : except that exposing `Bind' and `Return' there makes `IO' fail to be a monad ..
09:19:17 <kmc> true
09:20:04 <ski> (i think a similar representation, but putting CPS on top of it, cures that ill)
09:20:27 <sipa1024> why is it no monad anymore?
09:20:37 <kmc> you can pattern-match on the constructors
09:20:43 <identity> kmc: I just read about existential and universal quantification which is what I assume you are referring to, but care to explain what you mean by "existential type"?
09:20:50 <kmc> therefore you can tell ((a >=> b) >=> c) from (a >=> (b >=> c))
09:20:50 <identity> I'm not sure those terms are compatible in my head
09:20:53 <aristid> shapr: write a tool to find out :D
09:21:14 <kmc> identity, there's a type variable present in the arguments to Bind which does not appear in its result type
09:21:30 <identity> Aah.
09:21:43 <kmc> if we have (Bind x f :: IO b) then we know that (x :: IO a) and (f :: a -> IO b) for *some particular unknown* a
09:21:44 <identity> so const has an existential type?
09:21:47 <kmc> no
09:22:12 <kmc> by existential type i mean a type with an existential quantifier in it
09:22:17 <kmc> though i'm abusing the term here
09:22:34 <kmc> because the type of the constructor Bind doesn't have ∃
09:22:36 <ski> sipa1024 : yeah, monad laws fail. e.g. `Bind io_a Return' is distinguishable from `io_a'
09:22:43 <sipa1024> yes, i see
09:22:47 <kmc> when it's seen as a constructing function
09:22:51 <kmc> but when it's a value we're picking apart, it does
09:23:01 <shapr> aristid: Good idea...
09:23:02 <ski> kmc : "morally" it does :)
09:23:15 <quicksilver> ski: the monad laws are only ever intended to apply up to some notion of observational equivalence
09:23:27 <quicksilver> (in my opinion)
09:23:28 <kmc> it promises to take any (IO a) and any (a -> IO b) and return an (IO b)
09:23:32 <kmc> that's universal quantification
09:23:33 <sipa1024> ski: semantically, they are equal, but structurally they're not
09:23:42 <quicksilver> ski: you can decide it's an abstract type and you're not allowed to pattern match.
09:23:45 <benmachine> quicksilver: right, so they are satisfied only if we don't export the constructors
09:23:46 <kmc> but, if we tried to write a type like Bind anonymously
09:23:51 <ski> quicksilver : right, so if you make it an abstract datatype, and don't export any operation that can distinguish them, then you're ok
09:23:56 <shapr> So far, my CPU heats up most from cabal installing llvm-extra
09:24:17 <Philippa> ski: or if you call it a monad up to forgetting pattern-matching, for that matter
09:24:24 <identity> kmc: Ah, so universal quantification  = forall (IO a) and (a -> IO b) we will get IO a?
09:24:38 <kmc> i don't follow
09:24:51 <identity> kmc: I'm just trying to get my head around the abtract nature of it all
09:25:00 <kmc> aren't we all
09:25:12 <identity> Haha, most of you don't seem to have any problem with it
09:25:14 <kmc> ok, so you already read about existential quantification in Haskell
09:25:18 <ski> kmc : roughly speaking, it also promises that for every `b', if there is any ("any" being existential, here) `a' such that you can pass it `IO a' and `a -> IO b', then it will return `IO b'
09:25:30 <contrapumpkin> dstcruz++
09:25:37 <identity> kmc: Oh, no. In predicate logic
09:25:43 <identity> e.g. basically this: http://en.wikipedia.org/wiki/Existential_quantification
09:25:49 <kmc> identity, oh
09:25:50 <bos> pretty interesting to see monad comprehensions possibly coming back.
09:25:58 <identity> I assume that's where it's from
09:26:14 <kmc> identity, then read http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/data-type-extensions.html#existential-quantification and http://haskell.org/haskellwiki/Existential_type
09:26:33 <benmachine> I wonder if you could have a valid Monad instance while exporting to constructors, if in (>>=) you applied some kind of 'normalisation' to eliminate equivalent constructions
09:26:40 <contrapumpkin> bos: where?
09:26:40 <identity> kmc: Roger, thanks
09:26:44 <kmc> and also read http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ so you don't overuse them ;)
09:26:48 <ski> Philippa : *nod* (but who's to remind you to keep forgetting that ? ;)
09:26:50 <contrapumpkin> identity: his name isn't Roger
09:26:56 <contrapumpkin> identity: ;)
09:27:05 <identity> contrapumpkin: Affirmative, roger.
09:27:13 <bos> contrapumpkin: see traffic on glasgow-haskell-users
09:27:14 <identity> Now I called you roger.
09:27:14 <kmc> bos, really?  for Haskell 2011?
09:27:21 <contrapumpkin> oh I see
09:27:22 <bos> as a language extension initially.
09:27:24 <benmachine> requesting clearance, over
09:27:33 <benmachine> that's clarence oveur
09:27:34 <benmachine> roger
09:27:35 <benmachine> huh?
09:27:38 <benmachine> etc.
09:27:55 <kmc> looks like i picked the wrong day to stop sniffing glue
09:28:12 <ski> identity : `Bind :: forall a b. IO a -> (a -> IO b) -> IO b' is almost the same as `Bind :: forall a b. (IO a,a -> IO b) -> IO b', which is the same as `Bind :: forall b. (exists a. (IO a,a -> IO b)) -> IO b'
09:28:19 <geheimdienst> "we've got clearance, clarence" -- "roger, roger." -- "what's our vector, victor?"
09:28:37 <identity> haha.
09:28:37 <quicksilver> send three and fourpence we're going to a dance
09:28:42 * benmachine high fives kmc and geheimdienst simultaneously
09:28:48 <identity> ski: I'll read the links kmc gave me and try to grok that
09:28:54 <identity> I think I might be catching on though
09:29:04 <sipa1024> get us the bill, bill
09:29:08 <kmc> identity, it's confusing because GHC uses the 'forall' keyword for both ∀ and ∃ quantification
09:29:08 <identity> If all else fails I'll get drunk and look at it again.
09:29:11 <kmc> haha
09:29:13 <contrapumpkin> oh nice
09:29:21 <ski> benmachine : yes, i think one can do such a normalization .. sortof, at least
09:29:23 <nominolo> :t (-1)
09:29:24 <lambdabot> forall a. (Num a) => a
09:29:29 <nominolo> :t (+(-1))
09:29:30 <lambdabot> forall a. (Num a) => a -> a
09:29:32 <kmc> identity, drinking never helped me with Haskell.  psychedelic 5-HT₂ agonists, maybe
09:29:35 <nominolo> :t (+-1)
09:29:36 <lambdabot> Not in scope: `+-'
09:30:43 <Philippa> kmc: to be fair, there's a reason GHC does that - existential quantification is encodable in terms of universal quantification
09:30:43 <identity> kmc: The first time I really felt like monads made sense to be a good while ago was after coming home drunk from school on a friday
09:30:46 * contrapumpkin rubs hand sin glee
09:30:49 <contrapumpkin> hands
09:30:52 <kmc> haha
09:30:56 <identity> No, I'm not an alcoholic. It's normal in denmark.
09:31:05 <kmc> "hand sin glee" -- frowned upon by the catholic church
09:31:09 <contrapumpkin> lol
09:31:16 <Twey> Hahaha
09:31:23 <geheimdienst> @quote bong
09:31:23 <lambdabot> No quotes match. My brain just exploded
09:31:25 <kmc> Philippa, yeah.  and the ctor does have a legitimately universal type
09:31:48 <benmachine> ski: presumably you'd have to re-associate all the binds; given that one of the arguments is going to be a lambda I'm not sure that's possible
09:32:14 <kmc> geheimdienst, i've got that quote, should i teach it to lambdabot?
09:32:36 <geheimdienst> sure do :)
09:33:38 <ski> benmachine : i suspect that one can do something similar to `data CoYoneda f b = forall a. FmapIncl (a -> b) (f a); instance Functor (CoYoneda f) where ...'
09:33:43 <kmc> too long :/
09:33:53 <contrapumpkin> what quote is that?
09:34:01 <kmc> 'newbie walks into #xmonad and asks about IO. allbery_b: "so anything that interacts with the real world
09:34:02 <kmc> , which is fluid and constantly changing, is "hidden" inside of IO, and you have to lift pure functions into IO to operate on data there"'
09:34:02 <ski> benmachine : in any case, using CPS is possible, i think
09:34:07 <benmachine> fmap f (Fmap g m) = Fmap (f . g) m -- seems to work
09:34:09 <kmc> 'newbie says he'll get out the bong
09:34:09 <kmc> '
09:34:22 <benmachine> ski: yeah I have an idea that CPS works fine I'm just curious if this does too
09:34:24 <ski> (benmachine : .. which is more or less "re-associate all the binds")
09:34:40 <burp>  lol
09:36:48 <ski> benmachine : yeah .. the point being that instead of adding an `Fmap :: (a -> b) -> (Foo a -> Foo b)' constructor to a type `Foo', you can use `CoYoneda Foo' instead, and that normalizes uses of `fmap' (so that exactly one `FmapIncl' constructor is present)
09:37:07 <benmachine> ski: oh right
09:37:14 <ski> benmachine : that way, `fmap id = id' and `fmap (g . f) = fmap g . fmap f' holds for `CoYoneda Foo'
09:37:21 <kmc> identity, i guess, if we want to write one of those existential types *anonymously*, that's where we really need the ∃ quantifier
09:37:28 <kmc> (anonymously and without using CPS)
09:37:57 <kmc> like «data Foo = ∀a. Foo a (a → Char)» becomes «∃a. (a, a → Char)»
09:38:21 <kmc> now this particular existential type is not much more useful than Char ;)
09:38:30 <Twey> kmc: Hahaha
09:38:34 <Twey> (re. bong)
09:38:56 * ski hands kmc `exists a. (f a,a -> b)'
09:39:30 <benmachine> ski: forall b?
09:39:36 <ski> benmachine : btw, note that `CoYoneda IORef' is a variant of `IORef' which is a `Functor' .. but it's a read-only reference, you can't (usefully) write to it
09:40:08 <benmachine> ski: huh
09:40:11 <benmachine> okay
09:40:32 <ski> benmachine : for any particular `b' which might be in scope, be it instantiated to some other type, `forall'-bound, `exists'-bound, or bound by a pattern signature / scoped type variable
09:40:52 <contrapumpkin> ski: what other uses are there for it?
09:41:04 <ski> for `CoYoneda' ?
09:41:07 <contrapumpkin> yep
09:42:20 <ski> well, making any types of kind `* -> *' into functors is one application .., also istr there's `Monad' instances and things, but i haven't really grokked what those are for yet
09:42:44 <ski> could be `instance Monad m => Monad (CoYoneda m)' ..
09:42:53 <contrapumpkin> yeah
09:42:55 <ski> edwardk could possibly provide more info
09:42:57 <contrapumpkin> according to category-extras
09:43:13 <ski> preflex: xseen edwardk
09:43:13 <preflex>  edwardk was last seen on freenode/#haskell 5 days, 20 hours, 47 minutes and 40 seconds ago, saying: chrisdone: hah. i think that has happened to a lot of us at different points
09:44:08 <aristid> type :~> f g = forall a. f a -> g a
09:44:18 <aristid> is that a natural transformation?
09:44:22 <contrapumpkin> yep
09:45:56 <ski> (.. and a "MonadMonad" instance .. with `return2 :: Functor f => forall a. f a -> CoYoneda f a' and `bind2 :: (Functor f,Functor g) => (forall a. f a -> CoYoneda g a) -> (forall a. CoYoneda f a -> CoYoneda g a)' or something like that)
09:47:02 <ski> (not sure if those `Functor' constraints are needed .. or maybe they need to be `Monad' ?)
09:52:31 <kmc> ski, what's the particular point of ∃a. (f a, a → b) ?
09:53:08 * hackagebot libpq 0.3 - libpq binding for Haskell  http://hackage.haskell.org/package/libpq-0.3 (GrantMonroe)
09:53:11 <zygoloid> kmc: it acts like Functor f => f b, without requiring f to be a functor
09:54:39 <ski> kmc : `\b -> exists a. (f a,a -> b)' is a functor, regardless of whether `f' is one
09:55:00 <aristid> ski: so you can make a Functor out of a Set?
09:55:01 <kmc> is f also quantified or can i say F instead?
09:55:03 <ski> it's sometimes a nice way to "force" a type to be a functor
09:55:40 <ski> kmb : for every `f :: * -> *', `CoYoneda f', i.e. `\b -> exists a. (f a,a -> b)', is a functor
09:56:23 <ski> aristid : sure .. but i suspect there's a catch, there
09:57:16 <ski> aristid : hm, i suppose one would probably want to have `\b -> exists a. Ord a *> (Set a,a -> b)', at least (though no merging there)
09:57:37 <benmachine> it would only be useful if you could automatically (or, I guess, manually) lift functions on Set to CoYoneda Set
09:57:40 <kmc> data C f b = ∀a. C (f a) (a → b);  instance Functor (C f) where fmap f (C x g) = C x (f.g)  -- like so?
09:59:04 <ski> kmc : yeah (as benmachine noted above)
09:59:22 <kmc> ah, i missed that
09:59:53 <kmc> under what circumstances can we write a function of type «f t → C f t»
10:00:07 <kmc> \x → C x id -- ?
10:00:12 <ski> right
10:00:12 <benmachine> presumably yeah
10:00:19 <benmachine> but we can't in general write C f t -> f t
10:00:37 <kmc> right
10:00:39 <benmachine> unless f is a Functor, I guess
10:00:40 <ski> also, there's `join2 :: CoYoneda (CoYoneda f) ~> CoYoneda f'
10:00:42 <kmc> that's where the functorosity of f matters
10:00:56 <kmc> in which case it's just \(C x f) → fmap f x
10:01:25 <ski> well, in some cases, you can extract information out of `f a' even when `a' is a skolem
10:01:27 <kmc> CoYoneda is just deferring a chain of fmapped functions until later
10:01:52 <ski> e.g. if `f' is `IORef', you can still (monadically) extract an `a', and apply the function to get a `b'
10:01:56 <ski> right
10:02:02 <kmc> and it's a monad too?
10:02:21 <ski> so there's a chance of better efficiency (only once traversal)
10:02:33 <contrapumpkin> kmc: only if the functor is
10:02:33 <ski> yes, `CoYoneda m' is a monad if `m' is one
10:02:49 <kmc> but what of this join2
10:02:57 <kmc> ah that's a natural transformation between two functors?
10:03:12 * hackagebot bindings-apr 0.1 - Low level bindings to Apache Portable Runtime (APR)  http://hackage.haskell.org/package/bindings-apr-0.1 (MasatakeDaimon)
10:03:19 <ski>   join2 :: forall a. CoYoneda (CoYoneda f) a -> CoYoneda f a  -- if you prefer
10:03:20 * kmc still does not get NT's, which probably means he's missing the point of CT at a fundamental level
10:03:55 <kmc> ah, which is not Monad's join at all
10:04:00 <ski>   bind2 :: (forall a. f a -> CoYoneda g a) -> (forall a. CoYoneda f a -> CoYoneda g a)  -- as well
10:04:20 <kmc> which would be CoYoneda f (CoYoneda f a) → CoYoneda f a
10:04:35 <ski>   bind2 :: (f ~> CoYoneda g) -> (CoYoneda f ~> CoYoneda g)  -- using the NT shorthand
10:04:40 <kmc> but we can get that for f a functor, by way of this \(C x f) → fmap f x i wrote earlier
10:04:53 <ski> kmc : no `CoYoneda (CoYoneda f) a -> CoYoneda f a'
10:05:05 <ski> .. er
10:05:18 <ski> (no, you were talking about `join' .. so yes)
10:05:58 <ski> kmc : yeah, but then you need to assume `Functor f'
10:07:13 * hackagebot wumpus-core 0.35.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.35.0 (StephenTetley)
10:08:19 <ski> (btw, `return2' is more or less `lift', of course)
10:09:13 * hackagebot wumpus-basic 0.10.0 - Common drawing utilities built on wumpus-core.  http://hackage.haskell.org/package/wumpus-basic-0.10.0 (StephenTetley)
10:09:16 * hackagebot bindings-apr-util 0.1 - Low level bindings to Apache Portable Runtime Utility (APR Utility)  http://hackage.haskell.org/package/bindings-apr-util-0.1 (MasatakeDaimon)
10:09:18 * hackagebot wumpus-microprint 0.10.0 - Microprints - "greek-text" pictures.  http://hackage.haskell.org/package/wumpus-microprint-0.10.0 (StephenTetley)
10:09:20 * hackagebot wumpus-tree 0.9.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.9.0 (StephenTetley)
10:11:43 <nejucomo> What does the this syntax mean?  class http://hackage.haskell.org/packages/archive/base/4.2.0.2/doc/html/Control-Monad.html#t:Monad m => MonadState s m | m -> s where ...
10:11:57 <nejucomo> I'm unfamiliar with the '|' and the bit to the right.
10:11:59 <benmachine> nejucomo: functional dependency
10:12:37 <nejucomo> benmachine: Can you explain more?
10:12:38 <benmachine> nejucomo: basically, it means that there will only be one s for each m
10:12:54 <benmachine> it's very useful for lessening ambiguity in use of MPTCs
10:13:03 <benmachine> in this case, each monad can only contain one state type
10:13:18 <nejucomo> Can you define functional dependency?
10:13:30 <nejucomo> Also, what's an MPTC?
10:13:35 <benmachine> multi-parameter type class
10:13:48 <benmachine> a non-standard but reasonably common extension
10:14:29 <benmachine> with multi-parameter type classes alone there is a tendency for ambiguity, so a functional dependency allows some of the parameters to determine others
10:15:07 <kmc> read "MonadState s m where m determines s"
10:15:40 <benmachine> arguably this case is more naturally expressed with type families (type functions, essentially)
10:16:04 <kmc> here is the type family equivalent: http://hackage.haskell.org/packages/archive/monads-tf/0.1.0.0/doc/html/Control-Monad-State-Class.html
10:17:18 <roconnor> the Continuation monad is a delimited continuation which is delimited by runCont?
10:18:16 * hackagebot free-theorems-counterexamples 0.3.0.1 - Automatically Generating Counterexamples to Naive Free Theorems  http://hackage.haskell.org/package/free-theorems-counterexamples-0.3.0.1 (DanielSeidel)
10:19:12 <ski> `MonadState s m | m -> s' means that `forall m. unique s. MonadState s m' which means `forall m s0 s1. (MonadState s0 m,MonadState s1 m) => s0 = s1'
10:22:07 <ski> roconnor : i suppose you could say that, yes
10:22:32 <roconnor> yay, I understand delimited continuations
10:22:33 <ski>   reset :: Cont o o -> Cont p o
10:22:48 <ski>   reset = return . evalCont
10:22:53 <ski>   evalCont :: Cont o o -> o
10:23:02 <ski>   evalCont = (`runCont` id)
10:23:30 <ski> so using `reset' to delimit the continuation is basically using `runCont'
10:23:33 <roconnor> intresting, I've never used reset
10:23:40 <roconnor> reminds me of mapCont
10:23:53 <roconnor> @src mapCont
10:23:53 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:24:47 <aristid> @hoogle mapCont
10:24:47 <lambdabot> Control.Monad.Cont mapCont :: (r -> r) -> Cont r a -> Cont r a
10:24:47 <lambdabot> Control.Monad.Cont mapContT :: (m r -> m r) -> ContT r m a -> ContT r m a
10:25:40 <donri> @src Control.Monad.Cont.mapCont
10:25:41 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:25:43 <roconnor> "Some people, when confronted with a problem, think "I know, I'll use delimited continuations." Now they have three problems."
10:26:08 <ski>   shift :: ((a -> Cont p o) -> Cont o o) -> Cont o a
10:26:10 <ski>   shift f = Cont (\k -> evalCont f (return . k))
10:26:23 <ski> (that `evalCont' is more or less a `reset' as well)
10:26:36 <roconnor> shift can't be written with callcc?
10:26:43 <ski> indeed
10:26:54 <roconnor> shouldn't callcc appear somewhere?
10:27:06 <kmc> haha roconnor
10:27:10 <ski> roconnor : yes, `mapCont' is similar in power to `shift' (i'm not sure of the exact comparision)
10:27:30 <aristid> @hoogle shift
10:27:30 <lambdabot> Data.Bits shift :: Bits a => a -> Int -> a
10:27:31 <lambdabot> Data.Bits shiftL :: Bits a => a -> Int -> a
10:27:31 <lambdabot> Data.Bits shiftR :: Bits a => a -> Int -> a
10:27:37 <roconnor> kmc: I used callcc to make a third problem by visiting the second problem twice
10:27:59 <roconnor> aristid: not those shifts
10:28:05 <kmc> if only you'd placed your delimiter properly
10:28:08 <aristid> roconnor: blame hoogle, not me
10:28:53 <ski> roconnor : `shift' and `reset' can be implemented on top of `callCC' and state .. see "Reflecting Monads" by Andrzej Filinski
10:29:37 <ski> (and then every computational monad can be reflected into a side-effect, using `shift' and `reset')
10:30:22 <ski> (errata : s/evalCont f (return . k)/evalCont (f (return . k))/)
10:30:52 <roconnor> ski: does your definition of shift typecheck?
10:31:05 <roconnor> ah
10:31:15 <ski> @type let shift :: ((a -> Cont p o) -> Cont o o) -> Cont o a; shift f = Cont (\k -> evalCont (f (return . k))) in shift
10:31:16 <lambdabot> Not in scope: `evalCont'
10:31:28 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id)
10:31:29 <lambdabot>  Defined.
10:31:30 <ski> @type let shift :: ((a -> Cont p o) -> Cont o o) -> Cont o a; shift f = Cont (\k -> evalCont (f (return . k))) in shift
10:31:31 <lambdabot> forall a p o. ((a -> Cont p o) -> Cont o o) -> Cont o a
10:31:57 <roconnor> ski: I missed your errata
10:32:03 <roconnor> I was staring at the definition instead
10:32:11 <cads_> is there a programming assistant for haskell?
10:32:21 * hackagebot polyseq 0.1.2.1 - Taming Selective Strictness  http://hackage.haskell.org/package/polyseq-0.1.2.1 (DanielSeidel)
10:32:27 <roconnor> cads_: like clippy, but for haskell?
10:32:33 <cads_> sure
10:32:35 <roconnor> cads_: oh there is Dr. Haskell
10:32:51 <roconnor> http://community.haskell.org/~ndm/drhaskell/
10:32:53 <roconnor> oh
10:33:01 <roconnor> apparently it has been renamed HLint
10:33:10 <cads_> oh, yeah
10:33:13 <kmc> what is a programming assistant?
10:33:28 <cads_> http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6WGS-4T6NPX0-1&_user=10&_coverDate=03/31/1979&_rdoc=1&_fmt=high&_orig=search&_origin=search&_sort=d&_docanchor=&view=c&_searchStrId=1487510793&_rerunOrigin=google&_acct=C000050221&_version=1&_urlVersion=0&_userid=10&md5=b80584ed904f8478050f8a0b2b372f34&searchtype=a
10:33:29 <cads_> heh
10:33:33 <cads_> probably an IDE
10:33:39 <roconnor> CommandLine.lhs:94:1: Error, use concatMap
10:33:41 <roconnor> Found:    concat $ map escapeC s
10:33:42 <roconnor> Why not:  concatMap escapeC s
10:34:10 <benmachine> I always thought hlint's errors were a little presumptious
10:34:16 <cads_> what's going on with leksah development?
10:34:20 <kmc> yeah it told me to use view patterns once
10:34:32 <cads_> hehe
10:34:32 <roconnor> just imagine a voice bubble from a cartooon warm fuzzy thing
10:35:13 <roconnor> Found: Exception Monada
10:35:20 <roconnor> Why not: Delimited Continuations
10:35:52 <kmc> Found: Haskell
10:35:54 <kmc> Why not: Agda
10:36:10 <roconnor> Found: Ubuntu
10:36:14 <roconnor> Why not: NixOs
10:37:38 <cads_> www.virtualshackles.com/142
10:37:44 <cads_> this is what I'm thinking of
10:40:04 <donri> Found: HIV
10:40:06 <donri> Why not: AIDS
10:40:36 <identity> Note: I am so new to group theory and all this stuff that I almost have no idea what I'm talking about, but I'm curious anyway: I read that groups are a set and operation that combines two elements to a third element which has to belong to the same set. I also read that rings are a set and two binary operators that follow the same rules as groups and some additional rules. What I don't get is why there's need for "rings" and "groups"
10:41:00 <roconnor> identity: wrong chan?
10:41:20 <identity> roconnor: Not entirely. I know this isn't #math but people don't seem to mind discussions about this stuff
10:41:23 <contrapumpkin> identity: because a lot of useful things have those properties
10:41:29 <roconnor> ok
10:41:33 <contrapumpkin> identity: and it's useful to talk about those structures abstractly
10:41:43 <kmc> identity, because we can write theorems that apply to all groups or all rings
10:41:46 <cads_> its funny that the xerox paper pretty much directly describes the main features of a modern IDE
10:42:01 <roconnor> oh
10:42:03 <roconnor> what paper?
10:42:05 <cads_> but it doesn't make it sound as shitty
10:42:10 <pr> clocks form a group!
10:42:23 <geheimdienst> (for certain values of "useful" ...)
10:42:25 <cads_> roconnor, http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6WGS-4T6NPX0-1&_user=10&_coverDate=03/31/1979&_rdoc=1&_fmt=high&_orig=search&_origin=search&_sort=d&_docanchor=&view=c&_searchStrId=1487510793&_rerunOrigin=google&_acct=C000050221&_version=1&_urlVersion=0&_userid=10&md5=b80584ed904f8478050f8a0b2b372f34&searchtype=a
10:42:27 <roconnor> ah that paper
10:42:41 <rschnck> Hey #haskell, I come to you with a silly DFA question oncemore.
10:42:59 <identity> So what you mean is that I can take a set, say all integers, and two operators that will fulfill the conditions that rings set(which would then make them a ring), but I can take the same set and some other pair of operations that do not fulfill the requirements to be a ring?
10:43:03 <cads_> pr, what is the binary operation between clocks?
10:43:13 <rschnck> For the DFA that accepts any binary string except 11 and 111, would I want it to accept the empty string? I.e. should the start state be an accept state, as I put here: http://imgur.com/98qY3.png
10:43:20 <contrapumpkin> cads_: maybe he's talking about modular arithmetic?
10:43:39 <contrapumpkin> rschnck: why not?
10:43:45 <contrapumpkin> if the only spec is "not 11 and not 111"
10:43:45 <zygoloid> rschnck: well, is "" equal to "11" or "111"? :)
10:43:56 <rschnck> zygoloid: Most certainly not.
10:43:59 <rschnck> Okay, good :3
10:44:00 <cads_> sure, but there's still an operation between clocks even if we're thinking of times as modular numbers
10:44:02 <roconnor> identity: algebraic structures have social lives... What is important is what happens between different rings and between different groups
10:44:22 <zygoloid> rschnck: then you most certainly don't want to reject it :)
10:44:29 <roconnor> identity: at least that's what's important in math
10:44:30 <rschnck> zygoloid: Certainly!
10:44:40 <identity> roconnor: If that was some attempt at group theory humor it went way over my head o.o
10:44:46 <roconnor> identity: in CS we don't care so much, and that's why we are more intrested in monoids and monads.
10:44:52 <identity> I'm currently at the "what the ... I am doing?"
10:44:54 <identity> stage.
10:45:05 <roconnor> identity: it is something I read in a category theory book
10:45:09 <identity> ah.
10:45:12 <cads_> contrapumpkin, ah, you can just add clock times together so if you have times X and Y, you get time Z which is X hours and minutes later than Y, or vice versa.
10:45:23 <identity> @give
10:45:23 <lambdabot> Maybe you meant: dice gsite time
10:45:23 <ManateeLazyCat> preflex: seen mm_freak 
10:45:24 <preflex>  mm_freak was last seen on #haskell 15 hours, 40 minutes and 54 seconds ago, saying: > (1:) ((1:) [1])
10:45:27 <identity> Meh.
10:45:33 <identity> @lyah | laper
10:45:34 <lambdabot> Unknown command, try @list
10:45:35 <roconnor> homomopisms and such are really what is studied in group theory / ring theory.
10:45:46 <roconnor> not individual groups or rings
10:46:13 <identity> roconnor: Yep, I was reading about homomorphisms and isomorphisms and thus I had to read about groups and rings and so on
10:46:21 <pr> cads_: well, clocks actually dont form a group, at least not in the sense i was thinking of. i was sort of refering to clock arithmetic as an example for a group ;)
10:46:54 <cads_> well, in what sense do they not form a group?
10:47:11 <cads_> they seem to, mathematically
10:47:27 <contrapumpkin> forall operation :: Clock -> Clock -> Clock, group Clock operation -> False
10:47:38 <cads_> oh, why?
10:47:39 <contrapumpkin> I guess we'd want an identity element in there too
10:47:42 <Irv`> Hi, stupid question... if i have a Data.Map.fromList [(0,"a"), (2,"b"), (8, "c")] and another list of potential keys [0..8], how do i like, intersect them?
10:47:51 <contrapumpkin> cads_: I was just translating his statement into something more formal
10:48:01 <cads_> 12:00 is the identity element, isn't it?
10:48:01 * benmachine takes a set of {Clock} and defines the operation Clock * Clock = Clock
10:48:02 <benmachine> sorted
10:48:09 <Irv`> i thought i could maybe map Data.Map.lookup over the list of keys but i don't know enough to knwo why that isn't working
10:48:15 <pr> cads_: 12:00 is not a member of the set of all clocks
10:48:22 <ManateeLazyCat> @tell mm_freak I want buildin SSL connection in my IRC client, but i think it's better add SSL support in fastirc, then other IRC library can it, can you add SSL APIs in fastirc? Thanks!
10:48:22 <lambdabot> Consider it noted.
10:48:26 <roconnor> clocks are more like torsors than groups
10:48:49 <cads_> pr, there's a clock that indicates 12:00
10:49:06 <roconnor> Irv`: you can map (lookup) and then catMaybes.
10:49:08 <cads_> or 00:00
10:49:10 <benmachine> Irv`: we don't know enough to know why that isn't working, e.g. what you actually did or how it failed
10:49:50 <benmachine> Irv`: maybe filterWithKey would help you
10:49:57 <pr> cads_: sure, but again, that's not what i was thinking of and furthermore it doesnt seem very intuitive
10:51:01 <ski> roconnor : would that book be "Categories for Software Engineering" by José Luiz Fiadeiro ?
10:51:41 <cads_> pr, I guess formally I'd like to suggest that analog clock positions are isomorphic to the set T = {0 .. 23}x[0, 60).
10:51:48 <cads_> which seems pretty intuitive to me
10:52:01 <benmachine> cads_: {0 .. 11} >_>
10:52:09 <cads_> oh
10:52:14 <cads_> whoops
10:52:17 <benmachine> unless you have weird clocks :P
10:52:19 <Irv`> benmachine: well, i was thinking i had to do something like this Prelude.map ((flip Data.Map.lookup) (fromList [(0, "a"), (2, "b"), (8, "c")])) [0..8]
10:52:23 <cads_> indeed
10:52:31 <Irv`> benmachine: ah and actually that does work
10:52:39 <benmachine> uh, glad to have helped
10:52:45 <benmachine> <_<
10:52:48 <Irv`> benmachine: my box at work might be 6.8
10:52:52 <pr> i don't see how isomorphisms could be intuitive to someone who had just learned about group theory
10:53:05 <Irv`> benmachine: but thanks :)
10:53:24 <cads_> well, one to one maps are familiar from calculus
10:53:25 <contrapumpkin> heteromorphisms
10:54:54 <kmc> i think i saw isomorphisms first on graphs
10:55:06 <benmachine> isomorphisms are just like... renamings
10:55:13 <kmc> it's kind of an intuitive concept, lining things up to show they're the same
10:55:19 <cads_> I saw them first for countability
10:55:23 <kmc> homomorphisms are harder, because you can forget some structure but only in a regular way
10:55:34 * hackagebot bff 0.3.1.1 - Bidirectionalization for Free! (POPL'09)  http://hackage.haskell.org/package/bff-0.3.1.1 (DanielSeidel)
10:55:49 <cads_> intuiting that some set of objects forms a group if there exists a one to one mapping onto a more abstract and obvious group doesn't seem that hard
10:58:20 <pr> interestingly enough, the person who asked about groups/rings encountered isomorphisms and homomorphisms before he/she encountered groups/rings
10:58:39 <pr> and still couldn't think of why they might be useful/worth spending time with
10:58:57 <malorie> the function `bla = mod 5' "expands" to `mod 5 n' when given an argument. I'd like it to "expand" to `mod n 5', though. is there a recommended approach?
10:59:00 <pr> which seems to me as he/she didn't find *morphisms intuitive at all
10:59:13 <cads_> I mean
10:59:20 <benmachine> malorie: flip?
10:59:36 <malorie> benmachine: ah. nice!
10:59:37 <benmachine> malorie: or a section, as in (`mod` 5), although some people think that ugly
11:00:09 <cads_> pr, it doesn't occur to math students that anything you can do is an example of a morphism
11:00:24 <kmc> i like «bla = (`mod` 5)» and i think «bla x = x `mod` 5» is not too bad either
11:00:30 <dstcruz> contrapumpkin: thanks :)
11:00:33 <cads_> at least, most college level math students
11:00:49 <kmc> but, i probably wouldn't name bla at all
11:00:58 <kmc> (`mod` 5) is a better name than bla
11:00:59 <kmc> ;)
11:01:29 <malorie> yeah. it's just a minimal showcase
11:01:46 <cads_> pr, so she couldn't talk about different types of morphisms she encounters and what they mean?
11:02:18 <pokoko222> any image processing people here?
11:02:44 <cads_> hehe
11:02:45 <cads_> sure
11:03:00 <cads_> what do you need to know?
11:04:22 <pokoko222> i am having problems understanding what an edge operator is :)
11:04:39 <hrmlgon2> is there any way to cache the results of an IO operation?
11:04:56 <hrmlgon2> well, aside from defining it using unsafePerformIO
11:05:27 <contrapumpkin> it wouldn't have to be unsafePerformIO
11:05:31 <Nibble> hrmlgon2: use unsafePerformIO
11:05:43 <contrapumpkin> make an IO (IO a)
11:05:52 <hrmlgon2> ...naturally
11:05:53 <cads_> wow this is cool
11:06:02 <pokoko222> contrapumpkin hahaha what a name :D if only copumpkin knew
11:06:07 <cads_> I'm typing on my computer in the sunlight
11:06:10 <contrapumpkin> hrmlgon2: that's what I'd do, anyway
11:06:14 <cads_> the screen still works
11:06:15 <hrmlgon2> contrapumpkin: and that after it's an IO (IO a)?
11:06:20 <hrmlgon2> *what
11:06:29 <contrapumpkin> hrmlgon2: well, let me write you a quick function, brb
11:06:47 <cads_> when there's this much light hitting it, the white areas turn green, while dark colors are still black.
11:06:54 <kmc> hrmlgon2, does it count as "caching a result" when i do:   do { x <- getChar;   ... use x. .... use x again ... }
11:07:09 <cads_> So it looks like an old LCD screen, but I can still read things on it
11:08:04 <cads_> in fact
11:08:14 <cads_> I've just turned my backlight off completely
11:08:23 <cads_> and I'm just using the LCD
11:08:31 <contrapumpkin> hrmlgon2: something like http://hpaste.org/40415/cache
11:08:50 <geheimdienst> cads_: yeah that works if you have lotsa light hitting the screen
11:09:14 <hrmlgon2> kmc: doesn't help much if I need to redesign the world to use it
11:10:12 <kmc> hrmlgon2, what's your design now?
11:10:32 <hrmlgon2> kmc: I haven't yet. I worked around it.
11:10:37 <contrapumpkin> :t (>>= (newIORef >=> return . readIORef))
11:10:38 <lambdabot> Not in scope: `newIORef'
11:10:38 <lambdabot> Not in scope: `readIORef'
11:11:22 <hrmlgon2> how does lambdabot work anyway?
11:11:28 <contrapumpkin> hrmlgon2: do you see what my thing is doing?
11:11:55 <hrmlgon2> uh, it makes some IORef, then I have no idea
11:12:49 <contrapumpkin> http://hpaste.org/paste/40415/an_example_of_cache#p40416
11:13:44 <contrapumpkin> hrmlgon2: it runs the computation, puts the result into an IORef, and returns a computation that will read from the IORef
11:14:56 <shapr> hiya ninly! Are you learning Haskell?
11:15:32 <hrmlgon2> contrapumpkin: oh, I think I get it now
11:16:11 <hrmlgon2> so to extract the value, you do whaty
11:16:28 <contrapumpkin> hrmlgon2: there's an extra level of indirection
11:16:37 <Saizan> contrapumpkin: the IORef is useless there
11:16:57 <contrapumpkin> oh good point
11:17:04 <contrapumpkin> :P
11:17:35 <hrmlgon2> so just x <- c?
11:17:42 <hrmlgon2> and return x?
11:17:47 <contrapumpkin> man, I feel dumb
11:17:54 <hrmlgon2> or, uh, c >>= return?
11:18:05 <kmc> «c >>= return» = c
11:18:06 <kmc> monad law
11:18:16 <Saizan> "cache c = do x <- c; return $ return x" is equivalent to the one in the paste
11:18:27 <Saizan> i'm not sure why it's particularly useful though
11:18:38 <kmc> something like what contrapumpkin proposed is useful in a concurrent context.  make a var, spawn a thread to fill that var, then block on reading the var
11:18:47 <kmc> that's how my 'spawn' library works: http://hackage.haskell.org/packages/archive/spawn/0.2/doc/html/Control-Concurrent-Spawn.html
11:18:51 <kmc> (blatant advertising yay)
11:19:00 <benmachine> yay
11:19:10 <benmachine> kmc: donate all your ad revenue to charity and you will be forgiven
11:19:28 <Saizan> yeah, or even in a non-concurrent if you add a little more machinery to perform 'c' only once when you call the resulting action and then share that result with successive calls
11:19:33 <Nibble> benmachine: better idea
11:19:35 <Nibble> give it to me
11:20:00 <benmachine> Nibble: I was making a cunning allusion to the fact that he doesn't make any money from advertising but ok sure
11:20:09 <byorgey> did someone in here the other day have a tool for grepping #haskell logs?  I was curious what my first words in the channel were (and what the date was)
11:20:19 <kmc> i could probably make, like, $3 off ads on my blog now
11:20:19 <benmachine> byorgey: yeah, chrisdone was doing that
11:20:29 <contrapumpkin> kmc: per what unit of time?
11:20:33 <kmc> byorgey, http://mainisusuallyafunction.blogspot.com/2010/09/clogparse-parsing-haskell-irc-logs.html
11:20:36 <kmc> contrapumpkin, per ever
11:21:23 <Nibble> benmachine: I know
11:21:50 <kmc> i wonder if Google has Haskellers pegged as penniless hippies / academics
11:21:53 <kmc> and charges a lower ad rate
11:23:21 <byorgey> kmc: ah right, thanks
11:23:26 <cads_> pokoko222, I think and edge operator turns a normal image into an image which has regions of high intensity in places where the original images has edges
11:23:47 <kmc> byorgey, though plain old grep is probably fine for that purpose
11:24:26 <pokoko222> cads like this http://upload.wikimedia.org/wikipedia/en/8/8e/EdgeDetectionMathematica.png ?
11:24:30 <pokoko222> cads_
11:24:52 <byorgey> kmc: well, I guess so, if you have all the logs on your disk
11:25:01 <byorgey> unless there's some sort of 'network grep' I don't know about
11:25:06 <kmc> yeah, that's a prerequisite for clogparse as well
11:25:13 <kmc> chrisdone is working on the cool web interface
11:25:31 <cads_> pokoko222, that's the canny edge detector?
11:25:38 <cads_> but yeah
11:25:51 <pokoko222> cads_ hmm guess by edge operator they mean edge detector
11:26:03 <cads_> that's actually a pretty advanced method
11:26:18 <byorgey> kmc: oh, I see.
11:27:20 <pokoko222> cads_ canny? i dont study that one i just got the picture
11:27:27 <cads_> pokoko222,  well, if you just take the mean of the differences of each pixel with their neighbors, you get a kind of edge detection operator
11:28:10 <cads_> which is pretty basic, its just computing the gradient of the image
11:28:34 <pokoko222> cads_ yeah but why do they say approximate gradient?
11:29:39 <cads_> since you have to take into account that each pixel represents a sampling kernel over some idealized image which you don't really have all the details of
11:30:28 <cads_> I bet some approaches use more pixels to approximate the gradient better
11:32:28 <cads_> http://en.wikipedia.org/wiki/Canny_edge_detector talks about how the canny detector uses a variety of techniques to give its output
11:33:39 <pokoko222> i study sobel now, not canny ;)
11:34:37 <cads_> yes, sobel is the first step in the canny filter
11:35:05 <pokoko222> ok, i guess that will come later in my book then
11:35:35 <cads_> also; detector, filter, operator, in a sense these are the same thing, but each can be seen as a more general version of the one before
11:36:16 <pokoko222> heh nice said cads_ ok ;)
11:39:22 <Twey> kmc: Huh… I'm on there.
11:41:56 <kmc> on where?
11:42:04 <kmc> oh yeah
11:42:21 <kmc> lambdabot smacked you upside the head
11:51:14 <manateeUser> #Ubuntu is better channel to test irc client. :)
11:51:37 <manateeUser> Bye all, 02:30 am in China, sleep... :)
11:59:06 <hrmlgon2> contrapumpkin: cache = (>>= return. return) ?
11:59:28 <aristid> :t (>>= return . return)
11:59:29 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m, Monad m1) => m a -> m (m1 a)
11:59:33 <contrapumpkin> hrmlgon2: yeah, but why do you need it again? cause it's really not very useful
11:59:35 <contrapumpkin> :P
11:59:58 <aristid> @unpl (>>= return . return)
11:59:59 <lambdabot> (\ a -> a >>= \ d -> return (return d))
12:00:05 <hrmlgon2> contrapumpkin: I was attempting to golf it!
12:00:09 <aristid> @. do unpl (>>= return . return)
12:00:09 <lambdabot> (\ a -> do { d <- a; return (return d)})
12:00:11 <hrmlgon2> sort of
12:00:39 <aristid> :t liftM return
12:00:40 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 a1 -> m1 (m a1)
12:03:06 <RibeirinhoPreiro>  i have a couple question about Haskell, why Haskell isnt a very used language in both OpenSource and Bussiness World? i want to start programming with Haskell what is the best books
12:03:07 <RibeirinhoPreiro> ?
12:03:30 <contrapumpkin> RibeirinhoPreiro: even the most common languages today started out with few users
12:03:45 <contrapumpkin> ;)
12:03:49 <Lemmih> RibeirinhoPreiro: learnyouahaskell is very good.
12:03:50 <contrapumpkin> @where lyah
12:03:50 <lambdabot> http://www.learnyouahaskell.com/
12:03:53 <contrapumpkin> @where rwh
12:03:53 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:04:05 <RibeirinhoPreiro> which is better?
12:04:28 <Entroacceptor> that depends :)
12:04:38 <Entroacceptor> if you don't know any haskell, start with lyah
12:04:41 <RibeirinhoPreiro> depends on what?
12:04:44 <Entroacceptor> it's a great introduction
12:04:54 <aristid> RibeirinhoPreiro: why not try both? just read a few pages and then see which you like better
12:04:59 <RibeirinhoPreiro> i dont know anything about haskell or function paradigm
12:05:06 <ninly> i'm rereading lyah now
12:05:09 * hackagebot exception-transformers 0.2 - Type classes and monads for unchecked extensible exceptions.  http://hackage.haskell.org/package/exception-transformers-0.2 (GeoffreyMainland)
12:05:13 <ninly> it's awesome
12:05:24 <Entroacceptor> and lyah got nice pictures in it :)
12:05:48 <ninly> i haven't seen rwh though
12:06:36 <mheld> hey y'all
12:06:40 <kmc> hola
12:06:56 <RibeirinhoPreiro> one of my goals is to use xmonad
12:07:09 * hackagebot exception-mtl 0.2 - Type classes and monads for unchecked extensible exceptions.  http://hackage.haskell.org/package/exception-mtl-0.2 (GeoffreyMainland)
12:07:12 <mheld> what's going on kmc?
12:07:45 <kmc> RibeirinhoPreiro, writing correct code is hard in any language.  Haskell makes it also hard to write incorrect code.
12:07:46 <Entroacceptor> RibeirinhoPreiro: I didn't need a book to be able to cope with xmonad config
12:07:48 <Jdogg6ms> hey guys.gals
12:07:53 <kmc> RibeirinhoPreiro, this is sometimes a bad fit with the business world
12:08:00 <kmc> where you want to produce incorrect code quickly
12:08:31 <RibeirinhoPreiro> ah :)
12:08:38 <hrmlgon2> ha
12:08:43 <kmc> and there's a chicken and egg problem of course... people don't know Haskell, so employers / OSS projects don't use it for fear of a lack of developers, so people don't learn it…
12:08:55 <kmc> this problem is not unique to Haskell
12:09:10 <burp> there are people that still use fortran for new stuff…
12:09:25 <kmc> Java is one of the most popular languages around but, in terms of incorporating anything from programming languages theory or research, it's stuck in the late 1960's
12:09:40 <mheld> anybody ever go through Algorithms: A functional approach?
12:09:55 <tommd> preflex: seen dcoutts
12:09:55 <preflex>  dcoutts was last seen on #ghc 1 hour, 13 minutes and 8 seconds ago, saying: I also said to ask JaffaCake or Igloo
12:09:56 <tommd> preflex: seen dcoutts_
12:09:57 <preflex>  dcoutts_ was last seen on #ghc 11 days, 2 hours, 51 minutes and 39 seconds ago, saying: Igloo: or if it's simple, tell me what to do
12:10:03 <kmc> burp, FORTRAN is still a completely respectable language for narrowly defined scientific computing problems
12:10:15 <dcoutts> @yarr!
12:10:15 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
12:10:18 <kmc> it's great if you use it as, well, a formula translator, and not a general purpose language
12:10:21 <dcoutts> tommd: ? :-)
12:10:29 <burp> kmc: ok
12:10:33 <tommd> dcoutts: Did you consider my proposal wrt bytestring?
12:10:38 <kmc> FORTRAN compilers are good thanks to 50 years of effort, and the language forbids a lot of nasty C-ish tricks that inhibit optimization
12:10:45 <dcoutts> tommd: I don't think I've seen it
12:11:29 <kmc> that said you can probably do the same in C with the right set of vorpal-level compiler flags
12:11:50 <kmc> -fsafety-third
12:11:50 <sproingie> -fsnicker-snack
12:11:53 <tommd> dcoutts: I was proposing:
12:11:53 <tommd> 1) Adding the correct RULES to make zipWith' f = pack . zipWith f (comments say it should be there)
12:11:53 <tommd> 2) Exporting zipWith'
12:11:53 <tommd> 3) Different topic: exporting getN or changing defaultChunkSize (in an e-mail to you and the -cafe)
12:12:07 <cads_> I think the first time I saw this, I thought haskell was a language that was coded in emoticons:   (>>=)   
12:12:21 <tommd> dcoutts: Subject "ByteString missing rewrite RULES (zipWith' f a = pack . zipWith f a)"
12:13:10 * hackagebot exception-monads-tf 0.2 - Exception monad transformer instances for monads-tf classes.  http://hackage.haskell.org/package/exception-monads-tf-0.2 (GeoffreyMainland)
12:13:23 <dcoutts> tommd: ok
12:13:27 <tommd> crypto-api really suffers with that missing rule (I think, haven't added it and done all the proper comparisions, but it makes good sense).
12:14:13 * hackagebot exception-monads-fd 0.2 - Exception monad transformer instances for monads-fd classes.  http://hackage.haskell.org/package/exception-monads-fd-0.2 (GeoffreyMainland)
12:14:15 * hackagebot multiset 0.2.1 - The Data.MultiSet container type  http://hackage.haskell.org/package/multiset-0.2.1 (TwanVanLaarhoven)
12:14:59 <dcoutts> tommd: oh I see what it does, still I'd rather not export zipWith'
12:15:09 <dcoutts> tommd: if we can get away with just the rule, that'd be nice
12:15:17 <tommd> dcoutts: That's fine.  I suspect the rule, when it exists, will fire properly.
12:15:44 <tommd> Could we get a point release?
12:16:15 <dcoutts> tommd: eventually, yes
12:16:28 <tommd> great
12:17:10 <tommd> dcoutts: Let me know if you want a patch submitted.  If not I'll assume you've got it handled.
12:17:41 <dcoutts> tommd: probably best to send a patch to both maintainers so we don't forget (we're both fairly busy atm)
12:17:55 <tommd> dcoutts: ok, on my list.
12:18:26 <McManiaC> what exactly is a QuickCheck "shrink"?
12:18:57 <tommd> McManiaC: Lets say you have the program:  if null xs then xs else errror "OH NOS!"
12:19:21 <tommd> McManiaC: You'd like to see the bad case with a single-element xs (particularly if the elements are big and ugly).
12:19:56 <tommd> McManiaC: So once QC finds a bad case it tries to make the input "smaller" and thus more useful to you (shortening the list would do it in this case).
12:20:21 <tommd> That is, it makes the test smaller but ensures it still causes the interesting behavior.
12:20:42 <tommd> Or, that is my understanding of shrinking a check.
12:21:18 <McManiaC> ah
12:21:19 <McManiaC> ok
12:22:41 <McManiaC> my problem currently is, I have a head' function which should behave just like head
12:22:44 <McManiaC> so I run something like 
12:23:03 <McManiaC> quickCheck $ \a -> monadicIO . assert $ head' a == head a
12:23:07 <McManiaC> which fails on first try
12:23:35 <McManiaC> but if I add a expectFailure to it, it "fails as expected" after one try (the empty list)
12:24:00 <McManiaC> can I make quickcheck to continue and test more values on it?
12:24:08 <tommd> Yes, not surprising, prop_headIshead' xs = not (null xs) ==> head xs == head' xs
12:24:17 <tommd> McManiaC: ^^
12:24:29 <tommd> see the (==>) operation
12:24:50 <tommd> Its a guard.  If the guard is false then it will discard that as an invalid test and keep trying.
12:25:23 <tommd> Formatting wise I usually write:
12:25:24 <tommd> prop_HeadIsHead' xs = not (null xs) ==>
12:25:24 <tommd>     head xs == head' xs
12:26:33 <tommd> http://hackage.haskell.org/packages/archive/QuickCheck/2.3.0.2/doc/html/Test-QuickCheck.html#v:-61--61--62-
12:27:02 <dino-> When I build even a super simple program where 'main = putStrLn "foo"' statically, I get an evil failure message upon execution. This is with Arch Linux.
12:27:30 <dino-> I wonder what I'm doing wrong. Using a cli like: ghc --make -static -optl-static -optl-pthread foo.hs
12:27:38 <McManiaC> tommd: okay :)
12:27:43 <kmc> why the linker options?
12:27:50 <benmachine> dino-: tried just ghc --make foo.hs? I think static is default
12:27:51 <kmc> 's usually not required...
12:28:03 <dino-> Without that pthread business it freaks out about.. let me run it again..
12:28:09 <kmc> yes, static is default, and if you want threading support just do ghc -threaded
12:28:32 <kmc> (you'll have support for Haskell-level green threads either way, but only with -threaded do you get the ability to have multiple OS threads and true concurrency)
12:28:43 <kmc> err perhaps i should say true parallelism
12:29:31 <dino-> Huh, doesn't freak out. You know, this started with trying to build something static that uses Network.CGI and HDBC.Sqlite things.
12:30:19 <kmc> the default is not static, actually
12:30:32 <kmc> it's dynamic linking to system libraries, but static linking of Haskell code to other Haskell code
12:31:01 <kmc> dynamic linking for high-level languages is tricky; you have to ensure ABI compatibility and they only just added that as an option in GHC 6.12
12:31:31 <shapr> y0 y0 #haskell!!
12:31:34 * shapr boings cheerfully
12:31:52 <kmc> it's also not too hard to make ghc produce a .so
12:31:58 <kmc> if that's useful for some reason
12:31:59 <monochrom> \∩/
12:32:08 <dino-> Ok, what I've been really trying to do here is build something where sqlite is statically linked. For deployment to a rotten hosted something that I only have ftp access to.
12:32:19 <kmc> ah, the sqlite c library?
12:32:33 <kmc> i believe there's a configure flag for the Haskell sqlite lib which bakes in sqlite.c
12:32:46 <kmc> hi shapr :)
12:32:58 <donri> shapr: Yo, yo little brother, what you out there trying to discover?
12:33:28 <dino-> kmc: Ah, that may help
12:33:30 <dino-> with the sqlite
12:38:16 <shapr> Hej donri! Jag söker nånting ny och intressant! Och dig?
12:38:20 * hackagebot persistent-sqlite 0.2.2.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.2.2.1 (MichaelSnoyman)
12:38:59 <shapr> coi donri - mi'e capr
12:39:14 <donri> shapr: Inte den bästa svenska jag sett, i ta'o mi'e ba'e la donri
12:39:35 <shapr> eftersom jag kommer från den del av Alabama som talar Svenska? :-)
12:40:17 <donri> Jo, jag antog att svenska inte är ditt modersmål, med det i åtanke är svenskan rätt bra. :)
12:40:43 <shapr> haha, tack!
12:41:03 <donri> ma ni jbobau do
12:41:28 <dino-> When I build something with -static and then check it with ldd, I still see a pile of output like libgmp.so.10 => /usr/lib/...
12:41:31 <dino-> Is that right?
12:41:37 <Heffalump> no
12:41:37 <lambdabot> Heffalump: You have 3 new messages. '/msg lambdabot @messages' to read them.
12:41:56 <shapr> donri: My lojban is too rusty, haven't used it in years :-/
12:42:34 <kmc> dino-, it links dynamically to system libraries
12:42:44 <kmc> not sure how to get true static
12:42:49 <kmc> you might have to run ld / gcc yourself
12:43:06 <dino-> kmc: Ok, I think you were saying that earlier but I didn't get it.
12:43:21 <Heffalump> did you use -optl-static?
12:43:25 <shapr> donri: But I think you asked me which languages I speak.
12:43:39 <dino-> Heffalump: No, just -static
12:43:46 <Heffalump> I just realised that now that GHC can do dynamic linking, -static probably exists as well.
12:43:54 <kmc> dino-, do you need static linking to libgmp etc?
12:43:58 <Heffalump> ok, you need that, to tell ld to link statically against system libs
12:45:00 <kmc> cool trick, i did not know that
12:45:13 <donri> shapr: let language = Haskell in case spoken of (/=) Lojban -> id  -- OK not really sensemaking
12:45:24 <dino-> kmc: I'm not sure. This is for a hosted web thing at GoDaddy that I only have ftp access to. And I'm not the person who is paying for it. I have no access to their webby control thingy or tech support.
12:45:49 <kmc> :/ i'm sorry
12:45:53 <dino-> It's like this: Call our PHP web guy and figure out how to upload your thing to our already existing blah blah.
12:46:02 <donri> shapr: More like how much Lojban do you speak ("What is an ammount such that Lojban is a language you use?")
12:46:21 <dino-> Heffalump: Ok, thank you
12:46:24 <kmc> dino-, the solution is a Haskell to PHP compiler
12:46:29 <kmc> did -optl-static work?
12:46:31 <dino-> heh
12:46:42 <dino-> Trying now, I was busy ranting about GoDipshit
12:47:01 <shapr> donri: Not so much lojban anymore. Much more ten years ago. Lojban was one thing that got me into Haskell, I still want to make a spoken programming language.
12:47:11 <shapr> donri: But Haskell became an end unto itself, and here I am...
12:47:20 <dino-> I get charming answers like "I don't now what a log is. I never look at logs. I wouldn't know where to find them."
12:47:45 <shapr> dino-: Impressive!
12:48:36 <monochrom> spoken programming language: sudo make sandwich
12:49:03 <donri> ko jukpa lo snuji
12:49:08 <dino-> Ok, when I build with -static and -optl-static I get a lot of output like "undefined reference to `pthread_mutex_unlock'" type things.
12:49:29 <sproingie> i think 99% of lojban spoken is conversations about lojban
12:49:42 <dino-> And no binary is produced.
12:49:51 <kmc> 99% of Haskell code is about Haskell
12:49:57 <donri> sproingie: More like "coi" and "co'o" (hello and goodbye)
12:50:15 <kmc> dino-, ok, so we come back to your original cmd line.  what happens with -optl,-pthread ?
12:50:22 <kmc> err -optl-pthread
12:50:23 <sproingie> i remain sneeringly dismissive of invented languages with prescriptive structure
12:50:26 <kmc> whichever
12:50:28 <MasseR> dino-: -lopt-pthread
12:50:32 <sproingie> as spoken ones go anyway
12:50:38 <MasseR> No wait
12:51:01 <donri> sproingie: Can't have descriptivism without a very large and active speakerbase.
12:51:22 <dino-> with all three, -static -optl-static -optl-pthread it builds quietly, but then barfs when I run it.
12:51:22 <MasseR> Yep -lopt-pthread works with me
12:51:31 <kmc> what kind of bafr
12:51:34 <kmc> barf even
12:51:43 <dino-> A.cgi: ../sysdeps/unix/sysv/linux/getpagesize.c:32: __getpagesize: Assertion `_rtld_global_ro._dl_pagesize != 0' failed.
12:51:57 <cts> Can anyone explain why "printgraph g" with this definitions
12:51:59 <cts>   http://pastebin.com/7T1Qp2iq
12:52:01 <cts> doesn't terminate?
12:53:56 <Saizan> cts: you need a custom Eq instance for Node
12:54:33 <cts> Saizan: I don't understand...
12:55:53 <Saizan> cts: untion and (\\) use (==) to compare the nodes, but "deriving Eq" produces a (==) that also checks if the neighbours are equal
12:56:35 <Saizan> a better solution is probably to filter them by names explicitly in printgraph
12:57:43 <Saizan> or maybe use an entirely different representation for Graph, like Map String [String] associating each node name with the name of its neighbours
12:58:07 <contrapumpkin> IntMap IntSet!
12:58:08 <contrapumpkin> :P
12:58:15 <cts> Saizan: But the neighbours should be the same, or not?
12:59:24 <Saizan> cts: but to check if they are the same you have to check if their neighbours are the same, etc.. and since your graph is cyclic you get into an infinite loop
12:59:47 <cts> Saizan: I see.  Thank you.
12:59:57 * kmc is vaguely annoyed that IntMap IntSet is a well-kinded type
13:00:09 <cts> Saizan: Is there a standard approach to represent graphs?
13:00:21 <wlangstroth> is the graph directed?
13:00:22 <McManiaC> cloning the GHC darcs repo is slooow :>
13:01:16 <cts> wlangstroth: Yes, this one is, but I'm interested in undirected graphs, too.
13:01:22 <Saizan> cts: there are various a common one is what i described above, maybe using Int rather than String
13:01:24 <wlangstroth> (sorry, of course it is) - if you're trying something different, you could always just store the edges
13:01:38 <gwern> McManiaC: you using --lazy?
13:01:51 <dschoepe> McManiaC: the fun part is, after the first darcs get you have to run a darcs-all script which also takes about the same amount of time :)
13:01:53 <shapr> sproingie: I'm more interested in the tractability of unnatural language recognition.
13:01:57 <McManiaC> http://npaste.de/lw/ :)
13:02:20 <dschoepe> Yeah, lazy would have helped with that
13:02:27 <Saizan> cts: see also the fgl lib on hackage or Data.Graph in containers
13:02:48 <McManiaC> hmkay
13:02:49 <McManiaC> :D
13:02:54 <gwern> the smart thing to do is to --lazy first, and then do a 'darcs changes > /dev/null' later in the background
13:03:02 <cts> Saizan, wlangstroth: Thank you both!
13:03:16 <McManiaC> dschoepe: whats darcs-all?
13:03:37 <dschoepe> McManiaC: a script in the ghc repo that fetches all the required "subrepos"
13:03:38 <gwern> McManiaC: the base libraries are each a repo; darcs-all is a sh script which automates darcs getting pull each of them
13:03:48 <gwern> McManiaC: since yo udon't want to manually do it 7 or 10 times
13:04:15 <McManiaC> ah ok
13:04:44 <McManiaC> well, I dont have anything to do anyway...
13:04:44 <McManiaC> :D
13:05:54 <McManiaC> looks as if I'll get to hack myself into the GHC core soon :>
13:06:35 <Saizan> check the building/hacking guide on the tract
13:06:37 <Saizan> *trac
13:07:04 <McManiaC> ok :)
13:16:15 <kmc> McManiaC, whatcha hacking on?
13:16:43 <McManiaC> monad comprehension
13:16:49 <McManiaC> http://hackage.haskell.org/trac/ghc/ticket/4370 :D
13:18:07 <kmc> :D
13:18:25 * shapr cheers
13:21:59 <byorgey> McManiaC++
13:22:39 <dino-> Thanks everyone who helped with my cgi disaster.
13:24:00 <Saizan> solved?
13:24:12 <dino-> Saizan: no
13:24:23 <djahandarie> byorgey++
13:24:39 <McManiaC> whats this ++ thing?
13:24:42 <byorgey> =D
13:24:46 <dino-> I can build something with all those switches, including the -optl-pthread, on a Debian system and it does run.
13:25:00 <dino-> And still fails on this mysterious server where I can't see error logs.
13:25:02 <byorgey> McManiaC: it gives you karma
13:25:06 <byorgey> @karma McManiac
13:25:06 <lambdabot> McManiac has a karma of 2
13:25:22 <djahandarie> byorgey, if I wanted to try and hack in some translation for value-level functions to type families, where should I start? :)
13:25:27 <byorgey> McManiaC: the idea is you give out ++ to people who do something nice/helpful/funny/etc.
13:25:30 <dino-> No idea what's over there. I guess I could wrote some Perl script that dumps env var values, other things. Since I can't get a proper shell on it.
13:25:38 <byorgey> unfortunately it has fallen mostly into disuse.  but I don't see why.
13:25:39 <djahandarie> (Note: Literally zero background in the GHC code base.)
13:25:42 <contrapumpkin> djahandarie: that's pretty ambitious :P
13:25:51 <McManiaC> byorgey: ok :)
13:25:53 <djahandarie> contrapumpkin, I'm just curious
13:26:00 <djahandarie> And stop changing your name it's getting confusing :P
13:26:01 <contrapumpkin> djahandarie: how will you lift fix Suc to the type level?
13:26:29 <djahandarie> By thinking about it hard at a later time :P
13:27:07 <shapr> byorgey++ # for advertising ++
13:27:09 <benmachine> byorgey: doesn't lambdabot have a tendency to periodically forget everyone's karma
13:27:11 <shapr> @karma byorgey 
13:27:11 <lambdabot> byorgey has a karma of 25
13:27:15 <shapr> benmachine: There is that...
13:27:18 <gwern> benmachine: and quotes!
13:27:20 <benmachine> also it's just numbers who cares :P
13:27:22 <shapr> @karma
13:27:22 <lambdabot> You have a karma of 5
13:27:23 <byorgey> djahandarie: I'm really not sure.
13:27:30 <shapr> I have had a higher karma in the past...
13:27:33 <gwern> because no one will record periodically lambdabot's state files :(
13:27:37 <olsner> shapr++ here, have some more
13:27:40 <shapr> Yay!
13:27:41 <gwern> I kept bugging Cale  and lispy to do it more, but no...
13:27:54 <shapr> gwern: We could store it in Tahoe-LAFS mebbe?
13:27:56 <copumpkin> @karma shapr
13:27:56 <lambdabot> shapr has a karma of 6
13:27:56 <byorgey> the point is not to amass a huge number.  The point is to have a concise way of letting people know they are appreciated.
13:28:01 <gwern> if cassandra weren't such a common name, I'd use that nick instead
13:28:06 <shapr> byorgey: Ah, good point!
13:28:16 <copumpkin> byorgey: no, the point is to get a huge number
13:28:18 <benmachine> byorgey: right, so the counting is irrelevant more or less :P
13:28:21 * shapr grins
13:28:26 <benmachine> just saying it is fine
13:28:28 <gwern> shapr: no, that's not the problem at all. the problem is the !@$%s who run lambdabot won't do anything
13:28:29 <copumpkin> if people get helped in the mean time, that's an unfortunate side effect
13:28:49 <djahandarie> Side effects? Let's write a monad for this!
13:29:02 * benmachine giggles
13:29:10 <dino-> I should mention this too: couple of weeks ago I released my first Android program, written entirely in Scala. I tried to treat it like Haskell. As little object mutation as I could get away with. Using immutable data structures as much as I dared, etc..
13:29:47 <dino-> Absolutely no methods on any class being used as an ADT
13:29:48 <byorgey> well, there's already a monad for asking questions, with  ask :: q -> Ask q  and  dontasktoaskjustask :: Ask (Ask q) -> Ask q
13:30:16 <shapr> gwern: So, host lambdabot yourself?
13:30:20 <copumpkin> byorgey: lol
13:30:21 <shapr> gwern: Worked for me :-)
13:30:25 <gwern> shapr: I am too unreliable
13:30:29 <shapr> Ah
13:30:29 <gwern> my network is often cut off
13:30:31 <olsner> byorgey: appropriately, the latter is just an alias for 'join', but I guess most people miss that :P
13:30:45 <olsner> join then ask to ask again :/
13:30:45 <byorgey> olsner: indeed =)
13:30:50 <shapr> gwern: I have a virtual server... and could give you access.
13:30:51 <copumpkin> one question can lead to another, in which case you get bind
13:30:57 <gwern> shapr: then you host lb!
13:31:01 <dino-> http://www.appbrain.com/app/spectrahex.demo.ui
13:31:38 <gwern> shapr: I also don't especially care, because AFAIK #haskell has continuous logs going back many years, and it should be possible to get a 'true' lambdabot state just by 'cat'ing them all into lambdabot
13:31:55 <olsner> that would be a fun experiment
13:31:58 <byorgey> wasn't someone working on that at one point?
13:31:58 <gwern> (good ol tunes.org. I don't know why they are logging us, but they are)
13:32:13 <vitka> And unsafeUseAnswer when you use it with no regard how it'll fit in your code.
13:32:32 <byorgey> vitka: hehe
13:33:04 <gwern> olsner: I think I did it once. fairly slow but finished in a few hours
13:34:42 <shapr> gwern: ooh, point
13:35:11 <gwern> shapr: so, not a big priority on my part. now, if tunes.org threatened to stop logging or went under...
13:35:20 <shapr> gwern: They're logging us because the guy showed up early on and asked if we wanted it.
13:35:35 <shapr> So I said yes. I mean, there were like... thirty? people here.
13:35:59 <olsner> that's like 614 people ago
13:36:12 <gwern> if tunes.org did make that threat, I would instantly swing into action since their robots.txt blocks archiving and I would be unable to retrieve logs from the Internet Archive
13:38:36 <sky__> evening
13:40:57 <shapr> gwern: What sort of code you working on latery?
13:41:03 <gwern> Hakyll
13:41:07 <gwern> building www.gwern.net
13:41:31 <gwern> (turns out gitit does an awful lot and I've effectively been rewriting some features)
13:42:12 <sky__> i need a little help, i implemented a haskell chaos game, but it's kinda slow
13:42:23 <tommd> Make it faster
13:42:35 <sky__> i think the bottle neck is the function that write the data on the disk
13:42:37 <gwern> on the other hand, hakyll-generated sites are much faster than gitit, so I think it's been worth it
13:42:38 <sky__> http://pastebin.com/twb9YgbA
13:42:57 <tommd> sky__: Why are you guessing?  Have you tried profiling?  How much time does the GC take?
13:43:02 <sky__> any idea to make it faster, even urls would be good, i'm out of ideas
13:43:03 <gwern> sky__: why is a game writing to disk?
13:43:14 <sky__> it's not rly a game
13:43:26 <gwern> pickRandom looks pretty terrible
13:43:36 <sky__> http://en.wikipedia.org/wiki/Chaos_game
13:43:53 <gwern> I would wonder about hPutVec
13:44:15 <tommd> sky__: use bytestring IO, not [Char].
13:44:27 <monochrom> how large are the files?
13:44:28 <copumpkin> wow
13:44:31 <gwern> but yeah. you should profile this
13:44:34 <gwern> it looks easy to profile
13:44:35 <copumpkin> hPutVec--
13:45:00 <sky__> should be around 1 MB with 500k points generated
13:45:12 <sky__> maybe less
13:45:17 <Botje> sky__: swap [Float] for a custom datatype.
13:45:33 <dobblego> nest looks borked
13:45:40 <copumpkin> sky__: look at intersperse and intercalate for hPutVec, but I'd use Binary and ByteStrings for that (but yeah, profile first)
13:46:08 <copumpkin> also, seqn == sequence_
13:46:11 <copumpkin> :t sequence_
13:46:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
13:46:28 <dobblego> nest == iterate
13:46:39 <sky__> wow many new things ^^
13:46:43 <dobblego> add = zipWith (+)
13:46:51 <copumpkin> it's trying to be stricter than iterate, but I'm not sure it's succeeding
13:47:26 <dobblego> pickRandom is going to cause issues with (!!) and length
13:47:26 <copumpkin> sky__: it's nice and clean code though
13:47:58 <sky__> i tried to dont make the (f x) a strict evaluation but it didnt improve the time performance
13:48:04 <sky__> thx copumpkin 
13:48:35 <sky__> (actually i'm supriesed it wasnt worse without strict eval)
13:48:42 <dobblego> concat (map f xs) = xs >>= f
13:49:41 * hackagebot tls 0.2 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.2 (VincentHanquez)
13:49:53 <tommd> also, there's concatMap
13:50:00 <sky__> i will google the profiling and the data types you guys mentioned,  thx
13:50:05 <monochrom> w00t, haskell weekly news!
13:50:40 <sky__> dobblego: about randomPick, how would you implement it?
13:51:12 <monochrom> goddammit, stackoverflow questions?
13:51:30 <copumpkin> lol
13:51:51 <sky__> lol soz
13:52:00 <gwern> monochrom: well, that is sort of the raison d'etre of #haskell
13:52:02 <gwern> helping teh nubs
13:52:16 <sky__> and thanks ^^
13:52:21 <monochrom> soon there will also be a section for "ask yahoo!"
13:56:34 <geheimdienst> yahoo answers : stack overflow :: visual basic : haskell
13:57:21 <aristid> hmm, if maths notations had folds, some things might be much nicer to read. i'm thinking about stuff like sum_i (-1)^i * a_i
13:58:03 <aristid> in haskell: foldr1 (-)
13:58:04 <byorgey> aristid: it already has folds, that's what sum is.  what you need is zipWith and cycle.
13:58:46 <byorgey> sum . zipWith (*) (cycle [1,-1])
13:59:06 <byorgey> foldr1 (-) is too confusing.
13:59:11 <copumpkin> > foldr (-) 0 [a,b,c,d] :: Expr
13:59:12 <lambdabot>   a - (b - (c - (d - 0)))
13:59:16 <aristid> byorgey: foldr1 (-) is confusing?
13:59:24 <byorgey> yes.
13:59:32 <res> how so?
13:59:33 <copumpkin> aristid: it's not obvious
13:59:48 <copumpkin> but I agree
13:59:49 <res> neither is programming itself
13:59:50 <aristid> copumpkin: obvious from what? if sum_i (-1)^i is given, it's not obvious
13:59:51 <copumpkin> indices should be murdered
14:00:00 <byorgey> I suppose it could be immediately obvious to some people what foldr1 (-) does, but it isn't to me.
14:00:02 <copumpkin> (-1)^i is even more evil
14:00:04 <aristid> copumpkin: but sum_i (-1)^i is far from trivial either
14:00:36 <copumpkin> I agree
14:00:38 <aristid> byorgey: the thing is, if you start from a_1 - (a_2 - (a_3 - ...
14:00:47 <aristid> byorgey: then foldr1 (-) is just the natural translation
14:01:01 <aristid> instead of the indexed sum with (-1)^i
14:01:09 <byorgey> well, that's true.  but seeing the connection to a sum with alternating signs isn't obvious.
14:01:20 <aristid> i did see it :)
14:01:22 <byorgey> I guess it depends which interpretation you want to emphasize.
14:02:42 <aristid> byorgey: it's hard to say because the established notation is established so it might feel more natural due to experience
14:03:44 <byorgey> aristid: well, that's a good point.
14:06:26 <monochrom> when I was a student, it took me no less effort to see and remember (yes, rote memorization) that the (-1)^i trick (yes, repeat: trick) encodes (you read it right, encodes) alternating sums.
14:10:09 <tommd> Don't ask me why, but my brain was trying really hard to read that sentence with every word inverted.  "Now you are many professionals, it gave you yes more lazi-fare to blind yourself and forget that the obvious logBase i 1 decodes (I read it wrong, decodes) consistent differences."
14:10:25 <monochrom> here is the deal. before learning that, if someone would ask me "how to write '1-2+3-4+5...' without the '...' but rather with sum", I would have no idea. and if someone would ask me "what sum or series do you think 'sum (-1)^i a_i' stand for", I would have no idea either.
14:10:37 <c_wraith> I still have yet to be convinced by an argument about why sum(i=0, i -> infinity, (-1)^i) diverges.
14:11:03 <byorgey> tommd: shouldn't that be "I wrote it wrong"?
14:11:20 <tommd> byorgey: Good catch.
14:11:35 <monochrom> then finally the teacher told us "well expand 'sum (-1)^i a_i' and see the pattern" and I saw "oh so that's how you do alternating sums, that's a clever trick".
14:11:51 <geheimdienst> lazi-fare is very nice ... lazy-fare
14:11:51 <monochrom> so you see it is totally unnatural, it's taught not intuited.
14:12:35 <monochrom> and to date I still feel that raising -1 to a huge power like 10000001 just for saying "-1" is an ugly kludge.
14:12:50 <pumpkin_> I agree
14:12:52 <pumpkin_> indices are the devil
14:12:52 <byorgey> monochrom: hehe, indeed
14:12:59 <monochrom> so yes, foldr1 (-) is so much more elegant.
14:13:04 <tommd> geheimdienst: Yeah, I was too lazy to look up the spelling (LAISSEZ-FAIRE) but now you made me go and do it.
14:13:13 <byorgey> maybe something like   sum . zipWith (*) (iterate (*) (-1)) is more fundamental
14:13:24 <pumpkin_> iterate negate
14:13:30 <byorgey> I mean (iterate negate 1), yes
14:13:31 <geheimdienst> but i like lazy-fare better
14:13:48 <geheimdienst> btw, why is every word negated, not every second?
14:13:54 <JNuS> hi, anyone here that has experience of gtk2hs on mac?
14:14:15 <res> I have the experience "it's a pain"
14:14:17 <monochrom> there is nothing natural or intuitive about math. go for pure elegance.
14:14:40 <JNuS> res: haha yeah thats about the same as me
14:15:00 <JNuS> need it for school though...
14:16:15 <res> what kind of school forces you to do GUIs?
14:16:20 <JNuS> chalmers
14:16:25 <JNuS> its a lab
14:16:30 <res> are you doing graphic design or something
14:16:34 <JNuS> nope
14:16:38 <monochrom> the chicago school of GUI
14:16:39 <res> which course?
14:16:55 <JNuS> introduction to functional programming its called
14:16:58 <copumpkin> lots of good stuff happening at chalmers
14:17:04 <JNuS> oh yes :D
14:17:17 <monochrom> apparently there is a chicago school of just about everything! of style, of philosophy, of economics, of logic...
14:17:24 <JNuS> just started the civilengineer program
14:17:33 <JNuS> computer science
14:17:39 <sproingie> monochrom: pizza
14:17:44 <JNuS> dunno if its the same thing in english though
14:18:09 <monochrom> only exception: there is no chicago school of cabal XD
14:19:16 <JNuS> Master of Science in Engineering, Computer engineering
14:19:19 <JNuS> thats it!
14:19:57 <gwern> monochrom: don't forget of politics
14:20:03 <gwern> not the windy city for nothing
14:20:08 <monochrom> I keep forgetting politics :)
14:20:09 <sproingie> Master of Science in Pizza Engineering
14:20:25 <pumpkin_> that should definitely come with a mandatory sex ed course
14:20:32 * monochrom is blissfully ignorant of politics
14:20:48 <pumpkin_> pizza delivery people get the most action, if certain movies don't lie
14:21:08 <sproingie> that and cable installers
14:21:58 * geheimdienst was under the impression that porn actors get the most action
14:22:17 <pumpkin> no, definitely pizza delivery people, cable "servicemen", and plumbers
14:22:34 <pumpkin> anyway, this belongs in -blah :P
14:22:37 * pumpkin kicks himself
14:22:40 <gwern> masters in pizza engineering? that sounds like a joke from _Snow Crash_
14:23:39 <geheimdienst> MSc Cable Engineering
14:23:52 <FauxFaux> s/b//
14:24:06 <sky__> "there is nothing natural or intuitive about math" out of sync, but once von Neumann said "we dont understand math, we get used to it" :)
14:24:11 <ClaudiusMaximus> sky__: http://hpaste.org/40422/chaos_game -- should be significantly faster
14:24:36 <gwern> there is no math modality in the brain
14:24:41 <sky__> gonna give it a try thx a lot
14:25:07 <gwern> sky__: incidentally system.random is known to be slow. if profiling fingers random generation, then tryswtiching to the mersenne package mabe
14:25:16 <pumpkin> mwc
14:26:37 <pumpkin> @ask chrisdone could you add agda as a language option in hpaste and just use the haskell parser on it, for now? at least it'll be easy to tell at a glance on the overview which pastes are agda
14:26:37 <lambdabot> Consider it noted.
14:28:52 * hackagebot enumerator 0.4.1 - Implementation of Oleg Kiselyov's left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.1 (JohnMillikin)
14:32:03 <sky__> still a couple of seconds for 1k points ClaudiusMaximus ^^, tomorrow i will look for mersenne rnd gen too gwern thx. I'm feeling sleepy now, good night all 
14:35:05 <JNuS> anyone experienced with gtk2hs?
14:35:12 <JNuS> i would be really grateful!
14:35:27 <sky__> soz, your version is ALOT faster
14:35:58 <sky__> i forgot to update the makefile before ^^ my bad 
14:36:24 <sky__> thx again, good night
14:38:00 <gwern> another satisfied customer
14:38:11 <gwern> unfortunately, our quarterly revenue is still zero, so we're still in the red
14:38:35 <pumpkin> Apocalisp: that's a nice way of putting Liskov
14:39:20 <Apocalisp> haha, thanks
14:40:54 <Apocalisp> puttking Liskov _in her place!_
14:44:52 <kmc> so there's a billion and five ways to access sqlite from Haskell
14:45:06 <kmc> and generally a lot of DB layers
14:45:07 <kmc> is there an article comparing them?
14:46:29 <ivanm> nope
14:46:32 <Apocalisp> I found HaskellDB to be pretty nice
14:46:33 <ivanm> but people keep asking for one
14:46:35 <Apocalisp> if that helps
14:46:53 <ivanm> IIRC, HDBC is a bit lower-level than HaskellDB
14:47:10 <kmc> so HaskellDB is a layer that can use either hdbc or hsql?
14:47:15 <kmc> and both of those have sqlite backends
14:49:06 <Apocalisp> HaskellDB has an ADT for specifying (correct) databases, and a compiler to various SQL dialects
14:49:22 <Apocalisp> sqlite among them
14:49:37 * kmc is vaguely sick of SQL and eyes the CouchDB and mongoDB modules
14:49:39 <ivanm> kmc: haskelldb doesn't seem to be able to use  hdbc...
14:50:15 <Apocalisp> SQL is 1970s technology, man
14:50:30 <kmc> so is Hindly-Milner type inference
14:50:34 <Apocalisp> hah
14:51:18 <pumpkin> I quite like SQL
14:51:25 <dolio> HM is early 80s technology, I think.
14:51:25 <pumpkin> but also don't
14:51:54 <pumpkin> I feel much more comfortable if my SQL has CTEs
14:52:00 <kmc> i like relational algebra; it seems like SQL is a clunky way of doing it
14:52:29 <Apocalisp> SQL is just a totally ad-hoc approximation of relational algebra
14:52:52 <pumpkin> speaking of relational algebra or formalizing sql
14:53:12 <pumpkin> has anyone found a succinct way of describing outer joins mathematically?
14:53:21 <Apocalisp> yeah, I hear some people in Boston are working on a typed relational algebra
14:53:53 <Apocalisp> pumpkin: If anyone has, it would be Date and Darwen
14:54:46 <pumpkin> I'll take a look, thanks
14:54:56 <pumpkin> cause an inner join is roughly a pullback
14:55:04 <dolio> Oh, it is late 70s.
14:55:09 <dolio> ML was 80s, I guess.
14:55:10 <pumpkin> but outer joins seem rather more ad-hoc and ugly
14:55:53 <Apocalisp> pumpkin: I think their solution is relation-valued attributes
14:59:53 <nudded> Can anybody explain to me whether i can think of a functor as a computational context. Or is that only the case for a Monad?
15:00:22 <pumpkin> define computational context?
15:00:47 <pumpkin> a monad is (abstractly) just a functor with some additional requirements
15:00:57 <nudded> yes i understand that part
15:01:23 <nudded> just that a Functor is more than only a 'thing' that can be mapped over
15:01:53 <pumpkin> I mean, being able to map over it (in a meaningful way) is the only requirement to be a functor
15:01:54 <ivanm> well, a functor is a thing that possibly contains values that can be mapped over in a structure-preserving way
15:02:00 <ivanm> i.e. fmap id == id
15:02:20 <Apocalisp> nudded: Yeah, a functor is like a computational context where you cannot change the context.
15:02:49 <ivanm> Apocalisp: and what is a computational context?
15:02:49 <jaspervdj> In that case, computational context is basically a reader monad/functor, really
15:03:16 <danharaj> The concept of a functor is very general. The best thing to do is just internalize the idea like you internalized addition and multiplication as a child.
15:03:27 <danharaj> Because it comes up everywhere.
15:03:35 <nudded> ivanm: the structure-preserving way makes a lot of sense, thx
15:03:38 <pumpkin> danharaj: as a haskell programmer not interested in CT, it's not quite as general
15:03:43 <ivanm> yeah... see Caleskell :s
15:03:48 <ivanm> @type flip
15:03:49 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:04:17 <danharaj> pumpkin: I think it is general enough to cover a huge class of datastructures and other computational structures that don't look to have much in common without the notion of a functor guiding your intuition.
15:06:05 * hackagebot random-extras 0.18 - Additional functions for random values.  http://hackage.haskell.org/package/random-extras-0.18 (AristidBreitkreuz)
15:06:14 * pumpkin shrugs
15:06:32 <pumpkin> most Functors can be seen pretty easily as containers of some sort or another
15:06:43 <dolio> I wouldn't say most.
15:06:44 <pumpkin> at least the common ones
15:06:46 <geheimdienst> danharaj: could you say that a haskell functor is similar to a seq in clojure?
15:06:52 <dolio> Most that show up in Haskell on a regular basis, maybe.
15:06:56 <danharaj> I don't know what a seq in clojure is.
15:06:58 <sproingie> geheimdienst: much more general
15:07:05 <pumpkin> dolio: yeah, I'd already restricted it to haskell earlier :)
15:07:35 <danharaj> there are those that don't show up regularly though.
15:07:50 <pumpkin> like what?
15:07:51 <jaspervdj> pumpkin: Well, it's not true in the exact sense, but it's a good way of gaining intuition
15:07:54 <pumpkin> andrej's ones?
15:08:06 * hackagebot explicit-iomodes-text 0.1.0.2 - Extends explicit-iomodes with Text operations  http://hackage.haskell.org/package/explicit-iomodes-text-0.1.0.2 (BasVanDijk)
15:08:06 <danharaj> And very few people have the luxury of only dealing with the 'regular' objects in a programming language unless they are writing simple programs.
15:08:08 * hackagebot usb 0.6.0.2 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.6.0.2 (BasVanDijk)
15:08:10 * hackagebot safer-file-handles-text 0.1.0.3 - Extends safer-file-handles with Text operations  http://hackage.haskell.org/package/safer-file-handles-text-0.1.0.3 (BasVanDijk)
15:08:33 <sproingie> a functor is basically any parametric type that defines fmap
15:09:07 <nudded> sproingie: yes, but then anything is just a Typeclass
15:09:23 <danharaj> pumpkin: continuation monad? I dunno, does that show up in your work a lot?
15:09:24 <jaspervdj> sproingie: Not true -- for instance, fmap id == id needs to hold true over the functor
15:09:31 <pumpkin> danharaj: that's an existential "container" :P
15:09:50 <pumpkin> "I haz an object and can give it to you" if you give me a function that takes something of that type
15:10:08 <pumpkin> (the haz is crucial to the functorial nature of Cont)
15:10:10 <danharaj> the idea of a container is lame anyway. It takes us away from Church's paradise :p
15:11:03 <pumpkin> danharaj: yeah, I was just saying that most common monads (including ((->) r) and Cont r) can be explained in terms of containers (which most non-mathematician programmers have an intuitive, if not formal, notion of)
15:11:07 <Apocalisp> A functor is a homomorphism between categories. What's the big deal?
15:11:08 <pumpkin> common functors, that is
15:11:29 <danharaj> Apocalisp: How many people know what a homomorphism is :p
15:11:43 <sproingie> "f a" is s "something about a".  fmap (a->b) turns "something about a" into "the same something about b"
15:11:43 <pumpkin> I bet a large percentage of people would hate a homomorphism just on principle
15:11:46 <pumpkin> even without knowing what it is
15:11:53 <sioraiocht> pumpkin: I hate the name homomorphism
15:11:57 <fxr> danharaj: more than you imagine :)
15:12:00 <pumpkin> see, there you go
15:12:04 <pumpkin> sioraiocht hates homos
15:12:10 * sioraiocht is a homo.
15:12:12 <sproingie> so fmap on a list gives you a list.  fmap on Maybe gives you a Maybe
15:12:17 <pumpkin> sioraiocht: you're a homomorphism?
15:12:18 <sioraiocht> I feel like they appropriated my culture
15:12:19 <sproingie> that's the structure preserving aspect of it
15:12:29 <Apocalisp> homomorphism ~= structure-preserving map
15:12:32 <Apocalisp> easy!
15:12:37 * sioraiocht has been known to preserve structures.
15:12:41 <pumpkin> :O
15:12:50 <Ke> are you a map
15:12:51 <winxordie> a homomorphism is a homomorphism to a structure-preserving map?
15:13:05 <Axman6> Apocalisp: so fmap?
15:13:11 <Apocalisp> haha
15:13:38 <sioraiocht> metamorphisms and paramorphisms are far more offensive btw
15:13:39 <Apocalisp> yeah, exactly like fmap
15:13:40 * pumpkin is a homeosexual
15:14:07 <winxordie> I wonder why no one says idemsexual
15:14:14 <Ke> !
15:14:21 <pumpkin> (attracted to anything homeomorphic to a donut)
15:14:28 <pumpkin> which sadly excludes most people :(
15:14:45 <sproingie> mmm donut
15:14:46 <sioraiocht> isn't idem- latin?
15:14:56 <Ke> yes, people have 2 holes
15:15:08 <sproingie> yes but we're a big tube
15:15:22 <pumpkin> man, I've really devolved the conversation level in here
15:15:25 <winxordie> I was actually wondering today what the genus of a human is.
15:15:26 <Ke> hmm
15:15:32 <winxordie> Two holes, but they're connected, non?
15:15:46 <sproingie> right, so you're isomorphic to a donut
15:15:51 <pumpkin> not just two holes
15:15:55 <pumpkin> your face is full of them
15:15:57 <Ke> actually 3 holes, since we have 2 nostrils
15:16:07 <winxordie> but they're not actually holes through the human
15:16:31 <pumpkin> winxordie: sure they are, your ears are connected to your respiratory path which is connected to mouth/nostrils (And even eyes if you stretch it)
15:16:35 <pumpkin> and of course, the "other side"
15:16:36 <nudded> winxordie: but 1 entrance maps to 2 exits
15:16:50 <sproingie> well if you count permeable mucus membranes, we got billions of holes
15:16:53 <winxordie> pumpkin: right, but they're also connected to the mouth<->anus hole too
15:16:58 <pumpkin> winxordie: yeah, I know
15:17:01 <pumpkin> that's what I meant by "other side"
15:17:07 <winxordie> hmm
15:17:08 <sproingie> then again donuts are also riddled with pores like that too
15:17:12 <sproingie> except for glazed ones
15:17:17 <pumpkin> lol
15:17:17 <winxordie> ok, so for Platonic humans and donuts
15:17:20 <winxordie> I'd say genus 1
15:17:26 <pumpkin> winxordie: I wouldn't, still
15:17:28 <winxordie> *platonic forms
15:17:30 <sproingie> platonic noseless humans
15:17:35 <centrinia> I thought that we are simply a collection of deformed spheres.
15:17:37 <winxordie> pumpkin: alrighty, name thy genus!
15:18:03 <pumpkin> winxordie: hey, I'm a pumpkin, I hae genus 0
15:18:24 <winxordie> pumpkin: but the photosynthesis and the xylem!
15:18:28 <centrinia> Some pumpkins have genus 5.
15:18:32 <geheimdienst> 'scuse me, but the eardrum is in the way. i don't think you could go from the ear into the mouth without penetrating body tissue
15:18:34 <pumpkin> also cucurbita
15:18:38 <pumpkin> centrinia: :(
15:18:48 <sproingie> geheimdienst: actually you can.  eustachean tubes
15:18:49 <jaspervdj> i've actually written a program to calculate a genus of a graph once <_<
15:18:52 <winxordie> at least, I think pumpkins have that residue tissue...
15:18:56 <jaspervdj> running it on pumpkin now
15:19:12 <pumpkin> jaspervdj: ouch, this feels weird and tingly
15:19:18 * winxordie clearly needs to study more biotopology
15:19:19 <geheimdienst> sproingie: those are on the inside of the eardrum
15:19:52 <sproingie> of course i've had it in the ear before
15:19:55 <sproingie> cuz of a lust for life
15:19:58 <jaspervdj> pumpkin: actually, I need to map you onto a graph first
15:20:08 <newsham> ?type let arg = readFile "a" {-for example-} in \f -> join (f <$> return arg <*> return arg <*> return arg)
15:20:09 <lambdabot> forall (m :: * -> *) a. (Monad m, Applicative m) => (IO String -> IO String -> IO String -> m a) -> m a
15:20:25 <pumpkin> anyway, wikipedia here says my genus is cucurbita, as I said
15:20:25 <pumpkin> http://en.wikipedia.org/wiki/Cucurbita
15:20:51 <winxordie> 0 == cucurbita?
15:21:08 <sioraiocht> wow, what thick cell walls you ahve
15:21:19 <pumpkin> winxordie: yeah
15:21:42 <centrinia> You are in the same genus as cucumbers?
15:22:05 <sproingie> grandma, what bicollateral vascular bundles you have!
15:22:06 <geheimdienst> centrinia: typo, they're called cocumbers
15:22:29 <sproingie> the better to ... uh whatever those are for
15:22:42 <pumpkin> lol
15:23:33 <centrinia> What is the genus of Swiss cheese?
15:23:52 <newsham> cowicus milkius
15:24:07 <pumpkin> lol
15:24:45 <geheimdienst> cowicus milkius helvetica
15:24:53 <the_unmaker> is it true that os level threads can be outperformed by some kind of lightweight forking?
15:24:57 <centrinia> Shouldn't genus be a nonnegative integer?
15:25:03 <aristid> 5
15:25:08 <the_unmaker> or by anything?
15:25:11 <monochrom> yes
15:25:34 <kmc> the_unmaker, in as much as that's a very vague statement, yes, i can instantiate it to a true statement
15:25:34 <Cale> the_unmaker: OS threads are typically quite expensive
15:25:42 <sproingie> the definition of "lightweight" presumes that they're lighter than the OS threads
15:25:44 <pumpkin> kmc: geek :P
15:26:02 <sproingie> but purely green threads won't use multiple CPUs
15:26:10 <kmc> but systems like GHC's runtime system will
15:26:19 <monochrom> trivial example: create a thread whose code immediately quits. os threading cannot compete with green threading at this.
15:26:21 <sproingie> sure, it's a hybrid thing
15:26:25 <kmc> multiplexing hundreds of thousands of green threads across a configurable number of OS threads
15:27:07 <kmc> Haskell gets an advantage too from purity (which makes it easy to exploit parallelism without explicit threads) and non-sucky abstraction (which makes it easy to do explicit threading when you like)
15:27:12 <sproingie> OS threads are getting better, but its hard to compete with having no context switch at all
15:27:37 <Axman6> the_unmaker: it's not uncommon to use hundreds of haskell threads, where using more than a dozen or so OS threads would be quite rare almost anywhere
15:28:03 <the_unmaker> ok to be clear, these haskell threads CAN use a 8 cpu box?
15:28:10 <sproingie> yes
15:28:10 <tnks> am it true that you can't define custom data types in ghci?
15:28:12 <the_unmaker> or are they stuck on 1 cpu?
15:28:19 <kmc> the_unmaker, anyway, Haskell or Erlang systems with green threading regularly spawn hundreds of thousands of threads on a modest desktop-class machine.  Linux will shit itself totally at that stage, that's almost 200 GB of stack alone with default config
15:28:20 <pumpkin> the_unmaker: you can ask the haskell runtime to use any number of OS threads
15:28:21 <tnks> is it, sorry.
15:28:23 <monochrom> it is good news that os threading keeps improving. more choices for everyone!
15:28:39 <pumpkin> the_unmaker: it will take care of distributing the haskell threads over the OS ones
15:28:44 <the_unmaker> and haskell will spread its green threads accross the 8 cpus?
15:28:47 <kmc> the_unmaker, yes.  compile with «ghc -threaded --make foo.hs»; run with «./foo +RTS -N8»
15:28:50 <Axman6> the_unmaker: under GHC, you run programs using a certain number of OS threads, which you specify, and all your haskell threads are spread among those OS threads
15:28:58 <the_unmaker> NICe
15:28:59 <kmc> you now have all your Haskell threads multiplexed onto those 8 OS threads
15:29:01 <the_unmaker> just liek that?
15:29:03 <newsham> ?seen saizan
15:29:03 <lambdabot> Unknown command, try @list
15:29:03 <sproingie> tnks: yes, ghci has a limited ability to create new definitions.  you generally need full blown ghc for that
15:29:03 <kmc> yup
15:29:10 <newsham> preflex: seen saizan
15:29:10 <preflex>  saizan was last seen on #haskell 2 hours, 5 minutes and 10 seconds ago, saying: solved?
15:29:13 <the_unmaker> WOW
15:29:14 <Saizan> newsham: pong?
15:29:24 <the_unmaker> this sounds like something lisp even would have a problem doing
15:29:30 <newsham> saizan: I came up with a soln I like for that applicative thing I asked earlier
15:29:35 <kmc> the_unmaker, and this includes not only explicit threading but parallelism annotations, which are just like "compute x and y in parallel".  no explicit thread, no synchronization or communication on your part
15:29:35 <the_unmaker> I am a novice programmer.....
15:29:43 <pumpkin> newsham: oh, I'm curious too
15:29:44 --- mode: ChanServ set +o mauke
15:29:44 --- mode: mauke set +q *!*@gateway/web/freenode/ip.216.52.235.101
15:29:52 <sproingie> NPTL can deal with thousands of threads without breaking a sweat
15:29:53 <mauke> @protontorpedo
15:29:53 <lambdabot> help please
15:29:56 <Axman6> the_unmaker: threading in haskell is much easier than any other language i've used. and parallelism is even easier
15:29:56 <mauke> @protontorpedo
15:29:56 <lambdabot> why did someone create haskell?
15:30:05 <Saizan> newsham: nice, paste?
15:30:09 <kmc> the_unmaker, it's just an implementation thing.  Lisp could have implementations that work this way; I'm not sure if it does
15:30:13 <newsham> saizan: I have "type ESnap = ErrorT String Snap".  my soln is to write a simple   ejoin :: ESnap (Snap x) -> Snap x
15:30:18 <pumpkin> mauke: why'd you quiet him?
15:30:29 <mauke> pumpkin: we already have a bot to replace him
15:30:29 <kmc> the_unmaker, this is not really a property of Haskell, but of GHC.  the basic Haskell specs don't even say anything about threading
15:30:30 <newsham> then the functions are just:   ejoin (f <$> x)   and   ejoin (f <$> x <*> y)   etc..
15:30:40 <mauke> pumpkin: he's redundant now
15:31:01 <mauke> @protontorpedo
15:31:01 <lambdabot> is it a form of lisp?
15:31:15 <sproingie> not nice
15:31:29 <Axman6> mauke: who did you quiet?
15:31:30 * kmc wonders idly what's going on
15:31:42 <mauke> Axman6: protontorpedo a.k.a. the_unmaker 
15:31:44 --- mode: mauke set -o mauke
15:31:49 <kmc> hahaha
15:31:50 <Axman6> uh, why?
15:31:55 <sproingie> ohhhh same guy?
15:32:06 <Axman6> he wasd asking relevant questions
15:32:09 <Axman6> wtf?
15:32:10 <aristid> @protontorpedo
15:32:10 <lambdabot> how deos haskell differ from ml or lisp?
15:32:13 <Axman6> -d
15:32:30 <aristid> mauke: so, how does haskell differ from ml or lisp??!?!?!
15:32:39 <sproingie> if he's the same guy i think he is, he will start relevant then *endlessly* follow up with increasingly inane ones
15:32:46 <sproingie> and i mean for hours and hours
15:32:50 <kmc> we could quiet him then
15:32:59 <res> any non-globally-installed openbsd ghc ports?
15:33:02 <newsham> http://hpaste.org/40423/ejoin__for_saizan_and_pumpkin
15:33:03 <sproingie> the name i remember was isomethingorother
15:33:04 <Axman6> i agree with kmc, this is extremely bad form
15:33:07 <sproingie> started with an i
15:33:44 <sproingie> ipatrol, that's it
15:33:48 <pumpkin> newsham: nice
15:34:06 <pumpkin> newsham: can it be generalized from just ESnap?
15:34:22 <newsham> well you'll notice that my join's type is restricted to "()"
15:34:28 <newsham> since thats how my error handler rolls
15:34:32 <pumpkin> Axman6, kmc: it's actually protontorpedo, apparently
15:34:37 --- mode: ChanServ set +o monochrom
15:34:53 --- mode: monochrom set -q *!*@gateway/web/freenode/ip.216.52.235.101
15:34:54 <newsham> i guess if you provided a  (String -> Snap a)   error handler it could be generic?
15:34:57 <newsham> *shrug*  I dunno
15:35:08 <newsham> i mean.. it will work wheneve ryou have the appropriate join.. but the join is going to be specific, no?
15:35:32 <kmc> *shrug*
15:35:39 <newsham> i guess you could generaliaze it for ErrorT with a handler as an argument
15:35:49 <Saizan> it think it's more general to stick to the transformed monad
15:36:20 <newsham> saizan: yah, i considered making my handler functions be a->b->c->ESnap ()
15:36:32 <pumpkin> oh okay
15:36:32 <newsham> then its just a normal "join"
15:36:47 <newsham> but thats just more work for writing handlers which is written a lot more often than the boilerplate
15:36:50 <newsham> so i decided against it
15:37:09 <Saizan> ?type let ljoin m = do z <- m; lift z in \f x y -> ljoin (f <$> x <*> y)
15:37:11 <lambdabot> forall a a1 (m :: * -> *) b (t :: (* -> *) -> * -> *). (Monad (t m), MonadTrans t, Monad m, Applicative (t m)) => (a -> a1 -> m b) -> t m a -> t m a1 -> t m b
15:38:44 <newsham> ?type \f x y -> join (f <$> return x <*> return y)
15:38:45 <lambdabot> forall a a1 (m :: * -> *) a2. (Monad m, Applicative m) => (a -> a1 -> m a2) -> a -> a1 -> m a2
15:39:08 <Saizan> if you add returns you aren't doing much..
15:39:49 <newsham> ?type let arg = readFile "a" {-for example-} in \f -> join (f <$> return arg <*> return arg <*> return arg)
15:39:50 <lambdabot> forall (m :: * -> *) a. (Monad m, Applicative m) => (IO String -> IO String -> IO String -> m a) -> m a
15:40:17 <newsham> ?type let arg = readFile "a" {-for example-} in \f -> join (f <$> arg <*> arg <*> arg)
15:40:18 <lambdabot> forall a. (String -> String -> String -> IO a) -> IO a
15:40:33 <Axman6> :t \f x y -> (join (f <$> return x <*> return y),f x y)
15:40:33 <newsham> the former is what i want, not the latter
15:40:34 <lambdabot> forall a a1 (m :: * -> *) a2. (Monad m, Applicative m) => (a -> a1 -> m a2) -> a -> a1 -> (m a2, m a2)
15:41:56 <Saizan> yeah, it seems "f arg arg arg" should be the same
15:42:50 <newsham> notice in one the args to the function are String and the other they are IO String
15:44:00 <Saizan> ?type \f arg -> f arg arg (arg :: IO String)
15:44:01 <lambdabot> forall t. (IO String -> IO String -> IO String -> t) -> IO String -> t
15:45:02 <newsham> oh. heh :)
15:46:53 <dibblego> @type join . join
15:46:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
15:49:09 <newsham> anyway, ejoin made my definitions simpler.  happy.
15:52:45 <dibblego> I feel bad for making 'type IOMaybe a = IO (Maybe a) but I don't want to haul in MaybeT, mtl, etc.
15:54:12 <geheimdienst> dibblego, same thing for me ... i must have implemented "split" like 5 times over, instead of making a dependency on whatever package it's in ...
15:54:49 <dibblego> I might just make my own monad
15:55:01 <ivanm> geheimdienst: split? :p
15:55:20 <newsham> hrmm. would it be in bad taste to use either  `infix`? :)
15:56:02 <newsham> ejoin ea = runErrorT ea >>= (writeBS . jsonerr . S.pack) `either` id
15:56:18 <newsham> i do like the leftness and rightness of it
15:56:19 <geheimdienst> ivanm: you know, split ':' "lol:ca:ts" -> ["lol", "ca", "ts"]
15:56:35 <ivanm> no, I meant the library it is in is called "split"
15:57:39 <sioraiocht> geheimdienst: nice example strin
15:57:40 <sioraiocht> g
15:58:08 <newsham> > split '.' "goatse.cz"
15:58:09 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
15:58:09 <lambdabot>         against inferr...
15:59:10 <ivanm> @type split
15:59:11 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
15:59:13 <ivanm> heh
16:09:22 <newsham> problem with writing dsomething is haskell, i spend more time playing golf with the code when its done than writing the code (i guess in fairness, I'm not spending much time debugging)
16:10:07 <kmc> the problem with Haskell's "correct up front" philosophy is that debugging is fun
16:10:12 <kmc> chasing down failed test cases is also fun
16:10:20 <pumpkin> depends what kind of debugging
16:10:20 <kmc> as is 'finishing' the buggy code quickly
16:10:36 <kmc> thinking hard, writing code that works the first time, then going on to the next problem
16:10:41 <pumpkin> if you have a subtle bug of someone overrunning their memory by a byte or two
16:10:42 <kmc> is in some ways not as gratifying
16:10:48 <pumpkin> causing subtly different behavior far away
16:10:54 <pumpkin> I'd consider that not particularly fun
16:11:20 <pumpkin> especially on a platform valgrind doesn't support or in a huge chunk of code you don't own (but have to deal with) that triggers thousands of other valgrind warnings :P
16:13:32 <dibblego> is it possible/practical to set up a local hackage-like server and tell cabal to use that source as well?
16:13:38 * fryguybob could live without complicated debugging...
16:16:31 <the_unmaker> hmm
16:16:44 <the_unmaker> woa I can speak again
16:17:27 <hiptobecubic> the_unmaker, shhhhhhh
16:36:16 <Axman6> @djinn Read a => String -> a
16:36:16 <lambdabot> Error: Undefined type String
16:36:26 <Axman6> bah
16:42:50 <donri> Axman6: [Char]
16:43:08 <Axman6> won't work, djinn doesn't know anything about recursive data structures
16:43:45 <copumpkin> what would you expect it to do there? :P
16:44:32 <Axman6> @djinn Num a => a -> a -> a
16:44:32 <lambdabot> Error: Class not found: Num
16:44:38 <MoALTz> http://paulgraham.com/accgen.html  couldn't the haskell implementation just be   foo n = (+) n   ???
16:45:01 <MoALTz> i might be missing something but the example given there seems over the top
16:45:43 <Vanadium> Note [...] (b) that's incremented by, not plus. 
16:46:33 <Vanadium> If you call the function that foo returns multiple times, you are supposed to get increasingly higher numbers
16:46:46 <Axman6> ah
16:47:02 <Axman6> so it needs state
16:47:16 <MoALTz> ah ok
16:47:50 <roconnor> Haskeller's users should fill out starting date of haskell experience so the years of experience can be then calculated and displayed
16:48:06 <kmc> MoALTz, it can't be, that wouldn't suffice to prove that Lisp is the most powerful language
16:48:26 <MoALTz> kmc: this was my suspicion about the page too :)
16:48:32 <kmc> this page is a fine demonstration that Lisp is the best language for writing Lisp code
16:48:49 <kmc> if you write Lisp in Haskell or Lua, it is not as pretty as writing Lisp in Lisp
16:48:51 <kmc> stop the presses
16:48:54 <Vanadium> ksf: with lua, javascript and perl being close runner-ups imo
16:49:12 <ksf> huh?
16:49:18 <Vanadium> Sorry :<
16:49:23 <Vanadium> Tab completion is not my friend recently.
16:49:27 <Vanadium> I meant kmc
16:49:58 <djahandarie> All my Haskell programs are just FFI calls to C functions
16:50:01 <ksf> I like doing meta-programming with Haskell, though.
16:50:32 <ksf> TH takes some getting used to, but then that's mostly due to abysmal ADT docs
16:50:34 <Vanadium> djahandarie: Well. Yeah. Is that not all haskell is at the end.
16:50:40 <Vanadium> A fancy way to figure out what the right FFI call to make is
16:51:13 <djahandarie> Vanadium, FSVO of FFI call probably yeah, but I wouldn't say so
16:53:20 <kmc> i think TH is good for certain things but I think we're missing a good text-macro system just a bit more powerful than CPP
16:53:23 <kmc> i blogged about this today
16:53:59 <Vanadium> Right
16:54:21 <Vanadium> Helm, set course to planet haskell~
17:11:01 <dibblego> is there a movement for category-extras in base?
17:11:38 <gwern> hahaha
17:11:41 <gwern> I mean
17:11:41 <gwern> no
17:11:47 <gwern> I haven't noticed any such movement
17:12:06 <djahandarie> There is movement in the negative direction
17:12:25 <geheimdienst> yeah, because there's not quite enough confusing, poorly documented abstract nonsense in base ...
17:12:27 <gwern> dibblego: I feel confident in predicting it will not join base within the next 2 years, as I predicted MaybeT would not (and was proven correct)
17:12:36 <ivanm> dibblego: edwardk is in the middle of re-writing and splitting category-extras up
17:12:49 <djahandarie> ivanm, he has been for awhile now, no?
17:12:53 <ivanm> yeah
17:13:00 <ivanm> but he's too busy :p
17:13:09 <ivanm> I think he's almost ready to split comonad out...
17:13:21 <Mathnerd314> does function composition form something similar to a monad?
17:13:26 <djahandarie> Yeah he hasn't been around here for awhile
17:13:32 <gwern> the problem is edwardk will eventually reach category nirvana, and then all his stuff will become unmaintained
17:13:39 <ivanm> gwern: heh
17:13:42 <ivanm> preflex: seen edwardk
17:13:43 <preflex>  edwardk was last seen on #haskell 6 days, 4 hours, 18 minutes and 10 seconds ago, saying: chrisdone: hah. i think that has happened to a lot of us at different points
17:13:54 <ivanm> djahandarie: ^^ he's been here within the past week ;-)
17:14:01 <ivanm> Mathnerd314: not a monad
17:14:08 <ivanm> but it does form a Functor
17:14:16 <ivanm> at least I don't think it forms a monad...
17:14:21 <gwern> I've heard it's something like the (->) monad or gooblegygook like that
17:14:45 <ivanm> @instances-importing Control.Monad.Instances Monad
17:14:46 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:14:49 <ivanm> huh, it does
17:14:58 <ivanm> oh, wait, right, yeah
17:15:03 * ivanm was getting it mixed up with something else
17:15:13 <djahandarie> And you can get a monad from any endofunctor anywho
17:15:24 <ivanm> @src ((->) r) (>>=)
17:15:24 <lambdabot> Source not found.
17:15:26 <ivanm> bah
17:17:19 <dibblego> Mathnerd314, function composition is fmap for the ((->) t) value
17:18:19 <gwern> auuggh there it is again
17:19:42 <copumpkin> @src (->) (>>=)
17:19:42 <lambdabot> f >>= k = \ r -> k (f r) r
17:33:38 <TeachmeHaskell> hello
17:33:53 <Lemmih> Hi.
17:34:18 <Lemmih> Let me guess... you want to learn Haskell, right?
17:34:26 <TeachmeHaskell> yes
17:34:46 <FauxFaux> You should learn you a haskell.
17:35:15 <TeachmeHaskell> i should what?
17:35:15 <TeachmeHaskell> lol
17:35:21 <gwern> for great code!
17:35:21 <Lemmih> ?where lyah
17:35:21 <lambdabot> http://www.learnyouahaskell.com/
17:35:28 * winxordie wonders how to enumerate Haskells.
17:35:29 <gwern> launch all browsers
17:35:32 <gwern> you know what you reading
17:35:34 <Lemmih> TeachmeHaskell: lyah is a most excellent Haskell tutorial.
17:35:45 <TeachmeHaskell> yeah im looking that website..
17:35:48 <TeachmeHaskell> thank you..
17:35:52 * gwern air-guitars with Lemmih. yeah dood!
17:37:06 <ivanm> Lemmih: do you still maintain hacannon-light?
17:37:43 <Lemmih> ivanm: I haven't looked at it for a long time. Do you have a bug report?
17:38:03 <geheimdienst> gwern, dude, it's 2010. we don't use air guitars anymore. we use little plastic ones that connect to our playstations
17:38:14 <gwern> :(
17:38:17 <ivanm> no, just considering writing some C++ bindings this (southern) summer, and apparently using hacannon-light + zeroth is the easiest way to go
17:38:22 <gwern> this future isn't so awesome
17:38:26 <ivanm> geheimdienst: or other consoles
17:38:28 <ivanm> gwern: agreed
17:38:29 <gwern> what happened to you guys. you used to be cool
17:38:38 <ivanm> gwern: I beg to differ: I was _never_ cool
17:38:40 <kmc> the future is in the future
17:39:21 <geheimdienst> http://netwrok.us/stuff/future-man-big.jpg
17:40:04 <ivanm> geheimdienst: unfortunately, that's so true...
17:40:13 <gwern> ivanm: your mom thinks you're cool
17:40:16 <gwern> cool with me and her
17:40:24 <ivanm> gwern: no she doesn't, and here it's spelt "mum"
17:40:27 <ivanm> silly yanks...
17:40:42 <geheimdienst> yo mama thinks yo cool
17:42:50 <gwern> ivanm: I follow the demands of custom
17:43:05 <gwern> custom dictates that it's 'your mom' and not 'your mum' or mumsie
17:43:16 <pickles> @hoogle a -> [a]
17:43:16 <lambdabot> Prelude repeat :: a -> [a]
17:43:16 <lambdabot> Data.List repeat :: a -> [a]
17:43:16 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
17:43:18 <geheimdienst> customers who enjoyed "future man, is everyone in your time retarded" also enjoyed verity stob on social media: http://www.theregister.co.uk/2009/08/24/verity_stob_twirping/
17:43:23 <gwern> I cannot change custom's mind! I AM ONLY ONE MAN
17:44:22 * pickles is an idiot
17:44:38 * pickles has been using Map.lookup when he could (should) have been using (!)
17:44:51 <Cale> pickles: Actually lookup is better.
17:45:18 <pickles> yeah, for error checkability w/ the Maybe
17:45:23 <Cale> pickles: Unless you don't mind your program failing altogether when the key isn't found, right.
17:45:32 <pickles> but i will have already checked for the keys being present
17:45:40 <ivanm> pickles: why would you check twice?
17:45:43 <pickles> so it was just a hassle to get the values out of the Just's
17:45:43 <dibblego> for functions that return Maybe, I usually also write one that composes with fromMaybe
17:45:45 <ivanm> lookukp does the checks for you
17:45:47 <pickles> error reporting
17:45:57 <pickles> it lead to nicer code separation
17:46:22 <pickles> yeah, otherwise i would be using lookup
17:46:56 <A1kmm> Has anyone seen an issue with cabal where if you use Data-Files, the symbols for Paths_modulename aren't linked in?
17:46:57 <ivanm> use lookup with fromMaybe for error reporting!
17:46:58 <Cale> pickles: Why not use lookup instead, and pass the extracted (non-maybe) value forward to the code that needs it in the non-error path?
17:47:15 <ivanm> A1kmm: you put Paths_* in OtherModules I believe
17:47:28 <ivanm> yeah, that's it
17:47:29 <A1kmm> ivanm: Ah... I'll try that.
17:47:34 <A1kmm> thanks
17:47:43 <pickles> Cale: it's all setup in a medium-ish where clause (cuz it seems clearer to me than a state monad would have)
17:48:09 <pickles> i can hpaste if you would like to look
17:48:24 <pickles> (i am open to code critiques)
17:48:40 <pickles> (mind you, there's a bunch of supporting stuff id leave out)
17:48:42 <ivanm> sure
17:49:53 <A1kmm> ivanm: It seems to have worked.
17:50:02 <ivanm> good-o
17:52:55 <pickles> http://hpaste.org/40426/refining_assembler_first_pass
17:53:16 <pickles> the crap in the bracket comment is being replaced by the few lines above it (it's still a work in progress)
17:53:26 <pickles> it's for an assembler
17:53:43 <pickles> ooOOoo, hpaste is giving tips now!
17:54:09 <gwern> pickles: how dare it! what does it think it is
17:54:10 <pickles> (btw, the lookup would have to occur in the getTableValue function)
17:54:16 <gwern> it's just a bunch of glorified numbers
17:54:20 <pickles> hehe
17:54:30 <Cale> pickles: Note Data.Map.difference
17:54:50 <ivanm> gwern: it's hlint I think
17:55:02 * gwern knows what it is ~-~
17:55:09 <Cale> err...
17:55:16 <Cale> sorry, misinterpreted this code
17:55:28 <pickles> np, not surprising since it's not all ther
17:57:32 <pickles> (brb)
17:57:34 <Cale> map fst . Map.toList is the same as Map.keys
17:57:49 <pickles> oo, thx
17:57:57 <pickles> (i'm still learning the libraries)
17:58:52 <djahandarie> So is supercompliation eventually going to be the new way to deforest stuff?
17:59:41 <dolio> It's got problems, like everything else.
18:00:01 <copumpkin> djahandarie: it's pretty expensive :)
18:00:32 <copumpkin> I expect we might pick low-hanging fruit off with rewrite rules and then run supercompilation on specific modules that need it
18:00:42 <dolio> Stream fusion can't deforest concatMap. ndm's supercompilation can't do foldl (I believe)...
18:01:52 <Cale> I have an old machine here whose motherboard led and fans come on when I switch the powersupply on, but nothing else happens, and in particular, the system doesn't go into the normal off state, and the front panel power switch does nothing.
18:02:43 <Cale> There's no video, and I'm not sure it's even getting as far as a POST.
18:03:08 <Cale> Hmm, maybe bad RAM...
18:03:14 <djahandarie> dolio, I'm pretty sure supercompliation in general can do all deforestations and more
18:03:27 <djahandarie> Not familiar with ndms
18:03:37 <gwern> if there isn't even video, I think you'd be better off scrapping it. I mean, a good new motherboard is like 50-100$. even if you got it working, you'll probably wind up wasting that much time on issues
18:05:30 <dolio> djahandarie: foldl, and any other tail recursive function will supercompile forever, just getting bigger, in most of the supercompiling I've seen.
18:05:48 <dolio> So it will get cut off eventually without making any actual improvement to the code in that regard.
18:06:01 <pickles> Cale: any other critiques?
18:06:23 <djahandarie> dolio, wouldn't a good one simply be able to detect that you just end up with a rename of your original function and change it to recurse? I don't see why it wouldn't work with foldl specifically
18:06:33 <dolio> Not that I have an encyclopedic knowledge of supercompiling.
18:07:01 <copumpkin> dolio: wouldn't it be possible to recognize "accumulators" and ignore them when looking up expressions you've already done?
18:07:06 <dolio> djahandarie: One step of specialization of foldl doesn't turn into a renaming of the original.
18:07:08 <Cale> pickles: I haven't drawn up a code graph for it, but could you perhaps split pass1 up into smaller parts? That's a rather long definition.
18:07:10 <copumpkin> at least with heuristics
18:07:19 <sclv> ndm has a good simple termination criteria, and max's does too
18:08:22 <dolio> foldl f z l ==> case l of [] -> z ; (x:xs) -> foldl f (f z x) xs ==> case l of [] -> z ; (x:xs) -> case xs of [] -> f z x ; (y:ys) -> foldl f (f (f z x) y) ys ==> ...
18:08:51 <djahandarie> Hm yes I see
18:08:58 <pickles> Cale: heh, if you think that's long you'd be horrified by my first version
18:09:13 <pickles> Cale: tis a good suggestion though, I'll have to look into it
18:09:32 <dolio> So you end up with 'foo [] = z ; foo [x] = f z x ; foo [x,y] = f (f z x) y ; ...' for however many times you split before cutting it off.
18:11:05 <Cale> pickles: If you're using more than a few ++'s, you might consider using concat instead
18:12:03 <dolio> That may not actually cause any lack of deforestation, but it's a problem to be solved.
18:12:32 <pickles> Cale: oo, good call (you thinking of the error section?)
18:12:50 <Cale> pickles: yeah
18:13:15 <pickles> Cale: yeah, that'll condense that nicely!
18:13:46 <dolio> copumpkin: And, maybe. You'd have to ask someone who's actually doing research whether that'd be likely to work.
18:18:09 <ddarius> Cale: Have you hooked a speaker to it?
18:29:44 --- mode: ChanServ set +o mauke
18:29:44 --- mode: mauke set -q *!*@gateway/web/freenode/ip.216.52.235.101
18:31:44 --- mode: mauke set -o mauke
18:34:16 <EvanR> i suddenly forgot how to get B from T A B
18:34:28 <pumpkin> ?
18:34:35 <pumpkin> as a type?
18:34:40 <EvanR> a value
18:34:46 <pumpkin> pattern match on it
18:34:49 <EvanR> (\T a b -> b) ?
18:34:58 <pumpkin> in parentheses
18:35:05 <EvanR> oh
18:35:06 <pumpkin>  \(T a b) -> b
18:35:17 <EvanR> can i do something like
18:35:23 <EvanR> let (T a b) = expr
18:35:30 <Eridius> I suddenly forget how to typejsf jawienfawengmaw
18:35:33 <pumpkin> EvanR: sure
18:35:36 <EvanR> ah nice
18:36:19 <EvanR> can its Maybe (T a b)
18:36:24 <EvanR> s/can/crap/ goes insane
18:36:32 <EvanR> i forgot haskell
18:37:00 <pumpkin> let Just (T a b) = expr
18:37:08 <pumpkin> but beware of Nothings ;)
18:37:18 <EvanR> yeah thats wont work
18:37:36 <EvanR> fromMaybe Nothing (\T a b -> b) expr
18:37:55 <ivanm> need parens
18:37:59 <pumpkin> that won't work, unless your B is also a Maybe
18:38:01 <ivanm> (\(T a b) -> b)
18:38:09 <ivanm> but you want maybe, not fromMaybe
18:38:15 <EvanR> oh right
18:38:44 <EvanR> maybe i should use Maybe >>= here
18:39:03 <Eridius> ack, Maybe just suddenly turned into one of those words that looks wrongly-spelled even though it's correct
18:40:22 <EvanR> expr >>= (\T a b -> Just b)
18:40:45 <EvanR> damn
18:40:52 <EvanR> expr >>= (\(T a b) -> Just b)
18:41:30 <pumpkin> no need to use >>= and then return
18:41:37 <pumpkin> just fmap :P
18:41:49 <pumpkin> or liftM if you insist
18:41:56 <EvanR> expr >>= liftM (\(T a b) -> b)
18:42:24 <pumpkin> no >>=
18:42:31 <EvanR> oh
18:42:35 <pumpkin> liftM (\(T a b) -> b) expr
18:44:15 <EvanR> whats clearer liftM or maybe
18:44:17 <EvanR> maybe Nothing
18:47:52 <pickles> wellp, I'm off (but then you knew that)
18:48:01 <pickles> thx for the tips/adivce Cale
18:48:10 <Cale> pickles: no problem
18:56:49 <lispy> ?tell gwern I don't run lambdabot, I just provide the vhost.
18:56:50 <lambdabot> Consider it noted.
19:12:11 <gwern> lispy: and if you host lambdabot then you are the one with access to its state files, ones which aren't years outdated like the oens in the darcs repo...
19:14:14 <EvanR> says in the manual that readMVar 'takes from the mvar, and puts it back', does it really do this or need to do this to read the mvar?
19:14:24 <EvanR> or is it just for conceptualization
19:15:11 <lispy> gwern: not really.  All that stuff is in Cale's account.  I wouldn't even know where to look.
19:15:30 <gwern> how many lambdabot repos could he possibly have?
19:15:41 <gwern> it would not be hard with a quick find...
19:15:52 <pumpkin> it's still iffy to go poking around in someone's account
19:16:06 <gwern> pumpkin: if lispy is the admin on the vhost, he has every right
19:16:06 <pumpkin> (a private one, anyway)
19:16:08 <monochrom> it really takes and puts. there is also much exception handling to make sure that interruption does not ruin the mvar
19:16:32 <geheimdienst> wasn't cale here just half an hour ago?
19:16:44 <EvanR> ruins?
19:17:21 <monochrom> yeah, if you plan to take and put, but after you take you are killed, disaster
19:17:36 <monochrom> but readMVar's code protects from that disaster.
19:18:01 <EvanR> it cant just give me the pointer to the value 
19:18:23 <EvanR> so to speak
19:18:48 <aavogt> EvanR: it's supposed to block when the mvar is empty
19:18:54 <EvanR> oh right
19:19:19 <EvanR> not as simple as i thought
19:19:33 <monochrom> there is "sample var" and there is tvar if you don't like this
19:20:03 <EvanR> its fine, i do need it to act just like this
19:20:26 <EvanR> could be empty because a non trivial operation is modifying the value
19:23:19 <Cale> wat
19:23:42 <lispy> lolwat?
19:24:09 <Cale> What's going on?
19:24:14 <Cale> Why are people looking for me?
19:24:24 <lispy> Cale: something about stale state files.
19:24:29 <Cale> oh?
19:24:32 <lispy> Cale: lambdabot updates
19:24:49 <Cale> I don't know what that refers to :)
19:24:54 <Cale> What state files?
19:25:11 <gwern> Cale: ಠ_ಠ
19:25:20 <Cale> ?
19:25:32 <pumpkin> son, gwern is disappoint
19:25:32 <gwern> hm. my look of disapproval seems to've been mangled
19:25:39 <Cale> not here
19:25:51 <Cale> ಥ_ಥ
19:26:27 <gwern> (no, guess it's my terminal font)
19:26:29 <Cale> http://www.google.com/insights/search/#cat=0&q=%E0%B2%A0_%E0%B2%A0&geo=&gprop=&cmpt=q&hl=en-US
19:27:53 <gwern> Cale: the request is simple. ssh in. cd to your lb repo. cp lambdabot's state files to state/. record the changes. push them
19:28:07 <Cale> push them where?
19:28:09 <gwern> do this every 3-6 months or 100,000 miles, whichever comes first
19:28:15 <gwern> Cale: to the master lb repo on c.h.o
19:28:19 <Cale> okay
19:28:32 <copumpkin> what about all the private @tells!
19:28:38 <copumpkin> there are already plenty in the repo
19:28:51 <copumpkin> private hookups and so on
19:28:51 <gwern> copumpkin: lambdabot is a whore for whomever runs it! privacy is an illusion!
19:28:56 <gwern> THERE IS ONLY XUL
19:29:03 <copumpkin> oh okay
19:30:19 <ivanm> XUL?
19:30:34 <pumpkin> firefox
19:30:36 <ivanm> what does mozilla have to do with it?
19:30:39 <Cale> conflicts, apply failed
19:30:44 <Cale> ./Plugin/Eval.hs
19:31:04 <Cale> Shall I go over there and try to fix them?
19:31:34 <gwern> yes
19:31:46 <ivanm> and fix up @hpaste whilst you're at it!
19:32:08 <Cale> ivanm: I fixed it in the code, but I can't build lambdabot on the server anymore.
19:32:17 <ivanm> oh, that's right
19:32:31 <ivanm> (excuses, excuses)
19:32:46 <gwern> fortunately my request has nothin to do with compiling lb
19:32:53 <gwern> nice thing about serializable state
19:33:08 <Cale> wait, what? there's supposed to be a conflict in that file, but I don't see it
19:33:28 <Saizan> if you ever make a cabal package again remove State/tell, pls.
19:34:43 <Cale> well, whatever, I guess I'll assume everything is okay, since there are no occurrences of "v v v"
19:36:08 <ivanm> the case of the missing conflict!
19:36:10 <gwern> the state, Cale! the state of amontillado!
20:52:20 <mm_freak> can i write a list of guards, for which, when all of them are False, the pattern is considered unmatched?
20:53:14 <glguy__> You mean you want:  f (Just x) | odd x = ... ; y = ... 
20:53:15 <glguy__> ?
20:53:22 <glguy__> (if so , you can)
20:53:31 <glguy__> f y = ...*
20:53:42 <dolio> > let f [] | False = "hello" | False = "yes" ; f [] = "seven" in f []
20:54:14 <glguy__> "seven"
20:57:00 <mm_freak> oh, i see
20:57:18 <copumpkin> conal: you mean ditch the IEEE stuff?
20:57:22 <mm_freak> > let f _ | False -> "foo"; f _ -> "bar" in f ()
20:57:46 <copumpkin> conal: or just the sorry state of the numeric typeclasses? 
20:57:50 <glguy__> if -> was =, I'd say "bar"
20:57:51 <mm_freak> s/->/=/
20:57:55 <mm_freak> and it works, thanks
20:58:30 <mm_freak> i thought if all guards fail, then the result is an exception
20:58:44 <conal> copumpkin: i mean don't settle for types like Int, Int32, Float, & Double that have arbitrary precision limits.
20:59:08 <copumpkin> conal: oh yeah, although I'd like to have them for low-level stuff, but I'd much prefer all the built-in stuff to be written in terms of Natural and Integer
20:59:09 <conal> but be able to program correctly, elegantly, and efficiently with *numbers*.
20:59:19 <copumpkin> (where they are arbitrary-precision gmp-backed types)
20:59:54 <treeduck> I was working through "Making Monads" of LYAH (http://bit.ly/9PRkMc) and at the bottom it says it would be simple to combine all the outcomes. I wrote http://ideone.com/ZIL50 (particularly the count function) -- surely there's a better way? 
21:00:47 <copumpkin> I was thinking you could make an "optimized" version of length :: [a] -> Nat(ural) that takes int-sized chunks of it and adds traditionally computed lengths to a Natural accumulator
21:01:04 <copumpkin> and same for a bunch of other stuf
21:01:18 <copumpkin> so the performance effects wouldn't be too noticeable for many existing functions
21:01:52 <conal> sure.  lots of possibilities for sound optimizations.  start with correctness and work in efficiency.
21:02:20 <conal> in contrast with the current approach of starting with machine-oriented types and maybe getting correctness.
21:02:24 <copumpkin> I'd love to measure the performance effect of switching to arbitrary precision by default
21:03:44 <conal> play-time at home.  catch you all later.
21:03:58 <copumpkin> ciao :)
21:08:21 <copumpkin> preflex: seen notabel
21:08:21 <preflex>  notabel was last seen on #haskell 9 days, 11 hours, 8 minutes and 35 seconds ago, saying: yeah, ghc7 is the upcoming release (because it has major new code landing)
21:43:35 <inbuninbu> i'm trying to understand some GHC implementation details by looking at the generated .hc files... however it's naturally difficult to read. does anyone have any suggestions, or a page i've missed somewhere which might make it easer?
21:43:47 <ivanm> .... don't?
21:43:48 <ivanm> :p
21:43:59 <ivanm> there is ghc-core if you really want to see the generated core
21:46:13 <inbuninbu> oh, thanks. that looks useful! though i'm focusing on STG at the moment
21:46:22 <inbuninbu> and how it's implemented
21:47:58 <ivanm> SPJ has various papers
21:48:09 <ivanm> they might be more usefaul than reverse engineering intermediate files
21:49:29 <Jafet> preflex: seen lambdabot
21:49:30 <preflex>  lambdabot was last seen on #haskell 2 hours, 52 minutes and 40 seconds ago, saying: Consider it noted.
21:50:43 <Jafet> Whistle a happy tune
21:50:44 <Cale> inbuninbu: Compiling via C is slipping into deprecation
21:50:47 <ivanm> for Alternative, why do both some and many define some_v and many_v as where terms rather than just being mutually recursive?
21:50:55 <inbuninbu> i've been looking at papers. maybe i've been biting off more than i can chew before i'm ready, but i still have big holes in my understanding
21:50:55 <ivanm> Cale: and hooray for that!
21:51:05 <ivanm> let's get rid of the perl dependency of GHC already!
21:51:20 <ivanm> inbuninbu: any particular reason you're doing this?
21:51:29 <inbuninbu> cale: i've also been looking at generated llvm
21:52:33 <inbuninbu> ivanm: well, primarily just curiousity
21:52:47 <Cale> inbuninbu: It depends on what your goals are. If you just want to understand things well enough to estimate what will perform well, it's actually possible to do pretty well just thinking of things in terms of rewriting expressions.
21:53:21 <inbuninbu> well, as a goal, i want to write an STG->LLVM compiler
21:53:41 <inbuninbu> it may not be useful, but that's the part i'm interested in at the moment
21:53:42 <Cale> Well, yeah, for that you obviously need more specific knowledge :)
21:56:06 <inbuninbu> for example, i know that the info table in a closure contains information about the type of closure (which should be obvious anyway)
21:56:58 <inbuninbu> but as for the format of the payload... what happens when you enter a value of data A = B | C, for example
21:57:44 <inbuninbu> i'm guessing there's no easy way to learn this other than read through heaps of source and ask specific questions on the mailing list, though
21:59:56 <Cale> inbuninbu: In my loose understanding of how it works, the first time, the code for the expression to evaluate it is run, and it returns the computed value right after it updates the thunk with a pointer to code that returns the computed value immediately.
22:00:12 <ivanm> with Alternative, is there actually any purpose to the Maybe and [] instances?
22:00:20 <ivanm> they seem to generate infinite values...
22:00:29 <ivanm> (unless you provide it with an [] or a Nothing)
22:00:56 <Cale> ivanm: huh?
22:01:04 <ivanm> > some [3]
22:01:08 <lambdabot>   mueval-core: Time limit exceeded
22:01:19 <ivanm> @type some
22:01:20 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
22:01:42 <Cale> > [1,2,3] <|> [4,5]
22:01:43 <lambdabot>   [1,2,3,4,5]
22:01:55 <Cale> > empty :: [Integer]
22:01:56 <lambdabot>   Ambiguous occurrence `empty'
22:01:56 <lambdabot>  It could refer to either `Control.Applicative...
22:02:03 <Cale> > Control.Applicative.empty :: [Integer]
22:02:04 <lambdabot>   []
22:02:12 <inbuninbu> Cale: that's my understanding as well. actually i think i may be approaching it wrong anyway. there's a list of evaluation rules in the push/apply paper that i probably need to focus on. it's quite difficult to follow though :-(
22:02:37 <ivanm> Cale: OK, it's just that some and many don't make sense for them?
22:03:10 <Cale> I'd never noticed that some and many even existed...
22:03:25 <ivanm> heh
22:03:29 <ivanm> @type many
22:03:30 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
22:03:36 <ivanm> I think they're there for parsing purposes
22:03:50 <ivanm> some = many1 in parsec, etc. IIUC
22:04:14 <ivanm> Cale: so the whole point of Alternative is to make a kind * -> * version of Monoid?
22:05:02 <ivanm> if so, why can't we just say: empty :: (Applicative f, Monoid (f a)) => f a; empty = mempty ?
22:05:07 <ivanm> and similarly for <|>
22:05:14 <Cale> I'd always just thought of it as MonadPlus for Applicatives.
22:05:15 <ivanm> rather than defining a whole new type class
22:05:35 <ivanm> well, the documentation says "A Monoid on Applicative Functors"
22:06:11 <ivanm> even for MonadPlus then: is there really any point in having another type class for that?
22:06:20 <Cale> yes
22:06:24 <Cale> Well, ideally :)
22:06:30 <ivanm> just to avoid saying "(MonoidPlus m, Monoid (m a)) => ... " ?
22:06:49 <copumpkin> MonoidPlus eh ;)
22:06:57 <ivanm> *MonadPlus
22:06:58 <Cale> MonadPlus sets expectations that the monoid in question interacts with the monad instance
22:06:58 <ivanm> whatever
22:06:59 <ivanm> ;-)
22:07:04 <ivanm> Cale: *nod*
22:07:05 <copumpkin> MonoidObjectInEndoFunctorCategoryPlus
22:07:10 <ivanm> so it's more an explicit type alias?
22:07:20 <Cale> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
22:07:32 <Cale> http://www.haskell.org/haskellwiki/MonadPlus
22:09:13 <dons> Cale: seen this? http://www.youtube.com/watch?v=FE5Rd_uIdqw#t=51s
22:09:47 <ivanm> what's the difference between MonadPlus and MonadElse in that proposal?
22:09:58 <ivanm> apart from how >>= works...
22:11:01 <dons> Cale: kinda weird. 
22:11:46 * ivanm wonders why dons is showing Cale ads...
22:13:04 <dons> um. you don't see it?
22:13:15 <Axman6> the last 10 seconds?
22:13:16 <bblum> hey, so i am learning how to use the state monad; i declared a type Context = (blah,(Int,Int)), and wrote and annotated some functions as type State Context whatever, and ghc told me:
22:13:22 <bblum> No instance for (MonadState (Int, b) ((,) a2))
22:13:45 <bblum> i am confused at why it twisted the types of my context around
22:13:58 <bblum> but it makes me think that declaring an instance MonadState is probably not the right thing to do
22:14:25 <ivanm> dons: just the fact that the logo is *> ?
22:14:31 <dons> ivanm: http://www.spreadshirt.com/there-is-no-cabal-C3376A3612542
22:14:53 <Axman6> heh
22:14:58 <dons> well, i guess it will be easier to get cabal tshirts now
22:14:58 <ivanm> oh
22:15:02 <ivanm> shmeh
22:15:26 <Cale> dons: heh, interesting
22:15:26 <Axman6> dons: do you get any cash from those shirts?
22:15:32 <dons> Axman6: no.
22:15:46 <Axman6> interesting
22:16:18 <Cale> My prescience gets the better of me sometimes.
22:16:20 <Axman6> seems you could make a pretty interesting business from that. people can upload designes, get a small amount of the profits, and the maker gets most of the money
22:16:40 <ivanm> Axman6: it does say down the bottom how much commision the designer gets
22:16:54 * Axman6 would be interested in the -funbox-strict-fields t-shirt
22:17:11 <ManateeLazyCat> "deriveVariable (conT ''Maybe `appT` conT ''Int)" is template for 'Maybe Int', how to build template for 'Maybe (Int,Int)'?
22:17:27 <ManateeLazyCat> (conT ''Maybe `appT` conT ''Int)  ==> Maybe Int
22:17:34 <newsham> is there a std definition for   f a = do { x <- a; when x (f a) } ?
22:17:42 <Axman6> dons: i also wouldn't mind seeing one with something like "Down with foldl, long live foldl'!"
22:18:05 <ddarius> ivanm: some and many don't make sense unless your Applicative can "propagate state" in someway, i.e. unless there is someway for the "same code" to return different values.
22:18:16 <Axman6> @undo f a = do { x <- a; when x (f a) }
22:18:16 <lambdabot> f a = a >>= \ x -> when x (f a)
22:18:38 <ManateeLazyCat> @hoogle TypeQ -> TypeQ -> TypeQ
22:18:38 <lambdabot> Language.Haskell.TH appT :: TypeQ -> TypeQ -> TypeQ
22:18:38 <lambdabot> Language.Haskell.TH.Lib appT :: TypeQ -> TypeQ -> TypeQ
22:18:38 <lambdabot> Language.Haskell.TH recover :: Q a -> Q a -> Q a
22:18:47 <ManateeLazyCat> @m
22:18:47 <lambdabot> Maybe you meant: map messages messages? more msg . ? @ v
22:18:53 <newsham> axman: not quite what i meant.
22:19:00 <newsham> something like "whileM_"
22:19:03 <ivanm> ddarius: *nod*
22:19:08 <Axman6> newsham: yeah, i was seeing if it had anything more useful
22:19:45 <Axman6> newsham: so run a until it's false basically?
22:20:04 <ManateeLazyCat> (conT ''Maybe `appT` conT ''(Int, Int)) looks not valid syntax, can't pass.
22:20:16 <newsham> yup.
22:23:37 <ManateeLazyCat> @hoogle Name -> Name -> TypeQ
22:23:38 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:23:38 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
22:23:38 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
22:28:02 <ManateeLazyCat> Any idea?
22:28:19 <ivanm> ddarius: so, is there any reason why we can't just have something like [ignoring if the syntax is valid or not] "class (Applicative f, Monoid (f a)) => Alternative f; empty :: (Alternative f) => f a, empty = mempty ..." ?
22:28:29 <ivanm> i.e. force through the Monoid definitions rather than re-defining them
22:29:07 <ddarius> ivanm: You may well want a different monoid instance than the one that corresponds to Alternative.
22:29:45 <ivanm> hmmm....
22:30:00 <ivanm> base only has a few Alternative instances so it's hard to find counter-examples
22:30:21 <ivanm> and hackage doesn't let you search for "which package creates instances of Foo?"
22:33:39 <ddarius> ivanm: I listed three Monoid "instances" for arbitrary monads the other day, none of which correspond to MonadPlus/Alterative and at least one of which is used in a special case that would conflict with an Alternative definition (if one were so made.)
22:33:57 <ivanm> did you? must have missed them
22:41:10 <ddarius> Maybe is also a good example.  It's an instance of Alternative, but also a monoid in three different ways and I'm pretty sure the instance chosen for the Maybe type itself does not correspond to the Alternative instance.
22:41:45 <ivanm> I think it does
22:42:16 <ivanm> Nothing <|> p = p; Just x <|> _ = Just x
22:42:36 <ddarius> :t mappend Nothing
22:42:36 <lambdabot> forall a. (Monoid a) => Maybe a -> Maybe a
22:42:42 <ddarius> Different instance.
22:42:46 <ivanm> ahh, no, Maybe uses the underlying type
22:42:47 <ivanm> yeah
22:42:57 <ivanm> OK, Alternative and Monoid are completely different
22:42:59 <ivanm> *sigh*
22:43:09 <ivanm> ddarius: what is the third way of doing Monoid for Maybe?
22:43:27 <ddarius> ivanm: The dual of the Alternative way.  Last = Dual . First
22:43:44 <ivanm> what do you mean?
22:43:50 <ddarius> :t First
22:43:51 <lambdabot> forall a. Maybe a -> First a
22:43:51 <ddarius> :t Last
22:43:52 <lambdabot> forall a. Maybe a -> Last a
22:43:56 <ddarius> :t Dual
22:43:57 <lambdabot> forall a. a -> Dual a
22:44:16 <ivanm> p `msum` Nothing = p, etc. ?
22:44:34 <ddarius> ivanm: Yes s/msum/mappend
22:44:43 <ivanm> whatever the name is ;-)
22:44:58 <ddarius> Admittedly they both have that equation but I think you are thinking of the right thing.
22:45:30 <ddarius> Incidentally, Dual instantly gives another Monoid instance that will almost surely conflict with the Alternative one.
22:46:05 <ivanm> hooray! :s
22:46:32 <ivanm> OK, so why do both some and many define some_v and many_v as where terms rather than just being mutually recursive?
22:47:09 <ddarius> At any rate, Alternative says that your applicative functor has a (semi)ring structure.  It does not make sense to say "and the additive structure shall be the -canonical- monoid on f."
22:47:32 <ddarius> @src some
22:47:32 <lambdabot> some v = some_v
22:47:32 <lambdabot>   where many_v = some_v <|> pure []
22:47:32 <lambdabot>         some_v = (:) <$> v <*> many_v
22:48:59 <ddarius> @src many
22:48:59 <lambdabot> Source not found. Wrong!  You cheating scum!
22:51:39 <ddarius> ivanm: It avoids recomputing some_v and many_v, but I don't really see that mattering much in the relevant instances, but I could be wrong about that.  It also, conveniently, will lead to <<loop>> errors (with no -threaded) when you think these are useful functions on your list.
22:52:01 <ivanm> heh
23:10:54 <JoeyA> Is there a library that wraps SQL statement objects (e.g. HDBC's Statement) in a type with 2 parameters, one representing the type of the parameters, one representing the type of the result rows?
23:11:27 <JoeyA> I should probably release my code that does this, as I'm liking how it's shaping up.
23:12:37 <JoeyA> It's a relatively simple module that adds a monadic interface for converting records to/from SqlValue lists.
23:12:57 <JoeyA> I recently discovered the Statement gem I just described.
23:15:40 <olsner> maybe you should look at HaskellDB, iirc it makes all database interactions type-safe (probably by generating types from the database schema)
23:16:16 <JoeyA> I've looked at it, but have been turned off by it for various reasons before actually seeing it in action.
23:17:04 <JoeyA> For instance, the haskelldb sqlite driver is outdated and doesn't even build (granted, it's a simple wrapper, and I was able to code up a replacement mostly by copy/pasting the one used for PostgreSQL).
23:17:21 <JoeyA> (I'm not referring to the SQLite generator inside of HaskellDB)
23:18:35 <JoeyA> Another reason I was turned off is my fear that it would reduce flexibility I need.  That may or may not be true.
23:20:03 <JoeyA> My module would be good for people who want to use HDBC, but want a little more type safety and want to work with big structures easily.
23:20:45 <JoeyA> rather than having to learn a combinator framework that may or may not be adequate.
23:21:12 <JoeyA> Again, I don't know if HaskellDB actually works well in practice, but I know HDBC does.
23:21:24 <JoeyA> (mainly because I haven't really used the former)
23:22:28 <jamy> @karma+
23:22:28 <lambdabot> usage @karma(+|-) nick
23:22:43 <jamy> @karma+ kmc
23:22:44 <lambdabot> kmc's karma raised to 6.
23:25:17 <nickela> JoeyA: did you see http://hackage.haskell.org/package/Takusen ?
23:26:05 <nickela> JoeyA: it is iteratee based database layer, pros over HaskellDB  is using less memory
23:26:41 <nickela> JoeyA:  here tutorial http://blog.codersbase.com/2010/08/takusen-tutorial-part-1-hello-takusen.html
23:30:04 <bblum> is there a nice way to use fmap on infix operators? like if a have two "f [a]"s, and i want to ++ them, is there a prettier way than to say "(++) <$> x <$> y"?
23:31:12 <cozachk> make a new function
23:31:25 <JoeyA> nickela: Cool, thanks.  I'll look into that some year.  Looks like a good way to learn about iteratees doing Something Real.
23:31:33 <bblum> it seems like the haskell philosophy to have such a function for list-concatenation already defined :P
23:32:37 <JoeyA> > liftM2 (++) [[1,2,3]] [[4,5,6]]
23:32:37 <lambdabot>   [[1,2,3,4,5,6]]
23:32:58 <ddarius> :t \x y -> (++) <$> x <$> y
23:32:59 <lambdabot> forall a a1 (f :: * -> *). (Monoid a, Functor f) => (a1 -> a) -> f a1 -> f (a -> a)
23:33:17 <JoeyA> :t \x y -> (++) <$> x <*> y
23:33:17 <lambdabot> forall a (f :: * -> *). (Monoid a, Applicative f) => f a -> f a -> f a
23:34:19 <bblum> JoeyA: ahh, liftM2
23:34:57 <bblum> there isn't really a good way to infix it though
23:36:32 <glguy_> and it would be:   f <$> x <*> y
23:36:36 <glguy_> rather than two <$>
23:36:43 <bblum> yeah, i caught that
23:36:57 <JoeyA> @let (<++>) = liftM2 (++)
23:36:58 <lambdabot>  Defined.
23:37:16 <JoeyA> > Just [1,2,3] <++> Just [4,5,6]
23:37:17 <lambdabot>   Just [1,2,3,4,5,6]
23:37:28 <JoeyA> > Just [1,2,3] <++> Nothing
23:37:29 <lambdabot>   Nothing
23:37:55 <JoeyA> you could also use liftA2
23:37:56 <nickela> > Left [1,2,3] <++> Right [4,5,6]
23:37:57 <lambdabot>   No instance for (Control.Monad.Error.Class.Error [t])
23:37:57 <lambdabot>    arising from a use...
23:38:29 <JoeyA> Either doesn't have Functor/Applicative instances that are easy to find.
23:39:39 <nickela> > [1] <++> [2]
23:39:40 <lambdabot>   Ambiguous type variable `t' in the constraints:
23:39:40 <lambdabot>    `Data.Monoid.Monoid t'
23:39:40 <lambdabot>  ...
23:40:29 <nickela> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1 <++> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=2
23:40:33 <nickela> > http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1 <++> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=2
23:40:35 <lambdabot>   <no location info>: parse error on input `='
23:40:46 <nickela> > [ [1] ] <++> [ [2] ]
23:40:47 <lambdabot>   [[1,2]]
23:40:47 * ddarius should use folding in vim more.
23:40:55 <nickela> yeahhh :)
23:41:05 <bblum> is there a way to ask lambdabot what package a thing is from?
23:41:23 <bblum> i don't know if it's because we just defined it, but lambdabot likes <++>, but hoogle won't find it for me
23:43:03 <ddarius> : read-pci CONFADD P@ RSVD_MASK and swap RSVD_MASK not and CONF_ENABLE or or CONFADD P! CONFDATA P@ ;
23:45:14 <JoeyA> We just defined it, but a similar construct has been used in other libraries, I'm sure.
23:45:35 <bblum> ok, i'll define it myself
23:46:07 <nickela> > [ [1],[2] ] <++> [ [3,4] ]
23:46:08 <lambdabot>   [[1,3,4],[2,3,4]]
23:46:20 <dirk_> good moring from germany, I am compiling on windows as well as linux on linux I need a hiding import on Windows I need a non hiding one, is there something like a preprocessor in c to switch it?
23:46:54 <ddarius> There are hacks that can be used to get infix expressions, but I haven't ever seen them used in real code.
23:46:58 <JoeyA> guess: -fvisibility-hidden
23:47:22 <ddarius> dirk_: Yes, you can use the C preprocessor.
23:48:32 <bblum> i mean, i know of `foo`, but i am under the impression that is only for singular tokens
23:48:46 <arw> dirk_: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.25.9165&rep=rep1&type=ps
23:49:37 <dirk_> ok , thanks a lot
23:50:05 <dirk_> my line on linux is "import Data.List hiding (isInfixOf)"
23:50:16 <dirk_> on windows it must be "import Data.List"
23:50:30 <dirk_> is there a simple line I can type to get that
23:51:27 <Zao> dirk_: Maybe you can use cpphs?
23:51:27 <Zao> http://www.haskell.org/cpphs/
23:52:00 <Zao> dirk_: Or maybe use a separate pair of modules that reexports suitable names, based on Cabal conditionals?
23:52:20 * ddarius thinks he should reconsider why he needs this to begin with.
23:53:06 <Zao> I didn't bother investigating his "must", assuming it's correct :)
23:53:18 <Zao> Evaluating the possible avenues might be fruitful anyway.
23:53:20 <arw> dirk_: #ifdef LINUX_HOST_OS ... #else ... #endif, compile with ghc -cpp.
23:53:38 <arw> dirk_: but preprocessor stuff must be multiline or it won't work.
23:53:47 <dirk_> thanks arw, that looks like it'll do
23:53:49 <arw> dirk_: so no single-line solution
23:54:17 <dirk_> thats no problem a few line are ok as well
23:55:44 <dirk_> works on linux
23:56:56 <arw> dirk_: you should also examine, whether the #ifdef is the right one. for example if bsd and solaris behaves like linux in your software or like windows. 
23:57:30 <ddarius> What he describes should not be different between Windows and Linux.
23:57:43 <ddarius> (or in fact, between those two and any other OS)
23:58:01 <arw> hm, yes
23:58:18 <Zao> ddarius: Obviously Linux is the only non-Windows platform in existence.
