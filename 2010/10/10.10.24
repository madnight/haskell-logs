00:05:46 <dolio> tolkad: http://hpaste.org/paste/40817/generalized#p40819
00:07:44 <tolkad> dolio: thanks! I can use that
00:08:13 <tolkad> it works
00:08:54 <ClaudiusMaximus> are there any nice combinators somewhere for building GTK user interfaces out of nested boxes?
00:09:30 <tolkad> dolio: I was trying to do that for an hour. I thought of using one existential but didn't think of using two
00:10:28 <ClaudiusMaximus> something like:  (foo `beside` bar) `above` (baz `beside` quux) -- etc
00:11:37 <tolkad> lol casting to IO yields "internal error: stg_ap_v_ret"
00:11:47 <tolkad> and tells me to report it as a GHC bug
00:12:05 <ClaudiusMaximus> better maybe something like:  vbox [ hbox [ foo, bar ], hbox [ baz, quux ] ] -- etc
00:12:06 <c_wraith> yeah, they'll reject it when you tell them unsafeCoerce was involved :P
00:14:09 <dolio> tolkad: It doesn't use two.
00:14:18 <dolio> It coerces from (exists t. t) to (forall t. t)
00:14:37 <dolio> The first is the union of all types, so to speak, so you can put a value of any type in.
00:14:48 <dolio> The latter is the intersection of all types, so you can get a value of any type out.
00:15:01 * ClaudiusMaximus pining for EasyGUI from AmigaE days..
00:15:01 <tolkad> dolio: I see two forall t. t in there
00:15:15 <tolkad> dolio: one is before the constructor and one after
00:15:26 <tolkad> dolio: I never really understood the difference between those
00:15:33 <dolio> Yes. Whether it comes before or after makes a difference.
00:15:59 <Saizan> ClaudiusMaximus: GuiTV has something like that iirc, not sure if it's implemented over gtk2hs or wxWidgets though
00:16:14 <dolio> If it were GADTs, it'd be "E :: forall t. t -> E" and "A :: (forall t. t) -> A".
00:16:43 <ClaudiusMaximus> Saizan: maybe (if i'm bored) i'll write an EasyGUI-alike combinator library...
00:17:05 <dolio> Also, of course it works. I did test it to make sure it didn't just segfault or something. :)
00:18:43 <tolkad> dolio: but it does segfault if I try to use it :P
00:18:50 <tolkad> dolio: or bus error
00:18:53 <dolio> Well, it depends what you use it for.
00:19:01 <tolkad> dolio: or fail with some GHC error
00:19:07 <dolio> I successfully coerced an Int to a Word with it.
00:19:26 <dolio> And got the expected answer.
00:19:39 <tolkad> I successfully coerced a String -> IO () to IO () and executed it and it worked
00:19:43 <Veinor> what happens if you coerce a function to a string? :O
00:20:17 <tolkad> Veinor: empty string first try
00:20:50 <tolkad> it's probably a pointer with first byte 0 or something
00:20:53 <tolkad> idk
00:35:38 <SubjectiveObject> Aaah, I finally understand applicative functors and monads
00:35:49 <SubjectiveObject> I feel like my brain was lifted and transported to a beach in Hawaii
00:36:19 <ddarius> Since code entry points are at (d)word aligned address and since the list type has only two constructors and thus utilizes pointer tagging and finally since [] is the first constructor, unsafeCoercing a function to a String will be interpreted as "".
00:37:12 <arcatan> SubjectiveObject: now you can go and write an applicative functor tutorial and a monad tutorial!
00:42:25 <SubjectiveObject> arcatan: I don't think a noob can top Learn you a haskell =)
00:47:36 <razvandimescu> what's the character to add comments in haskell source code?
00:47:57 <SubStack> -- and {- -}
00:48:56 <razvandimescu> SubStack: thanks
01:02:50 <misterdc> Hello, looking for some last minute AS3 help.  Anyone here?
01:03:28 <misterdc> Anyone?
01:03:33 <Veinor> why are you asking for actionscript help in #haskell?
01:03:42 <ClaudiusMaximus> > "AS3" == "Haskell"
01:03:42 <hsbot>   False
01:03:50 <misterdc> Because I apparently can't find the right room!  Sorry.  
01:04:05 <Veinor> 's fine :P
01:04:23 <ClaudiusMaximus> well, i got some nice combinator action for simple buttons: http://hpaste.org/40820/gtk_combinators
01:05:09 <razvandimescu> can I refactor this?
01:05:09 <razvandimescu> matrixMultiplier mx factor= [map (*factor)xs|xs<-mx]
01:07:31 <ClaudiusMaximus> list comprehensions are sugar for things like map and filter
01:08:35 <ClaudiusMaximus> > let m ^^* f = map (map (*f)) m in [[1,0,0],[0,1,0],[0,0,1]] ^^* 37
01:08:36 <hsbot>   [[37,0,0],[0,37,0],[0,0,37]]
01:08:50 <Veinor> razvandimescu: I'm pretty sure that amounts to matrixMultiplier = map (map (*factor))
01:09:01 <Saizan> ?type \mx factor -> [map (*factor)xs|xs<-mx]
01:09:12 <Veinor> which you can rewrite as  matrixMultiplier = map . map $ (*factor)
01:09:34 <Saizan> Veinor: out of scope: factor
01:09:46 <Veinor> oh, derp
01:09:55 <Veinor> matrixMultiplier factor = map . map $ (*factor)
01:10:07 <Veinor> @pl \x -> map . map $ ( * x)
01:10:22 <Veinor> oh no!
01:14:00 <Guest86956> Hello, I got a question. I can ask it here right?
01:14:13 <Saizan> Guest86956: yes, if it's about Haskell
01:14:17 <Guest86956> yeah =)
01:14:28 <Veinor> what happened to \bot?
01:14:55 <Saizan> went down for some reason and cale is not around to restart it
01:14:58 <Veinor> aw
01:15:06 <Guest86956> The last time I got here I have been trying to make a breadth first search algorithm, now I see in my hints assignment that he says something about record syntax. But that hasn't been explained in the course.
01:15:11 <Guest86956> Can someone enlighten me about it?
01:16:19 <Guest86956> it looks somewhat likes this: data Traced a = Traced {current :: a, trace :: [a] }
01:16:33 <Veinor> right
01:16:45 <Veinor> so that creates a function current :: Traced a -> a
01:16:49 <Veinor> and trace :: Traced a -> [a]
01:17:12 <Guest86956> hmm... but what do "{" these things do?
01:17:25 <Veinor> they're just to delimit the 'fields' of the record
01:17:47 <Guest86956> okay and what does :: mean?
01:17:56 <Veinor> :: means 'has the type'
01:18:00 <Guest86956> (sorry I am not quite an experienced haskell User
01:18:01 <Guest86956> oh yeah
01:18:11 <Guest86956> it is the same as in a function right?
01:18:19 <Veinor> so, current :: a means 'there's a field that has the type a, and you can get at it using the current function'
01:18:35 <Guest86956> yeah exactly what I use to define functions I see...
01:18:53 <Saizan> you can also use the field names to construct or update a value
01:19:18 <Saizan> e.g. Traced { current = 1, trace = [] }
01:19:21 <Guest86956> can you please give an example? (I am not quite sure if I understand that
01:19:28 <Guest86956> let
01:19:30 <Guest86956> s see
01:20:50 <Guest86956> okay so this Traced { current = 5, [1, 2, 3, 4] } can mean, I have gone to 1, 2, 3, 4, to get to position 5?
01:21:16 <Saizan> 2Traced { current = 5, trace = [1, 2, 3, 4] }
01:21:18 <Guest86956> I wonder why it does not use a tuple but use "{" these things? When can I use "{"?
01:21:53 <Saizan> you could also have defined "data Traced a = Traced a [a]"
01:22:32 <Guest86956> I see... but when do I use "{"?
01:22:49 <Saizan> when you want to give a name to the fields
01:23:35 <Guest86956> so if I want to give name to that "a" in that field I need to use {?
01:26:05 <Saizan> how else would you do it?
01:26:19 <Guest86956> I never actually seen a usage of "{"...
01:27:17 <razvandimescu> figured it out   [map (*m)xs|xs<-mx] is equivalent with map (map (*m)) mx
01:28:56 <Peaker> razvandimescu, (map . map) (*m) mx
01:33:54 <razvandimescu> So all these are equivalent, cool!: matrixMultiplier mx m= [map (*m)xs|xs<-mx]
01:33:54 <razvandimescu> matrixMultiplier factor = map (map (*factor))
01:33:54 <razvandimescu> matrixMultiplier factor = (map . map) (*factor) 
01:43:06 <opqdonut> razvandimescu: or: fmap fmap fmap (*factor)
01:50:41 <Peaker> @where SEC
01:51:16 <Peaker> razvandimescu, http://conal.net/blog/posts/semantic-editor-combinators/  explains the generalized (map . map) idea
01:52:03 <razvandimescu> Peaker: thanks!
02:00:51 <razvandimescu> it the map function really defined like this?
02:00:52 <razvandimescu> map :: (a -> b) -> [a] -> [b]  map _ [] = []  map f (x:xs) = f x : map f xs  
02:01:10 * hackagebot authenticate 0.7.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.7.2 (MichaelSnoyman)
02:01:17 <razvandimescu> because that would mean that *2 4
02:01:27 <razvandimescu> should work, but it doesn't
02:01:44 <Lemmih> > map (*2) [4]
02:01:45 <hsbot>   [8]
02:02:14 <ClaudiusMaximus> > (*2) 4
02:02:15 <hsbot>   8
02:02:31 <razvandimescu> ClaudiusMaximus: ;) right
02:04:13 <ClaudiusMaximus> there's some magic in GHC to make map more efficient: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/GHC-Base.html#map
02:09:52 <Axman6> @djinn (elt -> lst -> lst) -> (a -> elt) -> a -> lst -> lst
02:10:12 <tolkad> what's the difference between transfomers and mtl? which one is better?
02:12:13 <Baughn> tolkad: transformers is newer, and generally considered to be better. They do about the same thing, but transformers does it less inconveniently.
02:12:55 <Baughn> tolkad: transformers also introduces a dependency on newer versions of GHC, but that's rarely a problem.
02:12:59 <ClaudiusMaximus> is there a transformers <=> mtl compatibility layer?
02:13:08 <Baughn> Not that I know of
02:13:33 <harlekin> How can I tell the terminal not to echo everything I type back using Haskell?
02:13:38 <tolkad> the error monad is annoying
02:13:43 <ClaudiusMaximus> gtk2hs uses mtl, so i have to depend on mtl purely for liftIO
02:13:49 <tolkad> why is it only for string types?
02:14:02 <tolkad> the mtl error monad doesn't require a string type
02:14:20 <ddarius> ClaudiusMaximus: Under normal circumstances they can't even be compiled in the same program.  At any rate, transformers (+ monads-fd or monads-tf) is intended to be a mostly drop-in replacement for mtl.
02:14:34 <Baughn> tolkad: Best I can tell you is you're not the only one annoyed
02:14:50 <tolkad> if I want computations that might fail with more than a "Nothing" I need to use a string?
02:15:02 <Baughn> Well, or reimplement Error.
02:15:11 <Baughn> Or use mtl.
02:15:20 <Axman6> someone had the idea of reqriting both met and transformers so one depends on the other, so everything is consistent
02:16:50 <tolkad> building any type compatibility between the libraries would be a really bad idea
02:17:04 <Baughn> Why?
02:17:20 <tolkad> unless it was done in a third package
02:17:45 <tolkad> it would make it much harder to deprecate one
02:18:35 <Axman6> the point is not to depreciate one, from what i know, they both implement a lot of the same stuff, so if one of them got rid of the stuff that was defined in the other, depended on it, and then added to it, that would be good no?
02:18:48 <Baughn> Just so long as Error gets fixed first
02:19:46 <tolkad> continuation monad sounds cool
02:19:55 <tolkad> I could obfuscate my code using it
02:20:19 * hackagebot wai 0.2.2 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.2.2 (MichaelSnoyman)
02:20:22 <ddarius> > fromLeft (do Nothing <- return (Just ()); return ())
02:20:24 <hsbot>   Not in scope: `fromLeft'
02:20:31 <tolkad> and make the order of function application impossible to understand
02:20:33 <ddarius> > either id id (do Nothing <- return (Just ()); return ())
02:20:34 <hsbot>   No instance for (Control.Monad.Trans.Error.Error ()) arising from a use of `GHC.Base.return' at <interactive>:1:28-43 Possible fix: add an instance declaration for (Control.Monad.Trans.Error.Erro...
02:20:59 <ddarius> > either id undefined (do Nothing <- return (Just ()); return ())
02:21:00 <hsbot>   Ambiguous type variable `a' in the constraints: `GHC.Show.Show a' arising from a use of `M309821816.show_M309821816' at <interactive>:(2,0)-(4,30) `Control.Monad.Trans.Error.Error a' arising from...
02:21:16 <ddarius> > either id undefined (do Nothing <- return (Just ()); return ()) :: String
02:21:16 <hsbot>   "Pattern match failure in do expression at <interactive>:3:24-30"
02:23:05 <ClaudiusMaximus> so i have strings like "-1.157121625891250000000000000000000000000000000000e-02" and i want to turn them into strings like "-0.015712162589125" - it's going to be a bit messy i think
02:23:40 <tolkad> > data T = T
02:23:40 <hsbot>   <no location info>: parse error on input `data'
02:23:51 <tolkad> is there any way to define data types in this bot?
02:23:52 <ClaudiusMaximus> > 0x7800 - 8
02:23:53 <hsbot>   30712
02:24:09 <tolkad> > 9 ^ 9 ^ 9
02:24:30 <hsbot>   *Exc
02:24:38 <harlekin> Is there a way to parse a string with parsec and when it succeeds return the remainder of the string which hasn't been parsed?
02:25:06 <harlekin> like parse anyChar "" "Hello" -> ('H', "ello")
02:27:58 <Saizan> parse (liftM2 (,) anyChar getInput) "" "Hello"
02:29:24 <harlekin> Saizan, that should do. Thanks. (:
02:30:35 <ddarius> ClaudiusMaximus: Will they all be in the range of a Double?
02:30:48 <ClaudiusMaximus> ddarius: yes, but with more precision
02:31:18 <ClaudiusMaximus> ddarius: so using read/show via double will lose information
02:31:24 * hackagebot DTC 1.1.0 - Data To Class transformation.  http://hackage.haskell.org/package/DTC-1.1.0 (DanielDiaz)
02:32:01 <ClaudiusMaximus> ddarius: it's an issue with the foreign code that i'm using - it seems to like scientific notation more than is healthy
02:41:53 <nkpart> anyone know what happened to lambdabot?
02:47:38 <Jafet> She's just resting.
02:49:01 <nkpart> :)
02:56:36 <Saizan> @bot
02:56:39 <lambdabot> :)
02:58:03 <Saizan> i've started her from my machine as a temporary replacement :)
03:00:08 <SchattenMeister> http://www.drogendealer.de/cgi-bin/dd.cgi?RXXb5pZa     Please clicks for me thx you
03:00:32 <tsbo> Does anyone know why I'd get a linker error for "duplicate definition for symbol _get_current_timezone_seconds" with ghci -package time?
03:02:25 <Saizan> tsbo: does it happen if you specify the version too?
03:02:46 --- mode: ChanServ set +o Saizan
03:02:59 <tsbo> Saizan: Nope. ghci -package time-1.2.0.3 loads fine.
03:03:03 --- mode: Saizan set +b *!*Bubby@*.dip.t-dialin.net
03:03:04 --- kick: SchattenMeister was kicked by Saizan (no spam please)
03:03:16 --- mode: Saizan set -o Saizan
03:03:40 <Axman6> @djinn (elt -> lst -> lst) -> (a -> elt) -> a -> lst -> lst
03:03:40 <lambdabot> f a b c = a (b c)
03:04:32 <Saizan> tsbo: i think you've two versions of time installed, "ghci -package time" tries to link both at the same time
03:04:50 <Saizan> tsbo: i think it's a bug
03:05:14 <Saizan> -package time should default to link just one or the other
03:05:43 <tsbo> Saizan: yeah. I used ghc-pkg hide to remove the old one, but it still failed so I though that must not be it.
03:05:48 <tsbo> "remove"
03:08:05 <tsbo> ghc-pkg unregister time-1.1.4 has fixed it. Thanks.
03:08:13 <Saizan> np
03:11:09 <monadic_kid> has anyone tried using those java bridge libraries on android?
03:17:43 <McManiaC> did anyone get network-fancy to build on windows? I get this: http://npaste.de/ne/
03:18:09 <tsbo> Has the prob w/ cabal requiring a dependancy even if the exec is not buildable been fixed?
03:28:52 * hackagebot cryptohash 0.6 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.6 (VincentHanquez)
03:32:06 <ClaudiusMaximus> so i have a type like:   data A = B String | C [A] | D [A]  and i want to generate arbitrary/random values that are sufficiently not enormous - any ideas?
03:33:14 <ClaudiusMaximus> i suppose i should define a metric :)
03:33:26 <aristid> ClaudiusMaximus: you need to find a distribution :)
03:34:23 <ClaudiusMaximus> i don't care about any statistical properties, i just don't want to crash my computer by trying to get GTK to display a 1M button GUI
03:35:28 <aristid> well, that IS a statistical property
03:38:54 * hackagebot network-info 0.2 - Access the local computer's basic network configuration  http://hackage.haskell.org/package/network-info-0.2 (JacobStanley)
03:54:19 <ClaudiusMaximus> aristid: well, i got it working :P   http://claudiusmaximus.goto10.org/g/misc/MuGtkRnd.png
03:58:24 <aristid> ClaudiusMaximus: oh, what kind of data would that be?
03:58:58 <ClaudiusMaximus> aristid: http://hpaste.org/paste/40820/random_gui_generator#p40822
04:00:03 <aristid> ClaudiusMaximus: it's for testing layout algorithms?
04:00:30 <ClaudiusMaximus> aristid: i was a bit bored..
04:02:39 <pastorn> ClaudiusMaximus: i looked at the code you put online
04:02:48 <pastorn> then my brain exploded a little
04:03:15 <pastorn> ClaudiusMaximus: if you'd put some comments in there it would be *awesome* ;)
04:03:48 <pastorn> I didn't really understand all the parts with the DoubleDoubleDoubleDouble-things
04:03:49 <aristid> pastorn: huh? the code that ClaudiusMaximus just linked is pretty easy to read IMO
04:03:58 <pastorn> aristid: this is something else
04:04:18 <aristid> pastorn: which is the one you refer to?
04:04:26 <ClaudiusMaximus> pastorn: yeah i have bad habits about not commenting much :(
04:05:32 <aristid> ClaudiusMaximus: why the "_ <-"? in _ <- b `on` buttonActivated $ act
04:06:01 * hackagebot iteratee-compress 0.1.1 - An enumerators for compressing and decompressing streams  http://hackage.haskell.org/package/iteratee-compress-0.1.1 (MaciejPiechotka)
04:06:25 <ClaudiusMaximus> aristid: on :: object -> Signal object callback -> callback -> IO (ConnectId object)
04:07:03 <ClaudiusMaximus> aristid: and GHC started warning about ignored results
04:07:12 <aristid> ClaudiusMaximus: oh, GHC warns about that? ok
04:08:00 <ClaudiusMaximus> aristid: yes...
04:08:01 <ClaudiusMaximus>     Warning: A do-notation statement discarded a result of type ConnectId
04:08:01 <ClaudiusMaximus>                                                                   Button.
04:08:01 <ClaudiusMaximus>              Suppress this warning by saying "_ <- ($)
04:08:06 <ClaudiusMaximus> etc
04:09:13 <aristid> ClaudiusMaximus: that's annoying
04:09:29 <ClaudiusMaximus> aristid: there is at least a flag that disables that particular warning...
04:09:29 <tsbo> How do I tell GHC which package to use when I get "Ambiguous interface for `Control.Monad.Trans'"? -package monads-tf doesn't seem to help...
04:10:16 <ClaudiusMaximus> tsbo: best way is probably to learn cabal, you'll probably going to want to use it eventually anyway
04:10:47 <benmachine> tsbo: try -hide-package mtl -hide-package monads-fd
04:10:48 <tsbo> ClaudiusMaximus: I'm just trying to get liftIO to play with some stuff in ghci ATM.
04:10:55 <aristid> tsbo: -hide-package mtl
04:11:12 <ClaudiusMaximus> tsbo: ah, then ignore me :)
04:12:10 <tsbo> Thanks all, -hide-package is what I was missing.
04:13:23 <benmachine> preflex: seen chrisdone
04:13:24 <preflex>  chrisdone was last seen on #haskell 4 days, 23 hours, 52 minutes and 46 seconds ago, saying: ah, n/m. I can patch it
04:16:40 <tab> actually which monad library should be used nowadays: monads-fd or monads-tf ?
04:17:16 <tab> i just "upgraded" from mtl to monads-fd, but the suggestion above seems to suggest -tf is the one to use ?
04:17:21 <benmachine> @tell chrisdone the HTML for annotations on hpaste has tags for line numbers with the same id attribute as in the main paste - this means that e.g. the HLint hints link to the wrong place
04:17:22 <lambdabot> Consider it noted.
04:17:49 <benmachine> tab: they do the same thing but in different ways, and it's up to you which you choose
04:18:17 <benmachine> tab: I prefer monads-tf because type families seem more natural to me than functional dependencies, but you might decide otherwise
04:18:29 <aristid> tab: i use monadLib
04:18:41 <tab> ETOOMANYCHOICE :)
04:19:19 <aristid> tab: if you want one of the more popular ones i'd go with monads-fd, because type families suck!
04:19:36 <tab> personally i don't really care :)
04:19:54 <tab> i'ld like to see a common option though
04:20:31 <tab> aristid: why monadLib and not monads-fd then ?
04:20:50 <aristid> tab: to avoid the whole "conflicting packages" mess, and because monadLib seems well-designed
04:21:43 <tab> right ok
04:22:05 <benmachine> monadLib has silly module names though
04:22:09 <benmachine> and that's the important thing
04:22:40 <pastorn> ClaudiusMaximus: but it would be really nice if you annotated your code a bit, mostly the technical details
04:23:00 <pastorn> ClaudiusMaximus: see it as flattiring yourself: "-- now this is where i am smarter than you:"
04:23:37 <aristid> benmachine: they're not silly
04:23:49 <aristid> import MonadLib <- important typing resources saved
04:24:34 <tab> oh noes, i started a monad library war :P
04:26:06 <Watermind> I'm trying to remember how ~ patterns work...
04:26:24 <ski> @botsnack
04:26:25 <lambdabot> :)
04:26:26 <Watermind> I know it's supposed to be the opposite of ! somehow
04:26:55 <Watermind> and provide a lazyness annotation, but not sure how it works
04:26:58 <Sina> Hi Everyone :)
04:27:01 <Watermind> where is the documentation for that?
04:27:04 <Watermind> I can only find !
04:27:14 <ski> when matching a value against a pattern `~<pat>', the match succeeds immediately, but any forcing of a variable bound by the pattern will match the value with `<pat>'
04:27:20 <ski> Watermind : ^
04:27:44 <ski> > case True of ~False -> ()
04:27:45 <hsbot>   ()
04:27:48 <lambdabot>   ()
04:27:52 <ClaudiusMaximus> pastorn: which code in particular are you referring to>
04:28:11 <ski> > case Nothing of ~(Just x) -> x :: Int
04:28:11 <hsbot>   *Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed for pattern (Data.Maybe.Just x)
04:28:12 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed for patt...
04:28:17 <ski> > case Nothing of ~(Just x) -> ()
04:28:18 <hsbot>   ()
04:28:18 <lambdabot>   ()
04:28:31 <Watermind> ski: I see, so it would only fail if you need to use the x in that case
04:28:37 <ski> right
04:28:45 <Watermind> is this H98?
04:28:48 <ski> yes
04:28:51 <ski> (but `!' is not)
04:28:53 <Watermind> or some quasi-standard GHC notation
04:28:56 <Watermind> ohh
04:29:01 <Watermind> I thought it was the other way around
04:29:12 <ski> no, `!' is a more recent addition
04:29:16 <Watermind> got it
04:29:47 <benmachine> foo !x just means foo | x `seq` False = undefined anyway
04:29:50 <ski> sometimes `~' is needed, when tying recursive knots, even though you're going to always force the pattern anyway
04:30:12 <nlogax> ah, lambdabot is back :)
04:30:40 <ski> nlogax : hsbot was yours ?
04:30:51 <nlogax> ski: yes
04:30:53 <ski> preflex: xseen Cale
04:30:54 <preflex>  Cale was last seen on freenode/#haskell 3 days, 15 hours, 4 minutes and 35 seconds ago, saying: Applying the function 4 to the value 5
04:31:05 <ski> (Cale appears not back, though)
04:31:15 <nlogax> my nooby bot with mueval inside
04:31:26 <Watermind> ski: I did not follow now, is there a simple example of such a case?
04:31:27 <tab> nlogax: it's not the true lambdabot though
04:31:37 <nlogax> tab: oh
04:31:48 <benmachine> it's an evil clone?
04:32:12 <benmachine> hmm, is it likely to hang around long enough for my @tell to get through I wonder
04:32:15 <ski> > (fix $ \fact n -> if n == 0 then 1 else n * fact (n - 1)) 5
04:32:16 <lambdabot>   120
04:32:27 <ski> Watermind : can you read that ^ example ?
04:33:13 <tab> benmachine: it's running from saizan's machine
04:33:19 <aristid> lambdabot is back?!
04:33:27 <Saizan> maybe i should have changed the nick.
04:33:39 <benmachine> preflex: tell chrisdone I sent you a message via lambdabot; poke me if she died again before you got it
04:33:40 <preflex>  Consider it noted.
04:33:47 <Watermind> > :t fix
04:33:49 <lambdabot>   <no location info>: parse error on input `:'
04:33:49 <benmachine> sorted
04:33:53 <Watermind> :S
04:33:54 <ski> @type fix
04:33:56 <lambdabot> forall a. (a -> a) -> a
04:33:56 <Watermind> oh
04:34:06 <benmachine> it... would have made more sense to just include the message there
04:34:08 <benmachine> but whatever
04:34:37 <benmachine> preflex: tell benmachine to think ahead more
04:34:38 <preflex>  what
04:34:42 <ski> > fix (0 :)
04:34:43 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
04:35:09 <ski> > fix $ \xs -> 1 : map (2 *) xs
04:35:11 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
04:35:23 <ddarius> benmachine: Don't worry.  He'll get that message.  Leave a message with this lambdabot for you.  The real lambdabot will return and his request will be lost.
04:35:43 <Watermind> ski: oh yes easy, I was parsing the parenthesis wrong
04:35:56 <Watermind> ski: seemed fix $ ...  5
04:36:17 <Watermind> ski: sure yes I understand fixed points
04:36:25 <ski> Watermind : ok, now consider that you want mutual recursion
04:36:38 <Watermind> ski: ok
04:37:27 <Twey> :t fix
04:37:28 <lambdabot> forall a. (a -> a) -> a
04:37:40 <ski> > fst (fix $ \(even,odd) -> (\n -> if n == 0 then True else odd (n-1),\n -> if n == 0 then False else even (n-1))) 5
04:37:44 <lambdabot>   mueval-core: Time limit exceeded
04:37:46 <Twey> 12:31:50 < ski> > (fix $ \fact n -> if n == 0 then 1 else n * fact (n - 1)) 5
04:37:51 <Twey> *I* don't get this one.
04:38:04 <Twey> Oh wait
04:38:13 <Twey> The result type is a -> a, then you pass it an a
04:38:15 <Twey> Got it.
04:38:25 <ski> Watermind : note that that `even',`odd' didn't work, as expected .. this is because the `(even,odd)' pattern there is too strict, too early
04:38:29 <ski> now compare with
04:38:33 <ski> > fst (fix $ \ ~(even,odd) -> (\n -> if n == 0 then True else odd (n-1),\n -> if n == 0 then False else even (n-1))) 5
04:38:35 <lambdabot>   False
04:39:34 <ski> you see, with `\(even,odd) -> (...,...)', that function will insist on matching on the input pair, before relinguishing the output pair (that, via `fix', is to *be* the input pair)
04:39:36 <benmachine> > partitionEithers $ zipWith id (cycle [Left, Right]) [1 ..]
04:39:39 <lambdabot>   *Exception: stack overflow
04:39:40 <Watermind> right!
04:39:50 <Watermind> got it thanks ski!
04:40:08 <ski> but with `\ ~(even,odd) -> (...,...)', the function will release the result pair, before matching on the input
04:40:26 <Watermind> yeap
04:40:37 <ski> now, this is probably not that practical example, but the same kind of situation can arise in other circumstances
04:41:18 <benmachine> partitionEithers doesn't work on infinite lists because it doesn't use ~
04:41:35 <Watermind> right I get the general idea
04:41:43 <ski> @src partitionEithers
04:41:43 <lambdabot> Source not found. Wrong!  You cheating scum!
04:42:02 <ski> Watermind : yeah, what benmachine said, as well
04:45:00 <ski> > snd . fix $ \(a,b) -> (map succ b,0:)
04:45:02 <lambdabot>   A section must be enclosed in parentheses thus: (0 :)
04:45:10 <ski> > snd . fix $ \(a,b) -> (map succ b,0:a)
04:45:14 <lambdabot>   mueval-core: Time limit exceeded
04:45:16 <ski> > snd . fix $ \ ~(a,b) -> (map succ b,0:a)
04:45:18 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
04:45:26 <pastorn> ClaudiusMaximus: the fractal thingy
04:45:27 <ski> that's yet another example (somewhat simpler)
04:45:30 <Watermind> ski: benmachine: yes thanks I'm reading the source
04:45:35 <benmachine> ~ can be translated into let-binds, which are always irrefutable
04:45:35 <pastorn> where you used DoubleDoubleDoubleDouble
04:45:43 <Watermind> for partitionEithers
04:45:53 <benmachine> case x of ~p -> e = let p = x in e
04:46:09 <ski> @type partition
04:46:10 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
04:46:13 <ski> @src partition
04:46:14 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
04:46:14 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
04:46:14 <lambdabot>                               | otherwise = (ts, x:fs)
04:46:18 <benmachine> but it's more convenient to use ~ in e.g. nested patterns
04:46:27 <ClaudiusMaximus> pastorn: well, that's mainly binding to foreign code (libqd - which is actually a bit pointless as it seems to be exceedingly slow)
04:46:58 <ski> > let partition p xs = foldr (select p) ([],[]) xs where select p x (ts,fs) | p x = (x:ts,fs) | otherwise = (ts, x:fs) in partition even [0 ..]
04:47:00 <lambdabot>   *Exception: stack overflow
04:47:06 <ski> > partition even [0 ..]
04:47:07 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
04:47:07 <ClaudiusMaximus> pastorn: i'll try to add more comments as i go...
04:47:23 <Jafet> @src partition
04:47:24 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
04:47:24 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
04:47:24 <lambdabot>                               | otherwise = (ts, x:fs)
04:47:35 <ski> Watermind : that's basically the same issue, as with `partition' (except the definition of `partition' is correct)
04:47:36 <Jafet> Sorry, thought this was the echo chamber
04:48:00 <benmachine> not sure why partitionEithers isn't just partition isLeft
04:48:11 <ski> @type partitionEithers
04:48:13 <lambdabot> forall a b. [Either a b] -> ([a], [b])
04:48:23 <ski> that wouldn't work
04:48:26 <ski> @type partitionEithers isLeft
04:48:27 <lambdabot> Not in scope: `isLeft'
04:48:42 <ski> @type partitionEithers (either (const True) (const False))
04:48:43 <lambdabot>     Couldn't match expected type `[Either a b]'
04:48:44 <lambdabot>            against inferred type `Either a1 b1 -> Bool'
04:48:44 <lambdabot>     In the first argument of `partitionEithers', namely
04:48:49 <benmachine> oh, true
04:48:52 <ski> er
04:48:58 <ski> @type partition (either (const True) (const False))  -- rather
04:49:08 <lambdabot> forall a b. [Either a b] -> ([Either a b], [Either a b])
04:49:35 <ski> `(map fromLeft *** map fromRight) . partition isLeft' would work, i think
04:50:10 <gio123_> k
04:54:53 <ourichocaixeiro> hey, what you guys think abou learning Haskell as a second language instead of python?
04:55:34 <sipa1024> where?
04:56:02 <Watermind> benmachine: ski: very very interesting, this had never occurred to me, thanks guys
04:58:41 <ski> ourichocaixeiro : good
04:59:09 <ourichocaixeiro> ski: and why is good?
04:59:11 <ski> Watermind : iirc, the first "real" use of `~' i saw was with `Dialogue'-I/O
04:59:18 <ddarius> ski is assuming information he does not have.
04:59:41 <Jafet> python is nice, but it comes back to bite you in the end.
04:59:57 <ddarius> Pythons are constrictors.
05:00:09 <ourichocaixeiro> Jafet: why?
05:00:27 <Sina> Guys, why is this thing wrong?  data Maybe [(Char,Char)] = Invalid | Valid [(Char,Char)] 
05:00:28 <ourichocaixeiro> ddarius: my previous language is c
05:00:42 <Jafet> I need a more realistic metaphor then
05:01:03 <ski> i'm just thinking it is good to learn Haskell (or at least some functional language). preferably sooner than later
05:01:27 <ski> of course, that doesn't mean that you shouldn't learn some imperative language(s) as well
05:01:48 <benmachine> forall n haskell is good to learn as an nth language >_>
05:02:02 <ski> indeed
05:02:12 <Sina> can anyone help me with a problem defining a data type?
05:02:20 <ddarius> ski: But what if the options had been "Learn Python first and Haskell second" which is a possibility with the way the question was originally stated.
05:02:24 <benmachine> Sina: what is that supposed to do?
05:02:34 <Watermind> ski: this is going slightly off topic but just curious, which imperative language would you pick to teach?
05:02:41 <JuiCe`> hello to all
05:02:52 <ddarius> benmachine: I was going to recommend learning Haskell as one's negative thirty seventh language.
05:02:53 <Jafet> ddarius: where is the option in that?
05:02:59 <benmachine> ddarius: sounds good to me
05:03:07 <ski> ddarius : i was assuming everything else held constant :)
05:03:33 <Sina> benmachine: I want this type to hold a list of tuples for me. and also I want it to have Invalid and Valid types
05:03:42 <Sina> benmachine: is it possible?
05:03:52 <benmachine> Sina: so can't you use the existing Maybe rather than defining a new data type?
05:04:10 <ski> Watermind : i think Ada could be a good choice
05:04:11 * ddarius doesn't know what n he's on in nth language.
05:04:17 <benmachine> Sina: unless you want the keywords to be Invalid and Valid
05:04:30 <Sina> benmachine: what do you mean by existing Maybe? Do you mean Nothing and Just ?
05:04:34 <benmachine> Sina: yes
05:04:43 <benmachine> Sina: data Maybe a = Nothing | Just a
05:04:55 * ddarius would probably teach C# nowadays as a first primarily imperative language.
05:05:28 <Sina> benmachine: Basically, I have to make a program to get a cipher, an offset and a string and provide an encoded string.
05:05:55 <Boxo> Sina: data Maybe2 = Invalid | Valid [(Char,Char)] is how to do it if you want to keywords
05:06:37 <Sina> Boxo: thank you. I don't need to write [(Char,Char)] before the = ?
05:06:48 <raek> Watermind: definitely Ada.
05:07:02 * ddarius wonders how E would go over as a first language.
05:07:12 * Twey would choose FORTH
05:07:13 <Boxo> Sina: no. type variables go there,  [(Char,Char)]  is not a variable
05:07:27 <benmachine> Sina: defining a data type in haskell is a bit like defining a function, you only put stuff on the left of = if you need a parameter for your type
05:07:49 <benmachine> Sina: if you only ever have one kind of thing in your data type, you don't need any parameters
05:08:05 <ddarius> Twey: From my impressions of Factor, I think Factor is a better Forth in almost all ways, particularly in ways relevant for pedagogy.
05:08:08 <Sina> Boxo: benmachine: this is what I got now which is working :)  data Cipher = Invalid | Valid [(Char,Char)]  			   deriving (Eq,Ord,Read,Show)
05:08:08 * benmachine decides that the function analogy was correct but confusing
05:08:15 <Twey> ddarius: It's less imperative, I think
05:08:29 <Watermind> ski: ddarius: raek: yeap I first learned Pascal and was wondering if there was something more modern that would be a good pick, Ada did cross my mind (although it's not exactly a recent language)
05:09:04 <Watermind> ski: ddarius: raek: I was briefly looking at Scala lately but still don't have an opinion
05:09:13 <magicman> Is there a library function somewhere that does a case-insensitive readFile on case-sensitive filesystems, or will I have to roll my own?
05:09:14 <ski> Sina : btw, why do you (think you) need `Invalid' ?
05:09:23 <Twey> I do agree that it's cool, and I just recommended it to a friend as a first language not five minutes before joining this discussion, but if we're talking purely imperative programming, I'd have to go for something like FORTH
05:09:44 <Twey> magicman: Why would you want to do that?
05:09:47 <Boxo> Sina: you could just use values of type (Maybe [(Char, Char)]). So instead of Invalid write Nothing, instead of (Valid x) write (Just x). Then you don't need any "data" definition.
05:09:52 <ddarius> Watermind: I haven't really looked into Scala much, but it seems overly complicated and busy for a first language.
05:10:00 <Twey> magicman: I doubt such a function exists
05:10:14 * ski wonders what would be a sensible OO language
05:10:24 <zachk> scheme....
05:10:24 <ddarius> Twey: I would actually probably teach assembly as a first language before Forth.
05:10:34 <Twey> ddarius: *nod* It is useful
05:10:36 <Watermind> ddarius: yes it is a huge language... but if you restrict yourself to a small imperative subset I think you might  make it elegant and simple
05:10:39 <magicman> Twey: I'm reading some data files which were originally made for Windows systems, and subsequently everyone saved theirs with different case.
05:10:47 <Twey> I'd never recommend a purely imperative language first anyway, though.
05:11:00 <Twey> magicman: Hmm, ick.
05:11:03 <magicman> Twey: So there's INFO.TXT, Info.txt, info.txt, INFO.txt, etc...
05:11:15 <magicman> Yeah, that's what I thought as well <_<
05:11:20 <Sina> ski: Boxo: I am doing this for a university assignment. apparently I need to validate the cipher and say if it is valid or not. however it doesn't say in the assignment sheet exactly :(
05:11:25 <Twey> magicman: I guess you'd have to do it yourself
05:11:43 <magicman> Oh, well. Splitting up the filepath, and searching the directoryContents it is...
05:11:47 <ski> zachk : there is no default OO system in Scheme .. maybe you meant PLT Scheme^WRacket ?
05:11:59 <Watermind> ddarius: and you get some nice extras like a handy interpreter, algebraic datatypes ...
05:12:04 <Boxo> Sina: so why don't you just define a function of type (Cipher -> Bool)
05:12:15 <Sina> ski: Boxo: I need to do further process on the cipher if it be valid. I don't have any better idea to do it :(
05:12:58 <ski> Sina : i think you could forget about the `Invalid' constructor altogether .. if the cipher is valid, then continue processing on it, otherwise don't
05:13:17 <Boxo> Sina: your current datatype can't even store invalid ciphers
05:13:27 <Sina> Boxo: cause I need to make a list of tuples to assign X to Y , A to N, etc. (just as an example) so that the encoder change every character to the alternative in the tuple.
05:13:40 <ski> Boxo : well it could .. store them using the `Valid' constructor :)
05:14:51 <Nibble> what happened to lambdabot :/
05:14:53 <Sina> ski: Boxo: I don't care about invalid ciphers (and I can show error message if I want). however, I have to make sure it is valid before I proceed. and I should be able to test the function which validates the function seperately
05:14:56 * ski somehow thinks OO could be too important to leave to the OOers ..
05:15:00 * Watermind is out
05:15:35 <ski> Sina : sure. that doesn't mean you need (or should want) an `Invalid' constructor, though
05:16:25 <ski> Sina : if you write an `isValid :: Cipher -> Bool' function, i think that would be going a long way
05:16:50 <Sina> ski: can I say data Cipher = Valid [(... ?
05:17:13 <Sina> ski: cause I want the validateCipher function to make a list of tuples for me as well. (As well as checking)
05:17:27 <ski> sure, but why not just `data Cipher = MakeCipher [...]' (or s/data/newtype/)
05:17:32 <ski> hm
05:17:42 <ski> ok, so you want to change formats, when validating ?
05:18:05 * ski understood it before as just validating a format
05:18:25 <ski> Sina : so, what will be the inputs of the `validateCipher' function ?
05:18:55 <Sina> ski: I am not really good in Haskell. :) this is a bit confusing here. I will explain in private chat
05:19:11 <ski> why not in here ?
05:19:28 <ski> more people can come with suggestions, here
05:19:40 <ski> (and more people can learn by listening, here)
05:23:30 <Sina> ski: ok here. just its a bit confusing here  :)
05:25:59 <Sina> ski: so, am I doing it the right way?
05:26:51 <ski> well, there aren't any other conversation going on here, atm
05:27:03 <ski> maybe you could repeat what you said in private, here ?
05:27:18 <Sina> yeah, its strange :D
05:28:02 <Sina> ok. I need to make a data type Cipher and then a function called validateCipher.
05:28:15 <Sina> validatecipher should be tested seperately.
05:28:30 <Sina> and I need to make a function called encode, to take a cipher, offset and a character, and give me the encoded character
05:28:46 <Sina> and another function that does the encode for every character.
05:28:53 <Sina> so basically: data type Cipher -> function validateCipher -> function encodeChar -> function encodeMessage
05:29:25 <ski> hm
05:29:30 <Sina> so, I though choosing a data type of invalid | valid [tuples]
05:29:40 <ski> what is a cipher, here ?
05:30:04 <ski> just a (bijective) map from individual characters to individual characters ?
05:30:22 <Sina> and then while validating, making the list of tuples from plain text to cipher. (like [('a','b),('c','d')]...)
05:30:39 <Sina> its like this: "ESOVPZJAYQUIRHXLNFTGKDCMWB"
05:30:56 <Sina> which means A should be changed to E, B to S, etc.
05:31:18 <ski> hm, so that is to be the input to `validateCipher' ?
05:32:21 <Sina> that is going to be given to encodeMessage which passes to encodechar which passes to validatecipher
05:33:24 <ski> i.e., does `validateCipher' take any string as input, like the string `"ESOVPZJAYQUIRHXLNFTGKDCMWB"', check that it encodes a valid cipher, and if so, returns a list of tuples that can be used more easily to apply the cipher on characters ?
05:33:49 <Sina> encode message performs encodechar on all items in the text given to it
05:34:36 <Sina> validateCipher is supposed to validate the Cipher. it takes a string as you mentioned, but I do not know what should be the output.
05:34:45 <ski> you should probably try to write type signatures for your functions
05:35:00 <ski> to state more clearly what you need to implement
05:35:15 <ski> if `validateCipher' is to take a string as input, then it should be something like
05:35:21 <ski>   validateCipher :: String -> ...
05:35:27 <ski> where you need to fill in the `...'
05:35:30 <Sina> If tested seperately, it should display if its valid or not. (I guess true false should be ok as well). but since encodeChar is going to call it every time, I thought maybe doing all the work at once
05:35:39 <Sina> yes, its String->...
05:36:24 <ski> well, since you, if the cipher-encoded-in-a-string is valid, want to *return* a pair-list, and not just say that it was valid
05:36:35 <ski> the type `Maybe' is better than `Bool'
05:36:40 <ski> consider if you had written
05:36:49 <ski>   validateCipher :: String -> (Bool,Cipher)
05:37:20 <ski> then, even if the `Bool' part of the result is `False' (i.e. invalid), you would still need to return some (dummy) `Cipher' as the other part
05:37:30 <ski> this is not good
05:37:43 <ski> it is then better to say
05:37:49 <ski>   validateCipher :: String -> Maybe Cipher
05:38:14 <ski> so, either `validateCipher' will then return `Nothing', meaning the string was invalid, interpreted as a cipher
05:38:30 <Sina> yeah. if it be valid, I have to write the thing as well
05:38:41 <ski> or it will return `Just c', meaning that it was valid, and `c' is the actual cipher (your list of pairs, probably)
05:38:43 <haskellElephant> @ski, consider this,  if the cipher is not valid then we will return false, and no list of touples, and if it is valid we should return true and a list of touples. Notice that this is the only two possibilities. In one case nothing happens and we get false and in the other we get a list of touples. There is a designated type for this and that is Maybe. The function should return Just [('char','char')] when it is valid and Nothing if it
05:38:44 <lambdabot> Unknown command, try @list
05:38:56 <ski> s/@ski/ski/
05:39:36 <Sina> Is defining a new type a bad thing?
05:39:43 <ski> haskellElephant : i'm not sure you've noticed, but it is actually Sina who is asking for help .. perhaps you wanted to direct that message to her/him ?
05:39:47 <ski> Sina : no
05:40:02 <ski> but often it is not needed, when there's already a good alternative
05:40:47 <ski> Sina : also consider this : your later functions probably will not care about invalid ciphers at all, so why even make it possible to pass invalid ciphers to them ?
05:41:24 <haskellElephant> @list
05:41:24 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:41:40 <haskellElephant> oh, I am sorry ski...
05:41:42 <Sina> I'm not passing invalid ciphers. I am thinking on probably doing this: data Cipher = Valid [(Char,Char)] 
05:42:08 <Sina> and on validatecipher, I return error instead
05:42:20 <ski> haskellElephant : IRC messages starting with `@' are interpreted by lambdabot as commands to her. please try to refrain from using `@' at the start of a message, if you don't want to give a command to lambdabot
05:42:44 <haskellElephant> ski: sorry again, to many hours on stackoverflow =D
05:42:50 <itsjar> In a list I can just search by checking if it's equal and if it's not searching on the rest of the list. But how do I do this in a Tree? I don't see how I should 'combine' the 2 function calls in the else branch
05:43:00 <ski> Sina : returning an error might be ok as well .. it depends a bit on what your assignment wants
05:43:21 <itsjar> this code might help to clearify my question:
05:43:28 <ski> Sina : if you return an error, then you can't (easily) do anything in case of an invalid cipher, except stop the whole program
05:43:32 <itsjar> else treeLookup' element func left treeLookup' element func right
05:43:59 <Sina> ski: sadly it doesn't say what validateCipher is saying. so I think I can assume myself.
05:44:13 <ski> Sina : if you use e.g. `Nothing' (in `Maybe Cipher') instead, then you can catch that "error" from other functions, and decide to do something else, instead of stopping the program
05:44:20 <olsner> to use the llvm backend in ghc, I'll need a ghc-7 snapshot, right? (alternately: is the llvm stuff included in any 6.12.x release?)
05:44:34 <ski> Sina : but, possibly, giving an `error' might be ok
05:45:00 <benmachine> Sina: the advantage with using existing data types vs. making your own is you can use all sorts of stuff from the standard library immediately - you don't need to define your own functions for getting stuff out of the Valid constructor, or applying functions inside it, or whatever
05:45:09 <Sina> ski: I am allowed to stop the program. however, I must make a Cipher type
05:45:22 <ski> itsjar : if your (binary) tree is sorted, then you should know which sub-tree to continue searching in
05:45:41 <ski> itsjar : otherwise, you can try searching every subtree, until you find what you're looking for (or not)
05:46:01 <ski> Sina : ok, the simplest is to define `type Cipher = [(Char,Char)]'
05:46:04 <Sina> ski: benmachine: I have to make a Cipher data type as it is a requirement. I don't know how to make the most of it
05:46:04 <hpc> itsjar: there are techniques to keep a binary tree organized that make every operation O(log n)
05:46:22 <hpc> look up red-black trees
05:46:37 <ski> Sina : note that using `type' makes a type *synonym* : it doesn't create a *new* type; it merely gives a name to an existing one
05:46:45 <ski> Sina : possibly that is enough
05:46:47 <itsjar> yup I know, but I was just wondering how you would do it in case you don't want to choose a branch
05:47:09 <benmachine> itsjar: treeLookup returns a Maybe result? you might want mplus from Control.Monad
05:47:14 <itsjar> since combining the values with && wisn't an option if it's a maybe
05:47:17 <ski> Sina : if you want to make a *new* type, use e.g. `data Cipher = Valid [(Char,Char)]' like you say (but i would use `newtype' instead of `data')
05:47:20 <haskellElephant> olsner: I think the first version with llvm was 6.13.2 with doing cabal install primitive --ghc-options=-fllvm , but you best shot is to go with GHC head.
05:47:20 <Sina> ski: this is what is needed:"1. Define a Haskell data structure Cipher to represent a substitution cipher"
05:47:21 <itsjar> oh okay benmachine 
05:47:22 <benmachine> itsjar: or you can use the First monoid from Data.Monoid
05:47:30 <itsjar> I guess that's what I was looking for
05:48:36 <ski> Sina : well, i would interpret that as a type synonym would suffice ..
05:48:59 <ski> Sina : but there's no large difference. make a new type with `data' (or `newtype'), if you want
05:49:36 <ski> Sina : the difference (here) to a type synonym is that with `type Cipher = [(Char,Char)]', `Cipher' is the *same* type as `[(Char,Char)]'
05:50:23 <ski> Sina : but with `data Cipher = Valid [(Char,Char)]' (or `newtype' instead of `data'), you need to wrap `Valid' around a value of type `[(Char,Char)]' to make it into type `Cipher'
05:50:36 <ski> (and you need to pattern-match on `Valid' to go in the other direction)
05:50:39 <Sina> ski: is using type and data basically the same thing? just type is more efficient?
05:50:49 <sipa1024> it's completely different
05:51:08 <ski> `type' is as efficient as `newtype'
05:51:24 <ski> `data' and `newtype' can create recursive types, `type' can't
05:51:39 <olsner> haskellElephant: thanks, I'll go with ghc head then :)
05:51:45 <Sina> ski: what are recursive types?
05:51:54 <ski> `data' can create types where the values can be of several possible forms, and where the constructors can take many (or zero) arguments
05:52:21 <ski>   data IntList = Empty | Cons Int IntList
05:52:29 <ski> is an example of a recursive type
05:52:34 <Sina> ski: what is the different between type and newtype? we have not been taught any of these.
05:52:40 <ski>   Empty :: IntList  -- `Empty' is an `IntList'
05:52:51 <sipa1024> newtype is like a data with only one constructor, but more efficient
05:52:57 <ski>   Cons 2 Empty :: IntList  -- `Cons 2 Empty' is also an `IntList'
05:52:58 <benmachine> Sina: newtype is more similar to data than type
05:53:06 <ski>   Cons 5 (Cons 2 Empty) :: IntList
05:53:06 <joe__> ksf: you around?
05:53:07 <sipa1024> but both newtype and data create a new type
05:53:15 <sipa1024> type just creates a new name for an existing type
05:53:18 <ski> Sina : you can probably forget about `newtype' for now
05:53:39 <ski> Sina : note how there's two possible shapes for a value of type `IntList'
05:53:44 <Sina> ski: oh, I understand. Empty :: IntList makes it quite clear. however, I do not know about these yet.
05:53:49 <ski> Sina : (a), `Empty' is an `IntList'
05:54:00 <Nibble> shit
05:54:03 <Nibble> The Yi editor
05:54:10 <ski> Sina : (b) `Cons x xs' is an `IntList' if `x' is an `Int' and `xs' is an `IntList'
05:54:11 <Nibble> it depends on cairo
05:54:24 <Nibble> but cairo gives ExitFailure 1 during configuration
05:54:27 <Nibble> ideas?
05:54:41 <Sina> ski: how do you pattern match it later? I mean Empty and IntList are basically same thing. aren't they?
05:54:43 <ski> Sina : what makes `data IntList = Empty | Cons Int IntList' a definition of a *recursive* type is that `IntList' (the type being defined), occurs at the right of the `=' symbol
05:55:01 <ski> so an `IntList' can contain a smaller `IntList'
05:55:02 <Nibble> oh right
05:55:06 <Nibble> it needs gtk2hsC2hs
05:55:10 <Nibble> shit
05:55:27 <ski> Sina : no, `IntList' is a type, but `Empty' is a value
05:55:37 <ski> example of pattern-matching on it
05:55:44 <ski>   firstElement :: IntList -> Int
05:56:03 <ski>   firstElement  Empty      = error "empty `IntList'"
05:56:10 <ski>   firstElement (Cons x xs) = x
05:56:13 <ski> that's one example
05:56:17 <ski> another is
05:56:23 <ski>   sumList :: IntList -> Int
05:56:37 <ski>   sumList  Empty      = 0
05:56:44 <ski>   sumList (Cons x xs) = x + sumList xs
05:56:54 <Axman6> data Car = Porche | Toyota | Ford <-- ski does that help you at all remembering what types and constructors are? 
05:57:15 <ski> Sina : `firstElement' just matches on whether the "top" shape of the `IntList' is empty or not
05:57:19 <hpc> haha, everyone is doing it; (pinging ski instead of Sina)
05:57:36 <Sina> ski: quite strange. but I guess I understand.
05:57:37 <Axman6> urgh
05:57:45 <Axman6> Sina: the car thing was for you
05:57:46 <ski> Sina : `sumList', however, is recursive (it calls itself), so it will check the whole of an `IntList'
05:58:03 <ski>      sumList (Cons 1 (Cons 2 (Cons 3 Empty)))
05:58:04 <Sina> Axman6: this data Car ... is exactly what we have been told so far.
05:58:11 <ski>   =  1 + sumList (Cons 2 (Cons 3 Empty))
05:58:18 <ski>   =  1 + (2 + sumList (Cons 3 Empty)
05:58:32 <ski>   =  1 + (2 + (3 + sumList Empty))
05:58:35 <ski>   =  1 + (2 + (3 + 0))
05:58:38 <ski>   =  1 + (2 + 3)
05:58:40 <ski>   =  1 + 6
05:58:43 <ski> er
05:58:45 <ski>   =  1 + 5
05:58:45 <hpc> 1+5
05:58:48 <ski>   =  6
05:59:17 <ski> Sina : that is a step-by-step evaluation of how `sumList (Cons 1 (Cons 2 (Cons 3 Empty)))' would typically evaluate
05:59:22 <joe1> is there a smarter way of removing the duplicity in this: data Message = Setup {lineno::Int, line::String, data::[String] | Out {lineno::Int, line::String, data::[String]. I could write a type synonym but that requires an extra paranthesis during pattern matching.
05:59:43 <Sina> ski: let me take a careful look at it :)
05:59:52 <joe1> see how i have the lineno, line and data written twice above.
06:00:23 <hpc> joe1: data Message = Message Flag Int String [String]
06:00:30 <hpc> data Flag = Setup | Out
06:00:51 <hpc> (except with records; i can't be arsed to type all that out)
06:00:56 <ski> hpc,joe1 : possibly adding back the record field names for `Message'
06:01:01 <Sina> ski: is Cons a type? does it do what : does?
06:01:09 <joe1> hpc: thanks, that was brilliant.
06:01:13 <hpc> also, i almost pinged ski instead of joe1
06:01:18 <joe1> ski: thanks, very good idea
06:01:22 <ski> Sina : no, both `Empty' and `Cons' are data constructors. they are a kind a value
06:01:23 <Axman6> cons is a constructor, it constructs new objects of type IntList
06:01:35 <Axman6> C*
06:01:40 <ski> Sina : and yes, `Cons' is similar to `(:)' (which is also a data constructor)
06:01:45 <Axman6> s/objects/values
06:02:33 <ski> joe1 : well, i *was* going to give you that idea, but hpc got ahead of me ..
06:02:38 <hpc> :D
06:02:44 <ski> Sina : note that
06:02:49 <Sina> ski: this is a bit hard to understand. as I did not know data strtuctures can "do" stuff :)
06:02:59 <ski>   Empty ::                  IntList
06:03:05 <ski>   Cons :: Int -> IntList -> IntList
06:03:19 <hpc> Sina: the data structure isn't doing anything, per se; it is more like it is defining a shape for the data to take
06:03:30 <ski> Sina : data structures don't "do" much :)
06:03:40 <ski> Sina : they more or less just store data
06:03:52 <ski> `Empty' is something that is an `IntList'
06:04:16 <ski> `Cons' is a function (a constructor), which, given an `Int' and an `IntList', will package them up into an `IntList'
06:04:17 <Sina> ski: hpc: well, doesn't Cons make a new list ?
06:04:28 <ski> and you can use pattern-matching to get the parts
06:04:45 <ski> Sina : well, it depends on what you mean by "new"
06:04:57 <hpc> Sina: creating stuff is generally not considered to be "doing something" in Haskell
06:05:08 <hpc> since that's all a constructor can do
06:05:32 <Sina> ski: well 4:[1,2,3] can be done like this: Cons 4 [1,2,3] . right?
06:05:47 <ski> if you write `Cons 1 (Cons 2 Empty)' somewhere in your code, and then write the same thing somewhere else, the compiler is allowed to only generate code which will "create" that list one time, and reuse it in both places
06:05:54 <ski> but it doesn't need to do that
06:06:27 <ski> Sina : generally, it is better to just think in terms of what values things return, instead of bothering too much with whether they are newly created or not
06:06:46 <ski> Sina : no, since the types `IntList' and `[Int]' are not the same type
06:07:05 <ski> Sina : `[1,2,3]' has type `[Int]', not `IntList'
06:07:09 <Sina> ski: this Cons 1 (Cons 2 Empty) returns [1,2] . right? 
06:07:14 <ski> no
06:07:21 <hpc> Sina: they are what we would call "isomorphic" (i think i have the term right)
06:07:22 <ski> it returns `Cons 1 (Cons 2 Empty)'
06:07:30 <ski> `Cons 1 (Cons 2 Empty)' is itself
06:07:37 <hpc> they are different, but extremely similar
06:07:58 <ski> Sina : i invented `IntList' above to simplify a bit from the `[Int]' type
06:07:59 <benmachine> hpc: I think that the term is abused by category theorists, but you use it in the same way as them :P
06:08:10 <ski> Sina : you are right in that the idea behind them is the same
06:08:17 <Sina> what is the difference between Intlist and a list of int ([Int]) . so far I thought they are the same
06:08:20 <joe1> ski: cool, thanks.
06:08:32 <hpc> benmachine: yay! i am bastardizing math like a pro!
06:08:45 <benmachine> :)
06:08:49 <ski> Sina : what is the difference betwee `(1,"hey")' and `("hey",1)' ?
06:09:19 <hpc> Sina: they are different types, fundamentally
06:09:35 <Sina> ski: the order? basically the types won't fit the definition as well
06:09:46 <hpc> Sina: what's the difference between Bool = False | True, and Falafel = Delicious | Rancid?
06:10:06 <Sina> hpc: different types, but are they doing the same thing?
06:10:12 <ski> Sina : yeah. both `(1,"hey")' and `("hey",1)' contain the same information, but that information is represented differently (the order, here)
06:10:16 <ski> Sina : yes
06:10:23 <hpc> Sina: essentially; when you find a delicious True, let me know ;)
06:10:29 * benmachine submits a haskell2010 proposal to change Bool to Falafel
06:10:36 <ski> similarly, `IntList' and `[Int]' are different types, but store the same information
06:10:39 <benmachine> *haskell2011 I suppose
06:11:11 <ski> Sina : you can define a new `IntList2' type if you wish, that will also store the same information as `IntList', but will still be a different type
06:11:16 <Sina> ski: this is well confusing for a beginner :) but I do understand ...
06:11:49 <ski> Sina : each time you use `data' you introduce a *new* type .. it might be similar to already existing types .. or not
06:12:06 <ski> if you write
06:12:13 <ski>   data IntList = Empty | Cons Int IntList
06:12:14 <ski> and then
06:12:20 <ski>   data IntList2 = Empty2 | Cons2 Int IntList2
06:12:26 <Sina> ski: I get that. so if I say data MyBool = True | False , it is the same as Bool, except that its a different type. right?
06:12:29 <joe1> is there a better way of removing the redundancy of "lineno line (parse line)" below..
06:12:32 <joe1> parse (lineno,line) | is line == ">>>>> 0x2D" = Message Setup lineno line (databytes line) | is line == ">>>>> 0xE1" = Message Out lineno line (databytes line)
06:12:40 <ski> those two types are different, because they are `data'-types, with different names
06:12:48 <ski> Sina : yes
06:13:01 <joe1> parse (lineno,line)
06:13:08 <joe1> | is line == ">>>>> 0x2D" = Message Setup lineno line (databytes line)
06:13:14 <joe1>  | is line == ">>>>> 0xE1" = Message Out lineno line (databytes line)
06:14:11 <Sina> ski: how big a deal to the computer is making a new type which already exists? (like the thing we discussed about [(char,char)] making it a "type" or "data")
06:14:11 <joe1> i cannot use another function instead of "lineno line (databytes line)" as a function can only return a tuple.
06:14:27 <ski>   parse (lineno,line) = Message (foo (is line)) lineno line (databytes line)
06:14:28 <ski>     where
06:14:36 <ski>     foo ">>>>> 0x2D" = Setup
06:14:38 <Axman6> Sina: in the case of Bool, it would not be the same, since Bool is treated specially in Haskell (such as in if-then-else, guards), but in general you're right
06:14:42 <ski>   foo ">>>>> 0xE1" = Out
06:14:50 <ski> (er, indented more, of course)
06:14:53 <ski> joe1 : ^
06:14:53 <joe1> ski: cool, brilliant. Thanks a lot, man
06:15:16 <hpc> Sina: new types will have minimal overhead; it mostly matters to the type-checker, which happens at compilation
06:15:29 <hpc> Sina: type aliases (the 'type' keyword) have zero overhead
06:15:46 <ski> Sina : no big deal at all, except that you might want to pass values of that new type where only values of similar, but not same, types will fit (so you will need to convert, then)
06:16:17 <rracer> Is there an example or library that shows a continuous processing of tcp stream, mainly csv data. Each line is parsed as it happens and not lazily.
06:16:25 <ski> Sina : the other deal is that if there already is a perfectly good type that you can use, it is usually less confusing to use that, instead of inventing a new type (there are limits to this, of course)
06:16:55 <ski> hpc : btw, note that "new type" here includes both `newtype' and `data'
06:17:21 <Sina> ski: since we have not been taught to use "type", I guess I should go on with "data". however, now I fully understand "type" :)
06:17:27 <hpc> ski: i am ignoring newtype; it's a bit odd for newbies to deal with right away
06:17:49 <ski> joe1 : generally, factor out the common parts of code with repetition, passing in the differing parts as parameters (sometimes this leads to higher-order functions)
06:18:03 <ski> Sina : sure, `data' is probably ok
06:18:46 <ski> Sina : btw, note that if you define `type Name = String' and `type Address = String', then since those two types are the *same* as `String', it is possible to, by mistake, confuse names with addresses in programs
06:19:34 <ski> Sina : but if you use `data Name = MakeName String' and `data Adress = MakeAdress String', then those are different types, so you can't confuse them with each other (or with `String') by mistake
06:19:47 <ski> Sina : that is one advantage to using `data' (or `newtype') to using `type'
06:19:48 <hpc> also
06:19:56 <hpc> String itself is an alias for [Char]
06:19:59 <Sina> ski: I see. :)
06:20:01 <ski> right
06:20:05 <ski>   type String = [Char]
06:20:16 <hpc> which is slightly less confusing since it has precedent in other languages
06:20:20 <ski>   length :: [a] -> Int
06:20:21 <hpc> but nice to know
06:20:24 <ski> > length "apa"
06:20:27 <lambdabot>   3
06:20:40 <ski> > take 6 "lambdabot"
06:20:41 <lambdabot>   "lambda"
06:20:41 <Axman6> > ['a','b','c']
06:20:43 <lambdabot>   "abc"
06:20:46 <Sina> so, its basically type String = [Char] ? or data String = [Char] ?
06:20:51 <hpc> type
06:20:54 <ski> the former
06:21:06 <Sina> ski: right :) I see...
06:21:06 <ski> `String' is the *same* type as `[Char]'
06:21:29 <ski> (instead of each `String' containing / consisting of a `[Char]', which is what the latter would do)
06:22:24 <Sina> ski: the latter would mean, its not the same data type, however it does the same thing. right?
06:22:39 <ski> yeah
06:22:43 <ski> but then you couldn't say
06:22:49 <ski> > take 6 "lambdabot"
06:22:50 <lambdabot>   "lambda"
06:23:02 <ski> since `take' wants a list as second argument
06:23:28 <ddarius> Sina: The latter is a syntax error.
06:23:36 <ski> right
06:23:41 <Sina> is > a prelude here in this chat? :)
06:23:45 <ski> the latter would have to be something like
06:23:50 <ski>   data String = MakeString [Char]
06:24:03 <hpc>  > is an alias for @run, which is a lambdabot command
06:24:14 <Axman6> Sina: lambdabot is a bot that does a lot of what ghci does, plus a lot more
06:24:15 <hpc> it runs haskell code and prints the output
06:24:21 <Axman6> > 1+1
06:24:22 <lambdabot>   2
06:24:23 <ski> Sina : it is a way to interactively evaluate haskell snippets, for pedagogical purposes
06:24:26 <Axman6> @type (+)
06:24:28 <lambdabot> forall a. (Num a) => a -> a -> a
06:24:28 <Sina> > "Its nice"
06:24:29 <lambdabot>   "Its nice"
06:24:36 <joe1> thank god, lambdabot is back
06:24:46 <joe1> > "it is nice to have you back"
06:24:47 <lambdabot>   "it is nice to have you back"
06:24:48 <ski> joe1 : not the usual lambdabot
06:25:00 <Axman6> @djinn (a->b) -> (b->c) -> a -> c
06:25:01 <lambdabot> f a b c = b (a c)
06:25:03 <ski> (but *a* lambdabot, yes)
06:25:12 <hpc> @type (.)
06:25:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:25:21 <hpc> it still runs caleskell
06:25:21 <Sina> ski: what is MakeString ?:)
06:25:41 <hpc> Sina: a hypothetical constructor for a hypothetical String
06:25:53 <ski> (Saizan is hosting this one. Cale is supposed to be hosting the usual one, but he seems to be missing in action)
06:25:55 <joe1> joe1: oh, ok. thanks.
06:26:07 <hpc> joe1: talking to yourself, i see
06:26:23 <ski> Sina : every time you use `data' you need not only to invent a name for your type, but also name(s) for your data constructors
06:26:37 <ski> Sina : like `Empty' and `Cons' with `IntList' above
06:27:43 <Sina> ski: oh I see. so if I say data Cipher = [(Char,Char)] I will get an error. right?
06:27:46 <ski> right
06:28:17 <Sina> but type Cipher = [(Char,Char)] would work perfectly fine. right?
06:28:22 <hpc> yes
06:28:34 <ski> since `Cipher' is not the same type as `[(Char,Char)]' here, you need some way of converting (or wrapping, if you will) values of type `[(Char,Char)]' to values of type `Cipher'
06:28:36 <ski> yes
06:28:44 <Sina> and type Cipher = Just x will not work?
06:28:53 <ski>   data Cipher = MakeCipher [(Char,Char)]  -- e.g.
06:28:58 <Axman6> Just x isn't a type
06:29:16 <ski> if you want, you can rename `MakeCipher' into `Valid' .. or anything else which you think appropriate
06:29:23 <hpc> type Cipher = Maybe x will work
06:29:44 <hpc> also, something fun about lists of tuples, like [(Char, Char)]
06:29:46 <ski>   MakeCipher :: [(Char,Char)] -> Cipher  -- `MakeCipher' is a function that converts `[(Char,Char)]'s into `Cipher's
06:29:47 <hpc> :t lookup
06:29:48 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
06:30:05 <tarwatirno> ]account on
06:30:06 <ski> Sina : what is the `x', there ?
06:30:23 <Sina> ski: I did not know fundamentally the differences, etc. and now I know :)
06:30:42 <Sina> anything. like an "a"
06:30:43 <ski> > lookup 'b' [('a','x'),('b','y'),('c','z')]
06:30:44 <lambdabot>   Just 'y'
06:30:49 <ski> > lookup 'g' [('a','x'),('b','y'),('c','z')]
06:30:50 <lambdabot>   Nothing
06:31:07 <hpc> > lookup 'b' [('b', True)]
06:31:08 <lambdabot>   Just True
06:31:45 <ski> Sina : the function `lookup' might be useful to you, for your assignment
06:31:46 <Sina> what is the data type of lookup ?
06:31:53 <ski> `lookup' is a function
06:32:03 <hpc> lookup :: forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
06:32:10 <ski>   lookup :: Eq a => a -> [(a,b)] -> Maybe b
06:32:11 <Sina> ski: I cannot use it :( need to search recursively for it....
06:32:15 <ski> ok
06:32:34 <ski> it is not that hard to do the recursion yourself
06:32:37 <hpc> you can read it as "give it a thing, and a list connecting those things to other stuff, then give us possibly a stuff correpsonding to that thing we gave before"
06:32:49 <ski> only a little more work that for the `sumList' example above
06:33:32 <Sina> ski: yeah, I can do the recursion. it would be pretty easy I guess.
06:33:46 <ski>   lookup :: Eq key => key -> [(key,value)] -> Maybe value  -- possibly better naming
06:34:32 <Sina> can you use something like: function :: alpha -> beta ?
06:34:47 <hpc> sure
06:35:03 <hpc> you could even go crazy and have function :: α -> β
06:35:08 <hpc> :D
06:35:24 <Sina> and what if the type be the same name as another function? like function :: lookup -> sort
06:35:36 <ski> that doesn't matter
06:35:36 <benmachine> surely you mean α → β >_>
06:35:40 <hpc> when they have lower case names, they are "type variables"
06:35:43 <hpc> benmachine: lol
06:35:47 <Sina> hpc: does it accept unicode ? :)
06:36:06 <benmachine> Sina: it should do, but implementations might differ
06:36:09 <ski> (a) the names of types, and the names of values (like functions) live in different "name spaces", there is no possibility to confuse one for the other
06:36:12 <hpc> so in our lookup function, "key" starts with "k", not "K"
06:36:17 <benmachine> Sina: in theory anything that passes Data.Char.isLower should be fine
06:36:38 <ski> (b) type *variables* start with lower case, while type *constructors* start with upper case
06:36:38 <hpc> so it can be whatever we want it to be; we reuse "key" later to show that other parameters have to be of the same type
06:36:45 <benmachine> > isLower 'λ'
06:36:46 <lambdabot>   True
06:37:01 <hpc> Sina: here's a simpler example
06:37:06 <hpc> id x = x
06:37:07 <hpc> :t id
06:37:09 <lambdabot> forall a. a -> a
06:37:16 <ski>   id :: a -> a
06:37:21 <hpc> so whatever 'a' is, it has to be the same for the input and output
06:37:31 <hpc> you can't have id True = ["zombies!"]
06:37:53 <hpc> id True would give id the type Bool -> Bool
06:37:59 <ski> > id True
06:38:01 <lambdabot>   True
06:38:13 <hpc> id "oogahboogah" gives id the type String -> String
06:38:14 <hpc> etc
06:38:18 <Sina> so, without type definition, add 2 = 1 + 1 will work?
06:38:23 <ski> > id `asTypeIn` \id -> id Bool
06:38:25 <lambdabot>   Not in scope: data constructor `Bool'
06:38:26 * Axman6 thinks it'd be cool if you could define id as: id =
06:38:32 <ski> > id `asTypeIn` \id -> id True  -- er
06:38:33 <lambdabot>   Overlapping instances for GHC.Show.Show
06:38:34 <lambdabot>                              (GHC.B...
06:38:42 <ski> @type id `asTypeIn` \id -> id True  -- er, again :)
06:38:43 <lambdabot> Bool -> Bool
06:38:49 <Axman6> ski: don't you need to use type?
06:38:54 <Axman6> yeah...
06:38:55 <ski> i do
06:39:06 <Sina> > add 2 = 1 + 1
06:39:07 <hpc> heh
06:39:07 <lambdabot>   <no location info>: parse error on input `='
06:39:18 <hpc> Sina:
06:39:25 <hpc> > let add 2 = 1+1 in add 2
06:39:26 <lambdabot>   2
06:39:32 <hpc> :t let add 2 = 1+1 in add
06:39:33 <Sina> > add x = 1+ 1
06:39:34 <lambdabot> forall t t1. (Num t1, Num t) => t -> t1
06:39:34 <lambdabot>   <no location info>: parse error on input `='
06:39:39 <ski> > let add 2 = 1+1 in add 3
06:39:40 <lambdabot>   *Exception: <interactive>:3:4-14: Non-exhaustive patterns in function add
06:40:01 <ski> > let add x = x + x in map add [0,1,2,3]
06:40:02 <lambdabot>   [0,2,4,6]
06:40:39 <Sina> why do we need let here?
06:40:52 <aristid> Sina: we don't
06:40:57 <ski> Sina : `> ' in lambdabot doesn't accept definitions, on their own, just expressions (which can contain definitions, inside `let ... in ...', e.g.)
06:41:03 <aristid> > map (join (+)) [0,1,2,3]
06:41:05 <lambdabot>   [0,2,4,6]
06:41:15 <gio123_> ski
06:41:27 <Sina> this doesn't make sense to me let add 2 = 1+1 in add 2
06:42:13 <hpc> Sina: it says, create a function called add; when it gets 2 as a parameter, return 1+1; then we do what comes after 'in'
06:42:38 <hpc> after we finish that line, stuff we defined inside the 'let' vanishes
06:42:56 <Jafet> > let 1 + 1 = 3 in 1 + 1
06:42:58 <lambdabot>   3
06:43:01 <Sina> so its basically a pattern matching as well :)
06:43:06 <hpc> yep
06:43:15 <ClaudiusMaximus> > map (\n -> let { (front,rear) = break (=='e') n ; (sign, mantissa) = case front of { ('-':m) -> (-1,m) ; m -> (1,m) } ; exponent = read (case tail rear of { ('+':e) -> e ; e -> e }) + length big ; (big, small) = break (=='.') mantissa } in reverse . dropWhile (=='.') . dropWhile (=='0') . reverse . (if sign < 0 then ('-':) else id) $ if exponent < 0 then "0." ++ replicate (-exponent) '0' ++ big ++ tail small else let (x,y) = sp
06:43:16 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:43:21 <ski> > let f 0 = 1; f 1 = 3; f 2 = 8 in map f [2,1,0]
06:43:22 <lambdabot>   [8,3,1]
06:43:27 <ClaudiusMaximus> my brain hurts now...
06:43:44 <ski> > map f [2,1,0] :: [Expr]
06:43:45 <lambdabot>   [f 2,f 1,f 0]
06:43:59 <hpc> patterns in let are kind of quirky, but you don't have to worry about it until you try doing crazy things with it
06:44:21 <Sina> ski: cool thing with that [8,3,1] :)
06:44:40 <ski> of course, note
06:44:44 <ski> > let f 0 = 1; f 1 = 3; f 2 = 8 in map f [2,1,0,3]
06:44:45 <lambdabot>   [8,3,1,*Exception: <interactive>:3:4-28: Non-exhaustive patterns in functio...
06:44:51 <ski> since `f 3' isn't defined
06:45:13 <jmcarthur> silly partial functions
06:45:18 <hpc> thanks to laziness (which is a whole other lesson), it doesn't fail until it tries to evaluate it
06:45:25 <hpc> which happens when it wants to show that element
06:45:26 <yitz> > let f 0 = 1; f 1 = 3; f 2 = 8; f _ = 1337 in map f [2,1,0,3]
06:45:27 <lambdabot>   [8,3,1,1337]
06:45:44 <hpc> which is why we can see the beginning of the list
06:45:47 <Sina> I see. so if after f2=8 you put ; f n = n
06:45:51 <Sina> it will work fine?
06:46:00 <ils> hi, how to get the path of haskell program's executable file?
06:46:05 <Sina> for any larger list with any variable.
06:46:09 <ski> > let f 0 = 1; f 1 = 3; f 2 = 8; f n = n in map f [2,1,0,3]
06:46:10 <lambdabot>   [8,3,1,3]
06:46:24 <ski> Sina : yes
06:46:29 <Sina> thats it :)
06:46:31 <hpc> ils: it should be in the directory you compiled it in
06:47:07 <Sina> guys. thanks a lot for the help. I learned a lot. specially thank you ski. and thank you hpc :)
06:47:41 <ils> hpc, oh, I mean the path on a user's system. Say, I want to load some file which is in the same directory as the binary
06:47:48 <hpc> oh
06:47:57 <hpc> look in the environment variables
06:47:59 <hpc> :t getEnv
06:48:01 <lambdabot> Not in scope: `getEnv'
06:48:09 <hpc> @hoogle getEnv
06:48:10 <lambdabot> System.Environment getEnv :: String -> IO String
06:48:10 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
06:48:14 <hpc> ^
06:48:15 <Sina> I need to go right now. I hope to talk to you all later :)
06:48:23 <ils> hpc, is it portable?
06:48:32 <hpc> not sure
06:48:38 <hpc> should b
06:48:41 <hpc> *be
06:48:51 <jmcarthur> why would that info be in the environment?
06:49:12 <jmcarthur> current dir probably is, but i don't know about the current executable's binary dir
06:49:22 <ski> Sina : ok. have fun with Haskell !
06:49:39 <Axman6> > let f 1 = f 2; f 2 = f 8; f 3 = f 4; f 5 = f 3; f 4 = f 9; f n = n in f 2
06:49:40 <lambdabot>   8
06:49:41 <jmcarthur> this is actually something that base makes unnecessarily hard, IMO
06:49:54 <Axman6> > let f 1 = f 2; f 2 = f 8; f 3 = f 4; f 5 = f 3; f 4 = f 9; f n = n in map f [1..10]
06:49:55 <lambdabot>   [8,8,9,9,9,6,7,8,9,10]
06:49:57 <jmcarthur> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-Environment.html#v%3AgetProgName  <-- doesn't do what it might do in most languages in the name of "portability"
06:50:45 <jmcarthur> and of course getArgs chops off the program name...
06:52:34 <ils> so, what to do then?
06:53:12 <hpc> i vote you run in circles and scream :P
06:53:28 <benmachine> ils: that information isn't always available
06:53:49 <benmachine> the practice of getting it from the first argument in other languages doesn't necessarily work as the first argument can just lie
06:54:09 <benmachine> that information is *sometimes* available though
06:54:19 <benmachine> and arguably should be easier to get
06:54:30 <ils> hmm, probably I should reformulate the task then
06:55:47 <benmachine> ils: maybe, maybe not
06:55:57 <benmachine> ils: I thought there was a way to do what you want on hackage but buggered if I can find it
06:56:20 <ils> I'm going to implement some kind of search fuctionality for resourse files which are bundled with the app. I thought about placing them into fixed directory relative to binary file and using path to binary as a way to get them
06:56:51 <benmachine> ils: the easiest way is to just assume the binary is being run from its folder
06:56:57 <benmachine> or
06:57:21 <ils> well, it's not always true
06:57:21 <ClaudiusMaximus> ils: use Paths_pgkname facility from cabal-install ?
06:57:25 <benmachine> Cabal can install them in a global location
06:57:39 <benmachine> and yes, provide you with that location via Paths_pkg
06:58:45 <benmachine> ils: try http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#paths-module
06:58:46 <ils> ClaudiusMaximus, I'm currently using it, but, say on Windows there is a practice in the installer to allow to change the place of installed files, so compiled-in pathes won't go
06:59:50 <hpc> you could have it save the path in (registry | file in program directory)
07:00:39 <mauke> launch via helper program that sets an environment variable to the full path
07:00:41 <benmachine> ils: can't you tell that installer to generate the correct Paths module for the new location?
07:00:45 <mauke> where helper program = shell script
07:00:49 <benmachine> or do what mauke says, that's 900x simpler
07:01:24 <jmcarthur> benmachine: you mean make the installer build from source? eek
07:01:31 <jmcarthur> end users don't want ghc ;)
07:01:32 <benmachine> jmcarthur: true :(
07:01:44 <ils> benmachine, installer in my case is InnoSetup, it knows nothing about Haskell and there is no haskell toolchain on the host in runs on
07:01:54 <ils> :)
07:01:56 <benmachine> ok just do what mauke says then :P
07:02:08 <benmachine> this I find is a useful guiding principle in life
07:02:13 <benmachine> always do what mauke says.
07:02:18 <jmcarthur> it's what i do
07:03:05 <yitz> mauke: on windows w/o cygwin helper program = ?
07:03:18 <jmcarthur> one of these days i want to say something like 
07:03:42 <jmcarthur> "/me jumps out the window" ... and then start using another nick without telling anybody
07:03:54 <mauke> yitz: batch file
07:03:55 <jmcarthur> and when somebody finally does @seen jmcarthur ...
07:03:59 <hpc> hahaha
07:04:06 <benmachine> jmcarthur: cruel :(
07:04:34 <yitz> jmcarthur: simpler - just change your nick to mmorrow
07:04:39 <jmcarthur> lol
07:04:41 <benmachine> o_o
07:04:49 <olsner> @seen mmorrow
07:04:49 <lambdabot> Unknown command, try @list
07:04:49 <preflex>  mmorrow was last seen on #ghc 279 days, 11 hours, 7 minutes and 3 seconds ago, saying: * mmorrow is rtfm'ing
07:04:52 * jmcarthur misses mmorrow
07:04:57 <jmcarthur> oh lambdabot is back!
07:05:07 <olsner> must be a long manual that :)
07:05:08 <jmcarthur> that is a loooooooooong manual
07:05:12 <jmcarthur> everybody says tha
07:05:13 <hpc> lambdabot is an imposter
07:05:14 <jmcarthur> t
07:05:18 <jmcarthur> oh, dang
07:05:31 <benmachine> no-one's seen Cale for a few days
07:05:34 <jmcarthur> but wait, how would an imposter have that info?
07:05:36 <aristid> preflex: seen cale
07:05:36 <preflex>  cale was last seen on #haskell 3 days, 17 hours, 39 minutes and 17 seconds ago, saying: Applying the function 4 to the value 5
07:05:46 <aristid> jmcarthur: preflex != lambdabot
07:05:52 <aristid> um, i mean /=
07:05:54 <Axman6> > 4 5
07:05:54 <benmachine> heh
07:05:55 <lambdabot>   4
07:06:00 <jmcarthur> oh
07:06:05 <Axman6> > 4 56
07:06:05 <hpc> clearly Cale doesn't have the right instances loaded
07:06:06 <lambdabot>   4
07:06:06 <Axman6> > 4 5 6
07:06:07 <lambdabot>   4
07:06:12 <Axman6> > 4 `5` 6
07:06:13 <lambdabot>   <no location info>: parse error on input `5'
07:06:15 <jmcarthur> i say lambdabot's name and then that text. didn't notice lambdabot was actually just complaining
07:06:16 * yitz thinks aristid was reading the reddit post about cpython
07:06:25 <jmcarthur> *saw
07:06:28 <aristid> yitz: no, i wasn't. link?
07:06:38 <Axman6> > let (*) = 5 in 4 * 6
07:06:39 <lambdabot>   5
07:06:58 <jmcarthur> > (+2) * (+1) $ 3
07:06:59 <lambdabot>   20
07:07:14 <yitz> aristid: http://www.reddit.com/r/haskell/comments/dvjzp/cpython_bindings_for_libpython_the_bindings_allow/
07:09:34 <aristid> yitz: GPL-3 sounds like you can't use it for some things, eh?
07:09:59 <ils> thank you all, I'll try to do it with shortcuts on Windows. Seems, they're capable of changing the current directory
07:13:10 <__philip> hi
07:19:20 <Guest86956> Hey I got a question, it's about creating a show instantiation. I have the datatype "data Traced a = Traced {current :: a, trace :: [a]}" Now if I try to instantiate it like this (http://hpaste.org/40823/how_to_instantiate_trace?pid=40823&lang_40823=literatehaskell) then I get an error. Any idea how I can instantiate trace?
07:20:47 <mauke> data Traced a = Traced {current :: a, trace :: [a]}
07:20:47 <mauke>   deriving (Show)
07:21:14 <Lemmih> Guest86956: Or: instance Show a => Show (Traced a) where ...
07:22:02 <jmcarthur> man it sure would be awesome if djinn could handle IO (IO (IO a -> IO (IO b -> IO c)) -> IO (IO a -> IO b) -> IO (IO a -> IO c))
07:22:02 <Guest86956> why is my method wrong?
07:22:43 <Lemmih> Guest86956: Traced takes a type argument. You haven't given it one.
07:23:10 <mauke> Guest86956: Traced is not a type
07:23:18 <Guest86956> Yes, but how do I give it an argument? (Until now I have only worked with data types without arguments)
07:23:34 <mauke> Guest86956: like Lemmih did
07:23:34 <Guest86956> (meaning I only created instances with types without an argument)
07:23:36 <Lemmih> Guest86956: Like this: instance Show a => Show (Traced a) where ...
07:24:03 <Guest86956> let's try
07:24:09 <mauke> or like this: instance Show (Traced a) where show _ = "but this is pretty useless"
07:24:29 <jmcarthur> i like deriving Show, myself ;)
07:24:58 <Guest86956> what actually means deriving? Does that mean that the compiler automatically does the work for me? :|?
07:25:05 <mauke> yes
07:25:06 <jmcarthur> pretty much yeah
07:25:19 <Guest86956> that's amazing... how does it do that?
07:25:26 <jmcarthur> it can only do it for certain classes
07:25:31 <mauke> Guest86956: it cheats
07:25:34 <jmcarthur> it's just specially programmed in
07:25:51 <jmcarthur> afaik, at least
07:26:01 <Guest86956> what kind of types can it "derive"?
07:26:06 <Guest86956> show is one I see...
07:26:27 <jmcarthur> let's see... eq, ord, read, show, ix, enum, bounded, ...
07:26:31 <jmcarthur> probably more
07:26:35 <jmcarthur> and even more with extensions
07:26:37 <Guest86956> that's sick..
07:26:39 <jmcarthur> like functor, typeable, etc.
07:27:23 <Guest86956> instance Show a => Show (Traced a) where
07:27:23 <Guest86956>     show (Traced a b) = "Current location" ++ show a ++ " road: " ++ show b
07:27:29 <Guest86956> the compiler says that this is correct
07:27:38 <Guest86956> oops
07:27:39 <Guest86956> wrong
07:27:49 <Guest86956> wait
07:27:58 <Guest86956> why can Show above be capitalized?
07:27:59 <jmcarthur> Guest86956: for the record, it's normally good for show to give a string that is valid haskell code
07:28:06 <mauke> zity: what's your first language?
07:28:15 <jmcarthur> Show is a class. show is a function in that class
07:28:23 <Guest86956> ah I see..
07:28:59 <jmcarthur> Guest86956: for pretty printing you are encouraged to do something separate from Show. Show is normally intended for things like debugging and playing around in ghci and stuff
07:29:17 <Guest86956> yeah I noticed, but I am debugging
07:29:17 <jmcarthur> it's commonly abused, but you really aren't *supposed* to
07:29:40 <Guest86956> I actually created somekind of BFS (breadth first search) thing..
07:29:42 <jmcarthur> it's nice to be able to take the output of Show and paste it directly into ghc to get the term that generated it
07:29:49 <jmcarthur> *ghci
07:30:28 <Guest86956> well I am actually (still) creating somekind of BFS search program
07:30:41 <Twey> There's a proposal for a generic ‘deriving’ extension to allow libraries to add their own ‘deriving’ clauses
07:30:42 <Guest86956> it's kind of working, but I am wondering how I can debug it
07:30:53 <Guest86956> so I used show
07:31:04 <jmcarthur> Twey: via something like the TH API or something?
07:31:13 <Guest86956> is this the correct way to use it?
07:31:43 <Twey> jmcarthur: Type magic, IIRC
07:31:48 <jmcarthur> show is fine for debugging. it's just generally meant to output a valid haskell string. that way you can use the Show instance of one type as part of the Show instance for another and expect the same behavior
07:31:58 <jmcarthur> magic? :o
07:32:03 <Twey> http://www.dreixel.net/research/pdf/gdmh_nocolor.pdf
07:32:10 <jmcarthur> how does one create deriving by magic?
07:32:12 * jmcarthur reads
07:32:19 <Twey> In the ‘sufficiently advanced technology’ class ;)
07:32:54 <Twey> Implemented in UHC, it seems
07:32:55 <Guest86956> thank you jmcarthur
07:33:15 <jmcarthur> Twey: UHC has a lot of cool stuff
07:33:31 <Guest86956> and mauke and Lemmih
07:33:40 <Twey> Aye
07:33:44 <adimit> something that helped me *sometimes* to debug pure code without turning the whole thing to an operation on a state monad is unsafePerformIO $ show stuff. that's very dirty, and shouldn't be left in production code!
07:33:58 <Twey> I only heard of it a little while ago, but it seems to have come quite far
07:33:59 <jmcarthur> i still haven't given it a shot. it just seems to be a fairly innovative compiler
07:34:15 <Twey> Are they aiming to be a real-world compiler like GHC, or just a research project?
07:34:19 <jmcarthur> adimit: Debug.Trace ;)
07:34:35 <adimit> jmcarthur: oh. nice. Didn't know about it.
07:34:37 <jmcarthur> Twey: no idea
07:34:50 <jmcarthur> adimit: it basically does what you just described :)
07:35:07 <dino-> jmcarthur: I use derived Show and Read instances of data types often for a cheap form of serialization.
07:35:09 <adimit> jmcarthur: shoulda thought someone had the same idea as I did a while ago.
07:35:30 <jmcarthur> dino-: i did that once, i have to admit
07:35:39 <jmcarthur> but i prefer not to :)
07:36:00 <dino-> But I stopped implementing my own instances of Show a long time ago.
07:40:56 <ski> zity : if you really think this is too noisy for you, you could join #haskell-overflow, though
07:45:07 <gregor3005> hi
07:45:48 <gregor3005> anybody know how i can zip two lists so i get the following: (0,0),(0,1),(1,0),(1,1) ....
07:45:59 <gregor3005> the input lists are [0..5] and [0..5]
07:46:29 <Lemmih> > liftM (,) [0..4] [0..4]
07:46:33 <lambdabot>   Couldn't match expected type `[t1] -> t'
07:46:33 <lambdabot>         against inferred type `[b ...
07:46:39 <Lemmih> > liftM2 (,) [0..4] [0..4]
07:46:40 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(1,0),(1,1),(1,2),(1,3),(1,4),(2,0),(2,1),(2...
07:47:04 <gregor3005> nice
07:47:40 <zity> Hi
07:47:45 <joe1> ski: do you have a quick minute?
07:47:51 <joe1> please
07:47:55 <ski> hello zity
07:47:57 <zity> i tryed to explain my problem here : http://pastebin.com/csj4BU41
07:48:00 <ski> joe1 : possibly
07:48:09 <adimit> gregor3005: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-List.html#17
07:48:20 <joe1> i posted the code with all your suggested changes here: http://hpaste.org/paste/40777/types_again#p40825
07:48:27 <joe1> please scroll all the way to the bottom.
07:48:28 <gregor3005> thanks for the fast help
07:48:40 <gregor3005> i worked 1 hour to build my own. *lol*
07:49:10 <joe1> i am wondering if you can suggest what I can do next
07:49:18 <adimit> gregor3005: the page I linked contains a lot of generalization over zipping lists. In case you're looking to do something with lists (ever) you should go look at Data.List's documentation.
07:49:19 <joe1> something more advanced than types.
07:49:53 <mauke> zity: what's your question?
07:49:53 <zity> I try to modelise the constraints langage "OCL" into haskell, and verify my "evaluate" fonctions on a model (Bank and clients for example)
07:50:32 <gregor3005> my main goal is to save the coorindate of an matrix and have matrix like [[(bool,(x-coord,y-coord))]]
07:51:26 <adimit> gregor3005: Haskell has a package for working with matrices: hmatrix http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix
07:51:33 <zity> mauke-> i'm trying to make just one example and verify it on a model (for the implication for exemple) 
07:52:51 <zity> For a Bank and clients which have an id for example
07:53:00 <joe1> ski: i think I have removed all the redundancy
07:53:12 * ski is looking at it
07:53:17 <joe1> ski: thanks
07:53:48 <zity> clientA<>clientB<>  Implicate   A.id <> B.id, how can i translate this into haskell ?
07:53:58 <ski>   concatMap msg2actions . map parse  =  concatMap (msg2actions . parse)
07:54:13 <merijn> How do you implement something like a game/server loop in Haskell? I realized most of my difficulties writing non-trivial Haskell result from not knowing the right approach to this problem...
07:54:18 <dreixel> Twey: I think UHC aims to be a research tool on compiler construction
07:54:19 <ski> (i'm not sure which you think is clearer, but the second is a possible way to express the same thing)
07:54:33 <jmcarthur> ha, favorite ghc warning of the day: "dropping loopy given equality"
07:54:38 <dreixel> Twey: and the generics stuff is hopefully coming to GHC as well
07:54:42 <ski> dreixel : like GHC, then ? ;)
07:55:06 <dreixel> ski: I think UHC has no serious attempts to perform fast, for instance
07:55:07 <hpc> merijn: in the case of games, it is usually something like:
07:55:21 <hpc> loop = simulateGame >> renderGame >> loop
07:55:21 <joe1> ski: cool, that is a good idea.
07:55:26 <ski> (or maybe the difference was that GHC is more a research tool on implementing type system extensions, rather per se compiler construction ?)
07:55:53 <Lemmih> zity: I think you have to explain your problem a little bit better.
07:56:09 <adimit> hpc, merijn: I'd rather use loop = forever $ simulateGame >> renderGame
07:56:17 <merijn> hpc: My main problem is multiplexing async IO (be it in a game or something like a daemon)
07:56:18 <mauke> zity: your code is weird and I don't understand your question
07:56:19 <ski> joe1 : btw, a style thing "only", but i find `location :: Location' a lot more readable than `location::Location'
07:56:26 <Twey> dreixel: Ah, I see
07:57:18 <jmcarthur> joe1: you can get a lot of style tips from the hlint tool such as the one that ski just mentioned involving concatMap
07:58:09 <jmcarthur> although it appears not to find that one on hpaste. weird
07:58:12 <jmcarthur> i thought it would
07:58:45 <joe1> ski: ok, thanks
07:59:10 <zity> mauke, it's about doing an interpreter for OCL, OCL have an operator "Implies", i translated it into haskell by saying that "a=>b" is equivalent to "not a OR b", and i have to verify this translation on a model
07:59:17 <Twey> I'd rather use loop = flip catch handler . mfix $ simulateGame >>= liftM2 (>>) renderGame return
07:59:23 <ski> joe1 : and, fwiw, i'd replace `deriving (Show)' with `deriving Show' (and `foo :: (Eq a) => ..a..' by `foo :: Eq a => ..a..', but you have no such thing in the paste there) .. but i think not all people agree with this
07:59:41 <mauke> zity: yeah, but you're using tuples everywhere. why?
07:59:55 <jmcarthur> i prefer ski's style
08:00:05 <mauke> I don't!
08:00:06 <monadic_kid> anyone used the JVM-Bridge?
08:00:11 * ski grins
08:00:16 <zenzike> If I have a function, say f x = g x + g x, does ghc compile this to something like f x = let y = g x in y + y ?
08:00:27 <mauke> zenzike: probably not
08:00:50 <zenzike> mauke: thanks. Do you know where the docs on the evaluation might be found?
08:01:16 * Twey does
08:01:30 <mauke> http://www.haskell.org/haskellwiki/GHC:FAQ#Subexpression_Elimination
08:01:49 <zenzike> thanks!
08:02:16 <zity> mauke>  because there is not just the "implies" operator, i have "forall", "select", "reject" etc... to modelise too, and verify them on a model. But i just want an entire example for "implies", i think that next it will easier for the others operators
08:02:52 <mauke> zity: but your Forall, Select, ... don't use tuples; only Implies does
08:02:56 <mauke> and eval, for some reason
08:04:16 <joe1> ski: I made the changes you recommended: http://hpaste.org/paste/40777/types#p40831
08:04:42 * ski is trying to prepare an annotation to the paste
08:05:11 <zity> mauke what do you mean with tuples ? lists ?
08:05:18 <mauke> zity: no, tuples
08:05:25 <mauke> (a, b)
08:05:26 <joe1> ski: can you think of any library that does something like what I did.. Take a file, read each line into some format and the map each format to an action.. so, just give the file, messageformat and the action and it takes care of everything. 
08:05:37 <joe1> maybe that it takes it to the domain of parsec?
08:06:22 <jmcarthur> sounds a lot like a typical compiler or interpreter :)
08:07:05 <jmcarthur> oh maybe i misunderstood though. i see a couple interpretations now
08:07:14 <zity> mauke, yes i have to use it for implies, (an OCL expression) IMPLIES (an other OCL expression)  , Implies(OCL,OCL) 
08:07:57 <mauke> zity: then why aren't you using it for Forall?
08:08:11 <gregor3005> anybody know how i can make a counter while working with list like: [ x+counter | x <- list ]
08:10:01 <zity> mauke, Forall takes a predicate and a list as arguments (not OCL expressions like implies), and verify the predicate on the list,  i guess
08:10:12 <ManateeLazyCat> gregor3005: Use IORef or TVar build a counter out of list, then update counter in list loop.
08:10:29 <mauke> zity: why doesn't it use tuples?
08:10:31 <gregor3005> ok i try it
08:12:28 <zity> maurer_ i see, the predicate and the list are OCL expressions too, and i have to write Forall(OCL,OCL) too 
08:12:37 <zity> mauke sorry
08:12:46 <mauke> wtf?
08:13:02 <ManateeLazyCat> gregor3005: Something like "counter <- newIORef 0; c <- readIORef counter; x <- list; writeIORef counter (c + 1) return x + c; "
08:13:09 <mauke> this has stopped making any sense
08:13:17 <zity> it's because i'm just working on the "Implies" for the moment
08:14:40 <ManateeLazyCat> gregor3005: Or like below : 
08:14:41 <ManateeLazyCat> test [] _ = []
08:14:41 <ManateeLazyCat> test (x:xs) counter = 
08:14:41 <ManateeLazyCat>   (x + counter : test xs (counter + 1))
08:14:44 <ManateeLazyCat>  
08:14:55 <ManateeLazyCat> gregor3005: Then you do "test list 0" 
08:15:10 <Lemmih> zity: It would help a lot if you asked a simple, concrete question.
08:15:55 <zity> Ok
08:16:15 <ManateeLazyCat> > let test [] _ = []; let test (x:xs) counter = (x + counter : test xs (counter + 1))
08:16:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:16:20 <ski> joe1 : it may take some time for me to process this .. you'll have to decide on which changes you like, after (and ask questions :)
08:16:24 <jmcarthur> gregor3005: so you just want to add the value of the counter to each value of the list in succession?
08:16:29 <merijn> Is there a de facto standard library for async networking? I see there is a select implementation but I'd rather not implement something myself using select if a better solution exists...
08:16:51 <jmcarthur> > zipWith (+) [0..] [4,8,5,2,4,7,9,9,2,34,1,5]  -- gregor3005 
08:16:52 <lambdabot>   [4,9,7,5,8,12,15,16,10,43,11,16]
08:16:54 <hpc> there's threads
08:17:27 <mauke> merijn: there's a select implementation? where?
08:17:40 <ManateeLazyCat> gregor3005: Use jmcarthur's neat solution. :)
08:17:50 <jmcarthur> > [ x + counter | x <- [4,8,5,2,4,7,9,9,2,34,1,5] | counter <- [0..] ]
08:17:52 <lambdabot>   [4,9,7,5,8,12,15,16,10,43,11,16]
08:17:59 <jmcarthur> gregor3005: ^^ that works as well
08:18:21 <merijn> mauke: http://www.haskell.org/ghc/docs/6.4.1/html/hslibs/Select.html
08:18:41 <mauke> merijn: ghc-6.4.1? what
08:18:41 <ski> joe1 : i'm currently wondering why you handle empty lists differently than non-empty ones, in `msg2actions'
08:18:58 <joe1> ski: ok, thanks. btw, before you spend more time, I am also trying to club all the trigger actions into one.
08:19:08 <merijn> mauke: That's just one of the first links I found via google while looking for networking libraries
08:19:19 <mauke> yeah, I don't think it exists
08:19:34 <ski> joe1 : what is "trigger actions", here ?, the ones returned by `msg2actions' ?
08:19:37 <joe1> ski: there is no TriggerinBuffer for empty lists
08:19:57 <merijn> So how the hell are you supposed to do any useful networking in haskell without any decent multiplexing libraries?
08:20:01 <joe1> ski: triggerin tag lineno flags = TriggerinBD tag lineno 0, TriggerinFlags lineno flags
08:20:02 <ski> joe1 : why not ?
08:20:16 <joe1> ski: because there is no data to write to the buffer.
08:20:22 <mauke> merijn: I heard you're supposed to use threads
08:20:36 <ski> can't it be `TriggerinBuffer BD0 lineno []' ?
08:20:50 <merijn> Threads don't really do what I want, though. Unless my thinking is broken...
08:20:50 <ski> or will that not be handled correctly, by what you're talking to ?
08:21:28 <joe1> ski: i think I am wasting too much of your time on this. I am sorry about that. My objective is to learn the process rather than making the best program, if you know what I mean.
08:21:34 <merijn> mauke: That'd mean using 1 thread per connection, if they're native threads that is a disaster...
08:21:38 * ski has no real idea what this program is really supposed to be doing .. just looking over structural things, currently
08:22:11 <mauke> merijn: dude, you can spawn like 600000 threads with no problems
08:22:14 <mauke> threads are free
08:22:29 <merijn> mauke: So they're not native threads, then. More like Erlang's threads
08:22:30 <joe1> ski: yes, ski. I am treating this as an exercise to get to the more complicated things.
08:23:33 <joe1> ski: can't it be `TriggerinBuffer BD0 lineno []', then the TriggerinBuffer should be able to handle the null scenario. Nothing needs to be done for the null scenario in that function.
08:25:05 <ski> joe1 : yeah, i'm just wondering if there's any *need* to handle the empty case specially
08:25:23 <ski> (there might be an efficiency reason for doing it .. but here i'm just wondering about correctness)
08:25:37 <merijn> mauke: Then there's still the design problem I asked earlier, if I want to implement a game server I can understand a central loop like "updateWorld getInput world >>= outputWorld", but if I use threading for the input how would I get the input back together into a single loop?
08:26:02 <joe1> ski: actually, your argument makes sense. I could replace all those empty list matching in msg2actions with one pattern in the triggerinBuffer
08:27:29 <joe1> ski: like this, act (TriggerinBuffer tag lineno []) = return ()
08:28:56 <co_dh> I get the following error message with some gadt code. 
08:28:56 <ManateeLazyCat> > zipWithIndex f xs = zipWith f xs [0..]
08:28:58 <ski> joe1 : ok
08:28:59 <lambdabot>   <no location info>: parse error on input `='
08:29:04 <ManateeLazyCat> > let zipWithIndex f xs = zipWith f xs [0..]
08:29:05 <lambdabot>   not an expression: `let zipWithIndex f xs = zipWith f xs [0..]'
08:29:06 <zity> mauke, jmcarthur,  I tryed to explain more here: http://pastebin.com/H9BERN8D  , is it explained better ?
08:29:13 <co_dh> Couldn't match expected type `a1' against inferred type `Tree a'
08:29:13 <co_dh>       `a1' is a rigid type variable bound by
08:29:15 <merijn> Maybe it's time to go back to Real World Haskell and see if they have any chapters on this
08:29:36 <co_dh> pretty ( Empty      :. Tree a )  = Text "Empty" 
08:30:16 <co_dh> does anybody read the Generic Programming , Now ! and tried the code with ghc ? 
08:31:25 <writer> I just realised perl sucks, hoping something like this will work as if it's in Haskell: join(",",map(chomp,@lines));
08:32:03 <co_dh> http://hpaste.org/40832/gadt_pattern_match
08:32:25 <mauke> writer: chomp(@lines); join ',', @lines
08:32:39 <mauke> writer: use Data::Munge; join ',', mapval { chomp } @lines
08:32:50 <writer> w00t
08:33:24 <writer> thanks mauke, perl sucks like black hole :-)
08:33:32 <ski> joe1 : btw, the commented out lines at the end, "--set TRNIF (bit 3) flag of UIR (0xF62) = 0x08", &c. .. there are two big chunks of those, are those two chunks identical ?
08:33:56 <writer> now I realize why he said, God ostensibly hacked the world in Perl :-)
08:34:09 <ski> actually, that was Lisp
08:34:32 <writer> ski, http://xkcd.com/224/
08:34:44 <writer> s/ostensibly//
08:34:57 <ski> right .. like i said :)
08:35:03 <Jafet> PERL IS LISP
08:35:21 <Entroacceptor> soylent perl?
08:35:24 <mauke> perl = lisp - macros + syntax
08:35:28 <Sina> Hi, I'm back. just a quick question. can multiple "where" be used? like x = y where y = z where z = 2 ?
08:35:49 <Lemmih> zity: No, it isn't.
08:35:56 <ski> Sina : yes
08:36:00 <ski>   x = y
08:36:04 <ski>     where
08:36:07 <ski>     y = z
08:36:11 <ski>       where z = 2
08:36:14 <Sina> > let x = y where y=z where z = 2 in x
08:36:15 <lambdabot>   2
08:36:15 <ski> also
08:36:18 <ski>   x = y
08:36:20 <ski>     where
08:36:21 <mauke> ski: pointless newlines
08:36:22 <ski>     y = z
08:36:24 <ski>     z = 2
08:36:30 <yitz> Sina: I usually try to avoid it though. It usually means there is an idea that warrants a separate function.
08:36:34 <Sina> ski: nice :) 
08:36:58 <ski> Sina : if you don't need to nest (or it is nicer, structurally), then i'd prefer not nesting
08:37:39 <Lemmih> zity: How about reading a Haskell tutorial? Learn You A Haskell and Real World Haskell are both good.
08:38:14 <Sina> I will try to avoid it then. but it might be useful in some cases (when I want to use x which is in where, twice)
08:39:40 <Sina> like here: where x = zip base cipher where base = ['A'..'Z']
08:39:58 <ski> probably you only need a single 'where', there
08:39:59 <mauke> where x = zip base cipher; base = ['A' .. 'Z']
08:40:19 <ManateeLazyCat> I like zipWithIndexM_ :: Monad m => [a] -> (a -> Int -> m c) -> m () zipWithIndexM_ xs f = zipWithM_ f xs [0..], neat solution. :)
08:40:20 <ManateeLazyCat>  
08:40:30 <Sina> wouldn't it require me to define base's type ?
08:41:06 <mauke> no, why?
08:41:35 <Sina> Shouldn't we define the type before writing the function/constant ?
08:41:44 <mauke> not in a 'where' clause
08:41:52 <ski> you are not required to specify the type of `x' either
08:42:19 <ski> in most cases, you don't *need* to write type signatures in Haskell at *all*
08:42:52 <ski> but often it helps document the intended type, and so the reader don't need to infer all the types in the head
08:43:19 <Sina> yes, specially when someone else is going to mark me :)
08:44:16 <Sina> thanks. I will continue working on my project. :)
08:46:46 <theorbtwo> Also, it means that the types of exported things won't change semi-unexpectedly, when the type implied is slightly more genera then the type intended.
08:48:33 <gregor3005> jmcarthur: when i work with your example from above i get the lists doubled  ---> [ x + counter | x <- [4,8,5,2,4,7,9,9,2,34,1,5] | counter <- [0..] ]
08:49:49 <gregor3005> i tested it with a shorter example: [ x + counter | x <- [4,8], counter <- [0..(length[4,8]-1)] ]
08:50:13 <gregor3005> the expected output is [4,9]
08:50:23 <gregor3005> [4+0,8+1]
08:50:43 <jmcarthur> gregor3005: use |, not comma
08:51:05 <jmcarthur> gregor3005: also, no need to get the length. it will stop when the short of the two lists is done
08:51:10 <gregor3005> then i get an syntax error (sry im new in haskell)
08:51:10 <jmcarthur> gregor3005: an infinite list is fine
08:51:25 <jmcarthur> hmm it might actually be an extension...
08:51:31 <jmcarthur> i rarely use list comprehensions
08:51:38 <gregor3005> when i type an infinite liste 0.. it produces infinite output
08:52:23 <jmcarthur> i mean for the counter, not for x
08:52:28 <jmcarthur> also, you have to use |, not comma
08:52:34 <jmcarthur> with a comma it would be infinit
08:52:36 <jmcarthur> ew
08:52:50 <gregor3005> [ x + counter | x <- [4,8] | counter <- [0..] ] ----> ERROR - Syntax error in list comprehension (unexpected `]')
08:53:09 <jmcarthur> what compiler are you using?
08:53:13 <gregor3005> hugs
08:53:15 <jmcarthur> oh
08:53:17 <jmcarthur> yuuck
08:53:35 <jmcarthur> in hugs your only option to do it my way would be to use the zipWith versioni think
08:53:42 <jmcarthur> *version, i think
08:54:09 <jmcarthur> > zipWith (+) [4,8] [0..]
08:54:10 <lambdabot>   [4,9]
08:54:18 <gregor3005> the main goal is to index an [[bool]] matrix with coordinates
08:54:28 <jmcarthur> oh?
08:54:44 <jmcarthur> > zip [0..] [4,8,6,8,5]
08:54:45 <lambdabot>   [(0,4),(1,8),(2,6),(3,8),(4,5)]
08:54:55 <jmcarthur> first component is index, second is element
08:55:09 <jmcarthur> no need for a counter :)
08:55:23 <jmcarthur> that's for the 1D case of course
08:55:35 <jmcarthur> i'm guessing this is homework and you should probably figure out the 2D case yourself ;)
08:55:49 <jmcarthur> but you can use the 1D case as part of your solution
08:56:25 <gregor3005> a little bit more
08:56:26 <jmcarthur> Cale: it's a Cale!
08:56:37 <jmcarthur> Cale: lambdabot is not lambdabot :(
08:56:40 <Cale> Yeah, just checking up on things :)
08:56:42 <Cale> oh, okay
08:56:49 <aristid> but i think Cale is Cale
08:56:53 <gregor3005> i had to build from a [[Bool]] an [[Neighboord has True]]
08:56:58 <Cale> Shall I get rid of the impostor lambdabot?
08:56:59 <gregor3005> +sum
08:57:04 <Cale> Or should someone else?
08:57:17 <jmcarthur> i don't know whose it is
08:57:20 <ski> jmcarthur : Hugs has parallel list comprehensions
08:57:28 <jmcarthur> ski: does it have to be enabled somehow?
08:57:34 <Nibble> > 2*2
08:57:35 <lambdabot>   4
08:57:39 <Nibble> WOOOHO
08:57:42 <Nibble> LAMBDABOT <3
08:57:53 <jmcarthur> Nibble: that one is an imposter but i think Cale will work that out :)
08:57:55 <ski> gregor3005 : you can use `[.. | .. | ..]' in Hugs, but you need to enable the extensions, by passing the flag `-98' to `hugs'
08:57:59 <rinzai> hi everyone
08:58:02 <ski> jmcarthur : yes
08:58:03 <Nibble> (> \x y -> x*y*y*y) 5 3
08:58:09 <Nibble> > (\x y -> x*y*y*y) 5 3
08:58:11 <Saizan> Cale: i'll close it
08:58:20 <jmcarthur> too late
08:58:23 <Saizan> Cale: oh, you did already :)
08:58:27 <rinzai> I'm trying to start a bit of SDL programming in Haskell and stumble upon this error:
08:58:33 <Nibble> (> \x y -> x*y*y*y) 5 3
08:58:34 <jmcarthur> @vixen i missed you!
08:58:37 <Nibble> > (\x y -> x*y*y*y) 5 3
08:58:41 <lambdabot> I'm stroking my hard cock as we speak...
08:58:44 <jmcarthur> ...
08:58:47 <lambdabot>   135
08:58:49 <Nibble> -__-
08:58:50 <ski> @slap lambdabot
08:58:55 <Cale> Man, worst @vixen ever.
08:58:55 <gregor3005> ski: thx for the hint now the above example works
08:58:57 * lambdabot moulds lambdabot into a delicous cookie, and places it in her oven
08:59:05 <Saizan> jmcarthur: she really likes you!
08:59:05 <jmcarthur> i didn't know vixen's vocabulary reached to those depths
08:59:09 <FauxFaux> <3 <3
08:59:10 <rinzai> when calling this: let r = SDL.Rect 100 100 10 10 I get the error "Couldn't match expected type `Maybe Rect'
08:59:10 <rinzai> against inferred type `Rect'"
08:59:14 <joe1> ski: the comments are not identical. I put a new file after merging the trigger statements: http://hpaste.org/paste/40777/types#p40833
08:59:15 <Nibble> lambdabot isn't a real bot?
08:59:19 <Nibble> > 3*3
08:59:27 <lambdabot>   9
08:59:30 <jmcarthur> Nibble: yeah she is
08:59:36 <Nibble> one hell of a delay
08:59:42 <jmcarthur> yeah
08:59:44 <rinzai> how can I correctly assign r?
08:59:45 <Cale> rinzai: How are you using r?
08:59:46 <Twey> Freenode's slow today
08:59:57 <ski> Nibble : possibly just taking time, because it was newly started up
08:59:57 <jmcarthur> i'm not getting lag from freenode
09:00:09 <rinzai> Cale, I'm using it on this call: SDL.fillRect screen r c
09:00:23 <rinzai> screen is the surface, and c is a Color
09:00:35 <Twey> rinzai: fillRect takes a Maybe Rect, not a Rect
09:00:40 <Twey> So you need to say (Just r)
09:00:43 <gju_> a question: i want to generate a (pseudo-)random value. i'm doing it with fst (random gen :: (Integer, StdGen). what type does my function need to have so i can return this value to the caller?
09:00:47 <Cale> rinzai: Right, and fillRect wants a Maybe Rect, not a Rect
09:00:58 <Cale> rinzai: So you want to pass (Just r) to it, not r
09:01:06 <rinzai> Twey, Cale : thank you!
09:01:27 <yitz> Cale, can you be in touch with whomever necessary? There has to be some limit to the level of \bot's offensiveness. This is a family channel, you know.
09:01:37 <olsner> I wonder if the ghc llvm backend can be convinced to output llvm bytecode instead of assembly, and do the llvm optimization/codegen at link time
09:01:40 <rinzai> I was trying to pass Just on the r assignment [let c = Just SDL.Rect...] -____-
09:01:49 <Cale> yitz: I could maybe just unplug the @vixen plugin.
09:01:51 <rinzai> thanks again
09:01:58 * jmcarthur manually converts some lambda terms to SKI
09:02:00 <yitz> Cale: that would be a shame
09:02:02 <mauke> @seen
09:02:02 <preflex>  what
09:02:02 <lambdabot> Unknown command, try @list
09:02:03 <jmcarthur> yay for quadratic blowup
09:02:20 <Cale> rinzai: You could define  r = Just (Rect ...)
09:02:54 * ski automatically converts some pi terms to JMCARTHUR
09:03:06 <yitz> Cale: add a wrapper to the socket layer that converts certain strings to *beep*
09:03:11 <Cale> gju_: Note that the StdGen you get back from random is valuable if you're going to generate more than a single pseudorandom number.
09:03:16 <rinzai> Cale, kk, thanks. I was obviously doing something wrong. when I tried to assign r = Just (Rect...) I got Couldn't match expected type `t1 -> t2 -> t3 -> t4 -> t'
09:03:16 <rinzai>            against inferred type `Maybe (Int -> Int -> Int -> Int -> Rect)'
09:03:44 <rinzai> Cale, anyway, works fine now!
09:03:50 <Cale> rinzai: That looks like you wrote Just Rect, rather than applying Just to the constructed rectangle
09:04:08 <Cale> Just Rect 10 10 10 10 -- this will be a type error
09:04:17 <Cale> Just (Rect 10 10 10 10) -- this is okay
09:04:23 <rinzai> -____- time to hit the haskell books some more time... ;-P
09:04:27 <gju_> Cale: mh, i get the generator by doing gen <- getStdGen, so that should be fine i guess.
09:04:33 <Cale> gju_: okay
09:04:34 <rinzai> thanks for your help
09:04:39 <sipa1024> @vixen are you back?
09:04:39 <lambdabot> i truely am
09:04:47 <sipa1024> @vixen how long were you gone?
09:04:47 <lambdabot> not too long
09:04:53 <sipa1024> yes too long!
09:04:58 <Cale> gju_: If you're only in need of the one random value, you might as well just use  randomIO or randomRIO
09:05:08 <aristid> @vixen how dare you say "not too long"? it WAS too long.
09:05:08 <lambdabot> very long
09:05:18 <aristid> @vixen yes, very long
09:05:18 <lambdabot> you agree?
09:05:27 <aristid> @vixen i'm glad we both agree
09:05:27 <lambdabot> are you?
09:05:32 <aristid> @vixen yes.
09:05:32 <lambdabot> that's what i figured
09:05:34 <sipa1024> @vixen we all are
09:05:35 <lambdabot> ok...
09:06:19 <mauke> Cale: could you apply http://mauke.ath.cx/tmp/disable-seen.patch http://mauke.ath.cx/tmp/admin-mauke.patch to lambdabot?
09:10:49 <gju_> Cale: randomIO does only create random integers?
09:18:23 <yitz> @vixen there is a middle ground between boring and obscene
09:18:24 <lambdabot> Uh-huh
09:21:59 <ski> joe1 : why `concat [setup_stat," ",(++) "0" . show $ count]' instead of `concat [setup_stat," ","0",show count]' ?
09:22:33 <ski> or even s/" ","0"/" 0"/
09:23:59 <Sina> guys, which one is more efficient: take-ing n elements from a lost and then drop-ing the last bit and then appending OR doing splitat and appending the splits?
09:25:03 <ski> > let s = "abcdefgh" in take 3 s ++ drop 5 s  -- do you mean like this ?
09:25:03 <lambdabot>   "abcfgh"
09:25:04 <Sina> from a list*
09:25:41 * hackagebot cpython 3.1.2.0 - Bindings for libpython  http://hackage.haskell.org/package/cpython-3.1.2.0 (JohnMillikin)
09:26:02 <Sina> I mean like this [1,2,3,4,5], a function to get 2, and do this: [4,5,1,2,3] . or if given 1, do this: [5,1,2,3,4]
09:26:18 <ski> oh, rotate a list
09:26:22 <ski> i'd use `splitAt'
09:26:56 <Sina> Is there any way more efficient? than splitat or take/drop
09:26:59 <mm_freak_> i'd not do that at all, but use Seq instead in all applications i can think of right now
09:28:14 <jmcarthur> for some applications even a cyclic list could be appropriate
09:28:36 <mm_freak_> true
09:28:50 <mm_freak_> > take 5 . drop 2 $ cycle [1..5]
09:28:51 <lambdabot>   [3,4,5,1,2]
09:28:52 <jmcarthur> although for that operation specifically i think Seq would be better
09:29:21 <Sina> what does cycle do?
09:29:27 <mm_freak_> > cycle "abc"
09:29:27 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
09:29:32 <Sina> and what is Seq ?
09:29:36 <jmcarthur> but if the take part is actually not necessary and drop will be used often then it could save some work
09:29:57 <jmcarthur> Sina: for Seq, check Data.Sequence
09:29:59 <Sina> I am not able to use cycle, Seq, $, etc. only basic functions :)
09:29:59 <mm_freak_> yeah, mostly when i do such a thing, i don't need the 'take'
09:30:03 <stepkut> the haddock documentation says that if I give a fully qualitified identifier name like, 'Control.Monad.Trans.liftIO', it will generate a hyperlink even if Control.Monad.Trans is not imported. But it does not work for me. Am I doing it wrong, or is haddock broken/documentation wrong ?
09:30:12 <mm_freak_> Sina: you are able to learn ;)
09:30:15 <joe1> i am trying to do or in patternmatching. is that possible? let test (1|2) = 3
09:30:28 <jmcarthur> if you drop a lot at a time though then that O(n) factor would hurt compared to Seq anyway
09:30:31 <joe1> ski: thanks, did that.
09:30:47 <jmcarthur> cycle is a pretty basic function
09:30:52 <jmcarthur> it's in Prelude
09:30:53 <mm_freak_> stepkut: the haddock documentation needs to be installed for the specific package, which is often not the case, when installing packages through your distribution
09:30:54 <ski> joe1 : unfortunately, Haskell doesn't have disjunctive patterns
09:31:10 <Sina> mm_freak_ yeah, I love to learn. its just that I'm doing this for an assignment. not for personal fun. otherwise I would do it the hardest possible way :D
09:31:19 <jmcarthur> @src cycle
09:31:19 <lambdabot> cycle [] = undefined
09:31:19 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
09:31:22 <ski> (i only know of O'Caml and SML/NJ having it)
09:31:30 <mm_freak_> Sina: we're giving you pointers to simple ways
09:31:37 <stepkut> mm_freak_: in my use case, the module I am trying to link to is in the same library that I am haddocking, it is just not imported..
09:31:50 <mm_freak_> Seq is not a lot different from list, but has much more efficient operations for many things
09:31:58 <joe1> ski: thanks.
09:32:09 <jmcarthur> i would never intentionally do things the hardest possible way, especially if i'm trying to learn ;)
09:32:22 <Sina> mm_freak_ we have limitations on what we can use.
09:32:28 <stepkut> mm_freak_: the doc also seems to claim that it just generates the link with out checking to see if it is actually valid?
09:32:29 <mm_freak_> jmcarthur: sometimes performance is the reason
09:32:41 <mm_freak_> Sina: if you need to use lists, the cycle method is pretty straightforward
09:32:43 <jmcarthur> mm_freak_: but then it's not the hardest possible way to reach your goals
09:32:51 <jmcarthur> where your goals includes performance
09:33:04 <mm_freak_> Sina: take the infinite cyclic list and cut your sublist out of it using 'take' and 'drop'
09:33:15 <mm_freak_> jmcarthur: true
09:33:21 <Sina> jmcarthur: not the hardest possible way. but sometimes you know how to do something silly, but making it in a neat way requires learning and takes time.
09:33:31 <mm_freak_> stepkut: i think haddock never generates invalid links
09:33:49 <mm_freak_> stepkut: unless you deinstall a package along with its documentation without updating your haddock docs, that is
09:33:50 <ski> joe1 : btw, if the grouping of several actions on one line in `msg2action' significant ? or can i break the lines ?
09:33:50 <jmcarthur> Sina: "neat" and "good" don't really mean the same thing though ;)
09:34:10 <jmcarthur> we were suggesting (IMO) "good" ways
09:34:15 <monochrom> the hardest ways are overrated
09:34:26 <jmcarthur> regardless, i understand that you are artificially limited by the assignment
09:34:37 <jmcarthur> i always hated that at uni
09:34:44 <stepkut> mm_freak_: well the docs say, "It is also possible to refer to entities that are not in scope in the current module, by giving the full qualified name of the entity. If M.T is not otherwise in scope, then Haddock will simply emit a link pointing to the entity T exported from module M (without checking to see whether either M or M.T exist)."
09:34:55 <Sina> mm_freak_: I cannot use cycle as I am not supposed to know it.
09:34:56 <mm_freak_> > let rotateL n xs = take (length xs) . drop n . cycle in rotateL 3 "abcdefg"
09:34:57 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
09:34:57 <lambdabot>    arising from a use ...
09:35:04 <jmcarthur> Sina: you could write your own then
09:35:06 <monochrom> however, do find out several ways because they will all be useful later
09:35:06 <mm_freak_> > let rotateL n xs = take (length xs) . drop n . cycle $ xs in rotateL 3 "abcdefg"
09:35:07 <jmcarthur> @src cycle
09:35:07 <lambdabot> cycle [] = undefined
09:35:07 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
09:35:07 <lambdabot>   "defgabc"
09:35:09 <jmcarthur> :P
09:35:19 <joe1> ski: i am breaking up the Message datatype.
09:35:27 <mm_freak_> Sina: well, you could define it
09:35:39 <mm_freak_> Sina: cycle is a very simple function, see its source code above
09:35:43 <joe1> is there a way to pattern match on data with record syntax as : testadata4 adata@(Adata {model = "junk"}) = putStrLn $ model adata
09:35:51 <monochrom> oh, lambdabot is back
09:35:56 <jmcarthur> joe1: that's pretty much it
09:36:14 <joe1> the record Adata could have a long list of attributes and I do not want to list them all in the patternmatching function.
09:36:15 <mm_freak_> stepkut: ah ok, i didn't know that
09:36:23 <Sina> what does @ do ?:D
09:36:25 <jmcarthur> joe1: you're still good
09:36:36 <alpounet> Sina, it gives a name to what's at its right
09:36:55 <jmcarthur> > let foo a@(x:xs) = (a, x, xs) in foo [1,2,3] -- Sina 
09:36:56 <lambdabot>   ([1,2,3],1,[2,3])
09:37:13 <joe1> cool, that worked.. had an overloaded function and ghci was complaining about that..
09:37:23 <Sina> mm_freak_ does cycle do lots of appends? that is something our lecturer hates :)
09:37:36 <jmcarthur> Sina: your other proposed solution will append just as much
09:37:41 <mm_freak_> Sina: infinitely many in fact =)
09:37:46 <lysgaard> Is there any way do do runtime debugging in haskell, like some sort of breakpoint. I know it makes less sense since haskell is functional.
09:37:52 <mm_freak_> Sina: but your approach won't append less
09:37:56 <mm_freak_> Sina: remember that haskell is lazy
09:38:05 <stepkut> mm_freak_: but it doesn't actually seem to work :)
09:38:06 <dschoepe> lysgaard: ghci has some debugging features
09:38:25 <hpc> lysgaard: it is generally done the old fashioned way
09:38:32 <lysgaard> dschoepe: Oh, it has?! Cool where's documentation or some tuts?
09:38:33 <hpc> @hoogle trace
09:38:34 <lambdabot> Debug.Trace trace :: String -> a -> a
09:38:34 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
09:38:34 <lambdabot> module Debug.Trace
09:38:37 <Sina> jmcarthur: does splitat do any appends?
09:38:50 <mm_freak_> Sina: (++) is just a convenient wrapper around multiple (:)
09:38:53 <jmcarthur> Sina: no, but you were appending in your version manually
09:38:54 <dschoepe> lysgaard: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/ghci-debugger.html
09:39:06 <mm_freak_> @src (++)
09:39:06 <lambdabot> []     ++ ys = ys
09:39:06 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
09:39:06 <lambdabot> -- OR
09:39:06 <lambdabot> xs ++ ys = foldr (:) ys xs
09:39:16 <jmcarthur> Sina: if you are able to avoid "take"ing from the result then cycle can perform fewer appends due to the beauty of knot tying, which perhaps we should avoid talking about right now
09:39:38 <jmcarthur> Sina: that is, instead of actually rotating, you could just read from the front of the list and drop every once in a while
09:39:45 <Sina> jmcarthur: thanks for "@" :)
09:39:46 <yitz> lysgaard: you can get started with just :help at the ghci prompt though
09:39:58 <lysgaard> hpc: Do one use the trace function like this? #trace "now it's gonna crash" crashFunction
09:39:58 <stepkut> argh, I wish tracs used openid, I can never remember my login
09:40:19 <hpc> lysgaard: essentially
09:40:46 <hpc> iirc, trace statements go to stderr
09:40:57 <Sina> mm_freak_ so basically ++ performs : as many times needed. thats why its inefficient :)
09:40:59 <hpc> so you could use bash-fu to log the traces
09:41:19 <mm_freak_> > let rotates = zipWith (++) <$> inits <*> tails in rotates "abcde"
09:41:20 <lambdabot>   ["abcde","abcde","abcde","abcde","abcde","abcde"]
09:41:24 <mm_freak_> uhm
09:41:30 <mm_freak_> > let rotates = zipWith (flip (++)) <$> inits <*> tails in rotates "abcde"
09:41:31 <lambdabot>   ["abcde","bcdea","cdeab","deabc","eabcd","abcde"]
09:41:33 <jmcarthur> my cat is trying to attack a leaf outside the window. it is of course failing
09:41:41 <jmcarthur> oh sorry that was meant for -blah
09:41:51 <joe1> ski: is there an alternative to disjunctive patterns: something such as: getdir (Setup) =  getdir (Out) =  Host2Device
09:41:52 <lysgaard> yitz: I'll take a look.
09:42:00 <lysgaard> dschoepe: Thanks
09:42:01 <mm_freak_> Sina: it's not inefficient, it's as efficient as a list implementation of (++) can get ;)
09:42:04 <Sina> hpc: what is bash-fu ?
09:42:07 <joe1> or do I have to list them as 2 different functions?
09:42:16 <mm_freak_> if you want faster (or even O(1)) (++), then you need a different data structure
09:42:18 <hpc> Sina: bash = a linux shell
09:42:31 <joe1> > f x = f y = 2
09:42:32 <lambdabot>   <no location info>: parse error on input `='
09:42:48 <joe1> how can I represent f (x|y) = 2
09:42:50 <hpc> Sina: bash-fu is sort of a joke, meaning do some clever trick in it
09:43:00 <ski> joe1 : not really :/ .. the best you can do is factor the right-hand-sides
09:43:20 <mm_freak_> > let rotates xs = take (length xs) . iterate tail . cycle $ xs in rotates "abcde"
09:43:21 <lambdabot>   ["abcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabc...
09:43:51 <mm_freak_> > let rotates xs = let l = length xs in take l . map (drop l) . iterate tail . cycle $ xs in rotates "abcde"
09:43:52 <lambdabot>   ["abcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabc...
09:43:57 <mm_freak_> uhm
09:44:00 <hpc> move cycle
09:44:01 <aristid> >  let rotates xs = take (length xs) . iterate tail . cycle $ xs in map (take 10) $ rotates "abcde"
09:44:02 <lambdabot>   ["abcdeabcde","bcdeabcdea","cdeabcdeab","deabcdeabc","eabcdeabcd"]
09:44:02 <mm_freak_> d'oh
09:44:04 <Sina> hpc: Is is possible to trace what the interpreter does in haskell?
09:44:08 <hpc> or that
09:44:15 <mm_freak_> > let rotates xs = let l = length xs in take l . map (take l) . iterate tail . cycle $ xs in rotates "abcde"
09:44:16 <lambdabot>   ["abcde","bcdea","cdeab","deabc","eabcd"]
09:44:21 <mm_freak_> there you go =)
09:44:31 <hpc> Sina: just use trace
09:44:35 <aristid> mm_freak_: nice.
09:44:37 <mm_freak_> but the applicative version is better, because it doesn't need 'length'
09:44:47 <mm_freak_> > let rotates = zipWith (flip (++)) <$> inits <*> tails in rotates "abcde"
09:44:48 <lambdabot>   ["abcde","bcdea","cdeab","deabc","eabcd","abcde"]
09:44:53 <Jonny> Hi
09:44:57 <Sina> hpc: how?
09:45:02 <aristid> :t tails . cycle
09:45:03 <lambdabot> forall a. [a] -> [[a]]
09:45:07 <hpc> @hoogle trace
09:45:08 <lambdabot> Debug.Trace trace :: String -> a -> a
09:45:08 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
09:45:08 <lambdabot> module Debug.Trace
09:45:09 <mm_freak_> though you'll probably want to add an 'init' there
09:45:11 <aristid> :t \n -> map (take n) . tails . cycle
09:45:12 <lambdabot> forall a. Int -> [a] -> [[a]]
09:45:19 <Jonny> Please could somebody help with a small error... In this function http://pastebin.com/27u9ycV5
09:45:20 <hpc> use the type signature, luke
09:45:20 <lysgaard> Hehe, now i need to learn that strange ghci debugging output.
09:45:31 <Jonny> i receive a type error
09:45:46 * hackagebot gmndl 0.2 - Mandelbrot Set explorer using GTK  http://hackage.haskell.org/package/gmndl-0.2 (ClaudeHeilandAllen)
09:45:49 <ClaudiusMaximus> pastorn: ^^^ with more comments inside for you
09:45:57 <aristid> > (\n -> map (take n) . tails . cycle) 3 "abc"
09:45:58 <lambdabot>   ["abc","bca","cab","abc","bca","cab","abc","bca","cab","abc","bca","cab","a...
09:46:00 <Sina> hpc: do I need to import Debug.Trace ?
09:46:03 <Jonny> *** Expression     : (x : right xs) a
09:46:03 <Jonny> *** Term           : (:)
09:46:03 <Jonny> *** Type           : e -> [e] -> [e]
09:46:03 <Jonny> *** Does not match : a -> b -> c -> d
09:46:04 <hpc> yes
09:46:11 <aristid> > (\n -> take n . map (take n) . tails . cycle) 3 "abc"
09:46:12 <lambdabot>   ["abc","bca","cab"]
09:46:16 <monochrom> x : (right xs a)
09:46:22 <Lemmih> Jonny: right (x : xs) a = x : right xs a
09:46:33 <aristid> @pl \x -> (\n -> take n . map (take n) . tails . cycle) (length x) x
09:46:33 <lambdabot> liftM2 (.) take ((. (tails . cycle)) . map . take) =<< length
09:46:35 <Jonny> oh i see
09:46:36 <Jonny> cheers
09:46:44 <mm_freak_> aristid: that still relies on the length
09:46:52 <aristid> mm_freak_: ya
09:47:06 <mm_freak_> > let rotates = zipWith (flip (++)) <$> inits <*> tails in rotates [0..]
09:47:07 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
09:47:21 <aristid> > let rotates = zipWith (flip (++)) <$> inits <*> tails in rotates [0..5]
09:47:22 <mm_freak_> > let rotates = zipWith (flip (++)) <$> inits <*> tails in map (take 3) $ rotates [0..]
09:47:22 <lambdabot>   [[0,1,2,3,4,5],[1,2,3,4,5,0],[2,3,4,5,0,1],[3,4,5,0,1,2],[4,5,0,1,2,3],[5,0...
09:47:23 <lambdabot>   [[0,1,2],[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[...
09:47:35 <joe1> can I have something like this: data Direction = Host2Device | Device2Host | Nothing deriving Show
09:47:37 <aristid> mm_freak_: that still does not stop at the end :)
09:47:43 <aristid> joe1: yes.
09:47:50 <joe1> aristid: thanks.
09:47:55 <stepkut> mm_freak_: looks like it is a bug, http://trac.haskell.org/haddock/ticket/78
09:47:59 <mm_freak_> aristid: add an 'init', if you want to get rid of the extra element
09:48:18 <mm_freak_> > let rotates = zipWith (flip (++)) <$> inits <*> tails in map (take 3) $ init (rotates "abcde")
09:48:19 <lambdabot>   ["abc","bcd","cde","dea","eab"]
09:48:32 <mm_freak_> uhm, wrong
09:48:34 <Sina> I'll go to finish my code:) thanks guys :)
09:48:37 <mm_freak_> > let rotates = zipWith (flip (++)) <$> inits <*> tails in init (rotates "abcde")
09:48:38 <lambdabot>   ["abcde","bcdea","cdeab","deabc","eabcd"]
09:48:45 <mm_freak_> there you go
09:48:53 <mm_freak_> Sina: have fun
09:49:34 <mm_freak_> (we just can't stop arrowing, applicating and monaddering)
09:50:14 <Sina> mm_freak_ is there any way to reverse items in a tuple?
09:50:29 <mm_freak_> > (\(x,y) -> (y,x)) (2,3)
09:50:30 <lambdabot>   (3,2)
09:50:31 <hpc> @hoogle (a, b) -> (b, a)
09:50:31 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
09:50:31 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
09:50:31 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
09:50:42 <hpc> or that
09:50:58 <Sina> mm_freak_ thanks :)
09:51:10 <mm_freak_> Sina: you should try doing such simple things yourself =)
09:51:16 <Sina> hpc: I have no clue about monads :)
09:51:17 <yitz> there was a proposal to add a function to Data.Tuple for that. It seemed to be accepted, but the submitter didn't follow through and get it added.
09:51:18 <mm_freak_> swap (x,y) = (y,x)
09:51:33 <hpc> Sina: i expected something easier to pop up ;)
09:51:38 <Sina> mm_freak_ I thought there is a built in function like reverse for it :)
09:51:52 <mm_freak_> Sina: no monads involved there
09:52:05 <mm_freak_> or at least you don't get into touch with them directly =)
09:52:35 <Sina> Ok, I'm going back to work. thanks :)
09:52:36 <mm_freak_> Sina: that function is so easy to write and probably so seldomly needed that it didn't make it into the base library
09:53:26 <mm_freak_> :t uncurry (flip (,))
09:53:26 <lambdabot> forall b a. (a, b) -> (b, a)
09:54:32 <yitz> > let rotates xs = takeLike xs . map (takeLike xs) $ tails xs; takeLike (x:xs) (y:ys) = y : takeLike xs ys; takeLike xs ys = xs ++ ys in rotates "abcde"
09:54:33 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
09:55:14 <sbrg> :t takeLike
09:55:15 <lambdabot> Not in scope: `takeLike'
09:55:23 <sbrg> oh, duh
09:55:34 <yitz> sbrg: should be [a] -> [b] -> [b]
09:55:50 <ski> @type snd &&& fst
09:55:51 <lambdabot> forall a c. (a, c) -> (c, a)
09:55:58 <sbrg> yitz: I just didn't see you define it and thought it was some standard function I had missed entirely
09:56:06 <sbrg> :t (&&&)
09:56:07 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:56:24 <ski>   (&&&) :: (x -> a) -> (x -> b) -> (x -> (a,b)) -- here
09:56:56 <hpc> here, x = (b, a)
09:57:03 <yitz> > let rotates xs = takeLike xs . map (takeLike xs) . tails $ cycle xs; takeLike (x:xs) (y:ys) = y : takeLike xs ys; takeLike xs ys = xs ++ ys in rotates "abcde"
09:57:04 <lambdabot>   <no location info>: lexical error at character '\GS'
09:57:12 <YoY> Hello all
09:57:21 <yitz> grr colloquy
09:57:52 <ski> @type (&&&) `asTypeIn` \(&&&) -> snd &&& fst
09:57:52 <lambdabot> forall c c'. ((c', c) -> c) -> ((c', c) -> c') -> (c', c) -> (c, c')
09:58:21 <yitz> > let rotates xs = takeLike xs . map (takeLike xs) . tails $ cycle xs; takeLike (x:xs)(y:ys) = y : takeLike xs ys; takeLike xs ys = xs ++ ys in rotates "abcde"
09:58:22 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
09:59:10 <yitz> > let rotates :: [a] -> [[a]]; rotates xs = takeLike xs . map (takeLike xs) . tails $ cycle xs; takeLike (x:xs)(y:ys) = y : takeLike xs ys; takeLike xs ys = xs ++ ys in rotates "abcde"
09:59:11 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:59:12 <YoY> Hello ? is there anyone ? may i have some help if it is possible thanks in advance .
09:59:21 <ski> hello YoY
09:59:28 <Azrael-> nobody exists, YoY 
09:59:40 <YoY> all bots ?
09:59:55 <ski> yeah, you're also a bot, you just don't know it yet :)
09:59:56 <yitz> @vixen are we all bots?
09:59:56 <lambdabot> i'll hafta plead the fifth on that one.
09:59:59 <lambdabot> I'm not a bot.
10:00:21 <Azrael-> i'm not a bot but i don't pass the turing test
10:00:22 <Azrael-> sorry
10:00:25 <YoY> ok, then my question is about xmonad.
10:00:34 <yitz> #xmonad
10:01:10 <YoY> ok in freenode ? irc.freenode?
10:01:17 <yitz> YoY: yep right here
10:01:18 <ski> yeah
10:01:29 <yitz> YoY: /join #xmonad
10:01:33 <alpounet> @type asTypeIn
10:01:34 <lambdabot> forall a b. a -> (a -> b) -> a
10:02:01 <ski> @type id `asTypeIn` \id -> id False
10:02:02 <lambdabot> Bool -> Bool
10:02:03 <yitz> YoY: it even has its own lambdabot :)
10:02:14 <YoY> ok my appologies i will for sure come here when i'll learn more about haskell . thanks again
10:02:18 <ski> alpounet : it's just a nice trick i invented ..
10:02:31 <yitz> YoY: great, we'll be looking for ya :)
10:03:13 <alpounet> nice indeed ski 
10:03:14 <Cale> YoY: Don't be afraid to ask any questions you might have here.
10:03:27 <Cale> (beginner questions are welcome)
10:03:53 <yitz> quick someone go answer YoY in #xmonad
10:04:31 <joe1> data Direction = Host2Device | Device2Host deriving Show
10:04:33 <joe1> data Message = Message {dir:: Just Direction, linenum :: Int,
10:04:52 <joe1> i cannot get the class constructor of "Just Direction" to work.
10:05:09 <joe1> I want  data Direction = Host2Device | Device2Host | Nothing deriving Show
10:05:16 <Botje> joe1: Just a isn't a type
10:05:19 <Botje> Maybe a is.
10:05:31 <joe1> Botje: gotcha.. faceslap.
10:07:55 <yitz> > let rotates :: [a] -> [[a]]; rotates xs = takeLike xs . map (takeLike xs) . tails $ cycle xs; takeLike (x:xs)(y:ys) = y : takeLike xs ys; takeLike [] ys = ys; takeLike _ _ = [] in rotates "abcde"
10:07:56 <lambdabot>   ["abcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabc...
10:08:46 <ski> joe1 : <http://hpaste.org/paste/40777/a_few_changes#p40834>
10:08:46 <yitz> > let takeLike (x:xs)(y:ys) = y : takeLike xs ys; takeLike [] ys = ys; takeLike _ _ = [] in takeLike "xy" "abcde"
10:08:47 <lambdabot>   "abcde"
10:09:30 <yitz> > let rotates xs = takeLike xs . map (takeLike xs) . tails $ cycle xs; takeLike (x:xs)(y:ys) = y : takeLike xs ys; takeLike _ _ = [] in rotates "abcde"
10:09:31 <lambdabot>   ["abcde","bcdea","cdeab","deabc","eabcd"]
10:09:36 <yitz> yay
10:10:14 <joe1> ski: http://hpaste.org/paste/40777/type#p40835
10:10:46 <joe1> ski: thanks for your changes. I made some changes above too. I will check your changes. Thanks a lot for your time.
10:11:51 <ski> joe1 : there's many things i don't really understand in your code, so i can't really touch it
10:12:35 <ski> joe1 : style changes i have made is : using camelCase more consistently (haven't done this throughout, yet)
10:12:46 <Sina> sorry for asking questions again. if I have a data type that is: data x = Valid [(Char,Char)] , and in a function I am expecting it, what should I do?
10:13:13 <Sina> I mean should I say, function Valid x = ... ?
10:13:25 <ski> joe1 : max 80 character lines (possibly you don't care for this, but i find long lines are often harder to read, and i often want to show several files beside each other)
10:13:29 <hpc> foo (Valid x) = x
10:13:41 <hpc> foo :: X -> [(Char, Char)]
10:13:54 <Sina> hpc: so it should be in brackets?
10:14:01 <hpc> yeah
10:14:10 <joe1> ski: i think even the gnu indentation style is 80 chars
10:14:17 <hpc> otherwise it sees foo as taking one parameter, Valid, and another parameter, x
10:14:42 <hpc> ahaha, gnu coding style :P
10:14:46 <yitz> takeLike is a better version of take . length
10:15:19 <Sina> hpc: it is not letting me to do function (Valid (h:t)) ... what should I do ? :(
10:15:33 <hpc> pastebin it
10:15:37 <hpc> that pattern looks valid
10:15:50 <ski> joe1 : i have also divided your code in pages (using the form feed character, looks like `^L' in emacs, enter by `C-q C-l', you can navigate backward and forward by `C-x [' and `C-x ]' and count the number of lines on the current page by `C-x l') .. if you don't care for this, just remove them again
10:16:25 <joe1> ski: ok.
10:17:12 <Sina> hpc: http://pastebin.com/BMr2qpVD
10:18:14 * ski tries to follow the non-Lisp-specific parts of <http://mumble.net/~campbell/scheme/style.txt>, mostly .. (see "Riastradh's Non-Standard Rules")
10:19:05 <Sina> hpc: I guess I found the problem :D
10:19:08 <hpc> Sina: i am getting problems with the deriving clause
10:19:35 <hpc> ah, yay
10:20:34 <Sina> hpc: not yet. seems the encode' thing has problems all over it
10:20:47 <Sina> hpc: whats wrong with the deriving clause?
10:20:58 <hpc> nothing; i just suck at copy paste
10:21:14 <hpc> http://pastebin.com/5RqkTnze
10:21:17 <hpc> compiles for me
10:21:29 <hpc> you were using (Char, Char) like it was Char, in one place
10:21:40 <hpc> and using [(Char, Char)] like it was Cipher in another
10:21:53 <hpc> also, snd needed a parameter
10:23:22 <Sina> hpc: oh, the problem is somewhere else in the code :(
10:28:12 <Sina> hpc: you see any problem in this? http://pastebin.com/AEwf1pCh
10:28:53 <hpc> sorry, i am getting sidetracked with launching a webserver
10:28:56 <hpc> bbl
10:34:01 <Sina> Can anyone see anything wrong in this? (\(Valid ci) -> ci) validateCipher cipher
10:34:17 <Sina> validateCipher cipher returns something like this: Valid [tuples]
10:34:28 <mauke> your expression doesn't contain validateCipher cipher
10:34:55 <Sina> muake: what do you mean?
10:35:11 <mauke> ((...) validateCipher) cipher
10:35:22 <Lemmih> Sina: (validateCipher cipher).
10:37:14 <Sina> done. cheers.
10:42:02 <ski> Sina : maybe you can write that nicer, by writing an extraction function, or something else (depending on context)
10:42:49 <gregor3005> i need some short help how to convert int to integer
10:42:54 <gregor3005> i found only fromIntegral
10:43:08 <gregor3005> to convert from integer to int
10:43:10 <ski> @type fromIntegral :: Int -> Integer
10:43:11 <lambdabot> Int -> Integer
10:43:16 <ski> @type fromIntegral :: Integer -> Int
10:43:17 <lambdabot> Integer -> Int
10:43:23 <ski> it can be used in both directions
10:43:28 <gregor3005> ok
10:43:41 <gregor3005> nice
10:43:51 <ski> > fromIntegral (fromIntegral (maxBound :: Int) + 1 :: Integer) :: Int
10:43:52 <lambdabot>   -9223372036854775808
10:44:19 <Sina> ski: what do you mean by extraction function? I am still kinda stuck with my code. :(
10:44:32 <ski> if you convert `Integer's which are outside `minBound' and `maxBound' for `Int', though, you will get strange results
10:44:44 <ski> > [minBound,maxBound] :: [Int]
10:44:44 <lambdabot>   [-9223372036854775808,9223372036854775807]
10:45:32 <ski> Sina : i just mean a function `cipherMap :: Cipher -> [(Char,Char)]; cipherMap (Valid cipher) = cipher'
10:45:50 <ski> then you could say `cipherMap (validateCipher cipher)' above
10:46:25 <ski> (at least if `validateCipher' returns a `Cipher' .. istr you had it returning `Maybe Cipher', last i saw)
10:46:54 <Sina> ski: thats a good idea which I also thought about. however I am stuck with the splitAt part it seems. I need to make it work before enhancing it :)
10:47:08 <ski> you want to use 'splitAt' for what ?
10:47:10 <burp> > (minBound :: Int) * (-1)
10:47:10 <lambdabot>   -9223372036854775808
10:47:43 <Sina> ski: to put the cipher on an offset
10:47:53 <ski> to rotate a list ?
10:48:18 <Sina> ski: yes. exactly
10:48:33 <ski> what is your current code ?
10:49:20 <Sina> ski: I guess I need to use type instead of data. I have to change the whole thing as what I've done so far makes no sense :D will be back in few minutes :)
10:49:39 <ski> why do you want to use `type' now ?
10:49:55 * ski thought Sina was required to use `data' by the assignment
10:50:25 <aristid> :t (==) <*> negate
10:50:26 <lambdabot> forall a. (Num a) => a -> Bool
10:50:34 <Sina> ski: I thought so, but with data, I am stuck with that Valid thing forever :)
10:50:36 <aristid> :t ((==) <*> negate) (minBound :: Int)
10:50:37 <lambdabot> Bool
10:50:39 <aristid> > ((==) <*> negate) (minBound :: Int)
10:50:40 <lambdabot>   True
10:50:44 <aristid> > ((==) <*> negate) (maxBound :: Int)
10:50:45 <lambdabot>   False
10:50:54 <ski> Sina : it is not very hard to use `Valid'
10:51:09 <ski> you just need to unwrap, when you need to get at the contents
10:51:23 <ski> (though i would probably rename `Valid' to something else)
10:52:22 <ski> @check ((/=) <*> negate) :: Int -> Bool
10:52:23 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> GHC.Bool.Bool'
10:52:48 <Sina> ski: one thing I'm stuck with is that if validateCipher return True, then how do I get that cipher again ?
10:53:08 <Sina> ski: I mean I will then need to use that cipher again.
10:53:16 <ski> Sina : that's why it should return `Just x', instead of `True' :)
10:53:50 <Sina> ski: I'm confused :) let me work on it for few minutes. I will find a solution :)
10:55:08 <aristid> :t ((/=) <*> negate) :: Int -> Bool
10:55:08 <lambdabot> Int -> Bool
10:55:19 <aristid> @check (((/=) <*> negate) :: Int -> Bool)
10:55:20 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
10:56:27 <ski> @check ((uncurry (||) . ((== 0) &&& ((/=) <*> negate))) :: Int -> Bool)
10:56:28 <lambdabot>   "OK, passed 500 tests."
10:56:38 <aristid> @check \x -> x == 0 || (x /= negate x) :: Int -> Bool
10:56:39 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> GHC.Bool.Bool'
10:56:52 <aristid> @check ((\x -> x == 0 || (x /= negate x)) :: Int -> Bool)
10:56:53 <lambdabot>   "OK, passed 500 tests."
10:57:08 <aristid> ski: mine is shorter, despite having pointes :D
10:57:16 <ski> yeah :)
10:57:31 <aristid> but quickcheck doesn't find the value
10:57:33 * ski just thought he'd continue in the same style
10:57:39 <ski> unsurprisingly
10:58:09 <djahandarie> lambdabot!
10:58:37 <ski> @botsnack
10:58:37 <lambdabot> :)
11:04:09 <alex404> What's the practical difference between the classes of 'vector' and 'array' types?
11:04:22 <alex404> As in, why would I use one over the other?
11:08:01 <Sina> How can I map a function which takes more than 1 argument? 
11:08:15 <alex404> Sina: What kind of result do you want?
11:08:26 <cwraith> Sina: partially apply the function, or zipWith*, depending on what you want
11:08:44 <cwraith> > zipWith (+) [1..5] [1..15]
11:08:45 <lambdabot>   [2,4,6,8,10]
11:08:50 <djahandarie> Or uncurry
11:09:00 <cwraith> or possibly liftM*
11:09:05 <djahandarie> lol
11:09:21 <cwraith> really, the answer depends on exactly the behavior you want
11:09:22 <Sina> I am supposed to only know "map".
11:09:38 <Sina> well, I have a string, I want to make modification on each character
11:09:46 <cwraith> Sina, the problem is, the specification you provided to us is incomplete :)
11:10:44 <Sina> What kind of specification should I provide?
11:10:56 <mauke> something that lets us answer your question
11:11:08 <djahandarie> Your function, list, and expected output, in this case. :)
11:11:08 <c_wraith> what's the type of the function you want to apply?  How many input lists are you processing at once?
11:12:29 <djahandarie> alex404, you usually get fusion with vectors
11:12:38 <Sina> I have for example "ABC...XYZ". I have another function which takes a character and takes a tuple and returns the alternative in the tuple. like if in the tuple its ('A','G'), then that function would return G.
11:12:59 <Sina> now I want to perform this function on all the characters in the string
11:13:32 <djahandarie> alex404, and they are easier to grow most of the time also
11:13:39 <mauke> map (\c -> f c ('A', 'G')) "string"
11:14:00 <alex404> djahandarie: So vectors unless there's an obvious reason not to?
11:14:08 <alex404> djahandarie: They do seem more 'haskelly', which is nice.
11:14:08 <Sina> its not just a single tuple. Its a list of tuples
11:14:10 <djahandarie> Yes.
11:14:23 <mauke> Sina: so which one do you want to use?
11:14:44 <alex404> djahandarie: Cheers.
11:15:07 <c_wraith> Sina: what's the type of the function you want to apply?  [(Char, Char)] -> Char -> Char ?
11:15:17 <Sina> I already have a function called encode, which takes a character, a cipher(a string), an offset and returns the encoded character.
11:15:28 <Sina> encode	:: Char-> String -> Int ->  Char
11:15:48 <c_wraith> Ok, where is the Int supposed to come from in your mapping?
11:16:26 <Sina> this is as far as I've gone: encodeMessage :: String -> String -> Int -> String;  encodeMessage from cipher offset = map
11:16:40 <alex404> Can someone explain this type signature to me: thaw :: PrimMonad m => Vector a -> m (MVector (PrimState m) a)
11:17:15 <alex404> I don't understand what the heck 'PrimState m' could mean.
11:17:49 <c_wraith> alex404, PrimState is a type constructor of kind (* -> *) -> *.  which probably doesn't help you at all :)
11:18:09 <c_wraith> actually, I'm not sure of that.  It might be (* -> *) -> * -> *
11:18:16 <c_wraith> in any case.
11:18:23 <c_wraith> It means PrimState is a type constructor
11:18:28 <c_wraith> And it's applying it to m
11:19:00 <alex404> Well m in this case is State
11:19:15 <alex404> from (Vector -> (Int, Vector))
11:19:23 <c_wraith> @kind State
11:19:24 <lambdabot> * -> * -> *
11:19:51 <c_wraith> Uh, m is not state
11:19:52 <Sina> this is as far as I've gone: encodeMessage :: String -> String -> Int -> String;  encodeMessage from cipher offset = map
11:20:03 <c_wraith> m would be State Vector, I think
11:20:17 <alex404> Right...
11:20:26 <alex404> e.g. State (Vector Int)
11:20:31 <c_wraith> ah
11:20:32 <c_wraith> ok
11:21:12 <c_wraith> alex404, PrimState functions something like a monad transformer there.  Though I'm sure it isn't one.
11:21:36 <c_wraith> alex404, in particular, it is a type constructor that takes a higher-kinded argument
11:22:28 <alex404> c_wraith: I can sort of rap my head around that... but I don't understand how the m is popping up in two parts of the signatrure
11:23:20 <Sina> Guys, any way to map a function which takes multiple inputs?
11:23:21 <c_wraith> alex404, that generally happens when, as in this case, some complicated operation has a type parameterized by the monad it's operating in.
11:24:01 <alex404> c_wraith: So what could an instantiated version look like in the case of the State Monad?
11:24:34 <asdf25> hi, i've got a question about how to implement a program if anyone wants to answer... i want a type representing a game state in poker, it has 2 basic fields (the previous game state, and the new game message), there are a lot of functions computed using those, and i need them to be computed only once... so what i was thinking was to make a field in the data type for each value i want cached like that... but the functions need to
11:24:34 <asdf25>  take the game state as an arg, so i don't know how i can initialize the game state's data fields with them since they need to take the game state itself as an arg... any ideas? some way to define an object's fields in terms of the object itself would be nice
11:25:03 <c_wraith> alex404, just substitute (State (Vector Int)) in wherever the signature has m currently
11:26:02 <c_wraith> asdf25, data types can refer to themselves.  That's a recursive data type, and used all over.
11:26:15 <ClaudiusMaximus> > let { o = (1, f) ; f (n, g) = (n + 1, g) } in snd o o
11:26:16 <lambdabot>   Overlapping instances for GHC.Show.Show ((t, t1) -> (t, t1))
11:26:16 <lambdabot>    arising fro...
11:26:24 <ClaudiusMaximus> > let { o = (1, f) ; f (n, g) = (n + 1, g) } in fst $ snd o o
11:26:25 <lambdabot>   2
11:27:00 <enthropy> > let a = 1; b = 2 in a+b
11:27:01 <lambdabot>   3
11:28:01 <ClaudiusMaximus> > let { o = (1, f) ; f (n, g) = (n + 1, g) } in take 5 . map fst . iterate (\p -> snd p p) $ o
11:28:02 <lambdabot>   Occurs check: cannot construct the infinite type:
11:28:02 <lambdabot>    b = (a, b) -> (a, b)
11:28:17 <ClaudiusMaximus> oops, i give up
11:29:15 <Adamant> sweet baby Jesus, someone needs to take away a certain mathematician's adverb and adjective license
11:29:37 <Adamant> this is literally worse prose than those bad fiction competitions
11:30:09 <Adamant> the bad thing is that what he's saying is important and interesting
11:30:36 <Adamant> it's just so damned dense and poorly written. admittedly, it's a translation by a non-native-speaker
11:31:24 <alex404> c_wraith: Right... I think I was confusing the monad paramter with its ultimate return type.
11:31:27 <ketil> Adamant, who?
11:31:48 <Adamant> Girard's Proofs And Types
11:31:50 <alex404> How do I deal with: Ambiguous module name `Control.Monad.State'
11:31:58 <Adamant> it's a free ebook, so don't think I'm bitching too much
11:32:02 <alex404> I have mtl and monads-fd isntalled
11:32:44 <enthropy> alex404: hide one with     ghc-pkg hide monads-fd
11:32:54 <c_wraith> alex404, either use cabal to build, compile using -hide-package blah, or use enthropy's advice
11:33:01 <alex404> Cheers
11:33:08 <c_wraith> alex404, I recommend just using cabal
11:33:28 <alex404> c_wraith: I want to be able to use it in ghci
11:33:49 <c_wraith> I really do with cabal had an interactive target
11:34:09 <alex404> wish?
11:34:09 <c_wraith> But every time I say that, dcoutts always responds "I'd accept patches" :)
11:34:14 <alex404> heh
11:34:15 <c_wraith> err, yes
11:36:50 <Sina> Can anyone help with Map ? :(
11:37:11 <Sina> I need to map a function which takes more than 1 argument
11:37:37 <asdf25> it's not obvious to me how the recursive data type concept lets me do what i was saying... say i have a data type A, with 2 fields of types A and B, then i have 2 functions x and y that both take one arg of type A... and x and y are both expensive, so i want to make fields in A to store them (x and y may call each other also, so they're not defined just in terms of the 2 fundamental fields of A)... so what i want to do is (Constr
11:37:37 <asdf25> uctorA {aField=aVal, bField=bVal, xField=(x self), yField=(y self)}), so the structure is created and the "self"'s in the lazy fields there refer to the newly created structure... is there some way to do that?
11:37:50 <enthropy> Sina: what does your list contain?
11:39:35 <Sina> enthropy: my list is a String. [Char]. basically I want to perform a function on all characters in a string
11:40:27 <enthropy> if your function    (f :: Int -> Char -> x), you can do    map (f 2)
11:40:33 <enthropy> and get a list of x
11:41:13 <Sina> my function is this:  encode	:: Char-> String -> Int ->  Char 
11:41:34 <aristid> @hackage records
11:41:34 <lambdabot> http://hackage.haskell.org/package/records
11:41:42 <aristid> asdf25: maybe you want to take a look at that
11:42:02 <enthropy> Sina: you're familiar with lambdas?
11:42:30 <Sina> you mean (\...) ?
11:44:53 <enthropy> yep
11:45:06 <joe1> can I have something as: data Io = IO () | [IO ()] deriving Show
11:45:18 <Botje> ?
11:45:21 <mauke> no, that's a syntax error
11:45:33 <mauke> the second part is missing a constructor name
11:45:35 <Botje> joe1: why would you need this?
11:45:47 <Sina> enthropy: Done :) thanks.
11:46:02 <monadic_kid> seems like this java binding only supports haskell calling java but not the other way round
11:46:35 <Sina> monadic_kid: java and haskell ?!
11:47:10 <joe1> Botje: I am just thinking of having a function return one IO action or more than one IO action as a list.
11:47:37 <mauke> why not just return a list of actions
11:47:51 <joe1> Botje: i have a function that does IO (), Some patterns generate a single IO action whereas others generate a list of IO actions.
11:47:59 <monadic_kid> Sina: yes? there is an old java-haskell bridging library which uses JNI and FFI, I want use this on android
11:48:10 <joe1> I am currently using sequence_ to convert the list of IO actions to a single IO ()
11:48:18 <mm_freak_> monadic_kid: java's typesystem can't represent haskell types in general
11:48:30 <dschoepe> joe1: In the one-action case, you could just return a one-element list.
11:48:33 <monadic_kid> mm_freak_: I don't really need to
11:49:08 <joe1> yes, an option is as dschoepe says convert the one IO action to a list of one IO action.
11:49:19 <Sina> monadic_kid: haskell on android? strange. I didn't know that java and haskell can work together
11:49:32 <mm_freak_> monadic_kid: true
11:49:51 <joe1> I am just curious if I can take it a step further and have a list of elements, where each element could be either one IO action or a list of IO actions?
11:50:04 <monadic_kid> Sina: they don't, it's just bridging the two with C
11:50:41 <monochrom> data Io = Case1 (IO ()) | CaseMany [IO ()]
11:50:46 <joe1> i can create a list of such elements for Int or Char, right..
11:50:54 <joe1> monochrom: thanks.
11:51:20 <Sina> monadic_kid: that means Java, Haskell and C working together?!
11:53:01 <joe1> as we bind Int and Char to types, i am assuming that in (IO ()), the paranthesis are used to bind functions..
11:53:25 <joe1> so, I could bind any function into a type by using ()?
11:54:01 <mauke> no, the parens are used for precedence
11:54:18 <mauke> I'm not sure what you mean by "bind" but function types contain "->"
11:54:53 <monadic_kid> Sina: From Java you can call into C code with JNI, from Haskell you can call into C Code with FFI. Then logically if you want host a Haskell in Java or the other way you bridge two the through C
11:55:16 <joe1> let test = "junk" ; I cannot create: data functionlist = Constructor1 (String) | Constructor2 ([String])
11:55:32 <mauke> that's a syntax error
11:55:59 <Sina> monadic_kid: Isn't using only Java on Android an easier solution?
11:56:10 <monadic_kid> Sina: i don't like java
11:56:20 <monochrom> data type names must be capitalized. data Functionlist = ...
11:56:20 <Sina> monadic_kid: and probably more reliable
11:56:55 <monochrom> A competently written tutorial would have said it.
11:57:13 <monadic_kid> Sina: more reliable? the android ndk (not sdk) provides various native libraries like OpenGL ES
11:57:20 <monochrom> for example "A Gentle Introduction to Haskell"
11:57:36 <monadic_kid> Sina: in any case I want to use Haskell not Java
11:57:44 <monadic_kid> Sina: As do many
11:58:18 <Eduard_Munteanu> o/
11:58:28 <dmwit> "Can I have a list of elements, where each element could be either one IO action or a list of IO actions?"
11:58:29 <Sina> monadic_kid: I see :)
11:58:39 <dmwit> Again, why not use singleton lists to represent single IO actions?
11:58:46 <dmwit> [[IO ()]] -- the type of the thing you want
11:59:00 <Eduard_Munteanu> Has anybody worked with Graphics.GD? I wonder if its Color data type is compatible with Data.Colour's Colour.
11:59:16 <dmwit> Do you actually plan to distinguish between singleton lists and single actions?
11:59:20 <dmwit> That seems very unlikely.
11:59:34 <nus> joe1, in 'Case1 (IO ())' above, the outer parens are used to express that it's a single parameter constructor
12:00:07 <monochrom> "Case1 (IO ())" is written because "Case1 IO ()" means something else
12:00:33 <monochrom> Apart from the type and value (), all parentheses are for disambiguation only.
12:01:16 <monochrom> oops, I forgot tuple types and values
12:01:18 <dmwit> Eduard_Munteanu: You could presumably use Data.Colour.SRGB to interface between them.
12:01:49 <joe1> nus: thanks.
12:02:09 <joe1> monochrom: sorry about the capitalization.
12:02:29 <dmwit> Eduard_Munteanu: toSRGB24 in particular looks good.
12:03:07 <dmwit> (combined with Graphics.GD.rgb)
12:05:46 <Eduard_Munteanu> dmwit: hm thanks. I was a bit unsure Colour was CInt internally as well.
12:07:03 <monadic_kid> Sina: so basically because (and fortunately) android ndk supports shared libraries. All I have to do is write some JNI hooks, a native method called haskell_main which in C sets up the haskell runtime system and then executes a haskell function, this would be equivalent main :: IO (). You don't compile a haskell executable you would compile a shared library
12:08:16 <monadic_kid> the only thing I'm not sure about is if the GHC runtime is in a shared library I can distribute on android.
12:09:01 <Sina> monadic_kid: I am happy to see that android supports more than just "Java"
12:09:46 <joe1> The basic types are Int, Char,etc.. and "data" is used to build "data types". When "code is data", I am just curious if I can use the functions as part of the "data type" definitions? I am not talking about the Constructor functions, which exist more as pattern matchers. Sorry if I am asking something that does not make sense.
12:10:22 <joe1> i know about the accessor functions. but am curious if there are more like that.
12:10:29 <alex404> Is there any reason one would want to use Mutable vectors directly, or is using them via the functions provided in Data.Vector like 'thaw' and 'modify' the standard way?
12:13:32 <nus> joe1, did you actually *read* the Ch.3 of RWH?
12:14:44 <Eduard_Munteanu> Hm, is there any standard average/mean function?
12:15:01 <pumpkin> @hackage statistics
12:15:01 <lambdabot> http://hackage.haskell.org/package/statistics
12:15:08 <pumpkin> Cale: yay, you brought her back!
12:15:15 <pumpkin> Eduard_Munteanu: that's probably your best bet
12:15:17 <Eduard_Munteanu> pumpkin: uh, I'd better write it myself then :)
12:15:26 <pumpkin> why?
12:15:32 <joe1> nus: will get back to the book, then.
12:15:38 <pumpkin> that library is good
12:15:58 <Eduard_Munteanu> pumpkin: well, I thought there was something in Prelude, doing an import just to skip writing a simple sum and division isn't great.
12:16:15 <pumpkin> well, depends on your performance needs
12:16:22 <couchrider> hello, i would like to use map with divison, but i have some problems with divison of fractional and integer, what could be the problem? - my code is:  divMap :: (Fractional a) => Int -> [a] -> [a]        divMap a b = map (/a) b
12:16:24 <pumpkin> this one is going to be way faster, but if you're using lists you probably don't care
12:16:34 <Eduard_Munteanu> pumpkin: yeah, it's a list.
12:16:37 <hpc> it's not hard to write a fast averager
12:16:59 <pumpkin> hpc: there are some nontrivial algorithms for fast numerically stable means
12:17:46 <alex404> What? What is there to do besides 'sum xs / n'?
12:18:14 <Draconx|Laptop> alex404, 'sum xs' is very unstable.
12:18:20 <kmc> monadic_kid, you're building GHC as a cross compiler to target android?
12:18:29 <djahandarie>  Haha
12:18:35 <alex404> Draconx: What do you mean, unstable?
12:19:07 <pumpkin> alex404: one issue is that finding length and sum are two separate folds over the list
12:19:10 <pumpkin> alex404: for a list
12:19:33 <kmc> monadic_kid, i have done this
12:19:34 <Ke> > sum ([10^17] ++ repeat 10^17 1)
12:19:35 <lambdabot>   No instance for (GHC.Num.Num [a])
12:19:35 <lambdabot>    arising from a use of `e_1101710171' a...
12:19:47 <kmc> it's nearly working
12:19:51 <Ke> > sum ([10^17] ++ (repeat 10^17 1))
12:19:51 <lambdabot>   No instance for (GHC.Num.Num [a])
12:19:51 <lambdabot>    arising from a use of `e_1101710171' a...
12:19:56 <Draconx|Laptop> alex404, it means that numerical errors compound catastrophically.
12:20:25 <alex404> pumpkin: Okay, but that's pretty trivial.
12:20:33 <monadic_kid> kmc: I'm not making a cross-compiler, i'm thinking of using JNI (android ndk) and FFI to bridge the two with shared libraries
12:20:37 <Ke> > sum ([10^17] ++ (replicate 10^17 1))
12:20:37 <lambdabot>   Couldn't match expected type `[t]' against inferred type `a -> [a]'
12:21:01 <aristid> > replicate (10^17) 1
12:21:02 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:21:06 <kmc> monadic_kid, how will you get compiled Haskell code onto the Android device?
12:21:09 <Ke> > sum ([10^17] ++ (replicate (10^17) 1))
12:21:11 <alex404> Draconx: Ahhhh. Why would sum be especially unstable? Or is that simply the case in general for basic summation?
12:21:16 <lambdabot>   mueval: ExitFailure 1
12:21:17 <pumpkin> alex404: http://snapplr.com/bm26 
12:21:29 <Draconx|Laptop> alex404, here's a specific example:
12:21:42 <Draconx|Laptop> > sum [1.8e16, 1, -1.8e16]
12:21:43 <pumpkin> > sum (replicate 100 0.1)
12:21:47 <lambdabot>   mueval-core: Time limit exceeded
12:21:47 <lambdabot>   mueval-core: Time limit exceeded
12:21:47 <Ke> well obviously that wii timeout
12:21:49 <aristid> Ke: taking the sum of a list of 10^17 elements is probably not very fast
12:21:55 <Ke> aristid: yup
12:22:02 <pumpkin> > sum (replicate 100 0.1)
12:22:03 <Draconx|Laptop> wtf?  lambdabot fails?
12:22:04 <lambdabot>   9.99999999999998
12:22:06 <Draconx|Laptop> > sum [1.8e16, 1, -1.8e16]
12:22:07 <lambdabot>   0.0
12:22:10 <Draconx|Laptop> there we go.
12:22:19 <monadic_kid> kmc: you mean my own or to everyone? if you mean the latter I don't know what the rules for android programs using the ndk on google app store
12:22:31 <kmc> monadic_kid, at all
12:23:03 <kmc> monadic_kid, you need to compile your Haskell code into a .so file compatible with your Android device's architecture, ABI, etc.
12:23:04 <kmc> right?
12:23:33 <alex404> Draconx: That's awesome.
12:23:34 <Draconx|Laptop> alex404, so the most obvious way to improve this is to sort the list first:
12:23:51 <alex404> pumpkin: Cool. Thansk for that...
12:24:02 <Draconx|Laptop> alex404, er, sort by magnitude
12:25:04 <Draconx|Laptop> alex404, but you can still get bad cases.
12:25:05 <monadic_kid> kmc: yes I'm just thinking about this at the moment. I guess I'll have to copy ghc runtime shared libraries for various architectures
12:25:28 <kmc> monadic_kid, you want to run ghc on your computer but have it produce android shared libraries, yes?
12:25:55 <alex404> Draconx: Interesting. So perhaps in general, be very careful when doing high precision calculations?
12:26:04 <alex404> Draconx: Rely on external libraries if you can?
12:26:19 <monadic_kid> kmc: i don't want to run ghc, I just need build haskell programs as either static or shared library with a runtime
12:26:27 <pumpkin> statistics is a very carefully implemented library
12:26:36 <pumpkin> in terms of numerical stability and speed
12:26:53 <alex404> pumpkin: It's just bindings to an open source c library, right?
12:26:56 <pumpkin> no
12:26:59 <pumpkin> it's all pure haskell
12:27:02 <alex404> Oh
12:27:04 <alex404> Cool
12:27:10 <pumpkin> :)
12:27:14 <kmc> monadic_kid, so you're going to use a compiler other than ghc?
12:27:18 <kmc> or an interpreter like hugs?
12:27:51 <alex404> pumpkin: That's super handy actually. I always regret not taking a numerics course... whenever I have another lazy sunday, I can go peaking into their code...
12:28:07 <pumpkin> it's pretty good :)
12:28:38 <kmc> monadic_kid, what you just said is "i don't want to run ghc, i just want to compile Haskell programs"
12:29:12 <monadic_kid> kmc: okay i get what your saying now, I still need ghc built for what ever architecture is going to be targetted when i actually build a shared library. So not only do i need shared libraries of the runtime for what ever architecture and a compiler than can build shared libraries for the target too
12:29:29 <Draconx|Laptop> alex404, If you're interestid, I recommend the article "What Every Computer Scientist Should Know About Floating Point Arithmetic" by David Goldberg as a starting point.
12:29:39 <Draconx|Laptop> s/interestid/interested/
12:29:51 <alex404> Draconx: Wicked. Thanks.
12:29:56 <kmc> yes
12:30:07 <kmc> you need a compiler that will run on your computer but produce android binaries
12:30:12 <kmc> that's called a cross-compiler
12:30:29 <kmc> (unless you want to run ghc on the android device itself, and besides that being a bad idea, there's a chicken-and-egg problem)
12:30:38 <kmc> anyway
12:30:52 <monadic_kid> kmc: i know what a cross-compiler is, I just didn't think about that part
12:30:54 <Sina> guys, how can I prevent code repetition in haskell?
12:31:09 <kmc> Sina, you'd have to be more specific
12:31:13 <nus> Sina, scrap your boilerplate
12:31:23 <kmc> probably by defining a function to generalize whatever you're repeating
12:31:44 <alex404> Draconx: Newbie Question: In general, don't we avoid floating point for doubles these days?
12:31:49 <kmc> monadic_kid, so i've done some work on building ghc as an android cross compiler
12:31:55 <kmc> work for iPwn Studios
12:32:06 <alex404> Draconx: Or this article touches on a number of good numerics issues?
12:32:25 <Martty> i have a module A which defines foo, a module B which imports A and where i can use foo just fine but if i create a module C that imports A i need to qualify foo to access it (B.foo). is there any way to prevent this?
12:32:32 <kmc> i can help you build it
12:32:48 <kmc> and also ask them if they're ok with releasing the code already
12:33:06 <kmc> Martty, do you mean "module C that imports B"?
12:33:17 <Martty> no
12:33:23 <Martty> shall i make a testcase?
12:33:25 <kmc> then how are B and C different?
12:33:35 <Martty> oh yeah, module C imports B
12:33:36 <Martty> :P
12:33:40 <kmc> ;P
12:33:48 <kmc> you can make B export all of A
12:33:58 <kmc> module B where (module A, other stuff) where
12:34:03 <kmc> import A
12:34:10 <Draconx|Laptop> alex404, not sure what you mean by "avoid floating point for doubles".
12:34:45 <Martty> ah.. whatafax
12:34:46 <Sina> kmc: nus: I have a function that encodes a message. I have another function that decodes the given string. basically the only difference is a small part. should I make another function to make the program look better? cause I have repeated code here
12:34:56 <kmc> probably
12:35:00 <kmc> can you hpaste your code?
12:35:06 <kmc> hpaste.org
12:35:23 <kmc> likely you can write a single function, that takes that "small part" as a parameter
12:35:29 <alex404> Draconx: Well, doubles are two words coupled together, while a floating point tracks the position of the decimal... so prima facie the precision issues might be slightly different?
12:36:16 <nus> so, supposedly, it's symmetric?
12:37:12 <Sina> kmc: http://pastebin.com/jM3G1VbL
12:37:39 <alex404> Draconx: If my question is simply undercooked, don't bother. I've got enough to chew on.
12:38:55 <kmc> Sina, a cipher is a map from characters to characters?
12:39:19 <Sina> a cipher is like this "ESOVPZJAYQUIRHXLNFTGKDCMWB"
12:39:33 <kmc> but you unpack it to [(Char,Char)]
12:39:40 <Martty> well kmc , doing import again seems to cut it
12:39:50 <Martty> in C do import A; import B; even though B imports A
12:39:51 <Draconx|Laptop> alex404, the "Double" type in Haskell is a floating point type.
12:39:54 <Sina> kmc it is exactly 26 chars long and has all letters in it (no-repetition)
12:40:23 <kmc> and you zip it with ['A'..'Z'] to make a list of (from char, to char) pairs
12:40:24 <alex404> Draconx: Ah. Good to know. Thanks for the article link.
12:40:24 <kmc> yes?
12:40:26 <aristid> > zip ['A'..'Z'] "ESOVPZJAYQUIRHXLNFTGKDCMWB"
12:40:27 <lambdabot>   [('A','E'),('B','S'),('C','O'),('D','V'),('E','P'),('F','Z'),('G','J'),('H'...
12:40:32 <aristid> :t lookup
12:40:33 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
12:40:40 <kmc> you should probably use (Data.Map k v) instead of [(k,v)] but anyway
12:40:47 <Sina> kmc yes. so in this example, A is E, B is S, ...
12:40:53 <kmc> why don't you just handle decoding by running map (\(a,b) -> (b,a)) on that list?
12:41:10 <aristid> map swap if swap would exist
12:41:56 <Sina> kmc well, the map is created by encode function.
12:42:25 <Sina> I mean the tuples.
12:43:04 <aristid> :t ((.).(.)) lookup (\(a,b) -> (b,a))
12:43:05 <lambdabot> forall a b t. (Eq a) => (a, t) -> (t, [(a, b)] -> Maybe b)
12:43:17 <aristid> :t ((.).(.)) lookup (map (\(a,b) -> (b,a)))
12:43:18 <lambdabot> forall b t t1. (Eq t1, Eq t) => [(t, t1)] -> [[((t1, t), b)] -> Maybe b]
12:43:34 <mercury^> :t ((.)(.))
12:43:35 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
12:43:53 <aristid> mercury^: that's the booby combinator
12:43:59 <mercury^> Yep. :)
12:45:03 <joe1> "Nothing" has to be used in a "Maybe " datatype. Whereas "Empty" can be used anywhere. Is this correct? It seems to work in ghci, but wanted to check.
12:45:22 <joe1> > data Bdata = Bdata Int | Empty deriving Show
12:45:23 <lambdabot>   <no location info>: parse error on input `data'
12:45:31 <joe1> > testbdata = Empty
12:45:33 <lambdabot>   <no location info>: parse error on input `='
12:46:07 <mercury^> @let bewbs = (.)(.)
12:46:09 <lambdabot>  Defined.
12:46:27 <joe1> @let testbdata = Empty
12:46:28 <lambdabot>  <local>:3:12: Not in scope: data constructor `Empty'
12:48:04 <mercury^> > (bewbs [(+3),(+4)]) <$> [(*4),(*2)] <$> [7,9]
12:48:05 <lambdabot>   Couldn't match expected type `a -> a1 -> b'
12:48:05 <lambdabot>         against inferred type `...
12:52:22 <mercury^> > bewbs ((+4) .) (+3) (+2) 3
12:52:26 <lambdabot>   mueval-core: Time limit exceeded
12:52:35 <mercury^> wut?
12:53:19 <aristid> :t bewbs
12:53:20 <lambdabot> forall (f1 :: * -> *) a b (f :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
12:53:37 <aristid> :t bewbs (+)
12:53:37 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => a -> f a -> f a
12:53:49 <aristid> :t bewbs (+) 1 (Just 2)
12:53:50 <lambdabot> forall a. (Num a) => Maybe a
12:53:52 <aristid> > bewbs (+) 1 (Just 2)
12:53:54 <lambdabot>   Just 3
12:54:04 <joe1> > :t Empty
12:54:05 <lambdabot>   <no location info>: parse error on input `:'
12:58:23 <mac_wooster>  /quit
13:00:39 <Eduard_Munteanu> Is Graphics.GD incomplete? After reading the original GD's docs, I saw getPixel returns an index whose projections on RGB should be taken with special functions.
13:01:02 <Eduard_Munteanu> But those don't exist in the Haskell binding. getPixel returns a Color which is simply a CInt.
13:01:40 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/gd/3000.5.0/doc/html/Graphics-GD-ByteString.html
13:01:43 <dmwit_> Graphics.GD is very incomplete.
13:02:08 <Sina> guys, how to remove duplicates from a list?
13:02:37 <Eduard_Munteanu> dmwit: can you recommend an alternative for reading an image? It should work with Data.Colour (I'm interested in RGB->HSV->RGB conversions).
13:02:49 <Eduard_Munteanu> I'm generally interested in PNGs.
13:03:11 <dmwit> I'm not sure. I've done some image manipulation with Gtk, and it wasn't horribly painful.
13:03:27 <dmwit> I think there's hsmagick, as well, but I've never personally used it.
13:03:33 <pumpkin> Sina: an inefficient way that doesn't require much is nub
13:03:34 <Eduard_Munteanu> dmwit: ah so GTK/GDK can open images?
13:03:42 <dmwit> yes
13:03:48 <Eduard_Munteanu> dmwit: thanks, I'll have a look.
13:03:55 <Sina> pumpkin: any other way than "nub" ?
13:04:03 <gregor3005> jmcarthur: thx for the hints i solved the problem :-)
13:04:15 <pumpkin> Sina: do you care about preserving order?
13:04:45 <Sina> pumpkin: I can sort I guess afterwards
13:04:56 <pumpkin> :t S.toList . S.fromList
13:04:57 <lambdabot> forall a. (Ord a) => [a] -> [a]
13:05:13 <pumpkin> > S.toList . S.fromList $ [1,1,1,5,3,2,7,27,2,7,1,3,4,7,2,2,2
13:05:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:05:15 <pumpkin> > S.toList . S.fromList $ [1,1,1,5,3,2,7,27,2,7,1,3,4,7,2,2,2]
13:05:16 <lambdabot>   [1,2,3,4,5,7,27]
13:05:49 <Sina> pumpkin: any way that be expected from a newbie ? :)
13:05:50 <aristid> @oeis 1,2,3,4,5,7,27
13:05:50 <lambdabot>  Sequence not found.
13:06:19 <pumpkin> :t map head . group . sort
13:06:19 <lambdabot> forall a. (Ord a) => [a] -> [a]
13:07:06 <Eduard_Munteanu> Hm, Cairo has this... withImageSurfaceFromPNG :: FilePath -> (Surface -> IO a) -> IO a
13:07:29 <benmachine> Sina: if you never want duplicates you might want to use Data.Set instead of list the whole way, it's not too difficult
13:07:42 <Eduard_Munteanu> An open function should simply be withImageSurfaceFromPNG path (return)
13:07:43 <dmwit> Eduard_Munteanu: There is also Gdk.Pixmap or something like that.
13:08:06 <Eduard_Munteanu> Ah, I'll look there too.
13:08:52 <Sina> benmachine: I have limitation on what I can use. Its not the matters of difficulty
13:09:25 <gregor3005> bye
13:11:50 <Eduard_Munteanu> pixbufNewFromFile from Graphics.UI.Gtk.Gdk.Pixbuf seems nice, thanks.
13:12:00 <kmc> Eduard_Munteanu, often 'with' functions are provided with the caveat that the parameter should not escape the delimited action
13:12:01 <mercury^> pumpkin: toList . fromList should be faster than head . group. sort
13:12:10 <kmc> it may deallocate when that action finishes
13:12:12 <kmc> so be sure to read the docs
13:12:16 <pumpkin> mercury^: how come?
13:13:34 <Eduard_Munteanu> kmc: I see. Well, I'll use the GDK variant then.
13:15:20 <mercury^> pumpkin: sort is a mergesort, fromList builds a Trie
13:15:31 <pumpkin> a trie? :O
13:15:38 <mercury^> I think so.
13:15:48 <pumpkin> how would you build a trie of an arbitrary Ord value
13:16:32 <mercury^> http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-IntSet.html
13:16:38 <pumpkin> yeah, that's IntSet
13:16:50 <pumpkin> only works on [Int]
13:16:59 <dmwit> Map uses "size-balanced binary trees" according to the Data.Map docs.
13:17:09 <pumpkin> yeah, and Set uses the same structure
13:17:12 <pumpkin> IntMap and IntSet use tries
13:17:16 <dmwit> binary *search* trees, sorry
13:17:52 <dmwit> So, yeah, fromList . toList may be faster, but if so, it's a coincidence, and not asymptotically faster.
13:18:30 <mercury^> Of course not asymptotically.
13:18:40 <pumpkin> well, a trie would be asymptotically faster
13:18:51 <pumpkin> but I don't see how with only an Ord constraint, you could build a trie
13:19:22 <dmwit> Isn't there some kind of theorem essentially saying you can't do that? sort's gotta be at least O(n * log n)
13:19:36 <pumpkin> yep
13:19:49 <mercury^> Eh, if IntMap was asymptotically faster than sort, we could implement sort through it and have a contradiction?
13:19:55 <endojelly> dmwit, only if it's based on comparision. which is necessarily the case for only ORd
13:20:16 <pumpkin> mercury^: the point is that IntMap has more information about its domain than a general Ord-map
13:20:19 <dmwit> mercury^: Nope, Int has more than just comparison.
13:20:27 <sipa1024> sorting based on a compare operation between elements is at least O(n log n)
13:20:34 <sipa1024> sort in general can be faster
13:20:38 <endojelly> yeah
13:20:41 <dmwit> mercury^: Flash-sort is O(n), but that doesn't contradict anything. =)
13:20:43 <endojelly> a very simple example is counting sort
13:20:48 <endojelly> which is O(n), too
13:20:52 <dmwit> (flash-sort assumes you know the distribution that the incoming elements are drawn from)
13:21:29 <mercury^> Oh, alright.
13:21:38 <endojelly> counting sort needs O(n) space and assumes that the elements are from a bound, discrete range
13:22:18 <mercury^> It just creates an array and writes the number of occurances into it?
13:22:25 <endojelly> exactly 8)
13:24:07 <gwern> endojelly: wait, I thought counting sort needed O(n) in the # of discrete items in the possible range of items, not O(n) in the length of the list
13:24:14 <gwern> and Int especially in 64-bit is awful big
13:24:23 <mercury^> So linear orders can be sorted in O(n), are there any other significant steps between that and the general case?
13:24:38 <endojelly> gwern, ah, sorry, of course
13:25:12 <endojelly> gwern, that's what I went but I said it wrong.. (and no I'm not saying counting sort is good for ints)
13:25:16 <endojelly> but there's also radix sort.
13:25:23 <mercury^> gwern: it should be O(min(n,m)), n being the range and m the length
13:25:29 <mercury^> err, max
13:25:30 <mercury^> =)
13:25:39 <gwern> mercury^: that's quite a difference...
13:25:54 <dmwit> mercury^: I don't know of any other significant ones.
13:25:57 <endojelly> mercury^, no, it's min
13:26:13 <mercury^> endojelly: you need to traverse the whole list and the whole range once, so it's max?
13:26:41 <endojelly> mercury^, *space*
13:26:55 <osaunders> @src (.)
13:26:55 <lambdabot> (f . g) x = f (g x)
13:26:56 <lambdabot> NB: In lambdabot,  (.) = fmap
13:27:45 <mercury^> endojelly: then it's just the range, why should the length of the list be a bound?
13:27:50 <endojelly> mercury^, it's O(n) time (not O(max(n,m)) because you can keep a linked list of visited values) and O(m) space
13:28:18 <mercury^> Ok.
13:28:29 <endojelly> mercury^, it isn't, I just thought about it again and these are the results ;)
13:28:31 <endojelly> sorry
13:29:45 <endojelly> mercury^, wait. if you know the range and the length before (which you do), you can decide to switch from an array containing the whole range to an array with the size of the length
13:29:53 <taktoa> I'm using a function that converts a hue value to the equivalent RGB values (with S and L predefined) in my program
13:29:53 <taktoa> http://hpaste.org/40840/hsl_to_rgb
13:29:59 <endojelly> mercury^, two arrays, one containing the values, the other the count
13:30:09 <taktoa> but for some reason, it gives me an error on run
13:30:10 <endojelly> mercury^, should be same time complexity, but O(min(n,m)) space complexity
13:30:12 <taktoa> one moment
13:30:18 <mercury^> endojelly: I don't yet see how that works.
13:30:30 <taktoa> non-exhaustive patterns in function hslrgb
13:30:44 <endojelly> mercury^, if the length of your data is smaller than the range, you know there are going to be at most n different values in your data.
13:30:54 <mercury^> endojelly: right.
13:30:59 <endojelly> mercury^, so you need only need space for that.
13:31:09 <mercury^> No, because you do not know where to place them.
13:31:11 <endojelly> mercury^, ... aaaand there goes O(n) time 8)
13:31:19 <endojelly> mercury^, yeah, that just dawned on me, too
13:31:20 <taktoa> can anyone tell be why?
13:31:23 <taktoa> *me
13:32:13 <dmwit> taktoa: yes
13:32:23 <taktoa> ok, will you?
13:32:24 <dmwit> taktoa: What is hslrgb 7? How about hslrgb (-1)?
13:32:38 <endojelly> mercury^, but hey, it's better to think about it and realize mistakes than not to think about it at all.
13:32:41 <hpc> @hoogle time :: IO String
13:32:41 <MrAI> Im looking for peoples suggestions on the best online tutorial/help for Haskell? Thanks in advance
13:32:42 <lambdabot> System.Time timeDiffToString :: TimeDiff -> String
13:32:43 <lambdabot> Data.Time.LocalTime timeZoneName :: TimeZone -> String
13:32:43 <lambdabot> Data.Time.LocalTime timeZoneOffsetString :: TimeZone -> String
13:32:44 <taktoa> thanks
13:32:49 <taktoa> *facepalm*
13:32:55 <hpc> @hoogle IO Time
13:32:55 <lambdabot> Did you mean: :: IO Time /count=20
13:32:55 <lambdabot> Data.Time.LocalTime timeOfDayToDayFraction :: TimeOfDay -> Rational
13:32:55 <lambdabot> System.CPUTime cpuTimePrecision :: Integer
13:32:57 <dmwit> hpc: getCurrentTime
13:33:00 <hpc> ah, ty
13:33:08 <kmc> MrAI, we typically recommend RWH and LYAH
13:33:09 <dmwit> :t getCurrentTime
13:33:09 <lambdabot> Not in scope: `getCurrentTime'
13:33:10 <kmc> @where RWH
13:33:10 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:33:11 <kmc> @where LYAH
13:33:11 <lambdabot> http://www.learnyouahaskell.com/
13:33:16 <MrAI> Thanks kmc
13:33:24 <kmc> MrAI, for asking questions, here is a great place, as is Stack Overflow
13:33:29 <MrAI> And Lambdabot
13:33:31 <kmc> :D
13:33:33 <joe1> MrAI: learn you a haskell is awesome.
13:33:51 * hackagebot augeas 0.3.3 - A Haskell FFI wrapper for the Augeas API  http://hackage.haskell.org/package/augeas-0.3.3 (JudeNagurney)
13:33:53 <dmwit> ?where gentle
13:33:53 <lambdabot> http://www.haskell.org/tutorial/
13:33:54 <endojelly> so, anyway
13:33:58 <endojelly> there's radix sort for integers
13:33:59 <dmwit> My favorite tutorial!
13:34:04 <endojelly> which looks at individual digits
13:34:11 <MrAI> Thanks dmwit
13:34:18 <endojelly> (and thus also works with strings of any kind)
13:34:37 <joe1> MrAI: also post your code to this irc and get it vetted. I learned a lot from the suggestions here, far more than a tutorial could ever teach..
13:35:10 <endojelly> and it's also pretty simple and has O(kN) time and space. this time I didn't estimate it by myself on a brim but looked it up so it should be really right ;)
13:36:28 <FDFlock> is there suck a thing as "O(kN)"? I mean, it's meaningless, right? ;)
13:36:42 <FDFlock> Since it is the same as O(n) by definition
13:36:58 <FDFlock> *such a thing
13:37:16 <endojelly> k is key length, N is average key length
13:37:29 <endojelly> er
13:37:44 <endojelly> k is number of digits, N is average key length
13:38:14 <endojelly> FDFlock, well you can see how they are related to each other
13:38:15 <dr460neye_> hi there, i
13:38:38 <FDFlock> Oh, sorry I must have missed the algorithm (I thought k was a constant since you chose one to be lowercase and the other uppercase) xD
13:38:42 * FDFlock goes back to lurking
13:38:46 <endojelly> FDFlock, with fixed number of key length the time grows linear with average key length and vice versa
13:39:06 <endojelly> FDFlock, no the big N is just a silly notation for average length %)
13:39:39 <FDFlock> endojelly: I see :)
13:42:39 <dr460neye_> i'm coding in haskell for about 5 days, but now i stuck on a little error.i try to create an diagonal graphics with a list http://hpaste.org/40841/diagramm_draw_v2 -- just look in the annotation
13:43:12 <dr460neye_> do you think you can help me? i'm happy for all hints
13:44:09 <mauke> what error?
13:44:11 <dmwit> Without tracing through carefully, I'm going to take a wild guess and say the problem is in aside.
13:44:28 <dmwit> Try (aside [] ["abc"]) and let me know of that's the expected result.
13:44:35 <dr460neye_> all methods from the picture module are working
13:44:57 <dr460neye_> it's not an real error. but it's not drawing the right "Picture"
13:45:47 <dr460neye_> and it's not allowed to me to change something inside the module
13:47:15 <dr460neye_> reutrn of aside [] ["abc"] = []
13:47:28 <dmwit> Is that what you expected?
13:48:00 <dr460neye_> all functions before the line are working well
13:48:27 <dr460neye_> but the problem is the diagMaker function
13:48:58 <dmwit> Forget whether it's working for a second. Is it what you *expected*?
13:49:11 <dmwit> If "working" doesn't match "expectation", it doesn't matter whether it's working or not. =)
13:49:11 <dr460neye_> yes
13:49:36 <dr460neye_> i expected that it will be  an empty list
13:51:29 <dr460neye_> the diagMaker calls the diagLine with wrong values
13:52:35 <dmwit> Alright. Here's debugging 101: what's the smallest sentence of the form "I do X, expecting Y, but get Z instead"?
13:52:59 <dmwit> You will probably spot your problem by the time you get to the smallest sentence of that form. =)
13:54:49 <McManiaC> what are pro/cons for happy vs parsec?
13:55:01 <taktoa> "I do your mother, expecting death, but get pleasure instead"
13:55:14 <hpc> no problems there ;)
13:57:02 * hackagebot neither 0.1.0 - Provide versions of Either with good monad and applicative instances.  http://hackage.haskell.org/package/neither-0.1.0 (MichaelSnoyman)
13:57:40 <hpc> ha!
14:00:56 <dr460neye_> expect >diagLine creates a string with ## at position pos, all other steps are "white" = .. diagMaker should put all diaglines together (thats working) , after outputing diagline through printPic you should see an diagonal line as ascii code.
14:02:32 <joe1> i have been asking this question but have not received much input. How does a haskell programmer evolve? 1st step: use lots of do functions, 2nd step: using sequence_ and lists of IO actions, 3rd step: use types and one do function, 4th step:??
14:02:41 <Kaidelong> does Haskell have some notion of optional, private methods which can be passed with an instance to help it generate default methods?
14:02:50 <joe1> any thoughts, please?
14:03:06 <joe1> Kaidelong: accessor functions
14:03:06 <Kaidelong> IE you can supply either a "m g Gene" or a "[Int] -> Gene"
14:03:44 <Sina> guys, I have a list of tuples. the type is: [(Char,Int)] . I want to sort them by the second element of tuples. how do I do this?
14:04:00 <dr460neye_> i get> the first diagLine correct. all other diagLines are not at the right position. (should be ##......) but it is (..##....), second problem> there is one line missing
14:04:07 <mauke> Sina: sortBy (comparing snd)
14:04:13 <nus> @where evolution
14:04:13 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
14:04:21 <kmc> joe1, http://www.willamette.edu/~fruehr/haskell/evolution.html
14:04:21 <nus> joe1, ^^^
14:04:23 <kmc> haha
14:04:27 <dr460neye_> @dmwit better explanation than before?
14:04:27 <lambdabot> Unknown command, try @list
14:04:38 <Kaidelong> joe1: doesn't seem to be related to what I need, unless I'm missing something
14:04:54 <nus> kmc, (-:
14:05:05 <kmc> Kaidelong, you can export a class without exporting all its methods
14:05:13 <Sina> mauke: I only have a mergesort function. which I have to use. it does not take a "by"
14:05:19 <kmc> Data.Array.Array does this
14:05:21 <kmc> i don't like it, though
14:05:27 <mauke> Sina: what is its type?
14:05:36 <Kaidelong> kmc: but could an instance of the class define those hidden methods?
14:05:43 <kmc> only if it were in that module
14:05:44 <Kaidelong> if they're not exported
14:05:53 <Kaidelong> hmm
14:06:02 <kmc> Kaidelong, it's also common to export helper functions that are not part of any class, but which are expected to be useful in defining instances
14:06:03 <Kaidelong> Okay well it's not a big deal
14:06:27 <Kaidelong> I'll just make a seperate function that turns an [Int] -> gene into a m g gene
14:06:34 <kmc> yes, that sounds useful
14:06:41 <Sina> mauke: I will put it in pastebin. one sec...
14:06:54 <Lemmih> joe1: Don't listen to those guys. Go for a the Metabolic Boost and do a lambda rush.
14:07:04 <dr460neye_> i added an output and expected output at the hpaste  http://hpaste.org/paste/40841/iooutput#p40843
14:07:30 <Sina> mauke: http://pastebin.com/FgD7jHSA
14:07:51 <mauke> Sina: ok, so the type is in the first line
14:07:54 <joe1> what is a lambda rush?
14:07:56 <mauke> mergesort :: (a->a -> Bool)->[a] -> [a]
14:07:57 <MrAI> I understand you have to return the same type in Haskell, how do you do more than one line for a return of an if statement?
14:07:58 <mauke> ^ type signature
14:08:25 <joe1> Lemmih: What is a "lambda rush"?
14:08:33 <dmwit> dr460neye_: Still too big. I bet you can call it with smaller arguments and still see a problem.
14:08:35 <dschoepe> MrAI: what do you mean by more than one line?
14:08:35 <Sina> mauke: I know whats the type. just wanted to give you the whole code to take a look at it :)
14:08:49 <mauke> Sina: mergesort ((<=) `on` snd)
14:08:53 <MrAI> Say before I return true, I want to do something?
14:09:24 <dmwit> dr460neye_: Also, that looks like a call to diag; I bet you can find a call to one of its sub-functions (like diagMaker or diagLine) that does something unexpected.
14:09:24 <MrAI> doubleSmallNumber' x = (if x > 100 then x else x*2) + 1
14:09:24 <MrAI> . Say before I return x I want to add 2?
14:09:32 <joe1> the evolution article is more of a joke, it seems?
14:09:37 <dmwit> dr460neye_: The more you narrow it down, the easier it will be for you to see where your problem is.
14:09:47 <Sina> what kind of thing is this ((<=) 'on' snd) ?
14:09:57 <Kaidelong> MrAI: what do you mean exactly? When do you add 2?
14:10:02 <mauke> Sina: a syntax error
14:10:23 <MrAI> doubleSmallNumber' x = (if x > 100 then <I WANT TO ADD 2 HERE AND THEN RETURN> x else x*2) + 1
14:10:23 <Sina> mauke: what do you mean ? :)
14:10:37 <dmwit> Sina: You probably meant ((<=) `on` snd), not ((<=) 'on' snd).
14:10:38 <Kaidelong> doubleSmallNumber' x = (if x > 100 then x+2 else x*2) + 1
14:10:49 <joe1> test x = | x > 100 = succ x (next line) | = succ $ x * x
14:10:52 <joe1> > test x = | x > 100 = succ x (next line) | = succ $ x * x
14:10:52 <lambdabot>   <no location info>: parse error on input `='
14:10:55 <dmwit> Sina: backticks turn a prefix function into an infix function
14:10:58 <MrAI> Ah ok thanks
14:10:59 <joe1> MrAI: test x = | x > 100 = succ x (next line) | = succ $ x * x
14:11:14 <joe1> MrAI: check out patternguards
14:11:20 <Lemmih> joe1: Similar to a zergling rush but with lambdas instead. Asking about the evolution of Haskell programmers doesn't merit more than a joke answer, does it?
14:11:24 <MrAI> I see what your doing
14:11:26 <Kaidelong> MrAI: doubleSmallNumber' x = (if x > 100 then x+2 else x*2) + 1 -- this is what you want
14:11:28 <dmwit> > let test x | x > 100 = succ x | otherwise = succ (x * x) in test 32
14:11:29 <lambdabot>   1025
14:11:32 <dmwit> joe1: ?
14:11:36 <MrAI> Yes
14:11:42 <MrAI> Kaidelong: Yes
14:12:05 <Sina> dmwit: how do you type ` ? and it will give an error
14:12:18 <Kaidelong> > `
14:12:19 <lambdabot>   <no location info>: parse error on input ``'
14:12:24 <mauke> Sina: I use the ` key
14:12:28 <joe1> Lemmih: i am not that concerned about the evolution of Haskell programmers, in general. I am more worried about the evolution of my thinking as it pertains to programming as I use Haskell.
14:12:49 <Sina> mauke: right :D but still, it gives an error.
14:13:00 <dmwit> Be more specific. What is "it"?
14:13:05 <mauke> Sina: better not tell us what error, otherwise we might be able to help you!
14:13:08 <magicman> @type (<=) `on` snd
14:13:08 <joe1> dmwit: was more MrAI
14:13:09 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Bool
14:13:30 <Sina> mauke: sorry,  Undefined variable "on"
14:13:41 <mauke> @index on
14:13:41 <lambdabot> bzzt
14:13:46 <mauke> lambdabot: you!
14:13:46 <magicman> 's in Data.Function
14:13:56 <mauke> Sina: import Data.Function
14:14:17 <Sina> mauke: is there any other solution? this is definitely not something I am allowed to use
14:14:29 <dmwit> import Data.Function
14:15:06 <Kaidelong> MrAI: now something to think about is how you could implement if yourself using only patterns
14:15:49 <Kaidelong> so that you end up with something like "if (
14:16:14 <Kaidelong> so that you end up with something like "if (>100) (+2) (*2)"
14:16:30 <mauke> Sina: sure, you can just do what on does manually
14:16:35 <Kaidelong> well you'd have to use something other than if
14:17:13 <MrAI> Eep take it easy - I started learning Haskell when I joined the channel :p
14:17:30 <Kaidelong> this would be an easy exercise yes
14:17:45 <Kaidelong> although perhaps not an obvious one
14:18:02 <Kaidelong> but if you're able to do it you'll understand something important about functional programming
14:18:30 <youngbull> Sina: ((<=) `on` snd) x y == (snd x) <= (snd y) , so just make an extra function for that if you are not comfortable importing Data.Function
14:18:38 <MrAI> So you want me to figure out how you type it in as if(>100) (+2) (*2)?
14:18:53 <Sina> mauke: I currently did something else (passed the list in a reverse way(Int,Char) and then sorted it and then mapped a function to reverse the tuple). Is there anything more efficient than this I can do?
14:19:01 <Kaidelong> well
14:19:10 <Kaidelong> if (>100) (+2) (*2) 50, for example
14:19:14 <joe1> > @ square
14:19:15 <lambdabot>   <no location info>: parse error on input `@'
14:19:17 <Kaidelong> which should give you 100
14:19:22 <joe1> > square
14:19:23 <lambdabot>   Not in scope: `square'
14:19:30 <Kaidelong> a good starting function to work with would be
14:19:36 <ezyang> What was the system of IO Haskell used before we invented monads? 
14:19:36 <mauke> Sina: yes, you can simply compare the second elements of each tuple
14:19:37 <Kaidelong> f True (x,y) = x
14:19:42 <Kaidelong> f False (x,y) = y
14:19:46 <dmwit> ezyang: interact
14:20:12 <ezyang> dmwit: Was there any literature published on the subject? 
14:20:22 <Sina> mauke: except doing `on` and importing Data.Function
14:20:30 <dmwit> Perhaps the Haskell retrospective has something on it.
14:20:36 <hpc> :t interact
14:20:38 <lambdabot> (String -> String) -> IO ()
14:21:00 <ezyang> (I'm trying to use monads versus stream IO to make a philosophical argument :-) 
14:21:08 <MrAI> Im still here... thinking
14:21:12 <Jonny> How is unzip defined in the prelude?
14:21:20 <Kaidelong> @src unzip
14:21:21 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
14:21:30 <Kaidelong> oh
14:21:30 <joe1> > if (>100) (+2) (*2) 50
14:21:31 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:21:38 <joe1> > (if (>100) (+2) (*2)) 50
14:21:39 <lambdabot>   <no location info>: parse error on input `)'
14:21:42 <Kaidelong> no that won't work
14:21:52 <ezyang> Hmm. How would people have done state with interact? 
14:22:21 <dmwit> I think before interact, people wrote their own C shell. But I'm not 100% sure of that.
14:22:29 <dmwit> As for state, I have no idea.
14:23:09 <ezyang> It's funny how we can't even imagine a world without monads anymore :-) 
14:23:21 <Veinor> a world... without monads?
14:23:22 <Sina> mauke: any idea?
14:23:27 <Veinor> what is this madness
14:23:30 <Kaidelong> > let f = case x of {True -> fst; False -> snd} in (uncurry (f (x < 100))) (x+2) (x*2) where x = 50
14:23:31 <lambdabot>   <no location info>: parse error on input `where'
14:23:35 <Eduard_Munteanu> I'm having troubles with doing an RGB->HSV->RGB conversion using Data.Colour. My input is RGB Word8, but I can't tell how to get RGB Word8 back from HSV. Any advice?
14:23:39 <hpc> Veinor: i can just imagine the movie
14:23:48 <mauke> <mauke> Sina: yes, you can simply compare the second elements of each tuple
14:23:51 <hpc> "in a world without monads, one programmer fights on..."
14:23:52 <Kaidelong> okay not good enough with single line haskell to get that going
14:24:05 <Veinor> In a world without abstract models of computation... ONE MAN
14:24:27 <hpc> it would be even worse than American Godzilla
14:24:29 * ezyang digs up the Haskell 1.2 report. 
14:24:31 <Eduard_Munteanu> I get that from an image represented as triples of Word8s: toSRGB24 $ sRGB24 r g b
14:24:34 <Kaidelong> > let f = case x of {True -> fst; False -> snd} in (curry (f (x < 100))) (x+2) (x*2) where x = 50
14:24:35 <lambdabot>   <no location info>: parse error on input `where'
14:24:37 <youngbull> dmwit: I have seen students invent the s ->(v,s) part of a function to use state so that it is not really unfeasable to just emulate State yourself... 
14:24:41 <MrAI> :D I was not thinking that at all, lol. I started learning functional programming also when I joined this channel ;)
14:24:41 <Jonny> is John Darlington known in here?
14:25:12 <Kaidelong> MrAI: I started learning functional programming with SCIP and then with Foundations of F# and Expert F#
14:25:20 <Kaidelong> and then moved to haskell
14:25:26 <hpc> Kaidelong: you mean SICP?
14:25:30 <Kaidelong> yes
14:25:33 <Kaidelong> SICP
14:25:39 <Sina> mauke: how to do that without `on` or importing Data.Functions ?
14:25:56 <hpc> Sina: write `on` :P
14:26:01 <hpc> @src on
14:26:01 <lambdabot> (*) `on` f = \x y -> f x * f y
14:26:23 <mauke> Sina: well, to extract the components of a tuple you use pattern matching
14:26:27 <mauke> Sina: to write functions you use \
14:26:32 <mauke> Sina: and to compare things you can use <
14:26:35 <youngbull> Like I said earlier Sina: ((<=) `on` snd) x y == (snd x) <= (snd y)
14:26:57 <MrAI> Ok back to http://learnyouahaskell.com/starting-out#ready-set-go I go, lol
14:27:05 <Sina> hpc: I can't . Its not a personal project. I am not supposed to know this `on` thing :)
14:27:14 <hpc> ah
14:27:28 <Sina> youngbull: how to put that in mergesort?
14:27:41 <youngbull> Sina: just make your own function and call it something else like foo x y = (snd x) <= (snd y)
14:28:21 <kmc> it should be noted that you could do IO in Haskell essentially the way it's done today, without monads
14:28:47 <ezyang> kmc: Sure. 
14:28:54 <kmc> the response is that you've made a monad, whether you know it or not
14:28:54 <Sina> youngbull: I don't understand. what do you mean by my own function ? I have a list of tuples that I want to sort by second element
14:29:08 <kmc> but you can do it without generalizing over all monads
14:29:47 <MrAI> I see Kaidelong - Did those steps really help?
14:30:45 <youngbull> Sina: http://pastebin.com/b0yYBMjC
14:31:21 <kmc> Sina, you're doing this for a class?
14:31:56 <Sina> kmc: university assignment
14:32:09 <MrAI> Sina for Neil Ghani?
14:32:11 <Sina> youngbull: I cannot modify the mergesort function.
14:32:17 <youngbull> what University Sina
14:32:18 <kmc> it is truly bizarre to say "I'm learning Haskell, so I'm not supposed to learn this `on` thing"
14:32:25 <Sina> MrAI: Neil Ghani ?!
14:32:30 <ezyang> :t on 
14:32:31 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:32:37 <kmc> i suspect that whatever system of education encourages such statements is deeply flawed
14:32:40 <MrAI> You would know who I was talking about if you knew him
14:32:43 <youngbull> Sina: then what are you allowed to do?
14:32:43 <Sina> youngbull: its in UK
14:32:52 <Kaidelong> MrAI: well it meant that picking up haskell was a lot easier since I was already familiar with functional programming in strict languages and the things left to pick up was laziness (which F# already does something with) and type classes
14:33:01 <ezyang> kmc: Usually, they're not trying to teach "Haskell" per se. 
14:33:23 <Sina> youngbull: use basic commands. :)
14:33:26 <kmc> ezyang, fine.  "I'm learning so I'm not supposed to learn"
14:33:27 <ezyang> If you're trying to teach how map works, telling them not to use the built-in map to implement map is a fine thing to say. 
14:33:28 <MrAI> I see Kaidelong. My background is definately different. I have only used OO before and procedural
14:33:34 <ezyang> kmc: Sure. :-) 
14:33:39 <kmc> ezyang, but the statement isn't "I'll learn this, but not use it"
14:33:39 <youngbull> Sina: define basic command.
14:33:51 <Kaidelong> MrAI: well that was where most of the people here were
14:34:03 <MrAI> :D
14:34:09 <Kaidelong> I did SICP first though and got a handle on some basic Scheme
14:34:22 <Sina> youngbull: like map, filter, foldr,zip, unzip, take, drop, ++, :, etc.
14:34:26 <Kaidelong> and then wrote some large programs in F# using a mix of functional and imperative programming
14:34:44 <Sina> youngbull: cannot import any other library or change anything that has been given
14:35:20 <mauke> Sina: do you know any Haskell at all? because to me it seems like all you've done is asking "and how do I do that?"
14:35:32 <youngbull> Sina: so you are to write the comparing function using functions from prelude?
14:36:31 <Sina> youngbull: basically yes. mauke: yes, I do. All I am asking is whether I can do things in a more efficient way or not.
14:36:59 <mauke> Sina: the answer to that is "yes"
14:37:28 <mauke> youngbull: it's not really 'comparing' because it has to return a Bool
14:38:02 <youngbull> Sina: the function is : \x y -> snd x <= snd y , wich is the sane as  (<=) `on` snd, wich you can give a name like foo by writing on a new line foo x y = snd x <= snd y
14:38:17 <Sina> mauke: and if yes, I want a way that can be expected from a beginner. I did learn a lot today here. but I cannot use anything I want, until our course finish (for the final assignment)
14:38:21 <youngbull> mauke: yes, sorry about that. Ofcourse it's not the comparing function....
14:38:50 <mauke> Sina: and that's what I and youngbull gave you
14:39:10 <mauke> youngbull even wrote the exact code you need for you to copy/paste
14:39:54 <Sina> mauke: and I am not asking someone to do my work. I just want ideas.
14:40:27 <youngbull> mauke: again sorry, I always speak before I think about these things... =D actually once one person fooled me into thinking he had read the same thing as me by letting me give all the answers in our conversation =D.
14:40:28 <mauke> <mauke> <mauke> Sina: yes, you can simply compare the second elements of each tuple
14:40:35 <Sina> youngbull: foo x y = snd x <= snd y can be used for only 2 tuples, right?
14:41:01 <monochrom> yes, only 2-tuples
14:41:16 <monochrom> @type snd
14:41:16 <youngbull> Sina: yes, but, you can only compare two things, giving the full relation is the transitive closure....
14:41:17 <lambdabot> forall a b. (a, b) -> b
14:41:26 <monochrom> does not anticipate (a,b,c)
14:42:33 <Sina> youngbull, well, I cannot use it inside the mergesort, can I ? it should be implemented inside the mergesort function, right?
14:43:01 <MrAI> Why does [3,2,1] > [2,10,100]
14:43:01 <MrAI>  come back as true? Is it just the head that is compared?
14:43:05 <youngbull> Sina: Now that I don't understand, I can make a mergesort with that function just fine!
14:43:19 <palyboy> MrAI: checks the heads first
14:43:25 <palyboy> then inward
14:43:46 <mauke> MrAI: why is "cba" > "bfz"?
14:43:50 <Sina> youngbull: I am not allowed to change the mergesort code. I can only use the mergesort function :)
14:44:05 <MrAI> Is it only the head it checks?
14:44:27 <Sina> youngbull: I understand your code and thanks a lot for the help, but I cannot change the mergesort function.
14:44:30 <mauke> MrAI: no
14:44:45 <youngbull> Sina: what does this mergesort look like?
14:44:49 <mauke> Sina: if you understand the code, why do you think you have to change the mergesort function?
14:45:08 <Sina> youngbull: right now, I map a function to reverse the elements which I guess is inefficient. but there seem to be no other way that I am allowed to use...
14:45:34 <Sina> youngbull: http://pastebin.com/FgD7jHSA
14:45:41 <mauke> Sina: why does your mergesort take 2 arguments?
14:46:10 <adimit> hexpat is managing to weird me out everytime I try to do something with it -.-
14:46:13 <MrAI> Can someone explain to me why [3,2,1] > [2,10,100]
14:46:14 <MrAI>  is true?
14:46:24 <MrAI> I get it checks the head first. But then what?
14:46:25 <mauke> MrAI: why is "cba" > "bfz"?
14:46:35 <Sina> mauke: it takes (<=) and a list and returns a list
14:46:54 <mauke> Sina: not just (<=)
14:46:58 <mauke> which is kind of the entire point
14:47:01 <dmwit> MrAI: Then it's done. 3 > 2, so why bother looking at the rest of the list?
14:47:16 <mauke> if you always had to pass the same argument, why make it a parameter at all?
14:47:49 <MrAI> Ah hmmm ok :s
14:48:23 <MrAI> If the head is true - it assumes the rest of the list is true in comparison?
14:49:00 <Sina> mauke: you mentioned I can use `on` but I cannot use that (not allowed to). and the function youngbull mentioned, I think it should be added in the mergesort.
14:49:01 <nus> MrAI, it doesn't care about the rest
14:49:06 <nus> @src (>)
14:49:06 <lambdabot> x >  y = case compare x y of { GT -> True;  _other -> False }
14:49:08 <MrAI> Ok Thanks.
14:49:11 <nus> @src compare
14:49:11 <lambdabot> compare x y | x == y    = EQ
14:49:11 <lambdabot>             | x <= y    = LT
14:49:11 <lambdabot>             | otherwise = GT
14:49:22 <benmachine> MrAI: question is what do you mean by > as applied to lists
14:49:26 <mauke> Sina: why do you think that?
14:49:50 <Sina> mauke: If I'm wrong, I'm sorry, but I am just a beginner
14:49:53 <MrAI> That was the first question I was ponder myself when I read this section :)
14:49:57 <MrAI> *ing
14:50:00 <youngbull> Sina: First off all have you tried using foo as the function?, I just did and it worked fine!
14:50:22 <benmachine> MrAI: there are several different ways you can compare lists, but the most natural one is just to compare corresponding elements until you run out
14:50:30 <MrAI> I see
14:50:34 <Sina> is (<=) a function that can be changed to anything?
14:50:40 <benmachine> MrAI: and the result is the first comparison that isn't equal
14:50:51 <MrAI> yep im with you :D Thanks
14:51:03 <youngbull> Sina: I don't understand your last question...
14:51:14 <youngbull> Sina: but have you tried using foo?
14:51:28 <Sina> I have: mergesort (<=) [tuples] . how to perform foo here?
14:51:47 <benmachine> Sina: what do you think mergesort (>=) [tuples] would do?
14:52:00 <Sina> youngbull: foo will work fine for 2 tuples. not more. right?
14:52:07 <nus> MrAI, <mauke> MrAI: why is "cba" > "bfz"?
14:52:07 <youngbull> Sina: mergesort (foo) [tuples] or mergesort (\x y -> (snd x) <= (snd y)) [tuples]
14:52:19 <Sina> benmachine: sorts the list of tuples based on the first elements.
14:52:25 <MrAI> Because c is greater than b
14:52:41 <MrAI> Strings are lists
14:52:50 <MrAI> lists of chars
14:53:01 <mauke> MrAI: what is your first language?
14:53:07 <bentael> hi, guys, i am new to haskell.  i have a function that uses guards, can someone give me a quick example on how can i modify such function so i can assign vars before getting to the switch like guards.
14:53:08 <Jonny> is haskell usually good with type inference?
14:53:09 <MrAI> Java is my main one
14:53:21 <youngbull> sina: or even better mergesort ((<=) `on` snd) [tuples]
14:53:24 <mauke> MrAI: no, I mean actual languages
14:53:27 <MrAI> English
14:53:49 <mauke> MrAI: do you know about alphabetically sorted lists such as dictionaries, telephone books, ...?
14:53:54 <MrAI> Yes
14:54:00 <companion_cube> Jonny, yes, but it's better to annotate your toplevel functions with types
14:54:00 <monochrom> haskell is very good with type inference
14:54:01 <mauke> well, then where's the problem?
14:54:06 <benmachine> Jonny: it depends on your standards for "good"; I don't know of any other languages with inference anywhere near as advanced as haskell's
14:54:12 <youngbull> bentael: just use a where clause...
14:54:18 <companion_cube> benmachine, maybe scala :)
14:54:25 <benmachine> companion_cube: I don't know of scala :P
14:54:28 <benmachine> well
14:54:28 <Jonny> Bentael: You can't assign variables like in imperative languages outside of a where clause
14:54:29 <Sina> youngbull: it works fine :) I didn't know I can use \x y -> (snd x) <= (snd y) in mergesort
14:54:30 <benmachine> I know *of* it
14:54:33 <benmachine> but nothing about it >_>
14:54:36 <Twey> Scala's isn't as powerful
14:54:44 <Twey> Also, it's impure >.>
14:54:59 <benmachine> Twey: you mean scala, or type inference in scala?
14:54:59 <companion_cube> scala's implicits are quite powerful
14:55:10 <benmachine> if type inference can have side effects then o_o
14:55:20 <Twey> Scala's inference isn't as powerful as Haskell's; Scala is impure
14:55:21 <Twey> Haha
14:55:24 <Twey> That would be… amusing
14:55:41 <monochrom> type inference has the side effect of causing you to believe in mind-reading
14:55:41 <companion_cube> Twey, it's impure but powerful :þ
14:55:59 <monochrom> or in computer intelligence
14:56:00 <Twey> So's Factor, and it's nicer
14:56:01 <youngbull> sina: there you go! I hope you will understand lambda abstractions now!
14:56:03 <companion_cube> many posts on lambda the ultimate are on scala recently
14:56:07 <bentael> Jonny, oh, so if i needed to use "let" what's my alternative for guards ?
14:56:25 <Twey> 22:54:04 < Sina> youngbull: it works fine :) I didn't know I can use \x y -> (snd x) <= (snd y) in mergesort
14:56:31 <Sina> youngbull: Thanks a lot. I learned something new here as well. I was blindly using this mergesort function without understanding what it does :)
14:56:32 <MrAI> Assuming the first goes underneath the second, I cant see it
14:56:33 <monochrom> of course, conversely, not knowing type inference has the side effect of causing you to believe in human intelligence
14:56:41 <Twey> Sina: \x y -> (snd x) <= (snd y) = on (<=) snd
14:56:46 <benmachine> bentael: 'where' after all the guards have finished
14:57:16 <benmachine> foo | test = rhs | test' = rhs' where rhs = thing
14:57:20 <benmachine> insert newlines in nice places
14:57:23 <benmachine> et voila
14:57:54 <youngbull> Twey: mentioned the on function earlier, but wasn't exepted due to this beeing homework...
14:58:01 <Sina> Twey: I know that. I cannot use on.
14:58:09 <youngbull> Twey accepted*
14:58:12 <aristid> type inference being a kind of reverse turing test?
14:58:19 <benmachine> Sina: you can't import it but you can define it easily
14:58:46 <monochrom> type inference being a kind of sufficiently advanced technology
14:58:57 <Twey> Sina: Why not?
14:59:03 <Twey> Oh
14:59:04 <Twey> Homework.
14:59:13 <Sina> Twey: due to this being homework and I'm not supposed to know that
14:59:23 <Sina> Twey: :)
14:59:29 <Twey> on (·) f x y = f x · f y
14:59:31 <Twey> >.>
14:59:33 <bentael> benmachine, thanks for the help and sorry for being picky; but what if I don't want to use guards anymore, how can i modiy the function's definition ? ( ill use a case of inside ) 
15:00:12 <benmachine> bentael: it depends what your guards are, put your function on hpaste.org and we'll see
15:00:41 <Jonny> you can use pattern matching instead of guards
15:00:57 <benmachine> Jonny: for some guards, yes
15:01:05 <benmachine> but guards can do things pattern-matching can't
15:01:09 <Jonny> true
15:01:21 <Twey> Not with view patterns!
15:01:35 <Jonny> but if he wants an alternative to guards...
15:01:35 <benmachine> Twey: I was just thinking that >_>
15:01:40 <Twey> :þ
15:01:46 <benmachine> I like how we have pattern guards now too
15:02:06 <kmc> "<Twey> Scala's inference isn't as powerful as Haskell's; Scala is impure"
15:02:10 <kmc> how does that follow?
15:02:38 <benmachine> foo x | (cond -> True) <- arg = result -- augh
15:02:54 <Twey> kmc: It doesn't
15:02:58 <kmc> oh, ok
15:03:06 <Twey> They are unrelated assertions (clarifications of points I made above)
15:03:13 <aristid> kmc: the ; indicates they are unrelated
15:03:23 <kmc> it sometimes indicates the opposite
15:03:29 <Twey> benmachine: I feel we should have syntax for Boolean views
15:03:42 <benmachine> Twey: ...guards?
15:03:45 <Twey> :þ
15:03:57 <kmc> view pattern guards!
15:04:10 <kmc> a guard is a boolean view pattern guard?
15:04:31 <mornfall> kmc: Stack overflow.
15:04:33 <benmachine> TypeDirectedViewPatternGuardInstances
15:04:43 <Twey> mornfall: You, sir, have an exceptionally small stack
15:04:55 <mornfall> Twey: Yeah, finite.
15:05:00 <mornfall> Stupid eh? : - )
15:05:08 <kmc> TypeDirectedViewPatternGuardInstanceSynonymFamilies
15:05:11 <Jonny> is pattern matching a haskell thing or a functional thing
15:05:19 <Twey> kmc: A.K.A. GlasgowExts ;)
15:05:24 <kmc> Jonny, it's a programming thing, often found in functional languages
15:05:26 <Twey> Jonny: A Haskell thing.
15:05:35 <Twey> Yes, not unique to Haskell
15:05:36 <benmachine> python has very very crude pattern matching
15:05:39 <benmachine> did I mention it's crude
15:05:42 <Twey> But it's a feature of Haskell, not a feature of functional programming.
15:05:47 <kmc> there's no reason non-functional languages should lack it
15:05:49 <Twey> benmachine: Does it?
15:05:55 <kmc> but there's also no reason languages should be non-functional, in the loose definition
15:05:59 <benmachine> Twey: well, on tuples
15:06:06 <Twey> Oh
15:06:07 <Twey> Right
15:06:14 <kmc> anyway languages with Haskell-like pattern-matching include Haskell, SML, OCaml, and Scala
15:06:15 <Twey> And dictionaries
15:06:16 <kmc> Erlang
15:06:26 <benmachine> you can pattern-match dictionaries? I did not know that
15:06:32 <kmc> Python has what i'd call "destructuring bind" rather than matching
15:06:40 <kmc> you can't give several alternatives or match literalsl
15:06:41 <Twey> benmachine: func(**somedict) unpacks somedict into keyword arguments
15:06:54 <benmachine> kmc: mm, I suppose so
15:06:58 <mornfall> kmc: Was it not in ML, before SML?
15:07:01 <Twey> Yes, true
15:07:05 <kmc> mornfall, i've no idea
15:07:13 <benmachine> python pattern matches can't "fail" except with TypeError or whatever silly thing it decides to throw you
15:07:31 <benmachine> but then not much in python fails except by throwing silly things at you
15:08:10 * benmachine notes with interest that x, y = 0 is TypeError but x, y = 1, 2, 3 is ValueError
15:09:09 * Twey scratches his head.
15:13:23 <companion_cube> why are monad transformers newtypes rather than types ?
15:13:57 <companion_cube> e.g. why is MaybeT m a  a newtype wrapper around  m (Maybe a) ?
15:14:02 <Eduard_Munteanu> How can I trace an exception to a line number with GHC?
15:14:12 <Eduard_Munteanu> Something like: (Array.!): undefined array element
15:14:20 <gwern> companion_cube: efficiency, perhaps. transformers can slow things down already
15:14:32 <benmachine> gwern: that's between newtype and data, not newtype and type
15:14:37 <benmachine> type just wouldn't work
15:14:40 <kmc> companion_cube, it is?
15:14:46 <gwern> benmachine: oh. maybe then it's information hiding?
15:14:50 <benmachine> companion_cube: m (Maybe a) already has a Monad instance
15:14:56 <benmachine> (the one for m)
15:15:00 <companion_cube> oh, ok
15:15:11 <kmc> i see
15:15:11 <benmachine> the MaybeT instance has different behaviour
15:15:15 <aristid> companion_cube: generally, newtype is slightly faster than data, so it's preferred
15:15:26 <companion_cube> but shouldn't the monad transformer behave like the monad ?
15:15:30 <kmc> no
15:15:31 <bentael> benmachine, sorry for the wait i was preparing the code, ok i pasted my original function here  http://hpaste.org/40846/partition_original , now before i start i have to tell u this is a homework that i am doing for class, i know the policy in here i am just trying to figure out the porblems that i am facing, here's what i did so far here, i created some kind of a pseudocode (mainly C ) because I can read it a lot easier than 
15:15:31 <bentael> haskell for me, but I kept some of the haskell expressions in it using html scripting like format example: (tail xlist) wrote it in this format <haskell> (tail xlist) </haskell> take a look if you have a chance thank you.  http://hpaste.org/40845/modified_partition_pseudocode
15:15:33 <companion_cube> aristid, my question was between type and newtype
15:15:52 <aristid> companion_cube: oh. type would not be possible because it would inherit all the unwanted instances
15:16:03 <kmc> companion_cube, «StateT s m a» is a wrapper on «s -> m (a,s)»
15:16:12 <Enigmatic> Eduard_Munteanu: you can with ghci, its not easy (and rarely always possible) to get a callstack from ghc compiled code
15:16:19 <kmc> the unwrapped monad instance for that would be ((->) s)
15:16:21 <benmachine> companion_cube: type MaybeT a = m (MaybeT a) would then reject instance Monad MaybeT where ... because the type synonym was not fully applied
15:16:26 <companion_cube> kmc, instead of m (s -> m a), you mean ?
15:16:31 <kmc> which is unrelated to m, and also unrelated to the desired behavior of StateT
15:16:32 <kmc> yeah
15:16:36 <companion_cube> but ok, I think i see
15:17:02 <Enigmatic> Eduard_Munteanu: run ":set -fbreak-on-exception" ":trace your_function_here" ":history" to get a stack in ghci
15:17:19 <companion_cube> monad transformers are hard :/
15:17:43 <aristid> companion_cube: no, no, they're not that hard. relax :)
15:18:01 <benmachine> bentael: this is too complicated for me to deal with atm, I've got to go and get food, maybe someone else can help you
15:18:35 <benmachine> companion_cube: monad transformers are pretty similar to monads, really. once you "get" newtype State s a = State { runState :: s -> (s, a) } then StateT s m a isn't all that different
15:18:35 <bentael> benmachine, no problem.
15:19:39 <aristid> benmachine: they ARE monads :)
15:20:20 * companion_cube still amazed how state can be expressed as functions
15:20:42 <aristid> benmachine: i wonder if future versions of GHC will optimize so well that there's no penalty to using monad transformers
15:21:14 <benmachine> aristid: they're functions from monads to monads >_>
15:21:22 <benmachine> and, who knows maybe
15:21:27 <aristid> benmachine: isomorphisms :)
15:21:30 <benmachine> inline the shit out of everything
15:21:32 <benmachine> aristid: nah
15:21:43 <benmachine> aristid: StateT s is a monad transformer, StateT s m is a monad
15:21:45 <aristid> you can construct and destruct them
15:21:53 <aristid> @mtl StateT s m a
15:21:53 <lambdabot> Maybe you meant: ft map msg pl unmtl url
15:21:59 <aristid> @unmtl StateT s m a
15:21:59 <lambdabot> s -> m (a, s)
15:22:06 <aristid> @mtl s -> m (a, s)
15:22:06 <lambdabot> Maybe you meant: ft map msg pl unmtl url
15:22:10 <aristid> wtf
15:22:14 <benmachine> heh
15:22:16 <aristid> why is there no @mtl anymore
15:22:22 <benmachine> was there ever?
15:22:24 <aristid> benmachine: anyway. that's an isomorphism
15:22:39 <benmachine> aristid: sure, but between what and what
15:22:47 <aristid> s -> m (a, s) <=> StateT s m a
15:23:01 <benmachine> okay, that's between one type and another
15:23:05 <companion_cube> there is an overhead with monad transformers if you only use the top monad ?
15:23:10 <benmachine> not between a monad transformer and a monad
15:23:12 <Peaker> I think "monad transformers" is a bad name.. "Stacked monads" or "Nested monads" would be more meaningful IMO
15:23:19 <dolio> Are you sure there was ever an @mtl?
15:23:24 <benmachine> monad transformer is a perfectly fine name
15:23:28 <aristid> benmachine: s -> m (a, s) is a monad too
15:23:33 <dolio> Because there's more than one way to give s -> m (a, s) an mtl type.
15:23:37 <aristid> dolio: no, i think there was
15:23:39 <benmachine> aristid: no it isn't, it's the wrong kind
15:23:45 <Eduard_Munteanu> Enigmatic: thanks, I figured out the culprit another way, but I'll remember this.
15:23:55 <dolio> Reader s (m (a, s)), for instance.
15:23:57 <aristid> benmachine: true
15:23:58 <Peaker> benmachine, are there monad transformers that don't nest monads?
15:24:04 <kmc> it was @unmtl
15:24:09 <kmc> @unmtl StateT s (ContT r) a
15:24:10 <lambdabot> err: `ContT r (a, s)' is not applied to enough arguments.
15:24:13 <benmachine> Peaker: what do you mean by nest?
15:24:20 <Enigmatic> Eduard_Munteanu: np
15:24:32 <kmc> @unmtl StateT s (ContT r (Reader p)) a
15:24:32 <lambdabot> s -> (a -> s -> p -> r) -> p -> r
15:25:07 <sadf3> bentael: what exactly is partition supposed to be doing?
15:25:23 <Peaker> benmachine, Hmm.. good question, can't think of a good definition of that.  I think the name should suggest the purpose/function, and not the mechanism by which it is achieved
15:25:26 <aristid> :t partition
15:25:27 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:25:55 <benmachine> Peaker: right. a monad transformer transforms monads into other monads :P
15:26:02 <companion_cube> oh my, ContT monad transformer
15:26:14 <benmachine> StateT s :: (* -> *) -> (* -> *)
15:26:17 <benmachine> one monad into another
15:26:18 <MrAI> What is the symbol for != in Haskell?
15:26:22 <benmachine> MrAI: /=
15:26:27 <bentael> sadf3, it takes a list of int, takes the head of it as a pivot, itirates through the rest of it placing what's less to the left and what's greater to the left
15:26:31 <MrAI> Thanks.
15:26:39 <ddarius> @quote not.not
15:26:39 <lambdabot> SyntaxNinja says: Fromagxo: NOT is not not in haskell, nor is "!", but rather, not.
15:27:39 <jmcarthur> Peaker: IMO, "monad transformer" is a fine name. there is only actually one monad in a stack of transformers, so calling it a stack of monads or nested monads sounds like it implies something that is not true
15:27:55 <bentael> sadf3, give me a minute i'll show u something 
15:28:22 <Peaker> jmcarthur, There are more monads being applied in succession to some value type
15:28:41 <jmcarthur> Peaker: if however it was a true composition of monads, e.g. (Monad m, Monad n, Comp (.)) => (m . n) a, then i would be more inclined to call it a stack of monads
15:28:51 <Peaker> Is there a way to interactively "walk" a GHC program's heap?   Profiling graphs are nice -- but can I freeze a program and see some values in there?
15:28:54 <jmcarthur> even then, "stack" doesn't seem right to me
15:29:29 <sipa1024> jmcarthur: maybe thats possible
15:29:36 <jmcarthur> sipa1024: it is possible
15:29:45 <jmcarthur> sipa1024: http://web.cecs.pdx.edu/~mpj/pubs/composing.html
15:29:52 <sipa1024> only use monad transformers
15:29:57 <sipa1024> ah, ok
15:30:30 <davekong> Anyone know how to get haskell syntax highlighting in hgweb? I installed pygments, but it does not seem to work for haskell
15:31:14 <jmcarthur> Peaker: vacuum?
15:31:47 <jmcarthur> it's not really interactive. it just shows you a data structure
15:32:14 <Peaker> jmcarthur, I want to take a real-world program with gigabytes of data, and randomly walk its heap to get an idea of where memory is going, because seeing (:) as the most memory-heavy constructor isn't very helpful :)
15:32:33 <benmachine> ReaderT r m ~= (->) r . m I guess
15:32:40 <Peaker> (Well, it seems newtypes may also get unpacked in the profiling results so you also get W32# and W64# and such
15:33:22 <jmcarthur> benmachine: roughly
15:33:34 <jmcarthur> well, in that case i think it's correct
15:33:44 <jmcarthur> but you also have to specify what kind of composition
15:33:56 <Peaker> A guy at work wrote a Haskell program to parse DWARF debug info from very large executables, and use it to parse some output, and it initially took gigabytes of memory.  Installing profiling libraries was a pain, and using those he eventually managed to fix space use, but it would have probably been easier to sample the heap interactively
15:33:58 <jmcarthur> which is admittedly a bit of a hassle
15:35:16 <benmachine> jmcarthur: I meant in the sense of (f . g) a = f (g a)
15:36:41 <jmcarthur> yeah
15:36:55 <bentael> sadf3, ok let's start again, here's the original function, the instructions for this assigment are strick and clear, i have to rewrite this function here http://hpaste.org/40848/partition_original  and combine the two inner function in one function, add a flag to tell it how is the direction AND here's the worst part, it has to call it self ONLY ONCE by definition, here's what ive been working on,  my function works fine the o
15:36:55 <bentael> nly problem is that I am not sure how can i change it even more to make call it self only once. check here http://hpaste.org/40847/my_partition
15:37:13 <MrAI> Is there a function to remove multiples from a list? e.g. [2,2] would become [2]?
15:37:37 <jmcarthur> MrAI: maybe you could check out nubBy
15:37:54 <jmcarthur> MrAI: oh, by multiples do you mean duplicates?
15:37:57 <MrAI> Yes
15:38:00 <jmcarthur> nub
15:38:00 <adimit> that's nub.
15:38:08 <MrAI> Thanks
15:38:15 <jmcarthur> > nub [2,5,4,2,7,4]
15:38:16 <lambdabot>   [2,5,4,7]
15:38:23 <MrAI> Thanks :D
15:38:23 <adimit> beware. it's fiendishly inefficient on large inputs.
15:38:35 <jmcarthur> on the other hand, it's lazy :)
15:38:46 <adimit> yeah. I mean, the task itself is just complex.
15:39:12 <jmcarthur> i guess it could still be made more efficient and still be lazy
15:39:18 <jmcarthur> it would just require Ord rather than Eq
15:39:24 <jmcarthur> or some other constraint
15:39:31 <companion_cube> with a Set ?
15:39:39 <jmcarthur> that would be a way
15:39:45 <dmwit> With two Sets and an IntMap!
15:39:57 * hackagebot xmonad-extras 0.9.2 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.9.2 (AdamVogt)
15:39:58 <jmcarthur> o_O
15:40:14 <aristid> with Enum and only an IntMap!
15:40:20 <Kaidelong> does anyone know a good tutorial for learning how to get started with Cabal?
15:40:33 <dmwit> copy somebody else
15:40:43 <dmwit> Then, when you feel adventurous, read the fine manual.
15:40:44 <adimit> is it cheaper to pack strings or to unpack them? For that matter, is it cheaper to compare Strings or to compare byteStrings? I'm guessing it's cheaper to compare BS and to convert to BS.
15:41:02 <Kaidelong> so I just download a tarball and check out the cabal files in it?
15:41:07 <aristid> adimit: beware, bytestrings are not optimal for dealing with unicode data
15:41:07 <Kaidelong> and try to reverse engineer that?
15:41:22 <FunctorSalad> Kaidelong: there's also "cabal init"
15:41:22 <bentael> Hi again guys, looks like my tutor has left, can someone help in a homework (i know the policy i just need a hint )
15:41:30 <dmwit> Kaidelong: Sure. Dunno if "reverse engineer" is really the right word for such a trivial format.
15:41:40 <Kaidelong> cabal is a trivial format?
15:41:43 <jmcarthur> cabal init is probably a good way to get started, but alone it is not enough to make a working build
15:41:50 <Kaidelong> hmm well that'd make it an exception as far as project systems go
15:41:51 <dmwit> cabal is a very trivial format.
15:41:52 <adimit> aristid: I'm dealing with Hexpat's GenericXMLString. I know of the encoding problems, but right now i'm trusting the author of hexpat to have done The Right Thing.
15:41:58 <jmcarthur> actually maybe with the comments it's enough to guide you
15:42:04 <jmcarthur> i normally use cabal init -m
15:42:17 <aristid> adimit: heh looks like everybody is doing xml parsers these days
15:42:19 <enthropy> dmwit: cabal has layout and such
15:42:20 <adimit> I'll see if there are any issues, but I can't parse 500MB+ sized XMLs from Strings. That's just cruel.
15:42:25 <gwern> I wonder if there is a better way to sort lines in a file without usings B.lines to turn it into [ByteString], running sort & nub on that, and then concating it
15:42:32 <jmcarthur> enthropy: trivial for people, not for computers ;)
15:42:38 <dmwit> enthropy: yes, and...?
15:42:39 <Jonny> bentael: what are you having trouble with?
15:42:52 <aristid> adimit: XML is not made to be 500 MB big, at least it doesn't really work out for that
15:42:59 <enthropy> exactly, it's not easy to write a parser for it
15:43:11 <adimit> aristid: I'm not really doing an XML parser. I just have a humungous XML corpus I want to convert to Haskell ADTs lazily.
15:43:19 <adimit> aristid: yeah. Tell that to a Linguist.
15:43:31 <sadf3> bentael:does it do the same thing as partition (x:xs) = (filter (<= x) xs) ++ [x] ++ (filter (> x) xs)?
15:43:32 <adimit> i'll work with what I get :-\
15:43:34 <dmwit> enthropy: If he were writing a parser, he'd ask for a reference, not a tutorial.
15:43:45 <jmcarthur> gwern: are the lines all an equal number of bytes or anything nice like that?
15:43:45 <bentael> YES
15:43:54 <bentael> sadf3, yes
15:43:54 <aristid> adimit: heh. have you seen my package xml-monad btw? *just randomly advertising it*
15:44:14 <gwern> jmcarthur: nah, random urls
15:44:17 <bentael> sadf3, but i cannot use that
15:44:22 <gwern> jmcarthur: separated by newlines obviously
15:44:26 <sadf3> bentael:right i get it
15:44:26 <adimit> aristid: yet ANOTHER haskell xml package? dear lord. I'll have a look at it, thanks.
15:44:43 <adimit> can it read byteStrings or Text? Because that's the only way I'm even gonna consider it :-P
15:44:56 <jmcarthur> gwern: well, nub of course isn't a great choice
15:45:12 <jmcarthur> gwern: map head . group . sort  :D
15:45:24 <dmwit> woot, started with a ring of polymorph control
15:45:25 <gwern> jmcarthur: on some inputs that's really terrible, iirc
15:45:31 <aristid> adimit: it isn't really a full parser, just an interface to a parser
15:45:39 <MrAI> Boom my first success in Haskell :D sum [x | x <- [0..999], x `mod` 3 == 0 || x `mod` 5 ==0 || x `mod` 15 == 0]
15:45:44 <jmcarthur> gwern: why? lots of common prefixes?
15:45:45 <gwern> jmcarthur: the fromList . toList Set trick doesn't blow up on you
15:45:50 <gwern> jmcarthur: yeah
15:45:51 <jmcarthur> gwern: probably best with a trie or something
15:46:04 <Twey> MrAI: The last clause is redundant
15:46:12 <adimit> aristid: aye, just looked at the API. The parser is supposed to be instance of ReaderM?
15:46:18 <MrAI> Ah ok
15:46:18 <gwern> MrAI: anything divisible by 15 is divisible by 5, no?
15:46:22 <Twey> MrAI: If mod x 15, mod x 3 && mod x 5
15:46:26 <MrAI> haha true
15:46:29 <aristid> adimit: and ExceptionM
15:46:42 <gwern> truly, 'a year in AI is enough to make one believe in God'
15:46:49 <aristid> adimit: there's a supplied type that matches these constraints, Xml
15:47:06 <aristid> adimit: parseXMLDoc parses xml
15:47:26 <ddarius> gwern: Give AI researchers a few billion years and they'll probably manage something by then.
15:47:35 <MrAI> Nah
15:47:36 <adimit> aristid: hmm... interesting. This might come in handy as an interface to Hexpat's SAX stuff.
15:47:38 <MrAI> We are close with AI
15:47:42 <MrAI> Or fool'ish AI
15:47:46 <gwern> ddarius: my quote is ironic because of MrAI
15:47:49 <MrAI> :D
15:47:49 <adimit> parsing SAX is *such* a pain.
15:47:53 <MrAI> lol oooo
15:47:59 <aristid> adimit: well yeah you would have to adapt it for that, right now it's really based on the xml package
15:48:18 * gwern believes insults should both be subtle and educational
15:48:55 <adimit> aristid: yup. I'll do that before writing my own combinators though. I did implement basic combinators based on Wadler and Hutton&Meijer.
15:49:00 <adimit> but XML can do more.
15:49:45 <companion_cube> wow, i just realized that liftM and fmap are conceptually the same thing
15:49:58 <Twey> companion_cube: Hehe
15:50:04 <zity> is somebody understanding this : http://pastebin.com/J4LpHWjh ? I want to make a short example program which return me "False, Jenny is 17 years old", can someone complete this please ?
15:50:21 <aristid> adimit: if nothing else, you can use my stuff as inspiration :)
15:50:26 <hasenov> hello, for a project in class i would like to write a report on compiling ghc with llvm
15:50:31 <adimit> aristid: I shall :-) Thanks for the pointer!
15:50:40 <hasenov> however im interested in focusing it on multicore
15:50:57 <sadf3> what is the difference betweem liftM and fmap?
15:51:10 <hasenov> would someone be able to point me to good benchmarks i could use for parallel programs?
15:51:18 <enthropy> sadf3: the names involved
15:51:35 <aristid> and the typeclasses involved
15:51:37 <aristid> :t fmap
15:51:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:51:39 <aristid> :t liftM
15:51:40 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:51:51 <dmwit_> zity: That feels very homework-y.
15:52:02 <tehgeekmeister> what does a "bus error" from ghci mean?  (i was raising very large numbers to powers, if that's relevant.)
15:52:03 <hasenov> the data parallell haskell i would probably check out, i was wondering if there were others
15:52:24 <dmwit_> zity: We'll be happy to help if you have a more specific question, but "write this program" isn't really an okay question.
15:52:31 <Twey> zity: main = putStrLn "False, Jenny is 17 years old"
15:52:38 <Twey> Done
15:52:50 <dmwit> ...so you're liable to get smart-ass answers like that one. ;-)
15:52:53 <Twey> :þ
15:53:01 <ddarius> Twey: That output "False, Jenny is 17 years old\n"
15:53:12 <Twey> It's true
15:53:31 <zity> dmwit, it isn't my whoole program, just an example, i have to do it for about a hundred other operators like Select, reject, etc...
15:54:13 <zity> No problem i'll search
15:54:24 <sadf3> monads are functors aren't they?
15:54:59 <Twey> sadf3: Conceptually
15:55:06 <zity> Twey so funny...
15:55:18 <Twey> sadf3: Sadly, Haskell doesn't enforce that, but any sensible Monad should also be a Functor.
15:55:43 <sadf3> Twey:ah i get it :)
16:01:35 <tehgeekmeister> what is wrong with this definition of the tetration function?  it can't go higher than n = 3 without causing a runtime error for me.
16:01:37 <tehgeekmeister> tet :: Integer -> Integer -> Integer
16:01:37 <tehgeekmeister> tet 1 a = a
16:01:37 <tehgeekmeister> tet n a = a ^ (tet (n -1) a)
16:02:54 <sipa1024> :t (^)
16:02:55 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
16:03:17 <sipa1024> > let { tel 1 a = a; tet n a = a ^ (tet (n - 1) a) } in tet 3 2
16:03:19 <lambdabot>   *Exception: stack overflow
16:03:40 <dmwit> > let tet 1 a = a; tet n a = a ^ (tet (n - 1) a) in tet 3 2
16:03:41 <lambdabot>   16
16:03:56 <tehgeekmeister> tet 3 3 is 7625597484987; it gets big quick.
16:04:01 <dmwit> > let tet 1 a = a; tet n a = a ^ (tet (n - 1) a) in tet 4 2
16:04:02 <lambdabot>   65536
16:04:08 <dmwit> > let tet 1 a = a; tet n a = a ^ (tet (n - 1) a) in tet 4 3
16:04:13 <lambdabot>   mueval: ExitFailure 1
16:04:17 <sipa1024> wth does it make a difference whether i put { } around it or not?
16:04:22 <dmwit> 7625597484987 is not big
16:04:26 <dmwit> sipa1024: you misspelled tet
16:04:31 <sipa1024> ow
16:04:33 <sipa1024> loi
16:04:39 <sipa1024> > let { tet 1 a = a; tet n a = a ^ (tet (n - 1) a) } in tet 3 2
16:04:40 <lambdabot>   16
16:04:41 <sipa1024> > let { tet 1 a = a; tet n a = a ^ (tet (n - 1) a) } in tet 3 5
16:04:42 <lambdabot>   191101259794547752035640455970396459919808104899009433713951278924652053024...
16:04:48 <sipa1024> > let { tet 1 a = a; tet n a = a ^ (tet (n - 1) a) } in tet 4 4
16:04:53 <lambdabot>   mueval: ExitFailure 1
16:05:20 <dmwit> tehgeekmeister: So, what runtime error do you get?
16:05:35 <tehgeekmeister> [3,27,7625597484987,zsh: bus error  ghci tet.hs +RTS -M600m
16:05:44 <tehgeekmeister> (as you can see i tried making the heap bigger.)
16:05:58 <dmwit> Wow, bus error?
16:05:59 <sipa1024> what is your code precisely?
16:06:05 <tehgeekmeister> i copied and pasted it
16:06:07 <tehgeekmeister> that's the whole file
16:06:18 <tehgeekmeister> i just felt like implementing tetration for fun
16:06:30 <sipa1024> ok, and what's the query?
16:06:48 <tehgeekmeister> map (flip tet 3) [1..]
16:06:51 <tehgeekmeister> if i understand what you're asking?
16:07:29 <sipa1024> so you're evaluating [tet 1 3, tel 2 3, tel 3 3, tet 4 3, ...] ?
16:07:38 <tehgeekmeister> yep
16:07:43 <tehgeekmeister> it dies on 4 3
16:07:47 <sipa1024> > let { tet 1 a = a; tet n a = a ^ (tet (n - 1) a) } in tet 4 3
16:07:52 <lambdabot>   mueval: ExitFailure 1
16:08:22 <guest2425> hello
16:09:25 <dmwit> hiya
16:09:33 <Eduard_Munteanu> What would you recommend for drawing a scaled up (nearest interpolation) 2D array of pixels in GTK?
16:09:35 <sipa1024> zity: please don't pm me
16:09:39 <sipa1024> you can ask here
16:09:39 <dmwit> tehgeekmeister: Dunno why you'd get a bus error.
16:09:41 <Eduard_Munteanu> I looked at pixmap but I can't tell how to write in it.
16:09:58 <Eduard_Munteanu> I'd also like it to be fast, my current Cairo implementation drawing rectangles is kinda slow.
16:10:02 <tehgeekmeister> dmwit: i don't even know what a bus error is
16:10:03 <tehgeekmeister> *googles
16:10:06 <guest2425> Eduard_Munteanu: thanks I got it
16:10:25 <tehgeekmeister> does ghc use some library for big integer operations?
16:10:25 <Eduard_Munteanu> guest2425: you should really ask here, I have problems of my own.
16:10:32 <dmwit> Eduard_Munteanu: Drawing to what? Screen? File? SVG? ...?
16:10:45 <Eduard_Munteanu> dmwit: screen. A GTK drawable surface.
16:10:53 <guest2425> oh ok
16:11:17 <Eduard_Munteanu> dmwit: consider I have to draw a succession of frames, some sort of animation I compute at runtime.
16:11:19 <ddarius> tehgeekmeister: 3^(3^27) takes almost a gigabyte to represent assuming a normal bitwise representation and no overhead.
16:11:27 <dmwit> tehgeekmeister: phew, started swapping trying to reproduce your problem
16:11:34 <dmwit> tehgeekmeister: I forgot how horrible swap memory was almost.
16:11:37 <guest2425> Hi everyone
16:11:41 <co_dh> good morning guys,  does anybody knows why the following code is not working ? 
16:11:42 <guest2425> I have a question
16:11:42 <co_dh> : http://hpaste.org/40832/gadt_pattern_match
16:11:48 <co_dh> it's about gadt. 
16:11:53 <tehgeekmeister> ddarius: that would explain it.
16:12:43 <dmwit> Eduard_Munteanu: I recommend you figure out how to write into a Pixmap. =)
16:12:45 <dmwit> It's not hard.
16:13:13 <sipa1024> co_dh: Tree is a constructor and not a type
16:13:30 <sipa1024> co_dh: so you can't use in the type definition of Tree itself
16:13:32 <dmwit> Sorry, I meant Pixbuf, of course.
16:14:01 <Eduard_Munteanu> dmwit: uhm, sorry, I rather meant Pixbuf. Pixmap seems to be a Drawable, which is easy, but I can't figure how to clone the offscreen Pixmap.
16:14:04 <sipa1024> co_dh: or do you try to refer to some other Tree that hasn't been included in the paste?
16:14:19 <Eduard_Munteanu> dmwit: there's drawPixbuf for Pixbufs.
16:14:38 <co_dh> sipa1024,  yes . 
16:14:40 <tehgeekmeister> ddarius: so basically without doing something exceptionally tricky (and i'm not sure what or if there's anything that's possible) tetration is just not a reasonable project on a regular, old machine?
16:14:54 <co_dh> data Tree a = Empty | Node (Tree a ) a (Tree a )
16:14:54 <co_dh>             deriving (Show)
16:14:58 <dmwit> Eduard_Munteanu: pixmapNew looks like it will clone a pixmap...?
16:15:20 <co_dh> the error comes from the line Empty :. Tree a 
16:15:21 <sipa1024> co_dh: and what about Text ?
16:15:33 <ddarius> tehgeekmeister: It's not really reasonable at all.  If you want to manipulate such things, you will need a different numeric representation, even for display as I doubt you want to look at a few billion digits.
16:15:35 <dmwit> Eduard_Munteanu: Oh, whoops, sorry, I read the docs wrong. Let's see...
16:15:43 <co_dh> Data Text = Text String
16:15:44 <co_dh>           | NL
16:15:44 <co_dh>           | Indent Int Text
16:15:44 <co_dh>           | Text :<> Text
16:15:53 <Eduard_Munteanu> dmwit: pixbufGetFromDrawable
16:15:55 <co_dh> these are sample from 
16:16:01 <Eduard_Munteanu> dmwit: sorry, I'm a bit tired, I found it ^
16:16:04 <Eduard_Munteanu> Thanks.
16:16:05 <dmwit> great
16:16:17 <tehgeekmeister> ddarius: okay.  i just couldn't find any wolfram alpha function that did it and was bored.  certainly not interested in spending lots of time on this.
16:16:18 <co_dh> "Generic Programming , Now! "
16:16:56 <dancor> how do you create a piecewise signal in yampa SF Time Int that is 10 for 1s then 20 for 1s?
16:17:18 <tehgeekmeister> ddarius: this has taught me to put representative numbers into wolfram alpha to find there power of ten representation to figure out just how unreasonably large a number i'm about to be working with.
16:17:19 <ddarius> tehgeekmeister: Suffice it to say, tet 5 3 would take more memory to represent in the standard notation than can be cobbled together with all the matter in the known universe.
16:17:51 <sipa1024> co_dh: data Text, not Data Text?
16:18:19 <tehgeekmeister> ddarius: i tend to pick really hard problems like this when i'm bored and want something to do.  i should stop that.
16:18:41 <ddarius> tehgeekmeister: It would not be very difficult to implement a different notation that would let you manipulate these.
16:18:56 <tehgeekmeister> ddarius: what would i need to read up on to look into that?
16:19:23 <dmwit> data TetNotation = Tet Integer Integer -- I can now represent all values that are tetrations
16:19:51 <ddarius> tehgeekmeister: You can probably find something, but it's probably quicker to think up your own notation.
16:20:14 <co_dh> sipa1024 , should be data Text. my emacs change word to upcase some times. 
16:20:20 <tehgeekmeister> that still doesn't give me the minimum i want.  power of ten representations of the numbers are the minimum i want for this to be interesting.  but i might be able to do that with logarithms?
16:20:20 <ddarius> Essentially you'll have a sparse representation of the positional notation, or perhaps a purely symbolic form.
16:20:21 <Eduard_Munteanu> dmwit: drawPixbuf seems to do no scaling... drawPixbuf d gc pb srcX srcY destX destY srcWidth srcHeight dither
16:20:35 <gwern> dmwit: I hope your Tet -> Integer function comes with a warning in the haddocks :)
16:20:45 <Eduard_Munteanu> I wonder if it's fast enough if I draw rectangles into it.
16:20:48 <co_dh> it looks like Haskell's implementation of GADT is not complete, am I right ? 
16:21:13 <ddarius> tehgeekmeister: You could use logarithms of sorts.  You'll need to figure out what the operations look like in logarithmic space, which shouldn't be hard at all.  You will still get very big numbers very quickly.
16:21:34 <Eduard_Munteanu> drawPixbuf :: DrawableClass d => d -> GC -> Pixbuf -> Int -> Int -> Int -> Int -> Int -> Int -> Dither -> Int -> Int -> IO ()
16:21:40 <co_dh> it not able to compile code like Empty :. Tree a because 'a' is not a rigid (concrete )type here .  
16:21:44 <Eduard_Munteanu> Uh crap, sucky documentation, I reckon the latter two args are sizes.
16:21:44 <co_dh> am I right? 
16:21:51 <ddarius> But it will be more like factorial or exponential, instead of way beyond exponential.
16:22:35 <dancor> ddarius: tet 5 3 is 5^(5^5)?
16:22:52 <dmwit> dancor: no, it's 5^(tet 4 3)
16:23:08 <sipa1024> co_dh: i suppose
16:23:18 <sipa1024> i don't know the details
16:23:20 <tehgeekmeister> ddarius: i meant using logarithms to convert to a representation with different powers
16:23:28 <co_dh> sipa1024: thanks. 
16:24:02 <tehgeekmeister> like wolfram alpha does: http://www.wolframalpha.com/input/?i=3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3^3
16:24:14 <tehgeekmeister> baaaaaah needs bitly
16:24:26 <tehgeekmeister> http://bit.ly/bYo4vc
16:25:25 <dancor> dmwit: are you saying tet a n = a^(tet (a-1) n)?  that doesn't seem right..
16:26:00 <dmwit> whoops
16:27:30 <ddarius> tehgeekmeister: That would be quite easy to do.
16:27:46 <tehgeekmeister> yeah, i'm looking into stuff on wikipedia about logarithms right now
16:28:57 * dancor looks in logs.  tet n a = a ^ (tet (n - 1) a)
16:31:24 * dancor likes a `op` n.  what are you going to do for pentation?
16:32:28 <dancor> a^^n is another notation for tetration, more amenable to computers than the (^n)a oddness.
16:33:18 <sipa1024> @tell co_dh use this: pretty ( x :. Tree a ) = case x of { Empty -> Text "Empty" }
16:33:19 <lambdabot> Consider it noted.
16:35:07 <Martty> i need..a book
16:35:12 <Martty> a good haskell book
16:35:31 <MrAI> I've got Fib(n) working, but how would I store the results and stop it once it reaches past 4million? I can show you what I have
16:35:37 <tehgeekmeister> dancor: i suppose i could make a general framework for any level of power towers, etc
16:35:46 <tehgeekmeister> MrAI: hpaste it
16:35:53 <tehgeekmeister> i'll take a look
16:36:02 <MrAI> fib :: Int -> Int
16:36:02 <MrAI> fib 0 = 0
16:36:02 <MrAI> fib 1 = 1
16:36:02 <MrAI> fib n = fib(n-1) + fib(n-2)
16:36:02 <MrAI> test:: [Int]
16:36:05 <MrAI> test = [fib(x)| x <- [2..100], x < 4000000]
16:36:07 <MrAI> I know its dirty :)
16:36:52 <MrAI> I think im on the right track
16:37:33 <tehgeekmeister> i don't think you should (even if you can) define the same variable twice in a comprehension?
16:37:42 <mauke> tehgeekmeister: huh?
16:38:16 <nus> MrAI, fib(x) ?
16:38:29 <tehgeekmeister> a simpler way to do this would be takeWhile (<4000000) $ map fib [1..]
16:38:45 <MrAI> It works nus, lol
16:39:18 <hpc> it is stylistically yucky
16:39:21 <MrAI> I've not got to while loops yet
16:39:24 <nus> MrAI, it'd even if you add a dozen of 'em
16:39:39 <hpc> there's no while loops in haskell
16:39:41 <tolkad> this code is failing with a segmentation fault how to fix? http://codepad.org/0rpHJ5YI
16:40:23 <MrAI> nus: huh?
16:40:24 <Martty> whats the opposite to a constructed type?
16:40:32 <tolkad> I'm using some code by dolio,forgot to attribute him in source
16:40:34 <Martty> like 2 as opposed to Maybe 2
16:40:43 <mauke> Martty: 2 is not a type
16:40:50 <Martty> well, x as opposed to Maybe x
16:41:07 <Martty> i guess just "type" does it >_<
16:41:12 <tehgeekmeister> MrAI: let me find you my favorite fib generator in haskell
16:41:14 <mauke> Maybe x is a type
16:41:18 <MrAI> ok :d
16:41:20 <MrAI> :D
16:41:26 <Martty> Maybe Int is a constructed type
16:41:30 <Martty> Int is a .. type ?
16:41:38 <Martty> built-in type?
16:41:42 <mauke> no
16:41:49 <mauke> Maybe Int and Int are types
16:42:13 <tehgeekmeister> MrAI: i say nothing about the efficiency of this (it might actually be efficient, i just don't know.); fibs = 0:1:zipWith (+) fibs (tail fibs)
16:42:29 <Martty> i dont get it, whats the difference between fmap and map?
16:42:30 <tehgeekmeister> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
16:42:31 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:42:31 <mauke> that's pretty efficient
16:42:41 <mauke> Martty: fmap is more general, map only works on lists
16:42:49 <hpc> :t map
16:42:49 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:42:50 <hpc> :t fmap
16:42:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:42:52 <tolkad> Martty: Int is a type provided by the haskell standard library according to the Haskell 98 report
16:42:55 <tehgeekmeister> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs!!1000
16:42:55 <lambdabot>   <no location info>: lexical error at character '\GS'
16:43:12 <tehgeekmeister> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs!!100
16:43:13 <lambdabot>   354224848179261915075
16:43:18 <tehgeekmeister> yeah, that's pretty efficient
16:43:25 <MrAI> haha
16:43:36 <MrAI> How would I store the results in a list then?
16:43:41 <mauke> MrAI: what
16:43:45 <mauke> that was a list
16:43:45 <Martty> wait so [] is the type constructor for lists
16:43:49 <tolkad> Martty: yes
16:43:51 <Martty> OMG im so confused now
16:43:57 <tolkad> :t String
16:43:58 <lambdabot> Not in scope: data constructor `String'
16:43:59 <kmc> [T] = [] T
16:44:02 <Martty> > [] 2
16:44:03 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
16:44:08 <tolkad> :k []
16:44:09 <lambdabot> * -> *
16:44:10 <kmc> > let x :: [] Int; x = [2,3] in x
16:44:11 <lambdabot>   [2,3]
16:44:23 <tolkad> :T ['a']
16:44:28 <tolkad> :t ['a']
16:44:28 <lambdabot> [Char]
16:44:37 <kmc> :t ['a'] :: [] Char
16:44:37 <lambdabot> [Char]
16:44:44 <Martty> OH
16:44:46 <Martty> type constructor
16:44:51 <MrAI> What does WinHugs not like the 'let'? :s
16:44:56 <mauke> data [] a = [] | (:) a ([] a)
16:45:12 <hpc> hugs is not as featureful as GHC
16:45:21 <Martty> that's good, mauke 
16:45:28 <kmc> tolkad, where did you get that code?
16:45:36 <tolkad> kmc: most of it is from dolio
16:45:42 <Martty> that's.. very good
16:45:45 <tehgeekmeister> MrAI: use the haskell platform for your sanity's sake
16:45:46 <kmc> oh, you're using unsafeCoerce
16:45:46 <Martty> i gotta write that down on my arm
16:45:50 <tolkad> kmc: I said so a few lines later
16:45:53 <kmc> oh, you're defining unsafeCoerce
16:46:11 <MrAI> The what? lol
16:46:11 <enthropy> some ghc extensions don't play nice
16:46:18 <kmc> does this correspond to a known ghc bug?
16:46:23 <MrAI> Im using WinHugs with a loaded .hs file
16:46:49 <tehgeekmeister> MrAI: google it
16:46:50 <Sina> guys, I need to decrypt a message by just guessing based on the english language frequency. Does anyone know a website doing this?
16:46:51 <kmc> probably #1496
16:47:02 <mauke> Sina: project euler?
16:47:04 <tolkad> Martty: so the instance of Functor for [] might look like: instance Functor [] where fmap f list = case list of { [] -> []; (x:xs) -> f x : fmap f xs }
16:47:16 <tolkad> :t fmap
16:47:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:47:18 <MrAI> ok
16:47:24 <kmc> anyway tolkad, pasting known test cases for known bugs and then asking "how to fix" is not so helpful
16:47:25 <monochrom> WinHugs is just fine.
16:47:26 <MrAI> Downloading...finished
16:47:42 <kmc> if you think it's a new bug, or you have some insight about the existing bug, please share that information
16:47:47 <kmc> probably here and also on the ghc trac
16:47:48 <Martty> tolkad: too advanced, give me 1 more month
16:47:59 <tolkad> kmc: yeah I was looking for a workaround
16:48:02 <kmc> or in #ghc, or on their mailing lists
16:48:02 <kmc> ah
16:48:11 <kmc> well workaround would depend on what it is you're actually trying to do
16:48:14 <tolkad> kmc: to make that code work
16:48:26 <tolkad> actually I guess if the bug is fixed
16:48:28 <monochrom> delete all code
16:48:29 <tolkad> that code wont compile
16:48:31 <tolkad> so nevermind
16:48:35 <kmc> the code is pretty cryptic, it's not clear what you're trying to do
16:49:03 <tolkad> kmc: I was trying to use the "id" function as IO ()
16:49:11 <kmc> well you should expect that to segfault ;P
16:49:34 <Sina> mauke: what is project euler?
16:49:53 <aristid> Sina: google it :)
16:50:13 <mauke> ah, that's a "no" then :-)
16:50:19 <kmc> tolkad, it mystifies me why you have this urge to troll the GHC developers
16:50:24 <MrAI> hmmm ok this platform was pretty much what I was using
16:50:34 <kmc> when you're clearly capable of being helpful and a reasonable person
16:50:34 <tolkad> Martty: a case expression is just like pattern matching in a function declaration. « f True = True; f False = False » is equivalent to « f x = case x of { True -> True; False -> False } »
16:50:38 <kmc> but anyway i'm not going to feed it more
16:50:39 <kmc> so ttyl
16:50:55 <Martty> roger
16:51:01 <tolkad> kmc: I was curious how I would be told to work around the bug
16:51:10 <Martty> one moment, if i get fmap to work on my custom list i will declare this as understood
16:51:12 <tolkad> kmc: since I couldn't think of anyway it would make sense to work around it
16:51:36 <tolkad> kmc: the result wasn't as interesting as I hoped. You just pointed out the bug
16:51:51 <monochrom> > fmap id [Left True, Right 'x']
16:51:52 <lambdabot>   [Left True,Right 'x']
16:52:06 <sipa1024> :t fmap
16:52:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:52:21 <monochrom> > fmap (either not ord) [Left True, Right 'x']
16:52:22 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:52:22 <lambdabot>         against inferred type ...
16:52:32 <monochrom> oh oops
16:52:39 <sipa1024> :t not
16:52:40 <lambdabot> Bool -> Bool
16:52:40 <tolkad> Martty: you can think of the list type as « data [] a = [] | (a : ([] a)) »
16:52:43 <Martty> i did it
16:52:46 <Martty> I DID IT
16:52:56 <Martty> is there a generalized version of folds?
16:52:56 <tolkad> Martty: where : is an infix constructor
16:52:57 <MrAI> How would I save the output from fib(n) e.g.1.2.3.5.8 etc... to a list?
16:53:04 <Sina> mauke aristid its not on project euler. I have created a function that replaces characters based on the frequency. however the output makes no sense :( and I'm quite sure my code is ok. I'm not sure if I'm doing something wrong...
16:53:09 <monochrom> > fmap (either fromEnum fromEnum) [Left True, Right 'x']
16:53:10 <lambdabot>   [1,120]
16:53:11 <mauke> Martty: Data.Foldable?
16:53:12 <monochrom> hehe
16:53:21 <Martty> lets see
16:53:24 <mauke> MrAI: you wouldn't
16:53:24 <aristid> how many total pure functions Bool -> Bool are there? is 2 the correct number?
16:53:33 <tolkad> Martty: http://www.haskell.org/haskellwiki/Foldable_and_Traversable
16:53:36 <sipa1024> aristid: 4
16:53:41 <MrAI> With my code I can
16:53:41 <mauke> MrAI: you'd just construct the list in the first place, which is much faster
16:53:43 <Martty> its very slowly starting to make sense
16:53:44 <aristid> sipa1024: explain
16:54:01 <hpc> aristid: there's const True, const False, not, and id
16:54:04 <monochrom> const True, const False, id, not
16:54:06 <MrAI> Do go on...
16:54:07 <aristid> ah!
16:54:08 <aristid> thanks
16:54:13 <sipa1024> aristid: what hpc said :)
16:54:21 <aristid> i was thinking only of id and not :D
16:54:27 <mauke> MrAI: fibs = 0:1:zipWith (+) fibs (tail fibs)
16:54:57 <dmwit> aristid: |X -> Y| = |Y| ^ |X|
16:55:02 <Peaker> @pl \xs -> zipWith (+) xs (tail xs)
16:55:03 <lambdabot> ap (zipWith (+)) tail
16:55:11 <aristid> > fix ((0 :) . (1 :) . (zipWith (+) <*> tail))
16:55:12 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:55:15 <mauke> @pl fibs = 0:1:zipWith (+) fibs (tail fibs)
16:55:15 <lambdabot> fibs = fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
16:55:17 <Peaker> zipWith (+) `ap` tail   yay
16:55:40 <aristid> mauke: i am the better @pl
16:55:47 <dmwit> ?quote zip`ap`tail
16:55:47 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
16:55:48 <aristid> dmwit: for total pure functions, that is?
16:55:54 <dmwit> aristid: yes
16:56:03 <dmwit> err
16:56:09 <tolkad> Martty: you could also take a look at http://codepad.org/3q78x1vM
16:56:14 <dmwit> total, eh?
16:56:14 <dmwit> That makes it harder.
16:56:26 <dmwit> At the very least, if X and Y are finite, then that equation still holds.
16:56:29 <aristid> dmwit: total, as in, returns no bottom
16:56:39 <aristid> evar
16:56:44 <dmwit> aristid: Yep, that makes it harder.
16:56:58 <aristid> i thought that makes it easier :)
16:57:04 <dmwit> No, wait, I'm confusing "total" and "computable" again.
16:57:11 <aristid> :)
16:57:23 <tolkad> Martty: if you want to feel more confused
16:57:32 <sipa1024> if X and Y are infinite then aleph(X -> Y) = max(aleph(X)+1,aleph(Y)) i think :)
16:57:35 <Martty> tolkad: i closed it before i let it affect me
16:57:49 <aristid> tolkad: this is the perfect channel for people who want to become more confused
16:58:39 <enthropy> tolkad: but that one needs the annotation on the int
16:58:48 <aristid> tolkad: could you maybe introduce fundeps to make it more robust?
16:58:53 <MrAI> So in order to stop my code id need to hard code an ending?
16:58:57 <Philippa> aristid: definitely if you want to become confused on a higher level
16:58:59 <MrAI> test:: [Int]
16:58:59 <MrAI> test = [0:1:zipWith (+) fibs (tail fibs)| x <- [2..20]]
16:59:09 <sipa1024> MrAI: no [ ] around it
16:59:12 <tolkad> enthropy: yeah well I don't understand yours at all :P
16:59:17 <sipa1024> oh wait
16:59:21 <tolkad> enthropy: also yours uses unsafeCoerce
16:59:41 <sipa1024> MrAI: that's a list comprehension of 19 times the fibonacci list
17:00:05 <aristid> > take 20 $ fix ((0 :) . (1 :) . (zipWith (+) <*> tail))
17:00:06 <mauke> MrAI: how can you stop something that doesn't move?
17:00:06 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
17:00:09 <enthropy> tolkad: it's used safely as far as I can tell
17:00:37 <monochrom> I can stop something that doesn't move by doing nothing.
17:01:07 <aristid> monochrom: how philosophic
17:01:24 <MrAI> Is there a way to stop the result going over 4million? And stopping
17:01:31 <monochrom> armchair philosopher just sits in armchair doing nothing :)
17:01:57 <aristid> deliberately stopping the nothingness from doing nothing
17:02:21 <dmwit> MrAI: takeWhile?
17:02:35 <monochrom> "I think, therefore I stop" :)
17:03:27 <aristid> or, to put it in terms that computer scientists can better understand: "I think, therefore I halt"
17:03:32 <monochrom> ObHaskell: I think, therefore haskell evaluates lazily
17:04:21 <MrAI> test:: [Int]
17:04:21 <MrAI> test = takeWhile (<4000000) 0:1:zipWith (+) fibs (tail fibs)
17:04:29 <magicman> I think I just sold my soul. I used both unsafeCoerce *and* unsafePerformIO in the same function.
17:04:39 <monochrom> congratulations
17:04:45 <aristid> MrAI: apart from the errors, that is correct
17:04:55 <MrAI> The errors? :s
17:05:08 <mauke> MrAI: where did you define 'fibs'?
17:05:11 <monochrom> (is that meant to be tautological? :) )
17:05:15 <MrAI> fib :: Int -> Int
17:05:15 <MrAI> fib 0 = 0
17:05:15 <MrAI> fib 1 = 1
17:05:15 <MrAI> fib n = fib(n-1) + fib(n-2)
17:05:16 <MrAI> up top
17:05:22 <mauke> MrAI: that defines 'fib', not 'fibs'
17:05:24 <MrAI> No wait :s
17:05:30 <MrAI> Interesting...
17:05:34 <enthropy> aristid: I'm not sure fundeps can address that problem... can you think of a way to encode knowing two variables determines what two others (but not in that order) could be?
17:05:39 <monochrom> oh, I see, parenthesis errors, easy to fix, not meant to be tautological
17:05:41 <aristid> monochrom: "apart from the errors, that is correct" is not tautological because it implies the existence of errors
17:05:44 <MrAI> How does that work then? :s
17:05:51 <aristid> enthropy: hmmm
17:06:02 <mauke> MrAI: recursion
17:06:16 <MrAI> Ah ok. So what errors? lol
17:06:29 <aristid> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in takeWhile (<4000) fibs
17:06:30 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584]
17:06:54 <monochrom> > takeWhile (<60) (0:1:zipWith (+) fibs (tail fibs))
17:06:55 <lambdabot>   Not in scope: `fibs'Not in scope: `fibs'
17:06:56 <aristid> MrAI: well, 1. you use fibs without defining it ever, 2. your precedence is all mixed up
17:06:58 <monochrom> oops
17:07:41 <MrAI> I asked for help and that was the code someone supplied me with :s
17:07:57 <Eduard_Munteanu> Uh... the GTK graphics context stuff is really crappy.
17:08:07 <Eduard_Munteanu> Makes drawing really hard.
17:08:10 <mauke> no, 'fibs = 0:1:zipWith (+) fibs (tail fibs)' was
17:08:17 <mauke> which is the definition of fibs
17:08:22 <mauke> which you should have put in your program
17:08:24 <monochrom> you can do a diff on both pieces of code and extract the help
17:09:17 <monochrom> help :: Bad_Code -> Good_Code
17:09:19 <MrAI> fibs :: Int
17:09:19 <MrAI> fibs = 0:1:zipWith (+) fibs (tail fibs)
17:09:19 <MrAI> test:: [Int]
17:09:19 <MrAI> test = fibs in takeWhile (<4000000) 
17:09:21 <MrAI> :D
17:09:36 <MrAI> ...or should that be Integer :s
17:09:42 <MrAI> Doesnt matter
17:10:02 <mauke> test = takeWhile (<4000000) fibs
17:10:21 <MrAI> ok
17:11:09 <MrAI> I am wondering why it doesnt terminate though
17:11:15 <MrAI> It appears to just keep looking
17:11:23 <aristid> because 4000000 is a BIG number
17:11:36 <aristid> also, you seem to guess around randomly :P
17:11:45 <mauke> MrAI: what doesn't terminate?
17:11:50 <MrAI> I dont want the result for fib(n) to be larger than 4 million
17:12:19 <MrAI> How would I do that?
17:12:25 <aristid> well, actually it does terminate
17:12:30 <aristid> you seem to do it wrong
17:12:31 <monochrom> there are only 34 numbers in takeWhile (<4000000) fibs
17:12:38 <mauke> MrAI: what doesn't terminate?
17:12:42 <aristid> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in takeWhile (<40000000) fibs
17:12:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:12:43 <monochrom> and it doesn't take more than 34 seconds.
17:12:54 <aristid> > length $ let fibs = 0:1:zipWith (+) fibs (tail fibs) in takeWhile (<40000000) fibs
17:12:55 <lambdabot>   39
17:13:03 <aristid> monochrom: it takes less than a second, in fact
17:13:28 <aristid> > length $ let fibs = 0:1:zipWith (+) fibs (tail fibs) in takeWhile (<4000000) fibs
17:13:29 <lambdabot>   34
17:13:49 <monochrom> yeah, an extra 0 bumps from 34 to 39 :)
17:13:54 <MrAI> [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,
17:13:58 <MrAI> Thats what mine does
17:14:01 <MrAI> And doesnt go further
17:14:03 <mauke> MrAI: what doesn't terminate?
17:14:24 <aristid> @oeis 1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657
17:14:25 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
17:14:25 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:15:01 <etnik> can anyone help with linked list (C) ?
17:15:01 <MrAI> Thats what I was going for before Lamb but it was ineffecient
17:15:07 <mauke> MrAI: what doesn't terminate?
17:15:11 <MrAI> The Program
17:15:14 <MrAI> When I run it
17:15:17 <mauke> MrAI: what program?
17:15:23 <MrAI> fibs :: Int
17:15:24 <MrAI> fibs = 0:1:zipWith (+) fibs (tail fibs)
17:15:24 <MrAI> test:: [Int]
17:15:24 <MrAI> test = takeWhile (<4000000) fibs
17:15:39 <aristid> which compiler do you use?
17:15:41 <mauke> MrAI: that's not a program; that's a bunch of declarations
17:15:51 <MrAI> When I run 'Test'
17:15:54 <mauke> MrAI: declarations don't run, so they take no time
17:15:54 <monochrom> sorry, I don't know linked lists in C
17:16:04 <MrAI> WinGHCi
17:16:24 <aristid> MrAI: your program also does not compile
17:16:29 <MrAI> ok
17:16:31 <aristid> MrAI: so there is no way it would ever run
17:16:35 <monochrom> should be a type error to begin with
17:16:39 <MrAI> Ok I get it :p
17:16:50 <monochrom> please don't lie again
17:16:55 <mauke> in conclusion: wtf are you doing
17:17:18 <MrAI> So how would I created a bunch of declerations that would allow me to create a list of the fibanacci sequence that does not go above 4 million?
17:17:25 <MrAI> That was my original question
17:17:34 <sipa1024> MrAI: fibs :: [Integer]
17:17:40 <monochrom> it has been answered 4 million times
17:17:42 <gwern> MrAI: create an infinite list, and then use 'take 4million'?
17:17:54 <mauke> MrAI: fibs :: [Int]
17:18:01 <mauke> MrAI: change that and it'll compile
17:18:17 <mauke> etnik: I could
17:18:32 <monochrom> if you just erase your own code and adopt one of five approaches shown to you, you are done.
17:19:19 <Eduard_Munteanu> How would I set a colormap for a GTK Pixmap? If I use Cairo to draw to it, it quits and complains there's no colormap for the offscreen pixmap.
17:19:21 <ddarius> It's a good thing we have such a supply of fib programs.
17:19:56 <etnik> mauke, thanks.
17:20:20 <etnik> want me to ask away here?
17:20:31 <mauke> #haskell-blah might be better
17:20:56 <alex404> Let's say I have some fancy function, and that I build a Map 'foo; between its input and output values, where foo takes no arguments (it's a constant). Does then compile all mapped outputs of the given function, thus saving the need to calculate them?
17:21:16 <alex404> *Does ghc
17:21:18 <Kaidelong> http://codepad.org/Fy1gG4Cr (for MrAI)
17:21:50 <MrAI> Thanks
17:21:58 <monochrom> no, ghc likely generates code to recompute it every time you start the generated code
17:22:59 <MrAI> And given you have used main that would actually compile? (I am just wondering)
17:23:08 <Kaidelong> yes
17:23:09 <Kaidelong> exactly
17:23:13 <Kaidelong> well
17:23:17 <MrAI> Cool thats how you do that
17:23:20 <Kaidelong> if it is a library it would compile without a main
17:23:29 <MrAI> I see
17:23:29 <Kaidelong> but if you want a program that can run you need a main
17:23:34 <MrAI> Got ya
17:24:46 <alex404> monochrom: What makes you say that?
17:25:36 <monochrom> experimental results
17:25:41 <MrAI> What is ' scanl '?
17:26:08 <alex404> monochrom: Thanks for the tip
17:26:25 <Kaidelong> @hoogle scanl
17:26:25 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
17:26:25 <lambdabot> Data.ByteString scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
17:26:25 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
17:26:31 <alex404> monochrom: Do you know of any way to force GHC to evaluate the results in my case?
17:27:12 <Kaidelong> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Prelude.html#v:scanl
17:27:55 <monochrom> TH may help you pre-compute all the outputs but still not pre-build the Map. At most you can pre-build a list, then at runtime build the Map.
17:28:23 <MrAI> Thanks
17:28:26 <monochrom> (Unless you break Data.Map encapsulation and pre-build its internal trees.)
17:30:03 <Kaidelong> mrai: in general, go to the Hoogle website to search for docs
17:30:10 <MrAI> Ok
17:30:28 <alex404> monochrom: Interesting... well, building the map from a list is not a problem if I only have to do it once. There's basically a parameter 'n' that underwrites a number of my functions, where it would make sense not to recompute a number of values over and over. So I was either thinking Memoization, or TH. TH is probably what I want, but it's scary.
17:32:39 <kmc> alex404, the easy way to memoize functions is something like data-memocombinators
17:33:02 <alex404> kmc: You recommend that over memotries?
17:33:09 <kmc> haven't used MemoTrie
17:33:58 <kmc> or you could just look up that reddit troll thread about how memoization is a "PhD level topic" in Haskell
17:34:18 <alex404> What's that supposed to mean?
17:35:08 <kmc> it means that someone wanted to troll haskellers
17:35:29 <alex404> Oh. Well I used memotries once and it hardly seemed like rocket surgery.
17:35:44 <kmc> no, everything in Haskell requires 3 PhDs in ultra category theory
17:35:47 <kmc> didn't you hear
17:35:53 <alex404> Cool.
17:35:58 <Peaker> alex404, Someone wrote a PhD about memoization in Haskell, so it is no longer allowed for non-PhD's to do memos in Haskel.  So a guy complained that he wants his memos back so he had to leave Haskell to get them
17:36:23 <Peaker> Then yairchu reminded him that there are PhD's about cheese, so he can no longer eat cheeseburgers
17:36:35 <alex404> Ouch. Tough break.
17:36:40 <monochrom> some troll said on reddit something like "omg haskell requires phd in memoization". (my dramatization)
17:36:45 <kmc> plenty of PhDs about C and Java too
17:36:50 <kmc> probably more than Haskell
17:37:13 <kmc> anyway trolls will be trolls, the thing that bugs me is there's this vein of antiintellectualism in the "programming community" that they can tap into
17:37:49 <alex404> The ironic I find is that if you're not concerned with performance, Haskell does quite well as a straight forward scripting language.
17:38:04 <alex404> Though maybe I've just lost perspective.
17:38:12 <monochrom> antiintellectual : programming :: antiintellectual : humanity
17:38:37 <enthropy> they are out to get you
17:38:51 <alex404> The intellectuals or the anti intellectuals?
17:38:58 <monochrom> both!
17:39:10 <kmc> those liberal elitist Haskell programmers are so out of touch with us good old fashioned hard working common sense guys
17:39:58 <winxordie> I forget when liberal had a meaning.
17:40:12 <alex404> It still does in Canada! (sort of)
17:41:31 <guest2425> hello
17:42:28 <dolio> I don't know. It still seems weird to me that as intellectual a discipline as computer programming would be populated by so many anti-intellectuals.
17:43:15 <dolio> Even factoring in how many humans in general fall into that mold.
17:43:34 <kmc> hello guest2425
17:43:36 <monochrom> it stopped being an intellectual discipline the moment good money was involved. it started being a common humanity discipline.
17:43:47 <guest2425> I have a question
17:43:53 <guest2425> in haskell
17:43:57 <guest2425> I am stuck
17:44:50 <winxordie> monochrom: money -> ruin_everything_fun?
17:45:08 <dolio> I guess.
17:45:08 <Sina> Is anyone here interested to help me decode a string?
17:45:11 <Axman6> sk it ;)guest2425: well, we can answer your question, but only as long as you 
17:45:34 <Axman6> hmm, no idea where that first bit came from...
17:46:30 <Axman6> but only as long as you ask it ;)*
17:46:39 <dolio> monochrom: Anyhow, engineers make money, but I doubt you'd find many of them complaining about intellectuals foisting their math nonsense on the field. Maybe there's just not as much money involved, though.
17:46:55 <kmc> a lot of programmers are self-taught, not highly educated, and may be more likely to buy into popular clichés of academia
17:47:03 <kmc> not many chemical engineers are self-taught
17:47:10 <dolio> Yeah.
17:47:11 <kmc> (unless you count illegal drug manufacture)
17:47:40 <kmc> although the successful illegal drug manufacturers also tend to be well-educated
17:47:54 <winxordie> So the fault here is the computer science education system eh?
17:48:08 <winxordie> (or lack of it)
17:48:11 <kmc> maybe the 'fault' is that CS is so accessible that people don't need to go through the formal system
17:48:16 <kmc> that doesn't seem like a bad thing in general
17:48:26 <kmc> it's one of the things i really like about CS
17:48:34 <kmc> or at least programming
17:48:35 <kmc> it's closer to a meritocracy
17:48:37 <gwern> university chemistry students are famous for their extracurricular activities; there was a big bust just yesterday here for some students apparently cooking up some hallucinogens
17:48:45 <kmc> haha
17:48:47 <kmc> which ones?
17:48:51 <kmc> also what school?
17:48:52 <gwern> the article did not say
17:48:57 <Axman6> guest2425: are you going to ask your question or not?
17:49:04 <gwern> kmc: I didn't care enough to remember details like what school
17:49:32 <MrAI> Goodnight all. Thanks for all your help
17:49:42 <guest2425> oh well
17:49:53 <guest2425> yes this what I have 
17:50:04 <guest2425> I need to do a bubbleSort function
17:50:14 <guest2425> using another function 
17:50:23 <guest2425> this is what I have ?
17:50:25 <monochrom> engineers complain about math unless it is positively shown the math is necessary to avoid disasters. for example U of Toronto computer engineering students complain about NP-completeness lessons. OTOH they don't complain about doing integrals, they see it's useful. OTOH they do complain about proving Riemann sums converge --- of course every function they care about are nicely integrable, why worry about pathological things li
17:50:25 <monochrom> ke the ruler function that never arise in their constructions.
17:51:03 <gwern> knowing about complexity seems very useful to me
17:51:08 <guest2425> here http://pastebin.com/Sqbv8Jk2 
17:51:19 <guest2425> I dont know what to write next?
17:51:25 <kmc> OTOH programmers complain about the idea that you should have some idea what your code does before you run it
17:51:43 <Kaidelong> kmc: that's wrong-headed
17:51:44 <kmc> guest2425, btw, did you write mapReduce?
17:51:54 <guest2425> Axman6: here http://pastebin.com/Sqbv8Jk2    I dont know what write next
17:51:56 <guest2425> No
17:51:58 <Axman6> heh, where are you learning haskell guest2425?
17:51:59 <kmc> ok
17:52:07 <guest2425> why?
17:52:10 <kmc> there's a nicer way to write mapReduce using the "worker/wrapper" transform
17:52:16 <kmc> you might tell your prof ;P
17:52:19 <enthropy> these mapReduce people are a single person?
17:52:20 <Axman6> because we've had other people doing the same course in here recently
17:52:25 <monochrom> However, engineers have legal responsibilities. This is incentive for them to use a bit more math than they would like, so they can avoid disasters. Programmers aren't punished for their disasters.
17:52:32 <guest2425> kmc: thank you
17:52:55 <MrAI> Computer Science is not about computing (See EE for that) nor is it about Science. CS teachs the people how to work with big systems they cannot keep in their head. Thats it. 12 year olds can program - thats not a skill.
17:53:08 <kmc> nothing a 12-year-old can do is a skill?
17:53:09 <guest2425> Axman6: oh ok
17:53:11 <dolio> kmc: There's an even nicer way using a composition of simpler functions that have clearer interpretations. :)
17:53:13 <guest2425> any clue
17:53:33 <kmc> i'm pretty sure playing piano or chess at a world class level is a skill
17:53:43 <guest2425> Axman6: any idea
17:53:45 <Axman6> man, the definition of mapReduce there is horrible
17:53:46 <guest2425> ?
17:53:54 <guest2425> I knwo
17:53:58 <guest2425> is like a tree
17:54:30 <Axman6> really need the types to be able to tell what's going on
17:54:42 <guest2425> ok 
17:54:46 <guest2425> of mapReduce '
17:54:52 <guest2425> correct?
17:55:02 <dolio> @let mapReduce f g p k h = flip (uncurry $ foldr h) . (map f *** k . head) . break p . iterate g
17:55:03 <lambdabot>  <local>:3:0:
17:55:03 <lambdabot>      Multiple declarations of `L.mapReduce'
17:55:03 <lambdabot>      Declared at: <...
17:55:08 <dolio> Whoops.
17:55:29 <Axman6> :t mapReduce
17:55:30 <lambdabot> forall a1 a b. (a1 -> a) -> (a1 -> a1) -> (a1 -> Bool) -> (a1 -> b) -> (a -> b -> b) -> a1 -> b
17:55:39 <dolio> Oh, that should probably be uncurry (flip $ foldr h)
17:55:43 <Axman6> -_-
17:56:27 <guest2425> here http://pastebin.com/QWnHkare
17:56:46 <monochrom> engineering has divided itself from hobbyist DIY. (note how people in hobbyist DIY can be anti-intellectual.) programming hasn't divided itself from basement fooling around.
17:56:51 <dolio> Anyhow, with that definition, you can understand it piece by piece.
17:57:14 <guest2425> Axman6: http://pastebin.com/QWnHkare
17:57:22 <dolio> monochrom: Yeah, that seems like the root cause to me.
17:59:39 <guest2425> Axman6: any clue
18:00:16 <guest2425> Axman6: I am stuck on what do next?
18:00:43 <osaunders> I asked a question on StackOverflow a while back about how to best create a single instance for a whole class of types without causing overlapping instances. The advice was to use a wrapping newtype and create the instance on that...
18:01:08 <osaunders> My question now is, if that's such a good idea, why doesn't Haskell come with a generic Wrapper newtype for doing this stuff?
18:01:57 <dancor> monochrom: imo a lot of programming industry and hobbyists are really against intellectualism
18:02:08 <dancor> so three layers!
18:03:34 <dancor> i guess four, google phd's on infrastructure might be industry+intellectual
18:04:13 <monochrom> there are pockets of enlightenment scattered here and there
18:04:26 <Adamant> intellectual isn't enlightened
18:04:55 <Adamant> at least if you get trapped in that silo
18:04:56 * dancor educated stupid
18:05:30 <Adamant> dancor: I love stealing that one to describe some of the bad effects of education
18:05:48 <dancor> like overuse of references
18:05:58 <guest2425> Guys hello
18:06:01 <Adamant> what reference are you referring to?
18:06:07 <Adamant> :P
18:06:07 <dancor> The Cor Effect
18:06:18 <guest2425> any clue and what to do 
18:06:29 <guest2425> in my problem
18:06:31 <guest2425> ?
18:06:37 <kmc> 'The site has been criticised for the "centered 30-point type" of its design and the "endless blather" of its content'[2]'
18:06:43 <ddarius> More people should do PhDs about cheese.  It's an important and valuable topic.
18:07:00 <luite> time cube?
18:07:02 <Adamant> also covered by the food science department
18:07:36 <Adamant> although molecular gastronomy looks pretty cool
18:07:43 <Gracenotes> but how do we know phds about cheese won't have a systemic bias towards tastier cheeses?
18:07:56 <Adamant> that's exactly the bias we want
18:08:06 <Gracenotes> I don't think we can afford that sort of rift in the cheese-eating community
18:08:12 <dancor> who will cheesecloth the cheeseclothers
18:08:20 <Adamant> this is not a social science department, damit
18:08:21 <ddarius> Food science isn't usually that interesting, but molecular gastronomy and some other related fields are quite a bit more interesting.
18:08:26 <koninkje> does anyone know what the significance of System.Posix.Files.namedPipeMode is?
18:08:45 <kmc> http://achewood.com/index.php?date=01262007
18:09:27 <Adamant> lol
18:09:32 <Adamant> pure aweseome
18:09:40 <Adamant> with a side of extra sauce
18:09:41 <dancor> koninkje: you can query to see if a given path is a regular file or a unix "named pipe" or something else
18:09:57 <guest2425> dont talk about food 
18:09:58 <Eduard_Munteanu> Mmm, what was the syntax for modifying a record (record syntax) and leaving others alone?
18:10:01 <guest2425> I am hungry
18:10:15 <dancor> koninkje: by calling getFileStatus and then fileMode on that
18:10:29 <dancor> koninkje: http://en.wikipedia.org/wiki/Named_pipe
18:10:38 <koninkje> dancor: So it's only for isNamedPipe, not for, say opening/creating pipes?
18:10:39 <monochrom> r{field = new value}
18:10:55 <ddarius> guest2425: I often have that problem.  I have found eating usually resolves it.
18:11:01 <kmc> stoners have a habit of naming pipes
18:11:05 <dancor> koninkje: well there's createNamedPipe
18:11:07 <Eduard_Munteanu> monochrom: thanks.
18:11:10 <guest2425> hahaha
18:11:12 <guest2425> ur funny
18:11:17 <guest2425> But haskell
18:11:23 <guest2425> is my food right now?
18:11:25 <guest2425> i guess
18:11:25 * ddarius goes to make and then eat some food.
18:11:26 <dancor> koninkje: it does seem like you shouldn't need it directly..
18:11:56 <koninkje> dancor: K. Just making sure since it's not documented nor obvious from C land
18:12:03 <monochrom> my research shows no correlation between hearing about food and being hungry
18:13:05 <dancor> koninkje: i guess the only use is the rare possibility that you need to look at a lot of mode-stuff and the individual is* functions would slow you down by doing extra IO?
18:13:28 <koninkje> that could be
18:14:21 <koninkje> Say, is there a way to get the current umask? I didn't see it in System.Posix.*
18:14:48 * ddarius wonders if there are any tasty Archaea.
18:15:59 <Adamant> ddarius: too much sulfur. probably not so good going out.
18:23:18 <osaunders> http://gist.github.com/644244
18:23:49 <kmc> haha
18:25:58 <osaunders> OK, I improved it. It outputs 42 now.
18:28:02 <Kaidelong> is there a utility for haskell that goes through all intermediate steps of an evaluation?
18:28:18 <Kaidelong> and prints out code
18:28:34 <Kaidelong> IE for the fibbonacis it would go
18:29:10 <Saizan> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi <- this one is nice
18:29:26 <Saizan> the only problem is that in some cases it does call-by-name rather than call-by-need
18:30:13 <monochrom> w00t that's the lost link I wanted to find again. thanks.
18:31:03 <Saizan> @where+ stepeval http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
18:31:04 <lambdabot> Okay.
18:34:55 <osaunders> That's a lot of code: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=drop+1+%5B1%2C2%2C3%5D
18:40:15 <joe1> :q
18:40:39 <kmc> E37: No write since last change (add ! to override)
18:41:10 <osaunders> @pl boxedF <*> x = unbox boxedF <$> x
18:41:10 <lambdabot> (line 1, column 14):
18:41:11 <lambdabot> unexpected "="
18:41:11 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
18:41:42 <osaunders> @pl boxedF <*> x = (unbox boxedF) <$> x
18:41:42 <lambdabot> (line 1, column 14):
18:41:42 <lambdabot> unexpected "="
18:41:42 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
18:41:52 <osaunders> @pl boxedF <*> x = ((unbox boxedF) <$> x)
18:41:53 <lambdabot> (line 1, column 14):
18:41:53 <lambdabot> unexpected "="
18:41:53 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
18:41:56 * osaunders gives up
18:45:31 <Eduard_Munteanu> Yay I did it.
18:45:48 <Eduard_Munteanu> Cairo was so much slower (granted, no double buffering) than simple GTK.
18:46:26 <Eduard_Munteanu> Thanks again dmwit.
18:46:59 <cads> hey, I'm trying to write a bubble sorting pass as a foldr - this is a function which would take  [4, 0, 0, 0, 0, 3, 2] to [0, 0, 0, 0, 3, 2, 4], for example
18:49:36 <djahandarie> It works much nicer as explicit recursion.
18:49:37 <Eduard_Munteanu> And I'm drawing pixel and doing upscaling with linear interpolation.
18:49:56 <Eduard_Munteanu> um, nearest, not linear.
18:50:06 <cads> so my folding function f : ord a => a -> [a] -> [a] takes the next element of the list x, compares it to the last element of the accumulator list (xs++last:[]),  and writes (xs++x:last:[]) if last >= x, and writes (xs++last:x:[]) otherwise.
18:51:08 <cads> this strikes me as being terribly inefficient since you have to traverse the whole accumulator list to check the last element, and also to append to the end
18:51:42 <cads> but it seems like the only way you'd write a bubble function using lists
18:51:59 <dolio> Why would it compare it to the last element?
18:53:30 <cads> say you started with   the list [1, 0, 0, 0, 0] and you're at the step where you accumulator list for the fold is [0, 0, 1], and your next value is 0. You must transform the accumulator list into [0, 0, 0, 1] in this case.
18:53:48 <dolio> Nope.
18:53:48 <webwanderer> what are closed and open lambda terms?
18:54:01 <dolio> bubble [1, 0, 0, 0, 0] = [0, 1, 0, 0, 0]
18:54:04 <cads> then the next value is yet another zero, and you must transform the list finally to [0, 0, 0, 0, 1]
18:54:07 <Saizan> > let bubble = foldr (\x xs -> case xs of [] -> [x]; (y:xs) -> min x y : max x y : xs) [] in bubble [4, 0, 0, 0, 0, 3, 2]
18:54:08 <lambdabot>   [0,4,0,0,0,2,3]
18:54:15 <webwanderer> is it based on variable binding?
18:54:33 <monochrom> no free variable: closed. has free variable: open. example: (\x -> x) is closed. (\x -> f x) is open, free variable f.
18:54:48 <cads> dolio, hmm, am I misunderstanding how bubbling works?
18:55:13 <dolio> You have to decide which end of the list to start swapping from.
18:55:13 <cads> I figured that bubbling would cause the greatest value to propagate all the way to the end of the list.
18:55:31 <dolio> That practice exam specifically tells you to start from the easier end from a foldr perspective.
18:56:08 <monochrom> closed lambda terms are aka combinators
18:56:59 <cads>  > let bubble = foldr (\x xs -> case xs of [] -> [x]; (y:xs) -> min x y : max x y : xs) [] in bubble [1, 0, 0, 0]
18:57:06 <cads> > let bubble = foldr (\x xs -> case xs of [] -> [x]; (y:xs) -> min x y : max x y : xs) [] in bubble [1, 0, 0, 0]
18:57:07 <lambdabot>   [0,1,0,0]
18:57:14 <cads> > let bubble = foldr (\x xs -> case xs of [] -> [x]; (y:xs) -> min x y : max x y : xs) [] in bubble [0, 1, 0, 0]
18:57:15 <lambdabot>   [0,0,1,0]
18:59:24 <cads> I thought that bubble would be written as  i in 0 to (maxIndex a - 1), if a[i] > a[i+1], swap a i (i+1).
19:00:47 <jmcarthur> but this isn't an imperative language with mutable arrays
19:01:00 <ddarius> has variables on parole: clopen
19:01:03 <cads> in this version if  a[0] were greater than each other value in a, the first step would swap a[0] and a[1], step two would swap a[1] and a[2], and so on...
19:01:34 <cads> jmcarthur, it just seems I'm missing how the bubble operator works :)
19:01:38 <Saizan> cads: another option is: i in (maxIndex a - 1) to 0, ...
19:01:49 <jmcarthur> @let bubble = foldr (\x xs -> case xs of [] -> [x]; (y:xs) -> min x y : max x y : xs) []
19:01:50 <lambdabot>  Defined.
19:02:05 <jmcarthur> > iterate bubble [4,2,6,4]
19:02:06 <lambdabot>   [[4,2,6,4],[2,4,4,6],[2,4,4,6],[2,4,4,6],[2,4,4,6],[2,4,4,6],[2,4,4,6],[2,4...
19:02:18 <jmcarthur> > iterate bubble [6,4,2,0,4]
19:02:19 <lambdabot>   [[6,4,2,0,4],[0,6,4,2,4],[0,2,6,4,4],[0,2,4,6,4],[0,2,4,4,6],[0,2,4,4,6],[0...
19:02:35 <cads> > iterate bubble [1, 0, 0, 0, 0]
19:02:36 <lambdabot>   [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1],[0,0,0,0,1],[0...
19:02:53 <cads> > iterate bubble [1, 1, 1, 1, 0]
19:02:54 <lambdabot>   [[1,1,1,1,0],[0,1,1,1,1],[0,1,1,1,1],[0,1,1,1,1],[0,1,1,1,1],[0,1,1,1,1],[0...
19:03:04 <cads> Ah.
19:04:18 <jmcarthur> > iterate bubble [9,5,5,5,0]
19:04:19 <lambdabot>   [[9,5,5,5,0],[0,9,5,5,5],[0,5,9,5,5],[0,5,5,9,5],[0,5,5,5,9],[0,5,5,5,9],[0...
19:05:09 <cads> > iterate bubble [4, 4, 4, 4, 3, 2, 1, 0]
19:05:10 <lambdabot>   [[4,4,4,4,3,2,1,0],[0,4,4,4,4,3,2,1],[0,1,4,4,4,4,3,2],[0,1,2,4,4,4,4,3],[0...
19:05:48 <cads> So it works as I believed it should, except from back to front.
19:10:20 <cads> it is much more efficient from right to left
19:11:48 <Saizan> O(n) stack though
19:14:43 <monochrom> hahaha variables on parole
19:16:00 <cads> :)
19:18:51 <Kaidelong> "no instance for MArray Array Int IO"
19:19:06 <Kaidelong> any idea why I would see this?
19:19:12 <Axman6> Arrays aren't mutable
19:19:36 <kmc> use IOArray
19:19:38 <kmc> or IOUArray
19:19:39 <monochrom> use STArray
19:19:39 <Kaidelong> it's from an invocation of newListArray (1,3) [3,2,1]
19:19:51 <kmc> newListArray creates a mutable array
19:19:57 <kmc> listArray and array create immutable arrays
19:20:28 <monochrom> oh oops, IO, use IOArray
19:20:50 <monochrom> pay attention to types. be type-driven.
19:21:08 <Kaidelong> looks like the problem is that it is inferring I'm using an immutable array because at once point I ask for "bounds"
19:21:23 <Kaidelong> how do I get the bounds of a mutable array?
19:22:09 <monochrom> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/array-0.3.0.0/Data-Array-MArray.html#v%3AgetBounds
19:22:28 <Martty> http://www.ideone.com/U0Dbj i don't get it
19:22:46 <monochrom> "the missing scrolls of elih"
19:23:52 <cads> Saizan, is it just that foldr f [] :: [a] -> [a] must always be O(n) on the stack?
19:24:20 <Saizan> cads: no, it's that our f is strict on its second argument
19:25:21 <Saizan> cads: e.g. "map f = foldr (\x xs -> f x : xs) []" uses only constant stack
19:26:16 <monochrom> foldr f z (Cons x xs) = f x (DF.foldr f z xs)
19:26:24 <monochrom> because you imported qualified
19:26:58 <Martty> bah only on the right_
19:27:00 <Martty> ?
19:27:10 <Martty> this makes no sense!
19:27:14 <Martty> |?\
19:27:17 <Martty> ><<<<<<<<<<<<<<<<<<<<<<<
19:27:29 <monochrom> you can add to the left if you like
19:27:37 <Martty> it whines 
19:27:40 <cads> @pf (\a b->a)
19:27:40 <lambdabot> Maybe you meant: bf pl
19:27:46 <cads> @pl (\a b->a)
19:27:47 <lambdabot> const
19:27:49 <monochrom> you can whine too if you like
19:27:52 <cads> @pl (\a b->b)
19:27:53 <lambdabot> const id
19:28:06 <Martty> i guess its just a warning 
19:28:16 <Martty> nvm it says faild
19:28:23 <Martty> so definitely can't 
19:28:36 <cads> @type const
19:28:36 <lambdabot> forall a b. a -> b -> a
19:28:38 <monochrom> yell at the computer "you make no sense" repeatedly. record a video. post it on youtube. have fun reading the comments that ensue.
19:28:50 <Martty> its okay i understand why it happens now
19:28:53 <Martty> thanks monochrom <3
19:29:20 <monochrom> for special effects, pick up the mouse and start speaking into it.
19:30:13 <cads> monochrom, "This makes no sense! This makes no sense! This makes no *TECHNO BREAKDOWN* SSSSSSSSSSEEEEEEEEEEENnnnnnnsnssssseeeee Unts UntsUntsUntsUntsUntsUntsUntsMAKESNOUntsUntsUntsUntsUntsSENSENSENSENSENSENSENENNSNE"
19:30:29 <cads> sorry.
19:30:29 <monochrom> Unts?
19:30:36 <cads> some techno beat
19:30:49 <monochrom> fun
19:31:24 <cads> yeah, reference the bloodhound gang's song, http://www.youtube.com/watch?v=A1U-MGTerwo
19:31:53 <cads> Saizan, that makes sense, thanks
19:39:35 <Axman6> when talking about a grapg, is there a name for the size of the graph, in terms of the number of vertices?
19:40:44 <Axman6> graph*
19:55:50 <joe__> -nick joe1
19:57:42 <Eduard_Munteanu> Is there an unsafe random function?
19:57:52 <kmc> unsafe how?
19:58:03 <Eduard_Munteanu> kmc: so that it can be used in a pure function
19:58:19 <kmc> well, that function would in turn be impure / "unsafe"
19:58:41 <Eduard_Munteanu> kmc: um, yes, but I'd take my chances :)
19:59:00 <kmc> you can use unsafePerformIO yourself then
19:59:09 <kmc> but the safe way to get randomness in a pure function
19:59:13 <kmc> is to pass in a list of random values
19:59:16 <kmc> probably an infinite list
19:59:28 <kmc> or of course you can explicitly pass and return PRNG state
19:59:38 <kmc> or use a monad to provide syntactic sugar for same
19:59:48 <kmc> or any other abstraction of your own devising
19:59:54 <Eduard_Munteanu> Ah. I'd rather have a try with unsafePerformIO, it messes my comonad values otherwise.
20:00:04 <Eduard_Munteanu> Thanks.
20:00:05 <kmc> ok
20:00:16 <kmc> i can think of a few semi-legit cases
20:00:40 <kmc> basically randomized algorithms where the probability of an error in the result is small
20:01:01 <kmc> just remember that unsafePerformIO is subject to inlining, etc.
20:01:25 <kmc> it will be safer to unsafePerformIO your entire randomness-using-but-probably-deterministic computation
20:02:31 <Eduard_Munteanu> Hm... on the other hand, I could have an f :: Random -> Comonad Foo -> Foo, and invoke it like x =>> (foo random_stuff)
20:03:19 <Eduard_Munteanu> So the evaluation function is actually random.
20:03:31 <Eduard_Munteanu> s/foo/f/
20:23:35 <jmcarthur> Eduard_Munteanu: careful with unsafePerformIO. sharing means you might not necessarily get a new random number every time you use the function
20:23:48 <jmcarthur> or ever, even
20:30:25 <Kaidelong> Eduard_Munteanu: What has made you unhappy with MonadRandom?
20:32:16 <ivanm> does showsString differ from just using shows in that showsString doesn't do any escaping, etc. and is meant to be used for custom Show instances?
20:35:59 <monochrom> > showsString "how are you" ""
20:36:00 <lambdabot>   Not in scope: `showsString'
20:36:15 <monochrom> > showString "how are you" ""
20:36:15 <lambdabot>   "how are you"
20:36:25 <monochrom> > shows "how are you" ""
20:36:26 <lambdabot>   "\"how are you\""
20:36:30 <monochrom> I guess so
20:37:09 <monochrom> showString s is meaningful name for (s ++)
20:38:17 <djahandarie> It's basically just for String -> ShowS wherever you need it
20:38:52 <ivanm> *nod*
20:38:57 <kmc> doesn't that make it equivalent to (++)?
20:38:59 <ivanm> what I figured
20:39:04 <ivanm> kmc: it _is_ ++
20:39:05 <kmc> > "foo" `showsString` "bar"
20:39:06 <lambdabot>   Not in scope: `showsString'
20:39:13 <kmc> > "foo" `showString` "bar"
20:39:14 <lambdabot>   "foobar"
20:39:16 <kmc> hehe
20:39:17 <ivanm> I was just checking that that was the rationale for it
20:39:19 <kmc> i'm going to use that in all my code now
20:39:21 <kmc> to confuse people
20:39:29 <ivanm> heh
20:39:39 <ivanm> kmc: it's only for String -> String -> String though
20:40:00 * ivanm wonders whether having an actual Char document type makes sense for a Text pretty-printer
20:40:01 <kmc> true
20:41:59 <ivanm> also, in wl-pprint, the whole Doc -> SimpleDoc -> <output> is a little weird; what's the point of the intermediary SimpleDoc?
20:42:41 <ivanm> how much of wl-pprint's API should I bother keeping/copying?
20:44:58 <Maxdamantus> @pl 5+4
20:44:59 <lambdabot> 9
20:45:09 <Maxdamantus> @pl 5+4*2
20:45:09 <lambdabot> 13
20:45:25 <Maxdamantus> @pl \a b -> a + a + a + a + b + b + b
20:45:25 <lambdabot> join . ((+) .) . join . ((+) .) . (+) . ((+) =<< (+) =<< join (+))
20:45:30 <Maxdamantus> O_o
20:48:58 <dial1> i have a list comprehension that looks like this: select mas = [a | Just a <- mas] ; is there a good way to convert it to a foldr function? i'm having some trouble
20:49:52 <Axman6> i'd be inclined to leave it like that, it's clear as can be really
20:50:02 <Axman6> unless you have to for an assignment or something
20:50:23 <ivanm> Axman6: I think catMaybes is clearer :p
20:50:34 <ivanm> > catMaybes [Just 3, Nothing, Just 2]
20:50:35 <lambdabot>   [3,2]
20:50:36 <Axman6> sure
20:50:46 <kmc> dial1, assuming you do actually want to use foldr, start with the type of foldr
20:50:47 <kmc> :t foldr
20:50:47 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:50:52 <Maxdamantus> @src catMaybes
20:50:52 <lambdabot> catMaybes ls = [x | Just x <- ls]
20:50:54 <ivanm> but yeah, as an initial implementation the list comprehension is probably the best you can get
20:51:01 <kmc> so you're going to write «foldr f z» for some f and z
20:51:13 <kmc> what are the types of f and z
20:51:22 <ivanm> that kind of pattern matching is one of the only times I'll use a list comprehension
20:51:50 <kmc> yeah, it's a useful property of list comprehensions that they discard failed pattern matches
20:51:51 <dial1> f is a function from that takes a,b and returns b; z is something of type b
20:51:59 <kmc> dial1, what are a and b in this particular case?
20:52:28 <dial1> a is a value, b is "nothing" ?
20:53:41 <kmc> b is a type
20:53:43 <kmc> it can't be Nothing
20:53:45 <kmc> Nothing is a value
20:53:59 <kmc> select :: [Maybe a] -> [a]
20:54:00 <kmc> right?
20:54:10 <dial1> right
20:54:44 <kmc> actually i'm going to write that as [Maybe t] -> [t]
20:54:48 <retroj> hello.  i want to use ghci to interactively debug my xmonad.hs, but i find that i must first delete xmonad.o in order for ghci to load my file in interpreted mode.  is there an easier way to tell ghci not to use the compiled version?
20:54:49 <kmc> and «foldr f z :: [a] -> b»
20:55:06 <kmc> so if «select = foldr f z», what are the types a and b?
20:55:07 <dial1> kmc: just to not confuse with the other a?
20:55:09 <kmc> right
20:55:17 <ivanm> retroj: touch xmonad.hs
20:55:22 <ivanm> or just shove a space or something somewhere
20:55:25 <kmc> retroj, ghci -fforce-recomp
20:55:25 <retroj> thank you
20:55:59 <dial1> kmc: a is of type maybe and b is of type Just?
20:56:06 <kmc> dial1, why?
20:56:06 <retroj> perfect
20:56:14 <retroj> many thanks
20:56:27 <dial1> kmc: because we're taking a list of maybes and returning only the justs
20:56:32 <dial1> [a]->b
20:56:51 <kmc> well, Just isn't a type
20:56:54 <kmc> it's a data constructor
20:56:59 <kmc> it's the wrong kind of thing to answer this question
20:57:04 <kmc> i'm saying that the type «[a] -> b» has to become the type «[Maybe t] -> [t]»
20:57:15 <kmc> so what do we choose for a and b to "unify" those two types?
20:57:47 <dial1> type t?
20:58:13 <kmc> for both of them?
20:58:24 <dial1> well, [t] and t
20:58:30 <dial1> wait no
20:58:34 <dial1> that's incorrect, sorry
20:58:47 <dial1> is Maybe t a different type than t?
20:58:52 <dial1> i'm assuming yes
20:58:53 <kmc> yes
20:59:05 <kmc> just like [t] is a different type than t
20:59:11 <dial1> so than a is just Maybe t and b is just t
20:59:14 <Axman6> :t \x -> Just x == x
20:59:15 <lambdabot>     Occurs check: cannot construct the infinite type: a = Maybe a
20:59:15 <lambdabot>       Expected type: Maybe a
20:59:15 <lambdabot>       Inferred type: a
20:59:15 <dial1> [t]*
20:59:15 <kmc> both Maybe and [] are "type constructors" that make a new type based on some other type
20:59:25 <kmc> dial1, that would give us [Maybe t] -> t
20:59:26 <kmc> right?
20:59:45 <dial1> yes sorry, did you see my correction there after Axman's lambda
20:59:50 <kmc> yeah
20:59:51 <dial1> so Maybe t to [t]
20:59:57 <kmc> ok, so a = Maybe t, b = [t]
21:00:05 <dial1> right
21:00:05 <kmc> so now we can start to figure out f and z
21:00:07 <kmc> :t foldr
21:00:08 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:00:18 <dial1> f :: (a->b->b)
21:00:29 <dial1> so f::(Maybe t->[t]->[t])
21:00:31 <kmc> right
21:00:44 <kmc> now, can you write f using pattern-matching?
21:01:22 <dial1> f Maybe t = Just t ?
21:01:33 <kmc> Maybe is a type, not a value
21:01:37 <kmc> you can't pattern-match it
21:01:57 <dial1> hmm right okay. 
21:02:00 <dial1> one moment
21:04:08 <dial1> kmc: http://hpaste.org/40850/foldr_test
21:04:45 <kmc> it has the wrong number of arguments
21:05:00 <dial1> oh right i need two arguments.
21:05:10 <kmc> and it's not going to work because on one branch of the 'case' you return Nothing, but on the other branch you return t, and you don't know that t is a Maybe type
21:05:39 <kmc> you want to take a Maybe value, and a list, and you either append what's inside the Maybe to the front of the list, or you don't
21:05:51 <NewWorld> Hi, I can't figure out why this statement only iterates through values of 'x' only. Can anyone help me out?    pic6 = unwords ([withPaint blue (concat ([rect (x, y) 35 h |  y<- [10,20..100],x <- [10,60..240], h <- [100,90..30]]))])
21:06:14 <kmc> > [100,90..30]
21:06:15 <lambdabot>   [100,90,80,70,60,50,40,30]
21:06:29 <ivanm> NewWorld: what do you mean it only iterates through values of x ?
21:06:48 <dial1> kmc: http://hpaste.org/paste/40850/fix#p40851 ; i'm not sure i understand?
21:07:02 <kmc> f t xs = case f t xs
21:07:09 <kmc> so to determine what the function should do, you call the function?
21:07:12 <kmc> on the same arguments?
21:07:14 <kmc> that's never going to work
21:07:26 <ebensh> hey all, i had a real quick question if anyone's around
21:07:38 <kmc> ebensh, yup :)
21:07:39 <ivanm> ebensh: shoot
21:07:46 <ebensh> kmc: hey :)
21:07:48 <ivanm> not that anyone's around... :p
21:07:59 <kmc> only 600 of us, it's a slow day
21:08:00 * Axman6 reminds ebensh of the first rule of IRC: don't ask to ask, just ask
21:08:09 <ebensh> kmc: in short, trying to get my 194 (byorgey's class) homework running
21:08:17 <kmc> dial1, why don't you start with «f Nothing xs = ...»
21:08:22 <ebensh> kmc: but getting the following error: Editor.hs:107:17: Not in scope: `hSetEncoding'
21:08:22 <NewWorld> ivan:  Function 'rect' is supposed to draw a rectangle. rect (x co-ord, y co-ord) width height. But even though I feed multiple values to 'h' and 'y' as well as 'x'. It only seems to change value for 'x'
21:08:24 <kmc> to handle that case
21:08:26 <dial1> kmc: right i see. i'm just having trouble figuring out how best to use maybe
21:08:27 <kmc> ebensh, import System.IO ?
21:08:29 <ivanm> Axman6: and unfortunately in some channels you then sit there for 6 hours before giving up without anyone else saying a thing :s
21:08:30 <dial1> kmc: okay i'll try it
21:08:57 <ebensh> kmc: hrm... not working
21:09:01 <ivanm> NewWorld: ummm, its valid; sure your definition of rect is correct?
21:09:06 <ebensh> kmc: the editor already imports System.IO
21:09:12 <Axman6> @hoogle hSetEncoding
21:09:12 <lambdabot> No results found
21:09:25 <NewWorld> ivan:  Hmm yeah very strange :S
21:09:30 <ebensh> Axman6: it's part of byorgey's magical editor file
21:09:33 <ivanm> Axman6: I'm guessing lambdabot's hoogle database doesn't know 6.12 stuff
21:09:52 <ebensh> it's possible i'm using a semi-outdated version of haskell (on school server), would that matter?
21:09:59 <ivanm> ebensh: are you using ghc 6.12?
21:10:09 <ebensh> 6.10.4
21:10:20 <ivanm> then hSetEncoding doesn't exist yet ;-)
21:10:21 <ebensh> ivanm: i can try running it on my local machine
21:10:24 <dial1> kmc: is this more what we're looking for?  http://hpaste.org/paste/40850/fix2#p40852
21:10:26 <ebensh> ivanm: ahhh hehe
21:10:32 <ivanm> NewWorld: how are you sure that it isn't working?
21:10:36 <kmc> yes dial1 
21:10:50 <kmc> for the second line, how about «f (Just t) xs = ...»
21:11:23 <dial1> kmc: ah yes makes more sense
21:11:28 <ebensh> ivanm: i'll reboot my linux box and then give it a go
21:11:37 <kmc> so now the right-hand sides
21:11:39 <ivanm> ebensh: or you could probably just get rid of that line
21:11:46 <kmc> we said that f should either add an element to the beginning of xs, or not, right?
21:12:04 <dial1> kmc: right, it should add the element only if it exists
21:12:13 <dial1> or only if it isn't Nothing
21:12:19 <NewWorld> ivan:  The height of the rectangle is not altered. The y-co-ord doesn't change (the rectangle doesn't move down like it should. But the x-co-ord changes (i.e. rectangles are drawn at [10,60..240] intervals
21:12:20 <kmc> right
21:12:35 <ebensh> i'd just like to throw this out there as a general statement: anyone who's extremely proficient in haskell is, in my mind, by definition utterly bonkers
21:12:47 <kmc> haha
21:14:09 <ebensh> oy... so on my laptop, which has ghci 6.12.1, i get the error "Could not find module `Control.Monad.State'"
21:14:16 <dial1> kmc: do I need to change the left hand sides to f Nothing (x:xs) and f (Just t) (x:xs)?
21:14:28 <ebensh> and on the school's server which is ghci 6.10.4, i get the previous error about hSetEncoding
21:14:28 <kmc> no
21:14:34 <kmc> because you want to get the whole list
21:14:38 <kmc> not split into head and tail
21:14:39 <djahandarie> ebensh, cabal install mtl, though you should probably already have that in normal haskell installs...
21:15:24 <dial1> okay i guess that's where the foldr comes into play here so i don't need to do tail recursion
21:15:29 <ebensh> djahandarie: cabal == apt-get package cabal-install?
21:15:34 <kmc> dial1, or indeed any recursion
21:15:55 <djahandarie> ebensh, yeah, the cabal command line is called "cabal-install"
21:16:05 <djahandarie> Confusing names, considering "Cabal" itself is something different
21:16:16 <ebensh> djahandarie: I was thinking of mortal kombat characters
21:16:20 <ebensh> >_>
21:16:20 <ebensh> <_<
21:16:45 <monochrom> mortal kabal
21:16:49 <djahandarie> You could  ghc-pkg list | grep mtl  to make sure it isn't hidden or something
21:17:16 <ebensh> woah... it says i'm using base version 3.x or somesuch
21:17:18 <ebensh> weirdness
21:18:56 <dial1> kmc: f (Just t) xs =  t:xs ?
21:20:37 <Axman6> looks pretty good to me
21:20:46 <Axman6> what about the Nothing case?
21:21:00 <dial1> f Nothing xs = xs ?
21:21:11 <Axman6> nice
21:21:29 <kmc> cool dial1, you got it
21:21:43 <kmc> now what about the 'starting value' for the fold, the z in «foldr f z»
21:22:00 <dial1> kmc, Axman6: thanks. just took me a second to understand what i was trying to do.
21:22:01 <dial1> kmc: hmm
21:22:02 <ebensh> woot, all good :)
21:22:06 <ebensh> i commented out the utf line
21:22:31 <djahandarie> btw, mtl sucks ;)
21:22:51 <dial1> kmc just the empty list?
21:23:11 <kmc> yep
21:27:01 <dial1> kmc: okay so is this what i want ? http://hpaste.org/paste/40850/select#p40854
21:27:23 <kmc> looks good
21:27:29 <kmc> well not quite
21:27:33 <kmc> select = foldr f [] where...
21:27:45 <kmc> if you take the arg 'mas' to select then you have to pass it back into foldr
21:27:50 <dial1> ah right okay
21:27:54 <kmc> but it's easier just to let foldr take it
21:28:01 <dial1> so that's it??
21:28:05 <kmc> well, does it type check?
21:28:13 <dial1> yep!
21:28:14 <kmc> and if so, does it work?
21:29:24 <dial1> yes! select [Just 3, Nothing, Just 2] --> [3,2]
21:29:48 <dial1> kmc, Axman6: thanks so much for your help. i was having trouble wrapping my head around foldr as a concept
21:30:01 <nkpart> @type select
21:30:02 <lambdabot> Not in scope: `select'
21:30:19 <nkpart> oh nevermind me
21:30:31 <dial1> nkpart: just wrote the function locally haha
21:33:00 <retroj> is there any way i can call a non-exported function?
21:33:26 <MiggyX> Hi guys, completely new to Haskell (Real World Haskell is in the post) and the first app that I need to write (and hopefully this is a good one to start with) is a log file analyzer. Basically I have a simple app that records to the log when it receives a message from two feeds. I just need to match up those log entries and then figure out whether feed one was faster than feed two.  Does this sound like a good one to start with? :)
21:34:08 <ivanm> sounds a little advanced
21:34:19 <ivanm> retroj: no
21:34:21 <Axman6> aye, just a little
21:34:28 <ivanm> retroj: not without forking, anyway
21:34:54 <MiggyX> ivanm:  ah pity
21:35:16 <ivanm> MiggyX: note that that'd be true for all languages
21:35:18 <kmc> MiggyX, you can read RWH onlin for free
21:35:33 <ivanm> kmc: I find the dead tree version easier to refer to though
21:35:36 <kmc> true
21:35:36 <ivanm> except for C-f :p
21:35:40 <Axman6> MiggyX: you may be able to write it pretty easily, but if you want to do it properly, and efficiently, it'll take more knowledge of haskell
21:35:48 <kmc> i mean, i don't agree at all
21:35:54 <kmc> so i shouldn't have said 'true'
21:35:58 <ivanm> kmc: heh
21:36:11 <kmc> dead tree has a few advantages
21:36:28 <MiggyX> I prefer dead tree - but I also like to support the authors :)
21:36:29 <kmc> but if you're programming, at your computer, don't you want it on the same screen with copy-paste and search and google etc.?
21:36:48 <Axman6> MiggyX: at least two of them are regulars in here
21:36:51 <Axman6> dons and bos
21:37:16 <bos> CosmicRay too
21:37:44 <MiggyX> Always good to know that you're in good hands :)
21:38:00 <ivanm> bos: I'm trying to write a pretty-printer for text; any suggestions/advice on how to do it properly?
21:38:03 <Axman6> MiggyX: while you're waiting for RWH, i would strongly suggest you start with LYAH, it's free and online (and will be a book soon!), and it's a much more gentle introduction to haskell and its concepts
21:38:33 <MiggyX> There's a lot of scope for other projects here though which is nice :)
21:38:42 <MiggyX> Axman6: I'm on higher order functions at present ;)
21:38:43 <retroj> ivanm: thanks... figured as much but thought i'd ask anyway
21:38:47 <turiya> hi
21:39:08 <turiya> what is the difference between ForeignPtr and Ptr?
21:39:11 <Axman6> MiggyX: in LYAH?
21:39:12 <bos> ivanm: Data.Text.Builder
21:39:21 <MiggyX> Axman6: yeah
21:39:24 <bos> uh, maybe Data.Text.Lazy.Builder
21:39:46 <ivanm> bos: so not to bother with strict Text values?
21:41:01 <bos> ivanm: there isn't a strict builder right now
21:41:07 <ivanm> *nod*
21:41:40 <Axman6> turiya: i believe FireignPtr's have some extra user defined code that's called to deallocate what it's pointing to when the GC feels it can free the pointer
21:41:53 <Axman6> so, basically it is a pointer along with a destructor
21:43:13 <MiggyX> any recommends on simple (ish) type of problems? I really want to build something useful rather than building it for its own sake if you know what I mean...  
21:43:17 <ivanm> bos: so, use Builder as the intermediary type between Doc and Text? or use Builder _as_ Doc?
21:43:24 * ivanm is looking at basing the API on wl-pprint
21:43:36 <ivanm> MiggyX: what kind of stuff interests you programming-wise?
21:44:59 <turiya> Axman6: The destructor is written in C?
21:45:09 <bos> ivan: use it as Doc, yeah
21:45:14 <Axman6> turiya:  i think so, i haven't used them myself though
21:46:00 <MiggyX> ivanm: Well the work I'm doing isn't mostly financial number crunching at present. Mostly use C for that though would love to start seeing Haskell replacing it
21:46:01 <ivanm> bos: so is Builder the ShowS equivalent for Text?
21:46:20 <ivanm> MiggyX: it is or isn't? :p
21:46:40 <MiggyX> ivanm: is lol
21:47:08 <Axman6> well, that's actually one of the places where haskell has seen comercial success, it's use in a few banks and finianial institutions
21:48:43 <bos> ivanm: that's one way to look at it
21:48:46 <MiggyX> Axman6: that is my ultimate goal tbh - using Haskell for that sort of work. I figured I probably shouldn't look to do that on Day 3 however :)
21:48:58 <Axman6> heh, no
21:49:15 <ivanm> bos: how to insert a newline into Text? '\n' `Text.cons` t ?
21:49:26 <ivanm> MiggyX: day 5 is a maybe though :p
21:49:28 <Axman6> though we have some libraries that make it rather nice to do, such as the vector library which lets you write very fast code in a high level style
21:49:42 <bos> ivanm: that puts it on the front, if that's what you want
21:49:54 <ivanm> right, or snoc for the back
21:50:09 <MiggyX> Axman6: that would be awesome :)
21:54:39 <dial1> hpaste
21:55:31 <dial1> anyone have any ideas where i'm going wrong in my definition of treeRecursion? http://hpaste.org/40855/tree_recurse
21:57:12 <Axman6> well, you're applyi8ng f to a, and a is a BinaryTree a, but it is expecting an a
21:59:24 <dial1> Axman6: ah. how can i access that next level then? i want the sub node
21:59:41 <Axman6> well, how are tyou recursing on the b side?
22:00:22 <dial1> treeRecursion f i b ?
22:00:52 <Axman6> yup
22:01:13 <Axman6> also, i don't think you're doing the right hting with the Leaf case, i is another function, from a to b
22:01:46 <Axman6> i think you want 'i a'
22:02:54 <dial1> Axman6: i see. but for the second case, do i want ... = treeRecursion f (f (treeRecursion f i a) (treeRecursion f i b)) a
22:03:21 <Axman6> nope, lose the first call to treeRecursion f
22:03:43 <NewWorld> If I have function:    foo (x,y) | x <- [1,2..10], y <- [10,20..100]     How do I make it so that the output will come out as (1,10), (2,20)... etc. so the values correspond. Instead of getting (1,10),(1,20),(1,30) etc
22:04:06 <Axman6> use zip
22:04:14 <dial1> Axman6: the outer call? so just ... = f (treeRecursion f i a) (treeRecursion f i b)) a ?
22:04:21 <Axman6> > zip [1..10] [10,20..100]
22:04:22 <lambdabot>   [(1,10),(2,20),(3,30),(4,40),(5,50),(6,60),(7,70),(8,80),(9,90),(10,100)]
22:04:31 <Axman6> dial1: and lose the a at the end
22:04:33 <NewWorld> Ohhh thank you Axman
22:04:48 <Axman6> dial1: and once you've done that, think very carefully about what'sn actually going on there
22:05:15 <dial1> Axman6: yeah that's the step i'm on now...
22:07:01 <dial1> Axman6: actually won't compile as is, type error that i've never seen before
22:07:07 <dial1> "Occurs check: cannot construct the infinite type: b = a -> b     When generalising the type(s) for `treeRecursion' "
22:09:47 <solarian-> can anyone tell me why my implementation of the sieve of eratosthenes is so slow? http://hpaste.org/40858/sieveoferatosthenes
22:10:32 <Zao> Consider doing it with arrays or vectors or so?
22:11:15 <solarian-> Zao: i'm a noob, havent gotten there yet.  Glad to know there's something faster though
22:12:49 <Guest86956> Hey guys, I got a small type question. I wonder why my compiler keeps giving me a type error about the following code. Can someone explain to me what is wrong? :( http://hpaste.org/paste/40859/why_doesnt_this_work#p40860
22:14:03 <danderson> pasting the error you get is also useful
22:14:42 <Zao> type clash, expected 'kittens, encountered 'pie
22:15:01 <Guest86956> Oh I'm sorry: the error is couldn't match the expected type 'Trace (Maybe State, [Person])'against the inferred type '[a]'
22:15:18 <Guest86956> In pattern: (Traced a b) : rest
22:16:11 <Zao> Shouldn't that be (Traced a b : rest) ?
22:16:16 <Axman6> try (Traces (a,b))
22:16:36 <Zao> Err, ((Traced (a,b)):rest)
22:16:36 <Axman6> yeah, ((Traces (a,b):rest)
22:16:38 <Axman6> d*
22:16:50 <Guest86956> You mean Traced (a,b)?
22:17:08 <Zao> In your signature, Traced takes a 2-tuple as first arg.
22:17:21 <Zao> While you try to match it as two args.
22:17:28 <Zao> Additionally, you try to match it as a list of lists.
22:17:28 <Guest86956> nope
22:17:46 <Guest86956> I try to match it as a tuple and a list of lists
22:17:55 <Axman6> :\
22:17:55 <Guest86956> because Traced is defined like Traced a [a]
22:17:58 <Axman6> nope?
22:18:01 <Guest86956> nope
22:18:16 <Axman6> well then either your type is wrong, or your definition is wrong
22:18:41 <Zao> If your signature is right, this should be  createTraced s (x:xs) ((Traced (a,b)):rest) = undefined
22:18:57 <dial1> Axman6: any idea regarding my earlier compilation type error?
22:19:15 <Zao> If your annotation is correct, fix your signature.
22:19:19 <Guest86956> oh wait...
22:19:24 <Guest86956> I try something
22:19:29 <Axman6> dial1: you'll need to share your new code and the error you're getting
22:19:51 <Guest86956> this was correct
22:19:52 <Guest86956> createTraced s (x:xs) ((Traced a c):rest) = undefined
22:19:55 <Guest86956> thanks!
22:20:33 <dial1> Axman6: sure, http://hpaste.org/40861/tree_recurse
22:20:53 <Zao> Guest86956: [(Traced a b):rest] matched the type [[Traced a]]
22:21:00 <Axman6> dial1:  f i (...
22:21:01 <Zao> Which is quite far from the type you actually fed it.
22:21:03 <Axman6> urgh
22:21:12 <Axman6> dial1:  f i (...) should be f (...)
22:21:25 <Guest86956> ah thanks guys!
22:22:13 <dial1> Axman6: same error
22:22:45 <dial1> Axman6: actually, appears to be an error with the first case
22:23:04 <Axman6> because you didn't change the first case when i told you to ;)
22:23:10 <Axman6> you want i a, not f i a
22:23:35 <Axman6> i takes the a's in the leaves and turns them into b's for the f function to combine
22:23:54 <dial1> Axman6: aaaahh i'm sorry! i was focusing on the other case at the time i guess. thanks for your patience...
22:25:20 <dial1> @type foldr
22:25:21 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:45:32 <blackdog> ask a stupid question, because my google-fu has failed me: where can i get the prerelease ghc sources?
22:45:50 <ivanm> @ask bos for Builder, I'm guessing that you're meant to use its Monoid instance to compose them together?
22:45:50 <lambdabot> Consider it noted.
22:45:52 <blackdog> just darcs clone http://darcs.haskell.org/ghc-7.0/, or is there a tarball?
22:46:05 <ivanm> blackdog: there's a tarball somewhere; I think it's just in the usual download directory
22:46:10 <ivanm> @google ghc 7 beta
22:46:11 <lambdabot> No Result Found.
22:46:13 <ivanm> bah
22:46:40 <ivanm> preflex: seen tibbe
22:46:40 <preflex>  tibbe was last seen on #ghc 21 hours, 1 minute and 15 seconds ago, saying: indexWordArray# only allows me to make aligned reads, is there a way to make unaligned reads on a ByteArray#?
22:51:10 <blackdog> ivanm: aah, there it is: http://new-www.haskell.org/ghc/dist/7.0.1-rc1/
22:51:42 <kmc> thanks blackdog, i was looking for that
22:52:55 <blackdog> kmc: it was pretty cleverly hidden.
22:53:20 <blackdog> anyone know who's building the mac os x packages?
22:58:02 <kmc> yay, GHC prerelease user's guide
22:58:05 <kmc> christmas has come early
22:58:09 <ivanm> heh
22:58:36 <blackdog> haskell-src-exts seems to be building properly. this gives me cause for much joy.
22:59:16 <kmc> user's guide says "The type checker has been overhauled"
22:59:31 <kmc> this makes me think of SPJ in work overalls and a respirator mask, tearing old insulation out of walls with a crowbar
23:00:18 <ivanm> with that overhaul, did we get superclass constraints for type families?
23:00:24 <kmc> think so
23:00:41 <dolio> I heard they turned them back off.
23:00:44 <kmc> aww
23:00:49 <dolio> Because they weren't working quite right.
23:00:51 <ivanm> :(
23:01:10 <dolio> They were in and working as far as I could tell, though.
23:01:25 <dolio> So I guess I couldn't come up with any nefarious enough examples.
23:03:52 <NewWorld> If I have function:      foo(x y z) | x <- [1,2,3], y <- [4,5,6], z <- [7,8,9]   . How can I make it so that foo is fed with these 3 lists 'zipped'? i.e. So that there are only 3 calls to foo: foo(1,4,7),foo(2,5,8),foo(3,6,9)? Thank you
23:04:29 <nkpart> anyone know off-hand roughly how many packages are up on hackage?
23:04:44 <kmc> alternative layout rules? :O
23:04:56 <ski> > [f x y z | x <- [1,2,3] | y <- [4,5,6] | z <- [7,8,9]] :: [Expr]
23:04:56 <lambdabot>   [f 1 4 7,f 2 5 8,f 3 6 9]
23:05:12 <kmc> nkpart, wget http://hackage.haskell.org/packages/archive/log | awk '{print $8}' | sort | uniq | wc -l
23:05:23 <kmc> ok that gives 0
23:05:25 <blackdog> nkpart: http://www.galois.com/blog/2009/03/23/one-million-haskell-downloads/
23:05:25 <kmc> but you get the idea ;P
23:05:27 <ski> > [f (x,y,z) | x <- [1,2,3] | y <- [4,5,6] | z <- [7,8,9]] :: [Expr]
23:05:28 <lambdabot>   [f (1,4,7),f (2,5,8),f (3,6,9)]
23:05:37 <NewWorld> ski:  Thank you for that hint... I've been trying to wrap my head around this for a while now
23:05:42 <blackdog> bit old, of course
23:05:49 <kmc> 2529
23:05:51 <ski> NewWorld : use a parallel list comprehension, like that .. or `zipWith3'
23:06:07 <blackdog> nkpart: so are we storming the barricades at NZ RailsCamp, for the glory and honour of graph reduction?
23:06:08 <ski> > zipWith3 f [1,2,3] [4,5,6] [7,8,9] :: [Expr]
23:06:09 <lambdabot>   [f 1 4 7,f 2 5 8,f 3 6 9]
23:06:25 <NewWorld> Thank you, once more))
23:06:30 <ski> > zipWith3 (((f .) .) . (,,)) [1,2,3] [4,5,6] [7,8,9] :: [Expr]
23:06:31 <lambdabot>   [f (1,4,7),f (2,5,8),f (3,6,9)]
23:06:45 <ski> > map f (zip3 [1,2,3] [4,5,6] [7,8,9]) :: [Expr]
23:06:46 <lambdabot>   [f (1,4,7),f (2,5,8),f (3,6,9)]
23:07:10 <ski> NewWorld : that's a few different variants
23:07:55 <ski> > getZipList (repeat f `ap` ZipList [1,2,3] `ap` ZipList [4,5,6] `ap` ZipList [7,8,9]) :: [Expr]
23:07:55 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList
23:07:56 <lambdabot>                  ...
23:08:05 <ski> > getZipList (return f `ap` ZipList [1,2,3] `ap` ZipList [4,5,6] `ap` ZipList [7,8,9]) :: [Expr]
23:08:05 <lambdabot>   No instance for (GHC.Base.Monad Control.Applicative.ZipList)
23:08:06 <lambdabot>    arising fro...
23:08:11 <ski> bah
23:08:25 <NewWorld> Haha thanks I have enough now :))
23:08:30 <ski> > getZipList (pure f <*> ZipList [1,2,3] <*> ZipList [4,5,6] <*> ZipList [7,8,9]) :: [Expr]
23:08:31 <lambdabot>   [f 1 4 7,f 2 5 8,f 3 6 9]
23:08:34 <ski> there you go
23:09:50 * ski recalls again why `ZipList' isn't (but `Stream' is) a monad
23:10:32 <ski> NewWorld : note that to use parallel list comprehensions, i think you need to enable an extension
23:10:36 <nkpart> thanks peeps. ~1100 will do me for now
23:11:07 <nkpart> blackdog: thanks for the reminder! I'll try and lock in RC-NZ today
23:11:34 <blackdog> excellent
23:12:54 <Enigmatic> nkpart: i think it's more than that.. http://donsbot.wordpress.com/2010/06/30/popular-haskell-packages-q2-2010-report/
23:13:08 <Enigmatic> though it'd be nice if there was 1100 useful packages :P
23:15:32 * ski wonders what guest2425 wanted ..
23:15:38 <nkpart> Enigmatic: It's for part of talk on the tools for writing haskell. before introducting the various API searches, so higher is better!
23:25:17 <kmc> "Data.Either.partitionEithers in now lazier."
23:25:19 <kmc> yes!
23:25:25 <kmc> small bugs get fixed!
23:40:55 <ystone> Enter text here...
23:40:59 <ystone> hello
23:41:45 <ystone> yo chanserv
23:42:01 <ystone> hey muep
23:42:13 <ystone> can sumbdy help me
23:42:50 <Entroacceptor> how could we know?
23:43:15 <ystone> entroacceptor
23:43:28 <ystone> can u help me
23:43:53 <Elbar> how should he know?
23:44:10 <ystone> can anybody hel me plz 
23:44:10 <blackdog> ystone: ask a question.
23:44:36 <ystone> lol o i need some help on learning how to c++ programing 
23:44:46 <kmc> ystone, this is the wrong channel
23:44:50 <kmc> this channel is about the Haskell language
23:44:52 <kmc> try ##c++
23:45:28 <ystone> + i have a couple of books but they make no sense to me i need sombody to break it down so i can understand it
23:45:40 <ystone> well which is the rite 1
23:45:42 <kfish> what books do you have?
23:45:47 <kmc> ask in ##c++
23:46:23 <ystone> programming and problem solving by nell dale and chip weems
23:46:35 <ystone> its da 4 edition
23:47:14 <kfish> i can see versions for c++, java and ada95
23:47:31 <kfish> do you have a haskell version?
23:47:48 <ystone> hey kmc do u have msn 
23:47:53 <kmc> no
23:48:02 <ystone> or another way we can chat
23:48:04 <kmc> i don't use the internet
23:48:26 <ystone> ur on it rite now arnt u
23:48:38 <kmc> nope
23:48:55 <kmc> ystone, what's this word 'u' mean?
23:48:57 <kmc> i'm not familiar with it
23:49:03 <yitz> @vixen is kmc a bot?
23:49:04 <lambdabot> i can't stand bots
23:49:13 <kmc> self-hating bot :O
23:49:21 <ystone> it means you
23:49:45 <kmc> ystone, ah, what's the point of inventing a new word for 'you'?
23:50:30 <ystone> wats da point of windows inventing a new windos
23:51:34 <kmc> my point is that, on the Internet, nobody knows who you are until you say things.  every opinion is formed from how you speak.  so i'm confused why so many people consciously try to sound like illiterate 12-year-olds
23:51:44 <kfish> ystone, have you read http://learnyouahaskell.com/ ?
23:51:53 <kmc> kfish, <ystone> lol o i need some help on learning how to c++ programing 
23:51:59 <blackdog> hey, anyone managed to get HINT working with ghc 7? looks like a lot of the ghc types changed...
23:52:34 <kfish> kmc, yeah i know :)
23:53:39 <ystone> ok and that was 4
23:55:25 * hackagebot dephd 0.1.5 - Analyze quality of nucleotide sequences.  http://hackage.haskell.org/package/dephd-0.1.5 (KetilMalde)
23:59:55 <kmc> "It is Your Responsibility to make sure that intLookup really behaves as a specialised version of genericLookup!!!"
