00:16:26 <sciolizer> If I'm using -fvia-c, is there a way to see the c code that gets generated?
00:16:54 <Maxdamantus> -C I think
00:17:13 <Maxdamantus> (Assuming GHC)
00:17:16 <kmc> -keep-hc-files
00:18:02 <sciolizer> cool thanks.
00:18:06 <sciolizer> yikes; generated c is not pretty
00:18:59 <kmc> hehehe
00:19:10 <kmc> you can run it through 'indent'
00:19:18 <kmc> you can also run it through 'gcc -E'
00:19:25 <kmc> this helps a little
00:19:39 <kmc> but it's basically assembly-level
00:20:08 <kmc> control flow is abnormal; very little type information; etc
00:20:13 <kmc> pretty much every value has type W_
00:21:04 <sciolizer> heh, yeah
00:22:03 <kmc> if you'd rather read C-- theres -ddump-cmm
00:23:08 <sciolizer> yeah, that is a little nicer
00:23:45 <mjrosenb> i remember going through all of that when i was trying to bootstrap ghc
00:24:02 <kmc> bootstrap to what?
00:24:23 <mjrosenb> bootstrap to run on my desktop
00:25:42 <kmc> oh
00:25:46 <kmc> why were such extreme methods necessary?
00:27:14 <mjrosenb> because nobody had bothered to get ghc to run on ppc64 since 6.4.2
00:27:18 <mjrosenb> and there were issues with it
00:27:22 <mjrosenb> that made it unusable
00:27:38 <mjrosenb> iirc, it did not output correct code for even the simplest programs
00:28:10 <kmc> ah
00:28:15 <kmc> did you start with unregisterised via-C?
00:29:38 <mjrosenb> yup.
00:36:01 <kmc> weird
00:36:47 <kmc> i'm not sure what would make unregisterised via-C produce broken code on a non-cross-compile
00:37:11 <kmc> debugging buggy ghc output with gdb is a fun adventure
00:43:41 <mjrosenb> iirc it got the endianness of file descriptors wrong
00:45:36 <kmc> o.O
00:46:51 <kmc> is it different from the endianness of everything else?
00:54:49 <c_wraith> hmm.  can you encode non-infinite list in the type system in some obvious way?  I guess it'd just be a list with a type-level length
00:55:52 <hiredman> sink a ship
00:56:10 <Maxdamantus> Using tuples?
00:56:11 <Jafet> Data.Sequence
00:57:03 <kmc> a spine-strict list
01:03:09 <c_wraith> Heh.  Spine-strict does force it to be finite, but..  that's not really the type level
01:04:30 <kmc> did you want a type-level list?
01:04:39 <kmc> or a value-level list whose type forces finitude?
01:04:44 <c_wraith> the latter
01:05:06 <c_wraith> the thing about spine-strict is that it doesn't prevent you from attempting to make an infinite list
01:05:13 <c_wraith> at least, not at compile time
01:05:21 <kmc> true
01:05:36 <kmc> there's always plenty of ways to write ‚ä• but you might want to catch this one statically
01:05:46 <Maxdamantus> Deja vu O_o
01:05:59 <kmc> however, it lets you write a finite list without proving it's finite, which could be hard in Haskell's limited type system
01:08:01 <Jafet> A proof of that would have to involve the rest of the program
01:08:29 <Jafet> Unless you carefully nerf what the user can do with them lists
01:09:31 <sipa> data List a = List Integer (Integer -> a)
01:09:43 <sipa> length + function that maps position to value
01:09:50 <kmc> :D
01:10:06 <kmc> Jafet, why would it? when i create a list i can guarantee that list is finite
01:10:13 <kmc> if you want to append stuff, it's on you to prove the new list is finite
01:10:25 <Jafet> Indeed
01:10:41 <Jafet> sipa: heh
01:12:02 <sipa> Jafet: it's guaranteed to be finite, no? ;)
01:12:41 <c_wraith> I feel like type-level naturals on each list node would guarantee finiteness
01:12:46 <c_wraith> But that's massive type hackery
01:12:49 <kmc> they would
01:13:49 <Saizan> massive?
01:14:06 <c_wraith> well, doing subtraction on the type level is massive to me :)
01:14:23 <c_wraith> Actually, that's pretty straight-forward, isn't it?  huh. :)
01:15:16 <Saizan> should be, especially with type families, though it won't be needed often either
01:15:39 <sipa> hmm
01:15:50 <Saizan> data Vec n a where Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a
01:15:53 <Jafet> That's stronger--it guarantees your lists are certain lengths
01:16:08 <kmc> type instance Minus (S x) (S y) = Minus x y
01:16:19 <kmc> type instance Minus Z n = Z
01:16:48 <Saizan> data FiniteList a where FL :: Vec n a -> FiniteList a -- existentially quantify over n if you want to forget the length :)
01:18:12 <Jafet> sipa: Integer isn't supposed to be finite, you mean Int?
01:18:38 <kmc> each Integer represents a finite cardinal number
01:19:10 <sipa> yes indeed, i mean Integer
01:19:15 <sipa> Int would limit the length
01:19:23 <sipa> not only force it to be finite
01:19:34 <Jafet> The set of integers isn't finite, so (Integer->a) could be infinite
01:19:42 <Jafet> Like, I use id
01:19:53 <kmc> Jafet, that's what the other integer is for
01:19:58 <kmc> sets the length
01:20:07 <Jafet> Oh, okay
01:20:10 <sipa> Jafet: the list represented by List n f is [f i | i <- [0..l-1] ]
01:20:22 <sipa> s/l/n/
01:20:26 <sipa> or something like that
01:20:27 <Jafet> Plus you don't need to have negative index errors, eh
01:20:28 <kmc> Int would limit the length, though not really on a 64-bit machine with GHC
01:21:06 <sipa> i'm sure ghc now can work with (some) lists longer than that
01:21:26 <kmc> longer than 2^64-1?
01:22:22 <sipa> it even supports infinite lists
01:22:31 <sipa> > [5..]
01:22:32 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,3...
01:23:02 <sipa> > [5..100000000000000000000]
01:23:03 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,3...
01:23:16 <sipa> there you go, a finite list longer than 2^64-1
01:23:19 <Maxdamantus> > length [5..100000000000000000000]
01:23:23 <lambdabot>   mueval-core: Time limit exceeded
01:23:33 <kmc> mm, and the higher-order representation allows to use the concise description
01:23:51 <sipa> hey i didn't say you would be able to evaluate it completely :)
01:24:07 <kmc> yeah
01:24:15 <kmc> in fact lack of sharing is an issue with that representation
01:24:31 <kmc> you might implement the function by a memo trie
01:25:16 <sipa> actually, i'd think that length [5..100000000000000000000] would work fine, just take a very long time to evaluate
01:28:45 * Maxdamantus wonders if compilers are allowed to optimise length [x..y] to y-x+1 (where length has not been redefined)
01:29:10 * sipa wonders why that wouldn't be allowed?
01:29:25 <dobblego> Maxdamantus, x and y need only be Enum
01:30:00 <Maxdamantus> Yeah, well, I don't know how to count the difference between Enums
01:30:14 <kmc> fromEnum y - fromEnum x + 1
01:30:23 <Maxdamantus> but I'd presume that other than the syntactically built-in constructors, it wouldn't really make a difference?
01:30:43 <Maxdamantus> Oh, ofcourse.
01:31:45 <kmc> is it guaranteed that enumFromTo is strict in both args and fromEnum is strict?
01:33:16 <c_wraith> I don't see any reason that should be guaranteed
01:33:30 <c_wraith> > [undefined..] `seq` ()
01:33:31 <lambdabot>   Ambiguous type variable `a' in the constraint:
01:33:31 <lambdabot>    `GHC.Enum.Enum a'
01:33:31 <lambdabot>      ar...
01:33:32 <kmc> so then the optimization is unsound
01:33:37 <c_wraith> > [undefined :: Int..] `seq` ()
01:33:38 <lambdabot>   <no location info>: parse error on input `Int..'
01:33:46 <c_wraith> > [(undefined :: Int)..] `seq` ()
01:33:47 <lambdabot>   *Exception: Prelude.undefined
01:33:56 <c_wraith> however, that is strict.  Interesting
01:34:40 <c_wraith> > [(undefined :: Integer)..] `seq` ()
01:34:41 <lambdabot>   *Exception: Prelude.undefined
01:34:46 <kmc> > [1..(undefined :: Int)] `seq` ()
01:34:47 <lambdabot>   *Exception: Prelude.undefined
01:34:53 <kmc> > [1,2..(undefined :: Int)] `seq` ()
01:34:54 <lambdabot>   *Exception: Prelude.undefined
01:35:06 <Saizan> you could optimize only for some types
01:42:37 <Phyx-> :t i
01:42:38 <lambdabot> Expr
01:42:44 <Phyx-> botty!!!
01:43:01 <kmc> @. elite nixon
01:43:01 <lambdabot> 4NY lADy who i5 FIRs+ Lady 1ixEs BeIN9 phiR$t |adY. I DoN'+ (4r3 WHa7 t|-|EY S4y, +h3Y |Ixe i+.
01:43:15 <Maxdamantus> > e^(i*pi)
01:43:20 <lambdabot>   mueval: ExitFailure 1
01:43:51 <sipa> > 0 :+ 1
01:43:55 <lambdabot>   mueval-core: Time limit exceeded
01:44:08 <sipa> > realPart (0 :+ 1)
01:44:10 <lambdabot>   0.0
01:44:15 <sipa> > imagPart (0 :+ 1)
01:44:17 <lambdabot>   1.0
01:44:37 <sipa> > let i = 0 :+ 1 in e^(i*pi)
01:44:38 <lambdabot>   No instance for (GHC.Real.Integral (Data.Complex.Complex t))
01:44:38 <lambdabot>    arising fro...
01:46:03 <Maxdamantus> > let i = 0 := 1 in (map (1/) (scanl (*) 1 [1..]))^(i*pi)
01:46:04 <lambdabot>   No instance for (GHC.Real.Integral
01:46:04 <lambdabot>                     (Control.Parallel.St...
01:46:55 <Maxdamantus> > let i = 0 := 1 in (sum . take 100 . map (1/) $ scanl (*) 1 [1..])^(i*pi)
01:46:56 <lambdabot>   No instance for (GHC.Real.Integral
01:46:56 <lambdabot>                     (Control.Parallel.St...
01:47:18 <Maxdamantus> > (sum . take 100 . map (1/) $ scanl (*) 1 [1..]
01:47:19 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:47:24 <Maxdamantus> > sum . take 100 . map (1/) $ scanl (*) 1 [1..]
01:47:26 <lambdabot>   2.7182818284590455
01:49:18 <Maxdamantus> > let i = 0 :+ 1 in (sum . take 100 . map (1/) $ scanl (*) 1 [1..])^(i*pi)
01:49:19 <lambdabot>   No instance for (GHC.Real.Integral (Data.Complex.Complex t))
01:49:19 <lambdabot>    arising fro...
01:59:06 <ClaudiusMaximus> > let i = 0 :+ 1 in (sum . take 100 . map (1/) $ scanl (*) 1 [1..])**(i*pi)
01:59:07 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Complex.Complex t))
01:59:07 <lambdabot>    arising from a ...
01:59:31 <ClaudiusMaximus> > let i = 0 :+ 1 in (sum . take 100 . map (1/) $ scanl (*) 1 (map (:+0) [1..]))**(i*pi)
01:59:33 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
02:00:50 <jamy> why "let head' [a,_] = a" work only with couples (head' [1,2] work | head' [1,2,3] dont anymore)? 
02:01:05 <kmc> because the pattern [a,_] only matches a two-elem list
02:01:09 <kmc> you probably want (a:_)
02:01:21 <sipa> > let {i = 0 :+ 1; r = 1 :+ 0} in (e*r)^(pi*i)
02:01:22 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
02:01:22 <lambdabot>         against inferred ...
02:01:24 <jamy> maybe [a.._] ?
02:01:27 <kmc> > 2 : [3,4,5,6]
02:01:29 <lambdabot>   [2,3,4,5,6]
02:01:34 <kmc> > case [2,3,4,5,6] of (x:xs) -> x
02:01:35 <lambdabot>   2
02:01:52 <kmc> jamy, [a,b,c] is just shorthand for a:(b:(c:[]))
02:02:42 <sipa> > let {i :: Complex Float; r :: Complex Float; i = 0 :+ 1; r = 1 :+ 0} in (e*r)^(pi*i)
02:02:43 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
02:02:44 <lambdabot>         against inferred ...
02:03:08 <sipa> > let {i :: Complex Float; r :: Complex Float; i = 0 :+ 1; r = 1 :+ 0} in (e*r)**(pi*i)
02:03:09 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
02:03:09 <lambdabot>         against inferred ...
02:03:23 <jamy> kmc: who has a privilege? [a,b,c] or a:(b:(c:[]))
02:03:29 <kmc> i don't understand
02:03:40 <sipa> jamy: they are identical
02:03:54 <sipa> but [a,b,_] matches a list of exactly size 3
02:03:59 <ClaudiusMaximus> anyone know any bad interactions between gtk2hs and threading?  for some reason my program uses around 130% cpu when i'd expect it to use 200% - does the gtk main loop sleep or something?
02:04:13 <sipa> jamy: while a:(b:_) matches lists of at least size 2
02:04:26 <jamy> no. in terms of hasskell syntax
02:04:39 <sipa> how do you mean privilege?
02:04:44 <humasect> priority ?
02:04:53 <jamy> yes
02:04:57 <kmc> sipa, a:(b:[]) is more fundamental
02:05:13 <sipa> yes, [a,b] is syntactic sugar for a:(b:[])
02:05:16 <jamy> i see so! :)
02:05:20 <kmc> [a,b] is what we call "syntactic sugar" -- a nicer form which is equivalent
02:05:39 <kmc> the reason a:(b:[]) is more fundamental is that (:) acts like an ordinary (though infix) data constructor
02:05:46 <kmc> whereas the [,,,,] syntax is special and couldn't be user-defined
02:07:20 <jamy> > (1:(2:(3:[]))!!1
02:07:21 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
02:07:36 <jamy> > (1:(2:(3:[])))!!1
02:07:37 <lambdabot>   2
02:08:49 <mjrosenb> kmc: well : is a capital letter.
02:08:55 <kmc> yeah
02:09:11 <jamy> ok! thanks!
02:11:38 <jamy> > :t (+)
02:11:40 <lambdabot>   <no location info>: parse error on input `:'
02:13:27 <mjrosenb> lambdabot seems to not be feeling well still
02:13:27 <Maxdamantus> > [,] "foo" "bar"
02:13:28 <lambdabot>   <no location info>: parse error on input `,'
02:14:53 <quicksilver> :t (+)
02:14:54 <lambdabot> forall a. (Num a) => a -> a -> a
02:14:56 <quicksilver> mjrosenb: ?
02:16:27 <jamy> how i can add c` to a` and b` on one line?
02:16:58 <quicksilver> a+b+c 
02:17:16 <jamy> (+c) a && b ?
02:17:27 <Maxdamantus> O_o
02:17:31 <sipa> :t (&&)
02:17:33 <lambdabot> Bool -> Bool -> Bool
02:18:00 <sipa> jamy: elaborate?
02:18:09 <mjrosenb> jamy: those types.  they don't check.
02:18:12 <quicksilver> well (a&&b)+c is syntactically correct
02:18:13 <jamy> a` and b` dont mix
02:18:26 <quicksilver> but doesn't make sense unless you define a (+) for Bool
02:18:28 <quicksilver> what are you trying to do?
02:18:39 <mjrosenb> or && for int.
02:18:55 <mjrosenb> but boolean operators are not typeclassed :(
02:19:03 <jamy> no! in one action add c to and c to b
02:19:23 <sipa> ah
02:19:25 <jamy> no! in one action add c` to a` and c` to b`
02:19:32 <quicksilver> (a+c,b+c) ?
02:19:36 <sipa> you want (a+c,b+c)
02:19:42 <Maxdamantus> > let x && y = x + y; (a, b, c) = (4, 5, 6) in (+c) a && b
02:19:43 <lambdabot>   15
02:23:59 <jamy> (a+c,b+c) its human like (syntactic sugar). How this write on haskell fundamental syntax?
02:24:38 <anshul> Is the following behaviour of the ghc garbage collector expected--I have compiled my code with profiling options, and when I run ./Main +RTS -stderr, I see a GC activity of 15%, but when I try ./Main +RTS -stderr -p -hy, the GC activity goes through the roof. Thanks 
02:24:52 <bd_> jamy: er, you can write it (a+c,b+c) ... ?
02:26:15 <jamy> maybe (+C) (A,B) ?
02:26:42 <sipa> map (+c) [a,b]
02:26:45 <jamy> > (+1) (2,3)
02:26:46 <lambdabot>   (3,4)
02:26:47 <Maxdamantus> (+) a ((+) b c)
02:27:05 <Maxdamantus> Oh, wait
02:27:11 <sipa> is (Int,Int) an instance of Num ?
02:27:29 <jamy> sipa: yes
02:27:48 <quicksilver> jamy: (,) (a+c) (b+c) is the desugared version
02:27:48 <sipa> apparently in lambdabot it is
02:27:52 <quicksilver> if you count (,) as sugar.
02:28:01 <quicksilver> sipa: just some lambdabot stuff I think, not sure where it comes from
02:28:06 <quicksilver> > (1,2) + (3,4)
02:28:07 <lambdabot>   (4,6)
02:28:11 <quicksilver> > (1,2) * (3,4)
02:28:13 <lambdabot>   (3,8)
02:28:18 <writer> @type (+1) (2,3)
02:28:19 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
02:28:23 <sipa> quicksilver: i guess you could call (,) sugar, in that it would not be possible to write its definition yourself
02:28:34 <quicksilver> right.
02:28:48 <sipa> not sure what the definition is
02:28:55 <Maxdamantus> @pl \a b c -> (,) (a+c) (b+c)
02:28:55 <lambdabot> (. (+)) . ap . ((,) .) . (+)
02:29:05 <Maxdamantus> Hm, fun.
02:30:37 <jamy> (+ Int) [Int] -> [Int]
02:31:48 <sipa> @src (Int,Int) (+)
02:31:49 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
02:32:00 <quicksilver> sipa: @src is useless and should be removed.
02:32:00 <mjrosenb> jamy: , is just an infix constructor that creates tuples
02:32:08 <Maxdamantus> @pl ap f id
02:32:08 <lambdabot> join f
02:32:09 <mjrosenb> however ,, is quite a bit crazier.
02:33:02 <quicksilver> mjrosenb: well, even , is not quite that. It's only valid inside () which is not normal, and it's lower precedence even that things of precedence 0.
02:33:33 <Zao> Tuple sections are even more awesome.
02:33:37 <mjrosenb> fair enough.
02:33:59 <mjrosenb> i would be slightly more horrified had they gone the ocaml route with ,
02:35:55 <jamy> > (+1) [1,2,3,4]
02:35:56 <lambdabot>   No instance for (GHC.Num.Num [t])
02:35:56 <lambdabot>    arising from a use of `e_111234' at <i...
02:36:17 <jamy> > (+1) (1,2,3,4)
02:36:18 <lambdabot>   (2,3,4,5)
02:36:34 <quicksilver> jamy: that's not standard, it's some instances which are in lambdabot for some reason.
02:36:35 <jamy> hm???
02:36:48 <Maxdamantus> > 1 + (2,3)
02:36:49 <lambdabot>   (3,4)
02:36:55 <Maxdamantus> > (1,2) + (2,3)
02:36:56 <lambdabot>   (3,5)
02:36:58 <sipa> jamy: if you'd try that in a vanilla ghci, it would fail
02:36:58 <Maxdamantus> > (1,2) + (2,3,4)
02:36:59 <lambdabot>   Couldn't match expected type `(t, t1)'
02:36:59 <lambdabot>         against inferred type `(t2, ...
02:37:02 <Maxdamantus> >_<
02:37:10 <sipa> Prelude> (+1) (1,2,3)
02:37:15 <sipa>     No instance for (Num (t, t1, t2))
02:37:21 <sipa> is what i get
02:37:27 <mjrosenb> what the deuce was added to lambdabot?
02:37:38 <jamy> sipa: why in lambdabot it has?
02:37:42 <quicksilver> pointwise Num instances for tuples, it looks like
02:37:50 <quicksilver> jamy: because somebody added a module to lambdabot
02:38:00 <quicksilver> > (1,2) / (5,8)
02:38:01 <lambdabot>   (0.2,0.25)
02:38:07 <jamy> what module?
02:38:11 <quicksilver> I don't know.
02:39:03 <sipa> > (2,3) * (5,7)
02:39:04 <lambdabot>   (10,21)
02:39:08 <sipa> > 2 * (5,7)
02:39:10 <lambdabot>   (10,14)
02:39:18 <Maxdamantus> > (2:+3) * (5:+7)
02:39:19 <sipa> > (2,3,5) * (7,11,13)
02:39:20 <lambdabot>   (-11.0) :+ 29.0
02:39:20 <lambdabot>   (14,33,65)
02:39:22 <sipa> > (2,3,5) * (7,11)
02:39:24 <lambdabot>   Couldn't match expected type `(t, t1, t2)'
02:39:24 <lambdabot>         against inferred type `(...
02:40:15 <jamy> sipa: why ghc it doesn't has?
02:40:29 <quicksilver> jamy: because it's a non-standard module.
02:40:32 <quicksilver> you could install it in your GHC
02:40:38 <quicksilver> if we knew what it was, which we don't ;)
02:41:19 <jamy> no! why native HASKELL it doesn't has?
02:41:35 <sipa> native haskell, without even the standard library, has almost nothing
02:41:43 <sipa> the standard library defines some things
02:41:55 <sipa> other modules can define a lot more
02:42:31 <sipa> the answer to why it isn't in the standard library: because people probably didn't think it was worth the effort of including it in the standard :)
02:43:05 <jamy> ok! this syntax dont contradicts to haskell fillosofy?
02:43:10 <mjrosenb> and because it feels like a horrible hack.
02:43:29 <mjrosenb> jamy: *philosophy
02:44:02 <jamy> mjrosenb: yes
02:44:29 <quicksilver> mjrosenb: I'm not sure it's that bad. Pointwise operations are a pretty natural thing.
02:44:47 <quicksilver> mjrosenb: of course, it fails to be a field, but I don't know if that matters
02:44:59 <quicksilver> is Num supposed to abstract fields? who knows.
02:45:25 <mjrosenb> :t ((1,2)+)
02:45:26 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1) -> (t, t1)
02:45:39 <sipa> the (,) syntax is part of the haskell language (eg that () means unit type, (a) is identical to a, and (a,...,b) create tuple types)
02:45:51 <mjrosenb> :t ((1,2)+) 1
02:45:52 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
02:45:53 <sipa> but even * and + are part of the standard library
02:46:09 <tensorpudding> (,) is a type constructor
02:46:22 <tensorpudding> :t (,)
02:46:23 <lambdabot> forall a b. a -> b -> (a, b)
02:46:26 <mjrosenb> this seems false.
02:46:30 <quicksilver> sipa: Num is part of the language, even though much of it is just written in haskell.
02:46:35 <mjrosenb> :k (,)
02:46:36 <lambdabot> * -> * -> *
02:46:53 <quicksilver> sipa: it's required for numeric pattern matches
02:47:00 <quicksilver> (and possibly other stuff I've forgotten)
02:47:12 <sipa> quicksilver: if i don't include the prelude, i don't have Num, right?
02:47:27 <mjrosenb> how can int unify with (t,t1)?
02:47:32 <quicksilver> sipa: not having something in scope isn't quite the same as it not existing :)
02:47:38 <jamy> ok! this syntax dont contradicts to haskell phillosophy?
02:47:39 <quicksilver> mjrosenb: it doesn't.
02:47:45 <mjrosenb> ohh
02:47:48 <quicksilver> mjrosenb: numeric literals are clever
02:47:53 <mjrosenb> right
02:47:54 <quicksilver> mjrosenb: "1" is (1,1) there.
02:48:11 <mjrosenb> literals are Num a => a
02:48:12 <quicksilver> sipa: what would you expect a numeric literal to mean without the prelude in scope?
02:48:19 <sipa> quicksilver: true
02:48:27 <quicksilver> sipa: the report is not really clear on this point
02:48:34 <quicksilver> GHC has some options to contorl what it means
02:48:37 <quicksilver> -XNoImplicitPrelude
02:48:39 <quicksilver> etc.
02:48:42 <mjrosenb> and since (Int,Int) is a Num ....
02:49:30 <sipa> > (5 :: (Int,Int))
02:49:31 <lambdabot>   (5,5)
02:49:38 <sipa> > (5 :: (Int,Integer))
02:49:39 <lambdabot>   (5,5)
02:49:57 <mjrosenb> > 5 :: (Int,(Int,Int))
02:49:58 <lambdabot>   (5,(5,5))
02:50:08 <quicksilver> jamy: I don't think there is a contradiction, no.
02:50:42 <sipa> it's just providing a definition for things that aren't allowed by default
02:50:59 <mjrosenb> abs (3,4)
02:51:07 <mjrosenb> > abs (3,4)
02:51:08 <lambdabot>   (3,4)
02:51:16 <mjrosenb> :t abs
02:51:17 <lambdabot> forall a. (Num a) => a -> a
02:51:25 <sipa> > (1,2,3,4) + (8,7,6,5)
02:51:26 <lambdabot>   (9,9,9,9)
02:52:03 <mjrosenb> > (1,(2,3))+((10,20),30)
02:52:04 <lambdabot>   ((11,21),(32,33))
02:52:16 <jamy> quicksilver: then why this doesn't including to vanilla ghc?
02:52:31 <quicksilver> jamy: GHC doesn't include everything which does not contradict haskell philosophy.
02:53:28 <jamy> quicksilver: ok! then why this doesn't including to module prelude?
02:53:36 <quicksilver> no reason.
02:53:38 <quicksilver> it just isn't.
02:53:46 <quicksilver> there are lots of things which aren't in the prelude which could be.
02:53:54 <mjrosenb> > (\x -> x + (x,x)) 12
02:53:55 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, a)
02:55:51 <Maxdamantus> Why isn't fix, ap, join, .. in Prelude? :\
02:56:07 * Maxdamantus keeps forgetting what packages they're in when trying to use ghci
02:56:22 <sipa> fix isnt't in prelude :o
02:56:30 <Maxdamantus> Apparently not
02:56:35 <sipa> :t join
02:56:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
02:56:45 <Maxdamantus> Hang on, lemme try my later ghci
02:56:54 <Maxdamantus> Nope.
02:57:18 <jamy> what modules is the main for simple work?
02:57:21 <Maxdamantus> > join (,) 5
02:57:22 <lambdabot>   (5,5)
02:57:38 <Maxdamantus> > ap (,) (*3) 5
02:57:39 <lambdabot>   (5,15)
02:57:54 <jamy> > (,) 5
02:57:55 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> (t, b))
02:57:56 <lambdabot>    arising from a use...
02:58:07 <Maxdamantus> > join "test"
02:58:08 <lambdabot>   Couldn't match expected type `[a]'
02:58:08 <lambdabot>         against inferred type `GHC.Types...
02:58:19 <sipa> > (,) (5 :: Int)
02:58:20 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> (GHC.Types.Int, b))
02:58:20 <lambdabot>    arisin...
02:58:31 <sipa> > ((,) 5) :: (Int,Int)
02:58:31 <lambdabot>   Couldn't match expected type `(GHC.Types.Int, GHC.Types.Int)'
02:58:32 <lambdabot>         again...
02:59:26 <Maxdamantus> Isn't ap one of the S-K combinators?
02:59:32 <Maxdamantus> one is const, and the other's ap
02:59:39 <quicksilver> jamy: the haskell platform is a reasonable way to start
03:00:20 <pozic> If you have a rho like structure and you delete the reference pointing at the cycle, will the cycle also be collected? I am pretty sure Haskell doesn't have these silly issues that some other languages have. 
03:02:11 <quicksilver> yes, haskell has true GC, not refcounting
03:02:19 <quicksilver> all unreachable structures are collected, cyclic or not.
03:02:35 <quicksilver> s/haskell has/GHC and hugs and I think all the others/
03:02:57 <quicksilver> of course, you can still cause space leaks if you accidentally leave somethiing reachable when it shouldn't be.
03:03:08 <quicksilver> GHC's GC is exact; I think JHC might possibly have a conservative one.
03:03:41 <Maxdamantus> Does GHC do anything to detect easily recomputable values to free?
03:03:48 <mjrosenb> yeah, refcounting or not, if you think an integer is a pointer, you can lose big time
03:04:35 <quicksilver> Maxdamantus: no.
03:04:45 <quicksilver> Maxdamantus: although there is a weak reference library I think.
03:04:54 <quicksilver> if you want to manage that yourself
03:04:56 <ClaudiusMaximus> hm, if i enable +RTS -hT i get  internal error: heapCensus, unknown object: -1814250194  (where the number changes on different runs..)
03:05:05 <quicksilver> System.Mem.Weak
03:05:16 <Maxdamantus> Hm.
03:05:16 <ClaudiusMaximus> no time to debug now, bbl
03:05:25 <quicksilver> ClaudiusMaximus: sounds like a bug, mention it on #ghc or make a trac.
03:05:29 <quicksilver> ok ;)
03:06:13 <quicksilver> mjrosenb: the probability of doing so is fairly low, these days. On a 64 bit machine with randomised memory layout the odds of a genuine Int also being a valid pointer are surprisingly low.
03:06:15 <Jafet> @let k = const; s = ap
03:06:17 <lambdabot>  Defined.
03:06:29 <quicksilver> mjrosenb: unless of course your program is directly or indirectly storing things calculated from memory addresses.
03:07:28 <Jafet> @check \x -> (s.k.k) x == id x
03:07:29 <lambdabot>   Couldn't match expected type `b -> c'
03:07:38 <Jafet> @check \x -> (s k k) x == id x
03:07:38 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
03:08:00 <Maxdamantus> \x -> id x
03:08:21 <Maxdamantus> @check \x -> (s k k) x == \x -> id x
03:08:22 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
03:08:27 <Maxdamantus> :\
03:08:36 <Jafet> @pl ap const const
03:08:37 <lambdabot> id
03:08:39 <Jafet> Haha
03:08:44 <quicksilver> @check doesn't have access to the @let namespace
03:08:44 <lambdabot>   Parse error at "let" (column 29)
03:08:46 <quicksilver> I don't think.
03:09:02 <jamy> > :t (=>)
03:09:03 <lambdabot>   <no location info>: parse error on input `:'
03:09:05 <quicksilver> @pl ap.const.const
03:09:05 <lambdabot> (.) . const
03:09:14 <quicksilver> Jafet: I remark that skk != s.k.k
03:09:28 <jamy> @map (=>)
03:09:28 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
03:09:38 <Jafet> Your remark is noted
03:09:42 <quicksilver> ;)
03:09:51 <jamy> > map (=>)
03:09:52 <lambdabot>   <no location info>: parse error on input `=>'
03:10:10 <quicksilver> jamy: => is not a funtion, it's syntax
03:10:48 <jamy> i cant use him without :: ?
03:12:57 <quicksilver> jamy: I don't understand that question.
03:16:31 <jamy> => using only in signature definition?
03:18:00 <sipa> jamy: => is part of the notation for writing types
03:18:05 <sipa> not for writing values
03:20:03 <sipa> :t (undefined :: [] Int)
03:20:04 <lambdabot> [Int]
03:21:54 <jamy> i say what => dont using without ::        :)
03:23:13 <ketil> jamy: type Foo = Num a => a -- no double colons
03:23:27 <ketil> (but needs rank 2 types, I guess)
03:24:09 <sipa> instance Show t => Show [t] where { ... }
03:24:11 <sipa> no ::
03:31:40 <jamy> cheat
03:33:00 <kamatsu> hmm
03:33:09 <kamatsu> jdh30 seems to have moderated a bit
03:33:28 <kamatsu> my vote count for him overall on reddit is now positive, because i was agreeing with him surprisingly often
03:33:42 <kamatsu> he seems to sing praises to simon marlow
03:34:07 <Phyx-> and that's why you agree with him?
03:34:16 <kamatsu> well, simon marlow collects our garbage
03:34:45 <Phyx-> well.. I'm not saying Simon Marlow isn't awesome
03:34:59 <Phyx-> but.. that's not reason to like someone because they think so too
03:35:00 <Phyx-> lol
03:35:07 <kamatsu> but he seems to have tuned down the haskell hate
03:35:20 <kamatsu> and doesn't really support OCaml anymore
03:37:21 <Phyx-> lol
03:37:26 <Phyx-> maybe they rejected him :)
03:37:30 <Twey> I thought he was into F# now
03:46:56 <kamatsu> yeah, mostly
03:48:41 <Phyx-> oh, so he's one of *those*
03:50:26 <HugoDaniel> where can i read about static types versus dynamic ?
03:50:37 <HugoDaniel> advantages and disadvantages of each
03:54:10 <kamatsu> HugoDaniel: don't worry about it, statics win 
03:54:20 <kamatsu> for a less biased opinion, there was a good stack overflow topic
03:57:20 <HugoDaniel> :D
03:57:24 <HugoDaniel> kamatsu i know statics win
03:57:32 <HugoDaniel> i would like to write about it for a project im building up
03:58:11 <HugoDaniel> i need to write some 3 articles for my website, so that it has content when it goes live :)
04:00:01 <kamatsu> hah
04:00:09 <kamatsu> perhaps learn, and then write tutorials for, Agda
04:00:19 <kamatsu> i'm sure Agda people would appreciate some beginner friendly introductions to it
04:00:50 <Saizan> go for "dynamic types are not types at all"
04:01:16 <kamatsu> Saizan: hm, i'm intrigued. What's your angle there?
04:01:16 <Saizan> or some more inflammatory phrasing :)
04:02:39 <Saizan> kamatsu: that they serve a quite different purpouse, they are not about knowing properties of your program
04:04:41 <pozic> Saizan: there are about excluding certain kinds of behaviour at run-time. Crashing is just not one of them. 
04:07:18 <Saizan> pozic: that seems unrelated to what i was saying :)
04:08:23 <pozic> Saizan: you will have the property that you don't execute random numbers like in C or C++. 
04:13:15 <ddarius> Bounds checking also helps avoid certain kinds of behavior at run-time.
04:17:54 <Maxdamantus> @pl (unzip .) . zip
04:17:54 <lambdabot> (unzip .) . zip
04:18:17 <sipa> @unpl (unzip .) . zip
04:18:17 <lambdabot> (\ d g -> unzip (zip d g))
04:18:54 <Twey> @pl \unzip zip -> (unzip .) . zip
04:18:55 <lambdabot> (.) . (.)
04:20:54 <ddarius> :t uncurry zip
04:20:55 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
04:21:06 <Saizan> pozic: true, i should have said properties specific to my program
04:21:39 <sipa> @pl \x z -> (x .) y z
04:21:40 <lambdabot> (. y)
04:24:40 <Quadrescence> you want to know what is annoying haskell's type system is annoying
04:25:23 <ddarius> Quadrescence wants a yes-man for a language.
04:25:53 <Quadrescence> this code was decently ok to write but it is useless http://codepad.org/0JDU46ew
04:26:03 <Botje> call it the obama type system :P
04:27:18 <Quadrescence> especially because haskell likes to get confused about whether something is Num or <one of my type classes [i know about numerichaskell {so don't bring it up w/o good reason}]>
04:27:23 <ddarius> Why would you put an Eq constraint on Monoid?
04:27:43 <Quadrescence> I expect to be able to compare items
04:28:42 <ddarius> And what about the rather important endofunction monoid?
04:28:52 <ddarius> Or the pointwise monoid?
04:29:01 <Quadrescence> what about them
04:29:27 <ddarius> You can't make functions an instance of Eq sanely.
04:29:38 <Quadrescence> Of course not but who cares
04:30:06 <ddarius> Well, you have a point.  Since no one is going to use this code, no one will care.
04:31:18 <Quadrescence> Correct
04:33:18 <Quadrescence> ddarius: I was writing it for a blog article "haskell for mathematicians" but now i just want to change "haskell" to "lisp" :S
04:34:06 <Maxdamantus> Are there any "popular" Haskell-like dynamically typed languages?
04:34:13 <Maxdamantus> obviously much simpler than Haskell
04:34:19 <Saizan> Quadrescence: it gets confused about what?
04:34:26 <Maxdamantus> but with the lambda calculus stuff and stuff
04:34:31 <Quadrescence> Maxdamantus: scheme
04:35:00 <Quadrescence> Saizan: I don't know, try ... I don't remember
04:36:19 * ddarius sticks to his original statement, at any rate.
04:36:45 <benmachine> Eq isn't things that can be equal, it's things that you can work out if they're equal or not
04:36:56 <benmachine> no reason why Monoid would be that
04:38:22 <benmachine> Quadrescence: what do you mean by useless what is actually the problem
04:38:34 <benmachine> Quadrescence: note that Num might come up because numeric literals are inherently Num
04:38:53 <Quadrescence> benmachine: yeah, that's the issue
04:39:09 <Quadrescence> so i have to explicitly type junk to use it
04:39:38 <benmachine> I don't get it
04:39:40 <benmachine> why is that an issue
04:40:15 <benmachine> ok, you have gcf x y | degree y <= 0 = x
04:40:39 <benmachine> hmm no never mind
04:41:12 <Saizan> s/0/addId/ ?
04:41:14 <benmachine> just define an integerToWhatever function
04:41:19 <benmachine> Saizan: no, degree :: a -> Int
04:41:27 <benmachine> hence never mind
04:42:00 <Saizan> yeah, a custom fromInteger + NoImplictPrelude
04:42:37 <Saizan> though i'm not sure in terms of what classes you could write that one
05:06:10 <dbelange> Are there any better alternatives to Haskell?
05:06:32 <sipa> yes, php, for example
05:06:37 <sipa> no stupid static type checks
05:06:41 <Ke> NOOOOOOOO
05:06:54 <sipa> oh, and x86 assembly
05:07:16 <Ke> r800 asm is way better
05:07:18 <dbelange> I like Haskell, but yeah, the type checks are pretty bad
05:07:25 <dbelange> I'd like to have a void*
05:07:35 <sipa> dbelange: i was being ironic, i hope you're not ;)
05:08:26 <Maxdamantus> Yeah, I bet you do hope dbelange wasn't being ironic.
05:08:44 <FauxFaux> I can't even begin to think why you'd want a base type like void* or Java's Object in Haskell.
05:09:07 <sipa> dbelange: you have a void*, Ptr (), but it's only useful when interacting with foreign libraries
05:09:21 <dbelange> I don't like being completely beholden to the interpreter
05:09:34 <dbelange> when I know exactly what the bytecode is going to have to look like
05:10:19 <dbelange> I guess an inline assembler would work too, but at that point I could probably just do it with a hex editor
05:10:59 <Maxdamantus> You could get GHC to output C code, then add inline assembly, which is supported by gcc
05:11:36 <sipa> you could just write some performance-critical parts in C, and use FFI to link to it, if you really need to
05:11:55 <dbelange> oh is there a monad for that?
05:12:03 <sipa> no, an extension
05:12:33 <sipa> calls to external functions are typically done in the IO monad
05:12:57 <dbelange> See, that's the trouble, I don't want an IO monad
05:13:04 <dbelange> I need complete transparency
05:13:11 <dbelange> this is return-oriented programming
05:13:24 <zygoloid> dbelange: you could use the llvm monad :)
05:14:19 <sipa> dbelange: if you know the functions you call are referentially transparent (meaning they have no observable side-effects, and may be called more than once), the IO monad is not necessary
05:16:13 <dbelange> I like zygoloid's idea
05:22:11 <McManiaC> is anyone in here using the darcsweb project on his lighttpd server?
05:27:47 <ddarius> dbelange: See also Harpy.
05:40:31 <dcoutts> ClaudiusMaximus: gtk2hs and threading is a tricky subject
05:41:36 <Phyx-> 14:06:44 < dbelange> I like Haskell, but yeah, the type checks are pretty bad <-- say wha?
05:42:18 <burp> uh, type checks are bad? 
05:42:26 <Phyx-> that's like saying you like cars, but the driving thing is pretty bad
05:42:43 <ray> well, that is an entirely defensible opinion
05:43:00 <ray> i wish all my roads were like the racetrack
05:43:01 <Phyx-> touche.. bad example
05:43:16 <sipa> the advantage to haskell is that as soon as it compiles, it has a pretty high chance of actually working :)
05:43:29 <Phyx-> sipa: unless you have a "head" in there :P
05:43:33 <Phyx-> then good luck finding it :P
05:43:35 <Phyx-> heheh
05:43:38 <ray> anyway, ghc error messages are sometimes obtuse
05:43:54 <kamatsu> The good thing about Agda is that it doesn't compile at all unless it works 
05:43:59 <sipa> Phyx-: ?
05:44:09 <Vitka> head shoud've been named unsafeGiveHead.
05:44:12 <burp> or !! of some kind
05:44:16 <Vitka> Sorry, had to say it.
05:44:37 <Phyx-> unsafeGetHead would be more appropriate
05:44:37 <sipa> ah yes
05:44:42 <ray> unsafe!veryUnsafe!listUnsafeHead
05:44:57 <sipa> there's nothing unsafe about it
05:45:02 <Phyx-> sipa: well, I mean, debugging haskell is hard at times
05:45:08 <sipa> Phyx-: yes, true
05:45:11 <ray> nonTotalHead?
05:45:22 <Phyx-> partialHead doesn't sound as fun
05:45:44 <ray> sounds kinda like a partial derivative which is fun
05:46:38 <Phyx-> hmm I'm out of cornflakes...
05:46:49 <Phyx-> :t for
05:46:50 <lambdabot> Not in scope: `for'
05:46:52 <Phyx-> :t forM
05:46:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
05:47:38 <Phyx-> @quote
05:47:38 <lambdabot> IceDane says: [on escaping an imperative mindset]: <kmc> i recommend heavy drinking <IceDane> I've tried that. I just have fun and wake up and feel like shit the day after. but still think in loops.
05:47:58 <Phyx-> lol
05:48:03 <Phyx-> @quote
05:48:03 <lambdabot> tolkad says: PHP is an elegant, expressive, simplistic yet powerful language
05:48:18 <Phyx-> what's with all the PHP love here recently
05:48:40 <ray> php is like your cornflakes
05:48:46 <ray> they are out of it
05:49:24 <ketil> HugoDaniel, the "type" part of dynamic type and static type are different things. This causes an endless torrent of confusion.  IMO
05:49:32 <ray> programming languages are like anvils: heavy and useful to blacksmiths
05:50:42 * ddarius hopes to start blacksmithing in the not distant future.
05:50:43 <ClaudiusMaximus> dcoutts: i know, if you have any practical tips i'd appreciate them - bit busy today, maybe i'll write to the list this evening though
05:51:03 <ray> a monad is like a toxic waste burrito placed on an anvil: it's a monoid on a category of endofunctors
05:51:08 <chrisdone> in what way do the following differ?
05:51:08 <chrisdone> x :: X
05:51:08 <chrisdone> x = ...
05:51:08 <chrisdone> and
05:51:08 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
05:51:11 <chrisdone> x = ... :: X
05:51:22 <chrisdone> I don't want no stinkin' messages
05:51:35 <Phyx-> ray: lol
05:51:49 <ray> it would depend on how tightly :: binds? however tight that is
05:52:00 <quicksilver> chrisdone: I can't think of a way they differ, off-hand.
05:52:12 <quicksilver> chrisdone: was it a trick question?
05:52:39 <chrisdone> no, in the past I've experienced the compiler allowing the former but not the latter
05:52:40 <dcoutts> ClaudiusMaximus: I've used concurrency (not parallelism) with gtk2hs in "serious" projects. I used the single-threaded RTS.
05:53:05 <chrisdone> quicksilver: let me see if I can reproduce an example
05:53:30 <ketil> ray: and voil·, a Monad tutorial!
05:53:43 <quicksilver> chrisdone: the former might bring type variables in scope
05:53:53 <quicksilver> chrisdone: if you're using -XScopedTypeVariables
05:53:59 <Phyx-> chrisdone: I can think of one, but that's really only applicable when higher rank types aren't used.
05:55:34 <Phyx-> well, no, nvm, in GHC that's not the case anyway
05:56:05 * Phyx- is off to get more corn flakes. they hold my haskell powers
05:56:47 <pythonic72> how can I simplify "glClear $ fromIntegral gl_COLOR_BUFFER_BIT"
05:56:51 <pythonic72> i.e. how can I go from glenum to glbitfield without int conversion
05:56:54 <pythonic72> re: http://hackage.haskell.org/packages/archive/OpenGLRaw/1.1.0.0/doc/html/Graphics-Rendering-OpenGL-Raw-Core31.html#t:GLbitfield
05:57:20 <chrisdone> ah, I found a small example case
05:58:17 <quicksilver> pythonic72: I don't know but it wouldn't surprise me if you can't. That is the low level wrapper after all.
05:59:06 <Phyx-> @src fmap
05:59:06 <lambdabot> Source not found. The more you drive -- the dumber you get.
05:59:14 <Phyx-> @src (.)
05:59:15 <lambdabot> (f . g) x = f (g x)
05:59:15 <lambdabot> NB: In lambdabot,  (.) = fmap
05:59:38 <chrisdone> quicksilver: http://hpaste.org/paste/40541/type_signature_on_expression_i#p40542
06:00:00 <pythonic72> would it be more "standard" for me to use OpenGL nonraw?
06:00:01 <chrisdone> quicksilver: admittedly when TypeFamilies are introduced I don't really know what's going on
06:00:34 <quicksilver> chrisdone: that's probably the DMR
06:00:37 <pythonic72> nevermind I dont like that question
06:00:40 <chrisdone> quicksilver: the DMR is?
06:00:48 <quicksilver> dreaded monomorphism restriciton
06:00:55 <chrisdone> oh, I always forget about that
06:00:57 <chrisdone> let me try
06:01:10 <quicksilver> add NoMonomorphismRestriction to your LANGUAGE line
06:01:15 <chrisdone> quicksilver: you were right
06:01:18 <quicksilver> \o/
06:01:20 <quicksilver> do I get a cookie?
06:01:27 <Phyx-> no
06:01:30 <chrisdone> @quicksilversnack
06:01:30 <lambdabot> Unknown command, try @list
06:01:32 <Phyx-> we ran out of cookies
06:01:36 <ray> a monomorphic cookie
06:01:41 <Phyx-> would you like a muffen instead?
06:01:59 <chrisdone> quicksilver: but I don't see why it fails at the expression level but not the declaration level. can you explain?
06:02:40 <quicksilver> chrisdone: because that's the monomorpishm restriction :)
06:02:41 <ClaudiusMaximus> dcoutts: well, i have a dual core machine and i'd like to use both cores (it's a toy project so far, a mandelbrot set renderer)
06:02:48 <quicksilver> it's not that your signature is failing
06:02:56 <quicksilver> it is that it is incompatible with the one inferred
06:03:01 <quicksilver> (in the presence of the MR)
06:03:28 <quicksilver> because the MR forbids type-class polymorphic signatures on definitions with no syntactic parameters.
06:03:52 <chrisdone> I see. why?
06:03:54 <quicksilver> ...unless you specifically annotate at the declaration level.
06:04:12 <quicksilver> a specific annotation at the declaration level is understood to mean "I know what I'm doing, I don't want the MR to apply to me, please"
06:04:25 <quicksilver> a specific annotation at the expression level is not understood in the same way.
06:04:28 <ClaudiusMaximus> dcoutts: threadscope has been slightly helpful, but there are strange gaps where once core is idle, and it's hard to tell why (my current hunch is that 1 capability is blocked waiting for gtk events)
06:04:35 <quicksilver> Why? Concerns about memoization/sharing.
06:04:43 <quicksilver> I don't really accept those concerns, but there you are ;)
06:04:59 <chrisdone> hmm, ok. I'll read the report for more information on that then
06:05:15 <quicksilver> the report is very brief on this point
06:05:18 <Maxdamantus> > sum $ takeWhile (>1e-100) . map (1/) . scanl (*) 1 [1..]
06:05:18 <quicksilver> IIRC the wiki is better
06:05:19 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
06:05:19 <lambdabot>    arising from a use...
06:05:50 <chrisdone> oki
06:05:59 <ray> the wiki has a long page
06:06:09 <quicksilver> chrisdone: http://www.haskell.org/haskellwiki/Monomorphism_restriction
06:06:17 <ray> the report has a confusing paragraph
06:06:23 <quicksilver> also http://book.realworldhaskell.org/read/using-typeclasses.html
06:06:32 <quicksilver> (search for monomorphi in that page)
06:08:40 <chrisdone> quicksilver: well at least it's optional
06:10:17 <chrisdone> the concept of using a dictionary for methods is odd to me. I don't know why it's not just separate functions
06:11:20 <chrisdone> ("The trouble is that typeclasses essentially introduce additional function parameters -- specifically, the dictionary of code implementing the instances in question. In the case of typeclass polymorphic pattern bindings, you end up turning something that looked like a pattern binding -- a constant that would only ever be evaluated once, into what is really a function binding, something which will not be memoised. CaleGibbard 23:46, 1
06:11:20 <chrisdone> February 2008 (UTC)")
06:13:00 <chrisdone> I thought when I implemented Show Int, a show_int function was generated at compile time. but really it seems like it's more like show_instances.push(show_int); show a = lookup "int" show_instances
06:13:06 <chrisdone> am I missing something?
06:13:36 <ddarius> chrisdone: Neither of those is what happens though they could be what happens.
06:13:39 <chrisdone> (er, I meant show instance a = lookup instance show_instances)
06:13:56 <chrisdone> ddarius: does it actually do a runtime lookup for the particular instance?
06:14:01 <ddarius> chrisdone: No.
06:14:56 <Saizan> for ghc it's more like data Show a = Show { show :: a -> String } (ignoring the other methods)
06:14:56 <ray> is it linktime? i don't know much about implementations
06:15:13 <ddarius> A "show_int" function is sort of "generated" (rather it's just your code), the question is what happens when something -uses- show.
06:15:29 <Saizan> so, when you do instance Show Int where .. you're doing "show_int = Show (...)"
06:16:31 <Saizan> then if you have a function "foo :: Show a => a -> ...;" and you call it like "foo (1 :: Int)" you're calling "foo show_int (1 :: Int)"
06:16:46 <ddarius> chrisdone: foo x = show x, foo :: Show a => a -> String.  This becomes foo :: ShowDict a -> a -> String and when the compiler resolves that to Int, it passes in ShowIntDict to foo and the 'show' in foo will select the 'show' field of that dictionary.
06:17:52 <ddarius> Of course, it is also mostly possible to specialize everything and this is how JHC works and GHC can do this to some extent.
06:18:39 <chrisdone> ah, ok
06:20:28 <chrisdone> what's the benefit of doing it with a dictionary? ease of implementation?
06:21:19 <sipa> one generic generated function
06:21:20 <Saizan> code size, separate compilation, ..
06:21:26 <sipa> instead of one per instance
06:21:54 <Jonny> Hi
06:22:52 <chrisdone> it's not clear to me why. but I'll take your word for it, I've never implemented a compiler
06:23:08 <ray> why is it so much more fun to run programs than to write them
06:23:29 <Botje> ray: disagree. if your programs run on the first try, writing them is more fun
06:23:52 <earthy> writing is always more fun
06:24:15 <earthy> once it runs without problems a program quickly bores me
06:24:41 <sipa> chrisdone: imagine you'd write a showTwice :: Show a => a -> String; showTwice x = show x ++ show x
06:24:59 <sipa> showTwice does not know what type a it will be passed
06:25:01 <chrisdone> earthy: how do you know it's without problems? it might be killing your family while you're not looking
06:25:29 <Botje> it'd run out of memory long before it gets there.
06:25:33 <Saizan> what's the sound of a family that gets killed while you're not looking at it?
06:25:45 <sipa> chrisdone: and if the call to it is in another module that's compiled separately, there is no way of knowing what types a it could even be called with
06:25:46 <Botje> of course, if you subscribe to charles stross's view to computational demonology .. :)
06:25:48 <ray> boring is good. if you decided that, say, ping sucked, and decided to rewrite it and change one of its behaviors slightly for no reason
06:25:53 <earthy> chrisdone: it might be. so might any number of other things. ;)
06:26:03 <ray> you would be a real person because someone did that
06:26:03 <donri> "If a family gets eaten in the forest when no one is there to hear it, does it really happen?"
06:26:05 <TimS> Can anyone decipher an error message for me?
06:26:06 <TimS> http://hpaste.org/40543/error
06:26:36 <sipa> chrisdone: so either you generate a separate function showTwice_Int, showTwice_Float, that calls the respective show_Int or show_Float function (or inline them)
06:26:45 <TimS> I'm being stupid
06:26:46 <Botje> TimS: it thinks leap accepts a float or somesuch
06:26:46 <TimS> ignore me
06:26:52 <Botje> TimS: give an explicit type :)
06:26:58 <Jonny> Please can someone help me with a recursion.... Basically the function im creating computes x^y mod n               Im using the fact that xy mod n = (xmod n)(y mod n)mod n          to say that x^y mod n = (x^0.5y mod n)(x^0.5y mod n)mod n    And so it calls itself recursively twice to keep halving the problem - but what should the base case be please? 
06:27:05 <TimS> Yeah, I just realised that
06:27:10 <Saizan> Botje: rather, mod doesn't return a Bool
06:27:16 <Saizan> ?type mod
06:27:17 <lambdabot> forall a. (Integral a) => a -> a -> a
06:27:25 <Botje> Jonny: if x < n ?
06:27:26 <Saizan> ?type \x y -> mod x y == 0
06:27:27 <sipa> chrisdone: or you generate code that receives a dictionary with the correct show function in as additional parameter, and uses the show function in there
06:27:28 <lambdabot> forall a. (Integral a) => a -> a -> Bool
06:27:31 <Botje> oh, heh
06:27:33 <Botje> that too
06:28:35 <Jonny> But its only y changing not x and n
06:29:27 <chrisdone> Saizan: hahaha
06:29:48 <Botje> Jonny: then check if y < n, i guess?
06:30:03 <Botje> wait, that doesn't make much sense
06:30:08 <Botje> i don't know, then
06:30:32 * zygoloid discovers with surprise that fmap = (.) does not obey the Functor laws
06:30:34 <gds> Does anyone know how to hide code from ghc in birdtrack style lhs files?
06:30:52 <zygoloid> > (fmap id undefined :: a -> b) `seq` ()
06:30:53 <lambdabot>   ()
06:31:39 <ddarius> zygoloid: What you are discovering is that Haskell types and functions don't form a category.
06:31:55 <zygoloid> ddarius: or that we have the wrong definition of (.) ;)
06:32:26 <zygoloid> "(!f . g) x = f (g x)" looks like it'd work
06:32:49 <zygoloid> hmm, no. "!f . g = \x -> f (g x)"
06:33:39 <ray> gds: comment it out by not explicitly uncommenting it in
06:33:54 <ddarius> Or just comment it out.
06:33:57 <chrisdone> sipa: ah, I see now. by instantiating a specialised function per call-site it would substantially increase code size
06:34:01 <ray> regular comments work too i think
06:34:01 <gds> ray: I was hoping to have it typeset nicely in the latex...
06:34:23 <ray> but you said bird tracks!
06:34:23 <gds> There's a note on the wiki that suggests I can use \begin{code}% Extra comment to hide from ghc
06:34:33 <gds> Yes - I'm using lhs2tex
06:34:46 <gds> Perhaps I shouldn't?
06:35:08 <zygoloid> gah, you need "!f . !g = \x -> f (g x)" to ensure "id . f = f", and that definitely seems too strict for everyday use
06:35:31 <ray> that is pretty strict!
06:35:45 <ray> gds: i guess just use normal comments
06:36:01 <ray> you can explain to the reader
06:36:05 * gds plays with things
06:36:18 <chrisdone> sipa: (I mean SomeModule.foo 1 and SomeModule.foo 'a' would need to generate SomeModule_foo_Int and SomeModule_foo_Char. thanks for enlightening moi)
06:37:06 <ray> say "uncomment the commented line when running on YHC during a full moon"
06:37:10 <ray> or whatever
06:39:44 <gds> Ah - perhaps I'm being overly specific - I'd like to hide a like from haskell, but typeset it like code.
06:39:58 <gds> The canonical example on the wiki is:
06:40:14 <gds> "The following definition would break by code if I defined it:
06:40:22 <gds> \begin{code}% Not real code
06:40:24 <fghj_> do var <- print "hi"; if (var=="hi") then print (var) else print "no"
06:40:24 <kamatsu> gds: \begin{code}% is the only way i could find to do it
06:40:26 <ddarius> I recommend reading the lhs2TeX documentation.
06:40:29 <gds> defn = defn
06:40:46 <gds> kamatsu: Yeah, I'm having problems with that...
06:40:58 <gds> ddarius: thanks - I'm doing so now.
06:41:00 <kamatsu> gds: what exactly? sorry for floating into the middle of the conversation
06:41:39 <gds> kamatsu: np - thanks for interest - lhs2tex is also typesetting the latex-comment
06:41:56 <kamatsu> it does that
06:41:57 <gds> If I remove the latex-comment, then the line messes up my executable file.
06:42:22 <kamatsu> i just mentioned in my lhs file that sections marked with a % do not actually constitute part of the program
06:42:30 <kamatsu> so it looks like i set it that way intentionally
06:42:31 <ddarius> My rolls smell amazing.
06:42:52 <kamatsu> there's always the nuclear option
06:42:54 <gds> kamatsu: heh - nice :)
06:43:21 <kamatsu> patch lhs2tex yourself
06:43:26 <kamatsu> add required features
06:43:44 <kamatsu> i would thank you as I usually write literate haskell
06:43:53 <fghj_> Is there any way to use "fromJust" and get Nothing as a result instead of *** Exception: Maybe.fromJust: Nothing
06:43:54 <kamatsu> my haskell has a tendency to become enormous and unreadable otherwise
06:44:00 <fghj_> when the value is Nothing
06:44:03 <Botje> fghj_: uh. no.
06:44:08 <kamatsu> fghj_: i don't think you understand Maybe types 
06:44:08 <gds> I'll add it to my todo list ;)
06:44:10 <sipa> :t fromMaybe
06:44:11 <Botje> fghj_: pattern match on the maybe value you get
06:44:11 <lambdabot> forall a. a -> Maybe a -> a
06:44:24 <sipa> fghj_: or use fromMaybe instead of fromJust
06:44:34 <Botje> or use the (fromMaybe/maybe) function to specify a default value
06:47:42 <Funktorsalat> fromNothing (credits: someone else)
06:47:55 <sipa> :t fromNothing
06:47:56 <lambdabot> Not in scope: `fromNothing'
06:48:17 <Funktorsalat> Maybe a -> () 
06:48:29 <sipa> :t (undefined :: Maybe a -> ())
06:48:30 <lambdabot> forall a. Maybe a -> ()
06:49:08 <fghj_> i got a function that solves a Sudoku and returns a Maybe [[Maybe Int]], so when it gets a impossible Sudoku it returns Nothing.
06:49:30 <fghj_> it works for possible sudokus
06:49:42 <sipa> what does it return if you give a sudoku with exactly one solution?
06:49:50 <sipa> i'd use a [[Int]]
06:50:00 <fghj_> it takes the first solution
06:50:23 <fghj_> do sud <- readSudoku "Sudoku.sud"; print (fromJust(solve sud)
06:50:38 <fghj_> returns a sudoku fomatted in a readable format
06:51:16 <fghj_> but when i use it on a impossible sudoku i get *** Exception: Maybe.fromJust: Nothing
06:52:02 <Saizan> fghj_: putStrLn (maybe "Nothing" show (solve sud))
06:53:12 <monochrom> ‚ô• haskell
06:53:42 <fghj_> thank you Saizan, it worked perfectly
06:56:14 <zomg> fghj_: what algorithm did you use to solve the sudoku? Just curious as I've implemented something to do that in JS myself
06:59:51 <ray> what a lie
07:04:07 <HugoDaniel> how do i import qualified in ghci ?
07:04:40 <Lemmih> HugoDaniel: The first step is to install ghc-7.
07:04:44 * EvanR-work wants to know too
07:04:47 <HugoDaniel> ah :(
07:04:48 <fghj_> :t maybe
07:04:49 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:05:06 <roconnor> does Mercurial have full-tree merge or 3-way merge?
07:09:07 <ezyang> Crazy ideas time: what if it wasn't a stack trace we wanted in Haskell, but a future trace? (That is, where the computation was going?) 
07:09:35 <Lemmih> ezyang: Go on...
07:09:58 <ezyang> For example, one complaint about TCO is that you lose information about the stack, since it just overwrites the previous frame. 
07:10:08 <ezyang> This seems like a pretty fundamental problem. 
07:10:43 <aristid> roconnor: those people who claim that git is complicated and hg is the solution... mercurial is extremely complex too
07:10:50 <ezyang> But actually, when we walk the stack for information about where we've come from, that's not actually what we're doing: we're looking at where the computation would return when you call 'ret' 
07:11:11 <aristid> didn't find how mercurial merges tho :/
07:11:21 <roconnor> aristid: I'm just trying to figure out if Mercurial has "correct" merging like darcs has
07:11:33 <ezyang> In the end, it's all continuations. So all Haskell needs is a way to inspect the future continuations from an error. 
07:11:40 <aristid> roconnor: what does "correct" mean?
07:11:59 <ezyang> Consider, also, laziness, so that if I'm traversing down some data structure I could force a thunk that evaluates to error. 
07:12:46 <ezyang> Yeah, so, crazy idea of the day. 
07:12:55 <dolio> Proper tail calls don't build up continuations.
07:13:01 <roconnor> aristid: it means that if you have a history tree with A -> B -> C on one branch and A -> Z along another branch, then merging Z into B and then merging that into C is the same as just directly merging it into C.
07:13:07 <roconnor> aristid: if that makes any sense
07:13:12 <dolio> They just call with the same continuation they were passed.
07:13:27 <ezyang> dolio: Fair. 
07:13:54 <aristid> roconnor: but the patch might not apply cleanly to C
07:14:16 <roconnor> aristid: assuming no conflicts
07:14:27 <dolio> Really, stack traces and dumping the continuation on an error are the same thing.
07:14:43 <dolio> For different execution models.
07:14:59 <roconnor> aristid: well what I really mean is that there will be a conflict with merging directy into C if an only if there is a conflict in one of the steps when merging via B
07:14:59 <ezyang> Yeah, agreed. 
07:15:14 <roconnor> aristid: hence "the same"
07:15:15 <roconnor> result
07:16:12 <ezyang> dolio: Another idea is that, if a statement hadn't errored, it probably would have created a different continuation: can we guess what that might have been? 
07:16:23 <aristid> roconnor: git offers a couple of different merge strategies, not sure which of them would be "correct"
07:16:34 <monochrom> I write back trace and future trace by hand. I need both to show other people how their code is flawed.
07:17:05 <monochrom> Or to show how my code is impeccable.
07:17:42 <aristid> Default strategy of git: [recursive] can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged
07:17:42 <aristid>            tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing
07:17:42 <aristid>            mis-merges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this can detect and handle merges involving renames.
07:18:24 <ezyang> Or, another idea is that a stack trace fairly naturally expands into a series of continuations: can we inspect our continuation and split it into a series of continuations? 
07:18:37 <monochrom> I write the complete trace from start to end. There is no divide between back and future. Only the reader's cursor makes the divide, and it moves.
07:19:09 <roconnor> aristid: git certainly does not have correct merging
07:19:36 <EvanR-work> whats correct merging?
07:19:49 <aristid> roconnor: none of the strategies are "correct"? have you really looked at all of them?
07:19:51 <roconnor> EvanR-work:  it means that if you have a history tree with A -> B -> C on one branch and A -> Z along another branch, then merging Z into B and then merging that into C is the same as just directly merging it into C.
07:20:37 <roconnor> aristid: I was refering to what you wrote
07:21:03 <aristid> roconnor: right, i can give you the list of all strategies.
07:21:49 <monochrom> I write the trace so coders will shut up. I write the trace I write the trace. ‚ô´
07:21:54 <aristid> roconnor: http://hpaste.org/40544/git_merge_strategies
07:22:18 <ddarius> monochrom: Don't you write programs to write the trace for you.
07:22:20 <ddarius> ?
07:22:49 <roconnor> aristid: none of those appear to be correct at first glance
07:23:18 <roconnor> aristid: thought i don't really understand subtree merge
07:23:46 <aristid> roconnor: i normally avoid thinking about merge strategies, if they work well enough for me. and i'm not sure if a "correct" strategy would perform better in real-world test cases
07:23:59 <roconnor> aristid: maybe not
07:23:59 <monochrom> I haven't done that. Too lazy, didn't realize = tl;dr
07:24:30 <cathper> Any hints?
07:24:31 <cathper> ghc: panic! (the 'impossible' happened)
07:24:31 <cathper>   (GHC version 6.10.4 for i386-apple-darwin):
07:24:32 <cathper>         linkBCO: >= 64k insns in BCO
07:25:27 <EvanR-work> git has a complex user interface?
07:25:41 <EvanR-work> seems pretty simple to me
07:26:08 <Lemmih> cathper: You've hit a limit in ghci.
07:26:08 <EvanR-work> i never worry about merge strategies, if octopus doesnt work oh well ;)
07:26:35 <Lemmih> cathper: You can compile with ghc before loading in ghci.
07:27:05 <cathper> Lemmih: Compile before loading---how?
07:27:17 <ddarius> Lemmih: Or there is corruption.
07:28:14 <cathper> It happens after ghci spend some seconds on compiling a module with quite some very (I mean *very*; 64k) long lists.
07:28:28 <cathper> 64k entries, that is.
07:28:33 <Lemmih> cathper: Right, ghci can't deal with that.
07:28:43 <aristid> EvanR-work: octopus is only used for crazy merges anyways :)
07:29:02 <Lemmih> cathper: You can compile the file with ghc. ghci will then used the compiled code.
07:29:09 <cathper> 6.8.2 gives me "*** Exception: stack overflow".
07:29:13 <dolio> ezyang: The continuation contains a lot of extra information beyond stack traces, too. And that information is unlikely to be useful for debugging.
07:29:34 <Lemmih> cathper: Well, then you have to refactor your code. (:
07:29:49 <hrmlgon2> cathper: either you outright have too much, or you're evaluating something and it's just being thunked
07:29:55 <dolio> ezyang: The reason people want to see stack traces on errors is that they want to know what sequence of events (function calls) led to the error in question.
07:29:56 <hrmlgon2> probably the former
07:29:59 <EvanR-work> aristid: just recently missed a chance to do an octopus merge, i did several normal merges :(
07:30:08 <aristid> EvanR-work: *tsk*
07:30:59 <ezyang> dolio: Hmmm 
07:31:04 <dolio> ezyang: Knowing everything that would have happened subsequently if said error condition didn't arise won't help you know what prior events caused the error.
07:31:21 <cathper> hrmlgon2: Nothing is being evaluated. It's just a "database" that has long list.
07:32:20 <dolio> And strictly speaking, a continuation probably wouldn't have that information either, unless it has information about what functions we're jumping back into, similar to the stack trace.
07:32:43 <ezyang> dolio: An argument I'd like to reply with is that knowing about the future ought to help us debug, but I don't have a good story on that. 
07:32:48 <ezyang> dolio: Yeah. 
07:33:10 <ezyang> The stack trace difficulty with Haskell might be largely from "GHC is a sufficiently clever compiler" 
07:33:35 <frerich3> ezyang: I think having an omniscient debugger would be useful if you know that some defect is in the system but you don't see when it was introduced (it might spread quite a bit before you notice it).
07:33:48 <dolio> Stack traces are useless in Haskell because stacks aren't fundamentally related to function calls.
07:33:50 <EvanR-work> ezyang: what about 'compile with debug symbols / in debugger friendly structure"
07:33:52 <roconnor> aristid: http://web.archive.org/web/20070606182509/http://zooko.com/badmerge/concrete-good-semantics.html
07:33:53 <EvanR-work> ""
07:34:06 <dolio> And they aren't related to how values come to be built.
07:34:23 <frerich3> ezyang: In that case you could stop at the beginning and then go forth (and back) in time, watching what expressions are evaluated (and what they evaluated to).
07:35:05 <ezyang> EvanR-work: Yes. But this is a lot of work if you're someone like GHC :-) 
07:35:07 <roconnor> aristid: actually the abstract version http://web.archive.org/web/20070603113858/zooko.com/badmerge/simple.html is easier to read first
07:35:28 <EvanR-work> ezyang: "compile with not GHC" ;)
07:35:34 <ezyang> HEh. 
07:35:46 <EvanR-work> for debugging purposes
07:36:31 <dolio> If you want to know "why is x equal to 5 when it should be equal to 4," knowing what would happen if x were 4 doesn't help you.
07:36:34 <fghj_> :t maybe
07:36:35 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:36:55 <dolio> But stack traces in a traditional imperative language can tell you something about the path through the program that caused x to be 5.
07:37:49 <ezyang> dolio: In some cases, knowing what would happen if x were 4 gives you context about what x is. But yeah, that's probably true in general. 
07:38:19 <ezyang> I wonder if GHC logging its mutations into a circular buffer would give useful info. 
07:38:33 <ezyang> probably too low level. 
07:38:49 <EvanR-work> low level wouldnt be that bad if there were adequate labels
07:39:01 <EvanR-work> like name of top level functions
07:39:09 <EvanR-work> or where clause names
07:39:15 <aristid> roconnor: i'm a bit too tired to be able to really understand this :/
07:39:15 <dolio> I imagine a better approach is not trying to salvage something stack-trace-like as your debugging method.
07:39:20 <ddarius> ezyang: Look up Omniscient Debugging.
07:39:49 <benmachine> dolio: the haskell stack is sort of a stack of pattern matches, isn't it?
07:39:56 <ezyang> ddarius: Oh, is that an actual phrase? (goes and looks it up) 
07:39:57 <benmachine> or, could be viewed as such
07:40:08 <dolio> Something like that.
07:40:12 <ezyang> dolio: I think so too. 
07:40:35 <benmachine> that could be useful, if you had information on where the pattern match was initiated
07:40:40 <ddarius> The return stack is just a representation of a continuation; it has exactly the same information.
07:40:49 <ddarius> s/return stack/hardware stack
07:41:03 <benmachine> I'm not sure what fusion would do to your hopes of debugging though
07:41:06 <ezyang> "The ODB is as close to a silver bullet as you can get. Why don't people use it?
07:41:06 <ezyang> I don't get it. :-( " That's very sad. 
07:41:14 <dolio> Evaluating 'case foo of <p -> e>' pushes 'case - of <p -> e>' onto the stack and evaluates 'foo'.
07:41:25 <benmachine> is the code that's being run actually terribly similar to the code you wrote >_>
07:41:41 <silver> ezyang, what's ODB?
07:41:42 <dolio> Or, unless evaluating of foo is not required.
07:41:45 <benmachine> @google ODB
07:41:46 <lambdabot> http://odb.org/
07:41:46 <lambdabot> Title: Our Daily Bread Daily Devotional
07:42:00 <EvanR-work> its functional programming, you can do as much testing as is possible by providing an array of test inputs
07:42:01 <benmachine> huh, I got Search Results
07:42:01 <benmachine>    1.
07:42:02 <benmachine>       Ol' Dirty Bastard - Wikipedia, the free encyclopedia
07:42:02 <monochrom> our daily bullet :)
07:42:03 <ezyang> omniscient debugger 
07:42:23 <ezyang> EvanR-work: Not useful if you don't know what function to provide test inputs to. 
07:42:36 <ezyang> Or the function is some inner helper that you don't know the context of. 
07:42:40 <EvanR-work> that process could be automated, give you each sub expression and ask you for input or an io action to get the input
07:43:08 <monochrom> when people say "stack trace" I silently drop their "stack" and just go happen to write an evaluation or execution trace.
07:43:08 <EvanR-work> starting with the most simple
07:43:13 <monochrom> s/happen/ahead/
07:43:42 <EvanR-work> if haskell is high level it needs high level debugging
07:44:02 <aristid> monochrom: do what they want, not what they say they want
07:44:06 <EvanR-work> we already know the low level stuff is taken care of
07:44:20 <monochrom> you give programmers what they need, not what they want, much less what they manage to say they want. programmers are the worst natural-language users in the world.
07:44:32 <meditans> anybody knows what the error hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)  does mean?
07:44:32 <benmachine> EvanR-work: I worked with a thing for transforming a Haskell AST, providing debugging inputs in full was a pain in the butt
07:44:33 <monochrom> (that's why they become programmers to begin with)
07:45:05 <meditans> it's about UTF8 encoding, i read
07:45:06 <benmachine> meditans: it might be you're trying to read a binary file in text mode?
07:45:12 <meditans> but I don't know how to fix
07:45:13 <aristid> monochrom: i disagree about the "wors natural-language users" part, but i guess that was dramatization on your part
07:45:15 <ddarius> My experience is that programmers tend to be better speakers/writers than many.
07:45:23 <meditans> i'm reading html files
07:45:26 <monochrom> (just look at how their docs are tautologies and how their irc questions require crystal balls)
07:45:32 <benmachine> monochrom: I hate programmers, they're rubbish.
07:45:55 <meditans> benmachine: no, i'm reading only html files
07:46:01 <ddarius> monochrom: Yes, but you have to compare to non-programmers, and I can assure you, they are no better.
07:46:15 <benmachine> meditans: possibly the html file is encoded in something that doesn't match your locale
07:46:30 <benmachine> ddarius: I hate people, they're rubbish.
07:46:37 <aristid> there probably are better speakers and writers than programmers are, but that by no means means that programmers are the worst
07:46:38 <EvanR-work> i hate rubbish
07:46:59 <aristid> benmachine: fortunately there is still maths remaining to be loved
07:47:03 <benmachine> aristid: <3
07:47:11 <ddarius> benmachine: I agree we should get rid of them.
07:47:11 <Nibble> EvanR-work: and in soviet russia, I rubbish hate.
07:47:17 <meditans> benmachine: it's possible, I'm analising wikipedia in other languages. However, how do I add the encoding to my locale?
07:47:50 <benmachine> meditans: I'm not absolutely sure, it might work if you set LC_ALL to something more appropriate
07:48:01 <benmachine> meditans: alternatively, you could read the file in binary mode and decode it yourself
07:48:22 <benmachine> (only suggesting that because I don't know how the other works)
07:48:44 <meditans> benmachine: the first is worth a try. How do i set LC_ALL to something more appropriate?
07:49:10 <benmachine> meditans: are you running linux? because if you're running windows I have no idea :P
07:49:28 <meditans> benmachine: yes, I'm running linux
07:49:32 <benmachine> ok
07:50:02 <benmachine> you can set it for a single command by going
07:50:07 <benmachine> LC_ALL=something ./foo
07:50:22 <benmachine> valid values for "something" are given by 'locale -a'
07:50:47 <benmachine> LC_ALL=en_GB.iso88591 ./myprogram perhaps
07:50:50 <meditans> benmachine: is there a way to include all locales?
07:51:11 <benmachine> meditans: that would be reading the file in binary mode, basically
07:51:21 <benmachine> meditans: that just gives you the bytes, but it doesn't tell you what they mean
07:51:34 <benmachine> so non-ASCII characters will get garbled
07:51:46 <benmachine> you have to decide how to interpret those characters, which is non-obvious
07:51:57 <benmachine> if you're getting pages from a website, the encoding would be in the HTTP headers
07:52:02 <benmachine> or it might be in a <meta> tag
07:52:55 <monochrom> then you decode yourself. as in, you call the decode routines with the right parameters.
07:53:09 <benmachine> yeah, utf8-string can be useful there I think
07:53:18 <meditans> benmachine: ok.. i'm checking the file
07:53:52 <benmachine> hmm utf8-string would be useful for UTF8 but I guess we already know that doesn't work
07:55:02 <meditans> benmachine: the file says charset=UTF-8
07:55:33 <benmachine> meditans: huh, that's weird
07:56:02 <meditans> benmachine: so I have to add UTF-8 to locales with LC_ALL=UTF-8?
07:56:18 <monochrom> LC_ALL=en_GB.iso88591 is emphatically an antithesis to UTF-8, of course
07:56:39 <benmachine> meditans: you don't add to locales, you set the locale, there can only be one
07:56:51 <monochrom> en_GB.utf8
07:56:55 <benmachine> yes
07:57:00 <benmachine> something like that
07:57:21 <meditans> benmachine: ok, got it :). And LC_ALL is a shell variable, isn't it?
07:57:30 <monochrom> environment variable
07:57:49 <benmachine> yeah
07:58:07 <benmachine> if you want to set it from the shell you need to use 'export', or you can just put it in front of the command like I showed you
08:03:59 <cathper> Lemmih: When I use ghc to compile the file with looong lists, I add +RTS -K32768000 to prevent a stack overflow. ghc doesn't succeed but gives me to following error:
08:04:02 <cathper> /usr/lib/ghc-6.8.2/libHSrts.a(Main.o): In function `real_main':
08:04:04 <cathper> (.text+0x12): undefined reference to `__stginit_ZCMain'
08:04:09 <cathper> [another similar error]
08:04:18 <cathper> collect2: ld returned 1 exit status
08:04:55 <cathper> Hmm, wait.
08:05:26 <quicksilver> you get errors like that if you try to compile a module as if it was a whole program, I think.
08:06:33 <cathper> quicksilver: Right.
08:06:48 <cathper> I just figured :-)
08:07:20 <Lemmih> cathper: Yeah, use -c or --make.
08:08:22 <cathper> I added --make :-)
08:13:09 <meditans> benmachine: so I executed LC_ALL=en_US.UTF-8 ./progname but it continued giving me the same error.
08:13:26 <meditans> i don't manage to open this file neither from ghci
08:14:17 <meditans> when I open it in vim, it shows some strange characters, in the middle of the file, but he can handle it
08:15:08 <Twey> You need to do more to enable a locale on your system than just set the environment variable‚Ä¶
08:15:57 <meditans> twey: could you tell me more, or suggest me a guide where to learn? I don't know how to do..
08:16:00 <monochrom> the file is html, so you can view it in firefox. does it look right in firefox? what does firefox say in "view page info" -> "encoding"?
08:17:00 <Twey> meditans: What operating system are you running?
08:17:27 <meditans> twey; kubuntu linux
08:17:50 <meditans> monochrom: firefox opens it, and says UTF-8 encoding
08:18:12 <meditans> monochrom: it displays some strange russian characters, however
08:18:26 <monochrom> that's strange because kubuntu would have done the right setup (insisting on utf-8 throughout) and ghc in that setup would have done the right thing too (opting for utf-8)
08:19:11 <monochrom> oh, so the file is not in UTF-8 afterall. try everything under "view" -> "character encoding" until the whole page is right.
08:19:16 <Twey> Maybe the file is not UTF-8?
08:19:18 <Twey> Yeah.
08:21:08 <monochrom> ubuntu sets LANG=blahblah.UTF-8 and ghc-compiled programs pick that up and go with UTF-8 too.
08:21:27 * hackagebot logic-TPTP 0.2.0.4 - Import, export etc. for TPTP, a syntax for first-order logic  http://hackage.haskell.org/package/logic-TPTP-0.2.0.4 (KiYungAhn)
08:22:56 <HugoDaniel> if there are lexical errors ghci ommits semantical ones :(
08:23:03 <HugoDaniel> and type errors 
08:23:37 <HugoDaniel> ...its a bit painfull 
08:23:46 <HugoDaniel> it would be nice if it could print them all at once
08:23:56 <monochrom> yeah, I would prefer parsers to just say "lexical errors" for all errors.
08:23:59 <Lemmih> HugoDaniel: That's nigh impossible.
08:24:11 <sipa> it would require guesswork
08:24:25 <monochrom> in fact, even the type-checker just says "lexical errors"
08:24:49 <monochrom> I used Apple II and it just said "syntax error".
08:24:50 <benmachine> it would be neat if someone wrote a correcting parser for haskell like the stuff that uu-parsinglib does
08:25:18 <benmachine> and then it would go "maybe you meant:" or something
08:25:33 <benmachine> "if you did, it would have been a type error anyway:"
08:25:41 <benmachine> because, you know, GHC really isn't verbose enough as it is.
08:26:23 <monochrom> my Sharp PC-1500 was even better. It just said "error 2".
08:26:50 <benmachine> http://hackage.haskell.org/package/hello ok I'm really interested in how this package managed to get two upgrades
08:27:05 <benmachine> ...and it has a darcs repository
08:27:37 <monochrom> hehehehe
08:28:24 <meditans> benmachine: i decided to look at the problem from a different perspective: how can I tell haskell to try to open a file and do his operation, and skip the file if he manages not?
08:29:11 <benmachine> meditans: you can catch exceptions thrown from IO operations using 'catch'
08:30:05 <fryguybob> Oooo hello has a threaded option.
08:30:11 <benmachine> meditans: e.g. withFile fp $ \h -> processFile h `catch` \e -> hPutStrLn stderr (show e)
08:30:14 <benmachine> something like that
08:31:33 <benmachine> withFile fp $ \h -> processFile h `catch` \e -> hPutStrLn stderr (show (e :: IOException)) -- if you're using extensible exceptions
08:31:49 <meditans> benmachine: thanks, I will learn about catch; there exist a function like try?
08:32:07 <benmachine> meditans: yes; see Control.Exception
08:32:20 <benmachine> http://hackage.haskell.org/packages/archive/base/4.2.0.2/doc/html/Control-Exception.html
08:34:05 <monochrom> System.IO.Error has a lesser try. where lesser means more.
08:35:28 <benmachine> monochrom: and more means...? :P
08:35:50 <monochrom> less means less general. more means more ready to be used.
08:36:21 <monochrom> a more general function requires more learning to be used.
08:36:28 <benmachine> right, yes
08:36:41 <benmachine> I'd have recommended the less general one had I remembered it existed
08:43:35 * hackagebot MorseCode 0.0.2 - Morse code  http://hackage.haskell.org/package/MorseCode-0.0.2 (AndyStewart)
08:44:26 <ManateeLazyCat> Enjoy Morse Code. :)
08:45:16 <chrisdone> haskelldb does not quote column and field names (I am shocked and appalled by this). does anyone have a patched version which fixes this ridiculous oversight? I'm doing it manually now but I'd appreciate not spending time doing it
08:47:35 <quicksilver> it's mentioned in the BUGS file, I doubt that's any comfort
08:49:24 <chrisdone> well at least it's acknowledged. I will submit a patch some time this week after testing
08:50:18 <chrisdone> genuinely shocked though. how could someone not think of this?
08:50:27 <chrisdone> bleh
08:51:15 <Botje> most people are trained to avoid pain, ie not using reserved keywords unless they have to :)
08:51:42 <chrisdone> I don't have the good fortune to be working with my own database ;)
08:52:34 <chrisdone> besides, trying to avoid keywords is poor practise
08:52:54 <quicksilver> chrisdone: I have a feeling it's partly because there is a frustrating lack of uniformity between DB backends on how to do the quoting.
08:53:16 <quicksilver> Botje: most "large" databases I have worked with have had at least one column which collides witha  reserved words
08:53:27 <quicksilver> there are a lot of them, and vendor dialects sometimes add more
08:53:55 <quicksilver> "order" is a favourite collision in commerce-type systems.
08:54:16 <Botje> heh heh :)
08:55:01 <chrisdone> the SQL standard's not freely available, so I can't check. but from what I've seen, delimited names with double quotes is standard
08:55:26 <monochrom> create table "table" ( "index" integer, "name" string, "order" integer, "with" integer, "by" string )
08:55:26 <sipa> is there any sql reserved keyword that contains a _ ?
08:55:26 <chrisdone> mysql has `foo`, ms sql has [foo], postgres has "foo", but I'd wage they all support "foo"
08:55:36 <mcnster> hi.  anyone willing to help me understand the difference between IArray and Array?
08:55:43 <quicksilver> mcnster: Array is a data type
08:55:49 <quicksilver> mcnster: IArray is a type class
08:56:00 <quicksilver> Array implements IArray (but it is not the only type to do so)
08:56:04 <EvanR-work> gah why is it called IArray >_<
08:56:09 <quicksilver> ImmutableArray
08:56:14 <EvanR-work> ok
08:56:20 <EvanR-work> so someone wasnt drinking too much java / c#
08:56:26 <mcnster> quicksilver, what does it mean that it is "immutable"?
08:56:34 <sipa> not mutable
08:56:34 <quicksilver> mcnster: that you cannot change any of the cells
08:56:39 <sipa> no destructive update
08:56:49 <EvanR-work> it does support updates though
08:57:22 <EvanR-work> make sure they are infrequent or over a lot of cells at once
08:57:33 <quicksilver> well, it supports 'functional updates' in the sense of returning a new array with some cells changes, yes
08:57:37 <quicksilver> but they copy everything.
08:57:42 <quicksilver> no sharing
08:57:57 <quicksilver> (unlikely, say, Map, IntMap, or Sequence, which support functional updates with sharing)
08:58:07 <mcnster> quicksilver, so immutable copies everything and non-immutable updates the data structure internally in-place?
08:58:08 <EvanR-work> its very likely!
08:58:26 <quicksilver> mcnster: well, the mutable array has a totally different interface
08:58:28 <quicksilver> (MArray)
08:58:36 <quicksilver> but the mutable array can do inplace updates, yes.
08:58:58 <quicksilver> also, even the your basic immutable Arrays don't actually copy "everything"
08:59:03 <quicksilver> just hte pointers
08:59:08 <quicksilver> (since everything is a pointer, in haskell)
08:59:26 <mcnster> quicksilver, i would like to use "amap", but it is defined in IArray.  do i need to make my array immutable?
08:59:31 <quicksilver> so what I said wasn't quite true - you can still have value-sharing.
08:59:36 <sipa> everything is either a pointer or optimized away :)
08:59:39 <benmachine> quicksilver: in GHC, surely :P
08:59:42 <quicksilver> mcnster: you need to use a class which implements IArray.
08:59:55 <monochrom> for example Array
08:59:57 <quicksilver> erm
08:59:58 <quicksilver> type
09:00:05 <quicksilver> as monochrom says, for example, Array.
09:01:46 <mcnster> quicksilver, this is where i'm confused.... when i try to use Data.Array.IArray i get errors saying "no instance for (IArray a Double)"...
09:02:08 <mcnster> yet, don't we know that 'a' is an Array?
09:02:15 <quicksilver> mcnster: the type you need to be using is Array
09:02:18 <EvanR-work> use Array
09:02:18 <quicksilver> not IArray.
09:02:21 <quicksilver> IArray is a class.
09:03:01 <quicksilver> if you use the polymorphic constructors in IArray you may need to pin the type down with a type signature somewhere.
09:03:32 <monochrom> > let a = array (2,4) [(2,"true"), (3,"maybe"), (4,"false")] in amap length a
09:03:33 <lambdabot>   Not in scope: `amap'
09:03:49 <mcnster> aha!
09:04:12 <quicksilver> > array (1,4) [(1,'a'),(2,'b'),(3,'c'),(4,'d')]
09:04:13 <lambdabot>   array (1,4) [(1,'a'),(2,'b'),(3,'c'),(4,'d')]
09:04:13 <monochrom> > let a = array (2,4) [(2,"true"), (3,"maybe"), (4,"false")] in fmap length a
09:04:14 <lambdabot>   array (2,4) [(2,4),(3,5),(4,5)]
09:04:25 <quicksilver> but the 'array' in scope in LB is the monomorphic one
09:04:27 <quicksilver> @type array
09:04:28 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
09:04:33 <cathper> ManateeLazyCat: Maybe give the option of different separation chars; I know some people using / to separate chars and // to separate words.
09:04:37 <quicksilver> I'm not sure if the polymorphic one is available qualified somewhere.
09:05:33 <ManateeLazyCat> cathper: Well, most "Morse converter" use ' ' separate chars and use '/' separate words.
09:05:50 <ManateeLazyCat> cathper: Yes, i will provide a option.
09:05:57 <ManateeLazyCat> cathper: Let user choose. :)
09:05:58 <monochrom> type classes are open. you never know that there is only one instance and it is always preferred.
09:06:07 <ManateeLazyCat> cathper: Thanks for suggestion
09:06:31 <benmachine> ManateeLazyCat: you could provide the option in the form of various splitting functions
09:06:44 <mcnster> quicksilver, thanks for the clues :) i'll fool around some more... 
09:06:51 <benmachine> ManateeLazyCat: so you'd have decodeMorse . splitAtSpace or decodeMorse . splitAtSlashes
09:07:02 <EvanR-work> ManateeLazyCat: visual recognition of morse code is a bad idea
09:07:03 <benmachine> rather than decodeMorseWith SpaceSplitting or whatever
09:07:16 <EvanR-work> or are you implementing audio recognition ?
09:07:28 <ManateeLazyCat> EvanR-work: So what's the better solution?
09:07:35 <EvanR-work> sound only
09:07:45 <ManateeLazyCat> EvanR-work: I have TTS in my irc client.
09:07:46 <EvanR-work> in the wild no ones writes down dots and dashes
09:08:07 <EvanR-work> just saying hams will hate you
09:08:28 <monochrom> hams
09:08:57 <monochrom> I wrote down a lot of dots and dashes yesterday.
09:09:19 <EvanR-work> better to write down the ascii chars instead
09:09:52 <benmachine> EvanR-work: so by visual recognition you mean recognition of a textual representation
09:09:57 <ManateeLazyCat> benmachine: I think i will write "toMorseCode :: String -> Maybe (Char, Char) -> String"
09:10:13 <EvanR-work> benmachine: or flashing lights
09:10:20 <EvanR-work> i guess that might be better since its time based
09:10:25 <monochrom> ascii chars can't do commuting diagrams or math. I wrote a lot of dashes because they were part of arrows in diagrams. I wrote a lot of dots because they were a math symbol.
09:10:28 <benmachine> ManateeLazyCat: if you say so, but I think it would be more haskelly to have those functions distinct
09:10:28 <EvanR-work> but they have their own flashing lights codes
09:10:46 <benmachine> monochrom: do you have a point? :P
09:10:56 <EvanR-work> no, hes point free
09:10:58 <benmachine> ha ha
09:11:07 <monochrom> it was pretty point free category theory math actually.
09:11:42 <monochrom> unless you count a dot to be a point and a dash to be infinitely man points
09:11:42 <ManateeLazyCat> benmachine: Thanks for your suggestion, i will consider it . :)
09:11:59 <benmachine> ManateeLazyCat: if you think I'm crazy you can ignore me, it's fine :P
09:12:22 <EvanR-work> ManateeLazyCat: a nice feature would be to convert text into audible code, with some speed configuration
09:12:30 <EvanR-work> both sent and received text
09:12:52 <EvanR-work> then you can use irc without being right next to the computer ;)
09:12:55 <ManateeLazyCat> EvanR-work: Yes, I have that. :)
09:13:02 <EvanR-work> smooth
09:13:05 <ManateeLazyCat> EvanR-work: In testing.
09:13:26 <ManateeLazyCat> EvanR-work: When you got "Morse code", convert automatically. :)
09:13:32 <benmachine> again you can make that compositional by converting text to text, and then using a generic audio interpreter '-' -> long beep '.' -> short beep
09:13:40 <monochrom> I had a math teacher in primary school who tried to convince us "a line segment is made of a lot of points". He used a very thick marker to jot some consecutive points, and said "see? it's a line!"
09:13:48 <EvanR-work> benmachine: and space to 'pause' or something
09:14:09 <monochrom> Fortunately he was just a trainee teacher and would disappear in two weeks.
09:14:12 <benmachine> heh
09:14:16 <EvanR-work> haha
09:14:19 <ddarius> monochrom: And he was correct, you just didn't realize that his points weren't mathematical points.
09:15:01 <pokoko222> matlab people here? i need litle help
09:15:07 <benmachine> monochrom: what is a line, then?
09:15:15 <ddarius> This isn't a matlab channel.
09:15:33 <benmachine> pokoko222: I recommend using haskell instead >_>
09:15:47 <roconnor> or at least octave :P
09:16:40 <monochrom> we could define a line to be lots of points, but not his thick points and not finitely many.
09:16:56 <ManateeLazyCat> EvanR-work: I have TTS in my irc client, not just morse code, it can read any IRC message. 
09:17:15 <Jonny2> Hi, with this code http://pastebin.com/BXGM7tHL   I receive:
09:17:28 <Jonny2> Instance of Fractional Int required for definition of modPow
09:17:37 <EvanR-work> ManateeLazyCat: in the funny macintosh voices?
09:17:41 <Jonny2> but I have to use Int -> Int -> Int -> Int
09:17:51 <benmachine> monochrom: well sure, but did you expect him to draw infinitely small points, or infinitely many of them?
09:17:52 <cathper> ManateeLazyCat: You're wellcome. I'll use the code occasionally anyway; and probably just hack it by hand to fit my needs :-)
09:17:55 <Jonny2> so I'm not sure how to fix it
09:18:03 <quicksilver> Jonny2: you can't use 0.5 with ints.
09:18:08 <EvanR-work> uncountable points on the board!
09:18:22 <quicksilver> Jonny2: what do you expect 0.5 * y to do, and still be integer?
09:18:23 <monochrom> I did realize his points weren't mathematical points. Too big. I was already convinced that a line was a lot of points before his show. But I also recognized that it needs infinitely many.
09:18:29 <quicksilver> y `div` 2 might be fine.
09:18:41 <quicksilver> (but I doubt it)
09:18:49 <benmachine> y `div` 2 would require an adjustment for when y is odd I think
09:18:52 <monochrom> I expect him to draw nothing. Wrong way to demonstrate.
09:18:56 <quicksilver> I think you need to distinguish between odd and even y.
09:18:58 <Jonny2> yeah if i add an odd adjustment
09:18:58 <ManateeLazyCat> cathper: Maybe (Char, Char) enough for you? First is chars separator and send is words separator. 
09:19:10 <Jonny2> will haskell realise i have distinguished odd and even y?
09:19:22 <ManateeLazyCat> EvanR-work: American female voice. :)
09:19:24 <quicksilver> you will still not use 0.5
09:19:29 <quicksilver> that is not an integer!
09:19:36 <quicksilver> instead you will use y `div` 2 when y is even
09:19:42 <quicksilver> and (y-1) `div` 2 when y is odd.
09:19:44 <quicksilver> or similar.
09:19:48 <Jonny2> ah I see
09:19:49 <EvanR-work> > odd 3
09:19:50 <Jonny2> thank you
09:19:50 <lambdabot>   True
09:20:10 <EvanR-work> > normal 3
09:20:11 <lambdabot>   Not in scope: `normal'
09:20:21 <EvanR-work> False
09:20:34 <monochrom> The best approach for primary school purpose is: it doesn't matter actually.
09:20:55 <EvanR-work> either kids have an interest or they dont
09:21:17 <benmachine> EvanR-work: that's rather pessimistic of you
09:21:26 <EvanR-work> no its one of those laws of logic
09:21:27 <cathper> ManateeLazyCat: Yep.
09:21:37 <ddarius> EvanR-work: We reject excluded middle here.
09:21:41 <benmachine> heh
09:21:42 <EvanR-work> lol
09:21:45 <benmachine> constructivist kids
09:21:58 <ManateeLazyCat> cathper: Ok, i will notice you when finish, i'm integrate morse code in my irc client. :)
09:22:36 <monochrom> even if you accepted "line is many points", there was no use anyway. the only thing you would want to do to lines at that stage was: intersect two lines, get a point. everyone accepted that fine. no need to try to be set-theoretic and point-set topology.
09:22:48 <cathper> ManateeLazyCat: Sweet :-)
09:23:04 <ddarius> There are those who would like to keep the synthetic and analytic concept of a line somewhat distinct.
09:23:34 <benmachine> monochrom: I'd agree with that, more or less
09:24:01 <benmachine> monochrom: you coudl argue that "points in both lines" is a concept that makes more sense if you think that lines are points, but I'd be surprised if people actually thought that way naturally
09:24:23 <monochrom> yeah, it's just primary school. in university I would agree to go deeper. but in university you wouldn't accept a demo by a thick marker anyway.
09:24:54 * hackagebot persistent 0.2.3 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.2.3 (MichaelSnoyman)
09:24:56 * hackagebot web-routes-quasi 0.6.1 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.6.1 (MichaelSnoyman)
09:24:58 * hackagebot yesod 0.5.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.5.3 (MichaelSnoyman)
09:26:00 * hackagebot yesod-auth 0.1.3 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.1.3 (MichaelSnoyman)
09:26:20 <Jonny2> sorry quicksilver, I'm having trouble doing the odd case - obviously I need to do x * x ^ (y-1 div 2) .... but how do I put the x * in my recursive function without it affecting the even cases?
09:27:09 <EvanR-work> if even x then id else (x*)
09:27:25 <benmachine> Jonny2: like you just wrote it? what's the problem?
09:28:51 <Jonny2> so would I write it as...      x * modPow x ( y-1 `div` 2 ) n
09:29:31 <benmachine> Jonny2: not sure why you're bothering to subtract one from y, but I'd think something like that yes
09:29:43 <Jonny2> I have to because thats the odd case
09:29:46 <benmachine> oh
09:30:04 <benmachine> then why are you dividing by 2
09:30:21 <Jonny2> because Im solving it recursively by splitting the problem in half
09:30:27 <sipa> can y be even?
09:30:29 <Jonny2> x^4 = x^2 * x^2
09:30:30 <benmachine> but you've only given one half there
09:30:40 <Jonny2> oh right yeah i also have an even case
09:30:48 <benmachine> uh no I mean you're doing
09:30:50 <Jonny2> where i dont subtract 1 or multiply modPow by x
09:30:55 <benmachine> x^(2n + 1) = x * x^n
09:31:01 <benmachine> that is what that clause says
09:31:03 <benmachine> that is not true
09:31:19 <Jonny2> sorry the whole line of code will say...:
09:32:06 <Jonny2> odd case: ( x * modPow x ( y-1 `div` 2 ) n ) * ( x * modPow x ( y-1 `div` 2 ) n ) `mod` n
09:32:14 <Jonny2> even y = ( modPow x ( y `div` 2 ) n ) * ( modPow x ( y `div` 2 ) n ) `mod` n
09:32:38 <benmachine> your haskell is fine your maths is still wrong
09:33:18 <benmachine> now it says, x^(2n + 1) = (x * x^n) * (x * x^n)
09:33:33 <quicksilver> You're more likely to mean (y-1) `div` 2 than y-1 `div` 2
09:33:42 <benmachine> oh, that too
09:33:45 <quicksilver> > 9-1 `div` 2
09:33:45 <lambdabot>   9
09:33:50 <quicksilver> > (9-1) `div` 2
09:33:51 <lambdabot>   4
09:34:10 <quicksilver> although `div` odesn't look like a * or a /, it "binds tightly" like they do.
09:34:50 <EvanR-work> is there such a thing as a MonadReader MonadWriter MonadState MonadCont MonadRandom etc deriving?
09:35:29 <EvanR-work> if you want your monad to do default stuff
09:35:31 <ddarius> EvanR-work: There's newtype deriving as an extension.
09:35:40 <ddarius> There is no "default" stuff for those monads.
09:36:17 <maurer_> Out of curiosity, could you explain how you'd expect deriving for these things to work?
09:36:31 <EvanR-work> i dont know, i dont fully understand the situation 
09:36:59 <EvanR-work> but we use lift and liftIO in cases where the inner monad isnt 'compatible' implements the outter interface?
09:37:08 <EvanR-work> doesnt implemtn*
09:37:15 <Jonny2> I'm sorry for being so slow today... at the moment my code looks like http://pastebin.com/sNTfH9N6
09:37:30 <Jonny2> and I'm trying to create the functin modPow which calculates x^y mod n recursively
09:37:46 <Jonny2> using the fact that xy mod n = (x mod n )(y mod n) mod n
09:38:34 <EvanR-work> or is it the other way around
09:39:11 <bblum> "foldl/foldM and reverse the output" seems to be a pretty common pattern in what i'm writing.. is this expected, or does it indicate i'm going about something wrong?
09:39:21 <benmachine> Jonny2: your haskell is fine, although using 'otherwise' instead of 'odd y' would be more sensible
09:39:28 <benmachine> Jonny2: but your maths is wrong, like I said
09:40:05 <EvanR-work> > otherwise
09:40:06 <lambdabot>   True
09:40:18 <Jonny2> can you see where I've gone wrong, because I can't see how splitting the problem up using the fact that x^n = x^n/2 * x^n/2    is wrong?
09:40:46 <benmachine> Jonny2: your even case is correct, explain your odd case to me
09:41:23 <Jonny2> well if y is odd we want to use the fact that, say, x^3 = x* x^2
09:41:28 <benmachine> Jonny2: (although, your even case would be easier to read if you used let or where - e.g. let r = modPow x (div y 2) n in r * r `mod` n
09:41:30 <Jonny2> and solve x^2 as if it were the even case
09:41:32 <benmachine> )
09:41:40 <benmachine> Jonny2: right
09:42:29 <monochrom> x^((y-1)/2) * x^((y-1)/2) = x^(y-1) /= x^y
09:43:04 <Jonny2> but thats why i multiply it by x monochrom
09:43:08 <Jonny2> to get it back to x^y
09:43:17 <monochrom> I see.
09:43:24 <benmachine> Jonny2: you multiply it by x twice though
09:43:38 <monochrom> (x*x^((y-1)/2)) * (x*x^((y-1)/2)) = x*x*x^(y-1) /= x^y
09:43:47 <benmachine> yes
09:44:25 <benmachine> > 9 `div 2
09:44:26 <lambdabot>   <no location info>: parse error on input `2'
09:44:28 <benmachine> > 9 `div` 2
09:44:29 <lambdabot>   4
09:44:59 <monochrom> I personally don't mind (y-1)`div`2
09:45:16 <Jonny2> where am I multiplying it by x twice though?
09:45:25 <monochrom> in your code
09:45:33 <Jonny2> "( x * modPow x ( ( y - 1 ) `div` 2 ) n )"
09:45:36 <Jonny2> theres only 1 x* there
09:45:51 <SebastianPhantom> i was wondering whether someone can help me with a lil java programmin
09:46:06 <monochrom> * ( x * modPow x ( ( y - 1 ) `div` 2 ) n )
09:46:36 <Jonny2> yeah but I need to put that also because I'm using the fact that xy mod n = (x mod n) (y mod n) mod n
09:46:46 <Jonny2> I can't leave out that (y mod n)
09:47:18 <monochrom> > "( x * modPow x ( ( y - 1 ) `div` 2 ) n ) * ( x * modPow x ( ( y - 1 ) `div` 2 ) n )" == "( x * modPow x ( ( y - 1 ) `div` 2 ) n ) * ( modPow x ( ( y - 1 ) `div` 2 ) n )"
09:47:19 <lambdabot>   False
09:49:04 <Jonny2> ohhh I see!
09:49:30 <Jonny2> I'm saying x^5 = x * x^2 * x * x^2
09:49:32 <monochrom> a string comparison is worth a thousand explanations
09:49:45 <Jonny2> when really its just x^5 = x * x^2 * x^2
09:51:18 <Jonny2> thanks very much for the help!!
10:12:47 <wakeupsticky> hi all :)
10:12:54 <wakeupsticky> how do i get java running on ubuntu maverick?
10:13:04 <wakeupsticky> whoops, wrong channel!
10:13:11 <EvanR-work> soooo the wrong channel
10:13:15 <alexbobP> hahaha
10:13:28 <alexbobP> I always join #haskell when I need java and ubuntu help...
10:13:30 <byorgey> cabal install java
10:14:50 <EvanR-work> MonadJava m => XYZFactoryPattern.get -> Int -> m Int
10:31:44 <bremner> Jaskell: finally, a java as lazy as its programmers.
10:33:00 <djahandarie> Heh
10:33:27 <aristid> bremner: java programmers are not lazy, or they would not endure that language
10:33:45 <djahandarie> Too lazy to learn another language
10:34:16 <aristid> that's the other kind of lazy
10:34:17 <bremner> aristid:  two words. intelli sense
10:34:34 <aristid> bremner: well that doesn't automate away all of the pain
10:35:16 <aristid> btw., how would you generalise orElse :: Monad m => m (Maybe a) -> m (Maybe a) -> m (Maybe a); orElse a b = a >>= \x -> if (isNothing x) then b else return x
10:35:38 <aristid> i like the function but i dislike that it works only on Maybe :D
10:39:38 <zygoloid> @type liftA2 mplus -- aristid
10:39:39 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (MonadPlus m, Applicative f) => f (m a) -> f (m a) -> f (m a)
10:40:56 <zygoloid> liftA2 mappend would work too, but then you'd need to wrap and unwrap with First ;(
10:41:49 <aristid> zygoloid: no, liftA2 mplus always evaluates both actions
10:42:01 <aristid> zygoloid: i only want to perform the second action conditionally
10:43:16 <zygoloid> aristid: ah, i see. i have another idea, one moment...
10:43:38 <jmcarthur> ok, so there's this removal of let generalization in GHC 7, described here: http://hackage.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7 ... i'm running into that "skolem type variable would escape" error when trying to build vector-space in GHC 7, but this time the skolem is bound by an instance declaration and i'm not sure how to resolve the problem
10:44:16 <jmcarthur> paste coming up
10:45:00 <jmcarthur> http://hpaste.org/40546/skolem_bound_in_instance_decla
10:45:17 <jmcarthur> bah, i'll add the error message to be clear
10:45:37 <jmcarthur> http://hpaste.org/paste/40546/error_message#p40547
10:45:46 <jmcarthur> does anybody know what i can do about this?
10:46:06 <jmcarthur> conal: relevant for you since its your package, although you may not know the answer either ^^
10:46:29 * conal looks
10:47:19 <conal> jmcarthur: what's the context here?  a new ghc version
10:47:21 <conal> ?
10:47:32 <jmcarthur> yeah, ghc 7
10:48:12 <conal> ah.  interesting.  i'm glad you spotted this problem early.
10:48:27 <Saizan> jmcarthur: try with "instance forall u s v. ( InnerSpace u, ..."
10:48:31 <conal> and it's a nice, simple example.
10:48:37 <jmcarthur> i've tried scoped type variables and all, but it didn't change anything
10:48:39 <jmcarthur> Saizan: ^^
10:48:48 <aristid> -XGADTs implies -XTypeFamilies? oO
10:49:01 <Saizan> jmcarthur: makes sense
10:49:30 <jmcarthur> Saizan: that is, i tried your suggestion already
10:49:50 <conal> wow.  pretty new hpaste!
10:49:54 <Saizan> jmcarthur: but does it compile with NoMonoLocalBinds ?
10:50:17 <jmcarthur> Saizan: no, same error
10:50:36 <jmcarthur> Saizan: there is not let or where involved, so i don't really know what to do :\
10:50:46 <zygoloid> @type \a b -> do v <- a; if null (Data.Foldable.toList v) then b else return v
10:50:47 <lambdabot> forall (m :: * -> *) (t :: * -> *) a. (Monad m, Data.Foldable.Foldable t) => m (t a) -> m (t a) -> m (t a)
10:50:49 <Saizan> ah, ok, so it's not really about lack of generalization
10:50:51 <zygoloid> aristid: ^^ how about that?
10:51:01 <Saizan> it's more that the implementation of type families changed
10:51:01 <jmcarthur> yeah, it's just the same error message in a different context
10:51:20 <aristid> zygoloid: interesting
10:51:32 <aristid> zygoloid: is Either foldable?
10:51:38 <Saizan> jmcarthur: can i just try with the vector-space from hackage to reproduce this?
10:51:43 <zygoloid> aristid: yep, should be.
10:51:49 <zygoloid> @instances-importing Data.Foldable Foldable
10:51:51 <lambdabot> Maybe, []
10:51:53 <benmachine> it doesn't seem to have an instance by default
10:51:53 <jmcarthur> Saizan: yes
10:51:54 <zygoloid> ;(
10:52:19 <aristid> zygoloid: :/ it just makes a lot of sense to extend orElse to Either
10:53:07 <zygoloid> aristid: well, instance Foldable (Either a) where foldr _ v (Left _) = v; foldr f v (Right w) = f w v
10:53:23 <aristid> zygoloid: i was thinking about orElse :: Monad m, MonadPlus f, Eq (f a) => m (f a) -> m (f a) -> m (f a)
10:53:49 <zygoloid> aristid: using (== mzero)?
10:53:52 <aristid> yeah
10:54:02 <aristid> mmh but that sucks because it often requires Eq a implicitly
10:54:09 <zygoloid> requiring Eq on 'a' (which you're not even going to use) is a p... yeah, that
10:54:42 <zygoloid> but you don't need that, just Eq (f ())
10:54:57 <aristid> right.
10:55:30 <zygoloid> Eq (f Void) would be fine, even
10:56:54 <twopoint718> newbie question - How can I determine my own IP address?  The computer in question has a public-facing address.
10:57:16 <zygoloid> class Eq1 f where (==~) :: f a -> f a -> Bool; a == b = fmap undefined a == (fmap undefined b :: f Void)
10:57:29 <Saizan> jmcarthur: it installed fine here..
10:57:34 <jmcarthur> o_O
10:57:36 <zygoloid> twopoint718: from haskell?
10:57:38 <aristid> zygoloid: where is the MonadPlus instance for Either again?
10:57:43 <jmcarthur> Saizan: which GHC?
10:57:48 <Saizan> jmcarthur: ghc-7.0.0.20100924
10:57:56 <twopoint718> zygoloid: yes
10:58:08 <zygoloid> aristid: Control.Monad.Error probablt
10:58:18 <twopoint718> zygoloid: (I guess I didn't mention that...)
10:58:24 <Saizan> jmcarthur: which is the first rc, i think
10:58:26 <zygoloid> (and it requires Error for the Left value)
10:58:32 <aristid> argh stupid mtl vs monads-fd conflict
10:58:41 <jmcarthur> ah, i'm on HEAD
10:58:44 <jmcarthur> well, 7.1.20101008
10:58:47 <zygoloid> twopoint718: we get a lot of people in here asking not-haskell-related questions ;)
10:59:17 <jmcarthur> so i guess maybe i should just go to 7rc
10:59:34 * hackagebot MorseCode 0.0.3 - Morse code  http://hackage.haskell.org/package/MorseCode-0.0.3 (AndyStewart)
10:59:58 <zygoloid> twopoint718: if there's a portable way to do it, it'll probably be in the network package on hackage
11:00:07 <Saizan> jmcarthur: may still be worth to report as a bug
11:00:09 <aristid> zygoloid: yeah Control.Monad.Either works
11:00:22 <aristid> :t let orElse a b = a >>= \x -> if (() <$ x) == mzero then b else return x in orElse
11:00:23 <lambdabot> forall (m :: * -> *) (f :: * -> *) b. (Monad m, Eq (f ()), MonadPlus f, Functor f) => m (f b) -> m (f b) -> m (f b)
11:00:24 <jmcarthur> yeah. i'm gonna do a quick pull and read the changes first, then report
11:00:25 <zygoloid> twopoint718: if you don't care about portability, it should probably be straightforward to get something working via FFI
11:00:38 <aristid> zygoloid: but that is a bit of a mess overall :D
11:00:43 <ManateeLazyCat> twopoint718: "ifconfig" (Windows) or "ifconfig" (Unix) ?
11:00:53 <ManateeLazyCat> twopoint718: "ipconfig" (Windows)
11:00:59 <jmcarthur> ooh, -fglasgow-exts finally got a deprecated in a recent patch
11:01:17 <aristid> :t let orElse a b = a >>= \x -> if (const () `liftM` x) == mzero then b else return x in orElse
11:01:18 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a1. (Monad m, Eq (m1 ()), MonadPlus m1) => m (m1 a1) -> m (m1 a1) -> m (m1 a1)
11:01:27 <twopoint718> ManateeLazyCat: ipconfig on Windows, IIRC
11:01:38 <ManateeLazyCat> twopoint718: yes, typo. :)
11:01:45 <aristid> jmcarthur: is there a replacement?
11:01:47 <zygoloid> aristid: well, the MonadPlus and the Foldable generalizations are both interesting, but neither is 'right'.
11:01:55 <aristid> zygoloid: yes
11:01:57 <jmcarthur> aristid: it was just a swiss army knife of other extensions
11:02:14 <aristid> jmcarthur: so you are supposed to enumerate the extensions now?
11:02:18 <jmcarthur> yes
11:02:29 <jmcarthur> supposed to anyway, IMO
11:02:37 <aristid> jmcarthur: i was hoping there would be a "superset extension" containing many other extensions
11:02:49 <zygoloid> aristid: you want something like: class Monoid m => InspectableMonoid m where isMempty :: m -> Bool, i think
11:03:07 <aristid> zygoloid: except maybe is no Monoid for evil reasons :)
11:03:22 <jmcarthur> aristid: extensions don't always play nicely with each other
11:03:23 <zygoloid> aristid: Maybe is a Monoid. just not the /right/ Monoid for your purposes
11:03:29 <zygoloid> aristid: but see First
11:03:40 <twopoint718> zygoloid: Okay, I was just wondering if there was a simple thing that I was missing in the Network package, I'll keep looking, but calling out to "ifconfig" is probably easier.
11:03:41 <aristid> zygoloid: yes, i mean i could also use MaybeT ;)
11:04:01 <jmcarthur> aristid: upcoming versions of the haskell spec should continue to integrate mature extensions anyway
11:04:15 <twopoint718> thanks ManateeLazyCat and zygoloid 
11:04:34 <jmcarthur> so by definition any other extension is "experimental" and a candidate for conflicting with other extensions anyway, so having a huge metaextension is probably a bad idea
11:04:44 <aristid> zygoloid: i think Monoid and MonadPlus are not supposed to be checked for emptiness. i mean, mappend appends list, it does not short-circuit
11:05:28 <aristid> jmcarthur: there's a big list of extensions that people use in combination with each other pretty safely
11:05:46 <jmcarthur> aristid: yes, and those are likely to be included in future versions of the haskell spec
11:05:51 <jmcarthur> meaning enabled by default, eventually
11:06:14 <aristid> jmcarthur: does ghc 7 have a flag for haskell 2010? does that enable some extensions?
11:06:23 <zygoloid> twopoint718: getSocketName looks like it might do the right thing
11:06:36 <jmcarthur> aristid: surely it does...
11:07:46 <twopoint718> zygoloid: cool, thanks I'll go check that out.
11:07:54 <Igloo> aristid: Yes, but the H2010 extensions are on by default anyway
11:08:03 <aristid> Igloo: even in ghc 6.12?
11:08:17 <Igloo> No, in ghc 7
11:08:24 <monochrom> ghc -XHaskell98 -XHaskell2010 -XMirandaMode
11:08:25 <aristid> oh, cool
11:08:36 <jmcarthur> MirandaMode?
11:08:43 <aristid> definitely looking forward to ghc 7
11:09:09 <dcoutts> aristid: but then Cabal undoes all your fun and defaults back to Haskell98 :-)
11:09:11 <monochrom> turns on compatibility with Miranda
11:09:34 <aristid> dcoutts: woot?
11:09:48 <monochrom> Cabal: we take the fun away from functional programming?
11:09:54 <dcoutts> :-)
11:09:58 <Igloo> dcoutts: Cabal also ought to handle the H98 and H2010 extensions for GHC < 7, incidentally
11:10:04 <aristid> dcoutts: will cabal have an option to say "my package gets the haskell 2010"? :D
11:10:17 <benmachine> dcoutts: presumably you'd use extensions: Haskell2010; it seems weird that it'd be thought of as an extension, now
11:10:22 <jmcarthur> yay, no more :*: in dph as of today
11:10:26 <dcoutts> aristid: not quite sure yet, but you can certainly set in in individual modules
11:10:51 <dcoutts> benmachine: right, it's whether or not it's listed as an extension that's not entirely decided
11:11:00 <dcoutts> Igloo: what do you mean exactly?
11:11:07 <monochrom> perhaps "extension" is better off called "dialect" so people stop debating philosophy.
11:11:29 <Igloo> dcoutts: If I say "extensions: Haskell98" (or 2010) is ought to turn that into the appropriate -X flags
11:11:47 <dcoutts> Igloo: or a new language field
11:12:03 <jmcarthur> "language: C++"? :P
11:12:16 <dcoutts> Igloo: JaffaCake and I think a nice enough final design is to have: languages, default-language, extensions, default-extensions
11:12:17 <Igloo> dcoutts: Well, wherever it goes. My point is just that it isn't in the --supported-languages otuput of older GHCs
11:12:56 <dcoutts> Igloo: right, well it's not listed as an extension yet either
11:13:51 <monochrom> what divides "language" and "extension"?
11:14:06 <monochrom> can't you just call all of them "dialect"?
11:14:09 <dcoutts> monochrom: Haskell98 and Haskell2010 (and Agda) are languages
11:14:21 <dcoutts> monochrom: fine, they're dialects of Haskell, versions, whatever
11:14:40 <dcoutts> they are a base language upon which you may be able to add extensions
11:14:43 <aristid> Agda is a dialect of Haskell? oO
11:14:59 <zygoloid> C++ is a dialect of BCPL?
11:15:01 <dcoutts> aristid: no, but it's FFI compatible
11:15:03 <monochrom> too much hair-splitting
11:15:23 <aristid> dcoutts: i.e. you can use haskell modules from agda?
11:15:26 <dcoutts> the compatibility of mixing languages in a single package is implementation dependent obviusly
11:15:53 <dcoutts> aristid: well Agda compiles into (weird) Haskell (ghc only) code
11:16:27 <dcoutts> monochrom: is there a clearer set of labels ?
11:16:49 <monochrom> Yes. Just call all of them "dialect"
11:16:50 <dcoutts> monochrom: the division is because we want to say what extensions are relative to
11:16:57 <dcoutts> monochrom: all of what?
11:17:21 <monochrom> dialects: haskell98 GADTs ForeignFunctionInteface
11:17:22 <benmachine> you could do what the pragma does and make all of them language
11:17:26 <sioraiocht> oh god, we're going to get into THE linguistic fight
11:17:46 <dcoutts> benmachine: yeah, we think that's wrong too :-)
11:17:46 * hackagebot MorseCode 0.0.4 - Morse code  http://hackage.haskell.org/package/MorseCode-0.0.4 (AndyStewart)
11:18:02 <benmachine> is there even a Haskell98 flag? wouldn't that just be NoHaskell2010?
11:18:27 <dcoutts> monochrom: what if you leave haskell98 out, or have haskell98 and haskell2010?
11:20:19 <monochrom> If I leave haskell98 out, a nondeterministic choice is made. If I have both, it is a conflict, a nondeterministic error occurs.
11:20:47 <tg_> I thought that said Moose code
11:20:52 <dcoutts> that seems to suggest that the base language is still special, different from the other extensions
11:21:09 <tg_> i've long wanted to talk to meese, so i got excited.
11:21:58 <monochrom> the base language is special but implicit. a nondeterministic choice made by the coincidental version of the coincidental compiler used.
11:22:33 <theorbtwo>  /connect irc.perl.org ; /join #moose
11:23:01 <dcoutts> monochrom: for a .cabal package description we want something deterministic I think
11:23:35 <manateeUser> -... -.-- . /.- .-.. .-.. --..-- /--. --- --- -.. /-. .. --. .... - /---... -.--.- 
11:24:09 <tg_> theorbtwo: if only that had existed when I first started using perl!
11:24:19 <monochrom> if a .cabal file underspecifies, there is nothing wrong with nondeterminism. lots of .cabal files underspecify dependencies, network==*
11:26:04 <monochrom> if base language is special just on account that two such flags may conflict each other, well I haven't seen proof that all subsets of non-base-language extensions in the future won't have conflicts.
11:26:44 <dcoutts> monochrom: that's certainly true, it's implementation-dependent if extensions can be mixed
11:26:52 <dcoutts> and which combos can be mixed
11:27:19 <zygoloid> if the .cabal file says language ForeignFunctionInterface and a source file says {-# LANGUAGE Haskell2010 #-} then i'd expect to /not/ have FFI work in that file
11:27:31 <zygoloid> s/2010/98/ oops
11:28:29 <dcoutts> zygoloid: I think that's not the semantics we've picked. Specifying the language does not mean "no more than this" it means "starting with this".
11:28:42 <kosmikus> gds: still there?
11:28:49 <benmachine> hmm, I wonder what happens if you do ghc -XForeignFunctionInterface and the pragma says NoForeignFunctionInterface
11:28:52 <dcoutts> Igloo: right? ^^
11:29:12 <zygoloid> dcoutts: i agree with that. but i'd expect HaskellX to overwrite other language settings, for the others to be incremental, and for the result to be order-dependent
11:29:13 <dcoutts> benmachine: the file pragma takes precedence
11:29:14 <Igloo> right
11:29:27 <zygoloid> (left-to-right in .cabal, then left-to-right in .hs, then left-to-right on command-line, i guess)
11:29:30 <gds> kosmikus: Yup
11:29:53 <zygoloid> or cmd-line before .hs?
11:29:59 <dcoutts> zygoloid: so you'd expect specifying a language to reset all previously listed extensions?
11:30:04 <zygoloid> dcoutts: yes, exactly.
11:32:08 <kosmikus> gds: you had a problem with lhs2tex earlier?
11:32:41 <gds> kosmikus: I was trying to get haskell to ignore some code, using the trick on the wiki.
11:32:43 <zygoloid> it's ok, you can just add an extension to specify how extensions are resolved ;)
11:33:03 <gds> \begin{code}% not real code
11:33:05 <kosmikus> gds: what "trick" on what wiki?
11:33:21 <monochrom> allow full boolean algebra in dialects:
11:33:29 <gds> That did successfully hide the code from ghc...
11:33:43 <gds> But it also printed "% not real code" in my document.
11:34:01 <gds> Which I can live with, but I was wondering if there was a way to avoid that :)
11:34:22 * gds gets the URL...
11:34:43 <monochrom> dialects: (haskell98 ‚áí FFI) ‚àß ¬¨(haskell2010 ‚àß ¬¨GADTs)
11:34:49 <gds> kosmikus: http://www.haskell.org/haskellwiki/Literate_programming#Hiding_code_from_Haskell
11:34:54 <gds> that trick :)
11:35:34 <monochrom> this says: if you choose haskell98, I want to add FFI; if you choose haskel2010, I want to add GADTs.
11:35:52 <caelan> i'm not familiar with tex, but i think a space before the % might help
11:36:02 <monochrom> (if you choose haskell2038, I don't have particular requirements)
11:36:20 <gds> To make matters slightly tangentally more complicated, I'm using birdtracks rather than \begin{code} blocks for all my real code. It's possible I shouldn't be doing that - the only reason I am is because the emacs syntax highlighting out of the box in ubuntu works better that way.
11:36:51 <kosmikus> gds: ok, ignore all the stuff on the Wiki for lhs2tex :)
11:36:56 <gds> Ok :)
11:37:00 <blackcustard> hmm, any way to make this happen? http://hpaste.org/40548/pattern_matching_fu ... it would greatly simplify a case statement i've got
11:37:03 <kosmikus> gds: use < rather than >
11:37:31 <gds> kosmikus: ooooh....
11:37:34 * gds tries...
11:37:48 <kosmikus> gds: or \begin{spec} \end{spec} rather than \begin{code} \end{code}
11:37:52 * hackagebot hjson-query 0.4 - library for querying from JSON  http://hackage.haskell.org/package/hjson-query-0.4 (YuriyIskra)
11:37:54 <gds> Very Cool.
11:37:56 <gds> Thanks :)
11:38:24 <monochrom> Implementation is trivial. Use a SAT solver.
11:38:30 <manateeUser> monochrom: Haskell2038 ? ;p
11:38:34 <Saizan> blackcustard: at best you can do:  case x of "a" -> "a"; x | x `elem` ["b","c"] -> "b"; "d" -> "d"
11:38:42 <kosmikus> gds: you're welcome
11:38:47 <monochrom> my hypothetical futuristic haskell version
11:39:12 <blackcustard> Saizan: that's perfect actually, thank you!
11:39:14 <Saizan> it's 20:38 here right now
11:39:27 <monochrom> haskell 20:38
11:39:36 <Saizan> blackcustard: cheers :)
11:40:18 <monochrom> that looks like a biblical reference, doesn't it?
11:40:31 <Watermind> hi
11:40:33 <monochrom> "Avoid success at all costs." --- Haskell 20:38
11:40:48 <caelan> monochrom: i want this Holy Book.
11:40:51 <kosmikus> gds: perhaps you could add this to the Wiki, because it seems to be misleading
11:41:08 <gds> kosmikus: Sure - do I need to set up an account, or can I just edit?
11:41:18 <chrisdone> anybody got a nice function :: Show a => a -> String which takes the default Haskell show instance and renders it line by line with some indentation and such?
11:41:20 <Watermind> I was trying accumulators and strictness using seq to check for efficiency benifits... but to my surprise it just makes things worst
11:41:31 <aristid> monochrom: ml is MUCH better at avoiding success
11:41:31 <Watermind> accumulator results in more memory used
11:41:32 <monochrom> I can write the whole book for you now. cycle "Avoid success at all costs. "
11:41:37 <Watermind> and strictness has no impact
11:41:39 <ddarius> chrisdone: I think someone did write something like that.
11:41:40 <chrisdone> I seem to recall there is a quick way to do this 
11:41:46 <Watermind> the difference is even bigger if -O2 is used
11:41:46 <gds> looks like I need an account...
11:41:53 <kosmikus> gds: yes you do
11:41:54 <Watermind> http://haskell.pastebin.com/LPq3Bq0P
11:41:54 <caelan> chrisdone: you mean like a pretty-printer?
11:41:56 <pr> > cycle "Avoid success at all costs."
11:41:57 <lambdabot>   "Avoid success at all costs.Avoid success at all costs.Avoid success at all...
11:42:03 <Watermind> I used that simple sum function
11:42:26 <chrisdone> caelan: sure
11:42:37 * gds signs up.
11:42:38 <Watermind> can anyone explain to me why the accumulator makes it worse and  seq shows no improvements either?
11:42:45 <caelan> no idea, then
11:43:33 <caelan> chrisdone: looks like there are some pprinters on hackage
11:43:37 <chrisdone> ddarius: ahh, the pretty-show library looks promising
11:43:57 <caelan> chrisdone: http://hackage.haskell.org/packages/archive/haskell-src/1.0.1.3/doc/html/Language-Haskell-Pretty.html
11:44:20 <Watermind> anyone? :S
11:44:36 <monochrom> > text "hello" $$ indent 5 (text "hi" <+> integer 4)
11:44:37 <lambdabot>   Not in scope: `indent'Ambiguous occurrence `<+>'
11:44:37 <lambdabot>  It could refer to either ...
11:44:43 <monochrom> > text "hello" $$ indent 5 (text "hi" <> integer 4)
11:44:44 <lambdabot>   Not in scope: `indent'Ambiguous occurrence `$$'
11:44:44 <lambdabot>  It could refer to either `...
11:44:45 <chrisdone> caelan: I'm not printing a Haskell AST
11:44:49 <benmachine> Watermind: try more than 5000
11:45:00 <Watermind> benmachine: ok
11:45:01 <benmachine> Watermind: say, 500000
11:45:05 <Watermind> sure
11:45:18 <benmachine> actually I'm not sure how long that would take
11:45:21 <benmachine> but experiment!
11:45:24 <monochrom> > vcat [text "hello", indent 5 (hsep [text "hi", integer 4])]
11:45:25 <lambdabot>   Not in scope: `indent'
11:45:31 <c_wraith> should be fast. 500k isn't that many :)
11:45:52 <caelan> chrisdone: oh well, worth a try :)
11:45:55 <monochrom> > vcat [text "hello", nest 5 (hsep [text "hi", integer 4])]
11:45:56 <lambdabot>   hello
11:45:56 <lambdabot>       hi 4
11:46:07 <Watermind> benmachine: same
11:46:13 <monochrom> that is from Text.PrettyPrint.HughesPF
11:46:15 <monochrom> err
11:46:17 <monochrom> that is from Text.PrettyPrint.HughesPJ
11:46:31 <Watermind> benmachine: makes no difference... no ac is always a bit better... a lot better if O2 is used
11:46:33 <c_wraith> Watermind, also note that on those simple examples, GHC is fully capable of noting that the types are strict, and making everything strict
11:46:47 <dolio> Use Text.PrettyPrint.Leijen. Be a rebel like me.
11:47:08 <chrisdone> hmm, not bad
11:47:11 <monochrom> > text "hello" $$ indent 5 (text "hi" <> integer 4)
11:47:12 <lambdabot>   Not in scope: `indent'
11:47:17 <monochrom> > text "hello" $$ nest 5 (text "hi" <> integer 4)
11:47:18 <lambdabot>   hello
11:47:19 <lambdabot>       hi4
11:47:29 <Watermind> c_wraith: what I find surprising is that even without optimization it is better
11:47:36 <monochrom> oh, better example of indentation:
11:47:41 <monochrom> > text "hello" $$ nest 5 (text "hi" $$ integer 4)
11:47:42 <lambdabot>   hello
11:47:43 <lambdabot>       hi
11:47:43 <lambdabot>       4
11:47:50 <Watermind> c_wraith: and with optimization it is a lot better as in half memory allocation
11:48:07 <chrisdone> caelan, ddarius, dolio: http://hpaste.org/40549/textshowpretty :-)
11:48:09 <Watermind> c_wraith: so I can understand that it is better not to pass around an extra variable
11:48:14 <Watermind> but still
11:48:18 <Watermind> it is a huge difference
11:48:43 * ddarius suggests that Watermind's benchmarking methodology may be flawed.
11:48:43 <c_wraith> Watermind, look at the core being generated.  That's all I can suggest.
11:48:58 <Watermind> c_wraith: good idea
11:49:07 <Watermind> ddarius: could you elaborate?
11:49:08 <c_wraith> well, ddarius has a point, too.  profiling != benchmarking
11:49:18 <chrisdone> this library is quite nice, because it parses the Show into a data structure, so I could implement my own pretty printer, it also provides a Doc value
11:49:20 <c_wraith> profiling can add non-representative slowdowns
11:49:28 <Watermind> I see
11:49:32 <c_wraith> Try benchmarking with criterion
11:49:39 <caelan> chrisdone: huh, the format reminds me of gnu c coding style
11:49:42 <Watermind> what is that? 
11:49:42 <c_wraith> It's a nice and easy library to use
11:49:47 <gds> kosmikus: Done.
11:49:49 <Watermind> ok
11:50:04 <chrisdone> caelan: well it's just the same syntax but with newlines
11:50:19 <chrisdone> </redundant-comment>
11:50:59 <c_wraith> @hackage criterion
11:50:59 <lambdabot> http://hackage.haskell.org/package/criterion
11:51:28 <Watermind> nice thanks c_wraith
11:51:40 <chrisdone> kind of annoying that newtype derived Show and Read are different than GeneralisedNewtypeDeriving
11:52:26 <chrisdone> makes sense from a serializability stand-point, though
11:52:28 <dolio> If they weren't, they wouldn't conform to Show and Read's informal constraints.
11:53:12 <zygoloid> chrisdone: GeneralizedNewtypeDeriving is the weird one, i think...
11:53:24 <chrisdone> zygoloid: why so?
11:53:29 <zygoloid> it's like 'instance Newtype a => Derivable a'
11:53:38 <zygoloid> it overlaps all other possible deriving features
11:54:18 <kosmikus> gds: great. thanks.
11:54:50 <gds> kosmikus: no problem:)
11:55:46 <zygoloid> chrisdone: for instance, Generics + GeneralizedNewtypeDeriving lets you override the newtype deriving for classes you define
11:55:57 <zygoloid> (or at least i /hope/ Generics wins that battle...)
11:56:20 <kmc> Generics doesn't use 'deriving'
11:56:38 * ddarius really has no idea what zygoloid is talking about.
11:57:18 <Watermind> just one more question... before trying criterion I tried just a simple test, using getCPUTime
11:57:21 <Watermind> http://haskell.pastebin.com/i63NktDV
11:57:45 <Watermind> the test showed accumulator being better and then strict ac even better
11:58:05 <dolio> ddarius: If we talk about language features by relating them to liked and disliked extensions of the class system, it helps lead people to the conclusions we want. :)
11:58:13 <Watermind> then I ran with -O2 and the times for ac and strict ac were 0... now that seems too good
11:58:25 <Watermind> my guess is I may be doing something wrong
11:58:52 <Watermind> is my test "correct"?
11:58:58 <ddarius> Watermind: No.
11:59:05 <Watermind> ddarius: where did I mess up...
11:59:09 <zygoloid> kmc: hah, good point :) i always assume it works the way i think it "obviously" should
11:59:09 <benmachine> Watermind: possibly. the seqs may not have been doing what you expect if GHC already knew the relevant values were strict
11:59:17 <Watermind> oh
11:59:43 <benmachine> Watermind: the only guaranteed rule for seq is that seq x y is an error or infinite loop if x is, and y otherwise
11:59:44 <chrisdone> needs more criterion
11:59:49 <Watermind> so there is no guarantee on that order of evaluation 
12:00:09 <chrisdone> does ghc optimize tail recursion modulo cons(and others)?
12:00:11 <Watermind> benmachine: I see... I had no idea about that
12:00:17 <Watermind> chrisdone: yes I will try that
12:00:46 <ddarius> chrisdone: What do you mean?
12:01:02 <chrisdone> http://en.wikipedia.org/wiki/Tail_recursion_modulo_cons#Tail_recursion_modulo_cons
12:01:41 <chrisdone> the explanation unfortunately shows C code, but it's not a hard concept anyway
12:01:54 <chrisdone> Scheme is known to do this kind of optimisation, for example
12:01:57 <ddarius> No, GHC does not guaranteedly do that.
12:02:11 <chrisdone> sure, not guaranteedly (nice word, haha)
12:02:34 <zygoloid> in any case, DeriveDataTypeable, DeriveFunctor etc have the problem i described
12:03:00 <caelan> hm, i'd been wondering how to optimize that form of cons
12:03:07 <dolio> Reading articles about tail recursion to try and understand what goes on in Haskell/GHC is probably going to lead you astray.
12:03:38 <zygoloid> Functor is fine since it's unique, but the newtype-derived Data and Typeable instances would be different if generated by GeneralizedNewtypeDeriving
12:03:43 <ddarius> chrisdone: Of course, the equivalent of that example in Haskell I believe would be lazy and thus not build stack.
12:03:52 <caelan> does the laziness modify uses of cons?
12:03:58 <ddarius> caelan: No.
12:06:17 <bss03> ?? duplicate = foldr : [] ??
12:06:17 <lambdabot>  duplicate = foldr : []
12:07:07 <sioraiocht> wait, is cons _|_ : [] = _|_?
12:07:31 <monochrom> No.
12:07:39 <sioraiocht> so laziness does affect cons
12:08:07 <bss03> > let (x:y) = (undefined:[]) in length y
12:08:08 <lambdabot>   0
12:08:21 <bss03> > let (x:y) = (undefined:[]) in x
12:08:22 <lambdabot>   *Exception: Prelude.undefined
12:08:26 <chrisdone> "With that said, tail recursion is not that useful of a concept in a lazy language like Haskell.  The important concept to know in Haskell is 'guarded recursion', where any recursive calls occur within a data constructor (such as foldr, where the recursive call to foldr occurs as an argument to (:)).  This allows the result of the function to be consumed lazily, since it can be evaluated up to the data constructor and the recursive call
12:08:26 <chrisdone> delayed until needed."
12:08:52 <wjtk> data Why = Syn (Integer, Integer)
12:08:54 <wjtk>          | Tax Integer Integer
12:08:56 <wjtk>          deriving (Show)
12:09:14 <wjtk> What's the difference between Syn and Tax?
12:09:26 <ddarius> Tail recursion is still crucial to Haskell.
12:09:34 <monochrom> perhaps author did not intend a difference
12:09:35 <bss03> wjtk: They don't have the same type.
12:09:38 <zygoloid> wjtk: Syn has one additional legal value (Syn _|_)
12:09:51 <bss03> wjtk: Syn :: (Integer, Integer) -> Why
12:10:01 <bss03> wjtk: Tax :: Integer -> Integer -> Why
12:10:05 <ddarius> sioraiocht: No, it doesn't.  It effects the evaluation order.  Cons is implemented exactly the same lazy or eager.
12:10:19 <sioraiocht> ddarius: okay...
12:11:21 <wjtk> bss03: Oh, so Tax is like a function where I can use partial application?
12:11:40 <kmc> yes
12:11:45 <bss03> wjtk: yep.
12:11:51 <c_wraith> wjtk, data constructors are functions, in every way
12:12:01 <kmc> also you can expect that converting between a Syn value and (Integer,Integer) will be faster than converting from a Tax value
12:12:12 <wjtk> Ok, I get it.
12:12:13 <kmc> in general though, we'd prefer the Tax form
12:12:25 <kmc> tuples exist to be anonymous product types
12:12:32 <bss03> You can also use partial application on curry Syn.
12:12:33 <kmc> once you've named one, it defeats the purpose
12:13:38 <bss03> @type let { syn :: (Integer, Integer) -> a; syn = undefined; } in curry syn
12:13:39 <lambdabot> forall a. Integer -> Integer -> a
12:13:42 <bss03> > let { syn :: (Integer, Integer) -> a; syn = undefined; } in curry syn
12:13:43 <lambdabot>   Overlapping instances for GHC.Show.Show
12:13:43 <lambdabot>                              (GHC.I...
12:14:42 <wjtk> Please allow second question. Are the keywords 'data', 'type', 'newtype' only confusing for me?
12:14:51 <monochrom> yes
12:15:05 <wjtk> too bad
12:15:18 <blackcustard> i've had some confusion with them, but not a huge amount
12:15:22 <monochrom> actually, no. confusing to person x iff x believes in "meaningful" names
12:15:28 <blackcustard> newtype and type i had conflated yesterday
12:15:55 <blackcustard> <-- is n00b
12:16:03 <monochrom> so perhaps you're in ample company.
12:16:08 <caelan> oh heavens, i prefer meaningful names
12:16:14 <caelan> lisp-style-verbosity
12:16:43 <wjtk> what's <-- again?
12:16:59 <monochrom> graphical arrow
12:17:08 <blackcustard> :p
12:17:11 <blackcustard> i was indicating myself
12:17:21 <monochrom> draw an arrow from "n00b" to "blackcustard"
12:17:44 <blackcustard> i guess that could have been confusing, considering that <- operator
12:19:24 <chrisdone> ew, a spider just dangled down on a web right in front of my face. why do they do that? maybe it was aiming for my head. :(
12:19:51 <caelan> spider gonna getcha
12:20:03 <monochrom> close your web browser
12:20:40 <monochrom> spider was trying to use the web to look at your facebook
12:20:53 <ddarius> chrisdone: You do realize probably you mass 30-100 thousand times it.
12:21:20 <wjtk> time to gabage collect maybe?
12:21:48 <monochrom> spider realizes that too. "food for life", it thinks.
12:22:38 <ddarius> It couldn't eat Chris even if it tried, and if Chris ate it, it would have almost no impact, certainly no discernible impact, on Chris's body.
12:23:01 <monochrom> but spider could emit poison to kill Chris first
12:23:15 <Twey> Yeah, this is an Italian spider
12:23:18 <Twey> It probably could eat him :√æ
12:23:22 <ddarius> If he ate the spider, he'd be consuming all the poison.
12:24:02 <blackcustard> which may or may not cross the lining of the digestive track to reach the blood and do damage
12:24:03 <monochrom> with great ROI comes great risk
12:24:22 <wjtk> Data constructors are functions, but their name starts with a capital letter.
12:24:55 <ddarius> blackcustard: It wouldn't matter if it did.  Most spiders are just too small to contain a dangerous amount of venom.
12:25:33 <chrisdone> hahaha
12:25:38 * chrisdone feels bad for bringing up spiders
12:26:16 <monochrom> it would not matter if spider's attempt to eat Chris is doomed to be futile
12:26:42 <monochrom> we humans engage in more futile attempts at profit
12:27:24 <chrisdone> monochrom: true, if anything the spider is admirable in its ambition, if a little too high. I regret squashing it now
12:27:57 <Rutix> you squashed him :(?
12:28:00 <Rutix> you are mean
12:28:15 <blackcustard> what is the name for operator "|"? the one you use in pattern matching and in list comprehensions?
12:28:17 <monochrom> I disagree. I admire the spider for thinking just as well as humans.
12:29:04 <chrisdone> blackcustard: I believe it's called a guard, but now that you ask I'm not sure
12:29:12 <fryguybob> A good spider is like a good type system, it kills the bugs we don't want.
12:29:29 <blackcustard> i had a spider spin a web in my doorframe a couple times ... i nearly walked into the thing
12:29:43 <monochrom> | is called the vertical bar, just like , is called the comma.
12:29:54 <caelan> but like a braindead-static type system, it leaves icky webs everywhere
12:30:35 <monochrom> If you think "but 'comma' and 'vertical bar' do not carry meanings", that is exactly what I want you to realize. When did punctuations --- delimiters --- needed a meaning?
12:31:01 <Saizan> the thing that has a meaning there is called a guard
12:31:03 <ezrakilty> it's worth noting that the | as used in those places is not an operator.
12:31:12 <blackcustard> actually i was just looking for a term to search for
12:31:13 <blackcustard> XD
12:31:27 <blackcustard> search "haskell guard" found me what i needed
12:31:35 <blackcustard> searching*
12:31:49 <chrisdone> monochrom: how is punctuations formed? how symbol get meaning?
12:33:42 <monochrom> I don't know.
12:34:48 <monochrom> Humans trying to assign meaning to symbols is probably like spider trying to look you up on the web.
12:35:12 <gwern> any date experts around? recognize how to read something like '2009-02-06 17:13:55'?
12:35:37 <dbelange> gwern: No matter what she says, you have to pay
12:35:39 <arcatan> year month day hours minutes seconds
12:35:54 <benmachine> gwern: I wrote a parser for that sort of format once
12:35:56 <monochrom> I may try one of the parsers in Data.Time.Format
12:35:58 <gwern> arcatan: I know, but usually there's some extremely arcane format string I need to write for that
12:36:06 <benmachine> where the year and time were optional
12:36:09 <monochrom> oh haha, the string.
12:36:13 <gwern> which will do String -> GregorianTimeWithCorrectionForLunarianTransit
12:36:23 <gwern> or whatever crazy shit the time functions want
12:36:42 <arcatan> that might be valid ISO 8601 date
12:36:49 <blackcustard> measuring time sucks
12:36:50 <gwern> did I mention I hate dealing with time and dates?
12:37:18 <aristid> "%Y-%m-%d %H:%M:%S"
12:37:31 <benmachine> gwern: do you want my parsec crap?
12:37:35 <monochrom> %Y-%m-%d :%M-%S
12:37:44 <gwern> benmachine: first I'll see if date.time can handle it
12:37:46 <monochrom> %Y-%m-%d %H:%M-%S
12:37:59 <benmachine> hmm
12:38:00 <gwern> hopefully I can get away with Data.List.Split as the msot sophisticated parser I need
12:38:11 <bss03> Can't you do "%Y-%m-%d" as just "%F" and "%H:%M:" as just "%T"
12:38:17 <aristid> either i get lots of lag, or aristid was the fastest
12:38:40 <thetallguy1> Anyone have experience/opinions on the differences between  Data.Edison.Coll.LeftistHeap and Data.Heap?
12:38:48 <bss03> % date +"%F %T"
12:38:49 <bss03> 2010-10-13 14:38:16
12:39:05 <monochrom> if you like
12:39:35 <mathijs> good evening all
12:39:51 <monochrom> aristid was the fastest
12:39:59 <mathijs> anyone around with some knowledge of message-passing, concurrency and STM?
12:40:10 * bss03 hides.
12:40:11 <aristid> monochrom: \o/
12:40:28 * hackagebot wumpus-core 0.36.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.36.0 (StephenTetley)
12:40:32 <aristid> gwern: why not just use parseTime?
12:40:45 <gwern> aristid: I dunno
12:40:46 <bss03> aristid: Isn't there a unicode character for "\o/"?  You should use that instead.
12:40:53 <aristid> gwern: i think your hatred of dates is blinding you from using the best options :)
12:41:36 <aristid> gwern: parseTime defaultTimeLocal "%Y-%m-%d %H:%M:%S" date
12:41:59 <aristid> really, that is not all that hard or evil or anything
12:42:00 <gwern> does UTCTime convey the year/month? or just the time within an unknown day?
12:42:13 <aristid> UTCTime conveys the year/month, sure
12:43:00 <benmachine> has old-locale actually been replaced yet
12:43:01 <aristid> well, of course if you want the date on another locale than UTC, it doesn't
12:43:07 <aristid> benmachine: no, not really
12:43:21 <wjtk> (|>) f g = g f
12:43:23 <wjtk> This is from F#. Is there a predefined equivalent in Haskell?
12:43:35 <gwern> flip?
12:43:40 <gwern> or no, that's not flip
12:43:43 <benmachine> flip id
12:43:51 <benmachine> or flip ($) if you like
12:44:01 <gwern> :t (|>) f g = g f
12:44:02 <benmachine> it doesn't have a standard name though
12:44:02 <lambdabot> parse error on input `='
12:44:11 <aristid> :t let (|>) f g = g f in (|>)
12:44:12 <lambdabot> forall t t1. t -> (t -> t1) -> t1
12:44:13 <caelan> :t flip . id
12:44:14 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
12:44:15 <arcatan> @djinn a -> (a -> b) -> b
12:44:16 <lambdabot> f a b = b a
12:44:19 <aristid> @hoogle t -> (t -> t1) -> t1
12:44:19 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:44:20 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
12:44:20 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
12:44:28 <bss03> @pl \f g = g f
12:44:28 <lambdabot> (line 1, column 6):
12:44:28 <lambdabot> unexpected "="
12:44:28 <lambdabot> expecting pattern or "->"
12:44:29 <monochrom> people gave it various names in the past. none stuck.
12:44:31 <gwern> aristid: alright, I wasn't sure, because the doc says 'This is the simplest representation of UTC. It consists of the day number, and a time offset from midnight. Note that if a day has a leap second added to it, it will have 86401 seconds.'
12:44:32 <bss03> @pl \f g -> g f
12:44:32 <lambdabot> flip id
12:44:42 <gwern> aristid: which to me sounds like it drops month/year data
12:44:47 <aristid> gwern: you can convert that back.
12:45:15 <chrisdone> I'm using Data.Time and System.Time in a project ~O_~
12:45:17 <aristid> gwern: the gregorian calendar is just a formula. there are some functions to do that
12:45:28 <aristid> chrisdone: why both?
12:45:33 <mathijs> does anyone know of a way to safely (atomically) change data on different machines? my code gathers some versioned data from other nodes, calculates results, and sends "update data to XX if version is still Y" messages to the other nodes. however, if one of the nodes tells me the version is no longer Y, I want none of the changes to apply (just like STM)
12:45:34 <jmcarthur> /fmmm/buff25
12:45:37 <jmcarthur> wat
12:45:39 <chrisdone> some libraries want one, others want the other
12:46:01 <mathijs> so I think I need something like a 2-stage commit, but can't figure it out :(
12:46:08 <monochrom> note that "day number" identifies a large range of days. "with zero being the day 1858-11-17"
12:46:51 <benmachine> mathijs: maybe you want http://hackage.haskell.org/package/DSTM-0.1.1
12:47:01 <aristid> gwern: toGregorian :: Day -> (Integer, Int, Int)
12:47:16 <aristid> gwern: so you take the day from UTCTime and get year, month, day
12:48:02 <aristid> gwern: you can even get the week calendar, which is pretty cool IMO
12:48:31 <monochrom> Data.Time is awesome
12:48:45 <aristid> yes, apart from time zone support
12:48:47 <monochrom> I hated dates and times too. Then I met Data.Time
12:48:56 <identity> Data.Time > System.Time anyway
12:49:00 <mathijs> benmachine: I know about that, looked at it, played with the examples. I like it, and I'm pretty sure they need to do something similar. But by reading the code, I couldn't figure out how they did it (so I can't verify if there's no race conditions)
12:49:01 <identity> I dind't know about Data.Time for a good while
12:49:19 <chrisdone> I like 'em both
12:49:41 <benmachine> mathijs: did you see the PDF manual?
12:49:55 <benmachine> (I haven't looked at it, just a thought)
12:50:00 <catarsis> What environment variables, or what not, controls the ability to just do putStrLn a wher a has non-ascii characters? I have this running in a shell, when I do sudo bash -c 'sameProggie.hs' it gives me that error. echo $LANG gives same value in both (nothing)
12:50:14 <mathijs> benmachine: yup, but maybe I skipped some parts, lemme see again
12:50:34 <benmachine> mathijs: maybe you didn't, like I said I haven't read it
12:50:40 <benmachine> just making sure you didn't miss anything obvious :P
12:50:47 <monochrom> LANG=en_CA.UTF-8
12:50:50 <gwern> > read '7' :: Int
12:50:51 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:50:51 <lambdabot>         against inferred ty...
12:50:58 <mathijs> benmachine: basically I'm after an anser to the question itself, not so much a working piece of code to use.
12:51:10 <chrisdone> one problem is converting between the old times and the new times
12:51:11 <catarsis> monochrom: what's the CA there?
12:51:13 <monochrom> of course that's just because I'm in Canada. just look for a valid somethingsomething.UTF-8
12:51:14 <gwern> @hoogle Char -> Int
12:51:14 <lambdabot> Data.Char digitToInt :: Char -> Int
12:51:14 <lambdabot> Data.Char ord :: Char -> Int
12:51:14 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
12:51:21 <chrisdone> some system libraries still use the old time, e.g., for modification time
12:51:39 <wjtk> Well, "atomically, on different machines" is a can of worms. Cluster membership, partitioning and the like. Paxos commit algorithm is the most recent "state of the art".
12:51:43 <chrisdone> :t getModificationTime
12:51:44 <chrisdone> :t getClockTime
12:51:44 <lambdabot> Not in scope: `getModificationTime'
12:51:45 <lambdabot> Not in scope: `getClockTime'
12:51:52 <chrisdone> @slap yourself
12:51:52 * lambdabot clobbers yourself with an untyped language
12:52:23 <aristid> chrisdone: making a System.Time.CalendarTime should be pretty easy with Data.Time
12:52:48 <chrisdone> I made:
12:52:48 <monochrom> even zh_CN.UTF-8 would do you much good
12:52:48 <chrisdone> calendarToUTC :: CalendarTime -> UTCTime
12:52:48 <chrisdone> calendarToUTC = parseUTCTime . showCalendarTime
12:53:09 <aristid> chrisdone: you should put that into a separate package :)
12:53:12 <chrisdone> not the fastest function in the world
12:53:23 <aristid> oh
12:53:33 <aristid> heh that's a lazy hack ;)
12:54:02 <sipa> @slap himself: what would i do
12:54:02 * lambdabot throws some pointy lambdas at himself: what would i do
12:54:06 <sipa> @slap himself: what would i do
12:54:06 * lambdabot pushes himself: what would i do from his chair
12:54:10 <chrisdone> aristid: care to write me a better one? ;_
12:54:15 <chrisdone> http://hpaste.org/40550/datatime_and_systemtime
12:54:30 <monochrom> it is compatible to my spirit of: all numerology exercises are solved by show and read
12:54:33 <chrisdone> woops, the first function is not relevant
12:54:46 <chrisdone> monochrom: damn straight!
12:55:55 <chrisdone> Read and Show are great. it is *damn* evil to implement custom versions of them
12:56:05 <monochrom> "Project Oiler #45: how many 4's and 5's appear in the factorial of 45?"  length (filter (\x -> x=='4' || x=='5') (read (product [1..45])))
12:56:17 <catarsis> monochrom: no dice. with LANG=en_CA.UTF-8  I get same error
12:56:30 <monochrom> then the file is not in UTF-8 to begin with
12:56:37 <mathijs> wjtk: thanks, I'll look at that
12:56:38 <catarsis> I have a feeling something in underlying locale machinery is broken
12:56:57 <nlogax> chrisdone: whoops.. i did that for my irc parser to be able to just hPrint it and stuff. with a comment saying "Is this abuse of the Show class?"
12:57:04 <monochrom> not broken
12:57:07 <aristid> chrisdone: it just involves toGregorian and a bit of arithmetic
12:57:34 <monochrom> it is so easy and comfortable to implicate that the compiler and lib has a bug.
12:57:43 <monochrom> especially when no one else can reproduce the error
12:57:51 <aristid> chrisdone: Data.Fixed has the nifty functions div', mod' and divMod' for that
12:58:10 <catarsis> monochrom: that's certainly possible.
12:58:28 <chrisdone> aristid: can you write it in about half a minute which is the time it took me to do the one above? 
12:58:50 * chrisdone waits
12:58:58 <monochrom> compiler has bugs but not like this. compiler bugs are like impossible typechecking errors in extreme uses of type families etc.
12:59:01 <chrisdone> nlogax: what's hPrint?
12:59:08 <aristid> chrisdone: no, i need more for that
12:59:13 <aristid> chrisdone: but it would feel cleaner :)
12:59:26 <elliott> haskell.org is identifying itself as localhost.localdomain
12:59:30 <elliott> browsers are not impressed
12:59:37 <nlogax> @type hPrint
12:59:38 <lambdabot> Not in scope: `hPrint'
12:59:40 <aristid> chrisdone: also i'm too lazy to do it for you now :P
12:59:43 <chrisdone> elliott: works fine here...
12:59:53 <nlogax> chrisdone: prints stuff into a Handle
12:59:57 <elliott> chrisdone: maybe chrome's gone insane.
12:59:59 <monochrom> how do you know what it self-identifies?
13:00:03 <nlogax> hPrint :: (Show a) => Handle -> a -> IO ()
13:00:05 <elliott> nope
13:00:08 <elliott> Organisation is SomeOrganisation
13:00:11 <elliott> expiry 2005
13:00:14 <elliott> someone's borked the certificate
13:00:22 <chrisdone> you use https?
13:00:46 <benmachine> The certificate is not trusted because it is self-signed. The certificate is only valid for localhost.localdomain The certificate expired on 25/05/05 14:26. 
13:00:51 <monochrom> I know of a school of thought that says you should https everything
13:01:12 <chrisdone> and that school of thought can go implement faster internet
13:01:38 <catarsis> monochrom: what are the downsides of that? makes sense to me.
13:01:45 <caelan> that's boring, i want O(1) encryption
13:01:48 <monochrom> self-sign certs are fine (and that school of thought actually welcomes it and rejects big-brother-ish cert authorities), but at least self-renew it too
13:01:57 <monochrom> no downsides
13:02:00 <catarsis> :)
13:02:04 <chrisdone> nlogax: so, (hPutStr .) . show?
13:02:39 <fizruk> where can I read about type constraints like (a ~ b)?
13:02:39 <chrisdone> no, flip hPutStr . show
13:03:06 <nlogax> chrisdone: yes, that looks right
13:03:20 <nlogax> chrisdone: anyway, i think you answered the question i put in my comment :)
13:03:25 <chrisdone> nlogax: so you implemented a custom show just for that? :P
13:03:42 <elliott> <chrisdone> you use https?
13:03:45 <elliott> google results do
13:03:48 <elliott> or rather thsi one google result
13:04:06 <elliott> *this
13:04:10 <chrisdone> how rare
13:04:10 <nlogax> chrisdone: i have a big ol type for irc messages, i made the show instance turn it into a irc friendly string
13:04:17 <monochrom> associated types and/or type families has (a~b)
13:04:26 <chrisdone> nlogax: tch tch :p
13:04:54 <chrisdone> you're re-implementing Network.IRC?
13:05:08 <monochrom> call it IRC.Network :)
13:05:08 <nlogax> chrisdone: but in the process i read that `show something' should output valid haskell that can be `read'
13:05:14 <elliott> chrisdone: It's my favourite thing to do.
13:05:17 <nlogax> so i knew i was up to no good
13:05:26 <elliott> nlogax: Lame, you should have one type per message! Like my crazy, crazy library that never got anywhere.
13:05:32 <nlogax> yeah, i'm reinventing the wheel for fun and profit^W^W
13:06:04 <nlogax> elliott: i'm just a noob, i write crappy stuff instead of crazy stuff :D
13:06:24 <elliott> nlogax: I'd do it your way now, too.
13:06:42 <monochrom> as long as you don't leak your Show instance to the world
13:06:44 <chrisdone> one constructor per message sounds nice
13:07:18 <elliott> @hoogle [a] -> StdGen -> a
13:07:18 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
13:07:19 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
13:07:19 <lambdabot> Prelude const :: a -> b -> a
13:07:22 <elliott> hmph
13:07:24 <chrisdone> I've found that militantly using newtype instead of type aliases in my project has already provided benefits
13:07:31 <nlogax> irc is so dirty anyway.. i don't like how ctcp messages are the same as any other, except the last parameter in the param list starts with '\SOH'
13:07:49 <nlogax> and lots of stuff like that
13:08:03 <djahandarie> Has there ever been a good specification for anything?
13:08:10 <sipa> SOH = ascii 1 ?
13:08:10 <nlogax> haskell?
13:08:12 <nlogax> :D
13:08:17 <elliott> <nlogax> irc is so dirty anyway.. i don't like how ctcp messages are the same as any other, except the last parameter in the param list starts with '\SOH'
13:08:20 <elliott> it's not really like that...
13:08:27 <elliott> it's just that CTCP is an *extension* to IRC messages
13:08:31 <elliott> a backwards-compatible one at that
13:08:45 <djahandarie> ngochai, Haskell98 has its problems also
13:08:45 <elliott> also isn't it \1...\1, not just \1...?
13:08:53 <nlogax> yes, it is
13:08:57 <djahandarie> Whoops
13:08:59 <djahandarie> nlogax*
13:09:09 <nlogax> but you have to get all the way there to know if it is one
13:09:34 <nlogax> djahandarie: i'm sure it does :)
13:09:45 <Sipax> let's
13:09:49 <sipa> damn
13:09:59 <monochrom> I think some people's code just looks at the leading \1 and makes the decision already.
13:10:01 <Sipax> let's see... i'm in netcat :)
13:10:11 * sipa test
13:10:23 <monochrom> netcat is insufficient. try netcat | od
13:10:31 * djahandarie prefers netdog
13:10:38 <sipa> od?
13:10:49 <monochrom> show octal numbers
13:10:53 <elliott> nlogax: also, it's more than that
13:10:59 <elliott> ctcp can be anywhere in a message
13:11:00 <monochrom> God, you know netcat and not od?
13:11:06 <elliott> for instance technically this is a mid-message /me:
13:11:07 <Sipax> oh it's pretty clear
13:11:13 <elliott> foo bar baz \1ACTION foo\1 quux
13:11:24 <nlogax> elliott: whoa. then i have misinterpreted it :)
13:11:24 <monochrom> misread. nevermind.
13:11:41 <elliott> ngochai: Nothing supports *that* but it might work for some other things.
13:11:42 <elliott> MAYBE
13:12:01 <djahandarie> Is there some way to exploit the monomorphism restriction to do awesome type-level hackery?
13:12:02 <sipa> :djahandarie!~darius@unaffiliated/djahandarie PRIVMSG #haskell :1ACTION prefers netdog1
13:12:08 <nlogax> i made my bot crash when it couldn't parse a message, spitting out the evil one.. and discovered that no client follows the rfc, through many crashes :)
13:12:10 <sipa> i see the 1's alright :)
13:12:14 * djahandarie checks Oleg's site
13:12:33 <sipa> monochrom: i knew hd, but not od :)
13:12:36 <djahandarie> Damn, nothing there. I guess that means its impossible ;)
13:12:51 <chrisdone> djahandarie: or it means Oleg's not released a paper about it yet
13:12:54 <monochrom> you should write your program to not crash despite all sorts of parse errors
13:13:18 <djahandarie> Or that it is so simple that it doesn't even need a paper
13:13:26 <monochrom> otoh my experience is opposite. everyone follows the rfc.
13:13:52 <Saizan> djahandarie: nothing so awesome but it can be useful if you want to avoid ScopedTypeVariables
13:16:02 <maurer_> If I want to wait for a thread produced by forkIO to return, how do I do that?
13:16:35 <chrisdone> monochrom: I learned recently that sometimes I should throw exceptions in my code. e.g., when a value in the database is in an incorrect format, which should never happen, but if it does, I should log it in the logfile. I could use the Error monad but I still need to catch any other exceptions like database problems, resource failures, etc. so I have an IO exception handler. it's tricky to know when to use plain exceptions or ErrorT
13:17:07 <Saizan> maurer_: do v <- newEmptyMVar; forkIO (foo >> putMVar v ()); takeMVar v
13:17:19 <maurer_> :( OK.
13:17:22 <Saizan> maurer_: you may want to s/>>/finally/
13:17:28 <chrisdone> Saizan: that should be in the library somewhere
13:17:35 <Saizan> it probably is
13:17:57 <Saizan> well, "a library" at least :)
13:20:13 <maurer_> I'm surprised we don't have a library for doing things such as "here is a list of IO actions. Please execute all of them, in any order, using n workers"
13:20:20 <maurer_> Or maybe I just suck at finding things.
13:20:40 <mauke> :t mapM_ forkIO
13:20:41 <lambdabot> Not in scope: `forkIO'
13:20:50 <sipa> that's not the same
13:20:53 <monochrom> exception and handling is one way to not crash
13:21:34 <benmachine> maurer_: such things either are or easily could be on hackage; I think the default libraries are supposed to be fairly minimalist
13:21:41 <chrisdone> I'm so happy that haskell weekly news is back
13:22:15 <monochrom> I write readIO ... catch ... all the time
13:22:15 <maurer_> Oh huh. I think Control.Monad.Parallel may do what I want.
13:22:28 <adimit> I have an issue: following hexpat's docs, I tried to implement a lazy xml parser, but the error handling code forces evaluation on the whole parse tree! Code's here:http://gist.github.com/624815
13:22:46 <adimit> w/o the last two lines, the programs runs in less than 4 megs on a huge input file.
13:23:02 <adimit> with them, it doesn't run at all, but first, it gobbles up >3Gigs of ram.
13:23:31 <adimit> I'm puzzled. Anyone who can help? The hexpat tutorial is the following: http://hackage.haskell.org/packages/archive/hexpat/0.19.2/doc/html/Text-XML-Expat-Tree.html
13:24:04 <benmachine> adimit: if you want to know if an error occurred, you pretty much have to do all the parsing
13:24:37 <sipa> but i suppose his problem is not that it parses everything, but that it consumes to much memory?
13:24:41 <adimit> yes.
13:24:52 <adimit> that's the problem. It *may* parse the whole thing - in fact, that's what I want.
13:24:59 <monochrom> perhaps you should go the SAX route
13:25:11 <adimit> ultimately. But why does it consume 3Gigs where I give it a 42 megs input file?
13:25:26 <benmachine> adimit: that *is* odd, suggests a memory leak in expat itself
13:25:31 <adimit> I don't think SAX or no SAX is the problem here. How could SAX help?
13:25:55 <adimit> benmachine: if you look at the url i linked, the author suggest *exactly* what I did in order to *avoid* memory leaks.
13:26:04 <benmachine> adimit: yes, I know
13:26:14 <benmachine> adimit: the principle is sound, but the implementation may have fucked up
13:26:15 <adimit> so I'm really confused. I guess I'll go ask some mailing list or the author himself :-|
13:26:48 <adimit> so for now I'll have to throw exceptions around. :-( Don't like exceptions.
13:27:46 <blackcustard> i just got the output "(4,word "where")" from a trace statement on a tuple of type (Int, Int) ... does Hugs print random crap when you make it print alot of stuff pretty fast?
13:30:33 <adimit> If I send a mail to a mailing list asking about the problem, would haskell or beginners be the better choice?
13:30:40 <blackcustard> o.O, not that it actually matters, i got the output i needed anyway XD
13:31:20 <monochrom> I suggest sending to haskell-cafe
13:33:25 <adimit> monochrom: ok, thanks.
13:35:49 <monochrom> the mailing list called "haskell" is not intended for asking. it's for announcing, like "w00t I've posted HaltingProblemSolve to hackage!"
13:36:14 <deadguys> I'm trying to get started with MissingPy, is anyone familiar with it?  I'm getting "HSMissingPy-0.10.3.o: unknown symbol `PyImport_ImportModuleEx'"
13:36:43 <monochrom> and 5 minutes later "w00t I've posted HaltingProblemSolver version 0.2 to hackage! changelog: corrected typo in the name!"
13:37:46 <benmachine> it's a problem solver, that halts
13:37:51 <benmachine> sorry for getting your hopes up, everyone
13:38:03 <DevHC> lol
13:38:18 <monochrom> however, a lot of announcing happens in haskell-cafe too (in fact most don't post to haskell even for package announcements). I guess the perception is that haskell-cafe is more popular.
13:38:31 <benmachine> and haskell is more important
13:38:35 <benmachine> sort of
13:40:32 <sipa> benmachine: i hear the author is working on NonhaltingProblemSolve now... the coding was finished but they're (still) running tests
13:41:06 <benmachine> sipa: :)
13:41:30 <adimit> well, I just wanna ask about a possible bug without bugging the author first, seeing as I might have missed something, and I don't wanna go spam his inbox...
13:41:35 <adimit> so haskell-cafe it is.
13:42:00 <benmachine> adimit: you don't want to spam his inbox, just everyone else's instead :P
13:42:06 <adimit> exactly :-P
13:42:11 <ddarius> benmachine: And probably his.
13:42:27 <adimit> well, every smart person has them filtered away. So i wouldn't be spamming his inbox really.
13:42:32 <benmachine> mm
13:43:01 <monochrom> hahaha sipa++
13:44:49 <maurer_> When I try to produce a statically linked binary like I used to (-optl-static) I now get linker errors. Anyone know how to do this?
13:46:04 <benmachine> maurer_: static is the default afaik
13:46:27 <benmachine> ghc also accepts -static
13:46:44 <benmachine> (or at least, doesn't say it's an unrecognised flag :P)
13:46:53 <maurer_> ghc -static is to use static haskell libraries
13:52:27 <dstcruz> HWN - Issue 154 is out! Get it while it is still hot :) http://sequence.complete.org/hwn/20101013 -- and send in the comments!
13:52:52 <Zao> Ooh.
13:55:19 <maurer_> Any other ideas?
13:59:38 <kmc> maurer_, which linker errors?
14:01:16 <maurer_> http://hpaste.org/40554/foo
14:01:20 <sinelaw> ooh, hwn is back
14:01:43 <maurer_> Command line:  ghc -static --make forceit.hs -optl-static -optl-pthread
14:02:24 <benmachine> maurer_: I was never quite clear on why you needed to specify anything at all, are you trying to statically link C libs or something?
14:02:56 <maurer_> I'm tring to make a binary that I can ship to another machine, with a different glibc, and run.
14:02:57 <benmachine> maurer_: I mean, have you established that not specifying that option dynamicallly links?
14:03:03 <maurer_> Yes.
14:03:08 <benmachine> oh ok
14:03:50 <maurer_> Depends on 9 different libraries :/
14:04:19 <kmc> maurer_, i see a bunch of warnings, is there anything else?
14:04:45 <maurer_> Nope. However, when I run the program, an assert fails and it crashes
14:04:53 <kmc> an assert related to this issue?
14:04:58 <maurer_> Yes:
14:05:09 <kmc> seems to be a design limitation in glibc, then :/
14:05:24 <kmc> you might have to do something drastic, like use a different libc for those functions
14:05:31 <maurer_> forceit: ../sysdeps/unix/sysv/linux/getpagesize.c:32: __getpagesize: Assertion `_rtld_global_ro._dl_pagesize != 0' failed.
14:05:47 <maurer_> So, this method worked about 2 years ago when I had to do this before.
14:05:51 <maurer_> I'm not sure what's changed.
14:06:15 <benmachine> is the problem limited to haskell source?
14:06:27 <benmachine> e.g. have you tried an example C program
14:06:29 <kmc> i'd be surprised if so
14:06:38 <kmc> maurer_, can you do a shared link and bundle the glibc .so with your binary?
14:06:55 <maurer_> kmc: glibc works differnetly
14:06:59 <maurer_> err, differently
14:07:12 <maurer_> You can't just LD_LIBRARY_PATH it because the shared library loading mechanism depends on it
14:07:20 <kmc> mm
14:07:28 <kmc> http://gcc.gnu.org/ml/java/2004-06/msg00136.html
14:07:35 <kmc> 'In order to make glibc support static linking you have to build a
14:07:35 <kmc> special version using the "--enable-static-nss" configure option,
14:07:35 <kmc> and this will render name service support less functional (fully
14:07:35 <kmc> statically linked binaries will only do the "files" and "dns"
14:07:35 <kmc> part of what you configured in nsswitch.conf).'
14:07:40 <kmc> sorry for flood
14:08:52 <kmc> makes sense ‚Äî nsswitch needs to load plugins dynamically
14:09:01 <kmc> it's dumb that it can't fall back without a custom-built glibc, though
14:09:15 <maurer_> What's the switch to tell gcc to link against glibc?
14:09:47 <maurer_> -lc produces fine results (no complaining)
14:09:57 <sipa> not giving -nostdlib
14:10:16 <kmc> gcc -nostdlib -L/path/to/my/special/libc -lc
14:10:42 <kmc> i'm not sure that's enough, honestly.  you might just pass libc.a on the linker command line
14:10:46 <kmc> but you'll still need nostdlib
14:13:00 <maurer_> Seems to produce a statically linked binary fine.
14:13:16 * kmc is confused
14:13:21 <kmc> you changed something and got rid of the warnings?
14:13:44 <maurer_> No. A sample C file seems to produce a static binary against my libc
14:14:16 <kmc> ah
14:14:22 <kmc> did you call one of those functions?
14:14:31 <maurer_> I'm beginning to suspect that the Network library, even in static for may be the problem. Onesec
14:14:38 <maurer_> s/for/form/
14:14:42 <kmc> i mean, this is a documented problem outside of Haskell
14:15:25 <maurer_> Well, yes, but my suggestion is that it appears my glibc supports it, but maybe the way we currently build Network doesn't?
14:15:33 <kmc> my glibc doesn't support it
14:15:56 <kmc> http://hpaste.org/40556/static_glibc
14:16:23 <Itkovian> hmm, should AllSubmatches [] (MatchOffset, matchLength) not return exactly that: all matches ofg a given regex? 
14:16:55 <maurer_> Nevermind, I can't actually build a regular binary, without using nss anywhere, in haskell, which is statically linked (it jut prints "foo")
14:18:01 <kmc> maurer_, so i think you've got to use a different libc -- either glibc built with --enable-static-nss, or some other libc
14:18:06 <maurer_> :(
14:18:19 <maurer_> Why did this work before?
14:18:22 <catarsis> Is there something in Control.Parallel.Strategies that I can use to ensure that a showable string doesn't include an error? I can get the desired behavior (program errors) by doing putStrLn . show $ somestring     . But I would like to do this kind of thing without resorting to putStrLn to force evaluation.
14:18:30 <kmc> or if you're not using those functions at all, you could build 'network' to avoid them
14:18:40 <kmc> catarsis, Control.Exception.evaluate
14:18:59 <maurer_> kmc: I tried doing main = putStrLn "foo" in a file and could not get this to build statically
14:19:05 <kmc> evaluates to whnf, so you could combine it with deepseq
14:20:14 <kmc> maurer_, works for me
14:20:34 <kmc> can you think of any other reason it'd be including the 'network' package?
14:20:48 <kmc> can you use objdump (or just grep) to look for references in the .o file?
14:20:56 <kmc> maybe build without --make to see what happens?
14:21:51 <kmc> maurer_, http://hpaste.org/40557/static_linking
14:22:13 <kmc> i can tell you versions of things i'm using, etc
14:23:03 <augur> CT question: my understanding is that f : A -> A is not necessarily an identity on A, yes?
14:23:11 <kmc> correct
14:23:17 <kmc> reverse :: String ‚Üí String
14:23:44 <kmc> augur, the existence of an identity morphism is guaranteed, for each type, but other morphisms with that signature may also exist
14:23:56 <kmc> then again...
14:24:01 <kmc> @check \xs -> reverse xs == xs
14:24:02 <lambdabot>   "OK, passed 500 tests."
14:24:07 <augur> ok, i just wanted to make sure. so the idea of an identity is A -> A but where the elements of an object are mapped to themselves
14:24:12 <hpc> wtf
14:24:18 <hpc> > reverse "123"
14:24:19 <lambdabot>   "321"
14:24:21 <kmc> augur, you don't explicitly talk about mapping elements through a morphism
14:24:31 <c_wraith> hpc: think about type defaulting :)
14:24:32 <kmc> not all categories have an idea of application
14:24:33 <olsner> hpc: defaulting to [()] I think
14:24:37 <augur> sure, but crucially thats what distinguishes f : A -> A from 1[A]
14:24:40 <ddarius> or "element"
14:24:53 <catarsis> kmc: thanks, trying that out
14:24:59 <kmc> augur, what makes id the identity is that (f‚àòid) = (id‚àòf) = f
14:25:03 <catarsis> it's not as simple as just replace with evaluate I see ;)
14:25:29 <augur> kmc, sure, but that depends on the internals of f/A not just f itself
14:25:39 <kmc> augur, i don't follow
14:25:48 <ddarius> kmc forgot the quantifier
14:25:57 <augur> since f(A) = A and 1(A) = A
14:25:57 <kmc> yeah i meant for all f
14:26:09 <kmc> augur, you can't write f(A) in general
14:26:10 <augur> so (f.1)(A) = A
14:26:16 <kmc> you mean that as f applied to A?
14:26:40 <kmc> there's no idea of "applied to" for a category in general.  and there's no idea of "values" in each type (object)
14:26:43 <augur> well, where A is f(A) is the first A in an arrow diagram
14:27:02 <augur> i mean, the way i was introduced to CT is that objects are objects, we dont talk about internals
14:27:25 <augur> but then any endomorphism is an identity if we cant talk about internals
14:28:29 <ddarius> augur: As kmc said, id is the arrow that satisfies, forall appropriately typed g and h, g . id = g and id . h = h.  
14:28:58 <augur> ddarius: but then we definitely have to have a notion of members-of-A not merely A qua A
14:29:16 <ddarius> augur: No you don't.  You need composition and equality of arrows.
14:29:27 <augur> because composition of arrows will still hold in that way even for non-identities
14:29:34 <ddarius> augur: No it won't.
14:29:35 <kmc> nope augur
14:29:53 <kmc> reverse . show  ‚â† show
14:29:55 <kmc> id . show = show
14:29:59 <augur> if f is not an ID, its still true that if f : A -> A and g : A -> B then g.f : A -> B
14:30:19 <augur> kmc: but thats only true because show and reverse have TYPEs and INSTANCEs
14:30:21 <ddarius> augur: Which has nothing to do with what I said.
14:30:40 <kmc> id isn't an identity because id . f : A -> B.  it's an identity because id . f = f
14:30:41 <ddarius> augur: Again, we have a notion of equality of arrows.  
14:30:56 <joeyh> are there any good tutorials for combining the IO and State monads? RWH is not doing it for me.
14:31:16 <augur> ddarius: and that concept of equality of arrows is more than just identity of end points
14:31:40 <ddarius> augur: It's data given in the definition of category.  When you make a category, you say which arrows are equal and which aren't.
14:32:03 <augur> ddarius: ok.
14:32:06 <kmc> right.  for a category built out of functions, you might *implement* that by extensional equality of input/output pairs, but that's not part of the definition of a category
14:32:07 <ddarius> That notion of equality can be based on some internal structure, or it can be completely arbitrary, it doesn't matter to category theory.
14:32:45 <kmc> if you're building CT on top of set theory, then for types A,B you have a set of all arrows A ‚Üí B, and you can define equality as ordinary set equality
14:33:02 <augur> kmc, ddarius: im just making sure i know whats going on, cause conceptual mathematics makes reference to internals in examples
14:33:07 <augur> and i want to make sure whether or not thats crucial
14:33:13 <catarsis> kmc: thanks for the tip. Not sure what you were suggesting wrt evaluate. however...
14:33:17 <catarsis> ("hoohah"  ++ error "arrrg") `deepseq` (putStrLn "ok")
14:33:19 <catarsis> does what I want
14:33:32 <catarsis> (if I use seq instead of deepseq the above prints "ok")
14:33:44 <kmc> catarsis, evaluate (("hoohah" ++ error "arrrg") `deepseq` ())
14:33:56 <kmc> that's an IO action which forces its string arg completely, but has no other observable effect
14:34:23 <catarsis> what's the difference between that and what I had?
14:34:24 <monochrom> "evaluate" is a function in Control.Exception
14:34:35 <sipa> joeyh: i just learned by trying :)
14:34:39 <kmc> catarsis, yours is tied to doing some real IO -- printing "ok"
14:34:55 <kmc> perhaps you don't want to print something, you just want to check for error and go about your business
14:35:15 <monochrom> use "StateT s IO a" to combine IO and State
14:35:18 <joeyh> sipa: yeah, actually I figured out the stupid typo that was breaking my program now
14:35:27 <kmc> now it would probably work to do:  foo `deepseq` (return ())
14:35:32 <sipa> monochrom: that's basically it :)
14:35:35 <kmc> but "evaluate" is nicer to read and more explicit
14:35:36 <catarsis> ("hoohah"  ++ error "arrrg") `deepseq` (return ()) -- also works
14:35:37 <joeyh> still in the stage where I miss a $ and get confused for 15 minutes sometimes :)
14:35:57 <monochrom> be type-driven
14:36:01 <kmc> evaluate x = (return $! x) >>= return
14:36:04 <kmc> catarsis
14:36:10 <benmachine> kmc: pretty sure that's a lie
14:36:22 <benmachine> it says it in the docs but I don't believe it
14:36:28 <catarsis> anyways I got what I want :)
14:36:28 <kmc> ok
14:36:28 <monochrom> it would also help if you coded in syntax trees rather than plain text
14:37:08 <benmachine> it's a monad law that (return $! x) >>= return = return $! x anyway
14:37:21 <ddarius> benmachine: Which simply means that IO doesn't satisfy the monad laws.
14:37:31 <kmc> monad laws are a bit fuzzy around strictness aren't they
14:37:38 <benmachine> ddarius: I think it does, though
14:37:39 <ddarius> kmc: No, they aren't.
14:37:59 <benmachine> and that that definition is just not true
14:38:07 <benmachine> it's not how it is in the source code at any rate
14:38:13 <ddarius> benmachine: You can at least verify whether that equation holds.
14:38:27 <kmc> hehe
14:38:30 <g_cross> Quick question:  Does anyone know of a library on Haskell that has lists tagged with their length using a phantom type-level natural number?
14:38:34 <kmc> the definition in the source code is nasty
14:38:43 <g_cross> I wrote such a library but I don't know if its redundant
14:39:22 <ddarius> benmachine: I'll give you a hint.  That equation doesn't hold.
14:39:26 <benmachine> ok I'm surprised
14:39:29 <benmachine> I thought it did
14:39:39 <benmachine> but I checked and you're right
14:39:43 <benmachine> >>= return does make a difference
14:39:49 <benmachine> how silly
14:40:24 <g_cross> Oops, found one:  fixed-list
14:40:33 <sipa> @hoogle fixed-list
14:40:33 <lambdabot> module Data.Fixed
14:40:34 <lambdabot> Data.Fixed data Fixed a
14:40:34 <lambdabot> Data.Fixed showFixed :: HasResolution a => Bool -> Fixed a -> String
14:41:00 <benmachine> I still don't think that's right for evaluate though
14:41:19 <catarsis> any library function like     evaluate'_ x = evaluate $ x `deepseq` ()       -- ?
14:41:25 * benmachine continues fiddling
14:41:32 <ddarius> catarsis: There's no reason for it.
14:41:50 <catarsis> evaluate a value strictly, with no side effect?
14:42:05 <kmc> isn't it clearer to write it with deepseq?
14:42:41 <catarsis> I guess it's a question of if the need for it comes up often enough. I always figured ' means strictly and _ means no side ffect
14:43:06 <ddarius> catarsis: The _ convention definitely doesn't mean "no side effects" 
14:43:21 <kmc> and 'evaluate' already evaluates its argument strictly
14:43:21 <ddarius> In many cases, such functions rely on side effects to be meaningful at all.
14:43:30 <kmc> "strictly" generally means to weak head-normal form
14:43:33 <kmc> deepseq forces more than that
14:43:36 <kmc> deepseq is also expensive
14:43:37 <catarsis> aha
14:43:42 <edwardk> _ usually means 'and don't waste time collecting the results'
14:43:42 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
14:44:29 <benmachine> kmc: ok, ignore me, as far as I can tell that equation is right. but only because IO breaks the monad laws >_>
14:44:35 <kmc> :/
14:44:38 <benmachine> and is also just downright weird
14:46:11 <benmachine> undefined >>= return :: IO a
14:46:14 <benmachine> is not bottom
14:46:26 <ddarius> It shouldn't be by the monad laws.
14:46:35 <benmachine> ddarius: hmm?
14:46:38 <ddarius> Or at least, it mightn't be.
14:46:45 <roconnor> ddarius: who says monad laws apply to non-total elements
14:46:47 <benmachine> x >>= return = x, is that not the case?
14:46:55 <ddarius> Actually, I misread that.
14:47:04 * quicksilver with roconnor. The laws don't work with _|_
14:47:14 <quicksilver> IO's not special in this respect either
14:47:21 <benmachine> hmph
14:47:29 <quicksilver> the state monad fails the monad law if you care about _|_
14:47:39 <quicksilver> due to the different between \_ -> _|_ and _|_
14:47:44 <ddarius> roconnor: They are equations in Haskell.  Haskell has _|_.
14:47:52 <quicksilver> I don't think it's the spirit of the laws to include that.
14:48:02 <benmachine> I think the laws should say if they have exceptions
14:48:13 <quicksilver> ddarius: they're equations on a subset of Haskell, up to a notion of observational equivalence.
14:49:26 <ddarius> quicksilver: I don't recall the Report saying anything like that at all.
14:49:35 <EvanR-work> > 3 * undefined
14:49:36 <lambdabot>   *Exception: Prelude.undefined
14:49:42 <EvanR-work> > [undefined]
14:49:43 <lambdabot>   [*Exception: Prelude.undefined
14:49:53 <EvanR-work> both are _|_ ?
14:49:58 <monochrom> No.
14:50:17 <benmachine> [undefined] =  (:) _|_ []
14:50:35 <mauke> > length [undefined]
14:50:36 <lambdabot>   1
14:50:37 <monochrom> [‚ä•] = (‚ä• : []).  quite usable and useful
14:50:48 <EvanR-work> ah
14:51:22 <EvanR-work> @src (*)
14:51:22 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:51:32 <kmc> > [undefined] `seq` ()
14:51:33 <lambdabot>   ()
14:51:39 <roconnor> ddarius: I don't think the H'98 report is at all clear what the domain of quantification is for the monad laws
14:51:45 <benmachine> quicksilver: did you have a particular counterexample in mind for State?
14:51:47 <roconnor> they are simply presented in equational form with free variables
14:52:17 <monochrom> (*) is a type class method. it's implementation for Int or Integer is understandably not very enlightening.
14:52:36 <hpc> roconnor: a reasonable domain would be the expected use case, perhaps?
14:52:39 <ddarius> roconnor: So we should automatically assume that they intended some unspecified subset of observational equality rather than the natural notion.  Furthermore, the laws lose some of their purpose when they don't hold.
14:52:49 <kmc> its implementation for Integer is a little interesting, actually
14:52:50 <EvanR-work> what other expressions are _|_, let bomb = 1:bomb in bomb ?
14:53:01 <benmachine> EvanR-work: nope, length bomb is though
14:53:04 <kmc> EvanR-work, nope, that one doesn't even have a ‚ä• anywhere in it
14:53:13 <roconnor> hpc ddarius: I find the natural notion to be the total elements of the domain in question
14:53:18 <kmc> EvanR-work, ‚ä• is anything where seq will throw an exception or never return
14:53:18 <EvanR-work> oh
14:53:37 <monochrom> > let notbomb = 1:notbomb in null notbomb
14:53:38 <lambdabot>   False
14:53:40 <kmc> (Just ‚ä•) is not ‚ä•.  but if you made ¬´data Foo a = Foo !a¬ª then (Foo ‚ä•) = ‚ä•
14:53:42 <ddarius> roconnor: "Here are some equation that don't have to hold.  In fact, just ignore them because they are meaningless."
14:53:43 <monochrom> does not bomb
14:53:48 <kmc> same if you had ¬´newtype Foo a = Foo a¬ª
14:53:57 <monochrom> > let notbomb = 1:notbomb in take 5 bomb
14:53:57 <lambdabot>   Not in scope: `bomb'
14:53:58 <roconnor> ddarius: holds for all total elements.
14:54:02 <monochrom> > let notbomb = 1:notbomb in take 5 notbomb
14:54:03 <lambdabot>   [1,1,1,1,1]
14:54:07 <EvanR-work> ah
14:54:07 <monochrom> works beautifully
14:54:19 <EvanR-work> so how can i define bomb besides undefined and arithmetic on undefined
14:54:27 <EvanR-work> length notbomb
14:54:40 <kmc> last notbomb
14:54:41 <monochrom> why do you want more ways to bomb?
14:54:42 <hpc> any strict operation on undefined
14:54:43 <benmachine> roconnor: the partial case is relevant sometimes
14:54:48 <EvanR-work> i want the coolest way
14:54:52 <hpc> or a strict operation on an infinite structure
14:54:53 <kmc> fix (1+)
14:54:59 <EvanR-work> nice
14:55:08 <benmachine> roconnor: in order to exist without FlexibleInstances, Text.Printf has to return undefined at the end
14:55:12 <monochrom> but anyway here is one: write a program to search for an odd perfect number.
14:55:16 <EvanR-work> hpc: 'a strict operation' is like a begging the question
14:55:22 <kmc> ¬´fix f¬ª is ‚ä• if f is strict
14:55:28 <kmc> by definition basically
14:55:50 <kmc> "f is strict" ‚áî "‚ä• is a fixed point of f"
14:55:56 <kmc> and fix finds the least fixed point
14:55:56 <roconnor> Indeed, I'd like the property that if main is a total program, the if I rewrite any subexpression of main with one of the laws, then main has the same value.
14:55:57 <monochrom> maybe it doesn't bomb but earns you a millenium prize instead
14:56:01 <hpc> EvanR-work: not really; strict is pretty unambiguous
14:56:05 <kmc> and ‚ä• is the bottom of the lattice of values, hence its name
14:56:11 <roconnor> this is weaker than laws holding for all values
14:56:17 <monochrom> coolest way to try to bomb and fail :)
14:56:20 <EvanR-work> can we accomplish it without strict primitives? yes, so last and length 'are strict' ?
14:56:31 <ddarius> roconnor: And completely useless if you are writing a library.
14:56:36 <roconnor> ddarius: is not
14:56:47 <roconnor> ddarius: ultimately your library is used in main
14:57:18 <monochrom> you need strictness to expose ‚ä•s
14:57:29 <ddarius> roconnor: Yes, but I can't apply those laws because I don't know if my input is non-bottom.  I guess I could pre-emptively force all my input.
14:57:29 <hpc> if you never evaluate bottom, you can't return it
14:57:52 <monochrom> notice that last and length use pattern matching. pattern matching is a strict primitive.
14:58:09 <roconnor> ddarius: well, if we have the property that I mentioned, then you can apply the laws with assurance that no working program using your library will break.
14:58:10 <hpc> weak-head strict, at least
14:58:28 <benmachine> roconnor: a working program might include bottom somewhere, but just where it's not evaluated
14:58:31 <roconnor> ddarius: that being said I don't know what is necessary for my property to hold, nor do I know if my property does hold for the IO/State monad laws
14:58:33 <EvanR-work> monochrom: ah
14:58:49 <roconnor> benmachine: I'm talking about the dentation of main.
14:58:49 <benmachine> roconnor: we might want the property that return undefined >> x = x
14:59:23 <hpc> benmachine: that property is automatic, isn't it?
14:59:29 <roconnor> benmachine: even if main has a subexperssion of undefined, doesn't mean the dentation of main will be non-total
14:59:48 <hpc> > return undefined >> 1
14:59:49 <lambdabot>   No instance for (GHC.Num.Num (m b))
14:59:49 <lambdabot>    arising from a use of `e_11' at <int...
14:59:51 <benmachine> hpc: only if the monad laws apply to partial elements
14:59:58 <hpc> > return undefined >> Just 1
14:59:59 <lambdabot>   Just 1
15:00:10 <monochrom> you may like (let x=x in x)
15:00:13 * EvanR-work needs to think more about weak head form
15:00:25 <EvanR-work> monochrom: ah
15:00:30 <EvanR-work> thats it
15:00:35 <hpc> weak head form is basically just "oh hey, we know which constructor was used"
15:00:45 <roconnor> benmachine: does the monad law for total element + continuity imply that return undefined >> x = x ?
15:00:46 <benmachine> roconnor: but if main is a total program, and then I replace some x in main with return undefined >> x, you're okay with that breaking?
15:00:58 <monochrom> "or else it's a (\x -> don't look inside)"
15:01:19 <benmachine> roconnor: total element + continuity?
15:01:54 <benmachine> roconnor: it's implied by return x >>= f = f x, if you think that applies for x = undefined too
15:01:54 <roconnor> benmachine: if we assume that the monad laws only hold for total elements, and we assume all functions are scott continuous, can we prove  return undefined >> x = x?
15:02:03 <benmachine> oh, no
15:02:06 <roconnor> benmachine: or do you have a counter example?
15:02:09 <EvanR-work> > let undefined = undefined in undefined
15:02:13 <lambdabot>   mueval-core: Time limit exceeded
15:02:35 <EvanR-work> bomb!
15:02:51 <EvanR-work> the mystic power of haskell
15:02:54 <benmachine> roconnor: I don't know what scott continuity is >_>
15:03:05 <EvanR-work> use it wisely grasshopper
15:03:07 <roconnor> benmachine: ah well, then.
15:03:26 <roconnor> benmachine: let us continue our discussion of domain theory when you do.
15:03:34 <sipa> @let undefined = undefined
15:03:34 <lambdabot>  <local>:1:12:
15:03:34 <lambdabot>      Ambiguous occurrence `undefined'
15:03:35 <lambdabot>      It could refer to e...
15:03:48 <benmachine> bah
15:04:03 <EvanR-work> does pattern match failure count as _|_
15:04:04 <monochrom> scott continuity = the usual continuity? f is continuous = f commutes with directed joins?
15:04:32 <benmachine> monochrom: wikipedia says something like that. but then I have to read the page about directed joins, too
15:04:34 <sipa> this channel is horrible
15:04:46 <sipa> it makes me realize how much i don't know/understand!
15:05:03 <L29Ah> > (\(x:xs) -> xs) []
15:05:04 <lambdabot>   *Exception: <interactive>:1:130-142: Non-exhaustive patterns in lambda
15:05:11 <benmachine> sipa: being confused is part of the joy of life
15:05:12 <hpc> sipa: you misspelled "awesome" :P
15:05:16 <monochrom> simplified version of "directed joins" is "joins of chains".
15:05:20 <ddarius> benmachine: Basically, all it means is that you can't solve the halting problem, i.e. you can't "pattern match" on bottom (and return non-bottom).
15:05:25 <L29Ah> > (\a@(x:xs) -> if null a then [] else xs) []
15:05:26 <lambdabot>   *Exception: <interactive>:1:134-171: Non-exhaustive patterns in lambda
15:05:34 <benmachine> ddarius: oh, I thought that was monotonicity
15:05:36 <L29Ah> > (\a@~(x:xs) -> if null a then [] else xs) []
15:05:37 <lambdabot>   <no location info>: parse error on input `@~'
15:05:39 <L29Ah> ;[
15:05:48 <mauke> > (\a@ ~(x:xs) -> if null a then [] else xs) []
15:05:49 <lambdabot>   []
15:06:12 <hpc> what do @ and ~ do?
15:06:15 <kmc> EvanR-work, yes, pattern-match failure throws an exception
15:06:21 <kmc> EvanR-work, except not in "do" or list comprehensions
15:06:30 <L29Ah> > (\~a@(x:xs) -> if null a then [] else xs) []
15:06:31 <lambdabot>   <no location info>: parse error on input `->'
15:06:31 <kmc> hpc, x@p matches the same things as p, but also binds x to the whole thing matched
15:06:41 <L29Ah> > (\~(a@(x:xs)) -> if null a then [] else xs) []
15:06:41 <lambdabot>   <no location info>: parse error on input `->'
15:06:46 * L29Ah sucks
15:06:56 <hpc> ~ is the incontrovertible match, or something like that
15:06:56 <mauke> L29Ah: you should learn about spaces, they're great
15:07:06 <kmc> hpc, ~p is like p, but always succeeds and doesn't actually force anything.  the arg is only forced once one of the variables is used, at which point if you guessed the wrong constructor, it's a runtime exception
15:07:13 <monochrom> space, the final frontier
15:07:14 <L29Ah> where should i've put spaces there?
15:07:16 <kmc> it's an irrefutable pattern
15:07:17 <benmachine> hpc: there's a good wiki page for stuff like this
15:07:22 <kmc> basically works the way pattern matching in "let" works
15:07:22 <mauke> L29Ah: between \ and ~
15:07:22 <benmachine> buggered if I can find it though
15:07:27 <hpc> i knew ~, but forgot
15:07:27 <kmc> > let Just x = Nothing in ()
15:07:28 <lambdabot>   ()
15:07:31 <L29Ah> > (\ ~(a@(x:xs)) -> if null a then [] else xs) []
15:07:32 <lambdabot>   *Exception: <interactive>:1:134-175: Irrefutable pattern failed for pattern...
15:07:32 <kmc> > case Nothing of Just x -> ()
15:07:33 <lambdabot>   *Exception: <interactive>:1:133-160: Non-exhaustive patterns in case
15:07:34 <mjrosenb> so is the failure that is thrown by a match failure something that can be caught?
15:07:36 <hpc> didn't know @ was different though
15:07:38 <kmc> > case Nothing of ~(Just x) -> ()
15:07:39 <lambdabot>   ()
15:07:41 <kmc> mjrosenb, in IO, yes
15:07:48 <kmc> i think all exceptions can be caught
15:07:58 <mjrosenb> and they are all in IO?
15:08:10 <kmc> data PatternMatchFail = PatternMatchFail String
15:08:28 <kmc> mjrosenb, catching is always in IO, unless you cheat and use 'spoon'
15:08:29 <benmachine> hpc: http://haskell.org/haskellwiki/Keywords
15:08:36 * mjrosenb knows that sml's exceptions *feel* a whole lot more sane than what I have seen from haske''l so far.
15:08:42 <hpc> benmachine: ooh, good stuff
15:08:58 <mjrosenb> *haskell's
15:09:00 <sipa> @type catch
15:09:01 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
15:09:02 <kmc> it's in IO because it can observe evaluation order
15:10:09 <hpc> ooh, pattern guards
15:10:14 <kmc> (GHC) Haskell's exceptions are pretty sane if you use them only as part of the IO mini-language
15:10:23 <kmc> even the extensible exceptions
15:10:38 <kmc> it's when you start wanting to throw exceptions on evaluation, rather than execution, that it gets messy
15:10:47 <kmc> and even messier if you have threads asynchronously throwing exceptions at each other
15:12:07 <hpc> those are well beyond the situations where exceptions are optimal though
15:12:33 <mjrosenb> bug exceptions are just values
15:12:37 <mjrosenb> *but
15:12:55 <mjrosenb> and they can be used in other contexts, not just being thrown, right?
15:13:43 <solidsnack> kmc: `spoon'?
15:13:56 <anshul> edwardk : Thanks for your help yesterday! I was able to solve my graph transpose problem quite easily after that.
15:13:58 <kmc> @hackage spoon
15:13:58 <lambdabot> http://hackage.haskell.org/package/spoon
15:14:08 <ddarius> benmachine: Well, Scott continuity also says we preserve the iterative fixpoint construction.  Scott continuity implies monotonicity.
15:14:36 <sinelaw> edwardk, hey
15:14:49 <solidsnack> Wow. Neat.
15:15:01 <solidsnack> I have always wanted spoon.
15:15:13 <ddarius> benmachine: That aspect is not particularly relevant for the given example though, though it could be for a potential counter-example.
15:15:13 <kmc> if you wanted it for 'read', there's a better wap
15:15:15 <kmc> way*
15:15:32 <solidsnack> kmc: Use `reads'?
15:15:49 <kmc> yeah
15:15:57 <sinelaw> edwardk, I was wondering the other day if you have any practical experience with wavelets
15:16:00 <solidsnack> Why is it better?
15:16:05 <kmc> 'spoon' is one of those libraries which cheats the system and has somewhat dodgy semantics
15:16:10 <ddarius> At any rate, roconnor's equation simply can't be simplified without allowing the monad laws on undefined elements or giving a definition of return and (>>=).
15:16:13 <solidsnack> kmc: Oh.
15:16:28 <solidsnack> Dodgy?
15:16:28 <kmc> using reads is simpler conceptually, less semantically dubious, probably faster
15:16:37 <kmc> yes, read the source
15:16:39 <kmc> http://hackage.haskell.org/packages/archive/spoon/0.3/doc/html/src/Control-Spoon.html
15:16:41 <blackcustard> > 1 / (0 :: Float)
15:16:42 <lambdabot>   Infinity
15:16:48 <blackcustard> > 1 / (0 :: Int)
15:16:48 <djahandarie> Oh god not this again
15:16:49 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
15:16:49 <lambdabot>    arising from a use o...
15:17:09 <solidsnack> Hmmm, yes.
15:17:12 <solidsnack> Dodgy.
15:17:44 <blackcustard> okay, well, that explains how i get "arithmatic overflow" exceptions from divisions by zero XD
15:17:53 <edwardk> sinelaw: i used to use haar wavelets to compress textures. have done some work with chirplets and there is some really old daubechies wavelet code of mine floating around on the web
15:17:53 <blackcustard> will simplify debugging greatly
15:18:19 <solidsnack> kmc: Actually, it doesn't seem so bad.
15:18:32 <edwardk> sinelaw: what do you need to know?
15:18:59 <sinelaw> edwardk, i'm trying to do musical instrument classification
15:19:00 <solidsnack> It calls unsafePerformIO, always concerning, but the type constraint is such that you can't get away with much.
15:19:01 <kmc> solidsnack, there's the unsafePerformIO part and the "needing to know how far to force something to hit an error" part
15:19:09 <kmc> and the "ad hoc list of exceptions we consider pure" part
15:19:42 <sinelaw> edwardk, and to do it in haskell. 
15:19:44 <solidsnack> kmc: Well, to be fair, that is also "ad hoc list of exceptions people put in pure stuff".
15:19:48 <edwardk> sinelaw: fair enough. so thinking of using wavelets to avoid having to play annoying short time fourier transform games?
15:19:57 <sinelaw> edwardk, right
15:20:07 <solidsnack> kmc: I agree that `teaspoon' is rather dubious.
15:20:11 <sinelaw> edwardk, i'll still need to extract some sort of feature vector from that
15:20:36 <solidsnack> Why there isn't a `reads' that returns a Maybe is beyond me.
15:20:38 <kmc> why is teaspoon more dodgy?
15:21:02 <edwardk> you may have better luck doing the short time fourier transform stuff, but instead using the fft(log(fft ...)) trick to approximate the z transform so you get something in mel frequency cepstral coefficients instead, that transforms to better correspond to human hearing anyways
15:21:06 <kmc> it's implemented in some random places like http://hackage.haskell.org/packages/archive/applicative-extras/0.1.6/doc/html/Control-Applicative-Error.html solidsnack
15:21:50 <solidsnack> kmc: `teaspoon' would seem to be less consistent in practice since it doesn't force all the way.
15:21:51 <edwardk> the reason is that that tends to give rise to a nice feature vector for each window, because you can break that up into cocheal bands and capture each as an entry in your vector
15:22:06 <edwardk> window-size might be tricky to calculate though
15:22:13 <kmc> solidsnack, it's deterministic either way
15:22:28 <kmc> 'spoon' is a lot more expensive
15:22:36 <kmc> maybe you have a function which either errors out or returns an infinite list
15:22:39 <kmc> can't use 'spoon' then
15:23:03 <solidsnack> kmc: Fair enough.
15:23:07 <sinelaw> edwardk, i've considered that. the window size thing is a pain
15:23:41 <solidsnack> kmc: I don't think of these as tools for buiding on, though. It seems like a way to wrap a few dirty bits.
15:23:47 <kmc> yeah
15:23:48 <edwardk> sinelaw: the wavelet bit at least avoids the need for a magic window size
15:23:49 <sinelaw> edwardk, i can just play with that and find what gives good results. i didn't get how you suggested getting a feature vector though
15:23:58 <kmc> it's semantically dubious, but still useful ;P
15:24:02 <solidsnack> If you force a floating point multiply or a read all the way to the bottom, who cares?
15:24:21 <solidsnack> If you're not forcing all the way to the bottom I have to ask, what are you doing?
15:24:41 <kmc> if you know an exception would be at the head
15:24:42 <sinelaw> edwardk, i've read about using statistical properties of each subband as entries in that vector
15:24:45 <kmc> then teaspoon is a lot faster
15:24:54 <sinelaw> edwardk, such as mean, variance, power, etc...
15:25:00 <solidsnack> kmc: If there's enough structure to make a difference, yes.
15:25:05 <sinelaw> well, variance and power are the same :)
15:25:19 <edwardk> when working with audio i usually use the real  Z transform to extract Mel frequency scale cepstral coefficients. the complex Z transform can be a bit of a pain in the butt, but the real analogue is actually fairly easy to calculate (up to a scale invariant)
15:25:39 <solidsnack> kmc: I think it is a little scary that if you're using a library that generates a list and also calls "error".
15:26:00 <solidsnack> s/that if/if/
15:26:02 <edwardk> just fft, take the log of the entries and fft again, the results have the same magnitude as results from the z transform
15:26:10 <kmc> yeah, but it happens.  we agree this is a pragmatic tool for fixing bad decisions by others, but you draw the line there?
15:26:35 <edwardk> which if you view the fft as transforming convolution to multiplication the z transform maps convolution onto addition. (though the real z transform is non-invertible)
15:26:36 <kmc> > tail []
15:26:37 <lambdabot>   *Exception: Prelude.tail: empty list
15:26:38 <kmc> > tail [1..]
15:26:39 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
15:26:43 <kmc> returns a list, throws an exception
15:26:56 <kmc> obviously there's a better way to write "safeTail" than using teaspoon
15:27:06 <sinelaw> edwardk, hmm. i'll look into that
15:27:12 <kmc> but these sorts of functions are not rare
15:27:13 <solidsnack> kmc: There is an even better way using pattern matching.
15:27:22 <edwardk> the nice thing about the z transformed values is that they have the same perceptual falloff that the mel frequency scale does at least above 500 hz, where it goes logarithmic
15:27:39 <solidsnack> Whereas, writing `safeRead' seems tough.
15:27:43 <sinelaw> edwardk, what do you suggest for the final feature vector? and how would you classify?
15:27:59 <benmachine> solidsnack: see: reads
15:28:11 <solidsnack> benmachine: Yes, I've seen it.
15:28:23 <solidsnack> It doesn't use `read'.
15:28:26 <benmachine> no
15:28:32 <benmachine> vice versa
15:28:36 <solidsnack> Right.
15:29:05 <benmachine> ...so you can write safeRead with reads
15:29:10 <benmachine> no?
15:29:15 <solidsnack> benmachine: Right.
15:29:43 * benmachine confused but has only himself to blame
15:29:43 <solidsnack> Say you don't have `reads'. You have to write `safeRead' with `read'. Now you might think, `spoon' is pretty nice.
15:29:48 <benmachine> ah
15:30:16 <benmachine> hmm
15:30:26 <edwardk> then you can use a psycho-acoustical model. human hearing through the cochlea is broken up into bands, you hear the loudest stimulus in each band. this is how mp3s etc compress, they fft, and toss away smaller stimuli in each band, so a good model is to just band together runs of coefficients and sum them up say from the transformed equivalent of 40 hz to 20000 hz, just evenly dividing the mel frequency coefficients into equally siz
15:30:29 <solidsnack> Whereas, you have to write `safeTail' with `tail'. I would be shocked to find a data structure library that doesn't make htat easy.
15:30:55 <edwardk> this gives me say 12 coefficients, then take the 12 deltas from each window to the previous window, this will help you judge stops, etc.
15:30:58 <kmc> say you cherry-pick an alternate universe, then you can win any argument
15:31:07 <edwardk> that has worked well for me for doing things like speech recognition, etc.
15:31:14 <solidsnack> kmc: Oh!
15:31:32 <sipa> :t safeTail
15:31:33 <lambdabot> Not in scope: `safeTail'
15:31:59 <benmachine> safeTail = drop 1 >_>
15:32:31 * ddarius cherry-picks a universe where he doesn't get into arguments.
15:32:39 <solidsnack> Well. I think if you use `spoon' and it costs the same as using `teaspoon', then both are okay. If they cost different amounts then neither is okay.
15:32:46 <kmc> hehe
15:32:49 <kmc> a baffling position to take
15:32:57 <kmc> but i don't care enough to continue debating it
15:33:02 <kmc> sorry
15:33:06 <solidsnack> Okay.
15:33:40 <ddarius> If you don't need to use spoon, don't use it.  If you need to use it, don't use it and give the library author a patch.
15:33:40 <solidsnack> I think I will probably never use it but thank you for pointing me to it; it's an interesting idea.
15:33:41 <edwardk> sinelaw: another option is to just use something like a daubechies wavelet, but without transforming into a perceptual Mel frequency-like space you'll probably not make the most efficient use of your wavelet
15:34:12 <edwardk> sinelaw: i haven't given much thought to what that perceptual weighting would transform to in that problem domain though
15:34:24 * ddarius has actually been looking at "wavelet packets" that are grouped into "musical" bands.
15:34:39 <ddarius> (It ceases to be a wavelet packet, technically, at that point though.)
15:34:55 <edwardk> ddarius: hrmm
15:36:18 <ddarius> Google Desktop is a waste of my time.
15:37:15 <sinelaw> edwardk, from my limited understanding the wavelet transform already gives a perceptually matched result because of the logarithmic scale resolution ?
15:38:19 <edwardk> sinelaw: not used to using them in 1d, working through the details now
15:38:23 <ddarius> @google Best time localized trigonometric polynomials and wavelets
15:38:27 <lambdabot> http://www.ingentaconnect.com/content/klu/acom/2005/00000022/00000001/00007411
15:38:27 <lambdabot> Title: ingentaconnect Best time localized trigonometric polynomials and wavelets
15:39:01 <ddarius> sinelaw: It will be better than the plain FFT.
15:39:02 <edwardk> sinelaw: but that is quite plausible
15:39:10 <McManiaC> haskell autocompletition in emacs - what do you guys?
15:40:18 <blackcustard> trig with fixed precision is :( ... guess i've had too much non-applied math
15:40:39 <sinelaw> another problem is how to find the envelopes that contain the part we want to classify
15:41:15 <sinelaw> but in my case simple power thresholds will be ok, because there will be only one instrument playing
15:41:28 <edwardk> sinelaw: yes, of course you are right (w.r.t. perceptual matching)
15:41:58 <sinelaw> edwardk, ah good, at least i got something from all those introductory papers 
15:42:17 <edwardk> sinelaw: have you seen the stuff already done in this space?
15:42:35 <sinelaw> edwardk, yes, one sec
15:42:50 <edwardk> http://www.sea-acustica.es/Sevilla02/mus01007.pdf etc
15:43:26 <sinelaw> @google WAVELET ANALYSIS IN MUSICAL INSTRUMENT SOUND CLASSIFICATION
15:43:29 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
15:43:40 <sinelaw> thanks, lambdabot 
15:43:49 <hpc> maybe that was the first result :P
15:43:56 <sinelaw> http://ieeexplore.ieee.org/iel5/10550/33373/01580181.pdf
15:44:14 <edwardk> gah, no ieee access
15:45:16 <sinelaw> the one you found looks just as good though
15:45:37 <sinelaw> edwardk, what do you use for classification?
15:45:48 <edwardk> sinelaw: i like gaussian mixture models
15:46:18 <sinelaw> i'll have to read about that
15:46:26 <sinelaw> i know a bit about neural networks
15:46:36 <sinelaw> but not much more than that
15:46:40 <edwardk> meh
15:46:50 <c_wraith> is there any native-haskell implementation of crypt?
15:47:05 <c_wraith> yes, it sucks, but...  backwards compatibility
15:47:06 <edwardk> most people employee neural networks as a bad approximation of better statistical tools when they don't know about the tools =)
15:47:31 <ddarius> Viva ignorance
15:47:34 <sinelaw> edwardk, is this thing a sort of "we assume the data is a mixture of gaussians, let's find their parameters?"
15:47:45 <edwardk> sinelaw: https://dspace.emich.edu:8443/dspace/handle/1970/98 -- if it ever opens
15:48:21 <ddarius> edwardk: One of the papers you had to write.
15:48:23 <sinelaw> edwardk, actually i have a really thorough book about nn's, i should be pretty aware of their limitations if i remember something
15:48:34 <edwardk> sinelaw: something i wrote very quickly on the topic of using guassian mixture models and mel frequency cepstral coefficients to automatically lip-sync 3d actors to audio streams in realtime
15:49:01 <sinelaw> edwardk, ah thanks :)
15:49:31 <sinelaw> bah my internet is choppy
15:50:42 <c_wraith> holy crap, I just looked at *how* bad crypt is, again.  That's really terrifying.
15:50:58 <edwardk> ddarius: yeah. i needed an honors thesis for a statistics class
15:50:59 * c_wraith grumbles about people who used it and want it to keep working
15:51:47 <edwardk> ddarius: and when i shopped around the only company that was selling real-time lipsync code was selling it for a floor of $20k a pop, so i figured i'd steal his market.
15:52:41 <sinelaw> edwardk, what if my data isn't guassian
15:52:56 <sinelaw> (i'll read more in depth about gmm later)
15:53:18 <sipa> almost every sum of independent statistical variables converges to a gaussian
15:53:31 <ddarius> sinelaw: Your data not "being" Gaussian means you have more data than just it's mean and variance.
15:53:55 <edwardk> sinelaw: the idea of the gmm is that you use it to figure out kind of roughly where in feature space each of the things you are looking for is, and how in each of those directions it stretches out.
15:54:01 <sinelaw> right sipa, but in this case there is some not-so-random stuff that affects the data
15:54:20 <sipa> and probably lots of not-so-independent thing as well
15:55:04 <edwardk> sinelaw: then you can train the model with known data, and just use the mahalanobis distance to the distribution as a scoring function
15:55:30 <sinelaw> edwardk, do you know how this relates to maximum likelihood?
15:56:13 <edwardk> sinelaw: btw- i pulled up the paper by googling 'mahalanobis lip-sync' and used google quick view to pull it up
15:56:19 <edwardk> i apologize for the terrible formatting
15:56:35 <edwardk> i had a brief fling with trying to lay out equations and papers using html and mathml at the time ;)
15:57:52 <edwardk> (and for the linguists in the audience, almost every occurence of the word 'phoneme' in the paper should be 'phone')
15:57:56 <ray> mmm inline mathml and svg
15:58:05 <kmc> phonon!
15:58:23 <ray> too bad you have to use xhtml to get either of those
15:58:42 <ddarius> "In particular, a special differential-difference operator is constructed which plays the role of a generalized root of the radial Laplacian."  *sigh*
15:59:09 <sinelaw> heh, maybe i shouldn't even try to download it 
15:59:18 <edwardk> sinelaw: the way i mentioned above works
15:59:31 <edwardk> i think eastern's dspace system is fubared
16:01:01 <sinelaw> right, got it now
16:01:56 <sinelaw> edwardk, ok i have a lot to think about
16:01:58 <sinelaw> and to try
16:02:05 <sinelaw> so thanks 
16:02:15 <edwardk> sinelaw: good luck =)
16:05:38 <gwern> edwardk: did you steal his market? at 20k, you could undersell him by 50% and with just a few customers make a living
16:06:22 <Axman6> so, looks like 10.7 will be OS X Lion
16:06:39 <Zao> Mmh, loin.
16:06:42 <edwardk> gwern: i actually did license it out as a side project
16:06:46 * sipa wonders when OSX Cat will be the next...
16:06:56 <edwardk> gwern: i used to license out a lot of hard-to-write middleware like that
16:07:20 <gwern> edwardk: used to? you are now independently wealthy and disdain such plebian work? :)
16:08:14 <edwardk> gwern: it takes a lot of time to manage those contacts and to push this sort of thing. nowadays folks know where to find me and usually just contact me directly if they need something =P
16:08:50 <Axman6> whoops, wrong chen, heh
16:08:52 <Axman6> chan*
16:11:42 <ddarius> edwardk's goal is to break the world record for times being independently wealthy.
16:12:28 <EvanR> learn haskell -> be edwardk -> ??? -> profit
16:12:33 <gwern> ddarius: haha. what's his vice, gambling on termination times of random turing machines?
16:12:45 <gwern> 'come on lucky 227 seconds! come to papa!'
16:13:34 <benmachine> what happens if you bet non-terminating
16:13:43 <kmc> haha
16:14:02 <edwardk> ddarius: yeah i just hope to end this game with the number of times being independently wealthy exceeding the number of times being broke ;) preferrably not only in peak/valley count, but also in the amount of time at peak vs. valley =)
16:14:09 <gwern> benmachine: oh, that's the house's edge
16:14:13 <EvanR> the casino uses a hypercomputer with lots of flashing lights to tell you if you won
16:14:22 <ray> you get your winnings on loan but have to pay back with interest if it ever terminates
16:14:32 <benmachine> heh
16:14:39 <gwern> benmachine: you see, you pay in advance, and the casino holds onto it as long as it runs, so...
16:14:46 <benmachine> gwern: :P
16:15:07 <ray> i invented a fair game not a casino game
16:15:25 <ddarius> ray: Now you know not to run a casino.
16:16:13 <ray> i know to only use time-tested casino games
16:16:18 <ray> and not invent my own
16:16:31 <kmc> you can run a casino where people play fair games against each other, and you just openly take a cut
16:16:44 <ray> yes this is what the poker tables are
16:16:44 <benmachine> hmm
16:16:50 <EvanR> gwern did you just make up that game?
16:16:50 <EvanR> because i think it could work
16:16:50 * EvanR patents it
16:17:07 <gwern> EvanR: of course I made it up
16:17:16 <EvanR> i mean it hasnt been implemented yet
16:17:19 * benmachine runs a roulette wheel where everyone gives me ¬£38 and I give them back ¬£36
16:17:23 <benmachine> seems fair to me
16:17:31 <gwern> what casino's clientele could be geeky enough to possibly support such a game?
16:17:34 <EvanR> benmachine: rent ;)
16:17:51 <EvanR> gwern: use a skin ;)
16:18:11 <benmachine> do "most" small turing machines terminate?
16:18:23 <benmachine> I only say small because obviously we have no idea for larger ones
16:18:45 <EvanR> and wed obviously use medium size to large for the real deal
16:19:13 <EvanR> simulation speed increases exponentially
16:19:34 <EvanR> to build suspense
16:19:35 <ray> you could ask the question about turing machines in general
16:19:51 <gwern> ray: chaitin's omega is uncomputable...
16:21:05 <Saizan> benmachine: there should be a paper somewhere with a prefix of chaitin's constant
16:21:11 <ray> so are most of the reals, but you can say "most of the reals" in the beginning of this sentence
16:23:18 <gwern> Saizan: iirc, the longest known prefix is 30 or 40 digits
16:24:18 <EvanR> brachiels quit message... what does it mean!
16:25:46 <tomh> guys, if I have a function like this: test :: (Alternative m) => m (List ([Char], [Char])), how can I tell it what m is?
16:25:59 <kmc> when you call it?
16:26:02 <gwern> @oeis 3, 7, 15, 1, 292
16:26:03 <lambdabot>  Continued fraction expansion of Pi.
16:26:03 <lambdabot>  [3,7,15,1,292,1,1,1,2,1,3,1,14,2,1,1,2,2,2,2,1,84,2,1,1,15,3,13,1,4,2,6,6,99...
16:26:09 <tomh> kmc how?
16:26:10 <gwern> EvanR: ^
16:26:12 <EvanR> oh
16:26:19 <kmc> test :: Maybe (List ([Char], [Char]))
16:26:20 <sipa> gwern: i was wondering about the same
16:26:26 <kmc> also that's not a function tomh
16:26:36 <tomh> eh yeah its a type signature
16:26:41 <kmc> no i mean, test isn't  function
16:26:48 <kmc> if it were a function, it would have -> in its type
16:26:50 <tomh> whats the proper definition?
16:26:53 <tomh> variable?
16:26:54 <EvanR> CAF
16:26:59 <kmc> it's a value
16:27:06 <kmc> functions are values, but not all values are functions
16:27:13 <kmc> anyway
16:27:20 <tomh> ah ok
16:27:22 <kmc> you don't generally need to fill in those type variables
16:27:25 <kmc> only if there's ambiguity
16:27:39 <kmc> if you take 'test' and pattern-match against (Just x)
16:27:42 <kmc> then it knows Maybe
16:27:44 <enthropy> kmc: does Alternative has instances involving ->  ?
16:27:50 <kmc> enthropy, none that i know of
16:28:01 <enthropy> @src Alternative
16:28:02 <lambdabot> class Applicative f => Alternative f where
16:28:02 <lambdabot>     empty :: f a
16:28:02 <lambdabot>     (<|>) :: f a -> f a -> f a
16:29:41 <enthropy> kmc: you could have one for    Alternative m => Kleisli m r, no?
16:30:00 <tomh> kmc: thanks that was the missing knowledge :)
16:32:25 <kmc> tomh, type inference is generally pretty smart and most potential ambiguity will just go away
16:32:47 <tomh> ok
16:32:54 <mm_freak> > let listA = foldr (<|>) empty in listA [1..10]
16:32:55 <lambdabot>   Ambiguous occurrence `empty'
16:32:55 <lambdabot>  It could refer to either `Control.Applicative...
16:33:53 <mm_freak> btw, that's a boilerplate function i used to write all the time, before i wrote a library
16:34:24 <kmc> :t asum
16:34:24 <lambdabot> Not in scope: `asum'
16:34:38 <deteego> assuming you have [(3, True, "cheese"),(4, False, "hello"),(2, True, "rawr")]
16:34:41 <kmc> :t Data.Foldable.asum
16:34:42 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Foldable.Foldable t, Alternative f) => t (f a) -> f a
16:34:47 <deteego> what is the easiest way to do this
16:34:53 <deteego> ([3,4,2],[True, False, True],["cheese","hello","rawr"])
16:35:04 <kmc> :t unzip
16:35:05 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
16:35:07 <kmc> :t unzip3
16:35:08 <lambdabot> forall a b c. [(a, b, c)] -> ([a], [b], [c])
16:35:21 <deteego> thanks
16:36:30 <mm_freak> kmc: ah, thanks
16:39:18 <EvanR> this exercise is telling me to define a Functor instance for the function type ((->) t), ive never messed with a type of this form. what are the constructors?
16:39:32 <mauke> EvanR: none
16:39:43 <mauke> well, lambda, sort of
16:39:48 <mauke> but it's not an algebraic type
16:39:53 <EvanR> oh
16:39:59 <EvanR> so just a variable
16:40:04 <benmachine> yes
16:40:08 <benmachine> you can't pattern-match functions
16:40:16 <kmc> (a -> b) is ((->) a b)
16:40:22 <sioraiocht> it helps to look at the types
16:40:26 <kmc> so ((->) a) is a partial application of the type constructor (->)
16:40:28 <benmachine> (except inasmuch as plain variables are patterns)
16:41:06 <sioraiocht> :t fmap
16:41:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:41:13 <EvanR> yes working through it now
16:41:14 <sioraiocht> so for (-> t)
16:41:31 <sioraiocht> (a -> b) -> (-> t) a -> (-> t) b
16:41:51 <kmc> by (-> t) do you mean ((->) t)?
16:41:57 <sioraiocht> kmc: sorry, yes
16:42:00 <kmc> (-> t) suggests a section which is not legal Haskell
16:42:01 <sioraiocht> big difference
16:42:06 <sioraiocht> aye
16:42:13 <kmc> ((->) t) would be (t ->)
16:42:31 <sioraiocht> (a -> b) -> (t -> a) -> (t -> b)
16:43:06 <sioraiocht> so what function has that type, EvanR?
16:43:16 <EvanR> yes im looking at ((->) t) as \x -> (t -> x)
16:43:26 <EvanR> shush im thinking
16:43:29 <sioraiocht> sorry
16:43:31 <sioraiocht> was trying to help you ;)
16:43:39 <identity> Hmm -- so I wrote a wrapper around Chan and I'm unsure if it's synchronizing properly. Do you guys have any suggestions on how to test this? These challenges always get harder when it comes to multi-threaded programming
16:43:40 <EvanR> yes i think im on the right track now
16:43:49 <EvanR> annoying i already know the answer i think
16:43:51 <sioraiocht> btw, there's a lambabot quote from me on thsi very subject =p
16:44:09 <kmc> identity, spawn a bunch of threads and have them do stuff to it with random delays?
16:44:12 <kmc> what's your wrapper do?
16:44:24 <kmc> randomized testing is kind of insufficient for multithreaded stuff though :/
16:44:49 <ddarius> Model check it.
16:44:57 <identity> kmc: Basically count the elements that are put into it and disallow input when the queue contains a certain amount of elements
16:45:04 <identity> until it reaches a certain threshold again
16:45:10 * ddarius needs to buy a backup violin bow.
16:45:56 <identity> E.g. when it reaches full, elements have to be consumed until a certain number is left before elements can be put back in it
16:47:08 <EvanR> fmap :: (a->b) -> (t->a) -> (t->b)
16:47:19 <EvanR> fmap x y = x . y
16:47:33 <EvanR> hmms
16:47:39 <sioraiocht> w00t
16:47:50 <benmachine> id . y = id y
16:47:50 <sioraiocht> @quote sioraiocht
16:47:51 <lambdabot> sioraiocht says: [after fmap = (.)] omg; my life is much happier now
16:48:20 <EvanR> how does this help?
16:48:28 <benmachine> where 'this' is?
16:48:33 <benmachine> er
16:48:34 <ddarius> > (id . undefined) `seq` ()
16:48:35 <lambdabot>   Ambiguous type variable `f' in the constraint:
16:48:35 <lambdabot>    `GHC.Base.Functor f'
16:48:35 <lambdabot>     ...
16:48:37 <benmachine> where 'this' is... ?
16:48:38 <EvanR> Functor instance of ((->) t)
16:48:43 <benmachine> oh
16:48:55 <sioraiocht> I mean, I'm not sure it *helps*
16:49:05 <benmachine> it allows you to do neat things
16:49:21 <benmachine> > (||) <$> null <*> null . drop 1 $ [1]
16:49:22 <lambdabot>   True
16:49:26 <sioraiocht> WAH
16:49:46 <benmachine> uh
16:49:48 <EvanR> im not to applicative yet
16:49:51 <benmachine> that example is silly ignore it
16:49:53 <EvanR> if thats what that is
16:49:54 <sioraiocht> ha
16:49:56 <sioraiocht> yes it s
16:49:58 <benmachine> EvanR: it's a mixture
16:50:01 <benmachine> <$> is Functor
16:50:10 <sioraiocht> :t <$>
16:50:11 <lambdabot> parse error on input `<$>'
16:50:12 <benmachine> but anyway, you need Functor for Applicative
16:50:16 <sioraiocht> :t (<$>)
16:50:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:50:19 <sioraiocht> huh
16:50:24 <benmachine> sioraiocht: it's fmap
16:50:28 <sioraiocht> tht's just fmap in different clothing
16:50:29 <sioraiocht> ah yes
16:50:30 <benmachine> but operatorised
16:50:59 * sioraiocht wants infix operators
16:51:18 <benmachine> sioraiocht: um, you already have them? :P
16:51:28 <sioraiocht> sorry, mixfix
16:51:31 <benmachine> oh
16:51:32 <sioraiocht> is I think what I mean to sa
16:51:37 <benmachine> go learn agda
16:51:50 <sioraiocht> I can finish degree first?
16:52:06 <benmachine> no do it now
16:52:19 <sioraiocht> actually, wha tI am going to do NOW
16:52:23 <sioraiocht> as in "at this moment"
16:52:25 <sioraiocht> is go to sleep
16:52:29 <benmachine> good idea
16:52:33 * benmachine doesn't do enough of that
16:52:37 <sioraiocht> meeeeee neither
16:52:38 <sioraiocht> night!
16:52:45 <EvanR> waaaaht
16:52:50 <EvanR> @src Functor
16:52:50 <lambdabot> class  Functor f  where
16:52:50 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
16:52:55 <sioraiocht> yes?
16:53:00 <EvanR> and (<$)
16:53:19 <benmachine> EvanR: (<$) is only there for optimisation purposes
16:53:23 <benmachine> it is equal to fmap . const
16:53:25 <sioraiocht> :t (<$)
16:53:26 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
16:53:32 <sioraiocht> oh that's irritating
16:53:46 <EvanR> fmap . const
16:54:02 <kmc> (<$) is there for nicer syntax i think
16:54:07 <kmc> more uniform with the rest of Applicative
16:54:13 <benmachine> kmc: yes but it's a class method now, is the complaint
16:54:19 <kmc> ahh
16:54:27 <kmc> yeah, like (>>) for Monad
16:54:31 <benmachine> mm
16:54:35 <EvanR> and fail 
16:54:35 <EvanR> ;)
16:54:50 <benmachine> no fail is different
16:54:55 * EvanR opens up that can
16:55:49 <EvanR> so Functor doesnt have anything to it
16:55:53 <EvanR> except fmap
16:55:56 <EvanR> no 'utilities' no nothing
16:55:56 <mauke> yes
16:56:02 <mauke> Functor is nice and simple
16:56:09 <mauke> a class just for map
16:57:04 <EvanR> Monad comes with a lot of stuff, forever, replicateM, when...
16:58:58 <EvanR> is instance Functor Either e where fmap _ (Left e) = Left e; fmap f (Right x) = Right (f x)
16:59:21 <mauke> that looks right
16:59:31 <mauke> except for the missing ( )
16:59:44 <EvanR> where
16:59:55 <EvanR> Functor (Either e)
17:00:03 <mauke> yeah
17:00:06 <EvanR> question what is the e for?
17:00:15 <mauke> @src Either
17:00:15 <lambdabot> Source not found. You untyped fool!
17:00:28 <mauke> data Either a b = Left a | Right b
17:00:32 <EvanR> in the above does it have anypurpose but to fill that place?
17:00:46 <kmc> EvanR, Either has the wrong kind for Functor
17:00:49 <kmc> (Either e) has the right kind
17:00:56 <EvanR> its not really used in fmap definition right
17:01:08 <kmc> type variables typically aren't in scope
17:01:13 <mauke> you're telling the compiler that for all types e, Either e is a Functor
17:01:18 <EvanR> ok
17:01:22 <kmc> when you say ¬´instance Show [a]¬ª you don't use a either
17:01:47 <EvanR> moving on to applicative
17:01:55 <mauke> (because Either isn't a Functor, nor is Either Char Int)
17:02:13 <EvanR> wait
17:02:57 <EvanR> so if have Either e A, Either e B, and Either e C, and two functions A -> B and B -> C
17:03:16 <EvanR> now do i fmap compose something
17:03:24 <EvanR> how*
17:03:34 <kmc> > fmap show (Right 3 :: Either Int Int)
17:03:35 <lambdabot>   Right "3"
17:03:36 <EvanR> to get Either e A -> Either e C
17:03:38 <kmc> > fmap show (Left 3 :: Either Int Int)
17:03:39 <lambdabot>   Left 3
17:03:57 <kmc> EvanR, (fmap f . fmap g) = fmap (f.g)
17:04:08 <EvanR> nice
17:04:51 <EvanR> the use for this seems similar to Maybe monad
17:05:02 <kmc> yes, error handling etc
17:05:44 <mm_freak> EvanR: you can think of Either as something like Maybe, but with a Nothing that can actually contain values
17:05:52 <mauke> @djinn (A -> B) -> (B -> C) -> (Either a A -> Either e C)
17:05:52 <lambdabot> Error: Undefined type A
17:05:59 <mm_freak> Just corresponds to Right and Nothing corresponds to Left
17:06:00 <EvanR> but now why would i use Monad over Functor
17:06:04 <EvanR> or vs
17:06:11 <mauke> @djinn (xA -> xB) -> (xB -> xC) -> (Either a xA -> Either e xC)
17:06:11 <lambdabot> -- f cannot be realized.
17:06:15 <kmc> @djinn (a -> b) -> (b -> c) -> (Either e a) - > (Either e c)
17:06:15 <lambdabot> Cannot parse command
17:06:21 <mm_freak> monads are more powerful, while functors are more general
17:06:24 <kmc> @djinn (a -> b) -> (b -> c) -> (Either e a) -> (Either e c)
17:06:24 <lambdabot> f a b c =
17:06:24 <lambdabot>     case c of
17:06:25 <lambdabot>     Left d -> Left d
17:06:25 <lambdabot>     Right e -> Right (b (a e))
17:06:53 <mm_freak> something, for which the functor instance isn't enough:
17:07:05 <mm_freak> > Just 3 >>= \x -> Just 4 >>= \y -> Just (x+y)
17:07:06 <lambdabot>   Just 7
17:07:25 <mauke> EvanR: not everything can be written in terms of fmap
17:07:30 <kmc> if you need to choose the next "possibly-failed computation" based on the non-failed result of the previous "possibly-failed computation"
17:07:31 <mauke> also, all monads are functors
17:07:31 <kmc> then you need Monad
17:07:32 <ezyang> Type inference is too damn sexy. 
17:07:55 <EvanR> ok
17:08:14 <kmc> Applicative is in the middle
17:08:23 <edwardk> heya ezyang
17:08:29 <ezyang> edwardk: Hallo! 
17:08:32 <kmc> it lets you perform multiple "possibly-failed computations" and combine the results with some overall function
17:08:35 <wlangstroth> ezyang: +1
17:08:38 <edwardk> how is the wrong cambridge treating you?
17:08:42 <kmc> but doesn't let you choose later actions based on results of earlier ones
17:09:01 <EvanR> ok, moving on to applicative
17:09:20 <ezyang> edwardk: Quite well. I've started to get into the swing of things... which means more time for hacking. :-) 
17:09:45 <edwardk> kmc: though, amusingly over a fixed alphabet, things like applicative parsers are just as powerful as monadic ones ;)
17:10:07 <mm_freak> edwardk: that has nothing to do with the alphabet
17:10:13 <benmachine> edwardk: the what?!?!?! :P
17:10:16 <mm_freak> Applicative is enough for context-free grammers
17:10:17 <mm_freak> grammars
17:10:28 <mm_freak> for context-sensitive grammars you need Monad
17:10:32 <edwardk> mm_freak: no, because you can have a codata cfg
17:10:45 <edwardk> mm_freak: that is enough strength that it DOES have to do with the alphabet ;)
17:10:57 <mm_freak> edwardk: what do you mean?
17:10:58 <ezyang> Hmm... the LDAP package isn't very type safe but does have the notable advantage of working. 
17:11:13 <mm_freak> ezyang: who uses LDAP anyway?
17:11:19 <ezyang> I do. >.> 
17:11:20 * caelan is inspired to return to his parsing methods text
17:11:21 <kmc> pretty much everyone
17:11:28 <byorgey> people at institutions that use LDAP.
17:11:29 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
17:11:32 <dolio> You can have CFGs that aren't CFGs!
17:11:36 <kmc> even windows people
17:11:38 <mm_freak> kmc: i know‚Ä¶  it was just a rant =)
17:11:41 <mm_freak> i hate LDAP
17:11:47 <ezyang> Hi byorgey! 
17:11:52 <byorgey> hi ezyang!
17:11:55 <byorgey> How's Cambridge?
17:12:07 <EvanR> whatis (<*>) called
17:12:17 <monochrom> star
17:12:23 <mm_freak> edwardk: oh, i read "cfg" as "configuration"
17:12:24 <kmc> splat
17:12:25 <edwardk> mm_freak: i mean that using an Alternative you can parse things bigger than CFGs, you can have an infinitely large CFG, which is enough to remove the free from context-free
17:12:25 <byorgey> ap
17:12:33 <ezyang> byorgey: It's nice! :-) 
17:12:34 <EvanR> beholder
17:12:53 <mm_freak> edwardk: i see, but what practical difference does that make?
17:12:59 <bss03> > (+) <$> Just 3 <*> Just 4
17:13:00 <lambdabot>   Just 7
17:13:02 <monochrom> preflex: quote monochrom modem
17:13:03 <preflex>  <monochrom> Do not try to pronounce haskell code. You are not a modem.
17:13:08 <byorgey> mm_freak: all the difference in the world, in a lazy language
17:13:09 <wlangstroth> edwardk: "codata cfg"?
17:13:46 <mm_freak> when does a CFG become a CSG because it's infinite?
17:13:52 <edwardk> mm_freak: it means that you can parse anything you could over a finite alphabet with an applicative parser that you could with a monadic parser
17:14:00 <byorgey> mm_freak: see the nice recent ICFP paper, "A Play on Regular Expressions"
17:14:11 <byorgey> which raises a similar point
17:14:30 <bss03> > pure (+) <*> Just map [3,4] <*> [Nothing, Just 5]
17:14:31 <lambdabot>   Couldn't match expected type `[t] -> f a'
17:14:31 <lambdabot>         against inferred type `Da...
17:14:33 <edwardk> mm_freak: nils anders danielsson raised the issue to my attention first
17:14:50 <bss03> > pure pure (+) <*> Just map [3,4] <*> [Nothing, Just 5]
17:14:51 <lambdabot>   Couldn't match expected type `[t] -> (a -> b) -> a1'
17:14:51 <lambdabot>         against inferr...
17:15:07 <mm_freak> hmm, i can't imagine that, so i'll read the paper
17:15:08 <bss03> > pure (+) <*> Just 3 <*> Just 5
17:15:09 <lambdabot>   Just 8
17:15:11 <byorgey> bss03: Just map [3,4] doesn't look right, did you mean  Just `map` [3,4] ?
17:15:18 <edwardk> mm_freak: nothing prevents you from storing an unbounded amount of 'state' in the tree structure of your infinitely large grammar.
17:15:23 <mm_freak> is there a small, practical example?
17:15:34 <edwardk> mm_freak: the CFG can't do that because it is bounded in the number of states.
17:15:56 <edwardk> the usual pumping lemma fails to apply here
17:15:58 <bss03> byorgey: Oh yeah, forgot map isn't infix. :P
17:16:28 <wlangstroth> it's the "codata" part that I don't get
17:16:29 <mauke> so what you're saying is I can parse nested structures with an infinitely long regex
17:16:33 <dolio> Forget CFGs. It works with infinite regular expressions, too.
17:16:37 <bss03> > pure (+) <$> map Just [3,4] <*> [Nothing, Just 5]
17:16:38 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
17:16:38 <edwardk> dolio: sure
17:16:38 <lambdabot>    arising from a use of...
17:16:49 <mauke> which makes perfect sense, actually
17:16:59 <bss03> > (+) <$> map Just [3,4] <*> [Nothing, Just 5]
17:17:00 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
17:17:00 <lambdabot>    arising from a use of...
17:17:27 <bss03> > (pure . pure ) (+) <*> map Just [3,4] <*> [Nothing, Just 5]
17:17:28 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
17:17:28 <lambdabot>    arising from a use of...
17:17:29 <mm_freak> i'm reading
17:17:34 <bss03> :(
17:17:42 <edwardk> wlangstroth: the codata bit is just a fancy way of saying 'lazily generated and hence potentially infinite'
17:17:58 <byorgey> bss03: unfortunately the composition of two Applicatives is not automatically an Applicative in the way that you would like
17:18:05 <byorgey> although it is, mathematically speaking
17:18:17 <byorgey> but you have to tell the compiler that with a newtype wrapper to indicate the composition.
17:18:24 <byorgey> see the TypeCompose package on Hackage.
17:18:26 <wlangstroth> Oh! Right, co-data. Hehe
17:18:39 <edwardk> mm_freak: earliest reference i know of is here: ftp://ftp.cs.wisc.edu/pub/techreports/1977/TR300.pdf
17:19:10 <bss03> > fmap fmap fmap (+ 1) [Nothing, Just 5]
17:19:11 <lambdabot>   [Nothing,Just 6]
17:19:51 <bss03> So, Functors automatically compose, but Applicative needs a newtype wrapper. *sad panda*
17:20:13 <caelan> :t fmap
17:20:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:20:29 <dolio> It's an infinite state machine. Have one state for each possible string in the language, and circle all the ones you want to accept.
17:21:16 <bss03> caelan: fmap fmap fmap = (fmap . fmap)
17:21:24 <byorgey> bss03: Functors don't automatically compose either, note you had to use (fmap . fmap) instead of just fmap.
17:21:39 <caelan> bss03: i'm still trying to figure out what fmap *is*
17:21:39 <mm_freak> i didn't know people still use typewriters
17:21:50 <edwardk> mm_freak: that was from 77
17:21:52 <mauke> caelan: a generic map
17:21:56 <mauke> caelan: do you know what map is?
17:21:59 <bss03> caelan: fmap = map for arbitrary containers.
17:22:04 <mm_freak> that paper is unreadable on screen and unfortunately i don't have a printer
17:22:06 <byorgey> bss03: likewise, for your map Just [3,4] example you would have to use a function other than <*>, which can be defined using <*> and fmap
17:22:09 <caelan> huh, how's that work?
17:22:13 <bss03> caelan fmap succ (Maybe 3)
17:22:17 <bss03> > fmap succ (Maybe 3)
17:22:18 <lambdabot>   Not in scope: data constructor `Maybe'
17:22:20 <edwardk> mm_freak: dolio's summary was succinct and spot on though
17:22:23 <bss03> > fmap succ (Just 3)
17:22:24 <lambdabot>   Just 4
17:22:27 <EvanR> Functor and Applicative involve 2 different types, because a function (a->b) is involved, but Monoid is for single types
17:22:28 <bss03> > fmap succ [1,2,3]
17:22:29 <lambdabot>   [2,3,4]
17:22:33 <byorgey> caelan: well, it has to be implemented separately for each type you want to use it with.
17:22:54 <mm_freak> edwardk: i think i'll read the first paper mentioned
17:23:02 <byorgey> caelan: do you know about type classes?
17:23:07 <mm_freak> but it's long =/
17:23:10 <caelan> byorgey: yes
17:23:11 <bss03> > fmap succ (Data.Map.fromList [(1,2),(2,4),(3,7)])
17:23:11 <lambdabot>   Not in scope: `Data.Map.fromList'
17:23:20 <byorgey> @src Functor
17:23:20 <lambdabot> class  Functor f  where
17:23:21 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
17:23:24 <byorgey> caelan: ^^^
17:23:25 <edwardk> mm_freak: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=271
17:23:35 <caelan> ahhhhh
17:23:56 <bss03> > fmap succ (Data.IntMap.fromList [(1,2),(2,4),(3,7)])
17:23:57 <lambdabot>   Not in scope: `Data.IntMap.fromList'
17:24:05 <caelan> i didn't know you could polymorphize on classes like that
17:24:10 <bss03> :(
17:24:14 <byorgey> caelan: yes, it's quite useful =)
17:24:38 <byorgey> caelan: usually we would call f a 'type constructor'
17:25:12 <caelan> ah, right, forgot; it's been a while since i Haskelled
17:25:13 <byorgey> meaning it is not a type itself, but takes some type argument(s) and results in a type
17:25:22 <byorgey> sure, no worries =)
17:25:58 <caelan> i've never gotten incredibly deeply into it; feels like i don't have the background to grok it fully
17:26:33 <byorgey> caelan: no one does.  but no matter where you are, you can always grok it more fully than you currently do. =)
17:27:13 <mm_freak> question:  newtype Parser r a = P (String -> (String -> a -> r) -> (Error -> r) -> r)
17:27:22 <mm_freak> say there is a Functor and Applicative instance, but no Monad instance
17:27:33 <mm_freak> and you can't construct combinators manually
17:27:43 <mm_freak> can you parse any grammar with this one?
17:29:08 <wlangstroth> mm_freak: is that a manual "Either"?
17:29:48 <mm_freak> wlangstroth: it's a manual StateT String (Either Error) a
17:30:42 <edwardk> mm_freak: you shouldn't have any problems
17:30:46 <gwern> (haskell haskell haskell hard; haskell in your back yard)
17:30:48 <wlangstroth> right - just made me squint for a second
17:30:59 <c_wraith> Blah.  Are there any tools for automating creation of a haskell type implementing Storable given the C definition of the type?
17:31:35 <gwern> c_wraith: that's rather specific, so my guess would be no
17:31:51 <c_wraith> Hmm.  ok, giving up on using alloca then
17:31:58 <mm_freak> edwardk: is that because of the codata thing you mentioned above?
17:32:15 <byorgey> (haskell haskell haskell nice; haskell hard to be precise)
17:32:19 <mm_freak> (remember, that parser doesn't allow state other than the remainder of the string)
17:34:59 <c_wraith> Agh.  This feels like it'd be so much simpler if I wrote one more C function and wrapped it, instead of attempting to wrap at the current level.  But then I'd need to deal with C code coming from places other than the standard header and lib directories
17:35:04 <mm_freak> wlangstroth: actually you need to add a ContT, too
17:37:09 <mm_freak> wlangstroth: and then it's still something different, but it models the same kind of computation as ContT r (StateT String (Either Error)) a =)
17:37:25 <ezyang> Did haskell.org go down? 
17:39:00 <caelan> ezyang: working for me
17:39:20 <ezyang> looks like it's back now 
17:42:20 <wlangstroth> mm_freak: still trying to decide which one is easier to read
17:42:49 <mm_freak> wlangstroth: which ones are you comparing?
17:44:32 <wlangstroth> mm_freak: monad vs functor/applicative
17:45:13 <wlangstroth> mm_freak: the last one vs the first one you wrote
17:45:41 <kmc> c_wraith, it's pretty easy to deal with .c files in a cabal project
17:46:19 <wlangstroth> mm_freak: my brain is desperately attempting to simplify them, to no avail
17:46:30 <kmc> c_wraith, the wrapper generators i know of are (in ascending order of power) hsc2hs, c2hs, GreenCard
17:46:37 <kmc> but i don't think any of them will just slurp in a C header file
17:46:51 <kmc> maybe you could use http://hackage.haskell.org/package/cgen c_wraith
17:47:47 <c_wraith> Well, here's what I want in the simplest terms:  I want to allocate some mutable buffer, pass it to a C function, and then free it after getting what I need out of it.
17:48:30 <roconnor> c_wraith: love 'em and free 'em sort of person aren't you
17:48:37 <c_wraith> yep
17:48:49 <kmc> oh there's also bindings-DSL
17:48:54 <kmc> c_wraith, alloca?
17:49:04 <c_wraith> requires Storable
17:49:15 <kmc> but you don't care about the Haskell-side type?
17:49:18 <c_wraith> no
17:49:23 <kmc> allocaBytes then
17:49:30 <c_wraith> ah, where's that defined?
17:49:33 <kmc> same module
17:49:35 <kmc> Foreign.Marshall.Alloc
17:49:43 <c_wraith> ok
17:49:47 <c_wraith> let me read more
17:49:48 <c_wraith> :)
17:49:52 <kmc> allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
17:50:10 <kmc> notice how nice and unconstrained 'a' is :)
17:50:30 <byorgey> looks scary
17:50:40 <kmc> btw don't overlook Foreign.Marshal.Utils, i ignored that module for too long, it has some nice stuff
17:54:33 <jeffwheeler> I'm trying to install some things through cabal-install, but I'm a bit confused. First, is it correct that user packages cannot depend on global packages? And as far as I can tell, any time I try to install a package, it rebuilds its dependencies (e.g. containers, even the exact same version).
17:54:55 <jeffwheeler> It seems like it shouldn't need to compile containers-0.3.0.0 every time I install anything.
17:55:24 <jeffwheeler> Would that normally only be compiled once?
17:55:52 <enthropy> jeffwheeler: have you tried:   ghc-pkg check
17:56:01 <solidsnack> jeffwheeler: Normally, yes.
17:56:28 <jeffwheeler> enthropy: a few times, but apparently not since I last broke it again in the last minute; I'll fix the current problem
17:57:30 <jeffwheeler> And I suspect user packages should be able to depend on global packages, right?
17:58:10 <mm_freak> wlangstroth: i think that's the simplest way to express it, but i'm a CPS guy
17:58:53 <mm_freak> the other alternative would be:  newtype Parser a = P (String -> (Either Error a, String))
17:59:01 <wlangstroth> mm_freak: oh, it definitely is - I should have said that; my brain is just barely under my control
18:00:41 <enthropy> jeffwheeler: definitely. Take base and other ones you can't install for example
18:01:11 <jeffwheeler> enthropy: alright, makes sense; I'll see if I can get things to stop recompiling then when I /should/ already have them installed
18:01:24 <Saizan> jeffwheeler: you probably have array-0.3.0.1 as well as array-0.3.0.0 installed, and that's screwing things up
18:01:38 <mm_freak> btw installation‚Ä¶  is there an easy way to reinstall all packages after a GHC upgrade?
18:02:05 <jeffwheeler> Saizan: nuked ~/.ghc/ a second ago, so I can't tell anymore, but I'll check for that this time around
18:02:15 <Saizan> jeffwheeler: also, if you have the same version of the same package in both the global an user directory, then you should get rid of one of them
18:02:31 <mm_freak> and is there an easy way to delete unneeded files in ~/.cabal/?
18:02:36 <Saizan> jeffwheeler: and if you didn't get the memo, don't ever use "cabal upgrade"
18:02:41 <mm_freak> like installations from older GHC versions
18:02:59 <wlangstroth> mm_freak: which os?
18:03:02 <jeffwheeler> Saizan: I'll check for that, too; I've been trying to install as much as possible from Ubuntu's ghc packages
18:03:07 <mm_freak> wlangstroth: arch linux
18:03:27 <jeffwheeler> Saizan: and yep, I'll avoid cabal upgrade (but cabal install package is still fine, to upgrade, I assume)
18:04:09 <Saizan> mm_freak: some recent version of cabal-install keeps a register of all the packages you explicitly installed, that'd make it as easy as "cabal install world", not sure if the feature is in any released version or only in darcs
18:04:14 <wlangstroth> mm_freak: k, as long as it's not a mac - I was chasing some weird errors and changing script files the other day
18:04:50 <Saizan> jeffwheeler: yep, it's fine, though there's quite a risk of getting in an unmanageable state if you upgrade any of the core packages
18:05:07 <mm_freak> Saizan: that sounds great, i hope it'll be in a release soon
18:05:14 <jeffwheeler> Saizan: alright, thanks for the advice; I'll see how it goes this time around with those pointers
18:05:21 <mm_freak> i think that would also be a good way to upgrade all packages
18:05:30 <mm_freak> just delete everything, then install world
18:05:34 <jeffwheeler> By the way, is ghc-pkg unregister the way to nuke a package?
18:05:40 <Saizan> yep
18:05:48 <enthropy> it leaves files behind though
18:06:01 <byorgey> ghc-pkg unregister is the way to forget a package
18:06:07 <byorgey> rm -rf is the way to nuke one.
18:06:42 <jeffwheeler> byorgey, but I need to delete it in a few places right, and then rebuild the index or something?
18:07:04 <byorgey> I don't actually know.  ghc-pkg unregister has always been good enough for me.
18:07:13 <byorgey> so there are a few extra files lying around, so what
18:07:34 <jeffwheeler> byorgey: yeah, I'm not gonna stress over that
18:09:13 <wlangstroth> but rm -rf does get rid of whichever version you unregistered
18:09:43 <wlangstroth> the danger is 1.0.0.1 vs 1.0.1.0
18:10:23 <wlangstroth> (minor danger, but enough to elicit an "ah! you idiot" at onesself)
18:15:26 <monochrom> ghc-pkg is metadata. it sufficies to work on metadata.
18:16:00 <monochrom> not deleting enough files is just space leak but safe. deleting more than enough files is unsafe.
18:16:40 <monochrom> but you're supposed to format disk, install fresh ubuntu anyway
18:18:00 <wlangstroth> monochrom: every time you upgrade ghc? That seems rough, but okay ...
18:18:49 <jeffwheeler> monochrom: don't worry . . . I do
18:18:59 <Saizan> the new ghc installer will do that for you, btw
18:19:08 <jeffwheeler> monochrom: that's what tells me I need to upgrade my Ubuntu install
18:19:31 <wlangstroth> Saizan: awesome - one less thing!
18:21:19 <jeffwheeler> Hey, everything seems to be working much better now, thanks to all y'all's advice. Thanks! :)
18:21:41 <jeffwheeler> (I'm saying that bravely; it's compiled 110/115 files.)
18:22:57 <jeffwheeler> . . . wow, it's been a /long/ time since I've seen Yi's pango UI run.
18:23:19 <halberd> I sinned today - I committed the sin of "code mixing"
18:23:46 <Maxdamantus> @pl \a b c -> t $ f a b c
18:23:46 <lambdabot> ((t .) .) . f
18:24:14 <conal> Maxdamantus: see semantic editor combinators
18:24:17 <halberd> the way this sin works, you start with a function A, that does X, and is a few dozen lines long.  You want to do Y which is similar to X.  Solution: add another parameter to A, and sprinkle conditionals throughout it so that when the parameter is set it does Y
18:25:13 <conal> @where SEC
18:25:13 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
18:25:31 * hackagebot type-level-natural-number 1.1 - Simple, Haskell 2010-compatible type level natural numbers  http://hackage.haskell.org/package/type-level-natural-number-1.1 (GregoryCrosswhite)
18:25:43 <halberd> it's an antipattern
18:25:50 <halberd> does anyone know the name of the antipattern?
18:26:24 <wlangstroth> halberd: I know a guy who called that "refactoring". It was infuriating.
18:26:47 <halberd> I try to avoid it when possible, I hate it when other people do that
18:26:55 <Maxdamantus> conal = Conal Elliot?
18:26:56 <halberd> it's unclean code
18:26:57 <caelan> halberd: it's called java.
18:27:03 <halberd> unfortunately in this case I had little alternative
18:27:12 <wlangstroth> caelan ftw
18:27:14 <conal> Maxdamantus: if you add another "t", then yes.
18:27:16 <Maxdamantus> Isdeed.
18:27:22 <conal> Maxdamantus: hi
18:27:30 <Eridius> hi conal
18:27:36 <conal> Eridius: hi :)
18:28:44 <wlangstroth> halberd: you could call it "unfactoring"
18:29:12 <halberd> there's gotta be a name for it
18:29:15 <halberd> it's a disease
18:29:52 <wlangstroth> halberd: then "parametritis" it is
18:30:00 <Philippa> it's an instance of refuctoring, but I couldn't name the specific refuctoring
18:30:05 <halberd> maybe wlangstroth 
18:30:25 <wlangstroth> (inflammation of the parameter list)
18:30:26 <halberd> it's not really the parameter that is the awful part, it's the fact that you have to sprinkle changes throughout an existing codebase
18:30:32 <halberd> and it's not composable
18:30:43 <caelan> cool, now i have a word to insult java blotches
18:30:47 <halberd> I mean you can have a long parameter list that isn't a problem
18:30:59 <halberd> or it is probably a separate problem
18:31:06 <wlangstroth> then Philippa's "refuctoring" might be it
18:31:17 <Philippa> refuctoring's a more general term :-)
18:31:34 * hackagebot type-level-natural-number-operations 1.0 - Basic operations on type-level natural numbers.  http://hackage.haskell.org/package/type-level-natural-number-operations-1.0 (GregoryCrosswhite)
18:31:35 <Philippa> (while I came up with it independently, it's obvious enough that someone did a talk on it a few years back)
18:33:34 * hackagebot type-level-natural-number-induction 1.0 - High-level combinators for performing inductive operations.  http://hackage.haskell.org/package/type-level-natural-number-induction-1.0 (GregoryCrosswhite)
18:33:54 <calsaverini> hi
18:34:08 <xiefei> hackagebot: 1+1
18:34:20 <enthropy>  o no undecidable instances
18:35:29 <calsaverini> supose I had a data type that had many entries and I want to create a function that just "updates" one of the entries
18:35:32 <wlangstroth> Philippa: no shortage of examples matching the term
18:36:08 <calsaverini> something like I have a data Person {name :: String, email :: String, etc :: Etc}
18:36:24 <calsaverini> and I want to create a function update_mail :: Person -> Person
18:36:30 <monochrom> new = old{email="nospam"}
18:36:31 <calsaverini> ops
18:36:37 <calsaverini> HAA!
18:36:45 <calsaverini> Exactly this was what I wanted to ask
18:36:46 <calsaverini> hahaha
18:36:59 <calsaverini> thanks
18:37:25 <calsaverini> I knew I saw that earlier but never used it
18:37:28 <calsaverini> thanksalot
18:37:35 * hackagebot natural-number 1.0 - Natural numbers tagged with a type-level representation of the number.  http://hackage.haskell.org/package/natural-number-1.0 (GregoryCrosswhite)
18:42:25 <wlangstroth> is haskellers.com toast?
18:42:36 * hackagebot tagged-list 1.0 - Lists tagged with a type-level natural number representing their length.  http://hackage.haskell.org/package/tagged-list-1.0 (GregoryCrosswhite)
18:45:39 <halberd> code should do one thing
18:48:27 <mm_freak> halberd: if you want to support extensibility, then use a record type right away
18:48:31 <mm_freak> data Config = ...
18:48:34 <mm_freak> defaultConfig :: Config
18:48:38 <halberd> the more I think about it though I can't figure out any solution
18:48:56 <enthropy> extensible records
18:48:58 <halberd> well it's not haskell it's an ancient procedural language you probably never heard of
18:49:10 <mm_freak> enthropy: unfortunately haskell doesn't have them, but i don't think you need them here anyway
18:49:13 <wlangstroth> halberd: cobol?
18:49:27 <halberd> everyone's heard of cobol
18:49:27 <enthropy> mm_freak: they are libraries
18:49:41 <mm_freak> enthropy: i know HList, and i don't like it
18:49:59 <mm_freak> halberd: BASIC?
18:50:00 <enthropy> what about it?
18:50:06 <halberd> everyone's heard of BASIC
18:50:20 <halberd> rumpelstiltskin is its name
18:50:31 <wlangstroth> halberd: we're going to keep bugging you with obvious ones until you tell us
18:50:43 <halberd> how are those obvious ones
18:50:51 <halberd> your two clues are: ancient, and very obscure
18:50:59 <mm_freak> sounds like an esoteric language like chef, but telling fairy tales instead of cooking recipes
18:51:00 <enthropy> have you got mumps?
18:51:04 <halberd> your two guesses are both: ancient, and well known
18:51:11 <halberd> haha you got it
18:51:13 <wlangstroth> mumps isn't esoteric
18:51:16 <caelan> omg mumps
18:51:22 <enthropy> it isn't
18:51:25 <mm_freak> wlangstroth: rumpelstiltskin
18:51:26 <caelan> tdwtf, anyone?
18:51:39 <halberd> well mumps isn't terrible
18:51:44 <wlangstroth> mumps is used in a LOT of stuff
18:51:53 <enthropy> it's a terrible disease
18:51:55 <halberd> as a procedural language it has certain advantages over COBOL or BASIC
18:52:00 <wlangstroth> GT.M?
18:52:01 <halberd> the disease is when you do it wrong
18:52:05 <mm_freak> does common lisp count as ancient?
18:52:05 <halberd> it can be done right
18:52:19 <halberd> the race is over mm_freak 
18:52:22 <Adamant> mumps is pretty interesting for something written in the 60's
18:52:23 <wlangstroth> haha
18:52:36 <mm_freak> halberd: i asked in general
18:52:37 <enthropy> mm_freak: what is your impression of HList?
18:52:43 <wlangstroth> which mumps system, though?
18:52:48 <halberd> yeah common lisp is pretty ancient
18:52:54 <caelan> mm_freak: not sure cl counts as either esoteric or sans-records
18:53:04 <mm_freak> enthropy: it doesn't feel like a solution, but rather like a workaround
18:53:08 <halberd> actually
18:53:13 <mm_freak> enthropy: you need to write way too much, too
18:53:27 <halberd> my MUMPS has records and all kinds of neat stuff attached
18:53:38 <enthropy> there's no pattern matching on HLists
18:53:47 <halberd> because my company is old and has built a lot on top of the language
18:53:49 <wlangstroth> halberd: so ... GT.M ... ?
18:54:34 <halberd> mumps has a repl
18:54:44 <mm_freak> enthropy: i don't remember
18:54:46 <halberd> and easy persistent database storage
18:55:00 <halberd> and easy multidimensional arrays
18:55:05 <mm_freak> anyway, i think you can solve the problem of extensible records easier in haskell, perhaps using type classes
18:55:18 <halberd> and you can dump a stack trace at any time
18:55:19 <mm_freak> but a real built-in solution would be best
18:55:30 <halberd> or trace any program as it runs
18:55:40 <halberd> you can debug and change a running system
18:56:00 <wlangstroth> halberd: k, seriously - which mumps system is it, or are you not allowed to say?
18:56:06 <mm_freak> halberd: compared to what?
18:56:23 <halberd> intersystems cache
18:56:37 <mm_freak> haskell has all that, too, but i'm not sure about run-time changes to the program
18:56:53 <enthropy> mm_freak: what aspect of 'using type classes'? hlist definitely uses lots of those, but you want each field to be it's own class instead of only one class with fundeps?
18:56:53 <halberd> plus a lot of customization
18:57:03 <mm_freak> the 'persistent' package is particularly great‚Ä¶  i learned about it through yesod
18:57:08 <halberd> a few million lines of customization
18:57:20 <wlangstroth> oh, cach√© - that's really close to GT.M
18:57:35 <wlangstroth> (at least, at the core)
18:57:49 <mm_freak> enthropy: not a type class actually, but you could write a Combine type like i did once for CPS-based monads
18:58:18 * enthropy doesn't follow
18:58:26 <mm_freak> the next release of contstuff might contain it, but i'm not yet sure, whether it's really useful
18:58:37 <mm_freak> well, CPS-based monads have an 'r' parameter for the end result
18:58:40 <mm_freak> ContT r m a
18:58:59 <mm_freak> what happens if you combine two of those using a monad transformer stack?
18:59:07 <mm_freak> ContT r1 (ContT r2 m) a
18:59:24 <mm_freak> my approach does this instead:  (ContT :+: ContT) r m a
18:59:48 <wlangstroth> halberd: fis released the code for GT.M, and a big chunk of it is in assembly. Monstrous.
18:59:58 <enthropy> why would you do that?
19:00:15 <mm_freak> enthropy: to have a single 'r' and a better composition syntax
19:01:16 <JoeyA> Is type inference for rank-2 polymorphism harder to implement than rank-1?
19:01:24 <mm_freak> particularly it's not the same as a monad transformer stack, and you have a single runCombined function instead of a composition of runContT calls
19:02:10 <JoeyA> Or is it possible to handle rank-2 such that the type inference algorithm actually makes more sense?
19:02:38 <halberd> how do you know it's the source doe then wlangstroth ?
19:03:19 <mm_freak> enthropy: in the same way you might be able to implement extensible records
19:03:38 <mm_freak> Record1 :+: Record2
19:04:05 <mm_freak> using an Accessor type-class probably
19:04:20 <wlangstroth> halberd: "doe"?
19:04:39 <monochrom> joe programmer writes source doe :)
19:05:33 <mm_freak> doe = depends on experience, according to VERA
19:05:53 <enthropy> department of energy
19:05:58 <wlangstroth> oh, was that "code"?
19:06:07 <monochrom> hehe
19:06:21 <halberd> mm I think the only good way I could work around my design antipattern is if it was object oriented
19:06:30 <halberd> which isn't an option
19:06:53 <wlangstroth> it's in assembly, not machine - I can barely read it, with labels like "L66", etc
19:06:58 <halberd> it's really the exact problem that object orientation was designed to solve
19:08:28 <wlangstroth> halberd: and yet, as caelan mentioned, it's pretty common in java
19:08:37 <halberd> so instead of passing in an extra parameter to tell the routine what to do, you pass in an object, and the object tells the routine what to do
19:09:05 <halberd> so you can keep the special case logic in the object's class instead of the routine
19:09:47 <mm_freak> wlangstroth: java has the facilities to solve the problem to some extent, but apparently people just don't use them
19:09:55 <mm_freak> same with C#
19:10:43 <wlangstroth> mm_freak: I'm not being fair, of course. Java is probably the second most used language, after JavaScript, so there are bound to be some painful examples
19:10:44 <mm_freak> it's also kinda stupid that there is no equivalent to classes like Num, even though they are well possible
19:10:44 <halberd> I could have split up the large routine into bite sized pieces but the problem is the pieces would take like 15 parameters each
19:10:50 <caelan> to some extent, i think the solution is in the sort of abstraction you see with lisp macros
19:11:10 <mm_freak> halberd: anyway, how is that related to haskell?
19:11:48 <wlangstroth> mm_freak: clearly, halberd is describing those things that drive one to want to program in haskell
19:12:00 <mm_freak> true
19:12:14 <mm_freak> but haskell hasn't solved the problem of extensible records either
19:12:24 <mm_freak> but that's a slightly different problem
19:12:45 * hackagebot Facts 0.1 - A collection of facts about the real world.  http://hackage.haskell.org/package/Facts-0.1 (AlexanderSolla)
19:12:48 <halberd> haskell is where people who think about programming languages are
19:13:03 <kmc> wow you had a serious discussion about MUMPS
19:13:06 <halberd> wouldn't have gotten any meaningful response in any other channel
19:13:07 <kmc> i am impressed
19:13:17 <caelan> mumps aren't funny, biologically or otherwise
19:13:27 <mm_freak> halberd: indeed
19:16:50 <kmc> halberd, i wish it weren't the case
19:17:16 <kmc> Haskell isn't perfect, and the PL community could use more diversity of thought
19:20:38 <caelan> i found a little big book called "Programming Language Design Concepts" pretty good
19:20:59 <kmc> maybe someone can tell me about some cool PL research that isn't centered around Haskell, ML, or hacking established features from those languages into Java and C#
19:21:25 <caelan> kmc: i don't think there really is any, unless you toss prolog or erlang into the mix.
19:21:44 <pickles1> kmc: i'm working on something, but it's a long way from seeing the light of day
19:21:50 <dolio> What PL research is centered around those?
19:22:40 <kmc> caelan, is there research done in Prolog and Erlang?
19:22:55 <kmc> i guess there's (still) a fair amount of research done in Lisp dialects
19:23:43 <caelan> kmc: i'm not sure there's nearly as much now, but i've dug up a few artifacts of old research
19:25:02 <caelan> and there's a mysteriously familiar installation of gprolog on the cse machines at my school...
19:39:52 <sidek> is there a function in haskell that takes a list and returns the members from largest to smallest or do I need to make one?
19:40:19 <dolio> reverse . sort?
19:40:41 <dolio> sortBy (flip compare)
19:40:42 <sidek> sort? is that a function?
19:40:44 <sidek> ah
19:40:46 <sidek> thanks
19:41:09 <sidek> sortBy isn't in scope...
19:41:18 <kmc> Data.List
19:42:01 <sidek> what about data.list?
19:42:24 <kmc> it has sort and sortBy
19:42:27 <kmc> @hoogle sortBy
19:42:27 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
19:42:30 <sidek> ah... a module
19:48:38 <Saizan> ghc started segfaulting on me all of a sudden..
19:51:08 <JuanDaugherty> eh? and you're not the root cause?
19:51:51 <monochrom> cosmic ray interference
19:52:38 <Saizan> heh
19:52:54 <kmc> you've angered the gods
19:53:13 <kmc> prepare for boils and locusts
19:53:16 <halberd> m-x butterfly
19:53:22 <blackdog> sacrifice a lambda and try again
19:53:38 <Saizan> well, i've only angered the 6.12.3 gods though, both 6.10.4 and 7 still answer my prayers :)
19:53:41 <caelan> the lambda has been replaced with a gnu
19:54:05 <tolkad> It's really annoying that I have to keep my data type arguments in a specific order in order to create for example Monad instances for them
19:54:46 <tolkad> why can't I do something like instance Monad (\a -> T a S)
19:54:53 <tolkad> or is there a way to?
19:55:08 <Saizan> because then typeclass resolution would need to do higher order unification
19:55:12 <monochrom> yeah, it's really annoying that stuff inside do-notation has to keep a specific order
19:55:16 <Saizan> which is a messy problem
19:55:31 <Saizan> tolkad: you can use a newtype
19:55:56 <tolkad> monochrom: that's different
19:56:07 <tolkad> monochrom: the order actually means something
19:56:13 <halberd> in my ideal programming language you wouldn't have to worry about the specifics of how to get a specific piece of data to a particular function
19:56:45 <caelan> halberd: you mean like ada's (or python's) keyword-passing?
19:56:49 <halberd> you'd just call for the data by name and it would get there, from register, memory, disk, or even a remote server
19:56:57 <caelan> oh, hm
19:56:58 <tolkad> although, maybe the fact I percieve this as a problem has to do with the fact I do not have much experience with lambda calculus and I still think of haskell functions as having multiple arguments rather than returning functions
19:57:55 <caelan> tolkad: i find it only really gets annoying when you've defined the function to take arguments in the wrong order
19:58:10 <caelan> there's a reason map takes a function first
19:58:25 <halberd> what's the reason?
19:58:34 <caelan> it makes it easier to curry map.
19:58:39 <halberd> o
19:58:46 <caelan> sines = map sin
20:00:12 <kmc> tolkad, you're right that it's annoying, and no there's not a good solution
20:03:04 <tolkad> oh. well thanks, guess I'm off to reorganize my instances
20:06:21 <Saizan> aristid: have you found an xml library that handles encodings btw?
20:07:14 <monochrom> hxt does
20:22:32 <Saizan> monochrom: readDocument seems to produce text nodes with octects in them
20:33:43 <JoeyA> What are ? and ?? in kinds?
20:34:11 <dolio> :k (->)
20:34:12 <lambdabot> ?? -> ? -> *
20:34:32 <JoeyA> Why isn't it * -> * -> *  ?
20:34:34 <dolio> ?? is * and #, ? is ?? and (#)
20:34:35 <lambdabot> Plugin `compose' failed with: Unknown command: ""
20:34:45 <dolio> And meaning union.
20:34:55 <dolio> # is for unboxed types.
20:35:01 <dolio> (#) is for unboxed tuples.
20:35:13 <kmc> JoeyA, it is ‚àó ‚Üí ‚àó ‚Üí ‚àó in standard Haskell
20:35:18 <kmc> unboxed types are a GHC extension
20:35:23 <JoeyA> oh
20:35:30 <JoeyA> so it has very little to do with type inference, right?
20:35:49 <kmc> hmm
20:35:53 <kmc> kinds are inferred, as are types
20:35:55 <JoeyA> I'm just looking for a standard-ish way to express the notion of a kind variable when parsing a type.
20:36:02 <kmc> but usually it's pretty obvious whether something is allowed to be unboxed
20:36:08 <kmc> GHC represents kinds and types with the same datatype
20:36:12 <kmc> this is a questionable decision
20:36:48 <kmc> there are no kind variables in standard Haskell
20:37:01 <kmc> there would be unification variables during kind inference, though
20:37:14 <JoeyA> right, that's what I'm getting at.
20:37:17 <kmc> but they are not generalized
20:37:23 <kmc> i think they simply default to ‚àó if unconstrained
20:39:17 <JoeyA> Does a type signature have to have kind * ?
20:39:32 <JoeyA> (even if parts of it have higher kinds, like ST s m a)
20:40:09 <dolio> No. Int# :: # is a valid type signature for some values.
20:40:20 <dolio> As is (# Int, Char #) :: (#)
20:41:10 <JoeyA> in standard Haskell, I mean.  Thanks, that's good to know, though.
20:41:39 <dolio> Then yes, only types with kind * have values.
20:42:40 <JoeyA> class Monad m; (Monad m) => , those are cases where a higher-kind type appears by itself.  Granted, they aren't signatures.
20:43:08 <kmc> yeah
20:43:14 <kmc> if you have v :: (t : k)  then k = ‚àó
20:43:23 <kmc> err v :: (t :: k)
20:44:06 <kmc> unboxed tuples are barely values, though
20:44:30 <lispy> JoeyA: http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes#KindsareTypes
20:44:36 <dolio> Yeah.
20:44:41 <kmc> about the only thing you can do with them is pattern-match them immediately
20:44:52 <kmc> can't bind them, pass them to a function, etc
20:45:25 <kmc> that's because they represent only a pattern of multiple return values in STG-machine registers
20:45:31 <kmc> they have no persistence
20:46:48 <calsaverini> :q
20:47:10 <kmc> E37: No write since last change (add ! to override)
20:47:35 <caelan> C-x C-c
20:47:54 <dmwit> Someday, editors will just save after every edit.
20:48:07 <dibblego> does foldl' (.) id exist somewhere?
20:48:08 <dmwit> And version control it, so that you can roll back stupid changes, even after exiting the editor.
20:48:25 <dmwit> msum . map Endo
20:48:25 <winxordie> darcs-emacs?
20:48:25 <caelan> dmwit: emacs interacts pretty well with bazaar
20:48:34 <kmc> dmwit, i wrote an editor which saved every edit to a git repo in /tmp
20:48:48 <dmwit> kmc: Exactly what I've been hoping for.
20:48:49 <kmc> the (unimplemented) design was to allow branching and merging of undo history
20:49:02 <kmc> yup what you just said
20:49:07 <kmc> i hear git can do in-memory repos too
20:50:11 <dmwit> Did you know that vim actually has an undo DAG?
20:50:13 * hackagebot MorseCode 0.0.5 - Morse code  http://hackage.haskell.org/package/MorseCode-0.0.5 (AndyStewart)
20:50:37 <dibblego> Endo doesn't have a MonadPlus
20:50:41 <dmwit> Also, the DAG is annotated with a canonical line and timestamps, so you can say "undo the last five minutes".
20:50:48 <dmwit> dibblego: sorry, mconcat
20:50:56 <mm_freak> i've seen that kind variables are possible, but i'm unable to construct one
20:50:58 <dibblego> mconcat uses foldr iirc
20:51:03 <dmwit> dibblego: Though I suppose that's technically foldr (.) id instead.
20:51:06 <mm_freak> can anybody give me an example?
20:51:07 <dibblego> yes
20:52:07 <caelan> :t foldr (.) id
20:52:08 <lambdabot> forall b. [b -> b] -> b -> b
20:52:18 <dibblego> @type appEndo . mconcat . map Endo
20:52:19 <lambdabot> forall a. [a -> a] -> a -> a
20:52:34 <caelan> :t mconcat
20:52:35 <lambdabot> forall a. (Monoid a) => [a] -> a
20:52:59 <dibblego> @check \k a -> let x = appEndo . mconcat . map Endo; y = foldl' (.) id in x k a == y k (a :: Int)
20:53:00 <lambdabot>   Overlapping instances for GHC.Show.Show
20:53:00 <lambdabot>                              (GHC.T...
20:53:26 <dmwit> No, they are different.
20:53:40 <dmwit> > foldr (.) id [(2*), (2+)] 37
20:53:41 <lambdabot>   78
20:53:42 <dmwit> > foldl (.) id [(2*), (2+)] 37
20:53:44 <lambdabot>   78
20:53:48 <dmwit> ...uh
20:53:53 <dmwit> Wait, what?
20:54:12 <caelan> interesting
20:54:17 <dmwit> Oh, yes, I see.
20:54:28 <dmwit> Fine, they are equal by associativity of (.), then. =)
20:54:30 <dibblego> >> quickCheck $ \a -> let k = [(2*), (2+)]; x = appEndo . mconcat . map Endo; y = foldl' (.) id in x k a == y k (a :: Int)
20:54:30 <dibblego> +++ OK, passed 100 tests.
20:54:44 <dibblego> if they are equal by associativity then they are equal for any monoid
20:55:15 <caelan> > let f gs x = map (flip ($) x) gs in f [(2*), (3*)] 3
20:55:16 <lambdabot>   [6,9]
20:55:21 <dmwit> dibblego: yes
20:55:35 <dmwit> dibblego: The only possible difference is performance.
20:55:44 <mm_freak> dmwit: functions with function composition form a monoid
20:55:50 <mm_freak> so composition must be associative
20:55:58 <monochrom> Saizan: http://hpaste.org/40566/hxt
20:56:11 <dmwit> mm_freak: Yes, it was a moment of idiocy. I was picturing foldl (flip (.)) id in my head.
20:56:53 <mm_freak> that's probably why mathematicians prefer to compose to the left =)
20:57:14 <mm_freak> although i'm not sure whether right-composition would change anything
20:57:15 * hackagebot Facts 0.1.1 - A collection of facts about the real world.  http://hackage.haskell.org/package/Facts-0.1.1 (AlexanderSolla)
20:57:16 <dibblego> haha so was I, thanks
20:57:29 <kmc> haha
20:57:32 <dmwit> I was reading a paper today that used the \circ notation for composition, but with the meaning (f . g) x = g (f x).
20:57:33 <kmc> best package ever
20:57:35 <dmwit> Confusing.
20:58:11 <caelan> i remember writing a function to compose any number of functions
20:58:12 <mm_freak> > map (\f -> f (>>>) id [(*2), (+3), subtract 4]) [foldr, foldl]
20:58:13 <lambdabot>   Overlapping instances for GHC.Show.Show (c -> c)
20:58:13 <lambdabot>    arising from a use of `...
20:58:33 <mm_freak> > foldr (>>>) id [(*2), (+3), subtract 4]
20:58:34 <lambdabot>   Overlapping instances for GHC.Show.Show (c -> c)
20:58:34 <lambdabot>    arising from a use of `...
20:58:38 <mm_freak> huh?
20:58:39 <dmwit> caelan: Was it foldr (.) id ?
20:58:57 <dmwit> > foldr (>>>) id [(*2), (+3), subtract 4] 5
20:58:58 <lambdabot>   9
20:59:02 <mm_freak> oh, lol
20:59:04 <caelan> dmwit: it was in lisp, actually
20:59:16 <dmwit> caelan: Was it the lisp equivalent of foldr (.) id?
20:59:17 <mm_freak> > foldl (>>>) id [(*2), (+3), subtract 4] $ 10
20:59:18 <lambdabot>   19
20:59:20 <mm_freak> > foldr (>>>) id [(*2), (+3), subtract 4] $ 10
20:59:21 <lambdabot>   19
20:59:36 <dmwit> caelan: I'm just trolling now. =)
21:00:33 <mm_freak> > foldr (.) id (repeat (1:)) []
21:00:34 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:00:37 <mm_freak> > foldl (.) id (repeat (1:)) []
21:00:44 <mm_freak> ok, they're not the same
21:00:44 <lambdabot>  Terminated
21:01:06 <dmwit> This Facts package seems to be a pretty small cross-section of all possible facts.
21:01:13 <mm_freak> bottom foils our plans
21:01:18 <dmwit> Like, maybe it should be called "ZipCodes" instead or something.
21:01:43 <kmc> yeah, i was hoping for a comprehensive bootstrapped ontology
21:01:47 <mm_freak> dmwit: it's named Facts, not AllFacts =)
21:01:49 <kmc> starting with "the world is that which is the case"
21:02:19 <Jafet> It invented its own package category, Factual
21:02:32 <mm_freak> > foldl (>>>) id (repeat (1:)) []
21:02:33 <Jafet> Maybe you could add your own ontological framework in that category
21:02:37 <lambdabot>   mueval: ExitFailure 1
21:02:38 <mm_freak> > foldr (>>>) id (repeat (1:)) []
21:02:41 <kmc> 10 Haskell Fun-Bux to the first person to upload a package in the category 'Fictional'
21:02:42 <lambdabot>   mueval-core: Time limit exceeded
21:02:59 <mm_freak> hmm, so right-to-left composition seems to be more powerful
21:03:01 <Jafet> I'll throw in ten zorkmids.
21:03:49 <mm_freak> kmc: like what?  an integer of type 'forall a. a'?  a klingon interpreter?
21:03:52 <mm_freak> fix id?
21:04:07 <dmwit> ?src (>>>) ->
21:04:07 <lambdabot> Source not found. There are some things that I just don't know.
21:04:11 <dmwit> ?src -> (>>>)
21:04:11 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:04:17 <dmwit> It is a bit silly.
21:04:25 <mm_freak> dmwit: (>>>) is not a class function anymore
21:04:33 <caelan> mm_freak: a complete consistent axiom system.
21:05:06 <mm_freak> ?src -> (.)
21:05:06 <lambdabot> Source not found. :(
21:05:18 <dmwit> Yeesh. (>>>) = flip (Category..) -- ?
21:05:19 <mm_freak> ?src -> (Control.Category..)
21:05:19 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:05:34 <mm_freak> dmwit: yeah
21:05:36 <mm_freak> probably
21:05:39 <mm_freak> @src (>>>)
21:05:40 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:06:18 <mm_freak> though it's better the way it is now
21:06:39 <mm_freak> but the Prelude has its own (.), which is not just (Control.Category..) reexported
21:06:44 <mm_freak> that sucks
21:06:49 <mm_freak> just like 'id'
21:11:34 <dolio> @src (->) (>>>)
21:11:35 <lambdabot> f >>> g = g . f
21:22:24 <dibblego> @hoogle (Traversable t, Monoid a) => t a -> a
21:22:25 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
21:22:25 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
21:22:25 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
21:26:56 <lispy> ?src Maybe Monoid
21:26:56 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:27:18 <lispy> ?src Maybe mplus
21:27:18 <lambdabot> Nothing `mplus` ys = ys
21:27:18 <lambdabot> xs      `mplus` ys = xs
21:27:24 <lispy> I see
21:27:34 <lispy> I didn't know about that syntax for src
21:28:49 <shachaf> lispy: @src doesn't have "syntax", only conventions.
21:29:01 <shachaf> lispy: It just looks up the line you give it in a text file.
21:30:56 <nomothetis> hi guys. I could really use some help here. Could someone tell me what the linesFromString method isn't getting called at all? I've compiled with --make and -Wall and have no warnings: http://pastie.org/1219956
21:33:02 <c_wraith> nomothetis, that appears to be an infinite loop
21:33:09 <nomothetis> oh?
21:33:20 <c_wraith> computeSocialNetwork is calling itself without doing anything productive
21:33:47 <nomothetis> no, it isn't; I just didn't copy the entire code.
21:34:00 <nomothetis> I'll put it all; I thought the whole method would be distracting.
21:34:02 <c_wraith> Oh.  then how can we possibly answer the question.
21:34:36 <c_wraith> Though that does fit.  The code as posted would error out with <<loop>> in the non-threaded runtime.
21:34:40 <c_wraith> and you didn't report seeing that.
21:35:08 <nomothetis> this is the whole code:
21:35:09 <nomothetis> http://pastie.org/1219964
21:35:26 <nomothetis> I just thought the problem would appear in the first few lines, since the issue is that the call to trace is never happening.
21:35:41 <nomothetis> And it should (right?) show up before a call to computeSocialNetwork
21:35:50 <c_wraith> So you're never seeing the trace output?
21:35:54 <nomothetis> nope.
21:36:00 <c_wraith> do you have a good grasp on lazy evalutation?
21:36:12 <nomothetis> almost certainly not. :-/
21:36:37 <c_wraith> the trace output will only show up when the linesFromString return value is evaluated enough that it has to examine its input.
21:37:05 <nomothetis> wont' that happen if computeSocialNetwork is called?
21:37:27 <nomothetis> oh, wait.
21:37:32 <nomothetis> I see what you mean.
21:37:44 <nomothetis> Okay, let me try a few other places where things could go wrong.
21:41:47 <nomothetis> ahah, I see what's going on. Thanks c_wraith. It'll take a while to debug still, but now I understand why the trace statements were affecting things before... :-)
21:42:17 <c_wraith> nomothetis, that's a big step forward.  Have fun :)
21:43:20 <billy> Hi, i tried to load a one-liner into ghci, and got "Not in scope" error on v0 and v1. The one line file is here - "data Group = Grp {v0, v1:: Int} [Group] | Node Int". THANKS!
21:44:00 <kmc> you can't declare data in ghci
21:44:05 <kmc> oh you mean you were loading that file?
21:44:24 <billy> yes, I was loading that one-line file
21:50:13 <icedane> @src join
21:50:14 <lambdabot> join x =  x >>= id
21:50:55 <kmc> billy, you can't have a single constructor that's part record and part not
21:51:08 <kmc> that's an unhelpful error message and it took a sec for me to see what was going on
21:51:32 <kmc> but you can do ¬´Grp { v0, v1 :: Int, foo :: [Group] }¬ª
21:52:20 <billy> kmc, thanks a lot! I appreciate the help
21:52:50 <kmc> no problem :)
22:03:49 <dibblego> @type foldr (>=>) return
22:03:52 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
22:04:03 <dibblego> @instances Monoid
22:04:04 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
22:04:43 <dibblego> instance Monad m => Monoid (Kleisli m a a) where mempty = return; mappend = (>=>)
22:04:53 <dibblego> is that lying around?
22:06:59 <kmc> instance Category c => Monoid (c a a) -- :D
22:07:19 <dibblego> ah yeah of course
22:07:26 <kmc> that would overlap like hell
22:07:53 <djahandarie> Just don't define an instance for (->) ;)
22:08:52 <kmc> i want a GHC extension
22:09:01 <kmc> where the instance-resolution system can be redefined by the user
22:09:03 <kmc> in Haskell code
22:10:42 <dibblego> what is the name of the property of a function f such that f . f = id?
22:11:50 <kmc> involution?
22:12:21 <dibblego> nice thanks
22:26:41 * hackagebot OSM 0.5.0 - Parse OpenStreetMap files  http://hackage.haskell.org/package/OSM-0.5.0 (TonyMorris)
22:31:11 <periodic> I hate to hop in just to ask questions, but does anyone have a recommendation on what data type to use with the Writer Monad and long logs?  I can't find a good answer through google.
22:31:30 <lispy> periodic: Perhaps Data.Sequence?
22:31:42 <periodic> lispy: hoogling it now.
22:31:48 <lispy> periodic: That or, doing periodic dumps on the stream
22:32:20 <lispy> periodic: if Data.Sequence isn't right, then Data.ByteString would at least be a compact representation.
22:32:48 <lispy> I don't really know which will be worse, the run-time of the appends or the memory requirements
22:33:27 <periodic> I'm building upa  long simulation log, then I was going to run analysis in a second pass.
22:34:01 <periodic> And I was noticing that longer runs seem to be getting longer faster than linear, so I thought I'd start with this obvious optimization.
22:34:07 <periodic> Looks like Sequence is a good bet.
22:34:10 <kmc> periodic, Sequence is good
22:34:13 <kmc> see also the 'dlist' package
22:34:14 <periodic> thank you.
22:34:19 <periodic> Yeah, I saw a reference to dlist.
22:34:30 <kmc> are you appending only at the end?
22:34:34 <kmc> you could just use a list and reverse it once
22:34:47 <kmc> you could also allocate a giganto ByteString buffer ahead of time
22:34:54 <periodic> I was wondering about that, but I'd have to redefine the Monoid instance for lists, right?
22:35:02 <periodic> to do the reverse thing?
22:35:05 <kmc> would be better to newtype them
22:35:14 <periodic> oh, that makes sense.
22:35:35 <periodic> Yeah, I'm writing and consuming linearly.
22:35:58 <periodic> and ultimately writing the whole thing out as well.
22:36:16 <periodic> I'll give Sequence a shot, because it looks like the right sort of thing.
22:36:24 <kmc> does what i said about ByteString make sense at all?  does its mutation-behind-the-scenes work that way?
22:36:26 <periodic> But I'll remember the newtype idea.
22:36:33 <kmc> yeah, Sequence is nice
22:36:42 <periodic> I get the idea of the ByteString, but it just seems a bit... inflexible.
22:36:50 <periodic> It doesn't seem like what that type was deisgned form
22:36:56 <periodic> *designed for
22:37:09 <kmc> it's designed for fast, space-efficient byte arrays
22:37:25 <kmc> and, secondarily, for fast, space-efficient text if all you need is ASCII
22:37:30 <kmc> for Unicode-aware packed text, see Data.Text
22:37:33 <kmc> dlist is as flexible as lists
22:37:45 <kmc> also has a Monoid instance
22:37:50 <kmc> which is basically the same as Endox
22:37:52 <kmc> Endo*
22:38:44 <periodic> since I'm going to do some analysis on the logs, I want to keep them as a datastructure.  Like "X sent 10 bytes of data to Y" as Sent X Y 10
22:39:26 <kmc> ah, good idea
22:40:02 <kmc> if you needed something like ByteString, you could use storablevector
22:40:31 <periodic> Well, I'm going to give Sequence a shot.
22:40:34 <periodic> Thanks for the input.
22:40:36 * kmc wonders how much work is being duplicated between lazy/strict BS, Text, StorableVector, vector, DPH, Repa, etc.
22:40:40 <kmc> good luck
22:40:53 <periodic> Yeah, lots of datatypes in the world!
22:58:38 <periodic> Looking good, kmc and lispy.  Thanks
22:58:47 <kamatsu> kmc: Repa + DPH share most of their work
22:58:51 <kamatsu> kmc: made by the same people
22:59:52 <kamatsu> got  Scala working on android
23:02:04 <kmc> cool cool
23:02:48 <kmc> now i have to get off my ass and finish ghc-android
23:02:54 <kmc> then we can achieve total functional domination
23:09:34 <jamy> hi all
23:11:42 <kmc> hi jamy
23:12:47 <lispy> kmc: oh, you're working on a ghc-android?  What is your approach?  Can android run native code?
23:12:59 <lispy> kmc: are you creating a "mobile" RTS?
23:14:02 <jamy> kmc: how are you?
23:14:40 <lispy> I want to work on a GHC native client backend, but I find that I just don't have the time for all these projects!
23:15:26 <JoeyA> is there a switch to ghc to make it run in Haskell 98 mode?
23:15:58 <kmc> i'm well jamy, how are you?
23:16:04 <kmc> lispy, native code, standard GHC RTS more or less
23:16:09 <kmc> via-C unregisterized compilation
23:16:16 <kmc> it is much like the iphone port, though working off a newer GHC
23:16:34 <JoeyA> in particular, GHC accepts something not accepted back in 2001: http://www.mail-archive.com/haskell@haskell.org/msg08087.html
23:17:44 * jamy running on dream, then dont slept now
23:30:53 <maurer_> Is there an easy way to extract [Word16] from ByteString or [Word8], or do I need to write one?
23:31:27 <kmc> hey maurer_ did you solve your linker problem?
23:31:33 <maurer_> kmc: No.
23:33:15 <JoeyA> there is unpack :: ByteString -> [Word8] in Data.ByteString
23:33:20 <kmc> Word16 from ByteString you could do by getting at the ForeignPtr + appropriate cast + peekArray
23:33:29 <maurer_> I suppose.
23:33:31 <kmc> not exactly pretty
23:33:43 <kmc> i bet it performs better than unpack plus a conversion that walks the list
23:33:50 <kmc> but i wouldn't bet very much, without profiling it
23:33:51 <JoeyA> If you're looking to convert to/from UTF-8, you could use Data.ByteString.UTF8.
23:33:53 <maurer_> I don't care about performance
23:34:01 <maurer_> I'm trying to get raw 16 byte numbers out of a file
23:34:08 <kmc> could you use Data.Binary?
23:34:15 <maurer_> Good idea.
23:34:21 <kmc> (or cereal)
23:36:20 <JoeyA> note that decode str :: [Word16] won't quite do, since Data.Binary writes a length portion as well.
23:37:27 <JoeyA> you'll want to look at the getWord16be and getWord16le getters.
23:43:29 <JoeyA> import Data.Binary.Get
23:43:33 <JoeyA> runGet (remaining >>= flip replicateM getWord16be . fromIntegral . (`div` 2)) <$> Data.ByteString.Lazy.readFile filename
23:46:01 <mjrosenb> kmc: clearly any time we say 'but it won't get as good performance' we need to add a new optimization to ghc!
23:46:11 <kmc> hehe
23:46:22 * mjrosenb should get ghc working on his ipod touch.
23:46:37 <mjrosenb> although that is likely a *very* bad idea
