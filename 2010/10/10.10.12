00:11:11 <jamy> shut up all :)
00:37:12 <jamy> tell me what: anybody use haskell on production?
00:37:47 <kmc> http://www.haskell.org/haskellwiki/Haskell_in_industry
00:41:56 <jedai> jamy: Yes, Haskell is used in production
00:42:47 <jedai> jamy: Some financial firms use it as a DSL environment to write executable description of exotic products
00:43:53 <jedai> jamy: it has also seen some usage recently to generate secure and fast embedded C code
00:44:52 <jedai> jamy: Galois is one company that use it a lot, check them out, they have some contracts with US national agencies and other interesting things
00:46:24 <jamy> and which os use him for native programming?
00:46:56 <Axman6> jedai: Galois use Haskell for a very wide range of projects, including a DSL which it used for monitoring systems for embedded systems, for NASA
00:47:32 <jamy> cool!
00:48:07 <Axman6> they've also developed a system called Cryptol, for producing cryptographic algorithms
00:49:04 <jamy> Axman: Where you getting this information?
00:49:51 <Adamant> jamy: a series of tubes.
00:50:28 <jamy> tubes? Joking?
00:58:32 <koninkje> Does anyone know if there's a canonical implementation for fixed size lossy priority queues (i.e., only keep the top K)?
00:59:03 <koninkje> ...or know whether that structure has a standard name?
01:01:50 <Jafet> koninkje: depending on how you use it, a cache or a selection algorithm
01:05:07 <koninkje> Ultimately it's for selecting the best solution, But I was just wondering if there was a googleable name for this cross between a pqueue and a buffer ring
01:09:58 <Jafet> For simple needs, there's take n . sort
01:10:58 <koninkje> yeah, not good enough for my needs :(
01:11:23 <koninkje> guess I'll have to implement something on my own
01:11:42 <Jafet> Well, uh, wrap an IntMap or something.
01:14:48 <koninkje> I'd prolly wrap http://code.google.com/p/priority-queues/ instead :)
01:15:33 <koninkje> since I'm using those anyways for my pqueues
01:16:49 <Jafet> Technically though, a pqueue only specifies access to one end.
01:17:30 <republic1n_devil> ok say I have 50 servers
01:17:42 <mjrosenb> republic1n_devil: can i have a server?
01:17:52 <kmc> this will be fun
01:17:57 <kmc> republic1n_devil, you have 50 servers
01:18:10 <republic1n_devil> and they differ slightly in name like server1.silo1.hou
01:18:36 <republic1n_devil> I wrote thsi bash script to iterate through them to check a config file to make sure the most recent softwre got there
01:18:46 <republic1n_devil> I had to write nester for loops
01:18:50 <republic1n_devil> nested
01:18:56 <republic1n_devil> how would one handle that in haskell?
01:19:05 <republic1n_devil> 50 server for 1 app
01:19:08 <republic1n_devil> got 100 apps
01:19:13 <republic1n_devil> work at big website
01:19:58 <mjrosenb> capitalist_demig: it depends what you need to do with it
01:20:04 <quicksilver> koninkje: I'm not sure starting with a pqueue is right.
01:20:19 <quicksilver> koninkje: pqueues are all about rapid access to the head; I think dropping the tail is (relative)ly expensive.
01:20:34 <mjrosenb> capitalist_demig: i'd probably make a single list, then loop over that with mapM or something similar
01:20:36 <quicksilver> koninkje: I suspect you're better off with a Data.Sequence or IntMap. 
01:20:41 <mjrosenb> if that makes *any* sense to you
01:20:43 <koninkje> quicksilver: Yes, I know. Hence asking if someone's already done the hard work
01:20:49 <quicksilver> or a clever fingertree trick.
01:21:30 <koninkje> Well, if you want the top k you can pull them from the head of a BO queue in O(k*logn) and then make a new queue from it; 
01:21:38 <mjrosenb> quicksilver: why do you need to access the end of the queue?
01:21:47 <koninkje> though that assumes you know when it's a good time to do "GC"
01:21:52 <cch> I am learning quasi-quotation. what is wrong with the following sentence: dcl dname = [d|data $dname = IDC {idcName :: String}|]
01:21:53 <cch>  
01:22:15 <koninkje> If I didn't care about keeping them sorted I'd just use a buffer ring
01:22:30 <quicksilver> mjrosenb: I don't, koninkje does :P
01:22:49 <quicksilver> mjrosenb: he wants to only keep the N highest priority items and drop anything that gets shuffled off.
01:22:59 <cch> I don't quite well understand QQ documentation as I can find
01:23:30 <cch> so thanks if any body can help me find out the problem
01:24:14 <mjrosenb> koninkje: so reverse the priority on your queue, and add elements to it until there are more than N, when you start removing the one with the highest weight.
01:25:12 <quicksilver> cch: [d|data $dname = IDC {idcName :: String}|] is fine, in isolation.
01:25:24 <kmc> cch, there's lots of places you're not allowed to splice :/
01:25:29 <quicksilver> cch: what it does (or whether it gives an error) is up to the definiton of the quasiquoter 'd'
01:26:03 <kmc> that's not a quasiquoter in the Language.Haskell.TH.Quote sense
01:26:10 <kmc> it's a plain TH decl quote
01:26:17 <quicksilver> oh.
01:26:37 <cch> [d|..|] has type Q[Dec]
01:26:39 <koninkje> mjrosenb: That could work; though it assumes I don't want to access the answers except at the end...
01:26:42 <kmc> sometimes the plain TH quotes are called "quasiquoters" but the term is now used more to refer to the user-defined «String → Q Exp» sort
01:26:44 <cch> as I learn from doc
01:26:57 <kmc> cch, i don't think you can splice the name with $dname there
01:27:12 <koninkje> mjrosenb: which _might_ be valid, I'll have to see
01:27:32 <kmc> TH splicing support is quite incomplete
01:27:34 <kmc> in GHC
01:27:45 <cch> kmc: ok, then I am learning to use is just plain TH quote
01:28:04 <kmc> yes
01:28:19 <cch> I am trying to do is declare data types programmingly
01:28:30 <kmc> you'll probably have to use the AST-building functions
01:28:34 <cch> so what may be write
01:30:54 <cch> how can I splice something into data type declaration?
01:31:18 <kmc> you can't (in that position)
01:31:21 <kmc> you'll have to write out the AST yourself
01:31:46 <jamy> many interesting! http://www.haskell.org/haskellwiki/Haskell_in_industry
01:31:58 <kmc> DataD [] dname [] [RecC (mkName "IDC") [(mkName "idcName", NotStrict, ConT $ mkName "String")]] []
01:32:01 <kmc> cch, like so perhaps
01:32:57 <cch> ah. I suppose I got you, let me try , thanx
01:51:02 * hackagebot free-theorems 0.3.1.3 - Automatic generation of free theorems.  http://hackage.haskell.org/package/free-theorems-0.3.1.3 (DanielSeidel)
01:56:14 <akamaus> hi, is there some api in cabal for getting the version of installed package?
01:57:18 <akamaus> I mean version which I specify in .cabal file
01:57:49 <akamaus> for example, to output it in the about window.
02:06:51 <Cale> akamaus: ghc-pkg list packagename
02:07:23 <Cale> oh, api for the Cabal library, hmm
02:07:41 <akamaus> Cale, yeah
02:09:18 <akamaus> Cale, I want my program to get it's version information in runtime. I'm lookking for something like getDataFileName but for versions
02:11:29 <Cale> It seems like there must be a way to get hold of values of type InstalledPackageInfo, but I'm not sure what it is.
02:13:42 <Cale> ah, hmm
02:13:57 <Cale> in Distribution.Simple.Configure, we have  getInstalledPackages :: Verbosity -> Compiler -> PackageDBStack -> ProgramConfiguration -> IO (Maybe PackageIndex)
02:14:57 <Cale> Ignoring the parameters to that function for now, a PackageIndex value is handy, because we can then do a lookupPackageName from Distribution.Simple.PackageIndex
02:15:41 <Cale> and that'll give a list of Version values paired with package information on each.
02:18:22 <Cale> Verbosity is an easy parameter to fill. PackageDBStack can be filled with [GlobalPackageDB, UserPackageDB]. The ProgramConfiguration parameter can be emptyProgramConfiguration. We still need a value of type Compiler.
02:18:32 <Cale> configCompiler :: Maybe CompilerFlavor -> Maybe FilePath -> Maybe FilePath -> ProgramConfiguration -> Verbosity -> IO (Compiler, ProgramConfiguration)
02:18:45 <Cale> GHC :: CompilerFlavour
02:19:47 <Cale> So...   (compiler, pc) <- configCompiler (Just GHC) Nothing Nothing emptyProgramConfiguration silent
02:20:46 <Cale> mpi <- getInstalledPackages silent compiler [GlobalPackageDB, UserPackageDB] pc
02:20:57 <Cale> case mpi of Nothing -> ... handle failure ...
02:22:09 <Cale>             Just index -> ... lookupPackageName index (PackageName "mypackage") ...
02:22:42 <Cale> Or... you could just use  ghc-pkg list --simple-output packagename   :)
02:23:29 <Cale> akamaus: Hope that helps
02:25:14 <akamaus> Cale, wow, thats looks scary )
02:25:36 <Cale> ghci> fmap words (readProcess "ghc-pkg" ["list", "--simple-output", "parallel"] "")
02:25:36 <Cale> ["parallel-2.2.0.1","parallel-3.1.0.0"]
02:25:42 <Cale> ^^ so much simpler
02:25:51 <akamaus> probably the easier would be just to autogenerate and link the module
02:26:39 <akamaus> Cale, it would be a binary package, It must not depend on ghc
02:28:04 <akamaus> thanks for your suggestion, it's an interesting way by it's own
02:28:43 <jamy> i am impressive how much soft include in hackagedb o_O
02:36:18 * hackagebot YFrob 0.4 - Yampa-based library for programming robots  http://hackage.haskell.org/package/YFrob-0.4 (TristanSkudlik)
02:42:33 <jkff> Hi. I've got a question on type families. Why the error in this innocent code? http://hpaste.org/40509/type_families_question
02:43:22 <jkff> (it should of course be Diff, not Delta there - an artifact of mixing code from the real program and from the reproducing example)
02:43:56 <Starfire> I don't know the cause exactly, but I'm guessing your problem goes away if you change toDoubles' type sig like this:
02:44:19 <Starfire> toDoubles :: (HasDiff t, t ~ t') => [Delta t'] -> [Double]
02:45:18 <jkff> Starfire: Nope, it doesn't
02:46:25 <jkff> However, the problem *does* go away if I change this from a type family to a data family.
02:46:28 <jkff> Any idea why?
02:46:34 <Starfire> data families are injective.
02:46:52 <blackh1> jkff: toDouble wants a Diff t, but you're giving it a Delta t and they're different.
02:46:54 <jkff> I mean, is this error an artifact of the type checking algorithm, or is my code indeed not "type-correct"?
02:47:08 <blackh1> Where's Delta t defined?
02:47:11 <jkff> blackh1: I meant Diff under Delta.
02:47:13 <sipa> jkff: two types t1 and t2 which satisfy HasDiff may share the same Diff t
02:47:26 <sipa> thus, given a Diff t, it is not possible to infer what t is
02:47:27 <blackh1> Oh, right. :)
02:47:52 <jkff> sipa: But I'm quantifying over the type 't'
02:47:59 <jkff> Ah, I see!
02:48:16 <jkff> When I'll use this function, the compiler won't be able to infer which 't' I meant, based on the Diff t I gave it!
02:48:24 <sipa> indeed
02:48:26 <sipa> if you pass that function something of type t as well, it will work
02:48:49 <jkff> sipa: Well, looks like I'll have to pass a dummy argument indeed
02:48:56 <jkff> I don't want to use data families in this case...
02:55:13 <L29Ah> how do i read and write packets to SOCK_SEQPACKET-type sockets?
02:56:12 <L29Ah> i found {send,recv}Ancillary in Network.Socket, but the api seems to be a bit too low-level and recvAncillary is segfaulting inside the ffi call
02:59:21 <blackh1> L29Ah: Well, that's a difficult question!
03:00:51 <blackh1> It could be that you've gone outside what anyone has attempted to do with that API.  I've found some quirks before and my networking is only "advanced", not extreme like you're trying to do. :)
03:00:54 <L29Ah> also, how do i debug the "network" package? i added -O0 -ggdb to network.buildinfo, but gdb still doesn't show me anything useful
03:01:43 <andern_> if i have a function eval that returns (_, Int), and in a list comprehension i need the Int-part of the answer assigned to a variable, can't i do something like (_, newVal) <- eval something something ?
03:01:53 <L29Ah> so, should i be trying to deal w/ ffi and {recv,send}msg myself?
03:02:30 <Phyx-> andern_: yes
03:02:38 <sipa> andern_: try it :)
03:02:48 <andern_> i have, but i get an error, i might be doing it wrong
03:02:52 <andern_> i can paste one line here right?
03:03:04 <sipa> one line is fine, i suppose
03:03:09 <andern_> [d | (e, d) <- mem, (_, newVal) <- eval mem e, newVal == c])
03:03:17 <quicksilver> if it returns (_,Int) you don't use <-
03:03:20 <blackh1> L29Ah: If the network package doesn't work, then you should probably do your own FFI stuff.  I think that packge doesn't have any C glue code, so gdb won't give you much useful info.
03:03:27 <quicksilver> you'd use <- if it returned [(_,Int)]
03:03:33 <quicksilver> <- (in a list comprehension) is for lists.
03:03:44 <quicksilver> you can put let (_,newVal) = eval mem e
03:03:57 <L29Ah> blackh1: it does, and the segfault is happening within cbits/ancilData.c
03:03:58 <sipa> quicksilver: even inside a list comprehension?
03:04:05 <quicksilver> yes.
03:04:07 <Phyx-> you can have lets inside list comp?
03:04:10 <quicksilver> especially inside a list comprehension.
03:04:11 <quicksilver> yes.
03:04:15 <sipa> good to know
03:04:23 <quicksilver> however, I wouldn't do that in this case.
03:04:37 <blackh1> blackh1: I sit corrected. Well, if you pass the -v option to ghc, which you have to do indirectly if you're building with cabal, you can see what command line it's passing to gcc, so you can check that the -g option is getting to it.
03:04:38 <quicksilver> [d | (e,d) <- mem, fst (eval mem e) == c]
03:04:46 <Phyx-> I'm guessing it's allowed because it's desugerd into using the list monad?
03:04:58 <quicksilver> I wouldn't waste a name on something that's only used once.
03:05:02 <blackh1> L29Ah: ^
03:05:07 <andern_> well, the function returns ([(Expr, Int)], Int)
03:05:14 <blackh1> Too many late nights. I'm talking to myself.
03:05:18 <andern_> where Expr is some data type i have assigned myself
03:05:20 <quicksilver> Phyx-: I'm not sure if that motivation makes sense. It's allowed because it's allowed. It's part of the syntax of list comprehensions.
03:05:25 <quicksilver> andern_: that's not relevant.
03:05:29 * hackagebot timeplot 0.1.8 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.1.8 (EugeneKirpichov)
03:05:36 <quicksilver> andern_: you're not examining the first componenet anyway.
03:06:05 <quicksilver> '<-' in list comprehensions is like a loop, or non-determinism - it takes every value from the RHS (in turn)
03:06:17 <quicksilver> so you only use it when you have multiple values (a list)
03:06:51 <quicksilver> Phyx-: it's true that list comprehensions are very similar to do notation, certainly.
03:07:00 <andern> quicksilver: well thanks a lot!
03:07:07 <andern> that helped clear things
03:07:13 <quicksilver> good :)
03:07:40 <quicksilver> I meant 'snd' not 'fst' in my rewritten version, by the way.
03:07:57 <andern> yeah, i know :)
03:08:28 <sipa> you could write [d | (e, d) <- mem, (_, newVal) <- [eval mem e], newVal == c])
03:08:47 <sipa> but that's overkill
03:10:28 <L29Ah> blackh1: it reaches gcc
03:14:05 <Phyx-> quicksilver: yeah, I was thinking that GHC still just desugars it into monadic style. but I guess since it no longer has general monad comprehension it probably deals with list comprehension differently
03:15:40 <blackh1> L29Ah: In case this is any use: I just tried running gdb on a ghc executable with a C file in it, and I was able to set a breakpoint on one of my C functions.  I did this without -g though.
03:15:52 <blackh1> So I don't think ghc strips symbols or anything silly like htat.
03:16:41 <quicksilver> Phyx-: as I recall, GHC desugars list comps in a special case (directly into Core, not into Haskell) in order to make sure fusion works
03:16:52 <L29Ah> ghc shows me the name of function w/o -g's, but i'd like to see the line number
03:17:00 <quicksilver> Phyx-: but, that's not really the point - the *semantics* of list comps are in the haskell language definition.
03:17:01 <L29Ah> s/hc/db/
03:17:46 <Phyx-> quicksilver: I get what you're saying :) 
03:19:34 <Phyx-> weee it works http://phyx.pastebin.com/iBpAwcd7
03:36:45 <Phyx-> is there a flag in cabal to tell it to autoupdate when it would otherwise suggest the user to update?
03:40:57 <younder> hi all
03:41:03 <blackh1> hello!
03:41:17 <Phyx-> hi
03:46:06 <Phyx-> what's the policy on  hackage about uploading a binary dependency along with the package?
03:59:31 <McManiaC> how does that "do rec" work?
04:00:54 <mm_freak> McManiaC: what is "do rec"?
04:01:06 <mm_freak> do you mean "mdo", i.e. recursive do?
04:01:22 <McManiaC> http://hackage.haskell.org/trac/ghc/ticket/4148
04:01:24 <blackh1> McManiaC: Or do you mean arrows?
04:02:30 <mm_freak> > mdo x <- Just (1:y); y <- Just (2:x); Just x
04:02:31 <lambdabot>   Just [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1...
04:02:46 <mm_freak> the new syntax allows to write 'do rec' instead of 'mdo'
04:02:54 <mm_freak> > do rec x <- Just (1:y); y <- Just (2:x); Just x
04:02:55 <lambdabot>   <no location info>: Parse error in pattern
04:02:59 <mm_freak> > do rec; x <- Just (1:y); y <- Just (2:x); Just x
04:03:00 <lambdabot>   Not in scope: `rec'
04:03:06 <McManiaC> ah okay
04:03:10 <mm_freak> apparently lambdabot doesn't have it yet
04:03:24 <dolio> mdo is gone.
04:03:33 <dolio> Or should be.
04:03:50 <donri> > let doIt = "enough" in Just doIt
04:03:51 <lambdabot>   Just "enough"
04:05:39 <andern> is there an easy way of dropping the head of a list while returning it?
04:06:03 <dolio> > drop 1 [1..10]
04:06:03 <lambdabot>   [2,3,4,5,6,7,8,9,10]
04:06:19 <andern> i want the head returned
04:06:20 <L29Ah> > tail [1..10]
04:06:21 <lambdabot>   [2,3,4,5,6,7,8,9,10]
04:06:22 <andern> not the tail
04:06:33 <dolio> > take 1 [1..10]
04:06:34 <lambdabot>   [1]
04:06:46 <L29Ah> > head [1..10]
04:06:47 <lambdabot>   1
04:06:58 <dolio> > listTomaybe [1..10]
04:06:59 <lambdabot>   Not in scope: `listTomaybe'
04:07:02 <dolio> > listToMaybe [1..10]
04:07:02 <mm_freak> dolio: what's wrong with 'mdo'?  redundancy?
04:07:03 <lambdabot>   Just 1
04:07:38 <dolio> mm_freak: For some reason they wanted the recursivity more tightly delimited, which is what rec does.
04:07:40 <jedai> andern: You use pattern matching to do that
04:07:45 <dolio> I'm not really sure what the motivation is.
04:08:12 <mm_freak> i see
04:08:14 <jedai> andern: Especially since you often need to handle the empty list case too
04:08:53 <jedai> andern : case list of (x:xs) -> yadayada; [] -> other stuff
04:09:03 <mm_freak> is yesod's basicHandler suitable for production?
04:09:20 <andern> jedai: well, i'm not quite sure how to do that. i need to return one specific element in a list comprehension, and after it is returned, that specific item need to disappear the next time it is run :P
04:09:26 <dolio> It probably admits a superior desugaring with less analysis, but I'm not sure how big a deal that is in practice.
04:10:30 <fghj> :r
04:10:42 <jedai> andern: What you're saying doesn't really make sense as such in the context of a pure language (since data is immutable) but if you tell us _what_ you're trying to do (not how), we can probably help you
04:14:55 <andern> jedai: i'm trying to implement some sort of "memory" [(Char, Int)], where it is possible to use the same character multiple times. for instance there can be multiple X's with different values, so that each time X is read, it has to be removed from the memory, so that if X is called more times that it is stored, the program should error out because of an empty list
04:15:01 <andern> not sure if that made any sense at all
04:16:16 <andern> this memory list of tuples is passed as an argument in a function with pattern matching
04:16:16 <mm_freak> andern: it often helps to consider what type your function would have
04:16:33 <benmachine> it makes sense but you're thinking about it in an un-haskelly way; you wouldn't remove it from memory, you'd produce a memory that didn't contain it
04:16:39 <benmachine> or you could use STArray and cheat
04:16:56 <benmachine> but it sounds like you want Data.Map.Map Char [Int]
04:17:34 <mm_freak> lookupAndRemove :: Char -> [(Char, Int)] -> Maybe (Int, [(Char, Int)])
04:17:58 <mm_freak> or follow benmachine's advice, which is to use Map instead of lists
04:18:18 <mm_freak> btw, i'm missing an Eq constraint
04:18:36 <mm_freak> ah, no, i'm not…  i'm not used to write non-polymorphic code =)
04:18:39 <benmachine> heh
04:18:51 <mornfall> :D
04:19:02 <benmachine> lookupAndRemote :: (Eq a) => a -> [(a, b)] -> Maybe (b, [(a, b)]
04:19:08 <benmachine> +)
04:19:16 <mm_freak>  yeah
04:19:17 <mornfall> One Eq-less Int for you.
04:19:27 <mornfall> Or Char.
04:25:16 <mm_freak> yesod looks like great stuff, i might find myself replacing hakyll by it
04:26:37 <mm_freak> now there are two fastcgi implementations, mod_fastcgi and mod_fcgid, what do you people prefer?
04:29:15 <ketil> Let me just verify something: sort is mergesort, so it splits up lists before merging them.  Does that mean that (sort $ map size [big data structures]) has rather poor laziness properties, retaining all the data until the merging step?
04:29:40 <ketil> In contrast to quicksort, which would evaluate all elements by comparing them to a pivot right away?
04:30:19 <dolio> sort is a bottom-up merge sort.
04:30:25 * ketil 's program seems to use unsustainable amounts of memory when sorting a handful (500M) of Ints...
04:30:51 <ketil> dolio, and?  Will it have said laziness behavior?
04:31:08 <ketil> Is there a quicksort in the std libs I can try?
04:31:25 <dolio> I'd have to think about it. I suppose it will keep the underlying data around until the end.
04:31:45 <Ivo> what's the difference between Set.elems and Set.toList?
04:31:50 <Twey> Ivo: Nothing
04:31:52 <ketil> Looks like it: memory profile shows a lot of : and Chunk (bytestrings, from the input data)
04:31:57 <Twey> Ivo: Oh, wait
04:32:05 <Twey> Yes
04:32:06 <Twey> Nothing
04:32:19 <Twey> Also toAscList, though that may be more of an implementation detail
04:32:24 <Ivo> any idea why they have the two different functions then?
04:32:36 <benmachine> ketil: to get the first element of a sort, you need to inspect every element and potentially hold them all in memory
04:32:43 <mm_freak> ketil: i don't think you can sort lazily at all without changing the asymptotic behaviour dramatically
04:32:44 <benmachine> ketil: that's just inevitable
04:33:11 <Jafet> > splitAt 1 [1..10]
04:33:12 <lambdabot>   ([1],[2,3,4,5,6,7,8,9,10])
04:33:34 <mm_freak> ketil: one such sorting algorithm is insertion sort (or something like that, forgot the name), which uses O(n) memory and O(n^2) time
04:33:36 <Jafet> > (head *** id) . splitAt 1 $ [1..10]
04:33:37 <lambdabot>   (1,[2,3,4,5,6,7,8,9,10])
04:34:02 <benmachine> I wrote a sort function once that guaranteed to preserve list length (such that length $ sort [undefined, undefined, undefined] == 3)
04:34:10 <benmachine> but I think it was O(n^2) yeah
04:34:28 <dolio> I think his point is, quicksort evaluates all the elements of the list as part of the partitioning procedure.
04:34:30 <Ivo> insertion and selection sorts are the basic ones
04:34:51 <mm_freak> Jafet:
04:34:52 <dolio> Mergesort partitions and only causes evaluation of the elements when you're merging things back together.
04:35:05 <mm_freak> > (,) <$> head <*> tail $ [1..10]
04:35:06 <lambdabot>   (1,[2,3,4,5,6,7,8,9,10])
04:35:11 <benmachine> right
04:35:12 <dolio> And he has stuff that can be garbage collected once all the elements are evaluated, which happens earlier with quicksort.
04:35:34 <Jafet> You and your applicatives
04:35:45 <mm_freak> ;)
04:35:58 <Peaker> > liftA2 (,) head tail [1..10]
04:35:59 <lambdabot>   (1,[2,3,4,5,6,7,8,9,10])
04:36:15 <mm_freak> > (do h <- head; t <- tail; return (x,y)) [1..10]
04:36:16 <lambdabot>   (x,y)
04:36:17 <Peaker> > head &&& tail $ [1..10]
04:36:18 <Jafet> In that case, fold insert into a Map
04:36:18 <lambdabot>   (1,[2,3,4,5,6,7,8,9,10])
04:36:34 <Peaker> :t [(&&&), liftA2 (,)]
04:36:35 <lambdabot> forall (a :: * -> * -> *) b a1 b1. (Arrow a, Applicative (a b)) => [a b a1 -> a b b1 -> a b (a1, b1)]
04:36:45 <Jafet> Well, but then you can't take anything out until it's sorted
04:36:46 <benmachine> > liftA2 (<$) ((,) <$> head <*> tail) (not . null) $ [1,2,3]
04:36:48 <lambdabot>   Couldn't match expected type `f b'
04:36:48 <lambdabot>         against inferred type `GHC.Bool....
04:36:49 <benmachine> hmm
04:36:54 <benmachine> whoops
04:36:59 <benmachine> > liftA2 (<$) ((,) <$> head <*> tail) (guard . not . null) $ [1,2,3]
04:37:00 <lambdabot>   No instance for (GHC.Show.Show (f (a, [a])))
04:37:00 <lambdabot>    arising from a use of `M645...
04:37:06 <Jafet> Great, I started a bot harem session
04:37:07 <benmachine> hmm
04:37:32 <mm_freak> the laziest sorting algorithm produces output after O(n) equality tests
04:37:33 <benmachine> > liftA2 (<$) ((,) <$> head <*> tail) (guard . not . null) $ [1,2,3] :: Maybe (a. [a])
04:37:34 <lambdabot>   <no location info>: parse error on input `.'
04:37:38 * benmachine cries
04:37:41 <benmachine> > liftA2 (<$) ((,) <$> head <*> tail) (guard . not . null) $ [1,2,3] :: Maybe (a, [a])
04:37:42 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
04:37:42 <lambdabot>    arising from the li...
04:37:48 <mm_freak> the algorithm itself probably is O(n^2)
04:37:52 <benmachine> > liftA2 (<$) ((,) <$> head <*> tail) (guard . not . null) $ [1,2,3] :: Maybe (Integer, [Integer])
04:37:54 <lambdabot>   Just (1,[2,3])
04:37:54 <mm_freak> (unless you use probabilistic sorting)
04:37:56 <benmachine> siiigh
04:38:00 <benmachine> > liftA2 (<$) ((,) <$> head <*> tail) (guard . not . null) $ [] :: Maybe (Integer, [Integer])
04:38:01 <lambdabot>   Nothing
04:38:14 <Jafet> head . sort in ghc is O(n)
04:38:21 <Jafet> Even with the old quicksort I think
04:38:30 <dolio> ketil: It's kind of hard to say, though. Both quicksort and mergesort should enable garbage collection after O(n) comparisons.
04:38:37 <Axman6> i thinik you may be right Jafet 
04:38:52 <dolio> Which actually takes more time, I don't know.
04:39:02 <mm_freak> Jafet: i don't think so…  the first element could be arbitrarily deep in the recursive call stack
04:39:02 <Jafet> Cool, I think so too
04:39:37 <mm_freak> the only algorithm i know of, which guarantees O(n) output for 'head' is insertion sort
04:40:13 <dolio> head . sort is O(n) for an appropriately lazy mergesort.
04:40:39 <mm_freak> dolio: dunno, but i don't think it's O(n) for quicksort
04:40:50 <mm_freak> should be O(n^2)
04:40:56 <Axman6> eh?
04:41:04 <Jafet> Sure it is, uniformly averaged.
04:41:14 <mm_freak> Jafet: O = worst case
04:42:13 <dolio> For a reverse-sorted list, head . quicksort is O(n^2), I think.
04:42:18 <quicksilver> even worst case you have established the first element after 1 partition.
04:42:36 <quicksilver> ah, no that's not true
04:42:42 <quicksilver> the other worst case :)
04:42:48 <quicksilver> is worser.
04:42:57 <mm_freak> dolio: a reversed quicksort is just a quicksort with reversed comparison operator, so i guess it's the same for nonreversed quicksort
04:42:57 <Jafet> Put in a median selection algorithm, then wait for quicksilver to barge in and demand we call it slowersort
04:43:01 <Axman6> the worster worst case
04:43:07 <Jafet> Oh, no need to wait for quicksilver
04:43:35 <mm_freak> horse case
04:43:51 <zygoloid> itym deforested tree sort ;)
04:44:06 <dolio> mm_freak: I don't mean the quicksort is reversed. I mean 'head . quicksort $ [10,9...1]'.
04:44:47 <dolio> After one step, that's: head $ quicksort [9,8..1] ++ 10 : []
04:44:48 <mm_freak> dolio: ah, ok, but that's only true for the obvious qsort implementation, which always picks the head
04:45:16 <dolio> Yes, but better strategies are difficult for a list.
04:45:27 <mm_freak> there are no better strategies anyway
04:45:43 * zygoloid ponders an adaptive partitioning scheme where you don't pick a pivot up-front, but instead keep track of the upper bound of the lower list and the lower bound of the upper list, and try to balance their size
04:45:52 <dolio> And even with a better strategy, you just change what the worst case is. You don't eliminate the worst case.
04:46:11 * Jafet points out that an algorithm of that complexity will only ever be implemented in MMIX.
04:46:32 <mm_freak> there might be better strategies for certain classes of input, but in general picking the head is just as good as picking any other element
04:46:42 <quicksilver> dolio: unless you are prepared to do more than O(1) work picking the pivot, of course :)
04:46:47 <dolio> Right.
04:46:47 <quicksilver> which is self-defeating in another way.
04:47:37 <zygoloid> you can do O(n) work picking the pivot, where n is the size of the list you're partitioning, without hurting the asymptotics, can't you?
04:48:10 <mm_freak> zygoloid: that would make it an O(n^3) algorithm, i guess
04:48:21 <mm_freak> ah, no
04:48:30 <mm_freak> an O(n^2 * log n) algorithm
04:48:54 <zygoloid> mm_freak: no, O(n log n). you pick one pivot per partition, so it's just doubling the partition time
04:49:07 <mm_freak> zygoloid: qsort is O(n^2)
04:49:08 <Jafet> Doubling, for some value of 2
04:49:18 <dolio> Anyhow, even in the average case, you get: head . quicksort $ l = head $ quicksort l1 ++ p ++ quicksort l2 taking O(n) time. It takes O(lg n) steps to get l1 down to a definitive element on average.
04:49:27 <zygoloid> mm_freak: sure, but i can't type the amortized-runtime big O ;)
04:49:31 <mm_freak> you can't reduce it to O(n * log n) by doing /more/ work =)
04:49:35 <dolio> So 'head . quicksort' is O(n lg n) average case.
04:49:40 <mm_freak> ah, i see
04:49:48 <dolio> It's O(n) best case.
04:49:58 <mm_freak> but if you're using an O(n) operation to pick the pivot, you could just as well use insertion sort ;)
04:50:06 <Jafet> You can select the exact median in O(n), use that as the pivot, and get your pretty O(n log n) worst case on paper
04:50:09 <zygoloid> mm_freak: actually, you can. if you pick the median element for each pivot, then it's O(n log n).
04:50:24 <Jafet> Or any pivot a fixed proportion away from the median.
04:50:58 <Jafet> And big O stands for omnomnom constants
04:50:59 <zygoloid> this assumes you can pick the median element in O(n) time, which is kinda the same problem
04:51:19 <mm_freak> zygoloid: why?  what's the advantage of picking the median element?
04:51:31 <dolio> Picking the median divides the array in half.
04:51:36 <dolio> Roughly.
04:51:45 <mm_freak> "roughly" is the keyword
04:52:01 <zygoloid> mm_freak: picking the median element means you do O(n) work log_2(n) times, so it's O(n log n)
04:52:07 <mm_freak> [1, 5] ++ replicate 100 10
04:52:28 <mm_freak> the worst case remains O(n^2)
04:52:33 <zygoloid> no it does not
04:52:54 <zygoloid> picking the median element means you only ever do O(log n) passes
04:52:59 <dolio> That's simple to avoid. Just collect up all elements identical to the median and don't recurse on them.
04:53:03 <zygoloid> the worst case comes when you do O(n) passes
04:53:08 <quicksilver> mm_freak: reasonable quicksort algorithms do not waste time on identical elements
04:53:20 <quicksilver> (including, IIRC, hoare's original description)
04:53:32 * dolio crosses his fingers for a 10.10 reboot.
04:53:35 <quicksilver> you just move the pivot boundaries inwards
04:53:48 <mm_freak> zygoloid: any references?  i find it hard to believe
04:54:35 <zygoloid> start with this: http://en.wikipedia.org/wiki/Quicksort#Selection-based_pivoting
04:54:38 <Jafet> No need to believe -- take the old List.sort (which is still there, commented out...) and trace it
04:54:56 <Jafet> Er well, you'll need to add your own pivot selector
04:55:00 <quicksilver> google for "median of medians" quicksort; but you'll find the results hopelessly polluted by copies of wikipedia :)
04:55:20 <mm_freak> zygoloid: that doesn't state that median pivot selection reduces qsort to O(n * log n)
04:55:23 <fasta> quicksilver, and wikipedia didn't copy it from anywhere?
04:55:28 <zygoloid> mm_freak: or just think about it ;) O(log n) passes, O(n) work per pass = O(n log n)
04:55:41 <fasta> quicksilver, I know of lots of algorithms papers that have been copied word for word on wikipedia.
04:55:41 <quicksilver> as I recall, the reason that C implementations of quicksort don't, in fact, use median of medians is that the constant factor for median of medians is very high
04:55:59 <mm_freak> zygoloid: i'm not convinced that it takes O(log n) passes, that's why i'm asking
04:56:00 <fasta> quicksilver, or let's say the introduction. 
04:56:03 <zygoloid> mm_freak: yes it does. "once we know a worst-case O(n) selection algorithm is available, we can use it to find the ideal pivot (the median) at every step of quicksort, producing a variant with worst-case O(n log n) running time"
04:56:04 <quicksilver> fasta: I claim no such thing. I did not attempt to establish authorship.
04:56:09 <fasta> quicksilver, ok
04:56:33 <zygoloid> mm_freak: but please think about it. O(n) work per step, O(log n) steps.
04:57:03 <zygoloid> (each step being one pass through the entire array, dividing each partition into two equal-sized subpartitions)
04:57:20 <mm_freak> zygoloid: indeed
04:57:40 <mm_freak> thanks, that's interesting
04:57:52 <sipa> quicksort is always O(n log n) average case (but O(n^2) worst case), but using median makes it O(n log n) worst case but with a worse constant factor?
04:58:24 <zygoloid> sipa: yes.
04:58:38 <Jafet> http://xw2k.nist.gov/dads//HTML/luckySort.html
04:59:15 <burp> haha, that had to appear in a sorting discussion :D
04:59:20 <fghj> I'm trying to make a sudoku solver. isOkay is a function that returns true if you can put a number in at the specific
04:59:23 <fghj>  spot. isSolved return True if the sudoku is solved, blank returns the next empty numbers posistion  and update takes
04:59:27 <fghj>  a sudoku, the posistion of the first empty number and the number i want to replace it with. And I'm stuck :(
04:59:30 <fghj> solve :: Sudoku -> Maybe Sudoku
04:59:32 <fghj> solve sud  | not(isOkay sud) = Nothing
04:59:35 <fghj>            | isSolved sud    = Just sud
04:59:38 <fghj>            | otherwise       = head(map solve2 sud')
04:59:38 <mm_freak> what's the median of medians?
04:59:40 <fghj>     where sud' = (filter (isOkay) [update sud (blank sud) (Just x)  | x <- [1..9]])
05:00:15 <Jafet> median . map median
05:00:59 <Jafet> Supposedly, you iterate (map median) until you have one left
05:01:46 <mm_freak> Jafet: what does that mean in the context of qsort, where i don't have a list of lists?
05:01:58 <Jafet> Well that code's wrong anyway
05:02:04 <dolio> You divide it into chunks.
05:07:47 <HaskellN0b> Hello everyone! Having a hard time grasping Haskell, coming from C++ :S Anyways, I'm really unsure on how to declare the functions. For instance, I'd like to give two arguments, i.eg. a char and then a list of chars
05:08:20 <RayNbow`TU> myfunction :: Char -> [Char] -> ResultType
05:09:11 <sipa> HaskellN0b: note that it isn't required to declare functions, usually when you define them, their type will be inferred automatically
05:09:20 <sipa> (at compile time, not runtime)
05:09:35 <HaskellN0b> I'm using an interpreter :)
05:10:01 <mm_freak> then compile time = the time just before interpretation
05:10:15 <HaskellN0b> :)
05:10:18 <Axman6> HaskellN0b: in ghci, use let foo c cs = ...
05:11:22 <sipa> HaskellN0b: put differently, even if you don't specify the type of a function, it has a static type that is used and verified
05:11:42 <sipa> contrary to languages that do no have static types at all (like PHP)
05:11:43 <Axman6> i think you're missing the point of the question sipa 
05:11:50 <ketil> Okay, I'm back and looking over my replies.  I'd like to say thanks, but somehow I think I should rather apologize for starting this :-)  Anyway: Data.List.sort is lazy, thus huge memory footprint, naive quicksort is strict, and thus relatively small.  But maybe I should really stash values in an IntSet instead.
05:12:20 <sipa> Axman6: he's asking how to declare functions - i want to tell him that although he can, there is much less need to do so than in the languages he knows
05:12:28 <ski> HaskellN0b : you're using Hugs ?
05:12:45 <ketil> ...as 'relatively small' is still substantial in absolute terms.
05:12:48 <Axman6> sipa: i think he wants to know how to define functions in ghci/hugs
05:13:15 <HaskellN0b> How would I go about creating a new list from an existing list given it matches a certain condition? Right now I'm looking at the head and comparing it, continuing to the tail through recursioncalls, but how to create a new list is beyond me at this point :)
05:13:19 <mm_freak> sipa: you're assuming that "declaring" means "giving type signature"
05:13:31 <mm_freak> probably, being a non-haskeller, HaskellN0b has a different notion of "declaring"
05:13:50 <ddarius> mm_freak: That's not the Haskell notion.
05:14:15 <Axman6> HaskellN0b: filter
05:14:18 <Axman6> :t filter
05:14:19 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
05:14:36 <sipa> mm_freak: no, i'm assuming that he thinks that's what it means :)
05:14:42 <mm_freak> HaskellN0b: you should tell us, what you're trying to do, first
05:14:52 <mm_freak> sipa: that's what i meant =)
05:14:53 <sipa> mm_freak: oh, the other way around
05:15:47 <mm_freak> HaskellN0b: the way you solve problems differs considerable between haskell and C++
05:15:47 <ddarius> mm_freak: In fact, arguably "declaring" does mean "giving a type signature" in C++ versus defining a function.
05:15:49 <HaskellN0b> It's a lab assignment so I don't just want to hand over the assignment.. although it feels as if I've already have, hehe :)
05:16:13 <HaskellN0b> I meant declaring a function, as takeEqual:: String -> [String] -> [String]
05:16:31 <ski> HaskellN0b : typically you create empty lists by `[]' and non-empty lists by `foo : foos', given an element `foo' to be the head, and a list of elements `foos', to be the tail
05:16:36 <Axman6> so giving its type? or defining the function itself?
05:16:47 <sipa> HaskellN0b: anyhow, summary: compared to C, there is no difference between declaring or defining a function... what you do have in Haskell is giving the type signature and giving the value (=function definition), of which the first is optional most of the time
05:17:11 <Axman6> HaskellN0b: i'd suhhest you take a look at a tutorial, for example, LYAH:
05:17:13 <mm_freak> ddarius: there are no type signatures in C++…  there is defining (giving the function's code) and declaring (noting the function's existence), although because of name mangling a declaration accounts for a type signature to some extent
05:17:14 <Axman6> @where lyah
05:17:15 <lambdabot> http://www.learnyouahaskell.com/
05:17:35 <ski> HaskellN0b : then there's some sugar for this, and you can also create lists indirectly, by calling function which directly (or indirectly) creates lists
05:17:53 <mm_freak> HaskellN0b: that's "writing a type signature", i.e. being more explicit =)
05:18:05 <mm_freak> you don't "declare" functions in haskell
05:18:39 <sipa> you just write the function, and it exists... you can even call functions which are defined further down in the source file
05:18:39 <ddarius> mm_freak: I was quoting your terminology for parallelism.
05:19:35 * ski . o O ( "I hereby declare C++ `null' and `void' !" ? )
05:19:55 <ski> (or s/null/NULL/, i suppose)
05:20:05 <sipa> #define null NULL
05:20:06 <sipa> done
05:20:33 <Zao> nullptr :D
05:20:40 <mm_freak> :t nullPtr
05:20:42 <lambdabot> Not in scope: `nullPtr'
05:20:48 <mm_freak> :t Foreign.nullPtr
05:20:49 <lambdabot> forall a. GHC.Ptr.Ptr a
05:21:16 <HaskellN0b> So am I going about this the right way? myFunc y (x:xs) = if y == x then (add to list in some manner I don't understand) else myfunc xs
05:21:44 <ski> that looks like it could work out
05:22:05 <mm_freak> myFunc y (x:xs) = if x == y then x : myFunc y xs else myFunc y xs
05:22:08 <Axman6> well, first problem is, where did y go in the recursive call to myfunc?
05:22:17 <mm_freak> but explicit recursion is usually not necessary
05:22:26 <Axman6> bah, just giving the answers means people learn nothing -_-
05:22:29 <mm_freak> > filter (== 3) [1..5]
05:22:30 <lambdabot>   [3]
05:23:16 <mm_freak> Axman6: direct answers help understanding concepts, while indirect answers help using them
05:23:32 <mm_freak> apparently HaskellN0b has difficulties with the concept, not with its usage
05:23:46 <HaskellN0b> hehe, I believe your right :)
05:23:57 <mm_freak> the "add to list in some manner" suggests this, because he's probably thinking imperatively
05:24:06 <sipa> HaskellN0b: do you understand why mm_freak's answer is correct?
05:24:43 <sipa> (or even better, could you tell it's wrong?)
05:25:06 <HaskellN0b> hehe
05:25:52 <HaskellN0b> I think I get it, as the ":" creates a list with head and tail you could use the return value of a function to create the tail if it returns a list, ye?
05:26:11 <sipa> correct
05:26:14 <mm_freak> HaskellN0b: no list is "created", x:xs "is" a list
05:26:25 <sipa> a list is either [], the empty list
05:26:26 <mm_freak> there is no "creating" and "changing" in haskell, there is "being"
05:26:52 <sipa> or it is a:b, in which a is an element of the list, and b is the rest (another list)
05:27:09 <HaskellN0b> So Haskell is carpe momentum whereas c++ is carpe diem? ;)
05:27:25 <sipa> > t 1:2:[3]
05:27:26 <lambdabot>   Couldn't match expected type `t -> a'
05:27:27 <lambdabot>         against inferred type `Simple...
05:27:36 <sipa> :t 1:2:[3]
05:27:37 <lambdabot> forall t. (Num t) => [t]
05:27:48 <sipa> > 1:2:[3]
05:27:49 <lambdabot>   [1,2,3]
05:28:36 <frerich3> mm_freak: Hmm, I'm a Haskell newbie myself - I hope you don't mind me chipping in. Is it possible to write such patterns recursively (so that instead of "x:xs" I could write something like "xs:[x]:[y]" in order to extract the last and second-last elemtn?
05:28:47 <frerich3> Ah,. no, sorry
05:29:01 <frerich3> That doesn't make sense - the argument to ':' is not a list
05:29:27 <mm_freak> frerich3: you can encode the end of a list, but then it has a fixed length
05:29:35 <ski> frerich3 : no, a list like `[0,1,2,3]' really is `0 : (1 : (2 : (3 : [])))', and you can only match on the constructors, i.e. `(:)' and `[]' here
05:29:51 <sipa> frerich3: you can write this:
05:30:00 <mm_freak> > (\(_:_:x:y:[]) -> x + y) [1,1,2,3]
05:30:01 <lambdabot>   5
05:30:08 <sipa> let (a:b:c) = someList
05:30:23 <sipa> to extract the first and second element of it (a and b), and the rest of the list in c
05:30:28 <mm_freak> sipa: frerich3 is asking for the end of the list
05:30:35 <ski> frerich3 : it would make sense to say `foo (xs ++ [x,y]) = ...', but that kind of patterns are not allowing in Haskell, only matching on constructors
05:30:36 <sipa> yes, i noticed that too late :)
05:30:55 * frerich3 nods
05:31:35 <mm_freak> ski: with one exception, n+k patterns =)
05:31:39 <ski> (btw, Mercury allows that kind of patterns)
05:31:49 <ski> mm_freak : *nod*
05:32:02 <frerich3> That aside, I'm now wondering - is it accurate to say that the argument to ':' is not a list? I was thinking that the signature of ':' is something like '(:) :: a -> [a] -> [a]' and that due to currying, the only "real" argument is the "a" (after that you just get a curried function back taking one argument, [a]).
05:32:16 <mm_freak> frerich3: (:) has two arguments
05:32:20 <mm_freak> :t (:)
05:32:21 <lambdabot> forall a. a -> [a] -> [a]
05:32:38 <sipa> in the very strict sense, it has indeed only one argument, the new element
05:32:38 <mm_freak> > (:) 3 [4,5]
05:32:39 <lambdabot>   [3,4,5]
05:32:52 <mm_freak> sipa: the type signature tells a different story =)
05:32:56 <frerich3> mm_freak: Well I'm not that deep into Haskell yet but I think that's just a convenience feature so that you don't have to express the currying explicitely.
05:32:58 <sipa> mm_freak: not true
05:33:10 <sipa> mm_freak: a -> [a] -> [a] means a -> ([a] -> [a])
05:33:19 <frerich3> mm_freak: The signature actually expresses that ':' is a function taking an 'a' and returning an ([a] -> [a]), i.e. a new function.
05:33:27 <ski> frerich3 : note that one instance of `(:) :: a -> [a] -> [a]' is `(:) :: [Char] -> [[Char]] -> [[Char]]', in which case the first (or only, if you will) argument would have to be a list
05:33:40 <mm_freak> sipa: you could go ahead and say that there are no binary functions in haskell, but then the arity of a function is meaningless
05:33:43 <frerich3> ski: Good point, I didn't raelize that 'a' itself could be a list.
05:33:47 <quicksilver> frerich3: it's quite sensible to describe that as one argument or as two.
05:33:59 <sipa> mm_freak: yes, strictly speaking a function in haskell takes exactly one argument
05:34:07 <quicksilver> it's more common, in everyday haskell parlance, to call it two.
05:34:12 <sipa> though there is syntactic sugar to make it easy
05:34:31 <mm_freak> sipa: for arity to be a useful concept, one has to remove all parentheses
05:34:40 <sipa> > (:) 1 []
05:34:41 <lambdabot>   [1]
05:34:46 <sipa> :t (:) 1
05:34:47 <lambdabot> forall t. (Num t) => [t] -> [t]
05:35:10 <ski> frerich3 : the `a' (or any identifier starting with lower-case) in a type signature like `(:) :: a -> [a] -> [a]' is called a "type variable". the idea is that type variables could be any type you (the caller) likes, but all the `a's must be the same type, for each use of the operation
05:35:43 <frerich3> ski: Yes, true - I gathered that much already but somehow, in this case, the 'a -> [a]' part didn't make me realize that 'a' itself could be a list of something.
05:35:58 <ski> frerich3 : so `(:) :: [Char] -> [[Char]] -> [[Char]]' is one possible use. another is `(:) :: Bool -> [Bool] -> [Bool]', &c.
05:36:02 <mm_freak> (but with that constraint only, all functions in haskell have infinite arity)
05:36:08 <frerich3> Thanks for clearing this up guys, it's quite interesting to follow this channel. :-)
05:36:16 <ski> frerich3 : yeah, it is easy to forget
05:36:53 <sipa> mm_freak: infinite? no, given an expression's type, you can immediately see how many times it may be applied to a value
05:36:55 <ski> frerich3 : btw, note that e.g. `head' in some cases is a function taking more than one argument .. can you see how ? :)
05:37:29 <mm_freak> sipa: no, you can't…  (a -> a) unifies well with (a -> a) -> a -> a
05:37:43 <mm_freak> now what if a = (b -> b)?
05:37:43 <frerich3> ski: It could be a list of functions, right?
05:37:45 <mm_freak> etc.
05:37:51 <ski> frerich3 : right ! :)
05:37:57 <frerich3> Tricky
05:38:01 <ski> > head [sin,cos,tan] pi
05:38:02 <lambdabot>   1.2246467991473532e-16
05:38:06 <mm_freak> sipa: in other words, the arity of 'id' depends on its argument
05:38:08 <ski> > head [sin,cos,tan] (pi/2)
05:38:08 <lambdabot>   1.0
05:38:11 <sipa> mm_freak: you're right
05:38:20 <frerich3> ski: It helps me a lot to 'reduce' statements to the bare metal in order to explain such things
05:38:33 <mm_freak> but i was lying, not every function has infinite arity
05:38:45 <sipa> only some polymorphous functions do
05:38:45 <mm_freak> but every fully polymorphic one
05:38:53 <sipa> polymorphic
05:39:07 <ski> (frerich3 : hm .. "reduce", how ?)
05:39:20 * hackagebot DTC 1.0.0 - Data To Class.  http://hackage.haskell.org/package/DTC-1.0.0 (DanielDiaz)
05:39:35 <Palmik> Is it somehow posible to serialize and deserialize the following data structure (Map Char [Bool], [Bool])? Where the map and lists can be of arbitrary length. Are there some materials I might be interested in order to solve this?
05:39:48 <mm_freak> frerich3: one piece of advice, which is always helpful:  if you don't know how to write a function, write its type signature first
05:40:05 <mm_freak> then often suddenly everything becomes clear
05:40:08 <sipa> Palmik: show and read?
05:41:07 <sipa> > (Map.fromList [('a',[]),('b',[False])],[True,False])
05:41:08 <lambdabot>   Not in scope: `Map.fromList'
05:41:13 <sipa> > (Data.Map.Map.fromList [('a',[]),('b',[False])],[True,False])
05:41:13 <lambdabot>   Not in scope: `Data.Map.Map.fromList'
05:41:16 <Palmik> sipa, hmm... even if I want to save them in binary?
05:41:18 <sipa> > (Data.Map.fromList [('a',[]),('b',[False])],[True,False])
05:41:19 <frerich3> ski: I meant "reducing" in the sense that "f :: a -> a -> a" is, at the core, a function which takes a value of some type 'a' and returns another function. So at the 'core', every function takes one argument and returns one.
05:41:19 <lambdabot>   Not in scope: `Data.Map.fromList'
05:41:25 <Axman6> :t M.fromList
05:41:27 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
05:41:28 <mm_freak> Palmik: see the 'binary' package
05:41:29 <frerich3> ski: I hope that makes some sense, I find it hard to express :-}
05:41:59 <ski> > M.fromList [('a',([False],[])),('b',([True],[True,False]))] :: M.Map Char ([Bool],[Bool])  -- Palmik ?
05:42:00 <lambdabot>   fromList [('a',([False],[])),('b',([True],[True,False]))]
05:42:22 <mm_freak> frerich3: i don't think there is anything wrong with viewing a -> a -> a as one binary function =)
05:42:39 <mm_freak> "reducing" this to a -> (a -> a) only helps to understand currying
05:43:09 <ski> frerich3 : yes. it's a good thing to do that, when learning
05:43:10 <frerich3> mm_freak: The slightly odd thing about viewing it as a binary function is that the syntax doesn't seem to make too much sense. Why do you use '->' all the time instead of separating arguments from the return value?
05:43:34 <mm_freak> frerich3: because (->) is an ordinary type constructor
05:43:34 <frerich3> I remember that was one of the first things I asked myself.
05:43:42 <mm_freak> (->) a b = a -> b
05:43:54 <mm_freak> and it's right-associative
05:43:57 <mm_freak> that's it
05:44:12 <frerich3> Right, so a -> a -> a invokes the type constructor *twice*
05:44:23 <dolio> It's nicer than taking a tuple of arguments.
05:44:32 <mm_freak> yes, just like 3 + 4 + 5 invokes (+) twice =)
05:44:33 <dolio> It lets you partially apply things nicely, for instance.
05:44:41 <ski> @type [sin,cos,tan] `asTypeIn` \functions -> head functions (pi / 2 :: Float)
05:44:42 <lambdabot> [Float -> Float]
05:45:00 <Palmik> ski, well I meant (Map Char [Bool], [Bool]) but anyway, is not that just converting list to a map? By "serialize" and "deserialize" I meant save to a file in binary (not  as a text) and then read it back. But I guess that mm_freak's suggestion of Data.Binary is the way to go
05:45:37 <dolio> map f instead of \l -> map (f, l)
05:46:28 <ski> Palmik : i constructed a map by converting it from a list, then that map was `show'n by converting back to a list, and showing that (plus an initial `fromList') .. but if you want non-text, then i think `binary' is useful, yes
05:46:46 <ski> dolio : even SML has curried `map' :)
05:46:59 <sipa> Palmik: if you want it to be binary, that's the way to go
05:47:11 <dolio> ski: It must be good, then, because they go out of their way to not curry things.
05:47:37 <Palmik> ok, thanks you sipa, ski and mm_freak :)
05:47:47 <Palmik> *thank
05:48:00 <ski> yw
05:49:44 <taruti> Does any of the FRP libraries support writing a networked app in FRP style, and is there any example of this?
05:50:43 <mm_freak> taruti: the generic ones do, like yampa and elerea, if you write the networking stuff yourself
05:51:16 <mm_freak> i.e. the actual communication and protocols
05:51:24 <taruti> mm_freak: has anyone done it already? I know it is possible in theory but having an example would be nice.
05:52:05 <mm_freak> i don't think so, but also i don't think that writing a network application is any harder than writing a game
05:52:38 <taruti> just doing it right without experience with the frp libraries and no examples is probably frustrating
05:53:08 <mm_freak> then write something else as your first FRP application, like a particle simulator
05:53:51 <mm_freak> that way you learn how to write FRP applications in general and how the signal transformers interact with the real world
05:56:17 <HaskellN0b> So back to my problem of understanding.. If I get this right, the result will be a list, containing a list, containing a list etc.. myFunc 1 123123123 will mean [1,[1,[1,]]] in a matter of speaking?
05:56:51 <HaskellN0b> but this will be represented by [1,1,1] in the output?
05:57:01 <sipa> > [1,1,1]
05:57:02 <lambdabot>   [1,1,1]
05:57:06 <mm_freak> HaskellN0b: the result is a list
05:57:08 <sipa> > 1:1:[1]
05:57:09 <lambdabot>   [1,1,1]
05:57:12 <mm_freak> just a "list"
05:57:14 <sipa> > 1:(1:[1])
05:57:15 <lambdabot>   [1,1,1]
05:57:53 <mm_freak> but consider what a list is:  it's either the empty list or an element prepended to a list
05:58:06 <mm_freak> or in haskell terms:  data List a = Empty | Prepend a (List a)
05:58:37 <mm_freak> this type is isomorphic to (just another representation of) the real list type
05:58:47 <mm_freak> data [a] = [] | a:[a]
05:59:53 <mm_freak> Empty is a list, and so is Prepend 3 Empty, and so is Prepend 2 (Prepend 3 Empty)
06:00:09 <mm_freak> similarly [] is a list, just like 3:[] and 2:(3:[])
06:00:19 <mm_freak> because (:) is right-associative, you can omit the parentheses
06:00:20 <Phyx-> are you just talking to yourself?
06:00:29 <mm_freak> Phyx-: to HaskellN0b 
06:00:35 <Phyx-> lol, ok
06:01:25 <sipa> HaskellN0b: [a] is syntactic sugar for (a:[]), [a,b] is sugar for (a:(b:[])), and so on
06:01:49 <ski> HaskellN0b : .. so `[2,3,5,7]' is "just" syntactic sugar for `2 : (3 : (5 : (7 : [])))'
06:02:14 <ski> the latter is the "primitive" way of writing it
06:02:24 <ski> the former is just a handy shorthand
06:02:40 <mm_freak> it's not a shorthand actually =)
06:02:46 <mm_freak> but it looks nicer
06:03:13 <mm_freak> oh yes, it is a shorthand, by one character
06:03:28 <frerich3> It's a bit confusing that the value of the empty list ("[]") has the same name as the type constructor. Or am I being too confused now?
06:03:32 <mm_freak> > map length ["1:2:3:[]", "[1,2,3]")
06:03:33 <lambdabot>   <no location info>: parse error on input `)'
06:03:37 <mm_freak> > map length ["1:2:3:[]", "[1,2,3]"]
06:03:38 <lambdabot>   [8,7]
06:03:54 <sipa> frerich3: you mean that [] is both a value expression and a type expression?
06:03:55 <mm_freak> frerich3: no, that's right
06:04:11 <frerich3> sipa: Yes, I only realized that now after reading through the backlog a bit.
06:04:12 <mm_freak> there is a type constructor [] and a data constructor []
06:04:15 <taruti> mm_freak: any insights into reactive vs eleria vs yampa?
06:04:18 <ski> frerich3 : your observation is correct. the value (a data constructor) `[]' and the type (constructor) `[]' is spelled the same
06:04:33 <sipa> frerich3: if you write data Bla = Bla String, you get the same
06:04:43 <sipa> but yes, you are rgiht
06:04:44 <sipa> right
06:05:06 <dcoutts> Phyx-: re your earlier Qs, I'm not sure what you mean in either case! :-) What about autoupdating? and what about uploading a binary dependency?
06:05:17 <ski> frerich3 : but note that there can be no confusion to Haskell, since there is no context in which both a value/expression and a type would be expected/valid .. either one is expected, or the other (or something else)
06:05:22 <mm_freak> taruti: i've used elerea and yampa, but only for small tests…  i wrote a particle simulation in elerea and a physics simulation in yampa…  yampa appeared to be more elegant, but it has some shortcomings
06:05:38 <taruti> what kind of issues?
06:06:01 <quicksilver> frerich3: yes, it's very confusing, in my opinion.
06:06:02 <Phyx-> dcoutts: Oh well, I was just wondering if there was a flag (or a setting) I could set that instead of being told by cabal "your package database is xx days old" that it would just go ahead and update it
06:06:11 <mm_freak> flexibility, for example i'm forced to use IORefs for state instead of some custom monad other than IO
06:06:12 <quicksilver> frerich3: and teh confusion is compounded by the fact that [1,2,3] is special syntax :)
06:06:43 <quicksilver> frerich3: [] the data constructor is nullary, [] the type constructor is unary (but conventionally written with the argument inside the [])
06:06:47 <ski> quicksilver : you'd prefer something like the approach in the ML's, then ?
06:06:55 <Phyx-> dcoutts: and the second part was, I have a package, but it depends on a dll that's not haskell code. So I'm wondering what the common way to include such packages are. just tell the user to get the dll elsewhere or just package it along
06:06:55 <quicksilver> frerich3: and [,,,,,] the special syntax is N-ary
06:07:08 <quicksilver> ski: I don't know that I'd prefer that. I just agree this is a source of initial confusion.
06:07:21 <mm_freak> taruti: that was for you
06:07:26 <dcoutts> Phyx-: ah, well I don't want to do that at the moment for a couple reasons, one it's slow to download (need to implement a more incremental update) and two, it gives you a consistent snapshot, each time you update then it changes what decisions cabal install might make.
06:07:44 <quicksilver> ski: I value the brevity of the haskell solution, once you understand it.
06:07:47 <taruti> ok
06:07:52 <dcoutts> Phyx-: there's no supported way to have binaries in hackage packages
06:07:58 <ski> quicksilver : ok
06:08:15 <dcoutts> Phyx-: currently you just tell the user to get it
06:08:43 <frerich3> quicksilver: Oh that's a nice mental model (the nullary vs. unary explanation)! I was just thinking of cases like 'f :: a -> [a]' and 'f (a:[]) = a', trying to explain whether it's a type or a data constructor (I think in the former case it's a type, in the latter it's a data constructor).
06:08:44 <HaskellN0b> I understand perfectly now! :D
06:08:49 <Phyx-> dcoutts: ah ok, cool, thanks :)
06:08:55 <HaskellN0b> 1:(1:(1:[]))
06:09:02 <HaskellN0b> haskell rules
06:09:34 <frerich3> quicksilver: So when you say that the argument to the type constructor [] is conventionally written inside the [], do you meant to imply that it can be written after the [] as well? e.g. "f :: a -> ([] a)" or osmething like that?
06:09:48 * frerich3 feels his head starting to spin
06:09:56 <mm_freak> frerich3: yes
06:10:11 <dcoutts> Phyx-: for updating the package list, supposing we had a quicker method to get just the changes, not the whole index, then it's not clean when we should do it. The current warning is a totally arbitrary number of days.
06:10:14 <mm_freak> > let f :: a -> [] a; f x = x : f x in f 3
06:10:15 <lambdabot>   [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
06:10:48 <mm_freak> [a] is just syntactic sugar for [] a
06:11:01 <aristid> :k []
06:11:02 <lambdabot> * -> *
06:12:18 <Phyx-> dcoutts: how often are packages packaged up on hackage into that .tar.gz file? you could have cabal check just once a day or something for a md5 of that package, to see if things changed (or just timestamp) and keep a series of changesets on the web aswell, that would get you incremental updates for xx last versions
06:12:22 <ski> @let select :: [a] -> [] (a,[a]); select [] = []; select (a:as) = (a,as) : liftM (fmap (a :)) (select as)
06:12:23 <lambdabot>  Defined.
06:12:40 <ski> > select "frerich3"
06:12:41 <lambdabot>   [('f',"rerich3"),('r',"ferich3"),('e',"frrich3"),('r',"freich3"),('i',"frer...
06:12:52 <aristid> @index select
06:12:53 <lambdabot> Text.Html
06:13:03 <aristid> @hoogle select
06:13:04 <frerich3> mm_freak: Are type constructors first-class functions? I.e. could I have a list of type constructors and then do 'meta programming' by having a function whose signature is described by a list of type constructors?
06:13:04 <lambdabot> Text.Html select :: Html -> Html
06:13:04 <lambdabot> Text.XHtml.Frameset select :: Html -> Html
06:13:04 <lambdabot> Text.XHtml.Strict select :: Html -> Html
06:13:07 <ski> > select "abcd"
06:13:08 <lambdabot>   [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
06:13:13 <dcoutts> Phyx-: the index is updated live, every time a package is uploaded, so about 15-20 times a day.
06:13:23 <aristid> select is a @let, eh?
06:13:32 <aristid> oh right, it is
06:13:46 <ski> frerich3 : type constructors which take arguments are functions, sortof, but on the type-level, not the value-level
06:14:13 <ski> frerich3 : since types don't really exist at run-time in Haskell, you can't put them in lists
06:14:16 <frerich3> ski: I see. Is there a 'meta type' level in which ordinary types are values?
06:14:26 <aristid> :t \f -> liftM (fmap f)
06:14:27 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => (a -> b) -> m (f a) -> m (f b)
06:14:35 <ski> frerich3 : .. however, dependently typed programming languages like Agda supports that
06:14:39 <aristid> :t (.).(.)
06:14:40 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
06:15:02 <quicksilver> mm_freak, frerich3: actually, no.
06:15:04 <ski> frerich3 : in Haskell there's three levels : (a) values; (b) types; (c) kinds
06:15:10 <quicksilver> As far as I know, "[] a" is a GHC extension, not haskell.
06:15:31 <aristid> ski: you found a use for generalised fmap-based (.:) :D
06:15:49 <mm_freak> frerich3: type constructors are first-class, but type functions are not
06:16:02 <ski> quicksilver : it works fine in Hugs, too
06:16:23 <sipa> how are type constructors first class?
06:16:24 <ski> aristid : .. where ?
06:16:32 <mm_freak> frerich3: and they are only first-class in the type system, because at run time all types are gone
06:16:55 <sipa> ah yes, you can 'pass' a type constructor as argument in the type level
06:17:09 <mm_freak> but you can actually do type-level metaprogramming using type classes and fundeps or alternatively type families
06:17:10 <aristid> ski: you used liftM . fmap
06:17:28 <aristid> ski: which incidentally is identical to (.).(.) in Caleskell, which in turn is how i define (.:)
06:17:46 <mm_freak> quicksilver: are you sure?  GHC accepts that without any extensions
06:18:04 <ski> aristid : ok .. yes, i introduced the name `.:' to this channel a long time ago :)
06:18:04 <Phyx-> dcoutts: hm, what I suggested/had in mind would generate too many files/diff files. I figured, the message is only relevant when a package you use changed. or when installing a package that the server has a newer version of.
06:18:08 <mm_freak> and after all you can write:  instance SomeClass [] where …
06:18:30 <ski> frerich3 : .. so, we say `False :: Bool' to say that the value `False' has type `Bool' .. similarly for `not :: Bool -> Bool'
06:18:39 <quicksilver> ski: atype -> .. snip ... [ type ]   # (list type)
06:18:47 <quicksilver> from http://www.haskell.org/onlinereport/syntax-iso.html
06:19:06 <quicksilver> hmmm, but
06:19:13 <quicksilver> [] still matches tycon.
06:19:13 <ski> frerich3 : then, on the next level we say `Bool :: *' to say that the type `Bool' has kind `*', meaning that it is a "complete" type, one which can have values
06:19:16 <quicksilver> you're probably right :)
06:19:20 * quicksilver apologises.
06:19:24 <aristid> :t let (.:) = fmap.fmap; select :: [a] -> [] (a,[a]); select [] = []; select (a:as) = (a,as) : ((a :) .: select as) in select
06:19:25 <lambdabot> forall a. [a] -> [(a, [a])]
06:19:34 <aristid> ski: the .: makes it nicer :)
06:20:21 <ski> frerich3 : otoh, `Maybe :: * -> *' says that `Maybe' has kind `* -> *', so `Maybe' is not a "complete type" .. you have to apply it like `Maybe Bool' or `Maybe (Int -> Bool)' to make a "complete type"
06:20:39 <ski> frerich3 : now, similarly to that, we have `[] :: * -> *'
06:20:58 <ski> frerich3 : and in Haskell, that's the end of it .. the is no "type of kinds" in Haskell
06:21:15 <frerich3> ski: Does is this 'completness' transitive? As in, Is "Maybe (Maybe)" incomplete because the inner type is incomplete?
06:21:16 <ski> frerich3 : .. but in e.g. Agda there is !
06:21:29 <mm_freak> ski: i differentiate between "type constructor" and "type" as opposed to "incomplete type" vs. "complete type"
06:21:45 <mm_freak> 'sin' is not an incomplete value, after all =)
06:22:11 <mm_freak> frerich3: Maybe Maybe is not even possible
06:22:15 <ski> frerich3 : `Maybe (Maybe)' is a kind error. the outer `Maybe' is a type function (in this case a type constructor) having kind `* -> *', so it wants a type argument of kind `*', and will then give back a type result of kind `*'
06:22:22 <mm_freak> that would require Maybe to be of kind (* -> *) -> *
06:22:32 <mm_freak> but Maybe is of kind * -> *
06:22:36 <ski> frerich3 : but the inner `Maybe' has kind `* -> *', which doesn't match `*', so there's a kind error
06:22:37 <mm_freak> so it cannot take itself as argument
06:22:58 <ski> frerich3 : this is similar to `not (not)', but on the type-level, instead of at the value-level
06:23:05 <ski> @kind Mu Maybe
06:23:05 <lambdabot> *
06:23:08 <ski> @kind Maybe
06:23:09 <lambdabot> * -> *
06:23:10 <ski> @kind Mu
06:23:11 <lambdabot> (* -> *) -> *
06:23:17 <aristid> @hoogle Mu
06:23:18 <lambdabot> Text.Html multiple :: HtmlAttr
06:23:18 <lambdabot> Text.XHtml.Frameset multiple :: HtmlAttr
06:23:18 <lambdabot> Text.XHtml.Strict multiple :: HtmlAttr
06:23:23 <aristid> where is Mu from?
06:23:30 <mm_freak> nowhere i guess
06:23:32 <mm_freak> @src Mu
06:23:32 <ski> @index Mu
06:23:32 <lambdabot> bzzt
06:23:33 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
06:23:47 <mm_freak> it's just 'fix' for types
06:24:19 <ski> > Mu [Mu [],Mu [Mu [Mu []],Mu []],Mu [Mu []]]
06:24:20 <lambdabot>   Not in scope: data constructor `Mu'Not in scope: data constructor `Mu'Not i...
06:24:38 <ski> > In [In [],In [In [In []],In []],In [In []]]
06:24:39 <lambdabot>   In [In [],In [In [In []],In []],In [In []]]
06:24:43 <ski> @type In [In [],In [In [In []],In []],In [In []]]
06:24:44 <lambdabot> Mu []
06:25:18 <ski> frerich3 : i here used "complete type" (not a standard term) to refer to types which have kind `*'
06:25:32 <frerich3> ski: Ok I have other crazy questions on my mind but I think that I will refrain from asking them right now for the sake of maintaining sanity. It's a bit intense to hop back and forth between the different levels.
06:25:38 <ski> frerich3 : the types with kind `*' are the only types which can possibly have values
06:25:45 <frerich3> FWIW, my longest Haskell program was 11 lines :-]
06:26:02 <frerich3> but there's already a lot to learn in 11 lines :)
06:26:13 <sipa> the question is: how long where those lines?
06:26:17 <frerich3> hehe
06:26:22 <frerich3> Less than eighty columns, I remember that much.
06:26:23 <ski> frerich3 : fya, that type `Mu []' is basically a type of "lists of (lists of (lists of (...)))" :)
06:26:34 <mm_freak> well, you can implement a whole webserver in 10 lines of code
06:26:39 <mm_freak> so 11 lines is BIG
06:26:58 <mm_freak> (suitable imports assumed)
06:27:04 <frerich3> It was 11 lines and I didn't use a single import.
06:27:38 <frerich3> Right now I'm tyoing with the language, I'm not using any libraries or such.
06:28:56 <ski> mm_freak : i differentiate between them as well .. afaiac, the "type constructors" are the things defined by `newtype' and `data' -- things like `Int',`Maybe',`(->)',`Mu', but not `Maybe Int',`Either Bool',&c.
06:29:35 <ski> (and "type" includes all type constructors, as well as all other type expressions)
06:29:47 <quicksilver> ski: "Either Bool" could quite reasonably be described as a partially applied type constructor, though, and it has many of the properties of a type constructor.
06:30:28 <Axman6> :t In (Right (In (Left True)))
06:30:29 <lambdabot> Mu (Either Bool)
06:30:45 <Axman6> :t (Right (In (Left True))
06:30:46 <lambdabot> parse error (possibly incorrect indentation)
06:30:51 <Axman6> :t Right (In (Left True))
06:30:52 <lambdabot> forall a. Either a (Mu (Either Bool))
06:31:22 <HaskellN0b> Can I do something like this for a bolean: myFunc t p = p t 3. And invoke it with myFunc (==) 3 and have that return true?
06:31:29 <ski> @type Cont (\k -> k (Right (\a -> k (Left a))))
06:31:29 <lambdabot> forall r a. Cont r (Either a (a -> r))
06:31:41 <quicksilver> ski: for example, you can give Functor instances for type constructors and partial type constructors but not, in general, all type functions.
06:32:04 <ski> HaskellN0b : you can say `myFunc (+) p = p + 3' if you like :)
06:32:19 <ski> HaskellN0b : or `myFunc (==) p = p == 3', of course
06:32:19 <sipa> so * is the kind of all types for which values can exist?
06:32:34 <quicksilver> sipa: yes
06:32:50 <HaskellN0b> So I have to use overloading for all kinds?
06:32:55 <ski> HaskellN0b : in both those cases, the operator is not the one which is globally referred to under that name. it is "just" a local variable
06:33:16 <quicksilver> sipa: although in GHC, not quite.
06:33:26 <sipa> quicksilver: you also have ? and ??, i understood
06:33:35 <quicksilver> sipa: GHC refines the kind system and does not use '*' as the name for the most general value kind.
06:33:43 <ski> HaskellN0b : you can also say `myFunc t p = t p 3' .. or `myFunc (-+*/!?<>=) p = p -+*/!?<>= 3'
06:34:01 <sipa> HaskellN0b: depends what you call overloading, but overloading in the C++/Java sense of having separately defined functions/operators with the same name doesn't exist
06:34:18 <sipa> (i haven't been following 100%, so it may not be what you mean)
06:34:52 <ski> HaskellN0b : this is unrelated to overloading .. it is just local shadowing of a name .. just as if you had defined `p = 42', the `p' in `myFunc (==) p = p == 3' is not the same `p'
06:35:35 <ski> quicksilver : yes .. it's a bit curious
06:35:54 <sipa> quicksilver: so, is there a kind expression that means "all function types" (not all functions of types)
06:35:58 <sipa> ?
06:36:16 <ski> no
06:36:46 <sipa> function types is just some not-separately nameable subset of the types referred to by *
06:36:49 <sipa> ?
06:36:50 <ski> every function type has kind `*' .. but there's lots of other types with that kind as well
06:36:58 <sipa> i see
06:37:01 <ski> @kind Int -> Bool
06:37:02 <lambdabot> *
06:37:22 <Maxdamantus> @pl \a b -> a >>= const b
06:37:23 <lambdabot> (. const) . (>>=)
06:37:49 <ski> (>>)
06:38:42 <Maxdamantus> Hm. Isn't that like, one of the axioms of the monad instances or something?
06:38:48 <Maxdamantus> @pl flip (>>=)
06:38:49 <lambdabot> (=<<)
06:38:54 <ski> yes
06:40:12 <Maxdamantus> @pl \a b -> a >>= (\_ -> b)
06:40:12 <lambdabot> (. const) . (>>=)
06:40:27 <ski> HaskellN0b : note that e.g. `(==)' and `sin' are both overloaded, while `(!)' and `not' are not -- so, overloading is unrelated to whether a name is an operator or an ordinary variable name
06:40:50 <ski> @pl a >>= \_ -> b
06:40:51 <lambdabot> a >> b
06:41:04 <ski> @pl foo a b = a >>= \_ -> b
06:41:04 <lambdabot> foo = (. const) . (>>=)
06:41:09 <ski> @pl foo b a = a >>= \_ -> b
06:41:10 <lambdabot> foo = flip (>>)
06:41:17 * ski shakes head ..
06:41:19 <Maxdamantus> O_o
06:41:38 <Maxdamantus> @pl \a b -> a >>= \_ -> b
06:41:39 <lambdabot> (. const) . (>>=)
06:41:51 <sipa> Maxdamantus: what are you trying to get?
06:42:00 <Maxdamantus> Nothing, just testing @pl
06:42:20 <Maxdamantus> Why doesn't it create >> from that?
06:42:53 <zygoloid> Maxdamantus: it doesn't really need testing, we know where the bugs are ;)
06:43:30 <zygoloid> @pl \xs -> [x | x <- xs] 
06:43:31 <lambdabot> return . ((x | x) <-)
06:43:33 <zygoloid> ^^ there's one
06:43:45 <Maxdamantus> It doesn't do list comprehension, does it?
06:43:48 <Axman6> heh
06:43:51 <opqdonut> heh
06:43:57 <Maxdamantus> @unlist [x | x <- xs]
06:43:57 <lambdabot> No module "[x | x <- xs]" loaded
06:43:59 <zygoloid> Maxdamantus: it really really doesn't
06:44:03 <zygoloid> @undo [x | x <- xs]
06:44:03 <Maxdamantus> @undo [x | x <- xs]
06:44:03 <lambdabot> concatMap (\ x -> [x]) xs
06:44:03 <lambdabot> concatMap (\ x -> [x]) xs
06:44:18 <Maxdamantus> @pl \xs -> concatMap (\ x -> [x]) xs
06:44:18 <sipa> @pl \xs -> [x | (x <- xs)]
06:44:18 <lambdabot> id
06:44:19 <lambdabot> return . (x |) . (x <-)
06:44:42 <zygoloid> @@ @type @pl @undo \xs -> [x | x <- xs]
06:44:42 <lambdabot>  forall a. a -> a
06:44:55 <zygoloid> @@ @djinn @type @pl @undo \xs -> [x | x <- xs]
06:44:56 <lambdabot>  f a = a
06:45:00 <zygoloid> \o/
06:45:15 <Maxdamantus> O_o
06:45:42 <Maxdamantus> Oh, you can pipe commands?
06:46:38 <Maxdamantus> @@ @eval @eval text $ show [1,2,3]
06:48:42 <zygoloid> @@ @run @run @run @run @run text $ show [1,2,3]
06:48:45 <lambdabot>   [1,2,3]
06:48:51 <Maxdamantus> @undo [(a, b) | a <- [1..], b <- [1..]]
06:48:51 <lambdabot> concatMap (\ a -> concatMap (\ b -> [(a, b)]) [1 ..]) [1 ..]
06:48:53 <zygoloid> @help eval
06:48:53 <lambdabot> eval. Do nothing (perversely)
06:49:28 <EvanR-work> why on earth are we manually running list monads??
06:49:36 <Maxdamantus> @eval "foo"
06:49:44 <Maxdamantus> @run "foo"
06:49:45 <lambdabot>   "foo"
06:50:02 <Maxdamantus> @@ @run @run @run @run @run @run @run ""
06:50:07 <lambdabot>   ""
06:50:12 <Phyx-> Is there a way to tell cabal which .cabal file it should be looking at? or does it always have to find it in the current dir? The build system is running form a different directory than the cabal file is. is the only way to do this to change the cwd?
06:51:48 <ezyang> Phyx-: I don't think so. 
06:53:16 <Phyx-> ezyang: ok, didn't find any indeed. Ok, time to dive into the documentation of this to see how to change the cwd
06:53:40 <dcoutts> Phyx-: the build must run from the cwd, but you can direct the ./dist/ dir to an alternate location
06:54:18 * ezyang goes "oh dear, custom build systems" 
06:55:05 <Phyx-> dcoutts: yeah, saw that option
06:55:14 <Phyx-> ezyang: lol, the alternative was much worse...
06:55:32 <dcoutts> ezyang: the problem is we didn't use enough t
09:51:30 <lambdabot> Not in scope: `bool'
09:51:30 <lambdabot>     Precedence parsing error
09:51:30 <lambdabot>         cannot mix `.' [infixr 9] and `ap' [infixl 9] in the same infix expression
09:51:38 <Twey> Boo
09:53:13 <adnap> > maybe [(Just 42)] (Just 43)
09:53:14 <lambdabot>   Couldn't match expected type `a -> [Data.Maybe.Maybe t]'
09:53:15 <lambdabot>         against in...
09:53:30 <aristid> Twey: yea i find it to be rather unreadable with ap or <*> tho
09:54:31 <Twey> aristid: You get used to it
09:54:50 <Twey> aristid: Probably not if you dismiss everything that uses them as unreadable, though.
09:55:01 <Twey> aristid: ap = liftM2 id; not too tricky
09:55:06 <aristid> Twey: no, i don't dismiss everything that uses them as unreadable
09:55:38 <aristid> Twey: i have used my share of <*> too, but in this case it is still a bit confusing for me
09:55:45 <adnap> > maybe 42 (+5) Nothing
09:55:47 <lambdabot>   42
09:56:01 <adnap> > maybe 42 (+5) $ Just 3
09:56:02 <lambdabot>   8
09:56:07 <aristid> Twey: orElse a b = a >>= bool b . return <*> isNothing
09:56:34 <aristid> @hoogle (??)
09:56:35 <lambdabot> No results found
09:56:53 <adnap> :t \b -> maybe b return
09:56:54 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> Maybe a -> m a
09:57:46 <aristid> adnap: (return . Just) for me
09:58:03 <aristid> (Monad m) => m (Maybe a) -> m (Maybe a) -> m (Maybe a)
09:58:09 <adnap> :let \b -> maybe b return = wtf in wtf 42 [5]
09:58:13 <adnap> > let \b -> maybe b return = wtf in wtf 42 [5]
09:58:15 <lambdabot>   <no location info>: Parse error in pattern
09:58:31 <aristid> wtf
09:58:36 <adnap> > let wtf = (\b -> maybe b return) in wtf 42 [5]
09:58:37 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
09:58:38 <lambdabot>         against inferred ...
09:59:48 <adnap> > let wtf = (\b -> maybe b return) in wtf $ Just 3
09:59:49 <lambdabot>   Overlapping instances for GHC.Show.Show
09:59:49 <lambdabot>                              (Data....
10:00:07 <adnap> > let wtf = (\b -> maybe b return) in wtf 5 $ Just 3
10:00:08 <lambdabot>   No instance for (GHC.Num.Num (m a))
10:00:08 <lambdabot>    arising from a use of `e_153' at <in...
10:00:44 <adnap> Bah, I don't get it.
10:01:15 <benmachine> aristid: reconstructing Maybes is not a big deal :P
10:01:29 <aristid> benmachine: but i don't like the looks of it!
10:01:36 <adnap> > (return . Just) 3
10:01:38 <lambdabot>   No instance for (GHC.Show.Show (m (Data.Maybe.Maybe a)))
10:01:38 <lambdabot>    arising from a ...
10:01:52 <benmachine> hmm
10:01:55 <adnap> > (return . Just) 3 :: [Maybe Num]
10:01:56 <lambdabot>   Class `GHC.Num.Num' used as a type
10:02:04 <adnap> > (return . Just) 3 :: [Maybe Int]
10:02:05 <lambdabot>   [Just 3]
10:02:26 <benmachine> :t \ a b -> maybe b (const a)
10:02:27 <lambdabot> forall a a1. a -> a -> Maybe a1 -> a
10:03:05 * benmachine is thinking something like a >>= \x -> maybe b (const x) x
10:03:28 <JoeyA> In the type signature a -> b, do both a and b both strictly have kind *, or can they be interpreted to have kind * -> *, * -> * -> *, etc.?
10:03:34 <benmachine> a >>= \x -> maybe b (const (return x)) x
10:03:43 <adnap> > let wtf = (\b -> maybe b return) in wtf [3] [Just 42]
10:03:44 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t'
10:03:44 <lambdabot>         against inferred ...
10:04:48 <benmachine> :t \b x -> maybe (const b) (const return) x x
10:04:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (Maybe a) -> Maybe a -> m (Maybe a)
10:05:01 <adnap> > let wtf = (\b -> maybe b return) in wtf [3] [Just 42] :: [Int]
10:05:02 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
10:05:03 <lambdabot>         again...
10:05:13 <JoeyA> Also, is it possible for a type to have kind (* -> *) -> *   ?
10:05:20 <JoeyA> (in Haskell 98, that is)
10:05:27 <benmachine> JoeyA: sure
10:05:44 <benmachine> JoeyA: and, yes, a -> b requires a and b to be *
10:06:05 <benmachine> Maybe -> IO isn't a valid type
10:06:31 <benmachine> a type with kind (* -> *): ReaderT r
10:06:35 <JoeyA> I guess an example of (* -> *) -> * would be data Foo m = Foo {m Char}
10:06:40 <benmachine> eerm (* -> *) -> *
10:06:45 <benmachine> oh wait
10:06:47 <adnap> (\b -> maybe b return) is supposed to return b if the Maybe is Nothing, and wrap it in a monad if it's Just something?
10:06:49 <benmachine> yes you're right I'm wrong
10:07:03 <benmachine> adnap: maybe b return Nothing = b
10:07:10 <benmachine> maybe b return (Just x) = return x
10:07:16 <benmachine> that's how it works
10:07:16 <adnap> Right, that's what I said.
10:07:46 <benmachine> adnap: I thought by "it" you meant b
10:07:57 <adnap> No, sorry.
10:08:10 <JoeyA> and would data Foo m a = Foo {m a} be of type (* -> *) -> * -> * ?
10:08:47 <adnap> But does the maybe come first or the b?
10:09:38 <JoeyA> meh, I'll just try it myself.
10:09:41 <adnap> > let wtf = (\b -> maybe b return) in wtf 3 Nothing
10:09:42 <lambdabot>   No instance for (GHC.Num.Num (m a))
10:09:42 <lambdabot>    arising from a use of `e_13' at <int...
10:09:49 <adnap> > let wtf = (\b -> maybe b return) in wtf Nothing 3
10:09:50 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
10:09:50 <lambdabot>    arising from a use of...
10:10:26 <adnap> :t (\b -> maybe b return) 3
10:10:27 <lambdabot> forall a (m :: * -> *). (Monad m, Num (m a)) => Maybe a -> m a
10:10:51 <JoeyA> :k data Foo m a = Foo (m a)
10:10:52 <lambdabot> parse error on input `data'
10:10:52 <adnap> > (\b -> maybe b return) 3 Nothing :: [Int]
10:10:53 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
10:10:53 <lambdabot>    arising from the literal `...
10:11:28 <adnap> > (\b -> maybe b return) 3 (Just 4) :: [Int]
10:11:29 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
10:11:29 <lambdabot>    arising from the literal `...
10:11:35 <adnap> Ahhh
10:12:00 * hackagebot ftshell 0.3.0.1 - Shell interface to the FreeTheorems library.  http://hackage.haskell.org/package/ftshell-0.3.0.1 (MatthiasBartsch)
10:12:09 <siracusa> > (\b -> maybe b return) [3] (Just 4) :: [Int]
10:12:10 <lambdabot>   [4]
10:12:39 <adnap> (\b -> maybe b return) [3] Nothing :: [Int]
10:12:47 <adnap> > (\b -> maybe b return) [3] Nothing :: [Int]
10:12:48 <lambdabot>   [3]
10:13:07 <adnap> a and b have to be the same type in this case?
10:13:30 <adnap> Why doesn't this give 3? (\b -> maybe b return) 3 (Just 4)
10:13:38 <adnap> Er, [4]
10:14:15 <adnap> 'Cause you can't say what type it is/
10:14:16 <adnap> ?
10:14:41 <adnap> So a and b have to be the same to definitively say which monad you want.
10:14:46 <siracusa> adnap: Because the value used if the Maybe value is Nothing, must be of the same type of return applied to the Just value.
10:16:06 <adnap> Ah, I see.  return takes a to a b, and since return makes monads, b has to be a monad.
10:20:09 <adnap> > (\b -> maybe b return) (putStrLn "woo") Nothing
10:20:10 <lambdabot>   <IO ()>
10:20:16 <adnap> > (\b -> maybe b return) (putStrLn "woo") $ Just ()
10:20:17 <lambdabot>   <IO ()>
10:30:56 <dons> http://learnyousomeerlang.com/ + http://www.tryerlang.org/ == erlangers.com is next...
10:32:57 <nooodl> how do i read all of stdin into a list of strings?
10:33:25 <nooodl> getContents?
10:36:20 <dons> do s <- getContents ; return (lines s)
10:36:26 <dons> ?pl do s <- getContents ; return (lines s)
10:36:26 <lambdabot> (line 1, column 21):
10:36:26 <lambdabot> unexpected ";"
10:36:26 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
10:36:27 <identity> If I'm writing a threaded application where each worked thread needs to modify a queue by putting elements at the back, should i just be using something like Data.Sequence.Seq in an MVar?
10:36:28 <dons> ?undo do s <- getContents ; return (lines s)
10:36:28 <lambdabot> getContents >>= \ s -> return (lines s)
10:36:32 <dons> ?pl getContents >>= \ s -> return (lines s)
10:36:32 <lambdabot> lines `fmap` getContents
10:36:42 <dons> identity: how about a Chan?
10:36:48 <identity> dons: Hmm
10:36:58 <identity> I'll have to look into those :P
10:36:58 <identity> thanks
10:36:58 <dons> Control.Concurrent.Chan is a threadsafe queue/fifo.
10:37:02 <identity> oh!
10:37:10 <dons> built using MVars.
10:37:14 <identity> I see
10:37:25 <identity> I should've known such a common model had been put in the standard
10:37:32 <dons> http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html#id674105
10:37:59 <identity> <3
10:38:10 <identity> Oh, that does *exactly* what I need to do
10:38:21 <identity> osom
10:38:22 <identity> thanks.
10:38:44 <pelotom_> is there such a thing as a type constructor that's *not* a functor?
10:38:45 <dons> we aim to please.
10:39:01 <dons> pelotom_: Functor in the type class sense?
10:39:03 <identity> then your aim is unparalleled
10:39:25 <pelotom_> dons: functor in the category theory sense
10:39:45 <pelotom_> meaning, there could be a functor type class instance if you wanted
10:40:07 <Saizan> the Functor class is about functors from Hask to Hask
10:40:08 <dons> well, things like Set or UA a => Vector a aren't Functor, but they're functors with sufficient side conditions (IANACT)
10:40:29 <Saizan> data Foo a = Foo (a -> a) wouldn't be one, for example
10:40:30 <dons> and i guess you don't mean "nullary" type constructors, like ByteString.
10:40:42 <dons> Saizan makes a good point.
10:41:18 <pelotom_> ah, good point
10:41:23 <pelotom_> I was missing an example
10:42:18 <conal> maybe we could find more non-functory examples.
10:42:36 <Saizan> it'd be a functor C -> Hask if C is the category where arrows A -> B are a pair of Hask arrows A -> B and B -> A
10:43:36 <conal> oh -- contravariant functors is one source.  maybe also phantom types
10:44:08 <pelotom_> it seems like phantom types are trivially functors... no?
10:44:26 <pelotom_> all you have to do is switch the type variable and map does nothing
10:44:41 <conal> i think so.
10:44:49 <conal> functor laws easily satisfied.
10:45:18 <c_wraith> fmap = id
10:45:19 <c_wraith> nice
10:45:27 <conal> not quite id.
10:45:33 <conal> since the type changes.
10:45:37 <c_wraith> Oh, true
10:45:38 <conal> almost id.
10:45:39 <Saizan> fmap = const unsafeCoerce
10:45:45 <c_wraith> generalized id!
10:45:53 <identity> :t unsafeCoerce
10:45:55 <lambdabot> Not in scope: `unsafeCoerce'
10:46:03 <c_wraith> it's a -> b
10:46:10 <identity> oh, yeah, that one
10:47:44 <pelotom_> Saizan: going back to your example, is that really not an endofunctor? can't I reasonably say that the only function you could've constructed that with is id, so I just instantiate id at whatever type I like when doing an fmap?
10:47:55 <Funktorsalat> if it's a gadt you may not be able to arbitraily change the phantom's value
10:48:35 <Saizan> pelotom_: that'd be true for data Foo a = Foo (forall a. a -> a)
10:48:50 <Saizan> ?type Endo
10:48:51 <lambdabot> forall a. (a -> a) -> Endo a
10:49:04 <Saizan> ?type Endo (+1) :: Endo Int
10:49:05 <lambdabot> Endo Intoingie> ENOLAMBDABOT
16:49:54 <Phyx-> again
16:50:01 <mjrosenb> ezyang: forall commutes with itself
16:50:05 <Phyx-> that bot commits senpuku alot
16:50:08 <mjrosenb> ezyang: as does extsts.
16:50:14 * ezyang nods 
16:50:16 <kmc> ezyang, no
16:50:18 <ezyang> ok. 
16:50:19 <gwern> in sunken vmware lambdabot lies dreaming
16:50:25 <anshul> Is there a strict version of Data.Map.foldlWithKey?
16:50:31 <kmc> ∃y. ∀x   is a stronger guarantee than  ∀x. ∃y.
16:50:32 <mjrosenb> ezyang: however, they do not commute with each other
16:50:38 <kmc> there exists *one* y which works for *all* x
16:50:39 <gwern> <>! <>! the ioref of the black woods!
16:50:40 <sproingie> > ftagn . cthulhu
16:50:45 <djahandarie> Hehe, senpuku is different from seppuku
16:50:57 <kmc> versus picking some (possibly different) y for each x
16:50:57 <sproingie> djahandarie: what pray tell is senpuku?
16:50:59 <Phyx-> gwern: it hit an iceberg?
16:51:00 <mjrosenb> \(x.x x) (\x.x x x) is the oomkiller
16:51:19 <djahandarie> sproingie, "concealment"
16:51:55 <mjrosenb> ezyang: \forall x . \exists y . x == y is rather different from \exists y . \forall x . x == y.
16:51:57 <kmc> (∃y. ∀x. φ(x,y)) → (∀x. ∃y. φ(x,y))
16:52:12 <sproingie> djahandarie: now there's some orders you want to say clearly.  "I just told him to stay hidden!"
16:52:19 <Phyx-> sproingie: i meant, seppuku
16:52:28 <Phyx-> stupid typo
16:52:44 <mjrosenb> Phyx-: congrats, your typo is well on its way to becoming a meme.
16:52:47 <kmc> proof:  λ(Exists y p). λx. Exists y (p x y)
16:52:55 <kmc> or such
16:52:58 <sproingie> I ARE A MEME WOO
16:53:04 <Phyx-> *Achievement Unlocked*
16:53:46 <Phyx-> I really need to get unicode support in this client
16:54:03 <Phyx-> kmc: just pasted alot of stuff I can't read :P
16:54:09 <sproingie> I \N{HEAVY BLACK HEART} Unicode
16:54:10 <ezyang> kmc: I forget what p means? 
16:54:10 <gwern> I was always fond of my Wikipedia page, 'Requests for Seppuku'
16:54:37 <mjrosenb> ezyang: if you get into complexity theory, with qualified expressions, the measure of "how large" an expression is is the number of times that you alternate \forall and \exists.
16:54:41 <sipa> įŧ'ś ňǒť ĥàřđ ŧố ŵŗĩţê ťĥīňġş ťħḁţ ẁīļļ ĉầữşế ñỏņ-ụńįćọďê ćĺĩĕňťś ţő ŝħøẃ ğĩbbëŕỉşħ
16:54:49 <sproingie> zalgo!
16:54:50 <kmc> Phyx-, i didn't paste it, i typed it ;P
16:54:57 <dolio> If they commuted, there'd be no need for talking about Pi_n and Sigma_n sentences.
16:55:01 <Phyx-> kmc: lol
16:55:14 <Phyx-> correction, sipa pasted garbled nonsense to me :P
16:55:26 <kmc> ezyang, i'm pattern-matching a constructor Exists and binding vars y and p
16:56:16 <kmc> the idea is that proofs of «∃x. φ» are pairs (x, p) such that (p x) is a proof of φ
16:56:29 <mjrosenb> kmc: what clietnt/terminal do you use that lets you type in unicode?
16:56:32 <mjrosenb> *client
16:56:47 <ezyang> Really mean type: (forall x. exists y. P x -> Q x y, forall x. exists z. forall y. (Q x y -> Bottom) -> P z) -> exists x. forall y. Q x y 
16:56:52 <ezyang> I might need excluded middle for this one... 
16:56:57 <sipa> Phyx-: i didn't paste anything :)
16:57:00 <sipa> i just typed
16:57:02 <sipa> /accentify it's not hard to write things that will cause non-unicode clients to show gibberish
16:57:15 <Phyx-> lol
16:57:23 <ezyang> kmc: Ah, so p is a "witness" of some sort? 
16:57:33 <Phyx-> I wonder why my irssi doesn't have unicode support
16:57:35 <kmc> data Exists (φ :: t) where { Exists :: (x :: t) → φ x → Exists φ }
16:57:38 <Shamar> how to understand which Prelude.read don't parse?
16:57:44 <kmc> hmm
16:57:47 <kmc> not quite, but close
16:57:48 <dolio> Wah? No, they're (v, p), where p is a proof of φ[x := v].
16:58:42 <kmc> hmm
16:59:01 <Phyx-> Shamar: it means.. it couldn't parse the input to what you desired
16:59:06 <benmachine> is that a kind variable?
16:59:06 <kmc> yea that makes more sense dolio
16:59:08 <Phyx-> > read "Fo" :: Int
16:59:23 <kmc> benmachine, it's not real haskell
16:59:36 <benmachine> k
16:59:40 <sipa> Phyx-: irssi has unicode support, but it needs some settings
16:59:41 <Saizan> kmc: φ :: t -> *
16:59:46 <sipa> as does your terminal
16:59:47 <kmc> right
16:59:50 <Phyx-> Shamar: for instance Prelude> read "Fo" :: Int will raise that error, because it can't parse "Fo" into a number
17:00:21 <Phyx-> sipa: well, my terminal is rxvt I assume it supports it. I'm looking for the setting in irssi
17:00:46 <LeoD> Phyx-: set term_charset utf-8 iirc
17:00:50 <sipa> /set recode_autodetect_utf8 ON
17:00:59 <kmc> data ∃ (φ :: t → ∗) where W :: ∀(x :: t). φ x → ∃ φ
17:01:01 <kmc> like so?
17:01:01 <LeoD> ah right there was that too
17:01:04 <EvanR> ive never had to configure irssi for unicode
17:01:11 <sipa> /set term_charset utf-8
17:01:27 <kmc> mjrosenb, X compose key.  i have a file at ~/.XCompose which is generated by feeding http://hpaste.org/40418/composein into http://hpaste.org/40417/mkcomposehs
17:01:32 <Phyx-> do i need to restart it?
17:01:50 <sipa> Phyx-: don't think so, but i'm not sure
17:01:55 <sipa> are you running it in a screen?
17:01:58 <Phyx-> someone type something unicody
17:02:05 <LeoD> ö?
17:02:05 <sipa> ţéşţ
17:02:06 <EvanR> abcd
17:02:07 <Phyx-> sipa: no
17:02:23 <Phyx-> lol, works
17:02:34 <mjrosenb> iirc, my laptop does nto have an extra key that would be useful as a compose key.
17:02:44 <sipa> ẁěŀçøḿë ţơ ŧĥĕ ẃøņđệŗƒủļ ẅóŕľđ öƒ Űņịċỏďę, Pĥỹx-
17:02:59 <Phyx-> oh my
17:03:05 <Phyx-> are you just pressing random keys?
17:03:09 <sipa> no
17:03:15 <Phyx-> then it's not working...
17:03:34 <sipa> it's possible that it uses some characters which your font doesn't support
17:03:36 <kmc> mjrosenb, i use the Fn key on my thinkpad
17:03:41 <BrianHV> worked for me...
17:03:42 <mee> sipa: I hope you have a plugin to do that for you
17:03:44 <sipa> but at least some you should be able to read
17:03:47 <sipa> mee: yes :)
17:03:54 <Phyx-> sipa: next question.. how do you change the font then
17:04:00 <Phyx-> well, I saw alot of accented characters
17:04:10 <mee> everything works great with erc/emacs, fyi
17:04:13 <Phyx-> instead of the usual \u<code>
17:04:23 <mauke> "usual"?
17:04:25 <mjrosenb> kmc: when i had a thinkpad, my fn key did not show up as a key at *all* to X
17:04:32 <kmc> ah
17:04:36 <sipa> sƃuıɥʇ ʎuunɟ ɹǝɥʇo ǝɯos sʍoʃʃɐ osʃɐ ǝpoɔıun
17:04:47 <Phyx-> mauke: well, before i would get \u03c6
17:04:48 <Phyx-> etc
17:04:52 <Phyx-> instead of the character
17:04:58 <mauke> pɹıǝʍ ʞooן s,ן ǝsoɥʇ
17:04:59 <kmc> mjrosenb, the current models send a keycode on release if you didn't press anything else
17:05:00 <Phyx-> now I get a.. weird character
17:05:10 <mjrosenb> kmc: good to know
17:05:19 <sipa> ǝǝɹƃɐ :ǝʞnɐɯ
17:05:19 * mjrosenb will look into using that on his dell.
17:05:23 <LeoD> Phyx-: you say you have rxvt, but wouldn't you need rxvt-unicode?
17:05:38 <EvanR> i hate how unicode has been reduced to snowmen, upside down text, and random symbols remeniscent of extended ascii on DOS
17:05:53 <Phyx-> EvanR: rodl
17:05:54 <sproingie> yes it should be no fun at all
17:06:03 <mauke> ｈｏｗ ａｂｏｕｔ ｅｘｔｒａ－ｗｉｄｅ ｔｅｘｔ？
17:06:04 <Phyx-> LeoD: I don't know, this seems to work
17:06:08 * sipa needs sleep - meeting in 7 hours
17:06:08 <Phyx-> let me change my font
17:06:11 <sipa> see ya all
17:06:11 <EvanR> extra wide text is normal
17:06:14 <Phyx-> that's in the theme file isn't it?
17:06:14 <EvanR> in chinese
17:06:15 <sproingie> mauke: you and the goddam spammers love that one
17:06:17 <Phyx-> night sipa 
17:06:18 <mauke> ᴀʟsᴏ, sᴍᴀʟʟ ᴄᴀᴘs
17:06:23 <kmc> so what will the Haskell community do if/when Reddit goes bankrupt
17:06:26 <sproingie> small caps too
17:06:36 <mjrosenb> mauke: oh god, what the hell are you doing to my terminal?
17:06:42 <Phyx-> hahaha
17:06:49 <Phyx-> and here I thought I was the only one :P
17:06:56 * mauke fires the nuclear missiles
17:07:04 <hpc> unsafeLaunchMissiles?
17:07:06 <anshul> Newbie Question: Is there a strict version of M.foldlWithKey?
17:07:07 <sproingie> actually when they use *just* the wide or smallcaps, that's easy to block
17:07:10 * EvanR fires the antinukes
17:07:12 <sproingie> it's when they stick them in the middle
17:07:20 <mauke> ⎄⨟⨾
17:07:21 <kmc> anshul, don't think so :/
17:07:22 * Phyx- sends in George W. Bush
17:07:24 <hpc> @hoogle foldl
17:07:27 <kmc> Data.Map is missing strict versions of lots of things
17:07:28 <mauke> ̴̧̨̛̣̤̥̦̪̬̮̰̱̲̻̼̃̄̅̆̈̌̐͒̀́̂̇̉̊̑̓̽̾̿͂̓͆͋ͅ͏⃘᷐᷎͓͙᷂᷏͛҃҄҇᷃᷄᷅᷆᷇᷈᷉᷋᷌᷑᷒͝͞͠⃝⃞⃟⃢⃣̵̶̷̸̡̢⃨̖̗̘̙̝̞̟̠̩̭̯̳̺͇͉͎͔͕͚⃧⃰꙯꙼꙽︦̋̍̏̒̔̀́̈́͊͐҅҆̕̚͘͜͟͡҉⃙⃚߲፟᷀᷁᷾⃐⃑⃔⃕⃖⃗⃛⃜᷍⃠⃥⃪⃮⃯⃩⳯⳰⳱ⷠⷡⷢⷣⷤⷥⷦⷧⷨⷩⷪⷫⷬⷭⷮⷯⷰⷱⷲⷳⷴⷶⷷⷸⷺⷻ꛰꛱꣠꣡꣢꣣꣤꣥
17:07:34 <mauke> 𝅥𝅻𝅼𝅽𝅾𝅿𝆂̜̫̹͈͍꣦꣧꣨꣩꣪꣫꣬꣭꣮꣯꣰꣱︠︡︤︥𝆅𝆆𝆇𝆈𝆉𝆬𝉂𝉃𝉄̎͌͑͗ͣͤͥͦͧͨͩͪͫͬͭͮͯ͢҈⃒⃓᩿᭬᷽߫߬߭߮߯߰߱߳᭫᭭᭮᭯᭲᭳ᷔᷕᷖᷙᷚᷜᷝᷠᷤᷦ⃡⃤⃦⃫ⷵⷹⷼⷽⷾ꙰꙱꙲𝅧𝅨𝅩゙゚𝅦𝅮𝅯𝅰𝅱𝅲𝆀𝆁𝆊𝆋͖᷊᷿⃬⃭𐇽𝅭︢︣𝆪𝆫𝆭ᷗᷘᷛᷞᷟᷡᷢᷣᷥⷿ᭰᭱ᷓ
17:07:38 <Phyx-> oh my..
17:07:40 <hpc> oh good god tall text
17:07:40 <anshul> <kmc> Thanks
17:07:51 <kmc> anshul, but there is foldl' in Foldable, if you don't need the keys.  or foldl' on assocs
17:08:03 <sproingie> that hosed my irssi window til i flipped back and forth
17:08:22 <kmc> wow whenever i highlight mauke's text it gets longer and longer
17:08:34 <hpc> since when does a monospace font allow variable /height/?
17:08:35 <Phyx-> sproingie: do you know how to change the font in irssi?
17:08:43 <adimit> 'elo people. Is there any way to get HaXml to parse from a lazy bytestring? It seems its parsing routines only accept String.
17:08:45 <sproingie> Phyx-: you change your terminal's font
17:08:47 <anshul> <kmc> I will try that ... profiling reveals lots of thunkage involving Maps
17:08:53 <Phyx-> sproingie: ah
17:09:08 <sipa> irssi just sends text and some markup codes to your terminal
17:09:21 <sproingie> zalgo used to render so nicely for me.  but ff 3.6.10 on fedora 13, it's just awful
17:09:22 <kmc> anshul, one trick i've used is to call 'alter' with a function that return something like (Just $! f x)
17:09:29 <sipa> anyway, i was going to sleep
17:09:51 <hpc> kmc: funny hack :D
17:10:09 <kmc> even a whnf-forced map can have thunks for values, but 'alter' will always force the Maybe value, so you can tie your update's forcing to that
17:10:11 <mjrosenb> alter?
17:10:23 <mjrosenb> :t alter
17:10:29 <hpc> the bot is down
17:10:32 <mjrosenb> oh right, lambdabot is out cold :(
17:10:40 <Phyx-> oooh
17:10:43 <Phyx-> consolas looks odd
17:10:44 <Phyx-> haha
17:10:51 <Phyx-> someone type something unicode :P
17:11:05 <EvanR> abcd
17:11:18 <Phyx-> heh
17:11:28 <EvanR> testing your utf8 support
17:11:36 <mauke> ａｂｃｄ
17:11:40 <sproingie> ---H҉̵̞̟̠̖̗̘̙ E҉̵̞̟̠̖̗̘̙ C҉̵̞̟̠̖̗̘̙ O҉̵̞̟̠̖̗̘̙ M҉̵̞̟̠̖̗̘̙ E҉̵̞̟̠̖̗̘̙ S
17:11:42 <anshul> kmc: Thanks ... i will try that out
17:11:44 <mauke> αβκδ
17:11:50 <EvanR> what in the hell sproingie 
17:11:54 <sproingie> zalgo
17:12:18 <Phyx-> oh well, this doesn't work, guess getting unicode support on irssi on windows requires more work
17:12:25 <sproingie> really looks awful if the renderer doesnt support combining chars
17:12:31 <EvanR> Phyx-: what is your locale set to
17:12:49 <sproingie> irssi supports unicode fine, problem is the terminal doesnt
17:13:11 <EvanR> sproingie: HEERMES?
17:13:34 <sproingie> EvanR: should say "HE COMES" with a bunch of combining marks radiating out of it
17:13:37 <hpc> someday china will stop being Howard Hughes and everyone will be forced to support unicode in its entirety
17:14:01 <Phyx-> EvanR: it was "ISO-8859-1:1998 (Latin-1, West Europe)" but i changed it to utf8
17:14:12 <EvanR> you may need to relog in
17:14:21 <djahandarie> Phyx-, putty?
17:14:48 <Phyx-> djahandarie: yeah
17:14:52 <Phyx-> EvanR: let's try
17:14:54 <EvanR> windows, that explains it
17:15:08 <sproingie> putty is slightly better.  zalgo text will probably still freak it out
17:15:14 <sproingie> which is kind of appropriate
17:15:30 <djahandarie> Phyx-, hm, I recall all I needed to do was change the charset in the settings
17:15:30 <Phyx-> EvanR: I knew you were going to say that :)
17:15:37 <djahandarie> Phyx-, is your font decent?
17:15:42 * hpc secretly hopes for a misfeature of bash that produces a zalgo forkbomb
17:15:55 <Phyx-> djahandarie: I switched it to consolas which i know is Unicode
17:16:03 <sproingie> bashoggoth
17:16:20 <sproingie> consolas doesnt have a very large range of unicode chars
17:16:25 <sproingie> it's mostly for code
17:16:47 <EvanR> a single gigabyte unicode font is a mistake
17:16:52 <djahandarie> Get Dejavu Sans Mono
17:16:53 <sproingie> go grab dejavu sans mono
17:17:00 <sproingie> heh
17:17:08 <mm_freak> i'm starting to love yesod…  it's incredible
17:18:21 <mm_freak> never seen such a powerful and still safe web framework, never thought it's possible at all
17:18:43 <EvanR> ready for production?
17:18:51 <EvanR> we are sort oflooking to replace cakephp
17:19:11 <mm_freak> EvanR: it appears to be young, but works very nicely
17:19:16 <EvanR> manager wants to use symfony and it looks exactly the same to me
17:19:21 <EvanR> as cake
17:19:24 <djahandarie> Haha cakephp
17:19:26 <djahandarie> > PHP
17:19:39 <djahandarie> Switch to any Haskell framework
17:19:41 * Phyx-  googles
17:19:57 <mm_freak> EvanR: the biggest problem with yesod is the incomplete documentation
17:20:10 <mm_freak> but watching some video tutorials helped greatly
17:20:10 <fizruk_> is there standard function for (return . lift) ?
17:20:36 <Phyx-> hrm, alot of clicks to get to a dl link
17:20:46 <ezyang> fizruk_: Why... do you want to do that? 
17:20:54 <mm_freak> fizruk_: doesn't seem to be a useful function to me, so probably no
17:21:08 <djahandarie> @type return . lift
17:21:19 <ezyang> lambdabot is dead, long live lambdabot 
17:21:28 <Phyx-> ok, dejavu sans installed
17:21:31 <Phyx-> now let's see
17:21:42 <fizruk_> i'm just interested if there is one :) not very useful function, of course)
17:21:46 <djahandarie> こんばんは
17:22:06 <Axman6> :t return . lift
17:22:15 <Axman6> LAMBDABOOOOOTTTTTT!
17:22:25 <sproingie> الله أكبر
17:22:26 <Phyx-> hmm putty doesn't show it as a option
17:22:27 <Axman6> :'_(
17:22:28 <mm_freak> preflex: @type return . lift
17:22:31 <Phyx-> think i have to restart it
17:22:32 <sproingie> wow that was badly mangled for me
17:22:34 <mm_freak> preflex, @type return . lift
17:22:47 <sproingie> backward arabic, yay
17:22:47 <Axman6> Cale: ping (\bot is dead)
17:22:56 <djahandarie> ribeshah hallah
17:22:59 <djahandarie> Or something...
17:23:03 <djahandarie> I forget my arabic alphabet
17:23:10 <sproingie> allahu akbar
17:23:16 <sproingie> backward and isolated
17:23:25 <djahandarie> Oh haha
17:23:36 <mm_freak> return . lift
17:23:37 <mm_freak>   :: forall (m :: * -> *) (m1 :: * -> *) a (t :: (* -> *) -> * -> *).
17:23:37 <mm_freak>      (Monad m, Transformer t, Monad m1) =>
17:23:38 <mm_freak>      m1 a -> m (t m1 a)
17:23:38 <fizruk_> (return . lift) :: (MonadTrans t, Monad m) => a -> t m a
17:23:46 <EvanR> whats the matter your terminal doesnt have bidi support??:)
17:23:51 <Phyx|Unicode> this font is quite wide
17:23:53 <Phyx|Unicode> lol
17:24:09 <mm_freak> or, well…
17:24:11 <fizruk_> mm_freak: m (t m1 a) ?
17:24:14 <mm_freak> return . lift :: (Monad m, Transformer t, Monad m1) => m1 a -> m (t m1 a)
17:24:19 <Phyx|Unicode> mm_freak: wee it worked
17:24:27 <Phyx|Unicode> someone paste more unicode :P
17:24:34 <mm_freak> ℤ → ℤ
17:24:38 <Phyx|Unicode> wee
17:24:39 <djahandarie> fizruk_, what package are you getting Control.Monad.Trans from
17:24:45 <djahandarie> mtl or transformers or something else
17:24:47 <kmc> مرحبا العالم
17:24:49 <Phyx|Unicode> now.... to figure out how to make these the default
17:24:53 <fizruk_> djahandarie: mtl
17:25:14 <djahandarie> Yeah, it should be a -> t m a then
17:25:27 <mm_freak> djahandarie: why?
17:25:34 <fizruk_> djahandarie: no... lift takes m a
17:25:43 <fizruk_> my fault
17:25:44 <djahandarie> (a -> m a) . (m a -> t m a)
17:25:54 <mm_freak> djahandarie: no
17:26:02 <fizruk_> but return type is (t m a), imo
17:26:03 <djahandarie> Oh haha
17:26:04 <mm_freak> (a -> n a) . (m a -> t m a)
17:26:04 <djahandarie> Haha
17:26:12 <EvanR> lol
17:26:19 <EvanR> :t (.)
17:26:31 <Phyx-> ty for all the help djahandarie , sproingie 
17:26:40 <Phyx-> now I can see mauke's freaky stuff :P
17:26:43 * djahandarie needs to take a break
17:26:58 <EvanR> (b -> c) -> (a -> b) -> (a -> c)
17:27:02 <fizruk_> i feel myself very stupid today, sory for question ))
17:27:15 <mm_freak> EvanR: in lambdabot (.) = fmap
17:27:16 <mm_freak> ;)
17:27:21 <EvanR> yeah
17:27:24 <EvanR> screwthat
17:27:41 <gwern> mm_freak: I think we got rid of that
17:27:47 <Phyx-> good
17:28:11 <mm_freak> another nice one is:  (.) :: (Category cat) => cat b c -> cat a b -> cat a c
17:28:30 <Phyx-> that one I can atleast see
17:28:41 <mm_freak> gwern: it was there today
17:28:52 <gwern> oh
17:29:02 <gwern> maybe cale's lambdabot just never caught u[
17:29:07 <mm_freak> but maybe someone @let-defined it
17:29:09 <gwern> or maybe he restored his customs
17:29:27 <djahandarie> What would be the most complex definition of (.) ?
17:29:44 <mm_freak> djahandarie: define "complex"
17:29:51 <djahandarie> Stupid
17:29:51 <hpc> probably something that looks similar to the type of =~
17:30:08 <mm_freak> there is no stupid definition, there are just multiple ways of generalizing (.)
17:30:10 <hpc> which fails at runtime, not compile time
17:30:24 <djahandarie> mm_freak, overgeneralized
17:30:32 <cedricshock> http://hpaste.org/40525/problem_building_with_happstac
17:30:39 <mm_freak> i think (.) = fmap is overgeneralized
17:30:49 <djahandarie> I kinda like it
17:30:55 <djahandarie> (Not on lambdabot, but otherwise...)
17:31:00 <EvanR> generalized abstract nonsense
17:31:19 <jedai> Well there's no doubt that it coincide on (a ->)
17:31:22 <magicman> ... This is me laughing at Michael Snoyman for his brilliant post about Schrödinger's Applicative cat.
17:31:28 <magicman> Well done, man. Well done :)
17:31:28 <Phyx-> bed time, gn :)
17:31:49 <mm_freak> well, i like my variants of subsequences and permutations =)
17:31:49 <cedricshock> The above gives an error about No instances for (Eq (ServerPartT IO Story) ... when built. Any ideas?
17:31:52 <Phyx-> :t (->)
17:32:19 <pickles1> does (,) -- that's a comma -- have a functor defn by default anywhere in the std libs?
17:32:22 <jedai> Still I think the Category generalization is closer to the idea of composition that (.) represent
17:32:32 <jedai> pickles1: no
17:32:34 <hpc> pickles1: no, but it should
17:32:45 <kmc> pickles1, Control.Monad.Instances
17:32:46 <pickles1> could swore i used it the other day...
17:32:53 <jedai> pickles1: but ((,) a) has one somewhere I think
17:32:54 <kmc> of course it has to be ((,) a)
17:32:56 <hpc> data (,) a b = a, b
17:33:02 <kmc> (,) has the wrong kind to be a functor
17:33:02 <hpc> if anything
17:33:09 <Phyx-> is taht even possible without using higher ranked types?
17:33:19 <Phyx-> the same f has to apply to both elements
17:33:27 <mm_freak> permutations = foldM (\x y -> zipWith (\l r -> l ++ y:r) <$> inits <*> tails $ x) []
17:33:27 <pickles1> maybe ((,) a) is what i wanted..
17:33:31 <mm_freak> subsequences = filterM (const [True, False])
17:33:59 <kmc> if you want to fmap pairs like (a,a) you'll have to define a new type «data Pair a = Pair a a»
17:34:34 <enthropy> there's no type level lambdas
17:34:44 <pickles1> i wanted fmap :: (b -> c) -> (a, b) -> (a, c)
17:34:56 <djahandarie> Or make a newtype around (a,b)
17:35:06 <djahandarie> pickles1, that's in Control.Monad.Instances
17:35:28 <djahandarie> Err (a,a)*
17:35:33 <pickles1> djahandarie: kmc mentioned that too
17:35:46 <fizruk_> is it normal to use (f .) . g ?
17:35:49 <djahandarie> Yep, just being specific that that is the exact type signature
17:35:59 <pickles1> sweet, thx guys
17:36:04 <djahandarie> fizruk_, it comes up every once in awhile
17:36:17 <EvanR> (.:) = (.) . (.)
17:36:26 <djahandarie> fizruk_, some people let (.:) f g = (f .) . g
17:36:31 <djahandarie> Or the way EvanR did it :)
17:36:46 <Phyx-> EvanR: lol
17:36:46 <hpc> :t let (.:) f g = (f .) . g in (.:)
17:37:21 <djahandarie> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:37:49 <djahandarie> Or (a -> b) -> f (f1 a) -> f (f1 b)
17:37:50 <fizruk_> I mean, shouldn't I write h x y = f (g x y) ? which form is more readable?
17:38:14 <EvanR> free the points!
17:38:14 <djahandarie> fizruk_, if you're making things point-free at all, it's already unreadable ;)
17:38:18 <hpc> it depends on how well your maintainer knows (.:)
17:38:20 <djahandarie> That is a joke of course
17:38:31 <JoeyA> In Haskell 98, is it ever valid to have two type variables with the same name in the same type?
17:38:39 <JoeyA> e.g. m -> m a
17:38:52 <djahandarie> I don't think so
17:38:53 <hpc> i personally would do f . g x $ y
17:38:59 <hpc> i think the types check
17:39:07 <enthropy> @type (Prelude..)
17:39:27 <hpc> (a -> b) -> (b -> c) -> (a -> c)
17:39:34 <fizruk_> hpc: i think I would prefer (f .) . g
17:39:41 <enthropy> JoeyA: yes, but  m isn't allowed to have kind *  and * -> * at the same time
17:40:01 <hpc> and -> :: * -> *
17:40:07 <JoeyA> err,  I meant with the same kind
17:40:12 <Kaidelong> constructors are allowed as parameters though aren't they?
17:40:26 <JoeyA> two type variables with the same name, same kind, same type.
17:40:30 <hpc> constructors are regular functions
17:41:05 <Kaidelong> I suppose the type would be "a -> m a" as opposed to "m" then
17:41:41 <hpc> would the two 'a's be different?
17:41:45 <hpc> oh, no
17:41:48 <hpc> then yes
17:41:52 <hpc> that is done all the time :P
17:41:58 <JoeyA> I'm just trying to make sure that, when doing an occurs check, I simply have to look for the type name, not check kinds.
17:42:21 <djahandarie> You won't have to check kinds because -> has the kind of * -> * so that is enforced already
17:42:34 <hpc> if you are getting kind mismatch you are terribly off track
17:42:46 <djahandarie> (Monad m) => m -> m   is invalid for example
17:42:48 <hpc> you won't have that problem unless you know you will have that problem
17:43:56 <JoeyA> thanks
17:45:14 <Kaidelong> well my solution works but doing a bunch of floating point math to calculate whether or not one out of 160000 pixels is black or white seems inefficient
17:50:47 <Maxdamantus> @src unzip
17:53:41 <pickles1> oh this can't be good
17:53:53 <pickles1> have you ever written a line of haskell then been confused by it 5 min later?
17:54:00 <Kaidelong> yes
17:54:08 <Kaidelong> rewrite it
17:54:18 <pickles1> that's what i'm thinking....
17:54:31 <Kaidelong> basically it means you lost focus while you were doing it
17:54:37 <Kaidelong> so it's probably wrong anyway
17:55:17 <pickles1> thing is i think it's right
17:55:20 <pickles1> it compiled and ran
17:55:24 <pickles1> the output looks fine
17:56:29 <JoeyA> A fun little case illustrating why a Haskell type checker needs to carry around kinds with its types:  m a `unify` a m
17:57:38 <JoeyA> this actually does unify:   m :: * -> * becomes a :: * -> * and a :: * becomes m :: *
17:58:00 <enthropy> did you try it? :)
17:58:27 <JoeyA> That's what the Typing Haskell in Haskell implementation says.
17:59:05 <JoeyA> looks like I have a little bit of refactoring to do.
17:59:17 <JoeyA> (I'm trying to write some of a Haskell type checker in C)
18:00:10 <pickles1> Kaidelong: i figured it out again, too much nesting :-/
18:00:11 <JoeyA> More and more, I'm just copying off of THIH :-)
18:03:02 <mjrosenb> JoeyA: what is unify?
18:03:53 <JoeyA> mjrosenb: unification is find a way to get two types to be the same as each other by substituting variables.
18:04:15 <mjrosenb> JoeyA: yes, but in haskell, what is that
18:04:39 <JoeyA> It's not a Haskell operation per se.  I used that as pseudocode.
18:04:43 <mjrosenb> i'm assuming that m and a are type constructors
18:04:44 <mjrosenb> ahh.
18:05:05 <JoeyA> by that, I was talking about unifying the types m a  and  a m
18:06:11 <enthropy> JoeyA:  m a :: *   ?
18:06:46 <JoeyA> in the context of what I was talking about, yes.
18:07:44 <enthropy> I don't follow you:  JoeyA | this actually does unify:   m :: * -> * becomes a :: * -> * and a :: * becomes m :: *
18:08:05 <enthropy> given types have only a single kind
18:08:28 <JoeyA> I'm talking about unifying types m a  and  a m.
18:09:16 <JoeyA> Unification is a bit confusing because the type variable domains are sort of independent, if I understand correctly.
18:09:38 <JoeyA> as in, the a in one type is not the same a as in another type, but when it comes to occurs checking, they are...
18:10:29 <JoeyA> But m :: * -> * becomes a :: * -> * and a :: * becomes m :: *  is a valid unifier of the types m a  and a m
18:10:46 <JoeyA> it converts m a to a m, and leaves a m alone because neither of the kinds match up.
18:11:07 <enthropy> oh, the problem is where the quantification is
18:11:34 <enthropy> or you could just use unique variables so there is no confusion
18:11:49 <JoeyA> I really don't know where exactly the quantification is :P
18:12:11 <JoeyA> > let r = read x in (r "5" :: Int, r "\"hello\"" :: String)
18:12:31 <JoeyA> > let r x = read x in (r "5" :: Int, r "\"hello\"" :: String)
18:12:59 <enthropy> well you're saying lets find a solution to:     (forall m a. m a) = (forall a m. a m)
18:13:06 <JoeyA> that confuses me because I don't quite get when types can be ambiguous and when they can't.
18:13:18 <JoeyA> (referring to the let binding)
18:13:24 * edwardk waves hello.
18:14:09 <kmc> hi edwardk
18:14:10 <kmc> long time
18:14:23 <edwardk> heya, kmc, wow, i guess it has =)
18:14:57 <JoeyA> now, Typing Haskell in Haskell unifies m a and a m the way I said earlier.  However, it fails to unify a and [a] due to occurs check.
18:15:16 <kmc> edwardk, i released a cheesy little EDSL for SMT solving in Yices
18:15:22 <JoeyA> whereas (forall a. a) and (forall a. [a]) can be unified.
18:15:29 <edwardk> kmc: nice, way to light a fire under my ass ;)
18:15:29 <JoeyA> so is THIH wrong?
18:15:35 <kmc> yup, ball's in your court now ;)
18:15:54 <kmc> JoeyA, i didn't follow earlier why it unifies (m a) with (a m)
18:15:55 <enthropy> edwardk would know?
18:16:14 <JoeyA> Or perhaps this is an incorrectness in its unify function that is swept under the carpet by functions that use it.
18:16:49 <edwardk> JoeyA: have you ever read http://norvig.com/unify-bug.pdf ?
18:17:59 <JoeyA> kmc: it treats the m and a in both versions as different than each other because they have different kinds.
18:18:09 <kmc> oh
18:18:14 <kmc> strange
18:18:23 <kmc> :t let x :: a a; x = undefined in x
18:18:41 <kmc> it's an error in my ghci
18:19:01 <edwardk> JoeyA: that strikes me as a bug. since the kind is something to be inferred =)
18:19:15 <djahandarie> Hey edwardk!
18:19:32 <edwardk> heya darius
18:19:33 <Saizan> edwardk: and they told me all this time that purity leads to less bugs!
18:19:55 <edwardk> Saizan: heh.
18:20:36 <edwardk> Saizan: i dashed off a little unification algorithm for capitaliq off the cuff, and i had that very bug in it. it is pretty easy to make
18:21:22 <dolio> If you try to unify a m with m a, you get a = m. Then you try to infer a kind for m such that m m is valid, and fail.
18:21:40 <edwardk> dolio: exactly
18:21:44 <anshul> kmc: Tried the alter (Just !$ f x) trick you suggested ... no luck ... any pointers on how I could go about locating the source of thunks?
18:21:51 <kmc> not sure
18:22:23 <enthropy> anshul: ghci debugger?
18:22:42 <edwardk> anshul: short answer: you can't. long answer, if you compile to ghc bytecode, maybe in some cases you could, but you'd probably need to drag matt morrow back into the community to explain to you how it was done ;)
18:22:58 <djahandarie> Cale, did you ever make that phonecall?
18:23:00 <kmc> yeah, we really really really need better tools for tracking down space leaks
18:23:12 <kmc> there was someone else working on a heap inspector...
18:26:12 <JoeyA> What's a simple way to get ghci to unify two types for me?
18:26:13 <Saizan> zygoloid: 
18:26:58 <Saizan> JoeyA: :t [(undefined :: type1), (undefined :: type2)]
18:27:21 <JoeyA> cool, thanks
18:27:34 <JoeyA> [(undefined :: m a), (undefined :: a m)] :: [m a]
18:28:22 <JoeyA> [(undefined :: a), (undefined :: [a])] :: [[a]]
18:28:31 <JoeyA> no occurs check
18:28:40 <JoeyA> is that a bug?
18:28:50 <dolio> No.
18:29:02 <dolio> Those aren't the same as.
18:29:15 <JoeyA> oh
18:29:37 <kmc> yeah, each is bound by an implicit ∀ within its sig
18:29:54 <kmc> turn on ScopedTypeVariables and bring 'a' into scope outside with an explicit ∀
18:31:58 <anshul> enthropy, edwardk, kmc : thanks ... Any suggestions for better data structures are appreciated: I have the following data structure (Map (X,Y) (Map NodeName Node)) where nodes need to be modified (modify (x,y) name) once the graph is constructed.
18:32:42 <edwardk> anshul: i just tuned in, so i missed the original problem statement
18:32:54 --- mode: ChanServ set +o mauke
18:32:54 --- mode: mauke set -q *!*@gateway/web/freenode/ip.216.52.235.101
18:34:54 --- mode: mauke set -o mauke
18:35:29 <JoeyA> "<kmc> turn on ScopedTypeVariables and bring 'a' into scope outside with an explicit ∀" I can't seem to find a way to do that.
18:36:47 <anshul> edwardk : I have a graph which has named nodes. These nodes are placed on a cartesian grid (Map (X,Y) (Map Name Node). The inputs of each node point to other nodes. I want to visit the inputs of each node and update the output of the node that the input points to. I am running into a space leak the source of which is difficult to track down. 
18:39:25 <pickles1> nite all
18:39:35 <edwardk> anshul: not yet parsing your problem correctly. you have a grid (Map (X,Y) ...) on which at each point you have a mapping of names to nodes, is a Node an (X,Y) pair?
18:39:52 <edwardk> giving you named edges? or is it something else
18:44:40 <anshul> edwardk : At each (X,Y) there are nodes which have a names. so say at (5,5) there is node 'A' which has 3 inputs. Each input is annotated with a pointer (dx,dy,name) to its driving node. So say (5,5,A) input 1 has the annotation (dx=3,dy=2,name=Z). I want to annotate (8,7,Z) with (x=5,y=5,name=A,input=1) 
18:45:59 <Gracenotes> :)
18:47:38 <edwardk> okay, first step i'd do is treat (x,y,name) as the key, and punt the grid structure to another part of the problem or ancillary structure.
18:48:56 <edwardk> anshul: second, have you  looked at just using graphFromEdges from Data.Graph? build the graph, transpose it. look at the new graph ;)
18:49:57 <anshul> edwardk : Thanks! I will look at Data.Graph ... any idea how it performs?  I have a graph of about 10E6 nodes
18:50:17 <edwardk> it is fairly efficient, it uses STArrays, etc under the hood.
18:51:22 <edwardk> there is data.graph.inductive as well, but it is prone to worse space/time usage
18:52:00 <edwardk> though much more pleasant to work with, and fuller featured than the little data.graph that was inherited by containers
18:53:00 <kmc> the latter is fgl?
18:53:18 <edwardk> yeah
18:58:08 <sbahra> Hy edwardk
18:58:59 <edwardk> heya samy
18:59:05 <sbahra> ltns, doing well? 
18:59:46 <edwardk> yeah, switching jobs, life generally interesting and chaotic. though we should probably talk about that in -blah ;)
20:56:26 <quattro_cs> Same error.
20:56:42 <kmc> yes, i don't expect it to fix an error like that
20:56:43 <mjrosenb> is Parser defined in Main?
20:56:52 <quattro_cs> no, that is in the Parsec package
20:56:58 <quattro_cs> i didnt paste the entire file.
20:57:02 <kmc> quattro_cs, in Parsec, there's a Parser type constructor but not a data constructor
20:57:12 <kmc> afaixk
20:57:15 <kmc> afaik*
20:57:30 <quattro_cs> but what is weird is that this works when the entire thing is one file.
20:57:37 <kmc> hmm
20:57:42 <quattro_cs> the only imports in the Main are IO and System
20:57:58 <cch> may declaratioin quotation  [d|...|]  contains something to be spliced $(..) inside ?
20:58:15 <kmc> cch, yes
20:58:17 <cch> such [d| data $blah = ..|]
20:58:20 <kmc> but not there
20:58:26 <quattro_cs> does creating a module have any effect on that file internally?
20:58:32 <kmc> cch, you can splice an expression only
20:58:39 <mjrosenb> quattro_cs: are you sure you aren't declaring a new data constructor in Main called "Parser"?
20:58:42 <cch> i got an error: malformed head 
20:59:17 <cch> kmc: so only like this : [d|data blah = ..$foo ..|]
20:59:29 <quattro_cs> mjrosenb, here is the entire main file. http://hpaste.org/40527/my_main
20:59:31 <kmc> yeah something like that
20:59:35 <quattro_cs> its short.
20:59:51 <cch> ok 
20:59:55 <cch> thanks
21:00:42 <kmc> cch, otherwise you can use the AST combinators or the AST constructor directly
21:01:23 <cch> kmc: this you told me yesterday, and really works :)
21:01:52 <kmc> :)
21:05:16 <mjrosenb> quattro_cs: i tried giving definitions for everything else, and dumping it all into main, and I still get that error.
21:05:24 <mjrosenb> where did you find the documentation on Parser?
21:05:32 <quattro_cs> Parsec pages.
21:05:34 <quattro_cs> Weird.
21:05:46 <mjrosenb> quattro_cs: also, can I see what you have when it is all in one file?
21:06:03 <quattro_cs> When I moved it back I get that same error now too... I'm so confused.
21:06:22 <quattro_cs> I do have a single file that isn't the same, but uses that same expression.
21:06:28 <quattro_cs> for a scheme parser/interpreter
21:06:33 <quattro_cs> i'll post that. because that definitely still compiles.
21:07:26 <quattro_cs> mjrosenb, http://hpaste.org/40529/scheme_parsec
21:07:32 <quattro_cs> that definitely compiles just fine.
21:08:04 * mjrosenb has a tendency to just write parser combinator libraries when he needs a parser.
21:08:04 <quattro_cs> line 234 is where the similar definition is
21:09:27 <mjrosenb> quattro_cs: http://hpaste.org/paste/40529/definition_of_parser#p40530
21:09:28 <kmc> haha mjonsson
21:09:29 <kmc> err
21:09:31 <kmc> haha mjrosenb
21:09:48 <kmc> it's really not hard, especially if you start with Applicative
21:09:54 <kmc> it already has 'many' :)
21:10:16 <quattro_cs> I've only been using Haskell for a few days. I'll get there one day ;)
21:11:59 * mjrosenb should probably learn how to use Applicative competently.
21:12:27 <conal> mjrosenb: do.  it's good stuff!
21:12:32 <wakeupsticky> hi, how do i get up and running with haskell on ubuntu maverick?
21:13:08 <quattro_cs> wakeupsticky, sudo apt-get install ghc6
21:14:13 <wakeupsticky> error. But I am downloading updates. Is that a conflict?
21:14:21 <wakeupsticky> I'll try again when the updates are done downloading.
21:14:32 <kmc> you want more than ghc6
21:14:34 <kmc> you want haskell-platform
21:14:41 <kmc> http://hackage.haskell.org/platform/
21:14:50 <wakeupsticky> ubuntu doesn't appear to be supported
21:14:57 <kmc> when you click on the fat, happy penguin you will see a link to an Ubuntu PPA
21:15:10 <wakeupsticky> the instructions are out of date (i.e., not for maverick) and look very complicated
21:15:24 <wakeupsticky> lucid ppa? i just installed maverick. 
21:15:47 <kmc> Maverick was just released yesterday ;P
21:16:04 <kmc> anyway i strongly recommend getting all of Haskell Platform
21:16:08 <mjrosenb> conal: i probably asked you this a while ago; did you have the tutorial/example of using datatypes where all of the fields in the constructors are actually functions that operate on things?
21:16:10 <kmc> but an acceptable way to do so
21:16:16 <kmc> is to get ghc and cabal-install (and its deps)
21:16:21 <mjrosenb> kmc: what does the haskell platform include above ghc?
21:16:44 <kmc> and then download the haskell-platform source tgz (which is just dependencies, i think)
21:16:45 <kmc> and install that
21:16:51 <conal> mjrosenb: nothing specific rings a bell.  sounds like an encoding of an object with methods.
21:16:54 <kmc> mjrosenb, a bunch of hackage packages
21:17:04 <kmc> base, array, bytestring, Cabal, containers, directory, filepath, haskell98, hpc, old-locale, time, old-time, pretty, process, random, syb, template-haskell, unix, Win32, cgi, fgl, GLUT, haskell-src, html, HUnit, mtl, network, OpenGL, parallel, parsec, QuickCheck, regex-base, regex-compat, regex-posix, stm, xhtml, zlib, HTTP, deepseq, extensible-exceptions
21:17:17 <mjrosenb> <3 hackport
21:17:20 <kmc> http://hackage.haskell.org/platform/contents.html
21:17:21 <wakeupsticky> ok, now apt-get appears to be getting ghc6
21:17:28 <kmc> cool mjrosenb
21:17:31 <wakeupsticky> so then sudo apt-get cabal-install?
21:17:31 <mjrosenb> kmc: ahh, so everything that breaks whenever i upgrade ghc :-)
21:17:34 <kmc> haha
21:18:23 <mjrosenb> hackport will grab the cabal information from hackage, then attempt to make an ebuild out of it
21:18:26 <wakeupsticky> yeah don't i just need ghc, cabal, and a text editor?
21:18:36 <mjrosenb> so that i only have *one* package manager running on my system
21:18:37 <wakeupsticky> i can get everything else from hackage with cabal right?
21:18:41 <kmc> yeah
21:18:51 <kmc> but having cabal-install (the command-
21:18:54 <kmc> line tool named 'cabal')
21:18:57 <kmc> is very useful
21:19:03 <wakeupsticky> what text editor is recommended? i was using notepad++ on windows
21:19:04 <kmc> and that in turn has a few deps like HTTP
21:19:16 <kmc> i think the haskell-platform tgz actually has those sources
21:19:24 <kmc> wakeupsticky, whatever you're comfortable with
21:19:26 <mjrosenb> wakeupsticky: i recommend emacs. others will likely recommend vim, yi, gedit and kate.
21:19:39 <kmc> a lot of us use emacs or vim but there's no community-wide preference
21:20:00 <wakeupsticky> so i just successfully got ghc6...now sudo apt-get cabal-install?
21:20:04 <kmc> imo none of the Haskell IDEs are really great yet, but you can try out leksah if you want
21:20:05 <mjrosenb> wakeupsticky: there is also a scite editor on linux, which is the core editor behind notepad++
21:20:14 <kmc> a good Haskell IDE could kick serious ass
21:20:20 <kmc> Agda-style holes
21:20:35 <mjrosenb> kmc: i may have one in like 3 years.
21:20:39 <kmc> put a ? in your code, the type of the missing function is inferred then sent off to hackage/hayoo
21:21:02 * hackagebot accelerate 0.8.1.0 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.8.1.0 (ManuelChakravarty)
21:21:05 <wakeupsticky> so i now have ghc6 and cabal-install
21:21:21 <kmc> cool
21:21:36 <kmc> grab http://hackage.haskell.org/platform/2010.2.0.0/cabal/haskell-platform-2010.2.0.0.tar.gz
21:21:38 <wakeupsticky> now i want the tar.gz source package?
21:21:40 <kmc> then run 'cabal install' in that dir
21:21:45 <mjrosenb> kmc: that is what i was talking about with having an all in one parser/tab completion library a couple of weeks ago.
21:21:49 <Jafet> And hackage will collect the queries along with general information that cannot be used to personally identify you, to rate the popularity of packages
21:21:51 <kmc> yeah
21:21:57 <kmc> mjrosenb, have you used scion?
21:22:02 <mjrosenb> nope.
21:22:09 <kmc> http://hackage.haskell.org/package/scion
21:22:57 <mjrosenb> kmc: looks neat
21:23:00 <wakeupsticky> ok, i think i used archive manager to put it in /home/jesse (hi, i'm jesse :P)
21:23:00 <mjrosenb> grr
21:23:10 <wakeupsticky> so now cd /home/jesse and then cabal install?
21:23:19 * mjrosenb thought he fixed that bug in hackport a *long* time ago
21:23:24 <kmc> hi jesse
21:23:35 <kmc> you have to uncompress the tgz
21:23:39 <mjrosenb> wakeupsticky: i imagine you need to untar the file first, then cd into that directory
21:23:45 <kmc> then cd into the directory haskell-platform-2010.2.0.0
21:24:04 <mjrosenb> tar xzf foo.tgz
21:24:39 <wakeupsticky> i have /home/jesse/haskell-platform-2010.2.0.0 with subfolders
21:24:53 <wakeupsticky> don't see a .tgz file there
21:24:57 <kmc> sorry
21:24:59 <kmc> by tgz i meant tar.gz
21:25:04 <kmc> cd to that dir you mentioned and run 'cabal install'
21:26:16 <wakeupsticky> config file does not exist
21:26:24 <wakeupsticky> looks like i have to run "cabal update" first?
21:29:11 <quattro_cs> ok I managed to get that error to go away.
21:29:37 <quattro_cs> I think there may have been some weird conflict between parsec and my function, display. I dunno. I changed the top of my module and it works now... *shrug*
21:29:55 <wakeupsticky> cabal: No cabal file found.
21:30:13 <wakeupsticky> Please create a package description file <pkgname>.cabal
21:31:28 <wakeupsticky> That's the error I got after running "cabal install" in my haskell platform directory.
21:36:57 <nomothetis> can anyone tell me why lineFromString doesn't get called in this code? http://pastie.org/1217404
21:37:39 <wakeupsticky> dead end? :(
21:38:02 <kmc> nomothetis, you're inferring that it isn't, based on 'trace'?
21:38:23 <kmc> perhaps some compiler optimization is getting in the way
21:38:28 <nomothetis> and based on the fact that the program which should return 8000+ eventually return 0...
21:38:30 <nomothetis> :-)
21:38:38 <nomothetis> s/return/returns
21:39:00 <nomothetis> the first trace gets called; the second does not.
21:39:00 <kmc> did you compile with -Wall?
21:39:05 <nomothetis> nope, I just ran:
21:39:11 <nomothetis> ghc -o filename filename.hs
21:39:19 <kmc> if you invoke ghc by hand
21:39:21 <kmc> you should use --make
21:39:26 <kmc> ghc --make -Wall filename.hs
21:39:31 <nomothetis> ok.
21:39:35 <nomothetis> what does -Wall do?
21:39:40 <kmc> this will automatically build any modules filename.hs imports, and link packages it uses
21:39:44 <kmc> -Wall enables all warnings
21:39:48 <nomothetis> ah, I see.
21:40:20 <nomothetis> Oh my.
21:40:24 <nomothetis> I get a whole new slew of warnings.
21:40:25 <nomothetis> :-)
21:40:28 <nomothetis> Okay, I'll dig through those.
21:40:29 <nomothetis> Thanks!
21:40:32 <kmc> no problem :)
21:40:42 <kmc> hlint can be useful too
21:41:01 <kmc> hpaste.org will run your pastes through hlint
21:42:34 <tolkad> To make a pattern match lazy do you have to also put ~ before subpatterns?
21:42:54 <tolkad> I.E. ~(Just 1) or ~(Just ~1)
21:43:07 <tolkad> I'm guessing the latter...
21:43:08 <mjrosenb> you can also add -Wall to the list of flags that ghc uses for an individual file.
21:43:25 <tolkad> > let f ~(Just ~1) = 2 in f (Just 1)
21:43:34 <mjrosenb> tolkad: lambdabot is down
21:43:35 <tolkad> lambdabot is gone : (
21:44:01 <tolkad> ah, it seems to work in ghci so I'm guessing it's true
21:44:12 <kmc> er that one experiment doesn't tell you anything
21:45:28 <tolkad> kmc: well, I don't think it would let you put ~ before subpatterns unless it actually did something. is it implicit? I.E. is ~(Just 1) the same as ~(Just ~1)?
21:45:37 <kmc> no
21:46:15 <kmc> maybe it is for the particular case of 1
21:47:04 <kmc> tolkad, http://hpaste.org/40532/nested
21:47:29 <kmc> here's a case where i start with an irrefutable pattern, make it fail by forcing part, then make it work again by adding more irrefutability
21:48:28 <kmc> i'm sure there's a better example
21:51:54 <kmc> Haskell 98 report has this example:
21:51:56 <kmc> (\ ~[x,~(a,b)] -> x) [(0,1),_|_]    =>    (0,1)
21:51:56 <kmc> (\ ~[x, (a,b)] -> x) [(0,1),_|_]    =>    _|_
21:52:22 <tolkad> ok, I understand
21:52:25 <kmc> the outer ~ defers matching the list until one of the pattern's bound vars is forced
21:52:34 <kmc> we force x, which then forces the pattern under the outer ~
21:55:06 <tolkad> so putting the lazy pattern match symbol before a list forces all the list constructors. that's useful
21:55:14 <tolkad> err I mean
21:55:22 <tolkad> implicitly applies it to all list constructors
21:56:36 <kmc> you mean all the (:)?
21:56:59 <tolkad> yeah
21:57:31 <kmc> hmm
21:57:36 <kmc> i'd have to think about that some more
21:57:50 <tolkad> I.E ~[a, b, c] is the same as ~(a:~(b:~(c:~[])))
21:58:12 <tolkad> I guess I could test it
21:58:37 <kmc> Cale, do you know where our lambdabot went?
22:00:30 <tolkad> no, they aren't the same
22:00:41 <tolkad> Prelude> (\x -> case x of ~(a:(~(b:(~(c:(~[])))))) -> a) [1]
22:00:41 <tolkad> 1
22:01:12 <tolkad> Prelude> (\x -> case x of (~[a, b, c]) -> a) [1]
22:01:13 <tolkad> *** Exception: <interactive>:1:7-33: Irrefutable pattern failed for pattern [a, b, c]
22:03:35 <tolkad> wait now I don't understand the difference between ~(a@(Just _)) and a@(~Just _)
22:04:23 <tolkad> I'll just come back to this later
22:04:34 <mjrosenb> i would imagine that the first does not  attempt to bind a until it is needed, at which point it needs to have just
22:04:52 <mjrosenb> and the second one binds a sooner rather than later
22:05:45 <nomothetis> kmc: I got rid of all the warnings, and the function still doesn't get invoked... :-/
22:06:09 <nomothetis> (again based on the trace statement)
22:06:17 <tolkad> mjrosenb: so ~(_@(Just _)) is the same as _@(~Just _)?
22:06:44 <nomothetis> I've updated the code: http://pastie.org/1217437
22:07:09 <mjrosenb> tolkad: since you can't ever reference the "bound variable", i'd say yes.
22:07:58 <Maxdamantus> > sum [0..1000000]
22:08:28 <Maxdamantus> Hm. Why does that get a stack overflow? Isn't there meant to be a seq in fold* to prevent that?
22:08:38 <tolkad> 500000500000
22:09:14 <tolkad> works in my ghci
22:09:24 <Maxdamantus> Weird.
22:09:46 <Maxdamantus> Actually, I was using enumFromTo.. but I'd not think that'd make a difference.
22:10:09 <Maxdamantus> *** Exception: stack overflow
22:10:09 <Maxdamantus> Prelude> sum [0..1000000]
22:10:10 <Maxdamantus> *** Exception: stack overflow
22:10:17 <tolkad> Maxdamantus: the example you just gave uses enumFromTo
22:10:28 <tolkad> Maxdamantus: maybe I just have more RAM than you, I'll try adding a few digits
22:11:01 <Maxdamantus> I'd imagine that however sum is implemented, it'd be implemented optimally for large lists.
22:11:04 <tolkad> actually *100 will take too long
22:11:18 <tolkad> I'll just wait for *10
22:12:04 <tolkad> I see lots of CPU usage but constant RAM
22:12:25 * Maxdamantus wonders what's wrong with his prelude
22:12:51 <tolkad> it's definitely NOT O(n) though
22:12:57 <tolkad> it's taking way too long
22:13:05 <Maxdamantus> Maybe bigger numbers take longer to add.
22:13:29 <tolkad> it did complete, no stack overflow
22:13:33 <Maxdamantus> But that still wouldn't make much of a difference.
22:13:34 <tolkad> maybe it's defaulting to Integer, I'll try Int
22:14:33 <tolkad> well, Int overflowed a few times but it was much much faster, it's just the Integer type that was making it not O(n)
22:15:27 <tolkad> wow memory leaks, every time I do this GHC does an initial jump in memory and then stays that way afterward
22:15:53 <mjrosenb> are you guys using the same version of ghc?
22:15:54 <Maxdamantus> I thought it reserved memory like that.
22:16:01 <Maxdamantus> GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
22:16:05 <mjrosenb> i would imagine the implementation would change between versions.
22:16:11 <Maxdamantus> Linux, x86_64
22:16:16 <tolkad> Maxdamantus: 6.12.3
22:16:25 <Maxdamantus> Ah.
22:16:27 <tolkad> Maxdamantus: maybe update :P
22:16:28 <mjrosenb> iirc, ghc/ghci uses a fixed amount of stack.
22:16:56 <Maxdamantus> Yeah, it works in 6.12.3
22:17:55 <JoeyA> Why doesn't foo = (,) (at the top-level with no signature) invoke the monomorphism restriction?
22:18:03 <Maxdamantus> But isn't foldl *meant* to be optimal?
22:18:22 <Maxdamantus> It's that that's causing the stack overflow on 6.8.2
22:18:59 <kmc> JoeyA, lack of a typeclass context, i imagine
22:20:15 <kmc> http://www.haskell.org/onlinereport/decls.html#sect4.5.5
22:20:24 <kmc> "In addition, the constrained type variables of a restricted declaration group may not be generalized in the generalization step for that group"
22:21:01 <c_wraith> Maxdamantus, it's true that foldl is rarely the operation you want.  But that doesn't mean it's never what you want.
22:21:07 <c_wraith> @src reverse
22:21:22 <c_wraith> oops, missing bot
22:21:38 <c_wraith> reverse = foldl (flip (:)) []
22:21:46 <c_wraith> foldl is correct there.
22:23:21 <tolkad> c_wraith: why?
22:24:05 <mjrosenb> c_wraith: more correct than foldl'?
22:24:16 <c_wraith> tolkad: because the memory use is the same either way, so you get *slightly* more laziness with that definition
22:24:42 <tolkad> c_wraith: but isn't heap use preferable to stack use?
22:25:04 <c_wraith> honestly, you're never going to reverse a list where it matters.
22:25:27 <c_wraith> if it's big enough to matter, it's big enough to be a complete mess in many other ways, anyway
22:26:06 <tolkad> c_wraith: well sometimes you are incrementally constructing a list in reverse order for later use
22:28:01 <tolkad> so when it comes time to use it you reverse it
22:29:11 <tolkad> like let's say you are reading characters one by one from some IO device and storing them in a buffer, then extracting the entire contents of the buffer at once
22:29:30 <tolkad> it would be fastest for the buffer to be backwards and reverse it when you take it out
22:29:55 <tolkad> c_wraith: is anything wrong with that?
22:30:42 <c_wraith> it involves the whole thing being in memory.  Other strategies (lazy IO, iteratee/enumerator) might not.
22:33:10 <kmc> use an iteratumeratoratee
22:33:36 <kmc> use the Iteratumeratoratee Pattern
22:33:39 <tolkad> well, I could construct some example where processing the string is expensive and you don't know if you need to process the string until you have recieved the whole thing. I guess that's rather uncommon though
22:33:44 <c_wraith> pattern-oriented programming!
22:48:16 <Maxdamantus> Hm, so seq is actually quite different to (\a b -> if (a == a) then b else b)
22:49:07 <Veinor> in particular, seq doesn't need an Eq instance for its first argument
22:49:19 <Maxdamantus> Other than that
22:49:25 <Veinor> also, those have different levels of strictness
22:49:32 <kmc> Eq can be lazy
22:49:58 <Veinor> > (\a b -> if (a == a) then b else b) [2,3,undefined] "whoo"
22:50:06 <Veinor> lambdabot noo D:
22:50:23 <kmc> yeah
22:50:24 <Maxdamantus> seq (fix id, 42) 84
22:50:26 <Veinor> well, that will 'evaluate' to undefined. but seq will evaluate to "whoo"
22:50:37 <kmc> i guess it's far more common for (==) to be stricter than whnf
22:50:53 <kmc> i have made some types with _ == _ = False
22:51:05 <kmc> that's kinda bad though
22:51:12 <Maxdamantus> Float?
22:51:26 <kmc> well,  Float's (==) is not reflexive
22:51:38 <kmc> but it's not (const $ const False) either ;P
22:51:53 <Veinor> kmc: why would you make a type with _ == _ = False?
22:52:49 <Jafet> True==True = True; False==False = True; _==_ = False
22:53:02 <Jafet> (OR: deriving Eq)
22:54:40 <kmc> i had a big sum type
22:54:48 <kmc> one of the ctors contains a function
22:54:53 <Veinor> ah
22:54:59 <Veinor> (ctors? :P)
22:55:13 <kmc> i wanted the derived Eq except that functions should compare as unequal
22:55:16 <mjrosenb> Float is all sorts of special.
22:55:17 <kmc> so i newtype wrapped the function
22:55:24 <kmc> then i found five dollars
22:56:55 <tolkad> is there any reason this library doesn't use type families? http://hackage.haskell.org/packages/archive/Vec/0.9.6/doc/html/src/Data-Vec-Base.html
22:56:55 <tolkad> it could do something like « data family a :. b :: *; newtype instance a :. () = VecEnd !a; newtype instance a :. (b :. c) = (!a, {-# UNPACK #-} (b :. c)) »
22:57:18 <mjrosenb> kmc: did aliza get that from you?
22:57:39 <kmc> mjrosenb, i think i got it from Caltech, before i knew Aliza
22:57:44 <tolkad> wait
22:57:53 <tolkad> « data family a :. b :: *; newtype instance a :. () = VecEnd !a; data instance a :. (b :. c) = (!a, {-# UNPACK #-} (b :. c)) »
22:57:59 <kmc> it's pretty widespread by now
22:58:11 <tolkad> that would mean it would be only boxed one level
22:58:34 <tolkad> so it shouldn't have any worse overhead than tuples
22:58:44 <tolkad> (except for tuple specific optimizations of course)
22:59:09 <tolkad> also it would be safer as all vectors would be guaranteed to end with ()
22:59:19 <kmc> interesting tolkad
22:59:54 <kmc> i like it
23:00:14 <tolkad> ooh, there's another error
23:00:32 <tolkad> I shouldn't use a newtype the first time either, it will end up unpacking the underlying type
23:00:47 <tolkad> « data family a :. b :: *; data instance a :. () = VecEnd !a; data instance a :. (b :. c) = (!a, {-# UNPACK #-} (b :. c)) »
23:03:57 <tolkad> ok I messed that up horribly
23:04:01 <tolkad> I'll try again
23:04:35 <tolkad> « data family a :. b :: *; data instance a :. () = VecEnd !a; newtype instance a :. (b :. c) = Vec (!a, {-# UNPACK #-} (b :. c)) »
23:04:47 <manateeUser> ......-...-..-----..-- .-.-...-..! 
23:05:00 <kmc> batman!
23:05:47 <manateeUser> Morse code.
23:07:09 <manateeUser> -....- -----.-..... -.-.----... -.-.-----.--..-...-.--..-- -...-.--. .-.-...-..! ---...-.--.-
23:12:02 * EvanR chastises manateeUser for using dots and dashes
23:12:42 <EvanR> bad ham etiquette ;)
23:12:53 <kmc> what should they be?
23:13:01 <EvanR> sound only
23:13:21 <kmc> — and ●
23:14:16 <EvanR> period is the accepted letter, its just almost never used, except in very beginner literature not intended to actually teach you anything
23:14:56 <EvanR> you dont want to mess with visual stimulus while trying to copy code
23:15:16 <kmc> so you have to learn from tapes or something?
23:15:33 <EvanR> or internet, or your actual radio
23:15:59 <EvanR> i actually found a console app for it
23:16:38 <earthy> sccw e.g.
23:17:15 <earthy> and then there's lcwo
23:20:55 <mjrosenb> @pl \x (a,b) -> f x a b
23:21:03 <mjrosenb> damnit lambdabot
23:21:13 <mjrosenb> also, i suspect i wanted unpl
23:22:01 <Phyx-> you guys still up
23:22:26 <mjrosenb> Phyx-: nope, been asleep for hours.
23:23:08 <Phyx-> lol
23:23:21 <kmc> sleep-haskelling :O
23:24:26 <Phyx-> bleh, can anyone turn of the sun please
23:24:28 <Phyx-> kthanks
23:27:09 <sciolizer> @pl (\a b c -> (a c, b c))
23:27:10 <kmc> oracle can
23:27:31 <sciolizer> Lambdabot in for an oil change?
23:27:53 <kmc> seems so
23:30:37 * hackagebot MorseCode 0.0.1 - Morse code  http://hackage.haskell.org/package/MorseCode-0.0.1 (AndyStewart)
23:30:53 <Phyx-> sciolizer: she's having a talk with her union rep about the conditions of her VM
23:32:35 <sciolizer> Phyx-: I knew she had a runtime system, but when did she get a VM?
23:33:18 <Phyx-> sciolizer: that's the problem, I think she wants one, all to herself
23:36:07 <Jafet> Prima donna, first lady of the stage
23:36:41 <mjrosenb> @unpl \x -> x
23:36:41 <lambdabot> \ x -> x
23:36:47 <mjrosenb> yay, lambdabot!
23:37:56 <Maxdamantus> @unpl id
23:37:56 <lambdabot> (\ a -> a)
23:38:17 <mjrosenb> Maxdamantus: more happy that lambdabot is back.
23:38:20 <Maxdamantus> @unpl const . const . const
23:38:21 <lambdabot> (\ f _ _ _ -> f)
23:39:02 <mjrosenb> @pl \x (y,z) -> f x y z
23:39:02 <lambdabot> (`ap` snd) . (. fst) . f
23:39:19 <mjrosenb> of course.  how could i not see that one before.
23:39:31 <Maxdamantus> @unpl (>>)
23:39:31 <lambdabot> (>>)
23:39:38 <sciolizer> @pl \a b c -> (a c, b c)
23:39:38 <lambdabot> liftM2 (,)
23:39:47 <Veinor> lambdabot!
23:41:13 <Maxdamantus> @unpl ap (,) 
23:41:14 <lambdabot> (\ e -> (,) >>= \ b -> e >>= \ a -> return (b a))
