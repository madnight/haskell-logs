00:00:23 <turiya> it looks like pollEvent is a bad idea for static image display (i get >98% cpu usage).. waitEvent is much better (0% cpu)..
00:00:52 <guest2524> Do yuo guys know that Haskell is 15 
00:00:55 <guest2524> years old
00:01:11 <guest2524> the owner is Simon is 45 years old
00:01:26 <lispy> guest2524: we should start preparing for the sweet 16
00:01:37 <guest2524> hahahaha
00:01:44 <guest2524> is a guy o girl
00:01:51 <razvandimescu> hello i'm new to haskell
00:01:57 <razvandimescu> i've entered ghci
00:02:07 <razvandimescu> but it seems that quit returns <interactive>:1:0: Not in scope: `quit'
00:02:11 <lispy> turiya: that's odd.  Shouldn't they be similar?  eg., Is it possible the pollEvent version is not written right?
00:02:20 <razvandimescu> what am i doing wrong?
00:02:25 <guest2524>  razvandimescu: that makes 2
00:02:35 <guest2524> razvandimescu: what u did?
00:02:40 <lispy> razvandimescu: you need to use a colon for commands to the interpreter
00:02:51 <lispy> razvandimescu: like, :quit
00:02:52 <dolio> guest2524: It isn't a function in Data.List.
00:02:57 <razvandimescu> :D cool stuff, thanks
00:03:00 <dolio> It's a function you should write.
00:03:07 <guest2524> oh ok
00:03:15 <razvandimescu> lispy: thanks
00:03:25 <lispy> razvandimescu: you're welcome
00:03:26 <turiya> lispy: i am not sure but the only change of replacing pollEvent by waitEvent reduced the cpu usage
00:03:28 <guest2524> dolio: like using swap
00:04:25 <guest2524> OMG OMG HASKELL HAS Sexy types
00:04:33 <guest2524> i dont think so
00:05:19 <davekong> OK, if I close stdin how do I open it again later?
00:05:40 <lispy> davekong: dup2?
00:06:05 <davekong> where is that?
00:06:19 <lispy> ?hoogle dup2
00:06:27 <lispy> hmm...no lambdabot?
00:06:50 <davekong> http://haskell.org/hoogle/?hoogle=dup2 no result
00:07:22 <lispy> It's called dup2 in posix, but maybe not in haskell
00:07:46 <kmc> look for it in the posix modules
00:09:16 <lispy> davekong: basically, once you have a file descriptor you can use dup2 to "clone" the file descriptor to some specific file descriptor
00:09:41 <lispy> davekong: shells use it to implement pipes
00:09:44 <ski> @type insertBy
00:09:57 <ski> :t insertBy
00:10:11 * ski slaps hsbot
00:10:48 <davekong> lispy: thanks System.Posix.IO dup and dupto look promising
00:10:48 <ski> preflex: seen hsbot
00:10:49 <preflex>  hsbot was last seen on #haskell 2 hours, 32 minutes and 51 seconds ago, saying:   ["Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hel...
00:11:46 <ski> joe1 : did you manage to get your program into looking better ?
00:12:36 <Jafet> > typeOf insertBy
00:12:37 <hsbot>   Not in scope: `typeOf'
00:12:44 * Jafet slaps hsbot
00:13:27 * Maxdamantus wonders if typeOf can be implemented.
00:14:07 <guest2524> dolio: any more clues
00:14:12 <Jafet> I have no clue how to implement it, I just import Data.Typeable
00:15:22 <ski> > insertBy (\x y -> Dual x <= Dual y) [] "abcd"
00:15:23 <hsbot>   Couldn't match expected type `GHC.Ordering.Ordering' against inferred type `GHC.Bool.Bool'
00:15:23 <dolio> guest2524: Not really.
00:15:30 <ski> > insertBy (\x y -> Dual x `compare` Dual y) [] "abcd"
00:15:31 <hsbot>   Couldn't match expected type `[a]' against inferred type `GHC.Types.Char'
00:15:40 <guest2524> dolio: thank you
00:16:05 <ski> > insertBy (\x y -> Dual x `compare` Dual y) '@' "abcd"
00:16:06 <hsbot>   "@abcd"
00:16:19 <ski> > insertBy (\x y -> Dual x `compare` Dual y) 'a' "cd"
00:16:20 <hsbot>   "acd"
00:17:16 <ski> > foldr (insertBy (compare `on` (`mod` 2)) [3, 1, 6, 4, 2]
00:17:17 <hsbot>   <no location info>: parse error (possibly incorrect indentation)
00:17:24 <ski> > foldr (insertBy (compare `on` (`mod` 2))) [3, 1, 6, 4, 2]
00:17:25 <hsbot>   No instance for (GHC.Show.Show ([a] -> [a])) arising from a use of `M780353214.show_M780353214' at <interactive>:(2,0)-(4,36) Possible fix: add an instance declaration for (GHC.Show.Show ([a] -> ...
00:17:32 <ski> > foldr (insertBy (compare `on` (`mod` 2))) [] [3, 1, 6, 4, 2]
00:17:33 <hsbot>   [6,4,2,3,1]
00:17:56 <ski> > foldr (insertBy (compare `on` ((1 -) . (`mod` 2)))) [] [3, 1, 6, 4, 2]
00:17:57 <hsbot>   [3,1,6,4,2]
00:18:50 <ski> > foldr (insertBy (compare `on` (`divMod` 2))) [] [0 .. 7]
00:18:50 <hsbot>   [0,1,2,3,4,5,6,7]
00:19:36 <ski> > foldr (insertBy (compare `on` ((snd &&& fst) . (`divMod` 2)))) [] [0 .. 7]
00:19:37 <hsbot>   [0,2,4,6,1,3,5,7]
00:21:17 <guest2524> ski: you are going to get an error message not in scope 'on'
00:21:30 <ski> `on' is in scope in hsbot
00:21:46 <guest2524> what is hsbot
00:21:47 <guest2524> ?
00:22:09 <ketil> An IRC bot?
00:22:14 <guest2524> oh ok
00:22:37 <guest2524> how about a regular compile
00:22:39 <guest2524> ?
00:22:44 <ski> (more or less) a stand-in for lambdabot, while she's resting
00:23:06 <ski> (.. or whatever keeps her away from us)
00:23:13 <guest2524> oh my
00:23:41 <guest2524> ski: how about a regular compile?
00:23:45 <razvandimescu> doubleSmallNumber' x = if x > 100 then x else x*2 + 1 , why is +1 only added for numbers smaller than 100
00:23:46 <guest2524> ghc
00:23:52 * ski is not really sure what guest2524 is trying to do ..
00:24:11 <dolio> Write the bubble pass of a bubble sort using foldr.
00:24:31 <guest2524> who is ski
00:24:32 <guest2524> ?
00:24:41 <ski> but you might try to write a function `f' such that `foldr f []' on lists like `[3,1,6,4,2]' gives whatever list you want
00:24:50 * ski is ski
00:24:53 <guest2524> yeah
00:24:56 <guest2524> oh ok
00:25:27 <guest2524> ski: I want to do this Write the bubble pass of a bubble sort using foldr.
00:25:41 * ski was thinking for a while that guest2524 wanted to sort a list by odd-evenness, odds first, evens then
00:25:45 <ziman> razvandimescu, i'd guess this is a priority issue - parenthesize the if-else expression and add +1 after that
00:26:00 <guest2524> oh ok
00:26:14 <guest2524> this is funny
00:26:19 <guest2524> who is ski
00:26:21 <guest2524> ???
00:26:28 <dolio> ski: It's homework, though, so don't just give the answer.
00:26:34 <ski> guest2524 : i'm me
00:26:42 <guest2524> ok
00:26:42 <Nibble> i'm you.
00:26:46 <ski> dolio : yeah .. i already figured that :)
00:26:47 <guest2524> a person
00:26:58 <guest2524> or a boot
00:27:00 <razvandimescu> ziman: i was just wondering why is it applied only to the "else" clause
00:27:00 <ski> just someone who hangs around this channel
00:27:07 <guest2524> oh ok
00:27:19 <guest2524> ski: i dont want the answer just the start 
00:27:38 <ziman> razvandimescu, it appears sensible to me that (+) binds tighter than if-else-then...
00:27:39 <guest2524> ski: I know I have to do it but I am stuck
00:27:45 <ziman> *if-then-else :)
00:27:52 <ski> razvandimescu : instead of `if ... then ... else ... + 1' which will be interpreted as `if ... then ... else (... + 1)' you can write `1 + if ... then ... else'
00:28:19 <ski> ziman : actually, sometimes i'd like to write `if'-`else'-`then', instead :)
00:28:32 <guest2524> ski: I know I have to do the homework but I just want the start up
00:28:45 <guest2524> if you can give any clues
00:29:10 <ski> razvandimescu : of course you can also write `(if ... then ... else ...) + 1' as ziman suggested .. but i prefer instead writing `1 +' before the `id'-expression
00:29:24 <ziman> yes, less clutter, more readability
00:29:51 <ski> guest2524 : if you write `foldr f [] xs', then this will traverse the list "from the end"
00:30:47 <ski> guest2524 : it will start with a "current result" (call it `acc') of `[]'. and then, for each element `x' in the list `xs', it will compute the next "current result" as `f x acc'
00:31:09 <ski> guest2524 : finally, when it reaches the start of the list, the current result is the final result of the whole
00:31:26 <ziman> > foldr f z [x,y]
00:31:27 <hsbot>   Not in scope: `f'Not in scope: `z'Not in scope: `x'Not in scope: `y'
00:31:34 <ski> btw, note that this is just a way to think about what `foldr' does .. it doesn't imply that things need to be evaluated in this order
00:31:47 <ski> hsbot appears to not have `Expr' in scope
00:31:48 <guest2524> yeah thank you
00:31:53 <guest2524> thats help
00:31:55 <ski> so
00:32:02 <guest2524> thank you to everybody 
00:32:06 <guest2524> yes ski
00:32:07 <ski> do you want to percolate up the list, or down the list ?
00:32:07 <guest2524> ?
00:32:35 <guest2524> I want to do bubble sort 
00:32:40 <guest2524> with the list
00:32:42 <ski> do you want to "bubble" (i.e. percolate) an element at a time, in the direction from the start to the end of the list ?
00:32:47 <ski> or the other direction ?
00:32:52 <ski> say you start with the list
00:33:00 <ski>   [4,2,8,5,7,1]
00:33:17 <ski> which list do you want to get, after one round of bubble-sort ?
00:33:50 <guest2524> [2,4,5,8,,1,7]
00:33:53 <guest2524> ??
00:34:14 <ski> why not
00:34:24 <ski>   [2,4,5,7,1,8]
00:34:25 <ski> ?
00:34:29 <ski> or
00:34:37 <guest2524> oh yeah
00:34:38 <ski>   [1,4,2,8,5,7]
00:34:39 <ski> ?
00:34:44 <guest2524> I am confuse ski
00:34:48 <ski> (depending on the direction you move in)
00:35:17 <ski> you should be able to manually walk through what your bubble-sort is expected to do, on a small list
00:35:32 <guest2524> like this list [3, 1, 6, 4, 2] and  get this [1,3,2,6,4]
00:35:37 <guest2524> ski:
00:36:06 <Jafet> > product [1..100000] `seq` ()
00:36:11 <hsbot>   *Exception: mueval-core: signal: 15
00:36:31 <Jafet> > let bsplit _ b [] = b; bsplit _ _ [x] = x; bsplit f b xs = let l = length xs `div` 2 in bsplit f b (take l xs) `f` bsplit f b (drop l xs); fac n = bsplit (*) 1 [1..n]; in fac 100000 `seq` ()
00:36:32 <hsbot>   ()
00:36:33 <ski> guest2524 : i think you mean to get `[..,4,6]' at the end, no ?
00:36:47 <guest2524> no 
00:36:54 <ski> hm, actually, no .. `[..,4,2,6]', rather
00:37:05 <guest2524> ski: like this result [1,3,2,6,4]
00:37:25 <guest2524> ski : from this input [3, 1, 6, 4, 2] 
00:38:02 <ski> the point of bubble-sort is to compare two adjacent elements at a time, then continue with the next two (including one of the ones you compared just before)
00:38:06 <ski> so, e.g.
00:38:15 <ski>   [3,1,6,4,2]
00:38:18 <dolio> @let foo = 5
00:38:23 <ski>     X
00:38:29 <dolio> Doesn't have that either, it seems.
00:38:30 <ski>   [1,3,6,4,2]
00:38:37 <ski>      | |
00:38:41 <ski>   [1,3,6,4,2]
00:38:50 <ski>         X
00:38:54 <ski>   [1,3,4,6,2]
00:38:59 <ski>           X
00:39:03 <ski>   [1,3,4,2,6]
00:39:10 <ski> that would be one round
00:39:18 <guest2524> oh ok
00:39:25 <ski> you could also start from the other end of the list, like
00:39:33 <ski>   [3,1,6,4,2]
00:39:38 <ski>           X
00:39:42 <ski>   [3,1,6,2,4]
00:39:46 <ski>         X
00:39:50 <ski>   [3,1,2,6,4]
00:39:59 <ski>      | |
00:40:01 <ski>   [3,1,2,6,4]
00:40:08 <ski>     X
00:40:12 <ski>   [1,3,2,6,4]
00:40:23 <guest2524> yes like that
00:40:26 <guest2524> exactly
00:40:35 <ski> you need to pick one direction to go .. it probably doesn't matter much which you pick
00:40:44 <guest2524> but how can I write that out
00:40:50 <guest2524> to start with the tail
00:40:50 <Jafet> dolio: it's a ghci that forbids permanent space leaks
00:41:38 <ski> well, `foldr' "traverses the list from right-to-left" (that's not completely true, but it's conceptually the right way to think, here)
00:41:48 <guest2524> ok
00:41:55 <ski> so, if you want to use `foldr', then you probably want to do a right-to-left traversal
00:42:01 <guest2524> yes
00:42:06 <ski> remember that
00:42:14 <ski>      foldr f [] [3,1,6,4,2]
00:42:21 <guest2524> yes
00:42:32 <ski>   =  f 3 (f 1 (f 6 (f 4 (f 2 []))))
00:42:41 <ski> you need to write `f'
00:42:41 <guest2524> ok
00:42:48 <guest2524> yes
00:42:54 <guest2524> but I am stuck in there
00:43:03 <guest2524> i dont know how to start f
00:43:13 <ski> the second argument of `f', at each step, will be the "current result of the round, for the rest of the list, to the right"
00:43:26 <ski> and `f' will need to decide how to add the next element to the left, to that result list
00:43:35 <guest2524> yes
00:43:52 <ski> so, looking at the above round for `[3,1,6,4,2]', `f' will first get `2' and `[]' as arguments
00:44:10 <ski> (and you want to return `[2]', then, since there's no elements to compare yet)
00:44:17 <guest2524> so you mean the tail and the list
00:44:17 <guest2524> ?
00:44:45 <guest2524> f (x:xs) = xs []
00:44:49 <ski> then, in the next step, it will get `4' and `[2]' as arguments .. and then you need to compare `4' with `2', notice you need to swap, and return `[2,4]'
00:45:05 <guest2524> ok
00:45:19 <ski> then, in the next step, it will get `6' and `[2,4]' as arguments .. and then you need to compare `6' with `2', notice you need to swap, and return `[2,6,4]'
00:45:41 <guest2524> so if x > xs swap x
00:45:44 <ski> then, in the next step, it will get `1' and `[2,6,4]' as arguments .. and then you need to compare `1' with `2', notice you *don't* need to swap, and return `[1,2,6,4]'
00:45:46 <ski> &c.
00:45:58 <ski> that's how your algorithm will function
00:46:18 <guest2524> so comparing and swaping?
00:46:21 <ski> what you need to do is write an `f' that accomplishes all these steps, correctly
00:46:24 <ski> yes
00:46:33 <guest2524> the head with the tail
00:46:36 <ski> all `f' needs to do is a single step of a whole round
00:46:49 <ski> `foldr' will take care of looping through the list
00:46:49 <guest2524> sounds so simple 
00:46:58 <guest2524> but I am getting crazy 
00:47:04 <guest2524> with  this Language
00:47:08 <guest2524> the TRUE
00:47:14 <ski>   f :: Ord a => a -> [a] -> [a]
00:47:19 <guest2524>  or mean Boolean
00:47:22 <ski>   f x xs = ..x..xs..
00:47:35 <ski> what about `Bool' ?
00:47:45 <guest2524> I am just kidding
00:48:10 <Jafet> Don't forget to set the swapsThisRound flag
00:48:24 * ski was ignoring that detail, for the moment :)
00:48:26 <Jafet> Bubble sort is especially pitiful in haskell
00:48:48 <guest2524> so ski f x xs = if x > xs then swap x else xs
00:48:58 <guest2524> ski:  f x xs = if x > xs then swap x else xs
00:49:06 <ski> (one option is to always do `length xs - 1' rounds ..)
00:49:16 <ski> well, you can't compare `x' and `xs' directly
00:49:22 <ski> `x' is an element, `xs' is a list of elements
00:49:29 <guest2524> oh ok
00:49:32 <Jafet> head . dropWhile (not. sorted) . iterate
00:49:40 <ski> you will probably want to use pattern-matching on `xs'
00:49:49 <ski> Jafet :)
00:50:06 <guest2524> oh ok
00:50:33 <guest2524> oh ok
00:50:40 <guest2524> thank you much to every one
00:50:45 <guest2524> i do appreciate
00:50:49 <guest2524> I am so sleepy
00:50:52 <guest2524> nite nte
00:50:56 <guest2524> nite nite
00:51:07 <ski> good night. and good luck !
00:55:29 <Jafet> > let bsplit _ b [] = b; bsplit _ _ [x] = x; bsplit f b xs = let l = length xs `div` 2 in bsplit f b (take l xs) `f` bsplit f b (drop l xs); merge xs [] = xs; merge [] ys = ys; merge (x:xs) (y:ys) = if y < x then y:merge (x:xs) ys else x:merge xs (y:ys); sort xs = bsplit merge [] (map return xs); in sort [10,9..1]
00:55:30 <hsbot>   [1,2,3,4,5,6,7,8,9,10]
00:58:48 <razvandimescu> let a=3
00:59:52 <razvandimescu> let myList = take 2 [1,2,3,4]
01:00:30 <razvandimescu> i've noticed that hsbot is returning the result?
01:01:16 <ski> only if you prefix with `> ' .. and it doesn't understand `let'-commands (but it understands `let'-expressions)
01:01:24 <ski> > take 2 [1,2,3,4]
01:01:25 <hsbot>   [1,2]
01:01:48 <ski> > let a=3; myList = take 2 [1,2,3,4] in (a,myList)
01:01:49 <hsbot>   (3,[1,2])
01:23:07 <ski> > let sort = bSplit [] merge . (map (:[])); bSplit a0 _ [] = a0; bSplit _ _ [a] = a; bSplit a0 (++) as = bSplit a0 (++) (coalesce as) where {coalesce (a1:a2:as) = (a1 ++ a2) : coalesce as; coalesce as = as}; merge ls [] = ls; merge [] rs = rs; merge ls0@(l:ls) rs0@(r:rs) | l <= r = l : merge ls rs0 | otherwise = r : merge ls0 rs in sort [9,8 .. 1]
01:23:08 <hsbot>   [1,2,3,4,5,6,7,8,9]
01:29:38 <davekong> I've been trying a ton of different things, how do I make sure that with an interactive program input from stdin is on registered at a specific time and the other input gets thrown away or is blocked?
01:30:02 <davekong> closing using dup didn't work (closing and opening it)
02:09:45 <sbrg> http://hackage.haskell.org/package/jail
02:09:54 <sbrg> This pakcage is too awesome
02:09:56 <sbrg> the idea, anyway
02:10:39 <Rembane2> Indeed
02:55:42 <cch> :t <$>
02:56:30 <ziman> <$> is fmap, defined in Control.Applicative
02:57:01 <ziman> (<$>) :: Functor a => (a -> b) -> f a -> f b
02:57:36 <cch> I was asking lambdabot :)
02:57:37 <cch> 3x
02:57:54 <cch> thanks
02:58:08 <ziman> she isn't here
02:58:39 <ziman> @type fmap
02:59:00 <cch> have a rest for weekend ? :)
03:00:01 <ziman> probably :)
03:00:44 <cch> ok, i notice there is hsbot
03:00:48 <ziman> i thought hsbot would answer to @type but it appears it uses different syntax (or does not provide @type at all)
03:01:01 <cch> > @type fmap
03:01:02 <hsbot>   <no location info>: parse error on input `@'
03:02:10 <kmc> Cale is not here either
03:02:29 <ski> @help
03:02:35 <cch> @help
03:02:42 <kmc> @halp
03:02:47 <FauxFaux> @help
03:03:08 <aristid> preflex: seen lambdabot
03:03:09 <preflex>  lambdabot was last seen on #haskell 8 hours, 42 minutes and 12 seconds ago, saying: * lambdabot is retiring, good night all
03:03:15 <kmc> oh dear
03:03:20 <aristid> NOOOOOOOOOOOOO, don't retire, lambdabot
03:03:37 <kmc> would make more sense if she was on strike
03:04:16 <aristid> too many pointless types and pointful expressions
03:28:19 <nlogax> ziman: it has .type
03:28:30 <ski> .type ()
03:28:30 <hsbot> ()
03:29:12 <nlogax> lambdabot isn't coming back? :´(
03:29:29 <ski> i'd ask Cale, if he was here
03:32:25 <cch> .type forM
03:32:26 <hsbot> (Monad m) => [a] -> (a -> m b) -> m [b]
03:55:49 <AmJa> hi
03:56:28 <AmJa> guys i have an issue with a a simple "C" programming code
03:56:44 <AmJa> would anyone like to help for a few mins?
03:57:46 <ski> AmJa : unless that is also related to the programming language Haskell, you might want to join the ##c channel and ask your question there
03:58:10 <AmJa> Oh sorry this is my first time here 
03:58:11 <ski> this is an IRC channel for discussing things related to the programming language Haskell
03:58:20 <AmJa> how do I join ##C channel?
03:58:21 <ski> ##c is the appropriate channel for the programming language C
03:58:24 <Nibble> AmJa: pm me
03:58:27 <ski> well, typicall you write
03:58:34 <ski> /join ##c
03:58:35 <AmJa> ##C
03:58:36 <Nibble> I can perhaps help you.
03:58:41 <AmJa> k
03:59:41 <ski> AmJa : if you type that, most IRC clients (afaik) will interpret that as you wanting to join the ##c channel
03:59:57 * hackagebot text-xml-qq 0.1 - Quasiquoter for xml. XML DSL in Haskell.  http://hackage.haskell.org/package/text-xml-qq-0.1 (OscarFinnsson)
04:18:34 <arcatan> oh wow, ndm has pushed lots of new versions of cmdargs since 0.2
04:18:52 <arcatan> i wonder if there's a changelog somewhere
04:20:59 <arcatan> (not in the sense of darcs changes but more like a NEWS file)
04:21:16 <ivanm> his blog posts are about it IIRC
04:23:28 <arcatan> no, he hasn't blogged about it since August
04:29:14 <arcatan> can you access package version defined in the cabal file from package code?
04:32:53 <ivanm> yes
04:33:02 <ivanm> using the Paths_* module from Cabal
04:33:11 <ivanm> xmonad does it
04:33:15 <ivanm> (if you want an example)
04:34:41 <arcatan> ok, thanks! i'll take a look
04:36:23 <manateeUser> ivanm: Hey. :)
04:37:20 <ivanm> hi manateeUser 
04:38:43 <manateeUser> ivanm: Use gtk2hs? We ready to release gtk2hs-0.12.0.
04:39:08 <ivanm> no, I don't
04:39:13 * ivanm tries to avoid GUI programming
04:39:26 <manateeUser> ivanm: GUI is fun. :)
04:44:55 <ManateeLazyCat> www.gtk.org/language-bindings.html
04:44:59 <ManateeLazyCat> Looks Haskell.
04:46:11 * hackagebot xml-monad 0.2 - Monadic extensions to the xml package.  http://hackage.haskell.org/package/xml-monad-0.2 (AristidBreitkreuz)
04:49:31 <arcatan> could some once again explain to me why everyone is getting away from mtl?
04:50:44 <ivanm> arcatan: the main idea behind the transformers split is to separate it out into haskell2010 and extension stuff
04:50:52 <ivanm> namely MPTCs and FDs
04:51:00 <ivanm> (or TFs in monad-tf)
04:51:02 <deggis> leaving democompo entry made with haskell to altparty jury's hands: check
04:51:07 <kmc> also, it's ugly to have monad and monad-transformer versions of everything
04:51:23 <ivanm> arcatan: so mtl-2 is likely going to be just the current monad-fd
04:51:26 <kmc> in 'transformers' the "base monad" is just a synonym for the transformer applied to Identity
04:51:36 <arcatan> deggis: :O, at alt party?
04:51:50 <deggis> arcatan: jea
04:52:29 <deggis> (beginner demo compo though, since there was such :)
04:52:30 <arcatan> deggis: which compo are you taking part to?
04:52:34 <arcatan> ah
04:53:35 <aristid> arcatan: i use monadLib to escape the mess of mtl/monads-fd/monads-tf/transformers
04:53:44 <deggis> gpipe helloworld and nice music, entertaining all 77s
04:54:27 <ivanm> preflex: seen lambdabot
04:54:27 <preflex>  lambdabot was last seen on #haskell 10 hours, 33 minutes and 31 seconds ago, saying: * lambdabot is retiring, good night all
04:54:36 <ivanm> :o lambdabot retired? :o
04:54:49 <dom96> :O
04:54:54 <ivanm> didn't anyone try offering her a raise if she'd stay?
04:54:55 <ivanm> :p
04:55:36 <ManateeLazyCat> preflex: seen duncan
04:55:38 <preflex>  duncan was last seen on ##c++ 1 year, 343 days, 21 hours, 7 minutes and 30 seconds ago, saying: Eelis: thanks
04:56:01 <ivanm> ski: hmmm...
04:57:09 <dom96> what's the best text editor/ide to use for haskell programming?
04:57:32 <arcatan> on the editor front, many use emacs or vim
04:57:38 <AmJa> f
04:57:44 <AmJa> join #c
04:57:46 <ManateeLazyCat> dom96: Emacs or vi
04:57:50 <AmJa> join ##C
04:57:56 <kmc> dom96, whatever you're otherwise comfortable with
04:58:00 <arcatan> on the ide front, some use leksah
04:58:02 <AmJa> join ##c
04:58:07 <AmJa> why is it not working?
04:58:08 <arcatan> kmc has the best suggestion
04:58:09 <kmc> AmJa, /join ##c
04:58:10 <ski> AmJa : you need to write a `/' before that
04:58:11 <kmc> with a slash
04:58:15 <ski> /join ##c
04:58:17 <ski> like that ^
04:58:29 <AmJa> ok i did nothing happened
04:58:37 <dom96> oh, i'm using gedit currently. I'm wondering if there is anything that will make programming in haskell easier.
04:58:50 <dom96> I guess i should try emacs
04:59:02 <ManateeLazyCat> dom96: Yes, Emacs will improve your efficient.
04:59:22 <dom96> Emacs is a lot different than other editors though :\
04:59:25 <kmc> dom96, learning emacs or vim well will probably make all of your programming more efficient
04:59:27 * ski doesn't know how one is meant to join new channels in PJIRC .. :/
04:59:32 <kmc> this is nothing special about Haskell
04:59:35 <AmJa> am I i n  c now? cuz i typed /join ##c
04:59:41 <kmc> no you're not AmJa
04:59:47 <ski> AmJa : how did you manage to join this channel ?
04:59:49 <kmc> what IRC client are you using?
04:59:53 <AmJa> through a site 
04:59:54 <ski> PJIRC
05:00:02 <AmJa> gogloom
05:00:02 <ManateeLazyCat> kmc: My own Haskell IRC client. :)
05:00:05 <AmJa> gogloom.com
05:00:15 * hackagebot darcs-fastconvert 0.1.1 - Import/export git fast-import streams to/from darcs.  http://hackage.haskell.org/package/darcs-fastconvert-0.1.1 (PetrRockai)
05:00:32 <dom96> AmJa: why not use freenode's webchat? http://webchat.freenode.net
05:00:35 * ivanm randomly guesses AmJa used tryhaskell.org
05:00:42 <arcatan> yay for not documenting my own code, what did I mean with LVar...
05:01:01 <ManateeLazyCat> dom96: I suggest you drop gedit and try use Emacs.
05:01:01 <ivanm> heh
05:01:04 <AmJa> dont even know what haskell is 
05:01:13 <AmJa> i just typed c programming chat in google
05:01:16 <ivanm> (to arcatan)
05:01:21 <ivanm> AmJa: which website did you get?
05:01:22 <AmJa> and it sent me here
05:01:36 <AmJa> gogloom.com
05:01:36 <dom96> ManateeLazyCat: Do you know of any good emacs tutorials?
05:01:40 <mauke> google doesn't send you anywhere, it lists seach results
05:01:52 <ManateeLazyCat> dom96: Emacs manual in Emacs.
05:01:55 <ivanm> AmJa: use the link that dom96 provided and join ##c
05:02:21 <ManateeLazyCat> dom96: type "M-x info", and search Emacs.
05:02:23 <Jonno_FTW> AmJa: or you could stay here and find out about haskell
05:02:41 <ManateeLazyCat> dom96: That's is best resource in this world
05:02:55 <ManateeLazyCat> dom96: Of course, EmacsWiki.org is very useful when you have some problem.
05:02:58 <AmJa> sorry jonno but i hate programming the only reason im even on a computer is because i have a project to do for my crazy prof
05:03:12 <ivanm> AmJa: if you hate programming, why are you doing a programming course?
05:03:13 <AmJa> ivanm i did it said ##c Cannot join channel (+b) - you are banned
05:03:15 <ivanm> engineering?
05:03:21 <kmc> haha
05:03:22 <ManateeLazyCat> dom96: You also can find some Emacs extension from my homepage : http://www.emacswiki.org/emacs/AndyStewart
05:03:26 <ivanm> AmJa: ahh, they probably don't like anonymous people
05:03:27 <dom96> ManateeLazyCat: ok, thanks :)
05:03:29 <kmc> looks like##c doesn't like web users
05:03:33 <kmc> not all channels are friendly...
05:03:42 <ivanm> AmJa: try registering your nick
05:03:44 <mauke> http://gogloom.com/FreeNode/%23c/ would have been the other link
05:03:56 <AmJa> ivanm i have to do it to complete my bachelor in science
05:04:10 <ivanm> wow, a BSc that forces learning C?
05:04:14 <ivanm> which uni is that?
05:04:16 <AmJa> yea 
05:04:20 <ivanm> and which major?
05:04:20 <AmJa> its in canada
05:04:34 <ivanm> well, that narrows it down :p
05:04:39 <Jonno_FTW> AmJa: hating programming is no attitude that will help you accomplish your task
05:04:48 <AmJa> all first year students have to take a course called "introduction to programming for scientists and engineers"
05:05:11 <AmJa> jonno, well I am getting a  %100 in that course so far
05:05:43 <AmJa> but i didn't understand a thing since we started loops
05:05:49 <ivanm> well, UQ has a new-ish 1st year math+science+philosophy+programming course that is strongly encouraged for 1st year science students, but it uses Python, not C
05:06:05 <ivanm> AmJa: maybe you should try getting alternate tutorials or texts and working through them
05:06:18 <mauke> AmJa: is there some specific problem you're having with loops?
05:06:22 <Jonno_FTW> ivanm: UQ?
05:06:34 <ivanm> University of Queensland
05:06:40 <Jonno_FTW> ahh
05:06:42 <ivanm> (Brisbane, Queensland, Australia)
05:06:53 <AmJa> yea there is but i'm not supposed to discuss it here
05:07:04 <mauke> hwat
05:07:10 <Jonno_FTW> what don't you get about looping?
05:07:35 <AmJa> no i get loops i just dont get the loop they want us to do for this assignment
05:07:37 <Jonno_FTW> ivanm: my university uses Java as it's beginning language
05:07:38 <ivanm> have we thrown the topic out by the wayside again? :p
05:07:47 <mauke> ah, ok
05:07:52 <ivanm> Jonno_FTW: even for science students? :p
05:08:02 <AmJa> this is my assignment http://www.cs.ryerson.ca/dhamelin/cps118/labs/manual.html
05:08:08 <AmJa> lab 5/6
05:08:16 <Jonno_FTW> it's the topic Computer Programming 1, it's the only first year programming topic
05:08:19 <ivanm> note: they're mainly using python not because it's easy, but because some biologists wanted it (probably because it's easy :p)
05:08:20 <mauke> http://www.cs.ryerson.ca/dhamelin/cps118/labs/lab05.html
05:08:22 <mauke> direct link
05:08:37 <AmJa> that was fast
05:08:59 <mauke> what's a Quincy?
05:09:02 <AmJa> yea
05:09:15 <AmJa> its a program that lets you compile 
05:09:17 <AmJa> c codes
05:09:29 <mauke> heh. "1. write the program.  2. fix the syntax errors."
05:09:39 <AmJa> read before the lab
05:09:43 <ivanm> mauke: isn't that everyone does? :p
05:09:58 <mauke> it's an explicit step in the instructions :-)
05:10:03 <mauke> it says nothing about type errors, though
05:10:13 <mornfall> ivanm: Well, after 2 it branches. In Haskell, it's fix type errors. In C it's fix segfaults. :P
05:10:21 <ivanm> heh, true
05:11:45 <AmJa> a person in this room helped me and we've gotten this far 
05:11:47 <mauke> AmJa: incomplete spec. can the beach numbers repeat?
05:12:00 <AmJa> http://pastebin.com/hQm31pcv
05:12:27 <AmJa> I'm stuck where fscanf is supposed to read the first number of EVERY line in the file
05:12:28 <mauke> missing 'return 0;' at end of main (unless you're using a strictly C99 compiler)
05:12:47 <mauke> line 12: ontario is potentially NULL; segfault
05:13:02 <AmJa> i can only make it read the first line
05:13:18 <mauke> you need another loop in line 18 to read the samples
05:13:28 <AmJa> ill do that later
05:13:30 <mauke> missing \n in output at line 17
05:13:52 <AmJa> but the first thing is im trying to make it read the first # in each line
05:13:54 <mauke> actually you need the other loop after line 15
05:14:02 <mauke> AmJa: you can't
05:14:15 <AmJa> why?
05:14:17 <mauke> you have to read the other data first
05:14:40 <AmJa> but the thing is each line has a different number of values
05:14:48 <mauke> your data looks like A1 B1 X1 X2 X3 A2 B2 X4 X5 A3 B3 ...
05:14:52 <AmJa> so for example first line is 331 5 5.2 5.2 .52 
05:14:56 <mauke> you want to read the A's and B's
05:15:02 <AmJa> the second line could be just 332 5 5.1
05:15:04 <mauke> but to do that you also have to read and skip the X's
05:15:18 <AmJa> ok
05:15:24 <mauke> forget about lines
05:15:24 <AmJa> and how would you do that in c
05:15:33 <mauke> think about the input file as one long stream of numbers
05:15:52 <AmJa> ok that actually makes more sense
05:16:00 <AmJa> skipping the Xes 
05:16:06 <AmJa> but how
05:16:15 <mauke> well, read them with fscanf
05:17:04 <AmJa> do i do (char rest[100]) at the top?
05:17:10 <mauke> no
05:17:24 <AmJa> then while (fscanf(ontario, "%d %d %s", &beach_num, &sample_num, rest) == 2)
05:17:35 <mauke> that wouldn't work
05:18:37 <mauke> because 1) you don't know that the rest of the line will fit in 100 chars, 2) %s doesn't read spaces, and 3) == 2 should be == 3 now
05:19:33 <mauke> oh yay, I broke my vim
05:19:38 <AmJa> thats the thing each line has a different number of Xs so for example A1 B1 X1 X2 X3 X4 A2 B2 X5 X6 A3 B3 X1..
05:19:43 <AmJa> fscanf(ontario, "%d %d %s", &beach_num, &sample_num, &organism_num)
05:19:53 <mauke> nah, leave the first fscanf alone
05:19:56 <AmJa> i mean fscanf(ontario, "%d %d %lf", &beach_num, &sample_num, &organism_num) would only read x1
05:20:05 <mauke> I told you you need another loop
05:20:49 <AmJa> what should the condition for the 2nd loop be?
05:20:59 <mauke> you need a counting loop
05:21:21 <mauke> it needs to run sample_num times and get a number each time
05:21:54 <AmJa> oooo nice
05:23:30 <Jonno_FTW> #haskell -- expert C advice
05:23:59 <mauke> well, you'd do the same in Haskell if Haskell had fscanf
05:24:11 <kmc> it's funny because everyone here knows like a dozen languages
05:24:22 <Jonno_FTW> I only know Haskell and Java
05:24:41 <kmc> Jonno_FTW, GET OUT
05:24:42 <kmc> ;)
05:24:51 <Jonno_FTW> Haskell is my first language though
05:25:08 <AmJa> Fun is my first language
05:26:09 <mauke> while (<>) { my ($beach, undef, @samples) = split; print $beach, "\n", @samples < 3 ? "insufficient data" : sum(@samples) / @samples > 50 ? "closed" : "open", "\n"; }
05:26:17 <aristid> mauke: AWESOME
05:26:58 <AmJa> is that in c language
05:27:04 <Jonno_FTW> :t (<>)
05:27:05 <nus> eclectic rubbish :-P (-;
05:27:05 <AmJa> cuz i've never seen @ before?
05:27:15 <mauke> AmJa: no, Perl
05:27:19 <AmJa> oh k 
05:27:43 <Jonno_FTW> If I read the problem properly I might have tried in haskell..
05:28:41 <mauke> main = interact (unlines . map (f . words) . lines)
05:28:49 <AmJa> but counting loops are used to reach a certain value for example while (x>= 100)
05:28:57 <nus> aren't they supposed to teach you at least AWK if they teach you C?
05:29:30 <AmJa> and here we dont have that value, but we have the value that tells you how many times the loop should run
05:29:49 <AmJa> AWK? is that another language
05:30:14 <mauke> f (beach : nsamples' : samples') = beach ++ "\n" ++ if nsamples < 3 then "insufficient data" else if sum samples / nsamples > 50 then "closed" else "open"
05:30:26 <mauke>   where nsamples = read nsamples'; samples = map read samples'
05:30:51 <nus> AmJa, it's a language which made someone come up with Perl
05:31:24 <mauke> AmJa: you can make them the same
05:31:31 <mauke> it all depends on where you start counting
05:32:52 <aristid> semantic question: how would you call the tuple of a Request and a Response? in the sense of you send a request to do something from a server, and get a response with data back
05:32:58 <AmJa> how do you get the value for sumsamples though
05:33:19 <mauke_> preflex: seen mauke
05:33:19 <preflex>  mauke was last seen on #haskell 1 minute and 47 seconds ago, saying: it all depends on where you start counting
05:38:25 <AmJa> Lets say i got the condition right how do I add X1 X2 X3 while skipping A1 B1 in the second loop
05:47:33 <ski> aristid : dunno .. maybe "Input-Output pair" ?
05:47:51 <ski> (that's probably not that good)
05:47:57 <aristid> ski: i'd like a nice and short name if possible :)
05:48:00 <nus> session?
05:48:12 <ski> session-result ?
05:48:13 <aristid> nus: hmm. session sounds like more than one pair
05:49:41 * ski tries to built some word out of "transaction", that sounds sensible
05:49:46 <ski> S/built/build/
05:51:03 <Twey> aristid: (Request, Response)
05:51:04 <Twey> ;)
05:51:14 <Twey> I don't think it really needs a new name…
05:51:34 * ski might try `ReqResp' ..
05:51:39 <aristid> Twey: well, i have some logic for Requests and some logic for Response, and i want to couple them
05:51:55 <aristid> in a new module
05:51:56 <mauke> Message
05:52:01 <Twey> So it's not a tuple — it can be a request *or* a response?
05:52:22 <aristid> Twey: no, it's first a function from request to response maybe
05:52:27 <aristid> -first
05:52:31 <Twey> toResponse
05:52:37 <Twey> Or Handler
05:52:43 * ski . o O ( `type Dialogue = [Response] -> [Request]' )
05:52:55 <nus> protocol
05:52:57 <Twey> o.@
05:53:03 <Twey> Not protocol… that's different
05:53:28 <nus> a logic coupling the logic for requests and responses?
05:54:03 <aristid> nus: yes :D
05:54:05 <Twey> A protocol a transaction format
05:54:51 <aristid> nus: right now you need to invoke a chain of 6 functions or so to make a request and analyze the response
05:54:52 <nus> the tuple is the transaction (as ski suggested alread)
05:55:09 <aristid> i want to put that together into a single function
05:55:18 <Saizan> aristid: so you're looking for the name of a module, not a type?
05:55:33 <aristid> Saizan: and also a class
05:55:37 <aristid> but yes
05:55:43 <Twey> nus: And the transaction format, the protocol, is (e.g.) HTTP — a function from one to the other would be a request handler
05:56:08 <aristid> Saizan: sorry for phrasing things so poorly, i don't really know how to say what i want
05:56:13 <Twey> (the handler responds according to the protocol, but it is not a protocol in itself)
05:57:22 <nus> Twey, that's correct if the protocol is formulated in a language different from the handler's
05:58:36 <kmc> "exchange"?
05:58:36 <Twey> Even if the protocol happens to be identical to the language used to write the handler, it's still not the handler itself
05:58:43 <Twey> Or am I misunderstanding you?
05:59:45 <aristid> i'm on the client side of things btw
06:00:11 <aristid> i'm sending a request to a server, and analyzing the response.
06:00:20 <razvandimescu> I'm reading through learnyouahaskel.com -> who did all those nice cartoonish images
06:00:30 <aristid> razvandimescu: BONUS
06:00:34 <aristid> preflex: seen BONUS
06:00:34 <preflex>  BONUS was last seen on #haskell 1 day, 22 hours, 14 minutes and 6 seconds ago, saying: ah. i'll read the thesis then
06:00:54 <aristid> "ah, i'll read the thesis then" is such a #haskell thing to say
06:00:55 <nus> aristid, that's an action, precisely, TRANSaction
06:01:07 <aristid> nus: Transaction... sounds good
06:01:41 <buddha_> hi all, just downloaded the haskell platform on osx - excited
06:01:50 <buddha_> diving in to functional programming
06:01:53 <aristid> buddha_: :)
06:02:03 <aristid> buddha_: if you don't know of it, try this:
06:02:05 <aristid> @where lyah
06:02:11 <aristid> DAMN
06:02:16 <aristid> laaaambdabot come back
06:02:29 <aristid> buddha_: http://learnyouahaskell.com/
06:03:25 <mauke> preflex: ? lyah
06:03:25 <preflex>  http://learnyouahaskell.com/
06:03:29 <mauke> preflex: ? rwh
06:03:30 <preflex>  http://book.realworldhaskell.org/read/
06:04:05 <aristid> preflex: ?run 1+1
06:04:32 <mauke> preflex doesn't run code
06:04:38 <mauke> all you get is calc
06:05:10 <buddha_> thanks guys
06:05:21 <buddha_> yeah, saw that learnyouhaskell...
06:05:32 <aristid> preflex: owner
06:05:36 <buddha_> reminded me of the poignant guide to ruby a little
06:05:41 <aristid> preflex: help
06:05:41 <preflex>  try 'help help' or see 'list' for available commands
06:05:50 <aristid> preflex: list
06:05:50 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen]; ZCode: [zdec, zenc]
06:05:52 <buddha_> seen lyah
06:06:22 <buddha_> so do any of you guys use haskell in the world or are you mainly hobbyists?
06:08:56 <nus> hobbyists are in another world?
06:10:05 <buddha_> ?MOTD
06:10:15 <buddha_> pwd
06:12:15 <nus> /
06:12:59 <nus> preflex, quote
06:13:11 <preflex>  <techjar> I use MySQL cause of PHP
06:13:36 <nus> preflex, quote
06:13:41 <preflex>  <mauke> Hungarian Notation constructs a type system in the mind of the programmer
06:14:22 <nus> preflex, quote
06:14:27 <preflex>  <leejr> Is the state monad anything like the state bird?
06:15:10 <spetrea-home> nus: hobbyists ? no right here
06:15:11 <arcatan> :O
06:16:48 <mauke> preflex: quote
06:16:53 <preflex>  <b3> we need to make it work on any system, so we need to get the win api running on Linux systems, and Macs as well if possible
06:17:01 <Jonno_FTW> > [1,1,2,3] < [1,1,2,5]
06:17:03 <hsbot>   True
06:21:02 <Azrael-> preflex, quote
06:21:08 <preflex>  <ew73> EVERYONE I FOUND THE < KEY NOW I RIT EXML FOR EVREARYTHING
06:21:50 <ski> > sortBy ((compare `on` length) `mappend` compare) (words "The quick brown fox jumps over the lazy dog")
06:21:51 <hsbot>   ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
06:22:07 <Sadache> if i have a 2d matrix represented in a list of lists, what is the best way to get neigbours of each element?
06:22:37 <ski> why not use a two-dimensional array ?
06:23:21 <Botje> @instanced Monoid
06:23:26 <Botje> @instances Monoid
06:23:31 <Botje> gah
06:23:43 <ski> lambdabot is sleeping
06:24:04 <Sadache> ski: was thinking about solving my problem functionaly
06:24:21 <ski> what is non-functional with using arrays ?
06:24:46 <nus> The dogfox the lazyoverbrown jumps quick.
06:25:42 <ski> > sortBy (compare `on` (length &&& id)) (words "The quick brown fox jumps over the lazy dog")
06:25:43 <hsbot>   ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
06:25:54 <Twey> > on compare length `mappend` compare `sortBy` words "The quick brown fox jumps over the lazy dog"
06:25:55 <hsbot>   ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
06:26:00 <Twey> Brackets are for wusses.  ;)
06:26:01 <Sadache> ski: i meant the fact that it employs search instead of traversal
06:27:01 <ski> i'm not sure what you mean
06:27:06 <nus> Sadache, what's a list?
06:27:25 <Sadache> actually i've never used arrays in Haskell, but it seems to me that it more about search by index than traversal
06:27:37 <Sadache> nus: [a]
06:28:17 <Botje> Sadache: haskell lists are singly-linked. so it's really rather a pain in the ass
06:28:28 <Twey> Lists are not a replacement for arrays
06:28:34 <Twey> At least if you care about efficiency or sanity
06:28:53 <Twey> Arrays also provide better static assurances
06:29:21 <Sadache> ok, fait enough. I thought about zipping with neighbors.
06:29:42 <Twey> If you're doing matrices, you should look at hsmatrix
06:32:54 <Sadache> ok, i'll look at that.
06:33:18 <Sadache> I was thinking how to solve  a cellular automaton using lists
06:33:32 <Sadache> but it seems not the right data structure for that
06:34:46 <ski> you might be able to use zippers instead, i suppose
06:35:08 <ski> (as long as you only need local movement)
06:35:49 <Sadache> ski: that's what i thought of. And I was trying to get my head around getting a cell neighbors using zippers
06:36:24 * ski tries to ponder how this would work
06:36:42 <ski> (.. the problem is that paths can commute)
06:37:39 <ski> hm
06:38:34 <ski>   data ListCxt a = LC [a] [a]
06:39:04 <ski>   type PosList a = (ListCxt a,a)
06:39:06 <Sadache> actually I need the neighbours of the last generation not the current
06:39:16 <ski>   fwd :: PosList a -> Maybe (PosList a)
06:39:20 <ski>   bwd :: PosList a -> Maybe (PosList a)
06:40:33 <ski>   type PosMatrix a = PosList (PosList a)
06:40:55 <ski>   left,right :: PosMatrix a -> Maybe (PosMatrix a)
06:42:07 <ski>   right (cxt,as) = liftM2 (,) (mapM fwd cxt) (fwd as)
06:42:28 <ski>   down = fwd
06:42:38 <ski> .. something along those lines might work
06:42:48 <Sadache> ski: I'll try that
06:42:50 <Sadache> thnank you
06:43:45 <ski> the `mapM' there is `(Monad m,Traversable f) => (a -> m b) -> (t a -> m (t b))'
06:44:00 <ski> .type Data.Traversable.mapM
06:44:01 <hsbot> Not in scope: `Data.Traversable.mapM'
06:44:40 <ski> anyway, the point being that to walk down, you just move one element of the outer list over, in the normal fashion
06:45:01 <ski> but to walk right, you need to move one element not only in the current row, but in all rows
06:45:23 <ski> &c. for the other operations
06:45:31 <ManateeLazyCat> How do you find Haskell job? Any company recruiter haskell programmer ?
06:46:10 <enthropy> ManateeLazyCat: you make haskell company
06:46:20 <alpounet> http://haskellers.com
06:46:21 <alpounet> heh
06:47:41 <ManateeLazyCat> enthropy: Found a haskell job is very hard.
06:48:57 <arcatan> "i haven't found a haskell job, so i'm going to found a haskell company"
06:50:07 <ManateeLazyCat> arcatan: Any haskell company?
06:50:27 <nus> "which helps others to find a haskell job"
06:55:33 <Lemmih> ManateeLazyCat: Galois and well-typed come to mind.
06:55:55 <ManateeLazyCat> Lemmih: What kind work for Galois?
06:56:14 <Lemmih> ManateeLazyCat: The difficult kind.
06:56:34 <ManateeLazyCat> Lemmih: Example? 
06:56:40 <ManateeLazyCat> Lemmih: Now i just can work in China.
06:57:42 <Lemmih> ManateeLazyCat: Dig a tunnel to HK, fly to the US, profit.
06:58:29 <spetrea-home> ManateeLazyCat: in China with Haskell ?
06:58:36 <ManateeLazyCat> spetrea-home: Yes.
06:58:38 <joe1> is there a way to do "data Bool = False | True" at the ghci prompt?
06:58:45 <spetrea-home> ManateeLazyCat: what do you do in China with Haskell ?
06:58:51 <mauke> joe1: no
06:58:51 <joe1> define ADT's in ghci?
06:58:52 <ManateeLazyCat> spetrea-home: I love Haskell.
06:59:00 <spetrea-home> ManateeLazyCat: what job do you do in China with Haskell?
06:59:14 <joe1> mauke: so, the solution is to write them in a .hs file and :r or :l then?
06:59:21 <ManateeLazyCat> spetrea-home: My haskell OS : http://goo.gl/MkVw
06:59:23 <spetrea-home> Lemmih: what do you mean "the difficult kind" ?
06:59:38 <Jafet> spetrea: * -> * -> *
07:00:07 <mauke> joe1: yes
07:00:21 <joe1> ManateeLazyCat: that looks cool.
07:00:28 <joe1> mauke: thanks
07:00:36 <spetrea-home> ManateeLazyCat: so you built an entire OS with all those application in Haskell by yourself ?
07:01:01 <ManateeLazyCat> spetrea-home: Now, i just use Linux kernel, otherwise is rewrite by Haskell complete.
07:01:07 <tomh> anyone here knows what is meant with "function spaces"
07:01:28 <arcatan> tomh: in what context?
07:01:42 <tomh> definition of regular datatypes
07:01:45 <spetrea-home> ManateeLazyCat: so you want to write kernel also in Haskell
07:01:57 <ManateeLazyCat> spetrea-home: That's the future plain.
07:02:09 <ManateeLazyCat> spetrea-home: I want build Haskell application first.
07:02:22 <spetrea-home> ManateeLazyCat: I think your current haskell code should get you into Galois ...
07:02:34 <spetrea-home> ManateeLazyCat: are you manatee or lazycat ?
07:02:40 <ManateeLazyCat> spetrea-home: ??
07:02:47 <ManateeLazyCat> spetrea-home: lazycat
07:03:12 <ManateeLazyCat> spetrea-home: I hope i can find some Haskell job 
07:03:32 <sbrg> ManateeLazyCat: So you run the linux kernel underneath but otherwise the window managers and everything else in user space is haskell, written by you?
07:03:43 <ManateeLazyCat> sbrg: Yes.
07:04:31 <ManateeLazyCat> Code at https://patch-tag.com/r/AndyStewart/ beginning with manatee-*
07:04:38 <ski> tomh : probably the same as "function types", then
07:04:43 <ski> joe1 : did you get your code to look cleaner ?
07:04:51 <joe1> ManateeLazyCat: how fast is it? is it zooming fast as it does not have to worry with the interactions.
07:05:07 <ManateeLazyCat> joe1: Every fast.
07:05:10 <joe1> ski: just started working on it, now. I will keep you posted in the next few hours.
07:05:19 <tomh> ski: so a regular datatype cannot have function types?
07:05:27 <joe1> ski: just could not think straight anymore yesterday night.
07:05:31 <ManateeLazyCat> joe1: Frame at http://www.flickr.com/photos/48809572@N02/5031811365/
07:05:52 <tomh> I guess they mean they cannot have arguments with kind *->* or something?
07:05:59 <ManateeLazyCat> joe1: It's multi-processes framework, so it won't block you if you do many work in it, just like Chrome's one but design for OS.
07:06:04 <joe1> ManateeLazyCat: way to go, man... let me know when others can start playing around with it.
07:06:06 <ski> joe1 : i saw you asked around a bit more after i went for sleep, and got some suggestions for refactoring from others
07:06:40 <ski> joe1 : if you still want suggestions for refactoring, i could take a look at what you have
07:06:59 <joe1> ski: yes, ksf recommended using ADT's and I thought that it was a brilliant idea.
07:07:15 <joe1> ski: i will post the code in a minute.
07:07:47 <ManateeLazyCat> joe1: I think it's much faster than gnome 
07:08:12 <ski> tomh : i don't recall the definition of "regular datatype" atm .. what i'm thinking of is (potentially) recursive types which "passes the same type parameters in recursive calls"
07:08:23 <Cleopatra> using the following Library : http://hackage.haskell.org/packages/archive/WAVE/0.1.1/doc/html/Data-WAVE.html    can someone give a example of an input of type WAVE would look like
07:08:26 <tomh> ok
07:08:56 <joe1> ski: http://hpaste.org/paste/40777/io_lists_again#p40794
07:09:07 <joe1> i think you might have to scroll all the way down.
07:09:34 <joe1> ManateeLazyCat: can others try it?
07:09:40 <Lemmih> Cleopatra: WAVE header [] ?
07:09:55 <ManateeLazyCat> joe1: Yes, install gtk2hs darcs, then download all manatee-* code from https://patch-tag.com/r/AndyStewart/
07:09:57 <ski> tomh : hm, actually .. judging from the presense of "regular" in "regular datatype", you can probably not have function types in them
07:10:10 <ManateeLazyCat> joe1: cd ./manatee && ./repos.sh install will install it in your system
07:10:30 <joe1> ManateeLazyCat: what apps does it have? terminal?
07:10:34 <ski> tomh : or maybe `c -> t' is allowed in it, as long as `c' is a constant type, not including your recursive type, nor type parameters
07:10:41 <tomh> yeah something like data A f b = A (f b) is not regular I think
07:11:10 <ManateeLazyCat> joe1: webkit-browser, editor, file-manager, image-viewer, irc-client, multimedia-player, pdf-viewer, process-manager, Rss/Atom reader.
07:11:17 <ski> (or maybe that would be "polynomial types" ?)
07:11:19 <Cleopatra> it should combinhe the waveheader and wavesamples
07:11:22 <joe1> ManateeLazyCat: vim?
07:11:30 <ManateeLazyCat> joe1: My own editor.
07:11:48 <joe1> ManateeLazyCat: ok, cool..
07:11:54 <Lemmih> Cleopatra: Could you explain what the problem is?
07:12:02 <ski> tomh : in any case, having parameters with kind not being `*' is different from having function types inside it
07:12:24 <tomh> ok
07:13:18 <ski> joe1 : right, i wondered about
07:13:20 <ski>   msg2code :: (Int,String) -> [IO()]
07:13:22 <ski> why not
07:13:25 <ski>   msg2code :: (Int,String) -> IO ()
07:13:28 <ski> instead ?
07:13:48 <ski> do you really need to give a list of `IO'-actions here, instead of a single (composite) action ?
07:14:04 <ManateeLazyCat> joe1: I'm working on release next version gtk2hs and first version manatee, after then, you can install it by "cabal install manatee"
07:14:24 <ski>   msg2code (lineno,line)
07:14:27 <ski>      | is_setup_token line = do
07:14:39 <ski>          printf . report lineno $ line
07:14:47 <ski>          appendFile "usb_test_script.scl" . report lineno $ line
07:14:50 <ski>          ...
07:14:51 <joe1> ski: yes, I could add a sequence in the beginnig of the write_to_file, as you recommended yesterda.
07:14:57 <ski> joe1 : like that ^
07:15:06 <Cleopatra> Lemmih im trying to use the function putWAVEFile but i dont knoe how to format the second input
07:15:56 <Lemmih> Cleopatra: type WAVESamples = [[WAVESample]]. And: doubleToSample :: Double -> WAVESample
07:16:00 <joe1> ski: i am thinking of taking it to the next level by using ADT's. I think it will make the code easier to read or smaller.
07:16:07 <ski> joe1 : if you do the above, then you can remove one call to `sequence_', since the result from `msg2code' will already be a single action of type `IO ()', instead of a list of type `[IO ()]'
07:16:20 <ski> joe1 : yeah, you can do that as well
07:16:28 <ski> what i was suggesting is orthogonal to that
07:16:51 <joe1> ski: yes. i tried that yesterday. That is what I had initially, before I thought of putting all sequence_ in one place. just felt that sequence_ belonged in main.
07:16:54 <Lemmih> Cleopatra: A WAVE is simply a WAVEHeader plus WAVESamples.
07:17:35 <joe1> ski: sorry, what do you mean by "orthogonal"?
07:18:07 <ski> joe1 : "independent"
07:19:34 <roconnor> joe1: good morning
07:20:14 <joe1> ski: my thinking has gone from "lots of do functions" -> one main function with do which processes a list of IO actions -> using types (ADT) -> (what is the next phase?)
07:20:21 <joe1> roconnor: good morning.
07:20:34 <roconnor> joe1: I'm more awake now :)  How's the code?
07:21:09 <ManateeLazyCat> joe1: Jens (juhp) have playing it too. 
07:21:14 <joe1> roconnor: just got up myself. I have not started working on the code yet. Hopefully, i will have something by this evening.
07:21:56 <Cleopatra> Lemmih, so it be something like this WAVEHeader{
07:21:56 <Cleopatra> waveNumChannels :: Int
07:21:56 <Cleopatra> waveFrameRate :: Int
07:21:56 <Cleopatra> waveBitsPerSample :: Int
07:21:56 <Cleopatra> waveFrames
07:21:57 <Cleopatra> }
07:21:57 <Cleopatra> WAVESample{
07:21:58 <Cleopatra> [[1],[2],[3]]
07:21:58 <Cleopatra> }
07:22:18 <mauke> don't paste into the channel
07:22:25 <Cleopatra> sry
07:22:35 <ski> joe1 : i dunno. i'd need to have a look at the code you get after using algebraic types to answer that
07:22:36 <joe1> evolution of programmer thinking in haskell: does anyone have more details on it.?
07:23:01 <joe1> ski: will keep you posted when I have something.
07:23:06 <Lemmih> Cleopatra: putWAVEFile "file.wav" (WAVE (WAVEHeader 0 0 0 Nothing) [])
07:24:09 <ManateeLazyCat> spetrea-home: Thanks for help, i will try to contact Galois
07:24:28 <joe1> should probably add "lots of head banging and hand holding from #haskell" as the first step..
07:24:49 <Cleopatra> Lemmih: thanks :)
07:27:10 <roconnor> god damn perl and nuclear weapons.
07:27:38 <mauke> wasn't that in the other channel?
07:27:45 <joe1> roconnor: yeah, saw that too. hats off to their testing process, though.
07:33:52 <roconnor> this exponent error is scarier
07:34:01 <roconnor> could happen in Haskell just as easily
07:34:16 <Lemmih> What happened?
07:34:34 <roconnor> Lemmih: coder thought (**) was left associative
07:36:08 <Lemmih> And nulcear weapons were involved?
07:36:22 <Lemmih> *nuclear
07:36:33 <roconnor> Lemmih: it was alegidly burned into the EEPROMS
07:36:41 <roconnor> and stuck into silos
07:37:15 <mauke> uh, everyone knows that article was a joke, right?
07:37:50 <roconnor> nope
07:37:56 <roconnor> just finished now
07:38:01 <roconnor> whew
07:38:08 <mauke> you don't have to finish it
07:38:15 <mauke> that line about Ada gave it away
07:38:37 <roconnor> I'm a sucker
07:39:17 <aristid> die, monomorphism restriction, die!
07:40:49 <ski> joe1 : in `getbytes', why not `[x,y]' instead of `drop 2 hexWord' ?
07:42:32 <ski> or possibly
07:42:33 <ski>   getbytes line = [xy | Just xy@[_,_] <- map (stripPrefix "0x") words line, all isHexDigit xy]
07:42:47 <ski> er
07:42:51 <ski>   getbytes line = [xy | Just xy@[_,_] <- map (stripPrefix "0x") (words line), all isHexDigit xy]
07:45:01 <ski> in `flags', are you sure you don't want `flags line = show line ++ ";"' ? (i.e. what if `line' already contains quotes, or other characters that need quoting ?)
07:45:13 <aristid> is there a good package for extensible record types? i only know of HList, but that scares me
07:46:06 <Saizan> there are a few more recent ones like "records"
07:46:51 <aristid> Saizan: thanks
07:47:21 <Saizan> more recent /= good, but at least it's been packaged by the authors
07:48:09 <ManateeLazyCat>  [22:44:59]
07:48:09 <ManateeLazyCat> 																											  [22:45:12]x
07:48:19 * ManateeLazyCat Damn erc bug.
07:49:49 <aristid> Saizan: well, given that HList is scary, it is at least POSSIBLE that records is less scary
07:56:47 <enthropy> will ghc-7 throw out base-3?
07:57:13 <Saizan> yep
07:58:17 <aristid> that will be fun
07:58:34 <enthropy> that'll break roughly half of hackage...
07:58:45 <alpounet> at the very least yeah
07:59:05 <enthropy> the changes aren't too difficult, but contacting 'maintainers'
07:59:07 <kmc> change must come through the barrel of a gun
08:00:14 <joe1> ski: ok, thanks.
08:02:49 <Twey> Perhaps we should form a base-4 strike-force to go through Hackage fixing stuff.
08:04:31 <enthropy> "we update all your base"
08:06:40 <Twey> Heheh.
08:10:41 <savgur> Hi, I have bug with xmonad+xscreensaver+gdm
08:12:23 <alpounet> savgur, ask on #xmonad
08:14:19 * hackagebot fountain 0.0.1 - A fountain codec.  http://hackage.haskell.org/package/fountain-0.0.1 (TomHawkins)
08:20:21 * hackagebot crypto-api 0.1.2.3 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.1.2.3 (ThomasDuBuisson)
08:20:41 <rinzai> hi everyone
08:21:57 <rinzai> can anyone point me to a good comparison/review of the current web framework options in Haskell? Thanks! 
08:25:57 <blueonyx> rinzai: http://www.haskell.org/haskellwiki/Web
08:26:38 <rinzai> blueonyx, cool, thanks! ;)
08:28:58 <aristid> Saizan: records looks quite interesting
08:29:35 <Saizan> aristid: seen the paper?
08:29:50 <aristid> no, where is it?
08:30:00 <aristid> the haddock is pretty good too
08:32:10 <Saizan> i think it's "Generic record combinators with static type checking"
08:32:40 <Saizan> though maybe the haddock is better, i've never really looked much at either
08:32:41 <aristid> Saizan: google found something
08:33:02 <aristid> GAAAH GATED
08:33:25 <monochrom> at least better than walled
08:33:37 <aristid> monochrom: it's gated and walled :P
08:33:45 <monochrom> whee!
08:34:51 <aristid> damn my university proxy server doesn't work. ok, whatever. i just don't read it.
08:35:08 <enthropy> aristid: there's a version you don't need to pay
08:35:08 <Saizan> google finds direct pdf links for me
08:35:31 <Saizan> http://scholar.google.com/scholar?cluster=10611101350093819205&hl=en&as_sdt=2000
08:35:42 <aristid> i only clicked on the first result in google
08:36:19 <monochrom> the 3rd link is always the best link XD
08:39:57 <aristid> hmm
08:40:43 <gareth_0> hi, is there a function to turn the read method into a parsec parser?
08:43:15 <Lemmih> gareth_0: You can write one.
08:46:09 <mm_freak> at least for 'reads'
08:46:23 <mm_freak> i don't think you can turn the general 'read' into a parser
08:46:26 <enthropy> it's a bit tricky to make parsec know how much input has been consumed http://hpaste.org/40795/readstoparsec
08:46:44 <enthropy> you can catch the exceptions
08:47:12 <Lemmih> mm_freak: Same thing.
08:47:38 <mm_freak> Lemmih: well, you can consume the input character by character, until 'reads' returns the empty string
08:48:02 <mm_freak> i would just write the parser myself instead of using 'read'/'reads'
08:48:42 <gareth_0> i see, thanks guys
08:49:38 <mm_freak> gareth_0: 'read' is actually not very useful for any complicated parsing
08:50:08 <mm_freak> but instead of writing a parser using 'read' you can write a 'read' using a parser
08:50:37 <gareth_0> in my case i just want to map a string to a member of a data = ... enumeration
08:56:59 <tarwatirno> set private false
09:40:21 <siracusa> @tell ManateeLazyCat For your information, the latest gtk2hs repo version builds and works fine on Win XP with Gtk+ 2.18.
09:40:38 <danharaj> Win XP is the new IE6
09:41:28 <siracusa> Hm, no lambdabot?
09:41:55 <haskellnewbie> Hi I am new to Haskell, I was trying to write a fibonacci series program, fibi n = let m = fibi (n-1) in [(m !! 0 + m !! 1) : m]
09:42:10 <haskellnewbie> The above gives me infinite type error when I compile
09:42:49 <haskellnewbie> I have defined fibi 0 and fibi 1 as 0 and [1,0] respectively 
09:42:50 <spetrea-home> haskellnewbie: are you from india ?
09:42:52 <sipa1024> no [ ] around it
09:42:59 <Nibble> haskellnewbie: fibs = zipWith (+) fibs (tail fibs)
09:43:02 <Nibble> or something like that
09:43:07 <Nibble> oh wait
09:43:08 <sipa1024> a:b is a list with first element a, and tail b
09:43:12 <Nibble> I forgot the 1:2
09:43:13 <haskellnewbie> spetrea-home: Yes 
09:43:14 <pumpkin> Nibble: except you need base cases
09:43:18 <sipa1024> [a:b] is a list with one element
09:43:18 <Nibble> pumpkin: yeah
09:44:35 <haskellnewbie> sipa1024: Yes but what is wrong in what I wrote is something I can't figure out 
09:44:40 <Lemmih> haskellnewbie: Perhaps you should start with something simple like: fib n = fib (n-1) + fib (n-2)
09:44:42 <haskellnewbie> Why is it an infinite type error 
09:44:49 <haskellnewbie> Lemmih: I did that
09:44:50 <sipa1024> haskellnewbie: 18:42:27 < sipa1024> no [ ] around it
09:45:09 <haskellnewbie> Lemmih: It worked and I used List Comprehension to build a list using that 
09:45:24 <haskellnewbie> Lemmih: But I wanted to do in this way as well 
09:46:03 <Lemmih> haskellnewbie: So you want to write a more efficient version using lists?
09:46:13 <haskellnewbie> sipa1024: Ah, thanks 
09:46:17 <haskellnewbie> Lemmih: Yes
09:46:46 <spetrea-home> do Haskell programmers in general like Perl ?
09:47:07 <sbrg> spetrea-home: What kind of question is that?
09:47:12 <sbrg> I mean, really
09:47:14 <Lemmih> spetrea-home: I don't think so.
09:47:15 <Nibble> spetrea-home: absolutely everyone
09:47:20 <Nibble> one hundred percent
09:47:23 <Nibble> loves it
09:47:25 <pumpkin> spetrea-home: absolutely nobody
09:47:26 <Zao> Many competent programmers tolerate other languages :D
09:47:28 <sbrg> To ask a question like that is to imply that everyone that writes haskell has to think alike
09:47:39 <Nibble> in fact, 50.15661320% made love to the code
09:47:41 <sbrg> But I would hope that no one in their right mind likes perl
09:47:43 <Zao> sbrg: Well, Haskell rots the brain.
09:47:46 <Nibble> one time or another in their life
09:47:54 <sbrg> Zao: :|
09:48:02 <sbrg> You just insulted my inner fan boy
09:48:40 <sina> Hi everyone
09:48:44 <Nibble> PROTIP: haskellers like haskell
09:48:47 <Nibble> end of story
09:48:49 <Nibble> period.
09:48:55 <Zao> sbrg: And then rebuilds it, better, stronger, more Haskellicious.
09:49:06 <sbrg> Zao: Good save.
09:49:28 <sbrg> Since I've started using Haskell I've realized that Haskell's way of doing it is the only one that makes sense
09:49:34 <sina> Guys, I have a question. when inside a function, I ask it to call itself, I get an error. why?
09:49:35 <sbrg> IO, etc
09:49:36 <Zao> spetrea-home: Any decent programmer knows that languages excel in different domains.
09:49:46 <Nibble> the thing I hate about most other languages
09:49:51 <sbrg> sina: Way too be specific
09:49:51 <Nibble> after learning haskell
09:49:52 <Zao> If I need to do some shell scripting or text mangling, I turn to Perl.
09:49:55 <ManateeLazyCat> siracusa: Sorry, too busy on job, haven't see your message.
09:49:57 <Zao> Codegen in Perl is quite nice.
09:49:58 <danharaj> Any decent programmer knows that some programming paradidgms are garbage.
09:50:02 <ManateeLazyCat> siracusa: Sounds good.
09:50:02 <Nibble> is not knowing what functions will modify arguments to it directly.
09:50:10 <Nibble> what arguments functions will*
09:50:11 <spetrea-home> Zao: what does Haskell excell in ?
09:50:11 <Lemmih> haskellnewbie: Try generating an infinite list of fibonacci numbers.
09:50:16 <danharaj> viz. duck typing and object orientation :p
09:50:20 <spetrea-home> Zao: what's codegen ?
09:50:25 <Zao> spetrea-home: Generating code.
09:50:37 <sina> sbrg: I have a function that is going to get a character from a string.
09:50:46 <xelxebar> studying category theory, does there happen to be a carryover benefit for Haskell coding?
09:50:46 * duckinator looks at danharaj, goes back to lurking
09:50:48 <sbrg> Zao: Making sure your program doesn't accidentally launch nuclear missilies
09:50:49 <ManateeLazyCat> siracusa: We will waiting some day, if no bug report, then release gtk2hs-0.12.0
09:50:50 <sbrg> missiles*
09:50:55 <Zao> spetrea-home: I'd rather have a quick-and-dirty automated code generator than to write thousands of lines of boilerplate.
09:50:57 <sbrg> sina: Still very unspecific
09:51:05 <sbrg> how about the error? how about some code?
09:51:10 <sina> sbrg: so, I pass an integer(location) and a string to it. it returns a character
09:51:11 <osaunders> sina: What error do you get?
09:51:21 <Zao> spetrea-home: As for what Haskell does well, heh... wasting time, having a large chance of having a correct program once it typechecks.
09:51:21 <sina> Ambiguous variable occurrence
09:51:45 <Zao> spetrea-home: Power through abstractions, the usual FP benefits, sanely distinct pure/impure code.
09:51:46 <osaunders> sina: Put the code up on hpaste.
09:52:06 <sina> it wants me to call the name of the haskell module before it. (it will work fine then)
09:52:20 <haskellnewbie> spetrea-home: Why the question about India ?
09:52:24 <haskellnewbie> Lemmih: Will do 
09:53:06 <osaunders> I'm trying to find some advice on how I should divide code into modules. Does anyone know of any guidelines or articles I could read?
09:53:07 <sbrg> sina: Seriously. If you want help, post the error and the code or a test case
09:53:18 <sina> sure, I'm doing it. one moment...
09:53:58 <Nibble> sina: PROTIP: never use several dots
09:54:03 <Nibble> makes you look ignorant
09:54:06 <Nibble> arrogant
09:54:16 <sipa1024> ============== 
09:54:17 <sina> http://hpaste.org/40796/getchar (I want it to wrap around if the number is bigger than the length)
09:54:24 <sbrg> Nibble: Doesn't to me
09:54:30 <sipa1024> ]
09:54:30 <sipa1024> ]
09:54:40 <sipa1024> apologies, i changed some keys
09:54:43 <osaunders> Nibble: To you, maybe.
09:54:44 <tcatipax> Nibble: PROTIP: use PROTIP more
09:54:46 <sipa1024> in my keyboard
09:54:54 <Nibble> sbrg: use mod
09:55:10 <sbrg> Nibble: What do you mean? 
09:55:14 <sbrg> Compose key?
09:55:35 <Nibble> sbrg: if you want a number to wrap around
09:55:35 <sina> It has problem with the getChar inside the if statement
09:55:37 <Nibble> you can use mod
09:55:46 <sbrg> Nibble: ... why are you telling me this?
09:55:56 <Nibble> sbrg: isn't that want you wanted to know
09:56:02 <Nibble> oh right, was not
09:56:06 <sbrg> Nibble: PROTIP: Scroll up and read.
09:56:15 <osaunders> lol
09:56:19 <Nibble> sbrg: PROTIP: don't get irritated at people trying to help you.
09:56:34 <sbrg> Nibble: PROTIP: Don't help problems with their non-existent problems
09:56:36 <sbrg> kthx
09:56:37 <sina> and this is the error: Ambiguous variable occurrence "getChar"
09:56:59 <sbrg> sina: You probably want: then getChar (num - length) text else text !! num
09:57:13 <sbrg> Ah.
09:57:23 <osaunders> sina: That goes has no errors for me.
09:57:29 <haskellnewbie> Lemmih: myfib =[(fib i) | i <- [1,2..]] 
09:57:30 <osaunders> s/goes/code/
09:57:35 <sbrg> If that is the only error then you have two modules imported that export the same module
09:57:35 <haskellnewbie> Lemmih: But very inefficient
09:57:38 <sbrg> eh, function
09:57:42 <sina> if I put moduleName.getChar it will work fine
09:57:47 * haskellnewbie goes to write a better version
09:58:06 <haskellnewbie> Oops myfib =[(fib i) | i <- [0,1,..]]
09:58:31 <Nibble> haskellnewbie: ??
09:58:34 <Nibble> why are you doing that
09:58:35 <osaunders> sina: If you're importing System.IO maybe add hiding (getChar)
09:58:43 * FunctorSalad_ suspects spetrea-home meant "generally" in the sense of "majority-wise", not in the sense of "always" ;)
09:58:44 <sbrg> Aye, that would work.
09:58:54 <osaunders> sina: LIke this: import System.IO hiding (getChar)
09:58:55 <Nibble> haskellnewbie: what is the definition of finb
09:58:58 <Nibble> fib
09:59:03 <enthropy> sbrg: you're allowed to import the same functions many times. Data.List exports things also exported by the prelude
09:59:10 <Lemmih> haskellnewbie: Recursion is the key. Try defining your infinite list of fibonacci numbers recursively.
09:59:19 <sina> osaunders: why is this happening? I have no problem in other functions I made
09:59:39 <osaunders> sina: Because in System.IO there's a function called getChar and you created one with the same name.
09:59:40 <enthropy> but maybe it's understood you mean different functions with the same name
09:59:53 <sina> oh really? thats the problem then :)
09:59:53 <sbrg> enthropy: Yeah, true
10:00:23 <sbrg> sina: 
10:00:30 <sbrg> Oh, your function is called getChar
10:00:47 <sina> thanks a lot osaunders. is there any way to make a better function to do the same? or mine is good enough?
10:00:47 <sbrg> You could either rename it or use "hiding" as osaunders described above
10:01:57 <sbrg> sina: What is it supposed to do exactly?
10:02:10 <osaunders> sina: Well basically the functionality you want it more or less already provided by (!!) alone. But if you want to have it so that it gives you the last char if the index exceeds the length of the list you could write something that did that more explicitly.
10:02:40 <sina> if I say getChar 10 "abcd" it should give me 'b'
10:02:45 <sbrg> If you want the last char in a string, "last" will simply do that for you. 
10:03:10 <sbrg> getChar n t = if n > length t then last t else t !! n
10:03:24 <sbrg> sina: oh..
10:03:28 <sbrg> why?
10:03:38 <haskellnewbie> Nibble: fib n = fib (n-1) + fib (n-2)
10:03:39 <FunctorSalad_> if you want random access into strings, you may really want ByteString or Text rather than String ;)
10:03:39 <sbrg> it should 'wrap around'?
10:03:47 <FunctorSalad_> (performance-wise)
10:03:50 <haskellnewbie> Lemmih: Yes looking for a better version
10:04:00 <osaunders> sina: http://hpaste.org/40797/maybe_better
10:04:01 <Eduard_Munteanu> Hi.
10:04:09 <Lemmih> haskellnewbie: Do you want help or do you want to work it out on your own?
10:04:21 <sina> Well, I am studying haskell in university. this is part of my assignment
10:04:34 <Nibble> > let a = 1:2 : (zipWith (+) fibs (tail fibs))
10:04:36 <hsbot>   not an expression: `let a = 1:2 : (zipWith (+) fibs (tail fibs))'
10:04:39 <Nibble> uh hu
10:04:40 <sbrg> > let foo n t = t !! (mod n (length t)) in foo 10 "abcd"
10:04:41 <hsbot>   'c'
10:04:43 <Nibble> long time since I did any haskell
10:04:45 <FunctorSalad_> (though random access into utf8-encoded bytestrings might take linear time too)
10:04:52 <FunctorSalad_> (random access by *char*)
10:05:11 <spetrea-home> hi Eduard_Munteanu 
10:05:12 <sbrg> hmm.
10:05:16 <FunctorSalad_> actually replace "might" by "I'm pretty sure it does" ;)
10:05:22 <sbrg> sina: What is the exact specification of the assignment?
10:05:25 <spetrea-home> Eduard_Munteanu: you know Mihai Mariuseac ?
10:05:38 <sbrg> "if I give it 10 "abcd" it gives me 'b'" isn't really specific
10:06:00 <sina> can I tell you in private, cause it will be lost in these many lines of chat
10:06:03 <Eduard_Munteanu> spetrea-home: hi. I think so. I only talked to him in here I suppose.
10:06:21 <sbrg> Just paste the specification somewhere
10:06:21 <Eduard_Munteanu> spetrea-home: even though we study at the same faculty.
10:06:24 <spetrea-home> Eduard_Munteanu: oh ok, I think he's at politechnique university
10:06:27 <osaunders> The new hpaste confuses me.
10:06:37 <Eduard_Munteanu> spetrea-home: yes, that's true.
10:06:46 <spetrea-home> Eduard_Munteanu: do you have a github account ?
10:06:50 <haskellnewbie> Lemmih: I am working it on my own. This is fun :). I think I need to figure out a tail recursion version of the inefficient solution
10:07:14 <Eduard_Munteanu> spetrea-home: I don't think so, I've used repo.or.cz for my stuff.
10:07:35 <Eduard_Munteanu> (liked the web interface better)
10:07:50 <Lemmih> haskellnewbie: You don't need tail recursion. Laziness is the key.
10:08:40 <tomh> mm why does happy require perl to install?
10:08:51 <Nibble> tomh: to be happy
10:08:55 <Nibble> you need to know what sad is.
10:08:58 <Nibble> :/
10:09:00 <tomh> :<
10:09:45 <haskellnewbie> Lemmih: But if I am generating the list, I would not want to compute fib 2 both for fib 2 and for 3,4... I would want to use the result 
10:10:16 <sipa1024> > fix ((1:) . scanl 0 (+))
10:10:17 <hsbot>   No instance for (GHC.Num.Num ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a)) arising from the literal `0' at <interactive>:3:18 Possible fix: add an instance declaration for (GHC.Num.Num ((a -> ...
10:10:22 <Lemmih> haskellnewbie: Right, you can use the contents of the list you're generating /while/ you're generating it.
10:10:31 <haskellnewbie> So I can kick List Comprehension bye bye 
10:11:20 <Lemmih> haskellnewbie: So, the nth element in the list is made by looking at the n-1'th and n-2'th element of the same list.
10:11:37 <Lemmih> haskellnewbie: Yeah, list comprehension isn't much of a help here.
10:11:47 <tomh> mm is windows deprecated as an OS for new cabal packages or ?
10:12:09 <kmc> what?
10:12:20 <tomh> can't build alex, can't build happy
10:12:27 <kmc> windows is still a supported OS for GHC Haskell and there are no plans to change that afaik
10:12:31 <haskellnewbie> Lemmih: Ah
10:12:33 <kmc> remember, the main GHC guys work for Microsoft ;)
10:12:42 <tomh> yeah
10:12:58 <kmc> so if alex / happy are unusable, it's a bug
10:13:10 <tomh> ah they already came with haskell platform precompiled
10:14:52 <Eduard_Munteanu> Could somebody recommend a method to draw a 2D grid? It has to be able to draw multiple frames in a succession, I'm interested for a cellular automaton.
10:14:53 <jmcarthur> where is lambdabot :(
10:15:20 <haskellnewbie> Lemmih: fibi n = let m = fibi (n-1) in (m !! 0 + m !! 1) : m
10:15:30 <haskellnewbie> Lemmih: My earlier function does this 
10:15:43 <haskellnewbie> I just need a way to call it infinitely
10:15:55 <haskellnewbie> without the param n 
10:15:59 <sipa1024> > fix ((0:) . scanl (+) 1)
10:16:01 <hsbot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39...
10:16:10 <Eduard_Munteanu> I'm currently using GTK and a grid of toggle buttons, but that doesn't scale to non-Bool and it's a bit slow.
10:16:37 <haskellnewbie> sipa1024: Hmm, I have not yet read about the scanl and fix functions. I need to take a look 
10:16:43 <haskellnewbie> sipa1024: Thanks 
10:16:48 <Lemmih> haskellnewbie: Drop the argument to fibi. Try something like this: fibs = 1 : 1 : more_code_here
10:16:48 <Eduard_Munteanu> And I'm a bit unsure this falls under "plotting".
10:16:51 <FunctorSalad_> heh, "Num ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a)" *think*
10:17:23 <FunctorSalad_> (+) op1 op2 x y = (op1 x y) + (op2 x y)
10:17:26 <FunctorSalad_> :)
10:17:28 <sipa1024> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib
10:17:29 <hsbot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,3908...
10:17:37 <sipa1024> haskellnewbie: that's maybe easier to read
10:18:19 <haskellnewbie> sipa1024: Yes it is 
10:19:07 <haskellnewbie> Lemmih: Now I see what you mean with respect to sipa1024 code 
10:19:58 <FunctorSalad_> oh nevermind, that definition is not higher-order enough :(
10:20:18 <Eduard_Munteanu> Uh, I suppose I'm going to go the GTK+OpenGL way or try some plotting lib; not sure whether the former is overkill or if the latter can be used to animate it.
10:20:45 <FunctorSalad_> (+) hop1 hop2 op1 op2 x y = (hop1 op1 op2 x y) + (hop2 op1 op2 x y) ?
10:20:55 <sipa1024> FunctorSalad_: no
10:21:16 <sipa1024> (+) hop1 hop2 op1 op2 x y = (hop1 + hop2) op1 op2 x y
10:23:13 * hackagebot hlint 1.8.2 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.2 (NeilMitchell)
10:23:24 <FunctorSalad_> sipa1024: that seems to be an infinite loop
10:23:38 <jmcarthur> sipa1024: that is actually the same thing if you think about it
10:24:16 <sipa1024> jmcarthur: about what are you talking?
10:24:16 <jmcarthur> sipa1024: it implies a Num instance for functions, and that instance has the semantics of lifting (+) to Reader
10:24:37 <jmcarthur> sipa1024: so you and FunctorSalad_ are both right
10:24:42 <sipa1024> that instance can be anything...
10:24:50 <jmcarthur> not many things
10:24:53 <sipa1024> or are you talking about a particular library?
10:24:58 <monochrom> there are 3 Num instances for functions
10:24:59 <FunctorSalad_> jmcarthur: eh? the Num instance is being defined
10:25:17 <jmcarthur> FunctorSalad_: oh. then yours works and sipa1024's doesn't
10:25:19 <FunctorSalad_> sipa1024's RHS is just the LHS
10:25:34 <jmcarthur> monochrom: what are they?
10:25:49 <sipa1024> FunctorSalad_: i'm sorry i didn't see you were talking about a Num instance
10:25:51 <jmcarthur> there's only one very sensible one that i'm aware of
10:26:41 <jmcarthur> instance Num b => Num (a -> b) where ...
10:27:12 <FunctorSalad_> hmm I guess mine is implied by several applications of that one
10:27:16 <jmcarthur> yes
10:27:40 <FunctorSalad_> (anyway, it isn't important, I just went from a bot error a page up)
10:27:51 <jmcarthur> in general, any Applicative can make a Num instance if you ignore the Show and Eq requirement
10:30:20 <monochrom> one instance says x y = x*y. another says 3 (1/2) = 3+(1/2). and the 3rd says f+3 = \x -> f x + 3
10:31:09 <monochrom> and I am not kidding or being original about x y = x*y. I talked to someone else who really advocated it.
10:32:19 <jmcarthur> so those first two are instance Num a => (a -> a) where ...?
10:32:39 <FunctorSalad_> how can you effect x y = x*y with a Num instance?
10:32:47 <FunctorSalad_> space isn't a method ;)
10:32:49 <jmcarthur> i would rule those out just by virtue of being less general, maybe have a newtype around it instead
10:32:51 <monochrom> I said to mathematicians "look at 3 x and log x, they are unrelated and still use the same notation, this makes notation ambiguous". one of them then really replied "sure it's unambiguous, just treat 3 as \x -> 3*x "
10:33:23 <FunctorSalad_> well yes, for literals you could do it
10:34:06 <monochrom> well if I wrote "x y and log y", it would be the same reply.
10:34:40 <aristid> hmm, the records package seems to be quite nice
10:34:56 <FunctorSalad_> but you couldn't define "z" to mean "\x -> z*x" in haskell ;)
10:35:16 * hackagebot authenticate 0.7.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.7.1 (MichaelSnoyman)
10:35:18 <aristid> > convert (X :& A := 4 :& B := 5) :: (X :& (A ::: Int)) (Id KindStar)
10:35:18 <aristid> X :& A := 4
10:35:19 <hsbot>   Illegal operator `:&' in type `X :& (A ::: Int)' Use -XTypeOperators to allow operators in typesNot in scope: type constructor or class `X'Illegal operator `:::' in type `A ::: Int' Use -XTypeOpe...
10:35:20 <FunctorSalad_> (for 'z' an arbitrary value)
10:35:33 <monochrom> anyway, just add OverlappingInstances, IncoherentInstances, UndecidableInstances, and SmartInstanceGuessing.
10:35:52 <jmcarthur> or do the sensible instance instead
10:36:04 <aristid> monochrom: SmartInstanceGuessing? :D
10:36:44 <monochrom> yeah, SmartInstanceGuessing selects the "sensible" instance
10:37:12 <aristid> it really exists?
10:37:17 <monochrom> no
10:37:26 <aristid> ok, so you were actually joking
10:37:31 <aristid> monochrom: you never know with GHC
10:37:40 <jmcarthur> it's glorious!
10:37:52 <aristid> jmcarthur: hence the name, Glorious Haskell Compiler
10:37:59 <roconnor> monochrom: does it make functors?
10:38:00 <jmcarthur> that was the reference
10:38:13 <jmcarthur> roconnor: FunctorDeriving?
10:38:24 <jmcarthur> or is it DeriveFunctor
10:38:24 <roconnor> monochrom: does it automatically make the continuation monad?
10:38:26 <monochrom> I don't know yet
10:38:33 <jmcarthur> i think it's DeriveFunctor
10:38:53 <roconnor> bassically does it run djinn to build instances?
10:38:54 <roconnor> :D
10:39:10 <jmcarthur> roconnor: you're aware of DeriveFunctor, right? ;)
10:39:18 <roconnor> nope
10:39:21 <jmcarthur> it's real
10:39:23 <jmcarthur> it works
10:39:25 <roconnor> I believe it
10:40:19 <aristid> jmcarthur: that's glorious too
10:47:07 <osaunders> I'm trying to find some advice on how I should divide code into modules. Does anyone know of any guidelines or articles I could read?
10:50:05 <enthropy> osaunders: unless you use template haskell, you don't really need to use modules
10:50:53 <enthropy> @hackage SourceGraph
10:50:57 <enthropy> :(
11:01:20 <dschoepe> Is there a regex library that supports named groups like python? E.g. (?P<foo>bar) where foo would be the name for the match bar.
11:02:04 <abstrakt> dschoepe, I know haskell has a regex lib, I don't know if it supports that specifically
11:02:27 <dschoepe> abstrakt: I looked at a few of the regex libs on hackage and they don't seem to support that.
11:02:39 <enthropy> they all use the same interfaces
11:02:45 <abstrakt> dschoepe, k, well then you're probably out of luck
11:03:29 <abstrakt> dschoepe, sudo apt-get install libghc6-regex-base-dev libghc6-regex-posix-dev
11:03:56 <abstrakt> dschoepe, those are the two that I know of
11:04:03 <enthropy> groups are by position, and I'm not sure if the posix one does those?
11:04:07 <abstrakt> dschoepe, that's not a POSIX standard thing I don't suppose?
11:04:20 <enthropy> the pcre one does for sure
11:04:32 <dschoepe> abstrakt: Yes, I know about those. I was just asking about that specific feature.
11:04:33 <abstrakt> enthropy, is there a PCRE haskell lib?
11:05:02 <dschoepe> abstrakt: http://hackage.haskell.org/package/regex-pcre-0.94.1
11:05:18 <abstrakt> dschoepe, well... enthropy says that pcre has it...
11:05:43 <abstrakt> so, I dunno I guess it's just TIAS and then roll your own if haskell-pcre doesn't have what you want
11:09:40 <jimmyjazz14> is there a good package for dealing with a lot of String to ByteString (and back) conversions?
11:10:39 <enthropy> jimmyjazz14: depends on your encoding in the bytestring
11:10:50 <alpounet> can't you write something like withString :: String -> (ByteString -> a) -> a 
11:11:37 <ddarius> You should, for the most part, avoid converting between the two very often.
11:12:59 <kw317> It will butcher your performance
11:20:49 <jimmyjazz14> true but many important pacakages still use 'String's
11:21:40 <jimmyjazz14> on that same note, is there a way to specify a default fallover type when using "OverloadedStrings"?
11:24:09 <Polarina> What are the differences between attoparsec and parsec3?
11:28:03 <ksf> http://www.vimeo.com/15833948 \o/
11:37:06 <astroboy> I have a problem while linking with ghc: http://hpaste.org/40799/linking_error .
11:37:12 <astroboy> both files work well with ghci
11:38:31 <Lemmih> astroboy: Compile with --make.
11:38:33 <sipa1024> ghc --make 
11:38:43 <astroboy> Lemmih: thanks I'll try
11:39:10 <astroboy> Lemmih: it works, thanks a lot
11:39:20 <astroboy> what was that error about?
11:39:32 <Lemmih> astroboy: It was about not using --make. (:
11:40:14 <astroboy> Lemmih: uh ok :P. as long as it works... it's strange because I've compiled other projects with the usual way
11:42:32 <mauke> astroboy: you could also use ghc -package containers
11:42:49 <mauke> --make tells ghc to resolve required libraries automatically
11:50:14 <azudem> (Sorry fo my english.) I write http://paste.org.ru/?fsamfo , but ghci write about error: http://paste.org.ru/?ce9n5a . Why?
11:51:36 <enthropy> azudem: use  `div`
11:52:55 <azudem> enthropy: thanks :)
11:55:19 <calsaverini> hi
11:55:26 <enthropy> jimmyjazz14: probably using the default keyword
11:55:34 <calsaverini> is there a library of functions to deal with graph theory?
11:56:01 <calsaverini> I just need to create graphs, modify it's edges and calculate centrality and mean shortest paths 
12:34:29 <osaunders> Have people seen this talk? http://www.infoq.com/presentations/The-Joy-of-Testing It's pretty great.
12:35:17 <pumpkin> I need me an iso haskell
12:35:29 <arcatan> I need me a small haskell
12:36:01 <Nibble> I need me a low level haskell
12:36:08 <Nibble> I need me a bad haskell
12:36:18 <Nibble> I need me a Barry-roll-haskell
12:36:28 <Nibble> guys
12:36:32 <Silvah> And I do not.
12:36:34 <Nibble> search for "kill it with fire" on youtube
12:36:39 <Nibble> look at the first result
12:36:40 <Nibble> hilarious.
12:37:41 <aristid> i need me a haskell with better support for product and sum types
12:37:43 <aristid> grml
12:38:06 <Silvah> No lambdabot?
12:38:10 <lispy> What is this meme?
12:38:13 <aristid> no lambdabot
12:38:28 <aristid> lispy: people complain that lambdabot is not here because he is not here. funny meme, eh?
12:38:29 <ymasory> beginner question: if i make functions without a type specification, doesn't the resulting function have a "structural type", since it will work for any types that define the methods i use?
12:38:30 <Silvah> Why?
12:38:40 <Silvah> He?
12:38:43 <lispy> aristid: no, the "I need me a X" meme
12:38:49 <Silvah> Lambdabot is he?
12:38:52 <Twey> That's not a meme
12:38:58 <Twey> In the usual sense
12:38:59 <aristid> lispy: no idea. but better product and sum types would be nice.
12:39:15 <lispy> aristid: Really, I thought they are pretty nice already
12:39:34 <merijn> ymasory: If I understand you correctly, then yes
12:39:36 <lispy> Anyway, I'm not sure why lambdabot is missing.  The server is up, where is Cale?
12:39:46 <ymasory> thanks
12:39:46 <lispy> preflex: seen cale
12:39:46 <preflex>  cale was last seen on #haskell 2 days, 23 hours, 13 minutes and 27 seconds ago, saying: Applying the function 4 to the value 5
12:39:57 <aristid> preflex: seen lambdabot
12:39:58 <lispy> Hmm...that's a big absence for Cale
12:39:58 <preflex>  lambdabot was last seen on #haskell 18 hours, 19 minutes and 1 second ago, saying: * lambdabot is retiring, good night all
12:40:06 <lispy> hmm
12:40:09 <merijn> ymasory: For example if you mean whether "add x y = x + y" will automatically infer that add works for all numbers
12:40:11 <Silvah> lol
12:40:15 <lispy> This is weird
12:40:17 <Silvah> How come?
12:40:49 <lispy> BTW, the accepted pronoun for lambdabot is female
12:40:53 <ymasory> merijn: i meant something a little stronger, that "add" will work for any two types that have "+" defined
12:41:10 <mauke> ymasory: same thing
12:41:17 <Twey> lispy: Very odd… I hope he's okay.
12:41:17 <ymasory> great
12:41:24 <Silvah> lispy: that's why I've been wondering.
12:41:42 <merijn> ymasory: The type signature for "add x y = x + y" boils down to the type signature for (+) which is: "(Num a) => a -> a -> a"
12:42:10 <Silvah> #haskell won't be the same without lambdabot... :(
12:42:22 <merijn> ymasory: Which means "this is a function taking two arguments part of the typeclass Num and returns one value of the same type"
12:42:38 <aristid> Silvah: huh? you think this is permanent?
12:42:57 <merijn> ymasory: Have you read about typeclasses yet?
12:43:02 <ymasory> merijn: no
12:43:22 <Silvah> aristid: no, but you know...
12:43:24 <merijn> ymasory: A typeclass defines a certain datatype provides certain functions
12:43:45 <merijn> ymasory: The typeclass Eq for example defines that a datatype supports == and /=
12:43:56 <Silvah> It became pretty common...
12:44:01 <aristid> lispy: one of my complaints about sum+product types in haskell is that every sum type requires a top-level declaration (or using a generic type like Either)
12:44:30 <lispy> You want anonymous algebraic types?
12:44:40 <Silvah> s/common/frequent/
12:44:47 <aristid> lispy: and fields common to more than one record can be annoying to. i looked at using the package records, but that doesn't support sum types so it's not really complete
12:45:00 <aristid> lispy: yes maybe that's what i want
12:45:10 <merijn> ymasory: So a function "(Eq a) => a -> a -> Bool" says "This function accepts any type a, as long as a is part of the Eq typeclass. Since Eq states that == and /= are defined our function can now use those functions on its arguments
12:45:55 <merijn> ymasory: http://learnyouahaskell.com/types-and-typeclasses has a more in depth explanation
12:46:04 <Silvah> preflex: seen Silvah
12:46:05 <preflex>  Silvah was last seen on #haskell 1 minute and 24 seconds ago, saying: s/common/frequent/
12:46:08 <Silvah> err...
12:46:13 <Silvah> nvm
12:46:57 <Silvah> Is it possible to check when I was here last time, not including today?
12:47:04 <ymasory> merijn: thanks, reading as we speak
12:47:14 <c_wraith> Silvah, look at the public logs?
12:48:55 <lispy> aristid: I guess you could get anonymous algebraic types via church encodings
12:49:01 <lispy> aristid: But not really what you want :)
12:51:12 <Silvah> Public logs?
12:52:00 <aristid> lispy: the problem is, i could try to write some extensions for records, but that is beyond my skills
12:52:01 <Silvah> I didn't know such thing existed.
12:53:19 <ddarius> lispy: I believe I've actually done that before in lambdabot.
12:54:18 <aristid> lispy: if you run the server, couldn't you restart lambdabot or so?
12:55:31 <guest2424> :ski are you here today?
13:04:30 <Enigmatic> i'm trying to get the protocol buffers stuff on hackage building with ghc 7.x and now i'm stuck
13:04:54 <Enigmatic> there is a function with no type signature called 'iFail' which is not being generalized anymore..
13:05:00 <Enigmatic> so i thought this would fix it: iFail :: forall m r. MonadReader r m => String -> m r
13:05:34 <Enigmatic> but that didn't work: Text/ProtocolBuffers/ProtoCompile/Resolve.hs:1046:20:    Couldn't match type `Bool' with `Env'    arising from a use of `iFail'
13:05:36 <Lemmih> Fitting name.
13:06:44 <Enigmatic> any ideas what i'm doing wrong, i hadn't had to use forall on higher kinds before
13:07:14 <Honeyman> Hello. I might be getting crazy... but can someone explain to a newbie the behaviour of "flip" function here? http://pastebin.com/LDXdWrgv
13:09:02 <Lemmih> Honeyman: It has nothing to do with flip. Try: ':t 10' and 'let a = 10 \n :t a'.
13:09:25 <alpounet> the type defaults to integer
13:10:02 <Honeyman> Hmm, so to be correct, I have to define the proper most-general types manually, right?
13:12:02 <Lemmih> Honeyman: Or use -XNoMonomorphismRestriction.
13:12:21 <Honeyman> ... and I've hit something like http://hackage.haskell.org/trac/haskell-prime/wiki/Defaulting
13:12:46 <Honeyman> Lemmih: oh. The fourth typing extension for the first week of Haskell learning. Thanks :)
13:15:33 <cydergoth> Afternoon all. Can anyone help me interpret this error message? http://hpaste.org/40800/cabal_error
13:16:51 <Martty> it means you are going to die
13:16:53 <Martty> godspeed
13:17:15 <cydergoth> @Martty that makes more sense than the error message ;-~
13:18:00 <Martty> looks like you have a Dependency Hell
13:18:17 <cydergoth> Delete my cabal directory and restart from scratch?
13:18:27 <int80_h> hello!
13:19:18 <Enigmatic> ok... so I've dumped the full file with my 1 line change (line 929) up on https://gist.github.com/10038dd3a3fb6c313507 with the full ghc error at the bottom
13:20:45 <Lemmih> Enigmatic: Why do you need to give it a signature at all?
13:22:03 <Lemmih> Enigmatic: And it looks like the type should be: String -> RE r.
13:22:06 <Enigmatic> this is with ghc 7.0's new type inference...
13:22:14 <Enigmatic> https://gist.github.com/10038dd3a3fb6c313507#gistcomment-12609 has the original error i'm trying to fix
13:23:02 <Enigmatic> Lemmih: alrighty that seemed to fix it :)
13:25:51 <guest2424> hello
13:30:31 <guest2424> anybody knows how to sort a list 
13:30:32 <guest2424> ?
13:30:38 <guest2424> like bubble sort
13:30:39 <guest2424> ?
13:30:44 <Lemmih> > sort [4,2,6,1,4,7,2]
13:30:45 <hsbot>   [1,2,2,4,4,6,7]
13:33:21 <int80_h> that's sum fancy sortin'
13:34:00 <gareth_0> > let x = []
13:34:01 <hsbot>   not an expression: `let x = []'
13:34:12 <gareth_0> > let x = [] in sort x
13:34:13 <hsbot>   []
13:34:19 <gareth_0> ...
13:34:37 <Lemmih> Not what you expected?
13:34:45 <gareth_0> hehe
13:35:27 <l8star> @all does anybody knows how to tell leksah to use 'makefile' in order to build something or how to change the configuration ?
13:36:50 <Lemmih> l8star: Try under "Edit Package".
13:37:09 <guest2424> Lemmih: is different
13:37:33 <Lemmih> I sure am.
13:37:57 <guest2424> I am suppose to inpur this list  [3, 1, 6, 4, 2] and get this result  [1,3,2,6,4] using foldr
13:38:10 <pumpkin> @src sort
13:38:10 <guest2424> *input
13:38:46 <Lemmih> guest2424: That's not sorted.
13:38:57 <pumpkin> foldr insert []
13:39:05 <guest2424> Lemmih: How you can call that
13:39:21 <pumpkin> guest2424: what is the pattern?
13:39:27 <cydergoth> Anyone know if it is actually *possible* to use apt-get install haskell-package under Ubuntu 10.10 and get a working system? Should I compile from scratch?
13:39:37 <Lemmih> guest2424: Years of studying math has taught me that 3 > 2.
13:39:45 <guest2424> I know
13:39:46 <sbrg> cydergoth: It has worked fine for me, yes
13:39:47 <guest2424> huh
13:39:54 <sbrg> but compiling from scratch isn't the only alternative
13:40:00 <sbrg> well, cabal does that
13:40:02 <gareth_0> >sort [1..]
13:40:03 <sbrg> but it's not the same
13:40:04 <cydergoth> @sbrg thanks, I wonder why it isn't working for me
13:40:05 <sbrg> just use cabal
13:40:19 <guest2424> (ord :: a -> [a]-> [a]
13:40:24 <guest2424> )
13:40:29 <sbrg> I don't remember the reason, but someone said that using cabal over apt-get install libghc6.... was preferable
13:40:47 <pumpkin> guest2424: you still haven't told us what the transformation even means
13:40:51 <cydergoth> sbrg - ok, I'll look into that 
13:41:00 <pumpkin> what property does [1,3,2,6,4] have?
13:41:02 <hpc> sbrg: cabal has more recent versions
13:41:19 <sbrg> hpc: ah yes, that is obviously one good point
13:41:19 <guest2424> pumpkin : Use foldr to implement a function  that performs one bubble sort pass (from rear to front) through a list. 
13:41:31 <pumpkin> guest2424: oh okay
13:41:43 <hpc> i personally use apt-get, then tarballs if that fails
13:41:59 <hpc> cabal doesn't seem to work for me; that or i just suck at it
13:42:19 <sbrg> I'm fairly certain submitting packages(and new versions) to the ubuntu repos isn't something you just do 'like that'
13:42:47 <guest2424> Lemmih: You are funny after all the math I know that 2 +2 = 6
13:42:49 <guest2424> hahahah
13:42:52 <cydergoth> @sbrg I'm sure the ones which are in the repos are supposed to work, but I get a ton of errors trying to do the apt-get install haskell-package
13:43:06 <cydergoth> @sbrg and now I can't uninstall them either!
13:43:09 <sbrg> cydergoth: I'm not sure 'are supposed to work' can be defined that easily
13:43:25 <sbrg> not for libraries, anyway
13:43:39 <sbrg> cydergoth: What pakcage did you install that broke everything?
13:43:40 <pumpkin> guest2424: so show us some work before we help you :P
13:43:41 <hpc> cydergoth: if they install with errors, they aren't installed;
13:43:47 <cydergoth> @sbrg Ubuntu is supposed to do _some_ QC I hope. 
13:43:59 <sbrg> cydergoth: I'm not referring to that
13:44:05 <nus> anybody intending to use Haskell on Ubuntu should first pester people @ https://wiki.ubuntu.com/MOTU/Teams/UncommonProgrammingLanguages/Haskell
13:44:12 <guest2424> I am that good in haskell
13:44:15 <sbrg> It doesn't matter
13:44:22 <sbrg> cydergoth: What package broke everything?
13:44:25 <pumpkin> guest2424: isn't the point of these exercises to make you  better at it?
13:44:33 <FDFlock> Hi all!
13:44:33 <guest2424> pumpkin:  I am that good in haskell
13:44:37 <guest2424> yeah
13:44:38 <FDFlock> Just a very quick "Yes or No" question from a Haskell newbie (actually, not even a newbie yet): It *is* possible to call compiled Haskell code from within a Python script, right? (eg. using ctype) I only need a cofirmation for now, not the details.
13:44:53 <nus> ... and read this https://lists.ubuntu.com/archives/ubuntu-devel-discuss/2009-July/009078.html
13:45:11 <hpc> FDFlock: it's theoretically possible, but it would be tricky, and well beyond newbie level
13:45:16 <cydergoth> @sbrg - I removed all my ghc packages and tried to reinstall them with haskell-package
13:45:25 <guest2424> pumpkin: ok I know I need to have a element and a list
13:45:39 <sbrg> nus: that's over a year old
13:45:47 <sbrg> a new LTS version has been released since then
13:45:49 <sbrg> and 10.10 on top of that
13:45:50 <guest2424> pumpkin: But i dont know how to compare a list to an element
13:45:59 <sbrg> cydergoth: What is 'haskell-package'? 
13:46:03 <pumpkin> it doesn't make sense to compare a whole list to an element
13:46:05 <pumpkin> what do you mean by that?
13:46:07 <sbrg> And did you install the haskell platform or the compiler?
13:46:12 <nus> sbrg, I believe, the situation hasn't changed much.
13:46:16 <cydergoth> @sbrg sorry, haskell-platform
13:46:27 <FDFlock> hpc: I see, thank you
13:46:42 <cydergoth> @sbrg it is a meta-package - supposed to be GHC + a set of 'standard(ish)' libraries
13:46:45 <sbrg> cydergoth: try sudo apt-get remove --purge libghc6-*
13:47:09 <nus> sbrg, "There is no way that we are going to deviate on so many source packages, at least not without an Ubuntu Haskell Team that cares for such a task."
13:47:10 <hpc> cydergoth: also try autoremove instead of remove, if you don't want lingering depends
13:47:28 <cydergoth> I've been doing autoremove after remove to clean up the rest
13:47:33 <guest2424> pumpkin: I only have this so far http://pastebin.com/kcc0ihrd
13:47:45 <sbrg> nus: where is that quote from, and what is it regarding?
13:48:06 <nus> sbrg, from the post above
13:48:07 <cydergoth> I understand ruby has a similar issue with the conflict between apt and their own GEMS manager
13:48:22 <cydergoth> @sbrg - thanks, that seems to have removed them all
13:48:36 <fffej> hi - i've written a little yesod app, upgraded the version, but now when I run the code I get "GHCi runtime linker: fatal error: I found a duplicate definition for symbol my_inet_ntoa"   - any advice on how to fix it?
13:48:41 <pumpkin> guest2424: a machine could have written that :P surely you have some idea of what to do. Have you programmed in other languages before?
13:48:43 <sbrg> nus: Yes, but regarding what? For one, https://launchpad.net/ubuntu/+source/haskell-platform/2010.1.0.0.1, this is new. This did not exist in 2009 in the repos, afaik
13:48:51 <guest2424> yeah
13:48:58 <sbrg> cydergoth: Good stuff. Does installing haskell-platform work now?
13:49:01 <guest2424> pumpkin: A machine
13:49:02 <guest2424> ??
13:49:06 <sbrg> I use 10.10 myself; everything worked like a charm. 
13:49:15 <sbrg> Well, except wxwidgets.
13:49:16 <pumpkin> guest2424: you don't have any "meat" in that code
13:49:18 <new-lisper> fffej: have you tried addressing the errors it found?
13:49:47 <cydergoth> @sbrg did you install ghc package or haskell-platform?
13:49:48 <guest2424> pumpkin: Can I have an if else then statament
13:49:50 <Lemmih> fffej: Try -fforce-recomp.
13:49:58 <sbrg> cydergoth: Haskell-platform.
13:50:01 <fffej> new-lisper: awesome plan :)  I've tried, I've looked at ghc-pkg list but don't know what modules the symbol is duplicated in
13:50:03 <nus> sbrg, "Original maintainer: Debian Haskell Group"
13:50:20 <cydergoth> @sbrg I wonder if the issue is incorrect deps to header files and other system packages?
13:50:31 <fffej> Lemmih: recompiling doesn't help unfortunately
13:50:31 <hpc> guest2424: guards are generally preferred over if-then-else
13:50:34 <sbrg> Following which you use cabal to install your new packages
13:50:46 <guest2424> oh ok
13:50:57 <sbrg> nus: Your point was still invalid; stuff has changed regarding haskell in the ubuntu repos since 2009.
13:51:42 <new-lisper> fffej: have you tried tracking my_inet_ntoa from ghci?
13:51:44 <cydergoth> @sbrg http://hpaste.org/40802/ghc_aptget_error
13:51:52 <guest2424> pumpkin: I know how to program in java C++ but Haskell is something else
13:52:02 <sbrg> cydergoth: .. why are you isntall ghc?
13:52:22 <sbrg> installing*
13:52:27 <cydergoth> @sbrg 'cos haskell-package failed, I wanted to see if ghc would install as it is a smaller set of deps
13:52:37 <fffej> new-lisper: Not quite sure how to do that - the error tells me it is in HSnetwork-2-2.1.7 but it's duplicated, so presumably I need to find the other reference
13:52:46 <cydergoth> @sbrg looks like I might have some stuff hanging about in my home dir tho'
13:53:12 <new-lisper> fffej: didn't you use it somewhere in your own code?
13:53:34 <fffej> new-lisper:  Not knowingly - I presume it's in something http like that's imported
13:53:56 <sbrg> cydergoth: do the following: sudo apt-get autoremove --purge ghc6 && sudo apt-get autoremove --purge libghc6-* && sudo apt-get install haskell-platform
13:54:05 <guest2424> pumpkin: even an if else statment thorws an error in haskell check this?  http://pastebin.com/6aXiDZkU  What I have wrong is a simple if else 
13:54:13 <new-lisper> fffej: paste your code in some pastebin for we to see
13:55:10 <enthropy> guest2424: what's supposed to happen when you compare a list and an element of that list?
13:55:43 <cydergoth> @sbrg: http://hpaste.org/40803/aptget_error
13:55:45 <enthropy> is  'z' more than ['a','b','c']?
13:55:54 <guest2424> enthropy: yes
13:56:09 <fffej> new-lisper - http://pastebin.com/wdT2fxnJ is a trace from loading with -verbose on ghci - code is a bit chunky to paste in
13:56:18 <enthropy> there are too many ways to do the comparison
13:56:29 <sbrg> cydergoth: wow.
13:56:35 <sbrg> how did you initially try to install haskell?
13:56:38 <enthropy> guest2424: but the list is longer
13:56:43 <guest2424> yes
13:56:45 <sbrg> oh, wait
13:56:46 <hpc> guest2424: what's the type of 'z', and what's the type of ['a','b','c']?
13:56:50 <sbrg> that actually wound up installing
13:56:54 <cydergoth> @sbrg I had it installed ok, then I upgraded from 10.4 to 10.10 and it all exploded
13:57:02 <hpc> guest2424: then, what's the type of (>)?
13:57:04 <guest2424> hpc: z i an element 
13:57:05 <sbrg> cydergoth: can you run ghc now?
13:57:08 <sbrg> it didn't fail, the install
13:57:15 <sbrg> just pointed out that a few packages were broken
13:57:25 <guest2424>  ['a','b','c']? is a list
13:57:33 <hpc> a list of what?
13:57:43 <guest2424> of letters
13:57:48 <cydergoth> @sbrg well, that counts as a fail for me as I need some of the broken packages, and I can't cabal install any upgrades
13:57:52 <guest2424> of strings
13:57:52 <hpc> the type of letters is Char
13:57:55 <guest2424> chars
13:57:57 <Twey> ['a', 'b', 'c'] = "abc" :: [Char] = String
13:58:03 <sbrg> cydergoth: yes, but let's take it one step a time
13:58:11 <hpc> so 'z' is a Char too
13:58:16 <guest2424> yes
13:58:26 <hpc> the type of (>) is Ord a => a -> a -> a
13:58:28 <sbrg> cydergoth: does running ghc work?
13:58:32 <cydergoth> @sbrg ghc seems to work
13:58:37 <guest2424> ok
13:58:38 <hpc> which essentially means, take two things that can be compared
13:58:40 <sbrg> alright, we can work with that
13:58:41 <hpc> and compare them
13:58:43 <hpc> er
13:58:48 <hpc> Ord a => a -> a -> Bool
13:58:56 <hpc> where Bool = True or False
13:59:00 <guest2424> ok
13:59:10 <cydergoth> @sbrg I'm not bothered if the installation is system wide or private
13:59:15 <hpc> so, the two arguments have to be of type a
13:59:24 <hpc> but both a's have to be the same
13:59:26 <guest2424> a -> a
13:59:34 <hpc> so 'z' isn't the same type as "abc"
13:59:38 <hpc> so they can't compare
13:59:39 <guest2424> type
13:59:48 <guest2424> but my x xs are the same
13:59:52 <sbrg> cydergoth: sudo apt-get autoremove --purge libghc6svgcairo or whatever it's called, and do that for all of the packages
13:59:55 <sbrg> (if it works, that is)
14:00:28 <guest2424> since is the head and the tail 
14:00:41 <guest2424> hpc: since is the head and the tail  of a list
14:00:44 <hpc> the head of a list is only one element
14:00:52 <guest2424> ok
14:00:55 <hpc> the tail is the rest of the list
14:01:08 <guest2424> oh all the rest
14:01:17 <hpc> so when you pull a list out into x and xs
14:01:22 <hpc> x :: a
14:01:24 <hpc> xs :: [a]
14:01:34 <guest2424> oh i got
14:01:37 <hpc> you can compare them if you put x back into a list
14:01:43 <hpc> and i gotta go
14:01:49 <hpc> someone else can continue the explanation
14:01:56 <guest2424> ok 
14:02:01 <enthropy> an infinite type is the solution to  a = [a]
14:02:21 <enthropy> where the a to satisfy is infinitely nested [ ]
14:02:29 <cydergoth> @sbrg it says it isn't installed
14:04:27 <new-lisper> fffej: well, I am not sure, but I think 1. Maybe the update loads two versions of HSnetwork and they conflict 2. Maybe the update defined this variable in HSnetwork, while one of your other libraries already use it. But I dunno, I am not much of a Haskell programmer, so I suggest you (also) ask someone else for help, as I cannot help much.
14:04:39 <cydergoth> @sbrg: Hmm, installing libghc6-mtl-dev seems to have helped, let me try some more
14:04:55 <enthropy> guest2424: there aren't really implicit conversions in haskell
14:04:58 <new-lisper> fffej: try tracking that variable before running main
14:05:07 <guest2424> what you mean
14:05:16 <guest2424> enthropy: what you mean
14:05:20 <ezyang> I just had the “pleasure” of writing some C++ code. I don't understand it: why are programmers write tomes and tomes about how to reason about manual memory allocation ownership but not about how to reason about lazy memory use. 
14:05:24 * ezyang is baffled. 
14:05:49 <guest2424> enthropy: How do you take an element out of a lits an compare and then put back
14:05:50 <fffej> new-lisper: thanks - I'll give that a go
14:06:09 <new-lisper> fffej: you're welcome.
14:06:10 <enthropy> guest2424: well what is the comparison supposed to be on?
14:06:19 <guest2424> enthropy: I can do that in my head but not in writing is picking
14:06:30 <Eduard_Munteanu> I gave up on the "pleasures" of C++. Either you enjoy doing every bit of plumbing as in C, or you go with something more extreme as Haskell.
14:06:35 <enthropy> the first element of the tail of the list, all elements of the tail
14:06:43 <Eduard_Munteanu> *like
14:06:49 <`Zerax`> Is there some kind of magic to getting the lambdabot evaluator to work on IRC? When I try to use it, it just reports that the expression was 'Terminated'. 
14:07:15 <new-lisper> guest2424: you probably won't need to get it off the list
14:07:17 <Eduard_Munteanu> Plus I found C++ to be incredibly verbose on a few occasions.
14:07:21 <guest2424> enthropy: so you compare a tail with a tail
14:07:42 <guest2424> I dont get that part 
14:07:46 <new-lisper> guest2424: then you compare tail xs to tail ys
14:07:56 <guest2424> ok
14:07:58 <enthropy> lets suppose the (>) :: a -> [a] -> Bool
14:08:08 <enthropy> what's the implementation of that function?
14:08:09 <guest2424> But I only have one tail is only one list
14:08:32 <cydergoth> @sbrg still doomed. Looks like the SVG system library includes have moved 
14:08:34 <guest2424> or you guys mean that I need to create a blank new list and put there the new elements
14:08:41 <Eduard_Munteanu> guest2424: what are the semantics of your (>)?
14:08:50 <guest2424> greater
14:09:01 <sbrg> cydergoth: you probably want to take this to the ubuntuforums or some such. This is, after all, a package manager issue.
14:09:07 <Eduard_Munteanu> guest2424: well, then can you compare an element with a list?
14:09:14 <cydergoth> @sbrg yes, it looks like it 
14:09:19 <sbrg> But for future reference, I know very, very few people that have had positive results upgrading their ubuntu systems
14:09:20 <enthropy> guest2424: which elements in the list matter?
14:09:21 <guest2424> No
14:09:32 <enthropy> just the first... what happens if it's empty?
14:09:37 <guest2424> enthropy: the head and the tail
14:09:41 <sbrg> I'm pretty sure someone on the forums will be able to take you through the motions of manually removing the packages and unregistering them et al
14:09:45 <cydergoth> @sbrg it has mostly worked for me, I've upgraded this from 8.x through the various versions
14:09:46 <ezyang> Eduard_Munteanu: I mean, that's not even what I'm complaining about. 
14:09:46 <guest2424> returns 0
14:10:15 <cydergoth> @sbrg but it looks to me like the packages are out of sync on some file locations and dependencies
14:10:17 <Eduard_Munteanu> ezyang: I still find plumbing refcounting and such stuff enjoyable, dunno.
14:10:18 <ezyang> I'm complaining that people complain that Haskell's memory model is hard to understand, and then happily deal with all sorts of complexity in their "traditional manual" models 
14:10:31 <Eduard_Munteanu> Oh.
14:10:41 <sbrg> cydergoth: yeah
14:11:00 <ezyang> Maybe it's because they know how to solve the latter but not the former. 
14:11:00 <Eduard_Munteanu> ezyang: I thought Haskell's memory model was supposed to be opaque.
14:11:19 <ezyang> Eduard_Munteanu: Not if you're running out of stack space :-) 
14:11:35 <enthropy> guest2424: perhaps you should start with what f is supposed to do
14:11:37 <cydergoth> Thanks all, I'll play around some more with the deps, see if I can get a consistent configuration
14:11:40 <nus> haskell has a memory model?
14:11:59 <guest2424> ok
14:12:06 <Eduard_Munteanu> ezyang: well, there are a few assumptions you can make, and use fold in the right way (strict vs nonstrict) for example.
14:12:17 <Eduard_Munteanu> At least unless you're doing stuff House does to the RTS.
14:12:46 <new-lisper> some times I feel Haskell is like 4D platformers
14:13:01 <Eduard_Munteanu> Woo, I like 4D mazes :P
14:13:06 <new-lisper> f******* hard to learn, but fun when you get it
14:13:10 <new-lisper> :)
14:13:18 <new-lisper> ok, not that hard
14:13:35 <Eduard_Munteanu> guest2424: do you want to compare the first element with the last element?
14:13:36 <guest2424> new-lisper: You mean Haskell
14:13:38 <guest2424> ?
14:13:43 <nus> > f*******
14:13:44 <hsbot>   <no location info>: parse error (possibly incorrect indentation)
14:14:09 <guest2424> Eduard_Munteanu: No the element to the right
14:14:37 <cydergoth> @sbrg - solved it. Seems there was some metadata left over in /var/lib/ghc6....
14:14:41 <Eduard_Munteanu> guest2424: so it will work only for lists with at least two elements?
14:14:53 <cydergoth> Deleting that dir seems to have allowed me to do a clean install of ghc at least
14:14:53 <jmcarthur> the difficulty is not learning haskell. it's unlearning everything else you "know" already
14:14:58 <guest2424> oh no
14:15:26 <Eduard_Munteanu> (of course, you can guard for other cases, but it's not going to compare)
14:15:29 <cydergoth> @jmcarthur, guest2424 but it is worth it to do that unlearning 
14:15:37 <sbrg> cydergoth: you should really, really not be installing ghc
14:15:40 <sbrg> you already installed ghc
14:15:43 <jmcarthur> unlearning is always worth it
14:15:45 <sbrg> you should install haskell-platform
14:15:47 <jmcarthur> even for things that are not haskell
14:15:56 <sbrg> because it's a package(or meta-package) that's made to work
14:15:57 <cydergoth> @sbrg Yes, I'm just testing the ghc install
14:16:05 <cydergoth> 'cos it is smaller
14:16:13 <cydergoth> It does seem to have installed ok tho'
14:16:28 <cydergoth> as well as cabal install
14:16:33 <new-lisper> guest2424: yes
14:16:47 <jmcarthur> @cydergoth is bringing twitter to irc :P
14:16:53 <guest2424> Eduard_Munteanu: like this input : [3, 1, 6, 4, 2]  Output = [1,3,2,6,4]
14:17:25 <guest2424> new-lisper: I totally agreee I dont think i will ever say that is fun do between you and me
14:17:27 <guest2424> hahaha
14:18:00 <int80_h> would anyone like to discuss the relationship between CurlCookieFile and CurlCookieJar, in the network.curl library?
14:18:14 <Eduard_Munteanu> guest2424: I'm not really sure I follow. What's the pattern there?
14:18:35 <guest2424> No idea they said is like a bubble sort
14:18:59 <guest2424> Eduard_Munteanu : Use foldr to implement a function that performs one bubble sort pass (from rear to front) through a list. 
14:19:15 <Eduard_Munteanu> guest2424: ah, I understand.
14:19:26 <guest2424> can you explain to me please
14:19:39 <guest2424> Eduard_Munteanu : can you explain to me please
14:19:40 <guest2424> ?
14:20:19 <Eduard_Munteanu> guest2424: well, in Bubble sort you compare two elements and either swap them or not.
14:20:27 <guest2424> ok
14:20:43 <Eduard_Munteanu> guest2424: so for every two elements, you do that comparison and swap if needed.
14:20:51 <guest2424> ok
14:21:45 <guest2424> so I can write a function and use swap max and min
14:21:46 <guest2424> ?
14:21:47 <Eduard_Munteanu> guest2424: I'm guessing a bubble sort pass is O(n).
14:21:54 <guest2424> yes
14:22:02 <Eduard_Munteanu> and there are O(n) such passes.
14:22:10 <guest2424> Eduard_Munteanu: can I  write a function and use swap max and min
14:22:33 <Eduard_Munteanu> guest2424: well, have you worked out a way to do the actual swapping, let alone comparison?
14:22:51 <guest2424> no
14:23:50 <Eduard_Munteanu> It's not that straightforward for lists, usually bubblesort is used as an introductory sorting algorithm for vectors.
14:24:04 <guest2424> Eduard_Munteanu: Thank you are you going to be later on today?
14:24:16 <Eduard_Munteanu> Maybe, maybe not.
14:24:21 <guest2424> ok
14:24:33 <guest2424> I will try to talk you later if you can
14:25:31 <Eduard_Munteanu> Since they're suggesting folding, this should tell you you could compare adjancent elements.
14:26:19 <Eduard_Munteanu> The actual folding function would do either x:y:, or y:x: depending on the comparison
14:27:10 <Eduard_Munteanu> The initial value should be obvious.
14:30:30 <Eduard_Munteanu> Bbl.
14:33:09 <Eduard_Munteanu> (um rather like x:)
14:33:40 <davekong> If I write a function that displays an image and times how long it takes a user to respond should I be able to get millisecond accuracy with say getCPUTime or should I use something else?
14:34:14 <Martty> huh? i can't see to access stuff defined in a module that is imported by another one im importing
14:34:43 <dolio> getCPUTime is the wrong thing to use if youw ant to know how long a user takes to respond.
14:35:13 <dolio> It tells you how much time the CPU has spent executing your process.
14:36:52 <davekong> Is there something to get real world time with?
14:36:59 <ClaudiusMaximus> davekong: how are you getting a response?  some operating systems / configurations have abysmal timing of keyboard events, for example (10ms quantization ...)
14:37:22 <davekong> ClaudiusMaximus: was going to use getch from curses
14:37:46 <dolio> Data.Time.Clock, probably.
14:38:51 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/time/1.2.0.3/doc/html/Data-Time-Clock.html#v:getCurrentTime
14:39:54 <davekong> thanks both
14:41:49 <joe1> can a function return 2 values as: f x = a b, I know a function can return a tuple as f x = (a,b)..
14:42:25 <joe1> not a list of values as a has a different type than b
14:42:44 <enthropy> joe1: you can return a continuation
14:43:01 <enthropy> so   f x andThen = andThen a b
14:43:02 <joe1> enthropy: interesting, what is that?
14:44:32 <joe1> enthropy: just googled it, reading up on it. thanks for pointing it out.
14:47:08 <nus> joe1, the question is do you know at the call time how many values do you want to return?
14:47:40 <joe1> nus: yes
14:48:02 <nus> joe1, what's wrong with an n-tuple?
14:48:57 <joe1> nus: nothing, just feel that with a tuple, you have to write most of the tuple operations yourself.
14:49:38 <nus> joe1, the tuple operations?
14:49:53 <joe1> another question: I have "f x y z", is there a way I can convert it to the format: "x f y z"?
14:50:31 * hackagebot bindings-gts 0.0.3 - Low level bindings supporting GTS, the GNU Triangulated Surface Library  http://hackage.haskell.org/package/bindings-gts-0.0.3 (JoelCrisp)
14:50:33 <joe1> joe1: if I need the fst, I have to write a lambda operation or pattern match, don't i?
14:50:45 <sbrg> or just "fst"
14:50:50 <sbrg> > fst (1, 2)
14:50:51 <hsbot>   1
14:51:06 <enthropy> > flip f x y z
14:51:07 <hsbot>   Not in scope: `f'Not in scope: `x'Not in scope: `y'Not in scope: `z'
14:51:09 <sbrg> hsbot /= lambdabot?
14:51:14 <enthropy> apparently not
14:51:18 <Nibble> \x y -> x * y is just sugar for \x -> \y right?
14:51:34 <joe1> sbrg: if it is a 2 element tuple, yes
14:51:46 <sbrg> joe1: ah, yes, otherwise you need to pattern match
14:51:50 <sbrg> but you can always write your own helpers
14:52:17 <sbrg> > let fst' (x, _, _) = x in fst' (1,2,3)
14:52:18 <hsbot>   1
14:52:24 <joe1> sbrg: yes, i was just curious if there is anything else out there better than that.. just prodding my boundaries..
14:54:06 <joe1> enthropy: i do not think flip works on 3 argument functions, does it?
14:54:10 <sbrg> nope
14:54:13 <sbrg> Well, it does
14:54:16 <sbrg> it merely flips the first two
14:54:39 <sbrg> :t flip (\x y z -> undefined)
14:54:43 <sipa1024> :t flip
14:54:48 <sbrg> Boo, hsbot.
14:54:49 <sbrg> Boo.
14:55:04 <sbrg> I was surprised to find this out myself, but I assume it is due to currying
14:55:18 <benmachine> .type id
14:55:19 <hsbot> a -> a
14:55:20 <sipa1024> > flip a b c
14:55:21 <hsbot>   Not in scope: `a'Not in scope: `b'Not in scope: `c'
14:55:30 <sipa1024> > flip (+) 3 4
14:55:31 <hsbot>   7
14:55:31 <benmachine> > show (typeOf flip)
14:55:32 <hsbot>   Not in scope: `typeOf'
14:55:35 <benmachine> hmph
14:55:39 <sipa1024> > flip (-) 3 4
14:55:40 <hsbot>   1
14:55:43 <benmachine> > Data.Typeable.typeOf ()
14:55:44 <hsbot>   Not in scope: `Data.Typeable.typeOf'
14:55:48 <benmachine> hmph hmph
14:55:49 <aristid> > subtract 3 4
14:55:49 <hsbot>   1
14:55:59 <enthropy> benmachine: it won't help since typeable doesn't do polymorphic things
14:56:06 <aristid> sipa1024: it turns out, haskell has a function for flip (-) embedded :)
14:56:10 <joe1> again, i have f a b c, I want to write it as a f b c
14:56:13 <benmachine> enthropy: oh, yes, true
14:56:14 <nus> joe1, homepages.cwi.nl/~ralf/HList/
14:56:27 <joe1> i know, f b a = flip f a b
14:56:28 <sipa1024> flip op a b c = (flip op a b) c = (b `op` a) c 
14:56:32 <Tony__> hey guys, i need some help in hakell
14:56:38 <Tony__> haskell*
14:56:54 <sipa1024> Tony__: if you tell us what the problem is, maybe we can help :)
14:57:05 <sbrg> What happened to our dearest lambdabot?
14:57:19 <sipa1024> it was destructively overwritten
14:57:50 <sbrg> no...
14:57:54 <joe1> nus: that is interesting. heterogenous datatypes. will check it out.
14:58:00 <sbrg> That cannot be true.
14:58:17 <joe1> sipa1024: what I have is actually a op b c
14:58:39 <Tony__> okay i need to rewrite a function that partitions a list, example input list [9,7,11,6,88,3,2] output takes the head of the list which is 9 in this case and puts every integer greater than it to the right and what's less to the right 
14:58:40 <nus> joe1, http://www.haskell.org/onlinereport/exps.html
14:58:50 <Tony__> can i paste the funtion here ?
14:58:59 <sbrg> > "lambdabot, n" ++ repeat 'o'
14:59:00 <hsbot>   "lambdabot, noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
14:59:24 <sbrg> Haskell is so expressive I might start expressing my feelings in it
14:59:34 <nus> joe1, http://www.haskell.org/onlinereport/decls.html#fixity
15:00:25 <Tony__> original function
15:00:27 <Tony__> high_down p  n old_low new_low new_high old_high
15:00:27 <Tony__>  | n == 0              = (reverse new_low) ++ (p : new_high)
15:00:27 <Tony__>  | p <= head old_high  = high_down p (n-1) old_low
15:00:27 <Tony__>                                            new_low
15:00:28 <Tony__>                                            ((head old_high): new_high)
15:00:30 <Tony__>                                            (tail old_high)
15:00:32 <Tony__>  | otherwise           = low_up    p (n-1) old_low
15:00:34 <sbrg> Tony__: No.
15:00:34 <Tony__>                                            ((head old_high): new_low)
15:00:36 <Tony__>                                            new_high
15:00:37 <sbrg> hpaste.org
15:00:38 <Tony__>                                            (tail old_high)
15:00:39 <sipa1024> Tony__: use hpaste.org
15:00:40 <Tony__>    
15:00:42 <Tony__>  | p >= head old_low   = low_up    p (n-1) (tail old_low)
15:00:44 <Tony__>                                            ((head old_low): new_low)
15:00:46 <sipa1024> do not paste code here
15:00:46 <Tony__>                                            new_high
15:00:48 <sbrg> ...
15:00:48 <Tony__>                                            old_high 
15:00:50 <Tony__>  | otherwise           = high_down p (n-1) (tail old_low)
15:00:52 <Tony__>                                            new_low
15:00:54 <Tony__>                                            ((head old_low): new_high)
15:00:57 <sbrg> this is where one leaves and rejoins
15:00:58 <Tony__>                                            old_high
15:01:00 <Tony__> partition (p: r) = high_down p (length r) r [] [] (reverse r) 
15:01:02 <Tony__> ok 
15:01:09 <companion_cube> Tony__, /cycle
15:01:14 <benmachine> companion_cube: too late
15:01:26 <benmachine> I believe /server purge does the trick on irssi
15:01:56 <Tony__> ok sorry
15:02:08 <Tony__> http://hpaste.org/40804/partition_function
15:02:44 <Tony__> now i need to rewrite this recursivly
15:04:20 <Tony__> so i simply used filter 
15:04:29 <Tony__> newfuntion []     = []
15:04:29 <Tony__> newfunction (x:xs) = newfunction (filter (< x) xs) ++ [x] ++ newfunction (filter (>= x) xs)
15:04:46 <kwikness> =D
15:06:26 <kwikness> team deadbeef 4 life
15:06:43 <Tony__> kwikness, tell us what do u think 
15:07:23 <kwikness> Tony__, i dunno. when i see haskell all i can think is "KTHXBYE"
15:07:39 <kwikness> so do you guys like doin computers?
15:07:48 <enthropy> the newfunction is that so-called quicksort
15:07:50 <pumpkin> I've never "done" a computer
15:08:25 <kwikness> pumpkin, rofl
15:09:25 <Tony__> enthropy, correct, it does the job by my old school prof wants me to rewrite the function in the link above so it would be a tail recursive function 
15:09:41 <Tony__> but my old school prof* 
15:10:01 <Tony__> kwikness, i do computaz
15:10:15 * kwikness high fives Tony__!!!!
15:10:52 <enthropy> Tony__: so add a tuple accumulating parameter
15:12:01 <kwikness> enthropy, is a tuple accumulating parameter just a parameter that counts the number of function calls?
15:12:12 <kwikness> enthropy, never heard the term
15:12:40 <enthropy> kwikness: I mean  (currentMiddle, leftHalfSorted)
15:12:51 <tmvphil> Anybody know if the Yi project is still being actively developed
15:13:03 <enthropy> you probably have to rearrange a bit more to be actually tail-recursive
15:14:43 <Tony__> enthropy, im really thankful for the help but im still not sure how to do that, would u be able to help me on that really quick ? thanks
15:15:19 <enthropy> Tony__: you know what it means to be tail-recursive?
15:15:41 <Tony__> yes, i read about it a little
15:17:21 <nus> tmvphil, http://news.gmane.org/gmane.editors.yi.devel
15:19:13 <kevinb7> Hi, any Haskell programmer willing to help on an assignment? Will pay money.
15:19:29 <kmc> haha
15:19:38 <abstrakt> kevinb7, wrong place to ask that question
15:19:53 <abstrakt> kevinb7, not to mention you'll need to tell us what the assignment is before anyone would even be remotely interested
15:19:53 <kmc> just ask your Haskell question
15:20:02 <kmc> don't try to bribe anyone
15:20:15 <kmc> people here are usually eager to answer specific questions
15:20:23 <kmc> specific questions ≠ do my assignment for me
15:22:39 <Zao> kevinb7: You probably alienated most of the channel by offering money.
15:23:18 <surjection> if it helps, i'll take the money
15:25:19 <kmc> donate the money towards buying a new lambdabot
15:25:35 <sipa1024> what sum are we talking about?
15:26:01 <nus> yeah, hire Cale back
15:28:38 <aristid> preflex: seen cale
15:28:39 <preflex>  cale was last seen on #haskell 3 days, 2 hours, 2 minutes and 20 seconds ago, saying: Applying the function 4 to the value 5
15:28:55 <aristid> preflex: seen preflex
15:28:55 <preflex>  what
15:29:08 <sipa1024> > 4 5
15:29:09 <hsbot>   No instance for (GHC.Num.Num (t -> a)) arising from the literal `4' at <interactive>:3:0-2 Possible fix: add an instance declaration for (GHC.Num.Num (t -> a))
15:33:12 <aristid> > 4 5 :: Int
15:33:13 <hsbot>   No instance for (GHC.Num.Num (t -> GHC.Types.Int)) arising from the literal `4' at <interactive>:1:0-2 Possible fix: add an instance declaration for (GHC.Num.Num (t -> GHC.Types.Int))
15:33:27 <aristid> hsbot: you're missing crucial instances!
15:33:46 <aristid> who runs hsbot?
15:33:48 <aristid> @help
15:33:53 <aristid> hsbot: help
15:33:59 <aristid> hsbot: version
15:34:01 <tolkad> is there a class for associating MonatTrans instances with their associated ordinary monads?
15:34:11 <opqdonut> no
15:34:23 <aristid> tolkad: you can apply them to the Identity monad
15:34:23 <tolkad> this is kind of annoying
15:34:24 <opqdonut> what would that association give you?
15:34:32 <aristid> tolkad: that yields something equivalent to the ordinary monad
15:34:42 <tolkad> opqdonut: a common function name so I don't have to think of my own
15:35:01 <tolkad> opqdonut: or recall whatever I named it for a particular monad pair
15:35:09 <opqdonut> what's the type of the function
15:35:53 <opqdonut> Monad a -> MonadT m a ?
15:37:08 <sipa1024> it is the type of functions
15:37:31 <sipa1024> that takes a monadic action that produces something of type a as result, as argument
15:37:43 <opqdonut> sipa1024: I was trying to find out what tolkad wants :)
15:37:49 <tolkad> writing it
15:37:55 <kmc> tolkad, use the 'transformers' package, then the "ordinary monad" is just the transformer applied to Identity
15:38:08 <spetrea-home> kmc: reminds me of the moview transformers
15:38:43 <aristid> kmc: oh, you can't do that with mtl?
15:38:57 <tolkad> how do I write multiple functional dependencies?
15:39:04 <kmc> a -> b, c -> d
15:39:08 <sipa1024> | a -> b, c -> d
15:39:18 <kmc> with mtl «State s» is isomorphic to «StateT s Identity», but not actually identical
15:39:27 <kmc> with transformers «type State s a = StateT s Identity a»
15:40:22 <tolkad> class (Monad m, MonadTrans n, Monad o) => Something m n | m -> n, n -> m where something :: Monad t => m a -> n t a
15:40:29 <tolkad> wait
15:40:33 <tolkad> don't need o
15:40:42 <tolkad> class (Monad m, MonadTrans n) => Something m n | m -> n, n -> m where something :: Monad t => m a -> n t a
15:40:44 <tolkad> there we go
15:41:16 <tolkad> not sure if the n -> m dependency is useful
15:41:31 <sipa1024> is that even possible
15:41:36 <tolkad> taking a look at transformers
15:42:39 <tolkad> sipa1024: what's wrong with it? instance Something Maybe MaybeT where something = MaybeT . return
15:43:10 <sipa1024> no, i wonder if it's possible to have a -> b, b -> a fundep
15:43:21 <opqdonut> tolkad: MaybeT . return doesn't unwrap the Maybe
15:43:53 <opqdonut> I guess you want something like "something Nothing = lift fail" "something (Just a) = lift (return a)"
15:44:22 <tolkad> opqdonut: why would you need to? the type of MaybeT is Monad m => m (Maybe a) -> MaybeT m a
15:44:36 <tolkad> are packages trans and mtl exclusive?
15:44:42 <opqdonut> ah, yes, my bad
15:44:45 <tolkad> transformers*
15:44:50 <tolkad> transformers and mtl
15:45:42 <tolkad> what I mean is, can I use transfomers and mtl in the same cabal package?
15:46:13 <tolkad> it looks like it has some mtl packages in it
15:47:04 <altmattr> I understand why SYB needs run-time type checks, but I don't understand how EMGM/regular/et.al manage to _not_ have run-time type checks.  Can anyone enlighten me?
15:47:51 <dreixel> altmattr: syb carries little information in its representation types
15:48:09 <monochrom> when you write "import Control.Monad.Blah", it will be ambiguous because both packages provide it. there is a GHC extension for saying "I mean from mtl" and "I mean from transformers". you decide whether you want to do that.
15:48:26 <dreixel> whereas other generic libraries have more complicated representations, thereby having more knowledge about the types and needing no runtime casts
15:49:02 <altmattr> dreixel: it is your paper (I think) about optimising generics that has me thinking about this
15:49:36 <dreixel> altmattr: yes, typed representations are essential for optimization of generic functions
15:49:49 <altmattr> instead of a run-time type check at each node in s structure, EMGM needs to convert the whole data structure to another structure that encodes the relevent information right?
15:50:17 <dreixel> uhm, yes
15:51:04 <altmattr> so how does that manage to happen with just a 17% overhead?  I imagine there must be three passes over the data - convert, do something, convert back
15:51:17 <dreixel> yes, but GHC is very good at fusing those things together
15:51:30 <dreixel> whereas it can't do much with rank-2 functions
15:51:51 <dreixel> actually you could try to implement syb differently, so that it would be easier to optimize (using the spine view)
15:52:24 <dreixel> but it's current implementation, with rank-2 functions and runtime casts, is not too good for the compiler to optimize
15:52:29 <tolkad> monochrom: why do I need a ghc extension when this could be handled by cabal?
15:52:45 <dreixel> also, it keeps traversing unnecessary things...
15:52:46 <tolkad> monochrom: couldn't it just rename one of the packages?
15:52:47 * hackagebot enumerator 0.4.2 - Implementation of Oleg Kiselyov's left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.2 (JohnMillikin)
15:52:59 <yitz> preflex: seen lambdabot
15:52:59 <preflex>  lambdabot was last seen on #haskell 21 hours, 32 minutes and 2 seconds ago, saying: * lambdabot is retiring, good night all
15:53:04 <altmattr> dreixel: I have implmented something similar to SYB in a fucntional compiler, so the tests are much faster
15:53:12 <altmattr> but still not as fast as EMGM/regular
15:53:19 <tolkad> monochrom: and use some cabal pragma interpreted by cabal to tell which package to rename the import to?
15:53:28 <yitz> ?
15:53:28 <altmattr> and I am trying to work out how.
15:53:37 <dreixel> altmattr: a simplified version of syb, like uniplate, optimizes much better.
15:53:41 <tolkad> monochrom: seems like this should be a cabal extension rather than a GHC extension considering packages are a cabal thing
15:54:10 <tolkad> I guess it really doesn't matter to me though
15:54:18 <altmattr> dreixel: indeed, but is quite restricted - I use uniplate in my compiler!
15:55:40 <dreixel> altmattr: I have high hopes for what we implemented in UHC, and is coming now to GHC
15:56:16 <altmattr> dreixel: to get as fast as EMGM/regular, there must be no checking of "extra structure" in most cases
15:56:34 <altmattr> dreixel: as far as I can see
15:56:48 <tolkad> is this a bad example in the wiki? using isJust there? http://en.wikibooks.org/wiki/Haskell/Monad_transformers#Motivation
15:56:48 <tolkad> If you used a case expression on maybe_value, you would already have it out of the maybe rather than having to use the unsafe fromJust
15:57:27 <altmattr> dreixel: perhaps I need to trace some regular code to see how it works
15:57:49 <dreixel> altmattr: looking at core code is a nice experience
15:58:02 <altmattr> dreixel: ha!
15:58:05 <monochrom> use case on maybe_value is more popular
15:58:07 <dreixel> well, "nice"... enlightning, at least :)
15:58:11 <altmattr> dreixel: perhaps I will bug you some more then :)
15:58:12 <tolkad> (I guess the other stuff could use a case expression but that's a bit redundant and there wouldn't be anything to do in the Nothing case)
15:58:53 <dreixel> altmattr: feel free to, and you can also email if you'd like (might be easier for longer things)
15:58:57 <Zaber> hi guys 
15:59:14 <kwikness> Zaber, hey
15:59:34 <monochrom> but I don't consider things like "if x/=0 then y/x else ..." and "if isJust x then fromJust x else ..." unsafe. the safety nets are right there, what is being unsafe?
15:59:44 <Zaber> my girlfreind thinks im a stupid fag nerd because im on IRC asking talking about Haskelll all day. I am not sure how i got a grilfreind in the first place. oh wait, it's my imagenary girlfreind, that's right ! ill just imagine another one ! thanks guys
16:01:15 <monochrom> "omg division is unsafe! we use restrict to safe_divide :: (Num a) => a -> a -> Maybe a"  that's just paranoia.
16:01:26 <monochrom> s/use/should/
16:01:48 <lolizor> can somebody offer some suggestions: http://hpaste.org/40807/style
16:02:10 <tolkad> Zaber: I find your conduct offensive! Are you calling me a homosexual for being in this channel?
16:02:25 <altmattr> dreixel: let me be more concrete - the update/tree example from the paper.  It requires a check (of some sort) at every node to see if it is the one we need to update.  Can you give me some insight into how EMGM/regular manage to get below the 2x slowdown I expect would be the best you could expect?  I expect 2x to be the best since the operation happening at the node of interest is simple and the check at each node in the structure should
16:02:26 <altmattr> least take *some* time.
16:02:38 <tolkad> Zaber: there's nothing wrong with people who have a different sexual orientation with you
16:02:43 <dreixel> altmattr: because they use type-classes
16:02:47 <dreixel> for the adhoc behavior
16:02:51 <tolkad> Zaber: than you*
16:03:06 <tolkad> I apologize for my grammatical error
16:03:24 <altmattr> dreixel: I am a bit rusty on my type classes, but is there not a dictionary encoding what functions to run for which types?
16:03:36 <Zaber> tolkad, why so serious ?
16:03:37 <altmattr> dreixel: ah! no! there is a dictionary of fucntions _for that type_
16:03:39 <kwikness> Zaber, just because i never kissed a girl doesnt have anything to do with the fact that i love formal software verification and have haskell posters on my walls
16:03:44 <altmattr> dreixel: silly me
16:03:57 <tolkad> lolizor: with that many Eithers... it's time to write a new data type...
16:04:16 <monochrom> lolizor: perhaps design your own data type with 3 variants instead of using nested Either's.
16:04:22 <zachk> kwikness: go get a fat cute girlfriend 
16:04:23 <altmattr> dreixel: I have been mixing that up ever since I first started programming haskell
16:04:26 <zachk> or you will die a virgin 
16:04:41 <kwikness> zachk, i would never go out with a chick unless she's got a haskell fetish
16:05:03 <dreixel> altmattr: good use of type-classes generally results in fast code
16:05:07 <altmattr> dreixel: The dictionary is all the functions for the type you are working on - type inference and the compiler desugarring of type classes ensure you have the dictionary for the right type at the right place - yeah?
16:05:14 <mauke> stop it! stop this right now
16:05:15 <tolkad> lolizor: it's telling you that parentheses are unnecessary within a tuple
16:05:21 <mauke> this channel is getting very silly
16:05:23 * Eduard_Munteanu is back
16:05:25 <crazycaw> hey
16:05:32 <tolkad> lolizor: (a, b) is the same as (a, (b))
16:05:44 <tolkad> lolizor: for any expressions a and b whatsoever
16:06:13 <dreixel> altmattr: yes, it's all taken care of by the static types
16:06:18 <sipa1024> (a) is the same as a, for any expressions of a whatsoever
16:06:38 <tolkad> Zaber: because you're trolling and responding seriously will either escalate your trolling or annoy you
16:06:43 <monochrom> I only go out with bots that have ghc installed.
16:07:06 <lolizor> tolkad, besides hlint suggestions =)
16:07:09 <tolkad> Zaber: both of which are amusing
16:07:45 <kwikness> Zaber, yeah we're not fags just cuz we like doin computers
16:07:51 <altmattr> dreixel: which makes me feel better about my 3x slowdown - I don't have type classes in my compiler 
16:08:00 <tolkad> sipa1024: in contrast to (a + b) not being the same as ((a) + (b)) for any expressions a and b
16:08:18 <fengshaun> kwikness, you like doing computers?
16:08:22 <tolkad> sipa1024: perhaps expression wasn't the right word since it implies it has already been parsed? sorry I wasn't sure what word to use there
16:08:34 <kwikness> fengshaun, yeah. doesn't everybody in this channel?
16:08:49 <tolkad> lolizor: well, you could put a pragma at the top of the file to ignore warnings
16:09:30 <dreixel> altmattr: I'm curious about that compiler of yours
16:09:42 <dreixel> altmattr: but now I'm off, so I'll have to hear about it some other time :p
16:09:50 <lolizor> tolkad, hlint takes pragmas?
16:09:54 <altmattr> dreixel: thanks so much for your help
16:10:39 <Zaber> tolkad, what's trolling means ?
16:10:56 <dreixel> altmattr: you're welcome! feel free to keep asking
16:12:06 <lolizor> tolkad, http://hpaste.org/paste/40807/style2#p40809
16:13:06 <Zaber> tolkad, now that i got your attention, can u help me on my assignement ?
16:13:54 <fengshaun> kwikness, hmmm I wonder how is it even possible -- physically.
16:14:45 <osfameron> Zaber: perhaps it might be worth you reading http://www.haskell.org/haskellwiki/Homework_help ?
16:14:56 <osfameron> and then coming back with a specific question
16:15:02 <kwikness> fengshaun, you can do it with the keyboard, the mouse..
16:15:20 <kwikness> i love debugging
16:15:34 <lolizor> monochrom, ^^ if you have more suggestions
16:15:47 <fengshaun> oh, I'm gonna think about it more!
16:19:07 <Zaber> ok the original assignement was to rewrite a partition function ( which has 2 inner functions ), combine these two into one tail recursive, this is the original function. http://hpaste.org/40804/partition_function
16:19:44 <tarwatirno> /bl 
16:19:44 <tarwatirno>  
16:19:48 <Zaber> i combined both high and low in here, making it a recursive function, http://hpaste.org/40805/partition_function_2
16:21:15 <Zaber> but this is not exactly what i need, this is not tail recursive
16:27:27 <zygoloid> Zaber: in both of those functions, the fourth and fifth guard will never match, since all cases are covered by the first three
16:29:32 <Zaber> zygoloid, are u sure, because in the 2nd and third it compares p with the head of old_high, in the 4th and 5th it compares p with old_low 
16:31:01 <Zaber> zygoloid, ignore this one, this is wrong http://hpaste.org/40805/partition_function_2
16:31:08 <Zaber> i meant that one
16:31:13 <Zaber> http://hpaste.org/40804/partition_function
16:31:32 <zygoloid> @src otherwise
16:31:47 <Zaber> ignore this one http://hpaste.org/40804/partition_function this is wrong
16:32:46 <zygoloid> Zaber: guards are matched top-down, and the first matching one is used. in order for the fourth guard to be even considered, "p <= head old_high" and "p > head old_high" must both be False
16:34:54 <Zaber> zygoloid, got ya, ... look at this one, this is working http://hpaste.org/40810/partition_function_original
16:35:28 <Zaber> how would u combine both inner functions into one tail recursive one on this ?  http://hpaste.org/40810/partition_function_original
16:41:28 <kmc> 'u' is not a word
16:44:29 <Zaber> how would you combine both inner functions into one tail recursive one on this ? http://hpaste.org/40810/partition_function_original
16:45:58 <zygoloid> that code looks tail-recursive to me
16:46:47 <PeyTy> hello all
16:47:01 <Zaber> zygoloid, then how would you combine both inner functions into one ?
16:48:47 <zygoloid> i think i probably wouldn't.
16:49:26 <Peaker> Is there an automated way to mechanically translate a non-tail-recursive definition (with just one recursive call) to a tail-recursive one (Perhaps at the cost of converting stack use to heap use, in some cases)? It seems for lazy functions, we want non-tail-recursive, and for strict functions, we want tail-recursive.  Could GHC do the conversion automatically, based on strictness?
16:49:48 <Peaker> Perhaps if laziness/strictness was "first-class", we could code via combinators that did this?
16:50:38 <hpc> :t let (t ?? f) b = if b then t else f in (seq ?? const id)
16:50:43 <Zaber> zygoloid, ok, let me rephrase the question then, if 1 million person are going to die and you are the only one who can save them by combining these two functions into one, what would you do ?
16:50:56 <zygoloid> i'd wake up
16:51:11 <Zaber> do you want money ?
16:52:59 <jmcarthur> money for what looks like a homework assignment?
16:53:17 <Zaber> yes, what do you think I am doing this for fun ?
16:53:51 <osfameron> or for learning how to pass your degree?
16:53:52 * jmcarthur wonders if there is a chance that Zaber's instructor is in this channel
16:54:03 <jmcarthur> because it would be awesome if so, after reading that
16:55:07 * osfameron has a homework question... but it's about research for a sci-fi writing assignment on colonizing Venus using floating cities.  Where's the best IRC channel to ask someone to write my story for me? ;-P
16:55:21 <zygoloid> Peaker: that sounds a lot like what the CPS transform would do
16:55:56 <Peaker> zygoloid, Yeah.. I am wondering because I was disappointed I would have to re-write many functions (e.g: "sequence") to be tail-recursive when using them in a strict monad
16:56:03 <zygoloid> (with the associated cost that it would pick a specific evaluation order rather than building thunks)
16:56:03 <jmcarthur> osfameron: you could always hit up #haskell-blah ;)
16:56:16 <Peaker> zygoloid, otherwise I get O(N) stack use, instead of as low as O(1) (at least iirc, this was a while ago)
16:56:44 <jmcarthur> Zaber: a lot of us do this stuff for fun
16:57:48 <Peaker> zygoloid, One of the modularity claims for laziness is re-using code in more contexts (the finite and infinite context), but here I'd have to write a strict variant manually, much like other language libraries write a lazy copy of each function manually
16:58:09 <Zaber> jmcarthur, ok well, i tried many things and it's not working for me, so I came here asking for help but it looks like when someone asks for help in an assignment you get flammed. 
16:58:55 <Peaker> Zaber, Are you asking for help or for someone to do it for you?
16:59:07 <jmcarthur> Zaber: we don't actually have any sort of no homework questions policy, but i have to admit i was rather offended by you offering money for it
16:59:22 <Axman6> Zaber: we help people with their assignments all the time, but we do not just give them answers
16:59:37 <zygoloid> Peaker: perhaps the trouble is that the two forms are denotationally distinct? i'm not sure they are, if you do proper strictness analysis before applying the transform, but i can imagine it being a wrinkle. certainly sounds like an interesting idea.
16:59:55 <jmcarthur> Zaber: sometimes people are even willing to just solve the problem for those who ask. after all, it only hurts the person not willing to do their own homework. perhaps there is just no such person in here at the moment
17:00:22 <zygoloid> Peaker: it's also not clear to me exactly what transform should be applied
17:00:28 <Zaber> ok, sorry, then what's a good way to ask a question, i hit a dead end on my homework
17:01:22 <zygoloid> Zaber: well, i hope you can imagine that starting by implying we're "stupid fag nerd"s is not productive
17:01:39 <Peaker> zygoloid, Maybe asking for the transform explicitly would be a good start
17:01:53 <jmcarthur> Zaber: sometimes there are people in here with a lot of time, but often that's not the case. maybe you could try to ask questions that are likely to have direct answers that don't take too long to derive?
17:02:03 <jmcarthur> either way, i'm one of those people without much time. gotta go make dinner
17:02:13 <jmcarthur> Zaber: good luck! (i mean that sincerely)
17:03:10 <zygoloid> Peaker: like a {-# RULES #-} pragma which can match strictness? that'd be neat
17:04:41 <Peaker> zygoloid, Haven't thought of it like that, that sounds pretty great, esp. since it is just about the operational semantics :)
17:05:09 <Peaker> zygoloid, does strictness analysis take "hints"? Does it "propagate" hints into functions you happened to call, to optimize them as well?
17:06:16 <zygoloid> Peaker: sorry, this is beyond my knowledge of ghc internals ;(
17:11:09 <tehgeekmeister> in the very last function (tiny one liner!) in this file http://github.com/tehgeekmeister/grokist/blob/master/src/WordList.hs, why does the handle get closed before L.hGetContents can read from it?
17:12:43 <tehgeekmeister> oh, because that is evaluated after withfile has finished executing
17:12:45 <tehgeekmeister> because of lazy io
17:12:48 <tehgeekmeister> i need strict io
17:15:07 <Peaker> tehgeekmeister, lazy I/O is horrible!
17:15:12 <Peaker> tehgeekmeister, Iteratee/enumerators
17:15:18 <tehgeekmeister> i plan to switch to them
17:15:23 <tehgeekmeister> but i'm on a schedule for right now
17:16:44 <tehgeekmeister> lazy io is awesome until you start to do something mildly complicated
17:16:45 <tehgeekmeister> then it blows
17:17:20 <endojelly> tehgeekmeister, do you have a quick example?
17:17:34 <tehgeekmeister> endojelly: of?
17:17:42 <endojelly> tehgeekmeister, when lazy IO poses a problem
17:18:03 <endojelly> tehgeekmeister, I always wondered but never thought too much about it.
17:18:14 <endojelly> tehgeekmeister, I mean, lazy IO still keeps everything in sequence, doesn't it?
17:18:36 <tehgeekmeister> if you use lazy io inside withFile, withFile opens the file, "evaluates" your code using lazy io (really it makes a thunk), and then closes the handle
17:18:52 <endojelly> tehgeekmeister, so unless we're talking about networking or interprocess communication... I can see where the problem is there, but top of the head I think just forcing it to evaluate at certain points should be enough?
17:18:54 <tehgeekmeister> then when you attempt to call that function using that bit of code later, the handle is already closed before the input is read
17:19:49 <Peaker> endojelly, "Forcing stuff to evaluate" is a bit of a tricky notion in Haskell, IMO
17:19:57 <endojelly> tehgeekmeister, hmm, why is closing of the handle not part of "the IO", which would delay its evaluation and thus the actual closing of the handle after everything else has been done?
17:20:02 <Peaker> endojelly, And I think in many cases it breaks/leaks abstractions
17:20:20 <endojelly> Peaker, ok, but let's put IPC and networking aside for a while. i'm wondering if there are problem with lazy IO in other ways
17:21:07 <tehgeekmeister> endojelly: i can't tell you why it's not, i only know that's how it works.  probably that ghc makes the io action inside withfile a thunk because the output is not immediately needed, then continues with the strict action of closing the handle
17:21:12 <tehgeekmeister> iteratees don't have that problem
17:21:13 <tehgeekmeister> which is nice
17:22:25 <endojelly> tehgeekmeister, how do iteratees work around that? or rather, what do they do differently?
17:22:39 <tehgeekmeister> ask anyone else in here and you'll probably get a better answer
17:22:45 <tehgeekmeister> i just know iteratees get around it
17:22:48 <tehgeekmeister> i haven't used them
17:23:01 <Peaker> endojelly, Once you use lazy I/O to "read" stuff you have to choose between "forcing" stuff (which means you have to know exactly how much of the parse *result* you need to force until it reads the whole file, which may leak abstractions or force computation of things you don't need), and..
17:23:22 <Peaker> endojelly, the other choice is never calling close-file on lazy I/O read handles, which means you leak FD's until the GC cares to operate
17:24:18 <endojelly> Peaker, I see, that's understandable. thanks.
17:24:22 <endojelly> and iteratees?
17:25:19 <Peaker> endojelly, Iteratees have the file-reading or other input handling drive the whole process, so it is like: open-file, read-content-incrementally, feed-incremental content to explicitly built "pipeline" that processes it (an Iteratee), close-file
17:26:25 <Peaker> endojelly, you represent a data consumer ("iteratee") as a simple state machine ("I'm done, here's a result" or "I want more data, here's a function that gives my new state when given more data")
17:26:50 <endojelly> aah.
17:26:52 <Peaker> endojelly, Then a "produce" is a function from a hungrier consumer to a fuller consumer (One that transforms a state machine to a new state after eating more data)
17:26:59 <Peaker> a "producer", that is
17:27:04 <koninkje> endojelly: Instead of doing (iterator $ data) you do (enumerator $ iteratee)
17:27:35 <Peaker> koninkje, nice way of putting it... push instead of pull
17:28:06 <Peaker> I guess maybe another way of putting it is that what we want is incremental I/O, not "lazy" I/O.  A push model of incremental I/O is better than a lazy-pull model in terms of resource guarantees
17:28:24 <koninkje> indeed
17:28:50 <endojelly> that's interesting. I'd like to see an implementation of this (I know that Snap uses it, so I can just look there). is it possible to do this entirely on top of the lazy IO monad? I guess it at least forces evaluation at some point, too?
17:29:00 <Peaker> and both can be used pretty similarly, as shown by the iteratee implementations
17:29:14 <Peaker> endojelly, What is the lazy IO monad?
17:29:17 * hackagebot lhs2TeX-hl 0.1.0.9 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.0.9 (AlessandroVermeulen)
17:29:55 <endojelly> Peaker, is that not what "normal" haskell IO is?
17:30:04 <endojelly> Peaker, a monad in which you do IO, with lazy semantics?
17:30:28 <Peaker> endojelly, http://docs.yesodweb.com/blog/enumerators-tutorial-part-1 (and part-2, 3)
17:30:31 <koninkje> endojelly: well, in normal haskell you can either use things like getContents (lazy I/O) or things like getLine (non-lazy)
17:30:38 <Peaker> endojelly, No, IO is a "strict" monad
17:30:58 <endojelly> Peaker, oh
17:31:02 <Peaker> endojelly, Laziness is a property of evaluation, and IO is more about execution, not evaluation..
17:31:30 <koninkje> the enumerator version of getContents would (a) open a file, (b) call getLine and feed the results to the iteratee untill the iteratte says "enough!", then (c) close the file
17:31:55 <koninkje> (d) returning whatever the final iteratee value is
17:32:01 <endojelly> Peaker, I was thinking about having a strict and a lazy state monad, and IO seemed more lazy to me because it wouldn't force evaluation without me, as you said, consuming the result
17:32:25 <endojelly> koninkje, that seems pretty easy actually
17:32:52 <koninkje> the "laziness" of lazy I/O is just in functions like getContents, which only perform the I/O as it is demanded
17:33:14 <koninkje> We could instead have a strict version of getContents which reads the whole file at once, but we don't\
17:33:32 <endojelly> koninkje, ok, I somehow assumed that most functions in the IO monad would be lazy.
17:33:53 <koninkje> endojelly: Yeah, once you get past the notation, iteratees are pretty easy
17:34:49 <koninkje> another trick in the notation is that a "stream" is modelled by data Stream a = Chunk a | EOF. Notice how it's not recursive like we might expect
17:35:18 <koninkje> the recursive part of things is made implicit and is handled by the enumerator
17:37:23 <endojelly> koninkje, I understand. because otherwise it would be just like what we had before. you'd have to force evaluation to recurse through it without consuming a result of a sufficiently hungry enough computation.
17:38:03 <Peaker> koninkje, It would read chunks, not lines in particular
17:38:12 <endojelly> quick question aside, something different and really simple but I want to be sure:
17:38:28 <Peaker> koninkje, I think "Stream" is a terrible name for it
17:39:04 <koninkje> Peaker: sure, depending on the implementation. The chunkiness isn't essential to the idea though; it's just for performance
17:39:17 <endojelly> the term Just 2 for example is whnf already, as is the term Just ((\x -> x) 2), right?
17:39:18 <Peaker> koninkje, I think "Stream" shouldn't exist at all, instead the (Stream .. -> ..) function should be replaced by different functions for the different cases -- allowing for type-safe restriction of the result of EOF for example (e.g: Must yield a value)
17:39:59 <McManiaC> > fail ", epic"
17:40:00 <hsbot>   No instance for (GHC.Show.Show (m a)) arising from a use of `M1411761716.show_M1411761716' at <interactive>:(2,0)-(4,30) Possible fix: add an instance declaration for (GHC.Show.Show (m a))
17:40:08 <Peaker> endojelly, WHNF means the choice between Nothing and Just was made, but the contents of Just may remain lazy, yeah
17:40:12 <McManiaC> > fail ", epic" :: Maybe Int
17:40:12 <hsbot>   Nothing
17:40:14 <McManiaC> :D
17:40:19 <endojelly> but Just 2 is in normal form, while Just ((\x -> x) 2) isn't, also true?
17:40:28 <endojelly> sorry
17:40:31 <endojelly> head normal form
17:41:02 <koninkje> endojelly: The "weak head" part of WHNF just means that the top level of the term is a constructor application or a lambda; i.e., no lambdas applied to things
17:41:16 <koninkje> (the "weak" is the lambda part of it)
17:41:38 <koninkje> Whereas "(full) normal form" means everything is reduced, even under the head
17:41:56 <endojelly> Peaker, that's a nice way to put it. I can say that in (\_ -> Nothing) Nothing the choice hasn't been made yet, because we need to evaluate that lambda first, yet it still is of type Maybe
17:42:57 <endojelly> koninkje, ok, but my question is about the difference between weak head normal form and head normal form (I accidentally said normal form first)
17:45:44 <endojelly> or is head normal form and normal form the same?
17:46:10 <Peaker> endojelly, Yeah, though in some philosophical ways what I said may be wrong, given that it is a determinism outcome :)
17:46:31 <dolio> No, head normal form is something different.
17:47:09 <endojelly> Peaker, yeah it's only true for a very specific meaning of "choice", I understood what you mean though 8)
17:47:28 <endojelly> dolio, so what is the difference between a head normal form and a weak head normal form?
17:47:41 <pumpkin> endojelly: looking inside lambdas
17:47:52 <dolio> Weak head normal form stops as soon as it sees a constructor or lambda.
17:48:30 <dolio> Or application of a variable.
17:48:32 <endojelly> so Just ((\x -> x) 2) isn't in head normal form, right?
17:48:52 <dolio> But head normal form will reduce a lambda if the body isn't in head normal form.
17:49:11 <endojelly> will head normal form reduce the body to head normal form?
17:49:18 <dolio> So (\x -> (\y -> y) x) is in weak head normal form, but not head normal form.
17:49:29 <endojelly> if so I'm not sure what the difference to normal form is.
17:49:31 <dolio> The head normal form would be (\x -> x)
17:49:57 <dolio> And (\x -> x ((\y -> y) (\z -> z))) is in head normal form, but not normal form.
17:50:00 <FunctorSalad> the "everything" one is called 'reduced normal form', if the function of that name is to be trusted
17:50:02 <FunctorSalad> (rnf)
17:50:19 <FunctorSalad> er though that can't eval in lambda bodies either
17:50:40 <dolio> It's in head normal form because it's an application of a non-lambda.
17:50:42 <endojelly> dolio, ah. so head normal form only looks at lambda bodies as a whole.
17:51:10 <endojelly> and since the body here isn't a lambda at all, it's happy.
17:53:43 <dolio> M N is in head normal form as long as that particular application is not reducible.
17:53:58 <dolio> So, it doesn't matter if N has redexes, it's still in head normal form.
17:54:14 <dolio> Thus, (\x -> M N) is also in head normal form.
17:54:47 <dolio> Normal form requires there be no redexes in N, as well.
17:54:49 <megajosh2> Hmm
17:54:59 <endojelly> dolio, it's clear now. thanks.
17:55:02 <dolio> Weak head normal form will accept any (\x -> M N), regardless of what M and N are.
17:56:44 <endojelly> I'm under the impression somehow that whnf is more important in practice than hnf?
17:56:53 <Peaker> FunctorSalad, I guess functions shouldn't have instances for rnf then?
17:56:54 <endojelly> (while nf is, of course, very important)
17:57:06 <dolio> Yeah. Honestly, I don't know where hnf comes from.
17:57:33 <Peaker> If you don't have the notion of a "constructor" at all, doesn't hnf become more meaningful than whnf?
17:57:34 <dolio> whnf is how reduction actually happens in a lazy language.
17:58:11 <koninkje> endojelly: In case it hasn't been answered yet, HNF requires there to be a constructor application under any number of lambdas; whereas WHNF doesn't go under lambdas
17:58:16 <endojelly> dolio, maybe hnf was just a side product of defining whnf
17:58:39 <dolio> Well, it's hard to tell, but I get the impression that hnf was around before whnf.
17:58:48 <endojelly> dolio, at least the name suggests that
17:58:49 <tehgeekmeister> how do i make bytestrings play nicely with unicode?
17:58:56 <endojelly> dolio, whnf's name, that is
17:58:57 <tehgeekmeister> (or do i just have to switch to using text?)
17:59:07 <endojelly> koninkje, it has been, but thanks again
17:59:09 <dolio> And that hnf was a proposal for modelling lazy graph reduction.
17:59:20 <dolio> But it clearly seems wrong.
17:59:46 <FunctorSalad> Peaker: hmm I don't think they have instances
18:00:15 <FunctorSalad> Peaker: and as I understand it, hnf is pretty impractical, because you can't look into function bodies with efficiently compiled code
18:00:27 <tehgeekmeister> (or is text a drop-in replacement for bytestring?)
18:00:32 <FunctorSalad> (you'd need to store an actual lambda expression, but maybe there are faster ways)
18:00:49 <endojelly> Peaker, koninkje, dolio, thanks a lot! have to go to bed now
18:00:58 <dolio> For instance, \x -> (\y -> y y) (\y -> y y) has no head normal form.
18:01:02 <endojelly> but that was really insightful
18:01:13 <Peaker> FunctorSalad, Sure, hnf sounds like it is important in LC/theory, and whnf more important in implementations of lazy languages
18:01:18 <dolio> But I'd be surprised to see a lazy language, or even a strict language, looping on it.
18:01:38 <Peaker> though I really dislike whnf.. if it is a concrete type, whnf is unnecessary (use a pattern match). if it is an abstract type, whnf's meaning is unclear, it leaks the abstraction
18:03:14 <tolkad> I wish haskell let you pattern match for bottom
18:03:30 <Peaker> tolkad, Godel disapproves
18:04:10 <deech> Hi all, I had a question about some interesting code I saw in the Haskell Lua bindings library (http://hackage.haskell.org/packages/archive/hslua/latest/doc/html/Scripting-Lua.html).
18:04:36 <tolkad> Peaker: if it weren't for Gödel and his "incompleteness theorems" we wouldn't have these problems : /
18:04:44 <deech> It has to do with 'callfunc' (http://hackage.haskell.org/packages/archive/hslua/latest/doc/html/src/Scripting-Lua.html#callfunc)
18:04:50 <FunctorSalad> tolkad: I think that would break monotonicity
18:04:52 <ddarius> tolkad: And you wouldn't have a job.
18:05:18 <tolkad> who came up with the halting problem?
18:05:21 <FunctorSalad> (f monotonic = if x is less defined or equal than y, then f x is less defined or equal than f y)
18:05:22 <tolkad> this is also their fault
18:05:44 <FunctorSalad> AFAIK all functions in haskell have monotonic semantics, and I assume it's rather useful for reasoning :)
18:05:45 <deech> Although according to the type sig only takes 2 parameters it can actually take any number. How is Haskell allowing this?
18:06:03 <tolkad> FunctorSalad: can you write that in haskell in terms of "isBottom"?
18:06:04 <Eduard_Munteanu> What do you mean by monotonicity in this context?
18:06:18 <Peaker> deech, The "a" type callfunc returns may be a function type
18:06:41 <tolkad> > id id 5
18:06:41 <hsbot>   5
18:06:46 <FunctorSalad> if you could pattern match on bottom, you could have an f :: Int -> Int such that f 0 = undefined, but f undefined = 7
18:06:48 <tolkad> deech: like that
18:06:50 <deech> But it takes any number of args.
18:06:54 <FunctorSalad> violating monotonicity
18:07:03 <tolkad> > id id id id id 5
18:07:04 <hsbot>   5
18:07:10 <tolkad> deech: like that?
18:07:25 <FunctorSalad> Eduard_Munteanu: with respect to the 'definedness' order
18:07:30 <deech> so I can say "callfunc l "proc" "abc" (1::Int) (5.0::Double)
18:07:33 <deech> "
18:07:42 <dolio> isBottom is a simple example, too.
18:07:52 <dolio> isBottom undefined = True ; isBottom _ = False
18:07:58 <FunctorSalad> right :)
18:08:03 <Eduard_Munteanu> FunctorSalad: ah, it makes sense.
18:08:06 <dolio> undefined < True, False, True </ False
18:08:12 <ddarius> deech: All Haskell functions take exactly one argument.
18:08:27 <zachk> what about the ones that take no arguments? 
18:08:30 <Peaker> deech, meaning it will take another arg.. the function instance of LuaCallFunc will probably look like:  instance LuaCallFunc result => LuaCallFunc (a -> result) where ...
18:08:34 <pikhq> zachk: No such thing.
18:08:46 <Eduard_Munteanu> Mm, not quite true.
18:08:48 <zachk> @type f = const 5 
18:08:53 <tolkad> wait, is it called bottom because it's part of some ordered set??
18:09:08 <Eduard_Munteanu> If anything, I'd take an f :: IO () as a function.
18:09:12 <tolkad> is that what you guys are talking about? because I'm confused
18:09:13 <hpc> tolkad: that seems to be the likely etymology
18:09:15 <Peaker> deech, by having the function return a function type, it can take "another" arg. If the result of that function happens to be a function, it will take another arg, and so on
18:09:16 <ddarius> Eduard_Munteanu: Nope.
18:09:17 <pikhq> Eduard_Munteanu: It certainly isn't.
18:09:28 <hpc> bottom comes from category theory, not haskell
18:09:36 <pikhq> Eduard_Munteanu: It's a value of type IO (), which clearly is not a function.
18:09:41 <Eduard_Munteanu> I mean it certainly corresponds to functions in non-functional languages.
18:09:47 <ddarius> deech: That defines a function `f' that takes one argument and returns five, which may or may not itself be a function.
18:09:48 <dolio> No, it comes from lattice/domain theory.
18:10:07 <deech> Peaker: Oh interesting. But how did the author scale this to arbitrarily large functions?
18:10:08 <ddarius> dolio: Lattice theory is usually considered synonymous with order theory.
18:10:18 <Peaker> deech, when you use:  callfunc ...  1 2 3 4 5        you are forcing the type checker to choose a type like: (... -> (Int -> Int -> Int -> Int -> Int -> a)) -- which works because the type of callfunc is:  LuaCallFunc a => ... -> a      so that "a" is allowed to be: Int -> Int -> ... -> a
18:10:21 <pikhq> Eduard_Munteanu: Not our fault they conflate functions and imperative actions.
18:10:26 <ddarius> hpc: Bottom does not come from category theory.
18:10:47 <Eduard_Munteanu> Ah, yes, mathematically speaking I'm in agreement.
18:11:03 <deech> Peaker: weird
18:11:10 <Peaker> deech, The key is the recursive instance for functions:   instance LuaCallFunc out => LuaCallFunc (in -> out) where ...  
18:12:14 <Peaker> deech, If you have (a -> b) and you allow "b" to either be your "final result type", or "yet another function type on the way to the result type", and allow that choice be made by the *caller*, you've gotten variadic functions
18:12:29 * hackagebot enumerator-tf 0.1 - Enumerator instances for monads-tf classes  http://hackage.haskell.org/package/enumerator-tf-0.1 (JohnMillikin)
18:12:31 * hackagebot enumerator-fd 0.1 - Enumerator instances for monads-fd classes  http://hackage.haskell.org/package/enumerator-fd-0.1 (JohnMillikin)
18:12:36 <Peaker> deech, because the "b" will expand to something like (another_input -> b) again
18:12:57 <Peaker> deech, This is another reason why return-type polymorphism is great :-)
18:13:10 <deech> Peaker: That's slightly insane. I'd never thought about it that way before.
18:13:13 <Peaker> deech, Caller chooses return type, and doing that it can choose to give more arguments
18:13:28 * ddarius wishes people wouldn't try to make a term out of "return-type polymorphism."
18:14:05 <Peaker> ddarius, Why not? if you subtract single-dispatch polymorphism which many know, from type-class+parameteric polymorphism, you get a set of things, one of which is "return-type polymorphism"..
18:14:43 <Eduard_Munteanu> I think ddarius implies you shouldn't make that distinction.
18:14:58 <ddarius> Peaker: That statement clearly illustrates why I dislike that term.  If you subtract single-dispatch polymorphism a la most OO languages from type classes and parametric polymorphism, you get type classes and parametric polymorphism.
18:15:25 <Peaker> ddarius, You mean, they give you none of the power?
18:15:39 <Peaker> (single-dispatch polymorphism gives none of the power, that is)
18:15:58 <ddarius> It's just different.
18:16:04 <deech> Saturday night, mind blown. I'll take what I can get.
18:16:16 <deech> Score.
18:16:27 * adu gives deech a potato
18:18:36 * Eduard_Munteanu asks a question from earlier on...
18:18:48 <Eduard_Munteanu> What would you recommend to draw a series of images on screen?
18:19:08 <deech> Sharpie
18:19:12 <Eduard_Munteanu> I need it to show the results of cellular automata simulation, and I'm currently using GTK.
18:19:33 * Eduard_Munteanu looks that up
18:19:50 <deech> It was a joke, a Sharpie is a marker. Sorry. 
18:19:52 <zachk> opengl ? :( 
18:20:02 <Eduard_Munteanu> Oh noes :)
18:20:13 <deech> Have you considered using the browser?
18:20:23 <Eduard_Munteanu> Well, I was kinda hoping there was some plotting function that pops up an window and can be used for animations :)
18:20:37 <Eduard_Munteanu> I'm being cheap on LOC.
18:20:47 <deech> I think there's Javascript libs for that. 
18:21:29 <Eduard_Munteanu> Grr... It seems I'll have to use GTK drawables w/ / w/o OpenGL.
18:22:07 <tolkad> ooh, this gives me a good idea
18:22:23 * Eduard_Munteanu thought he was going to prove a point by not doing it in Matlab :)
18:22:34 <tolkad> maybe I could write a class allowing me to forget about the argument order of functions
18:23:44 <megajosh2> If argument order is such a problem, then maybe you could just create a datatype that compacts some of those arguments for you
18:23:48 <megajosh2> Just use record syntax
18:24:09 <megajosh2> Is it some function with a huge amount of arguments?
18:24:45 <tolkad> class Call a b c d e where call :: (a -> b -> c) -> d -> e -> c
18:24:46 <tolkad> instance Call a b c a b where call = id
18:24:46 <tolkad> instance Call a b c b a where call = flip
18:24:47 <Eduard_Munteanu> tolkad: I don't think that's the proper workaround if you're simply passing environment around.
18:24:51 <tolkad> it's genious!
18:25:18 <tolkad> now can I make it variadic...
18:25:42 <sipa1024> call (+)
18:25:44 <sipa1024> what type?
18:26:03 <sipa1024> and better: which instance?
18:26:08 <koninkje> Has anyone here used Google's protocol buffers before?
18:26:42 <jmcarthur> koninkje: i did at work a long time ago, but i am probably very rusty by now
18:27:09 <Eduard_Munteanu> Fundeps?
18:27:11 <koninkje> jmcarthur: Do you happen to remember where the Java runtime jar is put?
18:27:29 <Eduard_Munteanu> a -> d and b -> e ? I imagine you don't need it that polymorphic.
18:27:29 <jmcarthur> sorry, no. i didn't use any java stuff for it that i remember
18:27:46 <Eduard_Munteanu> Though I don't think it works.
18:27:48 <koninkje> I'm not having luck finding it on the site nor where I installed stuff...
18:31:50 <tolkad> this doesn't make sense
18:32:00 <tolkad> my call function doesn't work without a type annotation
18:32:06 <tolkad> haskell is supposed to be able to infer types
18:32:09 <ClaudiusMaximus> Eduard_Munteanu: i have a fractal renderer that just pokes pixels into memory then uses OpenGL to upload it to a texture periodically
18:32:35 <ClaudiusMaximus> Eduard_Munteanu: the app uses GTK
18:33:40 <tolkad> here's the problem: http://codepad.org/xVRUNxso
18:33:41 <Eduard_Munteanu> ClaudiusMaximus: thanks, I suppose I'll do that too then.
18:33:45 <tolkad> how can that be possible?
18:34:11 <tolkad> isn't haskell able to infer types? I thought annotations were unnecessary except for the monomorphism restriction
18:34:14 <ClaudiusMaximus> Eduard_Munteanu: if you want to look at my ugly code, 'cabal unpack gmndl' (though i have a small update in the works that makes it slightly less ugly)
18:34:45 <Kaidelong> tolkad: not always
18:35:00 <tolkad> aww
18:35:07 <tolkad> well that makes my call function useless
18:35:10 <Kaidelong> tolkad: actually, making it so that all types can be inferred is a bad idea for various reasons
18:35:38 <tolkad> Kaidelong: well it would have allowed me to write this awesome function
18:35:47 <Eduard_Munteanu> ClaudiusMaximus: ah, I'll have a look at that if I get stuck
18:36:14 <Kaidelong> hmm I'm looking at it and trying to figure it out
18:36:38 <tolkad> Kaidelong: well, it actually IS inferring a type
18:36:43 <tolkad> Kaidelong: the wrong one!
18:37:15 <Kaidelong> I think the problem is that it can infer any type it wants for d
18:37:53 <tolkad> Kaidelong: why not e then?
18:38:24 <tolkad> I'm asking #ghc if it's a bug
18:39:12 <Philippa> tolkad: polymorphic recursion is undecidable without annotations, as is polymorphism of rank > 2 (and you can only manage 2 if you don't allow types of higher rank than that, AIUI)
18:39:47 <enthropy> tolkad: the 0 defaults to Integer, for which there is no instance
18:40:12 <enthropy> whoops no
18:41:38 <jmcarthur> tolkad: dependence on type classes are a good way to interfere with type inference
18:41:54 <enthropy> tolkad: you're still allowed instance Call a b c d e
18:42:12 <jmcarthur> MultiParamTypeClasses, in particular, is likely to lead to ambiguities
18:42:28 <Eduard_Munteanu> Well what instance is that "Call a b c d e"? For what?
18:42:34 <tolkad> well how can I write my call function allowing me to forget the order of arguments?
18:42:39 <jmcarthur> but you can even manage a type ambiguity even without it
18:42:58 <tolkad> jmcarthur: there is no type ambiguity error
18:43:10 <tolkad> jmcarthur: there is a missing instance error without the annotation
18:43:24 <jmcarthur> tolkad: in the absense of defaulting it would be an ambiguous type error
18:43:31 <jmcarthur> i don't really like defaulting anyway
18:44:11 <Eduard_Munteanu> Anyway, I think it's way too polymorphic.
18:44:20 <enthropy> tolkad: put   default Int    in your code
18:45:06 <jmcarthur> those instances scare me a lot. i'm surprised that's even accepted
18:45:10 <osaunders> Is there a realistic way of doing this? http://hpaste.org/40812/general_conversion_type_class
18:45:15 <jmcarthur> although i can't think of a specific rule it violates
18:45:26 <tolkad> enthropy: no difference
18:45:42 <tolkad> jmcarthur: yeah isn't it awesome?
18:45:49 <Eduard_Munteanu> jmcarthur: isn't "instance Foo a" an instance for _anything_?
18:46:02 <tolkad> jmcarthur: ever since I realized how powerful type class instances are I have been abusing them
18:46:08 <jmcarthur> Eduard_Munteanu: yes
18:46:16 <Eduard_Munteanu> And is that even allowed?
18:46:19 <Eduard_Munteanu> :)
18:46:23 <jmcarthur> Eduard_Munteanu: yes
18:46:27 <tolkad> Eduard_Munteanu: with FlexibleInstances
18:46:42 <Eduard_Munteanu> Uh, I think that thing covers a lot then.
18:47:25 <jmcarthur> tolkad: you are making hindley and milner cry
18:47:31 <Ytinasni> defaulting won't help because (Num t => t) is a valid type there. defaulting only works for unification failures.
18:47:39 <jmcarthur> yeah
18:47:49 <Ytinasni> replacing 0 with (0 :: Int) probably works.
18:47:51 <jmcarthur> type class constraints don't assist unification
18:48:04 <Ytinasni> jmcarthur: _constraints_ do. he has none.
18:48:26 <jmcarthur> Ytinasni: i mean instances don't impose anything on unification
18:48:41 <Ytinasni> :D
18:48:43 <jmcarthur> Ytinasni: which is only sensible, but sometimes surprising when you are just starting out abusing it like this
18:50:03 <osaunders> tolkad: What are you trying to do? I came in late.
18:50:23 <tolkad> class Call a b c d e where call :: (a -> b -> c) -> d -> e -> c
18:50:23 <tolkad> instance Call a b c a b where call = id
18:50:24 <tolkad> instance Call a b c b a where call = flip
18:50:31 <jmcarthur> Ytinasni: actually... do type class constraints help unification at all? i assume equivalence constraints do, but i'm treating that as a different thing
18:50:34 <tolkad> osaunders: http://codepad.org/xVRUNxso
18:50:34 <Eduard_Munteanu> He's trying to get Haskell to automatically flip function arguments when he makes a typo :)
18:50:48 <tolkad> I tried class Call a b c d e | d e -> a b c where call :: (a -> b -> c) -> d -> e -> c
18:50:50 <jmcarthur> Eduard_Munteanu: succinctly explaining why it's not working ;)
18:50:51 <tolkad> it's not working though
18:50:59 <Ytinasni> jmcarthur: they help defaulting, by making unification fail.
18:51:09 <tolkad> I think I misunderstood fundeps
18:51:14 <tolkad> hmm
18:51:15 <Eduard_Munteanu> Yeah, it's rather trivial to prove it can't really work for all functions.
18:51:16 <jmcarthur> ah, i was also not thinking of defaulting as a unification-related task
18:51:41 * hackagebot cpython 3.1.1.0 - Bindings for libpython  http://hackage.haskell.org/package/cpython-3.1.1.0 (JohnMillikin)
18:51:50 <Ytinasni> jmcarthur: i didn't until i saw that code :)
18:51:56 <jmcarthur> :P
18:52:00 <osaunders> tolkad: I'm trying to do something related if you look at my hpaste posted above.
18:52:27 <jmcarthur> monomorphism is silly. i am not a fan of both the monomorphism restriction and of defaulting
18:54:19 <Eduard_Munteanu> tolkad: for example, what if you had a function Int -> Int -> Int? Seems undecideable whether the arguments are the right way.
18:54:38 <Eduard_Munteanu> (remember a, b, c, ... can all be the same)
18:54:45 <tolkad> Eduard_Munteanu: I realize that, I would want it to have an overlapping instances error if I tried that
18:55:17 <tolkad> anyway, how do fundeps interact with types dependant on eachother?
18:55:22 <Eduard_Munteanu> tolkad: I don't think you would, you see, you're not writing instances for particular types, but for all types.
18:56:03 <Eduard_Munteanu> So those instances in fact do overlap a lot.
18:56:14 <Eduard_Munteanu> It doesn't depend whether you actually invoke 'call'.
18:56:17 <tolkad> Eduard_Munteanu: well, I should just avoid using them for functions like that then
18:56:36 <tolkad> Eduard_Munteanu: well it compiles just fine
18:56:40 <tolkad> Eduard_Munteanu: so ghc disagrees with you
18:57:04 <Eduard_Munteanu> Well, Haskell'/98 disagrees with your -XFlexibleInstances magic :D
18:58:09 <Eduard_Munteanu> I hear a lot of extensions aren't really things set in stone, like I heard for GADTs.
19:01:36 <tolkad> well I obviously don't need parameter c...
19:03:00 <mmoloney> does anyone here have Reactive-FieldTrip (FRP and OpenGL) experience?
19:03:51 <Eduard_Munteanu> ClaudiusMaximus: hm, I think I'll use Cairo, as I might need to draw squares. It also seems to take care of OpenGL.
19:04:55 <ClaudiusMaximus> Eduard_Munteanu: ok - but you can make a texture of pixels look like an array of squares by magnifying it with nearest-neighbour interpolation
19:06:01 <Eduard_Munteanu> I see.
19:06:44 * hackagebot anansi 0.2.1.1 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.2.1.1 (JohnMillikin)
19:11:39 <fhobia> what does the exclamation point mean in "data DisplayBits = DisplayRGBBits !Int !Int !Int" ?
19:12:08 <pikhq> fhobia: Strict field.
19:12:20 <fhobia> ah
19:13:49 <Eduard_Munteanu> Nice, I like freeze & thaw for arrays.
19:14:29 <ddarius> See also unsafeFreeze.
19:14:46 * hackagebot yajl 0.3.0.4 - Bindings for YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-0.3.0.4 (JohnMillikin)
19:17:24 <Eduard_Munteanu> ddarius: uh oh. I had in mind doing something like "thaw . pure_computation . freeze", the copy in freeze doesn't seem very good.
19:17:56 <ddarius> Eduard_Munteanu: Hence unsafeFreez.
19:18:00 <Eduard_Munteanu> Or is there a better idiom for that?
19:18:02 <Eduard_Munteanu> Oh.
19:18:21 <ddarius> There's also an unsafeThaw but you really don't want to be doing that.
19:20:09 <ddarius> The only time unsafeThaw would be reasonable is if you had a computation that expects a mutable array but doesn't actually mutate that array (even temporarily.)
19:20:37 <Eduard_Munteanu> Meh, would there be an workaround for this sort of stuff without messing with mutable arrays? I'm evaluating the cellular automata in a function triggered by a timer.
19:20:56 <tolkad> I will beat GHC into submission
19:21:00 <tolkad> why doesn't this work? http://codepad.org/AtKW5piV
19:21:11 <Eduard_Munteanu> ddarius: well, that kinda seems to be the case. I only need to store the result between timer ticks.
19:21:26 <Eduard_Munteanu> The evaluation itself is comonadic, pure.
19:21:50 <Eduard_Munteanu> Maybe a Writer monad?
19:22:18 <jmcarthur> i don't really see how you're doing this comonadically with mutable arrays at all
19:22:32 <ddarius> I don't see what the issue is.  Either your mutating the array or you aren't.  If you aren't, use immutable arrays.
19:22:37 <ddarius> s/your/you're/
19:22:45 <tolkad> Couldn't match expected type `[Char] -> String' against inferred type `CallT String Int t String'
19:22:45 <Eduard_Munteanu> jmcarthur: I'm not. I'm simply computing one step, then saving it so when the next timer tick comes, the result is there.
19:22:49 <tolkad> what's up with that
19:23:42 <tolkad> why isn't it applying my type synonym
19:23:44 <Eduard_Munteanu> ddarius: say I have evaluate :: Array -> IO (), which evaluates one step of the automaton evolution. I need to save it somehow.
19:23:47 <ddarius> Eduard_Munteanu: It sounds like you just want to store an immutable array into an IORef.
19:24:43 <Eduard_Munteanu> Oh, it seems that would work. For some reason I thought I had to recreate a different array if I did that.
19:24:53 <Eduard_Munteanu> Thanks.
19:25:25 <tolkad> why would it ever give me an error about a type synonym not matching a type!?
19:25:28 <tolkad> that doesn't even make sense
19:25:33 <Eduard_Munteanu> ddarius: btw, just making sure: in this case (GTK events) it's all swell to go ahead and use a few IORefs?
19:25:36 <tolkad> it should apply the type synonym
19:25:47 <ddarius> Eduard_Munteanu: Why wouldn't it be?
19:26:07 <tolkad> oh wait, it needs to know t
19:26:24 <Eduard_Munteanu> ddarius: I was keeping myself open to pure alternatives.
19:26:56 <Eduard_Munteanu> Anyway, the IO is there, why not use it.
19:27:19 <tolkad> oh, it's the ambiguous int that's the problem
19:27:29 <tolkad> I guess that works without this other stuff though
19:28:01 <tolkad> the original does
19:28:58 <tolkad> well that's acceptable, now I just need to make it varidaic
19:29:50 <ddarius> Eduard_Munteanu: I doubt GTK provides any other way for you to maintain state between events.  The low-level API probably has a user data void * field, but that would still have to be mutable to be useful and there's little reason to expose that API to Haskell as we get the same effect via lexical scoping.
19:30:38 <ddarius> Eduard_Munteanu: However, you can write a quick helper function to present a more pure interface, or, if you don't need any IO at all, just use modifyIORef.
19:32:21 <Eduard_Munteanu> ddarius: hm, that makes more sense. I can just pass "\x -> x =>> evaluate" to modifyIORef in upper levels.
19:33:10 <Axman6> "Anyway, the IO is there, why not use it." -> "Anyway, the vodka bottle is there, why not drink it all?" :P
19:33:35 <Eduard_Munteanu> Heh.
19:33:49 <ddarius> Axman6: Why not indeed.
19:33:54 <tolkad> if you are thinking that way you might as well put IO on all your functions
19:34:05 <Axman6> because vodka is horrible, nasty crap
19:34:54 <ddarius> Axman6: My slight experience with vodka seems along those lines, albeit it was vodka my brother and sister-in-law had that they didn't like and didn't want.
19:35:00 <ddarius> Tequila though...
19:38:16 <ymasory> is there a term i can use for contrast with with "generic type"?
19:39:46 <Axman6> undefined?
19:39:52 <Axman6> :t undefined
19:40:01 <Axman6> bah
19:40:10 <megajosh2> "something that is in contrast to a generic type"
19:40:46 <Axman6> oh contrast, i read that as constant
19:40:49 <ymasory> it's for my static types chart. i want to ask whether "standard types" are reified, and then whether generic types are reified
19:41:15 <ymasory> http://github.com/ymasory/Lang-Chart/blob/master/langchart.org
19:41:30 <tehgeekmeister> is (**) left or right associative by default?
19:41:51 <dolio> > 3 ** 2 ** 2
19:41:52 <hsbot>   81.0
19:42:00 <dolio> Oops.
19:42:08 <dolio> > 2 ** 3 ** 3
19:42:08 <hsbot>   1.34217728e8
19:42:34 <Gracenotes> @check \x y z -> x**y**z == x**(y**z)
19:42:38 <centrinia> Why does Scala have almost everything?
19:42:40 <Gracenotes> :o
19:42:56 <Axman6> > (2**3**4,(2**(3**4),(2**3)**4)
19:42:57 <hsbot>   <no location info>: parse error (possibly incorrect indentation)
19:43:04 <Axman6> > (2**3**4,2**(3**4),(2**3)**4)
19:43:05 <hsbot>   (2.4178516392292584e24,2.4178516392292584e24,4096.0)
19:43:05 <ymasory> centrinia: that's the purpose of this chart. to write an inflammatory blog post with the title "scala has every feature of every language"
19:43:52 <centrinia> It is lacking in the collections syntax chart.
19:44:06 <ymasory> centrinia: please suggest
19:44:06 <tehgeekmeister> wait
19:44:07 <Gracenotes> and the haskell column
19:44:10 <tehgeekmeister> can't ghc tell you fixity?
19:44:12 <tehgeekmeister> and whatnot?
19:44:17 <tehgeekmeister> err, ghci
19:44:19 <Gracenotes> does haskell have closures? I wonder..
19:44:38 <ymasory> i'm finding it damn hard to define closures in an interesting and fair way for the chart
19:44:49 <Axman6> tehgeekmeister: :i foo
19:45:08 <joe1> ski: you around
19:45:26 <joe1> ksf:  i have the code with types. do you have a minute?
19:45:33 <tolkad> why do people care so much about decideablity in the type system?
19:45:45 <centrinia> They should make Scala do full tail call optimization, lazy evaluation, pattern matching in parameters, preprocessing, lists, indexing, slicing, and maps.
19:46:08 <tolkad> it's possible to write a program which takes such a huge amount of time to compile that it's no better than never compiling
19:46:25 <ymasory> centrinia: i'm more of the opinion they need to take *out* a lot of stuff
19:46:49 <tolkad> unless it's also important that a language have a certain compilation complexity based on code length
19:46:57 <tolkad> but I'm not sure haskell has that
19:48:35 <tehgeekmeister> (slightly off topic: anyone know of a programming language where ** is *not* right associative?)
19:49:16 <ymasory> tehgeekmeister: scala
19:49:34 <tolkad> > let a=(.).(.) in let b=a.a.a in let c=b.b.b in let d=c.c.c in let e=d.d.d in let f=e.e.e in let g=f.f.f in let h=g.g.g in let i=h.h.h in let j=i.i.i in let k=j.j.j in let l=k.k.k in l
19:49:39 <hsbot>   
19:49:52 <tolkad> > 0
19:49:53 <hsbot>   0
19:49:57 <tolkad> hmm
19:49:58 <FunctorSalad> @commands
19:50:10 <FunctorSalad> not lambdabot's brother?
19:50:17 <FunctorSalad> @botsnack
19:51:27 <tolkad> @let lol = let a=(.).(.) in let b=a.a.a in let c=b.b.b in let d=c.c.c in let e=d.d.d in let f=e.e.e in let g=f.f.f in let h=g.g.g in let i=h.h.h in let j=i.i.i in let k=j.j.j in let l=k.k.k in let m=l.l.l in let n=m.m.m in let o=n.n.n in let p=o.o.o in let q=p.p.p in let r=q.q.q in let s=r.r.r in let t=s.s.s
19:51:28 <Axman6> tehgeekmeister: you can define more than one thing in a let statement...
19:51:37 <tolkad> @let lol = let a=(.).(.) in let b=a.a.a in let c=b.b.b in let d=c.c.c in let e=d.d.d in let f=e.e.e in let g=f.f.f in let h=g.g.g in let i=h.h.h in let j=i.i.i in let k=j.j.j in let l=k.k.k in let m=l.l.l in let n=m.m.m in let o=n.n.n in let p=o.o.o in let q=p.p.p in let r=q.q.q in let s=r.r.r in let t=s.s.s in t
19:51:40 <tolkad> aww
19:51:49 <tehgeekmeister> Axman6: eh?  i didn't ask anything about that.
19:51:51 <tolkad> > let a=(.).(.) in let b=a.a.a in let c=b.b.b in let d=c.c.c in let e=d.d.d in let f=e.e.e in let g=f.f.f in let h=g.g.g in let i=h.h.h in let j=i.i.i in let k=j.j.j in let l=k.k.k in let m=l.l.l in let n=m.m.m in let o=n.n.n in let p=o.o.o in let q=p.p.p in let r=q.q.q in let s=r.r.r in let t=s.s.s in t
19:51:56 <hsbot>   
19:51:56 <jmcarthur> wtf
19:52:01 <Axman6> sorry, meant tolkad 
19:52:10 <tolkad> uh yeah forgot for some reason
19:52:15 <tolkad> used to multiline haskell :P
19:52:23 <FunctorSalad> is this a new breed of bot?
19:53:30 <blbrown_win3_> can I install haskell on win32 without an installer. E.g. can I just unzip an archive?
19:54:52 <blbrown_win3_> ghc I mean
19:54:55 <Zao> blbrown_win3_: Snapshots seem to have tarballs.
19:55:10 <Zao> http://www.haskell.org/ghc/dist/stable/dist/
19:55:24 <Zao> Things like http://www.haskell.org/ghc/dist/stable/dist/ghc-6.12.3-i386-unknown-mingw32.tar.bz2
19:55:47 <FunctorSalad> there's also the source, though I have no experience with compiling it in win
19:56:29 <blbrown_win3_> I never understood why people like these msi, installers so much
19:56:40 <Zao> FunctorSalad: It's about as fun as compiling it on other platforms, but plus the joy of conjuring up a sufficiently capable msys+mingw.
19:56:58 <Zao> blbrown_win3_: Because they do things, like associate files, add to path, are UNINSTALLABLE, etc.
19:57:08 <Zao> Uninstallation, a concept completely foreign to the average hippie.
19:57:14 <blbrown_win3_> Zan ...exactly, horribly bad to unconfigure if you need tgo
19:58:01 <Zao> Not to mention that msis are easy to deploy centrally, slipstream into OS discs, can depend on other MSIs, have platform selection abilities, etc.
19:58:12 <Zao> It's like asking why people keep using debs where there are tarballs.
19:58:13 <FunctorSalad> Zao: there are some programs that wrap the 'make install' etc and monitor what gets installed
19:58:44 <blbrown_win3_> Zao, unzip, run, has worked for 30 years
19:58:46 <FunctorSalad> e.g. paco, in fact I wrap 'cabal install' in that, though I never actually uninstalled a package
19:59:07 <Zao> blbrown_win3_: For you, maybe.
19:59:12 <FunctorSalad> (and stow and checkinstall)
19:59:34 <Zao> blbrown_win3_: That doesn't handle the multitude of runtimes one might need, dependency checking, service packs, etc.
19:59:42 <Zao> blbrown_win3_: You are not every scenario.
20:00:09 <Zao> It's like asking why you need security when you can run your own personal machine as Administrator just fine.
20:00:14 <Kaidelong> as an added bonus
20:00:21 * Zao caresses the analogy machine.
20:00:27 <Kaidelong> microsoft can generate MSIs for you in their development environment
20:00:58 <Kaidelong> so if you're developing .NET they make sense tool-support wise
20:01:12 <Zao> Kaidelong: If you're developing anything non-trivial, I'd say.
20:01:46 <Zao> Anyway, if you hadn't quit, I'd told you that the tarball indeed seems to contain a GHC.
20:01:59 <ddarius> Zao: Actually there are plenty of reasons to have security even for a single user machine (which is probably most desktops nowadays.)
20:02:13 <Zao> ddarius: Naturally.
20:02:26 <Zao> ddarius: Many people don't though, as "it gets in the way".
20:03:09 <ddarius> That's because security is handled poorly throughout (any of) the current desktop software stacks.
20:03:10 <FunctorSalad> I set my sudo ticket lifetimes to 5 hours, is this bad? ;)
20:03:25 <ddarius> FunctorSalad: Not really.
20:04:11 <Kaidelong> shouldn't the escalated privilidges last the process' whole liftime (and all of the processes it spawns)?
20:04:25 <Kaidelong> I mean for sudo to be very useful
20:04:46 <FunctorSalad> yeah, the tickets are for additional invocations
20:05:15 <FunctorSalad> they're about the only reason I use sudo over su ;)
20:06:01 <Eduard_Munteanu> Actually I'm a bit worried some people underemphasize the multiuser model of Unix security and go do stupid things.
20:06:16 <FunctorSalad> I'm not quite sure how easy it is for an evil process ran as user to use that ticket
20:06:19 <Eduard_Munteanu> There should be a bit more concern for that.
20:07:08 <Zao> Eduard_Munteanu: Most distros seem to be shooting themselves in the feet quite nicely with HAL and removable media nowadays.
20:07:16 <Zao> Leading people to turn on "permit-all, ffs".
20:07:39 <FunctorSalad> out of frustation of insufficient privileges on mounted media?
20:08:23 <Zao> Out of frustration of not being able to mount media at all, having to elevate constantly to do it, out of frustration of constantly outdated documentation, as frameworks for doing and configuring things change constantly.
20:08:42 <megajosh2> Arch Linux eventually got rid of HAL :D
20:08:52 <Zao> If I got a machine and I had to configure which users may mount USB sticks, I would have _no idea_ where to start.
20:09:22 <Zao> ConsoleKit? Nope, gone. StorageKit? Renamed or mangled, can't remember.
20:09:28 <Zao> Conf location? Changes every month or so.
20:09:49 <megajosh2> Changes every month? On what distro? :/
20:10:02 <Zao> megajosh2: Well, across the field of all distros, I admit.
20:10:25 <megajosh2> Yeah, everybody has their own conventions for stuff like that...
20:11:16 <Eduard_Munteanu> There should really be some configurable policy somewhere between the normal DAC and SELinux MAC.
20:11:35 <Eduard_Munteanu> SELinux is way too "mandatory".
20:12:06 <Eduard_Munteanu> However I suspect we're a long way from that, sandboxing apps and sequestering specific resources seems to be really difficult.
20:13:09 <Maxdamantus> Why can't everything be as simple as seccomp?
20:13:26 <Eduard_Munteanu> Heh, seccomp.
20:13:58 * Eduard_Munteanu imagines Firefox in seccomp :)
20:14:02 <joe1> roconnor: you around?
20:14:08 <roconnor> joe1: yes
20:14:28 <joe1> do you have a minute to check out my code with types?
20:14:37 <roconnor> I will in 7 minutes
20:14:44 <roconnor> ping me again then
20:14:52 <joe1> ok, thanks.
20:18:37 <enthropy> tolkad: http://codepad.org/oXptvHEy
20:19:25 <enthropy> tries both argument orders
20:20:24 <enthropy> not 100% sure it works all the time, but I think so
20:21:28 <enthropy> sort of a lie that it tries both orders: it probably fails horribly when both arguments have the same type
20:21:51 <Eduard_Munteanu> enthropy: wooot!
20:22:45 <Eduard_Munteanu> Insane type sig.
20:23:17 <enthropy> ex. it doesn't know to try flipping     g :: Double -> Int -> String
20:23:35 <enthropy> but   call g 1.3 3  = 4.3
20:23:56 * enthropy should actually test the right function
20:24:45 <enthropy> well g works if one type is concrete
20:28:10 <FunctorSalad> the record of options seemed like a decent alternative idea ;)
20:28:23 <FunctorSalad> (don't remember who said it)
20:28:25 <enthropy> haha, that'd be too easy
20:28:51 <joe1> roconnor: is now a good time?
20:28:56 <roconnor> yes
20:29:19 <joe1> roconnor: please scroll to the bottom: http://hpaste.org/paste/40777/types#p40815
20:31:22 <roconnor> joe1: for is you can just use take 10
20:31:29 <roconnor> > take 10 [1,2,3]
20:31:29 <hsbot>   [1,2,3]
20:31:42 <roconnor> automatically works for short lists
20:32:54 <joe1> roconnor: got it. i was not sure if it would work.
20:34:11 <co_dh> Hi, guys, when ghci display string "\1" , it displayed as "\SOH", how can I make it display as "\1"?
20:34:15 <joe1> roconnor: can you look at it from a high level. i want to improve as a programmer. Just as I went from IO functions to types, I want to go to the next level of programming.
20:37:10 <roconnor> joe1: it's a little unusual to store the Count in your Data
20:38:04 <joe1> roconnor: did not want to keep counting it again, as needed.
20:38:26 <roconnor> joe1: where do you count it?
20:39:06 <joe1> getdata lineno line = (lineno,line,databyteslen line,databytes line)
20:39:16 <roconnor> I mean where do you use this data?
20:39:20 <roconnor> this count
20:40:06 <joe1> in msg2actions, I just pass on the count to Triggerin. Is that what you are looking for?
20:41:28 <roconnor> where else do you use it?
20:41:29 <Eduard_Munteanu> joe1: you might want to look into record syntax instead of using type synonyms to represent the semantics.
20:41:48 <roconnor> Eduard_Munteanu: good point
20:42:18 <joe1> roconnor: other than Triggerin, nowhere, I think.
20:42:29 <joe1> Eduard_Munteanu: cool, will check it out.
20:43:29 <roconnor> joe1: I'd be inclined to leave it out.  The fewer invarients you have the less likely they will be broken.
20:43:41 <roconnor> joe1: but it isn't a bit deal
20:43:43 <roconnor> *big
20:44:10 <Maxdamantus> > let foo (c:t) = if c < 32 || c > 126 then '\' : (show $ fromEnum) ++ foo t c else c : foo t in foo "\1\2\3foobar"
20:44:11 <hsbot>   <no location info>: lexical error in string/character literal at character ' '
20:44:17 <roconnor> joe1: I still wouldn't use sequence_  in triggerin et al.  I'd use do notation
20:44:28 <roconnor> I'm not sure what ksf was on about
20:44:51 <joe1> roconnor: I think you have a point. count is not required for all messages, definitely. will change it.
20:44:51 <Maxdamantus> > let foo (c:t) = if (c < 32 || c > 126) then ('\' : (show $ fromEnum) ++ foo t) else (c : foo t in foo "\1\2\3foobar")
20:44:52 <hsbot>   <no location info>: lexical error in string/character literal at character ' '
20:45:23 <Maxdamantus> > let foo (c:t) = if (c < 32 || c > 126) then ('\' : ((show $ fromEnum c) ++ foo t)) else (c : foo t) in foo "\1\2\3foobar"
20:45:23 <hsbot>   <no location info>: lexical error in string/character literal at character ' '
20:45:26 <Maxdamantus> O_o
20:46:08 <joe1> roconnor: i somehow feel that using do is inferior. maybe I get that feeling due to all the starting troubles I had trying to use do functions all the time.
20:47:02 <roconnor> joe1: using sequence_ on concrete lists doesn't really help anything over do notation
20:48:17 <roconnor> joe1: I think msg2actions can be  made more uniform
20:48:32 <joe1> roconnor: ok.
20:49:18 <joe1> roconnor: i am thinking of removing count from the data definition. I am doing it as we speak, actually.
20:49:28 <roconnor> ok
20:49:44 <roconnor> as simple as possible, but no simpler :)
20:50:48 <roconnor> joe1 it'll take a bit to give more high level advice
20:50:52 <joe1> roconnor: what do you mean? is this program as simple as possible, already?
20:51:03 <roconnor> as I understand the code I can give higher level advice
20:51:07 <roconnor> joe1: nope
20:51:14 <Eduard_Munteanu> joe1: it was a quote
20:51:25 <roconnor> joe1: all haskell code can be cut in half.
20:51:50 <Eduard_Munteanu> Descibing the principle of parsimony, but don't remember who actually said it.
20:52:21 <roconnor> joe1: I think you should get rid of msg2actions special cases for count = 0
20:52:37 <roconnor> joe1: and get rid of BD0 and BD1 data
20:52:55 <roconnor> joe1: and merge triggerin and triggering_buffer
20:53:23 <roconnor> and specialize on count 0 on the merged triggerin/trigger_buffer function
20:53:26 <roconnor> IHMO
20:53:57 <joe1> roconnor: I just removed the count = 0 from msg2actions.
20:54:42 <roconnor> so the new triggerin_buffer would have a special case for when databytes is []
20:54:51 <joe1> yes, that is what i did.
20:54:54 <roconnor> and would just do the old triggerin
20:54:57 <joe1> match on databytes = []
20:55:01 <roconnor> good
20:55:32 <roconnor> and the new triggerin_buffer would do both what the old trigger_in and old triggerin_buffer do now
20:55:37 <roconnor> in the non-null case
20:55:42 <roconnor> joe1: does this make sense?
20:55:42 <joe1> i can remove the BD0 and BD1 data too.
20:55:51 <roconnor> yes
20:55:54 <roconnor> I would do that
20:56:14 <ddarius> There seems to be at least a vague connection between capabilities and parametricity.
20:56:32 <roconnor> ddarius: what are you thinking
20:56:51 <Eduard_Munteanu> About that, I sometimes wonder whether (if possible) it would be wise to annotate function signatures with names, i.e. attaching names to parameters like in other languages.
20:57:03 <Maxdamantus> > '\1' : '\2' : '3' : []
20:57:04 <hsbot>   "\SOH\STX3"
20:57:12 <roconnor> \3
20:57:20 <Eduard_Munteanu> Would give a nice overview in documentation.
20:57:22 <Maxdamantus> > '\12345' : '3' : []
20:57:22 <hsbot>   "\12345\&3"
20:57:51 <roconnor> woa
20:57:53 <megajosh2> What's \& supposed to be
20:57:54 <megajosh2> ?
20:57:59 <Maxdamantus> Nothing, presumably
20:58:02 <roconnor> megajosh2: looks like epsilon
20:58:05 <enthropy> Eduard_Munteanu: type variables can have any name
20:58:21 <Maxdamantus> Because otherwise "\12345" ++ "3" would be "\123453"
20:58:24 <roconnor> > "\&"
20:58:24 <hsbot>   ""
20:58:29 <Maxdamantus> > length "\&"
20:58:29 <hsbot>   0
20:58:30 <enthropy> and you can make sure they end up equal to some concrete type
20:58:32 <dolio> > ['\SO', 'H', '\SOH']
20:58:33 <hsbot>   "\SO\&H\SOH"
20:58:42 <megajosh2> Oh okay...
20:58:46 <Maxdamantus> > '\&'
20:58:47 <hsbot>   <no location info>: lexical error in string/character literal at character '&'
20:58:57 <Eduard_Munteanu> enthropy: well yes, but suppose you had foo :: (Foo a, Bar b) => a -> b -> [b] -> c -> IO Bool
20:59:04 <roconnor> > '\&3'
20:59:05 <hsbot>   <no location info>: lexical error in string/character literal at character '&'
20:59:08 <ddarius> Maxdamantus: There's no reason you'd need \& in a character literal.
20:59:18 <Maxdamantus> I know, was just seeing what'd happen
20:59:22 <Eduard_Munteanu> enthropy: obviously for b and [b] you can't mangle type var names.
20:59:32 <Maxdamantus> Didn't think of the need for a terminator of that until now.
20:59:59 <Eduard_Munteanu> I noticed it makes a lot of difference to look at prototypes in C code for example, and see variable names.
21:00:15 <Eduard_Munteanu> Even in documentation, where the implementation isn't shown.
21:00:28 <Eduard_Munteanu> *good variable names
21:00:29 <enthropy> Eduard_Munteanu: there's conflict between seeing the shape of the expression and having longer variable names
21:00:45 <Eduard_Munteanu> Hm, that's true.
21:00:46 <enthropy> I think having longer class names is enough
21:01:35 <enthropy> and often it's difficult to have a name that's specific enough to be helpful, but not wrong in some cases
21:01:55 <ddarius> roconnor: Consider the object capabilities practitioner's cat.  It would only have authority to read from stdin and write to stdout.  No matter what a malicious cat tried to do, it could only gather information about the "file" bound to stdin and only communicate that information via stdout, which is to say even a malicious cat is almost forced into being an implementation of cat.
21:03:17 <Eduard_Munteanu> enthropy: I see.
21:03:46 <O33> Hi, can anybody direct me towards how to pretty-output in Hugs? I just want pretty-output, not pretty-print but I can print if I need to since it would be a big help. Here is an example of what I'm looking for: http://pastebin.ca/1971478
21:04:35 <Eduard_Munteanu> Though sometimes I wish ill-documented bindings/APIs at least gathered some info in Haddock in terms of sigs like f :: a {- foo -} -> a {- bar -} -> a.
21:04:53 <Eduard_Munteanu> (though that makes sense only with concrete types for FFI stuff)
21:07:21 <tensorpudding> you could write your own pretty printer for lists, it won't be too hard
21:07:39 <tensorpudding> also, hugs is dead
21:08:00 <enthropy> perhaps one on hackage will work too
21:10:21 <tolkad> if you have overlapping instances which one will be chosen?
21:10:49 <enthropy> more specific
21:11:05 <enthropy> did you see this http://codepad.org/oXptvHEy
21:11:34 <enthropy> tolkad: so you can think of overlapping instances as allowing fallback instances
21:11:52 <enthropy> say to show things that would have no instance
21:12:17 <kmc> but "more specific" is wrt the instance head only, not the context
21:12:32 <kmc> «(Eq a) => Foo a» and «(Eq a, Num a) => Foo a» are equally specific
21:12:43 <enthropy> you can work around that
21:13:18 <tolkad> enthropy: nice but a bit over my head :P
21:14:26 <tolkad> kmc: what about Foo (a) and Foo (a -> b)? the second is more specific?
21:14:31 <kmc> yes
21:14:50 <enthropy> in that you write those instances as properly overlapping in, class Foo2 t a, then an instance of Foo in terms of Foo2
21:14:53 <tolkad> hmm, well what about Foo a a and Foo a b?
21:15:05 <tolkad> first is more specific?
21:15:10 <enthropy> yes
21:17:30 <enthropy> tolkad: it doesn't guess and check f a b vs. f b a though
21:19:04 <enthropy> it needs one of the variables given to be concrete
21:19:45 * nejucomo discovers ScopedTypeVariables which solves a common problem he runs across.
21:20:30 <roconnor> nejucomo: usually fiddling with enough undefined where clauses works for me
21:20:32 <enthropy> nejucomo: it's not strictly necessary, but quite a bit prettier than the alternative
21:20:39 <roconnor> not as elegant though
21:20:45 <roconnor> but is Haskell 98
21:21:00 <enthropy> roconnor: and adding unnecessary class methods?
21:21:03 <tolkad> I'm guessing one instance is less specific than another if it can be transformed into the other by applying type constructors to its parameters until they are equivalent?
21:21:46 <nejucomo> enthropy: Yeah, I see the work-arounds on the haskell wiki, but they look like hacks.
21:21:47 <tolkad> and one instance is less specific than another if it can be transformed into the other by splitting a type variable into multiple type variables
21:22:14 <tolkad> are these the only two ways one instance can be less specific than another?
21:22:31 <tolkad> just trying to get a complete understanding
21:22:38 <roconnor> enthropy: I haven't done that
21:22:45 <enthropy> tolkad:    (a,b) is more specific than t
21:22:58 <tolkad> enthropy: tuple is a type constructor
21:23:18 <tolkad> enthropy: t can be transformed into (a,b) by applying the tuple type constructor
21:23:31 <enthropy> tolkad: but you split a type variable ;)
21:23:42 <nejucomo> When a programmer has to do something like asTypeOf (from http://www.haskell.org/haskellwiki/ScopedTypeVariables) that serves as an argument against static typing, IMO.
21:23:53 <tolkad> enthropy: no, I just added a new one
21:24:24 <nejucomo> I'm not trying to troll, but rather keep track of the trade-offs between static typing versus dynamic.
21:24:35 <jmcarthur> i don't see it as a downside for static typing at all
21:24:37 <tolkad> enthropy: think of it as ((\x -> (x, a)) t) ~ (a, b)
21:24:38 <mauke> nejucomo: how do you do asTypeOf with dynamic typing?
21:24:49 <tolkad> err wait
21:24:50 <tolkad> sorry
21:24:56 <tolkad> enthropy: think of it as ((\x -> (x, c)) t) ~ (a, b)
21:25:00 <enthropy> asTypeOf would be useless with dynamic typing
21:25:09 <tolkad> enthropy: although that doesn't make sense.
21:25:22 <roconnor> more like an argument against implicit type arguments
21:25:28 <jmcarthur> enthropy: why?
21:25:33 <tolkad> enthropy: I think my guess is correct but you can see that I am stumbling trying to describe it
21:25:46 <nejucomo> roconnor: Good point.
21:26:13 <enthropy> jmcarthur: because I don't think type information flows from expression to it's context in dynamically typed languages
21:26:22 <tolkad> I guess instances have a different sort of equivalence than ~
21:26:25 <joe1> cannot pattern match to record syntax datatypes, can I?
21:26:33 <mauke> joe1: sure you can
21:26:37 <nejucomo> jmcarthur: Because the whole point of its existence is a hack for the type system.  It says nothing about the runtime computation outside of the types involved.
21:26:39 <mauke> in two ways even
21:27:10 <jmcarthur> nejucomo: i agree that asTypeOf is a hack. i prefer explicit type signatures myself
21:27:21 <enthropy> nejucomo: you change which methods get used by adding constraints on types
21:27:27 <kmc> nejucomo, i would think it serves as an argument for the ScopedTypeVariables extension
21:27:28 <roconnor> lets' be clear, somthing like scopedTypeVariables is a good thing
21:27:29 <mauke> function asTypeOf(x, y) { assert(typeof x == typeof y); return x; }
21:27:44 <roconnor> too bad it isn't in haskell 98
21:27:53 <roconnor> that says more about haskell 98 than anything else
21:28:01 <enthropy> though I think it only changes program behavior (betwen things that 'work') if you have things like overlapping instances
21:28:12 <nejucomo> Yes, I think we all agree that ScopedTypeVariables does the right thing.
21:28:17 <joe1> mauke: would you have an example, please? I am not able to do it.
21:28:40 <tolkad> nejucomo: asTypeOf isn't necessary if you use ~
21:28:42 <mauke> joe1: what's your type?
21:28:43 <kmc> i mean it's a common technique to troll against static types in general by citing particular flaws of particular static type systems
21:28:52 <enthropy> tolkad: ~ is different
21:29:00 <kmc> "Java is verbose, so static types suck"
21:29:14 <copumpkin> you can use ~ for that
21:29:15 <preflex>  copumpkin: you have 1 new message. '/msg preflex messages' to read it.
21:29:25 <jmcarthur> nejucomo: i prefer the pattern:  foo = foo' undefined where foo' :: a -> blahblahblah ; foo' dummy = blahblahblah
21:29:32 <joe1> mauke: this is what I get: Illegal use of punning for field `a' Use -XNamedFieldPuns to permit this. test.hs:24:18: `a' is not a (visible) field of constructor `Adata'
21:29:46 <joe1> data Adata = Adata { model :: String } deriving (Show)
21:29:53 <joe1> testadata1 Adata {a} = putStrLn a
21:30:00 <kmc> Adata {model=a}
21:30:04 <kmc> or (Adata a)
21:30:05 <mauke> testadata1 (Adata a) = putStrLn a
21:30:08 <kmc> the latter case ignores the recordness
21:30:10 <enthropy> or use the namedfieldpuns
21:30:21 * enthropy sort of likes them
21:30:25 <joe1> thanks guys.
21:30:26 <mauke> testadata2 Adata{model = a} = putStrLn a
21:30:44 <enthropy> where you write   Adata{model} = putStrLn model
21:31:02 <joe1> mauke: thanks.
21:31:16 <mauke> testadata3 = putStrLn . model
21:31:43 <nejucomo> kmc: I don't mean to troll, but in considering the flaws of specific type systems, I believe this hints at a broader problem that they are never perfect, and therefore require occasional work-arounds.
21:31:52 <kmc> yeah
21:32:00 <enthropy> > (\x n -> show $ read x `asTypeOf` n) "1.3" 3
21:32:00 <hsbot>   "*Exception: Prelude.read: no parse
21:32:04 <kmc> i'm not saying you're trolling specifically, just that it falls into this pattern
21:32:06 <jmcarthur> i don't see it as a workaround at all
21:32:07 <tolkad> Why do these overlap?
21:32:08 <tolkad> instance Call a b m (b -> a -> m)
21:32:08 <tolkad> instance Call a a m (a -> a -> m)
21:32:13 <kmc> of making tiny things out to be indictments of the whole idea
21:32:15 <tolkad> shouldn't the second be more specific?
21:32:24 <kmc> anyway, yes, type systems are never perfect
21:32:27 <kmc> languages are never perfect
21:32:31 <kmc> nothing anyone has ever made is perfect
21:32:34 <djahandarie> I'm perfect
21:32:35 <jmcarthur> you simply have to provide that type information in order to determine the runtime behavior. in a dynamically typed system you would still have to provide that information explictly in some way
21:32:43 <enthropy> tolkad: they overlap because nobody says  a/=b in the first one
21:32:50 <kmc> dynamically-typed languages have type systems too, which are also imperfect
21:32:52 <mauke> > (\x n -> show $ read x `asTypeOf` n) "1.3" (3 :: Double)
21:32:53 <hsbot>   "1.3"
21:33:22 <tolkad> enthropy: but the second is more specific, shouldn't it be chosen regardless of the overlap?
21:33:41 <enthropy> tolkad: as in the two aren't allowed to coexist with -XOverlappingInstances?
21:33:42 <nejucomo> jmcarthur: It *feels* like a work around to me to define a function that ignores its argument just to make the type system happy, then to pass undefined.  But I'm not fluent in haskell...
21:33:56 <tolkad> enthropy: oh didn't know I had to use an extension
21:34:11 <tolkad> ok that worked
21:34:23 <enthropy> nejucomo: well what do you think of that example by hsbot?
21:34:23 <mauke> tolkad: the code you pasted uses like 3 extensions
21:34:38 <kmc> nejucomo, then you could try a language where type abstraction and type application are explicit
21:34:41 <tolkad> mauke: more! more!
21:34:44 <nejucomo> So when I skimmed the wiki to see "asTypeOf" my initial response, without thinking very hard, was: "What the hell?  That doesn't make sense."  On the other hand when I read about ScopedTypeVariables I immediately thought: "Oh, that makes sense and I know how to use it, and it's clear reading the code what this means in the type system."
21:34:45 <ddarius> Except that this argument is worse than that.  It's more like saying that air bags are an argument against cars versus walking.  While you surely don't need airbags walking (hopefully), it's because you are incapable of going fast enough to need them.
21:35:06 <kmc> in Haskell, they are implicit, so we sometimes need to fake explicit type args by writing explicit value args
21:35:07 <tolkad> mauke: I didn't mean that in a bad way, I just didn't know
21:35:11 <kmc> btw, there's better ways than passing "undefined
21:35:22 <kmc> you can use a type like «data Proxy a = Proxy»
21:35:28 <kmc> and pass (Proxy :: Proxy Foo)
21:35:36 <ddarius> See the tagged package.
21:35:44 <nejucomo> kmc: I do like that approach a bit more.
21:35:44 <tolkad> I wonder why the overlapping instance error message doesn't tell you to turn it on?
21:35:48 <tolkad> anyone know?
21:36:00 <enthropy> tolkad: ghc bug obviously
21:36:02 <kmc> that way, you preserve parametricity, and prevent mistakes from evaluating ⊥
21:36:04 <kmc> haha
21:36:10 <mauke> instance Default (Proxy a) where def = Proxy
21:36:21 <jmcarthur> nejucomo: a little fragment demonstrating my prefered way: http://hpaste.org/40816/alternative_to_scopedtypevaria
21:36:29 <tolkad> enthropy: oh, I'll submit another report
21:36:41 <Eduard_Munteanu> Not all extensions provide feedback like that, another one is -XUnicodeSyntax.
21:36:44 <jmcarthur> it does involved undefined, sure
21:36:53 <Eduard_Munteanu> (at least here)
21:37:00 <jmcarthur> the main problem isn't really how to define the type of a dummy argument
21:37:09 <jmcarthur> the problem is the API requiring a dummy argument in the first place
21:37:15 <jmcarthur> it could be avoided with a nicer witness type
21:37:22 <joe1> Eduard_Munteanu: while moving to the record syntax, just realised that it is a very brilliant idea. Thanks again.
21:37:52 <jmcarthur> this is a pretty nice way to avoid that undefined http://hackage.haskell.org/packages/archive/tagged/0.0/doc/html/Data-Tagged.html#t:Tagged
21:37:53 <jmcarthur> nejucomo: ^^
21:38:00 <Eduard_Munteanu> joe1: no problem.
21:38:08 <jmcarthur> it's just that the API has to accept that instead of a dummy argument
21:38:34 <megajosh2> .let y f = f (y f)
21:38:48 <enthropy> what's the point of Tagged having all those instances?
21:39:13 <enthropy> oh, it actually contains some data
21:39:14 <jmcarthur> oh newer version http://hackage.haskell.org/packages/archive/tagged/0.1.1/doc/html/Data-Tagged.html
21:39:24 <megajosh2> > let y f = f (y f) in y error
21:39:24 <hsbot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
21:39:29 <tolkad> jmcarthur: what an interesting monad instance!
21:39:33 <megajosh2> > fix error
21:39:33 <hsbot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
21:39:34 <mauke> > fix error
21:39:34 <hsbot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
21:39:39 <jmcarthur> yeah it just passes type information along with your actual data
21:39:40 <mauke> so yeah
21:39:41 <megajosh2> Hmm... thought so
21:39:59 <jmcarthur> tolkad: it's just the identity monad, isn't it?
21:40:15 <tolkad> jmcarthur: :P
21:40:28 * nejucomo will have to chew on the Tagged Monad instance someday...
21:40:37 <tolkad> I was kidding
21:40:38 <jmcarthur> tolkad: if you like that you should try the trivial monad!
21:41:00 <jmcarthur> data Trivial a = Trivial
21:41:08 <enthropy> academics love triviality
21:41:16 <mauke> jmcarthur: that's already in there
21:41:24 <mauke> jmcarthur: instance Monad Proxy
21:41:28 <jmcarthur> ha
21:41:33 <jmcarthur> indeed
21:42:48 <tolkad> jmcarthur: not trivial enough. « data Trivial a = Trivial; instance Monad Trivial where { return = Trivial; _ >>= f = Trivial } »
21:43:11 <Eduard_Munteanu> Hm, this evokes a thought: there's no trivial comonad like that.
21:43:12 <tolkad> jmcarthur: not trivial enough. « data Trivial a = Trivial; instance Monad Trivial where { return = Trivial; _ >>= _ = Trivial } »
21:43:27 <jmcarthur> why exactly is it not trivial enough?
21:43:29 <kmc> so are there lazy and strict flavors of the trivial monad?
21:43:39 <enthropy> haha
21:43:41 <jmcarthur> heh
21:43:48 <kmc> also «return = Trivial» does not typecheck
21:43:53 <kmc> return x = Trivial
21:43:59 <tolkad> whoops
21:44:00 <enthropy> Control.Monad.Trivial.Strict
21:44:16 <kmc> «_ >>= f» is equivalent to «_ >>= _» when f is unused
21:44:16 <enthropy>  seq's the first argument to >>=, as that matters
21:44:30 <Eduard_Munteanu> Because coreturn :: w a -> a would only pass as coreturn = undefined
21:44:41 <jmcarthur> newtype Trivial a = Trivial (Trivial a)  -- there, now there's only one valid monad instance
21:44:42 <kmc> i mean that it matters whether you write «Trivial >>= f = Trivial» or «_ >>= f = Trivial»
21:44:45 <kmc> haha
21:45:35 <tolkad> « data Monad m => TrivialT m a = TrivialT; instance Monad m => Monad (TrivialT m) where { return _ = TrivialT; _ >>= _ = TrivialT }; instance MonadTrans Trivial where lift _ = TrivialT; instance MonadIO (Trivial IO) where liftIO = TrivialT »
21:45:49 <tolkad> kmc: haha
21:46:08 <enthropy> data Monad?
21:46:18 <tolkad> can I not put that there?
21:46:23 <jmcarthur> you can but it's silly to
21:46:24 <enthropy> there is a separate namespace?
21:46:33 <jmcarthur> enthropy: look a little further to the right
21:46:36 <jmcarthur> enthropy: there's a => there
21:46:39 <enthropy> oh
21:47:08 <tolkad> jmcarthur: wont it cause the error to happen in a more relevant place if someone tries to put a non-monad in there?
21:47:27 <mauke> tolkad: not really
21:47:41 <jmcarthur> tolkad: is it necessarily an error just because somebody unifies it with something that's not a monad?
21:48:01 <mauke> hmm, does that kindcheck?
21:48:12 <jmcarthur> unifies the m, i mean
21:48:15 <joe1> when i define a record, the fieldname in the record becomes a function that takes the parameter of the record, doesn't it?
21:48:25 <mauke> joe1: yes
21:48:32 <Eduard_Munteanu> joe1: yes, it's called an accessor.
21:48:33 <joe1> due to this, I cannot have a field with the same name in 2 different records?
21:48:43 <Eduard_Munteanu> Yup.
21:48:44 <mauke> right
21:48:47 <nejucomo> How do I ask hsbot for help?
21:48:47 <joe1> i should say record definitions.
21:48:48 <enthropy> in the same module, joe1
21:49:00 <jmcarthur> @commands
21:49:05 <jmcarthur> @list
21:49:09 * jmcarthur shrugs
21:49:09 <ddarius> Eduard_Munteanu: The trivial monad is Const (), the trivial comonad would be Const Void.
21:49:10 <tolkad> jmcarthur: well it's useless
21:49:20 <jmcarthur> tolkad: it's trivial anyway :P
21:49:29 <tolkad> jmcarthur: and as soon as you try to actually use it in a Monad there will be problems
21:49:51 <jmcarthur> tolkad: that's what its concrete type is determined anyway
21:49:56 <ddarius> Eduard_Munteanu: coreturn _ = undefined would essentially be the definition.
21:50:11 <djahandarie> I really wonder what happened to Cale, it's odd for him to disappear for so long
21:50:12 <Eduard_Munteanu> ddarius: ah. But what's with the '()' in the trivial monad definition? It's certainly not needed.
21:50:21 <enthropy> preflex: seen Cale
21:50:22 <preflex>  Cale was last seen on #haskell 3 days, 8 hours, 24 minutes and 2 seconds ago, saying: Applying the function 4 to the value 5
21:50:39 <jmcarthur> actually, () is not really the 1 type
21:50:46 <jmcarthur> since it contains both () and _|_
21:50:47 <ddarius> jmcarthur: Indeed.
21:50:53 <jmcarthur> newtype Unit = Unit Unit
21:50:58 <Eduard_Munteanu> Oh.
21:51:00 <jmcarthur> would be more accurate
21:51:03 <djahandarie> Bottom, always getting in the way
21:51:18 <tolkad> jmcarthur: is that valid haskell?
21:51:20 <enthropy> djahandarie: Kale is a vegetable
21:51:23 <jmcarthur> should be
21:51:28 <tolkad> jmcarthur: oh, I see
21:51:36 <ddarius> jmcarthur: I wasn't going to go into that because what I really would want to say is that the trivial monad is based on the terminal object and the trivial comonad is based on the initial objec.t
21:51:37 <tolkad> jmcarthur: just looked weird for a second
21:51:40 * djahandarie embraces strictness and runs into the sunset
21:52:01 <jmcarthur> ddarius: see, i don't even really think "terminal object" when i see () anymore :\
21:52:15 <Eduard_Munteanu> ddarius: uh, got to go back to Awodey's. I put it away for a while.
21:52:33 <jmcarthur> even though i know it's what people normally mean
21:52:43 <Eduard_Munteanu> But it rings a bell.
21:53:10 <djahandarie> What would Const of a zero object be?
21:53:41 <ddarius> It would be both a monad and a comonad.
21:53:43 <tolkad> jmcarthur: newtype T a where T :: T Unit
21:53:48 <djahandarie> Okay, makes sense
21:53:51 <tolkad> jmcarthur: I remember seeing something like that in a bug report
21:54:06 <jmcarthur> tolkad: you can do that GADT-like syntax with newtypes?
21:54:12 <ddarius> jmcarthur: No.
21:54:14 <Eduard_Munteanu> djahandarie: does that relate to the 1-category, 0-category and so on?
21:54:31 <tolkad> wait that wasn't it... hmm
21:54:32 <Eduard_Munteanu> I'm unfamiliar with that terminology.
21:54:35 <ddarius> Eduard_Munteanu: A zero object is an object that is both initial and terminal.
21:54:42 <djahandarie> Eduard_Munteanu, AFAIK a zero object is just both a terminal and initial object
21:54:54 <Eduard_Munteanu> I see.
21:55:08 <djahandarie> So both of the morphisms exist
21:55:22 <ddarius> Eduard_Munteanu: They tend to arise in categories of algebraic objects, e.g. the trivial vector space is a zero object.
21:56:07 <kmc> T can't be a newtype there, it has zero fields
21:57:09 <jmcarthur> i wish our newtype was generalized to records (including zero fields)
21:57:26 <djahandarie> A trivial monoid would have a zero object right?
21:57:46 <enthropy> jmcarthur: what would that mean for claims of it's representation??
21:58:14 <jmcarthur> enthropy: passing such a newtype around would be operationally equivalent to passing each of its fields around
21:58:15 <tolkad> oh, I found the ticket, it was something different: http://hackage.haskell.org/trac/ghc/ticket/1251
21:58:28 <ddarius> djahandarie: When viewed as a category, yes.  It would be the zero object in the category of monoids.
21:58:49 <jmcarthur> enthropy: and an empty one would simply have no runtime representation
21:59:01 <jmcarthur> none necessary, anyway
21:59:29 <Eduard_Munteanu> Wasn't the monoid category a category with a single object?
21:59:33 <enthropy> what would it mean to return one of those records?
21:59:35 <tolkad> it shows that its possible to create GADTs with impossible data types
21:59:35 <djahandarie> Yes
21:59:47 <Eduard_Munteanu> If so, it won't matter if the monoid itself is trivial or not.
21:59:51 <enthropy> jmcarthur: my understanding is that such a thing would be either a tuple or a continuation...
21:59:55 <jmcarthur> enthropy: it would be like being able to return more than one value
22:00:07 <djahandarie> I'm pretty sure it'd be neither initial or terminal if the monoid is not trivial
22:00:07 <jmcarthur> enthropy: it's just that there isn't a runtime constructor associated with it, is all
22:00:34 <ddarius> djahandarie: That is correct.
22:00:51 <Eduard_Munteanu> Uh, I have to rethink this. :)
22:01:05 <jmcarthur> enthropy: for example, in the C world, it could be like pushing more than one return value (or zero return values) onto the stack
22:01:14 <ddarius> There would patently be more than one arrow from the initial object and to the terminal object.
22:01:23 <jmcarthur> well, in the world of low level assembler i guess
22:01:25 <Eduard_Munteanu> Oh, it's non unique.
22:01:32 <Eduard_Munteanu> Makes sense now.
22:02:16 <jmcarthur> enthropy: it would differ from haskell's current tuples in that pattern matching would always be irrefutable
22:02:16 * Eduard_Munteanu can't wait, TAPL arrives in a couple of days.
22:02:24 <joe1> roconnor: just wanted to thank you for taking the time to go through my program.
22:02:25 <jmcarthur> Eduard_Munteanu: you will like it
22:03:15 <djahandarie> I haven't read TAPL, though I probably should
22:03:52 <jmcarthur> i read Church's Thesis and Functional Programming today. it was good
22:03:54 <jmcarthur> http://www.eis.mdx.ac.uk/staffpages/dat/ctfp.pdf
22:04:33 <jmcarthur> seems like a nice, concise overview of the lambda calculus and type theory so far
22:04:39 <jmcarthur> not very in depth
22:05:03 * Eduard_Munteanu grabs that :)
22:05:21 <jmcarthur> i could argue that it could be good preparation for something like TAPL
22:05:46 <jmcarthur> like a "this is what you are about to jump into" sort of thing
22:06:09 <Eduard_Munteanu> Hm, it's indeed an overview.
22:09:29 <tolkad> if I have data T a where T :: T Int is it possible to create a non-bottom value of T a for some non-Int type a?
22:09:35 <Eduard_Munteanu> Well, considering I went like halfway through an abstract algebra treatise, and some bits of Awodey, this shouldn't be too scary.
22:10:16 <jmcarthur> it's not a scary paper
22:10:18 <jmcarthur> IMO
22:10:22 <jmcarthur> easy read, actually
22:10:25 <dolio> No. There is only one canonical value in the entire T family, and it's T, which has type T Int.
22:10:28 <enthropy> tolkad: T always contains an Int
22:10:42 <Eduard_Munteanu> (though I wasn't patient enough to work my way through to the Abel-Ruffini theorem in there, way too much)
22:10:57 <tolkad> dolio, enthropy: newtype deriving strikes when you least expect it! http://hackage.haskell.org/trac/ghc/ticket/1251
22:11:12 <Eduard_Munteanu> jmcarthur: ah, I was talking about TAPL.
22:11:29 <Eduard_Munteanu> The paper looks okay.
22:11:36 <dolio> tolkad: I've already seen that.
22:11:51 <tolkad> dolio: oh
22:11:52 <jmcarthur> ah, TAPL isn't really scary either
22:12:06 <jmcarthur> just much longer
22:12:16 <dolio> I'm not sure what it has to do with my answer, either, since it's labelled "fixed".
22:12:25 <jmcarthur> especially if you also read ATTAPL
22:12:43 <Eduard_Munteanu> jmcarthur: Advanced Topics in TAPL?
22:12:52 <tolkad> dolio: I think they fixed the crash, not the fact that you can do it
22:12:53 <Eduard_Munteanu> jmcarthur: no, I didn't order that yet.
22:12:54 <enthropy> tolkad: seems to be closed though...
22:13:06 <tolkad> let's try it
22:13:22 <Eduard_Munteanu> jmcarthur: seemed like the natural progression was TAPL -> ATTAPL :)
22:13:55 <Eduard_Munteanu> Uh, misinterpreted your "read", you probably meant present, not past tense.
22:14:05 <tolkad> enthropy, dolio: yeah, you can still do it, they just fixed the crash
22:14:28 <dolio> Anyhow, in Fc, any canonical value of the T family has a type that is equal to T Int.
22:14:39 <tolkad> dolio: not in GHC haskell
22:14:53 <dolio> Well, they should fix it.
22:15:40 <tolkad> no, I like it, it's useful
22:15:57 <dolio> Too bad.
22:16:05 <jmcarthur> i actually meant future tense ;)
22:16:37 <Eduard_Munteanu> Yes, I know.
22:16:49 <tolkad> what would happen if you tried to case expression it 0_o
22:18:13 <dolio> I'm not sure it can ever cause a problem you can notice, since they've fixed it crashing.
22:18:41 <tolkad> it just matches against the II Int constructor
22:18:42 <dolio> Because, not far below surface Haskell, Int and your newtype are identical.
22:18:45 <tolkad> which is just terrible
22:18:49 <tolkad> but whatever :P
22:19:53 <tolkad> it doesn't make sense
22:22:27 <tolkad> I guess I sort of understand it considering that
22:27:22 <tolkad> I guess you're right, you can't do anything bad with it
22:27:48 <codolio> Where'd I leave off there?
22:28:16 <tolkad> besides mess someone up who was relying on type classes instead of pattern matching to do something with a GADT
22:28:33 <tolkad> which is kind of bad afterall
22:28:46 <dolio> http://hpaste.org/40817/unsafe_coercing in case it didn't send before.
22:29:02 <tolkad> dolio: it didn't
22:29:53 <dolio> Anyhow, that will let you read random garbage out of memory wherever the pointer to () happens to be in any particular run of the program.
22:30:27 <tolkad> dolio: haha
22:30:38 <tolkad> dolio: nice, I didn't think of using type families
22:31:00 <tolkad> dolio: show #ghc maybe?
22:31:21 <tolkad> idk, I just want to see what they will say
22:31:22 <dolio> It seems like they should know about that already. I'll look at bugs.
22:31:37 <dolio> It can't be the first time I've written that down, even.
22:33:17 <dolio> You don't have 7.0 on hand, do you? It'd be interesting to know if it works there, too.
22:33:59 <tolkad> no
22:34:37 <Saizan> there's a ticket on ghc's trac for http://hpaste.org/40817/unsafe_coercing
22:35:21 <bblum> hey guys, i hear ocaml supports "disjunctive pattern matching" - like case foo of (Thing1 | Thing2 | ....) - does haskell let you do this? if not, why not?
22:35:38 <dolio> No one's implemented it.
22:35:59 <bblum> heh
22:36:00 <Saizan> http://hackage.haskell.org/trac/ghc/ticket/1496
22:37:08 <markspezzano> I've _almost_ got Leksah up and running. It tries to do a link: Linking dist/build/leksah-server/leksah-server ... and then times-out. I tried installing it from the .dmg file but the Leksah-bin window is displayed and then it pauses and vanishes. Can someone tell me what's going on? I think I've managed to install all of the prerequisites needed like gtk2hs and gtksourceview2 etc
22:37:23 <dolio> Ah, right.
22:38:45 <dolio> I think that was the bug I was originally thinking of, too.
22:39:30 <djahandarie> Yikes, that's an old bug
22:41:06 <dolio> The other one I hadn't thought of, but it's the same principle.
22:41:24 <markspezzano> BTW: I'm running GHC 6.12.3
22:42:11 <Saizan> markspezzano: linking can take a lot of memory
22:42:14 <dolio> The GADT version should allow you to get a (Newtype ~ Oldtype) constraint into the Haskell level.
22:42:44 <dolio> Which is presumably undesirable, because the whole point is that they aren't equal.
22:43:11 <djahandarie> How do add yourself as a cc on a ticket?
22:44:01 <djahandarie> I see a "Add to cc" checkbox, but there is also a lot of dangerous looking stuff surrounding it lol
22:44:43 <markspezzano> really? How do I fix this?
22:45:40 <Saizan> give it enough? it should be less than 1GB though
22:46:54 <Saizan> at least, i've never seen it take more
22:47:21 <Saizan> thoigh i'm not so sure about what you mean by "times-out"
22:47:52 <markspezzano> it waits for a while and then gives up.
22:48:29 <markspezzano> I also have a bunch of warning message that read like this: ld: warning: in /opt/local/lib/libiconv.dylib, file was built for unsupported file format which is not the architecture being linked (i386)
22:51:31 <Saizan> that sounds bad, but i don't know how to solve it
22:51:44 <markspezzano> alright, thanks anyway.
22:52:59 <ddarius> dolio: See http://www.cis.upenn.edu/~sweirich/newtypes.pdf if you haven't already.
23:02:46 <dolio> ddarius: Ah, interesting.
23:23:09 <tolkad> what's "arity"?
23:23:45 <tolkad> nevermind
23:35:04 <razvandimescu> haha
23:35:06 <razvandimescu> ghci> filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"  "GAYBALLS"
23:35:36 <razvandimescu> hsbot: > filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"
23:35:57 <Nibble> razvandimescu: coincidence?
23:36:00 <Nibble> YOU DECIDE
23:36:19 <Nibble> razvandimescu: protip: use isUpper
23:36:39 <Nibble> > filter (isUpper) "i lauGh At You BecAuse u r aLL the Same"
23:36:39 <hsbot>   "GAYBALLS"
23:36:48 <Jonno_FTW> >:3
23:36:54 <razvandimescu> =)) cool stuff
23:36:59 <Nibble> razvandimescu: indeed
23:37:11 <ddarius> Now don't use completely superfluous parentheses.
23:37:39 <Nibble> ddarius: oh right
23:37:49 <Jonno_FTW> how do I avoid succ Ace returning an error where: 
23:37:50 <Nibble> > (filter (isUpper) (("i lauGh At You BecAuse u r aLL the Same")))
23:37:50 <hsbot>   "GAYBALLS"
23:37:51 <Jonno_FTW> "9C JD 7C 6D TC 6H 6C JC 3D 3S\r"
23:38:01 <Jonno_FTW> wait
23:38:07 <Jonno_FTW> where the data is this: 
23:38:11 <Jonno_FTW> data Value = Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten | Jack | Queen | King | Ace deriving (Ord, Show, Eq, Enum)
23:38:57 <Jonno_FTW> since Two comes after Ace
23:39:02 <ClaudiusMaximus> write your own instance instead of deriving one, perhaps
23:39:54 <maurer_> Note that "succ" wrapping around goes against semantics if I remember correctly...
23:41:09 <Veinor> yeah
23:41:46 <Jonno_FTW> but how would I handle a straight flush of 5 4 3 2 Ace
23:41:55 <Nibble> Jonno_FTW: you don't.
23:42:16 <Jonno_FTW> :O
23:46:34 <Gracenotes> you can make two aces
23:46:49 <Gracenotes> which would be painful in so many other ways
23:46:53 <maurer_> However, I don't _think_ it would break anything to violate the succ restriction, just semantics
23:47:13 <Gracenotes> I forget, is 3 2 Ace K Q a flush? dunthinkso
23:48:13 <injection> it is if they are in the same suit
23:48:16 <Jonno_FTW> according ti wikipedia you can have A 2 3 4 5
23:48:21 <tolkad> haskell could learn a thing or two from intercal
23:48:38 <tolkad> like not just failing to compile whenever it encounters a little error
23:48:49 <tolkad> I mean seriously just deal with it. I don't care
23:48:52 <Jonno_FTW> but that's the best part of haskell
23:48:54 <Gracenotes> well yeah that is the requisite flush condition
23:49:05 <Jonno_FTW> you don't get unexpected behaviour
23:51:09 <Jonno_FTW> is doing data Value = Two | Three ... | King | Ace | Value reasonable?
23:51:38 <Veinor> @quote endofunctor
23:51:46 <Veinor> bah
23:52:14 <tolkad> dolio: I can't figure out a way to write a general unsafeCoerce :: a -> b : (
23:52:35 <Veinor> unsafeCoerce = undefined
23:52:37 <Veinor> bam
23:53:14 <tolkad> Veinor: <dolio> http://hpaste.org/40817/unsafe_coercing
23:55:35 <Gracenotes> I think you can use iorefs. with a restriction-removing extension or two.
23:56:46 <tolkad> only with unsafePerformIO
23:57:28 <tolkad> Gracenotes: dolio found a way to do it from a specific type to any other, but not a way to have a general function a -> b
