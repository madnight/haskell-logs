00:00:46 <d34df00d> Hm, but since I return tuples anyway, wouldn't it be nicer to use parTuple-family of functions?
00:01:42 <blackh> d34df00d: Simon Marlow did a paper on the new design. It's very readable, and tells you about how to use it in an applicative and monadic style, which are very convenient.  Or you can do it the straightforward way (similar to how Real World Haskell describes it).
00:03:48 <blackh> Yeah, parTuple sounds like what you want, e.g. (xs, ys) `using` parTuple rdeepseq rdeepseq (to evaluate xs and ys in parallel).
00:04:40 <d34df00d> Great.
00:04:44 <d34df00d> Thank you a lot.
00:04:51 <blackh> d34df00d: If you are testing your success by measuring execution speed, use the newest GHC and use the +RTS -S option to measure the times.
00:05:04 <blackh> It's helpful to look at the GC time vs. mutator time.
00:05:35 <blackh> Simon Marlow has done a lot of work on parallel performance recently.
00:06:00 <d34df00d> Btw, GC times are quite high in my case — the core of the algorithm I need to implement rewrites a map a lot of times, which leads to lots of copying.
00:06:07 <d34df00d> Thanks, I'd read that paper.
00:06:41 <blackh> It's fairly normal for GC times to be high in Haskell programs.
00:07:08 <blackh> That's why the parallel garbage collector is so important.  There's more work planned on that in future.
00:07:51 <blackh> 50% gc time is fairly typical.
00:08:07 <dolio> Really?
00:08:52 <blackh> For real programs, I think that's reasonable (as opposed to benchmarks).
00:09:48 <dolio> I wouldn't have guessed it'd be that high, but I guess a lot of the stuff I've bothered checking the performance of is biased against GC usage.
00:23:34 * hackagebot hmatrix-special 0.1.1 - Interface to GSL special functions  http://hackage.haskell.org/package/hmatrix-special-0.1.1 (AlbertoRuiz)
00:26:29 <SubStack> awesome, matrix stuff
00:26:53 <SubStack> I wrote some crappy extensions to hmatrix for some opengl simulations one time
00:30:38 <d34df00d> Oh, things got slower almost 2 times.
00:30:40 <d34df00d> Interesting.
00:31:34 <blackh> d34df00d: There are lots of reasons.  The learning curve for this stuff is reasonably big.
00:32:42 <d34df00d> Well, I can hardly imagine why it would behave in such a way.
00:32:59 <blackh> Examples: Sometimes your deepseq becomes expensive - for example, if it's a list of strings, deepseq will visit every character.
00:33:14 <blackh> Did gc time increase, or mutator time?
00:34:18 <blackh> How many CPU cores do you have, and what ghc version are you using?
00:35:02 <d34df00d> blackh: 2 cores, GHC 6.12.3.
00:35:43 <d34df00d> About times — well, I need to perform the original run, without parallelism, seems like I lost the numbers from that.
00:35:45 <blackh> Well, the overhead of doing things in parallel is significant. You don't get much advantage on 2 cores.  Also, many improvements are in GHC 7.0.
00:36:12 <mjrosenb> 7.0
00:36:14 <mjrosenb> wow
00:36:27 <mjrosenb> it has been at version 6 for as long as i can remember
00:37:21 <d34df00d> There is 7.0.0.20100924 in my OS repos, nice.
00:38:17 <blackh> d34df00d: Also, you need to give some consideration to spark granularity.
00:38:52 <blackh> GHC's sparks are very efficient, but not efficient to give you any advantage if it's just a single add, for example.
00:39:32 <Unforgivable^> im currently working on something to filter this: "(one) (two two)" into "one (two two)", => all entries where ( ) are around them with just one word in they need to be removed. Also "( one ) (two two)" should work to "one (two two)", is that possible to do at an easy way?
00:41:00 <blackh> d34df00d: Going afk for a while.  Good luck!
00:41:56 <Saizan> Unforgivable^: you could scan the String keeping a count of the number of tokens you've seen since the last ( and if it's 1 when you get to the next ) you can drop it
00:41:59 <d34df00d> Thanks!
00:42:13 <Unforgivable^> hm
00:42:25 <Saizan> and i guess you can normalize whitespace in the process
00:42:38 <Unforgivable^> but then you need to check for words I think?
00:42:46 <Unforgivable^> when you got (one), its o + n + e
00:42:52 <Unforgivable^> when you do char for char
00:43:17 <Saizan> counting the number of tokens involves spotting word boundaries, yep
00:44:11 <Saizan> in fact, it's probably best to write a lexing function that does the splitting an produces a list of tokens including parens
00:44:12 <d34df00d> Here are the results of -sstderr, anyway: http://pastebin.com/RNsdwqXL
00:44:18 <Saizan> e.g. lex advantage if it's just a single add, for example.
00:44:25 <d34df00d> First one is without anything explicit with par/pseq, the second one is.
00:44:55 <Unforgivable^> never heard of lexing
00:45:28 <Saizan> e.g. lex "(one) (two two)" == [Open, Symbol "one", Close, Open, Symbol "two", Symbol "two", Close]
00:46:28 <Saizan> Unforgivable^: a lexer is a program that does this sort of things, in parsing terminlogy
00:46:41 <Samantha> :Botje is not here tonight
00:46:42 <Samantha> ?
00:46:45 <Saizan> > lex "(one) (two two)"
00:46:46 <lambdabot>   [("(","one) (two two)")]
00:47:13 <Unforgivable^> hm
00:47:24 <Saizan> "lex" is the default haskell lexer used for the Read class, which splits only one token out of the String
00:48:10 <Unforgivable^> hm
00:48:14 <mjrosenb>  let tokenize1 = filter (\x -> not . isSpace . head $ x) . groupBy (equiv [varchar, inchar]) where equiv (h:t) x y = x `elem` h && y `elem` h || equiv t x y; equiv _ _ _ = False; inchar="!@#$%^&*-+><:="; varchar=['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] ++ "_'"
00:48:17 <Unforgivable^> but it does split entries as a string?
00:48:31 * mjrosenb wrote that a while ago
00:48:42 <Unforgivable^> wow
00:48:59 <Unforgivable^> what does that exactly mjrosenb?
00:50:32 <mjrosenb> Unforgivable^: try it on your example.
00:50:51 <mjrosenb> it comes suprisingly close to what i wanted it to do
00:51:13 <mjrosenb> then i realized that i wanted the string "\"hello world\"" to be a single token
00:51:18 <mjrosenb> and i cried for a while.
00:52:00 <Unforgivable^> what does the ` around the `elem` do
00:52:15 <mjrosenb> it makes the identifier infix for that usage
00:52:32 <Unforgivable^> aha
00:52:32 <mjrosenb> the opposite of ()
00:53:07 * mjrosenb has occasionally found himself writing (`foo` bar)
00:53:50 <Unforgivable^> what is the input of the tokenize?
00:54:15 <Unforgivable^> im trying to get it working but winhugs gives me an error (unexpected `}'
00:54:57 <mjrosenb> err, thirer isn't a '}' in the entire line
00:55:02 <Unforgivable^> i know
00:55:24 <mjrosenb> > let tokenize1 = filter (\x -> not . isSpace . head $ x) . groupBy (equiv [varchar, inchar]) where equiv (h:t) x y = x `elem` h && y `elem` h || equiv t x y; equiv _ _ _ = False; inchar="!@#$%^&*-+><:="; varchar=['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] ++ "_'" in tokenizer1 "(one) (two two)"
00:55:25 <lambdabot>   Not in scope: `tokenizer1'
00:55:31 <mjrosenb> > let tokenize1 = filter (\x -> not . isSpace . head $ x) . groupBy (equiv [varchar, inchar]) where equiv (h:t) x y = x `elem` h && y `elem` h || equiv t x y; equiv _ _ _ = False; inchar="!@#$%^&*-+><:="; varchar=['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] ++ "_'" in tokenize1 "(one) (two two)"
00:55:33 <lambdabot>   ["(","one",")","(","two","two",")"]
00:55:55 <Jafet> > let f ∫ x = flip f x in (const∫undefined) 5
00:55:56 <lambdabot>   5
00:56:19 <Jafet> Hmm no, that doesn't look mnemonic.
00:56:47 <mjrosenb> Jafet: why is there unicode in your.... why is that infix?
00:57:38 <Unforgivable^> hm getting a different error now mjrosenb lol
00:57:38 <Unforgivable^> *** Type : String -> [[Char]]
00:57:38 <Unforgivable^> *** Does not match : String -> String
00:57:44 <Unforgivable^> oh nvm
00:57:47 <Unforgivable^> my fault :D
00:57:48 <Jafet> Apparently, 222B INTEGRAL is a MATH SYMBOL.
00:57:56 <Jafet> And looks vaguely like flip.
00:58:11 <mjrosenb> Jafet: what does flip look like?
00:58:23 <mjrosenb> Jafet: or just a styalized f?
00:58:34 <mjrosenb> *stylized?
00:59:16 <Jafet> Well, in writing people draw a line like that to flip words around
01:00:31 <Jafet> > let x ∫ f = f x; infixr 0 ∫; in 1 + 2 ∫ succ
01:00:33 <lambdabot>   4
01:01:31 <Unforgivable^> mjrosenb
01:01:35 <Unforgivable^> got it working
01:01:36 <Jafet> @hoogle a -> (a -> b) -> b
01:01:37 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
01:01:37 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
01:01:37 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
01:01:39 <Unforgivable^> seems to do just what I need :)
01:01:42 <Unforgivable^> much appreciated!
01:01:49 <Jafet> Eh, I thought it'd exist.
01:02:35 <mjrosenb> Unforgivable^: i suspect it does a whole lot more
01:03:52 <Unforgivable^> yeah, the spaces are missing now but I wasnt needing them anyway
01:03:59 <Unforgivable^> so it seems like a pretty good deal to me :)
01:05:49 <Unforgivable^> but the infix -> x `elem` h can also be written als elem x h?
01:05:55 <Unforgivable^> or am I wrong about that :)
01:06:38 <Saizan> it can
01:06:59 <Jafet> Now we have you, kraut
01:15:54 <Unforgivable^> isSpace " "
01:16:02 <Unforgivable^> how does that lambdabot work?
01:16:11 <Unforgivable^> @isSpace " "
01:16:11 <lambdabot> Unknown command, try @list
01:16:17 <Unforgivable^> @list
01:16:17 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
01:16:20 <silver> > show "hi"
01:16:21 <lambdabot>   "\"hi\""
01:18:11 <RayNbow`TU> > text . show $ "hi"
01:18:13 <lambdabot>   "hi"
01:19:10 <Unforgivable^> hm
01:19:24 <Unforgivable^> show isSpace " "
01:19:33 <Unforgivable^> why is my stuff not working :(
01:19:37 <silver> > 
01:19:38 <Unforgivable^> show "why"
01:19:39 <lambdabot>   not an expression: `'
01:19:44 <silver> use ">"
01:19:55 <Unforgivable^> how?
01:20:00 <silver> just type it lol
01:20:05 <Unforgivable^> >
01:20:09 <silver> in the beggining of the string
01:20:20 <silver> > isSpace " "
01:20:22 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
01:20:22 <lambdabot>         against inferred type...
01:20:30 <Unforgivable^> oh i see
01:20:33 <Unforgivable^> isSpace ' '
01:20:35 <Unforgivable^> >isSpace ' '
01:20:37 <Unforgivable^> xD
01:20:42 <Unforgivable^> > isSpace ' '
01:20:43 <lambdabot>   True
01:20:47 <Unforgivable^> yey
01:20:48 <silver> woo :)
01:20:48 <Unforgivable^> finally :p
01:20:50 <Unforgivable^> ty
01:20:55 <Unforgivable^> > notSpace ' '
01:20:56 <lambdabot>   Not in scope: `notSpace'
01:21:09 <nlogax> > (not . isSpace) ' '
01:21:10 <lambdabot>   False
01:21:23 <silver> also you can search for stuff using @hoogle
01:21:28 <nlogax> isSpacen't = not . isSpace :)
01:21:40 <silver> @hoogle Char -> Bool
01:21:40 <lambdabot> Network.URI isAllowedInURI :: Char -> Bool
01:21:40 <lambdabot> Data.Char isAlpha :: Char -> Bool
01:21:41 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
01:23:09 <silver> http://www.haskell.org/hoogle/
01:41:41 <Qbyt> join #nodejs
01:41:44 <Qbyt> exit
01:57:27 <Unforgivable^> mjrosenb
01:57:35 <Unforgivable^> i was looking into your function
01:57:41 <Unforgivable^> but where does it get the input from exactly?
01:57:48 <Unforgivable^> i currently have this
01:57:52 <Unforgivable^> test :: String -> [String]
01:57:52 <Unforgivable^> test xs = let tokenize1 = filter (\x -> not . isSpace . head $ x) . groupBy (equiv [varchar, inchar]) where equiv (h:t) x y = x `elem` h && y `elem` h || equiv t x y; equiv _ _ _ = False; inchar="!@#$%^&*-+><:="; varchar=['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] ++ "_'" in tokenize1 xs
01:57:57 <Unforgivable^> so xs is the input
01:57:57 <Samantha> Can someone tell me how to test scanl1
01:58:00 <Samantha> ??
01:58:03 <Unforgivable^> but how and where is the input returned in the tokenize1
01:58:07 <Unforgivable^> and which variables there use that
01:58:13 <mjrosenb> Unforgivable^: it is called eta conversion
01:58:24 <Unforgivable^> eta conversion?
01:58:37 <Samantha> mjrosenb :Can someone tell me how to test scanl1
01:58:47 <mjrosenb> Unforgivable^: (\x -> f x) is equivalent to f
01:58:57 <Unforgivable^> yes
01:59:01 <Unforgivable^> i understand
01:59:01 <Samantha> how to test it
01:59:26 <Unforgivable^> but I dont understand where the xs is being used
01:59:36 <Unforgivable^> nor where groupBy gets its array from
01:59:39 <sipa_> at the end
01:59:39 <Unforgivable^> there is a condition and array
01:59:44 <Unforgivable^> but I don't see the input
01:59:48 <sipa_> tokenize1 is a function
01:59:58 <Samantha> Can someone tell me how to test scanl1
02:00:01 <Samantha> ?????
02:00:04 <Samantha> Can someone tell me how to test scanl1 ????
02:00:07 <sipa_> Samantha: elaborate
02:00:14 <sipa_> how do you want to test it
02:00:15 <Unforgivable^> <sipa_> tokenize1 is a function
02:00:16 <Unforgivable^> yes
02:00:22 <Unforgivable^> but there is let tokenize1 =
02:00:26 <sipa_> yes
02:00:27 <Unforgivable^> so no input as far as Im aware
02:00:33 <Samantha> this give an error message Prelude> scanl1 [1,2,3]
02:00:37 <Unforgivable^> so I dont understand where the xs is being used
02:00:43 <sipa_> Unforgivable^: let x = bla in foo
02:00:54 <sipa_> is identical to let x arg = bla arg in foo
02:01:00 <Samantha>  Couldn't match expected type `a -> a -> a'
02:01:08 <sipa_> :t scanl1
02:01:09 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
02:01:15 <Samantha> yes
02:01:20 <Samantha> How to tested
02:01:24 <Unforgivable^> i see
02:01:30 <sipa_> Samantha: i don't understand your question
02:01:42 <Unforgivable^> so would it be possible to rewrite the function than to have an argument there?
02:01:47 <sipa_> yes
02:01:49 <Samantha> Ok I want to run the function scanl1 
02:01:49 <Unforgivable^> like let tokenize inp = filter
02:01:50 <mjrosenb> Unforgivable^: right, let foo = bar baz is equivalent ot let foo x = bar baz x
02:02:23 <Samantha> Ok I want to run the function scanl1  in  the shell
02:02:28 <Samantha> how to do it
02:02:33 <Samantha> ?
02:02:44 <sipa_> Samantha: well what do you want it to do?
02:03:03 <sipa_> Unforgivable^: let tokenize1 = bla bli blu in tokenize1 xs
02:03:07 <Samantha> like this
02:03:24 <Samantha> Prelude> scanl1 [1,2,3]  
02:03:27 <sipa_> is equal to: let tokenize1 x = (bla bli blu) x in tokenize1 xs
02:03:31 <Unforgivable^> sipa_ but that would require to put the arguments also in the tokenize1 i tihnk?
02:03:35 <Samantha> this input is not valid why?
02:04:05 * hackagebot network 2.2.1.9 - Networking-related facilities  http://hackage.haskell.org/package/network-2.2.1.9 (JohanTibell)
02:04:05 <Cale> Samantha: scanl1 takes a function of two parameters, and a list
02:04:10 <Cale> > scanl1 (+) [1,2,3]
02:04:12 <lambdabot>   [1,3,6]
02:04:13 <Samantha> how
02:04:15 <Cale> > scanl1 (*) [1,2,3]
02:04:16 <lambdabot>   [1,2,6]
02:04:21 <Cale> > scanl1 (*) [1,2,3,4,5]
02:04:22 <lambdabot>   [1,2,6,24,120]
02:04:24 <Samantha> thank you
02:04:25 <Cale> > scanl1 (+) [1,2,3,4,5]
02:04:28 <lambdabot>   [1,3,6,10,15]
02:04:40 <sipa_> > scanl1 (*(-2)) [1..]
02:04:41 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
02:04:50 <Samantha> Got it
02:04:56 <Samantha> thank you Cale
02:04:59 <Unforgivable^> so when I want lets say
02:05:02 <Cale> No problem
02:05:07 <Unforgivable^> let tokenize1 xs
02:05:13 <Unforgivable^> where should I place the xs
02:05:20 <sipa_> 11:02:39 < sipa_> Unforgivable^: let tokenize1 = bla bli blu in tokenize1 xs
02:05:23 <sipa_> 11:03:03 < sipa_> is equal to: let tokenize1 x = (bla bli blu) x in tokenize1 xs
02:05:56 <Samantha> Cale:
02:06:04 <Samantha> do you have the definition
02:06:09 <Cale> of scanl1?
02:06:12 <Samantha> for scanl1
02:06:15 <Samantha> yeas
02:06:17 <Cale> @src scanl1
02:06:17 <Samantha> yes
02:06:18 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
02:06:18 <lambdabot> scanl1 _ []     =  []
02:06:22 <Cale> @src scanl
02:06:23 <lambdabot> scanl f q ls = q : case ls of
02:06:23 <lambdabot>     []   -> []
02:06:23 <lambdabot>     x:xs -> scanl f (f q x) xs
02:06:33 <Unforgivable^> <sipa_> 11:02:39 < sipa_> Unforgivable^: let tokenize1 = bla bli blu in tokenize1 xs
02:06:33 <Unforgivable^> <sipa_> 11:03:03 < sipa_> is equal to: let tokenize1 x = (bla bli blu) x in tokenize1 xs
02:06:48 <Unforgivable^> yeah, but then you have (bla bli blu) between ( )
02:06:52 <sipa_> yes
02:07:01 <Unforgivable^> id rather have it for readability in the function itselves
02:07:11 <mjrosenb> Unforgivable^: you say that now....
02:07:12 <Unforgivable^> and as far as Im aware the only thing using it is the groupBy
02:07:43 <Unforgivable^> is it possible to place the x between the lines
02:07:46 <sipa_> Unforgivable^: you can reason further
02:08:18 <sipa_> i was wrong by the way, since inside the bla bli blu of tokenize1, there is a 'where' definition
02:08:32 <Unforgivable^> yeah it should be before the where
02:08:35 <Unforgivable^> I got that working
02:08:36 <sipa_> indeed
02:08:42 <Unforgivable^> thats no problem, thanks :)
02:08:45 <sipa_> now there's another rule
02:08:50 <Unforgivable^> but what if I want the function between the lines :)
02:09:02 <Unforgivable^> (filter (\x -> not . isSpace . head $ x) . groupBy (equiv [varchar, inchar])) bs
02:09:06 <Unforgivable^> thats what I got right now
02:09:23 <sipa_> (a b c . d e f) x = a b c (d e f x) = a b c $ d e f x
02:09:27 <Twey> (\x -> foo $ x) === foo
02:09:56 <sipa_> Unforgivable^: you know the definition of . and $ ?
02:10:04 <Unforgivable^> yes
02:10:14 <cathper> Twey: Except it's anonymous ;-)
02:10:16 <sipa_> so, you can work out what it's equal to
02:10:58 <Twey> cathper: Hm?  Both are anonymous.
02:11:01 <Unforgivable^> yes, got it working :)
02:11:07 <Unforgivable^> much appreciated everyone!
02:11:11 <Unforgivable^> great channel this <3
02:12:50 <cathper> Twey: Uhm, foo has a name, thus, not anonymous; the function on the left-hand side does not have a name, thus, anonymous.
02:13:06 <Samantha> Sipa: I having an error message
02:13:19 <sipa_> Samantha: show me the code
02:13:26 <Twey> cathper: Oh, I see what you mean.  Well, in this case ‘foo’ was not a single name but a composition of other functions.  ☺
02:13:45 <Samantha> Where
02:13:47 <Samantha> ?
02:13:51 <Samantha> Where?
02:14:01 <sipa_> hpaste.org
02:14:02 <cathper> Twey: Ahh, I see :-)
02:14:22 <Samantha> The website cannot display the page
02:14:31 <Samantha> hpaste.org
02:14:38 <sipa_> it's down, so use pastebin.org
02:15:07 <Unforgivable^> pastebin.com is working 99% of the time :)
02:15:07 <Samantha> dne
02:15:09 <Samantha> done
02:15:14 <Samantha> can you see it
02:15:34 <Samantha> Sipa: can you see it
02:15:45 <sipa_> no, you have to give me the url :)
02:15:54 <Saizan> Samantha: you should copy the url from the address bar and paste it here
02:16:02 <Samantha> this http://pastebin.org/330913
02:16:21 <Samantha> i did
02:16:26 <sipa_> i think you forgot some equals signs
02:16:46 <sipa_> for mapReduce, reduceFn and turnAroundFn
02:16:50 <Samantha> this is the error message
02:17:03 <Samantha>  Couldn't match expected type `a -> ([a] -> [a]) -> [a] -> [a]'
02:17:08 <sipa_> yes
02:17:19 <Samantha> no mapreduce cant be change
02:17:29 <sipa_> you don't even define mapreduce
02:17:41 <Samantha> the proff did it
02:17:48 <Samantha> I just need to use it
02:17:54 <sipa_> are you sure you copied it correctly?
02:17:58 <Samantha> yes
02:18:07 <sipa_> are you sure you even had to copy it?
02:18:15 <Samantha> yes
02:18:21 <Samantha> I am positive
02:18:45 <Twey> This is not valid Haskell code
02:18:46 <sipa_> are you sure it's not an example of how you're supposed to use it?
02:19:07 <Samantha> No 
02:19:09 <Twey> And perhaps the names at the top are listings of functions you can use.
02:19:12 <Samantha> check this 
02:19:17 <ajnsit> Hi all
02:19:27 <ajnsit> I have a problem with cabal install
02:19:27 <Samantha> I create this yesterday
02:19:29 <Samantha> http://pastebin.org/330915
02:19:32 <ajnsit> tmp is mounted no exec
02:19:39 <Samantha> I use mapreduce in foldr'
02:19:47 <ajnsit> and it is causing install of unix-compat to fail
02:20:18 <Samantha> sipa: can you see it
02:20:19 <sipa_> Samantha: you'd still need an equals sign at the end of line 1
02:20:24 <Samantha> no
02:20:31 <Samantha> it compiles correctly
02:20:36 <Samantha> with the foldr'
02:20:44 <sipa_> apologies
02:20:46 <sipa_> i misread
02:21:04 <Samantha> ok http://pastebin.org/330917
02:21:12 <sipa_> but then use that mapReduce function instead of the line mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn 
02:21:21 <sipa_> that doesn't say anything
02:21:32 <sipa_> it's a function call, but it's not used
02:22:09 <Samantha> ok here you go http://pastebin.org/330918
02:22:17 <Samantha> it works with foldr'
02:22:28 <Twey> foldr' f p = mapReduce head tail null p f, by the way
02:22:30 <Samantha> yeah I need to follow the format for mapreduce
02:23:19 <Twey> You don't have a ‘p’ in your ‘test’, but you do in your ‘foldr'’
02:23:27 <Samantha> Why it works with foldr' but not for scanl1
02:23:35 <Samantha> because test is for scanl1
02:23:36 <Twey> Also, did you mean ‘(\xs -> p xs)’?
02:23:44 <Twey> That's not the point
02:23:54 <Twey> You can't pass completely different arguments to a function on a whim
02:24:03 <Twey> It has a specific type
02:24:16 <Samantha> and scanl1 only takes a list and function
02:24:28 <Samantha> Sipa: Can you see it now
02:24:42 <sipa_> yes
02:24:46 <sipa_> Samantha: foldr and scanl1' have difference types
02:24:51 <Twey> Samantha: But you're not calling scanl1, you're calling mapReduce
02:24:57 <sipa_> and remove line 1
02:25:05 <Twey> And mapReduce needs all those arguments (presumably)
02:25:10 <Samantha> which line 1
02:25:18 <sipa_> the one here: http://pastebin.org/330918
02:26:15 <Samantha> Here you go http://pastebin.org/330921
02:26:25 <Samantha> why am I getting an error message 
02:26:27 <sipa_> no
02:26:30 <sipa_> remove line 1
02:26:32 <sipa_> not line 2
02:26:43 <Samantha> I need it
02:26:46 <sipa_> you don't
02:26:51 <sipa_> it's not valid code
02:26:57 <Samantha> Oh my god
02:27:04 <sipa_> replace it with the real definition of mapReduce
02:27:07 <Samantha> oh course it is
02:27:16 <Samantha> I can not change mapreduce
02:27:20 <Samantha> at all
02:27:25 <sipa_> i don't tell you to change mapreduce
02:27:29 <sipa_> i tell you to use it
02:27:29 <Twey> >.>
02:27:33 <sipa_> instead of that line
02:27:38 <Twey> Samantha: You should read some of http://learnyouahaskell.com/ to get the basics of Haskell.
02:27:42 <Samantha> which line
02:28:08 <Samantha> :Sipa which line
02:28:46 <Samantha> :twey thank you
02:28:50 <Samantha> I have that book
02:29:21 <Samantha> so who is going to help me out
02:29:27 <Samantha> in my error message
02:29:28 <Samantha> ?
02:29:32 <Samantha> I guess nobody
02:29:56 <sipa_> Samantha: the line "mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn" is an example of how to use mapReduce
02:30:03 <sipa_> it is a valid haskell expression
02:30:14 <sipa_> but it's not supposed to be there on that line
02:30:47 <Samantha> it doesnt matter 
02:30:56 <Samantha> it run even do is there
02:31:00 <Samantha> or not there
02:31:05 <Samantha> thats not the problem 
02:31:17 <Samantha> the problem is with the scanl1'
02:31:42 <cathper> To be precise, the line of code applies the function `mapReduce' to `mapFn wayAheadFn turnAroundCond turnAroundFn'.
02:32:07 <mjrosenb> Samantha: in general, i will be more willing to help you if you remember to include all of the words in your statements.
02:32:18 <Samantha> I did 
02:32:45 <sipa_> Samantha: there is neither foldr' nor scanl1 in that piece of code
02:33:18 <Samantha> i need to define scanl1 using map reduce
02:33:30 <Samantha> Define scanl1 in terms of mapReduce. 
02:33:34 <sipa_> ok
02:33:40 <Samantha> I need to create myself
02:33:47 <Samantha> Define foldr in terms of mapReduce. 
02:33:50 <sipa_> and mapReduce is given to you?
02:33:53 <Samantha> yes
02:33:57 <Samantha> the proff
02:33:59 <sipa_> or you had to write it yourself?
02:34:00 <Samantha> create it
02:34:04 <sipa_> ok
02:34:08 <sipa_> but it isn't there
02:34:12 <sipa_> i don't see mapReduce
02:34:19 <sipa_> i only see an example of how to use it
02:34:19 <Samantha> http://pastebin.org/330921
02:34:43 <sipa_> ooh
02:34:50 <sipa_> you're adding newlines
02:34:52 <sipa_> now i see it
02:34:55 <Samantha> thats mapreduce
02:34:56 <Samantha> ok
02:34:58 <sipa_> but you can't do that
02:35:04 <sipa_> it changes the meaning of the program
02:35:16 <Samantha> he want that
02:35:22 <Samantha> the proff
02:35:39 <sipa_> why a newline between lines 1 and 3, and one between 8 en 10?
02:36:05 <Samantha> blank lines 
02:36:12 <Samantha> is not a problem 
02:36:26 <Samantha> are not a problem
02:36:30 <sipa_> yes they are
02:36:39 <sipa_> this is not valid code anymore
02:37:01 <Samantha> Here you go http://pastebin.org/330969
02:37:09 <Samantha> NO LINES 
02:37:11 <Samantha> NO LINES
02:37:23 <sipa_> if i remove them, it works fine
02:37:28 <Samantha> i am sorry but I am fustrate
02:37:33 <Twey> Samantha: Those aren't the newlines that are the problem.
02:38:12 <Samantha> in your computer
02:38:17 <sipa_> this still isn't valid haskell code
02:38:19 <Twey> Samantha: The problem is that ‘mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn xin’ is all one pattern, but you've split it over two lines without indenting the new line
02:38:37 <Twey> Samantha: Which makes the compiler interpret it as two definitions
02:38:48 <Samantha> I didnt do that
02:38:53 <Samantha> the professor 
02:38:57 <Samantha> did it and it works
02:39:16 <sipa_> i don't think you're copying the code correctly
02:39:21 <Samantha> man MAPREDUCE DONT HAVE ANY PROBLEMS
02:39:24 <Samantha> AT ALL
02:39:25 <Twey> It doesn't work in any valid Haskell compiler.
02:39:42 <sipa_> Samantha: ok, i'll ignore that fact for now, and look at the rest
02:39:52 <sipa_> but it still isn't valid code this way
02:40:10 <Samantha> Ok check this 
02:40:11 <Samantha> http://pastebin.org/330978
02:40:29 <Samantha> Compile that just type main at the shell
02:40:35 <sipa_> that is fine
02:40:41 <Samantha> what is fine
02:40:43 <Samantha> ?
02:41:09 <sipa_> line 9 on http://pastebin.org/330978 is "mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn xin"
02:41:29 <Samantha> No more please 
02:41:38 <sipa_> line 1 on http://pastebin.org/330969 is "mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn"
02:41:45 <Samantha> MAP REDUCE is a not a problewm
02:41:53 <sipa_> yes, i know now
02:41:54 <Samantha> Sipa: do you a haskell compiler?
02:42:18 <sipa_> Samantha: do i have one? of course
02:42:21 <Samantha> compile the code 
02:42:23 <sipa_> i did
02:42:33 <Twey> Samantha: That one's fine.  See how ‘mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn xin’ is all on one line?  That makes the code valid.
02:42:38 <sipa_> as i tell you, the version in http://pastebin.org/330978 is fine
02:42:45 <sipa_> but the version on http://pastebin.org/330969 is not
02:43:08 <Samantha> why?
02:43:13 <sipa_> you splitted that line
02:43:19 <Samantha> which line
02:43:22 <Samantha> ?
02:43:22 <sipa_> *sign*
02:43:27 <sipa_> mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn xin
02:43:28 <sipa_> that one
02:43:31 <sipa_> it became
02:43:34 <sipa_> mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn
02:43:43 <sipa_> reduceFn xin   
02:43:46 <sipa_> one two lines
02:44:07 <sipa_> and yes, mapReduce wasn't the problem
02:44:19 <sipa_> but since something probably went wrong when you copied it
02:44:25 <sipa_> we all assumed that was the problem
02:44:55 <Samantha> oh man
02:45:08 <Samantha> my problem is with scanl1'
02:45:14 <sipa_> ok, so on to that
02:45:29 <sipa_> mapReduce takes 6 arguments
02:45:33 <sipa_> you only pass it 5
02:45:46 <Samantha> http://pastebin.org/330979
02:46:55 <sipa_> Samantha: (+) takes two arguments
02:47:05 <sipa_> you passed it a single one, a list
02:47:27 <sipa_> > foldr1 (+) [1,2,3]
02:47:28 <lambdabot>   6
02:47:31 <sipa_> > foldr1 (+) [1,2,3,4,5,6]
02:47:32 <lambdabot>   21
02:47:39 <sipa_> is that what you mean?
02:47:58 <Samantha> no
02:48:05 <sipa_> > (+) 1 2
02:48:06 <lambdabot>   3
02:48:22 <Samantha> No i want to define scanl1 
02:48:31 <sipa_> yes
02:48:32 <Samantha> using mapreduce
02:48:35 <sipa_> i know
02:48:40 <sipa_> 11:45:05 < sipa_> mapReduce takes 6 arguments
02:48:41 <sipa_> 11:45:08 < sipa_> you only pass it 5
02:48:50 <Samantha> so what are you talking about foldr
02:48:51 <Samantha> ?
02:49:09 <sipa_> Samantha: in your last piece of code you say '(+) [1,2,3]'
02:49:12 <sipa_> i have no idea why
02:49:23 <sipa_> but i'm trying to guess what you want to do
02:49:34 <sipa_> on http://pastebin.org/330979
02:50:02 <Samantha> test is the scanl1
02:50:06 <Samantha> function 
02:50:12 <Samantha> i named test
02:50:21 <sipa_> ok
02:50:23 <sipa_> nevermind
02:50:34 <sipa_> go look at your definition of scanl1'
02:50:35 <Samantha> what?
02:51:00 <sipa_> on http://pastebin.org/330969
02:51:14 <sipa_> lines 8-14
02:51:29 <sipa_> mapReduce takes 6 arguments, but you only pass it 5
02:51:39 <sipa_> that's necessarily wrong, but in this case i think it is
02:52:07 <Samantha> ok I change to  6
02:52:18 <sipa_> i gotta go now
02:52:22 <sipa_> good luck
02:52:41 <Samantha> Here you go http://pastebin.org/330984
02:52:57 <Samantha> :sipa you got it
02:56:12 <freiksenet> .иг2
02:56:16 <freiksenet> oops, sorry
02:59:08 <Samantha> mjrosenb: Can you help me
03:00:23 <Samantha> mjrosenb: Can you help me
03:00:42 <EvilMachine> how do you use lambdabot again?
03:00:45 <EvilMachine> > True
03:00:47 <lambdabot>   True
03:00:50 <EvilMachine> ah ok
03:01:08 <EvilMachine> but what does it do when i...
03:01:19 <EvilMachine> > let y = [ x | x <- [1,2,3,4,5,2], not (x `elem` y) ] in y
03:01:24 <lambdabot>   mueval-core: Time limit exceeded
03:01:40 <EvilMachine> hmm. ;)
03:01:45 <Twey> You could more easily have:
03:01:48 <Twey> > let x = x in x
03:01:52 <lambdabot>   mueval-core: Time limit exceeded
03:02:04 <Jafet> > text "mueval-core: Time limit exceeded"
03:02:05 <lambdabot>   mueval-core: Time limit exceeded
03:02:14 <Twey> Hehe.
03:02:46 <EvilMachine> actually, my human assumption was, that my above try would result in "True"
03:02:56 <EvilMachine> no wait
03:03:02 <EvilMachine> in [1,3,4,5]
03:03:30 <EvilMachine> but of course that's a bit too smart, is it?
03:04:44 <Twey> Probably
03:04:49 <Twey> Also, x `notElem` y
03:05:38 <Twey> Or, let y = filter (`notElem` y) [1, 2, 3, 4, 5, 2] in y
03:05:46 <EvilMachine> right
03:06:01 <EvilMachine> > let y = filter (`notElem` y) [1, 2, 3, 4, 5, 2] in y
03:06:05 <lambdabot>   mueval-core: Time limit exceeded
03:06:12 <EvilMachine> wel... ;)
03:06:21 <EvilMachine> +l
03:06:22 <Twey> It's still not going to work, of course.
03:06:31 <EvilMachine> of course
03:06:35 <Twey> The opposite should, though.
03:06:58 <Twey> Oh, wait, no
03:07:04 <Twey> Never mind that
03:07:08 <EvilMachine> i just wonder why i think it should work, and where i differ from how haskell works. but i think i understood that now.
03:07:39 <Twey> Well, just imagine trying to get the first element
03:07:42 <EvilMachine> if you simply see it as a copy-paste machine, of course it will endlessly copy and past.e
03:08:14 <Twey> It would be 1, but we have a filter in place, so we first check whether it's in y, so we need to get the first element of y, which would be 1, but…
03:08:17 <EvilMachine> logically, we neey to give it a first element, and it will work. (but depending on how we do that, still may take a lot of time)
03:08:40 <Twey> No, because then the same thing will happen with the second element.
03:09:09 <Twey> Or, let y = 1 : filter (`elem` y) [1, 2, 3, 4, 5, 2] in y
03:09:17 <Twey> Err
03:09:20 <Twey> > let y = 1 : filter (`elem` y) [1, 2, 3, 4, 5, 2] in y
03:09:24 <lambdabot>   mueval-core: Time limit exceeded
03:09:28 <EvilMachine> it would be awesome, if one could could automate this thought that's so natural to us humans. i bet one could automate it. since i thing everything we can do, can be automated... some day.
03:09:31 <Twey> > let y = 1 : filter (`elem` y) [1, 2, 3, 4, 5, 2] in take 2 y
03:09:32 <lambdabot>   [1,1]
03:09:39 <Twey> We can do that, though, since it's lazy.
03:09:50 <Twey> Turing says no
03:10:20 <EvilMachine> hmm... i should know what you mean. my brain just isn't ready yet... still early here. ;)
03:10:26 <EvilMachine> (for me anyway)
03:10:49 <flux> twey, so human-decidable problems is a larger set than turing-decidable?
03:11:04 <EvilMachine> Twey: if you want, just link me to where turing says no. (wikipedia link)
03:11:14 <EvilMachine> i bet i got "duh, i knew that"
03:11:25 <EvilMachine> but i feel stupid otherwise. :)
03:11:38 <EvilMachine> ah
03:11:39 <EvilMachine> wait
03:11:44 <EvilMachine> you mean the turing test
03:11:53 <EvilMachine> duh, i knew that. 
03:11:55 <EvilMachine> :P
03:12:09 <EvilMachine> i say he's wrong though. 
03:12:55 <Twey> EvilMachine: http://en.wikipedia.org/wiki/Undecidable_problem
03:13:02 <Jafet> > join . filter ((==1).length) . group . sort $ [1,2,3,4,5,2]
03:13:03 <lambdabot>   [1,3,4,5]
03:13:25 <EvilMachine> since we can simulate all physical laws in normal software (although very slowly), and the brain is based on those, we can also simulate brains, and hence humans.
03:14:02 <Twey> EvilMachine: Ever played with a neural network?
03:14:16 <Twey> They're a long way off being human :þ
03:14:17 <zomg> EvilMachine: you'd first need to understand how exactly brains and consciousness works before you could simulate a human though =)
03:14:35 <Twey> Not only brains, but thought-encoding too
03:14:40 <Entroacceptor> Twey: and you're saying that's impossible?
03:14:53 <Entroacceptor> it's not about if we can do it _now_
03:14:57 <EvilMachine> quick side-note: this channel is like a paradise wonder-world where every random person you talk to at a party is a smart person that you can have very interesting and intelligent conversations with. ;)
03:15:32 <Entroacceptor> if you don't want that, I've been around enough online gaming groups to tell you to gtfo noob
03:17:05 <Twey> Entroacceptor: Not necessarily
03:17:09 <EvilMachine> Twey: yep, i played a lot with them. they are not that far off. i'm one of those who think apart from adding messengers (like global broadcast communication over side-channels) and a lot more neurons, there's no difference between modern (spiking) NNs and brains anymore. but of course i'd also love to be proven wrong. :)
03:17:33 * hackagebot a50 0.2 - Compare genome assemblies  http://hackage.haskell.org/package/a50-0.2 (KetilMalde)
03:17:35 <Biggles> EvilMachine: we cannot currently simulate all physical laws in a computer
03:17:49 <theom3ga> hi
03:17:49 <Biggles> if we could then physics would be over and we could all go home
03:17:57 <EvilMachine> Entroacceptor: i just made a compliment that included you. how did you end up thinking i would not like you? ;)
03:18:22 <theom3ga> I'm trying to write a function to show that operator && is not strict, this is what I got so far:
03:18:26 <theom3ga> check :: Bool -> Bool
03:18:26 <theom3ga> check x = False && check x
03:18:41 <theom3ga> but it says that it cannot infer instance, I don't know what that means
03:19:02 <Twey> theom3ga: check = not $ False && undefined
03:19:24 <EvilMachine> zomg: i understand how exactly brains work. consciousness is just an artifact of its basic rules. that's my p.o.v. well, we'll see who is horribly wrong  in the futur. maybe. :))
03:19:36 <theom3ga> Twey, what does that $ do there
03:19:51 <Twey> EvilMachine: Do you?  You should become a neuro-surgeon, then.  They have a lot to learn from you.  :þ
03:19:56 <Biggles> EvilMachine: explain language instinct
03:20:00 <Entroacceptor> Twey: we can simulate an awful lot, though
03:20:11 <Twey> theom3ga: Function application
03:20:21 <EvilMachine> Biggles: we can not simulate them all? now that's interesting. care to explain?
03:20:32 <Twey> @let (y ?? n) p = if p then y else n
03:20:35 <lambdabot>  Defined.
03:20:50 <Biggles> surely there is not a complete theory of everything.
03:21:25 <Twey> > test $ "Haskell " ++ ("isn't" ?? "is" $ False && undefined) ++ " lazy."
03:21:27 <Twey> Err
03:21:27 <lambdabot>   Not in scope: `test'
03:21:27 <Biggles> such a program would equate to one, I suspect.
03:21:29 <Twey> > text $ "Haskell " ++ ("isn't" ?? "is" $ False && undefined) ++ " lazy."
03:21:30 <lambdabot>   Haskell is lazy.
03:21:47 <EvilMachine> Twey: surgeon? that's like comparing a car engineer with a scrap yard worker. ;)r
03:21:56 <EvilMachine> (the surgeon being the worker)
03:22:08 <Twey> EvilMachine: Yeah, I got it.  :þ
03:22:33 <Psytonic> how difficult is it to draw a graph (as in x-y graph) in haskell? can i just give a library a bunch of points to plot a line through?
03:22:35 <Twey> EvilMachine: Nevertheless, you could save a lot of lives with your mystical complete comprehension of all the brain's processes, not to mention win yourself a Nobel Prize or two.  I say go for it.
03:22:46 <Twey> Psytonic: Sure… there's a graphviz library
03:23:11 <Biggles> probably some computer science awards for simulating the unvierse (slowly or on paper) in a computer too
03:23:16 <Psytonic> Twey: is it complicated? and is the library standard?
03:23:24 <EvilMachine> Biggles: language instinct? well, it's just pattern recognition. but there is no point in explaining the complex patterns emerging from a strongly emergent system. you know already that its few simple rules can create complex behavior. 
03:23:41 <Twey> Psytonic: http://hackage.haskell.org/package/graphviz
03:23:49 <Biggles> given that a lot of physics lives on the real line which contains uncomputable numbers
03:23:53 <zomg> If it was that simple I wonder why no one has really managed to simulate brains that well yet =)
03:23:55 <Psytonic> Twey: thanks
03:23:58 <Twey> Psytonic: Err, it's not standardised, no
03:24:06 <therp> there was a post once on planet.h.o that argued that monads particularly IO was not a clean solution to the side-effect problem, but rather a solution on how to separate the imperative from the functional cleanly. does anyone remember that by accident? I can't find it in my RSS reader :/
03:24:25 <EvilMachine> Biggles: but let's not get in a fight. i know i'm taking a p.o.v. that many don't like. maybe we should discuss this somewhere else, or it might end in flames.
03:24:46 <Psytonic> Twey: ok, thanks heaps :D
03:24:53 <Biggles> lol
03:24:55 <Entroacceptor> well, I'd bet that the unknown physical principle don't influence how the brain works
03:25:06 <Jafet> > map fst . filter (not.uncurry elem) . ap zip (uncurry (zipWith (++)) . (inits&&&tail.tails)) $ [1,2,3,4,5,2]
03:25:08 <lambdabot>   [1,3,4,5]
03:25:19 <Twey> Haha
03:25:25 <Twey> Have you been concocting that this whole time?  :þ
03:25:31 <Jafet> Yeah
03:25:41 <Twey> therp: I don't know it, but it sounds like something conal would say
03:25:50 <sipa_> @unpl map fst . filter (not.uncurry elem) . ap zip (uncurry (zipWith (++)) . (inits&&&tail.tails)) $ [1,2,3,4,5,2]
03:25:50 <lambdabot> (map fst (filter (\ k -> not (uncurry elem k)) ((zip >>= \ m -> (\ t -> uncurry (zipWith (++)) ((inits &&& tail) (tails t))) >>= \ l -> return (m l)) ([1, 2, 3, 4, 5, 2]))))
03:26:01 <sipa_> now that's more readable...
03:26:15 <therp> Twey: yes, I think so too. haven't located it though in his blog.
03:26:34 <Twey> sipa_: *snrk*
03:26:47 <Psytonic> Twey: erm, x-y graphs, scatter plots, not graphs with nodes etc
03:27:22 <Twey> Psytonic: Oh, sorry
03:27:25 <Twey> Psytonic: http://hackage.haskell.org/package/gnuplot
03:27:38 <Jafet> I'd better install lambdabot and goa before I turn into a human @pl.
03:27:56 <Twey> Arrrgh, Thielemann
03:28:00 <Psytonic> TweyL thanks :)
03:28:07 <Twey> ‘data T.  Instances: C T’
03:28:11 <blackh> Psytonic: Look at Chart. It's much nicer than gnuplot.
03:28:32 <Jafet> Here Twey, eat some quiche.
03:28:36 <Twey> http://hackage.haskell.org/package/Chart — this one?
03:29:01 <blackh> That's the one.
03:29:17 <EvilMachine> Twey: about my "mystical complete comprehension": under common assumptions, me stating i would have such a comprehension is very stupid, i completely agree. :) but i go a bit different. all those complex rules people try to find out right now... my theory is simply, that they are just artifacts. in that there are just a few basic rules. and all that stuff we would not know, can already deduced from them. of course this would als
03:29:42 <Biggles> you mean you read A New Kind of Science?
03:29:46 <Twey> EvilMachine: Sure, but you have to actually deduce them before you can say that you understand them :þ
03:29:50 <Entroacceptor> EvilMachine: that's cut off at 'would als'
03:29:56 <Twey> And yeah, truncated.
03:30:14 <Entroacceptor> Twey: well,  but you don't have to understand them to replicate the behaviour
03:30:16 <Psytonic> blackh: shall do
03:30:46 <EvilMachine> Jafet: you win the cake! thanks a lot!
03:31:32 <blackh> Psytonic: I'll give you a little more information: I haven't used the Haskell binding to gnuplot. Maybe that makes it OK, I don't know. But gnuplot itself is an abomination.  Chart is written in Haskell and it uses the gtk2 Cairo binding to do its rendering.  It's nice and Haskelly.
03:31:55 <EvilMachine> Entroacceptor: oh, sorry. 
03:31:58 <Entroacceptor> the opinions on that differ
03:32:07 <Entroacceptor> (that was to blackh)
03:32:12 <Entroacceptor> I bet gnuplot is more powerful
03:32:21 <Psytonic> blackh: haskelly :D
03:32:23 <EvilMachine> Entroacceptor, Twey: let's put it in more lines
03:32:29 <EvilMachine> 1. about my "mystical complete comprehension": under common assumptions, me stating i would have such a comprehension is very stupid, i completely agree. :)
03:32:42 <Jafet> I don't think gnuplot should be used for serious work.
03:32:44 <EvilMachine> 2. but i go a bit different. all those complex rules people try to find out right now... my theory is simply, that they are just artifacts. 
03:33:01 <EvilMachine> 3. and all that stuff we would not know, can already deduced from them. of course this would also be pretty arrogant to state without proof.
03:33:12 <EvilMachine> 4. but i thought: let's run with it, and see where it breaks down, to learn something from it. the problem is: that's years ago, and nothing broke down.
03:33:15 <EvilMachine> done
03:33:44 <EvilMachine> man, if i had money, i'd pay you to call me wrong and stupid all day long! ;)
03:34:03 <EvilMachine> but in this case i can only offer a beer or drink or something in case you live in the area.
03:34:34 <blackh> Psytonic: If you end up looking at both, let me know which one you think is better.
03:34:37 <Biggles> have you read / contributed to any of the work that is being done in this area
03:34:39 <Twey> Your manner of speech suggests you're an American, which would mean that sadly I am not
03:34:52 <Psytonic> blackh: i'll probably just go with chart, looks easier to use
03:34:53 <tab> blackh: the only problem with chart is, it's too simplistic
03:35:02 <Psytonic> and its for very simple usage
03:35:10 <EvilMachine> blackh: i agree on gnuplot being an abomination. although i used it, by piping my program's output to it.
03:35:20 <Psytonic> do they require a nix distro?
03:35:36 <Twey> Probably
03:35:40 <Psytonic> ><
03:35:41 <Twey> Does Cairo work on Windows?
03:35:45 <Psytonic> typical
03:36:08 <Twey> Wait, you're developing on a Windows machine?  :þ
03:36:11 <Biggles> cos.. i mean.. it's not like this is a unique approach to science. it kind of describes theoretical computer science in some respects.
03:36:15 <EvilMachine> Biggles: I've read a lot. But I currenly have very different goals. Game AI.
03:36:17 <Psytonic> Twey: yes
03:36:18 <tab> Twey: it does work on windows
03:36:29 <Psytonic> glib failed to install apparently ><
03:36:46 <Biggles> but we haven't proven wolfram's principle yet so as far as i'm concerned we can't just laud it
03:36:46 <Jafet> Does anything from the gtk heritage ever work on Windows...
03:36:50 <therp> everything works on windows, you just have to put it into Virtualbox running Linux first
03:36:57 <Twey> Oh, does it?  I guess it will, then.
03:37:01 <Psytonic> anyway
03:37:03 <Psytonic> thanks guys
03:37:04 <Psytonic> cya
03:37:12 <tab> cairo is a renderer, not anything to do with displaying on screen
03:37:31 <Biggles> i'm into game development too but am thorroughly disillusioned with ai as far as computer opponents go.
03:37:42 <blackh> Jafet: gtk2hs does work on Windows, so I understand
03:37:50 <Jafet> therp: Last time I tried, I couldn't get virtualbox to work on windows. That was pretty much the end of it.
03:37:50 <Biggles> if you want to play classical games then i guess ai is cool though.
03:38:25 <Biggles> and ai thought can be applies in expressive ways at times i guess.
03:38:27 <EvilMachine> Twey: i am not american. i  amluxemburgish. mer kënnen och letzeburgesch schwätzen. oder wir reden deutsch. ou peut-être français? ;)
03:38:28 <therp> Jafet: oh, I found VirtualBox to be of quite good quality. the devs are also quite friendly on #vbox-dev
03:38:30 <Biggles> applied
03:39:04 <blackh> EvilMachine: Luxemburg's name is too long for the size of the country.  I've never seen a map on any scale where the name fits inside the country.
03:39:35 <Biggles> did you ever read the book 'Expressive Processing' though? it's an interesting discussion of ai's relationship with particular forms of expression in games, particularly story generation
03:39:43 <EvilMachine> therp: i want to run that virtualbox in a computer that is built in MineCraft, running on Emacs. :P
03:39:43 <sipa_> Biggles: maybe it works if you use scale 1:1 ?
03:39:51 <Biggles> although for someone more educated than me it might be a bit shallow
03:40:30 <Biggles> scale 1:1?
03:40:41 <Biggles> was that meant for someone else
03:41:00 <EvilMachine> Biggles: yes, computer opponents are really stupid. but i really wonder how they do it. it's not that hard. you just have to think on a much higher level than "i'll make some rules and perhaps slap on some neural networks" ;)
03:41:31 <Biggles> actually computers have recently ruined some games on the developer end by being too smart
03:41:39 <EvilMachine> blackh: well, what's even worse: the capital city has the same name. try to fit it into what is not even a pixel on a map. ;)
03:41:50 <Twey> EvilMachine: Oh, fair enough.  :þ
03:41:57 <Twey> Still not very close, though.
03:41:58 <Biggles> in the development for that final fantasy wiiware game the AI basically played the game for players so they had to turn it down
03:42:24 <vivek> i've read learn you a haskell,but how do i get started with haskell? writing real programs?
03:42:25 <blackh> EvilMachine: I live in New Zealand, but we are surrounded by sea, so that's OK. :)
03:42:28 <Biggles> and the reason most game AI is dumb is that it's entirely state machines. it's hardly AI at all.
03:42:28 <EvilMachine> Biggles: sounds like an interesting read. i'll first try out if what i think works, or i'm just completely stupid. ;)
03:42:34 <Biggles> blackh: hey i'm from there
03:42:46 <Jafet> The barrier to higher AI will be the fact that there aren't enough clever programmers to make them.
03:42:48 <Twey> @where rwh
03:42:48 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:42:50 <Twey> vivek: ^
03:42:53 <blackh> Biggles: Great! Where are you? I'm in Manawatu.
03:43:06 <Biggles> Auckland
03:43:21 <Jafet> I bet you could port SHRDLU to the iphone, and people would still be amazed
03:43:34 <sipa_> Biggles: yes, it was meant for blackh 
03:43:41 <EvilMachine> vivek: O'Reilly has that great book online: http://book.realworldhaskell.org/read/
03:43:42 <Biggles> oic
03:43:44 <EvilMachine> ah, too late
03:43:45 <sipa_> blackh: maybe it works if you use scale 1:1 ?
03:44:45 <Entroacceptor> and often you don't even want a real AI for games
03:44:57 <Biggles> my concern with AI in games is that if you have little control over how the game expresses itself
03:45:00 <EvilMachine> blackh: New Zealand? Then, from what I heard, I wish you luck with picking up women... without anyone being drunk. (No offense... I got this from someone who is from there himself.)
03:45:02 <blackh> Biggles: There are about 5 or 6 Haskellers I know of in NZ.
03:45:14 <Biggles> blackh: I don't know any, haha
03:45:44 <blackh> Biggles: Hamishmack who works on Leksah lives in Wellington.
03:45:53 <blackh> Biggles: Well, now you know me!
03:46:01 <Biggles> lol
03:46:09 <Biggles> pleased to meet you
03:46:14 <blackh> EvilMachine: You mean you don't come from a country with a binge drinking culture? How strange.
03:47:32 <EvilMachine> Biggles: exactly. state machines. or neural networks. instead of thinking outside the box. my approach is coming from a standpoint of psychology. as luckily, i now found a method that can heal lots of things modern psychology still struggles with it. the only problem: you absolutely need people who can give love to people, even when those act very weird, creepy and unfriendly. i can sometimes do it, but it often requires superhu
03:47:39 <EvilMachine> (mental strength)
03:48:04 <FunctorSalad> haskell-cafe: 'And "purely functional programming language"?
03:48:04 <FunctorSalad> If they mean anything to many people, it's that the language works
03:48:04 <FunctorSalad> (i.e. functions). What language wouldn't work? '
03:48:11 <EvilMachine> (and this giving love is just assistance, to create a workable environment. not the actual therapy)
03:48:14 <EvilMachine> bla
03:48:19 <EvilMachine> sorry. back on topic
03:48:40 <Entroacceptor> EvilMachine: you got cut off again
03:48:50 <Entroacceptor> computer AI as therapists?
03:49:27 <EvilMachine> Jafet: smart statement. :) i hope not, but i feel like you might sadly be right. ;)
03:50:01 <EvilMachine> Entroacceptor: oops. wait
03:50:08 <Jafet> I know a few purely dysfunctional programming languages
03:50:13 <EvilMachine> 1. Biggles: exactly. state machines. or neural networks. instead of thinking outside the box. my approach is coming from a standpoint of psychology.
03:50:21 <EvilMachine> 2. as luckily, i now found a method that can heal lots of things modern psychology still struggles with it. the only problem:
03:50:29 <EvilMachine> 3. you absolutely need people who can give love to people, even when those act very weird creepy and unfriendly.
03:50:39 <EvilMachine> 4. i can sometimes do it, but it often requires superhuman strength, which nobody, including me, has. (mental strength)
03:51:21 <EvilMachine> Entroacceptor: not computer AI. but actually, that therapy is scaringly pretty algorithmic.
03:51:24 <EvilMachine> -pretty
03:52:17 <EvilMachine> but i fear it will be very off-topic to explain how it works
03:52:25 <FunctorSalad> #haskell-blah
03:53:07 <EvilMachine> i just can say that it's another thing i had so much success with, that it creeped me out, and i try to find flaws. :)
03:53:23 <EvilMachine> FunctorSalad: /agree
03:53:32 <EvilMachine> #join haskell-bla
03:53:34 <EvilMachine> oops
03:54:12 <EvilMachine> nooo, you lured me into... what's the correct name of that channel?
03:54:59 <theorbtwo> #haskell-blah
03:56:49 <Botje> one does not simply /walk/ into #haskell-blah.
04:14:14 <ibid> ... one runs?
04:21:14 <dv-> one ambulates
05:22:01 <turiya> hi
05:22:34 <turiya> are there any disadvantages of using the FFI?
05:22:52 <Lemmih> turiya: Compared to what?
05:23:50 <turiya> i am trying to understand why writing haskell code with FFI to interface with C libraries is better than writing in plain C
05:24:42 <Lemmih> turiya: Haskell has a lot of high-level features and is nicer to use than C. 
05:25:27 <Axman6> turiya: you'd use the FFI to link to C libraries
05:25:32 <turiya> is it possible to completely eliminate C?
05:25:51 <Axman6> you can write computationally expensive code in C and call it from haskell too
05:26:28 <Lemmih> turiya: You can use as much or as little C as you want.
05:27:21 <turiya> Lemmih: some times one is forced to link with external C libs, especially in graphics applications
05:28:36 <Lemmih> turiya: You could theoretically reimplement the UI libraries.
05:29:40 <sipa_> or use existing bindings
05:29:52 <turiya> Lemmih: in linux, one would have to deal with the C stuff at some point of the other.. no?
05:30:16 <turiya> or*
05:30:16 <Lemmih> turiya: Yes.
05:30:40 <Lemmih> sipa_: That would still involve linking with the external libraries.
05:30:47 <sipa_> yes
05:30:53 <turiya> the only solution then is a Haskell OS?
05:31:04 <Axman6> they exist
05:31:15 <Lemmih> turiya: I'm afraid I don't see the problem.
05:32:18 <turiya> Lemmih: the problem is to use only haskell code from ground up..
05:33:25 <Lemmih> turiya: Then you'd have to get rid of anything written in C, which includes the operating system.~
05:33:49 <Lemmih> turiya: Have a look at this: http://programatica.cs.pdx.edu/House/
05:33:52 <hpc> all you really end up needing is a haskell kernel
05:34:22 <sipa_> is there some extension that allows you to write inline assembly in haskell?
05:35:25 <Lemmih> sipa_: You can do that with the ForeignFunctionInterface.
05:36:01 <hpc> inline assembly in haskell would be very difficult to write
05:36:31 <sipa_> it's possible in C
05:36:41 <hpc> C is very different from haskell
05:36:54 <hpc> it translates almost directly to assembly
05:37:14 <Rutix> indeed
05:37:19 <turiya> i hope development on this House OS continues..
05:37:47 <hpc> in haskell you have to worry about mutation, thunks
05:37:54 <hpc> the GHC pointer format
05:38:09 <sipa_> of course
05:38:13 <Twey> hpc: It's not that hard
05:38:18 <tab> the inliner assembly extension would deal with that
05:38:19 <sipa_> but those problems have already been solved for the FFI itself
05:38:44 <hpc> there's an extension?
05:38:48 <tab> no
05:38:57 <hpc> oh, "would", nvm
05:39:00 <Twey> http://intoverflow.wordpress.com/2010/05/21/announcing-potential-x86-64-assembler-as-a-haskell-edsl/
05:39:05 <hpc> that makes sense then
05:39:09 <Lemmih> sipa_: How would it be different than just using the FFI?
05:39:10 <tab> but the way you could embedded that, you would declare where everything need to go
05:39:19 <tab> and how you get stuff back from the register to a haskell context
05:39:43 <Twey> You get static checks, too
05:39:53 <hpc> i see
05:40:27 <hpc> so then you basically have Foo a => Register -> a
05:40:32 <hpc> which wouldn't be hard to write
05:40:40 <tab> hpc: yeah
05:41:04 <hpc> in retrospect, that is entirely obvious :P
05:42:15 <tab> hpc: :)
05:55:37 <ksf> which web framework does that path analysing thingy best?
05:56:39 <ksf> ...and is flexible enough to support ripping out the http backend and replacing it with fuse/9p
06:00:07 <sipa_> is there some predefined/common implementation of arbitrary-precision fractions?
06:01:20 <aristid> sipa_: Rational?
06:02:03 <aristid> > 4.2 :: Rational
06:02:03 <sipa_> damn, thanks :)
06:02:04 <lambdabot>   21 % 5
06:02:21 <hpc> > sqrt 4.2 :: Rational
06:02:23 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
06:02:23 <lambdabot>    arising from a us...
06:02:34 <hpc> that's smart
06:03:13 <aristid> > toRational pi
06:03:15 <lambdabot>   884279719003555 % 281474976710656
06:03:15 <Jonny> Hi
06:03:21 <Botje> hallo
06:03:29 <aristid> > fromRational (toRational pi) - pi
06:03:30 <lambdabot>   0.0
06:03:51 <aristid> > fromRational (toRational pi) == pi
06:03:52 <lambdabot>   True
06:03:58 <aristid> nice
06:04:11 <Jonny> Please could anyone help with a small problem.... http://pastebin.com/XM3vX01z   I am receiving a pattern match failure when I try to run this with "lookUp "A" [("A",8),("B",9),("C",5),("A",7)]"
06:04:13 <aristid> > fromRational (toRational pi) == (pi :: Double)
06:04:14 <lambdabot>   True
06:04:21 <aristid> > fromRational (toRational (pi :: Float)) == (pi :: Double)
06:04:23 <lambdabot>   False
06:04:53 <quicksilver> Jonny: your function definition only applies to lists of length 1.
06:05:22 <quicksilver> "lookUp s [ ( f , i ) ]" <--- binding will only bind lists (of pairs) of length 1.
06:05:39 <hpc> more precisely, [x] is sugar for x:[]
06:05:45 <hpc> you want x:xs
06:05:49 <quicksilver> no he doesn't.
06:05:55 <quicksilver> that would force lists of length at least one.
06:06:03 <quicksilver> what he actually wants, I believe, is simply xs.
06:06:27 <Jonny> but I thought [ (x,y) ] is simply a list of pairs?
06:06:34 <hpc> ah, yes i see
06:06:41 <hpc> Jonny: it is a list of /one/ pair
06:06:51 <quicksilver> > let lookUp s xs = [ y | ( x , y ) <- xs , s == x ] in lookup "A" [("A",8),("B",9),("C",5),("A",7)]
06:06:52 <lambdabot>   Just 8
06:07:01 <quicksilver> oops
06:07:05 <quicksilver> that's not your lookup ;)
06:07:11 <quicksilver> > let lookUp s xs = [ y | ( x , y ) <- xs , s == x ] in lookUp "A" [("A",8),("B",9),("C",5),("A",7)]
06:07:12 <lambdabot>   [8,7]
06:07:27 <quicksilver> Jonny: I think your confusion is the different between type syntax and value syntax.
06:07:43 <quicksilver> as a type, the syntax [(String,Int)] is the type of lists of pairs.
06:08:04 <quicksilver> as a *value*, [("A",5)] is a list with precisely one element (a pair).
06:08:07 <Jonny> ah
06:08:10 <Jonny> I see, thank you
06:08:16 <quicksilver> so [(f,i)] is a patter which matches a list with precisely one element.
06:08:27 <quicksilver> in my example, f would get the value "A" and i would get the value 5.
06:09:07 <quicksilver> > let [(f,i)] = [("A",5)] in  "f has the value " ++ show f ++ " and i has the value " ++ show i
06:09:09 <lambdabot>   "f has the value \"A\" and i has the value 5"
06:09:47 <Jonny> yeah I understand :) Cheers
06:10:38 <sipa_> @pl \l n -> concat $ replicate n l
06:10:38 <lambdabot> (join .) . flip replicate
06:11:36 <sipa_> @pl \n l -> concat $ replicate n l
06:11:36 <lambdabot> (join .) . replicate
06:12:28 <ray> nope, they don't really emit much heat
06:14:13 <hpc> ray: blah is that way: -->
06:14:16 <hpc> :P
06:17:58 <mornfall> @seen bcoppens
06:17:58 <lambdabot> Unknown command, try @list
06:17:58 <preflex>  bcoppens was last seen on #haskell-blah 17 days, 40 minutes and 2 seconds ago, saying: I know a lot of people rather like Mendeley
06:25:09 <cathper> I want `binomial :: Integral -> Integral -> Integral' calculating (n choose k), so I searched Hayoo but nothing came up.
06:26:30 <cathper> Is it really true that theres no "choose" function implemented anywhere? (Except from Statistics.Math.choose which is not really "compatible" with combinatorics.)
06:27:29 <Botje> it's pretty easy to define yourself, so ..
06:28:20 <byorgey> cathper: try 'binomial' from Math.Combinat.Numbers, in the combinat package
06:28:24 <byorgey> http://hackage.haskell.org/packages/archive/combinat/0.2.4/doc/html/Math-Combinat-Numbers.html
06:29:02 <byorgey> oh, hmm, that's not a very efficient implementation
06:29:10 <byorgey> well, it probably works fine for most purposes
06:34:09 <cathper> byorgey: Weird that didn't come up in Hayoo in the top hits of Hayoo; it is on page 3 though.
06:35:13 <cathper> byorgey: I did "binomial n k = (binomial (n-1) (k-1)) * n `div` k" ...
06:40:42 <EvanR-work> i remembered enough and wrote down enough to implement MonadExit and ExitT transformer, but now im wondering how to use the actions for the inner monad in actions for ExitT
06:41:14 <EvanR-work> liftIO only works for IO a
06:41:17 <EvanR-work> :t lift
06:41:19 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
06:42:00 <sipa_> if i have a function that recurses a million times, and only does tail calls, is it normal that it uses more and more memory?
06:42:00 <EvanR-work> implement a MonadTrans instance for ExitT e ?
06:42:29 <Twey> sipa_: It is if it's too lazy
06:42:37 <byorgey> cathper: yes, that's more efficient
06:42:41 <Twey> Or possibly too strict, depending what you're doing
06:42:45 <ketil> ghci refuses to echo, after a ctrl-z and a fg.  Any way to fix without restarting?
06:42:56 <Twey> ketil: Not that I've found
06:43:33 <EvanR-work> sipa_: well are you identifying tail calls correctly
06:43:44 <byorgey> cathper: there are even more efficient implementations based on the fact that it is easy to quickly factor factorials; then you can do some canceling and so on
06:44:03 <byorgey> but that should be fine for small values of n and k
06:44:09 <sipa_> Twey: let me try to make it more strict by adding !
06:44:23 * hackagebot wai-handler-devel 0.1.0.1 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.1.0.1 (MichaelSnoyman)
06:44:34 <Jafet> Past binary splitting to make the fft code pull its weight, there isn't that much to gain from splitting factors.
06:44:38 <byorgey> EvanR-work: yes, a MonadTrans instance is what you want
06:44:55 <Jafet> @src product
06:44:56 <lambdabot> product = foldl (*) 1
06:45:02 <Jafet> Useless crap
06:45:11 <EvanR-work> byorgey: ah, seems simple enough
06:45:19 <wlangstroth> snoyman is a machine - I wonder if he sleeps
06:45:23 * hackagebot wai-handler-webkit 0.1.0 - Turn WAI applications into standalone GUIs using QtWebkit.  http://hackage.haskell.org/package/wai-handler-webkit-0.1.0 (MichaelSnoyman)
06:45:45 <Twey> Hehe, gwern's bashrc makes me chuckle
06:45:50 <byorgey> wlangstroth: I was just wondering the same thing =)
06:45:58 <sipa_> Twey: works perfectly now
06:46:15 <spetrea> what's a nice IRC server ?
06:46:17 <wlangstroth> byorgey: hackagebot says no
06:46:23 <Twey> spetrea: I like Unreal
06:46:39 <EvanR-work> Freenode
06:47:02 <spetrea> no, I was talking about a IRC server which I can deploy on a machine in order to connect to it
06:47:09 <Twey> sipa_: Remember that evaluation is lazy, so even if it's a tail-call, it won't be evaluated unless it's forced, which can result in a big chain of thunks being built
06:47:19 <sipa_> Twey: yes i understand it now
06:47:34 <Twey> spetrea: http://www.unrealircd.com/ — Unreal.
06:48:16 <sipa_> the function was fn a b c | ... = a % b; fn a b | ... = fn (a ...) (b ...) (c ...)
06:48:23 <ray> i believe the word nice was used in the original question there
06:48:31 <sipa_> so my a and b arguments were being accumulated without being evaluated
06:48:33 <EvanR-work> Twey: thats kind of spooky, i wonder why all of the primitive 'looping' mechanisms i use never have that problem
06:48:53 <EvanR-work> strictness analysis?
06:49:49 <Twey> EvanR-work: Yeah, strictness analysis will usually take care of this problem if you compile with -O2
06:50:03 <Twey> ray: Unreal is pretty nice.
06:50:20 <Twey> I don't know of any other server with good Unicode support, so it wins for now.  ☺
06:50:44 <EvanR-work> legacy utf8-just-works isnt good enough? ;)
06:51:05 <Twey> EvanR-work: Good enough for messages, but e.g. nicks and channel names are problematic
06:51:15 <ray> replying to that outrageous statement would be so off topic here!
06:54:01 <wlangstroth> Twey: I looked up gwern's bashrc, thinking "what could possibly be ... holy crap"
06:55:16 <Twey> wlangstroth: Haha, I know
06:55:23 <cathper> byorgey: Do you have a reference? Or just a name?
06:56:05 <Twey> wlangstroth: I like this one: #We set the default to off, just to be safe.\ndeclare -x SCREENP=True #default
06:56:41 <Twey> And the typo aliases
06:59:12 <wlangstroth> Twey: how does that guy use other computers? I'll have to ask him.
06:59:30 <Twey> Slowly
07:05:10 <EvanR-work> @hoogle [(a,b)] -> c
07:05:11 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
07:05:11 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
07:05:11 <lambdabot> Prelude snd :: (a, b) -> b
07:05:24 <benmachine> Twey: I just had a poke about on his website and didn't see it, got a link?
07:05:44 <Twey> It's on Wikipedia
07:05:46 <benmachine> oic
07:06:05 <Twey> http://en.wikipedia.org/wiki/User:Gwern/.bashrc
07:06:59 <EvanR-work> @hoogle [(a,b)] -> ([a],[b])
07:06:59 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
07:07:00 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
07:07:03 <EvanR-work> smooth
07:07:07 <EvanR-work> hoogle worked
07:07:55 <ksf> zomfg
07:08:02 <ksf> (@ that bashrc)
07:09:30 * hackagebot stm 2.2.0.0 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.2.0.0 (SimonMarlow)
07:10:57 <merijn> Lambda lifting is essentially taking a function "\x. x y" to become "\y.\x. x y", correct?
07:11:24 <Jafet> That might be the closest I've ever seen to an implementation of zsh in bash
07:12:35 <cathper> :-D
07:14:41 <ksf> hmm. why can't I create files with slashes in them?
07:15:11 <merijn> In the file name?
07:15:11 <Twey> Because the slash is the directory separator?
07:15:22 <ksf> in paths, yes.
07:15:30 <Twey> Jafet: Hehe.
07:16:26 <ksf> ...escaping works strange, there. I get the exact same error for a/a and a\/a
07:17:12 <sipa_> ksf: it's an OS issue
07:17:18 <sipa_> escaping has nothing to do with it
07:17:21 <ksf> well, possibly it's a bid foolhardy to allow all of -r, -f and / in one directory...
07:17:27 <Twey> Haha
07:17:42 <Twey> ksf: The kernel interprets slashes in filenames specially.
07:18:01 <merijn> ksf: Trying this sorta thing angers the dread god Murphy
07:18:02 <Twey> It's one of two characters disallowed in UNIX filenames (the other being NUL)
07:18:02 <ksf> erm... not really.
07:18:07 <ksf> with fuse, you get the full path.
07:18:20 <ksf> 9p only disallows null, iirc.
07:18:34 <Twey> Hm.
07:18:39 <ksf> which isn't strictly necessary, either, as 9p strings aren't null-terminated.
07:19:00 <ksf> it's gotta be valid utf8, though, I think.
07:19:20 <ksf> ...at least for cromulent servers.
07:19:57 <Twey> What string format does 9p use?
07:20:27 <ksf> utf8, with length prefix.
07:20:32 <Twey> Ah
07:20:36 <ksf> 16 bit prefix I think.
07:20:40 <Twey> Hmm
07:20:49 <ksf> ...for one path element.
07:20:55 <Twey> Ah
07:21:01 <ksf> there's no max path length per se.
07:21:20 <ksf> although you're limited to 128 bits of inode-like thingies, which include union mounts.
07:21:29 <merijn> ksf: Do you actually have plan9 running?
07:21:33 <ksf> nope.
07:21:48 * Twey does, in a VM, but hasn't played with it in a while.
07:22:10 <ksf> ...but I've got plan9 from userspace installed.
07:22:21 <ksf> mostly for the 9p client, though
07:22:36 <merijn> I considered messing around with it, but I fear I'd miss some of my tools too much
07:22:45 <ksf> didn't want to mount every time I access a 9p fs.
07:23:29 <ksf> it'd be a good idea to switch to variable-length integers in 9p, I think.
07:24:28 <zygoloid> "plan9 from userspace" is an amazing name
07:26:22 <inbuninbu> i've been trying to construct a heterogenous map, and was wondering if anyone has any advice... specifically, i want a map where the values are lists... but each entry in the map can have lists of a different type... this is what i have so far:
07:26:38 <inbuninbu> data HL whereHL :: 
07:26:52 * ksf wonders whether it's a vain idea to try to find a common subset for things like fuse, 9p, http and ftp to build a generic filesystem library.
07:27:09 <inbuninbu> data HL where HL:: (Show a) => [a] -> HL
07:27:22 <ksf> heterogenous anything is non-trivial in haskell, atm.
07:27:22 * Jafet present ksf a {}
07:27:38 <wlangstroth> inbuninbu: a paste site might be better than posting here
07:27:49 <ksf> you can either use Data.Dynamic, HList or grapefruit-records.
07:28:04 <ksf> ...the latter both being not for the faint of heart.
07:28:20 <inbuninbu> wlangstroth: it's just two one-liners that illustrate my problem
07:28:50 <wlangstroth> inbuninbu: ah, sorry - I thought you were really going to go for it - that's usually messy
07:28:51 <ksf> inbuninbu, is there any particular reason why you can't use an adt as index?
07:29:24 <inbuninbu> ksf: well, i seem to have solved it at the level of the map itself... but i can't seem to perform any functions on the GADTized list above
07:29:51 <inbuninbu> ksf: i want the chance to do some Typeable stuff in the future, maybe
07:29:51 <ksf> well, you can show the list elements.
07:30:34 <inbuninbu> i want to be able to use (!!) however...
07:30:47 <ksf> that works, too.
07:31:30 <ksf> ...but you won't be able to do anything with the elements except to show them.
07:32:04 <inbuninbu> ksf: is there any way to use the standard list functions?
07:32:16 <ksf> oh, and when you're using !!, you're usually doing it wrong, better use a recursion.
07:32:58 <ksf> you can't make the list type heteromorph, no.
07:34:38 <inbuninbu> ksf: i see. i'll check out Data.Dynamic. i've seen a library: http://hackage.haskell.org/packages/archive/hetero-map/0.21/doc/html/HeteroMap-Map.html
07:35:17 <inbuninbu> however the source seems to use a lot of type-level programming and for the moment that's over my head
07:35:53 <quicksilver> it's likely that Data.Dynamic is your quickest route to a solution
07:36:04 <quicksilver> it's somewhat likely that you may be solving the wrong problem.
07:36:13 <quicksilver> What do you hope to do with this heterogenous map?
07:36:30 <quicksilver> once you've looked up an item, how will you know what to do with that item, since it is of unknown type after all?
07:37:03 <quicksilver> the answer Data.Dynamic gives is "you must have some other way of knowing what the type will (should) be and Data.Dynamic will check that's true and give you the value if it is"
07:37:26 <ksf> .oO( #haskell idiom #12: "Of course Haskell can't do it. You should be ashamed to even consider your approach to be a solution." )
07:37:43 * hackagebot ip6addr 0.3 - Command-line tools to deal with IPv6 Addresses text representation  http://hackage.haskell.org/package/ip6addr-0.3 (MichelBoucey)
07:37:47 <Jafet> @quote unsafeCoerce
07:37:48 <lambdabot> ddarius says: isJust . unsafeCoerce
07:38:11 <Jafet> @quote unsafeCoerce
07:38:11 <mgckan> hi,, gud pm
07:38:11 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
07:38:30 <quicksilver> ksf: quite.
07:38:40 <ksf> unsafeCoerce isn't what it should be.
07:38:55 <ksf> a truly unsafe unsafeCoerce wouldn't ensure that kinds stay the same.
07:39:41 <inbuninbu> quicksilver: playing around with implementing relational-style tables in a data structure. i was thinking of using a typeclass to determine what to do with them
07:40:22 <sipa_> ksf: only types belonging to * have realizable values
07:40:54 <sipa_> there is no value of type 'Maybe' eg
07:41:08 <ksf> yeah. you can't coerce at the type level.
07:41:41 <ksf> well, oleg probably can.
07:42:01 <sipa_> so there is no value unsafeCoerce could produce whose type has a different kind than the input
07:42:26 <ksf> but there's a type it could produce that has a different kind.
07:42:50 <ksf> ...not all value-level definitions are meant to be executed.
07:42:57 <quicksilver> inbuninbu: you probably don't want a heterogenous map then, so much as a map with a complex polymorphic value type.
07:43:02 <sipa_> ksf: give an example?
07:43:07 <quicksilver> but the devil is in the details
07:43:22 <ksf> two = undefined :: S (S Z)
07:43:41 <sipa_> that has kind *
07:44:01 <ksf> yeah. I didn't claim that I knew an application for a non-kind preserving unsafeCoerce.
07:44:22 <sipa_> ksf: no, but can you give an example?
07:45:02 <ksf> foo = ( unsafeCoerce (undefined :: Foo ()) ) :: Foo
07:45:20 <ddarius> I believe unsafeCoerce, or at least unsafeCoerce#, can change kinds.
07:45:33 <sipa_> ksf: that has no meaning...
07:45:38 <ksf> yes.
07:45:59 <ksf> type families could probably do such a thing.
07:46:54 <ksf> can unsafeCoerce coerce from lifted to unlifted types?
07:47:54 <Jafet> unkindCoerce
07:49:44 <azudem> BONUS: (sorry for bad english) Hi. I'm reading your book (Learn Haskell...) now. But is there pdf version of the book?
07:54:40 <quicksilver> azudem: http://www.google.co.uk/url?sa=t&source=web&cd=1&sqi=2&ved=0CBUQFjAA&url=http%3A%2F%2Flearnyouahaskell.com%2Flearnyouahaskell.pdf&ei=jgK_TJ3uM86OswbkydTXDQ&usg=AFQjCNFtpP4HcWoafUtD_T8MYt5VkCWPWg&sig2=6DGdPzLo9jcyZBrdAUrpvg
07:54:45 <inbuninbu> quicksilver: can you elaborate a little more?
07:54:51 <quicksilver> azudem: oops, sorry for the daft google link
07:55:01 <quicksilver> azudem: anyway it's first hit for googling "learn you a haskell pdf"
07:55:07 <azudem> quicksilver: it's not full version.
07:55:37 <quicksilver> you should have mentioned that in your question, then.
07:55:47 <quicksilver> inbuninbu: not really. Too many unknowns.
07:56:02 <quicksilver> inbuninbu: "decide how you want to model your system - implement that model as haskell types"
07:56:52 * hackagebot yesod-auth 0.1.4.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.1.4.1 (MichaelSnoyman)
07:56:53 <inbuninbu> quicksilver: i just mean what 'complex polymorphic data type' means... i assume you don't mean run-of-the-mill algebraic data types?
08:01:00 <quicksilver> inbuninbu: right. I mean a type with some nested quantifiers.
08:01:45 <quicksilver> like existentials
08:02:03 <inbuninbu> quicksilver: ok, thanks!
08:11:05 <merijn> Random theory question: Lambda lifting is essentially taking a function "\x. x y" and making it "\y.\x. x y", correct?
08:11:52 <Philippa_> and passing y in at all use sites, yes
08:12:10 <merijn> ok, thanks :)
08:14:09 <ddarius> Philippa_: What's some good open source drum machine software?
08:17:46 <wmeurt> hi, how can i get out of GHCi?
08:17:52 <dstcruz> :q
08:18:19 <ddarius> You can also take a baseball bat to your computer.
08:18:25 <EvanR-work> ddarius: theres hydrogen
08:18:46 <dstcruz> EvanR-work: there's EvanR-work :)
08:18:57 <EvanR-work> theres smack, but it depends on rotten lad code
08:19:04 <wmeurt> thx 
08:19:44 <EvanR-work> any lad sequencer + lad sampler
08:26:16 <itayd> hi
08:28:01 <itayd> anybody knows how can i from an .hs file programatically fetch the cabal version number? meaning if i set Version: 0.0.1 in, say, x.cabal, how can i fetch it from x.hs
08:28:59 <Lemmih> itayd: Cabal generates the information for you. Just import Paths_{package} and use 'version'.
08:29:26 <itayd> Lemmih: thanks, i'll try that
08:29:38 <itayd> (that's the sort of thing i was looking for)
08:30:40 <itayd> hmm, what is Data.Version.Version?
08:30:50 <sipa_> @hoogle Version
08:30:50 <lambdabot> module Data.Version
08:30:50 <lambdabot> Data.Version data Version
08:30:50 <lambdabot> Data.Version Version :: [Int] -> [String] -> Version
08:31:27 <itayd> thanks
08:31:38 <sipa_> seems a system for representing version numbers
08:31:55 <sipa_> > Data.Version.Version [3,2,1] ["bla"]
08:31:56 <lambdabot>   Not in scope: data constructor `Data.Version.Version'
08:33:43 <irv_> hi, can someone give me some help/advice with attoparsec? i'm not understanding somehting fundamental i'm sure
08:33:45 <itayd> works like a charm, 
08:33:52 <itayd> import Data.Version(showVersion)
08:33:58 <itayd> import Paths_{pacakge}
08:34:01 <itayd> showVersion version
08:34:05 <itayd> thanks folks
08:35:30 <EvanR-work> transformers are getting to me
08:37:02 <EvanR-work> too many moving parts, too many necessary extensions, too much boilerplate
08:37:14 <EvanR-work> kind of ruins haskell
08:37:37 <roconnor> EvanR-work: monad transformers?
08:37:41 <EvanR-work> yes
08:37:47 <EvanR-work> 'transformer stack's
08:37:50 <roconnor> EvanR-work: don't use them.
08:38:02 <roconnor> EvanR-work: just write your own custom monad.  It is more efficent anyways
08:38:11 <roconnor> only use the MonadFoo classes
08:38:14 <EvanR-work> are you saying that because im complaning or because thats what you think
08:38:22 <roconnor> make your structure an isntance of the required classes
08:38:26 <roconnor> EvanR-work: both
08:38:38 <EvanR-work> yeah thats what im thinking 
08:38:50 <EvanR-work> flatten the stack
08:38:58 <irv_> here's my attoparsec test: http://hpaste.org/40712/attoparsec i was expecting try to read ahead and fail gracefully, but it doesn't appear to
08:39:06 <roconnor> People often also compain about having to lift random amounts of time etc. 
08:39:23 <roconnor> it boggle my mind that people are using transformer stacks in the raw.
08:39:31 <roconnor> at the very least wrap your stack in a new type
08:39:38 <Jafet> :t lift
08:39:39 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
08:39:43 <roconnor> write all your new "primitives" using random amounts of lifts
08:39:50 <EvanR-work> well you avoid lift with MonadFoo classes
08:39:51 <roconnor> and then seal it off in your module
08:39:59 <Jafet> Sometimes I find myself wanting a fall
08:40:08 <Jafet> Although I'm still not exactly sure what fall should do
08:41:08 <jmcarthur> roconnor: i think people don't realize that transformers are a means, not an end.
08:42:17 <jmcarthur> roconnor: more generally, i think type composition is greatly underappreciated and misused
08:43:37 <jmcarthur> most people wouldn't keep saying (f . g) in a hundred places when they could just define h = f . g, but they do that with composed types all the time
08:43:40 <jmcarthur> drives me crazy
08:44:42 <dmwit> jmcarthur: There's a difference.
08:44:52 <jmcarthur> yeah, i was trying to think of how to explain that
08:44:57 <dmwit> Writing A (B C) is actually different than (A `O` B) C.
08:45:34 <dmwit> (whereas (f (g x)) and ((f . g) x) are not actually different)
08:46:12 <jmcarthur> the similarity is when you have the choice of exposing both f and g or just h
08:46:40 <EvanR-work> roconnor: 'random amounts of lifts' in your module is the boilerplate im talking about
08:47:09 <EvanR-work> instance MonadFoo where innerAction = lift . innerAction
08:47:21 <jmcarthur> EvanR-work: yeah, that's why you should do that *once* in your module and then never have to think about it again :)
08:47:40 <EvanR-work> jmcarthur: not once
08:47:43 <EvanR-work> several times
08:47:44 <EvanR-work> in your module
08:47:49 <jmcarthur> sure, for entirely different operations
08:48:01 <EvanR-work> and several more times in the same way for a different instance of all those classes
08:48:06 <EvanR-work> in another module
08:48:08 <jmcarthur> but you're essentially doing the same thing even without transformers. you just lose the convenience
08:48:18 <jmcarthur> umm
08:48:26 <roconnor> EvanR-work: you only need to use it when defining your new "primitive operations"
08:48:36 <jmcarthur> you shouldn't have to use lift on a transformer stack from a different module if you are abstracting properly
08:48:41 <roconnor> EvanR-work: that being said, I still suggesting writing your own data structure for serious work.
08:48:54 <roconnor> EvanR-work: monad transformers are mostly for playing around with IMHO.
08:48:56 <jmcarthur> roconnor: why are you suggesting that? performance?
08:49:00 <jmcarthur> i disagree
08:49:08 <jmcarthur> transformers are great, IMO, although they could be better
08:49:16 <EvanR-work> roconnor: does that mean understanding the machinery of Reader Writer, Cont etc?
08:49:28 <EvanR-work> and how to combine them without a transformer
08:49:41 <jmcarthur> EvanR-work: i think roconnor means don't use mtl
08:49:51 <EvanR-work> i understand that
08:50:03 <jmcarthur> Reader, Writer, Cont are mtl
08:50:06 <roconnor> jmcarthur: :) My reasons for not using the mtl are somewhat different from what I'm arguing here
08:50:13 <jmcarthur> roconnor: well, sure ;)
08:50:45 * aristid uses monadLib
08:50:47 <EvanR-work> jmcarthur: your own structure which implements a ReaderT R (WriterT W IO) for example would not use mtl
08:50:52 <jmcarthur> roconnor: but why are transformers just for "playing around"?
08:50:54 <roconnor> I find I writing my own data structure lets me refine my data type more nicely.
08:51:02 <EvanR-work> but youd have to know how to accomplish that without a transformer
08:51:18 <jmcarthur> @unmtl ReaderT R (WriterT W IO) a
08:51:19 <lambdabot> R -> IO (a, W)
08:51:23 <roconnor> jmcarthur: writing your own data types gives you performance and a bit more control
08:51:23 <jmcarthur> like that
08:51:25 <aristid> roconnor: that's because transformers are not the solution to everything. just to some things :)
08:51:26 <EvanR-work> nice command
08:51:32 <jmcarthur> roconnor: what kind of control?
08:51:43 <roconnor> jmcarthur: you get to decide if you want to use continuation implementations of various pieces or not
08:51:54 <jmcarthur> roconnor: i prefer to build up my data types through composition the same way i build up my functions through composition
08:52:04 <quicksilver> as long as you make it abstrac + and just export custom primitives
08:52:12 <quicksilver> then you can switch from transformers/mtl to your own backend later
08:52:24 <EvanR-work> thats what i did
08:52:25 <quicksilver> this strikes me as just good engineering sense.
08:52:33 <EvanR-work> i like the idea of going back and flattening later
08:52:34 <jmcarthur> roconnor: you can make that same decision by using different implementations of the fundamental monads/transformers
08:52:44 <roconnor> quicksilver: exactly
08:52:46 <ksf> flattening should be done by the compiler.
08:52:49 <roconnor> I recommend what quicksiver said
08:52:57 <jmcarthur> i agree with performance though, although it would be better if the compiler did it
08:53:02 <EvanR-work> i think you would write less if you flatten it yourself
08:53:19 <ksf> and if there would be a nicer way to check whether something fused than wading through core
08:53:23 <jmcarthur> i can agree with what quicksilver said too, but only for performance reasons. i don't see any reason on a code readability level for doing it
08:53:28 <aj234> What's the best way to work with a list of strings? I have a list like this: ["1","+","2"] and I want to break it up at the "+" string. I am getting type errors when I try to do span (=="+") LIST
08:53:40 <roconnor> making an abstract interface to your custom monad is far more important than whether or now you use a custom data type or a transfomer stack.
08:53:53 <sipa_> @type (=="+")
08:53:54 <lambdabot> [Char] -> Bool
08:53:54 <ksf> :t span
08:53:55 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:53:59 <jmcarthur> i agree. i just find the latter simpler than rolling my own every time
08:54:04 <ksf> :t break
08:54:05 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:54:22 <sipa_> > span (=="+") ["1","+","2"]
08:54:23 <lambdabot>   ([],["1","+","2"])
08:54:28 <sipa_> > break (=="+") ["1","+","2"]
08:54:29 <ksf> > span (=="+")  ["1","+","2"]
08:54:29 <lambdabot>   (["1"],["+","2"])
08:54:30 <lambdabot>   ([],["1","+","2"])
08:54:36 <EvanR-work> jmcarthur: my gripes were: too many moving parts, too much boilerplate, too much extensions
08:54:46 <ksf> > span (/="+")  ["1","+","2"]
08:54:47 <lambdabot>   (["1"],["+","2"])
08:55:09 <jmcarthur> EvanR-work: i don't understand what you mean by moving parts. as for boilerplate, much of that should be pretty trivial with GeneralizedNewtypeDeriving
08:55:16 <ksf> my chrystal ball says aj234's type error is on the lhs
08:55:19 <jmcarthur> and i don't mind extensions, myself
08:55:25 <EvanR-work> so newtype deriving is a good thing?
08:55:38 <EvanR-work> it is a blessed feature
08:55:41 <jmcarthur> define "good thing"
08:55:41 <aj234> ksf: the lhs?
08:55:42 <ksf> definitely.
08:55:48 <ksf> left hand side.
08:55:55 <ksf> the part on the left of the =
08:56:04 <jmcarthur> EvanR-work: it's commonly used
08:56:04 <aj234> ksf: right right. thanks, I'll look again...
08:56:33 <EvanR-work> jmcarthur: and to get it all to work out, you have to issue several extensions and understand what each is doing
08:56:37 <jmcarthur> EvanR-work: all it does is create an instance that handles the newtype wrapping and unwrapping for you
08:56:54 <jmcarthur> EvanR-work: understanding is a necessity for anything
08:57:12 <jmcarthur> to argue against that sounds like anti-intellectualism to me
08:57:13 <EvanR-work> i think i would have to understand less if i did what roconnor suggested
08:57:19 <EvanR-work> because theres less there
08:57:20 <ksf> understanding what you need to understand and what not even more so
08:57:33 <EvanR-work> fewer moving parts
08:57:36 <jmcarthur> i think there is less when using existing code than when rolling your own, personally
08:57:41 <jmcarthur> what is a moving part?
08:57:43 <jmcarthur> i don't get that
08:57:53 <ksf> ...which wouldn't be anti-intellectualism, but the wisdom of efficiency.
08:57:56 <EvanR-work> a stage in a custom transformer
08:58:05 <jmcarthur> stage?
08:58:10 <EvanR-work> a stage in the whole system, which may be a custom transformer
08:58:20 <EvanR-work> or may just be you using a standard one
08:58:20 <jmcarthur> i think maybe your intuition about transformers is very different from mine
08:58:33 <ksf> don't they form a monad?
08:58:33 <EvanR-work> well i implemented ExitT from memory yesterday
08:58:38 <monochrom> if you don't like it, you can not-use it.
08:58:43 <ksf> shouldn't we all undestand them, thus?
08:59:04 <EvanR-work> and it wasnt that much code, but then combining them i added more code, it all seemed non haskelly
08:59:08 <EvanR-work> too much stuff
08:59:33 <ksf> much plumbing isn't non-haskelly.
08:59:34 <jmcarthur> could you maybe hpaste that code? i want to see what your complaint really is
08:59:37 <ksf> much boilerplate is.
08:59:37 <roconnor> jmcarthur: after thinking about it you are probably right.
08:59:52 <EvanR-work> this plumbing required functional dependencies and three other extensions
08:59:59 <EvanR-work> the functional dependencies required new syntax
09:00:08 <roconnor> jmcarthur: Using transformers is fine (hidden by your own custom interface), until later when you decide it is slow.  Then you can replace it with your custom implementation
09:00:20 <roconnor> jmcarthur: which is made easy by your custom interface!
09:00:25 <jmcarthur> roconnor: yeah!
09:00:49 <EvanR-work> i like the idea of combining simpler monads to get a obvious concatenation of feature of individual ones, but the process wasnt exactly that pleasant
09:00:49 <jmcarthur> the interface is the important thing. that transformers are used at all should be a mere implementation detail
09:00:59 <EvanR-work> its an implementation gripe
09:01:00 <roconnor> EvanR-work: which monads?
09:01:02 <ksf> never weld your plumbing, always use screw connectors?
09:01:04 <jmcarthur> EvanR-work: well, that's actually a flaw with the idea of transformers, IMO
09:01:29 <jmcarthur> EvanR-work: it would be better if we could simply compose two monads rather than having to have this separate concept of transformers
09:01:34 <ksf> er no. always keep them out of the walls, so you don't have to tear the building down when replacing it.
09:01:37 <EvanR-work> roconnor: ExitT, IO, ReaderT R m, and my custom monad
09:01:37 <jmcarthur> there are some ways to do that
09:01:41 <jmcarthur> but not commonly used
09:01:51 <jmcarthur> and perhaps strictly less flexible
09:01:51 <EvanR-work> jmcarthur: hmmm
09:02:12 <monochrom> this is why analogies like "plumbing" are wrong
09:02:33 <ksf> @quote bad explanation
09:02:33 <lambdabot> No quotes for this person. My pet ferret can type better than you!
09:02:35 <jmcarthur> "plumbing" and "moving parts" apply very badly to haskell code, IMO
09:02:40 <ksf> @quote analogy
09:02:41 <lambdabot> lilac says: * lilac looks forward to Cale explaining category theory by analogy to Call of Duty
09:02:45 <ksf> @quote analogies
09:02:45 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
09:02:51 <ksf> @quote analogies
09:02:51 <lambdabot> RaptorJesus says: using analogies on logic is like using a wrench on rivets
09:03:05 <ksf> @quote @quote metaphor
09:03:05 <lambdabot> No quotes match. Take a stress pill and think things over.
09:03:10 <ksf> @quote  metaphor
09:03:10 <lambdabot> tensorpudding says: A monad metaphor is like a metaphor, but less helpful.
09:03:15 <ksf> @quote  metaphor
09:03:15 <monochrom> @quote monochrom analog
09:03:15 <lambdabot> tensorpudding says: A monad metaphor is like a metaphor, but less helpful.
09:03:16 <lambdabot> No quotes match. :(
09:03:19 <roconnor> is ExitT isomorphic to MaybeT?
09:03:39 <ksf> @quote  analogy in the category
09:03:39 <lambdabot> No quotes for this person. I feel much better now.
09:04:00 <shachaf> @quote in.the.category
09:04:00 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
09:04:08 <ksf> hey.
09:04:27 <ksf> even google can't find "A metaphor is an analogy in the category of bad explanations"
09:04:56 <monochrom> yeah I recall that one
09:05:16 <shachaf> ksf: "analogies are endofunctors in the category of bad explanations", maybe?
09:05:33 <shachaf> @quote bad.explanations
09:05:33 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
09:06:33 <EvanR-work> roconnor: the way i defined it, runExit or runExitT must exit or its an error
09:06:45 <EvanR-work> i think Maybe results in Nothing or Maybe a
09:08:51 <ksf> fsck.
09:08:59 <ksf> I don't want to think about authentication.
09:09:23 <EvanR-work> authentication in general? for a website? for an api? 
09:10:01 <ksf> in an api, generalising over unix file permissions, http cookie or such auth and 9p etc.
09:10:36 <EvanR-work> sounds hairy
09:10:43 <ksf> yep.
09:10:52 <EvanR-work> is this generalization justified ;)
09:11:12 <monochrom> A lot of questions including "why would people use X" are pointless. If you know a better way, publish or perish. If you are "just curious", then "if you have to ask, you are not ready to know" applies.
09:11:44 <ksf> well, currently the only backend is fuse, and not even that is working, but I strive to serve one filesystem over all of http, fuse, and 9p.
09:11:52 <ksf> prolly ftp and others, too.
09:12:20 <ksf> ...fuse is because I'm lazy right now, http is almost a must these days, and 9p is the thing that actually makes most sense.
09:12:45 <ddarius> monochrom: If I won't perish if I don't publish, why would I publish rather than exploit the information gradient?
09:12:50 <ksf> ...a bi-directional dialect of 9p, that is. just a minimum-fuzz, maximum efficiency rpc layer.
09:13:35 <ksf> well. I could just use the unix model and make http use the same.
09:13:41 <ddarius> Admittedly, at that point I probably wouldn't be asking the original question.
09:13:44 <monochrom> har har
09:14:04 <aristid> ddarius: maybe the theory is that not immediately perishing allows better publications eventually
09:14:10 <monochrom> what is information gradient?
09:14:43 <EvanR-work> is -< and -<< a keyword?
09:14:46 <fasta> A fancy word that I think was ill-typed. 
09:14:47 <ksf> if it survived for 40 years, it's probably good enough.
09:15:08 <EvanR-work> or only with extensions
09:15:18 <McManiaC> arrow extension, EvanR-work 
09:15:28 <McManiaC> at least -<
09:16:05 <EvanR-work> <- is vanilla allowed in guards?
09:16:22 <McManiaC> nope
09:16:25 * hackagebot monadLib-compose 0.2 - Arrow-like monad composition for monadLib.  http://hackage.haskell.org/package/monadLib-compose-0.2 (AristidBreitkreuz)
09:16:27 <aristid> EvanR-work: parse error when reading your statement
09:16:28 <EvanR-work> oh
09:17:11 <monochrom> http://www.hck.sk/users/peter/HaskellEx.htm is very useful for looking up haskell 98 syntax
09:17:29 <EvanR-work> aristid: vanilla :: Adverb; vanilla = without extensions
09:18:35 <aristid> EvanR-work: so it is '"<-" is (vanilla allowed) in guards?"
09:18:46 <McManiaC> <McManiaC> nope
09:18:48 <McManiaC> try it ;)
09:18:59 <EvanR-work> aristid: yeah
09:19:05 <aristid> McManiaC: um i'm just trying to parse the syntax of EvanR-work's statement
09:19:15 <EvanR-work> http://haskell.org/haskellwiki/Keywords#.7C this page lists it
09:19:19 <McManiaC> ah lol
09:19:25 <monochrom> "is <- allowed in guards in haskell 98/2010"
09:19:29 <Twey> I think it's a sort of adverb, in the APL sense
09:19:35 <Twey> Vanilla-allowed
09:19:37 <aristid> monochrom: that would have been easy
09:19:41 <aristid> TOO easy
09:19:53 <monochrom> cf the "too many moving parts" argument
09:20:10 <EvanR-work> generalized parts of speech
09:20:10 <aristid> i wish there were closed classes
09:20:19 <monochrom> "why would people say 'vanilla allowed'? too many things to understand. too many moving parts"
09:20:36 <aristid> "only the instances in this module exist, remember that, GHC"
09:20:36 <Twey> Heh.
09:20:54 <co_dh> looks like APL guys comes to Haskell
09:20:56 <EvanR-work> forall words a for all parts of speech t, a can be instance of t
09:20:58 <EvanR-work> 'google it' ;)
09:21:31 <EvanR-work> friend me
09:21:45 <EvanR-work> i really hate friend (verb) because theres already a word for it
09:21:46 <EvanR-work> befriend
09:22:02 <aristid> <jacquesm> hn is like the haskell of forums
09:22:02 <aristid> <jacquesm> avoid growth at any cost
09:22:02 <aristid> <jacquesm> and yet it grows :)
09:22:18 <monochrom> hahaha
09:22:24 <dstcruz> how can I get a grouping out of a regex? like so:  "this here number 123 is not 234" =~ "number ([0-9]+)"  <--- I want to get the stuff in ()
09:22:25 <monochrom> but what is hn?
09:22:32 <aristid> monochrom: news.ycombinator.com
09:22:37 <monochrom> thanks
09:22:57 <ksf> it's an elitistic bunch of reddit haters.
09:22:58 <dstcruz> if I do :: String, I get "number 123"
09:23:11 <ksf> ...reddit being an elitistic bunch of digg haters.
09:23:37 <aristid> ksf: the internet is a matryoshka puppet of haters
09:23:54 <dstcruz> maybe I need to include hn in HWN? Hmmmm... would be hard to filter haskell specific news?
09:23:56 <ksf> who's at the bottom? youtube or myspace?
09:24:11 <EvanR-work> i would avoid the question of bottom by using a fixed point in the description
09:24:15 <jmcarthur> 4chan?
09:24:30 <sipa_> dstcruz: "(number [0-9]+)"
09:24:30 <aristid> maybe it's cyclic
09:24:30 <ksf> well, yes, that'd be the fixpoint.
09:24:34 <EvanR-work> or making it a cyclic heirarchy
09:24:43 <monochrom> I am an elitistic hater of reddit. maybe I will like news.ycombinator.com
09:25:03 <EvanR-work> you are yourself already in one of the puppet pieces
09:25:03 <jmcarthur> i was thinking that too :P
09:25:19 <monochrom> actually, no, I am too elitistic to care. :)
09:25:44 <ksf> the proggit and haskit sometimes even sounds like ltu, just without all that damnable respect and other nonsense.
09:25:59 <jmcarthur> ltu is great
09:26:01 <dstcruz> sipa_: that would return the string "number", but I'm only interested in the actual number
09:26:12 <jmcarthur> ltu is what got me into functional programming
09:26:21 <sipa_> dstcruz: oh i misunderstood your question
09:26:22 <ksf> ...people complain about not enough code on the proggit, but then everybody's glad that the dumb code questions get voted down.
09:26:28 <sipa_> dstcruz: what library or so ar you using?
09:26:38 <aristid> jmcarthur: c++ templates are what got me into functional programming :P
09:26:43 <ksf> you can't make puns on ltu.
09:26:46 <dstcruz> Posix
09:26:53 <ksf> the whole thing is dryer than dune.
09:26:54 <sipa_> the () capture subpatterns, which should be able to be extracted separately
09:26:57 <jmcarthur> they convinced me with long, thought-out arguments that the type systems i was familiar with were far less powerful than those of the languages they more often speak of in ltu
09:27:20 <jmcarthur> ksf: but it has the spice
09:27:27 <dstcruz> sipa_: I'm not sure about which RegexContext to use to extract the () stuff
09:27:58 <aristid> jmcarthur: what were you familiar with?
09:28:16 <jmcarthur> aristid: mostly imperative languages... and scheme
09:28:24 <jmcarthur> which barely counts
09:28:40 <jmcarthur> even that was only cursory knowledge
09:28:45 <ksf> scheme is strictly typed.
09:28:50 <sipa_> dstcruz: don't you get an array or a list somewhere out of the match?
09:28:53 <ksf> you don't even get unsafecoerce.
09:28:57 <aristid> i do think scheme counts, it's not that functional, but it does lead you to think about some things differently
09:28:57 <jmcarthur> ksf: strongly you mean?
09:29:14 <jmcarthur> aristid: sure, but it doesn't push the boundaries of type systems specifically
09:29:17 <ksf> I might.
09:29:18 <aristid> hmm i forgot to avoid the word "functional"
09:29:34 <ksf> it might have been an accident to use "strictly", but then I like the term.
09:29:34 <jmcarthur> i understood your gist
09:29:54 <jmcarthur> ksf: you could be correct if you meant in contrast to lazily typed ;)
09:29:56 <EvanR-work> functional is dysfunctional
09:30:01 <EvanR-work> freedom is slavery
09:30:09 <ksf> where unsafeCoercing would make stuff loosely typed.
09:30:25 <jmcarthur> weakly is the opposite of strongly in that sense
09:30:39 <dstcruz> sipa_: you can do :: [String], but that just returns all the matches, no the same as returning an array of submatches
09:30:41 <ksf> yeah, but people even call pascal strongly typed.
09:30:43 <EvanR-work> strong typing is weak
09:30:51 <aristid> jmcarthur: the appeal of type safety seemed ever more compelling to me after having longer-running tasks crash due to an error in how some object method was used
09:30:58 <MyWhi> Hello everyone!
09:31:00 <jmcarthur> people confuse "strongly" and "statically" quite often
09:31:30 <ksf> the thing that sold me to HM was realising that when I use dynamic type systems, I got to do all the inference and stuff myself.
09:31:35 <jmcarthur> aristid: oddly the language i was most infatuated with before coming to haskell was Io. can't really get much more "dynamic" than that
09:32:01 <sipa_> dstcruz: http://hackage.haskell.org/packages/archive/regex-base/0.93.1/doc/html/Text-Regex-Base-RegexLike.html#t:MatchResult
09:32:20 <sipa_> you can get such a 'MatchResult'? the mrSubList or mrSubs is what you need i think
09:32:41 <MyWhi> does haskell have something default to remove double parentheses? Eq from "((double)) ((not remove this) here)" to "double ((not remove this) here)", so multiple parentheses removal?
09:32:45 <jmcarthur> aristid: i don't think it currently is, but at one time Io's parser was written in itself and it somehow bootstrapped properly!
09:32:54 <jmcarthur> and you could even replace the parser at runtime
09:33:10 <jmcarthur> i think you still can do that, actually, although the default parser is in C
09:33:20 <aristid> jmcarthur: huh? why did they change that?
09:33:26 <jmcarthur> speed
09:33:35 <EvanR-work> can i 'bust out' a where block in the middle of a do block
09:33:38 <jmcarthur> you can still change out the parser for one written in Io anyway though
09:33:45 <EvanR-work> i hate let in do
09:33:59 <dstcruz> sipa_: ah, thanks! now to try to understand how to use that thing...
09:34:11 <jmcarthur> it's been a long time since i used it now. things are probably very different
09:34:13 <MyWhi> anyone who can look at my question? :)
09:34:24 <dstcruz> MyWhi: as in, can the compiler do that?
09:34:40 <MyWhi> well, or some function for the easy way 
09:34:53 <monochrom> no function in the lib does that
09:34:56 <MyWhi> im pretty sure that its possible for the compiler
09:34:59 <MyWhi> ah :(
09:35:30 <MyWhi> im guessing that would be pretty hard to code in haskell?
09:35:39 <sipa_> i think it would be very easy
09:35:59 <aristid> MyWhi: are you trying to tease us into writing code for you? :)
09:36:15 <monochrom> i think your specification is vague
09:36:21 <MyWhi> aristid: I can tease better I think :p
09:36:27 <jmcarthur> MyWhi: it should be very easy to do something like that with parsec or something
09:36:38 <jmcarthur> although even that may be overkill
09:36:47 <MyWhi> i'd like to be able to understand it myself but I was wondering if something easy is available for that
09:37:05 <ksf> MyWhi, try hint.
09:37:10 <ksf> and there's @pl
09:37:15 <MyWhi> @pl?
09:37:16 <lambdabot> (line 1, column 1):
09:37:16 <lambdabot> unexpected end of input
09:37:16 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:37:18 <ksf> @pl ((double)) ((not remove this) here)
09:37:18 <lambdabot> double (not remove this here)
09:37:49 <MyWhi> yeah but thats not correct, it should be double ((not remove this) here)
09:37:57 <jmcarthur> well, it's correct for haskell syntax
09:38:01 <ksf> no, it shouldn't.
09:38:19 <jmcarthur> i think MyWhi is asking for a generic string function, not one to parse haskell syntax
09:38:23 <jmcarthur> but i could be wrong
09:38:28 <MyWhi> no you are right
09:38:38 <sipa_> MyWhi: you want to do that on haskell code or not?
09:38:54 <jmcarthur> something like String -> String
09:38:57 <MyWhi> yes
09:39:03 <ksf> ...haskell doesn't know such esoteric stuff like functions with multiple arguments.
09:39:10 <MyWhi> its for mathematical strings to read it for me more easily so things like (1)  + ((2*4)+4)
09:39:16 <sipa_> ok
09:39:17 <MyWhi> but then more complex
09:39:26 <aristid> MyWhi: then you could, if you feel fancy, use one of the parser frameworks for it
09:39:29 <monochrom> learning parsing
09:39:36 <MyWhi> so for more readability (users tend to put too much parentheses in it)
09:39:37 <jmcarthur> parsec :D
09:39:39 <ksf> showsPrec can do such stuff.
09:39:52 <aristid> ksf: only if you have it as a data structure, right?
09:39:55 <aristid> :t showsPrec
09:39:56 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
09:40:08 <ksf> yeah, but that should be easy with formulae
09:40:11 <MyWhi> showsPrec, never heard of that before, let me check
09:40:31 <MyWhi> hm
09:40:32 <MyWhi> http://zvon.org/other/haskell/Outputprelude/showsPrec_f.html
09:40:39 <MyWhi> no examples
09:40:55 <ksf> zvon is about the worst source for docs there is
09:40:57 <monochrom> > (((a))) + (b*c)
09:40:59 <lambdabot>   a + b * c
09:41:14 <MyWhi> i always use zvon 
09:41:27 <MyWhi> maybe im just not knowing the proper pages :)
09:41:34 <ksf> try hoogle and hayoo
09:41:43 <ksf> ...and, of course, hackage.
09:42:25 <sipa_> > show $ read "((('a'))) + ('b'*'c')"
09:42:26 <lambdabot>   "*Exception: Prelude.read: no parse
09:43:13 <EvanR-work> roconnor: so you think liftIO is an example of inappropriately using raw transformers
09:43:26 <EvanR-work> liftIO outside of a module implementation
09:43:43 <MyWhi> well the haskell site doesnt show much information om showsprec either
09:43:56 <ksf> look at the source
09:44:12 <ksf> ...it's the prelude, after all.
09:44:59 <ksf> can the hugesPJ pretty printers etc. do such stuff?
09:45:02 <jmcarthur> EvanR-work: liftIO is one of those weird ones. sometimes you can hide it, sometimes you can't
09:45:10 <ksf> those might have better docs
09:45:27 <EvanR-work> jmcarthur: its a mess!
09:45:41 <jmcarthur> EvanR-work: often you can think of specific IO actions that you will want to perform and no others, in which case you can hide liftIO pretty easily. other times, you actually want to allow arbitrary IO actions, so you can't really remove it
09:46:09 <jmcarthur> EvanR-work: i wish more IO actions were defined in terms of a MonadIO by default, but that comes with its own problems
09:46:15 <EvanR-work> like what
09:46:20 <monochrom> pretty printer's only extra capability is indenting and breaking lines at good places
09:46:26 <MyWhi> showsPrec returns a Show?
09:46:30 <jmcarthur> exception handling gets pretty hairy, for example
09:46:32 <aristid> EvanR-work: like MonadIO not being in base
09:46:35 <ksf> nope a ShowS
09:46:38 <ksf> which is String -> String
09:46:49 <ksf> ...to append stuff efficiently.
09:46:51 <jmcarthur> aristid: well, i was assuming that it would be put in base in order for that to work at all ;)
09:47:10 <EvanR-work> @src MonadIO
09:47:11 <lambdabot> Source not found. Do you think like you type?
09:47:21 <monochrom> showsPrec is a type class method, so there is little source code to see.
09:47:27 <aristid> jmcarthur: right, that would help
09:47:51 <MyWhi> i looked into the source but i dont see anything useful there as source
09:47:54 <jmcarthur> but the ever increasing complexity of packages like MonadCatchIO shows some of the difficulties
09:49:08 <ksf> > showHex 3735928559 " is not very delicious"
09:49:09 <lambdabot>   "deadbeef is not very delicious"
09:49:24 <jmcarthur> EvanR-work: a neat way to avoid having IO at the bottom of your transformer stacks at all is to use something like MonadPrompt. i admit that i don't actually use it very often though, and it still requires you to come up with specific actions you want to expose
09:49:30 <jmcarthur> and it's more to learn
09:49:47 <ksf> MyWhi, look at the instances, there's a gazillion of them.
09:49:57 <EvanR-work> i can only think of situations where id want specific actions
09:50:03 <jmcarthur> the nice thing is that it allows you to define different kinds of "run" functions. some can use IO, others could be pure for testing, etc.
09:50:22 <EvanR-work> restricted IO seems the sanest, i mean, unrestricted IO is basically php
09:50:29 <jmcarthur> yeah :)
09:50:40 <MyWhi> ksf, ive been trying some entries fro showsPrec but it seems to add stuff here instead of removing entries, maybe Im doing it all wrong :)
09:50:44 <jmcarthur> then i would not expose any liftIOs for your type
09:50:58 <EvanR-work> not an instance of monadio?
09:51:45 <jmcarthur> right. if you don't want to allow arbitrary IO, don't :)
09:51:46 <monochrom> as for showsPrec source code for specific instances like Integer, they pretty much don't care about parentheses, there is not much relevance
09:52:06 <jmcarthur> just implement the appropriate actions behind your interface
09:52:08 <EvanR-work> jmcarthur: implement the IO in terms of raw lifts?
09:52:11 <jmcarthur> no
09:52:17 <ksf> % should have one.
09:52:18 <jmcarthur> don't expose a MonadTrans instance either
09:52:21 <jmcarthur> or whatever
09:52:25 <EvanR-work> by raw i mean...
09:52:28 <ksf> er :%
09:52:28 <EvanR-work> however lift works
09:52:33 <jmcarthur> all this transformer stuff shouldn't invisible outside the module
09:52:38 <jmcarthur> err
09:52:40 <ksf> :, too, but that's most likely some inbuilt magic.
09:52:40 <monochrom> the only relevant source code would be someone else's (not in the standard lib) Show instance for his/her homebrew abstract syntax tree.
09:52:41 <jmcarthur> *should be invisible
09:52:45 <MyWhi> well monochrom as far as I tested all the showsPrec does is add stuff 
09:53:15 <jmcarthur> EvanR-work: i mean you can use liftIO *inside* the module, but don't make a MonadIO instance for your exposed type
09:53:24 <jmcarthur> unless you want to allow arbitrary actions
09:53:47 <ksf> unsafeLiftIO
09:53:53 <EvanR-work> oh
09:53:57 <jmcarthur> or you could expose something silly like that ;)
09:54:11 <monochrom> but then there are two problems. (1) the focus on showsPrec is efficiency. you may as well ignore showsPrec and just work on show for starters. (2) the real question is parsing, not showing. showing is trivial, everyone can do that.
09:54:50 <monochrom> So I completely fail to understand why showsPrec was brought up to begin with for a parsing question. Unless you're sabotaging the asker.
09:55:11 <ksf> at least parsec and frisby support (relatively) painless precedence parsing
09:55:26 <ksf> but I was assuming the input is haskell code.
09:55:26 <MyWhi> maybe i'm not seeing it properly but how will showsPrec be able to get me from "((no)) ((yes two) two)" to "no ((yes two) two)", as far as I can see showsPrec adds stuff while I need less stuff
09:55:35 <MyWhi> and its not haskell code
09:55:40 <ksf> oh.
09:55:41 <MyWhi> but mathematical strings
09:55:45 <jmcarthur> EvanR-work: it's all about designing an interface that you want and *then* using transformers (or not) to implement it
09:56:00 <MyWhi> its for a better readability of whats written :)
09:56:33 <ksf> gf should be able to do it, too, and you'd get a parser _and_ unparser for the same source.
09:56:39 <ksf> but then, gf is a bugger to get started with.
09:57:05 <dmwit> Hey, let's keep it PG-13, ksf.
09:57:09 <MyWhi> oh
09:57:23 <abstrakt> hey, anyone know if it's possible to install the haskell platform onto something other than my system disk?
09:57:37 <monochrom> you are sabotaging the asker. you are suggesting bigger and bigger hammers. your next suggestion may be Epigram.
09:57:38 <MyWhi> gf is a parser or something?
09:57:56 <EvanR-work> jmcarthur: right, i made something from scratch that did all kinds of stuff but didnt use IO
09:58:00 <dmwit> abstrakt: On Windows? It asks where you want to install.
09:58:12 <abstrakt> dmwit: nope, sorry forgot to specify... on mac
09:58:15 <ksf> grammaticalframework.org
09:58:19 <EvanR-work> now for this, im using IO, and i decided combining two already existing monad
09:58:26 <jmcarthur> great!
09:58:27 <abstrakt> the "installer" for haskell on mac doesn't give me the option
09:58:42 <EvanR-work> and i landed in a tarpit ;)
09:59:13 <EvanR-work> jmcarthur: what about if you want to allow nothing but putChar ;)
09:59:25 <EvanR-work> it must be named something besides putChar i guess
09:59:30 <jmcarthur> EvanR-work: you expose a putChar function
09:59:39 <MyWhi> that gf seems like something completely new, and I dont fully understand Haskell yet 
09:59:48 <ksf> http://www.grammaticalframework.org/doc/gf-tutorial.html#toc132
10:00:01 <jmcarthur> it could be named the same, but would probably need to be used with a qualified import
10:00:07 <jmcarthur> which isn't necessarily bad
10:00:21 <EvanR-work> and Prelude.putChar in the implementation
10:00:26 <jmcarthur> yes
10:00:29 <dmwit> MyWhi: I hate to jump in the middle of something, but... what's the top-level goal you're trying to achieve?
10:01:05 <bos31337> let's scrumble!
10:01:13 <monochrom> what is scrumble?
10:01:17 <MyWhi> well, im trying to achieve to remove useless parentheses, eq from "((double)) (useless) ((useful here) and this)" to "double useless ((useful here) and this)"
10:01:36 <ksf> ...but with gf, you can translate "1+2" to "one plus two", "eins plus zwei" etc basically for free.
10:01:55 <dmwit> MyWhi: And is your input a String that somebody else made, or have you mistakenly created that String when you wanted to make the other?
10:02:13 <MyWhi> dmwit:, the input is from someone else indeed
10:02:16 <EvanR-work> ast -> transform ( ((x)) -> (x) ) as many times as needed -> toString
10:02:21 <dmwit> MyWhi: For the former, you need a parser and pretty-printer; for the latter you just need to improve your pretty-printer. =)
10:02:40 <ddarius> In the interest of abstraction, the rain forest, and energy conservation I'm coining the word "vapous" which combines the meanings of "vacuous" and "vapid."
10:03:03 <MyWhi> hm
10:03:05 <EvanR-work> fewer moving parts, i like it
10:03:32 <monochrom> "vacuous and vapid" seems a bit redundant.
10:03:33 <jmcarthur> are you just using the phrase "moving parts" to annoy me now? ;)
10:03:40 <sanders> for some reason cabal keeps re-installing all my dependencies every time I install a package, anyone had that problem before?
10:03:41 <EvanR-work> yes
10:03:58 <EvanR-work> jmcarthur: but i was talking about vapous
10:04:04 <EvanR-work> so i was trying to annoy monochrom 
10:04:11 <jmcarthur> yeah i understood the context :P
10:04:22 <dmwit> MyWhi: If you've never done Haskell, then I suggest Parsec for parsing and a hand-written pretty-printer (assuming efficiency isn't an issue...?).
10:04:40 <MyWhi> it can take an hour to complete, that doesnt matter :p
10:04:43 <MyWhi> time is no issue
10:05:00 <dmwit> MyWhi: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html is still the best intro to Parsec
10:05:09 <monochrom> hahaha
10:05:47 <dmwit> Be sure to ask more specific questions as they come up. =)
10:06:19 <dmwit> monochrom: laughing at me? =/
10:06:26 <monochrom> at moving parts
10:06:55 <monochrom> cabal (cabal-install) works fine for me. it never re-installs installed packages on me.
10:07:03 <monochrom> (or on my computer)
10:08:04 <jmcarthur> it has done it to me before, but i don't remember why
10:08:26 <monochrom> but generally the paradox is: if you have the same package same version installed twice, cabal's delicate logic may decide it wants to install more times.
10:08:31 <dmwit> It has installed different versions of packages that I already had to satisfy some dependencise.
10:08:58 <dmwit> Oh, yeah!
10:09:16 <dmwit> And I noticed that it made different install plans if I did "cabal install foo bar" than if I did "cabal install foo; cabal install bar".
10:09:28 <dmwit> i.e. the former wanted to build and install quux but the latter didn't.
10:10:10 <ologNation> Hm.  A function is saying "symbol-definiton is void: rest"
10:10:12 <monochrom> the logic is like this: you have two instances P0,P1. P0 is shadowed by P1, so P0 is ignored. P1 is found to be unusable, some weird conflict etc, so P1 is ignored too. oh no, now we have no usable instance at all, need to install moar
10:10:18 <ologNation> Ooops.  Emacs again. Sorry guys. 
10:10:30 * ologNation needs to practice tabbing between channels. 
10:10:34 <ologNation> Hi conal. 
10:11:00 <monochrom> was that scheme?
10:12:11 <ologNation> Yeah. 
10:12:19 <ologNation> Er.  Elisp. 
10:12:39 <ologNation> I was asking a question re: this great paste: http://paste.lisp.org/display/115733
10:12:52 <ologNation> I *do* have a haskell-relevant version of the question though. 
10:13:08 <ologNation> Question:  Is it possible to precisely control the color of each character in yi? 
10:13:13 <monochrom> my only regret with scheme is that its standard does not provide "define your own algebraic data type" and pattern-matching over them. Yes yes, every implementation provides its own.
10:13:38 <monochrom> (these days I don't even regret dynamic typing anymore)
10:13:47 <conal> ologNation: hi
10:14:49 <ologNation> Hey Conal. 
10:14:53 <ologNation> Just rushing off to class. 
10:15:01 <ologNation> You know some topology, don't you? 
10:15:04 <conal> ologNation: have fun!
10:15:12 <conal> ologNation: i don't remember much of it
10:16:17 <ddarius> monochrom: You are supposed to stick to a single implementation and form pep rallies around it.
10:19:10 <monochrom> hahaha
10:19:28 <Jafet> There's a big noisy racket around one of them now.
10:22:38 <merijn> monochrom: Actually I just finished an article by Steve Yegge on dynamic vs static typing and one metaphor he stated that really struck me was "Programming with static typing is [for] building hardware". I actually kind of like that distinction
10:23:48 <merijn> I like being able to slowly build something rock solid using something like Haskell's type system. But when I'm using program I much prefer a dynamic system like python where I can change my program under me while running without even restarting my code.
10:24:59 <EvanR-work> merijn: how does that work in python?
10:25:13 <merijn> EvanR-work: Evil hacks using eval :p
10:25:33 <merijn> Although writing code to dynamically load other files at run time is pretty trivial
10:25:38 <EvanR-work> a long running python program which uses eval and dynamic loading sounds insane
10:25:41 <merijn> Now to be fair I think I have a paper lying around on how to accomplish dynamic code loading in Haskell, but that's still not the same and I think both things are equally useful/desirable at different times
10:26:06 <EvanR-work> a python script which runs periodically and doesnt need all that makes sense
10:26:15 <EvanR-work> but then, haskell could do that just as easily
10:26:43 <EvanR-work> a runs forever rock solid daemon is heavy duty stuff, i think think python is up to it
10:27:07 <zygoloid> if you can avoid leaking file handles ;)
10:27:11 <EvanR-work> especially with dynamic code loading, how would you possibly test it before doing it
10:27:23 <EvanR-work> zygoloid: i meant to say i *dont* think
10:27:23 <merijn> EvanR-work: You don't? That's the point
10:27:30 <EvanR-work> you dont test it
10:27:37 <EvanR-work> so youre ok with the server crashing
10:27:39 <merijn> EvanR-work: You'd be wrong on long running python daemons
10:27:45 * zygoloid had major problems with a runs forever rock solid daemon in python because the subprocess module leaks fd's if it gets an EAGAIN
10:28:00 <zygoloid> EvanR-work: it's working pretty well now
10:28:04 <EvanR-work> if youre ok with the server crashing, whats the point of it being a daemon
10:28:09 <merijn> Twisted is pretty rock solid
10:28:17 <merijn> EvanR-work: Who said we were discussing daemons?
10:28:26 <EvanR-work> whatever you want to call it
10:28:37 <merijn> EvanR-work: Regardless, that's not the point I was trying to make
10:29:31 <tab> merijn: the disctinction between hardware and software is flawed. I actually want my software to run as stable as hardware
10:29:42 <merijn> EvanR-work: My point was that both extremes have their own pros and cons and you'd use them in different situations.
10:30:19 <EvanR-work> ive been lately trying hard to see any pro to dynamic typing, difficulty in testing, and lack of compile time checking
10:30:34 <merijn> tab: Really? A lot of end-user software I want to be able to do whatever the hell I want at runtime while in the programming without writing and testing code outside the program and then having to restart my program
10:30:52 <EvanR-work> if it crashes its going to have to restart anyway
10:31:08 <EvanR-work> not sure i see the point of reloading while its running
10:31:42 <tab> merijn: it depends what you're talking about in the end. you seems to make a generic point out of a specific case (script and tinkering)
10:32:55 <EvanR-work> i do do a lot of tinkering in ghci
10:33:13 <merijn> tab: Well, got kinda sidetracked. monochrom was remarking that he didn't even mind dynamic typing anymore, I was trying to point out both approaches are entirely different approaches to software and claiming one to be better then the other is rather pointless as they are not used the same way and not used for the same things
10:33:14 <EvanR-work> dont see how removing compile time checks helps with tinkering
10:33:58 <merijn> EvanR-work: I take it you don't really see anything in Lisp Machine and Smalltalk like systems then?
10:34:00 <EvanR-work> merijn: they are used the same way when youre trying to write correct code, you have all the 'static' types in your mind when write script code, you just have to ensure those constraints are satisfied manually
10:34:41 <merijn> And I don't mean just the language, but the Lisp and Smalltalk OS/environment going with it
10:35:08 <EvanR-work> those systems have a major difference in 'programs in general', they have implicit state or database that must be maintained and can be mutated in an imperative way
10:35:15 <EvanR-work> very object oriented
10:35:42 <merijn> EvanR-work: Quite a lot of programs function like that, though
10:35:56 <EvanR-work> programs sholdnt function like that, your shell environment should work like that
10:36:23 <merijn> EvanR-work: Emacs? Microsoft Excel? Firefox?
10:36:23 <EvanR-work> a database should be identified as one rather than keeping tiny databases everywhere
10:36:53 <EvanR-work> firefoxs main function is a webbrowser, which requests information, its caching bookmarks and saving to disk the content is auxilliary
10:37:31 <merijn> EvanR-work: I'm talking about GreaseMonkey dynamically reloading and running addons. (Addons are the only reason Firefox does so well)
10:37:48 <EvanR-work> firefox does so well because its ingrained in the mindshare of the masses
10:38:01 <EvanR-work> no one thinks about why they use their browser
10:38:19 <silver> how he got there?
10:38:34 <silver> it i mean
10:38:37 <EvanR-work> the universe was created in that state last thursday
10:38:49 <silver> no way
10:38:54 <dmwit> You postulate a much longer history than I do.
10:38:58 <EvanR-work> lol
10:38:58 <abstrakt> has anyone in here tried installing ghc via homebrew/macports?
10:39:02 <abstrakt> I'm getting an error :(
10:39:14 <abstrakt> Error: No such file or directory - /usr/local/Cellar/ghc/6.12.2/bin/ghc
10:39:20 <merijn> EvanR-work: At any rate, this discussion is rather pointless as we obviously fundamentally disagree on some perspectives software so lets leave at it that.
10:39:26 <EvanR-work> merijn: are you talking about a web framework?
10:39:27 <abstrakt> this is right after it runs /bin/pax -f ghc.pkg/Payload -p p -rz
10:39:42 <dmwit> The universe hasn't been created yet; "now" is just a memory from the future.
10:39:55 <EvanR-work> assuming you dont have insane long-running requests handlers, you can easily reboot the web service, fastcgi thing
10:40:32 <EvanR-work> dynamic loading of a fastcgi makes no sense, no ones requests should take long enough that you need to preserve them
10:40:46 <EvanR-work> its not a MUD server
10:41:26 <EvanR-work> merijn: im just looking for ways to make things work more often
10:41:32 <EvanR-work> spend less time fixing stuff
10:42:21 <EvanR-work> oop dynamic screwing around systems are great for 16 year old web hipsters but not for serious engineering
10:42:32 <merijn> EvanR-work: Your statement about that's how a shell environment should work, not other software. My statement is that more user software fits this description and thus the same model applies to quite a bit more software and hence this model is more suitable on occasion. Does that summarize our disagreement?
10:42:38 <EvanR-work> rabble rabble
10:43:59 <EvanR-work> if you clearly identify the parts of the software that require the added order of magnitude of complex of your description of most software, the text buffer, the data base, the cache etc, you are in much better shape than saying the entire system must be composed of persistent data storages
10:44:06 <EvanR-work> complexity*
10:44:11 <EvanR-work> merijn: probably
10:44:11 <merijn> EvanR-work: I agree that haskell's type system is far nicer for "serious engineering", hence why I brought up the Steve Yegge example of comparing such static typing to "writing hardware" which I thought was a nice perspective for looking at stuff like high demand servers
10:44:27 <roconnor> merijn: link?
10:44:37 <merijn> roconnor: http://steve-yegge.blogspot.com/2007/01/pinocchio-problem.html
10:44:42 <roconnor> thx
10:44:45 <abstrakt> grrr... trying to install haskell through homebrew craps out on me, http://pastie.org/1235988
10:44:48 <abstrakt> any ideas?
10:45:16 <dmwit> abstrakt: Perhaps you'd better ask on an appropriate mailing list.
10:45:29 <EvanR-work> merijn: i like the idea of producing a part of the system for the management which works like hardware
10:45:32 <abstrakt> dmwit: yeah I'm asking in #machomebrew so far
10:45:36 <abstrakt> but they don't seem to know
10:45:40 <abstrakt> I dislike mailing lists
10:45:40 <EvanR-work> while the rest of the system in php falls apart on a daily basis
10:45:55 <Jafet> Macho, me brew?
10:46:12 <merijn> EvanR-work: My current view (this tends to change like monthly) is that the most desirable approach would probably be to create a static core in something like haskell then implement any actual user facing UI using something dynamic interfacing with the core.
10:46:18 <EvanR-work> if its less reliable and you spend more time fixing it, wheres the pro
10:46:40 <EvanR-work> that makes sense, i havent figured out user interfaces yet
10:47:03 <siracusa> Is there a way to make GHCi load .hsc files, i.e. execute hsc2hs each time the file is reloaded?
10:47:08 <EvanR-work> its a giant puzzle
10:47:13 <Jafet> So, what language is better than Haskell at expressing user interfaces?
10:47:26 <EvanR-work> visual basic
10:47:30 <EvanR-work> 6
10:47:35 <abstrakt> cocoa?
10:47:37 <c_wraith> tcl/tk. :P
10:47:42 <EvanR-work> javascript
10:47:43 <abstrakt> (aka objective-c aka nextstep) 
10:47:48 <abstrakt> yah, all those
10:48:01 <abstrakt> HTML/CSS
10:48:17 <EvanR-work> html/css are horrible at user interfaces
10:48:20 <c_wraith> No, html/css is not good for user interfaces. That's the only one I have to disagree with
10:48:27 <Jafet> No, nextstep is just something you take a screenshot of to put on the computers in the background of your set to make your television show look trendy.
10:48:41 <roconnor> is tcl/tk better than GuiTV?
10:48:42 <Jafet> It worked for SEL.
10:48:45 <abstrakt> meh, whatever... I think HTML/CSS is fine for UI but maybe your definitions of UI are different
10:48:48 <merijn> EvanR-work: An example before I call it quits to avoid going in circles: I think Blizzard's World of Warcraft user interface is an example of this sort of thing and its a shiny beacon of execution. They only wrote interface rendering core in (I'm guessing) C/C++, the actual user interface was written in Lua and could be changed at runtime by users.
10:48:54 <abstrakt> I guess it all depends on what you want that UI to *do*
10:49:13 <c_wraith> abstrakt, html/css has *no* abstraction facility.  That, alone, makes it horrible for doing UI with
10:49:15 <abstrakt> that's different, but simply expressing the UI (aka, what it looks like) is quite trivial in HTML/CSS
10:49:34 <EvanR-work> merijn: dynamic screwing around, makes sense for something non critical and at this time difficult to engineer sanely
10:49:47 <EvanR-work> but theres more to be done
10:50:06 <EvanR-work> but anything besides a game user interface i consider critical
10:50:11 <EvanR-work> some people dont agree
10:50:16 <Jafet> Someday, we will need to have programmers competent enough to make holodeck user interfaces
10:50:33 <merijn> EvanR-work: Which leads us back to my predicted circle of us disagreeing on the applicability of such screwing around in end-user programs. :)
10:50:34 <Jafet> I hope they're starting to train these programmers now
10:51:02 <EvanR-work> merijn: losing your data because of a bug in the undo/redo of emacs i think is not an acceptable risk
10:51:13 <EvanR-work> or your preferences
10:51:31 <EvanR-work> saving the data to disk incorrectly
10:51:43 <EvanR-work> crashing at all
10:51:55 <ddarius> Jafet: Programmers shouldn't be making those user interfaces.
10:52:02 <medfly> what if your hello kitty animation doesn't work properly
10:52:05 <EvanR-work> crashing is basically never acceptable to an end user, despite status quo on windows 
10:52:27 <EvanR-work> hello kitty animation is in the realm of the gui as previously discussed
10:52:32 <merijn> EvanR-work: Out of curiosity, where do you work for a living? :)
10:52:44 <EvanR-work> market research
10:53:11 <EvanR-work> lots of gui and data
10:53:34 <Jafet> ddarius: I wouldn't want to lose my psychovisual sanity to a typoed rotation matrix
10:53:51 <EvanR-work> transporter psychosis
10:54:02 <ddarius> Jafet: Don't use matrices.
10:54:13 <roconnor> :O
10:54:16 <EvanR-work> hope the OS for the heisenberg compensators is written in haskell2310
10:54:20 <ddarius> At any rate, that doesn't conflict with what I said.
10:55:37 <merijn> Anyway, time to step away from IRC for a while, I have an Epigram paper that's way over my head to figure out...
10:56:42 <ksf> EvanR-work, the trick is to reload modules while running.
10:56:56 <ksf> ...each which has a clearly defined interface and doesn't know about any state of other modules.
10:56:58 <ksf> see erlang.
10:57:07 <Jafet> Do not bewilder a human with an unintuitive configuration space, redundant communication protocols, or bewildering interfaces, unless this comes into conflict with the first, second, or third laws.
10:58:07 <Jafet> Hm, that was a bewildering law
10:59:11 <dstcruz> must. learn. pretty print.
11:09:23 <monochrom> I diagree with dividing two kinds of software to say static typing is suitable for one kind and dynamic typing is suitable for another kind.
11:10:04 <monochrom> I instead divide programmers into two kinds. Dynamic typing is suitable for the careful kind, and static typing is suitable for the careless kind.
11:10:26 <Jafet> That sort of division is known as stereo typing
11:11:22 <monochrom> For example hot-swapping software does not require dynamic typing. static existential type is just fine.
11:11:32 <PatrickRobotham> lol
11:11:56 <monochrom> And no, the stereotype is in dividing two kinds of software, e.g., stereotyping that hot-swapping requires dynamic typing.
11:13:33 <monochrom> Whereas in my division, we could give out an exam on proving programs correct (or the weaker: proving programs type-correct). Those who pass the exam earn the license to use dynamic typing. This is not a stereotype, it is eligibility and qualification.
11:13:44 <PatrickRobotham> Don't sterotypes usually apply to people?
11:14:10 <Jafet> Some statically typed languages are also more statically typed than others.
11:14:43 <monochrom> If you do not have the right diplomas, you are not supposed to give out legal advice. This is not stereotyping.
11:15:00 <roconnor> the problems with static typing appear to me to have something to do with wanting to do generic programming.
11:15:20 <abstrakt> monochrom: um, it's not about diplomas, it's about passing the bar exam - at least in terms of legal advice
11:15:32 <roconnor> and are probably more do to inexpressive type systems than static typing itself
11:15:34 * hackagebot priority-queue 0.2.2 - Simple implementation of a priority queue.  http://hackage.haskell.org/package/priority-queue-0.2.2 (JamesCook)
11:15:48 <abstrakt> that might be irrelevant to what you were attempting to express
11:15:53 <monochrom> alright, sorry, but even better, if you havn't passed an exam, you are not supposed to give out legal advice, and this is not stereotyping.
11:15:55 <abstrakt> but if so, then you probably should find a better analogy :)
11:16:06 <ray> that is a totally irrelevant distinction and you generally need a JD to even sit the bar exam!
11:16:17 <abstrakt> what's a JD?
11:16:22 <ray> law degree
11:16:26 <abstrakt> no you don't
11:16:29 <monochrom> I bring up legal advice to say why my division is not stereotyping. that is all.
11:16:32 <abstrakt> you don't nee jack to take the bar, you just take the bar
11:16:37 <abstrakt> end of story, either you pass or you don't
11:16:54 <Azrael-> Hi guys -- I was wondering if there's any way to do a list comprehension along the lines of [(5+6*i, 7+6*i) | i<-[1..20]] etc.
11:17:06 <abstrakt> anyway, it's irrelevant and monochrom's point still stands
11:17:09 <roconnor> > [(5+6*i, 7+6*i) | i<-[1..20]]
11:17:10 <lambdabot>   [(11,13),(17,19),(23,25),(29,31),(35,37),(41,43),(47,49),(53,55),(59,61),(6...
11:17:13 <Azrael-> oops
11:17:15 <Azrael-> i didn't mean that
11:17:21 <Azrael-> that but without the brackets
11:17:24 <Azrael-> so not in a tuple
11:17:36 <Azrael-> just generating [11, 13, 17, 19...
11:17:36 <roconnor> > concat [[5+6*i, 7+6*i] | i<-[1..20]]
11:17:37 <lambdabot>   [11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,79,83...
11:17:44 <Azrael-> ah awesome
11:17:52 <Azrael-> thanks
11:17:55 <monochrom> passing an exam to earn more flexible power and take on more responsibility is not stereotyping.
11:18:00 <dmwit> > [x | i <- [1..20], x <- [5 + 6 * i, 7 + 6 * i]]
11:18:01 <lambdabot>   [11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,79,83...
11:18:09 <roconnor> > do { i <- [1..20]; [5+6*i, 7+6*i] }
11:18:10 <lambdabot>   [11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,79,83...
11:18:12 <PatrickRobotham> Azrael: You can also just go [11, 13, ...]
11:18:25 <PatrickRobotham> > take 20 [11,13, ..]
11:18:27 <lambdabot>   <no location info>: parse error on input `..'
11:18:28 <dmwit> PatrickRobotham: Nah, gotta skip 15, 21, etc.
11:18:29 <roconnor> dmwit: nice
11:18:34 <PatrickRobotham> oh, srry
11:18:43 <Azrael-> 5, 5+2, 5+2+4, 5+2+4+2, etc.
11:18:44 <roconnor> Azrael-: ^^
11:18:45 <Jafet> So, that would be the second ever standard programming exam after fizzbuzz?
11:19:03 <roconnor> Azrael-: oh good you are still following
11:19:05 <dmwit> > filter ((==3) . (`mod` 6)) [11, 13 ..]
11:19:07 <lambdabot>   [15,21,27,33,39,45,51,57,63,69,75,81,87,93,99,105,111,117,123,129,135,141,1...
11:19:13 <dmwit> > filter ((/=3) . (`mod` 6)) [11, 13 ..]
11:19:14 <lambdabot>   [11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,79,83...
11:19:17 <dmwit> parity error =P
11:19:22 <Azrael-> hmmm, sneaky
11:19:34 <ray> monochrom: of course in reality what you could create would be a professional certification
11:19:35 <dmwit> > (>>= take 2) . chunk 3 $ [11, 13 ..]
11:19:36 <lambdabot>   Not in scope: `chunk'
11:19:41 <joe1> > :t toUpper
11:19:42 <lambdabot>   <no location info>: parse error on input `:'
11:19:42 <dmwit> bah
11:19:50 <joe1> @hoogle toUpper
11:19:51 <lambdabot> Data.Char toUpper :: Char -> Char
11:19:55 <roconnor> dmwit:  list comprehension for plz
11:19:56 <Azrael-> fyi i've only just started learning Haskell, i don't understand monads and stuff
11:20:03 <roconnor> *form
11:20:05 <dmwit> > let chunk i xs = take i xs : chunk i (drop i xs) in (>>= take 2) . chunk 3 $ [11, 13 ..]
11:20:06 <lambdabot>   [11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,79,83...
11:20:15 <dmwit> roconnor: okay...
11:20:37 <Jafet> [0..] -- contains all prime numbers
11:20:48 <PatrickRobotham> Azrael-: It grows on you. If you keep plugging away at it, you'll find you'll learn the math along the way. 
11:20:53 <dmwit> > let chunk i xs = take i xs : chunk i (drop i xs) in [x | [i, j, k] <- chunk 3 [11, 13 ..], x <- [i, j]] 
11:20:55 <lambdabot>   [11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,79,83...
11:21:07 <Azrael-> I'm at uni, studying maths and compsci. I've had experience with imperative languages but this is just craaaaaaaazy
11:21:27 <roconnor> > [x | x<- [11, 13 ..], x `mod` 6 /= 3]
11:21:28 <lambdabot>   [11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,79,83...
11:21:41 <dmwit> Oh, you meant for that one. =P
11:22:06 <burp> hm, having used haskell for a while now, I can't really understand anymore what made it hard for me to grasp it :>
11:22:19 <Azrael-> aha roconnor -- that makes a lot of sense to me
11:22:28 <roconnor> burp: now try to write C++!
11:22:31 <ray> monads are easy, they're just burritos of endofunctors
11:22:32 <Azrael-> probably the most elegant one so far (thogh i don't understand dmwit's ones)
11:22:48 <burp> better not =)
11:22:50 <dmwit> Azrael-: dmwit is just messing around, not intending to present actual solutions
11:23:07 <Azrael-> ah, i hoped as much :)
11:23:12 <Jafet> > scanl (flip id) 7 (cycle [(+4),(+2)])
11:23:13 <lambdabot>   [7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,79,...
11:23:27 <roconnor> Jafet: nice
11:23:28 <silver> that's insane guys
11:23:36 <ray> are you trying to list primes or something
11:23:48 <roconnor> Jafet: bonus points for using flip id
11:23:56 <Azrael-> ray: no, i'm trying to get exactly the list that these guys are coming up with
11:23:58 <dmwit> ray: We'd be doing a pretty bad job of it if we were.
11:24:08 <dolio> Primes like 25, and 35. :)
11:24:18 <ray> yeah those are some terrible lists of primes
11:24:23 <ray> no argument there
11:24:28 <Azrael-> the list is part of an algorithm to find all the prime factors of a number
11:24:30 <roconnor> ray: our code would be much shorter if we were generating a list of primes
11:24:43 <PatrickRobotham> [x | x<- [0..] , prime x] 
11:24:51 <sipa_> :t prime
11:24:52 <lambdabot> Not in scope: `prime'
11:25:05 <PatrickRobotham> the definition of prime is left as an exercise to the reader :P
11:25:14 <Azrael-> exactly what i was about to say, PatrickRobotham
11:25:18 <roconnor> > nubBy(((>1).).gcd) [2..]
11:25:19 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
11:25:30 <dmwit> Please. You have an extra space.
11:25:34 <roconnor> oops
11:25:36 <roconnor> > nubBy(((>1).).gcd)[2..]
11:25:37 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
11:25:38 <silver> nice try
11:25:40 <dmwit> =)
11:25:54 <Jafet> @let prime n = mod (product [1..n-1] + 1) n == 0
11:25:56 <lambdabot>  Defined.
11:26:16 <Jafet> @let prime n = n > 1 && mod (product [1..n-1] + 1) n == 0 -- erp
11:26:17 <lambdabot>  <local>:8:0:
11:26:18 <lambdabot>      Warning: Pattern match(es) are overlapped
11:26:18 <lambdabot>               In...
11:26:21 <Jafet> Oh well.
11:26:39 <dmwit> For bonus points, define prime, primeprime, and prime'
11:26:46 <Azrael-> hehe
11:26:59 <ray> for bonus points, rename those to p, pp, and p'
11:27:01 <ddarius> The original version of the nubBy thing used /=1 but that was then "optimized."
11:27:01 <Jafet> is'?
11:27:09 <blackh> Azrael-: Don't just learn Haskell and forget it, since you're doing it at University. Haskell is much better than all those imperative languages for doing real work.
11:27:10 <dmwit> haha
11:27:26 <Azrael-> blackh: it's hard to use something solid for four years and then just forget it
11:27:28 <Jafet> @let is' n = n > 1 && mod (product [1..n-1] + 1) n == 0 -- erp
11:27:30 <lambdabot>  Defined.
11:27:37 <Zao> I don't associate "doing real work" and "Haskell" :)
11:27:49 <blackh> Azrael-: I like your University!
11:27:51 <monochrom> by the time Azrael- graduates, perhaps we will go on to something much better than haskell.
11:28:04 <Azrael-> blackh: whois me :)
11:28:13 <blackh> Zao: I do.
11:28:19 <Azrael-> monochrom: like C++?
11:28:36 <monochrom> perhaps like epigram and agda
11:28:42 <ray> our next language will be so good that type inference will be a one-liner
11:28:58 <McManiaC> @pl \a b -> "a=" ++ a ++ ", b=" ++ b ++"."
11:28:58 <lambdabot> (("a=" ++) .) . (. ((", b=" ++) . (++ "."))) . (++)
11:29:00 <McManiaC> ok
11:29:00 <McManiaC> not
11:29:01 <McManiaC> :D
11:29:10 <roconnor> @let primes = let isPrime n = n > 1 && mod (product (takeWhile (<n) primes + 1) n == 0 in 2:filter isPrime [3,5..]
11:29:11 <lambdabot>   Parse error: KW_In
11:29:15 <PatrickRobotham> I've heard about agda before. What's cool about it?
11:29:15 <McManiaC> might use printf :>
11:29:17 <blackh> Zero, Azrael- I'm working on a 67,983 line program at the moment.
11:29:21 <ray> and we'll be like "remember when we were using haskell and thought type inference was so cool, but really it's just [code omitted]"
11:29:28 <Azrael-> what does it do, blackh?
11:29:29 <dolio> PatrickRobotham: Everything.
11:29:33 <Azrael-> calculate primes? :D
11:29:37 <blackh> It's a video game for the iPhone.
11:29:44 <roconnor> @let primes = let isPrime n = n > 1 && mod (product (takeWhile (<n) primes) + 1) n == 0 in 2:filter isPrime [3,5..]
11:29:45 <lambdabot>  Defined.
11:29:47 <ray> yes, agda can do that
11:29:52 <roconnor> > take 100 primes
11:29:56 <lambdabot>   mueval-core: Time limit exceeded
11:29:59 <monochrom> dependent type is cool about agda. observe that dynamic type is dependent type checked at runtime.
11:30:07 <Azrael-> video games? for the iPhone? i let you get away with video games and haskell (i've played some before)
11:30:13 <Azrael-> but there are no games for the iPhone
11:30:17 <roconnor> @undef
11:30:22 <Azrael-> they don't exist
11:30:24 <PatrickRobotham> Ah, so it's one of those new fangled dependently typed languages.
11:30:50 <ray> dependent types are very nice to have
11:30:51 <PatrickRobotham> I'm in the process of grokking dependent types. I'll bang my head against them some more this weekend.
11:31:01 <Jafet> Any language that type-checks a proof of false must be worth learning.
11:31:12 <dmwit> hahaha
11:31:15 <dmwit> http://en.wikipedia.org/wiki/File:Agda_proof.jpg
11:31:26 <blackh> Jafet: Fale is the new True
11:32:04 <dolio> New fangled, from the 80s. :)
11:32:05 <dk08> is there a way to use takeWhile with && or ||? i.e. "takeWhile (/="+" && /="*") arg"
11:32:11 <dolio> Just like ML.
11:32:15 <monochrom> the idea of "my function returns integer or list, depending on the parameter, which may be boolean or bytestring" is not new fangled at all. observe how dynamc type programmers have been doing that for decades.
11:32:36 <monochrom> dependent type merely embraces that. that is all.
11:33:36 <Azrael-> dk08:  and . ((flip map) [(=/"+"), (/="*")])
11:33:39 <Azrael-> or something like that
11:33:42 <sproingie> with dynamic types your function could take an integer or list and return boolean or bytestring but there's no necessary correlation
11:33:49 <Azrael-> that almost definitely won't work, but you get the idea
11:33:56 <dmwit> dk08: liftM2
11:34:00 <dk08> Azrael: Thanks, I'll take a look
11:34:02 <sproingie> dependent types actually say something about how your type in determines the type out
11:34:04 <merijn> PatrickRobotham: I've got a decent intro to type theory from our logical verification course
11:34:11 <Azrael-> also, dmwit is a lot smarter than me, listen to him
11:34:15 <PatrickRobotham> merijn: link?
11:34:17 <ray> dk08: any predicate works as the first argument to takeWhile, so \a -> p1 a && p2 a
11:34:21 <merijn> PatrickRobotham: Just slaved through it myself because I'm doing a literature study on Epigram's type system
11:34:27 <ddarius> Oh god.  We have "glamour" shots of programming languages now.
11:34:29 <dmwit> :t liftM2 (&&) (/= "+") (/= "*")
11:34:29 <lambdabot> [Char] -> Bool
11:34:32 <ray> for anding two predicates p1 p2
11:34:39 <dafis> I hate NoImplicitPrelude. Or was CPP the culprit? Anyway, I hate it.
11:34:41 <ray> and then you can get clever like these jokers
11:34:50 <dmwit> Or, yeah, the pointed version is quite readable as well.
11:34:55 <merijn> PatrickRobotham: http://www.cs.vu.nl/~femke/courses/lv/notes/notes.pdf
11:35:04 <dk08> ray: Yours makes the most sense to me... thanks all!
11:35:09 <McManiaC> @pl \a b -> foo $ bar a b
11:35:09 <lambdabot> (foo .) . bar
11:35:20 <ray> as you get further into haskell the pointless ones will start looking prettier and prettier
11:35:33 <Jafet> And more and more pointless
11:35:39 <dmwit> And then, as you get even further, they'll start looking worse and worse again.
11:35:44 <ray> pretty soon you will be asking (***) to marry you
11:35:51 <monochrom> haha
11:35:52 <roconnor> dmwit: they do?
11:35:53 <dafis> :t (.) . (.) . (.) . (.) . (.)
11:35:54 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) a b (f4 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, Functor f4) => (a -> b) -> f (f1 (f2 (f3 (f4 a)))) -> f (f1 (f2 (
11:35:54 <lambdabot> f3 (f4 b))))
11:36:14 <merijn> PatrickRobotham: Starts with intuitionistic minimal proposition logic and simply typed lambda calculus then works up to predicate logic/dependently typed lambda calculus and second order proposition logic/polymorphic lamda calculus (i.e. Haskell's system)
11:36:16 <dmwit> roconnor: Now that it's been suggested, I much prefer (\a -> p1 a && p2 a) to (liftM2 (&&) p1 p2).
11:36:38 <Azrael-> so backslash = anonymous function?
11:36:39 <PatrickRobotham> merijn: Ok, so I'm half-way through.
11:36:39 <Azrael-> awesomes
11:36:48 <PatrickRobotham> merijn: does it come with exercises?
11:36:52 <dmwit> Azrael-: Yes, it's meant to look like a lambda from the lambda-calculus.
11:36:57 <monochrom> observe how \ is ascii art for λ
11:37:13 <monochrom> which is greek art for python's "lambda"
11:37:17 <ray> ,\ would be more accurate
11:37:20 <Azrael-> i vaguely remember one language that used .\
11:37:23 <Azrael-> can't remember what it was
11:37:25 <merijn> PatrickRobotham: There's some at http://www.cs.vu.nl/~femke/courses/lv/notes/exercises-0910.pdf
11:37:27 <dolio> @type \p1 p2 -> getAll . p1 ++ p2
11:37:29 <lambdabot> forall (f :: * -> *). (Functor f, Monoid (f Bool)) => f All -> f Bool -> f Bool
11:37:38 <dolio> @type \p1 p2 -> getAll . p1 ++ p2 . All
11:37:39 <PatrickRobotham> merijn: cheers :)
11:37:39 <lambdabot>     No instance for (Monoid Bool)
11:37:40 <lambdabot>       arising from a use of `++' at <interactive>:1:10-32
11:37:40 <lambdabot>     Possible fix: add an instance declaration for (Monoid Bool)
11:37:42 <monochrom> I vaguely remember one website that used /.  XD
11:37:42 <Azrael-> monochrom: one of my math assignments was to learn the greek alphabet :)
11:37:49 <dolio> @type \p1 p2 -> getAll . (p1 ++ p2) . All
11:37:50 <Azrael-> hehe monochrom
11:37:50 <lambdabot> (All -> All) -> (All -> All) -> Bool -> Bool
11:38:04 <ksf> dmwit, (&&) <*> p1 <$> p2
11:38:07 <dolio> @type \p1 p2 -> getAll . (p1 ++ p2)
11:38:08 <lambdabot> forall (f :: * -> *). (Monoid (f All), Functor f) => f All -> f All -> f Bool
11:38:14 <dolio> There we go.
11:38:23 <dmwit> ksf: I prefer the explicitly pointed one to that, as well.
11:38:31 <ksf> ...even better with idiom brackets
11:38:33 <sproingie> @pl \p1 p2 -> getAll . (p1 ++ p2)
11:38:34 <lambdabot> ((getAll .) .) . (++)
11:39:48 <Jafet> :t (&&) <*> id <$> id <$> id
11:39:49 <lambdabot> Bool -> Bool
11:42:17 <Azrael-> GHC vs. Hugs?
11:42:31 <merijn> Azrael-: GHC is the de facto standard
11:42:37 <Azrael-> that's what i thought
11:42:45 <Azrael-> then i came to uni and the lecturers recommended Hugs
11:43:05 <Azrael-> which gives errors on things that GHC doesn't, and when they both error, Hugs' error messages are completely bizarre
11:43:08 <merijn> I heard hugs has a nicer REPL, but GHCi suffices for me
11:43:13 <ksf> :t (&&) <$> id <*> id
11:43:14 <lambdabot> Bool -> Bool
11:43:21 <PatrickRobotham> Azrael-: Hugs is an interpreter. It's primary use is education. 
11:43:25 <monochrom> hugs is less powerful, therefore can give more direct error messages
11:43:46 <ksf> <$> == \f -> (pure f <*>), now I'm confused.
11:43:53 <Jafet> :t (&&) <*> (==1) <$> (==2) <$> (==3)
11:43:55 <lambdabot>     No instance for (Num Bool)
11:43:55 <lambdabot>       arising from the literal `1' at <interactive>:1:12
11:43:55 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
11:43:55 <Azrael-> if you have a syntax error in GHCi it will give you a vaguely sensible error message
11:44:10 <Azrael-> Hugs will tell you that it wasn't expecting a character that you never put in in the first place
11:44:31 <Jafet> I'm just a poser, I don't know how Functor ((->)r) works.
11:44:41 <monochrom> a powerful compiler like ghc (powerful means is capable of extensions) trying to be friendly cannot possibly give you direct error messages because it has to think "hmm, maybe you mean to use extension X but forgot to say it, I'll remind you!"
11:44:43 <ksf> you should trash everything that's labelled "for beginners" immideately.
11:44:46 <ksf> ...like pascal.
11:45:10 <Azrael-> lemme make a quick test script with an indentation error (i did this earlier today accidentally)
11:45:13 <merijn> Jafet: Join the poser club :p
11:45:37 <DrSyzygy> Jafet: From some f :: a->b, you'll need to produce an fmap f :: (r -> a) -> (r -> b). So fmap f g = g.f would work.
11:45:39 <dmwit> :t (<*>)
11:45:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:45:45 <Jafet> ksf: so you consider them Wirthless?
11:46:12 <merijn> I'm tempted to give my presentation to the theoretical CS department in a shirt saying "I'm not a theoretical computer scientist..." "...I just pretend to be one on IRC" (blatantly stolen from the #haskell shirts)
11:46:18 <ksf> blaize pascal would rotate in his grave if he knew what was being sold in his name.
11:46:26 <monochrom> My stance is: trash friendliness to restore direct error messages again.
11:46:41 <nooodl> i want to show a non-haskeller some haskell code. it uses "mapM_ putStrLn" to print every element of a list of strings. how do i explain mapM_? can i use something else that looks cleaner?
11:46:47 <Azrael-> ksf: he also fell for Pascal's wager, he's evidently not that smart
11:46:59 <PatrickRobotham> nooodl: Can't you show them quicksort in haskell?
11:47:08 <nooodl> hehe :)
11:47:09 <merijn> nooodl: "Magic map", that's what the M_ stand for ;)
11:47:24 <roconnor> PatrickRobotham: you mean tree sort
11:47:27 <nooodl> haha definitely "magic"
11:47:51 <nooodl> is using just mapM bad practice? the results are going nowhere
11:48:02 <roconnor> I use mapM all the time
11:48:04 <monochrom> you can explain: mapM_ x [1,2,3] = do { x 1; x 2; x 3 }
11:48:09 <Jafet> @src mapM
11:48:09 <lambdabot> mapM f as = sequence (map f as)
11:48:17 <Jafet> Demagickified.
11:48:18 <roconnor> often I use mapM_
11:48:24 <ddarius> @src sequence
11:48:25 <lambdabot> sequence []     = return []
11:48:25 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:48:25 <lambdabot> --OR
11:48:25 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
11:48:29 <Jafet> @src mapM_
11:48:30 <ddarius> Now fuse the foldr.
11:48:30 <lambdabot> mapM_ f as = sequence_ (map f as)
11:48:33 <PatrickRobotham> Azrael-: To be fair, Pascal did do some really cool stuff, like Pascal's triangle.
11:48:41 <merijn> Jafet: Because no haskell coders know about sequence and do notation?
11:48:50 <Azrael-> i guess he was a better mathematician than philosopher
11:48:54 <merijn> s/no haskell/non-haskell
11:49:08 <roconnor> merijn: sequence is one the the most important functions ever. 
11:49:10 <PatrickRobotham> Azrael-: Well, most philosophers are :P
11:49:18 <blackh> nooodl: For a non-Haskeller, forM_ might look familiar: forM_ strings putStrLn
11:49:26 <nooodl> roconnor: not to PHP programmers :)
11:49:32 <merijn> roconnor: Probably, but I have no clue what it does atm :p
11:49:33 <roconnor> nooodl: :(
11:49:34 <Azrael-> as a wannabe philosopher, PatrickRobotham, i can agree with that :)
11:49:37 <roconnor> ;(
11:49:48 <Jafet> nooodl: carry a large blunt stick, just in case.
11:49:52 <merijn> :t sequence
11:49:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:50:00 <PatrickRobotham> Hey, we've got a lot in common Azrael-!
11:50:05 <nooodl> http://codepad.org/ACHx0QIg looks explainable
11:50:06 <merijn> Oh, I guess that sorta makes sense
11:50:12 <ddarius> Jafet: Why not a sharp stick?
11:50:33 <monochrom> no. bring a usb stick. just plug into the target's head and download.
11:50:34 <merijn> :t mapM_
11:50:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
11:50:51 <ddarius> monochrom: That doesn't sound satisfying at all.
11:50:53 <Jafet> ddarius: because you want the stick to be point-free.
11:50:58 <monochrom> hahaha
11:51:07 <roconnor> > sequence [(+1), (*2), (^3)] 2
11:51:08 <lambdabot>   [3,4,8]
11:51:19 <roconnor> > sequence [[1,2,3
11:51:20 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:51:30 <roconnor> > sequence [[1,2,3],[4,5],[6]]
11:51:31 <lambdabot>   [[1,4,6],[1,5,6],[2,4,6],[2,5,6],[3,4,6],[3,5,6]]
11:51:39 <Azrael-> GHC errors vs. Hugs errors: http://pastebin.com/q3nDrNnp
11:51:50 <dmwit> Okay, this is super off-topic, but what is up with YouTube? How come when I change the "show annotations" setting in my account, it never "sticks", and I have to do it again next time I'm there?
11:52:07 <roconnor> dmwit: not written in Haskell I'm afraid
11:52:09 <monochrom> because youtube is not written in haskell
11:52:17 <edlinde> *Main> filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"  
11:52:18 <edlinde> "GAYBALLS"
11:52:28 <edlinde> love this example from the haskell tutorial :)
11:52:33 <PatrickRobotham> @faq Can haskell solve the halting problem? 
11:52:34 <dmwit> roconnor, monochrom: Well, I guess I deserved that answer. =P
11:52:34 <lambdabot> The answer is: Yes! Haskell can do that.
11:52:39 <monochrom> then again the new hpaste doesn't remember my "expire in 1 hour" preference either
11:52:54 <merijn> Solving the halting problem is easy
11:53:03 <merijn> Just run the program and wait till it stops...
11:53:05 <monochrom> the biggest irony is it remembers my nickname, just not by expiration preference.
11:53:09 <Jafet> Azrael: well, both error messages seem non-sequiturs.
11:53:28 <kmc> solving the halting problem is easy; ghc will terminate not-halting threads with the exception "<<loop>>"
11:53:44 <kmc> ;)
11:53:51 <Funktorsalat> merijn: you'll never get an anwer if it doesn't
11:53:56 <Azrael-> Jafet: telling me it's probably an indentation error is a lot better than telling me i had a right-moustache where i shouldn't
11:53:59 <Funktorsalat> this situation is called "semi-decidability"
11:54:00 <joe1> how can I change: f y x => x f y
11:54:05 <merijn> Funktorsalat: I wonder if that could've possibly been the joke :)
11:54:05 <ddarius> Concurrency: Making impossible problems easy.
11:54:26 <dmwit> ?pl \f y x -> x f y
11:54:26 <lambdabot> flip . flip id
11:54:27 <joe1> i think there was a function that can change the order of function arguments
11:54:34 <joe1> dmwit: thanks.
11:54:48 <joe1> :t flip
11:54:50 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:54:55 <roconnor> Cale!!!
11:55:00 <merijn> ddarius: Courtesy of #python: "<someguy> What causes race conditions? <python regular> Teenagers, booze and fast cars..."
11:55:04 <dmwit> :t Prelude.flip
11:55:05 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:55:05 <roconnor> joe1: ignore that
11:55:12 <Funktorsalat> merijn: uh it seemed like a reasonably plausible idea for a newbie (that's not saying that you are one, I just didn't know)
11:55:17 <roconnor> joe1: lambdabot is lying to you
11:55:23 <monochrom> why is } the right-moustache? isn't it the left-moustache?
11:55:39 <joe1> roconnor: thanks a lot.
11:55:44 <Jafet> Your left, his right
11:55:44 <Azrael-> monochrom: it goes on the right
11:55:54 <drhodes> it's the rotated -pi/4 stache
11:55:56 <Azrael-> ( isn't a right-happy-face
11:56:00 <PatrickRobotham> I like the strong-normalization theorem/
11:56:22 <monochrom> I saw (: as happy face all the time
11:56:25 <dmwit> monochrom: It's the "right-is-up" mustache, not the "left-is-down" mustache. ;-)
11:56:30 <joe1> > Prelude.flip !! 4 [1..7]
11:56:32 <lambdabot>   Not in scope: `Prelude.flip'
11:56:40 <dmwit> > Prelude.flip (!!) 4 [1..7]
11:56:41 <lambdabot>   Not in scope: `Prelude.flip'
11:56:44 <dmwit> anyway
11:56:49 <dmwit> > flip (!!) 4 [1..7]
11:56:50 <lambdabot>   5
11:56:53 <Azrael-> monochrom: (: is the happy face that 13-year-old emo girls use, because :) is too conventional
11:57:11 <merijn> Azrael-: 13-year-old emo girls don't use happy faces...
11:57:11 <joe1> dmwit: thanks
11:57:28 <Azrael-> merijn: my sister's a 13-year-old emo girl
11:57:41 <Azrael-> if she has no excuse to be upset, she will sometimes be happy
11:57:58 <PatrickRobotham> Pick an emotion and stick to it emos! 
11:58:00 <ddarius> Wouldn't she be unhappy about having no excuse to be unhappy?
11:58:08 <ketil> dons or kolmodin: is code.haskell.org/binary current and up to date?  It seems to be missing tags > 0.4.2.
11:58:11 <merijn> If she occasionally has no excuses to be unhappy, she's not really good at it, is she? :D
11:58:18 <monochrom> she is unlikely to be that meta-emo yet
11:58:23 <Azrael-> merijn: no, her family's too excellent :D
11:59:39 <abstrakt> I think it's pretty lame to make fun of people for being sensitive
11:59:52 * ddarius thinks he had a dream about cleaning his keyboard.
11:59:54 <abstrakt> I would say that over 75% of most of the people on IRC probably qualify as emo
12:00:32 <abstrakt> only difference, is that most people on IRC probably don't wear dark makeup - most notably because no one on IRC ever sees the light of day much less other people, so it'd be a moot point
12:00:38 <Azrael-> abstrakt: being emo is an entire subculture
12:00:47 <Azrael-> i suppose the more technically correct term would be being a 'scene' kid
12:01:02 <abstrakt> hmm, ok scene... I guess... I don't know what that really means
12:01:09 <PatrickRobotham> How do you create a subculture out of dyeing your hair black?
12:01:16 <abstrakt> for the most part emo seems to be an insult leveled at goth kids
12:01:30 <Azrael-> PatrickRobotham: music, etc.
12:01:39 <abstrakt> PatrickRobotham: same way you develop a subculture based on any other kind of fashion statement
12:01:40 <Azrael-> it's not a very interesting subculture
12:01:51 <ksf> it's simple. you're angsty  and upset like everyone in their teens, but you're too cool to let it drag you down, so you make it your style.
12:01:53 <PatrickRobotham> abstrakt: Get a celebrity to adopt it?
12:02:02 <monochrom> you have a subculture out of being born with hair black already
12:02:03 <Azrael-> i'm currently wearing a white robe with a pointy hood
12:02:07 <ddarius> If I were going to dye my hair, I'd dye it black since that's the hair color I most prefer, but my hair is already black...
12:02:14 <Azrael-> i've never seen anybody make a subculture out of that
12:02:15 <abstrakt> I put on my robe and wizard hat
12:02:18 <PatrickRobotham> Azrael-: Um...
12:02:19 <merijn> PatrickRobotham: Same way #haskell builds a subculture out of obscure category jokes and references to Oleg?
12:02:37 <Azrael-> abstrakt: a friend of mine (new friend from uni) made that same reference today
12:02:41 <Azrael-> it was the most hilarious thing
12:02:57 <merijn> category theory jokes, even
12:03:14 <PatrickRobotham> merijn: Humans are weird!
12:03:21 <dmwit> Well, I for one would never make a category theory.
12:03:22 <ddarius> PatrickRobotham: We should get rid of them.
12:03:24 <merijn> On the other hand, obscure may have been superfluous. I don't think there is such a thing as a non-obscure category theory joke
12:03:25 <dmwit> ...joke.
12:03:34 <ksf> jokes are endofunctors in the category of misunderstandings
12:03:39 <dmwit> whoops
12:03:40 <PatrickRobotham> Lol. 
12:03:57 <PatrickRobotham> What is an endofunctor?
12:04:00 <merijn> ksf: I laughed even though I have no clue what you just said :p
12:04:09 <ddarius> PatrickRobotham: You use endofunctors all the time.
12:04:10 <monochrom> the subculture of white robe with pointy hood is the vulcans. they also have pointy ears.
12:04:10 <dmwit> PatrickRobotham: It's a functor from a category to itself.
12:04:11 <ksf> a functor that stays in the same category.
12:04:19 <PatrickRobotham> If I can ask that without my lambda badge being removed.
12:04:20 <merijn> Category Theory for Dummies is still on my to read list >.>
12:04:29 <ksf> haskell's Functor class are endofunctors in Hask.
12:04:33 <dmwit> PatrickRobotham: It's a mapping from a category to itself that preserves identities and composition. =)
12:05:00 <PatrickRobotham> dmwit: Ok. So it's a map in the category of categories?
12:05:13 <dmwit> PatrickRobotham: A functor is an arrow in the category of categories, yes.
12:05:18 <PatrickRobotham> Ok. 
12:05:23 <PatrickRobotham> Makes sense.
12:05:23 <dmwit> PatrickRobotham: An endofunctor additionally has the same domain and codomain.
12:05:54 <ksf> so an endofunctor is an identity in the category of categories
12:06:02 <dmwit> No, not necessarily.
12:06:12 <Funktorsalat> other way around
12:06:16 <Azrael-> what's the difference between a category and a set?
12:06:23 <ksf> how would you tell them apart?
12:06:28 <Funktorsalat> a category has morphisms
12:06:30 <PatrickRobotham> ksf: not all arrows with the same domain and codomain are identity maps. Consider "*2" in the category of sets.
12:06:39 <dmwit> ksf: e.g. the "list" functor is not an identity; it does not map "Int" to "Int", it maps "Int" to "[Int]".
12:06:48 <Azrael-> Funktorsalat: what's a morphism?
12:06:50 <PatrickRobotham> That has a domain and codomain of R, but it's not an identity mapping.
12:07:02 <PatrickRobotham> Azrael-: fancy word for arrow I gather.
12:07:18 * Funktorsalat defers to the www :)
12:07:20 <dmwit> Yes, "morphism" and "arrow" are generally interchangeable.
12:07:35 <Funktorsalat> not that fancy, "morphism" is more standard actually
12:07:43 <Funktorsalat> (imho)
12:07:53 <EvanR-work> morphism is a function?
12:07:54 <ksf> didn't we leave values in R behind by looking at the category of categories?
12:07:56 <Azrael-> So far I've gathered that a category is a set with arrows.
12:08:00 <Azrael-> This makes little sense.
12:08:02 <dmwit> EvanR-work: No, not necessarily. =P
12:08:06 <PatrickRobotham> It's not necessarily a set.
12:08:12 * ksf isn't a category theorist, he just claims to be one while on #haskell
12:08:20 <EvanR-work> i play one on tv
12:08:30 <dmwit> EvanR-work: For example, there's a category of sets with relations as arrows.
12:08:37 <Funktorsalat> (and "arrow" as a synonym for "morphism" isn't the same as haskell's Arrow class, which would be a very special case)
12:08:37 <PatrickRobotham> Azrael-: The key idea is that you've got objects and arrows. 
12:08:51 <PatrickRobotham> Azrael-: and arrows can be composed
12:09:01 <dmwit> Or the category of a poset, where objects are the elements of the poset and there's a (unique) arrow between any two values x and y for which x <= y.
12:09:03 <Azrael-> How is this different from sets and functions?
12:09:04 <EvanR-work> dmwit: so its a many to many
12:09:20 <byorgey> Azrael-: the page on categories on the haskell wiki is actually quite nice.
12:09:21 <PatrickRobotham> Azrael-: Sets and functions are a category. Category theory generalizes this notion.
12:09:34 <ksf> ...a category is a set of objects, a set of morphisms between said objects, and a composition function for said morphisms.
12:09:35 <Funktorsalat> a category is like an appendoid, but with types
12:09:37 <Funktorsalat> sorry ;)
12:09:38 <monochrom> set-and-function is an example for category theory. not the only example.
12:09:44 <PatrickRobotham> What the heck is an appendoid?
12:09:45 <byorgey> Azrael-: http://haskell.org/haskellwiki/Category
12:09:46 <ksf> so it's a triple.
12:10:13 <dmwit> EvanR-work: I think it's best not to impose any additional structure on morphisms until you're talking about a specific category.
12:10:15 <Funktorsalat> PatrickRobotham: the name someone (seriously or jokingly) suggested as a better (less academic) word for "Monoid"
12:10:19 <Funktorsalat> on haskell-cafe
12:10:25 <EvanR-work> dmwit: additional to what?
12:10:29 <EvanR-work> you didnt provide any to begin with
12:10:33 <dmwit> EvanR-work: exactly
12:10:36 <byorgey> Azrael-: wait, I meant this one: http://en.wikibooks.org/wiki/Haskell/Category_theory
12:10:37 <EvanR-work> so there is no definition
12:10:38 <Saizan> EvanR-work: the arrows just need to be things that can be reasonably composed
12:11:01 <dmwit> EvanR-work: Arrows have a domain and a codomain, and two arrows can be composed if the codomain of the one is the domain of the other
12:11:08 <dmwit> EvanR-work: That's all the structure you get to begin with.
12:11:15 <monochrom> group-and-homomorphism is an example of category. the arrows are group homomorphisms. note that not all set-functions are eligible.
12:11:15 <merijn> Obviously I still haven't read enough papers as this still sounds like gibberish >.>
12:11:16 <EvanR-work> a domain is a what?
12:11:26 <Saizan> an object of the category
12:11:27 * ksf still waits for some conlanger to construct a language that's based on CT
12:11:34 <Saizan> but you don't know anything more than that :)
12:11:41 <Entroacceptor> s
12:11:41 <dmwit> EvanR-work: Okay, maybe we'd better start at the beginning. A category has objects and arrows, and some laws about them.
12:11:43 <joe1> does ghci use readline or haskeline?
12:11:49 <byorgey> a crowded IRC room makes a particularly poor forum in which to learn about category theory.
12:11:49 <monochrom> haskeline
12:11:53 <joe1> thanks.
12:11:55 <Funktorsalat> every morphism has a domain object and codomain object; these are primitives
12:12:03 <Saizan> byorgey: but it's fun to watch :)
12:12:06 <ksf> ...it can use readline too, though.
12:12:12 <byorgey> not for me
12:12:14 <ksf> at least last time I looked (and didn't care)
12:12:14 <Funktorsalat> (the dom/cod assignment is taken as an opaque primitive, I mean)
12:12:18 * EvanR-work bumps into people while learning categories
12:12:29 <dmwit> EvanR-work: Every object has a (unique) arrow called the "identity". Every arrow has a domain and a codomain. Arrows with matching endpoints can be composed. And (id; f = f; id = f).
12:12:57 <dmwit> EvanR-work: Here I'm using (;) as the composition operator.
12:13:04 <monochrom> and composition is associative
12:13:22 <dmwit> EvanR-work: We require that (f; g) is well defined iff the codomain of f is the same as the domain of g.
12:13:23 <EvanR-work> = ?
12:13:28 <dmwit> Whoops, yes, I forgot associativity.
12:13:46 <ksf> in haskellish syntax, id . f == f . id == f
12:13:52 <dmwit> (f; g); h = f; (g; h), whenever both sides are defined
12:14:01 <EvanR-work> whats =
12:14:05 <ksf> equals
12:14:08 <dmwit> EvanR-work: It's equality, of course.
12:14:15 <EvanR-work> as in equivalence relation
12:14:23 <dmwit> No, it's actual equality.
12:14:31 <EvanR-work> 'is the same thing'
12:14:34 <dmwit> Like, (f = g) is true when f and g are the exact same arrows.
12:14:38 <ksf> like in 1 + 1 = 2
12:14:39 <monochrom> equal is equivalence relation plus leibniz rule
12:14:42 <Azrael-> so i can think of a category as a set, a morphism as a homogeneous function (ie. domain = codomain), a functor as a non-homogeneous function
12:15:00 <byorgey> Azrael-: no, not really
12:15:02 <ketil> (Nevermind - it looks like it's there, except for the tags...)
12:15:04 <monochrom> many equivalence relations do not enjoy leibniz rule
12:15:15 <dmwit> Azrael-: morphisms need not have domain = codomain, plus using the mental model of sets/functions will only get you so far
12:15:27 <dmwit> Azrael-: There are plenty of categories that don't behave the way SET does.
12:15:46 <Azrael-> please give an example of a category that can't be modelled as a set
12:15:51 <EvanR-work> dmwit: what is id again?
12:15:56 <monochrom> leibniz rule allows you to infer: hey, since id;f = f;id, I can infer g;(id;f) = g;(f;id). "do the same thing to both sides"
12:15:59 <Azrael-> EvanR-work: id x = x
12:16:04 <ksf> ah now I get the identity in the category of categories thing.
12:16:05 <EvanR-work> an arrow from seom domain to itself
12:16:11 <dmwit> EvanR-work: It's a special arrow for each object.
12:16:22 <ClaudiusMaximus> how do i convince cabal to obey the "blank lines in between paragraphs" haddock stuff in the Description: section? I get everything smooshed onto one paragraph which is bad
12:16:30 <roconnor> @quote JamesMckinna
12:16:30 <lambdabot> JamesMckinna says: We are once again left with the miserable prospect that it is equality that divides us.
12:16:32 <EvanR-work> any other properties?
12:16:38 <EvanR-work> besides 'special'
12:16:38 <dmwit> EvanR-work: The rule is domain(id_A) = A, codomain(id_A) = A, and if f : A -> B, then id_A; f = f; id_B = f
12:16:58 <ksf> ...premature induction is the root of all misunderstanding
12:16:59 <EvanR-work> oh right
12:17:12 <roconnor> (in reference to differences between equality in different proof assistants)
12:17:14 <PatrickRobotham> Azrael-: Here's an example. A computer program that reads input from the screen and stores it.
12:17:25 <dmwit> Azrael-: Sure, the category of categories can't be modelled as sets and functions. Neither can the category of sets with relations, or the category of sets with lenses, or the category of posets...
12:17:26 <PatrickRobotham> And then prints it to the screen
12:18:08 <PatrickRobotham> (That's also a monoid)
12:18:26 <Funktorsalat> monoidoid
12:18:35 <ksf> i'd actually call that the identity function.
12:18:42 <Azrael-> dmwit: what can you do with the category of sets with relations that you can't do with categories?
12:18:42 <monochrom> ClaudiusMaximus: you may get inspiration from http://hackage.haskell.org/packages/archive/pcre-light/0.4/pcre-light.cabal
12:18:48 <ksf> id :: Screen -> Screen, that is.
12:18:51 <dmwit> Azrael-: eh?
12:18:52 <Azrael-> *can't do with sets
12:19:12 <PatrickRobotham> but it's not id :: Screen -> Screen, if it was, it wouldn't change what's on the screen ksf
12:19:15 <dmwit> Azrael-: Oh, there are more arrows (relations) between sets than there are functions between sets.
12:19:25 <EvanR-work> dmwit: f = f somehow defines an arrow?
12:19:35 <EvanR-work> or f : A -> B
12:19:42 <EvanR-work> if the latter, whats the point of expressing f = f
12:19:46 <dmwit> EvanR-work: No, let me parenthesize: (id_A; f) = (f; id_B) = f
12:19:49 <ksf> now don't come with such esoteric concepts as time.
12:19:51 <EvanR-work> oh
12:20:07 <ksf> PatrickRobotham, http://hackage.haskell.org/package/acme-now
12:20:14 <monochrom> you want to set up a category that outlaws some functions and retains some others. like group homomorphisms. that is why you just want to say "category" rather than "consider all possible sets, all possible relations"
12:20:17 <EvanR-work> makes more sense now
12:21:11 <EvanR-work> composing any compatible arrow with id for a given object has no effect on that arrow
12:21:17 <dmwit> right
12:21:18 <luite> consider an object in the category of commutative diagrams
12:21:50 <dmwit> luite: Ah, there are tons of great examples there, too, nice point. Cone categories, co-cone categories, ...
12:22:08 <EvanR-work> and arrow equality is all we have to identify 'what an arrow is/does' so far 
12:22:11 <ksf> objects in the category of cummutative diagrams are lolcats.
12:22:20 <dmwit> EvanR-work: correct
12:22:26 <EvanR-work> great!
12:22:40 <dmwit> EvanR-work: Saying "X" is a category says really very little. That's why so many things can share the language of category theory!
12:22:49 <EvanR-work> expressions of profound nothing ;)
12:22:54 <dmwit> yes =D
12:23:08 <ksf> category theory is like politics. convince everyone by saying nothing at all.
12:23:12 <ddarius> Until you break out adjunctions and such.
12:24:02 <dmwit> "There's nothing to understand. It's just definitions!"
12:24:08 <EvanR-work> so does a category immediately produce a monoid? :)
12:24:14 <ClaudiusMaximus> monochrom: perfect, thanks
12:24:26 <dmwit> EvanR-work: Actually, you can think of a category as being a "typed" monoid.
12:24:47 <dmwit> EvanR-work: Instead of an operation to combine any two elements, you can only combine them if their types match up (i.e. composition).
12:25:00 <EvanR-work> the domain and codomain
12:25:06 <EvanR-work> the arrows are the monoid elements
12:25:12 <dmwit> And in fact, each monoid induces a one-object (i.e. untyped) category, where the "mappend" function is composition and the elements of the monoid are the arrows.
12:25:17 <dmwit> EvanR-work: right
12:25:42 <dmwit> not bad, eh?
12:25:58 <EvanR-work> so i can think of category theory as a multi-monoid theory ;0
12:25:59 <EvanR-work> ;)
12:26:02 <ddarius> The "categories as a generalization of posets" view, though, is often more enlightening/useful.
12:26:05 <monochrom> I just studied this theorem about "if your category satisfies these extra conditions, then inside it, sequences have limits". It is applicable to several semantics of several different languages. Note that different languages have annoying differences in semantics, e.g., some say "functions may be non-strict", some other say "functions must be strict". But each language semantics is a category and satisfies the extra conditions
12:26:05 <monochrom> . And for all of them, the conclusion "sequences have limits" uniformly translates to "recursive types are supported".
12:27:03 <ddarius> "extra conditions" = has omega-colimits?
12:27:11 <monochrom> This is IMO a convincing reason why we would use category theory. The alternative would be treating each language separately but with lots of boilerplates.
12:27:14 <monochrom> Yes.
12:27:19 <monochrom> No.
12:27:29 <merijn> Maybe?
12:27:40 <monochrom> "has ω-colimits" is the conclusion.
12:28:44 <monochrom> The extra condition: homsets are CPOs, and something about pairs of embedding and projection, and join of some sequence of morphisms = id
12:29:19 <ddarius> A retractible object?
12:29:28 <Funktorsalat> id is a directed limit of compact elements?
12:29:30 <Funktorsalat> something like that
12:29:49 <Funktorsalat> ("limit" in the order sense of the homsets there)
12:33:45 <EvanR-work> in what way is category theory a 'fix' to naive set theory
12:34:05 * hackagebot control-event 1.2.0.0 - Event scheduling system.  http://hackage.haskell.org/package/control-event-1.2.0.0 (ThomasDuBuisson)
12:34:20 <EvanR-work> does the requirement of morphisms restrict the existence of paradoxical categories
12:34:21 <ddarius> EvanR-work: "Who cares?"
12:34:54 <ddarius> Category theory wasn't made to be a new foundation for mathematics.
12:35:18 <ddarius> And most categorists and most uses of category theory could care less what the foundations are.
12:35:45 <EvanR-work> is there no russel paradox for categories
12:36:15 <ddarius> EvanR-work: It depends.  If you naively have a category of all categories you will get into the same kinds of problem.
12:36:43 <EvanR-work> how do you naively have that, just dont identify what the arrows are?
12:37:22 <ddarius> You naively have that by asserting it as an axiom.
12:37:58 <abstrakt> how is $ different from .
12:38:00 <abstrakt> e.g.
12:38:11 <EvanR-work> :t Prelude..
12:38:13 <abstrakt> unwords . reverse . words
12:38:13 <byorgey> abstrakt: ($) is function composition.  f $ x = f x
12:38:14 <lambdabot> parse error on input `Prelude..'
12:38:22 <abstrakt> vs
12:38:23 <byorgey> abstrakt: argh, I meant to say function application
12:38:28 <abstrakt> unwords $ reverse $ words
12:38:33 <ddarius> More succinctly, ($) is id.
12:38:35 <byorgey> (.) is function composition.  (f . g) x = f (g x)
12:39:02 <burp> :t (.)
12:39:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:39:04 <burp> :P
12:39:06 <ddarius> abstrakt: Write those two lines into GHCi and see what happens.
12:39:13 <byorgey> abstrakt: unwords . reverse . words  is a function which takes its input and first breaks it into words, then reverses the result, then sticks the words back together.
12:39:21 <byorgey> abstrakt: unwords $ reverse $ words is a type error.
12:39:27 <dmwit> unwords . reverse . words is \x -> unwords (reverse (words x)), whereas unwords $ reverse $ words is unwords (reverse words).
12:39:59 <byorgey> however, unwords $ reverse $ words x   is the same as  (unwords . reverse . words) x
12:40:03 <byorgey> note the x.
12:40:03 <abstrakt> so... unwords $ reverse $ words x
12:40:03 <aristid> \x -> unwords $ reverse $ words $ x
12:40:08 <abstrakt> ahh ok that's what I was getting at
12:40:22 <abstrakt> they are essentially equivalent when used in the proper contexts
12:40:32 <dmwit> Actually, there's an important difference.
12:40:40 <abstrakt> well essentially != completely
12:40:46 <merijn> abstrakt: They're parenthesis elimination tools, and you can pass $ as a function to for example map
12:40:53 <merijn> s/can/can't
12:40:54 <dmwit> You can extract more valid subexpressions from (unwords . reverse . words) than from (\x -> unwords $ reverse $ words $ x).
12:40:54 <byorgey> abstrakt: not really.
12:41:08 <ddarius> merijn: Sure you can.
12:41:18 <byorgey> abstrakt: they may superficially appear similar in certain contexts.
12:41:22 <byorgey> but they are different things.
12:41:30 <aristid> dmwit: which helps with refactoring and changes?
12:41:31 <abstrakt> I didn't say they are equivalen
12:41:37 <abstrakt> I'm saying that that specific example
12:41:42 <merijn> ddarius: Digging a hole for myself here >.> Can't figure out how to formulate what I was trying too :p
12:41:46 <dmwit> aristid: correct
12:41:50 <abstrakt> those two different varieties are, for practical purposes, almost equivalent
12:41:51 <byorgey> abstrakt: they aren't even the same thing in that example.  the two expressions just happen to look similar.
12:42:20 <Funktorsalat> h . g . f $ x = (h . g . f) x
12:42:30 <Funktorsalat> h $ g $ f $ x = h (g (f x))
12:42:32 <byorgey> abstrakt: my point is that thinking of them as "essentially equivalent" will get you into trouble.  first understand what they ARE, then you can worry about how they are similar or different =)
12:42:54 <abstrakt> well that's what I'm asking
12:42:55 <edlinde> largestDivisible = head (filter p [100000,99999..])  
12:42:55 <edlinde>     where p x = x `mod` 3829 == 0  
12:42:58 <abstrakt> how are they different
12:43:03 <edlinde> can someone help me understand how that is working?
12:43:07 <abstrakt> they, in effect, accomplish the same thing, but how are they different
12:43:08 * hackagebot hsXenCtrl 0.1.0 - FFI bindings to the Xen Control library.  http://hackage.haskell.org/package/hsXenCtrl-0.1.0 (ThomasDuBuisson)
12:43:10 <Funktorsalat> (these two are equivalent, but you see how it's a quite different expression tree)
12:43:10 <abstrakt> that was my question
12:43:20 <edlinde> I understand p has to be a function that will return a boolean
12:43:35 <edlinde> but I don't get how the "where" clause is working here
12:43:41 <edlinde> whats x?
12:44:01 <mauke> edlinde: a parameter of p
12:44:10 <dmwit> edlinde: "where" just introduces some local (function) definitions. So "p x = ..." is defining a function named "p" that takes one parameter and names it "x".
12:44:12 <merijn> edlinde: The where clause is defining a function p inside largestDivisible
12:44:19 * ddarius decides that now is a good time to, perhaps, start watching BSG again.
12:44:22 <byorgey> abstrakt: h . g . f $ x  first builds a function which is the composition of h, g, and f, then applies that function to x
12:44:40 <edlinde> ok get you
12:44:41 <byorgey> abstrakt: h $ g $ f $ x first applies f to x, then applies g to the result, then h to the result of that
12:44:43 <edlinde> makes sense
12:44:43 <merijn> edlinde: largestDivisible then calls filter with that function p as an argument
12:44:49 <EvanR-work> (h . g . f) x  --ftw
12:44:52 <abstrakt> byorgey: but I'm asking about (h . g . f) x vs h $ g $ f x
12:45:00 <byorgey> abstrakt: ok, same thing
12:45:00 <edlinde> yep got it now
12:45:05 <edlinde> thanks guys
12:45:10 <Funktorsalat> EvanR-work: I like that way of writing it
12:45:19 <abstrakt> ok
12:45:30 <EvanR-work> im a communist so i reduce the $ floating around my source code
12:45:33 <byorgey> abstrakt: remember, f $ x = f x, so (h . g . f) x  and  h . g . f $ x  are the same (note $ has lower precedence than .)
12:45:35 <Funktorsalat> (somehow)
12:45:39 <edlinde> anoher thing
12:45:52 <byorgey> abstrakt: the only reason to have $ is so that you can write certain function applications without parentheses
12:45:53 <edlinde> I am still not sure I get the difference between let and where... maybe I can get some help?
12:46:06 <byorgey> e.g. instead of  f (g x)  you can write  f $ g x
12:46:11 <abstrakt> ok
12:46:12 <mauke> edlinde: let comes before stuff
12:46:15 <edlinde> I understand that the let doesn't go across "guards" while "where" can
12:46:17 <dmwit> edlinde: let makes an expression, where doesn't
12:46:18 <EvanR-work> let and where are for the same purpose just different syntax
12:46:18 <Funktorsalat> edlinde: I think there is none except the superficial one
12:46:19 <abstrakt> byorgey: so then what is the purpose of .
12:46:24 <ddarius> > let (.) = flip id in "hello world".words.map (map toUpper).unwords
12:46:25 <lambdabot>   "HELLO WORLD"
12:46:27 <abstrakt> does that have other purposes as well?
12:46:37 <abstrakt> or is it also, only for the purpose of eliminating parentheses
12:46:42 <EvanR-work> :t flip . flip
12:46:44 <lambdabot> forall a b a1. (a -> a1 -> b) -> a -> a1 -> b
12:46:49 <byorgey> abstrakt: (.) is function composition.  It makes a new function out of two functions, by running one after the other
12:46:52 <edlinde> so when do you use a let and when a where?
12:46:55 <byorgey> abstrakt: no, (.) is much more fundamental
12:46:58 <edlinde> can you give me a small example?
12:47:01 <Funktorsalat> (.) can also eliminate names.
12:47:07 <edlinde> I mean let is usually like
12:47:08 <dmwit> edlinde: I pretty much use "where" exclusively.
12:47:08 <monochrom> whenever you are free to use both let and where, you should make the choice according to your heart. but there are some places you can only use one of them.
12:47:10 * hackagebot ipc 0.0.5 - High level inter-process communication library  http://hackage.haskell.org/package/ipc-0.0.5 (ThomasDuBuisson)
12:47:13 <edlinde> let x in exp1
12:47:14 <Funktorsalat> \x -> g (f x) = g . f
12:47:25 <Funktorsalat> the name "x" disappeared
12:47:27 <edlinde> dmwit: but why?
12:47:34 <dmwit> edlinde: I like it better.
12:47:35 * dmwit shrugs
12:47:37 <mauke> edlinde: it looks more l33t
12:47:40 <byorgey> edlinde: it is mostly a matter of style.
12:47:48 <mauke> edlinde: you have to use 'let' in do-blocks, though
12:47:56 <byorgey> but yes, idiomatic Haskell tends to use 'where' much more often than 'let'
12:47:57 <edlinde> ok coz in ML let is used quite a lot
12:48:05 <abstrakt> byorgey: ok, well I get the notation, ala f (g x) and f $ g x
12:48:10 * hackagebot GeBoP 1.7.2 - Several games  http://hackage.haskell.org/package/GeBoP-1.7.2 (HenkJanVanTuyl)
12:48:12 * hackagebot bloxorz 0.1.1 - OpenGL Logic Game  http://hackage.haskell.org/package/bloxorz-0.1.1 (ViktorDevecseri)
12:48:15 <edlinde> so you guys are saying its pretty much the same thing?
12:48:22 <dmwit> I even use "where" for do-blocks, simply passing any bound variables as function arguments.
12:48:23 <abstrakt> and I get the notation (f . g) x f (g x)
12:48:23 <ddarius> edlinde: let also controls the order of effects in ML.
12:48:27 <edlinde> except that let comes in the start while where in the end?
12:48:28 <abstrakt> doh
12:48:33 <ddarius> edlinde: No.
12:48:36 <Funktorsalat> let tends to be more annoying indentationwise ;)
12:48:36 <monochrom> "f x | y>0 = True | y<0 = False  where y=x*x"  you cannot replace with let.
12:48:48 <Funktorsalat> (you have to align the "in" with the "let", I think)
12:48:50 <ddarius> edlinde: let is an expression.  where is part of the function declaration syntax.
12:48:57 <edlinde> ddarius: can you highlight this difference with an example please?
12:49:02 <dmwit> Funktorsalat: No, you have to align the second binding with the first binding.
12:49:23 <monochrom> "do { x <- getLine; let y=x*x; print y }" you cannot replace with where
12:49:33 <Funktorsalat> dmwit: sure, but is there no constraint about the 'in'? (I use 'let' too rarely :))
12:49:34 <monochrom> but otherwise you should just ask your heart.
12:49:43 <abstrakt> I'm sorry to be so dense, but I still don't quite get how . is different from $ in real world applications
12:49:46 <dmwit> monochrom: do { x <- getLine; print (y x) } where y x = x * x
12:49:48 <abstrakt> maybe a better example would help
12:49:52 <Funktorsalat> monochrom: that's a different let
12:49:57 <abstrakt> I understand the working differences between the two
12:49:58 <abstrakt> but
12:50:12 <EvanR-work> they have different types
12:50:13 <abstrakt> f $ g x = f (g x) and (f . g) x = f (g x)
12:50:14 <edlinde> its all quite confusing to be honest
12:50:15 <edlinde> :(
12:50:18 <monochrom> "negate . negate" is not "negate $ negate"
12:50:26 <abstrakt> so, in that instance I don't see a difference
12:50:33 <EvanR-work> i just wish (.) was defined in lambdabot
12:50:34 <byorgey> abstrakt: yes, those are the same
12:50:35 <EvanR-work> :t (.)
12:50:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:50:46 <Funktorsalat> haha
12:50:54 <EvanR-work> :t ($)
12:50:56 <lambdabot> forall a b. (a -> b) -> a -> b
12:50:58 <monochrom> but again, wherever you are free to use $ or . , go with your heart.
12:50:59 <abstrakt> monochrom: ok can you explain that? like expand it?
12:51:03 <mauke> :t (Prelude..)
12:51:06 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:51:35 <monochrom> negate . negate = \x -> negate (negate x).  negate $ negate is a type error. type error is euthemism for nonsense.
12:51:47 <ddarius> monochrom: You should take a more dictatorial approach.  It will save time for everyone.
12:52:13 <abstrakt> ok, now last question
12:52:19 <dolio> > (negate $ negate) 5
12:52:21 <lambdabot>   5
12:52:24 <dolio> Boom!
12:52:30 <monochrom> no, the best way to save time for everyone is to have everyone answer "go with your heart" and no more.
12:52:39 <ddarius> If it didn't have the opposite effect, I'd replace "euphemism" with "euthanasia."
12:52:44 <Funktorsalat> that's caleskell isn't it? dolio 
12:52:47 <abstrakt> > negate $ negate 5
12:52:50 <lambdabot>   5
12:52:50 <edlinde> ddarius: you said let is an expression while where is a part of the function declaration yeah... so whats the difference?
12:52:57 <abstrakt> > negate . negate 5
12:53:06 <Funktorsalat> (disclaimer: cale actually isn't responsible for "caleskell" afaik)
12:53:10 <lambdabot>   No instance for (GHC.Num.Num (f a))
12:53:10 <lambdabot>    arising from a use of `e_15' at <int...
12:53:12 <dolio> Funktorsalat: It's something that's imported into lambdabot. It wasn't written by Cale, to my knowledge.
12:53:16 <abstrakt> > (negate . negate) 5
12:53:17 <edlinde> ddarius: I mean I could do a let and then use say a case statement if I wanted... intead of a guard and where?
12:53:19 <lambdabot>   5
12:53:20 <edlinde> would that work?
12:53:26 <EvanR-work> euphemism
12:53:36 <merijn> > negate . negate $ 5
12:53:37 <lambdabot>   5
12:53:38 <Funktorsalat> (I just meant it's the Num (a -> b) instance)
12:53:41 <abstrakt> monochrom: um, so, apparently those are the same...
12:53:42 <dmwit> > negate (\x -> 37) undefined
12:53:43 <lambdabot>   -37
12:53:55 <ddarius> edlinde: Read the description of Haskell's syntax in the Report and, uh, "go with your heart."
12:54:21 <dmwit> haha
12:54:31 <dmwit> I definitely look forward to more answers of this form.
12:54:34 <abstrakt> byorgey: can you give an example of where . cannot be expressed in an equivalent manner with $ ?
12:54:42 <monochrom> "(negate $ negate) 5" does not work in your ghci. try it.
12:54:53 <abstrakt> monochrom: but that's not the point
12:54:59 <abstrakt> monochrom: because negate $ negate 5 does
12:55:00 <Funktorsalat> use a weakly typed language and "go with your heart" regarding which operations make sense on which data
12:55:05 <abstrakt> I just tried it here in chan
12:55:07 <Funktorsalat> :)
12:55:07 <dmwit> > foldr1 (.) [negate, negate, negate] 5 -- abstrakt, there's a ($) version but it's much uglier
12:55:08 <lambdabot>   -5
12:55:19 <abstrakt> (negate . negate) 5
12:55:20 <abstrakt> negate $ negate 5
12:55:24 <abstrakt> are equivalent
12:55:28 <monochrom> yes.
12:55:33 <mauke> abstrakt: map (negate . negate) xs
12:55:34 <abstrakt> > (negate . negate) 5
12:55:36 <abstrakt> > negate $ negate 5
12:55:36 <lambdabot>   5
12:55:38 <lambdabot>   5
12:55:42 <burp> I prefer negate . negate $ 5 ;P
12:55:50 <dafis> :t let dot = Prelude.(.) in dot `dot` dot
12:55:51 <merijn> abstrakt: 1+2 and 5-2 are equivalent too, so what?
12:55:51 <lambdabot> Not in scope: data constructor `Prelude'
12:55:53 <Funktorsalat> @ty join negate
12:55:54 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
12:55:54 <lambdabot>     Probable cause: `negate' is applied to too few arguments
12:55:54 <lambdabot>     In the first argument of `join', namely `negate'
12:55:55 <dmwit> abstrakt: Only because I happened to use negate. But imagine combining an arbitrary list of functions.
12:56:12 <dafis> :t let dot = (Prelude..) in dot `dot` dot
12:56:12 * hackagebot qd 0.2 - double-double and quad-double number type via libqd  http://hackage.haskell.org/package/qd-0.2 (ClaudeHeilandAllen)
12:56:12 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:56:15 <dmwit> composeAll = foldr1 (.) -- much more annoying to write with ($)
12:56:26 <mauke> composeAll = foldr (.) id
12:56:35 <abstrakt> dmwit: ok how would that be written with $
12:56:45 <abstrakt> I'd like to see how much more annoying it is
12:56:51 <mauke> dohoho
12:56:54 <monochrom> go with your heart. I am tired. is there any question regarding anything more interesting than syntax bikeshed?
12:56:56 <mauke> composeAll = foldr (.) ($)
12:56:59 <Funktorsalat> @ty foldr ($) 
12:57:00 <lambdabot> forall b. b -> [b -> b] -> b
12:57:10 <Funktorsalat> "much more annoying"?
12:57:21 <Funktorsalat> it's just flipped
12:57:38 <mauke> :t flip (foldl ($))
12:57:39 <dmwit> > foldr ($) z [w,x,y]
12:57:40 <lambdabot>     Occurs check: cannot construct the infinite type: b = b1 -> b
12:57:40 <lambdabot>     Probable cause: `$' is applied to too many arguments
12:57:40 <lambdabot>     In the first argument of `foldl', namely `($)'
12:57:40 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
12:57:40 <lambdabot>                           ...
12:57:49 <dmwit> > foldr ($) z [f, g, h]
12:57:50 <lambdabot>   f (g (h z))
12:57:54 <Funktorsalat> > foldr ($) 42 [(*2),(*3),(+1)]
12:57:55 <lambdabot>   258
12:57:57 <dmwit> > foldr (.) id [f, g, h] z
12:57:58 <lambdabot>   f (g (h z))
12:58:06 * dmwit shrugs
12:58:25 <dmwit> Probably not the last time I'll be wrong, either.
12:58:26 <byorgey> abstrakt: since function composition (.) is defined in terms of function application, you will always be able to express composition in terms of application.
12:58:50 <byorgey> abstrakt: if I were you I'd stop worrying so much about how they are different and just start using them.
12:59:13 * hackagebot gmndl 0.1 - Mandelbrot Set explorer using GTK  http://hackage.haskell.org/package/gmndl-0.1 (ClaudeHeilandAllen)
12:59:21 <monochrom> you are an intelligent person. whatever code you write is not ugly.
12:59:29 <mauke> (.) emphasizes the construction of functions from other functions, making it highly radical
12:59:36 <nooodl> haha @pl is great
12:59:49 <Funktorsalat> mauke: radical against which established ideology? ;)
13:00:05 <monochrom> radical against even mathematicians
13:00:11 <mauke> K RAD
13:00:14 <nooodl> @pl \f g h ((a,b),c) -> (f a, (g.h) (b.c))
13:00:16 <lambdabot> flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (. flip (flip . (((.) . (.)) .) . (.)) (.)) .
13:00:16 <lambdabot>  (.) . flip . (((.) . (.) . (,)) .)
13:00:24 <byorgey> Funktorsalat: the ideology of the Empire of Pointyheads
13:00:25 <monochrom> @quote monochrom krad
13:00:27 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
13:00:27 <lambdabot> entire human race would have to be rewritten!
13:00:37 <PatrickRobotham> lol
13:00:39 <nooodl> where's the IOHCC? :)
13:00:40 <abstrakt> dmwit: hmm, I see... so it wouldn't really be possible to write a fold method that would fold an arbitrarily long list if you use $
13:00:52 <abstrakt> but you can write a method that'll fold an arbitrarily long list if you use .
13:01:39 <dmwit> As Funktorsalat demonstrated, that is not a valid argument against ($), unfortunately.
13:02:04 <byorgey> I don't see what's unfortunate about it.
13:02:24 <monochrom> everything in #haskell is very fortunate
13:02:31 <mauke> @fortune
13:02:32 <dmwit> I feel in my gut that (.) is superior in many cases. But I can't demonstrate it.
13:02:33 <lambdabot> Couldn't find fortune file
13:02:49 <dmwit> That's unfortunate, since it either means that my gut is wrong or that I'm a lousy teacher.
13:02:53 <abstrakt> dmwit: well, as they say... "go with your heart" :)
13:03:11 <dmwit> =)
13:03:45 <abstrakt> I'm still interested to know if anyone has some instances in which it is impossible or at least very difficult to write an equivalent statement using $ vs .
13:03:48 <abstrakt> or vice versa
13:03:58 <abstrakt> I know I didn't state that very well, but I think you guys get the picture
13:04:01 <monochrom> the next question will be about line length
13:04:05 <abstrakt> now, last up, currying...
13:04:09 <byorgey> I don't think there are any such instances.
13:04:13 <mauke> <mauke> abstrakt: map (negate . negate) xs
13:04:22 <mauke> using lambda doesn't count
13:04:51 <byorgey> I don't know if a lambda counts as "very difficult", but it's certainly annoying.
13:04:54 <abstrakt> byorgey: ok cool thanks
13:05:06 <mauke> negate . negate . xs
13:05:08 <byorgey> map (negate . negate) xs    versus   map (\x -> negate $ negate $ x) xs
13:05:14 <byorgey> which would you rather write?
13:05:22 <abstrakt> yeah I'd rather write the first one
13:05:38 <monochrom> but then you wouldn't even consider (\x -> negate $ negate $ x) to begin with. there is no comparison.
13:05:51 <abstrakt> monochrom: you wouldn't? why not?
13:06:20 <monochrom> did (\x -> negate $ negate $ x) ever cross your mind?
13:06:42 <byorgey> monochrom: I imagine that would cross lots of new Haskell programmers' minds at first.
13:06:53 <abstrakt> um... no, but then again neither did map (negate . negate) xs
13:06:58 <Funktorsalat> not sure if you mean the form or the fact that the whole thing can be written as 'id'
13:06:59 <mauke> map f xs where f x = negate $ negate x
13:07:03 <byorgey> "let's see, I need a function to give to map... ok, \x ->  ...  now what should the function do?  well..."
13:07:22 <Funktorsalat> (except for strictness :P)
13:07:38 <monochrom> I bet you are likely to think up either "map f $ map g x" or "map f . map g $ x" or "map (f . g) x" yourself. but never (\x -> negate $ negate $ x)
13:07:42 <byorgey> ok, maybe negate . negate is a bad example
13:07:55 <Funktorsalat> :)
13:08:16 <byorgey> monochrom: I am teaching a class full of beginning Haskell programmers at the moment.  You would be surprised at the things they think of.
13:08:38 <monochrom> but abstrakt is not one of the students in the class.
13:08:52 <abstrakt> no, but I am in fact a beginning haskell programmer
13:09:02 <abstrakt> not a beginning programmer by any means, but a beginning haskell programmer
13:09:03 <monochrom> there is some self-selection bias in those who voluntarily join #haskell that I can rely on.
13:09:10 <HugoDaniel> hey
13:09:33 <dmwit> I think byorgey's class has a fair bit of self-selection bias as well.
13:09:39 <monochrom> hell, in fact some self-selection bias in those who manage to use IRC these days.
13:09:41 <dmwit> (It's basically an elective.)
13:09:48 <byorgey> whatever, this discussion is getting fairly useless IMO
13:09:57 <abstrakt> yeah, I'm actually consistenly surprised though, at how many idiots find their way on to IRC
13:10:03 <byorgey> hi HugoDaniel 
13:10:08 <abstrakt> I'm like "how did you even manage to tie your shoes? much less get on to IRC?"
13:10:14 <Entroacceptor> monochrom: which gives a sad statement about the world
13:10:57 <monochrom> self-select bias for elective classes is present but not as strong. consider the possible scenerio: "you must take one of these 3 electives: haskell, NP-completeness, Gödel incompleteness"
13:11:51 <joe1> > filter (\x -> (isHexDigit $ x !! 2) && (isHexDigit $ x !! 3) ) .filter (\x -> "0x" == take 2 x && 4 == length x ) . words $ "<<<<< 0x4B data1 pid 0x12 descriptor length 0x01 descriptor type = device 0x10 bcdUSB low byte 0x01 bcdUSB high byte 0x00 bDevice class 0x00 bDevice sub class 0x00 bDevice protocol 0x08 Max packet size"
13:11:54 <lambdabot>   ["0x4B","0x12","0x01","0x10","0x01","0x00","0x00","0x00","0x08"]
13:11:57 <HugoDaniel> hey byorgey, how is that haskell going ?
13:12:06 <HugoDaniel> lambdabot shellcode
13:12:07 <HugoDaniel> :)
13:12:50 <abstrakt> yeah I'd choose haskell right off the bat, not even knowing what the others were :)
13:13:03 <abstrakt> not sure why, but the others sound boring
13:13:14 <Entroacceptor> mh, I think I'd go with Gödel
13:13:15 <abstrakt> anyway, last main question I have and then I'll leave yall alone and continue with my learnings
13:13:20 <Entroacceptor> I just love that :)
13:13:26 <abstrakt> well Godel Escher Bach is a good book
13:13:31 <abstrakt> so there's that
13:13:33 <abstrakt> but still
13:13:44 <joe1> > isHex
13:13:46 <lambdabot>   Not in scope: `isHex'
13:13:47 <abstrakt> how does currying work? I'm not quite clear on this
13:13:47 <joe1> :t isHex
13:13:49 <lambdabot> Not in scope: `isHex'
13:13:53 <dmwit> > [hexWord | hexWord@['0','x',x,y] <- words "<<<<< 0x4B data1 0x12", isHexDigit x && isHexDigit y]
13:13:54 <lambdabot>   ["0x4B","0x12"]
13:14:15 <mauke> abstrakt: what's unclear?
13:14:22 <Funktorsalat> if you already know about g'd incompleteness thm., that may explain why the prospect of relearning it seems boring ;)
13:14:24 <joe1> dmwit: that is pretty cool.. thanks a lot.
13:14:29 <dmwit> > [hexWord | hexWord@('0':'x':rest) <- words "<<<<< 0x4B data1 0x12 data2 0x1234", all isHexDigit rest]
13:14:30 <Funktorsalat> s/'d/'s
13:14:30 <lambdabot>   ["0x4B","0x12","0x1234"]
13:14:57 <joe1> no, the hex numbers are exactly a byte, in my scenario.
13:15:03 * dmwit nods
13:15:12 <merijn> abstrakt: But the people of the category "how did they get on IRC" are quite consistently scared a way by talk of category theory, endofunctors and monads :p
13:15:30 <monochrom> anyway, yes, I always make sad statements about people.
13:15:39 <abstrakt> mauke: sorry busy, and also trying to formulate exactly what I'm unclear on :)
13:15:40 <byorgey> abstrakt: currying refers to representing a function of multiple arguments as a function of one argument which returns a function
13:15:55 <joe1> btw, is it wrong to do what I am doing on this irc? post working code and check for refinements from the irc folks?
13:16:11 <byorgey> abstrakt: for example, we usually think of the addition operation as taking two numbers as input and returning one number
13:16:14 <Entroacceptor> fun fact: I've cleared out some seats in the subway train talking about mathematics :)
13:16:21 <byorgey> abstrakt: but look at the type of (+) in Haskell:
13:16:23 <byorgey> @type (+)
13:16:25 <lambdabot> forall a. (Num a) => a -> a -> a
13:16:38 <byorgey> ignoring the (Num a) part for the moment, it is  a -> a -> a
13:16:49 <dmwit> joe1: I do the same thing all the time.
13:16:51 <byorgey> -> associates to the right, so this is the same as   a -> (a -> a)
13:17:03 <dmwit> joe1: The longer it is, the more polite it is to use hpaste.org, of course.
13:17:12 <byorgey> which means that (+) takes one number of type a as input, and returns a function of type (a -> a)
13:17:21 <byorgey> that function will take a number as input, and finally return the sum of the two numbers
13:17:34 <byorgey> abstrakt: does that make sense?
13:17:39 <abstrakt> yes I think so
13:17:46 <joe1> dmwit: ok, thanks
13:17:53 <abstrakt> it's mainly the part about the function of one argument, that I'm trying to wrap my head around
13:18:17 <abstrakt> like, in practice, I definitely can just "go with my heart" and basically understand how currying works
13:18:18 <merijn> abstrakt: Compare the following types
13:18:20 <merijn> :t map
13:18:21 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:18:25 <merijn> :t map even
13:18:26 <lambdabot> forall a. (Integral a) => [a] -> [Bool]
13:18:33 <merijn> :t even
13:18:34 <lambdabot> forall a. (Integral a) => a -> Bool
13:18:35 <abstrakt> but the function of a single argument still kind of confuses me
13:18:49 <abstrakt> I think I can actually express it better if I go look up the currying example from this tutorial I'm reading
13:19:04 <abstrakt> anyone have opinions on the "Learn You A Haskell" tutorial? cuz that's what I'm reading. I like it so far
13:19:10 <byorgey> it's good
13:19:24 <dmwit> psh
13:19:35 <merijn> abstrakt: It's pretty ok
13:19:39 <dmwit> If the Gentle Intro was good enough for our predecessors, it ought to be good enough for our postdecessors.
13:20:12 <c_wraith> It's still my favorite intro tutorial, though I think the monad section is...  A bit too soon.  As in, you should spend a lot of hours on the previous chapters.
13:20:38 <merijn> dmwit: In the words of #python: "<Brend> Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something." :p
13:21:07 <cathper> :-D
13:21:16 <dmwit> =)
13:21:24 <c_wraith> @quote gentle.introduction
13:21:24 <lambdabot> No quotes match. I've seen penguins that can type better than that.
13:21:34 <dmwit> Well, considering its real history, I'll have to inform my colleagues that dependent types == wrestling bears.
13:21:39 <dmwit> They'll probably approve. =)
13:21:59 <cathper> It's gentle, at least when you have studied math and CS for some time.
13:22:36 <merijn> cathper: Most CS programs don't really include the relevant math over here
13:23:10 <abstrakt> ok, here's where I get confused
13:23:18 <abstrakt> > max 4 5
13:23:20 <lambdabot>   5
13:23:24 <abstrakt> > (max 4) 5
13:23:26 <lambdabot>   5
13:23:35 <aristid> > max (4 5) 6
13:23:37 <lambdabot>   6
13:23:38 <abstrakt> how can max take a single argument? that just baffles me still
13:23:38 <augustss> what's confusing about that?
13:23:44 <cathper> merijn: The same here; that's why I usually advice CS students to start with a year of math. That pays them back later.
13:23:53 <merijn> :t max
13:23:54 <lambdabot> forall a. (Ord a) => a -> a -> a
13:23:54 <aristid> abstrakt: ALL haskell functions take a single argument
13:23:55 <abstrakt> max takes two arguments
13:23:56 <Zao> @type (max 4)
13:23:57 <lambdabot> forall t. (Num t, Ord t) => t -> t
13:24:07 <aristid> abstrakt: no, max takes one argument. as do all haskell functions.
13:24:08 <augustss> abstrakt: max takes one argument
13:24:09 <olsner> @ty max (4 5)
13:24:12 <lambdabot> forall a. (Num a, Ord a) => a -> a
13:24:18 <dmwit> abstrakt: (max 4) is a function that takes one argument, and either returns that argument or 4, whichever is bigger.
13:24:24 <merijn> :t max 4
13:24:25 <lambdabot> forall t. (Num t, Ord t) => t -> t
13:24:32 <aristid> :t (4 5)
13:24:33 <abstrakt> dmwit: ahh, hmm... ok
13:24:34 <lambdabot>     Ambiguous type variable `t' in the constraint:
13:24:34 <lambdabot>       `Num t' arising from the literal `5' at <interactive>:1:3
13:24:34 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
13:24:39 <aristid> :t (4 5) :: Num a => a
13:24:41 <lambdabot> forall a. (Num a) => a
13:24:43 <abstrakt> dmwit: that makes more sense to me, sure
13:24:50 <dmwit> abstrakt: If I wrote "f x = max 4 x", would "f" be a sensible function? If so, why shouldn't "max 4" on its own be a sensible function?
13:24:51 <merijn> max 4 == a function that takes one argument and returns the maximum of 4 and that argument
13:24:58 <olsner> does lambdabot have a Num instance for functions or something?
13:25:21 <abstrakt> merijn: ok, but then what about max?
13:25:23 <abstrakt> just by itself
13:25:24 <nooodl> wait, what, ":t (4 5) :: Num a => a" blew my mind
13:25:28 <augustss> I think our lambdabot sucks for beginners
13:25:35 <nooodl> is this applying 4 to 5?
13:25:45 <dmwit> nooodl: There's a funny instance in lambdabot that looks like Num a => Num (e -> a).
13:25:45 <cathper> abstrakt: When you work your head through currying, you must accept that every function takes exactly 1 argument. When you understand currying you'll "ignore" that however.
13:25:45 <augustss> It shouldn't have all kinds of extensions
13:25:52 <c_wraith> nooodl, no, it's applying 5 to 4.
13:26:09 <merijn> abstrakt: max is a function that takes a number x and returns a function comparing x against another number, returning the highest
13:26:19 <Cale> Applying the function 4 to the value 5
13:26:23 <c_wraith> nooodl, It "works" because numeric literals are polymorphic, and lambabot has an instance of Num for functions.
13:26:31 <abstrakt> hmm... ok I'm *almost* there
13:26:33 <dmwit> nooodl: so "4" gets translated to "fromInteger 4", which, for this instance, is probably "\x -> 4" or so.
13:26:54 <abstrakt> > (((max) 4) 5)
13:26:56 <lambdabot>   5
13:27:00 <nooodl> > (4 5)
13:27:01 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:27:01 <lambdabot>    `GHC.Num.Num t' arising f...
13:27:02 <merijn> abstrakt: Compare ":t map", ":t even" and ":t map even"
13:27:08 <abstrakt> so what about (max)
13:27:08 <dmwit> > 4 5 :: Integer
13:27:09 <lambdabot>   4
13:27:14 <abstrakt> that doesn't take any arguments... how can that be?
13:27:18 <dmwit> abstrakt: What about it?
13:27:22 <nooodl> > max (4 8) 6
13:27:23 <lambdabot>   6
13:27:27 <abstrakt> max has to start somewhere, like there's a chicken and the egg problem here IMO
13:27:29 <nooodl> > max (8 4) 6
13:27:29 <lambdabot>   8
13:27:46 <merijn> abstrakt: (max) == max, the parenthesis are ignored
13:27:55 <monochrom> "4 6" is another lambdabot specialty. not in your ghci. don't worry, the world hasn't ended yet.
13:27:57 <dmwit> abstrakt: max is a function that takes an argument and returns another function. Nothing too surprising there.
13:28:07 <merijn> abstrakt: (4) + (5) also works in most languages, right?
13:28:13 <nooodl> monochrom: phew!
13:28:25 <monochrom> but it will end tomorrow
13:28:47 <abstrakt> dmwit: ok (max 4) returns a function, how does max know what function to return?
13:28:59 <abstrakt> like where does that function come from if that function is not max itself?
13:29:03 <dmwit> ?src max
13:29:04 <lambdabot> max x y = if x <= y then y else x
13:29:07 <dmwit> so
13:29:10 <merijn> abstrakt: The type system and your specification of the function
13:29:10 <abstrakt> it seems to me that max must be different from the function that it returns
13:29:13 <dmwit> max 4 = \y -> if 4 <= y then y else 4
13:29:17 <merijn> abstrakt: Yes
13:29:44 <abstrakt> dmwit: ok but the src of max is a function that takes two arguments, x and y
13:29:57 <dmwit> max = \x -> \y -> if x <= y then y else 4
13:29:59 <abstrakt> where is the source of the max function that only takes one argument
13:30:00 <merijn> abstrakt: Does this make sense? "\x -> \y -> if x <= y then y else x"
13:30:24 <dmwit> max 4 = (\x -> \y -> if x <= y then y else x) 4 = \y -> if 4 <= y then y else 4
13:30:26 <augustss> abstract: f x y = ...  is the same as f = \ x -> \ y -> ....
13:30:55 <cathper> Syntactic sugar.
13:31:02 <abstrakt> merijn: ok yes I think that makes sense
13:31:19 <merijn> abstrakt:  Function declarations are just syntactic sugar for that
13:31:43 <dmwit> (We're fudging a tiny bit. Haskell doesn't quite treat (f x y = ...) and (f = \x y -> ...) the same way. But let's ignore that for now, it's kind of silly.)
13:31:53 <abstrakt> it seems like it still takes arguments to me
13:32:00 <abstrakt> just because you give it one, doesn't mean it's complete
13:32:05 <merijn> Like Knuth I'm a firm believer in lying for understanding :p
13:32:11 <dmwit> abstrakt: Both those sentences sound true.
13:32:16 <abstrakt> merijn: me too actually :)
13:32:21 <aristid> dmwit: does the monomorphism restriction hit there?
13:32:28 <abstrakt> I think I get it though
13:32:39 <dmwit> aristid: Yes, and I think there's something funny going on with caching, as well.
13:32:41 <augustss> dmwit: the MR is a goner!
13:32:47 <abstrakt> if you only give it one argument, it returns a function that is now half complete, which is waiting for its "other" argument
13:32:54 <aristid> dmwit: well caching is not semantically relevant, at least for beginners
13:32:59 <merijn> abstrakt: The basic idea is that function are values which can be returned and passed around
13:33:02 <abstrakt> you give the function one argument, then it returns a function that takes one argument
13:33:05 <dmwit> aristid: e.g. f x y = let foo = 3 in blah /== f = let foo = 3 in \x y -> blah
13:33:05 <abstrakt> so I see how that happens
13:33:07 <aristid> dmwit: also the monomorphism restriction must die.
13:33:07 <merijn> abstrakt: Close enough
13:33:22 <abstrakt> just, semantically in my head, from a practical perspective, max doesn't do anything until you've given it two arguments
13:33:26 <dmwit> Yes, the MR should die in a fire.
13:33:31 <abstrakt> but I guess I see now how it can be defined
13:33:34 <merijn> abstrakt: Not entirely true
13:33:36 <abstrakt> such that it can take one argument
13:33:42 <abstrakt> and then return a function that takes one argument
13:33:44 <aristid> dmwit: a big, violent fire
13:33:52 <augustss> dmwit: but in that you moved a let across lambdas.  i never claimed those were equal.
13:33:57 <merijn> abstrakt: Example (assuming you understand map): "map (max 4) [1..10]"
13:33:58 <abstrakt> that second function is more complete than the first
13:34:09 <dmwit> augustss: fair enough
13:34:10 <abstrakt> but the thing is, one of those functions returns a function, the other returns a value
13:34:12 <merijn> > map (max 4) [1..10]
13:34:13 <lambdabot>   [4,4,4,4,5,6,7,8,9,10]
13:34:16 <augustss> dmwit: the MR going away in the next version on Haskell
13:34:23 <abstrakt> because fundamentally, there is a definition of a function that needs two arguments
13:34:24 <merijn> abstrakt: Functions are values
13:34:32 <dmwit> abstrakt: A function *is* a value!
13:34:40 <aristid> augustss: foreal?
13:34:44 <abstrakt> dmwit: yeah but not all values have the same type
13:34:49 <abstrakt> e.g. String vs Integer
13:34:54 <merijn> abstrakt: Correct
13:35:01 <dmwit> Well, you would hope that not all values have the same type, yes.
13:35:11 <nostrand> hi, does anyone have som example code of mutable Vector in the ST monad?
13:35:15 <merijn> abstrakt: And max and (max 4) do not have the same type, yeah
13:35:16 <abstrakt> so if you give max a single argument, it returns a value of type function, if you then give that function a single argument, it returns a value of type Integer (presumably)
13:35:24 <abstrakt> merijn: yes that's what I was getting at
13:35:27 <merijn> abstrakt: Yes
13:35:51 <abstrakt> so I guess the thing that confused me
13:35:53 <abstrakt> is
13:35:54 <merijn> abstrakt: Try typing partially applied function in ghci with ":t" to see what happens
13:35:55 <abstrakt> ?src max
13:35:57 <lambdabot> max x y = if x <= y then y else x
13:36:01 <merijn> Very useful learning experience
13:36:12 <abstrakt> that source does not return a function anywhere that I can see
13:36:23 <abstrakt> so currying is a function of the haskell language
13:36:32 <dmwit> abstrakt: Oh, yes, it's just hidden for convenience.
13:36:43 <abstrakt> ok
13:36:48 <dmwit> abstrakt: You could just as well write max = \x -> \y -> ...
13:36:59 <dmwit> abstrakt: So, \x -> ... is a function that returns \y -> ....
13:37:02 <merijn> abstrakt: You could write "max = \x -> \y -> ...", but would you want to?
13:37:08 <abstrakt> ahh
13:37:18 <dmwit> abstrakt: But it's way annoying to write that, so we add the possibility of writing max x y = ..., instead.
13:37:23 <monochrom> "go with your lungs" or something
13:37:33 <abstrakt> hmm, if x returns y, but y contains x in its definition... how can that work?
13:37:41 <dmwit> "my lungs?" "close enough"
13:37:45 <merijn> abstrakt: Closures
13:37:57 <merijn> abstrakt: You're familar with C and the stack?
13:38:00 <abstrakt> max = \x -> \y -> if x <= y then y else x
13:38:24 <abstrakt> merijn: um, vaguely... you mean the call stack? or like stack the data structure?
13:38:25 <monochrom> same closure considerations in javascript
13:38:29 <dmwit> abstrakt: Well, I fudged again. Here's a more precise way of saying what I meant.
13:38:36 <merijn> abstrakt: The call stack, yes
13:38:45 <abstrakt> ok, yes I've done assembly language (for example)
13:38:51 <merijn> abstrakt: What if we do not store our function arguments on the stack and our function has a pointer to where we stored said arguments in memory?
13:39:21 <merijn> abstrakt: Then we could just pass around our function + pointer to where its arguments are located (even if some are missing), no?
13:39:32 <dmwit> (\x -> \y -> M) is a function which, when supplied with an argument (say, 'z'), returns (\y -> M { 'z' / x }), where the syntax (M { 'z' / x }) means "substitute 'z' for x anywhere x occurs".
13:39:43 <cathper> x is just a free variable ...
13:40:27 <cathper> I learned lambda calculus before Haskell; that might actually be easier?
13:40:31 <merijn> abstrakt: We can wrap all that in boiler plate code and let the compiler deal with it for us. Haskell does not use a call stack as C does
13:40:52 <merijn> cathper: Yes, probably, as long as you don't care about the implementation then
13:41:19 <cathper> merijn: Sure. Understanding the concepts ...
13:41:42 <abstrakt> merijn: ok sure I get the concept of passing around the function and a pointer to arguments, sure
13:42:03 <merijn> abstrakt: For now just think of the compiler magically having taken care of that for you
13:42:03 <abstrakt> merijn: I mean, in assembly, you have to know specifically what registers your arguments will be in, there's no passing of a pointer or some such
13:42:23 <dmwit> Internally, we might like to represent (\y -> M { 'z' / x }) as a pair of an "environment mapping" and a term, like ({ x -> 'z' }, \y -> M) instead. This is called a closure.
13:42:57 <dmwit> The benefit is that we do less computation at application time.
13:43:24 <abstrakt> dmwit: ok cool so it's part of the language to be able to include all the arguments of a function in the definition, but haskell still treats is a "a function that returns a function that returns a function"
13:43:29 <abstrakt> and just substitutes one variable at a time
13:43:37 <abstrakt> until it stops returning partial functions and finally computes a value
13:43:43 <dmwit> You got it!
13:43:45 <merijn> abstrakt: Yeah
13:43:48 <abstrakt> great
13:43:51 <abstrakt> yup, makes sense :)
13:44:03 <merijn> abstrakt: Well, actually. It does not evaluate the function until you try to use the result :p
13:44:08 <abstrakt> true
13:44:10 <augustss> abstrakt: A function call always returns a value.  Some of those values are functions.
13:45:00 <abstrakt> but it is also true, from a laymans perspective, that functions may "take" more than one argument
13:45:06 <abstrakt> i.e. the number of arguments
13:45:09 <abstrakt> defines the boundary/border cases
13:45:13 <abstrakt> if there are three arguments
13:45:16 <abstrakt> yes
13:45:20 <abstrakt> you can pass only a single argument
13:45:28 <abstrakt> but you won't get the result you expect
13:45:32 <dmwit> abstrakt: Figuring out what a type like (a -> b -> c) meant was what convinced me that Haskell was the language for me. It wasn't until later that I discovered this was tame stuff for PL people, not Haskell-specific. =P
13:45:35 <abstrakt> until you've finally passed through three functions
13:45:55 <abstrakt> so that the function finally stops just substituting variables and actually evaluates itself
13:46:24 <abstrakt> so there is a borderline between substitution and evaluation (as I am using those terms here for my own edification, I'm sure they could me something different to haskell specifically)
13:46:28 <dmwit> It bothers me a little bit that you don't consider the substitution to be "evaluating itself".
13:46:44 <abstrakt> dmwit: it bothers me that you do consider it to be evaluating itself :)
13:46:57 <dmwit> For example, consider the definition of ($) again.
13:46:59 <abstrakt> dmwit: for example, that if statement is never run
13:47:00 <merijn> abstrakt: Fairly natural when coming from lambda calculus/type theory :p
13:47:04 <dmwit> f $ x = f x
13:47:05 <dmwit> or
13:47:09 <abstrakt> until all the variables are present
13:47:16 <dmwit> mmm, no, not ($)
13:47:18 <abstrakt> only substution is happening, there's no calculation
13:47:31 <dmwit> abstrakt: But calculation *can* sometimes happen before all the variables are available!
13:47:32 <merijn> abstrakt: You can also think of a haskell program as being a single large expression
13:47:53 <abstrakt> dmwit: sure if a given calculation only requires two out of the three variables present in the expression
13:48:06 <abstrakt> dmwit: but still, the overall expression is not calculated until all variables are present
13:48:15 <abstrakt> it's "half baked" so to speak
13:48:17 <dmwit> Even if it requires them all.
13:48:36 <dmwit> Consider f x = if x then \y -> y else \y -> y + 1.
13:48:42 <dmwit> f is a function of two arguments.
13:48:46 <dmwit> f :: Bool -> Int -> Int
13:49:14 <abstrakt> "partially cooked" aka "curried" :)
13:49:17 <dmwit> but (f True) can actually do some calculation... it simplifies to (\y -> y) not to a closure.
13:49:29 <abstrakt> I had curry for lunch incidentally... he was tasty
13:50:03 <wlangstroth> neuter pronouns in English - "it" was tasty
13:50:19 <merijn> abstrakt: It actually comes from the mathematician Haskell Curry :p
13:50:21 <abstrakt> wlangstroth: no I'm talking about the dude, I'm a grave robber and a cannibal
13:50:25 <abstrakt> merijn: I know
13:50:30 <dmwit> similarly, we can expand this example to (f x = if isAPrime x then \y -> y else \y -> y + 1), to make it really clear that an expensive computation can happen before all arguments are supplied.
13:50:35 <abstrakt> hence the joke that apprently neither of you understood :)
13:50:57 <wlangstroth> abstrakt: I never get cannibal jokes
13:51:21 <wlangstroth> it's my humorous my Achilles heel
13:51:34 <dmwit> You know what the cannibal child got when he was late to the dinner table?
13:51:37 <wlangstroth> hmm - maybe that needed more "my"s
13:51:39 <dmwit> The cold shoulder.
13:52:01 * EvanR-work asks something about the difference between something and a dead baby, rhetorically
13:52:27 <joe1> mapM wirtetofile ["a","b","c"] : can I assume that the file will have "abc" or do I have to sequence to be sure?
13:52:29 <EvanR-work> GeneralizedJokeDeriving
13:52:40 <abstrakt> why is it easier to unload a wheelbarrow full of dead babies than it is to unload a wheelbarrow full of bowling balls?
13:52:50 <abstrakt> because at least with a wheelbarrow full of dead babies you can still use a pitch fork
13:52:54 <merijn> You can use a pitchfork?
13:53:22 <abstrakt> how do you get 10 dead babies into a bowl
13:53:23 <merijn> It should be possible to inductively proof all dead baby jokes funny...
13:53:24 <dmwit> ?src mapM
13:53:25 <lambdabot> mapM f as = sequence (map f as)
13:53:26 <abstrakt> blender
13:53:30 <abstrakt> how do you get them out?
13:53:30 <dmwit> joe1: mapM already uses sequence =)
13:53:32 <abstrakt> nachos
13:53:37 <joe1> dmwit: thanks.
13:53:41 <dmwit> joe1: Also, you might be interested in mapM_
13:54:00 <abstrakt> aight, well anyway, I now believe that I fully understand currying and $ vs .
13:54:13 <EvanR-work> forM_ whileM_ ifM_ breakM_ continueM_
13:54:37 <EvanR-work> gotoM_
13:54:42 <EvanR-work> returnM_
13:54:53 <abstrakt> dmwit: right, well I wasn't negating anything you just said about an expensive computation, in fact we are saying the same things
13:54:58 <olsner> longjmpM_
13:55:16 <abstrakt> dmwit: as I said earlier, if a particular expression only uses e.g. 2 out of the 3 arguments in the function, then yes that expression could be calculated
13:55:26 <abstrakt> foo x y z = x + y + z
13:55:30 <abstrakt> foo 3 4
13:55:38 <abstrakt> could still be partially computed, I realize that
13:55:59 <abstrakt> but, still the main caveat in my mind, is: that partically calculated result is not returned
13:56:04 <abstrakt> foo 3 4 doesn't return 7
13:56:22 <abstrakt> it returns a partial function
13:56:28 <abstrakt> that is waiting for a single argument
13:56:45 <dmwit> > let isPrime x = isPrime (x + 1) {- infinite loop -}; foo x y = if isPrime x then y else y+1 in foo 3 `seq` "hey"
13:56:46 <lambdabot>   "hey"
13:56:50 <abstrakt> dmwit: we were in fact saying, I think the same thing
13:56:52 <c_wraith> > 1 2 3 4 5
13:56:52 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:56:52 <lambdabot>    `GHC.Num.Num t' arising f...
13:56:59 <abstrakt> specifically that partial computation can occur
13:57:08 <dpratt71> well, I was going to ask some questions about Arrows, but I've run out of time (for now)...does anyone know of a good tutorial off-hand? particularly one that discusses Arrow 'notation'?
13:57:19 <abstrakt> but my point, is that even if partial computation occurs, you still don't get an actual result, you get a curried function waiting for its next argument
13:57:43 <dmwit> Okay. If that's what you were saying, then we were indeed saying the same thing.
13:57:49 <abstrakt> cool :)
13:57:53 <dmwit> dpratt71: Yes, one second.
13:57:57 <abstrakt> yay!
13:58:06 <abstrakt> we agree! (or so it seems)
13:58:16 <dpratt71> dmwit: ok, standing by
13:58:23 <abstrakt> ok thanks people, I'm gonna go back to learning more haskell :)
13:58:28 <dmwit> dpratt71: The papers are quite readable, http://www.haskell.org/arrows/biblio.html
13:58:29 <augustss> abstrakt: and returning anything but a function when you have a partial application would be a type error, so there's no choice. :)
13:58:38 <abstrakt> augustss: indeed
13:58:57 <dpratt71> dmwit: I'll check those out, thanks
13:59:26 <dmwit> dpratt71: I really recommend the paper on arrow parsers as a first one, and the Wadler paper for a third or fourth one.
13:59:48 <dpratt71> dmwit: ok
14:00:02 <McManiaC> http://npaste.de/nL/ <- why is n not printed?
14:00:18 <dmwit> [Hug00] on the page I linked is the parser one
14:00:45 <dmwit> McManiaC: Because (unsafePerformIO ...) is never evaluated.
14:01:05 <dmwit> McManiaC: Try Debug.Trace instead.
14:01:20 <nooodl> argh, i can't do [2..sqrt n], and "floor" isn't helping, nor is "round"
14:01:22 <dmwit> s/evaluated/demanded/
14:01:41 <dschoepe> McManiaC: instead you could use case trace (show n) n of...
14:01:42 <ezyang> @type sqrt 
14:01:45 <lambdabot> forall a. (Floating a) => a -> a
14:01:53 <ezyang> @hoogle Floating a => a -> Int 
14:01:53 <dmwit> > [2 .. floor (sqrt (fromIntegral 37))]
14:01:54 <lambdabot>   [2,3,4,5,6]
14:01:54 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
14:01:54 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
14:01:54 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
14:02:01 <ezyang> \ldots 
14:02:05 <McManiaC>  dmwit: ah, right
14:02:08 <dmwit> nooodl: You probably need casts on both sides.
14:02:11 <McManiaC> I `seq`ed it
14:02:41 <nooodl> > [2 .. floor (sqrt 37)]
14:02:42 <lambdabot>   [2,3,4,5,6]
14:02:52 <nooodl> hey it is working on lambdabot
14:02:54 <dmwit> nooodl: but compare
14:03:00 <abstrakt> ok actually, I have another question
14:03:00 <dmwit> > [2 .. floor (sqrt (37 :: Integer))]
14:03:01 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Internals.Integer)
14:03:01 <lambdabot>    arisi...
14:03:04 <abstrakt> but it's more hypothetical
14:03:14 <abstrakt> how are the basic IO functions of get and put not pure?
14:03:30 <abstrakt> because it seems to me that they are quite stable
14:03:35 <dmwit> abstrakt: What would their (pure) value be?
14:03:41 <nooodl> ooh [2..floor $ sqrt $ fromInteger n]
14:03:44 <abstrakt> putChar 's' will always print the letter s
14:03:50 <abstrakt> there's no ambiguity there
14:03:52 <dmwit> nooodl: 17:01 < dmwit> > [2 .. floor (sqrt (fromIntegral 37))]
14:03:53 <abstrakt> getLine
14:03:54 <dmwit> ;-)
14:03:56 <abstrakt> when you enter "hello"
14:03:59 <abstrakt> er
14:04:04 <abstrakt> foo <- getLine
14:04:09 <abstrakt> when you enter "hello"
14:04:14 <abstrakt> foo will always contain the word "hello"
14:04:20 <dmwit> abstrakt: "pure" means "you can replace this with its definition"
14:04:45 <dmwit> abstrakt: So you are claiming you can write a definition for (foo :: String) that behaves like getLine, but can be replaced by its definition everywhere.
14:05:08 <dmwit> abstrakt: But any value you choose of type String, say, "hello", will be wrong whenever the user doesn't enter that exact string.
14:06:07 <kolmodin> ketil: yes, c.h.o/binary is the latest released
14:06:43 <ketil> kolmodin, right, I discovered.  No tagged releases in the repo, though.
14:07:00 <dmwit> On the other side, you could certainly define something with the type (foo :: String -> ()), but the computation (foo "hello") wouldn't have the desired effect: "hello" wouldn't appear on the screen.
14:07:01 <kolmodin> ketil: right, that might be the case
14:07:37 <dschoepe> abstrakt: They are only pure in the sense that they always return the same IO _action_
14:07:41 <ketil> kolmodin, I was so sure I needed the lazy binary (i.e. <0.5), but I wanted to include other improvements that might have happened.
14:07:54 <abstrakt> dschoepe: but not the same data?
14:08:07 <abstrakt> it seems though, that output is always pure
14:08:18 <abstrakt> input, I could see maybe how that's not pure (though I'm not quite there yet)
14:08:34 <abstrakt> but output seems pure to me
14:08:37 <ketil> kolmodin, but now I can't seem to put together a test case that shows the difference, i.e. I thouhgt "decode (concat [encode 42, undefined])" would break on post 0.5
14:08:44 <abstrakt> putChar 's' always does the same thing when called with the same argument
14:08:53 <ketil> but it seems to work(!)
14:09:15 <dmwit> abstrakt: No, not quite the same. It has to know where on the screen to put the 's'. =)
14:09:22 <kolmodin> ketil: I see
14:09:31 <kolmodin> ketil: that might not be properly documented and non-obvious
14:09:31 <dmwit> Different invocations can (and often do) put it at different places.
14:09:35 <ketil> Have I capped binary version in vain, or is the test case something else?  (I'm fairly sure recent binary pulls in the entire file to decode a sequence of records, though)
14:09:38 <abstrakt> dmwit: nah, that's handled by the OS
14:09:46 <dmwit> abstrakt: The OS is impure, too.
14:09:51 <dmwit> Nothing surprising there.
14:09:52 <ketil> I'm sure I had a one line test case, but I can't find it :-(
14:09:58 <abstrakt> dmwit: that's fine, but haskell should be able to hand off something pure, to something impure
14:10:00 <dschoepe> abstrakt: still, calling the function twice results in different behaviour
14:10:18 <abstrakt> dschoepe: but not *that* different, and only different because of the OS
14:10:20 <dmwit> abstrakt: It can. By wrapping it in a marker saying that it's impure.
14:10:32 <dmwit> :t return :: a -> IO a
14:10:33 <lambdabot> forall a. a -> IO a
14:11:04 <abstrakt> dmwit: well but in this case I mean output should be considered pure
14:11:13 <dmwit> I strongly disagree.
14:11:16 <abstrakt> and haskell should hand off the output to the "impure" thing which is the OS
14:11:24 <augustss> abstrakt: absolutely not
14:11:24 <abstrakt> the purity of the haskell output function (IMO) should remain intact
14:11:34 <ketil> kolmodin, ah, found it in my mail.
14:11:52 <abstrakt> basically the output function takes one param, and then returns that param to the OS
14:11:55 <dmwit> abstrakt: If it doesn't philosophically bother you to have output be pure, then consider this practical argument: the user could close the terminal in between two calls to putChar.
14:11:56 <kolmodin> ketil: if you decode a file then you can use 'decodeFile'. it will make sure that the file handle is closed
14:11:57 <abstrakt> it always does the same thing, every time
14:12:03 <dmwit> abstrakt: Then the first call returns (), and the second returns an exception.
14:12:10 <kolmodin> ketil: (or so the docs say at least :))
14:12:23 <abstrakt> dmwit: um, wouldn't the closing of the terminal close the program first?
14:12:30 <dmwit> Nope.
14:12:33 <abstrakt> so it would never throw the exception
14:12:34 <dschoepe> abstrakt: If so, would you say that it should have type Char -> ()? If yes, you should be able to optimize that call away everytime you call it, since it can only return ().
14:13:01 <dmwit> You can perfectly well write a program that goes on after its output handle has been closed (but never does any more output).
14:13:14 <dmwit> You can also perfectly well write a program that stops as soon as its output handle has been closed.
14:13:18 <ketil> kolmodin, no, that's the answer to a different question :-)
14:14:30 <kolmodin> ketil: ah, you mean if there is an error in the source stream you are decoding?
14:14:43 <ketil> My problem was something like: data Foo = Foo Int; let x = decode undefined :: Foo; case x of Foo _ -> ---causes an exception.  But maybe this is a narrower case than I thought?
14:15:25 <ketil> Must look closer at it tomorrow...if you're interested, I'll mail you the results.  Now is bed time for me.
14:15:44 <joe1> @hoogle toString
14:15:46 <lambdabot> System.Time calendarTimeToString :: CalendarTime -> String
14:15:46 <lambdabot> System.Time timeDiffToString :: TimeDiff -> String
14:15:46 <lambdabot> Network.HTTP.Base uriAuthToString :: URIAuth -> String
14:15:58 <joe1> @hoogle InttoString
14:16:00 <lambdabot> No results found
14:16:03 <dschoepe> joe1: you want show
14:16:05 <dschoepe> @hoogle show
14:16:07 <lambdabot> Prelude show :: Show a => a -> String
14:16:07 <lambdabot> Text.Show show :: Show a => a -> String
14:16:07 <lambdabot> module Text.Show
14:16:20 <joe1> dschoepe: thanks
14:16:57 <kolmodin> ketil: yes, that code won't work. it needs at least one chunk of underlaying bytestring
14:17:17 <kolmodin> ketil: as the state of the Get Monad needs that, even if it's not used
14:17:36 <kolmodin> ketil: this behaviour is likely to change with binary 0.6
14:17:40 <ketil> kolmodin, somehow this forces the whole file for me.  I'll have to see what can be done about it.
14:19:04 <kolmodin> ketil: forces the whole file?
14:19:10 <ketil> kolmodin, I was considering bundling a lazy binary, or forking a binary-lazy.  Streaming is important, I have fair-sized files, and 0.5+ is about half the speed of 0.4, with excessive memory consumption.  But perhaps I can adjust my instances, or something.  Or perhaps 0.6 will fix it.
14:19:26 <ketil> kolmodin, fairly sure about that, yes.
14:19:53 <pumpkin> I'm working on a different binary
14:20:01 <pumpkin> but it likely will be quite different
14:20:08 <ketil> It's not a straightforward [a] instance, but some seeking, etc.
14:20:08 <kolmodin> ketil: you mean, you have a huge input stream (connected to a file) and even if you only want to consume part of this it will read the whole string from disk?
14:20:50 <ketil> Yes.  Basically it generates (data Foo = Foo header [record])
14:20:52 <kolmodin> ketil: seeking in binary?
14:21:09 <kolmodin> ketil: you can't skip to positions in the string without reading that data
14:21:32 <kolmodin> ketil: the operator 'skip' will actually read that data from disk and throw it away
14:22:03 <deggis> could someone give me pointers to (i guess classic) monad problem http://paste.ubuntu.com/517058/ ? thanks
14:22:28 <ketil> kolmodin, eh.  I'll have to check.
14:22:43 <kolmodin> ketil: ok
14:22:47 <zachk> mapM is prolly what you want 
14:23:18 <kolmodin> deggis: mapM, yes
14:23:58 <deggis> hmm, type looks good. i have only futile guesses of how implementation, but let's see
14:24:03 <kolmodin> deggis: map (\scene->packScene a scene) scenes   -- this is not monadic code, so you can't use it with   loadedScenes <- ...
14:24:25 <pumpkin> it is monadic, but in the list monad :P
14:24:33 <deggis> ah, ok
14:24:42 <dmwit> (\scene -> packScene a scene) can be written more simply as (packScene a). It won't fix your problem, but it's a nice thing to know.
14:24:47 <kolmodin> I'm trying to keep things simple :)
14:24:58 <wlangstroth> friends, Haskellers, countrymen ... how do we stop the bikeshedding on haskell-cafe?
14:25:03 <deggis> dmwit: true, thanks :)
14:25:19 <benmachine> wlangstroth: bikeshedding like all bureaucracy is indefatigable
14:25:20 <pumpkin> wlangstroth: ban everyone from it
14:25:34 <wlangstroth> fine, be that way!
14:25:40 <dmwit> deggis: Just to make sure, you're not intending to load a different texture for each scene, are you?
14:25:47 <cathper> byorgey: Was it http://portal.acm.org/citation.cfm?id=820168 you were referring to earlier?
14:25:53 <Nopik> hi all
14:25:53 <ketil> kolmodin, it's too late now, if you're interesting in helping out, I can get back to you tomorrow?  I'd really appreciate it if I could get rid of the version cap on binary, esp. now most distributions ship binary 0.5+
14:25:58 <benmachine> wlangstroth: it doesn't mean there's nothing to be done, I just don't think it helps to go "everyone stop talking!!"
14:26:08 <benmachine> wlangstroth: just try to make sure the things to talk about are interesting ones :P
14:26:08 <deggis> dmwit: yes, different for each scene
14:26:14 <EvanR-work> the hell is bikeshedding
14:26:32 <dmwit> deggis: Okay, then you'll need a bit more transformation than just using mapM.
14:27:04 <dmwit> deggis: I suggest as a first step you write a function that does everything for a single scene, loading its texture file and calling packScene and all.
14:27:17 <wlangstroth> EvanR: for complicated issues, no one has an opinion, when discussing the colour to paint the bike shed, everyone chimes in
14:27:24 <Nopik> i'm just finishing 'Real World Haskell', is there any other good book I should take on (i'm newbie)? maybe some publication showing interesting parts of the standard libaries?
14:27:43 <kolmodin> ketil: I will likely not be around very long tomorrow evening
14:27:51 <wlangstroth> thus "bikeshedding"
14:27:51 <wlangstroth> concrete example: the "skills list" on haskellers.com
14:28:02 <kolmodin> ketil: you can try. otherwise I'd suggest to try during the weekend
14:28:27 <pumpkin> wlangstroth: I wouldn't go that far
14:28:32 <deggis> dmwit: that sounds good. my previous attempt on that failed, but that is definetely what i want. hm, got an idea
14:28:32 <EvanR-work> lol
14:28:34 <pumpkin> lots of interesting questions get plenty of talk
14:28:44 <pumpkin> so do lots of completely inane ones, sadly
14:29:08 <wlangstroth> benmachine: haskell-cafe is usually so educational!
14:29:12 <deggis> dmwit: to make sure, the type signature of that function would be like :: Scene -> IO Scene?
14:29:17 <benmachine> wlangstroth: learn to skimread
14:29:49 <dmwit> deggis: Yes, something like that.
14:31:45 <ketil> kolmodin, I notice replicateM in the darcs comments...basically, I get the number of records from the header, and then do replicateM n get :: [Record].  Is this my culprit? 
14:32:52 <kolmodin> ketil: I think that should work fine
14:33:24 <zomg> Are there any resources I should see for functional/haskell programming idioms?
14:33:37 <zomg> I feel I'm approaching my coding in a very procedural fashion :)
14:34:01 <EvanR-work> spoon feeding instructions to the computer? ;)
14:34:08 <zomg> Yep
14:34:23 <EvanR-work> 10 print "hello world"
14:34:25 <EvanR-work> 20 goto 10
14:35:11 <EvanR-work> zomg: i dont know resources, but i do know reading and writing a lot of code will help
14:35:24 <c_wraith> EvanR-work, wouldn't that be easier to write as: forever (putStrLn "hello world")
14:35:29 <EvanR-work> and getting people in here to tear your pastebined code apart
14:35:54 <EvanR-work> c_wraith: how quaint
14:35:57 <zomg> Yeah perhaps I should look at the code of the libs I'm using or something
14:36:11 <EvanR-work> that code is not necessarily the most beautiful ;)
14:36:25 <deggis> dmwit: warm thanks to you. i've been trying to complete this for ~4-5 hours brute force :D went into 5 lines. ordinary story, i guess
14:37:12 <zomg> Maybe Sleep
14:50:12 <osaunders> "Polymorphic values are essentially functions on types" What does this mean?
14:50:29 <pumpkin> forall a. (a -> a)
14:50:37 <pumpkin> is a function that takes a type, and produces a function from that type to itself
14:50:40 <osaunders> Functions taking types as arguments?
14:50:58 <pumpkin> in ghc core, it's actually represented as a "big lambda"
14:51:03 <pumpkin>  /\
14:51:25 <pumpkin> then you can apply that big lambda to a specific type like Int
14:51:30 <pumpkin> and get Int -> Int
14:51:52 <osaunders> Like id?
14:51:59 <pumpkin> it's a bit like a pi type, but whose domain can only cover types
14:52:09 <osaunders> A pi type?
14:52:14 <pumpkin> let's see
14:52:27 <pumpkin> (a :: *) -> a -> a
14:52:28 <Saizan> in an explicitly typed lambda calculus you'd have "id = \ (a :: *) (x :: a) -> x"
14:53:52 <osaunders> : /
14:54:20 <osaunders> OK, dw, I think I'll come back to this later.
14:54:22 <pumpkin> osaunders: hmm, well, you have two different kinds of functions in haskell
14:54:49 <osaunders> pumpkin: OK, go on.
14:54:56 <pumpkin> one is introduced by a lambda and eliminated by applying the function (juxtaposition)
14:55:02 <pumpkin> that's a value-level function
14:55:13 <osaunders> OK.
14:55:32 <pumpkin> you also have type-level functions in the sense of polymorphism, where each forall is a parameter and every instantiation is an application (or in core, you have /\ and @)
14:55:44 <pumpkin> so forall a. a
14:55:51 <pumpkin> is actually a type-level function that can be applied to something like Int
14:55:56 <pumpkin> yielding Int
14:56:17 <osaunders> Oh!
14:56:20 <EvanR-work> :t 1
14:56:20 <pumpkin> forall a. [a] -> a
14:56:22 <osaunders> I understand that :-)
14:56:22 <lambdabot> forall t. (Num t) => t
14:56:27 <pumpkin> is a type-level function yielding a value-level function type
14:56:41 <pumpkin> so you can apply forall a. [a] -> a to Bool and get [Bool] -> Bool
14:57:03 <osaunders> Can you have type-level functions yielding type-level functions?
14:57:30 * osaunders hopes the answer is no.
14:58:23 <dmwit> In what language?
14:58:41 <dmwit> :k Monad m => m
14:58:42 <lambdabot>     `m' is not applied to enough type arguments
14:58:42 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
14:58:44 <pumpkin> osaunders: forall a. (forall b. a -> b)
14:58:52 <pumpkin> rank-n (2) types
14:59:13 <pumpkin> osaunders: or just forall a b. a -> b
14:59:29 <osaunders> Ah.
14:59:33 <osaunders> Currying.
15:00:09 <osaunders> TY pumpkin!
15:01:01 <dpratt71> so I've started to try to grok Arrows and I landed here: http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial 
15:01:05 <abstrakt> What's with the [(),(),(),(),()] at the end? Well, when we evaluate an I/O action in GHCI, it's performed and then its result is printed out, unless that result is (), in which case it's not printed out. That's why evaluating putStrLn "hehe" in GHCI just prints out hehe (because the contained result in putStrLn "hehe" is ()). But when we do getLine in GHCI, the result of that I/O action is printed out, because getLine has a type of IO String.
15:01:14 <abstrakt> > sequence (map print [1,2,3,4,5])
15:01:16 <lambdabot>   <IO [()]>
15:01:21 <pumpkin> abstrakt: use sequence_
15:01:27 <abstrakt> this is in reference to the above
15:01:34 <abstrakt> it's from the "Learn You A Haskell" tutorial
15:01:38 <aristid> the way haskell-indentation (in emacs) indents do blocks annoys me. is there a way to change that? :/
15:01:41 <abstrakt> that paragraph is not well formed
15:01:49 <abstrakt> aristid: sure... use vim :)
15:01:56 <aristid> abstrakt: very funny :P
15:02:03 <abstrakt> I know, I crack myself up sometimes
15:02:10 <abstrakt> but seriously... use vim :P
15:02:11 <dpratt71> at the moment I'm wishing to understand how the 'if' arrow notation maps to ArrowChoice
15:02:15 <dmwit> abstrakt: What's ill-formed about it?
15:02:24 <EvanR-work> emacs vs vim go
15:02:34 <abstrakt> dmwit: um... it doesn't make sense?
15:02:36 <dmwit> "follow your heart"
15:02:41 <dmwit> abstrakt: makes sense to me
15:02:48 <abstrakt> dmwit: yeah but you're not a haskell newb
15:02:49 <dmwit> abstrakt: Can you narrow down what's confusing you?
15:02:54 <abstrakt> yes I think so
15:03:29 <abstrakt> "Well, when we evaluate an I/O action in GHCI, it's performed and then its result is printed out, unless that result is (), in which case it's not printed out." in the example result output
15:03:43 <abstrakt> there's five numbers, 1-5, each on their own line, and then all the parentheses
15:03:43 <aristid> dpratt71: i would put off arrows until you cannot avoid it :D
15:03:56 <abstrakt> that sentence doesn't describe why those parentheses are there
15:04:11 <dpratt71> aristid: hmm
15:04:13 <dmwit> abstrakt: The action prints [1, 2, 3, 4, 5], then returns [(), (), (), (), ()].
15:04:22 <dpratt71> aristid: why do you say that?
15:04:26 <dmwit> abstrakt: Then, since the return value wasn't exactly (), it gets printed as well.
15:04:27 <abstrakt> dmwit: um, no it maps print to that array
15:04:38 <abstrakt> ahhh, ok that makes sense now
15:04:46 <aristid> dpratt71: because i think they are not nice at all, the way they currently are
15:04:48 <abstrakt> it maps to [print 1, print 2....
15:04:57 <dmwit> abstrakt: yep =)
15:05:20 <abstrakt> right, but each of those IO actions prints a result that is not ()
15:05:21 <dpratt71> aristid: interesting; do you think that is the general sentiment among Haskellers?
15:05:25 <abstrakt> ok, it does that 5 times, ok
15:05:34 <aristid> dpratt71: i cannot speak for all haskellers
15:05:35 <abstrakt> so why does it print out all those parens at the end though?
15:05:46 <dmwit> abstrakt: Yeah, "print" prints its argument, then returns ().
15:05:48 <aristid> dpratt71: but you can ask the channel if you want ;)
15:05:56 <dpratt71> aristid: of course; I was just wondering if that was your impression
15:06:24 <aristid> dpratt71: well some people have some complaints about arrows, so i'm not isolated in seeing imperfection there
15:06:26 <abstrakt> my impression is that (g)vim > emacs > *
15:06:32 <abstrakt> I hate vi though, fuck vi
15:06:32 <dpratt71> aristid: I'm interpreting the lack of reaction as non-disagreement
15:06:34 <dmwit> abstrakt: Since "sequence" returns the list of return values from the list of actions you give it, sequence [print 1, ..., print 5] prints 1-5, then returns [(), ..., ()].
15:06:46 <aristid> dpratt71: i would interpret it as typical IRC.
15:06:58 <abstrakt> dmwit: ahhh ok cool got it
15:07:02 <aristid> dpratt71: most of the time, most people do not read the activity in this channel :P
15:07:38 <abstrakt> I just saw the word emacs and started trolling
15:07:43 <abstrakt> I'll admit, I didn't really read
15:07:48 <dpratt71> aristid: I've notice that; not too surprising considering the # of people in the room
15:07:59 <dpratt71> *noticed*
15:08:42 <dpratt71> is there an FRP story without Arrows?
15:09:00 <aristid> dpratt71: right :) i think it's quite nice the way it is, otherwise it would be too chaotic, if everybody spake all the time ;)
15:09:15 <aristid> FRP without arrows? not sure, i'm not really into FRP
15:09:22 <Entroacceptor> aristid: dpratt71: like when I chime in?
15:09:32 <aristid> Entroacceptor: omg total chaos now
15:09:37 <Entroacceptor> aristid: dpratt71: sometimes I think that the google wave idea wasn't too bad after all
15:09:47 <aristid> Entroacceptor: that was total chaos too
15:09:55 <aristid> because nobody understood it
15:10:05 <cathper> aristid: Most of the time, people deliberately ignores statements involving editors :-)
15:10:09 <Entroacceptor> I'd like threads in irc or im conversations
15:10:10 <aristid> and discussions were hard to follow in wave
15:10:20 <aristid> cathper: that too.
15:10:33 <Entroacceptor> abstrakt: have you noticed that only vim people are that aggressive about telling people to use it?
15:10:45 <abstrakt> Entroacceptor: nope
15:10:53 <abstrakt> but that makes sense
15:10:57 <abstrakt> cuz vim is teh best
15:11:09 <aristid> Entroacceptor: that's not true, i sometimes like to annoy people that with emacs they wouldn't have problem X or Y
15:11:12 <abstrakt> Entroacceptor: the threaded IRC client has been tried
15:11:19 <abstrakt> not so easy
15:11:39 <dmwit> dpratt71: Hm, I think you could easily get away without using the Arrow instance for the most recent stuff from conal. "Push-Pull Functional Reactive Programming"
15:11:47 <Entroacceptor> aristid: but only sometimes, not for example now, that someone mentioned vi ;)
15:11:53 <dmwit> dpratt71: (At least, the little toy I wrote using it doesn't use any Arrow stuff.)
15:12:12 <aristid> Entroacceptor: only when i'm in the mood!
15:12:14 <abstrakt> Entroacceptor: btw, don't let anyone sucker you in to using vi
15:12:17 <Entroacceptor> abstrakt: yes, I don't know how to do that in a nice way, but it'd be cool to have
15:12:18 <abstrakt> vi sucks, I've already stated this
15:12:27 <adimit> Has darcs gotten even slower, or are the code.haskell.mirrors having trouble? Can't seem to grab code from there... :-(
15:12:29 <conal> dpratt71: the original frp story was without arrows.  it's applicative-centered.
15:12:38 <dpratt71> dmwit: I'll check it out, thanks; do you agree with aristid's sentiment (that arrows are not nice)?
15:12:46 <abstrakt> Entroacceptor: it would partially be dependent on other people on IRC following whatever conventions will lead to proper parsing of the threads
15:12:56 <abstrakt> most notably, using a threaded client, or always using nick hilite etc
15:12:57 <aristid> conal: but why have so many people moved to arrows? i like applicative
15:13:02 <dmwit> dpratt71: I dunno. I don't see anything wrong with them, though I haven't seen a really compelling use of them yet.
15:13:08 <abstrakt> I actually kind of prefer that IRC is non threaded
15:13:30 <conal> aristid: a few different reasons.  including some subtle ones.
15:13:40 <abstrakt> and then you have the problem of what happens when threads start crossing each other
15:13:50 <Entroacceptor> abstrakt: yes, sure
15:13:51 <abstrakt> and also when you get a large number of threads concurrently
15:13:59 <abstrakt> screen real estate begins to be a problem
15:14:11 <aristid> conal: is there an important one that is easy to explain?
15:14:16 * shapr hugs conal
15:14:31 <dpratt71> can someone explain (or point me in the right direction) how 'if' (in the context of arrow notation) maps to ArrowChoice?
15:14:32 <aristid> shapr: hey, warn people before attacking them with hugs
15:14:33 * conal likes hugs
15:14:47 <EvanR-work> get a room guys
15:14:48 <conal> aristid: the biggest reason for me is that the semantic model in afrp suits interactive behaviors, while the semantic model in frp suits noninteractive behaviors
15:14:55 * conal hugs shapr
15:15:08 <dmwit> ?src ArrowChoice
15:15:08 <lambdabot> Source not found. Just try something else.
15:15:08 <aristid> conal: afrp standing for arrow-frp?
15:15:15 <conal> aristid: yeah
15:15:21 <aristid> conal: what about monad frp?
15:15:50 <dmwit> dpratt71: Presumably, rather than using True and False, you use Left a and Right b, treating Either as a "tagged" boolean.
15:16:01 <dmwit> Let's see if there's something more formal easily available...
15:16:09 <conal> aristid: i don't really like those names.  frp is not about arrow or applicative or monad.  it's about its semantics.
15:16:38 <conal> aristid: the same reason i don't like the term "monadic IO".  IO is not about monad, an monad is not about IO.  the conflation confuses people.
15:17:13 <conal> aristid: i'm guessing there might be a clear question in there somewhere, though (behind "monadic frp").  maybe you can tease it out.
15:17:16 <aristid> conal: monads are an API, and that API affects how you have to structure code
15:17:43 <pumpkin> I hate using "The X Monad" unless you're actually talking about the monadic interface of X
15:17:44 <aristid> conal: oh, i lack the understanding to tease out a clear question
15:17:47 * shapr hugs aristid 
15:17:55 <EvanR-work> but it is monadic IO
15:17:55 <pumpkin> people say "The Maybe Monad" or "The IO Monad" all the time
15:17:58 <aristid> shapr: :D
15:17:59 <pumpkin> really annoys me :P
15:18:01 <conal> aristid: we #haskell'ers could help
15:18:14 * shapr hugs pumpkin 
15:18:17 * dmwit hugs shapr
15:18:23 <dmwit> Surprise! it's backwards
15:18:23 * shapr hugs dmwit
15:18:28 <shapr> dmwit: Dude, I haven't seen you in years!
15:18:30 <Entroacceptor> (I still like the names Haskelletons)
15:18:41 <shapr> Entroacceptor: Ooh, me too!
15:18:57 <conal> pumpkin: annoys me to.  i'd mind less if they also also say the Maybe/List/IO "functor" or "applicative" or "monoid"
15:19:25 <dmwit> dpratt71: Page 11 of [Pat01] seems to cover it.
15:19:25 <EvanR-work> they have standard instances?
15:19:45 <dmwit> (section 6.3, Conditionals)
15:19:58 <conal> pumpkin: i suspect part of the reason for "Monad" in "the Foo Monad" is simply avoiding saying something like "higher-kinded type"
15:20:01 <dpratt71> dmwit: looking, thanks
15:20:06 <pumpkin> conal: yeah :/
15:20:26 <dmwit> I don't think that's all of it, though.
15:20:29 <conal> pumpkin: or simply "type", since there are inconsistent common uses of "type".  
15:20:31 <sproingie> Foo Functors would make a cool geekcore band name
15:20:37 <dmwit> I usually say "the Maybe monad" when I'm intending to use its monadic instance.
15:20:42 <dmwit> Otherwise I don't say that.
15:20:44 <conal> sproingie: it totally would!
15:20:52 <pumpkin> everfmap by the Foo Functors?
15:21:10 <pumpkin> that's a bit of a stretch
15:21:17 <dmwit> I think it's fair to talk about "the X monad" if you're going to write some code that depends on X actually being a monad.
15:21:40 <conal> especially for "IO" I'd like everyone to stop saying "the IO monad".  we're confusing people faster than we can straighten them out.
15:22:06 <aristid> dmwit: which is probably usually the case, sequencing is an oft-needed operation :)
15:22:35 <roconnor> conal: really?
15:22:45 <conal> roconnor: definitely
15:22:49 <roconnor> ;(
15:22:55 <wlangstroth> and just saying "IO" is somehow bad?
15:22:58 * roconnor nixes talking about the list monoid
15:23:01 <wlangstroth> It's shorter
15:23:11 <deggis> somewhat gpipe spesific (if gpipe people happen to be around): can Texture2D dimensions be extracted from the texture object?
15:23:18 <conal> wlangstroth: yeah.
15:23:34 <roconnor> conal: what if I want to talk about it in the context of using do notation?
15:23:50 <conal> wlangstroth: the extra baggage ("the" and "monad") adds to the harmful mystique
15:24:03 <roconnor> conal: like for non-determinism I might say "use the list monad"
15:24:24 <roconnor> or dons might say "the list monad strikes again"
15:24:34 <conal> roconnor: doesn't matter.  when referring to the (higher kinded) type, you can say "IO", whatever kind of notation you use.
15:24:35 <EvanR-work> avoid mystique at all cost
15:24:44 <EvanR-work> i.e. dont
15:24:47 <EvanR-work> because its awesome
15:25:15 <conal> EvanR-work: yeah.  sometimes it's fun to deliberate obfuscate.
15:25:17 <wlangstroth> conal: I'm one of the people it threw off (that is, it confused the issue of instances for me)
15:25:38 <dmwit> http://s133702574.onlinehome.us/pictures/blog/mystique.jpg
15:25:43 <roconnor> But when refering to non-determinism the monad concept is important, as opposed to the monoid concept or anything else you might do with lists.
15:25:49 <conal> dmwit: yow!
15:26:07 <dmwit> =D
15:26:13 <roconnor> (or list comonad)
15:26:19 <aristid> conal: i think i can express my "monad frp" question better now
15:26:25 <wlangstroth> (not permanently, mind, you, but still)
15:26:37 <roconnor> conal: I remain unconvinced
15:26:43 <wlangstroth> (mind you)
15:26:45 <conal> roconnor: maybe you're saying that you want a name for subsets of functionality on certain types.
15:27:06 <conal> roconnor: and sometimes common classes exactly correspond to those subsets.
15:27:12 <roconnor> conal: ya, like the collection of IO and bind and return
15:27:20 <roconnor> conal: and their derived functions
15:27:24 <roconnor> I call it "the IO monad"
15:27:39 <conal> roconnor: that's almost none of the IO interface.
15:27:52 <conal> roconnor: and yet people use "the IO monad" to refer to the entire type.
15:27:56 <Philippa_> yet at the same time it's a critical part of it
15:28:14 <aristid> conal: i dislike the current Arrow API. i also found out that in many cases, you can perfectly well use an API based on Monads instead of one based on Arrows. so i was wondering if it would be possible or reasonable to create a FRP library using the Monad API instead of the Arrow API
15:28:15 <roconnor> well the ReadMonad also includes ask 
15:28:18 <conal> Philippa_: yes.  just as 0 is a critical part of the Integer type.
15:28:27 <aristid> conal: i hope that is better?
15:28:28 <roconnor> maybe the IO Monad includes primite IO operations
15:28:41 * dmwit adds "The IO Tutorial For People Who Don't Want to Mess About With That Monad Nonsense" to his TODO file
15:28:56 <Philippa_> more like how it being an instance of various algebraic structures is a critical part of it. It's more than 0 alone
15:28:56 <conal> roconnor: now you're changing the def.  "Monad" doesn't include any of those ops.
15:29:08 <ezyang> dmwit: I think it's been done, iirc. 
15:29:08 <roconnor> conal: indeed.
15:29:19 <roconnor> conal: I'm just trying to figure out what i mean by IO-Monad
15:29:29 <conal> roconnor: in which case, "Monad" isn't a descriptive term.
15:29:34 <Philippa_> well, there is /something/ going on here: we use monads to do something fairly specific in haskell, and that something fairly specific is about languages and embedding
15:29:35 <roconnor> conal: and I"m pretty sure I mean more than just the IO type constructor
15:29:38 <dmwit> ?google sigfpe monad tutorial for people who just don't care
15:29:40 <lambdabot> http://blog.sigfpe.com/2010/03/partial-ordering-of-some-category.html
15:29:40 <lambdabot> Title: A Neighborhood of Infinity: A Partial Ordering of some Category Theory applied t ...
15:29:45 <Philippa_> so "monad" becomes a description of a class of embedded language
15:29:54 <roconnor> conal: I'm willing to add a hyphen if it makes you feel better
15:30:04 <conal> roconnor: ??
15:30:09 <roconnor> IO-Monad
15:30:10 <dmwit> ezyang: Note that it's still called "The IO Monad for ..."
15:30:12 <roconnor> Reader-Monad
15:30:15 <roconnor> Writer-Monad
15:30:21 <Philippa_> and the thing is, we don't /have/ a good term for that, not least because people get all kinds of insistant about leaving multiple interpretations open
15:30:27 <roconnor> List-Monad
15:30:30 <dmwit> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
15:30:30 <Philippa_> (but it's a container!)
15:30:32 <conal> aristid: now i understand what you're asking.  you can design a frp library with applicative as the central organizing class.
15:30:52 <conal> aristid: and even monad, though i don't think it's been done.
15:30:56 <adimit> Guys, does code.haskell.org have any mirrors? I need access to hexpat's source code, and the host seems to be down.
15:31:09 <conal> aristid: http://conal.net/papers/push-pull-frp/
15:31:17 <aristid> conal: do you think that would be something that's interesting to experiment with?
15:31:17 <c_wraith> adimit, you could cabal unpack it
15:31:30 <adimit> c_wraith: sounds like a plan. thanks.
15:31:54 <danharaj> conal: does that get you equivalent expressiveness? There are some libraries that when converted from monad to applicative lose something. Like Parsec.
15:31:59 <conal> aristid: maybe. you could use the original fran/frp and the newer reactive as inspiration.
15:32:03 * Philippa_ incidentally finds that attempts to remove an avenue of communication without offering a suitable alternative are... dangerous. Check what people're actually saying with something before telling them not to say it
15:32:33 <Philippa_> danharaj: losing join is guaranteed to lose you expressiveness, the question is whether you care about it in your use cases
15:32:53 <conal> roconnor: i don't get the significance of hypen vs no-hyphen here.
15:33:03 <aristid> Philippa_: i agree with your sentiment on communication :)
15:33:13 <roconnor> [18:29] <conal> roconnor: in which case, "Monad" isn't a descriptive term.
15:33:26 <roconnor> I think I was missunderderstanding you here
15:33:31 <conal> ah
15:34:17 <Philippa_> it also very much /is/ descriptive as compared to, for example, "the Reader applicative"
15:34:45 <Philippa_> especially if you have a ReaderA that's applicative but not monadic
15:34:50 <conal> i've noticed how some people like unanswered questions as spaces for creative thinking, while others object to them.  i guess it's a personal preference thing.
15:35:04 <roconnor> I thought you wanted me to distinugh between the IO Monad  as (IO,bind,return) vs IO-Monad (IO,bind,return, other primitive ops)
15:35:13 <Philippa_> it's also a "do you sound like you're asking rhetorical questions?" thing
15:35:48 <danharaj> isn't IO with just (IO, bind, return) indistinguishable from the trivial monad?
15:35:53 <Philippa_> to people who read the questions as closer to rhetorical, you seem to be engaging in a very different piece of discourse
15:36:24 <danharaj> (except you can't get out of it)
15:36:27 <Philippa_> danharaj: it's distinguishable by type and ability to actually read the result, for one
15:37:21 <Philippa_> there's also the issue that questions frame discussion: they put an onus somewhere, and not everyone will be comfortable with where it's ending up
15:37:30 <wlangstroth> I thought it was "monadic IO" and "applicative Reader". No?
15:37:43 <roconnor> conal: I think I don't understand the confusion we are trying to clear up
15:38:02 <Philippa_> wlangstroth: I'd take "monadic IO" to mean something more general than Haskell's IO monad
15:38:35 <aristid> Philippa_: like the MonadIO class?
15:38:40 <Philippa_> roconnor: "monad is the monad signature and no more, what's all this other stuff you're bundling up with specific monads?"
15:38:48 <roconnor> danharaj: it's like the Ring Z2
15:38:55 <Philippa_> aristid: like the implementation of monadic IO in the toy language I built a few years back, for example
15:39:32 <aristid> Philippa_: well in haskell you will always go down to IO at some point, unless you write your own runtime :)
15:39:38 <roconnor> Philippa_: just extentions.  Like how a Ring is more than a group
15:39:48 <roconnor> or better
15:39:53 <Philippa_> roconnor: well quite, I'm comfortable with that usage myself
15:40:00 <roconnor> like how a normed ring is more than a ring
15:40:15 <conal> roconnor: i keep seeing people say "monad" or "monadic" when they just mean IO. the Monad idea and the IO idea are both useful ideas. by separating them more, i expect people will understand each better and see how to use each without the other.
15:40:39 <Philippa_> conal: which IO idea? There are several things you could label that way
15:40:56 <roconnor> conal: and you think people talking about the IO monad makes people think that monad is short for IO?
15:41:30 <pumpkin> roconnor: or if not that, that an understanding of "monad" is crucial to use IO in haskell
15:41:31 <roconnor> conal:  and did you just write a little mini pi in your sentence?
15:41:33 <Philippa_> and the signature-for-IO-in-haskell is a subtype of that for IO : IO-is-a-monad, as the OO folks would put it
15:41:35 <aristid> people will find creative ways to mistake one thing for the other, no matter how much you regulate your language :D
15:41:35 <pumpkin> which is really annoying
15:42:00 <jmcarthur> screw IO. i use the IO monadplus
15:42:01 <wlangstroth> Philippa_: true, it would be
15:42:06 <jmcarthur> it's better than the IO monad
15:42:13 <roconnor> Philippa_: you lost me with that last statment :)
15:42:23 <conal> roconnor: i'll collect some example and show you.  and i'll write a blog post about this issue sometime.  will make it easier for me to point it out when it crops up.
15:42:45 <jmcarthur> the IO num is pretty cool too
15:42:46 <aristid> pumpkin: well there is something else that is crucial to understanding IO in haskell. and i guess those things are getting confused
15:42:52 <Philippa_> roconnor: treat the IO type constructor and all the relevant operations as whatever generalisation of an algebra you need. Relate that to the corresponding one for a Monad
15:42:56 <conal> aristid: they sure will. this "IO monad" thing is one that i see especially often with haskell.
15:43:04 <roconnor> jmcarthur: isn't that just fmap of num functions?
15:43:17 <roconnor> jmcarthur: presumalby you mean IO Int num
15:43:18 <jmcarthur> roconnor: well, and liftA2
15:43:19 <roconnor> :P
15:43:33 <jmcarthur> roconnor: regardless, i think i've made my view on the issue clear
15:43:42 <jmcarthur> by example
15:43:55 <roconnor> Philippa_: yes.
15:44:01 <conal> there's a systemmatic Num for all Applicative
15:44:06 <conal> systematic
15:44:14 <jmcarthur> well, there would be if not for the Eq and Show constraints
15:44:19 <Philippa_> FWIW, I consider understanding the implications of IO's monadic structure in haskell pretty important to understanding how to use IO. Whether you have the generalisation in mind when you do it's less relevant
15:44:37 <conal> jmcarthur: right.  modulo questionable choices in the class hiearchy.
15:44:46 <Philippa_> but most of the "how do I use IO?" questions we get really are about how to use that bit of structure effectively and what it does and doesn't let you do
15:44:48 <jmcarthur> they make me sad
15:44:58 <roconnor> Philippa_: extremely important.  Even intermedate haskell programmers misunderstand how strictness and IO relate.
15:45:16 <jmcarthur> they relate at all?
15:45:29 <Philippa_> roconnor: it doesn't help that every time someone does bash out a sensible definition of "strict monad" it happens on IRC and promptly gets forgotten :-)
15:45:29 <roconnor> jmcarthur: yes, the IO monad is lazy
15:45:52 <roconnor> (I said IO moand because I"m talking about bind being lazy)
15:46:08 <jmcarthur> it better be lazy
15:46:21 <jmcarthur> otherwise the forever function would suck
15:46:30 <Philippa_> it's more than that though: it's also lazy when viewed at the level of the IO embedded language
15:46:32 <sproingie> @src forever
15:46:43 <roconnor> Philippa_: Actually I'm hoping popularizing the Free FFI Monad model of IO will clairify things and demystify IO.
15:46:56 <sproingie> i see lambdabot is up to its usual level of stability
15:47:05 <roconnor> a Free Monad is typically lazy
15:47:13 <Philippa_> roconnor: the "treat it as a simple language fed into an interpreter" one?
15:47:15 <sipa_> what's a Free monad?
15:47:15 <c_wraith> yet, (>>=) in IO is strict in its first argument.
15:47:15 <roconnor> especially if you want infinite terms.
15:47:18 <Saizan> and IO's (>>=) is also strict on its first argument, so it's so ambiguous when you say IO monad is lazy :)
15:47:42 <conal> roconnor: are you shooting for full abstraction in your model?  generally a desirable property of models.
15:47:59 <roconnor> Philippa_: I sort of.  But the simple language doesn't have loops. and the terms are typically infinite.
15:48:03 <conal> roconnor: puts a model near the semantics end of the syntax/semantics spectrum.
15:48:07 <roconnor> Philippa_: so it is an unusual language
15:48:10 <dab_> anyone know why this xmobarrc wont work? http://pastebin.com/rHHgiq0J
15:48:13 <jmcarthur> conal: i think it's more of a metaphor. metaphors aren't meant to be stretched too far ;)
15:48:34 <Philippa_> roconnor: well, they're finite, very very short and include the means to generate more via a function, but same difference :-)
15:48:39 <roconnor> conal: I'm mainly after something better than State RealWorld
15:48:42 <conal> jmcarthur: oh, a metaphor? i wonder for what purpose.
15:48:49 <jmcarthur> conal: me too
15:48:53 <roconnor> Philippa_: what is finite?
15:49:01 <conal> roconnor: better in what ways?  what would it do better?
15:49:11 <jmcarthur> i'm not sure what additional clarity it affords
15:49:30 <conal> jmcarthur: yeah.  that's what i'm wondering as well.
15:49:35 <Philippa_> roconnor: the size of the 'program' - I'm nitpicking about the presence of the (a -> m b) in >>='s type
15:49:36 <roconnor> conal: well it is clearly lazy.
15:49:50 <roconnor> conal: clearly seperates evaluation from execution
15:50:02 <Philippa_> here we go again: "how do you define strict/non-strict monad?"
15:50:21 <roconnor> Philippa_: I don't really want to get into that
15:50:31 <Philippa_> yeah, but I bet conal does :-)
15:51:03 <roconnor> Just want to note that return undefined doesn't evaluate undefined when that term is put into WHNF.
15:51:37 <jmcarthur> > (return undefined :: IO Int) `seq` "foo"
15:51:41 <roconnor> State RealWorld is just non-semantics
15:51:47 <jmcarthur> oh lambdabot is down
15:52:00 <Philippa_> yeah, it's more the behaviour of (return undefined >>= \_ -> putStrLn "Hello world!") that matters
15:52:03 <conal> roconnor: non-semantics?
15:52:20 <roconnor> no one ways what the values of RealWorld are
15:52:33 <roconnor> how am I to know if two functions RealWorld -> (a,RealWorld) are the same or not
15:52:35 <conal> roconnor: right.  and that's not the only problem.
15:52:56 <roconnor> the Free Monad tells your (or at least gives you a lower approximation)
15:53:27 <Philippa_> roconnor: yeah, the monadic bit has semantics, it's the what it does when it hits the rest of your system that's unspecified
15:54:27 <conal> roconnor: so the RealWorld myth doesn't define equality.  and the Free model does, but not consistently with intended uses of IO (imperative programming).  right?
15:54:46 <jmcarthur> IO is a wibble that seems to do what we want :)
15:54:54 <Philippa_> oh, it's precisely consistent with imperative programming: it's enough to be able to look at it and say "yep, looks imperative to me"
15:55:20 <Philippa_> (and probably to do so a little more formally given a suitable formal definition of what imperative looks like)
15:55:37 <conal> roconnor: if you see what i mean
15:55:57 <Philippa_> what the Free model doesn't do is tell you what print means
15:56:24 <Philippa_> it's not enough to tell you that launchMissiles is likely to lead to program termination, for example!
15:56:35 <conal> roconnor: in that lots of would-be equivalent imperative programs model as inequivalent.
15:57:04 <conal> roconnor: (failure of full abstraction)
15:57:44 <Philippa_> it's more a case of it actively taking a punt on that: you want that, provide a model for the individual effecting operations
16:00:40 <Philippa_> but it doesn't claim to speak of it either. If you wanted a version that did, you'd parameterise it in a manner akin to HM(X)'s parameterisation on a constraint domain
16:01:32 <Philippa_> in the meantime, it's one generalisation short of telling you precisely where the boundaries between the monadic&imperative structure and the specific things you can tell the system to do are
16:02:33 <Philippa_> this may strike you as useless to you :-) But it's enough to let someone who's comfortable-enough with imperative programming elsewhere become comfortable-enough with doing it in Haskell - it's the bridge they need for now
16:07:43 * roconnor back
16:08:15 <roconnor> Philippa_, conal, the result is whatever the runtime system does with it.
16:08:38 <Saizan> hey, at least in the Free model you can tell "forever (putStrLn "foo")" and "\ _ -> undefined" apart
16:08:48 <roconnor> same "same" haskell progam could do lots of different things with diffrerent runtime environments
16:08:56 <roconnor> er
16:09:01 <roconnor> *the same haskell...
16:09:32 <Philippa_> roconnor: exactly, the parameterisation I was suggesting is basically one on RTS or an abstraction thereof
16:09:38 <roconnor> Saizan: \_ -> undefined doesn't seem to have the right type. ...
16:10:18 <mreh> > maxBound - minBound :: Double
16:10:20 <conal> roconnor: couldn't you say the same about RealWorld?
16:10:21 <roconnor> Philippa_: when did you suggest this?  I think I missed it
16:10:25 <mreh> @bot
16:10:35 <roconnor> conal: I have no idea what RealWorld is.  
16:10:55 <conal> roconnor: ditto for the primops in your model, right?
16:11:06 <Saizan> roconnor: it does with IO a = World -> (a,World)
16:11:53 <Saizan> Philippa_: btw, seen eff?
16:11:57 <conal> roconnor: if you don't define anything about the primops, then can one reason non-trivially about imperative programs? maybe you don't care. by "nontrivial", i mean beyond functor & monad laws.
16:12:00 <roconnor> conal: well, the Free Monad has constructors.  The primitive operations build little IO Trees with these constructors
16:12:21 <Philippa_> Saizan: briefly. Only in enough detail for it to look like a "haskell wannabe python", and I know that's not enough detail
16:12:39 <roconnor> conal: given that the run time system could do anything, I don't think there is any reasoning you can do.
16:12:40 <Funktorsalat> you could factor the free model by some axioms, just like in algebra
16:12:50 <sipa> is there some standard function cutAt or something such that cutAt 3 [1,2,3,4,5,6,7,8,9] results in [[1,2,3],[4,5,6],[7,8,9]] ?
16:13:10 <conal> roconnor: that's the given i'm questioning.
16:13:18 <Funktorsalat> (e.g. free group = free structure with a binary and a unary and a nullary operation, factored by zeh group axioms)
16:13:44 <Funktorsalat> so maybe you could factor the free model by, say, some axiom relating writeIORef and readIORef
16:13:46 <roconnor> conal: Ah, well actually I should correct myself here.  I think of the IO monad as more than a free monad. The free monad is just for the "mysterious bits"
16:14:25 <roconnor> conal: for IORef and such you probably want to model IO as STT (Free-FFI-Monad)
16:14:25 <Philippa_> Funktorsalat: already suggested it can be done, already pointed out that that's also not the direct objective of what roconnor's talking about
16:14:35 <roconnor> where STT is a model of the ST transformer
16:14:47 <conal> roconnor: please keep doing what you're doing. i'll see how it turns out and what you end up saying it's for.
16:15:05 <roconnor> conal: and for modeling nondeterminism you will need to add more structure that I don't quite know how to do.
16:15:25 <roconnor> conal: but Neither concurrency nor do I think IORef is part of Haskell 98
16:15:45 <Philippa_> conal: mostly, it's for teaching people who aren't actually going to be comfortable using the monad laws directly how things behave, thus far. Multiple people've come up with this interpretation and used it for that purpose
16:16:06 <conal> roconnor: oh! then the World model isn't as bad.
16:16:23 <roconnor> conal: eh?
16:16:25 <cathper> byorgey: It seems that "(binomial' (n-1) (k-1)) * n' `div` k'" is slower but uses less memory than the original "(product [n'-k'+1 .. n']) `div` (product [1..k'])".
16:16:26 <Funktorsalat> "<roconnor> conal: given that the run time system could do anything, I don't think there is any reasoning you can do." <-- probabilistic semantics? :D
16:17:25 <Saizan> conal: as i hinted above the world model has an unsound equality, assuming we use extensional equality for functions
16:17:55 <conal> roconnor: the popular-but-bogus RealWord model of IO cannot handle concurrency.  it's a model of purely sequential sequential imperative programming. if you don't care about concurrency, then one big drawback goes away.
16:18:18 <Saizan> it can't even handle sequential imperative programming :)
16:18:22 <conal> Saizan: ooh. i missed that bit.
16:18:25 <roconnor> Saizan: ah does forever (printLn "foo") and \_ -> undefined appear to be the same semantically in World -> (a,World) ?
16:18:50 <roconnor> Saizan: it does look that way doens't it...
16:18:52 <Saizan> roconnor: forever is a never ending loop in that model
16:19:20 <Saizan> so when you apply those you'll get _|_ from both
16:19:25 <roconnor> Saizan: I should use this example to bash the State RealWorld model
16:19:48 <Funktorsalat> hmm is forever really such a loop?
16:19:54 <Saizan> roconnor: it's in Simon Marlow's tackling the awkward squad
16:19:56 <roconnor> @src forever
16:20:11 <Saizan> forever a = a >> forever a
16:20:15 <roconnor> Saizan: oh, it's been years since I've read that.  I should reread it with my new understanding of IO
16:20:16 <Funktorsalat> simplifying, it has type (World -> World) -> (World -> World)
16:20:57 <Funktorsalat> Saizan: hmm and (>>)'s semantics is determined?
16:21:07 <Funktorsalat> oh right, inherited from state monad
16:21:14 <Funktorsalat> in that case I agree..
16:22:21 <roconnor> [19:15] <Philippa_> conal: mostly, it's for teaching people who aren't actually going to be comfortable using the monad laws directly how things behave, thus far. Multiple people've come up with this interpretation and used it for that purpose
16:22:25 <Funktorsalat> Saizan: hmm that seems like a rather severe flaw
16:22:31 <roconnor> Philippa_: ^^ what was your statment in reply to?
16:22:44 <Funktorsalat> maybe explicit time would help salvage it
16:22:54 <Philippa_> <conal> roconnor: please keep doing what you're doing. i'll see how it turns out and what you end up saying it's for.
16:23:04 <Philippa_> the "thus far" bit is important :-)
16:23:13 <Philippa_> but it's a role it's /good/ at
16:23:18 <ddarius> It's easy enough to model a cooperative concurrency system.
16:23:57 <roconnor> ddarius: does it involve M-sets?
16:24:48 <roconnor> Philippa_: is it possible for you to repeat what you were trying to say there in different words?  I'm having diffuculty understanding it.
16:24:54 <conal> Saizan: thanks for that reminder.
16:25:05 <roconnor> Philippa_: maybe expanding out some of the pronouns :)
16:25:18 <ddarius> roconnor: I'm sure you could figure M-sets into it if you wanted to, but the way Li Peng did it for the first part of his paper should fit in relatively well with what you have.
16:25:37 <roconnor> ddarius: link?
16:25:39 <ddarius> Or Koen Claessen's "poor man's" concurrency monad should also fit fine.
16:25:54 <roconnor> someone needs to blog about these models
16:26:05 <roconnor> Saizan: EFF seems kinda interesting.
16:26:23 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.124.2927 http://www.google.com/url?sa=t&source=web&cd=1&ved=0CBMQFjAA&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.39.8039&rct=j&q=Poor%20man%27s%20concurrency%20monad&ei=gHq_TL66N4vrOeqSwQ0&usg=AFQjCNFwZj8U_5uE_GohNVTgDiLC09fmnA&cad=rja
16:26:29 <ddarius> Freakin' google.
16:26:30 <conal> Saizan: i wonder whether the World -> (a,World) model really cannot handle forever/print
16:26:37 * roconnor doesn't actually remember what M-sets are
16:26:42 <Philippa_> roconnor: "it" is the free FFI monad model. The free FFI monad is thus far good for teaching people how monads/IO behave when they're not comfortable just looking at the monad laws. It makes a reasonable grounding intuition, if you like. Several people've come up with it and used it that way
16:26:46 <Zao> ddarius: I hate those stealth ad forwarding ones.
16:27:20 <joe1> is there something similar to removeFile that checks if the file exists and deletes only if it exists?
16:27:23 <conal> Saizan: that model can express the desired semantics, can't it?
16:27:30 <joe1> @hoogle removeFile
16:27:30 <roconnor> Philippa_: you can understand IO just by looking at the monad laws?
16:27:40 <benmachine> joe1: well, removeFile doesn't delete the file if it doesn't exist >_>
16:27:40 <joe1> > @hoogle removeFile
16:27:49 <ddarius> roconnor: M-sets are sets with a monoid action on them, which (in one perspective) is just a monoid homomorphism M -> (X -> X) where X is the underlying set of the M-set.
16:27:53 <joe1> yes, but it seems to error out.
16:28:07 <benmachine> joe1: the syntax was right the first time, but lambdabot's not paying attention I suppose
16:28:12 <ddarius> @botsnack
16:28:16 <benmachine> joe1: oh, then just catch the error, seems easiest
16:28:24 <Philippa_> conal: I suspect it can handle it fine in a setting like Agda and with a little care in how you build your World type
16:28:26 <ddarius> lambdabot isn't even here.
16:28:46 <joe1> benmachine: this is what I have  mapM_ removeFile ["BD0STAT.dat","BD0CNT.dat","BD0BUFFER0.dat","BD0BUFFER1.dat", "BD0BUFFER2.dat", "BD0BUFFER3.dat", "BD0BUFFER4.dat"
16:28:50 <joe1> benmachine: this is what I have  mapM_ removeFile ["BD0STAT.dat","BD0CNT.dat","BD0BUFFER0.dat","BD0BUFFER1.dat", "BD0BUFFER2.dat", "BD0BUFFER3.dat", "BD0BUFFER4.dat"]
16:29:07 <joe1> and removeFile gets out at the first non-existing file.
16:29:34 <joe1> @hoogle removeFile
16:29:37 <Philippa_> roconnor: you can get all the things you need to reason with. Of course, that tells you a fairly limited amount about how it'll actually behave, but in theory the only difference is having an explicit notion of the RTS / there being some interpreting context
16:29:41 <roconnor> joe1: you will need to do mapM_ (myRemoveFileWithExceptionHandler) ...
16:29:55 <joe1> roconnor: ok thanks.
16:29:55 <ddarius> joe1: lambdabot isn't going to start responding if she's not here.
16:30:14 <Philippa_> roconnor: if you can find a useful refinement - some constraints on how the RTS is allowed to behave - that changes things
16:30:28 <krey_> hello, this might be a stupid question, but is it possible to write a function in haskell that lists give a list of all subsets (as lists) of rationals?
16:30:54 <roconnor> krey_: all finite lists?
16:31:14 <benmachine> joe1: maybeRemove fp = catchJust (guard . isDoesNotExistError) (removeFile fp) return
16:31:39 <roconnor> krey_: for any list (even infinite) you can make a list of all finite subsets of that infinite list
16:31:39 <krey_> roconnor: thank you, you've answered my question :)
16:31:53 <Saizan> conal: if you don't give some structure to World it can't express much, also it's a bit annoying that we're meant to care only about to which input is sent to which output for a function, but for IO we're really interested in the intermediate World's too
16:31:56 <benmachine> joe1: catchJust is from Control.Exception, guard is from Control.Monad, isDoesNotExistError is from System.IO
16:32:01 <joe1> benmachine: thanks a lot.
16:32:09 <krey_> roconnor: I'm just really tired and forgot about infinite subsets
16:32:23 <benmachine> joe1: it might be better, actually to do something like
16:32:44 <Philippa_> yeah, the World model is /just/ useful enough to let you think about linear/uniqueness typing and otherwise pretty useless
16:33:28 <Philippa_> I mean, it's cute if you need to argue a certain point of view regarding purity of functional programming, and I think it'll still have that utility with something like FRP too, but still
16:33:51 <benmachine> joe1: maybeRemove fp = catchJust (\x -> if isDoesNotExistError x then Just x else Nothing) (removeFile fp) print
16:34:01 <Saizan> conal: that can be solved by keeping a trace of the events inside World, i guess
16:34:04 <ddarius> I think it is a horrible way to argue for purity of functional programming.
16:35:03 <joe1> benmachine: where is the isDoesNotExistError ? i cannot find it.
16:35:15 <benmachine> joe1: System.IO.Error, sorry
16:35:48 <joe1> thanks.
16:35:53 <Saizan> yep, the free monad is much better to argue for purity :)
16:35:54 <Philippa> *sigh*. Did that get through?
16:35:58 <roconnor> Philippa_: Oh I see. Ya, if you treat PutChar as some unknown function, you pretty much can only do the same reasoning as the Free Monad model.
16:36:00 <benmachine> joe1: hmm I can make that simpler actually
16:36:00 <conal> Saizan: maybe even more elegantly.  we could play with it.
16:36:32 <benmachine> joe1: ignore Control.Exception, use 'try' from System.IO.Error, you should find it easier to understand
16:36:43 <Philippa> Saizan: "but it doesn't do anything!" :-) It's just a STFU line for a certain class of borderline troll
16:36:54 <roconnor> Philippa: what implementation of World are you imagining in Agda?  I can't imagine anything that would make forever (print foo) work.
16:37:16 <joe1> benmachine: thanks
16:37:33 <Philippa> roconnor: one based around the Tomorrow functor
16:37:57 <roconnor> Philippa: what is the Tomorrow functor?
16:38:21 <Philippa> roughly speaking, it's what happens if you take an arbitrary general computation and make you feed it clocks to get it to do its work :-)
16:38:54 <Philippa> (it's codata, of course)
16:39:22 <roconnor> As Saizan noted, the State monad hides the intermediate worlds which are impotant for understand the denotation of forever (print foo)
16:39:37 <joe1> benmachine: i will just doesFileExist to filter out the files that do not exist with filterM
16:39:47 <roconnor> Philippa: you mean feeding ticks?  Like Cappretta's work?
16:39:48 <Philippa> right. But what if it's (Tomorrow a, Tomorrow World)?
16:39:51 <Philippa> yeah
16:40:24 <roconnor> hmm
16:41:45 <Philippa> just don't ask about acausal computation :p
16:42:17 <roconnor> is lazy tuples enough to get to get the first and second compontents and get partial data out of that
16:42:29 <roconnor> like some of those print statements?
16:42:56 <Philippa> probably not (and you really want something slightly more structured than Tomorrow World)
16:43:08 <roconnor> Philippa: I think trying to get the World out of that computation would force the entire computation (which would take forever)
16:43:30 <roconnor> Philippa: I'm pretty sure the model is totally broken beyond all repair :D
16:43:44 <Philippa> yes, it would. But if you replace Tomorrow World with something that spits out intermediates as it ticks, you're fine
16:44:22 <roconnor> Philippa: I don't think it works...
16:44:25 <roconnor> but I'm not sure
16:44:56 <roconnor> because of the stupid state model World -> (a,world), you can never be sure that the function will take the world and undo some stuff.
16:45:23 <Philippa> you're worried about linearity?
16:45:40 <roconnor> ya
16:45:46 <roconnor> I"m worried about bad primops
16:46:04 <roconnor> like const ((),NewWorld)
16:46:29 <conal> roconnor: sounds like you want a junk-free model
16:47:13 <roconnor> even if the prim ops don't exist, the State model thinks they might exist.
16:47:15 <Philippa> *nod*. Which is something slightly more specific - fair enough if it's what you want
16:47:45 <Philippa> eh, you can probably do the linear typing if you have to
16:47:59 <Philippa> just don't ask about that quantum implementation of fix :p
16:48:07 <roconnor> conal: I'm not really worred about junk per se.  Just trying to illustrate why you can't get any output from forever (print foo) no matter what World is.
16:48:48 <Philippa> how does the existance of a BigBang primop affect forever (print foo)?
16:49:15 <Pseudonym> Philippa: OK, I'll bite.  What about the quantum implementation of fix?
16:49:17 * ddarius recommends experimentation.
16:49:18 <roconnor> Philippa: it means taht forever (print foo) >> bigBang doesn't print anything
16:49:25 * Pseudonym suspects it brings a new meaning to "black hole"
16:49:46 <roconnor> so how can you inspect the result of a State World comptuation to get the partial print information
16:49:57 <conal> roconnor: are you sure you can't?  maybe you have something more specific in mind than World -> (a,World)
16:50:00 <Philippa> roconnor: okay. So we rule that out, presumably by linear typing
16:50:06 <Philippa> and I mean linear, not uniqueness
16:50:15 <roconnor> Philippa: ah well, Agda doesn't have linear typing does it?
16:50:34 <Philippa> roconnor: if I have to build an entire universe to model the universe in, so be it :p
16:50:41 <roconnor> conal: I'm not sure, but fairly sure.
16:50:57 <roconnor> woah
16:51:00 <roconnor> deep embedding
16:51:22 <Philippa> also, I don't think it's unfair to say that the IO model includes the primop set up to at least some notion of FFI that's known not to screw with the entire universe
16:51:32 <conal> roconnor: any idea how to prove?
16:51:49 <roconnor> conal: I need a course on domain theory :(
16:52:12 <ddarius> Philippa: I'm having trouble parsing that sentence, but what I think it means seems completely false.
16:52:42 <conal> roconnor: maybe you don't need such a course.  that domain is very simple. not even recursive.
16:52:46 <ddarius> (Well, at least with regards to the relevant part of the universe, though arguably it does have effects on the entire universe eventually.)
16:53:13 <conal> roconnor: and you could use a simple notion of World, namely a single string of output
16:53:24 <Philippa> ddarius: OK, more like "doesn't get to create new universes or throw the current one away". Sloppy phrasing on my part
16:53:57 <ddarius> Philippa: Those MWI people might still disagree, but those MWI people are crazy.
16:54:03 <roconnor> conal: I think some continuting argument saying that if you could get partial information out of forever (print foo) then you would, by continutity, get the same information out of (forever (print foo) >> BigBang).
16:54:09 <roconnor> *continuity
16:54:25 <Philippa> ddarius: that, and it just forces me to rebind 'universe' to be slightly different to their meaning, no big :-)
16:55:07 <joe1> any thoughts on the code here: http://pastebin.com/n3AVz10u
16:55:11 <joe1> please..
16:55:18 <conal> roconnor: and you wouldn't want that outcome?
16:55:23 <Philippa> roconnor: I think that's a sort error, if anything. You've got something akin to * : * going on
16:55:44 <conal> roconnor: maybe you want BigBang to erase the string?
16:55:45 <roconnor> conal: do because (forever (print foo) >> BigBang) doesn't print anything.
16:55:55 <roconnor> conal: yes, big bang erases the string.
16:56:17 <conal> roconnor: oh. you want output erasure in your model.
16:56:20 <roconnor> not really erases even.  Totally ignores the string and substitutes it's own
16:56:23 <Saizan> (what is the current experimental validity of MWI?)
16:56:31 <roconnor> conal: *I* don't want output erasure in my model
16:56:38 <roconnor> conal: but State World has it in it's model
16:56:45 <roconnor> which is partly why it is a crappy model
16:57:16 <conal> roconnor: only an issue if you're going for junk-freeness
16:57:19 <Philippa> personally I say rule it out. It's not exactly a crazy condition
16:57:20 <roconnor> but the main reason it is a crappy model is (we believe) that it doesn't distinguish between (forever (print foo)) and \_ -> undefined.
16:57:28 <ddarius> Saizan: It's not something that can be experimentally validated for the most part.  There may be a few experimental results suggested by MWI and not by the standard model, but they are way beyond our current capabilities to do.
16:57:40 <conal> roconnor: junk-freeness is optional
16:57:45 <Philippa> right, but you're having to introduce primops explicitly designed to screw with it to prevent that distinction now
16:57:45 <joe1> is there a way that I can use one line instead of the 2 below
16:57:47 <joe1>    ep0_in_odd_files <- filterM doesFileExist ["file1.dat","file2.dat","file3.dat"]
16:57:50 <joe1>    mapM_ removeFile ep0_in_odd_files
16:57:50 <roconnor> conal: I'm just using the junk as a tool for showing that it doesn't distiguish (forever (print foo)) and (\_ -> undefined)
16:57:59 <Philippa> primops whose semantics are... distinctly questionable
16:58:24 <roconnor> Philippa: I'm not introducing the primops.  The junk was already in the model.
16:58:56 <Philippa> it's not in the linear version, though
16:58:58 <roconnor> again it isn't the junk that is the real problem (though it is distriction) I just want to prove that (forever (print foo)) isn't captured correctly by the model.
16:59:02 <roconnor> no
16:59:17 <aristid> (forever $ print foo) looks nicer
16:59:20 <roconnor> conal: World --o (a,World) probably works as a model
16:59:26 <roconnor> or plausibly works as a model
16:59:31 <roconnor> I could believe it.
16:59:40 <conal> roconnor: if so, then World -> (a,World) also works.  but is junkier.
16:59:49 <Philippa> okay. And World -> (a,World) works /when modelling implementable computations/
17:00:00 <Philippa> that is, the computations're modelled accurately in it
17:00:01 <roconnor> conal: oh.  Maybe it doesn't work then.
17:00:16 <Philippa> the existance of junk, so long as you can tell it's junk, doesn't affect that
17:00:23 <roconnor> I don't know how --o works in domain theory
17:00:28 <roconnor> :)
17:00:31 <Philippa> it's like using the reals as a model of the naturals
17:01:06 <Philippa> we're not actually using /all/ the reals as the model
17:01:11 <Philippa> they're just the domain of the model
17:01:34 <roconnor> Philippa: okay, but again it isn't the junk I have a problem with
17:02:02 <roconnor> I just want to prove (forever (print foo)) and (\_ -> undefiend) are indistigushable
17:02:28 <Philippa> yeah, but they are distinguishable for an appropriate value of World
17:02:33 <conal> roconnor: prove, based entirely on the choice of model, right?
17:02:43 <roconnor> prove for any choice of World
17:03:02 <conal> roconnor: sure.  wow. i bet that claim is false.
17:03:09 <roconnor> I think it is true :)
17:03:10 <Philippa> well if all you know is that it's called World then you haven't got the means to distinguish
17:03:34 <roconnor> Philippa: you are allow to make World whatever you like
17:03:37 <Philippa> but otherwise? The model I sketched above distinguishes fine. You had to introduce BigBang to break it
17:04:02 <roconnor> Philippa: you mean with the linear arrow
17:04:15 <Philippa> no, I don't need the linear arrow to handle this case!
17:04:28 <Philippa> I only need the linear arrow to rule out junk like BigBang
17:04:44 <roconnor> but State doesn't use the linear arrow
17:05:17 <Eduard_Munteanu> o/
17:05:20 <Philippa> look, you're saying you don't care about the junk, but you very clearly do: you're not allowing me a junky model
17:05:34 <Philippa> otherwise, I'm allowed to pick the non-linear version
17:05:50 <roconnor> Philippa: you are allowed to make World anything you want, but you cannot touch my arrow.
17:06:07 <Philippa> right. Then the version I sketched out above, before I introduced linearity
17:06:34 <roconnor> your Tomorrow World thing?
17:06:57 <Eduard_Munteanu> I'm defining a 2D grid where each cell has links in all directions, somewhat like a 2D doubly-linked list. However, I'm a bit suspicious of how a fmap would work.
17:06:58 <Philippa> you get back (_|_, (Tomorrow (Print foo) (Tomorrow (Print foo) (Tomorrow ...)))
17:07:00 <Eduard_Munteanu> http://paste.pocoo.org/show/278201
17:07:12 <roconnor> Philippa: I don't think you do.
17:07:22 <roconnor> I think you get (_|_,_|_)
17:07:26 <Eduard_Munteanu> Will this spin recursively back and forth or will Haskell somehow memoize them in the fmap recursive call?
17:07:34 <dolio> forever m = m >> forever m = fix (\r -> m >> r) = fix (\r -> \w -> r (snd $ m w))
17:07:43 <ddarius> @google weaving a web haskell
17:07:49 <ddarius> Fuck.
17:07:55 <dolio> (\r w -> r (snd $ m w)) _|_ = \w -> _|_ (snd $ m w) = _|_ . snd . m = _|_
17:07:58 <Eduard_Munteanu> ddarius: that was for me, I suppose.
17:08:02 <dolio> fix (\r w -> r (snd $ m w)) = _|_
17:08:14 <ddarius> Eduard_Munteanu: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.445 Read this.
17:08:23 <dolio> Some of that is probably only correct up to extensional equality, ignoring seq.
17:08:34 <dolio> Nevertheless.
17:08:52 <Eduard_Munteanu> ddarius: thanks, I was just getting to that.
17:08:53 <roconnor> conal: does dolio's proof suffice?
17:09:04 <roconnor> dolio: you make it looks so easy :)
17:10:04 <Saizan> dolio++
17:10:16 <ddarius> The significance of BigBang is really that -because- BigBang could be in the model, forever EXPR can't return even part of the world until it actually "finishes."
17:10:21 <conal> roconnor: nope.
17:10:29 <roconnor> conal!
17:10:40 <roconnor> conal: was the proof flawd?
17:10:47 <conal> roconnor: iiuc, dolio's proof uses more than just the model.
17:11:38 <Saizan> dolio's proof doesn't care about the model at all, it just uses the denotational semantics of haskell functions
17:11:41 <roconnor> ddarius: ya, that's what I was thinking.  But dolio's proof is certainly more clear :)
17:12:01 <roconnor> conal: what does it use beyond the model?
17:12:26 <roconnor> conal: heck it didn't even need to know anything about World, which is why it applies to all possibilities for World.
17:12:43 <conal> roconnor: iiuc, that proof assumes a semantics for >>
17:13:12 <roconnor> conal: the semantics of >> are given by "State" in "State World"
17:14:01 <conal> roconnor: oops. i was talking about World -> (a,World). sorry for the confusion.
17:14:23 <roconnor> conal: State World is isomorphic to World -> (a,World)
17:14:27 <conal> roconnor: i guess we originally said "State World" and then switched.
17:14:40 <Philippa> should the proof apply to Writer World as well?
17:14:44 <roconnor> conal: are you suggesting World -> (a,World) as a model of IO with a differen monad structure than the usual state one?
17:14:56 <conal> roconnor: exactly
17:14:58 <Philippa> what should (forever $ tell "foo") do?
17:15:09 <conal> roconnor: with a different semantics for the Monad operations
17:16:12 <roconnor> > runWriter (forever (tell "foo"))
17:16:19 <roconnor> no lambdabot
17:16:30 <Philippa> I'm not asking for the evaluated answer yet :-)
17:16:36 <ddarius> Philippa: That works, or should work, because it is inherent in the model that old output is preserved.
17:16:57 <Saizan> ?src >> Writer
17:17:12 <ddarius> lambdabot's absence is so destructive.
17:17:24 <ddarius> There was a time when there was no lambdab ot.
17:17:39 <djahandarie> Back in the day
17:17:44 * djahandarie wasn't even there
17:18:04 <ddarius> lambdabot was really cool when it was young because it was such a community project.
17:18:06 <roconnor> Philippa: it appears to denote ((),cycle "foo") as one would like.
17:18:09 <joe1> datalines line = (map (++ "\n") . replace_pid . addlength $ (getbytes line) ++ replicate (10 - (length . getbytes) line) "0x00" )
17:18:12 <joe1> getbytes line = [hexWord | hexWord@['0','x',x,y] <- words line, isHexDigit x && isHexDigit y]
17:18:30 <joe1> is there a smarter way to write the above function datalines?
17:18:31 <Philippa> okay, so something's breaking my intuitions here, and that's mostly "but you can implement Writer in terms of State" - what am I missing? What does that wrapping do that's odd?
17:18:53 <ddarius> Philippa: Writer (with an appropriate monoid) is guaranteed to be monotonic.  State is not.
17:19:11 <Kaidelong> is there something funky about Int or is it just a 32 bit two's complement integer?
17:19:13 <Saizan> Philippa: m >> n = (fst m ++ fst n, snd n); so forever m = fix (\r -> (fst m ++ fst r , snd r)), and (fst m ++ fst _|_ , snd _|_) /= _|_, so you can't deduce _|_ is the least fiex point
17:19:18 <Saizan> *fixed
17:19:20 <roconnor> Philippa: hmm, it seems you can't get a lazy writer with state.
17:19:23 <ddarius> Philippa: BigBang is a non-monotonic operation.  The fact that it -could- be there makes it impossible for State to behave monotonically here.
17:19:30 <Kaidelong> if I do things like
17:19:43 <Kaidelong> shiftL 31 (complement 0) :: Int
17:19:44 <Saizan> Philippa: in fact, when you implement Writer with State you get a stricter State
17:19:48 <Kaidelong> I get funky results like 15
17:19:52 <joe1> blank padding a list with "0x00" to get the list to a certain length using: (getbytes line) ++ replicate (10 - (length . getbytes) line) "0x00" )
17:19:55 <Philippa> ah. Learn something new every day...
17:19:59 <Saizan> *stricter Writer
17:20:04 <sipa> > maxBound :: Int
17:20:22 <Axman6> Kaidelong: Ints may be 64 bits
17:20:24 <roconnor> conal: okay.  I still think World -> (a,World) cannot model IO for any monad operations, but I would certainly need a different argument
17:20:39 <Kaidelong> bitSize (length [True]) gives me "32"
17:20:47 <sipa> in my ghci it is -2^63 to 2^63-1
17:21:25 <roconnor> conal: I vaguely recall some problem with the "a" there being "besize" the output "World" and not being "inside" the output World.
17:21:28 <dolio> forever (tell "foo") = fix (\r -> tell "foo" >> r) = fix (\r -> (fst r, "foo" ++ snd r))
17:21:30 <Kaidelong> hmm well I'll change the implementation to use bitSize
17:21:30 <roconnor> *beside*
17:21:37 <dolio> (\r -> (fst r, "foo" ++ snd r)) _|_ = (_|_, "foo" ++ _|_) /= _|_
17:21:46 <ddarius> Kaidelong: You are shifting 31 right 1.  15 is the correct answer.
17:22:08 <Kaidelong> ddarius: complement 0 is 1?
17:22:09 <Kaidelong> oh
17:22:14 <Kaidelong> arguments in the wrong order?
17:22:16 <ddarius> Yep.
17:22:18 <Eduard_Munteanu> ddarius: I took a look at that, seems to be very similar to what I did. I didn't get all the details with those Zipper/Web combinators, but it seems a traversal function must take visited locations out of the context.
17:22:34 <Kaidelong> I see, must be meant to be used infix then
17:22:47 <Eduard_Munteanu> It's a bit of a headache to figure out how such a grid will actually be processed.
17:23:05 <roconnor> Kaidelong: it is
17:23:12 <roconnor> I think at least
17:23:33 <monochrom> nonstrictness is so cool :)
17:23:42 <conal> roconnor: time for me to go. maybe continue later.
17:23:47 <monochrom> nonstrictness gives me more math to do :)
17:23:50 <roconnor> conal: see you later
17:24:11 <conal> roconnor: l8r.  fun chat
17:24:19 <ddarius> Eduard_Munteanu: If you want to avoid recomputation, you need to make sure you share values.  I didn't look at your code so I don't know if you are doing this or not.  Sometimes it can be simpler to pull out the sharing aspect explicitly, e.g. by having a Map, although that is certainly less efficient (though it won't really matter once all links are made.)
17:25:32 <Eduard_Munteanu> ddarius: well, this is all I have: http://paste.pocoo.org/show/278201/
17:25:40 <Eduard_Munteanu> ddarius: My point of concern is the 'fmap' definition.
17:25:52 * hackagebot yaml-light 0.1 - A light-weight wrapper with utility functions around HsSyck  http://hackage.haskell.org/package/yaml-light-0.1 (MichaelIlseman)
17:26:17 <Eduard_Munteanu> It feels wrong.
17:26:41 <digitteknohippie> has the network module changed?   i now get "Could not find module `Network'" when running my daskeb bot, which used to work fine.
17:27:09 <ddarius> Eduard_Munteanu: It isn't semantically wrong, but it certainly won't share anything.
17:28:17 <Eduard_Munteanu> ddarius: I'm not sure I get the actual meaning of 'sharing'. I'm concerned about recursively looping like up-down-up-down when applying fmap.
17:28:46 <Saizan> digitteknohippie: "ghc-pkg find-module Network" should tell you if it's there
17:29:05 <Saizan> digitteknohippie: from the hackage page it appears to still be exposed by the network package
17:29:34 <Saizan> digitteknohippie: it might be that your network package installation is now shadowed away for some reason though
17:29:49 <monochrom> tee hee hee
17:30:08 <Saizan> digitteknohippie: how are you running your bot? runghc?
17:30:11 <monochrom> need a collection of cabal-install horror stories. for halloween!
17:30:22 <ddarius> Eduard_Munteanu: It should work out albeit what you currently have is a type error.
17:30:44 <digitteknohippie> i have a shell script containing simply: runhaskell ~/daskeb.hs
17:30:45 <Eduard_Munteanu> ddarius: yes, I know, it should be '(up a)' instead of 'up'.
17:30:51 <Eduard_Munteanu> in the fmap definition.
17:31:26 <Eduard_Munteanu> ddarius: thanks, I'll continue working on it and see if it works. I was concerned about that.
17:31:49 <digitteknohippie> what kind of reason would it have been "shadowed away"?  and how can i circumvent this?
17:33:03 <Saizan> digitteknohippie: you can circumvent by asking explicitly for it, which is done by passing -package-id nerwork-<ver>-<id> as an argument to runhaskell, you can find the id by ghc-pkg describe network
17:33:31 <Eduard_Munteanu> Oh crap, 'occurs check', infinite types.
17:33:38 <monochrom> dstcruz: "quite the read to end the week". you are evil. :)
17:33:42 <digitteknohippie> hrmm.   not really ideal.
17:34:35 <Saizan> digitteknohippie: this kind of shadowing only happens when there are multiple installations of the same version of the same package, so you've to check if that's the case for some dependency of network
17:35:00 <Saizan> digitteknohippie: btw, first run "ghc-pkg check" to see if it isn't broken instead
17:35:06 <Eduard_Munteanu> Nvm, it worked.
17:35:36 <digitteknohippie> ghc-pkg check returned nothing, so i assume no news is good news.
17:36:22 <Saizan> yep
17:36:48 <digitteknohippie> and from ghc-pkg find-module Network, the result: "/var/lib/ghc-6.12.1/package.conf.d" is good news too?
17:36:56 <stepkut> i want a function which takes a path to a .hs file, the path given to -odir, and tells me where I can find the .o file that will be generated by ghc.. does something like this exist already?
17:37:07 <Saizan> digitteknohippie: no, it should list the network package
17:37:21 <stepkut> I think that requires parsing the .hs file at least enough to extract the module name from it ?
17:37:26 <Saizan> digitteknohippie: ghc-pkg list network?
17:38:44 <dibblego> http://paste.pocoo.org/show/278207/ any suggestions on how one might start diagnosing this?
17:38:52 <digitteknohippie> Saizan: that gets: /var/lib/ghc-6.12.1/package.conf.d
17:39:13 <Saizan> digitteknohippie: ok, so it's much simpler, you don't have the network package installed, cabal install network
17:39:30 <Saizan> stepkut: unless you also know the root of your source tree
17:39:57 <digitteknohippie> cool, thnx for your help Saizan, i learned a lot.
17:40:01 <stepkut> Saizan: yeah, I just thought of that.. in the current API I don't.. but maybe the API can be changed so that you specify the root
17:41:42 <monochrom> dibblego: one way it happens is two versions of the "time" package installed. normally multiple versions are fine. but not with those packages that come with their own C code --- obvious name clash. "time" has its own C code.
17:42:12 <dibblego> monochrom, I noticed I had two versions of "old-time"
17:42:21 <dibblego> oh and two of "time" as well
17:42:50 <monochrom> Yeah, suppose X deps on one version, Y deps on the other version, and then you import X and import Y. boom.
17:43:27 <dibblego> yeah I can't remove them without breaking dependencies :(
17:47:18 <Saizan> maybe ghci doesn't need load both at the same time though?
17:47:50 <dibblego> it crashes when I call a specific function
17:49:02 <Saizan> i guess unless you are using -package ghci will only load the strictly necessary, if that's correct you're stuck to compilation
17:49:12 <Saizan> (ld just ignores duplicated definitions)
17:49:47 <Saizan> unless there's some TH
17:50:03 <monochrom> well if you -package X and -package Y then the duplication is strictly necessary :)
17:50:28 <dibblego> I'm trying to remove the dependency altogether, but I don't like my chances at the moment
17:50:50 <Saizan> iirc, with "-package time" it'll link in both versions for no real reason, but icbw
17:50:53 <Eduard_Munteanu> Bah, this web is getting on my nerves...
17:50:54 <monochrom> need rollbackable file system
17:51:09 <Eduard_Munteanu> If I use an array with an index in it, is it still a zipper?
17:51:12 <monochrom> web on your nerves? try usenet
17:51:27 <Eduard_Munteanu> monochrom: heh, not the WWW, my 2D grid :)
17:51:32 <monochrom> oops
17:51:50 <Saizan> Eduard_Munteanu: update will be O(n), unless it's a mutable array
17:52:12 <monochrom> array with index is not exactly a zipper. but I would not use real zipper for array. have index, is happy.
17:52:46 <Eduard_Munteanu> Saizan: well, I'm probably going for DiffArray, but I'm not sure it matters since I'm thinking of making it a monad a-la sigfpe's cellular automata.
17:52:49 <monochrom> zipper is a method not a purpose.
17:52:51 <Eduard_Munteanu> *comonad.
17:53:28 <Eduard_Munteanu> I see.
17:53:57 <monochrom> oh, I haven't read comp.lang.haskell for a few days.
17:53:59 <Eduard_Munteanu> monochrom: basically I'm trying to model a 2D cellular automata using comonads, and those things really are zippers, but I'd be damned if I can figure out how to do it in 2D.
17:54:14 <monochrom> neato, not much happened there.
17:54:18 <Saizan> Eduard_Munteanu: i tried exactly that and it didn't end well, though i think it was my first computational intensive haskell program, so i might have screwed it up badly
17:54:31 <Saizan> Eduard_Munteanu: well, actually UArray worked well for me
17:54:48 <aristid> lol. Haskell-cafe 684 unread messages
17:55:08 <monochrom> I bravely reduced 684 to 64.
17:55:14 <jmcarthur> 1258 here
17:55:38 <monochrom> there are many skippable threads, such as .*haskeller.*
17:55:44 <aristid> highest number wins?
17:55:57 <monochrom> and .*interesting paper from.*
17:56:00 <jmcarthur> loses :(
17:56:11 <pumpkin> are free constructions terminal in the category of the free thing they are?
17:56:17 <tehgeekmeister> how easy is it to create a fully static binary using ghc 12.1 on Linux?
17:56:40 <Eduard_Munteanu> Saizan: well, I'm not too worried about performance. I'm rather worried I'd have to scratch one thing from the "things-which-comonads-are-useful-for" list :)
17:57:06 <monochrom> I thought free F-algebra was initial in the category of F-algebras. (fix a functor F)
17:57:07 <jmcarthur> tehgeekmeister: "fully" static
17:57:08 <jmcarthur> ?
17:57:09 <Eduard_Munteanu> (The actual program is a school project that I can very well do in C/Matlab/etc., but I'd rather not :D)
17:57:16 <jmcarthur> tehgeekmeister: including things like libc?
17:57:49 <Saizan> Eduard_Munteanu: nah, a pair of an array and an index is a nice comonad :)
17:57:50 <monochrom> ghc 12.1 is out? XD  <duck>
17:58:02 <digitteknohippie> thnx again saizen got my haskel irc bot working again.  :)   ( http://www.wastedartist.com/scripts/daskeb/daskeb.html a link to it, incase anyone wants a very basic haskel irc bot to start to build their own from)
17:58:27 <Eduard_Munteanu> Saizan: thanks, that cheered me up, will go that way.
17:58:28 <tehgeekmeister> versions might vary enough to be incompatible, but I can see already why that's a problem
17:58:45 <tehgeekmeister> monochrom: enough out of you.
18:00:43 <tehgeekmeister> fine, I'll just deploy to the same release of the same distro I code on, I guess.  wanted to keep the server on a lts release, but it doesnt look feasible
18:02:56 <dolio> pumpkin: Free things are initial. Cofree things are terminal.
18:02:59 <Saizan> tehgeekmeister: -static -optl-static might be it
18:03:01 <dolio> Roughly speaking.
18:03:09 <pumpkin> dolio: oh yeah
18:03:30 * Eduard_Munteanu wonders how many times he found out about very nice things such as zippers...
18:03:50 <Eduard_Munteanu> ... just to be disappointed when they wouldn't work on other very common problems.
18:04:04 * Eduard_Munteanu can't generalize.
18:04:10 <tehgeekmeister> Saizan: I'll try that.  don't want to have to build the platform for lucid lynx
18:04:15 <jmcarthur> generalize in what way?
18:04:35 <dolio> Strictly speaking, free things are generated by a left adjoint, and cofree things are generated by a right adjoint. But initial things are left adjoints and terminal things are right adjoints, so it probably works out most of the time.
18:06:09 <Eduard_Munteanu> jmcarthur: well I tried taking sigfpe's stuff from 1D to 2D, and I really don't like the results.
18:06:20 <jmcarthur> what stuff?
18:06:21 <Saizan> "the free monoid" is not the initial monoid though, only the initial "generated-monoid"
18:06:36 <Eduard_Munteanu> jmcarthur: the comonadic/zipper-ish cellular automata.
18:06:55 <jmcarthur> he used a zipper?
18:07:06 <jmcarthur> what was it, an array and an index?
18:07:09 <Eduard_Munteanu> jmcarthur: he does it on a 1D "plane", it's very elegant. But all tweaks look awkward on 2D.
18:07:32 <Eduard_Munteanu> jmcarthur: in 1D it's a zipper like list-value-list.
18:07:51 <jmcarthur> i'll have to check it out
18:07:55 <Saizan> jmcarthur: just Zipper a = Z { prefix :: [a]; current :: a; suffix :: [a] }
18:08:22 <Eduard_Munteanu> jmcarthur: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
18:08:25 <jmcarthur> yeah. i was just seeing how he was using it
18:08:31 <jmcarthur> Saizan: ^^
18:08:44 <dolio> Saizan: Right. I'd have to think about whether that's an issue for 'free F-algebra'. You might be able to have an initial F-algebra on some additional set of generators.
18:08:48 <jmcarthur> i think i personally would have use an array+index
18:08:56 <jmcarthur> *used
18:08:57 <Eduard_Munteanu> Well, that's equivalent to the more common "prefix, current:suffix"
18:09:24 <dolio> The initial F-algebra used in semantics of datatypes would then be the free F-algebra on the empty set of additional generators.
18:09:58 <jmcarthur> Eduard_Munteanu: what Saizan said?
18:10:23 <jmcarthur> not completely equivalent. "prefix, current:suffix" allows it to be completely empty
18:10:31 <jmcarthur> which is not comonadic
18:10:39 <jmcarthur> since you can't always extract a value from it
18:10:57 <Eduard_Munteanu> jmcarthur: oh, right.
18:11:08 <Saizan> dolio: yeah, while the free F monad would be the initial F-algebra on some generator, i think
18:11:14 <dolio> Free F-algebra on a set of generators is actually probably the free monad on F.
18:11:25 <Saizan> heh :)
18:12:21 <Eduard_Munteanu> Anyway, sigfpe's was looking simple and great (no arrays, just lists). It seems anything in nD, n > 1 is always going to be hackish with zipper lists.
18:13:18 <Saizan> in the comments of that post there's my fairly screwed up attempt at 2D
18:13:41 <Saizan> that's not the zipper for [[a]], nor the one for a grid type, i think
18:14:24 <pumpkin> psykotic had some nice matrix zippers on reddit somewhere
18:14:42 <pumpkin> which made lots of matrix operations quite elegant
18:15:11 <Eduard_Munteanu> I see.
18:15:56 <Eduard_Munteanu> Well what matters is the context you get, and I suppose that's application dependent.
18:17:06 <Saizan> also what's the complexity of moving around if you need to
18:21:35 <Eduard_Munteanu> Hm, I'm more clueless than I thought... how does one get an array in Haskell in the first place? I don't see how an ADT does it.
18:21:49 <Eduard_Munteanu> Or is it some FFI magic or compiler-specific stuff?
18:22:20 <jmcarthur> Eduard_Munteanu: yes
18:22:24 <monochrom> is backed by an array at some low level
18:22:42 <Eduard_Munteanu> Hm, I see.
18:23:08 <jmcarthur> Eduard_Munteanu: for 2D arrays i would recommend either the array package or the repa package, but repa is very experimental and only works really fast for ghc 7
18:23:44 <jmcarthur> repa also is lacking a lot of nice functionality, i guess
18:23:57 <jmcarthur> so i guess i recommend the array library
18:24:02 <jmcarthur> Data.Array and all that
18:24:13 <Eduard_Munteanu> jmcarthur: I'll look into them, I'm looking for something nice rather than fast. I was initially considering Data.Array.(Diff)Array.
18:24:24 * Saizan recommends UArray if your types fit
18:24:31 <jmcarthur> don't do DiffArray unless you really don't care about speed :\
18:24:37 <jmcarthur> DiffArray is slow for unknown reasons
18:25:22 <jmcarthur> Eduard_Munteanu: another thing you could do is use IntMap instead of an array
18:25:35 <jmcarthur> Eduard_Munteanu: so a "2d array" could be IntMap (IntMap a)
18:25:59 <jmcarthur> Eduard_Munteanu: although the Data.Array stuff is a bit nicer for indexing thanks to Ix
18:26:14 <Eduard_Munteanu> jmcarthur: hm, I'm not sure if that provides good context for computations.
18:26:28 <jmcarthur> why not?
18:27:00 <jmcarthur> it's maybe slightly less cache coherent than a real array, but you only get cache coherency if you are using unboxed arrays (like UArray) anyway
18:27:05 <Eduard_Munteanu> jmcarthur: well if that's anything like an array of arrays, then it's not that elegant to get neighboring cells.
18:27:14 <jmcarthur> why not?
18:27:20 <jmcarthur> it's not like a list of lists
18:27:45 <Eduard_Munteanu> Ah, I'll take a look at it then.
18:28:10 <jmcarthur> you just have to keep an index, just like you would with an array
18:28:36 <jmcarthur> except that IntMap is pure and all that nice stuff
18:29:13 <djahandarie> There should be something that automatically benchmarks most of the common data structure packages and does it for every new GHC version
18:29:14 <jmcarthur> there are pure arrays too of course, but it's slower to do things like update a single element at a time (which i think maybe you don't care about in this case anyway)
18:30:23 <Eduard_Munteanu> jmcarthur: hm, Data.Array should be pure.
18:30:52 <Eduard_Munteanu> jmcarthur: btw, is there any alternative to DiffArray?
18:31:11 <Eduard_Munteanu> I really liked it.
18:31:29 <djahandarie> DiffArray got split into its own package for someone to fix it and it never was
18:31:52 <djahandarie> Maybe I can try and see if I can... as long as it's easy ;)
18:32:09 <Eduard_Munteanu> Heh. Nevermind, I'll just have a look at IntMap.
18:32:18 <c_wraith> I think the fundamental problem with DiffArray is every read and write is gated on an MVar
18:33:00 <c_wraith> That's an extra level of locking and dereferencing for every read and write
18:33:25 <Saizan> for cojoin/extend a pure array works quite well since you're producing a whole new array anyway
18:33:37 <Eduard_Munteanu> (If that's the kind of performance drop we're talking about, then I might as well use it anyway.)
18:33:49 <jmcarthur> djahandarie: i've already looked at it, but i quit
18:34:07 <Eduard_Munteanu> Saizan: hm, that makes sense. Then I shouldn't really care.
18:34:08 <djahandarie> Well that's a bad sign
18:34:16 <jmcarthur> djahandarie: i only quit because i lost interest
18:34:24 <jmcarthur> djahandarie: profiling wasn't very helpful though
18:34:43 <c_wraith> I think it was edwardk who said the problem was the MVar lock.  And he's usually pretty reliable on performance issues
18:34:55 <djahandarie> It probably is
18:35:06 <jmcarthur> i don't see what else it could be
18:35:25 <jmcarthur> and that's something that is likely not to really show up in profiling, i suspect
18:36:12 <djahandarie> Is it possible to use futexs in Haskell?
18:36:25 <Saizan> Eduard_Munteanu: what i would be worried about is only memory use, Array Bool uses boxed bools, so you're wasting a few words for a single bit of information, UArray Bool solves that, but i've no idea of how large you want your arrays to be :)
18:37:00 * Saizan wanted to twist the game of life into an iterated image processing filter
18:37:22 <jmcarthur> :o
18:37:47 <Eduard_Munteanu> Saizan: it's some sort of homework, so I suspect we'll be punching in a few gliders and such.
18:38:21 <Eduard_Munteanu> Though it's not Game of Life, they only said to make a cellular automata that models some process.
18:39:59 <Eduard_Munteanu> Pretty much a polymorphic homework :)
18:40:06 <Saizan> heh :)
18:40:40 <Saizan> mh, if you use IntMap you could be clever and store only alive cells
18:40:57 <djahandarie> Heh, dcoutts mentioned futexs in the thread about DiffArray, although this was... years ago
18:41:12 <djahandarie> Scares me when people have been doing Haskell for so long, lol
18:41:49 <djahandarie> Also scares me that diffarray performance has sucked for 7 years
18:42:34 <Eduard_Munteanu> I see.
18:43:36 <Samantha> who knows how the scanl1 function works
18:43:37 <Samantha> ??
18:43:45 <djahandarie> @src scanl1
18:43:47 <Saizan> ?src scanl1
18:43:49 <pumpkin> Samantha: quite a few people, I'd expect
18:43:54 <Saizan> gh, no bot
18:43:56 <djahandarie> But not lambdabot, since it's dead
18:44:02 <djahandarie> (And not human)
18:44:13 <Samantha> pumpkin : Can you explain me 
18:44:20 <Samantha> that function
18:44:22 <pumpkin> Prelude Data.List> scanl1 (+) [1..10]
18:44:22 <pumpkin> [1,3,6,10,15,21,28,36,45,55]
18:44:28 <Samantha> Ok 
18:44:34 <Samantha> but how it works
18:44:35 <luite> is there no way to make lambdabot automatically reconnect after it loses its connection?
18:45:01 <Samantha> pumpkin: What is inside
18:45:07 <Samantha> that function
18:45:12 <pumpkin> Prelude Data.List> map (foldr1 (+)) (tail $ inits [1..10])
18:45:12 <pumpkin> [1,3,6,10,15,21,28,36,45,55]
18:45:19 <Samantha> can break down form me
18:45:29 <pumpkin> Prelude Data.List> inits [1..10]
18:45:29 <pumpkin> [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9,10]]
18:45:58 <monochrom> Samantha: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-List.html#scanl
18:45:58 <pumpkin> Samantha: a scan is like a fold that keeps the intermediate steps around
18:46:21 <djahandarie> pumpkin, could that be deforested down to the explicit recursion in prelude?
18:47:04 <pumpkin> I doubt it, as inits is horrendously inefficient and I don't think it fuses nicely with anything (even in stream fusion?)
18:47:17 <djahandarie> Hmmm
18:47:48 * djahandarie tries it
18:47:55 <Saizan> it'd also have to do something very clever with "map (foldr1 (+))"
18:48:11 <Saizan> the explicit recursion shares the intermediates
18:48:11 <djahandarie> It looks like supercompilation could figure it out, maybe
18:48:30 <danharaj> Is there a relationship between the rank of a polymorphic function and, say, the set of sigma sentences in a logic?
18:48:32 <pumpkin> I'm not even sure there
18:48:37 <pumpkin> since it adds sharing
18:48:55 <pumpkin> but it'd be interesting to see if one can write a general optimization that catches it
18:49:32 <Samantha> what is this error message means No instance for NUM
18:49:34 <Samantha> ??
18:50:06 <pumpkin> va.gov?
18:50:12 <Samantha> who me
18:50:15 <Samantha> yeah 
18:50:15 <pumpkin> yep :)
18:50:19 <Samantha> I am working
18:50:23 <pumpkin> aha :P
18:50:44 <Samantha> ok you got me
18:50:46 <djahandarie> Stop backtracing, pumpkin.
18:50:55 <pumpkin> anyway, it means you're trying to treat something that isn't (obviously) a number as a number
18:51:03 <pumpkin> djahandarie: a simple whois shows it :P
18:51:13 <Saizan> danharaj: maybe it fits more directly to Pi sentences? assuming i'm thinking of the right thing
18:51:58 <monochrom> "hello"+2 is one way to get yourself a "no instance for Num"
18:52:08 <danharaj> Saizan: Yes, I think you always want a leading universal quantifier. It was just an errant thought I had while doing some studying.
18:52:26 <Samantha> I am trying to define scanl1 
18:52:33 <Samantha> and I getting that error message
18:53:29 <monochrom> it happened to many people.
18:53:35 <Eduard_Munteanu> Samantha: that's really wrong then, Num methods shouldn't belong in scanl1 definition.
18:53:49 <Samantha> oh my god
18:53:51 <Eduard_Munteanu> Samantha: as in scanl1 should do any addition or something like that.
18:54:00 <Saizan> danharaj: btw, is there a term i can google to find a good description of these classifications? i've only heard of them in passing
18:54:00 <Eduard_Munteanu> *shouldn't
18:54:11 <Samantha> Why 
18:54:12 <Samantha> ?
18:54:24 <danharaj> Saizan: arithmetic hierarchy, maybe?
18:54:36 <dolio> I don't think there's an obvious way to connect them.
18:54:46 <dolio> You can't reduce things to prenex normal form in intuitionistic logic.
18:54:49 <Eduard_Munteanu> Samantha: scanl1 is merely applying the operation supplied as an argument, not something Num-specific.
18:55:00 <dolio> Unless I'm forgetting something.
18:55:06 <Saizan> danharaj: seems to work, thanks
18:55:20 <Eduard_Munteanu> Samantha: what is your definition of scanl1?
18:55:40 <danharaj> It's an interesting branch of computer science/mathematics but it doesn't interest me too much because I can't program with it :p
18:55:48 <Samantha> I called you in a private chat
18:56:03 <Eduard_Munteanu> We'd better talk here.
18:56:03 <danharaj> right now I am working through my copy of Maclane that I got last week and I'm trying to understand the Yoneda lemma as a mathematician and then as a computer scientist.
18:56:15 <Saizan> well, i've seen it more in the middle of arguments about the consistency of some theories :)
18:56:25 <Eduard_Munteanu> More eyes, more/better help.
18:56:28 <dolio> And encoding by swapping quantifiers doesn't reduce the rank of a type, I think.
18:56:34 <Samantha> ok
18:56:35 <monochrom> why do you ruin the experience by asking for specifics and details. should just let it be as vague as possible, or even more vague than possible.
18:57:00 <dolio> (forall a. a) -> T => forall r. ((exists a. a -> T) -> r) -> r
18:57:17 <dolio> Or did I do that wrong...
18:57:31 <dolio> Yeah, I did.
18:57:34 <danharaj> wouldn't it be the other way around
18:57:38 <danharaj> forall swapped with exists?
18:57:52 <danharaj> wait that doesn't look right either
18:57:54 <dolio> (forall a. a) -> T => (forall r. (exists a. a -> r) -> r) -> T
18:58:47 <dolio> Anyhow, the first is rank-2, and the second is rank-3, I think.
18:58:55 <dolio> So that's not making it lower.
18:59:54 <danharaj> ah well, it looked similar. Doesn't seem like it.
19:00:30 <dolio> And in classical logic, (forall a. a) -> T is equivalent to exists a. a -> T, I believe.
19:00:46 <monochrom> yes
19:00:52 <dolio> And ((forall a. a) -> T) -> T is equivalent to forall a. ((a -> T) -> T).
19:01:38 <dolio> So there are arbitrarily high rank types that reduce to Pi_1 or Sigma_1 sentences.
19:06:52 <Saizan> does that mean that with a built-in call/cc we'd have less use for higher rank types?
19:08:09 <monochrom> do you mean, every time I want to write a higher-rank function, I encode it using call/cc instead and stay rank-1?
19:08:26 <monochrom> I think I will not do encoding.
19:08:29 <dolio> Sounds great.
19:08:55 <Saizan> i was merely interested in the possibility :P
19:09:35 <danharaj> does yoneda's lemma work if you replace Set with an arbitrary elementary topos?
19:10:09 <ddarius> danharaj: There are enriched Yoneda lemmas and they don't require all the structure of a topos.
19:10:49 <danharaj> ddarius: ah. I was wondering because I can see instances where you would like something like the yoneda embedding but you don't want to work with Set.
19:10:49 <ddarius> However, they may require structure that's not implied by a topos, though toposes tend to be pretty nice.
19:10:54 <pumpkin> enriched yoneda lemmas on impoverished topoi?
19:11:03 <pumpkin> lemmata, I should say
19:11:08 <danharaj> lemons
19:11:14 <ddarius> danharaj: Read "Basic Concepts of Enriched Category Theory"
19:11:15 <pumpkin> yeah, or that
19:11:40 <danharaj> ddarius: thanks for the reference. I'll look at it after I digest enough of Maclane.
19:11:45 <monochrom> you also need existential type. translate ((∀a. p→q)→r) to (∃a. (p→q)→r).
19:11:46 <danharaj> 'tis a long road ahead.
19:12:35 <Eduard_Munteanu> Heh, lemmata is the plural form?
19:12:43 <ddarius> danharaj: I highly recommend Basic Concepts even if you aren't "ready" for the enriched case.  It is the most comprehensive introduction to indexed (weighted) (co)limits which you rarely hear about elsewhere and are very handy.
19:13:22 <monochrom> lemmata is the traditional plural form. but you don't have to be traditional.
19:13:35 <monochrom> another tradition: F-algebrae
19:14:30 <danharaj> ddarius: good to know. I am also intending to read Jacobs' Categorical Logic and Type Theory thoroughly because I thought it would be a good introduction to fibred categories and their computer scientific applications. Do you have superior suggestions to offer?
19:14:56 <EvanCarroll> is there a way to take a slice of the opposite side?
19:15:05 <EvanCarroll> erg
19:15:09 <EvanCarroll> badly worded
19:15:36 <danharaj> (it looks to be out of print but I bet my library has a copy)
19:15:40 <EvanCarroll> I was looking for a pointless style slice that satisfied the second arg first, I assume I just flip
19:16:41 <Saizan> EvanCarroll: (+ 2) ? 
19:17:26 <EvanCarroll> pointless fashion
19:17:32 <EvanCarroll> map (/) [1..10]
19:17:34 <djahandarie> pumpkin, yeah, it fails hard at deforesting this at all
19:17:38 <EvanCarroll> map (flip.(/)) [1..10]
19:17:48 <pumpkin> djahandarie: now come up with a general transformation that catches it :P
19:18:19 <Eduard_Munteanu> EvanCarroll: that doesn't look right.
19:20:10 * Saizan wonders if there's an easy and generalizable way to prove map id = id
19:20:26 <ddarius> danharaj: I've read his thesis.  It's informative but not easy to read.  The Prospectus for his book seemed more approachable but I haven't read the (rest of the) book.
19:21:21 <dolio> I've read about half of Introduction to Higher Order Categorical Logic, since someone mentioned it a few days ago.
19:21:26 <dolio> I can't say I'm thrilled with it, though.
19:21:37 <djahandarie> Didn't you mention it was complex or something?
19:21:47 <danharaj> ddarius: fair enough. I'll get back to you in a few weeks and tell you how it goes :p
19:21:59 <dolio> Well, there was one section where they were writing their implication arrows as <=.
19:22:12 <dolio> For simply typed lambda calculus.
19:22:24 <dolio> For some reason, in the section on type theory, they're writing it forward again.
19:22:39 <djahandarie> Variety!
19:23:34 <djahandarie> Reading all this STG makes me feel like writing that LLVM backend was hard as hell
19:24:05 <EvanCarroll> Eduard_Munteanu: why?
19:24:06 <dolio> The book seems to spend significantly more time on the type theory/lambda calculus side of things, too, and I don't really like their presentation of it.
19:24:11 <monochrom> I saw an easy and generalizable way to prove map id = id. generalizable as in: the way is useful for all infinite_list_1 = infinite_list_2 proofs. easy as in: even easier than mentioning coinduction. but it is in an imperative programming paper, a theory of lazy imperative programming (just state and lazy data structures, no I/O)
19:24:22 <dolio> Not to mention that's the part I already know well.
19:24:53 <djahandarie> Last time I learned some type theory, it seemed... very verbose
19:25:10 <Eduard_Munteanu> EvanCarroll: flip . (/) != flip (/)
19:25:19 <Eduard_Munteanu> Seems you want the latter.
19:26:10 <pumpkin> djahandarie: the LLVM backend doesn't operate on STG does it?
19:26:17 <Saizan> monochrom: do you remember the name?
19:26:18 <pumpkin> I thought it just consumed cmm
19:26:42 <EvanCarroll> good point
19:26:48 <EvanCarroll> what does flip $ (/) do 
19:26:52 <EvanCarroll> erg
19:26:55 <EvanCarroll> rather flip . (/)
19:27:12 <Eduard_Munteanu> Fails at type-checking? :)
19:27:28 <Saizan> it works if you have a Fractional instance for functions :)
19:27:38 <Saizan> ?type flip . (/)
19:27:44 <djahandarie> pumpkin, yeah, from C--
19:27:46 <Saizan> sigh.
19:27:51 <pumpkin> djahandarie: cmm! :P
19:27:56 <djahandarie> Blah blah
19:28:09 <EvanCarroll>   :: (Fractional (b -> c)) => (b -> c) -> b -> (b -> c) -> c
19:28:21 <EvanCarroll> interesting.
19:28:42 <monochrom> Saizan: almost any in http://www.uni-ulm.de/en/in/pm/staff/ex/guttmann/research.html will do. he is the guy to look for.
19:28:44 <Saizan> anyhow, flip . (/) = \x -> flip ((/) x) = \x y z -> (/) x z y
19:29:01 <monochrom> actually specifically the topmost one, i.e., [3]
19:29:04 <EvanCarroll> takes a function in typeclass Fraction that takes a b, and return a c, takes a b, and another function of the same type, and returns a c
19:29:19 <EvanCarroll> awkward.
19:29:50 <Saizan> monochrom: thanks
19:29:56 <monochrom> oh oops, it is not available free.
19:31:13 <Saizan> yeah :\
19:35:02 <monochrom> perhaps I can just tell you what is done. the leap of faith: in "map id xs = id xs", if xs is an infinite list, it is produced by some producer code. producer code = (⊔i· f^i ⊥) for some f. w00t!  so map id xs = (⊔i· map id (f^i ⊥)). Now we just look at each map id (f^i ⊥) individually. each is just a finite list...
19:36:32 <monochrom> hell, map id (f^i ⊥) = f^i ⊥ is something you know from induction over finite lists.
19:37:16 <Veinor> monochrom: is guttmann the same guy as the hard drive erasure paper?
19:37:29 <monochrom> so the whole thing is map id xs = map id (⊔i· f^i ⊥) = (⊔i· map id (f^i ⊥)) = (⊔i· f^i ⊥) = xs.
19:37:57 <ddarius> Sounds like just proving by directly appealing to fixpoint induction.  Somewhat related is the take lemma.
19:38:05 <monochrom> His example in paper is something about map-foldr = foldr.
19:38:46 <monochrom> I don't think he does hard drive erasure.
19:38:47 <Saizan> "map id (f^i ⊥) = f^i ⊥" seems the only part specific to lists, also
19:40:55 <dolio> Whoa, Jacobs' thesis is typeset two-pages-per-sheet.
19:41:10 <monochrom> yes, it is like the "take lemma"
19:43:13 <Saizan> the take lemma is something like "if it holds for every prefix it holds for the whole list" ?
19:43:15 <monochrom> I like (⊔i· f^i ⊥) more than (take n) because nothing restricts f^i ⊥ to produce list of exactly i things, and there is no extra "take" to carry around, and yeah, I can use (⊔i· f^i ⊥) for all lazy data structure producers, not just list producers.
19:43:20 <roconnor> um, how come Tackling the Akward Squad is dated April 7, 2010?
19:43:28 <roconnor> I"m pretty sure I've read it years ago
19:43:47 <roconnor> oh wow
19:43:51 <monochrom> yeah, (xs = ys) iff (∀n. take n xs = take n ys)
19:43:53 <roconnor> it's been updated over the last 10 years
19:44:17 <monochrom> It was first posted after summer of 2000.
19:44:41 <monochrom> I know because I was at that instance of Marktoberdorf in which he gave the lectures!
19:48:21 <roconnor> :O
19:49:20 * Saizan hopes he remembered the right paper
19:52:23 <monochrom> let me look up the "take lemma" for real. Andrew Gordon was a cool guy.
19:55:11 <monochrom> Andrew Gordon was probably the reason Haskell went for monadic I/O finally. His thesis was exactly  on functional I/O. He discussed streams, CPS ADT (or GADT if you did it now), monad, and proved bisimulations between all of them. The thesis would give you an impression that the monadic story was favoured.
19:55:36 <monochrom> http://www.vex.net/~trebla/weblog/fpbooks.xhtml :)
19:55:48 <Samantha> any one knows how to add pairs using lists
19:55:49 <Samantha> ?
19:55:59 <monochrom> I bought the OUP edition of his thesis at all cost!
19:56:10 <Samantha>  any one knows how to add pairs using lists
19:56:15 <djahandarie> Whatever happened to Alp Mestanogullari's LLVM SoC thing?
19:57:39 <Eduard_Munteanu> Samantha: I'm not sure what you mean. Do you have a list of pairs and want to sum them up?
19:57:53 <monochrom> http://www.talk-sports.net/ahl/girlfriend.aspx/Andrew_Gordon  XD
19:59:05 <Eduard_Munteanu> LOL look at the comments: "i hope hes single now i hope his gf is ugly cuz he is way to cute"
20:00:56 <Samantha> Sorry for being rude 
20:01:12 <Samantha> is that ok : djahandarie
20:01:42 <Samantha> like this > addPairs [1, 2, 3] [4, 5, 6]
20:01:48 <Samantha> [5,7,9]
20:02:06 <Eduard_Munteanu> Samantha: see zipWith
20:02:11 <Samantha> ok
20:02:27 <monochrom> Andrew Gordon's tutorial on coinduction is at http://research.microsoft.com/en-us/um/people/adg/Publications/details.htm#fp94
20:03:29 <Eduard_Munteanu> :t zipWith
20:03:34 <Eduard_Munteanu> Nah, still dead.
20:03:43 <monochrom> the "take lemma" is first due to Bird and Wadler proved by denotation semantics and fixed points. Gordon proves it using coinduction and bisimulation.
20:05:43 <dolio> It does have a coinductive flavor.
20:06:37 <dolio> Inasmuch as "every prefix you can observe" is the same as "every observation you can make."
20:15:20 <dolio> The original question is a little open ended. How is map defined?
20:15:54 <dolio> If we consider a bifunctor F a b, and Mu (F a)...
20:16:31 <dolio> And we define map f = cata (in . bimap f id)
20:17:37 <dolio> Then map id = cata (in . bimap id id) = cata (in . id) = cata in = id, by the universal property of initial algebras.
20:17:50 <dolio> And in Haskell, that includes infinite lists.
20:18:16 <dolio> For lists F a b = [] | a:b
20:18:34 <djahandarie> :o I like when I can follow these things
20:20:32 <roconnor> I'm surprised the free monad approch to IO isn't in tackling the akward squad
20:20:41 <dolio> Heh: "In this thesis we work exclusively with comprehension categories to describe type dependency. Among the above alternatives, comprehension categories are in our opinion at the right level of generality and abstraction; ..."
20:20:57 <dolio> It also happens to be the one invented by the author of the thesis.
20:21:15 <dolio> What does it use?
20:21:56 <monochrom> A variation of the "take lemma" is still in Bird's intro FP book 2nd edition.
20:22:39 <monochrom> that book is still ahead of the time
20:23:51 <monochrom> you don't actually find any other undergrad textbook discussing ⊑ and ⊔ for more than several pages.
20:26:19 <winxordie> ...?
20:26:27 <winxordie> What's so special about subsets and unions?
20:27:07 <monochrom> not subsets and unions. partial order and least upper bound
20:27:12 <winxordie> oh!
20:27:37 <winxordie> I would like to contend that Munkres' Topology does give a good shot at both
20:27:57 <monochrom> I mean undergrad textbooks on FP
20:28:01 <winxordie> just that it considers posets as a special class of the T0 separability axiom
20:28:05 <winxordie> oh. hehe.
20:28:18 <dolio> Oh, I should say, the stuff on C-monoids and untyped lambda calculi was pretty interesting in Introduction to Higher Order Categorical Logic. I hadn't seen that before.
20:28:22 <dolio> Maybe I wasn't looking hard enough.
20:28:35 <monochrom> I am sure Davey and Priestley's book is an undergrad textbook on lattice theory and it discusses partial order and lub to death.
20:28:52 <monochrom> (and indeed I read it to death)
20:29:06 <monochrom> @quote monochrom krad
20:29:14 <monochrom> I miss lambdabot!
20:29:25 <dolio> preflex: be monochrom
20:29:25 <preflex>  Do not try to pronounce haskell code. You are not a modem.
20:29:28 <monochrom> anyway, that quote was my praise about Bird's book.
20:29:53 <monochrom> s/about/of/
20:29:56 <wlangstroth> it's like watching people play with a lightswitch in a power outage
20:31:07 <monochrom> every time I seriously read Bird's intro book again, I find one more thing not covered in any other haskell books. paradoxical, eh? you would think as time goes by, other haskell books should be successively improving approximations to Bird's. but no.
20:31:47 <dolio> I'm not sure why you'd expect that.
20:32:20 <monochrom> civilization advances and newer books dare to cover "more advanced" materials for newbies
20:32:22 <dolio> Haskell books are progressively targeting people who don't care about lattice theory.
20:32:59 <winxordie> aww, people should care about lattice theory
20:32:59 <monochrom> like the way books 500 years ago dare not talk about arithmetic, but all books do now.
20:33:42 <monochrom> I don't expect general lattice theory, no. just the fragment you need to get through strictness and nonstrictness.
20:34:09 <wlangstroth> ... like the way Euclid's Elements was improved upon year after year from 300bc
20:34:24 <dolio> Let me put it another way: they're targeting people who'd consider any discussion of lattice theory grounds for discontinuing their study of Haskell.
20:34:38 <cads> :)
20:35:12 <cads> what about those of us that have discontinued our studies of category theory to go off to things like lattices ;)
20:35:21 <monochrom> haha
20:35:32 <cads> err, I meant haskell, not category theory
20:35:50 <cads> heh, synonymous, to my mind
20:37:39 <roconnor> is the J monad a commutative monad?
20:38:05 <monochrom> and what about stack overflow and/or inefficiency of foldl (+)? Bird's book completely explains its problem and how do you write foldl' to work around it and why it works better.
20:38:43 <dolio> Sussman and Abelson explain that in the SICP lecures without any lattice theory.
20:38:55 <monochrom> do you now say, newer books target people who'd consider any discussion of efficiency and optimization ground for discontinuing?
20:39:16 <monochrom> Bird's book doesn't use lattice theory for that either.
20:39:21 <dolio> Of course, they don't explain how to fix it.
20:39:26 <dolio> They just say, "lazy evaluation sucks."
20:42:12 <monochrom> it only uses "outermost reduction" and "head normal form" and $! for that.
20:42:47 <monochrom> the section after that is on fusion and deforestation. the whole chapter is called "efficiency"
20:50:44 * hackagebot mathblog 0.2 - A program for creating and managing a  static, mathematically-inclined weblog  http://hackage.haskell.org/package/mathblog-0.2 (JonathanDaugherty)
20:52:31 <joe1> what happened to lambdabot?
20:52:37 <joe1> isn't it a daemon?
21:01:37 <anon2304> Hi. I need to pull the output of a shell command run from a Haskell script and place it in a string. The two functions in System.Cmd don't do this (they run the command, print the output and return and exit code)...which library have I missed?
21:04:25 <bens> anon2304: something in System.Process should do it
21:04:34 <monochrom> System.Process.readProcess may work nicely
21:07:12 <anon2304> bens: System.Process.readProcess did the trick.
21:07:15 <anon2304> monochrom: Yep. (-:
21:07:18 <anon2304> Thanks guys.
21:08:24 <bens> np :)
21:17:00 <anon2304> Sweet. I just re-wrote a stupid C program that I was heavily dependent upon in Haskell. System.Process.readProcess was the last piece of the puzzle I needed. That was fun! 
21:17:51 <anon2304> I learned Haskell a while ago for fun, never used, and just tonight decided to use it seriously. I'm rusty, but it's going smoothly for the most part.
21:18:03 <anon2304> *never used it
21:19:41 <monochrom> it is nice
21:23:46 <jamfade> hello, can I use a sequence such as .x. as an operator?
21:24:21 <Saizan> no, you can't use letters in operator names
21:24:55 <jamfade> so only non-alphanumerics?
21:25:36 <Saizan> yeah, everything that's considered a symbol by unicode, minus some reserved ones
21:26:08 <Saizan> and : at the start is reserved for data or type constructors
21:26:27 <jamfade> thank you, any docs I could read on the subject?
21:26:53 <Saizan> http://www.haskell.org/onlinereport/lexemes.html <- yep
21:26:53 <shachaf> jamfade: You can use .×. if you want.
21:27:39 <Saizan> look for  symbol
21:27:55 <jamfade> shachaf: I'm getting the following: Syntax error in input (unexpected symbol "x"
21:28:06 <jamfade> thank you Saizan
21:28:10 <solidus-river> i'm thinking of writing a game engine in haskell using sdl, are there any limitations of the library i should know about?
21:29:45 <deggis> regarding ^, i'm trying to make use of sdl-mixer togerther with opengl, but opengl mainloop seems to break music playing (that's the guess). any ideas about that?
21:38:10 <monochrom> @bot
21:42:55 <ivanm> does anyone know of a pretty-printer for bos' text library?
21:43:06 <ivanm> i.e. renders Text rather than String
21:47:32 <monochrom> there is probably none yet. Text is rather recent.
21:47:43 <ivanm> *nod*
21:48:08 <ivanm> where "sort of recent" == "18 months old" :p
21:48:24 <ivanm> OK, I might try converting wl-pprint to deal with Text values then
21:49:49 <monochrom> the time between appearance of seq and appearance of foldl' was of the order of years, if that's any consolation :)
21:50:17 <monochrom> and time from mapM_ to forM_, a decade
21:53:02 <ivanm> heh
21:53:05 <ivanm> fair enough
21:54:38 <monochrom> it is years between good idea proposed (even implemented) and appearing on hackage. it is just two days between bad idea proposed and appearing on hackage.
21:54:38 <ivanm> what would be a good module name for it? Text.PrettyPrint.Leijen.Text or something?
21:54:44 <ivanm> monochrom: lol
21:54:54 <ivanm> I'd @remember it but lambdabot seems to be on a break...
21:55:57 <c_wraith> I still feel like String is almost always the wrong type.  I'd really love to see a retrofit of...  everything...  To use either Text or ByteString, depending on whether it needs bytes or characters.
21:56:09 <monochrom> example: oleg's iteratees: years, probably a decade.  variadic function mess "because it makes sense for monoids": someone just had to ask it in haskell-cafe, two days later it's done on hackage. I was thoroughly horrified.
21:57:41 <monochrom> I would agree to Text.PrettyPrint.Leijen.Text but it is somewhat funny, with "Text" both at the beginning and at the end.
21:57:51 <Saizan> tbf, oleg already implemented variadic functions years ago :)
21:58:26 <Saizan> Data.Text.PrettyPrint ?
21:58:30 <ivanm> monochrom: yeah; the other alternative is Data.Text.Pretty or something
21:58:47 <ivanm> Saizan: "oleg implemented it" /= "in a form other people can understand and use" :p
21:58:55 <monochrom> pretty printers are conventionally under Text.PrettyPrint though
21:59:10 <c_wraith> Eh, Text.Printf has been around forever, and nearly everyone understands it.
21:59:23 <Jafet> You can't call a language mainstream until it has a built-in, standard, widely used, but highly inefficient data structure for representing strings.
21:59:39 <monochrom> what the heck, Text.PrettyPrint.Leijen.Text or Text.PrettyPrint.Leijen.Text16 or Text.PrettyPrint.Leijen.UTF16
21:59:40 <c_wraith> Jafet, so haskell was mainstream from the start? :)
21:59:42 <ivanm> monochrom: true
22:00:06 <ivanm> monochrom: wait, why bother with the encoding info?
22:00:21 <monochrom> I don't know.
22:00:31 <cads> monochrom, are you talking about some arbitrary-way monoidal composition, like  comp a_1 ... a_n = a_1 ++ ... ++ a_n?
22:00:50 <cads> where comp can take any number of arguments?
22:01:03 <monochrom> I don't know that either. I just saw the titles of two haskell-cafe threads. did not read content.
22:01:08 <Jafet> c_wraith: indeed, some languages are fated to become mainstream that way, like C
22:01:31 <monochrom> but I guess yes, I guess someone wants the scheme equivalent of (+ 3 1 4 1 5 9 2 6)
22:01:34 <Jafet> And look at tcl. Its strings are so efficient, they do everything in strings. Now is tcl mainstream!?
22:01:34 <c_wraith> Jafet, at least C's time-inefficient default strings are space efficient.  haskell's are neither!
22:01:52 <cads> monochrom, I don't think most people would treat those as monoids :)
22:02:06 <c_wraith> Myself, I'd ask what's wrong with lists.
22:02:15 <cads> c_wraith, y'know?
22:03:46 <cads> hehe, whoops, I read up, you're commenting in a different thread :)
22:03:50 <ivanm> c_wraith: isn't it more that people are abusing them than there being anything wrong with lists per se?
22:04:11 <c_wraith> cads, yes, and I'm not being very clear about it.  My mistake.
22:09:35 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/81390/ and http://thread.gmane.org/gmane.comp.lang.haskell.cafe/81983
22:09:47 <monochrom> try not to read that until halloween
22:17:41 <ivanm> monochrom: would Text.PrettyPrint.Text suffice or should I keep the .Leijen in there to keep the emphasis of which kind of pretty printer is being used?
22:29:42 <cads> monochrom, that's a laugh :)
22:32:11 <Saizan> the injection makes it more reasonable
22:34:36 <ivanm> injection? is someone getting vaccinated or something?
22:36:14 <Saizan> yeah, monoids tend to get sick easily
22:37:43 <cads> hah Saizan for a moment I feared there was a mathematical concept of sickness
22:38:19 <cads> like eugenia cheng's notion of mathematical morality
22:39:43 <ivanm> there's a mathematical notion of morality? :o
22:46:55 <tehgeekmeister> is there a simple way to have cabal build two executables (i.e.: two main modules)?  i have some utilities i'd like to rebuild along with my app.
22:47:56 <Saizan> tehgeekmeister: you can have multiple executable stanzas
22:48:18 <tehgeekmeister> where do i learn about these executable stanzas?
22:49:01 <ivanm> tehgeekmeister: look at how other .cabal files have them
22:49:15 <Saizan> they are those "Executable foo\n   ..." you write in the .cabal file to make cabal build an exe
22:49:34 <tehgeekmeister> see, i've never touched a cabal file except to tweak dependencies
22:49:37 <cads> ivanm, http://mathoverflow.net/questions/14849/what-would-a-moral-proof-of-the-weil-conjectures-require
22:49:38 <tehgeekmeister> but i'll start poking at them i guess
22:49:48 <tehgeekmeister> oh!
22:49:50 <Saizan> http://hackage.haskell.org/packages/archive/HaXml/1.20.2/HaXml.cabal  <- e.g.
22:49:54 <tehgeekmeister> my cabal file has one of those already.
22:49:55 <tehgeekmeister> huh.
22:50:02 <tehgeekmeister> snap is teaching me things.
22:50:21 <ivanm> cads: ahh, a "good/elegant/etc." proof
22:50:24 <cads> ivanm, the author of the second highest ranked response quotes a very interesting passage, imo.
22:52:19 <cads> Cheng says that it is different than elegance. In my opinion, an elegant proof might rely on some elegant trick from another topic, which feels immoral in that context.
22:53:59 <cads> What feels moral to do in a given context probably depends greatly on the mathematician. But I'm also sure that many mathematicians would reject the idea that any kind of morality is at play when doing math.
22:56:24 <dbelange> Would it be moral to kill one elegant proof for the sake of ten ugly proofs?
22:57:59 <Saizan> well, it's an argument against clever hacks, which seems more justified in software engeneerings than proofs, unless maths is starting to be concerned about maintainability lately :)
22:58:17 <cads> Hah, there are apparently theorems that have a collection of immoral proofs. People are still glad, the more the merrier.
22:59:11 <cads> I wonder if ZFC is the java of math.
23:00:12 <cads> Saizan, that maintainability thing made me laugh.
23:00:39 <Saizan> heh, i'm glad :)
23:00:56 <cads> A moral proof usually does give more insight into working related things.
23:02:00 <cads> If you have to combine everything under the sun in some strange ad-hoc way to barely squeak out a proof, it's possible that having the proof won't get you many results
23:02:47 <Saizan> true
23:03:18 <Saizan> maybe if you formalize it you'll discover some structure though
23:04:12 <cads> hehe you may discover it has moral undertones
23:07:49 <Saizan> also, maybe such theorems are like NP-complete problems, they are just ugly :)
23:29:17 <path[l]> man why are universities making haskell a requirement for a cs degree
23:31:44 <tehgeekmeister> @pl \xs -> headMay >>= headMay
23:31:45 <kmc> maybe they want you to learn to think in more than one way
23:32:04 <tehgeekmeister> @pf \xs -> headMay >>= headMay
23:32:24 <kmc> @bot
23:32:39 <kmc> Cale, our lambdabot has vanished :/
23:32:45 <tehgeekmeister> baaaaaaaaah
23:32:53 <tehgeekmeister> anyone know the answer to that question?
23:33:02 <tehgeekmeister> i figure that's prolly a common idioum
23:33:19 <kmc> you aren't using xs on the rhs
23:33:27 <path[l]> someone found me on twitter and tried to pay me to help her pass an exam. Saying she doesnt need to learn it to work but she has failed the class once and she's afraid to fail it again
23:33:31 <Samantha> I have a question
23:33:34 <Samantha> hi
23:33:37 <path[l]> oh heh
23:33:37 <kmc> «\x -> f x x» is «join f»
23:33:42 <kmc> join in the ((->) r) monad
23:33:43 <path[l]> hi Jessica
23:33:55 <tehgeekmeister> \xs -> headMay xs >>= headMay
23:33:57 <tehgeekmeister> sorry
23:34:02 <kmc> hmm
23:34:07 <systemfault> path[l]: Let her fail.
23:34:15 <Samantha> who is path?
23:34:25 <path[l]> Im the person you were emailing
23:34:42 <Samantha> i tought you were working
23:34:43 <Samantha> ?
23:34:53 <path[l]> yeah Im heading off to work
23:34:57 <path[l]> bye
23:34:58 <Samantha> oh ok
23:35:05 <Samantha> Dont say my name here
23:35:17 <systemfault> path[l]: She had to understand that her boobs alone are not enough and that she needs to work to get what she wants.
23:35:25 <path[l]> fine, Im sorry about that
23:35:31 <kmc> oh dear
23:35:42 <Samantha> what
23:35:50 <Samantha> Why are you offending me
23:35:56 <Samantha> that is not nice at all
23:35:56 <tehgeekmeister> kmc: not sure how that relates
23:36:15 <kmc> tehgeekmeister, what you had before was «(>>=) headMay headMay».  except that's not what you wanted anyway
23:36:45 <kmc> :t foldr (>=>) return
23:37:01 <c_wraith> :t ?x >>= ?x
23:37:03 <tehgeekmeister> i want the equivalent of throwing >>= into a string of compositions, really
23:37:07 <c_wraith> right, missing bot
23:37:09 <kmc> right
23:37:17 <tehgeekmeister> or =<<
23:37:23 <kmc> foldr (>=>) return :: (Monad m) => [c -> m c] -> c -> m c
23:37:51 <kmc> now, i wonder if there's an «instance (Monad m) ⇒ Monoid (Kleisli m a a)»
23:38:00 <kmc> using that would be dubious anyway
23:38:07 <kmc> @hoogle [c -> m c] -> c -> m c
23:38:09 <kmc> grrr
23:38:16 <cads> path[l], solution is to negotiate the price up and then do it.
23:38:21 <cads> you need the money, don't you?
23:38:27 <mjrosenb> kmc: takes a list of functions and an input value and repeatedly applies the function, unpacks the monad?
23:38:42 <cads> systemfault, nothing to do with boobs at all
23:38:52 <systemfault> path[l]: Just give her that link: http://learnyouahaskell.com/ and tell her good luck
23:39:14 <tehgeekmeister> ah, >=> and <=< are just what i want.
23:39:28 <kmc> yeah
23:39:40 <cads> systemfault, it seems like she's just asking him to tutor her.. and in the worst case to do some of her work or something
23:39:58 <cads> the guy stands to make some cash, and the girl will fail the exam, anyways.
23:40:15 <systemfault> cads: Tutor? I read that she wants him to do the whole thing for her as she supposely doesn't need to know.
23:40:37 <Samantha> oh man
23:41:19 <cads> well, he also said she's asking for help to pass an exam. Perhaps she wants help cramming and doesn't care if she'll really learn it.
23:41:20 <kmc> if you absolutely can't learn Haskell, you should not be programming professionally
23:41:27 <mjrosenb> afiact, Samantha has been here for the last 3 days attempting to get someone to write 3 lines of code for her.
23:41:28 <kmc> not because Haskell is so great, but because it indicates you can only think in one way
23:41:38 <Samantha> What a personal conversation means = spread out  or personal 
23:41:51 <mjrosenb> kmc: although if you only know assembly and prolog, you should be pretty good.
23:41:54 <kmc> now, most people who "can't learn Haskell" are really just expecting it to take two days to learn, get frustrated, and quit
23:42:21 <kmc> it's supposed to be hard
23:42:24 <systemfault> Learning haskell is enlightening.
23:42:42 <systemfault> Even more when everything you written is C/C++/Java/C#
23:42:49 <cads> systemfault, so's paying your way past BS
23:42:57 <kmc> Samantha, did you try posting your question on Stack Overflow?
23:43:12 <Samantha> enough 
23:43:21 <Samantha> this is not nice
23:43:36 <Samantha> you guys are making fun of mw
23:43:40 <Samantha> fun of me
23:43:43 <kmc> Samantha, http://stackoverflow.com
23:43:50 <kmc> nice site
23:43:52 <Samantha> only because you guys know Haskell
23:43:56 <Samantha> so good 
23:44:11 <systemfault> Samantha: I only know the basics and I actually suck at haskell.
23:44:12 <cads> Samantha, do you have to learn haskell for a class?
23:44:18 <Samantha> then enjoy your intellegence
23:44:19 <kmc> Samantha, we see dozens of beginners every day
23:44:27 <Samantha> and make fun of people 
23:44:30 <kmc> most of them arrive, politely ask a question, get several answers immediately, and leave happy
23:44:33 <Samantha> who doesnt know
23:45:21 <Samantha> I am sure I  know some stuff that you guys dont have any idea and I will not make fun of that person that is no polite at all
23:45:57 <tehgeekmeister> Samantha: they're right, stack overflow is probably a good place to ask a question; the irc channel is hit and miss, sometimes there is someone who can help you online, sometimes there isn't.
23:46:14 <Samantha> And what I talk to VISHNU 
23:46:19 <cads> Samantha, I'd like to help ya if you'd just make sense to me
23:46:22 <Samantha> it was one to one 
23:46:32 <kmc> Samantha, perhaps it's your attitude or the way that you're phrasing your question
23:46:34 <Samantha> no public thing
23:46:40 <kmc> since, as i said, dozens of beginners every day have a positive experience here
23:46:43 <Samantha> but is ok
23:46:47 <kmc> and you can check the public logs if you don't believe me
23:47:02 <systemfault> Samantha: The haskell community is generally very friendly.
23:47:09 <Samantha> I know now that people is fake
23:47:14 <mjrosenb> Samantha: i have offered to help, but you keep speaking in something that isn't quite english.
23:47:19 <systemfault> Samantha: Try the C community if you want to see the opposite.
23:47:28 <tehgeekmeister> oh dear.  c.
23:47:38 <mjrosenb> try talking to zhivago
23:47:44 <mjrosenb> ask him why c is dumb...
23:47:47 <mjrosenb> that should be good.
23:47:52 <kmc> "the C community" is a funny term.  like all the people in the world who use C get together and talk
23:48:03 <cads> Samantha, where are you from?
23:48:11 <systemfault> kmc: Well.. in general, some of them are nice people.
23:48:20 <mjrosenb> kmc: to be fair, i usually just go in to ##c to watch the fireworks.
23:48:24 <kmc> hehe
23:48:32 <systemfault> kmc: But evil operators like Zhivago is giving that channel a very bad name.
23:49:44 * kmc agrees with the statement "c is dumb"
23:49:59 <kmc> not that using c is dumb
23:50:03 <kmc> but that it's a simple low-level language
23:50:31 <kmc> and this is to its advantage, in the domains where it is appropriate to use
23:50:34 <kmc> C++ tries to be smart and fails
23:50:50 <kmc> for languages, "dumb" is much more useful than "smart and crazy"
23:51:37 <systemfault> Well, C++, the way it was invented wasn't crazy
23:51:56 <systemfault> It became that way when people started to do experiences with templates.
23:52:07 <mjrosenb> c++ tries to be a swiss army knife with every possible tool, but actually has 30 knives that call themselves screwdrivers.
23:52:23 <systemfault> And found that with some extra work, templates could do a lot more than they were supposed to.
23:52:27 <boscop> lmao http://twitter.com/ghewgill/status/25051171050
23:52:44 <kmc> haha
23:52:48 <systemfault> :P
23:52:51 <systemfault> Not a bad one :)
23:52:57 <kmc> that's how many people write their whole resume
23:53:02 <systemfault> Hahaha
23:53:04 <systemfault> So true.
23:54:18 <kmc> systemfault, there's a lot more insanity in C++ than just templates
23:54:37 <kmc> you can start here: http://yosefk.com/c++fqa/defective.html
23:55:08 <kmc> incredibly complicated rules for automatic type conversion and type-directed name resolution
23:55:18 <kmc> are a good example of trying to be too clever
23:55:20 <Maxdamantus> Does evaluating one variable defined on the left of a = force evaluation of all variables defined on the left side of that =?
23:55:26 <tehgeekmeister> hpaste.org/40731
23:55:34 <Maxdamantus> > let (a, b) = (42, undefined) in a
23:55:34 <kmc> you can't use a language that second-guesses you
23:55:37 <tehgeekmeister> http://hpaste.org/40731
23:55:46 <kmc> Maxdamantus, that succeeds
23:55:53 <Maxdamantus> Oh
23:56:10 <Maxdamantus> > let (a, (b, c)) = (42, undefined) in a
23:56:10 <systemfault> kmc: I hate the fqa
23:56:12 <Maxdamantus> That doesn'tp
23:56:34 <systemfault> kmc: That website could have been a wonderful and realistic critique of C++...
23:56:35 <Maxdamantus> Hm
23:56:45 <kmc> Maxdamantus, let (a, ~(b, c)) = (42, undefined) in a
23:56:58 <kmc> the irrefutibility of a "let" pattern is only on the outermost layer, apparently
23:57:18 <tehgeekmeister> how do i nest that use of the maybe monad inside the io monad bit?
23:57:35 <systemfault> kmc: But the guy, I guess he didn't have enough content, filled it with a lot of lies and irrelevant stuff.
23:57:59 <tehgeekmeister> quickQuery conn getMaxVersionIdForTextSql [toSql 1] >>= (\xs -> maybe print "empty list" (print . fromSql) (headMay xs >>= headMay)) -- <== that's the line in quesiton
23:58:21 <kmc> that's a big effing line
23:58:46 <tehgeekmeister> i'm just trying to figure something out real quick, that is *not* how the code will stay
23:58:51 <kmc> (\xs -> maybe print "empty list" (print . fromSql) (headMay xs >>= headMay))
23:58:56 <kmc> i don't understand how that's supposed to work
23:59:11 <tehgeekmeister> takes a list of lists
23:59:15 <tehgeekmeister> (xs)
23:59:42 <tehgeekmeister> runs it through headMay, which returns Just x (which is a list)
23:59:54 <tehgeekmeister> which is then passed to the second call of headMay, which should also return a Just
