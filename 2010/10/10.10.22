00:00:08 <merijn> How would drag and drop haskell even work?
00:01:02 <mjrosenb> how would drag and drop any language work?
00:01:25 <zubayr> i mean for building interface and classes
00:01:38 <merijn> zubayr: No such thing in haskell...
00:02:00 <zubayr> k
00:02:16 * mjrosenb refuses to believe there is any situation where that is fster than ust writing it out.
00:02:35 <zubayr> like for java we have netbeans
00:02:38 <merijn> mjrosenb: You underestimate Java programmers ability to needlessly obfuscate constructions
00:02:54 <zubayr> and for dotnet there is visual studio
00:03:41 <merijn> zubayr: The preferred method is to make your data structures so simple that drag and drop interface are too much work
00:03:58 <zubayr> k
00:04:15 <zubayr> i m neew to haskell so dont have much experience of it
00:04:23 <zubayr> thanks for all the knowledge and advice
00:04:44 <zubayr> haskell is being taught as a module for our engineering curicullum
00:04:54 <mjrosenb> engineering?
00:04:57 <mjrosenb> interesting
00:05:07 <mjrosenb> we just learend verilog and matlab
00:05:18 <mtnviewmark> zubayr - how much Haskell coding have you done?
00:05:24 <mtnviewmark> and what environment did you do it in?
00:05:29 <zubayr> winhugs
00:05:31 <mtnviewmark> (as in compiler, etc...)
00:05:39 <zubayr> winhugs
00:05:53 <mtnviewmark> and your first assignment is a banking application?
00:06:46 <mjrosenb> hugs... fun
00:07:22 <mtnviewmark> presumably you should have been exposed to some simple coding Haskell, and would have seen that Haskell code doesn't have interfaces or classes in the sense that Java does, nor do you code files that way
00:09:04 <zubayr_> m back guys
00:09:12 <zubayr_> sorry had to refresh the page
00:09:19 <zubayr_> so wat i was telling is
00:09:25 <zubayr_> m completely new to haskell
00:09:47 <zubayr_> n all the while it was being taught in classroom i was busy in something else
00:09:47 <zubayr_> :P
00:10:01 <zubayr_> so facing hige prooblems coz of that
00:11:06 * mjrosenb recommends going to classes
00:11:28 <mjrosenb> or at least staying  on irc so people can help you
00:15:31 <Silvah> Hi guys.
00:19:35 <dufflebunk> Hello Silvah 
00:20:44 <mtnviewmark> ah - well, you can't extrapolate from java or other languages to Haskell
00:21:05 <mtnviewmark> it isn't like trying to code Python or Ruby if all you know is Java --- you can get away with that 
00:21:44 <mtnviewmark> Haskell is a totally different paradigm of writing code, and you'll need to take the time to learn how it is structured
00:21:49 <Silvah> I wonder when was the last time I've been (relatively) active here...
00:21:53 <guest2424> hello
00:22:08 <guest2424> does someones knows how to  do bubble sort
00:22:10 <guest2424> ?
00:22:19 <mtnviewmark> zubayr_: start here: http://learnyouahaskell.com/
00:22:32 <guest2424> ok
00:22:51 <Silvah> Bubble sort?
00:22:53 <dufflebunk> O_o
00:22:57 <guest2424> Yeah
00:22:58 <Silvah> Why do you need that?
00:23:01 <guest2424> like this 
00:23:14 <mtnviewmark> or here: http://book.realworldhaskell.org/
00:23:32 <guest2424> bubble [4, 3, 2, 7, 5, 8, 1] = [1,2,3,4,5,7,8]
00:23:51 <mtnviewmark> you will probably need to read through at least the first 10 chapters of either (or both) before you can write the Banking application
00:24:31 <guest2424> what is a Banking application?
00:24:34 <Silvah> But... bubble sort...?
00:24:44 <guest2424> or any name 
00:24:45 <zomg> guest2424: bubble = sort and then it should work :D
00:24:54 <zomg> oh, you'll need to import Data.List for sort though
00:24:55 <zomg> =)
00:25:15 <Silvah> :D
00:25:15 <mtnviewmark> guest2424: is this homework?
00:25:23 <guest2424> I wish
00:26:17 <mtnviewmark> then don't do bubble sort
00:26:37 <guest2424> then what else I can do?
00:26:49 <Silvah> Use Data.List.sort.
00:26:49 <mtnviewmark> bubble sort is an algorithm that makes sense for computation environments where you have fixed memory and mutatable arrays
00:27:01 <guest2424> OMG
00:27:05 <mtnviewmark> > sort "now I am a noodle"
00:27:10 <Silvah> mutable*
00:27:24 * dufflebunk had to use a bubble sort recently, but that was because of a non-transitive comparison
00:27:30 <mtnviewmark> where or where is lambda bot?
00:28:03 <Silvah> She's down. Again.
00:28:48 <nlogax> > "you can use this one" -- until lambdabot returns. please tell me so i can remove it later
00:28:51 <hsbot>   "you can use this one"
00:29:03 <mtnviewmark> > sort "now I am a noodle"
00:29:03 <hsbot>   " Iaadelmnnooow"
00:29:17 <mtnviewmark> > sort [4, 3, 2, 7, 5, 8, 1] 
00:29:17 <hsbot>   [1,2,3,4,5,7,8]
00:29:25 <guest2424> yeah I got it
00:29:36 <guest2424> i didnt import Data.list
00:29:37 <mtnviewmark> lovely! works on all Ord a => [a]
00:29:39 <mtnviewmark> :t sort
00:29:50 <guest2424> that why I was getting an error message
00:29:53 <guest2424> thank you 
00:29:55 <guest2424> all
00:29:59 <Silvah> :t doesn't work.
00:30:00 <nlogax> .type sort
00:30:01 <hsbot> (Ord a) => [a] -> [a]
00:30:07 <nlogax> sorry, it's not an actual lambdabot
00:30:07 <mtnviewmark> night all
00:30:11 <nlogax> gn
00:30:15 <mtnviewmark> haha!
00:30:19 <Silvah> g'night
00:31:21 <Silvah> GHC 7...?
00:31:27 <guest2424> huh
00:31:53 <Nibble> HUHUHUHUHUHUH
00:32:00 <guest2424> hahaha
00:32:32 <silver> Silvah, sure
00:34:47 <Silvah> Ah, it's that thing formerly called GHC 6.14...
00:36:18 <silver> erm, not sure, probably it will be ghc 8 when released
00:38:01 <Silvah> Are the changes really so significant?
00:38:25 <kmc> we have silver and Silvah
00:38:28 <kmc> this could get confusing
00:39:04 <silver> Silvah, http://vimeo.com/15467880
00:40:17 <Silvah> Thanks.
00:47:29 <Silvah> kmc: how could it get confusing?
00:47:48 <Silvah> > "Silvah" == "silver"
00:47:49 <hsbot>   False
00:48:10 <silver> heh
00:48:19 <Silvah> So it can't. ;)
00:48:50 <silver> > compare "Silvah" "silver"
00:48:51 <hsbot>   LT
00:48:54 <silver> woo!
00:50:23 <Silvah> heh
00:50:55 <Silvah> > randomRIO (0, 1)
00:50:56 <hsbot>   No instance for (GHC.Show.Show (GHC.Types.IO t)) arising from a use of `M1216496478.show_M1216496478' at <interactive>:(2,0)-(4,32) Possible fix: add an instance declaration for (GHC.Show.Show (G...
00:51:22 <Silvah> > unsafePerformIO (return 4)
00:51:23 <hsbot>   Not in scope: `unsafePerformIO'
00:51:28 <Silvah> :(
01:03:20 <nimred> hello all. anybody here running ghc on NetBSD amd64 ?
01:29:48 <turiya> hi
01:30:04 <turiya> :i surfaceGetPixels
01:30:49 <turiya> shows the type as Surface -> IO Graphics.UI.SDL.Types.Pixels
01:31:17 <turiya> but there is no information is obtained for :i Pixels
01:31:48 <turiya> does anyone know whats going on?
01:34:19 <mrdk> why would something like "files <- map (\f -> joinPath [path, f]) (getDirectoryContents path)" not work?
01:36:16 <dschoepe> mrdk: because (getDirectoryContents path) has type IO [String], while map expects a [String]. Also, if you use <-, the expression on the right-hand side has to return a monadic value
01:37:03 <dschoepe> you need to lift map using fmap to get around that: files <- map (\f -> joinPath [path,f]) `fmap` getDirectoryContents path
01:38:08 <mrdk> dschoepe: oh I see. Thanks for the nice explanation!
01:38:27 <kmc> or: files <- getDirectoryContents path; return (map (\f -> joinPath [path,f]) files)
01:40:14 <mrdk> kmc: right, works too
01:41:25 <mrdk> however, I still get an error because the expected type for (getDirectoryContents path) should be "IO FilePath". How's that possible?
01:41:37 <mrdk> these would be of type char, not [char]
01:43:42 <kmc> getDirectoryContents :: FilePath -> IO [FilePath]
01:44:05 <kmc> can you hpaste the actual code and error?
01:48:22 <mrdk> kmc: here you go: http://hpaste.org/40756/foo
01:51:41 <kmc> it's "expected" from the other direction
01:51:46 <kmc> probably has to do with the type of joinPath
01:54:49 <mrdk> kmc: hmm actually I could just do something like p ++ "/" ++ f
01:57:18 <altmattr> I am trying to stop SYB from traversing into strings and I am hoping to avoid writing a custom instance for Data (those type signatures are a little intimidating) - any ideas?
02:04:59 <dreixel> altmattr: use extQ/T and give a custom behavior on Strings
02:05:36 <Maxdamantus> Not directly related to Haskell, but can anyone think of like, a simple, unified system for pattern matching which works both in case expressions, and like fully lazy matching for = expressions (dunno what to call them) in Haskell
02:05:51 <altmattr> ah! I just add an extra extT
02:05:58 <altmattr> thanks - I will try that
02:06:10 <Maxdamantus> lazy matching as in: (a, (b, c)) = foo would look something like (a, ~(b, c)) = foo, in Haskell
02:06:40 <Davsebamse> Hi. I have a function that I want to call. See paste here: http://hpaste.org/40757/davse i want to call the printBoard, but it seems that readIORef returns a IO a instead of a board. How to call it function correctly?
02:09:03 <Maxdamantus> It could be implemented so there are two separate systems for the case matching and the other one, where with = it will just redefine each of a, b, c in terms of foo ((a, b, c) = (fst foo, fst $ snd foo, snd $ snd foo)) and the other will traverse the pattern tree applying what's meant to be matched.
02:16:13 <quicksilver> Davsebamse: you mean where you are currently using 'print' ?
02:16:38 <Davsebamse> quicksilver: yes
02:16:44 <quicksilver> Davsebamse: readIORef board >>= (putStrLn . printBoard) 
02:16:45 <quicksilver> should work.
02:16:58 <Davsebamse> ahh great i will try that
02:17:18 <quicksilver> the different between 'print' and 'printBoard' is that print actually does the printing to screen part, your 'printBoard' only converts to string.
02:17:43 <quicksilver> "print :: Board -> IO ()" while "printBoard :: Board -> String"
02:17:59 <quicksilver> so you need to combine it with putStrLn or putStr
02:18:03 <quicksilver> to actually output it.
02:18:10 <Davsebamse> quicksilver: yes,. great that worked :-)
02:18:16 <quicksilver> good :)
02:18:29 <Davsebamse> and yes.. i should remember to look more into that.. and that . operator
02:19:26 <altmattr> dreixel: doesn't work since it doesn't actually stop the traversal inside (using everywhere).  It gets to the string, pays attention to my function (id) then moves right on insides to find the chars
02:19:44 <Davsebamse> thanks a lot quicksilver !
02:21:23 <kmc> @src (.)
02:21:29 <kmc> hmm
02:21:33 <kmc> (f . g) x = f (g x)
02:21:47 <kmc> Davsebamse ^^^^
02:22:59 <Davsebamse> :-)
02:23:14 <Davsebamse> thanks
02:26:19 <dreixel> altmattr: it should work. Can you post your code for me to have a look?
02:28:39 <altmattr> dreixel: http://hpaste.org/40758/syb
02:38:32 <guest2512> hello
02:39:08 <guest2512> where is everybody??
02:39:47 <Maxdamantus> Hiding from my question.
02:43:20 <dreixel> altmattr: oh I see. this is problematic
02:44:48 <dreixel> altmattr: I think redefining everywhere might work...
02:49:11 <altmattr> dreixel: I am sure I read a blog post about this, but I can't find it anywhere
02:50:33 <dreixel> altmattr: b) in http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/syb-utils/README ?
02:53:27 <alios> after switching to head version of ghc, I have a problem with ghci. when I load a module to ghci I get a error "Could not find module 'Data.Binary'Get" ... compiling using cabal works... the binary package is installed as part of ghc. Are there any module loading related changes vom 6.12.x to 7.1.HEAD
02:53:32 <alios> ?
02:54:44 <dreixel> alios: as far as I know, binary doesn't come with ghc 7
02:57:53 <alios> dreixel: mmm ghc-pkg list shows: /opt/ghc-head/lib/ghc-7.1.20101020/package.conf.d \n\n [...
02:58:07 <alios>  binary-0.5.0.2
02:58:16 <altmattr> dreixel: I see, and I have looked at the code, but I just can't put my finder on the bit that will help me :(
02:58:26 <dreixel> alios: here it says (ghc-binary-0.5.0.2)
02:58:32 <alios> and as i set compiling it with cabal (with binary as dep) works
03:01:17 <alios> ahhh got ... for some reason it was hidden ... used ghc-pkg expose and now it works
03:03:09 <dreixel> altmattr: the easiest way might really be to give an instance Data String (with OverlappingInstances)
03:03:53 <altmattr> I got it working with everywhereBut (I think)
03:04:26 <dreixel> altmattr: oh how cool
03:04:34 <dreixel> that should be what you want, actally.
03:04:36 <dreixel> *actually
03:04:48 <dreixel> because it stops the traversal
03:05:18 <altmattr> dreixel: http://hpaste.org/40759/syb_again
03:05:53 <altmattr> dreixel: I had been trying the Data String and made it as far as GHC telling me I had overlapping instances before I thought of everywhereBut
03:07:35 <dreixel> altmattr: I definitely think everywhereBut is a better solution, I overlooked this
03:07:48 <altmattr> so I am in good company then :)
03:07:57 <altmattr> dreixel: thanks for the help
03:08:21 <dreixel> altmattr: it wasn't much, actually, thanks for helping realize the importance of everywhereBut ;-)
03:08:25 <quicksilver> I vaguely think examples like this are why Data is a bad idea
03:08:49 <quicksilver> it's an abstraction error to worry about how the internals of complex types are implemented
03:08:57 <dreixel> hopefully there will be a good alternative soon, also well connected to GHC...
03:09:19 <quicksilver> bad instances don't help
03:09:24 <altmattr> quicksilver: it is difficult to do otherwise when  your functions are type directed
03:09:36 <quicksilver> altmattr: I know. I don't have a clear alternative
03:09:44 <quicksilver> I'm just not sure it's a composable technique
03:10:04 <quicksilver> I remember a discussion when people wanted to add the 'wrong' instance of Data for Fixed + Complex
03:10:05 <altmattr> quicksilver: I think your vague feeling is shared by all the people who wrote their own generic library
03:10:09 <quicksilver> they didn't appear to see my point.
03:10:18 <altmattr> :)
03:14:18 <altmattr> dreixel: on the topic of alternative data-type generic libs.... what is the current front-runner to be "a good alternative soon, also well connected to GHC"
03:15:06 <quicksilver> dreixel is working on a secret project ;)
03:15:39 <quicksilver> (or maybe it's not really secret)
03:16:50 <dreixel> oh it isn't secret
03:17:09 <dreixel> but I'm not sure it solves the issue quicksilver's bringing up
03:17:20 <dreixel> though I'm also not sure what that issue is
03:17:34 <dreixel> as I see it, syb lacks a proper way to give adhoc cases for certain types for certain generic functions
03:17:41 <dreixel> other libraries do not have this problem
03:18:03 <dreixel> like the one we implemented in UHC: http://dreixel.net/research/pdf/gdmh.pdf
03:18:07 <dreixel> which I'm now implementing in GHC
03:19:45 <deggis> hip. anyone got ideas on howto keep music playing with SDL-mixer when program uses OpenGL mainloop? seems that sdl can't update its routines when using OpenGL and plays only first buffer length or so
03:40:09 <quicksilver> deggis: opengl doesn't have a mainloop
03:40:14 <quicksilver> deggis: whose mainloop are you using?
03:41:30 <deggis> quicksilver: umm :) (i'm a bit noob) the code makes use of GPipe, but the mainLoop is from GLUT
03:42:35 <quicksilver> deggis: OK. GLUT != openGL
03:43:05 <quicksilver> I would have thought it was a bad idea to use GLUT's mainloop with SDL_mixer - does gpipe force you to use glut?
03:44:06 <deggis> i'm not sure about that, have to check later
03:44:38 <quicksilver> failing that you probably have to call some sdl-mixer call in a glut timer func 
03:44:44 <quicksilver> to keep the audio buffer full
03:44:46 <deggis> from the problem's point of view it's promising that combination sounds like a bad idea (the failure was a total mystery for some time)
03:45:57 <deggis> that's an option too
03:46:33 <quicksilver> I had a quick glance over sdl-mixer's docs but they don't make it clear to me
03:57:13 * hackagebot flower 0.6 - Analyze 454 flowgrams (.SFF files)  http://hackage.haskell.org/package/flower-0.6 (KetilMalde)
03:58:02 <ketil> Whee!
03:58:58 <deggis> quicksilver: got the pointers towards solving i asked for, thanks
04:11:32 <ibt> morn
05:05:10 <Twey> 1070483285
05:06:32 <Twey> Err, sorry.
05:06:45 <Twey> PuTTY.  :-\
05:06:47 <quicksilver> 5 * 17 * 12593921
05:08:46 <Twey> Is that prime?
05:09:25 <quicksilver> 12593921?
05:09:27 <quicksilver> of course.
05:09:32 <quicksilver> it's one of my favourite primes.
05:09:36 <quicksilver> well, it's not in the top 10.
05:09:45 <quicksilver> But definitely somewhere in the top 50.
05:10:59 <Twey> Nice.
05:11:09 <quicksilver> I like the way it is so nearly palindromic, but is not.
05:14:57 <nlogax> quicksilver: you might enjoy this http://twitter.com/falindromes
05:17:32 <quicksilver> :)
05:43:45 <fryguybob> @botsnack
05:43:52 <fryguybob> :(
05:44:32 <tibbe> @seen dcoutts
05:44:32 <preflex>  dcoutts was last seen on #ghc 2 days, 35 minutes and 3 seconds ago, saying: only ./setup build
05:45:33 <tibbe> @tell dcoutts Could I have an account on sparky? I'd like to debug an I/O manager issue: http://hackage.haskell.org/trac/ghc/ticket/4348
05:45:42 <tibbe> preflex, wake up!
05:53:23 <BorisL> hi all! When I try to print a symbol 'e^' with putChar '\234', I receive an error " hPutChar: invalid argument (character is not in the code page)"
06:03:23 <xplat> BorisL: your default encoding is set to something that doesn't include the character U+9c, which btw is a control character
06:04:01 <quicksilver> BorisL: 234 is not the unicode char for e^
06:04:15 <quicksilver> in fact, as xplat points out, it's not really the unicode char for anything
06:04:30 <quicksilver> 128-255 is essentially useless in unicode.
06:06:24 <quicksilver> erm 128-160, rather.
06:06:35 <quicksilver> > 0xea
06:06:36 <hsbot>   234
06:06:49 <quicksilver> > 0x9c
06:06:50 <hsbot>   156
06:06:52 * quicksilver looks confused.
06:07:02 <quicksilver> > chr 234
06:07:03 <hsbot>   '\234'
06:07:11 <quicksilver> no, actually, BorisL was right all along
06:07:20 <quicksilver> unicode 234 *is* e^
06:07:33 <quicksilver> then I can only conclude your windows codepage doesn't have that hcaratecer
06:08:13 <dr460neye> hi there
06:09:13 <dr460neye> is there someone who can answer me a little newbie question ? :)
06:10:13 <osaunders> If I have «data Coord = Int Int» how do I generate arbitrary Coords with QuickCheck?
06:10:50 <quicksilver> write an Arbitrary instance for Coord, osaunders 
06:10:55 <quicksilver> dr460neye: yes, just ask :)
06:12:43 <dr460neye> i created an hs file.  all functions are working, but i get an error if i try to call a self made function
06:12:59 <fasta> osaunders, no, you don't ;)
06:13:00 <ksf> http://mozillalabs.com/chromeless/2010/10/21/chromeless-build-your-own-browser-ui-using-html-css-js/
06:13:16 <ksf> js compiler backend, anyone? 
06:13:17 <dr460neye> howManyEqual' a b c = if (allequal a b c) then 3 else 0
06:13:18 <quicksilver> dr460neye: what error?
06:13:24 <dr460neye> not in scope
06:13:35 <ksf> I think such a beast would be mindboggingly useful for a doc browser
06:13:45 <quicksilver> dr460neye: can you paste the whole file to http://hpaste.org/ ?
06:13:51 <quicksilver> dr460neye: (and the error, preferably)
06:13:52 <dr460neye> sure
06:14:02 <ksf> ...that integrates local stuff, hackage etc. into one tree and search.
06:15:02 <osaunders> quicksilver: Yeah, but I don't see how. «arbitrary = Coord arbitrary arbitrary» is obviously a type error because arbitrary gives a Gen a.
06:15:11 <osaunders> fasta: Huh?
06:15:35 <fasta> osaunders, you had a bug in what you wrote, nothing more. 
06:15:49 <osaunders> fasta: Oh yeah.
06:15:51 <quicksilver> osaunders: arbitrary = Coord <$> arbitrary <*> arbitrary
06:15:56 <osaunders> data Coord = Coord Int Int
06:16:05 <dr460neye> http://hpaste.org/40760/firsthaskell_tests  -  error : u1.hs Not in scope: `allequal'
06:16:22 <osaunders> quicksilver: Ooh!
06:16:25 <quicksilver> or, if you prefer monad notaion, do x <- arbitrary; y <- arbitrary; return (Coord x y)
06:16:29 <quicksilver> which is exactly the same.
06:16:41 <quicksilver> dr460neye: "allequal" != "allEqual"
06:16:46 <quicksilver> dr460neye: you have a capital E.
06:18:18 <osaunders> quicksilver: Riiiight.
06:18:43 <osaunders> That was sudden-realization riiighhtt, not I-don't-believe-you riiiighhht.
06:18:47 <dr460neye> :( omg, i'm looking for the error for more than 30 minutes . but i didn't see thats just a typing error :(
06:18:49 <dr460neye> thanks
06:19:19 <joe1> does haskell have a function that can return the line no of a file opened? such as perl __LINE__. I can compute it with zip [1..] $ filecontents. But, just curious if there was any.
06:19:31 <quicksilver> dr460neye: welcome :)
06:19:40 <quicksilver> joe1: I don't believe so.
06:19:47 <joe1> quicksilver: thanks.
06:20:22 <mun> is polymorphism a feature of higher-order logic?
06:20:35 <quicksilver> not exactly
06:20:46 <Jafet> You could make a perl monad
06:20:47 <quicksilver> polymorphism is a feature of programming langauges or type systems
06:20:59 <quicksilver> which correspond to logics via the curry-howard correspondance
06:21:20 <mun> but not necessarily a HOL?
06:21:25 <quicksilver> but, what we call parametric polymorphism in haskell
06:21:37 <quicksilver> corresponds to 2nd-order quantification in the obvious logic
06:22:02 <ksf> hmmm.
06:22:24 <ksf> can someone explain to me, in coder's, not mathematicians term, what a symmetric diagonally dominant linear system is?
06:22:33 * fryguybob ponders the obvious logic where everything is logical, obviously...
06:22:34 <xplat> not all forms of polymorphism act like higher-order quantification in the logic side, but most of the nice ones do
06:22:35 <mun> quicksilver, why is it 2nd-order?
06:23:02 <quicksilver> mun: because you're quantifying over propositions
06:23:12 <quicksilver> id :: forall a . a -> a
06:23:18 <xplat> mun: because it's quantified over types (aka propositions), not over something else
06:23:25 <quicksilver> corresponds to the logical formula /\ A . A -> A
06:23:25 <mun> i see
06:23:37 <quicksilver> which is quantifying over propositions A
06:25:34 <mun> thanks
06:26:08 <quicksilver> of course even in non-higher order logic, we hide the higher order in the metalanguage
06:26:17 <quicksilver> so I might say "A -> A is a tautology"
06:26:26 <fasta> ksf, you are an applied mathematician when you need to know that (or was that a joke). Anyway, the answer is one Google query away. 
06:26:35 <quicksilver> implicitly I mean that I can prove that, irrespective of the A.
06:26:45 <quicksilver> which is quantifying over A, but doing so in the metalanguage.
06:27:12 <quicksilver> and that fact / proof is the one which corresponds to 'id'.
06:27:14 <fasta> ksf, forall i, A_ii >= Sum_j_n (Aij)
06:27:48 <fasta> ksf, or rather that's the dominant part.
06:30:37 <ksf> well, I'm more interested in when such a scheme that appears to have a generic, efficient solver would be applicable. to extend my toolbox beyond stuff like dynamic programming and bdds
06:32:02 <ksf> that is, I understand what makes them special, but I don't have the faintest what kind of thing is special like that.
06:32:45 <quicksilver> all non-degenerate systems can be made diagonally dominant
06:32:47 <ksf> dynamic programming : composability of optimal subsolutions  ::: sdd : ??
06:33:06 <quicksilver> it's a property of your coordinate system, it's not intrinsic
06:33:15 <quicksilver> (well, the only intrinsic part of the property is non-degenerancy)
06:35:02 <ksf> ...degenerancy as in graph theory?
06:36:38 <EvanR-work> is it possible to have a list of different types, all instance of some class
06:36:42 <EvanR-work> Show a => [a]
06:37:18 <ksf> with -XExistentialQuantification or -XGADTs, yes.
06:37:21 <fasta> quicksilver, and how much time does it cost to do that transformation?
06:37:26 <quicksilver> EvanR-work: yes, although that is not what the type signature you just gave meant.
06:37:27 * ksf recommends GADTS, there.
06:37:30 <quicksilver> fasta: in general, a lot.
06:37:36 <EvanR-work> > ['a',4] :: Show a => [a]
06:37:37 <hsbot>   No instance for (GHC.Num.Num GHC.Types.Char) arising from the literal `4' at <interactive>:1:5 Possible fix: add an instance declaration for (GHC.Num.Num GHC.Types.Char)Couldn't match expected ty...
06:37:45 <fasta> quicksilver, heh, so it's basically useless ;)
06:38:06 <EvanR-work> whats the correct signature
06:38:15 <ksf> EvanR-work, but that's not very usefull when you use show, as you could just safe strings, instead.
06:38:15 <quicksilver> EvanR-work: Show a => [a] is a polymorphic list which takes *all* showable types, on demand.
06:38:29 <quicksilver> > [1,2,3] :: Num a => [a]
06:38:30 <hsbot>   [1,2,3]
06:38:37 <quicksilver> ^^ just to emphasise the meaning of that kind of type sig
06:38:51 <quicksilver> that's a polymorphic list - it's a list of doubles *and* a list of ints *and* any other num type.
06:39:11 <quicksilver> but in any instance, all the elements are the same type.
06:39:15 <quicksilver> what you want is this:
06:39:30 <quicksilver> data AnyShowable = forall a . MkShowable a
06:39:39 <quicksilver> [AnyShowable]
06:39:40 <EvanR-work> ksf: i wasnt thinking of actually using Show
06:39:54 <quicksilver> http://www.haskell.org/haskellwiki/Existential_types
06:40:05 <ksf> data Showable where MkShowable :: Show a => a -> Showable
06:40:17 <quicksilver> fasta: well, in some specific cases it may be less than "a lot"
06:40:32 <quicksilver> fasta: and in other cases it may be that what you were plannign to do *next* is even more work...
06:40:43 <quicksilver> fasta: ... and substantially sped up by the transformation to diagonal dominance.
06:41:05 <quicksilver> fasta: In the past it has seemed to me that the entire discipline of applied mathematics is basically about diagonalising matrices.
06:41:11 <quicksilver> ...but that reflects my own biases.
06:41:37 <fasta> quicksilver, I have the impression that CS is playing catchup to physical algorithms in a lot of areas. 
06:41:53 <quicksilver> yes, a sandbox is a much better computer than a computer.
06:41:57 <ksf> that'd be because physicists are damn formalists.
06:42:01 <quicksilver> and I mean one of those literal ones that is, actually, a box of sand
06:42:05 <ksf> ...or worse. 
06:42:07 <quicksilver> that you run streams of water through.
06:43:23 <ksf> that is, their maths works, but it's a patchwork of ugly hacks not stopping at "you can ignore that term if it's on the rhs at stage 2 of our derivation, here, but not in general"
06:45:08 <ksf> http://math.andrej.com/2008/08/13/intuitionistic-mathematics-for-physics/
06:46:59 <ksf> oh or did you mean "physical algorithm" like in, to pick an arbitrary example, solving traveling salesmen with a colony of ants?
06:47:57 <ksf> I fear that CS can't have been doing this, as Mr. Wolfram is the only one who can do such stuff.
06:49:20 <merijn> ksf: pfft, you don't solve TSP with ants...
06:49:32 <fasta> ksf, I meant algorithms which are applied to physical problems, mostly matrices, whereas CS mostly uses graphs (they are the same thing in some sense).
06:49:37 <merijn> You use mold :p
06:49:47 <ski> EvanR-work : you want `[exists a. Show a *> a]' rather than `Show a => [a]'
06:49:50 <fasta> We need universal constructors.
06:49:53 <fasta> In space.
06:50:27 <ski> EvanR-work : for each element in the list, you want there to exists some type `a', being an instance of `Show', such that the element has type `a'
06:50:45 <ksf> is anyone else here of the oppinion that things like church-turing are the actual laws of the universe, not the mere matter/energy stuff physicists make up?
06:51:02 <ski> EvanR-work : `Show a => [a]' would insist that every element in the list has the same type (so the choice is made at the wrong time, too early)
06:51:30 <merijn> ksf: Well, if we can proof untyped lambda calculus to be isomorphic with the laws of physics...
06:52:07 <merijn> Mold solving TSP -> http://www.sciencedaily.com/releases/2010/01/100121141051.htm
06:52:10 <ski> EvanR-work : the other thing that is wrong was that by `Show a => [a]' you presumably meant `forall a. Show a => [a]', and even if you fix that to `[forall a. Show a => a]' that's still something else
06:52:11 <ksf> cf. the "uncanny applicability of maths to physics"
06:52:49 <EvanR-work> ski: hm
06:52:52 <ksf> merijn, I think that's more or less the same as using ants.
06:52:53 <merijn> ksf: Actually, I'm of the opinion that phycists are trying to prove physics isomorphic to lambda calculus, which means they will do the work for us :p
06:53:24 <ksf> ha! they didn't even get the standard model right.
06:53:52 <ski> EvanR-work : in `[forall a. Show a => a]', it is the *user* of the list who determines which type `a' to use for each individual element -- so each element is handled separatedly, which is right; but you want the person who defines the list to make the choice of which type to use for each element -- therefore, you want `[exists a. Show a *> a]'
06:54:04 <ksf> it didn't predict the slowdown some deep-space probes experienced, something roughly equivalent to a universal friction in space.
06:54:13 <ski> EvanR-work : does that make sense ?
06:55:10 <EvanR-work> whats *>
06:56:19 <ski> a value of type `C X => Foo' is something that given an instance of `C X', gives you a value of type `Foo'
06:56:22 <ski> e.g.
06:56:28 <ski> @type 42
06:56:42 <ski> oh, no lambdabot
06:57:16 <ksf> oh, and that mold thing dosn't solve TSP, but shortest path from anywhere to anywhere. you don't get an order in which you're supposed to visit things.
06:57:31 <ski> anyway, a value of type `C X *> Foo' (that's my pseudo-haskell notation) is something that already contains an instance of `C X', together with a value of type `Foo'
06:58:48 <ski> EvanR-work : so, e.g. a value of type `forall a. C [a] => IO a' is something, that for any type `a' which the caller/user chooses, such that the caller can provide an `C [a]' instance, it will return something of type `IO a', for that particular type `a'
07:00:53 <ski> EvanR-work : and, e.g. a value of type `exists a. C [a] *> IO a' is something, where there callee (the one who defined the value)has already chosen a type `a' for you (the caller), and has already provided an `C [a]' instance for you, and it will return something of type `IO a' -- so the only thing you will need to do is be able to handle any `a' whatsoever, only knowing that `[a]' is an instance of `C'
07:01:38 <ski> EvanR-work : you can also consider `forall a. C [a] *> IO a', and `exists a. C [a] => IO a', but those two combinations aren't as useful ..
07:01:51 <EvanR-work> so whats the non pseudo haskell
07:02:37 <ksf> you change the exists into a forall in its own data type.
07:02:41 <ski> well, any time you mention `exists a. ..a..', or `exists a. C (Foo a) *> ..a..', you invent a new type
07:02:42 <ksf> lique quicksilver and me above.
07:03:02 <ksf> s/lique/like
07:03:06 <EvanR-work> ok so existentials
07:03:09 <ksf> french spelling, get out of my head.
07:03:17 <ski>   data SomeThing = forall a. Foo a => MkSomeThing (..a..)
07:03:20 <ski> alternatively
07:03:22 <EvanR-work> any reason its forall and not exists? :)
07:03:25 <ski>   data SomeThing :: *
07:03:26 <ski>     where
07:03:32 <ksf> UHC knows of exists
07:03:33 <quicksilver> because it's the quantifier on the constructor
07:03:35 <quicksilver> not the type
07:03:41 <ski>     MkSomeThing :: forall a. Foo a => (..a..) -> SomeThing
07:03:44 <quicksilver> it's odd, but not actually illogical
07:03:49 <quicksilver> just a surprising syntax
07:03:57 <ski> note that the type of the constructor there is basically the same as
07:04:06 <ski>     MkSomeThing :: (exists a. Foo a *> ..a..) -> SomeThing
07:05:05 <ski> iow, when you construct `SomeThing', which hides some value of type `..a..', together with the type `a', this is a polymorphic operation
07:05:20 <ski> you can hide any type `a' you like, and the `a' won't turn up in the result type `SomeThing'
07:05:44 <fasta> You can also do this without a new constructor, right?
07:05:51 <ski> but when you unpack this, you get back some unknown opaque type `a' from the insides, which you can't analyze, since it could be anything
07:06:21 <ski> this means that it is usually futile to try to define instances of e.g. `Eq' for "existential data types"
07:06:46 <ski> EvanR-work : concretely, in the `[exists a. Show a *> a]' case, you define
07:07:06 <ksf> fasta, nope, you have to hide the "a" or GHC will try to unify it in the usual way.
07:07:17 <ski>   data Showable = forall a. Show a => WrapShowable a
07:07:18 <ski> or
07:07:23 <ski>   data Showable :: *
07:07:25 <ski>     where
07:07:37 <ski>     WrapShowable :: forall a. Show a => a -> Showable
07:07:56 <ski> and then instead of `[exists a. Show a *> a]' you use `[Showable]'
07:08:10 <ksf> that's the very difference between an existential and merely limiting a data type to carry stuff that implement a certain class.
07:08:13 <ski> (and you need to manually wrap and unwrap elements .. which is a bit of a nuisance)
07:08:42 <ski> fasta : i'm not sure what you mean by "do this without a new constructor"
07:08:49 <ksf> (the latter being quite bad style)
07:08:53 <ski> EvanR-work : is it clear ?
07:09:11 <ski> EvanR-work : i hope you at least understand how to use it ..
07:09:33 <ski> btw, the ` :: *' part in the GADT-style definition of the existential data type is optional
07:09:42 <ski> (and requires extension `KindSignatures')
07:10:09 <ksf> I always use that because data Showable a can get confusing.
07:10:57 <ksf> ...the bindings you define there aren't defined in the constructor definitions
07:11:36 <ezyang> Hey guys: is Haskell's monomorphism restriction similar to '_a types in OCaml? 
07:11:36 * ski wonders whether ksf is talking about `data Show a => Foo a = ..a..' ..
07:11:52 <ksf> nope, GADT syntax in general
07:12:06 <fasta> ski, I am fairly sure that I have seen it working in GHC with forall once. 
07:12:41 <ski> ezyang : a little, but you can avoid the DMR in Haskell, by writing an explicit type signature (or using `NoMonomorphismRestriction') .. and the motivation for it is different
07:12:44 <fasta> ski, that is something like <some_list_of_different_types>::forall <blah> which was accepted in GHC. 
07:12:58 <fasta> UHC has this feature for exists. 
07:13:01 <quicksilver> fasta: only if you transform your data types into (higher ranked) functions.
07:13:04 <ezyang> ski: Ah. 
07:13:21 <fasta> quicksilver, example?
07:13:21 <ezyang> Right, so in OCaml you'd need to eta expand, and the motivation there is to preserve soundness in the face of side effects. 
07:13:24 <ski> ezyang : btw, i think OCaml allows instantiating non-generalized type variables by their use, which Haskell doesn't do
07:13:25 <HugoDaniel> where can i learn about GADT's ?
07:13:39 <quicksilver> you can replace [a] with r -> (a -> r -> r) -> r 
07:13:40 <ski> (and i think SML/NJ also does that .. that's an extension of the SML standard)
07:13:47 <ezyang> Whereas for Haskell the motivation is to avoid extra computation that the user doesn't expect. 
07:13:55 <ezyang> ski: What does that mean? 
07:14:01 <quicksilver> so you can replace [exists a . Show a => a] with r -> (forall a . Show a => a -> r -> r) -> r
07:14:33 <quicksilver> i.e. you can always encode existentials as higher rank functions but you have to unwind the data types
07:14:38 <ski> ezyang : yes
07:14:44 <ski> ezyang : what does what mean ?
07:15:02 <ezyang> ski: "instantiating non-generalized type variables" 
07:15:10 <ski> quicksilver : `forall r. ' is essential
07:15:16 <quicksilver> ski: thanks.
07:15:20 <ezyang> I don't really know what a non-generalized type variable is. Seems paradoxical :-) 
07:15:20 <fasta> quicksilver, yes, I suppose that was it then, but I don't really remember the extra argument r. 
07:15:57 <fasta> By the time you want these things, Coq makes more sense.
07:16:47 <ski> ezyang : oh. well if you say  let my_id = id id  then you get  my_id : '_a -> '_a  but if you then use it in the same module (i think) as  my_id 4  then that gets backpropagated (logic variable unification, basically) so that you actually have  my_id : int -> int  so then you can't also use  my_id "foo"
07:17:05 <quicksilver> haskell's compromise existentials - which require a constructor to delimit the point the type variable comes in scope - work fine
07:17:13 <quicksilver> the slightly clunkiness is something you can get used to.
07:17:15 <ezyang> ski: Ah, sure. 
07:17:41 <ezyang> IME Haskell would do the same thing (though not with functions) 
07:18:59 <ski> ezyang : in Haskell syntax, think of it as the difference between `my_id :: forall a. a -> a', and `my_id :: a -> a' (*not* assuming implicit generalization in the latter). the latter type signature depends on whatever type `a' actually stands for .. what OCaml (and SML/NJ) allows is that that type can actually be determined by the *use* of `my_id' .. so that later in the type inference, we unify `a = Int', so that `my_id ::
07:18:59 <ski>  a -> a' becomes the same as `my_id :: Int -> Int' (before that `a' was an "unknown, concrete type")
07:19:53 <ezyang> ski: Ah, that makes a bit of sense. 
07:20:01 <ski> ezyang : in any case, you have to realize that the concept of type variable is distinct from generalization
07:20:11 <ezyang> Ok. 
07:20:49 <ski> it is just that Haskell does implicit universal quantification over definitions (that's basically HM typing), and that can easily blure the distinction somewhat
07:20:56 <ezyang> Yeah. 
07:22:29 * ski thinks it would be really nice and useful, if we could get support for first-class existentials in types, even if we get restrictions that we have to manually write type signatures to convince things to type-check
07:22:42 <quicksilver> ski: have you seen UHC's implementaiton?
07:22:46 <ski> (similar to polymorphic recursion, and some other type system extensions)
07:23:06 <roconnor> anyone here use uniplate?
07:23:08 <quicksilver> (polymorphic recursion isn't an extension ;)
07:23:34 <ski> i've not. but i've heard rumors that they only allow `exists' on the left of `->' .. which doesn't really buy much over a plain `forall'
07:23:59 <ski> quicksilver : type system extensions other than first-class existentials ;)
07:24:26 <quicksilver> ski: nope; http://www.cs.uu.nl/wiki/bin/view/Ehc/UhcUserDocumentation#3_6_Existential_types
07:24:47 <ski> (well, i admit the "other" wasn't that clear in my head, when i wrote that)
07:25:05 <quicksilver> x1 :: exists a . a; x1 = 3 :: Int
07:25:09 <quicksilver> is one of their examples.
07:25:33 <ski> well, that sounds great then
07:25:41 <ski> (btw, Mercury has first-class existentials, too)
07:25:59 <quicksilver> but, oddly enough, UHC can't do class-bound existentials this way
07:26:30 <ski> (they have an operation ~ `newState :: exists s. State a', which is used instead of `runST :: forall a. (forall s. ST s a) -> a')
07:26:54 <ski> well, constrained existentials is a problem, afaiui
07:27:05 <ski> i.e. the problem is at trying to infer them
07:27:13 <ski> s/at/at least/
07:28:12 * ksf thinks an important feature of every feature that isn't amendable to inference are error messages that point out the fact that the code might typecheck with a signature
07:28:59 <ski> i *think* it should be possible to type-check stuff like `frob :: forall a. C a => Foo a -> exists b. D a b *> Bar a b', but you probably can't infer such types
07:29:23 <ski> ksf : yes, that'd be very helpful :)
07:29:39 * ski wonders what the status is on that wrt polymorphic recursion
07:30:16 <ksf> somewhat related is a feature I wished for while toying with grapefruit-records: being able to write custom inference strategies.
07:31:09 <ksf> as what might be impossible (or infeasible) in general might very well make sense in a specific library setting.
07:31:42 <ski> how would that work ?
07:32:14 * ski wonders whether EvanR-work got her/his existential data types to work ..
07:32:34 <ksf> select what stuff to try first, allow for backtracking etc.
07:32:49 <SonOfLilit> Hi
07:33:12 <SonOfLilit> In http://en.wikibooks.org/wiki/Haskell/Applicative_Functors, I am having trouble with Ex. 3:
07:33:24 <SonOfLilit> Define a functor instance for ((->) t)
07:33:31 <ksf> hmmm does a hlist-like thingy exist for agda or similar?
07:33:37 * roconnor seems to recall that constructors for Sigma types require annotations
07:34:22 <ski> roconnor : *nod*
07:34:53 <quicksilver> ksf: there is a fairly generic conflict between backtracking and open world
07:34:54 <ksf> ski, even up to the point of "if you infer those two classes, take this one which has them as restraints, instead".
07:34:56 <SonOfLilit> Can anyone help me reach a solution?
07:34:57 <ski> but i suspect that, often atleast, a type signature of the larger definition would suffice
07:35:10 <ksf> yes, that's why it can't be done in a generic way.
07:35:16 <ksf> a library is closed, though.
07:35:20 <ksf> (usually)
07:35:36 <quicksilver> well a library gets linked into an application
07:35:42 <quicksilver> and that application is free to define instances of its own
07:35:44 <ski> classes are open
07:35:49 <quicksilver> which may involve types the library uses
07:35:58 <quicksilver> *especially* if the library has any polymorphic functions
07:36:02 <ski> SonOfLilit : what have you written, so far ?
07:36:04 <quicksilver> it may be using those types without knowing it.
07:36:15 <ksf> I think closing classes is the least of the problems, there.
07:36:27 <quicksilver> those are normally the worst kind of open-world/backtracking coherences failures
07:36:41 <quicksilver> where you do some backtracking in the presence of an unknown (polymoprhic) argument type
07:36:49 <quicksilver> and a calling site may actually have instances you don't know about.
07:37:00 <ksf> a user _really_ doesn't need to write instances for "AppendHList" or something.
07:37:10 <SonOfLilit> ski: nothing
07:37:36 <SonOfLilit> it's supposed to be a simple excersize
07:37:58 <ksf> SonOfLilit, well, there's your problem.
07:38:05 <ksf> just start and let the type errors guide you.
07:38:08 <SonOfLilit> I just can't see how a type that generates functions is mappable
07:38:17 <SonOfLilit> mmm
07:38:19 <SonOfLilit> I'll try
07:38:32 <ksf> hint:
07:38:38 <ksf> :t (.)
07:38:45 <ksf> @bot
07:38:50 <ksf> @slap lambdabot
07:38:55 <EvanR-work> dead
07:39:03 <ksf> anyway, (.) = fmap
07:39:21 <ski>   fmap :: forall f. Functor f => (a -> b) -> (f a -> f b)
07:39:38 <ski> instantiate `f = (t ->)' (for any `t') and you get
07:39:59 <ski>   fmap :: forall t. Functor (t ->) => (a -> b) -> ((t -> a) -> (t -> b))
07:40:39 <ski> (note that what i wrote as `(t ->)' is just a "type operator section" (not actually allowed syntax :/), being the same as `(->) t')
07:41:23 <zygoloid> if you don't export a class but do export functions using that class, you can still use those functions, right?
07:41:24 <EvanR-work> ski stop making up syntax! ;)
07:41:50 <SonOfLilit> --  fmap :: (a -> b) -> (a -> t) -> (b -> t)
07:41:55 <SonOfLilit> is that right?
07:41:57 <Jafet> I like this (t->), where can I buy one?
07:42:15 <EvanR-work> fmap :: (Functor f) => (a -> b) -> f a -> f b
07:42:19 <ski> EvanR-work : why should we not be able to write `(foo :+-*)' for any type operator `:+-*' ?
07:42:19 <ksf> hackage.haskell.org/trac
07:42:25 * hackagebot histogram-fill 0.3 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.3 (AlexeyKhudyakov)
07:42:42 <EvanR-work> ski: it seems like the type language is lacking of a lot of things ilke that
07:42:43 <ski> SonOfLilit : no
07:42:57 <ksf> I'd even go so far that operator sections should be included in -XTypeLevelOperators
07:43:08 <ski> EvanR-work : btw, note that allowing `(-> t)' is much more problematic ..
07:43:11 <ksf> and -XTupleSections should be h'
07:43:39 <SonOfLilit> ski, ksf: Thank you both
07:43:42 <SonOfLilit> I have to go
07:43:52 <SonOfLilit> I'll convince myself later that your answers are correct :)
07:43:59 <ski> SonOfLilit : if you want, do it in small steps .. replace each `f' by `(->) t' .. what type signature does that give you ?
07:44:26 <ksf> I found the easiest way to convince myself of these things is to convince old aunt typechecker of them.
07:44:31 <ski> EvanR-work : did you get your existentials to work ?
07:44:58 <EvanR-work> im not going to use them for 'heterolists', i was just curious
07:45:31 <EvanR-work> im thinking its not that useful or useful enough given other techniques
07:45:42 <ski> "heterolists", can be useful, sometimes .. but probably not as often as people seem to think
07:46:13 <ksf> I think the only occurence of existentials in the standard libraries is SomeException
07:46:17 <EvanR-work> i thought i had a 'need' for them but i dont remember what it iss
07:46:19 <zygoloid> ski: i don't see that there's a problem with (t ->) nor with (-> t). both of them can be considered to be type synonyms in a sane way
07:46:25 <ski> EvanR-work : also see <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
07:46:40 <ski> zygoloid : what does `Mu (-> t)' mean ?
07:46:42 <zygoloid> ski: that wouldn't let you define instances for either of them (not even with -XTypeSynonymInstances) because they'd not be fully applied
07:46:50 <aristid> ski: if you have a list list [show a, show b, show c], then map show [a, b, c] might be nice
07:46:59 <zygoloid> ski: that's illegal because the type synonym isn't fully applied
07:47:06 <ksf> ...which is data SomeException :: * where SomeExectpion :: Typeable a => a -> SomeException
07:47:16 <zygoloid> ski: same as type F t u = (u -> t); ... Mu (F t) ...
07:47:44 <fasta> Is it just me or is the wikipedia entry on BFS really bad? 
07:47:55 <zygoloid> ski: in order to get Functor (t ->) to work, you need the type-level equivalent of the GHC extension which allows left sections to desugar abnormally
07:47:56 <ski> zygoloid : right .. oh, you have a point in that one might still allow `(-> t)' as argument to type synonyms
07:48:02 <fasta> It doesn't even list useful pseudo-code.
07:48:21 * ksf has long given up on wikipedia for cs topics.
07:48:22 <ski> hm .. maybe also for `data', and `newtype' ?
07:48:22 <zygoloid> ie (x!) = (!) x, not \y -> (!) x y
07:48:33 <ksf> it's only useable as a source of terms to google for.
07:48:43 <EvanR-work> ski: is this basically saying existential and existential-like data structures can be done with normal functions
07:48:43 <fasta> ksf, yes, but this is trivial stuff.
07:49:10 <fasta> ksf, maybe I should use the French version of Introduction to Algorithms next time ;)
07:49:14 <ksf> even worse. with non-trivial stuff, at least, bozos won't try to influence the article.
07:49:22 <saml> hey, given a tree, how do you get an immediate child (no grand child..)   whose value is 1?
07:49:31 <quicksilver> ski: yes, that's a great article by luqui.
07:49:35 <fasta> ksf, the lecture notes of some universities about the topic didn't even list it. 
07:49:38 <zygoloid> saml: using what representation of a tree?
07:49:42 <saml> do you recurse with "level" argument?
07:49:44 <fasta> ksf, 80% was wrong in total.
07:50:12 <fasta> The 'top-coders' article (which some people give some credit) is wrong too and people get paid to write that stuff. 
07:50:15 <saml> data Tree = Node Int [Tree] | Leaf Int
07:50:22 <ski> EvanR-work : it is saying that, *often*, people try using existentials, because they've heard you can do some similar things with them as with some OO techniques (which is more or less true) .. but often in such cases, existentials doesn't buy you anything, and in some cases is even worse
07:50:38 <fasta> I would rather have that not all people have write access to the Internet.
07:50:47 <ski> quicksilver : i'd `where+' it in lambdabot, were she present ..
07:50:54 <ezyang> Quantification in general is kind of tricky to use. 
07:51:00 <fasta> Or that I can search for 'person that has written this has a Phd in CS'.
07:51:16 <zygoloid> saml: childrenWithValue1 Leaf{} = []; childrenWithValue1 (Node _ xs) = [x | x@(Node 1 _) <- xs]
07:51:43 <ski> zygoloid : yes. and yes, exactly
07:51:55 <saml> yah.. i'm using functionaljava it's hard to get xs part.
07:52:33 <saml> data Tree = Node Int (Monad Tree) | Leaf Int
07:52:48 <ski> (but i consider `(x !) = (!) x' to be the proper desugaring, anyway .. regardless of whether you want to force the operation to have type `.. -> .. -> ..' or not)
07:53:09 <ksf> fasta, phds are quite often the worst kind of teachers.
07:53:37 <fasta> ksf, or via some social network kind of thing.
07:53:43 <quicksilver> ski: I have tended to do "data Widget s = { internaldata :: s, various other operations }"
07:53:57 <fasta> ksf, I can list a handful of people that adhere to my standards, I am sure some others can do so too. 
07:54:01 <quicksilver> ski: but of course you can always capture in a closure instead of making it a field.
07:54:06 <ksf> while hackers are usually as elitistic, they don't tend to revel in obfuscating publications.
07:54:10 <quicksilver> ski: and I think I was probably wrong not to do so.
07:54:25 <zygoloid> ski: you have my support :)
07:54:40 <ksf> cf. "shut up and show us the code"
07:55:07 <ski> quicksilver : you can only use a closure if `s' is only input to the operations, no ?
07:55:27 <quicksilver> ski: right.
07:55:35 <ksf> each time I wade through obscure terminology in a paper just to find out that that oh-so-good O comes with prohibitively expensive constant costs I want to shoot a whole faculty.
07:55:37 <quicksilver> ski: but in practice I ended up quantifying out over the s
07:55:43 <quicksilver> ski: so it could only be used as input for the operations.
07:55:53 <ski> quicksilver : sometimes you can use a recursive formulation instead .. but i'm not quite sure exactly when
07:56:09 <quicksilver> ski: in *principle* there might have been a case for type sigs like [Widget Int] -> .... which know there is an Int inside.
07:56:11 <ski> (ksf : "are usually considered as elitistic" ?)
07:56:15 <quicksilver> ski: ..but in practice I never did that.
07:56:31 <quicksilver> I think the basic point is 'keep it simple;
07:56:54 <ksf> there's nothing wrong with a good amount of elitism.
07:56:54 <ski> quicksilver : well, `forall s. [Widget s] -> ...' is quite different from `[exists s. Widget s] -> ...'
07:57:10 <ksf> ...keeps the clueless at bay.
07:57:12 <ski> (ksf : you seemed to be missing a word or two)
07:57:16 <quicksilver> ski: sure, but in fact it was the latter.
07:57:20 <ksf> nope I meant what I said.
07:57:33 <quicksilver> ski: and even if I had the former, I never actually *used* the fact that all the s's were the same
07:57:39 <quicksilver> ski: even though the type sig showed that I could
07:57:42 <ski> ksf : "are usually as elitistic" doesn't parse, for me
07:58:08 <ksf> that is, I implied "the definition of "hacker" inludes "person is cromulently elitistic""
07:58:16 <fasta> I think this was well-written for example: http://psnively.github.com/2010/03/13/100-proof.html
07:58:23 <ksf> ski, compared to phds, see a couple of lines above.
07:58:33 <ski> ksf : oh, sorry, mea culpa. you were comparing to what you said before (which i missed)
07:59:15 <fasta> I don't think he answered the questions in a satisfying manner, but the article itself is fine. 
08:00:10 <ksf> you see, you can even have fuzzy teddy bears like conal, and when you say the wrong kind of stuff, he elitistically cuddles you until you understand that you have no idea what you're talking about.
08:01:18 <megajosh2> [forall s. Widget s] means a list of anything that inherits from the Widget typeclass?
08:01:45 <ksf> ...implement the Widget typeclass.
08:02:09 <ksf> "inherentance" would be class Widget s => Button s where ...
08:02:10 <ski> neither
08:02:19 <ksf> well, instantiates.
08:02:25 <ksf> has an instance.
08:02:29 <megajosh2> Right, right
08:02:42 <megajosh2> I'm thinking about OOP classes
08:02:52 <ksf> and ski is right, that's not what your syntax says.
08:02:53 <ski> megajosh2 : `[forall s. Widget s]' is the type of lists where for each element of the list, the *user* of the list can choose any type `s' s/he wants, and then that element will have type `Widget s'
08:03:08 <ski> megajosh2 : as you can expect, that usually not a very useful type
08:04:01 <Saizan> in particular, Widget is not a typeclass there :)
08:04:12 <megajosh2> Oh duh
08:04:14 <ski> megajosh2 : a more useful type is probably `[exists s. Widget s]', which is the type of lists where for each element of the list, the one who created the list has already decided on some type `s' (and you don't know which it is), such that the element has type `Widget s'
08:04:24 * ksf thinks a couple of lines of code and at least twice the number of type errors teach those things best.
08:05:02 <ski> e.g. if you have `foo :: Widget Int' and `bar :: Widget Bool', then ideally, you could say `baz :: [exists s. Widget s]; baz = [foo,bar]'
08:05:18 <megajosh2> Oh, okay
08:05:23 <megajosh2> That's more of what I was thinking of
08:05:35 <ski> in practive, Haskell doesn't (yet, at least) support syntax like this, so you have to be a bit more roundabout .. but it will amount to the same thing
08:05:36 <dlazar> Need help with Haskell program Morfette! Encoding problems on new install. 
08:05:49 <ski> what you do instead is say
08:06:04 <ski>   data SomeWidget = forall s. WrapWidget (Widget s)
08:06:06 <ski> or
08:06:07 <ksf> that's actually bloody useful, to keep the widged type open but still write a generic e.g. layout algorithm.
08:06:11 <ski>   data SomeWidget :: *
08:06:14 <ski>     where
08:06:27 <dlazar> maurer, are you around?
08:06:33 <ski> (sorry)
08:06:53 <ski>   WrapWidget :: forall s. Widget s -> SomeWidget
08:06:55 <ski> and then
08:07:01 <ski>   baz :: [SomeWidget]
08:07:10 <ski>   baz = [WrapWidget foo,WrapWidget bar]
08:07:27 <megajosh2> Oh okay
08:07:35 <megajosh2> I've seen people do stuff like that and wasn't all that sure what I was looking at
08:07:37 <ski> so, the `exists s. Widget s' gets replaced by `SomeWidget', which you need to define as a data type, as above
08:07:50 <ski> note that
08:07:52 <ski>   WrapWidget :: forall s. Widget s -> SomeWidget
08:07:59 <ski> "morally" means the same as
08:08:08 <ski>   WrapWidget :: (exists s. Widget s) -> SomeWidget
08:08:36 <ski> the first says that for any type `s', if you give `WrapWidget' something of type `Widget s', then you get back a `SomeWidget'
08:09:03 <ski> the latter says that, if there exists some `s', such that you give `WrapWidget' an `Widget s', then you get back a `SomeWidget'
08:09:32 <ski> this is why `forall' is used in the syntax of "existentiall quantified data types"
08:10:03 <ski> btw, note that you can have an "existentiall quantified data type" that uses the local type variable in several arguments
08:10:06 <ski> e.g.
08:11:28 <ski>   data StackImpl a = forall x. MkStackImpl x (a -> x -> x) (x -> Maybe (a,x))
08:11:36 <ski> alt.
08:11:48 <ski>   data StackImpl (a :: *) :: *
08:11:49 <ski>     where
08:12:08 <ski>     MkStackImpl :: forall x. x -> (a -> x -> x) -> (x -> Maybe (a,x)) -> StackImpl a
08:12:26 <ski> the type signature for `MkStackImpl' here is *almost* the same as
08:12:37 <ski>   MkStackImpl :: forall x. (x,a -> x -> x,x -> Maybe (a,x)) -> StackImpl a
08:12:43 <ski> which is then "morally" the same as
08:12:52 <ski>   MkStackImpl :: (exists x. (x,a -> x -> x,x -> Maybe (a,x))) -> StackImpl a
08:13:10 <ski> but this latter version is the uncurried version of the original
08:13:26 <megajosh2> Hmmm... I should write some code and test some things out...
08:13:26 <ski> this also shows that while one could imagine
08:13:41 <ski>   data SomeWidget = forall s. WrapWidget (Widget s)
08:13:46 <ski> being written as
08:13:56 <ski>   data SomeWidget = WrapWidget (exists s. Widget s)
08:14:05 <ski> (and that makes sense)
08:14:26 <ski> one can't really do something similar for `StackImpl' above, as long as `MkStackImpl' is to be a curried constructor
08:14:50 <ski> megajosh2 : does that explain anything ?
08:14:59 <megajosh2> Oh definitely
08:15:02 <megajosh2> Thanks a lot
08:15:31 <ablmf> If I need to build a lexer+paser for C header files, which tools should I have a look.  You know, there are plenty of choices.
08:15:33 <ski> np
08:16:50 * ski would suspect that possibly the best would be to use part of an actual C implementation, and convince it to share the parsed data
08:17:08 <ski> (so that you don't get problems, trying to keep it in synch)
08:18:05 <ski> generally, parsing in Haskell is usually done wither by a parser generator such as `happy' (together with `alex' for lexer generating, e.g.), or to use a parser combinator library such as `Parsec'
08:18:33 <Maxdamantus> Parser generators are lame.
08:19:09 <ski> (s/wither/either/)
08:20:48 <dlazar> having trouble with GHC 6.12, and UTF8 encoding... anyone familiar with this?
08:21:02 <ski> (megajosh2 : btw, for concreteness, `listStack :: forall a. StackImpl; listStack = MkStackImpl [] (:) (\as -> case as of [] -> Nothing; a:as -> Just (a,as))' is an example of the above type)
08:21:48 <ksf> it's mostly the syntax that's lame (i.e. it's non-applicative), but the performance is actually very ok
08:22:41 <ski> (elaborate on what you mean by it being non-applicative ?)
08:23:08 <ksf> not being an edsl based on Appliactive or Monad
08:23:24 <ablmf> ski: I know Happy.  But it's only a parser generator.  I think I still need a lexer.
08:23:47 <ksf> ...in happy's case, with that notoriously ad-hoc yacc-style way of capturing results.
08:23:52 <ski> ablmf : `alex' ?
08:24:59 <ablmf> ski: Thanks
08:25:10 <ski> ablmf : btw, you might also want to check out `bnfc' at <http://www.cse.chalmers.se/research/group/Language-technology/BNFC/>
08:26:07 <ski> ablmf : that can auto-generate `happy' and `alex' code for you, as well as skeletons for functions in Haskell for traversing the parse tree, from an extended BNF-like notation
08:26:11 <ksf> frisby, parsec, attoparsec, uulib...
08:26:35 <ksf> not to forget grammatical framework.
08:27:00 <ksf> which, to the best of my knowledge, is the only one which unifies parsing and unparsing
08:27:37 <ski> ksf : well, `happy' is "off-line", so i think it probably can analyze your grammar more .. possibly an `Applicative' (or `Arrow') parser could ameliorate this, to some extent
08:27:41 <fasta> ski, and where are the LBNF definitions coming from?
08:27:51 <ski> fasta : you write them
08:27:59 <ksf> gf is offline, too.
08:28:06 <ski> yeah
08:28:09 <fasta> ski, right, so a completely uninteresting problem has been solved basically. 
08:28:39 <ksf> making an applicative edsl offline is a true bugger, because TH doesnt' let you lift arbitrary functions.
08:28:58 <aristid> fasta: maybe this seems more interesting to you: http://www.grammaticalframework.org/
08:29:06 * pumpkin is working on a bidirectional binary specification library
08:29:15 <pumpkin> very tricky :(
08:29:31 <ksf> hey, me too.
08:29:40 <quicksilver> I'm not, but I've thought about them more than once
08:29:51 <quicksilver> it's always annoying writing two halfs of a binary specification when they're obviously related
08:29:56 <quicksilver> pumpkin: it's not easy to get it right, is it?
08:30:02 <ksf> ...based on iteratee-style parsing and a regex compiler.
08:30:24 <pumpkin> quicksilver: not at all
08:30:37 <pumpkin> quicksilver: I'm especially frustrated at having to write constructor unpacking functions manually
08:30:38 <ksf> so you can mix optimally efficient regular stuff with elegantly written non-regular stuff.
08:31:07 <pumpkin> stuff like \(A x y z) -> (x, (y, (z, ()))) or something similar, to get the fields out
08:31:12 <ksf> I didn't think much about bi-di, though, but it should be doable with a layer on top of that.
08:31:40 <pumpkin> preflex: seen chrisdone
08:31:40 <preflex>  chrisdone was last seen on #haskell 3 days, 4 hours, 11 minutes and 2 seconds ago, saying: ah, n/m. I can patch it
08:32:07 <ksf> pumpkin, in the mean time, you can just write out a declerative spec of the protocol and write some custom TH to generate the necessary instances.
08:32:08 <quicksilver> pumpkin: yes. It struck me that what you want is a universal encoding of sum + product types
08:32:20 <quicksilver> pumpkin: ..which could be a simple thing in TH or Data.Derive
08:32:23 <pumpkin> ksf: yeah, then it becomes easy and less interesting :P
08:32:41 <pumpkin> quicksilver: yeah, and I'd want to preserve the types, which haskell can't really do
08:33:01 <quicksilver> so data A b c | D e f | E g h becomes (Either (Either (b,c) (e,f)) (g,h))
08:33:06 <ski> quicksilver : well, binary parsing seems simpler in that typically only one bitstring maps to each element
08:33:29 <pumpkin> quicksilver: yeah
08:33:31 <quicksilver> pumpkin: I don't mean you give up proper typing
08:33:39 <ablmf> fasta: GF looks good.  BTW: What do you mean by "offline"?
08:33:51 <quicksilver> I just mean you use TH to generate - two-way - conversions between your real types and the generic sum+product rep.
08:33:56 <pumpkin> quicksilver: well, I mean there's no facility in haskell for taking an opaque type and representing it in a more typeful manner
08:34:02 <pumpkin> yeah, TH would work
08:34:06 <fasta> ablmf, I didn't say that. 
08:34:08 <pumpkin> it just feels like it should be possible without TH
08:34:21 <quicksilver> "Part B: Add new MetaML-style constructs for strongly-typed metaprogramming"
08:34:23 <quicksilver> this sounds promising.
08:34:31 <ski> ablmf : "off-line" being a separate tool that processes some kind of files. "on-line" being a (in this case) Haskell function, that can be applied any time, at run-time
08:34:36 <ski> (roughly)
08:34:50 <ski> quicksilver : where do you read that ?
08:35:04 <pumpkin> in spj's roadmap for TH?
08:35:54 <quicksilver> yes
08:36:01 <quicksilver> ski: http://hackage.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal
08:36:08 <quicksilver> as telegraphed on g-h-u
08:36:19 <ski> aristid : hm .. it would certainly be nice if `map show [0,False,"bar"]' would work .. but i'm not sure how easy that would be
08:36:24 <ski> quicksilver : ty
08:36:51 <aristid> ski: yeah it probably would create more problems than it solves
08:38:20 <quicksilver> breaks princip{al,le} value property 
08:38:32 <quicksilver> (not that it is the only thing in haskell that does that, but it still something to think about)
08:39:24 <ski> aristid : a somewhat related issue would be that it would be nice if `fst :: (a,b) -> a' would be de-sugared to `fst :: forall a. (exists b. (a,b))' so that stuff like  maximumBy (comparing `on` fst) xs  would infer that `xs' had a type like `[exists b. (a,b)]'
08:40:12 <ski> (and you can implicitly go from `[(a,b)]' to `[exists b. (a,b)]', for any `b')
08:40:14 <aristid> ski: you should write a dialect of haskell with first-class existentials :)
08:40:22 <merijn> Where would I locate fork() and/or exec() in Haskell or does that require the foreign function interface?
08:40:51 * ski wonders whether that would break princip{al,le} types
08:41:14 <quicksilver> @hoogle forkprocess
08:41:18 <ski> aristid : i've pondered a little bit what would be sensible typing rules for this ..
08:41:34 <ski> lambdabot is absent
08:42:07 <Funktorsalat> http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-Process.html#v:forkProcess
08:42:08 <quicksilver> merijn: it's called forkProcess, but it comes with caveats
08:43:20 <roconnor> is there a channel for yhc?
08:43:26 <Funktorsalat> hmm yes, where did part of the warning go?
08:43:32 <pumpkin> @tell chrisdone can't seem to get "deep annotations" easily in hpaste: http://hpaste.org/40752/dearestpumpkin mentions 40753 as an annotation, but 40753 itself has an annotation 40754, which isn't visible on front page or on 40752, but only on the 40753 page. Any way to make the full set of annotations visible?
08:43:40 <pumpkin> preflex: tell chrisdone can't seem to get "deep annotations" easily in hpaste: http://hpaste.org/40752/dearestpumpkin mentions 40753 as an annotation, but 40753 itself has an annotation 40754, which isn't visible on front page or on 40752, but only on the 40753 page. Any way to make the full set of annotations visible?
08:43:40 <preflex>  Consider it noted.
08:43:47 <Funktorsalat> (I think it used to say that you can basically only call executeProcess in the fork)
08:43:51 <pumpkin> preflex: seen lambdabot
08:43:51 <preflex>  lambdabot was last seen on #haskell-blah 1 day, 3 hours, 17 minutes and 55 seconds ago, saying: i'll hafta plead the fifth on that one.
08:43:56 <pumpkin> preflex: seen Cale
08:43:57 <preflex>  Cale was last seen on #haskell 1 day, 19 hours, 17 minutes and 38 seconds ago, saying: Applying the function 4 to the value 5
08:50:53 <dom96> Why is there no instance of Data for JSValue in Text.JSON? 
08:51:12 <roconnor> any yhc developers around?
08:52:22 * ski seems to recall ndm is an yhc developer .. or maybe it was nhc ?
08:52:30 <quicksilver> he was, once
08:52:35 <quicksilver> I'm not sure he still involved.
08:52:52 <quicksilver> The only person who IRCs who speaks with authority on yhc seems to be malcolmw
08:52:58 <quicksilver> @seen malcolmw
08:52:59 <preflex>  malcolmw was last seen on #ghc 87 days, 18 hours, 13 minutes and 34 seconds ago, saying: full sigs would be my preference
08:54:14 <dom96> hrm, who was it that i talked to about JSON? Was it you quicksilver?
08:54:54 <quicksilver> I think I talked about it a bit.
08:55:12 <quicksilver> I suspect the answer to your question is 'no good reason - the developer just didn't put one in'
08:55:26 <quicksilver> with standalone deriving in GHC you can derive your own instance for JSValue.
08:55:31 <quicksilver> Do you really need a Data instance though?
08:55:36 <dom96> I tried that.
08:55:39 <dom96> I think so.
08:55:44 <dom96> I don't know how else to do it.
08:55:56 <quicksilver> do what?
08:56:16 <dom96> I'll hpaste what i'm trying to do, sec.
08:57:35 <quicksilver> win 23
08:58:24 <dom96> quicksilver: http://hpaste.org/40763/json
08:58:42 <joe1> is there any reason why "printf . report lineno $ line" is better than  "printf $ report lineno line"
08:59:01 <joe1> report :: Int -> String -> String
08:59:41 <quicksilver> dom96: I don't think Text.Generic.JSON is designed to allow you to say "actually, stop here, and just return this part as a JSValue"
09:00:43 <dom96> quicksilver: So i can't use it then? How should I get the data then?
09:00:51 <ski> joe1 : i would probably prefer `printf (report lineno line)' (at least given no more context)
09:01:06 <quicksilver> to be honest, dom96, I'd just do it the simple way
09:01:13 * ski thinks it is ugly to overuse `$'
09:01:15 <dom96> quicksilver: which is?
09:01:25 <quicksilver> just pull the fields out and stuff them in.
09:01:45 <Honeyman> Hello. Maybe I am missing something, but... isn't there any way (maybe, GHC-specific) to define a type synonim for a function? Something like  newfunctype comparator = (Ord a) => a -> a -> Bool
09:01:53 <dom96> quicksilver: how do i do that?
09:02:13 <ski> Honeyman : you can define `type Comparator a = Ord a => a -> a -> Bool', if you want
09:02:33 <ski> Honeyman : though possibly you really wanted `type Comparator a = a -> a -> Bool'
09:03:13 <ski> Honeyman : alternatively, instead of making it a type synonym, you might instead want to make a `data' or a `newtype' (this depends on what you're trying to do)
09:03:55 <ArizonaPeachTea> Hello everybody, I was wondering if there are any professional organizations oriented in functional programming or just software engineering specifically that you would suggest to join?
09:04:16 <ArizonaPeachTea> -6
09:04:34 <Lemmih> Like a union?
09:05:00 <quicksilver> dom96: case jsvalue of JSObject jso -> RPCRequest { method = fromJSString (fromJust $ get_field "method" jso), params = fromJust $ get_field "params" jso, .... and so on}
09:05:04 <ArizonaPeachTea> +Yea, like IEEE. But I don't know which society of IEEE for example to join.
09:05:20 <quicksilver> dom96: although I wouldn't really use 'fromJust', and I'd put error checking in.
09:06:02 <dom96> quicksilver: ahh, thanks. I've never seen get_field being used.
09:06:12 <dom96> Hopefully this will help me :)
09:07:40 <quicksilver> dom96: such code is slightly repetative and the 'generic' stuff is about automating it.
09:07:47 <quicksilver> dom96: but it's not that bad when you only have 4 fields.
09:07:51 <Philippa> ski: too $ I $ think $ (ugly $ it)
09:07:52 <Honeyman> ski: Generally, I am thinking about the typing for the set of functions which work on a list, but using a comparator function like (>) as an operand. Kind of, what should be the type of "a" in "let compares a = zipWith a". The derived type is kinda huge, I thought if there is a simpler way to maintain the types...
09:08:25 <dom96> quicksilver: well, i have more, i'm gonna have to parse the objects in that Array too. But i can do that with the 'generic' stuff i hope.
09:09:17 <ski> Honeyman : it is not clear to me what you're tying to do
09:09:33 <ski> `let compares a = zipWith a' is the same as `let compares = zipWith'
09:09:56 <ski> Philippa :)(
09:10:24 <Honeyman> ski: Right. And I want the "compares" function to be more specified so it can accept the functions like (>) and (>=) for "a" argument, but cannot accept the functions like (+)
09:10:48 <ManateeLazyCat> Hi all. :)
09:11:02 <ski> Honeyman : it can still accept `\_ _ -> False' ..
09:11:12 <Honeyman> But it is possible I am thinking in non-Haskell way...
09:11:45 <ski> Honeyman : i suppose `type Comparator a = Ord a => a -> a -> Bool', might be what you're after, then
09:11:52 <ski> (iirc, that requires some extension)
09:12:47 <ski> Honeyman : so then you say `foo :: forall a. Comparator a -> [a] -> ..a..', i suppose (where you can omit the `forall a. ', if you want)
09:12:49 <Honeyman> ski: -XRankNTypes probably. Thanks, let me investigate this into details...
09:13:17 <ski> hm
09:13:51 <ski> i suppose `foo :: forall a. Comparator a -> [a] -> ..a..' by itself is probably not that useful
09:14:33 <philosopher> is there an haskell 2011 planned ?
09:14:37 <ski> `foo :: forall a. Ord a => Comparator a -> [a] -> ..a..' would be more useful .. but maybe you're trying to avoid mentioning `Ord a' here ?
09:15:11 * ski wonders whether `type Comparator a = Ord a *> a -> a -> Bool' would be more useful ..
09:17:03 <ski> Honeyman : one variant would be to say `type Comparator = forall a. Ord a => a -> a -> Bool', then you could pass `(>)' as well as `(>=)' to `foo :: forall a. Ord a => Comparator -> [a] -> ..a..', but you can't pass something like  (>) `on` fst
09:17:41 <ski>   (>) `on` fst :: forall a b. Ord a => (a,b) -> (a,b) -> Bool
09:19:46 * ski idly wonders how hard it would be to change the syntax so that `foo \x -> ..x..', would be interpreted as `foo (\x -> ..x..)', and not just that `foo >>= \x -> ..x..' is interpreted as `foo >>= (\x -> ..x..)'
09:20:17 <ski> (that would remove some common uses of `$')
09:20:47 <Jafet> How would you know where the lambda ended
09:21:23 <quicksilver> it would at the latest time it could
09:21:32 <quicksilver> end of the expression or next closing delimeter
09:21:45 <quicksilver> this is how lambda is traditionally understood in maths 
09:21:48 <quicksilver> "scopes all the way to the right"
09:21:59 <ski> iirc, Agda does this
09:22:02 <quicksilver> I have a feeling it's called "the Church Dot"
09:22:03 <Jafet> Doesn't sound that useful then, unless you're in APL
09:23:04 <quicksilver> ski: I'm not really sure why ">>= \x" works and "foo \x" doesn't
09:23:07 <quicksilver> ski: I have wondered before.
09:24:20 <conal> hm. i wonder, too.  one of my std mistakes is forgetting that juxtaposition is treated differently from other infix ops in this regard (foo \ x -> ...)
09:24:35 <aristid> everybody interested in the fun world of xml now wait for hackagebot announce something! :D
09:24:44 * quicksilver stares breathlessly at hackagebot 
09:24:56 * hackagebot xml-monad 0.1 - Monadic extensions to the xml package.  http://hackage.haskell.org/package/xml-monad-0.1 (AristidBreitkreuz)
09:25:13 * sm gives hackagebot a biscuit
09:25:24 <quicksilver> I hate that hackagebot announces stuff but the haddock isn't built
09:25:28 <quicksilver> so you can't actually find out what it does
09:25:31 <aristid> yes :/
09:25:43 <quicksilver> (if the package doesn't have a homepage yet, or previous documented versions)
09:25:55 <aristid> also i should have put a homepage field in there that at least links to github
09:26:11 <aristid> there: http://github.com/aristidb/xml-monad
09:26:11 * conal wishes more people had read & embraced Landin's "The Next 700 programming languages" before the spread of xml. :(
09:26:20 <sm> hmm.. hackage should build the haddock before accepting an uploaded package ?
09:26:28 <aristid> conal: so that xml would not have spread?
09:26:43 <aristid> sm: well, hackagebot could defer the announcing until it has been built
09:26:51 <aristid> sm: or announce a second time when it is built
09:26:54 <ksf> ...or failed.
09:26:56 <conal> aristid: so that whatever did spread would be more elegant & powerful.
09:27:23 <Funktorsalat> sm: as a workaround, just cabal install --documentation=true it yourself
09:27:28 <conal> as a metalanguage 
09:27:40 <sm> aristid: that would complicate it, it's a simple feed announcer
09:28:15 <aristid> conal: i suppose reading that paper is never too late? :D
09:28:44 <conal> aristid: it's a gem, though the details are dated.
09:28:44 <Funktorsalat> hmm you think xml is bad?
09:29:06 <Funktorsalat> it may well be that there is something more elegant and powerful :)
09:29:11 <Funktorsalat> but didn't think it's tooo bad
09:29:25 <quicksilver> it is better to have it than not to have it
09:29:28 <aristid> Funktorsalat: it's just a bit of an incoherent mess
09:29:31 <quicksilver> but it has all kinds of strange quirks
09:29:47 <quicksilver> which really aren't needed to fulfill the simple goal of extensible serializable data format
09:29:51 <conal> and lacks basic properties of a solid metalanguage.
09:29:59 <quicksilver> something simple based on sexps would have worked fine
09:30:01 <aristid> Funktorsalat: for example, namespaces are a nice idea, but not implemented nciely
09:30:09 <quicksilver> (which has been observed many times by many people smarter than me)
09:30:20 <Funktorsalat> aristid: hmm ok, I just ignored them for the simple things I did so far ;)
09:30:34 <conal> read "Next 700" and imagine ISWIM replacing xml.
09:30:38 <ksf> I've yet to see a flawless data language.
09:30:43 <aristid> i had fun with amazon sometimes returning RequestID and sometimes RequestId as a tag
09:30:50 <ksf> it _should_ be that simple...
09:30:51 <Funktorsalat> "I someone who isn't me"?
09:31:03 <quicksilver> the most incomprehensible thing about XML as a generic semi-structured format is attributes
09:31:03 <aristid> and sometimes they send their tags with xmlns, sometimes without
09:31:07 <quicksilver> what are they for?
09:31:14 <aristid> quicksilver: more succinct syntax
09:31:17 <conal> and then fast forward to the modern day descendent of ISWIM (Landin's metalanguage in Next 700).
09:31:23 <ksf> define sum and product types, be done with it.
09:31:30 <quicksilver> aristid: bad reason ;)
09:31:40 <aristid> quicksilver: well it's based off a markup language
09:31:44 <quicksilver> I know.
09:31:45 <ksf> and, most importantly, do it in binary, and then define a "customary" text format on top of it.
09:31:46 <aristid> where attributes do kinda make sense
09:32:02 <quicksilver> ksf: I don't think that's important.
09:32:05 <quicksilver> or even a good idea.
09:32:06 <aristid> ksf: nah, define it in abstract.
09:32:26 <quicksilver> define it in abstract with a customary text representation
09:32:32 <quicksilver> feel free to add a customary binary rep too.
09:32:40 <erikc> xml exists because there's enough people that think parsing is hard
09:32:41 <aristid> and then add a text format on top of that
09:32:41 <aristid> binary sucks
09:32:54 <ksf> protocol buffers come close, but it doesn't do sum types.
09:33:05 <quicksilver> erikc: no argument there; it's just that there are plenty ways to define a generic parseable format
09:33:12 <Funktorsalat> quicksilver: I dislike the arbitrary choice you often have about <a b="c"/> vs <a><b>c</b></a> as well if you mean that
09:33:20 <quicksilver> erikc: and XML is not even close to the occams razor.
09:33:25 <quicksilver> Funktorsalat: yes, that's exactly what I mean.
09:33:27 <ksf> binary is usually way easier to parse.
09:33:34 <Funktorsalat> opportunity for arbitrary choices for no good reason = bad
09:33:41 <Funktorsalat> (bug-prone etc)
09:33:47 <quicksilver> ksf: perhaps, but the *main* point is that most consumers don't write the parser
09:33:53 <quicksilver> most consumers use a library parser
09:33:56 <ksf> the only easily parsable text format is bencoding, and that's not humanely readable.
09:34:05 <quicksilver> only people with special needs (perhaps speed?) write their own parser
09:34:11 <quicksilver> and such people are probably going to do it well anyway.
09:34:20 <ksf> I'm talking about processing overhead.
09:34:29 <quicksilver> Funktorsalat: (a (b "c"))
09:34:34 <ksf> ...and space usage.
09:34:40 <quicksilver> Funktorsalat: encapsulates both options just fine.
09:34:45 <ksf> the web would be way faster if html was binary.
09:34:51 <Funktorsalat> quicksilver: (a :b "c") *troll* :)
09:34:58 <aristid> ksf: of course binary is easy to parse. but humans being able to read the format directly is really worth something
09:35:09 <quicksilver> Funktorsalat: ;)
09:35:18 <quicksilver> ksf: I don't think that's true.
09:35:26 <ksf> ...that's why there needs to be an unambigious bijection between those two.
09:35:30 <quicksilver> ksf: I don't think parsing time is a major component of web slownes
09:35:38 <aristid> btw. i did not write xml-monad because i love xml
09:35:44 <quicksilver> and in those palces where bandwidth is an issue, compression is normally used
09:35:45 <aristid> but because amazon sends xml whether i want or not
09:36:01 <quicksilver> compressed HTML is not that far off the size you'd get with a careful binary format.
09:36:43 <quicksilver> Funktorsalat: if you mean to say 'sexp encodings have arbitrary choices too' then, yeah, I don't disagree.
09:36:55 <quicksilver> Funktorsalat: but at least one baffling choice is removed.
09:37:06 <aristid> this is actual code using xml-monad: http://hpaste.org/40764/parse_aws_responses_using_xml
09:37:06 <Funktorsalat> ksf: I think parsing binary is often more pleasant because you have to blindly trust the layout instead of 75% of your code being "if (myXmlReader.Current.NodeType != XmlNodeType.Element) throw new Exception("Expected a node type here");"
09:37:08 <ksf> binary would get rid of quirks mode.
09:37:24 <aristid> it's used for parsing responses from AWS
09:37:26 <Funktorsalat> err, "expected an element node here"
09:37:29 <ksf> no more <a><b></a></b> because you just can't express that.
09:38:19 <aristid> Funktorsalat: well, that is an issue of poor xml APIs, which i hope to address with xml-monad :)
09:38:50 <quicksilver> ksf: yes, but binary is not unique in having that advantage
09:38:55 <quicksilver> ksf: (a (b))
09:39:05 <merijn> Some people I know are of the opinion that in any given language it is easier to implement your own s-expr parser then figure out existing XML libraries :p
09:39:22 <quicksilver> merijn: ...but that's no use if you have to process amazon XML responses.
09:39:41 <quicksilver> merijn: or, more generally, if oyu have to interact with any of the millions of third parties who have chosen XML as their interchange format.
09:39:45 <merijn> quicksilver: Eh...why not?
09:39:59 <merijn> You realize XML are just fancy s-exprs, right?
09:39:59 <quicksilver> merijn: you can't use a s-expr parse to parse amazon XML ?
09:40:14 <Funktorsalat> aristid: yeah, that iterator-like XmlReader is clearly missing some abstraction, though I'm not quite sure what exactly
09:40:17 <quicksilver> I realise the sense in which that is true, and indeed the sense in which it is false.
09:40:27 <aristid> Funktorsalat: have you read my hpaste?
09:40:37 <merijn> quicksilver: Well, the added notation is pretty trivial
09:40:39 <Funktorsalat> nop
09:40:51 <ksf> haxml has a schema compiler, which is very nice.
09:40:53 <aristid> Funktorsalat: so you have no excuse, here's the link: http://hpaste.org/40764/parse_aws_responses_using_xml :P
09:41:07 <ksf> ...iff you have a schema and the xml you process is well-formed.
09:41:15 <ksf> in the end, everything looks like tagsoup.
09:42:00 <merijn> ksf: In the end we live in a messy world
09:42:02 <aristid> ksf: i guess in rather a lot of the cases the xml is not actually conforming to the schema, because nobody ever validates it, because that wastes computing resources
09:42:09 <merijn> Messy reality even
09:42:17 <aristid> merijn: exactly, and we have to find the best ways to deal with that.
09:42:18 <ksf> ...and because xml schema are a PITA
09:42:22 <merijn> Which is why I'm betting on probabilistic algorithms in the future
09:42:28 <erikc> xml formats usually evolve into programs that require AST walking interpreters to execute
09:42:37 <merijn> neural networks and evolutionary computing, baby!
09:42:48 <erikc> (see the complete mess that is COLLADA)
09:42:53 <Funktorsalat> I admit I quite like how visual studio uses schemata to provide autocompletion though
09:43:22 <Funktorsalat> (e.g. if you're in a <foo> tag it may look at the schema to suggest a <subfoo> tag)
09:43:43 <aristid> Funktorsalat: it's almost like a typed format ;)
09:43:49 <erikc> lol
09:44:03 <Honeyman> Yet another question: is it possible somehow to deal with functions as elements of Eg? Kind of, is it possible to create a single-argument function that returns (>) for argument (<), and (<) for argument (>)?..
09:44:45 <Honeyman> Or is it waaay to non-Haskell, as I am deemed to suppose?
09:44:55 <Honeyman> s/to/too/
09:45:13 <Funktorsalat> aristid: I don't quite get the essence of your last message, I think :)
09:45:32 <conal> Saizan: ping
09:45:41 <aristid> Funktorsalat: the message was you should read it :D
09:45:54 <Funktorsalat> (yes, it is more or less typed... but are you saying there are much better typed formats, or ...)
09:46:01 <ksf> so, just use GADTs and invent a binary serialisation?
09:46:06 <aristid> oh that message
09:46:20 <aristid> i forget what i say after saying it :/
09:46:40 <ksf> oh, and a reduced implementation of the textual syntax that only supports constants and type checking.
09:46:49 <ksf> ...haskell without functions.
09:47:05 <Funktorsalat> aristid: hmm the first thing I notice is that you have "findElement" functions... the naive implementation of that is O(n^2), of course
09:47:16 <Funktorsalat> but I assume you have some optimization behind the scenes
09:47:47 <aristid> Funktorsalat: these elements are very top-level
09:48:22 <Funktorsalat> (the microoptimization-obsessed prefer to linearly iterate through the xml and use each element as you find it, of course :))
09:48:24 <aristid> Funktorsalat: and it's not performance-optimised at all. why should it? also, the XML files are very short. typically a few hundred bytes.
09:48:46 <ksf> Funktorsalat, that's the proper way to process it, yes.
09:48:49 <Funktorsalat> but it'd be nice to have a monad that converts the findElement style to a linear iteration
09:48:50 <ksf> cf. nested word automata.
09:49:05 <ksf> you don't even need to go pushdown.
09:49:06 <aristid> Funktorsalat: well that is possible i guess
09:49:10 <aristid> Funktorsalat: using guard or so
09:49:11 <Funktorsalat> (it'd probably have to construct some abstract tree and "compile" it)
09:49:32 <aristid> but so far i don't need that, and haven't implemented it
09:49:57 <aristid> Funktorsalat: but it's quite readable, no?
09:50:06 <merijn> ksf: Haskell without functions = Olegskell? :>
09:50:20 <merijn> Just solve all your problems in the type system...
09:50:43 <Funktorsalat> aristid: yes, maybe I sounded too negative (as you say, it often doesn't matter)
09:51:21 <ksf> well, the other possibility would be to rip out the IO monad, that is, any method of giving input to the system.
09:51:24 <aristid> Funktorsalat: often, the worst algorithms are good enough, and you should spend your time on more important things
09:51:36 <ksf> ...but then I think most people want their data format to be strongly normalizing.
09:52:06 <Funktorsalat> aristid: hmm, but it may become significant later on and then you may have no time to switch to a good algorithm
09:52:07 <ski> Honeyman : `flip (>) = (<)' and `flip (<) = (>)' (at least modulo partial input)
09:52:20 <Funktorsalat> leading to annoyingly slow software *rolls eyes*
09:52:27 <aristid> Funktorsalat: that's too much of a hypothetical fear for me.
09:52:29 <roconnor> @seen ksf
09:52:30 <preflex>  ksf was last seen on #haskell 53 seconds ago, saying: ...but then I think most people want their data format to be strongly normalizing.
09:52:31 <ski> Honeyman : so, pass your input to `flip' to get the "other" one ?
09:52:44 <roconnor> ksf: oh, you are here
09:53:03 <Honeyman> ski: Oh :)
09:53:21 <ksf> allegedly I am, yes.
09:53:21 <ski>   flip :: forall a b c. (a -> b -> c) -> (b -> a -> c)
09:53:26 <roconnor> ksf: You changed the darcs repository location on this page in Feburary:  http://www.haskell.org/haskellwiki/Yhc/Building
09:53:36 <ksf> yep
09:53:42 <roconnor> ksf: I think the darcs link is wrongish maybe
09:53:46 <aristid> ski: how would flip and ($) look like with your exists stuff?
09:53:47 <Honeyman> That's quite a bit simpler :)
09:53:54 <ksf> ...the old one was dead, and that's the closest I found.
09:53:59 <roconnor> ksf: at least compared to http://community.haskell.org/~ndm/yhc/
09:54:08 <roconnor> I mean the one listed on that page
09:54:15 <roconnor> # darcs get --partial http://www.cs.york.ac.uk/fp/darcs/yhc/
09:54:22 <Funktorsalat> aristid: hey, I even use binary search for arrays that in the current application contain anywhere from 2 to 4 elements
09:54:22 <roconnor> But it is confusing
09:54:24 <Funktorsalat> ;)
09:54:30 <ski> aristid : `flip' would have the same type, since neither of `a',`b',`c' can be quantified "further inwards"
09:54:41 <Funktorsalat> (but it's a library function, so why not)
09:54:42 <roconnor> since the repo you gave did have relatively recent patches
09:54:55 <aristid> Funktorsalat: that might actually slow things down :D
09:54:58 <ksf> roconnor, well, feel free to do anything you want about that link.
09:55:07 <Funktorsalat> aristid: yes. it is for futureproofness
09:55:08 <roconnor> feel free?
09:55:10 <roconnor> :)
09:55:14 <roconnor> I know nothing about yhc
09:55:20 <ski> aristid : `($) :: forall a b. (a -> b) -> a -> b' would also be the same, but `uncurry ($)' could get type `forall b. (exists a. (a -> b,a)) -> b', i think
09:55:21 <aristid> Funktorsalat: i think haskell makes it reasonably easy to change things later
09:55:23 <roconnor> but I'll change it to the link on ndm's page
09:55:32 <ksf> me neither. I just downloaded it once to try out the javascript backend.
09:55:48 <ksf> or just list both repos.
09:56:35 <aristid> ksf: have you seen ghcjs? :D
09:56:41 <ski> aristid : of course, in cases like this, where the type is the same as the one you'd infer by inserting the quantifiers, you could probably still present it as `uncurry ($) :: (a -> b,a) -> b'
09:57:05 <ski> (aristid : so hopefully no need to confuse newbies with `exists' when reporting the type, here)
09:57:10 <ksf> last time I looked, the yhc implementation was the only functional one
09:57:20 <ski> (nor `forall' for that matter)
09:57:30 <aristid> ski: right, i am confused already
09:57:31 <ksf> ...and it's a true compiler, that is, doesn't come with a stg interpreter implemented in javascript
09:58:08 * ski thinks GHC should refrain from using `forall' when asked for types, in cases where the type is equivalent to the Haskell98 (or Haskell2010, i suppose) type
09:58:24 <ski> aristid : hehe .. what is confusing ?
09:58:42 <Philippa> it should, yes, it's unnecessarily confusing - especially when it's in Haskell98/2010 mode
09:59:09 <aristid> ski: um. not sure :D
09:59:35 <Funktorsalat> aristid: a compromise (between O(n^2) and the "compiled" declarative way) would be to have a first pass parsing each level into a Map, no?
09:59:38 <ski> you shouldn't need to understand the extension `forall', just to understand a Haskell(98|2010) program (or type errors in it)
10:01:00 <aristid> Funktorsalat: right, that might be a more efficient representation, adding an element cache
10:01:03 <Funktorsalat> (very simplistically (disregarding attributes, namespaces etc) data Xml = ([Text],Map String Xml))
10:01:06 <aristid> "cache"
10:01:25 <aristid> Funktorsalat: and lazy evaluation could also keep the costs for that down, except map has a strict spline afaik
10:01:36 <Funktorsalat> but that may actually slow things down too for very few elements
10:01:55 <aristid> Funktorsalat: i use 'xml' as the backend though, and that has a very simple data structure
10:02:40 <aristid> Funktorsalat: another possibility would be to use findChild instead of findElement, as that does not do deep searches
10:03:00 <aristid> Funktorsalat: but then i need to go down to the exact level and parse all the junk in the xml
10:03:36 <Funktorsalat> oh. I assumed findElement is findChild :)
10:03:40 <aristid> also it still needs linear searches for the element
10:03:56 <aristid> Funktorsalat: why did you say O(n^2) then? linear searches in a list of elements are O(n)
10:04:23 <Funktorsalat> aristid: for retrieving n named children from a list of n children
10:04:48 <aristid> Funktorsalat: huh? i only retrieve 1 element per findElementNameUI
10:05:03 <Funktorsalat> aristid: yes. I mean for the typical case of parsing a whole record which has n elements
10:05:09 <aristid> "UI" stands for Unqualified Case-Independent
10:05:19 <Funktorsalat> this is O(n) if you iterate over the xml and fill the record up
10:05:27 <Funktorsalat> but O(n^2) using findChild
10:05:43 <aristid> Funktorsalat: well in that case, yes. i don't parse the full xml tho. it contains some junk
10:05:50 <Funktorsalat> (assuming constant-cost string comparison ;))
10:06:05 <aristid> i tried if the junk makes any sense, but the java and ruby libraries supplied by amazon don't deal with it either
10:06:10 <aristid> that's so typical xml :D
10:06:58 <Funktorsalat> er, or constant-cost string lookup, actually
10:07:02 <aristid> Funktorsalat: for example the BoxUsage element is not always at the same position in the tree. and there is an <Errors> element around <Error> that always contains exactly one <Error>
10:07:54 * ski suspects XML would have needed more bondage-and-discipline, to avoid some of the mess
10:08:16 <Funktorsalat> so I guess filling a record of n named elements is O(n*log(n)) if you count string lookup as O(log(n))
10:08:25 <Funktorsalat> (not O(n) as I said)
10:08:30 <aristid> ski: it should have been statically typed :D
10:08:36 <osaunders> What is the precedence level of an infix function by default?
10:08:39 <aristid> ski: and not just an optional xml schema
10:08:41 * ksf still likes the idea of promoting GADTs to a data exchange format
10:09:13 <ksf> I bet they're powerfull enough to express all HTML invariants (unlike xml schema)
10:09:15 <Funktorsalat> ksf: GADTs not holding function types anywhere, I assume :p
10:09:20 <ksf> yep.
10:09:22 <aristid> ksf: GADTs are just a sum-of-product type with existentials, or am i misisng something?
10:10:06 <ksf> yes, all the type tricks you can do with them
10:10:17 <ksf> a la Foo :: a -> b -> Bar (a,b)
10:10:45 <Funktorsalat> and Refl :: Equal a a
10:10:46 <Funktorsalat> :)
10:10:56 <Funktorsalat> (data Equal a b where Refl :: Equal a a)
10:11:06 <Funktorsalat> IIRC GADTs can be reduced to that one + existentials
10:11:14 <ksf> do we have a gadt html combinator library?
10:11:31 <aristid> oO
10:11:44 <litb> hello folks
10:12:13 <osaunders> ksf: There's blaze, I think that uses a GADT somewhere.
10:12:44 <osaunders> The main HTML data type actually, if I recall correctly.
10:12:47 <Funktorsalat> ksf: hmm what would the "G" add to the serialization?
10:13:05 <Funktorsalat> (doesn't Foo still serialize as just a pair?)
10:13:12 <magicman> Anyone know of a get-function (from the Binary package) for little-endian signed 32-bits integers?
10:13:24 <Funktorsalat> (and Refl would serialize to... nothing ;))
10:13:28 <ksf> well, about exactly nothing.
10:13:29 <magicman> The default Binary instance of Int32 reads big-endian :-/
10:13:37 <ksf> the point is a proper schema system.
10:13:41 <Funktorsalat> ah
10:14:02 <magicman> (I didn't come up with the data format either. 's Some old format I'm trying to read in)
10:14:13 <Funktorsalat> magicman: there's one in Binary.Get iirc
10:14:32 <Funktorsalat> not sure about 'signed', but there is getLittleEndian32 or so
10:14:33 <magicman> getWord32le is unsigned.
10:14:49 <ksf> blaze doesn't seem to be strictly typed.
10:15:06 <magicman> Wait, would fromIntegral-ing Word32 to Int32 overflow, and cause stuff to be all good? *goes to check*
10:15:17 <litb> Why is it called "Haskell 2010" and not "Haskell' 2010" ?
10:15:20 <Funktorsalat> magicman: right, doesn't seem to have a signed one
10:15:25 <Funktorsalat> magicman: unsafeCoerce maybe
10:15:27 <magicman> (that is, convert 2^32-1 to -1")
10:15:37 <magicman> Will try that one too :)
10:15:47 <magicman> Thanks for the tips!
10:16:34 <ksf> magicman, don't forget to check whether Int32 is two's-complement on your architecture...
10:16:34 <Funktorsalat> (but not sure if you're relying on undefined/unportable implementation details that way)
10:17:15 <Funktorsalat> unsafeCoerce works fine for efficient serialization of doubles ;)
10:17:27 <Funktorsalat> rather than the 25-byte or so default ;)
10:17:51 <magicman> Oooh, fromIntegral :: Word32 -> Int32 *does* turn 2^32-1 into -1. Good to know.
10:18:26 <magicman> ksf: How'd I go about doing that?
10:19:08 <ksf> well, adding a test whether fromIntegral works as above might be a good idea.
10:19:23 <magicman> Ah, check.
10:19:47 <ksf> ...possibly as TH, so you can error out compilation.
10:20:18 <ksf> or fallback to an inefficient implementation
10:20:53 <ksf> you could also read the haskell2010 spec, Int32 _might_ be defined to use 2's complement.
10:23:31 <magicman> From the report: "Coercing word types (see Data.Word) to and from integer types preserves representation, not sign."
10:23:52 <magicman> So it seems like I'm good :)
10:23:56 <magicman> Thanks for the help!
10:26:33 <roconnor> I'm not sure this Uniplate, or rather this Biplate stuff works for mutually recursive data types.
10:30:19 <roconnor> is Sebastian Fischer on IRC?
10:30:30 <pumpkin> preflex: seen sebfisch
10:30:31 <preflex>  Sorry, I haven't seen sebfisch
10:30:35 <pumpkin> hmm
10:30:39 <pumpkin> I thought I'd seen that nick around
10:32:08 <y0-> Hello everyone
10:32:39 <astroboy> Is there a way to get some sort of traceback of errors? for example I am using maps and i get a "element not found" error, can I see what was the key that generated the error?
10:33:07 <ksf> try Debug.Trace
10:33:19 <astroboy> ksf: thanks, i'll check it out
10:33:30 <ksf> oh, and don't use functions that call error, ever.
10:33:36 <ksf> :t Map.lookup
10:33:42 <joe1> let test line = [ drop 2 hexWord | hexWord@['0','x',x,y] <- words line, isHexDigit x && isHexDigit y] where line = ">>>>> 0x2D setup pid 0x80 bmRequestType device standard 0x06 bRequest GET_DESCRIPTOR"
10:33:43 <ksf> @slap lambdabot
10:33:55 <joe1> is there a better way of writing the above list comprehension?
10:34:14 <joe1> i am using drop 2 to drop the first 2 letters ie 0x
10:34:21 <roconnor> ksf: you don't every call (/) ?
10:34:26 <roconnor> *ever
10:34:36 <ksf> something like "maybe (error "This shouldn't happen @Foo.hs:funname") id $ lookup mymap mykey
10:34:42 <roconnor> ksf: or `div`
10:34:42 <pumpkin> joe1: can't you just use reads?
10:34:49 <ksf> roconnor, rarely.
10:34:57 <pumpkin> > reads "0x5e" :: [(Int, String)]
10:34:58 <hsbot>   [(94,"")]
10:35:12 <roconnor> ... granted I sort of think x `div` 0 should return 0
10:35:24 <ksf> I generally consider anything above semirings as suspect.
10:35:40 <roconnor> ksf:  not much use for Integer I see.
10:35:43 <roconnor> that is fair
10:35:44 <joe1> pumpkin: i am not using the number, I just need it as a string though without that 0x prefix
10:35:59 <roconnor> Using Integers is a sign of poor code.
10:36:29 <pumpkin> I like Integer more than Int or related types
10:36:52 * ksf likes Integral a => a
10:36:53 <pumpkin> I'd prefer my functions not to break on fairly large numbers
10:37:04 <ksf> and would prefer Natural a => a
10:37:05 <zygoloid> roconnor: i sort of agree. (re x `div` 0 should give 0).
10:37:26 <ksf> *shudder*
10:37:32 <ksf> 0 * 0 = anything?
10:37:40 <zygoloid> in number theory, 0 and infinity have lots of properties in common :)
10:37:48 <roconnor> ksf: at the same time it is important to defined x `mod` 0 to be x
10:37:58 <ksf> don't get formalistic on me, young mister.
10:38:40 <roconnor> oh wait
10:38:54 <roconnor> maybe x `div` 0 doesn't need to be 0.
10:39:19 <ksf> it's bleeding +-infinity, if anything.
10:39:33 <roconnor> all we want is x = 0*(x `div` 0) + (x `mod` 0)
10:39:54 <aristid> roconnor: x `div` 0 might as well be _|_
10:39:57 <roconnor> ya
10:39:59 <aristid> > 1 `div` 0
10:39:59 <hsbot>   *Exception: divide by zero
10:40:02 <roconnor> so it should stay 0
10:40:03 <aristid> and it is!
10:40:12 <roconnor> we just need to make * short-curcut
10:40:19 <roconnor> which seems fair to me :)
10:40:44 <aristid> roconnor: then _|_ * 0 still is not 0
10:40:48 <aristid> hmm
10:40:53 <ksf> roconnor, I think we have a presburger solver somewhere on hackage for those of your ilk.
10:40:54 <zygoloid> 0 is divisible by every prime, therefore 2 * 3 * 5 * ... | 0, so 0 = k * infinity ;)
10:41:01 <aristid> no, there's no way to short-circuit from both sides
10:41:13 <ksf> but don't ever claim to be working with actual values.
10:41:18 <roconnor> aristid: not without par
10:41:31 <aristid> roconnor: oh right, that might work
10:42:04 <roconnor> Haskell should spark a thread for every multiplication!
10:42:25 <magicman> > undefined && False
10:42:26 <hsbot>   *Exception: Prelude.undefined
10:43:11 <Jafet> > False && undefined
10:43:12 <hsbot>   False
10:45:37 <aristid> > undefined || True
10:45:39 <hsbot>   *Exception: Prelude.undefined
10:45:43 <aristid> ZOMG
10:46:10 <picatrix> http://hpaste.org/40765/networkbrowser_example
10:47:06 <picatrix> hey gang (int80_h) here. I've had my name taken. I was thinking about abandoning it anyway.
10:47:17 <picatrix> I haven't made this one official yet
10:47:47 <picatrix> If you could take a look at the above hpaste, that would be groovy.
10:49:06 <aristid> picatrix: you're using a paste to show a link?
10:49:40 <picatrix> should I just paste the code in? That makes more sense. Hold on.
10:51:16 <aristid> preflex: seen int80_h
10:51:16 <preflex>  int80_h was last seen on #haskell 4 days, 21 hours, 49 minutes and 19 seconds ago, saying: not much so far but I'm looking
10:51:31 <picatrix> yeah that is me
10:51:39 <picatrix> some guy from germany took my name
10:51:51 <bremner> interupted your use did he?
10:51:54 <picatrix> I don't want to fight for it. I was going to ditch it anyway
10:52:03 <picatrix> yeah
10:52:16 <picatrix> aristid: okay I annotated with the pasted code
10:52:47 <aristid> preflex: i don't see no annotation
10:53:40 <theorbtwo> picatrix: nickserv this time?
10:53:51 <picatrix> aristid: http://hpaste.org/paste/40765/the_blog_example#p40766
10:53:59 <picatrix> nickserv?
10:54:14 <picatrix> oh you want me to authenticate?
10:54:48 <Makoryu> "Information on int80_h (account int80_h): Registered : Nov 20 01:38:46 2003 (6 years, 48 weeks, 2 days, 16:14:57 ago)"
10:55:02 <Makoryu> picatrix: Do you still have your old password?
10:56:31 <picatrix> it says it's already in use
10:56:45 <picatrix> yeah I'll bet it was snarfed
10:57:00 <picatrix> oh crap, I'm prolly logged in at home
10:57:05 * picatrix is dumb
10:58:18 <jmcarthur> picatrix: you could ghost it
10:59:05 * osaunders misses lambdabot
10:59:23 <picatrix> how do I ghost it?
10:59:23 <jmcarthur> picatrix: /msg nickserv ghost int80_h <password>
10:59:27 <picatrix> cool
10:59:51 <jmcarthur> should kick you off at home so you can use it
11:00:20 <conal> maybe /query nickserv and then do the "ghost" command.  so you can't accidentally share your password here.
11:00:25 <conal> speaking from experience :/
11:00:35 * hackagebot mwc-random-monad 0.1 - Monadic interface for mwc-random  http://hackage.haskell.org/package/mwc-random-monad-0.1 (AlexeyKhudyakov)
11:00:37 <jmcarthur> conal: heh. i've done it too
11:00:43 <turiya> hi
11:00:48 <conal> jmcarthur: heh.
11:01:03 <ulfdoz> Nee, das eher nicht.
11:01:08 <ulfdoz> ewin, sorry.
11:01:13 <int80_h> okay I'm for realz now
11:01:15 <turiya> how do I use surfaceGetPixels in the SDL module?
11:01:17 <jmcarthur> yay
11:01:31 <int80_h> now I shall post my annotation
11:01:49 <int80_h> http://hpaste.org/paste/40765/the_blog_example#p40766
11:01:53 <int80_h> there you are
11:03:02 <int80_h> I really found that blog post useful, except it seems libcurl might be buggy. Not sure what the problem is. But I think if I could get a feel for network.browser I could do okay.
11:03:49 <turiya> is there any good image loading library for haskell?
11:04:37 <ski> litb : afaiu "Haskell'" is the name of the perpetual process of revising the standard
11:04:38 <ski> roconnor : "x `div` 0 should return 0" *argh* ! .. i agree with "x `mod` 0 to be x", though
11:04:54 <int80_h> ZOMG ski!
11:04:59 <ski> zygoloid : well, `0' is the greatest element wrt the divisiblity ordering, so ..
11:05:04 <ski> lo int80_h
11:05:20 <int80_h> hiya, would you help me with my project?
11:05:24 <ski> (zygoloid : which is incidentally wht `gcd 0 0' should be `0')
11:08:06 <Firegolf1r> How can I truncate a float?
11:08:27 <Lemmih> Firegolf1r: round, floor, ceiling.
11:08:43 <Firegolf1r> round takes RealFrac
11:09:25 <Lemmih> Firegolf1r: Right, and Float is a member of the RealFrac type-class.
11:09:35 <Lemmih> > round (10.1 :: Float)
11:09:36 <hsbot>   10
11:09:53 <ClaudiusMaximus> > truncate (10.9 :: Float)
11:09:53 <hsbot>   10
11:10:09 <Firegolf1r> Could not deduce (RealFrac t, Integral t) from the context (Floating t)
11:10:25 <Firegolf1r> > round (10.1 :: Double)
11:10:26 <hsbot>   10
11:10:32 <ClaudiusMaximus> :t fromIntegral (truncate (10.9 :: Float))
11:11:20 <Firegolf1r> roundResult :: Floating t => t -> t
11:11:21 <litb> ski: oh
11:11:22 <Firegolf1r> roundResult a = (truncate (a * 100000)) / 100000
11:11:33 <Firegolf1r> ^- that's what I want to reach ;)
11:11:40 <Firegolf1r> round a Floating t to 5 digits
11:12:29 <Lemmih> Firegolf1r: You don't really wanna do that. Just print the result to five digits.
11:13:01 <Firegolf1r> Why wouldn't I?
11:13:28 <Firegolf1r> (because it's not easily possible with Haskell?)
11:13:35 <Lemmih> Firegolf1r: Because floating point values don't really work that way.
11:13:46 <Firegolf1r> ic.
11:13:58 <ClaudiusMaximus> > (1/3) + (1/3) + (1/3) :: Float
11:13:59 <hsbot>   1.0
11:14:02 <Lemmih> Firegolf1r: It is possible in Haskell but you don't want to do it in any language.
11:14:24 <Lemmih> > printf "%.5f" (0.123456789 :: Float) :: String
11:14:25 <hsbot>   "0.12346"
11:15:23 <Firegolf1r> ic.
11:15:24 <Firegolf1r> thx.
11:15:27 <Firegolf1r> like the c printf
11:15:39 <Lemmih> > showFFloat (Just 5) 0.123456789 ""
11:15:40 <hsbot>   "0.12346"
11:15:45 <Lemmih> Firegolf1r: Yes.
11:17:32 <ski> > showFFloat (Just 5) (pi :: CReal) ""
11:17:33 <hsbot>   Not in scope: type constructor or class `CReal'
11:17:37 <ski> bah !
11:18:52 <harlekin> What are characters like \[[23;1H called? I'd like to implement some of them in an application and don't know where to look up the definition.
11:19:57 <sm> harlekin: ansi codes, try ansi-terminal on hackage
11:20:06 <harlekin> sm, thank you. (:
11:20:23 <sm> and vty if you need more control
11:23:02 <djahandarie> Where is lambdabot?
11:23:18 <djahandarie> Cale is MIA also
11:23:38 <djahandarie> I think lispy has access to the box it runs on, but he isn't here either... lol
11:24:06 <int80_h> http://hpaste.org/40765/networkbrowser_example
11:24:20 <turiya> what is the difference between ForeignPtr and Ptr?
11:24:21 <int80_h> ^^^ is that a poorly formed question?
11:24:30 <Martty> can i has kell
11:24:32 <sproingie> ForeignPtr eats weird food and talks funny
11:24:37 <int80_h> I mean, the one I posted
11:25:06 <Lemmih> turiya: You can assign finalizers to ForeignPtrs.
11:25:38 <turiya> what are finalizers?
11:26:00 <Lemmih> turiya: Code that runs when the ForeignPtr is no longer used.
11:26:02 <FauxFaux> Like destructors, but lazy.
11:26:17 <pumpkin> dreixel: I guess I should ask in here :)
11:26:20 <turiya> Lemmih: the SDL bindings were written by you?
11:26:52 <ski> turiya : when the Haskell GC determines that the Haskell side doesn't refer to the `ForeignPtr a', then it can call the finalizer which runs some clean-up routine on the other side (e.g. C)
11:27:16 <Lemmih> turiya: Yeah.
11:29:42 <turiya> Lemmih: can you explain about the type Pixels in Graphics.UI.SDL.Types. I cannot find any stuff like data Pixels = .. etc
11:30:00 <dreixel> pumpkin: prob better, yes
11:32:26 <pumpkin> dreixel: so I want a set of "extractors" for a type like data Moo = A Int | B Int String | C like Moo -> Int and Moo -> (Int ,String) and Moo -> () (with a more consistent decomposition, obviously)
11:32:40 <pumpkin> I don't care if they fail on constructors that don't fit, cause I guarantee that in another way
11:32:44 <Lemmih> turiya: Pixels is an opaque data-type. A void* in C.
11:32:56 <int80_h> can I use simpleHTTP with postRequest to send POST data? If so, what would that look like. Example, want to send username/password
11:33:07 <turiya> oh
11:33:14 <int80_h> oh this is in reference to network.http
11:34:08 <turiya> what does Pixels contain?
11:34:29 <dbelange> pixels
11:34:30 <Lemmih> turiya: Well, pixels. The exact format depends on the pixel format.
11:34:45 <dreixel> pumpkin: that's an interesting one
11:34:59 <dreixel> pumpkin: to do something like getComponent :: (Representable a) => Int -> a -> ...
11:35:12 <pumpkin> I can deal with a Maybe on it, for constructors that don't fit
11:35:17 <dreixel> the return type depends on a and the integer
11:35:19 <pumpkin> but I'll just use fromJust as I'm positive that it fits
11:36:08 <dreixel> let me see if I can hack something together quickly.
11:36:16 <turiya> Lemmih: I dont understand how to use Pixels, can I convert it to a ForeignPtr or Ptr? I am confused..
11:36:27 <Lemmih> turiya: You're not supposed to use it.
11:37:12 <turiya> Lemmih: hmm.. u mean I cant get the pixel data?
11:39:46 <Lemmih> turiya: It's best to stay out of the internals until one has a better grasp of how they work.
11:41:41 <Lemmih> turiya: surfaceGetPixels /will/ give you the pointer to the pixel data but you can't use it for anything if you don't understand the pixel format.
11:44:08 <turiya> Lemmih: thanks for that clarification, i only wanted to test for a pixel format i already know.. i am not clear about how to use the pointer given by surfaceGetPixels
11:44:41 <Lemmih> turiya: Cast it to whatever you want.
11:45:28 <turiya> Lemmih: ok, now i see some parallels to void * :), how is casting done in haskell?
11:45:49 <quicksilver> in general, it isn't.
11:45:56 <quicksilver> in the specific case of Ptr there is castPtr
11:46:23 <Lemmih> @type Foreign.castPtr
11:46:39 <pumpkin> dreixel: thanks :)
11:46:41 <Lemmih> @bot
11:47:00 <quicksilver> surfaceGetPixels seems to be an opaque type though, is it actually a newtype Ptr?
11:47:15 <quicksilver> ah.. type Pixels = Ptr PixelsData
11:47:19 <quicksilver> you can castPtr that
11:47:32 <quicksilver> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Foreign-Ptr.html#v%3AcastPtr
11:48:15 <turiya> quicksilver: thanks, i will see how to use castPtr
11:53:22 <dreixel> pumpkin: here's a get1: http://hpaste.org/40768/generic_getter
11:53:37 <dreixel> and I hope I can generalize this in a few minutes... but it will involve type-level naturals.
11:57:51 <pumpkin> dreixel: hmm, scary :)
11:59:04 <pumpkin> is there a way to ask GHC to normalize type family applications?
12:00:01 <dreixel> pumpkin: not as far as I know
12:00:13 <dreixel> sometimes forcing type errors helps
12:06:09 <pumpkin> dreixel: I might just code up something in TH
12:06:39 <pumpkin> seems easier than trying to massage an existing TH-based tool into the shape I need it
12:10:55 <ibt> can someone point me at a good explanation of mfix/fixio/fixst or whatever?
12:11:24 <dreixel> pumpkin: TH is terrible to write and very hard to maintain
12:11:30 <dreixel> I'm happy with this code: http://hpaste.org/40769/improved_generic_getter
12:11:41 <dreixel> getComp :: (Representable a, GetComp n (Rep a)) => n -> a -> Comp n (Rep a)
12:12:22 <dreixel> given a (type-level) natural n and a value, it returns the arguments to the n-th constructor
12:15:13 * hackagebot hexpat 0.19.4 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.19.4 (StephenBlackheath)
12:16:01 <pumpkin> dreixel: that code makes sense, but the type-level number is kind of cumbersome (or even referring to constructors by index at all). I realize it's the only way to make it safe (other than a GADT which is what I was exploring yesterday)
12:16:05 <aristid> oh, hackagebot reminds me, and there is the docs finally built now: http://hackage.haskell.org/package/xml-monad-0.1 :>
12:17:05 <dreixel> pumpkin: how else can you do it?
12:18:39 <pumpkin> dreixel: if I have a GADT representation of the constructors, I can do something like data Moo = A Int | B Int String | C and use TH to generate data Repr Moo a where ReprMooA :: Int -> Repr Moo (Int, ()); ReprMooB :: Int -> String -> ReprMooB (Int, (String, ())); ReprMooC :: ReprMooC ()
12:18:57 <sproingie> Moooooooooo
12:19:06 <pumpkin> then extract :: Repr Moo a -> a, inject a -> Repr Moo a
12:19:27 <pumpkin> and an existential from Moo to Repr Moo a
12:20:05 <pumpkin> if that makes sense
12:20:42 <dreixel> pumpkin: but then you have those extra constructors which are just as cumbersome, no?
12:20:57 <pumpkin> dreixel: let me tinker with the idea and show you what I mean
12:21:00 <dreixel> ie. ReprMooA
12:21:01 <dreixel> ok
12:21:19 <pumpkin> the cumbersome would be ideally taken care of in the TH that generates the data family and associated functions (all in a type class)
12:23:37 <pumpkin> oh I can't write inject, but I don't care cause I don't need it :P
12:24:07 <dreixel> uhm... why can't you write inject?
12:24:25 <pumpkin> cause I don't tell you which constructor to use, and type may not uniquely determine it
12:24:34 <dreixel> ah, ok
12:25:18 <dreixel> but... I think I can also write something that extracts independently of the index
12:25:29 <dreixel> I thought you wanted the index to be there
12:25:35 <dreixel> but I don't think it has to
12:25:46 <pumpkin> oh, I guarantee the index indepenendetly
12:25:53 <pumpkin> I know that it contains the right types
12:26:30 <djahandarie> I swear, this fundep type-level programming is so annoying to read
12:26:58 <dreixel> I think fundep type-level programming is hard to read, yes
12:27:09 <dreixel> hence I use type families.
12:27:14 <djahandarie> :-)
12:27:16 <pumpkin> yeah, I almost always use type families too
12:27:50 <djahandarie> The Vec package on Hackage is still using fundeps
12:27:54 <djahandarie> I wonder if he is planning to change it
12:29:52 <megajosh2> Can anybody figure out why this expression won't evaluate? I'm trying to get the hang of hs-plugins
12:29:56 <megajosh2> http://hpaste.org/40770/problem_evaluating_an_expressi
12:30:19 <dreixel> pumpkin: and actually I don't think I can do it without the index... then it's really dependently-typed
12:30:28 <pumpkin> yeah
12:30:36 <pumpkin> and for DTs you want GADTs ;)
12:32:53 <pumpkin> hmm, seems like I still need to write some boilerplate with my approach
12:33:09 <osaunders> Are multi-param type classes a good idea?
12:33:10 <pumpkin> actually maybe not
12:33:17 <pumpkin> I like them for some things
12:38:43 <kmc> osaunders, in general?
12:39:35 <osaunders> NM
12:45:33 <int80_h> http://hpaste.org/40765/networkbrowser_example
12:49:14 <pumpkin> :t 5
12:51:19 <pumpkin> is ((->) r) Traversable?
12:51:59 <pumpkin> guess not
12:52:01 <megajosh2> :t arr
12:52:21 <megajosh2> Oh it's gone :C
12:52:50 <nlogax> .type arr
12:52:52 <hsbot> (Arrow a) => (b -> c) -> a b c
12:53:05 <pumpkin> shiver me timbers
12:53:16 <Saizan> pumpkin: why not "data Repr Moo a where ReprA :: Repr Moo (Int, ()); ReprB :: ReprMooB ((Int, (String, ())); ReprC :: ReprMooC ()" "extract :: Repr Moo a -> Moo -> a; inject :: Repr Moo a -> a -> Moo" ?
12:53:18 <nlogax> i put it in here until lambdabot returns
12:53:26 <megajosh2> Ah, okay
12:53:32 <nlogax> but it's not a lambdabot so it doesn't do all the same things
12:53:34 <sipa1024> is it still dead?
12:53:36 <Saizan> pumpkin: d'oh, extract won't work
12:54:04 <pumpkin> ?
12:54:58 <pumpkin> oh
12:55:02 <Saizan> with my version of Repr you could call (extract ReprA C) which wouldn't be able to produce an (Int, ())
12:55:29 <int80_h> any love for my problem?
12:56:49 <bos> type families: turning things that were hard into co-things that are co-hard
12:58:18 <Saizan> int80_h: what kind of errors in the docs?
12:59:04 <int80_h> Saizan, I will post. The erros are slight. But nevertheless I don't get the fleshed out example like in the blog I referenced. Hold on for post
12:59:28 <Saizan> http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/HTTP-4000.0.9#direct <- anyhow, you could look at some of these packages for examples
13:02:00 <int80_h> saizan: http://hpaste.org/40765/networkbrowser_example
13:02:06 <int80_h> saizan: sweet!
13:03:30 <ManateeLazyCat> Dear gtk2hs user, we have ready to release next version : gtk2hs-0.12.0
13:03:30 <ManateeLazyCat> Please pull gtk2hs darcs to test, if no bug report, we will release.
13:03:30 <ManateeLazyCat>  
13:04:08 <ManateeLazyCat> You can use below commands (Debian) to install gtk2hs darcs:
13:04:08 <ManateeLazyCat> darcs get --lazy http://code.haskell.org/gtk2hs/ && cd ./gtk2hs && sudo chmod +x ./bootstrap.sh && ./bootstrap.sh 
13:04:08 <ManateeLazyCat>  
13:04:35 <ManateeLazyCat> Thanks!
13:10:26 <ClaudiusMaximus> ManateeLazyCat: i'll give it a go; but my application is quite simple so might not prove an absence of bugs
13:11:01 <ManateeLazyCat> ClaudiusMaximus: Any test are welcome! :)
13:11:48 * ksf wonders whether GADTs are actually expressive enough to express the HTML5 spec. at least concisely, that is.
13:12:30 <ManateeLazyCat> ClaudiusMaximus: We have add many APIs in gtk2hs-0.12.0, perhaps have some bug we haven't found.
13:13:18 <ClaudiusMaximus> this darcs get --lazy is taking a while; and the second number in the progress meter seems to be increasing almost as fast as the first number...
13:13:22 <ksf> just a simple taste of it: the "head" element either contains one title element plus zero or more metadata-content elements iff it is in certain positions (say, body, not iframe), and zero or more metadata-content elements or
13:13:31 <ksf> s/or/otherwise
13:14:25 <ksf> this "list contains" thing smells like HList
13:15:22 <ksf> ("title" is a metadata-content element itself)
13:16:46 <ManateeLazyCat> In gtk2hs-0.12.0, we have support newest GIO library for "cross platform file APIs" and can replace GnomeVFS completely, a file manager screenshot at here : http://www.flickr.com/photos/48809572@N02/4793031888/lightbox/
13:21:25 <int80_h> Saizan: not finding anything that starts and maintains a cookiejar, or handles POSTs...any clues?
13:21:53 <Saizan> int80_h: no, sorry
13:22:36 <int80_h> no worries
13:22:40 <pumpkin> Saizan: that's fine, really
13:24:37 <conal> Saizan: the other day when we discussed problems with the 'State World' (non)model of IO, in addition to inability to handle concurrency, you mentioned that it gave the wrong semantics to 'forever (print "foo")'. It occurs to me that this latter problem is a special case of the former. 'State World' cannot even handle concurrency between a purely sequential imperative program and the outside World.
13:26:05 <conal> in this sense, State is an even more purely sequential model than what we normally consider sequential imperative programming.
13:27:40 <conal> i.e., cannot even handle interactive programs.  not even any external observation before termination.
13:29:25 <ksf> http://hpaste.org/40773/zomg_this_compiles
13:29:35 <pumpkin> Saizan: I like your approach the best
13:29:43 <ksf> now if I would understand impredicativity maybe I wouldn't be scared.
13:30:14 <kmc> ksf, you can always eliminate impred. with a wrapper type
13:30:28 <joe1> I am trying to do 'when (0 == 0) printf "junk" appendFile "test" "junk"' but am not able to.
13:30:48 <kmc> data AllElement = AllElement (forall a. MetadataContent a => Element a)
13:30:51 <kmc> then use [AllElement]
13:30:55 <joe1> i typed the printf with an indentation in the next line to when
13:31:01 <kmc> however, it's quite unusual to want [∀].  usually you want [∃]
13:31:09 <kmc> for which you'd also need a wrapper, in GHC
13:31:14 <roconnor> ... I don't suppose there is an ST transformer.
13:31:30 <kmc> data SomeElement = forall a. (MetadataContent a) => SomeElement (Element a)
13:31:36 <joe1> i believe it must be some syntax issue that i am not getting correct..
13:31:36 <kmc> roconnor, there's one on hackage but it's evil and unsafe
13:31:49 * hackagebot temporal-media 0.0 - data types for temporal media  http://hackage.haskell.org/package/temporal-media-0.0 (AntonKholomiov)
13:32:02 <ksf> kmc, so what I'm doing boils down to a syntactically pleasant version of existentials?
13:32:12 <kmc> where?
13:32:18 <kmc> the code you pasted has no existentials
13:32:48 <joe1> when (0==0) { printf "junk"; appendFile "data/test" "junk";}
13:32:50 <pumpkin> GADTs are roughly equivalent to ADTs + type quality + existentials
13:32:51 <kmc> if you write [∀t. T t] then each individual element of that list has to be capable of acting like *every* type «T t»
13:32:59 <roconnor> Warning! This monad transformer should not be used with monads that can contain multiple answers
13:33:01 <roconnor> intresting
13:33:04 <pumpkin> s/quality/equality
13:33:06 <kmc> hmm, maybe there is an existential though
13:33:08 <pumpkin>  /
13:33:13 <kmc> because i forgot that GADTs can make that implicit
13:33:26 <pumpkin>     Head :: [MetadataContent a => Element a] -> Element Head
13:33:29 <pumpkin> that's existential
13:33:31 <kmc> by using a variable but not mentioning it in the ctor
13:33:35 <ksf> ah yes.
13:33:38 <kmc> pumpkin, but it required ImpredicativeTypes
13:33:45 <kmc> pumpkin, so i assumed the implicit ∀ went after [
13:33:50 * hackagebot csound-expression 0.0 - Csound combinator library  http://hackage.haskell.org/package/csound-expression-0.0 (AntonKholomiov)
13:33:51 <pumpkin> oh
13:33:55 <pumpkin> yeah, I wouldn't do that
13:34:01 <pumpkin> why would you want that to be impredicative?
13:34:02 <kmc> i think you want the list itself to be existential
13:34:05 <pumpkin> yeah
13:34:08 <kmc> not an existential wrapper for a list of polymorphic values
13:34:50 <ksf> what I _want_ is more of an idea of GADTs and how to express constraints in them.
13:35:49 <joe1> can anyone please help? I am just trying to write a simple if/when, but am struggling..
13:35:52 <Philippa> the problem is I don't think you express constraints directly much, only encode them
13:36:57 <ksf> hmm. what I actually want is to annotate "Head" for "HasATitleElement", and then require that to put it into a Html
13:38:19 <ksf> Philippa, well I wouldn't mind expressing them decleratively and then generate a GADT that enforces them.
13:38:23 <hpc> why not have Head :: Title -> [blah] -> Head?
13:38:23 <Philippa> *nod*
13:38:37 <ksf> because that ain't typesafe.
13:38:46 <Philippa> hpc: because it might not HasATitleElement
13:39:02 <ksf> well... in that case, you can put head elements that don't have a title into iframes.
13:39:11 <pumpkin> Saizan: okay, I don't mind this solution, now to automate it with TH :P
13:39:46 <conal> joe1: try hpaste (or another online paste site), so we can see details, including indentation & "do"
13:39:57 <ksf> the html spec is full of nesting constraints like that.
13:40:08 <joe1> conal: thanks ,will do.
13:40:13 <hpc> bleh
13:40:58 <ksf> but consider the glorious consequeces! never again generate invalid html!
13:41:02 <Saizan> conal: yeah, even modelling getLine is hard there
13:41:20 <pumpkin> Saizan: you think that stuff will be useful for more than just me? should I make it a separate package?
13:41:41 <ksf> together with those statically safe links, we'd have something to _really_ annoy those test driven development hipsters.
13:42:02 <Philippa> ksf: you can probably do that by sticking a type-level list of children into the type, or doing something similar? Try playing with HList?
13:42:16 <ksf> yes, I probably could.
13:42:31 <ksf> HList is quite heavy-weight, though.
13:42:52 <Saizan> pumpkin: are you sure it works for you? anyhow it seems a more typed alternative to Data.Data.Constr, so i guess it could be
13:43:04 <pumpkin> Saizan: yeah, it works
13:43:15 <pumpkin> it's more or less what I was doing before but with less repetition
13:44:47 <Saizan> i guess you've "toConstr :: a -> exists t. Repr a t" :)
13:45:13 <pumpkin>   constr    :: (forall b. Constr a b -> r) -> a -> r
13:45:19 <ksf> I could also generate two different adts for metadata-content with and without title element, use smart constructors, and then have a typeclass choose which to use.
13:45:19 <pumpkin> yeah, but I don't even use that in my library
13:45:53 <pumpkin> I really dig generalized algebraic data families
13:46:07 <Saizan> GADTs++
13:46:07 <pumpkin> I'm using them in all sorts of different contexts
13:46:15 <pumpkin> GADFs++ :P
13:46:39 <ksf> pumpkin, got an example?
13:47:16 <pumpkin> http://hackage.haskell.org/trac/ghc/wiki/ObjectiveC/TypeSafeMessaging
13:47:26 <pumpkin> that was the first use case I had for them
13:47:41 <pumpkin> but then I also used them in my ARM disassembler library
13:47:43 <Saizan> hah, i almost forgot families are actually different in haskell :)
13:48:07 <pumpkin> to represent different instruction sets parametrized by something common
13:48:35 <pumpkin> Saizan: yeah, and in agda we still can't really write open type families :/
13:48:49 <pumpkin> they can only be as "open" as a custom universe
13:49:23 <pumpkin> currently I have http://snapplr.com/qcq0
13:49:30 <pumpkin> the instance would be generated by TH
13:49:31 <crazycaw> I am reading Real World Haskell and i have to do a exercice to give the type, so i have [(True, []), (False, [['a']])] i think it is [Bool,Bool,[[Char]]], is some guys said that is [(Bool,[[Char]])] why is that?
13:49:48 <ksf> hmmm. I also probably want to be able to express additional constraints, such as "every <img> has an alt attribute"
13:49:56 <ksf> *optional constraints
13:51:07 <Saizan> pumpkin: that's one of the appealings of epigram 2 to me
13:51:41 <jmcarthur> crazycaw: can you tell me the type of (True, [])?
13:51:44 <pumpkin> there's so much appeal in epigram 2 :P
13:51:53 <pumpkin> I really hope the syntax isn't too horrendous
13:51:56 <pumpkin> I'll use it even if it is
13:51:59 <pumpkin> but I'll be happier if it isn't
13:52:06 <crazycaw> jmcarthur, Bool
13:52:24 <jmcarthur> crazycaw: maybe you missed that it's a tuple?
13:52:49 <jmcarthur> what i just asked, that is
13:52:53 <pumpkin> anyone know of an example of TH for generating an instance for a type?
13:52:58 <pumpkin> I imagine I have to use reify
13:53:03 <pumpkin> but I haven't played with it much
13:53:06 <Saizan> pumpkin: "constr :: (forall b. Constr a b -> b -> r) -> a -> r" would be nicer, imo
13:53:20 <pumpkin> Saizan: that makes sense
13:53:20 <jmcarthur> pumpkin: happstack-state does it i know
13:53:28 <crazycaw> jmcarthur, so what type is it?
13:53:36 <jmcarthur> crazycaw: (Bool, [a])
13:53:45 <jmcarthur> crazycaw: do you understand why?
13:53:50 <crazycaw> no i dont
13:54:13 <nus> crazycaw, () :: ()
13:54:42 <crazycaw> yes a tuple can be of any type
13:54:47 <jmcarthur> crazycaw: the type of a tuple (a, b) is (A, B), where A is the type of a, and B is the type of b
13:55:20 <crazycaw> so ("100",100)
13:55:37 <crazycaw> the first is Char and the second is a int?
13:55:58 <jmcarthur> well, the second is technically Num a => a, but it would unify with Int
13:56:04 <jmcarthur> you have the idea
13:56:21 <jmcarthur> so do you now understand why the type of (True, []) is (Bool, [a])?
13:56:51 <nus> preflex, seen lambdabot
13:56:51 <preflex>  lambdabot was last seen on #haskell-blah 1 day, 8 hours, 30 minutes and 55 seconds ago, saying: i'll hafta plead the fifth on that one.
13:56:54 <crazycaw> i dont understand what the a stands for
13:57:25 <jmcarthur> crazycaw: the a means any concrete type could be placed there
13:57:32 <jmcarthur> crazycaw: because the list is empty, we don't know the actual type to use there
13:57:46 <jmcarthur> at least not based solely on the value
13:57:52 <crazycaw> ok
13:57:59 <jmcarthur> good up to here?
13:58:18 <jmcarthur> now, tell me the type of (False, [['a']])
13:58:35 <crazycaw> bool, char?
13:59:25 <jmcarthur> okay, you understand the typing rules for tuples i think. now we need to tackle lists
13:59:35 <jmcarthur> can you tell me the type of ["foo"]?
13:59:58 <crazycaw> char
14:00:19 <pumpkin> FamilyD in TH represents GADTs?
14:00:28 <jmcarthur> the typing rule for a singleton list like this is this:    the type of [a] is [A], where A is the type of a
14:00:37 <jmcarthur> crazycaw: ^^
14:01:31 <crazycaw> so char is right?
14:01:37 <jmcarthur> more generally, the type of [a, b, c, d, e] is [A], where a, b, c, d, and e all have type A
14:01:41 <jmcarthur> no, char is wrong
14:01:48 <ksf> pumpkin, nope
14:01:53 <pumpkin> oh it's a type family
14:01:55 <jmcarthur> the correct type of ["foo"] is [String]
14:02:13 <ksf> use DataD and equality constraints, there's no adt for gadts, per se.
14:02:24 <ksf> ...and a recent enough ghc version, which may mean head.
14:02:25 <crazycaw> but i can divide it 'f'++'o'++'o'
14:02:52 <jmcarthur> crazycaw: String is another word for [Char], yes, but in those terms the type of ["foo"] is [[Char]]
14:02:53 <ksf> if in doubt, lift a declaration and look at what you get.
14:03:09 <crazycaw> jmcarthur, ok :)
14:03:39 <jmcarthur> think you can give me the type of (False, [['a']]) now?
14:04:58 <crazycaw> bool for False and String for [['a']], or i am wrong again?
14:05:18 <jmcarthur> let's break down the [['a']] part
14:05:24 <jmcarthur> first, what's the type of 'a'?
14:05:37 <crazycaw> is a char
14:05:53 <jmcarthur> okay, now... ['a']?
14:06:11 <crazycaw> still a char
14:06:16 <crazycaw> but inside a list
14:06:29 <jmcarthur> that is written [Char]
14:06:34 <joe1> quick question about the structure of a program: is it a good idea to have 3 levels of IO () functions vs one main IO () function with a sequence?
14:06:49 <ksf> in general, the latter.
14:06:54 <ksf> ymmv, though.
14:07:08 <jmcarthur> crazycaw: now, what about [['a']]?
14:07:23 <crazycaw> now is a string
14:07:23 <ksf> ...always try to factor out the IO and other dirty stuff as much as possible.
14:07:32 <jmcarthur> no, [Char] was already a string
14:07:43 <ksf> type String = [Char]
14:07:59 <joe1> ksf: thanks. what do you mean by "factor out"?
14:08:03 <hpc> if you have main = do thing1; thing2; thing3, you might want to keep it as that
14:08:05 <crazycaw> jmcarthur, so, is a list of char's inside another list
14:08:12 <jmcarthur> crazycaw: right
14:08:18 <ksf> joe1, well, keep your IO separate from the rest.
14:08:19 <jmcarthur> crazycaw: can you write that as a type?
14:08:21 <hpc> if thing2 = liftM2 (+), refactor
14:08:28 <crazycaw> [[Char]]
14:08:31 <hpc> (or something like that)
14:08:32 <jmcarthur> there we go
14:08:53 <jmcarthur> so now we can surely get the type of (False, [['a']])
14:09:18 <crazycaw> the second list is a char to right? because the first one is a list of char's?
14:09:32 <joe1> hpc: it is actually thing3 that calls another IO () - thing31, which calls another IO function - thing311 scenario
14:09:49 <jmcarthur> crazycaw: i'm not exactly sure what you mean the way you worded it
14:10:03 * hackagebot monoid-statistics 0.1 - Monoids for calculation of statistics of sample  http://hackage.haskell.org/package/monoid-statistics-0.1 (AlexeyKhudyakov)
14:10:08 <hpc> joe1: ah; that's a whole other debate :P
14:10:11 <jmcarthur> crazycaw: instead of first and second say outer and inner and i think i might understand what you mean
14:10:21 <hpc> go with whatever makes functions easier to piece together
14:10:48 <hpc> if calling thing3 always means calling thing31 as part of it, or afterwards, keep what you have
14:10:49 <joe1> hpc: thanks.
14:11:12 <hpc> otherwise you might consider separating them
14:11:14 <crazycaw> [["hey","hey","hey"],a,b,c.d], every letter(a,b,c,d) has 3 strings?
14:11:22 <crazycaw> (hey,hey,hey)
14:11:34 <hpc> crazycaw: no
14:11:39 <joe1> i could serialise the IO into a list for sequence later, but I think the program would just look like a bunch of strings and become hard to read/understand later.
14:11:41 <hpc> or, not necesarilly
14:11:52 <hpc> lists can have any length, but their elements are of the same type
14:12:07 <hpc> [1,2,3] is the same type as [1,2,3,4,5,6,6,2,3,4]
14:12:16 <ksf> hmmm shouldn't ghc 7 have superclass constraints?
14:12:25 <hpc> or even [], if you squint
14:12:28 <jmcarthur> ksf: removed :(
14:12:42 <jmcarthur> ksf: i think it was only "working" by chance sometimes
14:12:49 <nus> hmm, doesn't RWH explain 'data' before giving this exercise?
14:12:50 <ksf> bah
14:13:13 <crazycaw> nus, i guess, but i dont understant it very weel
14:13:15 <crazycaw> well
14:13:51 <nus> crazycaw, 'data [] a = [] | a : [a]' did you see that expression?
14:14:06 <crazycaw> yes i did
14:14:08 <pumpkin> how would I use lift to determine how a GADF is composed?
14:14:47 <Saizan> pumpkin: you'd use reify i think
14:15:10 <Saizan> no, i think i don't understand :)
14:15:23 <pumpkin> does (Family Type) count as a "Name"? :P
14:15:57 <pumpkin> http://snapplr.com/jpqd
14:16:02 <hpc> crazycaw: it basically means a list can be one of two things
14:16:07 <hpc> crazycaw: an empty list
14:16:10 <pumpkin> I want to look up a representation in TH of Constr Moo
14:16:14 <hpc> crazycaw: a thing with a list on the end of it
14:16:15 <pumpkin> or Constr Moo a
14:16:31 <ksf> pumpkin, write it in [d| |] quotes, show the ast.
14:17:04 <hpc> so an empty list is []
14:17:06 <ksf> if ghc chokes on the gadt, you need a newer version
14:17:14 <hpc> a short list would be (1:[])
14:17:15 <Saizan> pumpkin: ah, ok, i'm not sure if that's possible, though you can ask for the representation of Moo and deduce the rest from there, no?
14:17:23 <hpc> and a longer list would be (1:(2:[]))
14:17:36 <ksf> pumpkin, http://hackage.haskell.org/trac/ghc/ticket/4188
14:17:44 <crazycaw> hpc, i dont know what a long and short list is yet
14:17:45 <hpc> but (2:[]) produces a list, same as []
14:17:55 <hpc> crazycaw: short and long aren't terms :P
14:18:13 <crazycaw> but the : dont add it in the list?
14:18:30 <crazycaw> like 1:[1,2,3,4] = [1,2,3,4,1]
14:18:32 <crazycaw> ?
14:18:41 <hpc> you have it backwards
14:18:51 <hpc> 1:[1,2,3,4] = [1,1,2,3,4]
14:18:55 <crazycaw> ok
14:18:56 <hpc> it puts 1 at the beginning
14:19:06 * hackagebot HaTeX 2.1.3 - Monadic tool for write LaTeX files.  http://hackage.haskell.org/package/HaTeX-2.1.3 (DanielDiaz)
14:19:07 <crazycaw> my mistake
14:19:08 <hpc> so you start with an empty list
14:19:10 <hpc> add 2
14:19:12 <hpc> then add 1
14:19:18 <hpc> etc
14:19:28 <joe1> is there an higher order function of the format: foldlX (function :: String -> [String]) [result:String] [input1:String,input2:String...]
14:19:39 <pumpkin> ksf: thanks
14:19:40 <joe1> i mean something similar to foldlX
14:19:50 <crazycaw> where can i get real fun exercices to do in haskell?
14:20:04 <hpc> project euler, or 99 problems
14:20:10 <hpc> @where 99 problems
14:20:12 <nus> crazycaw, depends on what's real fun for you
14:20:27 <hpc> there's also a page that gets you started on making an IRC bot
14:20:33 <hpc> i started with that one and enjoyed it
14:20:57 <crazycaw> euler is to boring for me
14:20:57 * ksf recommends http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
14:21:09 <crazycaw> but it is scheme not haskell
14:21:18 <ksf> well, it's both.
14:21:26 <hpc> you implement scheme in haskell
14:21:27 <ksf> comes with enough exercises
14:21:31 <Vq> It's a good Haskell tutorial
14:21:45 <nus> crazycaw, have you read "Learn You A Haskell"?
14:21:58 <crazycaw> hpc, http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot is that the page?
14:21:58 <hpc> for extra credit, implement haskell in the resulting scheme interpreter :P
14:22:01 <hpc> crazycaw: yes
14:22:02 * monochrom conceives "write yourself a haskell in 48 years", a tutorial in c
14:22:12 <Twey> Haha
14:22:18 <joe1> sorry, concatMap does exactly that.. thanks.
14:22:34 <Vq> Implementing a scheme subset is actually a good idea for learning any language
14:22:51 <crazycaw> nus, Learn you Haskell dont have exercices, i need a lot os exercices
14:22:52 <ksf> any sufficient program contains...
14:23:13 <monochrom> tryhaskell.org is a lot of exercises.
14:23:29 <nus> crazycaw, 'os exercices"?
14:23:30 <joe1> crazycaw: what do you think of fixing pastepipe?
14:23:32 <benmachine> real world haskell has lots of exercises I think
14:23:36 <hpc> you can get exercises out of lyah if you try a bit
14:23:39 <joe1> to post to hpaste..
14:23:49 <hpc> find pieces of code he doesn't elaborate on enough and bring them to a conclusion
14:23:56 <hpc> for example, his RPN calculator
14:23:58 <crazycaw> nus, sorry of
14:24:08 <sipa1024> monochrom: http://abstrusegoose.com/249
14:24:17 <hpc> (or at least, before the new monad section gave it more whistles...)
14:25:02 <sproingie> i started writing a tutorial that has lots of exercises
14:25:05 <sproingie> lemme see if its still up
14:26:11 <sproingie> http://monadfix.com/wiki/Haskell_Tutorial
14:26:24 <sproingie> i suffered a Gumption leak and ran out of Gumption
14:26:33 <hpc> i love your name for it
14:27:26 <pumpkin> TH.hs:23:6:
14:27:26 <pumpkin>     GADT declaration not (yet) handled by Template Haskell
14:27:26 <pumpkin>       ConstrMooA :: Constr Moo (Int8, ())
14:27:30 <pumpkin> should I upgrade to 7?
14:28:30 <ClaudiusMaximus> i tried a ghc-7 snapshot on my lenny installation; failed with "glibc too old" :(
14:28:36 <pumpkin> aw
14:31:19 <ksf> oh, crazycaw, I thing I've got an exercise for you.
14:31:43 <ksf> the write yourself a scheme tutorial seems to implement dynamic scoping instead of RSR5...
14:31:52 <kmc> :(
14:32:00 <crazycaw> loool
14:32:05 <crazycaw> i dont know Scheme
14:32:10 <kmc> lexical scoping is easy
14:32:10 <hpc> hahaha
14:32:22 <ksf> http://en.wikibooks.org/wiki/Talk:Write_Yourself_a_Scheme_in_48_Hours#Environment_bug
14:32:36 <hpc> i still don't understand why dynamic scoping is so amazing
14:32:43 <ksf> it isn't.
14:32:43 <hpc> it looks like a mountain of bugs waiting to happen
14:32:57 <ksf> it always has been a bug, from the very beginning of lisp.
14:33:01 <monochrom> that is why it is amazing. to perverts.
14:33:31 <ksf> which is why emacs users love it.
14:33:34 <Vq> I think it has a pretty good place in elisp
14:34:24 <hpc> if ksf didn't say it, i would have XD
14:34:40 <Vq> :'(
14:38:51 <crazycaw> and it is the end of coding for today
14:40:39 <joe1> is there a function that can execute this list of IO actions: let test = ["print \"junk\"","print \"junk1\""]
14:40:52 <hpc> :t sequenceM_
14:40:57 <ksf> nope.
14:40:58 <monochrom> sequence_
14:40:59 <joe1> hpc: thanks.
14:41:05 <joe1> monochrom: thanks
14:41:05 <ksf> that's a list of strings, not of IO actions.
14:41:06 <hpc> er, yes
14:41:08 <hpc> sequence_
14:41:12 <joe1> ksf: yes
14:41:13 <kmc> you have strings and you want to make them into code?
14:41:18 <joe1> kmc: yes
14:41:20 <kmc> you'd need something like 'hint' to do that
14:41:29 <kmc> it's not a very natural thing to do in a language like Haskell
14:41:33 <monochrom> just remove some " s
14:41:37 <kmc> we usually have better forms of abstraction
14:41:38 <joe1> i have code as strings and want to executed them.
14:41:46 <kmc> eval() is the abstraction of last resort
14:41:51 <hpc> do they need to be strings?
14:41:52 <kmc> but yes, 'hint' can do it
14:42:07 <hpc> you can do test = [print "junk", print "junk"0
14:42:11 <joe1> i have 2-3 levels of IO actions and I am thinking of changing the functions to return strings and executing the strings list in the main function.
14:42:12 <hpc> s/0/]/
14:42:24 <hpc> ah! don't do that
14:42:31 <hpc> return an action
14:42:50 <hpc> doThings = [do1, do2, do3]
14:42:57 <hpc> main = sequence_ doThings
14:43:23 <joe1> hpc: yes, that makes sense. Thanks a lot.
14:43:25 <Lemmih> joe1: You can pass IO actions around as if they were data.
14:43:58 <joe1> Lemmih: aha!!
14:44:13 <hpc> you can also pass functions around as if they are data, but that's a whole other lesson ;)
14:44:14 <joe1> Lemmih: this is one of those light-bulb moments for me..
14:44:20 <ksf> you can even pass functions around like they were data.
14:44:27 <ksf> or partially applied functions.
14:45:16 <joe1> hpc: that worked very well. thanks. i was dreading building the string list.
14:45:31 <conal> because they *are* data
14:46:02 <ksf> code and data are both illusions. there's only information.
14:46:32 <monochrom> information is illusion too. there is only illusion.
14:46:48 <hpc> lol
14:46:49 <Entroacceptor> wait, that gives way to a whole lot of stuff, if code is data, you can take code in one form and put it into another!
14:46:55 <ksf> wait, but illusion is -- tautologically -- an illusion.
14:47:12 <monochrom> it's illusions all the way down
14:47:16 <hpc> clearly there is nothing at all, and you should go back to "import antigravity"
14:47:40 <Entroacceptor> I tried that, that package is broken :(
14:47:50 <ksf> nope. at the very bottom layer, there's a joke that plays itself on itself.
14:48:13 * hackagebot histogram-fill 0.3.0.1 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.3.0.1 (AlexeyKhudyakov)
14:49:29 <joe1> hpc: i cannot find sequenceM_ though i can find sequence_, which works as expected. Did you mean sequenceM_?
14:49:35 <joe1> hpc: i cannot find sequenceM_ though i can find sequence_, which works as expected. Did you mean sequenceM_ or sequence_?
14:49:41 <pumpkin> sequenceA ?
14:49:48 <pumpkin> sequence already works on an M
14:49:58 <Lemmih> joe1: He meant the latter.
14:50:00 <ksf> hmmm I guess I shouldn't even think about starting to write the html spec as concrete code, but figure out some way to write out the constraints declaritively as an adt, first.
14:50:04 <joe1> Lemmih: thanks.
14:50:05 <int80_h> hiya, trying again
14:50:09 <int80_h> http://hpaste.org/40765/networkbrowser_example
14:50:29 <hpc> no, i was wrong; sequence_ is what you want
14:51:16 <ksf> ...which has the additional benefit that I can use it to generate both a gadt that encodes the constraints _and_ a parser that constructs the gadt.
14:51:40 <joe1> hpc: thanks
14:51:43 <aristid> wow, michael snoyman uploads a LOT of packages
14:51:53 <ksf> ...it's dsls all the way up.
14:52:06 <aristid> is he on irc?
14:52:51 <pumpkin> preflex: seen snoyberg
14:52:52 <preflex>  Sorry, I haven't seen snoyberg
14:56:15 <int80_h> aristid: yeah if http.enumerator was documented better, I'd give it a go.
14:56:30 <aristid> int80_h: so you got your old nick back?
14:56:49 <int80_h> arisitd: yeah I had help. I was logged in at home, someone showed me how to ghost
14:56:58 <aristid> int80_h: lol.
14:57:10 <int80_h> aristid: would you help me with my problem?
14:57:26 <aristid> int80_h: only if you give me a virtual hug
14:57:40 <benmachine> virtual void hug
14:57:48 <benmachine> private virtual void hug
14:57:49 * int80_h hugs aristid and slips a virtual greenback in his pocket.
14:57:52 <aristid> benmachine: no c++ hug :D
14:58:05 * int80_h chokes and gags.
14:58:08 <aristid> int80_h: still the network problem?
14:58:09 <int80_h> c==!!!
14:58:35 <int80_h> aritisid, yeah I am trying to duplicate functionality in the tutorial I found, using network.browser.
14:59:17 <int80_h> either I will find (1) network.curl was indeed broken and I should use browser or (2) my code is borked and I need more schooling.
14:59:31 <aristid> int80_h: i use curl too. let me see if POST works for me
14:59:45 <int80_h> when I said network.curl is broken, I suspect it is libcurl underneath with problems.
14:59:58 <int80_h> try it on github!
15:00:21 <int80_h> and let's match up versions if you have success.
15:01:00 <aristid> int80_h: POST works for me, using Network.Curl
15:01:06 <aristid> int80_h: which platform are you on?
15:01:08 <int80_h> *sniff*
15:01:15 <int80_h> would you post your code?
15:01:16 <aristid> (i used my own code for testing)
15:01:36 <int80_h> oh, could you use the tutorial code? If there is somethign wrong I'd like to fix it.
15:01:45 <hpc> benmachine: private hug? this is a G-rated channel!
15:01:53 <int80_h> or at least get the same functionality. It does exactly what I need.
15:01:54 <hpc> for shame! :D
15:01:59 <benmachine> hpc: :>
15:02:08 <aristid> int80_h: right, can you give me a direct link? i'll try in a few minutes
15:02:14 <int80_h> sure
15:02:45 <int80_h> aristid: http://flygdynamikern.blogspot.com/2009/03/extended-sessions-with-haskell-curl.html
15:03:25 <int80_h> i need to be able to add options, and his approach makes it easy.
15:03:44 <int80_h> It's doing exactly what I want, except no post
15:04:22 <int80_h> I would be very happy to retain the use of curl. It seems very accessible to my newbie eyes.
15:07:18 <aristid> int80_h: oh, the blog post IS the code?
15:07:39 <int80_h> well yeah he embeds in his blog post
15:07:46 <int80_h> I put it in my hpaste
15:08:02 <int80_h> but I thought when you said direct, you wanted the direct source.
15:08:21 <int80_h> aristid: 
15:08:29 <int80_h> aristid: http://hpaste.org/40765/networkbrowser_example
15:08:37 <int80_h> there you go, I removed it from the blog there
15:08:57 <int80_h> here is the specifics lines giving me troubles
15:09:11 <aristid> $ runghc x.lhs aristidb x
15:09:11 <aristid> x.lhs: Failed to log in: CurlOK -- HTTP/1.1 422 Unprocessable Entity
15:09:48 <aristid> that's with the code from the blog
15:09:49 <int80_h> srsly? I can log in but not with a POST
15:10:00 <aristid> well that was the wrong password
15:10:14 <aristid> is 422 expected for the wrong password?
15:10:43 <int80_h> oh yeah he got it wrong, it should be github.com/login
15:10:53 <int80_h> instead of github.com/session
15:11:12 <int80_h> I could show you my "fix" but it may be borked.
15:11:16 <aristid> int80_h: and yes your code uses GET
15:11:47 <int80_h> but the code suggests it is using POST
15:11:54 <int80_h> r <- do_curl_ curl "https://github.com/session" (loginOptions user pass)
15:12:00 <int80_h> right there, that should be a POST
15:12:09 <pumpkin> anyone know how to generate GADTs in TH?
15:12:19 <int80_h> because of this line
15:12:24 <aristid> int80_h: ok, try the following
15:12:27 <int80_h> r <- do_curl_ curl "https://github.com/session" (loginOptions user pass)
15:12:29 <pumpkin> or better, GADFs :P
15:12:32 <int80_h> alrighty
15:12:41 <aristid> int80_h: replace [ ... ] : method_POST with method_POST ++ [...]
15:12:41 <int80_h> oops i meant
15:12:47 <int80_h> >   CurlPostFields [ "login=" ++ user, "password=" ++ pass ] : method_POST
15:12:49 <hsbot>   Not in scope: data constructor `CurlPostFields'Not in scope: `user'Not in scope: `pass'Not in scope: `method_POST'
15:12:53 <aristid> int80_h: afaik later options override earlier options
15:13:06 <int80_h> aristid: okay I will try that
15:14:34 <aristid> *hopes it helps*
15:14:45 <int80_h> aristid I got a type error
15:15:08 <aristid> int80_h: right, i think you can fix that
15:15:41 <int80_h> >   CurlPostFields method_POST ++ [ "login=" ++ user, "password=" ++ pass ]
15:15:42 <hsbot>   Not in scope: data constructor `CurlPostFields'Not in scope: `method_POST'Not in scope: `user'Not in scope: `pass'
15:15:48 <int80_h> that's what I changed it to
15:16:37 <int80_h> hmm, I don't know why putting that same operator on the front of the list would make a difference
15:16:39 <ClaudiusMaximus> ManateeLazyCat: my gtk app worked fine with darcs gtk2hs
15:16:57 <ManateeLazyCat> gtk2hs support GTK+ 2.22 now, haha. :)
15:17:01 <ManateeLazyCat> ClaudiusMaximus: Cool
15:17:43 <ClaudiusMaximus> ManateeLazyCat: though i'm not sure if gtkglext (or whatever it's called) was the newest version - seemed to work anyway
15:17:44 <ManateeLazyCat> ClaudiusMaximus: Now you can use all GTK+ APIs in gtk2hs, from GTK+2.8 to GTK+2.22
15:18:29 <ManateeLazyCat> ClaudiusMaximus: GtkGlext APIs no update, just fix memory leak.
15:18:51 <aristid> int80_h: um of course you have to change it to method_POST ++ CurlPostFields [ "login=" ++ user, "password=" ++ pass ]
15:18:52 <int80_h> arisitd: this was my attempt to fix >   CurlPostFields (method_POST ++ [ "login=" ++ user, "password=" ++ pass ] :: CurlOption)
15:18:59 <int80_h> ack
15:19:42 <ManateeLazyCat> I have update all gtk2hs-base library in darcs, after gtk2hs-0.12.0 release, i will release those gtk2hs-base library (gtkimageview, gtksourceview, poppler, webkit, gconf, glade, gstreamer, gtkglext, vte).....
15:19:53 <int80_h> '    Couldn't match expected type `[CurlOption]'
15:19:53 <int80_h>            against inferred type `CurlOption'
15:20:01 <int80_h> we're getting closer!
15:20:12 <aristid> method_POST ++ [CurlPostFields [ "login=" ++ user, "password=" ++ pass ]]
15:20:34 <int80_h> oops I was wrapping the wrong thing in brackets
15:21:11 <int80_h> I tried wrapping [method_POST]
15:21:26 <int80_h> hells yes
15:21:32 <aristid> now it worky?
15:21:34 <int80_h> it compiles, now I will test it
15:21:39 <aristid> oh ok
15:23:41 <int80_h> aristid you r teh awesome
15:23:54 <aristid> int80_h: thank you, thank you :D
15:24:03 <int80_h> and you may be personally responsible for saving my plan for introducing haskell into my work.
15:24:27 <int80_h> I am the *only* haskell person here. You guys are my support :)
15:24:40 * ezyang gives int80_h a cookie. 
15:24:46 <int80_h> we figured getting this POST to work would save the project
15:25:12 <aristid> drama!
15:25:14 <aristid> action!
15:25:59 <ManateeLazyCat> Only C++, Python, JavsScript, Vala's binding complete as gtk2hs....
15:26:24 <int80_h> heh
15:26:56 <ManateeLazyCat> Now, waiting GTK+ 3 release.... :)
15:27:25 <aristid> int80_h: in return for my help, just have a look at this: http://hackage.haskell.org/package/xml-monad-0.1
15:27:45 <int80_h> agreed
15:28:07 <int80_h> I will look now, but I may have to spend much time studying it in the future. I noticed the "m" word
15:28:17 <aristid> it works tho, so you don't have to fix it :D
15:28:40 <ManateeLazyCat> ClaudiusMaximus: You can get gtkglext darcs at http://code.haskell.org/gtkglext/
15:28:55 <int80_h> aristid: that does xml parsing?
15:29:11 <aristid> int80_h: the actual xml parsing is done by iavor diatchki's xml
15:29:14 <ManateeLazyCat> ClaudiusMaximus: If you found darcs version have any problem, please report to gtk2hs list : gtk2hs-users@lists.sourceforge.net
15:29:29 <aristid> int80_h: i just provide a simple monadic wrapper
15:29:31 <ClaudiusMaximus> ManateeLazyCat: ok, i'll give it a go
15:29:42 <int80_h> aristid: you said the magic word. simple
15:29:48 <ManateeLazyCat> ClaudiusMaximus: Thanks
15:29:49 <int80_h> I likes me some simple
15:30:06 <int80_h> I must go rush and try this fix on the actual production code
15:30:10 <int80_h> I'll bbl
15:30:18 <int80_h> everyone but me is getting drunk right now
15:30:25 <int80_h> I have to stay here and make this work
15:30:33 <adimit_> Query: say I've an ADT A with a lot of constructors C1..Cn. Now I ended up writing a lot of function of type f = g h where h (C1 p) = Just p; h _ = Nothing;; and g is arbitrary. Is there a good way to abstract over that?
15:30:38 <theorbtwo> Oh, hey, you got your name back.
15:30:42 <theorbtwo> Nickserv it this time?
15:30:48 <int80_h> yeah, I learned about "ghost"
15:30:54 <aristid> int80_h: usage example http://hpaste.org/40774/another_xmlmonad_example
15:30:57 <int80_h> I had been logged in at home
15:31:08 <theorbtwo> Aha!
15:31:18 <aristid> testElementNameUI throws an exception (pure, no IO involved) if the element name does not match
15:31:19 <int80_h> aristid: recorded
15:31:23 <ksf> hmmm I might be just fine with regexes on the type level. after all, they're closed under everything.
15:32:07 <aristid> ksf: oO
15:32:15 <pumpkin> you can talk about regular types
15:32:31 <pumpkin> haskell's types are a superset of them
15:32:33 <ksf> ...not that I think I'd write the regex compiler in the type level, just encode the compiled expressions...
15:33:33 <aristid> logically
15:33:48 <aristid> ksf: you go down the path of c++ programmers :>
15:34:27 <ksf> well, no. I don't think c++ programmers generate their templates from a definition.
15:34:54 <aristid> true, but if you do it right you might even match the compile times
15:35:00 <ClaudiusMaximus> ManateeLazyCat: works fine it seems, thanks!
15:35:08 <ksf> when I learned one thing while toying around with network protocols is that you don't, ever, never, implement a spec directly.
15:36:07 <aristid> ksf: yes. you first write a paper on how to use GADTs for the task.
15:36:10 <ksf> well, if ghc's type checker is too slow to give a decent turnaround on html verification, I've got a solid bug to report.
15:37:09 <ManateeLazyCat> ClaudiusMaximus: New version gtk2hs fix manay memory leak, such as pixbuf.
15:37:31 <ksf> what exactly is a regular type/
15:37:32 <ksf> ?
15:38:22 <ManateeLazyCat> ClaudiusMaximus: Now you can use pixbuf build your own image-viewer (http://goo.gl/tOpT), no memory leak.
15:38:27 <ClaudiusMaximus> ManateeLazyCat: good to know - currently i'm poking bytes into memory and using glTexSubImage
15:39:22 <ksf> aristid, actually, I meant you first write the spec down as an adt, then generate code from there.
15:39:52 <ClaudiusMaximus> ManateeLazyCat: is it possible that these fixes also fixed a bug where (before)   mygtkcode +RTS -hT   would crash with a strange closure type error?
15:40:00 <aristid> ksf: did i mean that? i guess i did, if you say so
15:40:27 <ManateeLazyCat> ClaudiusMaximus: gtk2hs ticker link?
15:40:32 <ksf> ...as contrasted to starting out by writing a paper about gadts.
15:40:49 <ClaudiusMaximus> ManateeLazyCat: i didn't file one; and i don't know if anyone else did
15:40:51 <ManateeLazyCat> ClaudiusMaximus: Here is gtk2hs ticker : http://hackage.haskell.org/trac/gtk2hs/report/1
15:41:29 <aristid> ksf: you can't omit writing the paper
15:41:32 <aristid> ksf: publish or perish
15:41:38 <ManateeLazyCat> ClaudiusMaximus: You still got bug with gtk2hs darcs?
15:41:39 <ksf> I'm no academic.
15:41:55 <ksf> where I'm from, code weighs more than bla.
15:42:15 <dolio> ksf: I think the regular types are those closed under similar operations to regular expressions.
15:42:18 <ClaudiusMaximus> ManateeLazyCat: works fine now - so the bug (if there was one) is gone
15:42:23 <dolio> Empty, unit, product, sum.
15:42:27 <ManateeLazyCat> ClaudiusMaximus: Good. :)
15:43:21 <ksf> I still have to come across an operation regexen are _not_ closed under...
15:44:21 <dolio> Perhaps I should say, they are generated by those operations.
15:44:32 <ksf> ...as so often in type theory, the internet isn't being helpful when it comes to definitions.
15:45:01 <koninkje> ksf: what definition are you looking for?
15:45:12 <ksf> regular type.
15:45:20 <ksf> ...because pumpkin mentioned them
15:45:48 <ksf> is "adt without polymorphism" a good description?
15:46:44 <koninkje> I believe regular types are sum,product,fix types. I.e., standard ADT without nested recursion
15:47:01 <philosopher> how good is the llvm backend ?
15:47:21 <philosopher> is it still in beta stage ?
15:48:12 <ManateeLazyCat> philosopher: Wait GHC 7 . :)
15:49:09 <koninkje> ksf: http://strictlypositive.org/diff.pdf
15:49:51 <dolio> I seem to recall some article talking about types corresponding to several different classes of languages.
15:50:02 <dolio> Regular, context free, context sensitive types...
15:50:06 <dolio> I can't remember what it was called, though.
15:50:20 <ManateeLazyCat> Bye all, need sleep. :)
15:50:32 <koninkje> section 2.5 in particular
15:50:49 <ksf> regular ones then should be amendable to _agressive_ optimisations...
15:51:22 <koninkje> for the most part, yes. Sometimes fix gets in the way of things
15:51:41 <koninkje> (depending on the optimization)
15:51:53 <ksf> something like deriving zippers for them and reversing pointers optimally as-you-go.
15:52:30 * ksf tries to imagine what determisation would mean
15:53:36 <koninkje> I'm diving into the wooly world of parallel programming (in Haskell) and it's been a while since I've looked at things. Any gurus around to help troubleshoot the design (e.g., MVar, vs STM, vs FRP,...)?
15:53:48 <ksf> STM
15:54:00 <ksf> or par, depends.
15:54:25 <ksf> combinatorrent is a great example of how erlangy you can be in haskell
15:54:45 <ksf> there's also CHP if you like theoretical foundations.
15:54:52 <ezyang> Hey guys, I have an interesting proposal for eliminating memory leaks in Haskell: put computation in a monad that runs in IO to control precisely when the computation is run, and use phantom types to prevent references to the result from escaping. Do you think this could work? 
15:54:55 <koninkje> The design I have in mind is fairly pi-calculusy/erlangy. Not sure how stable CHP is these days
15:55:37 <koninkje> Also fairly simple, ~4 threads
15:55:59 <sproingie> i would tend to think STM for concurrency, par for "embarassingly parallel"
15:56:23 <ksf> definitely STM when you want erlangy.
15:56:36 <sproingie> erlangoid?
15:56:48 <sproingie> erlanguish
15:57:28 <Twey> Erlangesque
15:58:58 <nus> every time you type Erlang, a call gets disconnected.
15:59:10 <ksf> hmmm I basically want XQuery, I think.
15:59:30 <ksf> gfoldl expressed in adts so I can compile it?
15:59:31 <donri> Ericsson's language, that's Swedish yea?
15:59:41 <ezyang> Hm. 
15:59:48 * ezyang should just go and try to implement it. 
16:00:40 <ksf> ericsson is swedish, yep.
16:01:35 <Adamant> ezyang: for me at least, I'm not answering not because it's not a good idea, I'm not answering because I can't offer an intelligent opinion
16:03:05 <sproingie> ericsson also played a part in developing feldspar, which is written in haskell
16:09:26 <pumpkin> dolio, ksf: it's morris' thesis
16:09:40 <pumpkin> and a related paper on universes in epigram
16:09:44 <pumpkin> at least, that was my exposure to them
16:10:03 <pumpkin> regular types have sum, product, unit, void, and a "repeat" operator like the kleene star
16:10:10 <pumpkin> context-free have mu
16:10:58 <pumpkin> ksf: do you know how to write GADTs in TH then? cause [d| |] with an error if I try to stick my code into it to see the generated AST
16:11:10 <pumpkin> the error being "    GADT declaration not (yet) handled by Template Haskell"
16:11:17 <pumpkin> (even with GHC 7 RC1)
16:11:20 <ksf> also when you express it as equality constraints?
16:11:44 <pumpkin> I don't want to express GADTs as equality constraints manually :/
16:11:49 <pumpkin> or how do you mean?
16:12:00 <ksf> well, you might have to.
16:12:09 <hauzer> what, so many people here
16:12:13 <ksf> the TH adt doesn't support them in any other way.
16:13:08 <ksf> #haskell hasn't really grown in the last year or so.
16:13:15 <ksf> only very, very slowly.
16:13:15 <pumpkin> ksf: the only way I know how to represent them without constructor-level constraints or helper types
16:13:20 <pumpkin> *with
16:13:42 <pumpkin> which would make it complicated for users to use the generated type
16:14:05 <ksf> spj mentioned something about fixing the pretty printer in the bug
16:14:57 <ksf> data Foo :: * -> * where Bar :: (a ~ Int) => Foo a
16:15:20 <pumpkin> yeah, but how do I express the (a ~ Int) constraint on the Bar constructor?
16:15:43 <pumpkin> DataD Cxt Name [TyVarBndr] [Con] [Name]	
16:15:55 <ksf> data Pred = ClassP Name [Type] | EqualP Type Type
16:16:02 <ksf> Cxt = [Pred]
16:16:10 <pumpkin> yeah, that's Cxt on the entire DataD
16:16:12 <pumpkin> not per constructor
16:16:20 <pumpkin> the [Con] doesn't have any Cxt
16:16:23 <ksf> ForallC
16:16:33 <pumpkin> oh
16:16:39 <pumpkin> ick :
16:16:40 <pumpkin> :P
16:16:55 <pumpkin> okay, I'll give it a go
16:17:06 <ksf> you see, it's an accidental feature...
16:17:34 <ksf> the whole adt needs an overhaul.
16:17:46 <ksf> (and documentation)
16:17:57 <pumpkin> yeah :)
16:20:42 <joe1> a function that returns [IO ()], is it an impure function?
16:21:01 <ksf> nope.
16:21:14 <joe1> ksf: thanks
16:21:26 <ksf> unless you use unsafe functions, every haskell function is pure.
16:21:41 <ksf> (as in "referentially transparent")
16:21:42 <Zao> > let f x = cycle [x] in f (print "lol")
16:21:44 <hsbot>   No instance for (GHC.Show.Show (GHC.Types.IO ())) arising from a use of `M298439577.show_M298439577' at <interactive>:(2,0)-(4,30) Possible fix: add an instance declaration for (GHC.Show.Show (GH...
16:24:19 <pumpkin> ksf: what does the [TyVarBndr] do in the ForallC ?
16:26:58 <ksf> I don't think I ever figured that one out
16:27:28 <pumpkin> also, if I have associated types/data, do I just make the type/data family instances separately from the class, or is there a way to associate them in the TH AST?
16:28:22 <ksf> as it's a dec, it should er might be possible...
16:28:52 <enthropy> ksf: documentation is in the source, and some of will show up in haddock soon enough
16:29:09 <joe1> i feel very happy to learn that functions can be passed around in lists as data. Thanks to this irc, i understood this today.
16:29:51 <Saizan> joe1++
16:29:58 <pumpkin> joe1: yeah, functions are regular values 
16:30:05 <pumpkin> you can pass them around and do anything with them
16:30:10 <pumpkin> including sending them between threads and so on
16:30:32 <ksf> that's why they're also called jointoids.
16:30:48 <Saizan> really?
16:31:09 <Saizan> i mean, who uses that term?
16:31:20 <joe1> before this evening, all my haskell programs had atleast 2 or 3 levels of functions with do's in them. Now, I find that except for main, it is not needed..
16:31:23 <enthropy> pumpkin: you can't serialize them in ghc :(
16:31:24 <ksf> It's the most axiomatic first-class object grad students know of.
16:31:36 <pumpkin> enthropy: yeah :/
16:31:51 <joe1> ksf: what is jointoid?
16:32:01 <Saizan> enthropy: is there an haskell implementation where you can serialize them?
16:32:03 <ksf> anything you pass around.
16:32:11 <joe1> ksf: ok, thanks.
16:32:31 <enthropy> Saizan: I'm not ruling out the option
16:32:40 <ksf> cf. beeroids, which you don't pass around but instantiate more than once, instead.
16:33:20 <Saizan> enthropy: aw, you've just crushed my hopes
16:39:11 <pumpkin> enthropy: do you have any code that generates GADTs (that use type refinement) in TH?
16:39:30 <pumpkin> also, is TupleT 0 equivalent to ()?
16:39:41 <aristid> TupleT oO
16:48:11 <joe1> sorry, got disconnected.
16:48:19 <pickles> man, i have to learn the std libs better, i half re-invented the monoid
16:48:30 <osaunders> Any reason why DeriveFunctor doesn't appear in here: <http://www.haskell.org/ghc/docs/6.12.2/html/libraries/Cabal-1.8.0.4/src/Language-Haskell-Extension.html>?
16:48:41 <joe1> i am trying to see a list of [IO ()] from ghci
16:48:41 <sproingie> You Could Have Invented Monoids
16:49:03 <ksf> you can't show code.
16:49:48 <ksf> doing that in general would require partial evaluation, and ghc doesn't do that (yet)
16:50:07 <joe1> the only way to examine that list is by executing them, then?
16:50:28 <pickles> sproingie: tru
16:50:53 <ksf> yep
16:51:01 <int80_h> aristid: you still there?
16:51:14 <aristid> int80_h: yup
16:51:15 <int80_h> @seen aristid
16:51:15 <preflex>  aristid was last seen on #haskell 1 second ago, saying: int80_h: yup
16:51:17 <ClaudiusMaximus> urg, just heap-profiled my code and the vast bulk is taken up by:   pokeArray (imgdata :: Ptr Word8) (replicate (height * width * 3) (255 :: Word8))
16:51:27 <aristid> lol
16:51:32 <megajosh2> Err... something weird is up with my Haskell-evaluating command
16:51:35 <int80_h> arisitd: would you show me, using the code we were using, how to pass the cookie jar with each request?
16:51:40 <megajosh2> # 1 + 2
16:51:40 <gigajosh2> 3
16:51:50 <megajosh2> Now the next expression stays at 3
16:51:53 <megajosh2> # "test"
16:51:53 <aristid> int80_h: sorry, i don't use a cookie jar
16:51:53 <gigajosh2> 3
16:51:57 <megajosh2> :/
16:52:04 <int80_h> # 2.999999 + 2.99999
16:52:11 <megajosh2> It's admin-only
16:52:15 <int80_h> oh snap
16:52:19 <megajosh2> Since this is pretty naively implemented
16:52:33 <int80_h> I wanted to see if I could get 5
16:52:47 <int80_h> arisitd: no worries
16:52:58 <megajosh2> I'll show the code here... I don't get what's up with this
16:53:59 <sproingie> "Calm settles over Tijuana after 134 tons of marijuana burned"
16:54:34 <sproingie> "Munchies set in at downwind Tijuana"
16:54:35 <Martty> but that's just a day's production
16:55:14 <megajosh2> http://hpaste.org/40775/evaluation_command_is_acting_f I added comments showing where the code evaluating parts are
16:55:40 <aristid> int80_h: does your client have tabl completion?
16:55:49 <megajosh2> Line 136 & 161
16:56:41 <megajosh2> % QUIT
16:59:44 <ClaudiusMaximus> woop, from 33MB -> 700kB by foreign import memset
17:00:38 <pumpkin> :O
17:01:58 <megajosh2> # let something = 6 + 7 in something + 1
17:01:59 <gigajosh2> 14
17:02:04 <ksf> replicateM size (pokePtr image 255)
17:02:17 <megajosh2> # "hello " ++ "world"
17:02:18 <gigajosh2> 14
17:02:22 <megajosh2> :/
17:02:29 <pumpkin> ksf: might as well poke larger pointers in at a time
17:02:37 <pumpkin> but memset is probably way faster still
17:02:37 <ksf> yep.
17:03:02 <ClaudiusMaximus> speed wasn't the issue, the memory usage was..
17:03:11 <pumpkin> that's strange
17:03:14 <ksf> but constructing a list seems to be truly abysmal.
17:03:42 <ClaudiusMaximus> i'd need to check the core, but the list seemed to be being kept around instead of recomputed each time
17:04:16 <enthropy> pumpkin: have you thought of the performance of that Data projection function?
17:04:27 <pumpkin> enthropy: how so?
17:04:30 <enthropy> any ideas how it could be improved?
17:04:35 <pumpkin> oh
17:04:38 <pumpkin> the one you gave me yesterday?
17:04:42 <pumpkin> I decided to take a different approach
17:04:48 <enthropy> it's sort of O(n^2) for data types with n fields
17:04:54 <pumpkin> ack :P
17:05:52 <enthropy> pumpkin: what did you do then?
17:06:15 <pumpkin> enthropy: working on the GADT approach to it, with TH generating the boilerplatey GADT
17:06:42 <pumpkin> once I have the boilerplatey typeclass for my type, it's trivial to generate the functions I need
17:06:54 <pumpkin> it's Yet Another Generic Approach In Haskell
17:06:58 <pumpkin> YAGAIH ?
17:07:11 <enthropy> YAARGH
17:07:21 <pumpkin> yeah :P
17:07:38 <enthropy> the number of libraries is astounding
17:07:44 <pumpkin> I have a generalized algebraic data family representing type constructors
17:07:48 <pumpkin> data constructors, that is
17:08:00 <pumpkin> where the refined index is the equivalent nested tuple type of the constructor 
17:08:24 <enthropy> are you sure that's not been done before?
17:09:09 <pumpkin> I was looking for it
17:09:15 <pumpkin> was unable to find it :)
17:09:26 <pumpkin> in fact, I haven't come across anyone else using GADFs before for anything much
17:09:34 <pumpkin> I think part of the reason was they crashed GHC until just recently
17:09:41 <pumpkin> or nobody cared?
17:10:54 <enthropy> well what's the benefit of the G in there vs. other generics that project everything into a regular ADT (if I understand correctly)
17:11:14 <pumpkin> class Representable a where
17:11:14 <pumpkin>   data Constr a :: * -> *
17:11:14 <pumpkin>   extract :: Constr a b -> a -> Maybe b
17:11:14 <pumpkin>   inject  :: Constr a b -> b -> a
17:11:14 <pumpkin>   
17:11:15 <pumpkin>   constr  :: (forall b. Constr a b -> b -> r) -> a -> r
17:11:54 <pumpkin> then the instance looks something like
17:11:54 <pumpkin>   data Constr Moo a where
17:11:54 <pumpkin>     ConstrMooA :: Constr Moo (Int8, ())
17:11:54 <pumpkin>     ConstrMooB :: Constr Moo (Word64, (Int8, ()))
17:11:54 <pumpkin>     ConstrMooC :: Constr Moo ()
17:13:19 <pumpkin> then the magic function I want is unsafeIso x = Iso (fromJust . extract x) (inject x)
17:13:28 <pumpkin> where data Iso a b = Iso (a -> b) (b -> a)
17:13:52 <pumpkin> which gives me something like Moo -> (Word64, (Int8, ()))
17:15:02 * hackagebot explicit-iomodes-text 0.1.0.4 - Extends explicit-iomodes with Text operations  http://hackage.haskell.org/package/explicit-iomodes-text-0.1.0.4 (BasVanDijk)
17:16:03 * hackagebot usb 0.6.0.4 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.6.0.4 (BasVanDijk)
17:16:05 <pumpkin> enthropy: make sense?
17:16:34 <pumpkin> enthropy: the advantage over a regular ADT is that I can safely specify the type of the n-tuple I'm putting in or taking out
17:17:47 <Gracenotes> greetings pumpkin 
17:17:52 <pumpkin> greetings Gracenotes 
17:18:03 <Gracenotes> how you be doing, arr
17:18:42 <pumpkin> me eye be botherin' me matey, but otherwise the timbers be shiverin' (??? wtf did I just say)
17:18:45 <enthropy> pumpkin: I'm more familiar with the MPTC + Fundep way of doing things... it'll take a while for me to see
17:18:52 <joe1> i am trying to execute a list of lists of io actions: [IO (),[IO ()],IO ()]. Any suggestions, please?
17:19:07 <pumpkin> enthropy: not sure you can replicate this using anything but GADTs or the equivalent encoding using type equality and existentials
17:19:09 <enthropy> joe1: that's a type?
17:19:12 <joe1> I realise I cannot use concat on [IO ()] to make it a normalised IO(0
17:19:24 <pumpkin> joe1: that value has no type
17:19:24 <megajosh2> # 2 + 3
17:19:25 <gigajosh2> 5
17:19:32 <joe1> s/0/)/
17:19:35 <megajosh2> # Just a horrible parse error
17:19:35 <gigajosh2> Error:
17:19:45 <megajosh2> ...
17:19:56 <megajosh2> # 3 + 4
17:19:56 <gigajosh2> 5
17:20:00 <megajosh2> LIAR
17:20:23 <Gracenotes> @hoogle [m a] -> m ()
17:20:27 * enthropy is cool with existentials
17:20:36 <Gracenotes> you have failed me lambdybot
17:20:46 <megajosh2> Not here
17:21:06 <joe1> the code is here: http://hpaste.org/40776/io_list?pid=40776&lang_40776=Haskell
17:22:10 <dolio> pumpkin: Is that the one where he gives a generic algorithm for each class? Regular is decidable equality?
17:22:11 <enthropy> pumpkin: in the instance, do you say how to get those fields out?
17:22:27 <pumpkin> dolio: yeah, finite is decidable equality, iirc
17:22:35 <pumpkin> regular has kleene star which would give you infinite things
17:22:38 <pumpkin> not sure actually
17:22:39 <joe1> http://hpaste.org/40777/io_lists_again?pid=40777&lang_40777=Haskell
17:22:51 * pumpkin needs to dig up the paper again
17:22:56 <pumpkin> enthropy: yeah
17:22:56 <djahandarie> lispy, do you have access to the box lambdabot is on? Cale has disappeared
17:23:16 <dolio> pumpkin: You're not talking about Constructing Universes for Generic Programming, are you?
17:23:22 <joe1> pumpkin: any thoughts, on the code please?
17:23:23 <pumpkin> that's the one
17:24:32 <enthropy> pumpkin: so what happens if you're given a MooC but want your Int8?
17:24:40 <djahandarie> > fix error
17:24:44 <hsbot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
17:24:46 <pumpkin> enthropy: extract returns Nothing
17:24:48 <lambdabot> fix it yourself
17:24:50 <hpc> djahandarie: :D
17:25:20 <hpc> also, did lambdabot just make a pun?
17:25:21 <maurer_> W
17:25:25 <enthropy> pumpkin: and it's a type error if no constructor could contain those things?
17:25:34 <djahandarie> hpc, it's a fake
17:25:36 <lambdabot> puns aren't created, they're found
17:25:41 <pumpkin> enthropy: yeah, you have no way of constructing such a thing
17:25:50 <hpc> ah, figures
17:25:51 <guest2425> Hello
17:25:53 <pumpkin> enthropy: and for inject, the function can't fail
17:26:01 <joe1> hpc: any thoughts on the code here? http://hpaste.org/40777/io_lists_again?pid=40777&lang_40777=Haskell
17:26:06 <guest2425> guys I have a question about Haskell
17:26:26 <ksf> @slap lambdabot
17:26:28 <joe1> i have a list of lists of IO actions and am trying to use sequence_ on them.
17:26:40 * lambdabot 's head spins
17:26:46 <pumpkin> joe1: that's not a valid value
17:26:51 <pumpkin> testa is a list
17:26:56 <hpc> :t sequence_ . concatMap read
17:26:58 <pumpkin> you're putting into a list of non-lists
17:27:11 <pumpkin> joe1: all elements of a list must be of the same type
17:27:13 * lambdabot is looking up sequence_ ...
17:27:25 <enthropy> pumpkin: what I mean is your end result doesn't seem much different from a MPTC with one parameter Moo and the other being that list
17:27:35 <ksf> > let foo = if terminates foo then let x = x in x else () in foo
17:27:37 <hsbot>   Not in scope: `terminates'
17:27:50 <enthropy> besides the style of type errors you get
17:28:00 <pumpkin> enthropy: it's closed and it's impossible to construct invalid terms later on
17:28:02 <hpc> it appears it will typecheck
17:28:12 <enthropy> where  'no instance for <pages of garbage>' is different
17:28:15 <endojelly> ksf, trying to solve the halting problem?
17:28:21 <joe1> pumpkin: how would you recommend doing it?
17:28:28 <ksf> lambdabot can do it.
17:28:29 * lambdabot has given up on sequence_ and is going to make a sandwich.
17:28:41 <pumpkin> joe1: stick all your prints into a list if you really must
17:28:50 <endojelly> ksf, apparently, lambdabot can't even look up sequence_. and that one's really easy.
17:28:54 <pumpkin> [[print "moo], [print "baa"], mylistofprints, [..
17:28:59 <hpc> no, everything typechecks except for the list itself
17:29:03 <endojelly> ksf, you can have a sandwich instead of a halting problem solution, though.
17:29:04 <hpc> you have another list inside it
17:29:21 * lambdabot should have chosen to impersonate a computer when they weren't so tired....
17:29:27 <megajosh2> # Just 5
17:29:27 <gigajosh2> Just 5
17:29:30 <hpc> the definition of testa should have sequence_
17:29:32 <megajosh2> # Just 6
17:29:33 <gigajosh2> Just 5
17:29:56 <djahandarie> megajosh2, there is already another mueval instance running btw
17:29:56 <megajosh2> 3
17:30:00 <djahandarie> > "Right here."
17:30:03 <hsbot>   "Right here."
17:30:14 <megajosh2> I'm trying to get this command to work is all
17:30:16 <lambdabot> ^ right there
17:30:17 <joe1> hpc: i am sorry i do not understand
17:30:22 <megajosh2> I don't know what I'm messing up here...
17:30:28 <hpc> look at the type of testa
17:30:35 <djahandarie> megajosh2, this might not be the best place to test it...
17:30:43 <megajosh2> Yeah... I guess not
17:30:47 <hpc> it is [IO ()]
17:30:52 <guest2425> hello can you guys take a look at my code http://pastebin.com/YwqR1F42 
17:30:53 <megajosh2> % PART #haskell
17:30:55 <joe1> you mean return sequence_ as part of testa results
17:30:59 <hpc> look at the type of the big list in test
17:31:00 <guest2425> Thank you for your help
17:31:14 <hpc> you need to somehow flatten testa before you put it inside test
17:31:19 <lambdabot> sequence_ . concatMap read
17:31:19 <lambdabot>   :: (Monad m, Read (m a)) => [String] -> m ()
17:31:20 <joe1> hpc: yes
17:31:34 <enthropy> pumpkin: I think I get it now, thanks for explaining
17:31:51 <hpc> testa = sequence_ [print "junk", print "junk2"]
17:31:55 <hpc> ^ should make it compile
17:32:03 <dolio> pumpkin: I guess you must be right. None of his papers seems quite like what I was remembering, though.
17:33:13 <joe1> hpc: that was brilliant. 
17:33:17 <pumpkin> there's another paper with a similar shape to it that isn't just him
17:33:27 <joe1> thanks a lot. I was getting confused with the read.
17:33:27 <pumpkin> let me dig around for it
17:33:33 <dolio> I looked at all 4 on his website.
17:33:36 <pumpkin> oh
17:33:40 <joe1> hpc: sorry for the bother.
17:33:53 <hpc> never a bother
17:34:00 <lambdabot> ... the cake is a lie!
17:34:06 <osaunders> > 1 + 1
17:34:08 <hsbot>   2
17:34:17 <osaunders> @pl f x = x
17:34:21 <sipa1024> @vixen hi!
17:34:25 <lambdabot> 3, for extremely large values of 1
17:34:54 <guest2425> Any ideas of what I am doing wrong guys?   code http://pastebin.com/YwqR1F42 
17:34:54 <osaunders> Is lambdabot a person ATM?
17:34:59 <djahandarie> osaunders, yes.
17:35:06 <osaunders> How irregular.
17:35:08 <enthropy> markov bot obviously
17:35:19 <lambdabot> osaunders: sorry, i just had to take the opportunity to be an ass
17:35:49 <osaunders> You should answer all our > :t and @ requests.
17:35:55 <lambdabot> i've been trying
17:36:00 <osaunders> lol
17:36:04 <lambdabot> but am tired, so might not do so good a job
17:36:18 <hpc> :t let f = f f in f
17:36:20 <pumpkin> is there a way to ask TH to generate names without ridiculous suffixes?
17:36:29 <pumpkin> oh, mkName?
17:36:31 <enthropy> pumpkin: but hygene!
17:36:36 <pumpkin> fuck that :P
17:36:44 <lambdabot> sequence_ . concatMap read
17:36:44 <lambdabot>   :: (Monad m, Read (m a)) => [String] -> m ()
17:36:48 <lambdabot> gah, didn't copy
17:36:50 <lambdabot> 1 sec
17:36:51 <hpc> lol
17:36:56 <lambdabot> <interactive>:1:8:
17:36:56 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t
17:36:56 <lambdabot>     Probable cause: `f' is applied to too many arguments
17:36:56 <lambdabot>     In the expression: f f
17:36:56 <lambdabot>     In the definition of `f': f = f f
17:37:58 <pumpkin> yay, I generated my GADF
17:38:33 <pumpkin> now I just need my methods
17:38:43 <guest2425> pumpkin: Can you please give an idea of what I am doing wrong in this code  http://pastebin.com/YwqR1F42 
17:39:23 <pumpkin> guest2425: I have no idea what the stuff at the top is
17:39:44 <pumpkin> but you appear to have written a fold where you wanted a scan
17:40:11 <osaunders> @src scanl1
17:40:20 <lambdabot> lambdabot will brb
17:40:28 <osaunders> tisk
17:40:37 <osaunders> :)
17:42:02 <guest2425> pumpkin : I add the details for the function on the top http://pastebin.com/J0qX3Kwv
17:42:54 <pumpkin> okay, so you're pulling out the head and tail each time
17:43:02 <guest2425> yeah
17:43:23 <guest2425> but the scanl1 is supposed keep the head and add to the tail
17:43:27 <pumpkin> yeah
17:43:42 <pumpkin> this isn't a haskell question as much as asking how to solve your problem
17:43:47 <pumpkin> which I'd do if it weren't obviously homework :P
17:44:17 <guest2425> is not a Homework is a practice for a test next week 
17:44:30 <guest2425> so I want to get prepare for the test 
17:45:07 <pumpkin> start by writing down the type for mapReduce
17:45:11 <pumpkin> or asking ghci for it :)
17:45:26 <guest2425> ok
17:46:32 <guest2425> pumpkin: Here you go http://pastebin.com/u1TGqGjE
17:46:44 <pumpkin> here _you_ go!
17:47:19 <pumpkin> mapReduce :: (t1 -> t) -> (t1 -> t1) -> (t1 -> Bool) -> (t1 -> t2) -> (t -> t2 -> t2) -> t1 -> t2
17:47:27 <pumpkin> let's give the t1, t, and t2 meaningful names
17:47:43 <guest2425> t1 head
17:47:48 <guest2425> t2 tail
17:47:56 <guest2425> t = result
17:48:24 <guest2425> oh no
17:48:27 <guest2425> I  am wrong
17:48:43 <lambdabot> @src scanl1: Data.Vector.Storable
17:48:59 <guest2425> pumpkin: for example
17:49:04 <lambdabot> :t : a drink with jam and bread
17:49:16 <pumpkin> lambdabot: you're only supposed to speak when spoken to
17:49:20 <lambdabot> oh, sry
17:49:39 <guest2425> who is lambdabot
17:49:40 <pumpkin> guest2425: I mean, general abstract names for t, t1, t2 
17:49:41 <guest2425> ?
17:49:45 <pumpkin> guest2425: pickles
17:49:54 <lambdabot> aw, i've been found out
17:49:56 <pumpkin> normally it's a helpful bot that can run haskell and do related tasks
17:50:05 <pumpkin> but the real lambdabot seems to be offline right now
17:50:28 <guest2425> oh ok
17:50:48 <guest2425> ok
17:53:32 <ormaaj> multiplayer ghci
17:53:37 <ormaaj> mmorpg
17:53:53 <Sunhay_> beep a deep deep
17:54:02 <lambdabot> boop oop ba doop
17:54:56 * lambdabot is reminded of the other day when there was a discussion on the sentience of lambdabot....
17:55:18 <guest2425> pumpkin: like what type a names 
17:55:22 <Sunhay_> trippy
17:56:31 <lambdabot> would multiplayer ghci be mmorprog?
17:57:16 <enthropy> lambdabot: you're supposed to do multiplayer ghci
17:57:35 <lambdabot> right right, but that's hardly mmorpg
17:57:36 <pumpkin> guest2425: what would you describe those types as meaning, in general?
17:57:54 <guest2425> input and output
17:58:06 <guest2425> input calculation and result
17:58:25 <guest2425> pumpkin: input calculation and output
17:58:52 <pumpkin> okay, so your input and output are fixed, right?
17:58:54 <pumpkin> t1 and t2
17:59:10 <guest2425> yes
17:59:29 <pumpkin> so that means your calculation type needs to preserve the old values somehow
17:59:45 <pumpkin> how would you make it do that?
17:59:45 <guest2425> yeah that will be t
17:59:50 <ormaaj> IO calculation
18:01:10 <scipero> I have what is probably a very simple question on defining a list of floats...
18:01:26 <scipero> I'm working through Programming in Haskell and in chapter 5.
18:01:28 <pumpkin> why does Clause in TH take a list of Pats?
18:02:02 <scipero> The author gives the following (abbreviated):
18:02:07 <scipero> table :: [Float]
18:02:13 <scipero> table = [1.2, 3.4, 4.5]
18:02:23 <scipero> but both ghci and hugs give me an error.
18:02:38 <scipero> Any help? I can give whatever specifics might be helpful.
18:02:51 <pumpkin> "an error" 
18:02:59 <pumpkin> doesn't help us help you :)
18:03:17 <lambdabot> did you specifically enter "table = [1.2 ...]" into ghci?
18:03:45 <scipero> Specifically, then, hugs says ERROR - Syntax error in input (unexpected `=')
18:03:47 <lambdabot> because it's not like it would be in a script, you have to say "let table = [1.2 ...]"
18:03:53 <lambdabot> yeah, put a let before the table
18:04:10 <scipero> Is that true whether I enter it directly or use :load ??
18:04:11 <lambdabot> those command prompts actually put you inside a monad (the IO monad I think)
18:04:26 <pumpkin> if you load it from a file
18:04:31 <lambdabot> when you use :load that runs a .hs file, so you don't have to use the let then
18:04:31 <pumpkin> the file can contain table :: [Float] etc.
18:04:48 <enthropy> pumpkin: because it's     f x y z = ...  , where x y z are different patterns
18:04:54 <scipero> I've been using :load and that's what generates the error.
18:04:55 <pumpkin> enthropy: oh I see
18:04:58 <pumpkin> enthropy: thanks!
18:05:02 <lambdabot> hm
18:05:17 <lambdabot> can you paste the command you run exactly?
18:05:27 <scipero> For comparison, ghci gives "Couldn't match expected type `Float' against inferred type `a -> c'
18:05:51 <enthropy> TH is an interesting way to properly understand some portion of how haskell syntax works
18:06:08 <pumpkin> yeah, I've never really played around with this part of haskell
18:06:18 <scipero> The declaration is "table :: [Float]"
18:06:49 <scipero> The following definition is "table = [8.2, 1.5, 2.8, 4.3] and so on (with 26 numbers in it).
18:07:03 <enthropy> to know where wheres go and so on
18:07:15 <guest2425> pumpkin: How the tail can keep the numbers for later
18:07:25 <lambdabot> scipero: have those been in an .hs file or have those been directly into the command line?
18:07:37 <lambdabot> *entered directly into
18:07:42 <pumpkin> guest2425: don't think of it as the tail, think of it as your internal state
18:07:47 <scipero> lambdabot: I load them from an .hs file.
18:07:55 <lambdabot> hm
18:08:05 <pumpkin> guest2425: what's one way to keep lots of values around?
18:08:22 <lambdabot> could you paste a copy of the file on hpaste.org and send us the link to it?
18:09:28 <enthropy> scipero: ghci and hugs interactive work like you're in a do block of main
18:09:59 <scipero> Lambdabot: done. It's called caesar.hs
18:09:59 <enthropy> if you want the equivalent of a top-level declaration/function, you'd write    let x = [1,2,3]
18:10:12 <scipero> I'll try the let now...
18:10:14 <lambdabot> scipero: try running this line in ghci:
18:10:14 <lambdabot> let table = [8.2, 1.5, 2.8, 4.3]
18:10:36 <guest2425> pumpkin: doing recursion
18:10:37 <guest2425> ?
18:10:43 <pumpkin> guest2425: a list.
18:11:22 <guest2425> pumpkin: ok
18:11:23 <megajosh2> Does anybody have an idea why this is happening? http://hpaste.org/40779/code_is_only_evaluated_once
18:11:23 <scipero> enthropy: hugs now gives "unexpected keyword "let""
18:11:51 <megajosh2> A command I made for my IRC bot only evaluates code once; subsequent calls to it return the first result
18:11:54 <lambdabot> scipero: in your file, the third number in the list has a period after it instead of a comma
18:12:06 <enthropy> scipero: hmm, I guess I don't understand hugs then
18:12:09 <guest2425> pumpkin: so I need to make a list inside to keep the numbers
18:12:19 <scipero> The hpaste url is hpaste.org/40778/caesarhs
18:12:45 <pumpkin> guest2425: yes
18:13:08 <scipero> lambdabot: Yup. I knew it was a simple error, but not *that* simple. Many thanks for the sharp eye.
18:13:10 <guest2425> pumpkin: that will be in the tail correct
18:13:11 <guest2425> ?
18:13:14 <lambdabot> np
18:13:21 <lambdabot> glad i could help
18:14:23 <Veinor> megajosh2: is it giving you the same three-letter variable sequence each time?
18:14:42 <megajosh2> I don't think so
18:14:51 <sipa1024> pi time!
18:14:53 <megajosh2> I'll check...
18:15:13 <Veinor> 21:13:07         <sipa1024> pi time!
18:15:19 <Veinor> wow, my clock is off
18:15:47 <mauke> you're obviously in the wrong time zone
18:15:55 <Veinor> ... I'm also getting clock drift
18:15:58 <Veinor> stupid virtual machines
18:18:07 <pumpkin> omg my TH instance almost works
18:18:09 <megajosh2> Veinor: The 3 letter name is different each time, but the result of the evaluation isn't
18:18:26 <Veinor> that's bizarre
18:18:47 <Veinor> if you output the three-letter name instead of the evaluated, do you get the same output?
18:18:57 <megajosh2> Lesse...
18:20:22 <megajosh2> Veinor: The output is different each time when I output the variable name instead
18:20:36 <Veinor> interesting!
18:20:56 * lambdabot is retiring, good night all
18:21:00 <megajosh2> It also responds to type errors and parse errors in the code as expected
18:21:11 <joe1> hpc: in the program http://hpaste.org/40777/io_lists_again?pid=40777&lang_40777=Haskell the sequence_ in testa is executed immediately, isn't it? it returns an IO action and not a list of IO functions, isn't it?
18:21:36 <Veinor> does eval_ ("show " ++ str) not work?
18:22:11 <megajosh2> It did last time I checked... I'll see what happens
18:25:50 <megajosh2> Veinor: It does the same thing
18:25:58 <megajosh2> Constantly returns only the first evaluated result
18:27:06 <Veinor> that's incredibly odd
18:30:26 <Lumis> 9-11-2001 (American World Trade Center Bombing) was a US Government Psychological Opperation on the American public. 2 airplanes DO NOT CAUSE 3 BUILDINGS TO "IMPLODE" (CONTROLED DEMOLITION IS OBVIOUS TO ANYONE with Sence) the objective, to get the heard of midless following Americans to back wars in the middle east, to skyrocket stock of military industry, to expand oil industry. USA: THIS IS BAD
18:30:45 <Zao> Oh look, trolls.
18:30:54 <Veinor> :allears:
18:31:13 <Zao> I wish that they'd bother to spell things properly though.
18:31:27 <pumpkin> enthropy: is there an easy way to get the name of the (,) constructor?
18:31:30 <pumpkin> I can't use the ' notation for it
18:31:39 <enthropy> pumpkin: there's a function for that
18:31:47 <pumpkin> is there an app for that?
18:31:52 <enthropy> tupleDataName or so
18:32:01 <pumpkin> oh excellent
18:32:02 <pumpkin> thank you
18:32:03 --- mode: ChanServ set +o monochrom
18:32:09 <monochrom> oh, gone
18:32:13 --- mode: monochrom set -o monochrom
18:35:55 <pumpkin> wow, this is the ugliest TH code ever
18:38:32 <pumpkin> omg
18:38:35 <pumpkin> finished it
18:39:00 <dolio> I'll get your ugliest code ever award.
18:39:17 <kyagrd> Talking of TH how do you mix monadic values with TH?
18:39:39 <pumpkin> dolio: thank you!
18:39:57 <kyagrd> do { x <- mVal ; [| ... x ... |] } this won't work because x is a local binding and its int the same module
18:40:37 <kyagrd> There are two choices ;;; use unsafePerformIO or write entirely new versino of TH function that takes a monadic value instead of a plain one.
18:40:58 <enthropy> kyagrd: $x
18:41:04 <kyagrd> sorry :(
18:41:06 <enthropy> but what is mVal here?
18:41:25 <kyagrd> enthropy: I wrote a TH function and then I an reading that value from a file
18:41:45 <kyagrd> And realized that my TH function is very hard to use over them :(
18:42:23 <ksf> ..."incidentally", http://ns.inria.fr/active-tags/active-schema/active-schema.html uses sequence, cohice and alternation as primitives to desrcribe constraints.
18:42:28 <enthropy> so mVal :: Q Expr?
18:42:36 <kyagrd> no IO value
18:42:38 <enthropy> where the Expr is the contents of some file?
18:43:00 <kyagrd> I think I made the example wrong
18:43:10 <kyagrd> for instance if we have zipN TH function
18:43:17 <enthropy> you run IO in Q, using some function  f :: IO a -> Q a
18:43:19 <kyagrd> zipN : Int -> ExpQ
18:43:26 <enthropy> the name being something like runIO I think
18:43:34 <kyagrd> yeah
18:43:43 <kyagrd> and I have IO Int rather than Int
18:43:56 <kyagrd> then it's annying that I cant use zipN over that
18:44:16 <enthropy> then you         $(zipN =<< runIO myIOInt) a b c
18:44:38 <enthropy> this is how the monads work
18:44:44 <kyagrd> enthropy: right so I have to fetch the file every time I use zipN
18:45:09 <kyagrd> if file is large and takes much resource than it's not ideal
18:45:18 <enthropy> this happens at compile-time
18:45:31 <enthropy> oh, you want to cache this IO?
18:45:59 <kyagrd> yeah if I use them many times compile takes long
18:46:05 <enthropy> kyagrd: I think you're stuck unsafePerformIOing an IORef then
18:46:25 <enthropy> one of the more acceptable uses of that function
18:51:59 <joe1> if the return type of a function is "IO ()", is it an impure function?
18:52:32 <ezyang> You can think of it that way. 
18:52:40 <guest2425> pumpkin : I add numbers line to type of Map reduce can you please tell me in which line I need to create the list  http://pastebin.com/PwBhQKcf
18:52:53 <Zao> Or you can think of it as a pure function returning an IO action.
18:54:19 <joe1> can you please take a look at this code: http://hpaste.org/paste/40777/io_lists_agaun#p40780
18:57:56 <ksf> hmmmm
18:57:59 <ksf> hmmmm
18:58:15 <ksf> TH supports generating pragmas...
18:58:56 <ksf> so I can do {-# DOCUMENTATION ... #-} and then write an ugly perl script that makes haddock comments out of that.
18:59:16 <ksf> ...using noth, that is.
19:01:34 <pumpkin> once you figure out the basics of TH, it's pretty straightforward
19:01:39 <pumpkin> very boilerplatey though
19:01:56 <joe1> what is TH?
19:02:02 <pumpkin> template haskell
19:02:36 <ksf> active schema looks nice, but seems to be unmaintaned and unimplemented.
19:03:03 <ksf> well, nice in principle. in the end, it's bloated like every other xml thing.
19:03:28 <joe1> pumpkin: can you please help with the below code? I am trying to understand how to send out a blank IO action, as below:
19:03:31 <joe1> testb line = sequence_ [print "junktesta", print "junk2testa"]
19:03:33 <joe1> testb [] = return ()
19:03:40 <joe1> i cannot the 2nd line to work
19:04:00 <mauke> joe1: that can't work; the first line will always match
19:04:19 <joe1> i have tried testb [] = sequence_ [return ()]
19:04:37 <joe1> i cannot get it to compile, I actually had it the other way in the program
19:04:46 <mauke> joe1: what's the error message?
19:06:31 <joe1> it compiles without a type signature, but I tried adding a type signature of "testb :: String -> [IO ()]" and am not able to compile with this type signature.
19:07:33 <mauke> yeah, because that type signature is wrong
19:07:36 <joe1> i am trying to understand the type signatures of such a function and am having trouble doing so.
19:07:43 <mauke> and has nothing to do with "blank actions"
19:07:47 <monochrom> in ghci, use ":type testb" to find out the inferred type
19:08:36 <monochrom> (if ghci likes the file and doesn't whine)
19:09:19 <joe1> testb :: [t] -> IO () is what it says.
19:10:07 <monochrom> indeed observe that the parameter is a list type because some line says "testb [] = ..."
19:10:29 <ksf> .oO( String is a list type )
19:10:39 <monochrom> and the result type is IO() because some right-hand side says "sequence_ [stuff]"
19:10:55 <pumpkin> [t] -> IO () also shows that it can only ever reason about the shape of the list
19:11:02 <pumpkin> never about the values of the list
19:11:13 <pumpkin> it can't touch them in any way (but one)
19:11:27 <ski> joe1 : "if the return type of a function is "IO ()", is it an impure function?" -- no, but it is an effectful function
19:11:30 <ksf> unsafeCoerce to the rescue!
19:12:56 <joe1> ski: effectful function = function with side-effects, you mean.
19:13:28 <pumpkin> a function doesn't have side effects
19:13:37 <pumpkin> a value of IO a does, when executed
19:14:03 <pumpkin> a function returning IO a is building up a description of a (possibly) side-effectful action
19:14:10 <pumpkin> which can be passed around at will without actually running it
19:14:16 <ksf> well, it might increase the temperature of your cpu.
19:14:28 <ski> joe1 : "side-effects" is not the same as "effects"
19:15:01 <ski> joe1 : if there was no `IO' in the return type, but the function did I/O anyway, *then* it would be side-effectful
19:15:22 <ksf> and impure.
19:15:52 <ksf> though it might hide that fact with elaborate cheating.
19:16:00 <ski> joe1 : but because the `IO' is declared in the type, the effects don't happen on the "side", they are explicitly declared as part of the interface of the function. so it performs I/O-effects, but those are not side-effects
19:16:10 <joe1> as long as a function does only one thing and that is the return value, then it has no side-effects?
19:16:17 <ski> right
19:16:27 <ski> the I/O-effects here is part of the return value
19:17:24 <ski> the result of the function is an I/O-action, that *when*executed* (by some means), will actually perform some effects, and yield a value (in the above case, of type `()'
19:17:55 <joe1> ski: does sequence_ execute an IO action?
19:18:00 <ski> no
19:18:31 <ski> `sequence_' takes a list of actions, and constructs a new action, that when executed, will execute the actions in the list, in the order of the list
19:18:56 <joe1> got you, thanks a lot.
19:19:05 <ski> the only thing that starts execution of `IO'-actions in Haskell is the system executing `main :: IO ()'
19:19:46 <ski> since `main' is usually a compound `IO'-action, that will execute other ("smaller") actions .. and usually it will also evaluate various expressions, and call various functions
19:20:12 <ski> execution of `IO'-actions often cause evaluation of expressions, but never vice versa
19:20:34 <joe1> if String = [Char], for a list of functions: functionlist = [IO ()], in the similar vein, why can't there be [IO (),[IO ()], IO()]?
19:20:57 <ski> `[IO (),[IO ()], IO()]' is not a valid type
19:20:59 <roconnor> (though figuring out the next IO-action can also require evaluation)
19:21:08 <roconnor> joe1: have you see IO_Semantics on the wiki
19:21:16 <roconnor> @wiki IO_Semantics
19:21:17 <ski> every list must have elements of the same type, in Haskell
19:21:57 <joe1> gotcha. stupid mistake. it should be [ [IO()], [IO ()], [IO ()]]
19:21:58 <ski> if you're asking if you can have a list of several actions, all of type `IO ()', then sure
19:22:08 <joe1> just did not get it the last time hpc mentioned it.
19:22:17 <ski> you can also have a list of lists of `IO'-actions
19:22:27 <adnap> Is there a function in Prelude that's: in t min max = t >= min && t <= max
19:22:42 <ski> @type [[],[putStr "foo"],[return (),putStrLn "bar",print 12]]
19:22:52 <monochrom> [[IO()]]
19:22:57 <roconnor> adnap: there is inRange, but it really isn't designed for that
19:23:00 <ski> @botsnack
19:23:05 <roconnor> adnap: I'd write my own
19:23:08 <joe1> ski: thanks, that helped. Thanks a lot for being patient.
19:23:09 <monochrom> :)
19:23:55 <monochrom> and oh, http://www.haskell.org/haskellwiki/IO_Semantics
19:24:01 <ski> joe1 : so, `[ [IO()], [IO ()], [IO ()]]' is also not a valid type .. but presumably you meant the type `[[IO ()]]' ? .. which is the type of that list i showed above
19:24:25 <adnap> k
19:24:51 <roconnor> inRange is used for deterining if an index is inside array bounds
19:25:00 <ski> joe1 : in types, inside `[...]', there can only ever be *one* type (directly), so `[Int]' is ok, and `[(Int,Char)]' is ok, and `[IO Int]' is ok, and `[[IO Int]]' is ok
19:25:24 <ski> joe1 : but `[Int,Int]' or `[Int,Char]', or `[[IO ()],[IO ()]]' is not ok
19:25:33 <joe1> ski: thanks, yes i meant [[IO ()]]
19:25:55 <ski> joe1 : since every element in a list must have the same type, there is no point to writing that type more than once, so it is not allowed
19:26:01 <joe1> monochrom: just checking out the wiki lint
19:26:06 <joe1> s/lint/link
19:26:20 <joe1> ski: yes, makes sense.
19:27:24 <monochrom> I am just a bot
19:27:43 <roconnor> @monochrom-snack
19:27:46 <monochrom> :)
19:27:51 <ski> joe1 : so, there is no problem at all with something of type `[[IO ()]]' .. but you have to realize that this will be a list of lists of inert actions .. no I/O will be performed yet .. you can pass them around, but if you want something to happen, you need to use the `<-' in `do'-notation (or call something that does that, such as `sequence_')
19:28:39 <ski> s/something/some I\/O/
19:28:56 <joe1> ski: I could do sequence_ . map sequence_ $ [[IO ()]]
19:29:11 <ski> sure
19:29:37 <ski>   sequence_ [      ] = do return ()
19:29:54 <ski>   sequence_ (ma:mas) = do _ <- ma
19:30:08 <ski>                           sequence_ mas
19:30:29 <roconnor> that is the same sequence_ (concat iolistlist)
19:30:30 <ski> the `_ <- ma' there can be shortened to `ma', since the result is not used
19:31:17 <ski> joe1 : i hope this clears it up, somewhat ..
19:31:21 * ski needs to leave
19:31:32 <joe1> ski: it does help a lot. thanks a lot.
19:31:37 <ski> yw
20:02:04 <joe1> would anyone please have a free minute to check some code that I have. My gutfeel tells me that it is ugly and some structural changes might make it better.
20:02:34 <joe1> please let me know if you do and I will put it on hpaste.
20:04:51 * hackagebot pointless-rewrite 0.0.1 - Pointless Rewrite library  http://hackage.haskell.org/package/pointless-rewrite-0.0.1 (HugoPacheco)
20:04:55 <joe1> is it wrong to use sequence_? as [IO ()] becomes IO() and it could create an impression that it is one IO action?
20:05:23 <joe1> not in the main function, ofcourse. but in some 2nd level or 3rd level function.
20:06:34 <roconnor> joe1: I can look
20:06:55 <roconnor> joe1: using sequence_ is good
20:08:32 <joe1> thanks, please give me one sec and I will put it on hpaste.
20:10:24 <joe1> roconnor: http://hpaste.org/paste/40777/usb_messages#p40781
20:12:02 <ksf> you should refactor those head line == '<' && (head . tail . words $ line) == "0x4B"  into a function.
20:12:20 <ksf> foo x = head line == '<' && (head . tail . words $ line) == x
20:12:54 <ksf> return () at the end of a do block doesn't make any sense (at least in this case)
20:13:23 <ksf> try "import System.IO.Error as Err" and then use Err.try
20:13:42 <ksf> ...or say import ... hiding (try) for whatever package is clashing the name
20:14:09 <joe1> ksf: thanks, refactored. good idea.
20:15:16 <ksf> all in all, not bad for starters.
20:15:41 <ksf> ...but you're going to hate that code a few months from now.
20:16:41 <ksf> the main architectural issue is that you're doing IO, virtually all the time.
20:16:43 <joe1> ksf: what else would you recommend? I want to improve, please? 
20:17:17 <joe1> ksf: yes, I am generating some test code based on a messages file. could do it in awk/sed, but thought that haskell would be cleaner code.
20:17:34 <ksf> a cleaner approach would be to parse your stuff into a sequence of tokens, then convert that to an AST representing the output, and finally outputting.
20:17:50 <joe1> read messages file -> write simulation code to a file
20:18:07 <ksf> the resulting code cleanup will stagger you.
20:18:21 <joe1> ksf: i will try. i want to learn. 
20:19:14 <joe1> ksf: any suggestions on where I can find more details on the AST stuff. the parsing is not such a big deal. I could write the message (input) file as I want it.
20:19:25 <joe1> I could even write the message file into the haskell file, if that helps.
20:19:57 <ksf> start with something like data Token = Setup | Out | In |... and data AST = Comment | ...
20:20:24 <ksf> can you paste an output file?
20:20:26 <davekong> I made this short haskell application with hscurses and it seems to work OK, but if I hold down a key or press keys to fast I get:user error (Curses[-1]:wmove) any idea how to fix this? http://codepad.org/upeFL8yM
20:22:31 <ksf> http://en.wikipedia.org/wiki/Abstract_syntax_tree , in general.
20:23:11 <joe1> ksf: http://hpaste.org/paste/40777/output_code_file#p40782
20:23:16 <ksf> but it seems like you don't even have a tree, so you can just go [Token] -> [OutLine] , via concatMap
20:23:22 <joe1> ksf: the data files are just a series of bytes
20:24:14 <joe1> ksf: [Token] -> [OutLine], that is what I was doing, in my own newbie way..
20:24:37 <joe1> ksf: do you mean without the print statements?
20:24:43 <joe1> or the appendFile statements?
20:24:44 <ksf> yep. 
20:25:22 <joe1> and then run the appendFile as a mapM_ on the full list?
20:25:41 <ksf> oh wait, you're outputting to file and stdout
20:25:52 <joe1> yes
20:26:24 <joe1> the stdout is more to see what is going on.
20:26:43 <ksf> http://hackage.haskell.org/packages/archive/hslogger/1.1.0/doc/html/System-Log-Logger.html
20:26:56 <joe1> I could get rid of it or run mapM_ print intead of mapM_ appendFile on a duplicate list
20:27:13 <ksf> well nope that'd be IO, too.
20:27:38 <ksf> if it's just debug output to aid development, you can use Debug.Trace instead.
20:27:54 <ksf> otherwise, the Writer monad would be a good idea.
20:28:12 <joe1> I will checkout Debug.Trace. I think that might help.
20:30:10 <ksf> if you use hGetContents, your mapM_ print result will be one loop
20:30:23 <ksf> ...well, use constant space.
20:30:34 <joe1> ksf: forgot to mention, it is not just to stdout and one file, it is one code file, a particular data file(which changes for a different line) and stdout.
20:30:54 <joe1> I could get rid of the write to stdout, but I will still have writes to the code file and the data file.
20:31:18 <joe1> at the very minimum, i might end up with a three element tuple.
20:31:36 <joe1> (code to the code file, data filename , datafile contents)
20:31:51 <ksf> data Output = CodeLine | DataFileThingie | ...
20:32:22 <ksf> the processing function would have type Token -> [Output], so you can have an arbitrary number of actions going on.
20:33:10 <ksf> ...it's just cleaner to clearly separate the semantics of what you want to do and the ugly syntax you have to generate.
20:33:17 <joe1> i sense that what you are saying above with types is a good idea. but, i do not grasp the details yet.
20:34:22 <ksf> > let foo n = replicate n 'a' in foo [1,2,3,4]
20:34:24 <hsbot>   Couldn't match expected type `GHC.Types.Int' against inferred type `[a]'
20:34:25 <joe1> so, build up [Output] and then process that output list based on the data type
20:34:35 <ksf> > let foo n = replicate n 'a' in concatMap foo [1,2,3,4]
20:34:37 <hsbot>   "aaaaaaaaaa"
20:34:54 <ksf> > let foo n = replicate n 'a' in length . concatMap foo $  [1,2,3,4]
20:34:56 <hsbot>   10
20:35:11 <ksf> > let foo n = replicate n 'a' in length . (concatMap foo =<< [1,2,3,4])
20:35:13 <hsbot>   Couldn't match expected type `a -> [a1]' against inferred type `[GHC.Types.Char]'
20:35:17 <ksf> > let foo n = replicate n 'a' in length . (foo =<< [1,2,3,4])
20:35:18 <hsbot>   Couldn't match expected type `a -> [a1]' against inferred type `[GHC.Types.Char]'
20:35:21 <ksf> > let foo n = replicate n 'a' in length  (foo =<< [1,2,3,4])
20:35:22 <hsbot>   10
20:35:25 <ksf> (doh)
20:35:54 <ksf> (concatMap == (>>=) for the list monad)
20:36:16 <Jafet> @pl concatMap
20:36:30 <ksf> > let foo n = replicate n (show n) in length  (foo =<< [1,2,3,4])
20:36:31 <hsbot>   10
20:36:31 <joe1> > let foo n = replicate n 'a' in  concatMap foo $  [1,2,3,4]
20:36:32 <hsbot>   "aaaaaaaaaa"
20:36:36 <Jafet> Still no shipment of lambdas!?
20:36:38 <ksf> > let foo n = replicate n (show n) in (foo =<< [1,2,3,4])
20:36:39 <hsbot>   ["1","2","2","3","3","3","4","4","4","4"]
20:37:09 <Jafet> > (ap replicate show) =<< [1,2,3,4]
20:37:10 <hsbot>   ["1","2","2","3","3","3","4","4","4","4"]
20:37:48 <ksf> now that's one golf hole too much for me.
20:38:17 <joe1> ksf: i get the above code line but am not sure how I can use it.
20:39:53 <ksf> mapM_ interpret_output_adt . foo =<< hGetContents input_file
20:40:03 <ksf> mapM_ interpret_output_adt . foo . parse_input =<< hGetContents input_file
20:42:25 <ksf> where one of the Command constructors would look somewhat like TriggerIn { filename :: String, buffer :: String , address, String ... }
20:44:03 <ksf> so you can say foo Setup = [... , TriggerIn bdfilname buffer address , ]
20:45:16 <joe1> ksf: i sense what you are trying to say and it seems to be brilliant. But, I think I need to read up on AST before I can understand the details.
20:45:40 <ksf> well, it's just a data type that represents the syntax of a file.
20:45:53 <joe1> ok, will check it out.
20:46:51 <ksf> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/template-haskell-2.4.0.1/Language-Haskell-TH-Syntax.html
20:47:15 <ksf> that's a (arguably not too clean and utterly underdocumented) one for haskell
20:47:19 <joe1> thanks, will check it out.
20:48:29 <joe1> ksf: i did not have a clue what that page said. I will have to read up more on it. Would RWH help?
20:48:46 <ksf> not necessary.
20:49:41 <joe1> will dig around on google then.
20:50:34 <ksf> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing#Return_Values
20:50:42 <drostin77> isNewIrcClientWorking...
20:50:43 <ksf> that's a way smaller AST
20:50:49 <enthropy> somewhat better documented: http://code.haskell.org/~aavogt/libraries/template-haskell/Language-Haskell-TH.html
20:51:17 <ksf> I don't think you need a tree though, a simple non-recursive type will do.
20:53:21 <roconnor> joe1: sorry I got taken away from my laptop.  Did ksf help?
20:55:32 <joe1> roconnor: yes, ksf was brilliant. I need to get myself upto-speed on AST and stuff to understand the details of his suggestions.
20:56:20 <ksf> roconnor might be able to explain how to further improve that by using a zygohistomorphic prepromorphism, though.
20:56:24 <joe1> ksf: yes, I do not need a tree.
20:56:50 <joe1> roconnor: should I post the code again. will you please be able to give it a once-over?
20:56:56 <roconnor> sure
21:00:03 <joe1> roconnor: http://hpaste.org/paste/40777/scl_output#p40783
21:01:54 * roconnor looks
21:02:18 <roconnor> joe1: anything in particular I should look at?
21:02:50 <ksf> joe1, btw, you should listen to what hlint says
21:04:31 <joe1> roconnor: i want to get better not just at a syntax level but at the structure level. I think I am ok with haskell at the syntax level now, and I need to get to the next step ie., start to think in types, etc.
21:05:31 <joe1> ksf: yes, there were some suggestions on using mapM_ instead of map, etc. I find what you mentioned above more alluring than bothering with the hlint suggestions. 
21:06:01 <roconnor> joe1: you should avoid using head and tail, and use pattern matching isntead
21:06:30 <roconnor> joe1: you can do zip [1..5] and then drop the take
21:07:28 <roconnor> joe1: you can simply omit the "return ()"
21:07:39 <joe1> roconnor: i used the take 5, as I wanted to see a small portion of the output on the screen while I was running the program. I plan on removing it later.
21:08:18 <roconnor> oh ok
21:08:46 <joe1> roconnor: if remove  return (), i get an error. are you talking about the return () in line 199?
21:09:02 <joe1> if you are talking about the return() at the end of main, I thought I had removed that.
21:10:02 <joe1> roconnor: are you looking at post 40783? direct link: http://hpaste.org/40783/scl_output
21:11:35 <roconnor> oh
21:11:37 <roconnor> ya
21:11:43 <roconnor> I was looking at the wrong spot
21:15:59 <jeffwheeler> Before I start hacking around with it, I'm trying to understand what I can do with gtk2hs with custom widgets.
21:16:05 <jeffwheeler> Vim's Gtk UI has this special Form widget (http://goo.gl/xF9P) that I'd like to emulate, but I'm not sure if it's even possible.
21:16:28 <roconnor> joe1:  it seems a bit odd that msg2code is returning a list of IO ()
21:16:37 <ksf> jeffwheeler, did you read dante's inferno?
21:16:41 <roconnor> why not just use do and write all the action for each case in a do block
21:16:50 <jeffwheeler> ksf: well, for the class, I claimed to have
21:17:34 <ksf> well, let's say that extending a TK bound by the FFI is the secret level of hell that he didn't dare to describe.
21:17:40 <jeffwheeler> It seems like all the widgets in Gtk2hs are simple, but they all rely on their C counterparts . . .
21:18:14 <jeffwheeler> ksf: hmm, is it actually difficult? Or could it be possible without touching FFI?
21:18:39 <roconnor> joe1: the problem with head and tail is that your program will crash if the line is wrong, instead of returning false.
21:19:04 <jeffwheeler> I guess I sorta assumed that my widget could be remain a Container underneath (as far as the C knows), but I provide special behavior that works with the type
21:19:08 <joe1> roconnor: thanks. will use patternmatching instead.
21:19:22 <roconnor> joe1: you need to write something more like is_setup_token line = take 2 (words line) == [">","0x2D"]
21:20:27 <ksf> iirc gtk2hs doesn't support custom widgets, but I could be wrong.
21:20:47 <ksf> ...at least implementing them in haskell, that is.
21:20:57 <joe1> roconnor: something like this: is_data0_packet line@('>','>','>','>','>',' ','0','x','C','3') = True 
21:21:24 <ksf> all this reliance on foreign gui systems is a long-standing grudge of mine
21:21:33 <roconnor> joe1: is_setup_token line = take 2 (words line) == [">","0x2D"]
21:22:01 <jeffwheeler> ksf: Would it even be possible to write an all-Haskell gui library? Wouldn't you, at some point, have to interface with X11 or so?
21:22:11 <joe1> roconnor: thanks.
21:22:11 <ksf> but, alas, neither reactive is ready for production nor do we have a really good way to do extensible records, yet.
21:22:48 <ksf> yes, sure, but you could do haskell-level drawing combinators and event abstraction
21:23:31 <ksf> ...and client code of a tk shouldn't care whether it runs on x11, svgalib or whatnot.
21:24:28 <jeffwheeler> ksf: indeed, yeah; mostly, I just wanna see if I can get the same type of Gtk UI that vim has in Yi
21:24:34 <jeffwheeler> ksf: mostly out of curiosity
21:25:12 <ksf> I don't even use vim's gui.
21:26:55 <ksf> what about writing an x11/whatever library that could be used as the graphical backend of a terminal emulator?
21:27:23 <ksf> xhb/freetype or something, without all that gtk overhead.
21:27:38 <ksf> or even gl/ftgl, for starters.
21:27:44 <roconnor> joe1: I'd use ++ as infix in comment
21:28:04 <jeffwheeler> ksf: because I want some gtk features, like tabs and sometimes menus
21:28:16 <ksf> xmonad does those.
21:28:26 <jeffwheeler> ksf: Gtk tabs and menus?
21:28:27 <ksf> ...well, not menus per se, but the rest.
21:29:21 <ksf> ripping the x11 part out of it and doing a single-window mode would be a cool idea, more than one haskell app might want to have decent window management.
21:30:11 <ksf> I don't know how xmonad draws its tabs, I'd presume raw xlib.
21:30:58 <blueonyx> \
21:32:39 <jeffwheeler> ksf: hey, maybe I could go with a terminal emulator, vte looks pretty convenient
21:36:25 <joe1> roconnor: thanks for your help.
21:37:14 <guest2524> Hell
21:37:16 <guest2524> Hello
21:37:26 <guest2524> every one
21:37:55 <ksf> > replicate 586 "Hello, guest2524"
21:37:57 <hsbot>   ["Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hello, guest2524","Hel...
21:38:21 <guest2524> I have a question
21:38:25 <guest2524> about Haske;;
21:38:49 <guest2524> about Haskell
21:38:52 <guest2524> sorry 
21:39:10 <roconnor> joe1: I think you should replace your list of IO actions with a do block
21:39:25 <roconnor> joe1: unless you think you will only want to do part of the list of actions sometimes
21:39:35 <ksf> roconnor, I was trying to get him to use intermediate data types.
21:39:42 <roconnor> oh
21:39:50 <roconnor> um 
21:39:51 <roconnor> ok
21:40:13 <roconnor> it's a bit wierd
21:40:18 <ksf> it is
21:40:25 <guest2524> Can you guys check my code please http://pastebin.com/RXAfsPHS
21:40:27 <guest2524> ?
21:41:12 <ksf> (\(x1:x2:xs)
21:41:28 <ksf> ...matches only lists that have at least two elements.
21:41:42 <guest2524> oh 
21:42:01 <guest2524> so how can i add more elements?
21:42:48 <ksf> I think you want something like f (x1:x2:xs) =( x1+x2):xs ; f xs = xs
21:43:12 <ksf> that is, if there's only one (or zero) elements left, the list stays the same.
21:44:11 <guest2524> ok thank you
21:45:23 <guest2524> ksf: you mean this line correct
21:45:31 <guest2524>    (\(x1:x2:xs) -> (x1+x2):xs) 
21:45:34 <ksf> yes
21:46:00 <ksf> I don't really know what you're trying to do, but my f above at least won't pattern-fail.
21:46:49 <guest2524> oh I am trying to implement the scanl1 like this scanl1 (+) [1,2,3] = [1,3,6]
21:47:26 <ksf> ...I'm just confused by the mention of (+) in a generic function.
21:47:52 <guest2524> oh my can take any symbol
21:47:56 <guest2524> like + - *
21:48:06 <guest2524> oopss sorry my f
21:48:54 <republican_devil> common lisp and haskell are very cool
21:50:46 <Bercilak> Hi gang, I'm trying to install snap server and I keeping getting dependency errors from cabal. I reinstall the dependency, then some other package fails so I reinstall that. I try to install snap again, and an error due to a dependency error, and so forth... I finally made cabal reinstall *everything* and tried again. No dice.
21:51:16 <Bercilak> here's the paste of my latest error: http://hpaste.org/40784/snap_install_error
21:51:22 <Bercilak> anybody got any ideas
21:51:46 <ksf> missing or recursive is bad.
21:51:53 * ksf suggests nuking ~/.cabal
21:52:06 <Bercilak> has not worked :-/
21:53:32 <ksf> the interesting thing is that it fails _after_ resolving...
21:54:05 <ksf> try cabal unpack snap-core ; cd <directory>, runhaskell Setup.hs install --user
21:56:36 <guest2524> I am getting another error message http://pastebin.com/L1j58dA0
22:00:53 <monochrom> exactly what the error message says. you haven't made up your mind whether t1 should be a tuple type or a list type.
22:09:21 <guest2524> monochrom : and can i declare that
22:09:34 <pumpkin> I like how no documentation nor comments seem to mention what the purpose of qRecover in the quasiquoter class is for
22:09:50 <guest2524> sorry and how can i declare that
22:10:14 <monochrom> you cannot declare self contradiction.
22:11:11 <guest2524> monochrom: any idea how can I fix the error?
22:11:22 <jeffwheeler> guest2524: pick how you want to use it, and use it that way
22:11:46 <jeffwheeler> guest2524: right now, you're using it two different ways
22:12:08 <monochrom> I have no idea how to fix the error. I don't know what is the purpose. And I don't want to know.
22:12:36 <monochrom> (Or rather, I don't want to read a programmer's explanation. It is always muddled.)
22:12:38 <guest2524> monochrom: nice and honest 
22:13:34 <monochrom> for wayAheadFn, you gave it (\(z, x:xs) -> ((f z x), xs)), so this makes t1 a tuple
22:13:58 <guest2524> jeffwheeler: oh oh I hate haskell now another error 
22:14:09 <jeffwheeler> guest2524: okay
22:14:24 <monochrom> for mapFn, you gave it (\xs -> head xs), so this makes t1 a list.
22:14:45 <guest2524> ok
22:15:24 <monochrom> I am just a bot and I cannot guess what people mean when they are inconsistent.
22:15:38 <guest2524> huh
22:16:24 <guest2524> monochrom: You are a boot up only?
22:16:42 <monochrom> no. I am a shut down too. :)
22:16:56 <guest2524> oh my god you are funny
22:17:08 <guest2524> so thats mean you are a computer not a human
22:17:15 <republican_devil> anyone here in a startup?
22:17:43 <republican_devil> I had a problem I solved with bash today, and I am curious how a haskeller woulda solve it?
22:17:56 <republican_devil> anyone game?
22:18:16 <Jafet> Sure, $5 of your venture capital up front
22:18:22 <shachaf> republican_devil: You'd be better off posting the problem and letting people look at it than waiting for someone to respond.
22:18:30 <republican_devil> k
22:19:00 <monochrom> talk about lazy strings
22:19:30 <monochrom> "today's lecture is on lazy evaluation. any questions?"
22:20:00 <jeffwheeler> monochrom: Thank you for that.
22:20:03 <guest2524> jeffwheeler : A new error message http://pastebin.com/983ewMtZ
22:20:17 <guest2524> any idead
22:20:20 <guest2524> any idea
22:20:22 <guest2524> sorry
22:20:24 <Jafet> questions `seq` talk
22:20:33 <jeffwheeler> guest2524: it guesses for you
22:20:41 <jeffwheeler> guest2524: did you read the entire error message?
22:21:01 <guest2524> yes
22:21:27 <guest2524> jeffwheeler: but i did specific what to do
22:21:35 <guest2524> and when to stop
22:21:39 <jeffwheeler> what?
22:21:52 <guest2524> jeffwheeler: in the function
22:24:02 <guest2524> jeffwheeler: what i wanted to say is why is guessing?
22:24:26 <jeffwheeler> guest2524: it's telling you what your mistake probably is, it's not guessing that there's an error
22:25:42 <guest2524> effwheeler: I am lost 
22:25:58 <guest2524> jeffwheeler: I am lost
22:26:53 <republican_devil> http://pastebin.ca/1970560
22:31:32 <guest2524> jeffwheeler: would you guide me
22:31:54 <jeffwheeler> guest2524: it told you where to look; I'd play with what it said was erroneous
22:32:08 <jeffwheeler> guest2524: Try rewriting that line a few times
23:02:50 <guest2524>  is possible to do this using foldr  - > function  [3, 1, 6, 4, 2] = [1,3,2,6,4]
23:03:24 <dolio> Yes.
23:03:30 <guest2524> oh 
23:03:50 <guest2524> but foldr only unfold the list dont order the list
23:04:23 <guest2524> dolio: correct dolio 
23:04:25 <guest2524> ?
23:05:03 <guest2524> dolio: I need to use something else than foldr any clue 
23:05:07 <dolio> I don't really understand your question. What foldr does depends on the function you give it.
23:06:18 <dolio> It will look like: foldr f []
23:06:24 <guest2524> but that type sort will sort the list and this list is not in order
23:06:25 <dolio> f is what you have to figure out.
23:06:51 <guest2524> oh ok
23:07:51 <guest2524> dolio: the mistery is f
23:07:53 <guest2524> hahaha
23:07:53 <dolio> This is a question on a practice exam, right?
23:08:20 <guest2524> dolio: what you said that?
23:10:33 <dolio> You're not the first person from you class to be here. :)
23:12:21 <guest2524> dolio: oh ok
23:12:37 <guest2524> any idead
23:12:41 <guest2524> *idea
23:12:48 <guest2524> clues
23:13:32 <guest2524> dolio: any idea or clue 
23:14:00 <jeffwheeler> dolio: haha, is it?
23:14:15 <dolio> So, what foldr f [] will do...
23:14:51 <dolio> Is compute:  f 3 (f 1 (f 6 (f 4 (f 2 []))))
23:14:53 <guest2524> that is that part that i dont get it because the list result is not in order
23:15:32 <dolio> So you want an f such that that gives the right list.
23:15:45 <guest2524> yeah
23:16:38 <guest2524> dolio: but the list is not in order I mean sort the result list
23:17:09 <guest2524> function  [3, 1, 6, 4, 2] = [1,3,2,6,4] so foldr will move the odds to the front and then the evens
23:17:25 <dolio> No, that's just an accident.
23:17:26 <guest2524> dolio: function  [3, 1, 6, 4, 2] = [1,3,2,6,4] so foldr will move the odds to the front and then the evens
23:17:34 <guest2524> oh ok
23:18:02 <dolio> What should happen is that it compares each pair of numbers, and swaps them so that the lower number is first.
23:18:06 <dolio> Starting at the end of the list.
23:18:26 <davekong> Is there someway to disable keyboard input for parts of a program? I don't want people pressing keys at random times and then the keys sitting around to get read automatically later
23:18:52 <turiya> i have a 100% cpu usage for a very small program.. how do i reduce this?
23:19:14 <Veinor> turiya: can you pastebin your program?
23:19:37 <guest2524> turiya: you have a loop infinite loop
23:19:39 <guest2524> maybe
23:19:40 <dolio> Isn't 100% good? It's not bottlenecking on anything else. :)
23:20:22 <guest2524> dolio: so it will only sort the pairs
23:20:35 <dolio> Yes. That's how bubble sort works.
23:20:42 <turiya> guest2524: yes, i do have an infinite loop..
23:20:54 <dolio> You keep sorting individual pairs of elements, and eventually the whole list will be sorted.
23:21:05 <guest2524> turiya: why you have an infinite loop
23:21:13 <guest2524> it has to stop at some time
23:21:32 <turiya> the infinite loop is to process user input
23:21:51 <guest2524> turiya: yeah but it should be a key to exit that loop
23:22:01 <turiya> yes
23:22:40 <guest2524> dolio: so bubble sort is done with foldr
23:22:41 <guest2524> ?
23:22:52 <turiya> Venior: I tried to paste the code but it isnt very readable.. the formatting is bad
23:23:20 <dolio> No. But part of it is.
23:23:31 <dolio> The part that compares each pair of elements once.
23:25:24 <guest2524> oh my 
23:25:30 <guest2524> a big headache
23:27:03 <guest2524> dolio: I need to use a function from Data.list?
23:27:16 <guest2524> do I need to use a function from Data.list?
23:28:26 <guest2524> like this for insertion sort insertsort  =  foldr insert []
23:29:05 <turiya> Veinor: http://hpaste.org/40785/cpu_usage1, http://hpaste.org/40786/cpu_usage2, http://hpaste.org/40787/cpu_usage3, http://hpaste.org/40788/cpu_usage4
23:29:48 <guest2524> dolio:like this for insertion sort insertsort  =  foldr insert []
23:29:57 <Veinor> turiya: oh... sorry, I don't know anytbhing about sdl :/
23:30:32 <turiya> Veinor: oh
23:31:37 <turiya> dont know if the problem is with displaying the image or the infinite loop there..
23:33:46 <dolio> guest2524: No.
23:34:34 <guest2524> dolio: ok
23:35:10 <guest2524> dolio: swap
23:35:11 <guest2524> ?
23:35:31 <guest2524> dolio: OMG i am guessing hahahah
23:35:48 <davekong> How do I clear the keyboard buffer?
23:40:00 <guest2524> dolio: Any idea
23:41:03 <dolio> You want to compare pairs of elements.
23:41:30 <dolio> f will be passed an element, and a processed list.
23:42:11 <Cobra_> turiya: SDL.pollEvent returns immediately, it doesn't block
23:42:21 <dolio> And you want f to return a list where the first two elements are in order.
23:42:28 <guest2524> yes
23:42:30 <Cobra_> you probably want to block using SDL.waitEvent
23:42:35 <dolio> So write it.
23:42:54 <guest2524> dolio: I am confuse 
23:47:42 <dolio> guest2524: Write a function:   f :: Ord a => a -> [a] -> [a]
23:47:58 <guest2524> got it 
23:48:02 <guest2524> one second
23:48:05 <dolio> 'f x l' should return a list with all the elements of l, plus x.
23:48:13 <dolio> And the first two elements should be ordered.
23:49:53 <guest2524> dolio: insert can do that
23:50:17 <dolio> It can, but it isn't the function you want.
23:50:25 <guest2524> oh 
23:51:07 <guest2524> insertBy
23:51:28 <dolio> If f = insert, then foldr f [] sorts a list.
23:51:35 <dolio> But that's not what you're supposed to write.
23:51:50 <guest2524> yes
23:52:34 <guest2524> but I can use scanr
23:52:59 <guest2524> no
23:53:32 <guest2524> dolio: filter
23:54:11 <guest2524> dolio: foldr takes three arguments: a function, a seed value, and a list. 
23:57:29 <guest2524> dolio: I am lost
