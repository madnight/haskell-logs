00:01:05 <republican_devil> is software transactional memory the same as communicating squential processes?
00:02:24 <Axman6> i don't really know much about CSP, how would they be related?
00:02:27 <ddarius> No.
00:02:51 <jamy> this is offtop
00:05:19 <kmc> republican_devil, they are not the same
00:05:47 <kmc> both are systems for concurrent programming, and have been implemented in Haskell
00:06:01 <Axman6> jamy: huh?
00:06:24 <jamy> yes huh!
00:07:25 <Axman6> i assume by offtop you mean off topic? if so, i fail to see how...
00:08:33 <jamy> course off topic! what more else?
00:09:24 <Axman6> well, it wasn't at all off topic
00:09:28 <EvanR> i must prefer top off
00:09:37 <kmc> STM and CSP have both been implemented in Haskell
00:09:42 <kmc> and are frequently discussed here
00:10:36 <jamy> kmc: whats STM and CSP?
00:10:46 <Axman6> @hoogle STM
00:10:47 <lambdabot> module Control.Concurrent.STM
00:10:47 <lambdabot> module Control.Monad.STM
00:10:47 <lambdabot> package stm
00:10:56 <kmc> jamy, the two things republican_devil mentioned
00:11:38 <pelotom_> @hoogle CSP
00:11:38 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
00:12:05 <jamy> kmc: its i see. What its real mean?
00:12:12 <kmc> http://chplib.wordpress.com/  <--- CSP for Haskell
00:12:23 <kmc> jamy, they are two ways of structuring concurrent programs
00:12:32 <kmc> http://hackage.haskell.org/package/chp
00:13:24 <jamy> concurrent programs?
00:13:28 <kmc> yes
00:13:38 <kmc> programs with multiple threads of control
00:13:42 <pelotom_> is CSP basically actors?
00:13:53 <kmc> they're similar, i can't say precisely how they relate
00:14:25 <Maxdamantus> Is IO an example of CSP?
00:14:47 <EvanR> theory of IO
00:14:51 <EvanR> here we go
00:15:04 <kmc> no
00:15:08 <Maxdamantus> By IO, I mean the IO type in Haskell
00:15:11 <Maxdamantus> Not IO in general
00:15:23 <EvanR> the IO type in haskell is IO in general
00:15:23 <kmc> CSP doesn't just refer to any sequential processes that communicate
00:15:35 <kmc> it's the name of a specific formalism which has inspired various programming languages and libraries
00:16:01 <jamy> i see!
00:17:02 <Maxdamantus> Oh wait, CPS != CSP
00:17:13 <Maxdamantus> er, /= (
00:18:22 <pelotom_> yes, that acronyms are not commutative :)
00:18:24 <jamy> what mean character "|" ?
00:18:35 <EvanR> or
00:18:37 <kmc> where?
00:19:02 <jamy> only "or" ?
00:19:27 <Maxdamantus> or and
00:19:28 <Twey> ‘Guard’
00:19:49 <pelotom_> it can introduce a guard clause
00:20:37 <pelotom_> in which case it means something like "where"
00:20:50 <Axman6> jamy: we need context if you want useful answers
00:21:12 <Twey> There's no ‘can’ about it.  | 1) introduces a guard clause and 2) separates the map from the select in a list comprehension
00:21:13 <Maxdamantus> Where a question mark is where ends the where.
00:21:21 <Axman6> otherwise we'll be forced to give answers like: | is used to pipe the output of one program into another program, in most unix shells
00:21:29 <Axman6> it is also bitwise or in C
00:21:44 <Axman6> and it is many many other things
00:21:47 <pelotom_> Twey: it also means "or" in data definitions
00:21:52 <Axman6> it makes good borders for ascii boxes
00:21:54 <Twey> Ooh, that's true.
00:21:58 <Twey> Missed that one.
00:22:47 <jamy> data Rank = Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten
00:22:47 <jamy>   | Jack | Queen | King | Ace
00:22:47 <jamy>   deriving (Bounded, Enum, Eq, Ord, Show, Read)
00:23:10 <pelotom_> jamy: "or"
00:24:02 <jamy> and what meaning that code?
00:24:06 <pelotom_> it's saying the type "Rank" is one of Two, Three, Four... etc.
00:24:52 <jamy> and what is it data?
00:25:29 <Maxdamantus> It emphasises that you're defining a set of data constructors.
00:25:29 <pelotom_> data is encoded information
00:26:05 <jamy> and what is it deriving?
00:26:22 <sipa> jamy: it defines a type 'Rank', with 13 instances, called Two, Three, ...
00:26:34 <EvanR> 13 constructors
00:26:38 <EvanR> 6 instances
00:26:55 <sipa> EvanR: that's the correct terminology :)
00:26:55 <pelotom_> that's automatically figuring out type class instances for the data type
00:27:03 <sipa> the deriving Show means that a 'show' function will automatically be generated for it
00:27:29 <sipa> deriving Eq means that an == operator will be automatically generated
00:29:02 <kmc> jamy, you should read a haskell tutorial
00:29:27 <pelotom_> jamy: http://learnyouahaskell.com/
00:29:31 <jamy> then "Rank" is type description of object cards?
00:30:06 <sipa> > data Rank = Two | Three
00:30:07 <lambdabot>   <no location info>: parse error on input `data'
00:30:11 <sipa> :(
00:30:16 <jamy> i read her now. Now in part about functors
00:30:37 <kmc> jamy, then you're moving really fast
00:30:44 <kmc> you should have encountered data definitions long ago
00:30:45 <sipa> jamy: you mean functors, or functions?
00:30:46 <pelotom_> you should read the earlier parts, about data ;)
00:31:58 <jamy> its only few part of she translate on my language
00:32:37 <sipa> then i would still suggest you try other parts in english
00:33:34 <sipa> it may take you more time, but you shouldn't be learning about functors (but maybe about function... sure that's not what you're reading?) while you haven't understood data
00:33:43 <pelotom_> jamy: what's your language?
00:34:00 <jamy> then i get a mess
00:34:31 <jamy> RU. again!
00:37:34 <pelotom_> http://translate.google.com/translate?js=n&prev=_t&hl=en&ie=UTF-8&layout=2&eotf=1&sl=auto&tl=ru&u=http://learnyouahaskell.com/making-our-own-types-and-typeclasses
00:37:35 <Axman6> isn't there a #haskell.ru?
00:40:32 <jamy> pelotom_: on russian this seems like i saying on English :)
00:41:03 <pelotom_> jamy: I bet ;)
00:41:59 <Zeiris_> Are there any Haskell-C# bindings? (For developing a UI frontend in C#, with the backend in Haskell.)
00:42:45 <pelotom_> especially since the guy who writes learnyouahaskell is uses a lot of very idiomatic english
00:44:11 <jamy> better i read on English or read http://www.haskell.org/haskellwiki/Practice_of_Functional_Programming which borring
00:45:04 <jamy> sorry! This http://www.haskell.org/haskellwiki/Functional_Programming_in_Haskell
00:45:06 <kmc> Zeiris_, i think the easiest way to accomplish such things is separate processes communicating by one of many RPC protocols or serialization formats
00:45:16 <Zeiris_> Figures.
00:45:30 <kmc> Zeiris_, that said, there's hs-dotnet and Salsa
00:45:34 <kmc> and of course FFI via C
00:46:48 <kmc> it seems like most successful webapps, for example, consist of many programs on many machines in several languages loosely coupled via simple RPC / messaging mechanisms
00:47:28 <Zeiris_> Those are running on a controlled system maintained by professionals, though. I can't help but worry about user machines being more fragile.
00:50:16 <pelotom_> Zeiris_: why a desktop app? why not a webapp?
00:51:07 <Zeiris_> Well, on rare occasions I want to write standalone desktop apps for windows. I'm pondering how I can do so in Haskell rather than C++.
00:51:33 <Zeiris_> Telling users to install Tk is not a selling point... The idea of running a web server on local host for the UI is interesting though.
00:52:03 <Zeiris_> I remember seeing some paper on "formlets", and there's that Haskell On a Horse thing. Could be fun.
00:53:09 <pelotom_> what about something JVM-based?
00:53:16 <pelotom_> scala or clojure
00:53:20 <Jafet> import definitely unqualified System.WinAPI
01:15:09 <chrisdone> anyone get this question when connecting to scion?
01:15:09 <chrisdone> Versions differ: 2 (scion client) vs. 1 (scion server). Continue? (y or n) 
01:15:09 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:16:11 <chrisdone> (on the default devel branch)
01:18:08 <chrisdone> @messages -- better not be naughty!
01:18:08 <lambdabot> aristid asked 1d 16h 13m 39s ago: How does the "run paste" thing work?
01:18:08 <lambdabot> pumpkin asked 1d 10h 51m 31s ago: could you add agda as a language option in hpaste and just use the haskell parser on it, for now? at least it'll be easy to tell at a glance on the overview which
01:18:08 <lambdabot> pastes are agda
01:18:24 <chrisdone> sure thang
01:19:50 <chrisdone> added a channel too
01:20:36 <chrisdone> aristid:
01:20:36 <chrisdone> @hackage codepad
01:20:36 <lambdabot> http://hackage.haskell.org/package/codepad
01:26:18 <chrisdone> pumpkin: http://hpaste.org/40445/agda_test_paste_will_expire
01:31:08 <donri> t3eblinder and joyfulgirl, fuck you mind making me read tubegirl
01:32:21 <chrisdone> no swearing please, as punishment you have to demonstrate fibonacci in lambdabot, with fix
01:32:46 <donri> Oh soz :$
01:33:38 <donri> chrisdone: Fix mo?
01:34:08 <chrisdone> :t fix
01:34:09 <lambdabot> forall a. (a -> a) -> a
01:34:14 * chrisdone waits
01:34:23 * chrisdone folds arms
01:34:29 <donri> :(
01:34:53 <donri> > fix me some coffee, please?
01:34:54 <lambdabot>   <no location info>: parse error on input `,'
01:34:57 <donri> :(
01:35:02 <dolio> That's bush league.
01:35:07 <dolio> Demonstrate it *without* fix.
01:35:39 <dolio> And no direct recursion, either, of course.
01:36:13 <sipa> > let fib i = [1,1,2,3,5,8,13,21,34,55,89]!!i in fib 5
01:36:14 <lambdabot>   8
01:36:17 <sipa> there you go
01:36:39 * chrisdone taps foot
01:37:25 <donri> > fibs = fix ((0:) . scanl (+) 1)
01:37:26 <lambdabot>   <no location info>: parse error on input `='
01:37:26 <donri> :X
01:37:53 <sipa> > let fibs = fix ((0:) . scanl (+) 1) in fibs 10
01:37:54 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[t2]'
01:38:03 <sipa> > let fibs = fix ((0:) . scanl (+) 1) in fibs
01:38:04 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:38:21 <donri> chrisdone: BTW ghc+cabal+haskell-platform from ubuntu is working fine with hackage packages in 10.10 maverick meerkat
01:39:03 <nimred> ca somebody tell me why am i getting this error message http://pastebin.com/DggTbEZU while compiling http://pastebin.com/CxwCaV0s ?
01:39:30 <pelotom_> > fix ((0:) . scanl (+) 1)
01:39:31 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:39:40 <pelotom_> no need for let :)
01:40:50 <sipa> nimred: there's an error on line 78, but your pasted source file only has 20 lines?
01:41:15 <nimred> sipa line 78 is line 11 on first paste
01:41:21 <donri> > fix $ (0:) . scanl (+) 1
01:41:23 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:41:24 <nimred> sipa line 78 is line 11 on second paste
01:41:26 <nimred> sorry
01:42:00 <sipa> indent the brackets?
01:45:17 <nimred> sipa ok works now o_O
01:45:18 <nimred> thanks
01:45:24 <pelotom_> > unfoldr (\(a,b) -> Just (a,(b,a+b))) (0,1)
01:45:24 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:45:58 <dolio> That's what I'm talkin' about.
01:46:34 <pelotom_> what do I win?
01:46:47 <dolio> Absolutely nothing.
01:46:54 <pelotom_> :'(
01:47:05 <dolio> Or, we could let you drink from the fire hose.
01:48:16 <jamy> how haskell work with graphics, files. Or only from STDIN STDOUT?
01:48:41 <alex404> So I wrote a little function to generate all combinations of a list of numbers, by essentially taking the cartesian product of the list with itself over and over, and then filtering out lists which weren't ordered...
01:49:22 <alex404> When I put the filter outside of the loop, haskell sputters and dies in a frenzy of garbage collection. When I put the filter inside the loop, it does fine. I realize that the later is smarter, but why is the performance difference so extreme?
01:50:32 <pelotom_> what's the function?
01:51:11 <alex404> pelotom_: Just a sec...
01:51:26 <pelotom_> it sounds like you're generating an exponential amount of data and then filtering it
01:51:52 <alex404> I am, it's effectively n^n number of items
01:52:06 <alex404> But when I put the filter inside, it's fine... just a sec...
01:52:06 <pelotom_> um... well then
01:52:34 <jamy> how in haskell take a system time?
01:52:38 <alex404> Hmmm... though I suppose if I'm "only" cutting n by two, that makes a huge difference here
01:54:05 <quicksilver> @hoogle getCurrentTime
01:54:05 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
01:54:05 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
01:54:09 <quicksilver> jamy: ^^
01:55:22 <alex404> pelotom_: http://codepad.org/wwztSgIf
01:55:37 <alex404> pelotom_: If you look at choose and chooseloop
01:55:59 <jamy> @hoogle functors
01:55:59 <lambdabot> No results found
01:56:17 <jamy> @hoogle fmap
01:56:17 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
01:56:18 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
01:56:18 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
01:56:22 <alex404> pelotom_: Originally the filter was outside the loop
01:56:46 <jamy> @hoogle <*>
01:56:46 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
01:57:19 <jamy> @hoogle (++)
01:57:19 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
01:57:20 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
01:57:20 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
01:57:49 <jamy> > fmap (++)
01:57:51 <lambdabot>   Overlapping instances for GHC.Show.Show (f a -> f (a -> a))
01:57:51 <lambdabot>    arising from...
01:58:43 <quicksilver> jamy: if you want to experiment with the bot, it understands private message
01:59:58 <jamy> i want to all see. And can correct me
02:06:13 <nimred> when having such long lines :
02:06:14 <nimred> , ("M-x s",        spawn "urxvtc -title EMMS -title EMMS -g 320x90+0-0 -e sh -c \"emacsclient -nw --eval '(progn (emms-player-mpd-connect) (emms-playlist-mode-go))'\"")
02:06:46 <nimred> wich way to separate it into 2 lines so that it is more readable ?
02:07:07 <jamy> how haskell work with graphics, files. Or only from STDIN STDOUT?
02:07:41 <sipa> jamy: how is a bit too much to explain, but definitely not only stdin/stdout :)
02:08:24 <manateeUser> nimred: I think you at wrong channel, but my answer is use elisp-format.el format your elisp code automatically.
02:08:44 <pelotom_> anything can be done in IO
02:08:57 <sipa> including calling C libraries
02:09:00 <manateeUser> Haha, i use festival read irc message for me. :)
02:09:46 <jamy> ok! how i can take file content to ?
02:11:12 <quicksilver> jamy: there's quite a good introduction to IO in haskell in RWH
02:11:13 <quicksilver> http://book.realworldhaskell.org/read/io.html
02:11:18 <nimred> manateeUser the same for : 
02:11:18 <nimred> , ("M-x w",        spawn "urxvtc -title wifi-select -g 64x32+751+380 -e sh -c \"sudo ifconfig wlan0 up && sudo wifi-select wlan0\"")
02:12:16 <manateeUser> nimred: Download elisp-format.el from EmacsWiki.
02:13:18 <quicksilver> doesn't look like elisp to me.
02:13:34 <quicksilver> ("foo", bar "baz") is not valid elisp syntax. That's haskell.
02:13:45 * sipa thinks it may be xmonad config
02:13:54 <manateeUser> quicksliver: elisp-format.el will format elisp for you. Don't you format line by line.
02:14:02 <quicksilver> manateeUser: that is not elisp.
02:14:27 <quicksilver> nimred: I don't have an attractive way to format long strings (like the argument to 'spawn' there)
02:14:42 <quicksilver> I'd factor it out, I think.
02:14:47 <manateeUser> quicksilver: Oh, nimred's code is XMonad.
02:14:54 <sipa> bingo
02:15:20 <ddarius> If you want to know simply how to split long strings, you could use string gaps.
02:15:25 <manateeUser> nimred: I&#39;m sorry, I thought your code is elisp.
02:15:25 <ddarius> > "foo\      \bar"
02:15:26 <lambdabot>   "foobar"
02:15:39 <quicksilver> urxvtc t g c = concat ["urxvtc -title ",t," -g ",g," -e sh -c \"",c,"\""]
02:15:47 <quicksilver> then you could use
02:16:20 <quicksilver> ("M-x w", spawn (urxvtc "wifi-select" "64x32+751+380" "sudo ifconfig wlan0 up && sudo wifi-select wlan0")
02:16:28 <quicksilver> which is a bit more readable and splits naturally.
02:16:41 <quicksilver> ddarius: I didn't suggest that because I find string-gaps ugly.
02:16:52 <quicksilver> especially when combined with escaped quotes, which use \ in a different way.
02:17:22 <ddarius> > "foo\    " "    \bar"
02:17:23 <lambdabot>   <no location info>:
02:17:23 <lambdabot>      lexical error in string/character literal at chara...
02:17:30 <ddarius> > "foo\    \" \"    \bar"
02:17:31 <lambdabot>   <no location info>: parse error on input `\'
02:18:07 <ddarius> > "foo\    \\"\     \bar"
02:18:08 <lambdabot>   "foo\"bar"
02:18:09 <sipa> > "foo\     \\" \"\     \bar"
02:18:10 <lambdabot>   "foo\" \"bar"
02:18:24 <quicksilver> ddarius: exactly :) Ugly IMO. YMMV.
02:18:35 <ddarius> I've never used string gaps for anything.
02:19:23 <ddarius> I usually break long strings into multiple string and use concat or (++), usually concat.
02:20:06 <ddarius> 'don't have these problems in assembly.
02:20:41 <quicksilver> yes. well. see my suggested solution involving a simple custom function to construct urxvtc commands.
02:20:59 <quicksilver> abstracting common patterns is what programming languages are good at.
02:21:24 <ddarius> The question is, how common is that pattern?
02:21:46 <jamy> this room has anybody of they: Bryan O'Sullivan, Don Stewart, and John Goerzen
02:21:48 <quicksilver> sipa had two examples, possibly he has more in the file.
02:22:06 <quicksilver> jamy: yes, all three, from time to time. THey're not around now though.
02:22:18 <quicksilver> ddarius: anyhow, I think we've flogged that dead horse enough :)
02:22:30 <jamy> niks pleas
02:22:48 <ddarius> Sadistic quicksilver, always wanting to move on to flogging the living horses.
02:25:45 <sipa> quicksilver: i had two examples?
02:26:08 <quicksilver> sipa: sorry, nimred did.
02:26:21 <quicksilver> sipa: you can tell it's a rambling conversation when you forget who the OP was.
02:26:26 <sipa> hehe
02:27:06 <jamy> quicksilver: niks please
02:27:44 <quicksilver> jamy: not really my business to tell you.
02:29:04 <jamy> quicksilver: do you scary?
02:30:56 <nimred> not sure i understand the way you do
02:35:57 <manateeUser> Have any TTS better than festival? I found festival is very *smooth*...
02:36:06 <manateeUser> flite like a robot. :)
02:37:02 <manateeUser> espeak robot too. :)
02:37:16 <jamy> press the button!
02:41:28 <donri> manateeUser: Sounds like Hawking!
02:42:19 <manateeUser> donri: Yes.
02:42:33 <manateeUser> donri: But festival sounds good.
02:42:45 <manateeUser> donri: I install fmale voice. :)
02:42:57 <donri> That's gay.
02:43:24 <donri> If you're a female yourself that is.
02:44:00 <manateeUser> donri: festival much better than flite or espeak. 
02:44:16 <manateeUser> donri: I'm use it read IRC message for me. :)
02:44:43 <donri> I think espeak supports more languages but isn't as good as festival at the ones festival supports.
02:44:54 <manateeUser> donri: yep.
02:59:30 <McManiaC> hey, can anyone help me building ghc? I get:
02:59:36 <McManiaC> Error: ghc-tarballs/LICENSE doesn't exist.
02:59:36 <McManiaC> Maybe you haven't done './darcs-all get'? at boot line 37, <PACKAGES> line 42.
02:59:40 <McManiaC> on "perl boot"
02:59:44 <McManiaC> but I have done darcs-all get
03:03:58 <manateeUser> @preflex seen juhp
03:03:58 <lambdabot> Unknown command, try @list
03:06:22 <MasseR> Does newArray from ffi create a new copy?
03:07:23 <sipa> @hoogle Foreign.Marshal.Array.newArray
03:07:24 <lambdabot> Foreign.Marshal.Array newArray :: Storable a => [a] -> IO (Ptr a)
03:07:24 <lambdabot> Foreign.Marshal.Array newArray0 :: Storable a => a -> [a] -> IO (Ptr a)
03:07:33 <sipa> that one?
03:08:56 <MasseR> Yep
03:09:06 <MasseR> Err wait
03:09:06 <sipa> Write a list of storable elements into a newly allocated, consecutive sequence of storable values (like Foreign.Marshal.Utils.new, but for multiple elements). 
03:09:09 <MasseR> peekArray
03:09:10 <MasseR> :D
03:09:38 <MasseR> I had the haddock window open and newArray was in the center, I meant peekArray
03:21:10 <sinelaw> ooh the new haskell platform page is mighty nice
03:23:01 <MasseR> Finding memory errors from a ffi binding library <3. :'(
03:23:17 <Entroacceptor> sinelaw: reminds me of ubuntu...
03:23:27 <Entroacceptor> I think I liked the blue version better
03:23:54 <Entroacceptor> and it doesn't fit the CI of the other pages
03:25:19 <Entroacceptor> but I guess that's ok, as none of the other pages do ;)=
03:26:32 <Entroacceptor> I count 5.5 different designs
03:27:17 <sinelaw> Entroacceptor, as long as their nice :)
03:27:20 <sinelaw> they're
03:27:25 <ski> preflex: xseen juhp
03:27:26 <preflex>  juhp was last seen on freenode/#ghc 4 days, 3 hours, 7 minutes and 32 seconds ago, saying: or 512M ram is too little
03:27:38 <ski> (.. doh)
03:27:44 <ski> @type let foo :: (forall st. STRef st a -> ST st s) -> a -> (s,a); foo f a = runST (do ref <- newSTRef a; liftM2 (,) (f ref) (readSTRef ref)) in foo
03:27:46 <lambdabot> forall a s. (forall st. STRef st a -> ST st s) -> a -> (s, a)
03:28:03 <ski> @type Data.Array.ST.runSTArray
03:28:04 <lambdabot> forall i e. (Ix i) => (forall s. ST s (GHC.Arr.STArray s i e)) -> Array i e
03:30:31 <Entroacceptor> sinelaw: some of them are...
03:30:41 <MasseR> peekArray returns [4294967299,2,1] when it should return [3,2,1]. I have a little c program that uses the same interface, which works
03:30:55 <sinelaw> any signal processing experts around?
03:30:57 <MasseR> And everything works on a 32 bit machine
03:31:10 <MasseR> Where should I start looking
03:31:37 <ski> > 4294967299 - 2^32
03:31:39 <lambdabot>   3
03:39:34 <MasseR> ski: So.. some location is off?
03:41:46 <ddarius> > -3 :: Word32
03:41:47 <lambdabot>   4294967293
03:42:38 <ddarius> > 0x0000000100000003
03:42:38 <lambdabot>   4294967299
03:43:12 <zygoloid> > 0xfffffffd
03:43:13 <lambdabot>   4294967293
03:43:40 <sipa> sinelaw: asking for experts before asking your questions prevents non-experts who know the answer as well from answering :)
03:44:32 <zygoloid> @remember sipa asking for experts before asking your questions prevents non-experts who know the answer as well from answering
03:44:32 <lambdabot> Okay.
03:44:33 <ddarius> as well as experts
03:45:02 <zygoloid> sipa: you killed sinelaw!
03:45:38 <sipa> oh no, the universe will collapse without the sine law
03:46:00 <ddarius> The sine law doesn't hold in physical geometry.
03:53:08 <MasseR> Oh yeah, is it more likely that it's the library that's faulty, or could 64 bit ffi be faulty? http://hackage.haskell.org/package/HsHyperEstraier
03:59:42 <quicksilver> MasseR: seems unlikely 64 bit ffi is faulty in any substantial way, it's used quite a lot
03:59:52 <MasseR> Thought so
04:00:00 <quicksilver> MasseR: more likely the package has, somewhere, a bug where it assumes int length is 32 bits
04:00:36 <MasseR> That's weird since I was able to pinpoint at least one of the errors, and Int is used
04:00:56 <MasseR> Unless there is somewhere else an error which could affect
04:29:46 <cozachk> yay i finally got leksah to work :D
04:42:51 <jutaro> cozachk: what was the problem(s)?
04:44:38 <cozachk> well for awhile leksah wouldnt build, then i got it to build, ran it once and it stopped working,tried a month or so latter to run it again and it ran...
04:44:45 <MasseR> Hmm.. Are there some other full text search libraries for haskell other than hshyperestraier?
04:44:49 <cozachk> then i had to figure it out ;) 
04:45:04 <cozachk> whats full text search
04:45:46 <MasseR> https://secure.wikimedia.org/wikipedia/en/wiki/Full_text_search
04:46:01 <MasseR> "In text retrieval, full text search refers to a technique for searching a computer-stored document or database."
04:48:28 <`0660> you must be pretty paranoid to use secure wikipedia :)
04:48:54 <MasseR> Nah. duckduckgo !wikipedia :)
04:48:55 <sipa> someone might be trying to build a list of things you look up on wikipedia
04:49:14 <`0660> :P
04:49:15 <ketil> Re: Can GUIs be liberated... would it be possible to build GUIs similar to NDM's CmdArgs?  I.e., declare a data structure, add some hints, and let the system generate a dialog from it?
04:52:11 <ddarius> Sure.
04:52:19 <ddarius> There are systems that work that way.
04:52:27 <Botje> ketil: they're doing it for HTML forms already
04:52:35 <Botje> the switch to real guis shouldn't be much harder
04:52:38 <ddarius> To a degree, Conal's TVs/Eros stuff does something like that.
04:53:12 <ddarius> "Silver Needle in the Skype" is an excellent computer security talk.
04:54:43 <ketil> I looked at TV, perhaps I should take a second look.  Any other things I should look at? 
04:58:29 <luite> is it possible to make an instance for Foldable for unboxed vectors?
05:01:42 <ddarius> ketil: Probably, but I don't know them off-hand.
05:02:03 <ddarius> luite: Try it.
05:02:26 <sipa> :t gfold
05:02:27 <lambdabot> Not in scope: `gfold'
05:02:29 <sipa> :t gfoldr
05:02:30 <lambdabot> Not in scope: `gfoldr'
05:03:02 <benmachine> anything that supports toList can be Foldabled
05:03:03 <luite> ddarius: I already did, the problem is the Unbox a constraint on types that can be in an unboxed vector
05:03:17 <benmachine> oh, true
05:03:43 <benmachine> but Set can be made a Foldable
05:04:03 <ddarius> ketil: http://www.haskell.org/haskellwiki/WxGeneric  and other things in http://hackage.haskell.org/packages/archive/pkg-list.html#cat:gui
05:04:17 <ketil> ddarius, thanks!
05:05:29 <ddarius> luite: You could probably do something with GADTs.
05:07:48 <luite> hmm, ok
05:17:08 <ski> (.. or possibly type families)
05:18:50 <ddarius> :t Data.Set.toAscList
05:18:51 <lambdabot> forall a. S.Set a -> [a]
05:18:57 <ddarius> :t Data.Set.toList
05:18:58 <lambdabot> forall a. S.Set a -> [a]
05:19:24 <ddarius> toAscList should have an Ord constraint...
05:25:27 <quicksilver> ddarius: well, the definition doesn't require one... because the invariant says the data is in a sorted tree
05:25:32 <dom96> What would be the best way to parse JSON-RPC data? I'm not quite sure what to parse it into.
05:25:40 <quicksilver> so all toAscList has to do us unwind it
05:26:00 <quicksilver> dom96: probably an ADT representing the JSON types
05:26:31 <quicksilver> data JSON = Num Double | Str String | Array [JSON] | Dict (Map String JSON)
05:26:32 <ddarius> quicksilver: The Set module guarantees that it will always be implemented as a sorted tree in ascending order?
05:26:33 <quicksilver> something like that.
05:26:46 <quicksilver> ddarius: no; but that is what the source code does
05:26:58 <dom96> hrm
05:26:58 <benmachine> I suppose if the Set implementation changed, it would no longer be able to provide toAscList without Ord
05:27:02 <quicksilver> ddarius: and the signature given are the most general for the code.
05:27:19 <quicksilver> (they're not based on what makes a sensible interface, they're based on the existing implementation)
05:27:20 <ddarius> quicksilver: The whole point of the toAscList function is to keep people from depending on that behavior in toList.
05:27:24 <quicksilver> I'm not defending this.
05:27:28 <quicksilver> I'm just stating it :)
05:27:43 <dom96> quicksilver: would I be able to use Text.JSON.Generic to parse the JSON quickly into that data type?
05:28:22 <quicksilver> dom96: well if you're using the json package, just use their type, surely.
05:28:44 <quicksilver> the json type in that package is much like what I said, except for a few details.
05:29:03 <ddarius> quicksilver: I wasn't saying that :t was wrong and toAscList should have an Ord constraint, I was saying that Data.Set is wrong and toAscList should have an Ord constraint.
05:30:04 <dom96> quicksilver: i can do that, but then if i actually want to use the data, i have to 'unpack' everything into my own data type... is there an easier way?
05:30:52 <benmachine> dom96: just use the data type provided in the parser?
05:32:39 <dom96> benmachine: If i parse a simple "{ "test": "hello" }" I get, (JSObject (JSONObject {fromJSObject = [("test",JSString (JSONString {fromJSString = "hello"}))]}))
05:32:57 <dom96> I can't get the data i want easily from that.
05:33:02 <quicksilver> yes you can.
05:33:11 <quicksilver> you're a programmer, write a program.
05:33:28 <quicksilver> it's not a bad format, it's just the record notation makes it look ugly.
05:33:35 <quicksilver> not a bad data type, I mean.
05:34:02 <dom96> I know how to do it. I just think that it's a very messy way of doing it.
05:34:16 <dom96> People in the past told me to use Text.JSON.Generic
05:34:31 <dom96> which works, but not with ADT's
05:34:41 <dom96> or at least i can't get it work.
05:35:08 <quicksilver> dom96: can you explain why you think that type is messy?
05:35:14 <quicksilver> and how your proposed replacement would be better?
05:35:51 <dom96> I don't have a proposed replacement. I'm just wondering if there is any different way to do this.
05:36:17 <quicksilver> I might need an example / you to reword your question.
05:36:32 <quicksilver> I don't see how any possible way of describing JSON could be substantially different from that given
05:36:51 <quicksilver> there are a few places you might choose different (Double? Rational? Map? List of pairs?)
05:36:57 <quicksilver> but they're not substantative.
05:37:05 <quicksilver> surely any representation of JSON is going to look mostly like that?
05:37:06 <dom96> ok, let's say i want a function which has a type of String -> JSON.
05:37:24 <Vanadium> Well, you could have a parser combinator library that operates in terms of json instead of text, or someting
05:37:32 <Vanadium> and maybe do without the json type yourself
05:37:46 <quicksilver> or you build combinators to act on the parsed type
05:37:48 <quicksilver> "tree parsers"
05:37:51 <dom96> JSON is an ADT with {something :: String, anotherThing :: String } | {somethingElse :: Int}
05:37:52 <quicksilver> often arrow-shaped stuff.
05:39:01 <dom96> I guess there is no way to do this without me manually writing code to change JSValue into JSON
05:39:26 <benmachine> case object of JSObject (JSONObject kvs) -> map (\(k, v) -> (k, fromJSString v)) kvs
05:39:27 <dom96> or at least no easy way.
05:41:27 <dom96> I have wrote a lot of code like that, just so i can parse JSON. It feels very repetitive. That's why i'm asking if there is a better way.
05:41:44 <dom96> *written
05:46:10 <dom96> So is there?
05:46:26 <ski> quicksilver : as in `Arrow' ?
05:56:05 <mightybyte> Anyone know of a regular expression library that makes it easy to get a list of all matches as well as the capture expressions for each match?
05:57:37 <Sadache> is there any function to transform an Either e [a] to [Either e a]
05:57:56 <Sadache> ?
05:58:11 <benmachine> Sadache: what would it turn Left x into?
05:58:45 <Sadache> it will leave it the same
05:58:55 <benmachine> it can't, it needs to make a list
05:59:00 <sipa> Left x is not of type [Either e a]
05:59:07 <Sadache> ok sorry I wrote the wrong type
05:59:49 <sipa> then which is the right type? :)
06:00:31 <Sadache> [Either e [a]] to [Either e a]
06:00:45 <Sadache> so it looks in a way like flattening
06:00:58 <opqdonut> just code it yourself
06:00:59 <Sadache> but without dropping the Error
06:01:17 <opqdonut> you can probably chain some Monad functions, but it probably won't be that readable
06:01:35 <quicksilver> dom96: yes, almost certainly. There is no need to repeat patterns like that, you can abstract them.
06:01:40 <quicksilver> ski: yes, as in Arrow
06:01:43 <Sadache> opqdonut: it just looked general to me
06:01:46 <benmachine> :t either
06:01:47 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
06:01:53 <Sadache> like a flatten but with Either
06:02:06 <Funktorsalat> it looks like distributing Either into [] , followed by join
06:02:13 <opqdonut> yep
06:02:21 <Funktorsalat> dist :: Either e [a] -> [Either e a]
06:02:21 <quicksilver> ski: 'tree-parsers' of the shape a -> Either ParseError [b] or similar.
06:02:34 <benmachine> :t concatMap (either (Left . (:[])) Right)
06:02:36 <lambdabot>     Couldn't match expected type `[b]'
06:02:36 <lambdabot>            against inferred type `Either [a] b1'
06:02:36 <lambdabot>     In the first argument of `concatMap', namely
06:02:41 <dom96> quicksilver: oh, i'll see what i can do about abstracting them then. Thanks.
06:02:42 <Funktorsalat> (not that it existed in the library)
06:03:16 <ddarius> :t either (return . Left) (map (return . Right))
06:03:17 <lambdabot> forall a a1 a2. (Error a) => Either a [a1] -> [Either a (Either a2 a1)]
06:03:21 <sipa> :t concatMap (either (\x -> Left [x]) (map Right))
06:03:22 <lambdabot>     Couldn't match expected type `Either [a] b'
06:03:22 <lambdabot>            against inferred type `[Either a2 a1]'
06:03:22 <lambdabot>     In the second argument of `either', namely `(map Right)'
06:03:25 <quicksilver> dom96: if what you're doing is regular (i.e. your JSON tends to follow certain patterns and styles) you can generally represent that regularity fairly well
06:03:27 <ski> quicksilver : `b' being the children of `a' ?
06:03:36 <quicksilver> dom96: it's a bit difficult to be more precise
06:03:50 <benmachine> :t concatMap (either ((:[]) . Left) (map Right))
06:03:51 <lambdabot> forall a a1. [Either a [a1]] -> [Either a a1]
06:03:53 <dom96> quicksilver: ok
06:03:54 <quicksilver> ski: no, that is a "query" saying "find me one or more values of type 'b' within this 'a'"
06:03:55 <ddarius> :t either (return . Left) (map Right)
06:03:55 <lambdabot> forall a a1. Either a [a1] -> [Either a a1]
06:04:08 <quicksilver> ski: like HXT, if you're familiar with that.
06:04:15 <ski> not really
06:04:36 <quicksilver> ski: it's useful to think of them as arrows because you can sensibly compose them (>>>) and also run them side by side (&&&)
06:04:48 <benmachine> :t (either (return . Left) (liftM Right) =<<) -- woo unnecessary generalisation
06:04:49 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (Either a (m a1)) -> m (Either a a1)
06:05:25 <ddarius> :t (either (return . fail) (liftM return) =<<)
06:05:26 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a1. (Monad m, Monad m1) => m (Either String (m a1)) -> m (m1 a1)
06:05:56 <Sadache> :)
06:06:03 <benmachine> ew, fail :P
06:06:21 <quicksilver> ski: I used this for transform an parsed ADT which is not very different from dom96's problem
06:06:36 <Funktorsalat> @type ( (return . fail ||| liftM return) =<< )
06:06:37 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a1. (Monad m, Monad m1) => m (Either String (m a1)) -> m (m1 a1)
06:06:48 <Funktorsalat> aw
06:07:00 <benmachine> return . fail is differently general from return . Left
06:07:14 <benmachine> the output can be any monad but the input has to be String
06:07:25 <benmachine> and it doesn't produce what you'd expect if the output is Either
06:07:46 <benmachine> because fail doesn't have a sensible implementation in the Either monad
06:08:20 <benmachine> well, the (Either e) monad rather
06:08:22 <Funktorsalat> hmm, true
06:08:24 <benmachine> unless you constrain e
06:08:37 <benmachine> even then it's iffy :P
06:08:49 <Funktorsalat> it is constrained in the lib instance though
06:08:54 <Funktorsalat> (Error e)
06:09:00 <benmachine> I think that actually got changed
06:09:07 <Funktorsalat> oh
06:09:07 <benmachine> recent versions of mtl don't do that anymore
06:10:51 * benmachine tries to work out what transformers does nowadays
06:11:25 <sipa> @imdb transformers
06:11:25 <lambdabot>  transformers
06:11:30 <sipa> ...
06:11:41 <Funktorsalat> hmm mtl is one of the package you're not supposed to upgrade, isn't it
06:11:43 <benmachine> I have no idea what it thought @imdb was
06:11:49 <Funktorsalat> +s
06:11:57 <benmachine> Funktorsalat: I don't think it's a ghc boot package
06:11:57 <sipa> benmachine: neither do i
06:12:05 <benmachine> it comes with the platform
06:13:08 <ski> quicksilver : so with `Foo a b = a -> Either ParseError [b]', `Foo' is the arrow ?
06:17:53 <akhirsch> \msg lambdabot >map (+ 2) [1,2,3,4,5,6]
06:18:10 <benmachine> best module names of the day: http://hackage.haskell.org/package/polyseq-0.1.2.1
06:18:31 <benmachine> Language.Haskell.FreeTheorems.Variations.PolySeq.TheoremGen
06:18:40 <djahandarie> lol -_-
06:18:46 <sipa> akhirsch: it's /msg, not \msg
06:18:54 <akhirsch> yeah, thanks
06:18:55 <benmachine> or better, Language.Haskell.FreeTheorems.Variations.PolySeq.Parser.ParseTerm
06:21:23 <Jafet> > (+2) <$> [1..6]
06:21:24 <lambdabot>   [3,4,5,6,7,8]
06:27:54 <Blkt> good day everyone
06:28:14 <alej> morgen
06:28:30 <quicksilver> ski: (sorry, I'm a bit busy today) Yes, exactly.
06:29:07 <quicksilver> ski: sometimes b is a direct substructure of a
06:29:25 <quicksilver> tag "IMG" :: Foo HTML HTML -- find all IMG tags in the input data
06:29:32 <quicksilver> sometimes it's a computed result
06:29:45 <quicksilver> imgfilenames :: Foo HTML String
06:30:00 <quicksilver> numofimages :: Foo HTML Int (etc etc)
06:31:14 <benmachine> would numofimages return a singleton list?
06:31:54 <benmachine> (more generally, why is b necessary in a list?)
06:32:21 <quicksilver> benmachine: that's a bit of a wart.
06:32:31 <benmachine> *necessarily
06:32:44 <quicksilver> it's useful to allow lists in general because quite often queries do want multiple results
06:32:52 <quicksilver> but other times it's useful to restrict to single results
06:33:12 <benmachine> and it's not necesarily useful to have say Foo HTML [HTML] because it doesn't compose so nicely?
06:33:21 <ski> quicksilver : ok .. so this feels a bit like a non-deterministic (and also possibly exceptioning) functional reference of `b's inside an `a'
06:33:21 <quicksilver> so you end up with two types, Foo1 a b :: a -> Either ParseError b and FooL a b = Foo1 a [b]
06:33:30 <benmachine> can't you just use kleisli arrows with monad transformers?
06:33:53 <quicksilver> ski: well except I don't permit update
06:33:56 <ski> right
06:33:57 <quicksilver> but you could
06:34:03 <quicksilver> (and that would be something else, but also useful)
06:34:03 <ski> .. in some cases, at least
06:34:11 <quicksilver> benmachine: that's what they are
06:34:18 <quicksilver> modulo ListT not being what you think it is
06:34:26 <quicksilver> and module Kleisli unwrapping being really annoying.
06:34:36 <ski> (updating `cardImages' doesn't seem that sensible)
06:34:37 <benmachine> I guess it's the latter point I was thinking of
06:34:44 <quicksilver> benmachine: but, you end up with two sets of combinators
06:34:57 <quicksilver> benmachine: one which auto-unwraps an inner list, FooL styleee
06:35:01 <quicksilver> and one which doesn't assume a list.
06:35:06 <quicksilver> that's the wart :(
06:35:11 <benmachine> right
06:35:16 <quicksilver> I never really fixed that part. I just duplicated the combinators I needed.
06:35:21 <benmachine> heh ok
06:35:27 <quicksilver> and then finished the project and moved on.
06:36:08 <malorie> is there a "best-practice" identifier for `list' in `list@(x:xs)'?
06:36:11 <benmachine> if you run two parsers with &&&, does it run them on the same input or consecutively? if you did a similar thing with the Kleisli arrow for a monadic parser would you get the same answer?
06:36:25 <ski> malorie : i often say `xs0@(x:xs)'
06:36:35 <benmachine> I often do xs@(y:ys)
06:36:38 <benmachine> or l@
06:36:41 <benmachine> but I do stupid names
06:36:44 <benmachine> so don't listen to me.
06:36:48 <malorie> :)
06:37:02 <ski> for trees : `t@(Node l a r)'
06:37:13 <benmachine> it can depend on how it's being used I guess
06:37:25 <malorie> sadly capital names aren't allowed in this context. otherwise I'd do X@(x:xs)
06:38:02 <quicksilver> benmachine: it doesn't really run them in parallel
06:38:25 <quicksilver> benmachine: it just runs them one after another and duplicates the work
06:38:47 <quicksilver> you'd need to turn the whole thing into clever deep embedding if you wanted to fuse the traverses
06:38:57 <quicksilver> sounds clever but I haven't thought it about it.
06:40:19 <ski> @src (&&&)
06:40:20 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
06:40:22 <ski> @src (***)
06:40:22 <lambdabot> f *** g = first f >>> second g
06:40:46 <ski> @src Arrow
06:40:47 <lambdabot> class Arrow a where
06:40:47 <lambdabot>     arr, pure   :: (b -> c) -> a b c
06:40:47 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
06:40:48 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
06:40:50 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
06:40:52 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
06:40:54 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
06:40:58 <ski> .. i guess you could provide alternative definitions
06:42:52 <pr> so what is the #haskell folks doing on sunday, to honor binary day? data.binary hackathon?
06:44:02 <aristid> ski: that @src is wrong
06:44:11 <aristid> (>>>) is in Category
06:44:25 * ski is pondering how to sensibly cascade changes in binary options ..
06:44:47 <ski> (.. with implicational constraints, i.e.)
06:45:00 <sipa> pr: binary day?
06:45:05 <pr> sipa: 10/10/10
06:45:10 <sipa> haha, right
06:45:19 * ski thought `(>>>)' was both in `Arrow' and in `Category' .. they removed it from the former ?
06:45:36 <aristid> ski: yes. and Category a => Arrow a is added
06:45:39 <ski> > 10/10/10
06:45:40 <lambdabot>   0.1
06:45:51 * ski nods sagely
06:46:00 <ski> aristid : ah, nice
06:46:23 <EvanR-work> seems like binary day happens more than once a year
06:46:47 <aristid> :t let arrCurry arr a b = a <<< (a &&& b) in arrCurry
06:46:48 <lambdabot> forall t (cat :: * -> * -> *) c c'. (Arrow cat) => t -> cat (c, c') c -> cat (c, c') c' -> cat (c, c') c
06:46:48 <sipa> EvanR-work: ?
06:46:55 <EvanR-work> er, at least this year and next
06:47:00 <sipa> ah, yes
06:47:00 <aristid> :t let arrCurry arr a b = arr <<< (a &&& b) in arrCurry
06:47:01 <lambdabot> forall (cat :: * -> * -> *) c c' c1 a. (Arrow cat) => cat (c, c') c1 -> cat a c -> cat a c' -> cat a c1
06:47:50 <sipa> but on average, i'd say 4*3*3 times per century :)
06:48:27 <pr> so it's actually a more special day than sth. like a birthday
06:48:43 <pr> which happens on average 100 times per century
06:48:43 <pr> !
06:48:53 <sipa> which is actually remarkably close to once in a blue moon
06:49:12 <pr> well, that's actually not true for all birthdays
06:50:13 <sipa> binary day has an (average) frequency of 1.1407955e-08 Hz, once in a blue moon is 1.16699e-08 Hz
06:50:45 <aristid> hmm, i wonder if a class for curried arrows would be possible :D
06:51:57 <EvanR-work> pi day is stupid
06:52:03 <FeiRuoWa> class! bye!
06:52:26 <EvanR-work> the rendering of decimal pi in gregorian calendar makes almost no sense
06:52:37 <pr> project for sunday: make a clone of cal which adds support for both blue and double blue moons
06:52:40 <sipa> neither does the gregorian calender whatsoever make sense :)
06:52:48 <pr> + blog about it
06:52:48 <pr> !
06:52:59 * EvanR-work note to self: blog about it
06:53:05 <zygoloid> binary day is stupid too. it's really decimal day.
06:53:06 <EvanR-work> what has the world come to
06:53:22 <silasdavis> what does the single exclamation mark do in haskell?
06:53:24 * ski notes : don't blog about it
06:53:37 <silasdavis> I thought it was the index operator, but that seems to be !!
06:53:46 <EvanR-work> array index
06:53:51 <ski> silasdavis : delimits character literals .. and it is a valid non-initial character in identifiers
06:54:02 <zygoloid> silasdavis: it does whatever you define it to do. in the standard library it is used for array indexing
06:54:02 <ski> > let c' = 'c' in c'
06:54:03 <lambdabot>   'c'
06:54:05 <pr> decimal day is not as closely related to blue moons as binary day is. therefore decimal day is stupid
06:54:57 <ski> er .. (misinterpreted "exclamation" as "apostrophe" .. somehow)
06:55:06 <silasdavis> what do I need to load to use the standard definition?
06:55:16 <zygoloid> @index (!)
06:55:17 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.Map, Data.Array, Text.Html
06:55:28 <zygoloid> ^^ one of those, depending on which one you want
06:55:45 <EvanR-work> i was actually getting excited to be able to use ! in an identifier
06:56:28 <zygoloid> > let excited! a = a * a in excited! 42
06:56:29 <lambdabot>   1764
06:56:30 <aristid> EvanR-work: of course you can use (!), it will just conflict with Data.Array.
06:56:43 <silasdavis> so what is ! for? [1,2,3,4]!!1 seems to work in prelude
06:56:45 <nh910> hi! how come that 2 ^ 2 ^ 2 works fine and True == True == True does not?
06:56:55 <aristid> silasdavis: ! is for arrays
06:57:01 <sipa> let's celebrate every multiple of 2**64 Cs133-transitions since unix epoch
06:57:01 <aristid> silasdavis: !! is fo rlists
06:57:07 <sipa> that approximately every 4 years
06:57:14 <aristid> sipa: yay 64-bit
06:57:19 <zygoloid> nh910: because ^ is infixr and == is infix
06:57:31 <EvanR-work> aristid: dangerous!
06:57:35 <sipa> ow, it's every 64 years
06:57:35 <EvanR-work> identifier
06:57:41 <sipa> hmmm!
06:57:43 <zygoloid> nh910: (there's a standard and specified way of associating (^) but not for (==))
06:57:47 <aristid> EvanR-work: dangerous! is a valid identifier too
06:57:50 <EvanR-work> wow
06:58:04 <EvanR-work> so ! is like ' except can be initial
06:58:08 <aristid> > let dangerous! = "EvanR" in dangerous!
06:58:09 <lambdabot>   <no location info>: parse error on input `='
06:58:10 <zygoloid> EvanR-work: no, you're being lied to
06:58:14 <EvanR-work> oh
06:58:27 <zygoloid> sorry ;)
06:58:33 <silasdavis> are haskell lists linked lists?
06:58:39 <EvanR-work> @src []
06:58:39 <lambdabot> data [] a = [] | a : [a]
06:58:40 <zygoloid> silasdavis: yes, they're singly-linked lists
06:58:46 <opqdonut> > let (dangerous!) = "EvanR" in (dangerous!)
06:58:47 <lambdabot>   <no location info>: Parse error in pattern
06:59:00 <opqdonut> > let (!) dangerous = "EvanR" in (dangerous!)
06:59:01 <aristid> why did excited! work for zygoloid, but dangerous! not for me?
06:59:01 <lambdabot>   Not in scope: `dangerous'
06:59:10 <opqdonut> oh, nevermind
06:59:27 <EvanR-work> operator characters cant be mixed with normal characters in identifiers
06:59:33 <aristid> > let excited! a = a * a in excited! 42
06:59:34 <lambdabot>   1764
06:59:35 <aristid> ooh
06:59:37 <aristid> haha
06:59:41 <benmachine> > excited
06:59:42 <lambdabot>   *Exception: Prelude.undefined
06:59:45 <benmachine> <_<
06:59:54 <benmachine> dastardly
07:00:14 <opqdonut> ah
07:00:17 <opqdonut> yes
07:00:26 <nh910> zygoloid: thanks. so if I just use infix instead of r/l, I cannot chain the operators like that?
07:00:40 <ski> > (2^) `iterate` 0
07:00:41 <lambdabot>   [0,1,2,4,16,65536,200352993040684646497907235156025575044782547556975141926...
07:01:00 <benmachine> nh910: right. it's there because it's pretty rare than you'd want to chain ==
07:01:09 <benmachine> nh910: so it's sort of assumed that you made a mistake
07:01:13 <benmachine> if you try
07:01:19 <benmachine> same with <
07:01:42 <benmachine> if you write 4 < x < 8, you might intend x `elem` [5 .. 7], but that's not what it means
07:01:49 <aristid> hmm if (<) was defined in evil ways, 4 < x < 8 might work
07:01:49 <benmachine> so that construct is just disallowed
07:02:13 <benmachine> aristid: hmm, good luck with that
07:02:31 <aristid> benmachine: no that would feel just TOO evil
07:02:37 <aristid> even dangerous!
07:03:28 <nh910> benmachine, zygoloid: yeah, its just for exercise. another thing: the manual says "See §4.4.2 for a detailed definition of the associativity rules." in http://www.haskell.org/tutorial/functions.html but that leads to "Modules" (http://www.haskell.org/onlinereport/modules.html#fixity). Is the link wrong? how can I find out more about associativity?
07:03:29 <ski> aristid : apparently you can't define `(x !#%&/=?) = ..x..' while you can define `(!#%&/=?) x = ..x..' (don't ask me why)
07:04:31 <aristid> ski: maybe nobody thought that adding operator sections to definitions would be necessary
07:05:04 <benmachine> nh910: looks like the link is wrong, try http://www.haskell.org/onlinereport/decls.html#fixity
07:05:25 <ski> aristid : sometimes i also want `(x +++++ y) = ..x..y..' (to be able to indent the initial `x' more)
07:07:01 <aristid> ski: you can add a space
07:07:13 <opqdonut> not without destroying layout
07:07:19 <nh910> benmachine: thanks
07:07:28 <opqdonut> (in some cases)
07:07:36 <aristid> opqdonut: why does he want it then if it destroys layout? *confused*
07:08:21 <opqdonut> aristid: to be able to indent, say "Goob x ++++++ y = ...; x ++++++ Froob y = ....;" nicely
07:08:25 <opqdonut> for some value of nice
07:08:53 <alej> i like your metasyntactic variables
07:09:57 <Kirk> is haskell any good?
07:09:57 <opqdonut> oh, ski only used 5 +s in his original example
07:11:04 <Vanadium> Kirk: It is fascinating.
07:12:09 <Kirk> just looking at site now, is it high or low level?
07:12:38 <Vanadium> Yeah.
07:12:49 <Vanadium> It is pretty high level compared to, say, C
07:13:03 <EvanR-work> Kirk: no haskell sucks
07:13:15 <Vanadium> but it is a bit crazy in that it requires you to do some mental backflips that are not necessary in C~
07:13:29 <sipa> this channel is actually meant for people who need someone to complain to about it
07:15:22 <aristid> > 
07:15:23 <lambdabot>   not an expression: `'
07:16:31 <Kirk> are there any well know app developed in haskell?
07:16:52 <EvanR-work> no
07:16:53 <Jonno_FTW> Kirk: darcs?
07:16:56 <sipa> yes, ghc
07:16:59 <donri> GHC, xMonad, darcs
07:17:00 <sipa> ;)
07:17:00 <benmachine> Kirk: not hugely super-popular, but xmonad and darcs both have their own wikipedia pages
07:17:02 <EvanR-work> ah right ghc
07:17:03 <Vanadium> Most of them are haskell apps. Unfortunately.
07:17:04 <Jonno_FTW> hpaste
07:17:05 <EvanR-work> forgot about that one
07:17:16 <Kirk> darcs i know, code management app yeah?
07:17:26 <Jonno_FTW> yep
07:17:28 <benmachine> more or less
07:17:48 <donri> Google wave prototyped the collaborative algorithms in Haskell.
07:18:05 <nh910> why do -3.0 or -3 not match Float?
07:18:15 <Jonno_FTW> :t -3.0
07:18:15 <lambdabot> forall a. (Fractional a) => a
07:18:15 <ski> > -3 :: Float
07:18:16 <lambdabot>   -3.0
07:18:20 <ski> > -3.0 :: Float
07:18:21 <lambdabot>   -3.0
07:18:27 <benmachine> nh910: elaborate, but at a guess I'd say try (-3)
07:18:29 <ski> > -3.0 :: Rational
07:18:30 <lambdabot>   (-3) % 1
07:18:36 <ski> > 2.5 :: Rational
07:18:38 <lambdabot>   5 % 2
07:18:40 <benmachine> nh910: note that comparing floating-point numbers for equality tends to be iffy :)
07:18:40 <sipa> Kirk: i'd call being able to write the (infinite) fibonacci list as this rather high level:
07:18:48 <sipa> > fix $ (0:) . scanl (+) 1
07:18:49 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:19:45 <donri> Haskell is *very* high level, in that it doesn't really mimic the processor architecture *at all*.
07:20:07 <fasta> benmachine, and who created those Wikipedia pages?
07:20:09 <aristid> but it still is pretty fast (if you use GHC)
07:20:19 <Starfire> donri: Except if you're using a Reduceron processor!
07:20:20 <benmachine> fasta: I dunno, they're pretty decent though
07:20:37 <fasta> benmachine, I mean that it could not be be notable.
07:20:44 <fasta> not be*
07:21:09 <benmachine> fasta: yeah, and then again it could be; it's not easy to substantiate that judgement quickly
07:21:24 <fasta> benmachine, I agree completely, btw. 
07:21:53 <EvanR-work> reducerons vs lambdabots
07:22:02 <fasta> benmachine, (that it is hard to decide, but there was a similar issue with awesomewm or whatever it was called)
07:22:09 <donri> I don't think I've ever seen darcs use by a non-Haskell project. Not saying there is none.
07:22:24 <donri> Neither have I actively looked for one.
07:22:53 <sipa> the server for a Worms-clone called hedgewars is written in Haskell
07:22:59 <donri> I'm quite sure GHC isn't used much for non-Haskell projects, though. ;)
07:23:06 <nh910> Jonno_FTW, ski, benmachine: I still don't get it. -3.0 matches float if it is alone, but not if I use it in a function
07:23:18 <sipa> nh910: elaborate
07:23:21 <Jonno_FTW> nh910: what are you trying to do?
07:23:42 <ski> (donri : fwiw, Riastradh provides access to his (mostly Scheme-)projects via darcs)
07:23:46 <nh910> Jonno_FTW: just trying to find out the reason
07:23:48 <Jonno_FTW> > (-3.0) + 5
07:23:49 <lambdabot>   2.0
07:23:57 <ski> nh910 : which function ?
07:24:07 <Twey> Oh, really?  Cool.  I know Hedgewars, but I didn't know it used Haskell.
07:24:19 <nh910> Jonno_FTW: yeah, I know what to do to make it work, but not why it doesn't work without
07:24:34 <donri> Which would you say is more used within the Haskell community, darcs or Git?
07:24:36 <ski> nh910 : what is the actual code snippet that doesn't work as you thought it would work ?
07:24:43 <Jonno_FTW> i'm probably not the right person to ask
07:24:45 <nh910> ski: test :: Float -> Float. I cannot call it with test -3
07:24:46 <ski> nh910 : feel free to paste it, if it is largish
07:24:57 <ski> nh910 : try `test (-3)'
07:25:01 <benmachine> nh910: test -3 parses as test - 3, as if test was a number
07:25:04 <EvanR-work> paste it *somewhere else*
07:25:10 <benmachine> *were a number >_>
07:25:11 <Jonno_FTW> @hpaste
07:25:11 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:25:21 <ski> nh910 : `test -3' means : "subtract three from the number `test'" (which is not sensible, here)
07:25:22 <quicksilver> nh910: the minus sign is a bit of a wart on the language :(
07:25:32 <Jonno_FTW> someone should probably fix that link up
07:25:35 <quicksilver> nh910: when you want negative numbers it is, unfortunately, safest to put them in ()
07:25:39 <ski> @paste
07:25:40 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:25:43 <ski> @where paste
07:25:44 <lambdabot> http://hpaste.org/ http://codepad.org/
07:25:44 <aristid> @where hpaste
07:25:44 <lambdabot> http://hpaste.org/
07:25:54 <aristid> just remove the stupid @hpaste and @paste commands :P
07:27:49 <nh910> ski, quicksilver: you mean it is because haskell tries to apply the binary `-` function instead of the unary one in this case?
07:28:09 <quicksilver> nh910: yes.
07:28:17 <quicksilver> nh910: unary - is a mess.
07:28:25 <sipa> nh910: test -3    ==     test-3      == test - 3
07:28:39 <sipa> == (-) test 3
07:28:46 <sipa> instead of test (-3)
07:28:56 <ski> > even (-3)
07:28:56 <EvanR-work> @src neg
07:28:56 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:28:57 <lambdabot>   False
07:29:00 <ski> > even -3
07:29:01 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
07:29:01 <lambdabot>    arising from the literal `3'...
07:29:08 <sipa> > even (-3)
07:29:09 <ski> @src negate
07:29:09 <lambdabot> negate x = 0 - x
07:29:09 <lambdabot>   False
07:29:20 <EvanR-work> > negate 3
07:29:20 <lambdabot>   -3
07:29:31 <ski> > subtract 2 7
07:29:32 <lambdabot>   5
07:29:41 <EvanR-work> there
07:29:43 <EvanR-work> use those ;)
07:29:51 <EvanR-work> no more '2' + 2 js php crap
07:30:08 <ski> > subtract 2 `map` [5,6,7,8]
07:30:09 <lambdabot>   [3,4,5,6]
07:30:17 <nh910> quicksilver, sipa, ski: aaah, I got it (@quicksilver: I didn't complain about it, I think I'd implement it just like that ;) )
07:30:44 <aristid> > subtract 2 . [5,6,7,8]
07:30:46 <lambdabot>   [3,4,5,6]
07:31:25 <Jonno_FTW> @src subtract
07:31:25 <lambdabot> subtract x y = y - x
07:31:46 <Jonno_FTW> why is there such a trivial function in the prelude??
07:31:49 * ski wonders sadly which IRC clients expands a nick `foo' like `@foo:'
07:31:54 <McManiaC> > (2 -) . [5,6,7,8]
07:31:55 <lambdabot>   [-3,-4,-5,-6]
07:31:57 <EvanR-work> > let x = -3 in x
07:31:58 <lambdabot>   -3
07:32:00 <EvanR-work> > let x = - 3 in x
07:32:01 <lambdabot>   -3
07:32:02 <McManiaC> ok... :>
07:32:04 <aristid> > runIdentity $ subtract 2 . Identity 4
07:32:05 <lambdabot>   2
07:32:10 <wjt> ski: any client driven by a heavy twitter user? ;-)
07:32:11 <lambdabot> wjt: You have 1 new message. '/msg lambdabot @messages' to read it.
07:32:33 <ski> Jonno_FTW : mostly because `frob (- 2)' is not passing a section of `(-)' to `frob'
07:32:50 <aristid> Jonno_FTW: subtract is necessary because there are no right-hand operator sections for (-)
07:33:00 <ski> @type (4 -)
07:33:01 <lambdabot> forall t. (Num t) => t -> t
07:33:03 <ski> @type (- 4)
07:33:04 <lambdabot> forall a. (Num a) => a
07:33:14 <aristid> hmm haskell should have used another symbol for negation
07:33:17 <McManiaC> > (+ -2) . [5,6,7,8]
07:33:18 <lambdabot>   The operator `GHC.Num.+' [infixl 6] of a section
07:33:19 <lambdabot>      must have lower prece...
07:33:20 <McManiaC> :D
07:33:25 <ski> yeah .. SML and OCaml does this, iirc
07:33:31 <ski> (at least one of them does)
07:33:49 <aristid> ocaml also uses different symbols for floating point and integer arithmetic :D
07:33:52 <sipa> > (+ . -2) . [6,54,7]
07:33:53 <lambdabot>   <no location info>: parse error on input `.'
07:34:15 <aristid> > (( $ -2)
07:34:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:34:17 <aristid> argh
07:34:24 <aristid> whatever, stupid enter key :P
07:34:31 <ddarius> The problem is the MLs use ~ which Haskell already uses.  J uses _ but that won't work in Haskell either.
07:34:35 <t3eblinder> how often you need a partial function like (\x -> x - 4) :o get a new sign for negation which feels not natural is to much 
07:34:57 <McManiaC> @pl \x -> x - 4
07:34:58 <lambdabot> subtract 4
07:35:02 <McManiaC> :D
07:35:28 <ddarius> I personally think the Haskell designers chose one of the better solutions to this particular problem.
07:37:08 * ski idly wonders why `/ x' doesn't mean `recip x' (i.e. `1 / x')
07:37:21 <sipa> :t (/)
07:37:22 <lambdabot> forall a. (Fractional a) => a -> a -> a
07:37:32 <sipa> :t div
07:37:33 <lambdabot> forall a. (Integral a) => a -> a -> a
07:37:42 <ddarius> ski: The equivalent does in J.
07:37:51 <ski> ok
07:38:24 <ddarius> http://www.jsoftware.com/help/dictionary/d130.htm
07:40:28 <Twey> :t recip
07:40:29 <lambdabot> forall a. (Fractional a) => a -> a
07:40:33 <Twey> Huh.  That exists.
07:40:41 <Twey> @src recip
07:40:41 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:42:31 <ddarius> It's a method in Fractional
07:42:38 <nh910> is it possible to put hugs into some kind of 'verbose' mode? so that the error messages look like "Expression : (-) (test 3)" instead of "Expression : test - 3"?
07:42:50 <ddarius> nh910: Use GHC(i) instead.
07:43:05 <nh910> ddarius: ok
07:44:54 <Twey> ddarius: Ah
07:45:03 <Twey> ddarius: Is the reciprocal not always equal to 1 / n?
07:45:14 <benmachine> pretty sure it has a default implementation
07:45:17 <ski> it should be
07:45:26 <benmachine> I think in some contexts you can get a faster recip more directly perhaps?
07:45:32 <benmachine> like n ** -1 or something
07:45:34 <quicksilver> I'm sure that's the justification, yes.
07:46:23 <Twey> Ah, okay.
07:47:16 <ddarius> Of course, there's m / n = m * recip n too.
07:47:26 <quicksilver> recursive default methods
07:47:45 <quicksilver> so sensible seeming, until they give you a non-terminating program which you spend half a day tracking down
07:47:58 <quicksilver> then you want to put the entire haskell committee on a bonfire and dance around it chanting.
07:48:11 <ddarius> quicksilver: If you read the documentation, that should not ever be a problem.
07:49:06 <quicksilver> :P
07:50:52 <benmachine> I always thought they were a bit unpleasant
07:51:05 <benmachine> haskell is usually quite keen to catch your mistakes at compile time
07:51:19 <imc> is there an "andM" function? i.e. m [Bool] -> m Bool
07:51:27 <benmachine> then in this rather alarmingly large area it fails in the most irritating way possible >_>
07:51:38 <benmachine> imc: do you require that the monadic effects are short-circuited?
07:51:44 <ski> imc : `liftM and'
07:51:50 <imc> ski: thanks
07:51:52 <ski> benmachine : impossible, with that type
07:51:55 <imc> benmachine: not really
07:52:09 <benmachine> ski: oh right, yes
07:52:12 <benmachine> silly me
07:52:15 <ski> (imc : assuming `m' is a monad)
07:52:20 <imc> ski: of course
07:52:43 <imc> ski: don't know exactly what monad but it will be one :P
07:52:49 <ski> (if `m' is a functor (or applicative functor), then `fmap' instead of `liftM' ..)
08:09:55 <Jonno_FTW> @src (^)
08:09:56 <lambdabot> x ^ 0            =  1
08:09:56 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
08:09:56 <lambdabot>   where f _ 0 y = y
08:09:56 <lambdabot>         f x n y = g x n
08:09:56 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
08:09:57 <lambdabot>                       | otherwise = f x (n-1) (x*y)
08:10:00 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
08:11:40 <Jonno_FTW> why is that implementation of (^) correct?
08:12:05 <pumpkin> http://en.wikipedia.org/wiki/Exponentiation_by_squaring
08:12:26 <monochrom> you can prove by induction
08:12:47 <Jonno_FTW> is there a better proof?
08:13:21 <monochrom> but the key is x^(2*n) = (x^n)^2 = (x^2)^n
08:14:00 <monochrom> ISTR everyone accepted that when in school
08:14:56 <Jonno_FTW> ISTR?
08:15:04 <fasta> I Seem To Recall
08:15:13 * hackagebot fibon 0.1.0 - A reworking of the classic nofib benchmark suite  http://hackage.haskell.org/package/fibon-0.1.0 (DavidPeixotto)
08:17:14 * hackagebot dataenc 0.13.0.4 - Data encoding library  http://hackage.haskell.org/package/dataenc-0.13.0.4 (MagnusTherning)
08:22:57 <ski> `x^(2*n) = (x^n)^2' is currying ..
08:23:22 <pumpkin> nice!
08:23:28 <ski> @djinn ((Bool,n) -> x) -> (Bool -> n -> x)
08:23:29 <lambdabot> f a b c = a (b, c)
08:23:36 <ski> @djinn (Bool -> n -> x) -> ((Bool,n) -> x)
08:23:36 <lambdabot> f a (b, c) =
08:23:37 <lambdabot>     case b of
08:23:37 <lambdabot>     False -> a True c
08:23:37 <lambdabot>     True -> a False c
08:23:47 <ski> (and the composition of those, in either direction, is `id')
08:23:52 <pumpkin> :t curry :: ((Bool,n) -> x) -> (Bool -> n -> x)
08:23:53 <lambdabot> forall n x. ((Bool, n) -> x) -> Bool -> n -> x
08:23:57 <pumpkin> omnomnom
08:24:23 <zygoloid> Jonno_FTW: imagine an n x m grid of x's, all multiplied together. that's x^(n*m). now consider each row to be a unit. that's (x^n)^m. now consider each column to be a unit. that's (x^m)^n. since multiplication is associative, all of those must be equal.
08:24:45 <ski> er .. well, if you replace the `True' with `False', in the `False' branch, and mutatis mutandis for the other branch :)
08:24:58 <benmachine> djinn randomly decided you wanted your Bools the other way arounf
08:25:06 <benmachine> @djinn Either a a -> Either a a
08:25:06 <lambdabot> f a = a
08:25:07 <ski> @slap djinn for needlessly permuting `Bool'
08:25:07 * lambdabot decomposes djinn for needlessly permuting `Bool' into several parts using the Banach-Tarski theorem and reassembles them to get two copies of djinn for needlessly permuting `Bool'!
08:25:13 <benmachine> @djinn Bool -> Bool
08:25:14 <lambdabot> f a = a
08:25:15 * benmachine hmms
08:25:26 <benmachine> @djinn (Bool, a) -> (Bool, a)
08:25:26 <lambdabot> f a = a
08:25:31 <benmachine> hmph
08:25:38 <ski> @djinn Bool -> (Bool -> o) -> o
08:25:38 <lambdabot> f a b =
08:25:38 <lambdabot>     case a of
08:25:38 <lambdabot>     False -> b False
08:25:38 <lambdabot>     True -> b True
08:25:41 <benmachine> @djinn (Bool, a) -> (a, Bool)
08:25:42 <lambdabot> f (a, b) =
08:25:42 <lambdabot>     case a of
08:25:42 <lambdabot>     False -> (b, False)
08:25:44 <lambdabot>     True -> (b, True)
08:25:53 * benmachine shrugs
08:26:31 <benmachine> odd that it feels it is necessary to match here
08:26:53 <benmachine> maybe there should be a less deterministic, more heuristic djinn-like
08:28:12 <zygoloid> so (x^n)^m == x^(n*m) because the real numbers form a cartesian closed category? ;-)
08:29:07 <benmachine> eek
08:29:12 <ski> zygoloid : what are the morphisms (other than isomorphisms) ?
08:29:45 <ski> (or maybe every morphisms is iso : so a groupoid ?)
08:30:11 <pumpkin> the ordering
08:30:33 <pumpkin> does that work?
08:30:34 <pumpkin> hmm
08:31:02 <pumpkin> oh I guess not
08:31:15 <pumpkin> as there's no terminal object
08:32:02 <ski> would it work to consider it a discrete category ?
08:32:07 <zygoloid> working with the naturals instead of the reals, we can consider the arrows to be functions between sets with those naturals as cardinalities
08:32:30 <ski> hm, no, we need projections `m * n >-> m', &c.
08:32:52 <zygoloid> so it's saying that there are as many functions from m to n to x as there are from (n,m) to x
08:34:09 <Vanadium> I already regret bringing it up. I am going to wait for the category-theory-for-c-programmers book.
08:36:07 <monochrom> Godawful category theory
08:37:31 <Cale> Vanadium: What did you bring up?
08:37:56 <Vanadium> Sorry, that actually went into the wrong window and I did not notice.
08:38:09 <Vanadium> I am not very good with IRC today.
08:38:42 <Cale> Vanadium: If you want a book to study category theory from, I recommend Awodey's book
08:38:57 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf
08:39:23 <benmachine> 3.9 MB at 3.9 KB/sec
08:39:23 <benmachine> neat
08:39:35 <benmachine> (sry for eating your bandwidths)
08:39:47 <Cale> That's rather slow
08:39:56 <benmachine> it's down to 1.7 now
08:40:08 <Cale> I usually get ~150KB/s upload.
08:40:15 <benmachine> maybe 100 people want it at once :P
08:40:55 <benmachine> is it free somewhere?
08:41:18 <malorie> > map (-1) [1..5]
08:41:19 <lambdabot>   [-1,-1,-1,-1,-1]
08:41:25 <benmachine> lols
08:41:29 <malorie> wtf
08:41:30 <Cale> It's available elsewhere on the web, at least.
08:41:38 <benmachine> > map (subtract 1) [1 .. 5]
08:41:40 <lambdabot>   [0,1,2,3,4]
08:42:15 <Vanadium> It probably is 150KB/s upload split among half the channel clicking reflexively
08:42:17 <malorie> ah. neat
08:42:24 <benmachine> yeah >_>
08:42:36 <benmachine> all you guys stop so I can get it first :(
08:42:51 * benmachine goes and does something else
08:42:56 <Cale> malorie: Num instance for functions :)
08:43:08 <benmachine> > map 7 [1,2,3]
08:43:09 <lambdabot>   [7,7,7]
08:43:12 * benmachine wins
08:43:14 <Cale> malorie: So, numeric literals can be treated as constant functions
08:43:29 <Vanadium> That sounds crue
08:43:29 <Vanadium> l
08:43:35 <Vanadium> > 7 7
08:43:36 <benmachine> it's not, it's kinda neat
08:43:36 <lambdabot>   Ambiguous type variable `t' in the constraint:
08:43:36 <lambdabot>    `GHC.Num.Num t' arising f...
08:43:47 <benmachine> > (^2) + 1 $ 4
08:43:48 <lambdabot>   17
08:43:51 <malorie> Cale: but that ain't default?
08:44:02 <fryguybob> > map 7 [(-),(-),(-)]
08:44:02 <lambdabot>   [7,7,7]
08:44:06 <benmachine> malorie: it's in the vector-space package on Hackage, I think
08:44:19 <Cale> Yeah, that's what it's from :)
08:44:35 <Cale> Data.NumInstances from that package
08:44:55 <Cale> > map (sin^2 + cos^2) [1..10]
08:44:55 <lambdabot>   [1.0,1.0,0.9999999999999999,1.0,0.9999999999999999,0.9999999999999999,0.999...
08:46:10 <Cale> This is not the textbook, but is also by Awodey: http://www.andrew.cmu.edu/user/awodey/catlog/notes/
08:46:41 <Cale> http://www.reddit.com/r/math/comments/a15co/category_theory_steve_awodey_pdf/ -- this link to the textbook appears to have broken
08:48:41 <ski> @type let uh :: ShowS; uh = showChar 'x' in uh  -- huh ?
08:48:42 <lambdabot> String -> String
08:48:54 <ski> @type let uh :: ShowS; uh = showChar 'x' :: ShowS in uh
08:48:55 <lambdabot> String -> String
08:52:07 * ddarius is going to need to make a task gate for the page fault handler.
09:04:24 <ddarius> 1 :: (Int, Int)
09:04:27 <ddarius> > 1 :: (Int, Int)
09:04:28 <lambdabot>   (1,1)
09:04:57 <pumpkin> :O
09:05:01 <pumpkin> who provides that instance?
09:05:35 <Twey> > "foo" :: (String, String)
09:05:36 <lambdabot>   Couldn't match expected type `(GHC.Base.String, GHC.Base.String)'
09:05:36 <lambdabot>         a...
09:06:02 <pumpkin> > negate (1,1)
09:06:02 <Twey> > 3.5 :: (Float, Float)
09:06:02 <lambdabot>   (-1,-1)
09:06:03 <lambdabot>   (3.5,3.5)
09:06:07 <Twey> Weird
09:06:12 <pumpkin> > sgn (1, -1)
09:06:13 <lambdabot>   Not in scope: `sgn'
09:06:18 <pumpkin> > signum (1, -1)
09:06:19 <lambdabot>   (1,-1)
09:06:25 * pumpkin shrugs
09:06:36 <ddarius> > signum (3, -4)
09:06:37 <lambdabot>   (1,-1)
09:06:39 <pumpkin> > (2,3) * (5,7)
09:06:39 <lambdabot>   (10,21)
09:09:22 * ski would have expected `instance (Monoid w,Num n) => Num (w,n)'
09:10:04 <zygoloid> Monoid w? I would have expected Num w :)
09:10:06 <ski> (for, more or less, symmetry with `instance Num n => Num (r -> n)')
09:12:03 <zygoloid> Num n => Num (n, n) has a certain symmetry with Num n => Num (Bool -> n) :)
09:12:17 <ski> (the latter instance using the discard/copy comonoid on `r')
09:13:03 <zygoloid> ski: wouldn't (Monoid w, Num n) => Num (w, n) necessarily have a non-commutative (+) and (*)?
09:13:31 <ski> hrm, there is that, i suppose :)
09:13:58 <ski> make that commutative monoids
09:14:03 <zygoloid> i guess you take abs (w,a) = (w,a) and signum (w,a) = (mempty,a)?
09:14:24 <ski> yeah
09:14:36 <ski> er, `abs (w,a) = (w,abs a)'
09:14:45 <zygoloid> you need Eq and Show on the monoid, too. stupid Num.
09:14:46 <ski> @type abs
09:14:47 <lambdabot> forall a. (Num a) => a -> a
09:14:49 <zygoloid> yeah
09:14:59 <zygoloid> and signum (w, a) = (mempty, signum a) :)
09:15:22 <zygoloid> you can't get negate as a working inverter for (+).
09:15:35 <EvanR-work> holy crap this fcgi program in haskell is fast
09:16:00 * ski idly wonders exactly *what* laws `Num' is supposed to have
09:16:13 <EvanR-work> and im even using String functions to define the web content
09:16:41 <zygoloid> ski: the first Num law is: you do not talk about Num laws. the second Num law is: you DO NOT TALK about Num laws
09:17:54 <EvanR-work> when i write a String to a file, is the string lazily evaluated as its being written
09:18:11 <pumpkin> it can't really be lazy
09:18:22 <pumpkin> who would drive the laziness?
09:19:05 <EvanR-work> is there a way to write it incrementally?
09:19:22 <pumpkin> write chunks at a time
09:19:33 <EvanR-work> literally split it into chunks?
09:20:23 <benmachine> I think the answer to your original question was yes, EvanR-work
09:21:02 <EvanR-work> ill try to rephrase, is the string fully evaluated and stored as single linked list before its written
09:21:43 <benmachine> EvanR-work: writeFile "foo" (repeat 'x') works
09:21:49 <benmachine> does that answer your question?
09:21:57 <EvanR-work> writeFile is lazyIO right
09:22:08 <benmachine> writeFile cannot be lazy
09:22:13 <EvanR-work> oh
09:22:14 <benmachine> there's no result
09:22:25 <benmachine> well there is
09:22:29 <benmachine> but no-one ever demands it
09:22:36 <EvanR-work> i was thinking of hPutStrLn
09:22:47 <benmachine> ...same
09:22:52 <EvanR-work> thats pretty nifty
09:23:00 <benmachine> really only input functions can be lazy in a sensible way
09:23:21 <EvanR-work> i love it when laziness actually works
09:23:23 <benmachine> and even then, hGetLine and friends aren't
09:23:38 <benmachine> EvanR-work: there's a difference between lazy IO and lazy evaluation
09:23:48 <EvanR-work> yeah im not too clear on all the details with IO
09:24:13 <benmachine> lazy IO is unsafe and only possible because of unsafeInterleaveIO - it means that evaluation of the result causes the IO to happen
09:24:24 <EvanR-work> ok
09:24:33 <benmachine> (unsafe used loosely; it's not as bad as unsafePerformIO)
09:25:04 <benmachine> lazy evaluation is where a pure result is not calculated until it is demanded
09:25:31 <benmachine> lazy evaluation is safe because purity guarantees it doesn't matter what order you evaluate things in
09:25:35 <EvanR-work> and in the case of output, it will be demanded carefully so you can incrementally get bytes
09:25:48 <benmachine> hm?
09:25:57 <EvanR-work> > let x = 1:x in x
09:25:58 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:26:08 <EvanR-work> otherwise no output would be produced for infinite lists
09:26:33 <EvanR-work> guess this is obvious if you use jargon like weak head normal form or something
09:26:33 <benmachine> whether or not it is demanded carefully depends on the programmer >_>
09:26:44 <benmachine> > let x = 1 : x in length x
09:26:49 <lambdabot>   mueval: ExitFailure 1
09:26:50 <EvanR-work> i dont have control over the REPL or hPutStrLn
09:27:15 <EvanR-work> im just trying to understand the cases where it *does* work
09:27:27 <EvanR-work> 1,1,1,1,1...
09:27:37 * hackagebot haskelldb 2.0 - A library of combinators for generating and executing SQL statements.  http://hackage.haskell.org/package/haskelldb-2.0 (JustinBailey)
09:27:39 * hackagebot haskelldb-hdbc 2.0 - HaskellDB support for HDBC.  http://hackage.haskell.org/package/haskelldb-hdbc-2.0 (JustinBailey)
09:27:41 * hackagebot haskelldb-hdbc-odbc 2.0 - HaskellDB support for the HDBC ODBC driver.  http://hackage.haskell.org/package/haskelldb-hdbc-odbc-2.0 (JustinBailey)
09:27:59 <EvanR-work> haskelldb updates
09:28:01 <EvanR-work> nice
09:28:10 <benmachine> major version too :o
09:28:27 <EvanR-work> there is still a major bug in hdbc-mysql
09:28:42 <EvanR-work> author didnt seem to optimistic about it
09:28:43 * hackagebot haskelldb-hdbc-postgresql 2.0 - HaskellDB support for the HDBC PostgreSQL driver.  http://hackage.haskell.org/package/haskelldb-hdbc-postgresql-2.0 (JustinBailey)
09:28:45 * hackagebot haskelldb-hdbc-sqlite3 2.0 - HaskellDB support for the HDBC SQLite driver.  http://hackage.haskell.org/package/haskelldb-hdbc-sqlite3-2.0 (JustinBailey)
09:29:19 <benmachine> woah what
09:29:26 <benmachine> haskelldb went 0.13 -> 2.0
09:29:33 <burp> lol
09:29:51 <EvanR-work> puntuated equilibrium ;)
09:30:01 <EvanR-work> punc*
09:30:47 <EvanR-work> @src concat
09:30:47 <lambdabot> concat = foldr (++) []
09:33:00 * burp looks at the changes
09:33:34 <burp> last time I tried it, it was missing important features
09:33:45 <burp> but version 2.0 suggests that it's finished now? :D
09:35:08 <ski> > showsFun 0 [False,True] shows shows `flip` "" `map` ((|->|) `join` [False,True])
09:35:09 <lambdabot>   ["\\it -> case it of {False -> False; True -> False}","\\it -> case it of {...
09:37:43 <Jonno_FTW> > pi
09:37:44 <lambdabot>   3.141592653589793
09:37:51 <Jonno_FTW> > pi :: CReal
09:37:52 <lambdabot>   3.1415926535897932384626433832795028841972
09:38:14 <benmachine> > 3.1415926535897932384626433832795028841972 :: CReal
09:38:15 <lambdabot>   3.1415926535897932384626433832795028841972
09:38:33 <benmachine> hmm
09:38:35 <ski> > (3.1415926535897932384626433832795028841972 :: CReal) == pi
09:38:37 <lambdabot>   False
09:39:13 <ski> > (3.14159265358979323846264338327950288419716939937511 :: CReal) == pi
09:39:14 <lambdabot>   True
09:39:32 <benmachine> hmph
09:41:19 <Mathnerd314> would you say that Haskell has first-class continuations?
09:41:23 <Jonno_FTW> it's just that I have lambdabot running 
09:41:33 <Jonno_FTW> and it gets a timeout when doing > pi
09:41:40 * hackagebot haskelldb-th 2.0 - Template Haskell utilities for HaskellDB.  http://hackage.haskell.org/package/haskelldb-th-2.0 (JustinBailey)
09:41:44 <mm_freak> Mathnerd314: nope
09:41:54 <shapr> Yay! haskelldb 2.0!
09:41:58 * shapr cheers furiously
09:42:50 <mm_freak> Mathnerd314: simply by the fact that the current continuation is not accessible in haskell, but of course there is ContT, which models CPS computations
09:43:26 <Mathnerd314> mm_freak: ah... so if Haskell had call/cc, you'd say it did?
09:43:32 <Cale> Mathnerd314: yeah
09:43:34 <mm_freak> yes
09:43:35 <benmachine> :t callCC
09:43:36 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
09:43:41 <benmachine> <_<
09:43:46 <Cale> If there were a defined function of type ((a -> b) -> a) -> a
09:44:15 <Cale> But it would spoil referential transparency
09:44:36 <Cale> So it's not really completely desirable
09:44:57 * benmachine wonders if continuations are useful in an applicative context
09:45:03 <mm_freak> i don't think you need first class continuations in haskell
09:45:20 <Cale> It would be nice if the IO monad was a continuation monad
09:45:36 <pumpkin> I agree
09:45:44 <mm_freak> true, but i don't find it that bad to use ContT r IO
09:46:08 <Mathnerd314> Cale: how does it spoil referential transparency?
09:46:34 <mm_freak> after all delimited continuations are much more useful
09:46:36 <quicksilver> what haskell has, instead is a way of using continuations as long as you plan for it up-front; which means they have to be delimeted in extent.
09:46:47 <quicksilver> modulo speling.
09:47:31 <Cale> Mathnerd314: using call/cc, you can implement something similar to IORefs
09:47:55 <quicksilver> Cale: couldn't you use the extensible exception mechanism to write a MonadCont instance for IO?
09:48:03 <ski> Mathnerd314 : you can implement `argfc : () -> a -> a', such that `map (argfc ()) [0,1,2,3]' evaluates to `[0,0,0,0]' (or some of the other numbers instead of `0', depending on evaluation order)
09:48:17 <Cale> quicksilver: That's an interesting idea...
09:48:28 <ski> Cale : not *quite* .. but really strange things, anyway, yes
09:48:32 <mm_freak> Mathnerd314: call/cc allows you to have a function, which you can reexecute with different results
09:48:55 <ski> quicksilver : what to do with computations using a continuation more than once ?
09:49:19 <ski> s/argfc :/argfc ::/
09:49:22 <Cale> ski: hmm, there's some scheme code for it here which looks pretty translatable http://www.mail-archive.com/haskell@haskell.org/msg14047.html
09:49:45 <mm_freak> Mathnerd314: as a notable example of this you can implement labels and goto with values using this
09:49:47 * hackagebot Crypto 4.2.2 - Collects together existing Haskell cryptographic functions into a package  http://hackage.haskell.org/package/Crypto-4.2.2 (CreightonHogg)
09:49:59 <mm_freak> so this doesn't play well with pure code
09:50:02 * Cale tries...
09:50:14 <quicksilver> ski: well, you perform the side-effects more than once; a monadcont instance only requires ((a -> IO b) -> IO a) -> IO a
09:50:27 <ski> Cale : that's using the mutative (rather than the Turing/Ackermann fixpoint) implementation of `letrec'
09:50:52 <ski> Cale : so, the only thing that does is expose the mutation inside `letrec' :)
09:50:56 <quicksilver> ski: I could be entirely off-base though it was an intuitive leap not a reasoned thought :)
09:50:57 <Cale> ski: Okay, that's a detail that I don't quite understand.
09:51:09 <Cale> How does letrec do any mutation?
09:51:10 <gwern> > 25214351 * 0.01
09:51:10 <lambdabot>   252143.51
09:52:10 <gwern> it amuses me to think of everything going on behind the scenes when I type in that expression, as compared to the most efficient asm with a MUL or two
09:52:19 <gwern> orders of magnitude is an understatement ;)
09:53:13 <gwern> heck, it probably takes 5 or 6 orders of magnitude more instructions just for the network parts!
09:53:33 <mm_freak> gwern: the price of elegance =)
09:53:40 <monochrom> don't forget that lambdabot runs in a virtual machine
09:54:02 <mm_freak> you have a /bot/ calculating this /over the network/ and you're typing /actual numbers/ and /an actual operator/ instead of bit patterns =)
09:54:04 <gwern> monochrom: well, I'm not sure how bad that is. for something like Xen, there's very little overhead
09:54:29 <gwern> iirc, Xen as a paravirtualizer only has overhead for privileged OS calls into ring 0
09:54:35 <mm_freak> xen would be overkill for lambdabot, i'd use openvz
09:55:17 <gwern> mm_freak: I know, it's obvious if you *think* about it - but how often do we think about it?
09:55:24 <monochrom> it uses xen. linode.com
09:55:46 <ski> Cale : `(define-syntax letrec (syntax-rules () ((letrec ((?x ?e) ...) . ?body) (let ((?x *undefined*) ...) (let ((?y ?e) ...) (list (set! ?x ?y) ...) (let () . ?body))))))' iirc
09:56:14 <mm_freak> gwern: seldomly…  probably the type system often needs more CPU cycles than the actual program
09:56:21 <Cale> ski: Weird :)
09:56:48 <gwern> mm_freak: well, for devs it's taken for granted that we spend more time tweaking and compiling stuff than actually running it
09:56:59 <mightybyte> Where are RegexMaker and RegexLike instance defined in the regex- packages?
09:57:19 <mm_freak> gwern: no, i mean the compilation cycle compared to the application runtime
09:57:28 <ski> Cale : i.e. evaluate the expressions in an environment where the variables are not yet initialized, then mutate each variable to the respective result of the expressions, and evaluate the body in this new environment
09:57:29 <mightybyte> *instances
09:57:40 <mm_freak> gwern: most programs i write are short-lived
09:57:41 <Cale> ski: yeah
09:57:45 <gwern>  mm_freak: oh, in mueval you mean. that is probably true for nice behaved expressions
09:57:51 <Cale> ski: I suppose that works.
09:58:01 <gwern> mm_freak: obviously something like let x = x in x would spend more runtime than typecheck time if we let it...
09:58:10 <Cale> It's just not at all what I'd expect letrec to do.
09:58:15 <mm_freak> i remember copumpkin writing a comma category in agda, which took gigabytes of RAM to typecheck =)
09:58:26 <ski> Cale : the specification doesn't forbid that it set each variable in turn to the corresponding value (that's known as `letrec*'), but it doesn't specify that behaviour, either
09:58:50 <mm_freak> gwern: or it aborts right away with "endless loop!", but that's unlikely =)
09:59:00 <Cale> ski: So mutual recursion is not guaranteed to work?
09:59:15 <ski> Cale : so, the mutation is exposed when some of the expressions returns again, after the `set!'s has already happened
10:00:15 <ski> Cale : `(letrec ((even? (lambda (n) ..n..odd?..)) (odd? (lambda (n) ..n..even?..))) (odd? 4))' is guaraqnteed to work
10:00:20 <EvanR-work> in a >>= b, normally a or b could be evaluated first, but in IO a is always first?
10:00:46 <ski> Cale : `(letrec ((a 2) (b (+ a 1))) a)' is not
10:00:47 <mm_freak> EvanR-work: 'a' is /executed/ first
10:01:03 <Vanadium> 'a's sideeffects are sequenced before 'b's
10:01:31 <Cale> EvanR: It doesn't really specify anything about the evaluation order, but you can expect that a will be evaluated first usually.
10:01:38 <mm_freak> the evaluation order of 'a' and 'b' is unspecified
10:02:01 <ski> (Cale : but using `letrec*' instead of `letrec', that last is also guaranteed to work .. with the clauses in that order)
10:02:11 <mm_freak> evaluation leads to 'IO a', execution leads to 'a'
10:02:37 <monochrom> (unless you unsafeInterleaveIO, of course)
10:02:50 <Cale> Also, if you have something like x >>= \v -> y, then x will certainly be evaluated before anything in y, because the bodies of lambda abstractions are never evaluated before application, and x needs to execute before the lambda can be applied.
10:03:35 <Cale> (Of course, if there are other references to y, it might be evaluated before anyway)
10:04:19 <Vanadium> Are we talking about IO's >>= specifically or can I just postulate a "a >>= b" that goes "seq b (a >>= b)"?
10:04:37 <Cale> ski: The only difference there is that in the first case we have functions and in the second we don't?
10:05:08 <Cale> Vanadium: In that last bit, I'm pretty much referring to any >>=
10:05:50 <Cale> Vanadium: GHC never evaluates the body of an unapplied lambda abstraction.
10:06:00 <ski> Cale : the difference being that to evaluate `(lambda (n) ..n..odd?..)' you don't need to evaluate `odd?' (and mutatis mutandis for the other clause)
10:06:21 <ski> Cale : whereas evaluating `(+ a 1)' requires evaluating `a'
10:07:14 <Vanadium> Cale: Yeah, I realise the seq would not do anything to a lambda.
10:09:00 <pumpkin> mm_freak: only 1.2GB!
10:09:07 <ski> Cale : so `(letrec ((transform-forest (map transform-tree)) (transform-tree (lambda (tree) ..transform-forest..tree..))) ...)' is probably bad (need to eta-expand)
10:10:22 <shapr> Dangit, I've forgotten which package wanted to use both Crypto and QuickCheck.
10:12:11 <bblum> is there a library function that does what "fmap $ replicate 1" does?
10:12:30 <monochrom> no
10:12:30 <ski> @type fmap $ replicate 1
10:12:31 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f [a]
10:12:45 <ski> @type fmap (: [])
10:12:46 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f [a]
10:13:00 <bblum> i have a thing inside a monad and i'd like to concisely make a singleton list of it
10:13:09 <pumpkin> replicate 1 seems silly
10:13:20 <bblum> yeah, ":[]" is a better idea
10:13:23 <bblum> but still
10:13:24 <pumpkin> or pure
10:13:34 * djahandarie would use pure
10:13:34 <ski> bblum : s/fmap/liftM/, i'd do
10:13:40 <djahandarie> Or a pointed functor :)
10:14:01 <ski> (well, if you're in a specific monad, i suppose `fmap' works as well)
10:14:20 <bblum> noted
10:14:34 <shapr> Hm, looks like it was either HaskellNet or ssh, and they both build with wchogg's update of Crypto that removes the Arbitrary instances for Word64.
10:18:17 <bblum> what are the precedences among <$>, <*>, and $?
10:18:56 <shapr> I really do want a tool that lets me search reverse cabal deps for Hackage.
10:19:29 <zygoloid> bblum: $ is the lowest of all possible precedences (infixr 0). iirc <$> and <*> are infixl 4 but i'm not 100% on that
10:19:53 <monochrom> at the ghci prompt enter ":info <$> <*> $"
10:20:01 <dcoutts> shapr: the new hackage does that, take a look on http://sparky.haskell.org:8080/
10:20:10 <monochrom> larger number means binds tighter
10:20:21 <bblum> nod, thanks
10:20:36 <EvanR-work> whats the max precedence
10:20:39 <zygoloid> 9
10:20:47 <EvanR-work> can you use fractional precedence
10:20:55 <monochrom> actually I can't for my life remember larger number means what. fortunately ":info * +" reminds me well
10:20:58 <zygoloid> in some sense, function application is infixl 10, but that's not a 'real thing'
10:21:07 <zygoloid> EvanR-work: nope, only integers.
10:21:15 <EvanR-work> ten levels of precedence
10:21:20 <EvanR-work> guess thats enough!
10:21:32 <shapr> dcoutts: Does it let me ask which packages depend on both QuickCheck and Crypto?
10:21:33 <Vanadium> EvanR-work: Maybe we can extend it to use doubles for the precedence later.
10:21:42 <dcoutts> shapr: no
10:21:48 <EvanR-work> reminds me of programming in basic
10:21:55 <EvanR-work> 10 foo
10:21:56 <EvanR-work> 20 bar
10:22:00 <EvanR-work> oops 15 baz
10:22:03 <EvanR-work> 11
10:22:06 <shapr> EvanR-work: Except that programming in Haskell has a higher precedence.
10:22:07 <zygoloid> EvanR-work: they're all used in the Report, too: http://control.monad.st/haskell/operator-precedences/
10:22:10 <dcoutts> shapr: you could approximate it by intersecting the two lists, though it's not quite the same thing
10:22:13 <EvanR-work> now i need 10.5
10:22:27 <shapr> Ooh, I like the tags!!
10:23:39 <bblum> ugh. i have values "a" outside the monad and "b" inside the monad and want to create the list "[a,b]"... considering "reverse <$> liftM (:[a]) b" versus "liftM2 (:) (return a) b"
10:23:57 <bblum> is there a prettier way? :\
10:24:41 <Cale> fmap (a:) b ?
10:24:51 <Vanadium> sequence [return a, b]?
10:25:13 <bblum> ahhh, sequence :)
10:25:45 <zygoloid> (\b -> [a, b]) <$> mb
10:25:55 <pumpkin> flip [pure a, b]
10:26:06 <emph> Hi there. I've recently started reading The Craft of Functional Programming and are working my way through the examples. Though I've problems with one. I guess it's more of an algorithmic question than a haskell one but I hope someone here would help me. The exercies is to find out the maximum number of pieces made with n planar cuts through a solid block. 
10:26:10 <djahandarie> Choose your poison
10:26:20 <djahandarie> Pick your poison rather
10:30:54 <ddarius> [over] dip swap i
10:31:28 <shapr> ddarius: Hey, that's Joy!
10:31:48 <ddarius> over isn't in Joy, I don't think, not even under a different name.
10:31:52 <shapr> oh
10:31:55 <shapr> What is that then?
10:32:21 <ddarius> shapr: My language that's based on Joy, but much more restrained with elements of Prolog and Forth.
10:32:35 <shapr> Ooh, I want to see! Do you have a working implementation?
10:32:43 <ddarius> shapr: Yes.
10:32:55 * shapr begs
10:33:13 <ddarius> It can't really do anything that Joy can't do other than it isn't trying to be pure at all.
10:33:31 <ddarius> (In fact, it is designed to not be able to do some of the stuff Joy can do.)
10:34:27 * shapr tries cabal install DerekJoy
10:35:09 <ddarius> shapr: It's name, for now and probably permanently, is Koi and it's written in x86 assembler.
10:35:22 <shapr> whoa
10:35:23 <ddarius> Though I could write a Haskell interpreter in about five minutes.
10:35:27 <shapr> Ok!
10:36:03 <Cale> > extendSequence [1,1,2,3]
10:36:05 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:36:07 <Cale> hmm
10:36:27 <Cale> The OEIS web search is down and yet that works
10:36:39 <Cale> oh, it's back
10:37:45 <EricSlaman> what are the advantage of learning Haskell?
10:37:52 <pumpkin> EricSlaman: mind exercise
10:38:03 <shapr> EricSlaman: Awesome wizardly programming powers!
10:38:04 <Cale> EricSlaman: It's an awesome language in which to write programs in general.
10:38:42 <silver_> EricSlaman, feels good man
10:39:06 <Cale> emph: First work out the maximum number of pieces when slicing a plane with n cuts.
10:39:45 <EricSlaman> what you recommend?
10:39:47 <mm_freak> pumpkin: "only" ;)
10:39:50 <emph> Cale: Thats done already, but I can't seem to get a good pattern after that.
10:39:51 <EricSlaman> book i mean
10:39:56 <pumpkin> mm_freak: damn right
10:40:31 <Cale> emph: Okay, so suppose we've already cut a cube into as many pieces as possible with n-1 planes.
10:41:06 <hartmut__> Is it complicated to get flymake running on Haskell?
10:41:23 <ddarius> http://hpaste.org/40455/brute_force_pci_enumerator_in
10:41:54 <ddarius> @tell chrisdone When you click Preview on hpaste it unchecks the "Expire in an hour" box.
10:41:54 <lambdabot> Consider it noted.
10:41:56 <Cale> emph: If we add another plane, in the best case it will cut through each of the n-1 planes, with intersection lines that cut that new plane into as many pieces as possible
10:42:22 <EricSlaman> can someone recommend me a book in haskell?
10:42:36 <djahandarie> @where LYAH
10:42:37 <lambdabot> http://www.learnyouahaskell.com/
10:42:43 <djahandarie> EricSlaman, start with that, in my opinion.
10:42:44 * ddarius suspects that pumpkin actually executes some of his Haskell rather than just type checking it.
10:42:50 <Cale> Yeah, probably start with LYAH, there's also...
10:42:51 <djahandarie> EricSlaman, it isn't in paper form yet though
10:42:54 <Cale> @where rwh
10:42:54 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:42:59 <Cale> @where wikibook
10:42:59 <lambdabot> http://en.wikibooks.org/wiki/Haskell
10:43:02 <Cale> @where yaht
10:43:02 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
10:43:06 <EricSlaman> which is better?
10:43:06 <pumpkin> ddarius: occasionally :)
10:43:12 <djahandarie> EricSlaman, do them in order.
10:43:18 <djahandarie> At least LYAH first
10:43:19 <pumpkin> typechecking haskell isn't hard enough
10:43:25 <ddarius> That is true.
10:43:36 <pumpkin> so it's not much of a challenge
10:43:39 <Cale> emph: Does that make sense, or should I try to make that clearer?
10:43:42 <pumpkin> making it fast and do interesting things is though
10:44:27 <djahandarie> Maybe there should just be a single trigger for books/tutorials
10:44:59 <emph> Yes, I'll try it from there. Thanks for the tip. I'll shout if I don't get it working :)
10:45:15 <Cale> emph: So, when we add this new cutting plane P to the solution for n-1 cuts, the plane P will be cut by the other n-1 planes into as many pieces as possible for a plane, and each of those pieces will sever a piece of the solution for n-1 cuts into two
10:46:59 <djahandarie> Cale, is it possible to use more fancy words in that explanation? "Use a monomorphic cut generalized over all polytopes to result in a hyperplane in m dimensions with n-1 cuts"...... or something like that. :P
10:50:06 <Esteth> Hey guys. Does anyone know of an IRC channel where people discuss system/network design? Sorry to ask here, but it's the best place I know for smart programmers
10:52:02 <Mathnerd314> ski: I still don't see how to implement argfc in your example
10:52:53 <ski> Mathnerd314 : `argfc () = callcc (\k a -> k (\_ -> a))'
10:55:20 <teseract> @help
10:55:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:56:06 <aug_triad> what's the latest shit?
10:57:04 <ddarius> Max Bolingbroke needs to read Simon Marlow more carefully.
11:01:44 * ski wonders what the dual of "knows" is
11:02:19 <pumpkin> "is known by"
11:02:28 <ski> that's the *converse*
11:02:48 <pumpkin> what would dual mean in this context?
11:03:10 <Mathnerd314> ski: "has never heard of"
11:03:15 <ski> the dual of `\who what -> knows who what' is `\who what -> not (knows who (not what))'
11:03:38 <Mathnerd314> wait, what?
11:03:39 * ski is looking for some more colloquial way to express that
11:03:57 <pumpkin> "doesn't know that it isn't the case that"
11:04:03 <Mathnerd314> ski: how is (not what) defined?
11:04:15 <ski> just ordinary propositional negation
11:04:29 * fryguybob who's on first, what's on second
11:04:36 <ski> like "Bob knows the sun is not blue."
11:04:58 <ski> or "Cedric knows the `topiclock' option is not enabled."
11:05:01 <Mathnerd314> and the dual is "Bob doesn't know the sun is blue"?
11:05:57 <ski> .. aye
11:08:47 <zygoloid> ski: interesting. A knows B => not (A knows (not B)), if A's knowledge is consistent. not (A knows (not B)) => A knows B, if A's knowledge is complete. i guess consistency and completeness are dual too?
11:09:04 <ski> zygoloid : indeed they are
11:09:09 <zygoloid> i guess on reflection they obviously are ;)
11:09:26 <ski> er, actually, afaik, consistency is dual to provability
11:09:31 <zygoloid> since they're about truth and falsehood either overlapping or having a gap
11:09:33 * ski ponders this
11:11:09 <zygoloid> consistency (the nonprovability of A and not A) should be dual to the provability of A or not A, that is, completeness.
11:11:54 <ski> as i've seen it, `Prf_A(F)' means that `F' is provable in system `A', while `Con_A(F)' means that it would be consistent in system `A' to assume `F' as an extra axiom
11:12:01 <ski> and these two would be dual
11:13:48 <zygoloid> oh, i was talking about the system as a whole
11:13:53 <ski> iirc, in provability logic, one can express the non-provability of consistency as `[] (not ([] _|_)) -> [] _|_' .. which can also be cast as `[] (<> T) -> [] _|_'
11:14:07 <ski> (with `[]' being provability' and `<>' being consistency)
11:14:38 <ski> see "The Logic of Provability" (earlier version named "The Unprovability of Consistency") by George Boolos
11:24:36 <ski> zygoloid : btw, cf. `precision' : `sensitivity' :: `soundness' : `completeness' (see <http://en.wikipedia.org/wiki/Accuracy_and_precision> and <http://en.wikipedia.org/wiki/Sensitivity_and_specificity>)
11:30:08 <ski> zygoloid : hm, you need to distinguish between `[] (A \/ not A)' and `[] A \/ [] (not A)' .. the latter expressing what i think you meant by "completeness"
11:32:04 <ski> your "consistency" is, i think, `not ([] (A /\ not A))' which is `<> (not A \/ A)'
11:32:16 <zygoloid> ski: i was saying '¬(exists A)([]A /\ []¬A)' (consistency) is dual to '(forall A)([]A \/ []¬A)' (completeness)
11:33:31 <zygoloid> though the former being '¬(exists A)([](A /\ ¬A))' is equally reasonable i think
11:33:31 <ski> *nod*
11:34:00 <ski> .. or `forall A. not ([] A /\ [] (not A))'
11:35:14 <ski> (or `forall A. <> (not A) \/ <> A')
11:35:17 <zygoloid> yeah :) AKA '(forall A)(¬[]A \/ ¬[]¬A);
11:35:42 <ski> if you wish :)
11:35:45 <zygoloid> :D
11:36:14 <zygoloid> in modal logic, is the dual just swapping [] for <> and vice versa then?
11:36:23 <ski> yes
11:37:00 <ski> but if we let `[]_A' mean "A knows" (for some agent `A'), then i'm not sure how to pronounce `<>_A'
11:37:33 <ski> (another interesting thing to consider is `[]_A' meaning `A wants ... (to be the case)')
11:38:12 <monochrom> perhaps []_A P "A knows P is a must", <>_A P "A knows P is a maybe"
11:39:15 <monochrom> this is why irc software should be rewritten to display [monochrom] rather than <monochrom> :)
11:39:57 <zygoloid> ski: A does not know of a counterexample to...
11:40:30 * ski is pondering a system in which `[]_false P' means "Everyone knows `P'" and `[]_true P' means "Someone knows `P'"
11:40:34 <monochrom> I disgaree. A sees an example
11:40:53 <monochrom> [monochrom] x=x.  <monochrom> x=0.
11:41:56 <monochrom> "monochrom thinks that x=x is always true". "monochrom thinks that x=0 is possible".
11:42:27 <ski> (and the disjunction of two agents is the composite agents who knows anything either of the two agents knows .. while a conjunctive agent knows only the things each of the constituent agents know ..)
11:42:30 <zygoloid> you don't need to see an example to think something is possible
11:42:47 <ski> (.. does this seem to be the correct naming ? or backwards ?)
11:43:26 <monochrom> but counterexample alone doesn't refute it either. there are counterexamples to x=0 but monochrom still thinks that x=0 is possible.
11:44:20 <zygoloid> <monochrom> P <=> ¬[monochrom] ¬P.  presumably ¬[monochrom] ¬(there is no proof that P=NP), but you couldn't say that you have an example of a proof that P=NP
11:44:35 <zygoloid> hmm, i muddled that somewhat
11:44:51 <monochrom> alright, no examples.
11:45:03 <zygoloid> if you have a counterexample, then x=0 is not possible
11:45:51 <zygoloid> <monochrom> P means you don't know any way to refute P.
11:45:53 <ski> "A doesn't know P to be false."
11:46:04 <monochrom> there is no way to refute x=0
11:46:12 <zygoloid> sure there  is. x=1 would do it
11:46:28 <MasseR> Cabal install is like a woman. Your best friend when all's good, but when you say one thing wrong, all hell breaks loose
11:46:31 <monochrom> no. I do not have any quantifier over x.
11:46:52 <monochrom> In particular I do not say <monochrom> ∀x.x=0
11:46:52 <zygoloid> nor do i. so we're speaking of the same x, yes?
11:47:21 <ski> monochrom : if you do not quantify over `x', then `x = 0' is an open proposition, depending on the ambient value of `x'
11:47:56 <zygoloid> (<>x=0) /\ ([]x=1) -> _|_
11:48:07 <monochrom> I don't know. there is some unknown quantity x. perhaps a constant in physics yet to be measured carefully. therefore <monochrom>x=0 and <monochrom>x=1 and <monochrom>x=0.001 etc
11:48:15 <ski> "as far as A is concerned, P might be knowable."
11:48:22 <monochrom> Yes it is open. That's what makes it <monochrom>
11:48:43 <zygoloid> monochrom: it is refutable by [monochrom] x >= 5
11:49:02 <monochrom> But I don't know that x>=5.
11:49:23 <zygoloid> i'm completely confused about what you're trying to say
11:49:50 <monochrom> I am trying to say [monochrom]x=x, <monochrom>x=0
11:50:01 <zygoloid> what about it?
11:50:29 <monochrom> (<monochrom>x=0) = (monochrom thinks that x=0 is possible)
11:51:10 <zygoloid> what do you mean by 'possible', if not 'you don't know a way to refute it'?
11:51:35 <ski> "P isn't ruled out by A."  -- bah, still a negation
11:51:50 <zygoloid> ski: still a double negation
11:51:53 <monochrom> right, I don't know a way to refute x=0.
11:52:16 <IceDane> Is there a reason MaybeT isn't in the standard library?
11:52:28 <ski> zygoloid : one of them is "hidden" in a way of expression (you don't say "ruled in")
11:52:33 <zygoloid> monochrom: then i think we agree?
11:53:48 <monochrom> I disgree with either (there is a counterexample to x=0) or (a counterexample to x=0 falsifies (<monochrom>x=0))
11:54:07 <ski> (.. btw, dualizing `A wants P' i think we get `A is ok with P')
11:55:02 <monochrom> and I don't know which because I am not sure what is the definition of counterexample
11:55:02 <ski> monochrom : the latter, is what i would expect
11:55:18 <ski> counter-model, no ?
11:55:21 <zygoloid> monochrom: knowledge of something mutually exclusive
11:55:56 <mwbuksas> Hi all. First time here. Is this an okay place to ask questions about installing the Haskell platform?
11:56:14 <zygoloid> mwbuksas: it's a much better place for that than what we're currently using it for! ask away
11:56:33 <monochrom> take the FOL nonclosed sentence "x=0". yes it has a free variable, deliberately so. is there a model making it false? yes there is. but I still have (<monochrom>x=0) because there is another model making it true.
11:56:56 <mwbuksas> Heh. I don't seem to have gotten binaries for ghc and ghci in my installation. Am I supposed to? 
11:57:19 <zygoloid> mwbuksas: did you install the binary version of the platform or the source version?
11:57:19 <ski> `<>_#haskell (ask question about ...)' ?
11:57:31 <ski> (reading `[]' as "wants" :)
11:58:11 <mwbuksas> I installed a generic binary to get ghc 6.12.3, then compiled 2010.2.0.0 from source.
11:58:42 * ski slithers back into the pothole, for a while
11:58:57 <benmachine> IceDane: it depends what you mean by the standard library
11:59:23 <benmachine> IceDane: MaybeT doesn't come with GHC because GHC doesn't need it; it's not mandated by the Report because those libraries are supposed to be relatively spartan
11:59:39 <benmachine> IceDane: as for why it isn't in the haskell-platform, well, I suppose no-one suggested it
11:59:42 <benmachine> or really needed it
12:00:51 <IceDane> benmachine: I see
12:00:54 <IceDane> Fair enough
12:00:57 <Saizan> mwbuksas: then you're supposed to continue using your ghc/ghci from the generic ghc binary tarball
12:01:40 <benmachine> identity: I wouldn't worry too much about the "standard library"; all the cool toys are on Hackage anyway :)
12:02:04 <mwbuksas> Saizan: Thanks. So just the binary releases come with ghc/ghci?
12:02:16 <monochrom> But I do suggest you to use the notation <a> instead of <>_a. Indeed <a> is actually done in papers. In the μ-calculus, if you have transition relations R,S, you write <R>p, <S>p for "there exists next step using R to make p true", "there exists next step using S to make p true", respectively.
12:02:36 <identity> benmachine: It would seem so, yeah. It's just that, for some reason, I kind of expect that which is on hackage to be .. well, of lesser quality, though I have not found that to be the case. But it's not uncommon(Look at perl's CPAN which is full to the brink of semi-functional crap libraries)
12:02:53 <Saizan> mwbuksas: yeah, there isn't much point in having you rebuild a ghc from scratch to install the platform
12:03:19 <benmachine> identity: there's crap on hackage, but there's also gold, you just have to either go by reputation, revdeps, or try stuff out
12:03:25 * monochrom thinks that subscripts are overused. many things don't belong to subscripts.
12:03:32 <mwbuksas> Saizan: Makes sense to me. Thanks for the help.
12:03:32 <benmachine> (not either because that's three alternatives but whatever)
12:03:33 <monochrom> s/to/in/
12:03:34 <identity> aye
12:05:31 <mwbuksas> Cheers everyone. Back to work...
12:06:12 <ddarius> monochrom: Which mu calculus is this?
12:06:53 <monochrom> a temporal logic
12:06:56 <ski> monochrom : yeah, i've seen that notation, with binary relations .. not with agents, though
12:10:18 <Funktorsalat> what's disagreeable about subscripts? except that they're small maybe :)
12:11:20 <monochrom> on paper they are small and unsuitable for non-atomic expressions. in irc they are just unfit
12:12:26 * hackagebot hums 0.3.0 - Haskell UPnP Media Server  http://hackage.haskell.org/package/hums-0.3.0 (BardurArantsson)
12:14:30 <aristid> @hoogle readIO
12:14:31 <lambdabot> Prelude readIO :: Read a => String -> IO a
12:14:31 <lambdabot> System.IO readIO :: Read a => String -> IO a
12:14:31 <lambdabot> Data.IORef readIORef :: IORef a -> IO a
12:14:42 <aristid> readIO is in IO so it can throw exceptions?
12:14:52 <monochrom> yes exactly
12:15:12 <aristid> hmm so it should really be in MonadError or so?
12:15:21 <zygoloid> seems a strange choice of monad for exceptions
12:15:37 <monochrom> it should really be in MonadCatchIO
12:15:41 <zygoloid> if it's just going to use fail, why not an arbitrary monad?
12:15:57 <monochrom> it is not just going to use fail
12:16:20 <zygoloid> MonadPlus would make more sense, as a direct generalization of reads' return type
12:25:09 <Funktorsalat> MonadPlus doesn't allow throwing arbitrary Exception instances though
12:26:51 <monochrom> you can write a "readPlus" for MonadPlus and "readError" for MonadError, and propose them to inclusion into haskell 2039
12:27:49 <aristid> one year after the y2k38 bug *giggle*
12:27:55 <monochrom> sadly it can't be earlier because 2037 is already reserved for forM_ and 2038 is I-forgot-what
12:28:15 <aristid> monochrom: the end of 32-bit time_t
12:28:20 <monochrom> but yes there is hope that haskell 2039 becomes haskell 1971, all is not lost.
12:28:21 <Vanadium> 2038 is for inclusion of Int33 so we can avoid the y2k38 bug
12:28:56 <aristid> @remember monochrom but yes there is hope that haskell 2039 becomes haskell 1971, all is not lost.
12:28:56 <lambdabot> Good to know.
12:29:04 <aristid> lambdabot: indeed
12:29:04 <monochrom> hehe
12:29:22 <imc> is there a function like :: [Either a b] -> [a] ?
12:29:34 <pumpkin> :t lefts
12:29:35 <aristid> @hoogle mapEither
12:29:35 <lambdabot> forall a b. [Either a b] -> [a]
12:29:35 <lambdabot> Data.IntMap mapEither :: (a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
12:29:35 <lambdabot> Data.Map mapEither :: Ord k => (a -> Either b c) -> Map k a -> (Map k b, Map k c)
12:29:35 <lambdabot> Data.IntMap mapEitherWithKey :: (Key -> a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
12:29:39 <imc> :D
12:29:40 <imc> thanks
12:29:45 <pumpkin> it's in Data.Either
12:29:56 <pumpkin> guess what [Either a b] -> [b] is called
12:30:05 <aristid> notLefts
12:30:10 <monochrom> dexters
12:30:13 <imc> anyway
12:30:23 <imc> Data.Map actually
12:30:39 <ddarius> @hoogle [Either a b] -> [a]
12:30:40 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
12:30:40 <lambdabot> Data.Either rights :: [Either a b] -> [b]
12:30:40 <lambdabot> Data.Graph.Inductive.Query.DFS topsort' :: Graph gr => gr a b -> [a]
12:30:50 <imc> right(s) :)
12:31:00 <pumpkin> :t left
12:31:01 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
12:31:03 <pumpkin> :t right
12:31:03 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
12:31:06 <pumpkin> :)
12:31:12 <monochrom> perhaps it is topsort
12:31:13 <benmachine> :t foldr (either (:) (const id))
12:31:14 <lambdabot> forall a b. [a] -> [Either a b] -> [a]
12:31:38 <pumpkin> might want a base case there
12:31:38 * ddarius suspects Either would make a bad Graph.
12:32:01 <ddarius> Base cases are for the weak.
12:35:00 <monochrom> common misconception: strong induction still requires a separate base case
12:35:39 <pumpkin> coinduction, on the other hand
12:35:46 <zygoloid> well-ordered induction...
12:35:47 <pumpkin> that's for the strong
12:36:32 <yrlnry> It often seems to me that a lot of induction proofs are simpler and clear when they are phrased in terms of the well-ordering principle.
12:37:32 <zygoloid> monochrom: are you saying strong induction requires a separate base case or does not?
12:37:39 <monochrom> does not require
12:39:45 <zygoloid> Funktorsalat: readIO can't throw an arbitrary Exception instance anyway :)
12:42:44 <monochrom> proof by contradiction+wop simpler? suppose x^(2*n) /= (x^2)^n for some nat n, then there is smallest such n? then a lot of double-negations?
12:50:42 <monochrom> the only way I can see to proceed is to observe that the smallest n cannot be 0, the smallest n cannot be 1, the smallest n cannot be 2... after a while, you give in and use induction to prove x^(2*n) = (x^2)^n, then you can gladly conclude: if there is a smallest n for x^(2*n) /= (x^2)^n, n can't be anyone, contradiction.
12:51:43 <monochrom> all wop contributes is a hard cover so you can sell the proof for more money
12:52:26 <winxordie> In this rough 'n' tumble economy, maxing out the market value of a proof is no laughing matter
13:05:27 <hydo> it's all fun and games until someone loses a hymen.
13:05:31 <hydo> ACK
13:05:36 <hydo> wrong channel :(
13:16:02 * hackagebot pureMD5 2.1.0.1 - A Haskell-only implementation of the MD5 digest (hash) algorithm.  http://hackage.haskell.org/package/pureMD5-2.1.0.1 (ThomasDuBuisson)
13:17:26 <tommd> Could someone tell me how to write a Gpx to a file using hxt?  I have a value "g :: Gpx" and want something like 'writeFile "name.gpx" gpx'  -- it seems everything MUST use the Arrows in hxt though, rather inconvenient at times.
13:17:37 <zomg> Would anyone care to explain to a noob where the "location" comes from in this? http://github.com/nfjinjing/hack-contrib/blob/master/src/Hack/Contrib/Middleware/URLMap.hs
13:18:12 <zomg> I'm trying to understand that to find out why hack-handler-mongrel2 doesn't seem to route requests properly with that
13:18:25 <zomg> but apparently I suck too much to be able to figure it out myself =)
13:18:49 <tommd> zomg: "h.find (fst > (`isPrefixOf` path) )" must be of some type "Maybe (Location, a)"
13:20:07 <tommd> I would have decomposed that a little - just because you _can_ be concise doesn't mean it's always wise.
13:20:46 <zomg> So it would come from the Just (location... part?
13:21:25 <zomg> This really shows my problem with learning Haskell... I can't be bothered with those really simple examples so I just try to dive into something that's way beyond me.. =)
13:22:23 <zomg> Well, it might have worked out if the libraries I'm trying to use weren't in such a work-in-progress stage :p
13:24:09 <luite> does ghci 7.0 for windows have an improved linker, that can load c++ object files?
13:24:39 <bos> wow, parsing Doubles from text to Haskell is astoundingly slow.
13:24:48 <zomg> tommd: oh wait, I just realized I've been looking at this completely wrong...
13:25:12 <zomg> Got totally confused by the fact the different location variables are all called "location" so I thought it was the one and same thing even though it isn't
13:25:15 <zomg> Blah
13:25:18 <zomg> =)
13:25:40 <zomg> No wonder it made absolutely no sense
13:27:32 <djahandarie> bos, does this mean you're going to write a faster one? ;)
13:27:50 <dons> bos: see e.g. bytestring-lexing 
13:28:08 <dons> binary has similar issues. (hence binary-ieeeXXYY
13:28:19 <djahandarie> Oh neat
13:28:23 <dons> http://hackage.haskell.org/packages/archive/bytestring-lexing/0.2.1/doc/html/Data-ByteString-Lex-Double.html
13:30:37 <bos> dons: yeah, i know about that, but it cheats.
13:30:45 <dons> bos: you got me.
13:31:00 <bos> dons: since i'm working with Text values, i can't call strtod
13:31:29 <dons> ah fun fun
13:31:35 <bos> i can parse 2 million Ints per second from a Text
13:31:45 <bos> but 0.1 million Doubles
13:31:47 <dons> that sounds good
13:31:49 <dons> huh
13:32:06 <bos> because it has to go through fromRational
13:32:11 <dons> urgh
13:32:16 <bos> it's actually 1 million Doubles per second if they're integral
13:32:20 <dons> i bet that's not what they do in Fortran 
13:32:23 <bos> a little slower if there's a decimal point
13:32:31 <bos> and slower again with an exponent
13:32:34 <dons> mm
13:32:41 <dons> are alex-generated lexers any good here?
13:32:53 <bos> it's not the lexing that's the problem.
13:33:01 <res> can you use fixed-point and then just format it nicely for output?
13:33:20 <bos> it's purely the arithmetic that's slow in this instance, since i'm using Prelude functions.
13:33:36 <djahandarie> dons, hm, there is a misspelling in the haddocks for bytestring-lexing... "The result is returned as a pair of a double-precisoin [sic] floating point value ..."
13:33:47 <bos> i.e. Integer real component, Integer floating component, Int exponent.
13:33:49 <dons> bos: oh.
13:33:54 <dons> djahandarie: ah
13:33:59 <bos> then a big old fromRational
13:34:26 <djahandarie> And isn't that package an alex-generated lexer in the first place?
13:34:34 <dons> djahandarie: sort of
13:34:38 <bos> and that's all fine for e.g. Rational
13:34:51 <bos> but it would be nice to have tighter code that doesn't need Integer and Rational for Double
13:35:02 <dons> djahandarie: its a bit dumb. alex recognizes a double, but calls strtod to do the parsing
13:35:10 <bos> i figure this code is 20x slower than it should be
13:35:30 <bos> parsing the same data in Python takes a blink of an eye
13:35:49 <djahandarie> That's when you know somethings gone terribly wrong. ;)
13:36:06 <kmc> it shouldn't be too hard to bypass fromRational, right?
13:36:19 <bos> kmc: actually, it's very hard to.
13:37:08 <kmc> your input is a sequence of unicode Char in the form of Data.Text?
13:38:25 <bos> right
13:39:49 <ski> monochrom : (re strong / course-of-values- induction) i had to argue to a math teacher at uni to make her (maybe) accept that ..
13:39:53 <ski> monochrom : "wop" ?
13:40:21 <ski> (can't be "no infinitely descending chain" ..)
13:40:27 <tommd> What does "touch#" do? (ghc core)
13:40:51 <ski> make sure it is not GCed before that is called, i think
13:41:02 <ski> (otherwise being a no-op)
13:41:16 <benmachine> ski: why not? equivalent to every set of natural numbers has a lower bound
13:41:20 <benmachine> er
13:41:24 <benmachine> a least element, rather
13:41:32 <kmc> bos, hmm, the first solution i think of is a sort of atoi (iterating on the array directly, if you need to) which ignores a decimal point but remembers its position
13:41:36 <kmc> and outputs a Double directly
13:41:41 <kmc> then divide by a power of ten
13:41:57 <ski> benmachine : oh .. i suppose "wop" might be "well-ordering property"
13:42:07 <kmc> exponent makes that harder
13:42:11 <ski> @hoogle touch
13:42:11 <lambdabot> Foreign.ForeignPtr touchForeignPtr :: ForeignPtr a -> IO ()
13:42:11 <lambdabot> Data.Array.Storable touchStorableArray :: StorableArray i e -> IO ()
13:42:27 <ski> tommd : at least that's what i think those ^ does
13:43:31 <ski> (benmachine : btw, why not what ?)
13:43:39 <bos> kmc: reading floating point numbers accurately and fast is much more subtle than you think.
13:43:54 <kmc> yeah, i'm sure my method would lose precision on some numbers
13:44:07 <bos> on the other hand, maybe i just don't care about Rational at all.
13:44:24 <benmachine> ski: can't be infinite descending chain
13:44:25 <bos> the code is 10x faster if i get rid of fromRational
13:44:40 <ski> benmachine : hm .. i meant "wop" can't be short for that
13:44:41 <bos> and just do floating point division instead.
13:44:41 <kmc> tommd, from primops.txt.pp: primop TouchOp "touch#" GenPrimOp   o -> State# RealWorld -> State# RealWorld   with has_side_effects = True
13:44:47 <benmachine> ski: oh right :P
13:44:57 <kmc> and it's in the section on "Weak pointers"
13:44:59 <tommd> humm
13:44:59 <benmachine> ski: well-ordering principle I think?
13:45:08 <benmachine> property is just as good I suppose
13:45:25 <kmc> so i think it ensures, as an "IO action", that its first argument is considered live by the GC
13:45:25 <benmachine> http://en.wikipedia.org/wiki/Well-ordering_principle
13:46:08 <kmc> touchForeignPtr (ForeignPtr _ r) = touch r
13:46:11 <kmc> touch r = IO $ \s -> case touch# r s of s' -> (# s', () #)
13:46:28 <djahandarie> reallyUnsafePtrEquality# :: a -> a -> Int#
13:46:29 <djahandarie> heh
13:46:33 <kmc> i like that one a lot
13:46:43 <kmc> shouldn't it be a -> b -> Int#
13:46:48 <kmc> for maximum unsafeitude
13:47:06 <djahandarie> Haha
13:47:10 <djahandarie> Propose it
13:47:22 <benmachine> I imagine it's not that common for pointers of different types to point to the same object
13:47:27 <benmachine> or hmm maybe it is
13:47:29 <benmachine> newtypes etc.
13:47:50 <ski> kmc : that's not to be a conservative John-Major equality, no ?
13:49:08 <min> Does anyone have the address of the "visualize function rewriting" tool. I remember it being linked to a while ago.
13:50:51 <tswett> So, I'm installing the Platform without root access.  I stuck GHC in /home/swettt/ghc.  Now Platform's ./configure is asking me where ghc-pkg is.
13:50:56 <Saizan> min: benmachine's stepeval? or something else?
13:50:58 <tswett> Where is it?
13:51:21 <Saizan> tswett: it should be next to the ghc executable
13:51:57 <Saizan> so if you used --prefix=/home/swettt/ghc while installing ghc, it'll be at /home/swettt/ghc/bin/ghc-pkg
13:52:02 * tswett nods.
13:52:13 <tswett> I wonder why it doesn't look there automatically.
13:52:34 <min> Ah, okay - that was the name. Looks like its just available on github. Thanks Saizan.
13:52:44 <RyanT5000> is there any overhead associated with storing IO actions in datastructures as opposed to storing "plain data", and then running a function on it? or vice versa?
13:53:11 <tswett> Oh, it doesn't ask for where the GHC distribution is, only where each individual binary is.
13:53:20 <Saizan> min: see README for the "webservice"
13:53:50 <Saizan> tswett: i guess you could also add /home/swettt/ghc/bin/ to your PATH
13:53:52 <RyanT5000> for example, i can choose between something approximately like this: IORef (some_data), with a function that opens the IORef and runs a function some_data -> IO a on it
13:54:11 <tswett> Saizan: I guess that's a good idea, yeah.
13:54:14 <pumpkin> RyanT5000: shouldn't be
13:54:15 <RyanT5000> or, alternatively, just having an IORef (IO a), wherein that same function has been partially applied
13:55:20 <RyanT5000> pumpkin: ok, good to know; it's slightly cleaner using the IO a approach, IMO; i just didn't know if i'd miss out on a bunch of compiler optimizations
13:55:25 <monochrom> ski: "wop" is shorthand for "well-ordering principle"
13:55:40 <pumpkin> monochrom: oh, I just thought you were being offensive
13:56:19 <monochrom> you mean "wop" could be an offensive word?
13:56:30 <pumpkin> http://en.wikipedia.org/wiki/Wop
13:57:02 <monochrom> godawful. why do stupid people keep doing name clashes with me?!!
13:57:25 <aristid> http://it.wikipedia.org/wiki/Wop:D
13:57:26 <monochrom> at this rate by 2038 every math word is unsafe!
13:57:46 <aristid> damn i'm too stupid to copy&paste links correctly
13:57:51 <pumpkin> yeah, fail
13:57:56 <aristid> monochrom: you sure love 2038?
13:57:57 <dons> heya RyanT5000 
13:58:08 <RyanT5000> dons: how's it going?
13:58:18 <monochrom> 2038 is an easy target :)
13:58:27 <dschoepe> aristid: well, it is the year in which the famous year2038-problem will strike :)
13:58:42 <monochrom> it's just like how some people love "42"
13:59:03 <bos> okay, i have a function that is 10x faster now, and gives accurate answers in 94% of cases, losing precision around 6% of the time, but never more than 1e-13 of precision
13:59:08 <dons> mmm
13:59:11 <aristid> dschoepe: i know :)
13:59:14 <monochrom> except that "by year 42 every math word is unsafe" can't be right
13:59:18 <bos> i'll keep the accurate function, and the fast one.
13:59:35 <aristid> monochrom: well, maybe by 2038 we will use a different calendar
13:59:48 <Cale> RyanT5000: A neat thing about pre-applying readIORef or writeIORef is that you can control which parts of the code have read or write access to it separately.
13:59:56 <aristid> the new calendar starting in 1996
14:00:05 <aristid> what happened in 1996? *scratch head*
14:00:44 <RyanT5000> Cale: indeed; though, the code in question will all be protected by a module boundary, so safety isn't an especially huge deal
14:02:50 * benmachine waves vaguely at min
14:19:16 <malorie> > map putStrLn ["one","two"]
14:19:17 <lambdabot>   [<IO ()>,<IO ()>]
14:20:00 <malorie> hm. In ghci this gives me "No instance for (Show (IO ()))", whereas `putStrLn "one"' works perfectly.
14:20:08 <pumpkin> mapM_
14:20:16 <pumpkin> you've made a list of imperative actions
14:20:20 <pumpkin> that doesn't mean it'll do anything with them
14:20:29 <malorie> ah
14:20:35 <pumpkin> the imperative actions also have no meaningful way to be converted to strings
14:20:54 <benmachine> lambdabot has a meaningless way of doing it
14:20:54 <benmachine> woo
14:20:55 <gwern> malorie: lambdabot has special Show instances for IO to thwart attacks
14:21:04 <benmachine> it's not to thwart attacks
14:21:14 <min> sequence $ map putStrLn and mapM_ putStrLn will both work
14:21:16 <malorie> at least it makes sense now.
14:21:17 <kmc> malorie, GHCi can handle three things: a) IO actions with showable result, b) IO actions with non-showable result, c) showable values that aren't IO actions
14:21:21 <kmc> [IO ()] is nen of those
14:21:27 <gwern> benmachine: yes it is. laziness means the show instance gets evaluated before the IO action does, so the IO action never is evaluated
14:21:44 <benmachine> gwern: but it would never be executed anyway
14:21:46 <gwern> benmachine: there is nothing in mueval which specifically attacks IO sigs
14:21:54 <kmc> lambdabot will evaluate IO actions
14:21:57 <kmc> it just won't execute them
14:22:00 <gwern> it's all the show instance
14:22:03 <kmc> > putStr "foo" `seq` ()
14:22:04 <lambdabot>   ()
14:22:26 <kmc> IO has no Show instance by default, and it'd be impossible to write one (without using unsafePerformIO) which performs execution
14:23:15 <imanoob> hi, i am discovering GLUT with the haskell platform (the latest version) and when i try to execute a simple program i got the error : "testglut[30450:10b] GLUT Fatal Error: internal error: NSInternalInconsistencyException, reason: Error (1002) creating CGSWindow"
14:23:17 <kmc> i don't see how lambdabot's Show for IO adds any security.  the security comes from simply not having anything to execute IO actions
14:23:32 <imanoob> does someone have an idea to solve that ?
14:23:40 <gwern> kmc: look inside mueval - expressions get passed straight to ghc api
14:23:47 <benmachine> ok I can't get mueval to do anything because it jsut cries that there are too many Control.Monad.Conts
14:24:02 <kmc> imanoob, Google does.  it seems that it's a common OS X GLUT error, not related to Haskell
14:24:08 <pumpkin> the point is that evaluation is separate from execution, and nothing ever gets executed in lambdabot
14:24:08 <gwern> kmc: and the ghc api can definitely evaluate IO stuff without issue...
14:24:22 <pumpkin> it can, but lambdabot simply doesn't ask it to :P
14:24:23 <kmc> gwern, oh, you can't disable that?
14:24:26 <kmc> super lame
14:24:30 <imanoob> kmc: gonna have a look
14:24:32 <imanoob> thx
14:24:33 <gwern> pumpkin: then why have I been able to inspect /etc/passwd through lambdabot when I forgot the show instances?
14:24:42 <gwern> WHERE IS YOUR EVAL NOW
14:24:44 <benmachine> lolz
14:24:46 <pumpkin> lol
14:24:46 <kmc> i assumed mueval used some "evaluate but don't execute" function in GHC API
14:24:51 <c_wraith> It's so sad when running my quickcheck tests, watching memory use spike while ld runs, then fall back down after the tests start
14:25:00 <gwern> isn't it sad, sacchin
14:25:07 <benmachine> I thought it just printed the result
14:25:17 <benmachine> instead of using ghci's weird IO-guessing
14:25:25 <pumpkin> seems strange to me
14:25:39 <benmachine> gwern: I'm still not convinced by your argument
14:25:39 <gwern> pumpkin: fine go look at mueval and tell me how I'm wrong ~-~
14:25:42 <gwern> it's open source
14:25:48 <benmachine> so's ur face
14:25:55 <pumpkin> too lazy, and packing right now :P
14:25:59 <pumpkin> got a plane to catch soon
14:26:01 <gwern> (what do I know I only wrote mueval and did a little reverse-engineering of lambdabot)
14:26:02 <mjrosenb> Cale: i may have asked you this before, did you write up a tutorial on a method of writing haskell in an oop-ish way by having the datatypes hold functions that modify the state of the world?
14:26:08 <benmachine> pumpkin: where to? (stalkstalkstalk)
14:26:16 <pumpkin> benmachine: the US of A!
14:26:20 <benmachine> :O
14:26:21 <benmachine> lame
14:26:22 <benmachine> come here instead
14:26:23 <gwern> benmachine: hey, if you want my face, I'd be glad to oblige. I'm open-minded
14:26:24 <benmachine> it's better
14:26:29 <benmachine> gwern: neat
14:26:35 <pumpkin> benmachine: nah, been there done that
14:26:43 <benmachine> pumpkin: you didn't tell me :(
14:26:51 <benmachine> I feel personally betrayed
14:26:53 <kmc> Prelude Language.Haskell.Interpreter> runInterpreter $ do { setImportsQ  [("Prelude",Nothing)]; eval "print \"foo\"" }
14:26:53 <kmc> Left (WontCompile [GhcError {errMsg = "No instance for (GHC.Show.Show (GHC.Types.IO ()))\n  arising from a use of `M2724311067105766041.show_M2724311067105766041'\n               at <interactive>:(2,0)-(4,30)\nPossible fix:\n  add an instance declaration for (GHC.Show.Show (GHC.Types.IO ()))"}])
14:26:54 <pumpkin> benmachine: I was born there :P and didn't know you at the time
14:26:58 <kmc> that's hint, not mueval
14:27:13 <benmachine> pumpkin: well that's hardly my fault is it :o
14:27:20 <pumpkin> benmachine: not mine either!
14:27:30 <benmachine> that's your story
14:27:40 <mjrosenb> kmc: hint?
14:27:47 <kmc> http://hackage.haskell.org/package/hint
14:28:09 <kmc> in re: the discussion with gwern and benmachine
14:28:09 <benmachine> gwern: why does mueval try to import Control.Monad.Cont?
14:28:13 <c_wraith> mueval is built on top of hint.  hint is built on top of the GHC api
14:28:28 <gwern> benmachine: presumably it's one of the default imports that was also default in lambdabot
14:28:41 <ddarius> > 0x1000000
14:28:42 <lambdabot>   16777216
14:28:57 * benmachine successfully makes mueval evalute 0
14:29:03 <gwern> why did someone in the past want to eval C.M.C exprs in lb? dunno
14:29:03 <benmachine> I can either import nothing or too much :(
14:29:09 <gwern> the past is a foreign country!
14:29:14 <benmachine> gwern: but where does it get that from, is it hardcoded?
14:29:27 <gwern> benmachine: sure
14:29:35 <gwern> hardcoded in Mueval.context, iirc
14:29:39 <benmachine> :(
14:29:57 <gwern> I beleive you can add modules via --module, but I don't think there's any --remove-module
14:30:14 <gwern> although maybe I made it so --module implied loading none of the whitelist
14:30:20 * gwern shrugs
14:30:31 <Saizan> benmachine: mueval -n -l Imports.hs
14:31:04 <benmachine> Saizan: oh, neat, thx
14:31:29 <benmachine> gwern: $ mueval -n -l Qualified.hs -e 'print ()'
14:31:29 <benmachine> No instance for (GHC.Show.Show (GHC.Types.IO ()))
14:31:46 <benmachine> 'swhat happens to me
14:31:49 <gwern> is that bad?
14:32:00 <benmachine> no it means that without the show it's still not doing any IO
14:32:30 <gwern> now, anyway
14:33:17 <benmachine> so the lb show instance is definitely not for security :P
14:33:29 <benmachine> though I guess it might have been once
14:35:43 <monochrom> show instance cannot add security. but it can add user-friendilness
14:35:56 <kmc> 09.09.14 14:35:48 <Cale> > print "hello"
14:35:56 <kmc> 09.09.14 14:35:49 <lambdabot>   No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
14:36:32 <monochrom> to add security you do less, such as omitting IO execution.
14:38:20 <malorie> would somebody care to give me some advice at what to improve? http://ideone.com/k2LGI
14:40:18 <Funktorsalat> hurr hurr, I think I shoehorned C# into expressing existential types...
14:40:20 <benmachine> malorie: I would write nand' = not . and'
14:40:33 <benmachine> malorie: oh wait, no wait I wouldn't
14:40:35 <benmachine> that doesn't work
14:40:40 <chrisdone> what are these funny secret messages that GHC has started spitting out sometime this year?
14:40:40 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
14:40:40 <chrisdone> λ> :load "Types.hs"
14:40:40 <chrisdone> [1 of 4] Compiling Data.Has.Nice    ( Data/Has/Nice.hs, interpreted )
14:40:40 <chrisdone> [4 of 4] Compiling Types      ( Types.hs, interpreted )
14:40:43 <chrisdone> mkUsageInfo: internal name? v{tv a6fju}
14:40:45 <Funktorsalat> say you have Foo<T> and want AnyFoo...
14:40:47 <chrisdone> did someone leave a rogue unsafePerformIO and the horrid word of Great Cthulhu is being injected?
14:40:51 <monochrom> It can't be improved. Unless we break the educational purpose and start writing "and' = (&&)" :)
14:40:52 <benmachine> malorie: ok but and' could be lazier
14:41:14 <chrisdone> @messages
14:41:14 <lambdabot> ddarius said 3h 59m 21s ago: When you click Preview on hpaste it unchecks the "Expire in an hour" box.
14:41:16 <Funktorsalat> abstract class FooEliminator<R> { abstract R Run<R,T>(Foo<T> foo); }
14:41:34 <Funktorsalat> interface AnyFoo { R RunEliminator<R>(FooEliminator<R> elim); }
14:42:06 <benmachine> malorie: if the first argument of and' is False, you don't need to look at the second to know what to output
14:42:18 <imanoob> kmc: thx for your help, i found, it's not a bug, but glut for haskell is poorly typed
14:42:23 <Funktorsalat> essentially I'm (ab)using the fact that methods can be universally quantified over a type parameter, and then doing the double dualization encoding of existentials ;)
14:43:05 <kmc> ok
14:43:11 <chrisdone> mkUsageInfo: internal name? R{'lyeh wgah'nagl fhtagn}
14:43:15 <chrisdone> these messages are getting more and more creepy
14:43:19 <kmc> imanoob, i don't really like GLUT.  i've used SDL to get OpenGL context and input, and it works all right
14:43:23 <Funktorsalat> (thank you haskell ;))
14:43:32 <benmachine> GLUT doesn't make sense on my system
14:43:33 <benmachine> at all
14:43:35 <benmachine> er
14:43:41 <benmachine> *doesn't work
14:43:45 * benmachine brainwires crossed
14:43:51 <chrisdone> works fine for moi
14:43:53 <imanoob> kmc: yes, but i don't see sdl in the haskell platform libraries (i didn't look closely)
14:43:58 <chrisdone> Funktorsalat: what's a dualization encoding?
14:44:09 <chrisdone> Funktorsalat: and what's a double dualization encoding?
14:44:14 <malorie> benmachine: heh
14:44:23 <benmachine> it's not even the haskell binding, all freeglut things die immediately
14:44:34 <Funktorsalat> chrisdone: I mean "exists a. Foo a" == "forall r. (forall a. Foo a -> r) -> r"
14:45:19 <Funktorsalat> chrisdone: "dual" as a loose analogy to e.g. the dual space of an R-vector space V, namely the linear maps V->R
14:45:28 <chrisdone> Funktorsalat: is "exists a." real syntax or pseudo code? I see it everywhere
14:45:32 <Funktorsalat> pseudo
14:45:55 <cleopatra> can someone tell me if its possible to create and save a txt file on the hard drive using haskell? hope this question is precise enough..
14:46:06 <benmachine> chrisdone: there is a non-GHC compiler that has an exists keyword
14:46:08 <benmachine> I forget which though
14:46:13 <Twey> cleopatra: Errrrr yes.
14:46:13 <imanoob> cleopatra: of course you can
14:46:14 <chrisdone> benmachine: ah, probably UHC
14:46:25 <chrisdone> they've got all the good stuff
14:46:27 <cleopatra> how?
14:46:38 <chrisdone> cleopatra: writeFile "myfile" "hello!"
14:47:06 <chrisdone> Funktorsalat: that's a bit over my head
14:47:09 <cleopatra> thanks, il give it a try
14:47:20 <fasta> chrisdone, do you mean there compiler actually compiles out of the box? ;)
14:47:33 <fasta> chrisdone, since a year ago it couldn't do that. 
14:47:45 <chrisdone> I think it still needs GHC, if that's whatya mean
14:47:50 <Baughn> cleopatra: "Can Haskell do X?" 'Yes!'
14:47:50 <chrisdone> anyone using this? http://hackage.haskell.org/package/has
14:47:53 <Baughn> clog: For all X.
14:48:03 <sipa> cleopatra: main = writeFile "myfile" "hello!"
14:48:09 <sipa> that single line in a source file
14:48:09 <fasta> chrisdone, no, I meant simply compiling even with GHC.
14:48:45 <Funktorsalat> chrisdone: just saying why I think of it as a "dualization"
14:48:55 <chrisdone> Funktorsalat: yeah
14:49:06 <tomh> hey guys where can I download ghc 6.10?
14:49:21 <Baughn> tomh: 6.10? Are you sure?
14:49:39 <Axman6> haskell.org/ghc should have it... but it's quite old
14:49:45 <Funktorsalat> there are various "dual" things in math, but the "dual" of some entity A is often some sort of function space A -> R (or a subset of that)
14:49:47 <chrisdone> fasta: oh, dunno; haven't tried it. they are working on making it compile more and more Hackage packages, apart from research they do now want to make it actually useful "in the real world" (re the latest Haskell Implementors talk), but I'd prefer the cool stuff from UHC just filter back into GHC
14:49:52 <tomh> Baughn, yes
14:50:01 <tomh> school requires it :>
14:50:06 <Baughn> tomh: As axy said, haskell.org/ghc, but we're up to 6.12.3 by now.
14:50:20 <FauxFaux> It's the first google result for "ghc 6.10", too.
14:50:28 <fasta> chrisdone, ah, that would be a big change.
14:50:34 <tomh> FauxFaux, I prefer to have it in haskell platform
14:50:48 <sipa> http://www.haskell.org/ghc/download_ghc_6_10_4.html
14:50:49 <tomh> the haskell platform page doesn't show an overview which ghc is used in which release
14:50:59 <fasta> chrisdone, also an unlikely change, because you cannot write papers about useful software.
14:51:13 <fasta> (just about new software that only works on paper)
14:51:16 <chrisdone> hehe
14:51:21 <chrisdone> unless you're Oleg
14:51:36 <chrisdone> in which case most of your stuff gets packaged onto Hackage within the day of publication
14:51:42 <fasta> Oleg mostly does it aside, right? 
14:51:43 <tommd> tomh: Fair point, but I'm not sure any HP release is old enough to include GHC 6.10.
14:52:08 <tomh> ah ok
14:52:22 <monochrom> haskell platform 2009.2.0.2 uses or includes 6.10.4.
14:52:24 <tommd> tomh: Very few programs work with 6.10 that don't work with 6.12 - I'd consider using 6.12 and saying heck with the schools arbitrary "requirement".
14:52:44 <tomh> we have to use the one library which doesn't work with 6.12 ;)
14:53:01 <tomh> two actually, multirec and emgm
14:53:02 <imanoob> teachers refuse to evolve
14:53:05 <chrisdone> I'm not sure. he's listed as maintainer for Takusen, for example, but whether he actually does maintain it I don't know. I like that his papers contain actual Haskell code instead of abstract pseudo-unicode Haskell-ish nonsense
14:53:18 <tomh> imanoob, has nothing to do with the teachers
14:53:35 <Twey> chrisdone: That's not pseudo-…
14:53:37 <chrisdone> technically UHC have an army of great Haskellers
14:53:41 <Heffalump> what's the school?
14:53:45 <monochrom> people write-protect their brains after their bachelor degrees.
14:53:47 <Twey> chrisdone: There's an extension you can turn on to make GHC interpret that.
14:53:48 <tomh> UU
14:53:49 <chrisdone> Twey: I meant pseudo-haskell and put unicode in there
14:54:01 <chrisdone> Twey: I know of unicode support, that's not what I meant
14:54:03 <Heffalump> figures :-)
14:54:04 <Twey> Oh alright.  :þ
14:54:06 <pumpkin> monochrom: I've tried to avoid that :(
14:55:32 <tomh> the libs don't work because of added restrictions to GADT's and types or so i'm told
14:55:38 <monochrom> if you see "λx → 4" in papers, you can't just copy that as haskell code. not even -XUnicodeWhatever will help. because of the λ
14:55:55 <Heffalump> it would just be a few more type signatures needed, most likely
14:56:06 <chrisdone> monochrom: I have a paper right here that has that
14:56:07 <Heffalump> though I guess those libraries probably push the envelope quite hard, so perhaps they really can't work
14:56:22 <tomh> its pretty advanced stuff :)
14:56:39 <monochrom> OTOH "∀x. Nat → x" would work
14:57:43 <pumpkin> monochrom: just use agda!
14:58:05 <monochrom> yeah, haskell is for newbies
14:58:15 <pumpkin> damn newbies
14:58:38 <monochrom> transitional step for those deep in c# and java and python and ruby
14:59:12 <chrisdon`> piece of crap italian connection
14:59:19 <chrisdon`> the internet in italy is a joke
14:59:47 <monochrom> perhaps it's time to say "well-ordered principle internet"
15:00:08 <fasta> chrisdon`: or are you just spoiled? ;)
15:00:33 <chrisdon`> no
15:00:37 <fasta> How bad is it?
15:00:41 <monochrom> in soviet russia, the internet thinks you are a joke
15:01:17 <fasta> You can always become a radio amateur and get access in that way.
15:01:22 <pumpkin> chrisdon`: yeah
15:01:27 <monochrom> it is so bad he can't answer before another disconnection
15:01:30 <fasta> Could be a bit slow, though ;)
15:01:41 <fasta> monochrom, that was his other presence.
15:01:41 <chrisdon`> apart from the random disconnecting, random slowdowns and filtering of the pirate bay (~_~), it "works"
15:01:51 <monochrom> I'm just joking
15:01:53 <pumpkin> where my parents live, until earlier this year ISDN was the only option, so we got a 3g dongle
15:02:32 <pumpkin> and the 3g dongle sucks too, of course
15:02:32 <fasta> chrisdon`, but you can get around filtering trivially.
15:02:39 <pumpkin> finally got adsl, but that sucks too
15:02:41 <chrisdon`> I suspect the existing broadband lines are being pushed beyond their capacity
15:02:55 <kmc> chrisdon`, when i was in italy they made me give ID to use an Internet café
15:03:19 <fasta> kmc, Mussolini would be proud.
15:03:22 <pumpkin> yeah
15:03:27 <monochrom> hahaha
15:03:32 <pumpkin> they also block sites like thepiratebay and foreign gambling sites
15:03:33 <kmc> does that count as godwin?
15:03:33 <chrisdon`> kmc: there are a few free wireless internet providers here
15:03:39 <pumpkin> the great firewall of italy
15:03:48 <chrisdon`> in the city, at least. that's at least good intention
15:03:57 <monochrom> the great adequctwall of rome
15:04:02 <pumpkin> :P
15:04:44 <monochrom> mentioning mussolini may count as godwino --- italianized godwin
15:05:04 <pumpkin> goduino
15:05:09 <pumpkin> (no W)
15:05:14 <monochrom> thanks
15:05:42 <kmc> goduino -- the Christian-themed microcontroller development board
15:05:45 <chrisdon`> there's a great old picture of a woman with some text underneath it in the town, the text saying something about giving our lives for the good of the nation, etc. amusingly, they scratch out a word. rather than getting rid of this horrible sentiment, they just removed the word "Mussolini" :p
15:06:02 <kmc> weeduino.com — the internet's #1 stoner-oriented electronics hobby site
15:06:19 <chrisdon`> pumpkin: haha, goduino
15:06:20 <fasta> I had the impression that Mussolini was a bit of an idiot when compared to some of the military people that Hitler controlled. 
15:06:32 <pumpkin> lots of people here still idolize him
15:06:37 <pumpkin> but this seems more suited for -blah
15:06:48 <gwern> fasta: no one reminsces about mussolini's campaigns, that is true
15:06:50 <chrisdon`> the Has library is pretty nice
15:08:10 <chrisdon`> I have 20 record types and managing field conflicts was a pain, but not anymore! polymorphic fields for all!
15:08:44 <chrisdon`> what's the word on getting a decent extensible record system into GHC or Haskell 2011?
15:08:51 <pumpkin> chrisdon`: not gonna happen
15:08:57 <chrisdon`> or is the bikeshed debate still raging or simmering?
15:09:01 <kmc> anyone have opinions on Trex, the Hugs record system that's existed since forever?
15:09:04 <pumpkin> unless someone comes up with an excellent proposal and an implementation in time
15:09:09 <chrisdon`> kmc: I think it's brilliant
15:09:49 <Heffalump> chrisdon`: Haskell 2011, no chance.
15:09:56 <ddarius> dip is such an awesome combinator, X [P] dip = P X
15:10:08 <chrisdon`> Has and Haskelldb's records are the same vein, i.e. constructing records arbitrarily, the type reflecting what's in the record, etc.
15:10:12 <Heffalump> Haskell 2011 is going to be a very small change over Haskell 2010 as things stand at the moment (only one proposal at all)
15:10:17 <monochrom> I think Trex is good.
15:11:02 <chrisdon`> Heffalump: sure. 2010 was terribly underwhelming as a ten-year "overhaul", I don't expect one year to change anything that I'll care about
15:11:13 <chrisdon`> I only really care about GHC extensions tbh
15:11:25 <monochrom> this is the reason behind all my "haskell 2038" jokes
15:11:34 <Heffalump> I don't think anything would happen in GHC without someone outside the current GHC team doing it.
15:11:48 <pumpkin> yeah, we need to get more GHC contributors
15:12:03 <Heffalump> it's a knotty problem and probably not much research left in it
15:12:07 <chrisdon`> SPJ offered to implement something a few years ago. he asked on the mailing list but I think it was met with too mixed responses
15:12:30 <c_wraith> see, his problem was asking the mailing list instead of just doing it
15:12:36 <monochrom> heh
15:12:43 <ddarius> chrisdon`: 2010 was meant to be underwhelming.  2011 was not.
15:12:46 <chrisdon`> c_wraith: that's been my experience too
15:12:58 <benmachine> ddarius: 2011 was supposed to be exciting?
15:12:59 <gwern> we were supposed to get something in 2011?
15:13:15 <Heffalump> people should have proposed stuff if they wanted 2011 to be exciting :-)
15:13:19 <c_wraith> Honestly, someone needs to get top-level IO into GHC one of these days.  That would be really nice.
15:13:29 <c_wraith> JHC's top-level IO seems to work just fine.
15:13:32 <chrisdon`> what's top-level IO?
15:13:49 <monochrom> such as creating global IORefs?
15:13:52 <c_wraith> yeah
15:13:54 <benmachine> ACIO
15:14:00 <Axman6> that would be handy
15:14:02 <chrisdon`> ah, with some assurances, I suppose?
15:14:06 <benmachine> no-one's quite sure what the Affine bit is for
15:14:08 <gwern> c_wraith: no one uses jhc, so how do we know it works...
15:14:14 <benmachine> chrisdon`: yeah, it's got its own type
15:14:18 <kmc> i care about cool extensions from other implementations 
15:14:20 <ddarius> 2010 was like the beta of the new Haskell standards process.  2011 was supposed to be "for real."
15:14:21 <kmc> because i wish we had them in GHC
15:14:28 <chrisdon`> as opposed to {-# NOINLINE DON'T RUN THIS TWICE OR BREAK IT #-} x = unsafePerformIO newIORef ..
15:14:34 <Heffalump> nonononono!
15:14:40 <Heffalump> top-level IO is evil
15:14:46 <c_wraith> exactly.  That hack works, but it's painful.
15:14:58 <chrisdon`> personally I've never needed that
15:15:04 <Heffalump> blessing it in the language is even eviller than that hack
15:15:10 <pumpkin> I've never needed it either
15:15:14 <ddarius> benmachine: The point of "affine" was that the meaning of the program shouldn't change if the action is not executed at all.
15:15:18 <chrisdon`> but I've heard there are cases where it makes sense
15:15:20 <c_wraith> It's not a frequent need, but when you need it, there is no substitute.
15:15:25 <benmachine> Heffalump: you restrict it only to actions that are independent of execution time, e.g. newIORef
15:15:28 <monochrom> <monochrom> global IORefs
15:15:35 <Heffalump> c_wraith: there is, use implicit parameters
15:15:38 <benmachine> ddarius: oh, ok
15:15:55 <Heffalump> to pass down the IORef, that is
15:15:58 <chrisdon`> ddarius: ah, okay. that sounds good
15:16:12 <ddarius> I'm not a fan of the ACIO proposal.
15:16:33 <chrisdon`> sorry, I didn't see you said another message. I mean the out-of-beta 2011 sounds good
15:17:01 <ddarius> chrisdon`: From what Heffalump is saying, it sounds like user training is required.
15:17:29 <benmachine> I saw someone present several reasonable ideas why global variables were sometimes necessary
15:17:37 <chrisdon`> ddarius: are you talking to me about ACIO?
15:17:46 <c_wraith> Heffalump, does that work from unrelated parts of the program?
15:17:50 <pumpkin> benmachine: I haven't, really
15:17:51 <hpc> globals make threading ugly
15:17:58 <Heffalump> c_wraith: what do you mean by unrelated?
15:18:19 <pumpkin> benmachine: have a pseudoglobal ST-like thing custom monad that gives you access to your global state
15:18:19 <chrisdon`> I'm interested in seeing this programs where globals are necessary
15:18:24 <Heffalump> if you want global variables, you have to consider what scope they're global in
15:18:32 <chrisdon`> I imagine it's to do with squeezing out speed
15:18:33 <Heffalump> the process? The machine? The library?
15:19:08 <sipa> Heffalump: the world, obviously!
15:19:30 <monochrom> System.Environment is a lot of global IORefs
15:19:34 <c_wraith> Well, the case I'm thinking of isn't such a big deal after GHC 7, when it's not so bad to open arbitrary numbers of file descriptors.
15:19:50 <c_wraith> Though I guess you can still hit the OS limit.
15:20:19 <gwern> chrisdon`: there are usecases for globals
15:20:27 <chrisdon`> speaking of IO abuse, this week I saw this:
15:20:27 <chrisdon`> case (unsafePerformIO $ runIn handle (interpret s (as :: Rule))) of
15:20:28 <kmc> chrisdon`, locking a thread-unsafe FFI library
15:20:32 <kmc> needs a global MVar
15:20:43 <gwern> chrisdon`: for example, my archiver package is a use-case, but I foisted the problem onto users of it
15:21:03 <chrisdon`> kmc: why?
15:21:21 <kmc> your calls into the lib need to synchronize with each other
15:21:24 <gwern> except the issue with archiver is getting your IP banned for too many requests, which is similar but not the same as being thread-unsafe :)
15:21:34 <kmc> it's not "global" in the sense of being in scope everywhere
15:21:42 <Heffalump> foisting the problem on users is the right solution, and implicit parameters makes that farily lightweight
15:21:43 <kmc> but all the code which uses that library must be manipulating the same MVar
15:22:37 <c_wraith> Is there *really* a sane way to write this without a global Handle?  http://hpaste.org/40458/urandom
15:22:46 <chrisdon`> I'm agreeing with Heffalump here
15:23:12 <c_wraith> Opening it again on every call to getURandomGen is *not* correct, from a performance perspective
15:23:23 <c_wraith> as well as a resource use perspective
15:23:23 <chrisdon`> withLibrary $ ... seems straight-forward enough with a "don't run this twice" message
15:24:07 <hpc> it is probably possible to have a type for globals
15:24:21 <hpc> so instead of saying handle :: Handle, it is handle :: Global Handle
15:24:23 <kmc> chrisdon`, what if my code uses library L and also some library A which uses L?
15:24:45 <monochrom> withA $ \a -> withL $ \l -> ...
15:24:46 <hpc> and let Global control initialization, possibly as a GHC hack if necessary
15:24:53 <chrisdon`> kmc: hmm, not sure
15:24:58 <benmachine> given that people can write state to e.g. files and read it, there isn't really any difference with allowing the same to happen with memory
15:25:02 <benmachine> right?
15:25:17 <sipa> i'm sure there are humans that fail the turing test
15:25:24 <Heffalump> benmachine: writing state to files gives you per-machine scope for your globals
15:25:36 <monochrom> there may be some limitations in the "withA $ \a -> withL $ \l -> ..." scheme
15:25:47 <chrisdon`> monochrom: yeah, kmc's example
15:25:52 <Heffalump> there was a long discussion about this on haskell-cafe a couple of years back, btw
15:26:02 <benmachine> Heffalump: yeah I'm poking about on the wiki
15:26:04 <Heffalump> kmc: you shouldn't discharge the global requirement in your libraries
15:26:06 <kmc> it forces A to expose the fact that it uses L and to complicate its API just on the off chance that one of its uses will need to use L too
15:26:15 <chrisdon`> there was a long discussion on everything on Haskell-Cafe a couple years back :p
15:26:15 <monochrom> ah, I now read that properly. diamond dependency.
15:26:27 <Heffalump> kmc: which is the right solution. The use of L is part of the type of A.
15:26:27 <c_wraith> I mean, I worked hard to provide referential transparency with that code.  The fact that it's forced to use unsafePerformIO is unfortunate.
15:26:41 <kmc> so we lose a ton of modularity then
15:26:53 <kmc> every user of a library has to care about lots of that library's implementation details
15:27:00 <monochrom> how do you do singletons?
15:27:18 <chrisdon`> monochrom: a global mvar?
15:27:35 <monochrom> yeah, need some global IO then.
15:27:38 <Heffalump> because those implementation details are actually externally visible
15:27:46 * hackagebot cuda 0.2.2 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.2.2 (TrevorMcDonell)
15:27:51 <chrisdon`> (for this problem, at least. otherwise you can just keep passing it back to the library...)
15:28:03 <kmc> Heffalump, everything's externally visible until you hide it
15:28:17 <kmc> top-level IO lets us hide certain kinds of details
15:28:30 <Heffalump> you still haven't defined what "top-level" is
15:28:33 <kmc> thus allowing us to provide simpler, cleaner, less error-prone APIs
15:28:42 <chrisdon`> c_wraith: heh, I also have a URandom module
15:28:42 <Heffalump> what scope is the top-level?
15:28:55 <kmc> Heffalump, for the purposes of this discussion, I will consider JHC's ACIO
15:29:23 <kmc> the scope is module scope
15:29:26 <chrisdon`> c_wraith: http://hpaste.org/paste/40458/my_urandom#p40459 I guess mine is slower :p
15:29:34 <Heffalump> I mean what runtime scope, not what static scope
15:29:50 <kmc> i don't understand the question
15:30:11 <Heffalump> presumably you don't intend this global to be created only once in the entire universe?
15:30:19 <kmc> once per program invocation
15:30:19 <monochrom> perhaps runtime scope means lifetime. perhaps the answer is "done before main starts"
15:30:38 <Heffalump> ok. So now how do you implement that if your haskell code is in a DLL?
15:30:51 <kmc> oh, i didn't say we're looking for an easy implementation ;)
15:31:00 <kmc> anyway most linkers do provide a way to deal with this
15:31:01 <monochrom> eh? DLL has deliberate per-process init() no?
15:31:10 <kmc> it comes up in C++ code, it's a bit of a mess there but can be dealt with, and better in Haskell
15:31:10 <Heffalump> monochrom: not if unloaded and reloaded
15:31:20 <c_wraith> chrisdon`, yours is also only seeding from urandom.  Mine is actually using urandom instead of a stdgen
15:31:27 <kmc> a top-level ACIO action executes either "on init" or "on demand". this, as well as the order between modules, is unspecified,  which is why ACIO restricts what you can do ("affine central")
15:31:47 * hackagebot libpq 0.4.0 - libpq binding for Haskell  http://hackage.haskell.org/package/libpq-0.4.0 (GrantMonroe)
15:31:49 <Heffalump> kmc: I don't care about when it first executes. I care about when it might *second* execute.
15:32:00 <kmc> Heffalump, never again in that process's lifetime
15:32:18 <Heffalump> but that's unimplementable for plugins etc
15:32:24 <chrisdon`> c_wraith: I'm not educated in probability, does yours provide more randomness?
15:32:48 <kmc> Heffalump, ok, then you have to introduce a notion of module loading/unloading
15:32:52 <kmc> i mean
15:33:02 <kmc> when you use a module that has the unsafePerformIO global MVar trick via plugins
15:33:02 <c_wraith> chrisdon`, well, it's not a state machine.  it continually draws entropy from the environment.  StdGen does not.
15:33:03 <kmc> it does something
15:33:08 <kmc> ACIO could do the same thing
15:33:20 <Heffalump> I don't follow that.
15:33:26 <kmc> it's basically a question of how the RTS handles CAFs in dynamically linked code
15:33:44 <Heffalump> ok, and how should it handle them?
15:33:50 <kmc> i'm not sure
15:33:53 <chrisdon`> c_wraith: ah, I see
15:33:56 <kmc> i just don't think this question dooms the entire exercise
15:34:02 <kmc> it should be discussed etc.
15:34:25 <Heffalump> I'm sure that in practice some hack can be arranged. But the necessity is evidence that the proposal is messy.
15:34:43 <kmc> but, something like this exists in many other languages, and has been implemented (without plugins) in JHC, and can be "mocked up" using the uPIO trick
15:35:02 <kmc> the uPIO trick is a reality of Haskell code today, it's used everywhere; ACIO is not going to be worse than that
15:35:37 <kmc> having the correctness of your code depend on a {-# NOINLINE #-} pragma is really bad
15:36:25 <c_wraith> technically, my code is correct with or without the NOINLINE.  It just loses resource use guarantees without it.
15:36:37 <Heffalump> adding a notion of process to the fundamental language semantics is really bad too
15:36:41 <c_wraith> sure, open the file 200 times, it's fine. :)
15:37:17 <kmc> Heffalump, perhaps we should consider ACIO outside the "fundamental language semantics" then.  certainly uPIO on newIORef and NOINLINE are
15:37:31 <Heffalump> so then keep NOINLINE
15:38:05 <kmc> this is frustrating
15:38:16 <kmc> i'm arguing for harm reduction; you're arguing that there's still some harm so why bother trying to reduce it?
15:38:18 <Heffalump> btw, a concrete example: darcs uses globals for various things and that makes it hard to use it as a library
15:38:43 <Heffalump> I want it kept as a hack so people are discouraged from using it at all.
15:38:52 <kmc> right
15:39:04 <kmc> i want heroin users to have AIDS so people won't use heroin
15:39:17 <kmc> great reasoning
15:39:32 <kmc> we can have ACIO trigger a warning in GHC if you like
15:39:56 <c_wraith> Heffalump, I'd much rather have something with the same semantics as the hack currently has, but with the guarantee that those semantics will be preserved.
15:40:11 <Heffalump> what semantics does the hack have?
15:40:36 <c_wraith> single execution, executed on the first demand for it
15:40:44 <Heffalump> in what scope?
15:40:48 <Heffalump> </broken record>
15:41:04 <Heffalump> also,what happens if you end up linking against two different versions of the library that defines the variable?
15:41:05 <c_wraith> except it actually lacks the single execution guarantee in the case of the threaded runtime, so it'd be nice to have that actually *guaranteed*
15:41:11 * monochrom 's law: every discussion eventually mentions "semantics"
15:41:16 <c_wraith> Heffalump: each uses their own copy.  it's fine.
15:41:34 <Heffalump> it's not fine if the point of the global is to guard access to some unsafe FFI library
15:42:12 <c_wraith> If you're linking two different versions of the same unsafe FFI library, you've got problems no matter what.
15:42:26 <Heffalump> no, you're linking two different versions of a Haskell wrapper
15:42:37 <Heffalump> only one copy of the FFI library underneath
15:43:21 <c_wraith> looks like I'm arguing package scope.  As it's the scope that everything else in haskell works at, anyway.
15:43:37 <Heffalump> packages aren't in the language standard either :-)
15:43:45 <c_wraith> err, yes.  in GHC, not haskell
15:44:29 <Heffalump> ok, so you want package scope and kmc wants program scope :-)
15:44:37 <kmc> whatever
15:44:43 <kmc> like i said, it can be discussed and agreed on
15:44:47 <kmc> i'm not saying it's an easy question
15:46:29 <Heffalump> and I'm saying it's a question that has no good answer
15:46:42 <imc> mumbling.... some existential problems....
15:46:58 <c_wraith> But it has better answers than the current one.
15:47:08 <c_wraith> So make them available
15:47:23 <Heffalump> I've given you a better answer :-) Use implicit parameters to make the scope explicit.
15:47:29 <imc> let's say i have a parametric data, i.e. data Status x, i would to write a class like "class StatusClass Status x" ..
15:48:17 <imc> is it possible?
15:48:22 <c_wraith> heffalump: how would that not massively uglify my example for no practical gain?
15:49:15 <Heffalump> it would allow you to precisely delimit the scope in which a fresh handle was opened
15:49:18 <c_wraith> imc: It's really unclear what you want.  The answer is almost certainly yes, but it looks like you're trying to do two things at once that need to be separate
15:49:21 <imc> for now i've wrote the class as "class StatusClass x" but then i should be able to write something like "instance StatusClass Status x"
15:49:35 <c_wraith> Heffalump, aka "needless busywork for people using the library"?
15:50:02 <monochrom> class StatusClass s? instance StatusClass (Status)? instance StatusClass (Status x)?
15:50:25 <imc> c_wraith: 1) parametric data, 2) class with knoweledge of the parameter of the parametric data, 3) instance of parametric data for that class
15:50:26 * monochrom thinks you use "x" too many times
15:50:56 <Heffalump> I don't agree it's needless busywork, obviously.
15:51:12 <imc> monochrom: ?
15:51:23 <sipa> imc: class StatusClass x; instance StatusClass (Status x)
15:51:48 <imc> sipa: the problem is that inside status class i need to know the parameter to the data
15:51:55 <imc> for the signatures
15:52:04 <c_wraith> In my case, it is.  No matter how many times you open it, it's going to be the same thing: A source of entropy.  Why would you ever want to make it possible for the user of the library to get it wrong?
15:52:24 <sipa> imc: yes, x?
15:52:47 <imc> sipa: not really x would be i.e. data Status s
15:53:08 <imc> while inside StatusClass x i should know the parameter given to x
15:53:14 <imc> (not possible i suppose)
15:53:23 <sipa> just write the class over x
15:53:31 <sipa> not over (Status x)
15:53:45 <sipa> but in your class, you can have functions with types referring to (Status x)
15:54:06 <imc> sipa: and also to x ??
15:54:17 <sipa> can you be a bit more specific?
15:54:21 <imc> right
15:54:23 <monochrom> multiple parameter type class?  class StatusClass s a?  instance StatusClass (Status x) x?
15:54:33 <imc> monochrom: for example yes
15:54:43 <monochrom> you can already do that now.
15:54:52 <sipa> monochrom: i think he doesn't even need that
15:54:55 <monochrom> maybe class StatusClass s a | s->a
15:55:02 <Heffalump> c_wraith: but they can "get it wrong" and not even know, if there are multiple copies of your library loaded
15:55:17 <monochrom> well it's clearly totally unclear what he needs. all these overloadings of "x" doesn't help.
15:55:22 <c_wraith> Heffalump: that's not *wrong* in my case, it's just more wasteful of resources than necessary.
15:55:34 <EvanR> unclearly clear
15:56:06 <Heffalump> then how can the user get it wrong at all?
15:56:17 <monochrom> may as well write a bedtime story like "once upon a time there are two good friends. one day he visits him in the morning..."
15:56:33 <c_wraith> Pointing the handle at... any other file, really.
15:56:36 <imc> sipa: http://pastebin.com/Uez9V1Lm
15:57:25 <sipa> on line 10, remove 'Status'
15:57:33 <sipa> and on line 18 too
15:57:46 <sipa> and i think you're done
15:58:05 <imc> sipa: you don't get the point
15:58:07 <ddarius> c_wraith: As far as I can tell, the only reason you are doing this "global Handle" thing is to "save a file handle" for between different invokations of getURandomGen.
15:58:07 <Heffalump> you'd wrap it in an abstract type that only your library could create (though I guess then multiple versions would be a problem anyway, but at least it'd be clear to the user)
15:58:14 <sipa> imc: i think i do
15:58:26 <c_wraith> Heh.  Maybe this is a case for zero-parameter type classes. :)
15:58:30 <ddarius> s/for//
15:58:45 <Heffalump> that's sort of what an implicit parameter is
15:58:45 <imc> sipa: do you think that "invalid :: (s x) -> x -> (s x) === invalid :: x -> x -> x" ??
15:58:50 <c_wraith> ddarius, yes.  It's so that file handles don't get exhausted, as they are a very limited resource.
15:58:58 <sipa> imc: no
15:59:12 <imc> so how do i wrate that signature if i remove "Status" on line 10 ?
15:59:21 <sipa> imc: just leave it there
15:59:29 <sipa> only remove 'Status on lines 10 and 18
15:59:30 <imc> O_o ?
15:59:38 <sipa> imc: the type class is over type x
15:59:56 <imc> the implementation of (|^) will be correct then?
15:59:57 <sipa> but that doesn't prevent it from having function types that refer to both x and Status x
16:00:08 <Heffalump> also, if they're such a limited resource, surely you want the end-user to control when they are closed?
16:00:12 <imc> right, so the other Status i leave
16:00:19 <sipa> yes, just try
16:00:27 <imc> got it
16:00:37 <imc> i felt i was close :)
16:01:02 <EvanR> is there a string predicate 'consists totally of whitespace'
16:01:05 <c_wraith> Heffalump, not really.  1 isn't a big deal.  The ability to exhaust them with a trivial loop, however, is.
16:01:21 <sipa> imc: the other (much harder) possibility would be to write the class over (Status x), and use an associated type to map Status x back to x
16:01:22 <c_wraith> :t all isWhiteSpace
16:01:23 <lambdabot> Not in scope: `isWhiteSpace'
16:01:32 <tommd> :i isSpace
16:01:33 <c_wraith> eh, whatever that function from Data.Char is
16:01:37 <monochrom> sipa probably means http://pastebin.com/HZJAq54s
16:01:37 <ddarius> c_wraith: I can see several solutions.  You can simply document that in the interface as "newStdGen" isn't a terribly common thing.  Next, you can (in addition) have a version that takes a (wrapped) handle.  Third, you can simply close and reopen the handle in the unsafeInterleaveIO'd code.
16:01:38 <tommd> :t isSpace
16:01:39 <lambdabot> Char -> Bool
16:01:56 <sipa> monochrom: yes
16:02:03 <c_wraith> :t all isSpace
16:02:04 <lambdabot> [Char] -> Bool
16:02:10 <Heffalump> with the implicit parameter solution, you'd close it when the parameter went out of scope (using the withLibrary wrapper)
16:02:12 <EvanR> nice
16:02:13 <ninly> n00b question -- in the bookstore today, disappointed to find no haskell books, so i picked up a nearby F# book and read the introduction. it referred to haskell and a few others as "FP-like languages". is this just sword-rattling from the .NET faction, or is there a syntax or other technical distinction i don't know about?
16:02:19 <EvanR> @src all
16:02:19 <lambdabot> all p =  and . map p
16:02:19 <monochrom> I misspelled FlexibleInstances
16:02:22 <ddarius> c_wraith: A loop of reloading modules (like, say, lambdabot does/did) will leak, as you mentioned earlier.  However, if you take Heffalump's advice this wouldn't be a problem.
16:02:29 <EvanR> @src and
16:02:29 <lambdabot> and   =  foldr (&&) True
16:02:42 <imc> sipa: class Status_ used as a type (line 11)
16:02:50 <c_wraith> ddarius, except it would leak the abstraction to the user.  That's not very nice.
16:02:51 <tommd> ninly: Probably just poor organization.
16:02:58 <monochrom> Oh, darn.
16:03:00 <imc> should better use Status here
16:03:06 <ninly> tommd: on the author's part?
16:03:11 <ddarius> c_wraith: Not really.
16:03:14 <imc> oh no....
16:03:17 <Heffalump> the abstraction is already leaky. I'm saying you should expose that in the type system.
16:03:30 <sipa> imc: that would be Status, not Status_
16:03:37 <monochrom> http://pastebin.com/sYe1xvFN  and I still misspell FlexibleInstances
16:03:43 <sipa> Status is the data type, Status_ the class
16:03:47 <imc> sipa: but the instance Status_ Status would be for what? 
16:03:49 <monochrom> Status_ is my typo
16:03:52 <ddarius> c_wraith: As I, and Heffalump said, you can certainly encapsulate the handles so you don't need to worry about getting the wrong one.  And as I and Heffalump just said, your abstraction is already leaking.
16:03:58 * imc is confused
16:04:08 <sipa> imc: let me change your code to what i mean
16:04:15 <Saizan> ninly: you're wondering why it said FP-like rather than just FP?
16:04:19 <imc> i would be grateful
16:04:20 <ninly> yes
16:04:52 <pumpkin> implicit parameters are the devil
16:04:56 <pumpkin> ^Heffalump
16:04:56 <pumpkin> :P
16:05:04 <Heffalump> better than global state..
16:05:12 <pumpkin> if they behaved the way I'd expect them to, I'd like them more
16:05:15 * Heffalump thinks implicit parameters are fine if not used recursivel
16:05:15 <Heffalump> y
16:05:23 <Heffalump> though it'd be nice if they had namespaces
16:05:34 <monochrom> huh? why doesn't pastebin.com remember my preference about expiration? when it can remember my name.
16:05:39 <pumpkin> I want to be able to have a withImplicit :: ((?x :: Int) => a) -> ...
16:05:41 <ddarius> It's not even necessary to use implicit parameters.
16:05:41 <ninly> wiki, lyah, etc. all refer to haskell as "purely functional" (which i know has a technical meaning), but i'm not sure what the distinction is there, with "FP-like"
16:05:43 <pumpkin> something along those lines
16:05:56 <pumpkin> ddarius: you talking about the reify hack?
16:06:00 <ddarius> No.
16:06:08 <sipa> imc: do you need a type class, even?
16:06:15 <ddarius> There is nothing (more) that needs to be "passed around".
16:06:17 <Heffalump> pumpkin: why can't you?
16:06:23 <imc> got it right
16:06:30 <Saizan> ninly: "Functional Programming" as any other paradigm is quite loosely described, so maybe that's where the -like came from, to prevent people from arguing over the correctness of the list
16:06:30 <pumpkin> Heffalump: have you tried it? I wasn't able to make it behave that way
16:06:31 <EvanR> ninly: evaluating expressions cant have side effects
16:06:38 <imc> sipa: dunno really, but now it compiles fine
16:06:39 <EvanR> in haskell
16:06:51 <c_wraith> ninly: I'd agree with Saizan's guess
16:06:52 <pumpkin> Heffalump: having said that, I tried it when I was first learning haskell, so I may not have been very good at it :)
16:06:53 <EvanR> including 'function calls'
16:07:16 <imc> sipa: let me exercice a little :)
16:07:24 <pumpkin> Heffalump: the idea is to save the previous value of the implicit and restore it after the block
16:07:34 <Heffalump> oh, I see
16:07:37 <Heffalump> that might be harder
16:07:50 <Heffalump> I thought you just wanted to discharge the requirement
16:07:55 <pumpkin> ah no
16:07:58 <ninly> the side-effects thing i understand (the tech sense of "purely functional") but the list in that book, of "FP-like" was presented separately from other languages discussed. which, i think i agree, was just confusing organization.
16:08:08 <sipa> imc: http://pastebin.com/wnpyqdS2
16:08:10 <pumpkin> I just want to be able to pass an implicit in without using a let explicitly, really
16:08:14 <monochrom> beware of premature abstraction. I mean this: for instance, if you think you desire a type class, have 2 to infinitely many instances ready, so it is clear what is there to abstract way.
16:08:16 <pumpkin> "more composable"
16:08:23 <Heffalump> but none of the uses for "globals" could need that
16:08:30 <pumpkin> oh yeah, probably not
16:08:34 <EvanR> ninly: lisp, js, ocaml ?
16:08:52 <imc> sipa: we got the same result :P
16:08:58 <ninly> EvanR: i think ocaml was in the list with haskell
16:09:05 <sipa> you could even remove the type definitions, imc
16:09:08 <ninly> lisp had already been discussed as the first.
16:09:11 <Heffalump> I vaguely want to replace the globals in darcs with implicit parameters, but noone will let me :-)
16:09:19 <pumpkin> aw
16:09:23 <pumpkin> globals are the devil!
16:09:32 <pumpkin> exorcism is needed
16:09:45 <monochrom> stop global warming now
16:09:45 <EvanR> haskell has globals? next will be goto ;)
16:09:57 <imc> sipa: just plain functions?
16:10:00 <c_wraith> we have GotoT.  isn't that good enough?
16:10:13 <monochrom> also abortT
16:10:17 <sipa> imc: the types will be derived automatically
16:10:26 <monochrom> presumably soon there will be resumeT to go with abortT
16:10:34 <sipa> imc: drop lines 9-13
16:10:44 <sipa> EvanR: the next step will be an assignment operator
16:11:12 <imc> sipa: ?
16:11:13 <monochrom> -XTypeDrivenStringParsing
16:11:15 <EvanR> foo `writeIORef` bar ;)
16:11:20 <sipa> imc: sorry, the correct terminology is 'inferred', not 'derived'
16:11:24 <sipa> imc: try it
16:11:48 <imc> sipa: 9:16: parse error on input `::
16:11:58 <imc> sure you really meant 9-13 ?
16:12:31 <sipa> imc: i mean this: http://pastebin.com/WNCgDTG3
16:13:32 <imc> ok
16:13:43 <imc> thank you
16:14:08 <sipa> yw :)
16:14:22 <sipa> you understand why the type class wasnt' necessary?
16:14:44 <fasta> sipa, you can say both. 
16:15:26 <sipa> fasta: >
16:15:31 <sipa> ?
16:15:32 <fasta> sipa, inferring and deriving is the same thing. 
16:15:37 <monochrom> -XTypeDrivenStringParsing enables "True" || False to be True, for example
16:15:51 * ddarius needs to figure out a way of making errors involving i more debuggable.
16:16:09 <ninly> thanks, all (re: the FP-like thing)
16:16:26 <sipa> fasta: yes, but deriving in haskell context is used for auto-generated class instances, so can be confusing
16:16:55 <fasta> sipa, that's the deriving keyword or extension.
16:17:07 <sipa> yes
16:17:18 <EvanR> isnt functional programming a lot more well defined than other similarly marketting buzzphrases
16:17:20 <fasta> sipa, so, there was nothing wrong with the terminology. 
16:17:24 <EvanR> marketted
16:17:30 <sipa> fasta: what i says was correct english, it just may be confusing
16:18:16 <imc> sipa: yes i understand
16:18:22 <fasta> sipa, your English may have been correct, but your correction was not a correction, that's all I wanted to say. 
16:18:34 <hirsch> isn't it possible to use the value constructor of the basetype of a type declaration?
16:18:38 <sipa> fasta: fair enough :)
16:18:44 <ddarius> EvanR: It could be, but it isn't in practice.
16:18:58 <sipa> call it an improvement instead of a correction :)
16:19:02 <Heffalump> ddarius: i?
16:19:04 <hirsch> data Point a = Point (x, y)
16:19:08 <fasta> monochrom, that extention is going to be relased on 01-04-2011?
16:19:14 <fasta> released*
16:19:19 <hirsch> type MyPoint = Point Double
16:19:22 <fasta> extension*
16:19:57 <Heffalump> monochrom: can't you get that with OverloadedStrings and OverlappingInstances?
16:19:59 <hirsch> but I can't use the MyPoint type with the Point constructor
16:20:14 <EvanR> data Point a = Point (a,a) ?
16:20:34 <sipa> fasta: yes, together with -XPerlLikePatterns, -XInlineX86Assembly, -XForgetLazyness and -XNoStaticTypes
16:20:46 <hirsch> EvanR: äh, yes, that's what I meant
16:21:22 <EvanR> whats wrong with type MyPoint = Point Double then, error?
16:21:27 <fasta> sipa, we already have all of those :D
16:21:43 <sipa> ok :(
16:21:44 <fasta> sipa, all of them in libraries or as GHC extensions.
16:21:48 <hirsch> EvanR: I can't write MyPont (5,5)
16:21:57 <EvanR> MyPoint isnt a constructor
16:22:17 <EvanR> only a type
16:22:23 <hirsch> EvanR: hmm, that's unconvenient
16:22:27 <hirsch> ;-)
16:22:30 <Heffalump> http://hpaste.org/40460
16:22:42 <EvanR> define myPoint = Point
16:22:43 <sipa> fasta: no way you can disable static types in Haskell :)
16:22:50 <EvanR> myPoint (5,5)
16:23:09 <hirsch> EvanR: define? Never heard about that
16:23:11 <EvanR> do people actually use 'my' stuff?
16:23:20 <fasta> sipa, Data.Dynamic basically does that.
16:23:31 <ddarius> Heffalump: [P] i = P, a combinator in Joy.
16:23:43 <EvanR> hirsch: i told you to do that
16:23:45 <EvanR> like
16:23:48 <EvanR> type rm -rf /
16:24:23 <EvanR> dont actually type type
16:25:00 <hirsch> EvanR: ah, ok. I need a new type with the Point behaviour but specialized to the Double Type
16:25:14 <EvanR> a truly new type
16:25:31 <EvanR> newtype MyPoint = MyPoint (Point Double)
16:25:32 <hirsch> EvanR: a specialization
16:25:42 <EvanR> whats a specialization?
16:26:08 <hirsch> EvanR: sry, OO terminus
16:26:23 <EvanR> determine what requires your Points to be double
16:26:39 <EvanR> probably you want a Floating or a Num or something instead
16:26:52 <EvanR> then no need to make a MyPoint
16:27:12 <sipa> fasta: ok, didn't know about that - but that's still providing a possibility for dynamic types, not disable static types
16:27:29 <sipa> time for sleep
16:28:02 <hirsch> EvanR: That works, but I don't want to use the constructor with the (Point  Double) parameter, I want to use Point's (a,a) parameter
16:28:14 <hirsch> EvanR: that's my problem
16:28:20 <EvanR> so use Point (5,5)
16:28:48 <hirsch> that doesn't
16:28:57 <hirsch> work
16:29:03 <EvanR> why do you say that
16:29:52 <hirsch> EvanR: what?
16:29:58 <EvanR> what doesnt work about it
16:30:13 <hirsch>     Couldn't match expected type `SG.Point2' Double'            against inferred type `(Double, Double)'
16:30:27 <diefrage> Quick question: is there some favoured alternative to: head $ dropWhile?
16:30:43 <EvanR> something other than the Point (5,5) is misspelled
16:30:52 <hirsch> it seems the constructor is not "derived"
16:30:53 <EvanR> sometimes its hard to figure it out from the ghc messages
16:30:55 <diefrage> (for getting the first result of a list)
16:31:11 <diefrage> (that matches some predicate)
16:31:17 <hirsch> EvanR: Ok, I'll check once more
16:31:27 <Heffalump> diefrage: I'd probably use head $ filter (not . f), but it's much of a muchness for ugliness
16:31:35 <EvanR> :t Just (5,5)
16:31:35 <pelotom_> @type find
16:31:36 <lambdabot> forall t t1. (Num t, Num t1) => Maybe (t, t1)
16:31:36 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:31:42 <EvanR> :t Just (5,5)
16:31:43 <lambdabot> forall t t1. (Num t, Num t1) => Maybe (t, t1)
16:31:58 <EvanR> imagine Just is Point and Maybe is Point
16:32:09 <diefrage> Difference in performance or personal aesthetics?
16:32:40 <EvanR> @src find
16:32:41 <lambdabot> find p          = listToMaybe . filter p
16:33:03 <EvanR> (@src doesnt give you any real performance hints)
16:33:12 <EvanR> but its certainly aesthetic
16:33:13 <Heffalump> aesthetics
16:33:40 <Heffalump> find does sound better. I didn't know it existed :-)
16:34:08 <EvanR> head . dropWhile . not . f
16:34:13 <EvanR> er
16:34:19 <EvanR> head . dropWhile (not . f)
16:34:23 <EvanR> which crashes if not found
16:34:30 <diefrage> ah
16:34:34 <diefrage> Good point
16:35:39 <diefrage> Thanks guys
16:35:44 <EvanR> dropUntil
16:37:20 <pumpkin> I'm curious if anyone can golf sadache's question from yesterday more than I did
16:38:21 <pumpkin> 13:17:41 <Sadache> I need to write a function for taking elements of a list until I get the nth that satisfies a predicate
16:38:37 <pumpkin> 13:19:56 <Sadache> so it is like take 3 [1,2,3,2,4,2,5,4,4,2] (=2) gives [1,2,3,2,4,2]
16:38:51 <pumpkin> :t takeWhileN
16:38:52 <lambdabot> forall a1 a. (Enum a) => Int -> (a1 -> a) -> [a1] -> [a1]
16:38:55 <pumpkin> oh wow, it's still there
16:39:21 <pumpkin> > takeWhileN 3 (==2) [1,2,3,2,4,2,5,4,4,2]
16:39:22 <lambdabot>   [1,2,3,2,4,2]
16:41:24 <hpc> @src takeWhileN
16:41:24 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:41:34 <EvanR> split at 2, drop (3-1), concat the rest
16:41:44 <aristid> :t concatMap (++ "\n")
16:41:45 <lambdabot> [[Char]] -> [Char]
16:41:57 <hpc> :t unlines
16:41:57 <lambdabot> [String] -> String
16:42:08 <aristid> > unlines ["a", "b"]
16:42:09 <EvanR> unlines sucks
16:42:09 <lambdabot>   "a\nb\n"
16:42:25 <EvanR> join "\n"
16:42:30 <pumpkin> hpc:
16:42:31 <pumpkin> takeWhileN n p = map snd . takeWhile ((/=n) . fst) . uncurry zip . first (scanl (+) 0) . unzip . map (fromEnum . p &&& id)
16:42:39 <aristid> EvanR: not if you want a "\n" at the end
16:42:45 <EvanR> never!
16:43:03 <hpc> @hoogle [[a]] -> [a]
16:43:03 <lambdabot> Prelude concat :: [[a]] -> [a]
16:43:03 <lambdabot> Data.List concat :: [[a]] -> [a]
16:43:03 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
16:43:44 <hpc> > unwords ["a", "b"]
16:43:45 <lambdabot>   "a b"
16:43:58 <aristid> @hoogle prefix
16:43:59 <lambdabot> Data.Data Prefix :: Fixity
16:43:59 <lambdabot> Text.Parsec.Expr Prefix :: ParsecT s u m (a -> a) -> Operator s u m a
16:43:59 <lambdabot> Text.ParserCombinators.Parsec.Expr Prefix :: GenParser tok st (a -> a) -> Operator tok st a
16:44:07 <aristid> @hoogle isPrefix
16:44:07 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
16:44:07 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
16:44:07 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
16:44:08 <EvanR> unwords doesnt put a space at the end!1
16:44:32 <aristid> EvanR: both functions should be parametrised on the delimiter
16:44:40 <hpc> i think the idea behind unlines leaving a tailing newline is that it is needed for text files, which have an empty line by convention
16:44:47 <hpc> for cat and #include
16:44:58 <aristid> yeah unix says "good files end with \n"
16:45:13 <EvanR> concat . intersperse x
16:45:36 <Vanadium> hpc: It is not an empty line any more than C blocks have an empty statement at the end :)
16:45:39 <aristid> :t concatMap . flip (++)
16:45:39 <EvanR> ++ x
16:45:40 <lambdabot> forall b. [b] -> [[b]] -> [b]
16:45:54 <hpc> Vanadium: heh
16:46:24 <EvanR> when i recursively unlines, it does end up having 'blank lines' ;)
16:46:56 <bos> dons: about?
16:47:10 <hpc> :t mplus
16:47:11 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
16:47:31 <aristid> :t lines
16:47:32 <lambdabot> String -> [String]
16:47:40 <aristid> > lines "a\n"
16:47:41 <lambdabot>   ["a"]
16:48:10 <hpc> > unlines ["1", "2"] ++ unlines ["a", "b"]
16:48:11 <lambdabot>   "1\n2\na\nb\n"
16:48:23 <hpc> > unwords ["1", "2"] ++ unwords ["a", "b"]
16:48:24 <aristid> EvanR: unlines . lines is id for all "good files" :)
16:48:24 <lambdabot>   "1 2a b"
16:49:17 <hpc> so you can concatenate unlines'd lists
16:49:23 <hpc> but not unwords'd
16:50:06 <EvanR> > unlines ["1", unlines ["2", "3"], "4"]
16:50:07 <lambdabot>   "1\n2\n3\n\n4\n"
16:51:12 <EvanR> > lines $ unlines ["1", unlines ["2", "3"], "4"]
16:51:13 <lambdabot>   ["1","2","3","","4"]
16:52:19 * hackagebot loli 2010.10.9 - A minimum web dev DSL in Haskell  http://hackage.haskell.org/package/loli-2010.10.9 (JinjingWang)
16:52:29 <Ke> > words "a  b"
16:52:30 <lambdabot>   ["a","b"]
16:52:48 <pumpkin> good to see people following the pvp
16:54:27 <ddarius> pumpkin: Have you seen Jinjing's code?
16:54:36 <pumpkin> I saw one example of it a while ago
16:54:38 <pumpkin> was rather confused
16:54:57 <pumpkin> yeah, MPS I think
16:55:11 <pumpkin> (/) :: FilePath -> FilePath -> FilePath
16:55:22 <pumpkin> second :: [a] -> a
16:55:25 <pumpkin> forth :: [a] -> a
16:55:34 <hpc> :t (/)
16:55:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
16:55:36 <pumpkin> ninth :: [a] -> a
16:55:52 <hirsch> EvanR: I don't get it my base is the type: Point2 :: (a, a) -> Point2' a
16:55:54 <EvanR> ninth [1,2,3,4,5,6,7,8,9,10] = undefined ?
16:56:08 <hirsch> EvanR: then I do: newtype Point = Point (SG.Point2' Double)
16:56:10 <EvanR> er
16:56:13 <EvanR>  [1..8]
16:56:13 <pumpkin> eighth  = at 7
16:56:14 <pumpkin> ninth   = at 8
16:56:14 <pumpkin> tenth   = at 10
16:56:17 * pumpkin giggles
16:56:35 <monochrom> 0st, 1nd, 2rd
16:56:35 <hirsch> EvanR: but this does not work: mkVec = Point (5.0,5.0)
16:56:44 <pumpkin> preflex: 6st 7
16:56:44 <preflex>  7rd
16:57:18 <EvanR> hirsch: whats Point2'
16:57:19 <tnks> BONUS: I'm going through your tutorial.
16:57:25 <tnks> it's pretty awesome.
16:57:34 <monochrom> \∩/
16:57:52 <pumpkin> ohhhh
16:57:54 <pumpkin> now I remember
16:58:02 <pumpkin> MPS is the one with all the secret math in it
16:58:03 <hirsch> EvanR: http://hackage.haskell.org/packages/archive/SG/1.0/doc/html/Data-SG-Geometry-TwoDim.html#t:Point2-39-
16:58:12 <pumpkin> none of the modules are exported: http://github.com/nfjinjing/mps/tree/master/src/MPS/Math/
16:58:27 <tnks> where you pretty deliberate in not talking about the off-side rule?  or did I just miss it?
16:58:45 <EvanR> hirsch: the way you have it, you must construct like this... Point (Point2' (5.0,5.0))
16:58:49 <djahandarie> Whoa nice pumpkin 
16:58:53 <djahandarie> Why is that all hidden away?
16:58:58 <pumpkin> oh it isn't his code
16:59:01 <pumpkin> it's from haskell for maths
16:59:16 <djahandarie> Ah okay
16:59:17 <hirsch> EvanR: that's not very convenient
16:59:26 <EvanR> or
16:59:49 <hirsch> EvanR: isn't there a possibility to add an additional constructor?
17:00:21 <EvanR> nevermind
17:00:24 <hirsch> EvanR: Or why can't the constructor be automatically matched
17:00:24 <EvanR> what are you trying to do?
17:00:55 <EvanR> makea function from (a,a) to Point2' a ?
17:01:06 <hirsch> EvanR: I only want an easy to use Point2 type which is bound to Doubles
17:01:17 <EvanR> point = Point2'
17:01:26 <EvanR> i dont know why you want to 'bind to doubles'
17:02:03 <EvanR> you can rename Point2' Double to another name with type
17:02:04 <hirsch> EvanR: to reduce the type to that datatype
17:02:26 <EvanR> type DPoint = Point2' Double
17:02:34 <EvanR> dpoint = Point2'
17:02:35 <hirsch> EvanR: Ok, then I can't use a constructor with that name
17:02:58 <hirsch> EvanR: I want to hide the Point2' stuff
17:03:04 <EvanR> that doesnt?
17:04:00 <hirsch> EvanR: type Point = SG.Point2' Double
17:04:06 <EvanR> ok
17:04:08 <hirsch> EvanR: mkVec = Point (5.0,5.0)
17:04:23 <EvanR> Point isnt a valid constructor
17:04:27 <EvanR> define this
17:04:32 <hirsch> EvanR: Not in scope: data constructor `Point'
17:04:36 <EvanR> point = SG.Point2'
17:04:42 <EvanR> mkVec = point (5.0,5.0)
17:05:05 <EvanR> assuming SG.Point2' is how you construct one of those damned things
17:05:24 <EvanR> personally i would use Data.Complex
17:06:00 <hirsch> EvanR: I want to do linear algebra
17:06:17 <EvanR> and?
17:06:25 <Axman6> there are plenty of packages that let you do linear algebra
17:06:29 <hirsch> EvanR: SG provides it
17:06:37 <Axman6> then use SG
17:06:41 <hirsch> so, why not use it
17:06:47 <EvanR> so whats the problem
17:07:26 <EvanR> mkVec is kind of useless above, if its supposed to make a 'vec', you could take off the (5.0,5.0)
17:07:37 <hirsch> There's no straight way to create a "specialized" datatype with the original constructor
17:07:45 <EvanR> why are you trying to do that?
17:08:10 <Axman6> what's wrong with type Point = SG.Point2' Double?
17:08:10 <hirsch> EvanR: To test if it compiles, later in the code I need a constructor
17:08:45 <hirsch> Axman6: As I mentioned above, then I can't write Point (5,5)
17:09:01 <EvanR> use a lower case p
17:09:22 <Axman6> well write SG.Point2' (5,5) then, or do what EvanR has suggested numerous times now, point = SG.Point2'
17:09:26 <hirsch> EvanR: seems hacky to me
17:09:32 <EvanR> it is
17:09:36 <Axman6> it's a pretty common thing to do though
17:09:41 <EvanR> blame SG.Point2'
17:10:10 <EvanR> use the word mkVec then
17:10:10 <hirsch> EvanR: isn't it a language limitation?
17:10:32 <Axman6> hirsch: how is it a language limitation? o.O
17:11:00 <EvanR> youre the one who imported qualified
17:11:06 <hirsch> The language can't automatically deduce the typedefed constructor
17:11:12 <EvanR> theyre the ones who named it Point2'
17:11:13 <Axman6> -_-
17:11:38 <Axman6> hirsch: what is it that you actually want? i haven't been able to figure that out yet
17:12:14 <hirsch> Ok, I want to write: let p = Point (5,5)
17:12:25 <Axman6> why?
17:12:43 <EvanR> and you definitely want it to be upper case
17:12:50 <hirsch> Axman6: to create a point
17:12:54 <Axman6> you can do that, if you make your own type with a constructor called Point
17:13:12 <EvanR> he wants Point = SG.Point2'
17:13:30 <hirsch> Axman6: but I want to reuse an existing point implementation
17:13:47 <Axman6> well, pick one or the other. 
17:14:03 <Axman6> never met anyone so stubbornly fussy before
17:14:28 <EvanR> haskell is statically typed, you do have to play by some rules
17:14:58 <Axman6> oh, i have a good idea
17:15:07 <Axman6> #define Point SG.Point2'
17:15:22 <aristid> Axman6: awesome, that's what the C preprocessor was made for
17:15:44 <Axman6> should work actually
17:15:54 <EvanR> is that more or less hacky than point = SG.Point2'
17:15:55 <Axman6> though, you now can't have a type called Point
17:16:05 <Axman6> EvanR: more imo
17:16:16 <EvanR> or mkVec
17:16:24 <EvanR> which makes more sense
17:16:47 <hirsch> Axman6: I want to understand the languange and it seems a little bit too strict for me. Btw. Haskell is the fussyest beast
17:16:59 <EvanR> this is tedious, need to work on this webapp
17:17:10 <Axman6> Haskell is fussy for extremely good reasons though
17:17:35 <pelotom_> haha, haskell is too strict
17:17:35 <Axman6> i think what you want would break a lot of the good things we get from static typing
17:18:15 <hirsch> Axman6: it seems strange to introduce constructors if you have to write factroy functions for doing compley stuff
17:18:27 <Axman6> ...factory?
17:18:32 <EvanR> we have type aliases, seems like constructor aliases should be that harsh of an extension
17:18:34 <Axman6> java dev?
17:18:42 <EvanR> shouldnt*
17:18:53 <hirsch> Axman6: C++
17:18:53 <EvanR> but its definitely not in the scope of 'type' declaration
17:19:11 <Axman6> well, time to learn that haskell is a very different language to C++
17:19:23 <hirsch> EvanR: I assumed it and now I learned it the hard way
17:19:43 <EvanR> you can call your constructor anything you want as long as its got a lower case letter
17:19:48 <EvanR> why is this hurting your feelings so much
17:20:09 <hirsch> EvanR: it's inconsistent
17:20:21 <EvanR> not really
17:20:31 <Axman6> you're just writing a smart constructor
17:20:35 <hirsch> it's a factory function
17:20:38 <Axman6> they're quite common
17:20:38 <EvanR> ignoring certain things about c++ for a moment, constructors are really functions 
17:21:05 <Axman6> > map Just [1,2,3]
17:21:06 <lambdabot>   [Just 1,Just 2,Just 3]
17:21:09 <Axman6> :t Just
17:21:10 <lambdabot> forall a. a -> Maybe a
17:21:15 <hirsch> EvanR: also in C++ but there I can overload them to accept different types
17:21:36 <Axman6> they're not functions like in haskell
17:21:44 <EvanR> yeah, and thats useless and bizarre
17:21:46 <Axman6> :t Left
17:21:47 <lambdabot> forall a b. a -> Either a b
17:21:58 <Axman6> :t (:)
17:21:58 <lambdabot> forall a. a -> [a] -> [a]
17:22:09 <hpc> :t []
17:22:10 <Axman6> as you can see, these are actual haskell functions
17:22:10 <lambdabot> forall a. [a]
17:22:23 <copumpkin> hpc: it's a function!
17:22:29 <hpc> quite!
17:22:31 <copumpkin> a big lambda
17:22:59 <EvanR> its got to be weird going from haskell to c++
17:23:01 <EvanR> i mean
17:23:06 <EvanR> the other way around
17:23:15 <EvanR> its like diametrically opposed
17:23:19 <hirsch> EvanR: It is
17:23:19 <hpc> you were right before, too :P
17:23:34 <hpc> C++ does some hella odd things, and steals terms
17:23:35 <EvanR> before, weird -> very painful
17:23:48 <hpc> look up a c++ functor sometime, and prepare to facepalm
17:24:02 <EvanR> yeah i still dont know what thats supposed to be
17:24:07 <Draconx> EvanR, probably not significantly weirder than learning anything else new.
17:24:19 <EvanR> theres degree of new
17:24:22 <systemfault> All your C++ (except perhaps for template metaprogramming) won't help you to learn Haskell :)
17:24:31 <conal> Hi all.  I'd like to take a quick poll here for a blog post I'm writing.
17:24:34 <conal> Why do we Haskellers settle for using non-exact, machine-oriented numeric types & operations (e.g., Int & Float), rather than exact number types?
17:24:49 <pelotom_> aren't functors in c++ like lambda expressions?
17:24:50 <Axman6> speed
17:24:52 <Draconx> conal, performance?
17:24:55 <hpc> there's "peanut butter in my chocolate" new, and there's "quantum gravity" new
17:25:17 <systemfault> pelotom_: C++0x yes.
17:25:18 <EvanR> conal: is 'i dont' an answer?
17:25:23 <hpc> haha
17:25:28 <conal> EvanR: definitely.  thx.
17:25:35 <hpc> i try to use Integer whenever possible
17:25:46 <systemfault> But it takes more than lambdas to be a functional programming language.
17:25:50 <hirsch> EvanR: A Quote from a newsgroup I love: C++ is a hideous conglomeration of features and misfeatures haphazardly thrown together. The simple C core is still there, it's just buried beneath mountains of complexity.  I very much prefer C++.
17:25:53 <hpc> which is a perfectly fine number type
17:26:06 <conal> EvanR: i'm happy to have my question's assumption questioned.
17:26:24 <conal> note that i mean Float & Double, as well.
17:26:34 <Axman6> conal: also, no one should be using Float.... yeah, heh
17:26:35 <conal> not just integral types.
17:26:37 <EvanR> i switched to haskell for the Integer
17:26:54 <conal> Axman6: and yet people do, right?
17:26:58 <EvanR> so that i can do my arithmetic without going insane
17:27:00 <pelotom_> "C++ is like making an octopus by nailing extra legs to a dog"
17:27:02 <Axman6> not that i've seen
17:27:03 <copumpkin> conal: sometimes you don't need the precision and need the speed, but I'll use rational when I can
17:27:06 <pelotom_> I forget who said that
17:27:12 <hpc> i use float because i don't really need the extra precision for what i use it for
17:27:33 <Axman6> hpc: what advantage do you get from Float over Double though?
17:27:41 <copumpkin> rational: premature correctness
17:27:47 <copumpkin> float: premature optimization
17:27:55 <copumpkin> :P
17:27:58 <systemfault> Haskell is a high level language... leave your C/C++ mentality behind.
17:28:01 <hpc> Axman6: float or double
17:28:02 <Axman6> double: happy medium :P
17:28:05 <hpc> Axman6: Floating, perhaps
17:28:09 <hpc> :t 1.5
17:28:10 <lambdabot> forall t. (Fractional t) => t
17:28:14 <hirsch> EvanR and Axman6: So, I have to reflect a little on haskell's value- and typeconstructors. Good night and thanks for the patience
17:28:14 <hpc> er, Fractional
17:28:23 <conal> oh yeah, rational.  but then there are also non-rational operations, like sqrt & sin
17:28:27 <systemfault> float vs doubles.... Integer with fixed-size IntX types..
17:28:43 <copumpkin> conal: the only alternative is CReal for those, and it's painfully slow for even simple things
17:28:50 <copumpkin> as far as I know?
17:29:28 <hpc> sqrt and sin are implemented as taylor series usually
17:29:37 <conal> copumpkin: as far as i know also.  getting more to the heart of my inquiry, what puzzles me is why things like creal aren't getting improved.  that's what i mean by "settling".
17:29:40 <hpc> so you can still rationalize those
17:29:43 <Draconx|Laptop> conal, despite Haskell's support for floating point being limited at best; it still kills the alternatives in performance.
17:30:01 <Axman6> hirsch: i should also add that haskell programs are usually short enough for 'annoyances' like the one you have to get in the way
17:30:02 <EvanR> conal: i would use Word64 to perform an algorithm involving explicit arithmetic mod 2^64
17:30:03 <copumpkin> conal: ah, not sure about that :) profiling CReal and seeing how good it can be made (or something similar) sounds like a fun project
17:30:04 <hpc> and it isn't like other languages have a more precise version
17:30:16 <copumpkin> EvanR: how often do you need that? :P
17:30:24 <EvanR> multiply with carry generator
17:30:26 <hpc> floating point math is a generally damn hard problem
17:30:40 <conal> Draconx|Laptop: yeah.  with the current state of alternatives.  what keeps people from pushing on improving the alternatives?
17:31:05 <Draconx|Laptop> conal, gates are expensive.
17:31:10 <systemfault> Because it takes a brain to learn Haskell.
17:31:20 <systemfault> That's the problem.
17:31:39 <conal> i'm asking particularly about *Haskell* programmers.  we have a culture of taking on hard efficiency problems in order to get correctness, well-definedness, composability,  etc.
17:31:53 <copumpkin> conal: see also Int all throughout the prelude and data.list functions :(
17:31:55 <conal> and yet not so much for numbers.
17:31:58 <copumpkin> yeah :(
17:32:04 <copumpkin> I hate it
17:32:16 <conal> copumpkin: yeah.  wow :(  not only machine-oriented, but semantically undefinted.
17:32:20 <EvanR> DSP applications gain nothing from using something 'better' than Float or Double
17:32:20 <conal> (undefined)
17:32:29 <copumpkin> yeah
17:32:32 <copumpkin> even Word would make me happier
17:32:39 <ddarius> 0x07300730
17:32:41 <aristid> @pl \a b -> a ++ "=" ++ b
17:32:41 <ddarius> > 0x07300730
17:32:41 <lambdabot> (. ('=' :)) . (++)
17:32:42 <copumpkin> although some unbounded natural would be happier
17:32:42 <lambdabot>   120588080
17:32:53 * Axman6 wishes that the Prelude had functions like length :: [a] -> Integer, length' :: [a] -> Int etc
17:32:59 <hpc> natural is [0..]?
17:33:05 <copumpkin> Axman6: genericLength!
17:33:08 <copumpkin> ;)
17:33:15 <EvanR> hpc: no.. [1..] ! ;)
17:33:17 <Draconx|Laptop> conal, the reason floating point is so fast is because it permits efficient implementation in hardware.
17:33:29 <Axman6> copumpkin: sure, but have by default using Integer, and use Int when you want the better efficiency
17:33:34 <conal> copumpkin: yeah.  isn't it odd that the semantically well-defined and well-behaved function gets the uglier name?
17:33:37 <hpc> Axman6: why not length :: Integral b => [a] -> b?
17:33:44 <Axman6> hpc: or that
17:33:47 <copumpkin> Axman6: Integer is wrong too
17:33:50 <copumpkin> Natural
17:33:55 <copumpkin> :P
17:33:59 <Draconx|Laptop> conal, gates are expensive, so we are unlikely to see hardware implementations of Rational or CReal.
17:33:59 <Axman6> urgh
17:34:11 <hpc> :t fromInteger
17:34:12 <lambdabot> forall a. (Num a) => Integer -> a
17:34:17 * copumpkin has been meaning to get around to implementing a binding to GMP's naturals
17:34:20 <Axman6> but i still want the Int version of length, which is specialised
17:34:28 <hpc> Axman6: it would probably just be fromInteger . yourLength
17:34:59 <conal> these defenses of machine-oriented types are the sort of justification more typical of a c programmer than a haskell programmer.
17:35:33 <Axman6> conal: some of us want to write really fast code, and know you have to work with the hardware to get the best performance
17:35:36 <EvanR> yeah id rather do 3d graphics or dsp in C
17:35:38 <hpc> i think we have just resigned ourselves to the inevitability that we deal with computers :P
17:35:52 <conal> Axman6: definitely!  
17:36:12 <conal> Axman6: the same sort of defense tells us to program in c, though.
17:36:24 <copumpkin> keeping a more abstract form of the reals might also allow us to do some not-so-obvious optimizations, maybe?
17:36:27 <Axman6> i want the speed of C, with the ease of haskell
17:36:28 <Draconx|Laptop> conal, many applications of floating point need to perform computations non-stop for hours or even days.
17:36:31 <conal> i took these numeric expediencies for granted for such a long time.  i'm now starting to wonder why.
17:36:37 <EvanR> thank goodness for the ffi
17:36:38 <Axman6> i don't think that's an unreasonable thing to ask
17:37:03 <conal> Draconx|Laptop: yes, of course.  so it's important that the implementation use floating point reps & hardware.
17:37:04 <Draconx|Laptop> conal, an order-of-magnitude performance hit is not an option.
17:37:29 <conal> but isn't that the sort of thing that the haskell culture hands to the compiler rather than the programmer?
17:37:31 <hpc> i think the solution is more of the usual
17:37:38 <hpc> make shit properly polymorphic
17:37:42 <EvanR> 1 order of magnitude hit is just a constant factor ;)
17:37:44 <conal> just as with laziness and garbage collection?
17:37:48 <copumpkin> I'd also be interested in a type that keeps track of possible uncertainties introduced in float calculations
17:37:51 <Axman6> conal: there's only so much the compiler can do
17:37:55 <hpc> and write standard types that are fast and correct
17:38:03 <conal> it's these rationalizations that interest me.
17:38:06 <Axman6> i mean, the compiler just cannot make CReal as fast as Double
17:38:07 <copumpkin> so at least you can have an interesting bound
17:38:14 <copumpkin> Axman6: but how close can it get?
17:38:19 <copumpkin> and is it worth it, if it's 3x or so
17:38:29 <Axman6> i doubt it can get very close at all
17:38:30 <Saizan> conal: is there any research on how to implement these abstractions? for laziness and gc we have it
17:38:31 <copumpkin> most of the time, you aren't going to request all the digits
17:38:33 <EvanR> i think conal is trolling ;)
17:38:41 <copumpkin> EvanR: I don't
17:38:45 <EvanR> im joking
17:38:52 <conal> exactly.  and we go through these same arguments with things like consistent laziness vs strictness, manual vs automatic memory management, etc.
17:38:56 <hpc> he posed a great question
17:39:26 <EvanR> im the first guy on board for screwing performance
17:39:39 <copumpkin> I don't think we should approach it as screwing performance
17:39:46 <conal> i'm starting to see numerics as a bubble in which haskellers do not apply their usual inclinations.
17:39:57 <hpc> the first step is to have an unbound floating type in Prelude
17:40:04 <Saizan> conal: also, i guess floating point arithmetic is not the first thing that someone working on programming languages thinks about
17:40:05 <hpc> to match up with Integer
17:40:24 <conal> i.e. giving up on semantic cleanliness, instead of tackling the difficult problem of getting both semantic rigor *and* good performance.
17:40:35 <copumpkin> data CReal = CR (Int -> Integer)
17:40:41 <copumpkin> even CReal isn't unbounded!
17:40:42 <conal> Saizan: ah, interesting!  i hadn't thought of that angle.
17:40:49 <copumpkin> but it's not even a newtype
17:40:56 <copumpkin> I doubt it's designed with efficiency :)
17:40:58 <Saizan> you'll probably won't find many Double's in GHC's source :)
17:41:00 <conal> copumpkin: oh, wow!  hadn't occurred to me.   
17:41:19 <copumpkin> div2n (CR x') n = CR (\p -> if p >= n then x' (p-n) else round_uk (x' p % 2^n))
17:41:27 <copumpkin> % 2^n is a bitwise op
17:41:42 <copumpkin> oh wait
17:41:44 <copumpkin> it's not mod
17:41:45 <copumpkin> :P
17:41:52 <hpc> :P
17:41:58 * copumpkin kicks himself
17:42:10 <Axman6> back to C for you!
17:42:22 <Draconx|Laptop> conal, I
17:42:49 <conal> so, again, my question (not that i expect anyone will know the answer), is how do haskellers settle for very un-haskelly approach to numbers instead of pushing the state of the art of haskell-like (rigorous) numerics to the point where it's efficient enough to use in practice?
17:42:50 <EvanR> do we want hardware to 'solve it for us' ?
17:42:55 <EvanR> or what
17:43:05 <copumpkin> conal: but another question is how to implement comparison operations on such a type?
17:43:17 <copumpkin> since even in theory it isn't possible
17:43:26 <Draconx|Laptop> I'd be really interested to hear your ideas for significantly accelerating Rational using existing hardware floating point implementations :)
17:43:53 <hpc> that's a good point, actually
17:43:55 <conal> i do expect to get defensive responses, but honestly i'm not just trying to provoke/insult people (troll).  i'm looking for insights.
17:44:04 <conal> copumpkin: yeah.  very interesting!
17:44:06 <Axman6> conal: possibly because the precision we get from things like Double are good enough, that we're not prepared to give up the huge improvement in performance over more exact types
17:44:42 <copumpkin> Axman6: the issue seems to be that we're all assuming that the alternative is completely unbearably slow
17:44:43 <conal> Axman6: yeah.  i think so, too.  funny that we'd invoke the nebulous notion of "good enough" in this one case.
17:44:55 <EvanR> float is good enough for dsp, and if it were any better it wouldnt translate to the analog audio out
17:45:07 <hpc> not just unbearably slow, but potentially unbounded
17:45:18 <conal> copumpkin: exactly!  that assumption is what fascinates me.  i expect it of c programmers but not haskellers.
17:45:21 <EvanR> floating point may make sense when its used in an application where its closely tied to wires in the physical world
17:45:21 <copumpkin> hpc: well, with laziness, you can imagine something that doesn't request all the digits most of the time
17:45:36 <hpc> true, but you still have strict operators
17:45:37 <copumpkin> hpc: and if you don't request all the digits, you don't pay for them (but could get them if you chose)
17:45:38 <hpc> like (==)
17:45:52 <copumpkin> well, people already don't (or shouldn't) use comparison operators on floats
17:45:55 <Draconx|Laptop> conal, typically, when using floating point, one proves bounds on their error.
17:45:57 <Axman6> copumpkin: i don't believe you can make something that's close to the same performance without hardware support
17:45:59 <conal> just like so many people have said that the alternatives to manual memory management would be too slow.
17:46:03 <EvanR> if you can put more than N digits of a real number on a wire, whats the point
17:46:04 * Saizan goes on #Agda asking how Agders settle for a termination checker instead of solving the halting problem
17:46:09 <EvanR> cant*
17:46:13 <copumpkin> Axman6: yeah, but you seem uninterested in even seeing how close we can get?
17:46:14 <hpc> a neat tradeoff might be parametric precision
17:46:27 <Axman6> no, i'd like to see, i'm just sceptical :)
17:46:30 <hpc> FooFloat :: Precision -> Number -> FooFloat
17:46:31 <conal> Draconx|Laptop: *typically*?  really?
17:46:35 <Draconx|Laptop> conal, this allows one to make objective conclusions that something is "good enough".
17:46:48 <copumpkin> Draconx|Laptop: I was just talking about a type that would keep track of those errors for you
17:46:49 <conal> Draconx|Laptop: yeah.  if people actually did it.
17:46:52 <copumpkin> it'd be nice to see one
17:47:00 <hpc> you can get huge precision if you need it, or not
17:47:03 <monochrom> haskell is not the right place to push. a better place to push is a language or environment or framework or whatever where you state and prove program refinements: you start with use of correct but perhaps too theoretical data types, then you refine it to use machine-supported approximate data types, and proving the refinement says that the approximation happens to be exact or within allowed error margin
17:47:19 <Axman6> one of my lecturers is working on interval arithmetic
17:47:23 <Draconx|Laptop> conal, well, the degree of hand-waviness depends on how much you care.
17:47:30 <copumpkin> monochrom: so have the option of rewriting your correct type to float in haskell using a rule or something
17:47:35 <copumpkin> although rules can't replace types yet
17:47:54 <copumpkin> it behaves 100% correctly in testing
17:47:56 <monochrom> ghc rewrite rules are not powerful or expressive enough.
17:48:07 <hpc> nor intended for that purpose
17:48:07 <conal> Draconx|Laptop: yes, exactly!  and the extreme waviness shows that haskellers don't care about correctness for numbers.  which is so unlike haskellers!
17:48:15 <EvanR> what would software mean for analog arithmetic hardware
17:48:36 <monochrom> well, maybe powerful and expressive enough, as in you can rewrite anything to anything. but it doesn't let you express proof that the rewrite is correct, and it doesn't check your proof.
17:48:51 <Saizan> conal: have you talked with people doing scientific computing or any other number centric applications in haskell about this?
17:49:10 <EvanR> quantum haskell
17:49:30 <conal> Saizan: no, i haven't.  and it's a good idea.  still, these issues affect almost all haskell programs, i expect
17:49:32 <hpc> quaskell?
17:49:32 <EvanR> Qubit type
17:49:33 <Saizan> conal: because afaik, the strong point of haskell is symbolic manipulations, so i don't think we have a large mass of people that care much about Double at all
17:49:33 <Axman6> I would really like to see a haskell type which carries along with it its error
17:49:42 <Draconx|Laptop> conal, part of the problem is that many people doing scientific computation have very good reasons to avoid Haskell.
17:49:48 <dolio> I almost never use Float/Double.
17:49:50 <copumpkin> Saizan: same point still holds for the Int throughout Prelude though
17:49:55 <copumpkin> which has always bothered me
17:49:56 <conal> Draconx|Laptop: cultural?
17:49:57 <hpc> EvanR: that would be pretty badass when it happens
17:50:00 <Saizan> conal: almost all? i very much think otherwise
17:50:01 <EvanR> heh
17:50:06 <Draconx|Laptop> conal, floating point seems to have been added to the language as an afterthought.
17:50:06 <hpc> which it will, inevitably
17:50:09 <Axman6> error in prelude annoys me more
17:50:12 <dolio> If Haskell suddenly had a high-performance exact real implementation, I'd also probably never use that.
17:50:30 <EvanR> haha
17:50:39 <aristid> Draconx|Laptop: so it's not there because there is nobody who uses it, and nobody uses it because it is not there?
17:50:42 <Axman6> dolio: why?
17:50:44 <Draconx|Laptop> conal, the specification fails to consider important details.
17:51:15 <dolio> Axman6: Because pretty much none of the things I'm interested in involves real numbers.
17:51:20 <Draconx|Laptop> conal, such as the behaviour of infinities with virtually every library function.
17:51:25 <Axman6> fair enough
17:51:31 <conal> Saizan: my "almost all" includes programs that use Int
17:51:53 <EvanR> Int32 and Int64 makes sense for modular arithmetic
17:52:01 <conal> dolio: thx.  a reason i hadn't considered.
17:52:03 <EvanR> performance is not at issue
17:52:23 <EvanR> Int doesnt make sense to me
17:52:35 <copumpkin> EvanR: Word32 and Word64 do
17:52:37 <conal> EvanR: in that it's undefined?
17:52:44 <EvanR> i dont know what it means
17:52:52 <EvanR> semantically
17:53:06 <ClaudiusMaximus> EvanR: 32bit float isn't always good enough for dsp, eg: http://lists.puredata.info/pipermail/pd-list/attachments/20100827/bb7faff1/attachment-0001.png (decay time in ms vs midi note number for a resonator)
17:53:12 <EvanR> copumpkin: Int32 has well defined arithmetic no?
17:53:25 <copumpkin> EvanR: yeah, but doesn't match what you usually do modular arithmetic over
17:53:42 <EvanR> true
17:53:48 <dolio> Word makes more sense for modular arithmetic.
17:53:54 <dolio> And derivatives.
17:54:08 <EvanR> still Int32 doesnt have to be 'machine oriented'
17:54:37 <conal> the claim that float is adequate for dsp is pretty interesting to me.  would be great to make that claim precise, then prove it (or disprove it), and then make use of the derived insights in an optimizing compiler.
17:55:17 <EvanR> you could replace float with double, but the important part is where dsp is going, eventually to a DAC
17:55:31 <EvanR> i dont know how much computer science matters at that point
17:55:53 <ClaudiusMaximus> EvanR: if you have recursive filters, tiny rounding errors can accumulate, drastically changing long term behaviour
17:56:31 <EvanR> chaotic system whatre you gonna do
17:56:31 <conal> i'm wary of any claim that float or double is adequate for dsp.  i suspect the informal reasoning forgets about composability.
17:56:48 <dolio> copumpkin: CReal is effectively unbounded, too. Int -> Integer should give you something like 2^(2^32) binary digits past the point, at least.
17:56:53 <conal> as in http://conal.net/blog/posts/why-program-with-continuous-time/
17:56:54 <EvanR> ah, arbitrarily complex dsp
17:56:57 <EvanR> you have a point
17:57:07 <aristid> hm, mzero makes me actually want to use unicode
17:57:12 <ClaudiusMaximus> > foldl1' (+) 0 (replicate 17777777 (1::Float))
17:57:13 <lambdabot>   No instance for (GHC.Num.Num [[GHC.Types.Float] -> a])
17:57:13 <lambdabot>    arising from a us...
17:57:19 <ClaudiusMaximus> oops
17:57:20 <aristid> > let ø = mzero in mzero :: Maybe ()
17:57:21 <lambdabot>   Nothing
17:57:23 <aristid> \o/
17:57:23 <dolio> 2^(2^64) on a 64-bit machine.
17:57:24 <ClaudiusMaximus> > foldl' (+) 0 (replicate 17777777 (1::Float))
17:57:25 <lambdabot>   1.6777216e7
17:57:36 <conal> composabiit
17:57:39 <dolio> Or is it 2^n digits, I'd have to think.
17:57:48 <dolio> I guess it's the latter. Still, it's a huge number.
17:58:03 <conal> composability is at the heart of functional programming, and it happens in the middle, not the output.
17:58:08 <monochrom> this is why dsp hires very smart people and very few of them to fit dsp-done-right into dsp-done-floating even dsp-done-data.fixed
17:58:21 <conal> so the output resolution isn't adequate for intermediate computations
17:58:45 <copumpkin> dolio: yeah, I know :P
17:58:50 <copumpkin> dolio: just saying it isn't actually unbounded
17:59:08 <dolio> I guess strictly speaking, it should be able to approximate the number to within 2^-(2^31).
17:59:08 <EvanR> conal: now i see where 'real numbers' would help
17:59:19 <copumpkin> but then again, neither are GMP integers
17:59:19 <aristid> is ø = mzero evil?
17:59:20 <conal> EvanR: ah :)
17:59:45 <copumpkin> they're limited to 2^51 bits or something terrible like that (depends on which version you look at)
17:59:46 <dolio> And a lot of numbers would require all available memory to approximate to that level.
17:59:48 <EvanR> but it frightens me to think i am hearing irrational and uncomputable numbers
18:00:13 <Axman6> aristid: hey, i hadn't realised ø was just opt-o in OS X, that would be handeh
18:00:27 <Philippa> conal: I think there's a fair argument to be had about float or double being sufficient for DSP with certain output requirements. You have to do something pretty whacky for a double not to suffice for something that's eventually going to be CD audio for example
18:00:33 <aristid> Axman6: it's also AltGr-o on my german linux
18:00:47 <conal> Philippa: see my composability remarks.
18:01:02 <aristid> Axman6: but i wonder if using danish letters for emptiness is culturally acceptable :D
18:01:04 <Philippa> that's what the floating bit gets you
18:01:09 <conal> one thing i wonder is whether it's terribly hard to optimize exact real number computation.  or whether people just stopped trying.
18:01:13 <Axman6> heh
18:01:30 <aristid> conal: CReal is pretty cool, but also hard to understand :)
18:01:32 <Draconx|Laptop> Philippa, well, even if you use double and do only a few operations, you can still get bitten by cancellation.
18:01:48 <conal> aristid: from the source code?
18:01:53 <aristid> conal: yes
18:02:05 <ClaudiusMaximus> > 1e-20 + 1 - 1
18:02:06 <lambdabot>   0.0
18:02:09 <conal> aristid: for me, too.  i haven't found a paper that describes it yet.
18:02:09 <monochrom> it's terribly hard. people don't stop trying. they just don't try it under the fp umbrella. visit the numerical analysis group of your cs department some time.
18:02:15 <EvanR> how do you propose to 'compute' the output of an fm synth which is obviously a function of a transcendental function... efficiently xD
18:02:34 <aristid> conal: i don't think people have stopped trying. it's probably just difficult, and it's rare that people find good solutions to difficult problems
18:03:31 <conal> so maybe fp'ers are kludging along, hoping that someone else figures out an answer.
18:03:49 <EvanR> arent real numbers theoretically off limits to computers?
18:03:58 <copumpkin> computable reals
18:04:00 <Philippa> EvanR: that's what the C in CReal is
18:04:06 <conal> EvanR: aren't infinite lists off limits?
18:04:09 <aristid> conal: that's what most people do most of the time, so it isn't really surprising, is it?
18:04:15 <EvanR> conal: but now you are settling!
18:04:27 <monochrom> there is some phd thesis waiting for someone to be co-supervised by an FP prof, an NA prof, and a compiler prof.
18:04:28 <Philippa> EvanR: but no further than absolutely required
18:04:32 <EvanR> dont give up on infinite lists
18:04:38 <conal> aristid: unsurprising for most people.  surprising for fp'ers.
18:05:06 <conal> EvanR: i'm saying the opposite.  which is don't give up on reals.  we didn't give up on infinite data.
18:05:07 <Philippa> not really
18:05:19 <Philippa> only one little corner of what's historically been called FP has really been like that
18:05:20 <monochrom> fp'ers don't desperately need real numbers done right yet.
18:05:40 <conal> i wonder whether anyone but fp'ers really would work out practical exact reals.
18:05:53 <Saizan> fp'ers in this conversation is quite ambiguous.
18:05:55 <conal> whether any other group would have as much motivation as we do.
18:05:58 <pelotom_> http://blog.sigfpe.com/2010_04_01_archive.html
18:06:01 <dolio> roconnor has a real number prototype implementation somewhere, too.
18:06:02 <conal> haskellers.
18:06:11 <Philippa> I don't think we have any more motivation than anyone else actually does
18:06:12 <copumpkin> fewdigits, on his site
18:06:12 <dolio> I'm not sure if it's faster than CReal or not.
18:06:29 <Philippa> we just have tools that look like they might have a hope in hell of taking a crack at it
18:06:36 <Draconx|Laptop> when you guys say "FP" do you mean "floating point" or "functional programming" ?
18:06:44 <monochrom> my FP means functional programming
18:06:46 <conal> what's unusual about haskellers is our combination of practical & rigorous.
18:06:54 <conal> Draconx|Laptop: oh!  hah.
18:07:03 <conal> i mean functional programming as well.  oops.
18:07:24 <Philippa> I don't normally see someone refer to "(floating point)ers"
18:07:47 <monochrom> haskellers are practical and rigorous in what they actually care. for example many abstractions. for example if-then-else.
18:07:54 <dolio> Sounds like a bug in a C program.
18:08:08 <monochrom> you don't see haskellers being practical and rigorous about how they use natural languages either.
18:08:09 <dolio> "Your program is floating pointers."
18:08:20 <Martty> theres no such thing as a "haskeller"
18:08:27 <Philippa> monochrom: well, more practical than rigorous
18:08:29 <pumpkin> monochrom: I do still care about Int in the Prelude </beat dead horse>
18:08:32 <Martty> the correct term is "phd in <insert advanced math shit>"
18:08:41 <Draconx|Laptop> dolio, sounds like something being moved outside a let :)
18:08:48 <conal> anyway, i think i got all the answers to my question that i'm likely to get here today.  it's been helpful.  thanks very much.
18:08:53 <dolio> That, too.
18:09:04 <Philippa> Martty: eh, I'm just about qualified to be in the conversation and I never finished my (ordinary compsci) BSc
18:10:14 <Philippa> conal: I think to sell non-haskellers you'd have to show something that you specifically make easier to do that they can't already do by tedious-but-mechanical processes on something else. The engineering world /really/ doesn't give a damn about precise reals 'til you give them a use case: you've got so many sig. fig. and after that anything else is bullshit
18:10:42 <conal> Philippa: you thought i wanted to sell non-haskellers?
18:11:00 <Saizan> sig. fig. ?
18:11:09 <monochrom> significant figures
18:11:20 <Saizan> oh, right
18:11:31 <EvanR> Philippa: hrm but theres this thing about accurate computations after arbitrary nesting and recursion
18:11:49 <Philippa> conal: I think that in the long run, if you can't sell anyone else then it's pretty much mental masturbation. Which is fun, but even so
18:11:55 <monochrom> new feature: use the @expand command to get monochrom to expand shorthands. example: @expand eg -> <monochrom> for example
18:12:12 <Philippa> conal: for comparison, reactive programming is, over time, not so hard to sell to non-haskellers
18:12:19 <conal> Philippa: different question.  didn't include masturbation advice.
18:13:04 <dolio> monochrom: You should invent your own prefix, so that we don't get lambdabot complaining all the time.
18:13:20 <monochrom> oh oops. just write "expand eg" then :)
18:13:37 <pelotom_> expand eg
18:13:41 <monochrom> for example
18:13:46 <monochrom> \∩/
18:13:46 <Philippa> conal: in the long run, it ought to be useful to someone without having had to already sell them our particular brand of kool-aid. It should sell haskell to a target audience. IYSWIM. Otherwise, you've solved a problem that's not actually of practical interest to anyone else, which leaves the question of whether we're appealing to our own taste in rigour while not actually achieving practicality
18:13:49 <pelotom_> @expand eg
18:13:49 <lambdabot> Unknown command, try @list
18:14:46 <pelotom_> monochrom: what is this service exactly?
18:14:59 <ddarius> monochrom: @expand z.B.
18:15:02 <monochrom> there is the use case of outputting all digits of pi ad infinitum (well, until the user is bored and presses ctrl-c). there are several papers on it. there is one in the jfp.
18:15:17 <monochrom> z.B. probably means "note:"
18:15:53 <monochrom> the upshot is I haven't heard of any other use case.
18:16:09 <pelotom_> monochrom: that's not much of a practical usecase
18:16:12 <conal> zum Beispiel
18:16:13 <d-snp> z.B. is german for i.e.
18:16:27 <conal> d-snp: for e.g.
18:16:34 <d-snp> eh oops yeah
18:16:46 <d-snp> what's i.e. then.. dutch? :D
18:17:01 <EvanR> swedish
18:17:06 <d-snp> oh no, it's just something else
18:17:09 <ddarius> i.e. id est
18:17:10 <monochrom> precisely my point. no one seems to care for "keep outputting digits until the user wants quit" all that much.
18:17:16 <dolio> monochrom: If it's the paper I'm thinking of, that's a pretty poor way to represent real numbers.
18:17:21 <dolio> That is: infinite list of digits.
18:17:46 <dolio> For purposes other than computing pi, at least.
18:17:50 <d-snp> monochrom: what is the context?
18:18:02 <EvanR> wouldnt a computer real recursive filter eventually run too slow to keep up with the sample rate?
18:18:06 <d-snp> it might be handy for piping into some other app using a shell? :P
18:18:15 <EvanR> unless some mechanism 'sapped' some precision
18:18:16 <monochrom> the context is "would you like better real numbers than Double and CReal?"
18:18:21 <EvanR> computable real*
18:18:54 <d-snp> like, calculate pi, and then run it through grep until my name is in there in ascii codes
18:18:57 <EvanR> and if you sap precision, youre back to where you started with Double, maybe a little better
18:19:05 <d-snp> and I will know how relevant I am to the universe..
18:19:26 <Philippa> well, if you can adapt neatly to the exact amount of precision required, that's a win
18:19:33 <EvanR> d-snp: suddenly, half the channel runs off to actually try that
18:20:19 <Saizan> i guess roconnor would have another use case
18:20:23 <ddarius> EvanR: "recursive filter" usually means infinite impulse response.  They require only constant space.
18:20:30 <Saizan> which doesn't quite apply to haskell though.
18:20:42 <EvanR> ddarius: now what i mean
18:20:48 <EvanR> not
18:20:56 <dolio> With computable reals, you have to make choices about what operations are partial.
18:21:00 <EvanR> each 'weight' is a real number
18:21:14 <EvanR> partial?
18:21:15 <dolio> And the infinite list of digits makes addition partial, for instance.
18:21:56 <Saizan> and (==) would still be quite unusable
18:22:07 <dolio> Yes.
18:22:35 <monochrom> In the past several years I have only two uses of non-integer numbers. one is adding up marks of students and one division to get the average. the other is UTCTime.
18:22:40 <EvanR> are you saying it would only require as much space as the beefiest computable sample that arrived at some point in the past
18:24:01 <monochrom> I wouldn't use a "need performance" defense if suddenly we banned Double and made me use Rational or CReal for my two uses. There is really no performance to talk about in my uses. I mean, computing my class average! How fast do I really need it to be?
18:24:06 <dolio> EvanR: By partial, I mean that you may, for instance, add together two perfectly well-formed real numbers, and get something that isn't.
18:24:21 <aristid> monochrom: and UTCTime can be represented as a Data.Fixed very well, and in fact is if you use POSIXTime
18:24:29 <EvanR> doesnt partial defeat the purpose
18:24:33 <dolio> Like 1/3 + 2/3. As infinite strings of decimal digits, that will look fo a carry forever.
18:24:43 <monochrom> Yes, it ends up being Data.Fixed. I couldn't care less.
18:25:05 <Saizan> dolio: CReal solves that right? does it make something else partial then? other than (==)
18:25:09 <imc> do "restricted monads" exists, or something that allow do-notation for i.e. only Bool ? (i.e. return :: Bool -> m Bool, no other types) ?
18:25:10 <dolio> Something like CReal doesn't have that problem.
18:25:43 <dolio> Saizan: I think all comparisons are technically undecidable. But they would be with digit strings, too.
18:25:45 <Saizan> imc: there's the rmonad package
18:25:56 <imc> Saizan: going checking ..., thanks
18:26:02 <gwern> you know why it's called creal?
18:26:09 <pumpkin> cause someone forgot the E
18:26:15 <gwern> no, because it frequently kills performance
18:26:29 <EvanR> bazing
18:26:49 <imc> theorbtwo: just wonderful
18:26:51 <imc> oups
18:26:56 <imc> was for Saizan 
18:27:18 <Saizan> that's a very bad case of tab completion :)
18:28:21 <dolio> Saizan: The one thing that's obviously better about the digit string version is the ability to print well-defined values productively.
18:28:34 <dolio> CReal would have to generate ever-closer approximations.
18:29:05 <Saizan> ah, true
18:29:10 <imc> Saizan: ghgh fingers are going where they like
18:30:10 <monochrom> Industrial use of numbers requiring high speed and low memory footprint is much harder. Compiler-made choices will happen but not in 10 years. Look, we just most recently invented ByteString and Text, and we still haven't got the compiler to automatically do "the code says [Char], but maybe I should change that to Text"
18:30:16 <Saizan> so i guess we should ask conal what does he mean by exact reals next time :)
18:30:35 <danharaj_> ok, so you guys know how 'map' is intimately tied to the concept of functors? Well, is there a similarly illuminating connection about 'filter'?
18:31:05 <monochrom> no
18:31:48 <gwern> I think we just call filters folds and pretend we've said something deep
18:32:04 <danharaj_> It seems like there should be one. You take a function A -> Bool and there's really only one obvious way, if any, to write filter for F A.
18:32:10 <monochrom> filter is too special-case
18:32:32 <pelotom_> filters = monads with zero?
18:32:38 <monochrom> no
18:33:09 <pelotom_> monad is too specific?
18:33:13 <EvanR> set theory?
18:33:20 <monochrom> I take a function A->Bool and there are really 3 obvious ways to use it.
18:33:23 <dolio> Filters are like ultra filters, but less exciting.
18:33:28 <monochrom> filter is too specific
18:33:46 <danharaj> filters are nothing like set theoretic filters :p
18:34:12 <monochrom> sorry, really 4 really obvious ways to use it
18:34:14 <Saizan> danharaj: for "F A = mu. G A" you'll be able to write filter as a fold, i'm quite sure
18:34:48 <Saizan> or maybe not
18:35:03 <danharaj> Can you write filter on a list as a cata?
18:35:30 <danharaj> I bet you could do it with something slightly more complicated than a cata. para, perhaps.
18:36:01 <Saizan> ?type \p -> foldr (\x xs -> if p x then x : xs else xs) []
18:36:02 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
18:36:14 <Saizan> pretty simple, actually
18:36:36 <Saizan> the problem in generalizing it to other functors is getting an equivalent for :
18:36:43 <monochrom> cata would be the right thing to generalize from list to arbitrary algebras
18:36:59 <Taslem> Is it possible to create a function which takes types of the following:
18:37:12 <Taslem> (a,(a,(a,(a,.......))))
18:37:22 <Taslem> and returns of type a?
18:37:31 <pumpkin> :k Mu ((,) a)
18:37:32 <lambdabot> Not in scope: type variable `a'
18:37:41 <pumpkin> :k forall a. Mu ((,) a)
18:37:42 <lambdabot> *
18:37:44 <EvanR> data A a = (a,A)
18:37:47 <EvanR> data A a = (a,A a)
18:37:53 <EvanR> :S
18:37:59 <pumpkin> EvanR: that's not valid
18:38:03 <pumpkin> you could put a wrapper around it
18:38:04 <pelotom_> meaning it takes a list?
18:38:11 <pumpkin> Taslem: but the basic point is that you just have a Stream
18:38:21 <pumpkin> data Stream a = Stream a (Stream a)
18:38:23 <EvanR> whats wrong with it
18:38:38 <pumpkin> EvanR: it just isn't valid syntax
18:38:42 <pumpkin> you need a data constructor there
18:38:46 <EvanR> oh
18:38:53 <Saizan> Taslem: what's your use case for such a function?
18:38:56 <EvanR> data A a = A (a, A a)
18:39:02 <Taslem> use case?
18:39:08 <Taslem> You mean, why I need it?
18:39:14 <pumpkin> Taslem: anyway, I'd make a custom type like the one I wrote above
18:39:17 <pelotom_> how about 'head'
18:39:18 <Saizan> Taslem: yeah
18:39:19 <pumpkin> or you can use Mu ((,) a)
18:39:26 <monochrom> (don't hesitate to draw some UML diagrams for your use case :) )
18:39:50 <Saizan> (yeah, i sounded a lot javaish there)
18:40:09 <pelotom_> type CustomType = []
18:40:26 <pumpkin> :k Mu ((:*:) Int)
18:40:26 <Saizan> pelotom_: [] can be finite!
18:40:27 <lambdabot> *
18:40:36 <monochrom> "use case" is the one only UML word that manages to pollute #haskell. even "singleton pattern" doesn't quite manage. :)
18:40:43 <Taslem> Now, how wouldI go about making afunction that could take from a type of:
18:40:57 <Taslem> (a,b)  where b is (c,b) or Nothing?
18:41:02 <EvanR> does haskell support singletons
18:41:05 <Taslem> Like....
18:41:11 <pumpkin> (a, Maybe (c, b))
18:41:16 <Taslem> (a,(b,(c,(d,...))))
18:41:20 <EvanR> 'only one instance of a class' ;)
18:41:30 <Taslem> With the last one being Nothing
18:41:35 <Taslem> Could that be done?
18:41:36 <pumpkin> sounds like you want Cofree! :P
18:41:56 <pumpkin> Taslem: yeah, but typically you wouldn't use infinitely nested tuples
18:42:02 <pumpkin> Taslem: oh you want different types?
18:42:03 <Taslem> No, it's finite.
18:42:06 <Taslem> But arbitraily deep.
18:42:12 <pumpkin> how is the depth determined?
18:42:14 <pelotom_> Saizan: soudns to me like he wants []
18:42:15 <pumpkin> you can just write that :P
18:42:27 <Saizan> pelotom_: that might be true
18:42:36 <Taslem> It tells me I can't cunstruct the infinite type (a,b) -> b or something like that.
18:42:36 <Saizan> or maybe he wants HList
18:43:02 <pelotom_> Taslem: do you want this thing to be heterogeneous?
18:43:26 <Taslem> rt 0 x = fst x rt i x = rt (i-1) (snd x)
18:43:37 <Taslem> rt 0 x = fst x 
18:43:42 <Taslem> rt i x = rt (i-1) (snd x)
18:44:02 <Saizan> yeah, you can't write a function like that
18:44:10 <Taslem> hm?
18:44:51 * EvanR attempts to solve the above equations
18:45:19 <Taslem> Oh, the first of the 3 can be ignore,d it was a mis enter.
18:45:23 <EvanR> 0 = 0 >_<
18:45:42 <Taslem> 0=0?
18:45:43 <Saizan> Taslem: it won't typecheck because the depth of the tuple type should depend on the i
18:45:55 <Saizan> maybe you just want lists?
18:45:59 <Saizan> ?type (!!)
18:45:59 <lambdabot> forall a. [a] -> Int -> a
18:46:11 <Saizan> > [1,2,3,4,5] !! 2
18:46:12 <lambdabot>   3
18:46:15 <Taslem> The issue is that lists only take one type.
18:46:46 <Taslem> I'm trying to figure out an efficient way to be able to store any type (or pseudo-types if there's a fats way for it) in some form of list.
18:47:06 <EvanR> you want 'any type'? or 'any of a certain class' ? or 'one of several specific types'? 
18:47:12 <pelotom_> Taslem: if they take any type, how can you do anything with the list?
18:47:29 <pelotom_> forall a. [a] is only inhabited by []
18:47:47 <Taslem> Because the thing requesting them knows which is which, and won't make type errors, unless it does, in which case it's working properly.
18:48:09 <EvanR> sounds like php
18:48:37 <pelotom_> Taslem: you could make it a list of disjoint sums, which enumerate the possible things each element could be
18:49:22 <Taslem> " list of disjoint sums"?
18:49:25 <pumpkin> Taslem: is it a fixed set of types?
18:49:27 <pumpkin> or arbitrary ones?
18:49:34 <Taslem> Arbitrary.
18:49:40 <pumpkin> then just use Dynamic
18:49:46 <pumpkin> if the caller knows what to do with them
18:49:50 <Taslem> But, like I said, they could be Pseudo, representations of types, not actual types.
18:49:52 <pumpkin> or make a typeclass + existential
18:49:53 <Saizan> Taslem: there are various ways, 1) use a discriminated union data AnyOfTheseTypes = TypeA A | TypeB B | .. then [AnyOfTheseTypes] is accepted, 2) if these types you're talking about only have to be instances of some class you can use an existential type 3) Dynamic 4) HList or other similar "heterogenous list" libs
18:50:06 <Taslem> existential types confuse me...
18:50:25 <Saizan> oh, you don't want values of these types, you want a list of the types themselves?
18:50:33 <EvanR> or 5) rethink the problem
18:50:37 <gwern> i maked u an existential type, but i inferred it away :(
18:50:40 <Taslem> No, I want the valus themselves.
18:50:58 <Taslem> But, for instance, storing them entirely as lists of lists of ints, and then writing a converter, would work fine.
18:51:13 <EvanR> Int only has finite possibilities
18:51:17 <EvanR> you want arbitrary
18:51:29 <Saizan> Taslem: try Data.Dynamic
18:51:49 <Taslem> @Evan. All data is finite.
18:51:49 <lambdabot> Unknown command, try @list
18:52:21 <EvanR> Taslem: you may want to use more 'types' and 'value types' than there are Ints
18:52:45 <Taslem> Yes, but the lists could be any length.
18:52:54 <EvanR> this is adding epicycles
18:53:16 <EvanR> haskell has better ways for you to express yourself
18:53:36 <EvanR> than using certain configurations of cons cells
18:53:55 <Taslem> Hm...
18:54:10 <Taslem> Do anyof you know a simpler Haskell compiler?
18:54:23 <Taslem> I want a compiler, not interpreter, because I have no knowledge whatesoever of working with terminals.
18:54:36 <Taslem> And I can write code, but not compile it...
18:55:13 <pelotom_> "simpler haskell compiler"?
18:55:24 <Saizan> Taslem: what are you using currently?
18:55:32 <Taslem> GHC.
18:55:36 <Taslem> GCHi.
18:55:39 <Taslem> *sorry
18:55:41 <Saizan> ghc is a compiler
18:55:51 <aristid> and an interpreter
18:55:57 <Saizan> use "ghc --make yourfile.hs"
18:55:58 <aristid> but mostly a compiler
18:56:00 <pelotom_> ghci is the interpreter, ghc is the compiler
18:57:41 <Saizan> if you want something more like an IDE you've to use emacs or eclipsefp atm
18:57:42 <Axman6> Taslem: as a programmer, you should learn to use the terminal
18:58:02 <Taslem> Oh, gots to go.
18:58:29 <pumpkin> Axman6: you scared him off
18:59:06 <pelotom_> or leksah
19:00:23 <Saizan> i knew i was missing something :)
19:01:01 <Axman6> bleh, i hate that this channel has so many people who give correct answers to newbs. sometimes they need to be shown why what they want isn't a good thing first
19:01:13 <mlh> tsk tsk
19:01:21 <Axman6> i am referring to his need for a list that can hold any type
19:01:22 <EvanR> i didnt want to be too mean
19:01:38 <Saizan> i tried to ask what he wanted this for but i got ignored.
19:02:16 <Axman6> well, keep it up :)
19:02:21 <EvanR> in many channels he would have been ridiculed for trying to do that, insulted for not listening, and called names for continuing to speak before reading a book
19:02:41 <mlh> that's a pretty low bar to get over
19:02:51 <Axman6> but it just seems absurd to be that people would siggest things like Data.Dynamic to people who are obviously very new to the language
19:03:07 <Axman6> suggest*
19:04:03 <Saizan> well, they have to see for themselves that writing that kind of OO in haskell is not pratical, most react badly if you try to tell them
19:04:55 <EvanR> i know that heterogenous list basically never shows up, but people often say they need it. what im wondering is if theres some concrete proof of its general inapplicability?
19:05:05 <pumpkin> you can make one easily in agda :)
19:05:10 <EvanR> so i can explain it without coming off as arguing from authority
19:05:46 <pumpkin> it's not that it's inapplicable, it's just that haskell doesn't really give you the reasoning power to use them effectively, and most of the time there are nicer solutions unless you need to guarantee some properties
19:06:17 <pumpkin> there's HList, but it needs to be wrapped in an existential if you want to construct one without compile-time knowledge of its contents
19:06:21 <Saizan> and if you're using them just for the generality it's quite not worth it
19:06:26 <EvanR> no, even in python, js, php with support for arbitrary types in a list or equivalent, you just dont need them
19:06:46 <EvanR> but im not sure how to articular why
19:06:55 <EvanR> ate
19:07:11 <pumpkin> I wouldn't say it's inapplicable
19:07:16 <EvanR> why not?
19:07:37 <Saizan> in a more expressive type system you've more variety of types, so more uses for heterogenous lists
19:07:42 <pumpkin> if you're making a general library and you want users to be able to specify things like that, and retain type safety
19:07:44 <pumpkin> you might want them
19:07:48 <Saizan> in fact, i've found more uses in Agda than Haskell
19:07:50 <pumpkin> an example might be a relational database
19:08:10 <dolio> Uses of heterogeneous lists in dynamic languages tend to be lazy programming.
19:08:21 <EvanR> a relational database without a compatible type system?
19:08:31 <dolio> At least, genuine use of them.
19:08:38 <pumpkin> EvanR: say you have an interface to postgres in haskell
19:08:41 <EvanR> the database im working with has definite types
19:08:51 <pumpkin> you want to not be able to write unsafe queries
19:09:23 <dolio> Like, I stick a bunch of different things in a list, and expect them to come in a particular order, instead of defining a product type that expresses what I actually want passed to the function.
19:09:25 <pumpkin> so typed queries against typed tables
19:09:30 <Saizan> EvanR: e.g. HDBC uses SqlValue, so each row is just [SqlValue], you might want a more specific type instead
19:09:50 <Saizan> but at that point the result type should depend on the query
19:09:57 <EvanR> ok so this is a good case, but really its a problem with types not surviving the interface to the db
19:09:59 <Saizan> i think this is what haskelldb does?
19:10:09 <EvanR> its really [(Integer, String, Bool, Etc)]
19:10:11 <pumpkin> EvanR: well, it's a problem with the knowledge not being there are compile-time
19:10:17 <pumpkin> EvanR: and potentially changing
19:10:33 <dolio> If it's not that, then presumably it's a list holding things of different types with the same interface, which is an existential.
19:11:19 <EvanR> and in this case even dynamic languages dont use a hetero list for this
19:11:19 <JoeyA> I'm currently working on / using an addon of sorts to HDBC that facilitates converting lists of [SqlValue] to/from different data types, and uses the types of values as parameters to Statements.
19:11:22 <EvanR> it just returns strings
19:11:51 <pumpkin> EvanR: I'm just saying what heterogeneous containers might let you do
19:11:53 <JoeyA> Not sure if that's what you're getting at, but it's something I came up with trying to make my DB code nicer.
19:11:58 <pumpkin> just because someone else doesn't do it doesn't mean they aren't useful
19:12:01 <EvanR> i know what they let you do
19:12:11 <EvanR> but so far there are better ways
19:12:16 <pumpkin> what's better than what I said?
19:12:34 <JoeyA> Is it possible to make it so a type can have a type parameter of kind * -> * rather than * ?  Would that even make sense?
19:12:34 <Saizan> EvanR: it is really  [(Integer, String, Bool, Etc)] but only for a particular query, the question is what type your general queryDB function should have
19:12:36 <dolio> HList makes the first case clear, because it's really an extensible record system, which lets you build up product types on the fly.
19:12:48 <EvanR> for a database, you define types compatible with the current state of the result of the query in question, the result is Maybe [T]
19:13:06 <pumpkin> EvanR: that knowledge isn't present at compile time
19:13:15 <pelotom_> JoeyA: sure
19:13:17 <EvanR> thats what Maybe is for
19:13:28 <JoeyA> Here's my scenario:
19:13:34 <pumpkin> EvanR: why even allow it, if you have a type system that lets you specify a tighter constraint?
19:13:43 <EvanR> you dont
19:13:45 <JoeyA> say I have data structures representing objects in a DB:  data Person {personName :: String}
19:13:50 <pumpkin> EvanR: you're disallowing it at runtime
19:13:52 <pumpkin> by using Maybe
19:13:55 <JoeyA> err, data Person = Person {personName :: String}
19:13:57 <EvanR> yes
19:13:59 <pumpkin> your webapp could crash
19:14:02 <EvanR> no
19:14:21 <EvanR> Nothing means your static type is incompatible with the runtime state of the db
19:14:28 <JoeyA> and I want to use an ID type that is polymorphic to that which it applies to:
19:14:34 <EvanR> i could throw an exception
19:14:34 <pumpkin> EvanR: you don't seem very receptive to examples that you asked for, so I'm not going to keep trying
19:14:42 <JoeyA> newtype ID a = ID Int64
19:15:19 <JoeyA> The thing is, my Person records in the DB come with an ID column, and I'd like to avoid having to say (ID Person, Person) everywhere
19:15:30 <JoeyA> (granted, that's probably the right way to go)
19:15:37 <EvanR> pumpkin: stereotypical hetero list systems like python and php do not use hetero for db, and im talking about a better way for db. do you have another example of a 'good' use for hetero list?
19:15:42 <JoeyA> So I'm considering adding a type parameter to Person
19:15:48 <JoeyA> so functions that need an ID take Person ID
19:15:54 <JoeyA> and functions that don't take Person a
19:15:54 <EvanR> JoeyA: im using HDBC
19:16:19 <Saizan> JoeyA: sure, just do it
19:16:19 <pumpkin> EvanR: your original statement said that there was no applicable use for hetero lists, and I gave you one. Just because you can use a maybe and throw a runtime exception doesn't mean it's equivalent (you can say the same thing about any static type)
19:16:26 <pumpkin> EvanR: I'll think about other examples
19:16:30 <JoeyA> Can't.  Complier no likey
19:16:37 <EvanR> not equivalent, generally better
19:16:48 <pumpkin> why?
19:16:55 <EvanR> no converting, because its not a hetero list
19:16:59 <JoeyA> `Foo' is not applied to enough type arguments   The first argument of `ID' should have kind `*', but `Foo' has kind `* -> *'
19:16:59 <EvanR> its a list of tuples
19:17:05 <pumpkin> who says there's conversion involved?
19:17:17 <JoeyA> where data Foo a = Foo {fooExtra :: a, fooName :: String}
19:17:26 <EvanR> you have to convert from the dynamic type to a monomorphic type if its a hetero list
19:17:28 <JoeyA> and Foo ID is the intended usage.
19:17:36 <JoeyA> err
19:17:42 <pumpkin> EvanR: no, my point is you have a type system sophisticated enough to know what it is
19:17:44 <JoeyA> Foo (ID (Foo (ID ...
19:17:48 <pumpkin> so no runtime checks/conversions are needed
19:17:52 <JoeyA> but to solve that, I could screw with ID
19:17:55 <EvanR> in what system?
19:17:59 <Saizan> JoeyA: try data Foo a = Foo {fooExtra :: a Foo, fooName :: String }
19:18:02 <pumpkin> agda, what we've been talking about :P
19:18:05 <EvanR> oh
19:18:06 <JoeyA> and make the type ID takes have kind * -> *
19:18:13 <JoeyA> hmm
19:18:38 <Saizan> wait
19:18:41 <JoeyA> I still get a kind error
19:18:48 <Saizan> JoeyA: "data Foo a = Foo {fooExtra :: a (Foo a), fooName :: String }"
19:18:52 <JoeyA> wouldn't it have to be a (Foo a (Foo a (Foo a ... ?
19:19:03 <Saizan> no.
19:19:15 <pumpkin> EvanR: another example could be a verified implementation of another language
19:19:15 <EvanR> JoeyA: you can make a class for getting/storing from the database, but this is treating db as a store of objects. i recommend treating each query separately and using functional abstraction to get various 'flavors' of data out
19:19:31 <EvanR> ok, how would a hetero list help there?
19:19:40 <pumpkin> EvanR: you can construct a datatype representing terms of the language to model your syntax
19:19:51 <EvanR> so [Term]
19:19:52 <pumpkin> you ideally want to statically prevent badly formed terms
19:19:56 <JoeyA> EvanR: problem is, sometimes, I need to select a whole bunch of fields.
19:19:58 <pumpkin> oh, I wasn't talking about that
19:20:05 <EvanR> JoeyA: whats a 'whole bunch' ?
19:20:06 <mm_freak> hello
19:20:09 <JoeyA> about 15
19:20:33 <pumpkin> EvanR: say your language can be reduced to simply-typed lambda calculus
19:20:39 <pumpkin> :P
19:20:46 <pumpkin> or something more complicated, but this is simplest
19:20:55 <EvanR> JoeyA: why on earth?
19:21:03 <JoeyA> man lstat
19:21:07 <EvanR> pumpkin: ok
19:21:07 <pumpkin> you can represent variables as a type indexed by a type context, but isomorphic to a peano natural
19:21:11 <JoeyA> I'm putting all those fields in a database.
19:21:18 <pumpkin> where a type context is a list of abstract representations of types
19:21:26 <JoeyA> (and actually using more of them than I originally thought I would)
19:21:43 <EvanR> JoeyA: you need to normalize
19:21:50 <JoeyA> as in, stat a file, then put the result in a database.
19:21:52 <pumpkin> EvanR: here, I actually wrote a highlighter for agda and one example of it: http://pumpkinpat.ch/moo.html
19:22:00 <JoeyA> err, stat a whole tree of files.
19:22:05 <pumpkin> EvanR: Type is the ADT representing my types
19:22:27 <pumpkin> +, x, and => take two Types and produce a Type
19:22:28 <mm_freak> (just a social experiment…  my conjecture is that the more people there are in a channel, the less like it is that someone greets back) =)
19:22:32 <EvanR> type context?
19:22:34 <pumpkin> 0# and 1# are base types
19:22:39 <mm_freak> s/like/likely/
19:22:47 <pumpkin> mm_freak: hi!
19:22:52 <mm_freak> ;)
19:23:11 <pumpkin> EvanR: the idea is to keep knowledge of the type of a variable in your syntax representation, so you're guaranteed to have well-formed terms
19:23:19 <pumpkin> (parsing it is another issue)
19:23:23 <Saizan> JoeyA: did my last Foo above typecheck?
19:23:50 <JoeyA> The data declaration type-checked.
19:24:02 <JoeyA> Whether it's possible to actually use or not, I'll have to test.
19:24:09 <pumpkin> EvanR: ack, I should really go shower and get ready, gotta go to airport soon to catch a plane :P
19:24:15 <EvanR> yeah
19:24:22 <EvanR> stop screwing around!
19:24:26 <pumpkin> :)
19:25:28 <ddarius> You can bet that when mm_freak is on a channel by himself, he greets himself thoroughly.
19:26:20 <JoeyA> instance (Record (a (Foo a))) => Record (Foo a) where <- Not sure this is going to work out
19:26:53 <JoeyA> I'm guessing that UndecidableInstances thing is going to undecide my program if I try to use that.
19:27:21 <EvanR> the undeciderator
19:27:25 <gwern> “But I don't want to go among mad people,” Alice remarked.
19:27:25 <gwern> “Oh, you can't help that,” said the Cat: “we're all mad here. I'm mad, you're mad.”
19:27:28 <gwern> "How do you know I'm mad?" said Alice.
19:27:31 <gwern> “You must be,” said the Cat, “or you wouldn't have come here.”
19:27:50 <Saizan> JoeyA: UndecidableInstances is not that bad, at worst it'll make the typechecker loop :)
19:28:14 <JoeyA> Well, in this context, I have a good feeling it will.
19:28:26 <JoeyA> a (Foo a)
19:28:40 <JoeyA> but in normal, careful usage, I agree.
19:28:57 <monochrom> there is actual netiquette on irc that says don't greet people who join. (the joiner may greet, of course.) it's pretty logical (for large channels): 50 people saying hi to you when you join makes the channel unusable.
19:29:10 <Saizan> JoeyA: depends on the instance for Record (ID a)
19:29:58 <EvanR> can a thread end itself other than by 'returning'
19:30:09 <monochrom> kill itself
19:30:26 <EvanR> obliterate itself
19:30:30 <gwern> monochrom: you know, I didn't even realize that until just now. I had absorbed that norm so thoroughly it never even occurred to me that it might be more natural to greet joiners
19:30:35 <monochrom> myThreadId >>= killThread
19:30:42 <EvanR> ah
19:31:10 <JoeyA> From the dust you came, from the dust, you shall... err... killThread
19:31:38 <conal> copumpkin: earlier you said, "but another question is how to implement comparison operations on such a type?  since even in theory it isn't possible".  This question interest me as well.  Especially this angle: what are we trying to do when we use comparisons on Float or Double?
19:31:55 <conal> copumpkin: usually when i use an op on Double, i expect the result to be somewhat close to a corresponding operation on reals.  but what about comparisons?  what do we even want?
19:31:58 <pumpkin> nothing, they're not recommended
19:32:23 <ddarius> pumpkin: When do you start work?
19:32:25 <pumpkin> maybe we should kill the Ord and Eq classes on Float and Double (I'm tempted :P)
19:32:29 <pumpkin> ddarius: haven't decided yet
19:32:36 <pumpkin> ddarius: haven't actually accepted the job even
19:32:38 <monochrom> you ask yourself "what's the real question" and design your own comparison based on that.
19:33:09 <pumpkin> ddarius: flying back to the US today and will think more about it there
19:33:26 <ddarius> pumpkin: Where are you staying, if you don't mind me asking?
19:33:28 <Draconx> conal, I thought the question was about how to implement comparisons on a type that tracks roundoff error.
19:33:39 <pumpkin> ddarius: I'm flying to tampa first
19:33:49 <pumpkin> will probably fly up to boston in a week or two
19:34:21 <ddarius> I've never been Florida way.
19:34:53 <conal> pumpkin: i suppose if we somehow removed Ord from Float & Double, we have to think about what we wanted from them.
19:35:11 <pumpkin> I almost feel that Ord on those two is more justified than Eq
19:35:21 <pumpkin> but unfortunately Eq is a superclass of Ord
19:35:35 <pumpkin> ddarius: some parts of it are quite pretty, but overall it's not my favorite state
19:35:35 <ddarius> The only thing Float and Double are good for is implementing intervals.
19:35:45 <ddarius> pumpkin: What is your favorite state?
19:36:30 <Draconx> pumpkin, I think the Eq instance is fine, but Ord is problematic.
19:36:34 <pumpkin> not sure, actually :) I haven't seen that many, but so far, I'd say my favorite parts (in terms of atmosphere, not necessarily aesthetics) of the US are the DC area, boston, or SF
19:36:52 <conal> ddarius: ah, so maybe comparison would return a boolean interval
19:37:45 <conal> though interval as model doesn't sit well with me, since interval itself is a leaky abstraction.
19:40:29 <EvanR> JoeyA: if a record consists of 15 fields, then a record structure sounds like a good idea
19:41:13 <EvanR> if you are only interested in a subset of them at any given time, a tuple could suffice
19:43:34 <gwern> I found florida oppressive to my soul
19:43:41 <gwern> places need more bad weather
19:43:52 <tnks> what's the best explanation for the left-hand comma-alignment style?
19:43:56 <EvanR> try south louisiana!
19:44:05 <ddarius> EvanR: Ugh.
19:44:17 <RayNbow`TU> gwern: if you need bad weather, you should visit NL :p
19:44:31 <tnks> I've been told a rationale, but I forgot it.
19:44:49 <ddarius> tnks: You can add, remove, and reorder it without worrying about edge cases.
19:46:05 <EvanR> except at the front
19:47:25 <JoeyA> EvanR: My Record library has tuple instances
19:47:45 <JoeyA> For instance, if File is a Record, and ID File is a record, then (ID File, File) is also a record.
19:48:07 <JoeyA> (the [SqlValue] items are sequenced)
19:49:18 <EvanR> gah @ SqlValue
19:49:36 <EvanR> more like SqlDevalue
19:50:18 <JoeyA> Combined with a 2-parameter Statement type (one for the parameters, one for the result set), the only part that isn't type-checked is prepare.
19:50:32 <EvanR> something isnt type checked??
19:51:15 <JoeyA> Well, the only way you could get it checked would be to do something like require the Record class to include table and column names.
19:51:45 <EvanR> actually accessing the database has more problems than getting the spelling righ
19:51:55 <EvanR> since its IO
19:52:10 <gwern> RayNbow`TU: I liked the netherlands when I visited. very congenial. not as dark as london
19:52:11 <JoeyA> But that is too restrictive, as Int (an instance of Record corresponding to a one-item [SqlValue] and could correspond to many different column names of many different tables).
19:52:50 <EvanR> classes and instances are so boilerplate i usually question whether i need them 
19:53:11 <JoeyA> On the outside of the application-specific data access module, typing is hunky-dory.
19:53:16 <EvanR> for interpreting [[SqlValue]] i have done ok with functions only
19:53:48 <EvanR> usually simple, and often reusable
19:54:24 <JoeyA> My Record system facilitates doing that.  In my case, it really wasn't simple.
19:56:18 <JoeyA> (doing it manually)
19:57:01 <JoeyA> It is unfortunate that I have to write instance methods like: getSql = liftM4 Inode getSql getSql getSql getSql
19:57:23 <JoeyA> But at least I don't have individual converters anymore.
19:57:38 <EvanR> heh
19:58:09 <EvanR> instance methods, and generally useful functions accomplish the same goal
19:58:51 <EvanR> im trying to stay away from definite objects in my db
20:02:27 <JoeyA> I guess one reason I don't get to do that is because I'm using a DB in a less run-of-the-mill (namely, storing and retrieving tiny snippets of data for a website) fashion.
20:03:02 <JoeyA> I'm storing thousands of records at once, then performing aggregates, creating temporary tables, etc.
20:03:25 <JoeyA> Things where, to get good enough performance, I have to do things a certain way.
20:03:59 <EvanR> that sucks
20:04:20 <JoeyA> if you're wondering, I'm working on a data deduplication program.
20:04:34 <EvanR> i thought it might be that same guy
20:04:39 <JoeyA> lol
20:05:06 <EvanR> for something thats heavily 'not read only' maybe a relational database isnt the best structure
20:05:34 <EvanR> for higher performance
20:05:46 <EvanR> like the data gets inserted into a structure specially designed for the operation youre doing
20:06:05 <JoeyA> I considered implementing a single-value store with laziness.
20:06:28 <EvanR> well Data.Map already does that
20:06:35 <JoeyA> on-disk?
20:06:42 <EvanR> even better
20:06:45 <EvanR> in ram!
20:06:53 <JoeyA> well, what if you don't have enough RAM?
20:07:03 <EvanR> swap partition ;)
20:07:15 <JoeyA> and you're using an operating system that doesn't have a swap system that actually works worth the gold it's made of
20:07:19 <JoeyA> (e.g. Linux)
20:07:29 <EvanR> lol
20:08:47 <JoeyA> Anyway, I settled on using sqlite because it's fast enough, and it has a tendency to be flexible.
20:08:57 <EvanR> what good would such a single value store on disk be
20:09:28 <JoeyA> getFileTree >>= writeStore "tree.db"
20:09:59 <JoeyA> now, updating a single-value store like I'm talking about can actually be done efficiently, thanks to stable names.
20:10:08 <JoeyA> a simple example:
20:10:20 <JoeyA> writeStore "foo" [1..1000000]
20:10:50 <JoeyA> updateStore "foo" (\x -> 0 : x)
20:11:55 <JoeyA> that "x" represents a million items.  However, the storage library could recognize it's stable names as one it knows about (because it stored the stablename in a map after reading the file).
20:12:10 <JoeyA> s/it's/its
20:12:35 <JoeyA> and thus use a pointer to the data already stored rather than rewriting it.
20:12:44 <EvanR> storing a arbitrary length list as one of the values in the file?
20:12:57 <JoeyA> Well, that was a simple example.
20:13:25 <JoeyA> A real-world example would be, say, storing a Data.Map (after implementing the needed instance) in a file.
20:14:38 <EvanR> sounds like an interesting exercise on its own
20:14:40 <JoeyA> When you update the Data.Map and write it to disk, parts of the map you didn't change would just be pointed to rather than copied (again, thanks to stable names)
20:14:42 <EvanR> but not part of a real project
20:14:49 <JoeyA> I agree.
20:15:47 <JoeyA> Though it'd probably be better to have a map type specifically designed for use in a single-value store.
20:16:00 <JoeyA> err, specifically designed for on-disk storage
20:16:02 <JoeyA> e.g. a B-tree
20:16:39 <EvanR> should usernames be unique?
20:17:02 <EvanR> or should you just log into the user you used the right password for ;)
20:17:25 <JoeyA> are you changing the subject, or are we still talking about single-value stores?
20:17:33 <EvanR> i half changed the subject
20:17:44 <EvanR> im looking at my database, again
20:18:00 <JoeyA> yes, usernames should be unique.
20:18:19 <EvanR> reasoning?
20:18:36 <JoeyA> If you make passwords unique instead, users will get a message saying "this password is already taken"
20:18:43 <JoeyA> and thus know someone else's password.
20:18:51 <EvanR> yes thats a security problem
20:19:01 <EvanR> though if you guessed it you could just log in anyway
20:19:14 <syntaxglitch> no, make usernames antiunique
20:19:18 <syntaxglitch> everyone has the same username
20:19:55 <EvanR> instead of a message, it logs you into the appropriate user with that name
20:20:11 <EvanR> the edge case is same name and pass
20:23:29 <EvanR> JoeyA: allocating blocks to binary data doesnt sound like fun, much less keeping them straight in a tree
20:59:27 <tehgeekmeister> @pl (\n -> ((n `mod` 5)  == 0) || ((n `mod` 3) == 0)) 
20:59:28 <lambdabot> ap ((||) . (0 ==) . (`mod` 5)) ((0 ==) . (`mod` 3))
20:59:58 <tehgeekmeister> @hoogle ap
20:59:58 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
20:59:59 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
20:59:59 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
20:59:59 <systemfault> Project Euler? :P
21:00:12 <tehgeekmeister> yes.  resolving a problem in haskell
21:00:31 <tehgeekmeister> i'm redoing them in haskell along with a friend who's learning haskell
21:01:32 <tehgeekmeister> there has to be a point free version that doesn't use arrows
21:01:37 <tehgeekmeister> i.e.: one i can follow
21:02:39 <tehgeekmeister> i'm not sure point free has any benefit over a lambda, here, though
21:02:46 <tehgeekmeister> for any humans who want to read the code
21:04:01 <Axman6> > let f n = any (==0) . map (mod n) [3,5] in map f [1..20]
21:04:02 <lambdabot>   No instance for (GHC.Real.Integral [a])
21:04:02 <lambdabot>    arising from a use of `f' at <in...
21:04:13 <Axman6> > let f n = any (==0) . map (mod n) $ [3,5] in map f [1..20]
21:04:14 <lambdabot>   [False,False,True,False,True,True,False,False,True,True,False,True,False,Fa...
21:04:33 <Axman6> @pl f n = any (==0) . map (mod n) $ [3,5]
21:04:33 <lambdabot> f = flip (any (0 ==) .) [3, 5] . map . mod
21:04:54 <Axman6> could be worse
21:06:24 <tehgeekmeister> my final solution was: sum $ [3,6..999] `union` [5,10..999]
21:06:54 <Axman6> heh
21:07:01 <tehgeekmeister> a similar approach that didn't work was:  sum $ takeWhile (<1000) $ [3,6..] `union` [5,10..]
21:07:15 <tehgeekmeister> because [3,6..] is evaluated first
21:07:30 <EvanR> hey, chris waterson, check your email
21:07:43 <EvanR> i need hdbc-mysql fixed!
21:08:12 <tehgeekmeister> i use postgresql just because it works better with haskell.  =P
21:08:32 <EvanR> im sure postgresql works better with or without haskell
21:08:45 <tehgeekmeister> i don't know databases well enough to know that
21:08:51 <tehgeekmeister> but it certainly works better with haskell
21:09:03 <EvanR> i should get into that at some point
21:19:40 <augustss> howdy
21:26:52 <tehgeekmeister> haskell makes project euler too easy
21:27:04 <tehgeekmeister> i remember these problems being *hard* in ruby
21:27:42 <djahandarie> Most of Project Euler just require mathematical insight, so I don't know if that really holds true
21:28:43 <lpsmith> tehgeekmeister, maybe it's a matter that you've solved the problems before in ruby,  and that's why it seems easier
21:29:17 <JoeyA> Granted, Integer makes some problems easier
21:29:18 <tehgeekmeister> i think the main factor is that i've been programming for about five years more now
21:29:47 <tehgeekmeister> if i could still look at my ruby solutions (complete data loss since then), i'm sure i'd cringe
21:29:53 <lpsmith> I have to agree with djahandarie,  I don't think haskell makes PE that much easier,  although Integer is mighty convenient :)
21:30:09 <tehgeekmeister> i don't think any of these would be one liners in ruby, though.
21:30:52 <scottj> I haven't gone far in project euler but mathematica and J guys seem to have the solutions that look the easiest
21:30:58 <lpsmith> does ruby support arbitrary precision ints?
21:32:12 <tehgeekmeister> i don't know
21:32:20 <tehgeekmeister> probably in some library, but i never need to worry about stuff like that
21:32:43 <tehgeekmeister> yes, it does
21:32:51 <tehgeekmeister> automatically converts between the two
21:32:56 <tehgeekmeister> behind the scenes
21:46:22 <tehgeekmeister> nah, the haskell solutions are way more elegant
21:46:30 <tehgeekmeister> maybe not easier, but so much more elegant
21:51:52 <tehgeekmeister> @hoogle [a -> b] -> a -> [b]
21:51:52 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
21:51:53 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
21:51:53 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
21:52:15 <tehgeekmeister> now to figure out which i want
21:54:13 <Saizan> none of those
21:54:30 <Saizan> sequence for the (a ->) monad fits
21:54:38 <tehgeekmeister> that's what i was thinking, as i was looking at them
21:54:41 <JoeyA> :t (\x -> map ($ x))
21:54:42 <lambdabot> forall a b. a -> [a -> b] -> [b]
21:55:05 <tehgeekmeister> !  i was thinking $ and map might do it
21:55:38 <tehgeekmeister> :t map . (flip ($))
21:55:39 <lambdabot> forall a b. a -> [a -> b] -> [b]
21:56:58 <dolio> @type flip sequence
21:56:59 <lambdabot> forall a a1. a -> [a -> a1] -> [a1]
21:57:20 <JoeyA> :t (\fs x -> fs <*> pure x)
21:57:21 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
21:59:00 <dolio> @type fmap . flip id
21:59:00 <lambdabot> forall b (f :: * -> *) a. (Functor f) => a -> f (a -> b) -> f b
21:59:15 <dolio> @type flip $ fmap . flip id
21:59:16 <lambdabot> forall b (f :: * -> *) a. (Functor f) => f (a -> b) -> a -> f b
22:00:31 <JoeyA> @pl (\fs x -> (<*>) fs (pure x))
22:00:31 <lambdabot> (. pure) . (<*>)
22:01:05 <JoeyA> :t (. pure) . ap :: [a -> b] -> a -> [b]
22:01:06 <lambdabot> forall a b. [a -> b] -> a -> [b]
22:02:51 <dolio> @type (. flip ($)) . fmap
22:02:52 <lambdabot> forall a a1 b. (a1 -> b) -> a -> (a -> a1) -> b
22:03:08 <dolio> @type (. flip ($)) . flip fmap
22:03:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
22:04:30 <tehgeekmeister> now this problem i have not only failed to solve efficiently, but my solution is really ugly, too.
22:05:51 <Axman6> i taught myselg generic programming before i knew what i was with PE
22:06:14 <systemfault> PE?
22:06:18 <tehgeekmeister> project euler
22:06:24 <dolio> Who's myselg?
22:10:01 <Axman6> wow, what horrible typing
22:12:00 <systemfault> It's the weekend so you're forgiven.
22:25:09 <narens> hello, I have a question about runInteractiveCommand. When I run a command with this and supply input to read the output it doesn't return output unless I close the input handle first... any ideas?
22:26:28 <Axman6> prossibly because the program you're feeding input to is waiting for more input
22:26:48 <narens> Yea, i thought that too, but it generates output after every line of input
22:27:26 <narens> I am using hGetLine to read from the output handle
22:28:23 <narens> The command I am running is "Rscript --vanilla -" and then I put into its input "cat("DONE\\n")"
22:28:55 <narens> if you try this in command line you can see it prints output immediately, but using interactive command i can't read it
22:31:45 <tehgeekmeister> is there a really simple way to, in ghci, see how long evaluating an expression takes?
22:32:40 <systemfault> There are some parameters you can pass to the rts
22:32:56 <systemfault> You can even get a profiled output.
22:33:17 <systemfault> I don't remember the commands since it's been a while since I used Haskell :(
22:35:06 <ClaudiusMaximus> tehgeekmeister:  :set +s
22:35:50 <dmwit> Woooow.
22:35:56 <dmwit> Prelude> 3
22:35:57 <dmwit> 3
22:35:57 <dmwit> (0.01 secs, 4642816 bytes)
22:36:13 <dmwit> Four MEGAbytes?
22:37:17 <ClaudiusMaximus> narens: possibly too much IO buffering, at least when i need pipelines with responsive output i need to pass unbuffering flags to grep and sed...
22:37:25 <ClaudiusMaximus> too slow..
22:40:30 <tehgeekmeister> shouldn't there be a proper subset of [1..20] that, for the purpose of finding numbers divisible by all of the numbers in [1..20], is equivalent?
22:40:40 <tehgeekmeister> for example, you can immediately drop 1 off, trivially
22:40:48 <tehgeekmeister> and 2 is implied by divisibility by 20
22:40:52 <tehgeekmeister> so is 4 and 5
22:41:35 <tehgeekmeister> but when i try to find that set, i get the wrong answer, even when i'm conservative.  trying to figure out why.
22:42:18 <mm_freak> tehgeekmeister: exclude all numbers, which are nontrivial divisors of existing numbers
22:42:50 <dmwit> :t lcm
22:42:51 <lambdabot> forall a. (Integral a) => a -> a -> a
22:42:53 <ClaudiusMaximus> > foldr1 lcm [1..20]
22:42:54 <lambdabot>   232792560
22:42:59 <dmwit> damn, beat me to it
22:43:02 <tehgeekmeister> !!!
22:43:15 <tehgeekmeister> should have known it was in the prelude.
22:43:29 <Jafet> @src lcm
22:43:29 <lambdabot> lcm _ 0     =  0
22:43:29 <lambdabot> lcm 0 _     =  0
22:43:29 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
22:43:39 <tehgeekmeister> that makes my code look horrible.
22:44:08 <Jafet> Well, folding lcm is a bit slower.
22:44:21 <tehgeekmeister> head $ filter (and . (sequence $ map divides [3..19])) [20,40..(product [1..20])]
22:44:37 <Jafet> But not compared to that.
22:44:37 <tehgeekmeister> where x `divides` y is equivalent to the english meaning of the same.
22:44:59 <tehgeekmeister> takes 33 seconds on my system.
22:45:21 <tehgeekmeister> as opposed to 0.01 for the lcm version
22:47:17 <emilio> Could someone explain how I can grab the raw type out of this? http://hpaste.org/40465/monad
22:47:40 <mm_freak> just that you would want to use foldl' lcm 1 instead of foldr
22:47:54 <mm_freak> > foldl' lcm 1 [1..20]
22:47:55 <lambdabot>   232792560
22:48:28 <dmwit> emilio: What makes you think you can grab the raw type out of that?
22:48:54 <emilio> dmwit: Well, it returns a monad, as far as I understand
22:49:06 <dmwit> It returns a value of type (TC Type).
22:49:14 <tehgeekmeister> maaaaaan.  why'd i forget about lcm.
22:49:14 <dmwit> That is the most precise and correct way of saying what it does.
22:49:24 <emilio> Yeah, I understand that
22:49:30 <emilio> But I want to get just the Type
22:49:36 <dmwit> You may not be able to.
22:49:42 <emilio> Hm, ok
22:49:45 <dmwit> I don't know for sure, because I don't know what TC is.
22:49:45 <mm_freak> dmwit: it results in
22:49:49 <emilio> So there has to be some function to unmonad it>
22:49:53 <emilio> For me to do that
22:49:58 <ClaudiusMaximus> @djinn Maybe Int -> Int
22:49:58 <lambdabot> Error: Undefined type Int
22:50:08 <mm_freak> it "returns" something of type Type
22:50:13 <dmwit> emilio: Yes, there would have to be a function specifically for that.
22:50:31 <emilio> Ah, I believe I found it, unTC
22:50:40 <emilio> Thanks for setting me in the right direction
22:51:00 <mm_freak> @djinn Maybe a -> a
22:51:01 <lambdabot> -- f cannot be realized.
22:52:13 <mm_freak> i found a neat way to combine CPS-based monads like ContT
22:52:32 <mm_freak> testComp :: (ContT :+: ContT :+: ContT) r IO ()
22:55:14 <tehgeekmeister> annnnnd i'm at a problem that requires generating ten thousand primes.  i'm done for the night.
22:58:21 <mm_freak> is there any use case for Ran that is not covered by Codensity?
22:59:03 <Axman6> @src lcm
22:59:04 <lambdabot> lcm _ 0     =  0
22:59:04 <lambdabot> lcm 0 _     =  0
22:59:04 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
23:21:25 <mek||malloc> Hi folks. Is there a flag I can use with hugs to evaluate an expression and then exit without entering the REPL? Kind of like simply doing: echo "map (+ 1) [1,2,3]" | hugs
23:21:42 <mek||malloc> I was reading through the man pages but couldn't really find anything (or the verbiage didn't strike me as being a solution)
23:23:24 <Axman6> may i ask why you're using hugs?
23:23:35 <dolio> ghc -e "map (+1) [1,2,3]" will do that
23:23:37 <mek||malloc> Axman6: What would be a good alternative? 
23:23:42 <mek||malloc> Ah. Thanks dolio.
23:23:44 <Axman6> GHC
23:23:52 <systemfault> ghc is the only alternative :P
23:24:00 <Axman6> it's the preferred compiler and REPL
23:24:14 <mek||malloc> Fair enough, does seem to be much larger...
23:24:21 <mek||malloc> I appreciate the insight. :o)
23:24:33 <mek||malloc> Thanks folks.
23:24:34 <systemfault> mek||malloc: The best is to download the "Haskell Platform"
23:24:46 <systemfault> A bit download... but it has everything you need.
23:24:52 <systemfault> s/bit/big
23:25:33 <mm_freak> well, GHC has a downside:  it needs longer to startup
23:26:35 <systemfault> Big deal.
23:26:46 <mek||malloc> mm_freak: Not too worried about that. Just trying to learn me a haskell for me a haskell for great good.
23:26:54 <mek||malloc> Whoops
23:27:00 <mek||malloc> Mind the redundancy
23:27:37 <mm_freak> mek||malloc: well, in that case you usually either write a real program or stay in the REPL for more than one expression
23:28:03 * Maxdamantus couldn't follow that guide.
23:28:23 <systemfault> I love that guide
23:28:37 <mek||malloc> mm_freak: Well, I felt like working through some examples with friends over irc so I'm linking a little bot of mine to... well, now GHC
23:29:24 <mek||malloc> Didn't feel like creating a file each time and getting stuck in a repl will prevent values from being returned in a stream
23:30:03 <mm_freak> mek||malloc: use lambdabot
23:30:12 <mm_freak> > map (*2) [1..10]
23:30:13 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
23:30:20 <mek||malloc> mm_freak: That would take away my satisfaction.
23:30:54 <mm_freak> mek||malloc: then write your own IRC bot…  that's not too difficult in haskell =)
23:31:02 <mm_freak> to evaluate expressions you can use mueval
23:31:03 <mek||malloc> mm_freak: Already done.
23:31:11 <mek||malloc> mm_freak: Just adding an extension for haskell :o)
23:31:27 <mm_freak> mek||malloc: yes, you can use mueval, which is much cleaner and also probably much safer
23:31:41 <mm_freak> > sort [1..]
23:31:47 <lambdabot>   mueval: ExitFailure 1
23:32:48 <mek||malloc> Is mueval it specific interpreter?
23:33:54 <mm_freak> i think it's a GHC frontend
23:34:10 <mm_freak> and it has lots of features
23:34:58 <mm_freak> @let mySubsets = filterM (const [True, False])
23:35:07 <lambdabot>  Defined.
23:35:12 <mm_freak> > mySubsets "abc"
23:35:15 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
23:35:56 <Axman6> POWERSET!
23:36:16 <mek||malloc> Certainly useful for automata theory.
23:41:24 <Maxdamantus> Can "abc" be said to be a "subset" of "abc"?
23:41:51 <Maxdamantus> Aren't there two mathematical symbols for "subset" and "subset or equal"?
23:42:35 <mek||malloc> ghc -e "map (+ 2) [1..10]" did the trick. Thanks folks!
23:58:13 <sipa> Maxdamantus: i believe the terminology used is 'subset' and 'strict subset'
23:59:07 <Gracenotes> attn mathematicians: ⊂ means *strict* subset
23:59:47 <Gracenotes> yeah, a notational bigot I. :|
