01:00:04 <kwuxalot> I was thinking about the problem of persisting recursive and potentially infinite data structures to disk... has there been any research or libraries written to deal with this in Haskell?
01:04:14 <Davsebam1e> Hi. I have an IORef that I want to change the value of. If I use readIORef does it say that it does not know the IO type. Please see pasting here: http://hpaste.org/40636/maintotictactoe It is a tic tac toe program
01:05:50 <siracusa> Davsebamse: What's the type of testBoardEmpty?
01:07:49 <siracusa> Davsebamse: And you have to do {val <-  readIORef board; print val }
01:08:21 <siracusa> Or shorter readIORef board >>= print
01:14:39 <kwuxalot> is that an entirely non-sensical idea?
01:14:56 <kwuxalot> (persistence of bottomless data structures)
01:15:07 <Davsebamse> siracusa: Board 
01:15:21 <Davsebamse> siracusa: ok great I will try that
01:16:15 <siracusa> Davsebamse: If Board is a type that has a Show instance it will work fine.
01:16:28 <Davsebamse> ok great :-)
01:16:33 <Davsebamse> it is deriving show
01:37:53 <kulin> doh, so for what its worth, it seems my problem was with the difference between bound and unbound threads
01:37:58 <kulin> oops, sorry
01:46:32 <harlekin> How can I nicely maintain plugins with private state in a main application? I cannot come up with anything decent and there's little about that online according to google.
01:47:05 <harlekin> I just want to initialize and destroy the state from main and pass it to some plugin functions.
01:53:20 <arcatan> let a = 1; b = 2 in let a = b; b =a; in (a,b)
01:53:37 <arcatan> > let a = 1; b = 2 in let a = b; b =a; in (a,b)
01:53:41 <lambdabot>   mueval-core: Time limit exceeded
01:54:20 <arcatan> oh
01:55:08 <Jafet> > letrec a = b; b = 1 in a
01:55:09 <lambdabot>   <no location info>: parse error on input `='
01:55:48 <Jafet> Isn't it possible for mueval to give the column number of the error?
02:06:47 <augur> > letrec a = b, b = 1 in a
02:06:48 <lambdabot>   <no location info>: parse error on input `='
02:06:58 <augur> thats interesting.
02:07:08 * hackagebot base-unicode-symbols 0.2.1.1 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.2.1.1 (RoelVanDijk)
02:08:30 <vimes656> is there anything equivalent of python virtualenv for cabal?
02:09:00 <vimes656> I'd like to have an isolated environment of haskell packages that don't mess up with the system packages
02:09:13 <koninkje> > let a=b ; b=1 in a
02:09:14 <lambdabot>   1
02:09:33 <mreh> when did Mandelbrot die?
02:09:51 <Davsebamse> 14. okt
02:10:18 <mreh> it took the BBC three days to write an obituary
02:10:26 <koninkje> vimes656: you can install packages per --user
02:10:44 <koninkje> vimes656: if you use cabal-install, then --user is the default
02:11:33 <vimes656> koninkje, and can I have different 'environments' per user?
02:11:47 <raichoo> mreh: At least they wrote one, i highly doubt that mandelbrot is of any importance for the german media, didn't hear a word about his death here. Just via twitter :/
02:13:57 <vimes656> koninkje, I think I can manage for now, thanks!
02:14:01 <koninkje> vimes656: yes. the libraries are stored in ~/.cabal/
02:14:26 <koninkje> I'm not sure if there's a good way to do things with multiple environments for a single user...
02:14:50 <kwuxalot> is there a way to make all types automatically derive Show when interpreting in ghci?
02:15:10 * koninkje doesn't think so
02:15:20 <kwuxalot> that should be part of GHCi on Acid
02:15:35 <kwuxalot> has anybody gotten GHCi on Acid to work, BTW?
02:16:09 <sipa> how would you derive a Show instance for the type (forall a b. a -> b) ?
02:16:26 <kwuxalot> sipa: naturally it'd only derive it for types that it's possible to
02:16:30 <vimes656> koninkje, well, can you have multiple versions of the same package installed in the same environment?
02:17:08 <koninkje> vimes656: ghc-pkg --help
02:17:23 <koninkje> yes, but you have to manage things manually
02:17:29 <kwuxalot> sipa: it should be pretty straight forward to add "deriving Show" on any data type where doing so in normal ghci wouldn't produce an error
02:18:17 <sipa> true
02:18:49 <kwuxalot> Davsebamse: wow, just three days ago? I didn't know that old fucker was still kicking. :'(
02:19:25 <kwuxalot> I think Mandelbrot was one of my few childhood heros
02:20:18 <vimes656> koninkje, then 1 environment per user should be fine, I'll check ghc-pkg
02:20:51 <kwuxalot> it was him and Richard Feynman
02:21:21 <kwuxalot> ... Eistein and Tesla
02:21:23 <koninkje> The one big caveat is the "boot" libraries that GHC is compiled with. You can't have multiple versions of those
02:22:41 <koninkje> vimes656: IIRC, you can also set up your own separate environments. GHC just pulls in info from ghc-pkg, which in turn gets info from some set of package directories
02:22:50 <kwuxalot> sipa: it could be something like :show-me-the-money
02:23:22 <koninkje> It's just that the default set of package directories are the global one and the one in ~/.ghc/
02:23:52 <sipa> kwuxalot: but what if you don't want to have a derive but wont to write your own Show instance?
02:24:20 <sipa> introduce a noderive (Show) ?
02:25:02 <kwuxalot> sipa: how would that be a problem? :show-me-the-money would always prioritize instances found in your code
02:25:32 <sipa> i don't know how hard it would be implementation-wise
02:26:02 <harlekin> hpaste down?
02:26:08 <kwuxalot> neither do I... I've never dug in to GHC(i) code, but have been wanting to have an excuse to for at least a year
02:26:29 <harlekin> Ah, it's just slow. (:
02:27:16 * hackagebot regex-tdfa 1.1.6 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-tdfa-1.1.6 (ChrisKuklewicz)
02:27:21 <kwuxalot> to be honest, I'm a little afraid of it
02:27:41 <harlekin> http://hpaste.org/40638/fun_deps_and_sets - I would ghc to be able to infer the correct type of s since a is known. How come it doesnt? (It tries to match s1 against s.)
02:27:45 <vimes656> koninkje, I get it, I'll have to play with it. Got enough hints to get started, thanks for you help
02:27:48 <harlekin> *would expect
02:28:01 <kwuxalot> in my mental map of all code, the area that contains the source for GHC says "here be dragons"
02:29:01 <sipa> harlekin: where does b come from?
02:29:30 <harlekin> sipa, it comes from the function (s -> b)
02:31:16 * hackagebot regex-tdfa-unittest 1.1 - Unit tests for the regex-tdfa  http://hackage.haskell.org/package/regex-tdfa-unittest-1.1 (ChrisKuklewicz)
02:33:40 <Saizan> harlekin: in the definition of StSet there's nothing that ensures the 's' is the one for which there's a Plugin a s instance
02:34:09 <Saizan> harlekin: "data StSet a = forall s. Plugin a s => StSet [(a, s)]" might work
02:34:27 <harlekin> Ah, cool. That works. Thank you.
02:34:50 <harlekin> Is this as awkward code as I think it is?
02:37:17 <Saizan> well, "doSomething" is not really something you can implement sensibly
02:38:02 <harlekin> I could if it was returning IO () instead of b, right?
02:38:17 <sipa> const $ const undefined
02:38:18 <sipa> :)
02:38:39 <Saizan> harlekin: yeah
02:39:24 <Saizan> harlekin: then it's not quite clear why you keep 's' separate
02:39:45 <harlekin> Saizan, what do you mean by seperate?
02:40:02 <harlekin> Saizan, do you mean the functional dependency?
02:41:34 <ManateeLazyCat> @tell ezyang I have re-read your "six part intro to c2hs", it's brilliant! Discuss many details, thank you! :) Here have single pdf version : https://docs.google.com/fileview?id=0B8kprmQ446Y9ZWM4ZjllMzAtNmIyYS00ZjVhLWJjOWMtZmZmYmRjMzUwNWM0&authkey=CPe3orIE&hl=zh_CN
02:41:34 <lambdabot> Consider it noted.
02:42:03 <harlekin> Mh, in case you meant that: I actually don't need the functional dependency.
02:42:43 <ManateeLazyCat> I recommend people interested c2hs read ezyang's "six part introduction to c2hs". :)
02:42:54 <Saizan> i meant that it could be implicit inside 'a'
02:43:36 <harlekin> Saizan, could you give me an example? I still don't get that.
02:45:46 <harlekin> http://hpaste.org/paste/40638/fun_deps_and_sets_2#p40639 - Is this the way to go if I want to save private state for plugins in the main application or is there a nicer way?
02:46:27 <harlekin> And why can't I pass a function of type (s -> IO ()) to doSth instead of doSomething?
02:47:16 <kwuxalot> so is there a library out there for parsing command line options that automatically generates bash completion code?
02:48:06 <Saizan> harlekin: because once it's wrapped in the existential you've lost information about what that 's' really is, so it won't be considered equal to any other type
02:48:33 <Saizan> harlekin: but you can still use doSth because the typeclass constraint was wrapped by the existential too
02:49:00 <ManateeLazyCat> Evil Oracle will kill OpenOffice....
02:49:06 <harlekin> Ah, okay. I understand that. However, it seems kind of ugly. ):
02:49:48 <kwuxalot> how do I find what cabal package owns a given file?
02:50:16 <Saizan> harlekin: which makes the whole think equivalent to "data StSet a = StSet [(a,a -> IO ())]; doSth a (StSet ss) def = maybe def (\f -> f a) (lookup a ss)"
02:51:14 <Saizan> kwuxalot: for some interpretation of that question see "ghc-pkg find-module"
02:51:19 <mxc> has anyone seen this error when building yesod-0.5.4 and solved it?
02:51:20 <mxc> http://hpaste.org/40633/
02:51:41 <mxc> I've tried all the usual solutions - cabal install --reinstall all the relevant packages, no love
02:51:45 <ski> dolio : i've considered writing implication types in a type system that way ..
02:52:37 <Saizan> mxc: are you on windows?
02:52:47 <mxc> osx
02:53:04 <mxc> same problem on arch
02:53:04 <mxc> i've given up on haskell on windows
02:53:57 <Saizan> anyhow, that's not something you can fix by reinstalling, both zlib and zlib-bindings define that symbol, and the ghci linker doesn't like that
02:54:12 <mxc> i tried --ld-option=-x
02:54:26 <mxc> didn't help
02:54:32 <mxc> weird thing is that zlib-bindings depends on zlib
02:54:48 <ManateeLazyCat> mxc: Maybe report it to author will help. :)
02:55:20 <mxc> yup, thats step 2
02:55:57 <mxc> he's pretty helpful, was just wondering if anyone here has had the same problem so i could avoid bothering him
02:56:04 <mxc> i saw someone asked about it yesterday
02:58:25 <Saizan> i might be wrong though, i don't see why zlib should be defining that
02:59:45 <norm2782> hi all. I'm an msc student at utrecht university and I'm currently looking for places abroad where I could write a haskell related msc thesis next year. can anyone recommend me universities/institutes/businesses where I might be able to do this? :)
03:00:27 <kwuxalot> Saizan: hmm.. not finding it. I accidentally installed two packages that wrote to the same ~/.cabal/bin/foo file, and I can't figure out which package put the original file in there so I can get it back
03:00:37 <Saizan> in fact it links fine here
03:01:13 <Saizan> kwuxalot: ah, for binaries there's no way to tell
03:01:59 <kurtfryer> hi everybody
03:14:31 <Botje> norm2782: you could try pinging tom schrijvers @ KULeuven.be
03:14:41 <Botje> (not an email address, but you get my drift)
03:18:30 <mxc> norm2782:  upenn (my alma mater) has a decent FP group
03:18:35 <mxc> byorgey is a regular here
03:18:42 <mxc> i think he's doing a PhD there
03:18:51 <mxc> and ben pierce is amongst the faculty
03:18:56 <mxc> look for byorgey, ask him
03:19:45 <mxc> alternatively, standard chatered bank hired like 150 haskellers to do a huge rework of their systems.  ndm and lennart agustson (spelling?) are there
03:19:48 <sipa> Botje: you know Tom?
03:20:06 <Botje> no
03:20:28 <Botje> i'm a vub guy myself :P
03:20:59 <sipa> :)
03:21:23 <norm2782> Botje, mxc : thanks! I'll definitely consider those
03:23:53 <harlekin> http://hpaste.org/paste/40640/added_return__below_line_4#p40641 I'm trying to solve a problem I have with plugins and their private state. Could someone please take a look at a little longer example and give me some hints?
03:24:09 <harlekin> My problem is the call to render in line 43.
03:30:25 <cncl> is there some reason you're using a typeclass to model Document instead of just a string
03:30:48 <cncl> since the Document typelcass has only one method, which takes the one parameter to a String
03:31:01 <harlekin> cncl, my real document class has more methods.
03:31:11 <cncl> oh ok
03:31:22 <harlekin> Sorry. I should have mentioned that on the code.
03:32:02 <mxc> thats for norm2782 
03:32:02 <harlekin> But since documents are very different (pdf document from plain text for example) I'd like to keep the type class if possible.
03:35:46 <norm2782> mxc: upenn definitely sounds interesting. I hadn't considered it yet. 
03:38:20 <EnglishGent> hi :)
03:40:51 <cncl> harlekin: i think that sort of thing is not possible (sorry i'm slightly drunk)
03:41:45 <harlekin> cncl, hum, thank you.
03:42:52 <cncl> once the state data is in the magic existentially quantified list, i don't know how you would be able to 'recover' the information of its type
03:43:46 <norm2782> mxc: upenn definitely sounds interesting. I hadn't considered it yet. :)
03:43:49 <cncl> sort of like a GADT where you lose the type in a constructor that doesn't put a parameterized type in the signature
03:43:59 <cncl> (sorry, not great at wording that)
03:47:01 <harlekin> dons, ping
03:48:36 <cncl> it's 4am on the west coast, might be a bad time :)
03:49:48 <Zao> As far as I understand it, once you erase the concrete type, you can only operate on things through typeclasses.
03:50:30 <cncl> yeah
03:50:34 <cncl> that is a better way of putting it :)
03:51:02 <harlekin> Mh, as far as I get it type families are related to my problem. Is that right?
03:51:25 <Zao> Never touched a TF, so "maybe" :)
03:51:50 <Zao> You might get some decent suggestions for approaches on -cafe maybe?
03:52:28 <cncl> they are sort of related
03:53:26 <cncl> you will still hit the same problems with losing what type something is
03:53:56 <cncl> but it would probably let you model your problem better, and give you more opportunities to optimize the representation of your plugin states
03:55:34 <cncl> a type class with an associated datatype is probably what you want, instead of a multi-parameter typeclass with a functional dependency (the old way of doing it)
03:55:46 <blbrown_win3xx> is there this function.  [a -> b] [a -> c] -> (b, c)
03:56:06 <mornfall> BCoppens: Hey. Any chance there are going to be some folks with Agda background at BelHac?
03:56:55 <cncl> blbrown_win3xx: try again :)
03:57:10 <mornfall> You have RWH crash course, I need an Agda one. :D
03:57:53 <blbrown_win3xx> cncl, I wanted to see if there is a standard function that takes two inputs FuncA[A -> B] and FuncB[A -> C] that outputs a tuple of (B,C)
03:58:52 <cncl> i don't see how you could do that without an input of A as well
03:59:16 <blbrown_win3xx> cncl, yes
03:59:40 <blbrown_win3xx> [a -> b] -> [a -> c] :: (b, c)
03:59:42 <Blkt> good day everyone
04:00:37 <cncl> blbrown_win3xx, a type signature can't have a type signature
04:01:12 <aristid> and [a -> b] is a LIST of functions, not a function
04:01:20 <aristid> (or rather, the type of that)
04:02:03 <aristid> :t \f g a -> (f a, g a)
04:02:04 <lambdabot> forall t t1 t2. (t -> t1) -> (t -> t2) -> t -> (t1, t2)
04:03:14 <blbrown_win3xx> Let me try again, is this in the standard (a -> b) -> (a -> c) -> a -> [(b, c)]
04:03:28 <blbrown_win3xx> aristid, oh you got it
04:03:56 <aristid> blbrown_win3xx: you apparently have no idea how type signatures work :D
04:04:10 <blbrown_win3xx> aristid, or at least describing them
04:04:24 <aristid> why do you randomly add [] at places?
04:04:25 <cncl> the list of (b, c) would be a pretty redundant one :)
04:04:27 <blbrown_win3xx> Let me try again, is this in the standard (a -> b) -> (a -> c) -> a -> (b, c)
04:04:33 <aristid> yes
04:04:44 <aristid> [] is for LISTS
04:07:02 <cncl> the function you are looking for is (&&&)
04:07:16 <Rembane> Good morning.
04:07:44 <blbrown_win3xx> cncl, does it have a name
04:07:49 <cncl> yes, &&&
04:08:05 <cncl> it's in Control.Arrow
04:09:13 <aristid> @pl \f g a -> (f a, g a)
04:09:14 <lambdabot> liftM2 (,)
04:09:19 <aristid> :t (&&&)
04:09:20 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:09:37 <cncl> > ((+ 5) &&& show) 3
04:09:38 <lambdabot>   (8,"3")
04:09:58 <blbrown_win3xx> cool
04:11:07 <zygoloid> blbrown_win3xx: it's not in the standard, but it is in base.
04:12:00 <blbrown_win3xx>  > ((+ 1) &&& show) 3
04:12:03 <blbrown_win3xx> > ((+ 1) &&& show) 3
04:12:04 <lambdabot>   (4,"3")
04:12:59 <aristid> > (snd &&& fst) (1, 2)
04:13:00 <lambdabot>   (2,1)
04:13:33 <cncl> 'show' just turns the number into a string (it turns anything that supports it into a string)
04:30:20 <H-asker> Hey you guys! I'm writing a mergesort function, but as I'm totaly new to haskell I havn't really wrapped my head around how things are done here. I get so far as to dividing the list to "ones", but I don't understand how this recursion is then reverted in order to merge the "ones"
04:31:48 <Macha> I'm trying to write to file (just using hPutStrLn), but when the input is a â‚¬ character, the program crashes with: hPutChar: invalid argument (invalid or incomplete multibyte or wide character). 
04:31:53 <jkff> H-asker: Can you explain the mergesort algorithm in terms of "The mergesort of a list is the merge of results of sorting its so-and-so parts" etc.?
04:33:22 <Macha> Anyone know what's going on? (I presume hPutStrLn must be calling hPutChar internally)
04:35:41 <jkff> Macha: does hPutChar work for this character?
04:35:50 <harlekin> @pl (\(w1, h1) (w2, h2) -> (max w1 w2, (+) h1 h2))
04:35:50 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . max)
04:36:07 <jkff> Also, how do you know that you're indeed trying to write the euro character? Is it written in the source code?
04:36:14 <jkff> Maybe your source file encoding is broken :)
04:36:15 <benmachine> H-asker: hpaste.org what you've done so far then we can help more
04:36:22 <harlekin> @type first
04:36:23 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
04:36:40 <harlekin> @type first max $ second (+)
04:36:41 <lambdabot>     Couldn't match expected type `(b, c)'
04:36:41 <lambdabot>            against inferred type `a -> a -> a'
04:36:41 <lambdabot>     In the first argument of `second', namely `(+)'
04:36:50 <Macha> jkff: It's recieved over an IRC connection. I have a client in the same channel, which is displaying the â‚¬ char correctly.
04:37:03 <H-asker> hmm.. I don't follow. The sorting is done by dividing the list into smaller pieces untill I only have one 1 pieces, then I put them together again in the right order using a sort function that puts a infront of b if a > b or the other way around
04:37:08 <jkff> In what encoding is it received?
04:37:13 <Nibble> hello, lets say I have a data type named Player
04:37:19 <Nibble>     , playerCoords :: IORef Coords and have that in it
04:37:31 <Nibble> how do I set it when I initialize a player?
04:37:38 <jkff> H-asker: It's actually easier. You only divide the list into two parts, not into many. Recursion does the rest.
04:37:47 <benmachine> H-asker: write a function that takes two sorted lists and then merges them
04:38:05 <sipa> and do not use 'sort' :)
04:38:16 <H-asker> benmachine: done that already! :D
04:38:36 <jkff> So, the sort of a sufficiently large list is the merge of sorts of its splits. The sort of a very short list is the list itself. You just have to explain what is the merge of two lists, and what is the split of alist.
04:38:50 <Macha> jkff: UTF-8, in theory anyway.
04:38:53 <jkff> Try explaining it in natural language and translate it to Haskell :)
04:38:55 <benmachine> H-asker: okay, so in your mergesort function, what's the *last* thing you do?
04:39:08 <jkff> Macha: I think hPutChar uses Unicode, but I'm not sure.
04:39:12 <H-asker> Put the pieces back together?
04:39:15 <jkff> Macha: Have you tried using Data.Text?
04:39:27 <benmachine> H-asker: right, something like 'merge piece1 piece2'
04:39:47 <benmachine> H-asker: then you just have to ask yourself, what are piece1 and piece2
04:41:02 <Macha> jkff: Nope.
04:42:00 <benmachine> H-asker: have you done simpler recursive functions?
04:43:40 <jkff> Macha: Give it a try :) Its very purpose is good handling of international text
04:45:48 <Nibble> @type (++)
04:45:49 <lambdabot> forall m. (Monoid m) => m -> m -> m
04:46:01 <Nibble> interesting
04:46:03 <sipa> @src (++)
04:46:03 <lambdabot> []     ++ ys = ys
04:46:03 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:46:03 <lambdabot> -- OR
04:46:03 <lambdabot> xs ++ ys = foldr (:) ys xs
04:46:03 <H-asker> Lets say I have [1,6,5,3,2,4]. I want to divide that into [1,6,5] and [3,2,4]. After that I want [1] and [6,5] etc... When all that is done, I want to piece it together. There's some basic haskell logic here that escapes me..
04:46:10 <Nibble> what us a monoid
04:46:28 <Nibble> is*
04:46:48 <sipa> H-asker: you don't need to think about what you do with [1,6,5] and [3,2,4] to split them further
04:47:03 <sipa> assume you have a function that sorts (shorter) lists
04:47:39 <sipa> how will you sort [1,6,5,3,2,4] given that you can use a function that sorts lists of length 3
04:47:47 <H-asker> Am I going about this the wrong way? http://www.pastebin.org/252121
04:48:17 <sipa> H-asker: looks good
04:49:20 <sipa> except that you don't need to merge [1,6,5] with [3,2,4], but you need to merge (sort [1,6,5]) with (sort [3,2,4])
04:49:37 <sipa> since your merge function is not supposed to handle non-sorted lists
04:49:55 <sipa> right?
04:50:29 <H-asker> dude... my merge don't do any sorting, haha! :)
04:50:45 <sipa> rightly so
04:51:16 <sipa> H-asker: so how will you sort the subsequences?
04:57:17 <aristid> what's a good way to have errors with diagnostics? right now i use Maybe for some stuff that can fail, but i'd like to know WHAT happened
04:58:00 <Twey> aristid: Either
04:58:30 <Twey> Convention is that the Left branch contains an error value of some kind, and the Right branch contains the successful result
04:58:31 <aristid> Either [ErrorType]?
04:58:40 <Twey> Either ErrorType ResultType
04:58:49 <Twey> Or Either [ErrorType] ResultType if you want to have multiple errors
04:58:54 <aristid> well the list could be used for a stack of errors
04:58:59 <Twey> Yeah
04:59:00 <aristid> an error can lead to another error :)
04:59:18 <aristid> Twey: are there modules to make dealing with that easier?
04:59:26 <Twey> Data.Either
04:59:55 <Twey> If you make ErrorType an Error, you can also use the monad instance in Control.Monad.Instances
05:00:12 <aristid> Data.Either is rather minimalistic
05:00:29 <Twey> What are you missing?
05:01:36 <benmachine> Twey: Monad Either is not in Control.Monad.Instances until base 4.3 whereupon it no longer requires Error
05:02:04 <benmachine> aristid: the either function is super-useful
05:02:14 <aristid> benmachine: oh, sure, but it is bare-bones
05:02:38 <DRMacIver> So I've got some code that currently looks like the following: Take input, transform it on a line by line basis (where one line results in many), pass the results through a bunch of command line utilities, pass the final output to a haskell worker program. I'd like to change it so the haskell code is at the top level and it feeds lines into an external program. Where should I be looking? 
05:02:54 <benmachine> aristid: what more could you want :O
05:02:54 <aristid> benmachine: yeah, a Monad instance is one of the conveniences i was hoping for
05:02:57 <benmachine> oh
05:03:05 <benmachine> mtl has one, I think transformers has one
05:03:07 <DRMacIver> (it's important to note that the amount of input is Large, but it should be significantly reduced in the processing stage which currently happens before hitting haskell)
05:03:10 <benmachine> it's pretty easy to write yourself
05:03:36 <Twey> benmachine: Hmâ€¦ where is the old one, then?
05:03:47 <benmachine> return = Right; (>>=) = flip (either Left f)
05:03:51 <benmachine> er
05:03:56 <benmachine> f not in scipe
05:03:58 <benmachine> *scope
05:04:02 <benmachine> but you get the idea
05:04:12 <benmachine> Twey: oh, Control.Monad.Error or somewhere, it's not in base
05:05:18 <benmachine> x >>= f = either Left f x
05:05:26 <benmachine> cf. x >>= f = maybe Nothing f x
05:11:38 <aristid> benmachine: i think Control.Monad.Error is what i want
05:12:31 <aristid> or maybe i'll use monadLib cause monadLib is cool
05:12:33 <kwuxalot> what's the difference between Strings and ByteStrings?
05:13:03 <kwuxalot> are ByteStrings explicitly UTF8?
05:13:10 <aristid> kwuxalot: Strings are lists of unicode code points. ByteStrings are efficient representations of byte (octet) sequences
05:13:20 <aristid> and no, ByteStrings have no encoding
05:13:23 <benmachine> bytestrings are strings of bytes
05:13:30 <benmachine> they're not even characters, technically
05:13:43 <benmachine> although you can pretend they are with Data.ByteString.Char8
05:13:48 <kwuxalot> benmachine: but there's a very simple 1 to 1 between ByteStrings and UTF8, presumably?
05:14:04 <benmachine> kwuxalot: well, you could encode a unicode string as utf8 and then store that as a bytestring
05:14:13 <benmachine> the utf8-string package does that I believe
05:14:19 <aristid> kwuxalot: there's a module that can convert ByteString to/from UTF8
05:14:33 <kwuxalot> benmachine: ok, because I'm reading code that uses string syntax to make ByteStrings
05:14:35 <aristid> kwuxalot: but that is not 1:1, because some byte sequences are invalid in utf8
05:14:43 <benmachine> kwuxalot: that's a GHC extension
05:14:46 <kwuxalot> benmachine: they most likely imported utf8-string?
05:14:58 <benmachine> kwuxalot: see: OverloadedStrings
05:15:08 <andreo> How can i optimize expression: (\ x y -> concatenable x && concatenable y)?
05:15:30 <benmachine> andreo: optimise for what? speed? concision?
05:15:38 <Maxdamantus> @pl \ x y -> concatenable x && concatenable y
05:15:38 <lambdabot> (line 1, column 1):
05:15:38 <lambdabot> unexpected "\SI"
05:15:38 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
05:15:44 <Maxdamantus> @pl \x y -> concatenable x && concatenable y
05:15:44 <lambdabot> (. concatenable) . (&&) . concatenable
05:15:57 <benmachine> that is ew
05:16:03 <Maxdamantus> Indeed.
05:16:10 <benmachine> :t liftA2 (&&) concatenable concatenable
05:16:11 <lambdabot> Not in scope: `concatenable'
05:16:11 <lambdabot> Not in scope: `concatenable'
05:16:12 <Maxdamantus> Maybe join something something
05:16:20 <benmachine> :t \concatenable -> liftA2 (&&) concatenable concatenable
05:16:21 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool
05:16:46 <benmachine> > join (liftA2 (&&)) (> 0) even $ 4
05:16:47 <lambdabot>   Couldn't match expected type `a -> b'
05:16:47 <lambdabot>         against inferred type `GHC.Bo...
05:16:51 <benmachine> fff
05:17:50 <Maxdamantus> @pl \f g a b -> f (g a) (g b)
05:17:51 <lambdabot> join . ((flip . ((.) .)) .) . (.)
05:18:23 <Maxdamantus> @pl \a b -> f (g a) (g b)
05:18:23 <lambdabot> (. g) . f . g
05:18:37 <Maxdamantus> @pl \g a b -> f (g a) (g b)
05:18:37 <lambdabot> flip =<< (((.) . f) .)
05:19:13 <Maxdamantus> @pl flip =<< (((.) . (&&)) .) concatenable
05:19:13 <lambdabot> flip =<< (.) . (&&) . concatenable
05:20:20 <Maxdamantus> @pl \g a b -> f (g b) (g a)
05:20:20 <lambdabot> (.) =<< flip . (f .)
05:20:41 <kwuxalot> andreo: does that answer your question?
05:20:44 <Maxdamantus> @pl \a b g -> f (g a) (g b)
05:20:44 <lambdabot> (. flip id) . ap . (f .) . flip id
05:20:56 <Maxdamantus> Meh. I'd go with that flip =<< one
05:21:05 <Maxdamantus> actually no, I'd just use the lambda
05:21:16 <kwuxalot> Maxdamantus: exactly ;)
05:21:31 * kwuxalot thinks point free programming is a little masturbatory, but useful for learning Haskell
05:21:48 <Maxdamantus> Mmm.. Seems quite fun.
05:21:53 <benmachine> what's wrong with liftA2 (&&)
05:22:08 <Maxdamantus> You're referencing concatenable twice
05:22:19 <Maxdamantus> although I guess you could join that?
05:22:20 <benmachine> nn true
05:22:23 <benmachine> *mm
05:22:31 <benmachine> what about (&&) `on` concatenable
05:22:39 <benmachine> this places constraints on the types involved
05:22:51 <Maxdamantus> (join (liftA2 (&&)) concatenable) or something
05:23:07 <benmachine> actually so does liftA2 (&&) I think
05:23:23 <Maxdamantus> :t join (liftA2 (&&)) (True &&)
05:23:24 <lambdabot> Bool -> Bool
05:23:45 <Maxdamantus> :t liftA2 (&&) (True &&) (True &&)
05:23:46 <lambdabot> Bool -> Bool
05:23:49 <benmachine> if concatenable is a polymorphic function then any way of mentioning it once is going to fail on different argument types I think
05:23:54 <Maxdamantus> Hm O_o
05:24:06 <benmachine> Maxdamantus: (True &&) == id :P
05:24:37 <Maxdamantus> @pl (True &&)
05:24:37 <lambdabot> (True &&)
05:24:49 <Maxdamantus> @pl 5 == 4
05:24:49 <lambdabot> False
05:25:01 <andreo> kwuxalot: i wonder if it is possible to somehow write the expression in shoter way, just out of curiosity
05:25:16 <andreo> i decided to remain expression as is
05:25:30 <Maxdamantus> flip =<< (.) . (&&) . concatenable
05:26:17 <Maxdamantus> :t flip =<< (.) . (&&) . (5==)
05:26:18 <lambdabot> forall a. (Num a) => a -> (a -> Bool) -> Bool
05:26:27 <Maxdamantus> Maybe not.
05:28:40 <H-asker> sipa: I honestly have no idea where to start.. First I was thinking something like using the function minimum to get the lowest from the list and then dropping it.. but I'm having a hard time implementing it
05:28:56 <Jafet> kwuxalot: rewriting an expression with combinators that can be touch-typed with your right hand?
05:29:20 <sipa> H-asker: you did write merge already?
05:29:26 <Jafet> @pl \x -> x*x
05:29:26 <lambdabot> join (*)
05:29:29 <H-asker> ya
05:29:36 <sipa> H-asker: can i see it?
05:30:14 <H-asker> http://www.pastebin.org/253314
05:30:51 <sipa> H-asker: ok, looks good
05:31:22 <H-asker> forgot http://www.pastebin.org/253317
05:31:41 <H-asker> for when it's not even lists
05:32:05 <sipa> yes
05:32:57 <sipa> now, assume you have a hypothetical function sortSmall, which takes a list and sorts it, but it only works for lists smaller than your input
05:33:07 <sipa> how would you implement msort?
05:33:12 <sipa> using sortSmall
05:34:29 <H-asker> msort xs = merge (sortSmall (take diver xs)) (sortSmall (drop diver xs)) 		where diver = (length xs) `div` 2
05:34:46 <sipa> exactly
05:34:49 <H-asker> might aswell not use pastebin :)
05:35:33 <sipa> can you modify msort so that it also supports lists of a size smaller than 2?
05:35:38 <H-asker> I'm with you this far, but it's the actuall sortSmall that has be pinned
05:35:53 <sipa> it'll come naturally, don't worry
05:37:16 <sipa> remember, you can't pass sortSmall your entire input - given your msort function now, if xs is a singleton, it won't work right now
05:39:30 <sajkr> hey, what's up with the next issue of the monad reader?
05:39:47 <sipa> H-asker: ?
05:40:39 <H-asker> I don't follow... if it's a list of only one like [3]? Then that's already sorted so msort [x] = [x]?
05:40:51 <sipa> H-asker: precisely, it's that simple
05:41:48 <sipa> now you have a function that takes a list of length L, breaks it into smaller lists, sorts those, and recombines them to the whole sorted list
05:42:00 <sipa> why not use msort itself for sorting the smaller lists?
05:42:46 <H-asker> lol!
05:43:04 <ski>   (take n as,drop n as) = splitAt n as
05:43:05 <H-asker> Love you man! :D
05:43:13 <sipa> the msort [x] = [x] is necessary for making the recursion stop
05:43:32 <ski> (you also need to handle the empty list, specially)
05:43:56 <sipa> ski: true
05:44:20 <ski> H-asker : so, instead of `take' and `drop', you can use `splitAt'
05:44:27 <ski> > splitAt 3 "abcdefgh"
05:44:28 <lambdabot>   ("abc","defgh")
05:44:56 <Jafet> > let sort [] = []; sort [x] = [x]; sort (x:xs) = sort (filter (<x) xs) ++ filter (==x) xs ++ sort (filter (>x) xs) in sort [100..1]
05:44:57 <lambdabot>   []
05:45:05 <Jafet> Shit
05:45:05 <ski> > [100 .. 1]
05:45:06 <lambdabot>   []
05:45:15 <Jafet> > let sort [] = []; sort [x] = [x]; sort (x:xs) = sort (filter (<x) xs) ++ filter (==x) xs ++ sort (filter (>x) xs) in sort $ reverse [1..100]
05:45:16 <lambdabot>   [1]
05:45:18 <ski> > [100,99 .. 1]
05:45:19 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
05:45:32 <H-asker> ski: what's the difference? I use div on length xs for any length of xs
05:45:42 <sipa> H-asker: shorter
05:45:57 <Maxdamantus> Jafet: x doesn't appear in xs in this case
05:46:05 <ski> H-asker : using `splitAt' is shorter than using both `take' and `drop' .. and possibly more efficient
05:46:11 <Maxdamantus> maybe filter (==x) (x:xs)
05:46:33 <Maxdamantus> let sort [] = []; sort [x] = [x]; sort (x:xs) = sort (filter (<x) xs) ++ filter (==x) (x:xs) ++ sort (filter (>x) xs) in sort $ reverse [1..100]
05:46:45 <ski> > let sort [] = []; sort [x] = [x]; sort (x:xs) = sort (filter (<x) xs) ++ x : filter (==x) xs ++ sort (filter (>x) xs) in sort [100,99 .. 1]
05:46:46 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:46:53 <Maxdamantus> > let sort [] = []; sort [x] = [x]; sort (x:xs) = sort (filter (<x) xs) ++ filter (==x) (x:xs) ++ sort (filter (>x) xs) in sort $ reverse [1..100]
05:46:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:48:25 <benmachine> > let sort [] = []; sort [x] = [x]; sort (x:xs) = sort lower ++ x : sort upper where (lower, upper) = partition (<= x) xs in sort $ [1,2,3,4,2,3,4,5]
05:48:26 <lambdabot>   [1,2,2,3,3,4,4,5]
05:48:31 <ski> H-asker : so you'll say something like
05:48:33 <ski>   (front,back) = splitAt (length xs `div` 2) xs
05:48:45 <ski> inside your `where'
05:48:55 <H-asker> But wouldn't splitAt just replace drop and take as I still want to split the list in half?
05:49:01 <ski> yes
05:49:18 <benmachine> it would be possible to split the list in half without counting the length, though
05:49:31 <H-asker> oh, that's elegant :)
05:49:39 <benmachine> > zipWith3 (\b t f -> if b then t else f) (cycle [True, False]) [1 .. 10] [1 .. 10]
05:49:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
05:49:40 <ski> H-asker : try to figure out how to do that, yes :)
05:49:44 * benmachine blinks
05:49:59 <benmachine> > zipWith3 (\b t f -> if b then t else f) (cycle [True, False]) [1 .. 10] [11 .. 20]
05:50:00 <lambdabot>   [1,12,3,14,5,16,7,18,9,20]
05:50:08 <benmachine> that's still not quite what I meant
05:50:09 <Jafet> Haha
05:50:58 <benmachine> > foldr (\x (xs, ys) -> (ys, x:xs)) ([], []) [1 .. 10]
05:50:59 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
05:51:01 <benmachine> yay
05:51:37 <benmachine> > foldr (\x (xs, ys) -> (ys, x:xs)) ([], []) ([1 .. 10] ++ undefined)
05:51:38 <lambdabot>   *Exception: Prelude.undefined
05:51:43 <benmachine> > foldr (\x ~(xs, ys) -> (ys, x:xs)) ([], []) ([1 .. 10] ++ undefined)
05:51:44 <lambdabot>   ([2,4,6,8,10*Exception: Prelude.undefined
05:52:30 <benmachine> > zipWith id (cycle [fst, snd]) $ foldr (\x ~(xs, ys) -> (ys, x:xs)) ([], []) ([1 .. 10] ++ undefined)
05:52:30 <lambdabot>   Couldn't match expected type `[(b, b)]'
05:52:31 <lambdabot>         against inferred type `([a]...
05:52:45 <benmachine> > zipWith id (cycle [fst, snd]) . unzip $ foldr (\x ~(xs, ys) -> (ys, x:xs)) ([], []) ([1 .. 10] ++ undefined)
05:52:46 <lambdabot>   Couldn't match expected type `[(b, b)]'
05:52:46 <lambdabot>         against inferred type `([a]...
05:52:50 <benmachine> bugger it
05:53:32 <Saizan> > zipWith id (cycle [fst, snd]) . uncurry zip $ foldr (\x ~(xs, ys) -> (ys, x:xs)) ([], []) ([1 .. 10] ++ undefined)
05:53:34 <lambdabot>   [2,3,6,7,10*Exception: Prelude.undefined
05:54:02 <ski> > "abc" `zip` "def" >>= \(x,y) -> [x,y]
05:54:03 <lambdabot>   "adbecf"
05:54:31 <ski> (that probably behaves different from what benmachine wanted, on lists of unequal length)
05:55:09 <Maxdamantus> > map ($4) $ iterate ((*2) .) id
05:55:10 <lambdabot>   [4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2621...
05:55:32 <ski> > iterate (*2) 4
05:55:33 <lambdabot>   [4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2621...
05:55:43 <Maxdamantus> > iterate ((*2) .) id !! 1000 $ 10
05:55:45 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
05:55:56 <ski> > iterate (*2) 10 !! 1000
05:55:57 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
05:56:12 <Maxdamantus> > iterate ((*2) .) id !! 100000 $ 10
05:56:16 <lambdabot>   999002093014384507944032764330033590980429139054181691771529273863145832464...
05:56:33 <ski> > iterate (*2) 10 !! 100000  -- ...
05:56:37 <lambdabot>   999002093014384507944032764330033590980429139054181691771529273863145832464...
05:57:05 * ski peers curiously at Maxdamantus
05:57:21 <benmachine> > appEndo (foldMap Endo (replicate 100000 (* 2))) 10
05:57:22 <lambdabot>   Not in scope: `foldMap'
05:57:26 <benmachine> damn it.
05:57:33 <benmachine> > appEndo (Data.Foldable.foldMap Endo (replicate 100000 (* 2))) 10
05:57:36 <lambdabot>   999002093014384507944032764330033590980429139054181691771529273863145832464...
05:58:13 <benmachine> > 2 ^ 100000
05:58:14 <lambdabot>   999002093014384507944032764330033590980429139054181691771529273863145832464...
05:58:17 <ski>   foldMap :: (b -> b -> b) -> b -> (a -> b) -> ([a] -> b)  -- something like this ?
05:58:51 <Maxdamantus> > iterate join (*2) !! 100000 $ 10
05:58:51 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
05:58:55 <benmachine> ski: something like that; the first two arguments are from the monoid instance though
05:59:19 <benmachine> ski: and (Foldable t) => t a rather than [a]
05:59:26 * hackagebot containers-unicode-symbols 0.3.0.1 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/containers-unicode-symbols-0.3.0.1 (RoelVanDijk)
06:01:43 <ski> benmachine : ok
06:02:14 <benmachine> :t Data.Foldable.foldMap
06:02:14 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
06:03:42 * ski seems to recall that being one direction of an adjunction ..
06:05:29 <ski> hm .. i suppose to go from `[] a >-{Mon}-> m' to `a >-{Set}-> U m', one just includes `a' into a singleton `[] a', passes through, and extracts the result
06:05:38 <ddarius> If we interpret (a -> m) as a "set" function, t as [] as that's basically what Foldable means, and t a -> m as a monoid homomorphism, then this could be one side of the free monoid adjunction.
06:12:32 <FeiRuoWa> i'm going home! back from indiana in a sec!
06:12:46 <FeiRuoWa> (yes a sec can be six hours)
06:17:24 <DevHC> > flip flip flip (.) (const 42) flip
06:17:25 <lambdabot>   Ambiguous type variable `f' in the constraint:
06:17:26 <lambdabot>    `GHC.Base.Functor f'
06:17:26 <lambdabot>     ...
06:17:27 <hpc> (he must be going really fast)
06:21:13 <Jafet> > let t d n p = let ns = reverse.take d.reverse$show p in if length ns == d && all (\x -> x=='1' || x=='2') ns then n : t (d+1) n p else t d (n+1) (2*p); ts = t 0 0 1 in take 9 ts
06:21:14 <lambdabot>   [0,0,9,89,89,589,3089,3089,3089]
06:22:00 <Jafet> (What's the smallest power of 2 whose last nine digits are 1s and 2s?)
06:25:06 <Twey> > head . filter (on (liftM2 (&&)) show ((>= 9) . length) $ all (`elem` "12") . take 9 . reverse) $ map (^ 2) [1 ..]
06:25:07 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
06:25:07 <lambdabot>         against inferred type ...
06:25:10 <Twey> Damn
06:30:41 <res> > let f a = map (`elem` "12") (take 9 (reverse (show a))) in lookup True (zip (map (and . f) [ 2^a | a <- [26..]]) [26..])
06:30:45 <lambdabot>   mueval-core: Time limit exceeded
06:31:39 <ski> mxc : "augustsson"
06:33:32 <Jafet> D'oh
06:34:14 <kwuxalot> it just ocurred to me that all file system path operations in Haskell are in Strings, but I'm pretty sure linux file paths are 8-bit ascii
06:35:37 <sipa> kwuxalot: i don't think so
06:36:03 <kwuxalot> sipa: are they unicode?
06:36:12 <Jafet> > let t :: Int -> Int -> Int; t n p = let ns = show p in if length ns == 9 && all (\x -> x=='1' || x=='2') ns then n else t (n+1) (mod (2*p) 10^9) in t 0 1
06:36:16 <lambdabot>   mueval-core: Time limit exceeded
06:36:17 <sipa> kwuxalot: you can create unicode-filenames; yes
06:36:31 <kwuxalot> sipa: oh... wow, when did that happen?
06:36:35 <sipa> never
06:37:05 <sipa> i suppose originally it was just "bytes, but no '\000' or '/'%
06:37:20 <Twey> > head . filter (on (liftM2 (&&)) (. show) ((>= 9) . length) $ all (`elem` "12") . take 9 . reverse) $ map (2 ^) [1 ..]
06:37:21 <ski> @type [\x -> x == '1' || x = '2',(`elem` "12")]
06:37:22 <lambdabot> parse error on input `='
06:37:24 <lambdabot>   mueval-core: Time limit exceeded
06:37:28 <ski> @type [\x -> x == '1' || x == '2',(`elem` "12")]
06:37:29 <lambdabot> [Char -> Bool]
06:37:39 <kwuxalot> sipa: right, the restriction of the '/' byte probably makes storing unicode in filenames pretty awkward
06:37:47 <sipa> no
06:37:57 <Twey> 14:36:40 < sipa> i suppose originally it was just "bytes, but no '\000' or '/'%
06:38:00 <Twey> It still is
06:38:07 <sipa> Twey: yeah, probably
06:38:11 <Twey> I think it's interpreted as UTF-8 inside the kernel
06:38:23 <sipa> i think it's not interpreted at all inside the kernel :)
06:38:25 <shachaf> kwuxalot: Some filesystems let you make files with a '/' in them.
06:38:35 <shachaf> (I think.)
06:38:47 <sipa> but some fileserver drivers may do some internal conversion from/to utf8
06:38:47 <Twey> I'm pretty sure it is.  Some kernel operations do filesystem stuff that requires separating characters &c.
06:38:52 <kwuxalot> Twey: what's the significance of the '%'?
06:38:56 <sipa> Twey: such as?
06:38:57 <Jafet> > let t :: Int -> Int -> Int -> Int; t n p d = let ns = show p in if length ns == d && all (\x -> x=='1' || x=='2') ns then n else t (n+1) (mod (2*p) (10^d)) d in map (t 0 1) [1..9]
06:39:00 <lambdabot>   [0,9,89,89,589,3089,3089,3089,*Exception: stack overflow
06:39:01 <Twey> kwuxalot: Nothing â€” sipa typo'd.
06:39:07 <Twey> sipa: Separating out file paths
06:39:17 <shachaf> Hmm, I might be wrong.
06:39:21 <sipa> Twey: looking for a '/' in UTF-8 is identical to looking for it in ASCII
06:39:24 <Twey> Yeah
06:39:31 <sipa> no need to knoz character boundaries
06:39:33 * shachaf blames Wikipedia, which is wrong too.
06:39:40 <sipa> know
06:39:42 <Twey> Well, that's so
06:39:55 <Twey> Yeah, okay
06:40:12 <Jafet> > reverse . take 20 . reverse . show $ 2^315589
06:40:13 <lambdabot>   "55526394471212122112"
06:41:03 <Twey> Big number
06:41:08 <Twey> My CPU's still crunching away :-\
06:41:26 * sipa thinks modpow would be useful here
06:41:35 <sipa> :t modPow
06:41:36 <lambdabot> Not in scope: `modPow'
06:41:38 <sipa> :t modpow
06:41:39 <lambdabot> Not in scope: `modpow'
06:41:40 <kwuxalot> basically what I'm wondering is what happens when you put unicode characters in a file name with Haskell, then look at it using regular tools
06:41:53 <kwuxalot> guess I just have to experiment and find out
06:42:04 <shachaf> kwuxalot: Probably what you'd expect.
06:42:43 <sipa> Twey: so i think there was an informal convention that filenames were ascii... without any change to the code they could at one time decide that it wasn't ascii but utf-8 (changing the limits like '250 characters' to '250 bytes')
06:42:53 <shachaf> kwuxalot: (If what you expect is TOTAL CHAOS.)
06:43:25 <kwuxalot> shachaf: well no, I wouldn't expect that, because GHC's type system is pretty well thought out
06:43:33 <shachaf> Doesn't seem to work.
06:43:56 <kwuxalot> as an aside, does anybody else have the problem of ghci neglecting to echo input after you background it and foreground it?
06:44:23 <Twey> kwuxalot: *Yes*
06:44:28 <Twey> >.<
06:44:29 <shachaf> kwuxalot: Not here.
06:44:38 <shachaf> Oh, awit.
06:44:39 <shachaf> I do.
06:44:43 <kwuxalot> it's very annoying
06:44:46 <shachaf> Why would you ever background ghci?
06:44:52 <kwuxalot> so I can run shell commands!
06:44:58 <shachaf> ?
06:45:05 <shachaf> I understand suspending it, but backgrounding it?
06:45:08 <shachaf> (As in "bg"?)
06:45:14 <kwuxalot> oh, that's what I meant (ctrl+z)
06:45:19 <shachaf> Oh.
06:45:20 <sipa> > system "echo bla"
06:45:21 <lambdabot>   Not in scope: `system'
06:45:37 <shachaf> I get that issue if I `bg` it, but not for ^Z and `fg`.
06:46:01 <shachaf> No, I'm wrong again.
06:46:07 * shachaf hadn't noticed before.
06:46:19 <ddarius> kwuxalot: :!ls
06:46:31 <ski> @type System.system
06:46:32 <lambdabot> String -> IO GHC.IOBase.ExitCode
06:46:48 <shachaf> ddarius: That's a bit limited.
06:47:00 * ddarius also gets the issue and also has never noticed before and doesn't really care.
06:47:18 <ski> shachaf : `:!bash' ?
06:47:38 <Draconx> it's most likely that ghci doesn't properly save/restore the terminal state.
06:47:45 <shachaf> ski: Still. What if you want to fg to your editor and then back to ghci?
06:48:10 * ddarius just has an editor in a separate "window."  It's faster and easier that way.
06:48:11 <Draconx> probably on resume, it's stuck in whatever terminal mode your shell left it in.
06:48:17 <n0den1te> Assuming you guys use Linux, you can use screen?
06:48:23 <Draconx> which likely has echoing disabled.
06:48:26 <n0den1te> or any of the *nix OSes. 
06:48:31 <ddarius> ("Window" in my case is fullscreen because I use XMonad in that mode with no borders or anything.
06:48:32 <ddarius> )
06:49:05 <ski> shachaf : `:edit' ?
06:49:07 <n0den1te> and you don't have to go back and forth suspending and foregrounding ghci. 
06:49:24 <shachaf> ski: Doesn't keep your editor running.
06:49:45 <Draconx> n0den1te, yes, there are millions of ways to avoid fixing buggy applications.
06:49:54 <ddarius> GHCi's :def command, by the way, is ridiculously powerful and probably underused.
06:49:54 <shachaf> ski: I'm not saying this is the ideal way to work -- just that if you *do* work this way, the ghci bug would bug you. :-)
06:50:12 <ski> .. though i suppose, using `emacsclient' as editor there probably doesn't buy much
06:50:28 <Draconx> I bet ghci didn't have this bug when it still used readline...
06:50:43 <ddarius> Draconx: I'd rather have Simon and Simon fix compiler and RTS bugs.
06:50:50 <ddarius> Draconx: But feel free to submit a patch.
06:51:02 <kwuxalot> Draconx: yeah, I don't remember it from back then
06:51:07 * ski just has the editor is a separate GNU Screen window ..
06:51:17 <alios> iam working on a Data.Binary.Get based parser. I want to construct a combinator (<+++) :: Get a -> Get a -> Get a which first looksAhead the first argument and returns the read value if scuccess full, or tries the second argument ... how do i "catch" a call of fail in a Get monad?
06:51:49 <ski> (n0den1te : btw, there's screen in Cygwin, as well)
06:52:48 <n0den1te> Draconx: I wasn't suggesting that we avoid fixing it - just a workaround, that could be useful. 
06:53:12 <n0den1te> ski: good to know. does cygwin support most of GNU apps?
06:53:29 <kwuxalot> n0den1te: the only reason I was running in to the problem was because I was re-using the terminal running ghci to run some misc. shell commands
06:53:33 <n0den1te> ski: like gnu readline, coreutils etc. 
06:53:54 * ski hasn't used it *that* much .. but mostly yes, afaiu
06:55:12 <n0den1te> kwuxalot: ah, I see
06:56:55 <shachaf> Why did ghci stop using readline? Portability?
06:57:03 <Zao> shachaf: License?
06:57:07 <shachaf> Oh.
06:57:23 <shachaf> Readline is GPL?
06:57:27 <Zao> Seems so.
06:57:45 <shachaf> Hum. Why? And how was it using readline before, then?
06:57:57 <Zao> Because it didn't have an in-house alternative?
06:58:12 <n0den1te> btw, I just came in here to ask about some good haskell tutorial (found Real World Haskell irritatingly filled with too many buzzwords - atleast the first two chapters) - stumbled upon YAHT. All's well now. :D
06:58:29 <shachaf> License issues were still there, no? :-)
06:58:32 <n0den1te> (I'm a total newbie to haskell)
06:58:54 <ski> n0den1te : some people also like
06:58:57 <shachaf> n0den1te: Hmm, YAHT might not be the best introduction to Haskell.
06:58:58 <ski> @where lyah
06:58:58 <lambdabot> http://www.learnyouahaskell.com/
06:59:03 <Zao> shachaf: I'd expect that no-one quite bothered to care before, particularly as it mostly was for ghci, wasn't it?
06:59:05 * shachaf is biased, of course.
06:59:05 <kwuxalot> n0den1te: I remember reading both of those in parallel
06:59:12 <shachaf> Zao: I suppose.
06:59:31 * shachaf remembers reading YAHT when he was first learning Haskell and finding it very confusing.
06:59:37 <shachaf> I think it does things in the wrong order.
06:59:38 <Zao> I'm sure there's plenty of cvs-ghc@ and glasgow-haskell-users@ discussion about it.
06:59:48 * ski has a vague memory that you had to manually change compile options to get readline compiled in ..
06:59:57 <kwuxalot> shachaf: I was pretty happy with Rearl World Haskell + YAHT
07:00:09 <kwuxalot> shachaf: but not happy with either by itself
07:00:21 <n0den1te> ski: I also looked at LYAH. Sadly I find it very distracting with too many pictures (I suffer from mild ADD). Is there a text only version available? 
07:00:55 <ski> n0den1te : i don't know (you might ask BONUS ..) .. you could try viewing it in a text-only browser as well, i suppose
07:01:07 * ski has never read LYAH ..
07:01:49 <n0den1te> ski: that's an idea. :)
07:01:58 <ski> (i learned from "Haskell: The Craft of Functional Programming" by Simom Thompson)
07:02:24 <ski> (also, some browsers has an option to disable image loading)
07:02:28 <kwuxalot> interesting: > h <- openFile "\x2200" WriteMode
07:02:29 <kwuxalot> *** Exception: âˆ€: openFile: does not exist (No such file or directory)
07:02:45 <Raynes> n0den1te: Part of the point of LYAH is the adorable pictures. However, if necessary, you can probably disable picture rendering in your browser one way or the other.
07:02:51 <ski> @read "\x2200"
07:02:51 <lambdabot>  
07:03:54 <kwuxalot> > "\x2200"
07:03:55 <lambdabot>   "\8704"
07:04:01 <kwuxalot> grr
07:04:42 <kwuxalot> anyway `> putStrLn "\x2200"` prints the right looking character in ghci
07:04:48 <burp> >text "\x2200"
07:04:50 <burp> > text "\x2200"
07:04:51 <lambdabot>   âˆ€
07:05:07 <kwuxalot> cool, I learned a lambdabot command
07:05:11 <akamaus> hi all
07:05:13 <burp> :t text
07:05:14 <lambdabot> String -> Doc
07:05:36 <kwuxalot> so it looks like String is the completely wrong type for FilePath
07:05:38 <hpc> kwuxalot: text is just a function; String and Doc have different show instances
07:06:31 <akamaus> what's the easiest way to determine, whether a program is runned in windows or in linux?
07:06:31 <n0den1te> Raynes: thanks. will do. 
07:06:36 <luite> n0den1te: it should be relatively easy to make a bookmarklet that can replace any image larger than a certain size by a transparent placeholder of the same size. in general, I can recommend Readability for reading websites with fewer distractions, but it doesn't remove the images in this case
07:07:33 <Saizan> akamaus: System.Info
07:07:40 <hpc> another possibility is to use lyah to test the limits of your attention span
07:07:50 <hpc> see how long you can stay engaged in the text
07:08:02 <hpc> (which usually has its own entertaining distractions anyway)
07:08:14 <hpc> then try and beat that time
07:08:55 <Jafet> How do I get the program name correctly? (System.Environment.getProgName isn't behaving correctly...)
07:09:09 <luite> reading on a different device, ipad, kindle, helps for me too, fewer distractions than a regular desktop pc, and a bit more convenient
07:09:45 <hpc> Jafet: something in env perhaps?
07:10:14 <akamaus> Saizan, what does 'os' return? Where is the spec?
07:10:30 <n0den1te> luite: I use Readability too especially on webpages with unreadable text or too many ads. That's a good js plugin. 
07:11:05 <Jafet> n0den1te: learn to embrace your highly flexible attention span, and do you like butter cookies?
07:11:40 <Jafet> hpc: System.Posix.Env? It's all environment variables there
07:11:46 <Saizan> akamaus: not sure actually
07:12:25 <akamaus> Saizan, I tried, in Ubuntu it's "linux", in winxp it's.. "mingw"
07:12:37 <n0den1te> Jafet: I'm usually good when there's uniform content on the page so I can just focus on it. But that approach fails when I try reading, uhm, "unconventional" text. 
07:12:54 <Jafet> House of Leaves?
07:13:28 <n0den1te> Jafet: ? 
07:13:50 <Jafet> Hmm. The correct program name is in GHC.Environment.getFullArgs, which seems incorrectly placed
07:15:29 <benmachine> Jafet: I think what people expect from arg0 isn't usually available on windows, or something
07:15:34 <Jafet> Actually nope, it's not in GHC.Environment.getFullArgs
07:16:24 <n0den1te> Jafet: Nope, I was referring to LYAH in this case.
07:16:35 <Jafet> Okay, I'm just tabbing through System.Posix now
07:17:09 <benmachine> Jafet: I don't think it helps, I'd be inclined to try hackage
07:18:24 <n0den1te> (I'm now onto reading LYAH after disabling images. Thanks to everyone who chimed in to help! )
07:19:08 <benmachine> Jafet: http://hackage.haskell.org/trac/ghc/ticket/3199
07:21:01 <harlekin> > nub [1,1,2,3]
07:21:02 <lambdabot>   [1,2,3]
07:21:15 <Jafet> Okay, so there's a package made specifically to work around it
07:22:48 <Jafet> A bit silly, though. I'll just use the broken getProgName for now
07:22:49 <Maxdamantus> :t nub
07:22:50 <lambdabot> forall a. (Eq a) => [a] -> [a]
07:23:45 <fxr> ?pl \rs r -> (rs ++ [r])
07:23:45 <lambdabot> (. return) . (++)
07:23:47 <Maxdamantus> > take 10 . nub $ cycle [1..10]
07:23:48 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:23:59 <Maxdamantus> > take 11 . nub $ cycle [1..10]
07:24:04 <lambdabot>   mueval: ExitFailure 1
07:24:39 <Maxdamantus> @pl (=<<) . (return .)
07:24:39 <lambdabot> fmap
07:25:10 <ski> (.. or `liftM', if you don't want an additional `Functor' constraint)
07:44:02 <wjlroe> When you run runghc Setup.hs configure - how does it know where to look for the libs it needs? because I have the haskell platform installed and cabal installed a load of stuff, but still get missing dependancies for things I have installed
07:45:58 <identity> wjlroe: what are you installing?
07:46:19 <identity> Also, try "cabal configure" -- no idea if it does anything differently, but you might as well
07:47:25 <wjlroe> identity: I'm compiling pandoc - because I'm making changes. I have already installed pandoc and all dependancies 
07:47:53 <wjlroe> oh right, cabal configure seems to work
07:47:58 <identity> oh
07:48:19 <identity> random, not-necessarily-logical action similar to kicking computer to make it work ftw
07:50:02 <wjlroe> no doubt I have some weirdness with more than one haskell installed or something horrendous 
07:54:19 <fxr> @pl \a b -> (pack a, pack b)
07:54:19 <lambdabot> (. pack) . (,) . pack
07:55:47 <Jafet> > let cfrac 1 denom = [denom]; cfrac num denom = div num denom : cfrac denom (mod num denom) in cfrac (round (pi * 10**20)) 10^20
07:55:48 <lambdabot>   No instance for (GHC.Num.Num [b])
07:55:49 <lambdabot>    arising from a use of `e_1110201020' a...
07:56:21 <ski> fxr : `curry (pack *** pack)'
07:56:42 <ski> (or `curry (join (***) pack)', if your `a' and `b' had the same type ..)
07:57:42 <hpc> i wouldn't use join even if they did have the same type
07:57:56 <hpc> it's a bit easier to see, and still saves characters
07:58:02 <Jafet> > let cfrac 1 0 = []; cfrac 1 denom = [denom]; cfrac num denom = div num denom : cfrac denom (mod num denom) in cfrac 3141592653589793 1000000000000000
07:58:03 <lambdabot>   [3,7,15,1,292,1,1,1,2,1,3,1,14,4,2,3,1,12,5,1,5,20,1,11,1,1,1,2]
07:58:08 * ski was being pointless
07:58:48 <ski> @hoogle (s -> Either [a] a) -> (s -> [a])
07:58:48 <lambdabot> No results found
08:00:31 <hpc> blah Left xs = xs
08:00:35 <hpc> blah Right x = [x]
08:00:41 <aristid> @hoogle Either [a] a -> [a]
08:00:41 <lambdabot> No results found
08:00:43 <hpc> (with parens where needed)
08:01:04 <hpc> then do blah . whatever
08:01:52 <shachaf> @ty (either id (:[]) .)
08:01:53 <lambdabot> forall b (f :: * -> *). (Functor f) => f (Either [b] b) -> f [b]
08:02:30 <hpc> ^^
08:02:40 <aristid> hmm, is there a nice way around the fact that MonadLib has no public constructors?
08:03:32 <ski> hrm
08:03:41 <ski> @hoogle (s -> Either [a] (a,s)) -> (s -> [a])
08:03:41 <lambdabot> No results found
08:03:44 <ski> .. i rather meant :)
08:04:17 <hpc> oh i see now
08:04:30 <hpc> that's a bit more interesting
08:04:30 <ski> @type unfoldr
08:04:31 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:06:13 <ski> @hoogle (a -> r -> r) -> ([a] -> r) -> ([a] -> r)
08:06:14 <lambdabot> No results found
08:06:39 <ski> (i'm not sure what that would be, except it's to the above, as `unfoldr' is to `foldr')
08:07:57 <ski> (.. or is it ?)
08:08:26 <hpc> it looks like it would represent a fold where each step can consume a variable amount of the list
08:08:48 <zygoloid> @type (either id fst .) . runStateT . many . StateT
08:08:49 <lambdabot> forall b a. (Alternative (StateT b (Either [a]))) => (b -> Either [a] (a, b)) -> b -> [a]
08:09:00 <hpc> :t many
08:09:01 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
08:09:09 <hpc> @src many
08:09:09 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:09:15 <ibt> there is no way to make a constructor or function that surrounds its argument right? like []
08:09:19 * ski tries to recall the confusomorphismic name for when a structural recursion can opt to not further recur
08:09:29 <shachaf> ibt: Not *really*. You can fake it, though.
08:09:33 <shachaf> Sometimes.
08:09:43 <ibt> shachaf: what about ||n||?
08:10:01 <zygoloid> ski: i don't think that's the one you want though
08:10:09 <hpc> it's not worth hacking that sort of syntax in
08:10:13 <hpc> and || is already taken
08:11:25 <ibt> it'd be nice if that were easy to do
08:11:47 <hpc> it would be hard on the parser, i think
08:12:15 <ibt> i'd rather it be hard on it than me
08:13:37 <ski> zygoloid : nope .. i want to continue until we get `Left' (if we don't, there should be an infinite list)
08:17:18 <ski>   cata :: Functor f => (f r -> r) -> (Mu f -> r)
08:17:25 <ski>   ana  :: Functor f => (s -> f s) -> (s -> Nu f)
08:18:06 <ski>   foo  :: Functor f => (s -> Either (Nu f) (f s)) -> (s -> Nu f)
08:18:25 <shachaf> ski: "foomorphism"?
08:18:27 <ski>   bar  :: Functor f => ((Mu f,f r) -> r) -> (Mu f -> r)
08:18:49 <ski> there's some names for `foo' and `bar', i think .. but i forget which
08:19:26 <ski> hm .. `bar' looks like primitive recursion, in the case of natural numbers
08:19:54 <alios>  iam working on a Data.Binary.Get based parser. I want to construct a combinator (<+++) :: Get a -> Get a -> Get a which first looksAhead the first argument and returns the read value if scuccess full, or tries the second argument ... how do i "catch" a call of fail in a Get monad?
08:22:14 <zygoloid> ski: i think bar might be a histomorphism?
08:22:52 * ski stares blankly
08:25:59 <ski> @type Cont . flip cata
08:26:00 <lambdabot> forall r (f :: * -> *). (Functor f) => Mu f -> Cont r (f r)
08:29:05 <ski>   apo :: Fixpoint f t => (a -> f (Either t a)) -> a -> t  -- old category-extras
08:30:42 <ski>   histo :: Fixpoint f t => ((mu fa. f (a,fa)) -> a) -> t -> a  -- old category-extras
08:30:51 <ski> those seems to be not quite the above
08:32:12 <ski>   histo :: RunComonadCofree f w => (f w a -> a) -> FixF f -> a  -- current category-extras
08:34:11 <ski>   apo :: Functor f => (a -> f (Either (FixF f)) a) -> a -> FixF f  -- current category-extras
08:34:32 * ski wonders why the assymetry
08:36:55 <ski> hrm .. oh, i should be comparing with `para', not with `histo'
08:37:17 <ski>   para :: Fixpoint f t => (f (t, a) -> a) -> t -> a  -- old category-extras
08:38:02 <ski> .. so i think `para' and `apo' are closest
08:38:42 <ski> but i wonder why the parts are flipped
08:40:30 <ski> @type uncurry (fmap . (,))
08:40:31 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
08:41:37 <dolio> ski: bar looks like paramorphism.
08:41:43 <ski> yeah .. almost
08:42:06 <ski> i'm wondering why i have `(Mu f,f r)' while `para' has `f (Mu f,r)'
08:42:47 <ski> the types say from `bar' one can derive `para'
08:43:01 <ski> (but with the correct semantics ?)
08:43:22 <dolio> Para gives you the children, so to speak.
08:43:43 <dolio> Yours looks like it gives the whole structure.
08:44:09 <ski> yeah
08:44:25 <dolio> I'm not sure why you'd want that, though.
08:44:28 <ski> (since `foo' was supposed to give the whole result)
08:45:21 <dolio> Since the premise is that you can't take the whole thing apart without the recursion combinator.
08:45:46 <ski> well .. with another recursion operator :)
08:46:35 <dolio> I guess there are some places where you want 'foo v@(C ...) = ...'.
08:46:44 <dolio> Anyhow, that doesn't really have a name as far as I knkow.
08:47:34 <dolio> And so the dual doesn't have a name either, although it's close to apo (I think that's the right one).
08:47:50 <ski> but look at `apo' .. it doesn't allow one to stop as soon as a terminating condition is reached .. you are required to generate at least one new `f'-level, afaics
08:48:17 <ski> <ski> @hoogle (s -> Either [a] (a,s)) -> (s -> [a])
08:48:35 <ski> was supposed to allow one to stop with any specified tail
08:49:06 <ski> (do i read `apo' wrong ?)
08:51:26 <wakeupsticky> hi, i'm having trouble getting a haskell editor installed on ubuntu
08:51:36 <Twey> wakeupsticky: apt-get install emacs
08:51:37 <wakeupsticky> i get errors when trying to get both yi and leksah
08:51:56 <wakeupsticky> i have emacs, but it looks somewhat complicated to get haskell working with emacs.
08:52:12 <ski> (of course one can say `apo (\s -> ..(case theTail of [] -> Nothing; a:as -> Just (a,Left as))..)' .. but that's hardly satisfying)
08:52:18 <dolio> ski: You don't need recursion combinators to write the identity function.
08:52:48 <ski> dolio : i want to avoid an extra useless traversal :)
08:53:02 <ski> (it's irritating both syntactically and operationally)
08:53:16 <Twey> wakeupsticky: Not reallyâ€¦ â€˜apt-get install haskell-modeâ€™
08:53:36 <wakeupsticky> is that all? i thought i had to move files around and edit files and etc etc
08:54:42 <Twey> wakeupsticky: Not really, when there are OS packages available
08:54:52 <wakeupsticky> M-x haskell-mode? or what?
08:55:06 <Twey> wakeupsticky: If there aren't, you just download it somewhere and stick (load "/path/to/haskell-site-file") in your .emacs or whatever
08:55:24 <Twey> wakeupsticky: Yeah, but there should be hooks to load it automatically when you switch to a .hs file
08:56:20 * hackagebot augeas 0.3.2 - A Haskell FFI wrapper for the Augeas API  http://hackage.haskell.org/package/augeas-0.3.2 (JudeNagurney)
08:56:35 <blackcustard> hmm, calling Show works fine for everything that's a member of the Show typeclass, but when I call Show on a string, like e.g. "blah" I end up getting "\"blah\"" as the output. should i treat Strings as a special case, or is there a way i can tell Show not to do that to strings?
08:57:09 <Twey> blackcustard: That's what Show does: it attempts to produce a serialisable Haskell representation of the value.
08:57:10 <ski> blackcustard : what are you trying to do ?
08:57:34 <ski> > show 496
08:57:35 <lambdabot>   "496"
08:57:44 <Twey> blackcustard: If you're formatting output, try something like a pretty-printer or â€˜printfâ€™ (from Text.Printf) instead.
08:57:45 <ski> > show "foo"
08:57:46 <lambdabot>   "\"foo\""
08:57:49 <hpc> > show (Just 4)
08:57:50 <lambdabot>   "Just 4"
08:57:54 <ski> > read "496" :: Integer
08:57:55 <lambdabot>   496
08:57:57 <blackcustard> hmm, here i'll post the func, its really short
08:57:58 <hpc> > show (Just "foo")
08:57:59 <lambdabot>   "Just \"foo\""
08:58:02 <ski> > read "\"foo\"" :: String
08:58:02 <blackcustard> i'm printing a 2x2 array
08:58:02 <lambdabot>   "foo"
08:58:18 <hpc> > show (Just Nothing)
08:58:18 <lambdabot>   "Just Nothing"
08:58:24 <hpc> > show (Just "Nothing")
08:58:24 <lambdabot>   "Just \"Nothing\""
08:58:38 <hpc> ^ is a crucial reason for strings being quoted
08:58:39 <blackcustard> http://hpaste.org/40643/printing_an_array
08:58:56 <Twey> > (show 4, show '4', show "4")
08:58:57 <lambdabot>   ("4","'4'","\"4\"")
08:59:30 <blackcustard> i end up with output with a bunch of quotation marks in it :(
08:59:42 <blackcustard> maybe i shouldn't be using Show at all, but printf like Twey said?
08:59:47 <mreh> I am confused: "Type synonym `SF' should have 2 arguments, but has been given 0 In the instance declaration for `Control.Category.Category SF'
09:00:09 <Twey> blackcustard: Show is meant for serialisation and debugging, not human-readable output.  Use a tool better-suited for the task.
09:00:37 <Twey> Text.PrettyPrint, maybe
09:00:38 <blackcustard> ah, okay
09:00:39 <mreh> Category requires a type of kind * -> * -> *? Agreed?
09:00:40 <ski> mreh : you've defined `SF' like `type SF a b = ...' ?
09:00:48 <mreh> ski: yu[
09:00:50 <mreh> yup
09:00:53 <blackcustard> i misunderstood the use of Show
09:01:01 <Twey> blackcustard: You're not alone
09:01:02 <mreh> oh
09:01:05 <ski> you need to define it like `type SF = ...' .. or use `newtype' or `data'
09:02:15 <wakeupsticky> just tried the first example from http://www.muitovar.com/gtk2hs/chap2.html
09:02:26 <wakeupsticky> i should have all the gtk packages installed
09:02:38 <wakeupsticky> error: http://pastebin.com/vTrKQRMj
09:04:32 <wakeupsticky> i got ghc with apt-get if it matters
09:10:35 <monochrom> it looks like the packages are installed twice and in a mixed up way. I would scorch-earth. (or rather, an ounce of prevention: I would not let that happen to begin with)
09:15:36 <blackcustard> i've got it printing arrays of strings correctly which is all i really needed anyway, ty!
09:18:01 <wakeupsticky> so how do i redo the installs?
09:19:08 <identity> wakeupsticky: redo what installs, exactly?
09:19:17 <wakeupsticky> gtk2hs
09:19:55 <wakeupsticky> this happened because i followed some instructions to install leksah which apparently included reinstalling gtk
09:19:59 <wakeupsticky> i didn't think it would matter
09:22:28 <wakeupsticky> trying "cabal upgrade gtk"
09:22:45 <chrisdone> wow, I just encountered a major WTF. in my Types.hs file, if I merely write "foo" on a line by itself, all of the following 40 or so types are seen as "Not in scope" for the types that refer to them before this line, and there is no error message about "foo" whatsoever O__O
09:23:03 <aristid> heh, i think i'm going to use category-extras in a real project :D
09:23:41 <chrisdone> if I put "foo" at the top of the file I get, as expected, "Foo not in scope". something fishy about the place I'm putting it. I wonder if I can reduce it to a simple test case
09:24:08 <wakeupsticky> i wonder how much time you will waste on it XD
09:24:55 <aristid> man, Control.Monad.Error sucks
09:25:43 <chrisdone> oh, done it
09:25:54 <chrisdone> data Foo = Foo Bar
09:25:54 <chrisdone> foo
09:25:54 <chrisdone> data Bar = Bar
09:25:57 <chrisdone> Not in scope: type constructor or class `Bar'
09:26:03 <chrisdone> O_O
09:26:21 <chrisdone> foo
09:26:22 <chrisdone> data Foo = Foo Bar
09:26:22 <chrisdone> data Bar = Bar
09:26:22 <chrisdone> Not in scope: `foo'
09:26:30 <chrisdone> anyone got an explanation for that?
09:26:48 <benmachine> chrisdone: the support for top-level splices leads to some weird parses
09:26:50 <benmachine> I think
09:27:12 <benmachine> (and I'm pretty sure GHC always parses them even when not using TH)
09:27:43 * benmachine wonders if there's a -ddump for just after parsing
09:28:25 * benmachine tries out -ddump-parsed
09:28:55 <chrisdone> indeed, even without TH it's this error
09:29:33 <benmachine> a lot of extensions get parsed when disabled so that GHC can tell you what to enable
09:29:42 <chrisdone> I wrote:
09:29:42 <chrisdone> parseISOTime defaultTimeLocale "%Y/%m/%d" "2010/08/15"
09:29:42 <chrisdone> and clearly forgot the `=' and started working on something else. compiled the file, BOOM, 40 types not in scope. "uh, what?"
09:30:30 <benmachine> huh
09:30:34 <benmachine> looks like it parses correctly
09:30:49 <chrisdone> what?
09:30:59 <benmachine> as in
09:31:18 <benmachine> data Foo = Foo Bar; foo; data Bar = Bar parses to data Foo = Foo Bar; $(foo); data Bar = Bar
09:31:26 <aristid> @src Writer (>>=)
09:31:26 <lambdabot> Source not found.
09:32:09 <chrisdone> benmachine: oh, yeah, if TH was enabled, it's right. but it's not enabled, so it's a bug
09:32:43 <benmachine> chrisdone: well, TH enabled or not, an error is correct behaviour, but the error message given is useless
09:33:00 <benmachine> so yeah, that's a bug, I'd say
09:33:11 <chrisdone> it should be 'foo not in scope' either way, I suppose
09:33:28 <chrisdone> TH would say it's not in scope, and vanilla haskell98 would
09:33:59 <benmachine> ooh, I found a ghc panic
09:34:03 <chrisdone> or would it be a parse error in haskell98
09:34:05 <benmachine> while fiddling with -ddump-tc
09:34:07 <chrisdone> what, with this?
09:34:10 <chrisdone> oh dear
09:34:25 <benmachine> no, by coincidence while fiddling with this
09:34:27 <benmachine> um
09:34:36 <benmachine> I *think* it would be a parse error in haskell98
09:34:39 <benmachine> but I'm not totally sure
09:34:45 <chrisdone> yeah. it's hard to check, haha
09:35:01 <chrisdone> anyone got hugs?
09:35:14 * chrisdone gives everyone a hug
09:36:51 <Jafet> "I have no hugses"?
09:36:52 <mxc> @seen snoyberg
09:36:52 <lambdabot> Unknown command, try @list
09:36:53 <preflex>  Sorry, I haven't seen snoyberg
09:36:56 <mxc> @list
09:36:56 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:37:06 <chrisdone> preflex: seen snoyberg
09:37:06 <preflex>  Sorry, I haven't seen snoyberg
09:37:38 <chrisdone> ucasano: italian haskeller? :-)
09:37:50 <ucasano> hi
09:37:59 <ucasano> yes
09:38:06 <ucasano> but I am just a beginner
09:38:17 <SirFrancisDrake> hello there
09:40:49 <chrisdone> ucasano: I'm in trento :D
09:40:58 <chrisdone> benmachine: maybe we should report this burger
09:41:02 <ucasano> chrisdone: I am in Marsala
09:41:13 <benmachine> chrisdone: maybe, I'm trying to get me a darcs GHC so I can test it there
09:41:27 <ucasano> chrisdone: a good starting point... a tutorial, for example?
09:42:30 <chrisdone> ucasano: a book?
09:42:30 <chrisdone> @google real world haskell
09:42:30 <chrisdone> @google learn you a haskell for great good
09:42:32 <lambdabot> http://www.realworldhaskell.org/
09:42:32 <lambdabot> Title: Real World Haskell
09:42:32 <lambdabot> http://learnyouahaskell.com/
09:42:33 <lambdabot> Title: Learn You a Haskell for Great Good!
09:42:41 <ski> @where yaht
09:42:42 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
09:42:42 <chrisdone> benmachine: sure
09:42:45 <ski> @where lyah
09:42:45 <lambdabot> http://www.learnyouahaskell.com/
09:42:49 <ski> @where rwh
09:42:49 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:42:56 <chrisdone> ski: mine had titles :p
09:43:00 <ski> (shorter to write)
09:43:47 <ski> @map where [yaht,lyah,rwh]
09:43:47 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
09:43:49 <benmachine> oh my goodness darcs takes ages >_>
09:44:18 <ski> @hoogle [Tutorial]
09:44:19 <lambdabot> Warning: Unknown type Tutorial
09:44:19 <lambdabot> Prelude repeat :: a -> [a]
09:44:19 <lambdabot> Data.List repeat :: a -> [a]
09:44:33 <ucasano> another little question
09:44:58 <ucasano> which haskell compiler should I use? the one from haskell.org or ghc
09:45:12 <donri> Usually GHC
09:45:19 <c_wraith> haskell.org should just be providing links to a bunch of different things.
09:45:30 <c_wraith> unless you mean the haskell platform?  that's built on GHC
09:46:13 <monochrom> I have always been against all those "perhaps you should -XGADTs", "perhaps you mean capital letter", "perhaps you need parentheses", "perhaps I know what you mean" nonsense. The only one I endorse: "perhaps you should quit programming"
09:47:16 <benmachine> monochrom: if we didn't let stupid people program sometimes we'd never get anything done
09:47:54 <benmachine> warning: . already present; omitting
09:47:55 <monochrom> "perhaps you should quit programming" /= "don't let stupid people program"
09:48:00 <benmachine> well, thanks for letting me know
09:48:38 <monochrom> let stupid people program. that's fine. just tell them the truth.
09:49:52 <monochrom> s/stupid//
09:51:07 <ucasano> c_wraith: I meant the haskell platform... under osx I am able to use it or compile the one provided from darwin ports or fink
10:00:21 <Jafet> > {- print n/d to k digits -} let printdec k (n, d) = let digits = div (n * 10^(k+1)) d; rounded = show $ div digits 10 + if mod digits 10 < 5 then 0 else 1; str = replicate (k - length rounded + 1) '0' ++ rounded in (\(int, frac) -> int ++ "." ++ frac) $ splitAt (length str - k) str in map (printdec 10) [(1, 7), (1, 77), (22, 7), (123, 5)]
10:00:21 <lambdabot>   ["0.1428571429","0.0129870130","3.1428571429","24.6000000000"]
10:01:27 <dons> harlekin: pong
10:05:06 <Jafet> > showCReal 10 (1 / 7)
10:05:07 <lambdabot>   "0.1428571429"
10:07:16 <ski> @hoogle showCRealAtBase
10:07:16 <lambdabot> No results found
10:08:53 <Jafet> All your base are CReal to us. Or something.
10:10:57 * ski . o O ( "Where is my infinite list of digits of `pi', in base `e' ?" )
10:17:31 <cathper> ski: I have the base \pi list laying around somewhere.
10:18:01 * ski was murmuring about `pi' in base `e', though ..
10:26:35 <maurer_> You don't mean e, you mean 16, which is clearly the one true base given pi's representation in it.
10:27:59 <ray> too bad 2pi is the fundamental constant, not pi
10:28:43 <Jafet> > let showAtBase base n = let digit n base = let d = floor (n/base) in (d, n-base*fromIntegral d); iter n [] = ([], n); iter n (b:bs) = let (d,r) = digit n b; (ds, r') = iter r bs in (d:ds, r'); (int, r) = iter n $ reverse (takeWhile (<=n) (iterate (*base) 1)); (frac, _) = iter r (iterate (/base) 1); in (int, frac); in take 3 $ showAtBase (pi::CReal) (e::CReal)
10:28:44 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
10:28:45 <lambdabot>         against infe...
10:28:58 <Jafet> Erm
10:29:22 <benmachine> > unfoldr (\x -> let y = floor x in Just (y, (y - x) * 16)) pi
10:29:23 <lambdabot>   Ambiguous type variable `b' in the constraints:
10:29:23 <lambdabot>    `GHC.Float.Floating b'
10:29:23 <lambdabot>  ...
10:29:33 <benmachine> > unfoldr (\x -> let y = floor x in Just (y, (y - x) * 16)) (pi :: CReal)
10:29:34 <lambdabot>   No instance for (GHC.Real.Integral Data.Number.CReal.CReal)
10:29:34 <lambdabot>    arising from...
10:29:50 <benmachine> > unfoldr (\x -> let y = fromInteger $ floor x in Just (y, (y - x) * 16)) (pi :: CReal)
10:29:53 <lambdabot>   mueval-core: Time limit exceeded
10:30:12 <benmachine> > unfoldr (\x -> let y = fromInteger $ floor x in Just (y, (y - x) * 16)) (pi :: Double)
10:30:13 <lambdabot>   [3,-3,-12,-4,-1,-7,-6,-9,-8,-9,-11,-11,-13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:30:28 <benmachine> > unfoldr (\x -> let y = fromInteger $ floor x in Just (y, (x - y) * 16)) (pi :: Double)
10:30:29 <lambdabot>   [3,2,4,3,15,6,10,8,8,8,5,10,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
10:31:04 <benmachine> > unfoldr (\x -> let y = fromInteger $ floor x in Just (y, (x - y) * 10)) (pi :: Double)
10:31:05 <lambdabot>   [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,1,1,5,9,9,7,9,6,3,4,6,8,5,4,4,1,8,5,1,6,1,...
10:31:05 <ski> > let base `inals` n = fmap loop (properFraction n) where loop n0 = d : loop n1 where (d,n1) = properFraction (base * n0) in exp 1 `inals` pi
10:31:06 <lambdabot>   (3,[0,1,0,0,0,2,1,1,0,1,0,1,0,1,0,1,0,2,0,1,0,2,1,0,1,0,2,1,1,1,2,0,0,0,0,1...
10:31:11 <ski> > let base `inals` n = fmap loop (properFraction n) where loop n0 = d : loop n1 where (d,n1) = properFraction (base * n0) in 10 `inals` pi
10:31:12 <lambdabot>   (3,[1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,1,1,5,9,9,7,9,6,3,4,6,8,5,4,4,1,8,5,1,6,1...
10:32:15 <ski> (Jafet : s/e/exp 1/ ..)
10:32:26 <benmachine> > unfoldr (\x -> let y = floor x in Just (y, (fromInteger y - x) * 16)) (pi :: CReal)
10:32:30 <lambdabot>   mueval-core: Time limit exceeded
10:32:35 * benmachine wonders why that dies
10:33:18 <ski> benmachine wants `properFraction' ..
10:33:37 <benmachine> ski: probably, yes
10:34:31 <benmachine> > unfoldr (\x -> let (i, r) = properFraction x in Just (i, r * 16)) (pi :: CReal)
10:34:34 <lambdabot>   mueval-core: Time limit exceeded
10:34:45 <benmachine> > unfoldr (\x -> let (i, r) = properFraction x in Just (i, r * 16)) (0.12 :: CReal)
10:34:49 <lambdabot>   mueval-core: Time limit exceeded
10:34:52 <benmachine> CReal hates me
10:35:06 <benmachine> > head $ unfoldr (\x -> let (i, r) = properFraction x in Just (i, r * 16)) (pi :: CReal)
10:35:07 <lambdabot>   3
10:35:09 <benmachine> great.
10:35:14 <Taslem> Is there any compiler for Haskell that's not totally text-based?
10:35:17 <benmachine> > take 5 $ unfoldr (\x -> let (i, r) = properFraction x in Just (i, r * 16)) (pi :: CReal)
10:35:18 <lambdabot>   [3,2,4,4,-1]
10:35:23 <benmachine> -1 :(
10:35:25 <Jafet> Heh.
10:35:37 <Botje> Taslem: what's wrong with that?
10:35:38 <Rotaerk> Taslem, what does that mean? haskell and pretty much every other language are text-based languages
10:35:57 <Taslem> No, I mean, the compiler itself not being based in terminals.
10:36:05 <Taslem> ie, "Visual Haskell" etc.
10:36:12 <Rotaerk> visual haskell isn't a compiler...
10:36:16 <Botje> you mean you want an IDE?
10:36:20 <Botje> check out leksah
10:36:23 <Taslem> I suppose.
10:36:23 <Botje> @where leksah
10:36:23 <lambdabot> http://www.leksah.org/
10:36:29 <Taslem> mkay...
10:36:37 <Jafet> > let showAtBase base n = let digit n base = let d = floor (n/base) in (d, n-base*fromIntegral d); iter n [] = ([], n); iter n (b:bs) = let (d,r) = digit n b; (ds, r') = iter r bs in (d:ds, r'); (int, r) = iter n $ reverse (takeWhile (<=n) (iterate (*base) 1)); (frac, _) = iter r (iterate (/base) 1); in (int, frac); in (id *** take 10) $ showAtBase (pi::CReal) ((exp 1)::CReal)
10:36:38 <lambdabot>   ([2],[0,2,0,2,1,2,0,1,0,0])
10:36:47 <monochrom> there is a haskell plugin for eclipse
10:36:47 <Jafet> (Unfortunately that is totally wrong)
10:37:40 <mornfall> If I want to provide an Iteratee API, should I be using enumerator or iteratee?
10:37:42 * benmachine still fails to understand how i ended up being negative in his properFraction
10:37:53 <benmachine> mornfall: would you hate me if I said "yes"
10:38:14 <monochrom> I think iteratee
10:38:15 <mornfall> benmachine: No, but it wouldn't help me at all.
10:38:24 <Jafet> > take 5 $ unfoldr (\x -> let (i, r) = properFraction x in Just ((i, r), r * 16)) (pi :: CReal)
10:38:25 <lambdabot>   [(3,0.1415926535897932384626433832795028841972),(2,0.2654824574366918154022...
10:38:28 <benmachine> mornfall: iteratee was the original, and my understanding is enumerator was supposed to be simpler
10:38:48 <Jafet> > take 5 $ unfoldr (\x -> let (i, r) = properFraction x in Just ((i, showCReal 5 r), r * 16)) (pi :: CReal)
10:38:49 <lambdabot>   [(3,"0.14159"),(2,"0.26548"),(4,"0.24772"),(4,"-0.03649"),(-1,"0.41615")]
10:38:51 <benmachine> mornfall: but then iteratee was simplified; I think ultimately it's just a matter of taste, or you could be super helpful and provide both
10:39:18 <mornfall> benmachine: Uh oh. :)
10:39:33 <benmachine> > properFraction (0.24772 * 16) :: (Integer, CReal)
10:39:34 <lambdabot>   (4,-0.03648)
10:39:40 <mornfall> Well, in practice I can provide both, but it's a bit stupid to depend on both. And making extra hackage libs, no thankyou.
10:39:59 <benmachine> mornfall: yeah, providing both would be a pain
10:40:46 <Watermind> hi
10:40:59 <mornfall> There's iteratee-compress, that could be handy.
10:41:02 <benmachine> > 0.24772 * 16
10:41:03 <lambdabot>   3.96352
10:41:17 <Watermind> I have ghc 6.10.4 installed
10:41:17 * benmachine thinks CReal might be just broken
10:41:33 <Watermind> I tried running cabal but says command not found
10:41:35 <aristid> Watermind: that is not the most current version.
10:41:42 <Watermind> isn't cabal supposed to come with ghc
10:41:53 <benmachine> Watermind: cabal-install does not
10:41:53 <res> map(\(a,b)->[show a,"fizz","buzz","fizzbuzz"]!!read[b])$zip[0..]$cycle"300102100120100" this can't possibly be good for my brain
10:41:58 <Watermind> aristid: I know... 6.12 is not in the opensuse repositories yet
10:41:59 <benmachine> it comes with the haskell platform though
10:42:03 <Twey> cabal does; cabal-install, which provides the â€˜cabalâ€™ shell command, doesn't.
10:42:20 <Watermind> oh I see... sort of
10:42:33 <benmachine> res: heh, cute
10:42:37 <Watermind> how can cabal be used without the command line
10:42:39 <Twey> Watermind: Cabal itself is a library
10:42:43 <dcoutts> Watermind: ghc + cabal + other stuff comes with the Haskell Platform, ghc is just the compiler.
10:42:45 <Watermind> from within haskell programs?
10:42:47 <Twey> Watermind: Yes
10:42:50 <Watermind> got it
10:42:56 <Twey> Watermind: Most programs provide a file named â€˜Setup.hsâ€™ which calls Cabal
10:43:09 <monochrom> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
10:43:32 <dcoutts> Twey: these days I mostly consider that an implementation detail, rather than a user interface
10:43:54 <Twey> dcoutts: Setup.hs?
10:43:59 <dcoutts> right
10:44:11 <Twey> Ideally, yes
10:44:16 <Watermind> oh I found it
10:44:23 <Twey> But if you have no cabal-install, it's both.  â˜º
10:44:23 <dcoutts> Twey: these days it's really a machine interface
10:44:25 <Watermind> there's two haskell repositories for opensuse
10:44:27 <maurer_> If you have the cabal-install suite, you can get by w/o Setup.hs
10:44:28 <Watermind> I had missed that
10:45:11 <Watermind> right thanks all
10:46:01 <mornfall> Ok, iteratee it is.
10:51:25 <Tomh> hey anyone here knows if lambdacube is being worked on?
10:51:36 <Jafet> > let properProperFraction x base = let d = floor (x/base) in (d, x-base*fromIntegral d); showAtBase base = dropWhile (==0) . unfoldr (\x -> let (i, r) = properProperFraction x base in Just (i, r * base)) in take 20 $ showAtBase (exp 1 :: CReal) (pi :: CReal) -- ski
10:51:39 <lambdabot>   [1,0,1,0,1,0,0,2,0,2,0,0,0,2,1,1,1,1,2,0]
10:52:09 <Watermind> what is the state of type families vs multi param. type classes?
10:52:33 <Watermind> i.e., has one been choosen over the other?
10:53:43 <benmachine> Watermind: they don't really do the same thing, you might be thinking of functional dependencies and TFs
10:53:57 <Jafet> > sum $ zipWith (\p d -> (fromIntegral d)*(exp 1)**p) [1,0..] [1,0,1,0,1,0,0,2,0,2,0,0,0,0,2,1,1,1,1,2,0]
10:53:57 <lambdabot>   3.1415826100918536
10:54:22 <hpc> > pi
10:54:23 <lambdabot>   3.141592653589793
10:54:28 <ski> Jafet : how do i know where the coefficient of the term with zero exponent is ?
10:54:35 <hpc> eek, that's a fair bit of error
10:54:49 <Jafet> Uhh, ask benmachine that
10:55:00 <benmachine> wat
10:55:02 <Jafet> Or notice that e < pi < e^2.
10:55:09 * ski asks benmachine that
10:55:31 * benmachine sticks with his response
10:55:32 <ski> Jafet : yeah, but *generally* :)
10:55:57 <Watermind> benmachine: opss... yes that's what I meant 
10:56:00 <ski> (or, i suppose one says s/generally/in general/)
10:56:18 <benmachine> ski: I think in my version, the first term had zero exponent, but wasn't guaranteed to be less than the base
10:57:55 <Jafet> > let properProperFraction x base = let d = floor (x/base) in (d, x-base*fromIntegral d); showAtBase base n = splitAt (floor (log n / log base)) $ dropWhile (==0) $ unfoldr (\x -> let (i, r) = properProperFraction x base in Just (i, r * base)) n in (id *** take 20) $ showAtBase (exp 1 :: CReal) (pi :: CReal)
10:57:59 <lambdabot>   mueval-core: Time limit exceeded
10:58:27 <Jafet> > let properProperFraction x base = let d = floor (x/base) in (d, x-base*fromIntegral d); showAtBase base n = splitAt (floor (log n / log base)) $ dropWhile (==0) $ unfoldr (\x -> let (i, r) = properProperFraction x base in Just (i, r * base)) n in (id *** take 10) $ showAtBase (exp 1 :: CReal) (pi :: CReal)
10:58:29 <lambdabot>   ([1],[0,1,0,1,0,0,2,0,2,0])
10:59:07 <Jafet> > let properProperFraction x base = let d = floor (x/base) in (d, x-base*fromIntegral d); showAtBase base n = splitAt (ceiling (log n / log base)) $ dropWhile (==0) $ unfoldr (\x -> let (i, r) = properProperFraction x base in Just (i, r * base)) n in (id *** take 10) $ showAtBase (exp 1 :: CReal) (pi :: CReal) -- yay
10:59:09 <lambdabot>   ([1,0],[1,0,1,0,0,2,0,2,0,0])
11:01:23 <Jafet> (That's wrong too; use floor (log_base n) + 1.)
11:02:33 <ski> > let properProperFraction x base = let d = floor (x/base) in (d, x-base*fromIntegral d); showAtBase base n = splitAt (floor (log n / log base)) $ dropWhile (==0) $ unfoldr (\x -> let(i, r) = properProperFraction x base in Just (i, r * base)) n in (id *** take 10) $ showAtBase (exp 1 :: CReal) (pi :: CReal)
11:02:35 <lambdabot>   ([1],[0,1,0,1,0,0,2,0,2,0])
11:02:51 <ski> looks better
11:05:31 <mornfall> Can I do different things based on whether a monad is or is not in MonadIO?
11:05:32 <Watermind> >  (2*) .  product . take 3500 . map fromRat . iterate (\q -> (denominator q+1) % (numerator q+1)) $ (2%1) 
11:05:33 <lambdabot>   3.141144014874242
11:05:41 <Watermind> >  (2*) .  product . take 5500 . map fromRat . iterate (\q -> (denominator q+1) % (numerator q+1)) $ (2%1) 
11:05:42 <lambdabot>   3.141307119153573
11:05:47 <Jafet> > let properProperFraction x base = let d = floor (x/base) in (d, x-base*fromIntegral d); showAtBase base n = splitAt (floor (log n / log base) + 1) $ dropWhile (==0) $ unfoldr (\x -> let (i, r) = properProperFraction x base in Just (i, r * base)) n in (\(int, frac) -> show int ++ "." ++ show (take (floor (53 * log 2)) frac) ++ "...") $ showAtBase (exp 1) pi
11:05:48 <lambdabot>   "[1,0].[1,0,1,0,0,2,0,2,0,0,0,2,1,1,1,1,2,0,0,2,0,1,0,1,1,2,0,0,0,1,0,1,0,2...
11:05:59 <Watermind> Jafet: what is that method?
11:06:18 <Jafet> > let properProperFraction x base = let d = floor (x/base) in (d, x-base*fromIntegral d); showAtBase base n = splitAt (floor (log n / log base) + 1) $ dropWhile (==0) $ unfoldr (\x -> let (i, r) = properProperFraction x base in Just (i, r * base)) n in (\(int, frac) -> (show =<< int) ++ "." ++ (show =<< (take (floor (53 * log 2)) frac)) ++ "...") $ showAtBase (exp 1) pi
11:06:19 <lambdabot>   "10.101002020002111120020101120001010202..."
11:06:43 <Jafet> Watermind: brute force.
11:06:49 <Watermind> eh :P
11:08:04 <sipa> mornfall: you can use IO action in them
11:08:13 <sipa> after lifting them
11:08:34 <mornfall> sipa: No, that's not what I meant. I have some 'm' which may or may not be MonadIO.
11:08:48 <mornfall> I am not sure that OverloadedInstances would let me do that, even.
11:09:55 <benmachine> mornfall: it's definitely the kind of thing that Overlapping/IncoherentInstances would be required for if it's possible at all
11:10:02 <benmachine> @quote incoherent
11:10:02 <lambdabot> sproingie says: * enables IncoherentInstances and ends up with Sarah Palin in his living room
11:10:06 <mornfall> benmachine: Incoherent, blah.
11:10:26 <benmachine> mornfall: Overlapping is also blah
11:10:28 <mornfall> Anyway, I guess I no longer need that anyway.
11:10:31 <mornfall> benmachine: Overlapping is fine.
11:10:34 <danharaj> Is there a web page with all of lambdabot's saved quotes?
11:10:35 <benmachine> nah
11:10:37 <benmachine> it's definitely blah
11:10:43 <benmachine> danharaj: I don't believe so
11:10:50 <mornfall> Incoherent obviously breaks stuff.
11:10:55 <mornfall> Overlapping doesn't. :)
11:11:00 <ddarius> danharaj: You can get a snapshot of it from the source repo.
11:11:04 <benmachine> mornfall: Overlapping means that imports can silently change the meaning of your program
11:11:14 <benmachine> which is pretty blah
11:11:16 <dmwit> ?where lambdabot
11:11:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
11:11:56 <dmwit> danharaj: try gunzipping http://www.cse.unsw.edu.au/~dons/lambdabot/State/quote
11:12:00 <Itkovian> dons: was it you who tweeted on the no paper without code idea?
11:12:42 <mornfall> benmachine: Which normally doesn't happen because you keep all the overlaps in a single module anyway.
11:12:51 <benmachine> @quote <ddarius>
11:12:51 <lambdabot> <ddarius> says: mmorrow: Nothing is evaluated until it is
11:12:52 <ski> @type let foo :: Eq (a,b) => (a,b) -> (a,b) -> Bool; foo x y = x == (fst y,snd y) in foo
11:12:52 <lambdabot> forall a b. (Eq a, Eq b) => (a, b) -> (a, b) -> Bool
11:12:57 <mornfall> Haskell means that your program may fail to terminate. That's blah too. : - P
11:13:24 <benmachine> mornfall: well, it's a matter of opinion of course
11:13:38 <danharaj> yes, top score dmwit.
11:13:39 <benmachine> mornfall: but I think that Overlapping entirely change what classes and instances are about
11:13:55 <benmachine> danharaj: probably not up-to-date mind
11:13:55 <danharaj> (and ddarius)
11:13:57 <ski> mornfall : arguably, if you call `foo' when you have done `instance Eq (Char,Bool) where (==) = ...', `foo' should use that instance, and not the synthesized one
11:14:52 <mornfall> ski: Eq is a bad example.
11:14:57 <dmwit> ?quote refactoring
11:14:57 <lambdabot> zeeeeeee says: so aside from the refactoring, there's no other (major) improvements i can make to my program
11:15:06 <ski> s/Eq/Footle/
11:15:07 <danharaj> this file is going to eat up all my study tiem.
11:18:25 <baaba> @pl \x -> \y -> (x `mod` y) == 0
11:18:25 <lambdabot> flip flip 0 . ((==) .) . mod
11:18:30 <baaba> ew
11:21:25 <aristid> @pl \a b -> map toLower a == map toLower b
11:21:26 <lambdabot> (. map toLower) . (==) . map toLower
11:21:37 <aristid> :t (==) `on` map toLower
11:21:38 <lambdabot> [Char] -> [Char] -> Bool
11:21:51 <aristid> hmm. is there a standard function for that maybe?
11:22:06 <dmwit> :t equating
11:22:07 <lambdabot> Not in scope: `equating'
11:22:42 <dmwit> There used to be Data.Eq.equating, but it seems to be gone now.
11:23:21 <ddarius> danharaj: You might also be interested in http://www.haskell.org/haskellwiki/QuotesPage
11:24:37 <aristid> dmwit: i mean specifically for case-insensitive string compare
11:25:42 <danharaj> ddarius: now I'm definitely not getting any work done in the next hour or so.
11:26:05 <djahandarie> Is the counting sort in ByteString parallel?
11:26:49 <djahandarie> It's a little hard to read what it's doing lol
11:30:09 <dmwit> http://hpaste.org/40645/getenv ?
11:33:31 <dmwit> Any clues why getEnv would fail?
11:34:04 <dmwit> Or, more to the point, why "HOST" would be in my shell's environment, but not in ghci's?
11:34:35 <aristid> dmwit: maybe it's case-sensitive?
11:34:48 <aristid> dmwit: but it REALLY sucks that getEnv uses error to signal errors
11:35:09 <dmwit> Yes, I'm sure it is. But "getEnvironment" doesn't report anything that looks like HOST, host, Host, hOsT, or any such variation.
11:35:57 <c_wraith> I think HOST is one of the magic environment variables.  There are several things that bash, at least, expands as if it was an environment variable when it's really not
11:36:34 <dmwit> To add to the mystery, this worked just fine before my system upgrade last night. =/
11:36:37 <aristid> getEnv :: String -> IO (Maybe String) *fixed*
11:37:26 <aristid> dmwit: i don't have HOST in my environment
11:37:33 <aristid> what does env | grep -i HOST print?
11:38:20 <dmwit> Okay, it seems that somewhere between last night and today, some startup file lost an "export HOST".
11:38:25 <dmwit> I'll try to find out where. =P
11:38:33 <dmwit> ...and complain to the person responsible.
11:40:23 * ddarius had forgotten about mgoetze.
11:40:26 <ucasano> > 2 + 2
11:40:27 <lambdabot>   4
11:42:38 <dbelange> more like mgoatse
11:43:22 <kmc> bravo
11:47:53 <Watermind> code.haskell.org seems reeeeally slow
11:48:20 <tommd> It usually is
11:48:42 <Watermind> oh man
11:48:57 <Watermind> slow as in the web page doesn't even load
11:49:08 <tommd> not usually this so, something's up
11:49:18 <tommd> odd seeing nothing on top
11:49:31 <tommd> lots of logged in users but no activity
11:49:42 <tommd> humm, no my mistake - not many users.
11:51:00 <danharaj> reading through this quote file, I noticed one qwe1234. Quite a character.
11:51:04 <djahandarie> Was there going to be an effort to switch around the community server?
11:51:55 <tommd> galois was getting new server hardware, but was that supposed to replace nun?  I thought it was replacing monk.
11:52:09 <dolio> @quote qwe1234
11:52:09 <lambdabot> qwe1234 says: you might pass for somebody intelligent when you keep your mouth shut.
11:52:47 <dolio> I think he stopped posting for the most part.
11:53:05 <dolio> Although, I don't read the programming reddit anymore, so I guess I wouldn't know anyway.
11:55:02 <danharaj> I read proggraming reddit to feel superior and aloof.
11:55:43 <Addy[1]> can anybody recommend a book to learn haskell?
11:56:04 <danharaj> It depends. What is your programming background?
11:56:35 <c_wraith> I recommend lyah to anyone, regardless of background...
11:56:36 <Addy[1]> well i am experienced with imperative languages
11:56:37 <dmwit> For certain programming backgrounds, nobody can recommend a book to learn Haskell. (...seems to be the implication)
11:56:37 <c_wraith> @where lyah
11:56:37 <lambdabot> http://www.learnyouahaskell.com/
11:57:09 <danharaj> If you know C I would also consider Haskell for C programmers.
11:57:17 <Addy[1]> yeah, i have been through that book...
11:57:20 <danharaj> (not a book, but there are really only two books for haskell, LYAH, and the beetle book)
11:57:28 <Addy[1]> beetle book?
11:57:49 <c_wraith> real-world haskell
11:57:52 <c_wraith> @where rwh
11:57:52 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:57:53 <danharaj> http://book.realworldhaskell.org/
11:58:02 <ddarius> "<SyntaxNinja> Fromagxo: NOT is not not in haskell, nor is "!", but rather, not."
11:58:21 <danharaj> My favorite tutorial is: http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html
12:00:15 <Addy[1]> @danharaj, Thanks, this tutorial looks helpful
12:00:15 <lambdabot> Unknown command, try @list
12:01:12 <danharaj> Addy[1]: haskell is going to be painful for you because of your imperative background. It was for me. But it's all been worth it.
12:02:04 <Addy[1]> yeah I can concur. I am having a lot of difficulties...That is one reason I am looking for a book that has practical examples in haskell
12:02:14 <Watermind> Addy[1]: how experienced are you, in programming and math...?
12:02:26 <c_wraith> Eh.  I never had any trouble switching between the two.  Haskell was initially confusing for quite different reasons.  Mostly kind-related stuff, it turned out, but I needed to learn a lot to even understand it.
12:02:57 <Addy[1]> programming: 7+ years, mathematics, not much experience...
12:03:09 <danharaj> Haskell will make you a better mathematician. :p
12:03:50 <Watermind> Addy[1]: I think I would just try diving directly into  "Algorithms: A Functional Programming Approach"
12:04:25 <Addy[1]> hmm okay, I will check out that book...
12:04:40 <Watermind> Addy[1]: it gives you the fundamentals very briefly and then straight into algorithms in haskell
12:05:37 <Watermind> it is far from trivial for a begginer
12:06:09 <Watermind> but maybe it's better than treating you like a begginer programmer
12:06:43 <Addy[1]> ok, Thanks for the info
12:06:50 <c_wraith> danharaj, I haven't seen that tutorial before.  I do have one issue with it, early-on:  "These equations behave just like ordinary equations in algebra: you can always substitute the right hand side for the left within the text of the program, and it'll evaluate to the same value. Called "referential transparency", this property makes it significantly easier to reason about Haskell programs than other languages."
12:07:41 <c_wraith> danharaj, that's *not* the definition of referential transparency.  Talking about substituting the expression for the code it evaluates to is a red herring.  It's that you can substitute it for the value it evaluates to that's important.
12:07:42 <danharaj> hey, we've all been taught little lies that get overturned later on.
12:08:18 <c_wraith> The key point is that function calls return the same thing.  talking about code expansion is very misleading.
12:10:12 <dolio> That isn't a bad description of referential transparency. It doesn't have any necessary connection to functions.
12:10:36 <c_wraith> well, it's bad in that it says "replace the code with the expanded code"
12:10:36 <danharaj> I think the key point is that computation is reduction, and reduction is substitution.
12:11:00 <c_wraith> because C programs are referentially transparent if you define it as "you can replace code with expanded code"
12:11:11 <dolio> "Being able to substitute the left hand side for the right" is pretty much exactly it.
12:11:21 <c_wraith> It need to talk about *values*, not code.
12:11:21 <ddarius> dolio is correct.
12:11:25 <dolio> You can substitute a definition for a reference thereto.
12:11:27 <ddarius> c_wraith: Incorrect.
12:11:42 <c_wraith> ddarius, then you're defining C functions to be referentially transparent
12:11:44 <dolio> It's all about inlining and CSE.
12:11:58 <dolio> Nope. You can't freely inline C functions.
12:12:16 <c_wraith> in the absense of the static keyword, you can.
12:12:24 <c_wraith> well, and recursion.
12:12:25 <dolio> y = x++ ; foo(y,y) is not the same as foo(x++,x++).
12:12:49 <c_wraith> that's not inlining the function.
12:13:02 <danharaj> That is the procedure you had an objection to, though.
12:13:03 <dolio> It's inlining the definition of y.
12:13:32 <danharaj> At the bottom level, C has primitives that can't be substituted freely.
12:13:35 <ddarius> Referential transparency means if a name is bound to something, you can replace that name with what it is bound to without changing the meaning of the code.  There's no talk of values or reduction or evaluation.
12:14:09 <ddarius> No talk of functions either for that matter.
12:14:31 <c_wraith> by that definition, the function getChar is referentially transparent.
12:14:41 <dolio> It is, in Haskell.
12:14:43 <c_wraith> well, C.  getch()
12:14:55 <ddarius> getch is.
12:15:22 <c_wraith> if you define getch() as referentially transparent, you've thrown out all of the equational reasoning properties.
12:15:39 <ddarius> c_wraith: Except that C doesn't have syntax for it, you can replace getch with it's definition.
12:16:17 <ddarius> c_wraith: What you are conflating, is the name getch and the expression getch().  The latter is neither here nor there for referential transparency.
12:16:38 <ddarius> If you want to say int x = getch() and then say x is "referentially transparent" then that would be incorrect.
12:16:58 <benmachine> ddarius: would it be correct to say that it isn't?
12:18:17 <sipa> Referential transparency and referential opaqueness are properties of parts of computer programs. An expression is said to be referentially transparent if it can be replaced with its value without changing the program (in other words, yielding a program that has the same effects and output on the same input).
12:18:22 <sipa> -- wikipedia
12:18:56 <c_wraith> eh, wikipedia is garbage for precise definitions. :)
12:19:18 <sipa> according to that definition, getch() is definitely not referentially transparent
12:19:45 <ddarius> sipa: Look at where the term "referential transparency" comes from.
12:19:56 <sipa> enlighten me
12:20:13 <ddarius> Wikipidia has it.
12:21:27 <sipa> ddarius: wikipedia has so much, i don't know what you mean precisely
12:22:08 <danharaj> wikipedia is bad. case in point: the page on "polymorphic recursion"
12:22:17 <ddarius> Wikipidia only has so many entries for "referential transparency."
12:23:33 <sipa> ddarius: aha
12:26:52 <dolio> "Works like algebra" is a fine description, too.
12:27:16 <dolio> Since algebraic reasoning about programs is roughly what one hopes to get out of referential transparency.
12:27:47 <danharaj> I prefer to reason about my programs topologically, thank you.
12:28:05 <dolio> Algebraic topologically?
12:28:29 <ddarius> Quick, what is the second homotopy group of fix?
12:28:43 * sipa googles 'homotopy group'
12:28:50 <danharaj> I don't know what is the lambda term of S^2?
12:29:15 <kmc> isn't there a relationship between continuity and computability?
12:29:23 <danharaj> kmc: vaguely?
12:29:34 <dolio> Yes, there is.
12:30:07 <ski> <http://math.andrej.com/2006/03/27/sometimes-all-functions-are-continuous/> ?
12:30:08 <danharaj> I think it's only a matter of time before someone figures out how to define chain complexes on the category of types and start doing (co)homology.
12:30:12 <kmc> must have burritos, ttyl
12:31:45 <mreh> newtype deriving seems to be unable to derive a type class with more than one parameter
12:32:31 <ski> mreh : you can do stuff like `newtype Foo = MkFoo (...) deriving C T'
12:32:59 <ski> i.e. you specify all but the last parameter, which is the one derived over the type being defined
12:33:13 <mreh> ski: such as RandomGen g => MonadSplit g
12:33:39 <ski> how is `MonadSplit' specified ?
12:34:23 * ski is unsure that the syntax supports constraints on the given parameters ..
12:34:26 <aristid> mreh: RandomGen sucks
12:34:55 <ski> i would expect you can probably use *stand-alone* deriving, though
12:35:30 <mreh> ski: okay, I'll try it
12:35:51 <ski> (possibly you need to enable both language extensions)
12:35:56 <mreh> aristid: what are the alternatives?
12:36:07 <aristid> mreh: random-fu is pretty nice
12:36:09 <mreh> I've never tried any others up to now
12:36:21 <mreh> aristid: what is it? The crappy interface?
12:36:26 <ski> @src RandomGen
12:36:26 <lambdabot> class RandomGen g where
12:36:26 <lambdabot>    next     :: g -> (Int, g)
12:36:26 <lambdabot>    split    :: g -> (g, g)
12:36:26 <lambdabot>    genRange :: g -> (Int,Int)
12:36:52 <aristid> mreh: and the fact mwc, mersenne-twister and such generators do not support it
12:37:34 <aristid> mreh: and yeah, the interface of random-fu is nicer. monadic from the start, and based on random variables. it's not perfect, but it's flexible and works well for me
12:42:23 <mreh> aristid: MonadRandom is Monadic
12:42:35 <aristid> mreh: yes, i know.
12:43:10 <aristid> mreh: and MonadRandom would be decent if it didn't have the limitations of RandomGen. i do want to be able to use mwc as a generator
12:44:13 <ski> edwardk : have you considered the variant of `apo :: Functor f => (a -> f (Either (FixF f)) a) -> a -> FixF f' that is `Functor f => (a -> Either (FixF f) (f a)) -> (a -> FixF f)' ?
12:44:33 <mreh> aristid: k
12:45:11 <mreh> phew, GeneralisedNewtypeDeriving, StandaloneDeriving, FlexibleInstances, MultiParamTypeClasses
12:45:25 * ski grins
12:52:22 <tommd> dcoutts: You have a RULES patch in your inbox.  Let me know if there's any objections as I'm keen on getting this.
12:55:42 <Nopik> hi all
12:57:15 <Nopik> i'm new to haskell, what is the best way to browse its standard libraries? e.g. i'd like to see what is in Data.Map etc. i know that there are tons of small functions defined somewhere that could help me and i do not need to write them myself.. but how do i find them? i got the haskell platform, there is some html documentation on it, not bad.. is there anything better around?
12:57:45 <dcoutts> tommd: ok
12:59:19 <boegel> is there a way to make GHC spit out 32-bit code on a 64-bit Linux x86 system?
13:00:42 <byorgey> Nopik: the easiest way is to go to Hoogle (haskell.org/hoogle) and search, it will link you to documentation
13:01:37 <Nopik> byorgey: thanks, i'll check that out
13:01:48 <int80_h> I'm looking for some extensive docs for network.curl
13:01:57 <int80_h> not much so far but I'm looking
13:02:41 <byorgey> Nopik: if you want to browse all the standard libraries that come with GHC you can see them here: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/index.html
13:02:48 <byorgey> that's what Hoogle links to
13:03:11 <byorgey> Nopik: Hackage also has documentation available for all the packages there
13:03:22 <Nopik> yeah, seems like online version of what is in platform docs
13:03:51 <byorgey> Nopik: yes.
13:04:35 <byorgey> Nopik: when you say "is there anything better around", in what sense do you mean "better"?
13:06:39 <Tomh> no one used lambdacube here? or bullet integration with haskell?
13:07:09 <Nopik> i was just trying to know what you people use, thats all.. i've find that the docs i've got could be easier to browse sometimes
13:08:17 <mux> yay, the maintainer of regex-tdfa fixed the [^]] bug
13:08:30 <mux> less than 24 hours after I reported it :-)
13:15:32 <hpc> o.O
13:15:42 <hpc> i hate to imagine what it was doing incorrectly
13:16:10 <mux> [^]] just means "anything but a closing bracket character"
13:16:17 <mux> it's special syntax, obviously
13:16:50 <hpc> ah right, forgot about that
13:17:03 <hpc> wouldn't you need to escape the ']'?
13:17:13 <roconnor_> do people on Arch not use cabal install?
13:17:14 <mux> no, otherwise it wouldn't be special syntax
13:17:37 <mux> inside [^ ... ] or [ ... ], special characters are supposed to lose their special meaning, btw
13:17:44 <hpc> ah
13:18:04 <dcoutts> roconnor_: there's reasonable reasons for using distro packages
13:18:15 <roconnor_> sure
13:18:33 <roconnor_> dcoutts: I'm thinking about how best to manage Haskell packages in Nix
13:18:48 <dcoutts> roconnor_: generate nix packages from .cabal package descriptions
13:18:54 <ville> I use clyde to get Haskell packages from AUR
13:19:09 <roconnor_> dcoutts: and not use cabal install.
13:19:12 <dcoutts> roconnor_: the distro should provide minimal QA, ie that the versions at least compile together
13:19:15 <ville> So I don't directly use cabal to install packages.
13:19:20 <roconnor_> dcoutts: it is certainly the most logical choice
13:19:37 <dcoutts> roconnor_: you can use cabal-install to help you work out which packages work together, but then save the results into nix expressions
13:20:04 <roconnor_> dcoutts: There is already a hack-nix.  I will need to look at what it does
13:20:28 <roconnor_> dcoutts: but it is nice to see another distro facing the same problem and seeing how it solves it
13:20:29 <dcoutts> roconnor_: right, the appropriate level to map cabal packages into distros is to make distro packages build packages directly via the Setup.hs interface.
13:20:52 <djahandarie> Can this process be semi-automated?
13:20:56 <dcoutts> roconnor_: people do the same for gentoo and fedora cabal2X tools
13:21:06 <dcoutts> djahandarie: yes
13:21:11 <dcoutts> most serious distros do
13:21:16 <jutaro> dcoutts: Hi, remember the PP
13:21:24 <mux> dcoutts: just wondering, are you still following gtk2hs-devel ?
13:22:12 <dcoutts> jutaro: yes, it's in my patch queue
13:22:17 <dcoutts> mux: not really
13:22:23 <mornfall> How expensive are existentials in terms of runtime overhead?
13:22:30 <tommd> They aren't.
13:22:45 <dcoutts> mornfall: 0, except for class-qualified existentials
13:23:04 <mornfall> dcoutts: Well, of course, since unqualified existentials are useless. : - P
13:23:08 <jutaro> dcoutts: I tested it with all 16 thousand hackage cabal files, so I'm quite confitend it works
13:23:11 <dcoutts> class qualified ones carry their dictionary around as an extra field in the data record
13:23:18 <dcoutts> mornfall: that's not quite true
13:23:27 <dcoutts> jutaro: yes, that's great work
13:23:28 <mornfall> What's the use for those?
13:23:36 <mux> dcoutts: do you know anything about the move from signal handlers like "onFooBar" to using the "on" combinator and a "fooBar" Signal type ?
13:23:39 <tommd> jutaro: Whats the accomplishment?
13:23:42 <mux> it seems it wasn't finished at all
13:23:48 <dcoutts> mornfall: e.g. the stream data type is an existential but no classes
13:24:10 <dcoutts> mux: I started that move about 3 years ago, are they now finally completing it>
13:24:20 <mux> dcoutts: not that I can see
13:24:23 <jutaro> toomd: Its a pretty printer for cabal files, that works for generic package descriptions, and looks reasonable.
13:24:24 <dcoutts> mux: oh well
13:24:34 <tommd> yay
13:24:51 <mux> dcoutts: some objects have both styles of handlers, some old-style handelrs are marked as deprecated but have no replacement, and tons of signals are missing :-(
13:24:51 <mornfall> dcoutts: You mean this? forall s . Unlifted s => Stream !(s -> Step a s) !s
13:24:55 <jutaro> tommd: Sorry, got it wrong
13:24:56 <identity> {-# ?? -fno-warn-unused-do-bind #-} 
13:24:58 <mux> dcoutts: I'm in the process of patching things
13:24:58 <mornfall> Looks like a class constraint to me.
13:25:01 <identity> What is the format for that again?
13:25:08 <dcoutts> mornfall: the Unlifted class is not actually needed
13:25:23 <dcoutts> mornfall: the 'classic' formulation does not use it
13:25:38 <dcoutts> identity: OPTIONS_GHC
13:25:41 <jutaro> tommd: I need it for leksah. I want to write a gui for editing cabal files
13:25:45 <mornfall> Interesting.
13:26:21 <dcoutts> mornfall: but of course the reason it does not use any classes is because it contains a function already! :-) a class constraint just implicitly means it contains other functions.
13:26:22 <identity> dcoutts: thanks
13:26:37 <mux> dcoutts: how were you planning to handle the case of similar signal names? ie "toggled" applies to both ToggleButton and CheckMenuItem
13:26:48 <mornfall> Yeah, I see.
13:27:04 <dcoutts> mux: that's where we got stuck, we were either going to use qualified names or use a type class
13:27:06 <mornfall> Is it any more expensive to go through the dictionary? :)
13:27:29 <mux> dcoutts: hahah, I see that what the cas was "telling" me was true indeed :-P
13:27:32 <dcoutts> mornfall: not much, only an indirection
13:27:35 <mux> s/cas/code/
13:27:50 <dcoutts> mux: the qualified name issue in gtk2hs and other similarly large libs is pretty annoying
13:28:06 * mux nods
13:29:01 <dcoutts> mornfall: an existential with a dictionary is basically classic OOP, the "object" has a vtable containing pointers to class dictionaries
13:29:29 <dcoutts> one field in the data constructor for each class constraint
13:29:31 <mornfall> Yeah, I would have guessed it works like that, although one can never be sure. :))
13:29:31 <dcoutts> I think
13:30:02 <mux> I sometimes wish GHC would select the appropriate function if any, using type inference to determine it
13:30:16 <mornfall> mux: !
13:30:44 <mornfall> The only reason that is not undecidable is that it's not even a valid problem. : - P
13:31:40 <copumpkin> depends how constrained your type is
13:31:59 <mux> dcoutts: another question I had was about the type of "connectGeneric". it is weirdly polymorphic in the function parameter, and accepts pretty much everything, and an incorrect usage is likely to cause a nasty crash
13:32:16 <dcoutts> mux: yes, that's why it's not exported for users
13:32:18 <mux> of course, I shouldn't even have to use connectGeneric
13:32:35 <dcoutts> it's bound at correct types in the rest of gtk2hs
13:32:43 <mux> yup, I've seen that
13:33:10 <mux> wasn't it possible to at least constrain it some more? there's a GObject parameter that will always be there no matter what IIRC
13:34:05 <dcoutts> mux: it'd still be unsafe, still could not be used directly
13:34:11 <mux> sure
13:35:12 <mux> well, at least I know how to code new signal handlers I have to add; now what to do about namespace collisions with signal handlers...
13:35:52 <mux> making the name unique by inserting the object type (ie onCheckMenuItemToggled) would be clumsy
13:36:13 <mux> resorting to strings to give the signal name would throw all the type-safety to the bin
13:36:22 <mux> and the typeclass thing sounds like it would require quite some work
13:37:18 <dcoutts> mux: the obvious thing is to do what everything else does and add the name
13:37:32 <dcoutts> ie checkMenuItemToggled :: Signal ...
13:37:47 <mux> right
13:37:59 <mux> that's what I meant, the "on" prefix was a brain-o
13:38:12 <mux> that would be a massive renaming work
13:38:24 <mux> but at least it's consistent with the rest of the source
13:38:32 <mux> that would also break the API big time
13:39:54 <identity> Hmm. I Put the GHC_OPTIONS -fno-warn-unused-do-bind pragma at the top of my source file, before modules, and I still get the warning. Anything special I need to do?
13:40:42 <identity> ah, at the top, never mind
13:44:40 <mornfall> I might be missing something substantial, but isn't fileDriver printLines "file" supposed to *do* something?
13:44:49 <sipa> :t fileDriver
13:44:50 <lambdabot> Not in scope: `fileDriver'
13:45:05 <mornfall> In the iteratee lib.
13:45:18 <mornfall> It obviously typechecks. It doesn't do anything though.
13:45:38 <ezracooper> @hoogle generate
13:45:39 <lambdabot> Test.QuickCheck generate :: Int -> StdGen -> Gen a -> a
13:45:56 <ezracooper> Should it surprise me that Hoogle still links to QuickCheck 2
13:46:12 <ezracooper> ?
13:46:22 <ezracooper> rather, to QuickCheck 1
13:46:26 <mornfall> Oh wait. :)
13:46:34 <mornfall> It's just GHCi playing tricks.
13:47:02 <mornfall> Ok, I need a run in theree.
13:47:23 <mornfall> Err no.
13:47:43 <mornfall> So I can make it work with enumPure1Chunk, but not with fileDriver huh.
13:50:16 <ezracooper> .
13:50:39 <danharaj> I'm looking for different ways of philosophically interpreting natural transformations. Anyone want to throw their 2 cents out there?
13:56:48 <mornfall> So how would I go about enumerating a list? : - )
13:57:32 <monochrom> a natural transformation is like an analogy
13:57:38 <copumpkin> mornfall: what does that mean?
13:57:45 <monochrom> (is that philosophical enough? :) )
13:58:27 <monochrom> actually look for "data refinement is lax natural transformation"
13:58:28 <mornfall> copumpkin: http://hackage.haskell.org/package/iteratee
13:59:05 <monochrom> data refinement means you preserve an abstract data type's API and even its observable behaviour but change implementation
13:59:41 <ooooPsss> hey, I want to learn a functional programming language but I'm not sure between clojure, haskell and erlang.. any help concerning that? :/
14:00:11 <dobblego> ooooPsss, sure, let me help: haskell :)
14:00:29 <mornfall> What did you expect? : - P
14:00:42 <ooooPsss> hehe thanks ;) is there a link that outlines the differences between them and what's their best use?
14:00:57 <monochrom> the revelation is that one day I went to a talk given by someone cross-discipline in both cs and psychology. he was studying "how do people use analogies to help solve problems", i.e., people want to solve one problem, recognize it's analogous to another problem they have solved, transform solution accordingly.
14:01:06 <ooooPsss> mornfall: I expect people that use a language for a reason, not just for the sake of using it ;)
14:01:24 <mornfall> ooooPsss: Oh. Might be the wrong camp, then. : - P
14:01:33 <Raynes> Clojure.
14:01:35 * Raynes runs and hides.
14:01:44 <mornfall> Is the j in there for Java?
14:01:47 <mux> dcoutts: I went to the trouble of having all my data into ByteString's for memory efficiency, yet I have to unpack them to load them into the TreeView. Do you think I should go with String's all the way? Or maybe I should ensure that I don't use my db after the TreeView has been populated so that the memory can be reclaimed
14:01:49 <monochrom> he gave a convincing mathematical definition of such analogies. the definition is exactly that of data refinement.
14:02:01 <danharaj> monochrom: that is a good one... but wouldn't analogies be more like functors? :p
14:02:03 <Raynes> mornfall: It's a JVM language.
14:02:08 <monochrom> so, lax natural transformation = analogy
14:02:09 <dcoutts> mux: the strings are only intermediate
14:02:26 <mornfall> Come on it's got no static types.
14:02:34 <Raynes> Thankfully.
14:02:53 <dcoutts> mux: are you using your own model that's an instance of a TreeModelClass ?
14:02:55 <mux> dcoutts: yeah but I suppose they are marshalled out as CString?
14:03:00 <mornfall> You could just as well use common lisp.
14:03:01 <mux> dcoutts: nope, I'm still using ListStore
14:03:04 * Raynes dances around speaking unknown languages.
14:03:34 <dcoutts> mux: ah ok, then those are actually being kept as String (only to be converted to CString :-) )
14:04:06 <dcoutts> mux: so you'd need to make your store an instance of TreeModel to keep things in a packed format
14:05:04 <mux> dcoutts: uh? but ListStore is polymorphic in the type of elements it contains, why would it keep String's around?
14:05:36 <Raynes> Well sure, if CL and Clojure were the same thing. Definitely.
14:06:09 <Nopik> btw. any good jvm port of haskell?
14:07:07 <mux> dcoutts: were you confusing with, like, the specific text model of the ComboBox object?
14:07:17 <dcoutts> mux: oh sorry, you're right, the new list store just uses projection functions, I was thinking of the old impl
14:07:23 <mux> aaah, ok
14:07:51 <dcoutts> mux: so you're ok then, it's just doing lots of conversions but should not retain lots of Strings in memory
14:08:11 <mux> ByteString -> String -> CString sounds like such a waste
14:09:11 <mux> but as long as it's not leaking memory around, it's ok I guess
14:09:20 <mux> dcoutts: thanks for the answers!
14:10:13 <mux> I'll still see if it makes sense to stop using my own haskell data types once the TreeView is populated, that would be less memory to keep around anyways
14:10:59 <mornfall> Jeez. This iteratee stuff is ugly.
14:12:11 <mux> dcoutts: hmmmm, if I am correct though, the ListStore still retains the data I gave it in a Seq datatype; so I guess it duplicates stuff?
14:12:20 <mux> oh, but Haskell's sharing should come into play
14:14:17 <dcoutts> mux: right
14:14:40 <dcoutts> mux: and it retains the data in the format you gave it, ie ByteString not String
14:15:12 <mux> dcoutts: thanks; I guess it totally makes sense to stick with ByteString in that case
14:18:42 <JoeyA> Is there a way to make it so ghci_history retains more history?
14:18:59 <JoeyA> it only does 100 lines :(
14:19:15 <danharaj> 100 lines? You could fit eight programs in that many lines.
14:19:32 <JoeyA> well, I like to use my history to grab tests that I did and put them into a test suite.
14:19:55 <JoeyA> unless I habitually copy ghci_history out, I can't do this without losing many many tests
14:20:21 <danharaj> are you using one of the libraries made for organizing tests?
14:20:33 <JoeyA> nope
14:35:20 <adimit> stupid question: the best way to represent a matrix of bits is a list of lists, right?
14:35:45 <adimit> or, if the width is known, one can concat it of course.
14:36:04 <adimit> I'm having one of these CS exam moments: why the hell can't I think straight?
14:36:25 <dolio> If efficiency is a goal, no.
14:36:30 <Twey> Best way to represent a matrix of bits would be as a matrix of bits.
14:37:09 <ClaudiusMaximus> @instances Array
14:37:09 <lambdabot> Couldn't find class `Array'. Try @instances-importing
14:37:30 <Twey> @instances-importing Data.Array Array
14:37:31 <dolio> You'd have a multi-byte overhead for each bit.
14:37:31 <lambdabot> Couldn't find class `Array'. Try @instances-importing
14:37:38 <Twey> I did!  :<
14:37:57 <ClaudiusMaximus> @instances-importing Data.Array.IArray Array
14:37:58 <lambdabot> Couldn't find class `Array'. Try @instances-importing
14:38:01 <ClaudiusMaximus> :-(
14:38:03 <adimit> Twey: well, I need to do fancy stuff, like symmetry checking (i.e. if the matrix is suare-sized, I'd like to find symmetry along the x and y axes)
14:38:21 <Twey> Well, you *definitely* don't want a list of lists, then.
14:38:45 <adimit> I had a hunch that might be an awkward format. Though it's possible :-P
14:38:46 <maurer_> adimit: If you're going to do a bunch of array stuff, do hmatrix
14:39:00 <JoeyA> Is it possible to catch an exception thrown by the error function?
14:39:01 <maurer_> s/array/matrix/
14:39:19 <adimit> maurer_: sounds interesting, I'll give it a look.
14:39:20 <ClaudiusMaximus> @pl \x -> x == transpose x
14:39:20 <lambdabot> ap (==) transpose
14:39:33 <maurer_> It works fairly well, and uses lapack etc. as a backend, so it actually has reasonable performance.
14:39:37 <Twey> adimit: Use hmatrix
14:39:47 <Twey> Oh, someone else got there first :Ã¾
14:39:52 <adimit> I also need to do special kinds of transformations. Like, put one bit one to the right, or above, or so.
14:41:12 * ddarius couldn't imagine a difficult CS exam.
14:41:35 <adimit> not everyone's a genius, I guess.
14:41:41 <sipa> Question 1: prove or disprove P=NP
14:41:55 <danharaj> That's not an exam, that's a career.
14:41:57 <Twey> adimit: Yes, all things for which a Matrix is well-suited and a list of lists is not.
14:42:17 <sipa> danharaj: agree, but i still can image such an exam :)
14:42:22 <sipa> *imagine
14:42:35 <monochrom> you can catch the error exception using the full power of Control.Exception. be aware that it is an async exception
14:42:42 <danharaj> What if the exam is on type systems and asks you to prove strong normalization of a toy system defined for the sake of the exam? That could be difficult.
14:42:42 <adimit> Twey: already thought as much.
14:42:43 <ddarius> You could request a formal proof, and then it would just be pass/fail on whether it goes through.
14:42:54 <ddarius> danharaj: That could be time consuming.
14:43:16 <adimit> thanks very much, Twey and maurer_. Data.Packed.Matrix looks exactly like what I need.
14:43:50 <adimit> Isn't there like a $1M award on proving or disproving P=NP?
14:44:02 <Twey> adimit: For mutation (e.g. the imperative transformations you were describing) see http://hackage.haskell.org/packages/archive/hmatrix/0.10.0.0/doc/html/Data-Packed-ST.html
14:44:40 <adimit> Twey: thanks!
14:45:00 <adimit> I'm just a poor computational linguist. They never taught us such fancy stuff :-(
14:46:20 <wakeupsticky> hey, i've got some better info regarding wxhaskell
14:47:07 <wakeupsticky> http://pastebin.com/6gW7bhx4
14:47:12 <wakeupsticky> ^^ after "cabal install wx"
14:47:19 <wakeupsticky> is that a more useful error message?
14:47:47 <wakeupsticky> looks like there's some sort of conflict with the containers package...?
14:49:21 <JoeyA> to answer my own question, to catch exceptions thrown by error, use catch in Control.Exception: catch (...action...) $ \(ErrorCall err) -> putStrLn ("error: " ++ err)
14:49:55 <ClaudiusMaximus> anyone know if unboxed doubles (Double#) interact badly with -fno-excess-precision (or did i make a mistake somewhere when i converted 200-odd lines of code from   DD !Double !Double   to   (# Double#, Double# #)   etc..)
14:50:09 <eikke> anyone ever used pandoc with rst, lhs and using CPP in the source file?
14:54:46 <wakeupsticky> anybody on ubuntu or debian have wxhaskell installed?
14:55:05 <wakeupsticky> one of the reasons i moved to ubuntu from windows was to get wxhaskell :(
14:55:12 <sipa> > 72 >> 5
14:55:13 <lambdabot>   No instances for (GHC.Num.Num (m a), GHC.Num.Num (m b))
14:55:13 <lambdabot>    arising from a u...
14:55:19 <sipa> > (72 >> 5) :: Integer
14:55:20 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
14:55:20 <lambdabot>         agains...
14:55:28 <sipa> damn
14:55:39 <ClaudiusMaximus> > 72 `shiftR` 5
14:55:40 <Watermind> (72 >> 5 :: Int)
14:55:40 <lambdabot>   Ambiguous type variable `a' in the constraint:
14:55:40 <lambdabot>    `Data.Bits.Bits a'
14:55:40 <lambdabot>      a...
14:55:46 <ClaudiusMaximus> > 72 `shiftR` 5 :: Integer
14:55:47 <Watermind> (72 :: Int >> 5 :: Int)
14:55:47 <lambdabot>   2
14:55:49 <Watermind> yeay
14:56:05 <Watermind> oh that wasn't mine eh
14:56:11 <Watermind> > (72 :: Int >> 5 :: Int)
14:56:12 <lambdabot>   <no location info>: parse error on input `::'
14:56:22 <Watermind> :S
14:56:38 <ClaudiusMaximus> :t (>>)
14:56:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:56:43 <aristid> Watermind: Int is no instance of Monad
14:56:46 <ClaudiusMaximus> :k Int
14:56:48 <lambdabot> *
14:56:51 <eikke> lol
14:56:56 <aristid> and also has the wrong kidn
14:56:57 <aristid> *kind
14:57:19 <Watermind> aristid: true, I misread error message :S
14:57:21 <ClaudiusMaximus> > 72 >> 5 :: IdentityT Int
14:57:22 <lambdabot>   Not in scope: type constructor or class `IdentityT'
14:57:29 <ClaudiusMaximus> > 72 >> 5 :: Identity Int
14:57:30 <lambdabot>   No instance for (GHC.Num.Num
14:57:30 <lambdabot>                     (Control.Monad.Identity.Id...
14:57:45 <aristid> ClaudiusMaximus: i think you need unsafeCoerce for that ;)
14:57:51 <ClaudiusMaximus> > return 72 >> return 5 :: Identity Int
14:57:52 <lambdabot>   No instance for (GHC.Show.Show
14:57:52 <lambdabot>                     (Control.Monad.Identity....
14:57:57 <aristid> > 72 *> 5
14:57:58 <lambdabot>   No instances for (GHC.Num.Num (f a), GHC.Num.Num (f b))
14:57:58 <lambdabot>    arising from a u...
14:58:06 <aristid> > (72 *> 5) 1
14:58:06 <sipa> > 72 `shiftL` 5 :: Integer
14:58:07 <lambdabot>   5
14:58:07 <lambdabot>   2304
14:58:29 <ClaudiusMaximus> > 42 `shiftL` (42 `shiftL` 42) :: Integer
14:58:34 <lambdabot>   mueval: ExitFailure 1
14:59:10 <Watermind> aristid: oh man... I'm so sleepy I didn't realise it was the (>>) operator...  when I saw 7 >> 5 up there I just thought it was some bit shift operation 
14:59:23 <Watermind> I should go to bed 
14:59:33 <Watermind> good night all
14:59:39 <aristid> good night
15:02:48 <Shamar> sipa if you are interessed I explored your approach and build another version of my rpn calculator that use foldr and allow to "apply" function to function
15:03:05 <Shamar> I also named you in http://www.tesio.it/2010/10/rpn-calculator-without-custom-stack.html
15:03:25 <Shamar> good night all!
15:10:33 <identity> lolwat.. xkcd guy owns xckd.com as well
15:13:59 <tommd> > iterate (`shiftL` 42) 42 :: [Integer]
15:14:00 <lambdabot>   [42,184717953466368,812398150781030805402550272,357296485266985386636543337...
15:14:24 <dmwit> > iterate (`shiftL` 2) 42 :: [Integer]
15:14:25 <lambdabot>   [42,168,672,2688,10752,43008,172032,688128,2752512,11010048,44040192,176160...
15:14:34 <tommd> > iterate (`shiftL` 2) 2 :: [Integer]
15:14:35 <lambdabot>   [2,8,32,128,512,2048,8192,32768,131072,524288,2097152,8388608,33554432,1342...
15:15:02 <aristid> > iterate (join (+)) 2 :: [Integer]
15:15:03 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
15:16:18 <identity> @src join
15:16:19 <lambdabot> join x =  x >>= id
15:16:19 <res> durr
15:16:19 <res> durr
15:16:51 <aristid> @pl \a b c d -> (a+b) + (c+d)
15:16:51 <lambdabot> flip flip (+) . (((.) . (.) . (+)) .) . (+)
15:16:51 <res> durr
15:16:51 <res> durr
15:17:11 <aristid> @pl \a b c d -> a+b + c+d
15:17:11 <lambdabot> ((((+) .) . (+)) .) . (+)
15:17:12 <res> durr
15:17:12 <res> durr
15:17:17 <identity> ....
15:17:18 <res> durr
15:17:21 <identity> wat.
15:17:21 <res> durr
15:17:23 <identity> lol.
15:17:23 <res> durr
15:17:25 <identity> bot?
15:17:25 <res> durr
15:17:31 <tommd> lets kick it.
15:17:31 <res> durr
15:17:34 <identity> let's
15:17:35 <res> durr
15:17:55 <identity> lambdabot: destroy this clown
15:17:56 <res> durr
15:18:01 <ClaudiusMaximus> @where ops
15:18:01 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:18:01 <res> durr
15:18:01 <res> durr
15:18:04 --- mode: ChanServ set +o Saizan
15:18:12 --- mode: Saizan set +q res!*@*
15:18:26 <identity> works
15:18:47 <wolfspaw> yay \o/
15:19:32 <tommd> now the ops are going to all wake up.  Its the 23 man march.
15:20:17 <tommd> @quote ClaudiusMaximus
15:20:18 <lambdabot> ClaudiusMaximus says: i hate haskell -  i seem to have started trying to make a dsp language and ended up implementing a type-level map, now i need to learn template haskell to generate all the
15:20:18 <lambdabot> types and comparison instances for me..
15:20:35 <aristid> that's a nice quote
15:20:38 <tommd> How'd that end up, Claudius?
15:20:52 <c_wraith> oh, look.  a wave of web-based spambots.  fortunately, +q works on all of them
15:21:24 <identity> c_wraith: a wave? what are you referring to other than res?
15:21:45 <ClaudiusMaximus> failure - ghc needed >3GB to compile a parallel composition like "par 8 (+) `into` par 4 (+) `into` par 2 (+) `into` (+)
15:21:48 <c_wraith> identity, Al___ name and timing are very suspicious
15:21:53 <Al___> Hey I need some help with a Haskell Problems !
15:21:58 <identity> c_wraith: hahaha.
15:22:01 <c_wraith> or I could be entirely wrong :)
15:22:11 <identity> Al___: just ask and someone will answer
15:22:28 <tommd> AI__: Prove you aren't a bot.  Give us the derivative of 4 * sin (4 x - pi/2)
15:22:29 <aristid> @pl join . join . join $ \a b c d -> (a + b) + (c + d)
15:22:29 <lambdabot> join (join (flip flip (+) =<< (((.) . (.) . (+)) .) . (+)))
15:22:46 <aristid> @pl \a -> a + a + a + a
15:22:46 <lambdabot> (+) =<< (+) =<< join (+)
15:22:54 <aristid> wow, that looks pretty nice actually
15:22:59 --- mode: Saizan set -o Saizan
15:23:22 <Al___> Use mapReduce to define the function maxMin.
15:23:26 <aristid> > iterate ((+) =<< (+) =<< join (+)) 2
15:23:27 <lambdabot>   [2,8,32,128,512,2048,8192,32768,131072,524288,2097152,8388608,33554432,1342...
15:23:53 <identity> Maybe we are all bots in a simulated universe?
15:23:58 <identity> or something.
15:24:43 <c_wraith> I'm probably a bot.  Also, Al___, that question seems a bit vague.  First, is this homework?  second, what is mapReduce?
15:25:35 <c_wraith> :t mapAccumL
15:25:36 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:25:36 <tommd> @hackage Holumbus-MapReduce
15:25:36 <tommd> Do you mean this package?
15:25:36 <lambdabot> http://hackage.haskell.org/package/Holumbus-MapReduce
15:26:23 <c_wraith> I think he probably means something along the lines of a function that's a combination of map and fold
15:26:39 <c_wraith> probably as defined in some earlier homework program.
15:27:04 <tommd> AI___: What university?
15:27:48 <c_wraith> :t mapAccumR
15:27:49 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:28:52 <Al___> mapReduce goes something like this
15:28:54 <Al___> mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn xin      | (turnAroundCond xin) = turnAroundFn xin   | otherwise =        reduceFn          (mapFn xin)          (mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn (wayAheadFn xin))
15:29:37 <Al___> I know how to do it for max and min separately, but not concurrently 
15:29:53 <tommd> AI___: How about 1) using a paste bin 2) Answering c_wraith's question.
15:29:56 <tommd> @where paste
15:29:56 <lambdabot> http://hpaste.org/ http://codepad.org/
15:30:02 <Al___> I heard someting about envelope
15:31:06 <c_wraith> for the record, we answer homework questions, we just try to help, instead of flat-out giving the answer.
15:31:33 <c_wraith> in a vague sense, your answer is probably "use a tuple to store the running minimum in its first element, and the running maximum in its last element"
15:31:41 <tommd> And it's best to start by pasting what you have, even if it isn't what you want (your min or max solution would be a start)
15:33:37 <Al___> Ok, using mapReduce maximum is defined this way:
15:33:56 <c_wraith> Al___, please use a pastebin as requested above
15:34:19 <aristid> @where hpaste
15:34:19 <lambdabot> http://hpaste.org/
15:36:07 <Al___> # Paste:#40649
15:37:10 <adimit> it's customary to post a link to your paste instead of a number.
15:37:32 <Al___> http://hpaste.org/40649/mapreduce_max
15:37:40 <Al___> sorry, new to this
15:52:02 * raek picks up Real World Haskell again
15:57:34 * hackagebot hweblib 0.1 - Haskell Web Library  http://hackage.haskell.org/package/hweblib-0.1 (AycanIrican)
16:06:32 * ddarius read "use a tuple to store" as "use a tuple store."
16:07:11 <Saizan> how much for a 3-tuple today?
16:12:38 <wjlroe> What should I do to work around this too many Maybes error? http://hpaste.org/40650/too_many_maybes
16:13:09 <enthropy> wjlroe: Maybe (IO Handle)
16:13:17 <wjlroe> oh
16:13:20 <wjlroe> is that it?
16:13:25 <wjlroe> oh dear what a fail
16:14:32 <wjlroe> enthropy: thanks for that!
16:14:35 <hpc> you might also want Maybe Handle, depending on what exactly you want to do
16:14:36 <wjlroe> works great
16:14:48 <wjlroe> it's openBinaryFile
16:15:06 <hpc> ah
16:15:16 <wjlroe> i.e I'm passing the file descriptor 
16:38:42 <IIcke> Hi, newbie here: I have imported import Data.ByteString.Char8 and now when I call readFile it says it is ambiguous Â«It could refer to either `Prelude.readFile', imported from Prelude or `Data.ByteString.Char8.readFile', imported from Data.ByteString.Char8 Â»
16:38:50 <IIcke> how to solve the ambiguity?
16:40:46 <sipa> IIcke: either by hiding one of the defitions (import Data.ByteString.Char8 hiding (readFile)), or by using fully qualified names
16:41:02 <IIcke> ok, thanks, sipa 
16:41:15 <ClaudiusMaximus> IIcke: import qualified Data.ByteString.Char8 as C8 ; .. use C8.readFile
16:41:50 <sipa> or that :p
16:41:52 <IIcke> thanks a lot, it makes sense, I have seen examples of that before :)
16:51:18 <ronyv4-home> who's doing homework?
16:51:58 <monochrom> I always do my homework.
16:53:13 <ronyv4-home> haskell homework?
16:53:58 <periodic> hm... is there a Monad transformer that's the opposite of MaybeT?  E.g. stop calculations once you have a value and continue as long as you have Nothing?
16:54:06 <periodic> Or is there a clever way to make MaybeT do that?
16:54:30 <dmwit> > mconcat [Nothing, Nothing, Just 3, Nothing, Just 4]
16:54:31 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:54:31 <lambdabot>    `Data.Monoid.Monoid a'
16:54:31 <lambdabot>  ...
16:54:38 <dmwit> > mconcat . map First $ [Nothing, Nothing, Just 3, Nothing, Just 4]
16:54:40 <lambdabot>   First {getFirst = Just 3}
16:55:22 <dmwit> Here's a similar one:
16:55:35 <dmwit> > catMaybes [Nothing, Nothing, Just 3, Nothing, Just 4]
16:55:36 <lambdabot>   [3,4]
16:55:53 <periodic> hmmm...
16:56:18 <ddarius> > msum [Nothing, Nothing, Just 3, Nothing, Just 4]
16:56:19 <lambdabot>   Just 3
16:56:28 <tommd> periodic: Just use the list monad and only evaluate the first element.
16:57:04 <tommd> Be lazy and use Haskells built in lazyness so you don't have to build custom lazy constructs in a non-lazy language.
16:57:05 <periodic> I was hoping to get semantics like "do { (when u v); (when x y) }"
16:58:16 <dmwit> > listToMaybe $ do { x <- [1..5]; guard (odd x); y <- [6..10]; guard (even y); return (x,y) }
16:58:17 <lambdabot>   Just (1,6)
16:58:25 <monochrom> guard u v `mplus` guard x y
16:58:39 <dmwit> > listToMaybe $ do { x <- [1..5]; guard (even x); y <- [6..10]; guard (odd y); return (x,y) }
16:58:40 <lambdabot>   Just (2,7)
16:58:58 <periodic> I'll re-read Data.Maybe then. 
16:59:01 <periodic> Thanks for the pointers.
17:04:41 <periodic> Guess I'll slap on a 'WriterT [a]' and 'tell . Just $ a' or 'tell Nothing', then pull the first non-Maybe.
17:04:45 <periodic> Does that sound reasonble?
17:05:02 <periodic> I've never really used monad failure, and this sounded like a case where it might work.
17:06:07 <identity> periodic: what exactly do you need to do?
17:06:21 <ddarius> Why not use the First monoid and furthermore not 'tell' anything if you are just going to tell Nothing anyway.
17:06:32 <periodic> It's basically a little AI-type thing.  Based on the state, choose what action to do.
17:06:57 <periodic> ddarius: Never heard of the First monoid...
17:07:02 <periodic> until today.
17:07:30 <identity> periodic: But what does that have to do with Maybe?
17:08:04 <ddarius> periodic: It also sounds like you are making things more complicated than they need to be, but I don't really know what the problem is.
17:08:17 <identity> If you have a series of conditions that the state has to fulfill and only want to return the first action that's possible, what you need is mplus
17:08:21 <periodic> I think you might be right that I'm over-thinking it.
17:08:31 <identity> :t mconcat
17:08:32 <lambdabot> forall a. (Monoid a) => [a] -> a
17:09:16 <periodic> ah, that sounds like what I'm looking for.
17:10:08 <identity> Not sure if mconcat is, but yeah, if your code basically does the equivalent of getAction(state) { if state == X: return someAction; if state == Y: return anotherAction; } then mplus is what you want
17:10:27 <identity> @hoogle [m a] -> m a
17:10:27 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
17:10:28 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
17:10:28 <lambdabot> Data.IntMap unions :: [IntMap a] -> IntMap a
17:10:30 <identity> msum
17:10:41 <identity> msum [Just "doThis", Just "doThat"]
17:10:46 <identity> > msum [Just "doThis", Just "doThat"]
17:10:47 <lambdabot>   Just "doThis"
17:10:54 <identity> > msum [Just "doThis", Nothing, Just "doThat"]
17:10:55 <lambdabot>   Just "doThis"
17:11:00 <periodic> looks right.
17:11:00 <identity> > msum [Nothing, Just "doThis", Nothing, Just "doThat"]
17:11:01 <lambdabot>   Just "doThis"
17:11:02 <identity> So on
17:12:04 <periodic> So I'll just msum a list where the entries are the if-then-ish things.
17:12:16 <periodic> sounds simple enough.  Thanks.
17:15:43 <identity> periodic: Well, just guard maybe what you need
17:16:14 <identity> Meh
17:16:19 <identity> you'll come up with something
17:16:40 <periodic> Yeah, just going to go back to reading Control.Monad, Data.Monoid, etc.
17:17:22 <periodic> Is there a type that represents choice?
17:17:34 <identity> What kind of choice? Either?
17:18:03 <periodic> yeah, I guess that's what I mean.
17:18:08 <identity> :info Either
17:18:13 <identity> o.o
17:18:14 <identity> meh
17:18:17 <identity> Either is a type, anyway
17:18:37 <identity> So if it's a choice between one thing or the other(Like valid output and an error message) Either is probably what you want
17:20:04 <rothwell> > putStrLn "hello"
17:20:05 <lambdabot>   <IO ()>
17:20:14 <rothwell> huzzah!
17:20:27 <rothwell> is the L.hs for this lambdabot available?
17:22:35 <identity> rothwell: I think everything is online, aye
17:22:38 <identity> not sure where, though
17:23:14 <rothwell> identity: we're currently making a lambdabot very upset on our work server
17:23:50 <ddarius> @src Either
17:23:50 <lambdabot> Source not found. Are you on drugs?
17:24:17 <rothwell> ah, http://code.haskell.org/lambdabot/State/L.hs
17:24:19 <identity> rothwell: You are? That sounds mean
17:24:28 <identity> lambdabot is very nice
17:24:40 <rothwell> identity: well, technically it's a two way street
17:24:41 <identity> when it isnt' vixen'ing or doubting your intelligence due to a typo
17:25:33 <kmc> @. elite nixon
17:25:34 <lambdabot> YOU \/\/On'T HA\/e nIXoN +O xicK AROUND 4NY/\/\Or3, 8ecAUze, 93n7|emEN, tHis Is mY |4s7 PR3sz ConFEREn(3.
17:25:52 <identity> o.o
17:26:51 * rothwell catches train
17:28:33 <Adamant> Richard Nixon <3 China
17:35:44 * eikke just integrated CppHs into pandoc, hackish
17:37:10 <Itkovian> Somebody ought to go sleep :-)
17:37:28 <Itkovian> eikke: Or aren't you in CET territory?
17:38:00 <eikke> GMT+1 i guess?
17:41:11 <dmbarbour> Anyone know how to turn a NominalDiffTime into a number of microseconds?
17:44:30 <kmc> dmbarbour, toRational
17:45:03 <Itkovian> eikke: yes
17:45:16 <dmbarbour> I'm not quite grokking the 'toRational' interface. How do I get an 'Int' out of that?
17:45:50 <dmbarbour> > toRational 33/44
17:45:51 <lambdabot>   3 % 4
17:46:14 <cabalistik> a newbie question: how do I implement nested loops in haskell?
17:46:25 <Veinor> dmbarbour: what are you trying to do?
17:46:33 <periodic> cabalistik: call a different recursive function.
17:46:40 <Zao> cabalistik: You very rarely loop explicitly.
17:46:48 <dmbarbour> Velnor: I need a threadDelay based on a NominalDiffTime
17:46:55 <cabalistik> ah ok thanks
17:47:28 <Veinor> dmbarbour: nominaldifftime has an Enum instance, right?
17:47:43 <dmbarbour> Veinor: yes, it does.
17:47:58 <dmbarbour> Not quite sure what it 'means', though.
17:48:02 <dmbarbour> Could be picoseconds.
17:48:04 <kmc> cabalistik, that's an odd question.  nested loops are a solution, not a problem.  what problem are you trying to solve?
17:48:09 <Veinor> dmbarbour: so call fromEnum on it
17:48:13 <Veinor> :t from Enum
17:48:14 <lambdabot> Not in scope: `from'
17:48:14 <lambdabot> Not in scope: data constructor `Enum'
17:48:16 <Veinor> :t fromEnum
17:48:17 <lambdabot> forall a. (Enum a) => a -> Int
17:48:32 <dmwit> DAMNIT
17:48:36 <dmwit> So freaking close.
17:48:41 <dmbarbour> > :t maxBound
17:48:41 <lambdabot>   <no location info>: parse error on input `:'
17:48:49 <dmbarbour> :t maxBound
17:48:50 <lambdabot> forall a. (Bounded a) => a
17:48:59 <dmbarbour> maxBound :: Int
17:49:07 <Veinor> > maxBound :: Int
17:49:08 <lambdabot>   9223372036854775807
17:49:16 <dmwit> I made it to the very last step on the build instructions, then got this: http://hpaste.org/40659/building_on_windows
17:49:51 <dmbarbour> > getCurrentTime
17:49:52 <lambdabot>   Not in scope: `getCurrentTime'
17:49:59 <dmwit> Has anybody else successfully used regex-posix (installed via the Haskell Platform) on Windows?
17:50:01 <Veinor> dmbarbour: lambdabot doesn't do IO at all
17:50:06 <dmbarbour> ah
17:50:19 <kmc> yep, she can evaluate IO actions, but not execute them
17:50:21 <dmwit> ?localtime lambdabot
17:50:22 <lambdabot> I live on the internet, do you expect me to have a local time?
17:50:45 * ddarius tries to write code with his eyes closed.
17:51:05 <Veinor> also, it looks like nominaldifftime has picosecond precision
17:51:49 <dmbarbour> Veinor: it does, but it says something about conversions using 'seconds'. fromEnum probably qualifies.
17:52:08 <cabalistik> kmc: Im writing a function that lists a numbers primes for n, so I need a way to "loop" through numbers less than sqrt n and also "loop" to check if these numbers divide n
17:52:14 <Veinor> dmbarbour: well, make one that you know corresponds to a day
17:52:29 <Veinor> call fromEnum on it and do an order-of-magnitude check on the result
17:52:56 <cabalistik> i think a local recursive function should do the trick
17:53:34 <dmbarbour> Veinor: (fromEnum (86400 :: NominalDiffTime)) returns 86400000000000000 
17:53:44 <Veinor> so it's picoseconds
17:53:46 <kmc> cabalistik, probably a list comprehension
17:53:49 <dmbarbour> > 24 * 60 * 60
17:53:50 <lambdabot>   86400
17:53:58 <kmc> cabalistik, for the second part you could use 'any'
17:53:59 <kmc> :t any
17:54:00 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
17:54:10 <cabalistik> hmm
17:54:17 <jmcarthur> cabalistik: typically when you need to "loop over" anything, you're talking about a list
17:55:07 <dmbarbour> I'm a bit surprised that 'Int' has that width.
17:55:12 <kmc> actually i'm not sure how the last part is a loop at all cabalistik
17:55:13 <jmcarthur> cabalistik: in haskell, laziness means that data structures are very often control structures. list is one of those.
17:55:30 <kmc> once you pick some number k < sqrt n, the divisibility test is just one step
17:55:34 <kmc> n `mod` k == 0
17:56:05 <cabalistik> hmm ok
17:56:17 <Veinor> > 9223372036854775807 / 86400000000000000
17:56:18 <lambdabot>   106.75199116730064
17:56:45 <Veinor> you can also use toInteger to work with Integers, which are unlimited-width
17:57:17 <ddarius> Never use toInteger.
17:57:35 <Veinor> ?
17:57:43 <kmc> dmbarbour, Int is only guaranteed to go up to 2^29 - 1
17:57:51 <dmbarbour> kmc: thanks
17:57:52 <kmc> dmbarbour, but in GHC it is a full machine word
17:58:02 <kmc> 2^31 - 1 on 32-bit; 2^63 - 1 on 64-bit
17:58:12 <Veinor> ddarius: what if you need to work with NominalDiffTimes that are longer than... 100 days, or whatever
17:58:35 <dmbarbour> NominalDiffTime isn't an integral. That's a bit odd, given that it has a fromEnum instance.
17:59:21 <ddarius> Veinor: Then use fromIntegral.  You never, ever need any numeric conversions besides fromIntegral and realToFrac (and the rounding function if you count them.)
18:00:12 <dmbarbour> :t numerator
18:00:13 <lambdabot> forall a. (Integral a) => Ratio a -> a
18:00:21 <dmbarbour> :t toRational
18:00:22 <lambdabot> forall a. (Real a) => a -> Rational
18:00:35 <dmbarbour> :t Rational
18:00:35 <lambdabot> Not in scope: data constructor `Rational'
18:01:35 <dmbarbour> Yeah, it looks like toRational is the best bet, since I don't want to run afoul of my 2^29-1 limit
18:02:26 <ddarius> Don't use toRational either, use realToFrac albeit you may need to explictly give the result type.
18:03:06 <dmbarbour> :t realToFrac
18:03:07 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
18:04:11 <dmbarbour> ddarius: could you explain why?
18:06:19 <hrmlgon2> :t map
18:06:20 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:06:21 <hrmlgon2> chat.freenode.org: [Mon Oct 18 01:05:36 2010] <#_/res> #haskell
18:06:56 <ddarius> Because it and fromIntegral are the one-stop numeric conversion functions.  Remember them and forget everything else.  Also, though it probably doesn't matter most of the time, there are rewrite RULES that make those efficient (i.e. they use direct conversions).
18:07:40 <tommd> Proof that I'm brian-fried.
18:08:07 <tommd> I just tried to figure out why what I thought was a scan wouldn't have the right signature.  Squinting at it for a minute I realize all I want is a map.  Wow - time for a break.
18:10:40 <dmbarbour> > (realToFrac (307 % 21)) :: Double
18:10:41 <lambdabot>   14.619047619047619
18:11:27 <ddarius> It's not necessary to specify Double because Double is the default default.
18:11:39 <ddarius> (for fractional values)
18:11:45 <dmbarbour> > realToFrac (307 % 21)
18:11:46 <lambdabot>   14.619047619047619
18:13:04 <dmbarbour> Thank you, ddarius
18:14:44 <dmbarbour> > truncate $ realToFrac (307 % 21)
18:14:44 <lambdabot>   14
18:15:48 <ddarius> The Real class is also extremely misnamed.
18:17:30 <dolio> All real numbers can be converted to rational  numbers.
18:17:45 <dolio> I think that's one of the parts of the definition of the real numbers.
18:20:04 <dmbarbour> :t fromIntegral
18:20:05 <lambdabot> forall a b. (Integral a, Num b) => a -> b
18:20:27 <dmbarbour> >fromIntegral (3::Integer) :: Int
18:21:32 <dmbarbour> > fromIntegral (3 :: Integer) :: Int
18:21:33 <lambdabot>   3
18:22:40 <ddarius> Integer is the other default default, so the inner type annotation is unnecessary.  Also, numeric literals are overloaded so 3 :: Int would be equivalent to that.
18:24:17 <ddarius> > 3 :: (Int, Int, (Int, Int))
18:24:18 <lambdabot>   (3,3,(3,3))
18:25:07 <enthropy> > 2 :: (Double, Int)
18:25:08 <lambdabot>   (2.0,2)
18:25:31 <dmbarbour> ddarius: I know about numeric literals. I was more checking the conversion.
18:25:39 <dmbarbour> :t truncate
18:25:40 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:25:53 <dmbarbour> :t (truncate 3.8)
18:25:53 <lambdabot> forall b. (Integral b) => b
18:26:14 <ddarius> dmbarbour: I figured, but that was a boring case to check.
18:26:30 <ddarius> > 29083240893240893240893240893202323949289585 :: Int
18:26:31 <lambdabot>   -2860967013714689935
18:27:10 <dmbarbour> > maxBound + (1 :: Int)
18:27:11 <lambdabot>   -9223372036854775808
18:29:49 <ddarius> There are also Int32/64 and Word32/64 types (and other bitwidths) if you want a guaranteed number of bits.
18:30:10 <tommd> Int32 + 4
18:30:20 <tommd> It would be nice to have a generic IntX
18:30:45 <tommd> The LargeWord has some support for that, but I see the concept reinvented in numerous places (even saw a Word12 once)
18:33:13 <stepkut> does this system-wide ghc package.conf file still exist? Or do we only have the individual .conf files in the package.conf.d directory now ?
18:39:25 <stepkut> nm. 
18:43:47 <dmbarbour> tommd: I think you can get specific integer types from package Data.Int
18:44:20 <dmbarbour> oh, nm. I see you were looking more for 'Int27'
18:44:32 <dmbarbour> or other arbitrary types.
18:44:40 <dmbarbour> 3 :: Int8
18:44:44 <dmbarbour> > 3 :: Int8
18:44:45 <lambdabot>   3
18:44:54 <monochrom> Int29.39485
18:44:59 <dmbarbour> maxBound :: Int8
18:45:23 <dmbarbour> monochrom: that's exactly what I need.
18:45:28 <dmbarbour> > maxBound :: Int8
18:45:29 <lambdabot>   127
18:45:45 <monochrom> Int63.99999999 :)
18:46:17 <dmbarbour> > maxBound :: Word8
18:46:18 <lambdabot>   255
18:46:39 <dmbarbour> IntPi ?
18:47:51 <dmwit> IntAsGoodAs64
18:49:59 <identity> Anyone recognize this as some serialization format or some such, like JSON? [[A sketch of an Island]]\n{{Alt:Hello, island}}
18:53:11 <dmwit> identity: Could it be mediawiki markup?
18:54:02 <identity> dmwit: This actually comes delivered with JSON, and on the 'older set' the "alt" json parameter is empty and the alt is instead inside other stuff, embedded like that
18:54:06 <identity> so I don't think it's mediawiki markup
18:54:15 <identity> but it'll be a female canine to parse
18:57:07 <ebensh> 'ello all :)
18:57:36 <dmwit> hi5ya
18:58:24 <ebensh> i take your hi5 and return a hi6
18:58:38 <ebensh> it requires two hands, or knowledge of sign language, or a birth oddity
18:58:57 <dmwit> Hey, not bad! 20% return every 30s -- I'll have to invest a bit more in this thing.
18:59:25 <dmwit> > 1.2 ^ (365 * 24 * 60 * (60 / 30))
18:59:26 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:59:26 <lambdabot>    `GHC.Real.Fractional t'
18:59:26 <lambdabot> ...
18:59:31 <dmwit> > 1.2 ^ (365 * 24 * 60 * (60 `div` 30))
18:59:32 <lambdabot>   Infinity
18:59:41 <dmwit> In a year, I'll have infinity money!
18:59:59 <ebensh> always a good decision :)
19:00:14 <ebensh> i'm a bit confuzzled on haskell syntax for type classes and instances
19:00:26 <ebensh> if i could ask for some help (and then receive some help) i would appreciate it
19:00:38 <dmwit> Of course.
19:00:44 <dmwit> You don't even have to ask to ask. Just ask.
19:01:02 <ebensh> :p
19:01:05 <ebensh> okay, in short
19:01:13 <ebensh> i'm working on byorgey's class assignment
19:01:36 <ebensh> we have an ExprT type that has the constructors Lit Int, Add ExprT ExprT, and Mul ExprT ExprT
19:01:50 <ebensh> and we're now trying to write a new type Expr with constructors lit, add, and mul
19:02:14 <ebensh> his aid in this is that :t mul (add (lit 2) (lit 3)) (lit 4) is Expr a => a
19:02:35 <dolio> byorgey's bullying people into doing his homework again?
19:02:38 <ebensh> hahaha
19:02:39 <ebensh> yes, dolio
19:02:52 <ebensh> well, his assigned homework - not the homework that he himself must complete for a grade
19:02:52 <dmwit> Are you sure you've got all the words right? Did you mean, "trying to write a new *class* Expr with *methods* lit, add, mul"?
19:03:02 <ebensh> >_>
19:03:05 <ebensh> let me check
19:03:13 <ebensh> type class*
19:03:14 <ebensh> not type
19:03:20 <dmwit> Yes, okay.
19:03:23 <ebensh> and ... yes. methods
19:03:25 <ebensh> my bad >_<
19:03:31 <dmwit> Great, we're with you. What have you tried?
19:03:40 <ebensh> okay, so i've tried a few things
19:03:49 <ebensh> i feel the class declaration should start
19:03:51 <ebensh> class Expr a where
19:03:55 <dmwit> hpaste.org
19:03:58 <ebensh> ah my bad
19:03:59 <ebensh> kk 1 sec
19:05:21 <ebensh> http://hpaste.org/40660/expr is my current iteration
19:05:34 <ebensh> i'm not sure if lit should be a -> ExprT or Expr
19:05:45 <ebensh> but when i use Expr, i get other issues
19:06:20 <dmwit> ah, okay, maybe this clue will help
19:06:39 <dmwit> You should write the types of the methods using "a", keeping in mind that later, we will be allowed to substitute "ExprT" for "a".
19:06:56 <ebensh> oooh
19:07:07 <dmwit> So, for example, if we have Lit :: Int -> ExprT, then we'd want something like lit :: Int -> a in the class declaration.
19:07:20 <tehgeekmeister> does it take forever and a day to build the haskell platform?
19:07:33 <tehgeekmeister> apparently there's no package for the latest ubuntu yet.
19:07:37 <dolio> I don't think it took that long when I did it.
19:07:42 <ebensh> should i assume Int for the lowercase lit or generalize it out to Num?
19:08:10 <dmwit> ebensh: I haven't looked at his assignment myself, but my guess is that the simplest thing (i.e. specializing to Int) will be the right solution. =)
19:08:21 <ebensh> kk thanks :)
19:08:27 <dolio> If you generalize it, you won't be able to implement it with Lit later.
19:08:33 <dolio> Because Lit only takes an Int.
19:08:42 <adu> hi dolio 
19:08:50 <dmwit> ?hoogle Num a => a -> b
19:08:51 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
19:08:52 <lambdabot> Foreign.Marshal.Utils toBool :: Num a => a -> Bool
19:08:52 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
19:09:00 <dmwit> unsafeCoerce ;-)
19:09:12 <dolio> How could I forget that?
19:09:21 <ebensh_> so then... when creating an instance of Expr, would it have type ExprT or Int?
19:09:33 <ebensh_> that is, "instance Expr Int where" or "instance ExprT Int where"
19:09:42 <ebensh_> i believe the latter, correct?
19:09:42 <dmwit> neither =)
19:09:45 <ebensh_> oh poop.
19:10:00 * ebensh_ shakes fist at haskell!!!
19:10:02 <dmwit> ExprT is a type that provides all the methods that Expr demands.
19:10:09 <adu> hi dmwit 
19:10:10 <dmwit> So it would be "instance Expr ExprT".
19:10:13 <dmwit> adu: hiya!
19:10:21 <adu> ebensh: why?!?
19:10:28 <ebensh_> oh whoops; that's what i meant to type in the second instance
19:10:38 <ebensh_> when i c+p'd i wiped the Expr instead of the Int, haha
19:10:40 <adu> how goes the haskell world today?
19:10:55 <dmwit> I finally got wyvern built on Windows!
19:10:56 <dmwit> yay
19:11:21 <dmwit> Rumors that Haskell is cross-platform have been greatly exaggerated.
19:11:25 <ebensh_> ahhh many thanks
19:11:30 <ebensh_> dmwit: what is wyvern?
19:11:44 <dmwit> ebensh_: It's a program to help play go on dragongoserver.net
19:11:50 <adu> dmwit: this one: http://dmwit.com/wyvern/ ?
19:11:52 <dmwit> http://dmwit.com/wyvern
19:11:54 <dmwit> adu: That one!
19:12:04 <adu> you're very googleable :)
19:12:09 <dmwit> =D
19:12:18 <adu> i'm not: andrewrobbins.co.cc
19:13:26 <adu> i need to update my software page with my Android app
19:13:33 <ebensh> can you please resend the advice you gave me ^--- about using a so we could replace it as ExprT later?
19:13:42 <ebensh> when i nav'd away it wiped the channel history window
19:13:51 <dmwit> adu: Oh, we've met at a Hackathon, haven't we?
19:13:58 <adu> dmwit: yes, in PA
19:14:13 <dmwit> 22:06 < dmwit> You should write the types of the methods using "a", keeping in mind that later, we will be allowed to substitute "ExprT" for "a".
19:14:20 <ebensh> many thanks :)
19:15:45 <dmwit> adu: Oh man, I just finished the three EV:Override objectives for the first time a few days ago.
19:15:55 <dmwit> what a classic game
19:16:22 <ebensh> EV was delightfully fun :)
19:16:38 <ebensh> i played nova, though
19:16:46 <ebensh> was override better?
19:16:47 <identity> @pl (\x -> f x == n)
19:16:47 <lambdabot> (n ==) . f
19:16:51 <identity> thanks
19:17:00 <adu> dmwit: I love EV
19:17:19 <dmwit> I'm not sure whether EV or EV:O were better. They were both quite fun. =)
19:17:54 <ebensh> dmwit: EV == EV:Nova?
19:17:56 <adu> dmwit: "ev-tools" is kind of a misnomer, all the tools i have are just a perl script that is 5 lines long, that runs apple's DeRez with that file
19:18:04 <dmwit> ebensh: EV == EV
19:18:20 <dmwit> ebensh: EV:Nove had both EV and EV:O embedded in it, I think, as Easter eggs.
19:18:24 <adu> ebensh: EV = Escape Velocity, EVO = Escape Velocity Override, EVN = Escape Velocity Nova
19:18:34 <ebensh> adu: chronological order?
19:18:46 <adu> yes, EVO = 2, EVN = 3
19:19:02 <adu> EVN is the only one that works on Windows
19:19:13 <ebensh> ahhh gotcha
19:19:26 <adu> EV and EVO were MacOS9 only
19:19:38 <adu> EVN is also the only one that works on MacOSX
19:19:42 <dmwit> BasiliskII works on Windows and Linux, though. ;-)
19:20:58 <adu> anyways, I was considering making a WebEV cuz it would be somewhat easy
19:21:01 <mxc> preflex: seen interferon
19:21:02 <preflex>  interferon was last seen on #haskell 22 hours, 23 minutes and 32 seconds ago, saying: rwbarton: ah, gotcha
19:22:11 <adu> or perhaps EVH = Escape Velocity Haskell?
19:22:40 <dmwit> WebEV would be easy? Really?
19:23:24 <adu> dmwit: easier than doing a 3D game
19:23:26 <adu> dmwit: well, if all of the data were in XML or JSON, 
19:23:50 <adu> dmwit: I would have to write a converter from binary EV files to WebEV files
19:25:52 <adu> anyways, i wouldn't use Flash or WebGL, i would probably use HTML5 canvas2D
19:26:10 <adu> although I have been thinking of cool WebGL demos
19:26:36 * adu moves to #haskell-blah
19:30:18 <ebensh> can i use guards in my creation of the lit constructor?
19:30:40 <ebensh> that is, i'm now creating "instance Expr Saturated where", where Saturated only works on lits of 0..7 inclusive
19:30:49 <ebensh> i'd like to guard lit x
19:31:44 <Saizan> you can use guards there like in any other definition
19:32:36 <Saizan> lit i | i `elem` [0..7] = ... | otherwise = error "out of bounds"
19:32:39 <ebensh> Saizan: thanks :)
19:35:39 <bos> @hoogle showHex
19:35:39 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
19:43:42 <ebensh> minor question - any way to comment out a range of lines in a literate haskell file?
19:43:49 <ebensh> something like /* */ in C++?
19:44:13 <ebensh> (and yes, i tried googling before asking - admittedly not for too long though)
19:44:13 <enthropy> you can put regular {- -} comments in literate source, ebensh
19:44:28 <ebensh> really? when i tried it emacs didn't change colors
19:44:33 <ebensh> i assumed it wasn't working out
19:44:39 <ebensh> thanks :)
19:45:40 * hackagebot yajl 0.3.0.3 - Bindings for YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-0.3.0.3 (JohnMillikin)
19:45:42 * hackagebot yajl-enumerator 0.2.0.2 - Enumerator-based interface to YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-enumerator-0.2.0.2 (JohnMillikin)
19:54:56 <identity> Hmm
19:55:22 <identity> Anyone familiar with HJson? It is not liking \uXXXX escaped characters
19:57:33 <ebensh> dmwit: everything seems good, but i'm trying to figure out how to rewrite http://hpaste.org/40661/expr_saturated so that it's not so... ridiculous looking
19:57:39 <ebensh> dmwit: suggestions?
19:59:04 <ebensh> dmwit: the annotation is the best i could come up with
20:00:18 <dmbarbour> :t block
20:00:19 <lambdabot> Not in scope: `block'
20:01:40 <dmwit> ebensh: How about defining "clip :: Int -> Int" that clips things to the 0-7 range?
20:02:10 <ebensh> dmwit: is it really cleaner to move that to a separate function? i feel like that would be separating the definition of what saturated is from the one thing that actually uses it
20:02:29 <dmwit> I think it's a good and useful abstraction.
20:02:34 <dmwit> Then it looks like
20:02:41 <dmwit> lit x = Saturated (clip x)
20:02:48 <dmbarbour> Question: How does Control.Exception.block scopes work? That is, if I have block $ block $ unblock $ action, would asynchronous exceptions be blocked or unblocked upon entering action?
20:02:52 <ebensh> mmhmm
20:02:53 <dmwit> add (Saturated x) (Saturated y) = Saturated (clip (x+y))
20:02:55 <dmwit> etc.
20:02:59 <dmwit> quite nice looking
20:04:29 <ebensh> mmm cool, good suggestion
20:04:30 <ebensh> thanks
20:07:53 <dmbarbour> :?
20:12:45 <Saizan> dmbarbour: i think block . block = block, but it shouldn't be hard to test
20:13:47 <dmbarbour> Saizan: it seems quite painful to test. Threads aren't something easy to use in ghci.
20:14:55 <dmbarbour> It's an issue because 'catch' apparently does its own block/unblock implicitly...
20:16:23 <dmbarbour> and if block . block = block... that means we'd enable asynchronous exceptions upon returning from the inner block?
20:17:27 <ebensh> :t Right
20:17:28 <lambdabot> forall b a. b -> Either a b
20:17:29 <identity> anyone recommend a json parser? HJson doesn't like unicode so I guess it's out of the question
20:17:36 <ebensh> o_O
20:18:27 <chrisf> it's pretty sad to see 'X doesnt like unicode' in 2010.
20:18:39 <identity> It's annoying, yes
20:19:01 <identity> Granted, it's not a metric f**kton that I've written of code, but all I've written depends heavily on json
20:19:08 <identity> hjson*
20:19:27 <identity> but now I have to convert to some bytestring json parser and do all the work with convertin from/to bytestrings as well
20:19:29 <pikhq> identity: Who wrote HJson?
20:19:36 <identity> pikhq: um, sec
20:19:55 <pikhq> identity: Write him an email informing him that it's no longer 1985.
20:19:55 <identity> "voker57"
20:20:04 <identity> It should be.
20:20:23 <identity> Everything was so easy before unicode and locales
20:20:52 <pikhq> Yeah, before that there were only 5 billion incompatible encodings making it impossible to handle multilingual anything.
20:21:04 <identity> True
20:21:21 <pikhq> Aaand locales are about as old as the idea of software being sold outside of the US.
20:21:54 <identity> I guess it is
20:23:46 <identity> Well, time to waste a good while getting familiar with another json api
20:23:51 <pikhq> Seriously though, not supporting Unicode is, at best, bit rot. And at worst it's the result of the fundamental sort of idiocy that gets you the gets function.
20:24:21 <Saizan> dmbarbour: see Control.Exception.blocked
20:25:03 <dmbarbour> Saizan: thanks, I'll give that a try.
20:26:20 <identity> pikhq: "the gets function"? :P
20:26:52 <Saizan> and yeah, the catch runs the handler inside a block
20:26:53 <pikhq> identity: In C. It gets a string from stdin and puts it into the provided buffer. And makes *no* checks about the size of that buffer.
20:27:13 <identity> Ah, yeah
20:27:15 <identity> that gets
20:27:20 <pikhq> So, if someone *happens* to write 4 gigabytes followed by a newline, all of a sudden that 4 gigabytes is your C heap.
20:27:20 <identity> I was thinking the other gets
20:27:25 <identity> StateT gets and co
20:27:52 <identity> pikhq: Buffer overflow extravaganza
20:27:58 <identity> :t gets
20:27:59 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
20:28:02 <pikhq> identity: Yup. :)
20:32:09 <dmbarbour> Saizan: thanks for the suggestion.  It seems (block $ ((block blocked) >> blocked)) is true, so block is not the same as block . block
20:32:53 <tehgeekmeister> awww crap, i can't build the haskell platform without building ghc. =/
20:33:00 <dmbarbour> But 'unblock' also enables exceptions right away.
20:33:16 <dmbarbour> block $ block $ unblock blocked is false
20:33:50 <Saizan> dmbarbour: how does that test tell something about block . block ?
20:34:43 <dmbarbour> Saizan: if block . block were equal to block, then returning from the inner block would unblock exceptions.
20:35:23 <dmbarbour> Basically, it's an issue of counters or memory.
20:36:18 <Saizan> i'm not convinced by that argument, simply because block . block is in no way a subexpression of (block $ ((block blocked) >> blocked))
20:37:27 <Saizan> but, anyway, i'm pretty sure block just restores the initial blocked status at the end, it doesn't explicitly unblock exceptions
20:43:45 <davidL> .w 22
21:06:15 <ebensh> hrm
21:06:24 <ebensh> I can't quite figure out what byorgey is expecting us to do here
21:06:33 <ebensh> we need to convert arithmetic expressions to programs
21:06:40 <ebensh> where programs are a list of instructions
21:06:47 <ebensh> but how does one "add" two programs?
21:09:16 <dolio> Is it like a stack machine?
21:09:17 <Saizan> i guess you're supposed to produce a program that will compute the addition of the results of the two programs
21:09:52 <dolio> 2 + 2 => push 2 ; push 2 ; add?
21:10:16 <ebensh> dolio, for literals that makes sense, but i don't see how to apply an "add" to two programs
21:10:55 <tehgeekmeister> where do i get source for a particular ghc release from?
21:11:04 <ebensh> lit x = [S.PushInt x]
21:11:06 <ebensh> ^--- makes sense
21:11:25 <ebensh> but add x y = ...?
21:11:34 <Saizan> tehgeekmeister: haskell.org/ghc/
21:12:41 <Saizan> tehgeekmeister: btw, you should probably just use the binary tarballs if they are available for your platform
21:12:55 <tehgeekmeister> linux x86 is available, ubuntu isn't
21:13:01 <tehgeekmeister> but i'll try that and see if it works
21:13:13 <tehgeekmeister> haskell platform isn't packaged for newest ubuntu yet
21:13:43 <Saizan> yeah, the generic linux one should work fine
21:15:03 <tehgeekmeister> i can use that to build the platform, woo!
21:19:34 <tommd> #@%#@$@q9829898ut3q9842982q
21:19:36 <tommd> Grrr
21:19:37 <tommd> @$%#
21:19:37 <lambdabot> Unknown command, try @list
21:19:43 <tommd> yeah yeah
21:19:46 <ebensh> XD
21:20:54 <tommd> I've became to comfortable with infinite structures.  I implicitly designed a program around a structure which maps an infinite structure to another value...
21:21:19 <dmwit> Missing warrant!
21:21:21 <tommd> Didn't even notice it as I didn't consider the structure infinite, merely mutually recursive thanks to a small knot tying.
21:21:22 <identity> God, I don't know Right or Left in this Either clusterfuck. Maybe is should Just got to bed. Nothing is grokking.
21:22:15 <ebensh> dmwit: what does it mean to add two programs?
21:22:21 <ebensh> dmwit: or mul them?
21:22:32 <ebensh> where a "program" is a list of stack expressions
21:22:41 <ebensh> such as PushInt Int, PushBool Bool, Add, Mul, And, Ar
21:22:42 <ebensh> Or*
21:22:53 <ebensh> for a literal of int or bool i understand
21:23:04 <ebensh> it's just the singleton list of push(int/bool) x
21:23:52 <dolio> They aren't just any old sequences.
21:24:30 <dmwit> I would expect that it would run the first program (which is expected to leave one thing on the stack), then run the second program (leaving another thing on the stack), then add the top two things on the stack.
21:25:43 <dmwit> ebensh: (no content in this message, just using your name so you know I responded)
21:25:55 <ebensh> dmwit: thanks, i'll see if it works out
21:41:58 <newsham> is there a really small haskell interpretter or compiler that supports haskell98?
21:42:40 <dolio> Is nhc98 small?
21:42:52 <dmwit> Does any compiler actually do all of H98?
21:43:13 <newsham> i dont know (to either of those :)
21:43:31 <dolio> The web site describes it as small.
21:43:40 <dolio> And standards compliant.
21:44:25 <dolio> Heh, but n+k patterns are off by default.
21:44:33 <newsham> i wonder how hard it would be to target c64 or pdp11 with something like that
21:44:56 <dmwit> sorear told me a while ago that "default = t" should parse the same as "defaul t = t", according to the H98 spec.
21:45:12 <dolio> Yes.
21:45:29 <dolio> I don't know if anyone implements that correctly.
21:45:52 <dolio> (And it'd probably be better to change the spec.)
21:46:24 <dmwit> right
21:46:33 <Veinor> dmwit: wait, what?
21:46:34 <dmwit> I think most sane people agree on that.
21:46:46 <Veinor> why does it parse like that?
21:46:50 <dmwit> Veinor: Yup, it's a consequence of the maximal (successful) munch rule.
21:47:04 <Veinor> meaning
21:47:08 <dmwit> meaning
21:47:16 <Veinor> what is the maximal successful munch rule
21:47:20 <dmwit> lexing it as "default" "=" "t" wouldn't lead to a successful parse.
21:47:32 <dmwit> But lexing it as "default" "t" "=" "t" would.
21:47:37 <dmwit> sorry
21:47:43 <dmwit> "defaul" "t" "=" "t", of course
21:47:57 <dmwit> So "defaul" is the biggest munch that leads to a successful parse.
21:47:59 <Veinor> why doesn't the former parse?
21:48:06 <dolio> default is a keyword.
21:48:06 <dmwit> default is a keyword
21:48:11 <Veinor> ahhhh.
21:48:40 <dolio> There are other weird things caused by that, too.
21:48:41 <newsham> nobody is using GLR to lex tokens?
21:49:23 <dolio> Like, "let foo = bar in foo == bar == bar" should, I think, parse as (let foo = bar in foo == bar) == baz.
21:49:39 <dmwit> oh dear
21:49:46 <dolio> Because == is infix, and so 'foo == bar == baz' is an invalid parse.
21:49:59 <dmwit> Is Haskell actually a context-sensitive language?
21:50:00 <dolio> Or, can't be parsed.
21:50:08 <dmwit> I suppose it must be.
21:50:23 <flux> + is infix as well, yes, foo + bar + baz parses?
21:50:34 <flux> s/yes/yet/
21:50:37 <dolio> + is infixl
21:50:45 <flux> ah, right
21:50:49 <dolio> == is infix, which means chaining is invalid.
21:50:51 <dolio> I think, at least.
21:51:04 <dmwit> Yes, you're right.
21:51:29 <flux> > True == True == True
21:51:30 <lambdabot>   Precedence parsing error
21:51:30 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
21:51:50 <dolio> > let x = 5 in True == True == True
21:51:51 <lambdabot>   Precedence parsing error
21:51:51 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
21:52:04 <dolio> Needless to say, GHC doesn't implement that.
21:52:30 <dmwit> > let default = t in defaul 3 -- right
21:52:31 <lambdabot>   <no location info>: parse error on input `default'
21:53:01 <dolio> I'd be pretty surprised if nhc got it right, too.
21:54:11 <ebensh> Thanks for all of your help again!
21:54:13 <ebensh> i <3 you all
21:54:15 <ebensh> g'nite :)
21:55:36 <identity> Why are there no isLeft/Right ?
21:55:46 <dolio> @hoogle isLeft
21:55:46 <lambdabot> No results found
21:56:13 <identity> Seeing as there are isNothing/Just and all
21:56:24 <dolio> Either is a bit more neglected.
21:56:41 <identity> I see
21:56:44 <identity> @src isRight
21:56:44 <lambdabot> Source not found. Where did you learn to type?
21:56:46 <identity> eh
21:56:48 <identity> @src guard
21:56:48 <lambdabot> guard True  =  return ()
21:56:48 <lambdabot> guard False =  mzero
21:56:53 <newsham> ?type either True False
21:56:53 <lambdabot>     Couldn't match expected type `a -> c' against inferred type `Bool'
21:56:54 <lambdabot>     In the first argument of `either', namely `True'
21:56:54 <lambdabot>     In the expression: either True False
21:57:16 <newsham> ?type either (const True) (const False)
21:57:17 <lambdabot> forall a b. Either a b -> Bool
21:57:45 <identity> I know, it's not a problem
21:57:54 <identity> But neither are isJust isNothing
21:57:57 <identity> :t maybe
21:57:57 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:58:17 <identity> :t maybe False (const True)
21:58:18 <lambdabot> forall a. Maybe a -> Bool
21:59:36 <identity> Someone needs to put isLeft/Right in the standard library.
22:00:06 <identity> for added fun, they could be defined as: isLeft = either (const False) (const True) and isRight = not . isLeft
22:00:20 <identity> Then hilariy would ensue in haskell-cafe
22:01:02 <dmwit> i.e. purposely backwards?
22:01:20 <dmwit> I really don't think that would make it past the libraries submission process. =P
22:01:29 <identity> Yep.
22:01:31 <identity> Hehe, I know
22:02:32 <newsham> ?type const True `either` const False
22:02:33 <lambdabot> forall a b. Either a b -> Bool
22:03:04 <newsham> low core
22:03:04 <newsham> br4 = 200
22:03:04 <newsham> br5 = 240
22:03:04 <newsham> br6 = 300
22:03:07 <newsham> br7 = 340
22:03:09 <newsham> . = 0^.
22:03:12 <newsham>         br      1f
22:03:14 <newsham>         4
22:03:17 <newsham> trap vectors
22:03:19 <newsham>         trap; br7+0.            / bus error
22:03:20 <identity> induring accidental paste
22:03:22 <newsham>         trap; br7+1.            / illegal instruction
22:03:24 <newsham>         trap; br7+2.            / bpt-trace trap
22:03:27 <newsham>         trap; br7+3.            / iot trap
22:03:29 <newsham>         trap; br7+4.            / power fail
22:03:32 <newsham>         trap; br7+5.            / emulator trap
22:03:34 <newsham>         trap; br7+6.            / system entry
22:03:37 <newsham> . = 40^.
22:03:38 <cncl> freenode throttles it and drags it out, so we get to savor it
22:03:39 <newsham> .globl  start, dump
22:03:42 <newsham> 1:      jmp     start
22:03:44 <newsham>         jmp     dump
22:03:47 <newsham> . = 60^.
22:03:48 <identity> freenode does that?
22:03:49 <newsham>         klin; br4
22:03:52 <newsham>         klou; br4
22:03:54 <newsham> . = 100^.
22:03:57 <newsham>         kwlp; br6
22:03:57 <cncl> yeah that's a standard irc daemon feature
22:03:59 <newsham>         kwlp; br6
22:04:00 <dmwit> Oh, bother.
22:04:02 <newsham> . = 114^. trap; br7+7.            / 11/70 parity
22:04:03 <dmwit> ?where ops
22:04:03 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
22:04:04 <newsham> . = 214^.
22:04:07 <newsham>         tcio; br6
22:04:09 <newsham> . = 220^.
22:04:10 --- mode: ChanServ set +o Saizan
22:04:12 <newsham>         rkio; br5
22:04:14 <newsham> . = 224^.
22:04:17 <newsham>         tmio; br5
22:04:17 <identity> cncl: Not too sure about that; the unrealircd I'm on as well doesn't do that
22:04:19 --- mode: Saizan set +q newsham!*@*
22:04:19 <newsham> . = 240^.
22:04:20 <identity> irssi does do that though
22:04:38 <cncl> i have an unrealircd configured to do it
22:04:42 <identity> Ah
22:04:43 <cncl> also an inspircd
22:05:02 <cncl> though it will kill a connection before it goes on for too long
22:05:21 <identity> Hmm
22:05:33 <identity> there was a command, IIRC, something about clearing buffers
22:05:41 <Saizan>  /clear ?
22:05:43 <identity> can't remember if it was irssi or something to do with the server
22:05:43 <dmwit> It seems like clients ought to be able to detect when there's been a paste and just kill it after 3 lines or so.
22:05:43 <identity> nah
22:05:50 <identity> purge something maybe?
22:05:51 <identity> Can't remember
22:06:03 <cncl> irssi will prompt you if try to paste more than two lines at once
22:06:06 <identity> but it was what you needed to do when you saw yourself paste retarded amounts of accipaste
22:06:10 <identity> cncl: aye
22:06:15 <identity> It also throttles it for you
22:07:00 --- mode: Saizan set -q newsham!*@*
22:07:14 <newsham> so sorry everyone.  huge megapaste, and irssi didnt catch it
22:07:20 <newsham> mispaste too
22:07:53 <identity> question: When in a MaybeT IO a, doing something like: do { foo <- anotherMaybeTIOAction; .. stuff that uses foo .. }, if foo is basically Nothing, is the result Nothing?
22:08:04 <identity> I mean
22:08:31 <dmwit> That's the idea, yup.
22:08:34 <Saizan> the value of foo doesn't matter
22:08:34 <tommd> newsham: I'm just disappointed it wasn't more interesting, like ARM ASM or some such.
22:08:36 <identity> I thought I remembered having to check for Nothing/just inside a MaybeT, but doing: foo <- maybeTAction; seemed to 'get past that'
22:08:59 <newsham> tommd: i think its interesting (but not for #haskell)
22:09:06 <newsham> l.s from unix v6
22:09:14 <identity> Oh, never mind
22:09:29 <Saizan> identity: MaybeT (return Nothing) >>= f = MaybeT (return Nothing)
22:09:32 <identity> I just converted it to maybeTAction >>= (\foo -> ..) in my head and it made sense
22:09:37 <identity> Saizan: exactly
22:09:48 <tommd> newsham: What is it exactly?  I think I see interrupt table of some sort, some ASM...
22:10:05 <newsham> yup, for pdp11
22:10:08 <Saizan> otoh, MaybeT (return (Just Nothing)) >>= f = f Nothing
22:10:32 <identity> Man, MaybeT is osom.
22:10:42 <identity> everything I seem to do in IO/HTTP seems to boil down to MaybeT
22:11:16 <Saizan> you could also use IO exceptions i guess
22:11:24 <identity> I suck at nipping these patterns in the bud so I'll be halfway through manually boilerplating the IO (Maybe a) crap when I realize
22:11:30 <identity> Saizan: True, but not as clean
22:11:39 <identity> When I dont' care about the result, anyway
22:15:55 <identity> @src mapM
22:15:56 <lambdabot> mapM f as = sequence (map f as)
22:16:10 <identity> @src forM
22:16:10 <lambdabot> forM = flip mapM
22:29:00 <stepkut> are there any CAFs in the standard haskell libraries with the type, String ?
22:29:12 <stepkut> any String constant at all will do..
22:29:37 <stepkut> ah.. Text.Html
22:29:50 <stepkut> > System.Info.os
22:29:51 <lambdabot>   Not in scope: `System.Info.os'
22:30:07 * stepkut figured out how to improve his hoogle search results
22:30:11 <c_wraith> does a string constant alone count as a CAF?  I'm not sure if that's considered applicative form or not.
22:30:31 <stepkut> well, all i need is something with the type, :: String
22:33:55 <stepkut> ok, here is my real question
22:33:56 <stepkut> http://hpaste.org/40664/getting_name_into_the_splice
22:34:22 <stepkut> I have a function like:
22:34:24 <stepkut> nameAndPrint :: (Show a) => Name -> a -> IO ()
22:34:51 <stepkut> and I want to always call it like, nameAndPrint 'os os, where both arguments are the same symbol
22:34:53 <dmbarbour> I'd like a little help figuring out how to express cyclic dependencies with Monad variables. http://hpaste.org/40665/cyclic_dependency_syntax
22:35:33 <stepkut> so in theory, I could write something like this to  generate the call to nameAndPrint , $(nameAndPrintTH 'os). But I can't figure out how to actually implement it :)
22:36:12 <c_wraith> just splice in varE of the Name.  I think
22:36:46 <stepkut> dmbarbour: you need mdo I think
22:36:54 <dmbarbour> mdo?
22:37:13 <c_wraith> stepkut, it should just be a VarE constructor, if I remember my TH heirarchy right.
22:38:27 <stepkut> dmbarbour: recursive do
22:39:10 <identity> @src mdo
22:39:10 <lambdabot> Source not found. That's something I cannot allow to happen.
22:39:13 <identity> :t mdo
22:39:14 <lambdabot> Empty 'do' construct
22:39:26 <identity> what does mdo do exactly?
22:39:39 <dmbarbour> Ah, it seems to be a special GHC extension.
22:39:48 <dmbarbour> (mdo, that is)
22:39:50 <identity> ah.
22:40:04 <stepkut> dmbarbour: yes, I can't seem to find a good link for you at the moment. 
22:40:05 <c_wraith> mdo is for things that implement MonadFix
22:40:12 <c_wraith> :t mfix
22:40:13 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
22:40:38 <stepkut> dmbarbour: but, basically it allows you to have earlier statements depend on the results of later statements -- which I think is what you are doing
22:40:45 <c_wraith> But I have no clue how mdo desugars into an mfix call
22:41:13 <stepkut> dmbarbour: add {-# LANGUAGE DoRec #-}  and see if your code compiles ;)
22:41:51 <dmbarbour> stepkut: I'll give it a try, but I doubt that'd help.
22:42:14 <dmbarbour> I also dislike using more extensions than absolutely necessary...
22:42:47 <identity> you know, I really, really wish I could get a shell based on haskell
22:42:50 <identity> it would be beyond awesome
22:43:00 <identity> I'm sure someone has already done it, amirite?
22:43:15 <c_wraith> uh.  powershell for windows? :P
22:43:34 <identity> Powershell is better than cmd, sure, but powershell is, meh.
22:43:39 <c_wraith> Not based on haskell, but based on some of the same ideas as haskell
22:43:46 <stepkut> identity: not quite.. there have been several things that are close -- but the way that GHC handles file handles in forked processes is (or was) trouble
22:43:54 <identity> stepkut: ah.
22:44:00 <stepkut> c_wraith: this is what I have
22:44:03 <stepkut> nameAndPrintTH :: Name -> ExpQ
22:44:03 <stepkut> nameAndPrintTH n = appE (appE [| nameAndPrint |] undefined)  (varE n)
22:44:13 <stepkut> which compiles -- but I am not sure what to put in place of 'undefined'
22:44:50 <c_wraith> Oh, so it's actually passing the Name through that you're having trouble with?
22:45:05 <stepkut> c_wraith: yep
22:45:26 <c_wraith> I'd write it as something like [| nameAndPrint $n $(varE n) |]
22:45:29 <stepkut> c_wraith: makes my head go round and round
22:45:37 <identity> templatehaskell looks like something out of one haskell failure nightmares. (Yes, I have actually had a couple of those :|)
22:45:48 <c_wraith> except $n isn't quite right.
22:45:53 <c_wraith> since n has the wrong type
22:46:05 <stepkut> c_wraith: also, i gives you stage restriction error
22:46:12 <stepkut> s/i gives/it gives/
22:46:39 <c_wraith> That's odd.  you should be able to splice in that context.
22:47:18 <c_wraith> oh
22:47:37 <c_wraith> it would be like [| nameAndPrint $(lift n) $(varE n) |]
22:47:46 <c_wraith> unless for some reason Name isn't an instance of Lift
22:47:53 <stepkut> it is not 
22:48:01 <c_wraith> that makes no sense at all :)
22:48:09 <c_wraith> Eh, make it an instance of Lift, then.
22:48:16 <stepkut> nameAndPrintTH n = [| nameAndPrint n $(varE n) |]
22:48:16 <stepkut>  
22:48:21 <c_wraith> All the constructors are public, right?
22:48:22 <stepkut>     No instance for (Language.Haskell.TH.Syntax.Lift Name)
22:48:43 <c_wraith> oh, right.  $(lift n) is the same as n.  heh.
22:49:11 <stepkut> The constructor for 'Name' is public, but not OccName
22:49:22 <c_wraith> It's silly that it's not an instance of Lift.
22:50:08 <c_wraith> Well, implement a helper function (in yet another module, it looks like) that lifts names.
22:50:37 <stepkut> hmm. i better go to bed first I guess.
22:50:49 <stepkut> I have no idea how to do that yet :)
22:50:58 <c_wraith> and file a bug report that Name isn't an instance of Lift
22:51:31 <c_wraith> It's not that hard to implement, actually.  You just have to convert a value to its constructors at the template level.
22:52:21 <stepkut> I spent most of the evening fixing some bugs in hs-plugins.. so now everything is hard :)
22:52:32 <stepkut> tomorrow it might be easy though. 
22:52:38 <identity> oh god
22:52:40 <identity> 8 am
22:52:41 <identity> no sleep yet
22:53:11 <mjrosenb> identity: ahh, the magic hour!
22:53:19 <identity> mjrosenb: how so?
22:53:43 <identity> sleep is such a waste of time. Or so I think until I've not slept for 24 hours or so and the tiredness sets in.
22:53:49 <stepkut> maybe I can use deriveLift to derive lift for Name :p
22:54:01 <mjrosenb> identity: oh, it is only 24 hours?
22:54:12 <mjrosenb> that period sucks.
22:54:30 <mjrosenb> when you get up to 30 or so, then your body just gives up on making you try to sleep
22:54:32 <identity> There's a reason "sleep" in computer programming is often named "delay"
22:54:35 <mjrosenb> and you can get some work done.
22:54:41 <identity> mjrosenb: Yeah, there's a threshold for sure
22:54:51 <identity> But it depends on whatever my threshold is
22:55:04 <c_wraith> stepkut, I didn't know that existed, but..  Lift instances are definition completely mechanical, so sure. :)
22:55:14 <c_wraith> err, *definitely
22:55:43 <stepkut> c_wraith: it's in a different package, http://hackage.haskell.org/packages/archive/ForSyDe/3.1.1/doc/html/Language-Haskell-TH-Lift.html
22:55:43 <c_wraith> Or at least they are for ADTs that don't involve function types anywhere.
22:55:59 <c_wraith> lifting a function is hard in haskell.
22:56:04 <c_wraith> but ADTs are easy
22:58:01 <stepkut> well, tomorrow. bedtime first. But thanks! it seemed like Lift Name was my only option. But I wanted to make sure :)
22:58:34 <c_wraith> well.  you could implement the same functionality without the typeclass, but yeah.  you need that functionality somehow
23:01:41 <stepkut> or maybe I should offer $5 to anyone who will write it for me :)
23:09:49 <ManateeLazyCat> wjt: Are you there?
23:09:59 <ManateeLazyCat> :preflex seen wjt
23:10:48 * hackagebot Facts 0.1.2 - A collection of facts about the real world.  http://hackage.haskell.org/package/Facts-0.1.2 (AlexanderSolla)
23:21:08 <dmead> hey channel
23:21:30 <dmead> whats haaaapening
23:30:07 <Botje> sunrise!
23:32:39 <c_wraith> I'm not really surprised
