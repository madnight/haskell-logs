00:00:07 <ivanm> kmc: :o
00:00:11 <kmc> three exclamation points
00:00:17 <kmc> in the ghc manual
00:00:19 <Zao> kmc: No unsafeMissiles, eh?
00:00:24 <kmc> what's the curve of seriousness vs exclamation points
00:00:32 <kmc> after five or so, it starts to lose credibility
00:02:26 <ivanm> I would say that even 3 is partially dubious
00:02:34 <dorkitude> I barely know what Haskell is and I'm totally new to functional programming. What are some good links I should check out?
00:02:39 <blackdog> ivanm: you have no joy in your life.
00:03:01 <kmc> dorkitude, LYAH and RWH
00:03:03 <kmc> @where LYAH
00:03:03 <lambdabot> http://www.learnyouahaskell.com/
00:03:04 <kmc> @where RWH
00:03:04 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:03:19 <ivanm> blackdog: too true :(
00:03:22 <kmc> dorkitude, it should also be noted that, while Haskell is one of the best and fanciest functional languages, it's also an atypical functional language
00:03:29 <kmc> if you want to first learn FP-as-such, you could learn Scheme or SML
00:03:46 <kmc> Haskell adds lots of extra concepts like type classes, laziness, first-class IO actions, etc.
00:03:50 <ivanm> kmc: I would argue that haskell, clean, etc. are the only *real* FP langs around
00:03:56 <ivanm> due to referential transparency
00:04:04 <blackdog> ivanm: let's not get all sectarian about it.
00:04:15 <kmc> haha
00:04:34 <kmc> Haskell is referentially transparent *quickly kicks unsafePerformIO under the rug before anyone sees*
00:04:49 <kmc> purity is more an issue of library standards and community norms than it is a hard language feature
00:04:59 <kmc> at least in Haskell
00:05:25 <dorkitude> at this point it's totally untarnished territory for me - the only exposure i have to FP is: http://diveintopython.org/functional_programming/index.html  + writing one FP-style program to do some nerdy linguistics processing on picloud
00:05:28 * hackagebot flock 0.2 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.2 (ErikHesselink)
00:05:52 <kmc> cool
00:05:58 <kmc> well as you already noted, you can do FP in any decent language
00:06:08 <kmc> and you can hack it in indecent languages too
00:06:15 <kmc> witness the 1000+ line C++ hacks to do trivial FP
00:06:23 <dorkitude> haha
00:06:27 <kmc> people say functional programming is useless, then they bend over backwards to fake it
00:06:43 <dorkitude> but the very same people??
00:06:53 <blackdog> dorkitude: that sounds kinda cool, actually. what were you doing with linguistics?
00:07:03 <kmc> anyway rant over
00:07:11 <kmc> you can learn FP by jumping into Haskell, many people do
00:07:12 <blackdog> as a data point: i've done a bit of 5-gram processing with haskell, was pleasant and easy.
00:07:19 <kmc> just beware that it's a lot of new concepts all at once
00:07:38 <dorkitude> blackdog:i have this huge set of 45000 xml files, each one is an imdb movie with all reviews intact
00:07:48 <dorkitude> and a little bit of data about the movie (average review, language, genre(s))
00:08:25 <dorkitude> since the biggest file is like 20 megs, i couldn't very well do it all locally, so i gave piCloud a try
00:08:32 <dorkitude> had a blast and someone at work told me to check out haskell
00:08:34 <ivanm> blackdog: "5-gram"?
00:08:58 <dorkitude> does that mean 5-words as a linguistic unit?
00:09:08 <dorkitude> or 1,2,3,4,5 inclusive?
00:11:37 <dorkitude> wow, LYAH reminds me of _why's guide in a good way!
00:12:22 <dolio> It's actually a lot less goofy.
00:12:23 <ivanm> it's based upon it in style
00:14:05 <blackdog> dorkitude: as a linguistic unit
00:14:26 <blackdog> i was training a predictive text engine
00:15:12 <blackdog> dorkitude: hm, 900 gigs... probably still doable
00:15:48 <dorkitude> luckily the 20 meg one was an extreme outlier (the fellowship of the ring)
00:16:13 <blackdog> it's reasonably easy to parallelise haskell programs, so if you have a chunky CPU and can keep it fed, you'd probably have a good chance of doing it in a not unreasonable amount of time
00:16:31 <blackdog> sounds a bit like the widefinder benchmark, actually
00:17:54 <dorkitude> i ran 5% of the files in an arbitrary order, took around 24h
00:18:35 <blackdog> dorkitude: http://www.serpentine.com/blog/2007/09/25/what-the-heck-is-a-wide-finder-anyway/ has an example of how you might speed that sort of thing up in a parallel way.
00:19:01 <Guest86956> Hello, I got a question about the data type Multiset (http://hackage.haskell.org/packages/archive/multiset/0.1/doc/html/Data-MultiSet.html). Actually how do I create that data type? As I can't seem to find example code... =(
00:19:14 <blackdog> dorkitude: in python?
00:19:14 <Guest86956> (I have already imported it)
00:19:48 <kmc> empty :: MultiSet a
00:19:50 <kmc> singleton :: a -> MultiSet a
00:20:02 <kmc> fromList :: Ord a => [a] -> MultiSet a
00:20:10 <Guest86956> can I create Multiset [1,2,3]?
00:20:13 <dorkitude> blackdog: nice, this link is exactly what i was looking for :) 
00:20:35 <Guest86956> if I type in Multiset [1,2,3] for example, I get that Multiset is not in scope.
00:21:18 <dorkitude> blackdog: yup, in python with 20 threads on an ec2 box
00:21:18 <kmc> yes, it's an abstract type
00:21:25 <kmc> meaning that the type constructor is provided, but no data constructors
00:21:27 <kmc> use fromList
00:21:31 <dorkitude> blackdog: . since then picloud.com has proven it can do it however fast i need, but it's 5 cents per cpu hour, so i'm holding off
00:21:41 <Guest86956> oh...
00:21:48 <Guest86956> so I can only create that data fromList...
00:21:58 <Guest86956> thanks!
00:23:35 <blackdog> dorkitude: is this a netflix thing, btw?
00:24:36 <NewWorld> If I have function:      foo (x, y) 99 h |  x <- [1,2..10], y <- [11,12..20], h <- [21,22..30]     How would I go about feeding foo those 3 lists 'zipped', i.e. function calls would be: foo(1,11) 99 21, foo(2,12) 99 22, foo(3,13) 99 23, etc.
00:24:56 <blackdog> dorkitude: you may also be interested in stephen blackheath's http://hackage.haskell.org/package/hexpat
00:25:09 <dorkitude> blackdog: nah it's for a university
00:26:10 <Guest86956> another question if I want to define a data type with multiset, how can I do that? Because data State = State (Multiset Int) it will give again the same error =(
00:26:30 <kmc> no it won't
00:26:41 <kmc> Haskell has separate namespaces for values and types
00:26:51 <kmc> the type constructor MultiSet is in scope, even though there is no data constructor by that name
00:26:59 <kmc> (however it will give the error if you spell it wrong)
00:27:02 <Guest86956> oh I see...
00:27:04 <Guest86956> yes
00:27:17 <dorkitude> blackdog: bookmarked, now to curl up with LYAH til i fall asleep
00:27:36 <blackdog> dorkitude: have fun:)
00:29:27 <mornfall> For just a short while I wondered who LYAH was.
00:29:52 <kmc> haha
00:30:10 <kmc> @faq Can Haskell hug me and keep me warm at night?
00:30:10 <lambdabot> The answer is: Yes! Haskell can do that.
00:30:24 <Guest86956> well I try to do that, but still can't fix it =(. http://hpaste.org/40863/not_working
00:30:52 <kmc> Multiset ≠ MultiSet
00:31:00 <Guest86956> oh darn..
00:31:00 <kmc> also you should probably import qualified to avoid name clashes
00:31:07 <Guest86956> oh thanks!
00:31:07 <kmc> import qualified Data.MultiSet as MS
00:31:13 <kmc> data State = State (MS.MultiSet Int)
00:32:20 <Guest86956> darn.. stupid stupid stupid me =(
00:36:03 <Guest27167> wait if I import it as qualified data, then all my code and functions that I use from Multiset has to have MultiSet.functioname?
00:36:30 <kmc> import qualified Data.MultiSet as MS
00:36:34 <kmc> then you can say MS.fromList
00:37:48 <Guest27167> =)
00:45:56 <MiggyX> it's pretty cool when Haskell code goes from totally incomprehensible to precise and beautiful code.
00:46:39 <danderson> ... and then you start reading libraries, and your head explodes again.
00:46:46 <danderson> thus perpetuing the cycle of learning :)
00:52:42 * hackagebot bio 0.4.8 - A bioinformatics library  http://hackage.haskell.org/package/bio-0.4.8 (KetilMalde)
00:54:17 <kmc> sigh, one of my Haskell-related blog articles made its way to /r/programming
00:54:22 <kmc> most of the comments are trolls
00:55:43 * hackagebot flower 0.6.1 - Analyze 454 flowgrams (.SFF files)  http://hackage.haskell.org/package/flower-0.6.1 (KetilMalde)
00:56:57 <donri> kmc: Link?
00:57:06 <kmc> http://www.reddit.com/r/programming/comments/dvpm4/quantification_in_types/
00:58:35 <donri> kmc: Good example of the voting system then ;)
00:58:44 <kmc> shrug
00:59:29 <MiggyX> danderson: yeah it certainly keeps me on my toes - this is still simple LYAH, but it is nice to grasp some of the concepts even if they are basic :)
00:59:36 <donri> It even hid most of the troll comments for me
01:00:37 <danderson> MiggyX: keep at it. Haskell, like other languages only moreso, is a long journey sprinkled with delightful moments of clarity
01:00:40 <danderson> lots of fun :)
01:00:48 <kmc> donri, sure, they get recognized as trolls
01:01:00 <kmc> it's just depressing
01:01:06 <kmc> that this is the most visible response
01:01:09 <kmc> of the "programming community"
01:01:11 <donri> Not that I'm in love with some of the culture the point system fosters
01:01:36 <danderson> kmc: link?
01:01:42 <kmc> it's up there
01:01:51 <kmc> i dunno it sounds like i'm just bitching about them not liking my article
01:01:53 <danderson> oh, yeah, there it is
01:02:02 <kmc> i don't really care; i didn't even submit it to proggit
01:02:49 <danderson> kmc: if it makes you feel better, for me the comments are 1 person thanking you for the explanation, and two troll threads plunging deep into the negatives and auto-hiding
01:03:42 <danderson> but hey, it's r/prog
01:03:51 <danderson> and it's not about NoSQL, Ruby or Zed Shaw
01:03:56 <danderson> thus it's crap, by definition.
01:04:02 <kmc> no, they like Javascript now
01:04:05 <kmc> it has this amazing new feature
01:04:08 <kmc> called first-class functions
01:04:17 <danderson> oh, yeah, I missed that one
01:04:24 <danderson> those wacky programmers, what will they think of next
01:04:27 <kmc> maybe in 25 years Javascript will have static types with polymorphism
01:04:30 <kmc> then my article will be appreciated
01:05:05 <donri> /r/coding/
01:05:35 <danderson> donri: isn't that "HOW I MINE FOR ACCESS DATABASE?"
01:05:45 <kmc> @quote ubuntu.freebsd
01:05:45 <lambdabot> NIXDAEMON-COOL says: how to uncompile make into java gcc 3.3 under ubuntu freebsd ??
01:05:58 <donri> Duno, haven't looked at it much; I've read others say they find it more serious than proggit.
01:07:07 <kmc> the other topic proggit loves is talking about how 'hackers' are better than other people
01:07:30 <danderson> r/coding seems like a different slice of mediocrity
01:07:46 <danderson> anything mildly esoteric has either 0 comments or twenty people saying it's shite
01:08:05 <kmc> yeah any Haskell link on proggit has either 0 comments or a bunch of "lol monads r crazy"
01:08:06 <danderson> and #1 is a stackoverflow question about why some websites don't allow periods in passwords
01:08:31 <danderson> ooh, and more first page quality material: in-place reversal of a linked list!
01:08:33 <danderson> hardcore.
01:08:43 <donri> We need a jailbait reddit for programming languages
01:08:46 <kmc> sounds like someone had a job interview
01:11:23 <dolio> I found the name "coding" kind of a turn-off.
01:11:30 <donri> Agreed.
01:12:02 <donri> /r/compsci ?
01:12:07 <dolio> Like, take "programming" and remove all the stuff that isn't typing stuff into a file.
01:12:44 <dolio> And we all know how the former turned out.
01:12:57 <danderson> I was about to say that might be too dry, but then "Ooh, an article on functional programming for hardware design"
01:13:09 <kmc> it's not like i don't have enough to read
01:13:30 <kmc> i'm not looking for some niche community to keep me happy
01:13:42 <tensorpudding> cobol and basic were egalitarian
01:13:42 <kmc> i'm looking for an accurate view of the general world of programming
01:14:02 <donri> You won't find an accurate view of any kind of world on reddit.
01:14:08 <kmc> and what i see on proggit is not encouraging
01:14:18 <danderson> kmc: unfortunately, reddit may be close for programming :(
01:14:23 <kmc> simultaneously anti-intellectual and macho-elitist
01:15:10 <tensorpudding> instead of intellectually macho-elitist?
01:15:32 <kmc> yeah
01:15:34 <kmc> or intellectual-elitist
01:15:42 <tensorpudding> that's a better term
01:15:42 <opqdonut> or merely elitist
01:15:47 <opqdonut> :)
01:16:00 <tensorpudding> intellectualism is inherently somewhat elitist
01:16:10 <tensorpudding> or at least, opinionated
01:16:24 <donri> The most elitist reddit must be r/atheism
01:16:28 <kmc> well 'elitism' is a dirty word for something that's not necessarily bad
01:16:37 <tensorpudding> oh hey! donri!
01:16:41 <kmc> "those elitists think that only trained pilots should fly airplanes"
01:16:47 <kmc> why, yes, i would like my planes to be flown by elites
01:16:57 <tensorpudding> more lojban overlap
01:17:55 <kmc> my worst-case stereotype programmer is elitist not about actual skill but about personality / lifestyle attributes
01:22:06 <donri> coi tensar
01:22:58 <donri> kmc: To me elitism is an attitude of looking down on people outside the elite group.
01:23:05 <donri> Not necessarily anything wrong with the elites themselves.
01:23:14 <donri> The elitist aren't necessarily the elites.
01:23:22 <kmc> yeah
01:23:31 <kmc> and the self-styled proggit leet haxors aren't necessarily the good programmers
01:24:30 <donri> Elephants are very intelligent creatures, and their programming language of choice is Haskell!
01:24:36 * donri elitist? ;)
01:24:42 <kmc> haha
01:24:45 <kmc> source: LYAH
01:24:46 <donri> Elitist about Elephant superiority.
01:24:59 <danderson> the whole structure of voting on reddit encourages populism, the end result flows naturally from there
01:25:05 <tensorpudding> Elephants are also heavy and capriciously violent
01:25:11 <tensorpudding> just like ghc
01:25:15 <kmc> hahaha
01:25:35 <donri> Sounds like you need… hugs.
01:25:37 <kmc> the basic problem is that people will use downvoting for "i disagree" rather than "your comment is of negative value"
01:25:43 <silver> drugs
01:25:44 <tensorpudding> hugs not bugs
01:25:53 <donri> pugs not parrots
01:25:55 <donri> Wait what?
01:26:24 <tensorpudding> perl 6 will come someday
01:26:25 <danderson> stackoverflow got it somewhat right, by granting gradually more power as you contribute useful answers
01:26:26 <kmc> hugs not drugs
01:26:27 <kmc> wait, no
01:26:29 <kmc> hugs and drugs
01:26:34 <donri> \o/
01:26:37 <kmc> yeah
01:26:37 <donri> kmc: Upvoted.
01:26:39 <danderson> unfortunately that also favors people who have oodles of time
01:26:43 <kmc> slashdot tried to do that waybackwhen
01:26:49 <kmc> but their system was just complicated and cumbersome
01:27:04 <tensorpudding> how irrelevant is slashdot nowadays
01:27:10 <kmc> i don't know
01:27:14 <kmc> i know people who still read it
01:27:18 <donri> danderson: That encourages an elite minority. Wikipedia style.
01:27:19 <kmc> i think it has all the same stories as every other site
01:27:23 <tensorpudding> it doesn't seem that long ago that it was what everyone read
01:27:41 <kmc> donri, it doesn't take long to get into serious powers on SO, and nobody has to approve you manually
01:27:48 <danderson> donri: which is fine, if that elite minority are fair. Better that than reddit's rule of the people :)
01:28:05 <donri> danderson: The WP elite isn't fair.
01:28:19 <danderson> donri: because they didn't have to be useful to acquire that elite status.
01:28:31 <danderson> they just had to be there and shout a lot
01:28:40 <donri> Perhaps
01:28:40 <quicksilver> I doubt elites are ever fair
01:28:50 <quicksilver> they can be better than nothing though
01:29:05 <quicksilver> an imperfect system is still useful
01:29:12 <tensorpudding> the people who are in the minority are not usually thinking that the elites are being fair
01:29:13 <donri> Fairness is relative. WP is OK, but far from perfect.
01:29:15 <danderson> quicksilver: well, obviously it depends whether or not the elite agrees with you
01:29:24 <danderson> if they don't, they're tyrants and should be deposed.
01:29:25 <Biggles> i mean look at the haskell elite. thems do nothing. ;]
01:29:25 <danderson> :)
01:29:42 <kmc> yeah, math is so useless
01:29:48 <kmc> nobody ever made money or improved the world using math
01:29:51 <Biggles> kill math
01:29:59 <donri> MATH KILLS
01:30:07 <quicksilver> far worse than haskell elite is the #haskell elite
01:30:09 <quicksilver> ;)
01:30:14 <Biggles> support the president in his war on combinators
01:30:15 <Peaker> kmc, are you hskmc?
01:30:19 <haskellElephant> kmc: The elephant says no! just look at the Clay prize!
01:30:19 <kmc> yes
01:30:28 <donri> Biggles: Lets combine our efforts.
01:30:30 <kmc> yeah, the #haskell elite is what makes #haskell such a notoriously unfriendly channel
01:30:41 <danderson> reminds me of my favorite Onion horoscope: "Your belief that all life's problems can be solved with a heart-to-heart talk and a good night's sleep will be severely tested this week when you're introduced to mathematics."
01:30:53 <donri> :D
01:30:54 <tensorpudding> hehe
01:30:58 <Biggles> danderson: hahaha
01:31:20 <kmc> hahaha
01:31:20 <silver> :-)
01:31:34 <tensorpudding> i used to think that all math was about was building bigger calculators
01:32:03 <danderson> that's silly of course, it's also about making the missiles hit the right stuff.
01:32:17 <kmc> once the rockets go up, who cares where they come down?
01:32:22 <tensorpudding> yes, but the computers do all the math
01:32:28 <haskellElephant> In the most general case mathematics is about things...
01:32:32 <tensorpudding> once you build the machines, the computers think for you
01:32:38 <Biggles> or spy drones that target the right people
01:32:55 <kmc> easy, just target the ones that hate freedom
01:32:59 <Biggles> the pentagon celebrated when they solved the skin colour conjecture
01:33:04 <tensorpudding> or at least, that is what you think when you get a mediocre math education in public schooling
01:33:25 <Biggles> played connect the dots on a map of the middle east
01:33:40 <Biggles> that's what mathematics is. connect the dots.
01:34:54 <nschoe> Hi everyone! Is there anyone who could help me: I'm getting troubles understanding the State Monad fully. I've been reading many articles, now I'm with http://tinyurl.com/35t2x99 which seems the best I've read so far, but I still can't understand how 'get' and 'put' work.
01:35:27 <kmc> nschoe, before you worry about monads, is it clear how you can "emulate" state using functions of the type s -> (a,s) ?
01:35:41 <danderson> nschoe: have you read the couple of chapters on monads in Real World Haskell?
01:35:53 <Adamant> Biggles: the skin color conjecture failed to take into account modern counterinsurgency theory
01:35:57 <kmc> nothing monadic to it, we just have to take a state as a parameter, and return a result tupled with a new state
01:36:38 <Biggles> Adamant: and therefore was in line with the domminant millitary strategy at the time
01:36:44 <nschoe> danderson: Yes I did. I thought I had understood it, but it happens I'm missing something.
01:36:53 <nschoe> kmc: well, I guess so, but not sure anymore.
01:36:58 <kmc> why not anymore?
01:37:15 <kmc> under that scheme, get = \s -> (s,s)
01:37:23 <ketil> kmc, "...that's not my department! - says Werner von Braun"
01:37:25 <kmc> get the state, return the state unchanged, and also produce that state as a value
01:37:32 <nschoe> kmc: well if you ask, it means there should be something kinda tricky, isn't there?
01:37:51 <Adamant> Biggles: what time, Genghis Khan's?
01:37:53 <kmc> no
01:38:00 <kmc> it means that people think there's something tricky when there isn't
01:38:10 <kmc> the idea of passing and returning states is quite straightforward
01:38:23 <nschoe> kmc: well the part I don't get is: 'get' is implemented as: get = State $ \s -> (s, s)
01:38:29 <kmc> ok
01:38:38 <kmc> well, the State monad is just a type to wrap this idea of functions s -> (a,s)
01:38:50 <kmc> so that we can use monad operators / syntax
01:39:03 <nschoe> But, when I read the definition of their follDie function (and actually every definition I've read about State), the first line is : 'do generator <- get'
01:39:12 <kmc> yeah
01:39:21 <nschoe> kmc: Yes I thought I had understood it that way.
01:39:22 <kmc> do { x <- get; e }   ===   get >>= (\x -> e)
01:39:44 <kmc> if you read the definition of (>>=) for State
01:39:51 <kmc> you will see that it pipes that state parameter through two actions
01:39:55 <kmc> @src State (>>=)
01:39:55 <lambdabot> Source not found. That's something I cannot allow to happen.
01:40:18 <nschoe> kmc: yes... that's what I've been said too. But I still don't understand why 'get' has no argument: get = State $ \s -> (s,s) so 'get' *is* a function that *from a state* returns the tuple (s,s).
01:40:34 <kmc> get is not quite a function
01:40:36 <nschoe> But in 'do generator <- get' where is the state 'get' is supposed to return the tupple from?
01:40:46 <kmc> it's a function, wrapped in this State constructor
01:40:57 <kmc> nschoe, look at the definition of (>>=)
01:41:03 <kmc> because 'get' is the first argument to (>>=)
01:41:11 <nschoe> Hum okay.
01:41:16 <nschoe> Let me find it.
01:41:16 <kmc> and so (>>=) is what determines how its argument is used
01:41:24 <kmc> thus determines how the function wrapped inside is called
01:41:44 <kmc> http://hackage.haskell.org/packages/archive/mtl/1.1.1.0/doc/html/src/Control-Monad-State-Lazy.html#State
01:41:47 <c_wraith> nschoe, one thing to internalize: values in the state monad are *not* values carrying around some magical state.  Instead, they're functions for how to transform an initial state that's passed in.
01:42:08 <c_wraith> nschoe, so when you manipulate State values, you're composing those functions
01:42:11 <nschoe> c_wraith: okay. Thanks that confirms what I've been said.
01:42:42 <dolio> get :: s -> (s, s)
01:42:58 <dolio> There's about one sensible way to write that.
01:44:11 <nschoe> kmc: I think I got it, the 'get' gets its "argument" in the definition of (>>=), in this moment : '(a, s') = runState m s' where 'm' is actually 'get', right?
01:44:30 <kmc> yes
01:46:27 <nschoe> kmc: okay, I think I got it: I was being tricked by the do notation: if I use what you say : get >>= (\x -> e) it seems clearer that (>>=) will sort of "apply" 'get' to the following, right?
01:49:20 <kmc> right
01:49:48 <kmc> since get is a (State s) action, (get >>= (\x -> e)) must be a (State s) action
01:50:19 <kmc> it's the action which takes a state, passes it through the function wrapped inside 'get', to get a tuple
01:50:32 <kmc> passes the "result" part of the tuple to (\x -> e) to get a second action
01:50:39 <kmc> then passes the "state" part of that tuple to that wrapped function
01:50:44 <kmc> to get a final (result, new state) pair
01:51:10 <nschoe> Hum 'kay.
01:51:56 <kmc> it's a little intricate, but it's the natural thing to do with those types
01:53:13 <nschoe> So eventually, 'get' will indeed by applied to a state, but that occurs in the definition of (>>=) : in the (a, s') = runState m s part, in the case m is get it's something like "(st, st) = runState get s" (I used 'st' twice, because get gives a tuple with twice the state).
01:53:47 <kmc> yeah
01:53:58 <nschoe> kmc: okay, then thanks, I think I finally got the whole thing (and as they say in the wikibook, the name State for the monad is a bit tricky: it is rather a StateProcessor).
01:54:31 <kmc> yeah
01:54:42 <quicksilver> one perspective is that the state monad is just a set of combinators for building up functions.
01:54:54 <kmc> indeed, the "monad" part is not magical special sauce
01:54:57 <quicksilver> it happens to let you use the monad notation / standard combinators to build functions
01:54:58 <nschoe> quicksilver: yes, now I understand that.
01:55:01 <kmc> it's just one convenient API for building up these functions
01:55:03 <quicksilver> if you find that useful.
01:55:11 <kmc> anyway you'll rarely want to name the State type explicitly
01:55:17 <nschoe> defintely yeah.
01:55:24 <kmc> i usually make a type synonym and/or a newtype wrapper
01:55:28 <kmc> when i use mtl monad stacks
01:56:05 <nschoe> Yeah like 'RandomState a = State StdGen a" in RWH.
01:57:38 <kmc> yeah
01:57:43 <nschoe> And once we're done combining functions in the State monad, to actually use them, we "just" have to supply an initial state value whose type matches the type we used in our combined functions. That's why in RWH they use at a moment oldState <- getStdGen, right?
01:58:38 <kmc> i guess so
01:58:43 <nschoe> Okay.
01:58:56 <kmc> to actually use the built-up action, you'd call runState
01:59:03 <kmc> or pattern-match on the State constructor directly
01:59:45 <nschoe> Well, kmc, quicksilver, dolio, c_wraith (I'm sure I forget some) thanks a lot, I think things are definitely clearer in my mind, thanks a lot!
01:59:53 <kmc> no problem :)
01:59:58 <c_wraith> you're welcome :)
01:59:58 <kmc> good luck in your future haskelling
02:00:36 <nschoe> Thanks, just a last question (after that I leve you alone :D ). For what/ where/ why is the State monad usually used?
02:01:09 <nschoe> I mean if you are programmign a sort of game, would you keep the map of the game into a State monad? Will you keep your character's characteristics in a State Monad?
02:01:15 <kmc> you might
02:01:18 <kmc> or you might use IORefs
02:01:23 <Zao> Stuff you can't be arsed shoveling through parameters to all the functions in a chain.
02:01:25 <kmc> or write a custom monad from scratch
02:01:30 <kmc> or use StateT on some other monads
02:01:31 <kmc> or use STM
02:01:35 <kmc> or ST
02:01:39 <nschoe> Hum okay. Many ways.
02:01:40 <kmc> there's a lot of ways to handle state in Haskell
02:01:46 <nschoe> Yes I can see that.
02:01:49 <kmc> or, if you ask trolls, there is no way to handle state in Haskell
02:01:51 <kmc> ;)
02:02:16 <nschoe> are IORefs common things in Haskell? I thought they were sort of "hacks", that it was not really haskellish?
02:02:25 <kmc> *shrug*
02:02:34 <kmc> sometimes your problem is inherently IO-ful
02:02:47 <kmc> . o O ( does that rhyme with "awful"? )
02:02:54 <nschoe> I means, using IORefs seems to be c++ -like programming:
02:03:01 <nschoe> Lol IO-full, nice ^^
02:03:02 <kmc> also sometimes you need the performance of real in-place updates
02:03:07 <kmc> which State will not give you
02:03:08 <kmc> but ST will
02:03:25 <kmc> while preserving pure interface
02:03:29 <nschoe> Hum okay.
02:03:36 <kmc> GHC uses IORefs for unification variables during type inference
02:03:40 <kmc> this gives good performance
02:03:52 <kmc> it is not clear how far one can generalize this data point
02:04:03 <kmc> remember that GHC itself is an artifact of 20 years of Haskell evolution
02:04:16 <kmc> i bet some of the code predates ST
02:04:37 <nschoe> But for instance, when you program a simple mario like game in C for instance, at the beginning you define some constants such as max_life, max_ammo, max_speed. Etc. Hwo would you do that in Haskell? Using a State? Using IORefs?
02:05:07 <Maddas> Why would you use IORefs to define a constant?
02:05:11 <Maddas> (Sorry, just jumped in)
02:05:25 <kmc> they aren't constants
02:05:31 <Maddas> Ok.
02:05:39 <nschoe> Maddas: I dunnow I'm just asking how you would define some "universal" constants in a program.
02:05:51 <kmc> oh sorry, i thought you were replying to me not nschoe
02:06:01 <kmc> nschoe, i'd use a top-level definition
02:06:03 <kmc> if they're really constants
02:06:04 <kmc> jut say
02:06:07 <kmc> max_speed = 20
02:06:10 <kmc> in your file
02:06:12 <Maddas> Yes, I'd think a normal variable would be perfectly adequate.
02:06:32 <Maddas> (But I don't know whether you have specific requirements)
02:06:42 <nschoe> Okay, so it is "common" thing to just define some variables like that?
02:06:45 <kmc> yes
02:06:46 <Maddas> Absolutely
02:06:47 <nschoe> Ok.
02:06:55 <sipa1024> variables is haskell are not variable anyway
02:07:00 <kmc> it's harder when your "constants" depend on a cmd line parameter or config file etc.
02:07:04 <kmc> then you have to pass them everywhere
02:07:07 <kmc> or use hacks to get global IORefs
02:07:18 <kmc> or global "constants" that actually do IO
02:07:41 <nschoe> Hum. yeah, that may be a problem.
02:07:58 <kmc> or make your config file the main module of the Haskell program, and recompile on edit
02:08:00 <kmc> like xmonad does
02:08:06 <kmc> the dyre package will help with that
02:08:07 <nschoe> I don't actually know for now, I have to think again the whole thing now I understood a bit more State.
02:08:27 <yitz> sipa1024: they're variables. they just don't vary. um...
02:08:38 <nschoe> kmc: well I do have a file that needs to be loaded, it's a map.
02:08:43 <Maddas> If you really want a constant, a top-level definition is a perfectly good way to start.
02:09:04 <kmc> they're variables in the math sense
02:09:12 <yitz> kmc: right
02:09:12 <nschoe> Maddas: Yeah okay, actually I don't need any for the moment, I was just asking because I wondered, but thanks, I keep all you said in mind.
02:11:10 <nschoe> And what if I want to keep track of the position of my character? Where and how should I keep it? Should I use a State whose state is a (Position, Map) tupple for instance? I mean isn't it a disgusting way of doing things? Can it be thought of (even if it's not the most elegant solution)?
02:11:36 <quicksilver> that's fine
02:11:47 <quicksilver> you probably end up with something larger than that
02:11:53 <quicksilver> State GameWorld
02:12:09 <quicksilver> where 'GameWorld' is a big record/tuple with all the state of your game.
02:12:33 <nschoe> quicksilver: yeah of course, it was jsut to make things faster to write, but I intented to use some type like that.
02:12:36 <quicksilver> this is really quite a nice system because you know exactly what all your state is - you know exactly what you need to do to load and save
02:13:00 <nschoe> quicksilver: Yeah, now you say it, that looks nice, but one question: isn't it too heavy to carry around?
02:13:03 <quicksilver> no
02:13:07 <quicksilver> it's not moving ;)
02:13:14 <nschoe> lol
02:13:29 <quicksilver> it's just a point which is accessible to your codew
02:13:33 <quicksilver> nothing is actually moving around memory
02:13:42 <quicksilver> pointer, that should have been.
02:14:04 <quicksilver> also, you can save the previous GameWorld if you want => you get undo functionality for free.
02:14:07 <quicksilver> well, almost for free.
02:14:20 <nschoe> Well, each time you use runState or so, you yield another GameWorld with for instance the position modified, but it involves creating a GameWorld, so I wonder if it's not too heavy.
02:14:34 <kmc> nschoe, instead of a tuple, probably a custom state type
02:14:55 <kmc> yeah like quicksilver said with GameWorld
02:15:01 <nschoe> kmc: yeah definitely, that's what quicksilver said it's the GameWorld we're talking about.
02:15:19 <kmc> creating a GameWorld is not too heavy, if the stuff inside is shared
02:15:31 <nschoe> kmc: And I was wodnering whether it was not too heavy: because as Haskell can't modify things, it has to create them each time, so... heavy?
02:15:42 <kmc> it has to create them, but they can contain pointers back into the old version
02:15:45 <nschoe> kmc: what do you mean "is shared"?
02:16:08 <kmc> i mean that if we say «f (World x y z) = World (g x) y z»
02:16:16 <kmc> the y and z parts of the world are shared in memory between the two World objects
02:16:25 <kmc> two pointers to the same structure
02:16:27 <nschoe> kmc: okay exactly what I was about to ask.
02:16:35 <frerich4> quicksilver: Is there some way to apply a "filter view" or something to a monad like GameWorld so that it's possible to expose just a small part of the global "GameWorld" state (like, just the position of objects) to some part of the code (like the collision detection)? I'm probably just being naive here (I only wrote tiny Haskell experiment programs so far).
02:16:45 <kmc> this is why you can insert into a huge Data.Map and not incur the cost of copying the whole thing
02:16:53 <kmc> you only copy the spine from the root to the new node
02:17:02 <kmc> which is a logarithmic amount of work in the size of the tree
02:17:02 <nschoe> game {position = (x', y')} only changes the position and everything else contained in the GameWorld is shared that way, right?
02:17:03 <quicksilver> frerich4: Yes; you define a new type for that.
02:17:13 <kmc> this sort of data structure is /really nice/ especially when you have concurrency
02:17:20 <quicksilver> nschoe: right.
02:17:21 <kmc> because you can get a permanent consistent snapshot of the state for free
02:17:46 <quicksilver> nschoe: the cost is literally just a few pointers
02:17:55 <kmc> that's why Clojure, despite allowing side effects everywhere, emphasizes pure functions and immutable data
02:18:06 <nschoe> Okay.
02:18:18 <kmc> and it replaces traditional Java-ish destructive containers with clever persistent alternatives, such that you still have cheap updates but also high sharing
02:18:27 <nschoe> And all thar is handled by Haskell right? I don't have to do any special things for haskell to share the pointers?
02:18:31 <kmc> right
02:18:37 <kmc> well, it's the implementation's responsibility
02:18:39 <kmc> GHC probably
02:18:54 <kmc> i'm not sure what sharing guarantees the Haskell Report provides, if any
02:19:01 <kmc> it's kind of silent on operational details
02:19:02 <quicksilver> none explicitly.
02:19:05 <nschoe> kmc: Wow, nice work they did. Haskell is definitely something I love (even though I don't anything^^)
02:19:11 <quicksilver> it makes a few remarks which rather imply sharing
02:19:15 <quicksilver> but it doesn't mandate anything.
02:19:17 <kmc> but yes in practice with sane Haskell compilers, it will share
02:19:25 <nschoe> Okay.
02:20:03 <nschoe> Well, thanks a lot again you all!
02:21:18 <Peaker> In heap profiling, you can see gradual decreases in memory consumption.  Does this mean that each sample follows GC? Or does it somehow know the heap shrunk without GC?
02:21:41 <mun_> hi
02:21:56 <mun_> is quantification over types allowed in second-order logic?
02:22:36 <quicksilver> logic doesn't have types.
02:22:50 <quicksilver> second order quantification is quantificaiton over prepositions
02:22:56 <quicksilver> propositions, rather :)
02:23:09 <quicksilver> and propositions are the things that correspond to types under C-H.
02:23:50 <quicksilver> Peaker: as far as I know, samples are not guaranteed to follow GCs but minor GCs are quite frequent.
02:24:35 <mun_> quicksilver, doesn't second-order quantification is quantification over functions? or do functions correspond to propositions?
02:24:43 <dolio> Really, in second order logic, you usually get quantification over sets of some kind.
02:25:05 <dolio> Or collections of individuals in some manner.
02:25:47 <dolio> And propositions and collections of individuals both correspond to types under Curry-Howard, so they're unified.
02:27:12 <ski> quicksilver : .. there is "many-sorted logics"
02:28:02 <dolio> Of course, you can look at predicates and propositions as sets in ordinary logic, too.
02:28:19 <dolio> Associate a predicate with the set of all individuals that satisfy it.
02:29:07 <mun_> but since propositions correspond to types, why is it wrong to say that second-order quantification is quantification over types?
02:29:27 <Peaker> quicksilver, So it's likely that they do happen to correspond to minor GC's, I guess
02:29:32 <kmc> you can say that, if you're looking through the curry-howard lens
02:29:43 <kmc> there's no such thing as a 'type' in the logician's second-order logic, though
02:30:28 <dolio> It's the same reason one wouldn't talk about quantification over proofs in first-order logic.
02:31:11 <kmc> all the values in first-order set theory are proofs of a boring proposition
02:31:28 <kmc> if everything has type Set then every value is a proof of Set
02:31:56 <kmc> apparently Stack Overflow has set up a realtime web-based chat
02:32:00 <kmc> wonder how it will affect #haskell
02:32:59 <dolio> As in, it will send people here?
02:33:06 <kmc> or draw people away
02:33:07 <dolio> Or lure newbies away?
02:33:10 <dolio> Ah.
02:33:11 <kmc> or i don't know *shrug*
02:35:08 <quicksilver> ski: there is, but that's not what I understand by "second-order logic"
02:35:38 <dolio> You could probably have many-sorted second-order logic.
02:35:50 <quicksilver> you can have may things, I agree :)
02:36:03 <quicksilver> I'm only explaining that I answered the question in the context of the simplest thing it might mean.
02:39:24 <yitz> kmc: most of what is on SO is somewhat annoying, and at most marginally on topic. so i doubt their chat will have any negative effect on this channel - more likely a positive effect if any
02:39:44 <kmc> i've found the haskell-tagged questions to be pretty good
02:40:04 <kmc> a few were noise and they were quickly downvoted / closed
02:40:08 <kmc> can't speak for the rest of the site
02:40:08 <yitz> kmc: relatively, but not nearly as good as what usually goes on here
02:40:59 <yitz> kmc: do you get karma from chats?
02:42:10 <kmc> dunno
02:42:30 * edwardk waves hello.
02:42:55 <arcatan> hmm, i don't have enough karma to chat. oh well.
02:43:49 <edwardk> arcatan++
02:43:50 <edwardk> there
02:44:14 <kmc> hi edwardk :)
02:44:29 <edwardk> how goes?
02:44:35 <kmc> goes ok
02:44:52 <kmc> unfortunately i think i won't make it to boston haskell :/
02:44:59 <edwardk> spent the weekend here in california playing haskell evangelist
02:45:15 <kmc> looks like a good set of talks too, i hope there's slides or video
02:45:27 <kmc> who're you evangelizing to?
02:46:36 <edwardk> speaking of which, is anyone in the san francisco bay area that wants to meet? i'm here until noon tomorrow
02:46:36 <edwardk> kmc: the google summer of code mentor's summit, so ~230 or so open source types
02:47:26 <kmc> cool
02:47:43 <edwardk> gave a talk answering questions about haskell and tried to systematically work my way through the list of the other attendees ;)
02:49:08 <sipa1024> @pl \x -> "bla" ++ foo $ bar x
02:49:08 <lambdabot> ("bla" ++ foo) . bar
02:50:07 <arcatan> thaght might not be what you wanted
02:50:11 <arcatan> -g
02:50:34 <sipa1024> @pl \x -> ("bla" ++ (foo $ bar x))
02:50:35 <lambdabot> ("bla" ++) . foo . bar
02:50:51 * sipa1024 will never get used to all precendence
03:45:11 <Taejo> > inits =<< tails "Taejo"
03:45:12 <lambdabot>   ["","T","Ta","Tae","Taej","Taejo","","a","ae","aej","aejo","","e","ej","ejo...
03:47:22 <mm_freak_> > zip <$> inits <*> tails $ "Taejo"
03:47:23 <lambdabot>   [("","Taejo"),("T","aejo"),("Ta","ejo"),("Tae","jo"),("Taej","o"),("Taejo",...
03:49:09 <Maxdamantus> :t inits
03:49:10 <lambdabot> forall a. [a] -> [[a]]
03:49:16 <Maxdamantus> :t tails
03:49:17 <lambdabot> forall a. [a] -> [[a]]
04:10:34 <yitz> :t zip <$> inits
04:10:35 <lambdabot> forall b a. [a] -> [b] -> [([a], b)]
04:12:14 <aristid> :t \f -> f <*> tails
04:12:15 <lambdabot> forall b a. ([a] -> [[a]] -> b) -> [a] -> b
04:15:30 <aristid> :t inits <*> tails
04:15:31 <lambdabot>     Couldn't match expected type `a -> b'
04:15:31 <lambdabot>            against inferred type `[[a1]]'
04:15:31 <lambdabot>     Probable cause: `inits' is applied to too many arguments
04:25:28 <astroboy> is there a way to get the int timestamp in haskell?
04:26:35 <quicksilver> getCurrentTime
04:26:44 <quicksilver> not sure what you mean by int timestamp
04:26:52 <quicksilver> probably you want to convert to epoch seconds
04:28:16 <aristid> @tell chrisdone haskell-align-imports could sort the import lines alphabetically, too :)
04:28:16 <lambdabot> Consider it noted.
04:28:26 <aristid> i hope this is the real lambdabot?
04:28:38 <Jafet> Maybe he means one that overflows back to 1901 by 2038
04:29:03 <Lycurgus> prolly meant the unix system time value
04:30:16 <aristid> Jafet: i thought it overflows back to 1970
04:30:16 <astroboy> quicksilver: what Lycurgus said :P
04:30:26 <astroboy> the thing is, I have to generate the random number generator
04:30:35 <astroboy> and in c I feed it with the timestamp
04:31:51 <quicksilver> astroboy: don't do anything.
04:32:02 <quicksilver> the random number generator is automatically seeded 
04:32:11 <quicksilver> (with something using the current time and PID IIRC)
04:34:59 <astroboy> quicksiver: then why mkStdGen?
04:35:23 <quicksilver> mkStdGen is for when you want to choose the seed.
04:35:34 <quicksilver> there are lots of reasons to want to do that
04:35:43 <quicksilver> but it's a spurious reason to ask for a unix-style timestamp
04:35:46 <quicksilver> since that's already done for you
04:38:13 <astroboy> quicksilver: ok ok, I was used to the other method :P
04:38:38 <astroboy> then should I use newStdGen and unsafePerformIO or something like that?
04:38:44 <astroboy> or mkStdGen 1?
04:40:52 <astroboy> i'm confused.
04:50:15 <Twey> anonym: Just call newStdGen.  It will be seeded for you.
04:50:42 <anonym> wait what?
04:51:03 <anonym> Did you mean: _astroboy_?
04:51:45 <Twey> Sorry, yes
04:51:49 <Twey> astroboy: ^
04:51:51 <quicksilver> astroboy: well, if you're in a place where you'd need to unsafePerformIO newStdGen
04:51:59 <quicksilver> then you would also need to unsafePeformIO getCurrentTime
04:52:03 <quicksilver> so really it's no different
04:52:03 <FauxFaux> Haha, I thought you meant google was correcting newStdGen to astroboy.
04:52:11 <Twey> Haha
04:52:16 <quicksilver> any method to get the current timestamp will obviously require IO
04:52:23 <quicksilver> explicitly, or implicitly in newStdGen
04:55:30 <Twey> It's not very implicit in newStdGen
04:55:34 <Twey> :t newStdGen
04:55:35 <lambdabot> IO StdGen
04:55:43 <Twey> Look, it says it right there in the type
04:57:55 <quicksilver> Twey: the access to the current timestamp is implicit ;)
04:58:00 <quicksilver> the IO is, as you say, quite clear.
05:54:39 <MrAI2> Hey all
05:54:53 <MrAI2> *waits for the spam replies*
05:57:25 * Botje watches the tumbleweed roll by
05:57:36 <Axman6> spam? :\
05:58:22 <pumpkin> strathclyde!
05:59:07 <sipa1024> ?
05:59:26 <pumpkin> MrAI2 was from strathclyde
05:59:33 <sipa1024> ic
06:19:44 * hackagebot snap-core 0.2.14 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.14 (GregoryCollins)
06:21:29 <Axman6> anyone about who wouldn't mind commenting on the type of my C code? it seems nice and clear to me, but since i don't look at much C not written by me, i don't know if it's completely horrible in comparison
06:22:27 <Botje> Axman6: sure, bring it on
06:23:01 <Axman6> http://hpaste.org/40866/prims_mst
06:23:33 <Botje> you have to add that disclaimer? cool :)
06:23:45 * hackagebot snap-server 0.2.14 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.14 (GregoryCollins)
06:23:56 <Axman6> well, we weren't told to, but i do in general
06:24:09 <Botje> okay if i put comments in a /query?
06:24:16 <Axman6> sure
06:24:47 <Axman6> ah bugger, can you send that again? i closed it while trying to close another window -_-
06:29:59 <zygoloid> Axman6: i'd use typedefs rather than #defines for the Q_FOO types
06:30:12 <Axman6> yeah, Botje suggested that too
06:31:03 <zygoloid> that's a good argument for commenting in public :)
06:32:02 <Twey> Axman6: Aren't you now collaborating with other people to produce it? :þ
06:32:29 <Axman6> nah, i've already submitted it, i'd just like some tips now :)
06:32:42 <Twey> ‘pi’?
06:33:06 <zygoloid> Axman6: can you get in trouble from other people copying it?
06:33:28 <Axman6> well, it was due on friday, and i gopt an extension, so not likely ;)
06:34:09 <Twey> That's a pretty massive main() function.
06:34:27 <Twey> ‘return’ has low precedence, no need for brackets
06:34:45 <Axman6> Twey: the pi comes directly from the algorithm we were given, it's supposed to be a pointer to the parent in the MST
06:35:05 <Twey> Oh
06:35:08 <Twey> It's not actually pi
06:35:20 <Twey> I was wondering why you were storing π on every vertex :þ
06:36:06 <Axman6> heh
06:37:15 <jkff> Looks like I've run into the exponential merge behavior of darcs :( I thought it was gone
06:37:24 <Axman6> Twey: especially since i am storing it as an int? :P
06:37:30 <jkff> I'm pulling 19 patches for already 1.5 hours 
06:37:59 <Saizan> jkff: repo type?
06:38:15 <jkff> Don't know. How to check it?
06:38:47 <Saizan> jkff: darcs show repo
06:39:00 <jkff> Format: hashed
06:39:14 <jkff> Pristine: HashedPristine , if that matters
06:39:56 <Saizan> not sure then, if it was 1 or 2 i'd know :)
06:40:38 <jkff> And this repo only has 283 total patches
06:41:09 <elverkilde> can someone help me debug a stack overflow?
06:41:10 <jkff> darcs is currently "reading pristine 5/31" (for the first 40 minutes or so it has been "Merging them 7/19")
06:41:12 <Axman6> so, the interesting thing that this code shows when you run it, is that the average weight of a randomly weighted complete graph is about 1.2
06:41:19 <jkff> elverkilde: hpaste the code
06:41:26 <Axman6> uh, average weight of the minimum spanning tree
06:41:32 <elverkilde> http://hpaste.org/40867/bytestring_foldm
06:41:51 <elverkilde> thanks
06:43:24 <jkff> elverkilde: what is this code supposed to do?
06:43:55 <elverkilde> I need to do a monadic fold on bytestrings
06:44:15 <elverkilde> there is no foldM for bytestrings, so I did my own
06:44:17 <jkff> I see, but why are you invoking it with 'undefined' and '()' ?
06:44:27 <jkff> I mean, what is it supposed to produce?
06:45:41 <elverkilde> I want to generate a bitarray
06:46:00 <elverkilde> but for testing I've tried e.g. print
06:46:18 <elverkilde> this was just a minimal failing example
06:46:54 * hackagebot murmur-hash 0.1.0.2 - MurmurHash2 implementation for Haskell.  http://hackage.haskell.org/package/murmur-hash-0.1.0.2 (ThomasSchilling)
06:47:03 <EvanR-work> [Bit] ;)
06:47:11 <EvanR-work> the ultimate data structure!
06:48:19 <elverkilde> Ah, the point is not really the datastructure. The problem is my definition of foldM. Whatever monadic computation I stick into it fails (on big input)
06:48:32 <elverkilde> - it just generates one big thunk
06:48:41 <zygoloid> EvanR-work: Mu (Join Either) :)
06:49:02 <EvanR-work> whats Mu 
06:49:15 <zygoloid> @src Mu
06:49:15 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
06:49:36 <Jafet> The zen answer to "how do I write a Y combinator?"
06:49:50 <EvanR-work> ah
06:49:54 <EvanR-work> whats Join
06:50:06 <Jafet> Beats me
06:50:09 <Jafet> @src Join
06:50:09 <lambdabot> Source not found. That's something I cannot allow to happen.
06:50:14 <zygoloid> newtype Join f a = Join (f a a)
06:53:08 <Axman6> :t let a = In (Left (In (Right a))) in a
06:53:15 <lambdabot>     Occurs check: cannot construct the infinite type: a = Mu (Either a)
06:53:15 <lambdabot>       Expected type: Mu (Either a)
06:53:15 <lambdabot>       Inferred type: Mu (Either (Mu (Either a)))
06:53:53 <Axman6> :t let a = In (Join (Left (In (Join (Right a))))) in a
06:53:54 <lambdabot> Not in scope: data constructor `Join'
06:53:54 <lambdabot> Not in scope: data constructor `Join'
06:53:59 <Axman6> :(
06:54:09 <danr> :/
07:00:49 <Twey> Axman6: Aye :þ
07:06:11 <MrAI> hey people
07:06:35 <roconnor> What's a Schanuel topos?
07:07:36 <MrAI> Richard?
07:09:24 <Fraser> http://www.brics.dk/~pawel/papers/toposesAdhesive.pdf
07:09:42 <aristid> @let rotations = zipWith (++) <$> tails <*> inits
07:09:44 <lambdabot>  Defined.
07:09:55 <aristid> > rotations "rotations of strings"
07:09:57 <lambdabot>   ["rotations of strings","otations of stringsr","tations of stringsro","atio...
07:10:17 <MrAI> See http://www.springerlink.com/content/l503328863h56645/fulltext.pdf
07:10:46 <Jafet> > let bw str = head <$> sort ('$' : str) in bw "compress me! compress me baby!"
07:10:47 <lambdabot>   Couldn't match expected type `[a]'
07:10:47 <lambdabot>         against inferred type `GHC.Types...
07:11:02 * hackagebot SoccerFun 0.1 - Haskell port of a football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.1 (JanRochel)
07:11:04 <Jafet> Oops, dysfunction
07:11:08 <opqdonut> indeed
07:11:25 <Jafet> > let bw str = head <$> sort (rotations $ '$' : str) in bw "compress me! compress me baby!"
07:11:26 <lambdabot>   "    !!$$abbcceeeemmmmoopprrssssy"
07:11:42 <opqdonut> > let bw str = last <$> sort (rotations $ '$' : str) in bw "compress me! compress me baby!"
07:11:43 <lambdabot>   "e!ssey!!b a $mmrr  ooccmmppsseeb"
07:11:46 <opqdonut> there
07:11:53 <Jafet> Need sortBy to put $ first...
07:12:02 <Jafet> > let bw str = head <$> sort (rotations $ chr 0 : str) in bw "compress me! compress me baby!"
07:12:03 <lambdabot>   "\NUL\NUL    !!abbcceeeemmmmoopprrssssy"
07:12:12 <aristid> > rotations "abc"
07:12:13 <lambdabot>   ["abc","bca","cab","abc"]
07:12:15 <opqdonut> but head is wrong
07:12:19 <opqdonut> with that ordering
07:12:34 <Jafet> So it is
07:12:42 * shapr hugs aristid 
07:12:43 <aristid> rotations returns one too many
07:12:50 <aristid> shapr: hey shapr :)
07:12:54 <zygoloid> > let rle = map (head &&& length) . group in rle "e!ssey!!b a $mmrr  ooccmmppsseeb"
07:12:55 <lambdabot>   [('e',1),('!',1),('s',2),('e',1),('y',1),('!',2),('b',1),(' ',1),('a',1),('...
07:14:38 <joe1> MrAI: still going strong?
07:16:33 <danr> Jafet: are you using head <$> instead of map head?
07:16:55 <aristid> but i think the bwts are all wrong
07:17:08 <aristid> because they need to ignore the marker when sorting AFAIK
07:17:41 <Jafet> > let bwt str = last <$> sortBy (\x y -> flip compare `on` filter (/= chr 255)) (tail $ rotations $ chr 255 : str) in bwt "SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES"
07:17:42 <lambdabot>   Couldn't match expected type `GHC.Ordering.Ordering'
07:17:42 <lambdabot>         against inferr...
07:18:05 <Jafet> Er, intimate privmsg time
07:18:33 <aristid> > comparing (filter (/= '@')) "@abc" "a@bc"
07:18:34 <lambdabot>   EQ
07:19:16 <Jafet> Oh, heh, I wrote a pointfree lambda
07:19:39 <Jafet> > let bwt str = last <$> sortBy (compare `on` filter (/= chr 255)) (tail $ rotations $ chr 255 : str) in bwt "SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES"
07:19:40 <lambdabot>   "TEXYDST.E.IXIXIXXSSMPPS.B..E.\255S.EUSFXDIIOIIIT"
07:20:31 <aristid> > map head . sortBy (comparing $ filter (/= '@')) . rotations . ('@' :) $ "Compress me! Compress me! Compress me!"
07:20:32 <lambdabot>   "     !!!@C@CCeeeeeemmmmmmoooppprrrssssss"
07:20:46 <opqdonut> it's still last and not head :)
07:20:59 <aristid> opqdonut: does it have to be last?
07:21:01 <Jafet> And note the tail . rotations
07:21:08 <opqdonut> aristid: now you've just sorted the string
07:21:20 <opqdonut> > sort ""Compress me! Compress me! Compress me!"
07:21:21 <lambdabot>   <no location info>:
07:21:21 <lambdabot>      lexical error in string/character literal at end o...
07:21:22 <opqdonut> gah
07:21:24 <opqdonut> > sort "Compress me! Compress me! Compress me!"
07:21:25 <aristid> opqdonut: strictly speaking, the marker must be on the end and not in the beginning
07:21:25 <lambdabot>   "     !!!CCCeeeeeemmmmmmoooppprrrssssss"
07:21:34 <opqdonut> aristid: it doesn't matter, actually
07:21:41 <opqdonut> as long as you know which it is
07:21:42 <aristid> where the marker is?
07:21:52 <aristid> but it has to be the last element of the list?
07:21:54 <Jafet> The decoder just needs to know where the marker was placed.
07:21:56 <opqdonut> but if you want to use head, you need to use a different ordering
07:22:05 * hackagebot persistent 0.3.0 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.3.0 (MichaelSnoyman)
07:22:07 * hackagebot persistent-postgresql 0.3.0 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.3.0 (MichaelSnoyman)
07:22:09 * hackagebot persistent-sqlite 0.3.0 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.3.0 (MichaelSnoyman)
07:22:18 <aristid> opqdonut: reversing the sort? would that do?
07:22:23 <opqdonut> no
07:22:29 <opqdonut> that's the same as reversing the output string
07:22:40 <aristid> reversing the input string?
07:23:00 <opqdonut> > map head . sortBy (comparing reverse) . rotations . ('@' :) $ "mississippi"
07:23:01 <lambdabot>   "ms@@spipissii"
07:23:03 <opqdonut> yes
07:23:15 <opqdonut> > map head . sortBy (comparing reverse) . tail . rotations . ('@' :) $ "mississippi"
07:23:16 <lambdabot>   "ms@spipissii"
07:23:39 <aristid> opqdonut: that doesn't ignore the marker in the compare :)
07:23:48 <opqdonut> it shouldn't
07:23:59 <aristid> not? hmm i read that otherwise
07:24:08 <opqdonut> the marker should just be bigger or smaller than all the other letters
07:24:13 <opqdonut> smaller is the usual version
07:24:23 <aristid> so '@' does well here
07:24:24 <opqdonut> > map head . sortBy (comparing reverse) . tail . rotations . ('@' :) $ "MISSISSIPPI"
07:24:25 <lambdabot>   "MS@SPIPISSII"
07:24:31 <opqdonut> yes
07:24:46 <aristid> > rotations "abc"
07:24:47 <lambdabot>   ["abc","bca","cab","abc"]
07:24:57 <aristid> does it matter that rotations returns an element too many? :D
07:25:04 <opqdonut> see tail . rotations
07:25:05 <Guest86956> Hello, my compiler says Misplaced Type signature: successors :: State -> [State]. Here is my code: http://hpaste.org/40869/problem (Note the typo it should be [State] but I typed it wrong in)
07:25:08 <Guest86956> how can I fix that?
07:25:12 <aristid> @let rotations = init . (zipWith (++) <$> tails <*> inits)
07:25:12 <lambdabot>  <local>:5:0:
07:25:13 <lambdabot>      Multiple declarations of `L.rotations'
07:25:13 <lambdabot>      Declared at: <...
07:25:15 <opqdonut> but the return value is wrong
07:25:19 <aristid> @undef rotations
07:25:26 <Guest86956> what exactly does Misplaced type signature mean? :(
07:25:39 <opqdonut> even though I spelled mississippi correctly :D
07:26:19 <Guest86956> I indented correctly I think, I did everything correctly as far as I know and still I've done something wrong =(
07:26:21 <aristid> > map last . sort . tail . rotations . ('@' :) : "MISSISSIPPI"
07:26:22 <lambdabot>   Not in scope: `rotations'
07:26:28 <aristid> @let rotations = init . (zipWith (++) <$> tails <*> inits)
07:26:29 <lambdabot>  Defined.
07:26:36 <aristid> > map last . sort . rotations . ('@' :) : "MISSISSIPPI"
07:26:37 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> [GHC.Types.Char]'
07:26:37 <lambdabot>        ...
07:26:42 <aristid> > map last . sort . rotations . ('@' :) $ "MISSISSIPPI"
07:26:43 <lambdabot>   "IPSSM@PISSII"
07:26:49 <Jafet> > rotations "abcde"
07:26:50 <lambdabot>   ["abcde","bcdea","cdeab","deabc","eabcd"]
07:26:58 <aristid> i fixed rotations
07:27:11 <opqdonut> yep
07:27:18 <Jafet> @let bwt str = last . sortBy (comparing $ filter (/= chr 0xf0000)) (rotations $ str ++ [chr 0xf0000]) -- it's *my* private use area now!
07:27:19 <lambdabot>  Defined.
07:27:28 <Axman6> Guest86956: there isn't any need to write out the types in class definitions, but you do need to write o9ut the implementation of the runctions
07:27:29 <aristid> > map head . sortBy comparing . rotations . ('@' :) $ "MISSISSIPPI"
07:27:30 <lambdabot>   Couldn't match expected type `[a]' against inferred type `b -> a1'
07:27:41 <Guest86956> Axman6 I've written them already
07:27:45 <aristid> > map head . sortBy (comparing reverse) . rotations . ('@' :) $ "MISSISSIPPI"
07:27:46 <lambdabot>   "MS@SPIPISSII"
07:27:48 <Guest86956> but I didn't showed..
07:27:51 <Axman6> where are they?
07:27:57 <Guest86956> somewhere above instance
07:28:07 <Guest86956> HERE
07:28:08 <Guest86956> -- Make River an instance of Problem
07:28:09 <Guest86956> instance Problem River where
07:28:09 <Guest86956> -- Note: checks only if all the persons are on the east side of the river.
07:28:09 <Guest86956>     isSolution :: River -> Bool
07:28:09 <Guest86956> -- Note: generates all valid successors
07:28:09 <Guest86956>     successors :: River -> [River]
07:28:17 <Axman6> also, the wypue of the successors is wrong in the first one, it should be State -> [State]
07:28:31 <Axman6> type*
07:28:35 <Guest86956> oh this I renamed state to River
07:29:17 <Guest86956> I also said I had a typo somewhere in this conversation
07:29:40 <Guest86956> I already knew about my typo, I'm sorry for my mistake
07:30:06 <Axman6> well, maybe you could start by showing us the code you actually are having problems with, instead of something that's sort of similar, but not the same, and drastically different :\
07:30:28 <aristid> :t let bwt xs = (findIndex (== xs) &&& map last) . sort . rotations $ xs in bwt "MISSISSIPPI"
07:30:29 <lambdabot> (Maybe Int, [Char])
07:30:29 <Jafet> Or we could just give him mutually inconsistent answers
07:30:42 <aristid> > let bwt xs = (fromJust . findIndex (== xs) &&& map last) . sort . rotations $ xs in bwt "MISSISSIPPI"
07:30:43 <lambdabot>   (4,"PSSMIPISSII")
07:31:07 <Guest86956> Okay
07:31:07 <aristid> i think we can do without the marker, and use an index instead
07:31:15 <Guest86956> brb
07:31:20 <Jafet> Well, that's how the marker is implemented.
07:31:29 <Jafet> Except I abused unicode a bit
07:31:40 <Jafet> And did it wrongly
07:32:00 <aristid> Jafet: if you use a marker, you can't do it on binary data, and that sucks
07:32:30 <Guest86956> Here is my full code
07:32:32 <Guest86956> http://hpaste.org/40870/river_class
07:32:38 <aristid> > let bwt xs = (fromJust . findIndex (== xs) &&& map last) . sort . rotations $ xs in bwt "Compress me! Compress me! Compress me!"
07:32:39 <lambdabot>   (8,"!!ssseee!  mmmrrr   oooCCCmmmpppssseee")
07:32:45 <Jafet> :t let bwt xs = (fromJust . findIndex (== xs) &&& map last) . sort . rotations $ xs in bwt
07:32:46 <lambdabot> forall a. (Ord a) => [a] -> (Int, [a])
07:33:13 <Guest86956> http://hpaste.org/40871/search_class
07:33:17 <Guest86956> my second class code
07:33:50 <Guest86956> Axman6 I'm sorry for not showing my code before
07:33:55 <aristid> Jafet: now, inverse bwt! :D
07:34:14 <Jafet> > let bwt xs = (fromJust . findIndex (== xs) &&& map last) . sort . rotations $ xs in bwt (fromIntegral . ord . "Compress me! Compress me! Compress me!" :: [Word8])
07:34:15 <lambdabot>   (8,[33,33,115,115,115,101,101,101,33,32,32,109,109,109,114,114,114,32,32,32...
07:34:22 <Jafet> Hmph
07:35:12 <Guest86956> So uhm... what actually is a misplaced type signature?
07:35:33 <Axman6> what line is the error talking about?
07:36:03 <Guest86956> line 173:4
07:36:06 <Guest86956> line 171:4
07:36:09 <Axman6> -_-
07:36:16 <Axman6> which line is that in the paste...
07:36:17 <Guest86956> Oh sorry :p
07:36:31 <Guest86956>     successors :: River -> [River]
07:36:34 <Guest86956> this one somewhere below
07:36:44 <Guest86956> error on here:
07:36:45 <Guest86956>     isSolution :: River -> Bool
07:36:45 <Guest86956> -- Note: generates all valid successors
07:36:45 <Guest86956>     successors :: River -> [River]
07:36:50 <Axman6> ... so it's referring to a line you haven't pasted?
07:36:58 <Guest86956> no it's not
07:37:03 <Guest86956> if you look at my hpaste
07:37:05 <Guest86956> it's pasted
07:37:15 <Guest86956> -- Note: checks only if all the persons are on the east side. Definition of isSolution.                                                 
07:37:15 <Guest86956> isSolution (River _ e _ _) = (e == (MultiSet.fromList [Father, Mother, Son, Son, Daughter, Daughter, Policeman, Thief]))
07:37:18 <Axman6> there is no mention of rivers anywhere there
07:37:34 <applicative> you need to define those functions for the Problem class
07:37:56 <Guest86956> ?
07:38:17 <Guest86956> I don't get it
07:38:21 <applicative> Is the definition of "class Problem where...." somewhere in here
07:38:47 <Guest86956> instance Problem River where (this)?
07:38:56 <Guest86956> (I mean you mean that?)
07:38:58 <Axman6> Guest86956: neither do we, you're not making it at all easy to help you, because you aren't even showing us the code where the error is
07:39:09 * hackagebot bytestring-show 0.3.4 - Efficient conversion of values into readable byte strings.  http://hackage.haskell.org/package/bytestring-show-0.3.4 (DanDoel)
07:39:45 <Guest86956> I showed the code where the error is. The error is located 
07:39:45 <Guest86956> --       whether the state can be reached.
07:39:46 <Guest86956> isAdmissible :: River -> Bool
07:39:46 <Guest86956> isAdmissible = applyRules [rule_1, rule_2, rule_3, rule_4]
07:39:46 <Guest86956> -- Make River an instance of Problem
07:39:46 <Guest86956> instance Problem River where
07:39:46 <ski> Axman6,applicative : see the other paste
07:39:46 <Guest86956> -- Note: checks only if all the persons are on the east side of the river.
07:39:46 <Guest86956>    --ERRRORCODE
07:39:47 <Guest86956>    isSolution :: River -> Bool
07:39:48 <Guest86956> -- Note: generates all valid successors
07:39:48 <Guest86956> -- ERRORCODE
07:39:49 <Guest86956>     successors :: River -> [River]
07:40:02 <Axman6> basically what you're doing is something like this: "My car isn't working properly, can you fix it without actually seeing or toouching it? here's a schematic of the engine"
07:40:08 <Guest86956> the code below is the errorcode
07:40:09 <applicative> before you can write "instance MYCLASS MyType where a = foo ; b = bar .... before that, you need the class to instance.
07:40:17 <Axman6> Guest86956: please d not paste code in here!
07:40:19 <Axman6> do*
07:40:48 <Guest86956> applicative, what do you mean by that?
07:40:53 <ski> Axman6,applicative : i.e. <http://hpaste.org/40871/search_class> which Guest86956 linked to
07:40:59 <applicative> oh i see, are you importing the definition from http://hpaste.org/40869/problem
07:41:17 <Saizan> Guest86956: you don't put type signatures inside instances declarations, because the types of the methods are already defined in the class declaration
07:41:32 <ski> Saizan : but it ought to be allowed :/
07:41:55 <applicative> In any case, it's strange, I thought his mistake was that he thought that was going to be enough....
07:41:56 <Guest86956> uhm... according to my book it is allowed?
07:42:06 <ski> afaik, it's not allowed
07:42:13 <ski> but it ought to me, imo
07:42:20 <ski> s/to me/to be/
07:42:23 <Saizan> it's not allowed, books can be wrong :)
07:42:40 <Guest86956> so uhm..
07:42:47 <applicative> It seems bad, since it might overdetermine things.  But I'm always being surprised...
07:42:48 * drhodes does air guitar and rages against the book
07:42:53 <Guest86956> Saizan... what do I need to put under instance Problem River?
07:42:56 <applicative> whats the book
07:43:13 <Saizan> Guest86956: just the definitions of the functions, without the signatures
07:43:22 <Guest86956> well it's by some of my profs
07:43:36 <Guest86956> so where do I need to put the definitions?
07:43:36 * ski wants to slap whoever wrote this assignment, for wanting one to write an instance of `Show' which presumably wouldn't be a valid Haskell expression (otherwise, why not just use `deriving' ?)
07:43:38 <Axman6> where are you taking this course?
07:44:04 <Guest86956> University Utrecht?
07:44:16 <applicative> isSolution x = blah x    successors x = foo x  ; -- where blah takes x -> Bool and foo takes x -> [x]
07:44:44 <Guest86956> okay I try to not to write down the signature
07:44:51 <ski> Guest86956 : you need to put definitions of `isSolution' and `successors' (indented) under `instance Problem River where'
07:44:59 <Guest86956> I've been on it for two hours
07:45:16 <applicative> you need to say what it is for a River to 'be a solution' and what it is for some rivers to be successors of a river.  
07:45:17 <ski> Guest86956 : if you want to write the type signatures there, i'm afraid you'll have to comment them out
07:46:28 <Guest86956> Okay it worked alright, I removed those signatures
07:46:31 <applicative> the important question is, what's the function River -> Bool you need to complete "isSolution river = ...river ..."
07:46:45 <Guest86956> but I wonder why on earth is it not possible to write them there?
07:46:56 <Guest86956> I defined them correctly (I think)
07:47:31 <applicative> I suppose its because they are already written in the other file.  Do you think we should be able to write the same signature five times in one file?
07:47:56 <ski> Guest86956 : i see you already have definitions of `isSolution' and `successors' (at <http://hpaste.org/40870/river_class>). you just need to put them indented under a declaration `instance Problem River where'
07:48:11 <ski> applicative : yes
07:48:14 <Guest86956> applicative, I think it should be allowed
07:48:37 <Guest86956> as long it's correctly you should be able to define it as many times you want
07:49:04 <Guest86956> it gives us a lot useless code, but the compiler should also be able to optimize it...
07:49:18 <ski> applicative : or at least it should be possible to put signatures in `instance' declarations
07:49:33 <applicative> ski, I see them now.  Guest jst needs to move the defs into the instance statement
07:49:55 <ski> (but i don't really see a problem yet with multiple type signatures generally, as along as all are consistent)
07:50:20 <drhodes> if you change one, you have to change another, that's a hassle
07:50:30 <Guest86956> yes I already did that applicative
07:50:35 <Guest86956> and it worked
07:50:46 <applicative> ski, yeah, I don't disagree, I'm kind of surprised it isn't possible (in the typeclass case) -- just writing "isSolution :: River -> Bool" helps clarify the problem....
07:51:04 <Guest86956> however I cannot even define them anymore even above my instance Problem River
07:51:18 <Guest86956> so outside instance I can't even write them...
07:51:28 <Guest86956> but the errormessage all makes sense
07:51:41 <Guest86956> cause it said: "You cannot give a type signature for an imported value)
07:52:50 <ski>   instance Problem River
07:52:51 <ski>     where
07:52:56 <Guest86956> Well I'm disappointed in Haskell for the first time, but I'm happy that thanks to you guys I've solved it! :D
07:53:04 <ski>     isSolution (River _ e _ _) = ..e..
07:53:12 <ski>     successors s@(River w e m p) = ...
07:53:23 <Guest86956> yeah I've done that =)
07:53:24 <ski> that's how you should define them
07:53:35 <ski> (you could change the internal order, if you prefer
07:53:36 <ski> )
07:53:41 <Guest86956> thanks for your insights =)
07:54:33 <ski> drhodes : hm, right ..
07:55:25 <ski> drhodes : i was thinking one use for multiple signatures would be writing one "interface" signature first, and later one "expanded", that has unraveled type synonyms, just above the definition
07:55:41 <applicative> Guest, the given syntax is pretty handsome really.  where you introduce the class you say "class Blah a where; foo :: a -> Bool" then 
07:55:56 <ski> but i suppose this scenario would as well be served by allowing type signatures in export lists
07:56:44 <applicative> then you write "instance Blah River where foo = ...." a similar parallelism is used elsewhere, e.g. with type families.
07:59:19 <applicative> ski, would the purpose be, principally, to see if the compiler agreed with you?
08:00:52 <Jafet> > let f 'i' = 'o'; f x = x in f . "ping"
08:00:52 <Jafet> Oh dear.
08:00:53 <lambdabot>   "pong"
08:03:11 <Guest86956> map (+1) [1,2,3]
08:03:35 <Guest86956> hmm... somehow lamdabot doesn't react to my code.. =(
08:03:47 <ski> you need to prefix with `> '
08:03:57 <ski> > map (1 +) [0,1,2,3]
08:03:58 <lambdabot>   [1,2,3,4]
08:04:42 <Guest86956> oh I see
08:05:03 <Guest86956> > :t map map
08:05:03 <lambdabot>   <no location info>: parse error on input `:'
08:05:06 <applicative> @type (.) -- I can never remember these tricks
08:05:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:05:10 <ski> applicative : which case do you mean ? (a) signatures in export lists; or (b) signatures in `instances'
08:06:08 <applicative> ski, first I was thinking of them in instances, like Guestxyz, then there was a question of stating them multiply in one file.  Export didn't occur to me
08:06:23 <ski> Guest86956 : `> ' for evaluating an expression, `@type ' (or `:t ') for showing the type of an expression, `@kind ' (or `:k ') for showing the kind of a type expression
08:06:34 <applicative> ski are you thinking, you could write a complex one for internal use and export the other for the 'user'?
08:07:07 <ski> yeah, i was thinking one could be intended for interface, the other for the one reading the implementation
08:07:54 <applicative> but they would be the same, in fact, once the newtypes were shredded and so forth?  
08:07:54 <Guest86956> one small question, if I have imported Search and imported Data.Multiset, do I need to import Data.MultiSet in Search.hs as well if I want to use that in Search?
08:08:06 <ski> applicative : i was first thinking of multiple ones in a module, but then i thought that the case i was thinking of could as well be served by allowing one in the export list
08:08:46 <applicative> I see, it took me a second to get the idea of the one for the user and the other for the library writer
08:09:22 <ski> Guest86956 : yes
08:09:55 <Guest86956> ski: thanks!
08:09:56 <ski> applicative : well, not modulo `newtype', just modulo `type'
08:10:09 <applicative> ski, sorry, mispoke, yes
08:10:47 <ski> applicative : but see <http://cvs.haskell.org/Hugs/pages/users_guide/restricted-synonyms.html>
08:11:51 <ski> the MLs also have basically this, where you can define a type with (basically) `type' or `data', but export it abstractly anyway (so it externally behaves as a `data' / `newtype' for which you don't know the implementation)
08:12:17 <applicative> ski, that's really cool. is it saying that it is implemented in Hugs?  
08:12:23 <ski> yes
08:12:36 <ski> this is one thing i'm missing in GHC
08:13:01 <applicative> it's a drag everyone's so down on Hugs. I haven't used it forever now. 
08:14:12 <applicative> I propose the Committee to Save Hugs Despite the Conviction of our Betters
08:14:18 <ski> <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.2> is also fun to play with
08:14:23 <applicative> I am looking for zillionaire benefactors
08:14:51 <Guest86956> I don't know isn
08:14:55 <Guest86956> t hugs very old?
08:15:03 <ski> GHC is also old
08:15:42 <Guest86956> GHC has updates
08:15:45 <ski> (the difference is that GHC is more maintained and actively developed)
08:15:54 <applicative> The hugs interpreter is the high tech version of the old gofer interpreter, which was the first haskell implementation, if i understand
08:16:03 <ski> no
08:16:08 <ski> HBC was the first
08:16:14 <applicative> oh, i see
08:16:21 * hackagebot clash 0.1.2.0 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1.2.0 (ChristiaanBaaij)
08:16:23 <applicative> In any case, it goes way back
08:16:24 <ski> augustss wrote HBC
08:16:51 <ski> preflex: xseen augustss
08:16:51 <preflex>  augustss was last seen on freenode/#haskell 4 days, 18 hours, 5 minutes and 26 seconds ago, saying: abstrakt: absolutely not
08:16:54 <applicative> was it a proper compiler
08:17:01 <Guest86956> Why isn't anyone maintaining Hugs? =(
08:17:02 <ski> yes
08:17:11 <applicative> awesome
08:17:27 <ski> iiuc, it compile to LML (Lazy ML)
08:17:35 <ski> at least it was written in LML
08:17:39 <applicative> Guest, not sure.  My sense judging from attitudes around here was that it was thought not worth it, we have GHC.  
08:18:00 <applicative> which augustuss also wrote, maybe?  (LML?)
08:18:12 <ski> i think so, but i'm not sure
08:18:45 <applicative> Guest, but I disapprove of Hugs bashing. One, it's so damn easy to install; two many implementations help distinguish the language from the implementation
08:18:58 <Guest86956> I see... 
08:19:27 <applicative> with ghc dominance, the question what the language is, is becoming ever more opaque; but my views are very undertutored of course. Its just a feeling
08:20:11 <applicative> This thought seems sound though: if "its haskell" = "the ghc compiles it", we're in the situtation with html and the 'leading browsers'
08:20:22 <ski> at least we have the separation of extensions in `LANGUAGES', which other implementations have a chance of implementing themselves
08:20:35 <pumpkin> wlangstroth: interesting stuff you have on your github and homepage :P
08:20:48 <Guest86956> hmm..
08:21:03 <applicative> yes, I take it that's the purpose of them. Certainly ghc itself is keenly aware of the distinction, I just wonder if the rest of us can really retain it.
08:21:59 <ski> i suppose it would help if more of us tried to also use other implementations, when possible ..
08:22:36 * ski looks guilty
08:22:52 <Guest86956> ski how do you make things like "* ski looks guilty"?
08:23:06 <zygoloid> Guest86956: type: /me does something
08:23:09 <ski> Guest86956 : try saying `/me likes Haskell !'
08:23:09 <wlangstroth> pumpkin: you might be the first person to have actually looked
08:23:10 <applicative> ski, that was my thought. It doesn't suggest anything against the ghc, which is a gift of God.
08:23:18 * Guest86956 eat
08:23:19 <ski> *nod*
08:23:21 <Guest86956> oh i See
08:23:22 <Guest86956> :P
08:23:23 <quicksilver> for alternative implementations to succeed they have to have a niche
08:23:30 <quicksilver> there has to be a reason for people to develop them
08:23:31 <applicative> \me always escapes himself instead
08:23:31 <pumpkin> wlangstroth: your github page is particularly puzzling, although the latin and greek were rather unconventional too
08:23:41 <quicksilver> (and, possibly a reason for people to use them)
08:23:52 * Guest86956 likes Haskell!
08:24:20 <applicative> pumpkin, wheres this latin and greek?
08:24:21 <ski> that's it !
08:24:33 <aristid> pumpkin: and that? http://wlangstroth.github.com/
08:24:49 <aristid> applicative: http://langstroth.net/
08:24:51 <ski> Graeca sunt, non leguntur !
08:24:55 <pumpkin> lol
08:24:56 <wlangstroth> pumpkin: I'm doing a second degree in classics, and that document is the official US military stance on the commie threat
08:25:19 <pumpkin> wlangstroth: why are the other sections missing?!! what are you hiding from us?!?
08:25:26 * hackagebot snap-server 0.2.14.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.14.1 (GregoryCollins)
08:25:49 <wlangstroth> (in 1970)
08:25:58 <applicative> wlangstroth, are you an Agent of our enemy, Wikileaks???
08:26:00 <pumpkin> hey, those commies are awfully dangerous
08:26:13 <Guest86956> Well I have to admit it, at first I thought Haskell was just slow etc. But amazingly it's actually pretty fast and it's kind of easy to do something in  a pretty compact form...(unlike imperative languages)
08:26:26 <wlangstroth> haha - worse ... I'm ... Canadian!
08:26:35 <pumpkin> damn
08:26:44 <ski> Guest86956 : yeah, it's usually nice :)
08:27:28 <Guest86956> but I wish GHC could make those error messages a bit less complicated and more suggestions to fixes...
08:28:10 <applicative> Guest86956, the errors are a nightmare, until you consider that it is a miracle that it can give them at all.  
08:28:25 <quicksilver> everyone wishes GHC had better error messages
08:28:26 <Twey> The errors aren't that bad
08:28:29 <ski> yesh, it'd be nice if it used error slices to exactly pinpoint the possible sources of an error
08:28:32 <Twey> Compared to g++…
08:28:34 <quicksilver> but it's surprisingly hard to find good ones.
08:28:48 <quicksilver> most compilers give pretty poor error messages for a large class of cases
08:28:50 <applicative> Guest86956, the secret is to go the the exact line and position it mentions before trying to figure out anything else.  This is where it balked.
08:28:58 <Twey> They're usable.  A little cryptic to the uninitiated, sometimes, but they work.
08:29:04 <quicksilver> missing {} gives a bad error message in almost all languages.
08:29:07 <aristid> quicksilver: i would consider that an indication that the problem is hard
08:29:07 <ski> Guest86956 : but with some practice, you learn to interpret the most common ones quickly
08:29:23 <quicksilver> aristid: I agree.
08:29:26 <Guest86956> ski : I hope so XD
08:29:26 <applicative> Twey, I agree. At least when I'm not in some zone of typemadness, but then it's my own fault.
08:29:35 <quicksilver> aristid: "quicksilver> but it's surprisingly hard to find good [error messages]"
08:30:08 <applicative> The choice of words "expected" and "intended" is already pretty opaque, I remember.
08:30:34 <ski> Guest86956 : for the most part, i either just look at the line number, and quickly figure out / realize the error, or look at the overall shape of the error, and then figure out the error
08:30:56 <ski> Guest86956 : only in more complicated cases do i need to actually reads the whole error
08:31:25 <applicative> I would love to write 'elegant variations' of the expected .../ intended.... sort of error.  
08:31:49 * ski sometimes prefers Hugs' error messages to GHC
08:32:02 <ski> > not 'a'
08:32:02 <ski> ERROR - Type error in application
08:32:02 <ski> *** Expression     : not 'a'
08:32:02 <ski> *** Term           : 'a'
08:32:02 <ski> *** Type           : Char
08:32:03 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
08:32:03 <ski> *** Does not match : Bool
08:32:03 <lambdabot>         against inferred type ...
08:32:49 <applicative> ski, yes, that could be much clearer.  
08:33:08 <applicative> *** Meaningless Combination: not 'a'
08:33:18 <ski> ?
08:33:21 <pumpkin> I like meaningless combination
08:33:27 <applicative> *** Indigestible Term : 'a'
08:33:30 <monochrom> most of the time "expected" comes from external constraints and "inferred" comes from internal constraints. e.g. a :: Integer; a = True || False -- external Integer, internal Bool
08:33:31 <aristid> ski: yeah, that's what ed would show
08:33:36 <pumpkin> "not has type Bool -> Bool, but you tried to pass it 'a', which is a Char"
08:33:36 <EvanR-work> Incomprehensible construction
08:33:41 <applicative> *** Which is A:  Char
08:33:42 * ski remembers an old C64 monitor which said `?' to anything it didn't understand
08:33:51 <EvanR-work> Absolutely idiotic
08:34:00 <fasta> ski, those where fantastic. 
08:34:05 <applicative> *** What You SHould Have put there: Bool
08:34:27 <fasta> were*
08:34:36 <pumpkin> applicative: or Char -> Bool instead of the not
08:34:50 <pumpkin> it's hard to assume where the error is
08:34:53 <ski> pumpkin : that's where type error slices would come in
08:34:59 <pumpkin> but you can tell the user where the incompatibility arises
08:35:19 <applicative> pumpkin, yes, this is the problem.  It seems that in simple cases, they are assuming a reading from left to right, then suddenly can't eat the next term
08:35:36 <quicksilver> *** What you are : a fool
08:35:37 <ski> a type error slice is the set of locations that all relevantly contribute to the error, and at least one of them would have to be changed to fix the error
08:35:48 <pumpkin> makes sense
08:35:55 <applicative> *** What you are: A Conceptual Dyslexiac
08:35:57 <wlangstroth> abusive error messages are always way more entertaining
08:36:00 <pumpkin> I'd like an error along the lines what I wrote above
08:36:11 <wlangstroth> "Dyslexiac"?
08:36:27 <pumpkin> along with "possible fixes: pass `not` a Bool value, or apply a Char -> Bool function to 'a'"
08:36:29 <monochrom> *** Error message: $50
08:36:41 <monochrom> *** SPJ's salary: $50000
08:36:47 <applicative> pumpkin, I like it.  except in Haskell, I don't like the use of the word "passing"
08:36:50 <monochrom> *** Your brain explosion: priceless
08:36:51 <ski> <http://www2.macs.hw.ac.uk/~rahli/cgi-bin/slicer/html/concepts.html> has example in SML
08:36:57 <fasta> *** Please call 911.  ***
08:37:05 <pumpkin> applicative: apply the `not` function to a Bool value?
08:37:11 <applicative> though I guess it's just the converse of "apply"
08:37:49 <applicative> yes, doesn't "passing" seem hyper imperative, even mechanical. 
08:38:12 <ski> @type comparing
08:38:13 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
08:38:38 <applicative> *** Please call #Haskell ***
08:39:03 <EvanR-work> *** the haskell machinery broke ***
08:39:12 <EvanR-work> you passed in a weird shaped object
08:39:32 <ski> *** let's all henceforth start our #haskell messages like this !
08:39:33 <applicative> saboteur, throwing shoes into the typesystem!
08:40:09 <EvanR-work> *** haskell halted due to friction ***
08:40:13 <fasta> *** The authorities have been notified. ***
08:40:23 <ibid> *** what the hell? ***
08:40:41 <Botje> *** Error: * shortage.
08:40:48 <fasta> *** I hope this meme doesn't spread ***
08:41:57 <monochrom> ✂✂✂ cut here ✂✂✂
08:42:15 <EvanR-work> *** _|_ ***
08:42:32 <EvanR-work> haskell giving you the finger
08:42:36 <ToRA> am I the only person worried that *** id *** doesn't parse?  surely it should be (***) message (***)
08:42:49 <ToRA> @type (***) id (***)
08:42:50 <lambdabot> forall b (a :: * -> * -> *) b1 c b' c'. (Arrow a) => (b, a b1 c) -> (b, a b' c' -> a (b1, b') (c, c'))
08:42:59 <ibid> @type *** id ***
08:42:59 <applicative> ski, the ML thing looks nice.  A diagrammatic picture would be cool.  Square peg, round hole.  
08:43:00 <lambdabot> parse error on input `***'
08:43:08 <dmwit> *** go with your heart ***
08:43:37 <ski> applicative : diagrammatic how ? .. you want something else than like <http://www2.macs.hw.ac.uk/~rahli/cgi-bin/slicer/index.html> ?
08:43:48 <monochrom> ♥♥♥ really go with your heard ♥♥♥
08:44:06 <applicative> @type (***) ("In future please avoid nonsense" ++) (***)
08:44:07 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => ([Char], a b c) -> ([Char], a b' c' -> a (b, b') (c, c'))
08:44:59 <pumpkin> :t [join (***) join, join *** join]
08:44:59 <applicative> ski, that looks cool too.  It hadn't occurred to me that ML-land would be full of such things.
08:45:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => [(m (m a), m (m a)) -> (m a, m a)]
08:45:22 <ski> (hehe, irrelevant piece of fact : the heart symbol was how the token for `POKE' in basic was displayed in a monitor on an old pocket calculutor (descendent of PB-100F))
08:45:34 <pumpkin> how many other sequences of three symbols in haskell have that property?
08:45:36 <monochrom> my hands are dylexic. they made so many impossible typos
08:45:50 <pumpkin> x (y) z `asTypeOf` x y z
08:45:50 <applicative> which property
08:46:08 <pumpkin> x = y = z = id
08:46:16 <monochrom> I think I recall the PB-100F or some such. from Casio, right?
08:46:21 <ski> yeah
08:46:32 <ski> 510 bytes of RAM
08:46:34 <monochrom> I have an ancestor of it. FX-702P
08:46:38 <pumpkin> :t id [id (id) 5, id id 5]
08:46:39 <lambdabot> forall a. (Num a) => [a]
08:46:48 <pumpkin> x = y = id, z = *
08:47:03 <pumpkin> what else, beyond the original example I gave?
08:47:33 * hackagebot clash 0.1.2.1 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1.2.1 (ChristiaanBaaij)
08:48:36 <applicative> pumpkin, at last I get it.  y is an operator, so we want x (y) x = x y z , as one part of the problem
08:49:07 <applicative> no that's not it
08:49:12 <ski> the CASIO FX-602P was also interesting. you could get strange effects by writing a "program" which was just a long string, delete it, and in the middle of the deletion, turn the calculator off
08:49:12 <dmwit> pumpkin: ...what is the property?
08:49:18 <dmwit> You still haven't said, as far as I can tell.
08:49:20 <applicative> pumpkin, i'm glad you're not formulating programming contests
08:49:35 <monochrom> I have FX-602P too
08:49:36 <pumpkin> dmwit x (y) z and x y z can be refined to the same type
08:49:37 <ski> the interesting thing was that each program code had two meanings, one inside quotes, another outside
08:49:43 <applicative> but it would be an abuse of your skills :)
08:50:01 <ski> by doing the above, you could check which corresponded to which, and also access some strange and/or disabled commands
08:50:18 <dmwit> pumpkin: I guess anything where 'y' is an alphanumeric name, at least.
08:50:33 <dmwit> :t [const (const) const, const const const]
08:50:33 <lambdabot> forall a b. [a -> b -> a]
08:50:45 <pumpkin> dmwit: yeah, it's more interesting for symbolic y values
08:50:53 <pumpkin> applicative: hah, it'd make a decent contest if I knew the answer
08:51:19 <ski> (deletion of a program was an `O(n)' operation)
08:51:20 <pumpkin> or we can use the alphanumeric version of x `y` z and x y z
08:52:10 <pumpkin> so basically y x y and x y z can be refined to the same type
08:52:32 <pumpkin> y x z, sorry
08:53:00 <pumpkin> :t \x y z -> y x z
08:53:01 <lambdabot> forall t t1 t2. t -> (t -> t1 -> t2) -> t1 -> t2
08:53:13 <applicative> beat me to it
08:53:22 <pumpkin> :t \x y z -> (y x z, x y z)
08:53:23 <lambdabot>     Occurs check: cannot construct the infinite type:
08:53:23 <lambdabot>       t = (t -> t1 -> t2) -> t1 -> t3
08:53:23 <lambdabot>     Probable cause: `x' is applied to too many arguments
08:53:44 <pumpkin> :t (\x y z -> y x z, \x y z -> x y z)
08:53:45 <lambdabot> forall t t1 t2 t3 t4 t5. (t -> (t -> t1 -> t2) -> t1 -> t2, (t3 -> t4 -> t5) -> t3 -> t4 -> t5)
08:53:45 <applicative> @type \ x y z -> [ x y z , y x z]
08:53:46 <lambdabot>     Occurs check: cannot construct the infinite type:
08:53:46 <lambdabot>       t = (t -> t1 -> t2) -> t1 -> t2
08:53:46 <lambdabot>     Probable cause: `y' is applied to too many arguments
08:54:11 <dmwit> no fair
08:54:24 <dmwit> You're monomorphing the types of x y and z there.
08:54:28 <pumpkin> yeah
08:54:58 <pumpkin> we're also not covering higher-rank stuff that way
08:55:04 <ski> monochrom : though, after deleting the program, you'd have to first enter as many bytes into the program as it had managed to delete, before noticing anything strange
08:55:17 <pumpkin> which is I guess what you're saying
08:55:21 <dmwit> I think that's the same complaint.
08:55:21 <dmwit> yeah
08:55:25 <pumpkin> :P
08:55:27 <applicative> I see, so that's one feature of the solution, it must  be nonmonomorphic
08:55:39 <pumpkin> well, the original solution I gave isn't higher-ranked
08:55:50 <dmwit> It is, though.
08:56:13 <applicative> was it join (***) join?
08:56:28 <pumpkin> yeah, y = (***) and x = z = join
08:56:30 <dmwit> ((***) :: forall blah. blah), so \(***) -> a (***) , b *** :: (forall blah. blah) -> ...
08:56:38 <dmwit> rank-2
08:56:51 <dmwit> no?
08:57:43 <pumpkin> hmm, I don't see it
08:57:53 <pumpkin> :t (***)
08:57:54 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:58:05 <pumpkin> it's very polymorphic, but not higher-rank polymorphism?
08:58:41 <dmwit> pumpkin: If you were to write a function of the form \x y z -> (x y z, y x z) and supply (***) as the argument, the function you wrote would have to have rank-2 polymorphism.
08:58:46 <dmwit> Which I believe was what you were saying.
08:59:26 <applicative> dmwit, I don't seem to have to include a pragma to get it to compile? Or is that a misunderstanding
08:59:45 <dmwit> What is "it"?
09:00:06 <applicative> module A where a = join (***) join
09:00:15 <dmwit> I believe it's a misunderstanding.
09:00:25 <applicative> (with type signature a :: Monad m => ...
09:00:36 <dmwit> We were choosing how to describe the problem with (\x y z -> (x y z, y x z)).
09:00:59 <dmwit> You can describe it as forcing x, y, and z to be monomorphic, or you can describe it as not having a higher-rank type.
09:01:02 <applicative> i see, yes.  the instance that solves it wont be rank2
09:01:16 <dmwit> right
09:01:18 <applicative> but the type of what we're looking for, is
09:02:06 <pumpkin> ah I see
09:03:13 <monochrom> ski: there are several methods invented by a group of enthusiasists in Hong Kong. they all involved doing funny things when loading programs from tape (e.g., skipping forward a bit, interrupting) so you get an unmatched quote.
09:03:32 <ski> ok, i didn't know that
09:04:03 <ski> monochrom : the ones i know were invented by my older brother, and some friends of his, afaik
09:04:40 <ski> (they also tried saving a program with an operation from one model, loading it into another model, which couldn't type that command)
09:04:53 <pumpkin> dmwit: so, what is the verdict? is there a most general type of things that work? :P
09:04:54 <ski> (which worked in some cases, at least)
09:05:24 * dmwit shrugs
09:06:10 <applicative> dmwit, indeed, I'm having trouble getting the typechecker to digest a predicate that applies to x y and z if they meet the constraint 
09:06:42 <applicative> Rank n and no monomorphism dont seem to work. 
09:09:27 <ski> (monochrom : hm, i also remember if you pressed four or five keys in sequence (including `AC', but i don't recall the details), you'd get a "middle dot" character)
09:10:03 <wafna> i have a question about type classes
09:10:19 <wafna> why can't you mix instances in a list?
09:10:27 <quicksilver> you can.
09:10:31 <wafna> module Main (main) where  class Foo a where 	foo :: a -> String  data Blizz = Blizz instance Foo Blizz where 	foo _ = "Blizz"  data Blazz = Blazz instance Foo Blazz where 	foo _ = "Blazz"  main :: IO () main = mapM_ (putStrLn . foo) [Blizz, Blazz]
09:10:42 <wafna> oops, crappy formatting.
09:10:45 <quicksilver> howver, lists have to have a single type
09:10:46 <wafna> sorry
09:10:52 <ski> that's not really a question of instances, but of lists
09:10:57 <quicksilver> so you have to define a type which contains all those possibilities
09:11:01 <quicksilver> you do this using an existential.
09:11:02 <pumpkin> wafna: you want an existential type
09:11:06 <ski> every element in a list must have the same type
09:11:14 <wafna> oh?
09:11:18 <quicksilver> http://www.haskell.org/haskellwiki/Existential_type
09:11:27 <quicksilver> however, whatever you were thinking of doing like this
09:11:27 <pumpkin> wafna: also, what ski, quicksilver, and I said, is all the same thing, in different words
09:11:29 <quicksilver> don't
09:11:29 <ski> that type could be `exists x. Foo x *> x', though
09:11:32 <quicksilver> you're doing it wrong ;)
09:11:55 <quicksilver> data Foo = Blizz | Blazz would be much more idiomatic.
09:11:57 <pumpkin> "you want an existential type; however, you shouldn't want one"
09:11:58 <ski> quicksilver : it is hard to tell, only looking at mock-code ..
09:12:07 <dmwit> Hm, breaking out existentials on a newbie seems -- anti-pedagogical.
09:12:14 <quicksilver> ski: of course. That's why I had to rely on my psychic abilities.
09:12:23 <quicksilver> and quicksilver's first rule.
09:12:25 <ski> wafna : *usually* you don't need existentials .. but sometimes they are the proper thing
09:12:49 <ski> wafna : it is hard to tell which is the case here, because you haven't explained what you're trying to do
09:12:56 <wafna> each of these data types represents a bot that plays a two player game
09:13:26 <wafna> the bots encapsulate different strategies.
09:13:32 <ski> why do the bots need to have different types ?
09:13:40 <wafna> i'm writting a method that plays them against each other in a tournament.
09:13:55 <wafna> so, the tournament code can assume nothing other that that these data are instances of Bot
09:14:22 <wafna> the idea is that the tournament will work for any 2 player game
09:14:25 <ski> often, just having each bot be a record of operations, is enough
09:14:29 <quicksilver> data Bot = { foo :: This -> Function; bar :: That -> Function; baz :: Other -> Function }
09:14:33 <dmwit> how about, instead of "class Bot a where play :: a -> IO ()", you do something like "data Bot = Bot { play :: a -> IO () }"?
09:14:37 <ski> maybe you really want existentials here, though
09:14:38 <quicksilver> is a simpler design.
09:14:40 <dmwit> err
09:14:44 <dmwit> how about, instead of "class Bot a where play :: a -> IO ()", you do something like "data Bot = Bot { play :: IO () }"?
09:15:01 <wafna> and any kinds of botsclass Bot a where 	botName :: a -> String 	moveBot :: (Game2P g) => a -> g -> (g, String) 
09:15:35 <ski> wafna : try putting the bot operations into a record type, like quicksilver and dmwit suggests
09:15:46 <ski> using no `Bot' class at all
09:15:58 <dmwit> data Bot = Bot { botName :: String, moveBot :: Game2P g => g -> (g, String) } -- seems easy enough
09:16:04 <wafna> if i do that', how can i make teh game generic?
09:16:13 <dmwit> data Bot g = ..., of course
09:16:19 <wafna> ah
09:16:37 <ski> dmwit : not `moveBot :: forall g. Game2P g => ..g..' ?
09:16:46 <roconnor> State g String ?
09:16:54 <wafna> i guess i got lost in the forest.  that is the simple and straightforward solution.
09:16:57 <dmwit> No, I meant data Bot g = Bot String (g -> (g, String)).
09:17:00 <int-e> ski: then the bot would have to be able to play any game though ...
09:17:07 <dmwit> I just typed faster than I thought.
09:17:15 <dmwit> Lucky thing we've got #haskell checking my work. =)
09:17:22 <ski> roconnor : yeah, that too
09:17:38 <ski> int-e : yeah .. i was assuming wafna wanted that, since that's what the `class Bot' said
09:17:54 <monochrom> instance Bot monochrom where ...
09:17:55 <int-e> ski: true.
09:18:09 <int-e> ski: but probably not intended. at least that's my guess.
09:18:21 <ski> you are possibly right
09:18:30 <wafna> thanks for the input, folks.  much obliged.
09:18:56 <ski> wafna : if you have more trouble doing this, don't hesitate to show us the code and the problem
09:19:14 <wafna> it's a lot of code in several modules.
09:19:23 <wafna> i'd be happy to share it, though.
09:19:25 <ski> well, the *relevant* code, of course :)
09:19:42 <int-e> instance Bot Marvin where mood = Depressed
09:19:43 <ski> (we would probably prefer not to drown in a large mass of code)
09:19:57 <wafna> nods.  that's why i made that teeny example.
09:20:40 <ski> ("as simple as possible. but no simpler")
09:20:59 * ski thinks that describes "minimal type error slice" rather well
09:21:36 <monochrom> after "as possible", "but no simpler" is redundant, since it is impossible to be simpler.
09:22:05 * ski nods slowly
09:22:15 <EvanR-work> emphasis!
09:22:50 <monochrom> however, "as simple as necessary, but no simpler" is not redundant and is probably the real intention
09:23:12 <pumpkin> sounds universal
09:23:14 <EvanR-work> as simple as possible that accomplishes the goal
09:23:45 * ski refrains from making a comment about universal properties
09:24:27 <pumpkin> ski: that's what I was referring to :P
09:26:24 <applicative> the search for the simplest, is it always sound?  like trying to find the shortest axiomatization of the propositional calculus, or the one connective that will do it all
09:27:04 <monochrom> sound? yes. useful? depends.
09:28:06 <applicative> in  my system we have only Neither x ( F x , G x) meaning, nothing is either F or G.  well, let False = Neither x (x = x, x= x) , True = Neither x (False, False)
09:28:10 <applicative> and you're off. 
09:28:16 <monochrom> if you want to prove something about the propositional calculus, you prefer a shorter axiomatization, it means fewer cases in your case analysis.
09:28:44 <applicative> i think it went bad this search in the early 20th c.  let me look.
09:29:38 <monochrom> if you want to use the propositional calculus, you prefer more laws you are allowed to use, it means fewer steps for you.
09:29:39 <ski> imo, the problem with "one connective does it all" is that separate concepts are not kept separate
09:29:49 <applicative> wow, Lukasiewicz was still at it in the 40s http://www.jstor.org/pss/20488489
09:29:57 <PatrickRobotham> applicative: Well that's not too difficult. Just use NAND
09:30:12 <PatrickRobotham> or yeah, Neither works
09:30:52 <applicative> C C C p q r C C r p C s p  
09:30:56 <RayNbow> pumpkin: how did you stumble upon the ursus arctos?
09:31:03 <applicative> :t and
09:31:04 <lambdabot> [Bool] -> Bool
09:31:19 <pumpkin> RayNbow: functorsalad talking about the grizzly being horribilis :)
09:31:34 <monochrom> And the problem with logic courses (even those for users) is that they are run by people who prove about the logic, not people who use the logic. For example "you can always get rid of ⇒ by using ¬ ∨" is very damaging. It means more work for the user.
09:32:05 <monochrom> It perpetuates the myth that logic is tedious and pointless.
09:32:48 <applicative> :t \p q r s -> (&&) ((&&) ((&&) p q) r)  ((&&) ((&&) r p) ((&&) s p))
09:32:49 <lambdabot> Bool -> Bool -> Bool -> Bool -> Bool
09:32:51 <ski> yeah .. imo they should have more emphasis on using the logic
09:33:20 <SubStack> @pf \x y z -> x && y || not z
09:33:20 <lambdabot> Maybe you meant: bf pl
09:33:24 <SubStack> maybe!
09:33:27 <SubStack> @pl \x y z -> x && y || not z
09:33:27 <lambdabot> flip flip not . (((.) . (||)) .) . (&&)
09:33:32 <SubStack> there, pointless
09:33:36 <ski> (knowing what soundness and completeness is, is also good, but maybe their proof don't need to occur in an introductory course ?)
09:34:35 <wlangstroth> "ursus arctos" is "bear bear"
09:34:36 <applicative> > let foo = (\p q r s -> (&&) ((&&) ((&&) p q) r) ((&&) ((&&) r p) ((&&) s p))) in foo True True False True
09:34:37 <lambdabot>   False
09:34:52 <RayNbow> pumpkin: I can't tell whether grizzlies live up to their Latin name... no grizzlies here in Under-Sea-Level-Land :p
09:35:37 <applicative> need agda so we could write it as _Luka_sie_wicz_ 
09:36:12 <ski> what would the arguments be ?
09:36:23 <applicative> Four bools
09:36:54 <applicative> Then we have a constant that can define all Bool -> Bool ....-> Bool constants
09:37:02 <applicative> no wrong
09:37:53 <applicative> i was thinking of a different competition.  this is supposed to be an axiom that is generally true; everything follows from it with cut and substitution
09:44:51 <Hlbert> Hello
09:45:09 <Hlbert> Can I ask q's about haskell here?
09:45:21 <quicksilver> yes, that's what we're for.
09:45:23 <wlangstroth> Hlbert: this would be the place
09:45:49 <Hlbert> Great, I'm new to haskell
09:46:39 <Hlbert> I only know a small amount of imperative programming but I wish to learn the functional paradigm via haskell
09:47:34 <Hlbert> I find haskell's type system to be confusing
09:48:06 <quicksilver> it's very powerful and a useful tool but it can be confusing if you've never used anything like it
09:48:08 <ski> do you have a specific case which is confusing you ?
09:51:00 <Hlbert> I find it confusing that when writing simple function such as a funciton to add 2 numbers you write add :: int ->int-> int 
09:51:17 <EvanR-work> :t (+2)
09:51:18 <lambdabot> forall a. (Num a) => a -> a
09:51:34 <EvanR-work> built in support for partial application
09:52:03 <Hlbert> Why not use  add:: (int,int)-> int
09:52:19 <EvanR-work> then you cant do (+2)
09:52:26 <EvanR-work> or (2+)
09:52:49 <EvanR-work> and to add two numbers youd have to first put them in a tuple
09:52:52 <ski> > map (2+) [0,1,2,3]
09:52:53 <lambdabot>   [2,3,4,5]
09:52:59 <EvanR-work> (+) (2,2)
09:53:03 <EvanR-work> would suck
09:53:30 <ski> EvanR-work : `x + y' might be defined to mean `(+) (x,y)' (like in SML)
09:53:30 <EvanR-work> if you really wanted that you could uncurry
09:53:45 <EvanR-work> ah
09:54:24 <EvanR-work> well this way (+) acts like other functions even ones that arent operators
09:54:37 <ski> Hlbert : anyway, sometimes doing `foo :: (Int,Int) -> Int' makes more sense, but very often, `foo :: Int -> Int -> Int' is quite useful
09:55:28 <Hlbert> But how do you distinguish between foo::(Int,Int)-> Int and foo::Int->(Int,Int)
09:55:30 <ski> > map (map (10 +)) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
09:55:31 <lambdabot>   [[],[10],[11,12],[13,14,15],[16,17,18,19]]
09:55:56 <ski> Hlbert : the first is a function taking a tuple of two `Int's
09:56:04 <opqdonut> Hlbert: Int -> Int -> Int means Int -> (Int -> Int)
09:56:10 <ski> Hlbert : the second is a function *returning* a tuple of two `Int's
09:56:22 <EvanR-work> maybe he means in SML
09:56:51 * ski assumes Hlbert haven't tried SML
09:56:55 <Funktorsalat> Hlbert: re "confusing", it's mostly just a matter of getting used to it
09:57:37 <EvanR-work> Funktorsalat: thats a good way to draw ridicule from outsiders ;)
09:57:48 <Funktorsalat> why?
09:57:50 <EvanR-work> 'the gimp is great, you just have to get used to it'
09:58:02 <Funktorsalat> I mean as opposed to "intrinsically more complicated/confusing"
09:58:02 <EvanR-work> compare and contrast ;)
09:58:21 <Funktorsalat> (than uncurried style)
09:58:28 <EvanR-work> yeah
09:58:42 <Funktorsalat> though I'd admit it's probably intrinsically more confusing for precomposing functions that take multiple arguments
09:58:52 <chrisdb> Question: what dependencies do you need to distribute with a binary compiled by ghc for it to work? I'm thinking about oses without a decent package management system like Windows. 
09:58:55 <chrisdb> My code is open source, but I'd also like to have some installers that just work for people who don't want to bu
09:58:59 <EvanR-work> .: .:: ! ;)
09:59:01 <chrisdb> ild it themselves.
09:59:02 <ski> there's often merit both to "just get used to it" and to "those being used to it don't notice the strange quirks"
09:59:12 <Hlbert> I'm still confused
09:59:15 <wlangstroth> Hlbert: it's a conceptual leap from imperative parameters to currying
09:59:23 <chrisdb> I've googled and found some mentions of gmp...
09:59:24 <ski> Hlbert : confused about ?
09:59:31 <zygoloid> Hlbert: one reason to use Int -> Int -> Int (that is, the curried form) rather than (Int, Int) -> Int is that you can partially apply the curried form
09:59:39 <chrisdb> but not found any clear documentation about what, if any, extra dependencies there are.
10:00:15 <zygoloid> Hlbert: for instance, if I have (+) :: Int -> Int -> Int, I can write: let f = (+) 3.  this gives me a function f :: Int -> Int, which adds three.
10:00:18 <EvanR-work> chrisdb: ldd the binary tells you what runtime deps there are
10:00:24 <EvanR-work> libgmp is probably one of them
10:00:44 <ski> > let foo :: Int -> Int -> Int; foo x y = x^2 + y^2 in map (foo 2) [0,1,2,3]
10:00:45 <lambdabot>   [4,5,8,13]
10:00:53 <ski> > let foo :: (Int,Int) -> Int; foo (x,y) = x^2 + y^2 in map (foo 2) [0,1,2,3]
10:00:54 <lambdabot>   Couldn't match expected type `a -> b'
10:00:54 <lambdabot>         against inferred type `GHC.Ty...
10:01:01 <ski> > let foo :: (Int,Int) -> Int; foo (x,y) = x^2 + y^2 in map (\y -> foo (2,y)) [0,1,2,3]
10:01:02 <lambdabot>   [4,5,8,13]
10:01:11 <ski> Hlbert : compare those three examples ^
10:01:18 <chrisdb> EvanR-work: thanks. 
10:01:38 <ski> you can also write the first one as
10:01:45 <ski> > let foo :: Int -> Int -> Int; foo x y = x^2 + y^2 in map (\y -> foo 2 y) [0,1,2,3]
10:01:46 <lambdabot>   [4,5,8,13]
10:02:16 <Hlbert> I sort of get it now, but not fully, and I do't know what \ does
10:02:28 <ski> but, with the curried one (`foo :: Int -> Int -> Int'), you don't need to write a "lambda expression" (`\y -> ..y..')
10:02:46 <EvanR-work> \ == lambda
10:02:50 <ski> Hlbert : `\y -> 2 + y' is the function that, given any `y', returns `2 + y'
10:02:58 <ski> > (\y -> 2 + y) 10
10:02:58 <lambdabot>   12
10:03:05 <ski> > map (\y -> 2 + y) [10,20,30]
10:03:06 <lambdabot>   [12,22,32]
10:03:13 <ski> > map f [10,20,30] :: [Expr]
10:03:13 <lambdabot>   [f 10,f 20,f 30]
10:03:30 <ski> `map' is a function that calls an argument function on every element in a list
10:03:38 <ski> > map (2 +) [10,20,30]
10:03:39 <lambdabot>   [12,22,32]
10:04:19 <ski> Hlbert : note that you don't *need* to give the function a name : functions are values, just like `2' and `[10,20,30]'
10:04:19 <Hlbert> What exactly is a lambda expression
10:04:27 <ski> of course, if you *want* you can give it a name
10:04:44 <ski> > let addTwo = (\y -> 2 + y) in map addTwo [10,20,30]
10:04:44 <lambdabot>   [12,22,32]
10:04:50 <ski> > let addTwo y = 2 + y in map addTwo [10,20,30]
10:04:51 <applicative> @check \p q r s -> not (not (not p || q) || r) || (not (not r || p) || (not s || p) )
10:04:51 <lambdabot>   [12,22,32]
10:04:52 <lambdabot>   "OK, passed 500 tests."
10:04:52 <chrisdb> Hlbert: a locally defined function with no name.
10:04:53 <EvanR-work> lambda == anonymous function
10:04:58 <Hlbert> Functions are values? I
10:05:00 <ski> yes
10:05:30 <ski> Hlbert : to use the list `[10,20,30]' you don't need to give it a name, you just use it. it's the same with functions
10:05:32 * applicative finally formulated Lukasiewicz's 'shortest axiom'. Quickcheck like it
10:05:58 <Hlbert> How are functons values? 
10:06:04 <ski> Hlbert : if you want to use a function many times, then it makes sense to give it a name. otherwise, giving it a name is often just a complication
10:06:08 <applicative> they have types like everything else
10:06:17 <applicative> :t (+)
10:06:18 <lambdabot> forall a. (Num a) => a -> a -> a
10:06:18 <EvanR-work> you can pass them to functions and return them from functions
10:06:24 <applicative> :t (+3)
10:06:25 <lambdabot> forall a. (Num a) => a -> a
10:06:26 <zygoloid> you can store them in data structures
10:06:27 <ski>   [10,20,30] :: [Int]  -- a list of `Int's
10:06:33 <applicative> :t (3+3)
10:06:34 <lambdabot> forall t. (Num t) => t
10:06:46 <zygoloid> @type [id, (+1), div 3]
10:06:47 <lambdabot> forall a. (Integral a) => [a -> a]
10:06:51 <chrisdb> Hlbert: a lot of the power of functional programming is really just letting you pass functions around to other functions.
10:07:03 <ski>   [cos,sin,tan] :: [Double -> Double]  -- a list of functions from `Double' to `Double'
10:07:07 <EvanR-work> chrisdb: and computing new functions from old ones
10:07:11 <EvanR-work> using higher order functions
10:07:16 <Hlbert> I am not ues of considering functions as values
10:07:17 <EvanR-work> and partial app
10:07:53 <ski> Hlbert : well, that's one of the things you need to learn, then, learning the functional programming paradigm :)
10:07:54 <EvanR-work> Hlbert: consider 'even' a useful function being a value you can pass to any higher order function that requires a b -> Bool test
10:07:58 <chrisdb> Hlbert: What other languages do you know?
10:07:59 <applicative> > [(*), (+), (\x y -> x ^ 2 + y ^ 2)] <*> [2..5] <*> [5..7]
10:08:00 <lambdabot>   [10,12,14,15,18,21,20,24,28,25,30,35,7,8,9,8,9,10,9,10,11,10,11,12,29,40,53...
10:08:17 <Hlbert> Just c
10:08:21 <applicative> > [(*), (+), (\x y -> x ^ 2 + y ^ 2)] <*> [2] <*> [5]
10:08:21 <lambdabot>   [10,7,29]
10:08:22 <ski> ok
10:08:23 <chrisdb> Well, C has function pointers.
10:08:30 <ski> C allows you to pass around functions
10:08:32 <chrisdb> It's a bit like passing around function pointers to other functions.
10:08:44 <EvanR-work> > filter even [1,2,3,4,5]
10:08:44 <lambdabot>   [2,4]
10:08:45 <ski> it doesn't support anonymous function syntax, though
10:09:04 <chrisdb> Except in C it isn't normally used as much.
10:09:12 <ski> > partition even [0,1,2,3,4,5,6,7,8,9]
10:09:13 <EvanR-work> i use it all the time ;)
10:09:13 <lambdabot>   ([0,2,4,6,8],[1,3,5,7,9])
10:09:14 <chrisdb> Whereas in Haskell it's used for almost anything non-trivial.
10:09:47 <EvanR-work> in haskell you get along better with composing functions by name
10:09:53 <EvanR-work> lambdas sometimes
10:09:57 <chrisdb> EvanR: maybe I'm wrong. I only learned enough C to realise I didn't like it very much.
10:10:11 <EvanR-work> chrisdb: well i think my c is highly non standard
10:10:20 <EvanR-work> for the better
10:10:39 <Funktorsalat> haskell function values are more like function pointers together with the values of the local variables in scope at the lambda
10:10:52 <Funktorsalat> (=closure)
10:10:57 <applicative> Hlbert, there's no big secret about 'functions are values', they are viewed as more quasi-mathematical things, like ints.
10:11:10 <ski> Hlbert : consider `partition :: (a -> Bool) -> [a] -> ([a],[a])'. this is a function that given any predicate, i.e. any function which returns `Bool', and given any list of things, returns the list of the things that satisfied the predicate, and the list of the things that didn't
10:11:13 <Twey> Haskell function values are more like functions.  >.>
10:11:18 <ski> > partition even [0,1,2,3,4,5,6,7,8,9]  -- see this
10:11:18 <lambdabot>   ([0,2,4,6,8],[1,3,5,7,9])
10:11:22 <chrisdb> You can use a functional style in lots of languages I think. I probably use function handles in MATLAB more than most of my colleagues... although they suck because they're relatively slow compared to a direct function call.
10:11:53 <EvanR-work> chrisdb: i would imagine so, matlab isnt exactly a functional system
10:11:57 <Hlbert> I am used to thinking as a function as a subset of a cateerisan product 
10:12:09 <applicative> Twey, well, I suppose other senses are legit.  Like operation... of course, we can use that word mathematically too.
10:12:24 <ski> EvanR-work : at least they have added a real lambda, now ..
10:12:36 <EvanR-work> really now
10:12:39 <applicative> Hlbert, the really freak thing is that functions like print are values too...
10:12:40 <ski> (instead of `eval' cruft)
10:12:40 <EvanR-work> been a while since i used it
10:12:47 <dmwit> matlab has lambdas, believe it or not
10:13:24 <EvanR-work> Hlbert: you can specify it that way if you want ;) f 5 = 3; f 4 = 2; f 9 = 4; f 0 = 0
10:13:30 <ski> Hlbert : if you want, you can continue thinking like that. the important thing here, though, is that functions are used to *transform* inputs into outputs
10:13:33 <applicative> :t [print 4, print 5]
10:13:34 <lambdabot> [IO ()]
10:13:51 <applicative> :t head [print 4, print 5]
10:13:51 <ski> > let f 5 = 3; f 4 = 2; f 9 = 4; f 0 = 0  in  map f [0,4,5,9]
10:13:52 <lambdabot> IO ()
10:13:52 <lambdabot>   [0,2,3,4]
10:14:36 <ski> > let f 5 = 3; f 4 = 2; f 9 = 4; f 0 = 0; f _ = 999  in  map f [0,1,2,3,4,5,6,7,8,9]
10:14:37 <lambdabot>   [0,999,999,999,2,3,999,999,999,4]
10:14:41 <Hlbert> I know that functions transform input to output, ie map the elements of one set to those of another set
10:14:58 <ski> Hlbert : have you heard about derivative ?
10:15:03 <applicative> ... the latter is better, it maps..
10:15:06 <Hlbert> Yes
10:15:27 <applicative> deriv takes a function as an argument
10:15:31 <ski> Hlbert : consider `D : (|R -> |R) -> (|R -> |R)', derivative transforming one function into another
10:15:35 <Funktorsalat> IMO 'subset of a cartesian product' is a rather good way to think about functions in haskell, since it implies "no side-effects"
10:15:36 <ski>   D sin = cos
10:15:37 <ski> e.g.
10:16:23 <EvanR-work> too bad you cant pattern match functions ;)
10:16:40 <ski>   cos (pi/2) = 1
10:16:52 <ski>      D sin (pi/2)
10:16:56 <ski>   =  (D sin) (pi/2)
10:16:59 <ski>   =  cos (pi/2)
10:17:00 <EvanR-work> > let cos (pi/2) = 1 in cos (pi/2)
10:17:01 <lambdabot>   <no location info>: Parse error in pattern
10:17:02 <ski>   =  1
10:17:13 <ski> Hlbert : can you follow that ?
10:17:35 <ski> > cos (pi/2)
10:17:36 <lambdabot>   6.123233995736766e-17
10:17:36 <Hlbert> <ski> I argue that D map a function to a function but in maths D is called an operation as oppesed to a fucntion
10:17:53 <ski> er, actually, it is `0', not `1' :)
10:18:04 <ski> > sin (pi/2)
10:18:05 <lambdabot>   1.0
10:18:05 <Hlbert> And what value does D have?
10:18:12 <ski> `D' is also a function
10:18:17 <ski> the derivative function
10:18:19 <EvanR-work> a function on functions
10:18:26 <chrisdb> One thing I didn't realise when I first started playing with Haskell a few months back is that you can treat data constructors like functions for most purposes. E.g 
10:18:28 <ski> what value does `cos' have ?
10:18:34 <chrisdb> map ((,) 2) [1,2,3,4]
10:18:40 <chrisdb> works
10:18:43 <EvanR-work> chrisdb: i think for all purposes?
10:18:49 <applicative> it is clearer if you advert to the usual  d sin x / d x .  the function of writing x twice here is taken up by the lambda.  D (\x -> sin x)
10:18:57 <ski> chrisdb : well, data constructors (of at least one argument) *are* functions
10:19:02 <applicative> this is how frege invented the bound variable
10:19:08 <zygoloid> Hlbert: if you view functions as subsets of the cartesian product, then you're already viewing them as values.
10:19:13 <Hlbert> It doesn't, well not one I can know, it maps R to R
10:19:15 <ski> chrisdb : data constructors are values, in themselves .. only they are more, in that you can match, as well
10:19:18 <chrisdb> ski: yes, but because they don't look the same it took me a little while to realise that Haskell lets me treat them that way.
10:19:34 <ski> Hlbert : `|R' is the set of real numbers
10:19:53 <ski> Hlbert : `|R -> |R' is the set of functions, mapping real numbers to real numbers
10:20:06 <ski> Hlbert : so `cos' and `sin' are elements of the set `|R -> |R'
10:20:13 <zygoloid> ski: confusing the newbies with not-actually-haskell-syntax again i see ;)
10:20:15 <applicative> @type sin
10:20:16 <lambdabot> forall a. (Floating a) => a -> a
10:20:32 <ski> zygoloid : more like, mathy syntax :)
10:20:33 <EvanR-work> -XNotActuallyHaskellSyntax
10:20:45 <pumpkin> -XSkiSyntaxForExistentials kthx
10:20:50 <applicative> -XKindaMathy
10:20:54 <chrisdb> EvanR-work: if only that tag existed. It would automagically do what you meant...
10:20:58 <chrisdb> not what you actually said.
10:21:14 <ski> applicative : actually `d sin x / d x' is the same as `D (\x -> sin x) x', not `D (\x -> sin x)'
10:21:33 <stepkut> do the applicative functor laws dictate that this property always holds, const <$> a <*> b == a <* b
10:21:33 <applicative> ski, oh, i was guessing how D worked
10:21:46 <ski> (applicative : i tentatively call this "rebinding", not having seen a better term)
10:22:14 <ski> stepkut : i think so
10:22:18 <applicative> stepkut, don't the parsers presuppose it
10:22:34 <Hlbert> <ski> good argument but I still have prejudices which I have a hard time oercoming
10:22:45 <ski> well, you need some practive
10:22:47 <zygoloid> @src (<*)
10:22:47 <lambdabot> (<*) = liftA2 const
10:22:53 <ski> s/practive/practice/
10:22:54 <zygoloid> stepkut: ^^ that holds /by definition/ :)
10:23:02 <zygoloid> @src liftA2
10:23:02 <lambdabot> liftA2 f a b = f <$> a <*> b
10:23:05 <stepkut> zygoloid: right, I want to overide it so that it doesn't :)
10:23:19 <ski> stepkut : *bad* programmer !
10:23:28 <stepkut> it's only bad if it breaks the law!!
10:23:30 <Hlbert> <ski> Is there a definition for the word 'value'?
10:23:38 <monochrom> sometimes "d sin x / d x" is D sin. for example in "d (d sin x / d x) / d x".
10:23:39 <EvanR-work> Hlbert: open your brain!
10:24:02 <chrisdb> Hlbert: something that can be stored in data structures, assigned to variables, etc?
10:24:07 <ski> Hlbert : not really. you can think "anything which can result from evaluating any expression", if that helps
10:24:09 <chrisdb> passed to functions...
10:25:02 <ski> Hlbert : values are the things that are passed around and manipulated, when the program evaluates/executes
10:26:06 <ski> Hlbert : btw, don't use "<ski> " to address persons on IRC, use e.g. "ski : " or even "ski, " .. many IRC clients will do this for you, if you type the first few letters of someone's nick, and then press the <TAB> key
10:26:07 <EvanR-work> `eVALUEate` expr => value ;)
10:26:19 <applicative> stepkut, you are supposed to be able to implement <* for your applicative for efficiency, the law is stated: -- [/ignore right value/]  @u '<*' v = 'pure' 'const' '<*>' u '<*>' v@
10:26:37 <pumpkin> mmm, http://github.com/batterseapower/haskell-kata
10:26:50 <monochrom> don't address persons, period.
10:26:55 <Hlbert> Is there any mathematcal definition of the word value?
10:27:03 <dmwit> Why, yes!
10:27:06 <stepkut> applicative: yeah, i figured
10:27:15 <dmwit> Have a Google for "normal form".
10:28:00 <EvanR-work> expressions with no normal form have a value though?
10:28:02 <dmwit> Different languages have different definitions, but something like "has no top-level redexes" seems to be the common ethos.
10:28:03 <EvanR-work> _|_
10:28:04 <EvanR-work> ?
10:28:12 <applicative> is batterseapower the one who wrote to -cafe about Roll {unroll :....} with the wild type function wit?
10:28:17 <dmwit> Languages have values, not expressions.
10:28:21 <ski> (monochrom : i'm sorry, that's probably a bad translation of what i meant to say)
10:28:21 <dmwit> _|_ is not a value
10:28:48 <EvanR-work> _|_ is lack of a value
10:28:51 <pumpkin> applicative: yeah
10:28:57 <stepkut> applicative: I have a situation where I want something like, Just 1 <* Nothing, to  equal Just 1, instead of Nothing :-/
10:29:12 <dmwit> To expand on the above, what I meant was, languages have values, but expressions don't "have" values. They sometimes evaluate to a value -- but not always.
10:29:31 <stepkut> but I guess that is not 'sequencing the actions'
10:29:36 <applicative> bolinbroke, right http://web.archiveorange.com/archive/v/nDNOvrqG0QhMrKd3V1yz
10:29:38 <monochrom> ski: about D sin? or about addressing?
10:29:44 <ski> the latter
10:29:49 <dmwit> > First (Just 1) `mappend` First Nothing
10:29:50 <lambdabot>   First {getFirst = Just 1}
10:30:03 <stepkut> dmwit: yes
10:30:05 <ski> Hlbert : do you know about `map' ?
10:30:05 <dmwit> > Just 1 `mappend` Nothing :: Maybe (Sum Int)
10:30:06 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
10:30:06 <lambdabot>    arising fr...
10:30:20 <dmwit> oh bother
10:30:33 <EvanR-work> humbug!
10:31:02 <Hlbert> So in haskell the notion of a value is anything that a function can output? It ismuch more general that the concept of merly numeric value which I'm used to
10:31:21 <zygoloid> Hlbert: one notion of a value can be found here: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
10:31:46 <ski> Hlbert : well, values are the things that can be bound to variables, stored in data structures such as e.g. lists, passed into functions, returned from functions, &c.
10:32:00 <EvanR-work> Hlbert: no, there are other kinds of expressions than function application
10:32:13 <zygoloid> Hlbert: yeah. you can think of types as being sets, with certain constructive laws for how those sets are formed. then values are elements of any type.
10:32:17 <EvanR-work> but oh yeah functions can output any value
10:32:40 <ski> Hlbert : `5' is a value, the pair `(2,3)' is a value, the string `"hello"' is a value, the list `[(4,"yes"),(3,"no")]' is a value
10:32:43 <Hlbert> Ski: Can a function be bound to a varible?
10:32:49 <ski> yes
10:33:00 <ski> that's what e.g. `not' is
10:33:08 <ski>   not :: Bool -> Bool
10:33:10 <EvanR-work> > :t (\f -> flip f) (+)
10:33:11 <lambdabot>   <no location info>: parse error on input `:'
10:33:15 <EvanR-work> :t (\f -> flip f) (+)
10:33:16 <lambdabot> forall a. (Num a) => a -> a -> a
10:33:19 <ski> this is just a variable `not', that contains a function
10:33:33 <pumpkin> instance Arrow (Voldemort r) where
10:33:34 <ski>   otherwise :: Bool
10:33:38 <ski> is also a variable
10:33:40 <ski> > otherwise
10:33:40 <pumpkin> newtype Voldemort r a b = Voldemort { runVoldemort :: forall c. PurishWotsit r (a, c) (b, c) }
10:33:41 <lambdabot>   True
10:33:52 <ski> `otherwise' is the value `True'
10:33:59 <ski> > not False
10:34:00 <lambdabot>   True
10:34:02 <ski> > not True
10:34:03 <lambdabot>   False
10:34:06 <ski> > not otherwise
10:34:07 <lambdabot>   False
10:34:28 <ski> `not' is the function that maps `False' to `True', and `True' to `False'
10:34:28 <EvanR-work> the variable not contains a function ? :S
10:34:31 <stepkut> dmwit: this is, in fact, the source of my problem. I have an applicative functor that returns an 'empty' value. I want to be able to use that AF with <* or mappend, Just "foo" <* (mempty :: Maybe String) vs Just "foo" `mappend` (mempty :: Maybe String). Except that (<*) instance results in 'failure' which is not what I want.
10:35:01 <Hlbert> ski:I agree not is the name af a function, but why do we call it a varilbe?
10:35:02 <stepkut> Just "foo" <* (pure ()) does the right thing, but then I can't use it with mappend :-/
10:35:06 <EvanR-work> the variable not is a name for a function
10:35:12 <ski> EvanR-work : s/contains/is bound to/, if you prefer
10:35:23 <ski> Hlbert : because it is ?
10:35:27 <EvanR-work> variables are names
10:35:30 <EvanR-work> not storage
10:35:32 <dmwit> stepkut: I'm not sure I understand you. mappend and (<*) are different things; why would you expect to be able to use them interchangeably?
10:35:49 <dmwit> It's a bit like saying, "(+) and (*) give me different answers".
10:35:53 <Pille456> hi! i've a little question about funktions calling functions: letes say there is a function f which gets another function g as an argument. how can i do something like f(g(some Arguments), someMoreArguments) ? 
10:36:13 <ski> Hlbert : if you in your program say
10:36:23 <ski>   myName :: String
10:36:28 <ski>   myName = "Daniel"
10:36:29 <dmwit> f g = f (g someArguments) someMoreArguments -- Pille456
10:36:42 <ski> then that is giving the name `myName' to the string `"Daniel"'
10:36:46 <ski> if you say
10:36:53 <ski>   not :: Bool -> Bool
10:37:00 <monochrom> f g = f (g someArguments) someMoreArguments  -- type error
10:37:00 <ski>   not = \b -> case b of
10:37:09 <Pille456> yeha
10:37:09 <ski>                False -> True
10:37:15 <dmwit> Pille456: Function application is just juxtaposition, no parentheses needed (except to let the parser know what you're doing).
10:37:16 <ski>                True  -> False
10:37:41 <ski> Hlbert : then that is giving the name `not' to the function value `\b -> case b of False -> True; True -> False'
10:37:48 <monochrom> (unless you support infinite types)
10:38:02 <ski> Hlbert : in the case of giving names to functions, there's a more handy syntax
10:38:05 <ski>   not :: Bool -> Bool
10:38:07 <stepkut> dmwit: I don't want to use them interchagably.. they side effects are supposed to be different (in the real use case). 
10:38:08 <dmwit> Oh, whoops, you're right.
10:38:09 <ski>   not False = True
10:38:12 <ski>   not True  = False
10:38:13 <dmwit> In that case, I don't understand the question.
10:38:14 <applicative> > (\f -> f 1 + f 2 + sum (map f [1,2,3]) (+2)
10:38:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:38:18 <monochrom> (for example f's parameter is the hungry type in TaPL)
10:38:36 <ski> Hlbert : but both variants will do the same thing, i.e. give the name `not' to a specific function (value)
10:38:40 <monochrom> beginner's type errors reflect thought errors
10:38:41 <dmwit> stepkut: Okay, maybe you'd better start from the top for me.
10:38:41 <applicative> > (\f -> f 1 + f 2 + sum (map f [1,2,3])) (+2)
10:38:42 <lambdabot>   19
10:38:57 <dmwit> stepkut: (I'm a bit slow, sorry.)
10:39:00 <ski> Hlbert : do you understand ?
10:39:09 <applicative> Hlbert, isn't (+2) bound to a variable there? ^^^^
10:39:38 <stepkut> dmwit: hmm, I'll get back to you
10:39:48 <Pille456> dmwit: using f(g someArguments) moreArguments causes me always:  Couldn't match expected type `a -> b' against inferred type `Int'
10:39:49 <Hlbert> ski: sort of, I must overcome my prejudices
10:40:07 <stepkut> dmwit: are you familiar with formlets at all ?
10:40:34 <dmwit> nope
10:40:42 <ski> Hlbert : remember that the `map' function works as : `map f [x,y,z]' evaluates to `[f x,f y,f z]'
10:40:49 <dmwit> Pille456: Why not paste some code and the exact error you get to, e.g., hpaste.org?
10:40:49 <ski> > map f [x,y,z] :: [Expr]
10:40:50 <lambdabot>   [f x,f y,f z]
10:41:12 <ski> Hlbert : now, since `not' is just a name for a function, we can pass that function as argument to `map'
10:41:22 <monochrom> @quote monochrom runtime
10:41:22 <lambdabot> monochrom says: just add #! /usr/bin/runghc to your haskell file. then type errors occur at runtime only.
10:41:28 <ski> > map not [False,False,True,False,True]  -- Hlbert
10:41:28 <lambdabot>   [True,True,False,True,False]
10:41:56 <applicative> stepkut, so far all I'm coming up with is variants of     join (Just (Just 1) <* Just Nothing)
10:42:13 <applicative> > join (Just (Just 1) <* Just Nothing)
10:42:14 <lambdabot>   Just 1
10:42:15 <Hlbert> ski: so you would consider cosine to be a variable?
10:42:16 <ski> Hlbert : this is the usual way in which we "do the same thing to everything in a list"
10:42:18 <stepkut> dmwit: well, let's say we have a type, Form xml a. and a function, runForm :: Environment -> Form xml a -> (View xml, Maybe a)
10:42:20 <ski> Hlbert : yes
10:42:34 <ski> Hlbert : which is a name for a particular function
10:43:34 <ski> Hlbert : note that what in math, sometimes, is known as "variable","parameter", and often also "constant" are all known as "variable" in Haskell
10:43:45 <stepkut> actually that should be, runForm :: Environment -> Form xml a -> (View xml, Either [String] a)
10:43:54 <applicative> > let (<<**) x y = join (pure x <* pure y) in Just 1 <<** Nothing
10:43:55 <lambdabot>   Just 1
10:44:00 <stepkut> dmwit: so, when you run a Form, you give it an environment (containing the form values), and it produces a view and either a list of errors or a result
10:44:12 <dmwit> Sure.
10:44:25 <ski> Hlbert : the question is just "how variable" they are .. in each case, they are names that refer to values
10:44:45 <aristid> :t \x y -> pure x <* pure y
10:44:46 <lambdabot> forall a (f :: * -> *) b. (Applicative f) => a -> b -> f a
10:44:51 <aristid> :t (<*)
10:44:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
10:44:54 <Pille456> dmwit: alright, here is the code: http://hpaste.org/40874/error_in_haskell
10:45:08 <stepkut> so, you might want to create a form which contains a label. label "username: " *> inputText
10:45:30 <ski> > length [cos,sin,tan]  -- Hlbert : example of putting three function values into a list
10:45:31 <lambdabot>   3
10:45:37 <Hlbert> ski: I  am starting to understand slowly, but and so used to function for numbers to numbers that I am finding it difficult to abstract the concept
10:45:49 <aristid> :t \x y -> join $ pure x <* pure y
10:45:50 <lambdabot> forall (m :: * -> *) a b. (Monad m, Applicative m) => m a -> b -> m a
10:45:54 <stepkut> dmwit: so label wolud have the type, label :: Form xml (), and everything is great.
10:46:09 <ski> Hlbert : yeah "function from numbers to numbers" are useful, but there's lots of other functions
10:46:21 <monochrom> k1 x = update (update k 2 0) 5 0 x
10:46:27 <aristid> applicative: that's a very complicated way to write const
10:46:31 <stepkut> dmwit: except, the label is supposed to have an attribute 'for=id' where the id is the id of the element is labeling (the inputText)
10:46:40 <applicative> aristid, is it always const??
10:46:44 <stepkut> dmwit: the ids come from the Form applicative functor
10:46:44 <dmwit> Pille456: You probably shouldn't supply "x" as an argument twice. For enlightenment, try writing k1 starting with "k1 = update". No fair using lambdas.
10:46:45 <ski> Hlbert : "function from lists to numbers", "functions from numbers to booleans (i.e. truth-values)"
10:46:48 <ski> &c.
10:46:58 <ski> > even 5
10:46:59 <lambdabot>   False
10:46:59 <aristid> applicative: hmm, as long as join . pure = id, i guess
10:47:00 <ski> > even 6
10:47:01 <lambdabot>   True
10:47:03 <ski> > even 7
10:47:04 <lambdabot>   False
10:47:11 <ski> > map even [5,6,7]
10:47:12 <lambdabot>   [False,True,False]
10:47:21 <ski> > partition even [5,6,7]
10:47:22 <lambdabot>   ([6],[5,7])
10:47:24 <mister_m> Sorry guys, quick question about installing the haskell platform: What C OpenGL library am I missing when trying to ./configure? 
10:47:27 <aristid> :t join . pure
10:47:28 <lambdabot> forall (m :: * -> *) a. (Monad m, Applicative m) => m a -> m a
10:47:30 <dmwit> stepkut: Okay, I'm with you so far.
10:47:38 <applicative> damn, yes, it is.  I was trying it on different aplicatives, join ( pure x <* pure y)
10:47:45 <Hlbert> ski: Or functions from "function from lists to numbers tf functions from numbers to booleans, I can't even imagine such a function
10:47:53 <stepkut> dmwit: but Form is an applicative functor, so there is no way toget the id from one side of *> to the other. But instead we can use a monoid
10:47:54 <ski> Hlbert : those are examples of using the function `even', which is a function from numbers to booleans
10:47:55 <monochrom> mister_m: http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
10:48:09 <stepkut> dmwit: label "username: " `mappend` inputText
10:48:12 <ski> Hlbert : with practice, it will becomes easier :)
10:48:37 <mister_m> monochrom, thank you 
10:48:44 <ski> Hlbert : just start with the simple things first, and slowly work your way onward
10:48:55 <applicative> dmwith, there was a question what the other requirements were.  so far we just wanted Just 1 <**** Nothing = Just 1. 
10:49:03 <Hlbert> ski: I find t difficult to imagine this higher order functons
10:49:14 <ski> Hlbert : don't expect Haskell to be that similar to C
10:49:21 <Pille456> dmwit: hm cool, leaving the 'x' out works fine. but i dont get it, whats the difference between both?
10:49:23 <wlangstroth> Hlbert: I came from C myself, and I found playing with ghci, learnyouahaskell.com, real world haskell, and typeclassopedia were a great start
10:49:26 <applicative> dmwit, it was a given that fmap const was to be avoided ....
10:49:45 <benmachine> :t (<$)
10:49:46 <monochrom> I find it difficult to not imagine higher order functions.
10:49:46 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
10:49:49 <stepkut> dmwit: where, label :: Form xml a ; label = (<the xml>, Left [])
10:49:54 <ski> Hlbert : i think the simplest higher-order functions to start with are functions like `map',`filter',`partition'
10:50:14 <ski> > filter odd [1,4,2,8,5,7]
10:50:15 <lambdabot>   [1,5,7]
10:50:20 <ski> > partition odd [1,4,2,8,5,7]
10:50:21 <lambdabot>   ([1,5,7],[4,2,8])
10:50:24 <ski> > map odd [1,4,2,8,5,7]
10:50:25 <lambdabot>   [True,False,False,False,True,True]
10:50:30 <Twey> :t odd
10:50:31 <lambdabot> forall a. (Integral a) => a -> Bool
10:50:35 <stepkut> dmwit: assuming that (Left [] `mappend` (Right a)) == Right a
10:50:36 <ski> > map (\x -> (x,odd x)) [1,4,2,8,5,7]
10:50:37 <lambdabot>   [(1,True),(4,False),(2,False),(8,False),(5,True),(7,True)]
10:50:38 <dmwit> Pille456: Try reducing both definitions by hand. You'll quickly see what went wrong. =)
10:51:23 <ski> Hlbert : `filter' is used to get a list of only those values in a list that pass a given test, e.g. a test for evenness
10:51:42 <ski> Hlbert : `partition' is the same, except you also get a list of those values that didn't pass the test
10:52:16 <ski> Hlbert : `map' is used to transform each element in a list in some way, using any function you want to transform the values
10:52:29 <stepkut> dmwit: but, then when you do, label "foo" *> inputText, your form fails. The alternative would be that the form succeeds, but that the id in the label field refers to itself instead of the inputText element..
10:52:37 <ski> @let square x = x * x
10:52:38 <lambdabot>  Defined.
10:52:45 <ski> > map square [0,1,2,3,4,5,6,7,8,9]
10:52:46 <lambdabot>   [0,1,4,9,16,25,36,49,64,81]
10:52:56 <ski> > map square [0,1,2,3,4,5,6,7,8,9] :: [Expr]
10:52:57 <lambdabot>   [0 * 0,1 * 1,2 * 2,3 * 3,4 * 4,5 * 5,6 * 6,7 * 7,8 * 8,9 * 9]
10:52:58 <stepkut> dmwit: except that I can't really implement the alternative..
10:53:00 <Hlbert> ski: I understand what this function do, but don't know all the type changes they undergo
10:53:39 <ski> Hlbert : here, `square :: Integer -> Integer' so it maps a whole number to another whole number
10:53:41 <dmwit> stepkut: So, you have something like, type Form xml a = (xml, Either [Errors] a)?
10:53:42 <nominolo> > map chr [65..97]
10:53:43 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`a"
10:53:49 <stepkut> dmwit: yes..
10:54:04 <ski> Hlbert : and `[0,1,2,3,4,5,6,7,8,9] :: [Integer]', meaning that `[0,1,2,3,4,5,6,7,8,9]' is a list of whole numbers
10:54:10 <stepkut> dmwit: well, no
10:54:15 <applicative> Hlbert, square takes you from Int to Int, Int -> Int, in the symbolism.  map square makes it go from lists of Int to lists of Ints [Int] -> [Int}
10:54:52 <dmwit> stepkut: Would it make more sense to have something like type Form xml a = (some kind of xml representation with holes for input and holes for output, Either [Errors] a)?
10:55:00 <dmwit> Composition seems much more meaningful in the latter case.
10:55:01 <ski> Hlbert : so, here `map :: (Integer -> Integer) -> ([Integer] -> [Integer])' is a function that transforms functions like `square' (which transforms numbers to numbers), into functions that transform lists of numbers to lists of numbers
10:55:05 <stepkut> in reality it is, type FormState m i a = ReaderT (Environment m i) (StateT FormRange m) a ; newtype Form m i e v a = Form {unForm :: FormState m i (View e v, Result e a)}
10:55:07 <applicative> Hlbert, in general if f goes from a s to b's , then map f goes from lists of a's to lists of b's 
10:55:26 <ski> Hlbert : so `map square' is then a function that transforms lists of numbers to lists of numbers
10:55:49 <ski> Hlbert : which is written as `map square :: [Integer] -> [Integer]' in Haskell
10:56:03 <stepkut> dmwit: holes ?
10:56:28 <ski> Hlbert : so then `(map square) [0,1,2,3,4,5,6,7,8,9]', which can be written simply a `map square [0,1,2,3,4,5,6,7,8,9]' must evaluate to / be a list of numbers
10:56:34 <ski> Hlbert : does that make sense ?
10:57:13 <dmwit> stepkut: Yeah, in the graph algebra sense. There's a couple different ones. Do you want me to try to find a paper talking about them, or does this sound like a dead end to you?
10:57:21 <dmwit> stepkut: I can give a few more high-level comments, one sec.
10:57:23 <Hlbert> ski: Sort off, limitations in my intelligence prevent me form grasping it as fast as I should
10:57:33 <applicative> > map succ "Hlbert"
10:57:34 <lambdabot>   "Imcfsu"
10:57:40 <ski> Hlbert : btw, when math writes `f : X -> Y', Haskell writes `f :: X -> Y' .. it's basically the same idea, though
10:57:48 <applicative> > map (succ.succ) "Hlbert"
10:57:49 <lambdabot>   "Jndgtv"
10:57:56 <ski> > succ 'H'
10:57:57 <lambdabot>   'I'
10:58:07 <monochrom> but then math writes x∈Int rather than x::Int
10:58:28 <ski> (hence "basically" :)
10:58:32 <dmwit> stepkut: The idea is that you have named "input ports" and named "output ports". So you could have, for example, a tree with one node labeled "root" as an input port and one node labeled "leaf" as an output port.
10:58:41 <monochrom> someone should say "poor math, monochrom bashes it every so soften"
10:58:52 <Twey> Hmph
10:58:58 <ski> Hlbert : i would rather think it is limitations in familiarity, rather than in intelligence :)
10:59:04 <dmwit> Then you could compose this with another graph with a single node labeled "leaf" as an input port to give a graph with only one input port, labeled "root".
10:59:11 <applicative> > (ord 'H', succ 'H', map ord "Hlbert", map succ "Hlbert", map (ord.succ) "Hilbert")
10:59:12 <lambdabot>   (72,'I',[72,108,98,101,114,116],"Imcfsu",[73,106,109,99,102,115,117])
10:59:15 <Twey> Why isn't it ‘f ∈ X → Y’?  Surely f is in the set of functions from X to Y.
10:59:17 <ski> Hlbert : you just need some time to get used to it (functions as values) :)
10:59:32 <ski> Twey : category theory
10:59:48 <dmwit> In your case, "label" would generate a tree with one input port labeled "id" or so, and "inputText" would generate a tree with one output port labeled "id".
11:00:13 <dmwit> I have no idea if something like this could work out, it's just a pie-in-the-sky idea that you may be interested in or not.
11:00:21 <ski> Twey : the `f : A -> B' notation comes from category theory, where `A -> B' there is not a set, you can't write `g : (A -> B) -> C', there, that's a syntax error
11:00:32 <monochrom> indeed it should be either consistently "x∈ℤ, f∈ℤ→ℤ" or consistently "x:ℤ, f:ℤ→ℤ".
11:01:07 <Twey> ski: Why is ‘A → B’ not a set?  There's no set of arrows from A to B?
11:01:10 <Hlbert> ski: I'm am starting to like Haskell, but I must overcome some conceptual difficulties
11:01:24 <dmwit> stepkut: In any case, it sounds to me like you want another kind of composition than just (<*) and mappend. =)
11:01:27 * Twey suspects that he's out of his depth and probably won't understand the answer anyway, but decides to give it a try just in case.
11:01:29 <ski> Twey : yes, but that set need not be an object in the category under study
11:01:56 <Twey> ski: And → is fixed to require objects from that category?
11:01:57 <monochrom> the disparity reflects that one upon a time mathemantics considered functions second-class too, exactly like modern programmers who don't accept higher-order functions.
11:01:59 <applicative> Hlbert, it is fairly simple, once you get past a few things; then later it's hard again....
11:02:08 <stepkut> dmwit: dunno.. the key concept of the formlet stuff is (1) each form can be run to produce xml, and possible an extracted value, (2) you can compose the forms together to get bigger forms (3) you always get all the xml even if a value is not produced
11:02:11 <ski> Twey : plus, category theory downplays looking inside sets/objects, prefering to look at them "from the outside"
11:02:47 <applicative> Hlbert, you can make it as hard as you please, as some of our friends here are making plain.  But even the elements are very beautiful.
11:02:53 <stepkut> (3) is the reason why formlets are applicative functors -- if they were monads, then generating XML could possibly depend on the result of a previous formlet, but if that formlet fails to produce a result -- then you can not generate XML
11:03:01 <ski> Twey : the syntax is `<morphism typing> ::= <morphism expression> : <object expression> -> <object expression>', if you see what i mean
11:03:03 <Hlbert> applicative: What resources do you recommend for learning it?
11:03:06 <stepkut> dmwit: so I am wondering if the port stuff would result in a similar issue
11:03:11 <applicative> @where lyah
11:03:11 <lambdabot> http://www.learnyouahaskell.com/
11:03:28 <benmachine> mathematical notation is pretty lol
11:03:43 <applicative> Hlbert, that's quite good, if you take it slowly.   It's going to be a book sometime apparently.
11:03:43 <benmachine> see (x,y) out of context and weep
11:03:43 <ski> Hlbert : some like LYAH ^
11:03:47 <dmwit> stepkut: ah, hm
11:03:50 <dmwit> stepkut: Yeah, it might.
11:03:51 <mercury^> benmachine: indeed.
11:03:57 <mercury^> I wish it would be revised now.
11:04:17 <mercury^> Function application especially is very annoying.
11:04:18 <applicative> Hlbert, but try it, and remember you can always come back here.  Our offices are always open.
11:04:44 <applicative> Hlbert, do you have GHC or Hugs installed?
11:04:56 <Hlbert> GHC
11:05:04 <applicative> oh good.
11:05:08 <monochrom> category theory is one thing. in category theory there is only "f:a→b" and no "0∈a", not even "0:a", so that's fine. but set theory writing "f::a→b" is unforgivable.
11:05:09 <ski> mercury^ : i write `f x', for private mathematical use
11:05:14 <Hlbert> I am using that and nano
11:05:30 <Twey> ski: Sort of, yes
11:05:33 <applicative> aha, what OS are you using?
11:05:46 <Twey> ski: So is there any notation available for higher-order functions?
11:05:47 <applicative> nano is good. 
11:05:50 <Hlbert> I am using mac atm, but I also use Linux
11:05:54 <proq> is there a way to return an expression as (a < b) as 0 or 1 instead of True and False without using an if statement?
11:05:55 <Twey> Haha, nano
11:06:02 <mercury^> ski: but you also want that for arrow composition.
11:06:05 <Twey> proq: fromEnum
11:06:09 <ski> monochrom : well, there's an important distinction between the declaration of having a certain type, and the proposition of being an element of a subset of a type
11:06:11 <Twey> :t fromEnum
11:06:11 <applicative> text editors as they were when i first used one
11:06:11 <lambdabot> forall a. (Enum a) => a -> Int
11:06:23 <monochrom> in set theory there is no type
11:06:24 <Twey> > map fromEnum [True, False]
11:06:25 <lambdabot>   [1,0]
11:06:34 <Hlbert> Twey: I take it you use a more advanced text editor
11:06:38 <proq> Twey: thanks
11:06:43 <Twey> Hlbert: Most of us here use emacs
11:06:50 <ski> Hlbert : if you use Emacs with haskell-mode, you'll get pretty colors in your Haskell :)
11:06:54 <proq> Hlbert: emacs
11:06:55 <Twey> Hlbert: There are a few who use stuff like Yi or vim
11:07:01 <applicative> i now use yi inside urxvt in xmonad on osx to emulate wordperfect 5.1 from 1989 
11:07:06 <applicative> it was such a good year
11:07:09 <mercury^> ski: you could say that arrow composition is a special case of application, if you consider the arrow as lifted to a map of Hom-spaces, but that's not very satisfying, and implicit lifting is not sound.
11:07:16 <ski> monochrom : well, in Zermelo type theory, there is ;)
11:07:33 <Twey> Hlbert: But Yi is arguably incomplete, and vim lacks many of the features of emacs' haskell-mode
11:07:45 <proq> Hlbert: both carbon emacs and cocoa emacs are very well put together on os x
11:07:58 <benmachine> I use vim
11:08:03 <applicative> Hlbert, on OS X i shamelessly use Textmate for Haskell, since thats what I was using when I first learned it.  The associated bundle is not so great, but okay
11:08:10 <benmachine> it's lovely and everyone who says otherwise is clearly a flawed human being
11:08:16 <benmachine> or, well, clearly flawed anyway
11:08:31 <mercury^> I don't get why people use vim. If you go for something bloated, you might as well use emacs, which has far better features.
11:08:35 <ski> mercury^ : yeah, i *hate* conflation of `f' and `f(x)'
11:08:51 <monochrom> "the function f(x)" is a crime
11:08:56 <ski> indeed
11:09:12 <applicative> Hlbert, dont let these editor creeps bother you.  When you are cabalizing packages you might want emacs haskell-ultra-major-mode
11:09:14 <mercury^> It's ok, x is the identity, and f(x) is f composed with the identity thus.
11:09:22 <ski> this is one reason math is harder that it should be, for newbies to learn
11:09:35 <dmwit> f(id) /= f . id
11:09:45 <Hlbert> applicative: I do use window occasionally, what text edior should I use on that
11:09:50 <mercury^> multiplication is composition usually
11:09:55 <applicative> Hlbert, notice that emacs people think that there is not syntax highlighting outside emacs.  even nano has haskell highlighting
11:09:56 <mercury^> So f(id) == id
11:10:05 <mercury^> = f. id
11:10:09 <mercury^> sorry :)
11:10:45 <ski> Hlbert : even Notepad works on Windows .. i mostly use Emacs there, too
11:10:49 <Twey> benmachine: YeahESCi, I toallyESChhhhitA argeeESChhhhxpA ;)
11:11:16 <Twey> applicative: haskell-mode does rather more than highlighting
11:11:41 <EvanR-work> vim haskell highlighting is kind of wonky
11:11:45 <Hlbert> Should I stick to text ediors and a terminal or should i use an ide?
11:11:45 <monochrom> I couldn't care less about highlighting
11:11:50 <mercury^> You can make sense of the notation used currently, but it isn't uniform, sound or simple.
11:11:56 <Twey> mercury^: *nod*
11:11:57 <ski> applicative : ok. i never noticed `nano' doing *any* highlighting ..
11:12:15 <EvanR-work> nano does no highlighting by default
11:12:17 <Twey> mercury^: Personally I think that it would be a much better choice to devise a consistent RPN notation
11:12:22 <monochrom> I use emacs haskell-mode for almost-psychic indentation, and calling up ghci of course.
11:12:42 <monochrom> highlighting is for wimps
11:13:01 <ski> Twey : infix is useful for being able to write `x + y + z' instead of `(x + y) + z' or `x + (y + z)'
11:13:18 <mercury^> Twey: I'm not sure if humans do not prefer functions at the front.
11:13:20 <EvanR-work> another cool feature is paste the haskell cheatsheet as semi transparent background ;)
11:13:28 <mercury^> Twey: many natural languages do suggest it.
11:14:29 <sproingie> harhar.  http://xkcd.com/804/
11:14:55 <applicative> Twey, I am well aware that haskell-mode does more than highlighting, but saying it highlights is like saying it renders letters. 
11:15:46 <mercury^> And there will always be a need for special notation in special contexts. But still, a consistent and logical general notation for functions and composition would be nice.
11:15:50 <applicative> ski, yes, nano comes with several highlighting files ruby.nanorc   etc.  I can't find the haskell one I had a while back, it On The Web.  It wasn't too great, but was hackable
11:16:15 <ski> ok
11:16:30 <applicative> somehow i found nano good for doing :e inside ghci it feels like youre still in ghci
11:16:35 <mercury^> I think it would be better for juxtaposition to denote composition, to not explicitly convert anything and have special notation for function application.
11:17:06 <mercury^> But what is a good notation for it?
11:17:15 <ski> `@' is used in some papers
11:17:36 <mercury^> not implicitly convert*
11:18:06 <sproingie> heh today's xkcd reminds me of what someone was saying about my antispam automation
11:18:13 <mercury^> Yes, `@' sounds good, but the symbol is not so nice imo.
11:18:22 <sproingie> "all the spammers are moving to tiny one-liners we can't write signatures on".  me: "then we WON"
11:18:34 <ski> mercury^ : see <http://www.funmath.be/> .. i agree with the basic idea of that
11:18:45 <monochrom> on Halloween day or evening, we should all tell pumpkin about xkcd 804 :)
11:19:39 <EvanR-work> looking for a hash function
11:19:45 <EvanR-work> @hoogle hash
11:19:45 <lambdabot> Trace.Hpc.Util data Hash
11:19:46 <lambdabot> Network.HTTP.Headers class HasHeaders x
11:19:46 <lambdabot> Data.HashTable hashInt :: Int -> Int32
11:20:02 <EvanR-work> String -> Hash
11:20:06 <sproingie> prop 19 means you'll be able to use your hash function openly
11:20:20 <sproingie> (haha open hashing i made a funnay)
11:20:27 <EvanR-work> >_<
11:20:41 <ski> "Even now, mathematics students are expected to learn complicated (e-d)-proofs in analysis with no help in understanding the logical structure of the arguments. Examiners fully deserve the garbage that they get in return."
11:21:03 <ski> that's Paul Taylor for you ! :)
11:21:40 <mercury^> Hmm, syncopation need not be bad I think.
11:22:18 * applicative keeps looking upward when he sees mercury^ 's nick
11:22:26 <ski> when it distracts from being able to "mechanically" apply rewrite-rules, it is bad
11:23:01 <mercury^> That is mostly an issue for beginning students I would think.
11:23:14 <ski> you want to be able to focus on the direction your expression should be transformed, not be *forced* to all the time (re)figure what each expression means, because the syntax is too ambiguous
11:23:40 <monochrom> my ε-δ tutorial: http://www.vex.net/~trebla/homework/epsilon-delta.html
11:23:41 <mercury^> But you are thinking about it linguistically anyway (at least I do)
11:24:02 * applicative remembers a Tom Lehrer song, 'for every epsilon, there is a delta.." ... http://www.youtube.com/watch?v=1LyDys_IwMY
11:24:15 <ski> more advanced students of math (if they get that far) just learn to cope with it
11:24:42 <monochrom> since everyone has been a beginner, a problem for beginners is a problem for everybody
11:24:59 <Pille456> hi! with the help of dmwit i could get my function running, but (after 10 min of thinking) i've no idea why: k2 = update (update k 2 0) 5 0 worksn, whereas k2 x = update (update k 2 0 x) 5 0 x doesnt. update is defined as: update :: Eq a => (a->b)->a->b->a->b and k as k :: Int -> Int
11:25:26 <monochrom> if you devise a mechanism to sabotage most beginners, you're just putting up an unjustified barrier to entrance.
11:25:44 <mercury^> Yes, but don't you have to learn to cope with it anyway at some point?
11:25:53 <applicative> Pille456, it'd be easier to comprehend with the swank spacing and highlighting of hpaste.org
11:25:55 <monochrom> (now, I do that sometimes, but when I do it I deliberately mean to put up a barrier to entrance)
11:26:04 <mercury^> When you come up with a new idea, you will describe it in a mix of formulas and language.
11:26:05 <ski> mercury^ : not if we could get rid of it !
11:26:24 <ski> Pille456 : what is `x' supposed to be ?
11:26:54 <Pille456> maybe i'm too much used to C and java, but for me it looks like: k2 = update (update k 2 0 x ) 5 0 x  = update someFunction 5 0 x, whereas someFunction = update k 2 0 x 
11:27:09 <mercury^> What should the format of a research paper be in your opinion? Just a mechanically verifiable proof in a formal language?
11:27:11 <EvanR-work> hahaha swank
11:27:12 <ski> mercury^ : yes. but often the next step of making the idea more systematic is just forgotten
11:27:21 <dmwit> Pille456: Here's another observation that may help. Your working k2 is equivalent to k2 x = update (update k 2 0) 5 0 x; note that x occurs only once on the right-hand side.
11:28:20 <applicative> monochrom, you are too broadminded.  It has always been the labor of ex-beginners to make it impossible for everyone else. 
11:28:29 <Pille456> @ applicative: here you can finde the version with the 'x'es http://hpaste.org/40874/error_in_haskell
11:28:57 <mercury^> ski: is there a concrete example somewhere on that funmath page?
11:29:40 <ski> in the papers, i think
11:29:40 <Pille456> @ski, dmwit: i always thought you can see functions in haskell like the math-version of functions. so f x means something like f(x), but then i dont know why you can leave it out
11:29:41 <lambdabot> Unknown command, try @list
11:29:54 <mercury^> That page is horrible.
11:30:02 <mercury^> It does not explain anything and looks ugly. :D
11:30:35 <mercury^> Hrm, which paper in particular?
11:30:54 <mercury^> They seem relevant to the topic, but none is called "The Funmath calculus" or so.
11:30:54 <ski> Pille456 : please don't use `@' when refering to nicks, here
11:31:41 <Pille456> ski: okay
11:31:59 <dmwit> Pille456: Well, if I were to write "f x = g x", wouldn't the good mathematician in you say that's just about the same as saying "f = g"?
11:32:32 <dmwit> (keeping in mind that 'x' is universally quantified in the former equation, of course)
11:33:35 <ski> mercury^ : <http://www.funmath.be/LRRL.pdf> has a summary
11:34:05 <ski> mercury^ : btw, note that i don't agree with all the detailed choices they make, but they have the right idea, imo
11:34:32 <Pille456> dmwit: hm yeha true thing, but i'm telling "okay k2, you'll get an integer and give me back one" and then i do not define how this integer might be called later on. this is kind of... strange to me
11:34:36 <ski> Pille456 : why you can leave what out ?
11:35:15 <Pille456> ski: look at this: http://hpaste.org/40874/error_in_haskell leaving the 'x' in the function k2 out, let it work
11:35:30 <Pille456> ski: oh sorry, is k1 ;)
11:35:46 <Twey> ski: I'm confused by that: < ski> Twey : infix is useful for being able to write `x + y + z' instead of `(x + y) + z' or `x + (y + z)'
11:35:47 <ski> mercury^ : another note. the excerpt from Taylor's "Practical Foundations of Mathematics" is from the HTML-extracted version, which mangles the mathy symbols, unfortunately
11:36:11 <Twey> ski: You mean it's useful because it requires bracketing or conventions to disambiguate?
11:36:25 <Twey> mercury^: Plenty of languages are head-last
11:36:35 <dorkitude> ski: that's exactly why I'm loving Evernote's "clip to PDF" or "export to evernote PDF" functionality
11:36:46 <ski> Twey : no, i'm saying it is useful, because associativity says that it doesn't matter how you bracket
11:36:49 <Twey> I'm an English-speaker natively, but verb-last at least I've always found much more intuitive
11:36:53 <Twey> ski: Ah, I see
11:37:23 <Twey> ski: But the problem is that unbracketed infix isn't only used for associative operations
11:37:45 <Twey> Sometimes it's used for non-associative ones, and then you just have to memorise all the precedences
11:37:53 <ski> Twey : imo, it would be good if one could specify an operator to be (actually) associative. that would need to come with a proof (or a promise) that it actually is associative, of course
11:38:59 <Twey> ski: You mean a postfix syntax with a special notation to indicate that a particular operation is associative?
11:39:01 <monochrom> I should consider their use of ⟑. I may like it.
11:39:14 <ski> Twey : no, infix
11:39:15 <Twey> 5 3 +⁺, for example?
11:39:25 <Twey> Hm, why?
11:39:56 <mercury^> monochrom: seems just like the usual \wedge.
11:40:29 <monochrom> Currently I write like (∀x:t · x>10) if I have no further constraint, and (∀x:t | x even | x>10) if I do. Not completely satisfied, but I knew no nicer way (subjectively)
11:40:30 <mercury^> What about infix notation for constructs associative up to natural isomorphisms?
11:40:36 <ski> monochrom : by `f 0 = f 1 = f 2 = f 3' they mean that `f' is constant. by `f 0 =/= f 1 =/= f 2 =/= f 3', they mean that `f' is injective
11:42:01 <monochrom> But perhaps I will like (∀x:t ⟑ x even · x>10)
11:42:09 <mercury^> And you will need precedence anyway, so adding (left,right)-associativity rules does not seem too bad.
11:42:24 <ski> Twey : if you're going to pass a list, you don't need to know the operation is associative
11:42:53 <dmwit> ⟑ seems strictly harder to type than |
11:43:10 <monochrom> I don't care how hard to type.
11:43:18 <EvanR-work> and harder to see in gnu unifont on xterm!
11:43:22 <mercury^> dmwit: it would be &, not |
11:43:29 * hackagebot yaml-light 0.1.3 - A light-weight wrapper with utility functions around HsSyck  http://hackage.haskell.org/package/yaml-light-0.1.3 (MichaelIlseman)
11:43:34 <monochrom> I would be typing pure colloquial English if I cared.
11:43:46 <monochrom> Like all those die-hard traditional mathematicians
11:43:53 <dmwit> "such that" also seems strictly harder to type than |
11:43:59 <Twey> I have to say, I don't really see the advantage of infix.  Yes, it highlights associativity, but that's not much of an advantage really; associativity is much easier to memorise than precedence rules (and it's a real mathematical concept rather than a purely notational one)
11:44:53 <mercury^> Twey: infix notation is a natural format for specifying assocativity.
11:45:01 <ski> (if you use lists, then `(+ 0 1 2 3)' is just as good)
11:45:27 <jmcarthur> well, it also means that the compiler could feel free to parallelize certain expressions, but the benefit would still be harder to guess i think
11:45:38 <mercury^> Writing x y + z + = x (y z +) + is awkward, and it's much harder to see what is going on.
11:46:12 <EvanR-work> sum [x,y,z]
11:46:13 <jmcarthur> postfix wha-? i need to read up
11:46:48 <ski> mercury^ : `(x y + z +) (x (y z +) +) =' you mean :)
11:46:56 <mercury^> ski: :D
11:47:24 <ski> (or without the brackets, if you have specified arities)
11:48:18 <applicative> Pille456 I arbitrarily changed the order of terms in you 'update' to bring out that what is basically 'altered' is the function, for what its worth http://hpaste.org/40875/updatewith
11:48:23 <monochrom> but hey, perhaps I can throw them off by (∃x:t ∋ x even · x>10)
11:48:52 <mercury^> + id x = id + x (`x' here being the product)
11:49:13 <mercury^> Seems better, but I'm still not convinced.
11:49:20 <mercury^> err
11:49:23 <mercury^> I also forgot a lot there.
11:49:30 <Twey> mercury^: Um
11:49:53 <ski> (applicative : you forgot to annotate the original paste :)
11:50:12 <Twey> More like: x y + z + = x y z + +
11:50:21 <mercury^> (+ id \times + \circ) (id + \times + \cird) =
11:50:29 <ski> Twey : why do you use `=' infix ?
11:50:32 <Twey> The brackets are not necessary, and there's no awkwardness… you can just read it left to right as a normal mathematical rule
11:50:34 <mercury^> Would be the statement for `+' to be assocative in Twey's calculus.
11:51:07 <mercury^> (And I dare you to understand that with the brackets dropped)
11:51:08 <Twey> ski: Because it's a definition, not part of a formula, and having it override precedence makes sense since you're always going to want to pile up a term on either side
11:51:16 <jmcarthur> i like trees better than strings. i find it is easier to group things that way when i'm analyzing it mentally
11:51:23 <monochrom> I already don't understand with the \s
11:51:29 <applicative> ski, yeah, I thought I was annotating, but pressed too many buttons, his is http://hpaste.org/40874/error_in_haskell
11:51:43 <jmcarthur> parens are just an unfortunate side effect of expressing trees as strings
11:52:15 <jmcarthur> but i'd still rather the string be conceptually a tree than not
11:52:23 <Twey> jmcarthur: PN and RPN also express trees
11:52:26 <monochrom> (+ id × + ∘) (id + × + ∘) =
11:52:30 <applicative> yes, this is why Frege went for 2D when he introduced the idea of a formalized languages
11:52:31 <jmcarthur> they do, but they lean :P
11:52:34 <Twey> But unambiguously, without requiring brackets
11:52:46 <jmcarthur> a tree that leans heavily to one side is practically a string
11:53:02 <Twey> monochrom: Are you using the juxtaposition to mean application?
11:53:02 * ski would like it if `C-M-b',`C-M-f',`C-M-u',`C-M-d',`C-M-k' worked on Haskell expressions, in haskell-mode
11:53:11 <jmcarthur> trees are nicer when balanced, IMO
11:53:12 <mercury^> Twey: no
11:53:14 <monochrom> not yet
11:53:16 <applicative> Frege does unfortunately need parentheses in some places....
11:53:16 <EvanR-work> use tree supporting terminals
11:53:29 <ski> (respecting the actual expression structure, rather than just looking for brackets, i.e.)
11:53:41 <ski> (cf. paredit)
11:53:54 <Twey> mercury^: I don't understand your expression, then — + id × makes no sense (you can't multiply a function/operation)
11:54:18 <mercury^> Twey: it's the product functor of sets applied to + and the identity.
11:54:24 <mercury^> (and *an* identity)
11:54:55 <Twey> Oh, okay, I'm just not mathematically apt enough then. :þ
11:55:18 <applicative> that parentheses made it possible to 'serialize' the representation of composable thoughts is ... too bad.  People would have been motivated to discover cool things. 
11:55:48 <jmcarthur> applicative: graphically?
11:56:09 <mercury^> Twey: anyway, you claim that `+ id × + ∘ id + × + ∘ =' is the correct way to write that and easy to understand?
11:56:12 <Funktorsalat> Twey: hmm tbh I can't parse it either ;) (not that I'm particularly apt, but I'm supposed to get the notation)
11:56:21 <monochrom> if parentheses didn't exist, people would have been motivated to discover cool things, such as parentheses.
11:56:35 <applicative> yeah, it just made it clear that in a 'formalize' 'precise' language, we have to do with a list
11:56:43 <jmcarthur> monochrom: or a 2d representation of trees perhaps?
11:56:55 <mercury^> (and I don't see why you can drop the parenthesis there, the `=' could just consume + and ∘)
11:56:58 <jmcarthur> or more generally, graphs
11:57:07 <Twey> mercury^: Oh!  I see!
11:57:14 <monochrom> 2d representation of trees invented. still doesn't stop people from continuing with 1d parenthesizing.
11:57:17 <applicative> i remember thinking that the first 75 pages of Church's textbook are just proving theorems that don't exist without parentheses
11:57:18 <Twey> mercury^: No, I stick with infix =
11:57:19 <jmcarthur> honestly, i don't find the graph representations of lambda calculus expressions often used in papers very easy to understand
11:57:28 <Funktorsalat> I'm not used to operators without any decorations standing for themselves (being unapplied)
11:57:36 <Funktorsalat> in math that is
11:57:39 <ski> btw, cf. the "x -> y : y -> z :->. x -> z" bracket-less notation :)
11:57:47 <jmcarthur> applicative: i feel the same way about a lot of lambda calculus material that has to keep talking about alpha equivalence
11:57:52 <Twey> jmcarthur: You can think of it as a tree with the root at the right of the page and spreading left
11:58:10 <jmcarthur> Twey: right. it's imbalanced
11:58:13 <Twey> mercury^: Because = isn't really an operation, it's a definition
11:58:14 <ski> (that means `((x -> y) /\ (y -> z)) -> (x -> z)')
11:58:15 <applicative> jmcarthur, yes.  the whole business about the choice of letters springs from stringification
11:58:19 <jmcarthur> which makes it lose its "treeness"
11:58:27 <Twey> jmcarthur: No more than a 2D tree is imbalanced towards the top of the page
11:58:35 <Twey> (or the bottom)
11:58:41 <jmcarthur> applicative: combinators solve it, but at the expense of something else :\
11:58:52 <jmcarthur> Twey: i don't understand
11:59:09 <ski> Twey : a definition is just a proposition which uniquely determines a variable
11:59:26 <applicative> in quine's primer he uses (as a preliminary) a 2 D representation of e.g. for all x exists y ( x loves y and y loves x)   
11:59:32 <jmcarthur> Twey: the advantage of the tree representation is that i can easily decompose the problem into two parts by splitting an application. the more balanced the tree, the more equally sized the parts are
11:59:33 <applicative> combinators are loathesome. 
11:59:51 <Funktorsalat> jmcarthur: heh, after I had fooled with encoding lambda calculus in some provers a bit, I came to the conclusion that alpha equivalence is kinda the whole point of lambda calculus ;)
12:00:01 <applicative> combinators are loathesome because they don't display the composition as it would be if you were using real names, not variable letters.
12:00:02 <jmcarthur> Funktorsalat: i think so too
12:00:11 <Funktorsalat> (the names are by far the hardest part to deal with correctly, at least)
12:00:30 <EvanR-work> replace all identifiers with UUIDs ;)
12:00:37 <EvanR-work> the end
12:00:42 <jmcarthur> EvanR-work: ew
12:00:51 <monochrom> monochrom is a UUID
12:01:09 <EvanR-work> not a microsoft standard one
12:01:12 <applicative> > let ident f x = f x x in ident (+) 3
12:01:12 <lambdabot>   6
12:01:15 <jmcarthur> it's a Freenode UID
12:01:25 <Twey> jmcarthur: But with RPN you also have that tree: you can take the last operator and see where its arguments go, or just follow the expression from left to right to get a mental tree, without having to solve the problem
12:01:35 <EvanR-work> youll never run the same lambda calculus twice (tm)!
12:01:37 <monochrom> the microsoft one is not long enough anyway
12:01:37 <mercury^> The goal of a notation should be to make thinking about the problems easy. I do not see how RPN for example solves that goal.
12:01:38 <EvanR-work> or your money back
12:01:55 <ski> Twey : but it is harder to see where to divide it
12:02:07 <Funktorsalat> (for example, try to substitute the bound variable by a fresh variable while recursively implementing substitution, and zonk! your function isn't structurally recursive anymore ;))
12:02:14 <jmcarthur> Twey: my point is that it's basically a O(n) operation to do that with RPN
12:02:16 <dmwit> RPN is lousy when you don't know the arity of your operators a priori.
12:02:25 <dmwit> RPN is lousy other times, too.
12:02:44 <byorgey> such as when you don't know Polish
12:03:07 * EvanR-work polishes byorgey's polish
12:03:25 <byorgey> my polish or my Polish?
12:03:53 <mercury^> Constructions in monoidal categories for example can often be understood well if performed in the form of string diagrams. Therefore that is a good notation in that context. Forcing everything to be RPN would be horrible.
12:04:21 <jmcarthur> Funktorsalat: my issue with the lambda calculus is that it's actually not a great notation for reasoning about evaluation
12:04:37 <dmwit> By the way, I found a nice paper discussing various graphical languages for monoidal categories. Is there a standard text-ification of those graphical languages?
12:04:41 <jmcarthur> Funktorsalat: due specifically to alpha issues
12:04:43 * fryguybob thinks the shunting-yard algorithm is a nice example of the complexity captured in infix vs postfix.
12:04:57 <ski> Funktorsalat : "Alpha-Structural Recursion and Induction" at <http://www.cl.cam.ac.uk/~amp12/papers/alpsri/alpsri.pdf> by Andrew M. Pitts in 2006-05
12:05:01 <jmcarthur> Funktorsalat: it's a great syntax for creating a human readable representation of a computation
12:05:17 <mercury^> dmwit: you could write down the corresponding terms using standard mathematical notation.
12:05:17 <Twey> ski: But you don't need to divide it — you can follow it through directly
12:05:23 <Twey> And reduce the parts, if you can
12:05:26 <mercury^> And there are packages that create diagrams from such descriptions.
12:05:36 <jmcarthur> de bruin may solve some of those issues, but then what's the point of the lambda calculus at all?
12:05:50 <ski> Twey : in forth i can, in RPN i need to know the arities
12:05:56 <Twey> E.G. the inverse of 2 * 5 + is 5 - 2 / — you can just reverse the parts
12:05:57 <dmwit> mercury^: I do not know the standard. Can you point me to it (or examples of it)?
12:06:01 <jmcarthur> might as well just remove that lambda abstraction and translate to combinators
12:06:06 <Funktorsalat> ski: I don't doubt that there are more sophisticated ways than what I had tried, just saying how I found names more tricky to deal with than your average expression tree (without binders) :)
12:06:17 <jmcarthur> this is my conclusion after a fairly heavy dive in the lambda calculus this week, i think
12:06:23 <Twey> Yes, you do, but you need to know the arities anyway to know what to do with the operation
12:06:25 <mercury^> dmwit: just writing things like `f \otimes g' and so on.
12:06:40 <mercury^> dmwit: with juxtaposition as composition.
12:06:45 <dmwit> oh, blah
12:06:50 <ski> jmcarthur : well, combinators give quadratic blow-up
12:07:02 <jmcarthur> ski: SKI does
12:07:06 <ski> indeed
12:07:12 <jmcarthur> hmm, is that where your nick comes from?
12:07:17 * ski gives quadratic blow-up :)
12:07:17 <dmwit> I was specifically wondering about things like representing \otimes using let (x, y) = ... in ... or representing \oplus as case statements.
12:07:20 <ski> indeed
12:07:35 <jmcarthur> never noticed that. i always though "ski" like you would use on a mountain
12:07:35 <dmwit> It seems like it should be possible, but I can't see how to do it really. =P
12:07:38 <jmcarthur> *thought
12:07:54 <ski> (it's more or less a silly name choice, but i don't really care for changing it now .. and i don't know what i'd prefer, anyway)
12:07:59 <mercury^> dmwit: I don't yet understand what exactly you want.
12:08:12 <jmcarthur> ski: my point isn't really about efficiency. just about reasoning about evaluation. even with the blowup i think SKI is just easier to work with
12:08:17 <monochrom> ski is a combinator guru living on a mountain. of course he uses ski on a mountain.
12:08:22 <jmcarthur> *specifically* for evaluation
12:08:45 * ski looks down on the down from the mountain
12:08:55 <ski> heh, s/the down/the world/ :)
12:09:22 <dmwit> mercury^: My desires are scandalously vague. I've got a symmetric monoidal category, and I want a nice (i.e. nice for your average Joe, or maybe slightly-above-average Joe) language for specifying arrows.
12:09:26 <monochrom> polish the polish and look down on the down, ski the ski and lambda the lambda
12:09:33 <jmcarthur> you would obviously prefer bckw
12:09:58 <ski> lambda the ultimate .. lambda ?
12:10:01 <dmwit> "case blah of inl _ -> ...; inr _ -> ..." is nice; "reassociate;(f + g)" is not nice
12:10:06 <mercury^> dmwit: Umm, still not really sure what you want, but maybe Sweedler's notation or the leg numbering notation are of help.
12:10:20 <dmwit> I'll look them up, thanks!
12:10:39 * ski thinks Sweedler notation is probably related to comonads, somehow
12:10:58 <mercury^> It's used for comultiplications.
12:11:22 <mercury^> (generally comonoids in the category of vector spaces, not some functor category)
12:12:14 <mercury^> At least I have not seen it being used with monads, and I cannot think of a way it would apply to arbitrary monads.
12:13:03 <mercury^> (co) :P
12:14:20 <Raelifin1> Hello, world. I have a question.
12:14:30 <aristid> Hello, world.
12:15:02 <ski> Do you mind sharing your question ?
12:15:14 <Raelifin1> Yes, I'm trying to phrase it.
12:15:17 <EvanR-work> i have a question?
12:15:30 <dmwit> Yes, you do!
12:15:35 <EvanR-work> wrong!
12:15:38 <EvanR-work> this channel sucks
12:15:42 <jmcarthur> Why do people end questions with periods. It's like ending a statement with a question mark?
12:15:46 <ski> EvanR-work : yes, that is your question
12:15:49 <EvanR-work> oh
12:15:50 <EvanR-work> right
12:15:54 <applicative> yeah?
12:15:59 <mercury^> jmcarthur: who did that?
12:16:05 <dmwit> Another satisfied customer!
12:16:07 <duckinator> EvanR-work: your face sucks! </random out of context insult based on seeing the word "sucks" at the end of a line>
12:16:14 <duckinator> in other news
12:16:15 <jmcarthur> mercury^: actually EvanR-work did the latter, not the former, but the former happens a lot too
12:16:18 * duckinator continues lurking
12:16:21 <EvanR-work> you suck
12:16:22 <ski> mercury^ : i
12:16:31 <jmcarthur> EvanR-work: :P
12:16:38 <ski> (hm, or maybe i didn't ..)
12:16:41 <mercury^> ski: yours seemed like a proper question, albeit a rhetorical one.
12:16:51 <applicative> Raelifin1, was your question about Haskell.  Do you have an error message from the compiler??
12:17:03 <monochrom> I end a question with a period when I mean the question to be rhetorical. Example: why would people just say "I have a question" and not state it.
12:17:26 <jmcarthur> we should have special punctuation for that
12:17:28 <applicative> They might say it because its true, for example
12:17:32 * ski gives applicative a cookie for getting back to the main issue
12:17:39 <monochrom> (I know the answer. Lazy evaluation.)
12:17:51 <jmcarthur> more punctuation for those who like the interrobang
12:18:15 <jmcarthur> but adding a period to a question mark makes a question mark
12:18:25 <monochrom> let's use ∘ to end rhetorical questions.
12:18:27 <jmcarthur> so obviously the normal question mark should lack the period instead
12:18:36 <mercury^> Are both `?!' and '!?' correct by the way?
12:18:59 <fryguybob> But what is a rhetorical question∘
12:19:15 <applicative> but a rhetorical question is a piece of theater, it needs the marks it would have if it weren't theater.
12:19:33 <byorgey> mercury^: I don't know what "correct" means here; I use both, and to me they have slightly different connotations.
12:19:41 <monochrom> let's also argue whether rhetorical questions should be infix or PN or RPN.
12:19:55 <ski> distfix !
12:19:57 <c_wraith> hmm.  I've just discovered I don't like the implementation of groupBy
12:20:05 <jmcarthur> @src groupBy
12:20:05 <lambdabot> groupBy _  []       =  []
12:20:05 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
12:20:05 <lambdabot>     where (ys,zs) = span (eq x) xs
12:20:12 <fryguybob> Punctuation is postfix and consumes the whole stack.
12:20:17 <mercury^> byorgey: I would think so too. The first is a loud question, the second a silent exclamation.
12:20:22 <applicative> rhetorical questions dont compose, so we don't need a syntax to embed them in
12:20:29 <Entroacceptor> why do I get that message? I'm blind... http://npaste.de/nt/
12:20:29 <c_wraith> well, I guess it's the implementation of span I don't like :)
12:20:39 <jmcarthur> @src span
12:20:40 <lambdabot> span _ xs@[]                     =  (xs, xs)
12:20:40 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
12:20:40 <lambdabot>                   | otherwise    =  ([],xs)
12:20:54 <mercury^> byorgey: but if the former is called `interrobang', does the latter have a name too?
12:21:04 <monochrom> Entroacceptor: where is your "do"?
12:21:07 <Lemmih> Geez, you scared the guy away before he worked up the courage to ask his question.
12:21:09 <applicative> you fogot do
12:21:31 <byorgey> mercury^: I thought the latter was called interrobang!?
12:21:31 * applicative says, listen to the people with better typing skills, Entroacceptor
12:21:35 <monochrom> you're in deep do-do
12:21:37 <Entroacceptor> monochrom: :)
12:21:48 <Entroacceptor> I said I'm blind, thanks
12:22:01 <c_wraith> huh.
12:22:07 <c_wraith> That implementation is *not* what ghc uses.
12:22:11 <ski> mercury^ : i interpret the first as a somewhat uncertain exclamation, and the latter as (usually) disbelieving question
12:22:25 <c_wraith> oh, yes it is.
12:22:31 <c_wraith> THe problem *is* in groupBy
12:22:34 <applicative> monochrom, why does the compiler only complain about the end?  Isn't the missing do already making a hash by line 3 or so?
12:22:41 * hackagebot practice-room 0.0.0 - Watch the practice time for whatever practice you are trying to make, e.g. a piano?  http://hackage.haskell.org/package/practice-room-0.0.0 (JinjingWang)
12:22:48 <jmcarthur> what problem?
12:23:12 <ski> mercury^ : "i grok monads, i think ?!" vs. "you rewrote the whole program in pointless style !?"
12:23:30 <c_wraith> I really want this code to group consecutive ranges:  groupBy (\x y -> x + 1 == y)
12:23:48 <jmcarthur> oh
12:24:01 <dmwit> c_wraith: You get no guarantees if your predicate is not an equivalence relation (as indeed yours is not).
12:24:06 <mercury^> ski: The former seems like a disbelieving question to you?
12:24:23 <jmcarthur> i think there was a mailing list topic about this like a year ago
12:24:33 <ski> mercury^ : no. the latter, though
12:24:38 <mercury^> Ah.
12:24:44 <monochrom> compiler does not know someone wants a "do" to begin with. someone says "let", expect "let ... in", add layout, "let { x = y } z" hey where is the "in"? "expecting in, saw z, error".
12:25:12 <jmcarthur> ski: could disambiguate by putting one symbol in parens and using the other normally
12:25:24 <ski> hm, i might try that
12:26:01 <jmcarthur> (?) to represent uncertainty, (!) to represent surprise
12:26:03 <applicative> monochrom, i see, it didn't know where to begin
12:26:17 <c_wraith> dmwit: indeed.  But I feel like the specification is too loose, and in a way that provides little value.
12:26:36 <EvanR-work> so something with high ? happening is !
12:26:43 <jmcarthur> or just adopt lojban attitudinals ;)
12:27:15 <mercury^> jmcarthur: are you fluent in lojban?
12:27:21 <jmcarthur> who is?
12:27:36 <mercury^> I don't know..
12:27:44 <applicative> If G. Soros is a native Esperanto speaker, anything's possible
12:27:55 <jmcarthur> i don't think there is anybody in the world that is fluent, at least as of a couple years ago
12:27:55 <mercury^> Anyway, is it really worth to put in the effort to properly learn it?
12:27:56 <blackh> Sankta merdo!
12:28:07 <jmcarthur> probably not
12:28:13 <jmcarthur> it's kind of neat to me, but that's all
12:28:22 <dmwit> c_wraith: You are free to write your own function with a narrower specification, of course.
12:28:43 <jmcarthur> the only real use of lojban would be to teach it to some poor kid so that it's native to him/her and then study the kid
12:29:18 <applicative> like the sign language at the sandanista schools for the deaf
12:29:21 <mercury^> Some lojban advertisements say that it completely changes the way you think etc.
12:29:27 <mercury^> Is any of that true for you?
12:29:38 <EvanR-work> is any of that not false ?
12:29:41 <jmcarthur> well, i don't know enough to say one way or the other
12:29:47 <mercury^> (To a larger extend that say, learning a programming language)
12:29:51 <jmcarthur> but i would say that either the advertisements are lying or you read them wrong
12:29:58 <c_wraith> dmwit, is there any way in which the looser specification is better, except in that it allows you to write simpler code?
12:30:18 <jmcarthur> i think the hypothesis is that if you had learned it as your *native* language then you would think differently
12:30:31 <Vanadium> well. duh.
12:30:34 <c_wraith> jmcarthur, learning haskell makes you think differently :)
12:30:49 * applicative wonders how many words for 'snow' Haskell has
12:31:06 <jmcarthur> Vanadium: sadly it's not really "duh" to linguists because it's hard to test with any sort of discipline
12:31:31 <byorgey> > ("snow", ['s','n','o','w'], 's':'n':'o':'w':[], reverse "wons")
12:31:31 <lambdabot>   ("snow","snow","snow","snow")
12:32:04 <jmcarthur> Vanadium: the lojban angle is that because lojban is supposed to be so much more expressive than any known natural languages then a child raised speaking it might think *drastically* different from most other people
12:32:08 <applicative> hm, words for "snow"... that'll do.  I'm seeing "snow" in so many different ways now.  My perception is changed. 
12:33:05 <EvanR-work> a child who grows up speaking only haskell would have a hard time deal with side effects, referential oqaqueness, and pthreads
12:33:14 <applicative> jmcarthur, but can't we trust our fellow humans to come up with the forms they need to express themselves? 
12:33:17 <jmcarthur> c_wraith: but that's not to say that my native language was ever C in the first place, of course
12:33:36 <jmcarthur> applicative: i don't trust fellow humans to do much at all
12:33:38 <applicative> EvanR-work, To say nothing of tense and aspect
12:33:48 <mercury^> EvanR-work: :D
12:34:31 <applicative> I think when it comes to inventing humanly useful languages, the designer approach is hopeless.  Even three year old deaf people have reinvented tense/aspect combinations
12:34:31 <jmcarthur> applicative: the theory isn't about being able to express your thoughts well. it's about the flexibility of your expression shaping your thoughts in the first place
12:34:38 <monochrom> do you mean this thread that I started? http://thread.gmane.org/gmane.comp.lang.haskell.cafe/76590
12:34:44 <jmcarthur> applicative: that what is not expressible is not thinkable, essentially
12:35:09 <jmcarthur> that may be it, monochrom 
12:35:55 <mercury^> jmcarthur: So you find lojban to really be more efficient at expressing complex thought?
12:36:14 <Polarina> I've been taking a look at arrows, and they seem simple enough for me to use, but what advantages do they provide over a monad?
12:36:15 <mercury^> Because I always suspected that in the end I will have trouble formulating anything but toy examples.
12:37:02 <EvanR-work> mercury^: how do we know that an expression of something we think makes people think the same thing when they see the expression
12:37:04 <blackh> Polarina: I've been using arrows in anger for over a year now, and I wish I could give you a simple answer.
12:37:06 <jmcarthur> mercury^: yes to the question, and me too to what you said after
12:37:27 <jmcarthur> mercury^: it's just not something i'm used to, and i don't think i would ever be able to *use* the added expressivity
12:37:31 <Polarina> blackh, what have you been using them for? :)
12:37:53 <blackh> Polarina: This video game that we're writing (BloodKnight).
12:38:03 <mercury^> jmcarthur: can you give an example of something that is inherently hard to formulate in english but easy in lojban?
12:38:21 <mercury^> (And that simultaneously is desireable to formulate)
12:38:30 <jmcarthur> mercury^: i'm not good enough, and i haven't looked at this stuff in years. maybe ask in #lojban?
12:38:41 <jmcarthur> all i remember is i was convinced at one time
12:38:41 <dmwit> Polarina: Have you read the original paper by Hughes introducing Arrows as a solution for static analysis of parsers? It gives a good justification for not using monadic parsers.
12:39:38 <mercury^> Are there any good alternatives to parsec using arrows then?
12:39:50 <blackh> Polarina: We've been using Yampa but we've re-written it.  I suppose I could say that for certain problems, arrows fit better.
12:40:16 <Polarina> blackh, can you come up with an example in which arrows fit better?
12:40:33 <sproingie> how would you say "buffalo buffalo buffalo buffalo buffalo" in lojban?
12:40:41 <Polarina> dmwit, I am not much for papers.
12:40:43 <Polarina> sproingie, haha.
12:41:03 <jmcarthur> they don't have any *advantages* over monad. they just have a smaller api. that means they are more general, and apply to more models
12:41:12 <fixion__> Hi, excuse me everyone. I'm very interested in studying AI as my focus during my Comp. Sci. degree in university, so I wanted to get a head start on a functional language. I have been debating the differences between Lisp and Haskell. Apparently Python, which I already know, is good too. Your thoughts?
12:41:24 <jmcarthur> so there are some models that are arrows but not monads
12:41:31 <jmcarthur> *that form arrows
12:41:32 <pumpkin> jinjing's latest package has me puzzled
12:41:32 <sproingie> fixion__: python is not a functional language
12:41:45 <Polarina> fixion__, I can pretty much guarantee you that you will not find unbiased answers in here.
12:41:57 <ski> fixion__ : if you go for a Lisp, i suggest Scheme
12:41:58 <applicative> what is jinjings new package supposed to do for us?
12:42:00 <ezyang> fixion__: What kind of AI? 
12:42:01 <EvanR-work> sproingie: i was in #python recently, the natives would argue, sometimes
12:42:09 <EvanR-work> with that
12:42:12 <fixion__> I expect bias. I would just like to know some of the pros of using Haskell.
12:42:12 <sproingie> EvanR-work: the #python natives love to argue period
12:42:44 <Polarina> jmcarthur, what can be an arrow that cannot be a monad?
12:42:47 <sproingie> i used to hang out there for years.  smug anti-intellectualism abounds
12:42:49 <ski> fixion__ : otherwise, Haskell, SML, OCaml, Erlang are the usual functional programming languages
12:42:49 <EvanR-work> fixion__: well one pro is that its the best
12:43:01 <EvanR-work> objectively speaking
12:43:05 <jmcarthur> fixion__: my biased answer is that haskell would be more worthwhile to learn than any lisp that i know of. laziness emphasizes composability, types emphasize correctness (and open a whole new can of worms like proving your code correct and stuff), purity makes your code easier to reason about
12:43:11 <blackh> Polarina: The thing about monads is that they basically let you do anything.  Arrows are more circuit-like so they restrict what you can express.
12:43:16 <jmcarthur> *static types, i should say
12:43:26 <fixion__> And more specifically, I'm considering neural networks, intellectual development etc... The program at school is more an introduction.
12:43:35 <pumpkin> neural networks o.O
12:43:43 <sproingie> haskell is probably the most "modern" mainstream functional language.  scheme is also a good choice if you're not concerned so much with types
12:43:50 * hackagebot practice-room 0.0.1 - Practice Room  http://hackage.haskell.org/package/practice-room-0.0.1 (JinjingWang)
12:44:05 <sproingie> especially racket if you use immutable conses
12:44:08 <jmcarthur> Polarina: yampa forms an arrow because the full generality of the monad API would allow for strange sorts of recursion that could lock up a program, iirc
12:44:09 <fixion__> Does Haskell support the tail-recursion technique I've heard so much about?
12:44:12 <blackh> Polarina: I suppose you could say it's easer to slip into an imperative style with a monad, whereas arrows give you more of a transformation from inputs to outputs.
12:44:17 <jmcarthur> *forms an arrow and not a monad
12:44:17 <sproingie> fixion__: it certainly does
12:44:30 <pumpkin> fixion__: of course, but the notion of when you want it may be different from other languages
12:44:31 <sproingie> fixion__: though real world haskell code tends to use maps and folds instead of tail recursion explicitly
12:44:40 <ski> fixion__ : SICP, which uses Scheme, is good (though somewhat dated, at places)
12:44:40 <sproingie> fixion__: it's implemented with recursion tho
12:44:52 <ski> @where SICP
12:44:52 <lambdabot> http://mitpress.mit.edu/sicp/
12:45:01 <jmcarthur> fixion__: tail recursion means a quite different thing in haskell due to laziness
12:45:08 <fixion__> Alright. I think I really like the sounds of this one. Thanks everybody.
12:45:14 <mauke> fixion__: C also supports the "tail recursion technique"
12:45:20 <mauke> that doesn't mean much
12:45:23 <jmcarthur> mauke: some implementations do, not C proper
12:45:25 <pumpkin> mmm
12:45:29 <sproingie> mauke: not directly it doesn't
12:45:32 <mauke> jmcarthur: is Haskell different?
12:45:36 <pumpkin> c supports a recursive call in the tail position
12:45:37 <ski> fixion__ : if you decide to learn Haskell, please visit here when you have more questions
12:45:44 <Polarina> blackh, makes sense. :)
12:45:45 <pumpkin> implementations may or may not do that efficiently
12:45:52 <jmcarthur> mauke: tail recursion doesn't really mean the same thing in haskell, so it's hard to answer that question directly
12:45:58 <blackh> Polarina: I've been using them but I'm only really beginning to grasp their real "meaning".  Either I'm slow, they're subtle, or I haven't been making the effort.  I think it's a combination of those.
12:46:01 <sproingie> some C compilers can do tailcall elimination.  the C standard certainly doesn't mandate it, and I'm not sure it's even eliminated with -O2
12:46:05 <fixion__> Thank you ski. I hope to become an active contributor to this community which I've heard such great things about.
12:46:21 <mauke> sproingie: gcc will eliminate non-tail calls with -O2
12:46:22 <fixion__> One day. :)
12:46:32 <ski> `-fsibling-calls', i think
12:46:43 <blackh> Polarina: One of the key points about arrows is that constant Haskell values are out of scope.  So in arrow syntax, 'let' and 'while' are not equivalent.
12:46:46 <jmcarthur> blackh, Polarina: IMO, Arrow is poorly defined. most of the operations boil down to using functors/bifunctors on some instance of Category
12:47:06 <ski> blackh : s/while/where/ ?
12:47:13 <blackh> Polarina: You're forced to feed in only the stuff you got from the previous arrow.
12:47:19 <blackh> ski: I haven't been sleeping much lately. :)
12:47:30 <ski> blackh : me neither :)
12:47:44 <sproingie> blackh: i'm not sure how that's a feature.  one of the reasons to use monads in the first place is to capture contextual information
12:48:03 <ski> sproingie : restrictions are sometimes features
12:48:03 <jmcarthur> blackh: i don't really like that "forced" terminology. exposing the arrow interface is not sufficient to force any kind of particular usage on an API. you have to aso hide other operations
12:48:10 <jmcarthur> *also
12:48:11 <blackh> sproingie: It's a feature because it restricts what you can express, and for certain problems, makes it easier to eliminate bugs.
12:48:25 <jmcarthur> what i mean is that Arrow is not actually a restriction
12:48:28 <ski> (sproingie : e.g. static type checking in general)
12:48:35 <blackh> Actually what I said was wrong:
12:48:36 <sproingie> blackh: i suppose.  i'd probably prefer a parser that supported a mixed approach
12:48:55 <blackh> Constant things are in scope, but it doesn't work the other way.  Arrow inputs/outputs can't be treated as constants.
12:49:04 <ski> sproingie : if you want to compute static information in a parser (like first and follow sets), then that doesn't work if you have a too powerful formalism
12:49:10 <jmcarthur> what blackh is describing is a feature because the limitations allow more APIs to use it than the monad interface
12:49:46 <jmcarthur> not all APIs *should* expose ways to use context, and that's when you don't want to expose a Monad instance
12:49:56 <jmcarthur> but it may be the case that an Arrow instance is still okay
12:50:40 <edlinde> is there a way to list all the functions that have "Eq a" in their type signature?
12:50:50 * applicative favors applicative parser combinators, they're so weak.
12:50:51 <edlinde> like elem
12:50:51 <blackh> Monads allow you to express the continuation completely in Haskell.  Arrows separate the continuation from the output value you are calculating.
12:51:01 <jmcarthur> Polarina, blackh, sproingie: http://just-bottom.blogspot.com/2010/04/programming-with-effects-story-so-far.html
12:51:09 <EvanR-work> electrogeek: hoogle maybe
12:51:10 <ski> edlinde : i don't think hoogle can do that ..
12:51:12 <EvanR-work> edlinde: 
12:51:14 <blackh> So the structure of the computation can be controlled more by the implementation of the arrow.
12:51:29 <edlinde> in ghci then?
12:51:48 <sproingie> you can list all instances of Eq in scope
12:51:55 <edlinde> or is this something I will just know with time?
12:51:57 <sproingie> :info i think?
12:52:07 <edlinde> :info Eq?
12:52:49 <sproingie> try that.  that only covers the type classes, not free-floating functions with an Eq constraint, but that should be a start
12:52:58 <edlinde> Hmm that just listed all the classes where Eq is defined
12:53:35 <sproingie> it'd be a nice addition to hoogle
12:53:50 <sproingie> be a big result for Eq i imagine
12:54:04 <edlinde> hmm possibly
12:54:09 <Saizan> hayoo?
12:54:13 <blackh> Polarina, sproingie, jmcarthur: Like that article says, arrows have a construction phase and an execution phase which are separate.  In monads they happen at the same time.
12:54:31 <jmcarthur> indeed
12:54:40 <edlinde> but just helps to know that if you made your own datatype and then derive from say Eq... what functions would you then be able to take advantage of
12:54:42 <jmcarthur> monads are able to dynamically reconfigure
12:54:44 <jmcarthur> arrows are not
12:55:24 <sproingie> i suppose that makes arrows easier to reason about
12:55:30 <jmcarthur> in theory
12:55:42 <jmcarthur> like i said, i don't really like our current formulation
12:55:49 <jmcarthur> it's not even as general as it could be
12:55:58 <jmcarthur> so we don't actually get to use it uch
12:56:00 <jmcarthur> *much
12:56:00 <blackh> That's right.  ArrowChoice allows you to go down one path or another, but only ArrowApply allows you to do what >>= gives you: the ability to express in the execution what the continuation should be.
12:56:44 <blackh> But that's a new construction phase.
12:57:08 <jmcarthur> an alternative way to look at it is that with arrows, you can't return an arrow as a value and then use it in your current computation
12:57:17 <jmcarthur> but that's precisely what join allows
12:57:19 <jmcarthur> :t join
12:57:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:57:26 <blackh> Yes - that's it.
12:58:10 <EvanR-work> more power more power
12:58:21 <ski> `join' is the squisher of monads
12:58:23 <Nibble> oh
12:58:26 <Nibble> lambdabot is hereee
12:58:35 <ski> @botsnack
12:58:35 <lambdabot> :)
12:58:38 <Nibble> > let 2 + 2 = 5 in 2 + 2
12:58:38 <lambdabot>   5
12:58:39 <jmcarthur> yeah Cale came in yesterday and brought her back
12:58:41 <Nibble> classic.
12:58:45 <Nibble> how the hell does that work btw
12:58:55 <jmcarthur> what?
12:58:55 <ski> > let f 2 2 = 5 in f 2 2
12:58:56 <lambdabot>   5
12:58:57 <ski> like that
12:58:59 <Nibble> doesn't haskell differ expressions form just numbers
12:59:05 <blackh> Isn't that an n + k pattern?
12:59:21 <jmcarthur> no, it's a redefinition of (+)
12:59:31 <blackh> Oh, duh!
12:59:36 <jmcarthur> > let 2 + 2 = 5 in 2 + 3
12:59:37 <lambdabot>   *Exception: <interactive>:1:157-165: Non-exhaustive patterns in function +
12:59:37 <Nibble> let (+) 2 2 = 5 in 2 + 2
12:59:46 <Nibble> :/
12:59:52 <EvanR-work> let 2 + 2 | veryLarge 2 = 5 in 2 + 2
13:00:03 <jmcarthur> basically you are just case matching on the two values and returning 5 if they are both 2
13:00:04 <EvanR-work> 4
13:00:09 <jmcarthur> otherwise it's _|_
13:00:19 <ski> > let 0 + n = n; n + 1 + m = succ (n + m) in 5 + 4
13:00:20 <lambdabot>   9
13:00:59 <jmcarthur> blackh: that's an interesting observation though. it never occurred to me that there could be confusing between defining (+) and an n+k pattern
13:01:03 <jmcarthur> *confusion
13:01:12 <Twey> > P.+
13:01:13 <lambdabot>   <no location info>: parse error on input `P.+'
13:01:16 <Twey> > (P.+)
13:01:17 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
13:01:17 <lambdabot>    arising from a use...
13:01:19 <jmcarthur> it's not actually ambiguous i guess
13:01:23 <jmcarthur> but it's weird looking
13:01:45 <Vanadium> > let (a + 1) + (c + 2) = a + c in 4 + 5
13:01:45 <lambdabot>   *Exception: <interactive>:1:153-177: Non-exhaustive patterns in function +
13:01:51 <ski> it is ambiguous, if you don't know that disambiguation rule
13:01:58 <Vanadium> I do not actually know how n+k patterns work
13:02:12 <jmcarthur> surprisingly
13:02:17 <Twey> > let (+) = fmap (flip mod 4) . (P.+) in 3 + 2
13:02:18 <lambdabot>   1
13:02:50 <ski> Vanadium : `f (n + 3) = ..n..' gets translated to `f m | m >= 3 = ..n.. where n = m - 3', more or less
13:03:14 <Twey> > let [(+), (*)] = fmap (fmap . fmap $ flip mod 4) [(P.+), (P.*)] in 2 * (3 + 4)
13:03:15 <lambdabot>   2
13:03:51 <sproingie> n+k patterns are outright gone in Haskell 2010
13:03:56 <sproingie> right?
13:04:36 * ski wonders when we'll get `n*k + m'-patterns ..
13:04:47 <sproingie> polynomial patterns!
13:04:55 <ski> !
13:04:58 <nejucomo> What's an n+k pattern?
13:05:20 <ski> nejucomo a pattern of the form `<pat> + <integer literal>'
13:05:48 <sipa1024> > case 5 of { 0 -> "nothing"; n+1 -> (show n) ++ "plus one" }
13:05:49 <lambdabot>   "4plus one"
13:05:50 <Gracenotes> no, we need diophantine patterns next
13:05:59 <ski> > let f (x + 3) = x in f 8
13:06:00 <lambdabot>   5
13:06:00 <ski> > let f (x + 3) = x in f 3
13:06:01 <lambdabot>   0
13:06:02 <ski> > let f (x + 3) = x in f 2
13:06:03 <lambdabot>   *Exception: <interactive>:1:145-157: Non-exhaustive patterns in function f
13:06:05 <Gracenotes> nondeterministic ones
13:06:13 <Gracenotes> to account for multiple integer solutions
13:06:32 <ski> sipa1024 : s/(show n)/show n/ :)
13:06:54 <Vanadium> Instead of banning n+k patterns we should have come up with a fancy way to specify the n+k thing for arbitrary types
13:07:01 <ski> > let f ((x + 2) + 3) = x in f 8
13:07:02 <lambdabot>   <no location info>: Parse error in pattern
13:07:11 <Vanadium> "foo:" ++ bar patterns!
13:07:21 <ski> oh .. it appears it actually is `<identifier> + <integer literal>'
13:07:27 <blackh> jmcarthur: That article you linked to is just what I was ready for. :)
13:07:37 <ski> Vanadium : Erlang has that (and Mercury, but that's not a hack)
13:07:57 <sproingie> far as i can tell they made induction easier to express, but it isn't that hard without them, and they're confusing and they feel kind of like a hack
13:08:21 <Vanadium> regex patterns :3
13:08:34 <ski> yeah .. `f (n + 2) = ..n..' ought to have been `f (n + 2 | n >= 0) = ..n..'
13:09:39 <ski> > let f (((^2) -> x) + 3) = x in f 8
13:09:40 <lambdabot>   <no location info>: Parse error in pattern
13:09:42 <ski> :/
13:16:20 <monochrom> view pattern can be used as a replacement and generalization of n+k
13:17:37 * ski is missing a declaratice reading of view patterns
13:18:32 <magicman> I kind-of like http://hackage.haskell.org/package/first-class-patterns .
13:31:47 <monochrom> http://hpaste.org/40878/view_examples  how do you like it? :)
13:31:59 <monochrom> (and I couldn't care about camel_case)
13:32:11 <monochrom> (err, I couldn't care less about camel_case)
13:32:18 <jmcarthur> blackh: heh
13:32:24 <aristid> Zoro!
13:32:34 <monochrom> "nDiv2" is just ugly
13:32:47 <sipa1024> :t nDiv2
13:32:48 <lambdabot> Not in scope: `nDiv2'
13:35:24 <Heffalump> F# active patterns are really nice, FWIW
13:36:04 <pumpkin> active patterns!
13:36:09 <pumpkin> microsoft sure likes the word "active"
13:36:13 <pumpkin> what do they do though?
13:36:27 <monochrom> they also like the suffix "X"
13:36:40 <ksf> well... I guess #haskell isn't political.
13:36:42 <monochrom> sometimes they like the prefix "direct" too
13:37:01 <ksf> but still, there's enough eu citizens here to make me not care and spam a bit:
13:37:03 <ksf> http://www.deletion-not-blocking.eu/index.html
13:37:16 <monochrom> at first they meant something. after several iterations of generalization, they are merely brandings. like Apple's "i"
13:37:22 <pumpkin> oh, interesting
13:37:36 <pumpkin> it's sort of like an implicit view pattern
13:38:04 <pumpkin> class View a b where view :: a -> b
13:38:31 <pumpkin> instance View Int Parity where view x | even x = Even; | otherwise = Odd
13:38:58 <pumpkin> odd :: Int -> Bool; odd Even = False; odd Odd = True
13:39:12 <jmcarthur> i think an old version of haskell had that, even
13:39:16 <pumpkin> really?
13:39:28 <jmcarthur> it's hearsay, and i may be remembering it wrong
13:39:35 <pumpkin> anyway, seems like it'd be quite simple to have a preprocessor that sticks view -> into all your patterns
13:39:39 <jmcarthur> but it has been discussed here
13:39:56 <jmcarthur> i do like that and wish our ViewPatterns worked that way
13:40:04 <pumpkin> I dunno, it's awfully implicit
13:40:06 <pumpkin> :P
13:40:12 <jmcarthur> not with an explicit type sig
13:40:22 <pumpkin> it suggests that Even and Odd are constructors of Int
13:40:32 <ski> monochrom : hehe, i played with `data FibNat :: * -> * where Zero :: FibNat Void; One :: FibNat (Maybe Void); Step :: FibNat n -> FibNat (Maybe n) -> FibNat (Maybe (Maybe n))' some while ago :)
13:40:43 <jmcarthur> that could actually be an abstraction
13:40:54 <pumpkin> @let zero = In Nothing
13:40:55 <lambdabot>  Defined.
13:41:24 <pumpkin> :t let suc x = In (Just (In x))
13:41:25 <lambdabot> <no location info>:
13:41:25 <lambdabot>     not an expression: `let suc x = In (Just (In x))'
13:41:26 <pumpkin> :t let suc x = In (Just (In x)) in suc
13:41:27 <lambdabot> Maybe (Mu Maybe) -> Mu Maybe
13:41:33 <pumpkin> :t let suc x = In (Just x) in suc
13:41:34 <lambdabot> Mu Maybe -> Mu Maybe
13:41:34 <jmcarthur> even a version with some sort of annotation would be nicer than what we have right now, IMO
13:41:40 <pumpkin> @let suc x = In (Just x)
13:41:41 <lambdabot>  Defined.
13:41:57 <jmcarthur> foo (-> Even) = ...
13:42:05 <jmcarthur> instead of having to type the projection out yourself
13:42:12 <pumpkin> by the way, I loved BSP's Mu on haskell-cafe
13:42:27 <jmcarthur> yeah that looked neat. i'd like to play with it and see how fragile it is
13:43:34 <jmcarthur> wait, lambdabot knows Mu now? since when?
13:43:43 <pumpkin> I dunno, for a while
13:43:49 <jmcarthur> nice
13:43:50 <pumpkin> > fix suc
13:43:51 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
13:43:55 <ski> maybe a year or two, not sure
13:43:58 <jmcarthur> wow
13:44:08 <pumpkin> jmcarthur: GET WITH THE TIMES!
13:44:18 <monochrom> lambdabot knows all kinds of haskeller secrets
13:44:36 <pumpkin> it even has the :+: and :*: types for some reason
13:44:45 <pumpkin> :t Mu ((:+:) 1)
13:44:46 <lambdabot> Not in scope: data constructor `Mu'
13:44:46 <lambdabot> Not in scope: data constructor `:+:'
13:44:46 <monochrom> for example how you need to hug a lambda bear to sleep at night
13:44:48 <pumpkin> :k Mu ((:+:) 1)
13:44:49 <ski> monochrom : now implement addition on `exists n. FibNat n' :)
13:44:49 <lambdabot> *
13:45:02 <jmcarthur> oh maybe it has TypeCompose now?
13:45:07 <jmcarthur> i know vector-space was added
13:45:23 <jmcarthur> i doubt it has TypeCompose though
13:45:55 <jmcarthur> wait. i don't think those are what i expected them to be
13:46:20 <jmcarthur> :k (Maybe :*: [])
13:46:21 <lambdabot>     `Maybe' is not applied to enough type arguments
13:46:21 <lambdabot>     Expected kind `*', but `Maybe' has kind `* -> *'
13:46:24 * ski wonders what wagle_ is up to ..
13:46:26 <jmcarthur> nope
13:46:53 <jmcarthur> i guess they are just strict products and sums or something?
13:46:59 <jmcarthur> > 4 :*: 5
13:47:00 <lambdabot>   No instance for (GHC.Show.Show (t GHC.Generics.:*: t1))
13:47:00 <lambdabot>    arising from a u...
13:47:06 <jmcarthur> generics?
13:47:06 <wagle> registering wagle_ grouped with wagle
13:47:11 <jmcarthur> okay i need to look it up
13:47:43 <jmcarthur> oh those
13:47:46 <jmcarthur> how useless
13:47:49 <ski> wagle : it just looked very strange to see the change in that direction :)
13:48:32 <dreixel> jmcarthur: the little used generic classes: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/generic-classes.html
13:48:34 <kmc> :k 
13:48:35 <lambdabot> parse error (possibly incorrect indentation)
13:48:35 <kmc> :k 1
13:48:36 <lambdabot> *
13:48:43 <jmcarthur> dreixel: yeah, i remember it now
13:48:57 <jmcarthur> :k 1
13:48:58 <lambdabot> *
13:49:00 <dreixel> hopefully due to be replaced soon :)
13:49:06 <ski> @type Unit :: 1
13:49:06 <jmcarthur> woops dupe
13:49:07 <lambdabot> Unit
13:49:10 <jmcarthur> ah
13:49:16 <jmcarthur> :k 0
13:49:17 <lambdabot> Only unit numeric type pattern is valid
13:49:22 <jmcarthur> darn
13:49:24 <ski> bad
13:49:33 <jmcarthur> 1 is inaccurate as it is
13:49:41 <jmcarthur> i hate that our unit types have two values
13:49:52 <jmcarthur> nobody gives the newtype version any love
13:49:57 <ski> well, it has one *total* value
13:50:05 <jmcarthur> newtype Unit = Unit Unit
13:50:40 <bayyak> hi guys how is tail recursion different than the "usual" resursion ?
13:50:57 <ski> bayyak : tail recursion is just when the recursive call is a tail call
13:51:02 <jmcarthur> bayyak: tail recursion is when you recurse with a tail call
13:51:21 <jmcarthur> bayyak: a tail call is when the *last* thing you do in a function is call another function
13:51:53 <jmcarthur> bayyak: this is only really significant if the function is strict though. it's kind of weirder in haskell
13:52:16 <ski> bayyak : the idea being that the last call will return the same value as the whole definition, so it can reuse the same stack-frame, instead of making a new one, thereby bypassing the current function, when returning
13:52:29 <bayyak> does that means that the function CAN ONLY CALL IT SELF ONE TIME by definition ? or you could possibly have multiple calls for the same funtion depending on the guards ?
13:52:42 <monochrom> In non-haskell languages, tail recursion may enjoy a code optimization. In haskell, all recursions enjoy a code optimization.
13:52:48 <ski> bayyak : the latter
13:52:49 <sproingie> if the function calls itself twice, one of those calls is not going to be in the tail position
13:52:49 <monochrom> yes.
13:53:20 <sproingie> frankly i don't even think in terms of "calls" in haskell, i read it all definitionally
13:53:20 <jmcarthur> and example of a tail recursive function not doing what somebody expected because it was lazy: http://iam.elbenshira.com/archives/151_integral-calculus-in-haskell/
13:53:36 <jmcarthur> *an
13:53:36 <ski> bayyak : if `if foo then bar else baz' is in tail-position, then both `bar' and `baz' is in tail-position .. so if both of those are calls, those will be tail-calls
13:53:43 <sproingie> expanding calls in my head as necessary (why is there no easy way to expand them in ghci?)
13:53:54 <bayyak> is this tail reursion ? http://hpaste.org/40847/my_partition
13:54:16 <sproingie> ski: technically it's only calling once, it's just choosing one or the other
13:54:24 <jmcarthur> bayyak: looks it to me
13:54:26 <monochrom> yes
13:54:42 <c_wraith> in all the cases except n == 0 :)
13:54:47 <ski> bayyak : yes, but you should define `newfunc' in a `where' inside the `partition' definition
13:55:06 <bayyak> oh ok 
13:55:12 <monochrom> but then you couldn't test newfunc itself
13:55:28 <ski> bayyak : and you need to replace `,' by `&&'
13:55:31 <monochrom> you would have to prove it correct yourself. the horror! XD
13:55:52 <jmcarthur> the semicolons make me cringe ;)
13:55:58 <ski> monochrom : well, we ought to be able to step into the definition (providing values for the free variables) ..
13:56:10 <monochrom> anyway, so hlint hates oleg'case as well. I hate hlint
13:56:19 <ski> bayyak : instead of using `==', you should pattern-match on literals
13:56:40 <jmcarthur> ski: i disagree with that one
13:56:44 <jmcarthur> in this case
13:56:48 <monochrom> oh, testing an inner function should be an IDE job
13:56:52 <jmcarthur> because he's using guards already, might as well use them for that too
13:56:58 <ski> sproingie : yeah, so it is an additive conjunction, in the sense of linear logic :)
13:57:38 <bayyak> ski, thanks, see my professor doesn't agree with this as a tail recursion, he wants it .like literally calling it self only ONCE. how is this possible ?
13:57:45 <sproingie> conjunction junction, what's your tail-recursive function?
13:57:48 <ski> ok, right
13:57:52 <jmcarthur> bayyak: it is only calling itself once per call though
13:57:57 <ski> bayyak : `flag' ought to be a boolean
13:58:00 <jmcarthur> so i disagree with your professor
13:58:04 <monochrom> f x = if False then f(f x + f x + f x) * f(f x - f x) else f 0  -- tail? not tail? :)
13:58:29 <ski> bayyak : then your professor is wrong
13:58:39 <bayyak> THANK YOU ! 
13:58:40 <sproingie> ah, you're experiencing the age old problem of academia: the REAL problem is not the one on the paper, it's finding the answer the professor will accept
13:58:45 <jmcarthur> bayyak: but if you *had* to do it his way... you could put the conditionals into the parameters of the recursive call o_O
13:58:46 <ski> monochrom : both, of course
13:58:53 <monochrom> darn
13:59:05 <c_wraith> monochrom, looks like _|_ to me :)
13:59:11 <monochrom> fire the prof
13:59:22 <sproingie> (_|_) looks like a bottom
13:59:59 <ski>   where
14:00:05 <ski>   (ol,nl,nh,oh,f)
14:00:32 <ezyang> fat _|_ = girls 
14:00:55 <ski>     | p <= head old_high && flag == -1 = (ol,nl,(head old_high): new_high,(tail old_high),-1)
14:01:04 <ski>     ...
14:01:38 <ski> and then your recursive call is just
14:01:44 <ski>   newfunc p (n-1) ol nl nh oh f
14:01:51 <monochrom> the prof should be fired for emphasizing tail recursion at all for haskell.
14:01:52 <ski> (written in a single place)
14:02:01 <lambda1> can someone tell me why i'm getting a parse error here? http://hpaste.org/40881/partial_application_issue
14:02:32 <ezyang> lambda1: Dollar in the wrong place. 
14:02:37 <ezyang> line 4. 
14:02:50 * jmcarthur rewrites bayyak's code
14:02:54 <lambda1> ezyang: where should it be? I'm trying to get partial application to work there
14:02:54 <monochrom> same crime as a C prof saying "for this assignment, all identifiers must be in letters only, 0-9 not allowed"
14:02:56 <jmcarthur> monochrom: seriously
14:03:12 <ezyang> lambda1: just omit the dollar. 
14:03:22 <ezyang> You don't need anything special for your functions to be partially applicable. 
14:03:30 <ezyang> This is what we say is "curried by default" 
14:03:31 <ski> lambda1 : you presumably also want `assocs' in all the other defining equations
14:03:54 <ezyang> that too. 
14:04:22 <ski> lambda1 : i.e. each equation should start by `eval assocs'
14:04:45 <lambda1> ski: yeah I thought i was going to be able to avoid that with partial application someone? i guess i was mistaken
14:04:47 <ski> lambda1 : you also need to fix your recursive calls
14:05:05 <sproingie> monochrom: easy.  variableone = 123; variabletwo = "hello world"; ... variableseventyeight = ...
14:05:06 <ski> lambda1 : one alternative is to do :
14:05:12 <ski>   evalWith :: [(Char, ArithExpr)] -> ArithExpr -> Integer
14:05:17 <ski>   evalWith assocs = eval
14:05:19 <ski>     where
14:05:24 <ski>     eval (Num n) = ...
14:05:32 <monochrom> yes it's easy to do but the prof is a criminal for asking it at all
14:05:34 <ski>     eval (Var n) = ...
14:05:36 <ski>     ...
14:06:13 <ski> lambda1 : then you can continue calling `eval' recursively ..
14:06:17 <ski> lambda1 : .. if you want to call with a different `assocs', call `evalWith' instead
14:06:27 <lambda1> ski: hmm i see, i'll take a look thanks.
14:07:05 <ski> lambda1 : note that `evalWith assocs = eval' is the same as `evalWith assocs expr = eval expr', but shorter
14:07:47 <lambda1> ski: eta reduction?
14:07:50 <ski> yes
14:08:08 <ski> (or rather extensionality, but it is related)
14:08:51 <ski> eta-reduction is that `\x -> (...) x' is the same as `...'
14:09:23 * Twey tries to remember the other kinds of reduction.
14:09:30 <ski> extensionality is `forall f g. (forall x. f x = g x) => f = g'
14:10:38 <Twey> Oh, beta reduction is application: (\x -> t x) s → t s
14:11:15 <ski> well, one application there is an object-level application, while the other is a meta-level application
14:11:44 <ski> (it can also be phrased in terms of substitution)
14:11:48 <Twey> Yeah
14:12:09 <pumpkin> Twey: there's alpha
14:12:16 <ski> `t' is not an expression of function type, but a function from expressions to expressions
14:12:17 <pumpkin> which is just renaming
14:13:14 <Twey> pumpkin: Alpha isn't reduction, though
14:13:17 <Twey> Just equivalence
14:13:20 <pumpkin> oh yeah
14:13:22 <pumpkin> well
14:13:24 <ski> generally, beta-reduction is that an elimination-rule below an introduction-rule can be simplified
14:13:40 <ski> while, eta-reduction is that an introduction-rule below an elimination-rule can be simplified
14:14:12 <ski> so `fst (x,y) = x' and `snd (x,y) = y' are beta-rules for product/conjunction
14:14:26 <ski> and `(fst x,snd x) = x' is the corresponding eta-rule
14:15:10 <ski> (i'll leave you to figure out what beta and eta become for sum/disjunction)
14:16:53 <lambda1> ski: but if assocs :: ArithExpr -> Integer, why can't "eval assocs (Var n)" just take the assocs and pass the Var n onto the definition of assocs?
14:17:28 <lambda1> if that makes sense
14:17:32 <ski> it doesn't
14:17:34 <ski> lambda1 : i thought you wanted `assocs :: [(Char, ArithExpr)]' ?
14:18:36 * jmcarthur stops rewriting bayyak's code
14:18:39 <lambda1> ski: sorry correction, "eval assocs"
14:18:50 <lambda1> eval assocs :: ArithExpr->Integer
14:19:23 <ski> `eval assocs (Var n)' means `(eval assocs) (Var n)' .. i'm not sure whether you were confused by that
14:19:35 * ski is confused about what lambda1 is confused about
14:19:57 <ski> jmcarthur : done ?
14:20:04 <lambda1> ski: yeah I'm clear on that, what i'm asking, is why can't it be eval (assocs Var n) or similar
14:20:44 <ski> `assocs' is a list, so `assocs Var n' (trying to apply it on two arguments) doesn't make sense
14:20:49 <ski> if you want, you could do
14:21:09 <ski>   eval :: ([(Char,AruithExpr)],ArithExpr) -> Integer
14:21:18 <ski>   eval (assocs,Num n) = ...
14:21:22 <ski>   eval (assocs,Var n) = ...
14:21:23 <ski>   ...
14:21:24 <ski> though
14:21:49 <ski> that way `eval' will get a pair containing `assocs' and the expression, instead of accepting the arguments, one by one
14:22:14 <ski> .. but in this case, i don't see any advantage, doing it that way
14:22:18 <lambda1> no, that's not what i'm looking for. i'm trying to be able to define it with two arguments once and one argument all the other times basically, for the sake of elegance and not repeating myself but i guess that's impossible?
14:23:26 <chrisdb> lambda1: can't you just define a second function which is a partial application of the first function?
14:23:26 <ski> either `eval' takes one argument, or it doesn't
14:23:42 <chrisdb> presumably you know when you want to apply it to two, and when you want to apply it to one.
14:23:58 <ski> lambda1 : the `evalWith'/`eval' idiom i sketched above is useful to avoid mentioning `assocs' more than necessary, though
14:24:05 <lambda1> chrisdb: that's what i'm attempting to do
14:24:19 <ski> lambda1 : so `evalWith' will get two arguments, but `eval' will get only one
14:24:42 <lambda1> ski: i won't always have the assocs argument but rather only if the main argument is of type Var
14:24:52 <lambda1> ski: is that not an issue?
14:26:26 <ski> what if the main argument is
14:26:28 <ski>   Operator Plus [Var 'a',Num 3,Var 'b']
14:26:28 <ski> ?
14:26:59 <ski> you will need to have `assocs' ready for when your recursive calls reach the `Var's there
14:27:24 <lambda1> changing to user pygmalion guys, switching computers
14:27:30 <ski> generally, you don't know beforehand if your expression will contain `Var' or not
14:27:36 <ski> so you need to pass it always
14:27:37 <pygmalion> ski: true
14:27:45 <pygmalion> ski: but what if i don't have assocs?
14:27:50 <pygmalion> i guess it's the empty list then
14:27:59 <ski> `assocs' can always be an empty list, yes
14:28:22 <dankna> So!  A question.
14:28:40 <ski> the `evalWith'/`eval' trick above avoids most of the tedium of writing `assocs' everywhere
14:28:47 <dankna> I am attempting to implement typed feature structures, which are basically records but oriented towards linguistics.
14:29:09 <dankna> The catch is that, while I want them to retain all the typing properties of records, for the operation of unification I need to treat them as key-value maps.
14:29:12 <jmcarthur> ski: no, i just got tired of it :P
14:29:14 <jmcarthur> i was being too picky
14:29:21 <jmcarthur> and it's not code i will ever use again
14:29:25 <dankna> Do I want type families, which I don't really understand, or Data.Data, which I vaguely grasp?
14:29:28 <jmcarthur> or ever use, even
14:29:43 <ski> dankna : you might have fun talking to augur, btw :)
14:29:54 <dankna> ski: yeah we've met :) he's working on some neat stuff
14:29:59 <jmcarthur> dankna: i don't see the similarity between type families and Data.Data...
14:30:16 <ezyang> dankna: I don't think type families is appropriate for your application. 
14:30:21 <bayyak> ski, hi again, what am i doing wrong here, it compiles ok, but when i call partition function ...nothing happens ... http://hpaste.org/40882/my_partition
14:30:21 <dankna> jmcarthur: the similarity is only that they are both abstractions which I know just enough about to think that they might be able to help me
14:30:25 <ezyang> In particular, linguistics has very little in the way of static typing :-) 
14:30:35 <dankna> ezyang: this is true, haha
14:30:47 <ezyang> "you're better off trying to do it in lisp or something" 
14:30:56 <dankna> actually I wrote some code doing this in Lisp a few years ago and I am eager to redesign it with stronger typing
14:31:04 <ski> bayyak : next time, annotate the original paste with related pastes
14:31:08 <ezyang> In this case, I think the punning might get in the way. 
14:31:14 <dankna> hmm
14:31:18 <ezyang> Can you do something crazy with typeclasses? 
14:31:36 <dankna> possibly?  I've no idea :)
14:31:46 <bayyak> ski, ok sorry, im sitll new in this.
14:32:10 <ski> bayyak : you're "changing" the wrong arguments, in most cases
14:32:19 <koninkje> Does anyone have a worked example of using the cmdargs package (preferably with multiple modes)?
14:32:34 <ski> bayyak : also, sorry, i note i had a thinko in what i wrote above
14:32:38 <ezyang> dankna: No, it wouldn't really be appropriate, because you wouldn't know the typeclasses at compile time. 
14:32:44 <ski> you want
14:32:47 <dankna> ah, indeed.  yeah.
14:33:07 <ezyang> koninkje: cabal unpack cmdargs probably has a few. 
14:33:31 <koninkje> ezyang++
14:33:40 <koninkje> I always forget about cabal unpack
14:33:50 <augur> dankna: we've met??
14:34:20 <dankna> augur: yes, you were the one who was working on the English-based Quicksilver-like app, weren't you?
14:34:44 <augur> oh yes well
14:34:48 <dankna> you showed it to me, I thought the app itself wasn't much yet but the approach you described was very interesting.  unless that was someone else.
14:34:50 <augur> but thats not met really
14:34:57 <augur> i mean, net-met
14:34:59 <jmcarthur> bayyak: basically, the pattern i was going to show you in order to meet your professor's (irrational, IMO) demands was something like this:   myfunc (a,b,c) = myfunc $ case undefined of _ | p -> (a',b',c') | q -> (a'',b'',c'') | r -> (a''',b''',c''')
14:35:01 <augur> meet for me means in person
14:35:02 <augur> :P
14:35:03 <augur> ok im off
14:35:05 <dankna> yeah, fair enough
14:35:07 <dankna> okay
14:35:11 <drhodes> ezyang: your ocaml for haskellers post is #14 on hackernews.  
14:35:12 <ski>   (ol,nl,nh,oh,f)
14:35:16 <ski>     | p <= head old_high && flag == -1 = (old_low,new_low,(head old_high): new_high,(tail old_high),-1)
14:35:18 <ski>     | p > head old_high && flag == -1 = (old_low,(head old_high): new_low,new_high,tail old_high,1)
14:35:18 <jmcarthur> that would mean the tail call is only in one place
14:35:22 <ezyang> drhodes: \o/ 
14:35:32 <jmcarthur> ski's suggestion is also good
14:35:37 * chrisdb hasn't heard of typed feature structures
14:35:55 <jmcarthur> actually i like ski's better
14:35:57 <ezyang> It's really hard to predict what the HN crowd will like. 
14:35:58 <ski> bayyak : note how in the first case `nl' will be `new_low', but in the second case, it will be `(head old_high): new_low'
14:36:08 <dankna> chrisdb: they are basically just records, but for linguists
14:36:23 <ski> bayyak : so you're "changing" different parts of the five things in the tuple, in each case
14:36:41 <ski> bayyak : in your new paste you forgot to change the correct parts
14:36:47 <chrisdb> danka: I've been making a little language interpreter for applying sound changes. You can define symbols as (groups of) phones with specific features and then specify your changes in terms of those features.
14:36:57 <dankna> oh fascinating!
14:37:12 <bayyak> ski, ok i kind of got it, but where do i plate the laast call ?
14:37:49 <chrisdb> I did it once before in python, but that worked by translating everything into regexes on strings. Downside: hard to debug and understand, which made me unhappy.
14:37:54 <dankna> yes indeed
14:38:01 <ski> bayyak : also, i had said `| p <= head old_high && flag == -1 = (ol,nl,...)' while i should have said `| p <= head old_high && flag == -1 = (old_low,new_low,...)'  .. if you miss this, you will get problems (recursive binding)
14:38:06 <chrisdb> So this time I've wrote the whole thing to work directly with an internal representation of what phones look like.
14:38:07 <ski> bayyak : same as in your last paste
14:38:13 <chrisdb> *written
14:38:53 * dankna nods
14:39:28 <ski> bayyak : note that `(a,b) = (1,2)' is the same as `a = 1' followed by `b = 2'
14:39:35 <ski> so
14:39:40 <ski>   (ol,nl,nh,oh,f)
14:39:49 <ski>     | p <= head old_high && flag == -1 = (old_low,new_low,(head old_high): new_high,(tail old_high),-1)
14:39:56 <ski> in this first case, this is the same as
14:40:08 <ski>   (ol,nl,nh,oh,f) = (old_low,new_low,(head old_high): new_high,(tail old_high),-1)
14:40:10 <koninkje> chrisdb: you mean like Phone {voiced :: Bool ; front :: Bool ;...} ?
14:40:12 <ski> which is then the same as
14:40:16 <ski>   ol = old_low
14:40:21 <ski>   nl = new_low
14:40:27 <ski>   nh = (head old_high): new_high
14:40:33 <ski>   oh = (tail old_high)
14:40:36 <ski>   f = -1
14:40:51 <ski> but that is only done if `p <= head old_high && flag == -1' is true
14:40:54 <koninkje> chrisdb: In any case, I'd love to see it whenever you're finished :)
14:41:04 <ski> in the other cases, other of those five will be "changed"
14:41:10 <ski> bayyak : do you understand ?
14:41:34 <bayyak> ski, u're awesome ! .. it works now
14:41:47 <chrisdb> koninkje: well, kindof. But my little language doesn't hard code in the set of features, it interprets a file that defines them at runtime. So the internal representation is to map all feature and value names to Ints into sorted association lists.
14:42:05 <chrisdb> And then I've written my own backtracking matcher which works with features, values etc.
14:42:23 <chrisdb> Instead of translating to strings like I did last time.
14:42:33 <chrisdb> Downside: I can't hope to match a tuned regex engine.
14:42:45 <chrisdb> But I've found performance is acceptable for the size of problem I have.
14:42:49 <koninkje> Sure, I was just meaning the basic idea of using feature structs (as opposed to atomic phone/phoneme units)
14:43:08 <dankna> where I'm coming from is actually text generation
14:43:24 <ski> bayyak : btw, in `newfunc', you can remove *all* brackets, except those for the tuples, and those around `n-1'
14:43:28 <chrisdb> Yes. :) Phones are not atomic.
14:43:34 <chrisdb> They are bundles of feature value pairs.
14:43:39 <koninkje> If you need an efficient intern table for strings, I have one handy
14:43:41 <ski> > 0 == -1
14:43:42 <lambdabot>   False
14:43:44 <dankna> another component of the program generates a parse tree of natural-language text; and then I transform it into the text it represents
14:43:53 <koninkje> not yet published, as I'm pending on releasing the rest of the project
14:43:54 * ski was expecting to need brackets there ..
14:44:03 <dankna> the typed feature structure is how the parse tree is represented
14:44:13 <dankna> so that sorta explains what they are, I guess
14:45:01 <dankna> a wrinkle is that, unlike a record, they are allowed to have variables as the fields, and if the same variable occurs in two places those values have to be the same
14:45:12 <dankna> so they're useful for describing grammatical rules, as well
14:45:16 <chrisdb> koninkje: thanks. I think I'm OK at the moment... I'm sure some things could be a lot faster, but so far I've not hit a problem with performance. My test samples tend to contain, say, 1000 words of 1 - 30 phones, and for simple sound changes it can execute the lot in about a second.
14:45:22 <chrisdb> dankna: That sounds cool.
14:45:30 <dankna> it is :)
14:46:16 <koninkje> dankna: AVMs are fun. Have you looked into the AG stuff at UU? Seems like some of it could be crossapplied to your AVMS
14:46:25 <koninkje> s/AVMS/AVMs/
14:47:00 <dankna> I have not - do you have a link?
14:47:09 <chrisdb> I have to hold my hand up to being more of a functionalist / typologist (well, as a hobby). Every now and then I dip my toe into the more formalist side, but...
14:47:17 <chrisdb> so far I've not managed to maintain interest.
14:47:29 <ski> bayyak : oh, and in the last paste, you had `flag == -1' everywhere .. you want `1' in some places, i think
14:47:47 <ski> bayyak : but i think you should use `True' and `False', instead of `1' and `-1'
14:47:50 <koninkje> chrisdb: http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem
14:48:23 <dankna> chrisdb: oh that's fair, certainly.  I don't think of myself as particularly formalist, but I suppose I am really, with the caveat that linguistics is of course my hobby and not my profession.
14:48:32 <ski> AGs rock !
14:49:11 <dankna> koninkje: thanks, this looks applicable indeed
14:49:19 <youngbull> anyone else use yi here?
14:50:01 <Cale> @bot
14:50:01 <lambdabot> :)
14:50:03 <chrisdb> koninkje: thanks. I should really use more of that kind of stuff... I've written a few operations on my little AST that I could probably define better if I bothered to just define map-like functions on it.
14:50:17 <chrisdb> But it's pretty small, so there's not too much duplication.
14:50:42 <koninkje> also http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter
14:51:37 <koninkje> Now in @where ag and @where agmatters, for reference
14:52:49 <ski> @where AG
14:52:49 <lambdabot> http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem
14:53:01 <chrisdb> youngbull: Is yi good?
14:53:04 <koninkje> You may also be interested in checking out gf
14:53:09 <chrisdb> I've been using EclipseFP
14:53:12 <chrisdb> recently.
14:53:14 <ski> @where GF
14:53:14 <lambdabot> http://www.cs.chalmers.se/~aarne/GF/
14:53:28 <koninkje> @where+ gf http://www.grammaticalframework.org/
14:53:28 <lambdabot> I will never forget.
14:53:45 <ski> good, the old link was broken
14:54:13 <aristid> @where GF
14:54:13 <lambdabot> http://www.grammaticalframework.org/
14:54:17 <aristid> yay
14:54:20 * ski often finds it a problem to recall the good `where's in lambdabot
14:54:21 <chrisdb> I think the EclipseFP plugin might leak memory though...
14:54:24 <aristid> it's not case-sensitive :)
14:54:33 <chrisdb> after a while I start getting error messages, which I didn't have before.
14:55:07 <chrisdb> In Eclipse, I mean.
14:55:11 * koninkje usually things to google before @whereing
14:55:23 * koninkje s/things/thinks/
14:55:37 <youngbull> chrisdb: not bad I must say!
14:56:15 <youngbull> chrisdb: I mean, it's not an IDE, but it defenetly a step up as a textEditor
14:56:46 <youngbull> chrisdb: *definitely*
14:57:46 <chrisdb> I've tried Leksah too.
14:57:49 <chrisdb> Have you tried it?
14:58:42 <hpc> i tried it on windows and couldn't even get it to run :(
14:59:20 <youngbull> chrisdb: yea, it was ok when I tried it about 6 months ago, but writing everything in a cabal package inside a workspace became too much for me...
15:00:12 <youngbull> Besides, I never could figure out how to lookup function definitions...
15:00:31 <chrisdb> I made the mistake of trying to install it from cabal. I had quite a few problems getting it working to start off too.
15:00:36 <youngbull> chrisdb: in yi, you can use hoogle...
15:01:01 <chrisdb> hoogle is cool. :) I love finding the function you want just by guessing its type signature.
15:02:28 <aristid> when it works, yeah
15:03:16 <youngbull> yea, that always blows my mind. Have you ever noticed that usually knowing the type gives you enough information about how the function works?
15:03:17 <chrisdb> There's also Hayoo...
15:03:49 <hpc> lol, yahoo
15:03:59 <chrisdb> http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:04:25 <ski> @where hayoo
15:04:26 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:04:41 <youngbull>  @where hoogle
15:04:54 <ski> @where hoogle
15:04:54 <lambdabot> http://haskell.org/hoogle
15:11:28 <Fadazinha> could someone help me with deepseq, lazy evaluation?
15:12:00 <ezyang> Fadazinha: Don't ask if we can help, ask your question. 
15:12:36 <hpc> also, don't ask if /someone/ can help
15:12:41 <hpc> because it might not be someone here ;)
15:15:42 <Veinor> suppose that I have two versions of an api call function, one of which uses authentication (and therefore requires a parameter for the auth token)
15:16:01 <Veinor> do I use, say, foo for the un-auth'd version, and foo' for the auth'd version?
15:16:47 <dankna> personally I would not do that, as there are too many things that foo' could mean
15:16:53 <dankna> it could mean "internal helper for foo", say
15:16:53 <Veinor> true
15:17:10 <Veinor> so... authFoo and foo?
15:17:14 <dankna> I lean towards long names in general, so I would consider foo and secureFoo (or fooSecure if you prefer)
15:17:23 <Veinor> makes sense
15:17:26 * dankna nods
15:17:29 <benmachine> fooWithAuth
15:17:46 <Veinor> (the context here is twitter; you can get someone's timeline unauthenticated, but you need auth if their timeline is protected)
15:17:59 * ski . o O ( `M-/' )
15:18:01 <dankna> see, I don't like prepositions in function names if they can be avoided, because then there's always that uncertainty when trying to remember what you called it
15:18:15 <dankna> as many prepositions can be used interchangeably much of the time
15:18:31 <Veinor> I agree with dankna here
15:18:39 <sipa1024> just make it a (Maybe AuthData)
15:18:49 <dankna> actually, what sipa said
15:18:56 <ski> possibly the return type is different
15:19:11 <Veinor> return type isn't different
15:19:13 <benmachine> also if the common use case is Nothing it's kind of a hassle to say that all the time
15:19:19 <sipa1024> true
15:19:34 <Veinor> also, I really need to do exception handling sometime
15:20:10 <ddarius> Clearly it should be foo and unsafeFoo.
15:20:18 <Veinor> haha
15:20:28 <Veinor> @pl \x -> x
15:20:28 <lambdabot> id
15:20:30 <Veinor> yay!
15:20:49 <c_wraith> @pl \x -> 1 + x * x + 1
15:20:49 <lambdabot> (2 +) . join (*)
15:21:01 <ski> @botcrack
15:21:01 <lambdabot> :)
15:21:31 <c_wraith> yeah, that translation is horribly wrong over the fully polymorphism of "1" :)
15:22:16 <ski> isn't `(+)' supposed to be associative and commutative ?
15:22:23 <ski> and `2 = 1 + 1' ?
15:22:26 <benmachine> ski: it depends who you ask
15:22:33 <benmachine> the docs for Prelude say nothing
15:22:45 <benmachine> ski: but, say, Expr, is not either
15:22:53 <ski> well, `Expr' is bad
15:23:04 <benmachine> it's not bad, it's neat :P
15:23:11 <ski> well, that too :)
15:23:18 <ski> like `trace'
15:23:18 <benmachine> ok I guess they aren't exclusive
15:24:09 * benmachine wonders if anyone made an instance Num (Q Exp) with x + y = [| $x + $y |] or something
15:24:35 <benmachine> (possibly [| x + y |], not sure)
15:25:53 <Veinor> lol, right now if you do something wrong or twitter gives me an error
15:25:58 <vakosel> hi all! 100% new to haskell but not generally in programming.. Any ide recommedation is wlc :)
15:26:00 <Veinor> I get a non-exhaustive lambda as an error
15:26:07 <Veinor> vakosel: I use emacs
15:26:32 <vakosel> Veinor: there is haskell mode i believe 
15:26:37 <ski> yes
15:26:54 <vakosel> cool
15:27:10 <Veinor> yeah, haskell-mode works
15:28:42 <ski> vakosel : when you have questions about Haskell, be sure to ask here
15:28:50 <ski> (maybe you already have some ?)
15:29:42 <Fadazinha> When typing in winghci   *Main> let !mapasort =  rnf $ map  sort  [[23,45,3],[3,4,5]]  I do not understand why I get * Main> mapasort ()
15:29:47 <mee> vakosel: my 2c: buy a copy of Real World Haskell and read the "Gentle Introduction"
15:29:48 <vakosel> ski: not yes . I was a C and python fun till now. but things change. i am totally new to functional programming
15:29:57 <ski> ok
15:30:21 <EvanR-work> a c and python fan?
15:30:35 <aristid> > inits "abc"
15:30:35 <EvanR-work> funtil
15:30:35 <lambdabot>   ["","a","ab","abc"]
15:30:47 <aristid> > tails "abc"
15:30:48 <lambdabot>   ["abc","bc","c",""]
15:30:54 <vakosel> i am amazed with the activity of this community
15:30:55 <vakosel> EvanR-work: yes 
15:30:59 <vakosel> fan
15:31:02 <aristid> i think inits and tails return one element too many
15:31:13 <youngbull> vakosel: There are ofcourse other possibilities, there is leksah. And frankly most of the time I just my text editor of choice and a seperate terminal with GHCI...
15:31:14 <EvanR-work> vakosel: its one of the highest throughput channels
15:31:25 <benmachine> aristid: why
15:31:28 <ski> EvanR-work : "fan" <http://upload.wikimedia.org/wikipedia/commons/4/4e/Joy_Axial_Variable_Pitch_Fan.JPG>
15:31:57 <EvanR-work> thats a giant jpeg
15:32:02 <vakosel> EvanR-work: i noticed that 
15:32:04 <aristid> benmachine: because zipWith (++) <$> tails <*> inits returns an additional element as is
15:32:16 <aristid> > zipWith (++) <$> tails <*> inits $ "abc"
15:32:17 <lambdabot>   ["abc","bca","cab","abc"]
15:32:19 <vakosel> youngbull: i think this is the best option
15:32:33 <pumpkin> > init . zipWith (++) <$> tails <*> inits $ "abc"
15:32:33 <ski> "this" being ?
15:32:33 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
15:32:34 <benmachine> aristid: hmm
15:32:36 <benmachine> > inits []
15:32:37 <lambdabot>   [[]]
15:32:43 <pumpkin> > (init .) . zipWith (++) <$> tails <*> inits $ "abc"
15:32:44 <lambdabot>   ["abc","bca","cab"]
15:32:47 <pumpkin> zomg
15:32:50 <benmachine> aristid: you'd have that return []?
15:32:58 <benmachine> > inits [()]
15:32:59 <lambdabot>   [[],[()]]
15:33:01 <aristid> benmachine: yes
15:33:05 <pumpkin> ick
15:33:07 <aristid> > tails []
15:33:08 <lambdabot>   [[]]
15:33:10 <youngbull> vakosel: oh, and then there is eclipseFP...
15:33:30 <benmachine> aristid: that seems reasonable, since [] is not really an "init" of []
15:33:48 <benmachine> > init [()]
15:33:48 <lambdabot>   []
15:33:59 <aristid> > init []
15:33:59 <vakosel> mee: i saw that this is the gold standard , i mean real world haskell
15:34:00 <lambdabot>   *Exception: Prelude.init: empty list
15:34:05 <pumpkin> benmachine: it's an init of everything
15:34:09 <ski> > [] : (init . tails =<< tail (inits "abcd"))
15:34:10 <lambdabot>   ["","a","ab","b","abc","bc","c","abcd","bcd","cd","d"]
15:34:27 <benmachine> pumpkin: depends how you look at it. it's not the result of init applied some number of times
15:34:36 <Veinor> hm.
15:34:39 <pumpkin> :t init . tails <=< tail . inits
15:34:40 <lambdabot> forall a. [a] -> [[a]]
15:34:41 <aristid> zipWith (++) <$> tails <*> inits WOULD be such a beautiful permutations functions
15:34:45 <pumpkin> that's quite nicely symmetric
15:34:50 <aristid> ROTATIONS i mean
15:34:55 <pumpkin> > (init . tails <=< tail . inits) "moo"
15:34:55 <lambdabot>   ["m","mo","o","moo","oo","o"]
15:34:57 <aristid> if it were not for the dirty additional element
15:35:06 <Veinor> general API design: if my functions could fail to return a useful value because the thing that the caller is trying to get at doesn't exist, should I have all my functions return a Maybe Whatever?
15:35:19 <vakosel> youngbull: isnt this choice too heavy??
15:35:22 <ski> maybe there should be `inits1' and `tails1' functions ?
15:35:41 <Veinor> (e.g., Maybe Timeline which is Nothing if you try to get the timeline of a non-existant user)
15:35:51 <ezyang> Veinor: It depends. 
15:35:57 <Veinor> on?
15:35:59 <benmachine> ski: by analogy with foldr1 et al you'd expect those to demand a non-empty list but they don't afaict
15:35:59 <youngbull> eclipseFP ? yea, frankly I find an IDE to heavy for most of the things I do...
15:36:05 <ezyang> Maybe is good when there is only one possible way to fail. 
15:36:18 <ezyang> complex functions can fail in multiple ways, in which case Maybe is not very appropriate. 
15:36:29 <benmachine> Veinor: I wouldn't be shy of returning a lot of Maybes, since haskell has so many ways to glue them together
15:36:46 <Veinor> true... there are at least three different ways to fail in this case. no such entity, you don't have authorization to get that entity, or twitter is just being unresponsive
15:36:51 <ski> benmachine : well, since the computation is already (list-)nondeterministic, we can just return empty list in case of empty input
15:36:56 <youngbull> vakosel: well, atleast in Haskell, any other language IDE's becomes crucial.
15:37:10 <ski> > foldr1 (+) []
15:37:11 <lambdabot>   *Exception: Prelude.foldr1: empty list
15:37:34 <Veinor> I feel like that last one should use exceptions, though, since it's like trying to read from a closed file or what have you
15:37:42 <benmachine> ski: but we don't do that for e.g. tail
15:37:57 <ski> benmachine : but `tail' is not nondeterministic
15:38:11 <ski> we could use `Maybe', of course
15:38:32 <ski> but in case of `inits', and `tails', the list-nondeterminism is already there
15:38:45 <Veinor> so... two ways to fail here. no such entity, and so your question is meaningless, or you don't have the necessary privileges to get at that thing
15:38:49 <benmachine> ski: I just think the '1' suffix is inconsistent with other similar usages
15:38:59 <ezyang> In that case, use something besides Maybe. 
15:38:59 <ski> benmachine : you're possibly right
15:39:03 * ski isn't sure
15:39:22 <Veinor> ezyang: suggestions?
15:39:34 <benmachine> Veinor: well, Either is a fairly simple solution
15:39:40 <benmachine> Either OhNo Result
15:39:43 <ezyang> Exceptions >:-) 
15:39:46 <Veinor> haha
15:39:51 <ezyang> Cause it seems like your doing IO anyway. 
15:39:59 <ski> `Either' is exceptions
15:39:59 <Veinor> exceptions are for "haha, twitter is fail whaling" in my opinion
15:40:12 <benmachine> Veinor: that sounds reasonable
15:40:13 <mee> vakosel: yes, it's a very good book. Although I see now you were looking for "ide recommendations", not "idle recommendations" of which mine was one. Oops. To that question: I use Emacs with haskell-mode and think it's worth trying for a while.
15:40:40 <ski> (s/is/*is*/)
15:40:59 <Veinor> Either Failed Result, where data Failed = DoesNotExist | Forbidden
15:42:05 <vakosel_> mee: thank you a lot . i will follow your advice. I like emacs anyway
15:42:46 <Veinor> now... do I reuse the same value for a general 'that thing you want doesn't exist', or do I explicitly differentiate users not existing vs other things not existing
15:43:01 <blackdog> vakosel_: i also recommend ghc-mod for emacs - gives you some of the IDE experience for emacs (on-the-fly syntax checking etc)
15:43:29 <ezyang> re conal: holy cow that's a lot of ways to add numbers :-) 
15:43:30 <benmachine> Veinor: it doesn't sound like it would be much extra effort, so why not
15:43:36 <Veinor> fair enough
15:44:04 <ski> ezyang : ?
15:44:15 <ezyang> http://conal.net/blog/posts/adding-numbers/ 
15:44:42 <vakosel_> blackdog: haskell- mode and ghc mod . cool
15:44:59 <Veinor> now I need to name things!
15:45:05 <conal> ezyang: :) .  sometimes when i get started, i have a hard time stopping.
15:45:20 <vakosel_> also to intoduce myself  i am from Greece, Athens
15:45:45 <Veinor> also, now I remember what I was going to do. I was going to learn about iteratees :O
15:46:07 <blackdog> Veinor: just take it a bit at a time, you'll be fine
15:46:38 * blackdog will be here all week, try the veal
15:47:04 <Veinor> ohohoho
15:47:22 <blackdog> Veinor: are you ready for more?
15:47:30 <blackdog> ok, ok. i'll stop now.
15:47:40 <Veinor> :P
15:48:52 <Veinor> also, I'm really liking the new hackage
15:50:09 <ski> vakosel_ : ok, Sweden here
15:51:59 <ezyang> conal: I always thought backwards state was comonadic. Maybe I can find the sigfpe post. 
15:52:21 <conal> ezyang: that'd be cool.  please let me know if you find the post.
15:52:49 <vakosel_> ski: nice ! i was in Kiel last year for 6 mo. 
15:53:27 <lispy> Keal?
15:53:29 <lispy> ?keal
15:53:29 <lambdabot> oh btw my fpu is blown due to a hardcased failsafe i have 3 year warranty right. and then they call fads
15:53:36 <romand> hi guys; I have problem with happy+alex trivial parser; where should I paste the code (120 lines)?
15:53:41 <vakosel_> Kiel / Germany
15:53:53 <lispy> vakosel_: sorry, just teasing
15:54:20 <Veinor> romand: pastebin
15:54:25 <vakosel_> lispy: no p my friend
15:54:46 <lispy> ?keal
15:54:46 <lambdabot> someone needs to write a boids for haskell that emulates humans going on and off topic
15:54:49 <ezyang> nope, I can't find it. I guess I misremembered. 
15:54:54 <lispy> ?kiel
15:54:54 <lambdabot> Maybe you meant: keal kind
15:56:21 * ski wants to represent naturals as a direct limit `((...) ~> d) ~> d', where `Nat ~> d' is the direct limit `((...) * d) * d' (`d' being the base)
15:56:45 <ski> (so `Nat ~> d' is the functions from `Nat' to `d' with finite support)
15:56:45 <Veinor> I think it'd help if there was a guide on how to use Iteratee somewhere :I
15:57:02 <blackdog> Veinor: i think there's a tute on yesodweb
15:57:03 <ezyang> there are a bunch of iteratee tutorials 
15:57:06 <ezyang> which package are you using? 
15:57:19 <Veinor> Data.Iteratee
15:57:31 <ezyang> eheh. 
15:57:36 <Veinor> should I use a different one?
15:57:38 <romand> http://hpaste.org/40886/happyalex_problem
15:57:41 <ezyang> In that case, I recommend Oleg's slides. 
15:57:44 <koninkje> Veinor: the problematic thing is there are a bunch of tutorials, but they're all implementation agnostic
15:58:01 <romand> test.hs outputs: Ok "\r\n"
15:58:16 <romand> instead of string from 'sample'
15:58:21 <koninkje> Veinor: also beware, iteratee < 0.4 is entirely different than iteratee >= 0.4
15:58:37 <Veinor> hm
15:59:04 <koninkje> John Lato finally gave into the pressure to use standard names (in iteratee >- 0.4)
15:59:15 <Veinor> I think I'll do something else instead
15:59:33 <koninkje> (Though iteratees are awesome, once you figure out how to use them)
15:59:49 <ski> (standard names ?)
16:00:15 <conal> i wonder if iteratees will ever get a semantics and an un-leaky interface.
16:00:24 <koninkje> E.g., "Iteratee" "Enumerator" "Enumeratee", instead of "IteratorG" "EnumeratorN" Enumerator GM EnumeratorGMM
16:01:25 <wires> Hi, how come I get the following? cabal: dependencies conflict: ghc-6.12.3 requires directory ==1.0.1.1 however
16:01:26 <wires> directory-1.0.1.1 was excluded because ghc-6.12.3 requires directory ==1.0.1.2 (when running cabal install agda)
16:01:33 <koninkje> Just adding the G is fine, but the other ones confuse the discussion about enumerators and enumeratees
16:01:35 <ski> (argh !)
16:01:40 <wires> wow sorry about that bold or what it was?
16:01:50 <Veinor> if/when I figure out iteratees, I'll write an implementation-specific post about it
16:01:51 <ski> it was in reverse video, here
16:01:51 <monochrom> colouring
16:01:59 <pumpkin> was italic here
16:02:03 <wires> that was weird :)
16:02:09 <Veinor> pumpkin: you're not using a monospace font? :O
16:02:14 <wires> atleast I got your attention :)
16:02:20 <koninkje> wires: it means "add directory to your build-depends:"
16:02:22 <pumpkin> Veinor: hell no, I use a GUI IRC client
16:02:32 <Veinor> weirdo
16:02:36 * koninkje also got reverse video
16:02:51 <ski> well, there are GUI clients which properly display monowidth font
16:02:52 <wires> koninkje: and what does that mean? .. i know nothing about cabal
16:03:07 <benmachine> conal: my understanding was the more natural and less leaky interface didn't perform as well; I reckon it'd still be nice to see it released though
16:03:38 <wires> koninkje: build-depends: is some field in the agda package?
16:03:47 <benmachine> wires: it sounds to me like you installed a newer version of directory, but ghc wants to use the older one
16:03:48 <koninkje> wires: go to your foo.cabal and add the line "build-depends: directory" (sans quotes)
16:04:02 <conal> benmachine: i guess no one has figured out how to have both a non-leaky interface *and* an efficient implementation.
16:04:04 <benmachine> wires: installing newer versions of ghc's dependencies is a bad idea because ghc can't be rebuilt against them easily
16:04:07 <koninkje> unless you mean you're getting problems installing someone else's package
16:04:21 <wires> koninkje: someone elses' package (agda)
16:04:27 <conal> i wonder who's tried.
16:04:34 <benmachine> conal: well, efficiency is a relative term, I'm sure the non-leaky version wouldn't be unusable
16:04:36 <orlandu63> >- 0.4)                                          ??? _nickel
16:04:46 <ski> (argh, even though i know the above is reverse video, i have a hard time resisting clicking, to make the "selected text" disappear ..)
16:04:52 <koninkje> conal: is there a good summary of the leakages?
16:04:53 <wires> benmachine, koninkje: can i downgrade directory?
16:05:02 <blackdog> ski: it'll scroll off in a second. i had the same urge.
16:05:09 <wires> and would that help?
16:05:12 <benmachine> wires: possibly. do ghc-pkg list directory and see if it was installed locally or globally
16:05:13 <conal> sad for haskellers (especially) to give up on solid abstraction in order to get performance.  rather than biting the bullet and figuring out how to have both.
16:05:19 <pumpkin> conal: I quite like the Free ((->) r) view of them, although that doesn't really correspond to them à la oleg
16:05:20 <benmachine> (or hpaste the output if you can't work it out)
16:05:38 <wires> ski: lol I did the same thing ;-)
16:06:04 <conal> koninkje: no summary i know of.  there was a thread back in august.
16:07:02 <wires> benmachine: http://hpaste.org/40887/ghcpkg_output
16:07:02 <benmachine> http://www.haskell.org/pipermail/haskell-cafe/2010-August/082324.html this one, you mean
16:07:05 <koninkje> conal: I remember the thread, just not the specifics (or namely, the specifics not resolved then)
16:07:06 <benmachine> that's a long thread :o
16:07:22 <benmachine> wires: that's not what I said :P
16:07:26 <itemState> hi there
16:07:30 <benmachine> wires: ghc-pkg list directory
16:07:31 <wires> benmachine: ahh
16:08:04 <conal> i was thinking of this thread: http://www.haskell.org/pipermail/haskell-cafe/2010-August/082533.html
16:08:08 <itemState> hey, i'm trying to translate some haskell code and stumble over some syntax probs.
16:08:24 <benmachine> oh right, yes
16:08:36 <itemState> could anyone tell me what the period means in this expression : fst . split p
16:08:42 <pumpkin> conal: well, the Free monad view of them would make them into trees
16:08:48 <ski> itemState : function composition
16:08:50 <pumpkin> conal: not sure how "meaningful" that is to you though
16:09:06 <itemState> hmmm
16:09:22 <ski> itemState : `f . g' is the function such that `(f . g)(x)' is `f(g(x))', in math syntax
16:09:23 <conal> pumpkin: it's not.  "Free" & "denotational" are at opposite ends of a spectrum.
16:09:26 <ski> @src (.)
16:09:26 <lambdabot> (f . g) x = f (g x)
16:09:26 <lambdabot> NB: In lambdabot,  (.) = fmap
16:09:34 <pumpkin> conal: ah, I see, sorry
16:09:35 <romand> hi, can anybody help with http://hpaste.org/40886/happyalex_problem ?
16:09:42 <conal> pumpkin: :)
16:09:47 <conal> pumpkin: np
16:10:01 <conal> if one takes a denotational approach to design, these leaky abstractions won't arise.
16:10:05 <itemState> ok, so basically if split takes two arguments, split p is curried and then the outer function takes the second element of the resulting tuple2, right?
16:10:18 <ski> itemState : so `fst . split p' is the function that will call `split p' on its input, then call `fst' on the result of that, returning that resulting value
16:10:39 <itemState> exactly, thanks a bunch!
16:10:57 <ski> itemState : well, the first element, since it is `fst'
16:11:04 <itemState> oops, of course
16:11:10 <ski> itemState : what are you trying to translate Haskell into ?
16:11:38 <itemState> Scala (i hope that doesn't count as blasphemy >) it's my current language of choice
16:11:47 <kmc> haha
16:11:57 <kmc> i think most people here have a lot of respect for Scala
16:12:01 <itemState> i just learned haskell today. i must say the learning curve was really nice
16:12:06 <kmc> haha really?
16:12:08 <ski> i'm not sure whether Scala has a function composition function in its libs
16:12:18 <kmc> fyi, you're the first person in the history of the world to say that Haskell has a nice learning curve
16:12:26 <itemState> haskell is way cleaner for expressing algorithms it occurs to me, the scala code is much more verbose
16:12:31 <wires> benmachine: http://hpaste.org/40887/ghcpkg_output so can I unregister a specific version?
16:12:45 <Funktorsalat> kmc: itemState may have meant it in the sense of 'challenge' ;)
16:12:55 <koninkje> wires: ghc-pkg unregister foo
16:12:59 <kmc> hehe
16:13:00 <Funktorsalat> (apparently not)
16:13:04 <pumpkin> kmc: those of us who enjoy it tend not to bitch about it :P
16:13:22 <blackdog> kmc: i don't think the learning curve's that bad. you can get something to play with in haskell quicker than you can in C++ or Java
16:13:23 <koninkje> wires: or, occasionally, cabal unregister foo
16:13:28 <blackdog> it's just that it keeps going up... :)
16:13:40 <wires> thanks
16:13:49 <kmc> yeah
16:13:58 <itemState> no, it was rather easy. but only now. i remember i looked at it long time ago (trying to understand some scientific papers). now that i have a bit of experience with FP from Scala (and SuperCollider and LISP), it is not so difficult to grasp.
16:13:59 <rndm> blackdog: that's post learning-curve
16:14:10 <pumpkin> rndm: I enjoyed it greatly as I was learning it
16:14:15 <pumpkin> well, I still am :)
16:14:22 <blackdog> rndm: there is no post learning-curve with haskell
16:14:28 <itemState> now ocaml is more difficult to read >)
16:14:32 <blackdog> when you get that good at it you go hack agda or coq or something
16:14:51 <pumpkin> hacking coq reminds me of a certain pain olympics video
16:15:03 <kmc> ugh thanks pumpkin
16:15:05 <pumpkin> that I'd advise against googling
16:15:15 <ski> itemState : what is difficult about OCaml syntax ?
16:15:58 <pumpkin> kmc: sorry :(
16:15:59 <itemState> just unfamilar i guess.... i read today the haskell for C programmers tutorial in half an hour, and i could understand most of the stuff in the FingerTree paper from Hinze / Paterson
16:16:08 <kmc> i don't think ocaml syntax is difficult, just noisier and harder to read
16:16:29 <ski> OCaml's `function' is nice
16:16:29 <itemState> so, well done that tutorial
16:16:30 <kmc> though i've been reading the SML examples in Okasaki's book more or less fluently
16:16:34 <ski> (basically `\case')
16:16:39 <kmc> yeah
16:16:47 <kmc> anyone write a preprocessor for \case in Haskell yet?
16:17:17 <ezyang> kmc: Yes! 
16:17:23 <ski> .. and the `as' in types is nice to play with
16:17:27 <ezyang> well, it's actually a GHC patch 
16:17:41 <pumpkin>  \case ?
16:17:48 <ski> (`-rectypes' ftw !)
16:18:13 <ski> pumpkin : `\case of ...' instead of `\whatever -> case whatever -> ...'
16:18:20 <pumpkin> oh I see
16:18:31 <pumpkin> the patch by BSP, right?
16:18:39 <ski> s/-> .../of .../
16:18:51 <ezyang> pumpkin: Yeah, I think so. 
16:19:01 <pumpkin> I wish he'd come on IRC more often :P
16:19:07 <pumpkin> preflex: seen batterseapower
16:19:07 <preflex>  Sorry, I haven't seen batterseapower
16:19:15 <pumpkin> I spotted him in #ghc once
16:20:24 <kmc> cool ezyang
16:21:52 <romand> does some kind of maillist for happy exist?
16:22:25 <Veinor> hm... Twitter a = IO (Either TwitterError a) or Twitter = Either TwitterError a
16:23:03 <Veinor> the former leads to a lot of Either TwitterError a in non-IO-y part, but the latter leads to IO (Twitter a)
16:23:11 <Adamant> Twitter should always throw an Error
16:23:14 <kmc> what about ErrorT TwitterError IO a
16:23:16 <Adamant> </snark>
16:23:27 <kmc> or just use exceptions in IO
16:23:39 <Veinor> kmc: that's also a possibility
16:24:45 <Veinor> but the idea that I had was that exceptions would be for 'twitter is failwhaling', but 'you asked for a user that doesn't exist' wouldn't be an exception
16:25:19 <pumpkin> why use exceptions at all
16:25:24 <pumpkin> if you have nicer errors
16:25:25 <pumpkin> :P
16:25:43 <Veinor> true :P
16:25:47 <ski> `Either TwitterError' is exceptions
16:25:55 <pumpkin> ski: I mean IO exceptions, then
16:25:59 <blackdog> Veinor: 500 and 404 :)
16:26:04 <pumpkin> mm_freak_: also, did you ever provide benchmarks for your fancy cont stuff?
16:26:15 <pumpkin> oh yeah
16:26:18 <pumpkin> ErrorT Int IO a
16:26:23 <Veinor> haha
16:26:28 <Veinor> I might use ErrorT
16:26:49 * ski has used `Either [Integer]' as a monad
16:27:10 <mm_freak_> pumpkin: not really…  i did some benchmarks on specific monads and found at least ChoiceT to be noticably faster than []
16:27:50 <pumpkin> mm_freak_: I think people would be a lot more inclined to use it if you took some existing uses of the monad transformers, passed them through criterion on your library and the standard ones, and showed how much faster yours is
16:27:55 <pumpkin> but just a suggestion :P
16:27:59 <kmc> Veinor, the separation makes some sense, but it also means your users have to deal with errors in two separate ways
16:28:16 <kmc> mm_freak_, you encoded some transformers using CPS?
16:28:26 <kmc> is this anything like edwardk's monad-ran lib?
16:28:33 <Veinor> kmc: true
16:28:33 <mm_freak_> pumpkin: i wrote the library mainly for my own purposes, but found that others may find it useful, too
16:28:49 <mm_freak_> kmc: i encoded most of the usual tranformers using CPS
16:28:54 <mm_freak_> kmc: see the 'contstuff' package
16:28:57 <kmc> cool
16:29:05 <kmc> do you have any issues with loss of sharing?
16:29:24 <mm_freak_> kmc: not primarily for speed, though most of them were at least as fast as the standard versions
16:29:30 <kmc> ok
16:29:36 <mm_freak_> kmc: no, but the CPS-based monads are less lazy
16:29:48 <mm_freak_> (which appeared to be an advantage most of the time)
16:30:02 <pumpkin> monad-ran is kind of mind-bending :)
16:30:20 <mm_freak_> monad-ran doesn't provide additional flexibility, just additional speed
16:30:21 <pumpkin> I'd be interested in seeing criterion on that too
16:30:23 <Veinor> hah, if there's no net connection then serviceRequest just returns an empty response
16:30:23 <pumpkin> yeah
16:30:26 <Veinor> which isn't the worst thing
16:30:29 <mm_freak_> mine provide both
16:30:35 <pumpkin> preflex: seen edwardk
16:30:35 <preflex>  edwardk was last seen on #haskell 13 hours, 42 minutes and 53 seconds ago, saying: gave a talk answering questions about haskell and tried to systematically work my way through the list of the other attendees ;)
16:31:48 <Veinor> so... TwitterError is UserNotFound | StatusNotFound | AccessForbidden | ConnectionFailed or something
16:32:10 <mm_freak_> also in my package there are some monads, which monad-ran can't encode the way i did
16:32:17 <mm_freak_> for example MaybeT and EitherT
16:32:24 <mm_freak_> which use two continuations
16:32:46 <mm_freak_> also ChoiceT is implemented using a CPS-based left fold, which monad-ran also can't really encode
16:33:17 <pumpkin> Veinor: | FailWhale
16:33:35 <Veinor> yeah :P
16:34:18 <Veinor> making api decisions is hard!
16:36:13 <pumpkin> mm_freak_: that just makes me want to see performance comparisons even more :P
16:36:20 <pumpkin> I could quit bitching and run them myself, I guess
16:36:42 <mm_freak_> pumpkin: i've run only ChoiceT vs. [] tests
16:37:13 <mm_freak_> ChoiceT is up to two times faster than [], even if you extract only a partial result
16:37:47 <pumpkin> cool
16:38:25 * ski . o O ( `instance Enum TwitterError where fromEnum AccessForbidden = 500; ...' )
16:38:40 <pumpkin> succ AccessForbidden
16:38:58 <pumpkin> NotImplemented ?
16:39:08 <ski> hehe
16:39:54 <ski> mm_freak_ : `ChoiceT' being defined, how ?
16:40:30 <mm_freak_> ski: newtype ChoiceT r i m a = ChoiceT { getChoiceT :: (i -> a -> (i -> m r) -> m r) -> i -> (i -> m r) -> m r }
16:40:40 <ski> "CPS-based left fold" ?
16:40:55 <mm_freak_> looks a bit scary, but you don't have to bother with this a lot
16:41:13 <mm_freak_> there are convenient functions like 'findFirst' and 'findAll' as well as 'listChoiceT' and 'maybeChoiceT'
16:41:23 <mm_freak_> maybeChoiceT :: Applicative m => ChoiceT (Maybe a) (Maybe a) m a -> m (Maybe a)
16:41:38 * hackagebot yices 0.0.0.8 - Haskell programming interface to Yices SMT solver  http://hackage.haskell.org/package/yices-0.0.0.8 (KiYungAhn)
16:42:21 <Veinor> hm. handling errors without IO exceptions complicates the types, but makes them simpler to deal with, IMO...
16:43:18 <ski> it looks like `Cont (i -> ContT m r i) a'
16:43:44 <ski> @unmtl Cont (i -> ContT m r i) a
16:43:44 <lambdabot> (a -> i -> ContT m r i) -> i -> ContT m r i
16:43:50 <ski> bah
16:44:00 <mm_freak_> ski: simple left fold would be:  (r -> a -> r) -> r -> Choice r a -> r
16:44:18 <mm_freak_> CPS-based left fold is:  (r -> a -> (r -> r) -> r) -> r -> Choice r a -> (r -> r) -> r
16:44:38 <ski> except more general, no ?
16:44:44 <mm_freak_> the CPS-variant allows me to fetch only the first result without having to traverse the entire list
16:44:58 <mm_freak_> or more generally abort anywhere in the fold
16:45:59 <ski> hm .. you mean it is like a CPS-version of `newtype List m a = L (m (Cell m a)); data Cell m a = Empty | Cons a (List m a)' ?
16:46:35 <ski> .. at least in that you can decide to walk one more step, performing more `m'-effects
16:47:02 <ddarius> data Tree a = Branch (Tree a) a (Tree a) | Tip
16:47:09 <mm_freak_> ski: i'm not sure i understand the difference between that and the straightforward list definition
16:47:45 <ski> mm_freak_ : well, in `m [a]', the `m' is "bulky", you either get all or nothing
16:47:59 <ski> in `List m a', you get pieces of `m', one for each element
16:48:10 <mm_freak_> ah, i see
16:48:15 <mm_freak_> well, yes
16:48:38 <ski> ddarius : yes ?
16:49:43 <ddarius> The days are too short here.  It might get to the point where I cease seeing the sun.
16:50:42 <ski> are you near a polar ?
16:50:50 <ski> polar circle, i.e.
16:51:05 <ddarius> Not really.
16:53:52 <Veinor> ETOOMANYOPTIONS
16:54:12 <ddarius> EOUTOFERRORCODES
16:54:31 <centrinia> EPICFAIL?
16:55:14 <Veinor> haha
16:55:19 <ddarius> Your computer is probably pretty fubared if the PIC(s) fails.
16:55:27 <centrinia> Indeed.
16:56:27 <Veinor> I think... I'll just use Either
16:56:51 <mm_freak_> all your RTS are belong to us
16:57:26 <toothbrush0> /quit/quit
16:57:27 <Veinor> either or errort. argh.
16:58:10 <Veinor> make my decisions for me, #haskell!
16:58:56 <mm_freak_> Veinor: EitherT
17:00:33 <Veinor> :P
17:02:20 <mm_freak_> Veinor: wasn't supposed to be a joke actually
17:03:03 <Veinor> ah
17:07:11 <Veinor> EitherT looks like it might be not bad, actually
17:07:58 <Veinor> though I might try ErrorT first
17:18:26 * Veinor flails
17:18:38 <ezyang> Flailing builds character. 
17:25:23 <Adamant> also builds flailing form
17:26:51 <kmc> not quite a Haskell question, but some of you might know:
17:27:06 <kmc> when using pandoc in literate Haskell Markdown mode
17:27:10 <kmc> how can i make a block quote?
17:27:32 <kmc> the '>' prefix stands for Haskell source, while Markdown uses it for quotes ordinarily
17:29:35 <kmc> ah, seems i can start a line with ' >'
17:50:34 <Veinor> bah, using EitherT makes my code not as pretty
17:54:11 <Polarina> Why are you using EitherT to begin with?
17:54:45 <Veinor> not sure, exactly
17:54:51 <Veinor> to do error handling
17:55:44 <Veinor> I'm thinking maybe I should just use exceptions
17:56:21 <Polarina> Well, what are you performing error handling on?
17:57:00 <Veinor> well, I'm writing a twitter API, and I need to handle what happens if the user asks me to find something that doesn't exist, or that they don't have access to
17:57:14 <Satch> I'm just reading learnyouahaskell (noob here). Seems an unnecessary limitation that you can't overload equality operators to compare different types
17:57:48 <Veinor> Satch: how would you do that given the type system?
17:58:17 <ddarius> Satch: You could make an equality operator that took different types, but why would you want to?
17:58:41 * Veinor scraps the EitherT code
17:58:56 <Satch> I'm not sure, just coming from a c# viewpoint
17:59:18 <ddarius> Satch: That makes even less sense.
17:59:59 <Satch> Its my oo thinking, probably not helpful whilst learning haskell
18:00:17 <Polarina> Satch, two different types can be considered "incompatible" with each other. Haskell does not know what to do with them when you use them together. That's why you need to tell it how to interpret one type as another.
18:00:42 <rndm> Satch: any function taking a type a and b and returning a bool should do
18:01:28 <rndm> i.e. define one that returns true when two things are equal and then use it in place of equality
18:01:30 <Satch> Ill have a play, thanks
18:01:48 <Veinor> Polarina: so... I'm thinking I might just rewrite it to use Control.Exception instead
18:01:58 <Satch> Yup, as opposed to operator overloading
18:02:15 <Polarina> Veinor, that might work as well. :)
18:02:27 <rndm> Satch: what are you calling an operator?
18:02:46 <Polarina> Veinor, you can make your own lift functions, so that you do not have to type out lift . lift . lift, etc.
18:03:02 <Polarina> Veinor, and you already got liftIO. :)
18:03:25 <Veinor> true
18:03:39 <rndm> Satch: in haskell these are all just functions
18:03:58 <Veinor> error handling is hard!
18:04:00 <Polarina> Satch, you will find it much easier to learn haskell when you try not to relate it with the mess of the imperative languages.
18:04:16 <enthropy> you can have  class Eq2 a b where eq2 :: a -> b -> Bool
18:04:25 <Satch> On mobile atm. Yes its my thinking
18:05:00 <Satch> Point taken
18:05:02 <sipa1024> enthropy: if you use MPTC, which wasn't available when Eq got into Prelude, i suppose
18:05:46 <alpounet> Veinor, there's ErrorT too iirc
18:06:12 <Veinor> yeah, but that doesn't seem to be nicer
18:07:28 <enthropy> but more independent type variables will get you into more cases needing type annotations
18:07:42 <kmc> Satch, you could implement «(Typeable a, Typeable b, Eq a) => a -> b -> Bool»
18:07:59 <kmc> from the existing Eq, without any new class
18:08:00 <kmc> it's rare that you'd want that, though
18:08:21 <ddarius> MPTCs are still non-standard, but had they been there Eq would still look the same as it does now.
18:08:24 <enthropy> kmc: you'd really do it using runtime type checking?
18:08:32 <kmc> i'm just saying you could...
18:08:56 <enthropy> kmc: instead of a multiparameter typeclass
18:09:11 <kmc> :t \x y -> maybe False (==x) $ cast y
18:09:12 <lambdabot> forall a a1. (Eq a, Typeable a1, Typeable a) => a -> a1 -> Bool
18:09:41 <enthropy> you would have a list of acceptable conversions to try too
18:10:03 <ddarius> kmc, sanely, has the empty list.
18:10:14 <kmc> what?
18:10:29 <kmc> no conversions!
18:10:44 <kmc> that way lies madness and Perl and C++
18:11:09 <kmc> @let x === y -> maybe False (==x) $ cast y
18:11:09 <lambdabot>   Parse error: RightArrow
18:11:14 <kmc> @let x === y = maybe False (==x) $ cast y
18:11:15 <lambdabot>  Defined.
18:11:17 <kmc> > 3 === 3
18:11:18 <lambdabot>   True
18:11:19 <kmc> > 3 === 4
18:11:20 <lambdabot>   False
18:11:20 <kmc> > 3 === 'x'
18:11:21 <lambdabot>   False
18:11:28 <kmc> > 3 === Just 3
18:11:30 <lambdabot>   False
18:11:31 <ddarius> > 3 === "3"
18:11:32 <lambdabot>   False
18:11:48 <kmc> that is the Correct Answer
18:12:03 <pumpkin> omg no
18:12:04 <kmc> people say that Python is Perl with nicer syntax
18:12:08 <pumpkin> clearly they're both 3
18:12:12 <kmc> but Python agrees that 3 == "3" is False
18:12:58 <pumpkin> > 3 === "三"
18:12:59 <lambdabot>   False
18:13:03 <pumpkin> wtf that's wrong
18:13:06 <kmc> i can't understand how anyone thought that implementing a sea of renegade ever-shifting types could possibly allow the programmer to ignore types
18:13:29 <ddarius> kmc: It just Does What You Mean, man.
18:13:34 <kmc> yeah
18:13:45 <enthropy> kmc: do you like +.  ?
18:13:59 <koninkje> Does anyone know why openFd would hang on opening a fifo?
18:14:04 <kmc> i meant that my program's argument processing should stop at the argument "0" because i used for (@ARGV) { ... }
18:14:15 <kmc> koninkje, because nobody opened the other end yet?
18:14:23 <kmc> enthropy, in OCaml?
18:14:27 <enthropy> yes
18:14:38 <kmc> i think it's unavoidable in a vanilla H-M language
18:14:40 <koninkje> kmc: it'd hang just to get the fd, not even to read?
18:14:46 <kmc> koninkje, i'm not sure
18:14:53 <kmc> you could strace 'cat' to see
18:14:59 * koninkje checks
18:15:11 <kmc> i'd much rather have + and +. than some ad-hoc hack for overloading
18:15:25 <enthropy> they have that too
18:15:26 <kmc> type classes are elegant and general enough that i don't count them as an ad-hoc hack
18:15:36 <kmc> but i could understand if someone did
18:15:58 <koninkje> nope, looks like it's still hanging when someone's reading from it
18:18:32 <koninkje> doh, they should've been writing to that one.
18:18:42 <koninkje> yep, looks like that's the problem. foo.
18:21:32 <koninkje> makes sense I suppose. But still
18:24:52 <koninkje> sc
18:31:00 <Lambdanaut> Hi, I want to write a server for a game. Should I go with happstack for this? 
18:31:46 <Lambdanaut> or is that more of an http thing?
18:32:38 <c_wraith> happstack is very http-oriented
18:32:49 <c_wraith> however, depending on the game, http might be a fine transport.
18:32:57 <c_wraith> It might also be horrible :)
18:33:29 <Lambdanaut> I'm looking for something sorta like python's twisted
18:34:55 <blackdog> Lambdanaut: is your aim to handle many clients concurrently, then?
18:35:03 <blackdog> snap is quite good there
18:35:03 <Lambdanaut> yes!
18:35:17 <blackdog> last test i did, it was a bit slower than node.js, but comparable
18:35:34 <Lambdanaut> though it's not browser-based and doesn't necessarily need httpy. 
18:35:37 <blackdog> the nice bit is that you can program in a normal, threaded sort of way
18:35:51 <blackdog> but it acts as if it were evented
18:36:12 <Veinor> argh, no matter what I do this is going to suck
18:37:02 <Lambdanaut> I'll try out snap for it. 
18:37:07 <Veinor> I can't do all the error handling in parseTimeline because I want to differentiate "user not found" errors from "status id not found" errors
18:37:22 <Veinor> and I can't do it all in the callers because I want to get at the error message :/
18:38:07 <alpounet> you might as well just start here Lambdanaut http://haskell.org/haskellwiki/Simple_Servers#Basic_concurrent_server
18:38:52 <alpounet> or even better, that page's 4)
18:38:54 <augur> lambdanaut!
18:39:35 <Lambdanaut> I'd be better off writing it using sockets? 
18:40:13 <blackdog> Lambdanaut: i doubt it
18:40:26 <blackdog> it might b e marginally faster if you handtune it that way, but it seems unlikely
18:40:41 <Lambdanaut> it sounds easier personally
18:40:57 <Lambdanaut> but only because I've never fooled with a framework before
18:41:53 <blackdog> ok, rewind. what do you want to do?
18:42:16 <Lambdanaut> make a server for a multiplayer game
18:42:27 <Lambdanaut> not browser based
18:42:43 <Lambdanaut> nevermind though, this looks good
18:42:59 <Lambdanaut> I'm going to try with sockets
18:46:10 <MiggyX> Seems to me, that with the move to machines with continually more cores, functional programming ( and hence Haskell ) is going to become very important
18:47:09 <blackh> MiggyX: I agree. I also think people don't know how much of a problem they've got yet. :)
18:48:47 <MiggyX> blackh: I use C mostly, but even with simple concurrency like two CPU's, getting it right is still very much hit and miss
18:50:39 <blackh> MiggyX: I think purity is a necessary part of a sensible approach to parallelism.
18:50:56 <MiggyX> Yeah, you need to be able to make certain assumptions I think
18:51:43 <blackh> I'm quite interested in the subject and can bang on about it at length. :)
18:52:08 <MiggyX> I wish my Haskell were good enough to let me do that. I know my current approach is going to be horribly limited, but I still need to get my head around Haskell :)
18:52:34 <MiggyX> Just emailed Tilera to find out if I can code for their 100 core CPU cards in Haskell :)
18:53:06 <blackh> MiggyX: To go from C to Haskell takes a bit of work, but I think you will find that everything you learn is worth learning for its own sake. (Though we're all biased here.)
18:53:41 <MiggyX> biased isn't always bad :)
18:54:00 <kmc> in an article i make the claim that "lazy IO is semantically dubious"
18:54:03 <kmc> anyone have a good link for that?
18:55:04 <monochrom> I don't know of a good link for that, but perhaps something written by Oleg.
18:55:31 <monochrom> Most Oleg articles on iteratee begins with bashing lazy I/O. :)
18:55:57 <MiggyX> blackh: I'm hoping to use Haskell for finance and number crunching. At present C rules because it seems to be the fastest, but I'm not convinced that it will stay that  way - a bit like the myth that all hand crafted assembler is faster than C
18:56:52 <kmc> you can also write your numerical core in C (or hand-crafted assembler!) and call it from Haskell
18:57:11 <kmc> my experience in high-frequency finance is that some code definitely couldn't be in Haskell, but it was a small percentage of any app by weight
18:57:17 <blackh> MiggyX: The current situation is language implementations fall into three groups - The slow ones (Ruby, Python, etc) - the compiled ones (C#, Java, Haskell...) and the fast ones - C and C++.
18:57:35 <kmc> regardless of what program you're writing, 99% of your code will be boring glue and probably not in the critical path
18:57:43 <kmc> using a proper high level language there, rather than C or C++, is a huge win
18:57:48 <kmc> and Haskell's FFI is pretty easy
18:58:16 <MiggyX> problem is, with finance, microseconds often matter
18:58:30 <kmc> yep
18:58:44 <kmc> in HF you care about latency much more than computational throughput
18:58:59 <kmc> so garbage collector pauses in Haskell or Java will kill you, even if the overall speed is good
18:59:05 <blackh> MiggyX: For real stuff, Haskell (=GHC) is still a bit slower than C# and Java, but the gap is closing.
18:59:21 <wires> koninkje_away, benmachine : thanks for your help earlier on. My installation was properly messed up, just reinstalled everything, now it's all good.
18:59:33 <kmc> so put your strategy code in a realtime C thread, and your config / management / risk / parameter calc / etc. in a Haskell thread
18:59:50 <blackh> MiggyX: It is easy to glue C and Haskell together, though.
18:59:56 <kmc> a lot of strategies have a HF component which trades according to some longer-term parameters, which might be coming even from MATLAB or Excel
19:00:01 <kmc> they certainly could come from Haskell
19:00:22 <blackh> MiggyX: There are all sorts of brilliant ideas for speeding up Haskell that aren't actually practical now.
19:00:25 <MiggyX> blackh: slower than Java? :/
19:00:27 <kmc> reduceron!
19:00:37 <kmc> MiggyX, depends how you write your code
19:00:41 <blackh> MiggyX: Slightly slower than Java, but Java is not slow.
19:00:47 <kmc> high level concise beautiful Haskell might be slow
19:00:52 <kmc> but it will take you 10% as long to write as Java
19:00:54 <kmc> once you're an expert
19:01:01 <kmc> then, you have time left over to optimize the parts which need optimization
19:02:11 <MiggyX> blackh: true but the perception is there - I might not be able to convince people to give Haskell a shot at the high speed stuff, but I was hoping it shouldn't be too hard to trump Java :)
19:02:18 <kmc> http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=ghc&lang2=java
19:02:30 * hackagebot twidge 1.0.6 - Unix Command-Line Twitter and Identica Client  http://hackage.haskell.org/package/twidge-1.0.6 (JohnGoerzen)
19:02:32 <kmc> note in particular the "haskell used 1/10 memory"
19:02:40 <kmc> that will matter, with garbage collection pauses
19:02:56 <blackh> MiggyX: The idea that Java is slow seems to be very persistent. :)  (Not that I have any particular desire to defend Java.)
19:04:11 <MiggyX> Not that I'll be able to write decent Haskell code for years - but at least I'll have a head start on everyone else :D
19:04:15 <blackh> MiggyX: Haskell hasn't reached its potential with regard to speed yet.
19:04:20 <blackh> But it's pretty fast all the same.
19:05:04 <blackh> MiggyX: It took me about four months of doing Haskell in the evenings after work before I could write code about the same speed as I could in Java.
19:05:13 <blackh> Now I can write Haskell much faster than I can write Java.
19:05:40 * ski . o O ( `class Eq1 f where eq1 :: f i -> f j -> Maybe (Equal i j)' )
19:05:50 <blackh> MiggyX: Haskell is not actually difficult - it's just very different, so it appears difficult.
19:05:56 <MiggyX> blackh: at least some of the simple stuff makes sense now :)
19:05:57 <kmc> eh
19:06:00 <MiggyX> very different is right lol
19:06:04 <kmc> i think some parts of it are legitimately objectively difficult
19:06:27 <blackh> kmc, actually you're right
19:06:34 <ddarius> kmc: Mutable state is legitimately, objectively difficult.
19:06:37 <blackh> I put laziness into that category.
19:07:55 <kmc> yeah
19:08:02 <kmc> performance in the presence of laziness and persistence is difficult
19:08:07 <kmc> source: okasaki
19:08:10 <kmc> @quote ChrisOkasaki
19:08:11 <lambdabot> ChrisOkasaki says: Historically, the most common technique for analyzing lazy programs has been to pretend that they are actually strict.
19:08:14 <blackh> I don't think Haskell is the most difficult or the easiest language.
19:08:17 <kmc> however, you do get something in exchange
19:08:27 <kmc> yeah, Haskell is easier than C++ or Perl, which have way more arbitrary rules to memorize
19:08:42 <ski> @where WhyFP
19:08:42 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
19:09:18 <monochrom> I'm wonder, for people with programming day jobs, if the schedule (every day, do day job, then do haskell in evening) is worse than (for every 4-5 consecutive days, do day job and spill over into evening, but in exchange get a day off and do haskell whole day)
19:09:25 <blackh> kmc: My take on it is that most of Haskell's features are a huge benefit for very little cost, whereas laziness is fairly large benefit for a fairly large cost.
19:09:25 <monochrom> s/wondering/wonder/
19:09:35 <kmc> yeah
19:09:47 <kmc> well half of the "revolutionary" features in Haskell are common-sense good ideas that have been known for 40+ years
19:09:54 <kmc> but just never made it into the industrial mainstream
19:10:15 <MiggyX> common sense is undervalued imho
19:10:18 <kmc> it's not like algebraic data, first-class functions, or nestable multi-line comments are big ideological commitments
19:10:45 <ddarius> monochrom: I just do day job and omit the rest.
19:11:00 <blackh> Type classes are relatively complex but they pay enormous dividends.
19:12:29 <MiggyX> from a very untrained eye, typeclasses are somewhat akin to objects on steroids 
19:12:40 <kmc> it's worth noting that Okasaki chooses a strict language, but then introduces laziness in order to have amortized performance bounds even in the presence of persistence
19:12:46 <ddarius> monochrom: However, when I was in tech school, we had down days.  You would "work" (which for the students meant "go to class") an extra hour each day, but you'd have every other Friday off.  The schedule technically leads to the same or even more hours working, but nevertheless, it's awesome.
19:12:53 <kmc> and persistence is well-justified by concurrency
19:13:07 <ddarius> MiggyX: They are nothing like objects.
19:13:09 <kmc> see clojure, which has side effects and mostly strict evaluation, but emphasizes persistence
19:13:39 <kmc> so (well-controlled) laziness is useful for getting good performance out of functional programs
19:13:46 <kmc> though showing this is, well, someone's PhD thesis
19:14:07 <MiggyX> ddarius: classes then
19:14:14 <ddarius> MiggyX: Nope.
19:14:27 <kmc> type classes are more like Java interfaces
19:14:31 <kmc> but they're not much like those either
19:14:37 <kmc> just learn them as they are
19:14:49 <kmc> you can also see type classes as a system of implicit parameters
19:14:59 <MiggyX> ddarius: ah well, I did say untrained ;)  it just looks like they're a great way for looking at data in a flexible and fluid way
19:15:07 <MiggyX> which actually now I write it like that does not sound at all like objects or classes lol
19:15:13 <kmc> data OrdDict a = OrdDict { compare :: a -> a -> Ordering }
19:15:18 <kmc> now when you write (Ord a) => a -> b
19:15:22 <kmc> you can imagine OrdDict a -> a -> b
19:15:47 <kmc> so they're like implicit parameters
19:16:50 <blackh> MiggyX: Here's something I noticed when I shifted from OO languages to Haskell:  Good OO code tends to have more classes, so even though you're throwing out some unnecessary code as you go, it still gets bigger and bigger as the design improves.  Functional code shrinks down to nothing as it gets cleaner.
19:17:17 <dolio> Nah, they're like refinement kinds. :)
19:17:26 <kmc> blackh, i think that has more to do with popular OO languages (C++, Java) having pitifully weak abstraction
19:17:32 <kmc> and not much to do with the paradigm of OO itself
19:17:40 <kmc> in Python or Javascript or Smalltalk, you might not observe the same phenomenon
19:17:42 <blackh> I'm sure you're right.  I am talking about C++ and Java.
19:17:58 <kmc> if you are talking about C++, you are by definition not talking about "good OO code"
19:18:04 <dolio> Obviously we pass types to all polymorphic functions, so class constraints just refine the usual kinds for those types.
19:18:15 <dolio> And then when we call class functions, we do type case.
19:18:49 <monochrom> type class is like elephant
19:19:32 <kmc> type classes are like burrito
19:19:36 <ddarius> kmc: You haven't looked at the Smalltalk collection classes...
19:19:46 <kmc> nope, i've never used smalltalk
19:21:09 <chrisf> compared to c++, smalltalk is pretty sane ;)
19:21:17 <kmc> where a Java programmer would introduce an entire class, a C# programmer can use a single-line lambda expression
19:21:26 <kmc> and Java and C# are not too different in their conceptual foundations
19:21:31 <kmc> they're about equally "OOP languages"
19:21:58 <kmc> it's just that C# carried its foundations through to the logical conclusion, while Java is crippled to pander to some committee's idea of an "average programmer", which ends up being a least common denominator
19:22:48 <pumpkin> isn't the least common denominator always 1?
19:22:49 * ddarius would not describe C# as a language that "carried its foundations through to the logical conclusion."
19:22:58 <chrisf> "where a Java programmer would introduce a whole hierarchy of classes, a C# programmer will write a single-line expression involving multiple lambdas and higher-order functions"
19:23:06 <ddarius> pumpkin: No.
19:23:19 <monochrom> 0
19:23:35 * hackagebot twidge 1.0.6.1 - Unix Command-Line Twitter and Identica Client  http://hackage.haskell.org/package/twidge-1.0.6.1 (JohnGoerzen)
19:23:39 <pumpkin> greatest common divisor, least common multiple
19:23:58 <pumpkin> I guess multiple = denominator
19:24:02 <kmc> right
19:24:08 <kmc> it's about putting fractions into the same form
19:24:14 <kmc> anyway "lowest common denominator" is an english idiom
19:24:23 <pumpkin> yeah, I know :) was just being thick
19:24:34 <kmc> mathematical pedantry?!?
19:24:37 <kmc> in #haskell??!?!?!?
19:24:58 <monochrom> 0 is the least common denominator, in order to get you x/0 = ∞ for most x's. Like Einstein says, only stupidity and the universe are infinite, and he is not sure about the universe.
19:26:48 <ddarius> Last I checked, -1 was less than 0.
19:27:02 <monochrom> doesn't get you as much stupidity
19:27:31 <monochrom> just remember: least common denominator, maximum stupidity
19:27:47 <monochrom> they are galois-connected!
19:31:29 <roconnor> ddarius: the relative ordering of negative numbers has a complicated history
19:33:21 <pumpkin> roconnor: you suggesting it might have changed since he last checked?
19:33:54 <roconnor> pumpkin: it has changed in the past
19:33:58 <roconnor> you never know
19:34:15 <roconnor> pumpkin: pluto isn't a planet anymore
19:34:21 <roconnor> you never know
19:35:54 <roconnor> pumpkin: maybe ddarius last checked 300 years ago
19:36:04 <kmc> ddarius, are you Enoch Root?
19:36:16 <monochrom> you may enjoy http://groups.google.com/group/alt.algebra.help/msg/13e2bca9d0b23854
19:37:15 * roconnor doesn't enjoy needing to register with google to read that :(
19:37:42 <monochrom> I didn't know that! let me try.
19:38:45 <ddarius> roconnor: Do you have a gmail account?  I ask because, in the past, I've had issues where I'd be timed out of my gmail and would need to log in to Google Groups even though if I logged out of gmail, I could anonymously connect to Google Groups.
19:38:56 <ddarius> It was really fucking annoying.
19:39:24 <roconnor> ddarius: ya I could be logged in
19:39:45 <roconnor> ddarius: logging out did it
19:39:50 <roconnor> wow, that really sucks
19:41:40 <monochrom> ok resolved
19:43:44 <monochrom> no wonder all software works 100% of the time for me. I don't use gmail, that's why.
19:44:46 <roconnor> For me it wasn't gmail, but google finance
19:44:50 <roconnor> but same difference
20:22:05 <roconnor> after writing some generic code, I'm starting to see why people like untyped langauges
20:25:58 <tmo_> Suppose you defined a type that could be either a [Char] or Num.
20:26:18 <roconnor> Either [Char] Integer
20:26:48 <tmo_> Is there a function that can check if a variable of that type is a [char] or Integer?
20:28:24 <blackh> tmo_: You have to write it yourself using pattern matching.
20:28:27 <danderson> you can use a case statement to deconstruct and pattern-match
20:28:27 <Zao> class IsCool a where isCool _ = false; instane IsCool String where isCool _ = true; instance IsCool Integer where ...
20:28:38 <Zao> Oh, missed the either bit, heh.
20:28:54 <danderson> I was going to say that Data.Either has helpers too, but I'm wrong.
20:28:58 <tmo_> I wasn't aware you could pattern match with types, but that seems to be extremely useful.
20:29:41 <blackh> tmo_: You can pattern match with types using type functions. Is that what you want to do?
20:29:44 <roconnor> tmo_: um, it is just regular pattern matching
20:29:50 <danderson> tmo_: I suggest reading http://book.realworldhaskell.org/ as an introduction to Haskell (which includes pattern matching)
20:30:04 <danderson> or alternatively LYAH: http://learnyouahaskell.com/
20:30:53 <Zao> case mah_value of { Left theString = ...; Right theInteger = ... }
20:45:51 <jmcarthur> :t isLeft -- not sure if this exists
20:45:52 <lambdabot> Not in scope: `isLeft'
20:45:59 <jmcarthur> same. isJust exists
20:46:01 <jmcarthur> *shame
20:46:09 <pumpkin> yeah, I'd expect it to
20:46:17 <Funktorsalat> Graphics.SOE isLeft :: Event -> Bool
20:46:17 <Funktorsalat> Lambdabot.Util isLeft :: Either a b -> Bool
20:46:17 <Funktorsalat> Text.IMAPParsers isLeft :: Either a b -> Bool
20:46:17 <Funktorsalat> Agda.Utils.Either isLeft :: Either a b -> Bool
20:46:19 <Funktorsalat> hehe
20:46:40 <Funktorsalat> oh. nvm the first
20:48:01 <Funktorsalat> bonus points for writing it with gfoldl.
20:50:22 <Funktorsalat> @let isLeft = (==4) . length . toConstr
20:50:22 <lambdabot>  <local>:7:26:
20:50:23 <lambdabot>      Couldn't match expected type `[a]' against inferred type ...
20:50:31 <Funktorsalat> @let isLeft = (==4) . length . show . toConstr
20:50:33 <lambdabot>  Defined.
20:50:45 <Funktorsalat> > isLeft (Left 1 :: Either Int Int)
20:50:46 <lambdabot>   True
20:50:52 <Eduard_Munteanu> Hi.
20:50:57 <Funktorsalat> > isLeft (Right 1 :: Either Int Int)
20:50:58 <lambdabot>   False
20:52:07 <Funktorsalat> > isLeft "wraaa"
20:52:08 <lambdabot>   False
20:57:39 <Maxdamantus> http://www.lunarregistry.com/
20:58:09 <Maxdamantus> er, wrong channel :\
21:00:56 <Eduard_Munteanu> That's a bit outrageous...
21:01:06 * Eduard_Munteanu goes lay a claim and homestead Alpha Centauri.
21:01:12 <Funktorsalat> seems like a good deal.
21:01:14 <Funktorsalat> ;)
21:03:28 <Maxdamantus> Apparently the same guy claimed the Moon and all planets in the Solar system
21:03:35 * Maxdamantus wonders if he took the Sun too
21:04:17 <Gracenotes> what about moons of other planets. those are prime real estate.
21:04:41 <Maxdamantus> He sells land on the Moon, Mars, and Io
21:04:47 <Eduard_Munteanu> :))
21:05:12 <Gracenotes> navigating the ocean without electronic equipment? that'll be $10 to use the moons of jupiter thank you
21:05:27 <Gracenotes> oh Io
21:05:46 <Maxdamantus> Io is a moon of Jupiter
21:05:59 <Eduard_Munteanu> Sounds unsafe :P
21:06:01 <Maxdamantus> Wait, or is it Saturn?
21:06:02 <Gracenotes> yeah, anticipated
21:06:12 <Gracenotes> nope. saturn has rings, who cares about its moons
21:06:17 <Maxdamantus> No, Jupiter
21:06:28 <Maxdamantus> Saturn has some pretty big moons too though
21:06:40 <Maxdamantus> it has the second largest I think, after Io
21:06:57 <Funktorsalat> "The K2LX Project will involve establishing permanent human-based settlements on the Moon by 2015"
21:07:14 <Funktorsalat> text not updated in a while? ;)
21:07:41 <Maxdamantus> Yeah, Titan, second largest moon
21:14:19 <Eduard_Munteanu> I remember reading on Wikipedia recently that they're planning to send some sort of bacteria to a moon.
21:19:35 <Gracenotes> at which point it'll starve of resources?
21:20:31 <Gracenotes> well.. maybe some extremophiles could make it.. but it would have to be a pretty extreme extremophile
21:21:06 <maurer_> Hey, is there any way I can find out what line of code is generating an exception?
21:21:35 <blackh> maurer_: Actually, there is.  It actually can be done with ghci.
21:21:45 <Gracenotes> well, if you call head [], the line of code that's generating the exception is the 'head' function from within GHC
21:21:57 <maurer_> blackh: I was guessing so. I have the execution loaded in ghci. What do I do?
21:22:00 <Gracenotes> otherwise, you need stack traces :)
21:22:05 <kmc> hi maurer_
21:22:09 <kmc> -fbreak-on-exception i think?
21:22:15 <maurer_> kmc: OK, trying.
21:22:54 <blackh> maurer_: Unfortunately I don't remember the details, but I've seen it done.  There's another way using profiling cost centres - build with profiling, then run with +RTS -xc
21:23:04 <blackh> It's a bit rudimentary, but it can often work.
21:24:11 <maurer_> blackh: That doesn't sound like what I want--I'm trying to figure out which of n different Array.! invocations is causing an index out of range.
21:24:15 <Eduard_Munteanu> Mmm, is anyone aware of any codo sugar implemented for Haskell? Google seems to mess things up by correcting it to "code".
21:24:21 <maurer_> kmc: That causes a break, but :list doesn't give me the line of code...
21:24:53 <Gracenotes> try +codo
21:25:04 <blackh> maurer_: If you add cost centres to them using {-# SCC "something" #-}, you can do it if you run with +RTS -xc
21:25:36 <Gracenotes> but er I don't even know what that is
21:25:51 <Eduard_Munteanu> Ah, I only find a discussion by sigfpe on that, I've already read it.
21:26:04 <blackh> maurer_: That's only necessary if there are many in the same function. Otherwise -auto-all will tell you what function.
21:26:06 <Eduard_Munteanu> Gracenotes: the do-notation for comonads.
21:26:45 <maurer_> blackh: I already know it's restricted to this one function, but a bunch of array accesses are done. If I have to annotate manually, I might as well just replace with a safe! function.
21:27:23 <blackh> I don't know any better way than that.
21:27:40 <Gracenotes> syntactical sugar requires more of an excursion into the lexer than most people could probably make..
21:28:15 <Gracenotes> at least without becoming ghc experts <tm>
21:28:23 <Eduard_Munteanu> Heh. I see your point.
21:28:44 <Gracenotes> so <- becomes extend?
21:28:57 <ivanm> I'm currently working on a Text variant of wl-pprint; is there any point in having something analogous to the displayS or the displayIO functions or can I just avoid the whole SimpleDoc type and just have the rendering functions return a (lazy) Text value?
21:29:16 <ivanm> tibbe: are you responsible for Data.Text.Lazy.Builder?
21:29:34 <tibbe> ivanm: yes
21:29:47 <Eduard_Munteanu> Gracenotes: uh, I'm not yet used to edwardk's notations. I rather think in terms of (=>>), I think that was it.
21:29:48 <ivanm> so are Builder values meant to be concatenated using the Monoid instance?
21:29:55 <tibbe> ivanm: yes
21:30:01 <tibbe> ivanm: I should really improve the docs
21:30:02 <Eduard_Munteanu> Gracenotes: I assume it's still a chaining of lambdas using (=>>)
21:30:04 <ivanm> good-o; took me a while to figure that out though :p
21:30:06 <ivanm> tibbe: yeah ;)
21:30:23 <tibbe> ivanm: also, make sure you do so in a right-associative way e.g. a `mappend` (b `mappend` c)
21:30:36 <ivanm> *nod*
21:30:40 <tibbe> ivanm: otherwise performance will suffer
21:30:52 <ivanm> hmmm, is it possible to do an infixr on `mappend` just for builder values?
21:31:08 <Eduard_Munteanu> The difference would be you're taking a 'w a', processing it, and coreturning an 'a'.
21:31:26 <tibbe> ivanm: if the new <> monoid operator gets added you'll get that
21:31:31 <ivanm> cool
21:31:47 <tibbe> ivanm: you can define it locally for now
21:31:51 <ivanm> except that I'm writing a Text pretty-printer (well, adapting wl-pprint) and it has its own <> :s
21:32:00 <tibbe> ivanm: heh
21:32:59 * ivanm is currently debating whether to keep wl-pprint's SimpleDoc type, or to just have it render a Builder/Text value and then people can do IO/etc. from that
21:33:31 <Gracenotes> Eduard_Munteanu: well.. you only ever deal with 'w a', right.. you yield a 'b' value, and that value is decorated by the context of 'w a'
21:33:40 <ivanm> AFAICT, the reason wl-pprint has SimpleDoc is to let you avoid creating one big String when you're just going to be writing it to file, etc.
21:34:21 <Gracenotes> again a bit closer to edwardk's I guess
21:36:05 <Gracenotes> monads make lots more sense to me :|
21:37:34 <Eduard_Munteanu> Actually, seeing sigfpe's discussion, I think you'd still need some sort of monad to pack the initial 'w a' value for you.
21:38:23 <Eduard_Munteanu> Or to get it somewhere from IO.
21:39:01 <Eduard_Munteanu> (although the OI comonad idea has been put to rest)
21:41:29 <Eduard_Munteanu> But the comonad slogan is usually "it's unsafe to pack stuff into it", so :|
22:01:20 * hackagebot texmath 0.3.1.3 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.3.1.3 (JohnMacFarlane)
22:14:14 <MiggyX> mobile.internet.connections--
22:25:28 <ivanm> *sigh* isn't it great when you decide to remove/change large chunks of code thinking it isn't needed, then when you're almost finished you find out _why_ it was needed? :s
22:25:55 <Veinor> versino control!
22:26:16 <Rotaerk> versino... versus the neutrino!
22:26:39 <ivanm> no version control, because I only just started work on it
22:26:55 <MiggyX> ivanm: been there done that - usually goes with the scenario of "What a stupid way to do it, this can be done much easier with X!"   ::six hours later:: "Ah, that's why I did it that way...."
22:27:16 <ivanm> turns out that the SimpleDoc type is needed in wl-pprint if only for working out width/fitting :s
22:27:51 * ivanm might see if he can take pretty's rendering code so that infinite lines are possible
22:30:29 * hackagebot texmath 0.3.1.4 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.3.1.4 (JohnMacFarlane)
22:58:47 <Axman6> > sum . map (**(-3)) $ [1..100]
22:58:48 <lambdabot>   1.2020074006596781
22:58:53 <Axman6> > sum . map (**(-3)) $ [1..1000]
22:58:54 <lambdabot>   1.2020564036593433
22:59:04 <Axman6> > sum . map (**(-3)) $ [1..100000]
22:59:05 <lambdabot>   1.2020569031097323
23:08:18 <MiggyX> I wonder if Haskell related work would make a good research topic...
23:09:42 <Eduard_Munteanu> MiggyX: it does, Haskell gets a lot of love from research papers in CS.
23:10:32 <MiggyX> Eduard_Munteanu: I will have to look into it some more - see if I can come up with a topic that I can do :)
23:11:34 <Eduard_Munteanu> Just remember: just about any idea you might have, Oleg already did it! :P
23:12:19 <Axman6> but may not havew published, because he rthought it was too obvious
23:12:34 <MiggyX> Eduard_Munteanu: I suspect my work would be more along the lines of using it and comparing it to other languages for certain uses, rather than the low level stuff :)
23:23:00 <Eduard_Munteanu> For imperative computations with mutable variables, should I use IORefs/IOArrays, or is the State monad any better?
23:23:21 <Eduard_Munteanu> I'm considering it for numerical algorithms.
23:23:35 <Axman6> i;d use the ST monad, gives you real utable variables, but looks pure to the rest of your program
23:23:38 <Saizan> ST is more specific
23:24:15 <Eduard_Munteanu> Thanks, I'll have a try with ST then.
23:24:23 <kmc> State doesn't really give you mutable variables
23:24:31 <Axman6> ST is basically IO without the IO :P
23:24:32 <kmc> it's just sugar for very simple trick of passing your state around in function args
23:26:14 <Eduard_Munteanu> I see.
23:27:16 <Eduard_Munteanu> :t runST
23:27:17 <lambdabot> forall a. (forall s. ST s a) -> a
23:27:36 <Eduard_Munteanu> I wonder why the rank-2 type in there.
23:27:52 <Axman6> that's the magic that makes ST work
23:28:28 <Eduard_Munteanu> Uh, so that it's trapped inside the call.
23:28:49 <Axman6> @srrc ST
23:28:49 <lambdabot> newtype ST s a = ST (STRep s a)
23:29:00 <Axman6> @src STRep
23:29:00 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
23:29:06 <Axman6> @src IO
23:29:06 <lambdabot> Source not found.
23:29:20 <Axman6> bah, it used to be there
23:30:13 <Eduard_Munteanu> I assume that would've been valid without the rank-2 as well, but would have allowed s to be escaped outside, right?
23:30:37 <Eduard_Munteanu> like runSTunsafe :: ST s a -> a
23:30:40 <kmc> yes
23:30:50 <kmc> runST and unsafePerformIO have basically identical code
23:30:59 <Eduard_Munteanu> Oh, it makes sense.
23:31:13 <kmc> the safety of ST is entirely static
23:31:34 <kmc> @hoogle unsafePerformST
23:31:34 <lambdabot> No results found
23:32:00 <arcatan> unsafeOpenSafe
23:33:45 <lostman> I'm trying to get a memory profile of my program, but for some reason I only get the heap profile for the first 25% of execution time; what could be the reason?
23:34:40 <Eduard_Munteanu> I'm not sure I got around reasoning about rank 2 types. Can that be read as: forall a, there's an s depending on a, such that ST s a -> a?
23:34:51 <Eduard_Munteanu> like the forall s would be an existential?
23:35:40 <kmc> hmm, there is a correspondence Eduard_Munteanu
23:36:33 <kmc> ∃a. T a  ↔  ∀r. (∀a. T a → r) → r
23:36:39 <dolio> forall a. (forall s. ST s a) -> a is not the same as forall a. exists s. ST s a -> a
23:36:40 <kmc> this is a CPS transform
23:37:00 <kmc> but it doesn't precisely fit the type of runST
23:37:00 <dolio> Not in intuitionistic logic, at least, which is what we're dealing with here.
23:37:10 * MiggyX wonders if he'll ever understand that
23:37:22 <kmc> MiggyX, if you try, sure
23:37:27 <kmc> i can explain in more detail
23:37:34 <Veinor> bah, it looks like if I want to do something fancy like return what resource caused the NotFound or AccessForbidden error i'll have to do something fancy
23:38:06 <Maxdamantus> and doing something fancy means you have to do something fancy
23:38:55 <Eduard_Munteanu> kmc: I'm not sure that helps me read it as a theorem. If I first read (forall s. ST s a) as a proposition, then 'a' isn't quantified and doesn't really make sense.
23:38:58 <dolio> It's also important to maintain that separation, because the safety of ST depends on it.
23:39:14 <kmc> the theorem is ∀a. (∀s. ST s a) → a
23:39:28 <kmc> but we have no natural logical reading of the 2-ary "predicate" ST
23:39:44 <Saizan> exists s. (forall a. ST s a -> a)
23:39:47 <MiggyX> kmc: I'm not sure I know enough Haskell to really "get" it - but when I do I will gladly take you up on that offer :)
23:39:54 <kmc> ok MiggyX :)
23:39:58 <kmc> this is more type theory than Haskell
23:40:02 <kmc> though they obviously intersect
23:40:09 <Eduard_Munteanu> Saizan: oh, that makes more sense.
23:40:13 <kmc> GHC doesn't have the explicit ∃, though some less popular implementations do
23:40:30 <kmc> Saizan, you can write runST with that type?
23:40:57 <kmc> makes sense -- it's like unsafePerformIO, but it doesn't promise that it's using RealWorld, just some unknown s
23:41:14 <dolio> No, that type neglects some safety conditions.
23:41:32 <Saizan> dolio: really?
23:41:35 <dolio> Yes.
23:41:57 <Eduard_Munteanu> So in effect the missing outer forall on 's' makes it existentially quantified at the top level.
23:41:58 <dolio> For instance, you can open that existential and have 'forall a. ST s a -> a' for some skolemized s.
23:42:24 <dolio> Meaning you can pass STRefs out of a runST.
23:42:32 <kmc> Eduard_Munteanu, free vars become *universally* quantified at top level
23:42:53 <kmc> a skolemized variable is a free var that's implicitly universal?
23:43:36 <Eduard_Munteanu> kmc: yes, but being universally quantified in some inner term prevents it from being universally quantified at top level?
23:43:40 <dolio> I mean, it's some opaque 's'. You don't know what it is, but it's something particular.
23:43:46 <Eduard_Munteanu> I'm trying to internalize this stuff. :/
23:44:32 <kmc> yeah Eduard_Munteanu
23:44:36 <kmc> ok
23:44:39 <Saizan> dolio: ah, true
23:44:45 <Eduard_Munteanu> Makes sense that way.
23:44:58 <kmc> dolio, it's an s on the left hand side of the ⊢, then?
23:45:08 <Saizan> Eduard_Munteanu: disregard my exists s. (forall a. ST s a -> a), it's wrong :)
23:45:21 <dolio> kmc: Yeah, that's a good way to think about it, I guess.
23:45:23 <Eduard_Munteanu> I see.
23:45:28 <Saizan> Eduard_Munteanu: anyhow, i find the "game semantics" pretty useful for higher-rank types
23:46:09 <Saizan> "who gets to choose how to instantiate the type variable?"
23:46:19 <merijn> Design question: If I want to have a (global) runtime constant (i.e. read in at program start and not changed at runtime) what's the best approach to this? If I write them as a top level function I figure they'd have to live in the IO monad contaminating various pure pieces of code with IO...
23:46:30 <dolio> case runST of Box runST' -> let r = runST' (newSTRef 5) ; v1 = runST' (readSTRef r) ; v2 = runST' (readSTRef r) ; c = runST' (writeSTRef r) in print (v1, c, v2)
23:46:53 <dolio> Oops, make that c = runST' (writeSTRef r 0)
23:47:01 <kmc> merijn, you can pass it as an ordinary parameter
23:47:05 <dolio> That could conceivably print out (5, (), 0).
23:47:06 <kmc> but you still have to pass it around
23:47:15 <kmc> or you could use the Reader monad as sugar for that passing
23:47:19 <merijn> kmc: Yes, but then I'd have to pass it around, which was sorta what I wanted to avoid
23:47:31 <kmc> or you could say "screw it" and do your parameter reading in unsafePerformIO
23:47:46 <kmc> size :: Int; size = read . unsafePerformIO $ readFile "size.txt"
23:48:59 <Veinor> @pl f x = return . sequence . map g x
23:48:59 <lambdabot> f = ((return . sequence) .) . map g
23:49:13 <Veinor> oh wait, that return is redundnat
23:49:15 <Veinor> *redundant
23:50:05 <ziman> i'd say (forM x)
23:51:13 <kmc> in that case you might want {-# NOINLINE size #-} to prevent duplicated read
23:51:18 <Veinor> holy :t forM
23:51:21 <Veinor> ... whoops
23:51:25 <Veinor> :t forM
23:51:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
23:51:27 <kmc> although for this hack to have any merit, you should anyway guarantee that the file doesn't change during execution
23:51:34 <merijn> kmc: Ignoring the fact that laziness might cause it to not be read at all 'foo = unsafePerformIO $ readFile "bar"' will only be read once, correct?
23:51:44 <kmc> well laziness might cause it not to be read, only if it's not used
23:51:50 <kmc> and it might be read more than once if it gets inlined
23:51:55 * hackagebot texmath 0.3.1.5 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.3.1.5 (JohnMacFarlane)
23:52:11 <kmc> merijn, there's also the xmonad style of config-file-as-Main-module
23:52:16 <kmc> see the package dyre
23:52:59 <merijn> kmc: Oh, that might be what I want done in a less sucky way
23:53:36 <ziman> eh, the `g' is a constant so probably (mapM g)
23:54:43 <merijn> In unrelated news, if there's any OS X users here. What do you prefer installing the OSX Haskell platform or using MacPorts?
23:56:22 <arcatan> neither. i've installed just GHC and then cabal-installed everything needed.
23:57:16 <arcatan> though I don't have any reason why I wouldn't use the platform
23:58:52 <Veinor> whoo, error handling go
23:58:58 <Veinor> merijn: I use the platform
23:59:41 <merijn> I'm using the platform now, but I'm considering moving more of the software I use to the MacPorts version to deal with keep track of updates for me
