00:00:23 <dmwit> Reimplementing minimumBy with foldl1' shouldn't be hard, either.
00:00:48 <nickela> dmwit: because minimumBy internally using foldl1, and in this case all list will be constructed in memory
00:01:04 <dmwit> As for your optimization of stopping early: are you sure it's necessary? Is this really the bottleneck in your algorithm? What does profiling say?
00:01:37 <dmwit> nickela: So write minimumBy'.
00:02:01 <nickela> dmwit: just 'academic' interest, for example closest' 1 [1..1e6] work about minute
00:02:22 <nickela> dmwit: and closest'' 1 [1..1e6] work microsecond
00:02:25 <dmwit> > takeWhile (/=1) [1..1e6]
00:02:26 <lambdabot>   []
00:03:14 <McManiaC> > take 1 $ dropWhile (/=1) [1..1e6]
00:03:15 <lambdabot>   [1.0]
00:03:22 <dmwit> > let takeUntil p [] = []; takeUntil p (x:xs) | p x = [x] | otherwise = x : takeUntil p xs in takeUntil (/=1) [1..1e6]
00:03:22 <McManiaC> :>
00:03:23 <lambdabot>   [1.0,2.0]
00:03:56 <dmwit> Oh, I'm an idiot.
00:03:59 <dmwit> > let takeUntil p [] = []; takeUntil p (x:xs) | p x = [x] | otherwise = x : takeUntil p xs in takeUntil (==1) [1..1e6]
00:04:00 <lambdabot>   [1.0]
00:04:47 <nickela> thanks, I got idea
00:04:55 <dmwit> So, yeah, compose the naive implementation of closest with something like takeUntil. In general: separate concerns as much as possible.
00:06:28 <dmwit> nickela: Anyway, yeah, my main complaint is that you're constructing this totally unnecessary list of tuples and doing tuple-munging on each element.
00:06:37 <dmwit> (Hence my original suggestion.)
00:06:44 <dmwit> But that's mostly a style thing, and not a speed thing.
00:07:11 <ski> pelotom : hm, it's not *that* common to need it, but when you need it, it's hard to use something else instead
00:07:35 <Gracenotes> :o
00:07:42 <cch> is there a function that can do this: split '.' "00.0.7" == ["00", "0", "7"]
00:08:00 <dmwit> ?hackage split
00:08:01 <lambdabot> http://hackage.haskell.org/package/split
00:08:20 <ski> pelotom : sometimes it arises naturally in GADTs, e.g. .. the simplest example being `data Expr :: * -> * where Lit :: a -> Expr a; App :: Expr (a -> b) -> (Expr a -> Expr b)'
00:09:06 <cch> o, thankks
00:09:36 <McManiaC> <3 split
00:09:36 <pelotom> ski: where is the existential there?
00:10:42 <ski> pelotom : written in the algebraic style, that becomes `data Expr b = Lit b | forall a. App (Expr (a -> b)) (Expr a)' .. so the existential is the `a' which is not mentioned in the result type of `App'
00:11:42 <ski> pelotom : another example i've been pondering a bit is having a functional reference / lens which focuses on several parts of a data-structure at once : `newtype LensMany a b = LM (a -> exists f. Functor f *> (f b,f b -> a))' (pseudo-Haskell syntax)
00:13:51 <ski> pelotom : yet another such idea would be a kind of `Map', where the type of the values can depend on which the key that maps to them : `newtype Map1 key value = MkMap1 [exists i.(key i,value i)]'
00:14:17 <ski> s/which the key that/which key/
00:15:18 <ski> pelotom : there are probably other uses as well, in existing libraries, but i can't remember any atm
00:16:25 <pelotom> ski: I'm still stuck on your first example
00:16:25 <ski> well, there's `SomeException'
00:16:38 <pelotom> (sorry, I'm pretty new to haskell)
00:16:48 <ski> are you stuck on what it does/means ? or what it would be good for ?
00:17:10 <pelotom> I'm stuck on how it's existential... it doesn't seem like a is actually hidden
00:17:59 <ski> consider
00:18:01 <ski> @type ord
00:18:02 <lambdabot> Char -> Int
00:18:11 <ski> so, we have
00:18:17 <ski>   ord :: Char -> Int
00:18:20 <lars9> could anyone tell me why this simple program can not compile? http://hpaste.org/40954/why_error
00:18:21 <pelotom> ahh, nvm, I get it
00:18:22 <ski>   Lit ord :: Expr (Char -> Int)
00:18:31 <pelotom> Expr only has 1 type parameter
00:18:32 <ski>   Lit 'a' :: Expr Char
00:18:43 <pelotom> for App that ends up being 'b'
00:18:43 <ski>   App (Lit ord) (Lit 'a') :: Expr Int
00:18:50 <ski> there, `Char' is hidden
00:18:57 <ski> right
00:19:09 <dmwit> lars9: Either use integer division (`div` instead of (/)), or cast to a type that supports real division.
00:19:42 <lars9> dmwit: / returns Real?
00:19:44 <pelotom> haven't quite got the hang of GADTs yet either :)
00:19:49 <dmwit> lars9: No, not quite.
00:19:52 <dmwit> :t (/)
00:19:52 <lambdabot> forall a. (Fractional a) => a -> a -> a
00:20:07 <dmwit> :t div -- for comparison
00:20:07 <lambdabot> forall a. (Integral a) => a -> a -> a
00:20:22 <lars9> dmwit: must be applied on Fractional?
00:20:24 <pelotom> so GADTs sort of subsume existentials it seems like
00:20:38 <dmwit> lars9: Yes, it must be applied to a value whose type is a member of the Fractional class.
00:20:41 <pelotom> I didn't have to include the existential extension when compiling that
00:20:48 <dmwit> ?instances Fractional
00:20:49 <lambdabot> Double, Float
00:20:56 <dmwit> ?instances Integral
00:20:56 <lambdabot> Int, Integer
00:21:02 <pelotom> just GADTs and KindSignatures
00:21:12 <lars9> dmwit: what's the difference between Int and Integer?
00:21:18 <dmwit> lars9: size
00:21:38 <dmwit> lars9: Int is a machine int (but guaranteed at least 29 bits); Integer is unbounded.
00:21:56 <dmwit> > (2^65 :: Int, 2^65 :: Integer)
00:21:57 <lambdabot>   (0,36893488147419103232)
00:22:14 <dmwit> > maxBound :: Int
00:22:14 <lars9> dmwit: i see, you helped me a lot
00:22:15 <lambdabot>   9223372036854775807
00:22:18 <dmwit> > maxBound :: Integer
00:22:19 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
00:22:19 <lambdabot>    arising...
00:23:55 <ski> pelotom : yes, GADTs subsumes "existential data types"
00:24:35 <lars9> i'm practicing haskell with topcoder's problems, i found it's hard to do those dynamic programming ones...
00:24:49 <ski> pelotom : and `KindSignatures' aren't really needed, if you omit the ` :: * -> *' (in which case that will be inferred) (hm, or maybe you need to write like `data Expr x' instead of `data Expr' then .. i don't recall)
00:25:09 <pelotom> ski: right, I figured
00:25:14 <dmwit> lars9: Dynamic programming in Haskell is often just a scanl or so.
00:25:30 <dmwit> Lazy evaluation makes dynamic programming a snap. =)
00:25:37 <ski> pelotom : roughly speaking, the algebraic data type syntax more or less mimics BNF syntax, while with GADT syntax, you just explicitly write the type signatures you want for each constructor
00:25:48 <bonii> Illegal use of punning for field <- what is this referring to ?
00:26:12 <dmwit> You've got too many variables with the same damn name.
00:26:20 <pelotom> ski: yeah, I actually think the GADT syntax is somewhat more readable
00:27:07 <ski> pelotom : in some sense, i suppose. but it can seem wasteful to have to repeat the same result type many times, if you don't actually need the flexibility
00:27:11 <pelotom> ski: ok, for practice I'm gonna try to write an eval function for this GADT you gave me
00:27:15 <ski> imo, both have their places
00:27:25 <ski> pelotom : that should be pretty easy
00:27:28 <lars9> for example, how to solve this problem in haskell? http://hpaste.org/raw/40955/qsort
00:28:49 <ski> pelotom : for fun, you can add stuff like `Pair :: Expr a -> Expr b -> Expr (a,b)',`Fst :: Expr (a,b) -> Expr a',`Snd :: Expr (a,b) -> Expr b',`Eval :: Expr (Expr a -> a)',&c. if you want
00:29:47 <lars9> the python solution looks neat: http://hpaste.org/paste/40955/qsortpython#p40956
00:30:47 <ski> dmwit : 30 bits
00:31:04 <dmwit> what's a few bits between friends
00:31:19 <pelotom> ski: you're right, that was easy :)
00:31:27 <bonii> Can someone take a look at this and tell me why it is giving illegal punning for field error http://pastebin.ca/1976164
00:32:30 <Zao> bonii: What's the definition of P?
00:32:44 <ski> pelotom : you tried with additional constructors, as well ?
00:32:48 <Zao> Shouldn't it be like P { foo=x, bar=y; baz=x }  or something?
00:32:53 <pelotom> ski: not yet
00:33:01 <bonii> Zao: Urgh 
00:33:05 <pelotom> ski: still poking at the App thing
00:33:12 <dmwit> I see, my misconception stemmed from the upper bound being 2^29 (- 1, of course).
00:33:18 <ski> *nod*
00:33:18 <pelotom> case (App (Lit length) (Lit "hello")) of (App a b) -> a
00:33:23 <pelotom> no can do!
00:33:26 <pelotom> *boom*
00:33:28 <dmwit> Apologies to all involved.
00:34:04 <ski> pelotom : right, that's not allowed
00:34:32 <bonii> Zao: Thanks
00:35:29 <pelotom> cool
00:37:04 <pelotom> ski: is that because there's a bottom in haskell but no "top"?
00:37:36 <pelotom> if that makes any sense
00:38:04 <ski> it's because the type of `a' is `x -> String', where `x' is an unknown type, so it can't be returned
00:38:25 <ski> well, the type of `a' is `Expr (x -> String)', but the same point applies
00:39:34 <Zao> bonii: There's an language extension to automagically introduce names of fields into a scope, which might be the cause of your odd result.
00:40:32 * ski thinks it is/was a mistake to use the same names for fields, as well as for field extraction functions ..
00:40:51 <pelotom> ski: if haskell had an "exists" syntax, would it be able to infer that type as 'exists x. x -> String'?
00:41:08 <pelotom> still useless, but...
00:42:11 <ski> pelotom : well, it should at least be able to accept `exists x. Expr (x -> String)', yes
00:42:19 <ski> (maybe not infer it, i'm not sure)
00:42:41 <ski> and it could be useful in somewhat more complicated scenarios
00:43:21 <pelotom>  why don't record accessors work with existentials?
00:43:39 <ski> because there's no `exists'
00:43:52 <pelotom> ok, that makes sense
00:44:20 <ski> consider if we said `data Expr b = Lit b | forall a. App {operator :: Expr (a -> b) , operand :: Expr a}'
00:44:26 <ski> then we'd get
00:44:41 <ski>   operator :: forall b. Expr b -> exists a. Expr (a -> b)
00:44:52 <ski>   operand  :: forall b. Expr b -> exists a. Expr  a
00:45:28 <ski> however, istr record *update* syntax still works with existentials (at least if you use GADT syntax)
00:46:50 <ski> (thanks to autrijus of Perl6 fame, iirc)
00:47:10 <pelotom> ski: I see it now
00:47:21 <pelotom> accessors would allow the unknown type to "escape"
00:47:45 <ski> otoh, record accessors still work for fields whose types don't mention the existentially quantified type variables, iirc
00:48:15 <pelotom> ski: makes sense
00:48:59 <pelotom> so you can write functions that operate on records with existentials, as long as the result of the function combines the contents in such a way that the existential type is eliminated
00:49:21 <pelotom> that's poorly worded, but hopefully somewhat sensical
00:50:40 <ski> it's correct
00:51:07 <ski> that's basically what the `exists-elimination' rule in predicate logic is about :)
00:51:22 <ski> (which here translates to pattern-matching on existentials)
00:51:55 <ski> and replacing `Expr (x -> String)' with `exists x. (x -> String)' counts as "eliminating" all references to `x' :)
00:52:10 <ski> (er, replacing with `exists x. Expr (x -> String)' :)
00:54:04 <pelotom> curry-howard ftw!
01:11:59 <pelotom> ski: http://hpaste.org/40957/gadt_fun
01:12:48 <ski> yeah :)
01:13:03 <ski> (i'd not bother with `$' there, though)
01:13:46 <sipa1024>  pelotom why the 'Eval' constructor?
01:13:49 <pelotom> in eval Fst and Snd?
01:14:17 * ski for some reason really likes `eval Eval = eval' :)
01:14:30 <pelotom> sipa1024: I dunno, it's ski's exercise :)
01:14:38 <sipa1024> oh, ok :)
01:14:42 <ski> (oh, that's right, you don't need brackets around `Eval')
01:15:05 <pelotom> ski: I know, I just did that for symmetry
01:15:16 <pelotom> with the rest of the equations
01:15:25 * ski usually omits such brackets, but still aligns the start of the constructors
01:15:27 <pelotom> it looks purdy
01:15:47 <pelotom> I see
01:18:40 <aempirei> girl afraid where do his intentions lay
01:31:21 <lars9> in main::IO(), using 'interact', how to process each line immediately after input? now I have to use ctrl-D to input EOF
01:32:39 <ski> pelotom : btw, did you understand the point of `Map1' ?
01:34:16 <pelotom> ski: sort of
01:34:42 <lars9> got it: main = interact (unlines . map processLine . lines)
01:34:53 <pelotom> ski: so not just hte value depends on the key, but the type of the value depends on the type of the key?
01:36:16 <sipa1024> lars9: maybe by throwing an exception?
01:36:39 <ski> pelotom : yes
01:36:40 <ski> someone wanted to write a program where it would parse its own program name, and generate a key in `data ProgramName :: * -> *; PNFoo :: ProgramName Foo; PNBar :: ProgramName Bar; PNBaz :: ProgramName Baz', and then use the resulting key of type `ProgramName n', for some type `n' in a map, to get a value (a function) whose type used `n'
01:36:52 <ski> (i don't recall the details)
01:37:35 <ski> so the idea was that different keys had somewhat different types, which could then express how the types of the corresponding values differed
01:37:41 <ski> so, we'd expect
01:38:15 <ski>   lookup1 :: Eq1 k => Map1 k v -> (k i -> Maybe (v i))
01:38:19 <ski> and
01:38:27 <ski>   class Eq1 f
01:38:29 <ski>     where
01:38:47 <ski>     eq1 :: forall i j. f i -> f j -> Maybe (Equal i j)
01:39:30 <ski> so given a `Map1 ProgramName Action', and say, `PNBar :: ProgramName Bar', we'd use `lookup1' to get an `Action Bar'
01:39:43 <lars9> in a simple program "GetSum", it reads a line of numbers, then print their sum. how to make it work for both Integer and Float?
01:39:53 <ski> pelotom : does that make sense ?
01:40:30 <pelotom> ski: could you paste some code? I do better when I can load it in ghci and play with it
01:41:36 <lars9> something like: main = interact (unlines . map getSum . lines), getSum l = show $ sum $ map read $ words l
01:41:46 * ski never worked this out fully, because the one who wanted to do this settled for something else (or maybe just didn't come back to IRC .. i don't really recall)
01:42:32 <pelotom> ah, ok
01:43:24 <lars9> but it works only on Int
01:43:44 <lars9> can not parse Float
01:47:40 <pelotom> ski: A newtype constructor cannot have an existential context, but `MkMap1' does
01:47:55 <pelotom> :r
01:48:01 <pelotom> oops :)
01:48:06 <pelotom> data works though
01:49:09 <ski> pelotom : i know. but `Map1' isn't supposed to be the "existentially quantified datatype" here, anyway :)
01:49:30 <pelotom> ski: oh. what is it?
01:49:39 <ski> (it is supposed to *use* another datatype which will use the `forall i.' syntax for that)
01:49:51 <pelotom> oh
01:49:56 <ski> note that the `exists i.' was nested *inside* the list type constructor
01:50:11 <pelotom> I rewrote what you said as 'newtype Map1 key value = forall i. MkMap1 [(key i,value i)]', was that an incorrect translation?
01:50:18 <ski> if you do `data Map1 k v = forall i. MkMap1 [...]', you get something completely different
01:50:22 <ski> it wasn't
01:50:40 * ski is trying to code together a simple example ..
01:50:59 <pelotom> k, let me know :)
01:51:01 <ski> sorry, "it wasn't" is ambiguous or wrong
01:51:12 <ski> i mean that it was an incorrect translation, yes :)
01:51:12 <pelotom> it was wrong, you mean
01:51:57 <pelotom> MkMap1 [forall i. (key i, value i)]?
01:52:19 <pelotom> I'm just trying random positions now :)
01:52:35 <quicksilver> MkMap1 [exists i . (key i, value i)]
01:52:42 <quicksilver> (pseudo-syntax)
01:53:00 <quicksilver> to implement that in haskell you need an inner constructor for the pair
01:53:31 <quicksilver> data KVPair key value = forall i . MkKVPair (key i) (value i)
01:53:42 <pelotom> oh, duh
01:53:45 <quicksilver> newtype Map1 k v = [KVPair k v]
01:53:51 <quicksilver> but, I don't think that's actually useful.
01:53:57 <quicksilver> that is, I don't think you'll be able to look stuff up in it.
01:54:04 <quicksilver> think you need a typeable constraint at least.
01:57:04 <pelotom> for some reason I find "exists" more readable when I mentally replace it with "forsome"
01:58:33 <quicksilver> that's quite reasonable.
01:59:56 <ski> quicksilver : i think `lookup1 :: Eq1 k => Map1 k v -> (k i -> Maybe (v i))' would work fine
02:00:41 * ski attempts to figure out some somewhat-sensible looking example use of this, now
02:00:45 <quicksilver> ski: Eq1 lets you compare 'k's with different type indices?
02:00:48 <ski> yeah
02:00:58 <ski> (see a bit above)
02:01:03 <quicksilver> ah sorry. yes, well, that's equivalent to Typeable :)
02:01:12 <ski> not really
02:01:48 <quicksilver> depending what laws you assume for it
02:02:20 <quicksilver> if you assume that i /= j ===> (x :: k i) /= (y :: k j)
02:02:23 <quicksilver> for all x,y
02:02:50 <quicksilver> then your Eq1 instance gives you a form of type comparision rather like Typeable.
02:03:06 <quicksilver> (except you need witnesses to do it)
02:04:49 <quicksilver> ski: actually, I'm *not* sure.
02:05:06 <quicksilver> ski: because the compiler doesn't "know" that law I just wrote
02:05:18 * pelotom needs to learn about this Typeable now
02:05:45 <quicksilver> suppose you're comparing "kk" against the pair (ll,vv)
02:05:56 <quicksilver> and suppose that kk === ll (Eq1)
02:06:17 <quicksilver> the typechecker can't deduce that vv is therefore the same type (index) as kk.
02:06:22 <quicksilver> or were you planning to unsafeCoerce?
02:06:45 <quicksilver> pelotom: Typeable's very boring - it's a compiler provided construction which creates a runtime representative for every type.
02:06:52 <quicksilver> pelotom: so that you can compare types at runtime.
02:07:00 <ski> quicksilver : please see `class Eq1' above :)
02:07:07 <pelotom> ah, so reified types
02:07:23 <pelotom> that seems rather like cheating :)
02:07:44 <quicksilver> pelotom: it is.
02:07:55 <quicksilver> ski: hmm. Ok I found it. Your Eq1 isn't what I was talking about.
02:08:15 * quicksilver will wait for ski's example.
02:08:28 <dancor> i wonder what this is http://hackage.haskell.org/trac/ghc/wiki/SafeHaskell?version=1
02:08:31 <quicksilver> I don't understand how Maybe (Equal i j) can be a witness.
02:08:49 <quicksilver> Nothing :: Maybe (Equal Int String)
02:08:49 <lukasz> \quit
02:13:31 <Saizan> quicksilver: it's Maybe a witness
02:13:49 * quicksilver doesn't see how that helps the type-checker
02:14:06 <quicksilver> oh perhaps I do.
02:14:09 <lars9> so frustrated about averege::[a] -> Double...
02:14:13 <lars9> how to write it?
02:14:20 <quicksilver> afterall lookup only returns Maybe a value.
02:14:25 <quicksilver> lars9: you can't, obviously.
02:14:33 <quicksilver> not all types 'a' can be sensible averaged to Doubles.
02:14:50 <quicksilver> what would average :: [(Char,Int)] -> Double mean?
02:15:22 <lars9> how to write [Double] -> Double?
02:15:33 <quicksilver> average xs = sum xs / length xs
02:16:19 <lars9> thanks
02:20:17 <adnap> average xs = sum xs / genericLength xs
02:20:29 <dancor> answer my q: David Mazieres at Stanford wants to implement Safe Haskell, a flag for GHC that will guarantee that your program does not use unsafePerformIO, foreign calls, RULES, and other stuff
02:20:34 <dancor> http://hackage.haskell.org/trac/ghc/wiki/Status/Oct10
02:24:50 <pelotom> isn't unsafePerformIO needed to implement certain things?
02:25:14 <dancor> pelotom: i just know it's used for hGetContents
02:25:56 <pelotom> dancor: ST monad maybe?
02:26:12 <dancor> idk
02:26:31 <quicksilver> dancor: unsafePerformIO is not used for hGetContents.
02:26:43 <quicksilver> pelotom: the ST monad should be regarded as a compiler primitive.
02:27:07 <pelotom> quicksilver: yeah, but would this "safe haskell" flag consider it so?
02:27:18 <pelotom> it says it disallows FFI
02:27:22 <dancor> quicksilver: sorry, unsafeInterleaveIO is used there.  but i assume that is flagged as well in Safe Haskell.
02:27:22 <quicksilver> hGetContents uses unsafeInterleaveIO which probably isn't much better, but doesn't *obviously* allow you to circumvent the type system.
02:27:23 <pelotom> too
02:27:36 <quicksilver> pelotom: I don't see why it should.
02:27:42 <quicksilver> pelotom: 'Int' and 'Char' are compiler primitives
02:27:47 <quicksilver> should we disallow those too?
02:28:02 <quicksilver> why is ST a worse compiler primitive than any other?
02:28:13 <sipa1024> it allows imperative programming
02:28:18 <sipa1024> which is obviously evil
02:28:21 <sipa1024> ;)
02:28:26 <quicksilver> rubbish.
02:28:31 <quicksilver> I know you're joking, but...
02:28:40 <pelotom> no, I'm not advocating that at all, I'm concerned that if you disallow unsafe IO, you might inadvertently disable things that were built on it but which are nonetheless safe
02:28:56 <quicksilver> the ST monad doesn't allow any 'imperative programming' that you couldn't already use without it
02:28:59 <dancor> pelotom: right.  but people do gripe about getContents
02:29:00 <pelotom> how would you tell this thing to ignore certain things?
02:29:10 <quicksilver> pelotom: well you give it a trusted library base.
02:29:32 <quicksilver> otherwise you can't even add two numbers (+# is a compiler primitive)
02:29:33 <dancor> the only other thing that comes to my small mind in unamb, which is another thing people are wary of
02:29:52 <pelotom> ok
02:30:07 <dancor> i would miss FFI more than unsafe* i think
02:30:37 <sipa1024> obviously you can implement unsafeCoerce easily using the FFI
02:30:51 <dancor> right, but i just mean practically
02:31:21 <quicksilver> safe haskell wouldn't be able to interface with arbitrary C libraries - but that's not surprising.
02:31:37 <sipa1024> would it allow you to do IO?
02:31:39 <dancor> i'm more willing to sacrifice safety when i need to bind to an existing C thing for speed or to not rewrite it.  lazy io never saved my life.
02:31:53 <quicksilver> I imagine the idea is that the security "host program" can use arbitrary libraries
02:32:05 <quicksilver> and it can make what it wants available to the client program
02:32:15 <quicksilver> imagine application servers or secure OSes
02:32:39 <pelotom> quicksilver: it'd be nice if the "ignore these, I promise they're safe" set was configurable by the programmer
02:33:04 <dancor> well you can already statically analyze your program.  if it doesn't use TH.
02:33:10 <merijn> Is the main difference between lambda_omega and dependently typed lambda calculus that "nat -> * : []" is only valid in the former and "* -> * : []" is only valid in the latter?
02:34:08 <merijn> eh
02:34:44 <merijn> I mean the reverse of what I said..."nat -> * : []" is only valid in dependent and "* -> * : []" is only valid in lambda_omega
02:34:49 <pelotom> remind me which axis lambda omega is on...
02:35:01 <merijn> pelotom: Type operators
02:36:54 <pelotom> so type constructors basically?
02:37:56 <merijn> pelotom: I think? Types depending on types says wikipedia. But if I was sure I didn't need to ask whether I was right with my question :p
02:38:38 <pelotom> right, ok
02:39:10 <ray> where wikipedia says depending on _, replace with "that can take _ as arguments"
02:39:13 <pelotom> types depending on types, that's polymorphic types I believe
02:39:40 <pelotom> parametric polymorphism
02:39:41 <merijn> pelotom: Polymorphism is terms depending on types
02:39:44 <pelotom> in types
02:39:44 <Saizan> types depending on types is what let you have parametrized types
02:39:50 <lars9> can not add Int to Double using +?
02:39:51 <pelotom> sorry, yes
02:39:54 <pelotom> type constructors
02:40:09 <Saizan> not only type constructors
02:40:13 <lars9> "length l + cal" reports error
02:40:22 <lars9> cal returns Double
02:40:26 <pelotom> orly?
02:40:27 <Saizan> type functions in general, actually in pure lambda calculus there are no constructors
02:40:35 <merijn> Saizan: My concrete question was whether these observations were right: "nat -> * : []" is only valid in dependent and "* -> * : []" is only valid in lambda_omega
02:41:22 <Saizan> merijn: yep, though any sane dependently typed language i've seen subsumes lambda_omega
02:41:30 <Saizan> merijn: i.e. allows both of those
02:41:45 <Saizan> merijn: but in the lambda cube those are on different axis
02:41:53 <merijn> Saizan: That's what I figured, but I'm trying to grok the difference between all the lambda cube stuff
02:42:42 <pelotom> is there any dependently typed theorem prover/PL that uses anything less than all 3 axes of the cube/
02:42:51 <ray> it's a cube because you can either have or not have any of 3 things
02:42:56 <merijn> I think I can finally feel the burning light of enlightenment after a twisty maze of papers all alike :>
02:43:33 <ray> just imagine a 3 bit number if you're some kind of computers nerd
02:43:34 <pelotom> ray: I know, I'm asking if anyone's implemented something that has dependent types but missing one of the other 2 axes
02:43:45 <pelotom> a programming language
02:44:02 <paolino> hello there, I'm trying to make an instance of typeable without luck. Here is the code http://hpaste.org/40958/typeof_existential. Anyone can help please ? 
02:44:04 <ray> not that i know of
02:44:29 <ray> you could in theory
02:44:39 <merijn> myType 1 (with myType : nat -> *, 1 : nat and nat : *) is dependent, where as myType nat (with myType : * -> *, nat : *) is lambda_omega
02:45:17 <merijn> And haskell's system is roughly based on System F_omega?
02:45:24 <pelotom> merijn: yup
02:45:44 <merijn> Hurray! \o/
02:46:25 <pelotom> F gives you type -> terms and omega gives you type -> types
02:46:36 <ray> yeah, haskell sadly lacks dependent types ; ;
02:47:40 <pelotom> and haskell manages to be have type inference on top of all of that (unless you get too crazy with the higher rank poly)
02:48:06 <ski> paolino : you don't want to return the type of `x', there
02:51:17 <Saizan> it manages to have type inference by assuming you're not using any extension most of the time, which also means that you get type errors that are just the result of wrong guesses
02:51:36 <ski>   instance Typable b => Typable (Reazione b)
02:51:41 <ski>     where
02:51:47 <merijn> Ok, one more question
02:51:50 <ski>     typeOf (Reazione f) = mkTyCon "Reazione" `mkTyConApp` [typeOf (f undefined)]
02:52:28 <paolino> ski, the error is ambiguous type . I was wondering why. I know it's not correct, but I couldn't derive Typeable as b is monadic 
02:52:49 <ski> paolino : i think something like that would be a valid instance for `Reazione' (it's possible there's some kind of `mkTyConApp1' shortcut or something, i don't use `Typable' much)
02:52:54 <merijn> The calculus of constructions has all three axes(?) of the lambda cube, if I understand the Extended Calculus of Construction correct we obtain that by extending [] with an inductively defined infinite hierarchy of kinds?
02:53:23 <ski> paolino : btw, your `Typable a' constraint inside `Reazione' is unused here .. just so you are aware of it
02:54:28 <ski> pelotom : re "unless you get too crazy with the higher rank poly", or just plain Haskell98 polymorphic recursion
02:54:37 <paolino> ski, I thought it was
02:55:31 <pelotom> merijn: what is []?
02:55:53 <ski> (btw, i realized the example of `Map1' i was going to write is probably hard to do without `unsafeCoerce' .. a pity the example int80_h was trying to do is just a sketch, and unfinished)
02:57:01 <pelotom> ah, oh well
02:57:04 <Saizan> merijn: i'm not very familiar with ECC, though the infinite hierarchies i've seen were mostly to keep the system predicative
02:57:24 <ski> (fwiw <http://webcache.googleusercontent.com/search?q=cache:iTpj5R8Y7xoJ:hpaste.org/fastcgi/hpaste.fcgi/view%3Fid%3D29641%22&cd=1&hl=en&ct=clnk&ie=UTF-8>)
02:59:36 <paolino> ski, this is working ,http://hpaste.org/paste/40958/a_working_instance#p40959
03:00:31 <paolino> I miss the type inference difference actually
03:03:01 <kevinburke> rd1
03:03:32 <kevinburke> is there an easy way to get the type of a variable, or to compare the types of two variables?
03:04:44 <paolino> kevinburke: (==) at compile time usually
03:05:22 <kevinburke> well but lets say I have a data Fruit = Apple String | Orange String
03:05:36 <kevinburke> and I want to check if a and b are both apples
03:05:37 <ski> paolino : it is "working". but it is wrong
03:05:50 <sipa> kevinburke: both have the same type, but hteir values differ
03:06:09 <sipa> use deriving Eq
03:06:10 <ski> paolino : the type `Reazione b' is not the same as the type `a -> b'
03:06:18 <sipa> and compare them using ==, is what you want
03:06:25 <ClaudiusMaximus> case (a, b) of (Apple _, Apple _) -> ...
03:06:45 <ski> paolino : using that instance can possibly make your program crash
03:07:18 <ClaudiusMaximus> or let f (Apple _) (Apple _) = ... in f a b
03:07:43 <ClaudiusMaximus> replace _ with a variable in case you want the strings
03:07:45 <ski> (if used together with GADTs or type families which refer to `Reazione', i think)
03:08:16 <paolino> ski, I'm using it to "see" a structure full of (Reazione b) and distinguish the structure nodes by Reazione 
03:08:30 <paolino> so, it's a hack
03:08:31 <ski> i have no idea what that means
03:10:26 <paolino> the only way to distinguish 2 (Reazione b) is by showing the typeOf a, that is my goal
03:11:52 <ManateeLazyCat> I use "darcs add ./Manatee/* -r -q --case-ok || darcs record" in my script to scan/add new files before record them. But darcs looks can't add new files successful when first time, "darcs record" just work when i need do "darcs add" again. Any idea fix this problem?
03:11:52 <ManateeLazyCat>  
03:12:38 <ski> paolino : i still don't understand what you're attempting to do ..
03:14:38 <ski> (.. or `... = ..(f a b).. where f (Apple _) (Apple _) = ...; ...')
03:16:10 <paolino> ski, say I have a [Reazione b] and want to count the Reazione b with a function inside of type (Int -> b)
03:16:58 <ski> that should be `filter' and `length', i think
03:17:22 <paolino> or simply print out a [TypeRep] of all those a, hidden in the Reazione
03:17:36 <ski> that seems unneccesary, imo
03:17:57 <ski> well
03:18:01 <ski> also, it seems useless
03:18:03 <paolino> the Typeable instance ?
03:18:13 <ski> (with a *valid* `Typable' instance)
03:18:46 <ski> `map'ping `typeOf' on the list seems unnecessary^W*useless*
03:19:11 <ski> since (with a *valid* `Typable' instance for `Reazione'), you'll get `Reazione b' for every element of the list
03:19:37 <ski> (since that is what their type is. giving anything else in the `Typable' instance is asking for trouble)
03:19:54 <ski> so, why not
03:20:15 <paolino> ok, I give up the instance then, but not the goal
03:20:21 <ski>   countFunsFromInt :: [Reazione b] -> Int
03:20:44 <ski>   countFunsFromInt rs = length (filter isFromInt rs)
03:20:46 <ski>     where
03:21:24 <ski>     isFromInt (Reazione f) = typeOf (undefined :: Bool) == typeOf (grabArg f)
03:21:27 <ski>       where
03:21:35 <ski>       grabArg :: (a -> b) -> a
03:21:41 <ski>       grabArg = undefined
03:21:48 <ski> ?
03:22:40 <ski> er, actually s/Bool/Int/, of course
03:22:47 * paolino tries
03:23:10 <ski> if `Typable' exports a value representing the type `Int', you can of course use that directly instead of `(undefined :: Int)'
03:23:27 <ski> er, instead of `typeOf (undefined :: Int)'
03:23:48 <ski> @type toDyn
03:23:49 <lambdabot> forall a. (Typeable a) => a -> Dynamic
03:23:54 <ski> @type fromDyn
03:23:55 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
03:23:58 <ski> @type fromDynamic
03:23:59 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
03:24:22 <ski> i suppose `fromDynamic' could be used instead of `(==)', there .. i don't know which would be better, if any
03:24:46 <ski> hm, well, there's no `Dynamic' here, so that's probably uncalled for
03:27:06 <paolino> thanks ski, I was just looking for subtype (Reazione f) = typeOf ((undefined :: (a -> b) -> a) f)
03:27:28 <ski> ok
03:27:34 <paolino> but couldn't get there
03:28:01 <ski> often you may need such `undefined' tricks to get at the constituent types
03:28:13 <ski> you could probably use `ScopedTypeVariables' instead
03:28:41 <ski>      isFromInt (Reazione (f :: a -> b)) = typeOf (undefined :: Int) == typeOf (undefind :: a)
03:28:42 <ski> i.e.
03:29:04 <ski> (i suppose that's simpler)
03:29:29 * ski didn't think of that, at first
03:30:11 <Twey> Yay, conditional offer to Glasgow
03:30:40 <Saizan> ?
03:31:13 <zygoloid> Twey: i hear they have a compiler
03:31:26 <quicksilver> they compiler moved house long ago ;)
03:32:54 <Twey> Where's it developed now?
03:33:05 <zygoloid> cambridge
03:33:39 <Twey> Oh, okay
03:33:54 <Twey> Well, I applied there too.  :þ  Here's hoping
03:34:06 <zygoloid> cool, which college?
03:34:08 <earthy> actually, the compiler is at MSR
03:34:16 <earthy> rather than cambridge university
03:34:37 <Twey> zygoloid: Fitzwilliam
03:34:42 <zygoloid> earthy: cambridge is a place as well as a university :)
03:34:45 <paolino> ski: this is not working subtype (Reazione (f :: a -> b)) = typeOf (undefined :: a)
03:34:56 <earthy> zygoloid: I know that. ;) 
03:35:21 <paolino>     A pattern type signature cannot bind scoped type variables `a', `b'
03:35:21 <paolino>       unless the pattern has a rigid type context
03:35:32 * earthy just noted that 'applying to cambridge' does not necessarily bring you closer to the compiler in any other fashion than geological. :)
03:36:10 <quicksilver> earthy: I think it does.
03:36:19 <quicksilver> MSR cooperates closely with Cambridge university.
03:36:26 <ski> paolino : hm
03:37:11 <quicksilver> they organise seminars, summer schools, I think research students move between the two
03:37:44 <quicksilver> pretty sure they have joint grants.
03:38:23 * earthy sees SimonPJ being an external member of the Cambridge U Programming Research Group, so yeah.
03:38:24 <zygoloid> there's a reason that MSR is on the same site as the university's main compsci building
03:39:48 <quicksilver> the gossip was that MS wanted to recruit Roger Needham (the then-head of the cam computing lab) but he wouldn't leave cambridge.
03:39:51 <quicksilver> so they came to cambridge.
03:40:01 <Twey> Haha!
03:42:56 <ski> 7.8.7.4. Pattern type signatures <http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/other-type-extensions.html#pattern-type-sigs> : "However, in all patterns *other* than pattern bindings, a pattern type signature may mention a type variable that is not in scope; in this case, the *signature*brings*that*type*variable*into*scope*. This is particularly important for existential data constructors."
03:43:32 <ski> paolino : i would think that this would allow the `subtype (Reazione (f :: a -> b)) = ...' above ..
03:43:44 <ski> hm .. but maybe they only allow that if `b' is already in scope
03:44:05 <ski> paolino : try with `subtype :: forall b. Reazione b -> TypeRep'
03:46:06 <paolino> ski, it typecheck :)
03:48:22 <paolino> then b is the rigid type context ?
03:49:35 <ski> yeah
03:50:02 * ski thinks "rigid type variable" is a strange term
03:51:20 <quicksilver> they're called skolems in GHC 7.0 aren't they?
03:51:24 <quicksilver> not sure that's any more accessible ;)
03:51:34 <Twey> Skolems?  o.@
03:54:32 <Phyx-> Skolem variables are the same as rigid?
03:54:35 <Phyx-> didn't know that
03:55:27 <Saizan> rigid was from the wobbly/boxy/.. types papers, afaiu
03:56:27 <Twey> Why ‘skolem’?
03:56:32 <Phyx-> ah, I know the term Skolem, but the rigid eluded me
03:58:20 <quicksilver> it's a variable which was introduced by a logical rule
03:58:22 <Saizan> skolem is a logicians mostly known to students for a theorem that let you remove existential quantifications by introducing a new constant symbol, more or less
03:58:28 <quicksilver> and is required to be 'fresh'
03:58:32 <quicksilver> so you're not allowed to unify it.
03:58:34 <Twey> Aha
03:59:26 <quicksilver> exists-elimination and forall-introduction both use them
03:59:37 <lars9> is there anything like hashmap in haskell?
03:59:41 <quicksilver> in some formalisms, anyway.
03:59:44 <quicksilver> lars9: Data.Map
04:00:10 <Phyx-> quicksilver: well, it's allowed to unify to itself :P
04:00:41 <lars9> quicksilver: thanks
04:01:44 <Phyx-> isn't Data.Map a BST?
04:02:06 <quicksilver> yes.
04:02:11 <quicksilver> it is "something like hashmap"
04:02:18 <quicksilver> I didn't say it *was* a hashmap.
04:02:32 <Phyx-> lol, touche
04:02:43 <lars9> quicksilver: in dynamic programming, we need this a lot: f x = if x not in dic then dic[x] = f' x, return dic[x]; how to do it in haskell?
04:02:45 <quicksilver> because lars9 didn't give any indication he needed something which used a particular implementaiton.
04:04:11 <quicksilver> lars9: if member x dic then dic else insert x (f' x) dic
04:04:12 <dolio> lars9: You build a data structure with all the answers already in it, that references other parts of the data structure, and allow the Haskell runtime to only build the parts that are needed for the final answer.
04:04:35 <quicksilver> dolio's answer is better, although at a different level :)
04:04:52 <quicksilver> I was just addressing the mechanics of Data.Map, whilst dolio is telling you how to do dynamic programming in haskell.
04:06:29 <lars9> dolio: what data structure is suitable for this?
04:07:41 <Phyx-> anyone have a link to a paper about the new GHC 7 type checker?
04:07:44 <lars9> dolio quicksilver: when x's range is like [0...n], it's easy to build a listArray, but sometimes x is just an ad hoc thing like a string
04:08:06 <dolio> It depends on what type of input you're trying to do dynamic programming on, and on what range of values.
04:09:22 <quicksilver> quite often the answer is something like a Trie, though.
04:09:33 <quicksilver> q.v. MemoTrie on hackage
04:12:50 * Phyx- goes back to playing pokemon
04:13:30 <lars9> quicksilver: im reading MemoTrie, thanks
04:14:25 <maurer_> Alternatively, Memocombinators are easier for simple stuff.
04:17:55 * hackagebot timeplot 0.2.3 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.3 (EugeneKirpichov)
04:19:54 <ski> quicksilver : yeah .. "skolems" make more sense to me than "rigid"
04:21:50 * quicksilver doesn't find either of them inherently sensible.
04:21:55 <Saizan> they've replaced "inferred" with "actual" too
04:22:04 <Saizan> not sure how much i like that
04:22:05 <quicksilver> the most sensible word - to me - is "arbitrary"
04:22:12 <quicksilver> but that's not that great in context.
04:22:20 <quicksilver> at the end of the day it's all jargon.
04:22:48 <Saizan> well, the truth is that it's actually an object language type variable, rather than a meta-variable used to implement H-M
04:24:03 <quicksilver> Saizan: yes, that's a sensible view too
04:24:10 <quicksilver> but rather tied to a particular operational image
04:24:12 <thehaltingproble> hi
04:24:55 <thehaltingproble> i am just starting to learn haskell. found this book called learn yourself a haskell. is it good? or any other suggestions?
04:25:11 <nlogax> i like that one
04:25:19 <nlogax> @where RWH
04:25:19 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:25:24 <nlogax> also that one, thehaltingproble 
04:25:26 <Saizan> quicksilver: why operational? they are an explicit part of types
04:25:38 <thehaltingproble> thanks nlogax
04:27:49 <dolio> The problem with "skolem variable" is that most presentations of type theory don't use skolem variables.
04:29:55 <ski> well, in lambdaProlog, in `pi EA_EB \ has_type (lam EA_EB) (imp TA TB) :- pi EA \ has_type EA TA => has_type (EA_EB EA) TB.', `EA_EB' (and `TA' and `TB') could be said to be a logic variable, while `EA' is a skolem constant
04:30:21 <ski> so, variables universally quantified over the clause, or existentially quantified over the body would be logic variables
04:30:53 <ski> while variables universally quantified in the body would be skolems (and variables existentially quantified over clauses as well, if that was allowed)
04:32:00 <ski> (and skolems here act like "fresh", local, constructors, over their respective types)
04:33:14 <ski> (this is assuming `type lam (expr -> expr) -> expr.' and `type imp typ -> typ -> typ.')
04:34:10 <lars9> Data-MemoCombinator can not memorize Double? i see only integral and bool etc there
04:35:26 <Palmik> Prelude.foldr (\x acc -> Data.Map.insert 'c' x acc) Data.Map.empty [1,2,3,4,5]
04:36:37 <ski> > foldr (\x acc -> M.insert 'c' x acc) M.empty [1,2,3,4,5]
04:36:38 <lambdabot>   fromList [('c',1)]
04:37:14 <ski> Palmik : is that ^ the result you wanted ?
04:37:19 <Palmik> Nope :P
04:37:33 <ski> what did you want, then ?
04:37:53 <Palmik> more like fromList [('c',1),('c',2)..]
04:38:02 <Palmik> up to 5
04:38:36 <ski> well, each `Map Char Integer' only maps each `Char' to *at*most* one `Integer'
04:38:50 <Jafet> > fromList $ map (,'c') [1..5] :: Map Int Char
04:38:51 <lambdabot>   <no location info>: parse error on input `''
04:38:51 <ski> that's why it is a *map*, rather than a (binary) relation !
04:39:07 <Palmik> ah, you are right, my bad :)
04:40:01 <benmachine> Palmik: you could map 'c' to [1,2,3,4,5]
04:40:18 <ski> > M.fromList (map (flip (,) 'c') [1..5])
04:40:19 <lambdabot>   fromList [(1,'c'),(2,'c'),(3,'c'),(4,'c'),(5,'c')]
04:40:21 <benmachine> :t M.insertWith (++) . (:[])
04:40:22 <lambdabot> forall a a1. (Monoid a, Ord a1) => a1 -> a -> M.Map [a1] a -> M.Map [a1] a
04:40:24 <ski> > M.fromList (map ((,) 'c') [1..5])
04:40:25 <lambdabot>   fromList [('c',5)]
04:40:30 <benmachine> er
04:40:35 <Jafet> Oh, no tuplesections!
04:40:38 <benmachine> :t \k -> M.insertWith (++) k . (:[])
04:40:39 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k [a] -> M.Map k [a]
04:41:31 <Jafet> @vixen did you steal the identity of lambdabot?
04:41:31 <lambdabot> no, how dare you ask if i'm a bot!
04:42:23 <Palmik> I will probably use different data structure... I'm just doing some simple transitionalClosure for binary relations and I have relation as data Relation a = Relation ([a]) (Map a a)  which is no good for my purposes because of the "single value to one key" rule :)
04:43:23 <ski> maybe `Map a [b]' would be good enough for you ?
04:43:50 <ski> (btw, `([a])' is simpler written as `[a]')
04:50:38 <Eduard_Munteanu> Hi.
04:51:19 <lars9> quicksilver: It seems MemoTrie's performance is quit poor...
04:51:20 <lars9> fib 0 = 0
04:51:20 <lars9> fib 1 = 1
04:51:22 <lars9> fib n = mfib (n-2) + mfib (n-1) where mfib = memo fib
04:51:27 <lars9>  can not solve fib 50...
04:52:00 <Saizan> you shouldn't put mfib in a where
04:52:22 <lars9> Saizan: oh yeah, it works now
04:53:51 <ski>   (memo -> fib) = \n -> case n of
04:53:55 <ski>     0 -> 0
04:53:58 <ski>     1 -> 1
04:54:03 <ski>     _ -> fib (n-2) + fib (n-1)
04:54:58 * ski thinks that's somehow nicer .. it would be better if one could use multiple equations there, though
04:58:20 <aristid> ski: that works?
04:58:40 <aristid> it desugars to fib = memo $ \n -> case n of ... ?
04:59:21 <ski> yes
04:59:29 <ski> i'm not sure whether it is intensional, though
05:00:05 <ski> i suspect it is an artefact of that being a pattern-binding, which they presumably reuse for `x' in 'f x = ...'
05:00:47 <ski> (you need to enable `ViewPatterns' of course)
05:01:34 <aristid> sure
05:01:49 <aristid> ski: somehow i don't think it's a big improvement over fib = memo $ \n ...
05:01:57 <ski> yeah, better would be
05:02:02 <ski>   (memo -> fib) 0 = 0
05:02:05 <ski>   (memo -> fib) 1 = 1
05:02:10 <ski>   (memo -> fib) n = fib (n-2) + fib (n-1)
05:02:21 <aristid> or better yet
05:02:27 <aristid>   (memo -> fib) 0 = 0
05:02:31 <aristid>            1 = 1
05:02:58 <aristid>            n = fib (n - 2) + fib (n - 1)
05:03:00 <ski> that looks really strange ..
05:03:09 <aristid> yeah :D
05:03:13 <ski> would you condone
05:03:18 <ski>   length [    ] = 0
05:03:27 <ski>          (_:as) = 1 + length as
05:03:29 <ski> as well ?
05:04:00 <ski> (btw, this somehow reminds me of Agda2's `with' and `...' syntax)
05:04:16 <aristid> ski: maybe a different syntax with placeholders?
05:04:21 <aristid> (memo -> fib) 0 = 0
05:04:26 <aristid> $ 1 = 1
05:04:35 <aristid> $ n = fib (n - 2) + fib (n - 1)
05:04:42 <ski> i'm not sure i like that either
05:04:54 <aristid> it would be more parseable
05:04:57 <ski> i'd like to be able to read each equation separatedly
05:05:12 <aristid> but then you repeat the (memo -> fib) and i do not like that AT ALL
05:05:24 <ski> well, you repeat `length' as well, currently
05:05:32 <aristid> length is just a name tho
05:05:37 <ski> granted
05:05:38 <aristid> that's not that bad
05:05:51 <ski> another approach would be something like
05:05:52 <lars9> when compiling a program using "import Data.MemoTrie", it's reported: 10996.o: In function `rJS_info':
05:05:56 <lars9> (.text+0x176): undefined reference to `MemoTriezm0zi4zi9_DataziMemoTrie_zdfHasTrieZMZN_closure'
05:05:59 <ski>   {-# MEMO fib #-}
05:06:25 <lars9> but i can load it in ghci
05:06:27 <ski> (the Melbourne Mercury Compiler has a pragma for memoizing predicates and functions)
05:06:37 <zygoloid> let fib 0 = 0; fib 1 = 1; (memo -> fib) n = fib (n - 2) + fib (n - 1) in fib 20
05:06:37 <aristid> ski: or {-# VIEW memo fib #}
05:06:44 <Jafet> lars9, --make
05:07:10 <ski> aristid : i'm not sure i understand what the semantics of `VIEW' pragma would be ..
05:07:22 <lars9> Jafet: thanks it compiles now, why we need a --make now?
05:07:26 <aristid> ski: well, just wrap the whole thing in a memo
05:07:41 <zygoloid> [desugaring to: let fib n = case n of 0 -> 0; 1 -> 1; n -> memo (\n -> fib (n-2) + fib (n-1)) n]
05:07:47 <Jafet> lars9: it tells ghc to resolve linking dependencies.
05:07:47 <ski> zygoloid : that's *very* strange .. only `memo'izing the resulting function, if the argument is not `0' or `1'
05:07:55 <aristid> f x y = z becomes f = memo $ \x y -> z
05:08:06 <lars9> Jafet: thanks
05:08:10 <zygoloid> ski: strange, but implementable i think
05:08:15 <ski> zygoloid : also, it would be useless
05:08:21 <zygoloid> ski: how so?
05:08:30 <lars9> Jafet: why it's not needed when not using MemoTrie?
05:08:55 <zygoloid> ski: the desugaring isn't quite right. the memo (...) part should be lifted to a CAF
05:08:59 <ski> zygoloid : it is building a separate lookup-table, for each time the recursive clause is used
05:09:02 <Jafet> lars9: no idea
05:09:14 <ski> zygoloid : well, that's a completely different thing :)
05:09:25 <Jafet> In principle, ghc could require it if you use any library
05:09:26 <zygoloid> ski: only operationally :)
05:09:45 <lars9> Jafet: i see, thanks
05:09:55 <ski> zygoloid : afaiu, GHC (almost ?) never does that kind of lifting, because it can lead to space leaks
05:10:17 <zygoloid> ski: sure. as i said, i got the desugaring wrong. but it's denotationally correct i think
05:10:50 <ski> aristid : ok. so why the word `VIEW', then ?
05:11:20 <ski> zygoloid : yeah .. but memoizing is about the operational working ..
05:11:48 <zygoloid> ski: sure, as i said, i got the desugaring wrong.
05:12:16 <zygoloid> and views are much more general than just memoization, of course
05:12:20 <ski> what if you have several recursive clauses ?
05:12:35 <zygoloid> then this doesn't help you
05:12:39 * ski fails to understand what this has to do with views ..
05:12:58 <zygoloid> or at least you have to resort to writing the case by hand
05:13:08 <aristid> ski: because it's like a view pattern on the left-most thingie
05:13:20 <ski> hm .. maybe you mean that in `VIEW v x', if `x :: a', then `v :: a -> a' must be the case ?
05:13:22 <aristid> ski: it's like (memo -> f) = \x y -> z
05:13:45 <ski> i suppose one could call that an endo-view
05:13:58 <aristid> haha
05:14:14 <ski> but general views can use different types for the domain and codomain .. so i don't think the word `VIEW' is warranted, here
05:14:52 <zygoloid> consider: length [] = 0; (fix -> length) l (x:xs) = l xs + 1
05:15:59 <ski> hm, this is where the lack of a declarative semantics for view patterns bites me
05:16:09 <Eduard_Munteanu> Does 'do' notation use anything else besides (>>=) when desugared?
05:16:20 <ski> Eduard_Munteanu : `fail', in some cases
05:16:30 <Jafet> It may use (>>)
05:16:30 <ski> @undo do True <- a; b
05:16:30 <lambdabot> a >>= \ c -> case c of { True -> b; _ -> fail ""}
05:16:39 <Eduard_Munteanu> Oh.
05:16:41 <zygoloid> desugaring to something like: length'0 [] = 0; length'1 l (x:xs) = l xs + 1; length xs = case xs of [] -> length'0 xs; _ -> fix (\l (x:xs) -> l xs + 1) xs
05:17:10 <zygoloid> ok, i got that wrong again ;)
05:17:27 <zygoloid> i think it's ok so long as the view pattern is on the last definition.
05:17:52 * zygoloid thinks this half-baked idea sucks :)
05:18:49 <Eduard_Munteanu> Because I'm trying to hack in a 'codo' notation like this: http://paste.pocoo.org/show/283069/
05:18:55 <Eduard_Munteanu> And it doesn't really make sense after all.
05:19:51 * ski doesn't think `do' makes sense for comonads ..
05:20:33 <Eduard_Munteanu> It seems '<-' still has some extracting semantics, doesn't make much sense.
05:21:07 <ski> some kind of special syntax for comonads needs to focus a lot more on the environment, and on patterns, rather than on expressions
05:22:21 <Eduard_Munteanu> Yeah, I at least got to a point where I could experiment with it without hacking GHC itself. :)
05:22:30 <Eduard_Munteanu> I'm satisfied I put my concerns to rest.
05:27:28 <ski> the `do'-notation, in some partial sense, allows one to work in the Kleisli-category of a monad
05:27:49 <ski> for a comonad, one'd need something corresponding to the coKleisli-category
05:28:27 <quicksilver> isn't the do notation mostly just syntax sugar for the pattern ( .... ) >>= (\x -> \n
05:28:32 <ski> dataflow languages like Lucid could probably be said to have (a specific kind of) comonad-side-effects
05:28:50 <ski> well, hence the "partial"
05:28:54 <quicksilver> (which was an idiom that was quite widely used just as people were getting the hang of this stuff)
05:29:12 <quicksilver> well, then the question to ask is, if you're writing comonad stuff by hand
05:29:22 <quicksilver> is there anything equivalently ugly you'd like to sugar?
05:29:41 <ski> the pattern that recurs again and again is `wa =>> \wa -> ..(extract wa)..'
05:30:25 <quicksilver> sounds like you want to sugar that as x <<- wa; .... (x) ....
05:30:26 <ski> (or sometimes `foo wa' instead of having `extract wa', i suppose)
05:31:20 <roconnor> isn't the composition of a monad and a commonad an arrow?
05:31:23 <Eduard_Munteanu> Well, is 'extract' actually Haskell?
05:31:35 <Eduard_Munteanu> I thought it was in terms of binding.
05:31:39 <ski> yeah, but i'm not sure it is as common to write long chains of `=>>' as it is for `>>='
05:31:46 <roconnor> oh =>>
05:31:55 <ski> Eduard_Munteanu : `extract' is what you called `coreturn'
05:32:09 <Eduard_Munteanu> Oh, like edwardk calls it.
05:32:15 <ski> yeah
05:32:30 * ski thinks `extract' is a better name
05:32:50 <Eduard_Munteanu> For a programming language, sure.
05:33:13 <ski> (for `cojoin', i've tentatively settled on `scaffold')
05:33:28 <Eduard_Munteanu> CT-wise, I found 'co-' more comfortable.
05:33:39 <Eduard_Munteanu> (and cobind :) )
05:33:49 <ski> it gets tiresome after a while, if you use it heavily, i think
05:34:14 <Eduard_Munteanu> Yeah, scaffold sounds fine.
05:35:35 <Eduard_Munteanu> Mmm... I think my "<-" should repack the value into a comonad.
05:35:58 <Eduard_Munteanu> Anyway, it sucks, I agree.
05:35:58 <ski> s/comonad/comonadic value/
05:36:04 <Eduard_Munteanu> Yes, sorry.
05:36:10 <ski> for a comonadic syntax, i think `class Zippable f where zip :: f a -> f b -> f (a,b)' is probably useful, as well
05:36:27 <ski> (to handle the multiple parts of environments)
05:37:25 <Eduard_Munteanu> Hm yes.
05:38:05 <ski> (you can `unzip' if you have a functor)
05:38:08 <Twey> A comote!
05:38:27 <ski> @type fmap fst &&& fmap snd
05:38:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> (f a, f b)
05:38:32 <kmc> cocoa coated co-cones
05:38:49 <Eduard_Munteanu> I wonder if it makes more sense to translate do syntax in terms of Kleisli arrow composition.
05:38:49 <ski> kmc : sounds yummy ! :)
05:39:01 <Twey> :t on (&&&) fmap fst snd
05:39:02 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (b, b) -> (f b, f b)
05:39:04 <Eduard_Munteanu> I.e. translating >=> to comonadic counterparts.
05:39:06 <Twey> :<
05:39:19 * ski doesn't think it makes sense to start out from `do'-notation at all ..
05:39:20 <Eduard_Munteanu> Cojones?
05:39:58 <ski> (it is heavily biased towards monads, and isn't really *that* good for monads either, imho)
05:40:00 <Twey> Hm… is (=>>) :: w b -> (w b -> a) -> w a ?
05:40:08 <ski> yeah
05:40:09 <Twey> I have trouble imagining co-bind
05:40:12 <Eduard_Munteanu> :t (>=>)
05:40:13 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:40:23 <Twey> Are you supposed to flip the arrow in the function argument too?
05:40:31 <ski> Twey : `flip fmap' and "select the diagonal"
05:40:51 <ski> hm, no, that's wrong
05:40:56 <ski> (monads confusing me)
05:41:01 <Eduard_Munteanu> So (=>=) :: Comonad w => (w a -> b) -> (w b -> c) -> w a -> c
05:41:17 <ski> it's rather, "tailize" and `flip fmap'
05:41:25 <meditans> I have a question about learning sources: where can I found examples in which a problem is developed in a functional (functors, monoids, monads) approach?
05:41:36 <Twey> ‘Tailize’?
05:41:39 <Martty> @rwhs
05:41:39 <lambdabot> Unknown command, try @list
05:41:42 <Twey> meditans: Maybe Real World Haskell?
05:41:47 <Twey> @where rwh
05:41:47 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:42:16 <ski> well, for streams (corresponding to anti-causal stream transformers) it's basically `tails'
05:42:17 <kmc> meditans, i wouldn't call that simply "functional approach", those concepts don't show up very often in Scheme or ML
05:42:25 <Twey> Oh right
05:42:41 <kmc> meditans, in Haskell we have some general APIs for things that are used as latent patterns in other languages
05:43:06 <ski> for a tree with elements in the leaves, it is "replace each element with the sub-tree starting from that node"
05:43:34 <meditans> twey: Yes, but those examples (real world haskell) are too real, i'm searching just a few good examples
05:43:45 <kmc> to me "functional approach" is not about particular APIs you use but is about writing pure functions and composing them to solve your problem
05:43:47 <ski> kmc : though, there are libs in the MLs which uses monads
05:44:23 <Eduard_Munteanu> I wonder if comonads can be coaxed into maintaining state. Seems doable to me.
05:44:23 <meditans> kmc: you are right.. should I call it Haskell approach?
05:44:28 <kmc> maybe *shrug*
05:45:06 <ski> Eduard_Munteanu : maybe with uniqueness typing ..
05:45:14 <Eduard_Munteanu> More so with comonadic functions like w a -> b where the monad can encapsulate state.
05:45:38 <Eduard_Munteanu> I'll look that up.
05:48:29 <Eduard_Munteanu> runCoReader f env = f (Environment env); f :: Environment -> a, f env = do_something $ ask env ...
05:48:43 <Eduard_Munteanu> Seems simpler than the monadic counterpart.
05:49:07 <ski> Eduard_Munteanu> :t runCoReader
05:49:40 <Eduard_Munteanu> runCoReader :: Comonad w => (w a -> b) -> a -> b
05:50:07 <dolio> That can't be right.
05:50:43 <dolio> @djinn ((r, a) -> b) -> a -> b
05:50:44 <lambdabot> -- f cannot be realized.
05:50:48 <ClaudiusMaximus> i read coaxed as co-axed there, Eduard_Munteanu 
05:50:58 <Eduard_Munteanu> Oh, no :)
05:51:01 <ClaudiusMaximus> too much co...
05:51:18 <Eduard_Munteanu> dolio: I just provided a definition ^
05:51:33 <Eduard_Munteanu> Kinda makes sense to me.
05:51:47 <Eduard_Munteanu> Well, maybe 'w' is too generic.
05:52:05 <Eduard_Munteanu> runCoReader :: (Environment a -> b) -> a -> b
05:53:11 <dolio> What is Environment?
05:53:13 <ski>   Environment  ~=  Identity  -- ?
05:53:43 <Eduard_Munteanu> dolio: a functor used to encapsulate the reader environment.
05:53:50 <Eduard_Munteanu> ski: yes.
05:53:54 <Eduard_Munteanu> Maybe it's existential
05:54:06 * ski stares blankly
05:54:10 <Eduard_Munteanu> So you can only pack and unpack it using 'ask'/'local'.
05:54:25 <Eduard_Munteanu> (well, coask/colocal :P)
05:54:30 <dolio> All I know is that CoReader r a = (r, a).
05:55:08 <Eduard_Munteanu> dolio: I don't think it's necessarily to follow the same pattern as in the monadic Reader.
05:55:09 <dolio> And ((r, a) -> b) -> a -> b doesn't have an implementation that doesn't use _|_.
05:55:19 * ski isn't sure `CoReader' is a sensible name, but `CoReader r' there is anyway a left adjoint to `Reader r'
05:55:48 <Eduard_Munteanu> Oh, it's not CoReader r a, it's CoReader r.
05:56:49 <ski> operations from `a' to `b', which use monadic effects from `m', is represented with `a -> m b'
05:57:01 <ski> operations from `a' to `b', which use comonadic effects from `w', is represented with `w a -> b'
05:57:43 <ski> and this `w' should have operations like `extract :: forall a. w a -> a',&c.
05:58:30 <ski> Eduard_Munteanu : maybe you're doing something else, but i was expecting you to provide something like `extract :: forall a. Environment a -> a', at least ..
05:58:39 <ski> .. otherwise, what's the connection with comonads ?
05:58:55 <Darkone> Also, yesterday I was asking about parsing with a delimiter, and swore I had seen it, and someone pointed out split? Yea, I just wasn't looking in the right place in LYAHFGG:P
05:59:25 <Darkone> It's in Data.Bytestring :V
05:59:33 <Eduard_Munteanu> ski: you'd thread state by cobinding.
05:59:44 <Eduard_Munteanu> ski: ask is extract
06:00:01 * ski doesn't really understand
06:00:23 <Eduard_Munteanu> s/state/read-only state/
06:01:22 <ski> oh .. s/read-only state/environment/ you mean :)
06:01:32 <Eduard_Munteanu> Yes, just like Reader.
06:02:23 <Eduard_Munteanu> Well, a comonadic Reader, because it made sense to me having 'w a' as an argument to encapsulate data.
06:02:44 <Eduard_Munteanu> No 'do' syntax though.
06:04:33 <Darkone> So, writing a short prog to parse a TShips.txt, should I care about LAzy bytestring vs strict at all? Only going to handle about 600 ships, or 500kb of txt
06:04:50 <Darkone> Not even touching half of it :P
06:05:46 <Twey> Darkone: I probably wouldn't…
06:06:05 <Nibble> Easy change
06:06:15 <Nibble> basically you just need to change the import
06:06:19 <Darkone> Yea, I'm new to this but I was like "So... I want to load some strings... do some math... and write some stri- hoolycraphaskell!"
06:07:13 <ricree> I'm playing around a bit with HDBC and sqlite3.  I'm a bit confused about how to most effectively work on the data returned by a query.  In this particular case, I'm trying to reduce the result of several queries into a single number.  I think I want to wind up with a function that looks like "[m a] -> m a".  assuming I have a function "[a] -> a", how do I wind up with one that works on the data returned from a query?  Or am I on the w
06:07:13 <ricree> rong track with this altogether?
06:07:40 <Jafet> Haskell, where you can do it in one line without having to reinvent integer arithmetic in a term rewriting language
06:07:49 <ski> @type sequence
06:07:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:07:55 <Twey> ricree: fmap sum . sequence
06:07:58 <ski> ricree : that might be useful
06:08:11 <ricree> thank you
06:08:16 <Twey> F'r example
06:08:53 <Twey> :t fmap sum . sequence
06:08:54 <lambdabot> forall a (f :: * -> *). (Num a, Functor f, Monad f) => [f a] -> f a
06:09:30 <Jafet> In a perfect world, Functor f would be redundant
06:09:42 <benmachine> well you can use liftM
06:09:56 <benmachine> but in practice every Monad has a Functor instance anyways
06:10:11 <benmachine> so the only drawback is more verbosity
06:10:19 <benmachine> actually
06:10:25 <benmachine> in a perfect world it would be defined
06:10:29 <Jafet> @pl \f -> liftM f []
06:10:29 <lambdabot> const []
06:10:32 <ski> in some cases, the difference matter
06:10:34 <benmachine> :t fmap sum . Data.Traversable.sequenceA
06:10:34 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => [f a] -> f a
06:10:47 <ski> (consider `data Foo = forall m. Monad m => MkFoo (..m..)')
06:10:48 <Jafet> That was a surprising @pl
06:10:52 <Jafet> @pl \f -> liftM f [1]
06:10:53 <lambdabot> flip fmap [1]
06:11:06 <Twey> So it is
06:11:12 <benmachine> :t fmap Data.Foldable.sum . Data.Traversable.sequenceA
06:11:12 <lambdabot> forall (t :: * -> *) a (f :: * -> *). (Data.Traversable.Traversable t, Num a, Applicative f) => t (f a) -> f a
06:11:25 * ski wonders why `const' isn't a Caleskell alias for `return'/`pure' ..
06:11:40 <benmachine> ski: the name kinda says what it is
06:11:49 <benmachine> which is not so much the case for (.) or (++)
06:11:54 <Jafet> :t pure :: a -> b -> b
06:11:55 <lambdabot>     Couldn't match expected type `a' against inferred type `b'
06:11:55 <lambdabot>       `a' is a rigid type variable bound by
06:11:55 <lambdabot>           an expression type signature at <interactive>:1:8
06:11:56 <Twey> Oh, but smart!
06:12:07 <Jafet> :t pure :: a -> b -> a
06:12:07 <benmachine> :t pure :: a -> b -> a
06:12:08 <lambdabot> forall a b. a -> b -> a
06:12:08 <lambdabot> forall a b. a -> b -> a
06:12:11 <Jafet> Err
06:12:13 * ski grins
06:12:13 <Twey> \f -> liftM f [] = flip liftM [] = flip fmap []… and fmap _ [] = [], so const []
06:12:17 <Cale> ski: I only replaced a couple of definitions anyway, but that's not a terrible idea.
06:12:39 <Twey> *pride*
06:12:41 <ski> Cale : i was thinking it might be sensible, at least ..
06:12:42 <Twey> Took me a while to work that one out :þ
06:12:46 <benmachine> Cale: you know, more polymorphism isn't *always* a good thing >_>
06:13:00 <Jafet> Polymoarphism
06:13:02 <djahandarie> Moar!
06:13:03 <Cale> MOAR POLYMOARPHISM
06:13:06 <Eduard_Munteanu> :))
06:13:08 <Twey> Hmm, but is it return or is it pure?
06:13:14 <Twey> If only we had a Pointed…
06:13:20 <djahandarie> This looks like a job for...
06:13:27 <djahandarie> CATEGORY EXTRAS
06:13:31 <Twey> Isn't there an alternative Prelude that uses Pointed and stuff?
06:13:31 <benmachine> Twey: if only Applicative was a superclass of Monad, you mean >_>
06:13:36 <benmachine> pointed is sort of orthogonal
06:13:41 <benmachine> never been that convinced it's useful
06:13:55 <Twey> benmachine: Well, it helps for the whole ‘one typeclass, one feature’ thing
06:14:09 <benmachine> Twey: yes but I've never been convinced that thing is a good thing :P
06:14:25 <benmachine> Twey: there should be as many type classes as are needed and no more, imo
06:14:26 <Twey> benmachine: But if you don't, you end up with Num!
06:14:33 <Twey> benmachine: You don't want to end up with Num, do you?!
06:14:36 <benmachine> :O
06:14:46 <benmachine> well, Num is fewer than needed :P
06:14:51 <Twey> Heheh.
06:15:08 <benmachine> admittedly my policy might have made Num originally
06:15:17 <benmachine> this is why we need class aliases, perhaps
06:15:23 <Eduard_Munteanu> class (Applicative a, Failable a, Returnable a, Joinable a) => Monad a ? :)
06:15:34 <benmachine> or superclass defaults would do it I think
06:16:01 <benmachine> Eduard_Munteanu: just make it Applyable and Mappable while you're at it >_>
06:16:18 <Jafet> Eduard, do you need help inventing ML?
06:16:35 <Eduard_Munteanu> Heh, I'm not familiar with ML. Is it like that?
06:16:55 <Eduard_Munteanu> It's not a really bad idea, just don't take it to extreme.
06:16:55 <Jafet> No, but it is the logical conclusion of that
06:17:31 <Twey> Eduard_Munteanu: Needs more class aliases :þ
06:17:38 <benmachine> I wonder how often foldable and traversable are used on non-lists
06:18:13 <benmachine> Twey: am I right in thinking that superclass defaults alone could more or less subsume class aliases?
06:18:22 <benmachine> hmm
06:18:29 <benmachine> no
06:18:36 <ski> Eduard_Munteanu : s/=>/<=>/, please
06:18:40 <benmachine> unless you have a weird idea of what superclass defaults are
06:18:49 <Jafet> Ah, ski beat you to inventing ML.
06:18:51 <Twey> Not actually sure
06:19:01 <ski> Jafet : .. i did ?
06:19:01 <Eduard_Munteanu> Heh.
06:19:14 <benmachine> basically we want it so that instance Num n where ... also instantiates FromInteger n and Ring n and whatever else
06:19:41 <benmachine> which isn't currently possible.
06:19:52 <ski> *nod*
06:20:06 <Eduard_Munteanu> Ring would be nice.
06:20:24 <benmachine> do we also want you to be able to instantiate Ring and then Num on top of that?
06:20:27 <benmachine> I would guess so
06:20:32 <benmachine> that's where it gets tricky
06:20:33 <ClaudiusMaximus> benmachine: i used foldable/traversable for a directory tree alike here: http://gitorious.org/binembed/binembed/blobs/master/Data/BinEmbed.hs
06:21:02 <benmachine> ClaudiusMaximus: neat!
06:21:24 <quicksilver> benmachine: I have used the foldable/traversable instance for Data.Sequence
06:21:41 <quicksilver> (along with the Functor instance they provide a lot of basic necessary functionality)
06:21:50 <benmachine> ah right
06:21:57 <benmachine> so in answer to my question, moderately often
06:22:00 <benmachine> well, good.
06:22:15 <quicksilver> they're the haskellish version of ListLike
06:22:22 <quicksilver> ListLike being very unhaskellish ;)
06:22:30 <benmachine> heh
06:22:39 * ski . o O ( `ListUnlike' ? )
06:22:42 <benmachine> ListLike accommodates bytestrings though
06:22:52 <benmachine> which is nice sometimes
06:24:21 <quicksilver> yes
06:24:31 <quicksilver> that's quite true.
06:24:32 <Eduard_Munteanu> It'd be nice to write stuff like 'fold (foo) bar (postOrder tree)', so I guess foldable trees make sense if you can lazily switch traversal representations.
06:25:02 <quicksilver> benmachine: Ideally you'd have generalisation of Foldable using type functions.
06:25:16 <quicksilver> associated types.
06:25:20 <benmachine> hmm
06:25:36 <quicksilver> the 'point' is that Foldable things are forced to express their members as a type parameter
06:25:42 <quicksilver> [Char], Seq Char
06:25:51 <quicksilver> ByteString is of the wrong form.
06:25:52 <benmachine> ah right
06:26:11 <benmachine> even though strictly speaking Foldable is a subset of Functor, so it's not in general required to be parametric?
06:26:21 * benmachine is using his words a bit oddly
06:26:32 <quicksilver> If you could do class Foldable0 x where type member :: *; toList :: x -> [member];
06:26:43 <benmachine> but in principle ByteString could implement a Foldable-like interface, whereas for example Traversable ByteString wouldn't make any sense
06:26:47 <quicksilver> Foldable doesn't really require Functoriality/parametricity to work.
06:27:14 <benmachine> so, yeah, that would be nice
06:27:20 <quicksilver> 'toList' tells you everything about Foldable, pretty much.
06:27:32 <benmachine> mm
06:27:57 <benmachine> I wonder what extensions base needs to compile
06:27:59 <quicksilver> Traversable would be much harder, though.
06:28:08 <quicksilver> base is haskell98, I believe
06:28:29 <quicksilver> in API even if not in implementation.
06:28:46 <benmachine> hmm
06:29:00 <benmachine> there are rank-2 types in base, at least
06:29:12 <quicksilver> where?
06:29:12 <benmachine> even if rank-2 types aren't required to use them, as it were
06:29:21 <benmachine> I was thinking Typeable and Data
06:29:30 <benmachine> and Dynamic possibly
06:29:35 <benmachine> and Control.Exception (similar idea)
06:29:50 <quicksilver> Typeable doesn't have rank 2 types in its API
06:30:04 <quicksilver> it coul dbe implemented as a compiler primitive without using rank 2 types
06:30:12 <quicksilver> (if your compiler actually had run time type information)
06:30:13 <benmachine> right
06:30:16 <benmachine> but what about Data?
06:30:19 <Darkone> Bytestring implements just about every function list does right? Like intercalate? :P
06:30:20 <quicksilver> Control.Exception is not in base
06:30:26 <quicksilver> and neither is Data
06:30:29 <benmachine> quicksilver: http://hackage.haskell.org/package/base
06:31:03 <quicksilver> ok, but the 'tricky' bit of Control.Exception is in extensible-exceptions
06:31:11 <benmachine> extensible-exceptions is basically in base
06:31:15 <quicksilver> hmm
06:31:24 <benmachine> it only exists now so you can have the same mechanism with base3
06:31:26 <quicksilver> you're right, though, SomeException is in base.
06:31:27 <benmachine> that is my understanding
06:31:34 <quicksilver> so base isn't h98 any more.
06:32:11 <quicksilver> benmachine: OK, I don't know the correct answer to your question ;)
06:32:17 <benmachine> http://hackage.haskell.org/packages/archive/base/4.2.0.2/base.cabal FlexibleInstances is in here too, I wonder why
06:33:47 * quicksilver ponders a Functor0 class
06:34:16 <benmachine> fmap0 :: (Elem a -> Elem a) -> a -> a?
06:34:27 <quicksilver> no
06:34:31 <quicksilver> hmm
06:34:32 <lars9> in main = do ..., how to write this: args <- getArgs; if args == [] then interact proc else print (show args) 
06:34:32 <quicksilver> yes
06:34:44 <Darkone> Uhhm
06:34:46 <lars9> if...else... seems not working here?
06:34:46 <Axman6> fmap0 :: (a -> b) -> f -> f?
06:34:53 <quicksilver> no.
06:35:06 <Darkone> With a bytestring, how do I convert something to Word8? Would I have to jsut look it up?
06:35:20 * Axman6 hasn't been paying attention
06:35:24 <benmachine> Axman6: fmap0 ord . fmap0 ord typechecks :P
06:35:29 <quicksilver> fmap0 :: (a ~ Elem f, g ~ Elem b) => (a -> b) -> f -> g
06:35:39 <quicksilver> fmap0 :: (a ~ Elem f, b ~ Elem g) => (a -> b) -> f -> g
06:35:41 <quicksilver> is what I meant
06:35:48 <quicksilver> but I think it doesn't make sense
06:35:54 * Axman6 -> sleep
06:35:56 <benmachine> that'd have to be an MPTC surely
06:36:28 <benmachine> lars9: you might have the indentation wrong, can you put the code on hpaste.org?
06:36:47 <benmachine> lars9: you are allowed to use if/then/else in do, if it is indented correctly
06:38:17 <benmachine> quicksilver: maybe (ElemOf f a, ElemOf f b) => (a -> b) -> f -> f
06:38:57 <benmachine> no that doesn't really work either
06:39:09 <EvanR-work> does it make sense to define a monad of type M a that wont use the a
06:39:14 <lars9> benmachine: thanks, i'll adjust the indent first
06:39:24 * ski wonders whether `a ~ Elem f => ..a..' is used because `Elem' is partial ..
06:39:43 <EvanR-work> evalState comes to mind as a use case, Exit another
06:40:14 <benmachine> EvanR-work: if your monad doesn't use the parameter it's a trivial monad; the only use case I can think of is abusing do-notation
06:40:17 <EvanR-work> if you wanted to do nothing but sequence monadic actions is there a more obvious solution
06:40:21 <ski> EvanR-work : how do you mean ?
06:40:35 <ski> maybe you want a `Monoid' ?
06:40:48 <benmachine> EvanR-work: if you just wanted to sequence functions that transformed a state, you could just compose ordinary functions
06:40:50 <EvanR-work> yes maybe Monoid
06:40:55 <quicksilver> if your monad doesn't use a parameter is a Monoid, yes.
06:41:08 <quicksilver> a well known example is Put () from Data.Binary
06:41:16 <EvanR-work> composing functions being the substrate
06:41:20 <benmachine> I always thought Put was silly
06:41:23 <quicksilver> it's a Monad for symettry with Get a but it's actually just a Monoid.
06:41:25 <quicksilver> it is silly :)
06:42:09 <EvanR-work> S -> S for instance
06:42:22 <benmachine> EvanR-work: just compose them
06:42:23 <EvanR-work> mappend = (.)
06:42:23 <quicksilver> "Endo S" as the monoid is known.
06:42:34 <benmachine> yeah
06:43:00 <benmachine> :t appEndo . Data.Foldable.foldMap Endo
06:43:01 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> a -> a
06:43:50 <EvanR-work> Endo? ive asked about this before, how is it useful above and beyond (.) ?
06:44:14 <benmachine> EvanR-work: it allows using Monoid functions like mconcat
06:44:22 <ski> `Writer (Endo S)' ?
06:44:28 <Twey> But we don't have pretty sugar for Monoids!
06:44:38 <EvanR-work> mconcat [a,b,c,d,e] ;)
06:44:39 <benmachine> or foldMap like I did up there, which makes the newtype wrapping/unwrapping relatively painless
06:44:43 <EvanR-work> [a
06:44:44 <EvanR-work> ,b
06:44:45 <EvanR-work> ,c
06:44:46 <EvanR-work> ,d]
06:44:54 <benmachine> EvanR-work: yeah, that's what I'd do
06:44:56 <benmachine> if not just
06:45:00 <benmachine> f . g .
06:45:04 <benmachine> c . d .
06:45:08 <benmachine> otherFunction .
06:45:10 <benmachine> whatever
06:45:12 <quicksilver> yes, although I would not be opposed to a simple extension which let you use whitespace for `mappend`
06:45:21 <Twey> I guess
06:45:23 <Twey> quicksilver: Yeesh
06:45:25 <benmachine> quicksilver: :O how would that work
06:45:33 <Twey> quicksilver: What about function monoids?
06:45:35 <quicksilver> exactly like do
06:45:39 <benmachine> ah
06:45:44 <benmachine> you mean explicitly introduced :P
06:45:44 <quicksilver> except >>  becomes mappend
06:45:47 <quicksilver> and <- doesn't work
06:45:52 <quicksilver> yes, explicitly introduced.
06:45:55 <benmachine> that's significantly less crazy than it sounded at first
06:45:55 <Twey> Oh, okay
06:46:00 <Twey> Yes :þ
06:46:09 <quicksilver> benmachine: that's me in a nutshell.
06:46:12 <benmachine> :D
06:46:13 <quicksilver> Twey: I don't think it's very important.
06:46:25 <quicksilver> but an awful lot of people think it's worth abusing Monads in this way
06:46:29 <Twey> Mm
06:46:30 <quicksilver> so there is obviously some demands for it
06:46:31 <lars9> how to convert an Int to Integer?
06:46:34 <quicksilver> blazehtml does, doesn't it?
06:46:37 <quicksilver> lars9: fromIntegral
06:46:41 <lars9> thanks
06:46:46 <EvanR-work> ah thats what i wanted to know, if anyone does it
06:46:48 <quicksilver> as well as the previously mentioned Put ()
06:46:59 <ski> lars9 : better is to use an `Integer' to begin with, though
06:47:02 <EvanR-work> and they do it because Monoid doesnt have special syntax
06:47:06 <quicksilver> and I have a vague notion some part of yesod does
06:47:10 <ski> (lars9 : see `genericLength', &c.)
06:47:12 * benmachine wonders if the Const newtype from Control.Applicative does this
06:47:47 <lars9> ski: sorry i dont get it, could you please tell me what is "Integer to begin with"?
06:48:16 <benmachine> lars9: wherever you're getting that Int from, see if you can persuade it to give you an Integer instead
06:48:39 <benmachine> the Const newtype seems not to have a monad instance
06:48:46 <benmachine> but I reckon it could do
06:49:03 <ski> lars9 : in some cases you get an `Int' e.g. because you used `length'. if you had used `genericLength', you probably wouldn't have needed to convert from `Int' to `Integer', since you would have gotten `Integer' from the start (if that's what you wanted)
06:49:17 <ski> lars9 : i just figured you case *might* be a case like this
06:49:40 <ski> > length "foo" * (2 :: Integer)
06:49:41 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
06:49:41 <lambdabot>         against inferred type ...
06:49:46 <ski> > genericLength "foo" * (2 :: Integer)
06:49:46 <lambdabot>   6
06:50:17 <lars9> ski: benmachine: that helps!
06:50:40 * ski smiles
06:50:41 <lars9> by the way, MemoTrie is so handy for dynamic programming problems...
06:51:30 <EvanR-work> whats dynamic programming
06:51:32 <lars9> and it's source code is so short, amazing. i don't understand it though right now. ;D
06:51:52 <lars9> EvanR-work: to memorize results
06:53:16 <Eduard_Munteanu> Actually it's a hill-climbing class of algorithms.
06:53:30 <quicksilver> EvanR-work: dynamic programming is avoiding repeated work by only evaluating solutions to sub-problems once
06:53:39 <quicksilver> even if you need them multiple times.
06:53:41 <chrisdone> ((Just <$> foo) <|> pure Nothing)
06:53:41 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:53:41 <preflex>  chrisdone: you have 2 new messages. '/msg preflex messages' to read them.
06:53:44 <chrisdone> I get this quite a lot
06:53:49 <chrisdone> does anyone have a generalization of it?
06:54:03 <EvanR-work> quicksilver: memoization... something we cant generalize to any functional program because we dont know what to memoize?
06:54:08 <chrisdone> maybe part of an Applicative extension package
06:54:09 <EvanR-work> like in the compiler
06:54:12 <quicksilver> roughly, yes.
06:54:27 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Dynamic_programming
06:54:29 <benmachine> chrisdone: not a generalisation, but I think it's called 'optional' in Control.Applicative
06:54:33 <lars9> chrisdone: try import MemoTrie, f' = memo f, then f' is what you want.
06:54:36 <Eduard_Munteanu> What's that have to do explicitly with memoizing?
06:55:17 <benmachine> I'm told the naming of dynamic programming was entirely on the basis that 'dynamic' just sounded like a good word
06:55:30 <quicksilver> Eduard_Munteanu: "simplifying a complicated problem by breaking it down into simpler subproblems in a recursive manner"
06:55:45 <quicksilver> Eduard_Munteanu: ... and saving a lot of work by not solving the same subproblem twice.
06:55:58 <ski> @hoogle optional
06:55:58 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
06:55:58 <lambdabot> Text.Parsec.Combinator optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
06:55:58 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
06:56:02 <quicksilver> it's that last notion which is the bit you use memoisation for.
06:56:38 <benmachine> you can usually generalise Just/Nothing into return/mzero or pure/empty, but I'm not sure that you'd *want* to
06:56:42 <lars9> is parsec very useful for daily use?
06:56:47 <benmachine> lars9: yes
06:56:50 <quicksilver> yes.
06:56:59 <quicksilver> it's backtracking behaviour is very annoying
06:57:04 <quicksilver> but it's very usable nonetheless
06:57:08 <benmachine> I wrote a thing to keep track of deadlines for me, and I parsed the data file in parsec
06:57:25 <osaunders> Are orphan instances anything I should worry about?
06:57:40 <benmachine> osaunders: avoid them if possible
06:58:00 <benmachine> osaunders: if you're super-paranoid, define a newtype and instance that instead
06:58:46 <benmachine> osaunders: if you're supplying an orphan instance for a data type that should pretty obviously have that instance, chances are it will someday, or someone else will define another orphan, and then bad things happen
06:59:17 <benmachine> osaunders: pretty much the only way you can guarantee that won't happen is if you control the class and/or type, in which case you have no reason to make an instance orphan anyways :)
06:59:33 <osaunders> Well, I do actually
06:59:42 <benmachine> why not just put the instance in the module then?
06:59:55 <osaunders> I'm creating Arbitrary instance for QuickCheck and I don't want the module to need to import QuickCheck.
07:00:01 <benmachine> ah
07:00:25 <benmachine> are you exporting your tests at all?
07:00:29 <osaunders> I'm just reading about why orphans are bad now.
07:00:40 <benmachine> you're probably in one of the cases that they're fine :)
07:00:40 <quicksilver> osaunders: it's not morally an orphan if the type itself is defined in the same pacakge
07:00:43 <osaunders> benmachine: Yes
07:00:46 <EvanR-work> so to use quick check you need an Aribtrary instance...
07:00:57 <quicksilver> in fact, it's not morally an orphan if it's a type you write.
07:00:59 <quicksilver> wrote.
07:01:00 <quicksilver> EvanR-work: nope
07:01:05 <quicksilver> EvanR-work: they just make it easier.
07:01:11 <quicksilver> well, a tiny bit less verbose.
07:01:13 <benmachine> quicksilver: it could still be a problem if users can import the type and the class but not the instance
07:02:16 <osaunders> benmachine: That's not a problem in my case. I don't want them to import the Arbitrary instance.
07:02:24 <benmachine> osaunders: oh, then you're fine, I think
07:02:25 <ski> (.. it is impossible to import the module, but not all the instances in it)
07:02:52 <benmachine> osaunders: although isn't there a chance people will want to use quickcheck in their own code that uses your types?
07:03:05 <osaunders> ski: Unless the instances are defined in another modules which is the case here and the reason for this conversation.
07:03:42 <osaunders> benmachine: Hm, possible but it's an application not a library so it is pretty moot.
07:03:47 <ski> osaunders : ok. (my understanding was that you were doing it in a single module)
07:04:02 <benmachine> osaunders: oh, if it's an application you're fine
07:04:28 <EvanR-work> an application in haskell, unheard of!
07:04:32 <osaunders> ski: Basically, I have tests in one module and definition in another.
07:04:38 <benmachine> osaunders: p.s. where are you reading about the evil of orphans, ooi?
07:04:47 <ski> osaunders : that sounds good, then. the testing stuff for the module is morally not part of the interface, so it would be appropriate to have in a different module (perhaps visible)
07:04:53 <osaunders> Arbitrary instances go in test module because I don't want QuickCheck to be a part of the other stuff.
07:04:56 <ski> osaunders : right
07:05:01 <benmachine> if it's an application, do you even *have* an interface
07:05:16 <osaunders> http://www.haskell.org/haskellwiki/Orphan_instance
07:05:31 <benmachine> Warning: this page is
07:05:34 <benmachine> ...
07:05:42 <benmachine> I would be worried if it wasn't.
07:05:54 <osaunders> benmachine: I've created it with a relatively nice modular layout.
07:06:02 <osaunders> Just because I want to learn how to do things right.
07:06:15 <osaunders> benmachine: The page is incomplete?
07:06:33 <EvanR-work> or you just wanted to keep your sanity when the source code required expands beyond a single screen
07:06:50 <benmachine> osaunders: the page... is.
07:06:55 <benmachine> it continues to be
07:07:17 <osaunders> Oh lol, I didn't even see that.
07:07:25 <lars9> how to parse an expression with variable: "(x^2 + 2x + 3)" into a haskell function f x = x*x + 2*x + 3?
07:07:42 <EvanR-work> eval
07:08:00 <EvanR-work> which doesnt exist
07:08:06 <EvanR-work> read instance no functions
07:08:07 <Nibble> :P
07:08:09 <EvanR-work> on
07:08:23 <Nibble> lars9: lisp is good for this
07:08:25 <Nibble> also
07:08:28 <Nibble> are you swedish?
07:08:45 <lars9> Nibble: im not, im asian
07:08:52 <Nibble> ok
07:09:02 <lars9> Nibble: like this name though :-)
07:09:13 <osaunders> lars is a cool name
07:09:25 <osaunders> Not as cool as osaunders though, obviously.
07:09:33 <osaunders> :P
07:09:35 <EvanR-work> last name: from mars
07:10:41 <lars9> i like the shape of "lars", some beauty in its shape
07:11:49 * ski . o O ( "Lars Hörmander" )
07:11:51 <dial1> is there some way to do if statements in monads or is that not in the spirit of monadic code?
07:12:18 <EvanR-work> theres do if and if ... then do ... else do ...
07:12:20 <dmwit> If statements are done the same way as normal.
07:12:31 <Nibble> do dit do dat
07:12:42 <ski> also, `when' and `unless'
07:12:59 <dmwit> If you're in a do-block, remember to indent "then" and "else" differently from the block itself, and to re-start a do-block in the "then" and "else" clauses if you still want to be in a do-block.
07:13:07 <atude> I think haskell alone is turning me into a computer scientist
07:13:22 <EvanR-work> atude: its mutagenic like that
07:13:48 <Martty> haskell is quite a scientific language
07:15:07 <dial1> would you consider this "pure" monadic code? http://hpaste.org/40960/monads
07:15:38 <EvanR-work> what monad is that anyway
07:16:26 <Eduard_Munteanu> Looks like misusing "<-" instead of let/where clauses
07:16:26 <EvanR-work> dial1: if x then True else False is just...  x
07:16:46 <Eduard_Munteanu> Anyway, all monadic code is pure unless it does IO.
07:16:47 <EvanR-work> and yeah, name2id father and mother are likely not monadic
07:16:56 <EvanR-work> so <- wont work
07:17:07 <dial1> EvanR-work: it definitely works. 
07:17:13 <dial1> EvanR-work: I'll show you the rest
07:17:17 <EvanR-work> can you write the type signature at the top
07:17:22 <EvanR-work> for sibling
07:17:37 <dial1> http://hpaste.org/40961/monads
07:17:52 <EvanR-work> ah
07:17:54 <EvanR-work> Maybe
07:18:07 <EvanR-work> Maybe a is indeed monadic action
07:18:09 <dial1> EvanR-work: this is an assignment and we're supposed to implement sibling in both monadic and non monadic code that's why i ask
07:18:24 <EvanR-work> dial1: ok, so its good as long as you remove the if
07:18:54 <quicksilver> it won't be Person -> Person -> Bool
07:19:00 <quicksilver> it will be Person -> Person -> Maybe Bool
07:19:17 <EvanR-work> and idOne and idTwo arent being used
07:19:24 <Eduard_Munteanu> Yeah, you can't escape the monad.
07:19:28 <quicksilver> where Just True = yes they are siblings, Just False = no they are not siblings and Nothing = one of the name lookups failed (someone doesn't exist)
07:19:32 <dial1> EvanR-work: so just say "fOne == fTwo || mOne == mTwo"
07:19:37 <EvanR-work> return that
07:19:42 <EvanR-work> to make it Just
07:19:49 <dial1> EvanR-work: ah I see
07:19:59 <quicksilver> "if x then True else False" is the same as "x"
07:20:09 <quicksilver> similarly "if x then return True else return False" is the same as "return x"
07:20:32 <dial1> EvanR-work: hmm I'm getting an error now
07:20:49 <EvanR-work> well, what is it?
07:20:57 <dial1> http://hpaste.org/paste/40961/error#p40962
07:21:25 <EvanR-work> past the changed code
07:22:19 <dial1> http://hpaste.org/paste/40961/new_code#p40963
07:22:20 <quicksilver> return (fOne == fTwo) || (mOne == mTwo)
07:22:22 <quicksilver> is wrong
07:22:22 <Cale> dial1: You missed a $ or some parens around the parameter to return
07:22:23 <quicksilver> you want
07:22:31 <quicksilver> as cale says
07:22:36 <quicksilver> return ( (fOne == fTwo) || (mOne == mTwo) )
07:22:47 <Cale> (return is just a normal function, not syntax)
07:22:55 <dial1> ah i see. duh.
07:22:57 <dial1> thanks guys.
07:23:00 <Eduard_Munteanu> :t return
07:23:00 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
07:23:04 <dial1> does that second definition look full non-monadic?
07:23:11 <EvanR-work> :t return :: a -> Maybe a
07:23:12 <lambdabot> forall a. a -> Maybe a
07:23:23 <Eduard_Munteanu> It just does \x -> Just x
07:25:06 <ski> @src Maybe return
07:25:06 <lambdabot> return              = Just
07:27:14 <chrisdone> benmachine: thanks, somehow I didn't remember `optional'
07:27:19 <EvanR-work> leave = UnJust
07:27:46 <EvanR-work> stay = JustPlainWrong
07:27:59 <Eduard_Munteanu> That would be a comaybe.
07:28:02 <Eduard_Munteanu> :P
07:28:25 <chrisdone> @messages
07:28:25 <lambdabot> djahandarie said 9d 15h 35m 12s ago: Nice job capitalizing on that haskellers.com job space ;)
07:28:26 <lambdabot> aristid said 4d 3h 10s ago: haskell-align-imports could sort the import lines alphabetically, too :)
07:28:34 <ski>   codata CoMaybe a = CoNothing :: Void && CoJust :: a  -- ?
07:28:53 <quicksilver> chrisdone: it's an interesting, really. It's like you want to externalise or 'reify' the Alternative's internal notion of failure
07:28:58 <ski> (er, s/&&/&/)
07:28:59 <chrisdone> arkx: see haskell-sort-imports.el
07:29:00 <adimit> hmm... what is the difference between a Monadic and an Applicative interface? I.e. M a -> (a -> M b) -> M b vs A (a -> b) -> A a -> A b. What do I gain by using Applicative over Monadic? I'm trying to understand why uu-parsinglib uses the latter, and not a Monadic interface.
07:29:04 <EvanR-work> CoJack
07:29:12 <chrisdone> aristid: see haskell-sort-imports.el
07:29:12 <Eduard_Munteanu> Heh.
07:29:34 <gio123> ski
07:29:37 <quicksilver> adimit: Applicative doesn't force you make the results of "earlier" effects available to later effects
07:29:54 <EvanR-work> adimit: you lose stuff by using applicative over monad
07:30:02 <quicksilver> adimit: this means it's less restrictive about evaluation strategy which can enable you to do some more up-front optimisation.
07:30:22 <quicksilver> adimit: IOW; you gain nothing, but the uuparsing-lib author's gained some transformations they could use.
07:30:23 <benmachine> the more stuff your interface can do, the less you can assume about what it does
07:30:28 <Philippa> EvanR-work: that's entirely a matter of perspective
07:30:38 <ClaudiusMaximus> chrisdone: want a hpaste bug report?  (i get internal server error here: http://hpaste.org/40908/segmentation_fault_in_hmatrix , you may have spotted it in the logs already, if so sorry for interrupting)
07:30:45 <ski> hm, doesn't `MonadLogic' have an `MonadLogic m => m a -> (a -> m b) -> m b -> m b' operation ?
07:30:49 <benmachine> Philippa: well, you *do* lose stuff, but maybe you gain more stuff
07:31:10 <adimit> quicksilver: ok, so that means I can layzily parse stuff, because later appliactions of Applicatives don't force an evaluation on the former ones?
07:31:19 <adimit> EvanR-work: what do I lose?
07:31:26 <quicksilver> adimit: it certainly makes that 'more possible'
07:31:26 <Philippa> adimit: it means that the parser can examine its own structure
07:31:27 <EvanR-work> Control.Monad? :)
07:31:35 <quicksilver> adimit: you lose the ability to do highly context-sensitive parsing
07:31:36 <Philippa> so it can optimise itself
07:31:43 <adimit> Philippa: right. I get that. Sort of. Have to read that paper to the end.
07:31:54 <quicksilver> a later production can't based its behaviour on the result of the production before
07:32:01 <adimit> quicksilver: ok. I don't get that yet, but I'm sure I can work it out.
07:32:11 <adimit> ah, yeah.
07:32:13 <adimit> that makes sense.
07:32:18 <Philippa> adimit: you can do that because the structure isn't all on the RHS of a function arrow
07:32:22 <Olathe> Is getAddrInfo Nothing (Just "www.google.com") Nothing supposed to give an error?
07:32:32 <quicksilver> you can't parse "a number in decimal notation" followed by "Exactly that number of xes"
07:32:34 <Philippa> whereas with a monad - on account of the type of >>= - it is
07:32:40 <quicksilver> as in "5xxxxx"
07:32:55 <quicksilver> which you could, in a monadic framework
07:33:06 <adimit> Philippa: ok, so I get a certain level of 'introspection'
07:33:12 <quicksilver> (n <- parseInt; replicate n (parse 'x'))
07:33:16 <adimit> quicksilver: well, except I put a state monad on top of it.
07:33:23 <quicksilver> nope.
07:33:25 <quicksilver> except nothing.
07:33:30 <quicksilver> you can't do it as a grammar production.
07:33:45 <quicksilver> you can parse "a number followed by an arbitrary number of xs"
07:34:00 <quicksilver> and then *as a second pass* verify that the number of xes was the right number
07:34:08 <quicksilver> but then that's no the parsing library doing it any more.
07:34:25 <benmachine> there doesn't seem to be a replicateA even though it's not hard to define
07:34:40 <adimit> quicksilver: ok, that makes sense.
07:34:48 <quicksilver> I don't htink this is a problem in practice - constructs like that are not common in sensible languages.
07:34:56 <adimit> quicksilver, Philippa, thanks.
07:35:00 <quicksilver> conversely, you almost always do something in a second pass anyway.
07:35:10 <quicksilver> (not many people try to put name resolution into the parser, for example)
07:35:14 <adimit> quicksilver: I'm working in NLP. we deal with the most un-sensible languages possible :-P
07:35:26 <quicksilver> sure, but I bet you use multiple passes too.
07:35:33 <EvanR-work> adimit: php?
07:35:47 <Maddas> o_O
07:35:53 <Eduard_Munteanu> That's plainly unsensible :)
07:36:04 <Darkone> To pattern match to a ByteString, do you have to use cons? Like (x `cons` xs)?
07:36:09 <Darkone> Or can you use :
07:36:10 <adimit> yes, we do use multiple passes. In fact, it's considered good to have your algorithm be O(n^4) or so.
07:36:15 <quicksilver> benmachine: http://hackage.haskell.org/packages/archive/containers/0.3.0.0/doc/html/Data-Sequence.html#v:replicateA
07:36:22 <adimit> EvanR-work: wait till you see Swiss-German.
07:36:29 <EvanR-work> lol
07:36:41 <EvanR-work> wait, thats not written
07:36:42 <adimit> makes even template C++ look perfectly reasonable.
07:36:45 <adimit> it is.
07:36:46 <quicksilver> Darkone: you don't pattern match ByteStrings. Their constructors are opaque.
07:37:08 <Darkone> I'm trying to unpack a long ; delimited string by splitting it at ;s to make a list, and then getting items in certain positions.
07:37:11 <adimit> and even if it weren't that wouldn't really matter :-) Have to be able to formalize it anyway.
07:37:32 <EvanR-work> do you? ;)
07:37:38 <quicksilver> benmachine: odd that the general one isn't defined, I agree
07:37:44 <adimit> thanks for the help everyone!
07:37:45 <Darkone> Or would I just use !! and cons?
07:37:47 <adimit> EvanR-work: god no.
07:38:19 <quicksilver> Darkone: have you see the bytestring function 'split' ?
07:38:25 <EvanR-work> Darkone: Data.ByteString.Search split
07:38:29 <Darkone> Yea, I'm using it
07:38:33 <EvanR-work> or ByteString split
07:38:55 <Darkone> I have... well, a LONG line of ; dlimited fields
07:39:01 <quicksilver> > BSC.split ';' (BSC.pack "hi;there;darkone")
07:39:01 <lambdabot>   ["hi","there","darkone"]
07:39:11 <Darkone> I can break them with split into a list
07:39:19 <Darkone> Should I jsut use !! to get the ones I want?
07:39:24 <EvanR-work> doesnt matter how long since split will be lazy
07:39:25 <Darkone> brb
07:39:37 <aristid> Darkone: multiple !! would be relatively inefficient
07:39:39 <EvanR-work> dont know about !! then
07:40:26 <Eduard_Munteanu> If you really need lots of (!!) then you probably want an array.
07:40:33 <EvanR-work> could fold over the first part of the list and count and collect positions you want
07:40:42 <Eduard_Munteanu> But in this case I doubt it.
07:42:19 <EvanR-work> convert to Map indexed by index maybe
07:42:51 <quicksilver> !! is probably fine for lists up to length, say 20.
07:42:53 <EvanR-work> but then Array makes more sense
07:43:03 <quicksilver> it depends if you actually care about speed for this case.
07:43:32 <EvanR-work> :t (!)
07:43:33 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
07:43:39 <Eduard_Munteanu> (!!) is kinda unsafe; since you're programming in a functional language you'd better make use of better approaches.
07:43:48 <copumpki_>  it's also inefficient as hell
07:43:59 <Eduard_Munteanu> Yeah, on lists it's bad.
07:44:02 <EvanR-work> `unsafe!!`
07:44:07 <copumpki_> unwise!!
07:44:12 <copumpki_> pity that isn't a valid name
07:44:15 <Eduard_Munteanu> That rather. :)
07:44:29 <benmachine> genericIndex is such a convenient name
07:44:45 <Eduard_Munteanu> Well it's not unsafe as in C or unsafePerformIO, but it can still trigger bounds checking failure.
07:45:00 <EvanR-work> "dude your code is littered with 'unsafe!!' and 'unwise!!'" "dont worry i know what im doing"
07:45:03 <EvanR-work> (tm)
07:45:20 <Eduard_Munteanu> (!!) 0xDEADBEEF :P
07:45:21 <benmachine> the unsafe prefix is perhaps overused
07:45:30 <EvanR-work> or under used!
07:45:40 <benmachine> nah, a function that calls error is not unsafe
07:45:48 <copumpki_> unsafePrependUnsafe :: String -> String
07:45:55 <benmachine> a function that might violate haskell semantics, that's unsafe
07:46:15 <frerich6> As an exercise, I'd like to develop a small game (e.g. an "Asteroids" clone) in Haskell. It seems that FRP is the paradigm of choice for implementing such a games (is this true?). I was wondering: is there a "native" FRP-based graphics module for haskell? The closest thing I found so far was Gtk2Hs.
07:46:32 <EvanR-work> opengl
07:46:44 <Eduard_Munteanu> Gtk2Hs/OpenGL FRP? oO
07:47:00 <Eduard_Munteanu> See Yampa, Grapefruit etc.
07:47:07 <Eduard_Munteanu> There's info on that on the wiki.
07:47:21 <copumpki_> hmm
07:47:27 <Eduard_Munteanu> And I doubt FRP is the paradigm of choice.
07:47:43 <Eduard_Munteanu> It's more of a research topic that looks awesome.
07:47:52 <EvanR-work> i did asteroids as a approximate solution to newtonian motion
07:48:19 <EvanR-work> where keyboard events reset the simulation and changed the initial data to current data
07:49:09 <frerich6> What would you suggest? Just use some "event loop" (I assume such a thing exists)? I was trying to find something which is a typical example of Haskell - I don't want to re-use my C++ mindset too much. :-}
07:49:11 <EvanR-work> each simulation was a lazy list ;)
07:50:09 <Eduard_Munteanu> I recently did a cellular automata simulator using Gtk2Hs and used a timer. I assume there would be differences with your event sources (e.g. keyboard).
07:50:34 <EvanR-work> frerich6: well the event loop is a straight forward way, though in c++ most people dont put it in such semantically expressive terms
07:51:05 <Eduard_Munteanu> Apart from that, an event look in Haskell might simply be an 'iterate' idiom.
07:51:12 <Eduard_Munteanu> s/look/loop/
07:51:35 <EvanR-work> iterate of a pure function would allow IO
07:51:39 <EvanR-work> would not
07:52:05 <EvanR-work> fix mainLoop :: IO () would work
07:52:16 <Eduard_Munteanu> Well, not literally iterate.
07:53:14 <EvanR-work> would allow getting events, drawing, changing an internal state (update :: S -> S or S -> Maybe S to signal stop)
07:53:19 <EvanR-work> and exitting
07:53:35 <EvanR-work> or you could use forever and exit with exceptions
07:53:46 <EvanR-work> and use IORefs
07:54:11 <EvanR-work> draw :: S -> IO ()
07:54:29 <Eduard_Munteanu> GTK timers automatically stop if the handler returns False.
07:54:35 <EvanR-work> and my patented howManyStepsToKeepUpWithRealTime :: IO Int
07:55:07 <EvanR-work> i prefer to keep synched with real time, timers in toolkits often drift
07:55:30 <Eduard_Munteanu> I'm yet to find a fast and easy drawing solution.
07:55:37 <EvanR-work> theres drawing combinators
07:55:40 <EvanR-work> havent tried it
07:55:45 <Eduard_Munteanu> Though I admit the problem could've been in computation code.
07:56:27 <Eduard_Munteanu> I was short on time and didn't evaluate if those array -> array conversions were any smart.
07:56:36 <EvanR-work> frerich6: hope my type signatures help ;)
07:57:07 <EvanR-work> the above would put you on track to separate the game fromthe IO, if thats the design you want
07:57:08 <Eduard_Munteanu> frerich6: well and I wouldn't suggest going FRP the first time.
07:57:46 <EvanR-work> i wouldnt use gtk+ for a game
07:57:52 <EvanR-work> i mean a real time game like asteroids
07:58:01 <EvanR-work> card game maybe
07:58:26 <Eduard_Munteanu> You can draw on OpenGL surfaces in GTK windows.
07:58:37 <EvanR-work> yes but whats the point of the gtk
07:58:50 <Eduard_Munteanu> Mostly getting a window and maybe a menu and some buttons.
07:58:56 <EvanR-work> meh
07:59:14 <Jafet> Isn't gtk+ like, the asteroid smashes into the right edge, your gnome session reboots
07:59:16 <EvanR-work> maybe a menu and buttons, well if not menu and buttons i see no point to a toolkit ;)
07:59:17 <Eduard_Munteanu> It's probably easier than writing ad-hoc game-ish controls yourself.
07:59:36 <EvanR-work> asteroids didnt have a gui
07:59:46 <EvanR-work> only real life controls
08:00:19 <EvanR-work> and in 'real games with a gui' you basically dont want it to look like gtk+
08:00:40 <Eduard_Munteanu> Eh, I'm probably coming from KAsteroids :)
08:00:51 <EvanR-work> right..
08:03:00 <Eduard_Munteanu> Hm, ever since I started using Gtk2Hs in Haskell as opposed to wxWidgets in C++, I started thinking wx sucked... :/
08:03:36 <Eduard_Munteanu> Didn't try the other way around, but I really remember the verbosity and subtle problems I got in the latter combo.
08:03:40 <EvanR-work> i think not many people like it, but then, if you like any existing toolkit then your opinion doesnt count anyway
08:03:59 <turiya> does anyone know the possible values of ImageFormat in X11?
08:04:10 <Eduard_Munteanu> Though wxWidgets was really great at being easy to cross-compile on MinGW.
08:04:13 <EvanR-work> turiya: that should be listed in the doc or in the source
08:04:44 <Eduard_Munteanu> EvanR-work: why? I somehow agree they all suck in some way or another.
08:04:46 <EvanR-work> wx is based on the flawed premise that native look and feel makes any difference at all to the quality of the app
08:04:55 <EvanR-work> Eduard_Munteanu: then youre good! ;)
08:04:57 <turiya> i tried :i ImageFormat but did not get any useful info
08:05:28 <Eduard_Munteanu> turiya: google it, and look for hackage links.
08:05:51 <EvanR-work> turiya: the source link
08:06:26 <Eduard_Munteanu> I recently had the chance of looking at Visitor patterns in some C++ lib, they're incredibly verbose.
08:06:36 <Eduard_Munteanu> I'd take Traversable any time :)
08:06:47 <turiya> ah..got the source.. could find the values now..
08:07:00 <EvanR-work> uhg oop design patterns
08:07:07 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/X11/latest/doc/html/Graphics-X11-Types.html#46 just below the type (CInt..) are some values
08:07:54 <Eduard_Munteanu> EvanR-work: yeah, it was for visiting nodes of a scene graph, lots and lots of code to write a simple map/filter equivalent application.
08:08:13 <EvanR-work> absurd!
08:09:56 <turiya> is it ok to cast a pointer from Word8 to CChar?
08:10:52 <EvanR-work> Eduard_Munteanu: pitiful attempts to make higher level code!
08:11:14 <EvanR-work> when will it end
08:11:45 <Twey> turiya: Yes, should be fine
08:12:02 * hackagebot improve 0.1.2 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.1.2 (TomHawkins)
08:12:23 <Twey> turiya: But why are you casting pointers instead of using fromIntegral?
08:12:29 <quicksilver> turiya: well, the type tag on a Ptr is largely up to you anyway.
08:12:43 <quicksilver> turiya: if you know that what is in it is CChars then that's the correct thing to do
08:12:50 <quicksilver> but in that case how did you end up with a Ptr Word8 ?
08:13:15 <Eduard_Munteanu> The other problem with wx I think was the lack of adoption of more complicated C++ features, like exceptions and templates.
08:13:27 <Eduard_Munteanu> It was much like C with OOP sugar.
08:13:38 <turiya> quicksilver: i am trying to make a ByteString into a Ptr CChar for createImage in Xlib .. it does not seem to work
08:13:44 <EvanR-work> lack of adoption of more complicated features is a problem?
08:13:50 <EvanR-work> exceptions would be good though
08:14:03 <Eduard_Munteanu> EvanR-work: yeah, they didn't use any.
08:14:13 <EvanR-work> it uses return values for errors?
08:14:16 <EvanR-work> >_<
08:14:18 <Eduard_Munteanu> And they wouldn't work or bring in subtle bugs if you used exceptions in your app.
08:14:47 <EvanR-work> exceptions makes it simpler not more complicated
08:14:55 <turiya> Twey: createImage expects a Ptr CChar
08:14:56 <EvanR-work> smart pointers, now that seems complicated
08:15:00 <quicksilver> turiya: using toForeignPtr
08:15:03 <quicksilver> turiya: ?
08:15:11 <turiya> quicksilver: yes
08:15:23 <Twey> Is this from the X11 library?
08:15:25 <Eduard_Munteanu> EvanR-work: I don't really remember the details.
08:15:27 <turiya> quicksilver: and withForeignPtr
08:15:28 <quicksilver> that's a reasonable thing to do.
08:15:29 <dschoepe> Is there an already existing way(using the GHC api or hint or similar) to partially load a file with errors in it (ignoring the erroneous definition and things that depend on them)?
08:15:33 <turiya> Twey: yes
08:15:35 <Twey> Libraries shouldn't be exposing foreign types…
08:15:46 <Eduard_Munteanu> EvanR-work: yeah.
08:15:56 <quicksilver> dschoepe: I am fairly sure the answer is no.
08:16:25 <Eduard_Munteanu> Although since GCC switched to C++, they're kinda striving to keep things "stupid, simple" for programmers not used to such features.
08:16:25 <quicksilver> dschoepe: constructing the maximal valid component is not trivial (although it's obviously something you'd like to try to do)
08:17:35 <turiya> anyone used createImage in X11 before?
08:18:10 <Darkone> Back. Sorry yall who were helping.
08:18:31 <dschoepe> quicksilver: hmm, too bad
08:18:40 <Darkone> Okay, I have a list of bytestrings, and want to get certain numbered elements from them.
08:19:00 <Eduard_Munteanu> Darkone: how do you know which elements?
08:19:03 <Darkone> What's an easy way? Performance is unimportant, it's only ~490kb
08:19:07 <quicksilver> dschoepe: not unique, either :)
08:19:12 <Darkone> Eduard_Munteanu http://www.xwiki.chaos.net.nz/TShips_file_%28X3%29
08:19:22 <Darkone> 2,3,4,7,8,26,27
08:19:37 <Eduard_Munteanu> Executable size doesn't really matter, I can write you an infinite loop in about 20 bytes or so :)
08:19:39 <Darkone> If 0 is start value, those are the ones I want :P
08:19:51 <Darkone> Only 490kb of data ;)
08:19:55 <Eduard_Munteanu> Oh.
08:20:02 <quicksilver> I would just use (!!) as you originally thought you might, Darkone 
08:20:06 <quicksilver> split and (!!)
08:20:09 <quicksilver> that's nice and simple 
08:20:14 <quicksilver> avoid premature optimization :)
08:20:14 <Darkone> I'm a nob, looking to do some quick adjustments to a mod file
08:20:21 <quicksilver> if it turns out to be too slow, then you know where to look.
08:20:21 <EvanR-work> map (foo!!) [2,3,4,7,8,26,27]
08:20:23 <Darkone> Yea, I was thinking that.
08:20:34 <Darkone> You can map- right
08:20:39 <Darkone> :D
08:20:41 <EvanR-work> and the array version
08:20:49 <EvanR-work> map (foo!) [2,3,4,7,8,26,27,453485]
08:21:10 <Eduard_Munteanu> Darkone: you'd better use a parser
08:21:48 <Darkone> <3 how you can use functions as values in haskell.
08:21:48 <Darkone> Easy to parse.
08:21:48 <Darkone> semicolon delimited
08:21:48 <Darkone> I jsut need to change a LOT of numbers
08:21:48 <Darkone> And doing it by hand would make me cry
08:22:16 <Eduard_Munteanu> Ah, then it's probably legitimate to get them by index.
08:22:47 <EvanR-work> if its a lot longer than 27 columns, an optimization would be to stop reading the line at column 27
08:23:02 <quicksilver> well, ByteString.split is already lazy in that sense
08:23:05 <EvanR-work> assuming you werent using !!
08:23:19 <Eduard_Munteanu> You can use an array, like Data.Array.listArray (0, length foo - 1) foo
08:23:21 <quicksilver> it won't bother to split past the last column you need
08:23:23 <EvanR-work> quicksilver: building the array is lazy?
08:23:23 <Darkone> Everything that isn't what I want is just ignored :P
08:23:28 <Eduard_Munteanu> where foo is the splitted string.
08:23:34 <quicksilver> EvanR-work: building the list that results from ByteString.split is lazy, yes.
08:23:51 <EvanR-work> i know that
08:23:58 <EvanR-work> consider
08:24:00 <EvanR-work> map (foo!) [2,3,4,7,8,26,27,453485]
08:24:03 <quicksilver> right
08:24:08 <quicksilver> well that's why you don't use an array ;)
08:24:23 <Eduard_Munteanu> Using an array will memoize (!!) application.
08:24:41 <EvanR-work> but it will build the entire array i think
08:24:55 <EvanR-work> bah use !!
08:24:59 <EvanR-work> lazy wins
08:25:10 <Darkone> So, if I have a [bytestring] and do map ([bytestring]!!) [2,3,4,7,8,26,27] it will work? I can't seem to test it in GHCI
08:25:15 <EvanR-work> flawless victory
08:25:27 <Eduard_Munteanu> :t (!!)
08:25:28 <lambdabot> forall a. [a] -> Int -> a
08:26:02 <EvanR-work> [bytestring] is a list containing the one bytestring
08:26:05 <EvanR-work> not the list of chunks
08:26:09 <copumpki_> jmcarthur: is this going too far? :P zipWith :: (Mapping f, Mapping g, Domain f ~ a, Codomain f ~ g, Domain g ~ b, Codomain g ~ c) => f -> ([a] -> [b] -> [c])
08:26:14 <Darkone> Okay, wait.
08:26:20 <copumpki_> jmcarthur: I also have kleisli composition and stuff in terms of Mapping
08:26:40 <Darkone> Lines on the contents of a file will produce [ByteString] right? A list of bytestrings?
08:26:59 <EvanR-work> yes, map split would produce [[ByteString]]
08:27:00 <Darkone> And bytestring is just [Word8], correct?
08:27:03 <EvanR-work> no
08:27:09 <EvanR-work> opaque implementation
08:27:15 <Darkone> Err ignore that, I need to stay focused
08:27:17 <copumpki_> it's roughly equivalent to [Word8] sometimes
08:27:28 <EvanR-work> interface wise
08:27:34 <Darkone> So, if I pass it one bytestring from lines, and split that, I jsut have a [bytestring]
08:27:54 <Darkone> I'm thinking, just make the function take them one at a time.
08:27:57 <EvanR-work> [ByteString]
08:28:05 <Darkone> Yep.
08:28:09 <Darkone> Okay...
08:28:10 <osaunders> What do people do to name a function in a way that denotes it is a predicate?
08:28:12 <Darkone> Let me paste this
08:28:14 <Eduard_Munteanu> copumpki_: that looks nice, how does '~' actually work?
08:28:44 <Eduard_Munteanu> pumpkin: ^
08:28:55 <Darkone> This is the code for a Starburst racer. 
08:28:57 <EvanR-work> osaunders: often nothing
08:28:59 <pumpkin> Eduard_Munteanu: it's a type equality constraint
08:29:02 <Darkone> Waiting on pb...
08:29:09 <EvanR-work> :t even
08:29:10 <lambdabot> forall a. (Integral a) => a -> Bool
08:29:14 <Darkone> http://pastebin.com/N8VWbWzJ
08:29:21 <EvanR-work> often prepend is
08:29:22 <Darkone> Too long for mirc, so I pb'ed it
08:29:23 <EvanR-work> :t isJust
08:29:24 <lambdabot> forall a. Maybe a -> Bool
08:29:37 <Darkone> That line represents one of the simpler ships.
08:29:50 <osaunders> EvanR-work: Hm.
08:29:59 <Twey> Heh, people still use mIRC?
08:30:17 <Eduard_Munteanu> pumpkin: a-la HList magic?
08:30:26 <Darkone> with start index 0, the positons [2,3,4,7,8,26,27] represent the values I want if you split ; that.
08:30:29 <Eduard_Munteanu> Or is it language syntax?
08:30:45 <pumpkin> Eduard_Munteanu: language syntax, with -XTypeFamilies
08:30:56 <Eduard_Munteanu> Ah, I need to look deeper into that.
08:31:21 <Darkone> If I want to extract hose values into floats, perform operations, and write them back into a file, without modifying the rest, what would be the easiest way?
08:31:34 <Eduard_Munteanu> HList had some interesting magic that let you write TypeEq foo bar in type constraints.
08:32:34 <Eduard_Munteanu> Twey: you won't believe how many people shake heads when I say "IRC". They stop for a second and say "oh, mIRC".
08:32:59 <pumpkin> Eduard_Munteanu: it probably used a GADT, which uses a similar mechanism to ~
08:33:05 <pumpkin> or even the same one, probably
08:33:09 <Eduard_Munteanu> Although quite often they don't know mIRC either :/
08:33:15 <Darkone> Some sort of patter? Like bind 0,1 to blah, 5,6 to blah2, 9..25 to blah3, and rest to blah4, and have like, blah:x:y:z:blah2:zoom:whiz:blah3:screech:poom:rest?
08:33:58 <billodo> trouble installing ghc on snow leopard... install button greyed out.   anyone resolved this?
08:34:00 <Eduard_Munteanu> Darkone: probably a mutable array.
08:34:18 <Darkone> Without going more complex :(
08:34:36 <Eduard_Munteanu> Darkone: it isn't. DiffArray has a nice pure interface for updates.
08:34:41 <Eduard_Munteanu> Albeit slow I hear.
08:34:51 <Eduard_Munteanu> Won't get you into problems I think.
08:35:10 <Darkone> My level of Haskell is like, Learnyou.. up to data input and output
08:35:15 <Darkone> :X
08:35:24 <shapr> Darkone: It's okay, it gets better!
08:35:44 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/6.8.2/html/libraries/array/Data-Array-IArray.html#v%3A%2F%2F
08:35:51 <Eduard_Munteanu> Use (//).
08:36:05 <Darkone> shapr, I know, I mean, let's try and keep it straight forward and to stuff I might know already. It doesn't need to be fast at all
08:36:10 <Darkone> 580 lines of ships basically
08:36:24 <Darkone> Most of the line can be ignored
08:36:31 <Eduard_Munteanu> It will be something like 'myarray // [(10, "foo")]'
08:37:01 <Eduard_Munteanu> Which replaces the 11-th element with "foo".
08:37:28 <Twey> > unfoldr (\(break (== ';') -> (v, (drop 1 -> n))) -> if null v then Nothing else Just (v, n)) "foo;bar;baz;"
08:37:29 <lambdabot>   ["foo","bar","baz"]
08:38:01 <Eduard_Munteanu> s/replaces/evaluates to a replacement of/
08:38:09 <Twey> @let predToMaybe p v = if p v then Just v else Nothing
08:38:10 <lambdabot>  Defined.
08:38:29 <ski> Eduard_Munteanu : well, that's the same thing !
08:38:32 <ski> :)
08:38:42 <Twey> > unfoldr (\(break (== ';') -> (v, (drop 1 -> n))) -> predToMaybe (null . fst) (v, n)) "foo;bar;baz;"
08:38:43 <lambdabot>   []
08:38:49 <Darkone> So far, I have it reading the file, binding that to a name, lines'ing the name
08:38:51 <Eduard_Munteanu> Yeah. But I wanted to avoid confusion.
08:38:54 <Twey> > unfoldr (\(break (== ';') -> (v, (drop 1 -> n))) -> predToMaybe (not . null . fst) (v, n)) "foo;bar;baz;"
08:38:55 <lambdabot>   ["foo","bar","baz"]
08:39:00 <Twey> Yay
08:39:03 * Twey likes view patterns.
08:40:36 <Eduard_Munteanu> Using a DiffArray will also memoize any (!!) application.
08:41:00 <Darkone> http://pastebin.com/zLXk0WAB
08:41:10 <Darkone> First line is the line from the source
08:41:11 <Eduard_Munteanu> Which would matter if you have multiple (!!) scattered all over the place.
08:41:22 <Darkone> line 3 is what I'm basically doing.
08:41:30 <Darkone> Everything that's _ is stored, but ignored.
08:43:26 <Darkone> gotta go
08:43:58 <quicksilver> Twey: guard (p v) >> return v
08:44:14 <quicksilver> Twey: but, however you right the definition and however you name it, it certainly is useful.
08:44:19 <quicksilver> s/right/write/
08:49:59 <jmcarthur> copumpkin: it is my opinion that Mapping is just a bit too general
08:50:05 <pumpkin> jmcarthur: yeah?
08:50:07 <pumpkin> how so?
08:50:29 <jmcarthur> i tend to believe that when the compiler starts having problems inferring types ;)
08:50:40 <pumpkin> :P
08:51:16 <jmcarthur> i prefer not to have to sprinkle type annotations around. kind of defeats the purpose of this nice semantic sugar
08:51:34 <pumpkin> hmm, what cases did you need annotations for?
08:52:27 <jmcarthur> pumpkin: i'm not remembering now
08:52:42 <jmcarthur> pumpkin: it occurs to me that this may have been when i was overloading whitespace
08:52:42 <Twey> quicksilver: Ah, I knew there was a nicer way.  Thanks.
08:53:42 <jmcarthur> pumpkin: but basically i think it's just that Domain and Codomain are not injective
08:54:01 <pumpkin> ah
08:54:07 <pumpkin> they can't be though
08:54:12 <dankna> I have something of a weird question
08:54:15 <Olathe> @seen snoyberg
08:54:15 <lambdabot> Unknown command, try @list
08:54:15 <preflex>  Sorry, I haven't seen snoyberg
08:54:23 <dankna> I'm far from convicned that what I'm thinking of is even a good design, but I'm curious whether it's possible
08:54:45 <dankna> I have class DatabaseAtom value collection where ; fromColumns :: [SQLData] -> collection -> Maybe value ; toColumns :: value -> [SQLData]
08:55:20 <dankna> I was thinking, it would be nice if it knew at compile-time how many columns to expect
08:55:22 <dankna> so it occurred to me to make it a multi-parameter type class:
08:55:26 <dankna> class DatabaseAtom value count
08:55:36 <dankna> where count is a type that represents a compile-time natural number
08:55:46 <dankna> is there such a type?
08:55:59 <Eduard_Munteanu> dankna: look into type-level numbers. It's not easy to implement.
08:56:03 <dankna> hmm
08:56:07 <quicksilver> there are a number of them on hackage, dankna 
08:56:12 <quicksilver> there are various shortcomings with each/any
08:56:12 <Eduard_Munteanu> But it gives you compile-time type-checking.
08:56:19 <dankna> hmm!
08:56:23 <dankna> right, that would be kinda cool
08:56:25 <dankna> probably wouldn't save me any code in the long run
08:56:27 <quicksilver> http://hackage.haskell.org/package/type-level-natural-number-1.0
08:56:33 <quicksilver> this ist he first one google found
08:56:35 <Eduard_Munteanu> dankna: also I think Oleg or somebody had some arrays with type-level bounds checking.
08:56:37 <quicksilver> doesn't mean it's the best :)
08:56:38 <dankna> but in the spirit of understanding Haskell better I'd like to know how to do it
08:56:39 <dankna> haha
08:56:43 <dankna> looking
08:57:07 <dankna> hmmm
08:57:33 <dankna> this particular one actually looks quite straightforward
08:57:56 <dankna> neato, I think I'll use it :D
08:58:35 <Eduard_Munteanu> Actually I think it's possible to convert values into types, I remember it was rather straightforward as opposed to the reverse conversion.
08:58:54 <dankna> hmm
08:58:57 <dankna> fascinating
08:59:42 <dankna> hmmm I'll have to design my own type "list having a given length" on top of this, but I think I see how to do that
08:59:43 <Cale> Well, you have to reconstruct the values of the type as types.
08:59:49 <Eduard_Munteanu> Ah, no. Converting types to numbers is easy, the other way around needs existentials.
09:00:07 <Eduard_Munteanu> I wrote something like that sometime ago.
09:01:14 <Eduard_Munteanu> Heh:
09:01:15 <Eduard_Munteanu> naturalNumberAsInt :: n -> IntSource
09:01:21 <Eduard_Munteanu> s/Source//
09:01:51 <Eduard_Munteanu> They don't supply the reverse transformation.
09:02:28 <dankna> yeah, but the synonym types are all I need in practice
09:02:38 <dankna> I can't imagine having an atomic value that requires more than fifteen columns
09:02:50 <Eduard_Munteanu> http://www.mail-archive.com/haskell-cafe@haskell.org/msg22506.html
09:02:55 <Eduard_Munteanu> [Haskell-cafe] Type level programming to eliminate array bound checking, a real world use
09:03:18 <Eduard_Munteanu> And similar, as an example.
09:03:21 <benmachine> one neat idea with arrays with the size in the type I had was with matrices
09:03:28 <aristid> Eduard_Munteanu: using hacks for such things painfully reminds me of c++
09:03:32 <dankna> by "atomic value" I loosely mean "value containing no foreign keys", although actually I do support limited foreign keys with the concept of the collection type-class parameter
09:03:35 <benmachine> you could define a zero matrix or an identity matrix that was exactly as big as it needed to be
09:04:55 <Eduard_Munteanu> aristid: C++ and type-level hacks? Kinda weird :)
09:05:20 <Eduard_Munteanu> Although templates do provide some power.
09:05:30 <aristid> Eduard_Munteanu: templates are turing complete
09:05:51 <Eduard_Munteanu> Yeah, they're using them for metaprogramming IIRC.
09:06:01 <Eduard_Munteanu> Some sort of preprocessing.
09:06:10 <Eduard_Munteanu> and code generation
09:06:22 <aristid> Eduard_Munteanu: in fact, c++ has a slight advantage there: it does not need HSucc / HZero to simulate type-level numbers, you get that with templates for free
09:06:42 <Eduard_Munteanu> aristid: now don't tell me C++ has got dependent types :P
09:06:45 <aristid> Eduard_Munteanu: so you can actually write matrix<4,3>
09:06:58 <Eduard_Munteanu> Oh
09:07:01 <aristid> well it doesn't have full dependent types, just integers and such
09:07:31 <aristid> Eduard_Munteanu: it isn't beautiful, but it works. just like type-level hackery in haskell :)
09:07:58 <Eduard_Munteanu> You can have a (toType 14) in Haskell too.
09:08:10 <Eduard_Munteanu> But it isn't that easy to use.
09:08:10 <aristid> Eduard_Munteanu: with existentials?
09:08:13 <Eduard_Munteanu> Yes.
09:08:33 <aristid> Eduard_Munteanu: but you understand why it makes me a bit uneasy? :)
09:08:50 <EvanR-work> type level assembly language!
09:08:55 <quicksilver> I don't think you can really have (toType 14) in haskell.
09:09:03 <Eduard_Munteanu> quicksilver: you can.
09:09:07 <lars9> hi, I kind of feel this problem should have elegant solution in haskell, but I can not figure it out. can anyone write a neat solution for it? http://hpaste.org/40965/afraidofeven
09:09:09 <quicksilver> existential doesn't *actually* have any type information
09:09:29 <quicksilver> so it's not really a type-level 14.
09:09:30 <Eduard_Munteanu> quicksilver: indeed, but it's reified via data.
09:09:38 <lars9> my solution looks quite the same as C++..
09:09:38 <EvanR-work> lars9: what happened to line wrap technology
09:09:40 <quicksilver> it's more a typelevel 'I don't know what this is'
09:10:05 <Eduard_Munteanu> My definition looked like toPeano :: (Show b) => Int -> a -> (forall a. Peano a => a -> b) -> b
09:10:06 <lars9> EvanR-work: it's plain text... hpaste does not wrap it, dunno why
09:10:09 <Eduard_Munteanu> and I could only do Show on it.
09:10:12 <quicksilver> existential means "this is some type-level number but I don't know what)
09:10:12 <EvanR-work> its unreadable
09:10:13 <Jafet> Suppose you could do that with TH.
09:10:21 <Eduard_Munteanu> You really need to supply the classes you need.
09:10:40 <Jafet> (Which is, on some level, more similar to C++ templates than higher-order typing.)
09:10:57 <dankna> is hpaste working today?
09:10:58 <quicksilver> Eduard_Munteanu: Oh, I see, it just converts back to a value and compares?
09:11:01 <Eduard_Munteanu> Jafet: nah, TH will only make it some sort of axiom schemata, you'll have a finite number of types defined that way.
09:11:11 * dankna goes to find out
09:11:17 <dankna> ah, it looks like it is
09:11:20 <aristid> Jafet: the parallel even extends to the ugliness of the syntax :>
09:11:28 <Eduard_Munteanu> quicksilver: nah, I could only do stuff like "toPeano n () $ \x -> show x"
09:11:35 <dankna> http://hpaste.org/40966/countedlists
09:11:37 <lars9> EvanR-work: is raw file better? http://hpaste.org/raw/40965/afraidofeven
09:11:39 <Jafet> Well, all the types you can use for C++ templates must be bounded, too...
09:11:45 <Eduard_Munteanu> quicksilver: or toPeano n () $ \x -> show $ fromPeano x
09:11:52 <EvanR-work> yes
09:11:59 <dankna> this doesn't work, because "Type found: Zero where type variable expected, in: Zero valueType"
09:12:00 <Eduard_Munteanu> to convert back, but still, you need specific constraints in the definition.
09:12:02 <dankna> reasonably enough
09:12:03 <dankna> suggestions?
09:12:40 <EvanR-work> lars9: whats this assignment assuming, D?
09:12:43 <EvanR-work> C#?
09:13:07 <Eduard_Munteanu> dankna: Zero has no parameters.
09:13:22 <lars9> it's a topcoder contest problem, in contest, c++, java and C# are supported
09:13:28 <edlinde> hi all, can someone suggest a good haskell book other than real world haskell.. which is available for free?
09:13:50 <merijn> edlinde: Learn You a Haskell? But I think that's only available online
09:13:54 <edlinde> something that has a lot of examples of things like data structures, trees, navigations etc
09:14:02 <merijn> So I dunno if you want a dead-tree version
09:14:10 <edlinde> merijn: yeah I been reading through that.. nearly to the end
09:14:14 <dankna> Eduard: oh - no, if you look at the full context it's giving the list of parameters to the synonym declaration ListOfLength Zero valueTYpe
09:14:20 <EvanR-work> lars9: so its a search problem
09:14:41 <edlinde> http://www.amazon.com/Haskell-Logic-Maths-Programming-Computing/dp/0954300696/ref=sr_1_2?s=books&ie=UTF8&qid=1288368746&sr=1-2
09:14:42 <dankna> I interpret the error message as saying that I can't give a type as a parameter to a synonym, I need to give a type variable
09:14:46 <merijn> edlinde: Haskell data structures aren't really much different then those in other languages
09:14:51 <dankna> so I understand the message, if that's right; I just don't know what I can do about it
09:14:53 <edlinde> merijn: do you know what that book is like?
09:14:53 <lars9> EvanR-work: yeah.
09:14:59 <dankna> clearly some reorganization is called for
09:15:08 <EvanR-work> lars9: theres list comprehension and list monad instance
09:15:13 <EvanR-work> which may help
09:15:20 <merijn> edlinde: I've only used Learn You a Haskel and RWH, there's also some haskell wikibooks I think
09:15:28 <edlinde> merijn: I am kind of new to FP as a whole, so would love to see some applications that are more advanced... just to see what is possible with haskell
09:15:51 <EvanR-work> edlinde: theres whats possible and whats a good idea to use
09:15:52 <Eduard_Munteanu> dankna: uh oh, I don't think you can provide pattern matches on type synonyms.
09:15:58 <merijn> edlinde: Write Yourself a Scheme in 48 Hours?
09:16:00 <EvanR-work> edlinde: if you use everything possible is perl youre screwd
09:16:06 <dankna> Eduard: yeah :(
09:16:11 <EvanR-work> in perl
09:16:42 <Eduard_Munteanu> edlinde: dunno, once you get comfortable to reading and using Haskell, you can go reading stuff on Hackage directly.
09:16:45 <edlinde> EvanR-work: don't think I get you there :)
09:16:55 <dankna> heh, I have to remember that strategy - the next time I'm a student and get an assignment like "write something in <obnoxious language> in 72 hours"...
09:17:09 <dankna> I will spend 48 hours writing a Scheme in <obnoxious language> and the remaining 24 solving the problem :D
09:17:10 <lars9> write scheme in 48 hours is mostly about parsec?
09:17:23 <edlinde> Its just that I want to reach a level with Haskell where when confronted with a problem I am able to naturally think up a possible solution in Haskell
09:17:23 <Eduard_Munteanu> dankna: try reading Oleg's paper linked from the URL I gave you.
09:17:26 <EvanR-work> edlinde: advanced doesnt always mean better, see c++ templates ;)
09:17:29 <dankna> Eduard: oh!  okay, looking
09:18:00 <edlinde> at the moment I just know the list processing... haven't seen any more with haskell (at the moment)
09:18:05 <dankna> where was that linked from again?  I don't see it ^^'
09:18:16 <edlinde> I know there is much more... but examples would really help learn it quicker
09:18:29 <Eduard_Munteanu> dankna: http://okmij.org/ftp/Haskell/types.html#branding
09:19:19 <edlinde> hope that made sense
09:19:46 <aristid> EvanR-work: how is it with you and fundeps btw? :D
09:20:24 <EvanR-work> aristid: not using them
09:21:02 <Eduard_Munteanu> dankna: still, I'm warning you to stop if you have some sort of deadline to this project, it will require some head banging to get straight unless you find a ready-made lib somewhere.
09:21:10 <Eduard_Munteanu> I'm not sure one exists, but you could look.
09:21:50 <Eduard_Munteanu> Just having a type-level numbers lib doesn't actually help much.
09:22:26 <dankna> Eduard: nah, this is a fun project
09:22:51 <dankna> Eduard: I appreciate the warning but there's no deadline on this
09:23:07 <dankna> and thanks for the link.  somehow I missed seeing it altogether the first time.
09:23:07 <djahandarie> There is a type-level nat package on hackage somewhere
09:23:12 <edlinde> how does one for example write a hash table in Haskell?
09:23:18 <Eduard_Munteanu> dankna: this might do http://hackage.haskell.org/package/tagged-list
09:23:35 <dankna> cool, yes, it looks like it does
09:23:38 <edlinde> are there Haskell modules that people re-use for things like hash tables, search trees etc?
09:23:48 <merijn> edlinde: Of course
09:23:49 <djahandarie> edlinde, hash tables are mutable structures, so they aren't super elegent in Haskell
09:23:53 <djahandarie> And yeah
09:23:53 <dankna> edlinde: hash tables are not easy to implement as immutable data structures
09:23:57 <merijn> edlinde: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/index.html
09:24:00 <dankna> edlinde: which is why we use maps instead
09:24:09 <Jafet> You can make any hash table of your choice on Array.
09:24:12 <edlinde> ah okie I see ... Maps
09:24:27 <Jafet> Map is a search tree.
09:24:36 <dankna> edlinde: internally a Data.Map is a "finger tree", which in my understanding is basically a binary tree with both parent pointers and a linked list of the leaves
09:24:37 <merijn> edlinde: Basic example of doing a Map could be a trie
09:24:37 <edlinde> Jafet: but the lookup should still be o(1)
09:24:42 <Eduard_Munteanu> ... also with the variety of trees in competition with the hash tables ...
09:24:52 <bos> immutable hash tables aren't actually hard. you just need a good immutable array to build 'em on.
09:24:56 <quicksilver> dankna: no, it's not.
09:24:57 <djahandarie> dankna, no it isn't?
09:25:00 <merijn> edlinde: Take a look at how a trie works and try implementing it haskell?
09:25:07 <dankna> oh.  I got corrected by two separate people.  what is it then?
09:25:07 <quicksilver> dankna: Data.Map isn't a finger tree, it's a plain binary tree.
09:25:12 <dankna> oh!  okay
09:25:13 <edlinde> ok
09:25:15 <EvanR-work> bos: but its cheating!
09:25:15 <tautologico> just got a macbook some days ago, any recommendations about haskell on mac os x?
09:25:19 <quicksilver> neither fingertrees nor data.map have parent pointers.
09:25:22 <edlinde> first I got to build up my Haskell arsenal :)
09:25:24 <dankna> tautologico: install Haskell Platform
09:25:26 <djahandarie> Yeah, a size-balanced binary tree
09:25:38 <dankna> tautologico: prebuilt everything will save you six hours and twenty-nine minutes, if you're me.
09:25:40 <edlinde> also in haskell have you got special functions to deal with large bit streams?
09:25:49 <edlinde> like the ones you would need in crypto?
09:25:51 <dankna> Data.ByteStream
09:25:59 <edlinde> to do lots of XORs, ANDs etc
09:26:02 <dankna> and also see the hackage package "crypto"
09:26:03 <tautologico> dankna: what about further libraries? do you use fink or macports?
09:26:05 <benmachine> do you mean Data.ByteString
09:26:07 <quicksilver> (there is a fingertree-based sequence type in Data.Sequence, and a fingertree based priority queue somewhere on hackage)
09:26:14 <djahandarie> Yep
09:26:23 <quicksilver> tautologico: start with the platform and then install other haskel libraries using 'cabal'
09:26:27 <dankna> tautologico: I have a ~/.cabal/config set up to install globally by default, into /usr/local/cabal/
09:26:35 <edlinde> http://hackage.haskell.org/packages/archive/pkg-list.html
09:26:38 <quicksilver> tautologico: if they need native libraries then install those with macports
09:26:41 <quicksilver> is my recommendation.
09:26:44 <edlinde> are those predefined packages people wrote ?
09:26:47 <dankna> tautologico: most people use the default Cabal config, which installs into home
09:26:50 <tautologico> quicksilver: ok thanks
09:26:52 <djahandarie> I think the priority queue is in fingertree
09:26:54 <edlinde> which can be imported in your own Haskell code?
09:26:55 <dankna> edlinde: yes they are
09:26:57 <djahandarie> @hackage fingertree
09:26:57 <lambdabot> http://hackage.haskell.org/package/fingertree
09:27:01 <edlinde> cool thanks
09:27:09 <merijn> edlinde: You can download stuff from hackage and import it in your own code, yes
09:27:19 <tautologico> I'm thinking mostly about libraries that link to C libraries and such, I'm used to apt-get install anything I need on linux
09:27:23 <merijn> And there is of course a reasonably sized standard library
09:27:28 <edlinde> neat
09:27:35 <djahandarie> Though I'd use Okasaki's purely functional heap-based priority queue implementation if I were going to use one
09:27:50 <djahandarie> THe skew-binomial heaps
09:27:54 <dankna> tautologico: one possible solution is to use fink or macports.  again, if you're me, you're insane, and this isn't good enough for you so you install into /usr/local/stow/ and use the Perl script "stow" to make symlinks in /usr/local/
09:27:57 <djahandarie> I think they are on hackage somewhere
09:28:12 <dankna> tautologico: however there are fewer of such libraries than you might expect
09:28:37 <dankna> typical sequence is:
09:29:35 <merijn> Any type theory experts around that can confirm/correct my understanding of Calculus of Constructions and ECC?
09:29:39 <dankna> cd external-library-1.0-src; ./configure --prefix=/usr/local; make; sudo make install prefix=/usr/local/stow/external-library-1.0; cd /usr/local/stow; sudo stow external-library-1.0
09:30:00 <tautologico> dankna: 
09:30:07 <tautologico> dankna: thanks
09:30:18 <dankna> tautologico: if that doesn't sound like fun, fink uses apt-get internally :)
09:30:20 <tautologico> I'll install the platforms and probably try to go with macports
09:30:30 <bos> macports will screw you badly.
09:30:46 <dankna> tautologico: I don't like fink or macports because they mess things up royally if you need a custom-built gtk+, because they install their own
09:30:56 <tautologico> dankna: lol I used to do things like that in unix all the time, got tired
09:31:08 <bos> afaik, it's not compatible with the prebuilt haskell platform.
09:31:17 <dankna> tautologico: and the gtk+ they install is built against X11, whereas it has actually got a native Cocoa port nowadays
09:31:28 <dankna> tautologico: fair enough :)
09:31:34 <lars9> what func in prelude can do this: \x -> [x, x*2, x*4, x*8...] ?
09:31:41 <tautologico> yeah 
09:31:55 <tautologico> I was thinking about that... I don't want a X GTK instead of a native one
09:31:58 <dankna> well, surely macports won't screw you up if you don't use it for anything Haskell, only for foreign dependency libraries
09:32:00 * Eduard_Munteanu has to go, bbl...
09:32:00 <EvanR-work> > [0,2..]
09:32:01 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
09:32:04 <Jafet> @oeis 1,2,4,8
09:32:05 <lambdabot>  Powers of 2: a(n) = 2^n.
09:32:05 <mercury^> lars9: unfoldr
09:32:05 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
09:32:19 <Jafet> > iterate (2*) x
09:32:20 <lambdabot>   [x,2 * x,2 * (2 * x),2 * (2 * (2 * x)),2 * (2 * (2 * (2 * x))),2 * (2 * (2 ...
09:32:24 <dankna> tautologico: yeah... but the last time I built GTK, it was an all-day project, so you have to decide how much you care
09:32:27 <EvanR-work> smooth
09:32:29 <Jafet> Ew.
09:32:34 <EvanR-work> but its not the right function
09:32:42 <lars9> iterate is neat
09:32:59 <EvanR-work> :t map (x*) [0,2..]
09:33:00 <lambdabot> [Expr]
09:33:08 <mercury^> EvanR-work: that's not what he wants.
09:33:12 <EvanR-work> :t \x -> map (x*) [0,2..]
09:33:13 <lambdabot> forall a. (Num a, Enum a) => a -> [a]
09:33:25 <EvanR-work> mercury^: no?
09:33:30 <mercury^> Yes.
09:33:34 <EvanR-work> yes?
09:33:40 <lars9> iterate (*2) x
09:33:48 <Jafet> http://www.youtube.com/watch?v=DhV3fkB2eUM
09:33:53 <lars9> iterate (*2) 3
09:34:03 <lars9> :t iterate (*2) 3
09:34:04 <lambdabot> forall a. (Num a) => [a]
09:34:10 <dcoutts_> EvanR-work: \x -> map (\n -> x*2^n) [0,1..]
09:34:20 <EvanR-work> where did 2^x come from
09:34:34 <EvanR-work> oh, theres no 6
09:34:45 <EvanR-work> of course mine works if you remove 6
09:35:28 <dcoutts_> EvanR-work: he said  [x, x*2, x*4, x*8...]
09:36:15 <Jafet> > filter ((==0).ap(.&.)pred) [0..]
09:36:16 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:36:16 <lambdabot>    `Data.Bits.Bits a'
09:36:16 <lambdabot>      ...
09:36:32 <Jafet> > filter ((==0).ap(.&.)pred) [1..] :: [Integer]
09:36:36 <lambdabot>   mueval-core: Time limit exceeded
09:37:00 <Jafet> > take 10 $ filter ((==0).ap(.&.)pred) [1..] :: [Integer]
09:37:01 <lambdabot>   [1,2,4,8,16,32,64,128,256,512]
09:37:10 <EvanR-work> dcoutts_: yes, delete 6 [0,2..]
09:37:32 <dcoutts_> EvanR-work: not just 6 :-)
09:37:37 <EvanR-work> oh?
09:37:41 <dcoutts_> it's totally different sequence
09:37:51 <EvanR-work> not enough info!
09:37:56 <benmachine> EvanR-work: sure there is
09:38:02 <benmachine> ... means "extend in the natural way"
09:38:04 <EvanR-work> oh its 1 2 4 8
09:38:07 <dcoutts_> well, seems pretty obvious what he means
09:38:07 <benmachine> yes
09:38:17 <dolio> merijn: What do you want to know?
09:38:25 <Jafet> 1 : {-correct off-by-one error-} filter (/=6) [2,4..]
09:38:47 <EvanR-work> @src delete
09:38:47 <lambdabot> delete = deleteBy (==)
09:39:05 <EvanR-work> filter (/=6) is the same as delete 6 ?
09:39:19 <Jafet> If [..] syntax is given more terms, it should look then up in oeis.
09:40:12 <dcoutts_> EvanR-work: no, delete only does the first occurrence
09:40:20 <dcoutts_> > delete 6 [6,6,6]
09:40:21 <lambdabot>   [6,6]
09:40:53 <merijn> dolio: Well, I've finally figured out the difference between the lambda cube axes. As I understand it the calculus of constructions is just the simply typed lambda calculus with all three axes included, no? And as I understand the extended calculus of constructions, its main extension is replacing [] (as in * : []) with an infinite hierarchy of []_0 : []_1, []_1 : []_2 so that functions of type []_0 -> []_0 : []_1 are also possible, correct?
09:41:03 <mercury^> > iterate (delete 6) [6,6,6]
09:41:04 <lambdabot>   [[6,6,6],[6,6],[6],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
09:41:24 <dolio> merijn: Yes.
09:41:56 <merijn> dolio: Hurray! My endless quest to understand the basics is starting to near its end :)
09:42:14 <djahandarie> I need to go learn this stuff
09:42:26 <dolio> I think the only other big addition to ECC is sigma types.
09:42:39 <Twey> Hm… shouldn't it be possible to express ‘filter (/= 6)’ in terms of ‘delete 6’ and fix?
09:43:08 <merijn> dolio: Could be, haven't finished the entire ECC paper yet, but wanted to know if I was on the right track
09:43:24 <dolio> Also, you should note the impredicativity caveats.
09:43:44 <dolio> F, F_w and CoC have the rule ([],*,*).
09:44:00 <dolio> So, (forall a. a -> a) :: *
09:44:19 <dolio> ECC has that rule, too. But only at the bottom level.
09:44:48 <dolio> So, if we call * Prop, and the levels above Prop Type[i]...
09:45:02 <dolio> There's a rule (Type[i], Prop, Prop).
09:45:19 <dolio> But the rules for the other levels are like (Type[i], Type[j], Type[max i j])
09:45:47 <dolio> And if you try to make the higher levels impredicative, it leads to paradoxes that let you write infinite loops.
09:46:30 <merijn> I don't think I follow that one
09:46:35 <danbrown> shapr: hello! :)
09:46:49 <dolio> Which part?
09:47:40 <merijn> dolio: I was reading the Barendregt paper on the lambda cube which has rules (*, *), ([], *), etc. but I haven't seen one with 3 entries before?
09:48:39 <dolio> Oh. Well, that's because in the plain lambda cube, the third entry is always the same as the second.
09:48:43 <dolio> So it's omitted.
09:49:22 <dolio> So (*,*,*), (*,[],[]) ([],*,*) and ([],[],[]) are the axes.
09:49:31 <merijn> Ah, so that's in the ECC paper too?
09:49:43 <EvanR-work> what about ([],*,[])
09:49:47 <EvanR-work> what kind of cube is that
09:49:55 <dolio> That's a predicative rule.
09:50:10 <dolio> If you use it instead of ([],*,*).
09:50:25 <dolio> It would make: (forall a. a -> a) : []
09:51:18 <dolio> And so, you can't instantiate 'a' in that type with (forall a. a -> a) itself.
09:51:28 <EvanR-work> where is haskell on that cube
09:51:29 <dolio> Because it's (forall (a : *). a -> a).
09:52:13 <dolio> Well, to accurately model Haskell sans extensions, you need something different than the lambda cube.
09:52:26 <merijn> dolio: Oh, of course, because it'd make no sense for a constructor in []_x to be able to return itself, only things of type []_(x < n)
09:52:36 <dolio> But it's kind of like F_omega, which has the (*,*,*) ([],*,*) and ([],[],[]) rules.
09:52:58 <merijn> eh, "n < x", but whatever
09:53:31 <dolio> It's more like F_omega if you allow rank-n types.
09:53:53 <dolio> merijn: I'm not sure how to interpret that sentence.
09:54:23 <merijn> (forall a (a : []_x) . a -> a) : []_y, only makes sense when x < y?
09:55:10 <dolio> Oh. Well, it's not necessarily that it wouldn't make sense, but it leads to inconsistency.
09:55:24 <merijn> Inconsistencies don't make sense in my mind :p
09:55:33 <dolio> Similar to having a set of all sets.
09:55:55 <merijn> But I should go reread/finish the ECC paper before bothering with more questions I think
09:56:02 <dolio> But, as far as anyone knows, it's okay to have quantification over big things in the smallest level.
09:56:13 <merijn> At least I'm mostly on the right track
09:56:18 <dolio> Just not in any levels above the smallest.
09:57:07 <merijn> Because "forall a (a : []_x) .  a -> a) : *" is consistent, you mean?
10:01:10 <shapr> Does hackage have a built-in bug tracker where I can report build failures?
10:02:14 <merijn> dolio: So final question, before dinner and more reading. You meant that "forall a (a : []_x) .  a -> a) : *" is consistent (as only one with the resulting type less high in the hierarchy then its argument)?
10:02:44 <djahandarie> Twey, I don't think so, there is no function that we are getting the fixed point of
10:04:15 <djahandarie> > head . head . filter (\(x:y:_) -> x==y) . tails . iterate (delete 6) $ [1,6,3,4,3,7,5,6,6,6,3,2,1]
10:04:16 <lambdabot>   [1,3,4,3,7,5,3,2,1]
10:05:00 <djahandarie> lol, used filter in that when I was trying to define filter (\= 6), oops
10:05:16 <EvanR-work> smooth
10:05:29 <dolio> merijn: No. The rule is ([]_x, *,*). So, (forall (a : []_x). T[a]) : *, if T[a] : *.
10:05:36 <EvanR-work> blue is the color of blue things
10:05:51 <dolio> Where T[a] is some expression involving a.
10:06:37 <dolio> But (a -> a) does not have type * if a : []_x. It has type []_(x+1).
10:06:55 <merijn> dolio: ok, thanks for the explanation. Off to dinner now :)
10:07:00 <dolio> Wait... No, it has type []_x.
10:14:58 <Twey> djahandarie: Hm, but I thought that any recursive function could be written in terms of fix
10:15:15 <benmachine> it can
10:15:17 <Twey> And since filter (/= 6) can be seen as a recursive application of delete…
10:15:34 <pumpkin> yeah, and it's quite mechanical
10:15:47 <benmachine> it can be seen as a recursive application of delete but it isn't really
10:16:03 <Twey> Hm
10:16:09 <Twey> I guess a base-case is hard to find
10:16:10 <EvanR-work> i think the point is to write with fix anyway
10:16:19 <EvanR-work> for no reason
10:16:25 <EvanR-work> as is typical in haskell
10:16:27 <EvanR-work> !
10:17:25 <benmachine> :t \x -> fix $ \filter xs -> case xs of [] -> []; y:ys -> (if x == y then id else (y:)) (filter ys)
10:17:26 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
10:18:33 <EvanR-work> > :t (fix delete)
10:18:34 <lambdabot>   <no location info>: parse error on input `:'
10:18:36 <EvanR-work> :t (fix delete)
10:18:37 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a] -> [a]
10:18:37 <lambdabot>     Probable cause: `delete' is applied to too few arguments
10:18:37 <lambdabot>     In the first argument of `fix', namely `delete'
10:18:44 <benmachine> :t \x -> fix (delete x)
10:18:45 <lambdabot> forall a. (Eq a) => a -> [a]
10:19:03 <benmachine> > fix (delete 'x') "fix this! love, Ben xx"
10:19:04 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
10:19:04 <lambdabot>         against inferr...
10:19:12 <benmachine> hmm
10:19:18 <EvanR-work> > (fix delete) [5,2,67,5,3] --what happens?!
10:19:19 <benmachine> oh
10:19:19 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a] -> [a]
10:19:22 <EvanR-work> crap
10:19:24 <pumpkin> :t delete
10:19:25 <pumpkin> :t fix
10:19:25 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
10:19:26 <lambdabot> forall a. (a -> a) -> a
10:19:46 <pumpkin> :t fix (delete 'x')
10:19:47 <lambdabot> [Char]
10:19:49 <benmachine> yeah
10:19:54 <benmachine> that's... not ideal :P
10:19:54 <pumpkin> doesn't seem too meaningful ;)
10:20:24 <EvanR-work> well were i work we try to find meaning in the most brain damaged things
10:20:50 <pumpkin> > fix (('m' :) . delete 'x')
10:20:51 <lambdabot>   "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm...
10:22:18 <jmcarthur> EvanR-work: sounds like a fun place to work
10:22:30 <pumpkin> > (\x -> fix (delete 'x' . (x ++))) "mooxbala"
10:22:31 <lambdabot>   "moobalamoobalamoobalamoobalamoobalamoobalamoobalamoobalamoobalamoobalamoob...
10:22:34 <jmcarthur> EvanR-work: we try to do that in #haskell too
10:22:35 <pumpkin> ;)
10:22:41 <jmcarthur> EvanR-work: e.g. IO
10:23:21 <jmcarthur> ;)
10:23:58 <benmachine> :t \x -> fix $ \filter xs -> delete x (filter xs)
10:23:59 <lambdabot> forall t a. (Eq a) => a -> t -> [a]
10:24:03 <benmachine> oh drat it
10:24:47 <EvanR-work> lol
10:25:04 <EvanR-work> "IO is meaningless"
10:27:26 <roconnor> EvanR-work: says who?
10:27:59 <dolio> I'll tell you a secret about zip codes....
10:28:01 <EvanR-work> > "IO is meaningless" --unknown
10:28:02 <lambdabot>   "IO is meaningless"
10:28:34 <scree> RealWorld is certainly meaningless
10:28:39 <EvanR-work> yes
10:28:49 <benmachine> it's not meaningless, it preserves ordering
10:29:06 <EvanR-work> ordering of effects right
10:29:20 <roconnor> certainly State RealWorld is not a faithful represenation of whatever IO is
10:29:39 <EvanR-work> where effects also consists of time travel
10:29:53 <EvanR-work> basically what are effects
10:30:22 <roconnor> EvanR-work: were you not around during the Free FFI monad discussion with conal?
10:30:35 <EvanR-work> probably not
10:30:54 <atude> guys, i'm scared
10:31:48 <pumpkin> I wonder if at haskell university, they get students to attend boring meetings by offering free monads
10:31:54 <roconnor> IMHO and a few other's HO, The Free FFI monad is currently #haskell 's best model of sequential IO.
10:32:06 <pumpkin> (http://haskell.edu)
10:32:19 <roconnor> EvanR-work: do you know what the free FFI monad is?
10:32:24 <pumpkin> roconnor: free FFI monad?
10:32:25 <EvanR-work> no i was about to ask
10:32:28 <djahandarie> Our channel does IO?
10:32:31 <EvanR-work> the FFFI monad
10:33:06 <roconnor> A free monad is a tree with leaves and nodes
10:33:19 <pumpkin> roconnor: you just mean represent foreign calls as constructors of something like monadprompt or operational-monad?
10:33:35 <pumpkin> okay yeah I see what you're talking about
10:33:39 <roconnor> for the FFI monad there is a node type for each FFI call
10:33:49 <pumpkin> you'd need a GADT to represent that in a typesafe manner though
10:33:52 <roconnor> that holds the FFI call and all it's arguments
10:34:00 <roconnor> pumpkin: you don't need GADTs
10:34:03 <djahandarie> A free monad is a tree?
10:34:12 <pumpkin> roconnor: oh, you'd hide the constructors and have phantom parameters?
10:34:15 <pumpkin> djahandarie: yes!
10:34:15 <djahandarie> A thought a free monad was a monad that is determined by its functor
10:34:17 <roconnor> pumpkin: nope
10:34:21 <pumpkin> hmm
10:34:38 <roconnor> and for each possible response of a FFI call there is one child of the node
10:34:44 <EvanR-work> ok
10:34:57 <roconnor> lastly there is a speciall leaf called "return" that holds a piece of data
10:35:06 <EvanR-work> what are the children
10:35:16 <pumpkin> roconnor: do you see the approach I'm talking about though?
10:35:32 <roconnor> EvanR-work: there is one child for each response of the FFI
10:35:35 <pumpkin> EvanR-work: the function you pass to bind specifies the children
10:35:41 <roconnor> EvanR-work: say the return type of an FFI call is Char
10:36:09 <roconnor> EvanR-work: then there is one child for each Char.  Typically it will be stored as a funciton (Char -> IOTree a)
10:36:23 <roconnor> so a node is
10:36:33 <EvanR-work> so a node is an ffi call or anything else
10:36:38 <EvanR-work> or return
10:36:44 <roconnor> FFICallName param1 param2 ... (resultType -> IOTree a)
10:36:55 <pumpkin> data FFI a where GetChar :: FFI Char; PutStrLn :: String -> FFI ()
10:36:58 <roconnor> ya each node is an ffi call or return
10:37:08 <pumpkin> then you have a generic free wrapper
10:37:11 <EvanR-work> the return has the like every char
10:37:19 <roconnor> pumpkin: well, putstrln probably isn't a ffi call, though putchar might be.
10:37:47 <pumpkin> roconnor: yeah, although it probably is given that it's a lot faster to make one call than put characters individually
10:37:49 <roconnor> The IOTree is parameterized by the type of data held by return
10:38:02 <roconnor> pumpkin: fair point
10:38:27 <pumpkin> but it putchar and getchar could be considered a "basis" for character IO :P
10:38:36 <pumpkin> whatever that means here
10:38:44 <roconnor> EvanR-work: the bind function is given a tree with return leaves of type a and a function from a -> IOTree b, then it subsututes all the return leaves with new IOTrees given by the function
10:39:20 <pumpkin> anyway, operational or MonadPrompt both implement this kind of approach for arbitrary "instruction sets"
10:39:38 <roconnor> EvanR-work: given a big IO tree defined by main, the run type system makes the first FFI give at the top of the tree.  Then depending on the response of the FFI call, the appropriate subtree is recursively intepreted.
10:39:51 * djahandarie is still stuck wondering why a free monad is a tree
10:40:05 <EvanR-work> roconnor: so there is IO involved still as a primitive
10:40:06 <djahandarie> Unless we are talking about some other free than the category theory free
10:40:21 <EvanR-work> its not abstracted out like the real world doesnt exist in QM
10:40:22 <pumpkin> djahandarie: data Free f a = Return a | Recurse (f (Free f a))
10:40:29 <roconnor> EvanR-work: the free FFI monad says nothing about what the calls mean
10:40:32 <pumpkin> djahandarie: right?
10:40:39 <EvanR-work> roconnor: i thought that was the issue
10:41:17 <djahandarie> pumpkin, I wouldn't call that a tree... it only branches in one direction
10:41:17 <roconnor> EvanR-work: arguably it is.  The FFFI monad has almost no semantics.
10:41:23 <EvanR-work> right
10:41:31 <pumpkin> djahandarie: now take f = [], data Tree a = Leaf a | Node [Tree a]
10:41:41 <zygoloid> djahandarie: roconnor's explanation has somewhat hidden the freeness of it.
10:41:42 <EvanR-work> so what benefit does it have over just taking getChar as a primitive IO Char
10:41:51 <pumpkin> djahandarie: or take f = ((->) b), now you have b-branching trees
10:42:08 <djahandarie> pumpkin, I know a lot of free monads can be trees, but it certainly isn't a requirement...
10:42:22 <EvanR-work> is it to provide a in-haskell meaning to >>= for IO
10:42:23 <roconnor> EvanR-work: actually the free FFI monad is exactly what you get if you take a bunch of abstract funciton and mod out by the monad laws.
10:42:40 <EvanR-work> ok
10:42:47 <pumpkin> djahandarie: you can view any of them as a tree is the point. Think of a monad abstractly as bind and return, otherwise
10:42:48 <pumpkin> :t (>>=)
10:42:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:42:53 <roconnor> EvanR-work: but it does provide meaning for >>= and putStrln and, in paricular, forever
10:43:00 <roconnor> (note that IOTrees may have infinite depth
10:43:01 <EvanR-work> yes
10:43:09 <roconnor> State RealWorld does not handle forever
10:43:20 <EvanR-work> realworld does not handle time
10:43:27 <EvanR-work> or concurrency
10:43:47 <djahandarie> data Succ a = Succ a ?
10:43:50 <roconnor> the FFFI monad doesn't handle concurrency (very well) either
10:44:07 <pumpkin> djahandarie: here, http://blog.sigfpe.com/2010/01/monads-are-trees-with-grafting.html
10:44:26 <pumpkin> djahandarie: that's an unbranching tree, or a list
10:44:42 <djahandarie> I know
10:44:56 <djahandarie> I just thought it's weird to call it a tree, but I guess that's true
10:47:16 <shachaf> yjumlijkyhujump'[;/
10:47:22 <pumpkin> shachaf: I see
10:47:23 <shachaf> Ahem.
10:48:18 <roconnor> EvanR-work: I think the point is that the FFFI monad is (1) better than State RealWorld
10:48:33 <pumpkin> roconnor: isn't that approach how IO used to work?
10:48:35 <djahandarie> It'd be nice if Bifunctor was somewhere other than category-extras
10:48:40 <roconnor> which enables (2) users to imagine a concrete data type behind IO
10:49:07 <pumpkin> djahandarie: we'd need *variance-polymorphism
10:49:08 <pumpkin> :P
10:49:09 <roconnor> pumpkin: are you refering to the [Response] -> [Request] stuff?
10:49:24 <pumpkin> roconnor: yeah, that seems like a simple/ugly form of the same idea
10:49:36 <roconnor> no, it is totally different IMHO
10:49:43 <pumpkin> :o
10:50:05 <djahandarie> pumpkin, huh
10:50:08 <roconnor> pumpkin: the tree strucure forces a kind of monotinicty that the list function (and State RealWorld) don't have
10:50:18 <pumpkin> you're reifying your FFI calls as an ADT that you have a processor for
10:50:36 <pumpkin> djahandarie: your bifunctor could be covariant on one side and contravariant on the other
10:50:37 <roconnor> pumpkin: yes
10:50:55 <pumpkin> roconnor: I thought that's how IO used to work? I wasn't around back then so I don't actually know :P
10:51:31 <alex404> How does fusion fare when moving between lists and vectors? If I do 'fromList <$> sequence foo' does that cost much more than simply 'sequence foo'?
10:52:00 <pumpkin> not well
10:52:00 <roconnor> the [Response] -> [Request] stuff does reifiy the FFI calls as Request yes,
10:52:02 <pumpkin> avoid it if you can
10:52:13 <roconnor> pumpkin: but they are not properly sequenced with the responses.
10:52:37 <pumpkin> roconnor: yeah, that's what I meant by the simple/ugly factor :P it seems like it was completely unsafe
10:52:39 <alex404> pumpkin: Were you answering my question there?
10:52:43 <pumpkin> alex404: yes
10:52:44 <roconnor> there is nothing connecting the Request with the corresponding response in the input list.
10:53:16 <roconnor> the FFFI monad is safe.
10:53:32 <roconnor> maybe even too safe :)
10:53:39 <alex404> pumpkin: Cheers. Can you suggest an alternative?
10:54:01 <pumpkin> alex404: just avoid crossing the barrier as much as possible. Put whatever you have into vectors early on and work within their API 
10:54:12 <pumpkin> oh no! not too safe
10:55:03 <alex404> pumpkin: Roger dodger
10:57:15 <roconnor> (Haskell is a language used make a sequence of C calls)
11:01:04 <lars9> for list [1,1,1,5,4,1,5], how to take those heading qual part [1,1,1]?
11:01:10 <lars9> *euqal
11:01:23 * pumpkin tries to figure out how to do that variance-polymorphism stuff
11:01:52 <Botje> lars9: head . group
11:03:59 <lars9> Botje: thanks, how to take the progressive part? [1,3,5,8,100] -> [1,3,5]
11:04:26 <Botje> *blink*
11:04:30 <Botje> why would you stop at 5?
11:04:39 <Botje> (also: is this homework?)
11:04:54 <pumpkin> okay, I have it
11:05:45 <lars9> Botje: because 1,3,5 is a progression, and 1,3,5,8 is not..
11:05:58 <lars9> Botje: no, i just want to make my program neat
11:06:07 <Botje> lars9: uh, it clearly is.
11:06:18 <Botje> or do you mean that 8-5=3 and not 2 as the others?
11:06:43 <lars9> Botje: yeah..
11:08:04 <Botje> hmm
11:08:56 <Botje> let l = length . head . group $ zipWith (-) (tail list) (list) in take (l+1) list
11:09:12 <Botje> oh, and it will die horribly if list is []
11:09:40 <zygoloid> Botje: what, no `ap`?
11:09:44 <Twey> Haha, I was about to say
11:10:42 <lars9> how does ap help?
11:10:42 * zygoloid tries to think of the most convoluted way to write 'take 3'
11:10:43 <Botje> i like zipwith better than map (uncurry (-)) (zip`ap`tail)
11:10:59 <Twey> Botje: What's wrong with zipWith (-) `ap` tail?
11:11:12 <pumpkin> djahandarie: http://hpaste.org/40968/functor_variance
11:11:12 <benmachine> :t zipWith (-) =<< tail
11:11:13 <lambdabot> forall a. (Num a) => [a] -> [a]
11:11:15 <Botje> heh
11:11:20 <Botje> don't you get negative numbers then?
11:11:37 <Twey> It's exactly the same as map (uncurry (-)) (zip `ap` tail) >.>
11:11:39 <benmachine> > zipWith (-) =<< tail $ [1 .. 10]
11:11:40 <lambdabot>   [1,1,1,1,1,1,1,1,1]
11:12:00 <benmachine> does that answer your question
11:12:02 <pumpkin> if you ever map (uncurry f) to zip
11:12:02 <Twey> > zipWith (-) `ap` tail $ [1 .. 10]
11:12:03 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1]
11:12:08 <Twey> … isn't it?
11:12:08 <Botje> Twey: fair enough :)
11:12:09 <Twey> Maybe not
11:12:13 <Twey> > zipWith subtract `ap` tail $ [1 .. 10]
11:12:14 <lambdabot>   [1,1,1,1,1,1,1,1,1]
11:12:25 <Twey> Opposite argument order, I guess.
11:12:36 <benmachine> Twey: if you want f (g x) x instead of f x (g x), just use (=<<)
11:12:49 <Twey> I prefer subtract
11:12:58 <benmachine> yeah
11:13:01 <Twey> But noted ☺
11:13:03 <benmachine> but in the general case
11:13:39 <lars9> so back to the original question, how to take the equally progressive part? [1,3,5,8,100] -> [1,3,5]
11:13:53 <lars9> do we have neater way now?
11:14:03 <Twey> Hmm
11:15:06 <Twey> take (length monotonic) list where monotonic [] = []; monotonic (x : xs) = takeWhile (== x) xs
11:15:09 <Twey> Errr
11:15:16 <Twey> take (length $ monotonic list) list where monotonic [] = []; monotonic (x : xs) = takeWhile (== x) xs
11:15:28 <zygoloid> lars9: this really isn't homework? :)
11:15:42 <pumpkin> lol
11:16:09 <lars9> zygoloid: homework assigned by myself?
11:16:13 <SonOfLilit> Hi
11:16:14 <Botje> let (a:b:_) = list in [ x | (x,y) <- zip list [a,b..], x == y ]
11:16:15 <SonOfLilit> Say
11:16:15 <lars9> lol
11:16:20 <zygoloid> lars9: :) what do you want from [1,3,5,8,10,12] ?
11:16:30 <Botje> that's the best i can do
11:16:32 <zygoloid> and what about [1] and [1,3]?
11:16:46 <benmachine> zygoloid: convoluted ways to write take 3?
11:16:49 <benmachine> > foldr (\ x take n -> guard (n > 0) >> x : take (n-1)) (const []) [1 ..] 3
11:16:50 <lambdabot>   [1,2,3]
11:16:50 <Twey> @let list _ z [] = z; list f _ (x : xs) = f x xs
11:16:51 <lambdabot>  Defined.
11:17:24 <SonOfLilit> I'm looking for a way to embed a data file into my code at compile time (or read it in during startup, an have it be a value)
11:17:44 <pumpkin> SonOfLilit: someone was working on a project to do just that recently, but I can't remember any more details than that :/
11:18:07 <SonOfLilit> pumpkin: No built in way better than unsafePerformIO?
11:18:19 <Twey> take =<< length . list [] (takeWhile . (==))
11:18:27 <Twey> benmachine: There, happy?  :þ
11:18:37 <benmachine> Twey: so. happy.
11:19:06 <Twey> Oh, off-by-one though :<
11:19:24 <Twey> take =<< length . list [] (fmap (undefined :) . takeWhile . (==))
11:20:12 <c_wraith> SonOfLilit, you can do it with template haskell or a quasiquoter. (same mechanism, slightly different interfaces)
11:20:23 <Botje> heh
11:20:24 <Botje> 'undefined :)'
11:20:29 <Twey> :-D
11:20:43 <Twey> Hm, I wonder whether ‘list’ is better defined as f x xs or f x (x : xs)
11:21:05 <benmachine> the former!
11:21:08 <dolio> f x xs
11:21:12 <Twey> Yeah?  Okay.
11:21:16 <benmachine> I think so
11:21:28 <dolio> The purpose of list is to take a list apart.
11:21:29 <benmachine> in f x (x : xs) you know it's safe to access the tail of the second argument
11:21:37 <benmachine> but you can't prove that in the type system
11:21:47 <pumpkin> wow, has anyone ever heard of "solveWanteds: loop" ?
11:21:50 <benmachine> in f x xs, you already have the tail
11:21:57 <benmachine> you can easily reconstruct (x : xs) if you want it
11:22:08 <benmachine> besides, having list [] (:) = id is cute
11:22:10 <elwood_> why doesn't this show all combinations?
11:22:11 <elwood_> http://codepad.org/GDLlJLTG
11:22:35 <elwood_> that are palandromes?
11:23:05 <merijn> elwood_: It's not multiplying everything
11:23:08 <elwood_> why?
11:23:14 <benmachine> elwood_: do you understand how zipWith works?
11:23:18 <Botje> elwood_: zipwith will only produce 900 elements
11:23:21 <merijn> It's doing 100 * 100, 101 * 1001, etc
11:23:29 <elwood_> ahh
11:23:31 <elwood_> of course
11:23:32 <merijn> s/1001/101
11:23:38 <roconnor> what is list?
11:23:40 <elwood_> no I did not understand zipWith
11:23:52 <elwood_> now I am enlightened
11:23:55 <merijn> :t zip
11:23:56 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
11:24:01 <elwood_> thanks
11:24:02 <merijn> :t zipWith
11:24:02 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:24:05 <benmachine> roconnor: a proposed name for (a -> [a] -> b) -> b -> [a] -> b
11:24:09 <benmachine> roconnor: by analogy with maybe
11:24:37 <pumpkin> okay, my next question is _should_ the paste I wrote earlier work?
11:24:39 <pumpkin> cause it doesn't
11:24:55 <alej> like ok later dudes
11:25:04 <djahandarie> pumpkin, hmm, I see
11:25:06 <pumpkin> it seems that if a fundep uniquely determines parameters to a type function, it still won't apply them
11:25:22 <dolio> Functor variance?
11:25:32 <pumpkin> yeah
11:25:49 <pumpkin> I get the puzzling "solveWanteds: loop" message when typechecking
11:25:57 <pumpkin> not an error or warning
11:25:58 <djahandarie> GHC 7.0?
11:26:01 <pumpkin> just appears on my ghci
11:26:02 <pumpkin> yeh
11:26:34 <dolio> If the problem is a lack of evaluation, so to speak, from fundeps, I'm not surprised.
11:27:48 <pumpkin> well, if I write map (+1) [1,2,3], the return type is determined by the fact that I'm applying it to the [] functor, which has a specific variance determining it
11:28:19 <pumpkin> so it should see [], oh, so by the fundep, v = Covariant, so return type = Variance1 Covariant [] = [a] -> [b]
11:28:25 <dolio> Why not use associated types?
11:28:34 <elwood_> how should one do all possible multiplications between two lists?
11:28:34 <dolio> Then it's all within the type families world.
11:28:45 <pumpkin> dolio: good point
11:28:48 <pumpkin> I'll try with that
11:28:49 <dolio> And you don't have to worry about the separate extensions working together properly.
11:29:05 * pumpkin moves it
11:29:13 <SonOfLilit> c_wraith: Thank you very much
11:29:21 <roconnor> > liftM2 (*) [2,3,4] [6,4,2
11:29:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:29:24 <roconnor> > liftM2 (*) [2,3,4] [6,4,2]
11:29:25 <lambdabot>   [12,8,4,18,12,6,24,16,8]
11:29:34 <roconnor> elwood_: ^^
11:29:39 <elwood_> ty
11:30:33 <djahandarie> It'd be neat if type declarations automatically got lifted to the type/kind level :V
11:30:50 <atude> djahandarie: :)
11:31:07 <roconnor> djahandarie: Omega!
11:31:18 <djahandarie> roconnor, byorgey!
11:31:42 <sproingie> > liftM2 (*) (Just 3) (Just 4)
11:31:43 <lambdabot>   Just 12
11:31:48 <pumpkin> dolio: same issue
11:32:15 <elwood_> Is list comprehension the wrong way to do it?
11:32:17 <djahandarie> That sounds like an issue that should possibly be reported
11:32:21 <pumpkin> http://hpaste.org/paste/40968/no_fundeps_polymorphic_varianc#p40969
11:32:52 <djahandarie> The fundep version is cleaner :P
11:33:06 <pumpkin> it felt more natural which is why I started that way
11:33:31 <djahandarie> It'd be nice if GHC just did some internal translation between the two instead of maintaining two entirely seperate things
11:33:43 <djahandarie> That way you could safely mix them and expect no (fewer) bugs
11:33:56 <Botje> elwood_: it's one way to do it
11:34:02 <EvanR-work> expect no fewer bugs!
11:34:02 <pumpkin> I'd assume once they actually are equivalent, it will work that way
11:34:08 <EvanR-work> so equal to or greater than bugs
11:34:12 <EvanR-work> than before
11:34:24 <roconnor> elwood_: list comprehension is a good way to do it
11:34:32 <djahandarie> "Fewer" was meant to replace "no" :P
11:37:33 <elwood_> ok
11:39:00 <pumpkin> djahandarie, dolio: oh, I can see why it's a tough case
11:40:51 <pumpkin> I'm going to try to wrangle it into a nicer form for typechecking
11:43:08 <SonOfLilit> Is there a way to have named with IO?
11:43:59 <Lemmih> SonOfLilit: What?
11:44:08 <EvanR-work> parse failure
11:45:15 <djahandarie> atude, are you learning Haskell now?
11:45:58 <atude> djahandarie: I have been learning, off and on, for a while.. I'm thinking about focusing on it, but............... right now, it's either this or lisp
11:46:10 <EvanR-work> the choice is obvious
11:46:19 <atude> EvanR-work: it's true...
11:46:22 <EvanR-work> also obvious, one which to choose
11:46:37 <djahandarie> parse failure
11:46:44 <EvanR-work> >_<
11:46:46 <monochrom> choose scheme. (think outside the dilemma)
11:47:00 <atude> people in #lisp tell me to experiemnt.. it's weird because in #C++, the told me to experiment... #C told me the choice was obvious
11:47:16 <djahandarie> Scheme is nice for learning
11:47:18 <djahandarie> But...
11:47:20 <EvanR-work> #c told you the choice was obvious between lisp and haskell?
11:47:21 <djahandarie> Beyond that...
11:47:33 <alej> beyond that it's pretty good, too
11:48:01 <atude> EvanR-work: no, between c and c++
11:48:06 <EvanR-work> oh, well yeah
11:48:39 <scree> well, C is by far the best language for the things you use C for
11:48:45 <EvanR-work> scheme has a flaw, its dynamically typed. they forgot to add type safety
11:48:45 <djahandarie> I think Haskell beats Scheme in most of the places it beats Common Lisp
11:48:51 <scree> whereas C++ is a pretty rubbish language for the things it's used for
11:49:15 <scree> so maybe their attitudes make sense
11:49:36 <gwern> EvanR-work: there's always Typed Scheme
11:49:42 <gwern> or you could pick up the Liskell torch
11:49:46 <atude> scheme is useless
11:50:11 <alej> false
11:50:12 <scree> well, it is turing-complete
11:50:18 <djahandarie> gwern, does Liskell even compile anymore?
11:50:39 <gwern> djahandarie: I don't think so. but it wasn't done in a very futureproof manner
11:50:41 <EvanR-work> haha liskell
11:51:06 <djahandarie> I think it was a stupid project anyways
11:51:11 <djahandarie> Lisp syntax really hurts my eyes
11:51:16 <atude> same
11:51:23 <atude> and ML
11:51:28 <atude> and Racket so far
11:51:29 <scree> I can sympathise with wanting to improve on haskell syntax though
11:51:36 <djahandarie> Uh
11:51:38 <djahandarie> ML isn't bad
11:51:47 <djahandarie> Much closer to Haskell at least
11:51:55 <atude> still not haskell
11:52:05 <gwern> djahandarie: template haskell hurts my mind
11:52:11 * EvanR-work throws scala into the fray
11:52:12 <gwern> macros have their place
11:52:20 <atude> maybe you mean standard ml
11:52:43 <djahandarie> gwern, yeah, that's the one place where Lisp totally destroys Haskell :(
11:52:49 * scree prefers let .. in let .. in to haskell's version these days
11:53:03 <gwern> scree: what?
11:53:07 <djahandarie> I hear there are improvements coming down the pipeline for TH though
11:53:28 <atude> I must say, these are very different worlds
11:53:29 <gwern> djahandarie: yeah and Duke Nukem Forever will kick ass and chew buttergum
11:53:31 <scree> gwern: what did I say?
11:53:39 <EvanR-work> hahahaha
11:53:41 <atude> my mind is really actually moving in 40 directions now
11:53:44 <gwern> scree: I dunno. that doesn't even parse to me
11:53:54 <djahandarie> atude, most MLs have similar syntax
11:53:59 <djahandarie> What are you talking about?
11:54:36 <atude> djahandarie: maybe it's the examples I've been looking at; there in way similar to haskell, but still much different
11:54:41 <EvanR-work> replicateM 40 (forkIO atude)
11:54:48 <atude> and hurt my eyes
11:55:00 <scree> gwern: doesn't ML use multiple "let foo = bar in \n let blah = foobar in \n" thingies?
11:55:26 <djahandarie> ML itself is pretty different from Haskell, yeah, but I think ML has the closest syntax (aside from Miranda) to Haskell
11:55:26 <aristid> > let foo = 1 in bar = foo in bar
11:55:27 <lambdabot>   <no location info>: parse error on input `='
11:55:34 <scree> gwern: it wasn't an insightful comment
11:55:38 <EvanR-work> Clean
11:55:40 <aristid> > let foo = 1 in let bar = foo in bar
11:55:41 <lambdabot>   1
11:55:41 <djahandarie> (Not including things inspired by Haskell obviously)
11:55:44 <gwern> scree: dunno. haskell lets you do things like 'let x = y; b = z; c = d in ...', which is a lot like scheme/cl's let
11:56:38 <scree> aristid: sure, but then it doesn't play well with newlines and stuff
11:56:46 <EvanR-work> try clean! its like haskell without the monad kludge! (tm)
11:56:47 <alej> let*
11:56:48 <atude> djahandarie: regardless, my eyes feel like I dropped sugar on it :(
11:56:59 <EvanR-work> (actual clean ad)
11:57:00 <atude> definately, much different from C
11:57:05 <gwern> EvanR-work: and it's basically unmaintained and has no community
11:57:13 <aristid> scree: whatever. you seem to care about totally unimportant stuff
11:57:27 <scree> aristid: oh, definitely
11:57:34 <EvanR-work> yes like most people
11:57:42 <EvanR-work> including the management
11:58:07 <aristid> EvanR-work: only most people outside #haskell, of course.
11:58:19 <EvanR-work> oh of course
11:58:33 <EvanR-work> we are the aristocracy of code land
11:58:44 <EvanR-work> everyone else are prols
11:58:55 <scree> aristid: though we are comparing programming languages, so I didn't think it was possible to be too opinionated
11:58:56 <aristid> indeed.
11:59:26 <aristid> scree: you can line up your declaration inside a single let block, which suffices because it's always recursive
11:59:38 <aristid> > let foo = 1; bar = foo in bar
11:59:39 <lambdabot>   1
11:59:50 <scree> aristid: I was complaining about syntax, not semantics
12:00:00 <scree> aristid: it really was that unimportant :)
12:00:06 <aristid> i'm talking about syntax.
12:00:41 <EvanR-work> i dont see why theres a need for two kinds of let
12:00:47 <EvanR-work> let vs let rec
12:01:01 <aristid> EvanR-work: well if you fear accidentally introducing recursion
12:01:14 <scree> there are other reasons
12:01:21 <scree> some people view shadowing as a good thing
12:01:25 <zygoloid> let is much easier to prove total
12:01:26 <EvanR-work> the few times i actually accidentally did that, it was a type error
12:01:37 <scree> let a = a+1 in 
12:01:52 <aristid> EvanR-work: right, preventing type errors is something that matters, tho
12:02:00 <aristid> oh wait
12:02:05 <aristid> i was misreading your statement
12:02:11 <aristid> sorry
12:02:30 <chowder> haskell newbie here reading "learn you a haskell for great good." I'm writing a function that takes a list and gets the factorial of all the numbers in the list. So listfacs [1..5] = [1!, 2!, 3!, 4!, 5!]. I'm writing the function to better understand higher order functions. Can anyone help?
12:02:32 <EvanR-work> but might have been better categorized as unexpected shadowing
12:02:43 <EvanR-work> if that were possible
12:03:07 <EvanR-work> aristid: but you can get 'non recursive let' another way in haskell
12:03:08 <luite> chowder: in general, if you want to apply a function to each element of a list, you use map
12:03:11 <zygoloid> chowder: sure. do you have an approach in mind?
12:03:14 <aristid> EvanR-work: yeah :)
12:03:19 <mauke> chowder: that sounds like a perfect match for 'map'
12:03:22 <aristid> EvanR-work: i read a blog about thise once
12:03:31 <chowder> luite: right, I know I have to use map but I'm not sure how to go about it
12:03:46 <chowder> I'll pastebin some of my code
12:03:47 <luite> chowder: have you already written a factorial function?
12:03:55 <mauke> map f [x1, x2, x3 ...] = [f x1, f x2, f x3, ...]
12:04:16 <scree> > map f [x1, x2, x3]
12:04:16 <chowder> luite: yes
12:04:17 <lambdabot>   Not in scope: `x1'Not in scope: `x2'Not in scope: `x3'
12:04:20 <mauke> map takes a function and a list of arguments, and returns a list of results
12:05:05 <aristid> > map f [x, y, z]
12:05:06 <lambdabot>   Ambiguous type variable `b' in the constraints:
12:05:06 <lambdabot>    `GHC.Show.Show b'
12:05:06 <lambdabot>      a...
12:05:12 <aristid> > map f [x, y, z] :: [Expr]
12:05:13 <lambdabot>   [f x,f y,f z]
12:05:16 <chowder> http://pastebin.com/9pH5X5j3
12:05:20 <aristid> scree: :>
12:05:42 <mauke> why is the empty list an error?
12:05:53 <EvanR-work> > foldr f o [x,y,z] :: [Expr]
12:05:54 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
12:05:54 <lambdabot>         against inferre...
12:06:06 <aristid> chowder: listfacs xs = map fac xs
12:06:06 <mauke> EvanR-work: o :/: [Expr]
12:06:10 <chowder> mauke: because the empty list has no elements. I can't get the factorial of nothing
12:06:15 <mauke> chowder: sure you can
12:06:19 <mauke> chowder: map f [] = []
12:06:19 <EvanR-work> i mean
12:06:25 <EvanR-work> > foldr f o [x,y,z] :: Expr
12:06:26 <lambdabot>   f x (f y (f z o))
12:06:30 <EvanR-work> \o/
12:06:36 <EvanR-work> > foldl f o [x,y,z] :: Expr
12:06:37 <lambdabot>   f (f (f o x) y) z
12:06:40 <EvanR-work> cool
12:06:46 <aristid> EvanR-work: it is teh awesome
12:06:51 <mauke> > foldl f o [x,y,z]
12:06:52 <lambdabot>   f (f (f o x) y) z
12:06:53 <chowder> aristid: is it really that simple? Wow.
12:07:07 <aristid> chowder: actually it's even simpler. :)
12:07:12 <aristid> listfacs = map fac
12:07:18 <chowder> O_o
12:07:22 <chowder> I need to study more
12:07:37 <mauke> listfacs xs = map fac xs  -- you can cancel 'xs' on both sides here
12:07:41 <djahandarie> That's a simple conversion you can do to any function
12:07:42 <djahandarie> Yeah
12:08:02 <djahandarie> Called "eta-reduction" because confusing names are cool
12:08:04 <aristid> chowder: but i thought that would confuse you, so i kept the xs at first :)
12:08:09 <EvanR-work> i keep wanting to do that to stuff that has that form
12:08:18 <aristid> djahandarie: in ML you usually do the opposite i learnt :D
12:08:18 <chowder> I come from the land of imperative and OO. So haskell is somewhat new but appeals to the side of me that loves math.
12:08:30 <EvanR-work> data T a = T A B a
12:08:31 <zygoloid> > map (\n -> product [1..n]) [1..5]
12:08:31 <lambdabot>   [1,2,6,24,120]
12:08:33 <EvanR-work> data T = T A B
12:08:34 <monochrom> "eta-reduction" tries to cause you to say "eh? what?"
12:08:55 <aristid> monochrom: and then you can the play funny "i just repeat what i said" game
12:08:57 <mauke> > let { fac n = product [1 .. n];  listfacs = map fac } in  listfacs [1, 2, 3]
12:08:58 <lambdabot>   [1,2,6]
12:09:31 <aristid> "eta-reduction" - "eh what?" - "eta-reduction" - "what?" - "eta-reduction" - "what?!?!?!" - "eta-reduction"...
12:09:36 <mauke> listfacs [1, 2, 3] ==> map fac [1, 2, 3] (because listfacs = map fac) ==> [fac 1, fac 2, fac 3]
12:09:51 <chowder> mauke: I see
12:10:50 <djahandarie> What is Dist short for by the way? type Dist f g = forall a. f (g a) -> g (f a)
12:11:11 <aristid> djahandarie: distributive? *guess*
12:11:31 <monochrom> perhapd Dist is short for "commute"
12:11:49 <djahandarie> Odd shortening scheme in that case
12:11:58 <aristid> distributive kinda makes sense when you think of f as * and g as +
12:12:24 <aristid> (a+b)*(c+d) = a*c+a*d+b*c+b*d :D
12:12:52 <EvanR-work> > (a+b)*(c+d)
12:12:53 <lambdabot>   (a + b) * (c + d)
12:13:08 <EvanR-work> lambdabot disagrees
12:13:24 <aristid> > dist $ (a+b)*(c+d)
12:13:25 <lambdabot>   Not in scope: `dist'
12:13:44 <aristid> hmm, are there analysis functions for Expr?
12:14:25 <djahandarie> Expr is really dumb
12:14:41 <aristid> dum
12:15:07 <mauke> > derive
12:15:08 <lambdabot>   Not in scope: `derive'
12:15:10 <mauke> > deriv
12:15:11 <lambdabot>   Overlapping instances for GHC.Show.Show
12:15:11 <lambdabot>                              ((Data...
12:15:11 <atude> > (a/(b*c)*d)/(e*b+a/c)
12:15:12 <lambdabot>   a / (b * c) * d / (e * b + a / c)
12:15:13 <benmachine> it comes from *Simple*Reflect
12:15:15 <mauke> :t deriv
12:15:16 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
12:15:24 <djahandarie> :t grad
12:15:25 <lambdabot> Not in scope: `grad'
12:15:26 <djahandarie> Aw
12:15:30 <mauke> > deriv sin x
12:15:30 <djahandarie> No ad imported
12:15:31 <lambdabot>   1 * cos x
12:15:46 <mauke> > deriv (^2) x
12:15:47 <lambdabot>   1 * x + x * 1
12:15:54 <benmachine> mauke: :o
12:15:56 <benmachine> impressive
12:16:06 <djahandarie> Cale, import Numeric.AD from ad?
12:16:38 <aristid> :t deriv
12:16:39 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
12:16:57 <djahandarie> Is "Agile software development" a skill?
12:19:46 <benmachine> djahandarie: quite a vague one if so
12:19:52 <benmachine> imo
12:20:15 <mauke> > deriv (deriv exp) x
12:20:15 <lambdabot>   1 * (1 * exp x)
12:20:20 * benmachine still thinks 'skills' should be broken up into 'tools used' and 'interests', broadly speaking
12:20:58 <benmachine> > deriv (sin^2 + cos^2) x
12:20:59 <lambdabot>   1 * cos x * sin x + sin x * (1 * cos x) + (1 * negate (sin x) * cos x + cos...
12:21:06 * benmachine blink
12:21:38 <Mitar> is there a way for two haskell threads to run in the same os thread always?
12:21:44 <sproingie> i never bother with "interests".  they care what i'm good at, not what i like
12:21:48 <mauke> > length . show $ deriv (sin^2 + cos^2) x
12:21:49 <lambdabot>   101
12:21:54 <sproingie> if they like what i'm good at, then maybe they'll ask me what i like
12:21:56 <benmachine> sproingie: except you're probably good at what you like
12:22:10 <mauke> Mitar: what's the point?
12:22:14 <sproingie> oddly, they don't necessarily intersect
12:22:22 <Mitar> if i make a forkOS and  then from it forkIO this second thread is still freely scheduled around
12:22:27 <sproingie> i like a lot of things i completely suck at.  haskell for example.
12:22:33 <Mitar> mauke: x11 and threads, of course ;-)
12:22:43 <mauke> Mitar: the forkOS is also freely scheduled around
12:22:46 <sproingie> i'm good at java and i hate it
12:22:50 <benmachine> sproingie: so maybe interests isn't the best term, I just want to separate the abstract and the concrete
12:23:03 <Mitar> the point is that everything works with -N1 but not with -N4 ;-)
12:23:04 <sproingie> benmachine: i just put them in a separate bullet point
12:23:21 <sproingie> most resumes are just keyword-scanned anyway, either by a computer or by a human skimming them
12:23:22 <Mitar> so it seems that if two haskell threads would be in the same OS thread things would work
12:23:23 <EvanR-work> abstract interests:
12:23:35 * hackagebot nettle-openflow 0.1 - High level configuration and control of computer networks.  http://hackage.haskell.org/package/nettle-openflow-0.1 (AndreasVoellmy)
12:23:43 <Mitar> so the problem is that I use x11 for two things: keyboard events and drawing to screen
12:23:58 <Mitar> drawing takes a lot of time (I use directly x11 drawing primitives)
12:24:12 <EvanR-work> drawing from a thread that didnt initialize X is a bad idea (tm)
12:24:14 <Mitar> but I would like that responses to keyevents are fast
12:24:51 <Mitar> so my idea is to have one OS thread which does events and drawing, but to let haskell interweave those together
12:25:12 <Mitar> by using haskell threads
12:25:14 <mauke> you could use a queue of actions
12:25:22 <mauke> so everything ends up in one thread
12:26:23 <Mitar> but it should not be one haskell thread
12:26:33 <Mitar> two haskell threads, but one os thread
12:26:38 <Mitar> maybe there is some other way to do it ;-)
12:26:44 <Mitar> the correct one ;-
12:28:00 <EvanR-work> the correct one for me has always be to deal with X in 1 thread
12:28:14 <EvanR-work> in C
12:29:52 * pumpkin just wrote statically checked ordered lists in haskell
12:29:58 <benmachine> :O
12:30:06 <christastrophe> Is it possible to make cabal use additonal package directories when configuring?
12:30:17 <pumpkin> benmachine: don't worry, it's horribly ugly
12:30:19 <EvanR-work> christastrophe: haha @ your nick
12:30:44 <christastrophe> directories other than 'ghc-pkg dump --global' and 'ghc-pkg dump --user'?
12:30:52 <christastrophe> EvanR-work: :)
12:31:42 <atude> I think i'm seeing and understanding the beauty of xmonad as a window manager :D
12:32:28 <penny> I'm trying to gradually wean myself off kde with it--wicd > networkmanager
12:34:45 <dstcruz> I just had some Launchpad envy... maybe Hackage could benefit from some of their ideas
12:35:04 <caelan> dstcruz: which ideas?
12:35:24 <penny> me too!
12:35:25 <penny> ?
12:35:36 <dstcruz> it's not just a project repo, but also a bug tracking tool
12:35:52 <caelan> ah
12:35:55 <pumpkin> http://hpaste.org/40975/ugly_ordered_lists
12:35:55 <dstcruz> i.e. it is a communication tool
12:36:07 <penny> (or a noise machine!.
12:36:12 <caelan> i'm not familiar with hackage, but am more familiar with launchpad, so...
12:37:59 <benmachine> pumpkin: that's brilliant and I love it
12:38:44 <dstcruz> caelan: hackage is like a debian package repository, sort of
12:38:52 <pumpkin> benmachine: hah thanks
12:39:14 <dstcruz> caelan: cabal-install is like, uh? dselect? (been a while)
12:39:28 <dstcruz> caelan: Cabal might be more like dpkg
12:39:32 <benmachine> cabal-install fetches things from the nets
12:39:41 <benmachine> does dselect do that? I thought it was apt's job
12:40:11 <caelan> apt fetches things, dpkg operates on downloaded things
12:40:13 <dstcruz> Yes, that. I thought dselect was a front-end to apt
12:40:32 <benmachine> well, I don't really remember either to be fair
12:42:10 <dstcruz> atude: what are you liking about it?
12:43:42 <EvanR-work> gah.. php has no laziness
12:43:55 <EvanR-work> well it does, with ? :, but its not enough
12:44:06 <penelope> It has eval.
12:44:36 <alej> does cabal have proxy settings?
12:51:57 <EvanR-work> gah, it has array_map but not array_map_with_key
12:52:33 <christastrophe> ok I'm totally confused. why would 'ghc-pkg list' give results which are not the sum of 'ghc-pkg list --global' and 'ghc-pkg list --user'?
12:53:51 <penelope> christastrophe: on debian, it sort of does..
12:54:39 <christastrophe> penelope: hmm, this is ubunut, but I'm sure that counts too. what is the root of the problem?
12:55:13 <Cale> christastrophe: Perhaps you have more than two package databases
12:55:36 <Cale> christastrophe: It's possible that there's one which is part of your distribution...
12:55:50 <Cale> Though I'm not certain why they wouldn't just install things globally.
12:56:32 <Cale> ghc-pkg list should tell you which package.conf files the packages are installed in
12:56:58 <EvanR-work> what is this crap... when i do $x = expr; $y = $p ? constant : $x, the expr gets evaluated completely no matter what
12:57:27 <EvanR-work> i cant write code like this anymore
12:57:42 <christastrophe> Here's what I've got (paths are shortended for brevity):
12:58:43 <christastrophe> 'ghc-pkg list', searches /var/lib/ghc-6.12.1/package.conf.d, ~/.ghc/..., ~local/.ghc/...
12:59:03 <christastrophe> 'ghc-pkg list --global' searches only /var/lib/ghc-6.12.1/...
12:59:15 <christastrophe> and 'ghc-pkg list --user' searches only ~/.ghc/...
12:59:48 <christastrophe> now '~local/.ghc/...' is searched because I have GHC_PACKAGE_PATH=~local/.ghc/...:
13:00:12 <christastrophe> so it seems 'ghc-pkg list' uses GHC_PACKAGE_PATH, but nothing else does...
13:01:28 <penelope> what happens when you do a cabal install? Where does it go? .ghc?
13:03:25 <dankna> ~/.cabal by default
13:03:35 <dankna> you can also set it up to go to a global directory, which you have to specify
13:03:43 <dankna> edit ~/.cabal/config
13:04:04 <dons> penelope: ~/.cabal/{bin,lib}
13:08:16 <christastrophe> penelope: not sure. I don't cabal install with this account... rather I haven't yet (I use a networked home dir, so I wanted to keep haskell stuff on the local disk).
13:10:18 <sm> Igloo: fyi the trac link from the unix package on hackage gives a permission error
13:11:11 <Igloo> sm: Probably because you aren't logged in to trac
13:11:23 <christastrophe> I see that trying to have what amounts to two global package dirs is just not going to cut it with cabal. I think I need to simply revamp my setup
13:11:50 <penelope> cabal doesn't always play nicely with system packages...
13:11:50 <sm> I shouldn't have to be just to view the tracker, eh ?
13:11:59 <EvanR-work> penelope: thanks for that
13:12:18 <dankna> chris: what are you trying to achieve?
13:12:39 <EvanR-work> i am now writing manual currying
13:12:46 <sm> I see, you've linked to the create form. It should ask for a login instead of erroring. Stupid trac. Well, I thought you should know
13:14:00 <EvanR-work> i sure hope i can do $f($x)($y)...
13:14:38 <mauke> hah, good luck with that
13:14:45 <mauke> you can't even do f($x)[$y]
13:14:49 <EvanR-work> i know that much
13:14:56 <EvanR-work> im expecting vomit any second
13:15:01 <penelope> It's easier in javascript...
13:15:11 <christastrophe> danka: basically I was trying to leave the bits of ghc that ubuntu installs in place, and use cabal ontop of that... without installing into the global package dir. I was trying to keep it all seperate...
13:15:33 <christastrophe> but it appears to be a less than ideal situation
13:16:09 <aristid> EvanR-work: perl is better in that respect :>
13:16:30 <Raelifin> Newbie question: Is there an easy way to subtract one list from another list. Like: <function> [1,2,2] [1,1,1,2,2,2,3] == [1,1,2,3]
13:16:43 <penelope> for debian, cabal install --global goes to /usr/local, but (sadly) the package database goes to /var...
13:16:47 <EvanR-work> php parser seems to have been designed by a gerbil
13:16:51 <mauke> > [1,1,1,2,2,2,3] \\ [1,2,2]
13:16:52 <lambdabot>   [1,1,2,3]
13:16:52 <nooodl> Raelifin: List.(\\)
13:16:58 <mauke> nooodl: syntax error
13:16:58 <Raelifin> Thanks
13:17:11 <nooodl> heh it's List.\\ isn't it
13:18:46 <Twey> List.\\ is the operator
13:18:52 <Twey> (List.\\) to treat it as a function
13:19:06 <mauke> also, Data.List
13:19:07 <christastrophe> penelope: it makes sense from debian perspective... I was trying to be clever and use GHC_PACKAGE_PATH, but that is apparently not the way to go at all :)
13:19:21 <EvanR-work> gahhhh
13:20:11 <Twey> mauke: List in H98 ;)
13:22:03 <christastrophe> http://hackage.haskell.org/trac/hackage/ticket/335
13:36:25 <ksf> is it necessary for cabal-install to fail when I move its cwd to another place?
13:40:21 <EvanR-work> k i left off the ++ in for($i=0; $i<count; $i++) and couldnt figure out what was causing the infinite loop
13:40:32 * EvanR-work smashes head into wall
13:40:37 <dankna> christastrophe: yeah I suspected that might be your use-case
13:41:03 <EvanR-work> needs more direct-fastcgi
13:41:05 <dankna> that specific use-case is something that I talked to dcoutts about a few weeks ago
13:41:05 <dankna> (maybe a month?)
13:41:16 <dankna> and he agreed with my proposed solution, which was to use a separate ghc-pkg database for things that are part of the distribution and things that are installed later
13:41:19 <mauke> EvanR-work: perl would give you a warning for that :-)
13:42:00 <penelope> danka: OMG. no more sudo for --global
13:42:20 <dankna> but I didn't have time to volunteer to implement that behavior, and I don't know when he'll get to it
13:42:20 <dankna> but it's in the pipeline as something that will eventually get nicer
13:42:24 <EvanR-work> this framework stupidly nullifies phps output streaming and only sends the data when all the millions of strings are concatenated, which means error messages dont show up until timeout
13:42:41 <EvanR-work> even if there was one for this
13:42:53 <dankna> penelope: yeah
13:42:57 <mauke> why are error messages part of the normal output?
13:43:14 <christastrophe> dankna: that would be nice.
13:43:23 <dankna> penelope: were you here last night as "penny"?  just curious if you're the same person
13:43:23 <EvanR-work> all output has been redirected to a buffer
13:43:36 <EvanR-work> which is them prepended to the real output, also in a buffer
13:43:37 <EvanR-work> at the end
13:46:26 <christastrophe> dankna: what is the relation of ghc-pkg and the Cabal library, does ghc-pkg use Cabal?
13:47:00 <dankna> other way around
13:47:03 <dankna> Cabal uses different backends depending on the compiler
13:47:18 <dankna> ghc-pkg is not an installation/compilation manager, just a way to find already-compiled things
13:47:27 <dankna> Cabal is therefore responsible for creating and managing the directory structure
13:47:38 <dankna> and putting that into the ghc-pkg database
13:47:39 <penelope> "responsible"
13:47:42 <dankna> ha
13:49:48 <christastrophe> so is there a way to tell ghc-pkg to use a different user package database?
13:51:41 <penelope>  /var/lib/ghc-6.12.1/package.conf
13:51:44 <penelope> ?
13:51:58 <Lemmih> christastrophe: --package-conf?
13:52:19 <dankna> I believe so but I don't know it
13:54:03 <christastrophe> Lemmih: that looks promising
14:00:07 <davean> h3r3tic: 
14:00:42 <christastrophe> oh well. it seems ghc-pkg cannot be told that the user package dir is not in ~/.ghc ... but you can symlink ~/.ghc elsewhere ... good enough for now
14:05:46 <Watermind> why does this need undecidable instances?   instance Enum a => RetI a where
14:09:27 <Raelifin> How do you define new typeclasses in the interpreter? I keep getting a parse error on "data T = T"
14:09:47 <dons> you can't define new data types or classes at the prompt. you should instead load them from a file
14:09:53 <Raelifin> Ah, ok.
14:10:04 <Raelifin> I figured I just didn't know a special trick.
14:12:47 <mauke> Watermind: because it's not guaranteed to terminate
14:13:27 <caelan> Watermind: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/type-class-extensions.html explains it
14:15:13 <sshc> If I'm writing a function for a container, should the container be passed first or the other argument first?  ("Container -> a -> Container" or "a -> Container -> Container")
14:15:37 <EvanR-work> which one will be more convenient to partial
14:15:38 <alpounet> @hoogle member
14:15:39 <lambdabot> Data.IntMap member :: Key -> IntMap a -> Bool
14:15:39 <lambdabot> Data.IntSet member :: Int -> IntSet -> Bool
14:15:39 <lambdabot> Data.Map member :: Ord k => k -> Map k a -> Bool
14:16:03 <mauke> @hoogle update
14:16:03 <lambdabot> Data.HashTable update :: HashTable key val -> key -> val -> IO Bool
14:16:04 <lambdabot> Data.IntMap update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
14:16:04 <lambdabot> Data.Map update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
14:16:50 <Watermind> mauke: caelan: I see... didn't even occur to me since since I only had ground types in mind... as Enums are generally ground
14:17:02 <mauke> huh?
14:17:19 <EvanR-work> watch out because grass type is strong again ground type
14:17:26 <dankna> hah :D
14:17:27 <dankna> priceless
14:17:30 <Watermind> mauke: types with instances of Enum are usually ground, no?
14:17:33 <caelan> the mower is strong with this one
14:18:00 <mauke> Watermind: what's a ground?
14:18:39 <Watermind> mauke: I was thinking non exponential and non recursive type
14:18:57 <mauke> yeah, I don't know what that is
14:19:01 <Watermind> mauke: although I guess recursive may be called ground
14:19:18 <caelan> Watermind: you mean a non-parameterized type?
14:19:20 <mauke> I think about classes like functions
14:20:07 <Watermind> caelan: well and yes that too...  but not only that
14:20:43 <mauke> 'class RetI a' is 'RetI :: a -> b'; 'instance Enum a => RetI a' is 'RetI a = Enum a'
14:20:45 <Watermind> base types (such as Int, char etc) and finite products and coproducts of those
14:21:03 <mauke> by adding another function Enum a = RetI a I get an infinite loop
14:23:28 <shapr> dons: awake?
14:23:40 <dons> shapr: pong
14:24:07 <shapr> dons: Got any ideas on how to record build failures and bugs/bugfixes for hackage?
14:24:23 <shapr> I ran across two build failures with most recent versions on hackage.
14:24:34 <Watermind> mauke: sure but I thought ghc would be able to detect such loop and issue the overlaping instances warning only when it occurs
14:24:35 <dons> record in what sense?
14:24:37 <dons> upload?
14:24:55 <Watermind> but I'mn probably being naive in thinking that would be easy 
14:25:07 <Watermind> as I didn't give it too much thought reallyu
14:25:12 <mauke> Watermind: how is that overlapping?
14:25:22 <dons> shapr: hackage 2 supports anonymous build logs.
14:25:25 <shapr> dons: For example,GoogleTranslate fails to build...  is there something easier/simpler/more automatic than tracking down the author from the hackage page and sending them a bug report/patch?
14:25:27 <dons> we better have it  live after belhac
14:25:33 <dons> shapr: nothing easier yet.
14:25:35 <mauke> overlapping would be F x = a; F x = b
14:25:42 <dons> i mail them the failure
14:26:10 <shapr> Hm
14:26:27 <Watermind> mauke: I wouldn't call it overlaping, but it's the interpreter who is asking for the overlapping instances flag to accept it
14:26:41 <blackdog> dons: I'm building a little CI server up to track the packages i care about
14:26:46 <shapr> I don't mind running a build-bot, but it would be better if there were a central place to record build failures, instead of anywhere from zero to many bug reports being sent to the author.
14:26:53 <blackdog> but it'd be really nice to have a more general server
14:27:02 <dankna> hmm
14:27:06 <dankna> that WOULD be very nice indeed
14:27:18 <dankna> another thing I personally would love is if I could get a report on a build success
14:27:24 <dankna> as a way of measuring how many people are using my packages
14:27:31 <dankna> and therefore deciding where I should spend my efforts
14:27:38 <shapr> dankna: like debian's popcon?
14:27:47 <dankna> probably?  not familiar with
14:27:48 <Watermind> mauke: nevermind undecidable not overlapping
14:28:01 <shapr> dankna: http://popcon.debian.org/
14:28:06 <Watermind> mauke: I think it's time for me to take a break... geeez
14:28:12 <mauke> Watermind: it's undecidable because it can make the typechecker loop
14:28:17 <Watermind> yes yes got it
14:28:24 <dons> blackdog: we have a hudson-based one at work
14:28:25 <dankna> ooh, yes, very much like that
14:28:26 <Watermind> I got confused there with the names
14:28:30 <dons> should get released soonish
14:28:38 <dankna> it would have to be an opt-in thing obviously, but I suspect most people will
14:28:44 <blackdog> the killer feature for me would be to integrate the checks with something like RVM for haskell - i rely on a bunch of packages that work ok on older versions of GHC, but not on 7
14:28:46 <shapr> Yah, popcon is opt-in
14:28:51 <Watermind> mauke: I was reading undecidable and thinking overlapping
14:29:00 <Watermind> nevermind I got it
14:30:20 <blackdog> dons: how much of hackage do you cover? or just galois packages?
14:30:29 <blackdog> https://ci.shimweasel.com is what i've got so far
14:30:41 <shapr> Oh no, you've been #haskell-dotted!
14:30:44 <blackdog> ha
14:30:54 <blackdog> is it down?
14:31:05 <dons> blackdog: just our stuff for now.
14:56:06 <grahamhutton> @users
14:56:06 <lambdabot> Unknown command, try @list
14:56:11 <grahamhutton> users
14:57:13 <grahamhutton> sorry - long time not here, and can't remember the commands...
14:57:37 <benmachine> grahamhutton: what do you want to do? I think some of lambdabot's commands got disabled due to a memory leak
14:57:42 <benmachine> sometimes preflex has them instead
14:57:44 <benmachine> preflex: users
14:57:52 <pumpkin> benmachine: or just cause it was so forgetful so as to be useless
14:57:53 <Darkone> Okay guys, question time
14:57:54 <benmachine> ...sometimes not
14:57:56 <pumpkin> in the case of @users
14:58:03 <grahamhutton> @benmachine: how many users online
14:58:03 <lambdabot> Unknown command, try @list
14:58:05 <benmachine> pumpkin: orite
14:58:13 <monochrom> I think the @users command was removed. mentioning a ton of people's names interferes with many people's irc software
14:58:18 <benmachine> 22:57:42 -!- Irssi: #haskell: Total of 666 nicks [1 ops, 0 halfops, 0 voices, 665  normal]
14:58:25 <grahamhutton> thanks!
14:58:47 <caelan> benmachine: how temporally appropriate
14:59:01 <benmachine> caelan: :P
14:59:30 <Darkone> sourcedata <- readFile sourcefile    tships = lines sourcedata ( so that's [String])  rest = map split . drop 3 $ tships  (split is a custom string version of split that's like words for ';')
14:59:45 <Darkone> So that would be [[String]] right?
14:59:59 <Darkone> [[String],[String],..]
15:00:14 <EvanR-work> theres several already made split for you
15:00:17 <monochrom> tships is [[String]]
15:00:25 <Darkone> Uh oh.
15:00:28 <monochrom> sorry, tships is [String]
15:00:32 <Darkone> Oh.
15:00:44 <caelan> :t lines
15:00:45 <lambdabot> String -> [String]
15:00:48 <EvanR-work> also a large source data may cause stack overflow
15:00:56 <Eduard_Munteanu> Mmm, I'm not sure about the Reader monad, what does it get me beyond one less "Foo ->" in function sigs?
15:01:10 <Eduard_Munteanu> And perhaps not passing around environment?
15:01:14 <EvanR-work> Eduard_Munteanu: you dont have to pass it around
15:01:20 <EvanR-work> and you can use asks
15:01:21 <Darkone> EvanR-work, I switched to regular Data.List and stuff, because performance isn't important (<1Mb source data) and list stuff is easier for me
15:01:23 <c_wraith> Eduard_Munteanu, nothing.  it's not very useful by itself.  ReaderT is a lot more valuable.
15:01:24 <Eduard_Munteanu> Ah, so not much.
15:01:32 <EvanR-work> i use Reader :(
15:01:33 <monochrom> split stuff is [String]? then map split stuff is [[String]], yeah.
15:02:03 <Eduard_Munteanu> c_wraith: hm, what would you use it for? I think ReaderT IO () isn't much different.
15:02:04 <EvanR-work> for configuration
15:02:26 <EvanR-work> ReaderT S IO lets you keep an arbitrary number of IORefs as 'globals'
15:02:31 <Darkone> Right. split is basically = filter (not . any (== ';')) . groupBy (on (==) (== ';'))
15:02:31 <EvanR-work> in S
15:02:44 <stepkut> I have code that compiles fine under 6.12, but requires IncoherentInstances under 7.0. How should I get started figuring out what is wrong?
15:02:53 <Eduard_Munteanu> I see.
15:02:55 <c_wraith> Eduard_Munteanu, I use it for passing around configuration data any time I'm in a monad stack already
15:03:05 <Darkone> groupBy run like that seperates all ';' from the string, making a list of strings
15:03:22 <Darkone> Then I just filter any strings with ';' in them, like from the Learn you a Haskell example
15:03:36 <Eduard_Munteanu> I see. Well, yeah, it is useful, just not as much as I imagined :)
15:04:12 <Darkone> Okay, so far so good, right?
15:04:50 <Eduard_Munteanu> I suppose Writer is something harder to avoid/replace.
15:05:00 <Darkone> That produces something like [["12","213","24",..],..]
15:05:01 <EvanR-work> Writer is cool
15:05:04 <Darkone> Amirite? :)
15:05:45 <Darkone> From "12;213;24;..\n.."
15:10:58 <dstcruz> is it possible to do a getChar without echoing the char to the screen?
15:11:17 <Jafet> Tell your screen to stop echoing it
15:11:21 <Jafet> See also termios.
15:12:10 <EvanR-work> tell your echo to stop screening it
15:12:23 <Heffalump> can anyone tell me how to do the equivalent of darcs tag in git?
15:12:33 <EvanR-work> git tag ?
15:12:45 <Eduard_Munteanu> I don't know about Darcs' tag :)
15:12:53 <EvanR-work> i passed the IQ test
15:13:05 <Heffalump> I tried that, but nothing much seemed to happen.
15:13:16 <EvanR-work> git tag shows your tags
15:13:21 <EvanR-work> if you have none, it shows nothing
15:13:27 <EvanR-work> like a lot of other commands
15:13:33 <Heffalump> oh, I see.
15:13:33 <Eduard_Munteanu> Tagging in git signs a commit.
15:13:36 <Heffalump> I think I figured it out now.
15:13:44 <Heffalump> I did git tag foo and now git tag says 'foo'
15:13:47 <EvanR-work> by default it does not sign anything
15:13:50 <Heffalump> and that identifies a repo state?
15:13:54 <EvanR-work> yes
15:13:58 <Eduard_Munteanu> EvanR-work: yeah, not simply "git tag"
15:14:24 <Heffalump> I'm too used to darcs asking me what I want to do if I don't tell it up front :-)
15:14:33 <EvanR-work> sounds fluffy
15:14:35 <Eduard_Munteanu> I think it makes a branch, IIRC.
15:14:37 <dstcruz> I've had bad experiences trying to tell my screen to do things ;). My wife thinks I'm crazy when I start talking to the machine :) haha.
15:14:57 <EvanR-work> tag is not a branch, its a ref
15:15:02 <EvanR-work> like a branch
15:15:04 <Eduard_Munteanu> Oh.
15:15:33 <EvanR-work> if you check out a tag you cant commit, you have detached head
15:15:35 * hackagebot HTTP 4000.0.10 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.0.10 (GaneshSittampalam)
15:15:42 * EvanR-work continues blurting out hilarious git jargon
15:15:50 <Eduard_Munteanu> :)
15:16:12 <Feuerbach> EvanR-work: you can, but the reference will not be updated automatically
15:16:29 <EvanR-work> which reference?
15:16:36 <Feuerbach> the tag
15:16:40 <EvanR-work> of course
15:16:43 <Eduard_Munteanu> Yeah, the tag will stay there no matter how you rebase the current branch.
15:17:06 <EvanR-work> git checkout -b take-the-low-road tag-name
15:17:46 <Eduard_Munteanu> That makes a local branch, no detached head.
15:18:24 <EvanR-work> head firmly attached
15:18:32 <Eduard_Munteanu> :)
15:20:17 <stepkut> what does it mean when GHC says I have overlapping instances and need to use IncoherentInstances, but then only lists on overlapping instance?
15:23:36 <Eduard_Munteanu> Hm, what duplication... I wonder what's keeping Prelude implementers from importing mtl and newtyping stuff like Reader to ReaderT Identity.
15:24:01 <Eduard_Munteanu> or s/importing/adopting/
15:25:45 <alecs1> hi, is this channel  a good place for noob questions?
15:25:59 <Heffalump> alecs1: yes
15:26:46 <alecs1> ok, the error is this:     Couldn't match expected type `IO [String]'
15:26:46 <alecs1>            against inferred type `[[a]] -> [a]'
15:26:54 <alecs1> I'll put the code to a pastebin
15:27:36 <Eduard_Munteanu> alecs1: you're probably calling a monadic function and using that directly
15:28:00 <Eduard_Munteanu> alecs1: you need to bind it like a <- getThatString
15:28:13 <Eduard_Munteanu> then use 'a'
15:28:44 <Eduard_Munteanu> Obviously, you need a 'do' block.
15:29:08 <alecs1> true, it's a monadic function; I didn't think that's the error
15:29:13 <Eduard_Munteanu> It won't do in 'let' or 'where'.
15:30:09 <alecs1> Eduard, I should know you from the linux360 forum, shouldn't I?
15:30:37 <Eduard_Munteanu> alecs1: hm, I am there, so it's a possibility.
15:41:04 <alecs1> so I moved on with the error:     Couldn't match expected type `[IO [String]]'
15:41:04 <alecs1>            against inferred type `IO (IO [String])'
15:41:21 <blackdog> ok, so Matrix builds in hudson are pretty damn awesome. you can give it [(Key, [Value])] and it'll build the project for every possible choice of value
15:41:25 <alecs1> http://hpaste.org/40976/io_io_string#6 , and it gives some hints to use function composition
15:41:42 <blackdog> which is rather useful when the key is "ghc version"...
15:42:01 <Eduard_Munteanu> alecs1: return doesn't return like in C.
15:42:22 <Eduard_Munteanu> alecs1: actually it doesn't alter control flow in any way.
15:42:28 <dark> alecs1, i'm trying to make sense of your indentation
15:43:05 <alecs1> it's like a series of standard "else if"
15:43:08 <Eduard_Munteanu> alecs1: it just transforms, for example in IO, a value of type Foo into another of type IO Foo. 
15:43:14 <alecs1> (written in clumsy Haskell)
15:43:57 <Eduard_Munteanu> So it's merely a function, not a special keyword.
15:44:50 <dagle> alecs1: return takes a value and puts in a type of container.
15:45:26 <sproingie> egad not the container analogy
15:45:26 <dagle> return 5 :: Maybe Int , becomes Just 5
15:45:47 <sproingie> return turns a regular value into a monadic one
15:46:08 <sproingie> > return 5 :: [Int]
15:46:09 <lambdabot>   [5]
15:46:16 <sproingie> > return 5 :: Maybe Int
15:46:16 <lambdabot>   Just 5
15:46:19 <alecs1> I'm a bit lost; I didn't get to return yet; the error is at "visitedDirectories <- map myVisit (map ((path ++ "/") ++) contentList)"
15:46:24 <Eduard_Munteanu> Also 'return concat visitedDirectories' is getting it wrong, should be 'return $ concat visitedDirectories' if anything
15:46:33 <Darkone> Uhmmm
15:46:36 <dagle> sproingie: And you think a person who write clumsy Haskell knows what a monad really is?
15:47:05 <Darkone> If you haven't gotten to return yet, you haven't gone far enough in Learn You a Haskell :P
15:47:09 <sproingie> dagle: explaining what return does is part of explaining what a monad is
15:47:11 <Eduard_Munteanu> alecs1: oh, map doesn't return a monadic value.
15:47:35 <Darkone> Be sure to do the entire section on Input/output
15:47:38 <Darkone> Also, yea.
15:47:42 <sproingie> monads are best explained by what they do, not what they look like
15:47:49 <Eduard_Munteanu> So '<-' can't really work properly there. Well, unless you factor a 'return $' before the actual value.
15:48:01 <Eduard_Munteanu> sproingie: burritos? :)
15:48:14 <sproingie> toxic burritos
15:48:59 <Darkone> Guys
15:49:19 <Darkone> filterbypos [] _ = [], filterbypos _ [] = [], filterbypos pos list = (list !! (head pos)) : filterbypos (tail pos) list
15:49:35 <caelan> sorry, alecs1. we have overgrown senses of humor
15:50:06 <alecs1> ok, so the conclusion is that I can't get that list of lists with <-? sorry for dumbing down your answers, it's just how much I understand
15:50:47 <Darkone> Hey, you're playing around with like, recursive mapping :(
15:50:52 <Darkone> I'm sitting here
15:50:56 <sproingie> can't you just map (list !!) pos?
15:50:57 <Jonny> Hi
15:51:01 <Darkone> Trying to get my simple stuff to work
15:51:03 <Eduard_Munteanu> You need to understand 'do' notation and how you'd write code without it: http://www.haskell.org/haskellwiki/Monad#Special_notation
15:51:19 <Jonny> Does anyone know how I might go about converting a number to base 3
15:51:21 <alecs1> caelan: no problem, I'll didn't fully  understand the joke :P
15:51:23 <caelan> alecs1: return doesn't do what return does in "normal" languages
15:51:23 <Jonny> in haskell
15:51:31 <Darkone> sproingie, maybe
15:51:47 <Eduard_Munteanu> alecs1: visitedDirectories <- map myVisit (map ((path ++ "/") ++)  contentList)
15:51:52 <Eduard_Munteanu> can be replaced...
15:51:55 <benmachine> alecs1: did anyone tell you to mapM yet
15:52:07 <Eduard_Munteanu> alecs1: visitedDirectories <- return $ map myVisit (map ((path ++ "/") ++)  contentList)
15:52:10 <Eduard_Munteanu> as a quick hack
15:52:26 <sproingie> return was a lousy name.  i'd have called it "give" or "yield"
15:52:37 <benmachine> sproingie: or "pure"
15:52:39 <benmachine> oh wait!
15:52:40 <sproingie> tho "yield" is likely to confuse people from python now
15:52:41 <benmachine> :P
15:52:48 <enthropy> Eduard_Munteanu: why not let, or this is for name shadowing?
15:52:52 <Darkone> CAll it "makeThisIO"
15:52:54 <Darkone> :V
15:52:56 <Jafet> Well, give is a coreturn
15:52:58 <Darkone> Literalist!
15:53:00 <Darkone> :V
15:53:02 <sproingie> "make" wouldn't be too bad actually
15:53:02 <Jafet> Or is return a cogive?
15:53:16 <benmachine> return is not that bad a name
15:53:18 <Darkone> Nonono, you're butchering my function name! 
15:53:20 <Darkone> :P
15:53:21 <caelan> alecs1: basically, return wraps a normal value inside a monad (e.g, IO)
15:53:23 <benmachine> except that everyone 'already knows' what it means
15:53:47 <Darkone> Okay, sourcedata <- readFile sourcefile, let	tships = lines sourcedata 
15:53:52 <benmachine> alecs1: you want visitedDirectories to be [[String]]
15:53:59 <Darkone> errr
15:54:04 <Eduard_Munteanu> Well, or a 'let' block.
15:54:04 <benmachine> alecs1: this means that, the stuff on the right of <- has to be IO [[String]]
15:54:09 <Darkone> let tships = lines sourcedata
15:54:12 <Jafet> @let frotz = return
15:54:13 <lambdabot>  Defined.
15:54:19 <Darkone> That = [String] RIGHT?
15:54:24 <benmachine> alecs1: I look at your code and see 'map ...' and immediately know the stuff of the right of <- is a list of some kind
15:54:32 <benmachine> alecs1: i.e. not an IO anything - hence your problem
15:54:49 <alecs1> Eduard: your solution says:    Couldn't match expected type `IO [String]'
15:54:49 <alecs1>            against inferred type `[[a]] -> [a]'
15:54:53 <sproingie> fmap if you really want it to work on stuff other than lists.  or . if you're into caleskell
15:55:14 <benmachine> alecs1: on the next line though, right?
15:55:19 <benmachine> well actually
15:55:24 <benmachine> there are several things going on here
15:55:26 <Eduard_Munteanu> alecs1: well, you're mapping with a monadic function
15:55:32 <benmachine> one is that his solution is wrong and mine is right >_>
15:55:37 <Eduard_Munteanu> that is, myVisit
15:55:43 <benmachine> you need mapM rather than map
15:55:45 <Darkone> Okay, I bet my problem is very simple. 
15:55:55 <benmachine> the other is that return concat visitedDirectories is wrong
15:56:02 <Darkone> sourcedata <- readFile sourcefile
15:56:11 <Darkone> tships = lines sourcedata
15:56:22 <benmachine> return concat visitedDirectories is parsed as (return concat) visitedDirectories, but you want return (concat visitedDirectories)
15:56:23 <Darkone> tships will be of type [String], right?
15:56:27 <alecs1> ah, I can't map with the function, finally got it (it was the same first time)
15:56:36 <benmachine> Darkone: you've got a let somewhere?
15:56:40 <Darkone> Yea
15:56:48 <benmachine> alecs1: you can map but you just don't get the right type out
15:56:50 <Darkone> Just left it out to make it easier to read on irc :V
15:56:59 <Darkone> let tships = lines sourcedata
15:57:20 <Darkone> s/let tships/let(tab)tships/
15:57:23 <benmachine> alecs1: map myVisit stringlist is type [IO [String]] - which is a perfectly okay type, but it's just not the one you want
15:57:43 <Eduard_Munteanu> Yup, benmachine got it more thoroughly, mapM will automatically yield a IO a to bind using <-
15:57:56 <Darkone> (tab)rest = map split ';' . drop 3 $ tships
15:58:02 <benmachine> :t mapM
15:58:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:58:17 <Darkone> I drop the first 3 lines from the file, because they're unimportant
15:58:26 <enthropy> Darkone: tabs can be misleading if your editor doesn't display them exactly like ghc wants them
15:58:32 <Darkone> Then I split each string into a list of strings
15:58:37 <benmachine> Darkone: wait a sec
15:58:39 <Darkone> enthropy, mine works fine
15:58:43 <benmachine> map split ';'
15:58:53 <benmachine> that's, map the split function over ';'
15:59:01 <benmachine> which is, type error
15:59:05 <benmachine> do you mean, map (split ';')
15:59:14 <Darkone> Yea
15:59:22 <Darkone> Technically, it's just "map split"
15:59:30 <Darkone> Because my split function is already partially applied
15:59:33 <benmachine> ok fine
15:59:38 <benmachine> these details are relevant :P
15:59:56 <benmachine> but yes, lines sourcedata is [String]
15:59:56 <Darkone> Okay, that will split each string into [String], right?
16:00:04 <Darkone> Giving me [[String]]
16:00:17 <benmachine> split :: String -> [String]?
16:00:22 <Darkone> Yes.
16:00:25 <benmachine> then yes
16:00:39 <Darkone> Okay
16:00:44 <alecs1> thanks, I got it compiled; no I have to see why it never stops (following some '..' recursively or smth)
16:00:58 <Darkone> filterbypos pos list = map ( list !!) pos
16:01:10 <benmachine> alecs1: you know, you could combine your tests for "." and ".."
16:01:16 <Eduard_Munteanu> alecs1: it's probably those returns that make no sense.
16:01:20 <Darkone> This allows me to extract a given set of positions from a list
16:01:20 <benmachine> alecs1: if path == "." || path == ".."
16:01:43 <Darkone> Right?
16:01:52 <benmachine> Darkone: !! has terrible error handling
16:01:53 <alecs1> oh, now I have to fix the returns :)
16:01:55 <benmachine> but sure
16:02:02 <Darkone> benmachine, unimportant atm :P
16:02:04 <benmachine> Darkone: if you don't hpaste this stuff I will forget it all
16:02:12 <benmachine> and no-one else will be able to follow
16:02:29 <Eduard_Munteanu> Ah, still on the (!!) problem?
16:02:38 <Darkone> http://pastebin.com/iZeEU1bw
16:02:48 <Darkone> The first bunch of crud is unimportant atm :P
16:02:51 <Darkone> It
16:03:09 <Darkone> It's an example of the data this thing has to parse, and then what values I'm looking for.
16:03:16 <Darkone> line 5 is where code starts
16:03:35 <benmachine> so what's wrong?
16:03:37 <Darkone> rest = [[String]]
16:03:53 <Darkone> filterbypos should be [String] -> [String], right?
16:04:15 <Darkone> Well, maybe polymorphic
16:04:19 <benmachine> filterbypos takes two arguments
16:04:22 <Darkone> Err yea
16:04:30 <benmachine> [Int] -> [a] -> [a]
16:04:37 <benmachine> would be my guess
16:04:37 <Darkone> Yea
16:04:40 <Darkone> Okay
16:04:48 <Darkone> So, values is still = [[String]]
16:05:05 <benmachine> sure
16:05:11 <Darkone> If I want to take the [String]s out of values
16:05:21 <benmachine> :t intersperse
16:05:21 <lambdabot> forall a. a -> [a] -> [a]
16:05:31 <Darkone> And flatten them into 1 string, interspersed by ';'
16:05:40 <benmachine> :t intercalate
16:05:41 <lambdabot> forall a. [a] -> [[a]] -> [a]
16:05:51 <Darkone> But
16:06:00 <Darkone> Wait, lost. Second.
16:06:01 <benmachine> shipstats :: [String]
16:06:17 <benmachine> intersperse ';' :: String -> String
16:06:28 <Darkone> Ahhh.
16:06:30 <Darkone> That must be it.
16:06:52 <benmachine> if you'd given me the paste and the GHC error straight away I could have told you like ten minutes ago :P
16:07:05 <Darkone> :V
16:07:07 <Darkone> Yea..
16:07:24 <Darkone> Wow, that was quick.
16:07:30 <Darkone> Thanks... I feel stupid now :(
16:07:31 <Eduard_Munteanu> In this case I'm not really sure there's a better way than using (!!), unless he parses all fields and associates sensible tags to each of them.
16:07:47 <enthropy> pattern matching
16:07:56 <Darkone> This is like, dirty as hell
16:07:57 <Eduard_Munteanu> I doubt that's better.
16:08:04 <Darkone> Basic idea
16:08:14 <Darkone> Take a file
16:08:18 <benmachine> Darkone: when you're learning about comonads and iteratees you'll still feel stupid on a semi-regular basis
16:08:22 <Eduard_Munteanu> x:y:z:a:b:c:d:e:f:g:h:j:aska:askdksa:asfdsafd won't be any safer in case the string is malformed.
16:08:25 <benmachine> Darkone: welcome to haskell :P
16:08:41 <benmachine> Darkone: every other language, you do stupid things and feel clever, we do it the other way around
16:08:45 <Darkone> except for the first 3 lines, each line looks like the first in that pastebin
16:08:49 <Eduard_Munteanu> or in case of a typo.
16:08:59 <Darkone> No typos ;)
16:09:03 <benmachine> Eduard_Munteanu: better than using (!!) is probably using Maybe
16:09:07 <Darkone> These files are all clean by X3TC standards
16:09:20 <Darkone> So, if the game runs, there are no typos :V
16:09:42 <Darkone> http://pastebin.com/iZeEU1bw
16:09:43 <benmachine> I like to define xs !? n = listToMaybe (drop n xs)
16:09:48 <Darkone> That first line
16:09:53 <Darkone> Is what a ship looks like
16:10:09 <Darkone> The 3rd one is the values I'm extracting.
16:10:10 <Darkone> BUT
16:10:21 <Eduard_Munteanu> I was thinking of data = Name | Location | Foo | Baz | Bar deriving Enum
16:10:38 <Eduard_Munteanu> um data Field = ...
16:10:39 <Darkone> I have to remember the values I'm not using, so that I can write them back in later
16:10:39 <benmachine> there are also much more efficient ways than using !!
16:10:48 <Darkone> I don't know.
16:10:51 <Eduard_Munteanu> and zipping with those enums.
16:11:12 <Eduard_Munteanu> Darkone: I just told you before you can use an array.
16:11:16 <Darkone> This is supposed to be a program to make it easier for me to change a LOT of ship stats at once, say, 580 ships
16:11:29 <Darkone> And directed me to the hashell page on arrays... >.>
16:11:47 <benmachine> Darkone: hmm
16:11:50 <Eduard_Munteanu> Well, it counts :)
16:12:27 <Eduard_Munteanu> Oh noes, in fact I gave example code.
16:12:44 <Eduard_Munteanu> like using listArray to build it.
16:12:59 <Darkone> In a imperative, the flow would be -> load file, split it into ships, parse ships into stats (in a vector), modify what I want, then unparse the vector, and write it all back out.
16:13:02 <Eduard_Munteanu> and (//) to update in case you choose DiffArray.
16:13:10 <Darkone> Wait, listArray? 
16:13:21 <Eduard_Munteanu> :t listArray
16:13:22 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
16:13:34 <benmachine> Darkone: that sounds pretty much what it would be like in haskell
16:13:57 <Darkone> benmachine, well, if haskell variables weren't constant :P
16:14:33 <Eduard_Munteanu> They are mutable with DiffArray.
16:14:38 <Darkone> That type dec... d:
16:14:39 <Darkone> D:
16:14:44 <Eduard_Munteanu> :t (//)
16:14:44 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
16:14:46 <enthropy> Eduard_Munteanu: you're aware of DiffArray performance?
16:14:50 <Darkone> I'm new!! D:
16:14:54 <benmachine> Darkone: that has nothing to do with it
16:15:02 <benmachine> Darkone: you just apply functions!
16:15:03 <benmachine> simples.
16:15:08 <Eduard_Munteanu> enthropy: yeah, but since he was going to kill performance with (!!), I think (//) isn't much different.
16:15:15 <Darkone> benmachine, well.... come to think of it
16:15:23 <Darkone> I could, after splitting it up like that
16:15:29 <Darkone> Using split I mean
16:15:31 <dorkitude> it seems that the inequality operators only actually check the head.. i found it experimentally. is this normal?
16:15:34 <enthropy> Eduard_Munteanu: I mean that DiffArray is probably no better than regular Array
16:15:43 <Darkone> Just apply functions to specific values
16:15:51 <benmachine> Darkone: writeFile "newfile" . unparse . modify . parse =<< readFile "oldfile"
16:15:54 <benmachine> sorted.
16:15:59 <Eduard_Munteanu> enthropy: yeah, though it's probably a bit easier to update using (//).
16:16:05 <Darkone> Like, if values = [[shipstats]]
16:16:06 <benmachine> unparse, modify, parse left as exercises to the reader
16:16:10 <benmachine> *for the reader
16:16:17 <enthropy> Eduard_Munteanu: there's no reason for DiffArray though
16:16:23 <Darkone> Hold on
16:16:27 <Eduard_Munteanu> Yeah, I agree.
16:16:29 <Darkone> Ship = [shipstats]
16:16:35 <benmachine> dorkitude: they don't only check the head
16:16:38 <Darkone> Values = [Ship]
16:16:42 <benmachine> dorkitude: but, what do you expect them to do?
16:16:44 <dorkitude> it's weird.. why does (1,100) < (2,2)  = true?
16:17:02 <benmachine> dorkitude: how else would you have it?
16:17:06 <dorkitude> but (1,100) == (1,2) = false, which means it's checking them all
16:17:26 <Eduard_Munteanu> Mmm, is there actually an instance for (Int, Int)?
16:17:33 <Darkone> So, if for each Ship in Values, I return newship, where newship is ship but with !! n modified
16:17:33 <dorkitude> well, since term 2 in the left-hand tuple is not in fact smaller than term 2 in the right-hand tuple, i expected false 
16:17:39 <Eduard_Munteanu> *an Ord instance
16:17:41 <Darkone> ...Oh god :(
16:17:44 <Twey> dorkitude: It's compared in order
16:17:48 <dorkitude> i'm on the 2nd chapter of Learn You a Haskell and he basically even *said* it would be false
16:17:52 <Twey> The snd counts for less than the fst
16:18:08 <dorkitude> oh i see!
16:18:12 <benmachine> dorkitude: so you expect (1,100) < (2,2) false, but also (1,100) > (2,2) false?
16:18:13 <Twey> If the fst is greater than the other fst, the snds won't be checked
16:18:14 <Darkone> Okay, performance is unimportant, ease of understanding: How do I do what I want to do, where what I want to do is:
16:18:32 <dorkitude> I get it now, thanks :)
16:18:36 <dorkitude> (first day with haskell)
16:18:53 <gwern> I sometimes think of writing Haskell fanfiction where I ship dons and SPJ. "'Dr. Simon...' Don trailed off - 'call me Simon', Simon said, standing erect on his unicycle"
16:19:03 <Darkone> Load file, lines it, take each line and parse by ';' (got this so far), modify specfic values in that, unparse it, unlines it, write it back
16:19:05 <Twey> Tahahaha
16:19:10 <benmachine> gwern: do it do it now
16:19:48 <dagle> gwern: Lamdba unite!
16:19:51 <Eduard_Munteanu> Darkone: http://hackage.haskell.org/package/array-0.3.0.0
16:19:52 <Darkone> It's out of my buffer now, Eduard_Munteanu, but what was the example of how I would use that?
16:19:55 <gwern> dagle: yes, precisely...
16:19:57 <dorkitude> benmachine: good point, if that were the case i see that they would have to be equal, which is definitely not true
16:19:59 <Eduard_Munteanu> Look at the load of operations you can do on an array.
16:20:08 <enthropy> Data.Map might be nicer to use
16:20:24 <gwern> benmachine: I don't think I have the ability to write it as it deserves with horrible purple prose
16:20:35 <Eduard_Munteanu> Darkone: you can quickly get an array from a list like 'listArray (0, length list - 1) list'
16:20:42 <benmachine> gwern: aww
16:20:50 <Darkone> Okay.
16:21:08 * benmachine isn't convinced arrays are necessary here
16:21:10 <Eduard_Munteanu> A type signature might be necessary to pin down a specific array type.
16:21:25 <Darkone> And can you edit a specific value of the array? I don't care if it's actually returning a new array, so long as the edit feels like you're editing, and c onserves the rest of the array
16:21:29 <Eduard_Munteanu> benmachine: it memoizes indexing by element number.
16:21:40 <benmachine> Eduard_Munteanu: sure, but performance, blah
16:21:40 <benmachine> who cares
16:21:41 <Darkone> Like
16:21:51 <Darkone> Performance doesn't matter!
16:21:53 <benmachine> Darkone: I'd split the array
16:21:57 <benmachine> as you're doing
16:21:59 <benmachine> into a normal list
16:22:07 <benmachine> and then do zip [1..] splitbits
16:22:13 <benmachine> or erm
16:22:15 <gwern> I think one must have an odd idea of me if one were to go on my quotes
16:22:17 <Darkone> This is running on my computer over a 480kb text file with 580 + 3 lines
16:22:20 <gwern> @quote already.*exist
16:22:20 <lambdabot> gwern says: my problem is that most programs I use already exist
16:22:21 <benmachine> and then do zip [0 ..] splitbits -- probably better
16:22:38 <benmachine> gwern: is that idea broadly speaking accurate, too >_>
16:22:39 <Darkone> Wait, split the array?
16:22:45 <Darkone> Right now, I'm splitting a string.
16:22:49 <benmachine> Darkone: okay I'm just confusing you now :P
16:22:53 <benmachine> Darkone: I don't think you need an array
16:22:53 <Darkone> Splitting a bunch of strings
16:23:01 <gwern> benmachine: psychological studies tell us that most people think they are more accurate than average at self-assessment
16:23:10 <Darkone> Okay then, how would I easily modify  these INPLACE
16:23:13 <benmachine> gwern: this is kind of expected
16:23:21 <gwern> benmachine: but highly ironic
16:23:31 <benmachine> gwern: I know people use it as indicative that people are all self-obsessed or whatever
16:23:41 <Eduard_Munteanu> Inplace? You don't really care about performance.
16:23:41 <benmachine> gwern: but I think it would be a strange world if everyone went around thinking they were wrong
16:23:51 <Darkone> given the list ["0","0","2","2","1","0","500"]
16:23:58 <benmachine> Darkone: what I would do is, once you've got your bits
16:24:00 <gwern> benmachine: I think I'm worse than average at many things
16:24:12 <Darkone> If I want to edit "2", "2", "1", and "500"
16:24:16 <benmachine> gwern: well, good for you, sort of
16:24:17 <gwern> benmachine: nothing odd about that. not everyone is above-average at leadership or at driving, say
16:24:19 <Darkone> And CONSERVE the rest, so it isn't lost
16:24:23 <Darkone> How?
16:24:42 <gwern> benmachine: and it's better to be subaverage and know it than to be subverage and be deluded into thinking one is above average
16:24:42 <Darkone> For example, the first edit may change index 2 to "4"
16:24:51 <Darkone> Creating a new list 
16:24:55 <benmachine> Darkone: zip [0 ..] bits would get you a list [(0, "2"), (1, "2") ...]
16:24:59 <Darkone> ["0","0","4","2","1","0","500"]
16:25:12 <benmachine> Darkone: then I would map a function over the bits that did something conditional on what the index number (first of the tuple was)
16:25:22 <benmachine> Darkone: usually it would just return the second bit of the tuple, but it might modify it first
16:25:38 <Darkone> So, I would need to have a function for each thing
16:25:47 <Eduard_Munteanu> Not really.
16:25:52 <benmachine> gwern: true. but weren't you commenting that most people think they are good at self-assessment? so you think you are right about being sub-average at some things
16:25:56 <Darkone> Like, changeyaw (index, value) = ...
16:26:05 <Eduard_Munteanu> You can use a 'case' or guards.
16:26:05 <Darkone> changepitch .. = ..
16:26:10 <benmachine> Darkone: you'd have
16:26:11 <Darkone> Yea, 
16:26:13 <gwern> benmachine: I do; I'm quite convinced I'm a bad driver
16:26:13 <Darkone> I can
16:26:18 <dancor> the question of "being good at self-assessment" doesn't seem to be a very specific one
16:26:22 <Darkone> Wait
16:26:30 <benmachine> gwern: I would be an awful driver if I drove, but I don't :P
16:26:31 <Darkone> I could just use apttern matching?
16:26:35 <Eduard_Munteanu> foo (i, str) = case i of ...
16:26:38 <benmachine> I settle for being a bad cyclist
16:26:41 <dancor> possibly to the point that the concept in meaningless and not useful
16:26:44 <benmachine> conscientious but incompetent >_>
16:26:46 <dancor> s/in/is/
16:26:48 <gwern> benmachine: to the extent that I have a posthumous letter for my family which essentially goes 'you laughed at me for being paranoid and thinking I'm a bad driver; I told you so'
16:26:59 <Darkone> changevalues (2, value) = blahblah value  --Changes yaw
16:27:05 <Eduard_Munteanu>   1 -> str
16:27:07 <benmachine> dancor: sure it's specific, am I good at predicting my aptitude relative to my peers at various tasks
16:27:13 <Eduard_Munteanu>   2 -> "2"
16:27:16 <gwern> callous, perhaps, but I've always valued the truth
16:27:18 <Darkone> changevalues (3, value) = blahblah value  --Changes pitch
16:27:25 <Eduard_Munteanu>   otherwise -> str
16:27:26 <benmachine> gwern: ... if you think it's that bad, stop driving? >_>
16:27:27 <dancor> benmachine: averaged over what set of tasks?
16:27:35 <benmachine> dancor: all tasks.
16:27:39 <gwern> benmachine: I have no choice. driving is too useful
16:27:40 <benmachine> dancor: or any subset that is relevant to you
16:27:42 <benmachine> gwern: :(
16:27:46 <gwern> damn suburbs eh
16:27:47 <dancor> benmachine: all conceivable tasks?  what does that set look like..
16:27:54 <benmachine> dancor: it's really really big
16:27:57 <benmachine> but finite.
16:27:57 <dancor> ha
16:27:59 <benmachine> sort of
16:28:05 <dancor> i'm not sure if it's finite
16:28:11 <Darkone> Actually
16:28:11 <benmachine> no
16:28:14 <benmachine> probably countable though
16:28:17 <Darkone> This array might be easier.
16:28:23 <dancor> maybe all-tasks-with-a-discripiton-in-some-system-under-some-size
16:28:25 <Eduard_Munteanu> Um '_' instead of otherwise.
16:28:25 <benmachine> Darkone: sorry I kind of keep forgetting aboutyou
16:28:53 <benmachine> dancor: snip 'some-system' on the basis that most interesting systems can describe each other :P
16:29:00 <Darkone> listArray (0, length list - 1) list
16:29:00 <benmachine> so really any system will do
16:29:15 <Eduard_Munteanu> Darkone: nah, you can do like benmachine 
16:29:22 <Darkone> Yea, I guess.
16:29:25 <Eduard_Munteanu> just read up ^
16:29:36 <Eduard_Munteanu> You can map that foo over the zipped list.
16:30:55 <EvanR> map that foo over the zipped bar
16:31:05 <EvanR> ^ standard haskell program
16:31:05 <Darkone> Okay hold on
16:31:11 <Eduard_Munteanu> ... makes it fubar :P
16:31:20 <Darkone> Rest = split . drop 3 $ tships
16:31:32 <Darkone> produces [[String]
16:31:37 <Darkone> ]*
16:31:45 <benmachine> wasn't it map split before
16:31:52 <Darkone> Woops yea
16:31:56 <Darkone> Left out the map. 
16:32:04 <benmachine> Darkone: haskell is notoriously picky about details
16:32:08 <Darkone> I stupidly deleted it from my code
16:32:12 <Darkone> Now it's back
16:32:18 <Darkone> Okay, Shipstats = String
16:32:21 <benmachine> if you are slapdash about them we are going to be just as confused as GHC :P
16:32:28 <Darkone> Ship = [Shipstats]
16:32:34 <Darkone> rest = [Ship]
16:32:50 <Darkone> So rest = [[string]]
16:32:58 <Eduard_Munteanu> @vixen Could you help Darkone?
16:32:58 <lambdabot> whoa whoa whoa, one question at a time!
16:33:15 <Darkone> I would have to extract out that list, and then zip the extracted list, right?
16:33:38 <Eduard_Munteanu> Yes, then map over it.
16:33:52 <Darkone> Right, jsut checking. Errors make me cry :(
16:33:56 <Darkone> Compielr errors that is
16:34:02 <Darkone> Typofest.
16:34:04 <Eduard_Munteanu> foo :: (Int, String) -> String
16:35:42 <Darkone> After zipping, I should have [[(int, string)]]
16:35:43 <Darkone> right?
16:35:51 <Eduard_Munteanu> Mmm, no.
16:35:55 <Darkone> Uhhmm
16:36:01 <Eduard_Munteanu> [(Int, String)]
16:36:05 <benmachine> right
16:36:05 <Darkone> First I have [[String]]
16:36:15 <benmachine> Darkone: work with each line separately
16:36:19 <Darkone> I turn each [String] 
16:36:28 <Eduard_Munteanu> Oh, multiple lines.
16:36:29 <Darkone> Into [(int,string)]
16:36:34 <benmachine> yes
16:36:35 <Darkone> Right?
16:36:36 <Darkone> Okay
16:36:38 <benmachine> Darkone: well, sort of
16:36:55 <benmachine> Darkone: I would define the function to work on each line
16:37:01 <benmachine> to do all the work on each line
16:37:04 <Darkone> Ehh...
16:37:07 <benmachine> rather than repeatedly mapping over all the lines
16:37:24 <Darkone> I'm applying the same function to each ship
16:37:32 <Darkone> Which is a pseudonormalization
16:37:40 <benmachine> that is a long word and I'm tired
16:37:50 <Darkone> It's probably not a real word either
16:37:53 <Darkone> But I like it.
16:37:55 <benmachine> heh
16:37:57 <benmachine> ok
16:38:00 <benmachine> well anyway
16:38:09 <benmachine> if you're altering each line independently
16:38:17 <benmachine> then define a function String -> String
16:38:26 <benmachine> which splits, zips, maps, and joins
16:38:38 <benmachine> and then map it over the list at the end
16:38:46 <alecs1> hi, I need one more piece of help: I want to filter out "." and ".." out of  "contentList <- getDirectoryContents path" and run out of patience
16:38:49 <benmachine> try to break up your program into parts that work independently of each other
16:39:05 <EvanR> check out my Typewriter!
16:39:08 <EvanR> http://codepad.org/OsI2ccmi
16:39:13 <benmachine> alecs1: there are a few ways you could do that
16:39:25 <Eduard_Munteanu> :t filterM
16:39:26 <benmachine> alecs1: the simplest is:
16:39:26 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
16:39:35 <benmachine> unfilteredContents <- getDirectoryContents path
16:39:43 <EvanR> now you can write composable indented text! ;)
16:39:56 <Eduard_Munteanu> um, rather not...
16:39:57 <benmachine> let contentList = filter (\x -> x /= "." && x /= "..") unfilteredContents
16:39:58 <Eduard_Munteanu> :t filter
16:39:58 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:40:05 <benmachine> then use contentList
16:40:31 <benmachine> if you feel like being clever, you can do something more like
16:40:43 <Darkone> benmachine, I see now
16:40:57 <benmachine> contentList <- fmap (filter (`notElem` [".", ".."])) $ getDirectoryContents path
16:41:06 <benmachine> but if you don't understand how that works you should probably use the other version
16:41:54 <benmachine> Darkone: haskell's biggest strength is it's very good at gluing small working programs into big ones; you should exploit this by splitting stuff up as much as possible, then you can see how each bit works in isolation
16:43:24 <alecs1> thanks everyone, "let contentList = filter (\x -> x /= "." && x /= "..") unfilteredContents" worked; I can finally go to sleep now
16:43:59 <Eduard_Munteanu> Heh, no, mr. Curry will haunt your dreams.
16:44:23 <alecs1> I'll understand that filter expression tomorrow; I didn't imagine a directory traversal is a +3 hours endeavour;
16:44:32 <Eduard_Munteanu> (I often get Tetris-effect from programming.)
16:44:40 <EvanR> this 'pattern' is awesome, is there a name for it, or a way to abstract it?
16:44:46 <sproingie> Eduard_Munteanu: tim curry?  not sure i want dr frankenfurter in my dreams :-/
16:44:56 <Eduard_Munteanu> alecs1: unlearning is a big endeavor.
16:45:25 <Eduard_Munteanu> sproingie: no no, mr. Haskell Curry :)
16:45:27 <EvanR> ive been haunted by relation databases recently
16:45:30 <dagle> alecs1: if I put the file ././ ?
16:45:31 <EvanR> relational
16:45:38 <EvanR> combined with haskell
16:46:06 <Eduard_Munteanu> EvanR: I failed an SQL exam at some point, so I know :)
16:47:50 <EvanR> type Operator = S -> S, monoid mempty = id, mappend = flip (.), and a 'run' function :: Operator -> T where T is derived from 'final' S
16:47:54 <Eduard_Munteanu> alecs1: by chance, are you studying at UPB and got a course that deals with Haskell? :)
16:48:09 <Eduard_Munteanu> I've seen people coming from there.
16:48:17 <EvanR> this gets much less attention than monads or applicative
16:49:20 <alecs1> dagle: http://hpaste.org/40979/result , it's a bit funny but I won't look at it now
16:50:03 <alecs1> Eduard: no, I finished school, and it was informatics at West University
16:50:15 <alecs1> never studied Haskell there
16:50:51 <caelan> alecs1: my school actually has a class that teaches several functional langs
16:51:05 <alecs1> some LISP, but unfortunately I was a lazy student most of the time;
16:51:08 <dagle> alecs1: what are you really trying to do? It really feels like you are doing something wrong. :P
16:51:14 <Eduard_Munteanu> That's the case here, although not in my major.
16:51:17 <EvanR> alecs1: that makes haskell a great match for you!
16:52:21 <alecs1> I studied Python, Qt, C++ rather than attend school as I should have done
16:52:33 <alecs1> dagle: I'm trying to write useful programs
16:52:34 <EvanR> im sorry to hear that
16:53:16 <Eduard_Munteanu> I'm not great on attendance either.
16:53:27 <dagle> alecs1: But I feel like your program has bugs to it. :P
16:53:54 <dagle> But I'm not sure what i should do.
16:54:02 <dagle> it*
16:54:51 <monochrom> if you attended school, you would study C++ anyway
16:55:33 <alecs1> dagle: following "Real world Haskell" was tiresome, it made some JSON framework before even opening a file
16:55:45 <alecs1> dagle: yes, it has bugs
16:56:04 <Darkone> Yea...
16:56:23 <Darkone> It did explain some things better than Learn You..
16:56:41 <alecs1> monochrom: yes there was C++, but I studied it much more than we did at school; there we rather concentrated on C
16:57:01 <Eduard_Munteanu> Now the nicer stuff... I forgot to tell you. I got TAPL a few days ago! :)
16:57:16 <Eduard_Munteanu> Seems excellent.
16:57:17 <endojelly> alecs1, it's very very very *very* useful to have a very good foundation on C to use C++
16:57:25 <endojelly> alecs1, and there are a lot of subtelties
16:57:26 <Eduard_Munteanu> Not many books provide dependency graphs for chapters :)
16:58:15 <EvanR> useful / basically required unless you want things to fall apart
16:58:22 <EvanR> wait, things will fall apart anyway, nevermind
16:58:27 <Eduard_Munteanu> In retrospect, I didn't really like Awodey's, but I'm not sure if he could've done much better.
16:58:56 <dolio> Awodey's dependency graph?
16:59:15 <Eduard_Munteanu> dolio: no, Awodey's book. In comparison to TAPL, it seems "all over the place".
16:59:21 <Eduard_Munteanu> (on category theory)
16:59:21 <dagle> I have used c++ once in school. During computer graphics where it would be kinda silly to use anything other then c++.
16:59:34 <Eduard_Munteanu> dolio: TAPL's got a dependency graph.
17:00:20 <Eduard_Munteanu> And TAPL's got lots more people listed on pedagogy consulting rather than actual content, so I guess that says something.
17:01:17 * hackagebot sifflet-lib 1.2 - Library of modules shared by sifflet and its  tests and its exporters.  http://hackage.haskell.org/package/sifflet-lib-1.2 (GregoryWeber)
17:01:45 <dolio> I guess Awodey's book could be better in that regard, yeah.
17:02:02 <dolio> I wasn't particularly thrilled by the chapter on group theory in the middle of everything.
17:02:19 <dolio> For instance.
17:02:31 <Eduard_Munteanu> dolio: yeah, that's exactly my sort of issue with Awodey's. 
17:03:01 <Eduard_Munteanu> And definitions in middle of exercises/examples, which you do need later.
17:03:17 * hackagebot sifflet 1.2 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-1.2 (GregoryWeber)
17:07:15 <alecs1> guys, thank you for your help; it's 3 AM in Bucharest, I wish it was 1 or something
17:07:18 <alecs1> good night
17:08:30 <Eduard_Munteanu> alecs1: good night.
17:08:56 * Eduard_Munteanu regularly goes on a screwed up sleep schedule.
17:14:04 <Darkone> Quick, what's opposite of read again?
17:14:51 <dark> show?
17:14:57 <Darkone> Doh
17:14:59 <Darkone> Thanks mon
17:24:41 <bleepbloop> noob question: If I download Hugs, am I right in thinking that I don't need to download the Haskell platform as well?
17:25:05 <enthropy> bleepbloop: depends what you want to do
17:25:13 <Axman6> hugs is just an interpreter, if you want to compile haskell programs, you'll want ghc anf the platform
17:26:15 <bleepbloop> I'm not really sure yet, I've never used Haskell before so I wanted to try it out, and I heard Hugs is the most user friendly interpreter, but I guess I'd be wanting a compiler as well
17:26:37 <AnAdorableNick> bleepbloop: I'd suggest ghci
17:27:24 <monochrom> if you use hugs, you don't need the haskell platform.
17:28:55 <bleepbloop> sweet, thanks!
17:30:26 <cads> @t (\a -> a^2 > 10)
17:30:27 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:30:39 <cads> @type (\a -> a^2 > 10)
17:30:40 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
17:30:44 <Darkone> I must be doing something wrong :P
17:30:52 <monochrom> thank you (\a -> a^2 > 10)
17:30:55 <monochrom> @thank
17:30:55 <lambdabot> Maybe you meant: thank you thanks
17:31:00 <Darkone> These functions are so complex
17:31:01 <monochrom> @thank you
17:31:02 <lambdabot> Maybe you meant: thank you thanks
17:31:05 <monochrom> @thanks
17:31:06 <lambdabot> you are welcome
17:31:08 <monochrom> haha
17:31:12 <monochrom> @thankyou
17:31:13 <lambdabot> you are welcome
17:31:30 <monochrom> @thankyou (\a -> a^2 > 10)
17:31:30 <lambdabot> you are welcome
17:32:27 <enthropy> @kthx
17:32:27 <lambdabot> you are welcome
17:32:45 <unkanon> @ty
17:32:46 <lambdabot> <no location info>: not an expression: `'
17:32:49 <Axman6> bleepbloop: i'd also recommend you go with the haskell platoform, it's used by everyone, and is under very active development. hugs has some other problems, that aren't likely to get fixed
17:32:51 <unkanon> aww..
17:33:15 <Eduard_Munteanu> Everyone? :)
17:33:29 <Axman6> pretty much
17:33:47 * Eduard_Munteanu looks it up on his Gentoo
17:33:52 <cads> @type [1..]
17:33:53 <lambdabot> forall t. (Num t, Enum t) => [t]
17:34:05 <Eduard_Munteanu> Hm, keyword masked.
17:34:09 <blackdog> ghc was too slow for me. i just reduce redexes in my head.
17:35:09 <Eduard_Munteanu> I don't think "take this huge binary" will fly with distributors.
17:38:12 <bleepbloop> I think I'll just try Hugs since there's already a port for it in the freebsd ports, and if I don't like that I can always download the platform later
17:40:51 <Darkone> oh god oh god
17:41:22 <Darkone> Eduard_Munteanu, when I supply a string like 0;0;2.199997;2.799988;0.5;SG_SH_M5;4711;142500;55000;105;1;5;378;1000;168;202;ships\argon\argon_M5_scene;ships\argon\cockpits\argon_m5_cp_scene;0;0;1;0.0;0;2;0;0;30;10;10;35;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;1;2000;35;36 ... 
17:41:29 <Darkone> I cut eit down btw
17:41:53 <Darkone> But when I supply that, it won't try to parse those \? Will iot automatically add the needed \ to them?
17:41:59 <Darkone> Err.
17:42:06 <Darkone> Like, that's in the textfile
17:42:13 <Eduard_Munteanu> \? ?
17:42:21 <Eduard_Munteanu> Isn't that some non-printable char?
17:42:24 <Darkone> When I read it, it will be like that, with endlines = \n or whatever
17:42:41 <Darkone> Will it try to read things like \a in \argon as a special character?
17:42:46 <Eduard_Munteanu> Darkone: just lines and unlines it
17:42:56 <Eduard_Munteanu> I doubt it.
17:43:09 <Darkone> These functions are getting way too long
17:43:45 <Eduard_Munteanu> Literal \argon should be read fine, though if you want to type it by hand it would look like "\\argon"
17:43:46 <Darkone> http://pastebin.com/ncxPmGc8
17:43:54 <Darkone> This is what I have so far.
17:43:56 <sshc> I'm trying to build a cabal project, but it fails with "File name does not match module name: Saw `Main' Expected `Foo'", but Main isn't anywhere in Foo.hs.  When I comment out "import Foo" (which is still needed for building, apparently still after it fails), it fails with the same message but for another module.
17:44:07 <Darkone> It's uggly, inefficient, and probably has some errors or bugs
17:44:29 <Darkone> But it's the best I can do atm... and it's already long as hell for such a simple job.
17:44:29 <sshc> same message except for "Expected `<modulename>'"
17:44:45 <Darkone> I'm thinking I need to presplit and zip it
17:45:02 <Darkone> PArt of it is because of constant/static variables.
17:45:11 <sshc> Does anybody have a clue?
17:45:21 <Darkone> I can just go ship !! 7 = HerpDerp
17:45:38 <Eduard_Munteanu> Darkone: is it causing you any problems at this point? You should attempt zipping, that's easy.
17:45:55 <Darkone> I have to get everything before ship !! 7, everything after, and when making the new string, ++ them before and after the modded value
17:46:08 <Darkone> Eduard_Munteanu, it's causing me problems with being bloody complicated :(
17:46:51 <Eduard_Munteanu> Darkone: well, that's an issue, why not simply structure your program like write . unsplit . process . split . read ?
17:47:05 <Eduard_Munteanu> And make all changes in process?
17:47:32 <Darkone> write . unlines . unsplit . process . preprocess . split . lines . read is closer
17:47:41 <Eduard_Munteanu> Hm, yes.
17:47:46 <Darkone> I can probably do all in process
17:47:51 <Darkone> But might end up messier.
17:47:58 <Darkone> Preprocess is one thing:
17:48:09 <Darkone> Check each ship's value for EngineTunings
17:48:36 <Darkone> If it's > 15, reduce it to 15, and --increase base speed-- by a value based on how many tunings you remove.
17:49:13 <Darkone> 0.1 per tuning
17:49:24 <Darkone> So if it's <= 15, then multiplier = 1
17:49:32 <Darkone> If it's > 15, say, 17
17:49:37 <Darkone> Then mult = 1.2, etc
17:49:44 <Darkone> Or for the extreeeeme end
17:49:53 <Darkone> The starburst has 30 mults
17:50:04 <sshc> I'm trying to build a cabal project, but it fails with "File name does not match module name: Saw `Main' Expected `Foo'", but Main isn't anywhere in Foo.hs.  When I comment out "import Foo" (which is still needed for building, apparently still after it fails), it fails with the same message but for another module and "Expected: <module name>".
17:50:13 <Darkone> So it would be 1 + (30 - 15) * 0.1
17:50:16 <Eduard_Munteanu> Darkone: hm, you could fold over the zipped list to extract some values you need into a common environment.
17:50:20 <Darkone> Or 2.5
17:50:55 <Darkone> I'm surprised noone has pointed out some library for doing imperative style operations like that :P
17:51:10 <Darkone> Inplace modification is slow, but it's /all/ you can do with this :/
17:51:29 <Axman6> what are you trying to do?
17:52:31 <Eduard_Munteanu> Darkone: in imperative languages you'd access by index, though that would be considered unsafe too.
17:52:36 <Darkone> Axman6, load a file
17:52:46 <Darkone> It has a bunch of lines in it
17:52:48 <Axman6> to do what?
17:52:52 <Darkone> Each represents a ship's stats
17:53:13 <blackdog> you'd usually use Parsec for that sort of thing.
17:53:29 <Eduard_Munteanu> Axman6: he wants to modify semicolon-separated values in a line. Some can be changed directly, others depend on other "columns".
17:53:39 <Eduard_Munteanu> And write them back.
17:53:42 <Darkone> I want to parse the stats, turn them into numbers, do operations on /some/ of them, and then turn them into strings, and unparse.
17:53:50 <Darkone> Right
17:53:59 <Darkone> Preprocessing is the only dependancy
17:53:59 <Eduard_Munteanu> He already separated the file into lines and columns.
17:54:03 <Axman6> hmm, what's that parsing library that returns a continuation if it's awaiting more data?
17:54:18 <Saizan> attoparsec is one
17:54:19 <Eduard_Munteanu> Don't go that way on him :)
17:54:37 <Darkone> preprocess changes speed (index 7) if enginetunings (index 26) is > 15
17:54:57 <Darkone> The rest are inplace, with constants and equations supplied by me
17:55:20 <Eduard_Munteanu> Now some people suggested he should really avoid (!!).
17:55:29 <Darkone> Like speed += ((targetspeed - speed) / 12)
17:56:06 <Darkone> Performance is unimportant. If I had started this in C# I would have an unsafe, but working version by now XD
17:56:11 <Axman6> well, sounds like a good use of a very large record
17:56:22 <Darkone> I thought this would be easy in haskell :P
17:56:54 <Eduard_Munteanu> You can use (!!) and forget about people nagging if you really need this fast.
17:57:19 <Darkone> Performance does not matter, and it is impossible for it to fail outside of programming error
17:57:29 <Darkone> The text file is perfect
17:58:10 <Axman6> care to chare what you have now?
17:58:13 <Axman6> share*
17:58:14 <Darkone> http://pastebin.com/ncxPmGc8
17:58:15 <Eduard_Munteanu> Darkone: or you can simply add an additional fold before the map, that parses out the little bits you need.
17:58:46 <Darkone> Eduard_Munteanu, can you show like, a pseudocode example? I'm kind of burnt by now, so I have no clue what you mean
17:58:51 <Eduard_Munteanu> The folding function looks like fixit.
17:59:26 <Darkone> I was using pattern matching, because each position that needs to be modified needs a different function
18:00:00 <Eduard_Munteanu> Darkone: data Environment = Environment { targetSpeed :: Int }
18:00:33 <Eduard_Munteanu> foldl getTheEnvironment string_line
18:01:11 <cads> @hoogle Integer -> String
18:01:12 <lambdabot> Prelude show :: Show a => a -> String
18:01:12 <lambdabot> Text.Show show :: Show a => a -> String
18:01:12 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
18:01:18 <cads> err
18:01:22 <cads> @hoogle Integer -> Char
18:01:23 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
18:01:23 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:01:23 <lambdabot> Prelude show :: Show a => a -> String
18:01:30 <Darkone> http://pastebin.com/fTr1jCN3 
18:01:38 <Darkone> Made a couple small changes
18:01:41 <Eduard_Munteanu> um, foldl getTheEnvironment (Environment 0) string_line
18:01:43 <cads> @hoogle digit
18:01:43 <lambdabot> Text.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
18:01:43 <lambdabot> Text.ParserCombinators.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
18:01:43 <lambdabot> Data.Char digitToInt :: Char -> Int
18:01:46 <Darkone> Removed some command line arguments
18:02:06 <Darkone> Removed Fixit for Engine, because engine will be handled in preprocessing
18:03:20 <Eduard_Munteanu> getTheEnvironment (i, s) env= case i of ... 3 -> env { targetSpeed = read s }
18:03:30 <Eduard_Munteanu> And you can fill in the blanks.
18:03:49 <Eduard_Munteanu> and add other properties you need.
18:05:23 <Eduard_Munteanu> Then when you map fixit, you can send in the Environment, like map (fixit env) ... (and of course modify fixit a bit)
18:05:42 <Darkone> so wait
18:06:00 <Darkone> Environment is a custom type that stores a value
18:06:07 <Eduard_Munteanu> yes.
18:06:16 <Darkone> Well, make it a float, not an int
18:06:34 <Eduard_Munteanu> Whatever suits you.
18:07:11 <Darkone> And with... wait, so foldl getTheEnvironment (Environment 0) string_line  is only searching for a specfic value?
18:07:42 <Darkone> nervermind
18:07:48 <Darkone> Too late, and I'm being stupid ATM
18:07:49 <Eduard_Munteanu> Darkone: no, it builds an Environment by going over each token/column in the line.
18:08:08 <Axman6> i don't think that will work...
18:08:16 <Eduard_Munteanu> (the otherwise case is just otherwise -> env)
18:08:17 <Axman6> unless you're doing something different to what i think you are
18:08:35 <Darkone> Okay, hacksaw time.
18:08:44 <Darkone> What if I completely cut out the values I want
18:08:49 <Darkone> Work on them
18:08:57 <Eduard_Munteanu> Axman6: why? It's using a fold to parse some columns.
18:08:57 <Darkone> And then when I go to write it
18:09:19 <Darkone> I just zipWith makeNewLine newValues oldValues
18:09:20 <Eduard_Munteanu> Axman6: his string_line is actually a [String]
18:09:24 <Axman6> Eduard_Munteanu: what are the elements of Environment?
18:09:34 <Darkone> Axman6, here's the specs
18:09:44 <Darkone> The file is 583 lines or so
18:09:53 <Eduard_Munteanu> Axman6: it's a data in record syntax.
18:09:59 <Darkone> The first 3 are crap that can be ignored until it's time to write a new file
18:10:17 <Darkone> The rest are semi-colon delimited stats and stuff
18:10:17 <Axman6> Eduard_Munteanu: yes, and what are the elements?
18:10:23 <Darkone> Like name, speed, etc.
18:10:27 <Darkone> each line is one ship
18:10:35 <Axman6> yup
18:10:35 <Eduard_Munteanu> Axman6: um, he knows, suppose it's a Float, some Ints etc.
18:11:02 <Darkone> It's a mix of junk.
18:11:09 <Darkone> The stuff I'm after are some floats and ints.
18:11:35 <Darkone> Positions on the line corresponding (index starting at 0) to 2,3,4,7,8
18:11:47 <Darkone> 2,3,4,7,8,26 
18:11:48 <Eduard_Munteanu> But those values are still stringified when he gets them.
18:11:54 <Darkone> I'll be reading and modifying
18:12:05 <Darkone> http://pastebin.com/fTr1jCN3
18:12:08 <Darkone> Line one
18:12:08 <sshc> Ah, I had my import list before "module"
18:12:12 <Darkone> Is ONE LINE.
18:12:22 <Darkone> And it's one of the simpler ships, no weapons
18:13:03 <Axman6> Eduard_Munteanu: you can't just initialise it to Environment 0 then, you need to initialise all the elements
18:13:22 <Darkone> All I want to do
18:13:26 <Darkone> Is read each line
18:13:26 <Eduard_Munteanu> Yes, of course. My example contained a single value, he can extend it.
18:13:34 <Darkone> Parse it and whatever
18:14:09 <Darkone> Look at index 26, and if it's over 15, set it to 15 while increasing index 7 proportionately
18:14:23 <Eduard_Munteanu> Or he can simply use (!!) :)
18:14:33 <Darkone> Actually, increase both index 7 and 8 :|
18:14:39 <Darkone> After that
18:14:59 <Darkone> I go through indexes 2,3,4,7(modified),8(modified)
18:15:16 <Darkone> And normalize them to a value with equations and constants of my own design
18:15:56 <Darkone> 7 is speed, and is normalized thus: speed += (500000 - speed)/12
18:16:01 <Darkone> As an example
18:16:30 <Darkone> Thoughts now?
18:16:39 <Darkone> Pretty dang simple.
18:17:29 <Darkone> Not sure why it's so hellish in practice :(
18:18:37 <Darkone> Ahh hell
18:18:41 <Darkone> 8 is dependant on 7
18:18:56 <Darkone> I'm changing accel proportionately to speed change
18:19:16 <Eduard_Munteanu> Axman6: actually you can have something like 'data Environment = NoEnv | Environment { ... }' and not initialize them all, though it's a bit unsafe.
18:20:10 <Eduard_Munteanu> Um, no, that sounds terribly unsafe after all...
18:22:00 <Eduard_Munteanu> Darkone: oh well, if you find this too bad, you can go back to the array idea.
18:22:22 <Eduard_Munteanu> At least it provides better upper bounds for accessing by index.
18:22:51 <Eduard_Munteanu> and easier updating.
18:23:13 <Eduard_Munteanu> Just do like this...
18:23:58 <Darkone> Look at it this way
18:24:06 <Eduard_Munteanu> ar = listArray (0, length row - 1) row
18:24:10 <Darkone> The indicies I want to modify exist for all lines
18:24:30 <Eduard_Munteanu> Then you can use (//) on ar to update.
18:24:33 <Eduard_Munteanu> :t (//)
18:24:34 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
18:24:46 <Eduard_Munteanu> and (!) to access a specific index.
18:24:48 <Darkone> I'm way too slow to understand that.
18:24:48 <enthropy> @type M.modify
18:24:49 <Eduard_Munteanu> :t (!)
18:24:49 <lambdabot> Couldn't find qualified module.
18:24:49 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
18:24:57 <enthropy> @type Data.Map.modify
18:24:58 <lambdabot> Not in scope: `Data.Map.modify'
18:25:03 <enthropy> @type Data.Map.update
18:25:03 <lambdabot> forall a k. (Ord k) => (a -> Maybe a) -> k -> M.Map k a -> M.Map k a
18:25:09 <Eduard_Munteanu> Darkone: examples: 3 (!) ar
18:25:32 <Eduard_Munteanu> ar (//) [(5, "foo")] -- replaces index 5 by "foo"
18:25:33 <Darkone> ar = listArray (0, length row - 1) row   = take a split line from file, and make it array?
18:25:41 <Eduard_Munteanu> Darkone: yes.
18:25:46 <Darkone> Okay.
18:25:58 <enthropy> > let ar =listArray (0,1) "ab" :: Array Int Char in 3 (!) ar
18:25:59 <lambdabot>   Ambiguous type variable `i' in the constraint:
18:25:59 <lambdabot>    `GHC.Arr.Ix i'
18:25:59 <lambdabot>      arisi...
18:26:24 <enthropy> > let ar =listArray (0,1) "ab"; ar :: Array Int Char in 3 (!) ar
18:26:25 <lambdabot>   Ambiguous type variable `i' in the constraint:
18:26:25 <lambdabot>    `GHC.Arr.Ix i'
18:26:25 <lambdabot>      arisi...
18:26:45 <enthropy> of course that's not how you're supposed to use !
18:26:49 <Darkone> So,  mkarray list = listArray (0, (length list - 1)) list 
18:27:08 <Eduard_Munteanu> > let ar = listArray (0,1) "ab"; ar :: Array Int Char in 3 ! ar
18:27:09 <enthropy> it needs a type signature most likely
18:27:09 <lambdabot>   No instance for (GHC.Arr.Ix
18:27:09 <lambdabot>                     (GHC.Arr.Array GHC.Types.In...
18:27:28 <enthropy> Eduard_Munteanu: you know the type puts the array as the first argument?
18:27:37 <Darkone> let mkarray list = listArray (0, (length list - 1))
18:27:55 <Darkone> Ermm how to I address that to lambdabot?
18:28:07 <Darkone> let mkarray list = listArray (0, (length list - 1)) list 
18:28:10 <Eduard_Munteanu> enthropy: I'm not sure what you mean.
18:28:20 <enthropy> @type (!)
18:28:20 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
18:28:26 <Eduard_Munteanu> Oh.
18:28:38 <enthropy> you write   (!) array index = array ! index
18:28:38 <Eduard_Munteanu> > let ar = listArray (0,1) "ab"; ar :: Array Int Char in ar ! 3
18:28:39 <lambdabot>   *Exception: Error in array index
18:28:43 <Eduard_Munteanu> > let ar = listArray (0,1) "ab"; ar :: Array Int Char in ar ! 1
18:28:44 <lambdabot>   'b'
18:28:55 <Eduard_Munteanu> I just copy-pasted you :)
18:29:12 <enthropy> if that mistake is coming up for you... perhaps design is more tricky
18:29:22 <Eduard_Munteanu> Darkone: you need to start the line with >
18:30:12 <Darkone> Can it remember a couple? Like if I tell it that, then let myArray = mkarray "Hello everyone", I can then access myArray?
18:30:51 <Eduard_Munteanu> You need @let for that
18:30:52 <enthropy> this \\ function you're supposed to be using isn't all that difficult to write for lists
18:31:41 <Eduard_Munteanu> enthropy: I doubt it's any better on lists.
18:31:48 <Eduard_Munteanu> Or faster to write.
18:33:09 <Darkone> parsedlist = map split rest
18:33:15 <Darkone> arrayedlist = map mkarray parsedlist
18:33:21 <Darkone> mkarray list = listArray (0, (length list - 1)) list
18:33:24 <Darkone> Sound right?
18:33:37 <Eduard_Munteanu> Darkone: yeah.
18:33:57 <Eduard_Munteanu> Darkone: though I'd rather do the array transformation and processing in a separate function
18:34:19 <Darkone> [Array] basically, correct? (ignoring whatever the type of it is)
18:34:33 <Eduard_Munteanu> Darkone: err, no.
18:34:43 <Darkone> rest = [String]
18:34:56 <Eduard_Munteanu> Darkone: that function would be String -> String
18:35:00 <Darkone> parsedlist = [[String]]
18:35:15 <Eduard_Munteanu> Darkone: um, sorry, [String] -> [String]
18:35:18 <Darkone> rest is a list of Strings
18:35:28 <enthropy> @type let updateAt (i,f) ls = take i ls ++ (case drop i ls of x:xs -> f x:xs); list $$ ixs = foldr updateAt list ixs in ($$)
18:35:29 <lambdabot> forall a. [a] -> [(Int, a -> a)] -> [a]
18:35:37 <Darkone> split :: String -> [String]
18:36:03 <enthropy> @let ($$$) = let updateAt (i,f) ls = take i ls ++ (case drop i ls of x:xs -> f x:xs); list $$ ixs = foldr updateAt list ixs in ($$)
18:36:03 <lambdabot>  Defined.
18:36:05 <Eduard_Munteanu> enthropy: yeah, but that's a lot easier to misuse performance-wise
18:36:06 <Darkone> So mapping split to rest produces [[String]]
18:36:23 <Darkone> I want to extract each [String] and make an Array
18:36:25 <Darkone> Correct?
18:36:56 <enthropy> > [3,2,1] $$$ [(1,(*2)),(0,const 0)]
18:36:57 <lambdabot>   [0,4,1]
18:37:08 <enthropy> Eduard_Munteanu: hence the $$$
18:37:09 <Eduard_Munteanu> Darkone: technically you want to make an array from each [String], process the array, then take it back into a [String]
18:37:17 <Darkone> Right
18:37:18 <Eduard_Munteanu> Heh.
18:37:30 <Darkone> I'm being lazy, and keeping it simple and easy to read
18:37:40 <Darkone> So, I turn the whole damn thing into a list of Arrays
18:37:46 <Eduard_Munteanu> Darkone: the conversion from array to list is easy, just use 'elems'
18:37:48 <Eduard_Munteanu> :t elems
18:37:49 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
18:37:50 <enthropy> the implementation could be done better by first sorting the update functions, and doing one pass
18:38:00 <Darkone> Then go through and operate on each array
18:38:23 <Darkone> Then turn all arrays into lists, unsplit lists, unlines that, and boom, ready to write
18:39:05 <Eduard_Munteanu> Darkone: yes. Remember, that function will operate on every row.
18:39:16 <Eduard_Munteanu> (which is represented as a list of Strings)
18:39:19 <Darkone> processedlist = map preprocess arrayedlist
18:39:25 <Darkone> Err
18:39:37 <Darkone> Yea, that's right.
18:39:45 <Darkone> arrayedlist = [Array] 
18:39:56 <Darkone> So preprocess :: Array -> Array
18:40:33 <Eduard_Munteanu> Darkone: I wouldn't
18:40:50 <Eduard_Munteanu> Darkone: just combine process with preprocess into a single function :: [String] -> [String].
18:41:06 <Darkone> Not about speed, or cleanliness, it's now about making it readable to a noob, and freaking working :(
18:41:16 <Darkone> KISS
18:41:28 <Eduard_Munteanu> Oh, okay, just making sure.
18:41:51 <gwern> Eduard_Munteanu: why, that almost looks like 'interact' :)
18:42:07 * enthropy wonders about that spreadsheet trick with fix
18:42:13 <Darkone> Type of the array produced by listArray = IArray, right?
18:42:27 <Darkone> Or is it Array?
18:42:58 <Eduard_Munteanu> Darkone: Array
18:43:10 <Eduard_Munteanu> Darkone: IArray is a typeclass for immutable arrays.
18:43:36 <Eduard_Munteanu> Which covers array.
18:43:55 <Eduard_Munteanu> (don't be mislead by "immutable", it means it doesn't do truly in-place updates)
18:44:25 <enthropy> Eduard_Munteanu: what language does infix functions like      argument1 (**) argument2?
18:45:08 <Axman6> @hoogle (=>)
18:45:08 <lambdabot> Test.QuickCheck (==>) :: Testable a => Bool -> a -> Property
18:45:08 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:45:22 <Eduard_Munteanu> enthropy: yeah, that was a mistake earlier, it should've been //, not (//)
18:45:33 <Eduard_Munteanu> for updating the array.
18:45:58 <Eduard_Munteanu> Or did I misunderstand your question?
18:46:23 <enthropy> the question is whether that's from confusing haskell with something less pretty
18:47:29 <Eduard_Munteanu> Nah, it's lack of sleep, I don't use a language that fits that description :)
18:48:03 <Eduard_Munteanu> What would that be?
18:48:39 <enthropy> @let ($$$$) = let updateAt self (i,f) ls = take i ls ++ (case drop i ls of x:xs -> f self x:xs); list $$ ixs = fix (\self -> foldr (updateAt self) list ixs) in ($$)
18:48:40 <lambdabot>  Defined.
18:48:45 <enthropy> @type ($$$$)
18:48:46 <lambdabot> forall a. [a] -> [(Int, [a] -> a -> a)] -> [a]
18:49:45 <ccasin> enthropy: what function is that?
18:50:08 <Eduard_Munteanu> Some sort of CPS update?
18:51:11 <enthropy> > [1,5,20,33] $$$$ [(0, \ls _ -> ls !! 3), (2, \ls a -> a + ls !! 2), (3, \ls _ -> ls !! 2)]
18:51:14 <lambdabot>   mueval-core: Time limit exceeded
18:51:18 <enthropy> :(
18:51:40 <enthropy> > [1,5,20,33] $$$$ [(0, \ls _ -> ls !! 3), (2, \ls a -> a + ls !! 1), (3, \ls _ -> ls !! 2)]
18:51:40 <ccasin> oh, that function
18:51:41 <lambdabot>   [25,5,25,25]
18:51:42 <ccasin> :)
18:51:45 <Eduard_Munteanu> Ah, nice.
18:53:02 <enthropy> Darkone: that is sort of what you're looking for? (though one pass instead of as many as necessary might be better)
18:53:38 <enthropy> the definition of pass being quite loose
18:54:09 <Eduard_Munteanu> A list zipper comonad could've done that if you can manage the indexes.
18:55:40 <sshc> How does FFI's behaviour change when "safe" or "unsafe" is used?
18:55:55 <enthropy> sshc: when your C calls back to haskell
18:56:08 <enthropy> which is more likely an 'if'
18:58:42 <enthropy> Eduard_Munteanu: how's a zipper to be involved?
18:59:17 <Darkone> Back
18:59:25 <Darkone> Just going to sluff it with array
18:59:50 <enthropy> Darkone: you saw $$$$ ?
19:00:09 <Darkone> Yea, and didn't understand it at all.
19:01:17 <enthropy> well from the type: [a] -> [(Int, [a] -> a -> a)] -> [a],  you give a list of updates for some Int indexes, which you provide a function that gets the resulting list and the current value
19:01:20 <sshc> enthropy: I asked "how", not "when".
19:01:43 <enthropy> sshc: the keyword isn't clear enough?
19:02:20 <Darkone> with where bindings
19:02:28 * enthropy doesn't know the details of how it crashes / ends up in an inconsistent state
19:02:30 <Darkone> Can you use the where bindings in themselves?
19:03:13 <Darkone> Like, where fixarray array = array // [(7,fixedspeed)] -newline and tabs to line up- fixedspeed = ...
19:03:28 <enthropy> > let a = 1 + b where b = 2 + c where c = 3 in a
19:03:29 <lambdabot>   6
19:03:47 <enthropy> > let a = 1 + b + c where b = 2 + c where c = 3 in a
19:03:48 <lambdabot>   1 + (2 + 3) + c
19:04:04 <Darkone> Like...
19:04:22 <Eduard_Munteanu> enthropy: did you see sigfpe's cellular automata made with comonadic zippers?
19:04:24 <enthropy> Darkone: those are nested wheres ^^
19:04:46 <Saizan> Darkone: yes, you can
19:04:50 <Eduard_Munteanu> enthropy: basically it makes updating really easy and gives context at the same time.
19:04:55 <Darkone> | guard = ...     | otherwise = ...   where a b = c b    c b = ...
19:05:35 <Saizan> Darkone: definitions in a where clause are allowed to be mutually recursive, like in let and toplevel definitions
19:05:41 <Eduard_Munteanu> He uses a zipper like [a] a [a].
19:06:28 <Eduard_Munteanu> So if you cobind a function :: w a -> a for some concrete w and a, you can update the middle element depending on what's left and right.
19:06:42 <Eduard_Munteanu> *cobind to
19:08:29 <Eduard_Munteanu> Of course, some other context might be appropriate in this case.
19:08:48 <Darkone> http://pastebin.com/ty8pNLhZ
19:08:54 <Darkone> Is this correct?
19:09:10 <Darkone> Assuming I add definitions for fixedaccel, etc.
19:09:48 <Eduard_Munteanu> like [a] a i [a], where the first is the special element, i the index and [a]s left and right.
19:12:35 <Eduard_Munteanu> Darkone: looks okay.
19:12:41 <Darkone> Wait, let me change this
19:13:17 <Eduard_Munteanu> Darkone: although you might want to name it something else than 'array', there's another function by that name.
19:13:27 <Eduard_Munteanu> :t array
19:13:28 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
19:14:06 <Eduard_Munteanu> Darkone: um, passedarray seems undefined.
19:14:21 <lars9> why haskell likes the style of fromXXX (fromIntegral, fromList), but not toXXX like in other langs?
19:14:22 <Eduard_Munteanu> Err, scratch that
19:14:25 <Eduard_Munteanu> It is :)
19:14:27 <lars9> toString
19:14:33 <lars9> toInt
19:15:17 <enthropy> @hoogle toEnum
19:15:18 <lambdabot> Prelude toEnum :: Enum a => Int -> a
19:15:29 <sshc> enthropy: "unsafe" and "safe" doesn't really tell me what exactly the differences in behaivour are
19:16:11 <Darkone> Eduard_Munteanu, http://pastebin.com/W5ZXiwct
19:16:15 <Darkone> Prettier, right? :)
19:16:15 <sshc> Should I use unsafePerformIO with newForeignPointer?
19:16:57 <Darkone> Hahaha
19:17:00 <Darkone> D'oh
19:17:04 <enthropy> @hoogle toList
19:17:04 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
19:17:04 <lambdabot> Data.HashTable toList :: HashTable key val -> IO [(key, val)]
19:17:04 <lambdabot> Data.IntMap toList :: IntMap a -> [(Key, a)]
19:17:10 <Darkone> Didn't even need a fixedengine function!
19:17:12 <Darkone> http://pastebin.com/GWEDQ4BL
19:17:18 <Eduard_Munteanu> Darkone: looks okay.
19:17:20 <Darkone> This should be complete 
19:17:28 <Eduard_Munteanu> Darkone: write the rest and test it.
19:17:32 <lars9> enthropy: that helps, thanks
19:17:37 <Darkone> Wait, I defined tunings twice :V
19:17:44 <lars9> @hoogle toInt
19:17:44 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
19:17:44 <lambdabot> Data.Char digitToInt :: Char -> Int
19:17:45 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
19:17:57 <Eduard_Munteanu> Darkone: yeah, but the array is used correctly it seems.
19:18:02 <lars9> can I use hoogle in command line?
19:18:14 <Saizan> yep
19:18:41 <Saizan> cabal install hoogle
19:18:44 <Eduard_Munteanu> @where hoogle
19:18:44 <lambdabot> http://haskell.org/hoogle
19:18:48 <Eduard_Munteanu> Or online.
19:19:04 <lars9> yaourt installing...
19:19:13 <revenantphx> I have a small statistics type question (regardless of language). Say you have some trail discretized into nodes. There is an ant at some node n. n+1 and n-1 each have varying amounts of pheromone A and B. Let's say A is twice as attractive as B. Logically you'd weight them (2*A + B) and then calculate the percentage of it moving to one of them as weight_a/(weight_a+weight_b). 
19:19:19 <Eduard_Munteanu> You can actually use lambdabot if you install it with cabal install
19:19:29 <revenantphx> However, what about when the amount of pheromones are both 0.
19:19:38 <revenantphx> How is that case handled mathematically
19:19:47 <revenantphx> Since the ant would still be equally compelled to go either way
19:20:00 <Darkone> Special case
19:20:11 <revenantphx> thought so.
19:20:16 <Darkone> You don't want  to try and div by 0, so just code a case
19:20:22 <revenantphx> well, of course.
19:20:24 <Darkone> Maybe multiple cases
19:20:59 <Darkone> Nevermind, your weight function should be fine
19:21:05 <lars9> oh lambda is also in yaourt. is cabal prefered when package is available on AUR?
19:21:14 <revenantphx> Darkone: not if they're both zero D:
19:21:19 <Darkone> As long as one value is not zero
19:21:24 <Darkone> Yea
19:21:33 <revenantphx> If one value is zero it's fine...
19:21:37 <Darkone> I was thinking you would need multiple cases, but you only need one to catch 0,0
19:21:44 <revenantphx> mm
19:22:51 <Darkone> Of course
19:22:53 <Darkone> AI Wise
19:23:03 <Darkone> Your ant will ALWAYS follow the pheremone
19:23:08 <Darkone> Which may or may not be good.
19:23:13 <Darkone> Depending on how you use it.
19:23:14 <revenantphx> That's the point.
19:23:22 <Darkone> The strongest pheremone*
19:23:26 <Darkone> Just a warning :P
19:23:29 <revenantphx> thats the point
19:23:40 <revenantphx> the weaker pheromone decays slower though.
19:23:55 <revenantphx> the stronger one is layed during the exploitation of a food source.
19:24:03 <revenantphx> So when the food source dissipates it needs to also dissipate quickly.
19:26:18 * Eduard_Munteanu has to leave.
19:26:22 <Eduard_Munteanu> Good night everyone.
19:28:00 <revenantphx> Darkone: Ant AI models are fun.
19:28:49 <revenantphx> One other question. That works nicely in the event of a dichotomous node.
19:28:54 <revenantphx> But what about a trichotomous node?
19:29:08 <cads> hey, I'm writing a bit of a haskell tutorial/tutoring help for someone I'm helping
19:29:12 <revenantphx> (0,0,0) is still a special case.
19:29:40 <enthropy> yet another tutorial?
19:30:06 <cads> well
19:30:10 <cads> not quite
19:30:45 <cads> this person doesn't really know how to "read" haskell into english sentences that break it down into the "parts of haskell speech", as it were
19:30:55 <cads> so I'm trying to teach that
19:31:15 <enthropy> have they looked at Haskell's grammar?
19:31:27 <cads> not at a formal level
19:32:04 <enthropy> teach it by teaching TH
19:32:30 * enthropy thinks that one hasn't been done yet
19:32:36 <cads> TH?
19:32:43 <enthropy> template haskell
19:33:02 <cads> well
19:33:18 <cads> lemme give you a small idea of where I'm starting with
19:33:28 <cads> I asked them to describe this expression:  filter (\x -> x^2 < 1000) [1..]
19:34:02 <revenantphx> I think the fibonacci sequence was very educational for me...
19:34:08 <cads> explain the parts of the "sentence" in a way that gives me an idea of what is going
19:34:11 <enthropy> did you get _|_ ?
19:34:36 <cads> that part is part of a trick question
19:36:04 <cads> I got
19:36:10 <cads> "ok x is a variable, and we want that x to be ^2 but only if the x is less than 1000
19:36:10 <cads> and we will start at 1 and we will print the numbers in a list??????????????"
19:38:27 <cads> I wanted:  This expression has a function, filter, of type ..., which receives a lambda expression and the list [1..], and uses the lambda to select the elements of the list  whose squares are less than 1000.
19:39:03 <cads> However, that's not what I wanted - that doesn't account for the fact that the value it returns is bottom
19:40:54 <cads> how would I correct the last part of the sentence to reflect that it passes all the elements below 32, but cannot terminate if it reaches that point?
19:41:18 <cads> I think I can't quite do it without complicating things too greatly
19:46:36 <pumpkin> does anyone have any interesting/useful examples of mfix usage?
19:49:53 <enthropy> cads: so the interpretation needs to be more 'operational'
19:50:02 <gwern> > 43000 * 30
19:50:03 <lambdabot>   1290000
19:58:12 <pumpkin> mm
19:59:39 <Darkone> Thanks, Eduard_Munteanu, in case you're still here
19:59:47 <Darkone> The array made it so much simpler.
20:00:45 <monochrom> http://www.haskell.org/haskellwiki/MonadFix  has mfix examples
20:02:47 <Darkone> In a haskell script, how much is already imported?
20:02:56 <cads> enthropy, sure, that'd be it
20:02:57 <Darkone> Like is the equiv to GHCI prelude already there?
20:02:58 <monochrom> the Prelude
20:03:03 <Darkone> Yay, thanks.
20:03:48 <enthropy> cads: so ask the question that way, so the person knows they aren't answering correctly
20:04:29 <enthropy> you can go through evaluation step-wise
20:04:59 * enthropy can't remember where a web applet that did so exists
20:05:23 <Saizan> @where stepeval
20:05:23 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
20:09:48 <Darkone> error log incoming :(
20:11:24 <Darkone> http://pastebin.com/M9J4vLmL
20:11:32 <Darkone> Can someone tell me what the error is talking about
20:12:20 <enthropy> Darkone: add a type signature for mkarray
20:13:18 <Darkone> Aha
20:13:28 <Darkone> Needed to write the type as "Array Int String" :X
20:14:05 <enthropy> well the String part could be left polymorphic
20:14:18 <Darkone> Woops!
20:14:29 <Darkone> Forgot to append the start before writing :P
20:17:27 <cads> hey, enthropy, https://docs.google.com/document/edit?id=1hSauHWVAJwETfXHcvsrdcXGAlm01MGP7gys-gYktByo&hl=en&authkey=CPzWvJIL
20:17:45 <Darkone> Okay
20:17:52 <Veinor> Darkone: you shouldn't have so many lines in that let-binding
20:18:16 <Darkone> I know, just trying to keep it readable so my noob mind can comprehend it
20:18:35 <Darkone> Also, how do I convert/force some math to evaluate as an integer?
20:18:44 <cads> enthropy, perhaps I explain first - this is a minitutorial I started writing motivated by the explanation I received from this kid
20:20:32 <enthropy> "the filter uses the the lambda to filter the list"
20:20:39 <enthropy> redundancy?
20:21:21 <enthropy> Darkone: what kind of math?
20:21:26 <cads> yeah, that means to show that  the (function) uses the lambda to (verb) the list, but there's ambiguity
20:21:53 <cads> I could say the filter uses the lambda to sift through the list or something  :)
20:22:25 <enthropy> Darkone: you might be interested to know that  /   for integer-like numbers is called   div
20:23:12 <cads> enthropy,  btw I appreciate the criticism, thanks
20:23:23 <Darkone> ...oh god WHAT
20:23:45 <cads> @type (/)
20:23:46 <lambdabot> forall a. (Fractional a) => a -> a -> a
20:23:51 <cads> @type div
20:23:52 <lambdabot> forall a. (Integral a) => a -> a -> a
20:23:57 <enthropy> cads: clarify this 'sift' to be "walks through the list, removing elements that the lambda returns false for"
20:24:24 <enthropy> teaching is hard, and it's much easier to point out mistakes than to do better :(
20:24:34 <Darkone> :PSYDUCK:
20:24:55 <Darkone> X3 editor lists 557 as the nova PAR- oh nvm
20:25:00 <cads> PSY-YAI-YAI
20:25:01 <Darkone> ship 557, not line 557!
20:25:10 * cads puts his hands to his face and shakes his head in distress
20:25:44 <enthropy> cads: why not list comprehensions?
20:26:43 <Darkone> I feel so silly for making that mistake
20:27:20 <cads> enthropy, part way through I realized I wanted to talk about inventing idiomatic language to make it easier to understand what higher order functions do
20:27:40 <Darkone> enthropy, basically, I want to force some floats into integers
20:27:44 <cads> I want to see if she can work the map example using the same style for the filter example
20:27:56 <enthropy> maybe this 'talking about programs in english' is misguided
20:28:04 <Darkone> I have a general function for normalizing
20:28:04 <cads> enthropy, that's why I gave technically a simpler program
20:28:07 <Darkone> It returns a float.
20:28:26 <Darkone> For a few things, I want that to be an Int. 
20:28:26 <enthropy> @quote mono.*analogy
20:28:26 <lambdabot> No quotes match. Maybe you made a typo?
20:28:28 <Darkone> What do?
20:28:40 <enthropy> @quote analogy
20:28:40 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
20:29:01 <Darkone> Make a new function that's built from groundup for this?
20:29:02 <enthropy> Darkone: what type is this 'normalizing'?
20:29:24 <cads> enthropy, I do a much less verbal version of it when I analyze an expression or statement, but my student doesn't do it at all
20:29:41 <Darkone> normalize num mid factor = num + (mid - num) / factor
20:29:43 <Darkone> Wait
20:29:55 <lars9> how to memo "f -> Integer -> [Integer] -> Double" using MemoTrie? "memo f" seems not working...
20:29:55 <Darkone> Can I do like, Floor Float to get an int?
20:30:19 <enthropy> lars9: uncurry f?
20:30:36 <lars9> :i uncurry f
20:30:37 <cads> enthropy, I shouldn't say that, I should say her analysis is muddled - and the only way I can get a clue of what her internal analysis happens to be is if she can explain it to me in english
20:30:47 <Veinor> lars9: memo2 f
20:31:01 <lars9> Veinor enthropy thanks
20:31:17 <cads> enthropy, she knows enough haskell, but she's failing the course since she can't get comfortable reasoning about it
20:31:58 <cads> she can't even go to the professor and explain what she doesn't understand because she doesn't talk in terms of the components of the language in explaining a problem
20:32:11 <lars9> how to make "data Card = Card Char Integer" an instance of HasTrie ?
20:32:57 <Axman6> Darkone: floor
20:33:00 <Axman6> :t floor
20:33:00 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:33:11 <cads> enthropy, it's "what am I doing wrong?", which makes my life very hard as a tutor, instead of "how am I getting the syntax of the guards in this list comprehension wrong?!", which I can work with
20:33:15 <Axman6> > floor (2.5 :: Float) :: Int
20:33:16 <lambdabot>   2
20:33:22 <Darkone> Uh oh
20:33:28 <Darkone> fixedspeed = floor $ originalspeed * ( 1 + (tunings - 15) * 0.1)
20:33:39 <Darkone> Ambiguous type variable `a' in the constraints:
20:33:44 <enthropy> cads: what does the course cover?
20:33:48 <Darkone>   `Integral a' arising from a use of `floor' at new  2.hs:49:15-19
20:34:14 <cads> http://cs.calstatela.edu/wiki/index.php/Courses/CS_332F/Fall_2010
20:34:47 <Darkone> Axman6
20:34:48 <Darkone> http://pastebin.com/8heYGqNZ
20:35:14 <Darkone> Error at bottom
20:35:27 <cads> enthropy,  the professor is apparently a jackass - he lectures from the wiki in class, he doesn't have office hours, he doesn't write code in class, only executes functions. He expects all the students to post any questions to him publicly on the wiki.
20:35:32 <lars9> could anyone show me how to make "data Card = Card Char Integer" an instance of HasTrie? I dont quite understand source code of MemoTrie..
20:36:36 <cads> enthropy, how can this girl post questions when she doesn't have the language to explain exactly what she doesn't understand - these kinds of professors tear students apart when questions aren't asked eloquently.
20:36:48 <Darkone> Halp :(
20:37:34 <cads> Darkone, post a three line code fragment that you want to learn how to fix, not a big listing, neh? You'll get halp.
20:37:59 <Darkone> Getting ambiguous type variable error when trying to compile. Oh, just posted it all because people complain if I post 3 line fragments :V
20:38:31 <cads> between you and me I _still_ fuck up when I have to deal with the numerical type classes
20:38:57 <Darkone> http://pastebin.com/p2Lk2jXJ  shortened
20:39:06 <Darkone> Error is at bottom. I jsut don't understand it at all.
20:39:25 <Darkone> Both are floats
20:39:33 <Darkone> So both should be floorable
20:40:20 <Saizan> ?type floor
20:40:21 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:41:16 <Saizan> Darkone: fixedspeed has to be an Integral because it's the result of a floor, but you're using it in an expression involving (/) in the definition of fixedaccel
20:41:19 <cads> Darkone, download this pdf. Print it out, tape it somewhere you will see, or put it in the front of your haskell notes book. http://bucephalus.org/text/Haskell98numbers/Haskell98numbers.html
20:41:30 <Darkone> Saizan, oh!
20:42:19 <Darkone> Hahaha typos
20:42:27 <Darkone> "Not in scope: 'floot'
20:43:50 <cads> Darkone,   haha, chopping up your original code listing so that it no longer valid code is not exactly what I meant :)
20:44:16 <cads> I meant construct a short example that produces the same kind of error :)
20:44:47 <Saizan> i don't mind large listings, as long as i have a line number :)
20:45:00 <cads> Saizan, you code professionally, right?
20:45:15 <Saizan> cads: no
20:45:40 <cads> hmm..
20:45:59 <Saizan> but i read code in a lazy style
20:46:02 <cads> I need to get better with bigger code listing
20:46:06 <cads> listings*
20:46:44 <enthropy> cads: I dunno, this is a pretty inadequate hand-wavy explanation of defaulting and related issues http://cs.calstatela.edu/wiki/index.php/Courses/CS_332F/Fall_2010/Week_3._Oct_7
20:47:06 <Saizan> Darkone: on a more general note, all these show/read seem quite weird, why aren't you keeping numbers directly in your array?
20:47:28 <cads> I prefer compact 'academic' style examples, since that lets us see mathy stuff better, but that's a weakness :P
20:48:36 <monochrom> I read code lazily too.
20:49:43 <Veinor> I think a lotof people do
20:49:46 <cads> I read code _very_ lazily :P
20:49:48 * ddarius pokes all the pumpkins.
20:49:58 <pumpkin> ddarius: allo!
20:50:12 <Veinor> pumpkin: I wanted to hear you evangelize at me :(
20:50:15 <Saizan> cads: large listings are still a problem for me if the questions are "why this doesn't work?" "can i do this more elegantly?" or similar, because then i really have to understand the whole code and potentially a lot of details that don't contribute to the real problem
20:50:19 <enthropy> if there's no explanation of what's going on (motivations for why there are such odd rules, or that such things exist), you expect people to do the same for values?
20:50:21 <pumpkin> Veinor: I'm sowwy :(
20:50:25 <Veinor> what happened? :P
20:50:32 <pumpkin> I'm still in florida :P
20:50:37 <ddarius> pumpkin: I noticed.
20:50:37 <Veinor> bah!
20:50:45 <Veinor> details!
20:50:47 <ddarius> pumpkin: When do you get up here about?
20:50:59 <pumpkin> probably next weekend at this rate
20:51:09 <cads> enthropy, this whole professor is handwavy
20:51:12 <pumpkin> Veinor: had some stuff to do here before moving up :P
20:51:40 <cads> enthropy,  he writes papers on abstraction's purpose and role in emergent phenomena :P
20:51:53 <Veinor> oh, you're actually moving?
20:52:17 * enthropy acknowledges you need to handwave, but if it's text you can at least refer to "this is what's actually going on"
20:52:29 <ddarius> Veinor: He's going to see how long he can keep us believing it.
20:52:35 <Veinor> haha
20:52:46 <cads> enthropy, he gave a midterm, the scores were 100, 90, 68, 65, 50, 48, 45, 45, 40, 40, 38, 38, 35, 33, 30, 30, 30, 20, 20, 20, 20, 18, 17, 10, 10, 10, 0, 0, -30.
20:53:01 <enthropy> that doesn't mean much
20:53:08 <djahandarie> ddarius, okay, I was wrong about djinn supporting Mu. I think it may have at one point (there is an examples file that shows it finding  null ? List a -> Bool)
20:53:23 <fengshaun> cads, only 5 people passed?
20:53:54 <cads> enthropy, if it was a graduate level class or something I'd say it's okay for only 5 people to pass
20:54:06 <ddarius> djahandarie: Djinn can (appear to) go a bit beyond what it allegedly supports with some cleverness.
20:54:39 <ddarius> E.g. it has a Monad class definition, but it can't actually handle it, so derivations using Monad are spotty.
20:55:12 <sciolizer> Has anybody made a Haskell wrapper for termios?
20:55:40 <djahandarie> And whoops, I meant to ask edwardk something but forgot about it
20:55:53 <djahandarie> ... guess I'll have to wait for him to show up here
20:56:00 <djahandarie> Hopefully it isn't another couple months
20:56:34 <ddarius> I doubt he'll get on tonight.  He seems like he might be getting sick enough to rest.
20:56:47 <djahandarie> Yeah he didn't sound too good
20:57:12 <lars9> :src curry
20:57:29 <lars9> oops, how to show source?
20:57:39 <djahandarie> @src curry
20:57:39 <lambdabot> curry f x y = f (x, y)
20:57:39 <lars9> @:src curry
20:57:39 <lambdabot> curry f x y = f (x, y)
20:57:40 <djahandarie> But it lies
20:57:42 <quantumboy> How can I sove simultanneous equations use haskell programing? not only the linear equations. thanks.
20:58:06 <tg_> i sense... a trap
20:58:36 <djahandarie> quantumboy, there are linear algebra libraries. Beyond that, I'm not sure
20:58:41 <djahandarie> What else are you trying to solve?
20:59:04 <enthropy> quantumboy: http://hackage.haskell.org/packages/archive/hmatrix/0.10.0.0/doc/html/Numeric-GSL-Root.html
20:59:34 <djahandarie> (All of hmatrix would be useful probably, not just that module)
21:00:43 <enthropy> well for nonlinear equations
21:02:16 <quantumboy> thank you djahandarie, I want calculate a group 3d curvs join pairwiss smoothly , only segment and arc ,they  are control by some equations constrains
21:04:04 <djahandarie> Normally you either convert your nonlinear system into a linear approximation, or solve nonlinear diff eqs
21:05:16 <enthropy> where is the diff eq djahandarie?
21:05:35 <djahandarie> I didn't understand what he said, I was just talking in general
21:06:07 <lars9> quicksilver: hi
21:06:57 <djahandarie> Most nonlinear algebra problems can be solved
21:07:40 <quantumboy> ok, my equations  all are the algebra equations with tri function, can I code hasekell to sove it ,do not use the hmatrix lib?
21:07:44 <ddarius> By "can" did you mean "can't"?
21:08:14 <djahandarie> I thought they were usually okay?
21:08:39 <djahandarie> (Not including nonlinear diff eqs here)
21:09:46 <quantumboy> yes I dont want use the libarary , want only use the haskell code to solve it to learn the language
21:10:14 <djahandarie> quantumboy, that might be a complicated first task
21:10:23 * djahandarie would recommend to start with something simpler...
21:11:33 <quantumboy> Ennnn, for me is a hard work
21:12:07 <djahandarie> But the answer to your question is yes
21:12:28 <quantumboy> ok, thank you very much
21:12:31 <djahandarie> Gaussian elimination should work purely functionally just fine
21:15:17 <quantumboy> Because I'm design a mathematical model , I want use the haskell to design the caluclate module , the project main use c++
21:16:28 <djahandarie> I'd recommend doing it the other way around :) Or just all Haskell
21:55:27 <Axman6> > (20*(x+1))*(20*(x+1)
21:55:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:55:33 <Axman6> > 20*(x+1))*(20*(x+1)
21:55:34 <lambdabot>   <no location info>: parse error on input `)'
21:55:39 <Axman6> > (20*(x+1))*(20*(x+1))
21:55:40 <lambdabot>   20 * (x + 1) * (20 * (x + 1))
22:15:51 <co_dh> @seen copumpkin
22:15:51 <lambdabot> Unknown command, try @list
22:15:51 <preflex>  copumpkin was last seen on #haskell-blah 5 days, 12 hours, 7 minutes and 19 seconds ago, saying: duh
22:16:11 <pumpkin> hi co_dh 
22:16:34 <co_dh> hi, pumpkin :)
22:16:35 <lambdabot> co_dh: You have 1 new message. '/msg lambdabot @messages' to read it.
22:18:15 <co_dh> for string replace , what funciton you guys use ? I tried ByteString, but can't find a good replace function. 
22:18:43 <co_dh> I have only limit access to Hackage,  which mean's I cannot use cabal install during working . 
22:19:06 <co_dh> so I have to limit my self to what's inside Haskell platform, or debian's haskell release.
22:19:12 <pumpkin> is it text data or binary data?
22:19:16 <pumpkin> cause you should be using Text if so
22:19:20 <pumpkin> and I think that has a good string replace
22:19:54 <co_dh> text data. 
22:20:12 <pumpkin> so use Data.Text
22:21:09 <co_dh> Text depends on deepseq, I have problem to install that.
22:21:44 <pumpkin> why?
22:21:57 <co_dh> version conflict . 
22:22:05 <pumpkin> huh
22:22:19 <pumpkin> fix it, don't just avoid anything that depends on it :P
22:22:23 <co_dh> I'm running cabal from a proxy , and the proxy need authentication. 
22:22:56 <co_dh> cabal cann't handle the password things, so basically I don't have cabal, 
22:23:23 <pumpkin> just download the package tarballs yourself?
22:23:33 <co_dh> I've tried download the source myself , and cabal install it locally , but , the package dependency stopped me. 
22:23:57 <co_dh> and all I need is just a replace function :(
22:24:10 <pumpkin> well, for human text you should be using Text anyway :P
22:24:10 <co_dh> so.... I write one myself. 
22:24:50 <co_dh> I think Haskell should use the way python package itself. 
22:25:08 <co_dh> have a fixed version number, and have everything included and fixed. 
23:57:37 <mjo`> Help: I need 'cp -r', but putting the word "recursive" into a Google search for Haskell is a recipe for disappointment.
