00:01:37 <sm> hey all.. what function applies another function to a value N times ? ie recurse to depth N
00:02:53 <Heffalump> foldr1 (.) (replicate 10 f)
00:03:15 <sm> thanks Heffalump 
00:03:17 <Saizan> mjo`: you should use hayoo, http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:copy%20directory%20recursive
00:03:55 <Saizan> ?type foldl1
00:03:56 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
00:05:00 <mjo`> Thanks. Attempting to make those results work =)
00:06:06 <kmc> :t iterate
00:06:06 <lambdabot> forall a. (a -> a) -> a -> [a]
00:06:15 <sm> hmm
00:06:17 <kmc> :t \f n x -> iterate f x !! n
00:06:18 <lambdabot> forall a. (a -> a) -> Int -> a -> a
00:06:30 <kmc> (a -> a) -> Int -> (a -> a)
00:06:37 <Saizan> mjo`: there's another in Distribution.Simple.Utils, though you probably want to steal the code rather than depend on Cabal for something like this
00:07:23 <Saizan> "iterate f x !! n" is not a great idea if f is strict and n is potentially large
00:07:57 <Saizan> i'd use "foldl' (flip ($)) x (replicate n f)" in that case
00:08:18 <Saizan> ?type \f n x -> foldl' (flip ($)) x (replicate n f)
00:08:19 <lambdabot> forall b. (b -> b) -> Int -> b -> b
00:12:42 <mjo`> Ah, I see. I'll probably steal the Cabal version, then. It looks a lot uglier, but is probably correct.
00:15:32 * hackagebot buildbox 1.2.0.0 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-1.2.0.0 (BenLippmeier)
00:16:32 * hackagebot buildbox-tools 1.2.0.0 - Tools for working with buildbox benchmark result files.  http://hackage.haskell.org/package/buildbox-tools-1.2.0.0 (BenLippmeier)
01:51:10 <merijn> I've seen some people claim that an untyped language can be trivially implemented by creating a universal type in a typed language. But isn't this claim wrong? I'd say a typed lambda calculus with a universal type is still strongly terminating, while the untyped lambda calculus is not...
01:54:05 <dagle> merijn: I think that statement is really big and needs to explain what it means.
01:55:19 <dagle> Sure I can define a function f :: a -> b -> c and that wont give me much more security then an untyped language in some regards.
01:56:26 <merijn> dagle: My interest is more in the fact that I expect it is technically wrong (i.e. not all programs possible in an untyped language can be expressed in a typed language), but I'm not sure I'm right about that
01:56:33 <dagle> I have also seens some strongly typed things were strongly type is just String -> String.
01:57:22 <merijn> Oh actually, I guess they could be possible in a typed language, but not one whose type system is consistent
01:58:07 <bd_> merijn: it's fairly simple to create a UTM in a typed language, so I'm not sure what you mean by technically wrong
02:02:20 <merijn> bd_: Untyped lambda calculus is not strongly terminating, the simply typed lambda calculus is. Hence the simply typed one is less expressive and not everything written in the former can be written in the latter. But I just realized that is because the type system of STLC is consistent. So if I understand everything correctly (which I'm not sure I do), then you could have a typed language as expressive as untyped, but not while having a
02:02:20 <merijn> consistent type system. Which I guess means this is all an encounter with Gödel's theorem
02:05:39 <Saizan> right, or turing-completeness, which is not much different
02:07:48 <Saizan> merijn: if your untyped language wasn't turing-complete you wouldn't need this, off course
02:09:01 <merijn> Saizan: Of course. I'm just pleased that the bits are sorta falling into place in my head after being stuck for a week :>
02:12:17 <Saizan> merijn: nice :)
02:17:59 <Watermind> why do I get overlapping instances here?
02:18:01 <Watermind> http://hpaste.org/40983/overlapping
02:18:37 <Watermind> there is only one way to make Int -> Int -> Int an instance of F1
02:18:57 <Watermind> since Int -> Int  is not an instance of F0
02:20:15 <Saizan> the instance context is not taken into account when deciding which instance to pick
02:20:45 <Lemmih> Watermind: Do you see how 'a -> b' and 'a -> (b -> c)' are similar?
02:21:04 <Saizan> it seems counterintuitive to many, but it's for the sake of consitency in the presence of separate compilation
02:22:02 <Saizan> so the first matches with a = Int; b = Int -> Int; while the second with a = b = c = Int
02:38:58 <Watermind> Lemmih: sorry got distracted coding
02:39:48 <Watermind> Lemmih: yes I understand that,   b could be  of the form  b'->c
02:40:37 <Watermind> but when applying to a specific type there's not necessarily any overlapping
02:41:02 <Watermind> and in that case if the type is    Int -> Int -> Int  only the second instance works
02:41:29 <Watermind> Int -> Int   is not an instance of F0 
02:42:25 <Watermind> so there is only  one possible way for Int->Int -> Int to be an instance of F1 
02:47:13 <Saizan> yeah, that would make sense if the context would matter any
02:47:44 <Saizan> but it's only added as additional constraints _after_ the decision on which instance to pick is made
02:49:20 <Watermind> Saizan: I see
02:50:11 <Saizan> now, if you allow OverlappingInstances then the most specific match is chosen
02:50:14 <benmachine> Saizan: I don't think it's just about separate compilation, it's also relevant whether or not adding instances in your code affects the behaviour of seemingly unrelated code
02:50:36 <Saizan> it still won't consider the contexts though
02:52:14 <Watermind> so if I understand correctly any attempt to use the 2nd instance will result in "overlaping instances"
02:52:20 <phil> I'm really new to haskell and I'm supposed to implement a binary tree.       When you define a data type, is there a way to specify some constraints?  (in this case: value in the left child has to be smaller than in the right one)
02:52:42 <phil> Looked at a couple of tutorials and I didn't see anything like that
02:52:43 <Saizan> benmachine: well, a unique global registry of instances would at least be feasible with whole-program, it'd be consistent even if not local
02:52:46 <Watermind> therefore shouldn't the error occur when when the 2nd instance is implemented?
02:53:21 <Watermind> phil: not those kind of constraints, you just have to enforce that  youself
02:55:41 <Saizan> Watermind: yeah, it'd make sense to perform such a check early wrt the instances in scope
02:55:41 <phil> how can I do that?    Can I stop people from creating  let's say   Node 3 (Leaf 5) (Leaf 1) ?
02:56:43 <Watermind> phil: make it an abstract data type, do not export the constructors but only functions which allow them to build sound trees, in the sense that they satisfy your constraint
02:56:48 <Saizan> phil: http://www.haskell.org/haskellwiki/Smart_constructors
02:58:29 <phil> thank you
02:59:21 <Watermind> Saizan: I was also suprised that in the full code, for the case a->b->c , I use s1 in it's own definition (to a function of type b->c), but it does not complain about overlapping instances
02:59:50 <Watermind> Saizan: however if I try to put an explicit type signature in that use of s1 then I imediatelly get the overlapping instances error
03:05:56 <turiya> i have been trying to program a small image display system in haskell but it seems to be very difficult.. whereas such stuff can be done relatively easily in C. What are the advantages of haskell over C? I am trying to understand this before I proceed further. Any comments?
03:07:39 <Zao> turiya: Excellence in the situations where Haskell is better than C.
03:07:52 <Zao> Nothing is universally better.
03:08:46 <Watermind> turiya: for how long have you been programming in C, for how long have you been programming in Haskell...?
03:09:24 <turiya> C > 7 yrs, Haskell ~ 4 months
03:10:17 <turiya> i think that, for low level stuff i.e., i/o, graphics, etc.. C is better..
03:10:28 <dagle> Depends.
03:10:40 <Watermind> turiya: that should explain plenty of your difficulties, had you been working with haskell for 7 years and C for 4 months you'd probably  be stuck with  segmentation faults and implicit conversion bugs
03:11:34 <turiya> Watermind: that might be the case. i still want to know which language to choose from for typical image processing stuff..
03:12:26 <turiya> working in haskell --  does it really save my time? or is it more easier?
03:12:48 <Watermind> turiya: I would actually say C is a terrible imperative language.... of course there's plenty of libraries, documentation and all... but the language itself is awful
03:13:38 <ClaudiusMaximus> what's typical image processing in your case?
03:13:45 <dagle> Watermind: It has it uses.
03:14:12 <ClaudiusMaximus> you can mix C and Haskell quite easily with the FFI, at least if your C code has a sane API
03:14:17 <Watermind> dagle: sure it has, but some design decisions in C are just bad rather than "appropriate for a certain use"
03:14:35 <turiya> ClaudiusMaximus: simple image addition, subtraction etc..
03:15:25 <dagle> Watermind: Ofc. 
03:15:52 <ClaudiusMaximus> turiya: i see - then use Haskell to define a single "combine :: (Pixel -> Pixel -> Pixel) -> Image -> Image -> Image" and forget about nested for loops forever after that
03:15:54 <turiya> mixing haskell and C is an option, but that seems to be hard and why not completely program in C when the advantages of haskell are not clear?
03:15:59 <Watermind> dagle: two simple examples are  implicit casts and  things like the overloading of  /
03:17:17 <dagle> Watermind: Well if you look at how hardware can look it can be kinda ok.
03:18:16 <Watermind> dagle: not sure what you mean, what does that has to do with the overloading of   /  for Ints and Doubles?
03:18:19 <ClaudiusMaximus> C is neither low level enough (to access hardware flags like "was the result of the previous subtraction 0") nor high level enough
03:18:41 <Watermind> dagle:  integer and real division are completely different operations with different properties
03:18:55 <dagle> Watermind: Aha. You meant that.
03:19:20 <Watermind> dagle: and   abs(-4.5)  -> 4     
03:20:09 <dagle> Watermind: Well I use C mostly for kernelprogramming were it's pretty much ok.
03:20:22 <dagle> Watermind: Well that is a lib and not C.
03:21:22 <Watermind> dagle: yes I understand that sometimes you may want to work low level, but I still don't see how implicit casts from doubles to integers are a big help for that, more than a source of errors
03:21:51 <Watermind> dagle: the include system is arcaic....
03:22:07 <Watermind> dagle: switch with those breaks is pretty bad... etc etc 
03:22:45 <dagle> Watermind: There are alot of legacy stuff in C which made sense at that time.
03:22:57 <dagle> Now it doesn't.
03:23:40 <dagle> The switch/case is almost just a weak version of if/else if/else 
03:23:56 <Watermind> yes I understand
03:24:12 <Watermind> well the if doesn't follow to the else :S
03:24:21 <Watermind> like one case follows to the other
03:24:42 <dagle> That might have been a good idea back then.
03:24:51 <Watermind> probably was :)
03:24:59 <dagle> Save 2 instructions or something.
03:25:08 <Watermind> yeap
03:25:22 <dagle> Easier to get it to iCache etc.
03:25:34 <Watermind> I understand you had to do the language with the compiler in mind
03:26:24 <dagle> Just look at lisp. Part of the design was to make the compiler easier, now it stuck like that. :)
03:27:02 <Watermind> if only the number of C users was that of lisp
03:27:04 <Watermind> ;)
03:28:11 <dagle> But there are cool languages like clay which tries be a safe, typed hardware language with some functional elements.
03:28:28 <Watermind> oh I don't know clay
03:28:55 <Watermind> I don't know that many hardware languages though
03:29:05 <dagle> Maybe it's not that hard to write a kernel i haskell but It would be strange for me.
03:29:42 <dagle> Going from C to clay would be almost the same.
03:30:23 <Watermind> yeap I was thinking C vs Pascal like languages (Modula's, Ada,...)
03:30:31 <dagle> :)
03:32:06 <dagle> And it's not like you can't write good C programs. It's just really easy to write really bad ones.
03:33:32 <Watermind> true
03:33:56 <lars9> what kind of programs do you write in haskell?
03:34:47 <Watermind> recursive programs
03:35:21 <dagle> if above 50% is some strange IO then I woundn't consider haskell.
03:36:49 <ezyang> dagle: That's not true. 
03:37:16 <dagle> ezyang: Ok? 
03:37:42 <dagle> What part?
03:37:51 <ezyang> dagle: Haskell is a perfectly good imperative programming language. 
03:38:16 <dibblego> Haskell is a *great* imperative loanguage
03:38:31 <dagle> ezyang: Maybe I define strange IO a bit different then you. :P
03:38:45 <ezyang> dagle: Ah yes. What is strange IO? 
03:39:24 <dagle> Writing a highspeed blockfilesystem. 
03:39:35 <dagle> Stuff like that.
03:41:07 <dagle> If you end up with being forced to edit the buffersizes of how the file should be read etc.
03:41:15 <phil> how fast/slow is haskell?    Does being lazy make it really slow?
03:41:55 <Saizan> haskell as a language is neither fast nor slow
03:41:56 <dagle> phil: For 99% of the cases it's fast.
03:42:29 <Saizan> GHC produces executables that are pretty performant
03:42:46 <dark> the bitC author is doing a type system that includes first-order notion of mutability ("region analysis") because, accordingly to him, encapsulating i/o in monads is not enough for the kind of low level program he wants to write
03:42:48 <Saizan> i.e. comparable to C
03:43:08 <dark> I admit I don't know much about this stuff..
03:44:07 <dark> (his idea is that if some mutability does not escape the inner working of a function, the function can be considered "pure". but mutability is first order, so this is hard)
03:44:49 <dagle> dark: The problem I have with bitC is that alot of talk and theory and not so much practice all the time.
03:45:28 <Saizan> dagle: the ST monad let you do something like that, and indeed it's inspired by regions, but i guess you can get way fancier with a dedicated type system
03:45:41 <dark> Saizan, can haskell do "from now on, I want to allocate everything on stack"?
03:46:13 <Saizan> dark: i was referring to "if some mutability does not escape the inner working of a function, the function can be considered pure"
03:46:26 <dark> unrelated to the monad thing, but also a reason to go to C
03:46:56 <dark> Saizan, yes, haskell actually can do that
03:47:06 <sipa> dark: why would you need to say something like that?
03:47:49 <dagle> Saizan: Not saying that it can't be done. More saying that choosing haskell in that regard wont give me enough to choose it.
03:48:54 <lars9> why my haskell code looks ugly, like C, how to write haskelly haskell?
03:49:10 <ClaudiusMaximus> i did some translation from C to Haskell a while ago, the resulting code is ugly.. http://webcache.googleusercontent.com/search?q=cache:eaHz_J_xuIAJ:hpaste.org/fastcgi/hpaste.fcgi/view%3Fid%3D28465
03:51:41 <lars9> for example, how to solve this problem in haskell's declerative style? http://hpaste.org/raw/40984/internetsecurity
03:52:00 <lars9> i can only write something with iteration like in C.
03:52:41 <Saizan> ClaudiusMaximus: IORefs!
03:53:40 <ClaudiusMaximus> Saizan: well spotted ;)
03:54:16 <Saizan> loops with IORefs all over the place, that's going to be slow too
03:55:02 <ClaudiusMaximus> lars9: prettify . dropWhile foo . iterate bar $ initial
03:56:25 <lars9> is that still iteration? find more and more dangerous sites each time until no more can be found?
03:57:41 <ClaudiusMaximus> lars9: there, 'bar' would do the danger propagation, 'foo' would check the threshold
03:59:36 <ClaudiusMaximus> lars9: hm, actually the algorithm is a bit less decomposable than i initially misread..
04:01:55 <dagle> lars9: If you don't care that much about speed you just find all the dangerous keywords first and then from that get the sites.
04:02:05 <lars9> ClaudiusMaximus: you can try to make a neat solution :)
04:02:05 <Saizan> that very imperative specification can be reformulated by thinking of websites of nodes of a graph which are connected if they have at least a word in common, then you start from the websites that are immediately dangerous and calculate the maximally connected graph
04:02:49 <dark> sipa, embedded devices? writing a kernel? sincerely I don't know much, but being able to go heap-free seems to be important
04:02:59 <Saizan> oh, wait, "threashold"
04:03:03 <Saizan> forgot about that.
04:04:12 <sipa> dark: i don't think haskell is able to be compiled to an environnement without garbage collection, so i doubt whether it can be done without a heap (or better: whether the remaining stack would be anything like you expect it to be)
04:05:32 <ClaudiusMaximus> lars9: i'd start with something like:  safe threshold dangerous (_name, keywords) = threshold <= S.size (dangerous `S.intersection` keywords)
04:05:32 <lars9> What i want is some delarations saying what kinds of sites are dangerous, then give a initial state, then the answer is lazily calculated by it self...
04:06:02 <ClaudiusMaximus> oops, should be > not <=
04:06:59 <lars9> can you show your working code under http://hpaste.org/40984/internetsecurity ?
04:07:58 <ClaudiusMaximus> maybe if i'm bored enough to get something working
04:08:01 <ClaudiusMaximus> :)
04:08:27 <lars9> ClaudiusMaximus:  :D
04:26:41 <SenseiScalps> is there anything like python lists so you can use mixed elements?
04:27:01 <dagle> SenseiScalps: You men a liste of both a and b?
04:27:02 * hackagebot darcs 2.5 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.5 (ReinierLamers)
04:27:05 <sipa> type Mixed = Either Foo Bar
04:27:07 <sipa> [Mixed]
04:27:24 <SenseiScalps> sipa: thx
04:27:45 <ClaudiusMaximus> :t [Left "foo", Right 42]
04:27:45 <SenseiScalps> dagle: like [1,"foo"]
04:27:45 <lambdabot> forall b. (Num b) => [Either [Char] b]
04:28:15 <Zao> SenseiScalps: Not with an unbounded set of elements.
04:28:23 <Zao> As you wouldn't be able to do anything useful with them.
04:28:30 <Zao> (set of element types, that is)
04:28:48 <ClaudiusMaximus> data Thing a b c d e f g = A a | B b | C c | ...
04:28:49 <Zao> (ignoring Typable and other abominations)
04:28:49 <SenseiScalps> Zao: mmm
04:29:15 <sipa> you could use http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Dynamic.html
04:29:27 <sipa> but think whether you really need it
04:29:43 <ClaudiusMaximus> type MyThings = Thing String Int Float Double (Maybe Char) ...
04:29:58 <SenseiScalps> thx a lot all of you. i will check you answer and feedback shortly
04:30:08 <SenseiScalps> answers
04:30:18 <Zao> Most people, when they think they need heterogeneous collections, don't :D
04:31:04 <sipa> indeed
04:31:12 <Watermind> SenseiScalps: you can also have a    list :: T a => [a]
04:31:43 <sipa> that's still a list of elements of a single type, although not a fixed one
04:32:46 <Zao> Where the only useful operations you can do on the elements are the ones in the typeclass T.
04:32:54 <Watermind> opss missed a forall over there
04:32:58 <SenseiScalps> Zao: curiosity of a newcomer is my motive
04:33:02 <Zao> And of course, having lots of forall and exists and other fun extensions.
04:34:20 <Watermind> sipa: you're right, my mistake... I don't remember the exact syntax now, I meant to write a list where elements can be any of class T a... I think remember using that before
04:34:37 <sipa> you mean existential types, i think
04:34:39 <Zao> Don't you need some wrapper type or something?
04:34:49 <sipa> and yes, i think you do
04:35:09 <Watermind> sipa: yeap ... and existential types in haskell are declared with a forall
04:35:56 <astroboy> if I try to use this function: http://hpaste.org/40987/floating_problems it says no istance for Floating Integer
04:36:16 <Watermind> forall a. (T a ) => [a]   ?
04:36:21 <Watermind> soemthing like that 
04:37:09 <Zao> astroboy: Most probably arising from the sqrt.
04:37:29 <Zao> astroboy: Sneak in a fromIntegral or whatever the function is to make a Floating?
04:37:45 <Zao> @type fromIntegral
04:37:46 <lambdabot> forall a b. (Integral a, Num b) => a -> b
04:37:56 <Zao> @type sqrt
04:37:57 <lambdabot> forall a. (Floating a) => a -> a
04:38:02 <astroboy> yeah but
04:38:06 <astroboy> @type floor
04:38:06 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
04:38:28 <astroboy> so in short, how to I get an Integer from a squareroot?
04:38:47 <SenseiScalps> bye all
04:38:48 <Zao> Via floor or ceil, but that's not the problem.
04:39:02 <Zao> Your problem is that sqrt requires a Floating argument.
04:39:22 <Zao> @instances Floating
04:39:23 <lambdabot> Double, Float
04:39:29 <astroboy> ohhh ok.
04:39:32 <Zao> Integer, isn't one :D
04:39:51 <astroboy> I'll try fromIntegral, thanks a lot
04:40:44 <astroboy> Zao: it works thanks a lot
04:40:46 <Zao> > floor . sqrt . fromInteger $ (42 :: Integer)
04:40:47 <lambdabot>   6
04:41:20 <Zao> > floor . sqrt . fromIntegral $ (42 :: Int)
04:41:21 <lambdabot>   6
04:41:26 <Zao> Excellent.
04:41:43 <Zao> @src fromIntegral
04:41:43 <lambdabot> fromIntegral = fromInteger . toInteger
04:41:47 <Zao> Cute definition :)
04:42:55 <phil> Zao, what does the $ do in that line?
04:43:10 <Zao> $ is like function application, but with a very low precedence.
04:43:20 <Zao> It's commonly used to get rid of excess parenthesis.
04:43:35 <Zao> a b $ c d   is kind of like  (a b) (c d)
04:43:47 <phil> ah, thanks
04:44:00 <Zao> > (floor . sqrt . fromIntegral) (42 :: Int)
04:44:01 <lambdabot>   6
04:44:14 <horms> or just a b (c d)
04:44:24 <Zao> It's one of the constructs that make Haskell less LISPy :D
04:44:26 <Zao> Indeed.
04:44:36 <merijn> @src ($)
04:44:36 <lambdabot> f $ x = f x
04:44:57 <merijn> It's a parenthesis elimination tool :p
04:45:12 <benmachine> it's also useful in some other contexts
04:45:17 <benmachine> e.g
04:45:30 <benmachine> > map ($ 0) [sin, cos]
04:45:30 <lambdabot>   [0.0,1.0]
04:45:34 <benmachine> sections woo
04:45:57 <phil> nice
04:46:58 <merijn> hmm, does this work in lambdabot?
04:47:02 <merijn> @src ($0)
04:47:02 <lambdabot> Source not found. The more you drive -- the dumber you get.
04:47:54 <astroboy> is there a higher order function to check if a list is composed of just one element :P?
04:48:22 <sipa> (==1) . length
04:48:33 <astroboy> no i mean
04:48:43 <astroboy> is composed of the same element, repeated
04:49:03 <astroboy> or a function that removes every occurence of one element
04:49:04 <sipa> (==1) . length . nub
04:49:09 <astroboy> ok thanks
04:50:02 <scree> @src nub
04:50:02 <lambdabot> nub = nubBy (==)
04:50:07 <scree> @src nubBy
04:50:07 <lambdabot> nubBy eq []             =  []
04:50:07 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
04:50:22 <scree> sounds a bit quadratic
04:50:39 <sipa> why?
04:50:53 <Zao> filter on not being the first element, take the length of that.
04:51:06 <scree> isOne (x:xs) = and (zipWith (==) (x:xs) xs)
04:51:24 <Zao> Or just not . any (/=the_head)
04:51:46 <scree> > let isOne ls = and (zipWith (==) ls (tail ls)) in isOne [1,1,1,1,1]
04:51:47 <lambdabot>   True
04:51:51 <scree> > let isOne ls = and (zipWith (==) ls (tail ls)) in isOne [1,1,1,2,1]
04:51:51 <lambdabot>   False
04:52:14 <sipa> that's probably faster indeed
04:52:24 <Zao> If comparisions are expensive, could they be sparked off?
04:52:36 <scree> Zao: how do you mean?
04:52:58 <Zao> Linearly iterating, sparking of parallel computations of equality, early-outing as soon as you get one negative?
04:53:01 <Zao> *off
04:53:14 * hackagebot throttle 0.1 - Throttle TCP/IPv4 connections to a given server.  http://hackage.haskell.org/package/throttle-0.1 (ChrisDone)
04:53:27 <merijn> astroboy: Function that removes every occurence of one element == "filter"
04:53:27 <sipa> that's what scree's isOne does i think
04:54:12 <Zao> sipa: Minus the sparking.
04:54:34 <scree> if you use mine with a parallel and, or Zao's with a parallel any, you get that behaviour I think
04:54:38 <sipa> you mean in a multi-threaded way?
04:54:39 <Zao> Ah.
04:54:52 <Zao> scree: Stealthy primitives, those.
04:55:04 <scree> Zao: not primitives surely?
04:55:14 <sipa> @src and
04:55:15 <lambdabot> and   =  foldr (&&) True
04:55:22 <Zao> Well, primitive as in "stuff you can build stuff with"
04:55:34 <scree> Zao: right
04:55:38 <Zao> Not the Int# kind of primitives.
04:55:41 <sipa> ok
04:55:58 <astroboy> is there a fun to convert an integer to a string?
04:56:06 <Zao> show
04:56:21 <astroboy> oh right, i'm an idiot :P
04:57:08 <scree> I'm pretty sure there's an early-outing parallel (&&) somewhere
04:58:17 <elmargol> I'm using hpodder (haskell) and since a recent update to my system hpodder takes forever to fetch feed updates. Any hpodder users here?
05:02:08 <chrisdone> I see hackage's package description package got an update. looks nice
05:03:21 <chrisdone> who made that change?
05:03:35 <chrisdone> I looked on Gracenotes's blog and there's no update
05:04:04 <chrisdone> granted, it could've been spontaneous beautification
05:04:49 <benmachine> iiinteresting
05:05:59 <Eduard_Munteanu> Hi.
05:06:03 <benmachine> hi
05:16:19 <astroboy> I remember a command to force haskel to execute a command instead of being lazy
05:16:46 <aristid> :t seq
05:16:47 <lambdabot> forall a t. a -> t -> t
05:16:58 <aristid> astroboy: but that's not for "commands"
05:17:11 <aristid> it's for expressions
05:17:35 <Zao> > let x = 5 `seq` 3 in 9001
05:17:36 <lambdabot>   9001
05:17:46 <Zao> Is 5, 3 or x evaluated? No-one knows!
05:18:28 <dolio> I know.
05:18:51 <Zao> dolio: You know what?
05:19:09 <dolio> Whether 5, 3 and x are evaluated.
05:19:12 <astroboy> aristid: yes that's what I meant, thanks (:
05:20:00 * Zao deepseqs dolio.
05:20:05 <astroboy> let's see I've got and (some code generating a long list). haskell will stop calculating as soon as it encounters a False, right?
05:20:18 <astroboy> i mean "and (some code)"
05:20:31 <dibblego> if you mean the function "and" then yes
05:20:41 <dibblego> you can demonstrate this to yourself by giving it an infinite list
05:20:56 <dibblego> observe termination when there is one False in the infinite list
05:21:02 <aristid> > and (repeat False)
05:21:03 <lambdabot>   False
05:21:06 <aristid> > and (repeat True)
05:21:12 <lambdabot>   mueval: ExitFailure 1
05:21:22 <astroboy> yes I meant "and"
05:21:27 <benmachine> astroboy: as long as the code generating the list is productive
05:21:29 <astroboy> well of course doesn't work with repeat True :P
05:21:38 <benmachine> astroboy: i.e. can quickly produce the first element
05:21:40 <aristid> astroboy: just wanted to demonstrate :P
05:22:03 <benmachine> astroboy: if you were like, and (reverse (huge long list)) then it would be the same but the whole list would be calculated before you got your result
05:23:10 <dark> how can I stop darcs asking if I really want to pull some patch? (at darcs pull). I always press "a"..
05:25:13 <dolio> darcs pull -a
05:31:31 <benmachine> dark: darcs pull -a
05:31:33 <benmachine> I think
05:32:41 <dark> thank you! (ps: i'm unable to find it on man darcs)
05:33:27 <dark> ok, in darcs rev it says "The --all switch can be used to avoid such prompting."
05:33:43 <dolio> You can get help on most things with 'darcs <whatever> --help'.
05:33:51 <dolio> 'darcs pull --help'
05:34:31 <dark> yes, better :)
05:40:12 <Heffalump> dark: you can set defaults in ~/.darcs/defaults (I think that's the file)
05:41:18 <Heffalump> yes, that's the file. A line saying "pull all" would do it.
05:42:24 <lars9> archlinux users, do you use cabal or AUR to install ghc packages?
05:46:29 <Eduard_Munteanu> lars9: I'm on Gentoo and I tend to go for distro packages especially when it's a lib used by applications (e.g. xmonad), then cabalize whatever else I need to write my code.
05:46:56 <Eduard_Munteanu> Since "cabal is not a package manager", I'm being a bit conservative.
05:47:34 <Kaidelong> cabal is something that needs a lot of work
05:47:43 <burp> "something" yes ;)
05:48:05 <Eduard_Munteanu> Technically distros still need a lot a work to provide more Haskell packages and keep them uptodate.
05:48:13 <Kaidelong> I wonder if darcs will build for me now
05:48:39 <burp> Kaidelong: I had to downgrade to Cabal-1.8.0.2
05:48:45 <burp> for some dependency to build
05:48:54 <Eduard_Munteanu> Though a user-local package manager for Haskell wouldn't be bad.
05:48:56 <Kaidelong> I'll take that as a no and move on, then
05:50:00 <aristid> Eduard_Munteanu: isn't cabal already user-local by default?
05:50:21 <aristid> oh, because it is not a package manager? :D
05:50:22 <burp> http://haskell.org/haskellwiki/Hack-Nix http://github.com/MarcWeber/nixpkgs-haskell-overlay
05:50:52 <Eduard_Munteanu> aristid: yeah :)
06:01:16 <Eduard_Munteanu> burp: nice
06:01:17 <Maxdamantus> :t merge
06:01:18 <lambdabot> Not in scope: `merge'
06:01:26 <Maxdamantus> @hoogle merge
06:01:26 <lambdabot> Data.Graph.Inductive.Internal.Heap merge :: Ord a => Heap a b -> Heap a b -> Heap a b
06:01:26 <lambdabot> Data.Graph.Inductive.Internal.Heap mergeAll :: Ord a => [Heap a b] -> Heap a b
06:01:26 <lambdabot> Text.Parsec.Error mergeError :: ParseError -> ParseError -> ParseError
06:01:30 <Eduard_Munteanu> Purely functional package manager, heh.
06:01:44 <burp> using nixpkg solves all these "cabal" dependency hell issues
06:01:44 <Eduard_Munteanu> I guess it doesn't do any IO to the disk? :P
06:02:19 <dagle> Hmm.
06:02:58 * dagle made an error so a function didn't become lazy and applied it to [1..]
06:03:22 <Eduard_Munteanu> This Nix stuff looks interesting.
06:04:23 <Entroacceptor> I installed nixos on a vm once
06:04:25 <Entroacceptor> very nice
06:05:37 <Eduard_Munteanu> Hm, is it source-based? It says something about downloading binaries if available.
06:05:51 <Eduard_Munteanu> I might try this, I'm a Gentoo-head.
06:05:59 <Entroacceptor> you can dl source or binary,IIRC
06:06:03 <Entroacceptor> go to #nixos
06:06:11 <dagle> Is there a haskell compiler written in C?
06:06:18 <Eduard_Munteanu> dagle: JHC
06:06:20 <Eduard_Munteanu> IIRC.
06:08:06 <aristid> doesn't GHC have a bootstrap compiler in C?
06:08:32 <merijn> aristid: Yes
06:08:54 <merijn> But that might just be a compiler written in haskell compiled to C?
06:09:29 <dagle> That C code might not be so much fun if you want to do porting. :P
06:09:40 <merijn> At least I know FreeBSD bootstraps using a haskell compiler written in C to compile GHC to compile the newest GHC with GHC
06:09:59 <merijn> dagle: Examine how the FreeBSD ghc port does it?
06:10:04 <dolio> I don't think JHC is written in C.
06:10:08 <Lemmih> Eduard_Munteanu: JHC is written in Haskell.
06:10:08 <dolio> Not primarily, at least.
06:10:28 <dagle> merijn: Freebsd is nix. That might make it a bit easier. :P
06:12:02 <Entroacceptor> dagle: no the nix we're talking about ;)
06:12:19 <dagle> Entroacceptor: Huh?
06:12:27 <Eduard_Munteanu> Lemmih: hm, my bad then.
06:12:37 <Eduard_Munteanu> Or were the earlier versions coded in C? :/
06:13:23 <Lemmih> Eduard_Munteanu: Nope, it has always been 100% Haskell.
06:13:33 <Eduard_Munteanu> dagle: not nix as in *nix, but nix as in NixOS
06:13:37 <Lemmih> It generates C, though.
06:14:00 <Eduard_Munteanu> Ah, that was it. At least more readable C than GHC last time I tried.
06:14:02 <merijn> Looks like that's just Yet Another Linux Distro, why the fancy name? >.>
06:14:43 <Eduard_Munteanu> merijn: indeed, names like that make me think of some sort of RTOS by that name
06:15:08 <dagle> Hugs seems to be in C. :)
06:15:39 <merijn> Can Hugs compile ghc, though?
06:15:46 <dagle> Dunno.
06:15:49 <merijn> (I'm assuming that's the eventual goal)
06:16:01 <sipa> hugs doesn't compile anything, the question is whether it can run the GHC source :)
06:16:22 <dolio> Doubtful.
06:16:27 <burp> oh, what an idea… running ghc with hogs =)
06:16:37 <burp> erm hugs
06:17:16 <Jafet> Sup dawg we heard you like hugs
06:17:47 <dagle> merijn: The idea is to run hugs in firefox some day.
06:22:05 <merijn> dagle: There's a Haskell to JS compiler I saw :p
06:22:22 <dagle> merijn: I know about that one.
06:24:58 <Twey> Eduard_Munteanu: It's source-based, but there are cached binaries, so if you would be compiling exactly the same thing that someone else has already compiled that's been made available as a binary, you'll get the binary instead, transparently
06:26:00 <Eduard_Munteanu> Hm, that sounds strange.
06:26:26 <Eduard_Munteanu> Twey: is that uploading transparent as well?
06:33:18 <Twey> Eduard_Munteanu: No, that would be a security risk
06:33:29 <Twey> (sadly; I had the same thought just now when describing it)
06:33:39 <Twey> Sort of P2P compiling
06:35:15 <Eduard_Munteanu> Yeah, I was concerned.
06:35:53 <Maxdamantus> I saw another interesting thing that might be used to convert Haskell to JS
06:36:08 <Maxdamantus> A llvm to JS converter
06:36:37 <Maxdamantus> Hm, but I'd think either the GHC JS backend or the YHC thing would be better performance in most cases.
06:39:08 <Maxdamantus> It requires funny stuff for emulating the memory system in actual machines.
06:43:33 <pokoko222> what software can i use for practicing proving boolean algebra expressions?
06:43:53 <pokoko222> type theory guys recommended me something of this sort before i think
06:44:19 <pokoko222> where you know, you can go step by step applying theorems and postulates 
06:44:28 <merijn> pokoko222: Coq?
06:44:38 <pokoko222> ah yeah Coq
06:44:40 <Twey> Agda? :þ
06:45:01 <merijn> Twey: It's funnier to make English people pronounce Coq :D
06:45:02 <pokoko222> ah yeah the those were the two
06:45:08 <Twey> Haha
06:45:10 <pokoko222> so who should i go for
06:45:20 <pokoko222> i need to practice for digital logic class
06:45:22 <Twey> merijn: Minor issue… ;)
06:45:34 <Twey> pokoko222: Either should work, I think
06:45:38 <merijn> pokoko222: Well, depends on what people around you use, I guess
06:45:39 <Twey> Pick one you like
06:45:45 <merijn> I found a good intro to Coq, though: http://www.cis.upenn.edu/~bcpierce/sf/toc.html
06:45:51 <pokoko222> merijn we use nothing, just on paper
06:45:56 <pokoko222> but i want to try one for myself
06:46:42 <merijn> Go with the one which you find the better documentation/OS support for? :p
06:59:17 <Eduard_Munteanu> Automated proving is more involved and rigorous than paper-and-pen
07:00:13 <Eduard_Munteanu> So if you just want to evaluate expressions and provide somethink like a handwritten formal proof, Coq might be a bit too much.
07:00:26 <Eduard_Munteanu> *something
07:41:53 <duairc> Is there any way of doing something like type X = typeof(some expression)?
07:43:27 <Twey> duairc: Ummm, maybe in TH
07:43:31 <Twey> duairc: Why?
07:44:24 <duairc> It's not terribly important, but the type is such that the expression is much shorter than the expression itself, and the expression is probably clearer
07:44:47 <Twey> Hm.  I'd look into TH if it's worth it for you.
07:45:32 <duairc> *than the type itself
07:45:51 <duairc> I may end up using TH in this project anyway, but for now I think I'll just write the type
08:10:47 <krey_> hello, i'm trying to do a dfs in a graph to get the set of vertices, using this function: http://hpaste.org/40988/dfs
08:11:00 <krey_> how inefficient is this, is there a nice way of making it more efficient?
08:18:51 <fffej> I've got a duplicate sysmbol definition which is caused with having directory-1.0.1.1 and 1.0.1.2 required.  What should I do to fix it?  I've tried looking at the package conf file but I don't know what changes I should make
08:19:16 <aristid> appending to a lazy bytestring is more efficient than appending to a strict bytestring, right?
08:20:06 <krey_> whoa, channel's kinda dead
08:20:27 <aristid> krey_: maybe just because it's a saturday, or halloween or so
08:20:48 <krey_> aristid: it's halloween today??
08:20:49 <krey_> omg
08:20:58 <aristid> krey_: dunno
08:21:05 <aristid> krey_: today or tomorrow or some day
08:21:05 <krey_> I think it's tomorrow
08:21:09 <aristid> no idea really
08:21:17 <aristid> krey_: i just know minecraft gets an update tomorrow
08:21:24 <krey_> :D
08:21:33 <krey_> more important than halloween, I guess
08:21:37 <aristid> ya
08:22:04 <burp> sure
08:22:06 * jmcarthur builds a portal and visits the Slip for a while
08:22:14 <burp> it's just halloween tomorrow _because_ minecrafts gets an update
08:23:34 * ski . o O ( <http://en.wikipedia.org/wiki/Halloween_Documents> )
08:24:55 <Darkovsky> Eduard_Munteanu, you there?
08:25:15 <pokoko222_> has someone implemented quern mcluskey algorithm?
08:26:33 <Darkovsky> Anyone here used IArray?
08:26:36 <Darkovsky> I have a slight issue
08:27:00 <aristid> Darkovsky: yea just ask :)
08:27:24 <aristid> jmcarthur: you got the upgrade already?!
08:28:58 <Darkovsky> aristid, here's the problem
08:29:18 <Darkovsky> I'm reading a semicolon delimited- wait, maybe it's not with the array
08:29:36 <Darkovsky> Using regular list processing on the line...
08:30:26 <Darkovsky> Yep. That's the problem :/
08:30:43 <aristid> Darkovsky: ok, sometimes it helps just to talk about the problem :D
08:31:54 <Eduard_Munteanu> Darkovsky: yes
08:32:17 <Eduard_Munteanu> Ah.
08:32:38 <Darkovsky> Eduard_Munteanu, will bytestring split choke on "0;0;0;;0;" ?
08:33:00 <Darkovsky> The method I was using assumed that a ; did not follow another ; 
08:33:28 <Darkovsky> Which is why, when it encountered ";;", it happily grouped them, and deleted them both.
08:34:23 <Eduard_Munteanu> Darkovsky: hm, yeah, the problem is in your ';'.
08:34:32 <Eduard_Munteanu> *in your split
08:34:36 <Darkovsky> Yep.
08:34:39 <Darkovsky> I know :P
08:35:11 <Darkovsky> How would I ask lambdabot to run Data.ByteString split?
08:35:19 <benmachine> :t BSC.split
08:35:19 <lambdabot> Char -> BSC.ByteString -> [BSC.ByteString]
08:35:50 <benmachine> or
08:35:52 <benmachine> :t BS.split
08:35:53 <lambdabot> Word8 -> BSC.ByteString -> [BSC.ByteString]
08:36:10 <Darkovsky> >BS.split 59 (BS.pack "0;0;0;;0;")
08:36:15 <Darkovsky> >.>
08:36:31 <benmachine> > text "you need a space"
08:36:31 <Eduard_Munteanu> > BS.split 59 (BS.pack "0;0;0;;0;")
08:36:32 <lambdabot>   you need a space
08:36:32 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
08:36:32 <lambdabot>         against inferred type...
08:36:40 <Darkovsky> Lol xD
08:36:45 <Darkovsky> > BS.split 59 (BS.pack "0;0;0;;0;")
08:36:45 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
08:36:45 <lambdabot>         against inferred type...
08:37:10 <Eduard_Munteanu> > BSC.split 59 (BSC.pack "0;0;0;;0;")
08:37:10 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
08:37:10 <lambdabot>    arising from the literal `5...
08:37:15 <ClaudiusMaximus> > BS.split 59 (BS.pack $ map toEnum "0;0;0;;0;")
08:37:16 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:37:16 <lambdabot>         against inferred type ...
08:37:29 <Darkovsky> > BS.split (BS.pack ";") (BS.pack "0;0;0;;0;")
08:37:29 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
08:37:30 <lambdabot>         against inferred type...
08:37:34 <Darkovsky> ?!
08:37:34 <lambdabot> Maybe you meant: . ? @ v
08:37:38 <benmachine> > BS.split 59 (BSC.pack "0;0;0;;0;")
08:37:38 <lambdabot>   ["0","0","0","","0",""]
08:37:43 <benmachine> <_<
08:38:13 <Darkovsky> That's good behavior there
08:38:25 <benmachine> > BSC.split ';' (BSC.pack "0;0;0;;0;")
08:38:26 <lambdabot>   ["0","0","0","","0",""]
08:38:31 <Darkovsky> Now, how will it handle that trailing ""?
08:38:44 <benmachine> note that despite appearances these are bytestrings not strings
08:38:50 <Eduard_Munteanu> Darkovsky: well when you unsplit it just appends ';'
08:38:54 <Darkovsky> My code that is, when I write.
08:39:12 <Darkovsky> So, intercalate ";" ["0","0","0","","0",""]
08:39:14 <Eduard_Munteanu> Darkovsky: it's just an extra column, when you access by index, it's at the end so it shouldn't matter
08:39:20 <Darkovsky> > intercalate ";" ["0","0","0","","0",""]
08:39:21 <lambdabot>   "0;0;0;;0;"
08:39:24 <Darkovsky> Okay
08:39:38 <Darkovsky> Was worried that the empty list might act up with my thing.
08:39:49 <Darkovsky> Not about it acting up with the array ;)
08:44:07 <aristid> :t fmap (BSL.fromChunks . return) . BS.packCStringLen
08:44:08 <lambdabot> Foreign.C.String.CStringLen -> IO BSLC.ByteString
08:44:19 <aristid> \o/
08:45:19 <dagle> :)
08:48:15 <Darkovsky> > BSC.pack "test;t;t;;0;"
08:48:16 <lambdabot>   "test;t;t;;0;"
08:48:34 <Darkovsky> > BS.split ';' (BSC.pack "test;t;t;;0;")
08:48:35 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
08:48:35 <lambdabot>         against inferred type...
08:48:45 <Darkovsky> Woops
08:48:51 <Darkovsky> > BSC.split ';' (BSC.pack "test;t;t;;0;")
08:48:51 <lambdabot>   ["test","t","t","","0",""]
08:51:29 <Darkovsky> :t BSC.pack "test;t;t;;0;"
08:51:30 <lambdabot> BSC.ByteString
08:51:46 <Darkovsky> :t BSC.split ';'
08:51:47 <lambdabot> BSC.ByteString -> [BSC.ByteString]
08:52:00 <Darkovsky> :t "test;t;t;;0;"
08:52:01 <lambdabot> [Char]
08:52:07 <Darkovsky> ... why isn't this working...
08:52:33 <Eduard_Munteanu> What isn't working?
08:52:47 <Darkovsky> import qualified Data.ByteString.Char8 as BSC   
08:52:50 <Darkovsky> Correct?
08:53:02 <Eduard_Munteanu> Yes.
08:53:45 <Darkovsky> split list = BSC.unpack . BSC.split ';' $ BSC.pack list
08:54:42 <Darkovsky> Couldn't match expected type `BSC.ByteString' against inferred type `[BSC.ByteString]'  In the second argument of `(.)', namely `BSC.split ';''
08:55:08 <ski>   split = map BSC.unpack . BSC.split ';' . BSC.pack  -- ?
08:56:24 <Darkovsky> > BSC.unpack . BSC.split ';' $ BSC.pack "t;t;tgs;;0;0;"
08:56:25 <lambdabot>   Couldn't match expected type `Data.ByteString.Internal.ByteString'
08:56:25 <lambdabot>         ...
08:56:40 <Darkovsky> > map BSC.unpack . BSC.split ';' $ BSC.pack "t;t;tgs;;0;0;"
08:56:41 <lambdabot>   ["t","t","tgs","","0","0",""]
08:57:39 <Darkovsky> There is goes.
08:58:07 <Darkovsky> Had to change the $ to a ., as it's just composition, not passing a value...
08:59:06 <ski> if you want to use `$', then i suggest
08:59:25 <ski>   split list = map BSC.unpack . BSC.split ';' . BSC.pack $ list
08:59:28 <ski> instead of
08:59:34 <ski>   split list = map BSC.unpack . BSC.split ';' $ BSC.pack list
08:59:40 <ski> the former is prettier, imo
08:59:44 <ski> in this case
08:59:49 <Darkovsky> It works! GLEEEE
08:59:49 <Darkovsky> GLEEEE it even loads into X3 editor!
08:59:49 <Darkovsky> Now to tweak the stats. A collossus doing 180m/s is terrifying
08:59:50 <ski>   split = map BSC.unpack . BSC.split ';' . BSC.pack
08:59:55 <ski> is even nicer, though
09:00:03 <Maxdamantus> @hoogle liftM2
09:00:03 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:00:44 <ski> @hoogle GLEEEE
09:00:44 <lambdabot> No results found
09:02:29 <Maxdamantus> @pl \f g a b -> f (g a) (g b)
09:02:29 <lambdabot> join . ((flip . ((.) .)) .) . (.)
09:02:43 <Maxdamantus> @pl \g f a b -> f (g a) (g b)
09:02:43 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
09:03:06 <Maxdamantus> @pl \f g a b -> f (g b) (g a)
09:03:06 <lambdabot> join . (((.) . flip) .) . (.)
09:03:36 <Darkovsky> > let normalize num mid factor = num + (mid - num) / factor
09:03:37 <lambdabot>   not an expression: `let normalize num mid factor = num + (mid - num) / fact...
09:03:43 <Darkovsky> Woops
09:04:25 <Darkovsky> > let normalize num mid factor = num + (mid - num) / factor in normalize (38 * 1.2) 1000 25
09:04:26 <lambdabot>   83.77600000000001
09:04:30 <Darkovsky> Niice
09:05:08 <Maxdamantus> @pl sort a = uncurry merge  $ (\(a,b) -> (sort a, sort b)) $ splitAt (length a `div` 2) a
09:05:08 <lambdabot> sort = fix ((uncurry merge .) . (. (splitAt =<< (`div` 2) . length)) . (. snd) . (ap =<< ((,) .)))
09:05:16 <Darkovsky> > let normalize num mid factor = num + (mid - num) / factor in normalize (300 * 1.2) 1000 25
09:05:17 <lambdabot>   385.6
09:05:25 <Darkovsky> Reasonable.
09:05:39 <Maxdamantus> @pl uncurry merge  $ (\(a,b) -> (sort a, sort b)) $ splitAt (length l `div` 2) l
09:05:39 <lambdabot> uncurry merge ((sort *** sort) (splitAt (length l `div` 2) l))
09:07:15 <Darkovsky> Well that didn't work
09:22:34 <mrg> hi
09:23:02 <Eduard_Munteanu> mrg: hi
09:23:30 <mrg> i've a question regarding haskell... i hope i am right here
09:23:44 <Eduard_Munteanu> Yep, shoot :)
09:24:24 <mrg> ok.. i am new to haskell and have a task that includes a type: type Graph a = [(a,[a])]
09:25:46 <mrg> i learned about the useful syntax (x:xs) and tried to applie it to a function using this type
09:26:04 <mrg> test :: Eq a => Graph a -> Bool
09:26:44 <mrg> i've tried to use it like ((y,ys):xs) but his doesn't work
09:27:29 <mrg> is it possible to use this (x:xs) syntax with this kind of type?
09:27:43 <sipa> that looks like a correct pattern match for such a Graph a
09:28:22 <mrg> i got an error...
09:28:26 <sipa> which one?
09:31:16 <monadic_kid> mrg: what you have there is a list of a tuple of a' and list of a', (y, (z:zs)):xs is on possible destructing pattern
09:31:37 <monadic_kid> *is one possible destructing pattern
09:31:59 <mrg> ok... i'll try
09:32:12 <monadic_kid> mrg: what exactly are you trying to pick out exactly
09:32:57 <aristid> man, i wish there was a decent http library for haskell that also supports SSL/TLS
09:34:03 <mrg> hmm this doesn't work... i try to seperate the first tuple of the list to start a recursive function...
09:34:18 <Philonous> I'm trying to open a project in emacs scion, but on sending the method "open-cabal-project" the scion server replies with "The requested method is not supported". Am I doing something wrong? Is this a known bug?
09:34:37 <alpounet> aristid, HTTP doesn't ?
09:35:58 <mrg> the error is: Couldn't match expected type `(a, [a])' against inferred type `[a1]' In the pattern: (y, (z : zs)) : xs  In the pattern: [(y, (z : zs)) : xs] In the definition of `test': test [(y, (z : zs)) : xs] = True
09:36:01 <Philonous> > let f ((a,b):xs) = show a ++ show b ++ f xs; f[] = " end" in f $ zip [1..10] ['a'..'j']
09:36:02 <lambdabot>   "1'a'2'b'3'c'4'd'5'e'6'f'7'g'8'h'9'i'10'j' end"
09:36:13 <alpounet> aristid, curl (http://hackage.haskell.org/package/curl) seems to support that
09:36:19 <sipa> mrg: no [ ] around it
09:36:20 <enthropy> mrg: use ( ) on the outside
09:36:43 <sipa> [a] matches a singleton list
09:37:03 <mrg> ooh god
09:37:09 <ClaudiusMaximus> given the radius of four circles at each vertex of a square, how could i compute if the union of the circles completely covers the square?
09:37:13 <mrg> sorry for that stupid question
09:37:22 <mrg> just did not see it
09:37:24 <monadic_kid> mrg: you still need parenthesis in the right place
09:37:35 <mrg> thanks for your help
09:37:36 <aristid> alpounet: right, the curl package supports it
09:37:43 <aristid> alpounet: but it has a horrendous interface
09:37:44 <enthropy> depends whether the context expects multiple patterns
09:37:58 <aristid> alpounet: granted, that is largely curl's fault
09:38:01 <aristid> but still
09:38:13 <alpounet> aristid, yeah agreed... maybe you can wrap this out in a nicer looking interface ?
09:38:16 <enthropy> monadic_kid: if the match is in `case', the only parens you need are for the tuple
09:39:02 <aristid> alpounet: i do, internally for my project. attempting to make a fully general interface for curl would be too hard
09:39:03 <old_sound> Hi guys, I'm having an error while trying to build pandoc
09:39:31 <monadic_kid> enthropy: yes i know but that isn't in a case statement and I'm talking in general because it looks like this guy thinks it's part of the syntax and required everywhere
09:40:12 <gwern> ClaudiusMaximus: could you just see whether all 4 circles interesect at the same point in the square?
09:40:24 <benmachine> old_sound: specifically?
09:40:37 <old_sound> this command runghc Setup.hs configure
09:40:44 <old_sound> is returning: Could not find module `Distribution.Simple.Utils':
09:40:54 <old_sound> which I think it should be part of Cabal no?
09:41:07 <old_sound> I just reinstalled the haskell platform on mac
09:41:09 <benmachine> old_sound: what's the next line of the error?
09:41:13 <enthropy> old_sound: what version of Cabal (library) do you have?
09:41:18 <gwern> old_sound: sounds like you're missing cabal entirely. since you're on a Mac, expect many such errors
09:41:19 <ClaudiusMaximus> gwern: they each have a different radius
09:41:21 <old_sound> let me check
09:41:38 <old_sound> benmachine: next line: -v to see a list of the files searched for.
09:41:40 <ClaudiusMaximus> gwern: sorry i wasn't explicit
09:41:48 <benmachine> old_sound: oh, hmm
09:41:52 <gwern> ClaudiusMaximus: ah. ok, that's a little different
09:41:52 <old_sound> Cabal-1.8.0.6
09:42:03 <old_sound> I've got that after running ghc-pkg list | grep Cabal
09:42:26 <benmachine> old_sound: do ghc-pkg list Cabal instead, and tell us what the path above it says
09:42:30 <ClaudiusMaximus> i think i'll just put a square in each circle and live with the suboptimality
09:42:38 <gwern> ClaudiusMaximus: maybe you could average the 4 circles radius so they *are* the same radius and then see whether?
09:42:51 <old_sound>    Cabal-1.8.0.6
09:43:11 <old_sound> Sorry
09:43:15 <old_sound>  /Library/Frameworks/GHC.framework/Versions/612/usr/lib/ghc-6.12.3/package.conf.d
09:43:22 <old_sound> and /Users/mrhyde/.ghc/i386-darwin-6.12.3/package.conf.d
09:43:39 <benmachine> old_sound: which one does Cabal appear under?
09:43:50 <old_sound> first one, the long one
09:44:13 <benmachine> ClaudiusMaximus: isn't that optimal, actually?
09:44:31 <benmachine> old_sound: oh ok, that makes sense (and disproves my hypothesis)
09:44:41 <benmachine> old_sound: try ghc-pkg find-module Distribution.Simple.Utils
09:45:10 <ClaudiusMaximus> benmachine: hm, maybe
09:45:12 * enthropy has Distribution.Simple.Utils with that Cabal
09:45:15 <ClaudiusMaximus> benmachine: i'll try it and see
09:45:26 <benmachine> enthropy: me too
09:46:11 <enthropy> ClaudiusMaximus: what's the cost for making a circle larger?
09:46:22 <Jafet> ClaudiusMaximus: take the intersections of the circles, and you have the maximal octagon that can cover the square. Then check if it does.
09:46:25 <enthropy> do you pay for area, radius, something else?
09:46:38 <ClaudiusMaximus> enthropy: neither
09:46:46 <paolino> ClaudiusMaximus: maybe use bisection on the diagonals to find a point outside all circles
09:46:49 <old_sound> benmachine: it says Cabal-1.8.0.6
09:47:06 <old_sound> and is below /Library/Frameworks/GHC.framework/Versions/612/usr/lib/ghc-6.12.3/package.conf.d
09:47:12 <benmachine> old_sound: hmm, ok, so you definitely have that module, but pandoc isn't looking for it for some reason
09:47:30 <benmachine> old_sound: might be worth throwing some -v options at it?
09:47:41 <old_sound> fails the same :(
09:47:42 <ClaudiusMaximus> the context is building a quad tree to cover a fractal, using exterior distance estimates
09:47:46 <Jafet> ClaudiusMaximus: oh, you need to compute intersections in the center of the square too. I'll leave that as an exercise
09:49:15 <ClaudiusMaximus> so i only subdivide quads that contain points of interest - if the square is completely covered by the circles i'll know that it is boring inside
09:52:42 <paolino> ClaudiusMaximus: if there is a point outside the circles it's on the sides or on the diagonals (not proved)
09:54:13 <lars9> 
09:55:53 <enthropy> is it bad advice to ask people to "cabal upgrade haddock"
09:58:33 <benmachine> enthropy: cabal upgrade is bad advice
09:58:49 <benmachine> enthropy: cabal install is nearly always what you want instead
09:58:55 <enthropy> when isn't it?
09:59:30 <benmachine> umm
09:59:40 <benmachine> pass
09:59:52 <benmachine> when you can't be satisfied I suppose :P
09:59:59 <benmachine> cabal upgrade has been outright removed in later versions I think
10:02:14 <enthropy> just wondering about http://www.google.com/search?q=site:haskell.org%2Fhaskellwiki+%22cabal+upgrade%22
10:03:08 <nschoe> Hi all!
10:04:46 <old_sound> benmachine: finally I downloaded cabal and reinstalled it
10:04:50 <old_sound> that fixed the problem, thanks
10:04:58 <benmachine> heh okay
10:05:17 <old_sound> I've need to learn more about this
10:10:31 <old_sound> benmachine: and finally built pandoc ;)
10:26:59 <dRbiG> anyone for some haskell advocacy? i've been reading through the 'real world haskell' and i'm still in doubt whether actually spending time learning it is a good idea... i'm not a fulltime coder, rather a hacker so i have the great advantage i can always choose a language for a task on hand, so the question is where i may find haskell practically better than say ruby, python, tcl, perl or c (these being my current weapons)?
10:27:29 <Twey> dRbiG: Maybe
10:28:37 <Twey> dRbiG: If you're just using it for glue scripts and so on, it's likely that the learning cost will outweigh any benefits you get from it.  Its brevity is nice for these tasks, but you get most of that from Perl/Ruby already.
10:28:40 <ketil> dRbiG: more fun, maybe?
10:29:20 <Twey> dRbiG: If you develop real applications that need to be maintainable and not break, or just want to learn to think about programming a different way, Haskell might be worth your time.
10:29:29 <turiya> is there an easy way to create a list such as [1,1,1,1,1,1,...,1] with n elements?
10:29:36 <Twey> turiya: replicate
10:29:38 <Twey> :t replicate
10:29:39 <lambdabot> forall a. Int -> a -> [a]
10:29:43 <Twey> > replicate 5 1
10:29:44 <lambdabot>   [1,1,1,1,1]
10:29:46 <sciolizer> dRbiG: I would agree, fun is the best reason. (I think it's fun, at least.) What sort of tasks do you typically need to do?
10:29:53 <turiya> oh..cool
10:32:49 <dRbiG> fun? rather a challenge :) most stuff i do falls into the broad category of automisation, like getting stuff from websites, uncompressing, parisng, converting, calculating etc. - from what i understood of the mentioned book it's all about side effects
10:33:34 <sciolizer> uncompressing, parsing, converting, and calculating all sound to me like excellent side effect free things
10:34:05 <sciolizer> but Haskell is still good at side effects too :)
10:34:19 <Eduard_Munteanu> dRbiG: it makes a good experiment to trade a bit of careful coding for loads of time spent debugging.
10:34:58 <dRbiG> sciolizer: so i guess i don't get the concept properly right now... very plausible
10:35:50 <Eduard_Munteanu> It's interesting to see you're head banging not knowing how to write it in Haskell, only to figure out later "wait, that was because I didn't understand the problem properly".
10:36:14 <sciolizer> dRbiG: basically, all of things can be seen as functions with input and output. uncompressing is a just a function which takes a bytestring as input and returns a bytestring, for instance.
10:36:44 <dRbiG> Eduard_Munteanu: that's why i'm always open to new ways of looking at stuff  :)
10:36:51 <sciolizer> dRbiG: excuse me, all of "your" things. (It's true that EVERYTHING can be viewed as a function from input to output, but that's not always the most meaningful encoding. But in your case it is.)
10:36:56 <jmcarthur> dRbiG: more and more i believe that a choice of language is actually best determined by how fun it is to use. that means haskell wins easily :)
10:37:26 <Eduard_Munteanu> dRbiG: yeah. Basically that's my approach too, I think it's useful to study the extremes.
10:37:34 <jmcarthur> dRbiG: but haskell has a bullet point list of advantages we could all list off too
10:37:39 <Eduard_Munteanu> e.g. rather than learn 2 C-like languages, better learn C and Haskell.
10:37:41 <jmcarthur> that's just not fun to read ;)
10:38:17 <Eduard_Munteanu> (I still enjoy writing C code.)
10:38:27 <jmcarthur> i enjoy writing certain kinds of C code
10:38:31 <dRbiG> jmcarthur: fun...okey, but what i seek is doing stuff that works, and works rapidly - thats why ruby and python win in majority of cases
10:38:45 <Eduard_Munteanu> jmcarthur: indeed, that's more accurate. Some things are sucky to write in C.
10:38:50 <dRbiG> as i said i develop for myself or a limited number of users
10:39:09 <jmcarthur> dRbiG: the haskell approach is to take a little more time with your code and achieve a more beautiful result
10:39:21 <nschoe> Hi all^^
10:39:35 <dRbiG> and i wouldn't choose C for anything else than embedded code
10:39:37 <jmcarthur> dRbiG: you can certainly attain rapid development and all that, but it's not why i use it
10:40:04 <n00p> dRbiG: I'd half expect someone from #haskell to choose C# over C for embedded code.
10:40:06 <jmcarthur> dRbiG: coincidentally, haskell has a couple very nice DSLs for hard real time C generation
10:40:26 <Eduard_Munteanu> dRbiG: depending by application, even spending time learning Haskell while you're at it, you might that you solved your problem in just about the same time as if you had done it in the familiar lowlevel language.
10:40:37 <Eduard_Munteanu> Haskell is great for rapid prototyping.
10:40:49 <jmcarthur> i'll half agree with that
10:40:59 <codegenerator> what a wonderful coincidence - I was just interested in C-code generation from Haskell.
10:41:03 <jmcarthur> it very much depends on how hard you are on yourself about good code
10:41:07 <dRbiG> haskell is temtping for me by the way it is so different
10:41:19 <dRbiG> and yes, the fact that it compiles directly is something kind of new
10:41:21 <nschoe> Hi jmcarthur, can I ask you one more thing about the AI thing? (I'm almost done implementing the fuctions you taught me)
10:41:27 <jmcarthur> dRbiG: i recommend learning it. there's at least nothing to lose but some time, but i think it would not be a waste of time :)
10:41:27 <dRbiG> for a high level language for me
10:41:32 <n00p> Eduard_Munteanu: Have you tried C#?
10:41:37 <jmcarthur> nschoe: awesome! sure, ask me anything
10:41:41 <Eduard_Munteanu> n00p: no.
10:42:07 <codegenerator> Can anyone direct me to a good tutorial about generating C from Haskell? I'm studying Tom Hawkins work on Atom etc., but I was wondering if there were some papers or websites discussing this
10:42:08 <n00p> I suggest taking a look at it.
10:42:09 <jmcarthur> nschoe: it occurred to me later that we may have forgotten an action to expose, depending on how the AI is supposed to work
10:42:26 <Eduard_Munteanu> I don't really code in that many languages, though I ocassionally delve into code written in other languages to fix some stuff.
10:42:30 <jmcarthur> nschoe: an action to clean a dirty position
10:42:34 <n00p> There's a functional aspect (using a traditional syntax) and pointers, using the "unsafe" keyword.
10:42:40 <dRbiG> jmcarthur: honestly as i look over my codebase i say it sucks - i'm making progres toward better quality over the years, but still i never really shared my code 
10:42:43 <nschoe> jmcarthur: Thanks^^ I've implemented (I hope sucessfully) the functions, but I'm stuck with the "run" function because I don't really know what it's supposed to do.
10:42:45 <dRbiG> so i have no feedback
10:43:03 <Eduard_Munteanu> n00p: ah. I see many formerly non-functional languages are slowly gaining functional semantics.
10:43:05 <dRbiG> but, the code i did always worked for me
10:43:05 <nschoe> jmcarthur: Yeah you're right, but I don't think it's very hard: just Set.delete.
10:43:06 <dRbiG> :)
10:43:16 <Eduard_Munteanu> Like C++, Python etc.
10:43:41 <Eduard_Munteanu> I'm quite surprised by somethings proposed to be included in C++0x
10:43:52 <Twey> Why?
10:43:58 <jmcarthur> nschoe: the run function is what you use at the top level of your program. the AI gives you something of type Info a, and the run function has to turn that into something you can use externally
10:44:02 <Twey> If C++ sees a feature, it grabs it.
10:44:09 <jmcarthur> nschoe: well, closer to the top level of your program, at least
10:44:11 <Eduard_Munteanu> I'm "oh, this is just like typeclasses", "oh, this is like polymorphism", "oh, this looks like lambdas"
10:44:11 <Twey> Not necessarily very well, but they try.
10:44:14 <dagle> lambda functions in C++0x looks strange iom.
10:44:27 <alpounet> boost.phoenix is way more interesting 
10:44:28 <Eduard_Munteanu> Twey: well, not surprised in a negative way.
10:44:30 <alpounet> than C++0x's lambdas
10:44:45 <jmcarthur> dagle: the issue with lambda in C++0x is that it has to explicitly declare the closure. kind of ugly, but it's in line with the general goals of C++
10:44:59 <nschoe> jmcarthur: hum... I'll post the code  on hpaste, just to be sure I have the right type for run, if you don't mind.
10:45:05 <jmcarthur> sure
10:45:08 <alpounet> jmcarthur, have you seen boost.phoenix ?
10:45:11 <n00p> In my opinion, C and C++ are going to lose popularity in the next 10-15 years.
10:45:18 <jmcarthur> alpounet: i've only heard about it
10:45:20 <Eduard_Munteanu> Mainly, I'm a C coder in my bones. I never got to code/like C++ much.
10:45:24 <n00p> The issue is that they're branching too far away from each other.
10:45:25 <alpounet> you should check that out
10:45:25 <jmcarthur> n00p: they have been already
10:45:25 <turiya> i think something is wrong with the Xlib.Image bindings createImage and putImage (Graphics.X11.Xlib.Image), do i send a bug report?
10:45:28 <aristid> n00p: captain obvious wants you to work for him
10:45:39 * dagle doesn't like c++ at all.
10:45:41 <dRbiG> hmm, i have a feeling that haskell is better for more 'abstract
10:45:46 <dRbiG> ' stuff
10:45:53 <n00p> It most certainly is.
10:45:59 <alpounet> C++ is in between
10:45:59 <kw317> C and C++ are not going anywhere
10:46:02 <dagle> I have seen compiler blow up a 20mb binary to 200mb and then optimize it.
10:46:06 <Eduard_Munteanu> dRbiG: rather it's good for abstracting a problem, then solving for the abstraction.
10:46:12 <kw317> Too much has been written
10:46:13 <aristid> kw317: and you too, should work for captain obvious
10:46:15 <jmcarthur> dRbiG: you can write haskell code that is as abstract or as low level as you want, really
10:46:19 <Eduard_Munteanu> dRbiG: which yields more general solutions.
10:46:34 <Eduard_Munteanu> And lotsa reusable code.
10:46:36 <jmcarthur> dRbiG: the haskell FFI even allows you to essentially write C in haskell, even (including pointer manipulation, etc.)
10:46:42 <kw317> And we still can't match performance
10:46:43 <jmcarthur> just a different syntax, of course
10:46:45 <alpounet> you can do that in C++ too
10:46:48 <alpounet> it's just harder
10:46:51 <alpounet> and longer
10:46:52 <alpounet> heh
10:46:52 <dRbiG> right now i have a need for a piece of code that would take a set of .pdf files, try it's best to extract some string and putt them in a certain way in an .xls file
10:47:13 <Eduard_Munteanu> kw317: indeed, for some things, I still doubt Haskell is the answer.
10:47:27 <dRbiG> i'm going to tacle it with ruby, but i'm saying that as to show what kind of stuff i usually deal with
10:47:28 <Eduard_Munteanu> I'm not particularly delighted by the way House, for example, does it.
10:47:29 <nschoe> jmcarthur: here I am : http://hpaste.org/40991/ai_basics
10:48:07 <jmcarthur> dRbiG: that doesn't sound like an unreasonable task for haskell either, but perhaps a less engineered solution in a scripting language would still be more appropriate
10:48:11 <Eduard_Munteanu> Haskell is too much dependent on a vm-like abstraction.
10:48:42 <dark> vm-like?
10:48:47 <jmcarthur> nschoe: "Info ∅" <-- does that do what i think it does?
10:48:59 <jmcarthur> nschoe: or is that just some sugar that your editor adds in?
10:49:03 <Eduard_Munteanu> dark: the way it handles IO, garbage collection etc.
10:49:10 <nschoe> jmcarthur: sorry it's because of some plugin in emcas, it's just Info () yeah.
10:49:15 <jmcarthur> okay
10:49:42 <Eduard_Munteanu> I wish there was some sort of region inference Haskell compiler that could be used for low-level stuff.
10:49:52 <dRbiG> jmcarthur: that's basically what i thought
10:49:53 <dark> most "new" languages depends on a GC
10:50:06 <EvanR> gc just makes sense
10:50:20 <EvanR> reference counting doesnt
10:50:34 <Eduard_Munteanu> That makes it less suitable for some applications.
10:51:02 <jmcarthur> nschoe: okay, my first thought is that since you are using those type aliases in the type signatures of your exposed functions you will want to expose those type aliases too
10:51:23 <Eduard_Munteanu> And it's basically chicken and egg, you'd have to write some basic runtime whenever you're putting it in a low-level/RT/embedded environment.
10:51:24 <jmcarthur> nschoe: the run function's type signature looks alright to me if all you want is a plain jan unwrapper run function
10:51:29 <jmcarthur> *plain jane
10:51:33 <Eduard_Munteanu> *basic runtime in some other language
10:51:42 <EvanR> on going research into various kinds of gc like low memory, low latency, concurrency
10:52:31 <jmcarthur> nschoe: basically what you need to do to write that function is use the runReaderT and runState functions to unwrap those transformers for you
10:52:38 <nschoe> jmcarthur: okay, thx for exposing the aliases, looks logical (just forgot that^^). you said "if you want..." (for the run function), does that mean there is another alternative?
10:52:41 <jmcarthur> *unwrap that transformer stack for you
10:52:56 <jmcarthur> nschoe: how would *you* like to use it?
10:53:13 <Eduard_Munteanu> EvanR: well, GC is all good but RT GCs are still not here. Also embedding a Haskell runtime in an OS kernel still won't be an option for some time.
10:53:32 <nschoe> jmcarthur: Well, I'm sorry I really don't get the thing. So I don't know.
10:53:35 <EvanR> maybe you wouldnt want haskell in an os kernel
10:53:43 <aristid> also, haskell is not very good for HTTP connections over SSL :>
10:53:45 <dRbiG> Eduard_Munteanu: for me low-level embedded is pic 8 and 16 bit and alike - C is perfect here
10:53:52 <jmcarthur> nschoe: heh, okay. give me a sec and i'll try to come up with with a reasonable explanation for what i mean
10:53:54 <nschoe> jmcarthur: For instance, should I "loop" in that run function, or is it that run function that I will call indefinitely?
10:53:54 <Eduard_Munteanu> EvanR: indeed, that could be an answer.
10:54:04 <n00p> aristid: Why is that?
10:54:06 <jmcarthur> nschoe: it's your choice
10:54:11 <Eduard_Munteanu> dRbiG: it is.
10:54:23 <aristid> n00p: because there are no good libraries for it. there are some, but they're not nice to use
10:54:25 <Eduard_Munteanu> For kernels, plumbing is what they are.
10:54:30 <nschoe> jmcarthur: Okay no problem, I can wait if you're busy, there's no urgence^^
10:54:40 <n00p> aristid: The same is to be said of any language, unfortunately.
10:54:46 <Eduard_Munteanu> Abstract plumbing and it's not anymore a kernel.
10:54:59 <aristid> n00p: dunno, maybe in, say, python there are better libs for that
10:55:21 <n00p> aristid: They may have a nice interface, but if you study their inner workings...
10:55:33 <dagle> Eduard_Munteanu: NetBSD have lua in it's kernel in git. :)
10:55:38 <n00p> Things start to become obscure
10:55:43 <dRbiG> libs are the key for automation
10:55:46 <dagle> Or cvs I mean.
10:55:59 <n00p> It's almost like an old-fashioned Microsoft is in charge of SSL.
10:56:11 <Eduard_Munteanu> dagle: interesting. There's also some lib to write Linux kernel modules in Haskell. But you'll get a good flame if you ever post a patch like that on vger :)
10:56:18 <dRbiG> hmm, anyone here had some lisp experience?
10:56:44 <alpounet> aristid, so, how is it going ?
10:56:45 <Eduard_Munteanu> dRbiG: Lisp indeed receives some warmth in here.
10:56:55 <alpounet> do you manage to get some work done out of curl ?
10:57:22 <jmcarthur> nschoe: sorry, i'm just trying to transfer some photos to clear up a memory card and i haven't set all this stuff up in a while ^_^
10:57:39 * Eduard_Munteanu imagines a type-level SLAB allocator posted on LKML :P
10:57:47 <jmcarthur> gotta go out shortly and practice with a lens i rented so i can do my best to take my sister's engagement photos tomorrow
10:58:18 <aristid> Eduard_Munteanu: you have to be called Oleg to do that
10:58:44 <nschoe> jmcarthur: take your time. We can postpone to another day if you prefer.
10:58:50 <Eduard_Munteanu> aristid: he probably already did it :P
11:00:01 <dRbiG> Eduard_Munteanu: haskell is for me in the same category as lisp - different, valuable, but rather unsuited for what i do usually - i've been thinking earlier about lisp too but never actually write anything in it. 
11:00:38 <dagle> lisp / scheme have some features that are cool but in the end makes it inpure.
11:00:39 <jmcarthur> nschoe: okay, the run function is what will "drive" Info, essentially
11:00:40 <Twey> dRbiG: CL is probably quite well-suited for… whatever it is you do.
11:00:54 <Eduard_Munteanu> dRbiG: I think suitability depends a lot on available libs/bindings/interfaces.
11:01:08 <jmcarthur> nschoe: it may be interesting to note that while Info is your abstraction as the AI sees it, the run function is actually what determines the architecture
11:01:43 <dRbiG> Eduard_Munteanu: agreed, i long ago learned that reinventing the weel is usually a bad idea
11:01:54 <Eduard_Munteanu> No point in coding something in an obscure language that can't even open a window.
11:02:24 <nschoe> nschoe: okay... I'd like the run function not to loop by itself, I'd like the run function to somehow represent "one step" of the AI decisions.
11:02:53 <ulfdoz> reinventing the wheel is imho a good excercise, but not necessarily something leading to a useful result.
11:03:17 <jmcarthur> nschoe: okay, if you want to be able to observe each step, you may want to stick IO or something underneath your transformer stack
11:03:27 <Eduard_Munteanu> nschoe: talking to yourself? :D
11:03:30 <nschoe> It's already stacked.
11:03:35 <nschoe> Eduard_Munteanu: yeah sorry, ^^
11:03:47 <jmcarthur> nschoe: there's another way (monad prompt) but it's maybe a little more over your head
11:03:54 <dRbiG> as for obscurity, i guess that tcl may be considered obscure - but i still have a bunch of scripts in it that i really wouldn't like to translate to anything else
11:04:04 <jmcarthur> nschoe: monad prompt would allow you to step over it "from the outside" like you want though
11:04:12 <jmcarthur> basically like an interpreter
11:04:30 <EvanR> tcl is good for quick guis
11:04:41 <megajosh2> tcl is so ugly
11:04:42 <EvanR> widely available
11:04:58 <jmcarthur> nschoe: oh i just noticed something about your module that i don't like :)
11:05:01 <dRbiG> with pragmatic approach the only thing that matters is whether you can solve the problem on time - which basically takes out some possibilities like java
11:05:01 <nschoe> jmcarthur: Well the thing is: I'm not familiar with that at all (never heard of actually) and I don't want to consume too much of your time so, maybe we could stick to the "normal" way first?
11:05:05 <EvanR> dont get caught up in syntax
11:05:09 <jmcarthur> nschoe: you derived instances of MonadReader and MonadState for Info
11:05:17 <jmcarthur> nschoe: that exposes the implementation
11:05:22 <nschoe> jmcarthur: Well I took that from RWH, yeah.
11:05:35 <dRbiG> EvanR: yes, extacly, quick guis making life so much easier
11:05:35 <jmcarthur> nschoe: and it gives AI access to e.g. the positions of dirty positions
11:05:45 <megajosh2> @src ask
11:05:45 <lambdabot> Source not found. Maybe you made a typo?
11:05:55 <jmcarthur> nschoe: deriving Monad is fine
11:06:09 <jmcarthur> nschoe: but some of those other instances break the abstraction
11:06:12 <nschoe> jmcarthur: So you mean I should make Info an instance of MonadReader by hand?
11:06:18 <jmcarthur> no
11:06:19 <dRbiG> megajosh2: beauty is always subjective and for problem solving it's not realy neccesary :)
11:06:24 <jmcarthur> i mean it should not be an instance of MonadReader
11:06:27 <benmachine> jmcarthur: wouldn't Writer be sufficient if all you want to do is observe the steps?
11:06:33 <dagle> I did my AI project in matlab. :( :( :(
11:06:41 <EvanR> dRbiG: on the other hand a command may be faster to access
11:06:44 <jmcarthur> benmachine: it really just depends on a lot of things
11:06:49 <EvanR> and more configurable on the spot
11:06:53 <jmcarthur> benmachine: i guess you are right
11:06:59 <jmcarthur> for mere observation, a Writer would be fine
11:07:46 <jmcarthur> nschoe: do you understand why i'm saying it shouldn't be an instance MonadReader?
11:07:57 <jmcarthur> or MonadState or, arguably, MonadIO?
11:09:05 <nschoe> jmcarthur: SOrry to disapoint but no. But it's because I didn't really understand why I needed to put them in the first place. I just read the error messages from ghci, then I checked with RWH and I saw that's what htey did.
11:09:16 <jmcarthur> nschoe: oh i see
11:09:39 <jmcarthur> nschoe: okay, the reason ghc complained is because you were using Info as though it exposed that information
11:09:48 <jmcarthur> i'll rewrite one of your functions to show what i mean
11:10:12 <nschoe> Okay.
11:10:56 <jmcarthur> nschoe: http://hpaste.org/paste/40991/example_of_wrapping_so_you_don#p40993
11:11:06 <jmcarthur> nschoe: notice how i wrapped the entire thing in Info there
11:11:19 <jmcarthur> nschoe: that means i'm using the transformer stack in the raw rather than Info itself
11:12:32 <benmachine> > isSymbol '¬'
11:12:33 <lambdabot>   True
11:13:06 <jmcarthur> nschoe: if all the actions were written in that way, you could eliminate those instances that you don't want to expose
11:13:09 <nschoe> benmachine: just my emacs eye-candy for "not" function./
11:13:41 <benmachine> nschoe: oh right.
11:14:05 <benmachine> > let (¬) = (not .) in isSymbol ¬ '¬'
11:14:06 <lambdabot>   False
11:14:19 <nschoe> jmcarthur: Hum okay. but in how I wrote them, how does GHC know in what context "return" should put the result it?
11:14:23 <nschoe> in*
11:15:26 <benmachine> nschoe: the Monad instance determines it - there is actually only one Monad in play
11:15:45 <benmachine> so return :: a → ReaderT (DirtyPositions, Walls) (StateT Position IO) a
11:18:02 <nschoe> benmachine: So it's because I derived the instance, right?
11:18:13 <dRbiG> oh, and btw. am i right guessing that a native code that ghc generates is actually some kind of interpreter + byte code of ours sorce file?
11:18:34 <Nibble> dRbiG: no
11:18:36 <Nibble> magic
11:19:05 <benmachine> nschoe: oh wait, hold on
11:19:15 <benmachine> in how you wrote them, yes, it's because you defined the instance
11:19:22 <benmachine> derived
11:19:24 <nschoe> derived*
11:19:25 <benmachine> so return :: a → Info a
11:20:12 <nschoe> Okay. So what jmcarthur is telling me, is rather to write the functions in the same way he did?
11:20:36 <benmachine> nschoe: if you do that, then only you will be able to ask/get/put
11:20:55 <benmachine> if you do that and hide the Info constructor, I mean
11:21:08 <nschoe> benmachine: and that's what's usually done, right?
11:21:12 <benmachine> people using your library will be able to get what information you give them and no more
11:21:33 <benmachine> nschoe: it depends on your use case - sometimes hiding implementation details is a good thing, sometimes it's not necessary
11:21:35 <dRbiG> Nibble: is that irony? (no matter how stuipd the question might be i'd be happy with a straightforward answer)
11:22:06 <benmachine> dRbiG: why do you think ghc generates bytecode?
11:22:12 <jmcarthur> nschoe: since the intended "client" of this API is the AI it makes sense to only expose what the AI should be able to access
11:22:36 <jmcarthur> since you are writing the AI yourself you could just practice discipline and all
11:22:51 <jmcarthur> but my personal preference would be to have a simplified API
11:22:51 <benmachine> dRbiG: there was a time when ghc generated C code and let gcc compile it, nowadays it cuts out the middleman and generates executables directly
11:23:20 <nschoe> jmcarthur: okay so: I don't use the deriving clause, and re-write the functions in the same way you did. But Do i need to wrtie something like instance MonadReader (Info a) where... ?
11:23:23 <benmachine> dRbiG: does that answer your question?
11:23:35 <benmachine> dRbiG: ghci is a bytecode interpreter though
11:23:42 <benmachine> so both options are available
11:24:16 <benmachine> nschoe: no, the point is to have no MonadReader instance, so people can't use ask unless you let them
11:25:35 <dRbiG> benmachine: what i really mean asking that is whether ghc generates the code that is extacly what my 'script' (the source code) does - that is if only the stuff that is actually needed to run my script is being compiled
11:25:53 <nschoe> benmachine: okay thanks (sorry guys, I'm a slow leaner^^)
11:26:24 <benmachine> dRbiG: I don't exactly understand, what else would be compiled?
11:26:49 <benmachine> nschoe: haskell can be slow to learn sometimes, don't worry about it
11:27:44 <dRbiG> benmachine: like i use a function from some big module that really has no dependencies - what i would like to is to have only that function in code, not the whole module
11:28:03 <dRbiG> thing that can be tricky when trying to wrap an exectuable for a ruby script for example
11:28:08 <benmachine> dRbiG: presumably that function will call other functions
11:28:22 <benmachine> dRbiG: you will need to compile whole modules at a time, I think
11:28:27 <dRbiG> benmachine: yes, but almost certainly not all from that module
11:28:37 <benmachine> dRbiG: which is why it's good style to write small modules
11:28:58 <sipa> the idea of modules is exactly to divide the code and the task of compilation into separatable pieces
11:29:20 <sipa> so that you do not need to compile all the code from all libraries that you use every time
11:29:43 <sipa> the disadvantage is of course the you will link all code from every library that you use
11:29:53 <dRbiG> benmachine: this is the classic dependency hell issue - like i use a urlparse function form a http lib that does only split an url into parts and along the way i end up with the whole http lib being part of the executable
11:29:53 * jmcarthur personally thinks that the idea of modules and compilation units can benefit from separate treatment
11:29:57 <dRbiG> or a dependency
11:30:01 <dRbiG> which sucks either way
11:33:23 <benmachine> dRbiG: well, the solution is to make smaller libraries
11:33:53 <benmachine> dRbiG: actually chasing all the dependencies of all the functions, given that some might be inlined, some might be subject to rewrite rules, some might be generated at compile-time
11:34:09 <benmachine> dRbiG: it sounds like a giant mess
11:34:11 <dRbiG> benmachine: other aspect to my question was that i can make ruby or tcl an 'executable' buy a wrapper that is actually embedding proper interpreter and preloading all libs/packages before loading my sciprt
11:34:30 <sipa> buy or by?
11:34:41 <dRbiG> s/buy/by/
11:34:42 <benmachine> dRbiG: GHC doesn't interpret like that
11:35:37 <dRbiG> benmachine: o'right, to it's much closer to a real exec than ruby/tcl wrapping
11:35:46 <dRbiG> so*
11:35:47 <dRbiG> ehh :)
11:35:53 <sipa> it *is* a real executable
11:37:24 <dRbiG> sipa: and what about dynamic linking? does it link to anything outside the standard libs for that platform?
11:37:42 <Eduard_Munteanu> I think it does static linking by default.
11:38:12 <Eduard_Munteanu> Though it can be disabled, giving you a dynamically linked executable.
11:38:22 <dRbiG> so if i compile an exec on my win laptop i should be able to run that exec on any other windows pc
11:38:53 <Eduard_Munteanu> Never actually tried. :/
11:40:14 <dRbiG> static linking would be great for me, especially for windows 
11:40:28 <Eduard_Munteanu> jmcarthur: indeed, I could cite inlining semantics.
11:40:34 <dRbiG> it would be a practical pro for learing haskell
11:41:14 <Eduard_Munteanu> Cross-file inlining is a problem in C as well.
11:41:26 <Eduard_Munteanu> Since there it's separated as well.
11:43:21 <ddarius> See -split-objs on http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/options-phases.html#options-linker
11:44:09 <dRbiG> well, not writing everything you need purely in the language you use always makes some dependency 'problems'. being able to put all needed stuff in easy package that should work in 90% or more of cases is really practical
11:53:22 <dRbiG> anyway thanks for the input, i guess i'll hang around and probably attempt to do something in haskell :) even for the fun of it :)
12:01:20 <sphericalchicken> Has anyone here tried to use the FFI together with parallel constructs?  I'm having performance troubles due to what looks like lots of GC pauses.
12:01:48 <joeyh> I wrote a program that uses try :: IO SomeException but it seems old versions of ghc don't support that. Is there any way to write exception catching code that will work with current ghc but also 6.8?
12:02:12 <osaunders> Do people actually use the Product and Sum monoid instances?
12:02:22 <EvanR> doubt it
12:02:37 <EvanR> + and * already work fine for usual casese
12:02:44 <osaunders> Yeah, that's what I was thinking.
12:02:59 <enthropy> when you use Writer
12:03:10 <EvanR> i cant think of numeric code that needs to be generic over addition or multiplication
12:03:25 <osaunders> @hoogle Writer
12:03:25 <lambdabot> module Control.Monad.Writer
12:03:25 <lambdabot> Control.Monad.Writer.Lazy newtype Writer w a
12:03:25 <lambdabot> Control.Monad.Writer.Lazy Writer :: (a, w) -> Writer w a
12:03:25 <EvanR> of course that doesnt mean much
12:06:00 <ddarius> :t fold
12:06:01 <lambdabot> Not in scope: `fold'
12:06:10 <ddarius> :t Data.Foldable.fold
12:06:11 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
12:06:50 <joeyh> oh, I found a rune that uses #if to test ghc version and type SomeException = Exception
12:09:38 <enthropy> @hackage extensible-exceptions <-- joeyh
12:09:38 <lambdabot> http://hackage.haskell.org/package/extensible-exceptions <-- joeyh
12:11:10 <ClaudiusMaximus> gwern, benmachine, paolino, enthropy, Jafet: in case you're curious, using squares inside the corner circles to test if the whole square is covered seems to work out well enough: http://claudiusmaximus.goto10.org/g/mandelbrot/distance-estimate-grid.png
12:13:23 <ClaudiusMaximus> i put the code here too: http://hpaste.org/40994/mandelbrot_set_distance_estima
12:13:39 <joeyh> so is there any reason someone would want to use Control.Exception rather than Control.Exception.Extensible?
12:13:49 <joeyh> this seems an odd gotcha to leave lying around
12:14:23 <sipa> ClaudiusMaximus: my test would be to see that each circle overlaps with each other circle
12:14:31 <sipa> or at least touches
12:15:03 <sipa> not sure if that's strong enough, actually
12:16:13 <enthropy> joeyh: if you have other reasons to not keep compatibility with 6.8
12:16:42 <enthropy> the shorter module name and no need for an additional package is appealing
12:17:05 <ClaudiusMaximus> sipa: well, if each edge is covered by two squares, the square will surely be covered by the circles
12:17:26 <joeyh> the package is part of ghc though
12:19:52 <gwern> ClaudiusMaximus: that seems kind of lame. surely there's an exact and relatively simple answer
12:23:33 <HairyDude> Hayoo seems to be down?
12:24:02 <blut> http://pastebin.com/W984KLsR gives me a error: http://pastebin.com/2CuUKF8S
12:24:08 <blut> any idea why?
12:25:06 <sipa> "Home page" is a string, where something of type Html is expected
12:25:59 <blut> hmm
12:26:17 <blut> i found that snipset on the tutorial
12:27:42 <c_wraith> blut: probably for an older version of yesod.  It's been updated many times recently
12:28:21 <blut> so how would i write it now?
12:37:38 <sshc> Why isnt OOHaskell in Hackage??
12:38:00 <sshc> -?
12:43:03 <Saizan> sshc: why would it be?
12:47:51 <sciolizer> sshc: I agree. We need a library that renames data to class, class to interface, and instance to implements. :)
12:48:10 * Veinor has been annoyed by namespace collisions
12:50:09 <enthropy> sshc: the library part is more or less HList?
12:51:25 <sipa> sciolizer: but what do you do with type and newtype, those are so confusing!
12:54:17 <sciolizer> sipa: clearly type should be renamed to #define
12:57:06 <sshc> Saizan: It's a library that could be used?
12:57:39 <sipa> but not a haskell package
12:58:16 <alpounet> sipa, confused with type/newtype ?
12:58:17 <Saizan> sshc: even oleg considered it nothing more than a proof of concept or at best a tool to explore features for OO languages
12:58:23 <sipa> alpounet: no i was joking
12:58:35 <alpounet> oh
12:58:42 <alpounet> was about to fire the haskellwiki page about that
12:59:23 <Saizan> sshc: but i guess creations can go beyond what's expected by their authors..
13:00:18 <sshc> enthropy: HList?
13:00:20 <tmo_> I want to declare a type that roughly does this:
13:00:35 <tmo_> data Type = Con (Num, Num, Char)
13:00:50 <alpounet> heterogeneous lists
13:00:57 <Saizan> Num is not a type
13:01:07 <tmo_> How do I get the same effect?
13:01:22 <enthropy> sshc: you tend to need better records to do OO
13:01:33 <sipa> data Num a => Con a a Char
13:01:48 <Saizan> tmo_: you could either decide early which instance of Num you want or parametrize Type over it
13:02:02 <benmachine> sipa: noooo not datatype contexts
13:02:06 <sipa> ok ok
13:02:12 <Saizan> tmo_: the latter case would look like "data Type a = Con a a Char"
13:02:12 <sipa> data a = Con a a Char
13:02:31 <Saizan> sipa: you keep missing the type name :)
13:02:38 <sipa> bah
13:02:56 <tmo_> Okay, I'll try that.
13:03:03 <sipa> i'm used to having a compilar complain about that immediately :)
13:03:03 <Martty> where is the Num constraint
13:03:06 <sipa> *compiler
13:03:39 <Saizan> Martty: the Num constraint is best left to the functions that will need it when using Type 
13:03:54 <Martty> but im sure you can specify it in the data decl..
13:04:28 <Martty> RIGHT?
13:04:29 <Saizan> in haskell10 you can write "data Num a => Type a = .." but that's essentially deprecated
13:04:29 <BluShift> Hey all, I'm familiar with a few "traditional" languages (procedural, OO) and I'm having trouble wrapping my head around the structure of Haskell code. I've read the "Learn Haskell in 5 steps", "Learn Haskell in 10 minutes", and a large portion of the definition of an "action". Help?
13:04:43 <Martty> alright
13:04:44 <Saizan> it will probably be removed in haskell2011
13:04:58 <alpounet> BluShift:
13:05:02 <alpounet> @where lyah
13:05:02 <lambdabot> http://www.learnyouahaskell.com/
13:05:22 <Saizan> BluShift: it isn't going to take 5 steps nor 10 minutes.
13:05:23 <BluShift> alpounet: Thanks :)
13:05:37 <Martty> its gonna take more like 1 year or 2
13:05:39 <Eduard_Munteanu> Saizan: why?
13:06:15 <tmo_> I'm wonder that too. data Num a => Type a seems like a very useful idiom.
13:06:20 <tmo_> *wondering
13:06:24 <alpounet> conceptually
13:06:26 <Eduard_Munteanu> BluShift: I'm not sure I get your question, perhaps you can be a bit more specific?
13:06:27 <BluShift> Saizan: Oh, I know. But I feel like I can't learn anything in my current understanding... but I was off the ground in that amount of time with C, Java, and Python. That's all :P
13:06:36 <alpounet> it's more logical to keep the constraint in the *functions*
13:07:03 <alpounet> where do you actually need to specify that this type must be an instance of Num ?
13:07:09 <alpounet> where you'll use +, * etc.
13:07:15 <alpounet> that is, in the functions using your type
13:07:46 <Saizan> BluShift, Eduard_Munteanu: haskell is genuinely different from that sort of languages, so it takes an effort comparable with understanding programming from scratch in some aspects.
13:07:49 <Veinor> BluShift: it helps that C, Java, and Python are all vaguely similar
13:08:20 <BluShift> Eduard_Munteanu: I understand it's a very "different" way of looking at programming, which is why I'm so interested in it, but learning the 30,000-foot view of how Haskell code is organized (like, the idea of only 1 IO action, for example) is proving difficult because I've always understood programming to be very procedural.
13:08:22 <alpounet> BluShift, you'll see, Learn You A Haskell is a great ressource for learning Haskell
13:08:35 <BluShift> Veinor: I know. That's why I'm so interested in Haskell :)
13:08:37 <alpounet> however you'll definitely have to spend some effort there
13:08:38 <Eduard_Munteanu> Saizan: ah, I wondered about your data syntax statement.
13:08:42 <Veinor> :D
13:08:59 <shachaf> BluShift: You should probably not focus on IO at first -- it doesn't really help.
13:09:27 <BluShift> shachaf: That's how we know that our program is doing what we want it to, no?
13:09:47 <shachaf> BluShift: You can test it with ghci.
13:10:07 <Eduard_Munteanu> alpounet: surely, but since there are cases where you really need a forall and constraint in the data (e.g. existential), I'd say it's not that bad to allow this case.
13:10:15 <Eduard_Munteanu> alpounet: just saves some typing everytime.
13:10:21 <Saizan> Eduard_Munteanu: ah, ok, that's because that declaration will only annoyingly constrain the type of the constructor, while not providing the Num context when you pattern match on a Type
13:10:22 <BluShift> I think that's part of my problem -- I don't really understand how it works.
13:10:24 <shachaf> BluShift: Alternatively, you're allowed a "main = print MYVALUE" at the end of your program, but that should be sufficient. :-)
13:10:37 <alpounet> Eduard_Munteanu, yeah, sure, but I guess they deprecated it because of the bad uses
13:10:43 <Veinor> ghci is invaluable for testing
13:10:44 <Saizan> Eduard_Munteanu: so it won't even save typing.
13:11:00 <Veinor> especially considering that you can tab-complete
13:11:01 <Eduard_Munteanu> Ah, so it works only on the constructor.
13:11:03 <shachaf> BluShift: IO is tempting because it lets you write "real-world" programs, which is why some introductions focus on it immediately, but I think that causes more confusion than it's worth.
13:11:08 <BluShift> It doesn't appear to create a visible executable that I can just "run". It opens in GHC (I think) and then I have to type "main <enter>" and it works :/
13:11:19 <BluShift> shachaf: Yeah?
13:11:19 <shachaf> BluShift: No, you type other expressions in ghci.
13:11:26 <Eduard_Munteanu> Then it makes sense to either extend it or remove it.
13:11:39 <BluShift> shachaf: How are executables created, then?
13:11:45 <alpounet> BluShift, you have a "normal" compiler, which creates executables
13:11:45 <shachaf> BluShift: ghc
13:11:47 <alpounet> ghc
13:11:51 <alpounet> but aside from that
13:11:57 <mjo`> Essentially, ghci lets you test your functions without having to write a program that uses them, compile it, and run it.
13:12:01 <Veinor> ghc --make
13:12:14 <alpounet> you have ghci, which lets you load some of your code and test it right in your terminal
13:12:15 <Eduard_Munteanu> BluShift: you can use ghc --make test.hs, for example
13:12:21 <BluShift> Ohh ok.
13:12:22 <shachaf> BluShift: For instance, several of the common introductions that start with IO might lead you to think that monads or the "do" keyword are about "impure" or "imperative" programming.
13:12:29 <alpounet> for example, if you have 'mySort' which takes a list and sorts it
13:12:32 <Saizan> BluShift: have you ever used the python repl?
13:12:33 <BluShift> Hah, consequently that's exactly what my first "program" was called :)
13:12:47 <alpounet> you can just fire ghci, load your code and try to do 'mySort [1,3,2]'
13:12:58 <BluShift> python repl?
13:13:03 <Eduard_Munteanu> There's also runhaskell.
13:13:10 <shachaf> BluShift: Without the Python bit.
13:13:17 <shachaf> BluShift: Python didn't invent REPLs, you know. :-)
13:13:18 <Eduard_Munteanu> So you can write a file that starts like #/usr/bin/runhaskell
13:13:18 <alpounet> BluShift, yeah, it's used the same way
13:13:23 <Saizan> BluShift: or shell, the thing that comes up when you run "python" without any arguments
13:13:25 <mjo`> REPL == read, eval, print loop. "Interactive shell" or whatever you want to call it.
13:13:29 <shachaf> (That would be LISP.)
13:13:29 <Veinor> BluShift: one thing is that ghci is in the IO monad
13:13:31 <Eduard_Munteanu> and execute it as a script, just like if it were a bash script
13:13:39 <Veinor> so you can't say 'x = 2', you have to do 'let x = 2'
13:13:40 <BluShift> Oh, IDLE. Yes, I have.
13:14:02 <Eduard_Munteanu> Err... #!/usr/bin/runhaskell
13:14:03 <shachaf> Oh, I misseed a message there. Never mind.
13:14:15 <Saizan> BluShift: no, not that
13:14:24 <alpounet> BluShift, anyway, you really should start reading Learn You A Haskell now
13:14:29 <BluShift> Veinor: Oh. That's why you can run "Hello, world!" and have it print that immediately?
13:14:48 <shachaf> BluShift: IDLE is a specific GUI front-end to the Python REPL. What OS are you using, by the way? Do you have a command prompt? :-)
13:14:54 <BluShift> Saizan: Oh, when it's run on the command line.
13:15:06 <alpounet> yes
13:15:08 <Veinor> BluShift: that's why if you run 'putStrLn "Hello World"' it'll actually print it
13:15:09 <Saizan> BluShift: yep, ghci is just that sort of thing, but for haskell
13:15:16 <maltem> Saizan, looks like that IDLE thing includes a REPL
13:15:21 <BluShift> Saizan: I've used it as a calculator on machines without a graphical front-end :)
13:15:32 <Saizan> maltem: i've looked closer and yeah
13:15:51 <BluShift> Alright, off to read LYAH.
13:15:52 <Veinor> it doesn't have tab-completion though
13:16:04 <BluShift> Thanks for the assistance :)
13:16:14 <shachaf> Veinor: As far as REPLs go, have you seen bpython?
13:16:22 <Veinor> nope
13:16:29 * shachaf has been writing some Python recently, and it's pretty nice.
13:16:44 <maltem> BluShift, I use it as a calculator at work, where the alternative would be calc.exe ^^
13:16:55 <Veinor> shachaf: it's a fun language
13:16:56 <BluShift> maltem: :P
13:17:12 <Veinor> it's my go-to 'hey, I need a quick script to do this' where 'this' doesn't comprise mostly text processing
13:17:20 <shachaf> (Except that it's Python, of course. :-) I'm also trying to simulate multiline lambdas with the "with" keyword, which only kind of works.)
13:17:28 <BluShift> Veinor: shachaf: It's my go-to, when I'm not contrained by an assignment or anything :)
13:17:43 <shachaf> Veinor: Not enough FP for my taste. I prefer Ruby for things like that. :-)
13:17:57 <BluShift> Veinor: Yes, exactly.
13:18:17 <basvandijk> Anyone aware that the glasgow-haskell-users@haskell.org mailinglist server has: "no space left on device"
13:18:31 <shachaf> Veinor: (I meant *bpython* was pretty nice, by the way, not Python the language. Not that it's horrible but it's just generally annoying.)
13:18:37 <alpounet> you should report that to #ghc basvandijk 
13:18:49 <basvandijk> alpounet: will do
13:18:51 <alpounet> less noise
13:18:54 <BluShift> So, befor I start getting too far into lyah, what is haskell "best at"? Obviously it's capable of everything, but... why is it most expressive with?
13:19:13 <BluShift> So I know what I'm getting into :P
13:19:20 <alpounet> BluShift, http://www.haskell.org/haskellwiki/Introduction
13:19:29 <mjo`> it's good at math and computer science problems =)
13:19:34 <FunctorSalad_> best at having a good type system? ;) if that counts
13:19:35 <sipa> basvandijk: were you accidentaly in AFP/TFP in nijmegen 2 years ago?
13:19:43 <Veinor> shachaf: ahh.
13:20:00 <basvandijk> sipa: yes I was
13:20:01 <Saizan> the historical strong point is symbolic manipulation especially in the realm of compilers/interpreters/..
13:20:09 <FunctorSalad_> mjo`: I don't see why it'd be particularly good for math
13:20:19 <sipa> basvandijk: then i think i know you :)
13:20:31 <BluShift> So, if I don't have a confortable grasp of lambda calculus, will it still be useful to me?
13:20:35 <FunctorSalad_> (it is *itself* relatively mathematically flavoured, sure. but good *at* doing math?)
13:20:36 <BluShift> comfortable*
13:20:41 <basvandijk> sipa: What is your real name?
13:20:44 <sipa> pieter
13:20:48 <Saizan> but that might be more a byproduct of the early users :)
13:20:49 <sipa> i'm from belgium
13:20:51 <jedai> good symbolic manipulation and a flexible syntax makes it a quite good EDSL environment
13:20:51 <mjo`> As in, I can write the peano axioms and then execute them.
13:21:13 <basvandijk> sipa: ah right, I remember. How are you doing?
13:21:18 <sipa> i'm fine
13:21:21 <sipa> how are you?
13:21:24 <Saizan> BluShift: sure
13:21:25 <basvandijk> Are you coming to BelHac?
13:21:52 <sipa> yes, i think so - i should still register though
13:22:24 <BluShift> Saizan: I'm a college student -- I'm interested in mathematics (incredibly interested) but by trade I'm an IT person, so I'm not exactly qualified to do "computer science problems"
13:22:32 <mjo`> It's also easy to translate back and forth between pure proofs and code examples, since the language matches up pretty nicely.
13:22:32 <jedai> BluShift: no problem, lambda calculus isn't that hard anyway, you'll probably understand it better if you see it after some work in Haskell though
13:22:35 <Saizan> BluShift: assuming you can get more and more comfortable with first-class functions :)
13:23:05 <osaunders> What should I use if I want the type homogeny of lists and the fixed length-ness of tuples?
13:23:16 <basvandijk> sipa: I hope to see you then, I remember we had some good laughs at AFP.
13:23:21 <jedai> BluShift: Basically the only hard concept of lambda calculus is the first-class functions
13:23:52 <BluShift> jedai: The most advanced math course I've taken is grade 12 precalculus :) I think you over-estimate my understanding of these things :P
13:24:23 <alpounet> first class functions basically means that you can return functions, pass functions to other functions, store functions
13:24:41 <jedai> BluShift: No really, lambda calculus isn't hard, it's more making something interesting with it that is, since it's extremely minimalist, Haskell don't have that problem
13:24:42 <BluShift> Yeah.
13:24:57 <BluShift> jedai: Hah.
13:24:59 <alpounet> and lambda calculus is more the "theoretical framework" between that
13:25:00 <Saizan> BluShift: haskell is currently used for all sort of things, from webservers to high frequency trading, and GHC has extremely easy to use parallelism and concurrency, so it's not just about computer science :)
13:25:16 <alpounet> behind*
13:25:36 <BluShift> Saizan: Yeah, that's what I find interesting. THings like Python and C aren't really capable of parallel work out of the box.
13:26:10 <BluShift> alpounet: See, I understand how something can take a function as an argument, I just don't understand how it could possibly *return* a function.
13:26:30 <Eduard_Munteanu> BluShift: you can return pointers to functions in C too
13:26:32 <BluShift> Although that's probably because function is a synonym of sub-routine, to me.
13:26:40 <sipa> basvandijk: yes :)
13:26:46 <BluShift> Eduard_Munteanu: Well, in that case I've never done it :P
13:26:56 <alpounet> > let giveMeAFunction x = (+x) in (giveMeAFunction 1) 4 -- BluShift 
13:26:57 <lambdabot>   5
13:26:59 <jedai> BluShift: Well functions in Haskell are more like the mathematical functions
13:27:00 <sipa> basvandijk: were you the one who told me about a window manager in haskell back then?
13:27:16 <BluShift> sipa: XMonad?
13:27:27 <Eduard_Munteanu> Xmonad rocks.
13:27:52 <sipa> BluShift: well, i can't remember whether it was xmonad he showed me, but that's what i'm using now :)
13:29:15 <jedai> BluShift: if f is a function of type "A -> B" and X is of type A, "f X" will evaluate to something of type B, always the same wherever you put "f X"
13:29:36 <basvandijk> sipa: could be since I'm running xmonad from version 0.1
13:30:22 <jedai> BluShift: just like cos was a function from R in R, pi a real and "cos(pi)" always evaluated to -1
13:30:23 <basvandijk> It seems all mailinglists on haskell.org are down due to "no space left on device".
13:30:29 <basvandijk> Who can we contact?
13:30:47 <alpounet> basvandijk, maybe Igloo ?
13:30:55 <alpounet> or dcoutts
13:31:08 <tmo_> http://pastebin.com/C6Yammjw
13:31:28 <tmo_> How do I get it so that whatever type a is in Show, it too must be a member of both the Num typeclass and the Show typeclass?
13:32:00 <jedai> BluShift: except of course most of the functions you saw in maths worked on numbers whereas in Haskell you'll manipulate other objects like lists, tuple, or even functions
13:32:20 <basvandijk> alpounet: Do you have the email address of Igloo?
13:32:32 <BluShift> What are you, some kind of liar?
13:32:42 <maltem> tmo_, you almost certainly want   instance (Show a) => Show (Polynomial a)
13:32:46 <basvandijk> alpounet: never mind I already got it
13:33:16 <jedai> BluShift: if you want an example of mathematical function that returns a function, you can think of derivation
13:33:32 <c_wraith> jedai, I was just going to mention that as a function from functions to functions.
13:33:40 <BluShift> jedai: Like I said, I stopped at Grade 12 Pre-calc.
13:33:48 <alpounet> ok BluShift
13:33:51 <alpounet> an easier one :
13:34:03 <alpounet> imagine i hand you a function
13:34:07 <alpounet> from R to R
13:34:08 <BluShift> Sure.
13:34:20 <alpounet> let's call it f
13:34:25 <tmo_> maltem: Thanks!
13:34:26 <alpounet> now, for any real number x
13:34:30 <BluShift> So, f(R) = R?
13:34:31 <Eduard_Munteanu> Math people don't seem to think in terms of higher order functions usually.
13:34:32 <alpounet> i want you to return me
13:34:39 <alpounet> 2*f(x)
13:34:45 <tmo_> I'm still unfamiliar with the intricacies of typeclasses @_@
13:34:57 <alpounet> BluShift, you understand so far ?
13:35:04 <BluShift> alpounet: I think so.
13:35:05 <jedai> Eduard_Munteanu: well that depends on what field and at what level you're working
13:35:18 <alpounet> BluShift, ok now 
13:35:22 <alpounet> let's call that g
13:35:27 <alpounet> so g(x) = 2*f(x)
13:35:47 <alpounet> in C, you would write that : double g(double x) { return 2*f(x); }
13:35:59 <BluShift> Ok.
13:36:06 <alpounet> in Haskell
13:36:09 <alpounet> it becomes
13:36:11 <Eduard_Munteanu> jedai: the normal function theory (relations) doesn't seem to ever make any explicit construction of a HOF. Though yes, lambda calculus and type theory is another thing.
13:36:15 <megatron242> Hi, I have a noob question about something the confuses me about haskell - when exactly should one use ++ to concate a list and when : ?
13:36:16 <alpounet> g x = 2 * f x
13:36:17 <Saizan> tmo_: instance Show a => Show (Polynomial a) where ..
13:36:27 <shachaf> tmo_: What you're defining is more general than a polynomial, by the way.
13:36:28 <alpounet> with me so far BluShift ?
13:36:31 <jedai> Eduard_Munteanu: I saw quite a lot of 'higher-level" function in my maths classes, even if the teachers didn't use those terms (after all they're just the same old function, nothing really different in nature)
13:36:57 <BluShift> alpounet: Sort of. In C, it wouldn't return a function, but rather the result of said function, right?
13:37:12 <osaunders> megatron242: (++) and (:) aren't equivalent. 
13:37:13 <alpounet> yeah
13:37:18 <alpounet> BluShift, the haskell version i wrote does the same
13:37:19 <Eduard_Munteanu> jedai: yeah, they're somehow obscured. They talk of dual spaces in algebra, or function spaces or such. But almost never spelled out a -> (b -> c) :)
13:37:24 <jedai> megatron242: (++) is concatenation, (:) is not
13:37:28 <jedai> :type :
13:37:30 <alpounet> however I'm gonna make you see how we can get to manipulate a function
13:37:34 <jedai> :type (:)
13:37:34 <BluShift> Returns the result, not the actual function?
13:37:39 <osaunders> :t (:)
13:37:40 <lambdabot> forall a. a -> [a] -> [a]
13:37:44 <osaunders> :t (++)
13:37:45 <lambdabot> forall m. (Monoid m) => m -> m -> m
13:37:51 <jedai> oops
13:37:54 <alpounet> BluShift, that's what we do now yes
13:37:54 <alpounet> but BluShift 
13:37:58 <osaunders> Uh, that should be (++) :: [a] -> [a] -> [a]
13:38:00 <BluShift> Yes?
13:38:15 <FunctorSalad_> osaunders: hmm, Vec maybe?
13:38:15 <alpounet> now imagine I want you to do that for any function over real numbers I want
13:38:17 <Eduard_Munteanu> osaunders: I think it's mappend
13:38:31 <osaunders> Eduard_Munteanu: In lambdabot, yes.
13:38:34 <alpounet> in C, you'd use a pointer to a function right ?
13:38:36 <shachaf> megatron242: (:) is the constructor that lists are built of.
13:39:22 <BluShift> alpounet: Sure.
13:39:25 <shachaf> megatron242: (++) is a utility function that appends one list to another, and it traverses its entire first argument in order to create the new list.
13:39:32 <megatron242> so, just to be clear, is x:xs is equavilent to [x] ++ xs ?
13:39:33 <osaunders> FunctorSalad_: So basically this is something I'm going to have to implement myself?
13:39:37 <BluShift> alpounet: Well, i wouldn't. But that's just my style, I suppose :P
13:39:41 <Veinor> megatron242: yep
13:39:46 <jedai> megatron242: Well (:) takes two lists and put them end to end, (:) takes one element and a list and return a new list contitued of this element and the list as the tail
13:39:47 <FunctorSalad_> osaunders: the underlying datatype is hetero, but it has a bunch of synyonyms for fixed-length homo vectors http://hackage.haskell.org/packages/archive/Vec/0.9.8/doc/html/Data-Vec-Base.html#1
13:39:52 <alpounet> BluShift, something like:  double g( double (*f)(double), double x) { return 2 * (*f)(x); }
13:39:56 <BluShift> alpounet: I write C like I write Java, or Python (which is probably not correct)
13:40:18 <FunctorSalad_> osaunders: huh? don't see how you saw that in my answer :)
13:40:26 <alpounet> BluShift, now, in Haskell, here's how it would look like: let g f x = 2 * f x
13:40:28 <shachaf> BluShift: You write C without worrying about memory allocation? :-)
13:40:32 <megatron242> OK, now it's make more sense to me. Thanks for all those who replied!
13:40:37 <alpounet> now f has become an argument of g
13:40:40 <BluShift> shachaf: Hah, of course not.
13:40:41 <Eduard_Munteanu> @free \a b -> a : b
13:40:42 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
13:40:48 <osaunders> FunctorSalad_: OK, yeah. I only said that because a search for Vec didn't yield anything for me, but I was looking in the wrong place.
13:41:01 <Eduard_Munteanu> @free a -> [a] -> [a]
13:41:02 <lambdabot> Extra stuff at end of line
13:41:13 <osaunders> FunctorSalad_: Still, kind of lame that you can't easily specify any length.
13:41:14 <Eduard_Munteanu> Damn, how do I use that.
13:41:14 <alpounet> BluShift, but now I tell you I don't care about a precise x anymore
13:41:20 <BluShift> alpounet: Ok, you've lost me.
13:41:28 <alpounet> BluShift, where ?
13:41:35 <BluShift> alpounet: I feel I'm over my head a little here.
13:41:39 <maltem> Eduard_Munteanu, I think mathematicians don't usually name HOFs that way because there are no interesting properties to state about them regarding their nature of being HOFs. It still can be a little frustrating at times when real analysis people keep writing "f(x) = g(x) forall x in U", rather than f = g :)
13:42:08 <Eduard_Munteanu> Heh, yes.
13:42:14 <alpounet> BluShift, yeah
13:42:17 <Eduard_Munteanu> I also think it's some contention over what f = g menas.
13:42:18 <Eduard_Munteanu> *means
13:42:25 <FunctorSalad_> osaunders: that'd seem to need dependent types
13:42:30 <alpounet> you have to get yourself to think a level higher than usual
13:42:34 <shachaf> maltem: They don't write "f = g"?
13:42:38 <BluShift> alpounet: Perhaps I'll just read LYAH. :P
13:42:43 <osaunders> FunctorSalad_: Dependent types?
13:42:46 <alpounet> just like you think a move ahead when playing chess
13:42:48 <FunctorSalad_> osaunders: assuming haskell type-level ints don't count as 'easy' ;)
13:42:52 <shachaf> maltem: I see things like "f = g + h" all the time, without the argument written out explicitly.
13:42:59 <Eduard_Munteanu> Some say f = g <=> forall x. f(x) = g(x); other add that dom(f) = dom(g) and cod(f) = cod(g)
13:43:03 <BluShift> alpounet: Yes, perhaps. Imperative languages are very much "point a to point b", which is how I think.
13:43:21 <Draconx|Laptop> maltem, f(x) = g(x) forall x in U is a weaker condition than f(x) = g(x), which implies that the domain, codomain and graph be identical.
13:43:28 <alpounet> BluShift, yeah whereas haskell is more like describing the relations between stuffs, and let that do the work
13:43:30 <maltem> shachaf, well sometimes they do, sometimes they don't
13:43:41 <BluShift> alpounet: Yeah.
13:43:41 <alpounet> BluShift, I definitely think you should read LYAH and come back here when you have questions
13:43:45 <alpounet> we'd be glad to answer them
13:43:56 <BluShift> alpounet: Okie doke.
13:43:57 <Draconx|Laptop> maltem, er, s/f(x) = g(x)/f = g/
13:44:01 <Eduard_Munteanu> How's LYAH compared to RWH?
13:44:06 <Eduard_Munteanu> Less technical?
13:44:08 <jedai> FunctorSalad_ osaunders : Though there is now some packagges on hackages to bring "easy" (?) type-level integers and lenght-coded lists to the average haskeller
13:44:08 <alpounet> Eduard_Munteanu, yeah
13:44:12 <alpounet> more beginner-friendly
13:44:16 <osaunders> LYAH is more explainy.
13:44:18 <Eduard_Munteanu> Ah.
13:44:26 <maltem> Draconx|Laptop, true, I was thinking of a context where f, g : U -> R, so it wouldn't matter
13:44:32 <bremner> lyah doesn't really assuming programming competence
13:44:39 <shachaf> Draconx|Laptop: When restricting the domain, don't they usually write something like "f|_U"?
13:44:48 <osaunders> jedai: Any examples?
13:44:56 <xxxxxx_> does one has this paper? http://search.ieice.org/bin/summary.php?id=e79-d_6_840
13:44:57 <xxxxxx_> ?
13:45:22 <jedai> osaunders: there was one pretty recently, search type-level in hackage maybee
13:45:37 <osaunders> @hackage type-level
13:45:37 <lambdabot> http://hackage.haskell.org/package/type-level
13:45:42 <Eduard_Munteanu> @help
13:45:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:46:12 <Draconx|Laptop> shachaf, sure, but that notation usually doesn't affect the codomain.
13:46:16 <xxxxxx_> ?
13:46:28 <Draconx|Laptop> shachaf, of course, mathematicians abuse notation all the time.
13:46:34 <shachaf> Draconx|Laptop: Do people often restrict only the codomain?
13:47:00 <maltem> shachaf, my impression is that in situations like this: "Let f, g : U -> R be functions such that  then we have f(x) = g(x) for all x in U", they wouldn't
13:47:17 <Draconx|Laptop> shachaf, equality would demand that the codomain of the two functions be the same.
13:47:22 <Eduard_Munteanu> @free (:)
13:47:22 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
13:47:23 <shachaf> maltem: Sure, that's just f = g. But what's the point of that anyway? :-)
13:47:31 <Eduard_Munteanu> Is '@free' broken?
13:47:37 <Eduard_Munteanu> @djinn (:)
13:47:37 <lambdabot> Cannot parse command
13:47:45 <Eduard_Munteanu> @djinn a -> [a] -> [a]
13:47:45 <lambdabot> Error: Undefined type []
13:47:49 <shachaf> @djinn a -> a
13:47:49 <lambdabot> f a = a
13:47:49 <maltem> shachaf, I wasn't aware of a certain point :)
13:47:51 <Eduard_Munteanu> Shucks.
13:48:05 <alpounet> @djinn [a] -> [a]
13:48:05 <lambdabot> Error: Undefined type []
13:48:08 <alpounet> dang
13:48:11 <Eduard_Munteanu> @free map
13:48:12 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
13:48:12 <xxxxxx_> does one has this paper? http://search.ieice.org/bin/summary.php?id=e79-d_6_840
13:48:14 <xxxxxx_> ?
13:48:17 <osaunders> @djinn a -> [] a
13:48:17 <lambdabot> Cannot parse command
13:48:19 <shachaf> Why should @djinn know about []?
13:48:26 <Eduard_Munteanu> @djinn map
13:48:26 <lambdabot> -- f cannot be realized.
13:48:26 <maltem> shachaf, or did you mean, point of that example?
13:48:29 <osaunders> @djinn (a,b) -> a
13:48:29 <lambdabot> f (a, _) = a
13:48:29 <shachaf> Use Maybe instead. It's equivalent.
13:48:42 <Lemmih> xxxxxx_: Third time is the charm.
13:48:42 <shachaf> maltem: Yes.
13:48:50 <xxxxxx_> ok
13:48:54 <Eduard_Munteanu> Interestingly map works.
13:49:14 <Eduard_Munteanu> @free (a -> b) -> [a] -> [b]
13:49:14 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
13:49:31 <shachaf> @free cons :: a -> [a] -> [a]
13:49:31 <lambdabot> $map f . cons x = cons (f x) . $map f
13:49:39 <Eduard_Munteanu> Oh. Thanks.
13:50:08 <dagle> Hmm. 
13:50:15 <maltem> shachaf, well the dots could be: U is an open subset of R, both functions are differentiable with f'(x) = g'(x) for all x in U, and f(c) = g(c) for some c in U.
13:52:29 <Eduard_Munteanu> I wonder how it deals with functors.
13:52:33 <Eduard_Munteanu> @free return
13:52:33 <lambdabot> Expected variable or '.'
13:52:40 <megajosh2> @src replicateM
13:52:40 <lambdabot> replicateM n x = sequence (replicate n x)
13:53:14 <Eduard_Munteanu> Probably not good.
13:54:02 <Eduard_Munteanu> @free zipWith
13:54:03 <lambdabot> (forall x. h . k x = p (f x) . g) => $map h . zipWith k xs = zipWith p ($map f xs) . $map g
13:54:22 * Eduard_Munteanu has to get lambdabot on localhost...
13:54:48 <Eduard_Munteanu> I hope they solved the problem on Gentoo.
13:56:48 * BluShift likes the pictures in LYAH *hurr durr*
13:57:08 <Nibble> hurr durr
13:57:25 <BluShift> I'm digging how gentle this tutorial is.
13:57:37 <osaunders> Eduard_Munteanu: «cabal install pointfree» goes some of the way
13:58:07 <osaunders> BluShift: LYAH?
13:58:07 <Nibble> screw that website
13:58:11 <Nibble> I was watching a movie
13:58:12 <Nibble> ffs
13:58:24 <Nibble> thank god firefox interrupted it.
13:58:55 <Eduard_Munteanu> osaunders: last time I tried it could link lambdabot or some dep because Gentoo had linker scripts instead of libs in some places.
13:59:07 <Eduard_Munteanu> *couldn't
13:59:17 <BluShift> osaunders: Everyone here referred my to learnyouahaskell.com
13:59:23 <osaunders> Yeah I couldn't install lambdabot either, but I'm happy with just pointfree.
13:59:39 <osaunders> BluShift: Yeah. I was just going to say it isn't so much a tutorial as a book.
13:59:52 <HairyDude> argh, it's annoying that you can't define something polymorphically over (/) and div
14:00:04 <Eduard_Munteanu> osaunders: yup still not working
14:00:06 <Eduard_Munteanu> Loading package readline-1.0.1.0 ... <command line>: can't load .so/.DLL for: readline (/usr/lib64/libreadline.so: invalid ELF header)
14:00:24 <HairyDude> I know there's always no remainder so there's no difference in this case
14:00:42 <osaunders> I can't help you with that, sorry. I have problems with cabal all the time, most of them I never manage to fix.
14:01:03 <Eduard_Munteanu> I'll look if there's an open ticket on this issue.
14:01:21 <HairyDude> (dividing each of a list of numbers by their gcd, regardless of whether they're integers or fractional)
14:02:24 <maltem> HairyDude, what's the gcd of fractionals?
14:02:30 <BluShift> osaunders: Oh, bad place to start?
14:02:41 <HairyDude> maltem: ... I just realised that. I am an idiot :)
14:03:22 <osaunders> BluShift: No. LYAH is a good place to start but it is a book. Quite a long one at that.
14:04:14 <BluShift> osaunders: Well, I do like a good book ;)
14:04:22 <dagle> BluShift: Rember to put the book down from time to time and use what you have learned without the book in front of you. :)
14:04:26 <osaunders> Those two facts go hand-in-hand. LYAH is heavy on explanation, which is why it is so long.
14:04:48 <BluShift> dagle: Without?
14:04:48 * osaunders agrees with dagle.
14:05:02 <BluShift> dagle: Approximately how far in should I be doing this?
14:05:13 <osaunders> Or, more concisely: Don't forget to actually program.
14:05:31 <dagle> BluShift: It's easy to think you understand / know it but when you remove the book you just know the theory and not pratice.
14:05:43 <maltem> BluShift, when(ever) you see fit.
14:05:51 <BluShift> maltem: Okie doke.
14:05:54 <Eduard_Munteanu> Well it's possible to learn Haskell without books if you have some project at hand and are willing to Google for everything.
14:06:05 <Eduard_Munteanu> Basically that's what I did.
14:06:25 <osaunders> Crazy mother.
14:06:27 <dark> BluShift, I find the most interesting way to learn more is to actually try to do something. specially something haskell is very nice, like, a parser with parsec
14:06:30 <BluShift> Ooo, I like that functions don't need explicit return types. Very python-like :)
14:07:07 <dark> (but I have been unsuccessful in all projects I try to start in haskell. I don't know why, but I never get used with anything but the basics)
14:07:09 <dolio> What does that mean?
14:07:10 <osaunders> BluShift: Well they do, it's just that sometimes the type of polymorphic.
14:07:13 <Eduard_Munteanu> BluShift: they do need explicit return types!
14:07:17 <alpounet> Eduard_Munteanu, tried just reinstalling libreadline ?
14:07:31 <dark> BluShift, it is due "type inference"
14:07:34 <BluShift> Well, I came to Haskell initally because I was trying to write a (faster) copy of a Mersenne finder, which I had initally written in Python. But with C's strict type limitations, Mersenne numbers can't get very big before C can't work with them.
14:07:44 <Eduard_Munteanu> BluShift: you can't just supply argument types.
14:08:00 <dark> types in haskell are most of times implicit (but strong)
14:08:05 <BluShift> Haha, everyone jumped on me for that :P
14:08:14 <Eduard_Munteanu> alpounet: yes, but that's how it is on Gentoo. I suppose it's some multilib magic to allow both 32-bit and 64-bit readline, or something
14:08:17 <dark> BluShift, I think haskell has good support for "bignums". That's what you need, right?
14:08:17 <dolio> That doesn't have anything to do with C's types.
14:08:18 <BluShift> That what I meant, that GHC inferes them.
14:08:24 <HairyDude> @hoogle Integral i => [i] -> i
14:08:24 <lambdabot> Prelude head :: [a] -> a
14:08:24 <lambdabot> Prelude last :: [a] -> a
14:08:24 <lambdabot> Data.List head :: [a] -> a
14:08:25 <blackdog> dark: static, not just strong
14:08:27 <blackdog> python has strong types
14:08:31 <BluShift> dark: Oh, I assume so.
14:08:39 <HairyDude> so, no gcd-of-list function in the standard library?
14:08:43 <BluShift> Anything beyond 2^32-1.
14:09:06 <Eduard_Munteanu> BluShift: although it's good practice (at least after you get going), to write explicit type signatures in most places.
14:09:31 <BluShift> Eduard_Munteanu: What if I want a function to work on a number of types?
14:10:01 <dark> BluShift, and.. doesn't the standard library have them?
14:10:02 <Eduard_Munteanu> BluShift: you supply a typeclass constraint
14:10:08 <Eduard_Munteanu> BluShift: don't worry about it now
14:10:20 <BluShift> I had to write my own version of C's "pow()" function, because I just wanted a long, unsigned integer returned, not a double.
14:10:57 <HairyDude> :t (^)
14:10:58 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
14:11:12 <HairyDude> is a power function for integers.
14:11:14 <BluShift> dark: C's library? If it doesn't, i wasn't aware of it. The only way for me to get close to what I need was to compile it for a 64-bit machine :-/
14:11:20 <Eduard_Munteanu> you don't need to write 'forall a b.' explicitly.
14:11:37 <HairyDude> yeah, lambdabot is a bit verbose
14:11:50 <dark> BluShift, there are multiple C libraries for this (usually implementing a bignum as a linked list, or something like that). But, I meant, for haskell..
14:12:01 <BluShift> HairyDude: I meant I rewrote the function in C, for use in C code :)
14:12:07 <Eduard_Munteanu> Bignums are arbitrary precision arithmetics.
14:12:07 <HairyDude> oh, right :)
14:12:12 <dark> no, bignums are really unbounded (or, well, bounded to the size of your actual memory..)
14:12:15 <Eduard_Munteanu> 64-bit isn't arbitrary precision.
14:12:16 <alpounet> > 2^1000
14:12:17 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
14:12:30 <Eduard_Munteanu> dark: that's what I mean.
14:12:32 <dark> wow, haskell has built-in bignums!
14:12:42 <BluShift> dark: I know!
14:12:45 <alpounet> dark, that's the Integer type
14:12:47 <maltem> HairyDude, foldl' gcd 1 ?
14:12:49 <alpounet> it fails for Int
14:12:50 <HairyDude> most HLLs do these days don't they?
14:12:53 <alpounet> > 2^1000 :: Int
14:12:54 <lambdabot>   0
14:12:59 <dark> ahh...
14:13:07 <alpounet> > 2^1000 :: Integer
14:13:08 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
14:13:20 <benmachine> > isSymbol '-'
14:13:21 <lambdabot>   False
14:13:22 <dark> I remember now
14:13:23 <benmachine> ^ wat
14:13:28 <BluShift> I didn't want to be constrained by a fixed size, so I was forced to ditch C and come to Haskell. Python just wasn't giving me the performance I wanted :)
14:13:28 <alpounet> Integer is the one you want if you need to be able to perform calculations on arbitrarily big numbers
14:13:40 <osaunders> > isSymbol '-'
14:13:41 <lambdabot>   False
14:13:44 <osaunders> Gawd
14:13:51 <benmachine> osaunders: I know right, what the heck
14:13:55 <HairyDude> maltem: doesn't seem to work. foldl1' does though (fails for an empty list of course)
14:13:56 <Eduard_Munteanu> BluShift: bignums vs normal nums is indeed a performance tradeoff
14:14:03 <dolio> The library GHC uses for Integer is GMP, which is a C library for abitrary precision arithmetic.
14:14:12 <Eduard_Munteanu> It's normal for bignums to be slower.
14:14:13 <osaunders> benmachine: I was just checking you weren't using some funny unicode dash, but no.
14:14:19 <benmachine> > isPunctuation '-'
14:14:20 <lambdabot>   True
14:14:23 <benmachine> hmph
14:14:26 <BluShift> Eduard_Munteanu: Oh, perhaps I should forget Haskell and go back to C  then :P :P :P
14:14:30 <benmachine> pretty sure - is a minus not a hyphen
14:14:32 <BluShift> *kicked, banned*
14:14:33 <benmachine> however it is abused
14:14:43 <maltem> HairyDude, I was being dumb, it should be 0 instead of 1
14:15:01 <osaunders> benmachine: It is both.
14:15:07 <BluShift> I thought C was limited to long int, int, and short int.
14:15:19 <osaunders> I think it is called minus-hypen or something, offically.
14:15:19 <HairyDude> maltem: that does work :)
14:15:21 <benmachine> osaunders: hmph
14:15:37 <osaunders> But it's actually not typographically correct for either. I think.
14:16:05 <benmachine> osaunders: what the heck IS it then :P
14:16:12 * hackagebot ncurses 0.1.0.1 - Modernised bindings to GNU ncurses  http://hackage.haskell.org/package/ncurses-0.1.0.1 (JohnMillikin)
14:16:20 <dark> BluShift, yes, but you can implement something like a list of numbers, each number being a "digit"
14:16:23 <HairyDude> > foldl' gcd 0 [0]
14:16:24 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
14:16:28 <dark> or a similar scheme
14:16:29 <BluShift> And to think I was considering using unsigned longs on a 64-bit machine, just to get a few more places of precision >_>
14:16:38 <osaunders> benmachine: What are you doing that requires you to know?
14:16:54 <dark> I read something about doing multiplication using fast fourier transform and things like that, too..
14:16:54 <benmachine> osaunders: being human
14:17:06 <BluShift> dark: Is that part of the stdlib?
14:17:08 <benmachine> osaunders: and engaged in the pursuit of knowledge\
14:17:12 <maltem> HairyDude, umph. Why did they do that?
14:17:13 <osaunders> Ah
14:17:15 <osaunders> Then I don't know.
14:17:22 <benmachine> oh :P
14:17:22 <benmachine> k
14:17:23 <dark> BluShift, no. GMP seems to be a gnu lib, so it's free
14:17:27 <HairyDude> I think foldl1' is the correct implementation. not sure the gcd of an empty list makes sense, but gcd of a singleton does
14:17:41 <Eduard_Munteanu> BluShift: not really, you can use fixed-size arithmetics/numbers in Haskell as well.
14:17:41 <Eduard_Munteanu> (some say it's premature optimization to use Int everywhere)
14:17:47 <benmachine> > let f "→" = True in ()
14:17:48 <lambdabot>   ()
14:17:50 <benmachine> hmm
14:18:03 <dark> gmp site seems off here
14:18:04 <benmachine> oh I'm a tit
14:18:31 <osaunders> Eduard_Munteanu: Int is way bigger than I need most of the time though.
14:18:39 <maltem> HairyDude, it does make sense: 0 is the greatest (according to divisibility) number that divides all elements of the empty list
14:18:40 <osaunders> > maxBound :: Int
14:18:41 <lambdabot>   9223372036854775807
14:18:59 <maltem> I'm not sure why the Prelude doesn't define gcd 0 0 = 0
14:19:15 <dark> :t maxBound
14:19:16 <lambdabot> forall a. (Bounded a) => a
14:19:16 <osaunders> OK it's not _that_ big on my system.
14:19:20 <benmachine> osaunders: but bugs from improper use of Int are far subtler (and quicker to anger) than bugs from misuse of Integer
14:19:20 <HairyDude> maltem: erm, surely for all x in [], every number divides x
14:19:27 <ulfdoz> maltem: You cannot devide bei zero.
14:19:32 <dark> > maxBound :: Char
14:19:33 <HairyDude> maltem: therefore, the empty list has no gcd
14:19:33 <lambdabot>   '\1114111'
14:19:37 <maltem> ulfdoz, yeah it wouldn't make much sense, but it would be consistent.
14:19:45 <benmachine> maltem: consistent with what
14:20:23 <ulfdoz> maltem: Its absolutely inconsitent from a mathematical point of view. It is indeed undefined.
14:20:25 <benmachine> > gcd 0 1
14:20:26 <lambdabot>   1
14:20:46 <benmachine> I think 'a divides b' means 'there is some k such that ka = b'
14:20:47 <dark> BluShift, see the kind of code one does with gmp: http://stackoverflow.com/questions/822734/square-root-of-bignum-using-gmp , I would stick to haskel..
14:20:56 <Eduard_Munteanu> ulfdoz: not if you take the set of numbers, along with `divides` as a preorder
14:20:58 <osaunders> benmachine: Yeah.
14:20:59 <HairyDude> > map (gcd 0) [1..]
14:21:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:21:06 <ulfdoz> maltem: gcd 0 0 could be 3 as well.
14:21:10 <osaunders> benmachine: I found one when using QuickCheck the other day
14:21:16 <HairyDude> > map (`gcd` 0) [1..]
14:21:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:21:21 <benmachine> and 'gcd a b' is a number that divides a and b, and has the property that any other number dividing a and b divides it
14:21:22 <maltem> ulfdoz, how is it inconsistent? 0 is indeed a divisor of 0. And 3 is too, but not the greatest
14:21:23 <dark> (some other languages also have good bignum support, like lispes. but with C it's awkward..)
14:21:49 <benmachine> maltem: wait so, 3 isn't greater than 0 now?
14:22:01 <HairyDude> ulfdoz: erm, what? 0 divides nothing
14:22:10 <maltem> benmachine, not in the divisibility ordering, which is used to define gcd
14:22:29 <benmachine> I think I got my definition backwards, possible
14:22:32 <benmachine> *possibly
14:22:35 <BluShift> dark: Oh, good lord.
14:22:37 <ulfdoz> isn't that an implementation detail?
14:22:42 <maltem> HairyDude, sure it does: 0*n = 0 for all n. Of course you cannot divide by zero, that's a different thing.
14:22:42 <Eduard_Munteanu> gcd a b = a V b
14:23:41 <Eduard_Munteanu> gcd is the supremum/join taken by divisiblity as ordering, right?
14:23:45 <ulfdoz> maltem: So why do you want a divisor, you cannot divide with?
14:23:53 <Eduard_Munteanu> (or erm, meet, I confuse those all the time)
14:24:33 <HairyDude> ah, according to wikipedia gcd is defined on arbitrary commutative rings. so you don't need to be able to divide with it
14:24:35 <BluShift> dark: I absolutely love the built-in functionality of Haskell and it's speed, thus far. I just need to *learn how to program generally* with it :/
14:25:00 <maltem> ulfdoz, it gets you rid of "Exception: gcd 0 0 not defined"
14:25:01 <dark> BluShift, I sometimes do bignum things with bc (it also has unbounded decimal expansion, try this at the shell: echo 'scale=1000; 4*a(1)'|bc -l)
14:25:18 <monochrom> if you take "3 divides 12" as "3 is below 12", gcd is meet, infimum, greatest lower bound.
14:26:18 <dark> BluShift, oh. my initial problems were solved by good editor integration (emacs), and, hmm.. doing simple things, and..
14:27:03 <Eduard_Munteanu> <insert editor-wars remark>
14:27:13 <HairyDude> I think "greatest" in "greatest common divisor" refers to the usual ordering on the integers, not some other ordering
14:27:27 <osaunders> Are there plans to add type-level computations to Haskell then?
14:27:38 <Eduard_Munteanu> HairyDude: indeed, but there's another way to look at integers.
14:27:51 <BluShift> dark: Yeah. I'm still trying to wrap my head around one action per program, and wondering wth a "monad" is :P
14:28:47 <BluShift> I like the way functions are defined in LYAH. Rather than getting caught up with the syntax, I'm just seeing "doubleMe x = x + x"
14:28:52 <BluShift> Gorgeous!
14:28:53 <Eduard_Munteanu> As byorgey says, the only way to get it is to stare at the monad definition until you get it.
14:28:54 <dark> osaunders, http://www.haskell.org/sitewiki/images/d/dd/TMR-Issue8.pdf
14:29:01 <ulfdoz> maltem: It get's you rid of the exception? sorry, doubt, that this is a good reason, if you could say it is correct, it is a good reason. But imho it breaks invariants, if you define it.
14:29:22 <BluShift> Eduard_Munteanu: Hah, ok.
14:29:23 <Eduard_Munteanu> Wikibooks has a chapter (in the Haskell wikibook)on monads as well, might want to check that out too
14:29:49 <osaunders> dark: Ooh, TY
14:30:22 <ulfdoz> maltem: Most of the time, I develop in Java, this sounds a bit like the reason why I always have a default in switch-statements over enums.
14:30:38 <Eduard_Munteanu> Most importantly, skip the parts where monads are burritos :P
14:30:48 <dark> BluShift, I'm familiar with OCaml, and a lot of patterns of haskell is like ml. And the funny thing is, there is a lot of libraries of ocaml that implement monads, but they are all incompatible, due to lack of typeclasses
14:31:35 <Darkovsky> Uhhm
14:31:38 <dark> in fact, I came to appreciate monads after reading about monads in ocaml. Maybe you can read about monads in.. python?
14:31:51 <Darkovsky> USing a list of IArrays, how would I search them?
14:31:54 <Eduard_Munteanu> I wouldn't recommend it.
14:32:01 <c_wraith> dark, monads don't make much sense if you're not familiar with higher-order functions.
14:32:07 <Darkovsky> Or at least, how would I get the last element of an IArray?
14:32:09 <Eduard_Munteanu> It doesn't make sense to look at dynamically typed languages.
14:32:27 <Darkovsky> Eduard_Munteanu :D
14:32:38 <Darkovsky> Trying to do one last thing now.
14:32:42 <Eduard_Munteanu> Darkovsky: (!) . snd . bounds
14:32:48 <dark> c_wraith, but, I am. (and I enjoy thinking in terms of fold, for some problem)
14:32:52 <Eduard_Munteanu> off the top of my head, could fail.
14:32:55 <BluShift> dark: I think I need a visual diagram of a monad. From what I've read, a monad is an initial value, followed by a number of functions that transform it, and then returned to the programs' flow.
14:33:01 <BluShift> But that's probably really wrong.
14:33:14 <c_wraith> dark: BluShift seems not to be, though.
14:33:25 <Eduard_Munteanu> :t (!) . snd . bounds
14:33:26 <lambdabot> forall i e e1. (Ix i, Ix (Array i e)) => Array (Array i e) e1 -> i -> e
14:33:34 <maltem> ulfdoz, well it *is* correct :)
14:33:47 <BluShift> c_wraith: I seem not to be what?
14:33:51 <ulfdoz> maltem: Is it the greates divisor?
14:34:01 <Eduard_Munteanu> :t (!)
14:34:02 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
14:34:04 <c_wraith> BluShift, familiar with higher-order functions
14:34:21 <Eduard_Munteanu> :t (!) . snd . (flip bounds)
14:34:22 <lambdabot>     Couldn't match expected type `(a, a1 -> Array i e)'
14:34:22 <lambdabot>            against inferred type `Array i1 e1 -> (i1, i1)'
14:34:22 <lambdabot>     In the first argument of `flip', namely `bounds'
14:34:31 <BluShift> c_wraith: Not really.
14:34:35 <Eduard_Munteanu> :t bounds
14:34:36 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
14:34:55 <BluShift> c_wraith: Is it the idea that a function can act as an argument to another function, or that a function can return another function?
14:34:57 <c_wraith> BluShift, the key is to not think functions deserve special treatment. :)
14:35:03 <monochrom> both
14:35:05 <Eduard_Munteanu> Darkovsky: (!) . snd . bounds your_array
14:35:11 <c_wraith> functions are just values.
14:35:24 <dark> BluShift, a monad may store a value, a number of values, or no value; a monad may not store a value at all but _produce_ values.. or none of this. the meaning of the monad depends on which monad you are talking about
14:35:25 <Eduard_Munteanu> Darkovsky: check out the API on Hackage
14:35:42 <Eduard_Munteanu> Darkovsky: most importantly look at both the actual array and its typeclass
14:35:43 <Darkovsky> Eduard_Munteanu, so I guess I would search the list for each array that ends in ...._PAR
14:35:52 <dark> BluShift, so you need to understand the monad in terms of the operations valid for all monads..
14:35:58 <BluShift> dark: Ok. But are there a number requisite parts that exist in every monad, or necessarily define a monad?
14:36:05 <Darkovsky> And then search for a corresponding one without PAR
14:36:06 <ulfdoz> maltem: gcd ist defined to be positive.
14:36:09 <dark> BluShift, yes: return and bind
14:36:18 <Darkovsky> SS_SH_TR_M3_PAR;
14:36:20 <Eduard_Munteanu> Darkovsky: I don't get it :/. You asked how to get the last element of an array.
14:36:23 <maltem> ulfdoz, here's the algebra definition of gcd: d is a gcd of a and b if a | d, b | d, and for any d' with the same properties, d' | d.
14:36:24 <BluShift> Ok, I understand return. What is "bind"/
14:36:25 <BluShift> ?
14:36:37 <maltem> ulfdoz, not necessarily so.
14:36:37 <Darkovsky> Eduard_Munteanu, right, I can use a list search if I can get the last element of the array, right?
14:36:39 <Eduard_Munteanu> BluShift: do you?
14:36:49 <Darkovsky> Doesn't look like IArray has a method for searching
14:36:56 <dark> @src bind
14:36:56 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:37:03 <BluShift> Eduard_Munteanu: I understand it in terms of imperative languages. Is it different in functional languages?
14:37:09 <Eduard_Munteanu> BluShift: yes
14:37:17 <BluShift> Oh, lol.
14:37:22 <nschoe> Hi back all.
14:37:33 <Eduard_Munteanu> BluShift: there are similarities, but in the end, in Haskell it's merely a function.
14:37:44 <nschoe> (is jmcarthur here ?)
14:37:48 <maltem> ulfdoz, note that a = b = d = 0 works.
14:37:48 <ulfdoz> maltem: but a | 0 and b | 0 is not defined.
14:37:48 <Eduard_Munteanu> > return 5 :: Maybe
14:37:49 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
14:37:49 <lambdabot>  Expected kind `...
14:37:57 <Eduard_Munteanu> > return 5 :: Maybe Int
14:37:58 <lambdabot>   Just 5
14:38:05 <BluShift> Eduard_Munteanu: Is "merely a function" a really abstract way of splitting hairs?
14:38:11 <Eduard_Munteanu> BluShift: no.
14:38:26 <Eduard_Munteanu> BluShift: it is indeed a function
14:38:28 <maltem> ulfdoz, a is said to be a divisor of g, written a | g, if there is some m such that a * m = g.
14:38:28 <Eduard_Munteanu> :t return
14:38:29 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:38:37 <BluShift> Ok, what purpose does "return" serve in a monad, then?
14:38:43 <Eduard_Munteanu> BluShift: it doesn't alter flow control in any way
14:38:44 <monochrom> (what hair is there to split?)
14:38:55 <BluShift> Eduard_Munteanu: Right, i read that somewhere.
14:39:08 <BluShift> Eduard_Munteanu: So what happens with a returned value, then?
14:39:14 <Eduard_Munteanu> BluShift: it lifts a value into the monad
14:39:17 <Eduard_Munteanu> For example...
14:39:21 <alpounet> return "takes the value into the monad"
14:39:22 <Eduard_Munteanu> a <- getFoo
14:39:23 <ulfdoz> maltem: But if gcd is a, then a >= m.
14:39:23 <Eduard_Munteanu> return a
14:39:30 <Eduard_Munteanu> will work like an imperative return
14:39:32 <Darkovsky> Uhmmm
14:39:44 <sipa> BluShift: return lifts a non-monadic value to a monadic one; the do notation and the return function look very imperative (and maybe purposefully so), but return really is a normal function, like every other
14:39:55 <maltem> ulfdoz, what do you mean exactly?
14:39:55 <dark> BluShift, but now my understanding fail: I don't know the definition of bind without looking docs. but anyway, a list of values is a monad; return x is just a list with just x.. you use bind to make transformations on this list. but the monad mechanism itself has no provision for getting the value back
14:40:05 <dark> to get the values of the list, you need to use an list-specific mechanism..
14:40:11 <monochrom> you really need to see "bind" in order to see what "return" does and what good it is.
14:40:11 <ulfdoz> maltem: I mean, that there is no greater common divisor.
14:40:17 <Eduard_Munteanu> Darkovsky: use elems and search the list
14:40:19 <dschoepe> Is there a convenient way(i.e. without parsing the html files) to access the haddock information of installed packages/modules/functions?
14:40:31 <Darkovsky> Actually, I have an idea on that.
14:40:35 <Darkovsky> Different question here
14:40:54 <ulfdoz> maltem: But in unbounded rings, there is always a greater common divosor for 0.
14:41:01 <Darkovsky> Is what would be a good way to run a function repeatedly a certain number of times? Just define it recursively?
14:41:08 <dark> > return 1 :: [Int]
14:41:09 <lambdabot>   [1]
14:41:10 <Eduard_Munteanu> Darkovsky: as a matter of fact it's equivalent to searching the array
14:41:13 <Darkovsky> It consumes it's own output
14:41:15 <dark> > [1] >>= \x -> return (x+1)
14:41:16 <lambdabot>   [2]
14:41:17 <ulfdoz> infinite rings is probably the correct name.
14:41:18 <BluShift> Well, you've all lost me.
14:41:23 <maltem> ulfdoz, "greater" in what sense?
14:41:35 <BluShift> I think I need to hit up LYAH a little more :P
14:41:37 <dark> yes. If I really knew it, I probably could make it look easy. :(
14:41:38 <Eduard_Munteanu> Common divisor in what sense? :)
14:41:46 <BluShift> Thanks for your help, all :)
14:41:50 <ulfdoz> maltem: The order you need to say, that a divisor is greater then another.
14:42:16 <Eduard_Munteanu> Darkovsky: you could use iterate
14:42:18 <Eduard_Munteanu> :t iterate
14:42:19 <lambdabot> forall a. (a -> a) -> a -> [a]
14:42:21 <Lemmih> Darkovsky: Yes. You can use 'iterate' and '!!' but it's not all that nice.
14:42:44 <Darkovsky> The function takes a list of arrays, searches it for the first array where the last element = "..._PAR;", and when it finds one, it searches for the other half of that, "SS_SH_TR_M3;", copies the values across, and returns a new array
14:43:02 <Darkovsky> I know exactly how many ships are PAR
14:43:47 <fengshaun> what is haskell's 'not' operator?  if I want to negate an expression
14:43:55 <Eduard_Munteanu> :t not
14:43:56 <lambdabot> Bool -> Bool
14:43:56 <Darkovsky> not
14:43:58 <Darkovsky> :P
14:44:02 <fengshaun> thanks, that was easy
14:44:12 <Darkovsky> not . myboolfunction
14:44:35 <BluShift> So, part of a function being a HOF is that fact that is MUST always return SOMETHING, right?
14:44:42 <Lemmih> Darkovsky: I don't understand your problem description.
14:45:22 <Darkovsky> Lemmih, 583 lines of text, the last 23 are what's called "PAR" ships.
14:45:26 <Darkovsky> Prepped and Ready.
14:45:39 <BluShift> In that sense, it can stand in for a value, because it will always have some returned value. Is this correct?
14:45:40 <dark> BluShift, high order function, for me, means a function that takes a function as parameter. it has nothing to do with having to return something.. (it might diverge, i.e. enter an infinite loop or something)
14:45:52 <BluShift> dark: Oh.
14:45:56 <Darkovsky> They are already upgraded, but due t ohow the engine handles ships, this was done by making their /base/ speed really high, and allowing 0 tunings.
14:46:18 <Darkovsky> This means I had to leave them out of my normalizer, or they wouldn't match their base ships.
14:46:24 <BluShift> dark: When I think of a function taking a function as an argument, I think of a python example like "print(type("test"))"
14:46:34 <BluShift> dark: Is this the wrong way to think of it?
14:46:35 <dark> > let f a b = a b b in f (\x y -> x + y) 2
14:46:35 <lambdabot>   4
14:46:56 <dark> \x y -> x + y is a function that receives 2 arguments and return the sum between them
14:47:05 <Lemmih> Darkovsky: Try again without mentioning 'ships' or 'normalizer'.
14:47:18 <dark> f receives 2 arguments: a function a and b. and calls a b b
14:47:26 <BluShift> dark: So, every imperative language is capable using HOF right?
14:47:37 <monochrom> cobol isn't
14:47:38 <Darkovsky> Lemmih, I want to take the last 23 lines of a semi-colon delimited file
14:47:53 <Darkovsky> Match their last value (SS_SH_TR_M3_PAR; is an example)
14:47:58 <dark> BluShift, if you are satisfied in compiling the high-orderness in your head before writing the code, yes..
14:48:01 <BluShift> Because you can evaluate a number of infix functions (2 + 2, for evxample) and drop that immediately inside the parentheses of a function.
14:48:03 <Darkovsky> To another value (SS_SH_TR_M3;)
14:48:08 <Lemmih> Darkovsky: reverse . take 23 . reverse . lines ?
14:48:16 <dark> BluShift, ah.. but what if the function is recursive?
14:48:28 <dark> that example was contrived
14:48:33 <Darkovsky> When I find the second one, I want to copy the data from it, apply a small operation, and then paste the data into the first thing I found
14:48:41 <monochrom> but javascript is a good example of supporting higher-order functions
14:48:59 <BluShift> monochrom: I was talking about modern imperative languages ;)
14:49:07 <scree> Darkovsky: so, you're looking to do a fold on the list Lemmih gave?
14:49:13 <Funktorsalat> "cobol doesn't have an email library either!" ;)
14:49:19 <Darkovsky> Basically, parships = getLast23 allships
14:49:27 <monochrom> java doesn't support higher-order functions.
14:49:31 <Funktorsalat> (haskell-cafe)
14:49:45 <Eduard_Munteanu> BluShift: neither C can fully use HOFs
14:49:50 <Funktorsalat> monochrom: well it does in a roundabout way
14:49:54 <dark> BluShift, high-order functions is more like C function pointers (but even that, C does not let you create closures, that is, a function plus some variable bindings)
14:49:55 <BluShift> monochrom: You can drop an expression into a function, or a function into a function.
14:50:00 <Eduard_Munteanu> Function pointers aren't really HOFs.
14:50:19 <Darkovsky> foreach parship in parships: find (matchingship parship) allship, correct parship
14:50:24 <dark> neither create functions at runtime
14:50:27 <Funktorsalat> abstract class Function<A,R> { abstract R Invoke(A a); }
14:50:29 <BluShift> Are we all literate in Java? Or Python?
14:50:31 <Eduard_Munteanu> Just like pointers aren't really arrays.
14:50:40 <BluShift> I'm trying to look at this in an imperative way.
14:50:48 <Funktorsalat> (my java is *really* rusty, sorry for any syntax errorz)
14:51:00 <Darkovsky> Oooh
14:51:04 <monochrom> "function funny(f) { return f(0) + f(1); }"  write this in java. you can't.
14:51:06 <Darkovsky> I know what I can do
14:51:30 <Darkovsky> I can get a list of the last 23, like suggested
14:51:35 <Darkovsky> And then map a function to it
14:51:39 <BluShift> monochrom: Oh, ok.
14:51:40 <dark> BluShift, in an imperative way, you might actually write some interpreter for running functional code...
14:51:46 <Darkovsky> The function already has the allships list :D
14:51:55 <gwern> (what is parship? a salty parsnip?)
14:51:57 <BluShift> dark: I don't understand.
14:52:28 <Darkovsky> gwern, Prepped And Ready. A ship that's ready for combat form the shipyard, and doesn't need weapons, uupgrades, etc bough :V
14:52:33 <Twey> gwern: I seem to remember a dating site by that name
14:52:40 <monochrom> (there is an encoding, but all encodings are turing-tarpit. if you allow turing-tarpit, may as well say x86 machine code supports iterators.)
14:52:41 <BluShift> monochrom: Really? If they both return strings, they wouldn't be added together?
14:52:45 <dark> BluShift, for every piece of code with HOF, you can find an alternate code that does not have HOFs but does the same thing. If you are programming in a language that has no such capability, you are forced to find it
14:52:54 <ddarius> monochrom: There's a -local- encoding.
14:52:57 <Twey> gwern: http://www.parship.co.uk/
14:53:09 <BluShift> monochrom: Rather, cocantenated
14:53:45 <BluShift> dark: Oh, ok. So HOF just means that a function **literally* can be used in the any and all instances that a straight value could be?
14:53:53 <dark> yes...
14:53:57 <BluShift> Oh.
14:53:59 <Eduard_Munteanu> Function as a value.
14:54:00 <BluShift> That's it?
14:54:05 <Funktorsalat> monochrom: I don't want to defend java's lack of concise syntax for functions, but co-opting virtual methods for it as I hinted at is way higher-level than writing an interpreter for a func language
14:54:10 <monochrom> assume I only ever give you those f such that f(0) and f(1) both make sense and adding them makes sense. assume numbers if you like.
14:54:10 <dark> yes :)
14:54:26 <Eduard_Munteanu> BluShift: as long as you respect types.
14:54:34 * Eduard_Munteanu goes watch a movie, bbl
14:54:34 <BluShift> Eduard_Munteanu: rIGHT.
14:54:36 <BluShift> RIght*
14:55:11 <BluShift> So something like print(type(str(10))) could be considered an example of HOF? (Python)?
14:55:29 <dark> no, but python has map
14:55:33 <BluShift> Map?
14:55:46 <dark> > map (+ 2) [1, 2, 3]
14:55:46 <lambdabot>   [3,4,5]
14:55:52 <dark> you can write this in python
14:56:05 <dark> (+ 2) is a function that adds 2 to its argument
14:56:08 <dark> > (+ 2) 5
14:56:09 <lambdabot>   7
14:56:12 <BluShift> Oh.
14:56:22 <Veinor> map(len, [[1,2],[],[3]]) = [2,0,1]
14:56:39 <unkanon> HOF is a function that can take another function as an argument
14:56:41 <Veinor> (in python, that is)
14:56:41 <dark> yeah, "len" is a function and map receives it as argument
14:57:02 <unkanon> which means map is an HOF
14:57:08 <BluShift> So in an imperative sense (not Python, in this instance) you'd have a loop that traversed the list and added 2 to every item. But in a functional sense, there is no required function for doing this loop, other than +2?
14:57:29 <unkanon> BluShift: you could say so
14:57:31 <dark> well.. yes, but you need to see that map returns a new list
14:57:36 <dark> the old list is untouched
14:57:42 <Funktorsalat> the looping logic is abstracted out, you only need to supply what's done at reach iteration
14:57:44 <Veinor> @src map
14:57:44 <lambdabot> map _ []     = []
14:57:44 <lambdabot> map f (x:xs) = f x : map f xs
14:58:00 <BluShift> Funktorsalat: I see.
14:58:08 <Funktorsalat> *at each
14:58:39 <BluShift> So this is where monads come in -- the +2 function "lifts" a value to the list, and then that does what needs to be done with the value? Sort of?
14:58:59 <unkanon> you don;t need monads to make map work
14:59:03 <BluShift> Oh.
14:59:15 <unkanon> and it's not implemented in terms of a monad in haskell either afaik
14:59:23 <BluShift> I'm just trying to get the whole structure and activity of these things straight in my head.
14:59:35 <dark> > foldl (+) 0 [1, 5, 20]
14:59:36 <lambdabot>   26
14:59:36 <Veinor> BluShift: don't worry about monads right now
14:59:41 <BluShift> I thought everything worked in terms of monads :/
14:59:43 <dark> I just love it. *_*
14:59:59 <Veinor> people overemphasize their importance
15:00:10 <BluShift> Veinor: Really?
15:00:12 <BluShift> Ok.
15:00:14 <alpounet> BluShift, no, monads are just like "an idiom" 
15:00:22 <alpounet> a useful one
15:00:24 <BluShift> An idiom for what?
15:00:27 <augustss> Try to avoid monads at first
15:00:30 <Veinor> like, you should know how to do stuff with IO, but you don't need to understand monads on a deeper level to do that
15:00:31 <dark> it is equivalent to a loop that gets an accumulator variable, initialized as 0, and keeps summing the "next" element to the list, to it, and then return it
15:00:44 <Saizan> BluShift: an idiom for certain kinds of combinator libraries
15:00:54 <Funktorsalat> dark: you want foldl' ;)
15:01:00 <BluShift> Saizan: Aaaaand you lost me :P
15:01:01 <Saizan> BluShift: you can't say much more than that, because Monad is a very general abstraction
15:01:19 <alpounet> BluShift, well monads represent some pattern that tend to appear here and there when writing Haskell code
15:01:20 <dark> Funktorsalat, I'm not familiar with the difference.. (I'm from OCaml's List.fold_left)
15:01:26 <Funktorsalat> > foldl (+) 0 [0..10^7]
15:01:33 <lambdabot>   mueval: ExitFailure 1
15:01:35 <Funktorsalat> > foldl' (+) 0 [0..10^7]
15:01:36 <BluShift> alpounet: Ok, I see.
15:01:39 <lambdabot>   50000005000000
15:01:39 <dark> oh. it's strict?
15:01:43 <Funktorsalat> yes :)
15:01:43 <dark> :)
15:01:46 <monochrom> foldl and foldl' have different orders of evaluation
15:02:14 <monochrom> foldl' order is much closer to ocaml order
15:02:17 <Funktorsalat> dark: foldl' in this case keeps just a number in the accumulator, while foldl' keeps an unevaluated thunk there
15:02:20 <Funktorsalat> or so I understand it
15:02:26 <BluShift> Sort of like getters and setters in OO? Something that just comminly exists in most Haskell code?
15:02:30 <BluShift> commonly*
15:02:30 <monochrom> you have a typo
15:02:30 <Veinor> > foldr (+) 0 [0..10^7]
15:02:31 <lambdabot>   *Exception: stack overflow
15:02:32 <Funktorsalat> *while foldl
15:02:37 <Saizan> BluShift: in some sense you're likely to want to use a Monad when you're dealing a lot with functions that return some enriched structure along what you'd consider their core result
15:02:53 <dark> BluShift, it looks like there is no such thing in most haskell code, because haskell structures are immutable!
15:02:54 <sciolizer> BluShift, sort of like Closeable, Iterator, etc. That's what he means by common pattern.
15:03:11 <dark> BluShift, that is, in order to modify some structure, you return a new one o.o
15:03:12 <Saizan> BluShift: so you capture the way to compose such functions in the methods of the Monad class
15:03:34 <BluShift> Oh good lord, my head's splitting o_O
15:03:39 <monochrom> you should learn the basics first. pretend you never knew computing.
15:03:43 <monochrom> I am serious.
15:03:43 <BluShift> Ok.
15:03:52 <dark> well, you saw so with map: map return a new list, instead of modifying the argument..
15:04:01 <Veinor> related: I've always wondered why people keep reimplementing Either in terms of Result = Ok | Error, or what have you
15:04:03 <alpounet> BluShift, their importance is like that of design patterns in OO
15:04:14 <monochrom> @quote monochrom unlearning
15:04:14 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
15:04:15 <BluShift> dark: Because arguments can never be modified, correct?
15:04:21 <Veinor> it exists for a reason, dammit!
15:04:37 <alpounet> once you know your language a bit at least, then you'll tackle Monads and some other common patterns in haskell code
15:04:47 <dark> BluShift, yes..
15:04:56 <alpounet> but just don't focus on these now
15:04:57 <Funktorsalat> Veinor: maybe we need a typeclass for types isomorphic to Either :)
15:04:59 <BluShift> dark: Ok.
15:05:03 <alpounet> you have to understand the basics of Haskell
15:05:06 <BluShift> alpounet: Okie.
15:05:06 <alpounet> how to write functions
15:05:11 <alpounet> how to see what they do in ghci
15:05:30 <alpounet> how to create your own types
15:05:30 <alpounet> etc
15:05:44 <BluShift> Ok, I will do so.
15:05:48 <Funktorsalat> Veinor: class Sum a b sum | sum -> a, sum -> b where { left :: a -> sum; right :: b -> sum; either :: (a -> r) -> (b -> r) -> (sum -> r) }
15:06:02 <BluShift> As if I've never programmed or understood anything beyond "Windows are made of glass" :)
15:06:03 <Veinor> possibly
15:06:26 <Saizan> Funktorsalat: madness
15:06:33 <Veinor> oh well, most of the time I just wind up pattern-matching against the constructors as opposed to using either or left
15:06:38 <Funktorsalat> Saizan: is it?
15:07:15 <Funktorsalat> it's save you from having to look up how each particular parser called the "ok" result ;)
15:07:29 <Funktorsalat> ParseOk, ParseOK, ParseSuccess, Success, Good, ....
15:07:34 <Funktorsalat> *it'd
15:07:37 <Saizan> each particular parser should stick to Either
15:07:37 <Veinor> Right
15:07:57 <dark> Saizan, what if somehow it had to get a third option?
15:08:00 <Veinor> so why don't they?
15:08:10 <Veinor> dark: other than success or failure?
15:08:14 <dark> hmmm...
15:08:21 <ski> dark : `Either (Either Foo Bar) Result' ?
15:08:22 <Saizan> dark: then it wouldn't be an instance of Sum
15:08:30 <Veinor> ski: yo dawg
15:09:05 <ski> @babel eb en yo dawg
15:09:05 <lambdabot> Plugin `babel' failed with: Error: Language eb not supported
15:09:10 <Saizan> unless it makes b an Either, which would kind of defeat the point
15:09:32 <dark> in fact, structurally, there is no need for any other data type.. Either and a type with a single value would suffice..
15:09:45 <Funktorsalat> makeSumN :: Int -> Q [Dec] ...
15:09:57 <Funktorsalat> :D
15:10:02 <dark> oh, no, a pair is better for that
15:10:06 <Saizan> dark: you also need products, function spaces, and recursion
15:10:40 <BluShift> I thought there wasn't supposed to be any assignment operators in Haskell?
15:10:47 <dark> both product and sum are needed?
15:11:01 <dark> lisp can do without sums..
15:11:06 <Funktorsalat> you can encode sums through functions
15:11:20 <Funktorsalat> essentially I just did that in my Sum class
15:11:33 <dark> BluShift, and there is? o.o
15:11:35 <Saizan> dark: you'd need atoms then
15:11:54 <Saizan> (i.e. a Nat type would suffice)
15:12:01 <Funktorsalat> a + b ~ forall r. (a -> r) -> (b -> r) -> r
15:12:18 <Funktorsalat> except the latter doesn't have memoization
15:12:19 <BluShift> dark: Perhaps I'm confusing that for not being able to assign anything to something that's already had something assigned to it.
15:12:22 <BluShift> >_>
15:12:26 <dark> Saizan, but one can encode atoms with pairs of units.. (but well, in the loose type system of lisp)
15:12:34 <Funktorsalat> (which, as I understand it, is a good thing if you're using it just once)
15:12:39 <Saizan> though a simple Nat couldn't carry information about the type of the filds
15:12:48 <Saizan> *fields
15:12:54 <dark> BluShift, <-? it isn't really assignment.. but hey, now I'm also confused..
15:13:09 <alpounet> BluShift, in Haskell you don't assign
15:13:13 <dark> <- inside do is just a shortand for bind
15:13:16 <alpounet> you just give names to expressions
15:13:19 <BluShift> <- is bind, I thought.
15:13:28 <Twey> It's not so simple
15:13:33 <Saizan> BluShift: in fact you never assign something
15:13:39 <Twey> a <- b; c translates to b >>= \a -> c
15:13:43 <BluShift> alpounet: So what's test = ['a', 'b', 'c']?
15:13:56 <Saizan> BluShift: that's a definition of test
15:13:57 <alpounet> BluShift, you give a name to the list containing 'a', 'b', and 'c'
15:14:05 <alpounet> and that name is : test
15:14:11 <Funktorsalat> BluShift: it's similar to how an automaton doesn't allow any mutation on one level (its description is immutable) but clearly mutates itself on another level :)
15:14:13 <Twey> BluShift: It's definition
15:14:24 <Funktorsalat> the State monad and so on are essentially just sugar for writing such automata
15:14:36 <BluShift> alpounet: That sounds identical to immutable types in other languages o_O
15:14:51 <alpounet> that's what it is
15:14:55 <BluShift> Oh.
15:14:56 <BluShift> Ok.
15:15:02 <Funktorsalat> (it makes a (pure) function of a type like (a,s) -> (b,s), where 's' is a state type)
15:15:05 <Saizan> they are all immutable in haskell :)
15:15:10 <BluShift> I see.
15:15:19 <Saizan> though if you really need, there are explicit reference types
15:15:28 <alpounet> you'll see that you can still do I/Os etc, and have mutable stuffs
15:15:40 <alpounet> but don't care about that for the moment
15:15:43 <alpounet> focus on the language itself
15:15:51 <BluShift> Ok.
15:16:04 <Saizan> which themselves don't mutate, but you can change what they refer to.
15:16:23 <BluShift> Saizan: It's just all one transparent operation?
15:16:24 <nschoe> alpounet: and *ex-pe-ri-ment* right? ^^
15:17:18 <alpounet> yeah
15:18:01 <nus> BluShift, transformation
15:18:07 <BluShift> nus: I see.
15:18:20 <BluShift> Why does ++ require that both sides be lists, whereas : does not?
15:18:34 <nus> @type (:)
15:18:37 <lambdabot> forall a. a -> [a] -> [a]
15:18:55 <Twey> BluShift: Because : is the cons constructor for lists, whereas ++ is a concatenation operation for two lists.
15:19:04 <BluShift> Oh.
15:19:07 <nschoe> BluShift: these are two different functions.
15:19:08 <Saizan> because the first argument of (:) is supposed to be an element of the resulting list
15:19:20 <BluShift> Twey: So : never works for two lists, only one item prepended to a list?
15:19:27 <Saizan> the first, in particular
15:19:39 <Saizan> > 1 : [2,3]
15:19:39 <lambdabot>   [1,2,3]
15:19:48 <BluShift> I see.
15:19:55 <Saizan> > [1,2] : [[3,4],[5,6]]
15:19:55 <lambdabot>   [[1,2],[3,4],[5,6]]
15:19:57 <Twey> BluShift: It can work for two lists if you're creating a list of lists.
15:20:05 <Twey> But they're not of the same type.
15:20:22 <nus> @type []
15:20:23 <lambdabot> forall a. [a]
15:20:32 <BluShift> But you can't say 1 2 : [3, 4] and end up with [1, 2, 3, 4]
15:20:45 * ski . o O ( "In the land of Haskell, they are all immutable." )
15:20:48 <Twey> BluShift: The second argument must be a list of the type of the first argument, so if the types are the same then it must be a list of lists of lists of lists, ad infinitum
15:20:53 <ski> > 1 : 2 : [3,4]
15:20:53 <lambdabot>   [1,2,3,4]
15:21:04 <Twey> BluShift: 1 2 is the function ‘1’ applied to the argument ‘2’
15:21:06 <BluShift> I see.
15:21:20 <aristid> > [1,2] ++ [3,4]
15:21:20 <Twey> BluShift: But you can say 1 : 2 : [3, 4], which parses as 1 : (2 : [3, 4])
15:21:22 <lambdabot>   [1,2,3,4]
15:21:25 <ski> BluShift : `1 : 2 : [3,4]' is the same as `1 : (2 : [3,4])', so it is adding one element at a time
15:21:26 <nschoe> BluShift: what might really help you is playing with ghci, especially using the ":t" command.
15:21:41 <BluShift> :t?
15:21:47 <Twey> A.K.A. 1 : 2 : 3 : 4 : [], or 1 : (2 : (3 : (4 : [])))
15:21:47 <aristid> :t [1,2,3,4]
15:21:48 <BluShift> > :t
15:21:48 <lambdabot> forall t. (Num t) => [t]
15:21:49 <lambdabot>   <no location info>: parse error on input `:'
15:21:52 <ski> `:t' is short for `:type'
15:21:53 <BluShift> Type, ok.
15:21:56 <aristid> no, without the >
15:21:58 <ski> :t not
15:21:59 <lambdabot> Bool -> Bool
15:22:06 <Twey> Which is how lists are defined in Haskell, the square-bracket-and-commas notation being merely sugar
15:22:08 <ski> :t take
15:22:09 <lambdabot> forall a. Int -> [a] -> [a]
15:22:36 <sipa> :t return
15:22:37 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:23:40 <dark> why return says m :: * -> * and also Monad m? doesn't Monad m imply in kind * -> *?
15:23:43 * ski wonders if it is possible to convince `:type' to not use `forall', except in higher-rank circumstances
15:23:47 <nschoe> BluShift: do you have RWH?
15:23:54 <BluShift> RWH?
15:23:55 <ski> dark : yeah, it is redundant ..
15:23:58 <ski> @where RWH
15:23:59 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:24:07 <BluShift> No, I do not.
15:24:09 <ski> @where LYAH
15:24:09 <lambdabot> http://www.learnyouahaskell.com/
15:24:21 <dark> BluShift, you can read online..
15:24:23 <BluShift> That's what I'm currently reading ^_^
15:24:29 <unkanon> RWH is sooo slowww
15:24:34 <ski> @where YAHT
15:24:34 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
15:25:00 <ski> unkanon : maybe you'll like the gentle introduction .. ?
15:25:24 <fpletz> my head is now a lmabda-expression: http://asset.soup.io/asset/1196/8300_0b12.jpeg
15:25:28 <dark> i think the system for commenting each paragraph of rwh is awesome
15:25:30 <unkanon> ski: i like the Haskell School of Expression book
15:25:53 <ski> unkanon : ok. i learned from "Haskell: The Craft of Functional Programming"
15:25:59 <unkanon> dark: every book that is publicly reviews uses that system :)
15:26:20 <unkanon> ski: have that as well, love it as well :)
15:26:37 <unkanon> ski: btw i haven't "learned" haskell yet :)
15:26:39 <dark> "every"? on that publisher?
15:26:44 <dark> on haskell community?
15:26:44 <unkanon> too hard for my little brain
15:26:46 <Twey> fpletz: Haha, that's cool.  Is that really you?
15:26:58 <unkanon> dark: on the IT community i'd say
15:27:06 <BluShift> The "head" of a list refers to the first item in a list, yes?
15:27:10 <ski> yes
15:27:18 <ski> > head [2,3,5,7,11]
15:27:19 <lambdabot>   2
15:27:20 <BluShift> Ok, thank you.
15:27:24 <unkanon> dark: "every" = "lots" is the human world of exaggerated statements
15:27:27 <fpletz> Twey: yup, was just made in our laboratory at our local hackerspace :)
15:27:36 <unkanon> dark: /is/in/
15:27:45 <dark> unkanon, uhm. (also i haven't learned haskell yet too. .-.)
15:27:57 <ski> fpletz : haha :)
15:28:26 <BluShift> I like LYAH's monster illustation
15:28:51 <unkanon> dark: if i ever learn it one day i will write my own haskell-ish language
15:29:02 <dark> unkanon, i remember this system used only at gplv3 review.. but anyway this doesn't subtract the awesomeness of commenting individually each paragraph of rhw in a pretty web interface
15:29:22 <unkanon> dark: yep it's pretty awesome
15:29:30 <ski> unkanon : you might try the JohnMeacham approach : learn Haskell by writing a compiler for Haskell .. in Haskell !
15:29:36 <dark> unkanon, I also have such ambitions. if I only were more competent. .-.
15:30:27 <BluShift> I'm feeling that "drop" is very similiar to SQL.
15:30:39 <unkanon> dark: i'm not as clever as that John guy :)
15:30:48 <Twey> BluShift: It isn't.
15:30:48 <dark> @src drop
15:30:49 <lambdabot> drop n xs     | n <= 0 =  xs
15:30:49 <lambdabot> drop _ []              =  []
15:30:49 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
15:31:06 <dark> BluShift, I find "take" is similar to sql "limit"
15:31:07 <nschoe> Does anyone know a good Haskell howto over network programming? (Don't really liked the chapter on RWH)?
15:31:35 <Twey> nschoe: Just look at the Haddock… it's pretty self-evident
15:31:59 <unkanon> dark: i tried Clean, have you looked at it ever?
15:32:00 <BluShift> Twey: No?
15:32:13 <BluShift> I could see it being used similiar to "DROP COLUMN"
15:32:13 <dark> BluShift, drop seems like the complement of take.. it does not destroy nothing like a table
15:32:23 <ski> <http://repetae.net/computer/jhc/jhc.shtml> "My reasoning was simple, by writing a Haskell compiler in Haskell I will double my language learning speed since I will not only have to learn how to program in it by forcing myself to complete a non-trivial project, but also its subtle semantics and dark corners since I actually needed to implement it correctly. Writing a compiler is also doubly efficient to begin with, since if 
15:32:23 <ski> you self-compile improvements not only give you a better optimizer, but also speed up your self-compiled compiler. All in all I figure I was making very good use of my time. For some reason, when I explain my reasoning to other people they look at me like I am crazy, but I can detect no flaw in my logic."
15:32:26 <dark> unkanon, no..
15:32:32 <BluShift> Fine, nevermind. Gawd >_>
15:32:56 <nschoe> Twey: (you mean the documentation of the network modules on haskell.org?)
15:32:56 <Twey> Right.
15:33:00 <Twey> nschoe: Yes
15:33:27 <Twey> nschoe: All that's different (at least in the high-level Network module) is that there are some special functions that connect/accept/whatever, and give you a Handle
15:33:29 * ski thinks `take' is similar to `LEFT$()' ..
15:33:34 <Twey> nschoe: After that, it's all just handle IO
15:33:39 <dark> BluShift, you can use (At postgres) something similar to limit, called "offset", to discard the first N results. I used it like limit 10 offset 20 to get results from a certain window. offset would be like drop..
15:34:11 <nschoe> Twey: Hum but... one needs to have some background in network programming? I don't know much about it.
15:34:21 <Twey> nschoe: Ah, yes, it would be confusing in that case.
15:34:38 <alpounet> but not *that* much
15:34:44 <alpounet> it's still pretty straightforward to use
15:35:00 <Twey> I remember I found the socket model quite tricky to pick up
15:35:07 <nschoe> So the doc will suffice, alpounet ?
15:35:14 <nschoe> Twey: And how did you get the thing then? ^^
15:35:24 <Twey> Hacking around in C for weeks >.>
15:35:31 <dark> unkanon, clean looks interesting. at least the syntax, at wikipedia examples..
15:35:43 <nschoe> Twey: xD very poor knowledge in C :/
15:35:54 <Twey> Yeah, it's not something I'd advise you to try anyway
15:36:05 <Twey> The docs will suffice for the Haskell part, but you might find it useful to read up on the Linux/UNIX/BSD socket model first
15:36:12 <unkanon> dark: Clean came before Haskell, so haskell's syntax is a lot like clean. clean doesnt use monads i think, and to solve the IO problem it uses uniqueness.
15:36:30 <unkanon> dark: i've written some code using the concept of uniqueness in Clean but i couldnt wrap my head around it
15:36:31 <nschoe> Well I'll try reading the doc. If I feel like I need to read more about sockets, I will. Thanks.
15:36:57 <dark> unkanon, uniqueness? o.o
15:37:22 <dark> like linear type?
15:37:57 <BluShift> > take 1000 (cycle "LOL ")
15:37:58 <lambdabot>   "LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LO...
15:38:03 <BluShift> :D
15:38:26 <Twey> λb truncates anyway
15:38:33 <BluShift> I see that
15:38:36 <Twey> > cycle "OL"
15:38:37 <lambdabot>   "OLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOL...
15:38:39 <BluShift> LAME.
15:38:52 <nschoe> Damn, now lambdabot is flooding^^
15:39:00 <unkanon> dark: it's a way to "change" the contents of a variable without really changing it, you're just using the same name but it's a different variable because the one before it went out of scope
15:39:03 <BluShift> Really?
15:39:06 <Twey> nschoe: You need a bigger terminal… that's not even one whole line for me :þ
15:39:11 <BluShift> Or does it kill itsself?
15:39:24 <nschoe> Twey: was joking it's not a line either ^^
15:39:29 <Twey> Ah :þ
15:39:31 <BluShift> Oh.
15:39:39 <BluShift> I thought I was being clever with that :P
15:39:52 <BluShift> But apparently I've been out-clevered.
15:40:01 <nschoe> (But if someone knows how to make irssi display bigger fonts... I'll pay him a lot :P )
15:40:13 <Twey> @vixen Are you cleverer than BluShift?
15:40:16 <ski> <http://pll.cpsc.ucalgary.ca/charity1/packages/clean/stdenv/StdFunc.dcl> (that's an old file, but) this has a few basic operations for state monad in Clean
15:40:17 <lambdabot> no
15:40:22 <Twey> BluShift: You're safe
15:40:30 <Twey> The Singularity isn't here yet
15:40:49 <dark> unkanon, i understand something: if you want to update a functional structure, you actually return a new one. so if you are eg. reading chars from stdin, you can receive the I/O state as argument, and return a new state
15:40:52 <ddarius> Twey: Or the computers are covering up.
15:40:56 <BluShift> > take 5 (cycle "ha")
15:40:56 <ski> unkanon : ^
15:40:57 <lambdabot>   "hahah"
15:41:28 <unkanon> ski: looking at the link
15:41:28 <Twey> ddarius: Possible
15:41:34 * hackagebot expat-enumerator 0.1.0.2 - Enumerator-based API for Expat  http://hackage.haskell.org/package/expat-enumerator-0.1.0.2 (JohnMillikin)
15:41:36 * hackagebot yajl-enumerator 0.2.0.3 - Enumerator-based interface to YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-enumerator-0.2.0.3 (JohnMillikin)
15:41:58 <unkanon> dark: yes and Clean knows that. i guess uniqueness is just an attempt to make that more pallatable
15:41:59 <dark> unkanon, your program will continue to be functional, because it will read a certain character for the first state, another for the second state.. and "would" read that first character again if it were to read the first state again. but in order to not keep previous read characters in memory, one can restrict re-use of this state..
15:42:05 <unkanon> dark: but to me it was still complicated
15:42:27 <dark> unkanon, encapsulating it on a monad.. or ruling out the use of it after the first use
15:43:01 <unkanon> dark: i guess then, that Clean does the latter
15:43:11 <ski> unkanon : the uniqueness typing means that since the reference to the "old value" was the last reference to it, the implementation can use update-in-place to create the "new value"
15:43:16 <unkanon> ski: that link's way over my head :)
15:43:35 * hackagebot libxml-enumerator 0.4.0.2 - Enumerator-based API for libXML's SAX interface  http://hackage.haskell.org/package/libxml-enumerator-0.4.0.2 (JohnMillikin)
15:43:37 <dark> hm o.o
15:43:39 <unkanon> ski: oh ok, thanks for explaining it to us :)
15:43:45 <ski> unkanon : btw, Mercury uses basically the same idea as Clean (except there it is uniqueness modes, instead of in types)
15:43:58 <edwardk> ddarius: in the meantime, singularity humor abounds: http://questionablecontent.net/
15:44:05 <ski> unkanon : that link is (or at least, was) part of the standard library of Clean
15:44:28 <unkanon> ski: never looked at mercury
15:44:51 <ski> Mercury is like a saner, statically typed, statically moded version of Prolog
15:44:55 <unkanon> ski: ugh, it looks like prolog
15:45:06 <ski> well, it *is* a logic programming language
15:45:19 <ski> (it is a functional programming language, as well)
15:45:27 <dark> another i/o model is to consider the read state as a lazy list, and just keep reading from it. (haskell did this in the beginning, didn't it?)
15:45:27 <BluShift> Pardon my French, but I just wanted to let you guys know that in general, you're all much more amiable (and intelligent, it would appear) than the folks over in #python :P
15:45:48 <nschoe> Twey: am I dumb or missing something: why can't I find anything related to network in here: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ ?
15:45:49 <ski> dark : yeah, basically the `Dialogue' I/O model
15:45:49 * sipa doesn't see French
15:45:51 <unkanon> #haskell is one of the best channel in freenode people-wise
15:46:03 <unkanon> that's why i hang here sometimes, even though i don't know haskell :)
15:46:10 <BluShift> I find ##php to be quite fantastic as well :)
15:46:20 <unkanon> sipa: just pretend he said "fuck" at the end of it
15:46:28 <sipa> unkanon: you've been in all 39513 channels here? :)
15:46:44 <luite> unkanon: watch out, before you know it you'll be writing your own monad tutorial ;)
15:46:57 <unkanon> sipa: 39513 ?? no, only in 39512, what's the 39513rd? ;)
15:47:02 <Twey> nschoe: http://hackage.haskell.org/package/network
15:47:12 <edwardk> sipa: we spread out and checked them. split 657 ways its not much work all told.
15:47:18 <unkanon> luite: monads are like burritos!
15:47:27 <nschoe> Twey: ho... thanks (I feel idiot now :/ )
15:48:16 <edwardk> unkanon: spacesuit burritos. they sound rather unpleasant if you ask me.
15:48:18 <dark> BluShift, php was fun to learn.. to see I could build a page that get /?a=1&b=2 and print 3..
15:48:29 <dark> but for most part, I don't have so good memories
15:48:46 <unkanon> edwardk: no no, they're like burritos INSIDE spacesuits!
15:49:05 <edwardk> unkanon: that sounds more like a burrito transformer. ;)
15:49:16 <Darkovsky> okay
15:49:24 <dark> I actually found my old php code here, from, hmm, 2004, 2005.. it's.. a mess
15:49:26 <unkanon> if you want to microwave a burrito, you put it inside a spacesuit, then put your microwave inside the same spacsuit, then you go inside the space suit and microwave the burrito
15:49:54 <Darkovsky> Passing [Array Int String]. I map a function that goes Array Int String -> String   to that
15:50:01 <Darkovsky> That gives me [[String]], right?
15:51:54 <raceRider> what's the fastest way to concat a Char with [Char] to get another [Char] ? 
15:52:10 <Twey> raceRider: On the front?  :
15:52:16 <edwardk> unkanon: yes, but given a distributive law that lets you take a burrito full of spacesuits to a spacesuit full of burritos you get the same thing. =)
15:52:16 <Lemmih> > 'a' : "bc"
15:52:17 <lambdabot>   "abc"
15:52:20 <Twey> It's O(1): doesn't get much faster than that
15:52:32 <Twey> On the back would be ++ [c]
15:52:37 <raceRider> thanks
15:52:40 <Twey> > "ab" ++ ['c']
15:52:42 <lambdabot>   "abc"
15:52:45 <Twey> Which is not fast
15:52:56 <Twey> If you're doing that a lot, consider doing… something else.
15:53:11 <unkanon> Twey: great suggestion :)
15:53:13 <gwern> > 1.5^12?
15:53:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:53:14 <Twey> DLists or functions or a big reverse-'n'-concat at the end, or something.
15:53:15 <gwern> > 1.5^12
15:53:16 <lambdabot>   129.746337890625
15:53:40 <unkanon> edwardk: lol
15:53:48 <edwardk> or a Data.Sequence
15:58:27 <Darkovsky> FfffFFFfFFFFFFF
15:58:33 <Darkovsky> ;_;
15:58:47 * hackagebot libxml-sax 0.6.0.2 - Bindings for the libXML2 SAX interface  http://hackage.haskell.org/package/libxml-sax-0.6.0.2 (JohnMillikin)
15:59:15 <Darkovsky> :t tail . init
15:59:15 <lambdabot> forall a. [a] -> [a]
15:59:21 <Darkovsky> .... oh
15:59:53 <Funktorsalat> does anyone get the quip behind this book cover? http://www.amazon.com/Real-World-Functional-Programming-Examples/dp/1933988924
16:00:55 <unkanon> Funktorsalat: can you paste the quip?
16:01:38 <Twey> It's ‘With examples in F# and C#’
16:01:39 <Twey> ;)
16:01:55 <Funktorsalat> unkanon: it's pictorial. I mean what functional programming has to do with a gentleman dressed like 1.5 or so centuries ago
16:01:57 <Funktorsalat> (more?)
16:01:59 <unkanon> Twey: then I don't get it :D
16:02:14 <unkanon> Funktorsalat: oh, they've xplained that somewhere in their website
16:02:22 <unkanon> Funktorsalat: they explain why they chose that guy
16:03:05 <lopex> he looks immutable
16:03:10 <Funktorsalat> btw the url is from a google hit, not my referral code or anything :p
16:03:17 <Darkovsky> .... ;_;
16:03:24 <unkanon> lopex: hahaha
16:03:45 <unkanon> he looks monadic to me
16:04:02 <lopex> lifted ?
16:04:15 <unkanon> precisely
16:04:33 <unkanon> i think it'd be a better quip if he were wearing a spacesuit and holding a burrito
16:04:44 <unkanon> edwardk: ^
16:04:51 <Darkovsky> > let reallast = last . init in reallast ["derp","herp",""]
16:04:52 <lambdabot>   "herp"
16:05:19 <Darkovsky> > let reallast = last . init in (reallast ["derp","herp",""]) == "herp"
16:05:20 <lambdabot>   True
16:05:28 <Darkovsky> Well what the f.
16:05:44 <unkanon> wow that is strange
16:05:55 <ski> Darkovsky : no, `[String]'
16:05:56 <unkanon> maybe lambdabot is caching the last result, lol
16:06:21 <shachaf> unkanon: What is strange?
16:06:24 <Darkovsky> ski, ???
16:06:45 <ski> <Darkovsky> Passing [Array Int String]. I map a function that goes Array Int String -> String   to that
16:06:46 <dark> to lift: plagiarize: take without referencing from someone else's writing or speech; of intellectual property 
16:06:46 <ski> <Darkovsky> That gives me [[String]], right?
16:06:49 <Zhuangzi> That lambdabot result looks fine.
16:07:17 <unkanon> shachaf: i thought it was a function for taking the last item, nvm
16:07:25 <Darkovsky> ski, I pass a list in [Array Int String] form
16:07:40 <Darkovsky> Then I map Array Int String -> [String] over it
16:07:46 <ski> > (last . filter (not . null)) ["derp","herp",""]
16:07:47 <lambdabot>   "herp"
16:08:03 <Darkovsky> That should certainly be [[String]]
16:08:07 <ski> Darkovsky : ok .. that's not what you said earlier, though
16:08:14 <Darkovsky> Oh
16:08:56 <Twey> ski: No, it gives you [String]
16:09:04 <Twey> Errr
16:09:07 <Twey> Darkovsky: ^
16:09:11 <Twey> :t map
16:09:11 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:09:22 <Twey> If a = Array Int String, and b = String…
16:09:25 <EvanR> b = [String], [b] = [[String]
16:09:26 <EvanR> ]
16:09:35 <ski> Twey : `Array Int String -> String' vs. `Array Int String -> [String]'
16:09:58 <Twey> Ah, said something else, huh
16:10:13 <ski> Twey : Darkovsky said both things :)
16:10:32 <ski> (but appears to only have meant the latter)
16:11:30 * Zhuangzi is compelled to ponder, by the posted book, what a "Object Oriented Programming / with examples in Haskell and Scheme" might look like. An Asiatic elephant in a straight-jacket?
16:12:18 <dark> Zhuangzi, isn't F# functional enough?
16:13:04 <ddarius> edwardk: Did you take your pills or are you still dying slightly faster than normal?
16:15:07 <pumpkin> omg edwardk 
16:15:40 <Zhuangzi> dark: For what purpose?
16:21:28 <Darkovsky> > let mkarray list = listArray (0, (length list - 1)) list in mkarray ["herp","derp","lerp",""]
16:21:29 <lambdabot>   array (0,3) [(0,"herp"),(1,"derp"),(2,"lerp"),(3,"")]
16:22:19 <dark> Zhuangzi, giving functional examples
16:23:10 <Twey> > let mkarray = join $ listArray . (1, ) . length in mkarray ["herp", "derp", "lerp", ""]
16:23:11 <lambdabot>   <no location info>: parse error on input `)'
16:23:18 <Twey> No tuple sections?
16:23:25 <Twey> > let mkarray = join $ listArray . (,) 1 . length in mkarray ["herp", "derp", "lerp", ""]
16:23:26 <lambdabot>   array (1,4) [(1,"herp"),(2,"derp"),(3,"lerp"),(4,"")]
16:24:38 <Darkovsky> Oh FFS, there's my problem :|
16:25:23 <Darkovsky> > reverse . drop 4 . reverse $ "SS_SH_P_M3_PAR;"
16:25:24 <lambdabot>   "SS_SH_P_M3_"
16:25:27 <Darkovsky> Yep.
16:25:39 <Darkovsky> WHAt.
16:25:49 <Darkovsky> EMPTY LIST? argaragmaa;lmanbajn ;_;
16:26:01 <Darkovsky> > reverse . drop 5 . reverse $ "SS_SH_P_M3_PAR;"
16:26:02 <lambdabot>   "SS_SH_P_M3"
16:27:18 <edwardk> ddarius: still hacking up bits of my lungs, but i'll be okay ;)
16:27:19 <ski> > fmap reverse . stripPrefix (reverse "_PAR;") . reverse $ "SS_SH_P_M3_PAR;"
16:27:20 <lambdabot>   Just "SS_SH_P_M3"
16:27:24 <edwardk> heya pumpkin
16:27:37 <pumpkin> hi :)
16:27:38 <Darkovsky> This isn't a contest, guys :P
16:27:50 <Darkovsky> Just trying to figure out why a search is returning an empty list.
16:28:19 <edwardk> Darkovsky: anything said to lambdabot on channel is basically a free license to start golfing it down to nothing ;)
16:28:39 <megajosh2> @hoogle stripPrefix
16:28:39 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
16:28:44 <megajosh2> Okay that'll be useful...
16:28:56 <burp> minecraft halloween update is out
16:29:15 <Darkovsky> > reverse . drop 5 . reverse . last $ ["derp","derp","SS_SH_P_M3_PAR;"]
16:29:16 <lambdabot>   "SS_SH_P_M3"
16:29:17 <ski> @let stripSuffix :: Eq a => [a] -> [a] -> Maybe [a]; stripSuffix suffix = fmap reverse . stripPrefix (reverse suffix) . reverse
16:29:19 <lambdabot>  Defined.
16:29:33 <ski> > stripSuffix "_PAR;" "SS_SH_P_M3_PAR;"
16:29:34 <lambdabot>   Just "SS_SH_P_M3"
16:30:26 <ski> megajosh2 : often useful in pattern guards or view patterns, to substitute for the lack of `<expr> ++ <pat>' patterns
16:31:13 * ski idly wonders what this "minecraft halloween update" which "everyone" seems to be talking about is
16:32:20 <Darkovsky> Okay, I'm clueless.
16:32:50 <Darkovsky> ... Oh. FML
16:33:33 * Twey chuckles.
16:33:50 <Darkovsky> .... ;_;
16:34:41 <ski> Darkovsky : what seems to be the problem ?
16:35:16 <Darkovsky> > reverse . (:) ';' . drop 5 . reverse . last . init $ ["derp","herp","lol","SS_SH_TR_M3P_PAR",""]
16:35:17 <lambdabot>   "SS_SH_TR_M3;"
16:35:30 <Darkovsky> Wait, I don't want the ;
16:35:39 <brisbin> ski: seems a common occurance to take popular video cames and release a "zombie" patch where the gameplays the say but the bad guys are zombies
16:35:43 <adimit> OK guys, I'm going mad right now. Tell me that this is nonsense in 2 ways: a) that `data` declaration doesn't compile (looks more like it was supposed to be a class.) b) eval will always either give `error`, or never terminate. No matter what, no matter the definition of Steps: http://hpaste.org/40998/infinite (This is from Swierstra's paper on uu-parsinglib)
16:35:43 <brisbin> i have to assume this is one of those
16:35:54 <Darkovsky> > reverse . drop 5 . reverse . last . init $ ["derp","herp","lol","SS_SH_TR_M3P_PAR",""]
16:35:55 <lambdabot>   "SS_SH_TR_M3"
16:35:56 <brisbin> (holy typos...)
16:36:11 <adimit> My brain's been tortured by the continuation-passing style enough, and this is giving me the rest :-|
16:37:02 <Twey> CPS isn't brain-torture
16:37:12 <mauke> adimit: that data declaration uses GADT syntax
16:37:16 <adimit> Twey: it isn't. I've gotten my head around it.
16:37:17 <ski> Darkovsky : was there something wrong with using `stripPrefix' .. ?
16:37:25 <Twey> brisbin: Aren't the bad guys already zombies in Minecraft?
16:37:26 <adimit> mauke: ah, ok. that makes more sense now. Thanks. 
16:37:30 * ski tries to look wounded
16:37:34 <brisbin> Twey: i wouldn't know
16:38:05 <adimit> but, but, `eval` can't possibly return a result, can t?
16:38:07 <mauke> adimit: b) no, the third case goes into f
16:38:07 <adimit> *it?
16:38:13 <brisbin> i liked your stripPrefix, ski... there, there
16:38:14 <ski> adimit : CPS ? where, where ?
16:38:30 <adimit> ski: uu-parsinglib. tons of it.
16:38:33 <Darkovsky> > let findtag ship | tail.init ship == "SS_SH_TR_M3P_PAR" = True | otherwise = False in filter findtag [["no","no","no",""],["yea","SS_SH_TR_M3P_PAR",""]]
16:38:34 <lambdabot>   Couldn't match expected type `[a]'
16:38:34 <lambdabot>         against inferred type `GHC.Types...
16:38:37 <mauke> adimit: and f can return whatever it wants
16:38:42 <Darkovsky> ahhhh errors ;_;
16:39:04 <adimit> mauke: oh. so basically f has to be a const in order for it to return?
16:39:12 <mauke> adimit: no, why?
16:39:20 <adimit> (because otherwise `eval l` will first have to be evaluated.
16:39:20 <benmachine> adimit: not necessarily a const, just non-strict
16:39:21 <ski> adimit : s/error/error "fnord !"/
16:39:27 <mauke> adimit: no, it won't
16:39:36 <benmachine> adimit: it could be (() :), for example
16:39:41 <adimit> d'oh!
16:39:52 <mauke> :t (() :)
16:39:53 <lambdabot> [()] -> [()]
16:39:55 <adimit> sure, it could just leave it thukned. Didn't think about that.
16:39:59 <adimit> *thunked.
16:40:07 <benmachine> adimit: have you seen the definition of fix?
16:40:11 <mauke> *didn't thunk about that
16:40:19 <ski> adimit : or `eval (Apply (const "foo !") Fail)'
16:40:26 <adimit> lol. benmachine: no. I'll go and see.
16:40:34 <benmachine> adimit: no I can give it to you
16:40:35 <mauke> ski: that's a const
16:40:40 <benmachine> adimit: it's just a similar idea
16:40:54 <Darkovsky> >let reallast = tail.init in let findtag xs | reallast xs == "SS_SH_TR_M3P_PAR" = True | otherwise = False in filter findtag [["no","no","no",""],["yea","SS_SH_TR_M3P_PAR",""]]
16:40:56 <adimit> aha. Thank you guys, for explaining this.
16:41:00 <ski> mauke : .. yeah, i just noticed "oh. so basically f has to be a const .."
16:41:03 <Darkovsky> > let reallast = tail.init in let findtag xs | reallast xs == "SS_SH_TR_M3P_PAR" = True | otherwise = False in filter findtag [["no","no","no",""],["yea","SS_SH_TR_M3P_PAR",""]]
16:41:03 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:41:04 <lambdabot>         against inferred type...
16:41:05 <benmachine> adimit: fix f = f (fix f) -- have fun with that one
16:41:08 <Darkovsky> uh oh
16:41:12 <Darkovsky> Whhyyyy...
16:41:15 <mauke> @src fix
16:41:15 <lambdabot> fix f = let x = f x in x
16:41:16 <Darkovsky> ;_;
16:41:18 <benmachine> adimit: (actually, it's let x = f x in x, but that's equivalent)
16:41:30 <Darkovsky> :t reallast = tail.init
16:41:30 <lambdabot> parse error on input `='
16:41:42 <benmachine> adimit: I'm not claiming this will help you understand, just thought you might think it was interesting :P
16:41:52 <mauke> | otherwise = False looks unnecessary
16:42:01 <Darkovsky> :t reallast xs = tail . init $ xs
16:42:01 <lambdabot> parse error on input `='
16:42:04 <ski>   fix f = x
16:42:06 <ski>     where
16:42:06 <ski>     x = f x
16:42:13 * ski finds that version prettier
16:42:15 <adimit> benmachine: thanks. yeah, it's interesting. Kinda reminds of a Y-combinator.
16:42:17 <mauke> useless use of multiple messages
16:42:25 <mauke> fix f = x where x = f x
16:42:31 <benmachine> adimit: mm, it does the same thing, kind of
16:42:38 <mauke> adimit: that is the Y combinator
16:42:40 <Darkovsky> :t tail . init
16:42:41 <lambdabot> forall a. [a] -> [a]
16:42:53 <benmachine> mauke: I thought the Y combinator was a specific implementation
16:42:54 <adimit> ha. I still have some brain left. That's good to know.
16:42:57 <Darkovsky> BLOODY HELL I AM RETARDED ;_;
16:43:00 <dark> mauke, i heard it is not, because the y combinator isn't typeable in haskell
16:43:04 <Darkovsky> :t last.init
16:43:04 <lambdabot> forall a. [a] -> a
16:43:11 <benmachine> i.e. λg. (λx. g (x x)) (λx. g (x x)) -- this is not fix
16:43:12 <mauke> benmachine: really?
16:43:16 <adimit> mauke: wasn't the Y-combinator only possible in untyped lambda calc?
16:43:24 <benmachine> mauke: "I thought" -- I'm not an expert :P
16:43:28 <mauke> me neither
16:43:33 <adimit> afaik it's not possible in typed L-calc.
16:43:40 <mauke> depends on how you type it
16:43:41 <brisbin> > let findTag = ("foo" `elem`) in filter findTag [["no","no"],["yes","foo"]]
16:43:42 <lambdabot>   [["yes","foo"]]
16:43:43 <dolio> Yes, I think that's specifically the Y-combinator.
16:43:45 <ski> dark : you can do it, with `newtype Santa a = Wrap {unWrap :: Santa a -> a}'
16:43:53 <dark> y combinator is a fixed point combinator..
16:43:57 <Darkovsky> > let findtag xs | last.init xs == "SS_SH_TR_M3P_PAR" = True in filter findtag [["no","no","no",""],["yea","SS_SH_TR_M3P_PAR",""]]
16:43:57 <lambdabot>   *Exception: <interactive>:1:145-198: Non-exhaustive patterns in function fi...
16:44:00 <dark> ski, m? @.@
16:44:03 <Darkovsky> ...
16:44:03 <dolio> There are fixpoint combinators that ultimately do the same thing, but are different terms, and have different names.
16:44:08 <Darkovsky> You need the | otherwise
16:44:18 <Darkovsky> @ mauke
16:44:24 <benmachine> Darkovsky: no you don't
16:44:31 <mauke> Darkovsky: findtag xs = last (init xs) == "SS_SH_TR_M3P_PAR"
16:44:32 <benmachine> Darkovsky: you can't just remove it, but that doesn't mean you need it either
16:44:43 <ski> (turing fixed-point combinator vs. ackerman fixed-point combinator)
16:44:46 <dark> "One well-known fixed point combinator in the untyped lambda calculus is Haskell Curry's Y = λf·(λx·f (x x)) (λx·f (x x)). The name of this combinator is incorrectly used sometimes to refer to any fixed point combinator."
16:44:46 <Darkovsky> I see what you mean now
16:44:51 * alpounet remembers when he discovered wht "ski" was
16:44:57 <ski> (benmachine's was the turing one)
16:44:58 <brisbin> > let findtag xs = last . init xs == "foo" in [["no","no"],["yes","foo",""]]
16:44:59 <lambdabot>   [["no","no"],["yes","foo",""]]
16:45:06 <brisbin> whoops
16:45:09 <benmachine> alpounet: excessive! sk is sufficient :P
16:45:17 <alpounet> haha
16:45:23 <mauke> :t ap const id
16:45:24 <lambdabot> forall b. b -> b
16:45:30 <benmachine> :t ap const const
16:45:31 <lambdabot> forall b. b -> b
16:45:32 <adimit> nice. mauke, benmachine, thank you for your help!
16:45:37 <benmachine> adimit: np :)
16:45:40 <Rotaerk> hmm is there a haskell operator for coalescing a maybe; i'm trying to come up with one for my F# utilities library (because F# has no standard one)
16:45:57 <Rotaerk> thinking |?, but if there's one in haskell I might copy it
16:46:00 <mauke> Rotaerk: maybe, fromMaybe
16:46:03 <adimit> I wish uu's parsers were a bit easier to understand. >.<
16:46:07 <mauke> depending on which one you want
16:46:10 <Rotaerk> oh so no operator, just a function
16:46:12 <Darkovsky> > let findtag xs = last . init xs == "SS_SH_TR_M3P_PAR" in filter findtag [["no","no","no",""],["yea","SS_SH_TR_M3P_PAR",""]]
16:46:13 <ski> Rotaerk : how do you mean ?  `join :: Maybe (Maybe a) -> a' ?
16:46:13 <lambdabot>   []
16:46:19 <Darkovsky> WAT?
16:46:21 <mauke> Rotaerk: `fromMaybe`
16:46:24 <Rotaerk> k
16:46:26 <Darkovsky> I must be using something wrong
16:46:26 <Eduard_Munteanu> :t fromJust
16:46:27 <lambdabot> forall a. Maybe a -> a
16:46:32 <mauke> or mplus?
16:46:35 <BluShift> What's the easiest way to do a "power" operation to two numbers in parallel?
16:46:49 <Rotaerk> mauke, oh, wait, those aren't coalesce
16:46:51 <Darkovsky> Eduard_Munteanu, what library is that one from?
16:46:53 <BluShift> par num**num2 isn't working for me? (noob question)
16:46:54 <Darkovsky> fromJust
16:47:05 <Eduard_Munteanu> Darkovsky: Data.Maybe, it's standard
16:47:06 <mauke> Rotaerk: mplus?
16:47:12 <Twey> BluShift: Errr, that's not quite what ‘parallel’ means
16:47:14 <Darkovsky> Yea, screw filter.
16:47:15 <ski> @index fromMaybe
16:47:16 <lambdabot> Data.Maybe
16:47:17 <Rotaerk> ah yea that'd probably be it
16:47:24 <Rotaerk> mplus
16:47:26 <ski> @type catMaybes
16:47:27 <Eduard_Munteanu> :t par
16:47:27 <lambdabot> forall a. [Maybe a] -> [a]
16:47:28 <lambdabot> forall a b. a -> b -> b
16:47:35 <Eduard_Munteanu> The second
16:47:42 <Eduard_Munteanu> BluShift: 
16:47:44 <BluShift> Eduard_Munteanu: That output is absolutely no help to me.
16:47:45 <brisbin> mapMaybe always comes in handy for me
16:47:49 <Rotaerk> F# syntax for this would be like:  None |? 5
16:47:52 <Rotaerk> resolves to 5
16:47:56 <Eduard_Munteanu> BluShift: it evaluates two expressions, returns one
16:47:59 <Rotaerk> Some 6 |? 5
16:48:01 <Rotaerk> resolves to 6
16:48:07 <mauke> Rotaerk: fromMaybe
16:48:16 <BluShift> Eduard_Munteanu: Returns 1 how? Adds them?
16:48:19 <ski> Rotaerk : so `fromMaybe 5 Nothing' and `fromMaybe 5 (Just 6)'
16:48:19 <BluShift> Subtracts?
16:48:23 <Rotaerk> ah
16:48:26 <Rotaerk> gotcha
16:48:39 <Twey> BluShift: You'd want to do something like let (r, l) = (num1 ** num2, num3 ** num4) in something_that_uses (par l r) >> something_that_uses l
16:48:39 <Eduard_Munteanu> BluShift: it's a hint to the runtime.
16:48:40 <Darkovsky> Oh my god whyyyyyy ;_;
16:48:47 * benmachine is reading about alternative fixed point combinators and finds >>> Z = lambda f: (lambda x: f(lambda *args: x(x)(*args)))(lambda x: f(lambda *args: x(x)(*args)))
16:48:51 <benmachine> beautiful.
16:49:08 <Twey> BluShift: It's about execution/evaluation order — it's a performance thing.
16:49:08 <Eduard_Munteanu> BluShift: you use it like foo = par a b, so foo ends up b and a is evaluated in parallel.
16:49:14 <Twey> BluShift: You shouldn't be worrying about it yet.
16:49:34 <BluShift> Twey: But it's so.... cool!
16:49:37 <BluShift> :P
16:49:59 <Eduard_Munteanu> (a isn't assigned to anything)
16:50:01 <Twey> It's actually kind of ugly.
16:50:07 <BluShift> How?
16:50:15 <Darkovsky> > let findtag xs = last.init xs == "HERP" in fromJust . find findtag $ [["nope","lol","haha"],["YESBABY","HERP",""]]
16:50:17 <lambdabot>   *Exception: Maybe.fromJust: Nothing
16:50:26 <Darkovsky> Okay, puzzle that one please :(
16:50:49 <Eduard_Munteanu> > fromJust Nothing
16:50:50 <lambdabot>   *Exception: Maybe.fromJust: Nothing
16:50:56 <Darkovsky> last.init ["YESBABY","HERP",""]
16:51:01 <BluShift> Twey: How?
16:51:02 <Darkovsky> > last.init ["YESBABY","HERP",""]
16:51:03 <lambdabot>   "YP"
16:51:11 <brisbin> Darkovsky: you need  $ in there somewhere
16:51:16 <Twey> BluShift: We prefer not to have to explicitly talk about evaluation order in Haskell.
16:51:23 <brisbin> > last $ init ["YESBABY","HER",""]
16:51:24 <lambdabot>   "HER"
16:51:26 <benmachine> Darkovsky: oh heh
16:51:37 <Twey> Darkovsky: findtag xs = last . init xs == "HERP" is… wrong.
16:51:44 <benmachine> > (last.init) ["lol", "butts", "hi"]
16:51:45 <lambdabot>   "butts"
16:51:56 <BluShift> Twey: Why? How do we know how functions will be evaluated if we don't?
16:51:58 <Darkovsky> All. This. Pain. For that little error.
16:52:02 <Darkovsky> o.o
16:52:08 <Twey> :t let findtag xs = last . init xs == "HERP" in findtag
16:52:08 <Eduard_Munteanu> BluShift: did you read on lazy evaluation?
16:52:08 <lambdabot> [[Char]] -> Bool
16:52:42 <Twey> This only works because of Caleskell, I think.
16:52:43 * benmachine writes this down as evidence in his case against excessive polymorphism
16:52:48 <Twey> :t let findtag xs = last P.. init xs == "HERP" in findtag
16:52:49 <lambdabot> Couldn't find qualified module.
16:52:53 <Twey> :t let findtag xs = last Prelude.. init xs == "HERP" in findtag
16:52:54 <lambdabot>     Couldn't match expected type `a -> [a1]'
16:52:54 <lambdabot>            against inferred type `[a2]'
16:52:54 <lambdabot>     In the second argument of `(GHC.Base..)', namely `init xs'
16:53:03 <Twey> That's what I'd expect, usually.
16:53:16 <Eduard_Munteanu> What's this Caleskell? Did Cale write a Prelude or something? :)
16:53:24 <ski> evening, augustss
16:53:26 <mauke> no, Cale just runs lambdabot 
16:53:33 <Eduard_Munteanu> Ah.
16:53:45 <Twey> Eduard_Munteanu: He made a few generalisations in λb that aren't in the Prelude
16:53:49 <Twey> :t (.)
16:53:49 <BluShift> Eduard_Munteanu: Yes.
16:53:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:53:57 <Eduard_Munteanu> I see.
16:53:58 <Twey> For example.
16:54:05 <mauke> :t (++)
16:54:06 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:54:08 <mauke> any others?
16:54:15 <benmachine> :t flip
16:54:16 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:54:16 <Twey> There are, but I can't remember
16:54:18 <mauke> :t id
16:54:19 <lambdabot> forall a. a -> a
16:54:24 <Twey> Oh, that's it.
16:54:25 <Eduard_Munteanu> Makes sense.
16:54:33 <benmachine> no-one's quite sure if flip is actually useful
16:54:35 <Eduard_Munteanu> Wait, what's id in prelude?
16:54:38 <Darkovsky> Okay, I'm ready.
16:54:41 <benmachine> Eduard_Munteanu: that.
16:54:55 <benmachine> Eduard_Munteanu: it's generalised in Control.Category but lambdabot doesn't use that generalisation
16:55:19 <BluShift> Eduard_Munteanu: But we can't tell it to evaluate certain things at certain times, if we want, and then have it just default to lazy when necessary (like lists that are extremely long, for example)?
16:55:48 <Eduard_Munteanu> BluShift: you can, see 'seq' and strictness annotations
16:56:10 <Darkovsky> > last.init $ ["YESBABY","HER",""]
16:56:11 <lambdabot>   "HER"
16:56:23 <Darkovsky> Okay, that works as expected.
16:56:46 <Darkovsky> > last.init $ ["YESBABY","HERP",""] == "HERP"
16:56:47 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:56:47 <lambdabot>         against inferred ty...
16:57:01 <Darkovsky> > (last.init $ ["YESBABY","HERP",""]) == "HERP"
16:57:02 <lambdabot>   True
16:57:12 <BluShift> Eduard_Munteanu: I know, but another user told me that using "par" is ugly because we "don't like to explicitly define order of execution"
16:57:46 <brisbin> > (== "HER") . last $ init ["YES","HERP",""]
16:57:47 <lambdabot>   False
16:57:54 <brisbin> > (== "HERP") . last $ init ["YES","HERP",""]
16:57:55 <lambdabot>   True
16:58:13 <Eduard_Munteanu> BluShift: well, you're a bit prematurely concerned about this.
16:59:14 <BluShift> Eduard_Munteanu: Hah, ok.
16:59:15 <dolio> par doesn't explicitly define order of execution.
16:59:18 <Twey> BluShift: In Haskell, we like to let the compiler take care of evaluation details for us.
16:59:40 <BluShift> Twey: So we should never use par, then?
16:59:50 <Twey> BluShift: Ideally, the compiler would be able to decide for itself when it should parallelise things
17:00:03 <Twey> BluShift: But it's not that smart yet, so we have to give it hints with ‘par’ and the like.
17:00:10 <Eduard_Munteanu> More like, use 'par' when it's wise to.
17:00:13 <BluShift> Twey: Ahhh, I see.
17:00:18 <BluShift> Twey: That makes sense.
17:00:43 <BluShift> Twey: Eduard_Munteanu: Couldn't it just run independent tasks all in parallel?
17:01:00 <Eduard_Munteanu> BluShift: not really wise.
17:01:10 <BluShift> Eduard_Munteanu: Why?
17:01:13 <benmachine> BluShift: there's overhead associated with starting a computation in parallel, so that's slow if it turns out the tasks aren't as independent as you thought
17:01:22 <Eduard_Munteanu> BluShift: consider evaluating simple arithmetic expressions...
17:01:33 <Eduard_Munteanu> Spawning a thread is way more costly than doing it sequentially.
17:01:50 <Eduard_Munteanu> Especially when there's little work to do.
17:01:54 <BluShift> Eduard_Munteanu: Ahhh, ok. All that extra overhead to set up multiple threads, just to do one short instruction.
17:02:45 <gwern> an old problem with the Lisp work on futures
17:02:57 <gwern> the transaction costs may cost you more than you gain
17:03:19 <Darkovsky> pastebinning this, the error is probably real damn obvious
17:03:24 <Darkovsky> and I can't find it
17:03:24 <BluShift> I'm primarily interested in Haskell because C doesn't do bignums quite as easily as I would like, and Python really isn't as quick as I'd like. I've figured out a simple algorithm for finding Mersenne primes, and I've wanted to implement it in something that is A) parallel B) close to C, in terms of speed and B) FOSS
17:03:32 <BluShift> So that's how I've gotten to Haskell :)
17:05:04 <Eduard_Munteanu> BluShift: it makes more sense to parallelize multiple work units, like multiple tests
17:05:25 <BluShift> Eduard_Munteanu: Like, testing two possible candidates?
17:05:29 <BluShift> (or more)
17:05:34 <Eduard_Munteanu> Yes.
17:06:05 <BluShift> Hmm.
17:06:14 <gwern> BluShift: big Integers are done through GMP, which is a c lib is it not?
17:07:18 <pumpkin> just cause it's a c lib doesn't mean it's pleasant to use in c
17:07:29 <BluShift> pumpkin: Hah, exactly my thoughts :)
17:07:33 <pumpkin> I much prefer writing + than mpz_add
17:07:43 <BluShift> gwern: I like that it's automatic in Haskell.
17:07:54 <BluShift> (the conversion, I mean)
17:08:31 <Eduard_Munteanu> push %rax ... call mpz_add, subq $[...], %rsp
17:08:37 <Eduard_Munteanu> :P
17:08:49 <Darkovsky> ...
17:09:15 <Eduard_Munteanu> What it would've been like if it were an asm lib. ^^
17:09:19 <Darkovsky> I think I'm going to go hang myself. I thought my programming was screwing up: It's this mod file
17:09:25 <gwern> Eduard_Munteanu: that's not so bad
17:09:39 <Darkovsky> Terran PAR ships are named "SS_SH_TR_M3_PAR"
17:09:49 <unkanon> Eduard_Munteanu: that would only run in 64 bit machines :/
17:09:51 <Darkovsky> While Terran REGULAR ships are named "SS_SH_USC
17:09:58 <Darkovsky> FML so harrrddd
17:10:04 <Darkovsky> Two hours only to realize that now.
17:10:04 <Eduard_Munteanu> unkanon: uh, I actually screwed up.
17:10:23 <Eduard_Munteanu> AMD64 passes first 6 args in registers.
17:10:33 <Eduard_Munteanu> So it's inconsistent across the board :)
17:10:48 <unkanon> meh, who uses amd64 anyway
17:11:02 * Eduard_Munteanu raises his hand
17:11:17 * BluShift raises his hand
17:11:29 <Eduard_Munteanu> unkanon: amd64 refers to any x86_64
17:11:39 <brisbin> really?
17:11:42 <BluShift> Yes.
17:11:43 * Twey raises his hand.
17:11:47 <BluShift> Any 64-bit machine.
17:11:48 * brisbin raises his hand...
17:11:52 <Twey> Well, not *any*
17:11:52 <BluShift> Hahaha
17:11:59 <Twey> Also, haha.
17:12:00 <BluShift> Twey: Any "modern"
17:12:07 <Twey> The Itaniums don't count, do they/
17:12:08 <Twey> ?**
17:12:09 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
17:12:09 <Draconx|Laptop> BluShift, amd64 refers to modern sparc machines?
17:12:12 <Eduard_Munteanu> Nope.
17:12:13 <Twey> Are they dead now?
17:12:17 * ddarius is about to have a 64-bit AMD processor.
17:12:37 <Eduard_Munteanu> I'm not sure.
17:12:41 <BluShift> Draconx|Laptop: Sparc doesn't count ;)
17:12:42 <Eduard_Munteanu> The design wasn't so bad.
17:12:42 <gwern> doesn't Intel use the same convnetions as AMD for 64-bit?
17:12:55 <Eduard_Munteanu> gwern: it does
17:12:59 <BluShift> gwern: I believe so.
17:13:06 <Twey> Hm
17:13:22 <gwern> so let's just call it x86_64 and drop the AMD mentions entirely
17:13:23 <Twey> Why were there separate compile targets back when I used Gentoo, then?
17:13:34 <Eduard_Munteanu> But Linux got 64-bit x86 support before CPUs were actually launched, and it was contributed by AMD, and first ones available were from AMD, ...
17:13:44 <Eduard_Munteanu> So amd64 made sense :)
17:14:14 <Draconx|Laptop> Twey, The Gentoo amd64 arch has supported both since day 1...
17:14:28 <Eduard_Munteanu> Twey: there weren't, it's still named amd64. It's probably got ia64 too, but that's Itanium.
17:14:45 <Twey> Isn't that what I said?
17:15:03 <Eduard_Munteanu> I mean, no separate Gentoo arches.
17:15:34 <Twey> Then what's ia64?  I think I'm failing to understand you here.
17:15:45 <sipa> ia64 is 64-bit itanium
17:15:49 <Twey> Right
17:15:53 <sipa> which is not x86 compatible
17:15:55 <Twey> Which is or is not a separate Gentoo arch?
17:16:14 <Eduard_Munteanu> It is, but it's worthless unless you got Itanium (which is rather unlikely)
17:16:23 <sipa> ia64 is definitely separate from x86 or (x86_64 aka amd64)
17:16:57 <ddarius> "as of June 2010, there are no known motherboards for x86-64 processors that support 256 TB of RAM"
17:17:19 <ddarius> Are there motherboards for anything at all that support 256 TB of RAM?
17:17:41 <tg_> no
17:17:46 <tg_> i don't know of any
17:17:47 <Eduard_Munteanu> Mmm... 2^48?
17:18:08 <BluShift> If there are, I would like one for Christmas.
17:18:22 <tg_> nothing that would be considered a motherboard by itself :O
17:18:24 <Eduard_Munteanu> Wasn't the theoretical limit about 2^52 or so?
17:18:36 <Eduard_Munteanu> ddarius: do you need one? :/
17:18:46 <dagle> ddarius: It you be that the bios doesn't support it.
17:18:48 <tg_> NEED?
17:18:52 <sipa> i think it differs between intel's x86_64 and amd64
17:18:52 <gwern> who doesn't need 256TB of RAM?
17:18:58 * sipa
17:19:02 <Eduard_Munteanu> sipa: hm, possibly
17:19:51 <Sgeo> :t [Right, Left]
17:19:52 <lambdabot> forall b. [b -> Either b b]
17:19:56 <Sgeo> Makes sense
17:22:03 <Darkone> I was doing so many things wrong.  I was droping 5 instead of 4, and I didn't know some PAR ships don't match up with regulars. I fixed that, added in hardcoded special cases for the retarded Terran ships, and BOOM, it works!
17:22:07 <ski> @type Right ||| Left
17:22:08 <lambdabot> forall b a. Either b a -> Either a b
17:22:18 <Darkone> Also, 256TB of RAM?
17:22:31 <Darkone> I bet X3 could fill that up in 4 hours of playtime :|
17:22:31 <Sgeo> |||?
17:22:36 <Sgeo> :t |||
17:22:37 <lambdabot> parse error on input `|||'
17:22:45 <ski> @src (->) (|||)
17:22:45 <lambdabot> Source not found. Just try something else.
17:22:50 <ski> @src (|||)
17:22:50 <lambdabot> Source not found. Wrong!  You cheating scum!
17:22:53 <ski> bah
17:22:54 <Sgeo> :t (|||)
17:22:55 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
17:23:02 <ski> basically `either'
17:23:07 <ski> @type either
17:23:08 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
17:23:11 * Sgeo looks in uncomperhension
17:23:11 <Darkone> To celebrate my final noob victory over this mod
17:23:14 <Sgeo> Oh
17:23:15 <ski> @type Right `either` Left
17:23:16 <lambdabot> forall a a1. Either a a1 -> Either a1 a
17:23:25 <Darkone> Robot unicorn attack heavy metal music! http://www.youtube.com/watch?v=mllIWtUzmac
17:23:30 <Sgeo> Uh
17:23:45 * Darkone dances while his code happily runs without empty list errors \o/
17:25:12 <Funktorsalat> "<Eduard_Munteanu> Wasn't the theoretical limit about 2^52 or so?" <-- what happens then? black hole?
17:25:23 <BluShift> Darkone: What are you hacking on?
17:25:46 <brisbin> Funktorsalat: i think your cat catches fire
17:25:47 <Eduard_Munteanu> Funktorsalat: heh no, it's just a limitation in the CPU (actually less than the addressing space)
17:25:49 <brisbin> 's documented somewhere
17:26:01 <Darkone> BluShift, Ship Rebalance Mod for X3TC
17:26:02 <BluShift> Funktorsalat: I think UEFI will change that maximum.
17:26:08 <BluShift> X3TC?
17:26:15 <Eduard_Munteanu> It has a bit of a strange address space layout
17:26:22 <Funktorsalat> brisbin: oh no ! :o
17:26:22 <sipa> $ cat /proc/cpuinfo | fgrep 'address sizes'
17:26:22 <sipa> address sizes	: 36 bits physical, 48 bits virtual
17:26:46 <Funktorsalat> UEFI?
17:26:52 <ski> > 35 + 48
17:26:53 <lambdabot>   83
17:26:56 <Eduard_Munteanu> sipa: that could be extended
17:27:03 <ski> > 36 + 48  -er
17:27:04 <lambdabot>   Not in scope: `er'
17:27:06 <ski> > 36 + 48  -- er
17:27:07 <lambdabot>   84
17:28:56 <Darkone> BluShift, X3: Terran Conflict
17:29:33 <BluShift> Funktorsalat: http://en.wikipedia.org/wiki/Extensible_Firmware_Interface
17:29:43 <BluShift> Darkone: Ahh. Cool!
17:30:07 <Darkone> Wowowo.
17:30:10 <Funktorsalat> hmm ok
17:30:18 <BluShift> Eduard_Munteanu: http://en.wikipedia.org/wiki/Extensible_Firmware_Interface
17:30:36 <BluShift> Eduard_Munteanu: That theoretical limit should disappear when this shows up in a few years.
17:31:27 <Eduard_Munteanu> I doubt it... what's EFI got to do with the maximum physical address space?
17:31:29 <tolkad> I don't think you should be allowed to do record updates with the constructor out of scope... I would sometimes like to export record functions just like normal functions, I don't want to have to give them some special name just so I can avoid exporting their record update ability
17:32:31 <BluShift> Eduard_Munteanu: It allows for the rest of the motherboard to "catch up" with the theoretical address space of 64-bit processors/
17:32:43 <edwardk> tolkad: then what about folks who export just a few such accessors and hide the constructor and/or some other fields because they want to control their contents?
17:33:01 <BluShift> BIOS doesn't support 2^64-1 addresses, but 64-bit processors do. UEFI should close that gap.
17:33:02 <tolkad> edwardk: they can make a function a -> b -> a
17:33:12 <tolkad> edwardk: for some types a and b
17:33:12 <Eduard_Munteanu> BluShift: they don't
17:33:25 <ski> tolkad : we ought to have rename-on-export ..
17:33:29 <Eduard_Munteanu> BluShift: it is a 64-bit address space, but it can't addres that much memory.
17:33:44 <jmcarthur> wait, you can do record updates with the constructor out of scope?
17:33:46 <edwardk> tolkad: but they already have a perfectly good function, which provides sugar their function can't. since you want to change the world the burden of proving why this is a good thing is on you ;)
17:33:49 <tolkad> edwardk: or at least give me a way to export them as regular functions
17:34:05 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Amd64#Virtual_address_space_details
17:34:18 <BluShift> Eduard_Munteanu: Why not?
17:34:25 <tolkad> edwardk: another solution
17:34:30 <Eduard_Munteanu> BluShift: read up the details ^
17:34:39 <tolkad> edwardk: would be to allow that sugar for regular functions
17:35:03 <tolkad> edwardk: on the other hand, maybe not. It has tremendous potential for abuse
17:35:19 <ski> tolkad : also, if one exports like `Foo ( bar )' it ought to export the field-ness of `bar', but if exporting like `Foo,bar', it ought not to do that
17:35:22 <edwardk> tolkad: foo { bar = baz } becoming bar baz foo  somehow?
17:35:27 <BluShift> Eduard_Munteanu: That's simply AMD's implementation ;) UEFI would make it possible for true 64-bit addressing to exist.
17:35:48 <Eduard_Munteanu> Well yes, it can technically be extended
17:35:54 * ski wonders whether it already does that ..
17:36:57 <ski> edwardk : `lensSet bar baz foo' :)
17:39:11 <BluShift> Eduard_Munteanu: I dunno about you, but I'd love a machine with 16 EB of RAM :) Just make the RAM (somehow) non-volatile, you'd have instant on :)
17:39:45 <tolkad> edwardk: maybe like « Foo { bar (Foo x) y = (Foo y)  } » in module context creating a record updater bar for Foo
17:40:31 <Eduard_Munteanu> BluShift: well, in the meanwhile you can hibernate to SSD :)
17:41:00 * Eduard_Munteanu wonders how Git sessions feel on SSD
17:41:38 <BluShift> Eduard_Munteanu: Ugh, but TRIM is ugly :(
17:42:03 <gwern> (my next laptop will be SSD, absolutely. I promised that to myself a long time ago)
17:42:28 <tolkad> edwardk: I guess it's more trouble that it's worth. you would also have to give record updaters their own namespace
17:43:00 <edwardk> tolkad: yeah
17:43:32 <tolkad> edwardk: if I could just export the function without the record update ability I would be happy
17:43:57 <tolkad> edwardk: just rename-on-export would work perfectly
17:45:01 <Eduard_Munteanu> tolkad: so you want it as accessors, but not setters/constructors?
17:45:08 <tolkad> « module A (t = t) where { data T = T {t :: Int} } »
17:45:18 <edwardk> tolkad: or you could just make a bunch of boringFoo = foo declarations and be done with it ;)
17:45:41 <Eduard_Munteanu> s/it/them/
17:45:50 <mauke> or you could not make it a record type
17:45:51 <tolkad> Eduard_Munteanu: Yes, I want it as a function
17:46:11 <tolkad> mauke: I might want to use it in module A but nowhere else
17:46:21 <Eduard_Munteanu> tolkad: it doesn't make sense, think what if it weren't record syntax.
17:46:25 <tolkad> currently I have to do:
17:46:30 <Eduard_Munteanu> You'd need the constructor to access the internal representation.
17:46:34 <ski> tolkad : i just tried having an export list `Foo,bar' .. sadly it appears to export `bar' as a selector, just like `Foo (bar)'
17:47:08 <tolkad> « module A (t) where { data T = T {t' :: Int}; t = t' } »
17:47:21 <tolkad> I just want to be able to move that into the export list
17:47:42 <Eduard_Munteanu> tolkad: I'd recommend splitting that data into stuff that is opaque and stuff that's public
17:48:15 <Eduard_Munteanu> Then data OpaqueData [...] = OpaqueData PublicData [...]
17:48:22 <tolkad> Eduard_Munteanu: I know I would in reality need more stuff in the export list. if this was Data.Map I would export empty and some functions to manipulate empty
17:48:32 <tolkad> Eduard_Munteanu: I'm just leaving it out of this example
17:49:16 <tolkad> Eduard_Munteanu: that's not what Data.Map does
17:50:15 <tolkad> Eduard_Munteanu: sometimes the data representation is impossible to ensure correct using the type system, as in the case of Data.Map
17:50:28 <ski> Eduard_Munteanu : imo, one shouldn't need to change the representation, just to change what parts of it are visible in the interface
17:51:38 <Eduard_Munteanu> Hm, this is like asking for private fields in a C++ to be public only for getting but not setting :/
17:51:46 <Eduard_Munteanu> *C++ class
17:52:05 <tolkad> Eduard_Munteanu: no, I gave up on that, I just want a rename-on-export
17:52:36 <tolkad> allow « module A (t = t) where { data T = T {t :: Int} } » instead of « module A (t) where { data T = T {t' :: Int}; t = t' } »
17:53:55 <tolkad> Eduard_Munteanu: I don't want to be allowed to use t for record syntax at all
17:54:02 <tolkad> Eduard_Munteanu: I just want it as a function
17:54:30 <tolkad> t :: T -> Int
17:54:59 <tolkad> hmm, I'll just have to stick with the latter I guess
17:55:03 <ski> tolkad : imo, `module A (T (t)) where data T = MkT {t :: Int}' ought to export `t' as a selector, but `module A (T,t) where data T = MkT {t :: Int}' ought to export `t' only as a function of type `T -> Int'
17:55:29 <tolkad> ski: hmm, I just don't like having to think of redundant names
17:55:49 <tolkad> it's the hardest part of programming... thinking of names for things
17:55:49 * ski hasn't talked about having redundant names
17:56:24 <caelan> tolkad: wolfram actually wrote about that
17:56:34 * ski wonders whether tolkad has read the suggestion above ..
17:58:29 <tolkad> ski: oh didn't realize you changed it
17:58:38 <tolkad> ski: hmm, I agree
17:59:17 <tolkad> ski: maybe module A (T (MkT (t)))? :P
17:59:59 <ski> `module A (T (MkT,t))' if you want to export both `t' as a selector, as well as the constructor `MkT'
18:00:17 <gwern> naming is the hardest part of programming?
18:00:23 <pumpkin> definitely
18:00:36 <ski> (note that you may reuse the same selector for multiple constructors .. so the selectors don't really belong to a single constructor)
18:03:00 <ski> (naming is hard, when no sensible name suggests itself)
18:22:04 <emilmeln> Is there any tool for inspecting structure layout in memory (i.e. what parts of a data are shared)?
18:22:28 <gwern> emilmeln: vacuum?
18:27:19 <emilmeln> gwern: Looks like the Right Thing. Thanks.
18:34:16 <man> Hey
18:34:28 <man> I am looking for someone who can help me with Haskell
18:34:29 <emilmeln> Vacuum is the great tool.
18:34:56 <Axman6> man: well, therte's 600 people in here who fit that description
18:34:59 <Axman6> -t
18:35:54 <man> I need help with topics like "mapReduce defined funtions" "recursionEngine defined funtions"
18:36:08 <Martty> no need to make an introduction, just go to the point
18:36:18 <Axman6> heh, which university are you learning haskell at?
18:36:56 <man> UCI, y does it matter?
18:37:43 <Axman6> well, we've had quite a few people in here recently asking about the same things
18:37:53 <Eduard_Munteanu> They do Haskell here too, though not in my major.
18:38:13 <Axman6> well, mapReduce anyway, not sure about this recursionEngine thing
18:38:18 <man> Its not a part of my major either, but still had to take it
18:38:39 <Eduard_Munteanu> I've actually seen a few Romanian articles on haskellwiki, I suppose it's by some teachers at another university in the country.
18:38:59 <man> I can send you the document where it explains how funtions are written using mapReduce and recursionEngine
18:39:05 <caelan> my school has a course in programming languages or something; my advisor teaches it
18:39:21 <Eduard_Munteanu> Uh, you're the same guy/girl from a few days ago?
18:39:38 <caelan> Eduard_Munteanu: you mean me?
18:39:47 <man> me?
18:39:55 <Eduard_Munteanu> I remember that mapReduce stuff.
18:39:58 <Axman6> man: anyway, what is your question?
18:40:46 <BluShift> Haskell has the coolest logo ever.
18:40:50 <BluShift> Just sayin'.
18:41:15 <mauke> http://blog.plover.com/prog/haskell/logo.html
18:41:51 <Eduard_Munteanu> Heh, that is similar.
18:42:01 <man> i have to define the funtion scanr1 using mapReduce
18:42:04 <Eduard_Munteanu> Though more like a >>=
18:42:18 <ddarius> There will be big issues if we get into the transportation business.
18:42:20 <BluShift> It's not very similiar.
18:42:47 <caelan> oh heavens, guess we won't be shipping much software [badum-tish!]
18:42:54 <BluShift> Haskell's thing has always been the Lambda, so it's obvious that it's just a stylized Lambda.
18:42:58 <zachk> similar except for the lambda in the middle 
18:43:01 <BluShift> caelan: lol
18:43:04 <Axman6> man: well, we don't know what mapReduce is, so you
18:43:10 <zachk> it also looks like >>= kinda 
18:43:12 <Axman6> you'll have to give us more information than that
18:43:37 <man> can i send u a document somewhere here?
18:43:40 <BluShift> Why has the site not adopted the new logo? And the executable hasn't, either.
18:43:41 <man> it exaplins it all
18:43:46 <Eduard_Munteanu> man: hpaste
18:43:47 <man> *explains
18:43:48 <Eduard_Munteanu> see /topic
18:44:25 <benmachine> >λ=
18:44:27 * caelan fishes up his Report printout
18:44:30 <ddarius> BluShift: The site did.  Then there was a "problem" and the site was reverted and no one has fixed it because a new web server is about to be stood up.
18:44:36 <dark> Eduard_Munteanu, where in the topic?
18:45:10 <Eduard_Munteanu> ' [...] "Paste: http://hpaste.org", [...] '
18:45:20 <man> mapReduce is defines like this
18:45:20 <BluShift> ddarius: I see.
18:45:24 <man> mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn xin   
18:45:31 <Eduard_Munteanu> man: DON'T
18:45:39 <Eduard_Munteanu> man: paste it there ^
18:46:25 <man> what r u talking abt?
18:46:32 <Eduard_Munteanu> http://hpaste.org
18:46:37 <dark> ah, yes. but see, hpaste has the logo, BluShift
18:46:44 <brisbin> if i knew how mapReduce worked, i think that'd be the best interface ever.
18:47:16 <mauke> man: using English helps
18:47:32 <emilmeln> BluShift: http://new-www.haskell.org/
18:48:23 <caelan> man: are you referring to that Google thing?
18:48:28 <Axman6> man: you're going to have to ask specific questions if you want good answers. we won't do your homework for you
18:48:30 <dark> emilmeln, cool o.o
18:48:45 <Vanadium> oh god there are links all over that web page
18:48:49 <Vanadium> where do i even click
18:48:54 <emilmeln> dark: yes, very stylish.
18:49:13 <dark> everywhere people recommend the haskell platform
18:49:20 <Eduard_Munteanu> It ain't bad.
18:49:25 <Eduard_Munteanu> I'm not yet used to it though.
18:49:28 <man> so I cant get help for my homework problems here?
18:49:33 <dark> but people at #gentoo-haskell says it actually isn't advised to have it on a gentoo system..
18:49:53 <BluShift> Dark: Why?
18:49:54 <dark> i.e. there is a package for it, but it's better to just track the gentoo-haskell overlay
18:49:58 <caelan> man: you can get help, but not answers; we'll show you the path, but you have to follow it yourself
18:50:01 <dark> BluShift, I don't know exactly
18:50:25 <Eduard_Munteanu> I don't use it on Gentoo. It's keyword masked here and I suspect xmonad and other stuff needs dev-lang/ghc
18:50:33 <Eduard_Munteanu> And separate libs.
18:50:34 <dark> gentoo is a "rolling" distro, it has no releases. and.. the platform seems like a release of a bunch of libraries, plus a ghc version
18:50:50 <emilmeln> btw, does anyone use Debian here? If so, what -dev packages should I install for gtk2hs?
18:50:53 <dark> yes, i update libs separatedly
18:50:54 <Eduard_Munteanu> Anyway, it makes sense for Linux distribution to have separate packages I think.
18:51:15 <dark> so the haskell platform was meant for windows and mac os x?
18:51:26 <Eduard_Munteanu> Haskell Platform is probably nice to develop stuff rather than use as a big distro pkg.
18:51:52 <Eduard_Munteanu> dark: what I said isn't an official/widespread position.
18:51:58 <BluShift> Eduard_Munteanu: Yeah. I think binaries should be distro'd with source code, but I don't think all distro's should come with a 70MB dev environment :P
18:53:07 <zachk> if they come on a dvd why not 
18:53:40 <BluShift> zachk: Because some people like to not fill their drive with stuff they might never use :)
18:53:55 <emilmeln> Why not? For examlpe, JRE is quite big.
18:54:04 <zachk> pffft 70 megs is nothing compared to the bloat of a java IDE 
18:54:07 <BluShift> Yes, but the JDK doesn't come pre-installed :)
18:54:37 <BluShift> That's like saying "Yo, we've already got GCC installed, let's just go ahead and install Eclipse for them too"
18:54:50 <caelan> i'd say that 70M of haskell is much more worth it than 70M of java
18:54:56 <dark> I'm quite fine with the latest things on gentoo-haskell, plus handmade ebuilds for something I want outside it (hopefully not common)
18:55:01 <BluShift> caelan: Hah, you're biased ;)
18:55:17 <caelan> BluShift: only because i've used both :)
18:55:35 <BluShift> caelan: Pshh. Both are great languages.
18:55:44 <BluShift> Well.
18:55:53 <BluShift> Haskell is appearing to be.
18:56:04 <BluShift> I can't do anything interesting with it yet :P
18:56:37 <zachk> haskell is the greatest language in the world for writing the correct language for your given problem domain 
18:56:52 <BluShift> zachk: What?
18:57:15 <BluShift> Is Haskell pronounced hass-KELL, or "haskle"?
18:57:26 <BluShift> "hasskle"*
18:57:39 <caelan> i say "hasskle"
18:57:41 <Eduard_Munteanu> I use the latter, but I'm unsure.
18:57:42 <zachk> i say hass-kell sort of like pascal then i disambiguated people 
18:58:07 <BluShift> HassKELL sounds cooler, but it confuses my friends :P
18:58:10 <Eduard_Munteanu> Heh.
18:58:12 <BluShift> They think "Pascal"
18:58:12 <caelan> wiki says nothing
18:58:14 <Martty> can i has kell
18:58:19 <BluShift> :P
18:58:35 <ddarius> The popular, and I believe, "correct" pronunciation is like "haskle", i.e. no emphasis on the latter syllable.
18:58:39 <Eduard_Munteanu> @faq Can Haskell beat Pascal?
18:58:39 <lambdabot> The answer is: Yes! Haskell can do that.
18:58:45 <ddarius> I say "Haskell" like "Pascal" though.
18:59:02 <Martty> who the heck says "paskle"
18:59:05 <BluShift> ddarius: How do you say Pascal? "Pass-CAL"?
18:59:09 <zachk> yes
18:59:12 <dbelange> It's pronounced Haskell, you dipshits.
18:59:12 <caelan> Martty: quite a few people
18:59:21 <Martty> gross
18:59:25 <dbelange> Not surprising you have no idea what you're doing.
18:59:56 <ddarius> At any rate, Haskell Curry allegedly didn't like his name, so feel free to say it however you like.
19:00:08 <BluShift> ddarius: Let's just rename, why the hell not?
19:00:13 <BluShift> ddarius: PERL2.
19:00:18 <mauke> BluShift: taken
19:00:20 <mauke> by Perl 2
19:00:31 <BluShift> Oh.
19:00:34 <BluShift> PYTHON 2
19:00:37 <Eduard_Munteanu> G# ?
19:00:38 <caelan> an answer we have: http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/msg07152.html
19:00:47 <BluShift> G#
19:00:47 <BluShift> Haha
19:00:49 <BluShift> I like it.
19:00:54 <emilmeln> Why G?
19:00:59 <Eduard_Munteanu> F is taken.
19:01:05 <emilmeln> Oh :)
19:01:06 <Eduard_Munteanu> :)
19:01:07 <caelan> no, it's for Good
19:01:17 <benmachine> plus it's almost H
19:01:19 <benmachine> for haskell.
19:01:23 <caelan> wouldn't you want a Good Sharp language?
19:01:47 <emilmeln> Then you need a different sign (not '+' or '#').
19:01:48 <BluShift> H#?
19:01:53 <BluShift> H++
19:01:54 <BluShift> :P
19:02:09 <BluShift> H#++
19:02:14 <BluShift> o_O
19:02:17 <benmachine> H#++ 2.0
19:02:29 <caelan> H$1
19:02:31 <Eduard_Munteanu> H in German musical notation means B, so H# would actually be... well, C :)
19:02:33 <Axman6> H#++ 2.0'
19:02:49 <tg_> if you guys keep this up, my head will actually asplode.
19:02:58 <emilmeln> '#' is bad, because it symbolises low-level, unboxed stuff :)
19:03:10 <ddarius> @src Char
19:03:10 <lambdabot> data Char = C# Char#
19:03:10 <emilmeln> [G]
19:03:18 <Rotaerk_> haskell sharp?!?1
19:03:21 <caelan> H@(())
19:03:22 <brisbin> creepy
19:03:26 <BluShift> Eduard_Munteanu: This information, combined with the knowledge that GHC can compile to straight C leads me to only one conclusion.... Haskell is nothing more than LOLCODE for C :O :O :O
19:03:31 <Eduard_Munteanu> I'd take "prime" anyday.
19:03:43 <tg_> I always wanted to view the # in something like C# as plus plus plus plus
19:03:54 <Eduard_Munteanu> Yeah, CAN HAZ CLOZURE?!
19:04:05 <BluShift> Eduard_Munteanu: lololol
19:04:08 <caelan> \x -> LOLCATS
19:04:59 <BluShift> What IS a closure, anyways>
19:05:00 <BluShift> ?
19:05:11 <BluShift> Or is this another "don't worry about it.... yet"?
19:05:16 <zachk> something that scheme has 
19:05:26 <Martty> its like a brochure but closed
19:05:29 <danderson> something that all modern languages have
19:05:33 <zachk> its a function with mutable state inside of it 
19:05:39 <caelan> BluShift: it's when bound variables in the lexical scope of a function are "closed" into the function's runtime environment
19:05:52 <zachk> does haskell have closures? 
19:06:02 <c_wraith> zachk, yes.
19:06:02 <BluShift> caelan: Closed in what sense? Not visible outside of that functions scope?
19:06:14 <c_wraith> zachk, it'd really be bad at non-strict evaluation if it didn't.
19:06:37 <caelan> BluShift: it means that bindings of the variable in the context where the function is called do not affect the bindings the function sees
19:06:51 <zachk> i thought that was just lexical scoping 
19:07:05 <dark> BluShift, a function plus an environment for it (with variables for bindings). for example, consider (\x -> x + a), it's the function that receives x and returns x + a. it depends on a. give this code, plus a meaning for a, and you have a closure
19:07:08 <BluShift> I have no idea what that means.
19:07:27 <c_wraith> zachk, it needs to hold on to values after a function returns in order for lazy evaluation to work.  that requires closures.
19:07:35 <BluShift> Ahh
19:07:41 <Eduard_Munteanu> BluShift: it is kinda early.
19:07:41 <caelan> zachk: right, but the combination of lexical scoping and first-class functions forces you to disambiguate bindings
19:07:54 <tg_> is the person behind gmandl here?
19:07:59 <tg_> gmndl, that is
19:08:03 <dark> actually closure is the data structure.. it's kind of a metonymy to call closure the abstract concept. i.. think
19:08:10 <Eduard_Munteanu> BluShift: though anyway, \x -> x + a is an anonymous function
19:08:12 <emilmeln> I'm still wondering how closures are fit seamlessly in Haskell, in contrast with non-pure languages.
19:08:12 <ddarius> ClaudiusMaximus
19:08:19 <BluShift> c_wraith: So in eager evaluation, a function can ditch it's local scope because all the values have already been used for their required purpose. But in lazy eval, that stuff needs to stick around to be eval'd later?
19:08:24 <Eduard_Munteanu> Or, ahem, a lambda expression.
19:08:30 <tg_> ClaudiusMaximus: here?
19:08:35 <c_wraith> BluShift, assuming you don't have first-class functions, anyway
19:08:45 <BluShift> c_wraith: Hmm.
19:08:47 <caelan> it doesn't depend on laziness
19:09:04 <c_wraith> yeah, first-class functions are what really require it
19:09:13 <BluShift> Why is that?
19:09:23 <BluShift> OH.
19:09:33 <caelan> because if you can't toss functions around, you never deal with two different scopes at once
19:09:43 <BluShift> Because if a function returns a function, that returned function needs to access the "parent function"'s state, correct?
19:09:47 <caelan> right
19:09:55 <BluShift> AHH.
19:10:01 <caelan> sort of; it doesn't have to be "state" per se
19:10:03 <BluShift> .
19:10:10 <c_wraith> its environment
19:10:22 <caelan> we blew his mind
19:10:46 <emilmeln> For short, closure is just a function with some data added.
19:12:07 <caelan> i've always thought of it as meaning that bindings have indeterminate lifetimes -- that bindings are gc'd along with objects
19:12:21 <tmo_> Suppose you need to check if two lists have the same elements, and you cannot sort the lists.
19:12:32 <tmo_> What is the most efficient algorithm that lets you accomplish this?
19:13:03 <BluShift1> Sorry, laptop died >_>
19:13:16 <caelan> tmo_: if they're unsorted lists, i think you have to have something like an n^2 algorithm
19:13:23 <caelan> but i'm no expert
19:13:24 <zachk> tmo_ what can you sort them? 
19:13:41 <ddarius> If all you can do is compare them for equality, O(n^2) a la nub is the best you'll get.
19:13:45 <zachk> why cant you 
19:13:57 <tmo_> Because not all the elements are orderable.
19:14:44 <Eduard_Munteanu> Being an instance of Ord simplifies complexity.
19:15:11 <Eduard_Munteanu> Unfortunately I don't think there's a Prelude nub that takes Ord to its advantage.
19:15:22 <zachk> are the elements finite? you can define an ordering for it 
19:15:39 <Eduard_Munteanu> zachk: not really
19:16:19 <Eduard_Munteanu> At least from a mathematical point of view, when dealing with polymorphic types, they can be anything.
19:16:32 <emilmeln> tmo_: I think you can keep some hash value along with the list, if the performance is important
19:16:46 <tmo_> Well I'm not sure if performance is that important.
19:17:03 <tmo_> The main thing it's going to be working with are algebraic expressions, which usually don't stretch out to 1000 terms.
19:17:25 <caelan> in that case, the obvious n^2 algorithm is probably good enough
19:18:15 <Eduard_Munteanu> Oh, zachk was specifically referring to this particular problem...
19:18:24 <emilmeln> Algebraic expressions can't be sorted?
19:19:53 <Eduard_Munteanu> Functions can't be sorted.
19:20:01 <BluShift1> emilmeln: Only if they're evaluated ;)
19:21:22 <emilmeln> I thought about something like "data Expr a = Plus a a | Mul a a | Neg a | ..."
19:26:32 <Saizan> data Expr a = Plus (Expr a) (Expr a) | ... would make more sense :)
19:26:47 <Saizan> and ".. | Var a"
19:27:11 <Saizan> (or Const a, depending on taste)
19:28:53 <emilmeln> "Const a" means an immutable lamguage?
19:29:48 <tmo_> By the way, does haskell transform the singly-linked-lists into arrays so operations don't take O(n) time?
19:30:11 <emilmeln> tmo_: no
19:30:11 <Eduard_Munteanu> tmo_: no
19:30:15 <Eduard_Munteanu> Heh.
19:30:18 <dolio> You mean, so that more common operations take O(n) instead of uncommon array-like operations?
19:30:36 <caelan> dolio: i think some of the operations are tco'd
19:30:52 <emilmeln> tmo_: use an "array" package (or better, the "vector" package, if GHC extensions are fine for you)
19:31:12 <caelan> whoops, sorry; s/dolio/tmo_/
19:31:29 <tmo_> is the O(n) versus O(1) slow down that important?
19:31:34 <BluShift1> What makes the knapsack problem so difficult?
19:31:58 <BluShift1> It would appear pretty easy to solve, using a basic way of determining efficiency.
19:32:21 <Eduard_Munteanu> It's NP-complete if we're talking about the same thing.
19:32:37 <krey_> knapsack, np, whut?
19:32:55 <BluShift1> Eduard_Munteanu: Yes, I believe we are.
19:32:56 <krey_> it's linear when I implement it
19:32:58 <emilmeln> I suppose O(1) is not really takes constant time in the real world (same for O(n)).
19:33:06 <Eduard_Munteanu> Ah, then it's something else.
19:33:53 <BluShift1> I just don't understand how it's that difficult to solve. Just find which block is the most efficient for a given weight, fill to maximum, and then fill with next most efficient weight for that available space, repeat.
19:33:55 <Eduard_Munteanu> emilmeln: it merely means the upper bound is a constant function.
19:34:15 <BluShift1> If there is any space left over, drop back, replace block with two blocks that take up all space.
19:34:19 <BluShift1> Am I righT?
19:34:20 <krey_> BlueShift1: yeah, that doesn't work, easy to construct a counterexample
19:34:24 <Eduard_Munteanu> Oh that.
19:34:34 <BluShift1> krey_: Can you provide that counterexample?
19:34:45 <krey_> sure
19:35:15 <Eduard_Munteanu> emilmeln: same goes for O(n), or theta(1).
19:35:56 <Martty> if im an edge in a digraph, what is my end point called in a single word?
19:36:19 <BluShift1> Eduard_Munteanu: I've done some reading on polynomial time, and I don't (can't?) understand understand what it means. Can you explain it in laymans terms?
19:36:41 <Saizan> Martty: target?
19:37:00 <Martty> thats good
19:37:22 <caelan> BluShift1: IIRC, it's O(n^m) for some constant integer m
19:37:31 <Eduard_Munteanu> "An algorithm is said to be polynomial time if its running time is upper bounded by a polynomial in the size of the input for the algorithm, i.e., T(n) = O(nk) for some constant k"
19:37:35 <Saizan> Martty: the other one is called source
19:37:53 <Eduard_Munteanu> BluShift1: any particular misunderstanding?
19:37:54 <BluShift1> Eduard_Munteanu: I said "laymans terms" :P
19:37:55 <krey_> BluShift1: you have two types of items: (5 kg, $ 11) and (2 kg, $4) and you can only lift 6 kgs
19:37:57 <emilmeln> Eduard_Munteanu: I was saying about caching, I/O slowdowns etc.
19:38:38 <Eduard_Munteanu> emilmeln: indeed, but the math covers that too
19:38:53 <caelan> BluShift1: do you know what a polynomial is?
19:38:53 <BluShift1> krey_: 2 kg is more efficient, and can fill the space appropriately.
19:39:05 <Eduard_Munteanu> BluShift1: it's helpful to understand big oh notation
19:39:07 <Saizan> Martty: oops, no, source is something else, the opposite of sink
19:39:09 <BluShift1> caelan: I believe so, but perhaps my understanding of it is what's hurting me.
19:39:22 <Martty> ? thats ok
19:39:22 <BluShift1> Eduard_Munteanu: Unfortunately, I have no idea what that means
19:39:30 <Martty> i just neede a good indentifier
19:39:32 <Eduard_Munteanu> O(...) notation
19:39:39 <Martty> i was using "next" but it was kinda confusing i thought
19:39:49 <BluShift1> caelan: An expression made of a arbitrary number of terms, right?
19:39:51 <krey_> folding question: what type would you suggest for folding over data RegExp ab = Unit ab | Union [RegExp ab] | Concat [Regexp ab] | Star (Regexp ab) ?
19:40:15 <krey_> BluShift1: dude, it's a counterexample, deal with it
19:40:18 <BluShift1> Eduard_Munteanu: What sort of field is that a part of?
19:40:22 <BluShift1> krey_: What?
19:40:37 <krey_> BluShift1: what is your precise algorithm?
19:40:44 <Eduard_Munteanu> BluShift1: example: if you find a polynomial that constitutes an upper bound for your time, then it's polynomial time
19:41:01 <Eduard_Munteanu> BluShift1: computational complexity theory
19:41:07 <BluShift1> Eduard_Munteanu: Couldn't a polynomial be theorectically any size?
19:41:08 <Saizan> foldRegExp :: (ab -> r) -> ([r] -> r) -> ([r] -> r) -> (r -> r) -> RegExp ab -> r ?
19:41:17 <Eduard_Munteanu> BluShift1: yes
19:41:44 <krey_> Saizan: foldRegexp ::  z -> (z -> z -> z) -> z -> (z -> z -> z) -> (z -> z) -> Regexp ab -> z ?
19:41:44 <caelan> BluShift1: the important thing in big-O is how quickly the function grows
19:41:51 <BluShift1> Eduard_Munteanu: So, if a computation can be completed in an amount of time that's not infinite, it's polynomial time?
19:41:58 <krey_> Saizan: which one's better/more standard?
19:41:59 <Eduard_Munteanu> BluShift1: but for instance 2^n grows larger than ANY polynomial eventually
19:42:47 <Eduard_Munteanu> It only matters as n -> infinity
19:42:47 <BluShift1> Eduard_Munteanu: How so? Couldn't you have a polynomial (2^n) + (2^n)?
19:42:54 <Eduard_Munteanu> BluShift1: no
19:43:06 <krey_> mathsfail?
19:43:07 <Eduard_Munteanu> Polynomial in terms of n
19:43:09 <Saizan> krey_: what is the second 'z' parameter for? in case the lists inside Union or Concat are empty?
19:43:11 <caelan> BluShift1: no, a polynomial is a sum of terms of the form a*x^n
19:43:20 <Saizan> krey_: more standard surely mine
19:43:23 <byorgey> krey_: Saizan's seems more general
19:43:56 <krey_> byorgey: you think so? I'd disagree
19:44:06 <BluShift1> caelan: Eduard_Munteanu: Ok, so wouldn't 2*2^n remain larger than 2^n, no matter what?
19:44:22 <krey_> byorgey: example?
19:44:28 <byorgey> krey_: well, if you add an (ab -> z) argument I think it would be the same
19:44:45 <krey_> byorgey: oh, yeah typo
19:44:46 <caelan> yes, but it's still a constant multiple of 2^n, so we strip off the coefficient and call it 2^n
19:44:57 <Userh626> Hello, anyone here?
19:45:05 <dolio> No.
19:45:11 <caelan> absolutely not
19:45:15 <Userh626> can anyone hear me ?
19:45:18 <byorgey> krey_: I guess your type amounts to inlining foldr for the lists
19:45:19 <BluShift1> krey_: Couldn't you find which weights divide most evenly into a given maximum weight, and then sort those weights in terms of "efficiency", or value/weight?
19:45:44 <Userh626> ok is anyone here familar with what a CRC check is ?
19:46:12 <Eduard_Munteanu> BluShift1: that doesn't change the fact that 2^n is larger than polynomial
19:46:15 <krey_> BluShift1: that doesn't sound like a precise description to me... "divide most evenly"...
19:46:44 <krey_> byorgey: could you rephrase that to almost noobie please? :D
19:46:54 <Userh626> hey does anyone know what a CRC check is ?
19:47:10 <aristid> Userh626: yes, but wikipedia explains it best
19:47:33 <BluShift1> krey_: Sorry, let's look at it in terms of mathematical operations. Which ever MAX_WEIGHT % WEIGHT_OF_ITEM == 0, sort them in terms of "efficiency, where efficiency is value / weight
19:47:37 <Userh626> yea well im having trouble tob bypass it
19:47:49 <aristid> http://en.wikipedia.org/wiki/Cyclic_redundancy_check
19:47:50 <krey_> byorgey: oh wait, i'm being an idiot
19:47:57 <caelan> Userh626: what do you want to bypass it for?
19:47:58 <krey_> byorgey: real late hear (GMT)
19:48:03 <krey_> ^here, dammit
19:48:11 <Userh626> Well for memory editing
19:48:12 <caelan> CRC is Your Friend, unless you're trying to fix a bad drive
19:48:25 <Userh626> quote from my friends attempt 
19:48:42 <BluShift1> krey_: But then I suppose a counter-example could be formed that states that no weight is a factor of the maximum weight.
19:48:54 <Userh626> i found the crc addy and i tried feeding it a copy of correct bytes and tried forcting it to compare a copy of the addresses and it did not work
19:48:57 <BluShift1> krey_: But in your example, my algorithm would work. Not that that means much.
19:48:59 <krey_> BluShift1: :)
19:49:15 <Userh626> does anyone got any idea for me to do ?
19:49:25 <caelan> Userh626: why in the world are you trying to break a CRC?
19:49:30 <BluShift1> krey_: So, is there any one algorithm capable of solving the knapsack problem?
19:49:31 <krey_> BluShift1: admit defeat? surrender to Dynamic Programming?
19:49:43 <BluShift1> krey_: Hah. Not a chance :P
19:49:54 <caelan> BluShift1: yes, if you accept massive runtimes :)
19:49:58 <Userh626> Well this game i play im trying to do a memory edit and the crc check detects my memory edit
19:50:21 <BluShift1> caelan: Massive meaning?
19:50:26 <krey_> BluShift1: of course, you could just enumerate all possible combinations of objects st. the weight limit is not exceeded and pick the best in price
19:50:31 <caelan> Userh626: i think you're in the wrong channel
19:50:40 <Userh626> caelan where can i go
19:50:47 <caelan> BluShift1: as in, testing every possible combination
19:50:51 <krey_> BluShift1: it's incredibly inefficient, but shows that there is an algorithm
19:51:03 <BluShift1> caelan: Brute-forcing isn't really an algorithm :P
19:51:11 <BluShift1> krey_:  ^ ^ ^
19:51:28 <Userh626> So no one knows on how to bypass a game's crc check ?
19:51:34 <caelan> BluShift1: yes it is. it has preconditions and postconditions and exists :)
19:51:43 <krey_> BlueShift1: bullshit, it really is, and it's the only option quite often
19:52:09 <caelan> Userh626: again, wrong channel; try something related to CheatEngine if you must, or just try playing the game as intended
19:52:22 <BluShift1> caelan: Well, I'll look at it from a cryptographic point of view -- it doesn't lower running time any more than brute forcing, so it's not a significant "risk"/
19:52:24 <krey_> Userh626: google $nameOfGame free crack serial
19:52:45 <BluShift1> Userh626: Games are meant to be played without cheats :)
19:52:46 <Userh626> ok chill guys this game is a free mmorpg and cheatengine doesnt allow this game on there site
19:53:05 <Userh626> blushift1 my friend has a business of selling cheats and im trying to help him out he has alot of stress
19:53:08 <krey_> User626: dude, seriously wrong channel
19:53:11 <caelan> Userh626: hmm, so maybe you could just not do it?
19:53:29 <Userh626> sigh.
19:53:31 <Userh626> ok
19:53:42 <tg_> #haskell: serious business.
19:53:46 <Userh626> i though irc channels were ment for leets
19:53:48 <Userh626> i guess not
19:53:58 <caelan> srs bizness plz
19:54:21 <krey_> I feel kinda evil
19:54:21 <tg_> caelan: don't! you think you can speak like them, but you can't! they'll find out!
19:54:22 <BluShift1> caelan: Example being an XSL attack on Rijndael -- Sure, it reduces the key's to test by a good couple orders of magnitude, but it takes srsly like 1400 variables and monsterous amount of time to come up with each of the keys, so it's really not much of a step forward, until computers have a good chunk more RAM and much faster processors.
19:54:34 <krey_> we could've linked him some haskell tutorials...
19:54:52 <caelan> krey_: but that would have been mean :)
19:54:58 <BluShift1> krey_: Hah.
19:55:20 <BluShift1> krey_: Oh yeah, if you learn this you can write your own cheats! It's real easy, I promise!
19:55:30 <krey_> :D
19:55:32 <tg_> he'll probably come back here in 2 years and show you what's what
19:55:36 <caelan> i've actually done a bit of game cheating myself, but then it got boring...
19:55:58 <caelan> no point in winning the easy way, and i'd rather write than win games
19:56:23 <BluShift1> krey_: Example being an XSL attack on Rijndael -- Sure, it reduces the key's to test by a good couple orders of magnitude, but it takes srsly like 1400 variables and monsterous amount of time to come up with each of the keys, so it's really not much of a step forward, until computers have a good chunk more RAM and much faster processors.
19:56:27 <BluShift1> :)
19:56:51 <krey_> wth???
19:57:02 <caelan> BluShift1: that's why heuristics are used
19:57:14 <BluShift1> caelan: In what fashion?
19:57:42 <caelan> i've got a 1000-page-or-so book on planning algorithms, which deal with the knapsack problem a good bit
19:57:55 <krey_> caelan: which one is it?
19:58:10 <caelan> it's called Planning Algorithms, i think
19:58:16 <krey_> :D
19:58:17 <caelan> can't remember off the top of my head
19:58:24 <BluShift1> caelan: Appropriately named :P
19:58:28 <caelan> indeed
19:58:50 <krey_> caelan: I have a fairly standard one called "Algor
19:58:54 <krey_> ithms"
19:59:05 <krey_> oh sorry: "introduction to "
19:59:11 <caelan> the book i'm talking about is a classic in robotics
19:59:14 <tg_> there's also
19:59:15 <tg_> DADS
19:59:15 <tg_> http://xw2k.nist.gov/dads//
19:59:39 <caelan> once my laptop is booted, i'll have the name
19:59:59 <tg_> god knows the stamp collectors over at NIST know their stuff
20:00:03 <krey_> tg_: I'm too afraid to click that link
20:00:17 <tg_> krey_: luckily, it's not well interlinked like wikipedia
20:00:30 <krey_> :D
20:00:34 <caelan> oh wow, forgot about that site
20:00:37 <tg_> that's also unlucky, I suppose, if you are smart enough to understand it
20:01:33 <caelan> yeah, here we go: http://planning.cs.uiuc.edu/
20:02:44 <caelan> BluShift1: basically, your only hope in the face of exponential complexity with large data is to know your data is somehow special
20:13:03 <djahandarie> edwardk, oy
20:19:59 <arhart> Hi All. Supposing I define: mymap _ [] = []; mymap f (x:xs) = (f x):(mymap f xs)
20:20:00 <arhart> Then why does this work (non-strictness of Haskell? Compiler optimization?): last (mymap ((-1)*) [1..10000])
20:20:12 <arhart> Coming from C, I'd expect a stack-overflow.
20:20:35 <shachaf> arhart: Which part of that expression would you expect to overflow?
20:21:25 <Saizan> arhart: lazyness
20:21:26 <arhart> the recursive calls to mymap -- the cons prevents the recursive call from being subject to tall-call recursion, requiring more and more stack space
20:21:51 <shachaf> arhart: Ah. In that case the answer is laziness, as Saizan said.
20:22:23 <Saizan> in addition to preventing TCO, the cons there also let the evaluation suspend
20:22:46 <arhart> Laziness causes just-in-time evaluation, potentially avoiding some evaluation all-together... but last forces evaluation to go through to the end
20:23:01 <arhart> Saizan: please tell me what you mean by suspending evaluation
20:24:28 <Saizan> arhart: let's make an example, last (map (+1) [1,2]) 
20:24:52 <Saizan> now, last needs to inspect the list
20:25:01 <Saizan> so we need to evaluate map (+1) [1,2]
20:25:43 <arhart> I'm with you so far
20:25:56 <Saizan> you can imagine that (+1) and [1,2] go onto the stack, and we scrutinize [1,2] reaching the conclusion that we need to take the second clause of map
20:26:29 <arhart> because [1,2] is not []; okay
20:27:23 <Saizan> at this point we create on the heap a cons cell holding (pointers to) (f x) and (map f xs)
20:27:52 <Saizan> we free the stack, and give this cons cell to last to scritinize
20:28:56 <Saizan> when i say that the cons cell holds those two things, i don't mean that it holds the value they will eventually evaluate to
20:29:01 <arhart> ahh, that makes sense
20:29:14 <Saizan> but just some description of the code to run to evaluate it
20:30:40 <Saizan> (a closure, essentially)
20:30:47 <shachaf> arhart: Also note that as soon as last (which is tail recursive) decides that it doesn't need the value of (f 1), that value (and the whole cons cell) can be garbage-collected.
20:30:56 <Saizan> this is very operational, but since we were talking of stacks :)
20:32:02 <emilmeln> Saizan: Does it really use the stack?
20:33:12 <Saizan> emilmeln: well, when you use too much of it ghc reports a "stack overflow"
20:33:57 <Saizan> my description of what happens is probably naive, but it works for me
20:34:02 <edwardk> djahandarie: heya. was nice seeing you at boston haskell. sorry i didn't get much chance to chat
20:34:31 <djahandarie> Are you feeling any better?
20:34:48 <edwardk> alost done hacking up my lungs. ;)
20:34:52 <edwardk> er almost
20:34:59 <djahandarie> lol
20:35:01 <emilmeln> Saizan: OK. I've about to read "the implementation of FP languages
20:35:11 <djahandarie> I actually had a question I was going to ask you but forgot while I was there
20:35:19 <arhart> shachaf and Saizan, thanks for the explanation
20:35:29 <edwardk> shouting over CBC's ambient background volume made me largely lose my voice though
20:35:52 <Saizan> arhart: np
20:36:06 <Saizan> emilmeln: that's been on my to read list for ages.
20:36:35 <djahandarie> That is... what is the point of a generalized morphism? Considering you can convert for eg. a g_cata to a cata by changing the fwalgebra to the f algebra using Dist and liftW, they seem like they are operationally exactly the same
20:37:18 <djahandarie> I was trying to figure out when using a generalized morphism would be "easier", but couldn't really figure it out from the interface
20:43:13 <edwardk> generalized morphism like how the fw-algebras are augmented? they are just aliases, so they have no power other than expressiveness
20:45:22 <djahandarie> Where would be a case where a g_cata is "more expressive" than a cata?
20:45:29 <edwardk> also, yes, you can turn a g-cata into a cata and vice versa
20:46:24 <edwardk> note that to lower a fw-algebra to an f-algebra you need fmap
20:46:39 <edwardk> (technically to call cata you do as well)
20:46:45 <djahandarie> Right
20:47:56 <edwardk> but there are things you can apply a cata-like operator to that you can't g_cata. see my rotten bananas article on meijer-hutton and fegaras sheard catamorphisms, and the notion of mendler-style catamorphisms in http://knol.google.com/k/catamorphisms#
20:48:34 <edwardk> the latter eliminates the functor requirement, the weirich and washburn catamorphism in the rotten bananas post does the same, but by a different means.
20:49:19 <djahandarie> The mendler-style catamorphism is neat
20:49:27 <edwardk> in those cases you don't have a Functor lying around to lift your g_cata into cata
20:49:57 <edwardk> its just an application of contravariant version of the yoneda lemma.
20:50:36 <edwardk> the weirich/washburn catamorphism is to encode your fixed point as data Nu f = Nu (forall a. (f a -> a) -> a)
20:50:43 <edwardk> then cata f (Nu x) = x f
20:51:47 <djahandarie> So why do you do it the way you do in category-extras rather than these other ways?
20:52:47 <edwardk> because mendler style is less direct. (it actually reaches its most absurd point in the MSFP-08 paper by uustalu on the recursion scheme for the cofree recursive comonad given in mendler style)
20:54:03 <caelan> eek
20:54:23 <edwardk> also by encoding things in terms of a g_cata we can talk about the fact that g_cata is a catamorphism that can exploit the fact that given a distributive law for a comonad over a functor, you can build fold with that extra structure. and by expressing g_cata that way, we can allow you to compose distributive laws
20:54:34 <caelan> i move over to #lisp for three minutes, and next thing i know, people in #haskell are discussing catamorphisms
20:54:51 <edwardk> thereby letting you build more complicated traversals, including the now 'legendary' zygohistomorphic prepromorphism =)
20:55:03 <BluShift1> What is "fold"? I keep hearing people talking about it.
20:55:11 <edwardk> @type foldr
20:55:12 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:55:25 <edwardk> > foldr (+) 0 [1,2,3]
20:55:26 <lambdabot>   6
20:55:41 <edwardk> > foldr (+) z [a,b,c,d]
20:55:41 <lambdabot>   a + (b + (c + (d + z)))
20:55:47 <BluShift1> That tells me nothing :P
20:55:52 <edwardk> > foldl (+) z [a,b,c,d]
20:55:53 <lambdabot>   z + a + b + c + d
20:55:54 <BluShift1> I'm still very, very new to Haskell :P
20:56:01 <srh> that tells you what it does
20:56:01 <edwardk> ah
20:56:30 <edwardk> think of foldr as replacing every cons (:) with the first argument and nil with the second argument in a list. 
20:57:03 <edwardk> so a : b : c : d : [] in the above becomes a + (b + (c + (d + z)))
20:57:36 <edwardk> foldl is a bit more complicated, but basically starts trying to do so from the 'wrong side' of the list.
20:57:46 <BluShift1> Hah, ok. That's still outside of my understanding anyway, but thanks for trying :)
20:57:50 <tolkad> I have heard a benefit of the transformers package over mtl is the lack of functional dependencies. Is there any particular reason for this?
20:58:27 <edwardk> tolkad: the problem with transformers is that the platform hasn't moved to it yet, so basically all you do is cut yourself off from using most of hackage
20:58:39 <djahandarie> mtl-2 is now using transformers
20:58:50 <djahandarie> And hopefully that goes into platform eventually :)
20:58:52 <edwardk> djahandarie: did that get platformed yet?
20:58:58 <tolkad> yes I'm wondering why anyone would want to avoid using functional dependencies?
20:59:20 <djahandarie> tolkad, with transformers you either use monads-fd (functional dependencies) or monads-tf (type families)
20:59:30 <djahandarie> Or now mtl-2 (which uses functional deps)
21:00:00 <Saizan> tolkad: there's this idea that only one of fundeps or type families will ever get into the standard
21:00:15 <djahandarie> Fun deps vs type families do the same thing, just with different styles
21:00:26 <edwardk> tolkad if you write your code to be able to take the old mtl or mtl-2 you're generally in a good place.
21:00:36 <djahandarie> Fun deps being logic programming and type families being lazy functional programming
21:00:55 <codolio> There are actually fundamental differences between the two implementations.
21:01:00 <djahandarie> So generally people like type families more because the style matches Haskell (I guess that's the reason)
21:01:13 <Saizan> if you add OverlappingInstances fundeps can do more
21:01:18 <djahandarie> codolio, neither can express anything more than the other though, right?
21:01:19 <djahandarie> Oh
21:01:28 <edwardk> i like both and continue to need both, so if we get stuck with one or the other i get screwed =/
21:01:30 <tolkad> so when writing my own monad abstraction classes it's preferred to use type families?
21:01:48 <djahandarie> tolkad, nope, whatever is nicer for your usage, really
21:01:56 <djahandarie> Sometimes it works well to mix them
21:02:22 <codolio> There are things that type families will do that you can't do with fundeps, too.
21:02:35 <codolio> Because if you got fundeps to do them, it'd no longer be safe to overlap, I think.
21:02:44 <tolkad> and also things fundeps can do that type families can't
21:02:51 <Saizan> codolio: e.g.?
21:02:55 <tolkad> like class a b | a -> b, b -> a
21:03:00 <tolkad> can't do that with type families
21:03:09 <codolio> I don't have a ready example. But there was a discussion about it not long ago.
21:03:25 <tolkad> at least, I don't think you can
21:03:33 <edwardk> overlappinginstances lack a type family equivalent, data families let you do all sorts of things
21:03:42 <codolio> Fundeps don't allow local constraints, essentially.
21:03:58 <Saizan> class (a ~ F b, b ~ G a) => C a b where type F b; type G a; 
21:04:08 <Saizan> assuming superclass constraints get implemented
21:04:56 <tolkad> Saizan: you can use this hack: class EqTypes a b; instance EqTypes a b
21:05:04 <tolkad> and just make everyone promise not to create an instance
21:05:20 <tolkad> maybe get a pointy stick to help enforce it
21:05:38 <Saizan> no, that doesn't work, but you could use oleg's TypeCast
21:11:48 <codolio> Saizan: http://hpaste.org/41001/families_vs_fundeps
21:12:33 <codolio> Saizan: If unbar were accepted, it would be unsound in the presence of overlapping instances.
21:15:40 <dolio> Because I could create a general instance 'C a ()', and a 'ubar :: Bar a', and then elsewhere write an instance 'C T U', and instantiate 'ubar :: Bar T', ending up with unsafeCoerce :: () -> T.
21:15:58 <jmcarthur> tolkad: "class a b | a -> b, b -> a" ... can't that be emulated by just using an associated data type?
21:16:12 <dolio> Er, () -> U
21:16:50 <Saizan> dolio: thanks
21:17:05 <jmcarthur> it's perhaps a little less convenient to use because you have to either use a newtype or a specialized data structure
21:17:42 <dolio> You could, of course, disallow overlapping fundep instances, and make them behave more like type families, of course. It isn't intrinsic that fundeps work this way.
21:19:06 <dolio> That will effectively be what happens if fundeps ever become sugar for type families/superclass constraints.
21:24:10 <tolkad> jmcarthur: the point was to do it without fundeps
21:24:39 <tolkad> jmcarthur: the point was to do THAT without fundeps
21:25:14 <tolkad> jmcarthur: oh maybe that's what you were saying
21:25:27 <tolkad> jmcarthur: sorry misunderstood
21:26:31 <tolkad> do type families have kinds?
21:26:49 <jmcarthur> tolkad: right, that was not with fundeps
21:27:33 <jmcarthur> tolkad: e.g.     class Foo a where data Bar a   ...   instance Foo A where newtype Bar A = BarA B
21:27:42 <tolkad> jmcarthur: yeah but that's different
21:27:46 <jmcarthur> how so?
21:27:49 <jmcarthur> it's injective
21:28:17 <jmcarthur> tolkad: it's a bit more work to use, i admit
21:41:33 <tolkad> Can I do something like « type family A a :: * -> *; type family B a :: *; type instance A a = B »
21:42:09 <tolkad> what if we could put functional dependencies on our type families =P
21:42:19 <BluShift1> So what's the purpose of binding in list comprehension? Why can't we just work on the initial input?
21:42:21 <tolkad> type family A a b | a -> b
21:44:00 <ddarius> BluShift1: There is no "input" at all.
21:44:15 <tolkad> BluShift1: it's just pretty syntax. you can do the same thing without list comprehensions
21:44:16 <BluShift1> ddarius: Well, there's an argument, right?
21:44:29 <BluShift1> tolkad: I don't follow.
21:44:40 <ddarius> BluShift1: No.
21:45:10 <BluShift1> ddarius: Ok, so how does the function do anything useful?
21:45:25 <ddarius> A list comprehension isn't a function.
21:45:38 <BluShift1> ddarius: I thought everything in Haskell was a function :-/
21:45:52 <ddarius> You thought wrong.
21:46:03 <BluShift1> ddarius: My mistake. What's a list comprehension?
21:46:13 <ddarius> An expression, like 3 + 4.
21:46:47 <BluShift1> ddarius: Oh, ok.
21:46:57 <BluShift1> isn't "+" an infix function?
21:47:34 <ddarius> BluShift1: + is an infix operator and denotes a binary method, but 3 + 4 isn't (+).
21:47:47 <tolkad> BluShift1: that's lambda calculus
21:48:03 <tolkad> BluShift1: haskell is not lambda calculus at all, only based on lambda calculus
21:48:18 <BluShift1> tolkad: Hah, I have no idea what lambda calculus is.
21:48:32 <BluShift1> I'm just trying to learn Haskell from you guys, and LYAH.
21:48:33 <tolkad> BluShift1: that's where you got your "everything in haskell was a function" idea
21:48:44 <tolkad> BluShift1: apparently indirectly without your knowledge
21:48:50 <BluShift1> tolkad: Apparently.
21:49:02 <BluShift1> tolkad: What about *?
21:49:09 <tolkad> BluShift1: that's a kind
21:49:17 <BluShift1> tolkad: Of function, or operator?
21:49:25 <tolkad> BluShift1: kind of type
21:49:34 <BluShift1> tolkad: wut
21:49:36 <tolkad> BluShift1: just like expressions have types, types have kinds
21:49:43 <tolkad> :k Map
21:49:44 <lambdabot> Not in scope: type constructor or class `Map'
21:49:51 <tolkad> :k Either
21:49:52 <lambdabot> * -> * -> *
21:49:58 <tolkad> :k EIther Int
21:49:59 <lambdabot> Not in scope: type constructor or class `EIther'
21:50:05 <tolkad> :k Either Int
21:50:06 <lambdabot> * -> *
21:50:09 <tolkad> :k Either Int Char
21:50:10 <lambdabot> *
21:50:29 <BluShift1> tolkad: I'm too new to understand what those outputs mean, I'm sorry.
21:50:38 <tolkad> ok, then don't worry about *
21:50:42 <tolkad> you don't need it
21:50:49 <tolkad> or did you mean the times function?
21:51:02 <BluShift1> Yes, multiplication.
21:51:14 <BluShift1> I assumed because * is a function, that + and - was as well.
21:51:22 <tolkad> that's part of the class Num. * is a polymorphic function
21:51:30 <tolkad> :t *
21:51:31 <lambdabot> parse error on input `*'
21:51:34 <tolkad> :t (*)
21:51:35 <lambdabot> forall a. (Num a) => a -> a -> a
21:51:43 <BluShift1> tolkad: As in, it's not picky on input, and output is based on input?
21:52:26 <tolkad> BluShift1: as in, the first parameter is any type "a" which has an instance of Num, the second parameter is the same type "a", and the result is of type "a"
21:52:45 <BluShift1> What is type "a"?
21:53:00 <BluShift1> Any type?
21:53:02 <tolkad> a type variable representing any type
21:53:03 <tolkad> yes
21:53:15 <tolkad> but in this case it has to have an instance of the class Num
21:53:15 <BluShift1> Ohh ok.
21:53:21 <BluShift1> What does that mean?
21:53:40 <BluShift1> I take classes to mean OO classes.
21:54:13 <tolkad> http://learnyouahaskell.com/types-and-typeclasses#believe-the-type
21:55:02 <BluShift1> Ok.
21:55:03 <BluShift1> :)
21:55:08 <BluShift1> I'll get back into my hole :P
21:55:08 <Saizan> Num is a typeclass, which has quite little to do with OO classes
21:55:19 <tolkad> BluShift1: it's more like an OO interface
21:55:30 <BluShift1> Ughh, yeah. Back to my hole :P
21:55:45 <BluShift1> I think i need to read through LYAH a few times before I ask anymore questions :P
21:57:03 <caelan> BluShift1: a class in haskell is more like a java interface
21:57:27 <caelan> or like an abstract class
21:57:28 <BluShift1> caelan: Yep, still don't know what that means :)
21:57:36 <BluShift1> caelan: Or that :S
21:57:44 <tolkad> BluShift1: do you know what an OO interface is?
21:57:50 <BluShift1> No! lol
21:58:15 <tolkad> BluShift1: ok, so you know that a can be any type
21:58:22 <BluShift1> tolkad: Yes.
21:58:45 <tolkad> BluShift1: but, haskell has to know how to multiply two expressions of type "a"
21:58:55 <BluShift1> Ok.
21:59:35 <BluShift1> Is this related to the 5 numeric type? Int, Integer, (something I can't remember), and then 2 more belonging to Fraction or something?
21:59:41 <BluShift1> types*
21:59:48 <tolkad> so we have « data T = T Int; class Num a where (*) :: a -> a -> a; instance Num T where (T x) * (T y) = x * y »
22:00:09 <tolkad> wait
22:00:10 <tolkad> sorry
22:00:12 <BluShift1> tolkad: You lost me.
22:00:13 <caelan> BluShift1: yes; all those are instances of Num
22:00:18 <tolkad> so we have « data T = T Int; class Num a where (*) :: a -> a -> a; instance Num T where (T x) * (T y) = T (x * y) »
22:00:43 <tolkad> BluShift1: data T = T Int creates a new data type T with a single constructor T with a paramater of type Int
22:00:49 <caelan> BluShift1: you can think of a typeclass as specifying a set of functions that an instance of the class must have
22:01:00 <djahandarie> BluShift1, note than if you ask questions in here you might get answers pretty "out of order" compared to following a tutorial like LYAH
22:01:24 <djahandarie> But it's good if you just want a bunch of words to google ;)
22:01:29 <BluShift1> Yeah, aside from what caelan said, I have no idea what you just said tolkad.
22:02:04 <BluShift1> I understand this is pretty advanced language, so asking a simple question and getting a simple answer may not always work.
22:02:07 <tolkad> BluShift1: you shouldn't be learning about classes until you have an understanding of types
22:02:12 <BluShift1> I'm just trying to understand this all at once.
22:02:24 <BluShift1> tolkad: Ok.
22:02:48 <BluShift1> tolkad: I do think I understand types from other languages, I think.
22:02:55 <caelan> BluShift1: don't get scared off; just remember that there are conceptual dependencies in haskell
22:03:04 <caelan> as in any lang
22:03:14 <djahandarie> Re your original question, plenty of stuff in Haskell aren't functions
22:03:17 <djahandarie> Like, 3
22:03:21 <djahandarie> Or any value
22:03:29 <BluShift1> caelan: As in, learning one thing requires learning something else a requisite, and so on down the chain, ad infinitum?
22:03:43 <caelan> BluShift1: basically, yes :)
22:03:52 <caelan> djahandarie: isn't 3 a function of no args?
22:03:55 <caelan> :t 3
22:03:55 <lambdabot> forall t. (Num t) => t
22:03:56 <djahandarie> caelan, wrong.
22:03:59 <tolkad> BluShift1: not ad infinitum
22:04:10 <djahandarie> caelan, not in Haskell.
22:04:12 <BluShift1> djahandarie: Well, yes. But I was referring to anything that modifies something, whether it be + or gcd.
22:04:20 <djahandarie> BluShift1, yes, gcd and + are functions
22:04:25 <djahandarie> BluShift1, but 3 + 5 isn't a function
22:04:28 <djahandarie> It's a value
22:04:32 <tolkad> an expression?
22:04:36 <djahandarie> (Eventually a value)
22:04:43 <BluShift1> djahandarie: Eventually.
22:04:59 <BluShift1> djahandarie: But that's the same with any language. A value isn't reached until it's evaluated.
22:05:21 <djahandarie> Sure, but that doesn't make the whole expression a function
22:05:44 <BluShift1> tolkad: If you are probing into knowledge that's infinitely "down the chain", then yes, it's infinite ;)
22:06:01 <BluShift1> djahandarie: It's a function with its arguments, is it not?
22:06:59 <BluShift1> What about gcd 945 327 ? Is that an expression?
22:07:33 <djahandarie> BluShift1, nope. Think of it this way. (+) has type Int -> Int -> Int. (+) 3 has type Int -> Int. (+) 3 5 has type Int  (Note that (+) 3 5 is the same as 3 + 5)
22:07:39 <djahandarie> And yes that is an expression
22:07:54 <djahandarie> Also a value (eventually)
22:07:57 <tolkad> BluShift1: it's not infinite though
22:07:59 <djahandarie> It wouldn't be wrong to say it is just a value
22:08:08 <tolkad> BluShift1: learn a finite number of concepts and you will understand haskell
22:08:15 <Axman6> an unevaluated value maybe?
22:08:21 <djahandarie> Sure
22:08:35 <BluShift1> tolkad: Depends how you define "understand". You might be able to code it, but will you truly grok it?
22:08:35 <djahandarie> If you define a value as a type with no arrows in it, it is a value
22:08:59 <BluShift1> djahandarie: No arrows?
22:09:03 <djahandarie> ->
22:09:15 <enthropy> BluShift1: you'd rather be studying philosophy?
22:09:21 <BluShift1> djahandarie: Aren't those only used in function definitions?
22:09:38 <djahandarie> This is an example type:  a -> a
22:09:56 <BluShift1> enthropy: I find programming and philosophy overlap quite often. I find having a working knowledge of both to be useful.
22:10:03 <djahandarie> Try writing ":t id" in ghci
22:10:15 <BluShift1> djahandarie: id being what?
22:10:23 <djahandarie> A function in the standard libraries
22:10:35 <BluShift1> Ok, I get id :: a -> a
22:10:37 <djahandarie> It's behavior is to just give back whatever you put in
22:10:44 <djahandarie> And that -> is the arrow I was referring to
22:10:47 <BluShift1> Which means it takes any type, and returns that type, correct?
22:10:53 <BluShift1> Yeah, ok
22:11:32 <enthropy> the type almost completely specifies what that function is
22:11:36 <djahandarie> So if you do ":t id 'a'"
22:11:51 <djahandarie> I should switch how I'm writing quotes... this is confusing lol
22:12:02 <djahandarie> Will use « and » now
22:12:06 <BluShift1> enthropy: I've been writing Python for over a year, and I find my 2-month understanding of Java to be substantially better than my understanding of Python.
22:12:28 <BluShift1> djahandarie: Ok.
22:12:38 <djahandarie> So if you do «:t id 'a'» you will get Char back as the type
22:12:56 <djahandarie> So I would consider «id 'a'» a value, not a function
22:13:14 <BluShift1> djahandarie: So, is anything a function?
22:13:25 <djahandarie> «id» is a function
22:13:37 <djahandarie> «id 'a'» is a value
22:13:41 <BluShift1> djahandarie: But id with an argument is not.
22:13:47 <Saizan> things whose types are of the form A -> B for some A and B are definitely functions
22:13:59 <BluShift1> Saizan: Ok.
22:14:01 <Saizan> functions are values too, btw :)
22:14:04 <djahandarie> Yeah
22:14:05 <tolkad> <BluShift1> tolkad: Depends how you define "understand". You might be able to code it, but will you truly grok it?
22:14:05 <tolkad> BluShift1: I think you want ##philosophy
22:14:26 <BluShift1> tolkad: There's honestly a philosophy channel?
22:14:34 <djahandarie> Saizan, I was just avoiding saying that till the end ;)
22:14:59 <tolkad> BluShift1: freenode has a lot of discussion channels
22:15:11 <BluShift1> So a value is sort of an umbrella term for everything represented, and functions are just a sub-term of that?
22:15:31 <djahandarie> BluShift1, sure
22:15:48 <djahandarie> There are things in Haskell which aren't values (like type classes), but you don't really manipulate those
22:15:50 <BluShift1> So what's an expression? Is a function an expression too?
22:16:08 <djahandarie> An expression is more of an operational thing
22:16:18 <BluShift1> djahandarie: What do you mean?
22:16:41 <tolkad> BluShift1: an expression doesn't have anything to do with haskell's type system, it's a syntatic concept
22:17:06 <jmcarthur> an expression is syntax for a value
22:17:22 <jmcarthur> hmm
22:17:25 <BluShift1> A function is syntax for a value, too ;)
22:17:30 <jmcarthur> no
22:17:48 <jmcarthur> a function is a value, but not all values are functions
22:18:00 <BluShift1> jmcarthur: That makes sense.
22:18:04 <jmcarthur> an expression is syntax for a value, and that can include functions
22:18:07 <tolkad> @src id
22:18:07 <lambdabot> id x = x
22:18:18 <tolkad> > id id
22:18:19 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
22:18:19 <lambdabot>    arising from a use of `...
22:18:23 <tolkad> whoops
22:18:26 <tolkad> > id id 1
22:18:26 <lambdabot>   1
22:18:32 <djahandarie> As usual lambdabot giving shitty messages
22:18:33 <tolkad> :t id id
22:18:34 <lambdabot> forall a. a -> a
22:18:43 <jmcarthur> \x -> x     is an expression.  it's the syntax for a function that takes a value and returns it
22:18:45 <dmwit> :t \n f x -> f (n f x)
22:18:46 <lambdabot> forall t t1 t2. ((t1 -> t2) -> t -> t1) -> (t1 -> t2) -> t -> t2
22:18:54 <tolkad> > id (\x -> x)
22:18:55 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
22:18:55 <lambdabot>    arising from a use of `...
22:18:56 <tolkad> > id (\x -> x) 1
22:18:57 <BluShift1> jmcarthur: So an expression is just a standardised way or representing functions? Like 1 + 2 / 3?
22:18:57 <lambdabot>   1
22:19:02 <tolkad> :t id (\x -> x)
22:19:03 <jmcarthur> BluShift1: not just functions
22:19:03 <lambdabot> forall t. t -> t
22:19:07 <djahandarie> BluShift1, any value
22:19:13 <djahandarie> BluShift1, 3 is an expression
22:19:17 <BluShift1> jmcarthur: Sorry, values and potentially functions
22:19:25 <BluShift1> Ok.
22:19:38 <BluShift1> So an expression is literally what it means -- it's the expression of something.
22:19:41 <jmcarthur> "expression" is a very abstract word. it's not "standardized" in any way unless you are talking about a specific language
22:20:06 <BluShift1> When I express my disbelief in my need to sleep, I say it out loud. When I express a value, I write "3".
22:20:12 <tolkad> BluShift1: it's a valid sequence of characters in haskell that can be reduced to a value through computation
22:20:19 <BluShift1> Ok.
22:20:19 <jmcarthur> BluShift1: i think you have the idea
22:20:23 <BluShift1> YES.
22:20:29 * djahandarie nods
22:20:31 <BluShift1> Feeeeelss goooooooood, maaaaaaaaan.
22:20:44 <djahandarie> Now you know some useless jargon
22:20:54 <djahandarie> Rejoice
22:21:02 <ddarius> It's certainly not useless.
22:21:09 <BluShift1> djahandarie: Thanks for the vote of confidence >_>
22:21:15 * djahandarie was joking
22:21:18 <tolkad> you should probably have learned the word "expression" during your math education
22:21:33 <djahandarie> And math education should have probably not sucked at teaching people
22:21:35 <BluShift1> tolkad: Hah, I probably did at some point. Alas, I never was a "math guy".
22:21:53 <jmcarthur> math education is consistently inconsistent
22:22:14 <BluShift1> It's not that I never knew what an expression was, I've just never had to compare it to the concept of a value and a function.
22:22:28 <djahandarie> jmcarthur, I'm pretty sure that reduces to inconsistent :P
22:23:02 <jmcarthur> djahandarie: then you get the joke
22:23:17 <BluShift1> Ok, so a function with an argument is basically a value.
22:23:20 <BluShift1> Right?
22:23:29 <jmcarthur> BluShift1: it's a value without an argument too
22:23:47 <BluShift1> jmcarthur: It's not a variable?
22:23:58 <tolkad> haskell doesn't have variables like other languages
22:24:06 <jmcarthur> variables are another syntactic concept
22:24:23 <BluShift1> tolkad: I mean, a variable in the sense that it has no defined value, at present.
22:24:43 <djahandarie> BluShift1, if the thing on the right of the first arrow of the function f has no arrows in it, then f with a value will not be a function
22:24:57 <djahandarie> (To be precise)
22:25:20 <djahandarie> a -> a -> a   applied with a single a will give you   a -> a
22:25:22 <BluShift1> djahandarie: What?
22:25:33 <tolkad> BluShift1: a function is a value. it has a type of (a -> b) for some types "a" and "b". it can be applied to a value of type "a" yielding a value of type "b"
22:25:45 <jmcarthur> BluShift1: a function applied to an argument can still be a function
22:25:48 <BluShift1> tolkad: Ok, sure.
22:25:56 <BluShift1> Ok.
22:26:02 <tolkad> > let f x = x :: a -> a in f 0
22:26:03 <lambdabot>   Inferred type is less polymorphic than expected
22:26:03 <lambdabot>    Quantified type variable...
22:26:11 <jmcarthur> BluShift1: (+) 2 is still a function despite being applied to an argument
22:26:12 <BluShift1> But is a function without any arguments (one that needs arguments, of course) a function?
22:26:18 <tolkad> whatever
22:26:25 <jmcarthur> BluShift1: however, (+) 2 3 is a value
22:26:26 <BluShift1> SORRY
22:26:26 <BluShift1> Wait
22:26:27 <tolkad> oh whoops
22:26:29 <BluShift1> Wait wait wait
22:26:34 <tolkad> > let f = \x -> x :: a -> a in f 0
22:26:35 <lambdabot>   Inferred type is less polymorphic than expected
22:26:35 <lambdabot>    Quantified type variable...
22:26:42 <tolkad> > let f = (\x -> x) :: a -> a in f 0
22:26:43 <lambdabot>   0
22:26:44 <jmcarthur> BluShift1: well, unless you define an instance of Num for functions, but that's just pushing things in this discussion ;)
22:26:45 <tolkad> there we go
22:26:46 <BluShift1> What I meant was, is a function without an argument a value?
22:26:47 <tolkad> lol
22:26:49 <pumpkin> BluShift1: any value of a type (a -> b) is a function, and nothing else is
22:27:16 <jmcarthur> i think BluShift1 is the most fun troll i've ever seen here :)
22:27:28 <djahandarie> jmcarthur, no, we all just suck at explaining
22:27:28 <BluShift1> Why does everyone think I'm a troll?
22:27:33 <jmcarthur> i don't mean that to be offensive
22:27:33 <djahandarie> I don't.
22:27:44 <BluShift1> #python and ##php both said that same thing Q_Q
22:27:49 <djahandarie> You've asked good questions consistantly
22:27:53 <jmcarthur> BluShift1: i just think this whole conversation is kind of cycling, is all
22:27:55 <djahandarie> I don't know why jmcarthur said that
22:28:01 <djahandarie> Well now I do
22:28:02 <jmcarthur> BluShift1: i don't actually believe you are trolling
22:28:19 <ddarius> BluShift1: Perhaps you should just sleep on it.
22:28:22 <BluShift1> jmcarthur: I think I might just be too inexperienced to be asking these questions, is all.
22:28:30 <jmcarthur> BluShift1: no worries :)
22:28:39 <BluShift1> ddarius: I don't feel this is cycling?
22:28:50 <jmcarthur> BluShift1: all functions are values
22:28:58 <BluShift1> jmcarthur: Sure.
22:29:00 <ddarius> BluShift1: I didn't say anything in regards to that.
22:29:14 <BluShift1> ddarius: So why did you say "sleep on it"?
22:29:16 <jmcarthur> BluShift1: "is a function without an argument a value?"   in response to that
22:29:28 <BluShift1> jmcarthur: Right
22:29:30 <ddarius> BluShift1: Because that might be the best approach for now.
22:29:52 <BluShift1> ddarius: I think I'm just beginning to get it. I've been reading about Haskell all day :P
22:29:58 <jmcarthur> BluShift1: look what i've done. :( i don't want to frustrate you
22:29:59 <tolkad> BluShift1: just wait until you try to understand currying...
22:30:16 <djahandarie> Currying is simple
22:30:24 <enthropy> everything is simple
22:30:30 <ddarius> BluShift1: Having read about Haskell all day is just more of an argument to sleep on it.
22:30:33 <djahandarie> enthropy, what?
22:30:39 <BluShift1> jmcarthur: You're not. You're explaining things concisely, and accurately. here's no harm in that :)
22:31:04 <BluShift1> ddarius: I'll lose my train of thought :)
22:31:07 <jmcarthur> BluShift1: well it was unfair to call you a troll
22:31:13 <ddarius> BluShift1: That's the goal.
22:31:14 <enthropy> djahandarie: we're discussing words currently, right?
22:31:17 <djahandarie> jmcarthur, you're such a troll
22:31:28 <djahandarie> enthropy, lol, whatever
22:31:29 * jmcarthur bans himself
22:31:33 <BluShift1> Hahahaha
22:31:46 <BluShift1> Oh lord, I've got everyone hating themselves now -_-
22:31:47 * pumpkin bans jmcarthur 
22:31:50 --- mode: ChanServ set +o pumpkin
22:31:52 * djahandarie bans... oh wait
22:31:57 <tolkad> BluShift1: the "g" in « f x = 0; g y = f » is the same as the "g" in « g x y = 0 »
22:32:02 <pumpkin>  /mode +b jmcarthur
22:32:02 --- mode: ChanServ set +o jmcarthur
22:32:09 * pumpkin cowers
22:32:12 --- mode: pumpkin set -o pufuwozu
22:32:13 <jmcarthur>  /mode +q pumpkin 
22:32:15 --- mode: jmcarthur set -o jmcarthur
22:32:16 --- mode: pumpkin set -o pumpkin
22:32:22 <pumpkin> :(
22:32:31 <djahandarie> pumpkin, how dare you do that to pufuwozu
22:32:37 <pumpkin> sorry pufuwozu 
22:32:37 <BluShift1> I just found is strange (and slightly insulting) that you called me a troll, because every other programming channel I've been to for an extended period has said that. But if you were kidding, then no hard no foul :)
22:32:54 <tolkad> BluShift1: the type of "f" in the first example is a -> Integer, the type of g in both examples is a -> b -> Integer
22:33:15 <ddarius> BluShift1: If you are getting consistently called a troll, perhaps you might want to rethink your approach.
22:33:15 <BluShift1> tolkad: What is b?
22:33:21 <tolkad> BluShift1: I'm lying, the type is actually any Integral, not just Integer, but you might not understand that yet and it's not important
22:33:36 <tolkad> BluShift1: the "a" in each of those type signatures are different
22:33:47 <tolkad> BluShift1: the type of "f" in the first example is a -> Integer, the type of g in both examples is b -> c -> Integer
22:34:11 <jmcarthur> BluShift1: i only said it because i noticed a couple of questions you asked seemed to be repetitions of the same things in different words. it's a characteristic that is somewhat common in trolls
22:34:14 <tolkad> BluShift1: "a", "b", and "c" are all type variables, they mean you can pass a value of any type to the function
22:34:28 <jmcarthur> BluShift1: but you have not exhibited any actual trollish behavior that i've noticed
22:34:32 <tolkad> BluShift1: the function doesn't care what type because it doesn't do anything with it
22:34:55 <BluShift1> tolkad: Ok, so given that notation I'm lead to believe that a function (which must have a type a -> b) can not return the same type it received. Is this correct?
22:35:06 <BluShift1> jmcarthur: :( My grade 3 teacher said that same thing.
22:35:20 <tolkad> BluShift1: no, a and b can be the same type
22:35:30 <tolkad> BluShift1: two different type variables can have the same value
22:35:37 <BluShift1> tolkad: Oh.
22:35:47 <jmcarthur> BluShift1: anyway, i apologize, and if you still want to discuss this we should talk about it in a private session
22:36:01 <tolkad> BluShift1: also, an important concept here is that (a -> b -> c) is the same as (a -> (b -> c))
22:36:44 <enthropy> tolkad: it might be good to be picky about what is meant by 'type variables having values'
22:36:46 <BluShift1> So, a -> b can be different types, or the same. But a -> a means the input type will match the output type?
22:37:11 <BluShift1> tolkad: You need to explain your use of parentheses.
22:37:34 <tolkad> BluShift1: a correction on what I said before: two different type variables can refer to the same type
22:37:48 <BluShift1> tolkad: You said that already :)
22:37:51 <tolkad> BluShift1: I didn't mean "value" in the haskell sense of the word
22:37:59 <tolkad> BluShift1: just clearing that up
22:38:03 <BluShift1> tolkad: I know :)
22:39:18 <tolkad> a -> b -> c means a function that takes a parameter of type a, and returns a new function which takes a parameter of type b, and returns a value of type c
22:39:44 <tolkad> (b -> c) means a function that takes a parameter of type b and returns a value of type c
22:40:00 <tolkad> a -> b -> c is the same as a -> (b -> c)
22:40:07 <BluShift1> tolkad: Ok, so what's an example of a function that returns a function? 
22:40:15 <tolkad> BluShift1: the "g" in « f x = 0; g y = f » is the same as the "g" in « g x y = 0 »
22:40:58 <tolkad> f x = 0; g y = f
22:41:02 <BluShift1> Oh, ok.
22:41:28 <tolkad> BluShift1: let's define the id function. id x = x
22:41:32 <BluShift1> Ok.
22:41:45 <tolkad> what's the type of « id id »
22:42:01 <tolkad> ?
22:42:33 <tolkad> that means the function id applied to the function id
22:42:59 <tolkad> let's look at the type of id: a -> a
22:43:15 <Axman6> @pl id x = x
22:43:15 <lambdabot> id = id
22:43:22 <Axman6> >_>
22:43:26 <tolkad> it returns it's paramater, so it must return the same type as its parameter
22:43:29 <djahandarie> Haha @pl fail
22:43:39 <tolkad> its parameter*
22:44:16 <tolkad> BluShift1: so id id yields the value (\x -> x)
22:44:21 <BluShift1> Ok.
22:44:33 <tolkad> so
22:44:35 <tolkad> > 0
22:44:35 <lambdabot>   0
22:44:38 <tolkad> > id 0
22:44:39 <lambdabot>   0
22:44:48 <tolkad> > (id id) 0
22:44:49 <lambdabot>   0
22:44:57 <tolkad> > id (id 0)
22:44:58 <lambdabot>   0
22:45:02 <tolkad> make sense?
22:45:03 <BluShift1> > :t id id
22:45:04 <lambdabot>   <no location info>: parse error on input `:'
22:45:09 <BluShift1> Oh :-/
22:45:09 <tolkad> :t id id
22:45:10 <lambdabot> forall a. a -> a
22:45:35 <BluShift1> Shouldn't it be a -> a -> a?
22:45:38 <tolkad> don't worry about the "forall a.". you don't use that syntax in standard haskell
22:45:56 <tolkad> BluShift1: no, you are applying the function "id" to the value "id"
22:46:01 <djahandarie> Again lambdabot sucking
22:46:06 <tolkad> BluShift1: id returns whatever you pass it
22:46:14 <BluShift1> tolkad: Oh.
22:46:14 <tolkad> BluShift1: so it returns id
22:46:25 <BluShift1> :t id id id
22:46:26 <lambdabot> forall a. a -> a
22:46:29 <BluShift1> ...
22:46:35 <tolkad> :t id (id id)
22:46:36 <lambdabot> forall a. a -> a
22:46:40 <tolkad> :t (id id) id
22:46:40 <enthropy> just because   (id id) 0  == id (id 0) == id id 0, does not mean you can associate function application as you please
22:46:40 <lambdabot> forall a. a -> a
22:46:53 <BluShift1> enthropy: wut
22:47:14 <BluShift1> tolkad: Ok, so what sort of function returns a function?
22:47:17 <enthropy> BluShift1: for other functions, that is not the case
22:47:30 <BluShift1> Because it appears that id doesn't return a function, at all.
22:47:35 <tolkad> enthropy: he's saying that (f x) y is not always the same as f (x y) for values f, x, and y
22:47:44 <tolkad> BluShift1: id can return a function
22:47:50 <tolkad> BluShift1: because functions are values
22:48:13 <BluShift1> tolkad: Ok, so how would we make it return a value?
22:48:13 <tolkad> enthropy: whoops, I meant BluShift1 
22:48:22 <tolkad> > id 0
22:48:23 <lambdabot>   0
22:48:29 <tolkad> BluShift1: we pass it a value
22:48:46 <BluShift1> tolkad: But the type it returns with :t id 0 is a -> a
22:48:46 <djahandarie> > (+) 1 2
22:48:47 <lambdabot>   3
22:48:51 <djahandarie> > (id +) 1 2
22:48:52 <lambdabot>   3
22:49:07 <djahandarie> :t (+)
22:49:08 <lambdabot> forall a. (Num a) => a -> a -> a
22:49:08 <tolkad> BluShift1: no, it doesn't return type a -> a, it IS type a -> a
22:49:12 <djahandarie> :t id (+)
22:49:12 <lambdabot> forall a. (Num a) => a -> a -> a
22:49:27 <tolkad> BluShift1: it only returns type a -> a if you call it on something of type a -> a
22:49:28 <BluShift1> tolkad: Right, ok.
22:49:41 <BluShift1> :t id 0
22:49:42 <lambdabot> forall t. (Num t) => t
22:49:46 <BluShift1> Num, ok.
22:49:50 <BluShift1> :t id 'a'
22:49:51 <lambdabot> Char
22:49:55 <BluShift1> :t id id
22:49:56 <lambdabot> forall a. a -> a
22:49:58 <BluShift1> Function.
22:50:18 <djahandarie> Numbers are just a little weird
22:50:19 <BluShift1> Ok, so you'll never actually see the type "a -> a -> a" with :t, right?
22:50:58 <djahandarie> :t const
22:50:58 <lambdabot> forall a b. a -> b -> a
22:51:04 <BluShift1> Because a -> a -> a -> describes the transformations, whereas :t just returns the type of the final transormation?
22:51:07 <tolkad> BluShift1: we could write « f :: a -> a -> a; f x y = x »
22:51:37 <tolkad> @let f = (\x -> (\y -> x)) :: a -> a -> a
22:51:38 <lambdabot>  Defined.
22:51:39 <tolkad> :t f
22:51:40 <lambdabot>     Ambiguous occurrence `f'
22:51:40 <lambdabot>     It could refer to either `L.f', defined at <local>:7:0
22:51:40 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:73:0-32
22:51:43 <djahandarie> Haha
22:51:46 <tolkad> :t L.f
22:51:47 <lambdabot> forall a. a -> a -> a
22:52:06 <tolkad> djahandarie: what kind of idiot exports a function named "f"
22:52:16 <djahandarie> tolkad, SimpleReflect
22:52:23 <djahandarie> > g a b
22:52:24 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:52:24 <lambdabot>    `GHC.Show.Show a'
22:52:24 <lambdabot>      a...
22:52:30 <djahandarie> > g a b :: Expr
22:52:30 <lambdabot>   g a b
22:52:48 <djahandarie> So you can do all that neat stuff with showing exectuion
22:52:49 <tolkad> djahandarie: you are confusing BluShift1 :P
22:52:51 <Axman6> > g (a b) $ c
22:52:52 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
22:52:52 <lambdabot>         against infe...
22:52:56 <Axman6> > g (a b) $ c :: Expr
22:52:57 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
22:52:57 <lambdabot>         against infe...
22:53:00 <BluShift1> So wait, that type is "a -> a -> a" because that function contains another function? or what?
22:53:04 <Axman6> > g (a b) c :: Expr
22:53:05 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
22:53:05 <lambdabot>         against infe...
22:53:12 <Axman6> phail
22:53:21 <BluShift1> SKYNET -- ONLINE
22:53:29 <tolkad> BluShift1: meaning the function called on a parameter of type "a" returns a function of type a -> a
22:53:31 <djahandarie> BluShift1, you can think of it as « a -> (a -> a) »
22:54:12 <BluShift1> djahandarie: Ok.
22:54:16 <tolkad> BluShift1: for example, the multiplication function
22:54:25 <BluShift1> So why doesn't id id 0 have the type a -> a -> a?
22:54:26 <tolkad> :t (*)
22:54:27 <lambdabot> forall a. (Num a) => a -> a -> a
22:54:49 <tolkad> BluShift1: id called on a parameter of type a returns a value of type a
22:55:05 <tolkad> BluShift1: id called on a parameter of type (a -> a) returns a value of type (a -> a)
22:55:24 <tolkad> :t (*) 5
22:55:25 <lambdabot> forall t. (Num t) => t -> t
22:55:35 <tolkad> :t (*) 0 0
22:55:36 <lambdabot> forall t. (Num t) => t
22:55:55 <tolkad> > ((*) 5) 5
22:55:56 <BluShift1> tolkad: It called on the parameter 0, (type a) , which is passes to id as type a, which returns type a, so a -> a -> a, no?
22:55:56 <lambdabot>   25
22:56:17 <djahandarie> BluShift1, if it returns a, then it is a
22:56:22 <djahandarie> Not something more complicated
22:56:33 <BluShift1> I don't follow/
22:57:00 <tolkad> BluShift1: a function of type a -> b applied to an argument of type a yields a value of type b
22:57:12 <BluShift1> tolkad: Right/
22:57:32 <djahandarie> BluShift1, just use :t a bunch in ghci and see what it returns
22:57:39 <djahandarie> It should become very clear how it works
22:57:45 <BluShift1> djahandarie: Yeah?
22:58:03 <djahandarie> Yes, try it on (+) and other functions you know of
22:58:10 <tolkad> BluShift1: if the function "f" has the type a -> b, and the value "t" has the type "a", then the expression "f t" has the type b
22:58:18 <BluShift1> Why would + and * return a function?
22:58:34 <tolkad> BluShift1: because in haskell all functions have one parameter
22:58:40 <Axman6> :t (+)
22:58:41 <lambdabot> forall a. (Num a) => a -> a -> a
22:58:48 <tolkad> BluShift1: functions with two parameters are really functions that return functions
22:58:49 <Axman6> which is a -> (a -> a)
22:58:53 <Axman6> :t (1+)
22:58:54 <lambdabot> forall t. (Num t) => t -> t
22:58:56 <BluShift1> tolkad: Oooooohh.
22:59:00 <BluShift1> tolkad: I see.
22:59:03 <djahandarie> «(+)» IS a function, «(+) 2» is STILL a function. «(+) 2 3» is finally not a function
22:59:14 <BluShift1> So... zip is a function that returns a function?
22:59:18 <tolkad> :t zip
22:59:19 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
22:59:23 <BluShift1> yes.
22:59:26 <BluShift1> YES *
22:59:35 <enthropy> > (+) 2 3 4
22:59:36 <lambdabot>   5
22:59:40 <BluShift1> I feel like I'm winning a little.
22:59:47 <djahandarie> enthropy, wow, that was not a good example to bring up
22:59:54 <djahandarie> BluShift1, ignore what just happened
23:00:01 <djahandarie> That is lambdabot being stupid as hell
23:00:05 <tolkad> WTF
23:00:08 <tolkad> why did that happen?
23:00:13 <djahandarie> tolkad, vector-space num instance
23:00:16 <BluShift1> djahandarie: Is that totally incorrect Haskell?
23:00:26 <tolkad> BluShift1: yes
23:00:29 <djahandarie> BluShift1, it is only correct with a weird instance
23:00:29 <Axman6> bloody Cale
23:00:35 <Veinor> BluShift1: it's syntactically valid, but it's... complicated
23:00:37 <Axman6> > id + 3
23:00:37 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
23:00:37 <lambdabot>    arising from a use of `...
23:00:38 <tolkad> BluShift1: it's correct because of some crazy extension
23:00:38 <enthropy> it is doing as it was told
23:00:42 <Axman6> > id + 3 4
23:00:43 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
23:00:43 <lambdabot>    arising from a use of `...
23:00:47 <djahandarie> tolkad, it isn't an extension.
23:00:50 <djahandarie> It's valid Haskell
23:00:52 <djahandarie> Just weird
23:00:56 <BluShift1> (+) 3 2
23:01:06 <BluShift1> > (+) 3 2
23:01:07 <lambdabot>   5
23:01:09 <tolkad> oh wait, I understand
23:01:16 <BluShift1> > (+) 3 2 1
23:01:17 <lambdabot>   5
23:01:21 <tolkad> BluShift1: it's correct because of a package doing something evil
23:01:34 <Veinor> yeah
23:01:46 <djahandarie> I wish this shit wasn't imported into lambdabot at times like these
23:01:47 <BluShift1> tolkad: Does (+) normally just take at most 2 parameters?
23:01:54 <djahandarie> BluShift1, it still does
23:01:55 <djahandarie> > 2 3
23:01:56 <lambdabot>   Ambiguous type variable `t' in the constraint:
23:01:56 <lambdabot>    `GHC.Num.Num t' arising f...
23:01:58 <djahandarie> > 2 3 :: Int
23:01:59 <lambdabot>   2
23:02:01 <djahandarie> That's why it breaks
23:02:09 <tolkad> BluShift1: it hase one paramater, all functions in haskell have one parameter
23:02:12 <Veinor> fucking caleskell
23:02:26 <BluShift1> Wait, wtf.
23:02:29 <tolkad> BluShift1: (+) 1 2 means ((+) 1) 2
23:02:35 <djahandarie> BluShift1, yes, ignore it for sanities sake
23:02:40 <tolkad> BluShift1: ((+) 1) returns a function
23:02:41 <BluShift1> tolkad: Ok.
23:02:48 <tolkad> BluShift1: which is then applied to 2
23:03:01 <tolkad> so we can write
23:03:06 <tolkad> > (+) (1 2)
23:03:07 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
23:03:07 <lambdabot>    arising from a use of `...
23:03:10 <BluShift1> So Int -> Int -> Int?
23:03:11 <tolkad> > (+) (1 2) 3
23:03:12 <lambdabot>   4
23:03:23 <Axman6> > 1 2 3 4 5 6
23:03:24 <lambdabot>   Ambiguous type variable `t' in the constraint:
23:03:24 <lambdabot>    `GHC.Num.Num t' arising f...
23:03:25 <tolkad> just kidding
23:03:36 <tolkad> ignore that > (+) (1 2) 3, it's bad
23:03:53 <BluShift1> You guys are confusing the shit out of my face.
23:03:59 <tolkad> BluShift1: yes, but you can also use it for other types of numbers
23:04:07 <tolkad> BluShift1: like Float, for example
23:04:09 <djahandarie> BluShift1, blame it on enthropy
23:04:15 <BluShift1> Hah, ok!
23:04:24 <enthropy> > (sin^2 + cos^2) 3
23:04:25 <lambdabot>   0.9999999999999999
23:04:43 <djahandarie> enthropy, I guess you're the troll here now :P
23:04:45 <BluShift1> tolkad: So, :t (+) 3.0 3.2  == Float -> Float -> Float?
23:04:45 <Veinor> blame it on Cale
23:04:53 <tolkad> no
23:05:05 <tolkad> BluShift1: :t (+) 3.0 3.2 == Float
23:05:21 <BluShift1> :t (+) 3.0 3.2
23:05:22 <lambdabot> forall t. (Fractional t) => t
23:05:25 <BluShift1> ???
23:05:27 <BluShift1> Wtf?
23:05:34 <BluShift1> :T (+) 1 2
23:05:41 <BluShift1> :t (+) 1 2
23:05:42 <lambdabot> forall t. (Num t) => t
23:05:43 <enthropy> it's rather nice, but unfortunately results in overlapping instances for nice show of functions
23:05:49 <tolkad> :t (+)
23:05:50 <lambdabot> forall a. (Num a) => a -> a -> a
23:05:55 <BluShift1> OH
23:06:00 <tolkad> :t ((+) :: Int -> Int -> Int)
23:06:01 <lambdabot> Int -> Int -> Int
23:06:17 <tolkad> :t ((+) :: Float -> Float -> Float)
23:06:17 <lambdabot> Float -> Float -> Float
23:06:32 <BluShift1> So the :t of a function shows how many times it calls another function, but the :t of a function with paramenters just shows the returned type?
23:06:53 <tolkad> BluShift1: uh, your language is a little off, but conceptually yes
23:07:04 <BluShift1> tolkad: Where?
23:07:16 <tolkad> BluShift1: it doesn't show "how many times it calls another function"
23:07:28 <BluShift1> tolkad: Right, but be can infere how many times it does, right?
23:07:34 <BluShift1> infer*
23:07:45 <BluShift1> we*
23:07:47 <tolkad> the :t of a function shows the type of the function
23:08:10 <BluShift1> tolkad: But given the number of "hops", we can figure out how many functions it calls too, right?
23:08:12 <tolkad> the :t of any expression shows the ultimate type of that expression
23:08:19 <Veinor> BluShift1: you can infer how many 'arguments' a function has by looking at the type, yeah
23:08:29 <Axman6> :type (+)
23:08:31 <tolkad> BluShift1: we can figure out how many function applications there are in the expression, yes
23:08:33 <BluShift1> Veinor: That's what I mean :)
23:08:48 <Veinor> :t zipWith3
23:08:49 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
23:09:01 <BluShift1> Oh right, we don't "call functions" in Haskell, right?
23:09:05 <tolkad> > 1 2 3 4 5
23:09:06 <lambdabot>   Ambiguous type variable `t' in the constraint:
23:09:06 <lambdabot>    `GHC.Num.Num t' arising f...
23:09:08 <BluShift1> We simply apply multiple functions.
23:09:13 <tolkad> > 1 2 3 4 5 :: Int
23:09:14 <lambdabot>   1
23:09:25 <BluShift1> > 2 'a; :: INT
23:09:26 <lambdabot>   <no location info>:
23:09:26 <lambdabot>      lexical error in string/character literal at chara...
23:09:33 <BluShift1> > 2 'a' :: Int
23:09:34 <lambdabot>   2
23:09:38 <BluShift1> :O
23:09:42 <tolkad> BluShift1: we apply a function of type a -> b to a parameter of type "a" yielding a value of type "b"
23:09:46 <Veinor> ignore that, that's not normal for haskell
23:09:59 <tolkad> BluShift1: if the function "f" has the type a -> b, and the value "t" has the type "a", then the expression "f t" has the type b
23:10:23 <BluShift1> Veinor: I assume the Haskell that Lambdabot does is extensively hacked upon to make it safe?
23:10:41 <BluShift1> tolkad: Right.
23:10:48 <djahandarie> BluShift1, lambdabot is just fucking weird
23:10:54 <tolkad> BluShift1: not really, haskell makes it easy to make safe
23:10:55 <djahandarie> Which makes it awful for teaching people
23:11:04 <BluShift1> djahandarie: Haha
23:11:32 <tolkad> BluShift1: once you understand type classes, you can understand why (1 2) works. it only works because of something crazy which shouldn't ever be done though
23:11:33 <Veinor> BluShift1: lambdabot haskell is the same that you get when you launch ghci with a few standard-ish extensions, no execution of IO (so you can't format the hard drive or anything), and a couple fucking weird things
23:11:34 <djahandarie> But the maintainer likes to have the extensions because they let us talk about neat stuff
23:12:12 <BluShift1> > (1 2)
23:12:12 <lambdabot>   Ambiguous type variable `t' in the constraint:
23:12:12 <lambdabot>    `GHC.Num.Num t' arising f...
23:12:20 <tolkad> BluShift1: just forget about it
23:12:25 <BluShift1> ?
23:12:26 <BluShift1> Ok.
23:12:58 <BluShift1> Veinor: No limit on things that might take up huge amounts of memory?
23:12:59 <tolkad> BluShift1: so, if function "f" has the type "a -> b" and "t" has the type "a" what is the type of the expression "f t"?
23:13:10 <tolkad> BluShift1: it has a time limit
23:13:11 <BluShift1> tolkad: b?
23:13:14 <BluShift1> tolkad: Ahh
23:13:15 <tolkad> BluShift1: probably a memory limit too
23:13:20 <tolkad> BluShift1: yes
23:13:26 <enthropy> djahandarie: ghc accepts those instances without any additional flags
23:13:54 <djahandarie> enthropy, the num instances? I know, I said that already lol
23:13:57 <tolkad> BluShift1: if a function "f" has the type "a -> b -> c" and it is applied to an argument "t" of type "a" what is the type of the expression "f t"?
23:14:08 <BluShift1> So if f has type "a -> b", and f 2 2 applies f twice for both parameters, then the type would be a -> a -> b?
23:14:42 <tolkad> BluShift1: f 2 2 applied f to 2, and applies the result of that application to the second 2
23:14:54 <tolkad> BluShift1: f 2 2 = (f 2) 2
23:14:55 <BluShift1> tolkad: Yes.
23:15:07 <tolkad> BluShift1: if a function "f" has the type "a -> b -> c" and it is applied to an argument "t" of type "a" what is the type of the expression "f t"?
23:15:14 <BluShift1> tolkad: c?
23:15:21 <tolkad> BluShift1: b -> c
23:15:27 <BluShift1> Oh.
23:15:34 <BluShift1> Right, because it's only one argument.
23:16:04 <Veinor> BluShift1: it helps to just write some simple programs
23:16:11 <BluShift1> So if f took two arguments, the return value would be c. But in this case, it returns a function because the other function "hasn't been used", so to speak?
23:16:25 <tolkad> BluShift1: if a function "f" has the type "a -> b -> c", "t" has the type "a" and "s" has the type "b" what is the type of the expression "f t s"?
23:16:30 <Veinor> you could think of it that way, yeah
23:16:37 <tolkad> BluShift1: it always returns a function
23:16:43 <BluShift1> Veinor: That's not horribly retarded?
23:16:50 <tolkad> BluShift1: sometimes the function it returns is also being applied
23:17:07 <Veinor> I mean, most of the time I write haskell I think of stuff as 'okay, f x y is calling f with the arguments x and y'
23:17:09 <Veinor> ir
23:17:16 <dark> f a b means (f a) b
23:17:17 <Veinor> it's just that sometimes it's better to think of it correctly
23:17:18 <BluShift1> tolkad:  c?
23:17:24 <tolkad> BluShift1: yes
23:17:56 <tolkad> BluShift1: the reason what you said is wrong is that no function takes two arguments
23:17:59 <dark> a -> b -> c means a -> (b -> c)
23:18:22 <tolkad> BluShift1: haskell just lets you write functions as if they do for simplicity
23:18:24 <BluShift1> tolkad: Right. On the surface though, it would appear you're passing two arguments to one function.
23:18:27 <tolkad> yes
23:18:29 <Veinor> right
23:18:33 <Veinor> and it's fine to think of it that way
23:18:39 <Veinor> as long as you understand that that's not what you're really doing
23:18:44 <BluShift1> Veinor: Ok.
23:18:54 <tolkad> BluShift1: really you are passing the first argument to the function, and then apply the result of that to the second argument
23:19:00 <tolkad> applying*
23:19:06 <BluShift1> Veinor: And the "correct" way to think of it is (+) 2 2 == (+ 2) 2?
23:19:17 <tolkad> BluShift1: yes
23:19:31 <tolkad> BluShift1: haskell is based on http://en.wikipedia.org/wiki/Lambda_calculus
23:19:37 <djahandarie> Oh great yeah
23:19:37 <Veinor> well... (2+) 3
23:19:40 <djahandarie> That'll help tolkad 
23:19:44 <BluShift1> Hahahahahaha
23:20:07 <BluShift1> djahandarie: tolkad: So, am I secretly learning Lambda calc?
23:20:16 <BluShift1> Veinor: Why the distinction?
23:20:17 <tolkad> BluShift1: no, haskell is only based on it
23:20:22 <tolkad> BluShift1: haskell is very different
23:20:52 <BluShift1> tolkad: So the concept of a function calling a function to handle two arguments in Haskell, not a Lambda calculus thing?
23:20:54 <dark> BluShift1, i think (2 +) is \x -> 2 + x, that is, the variable is in the second argument, o.o
23:20:54 <Axman6> haskell is based on a typed lambda calculus
23:21:00 <Veinor> BluShift1: because, say, (2/) 4 evaluates to 0.5, but (/2) 4 evaluates to 2
23:21:03 <dark> (+ 2) is \x -> x + 2
23:21:08 <tolkad> >(3 :: Int -> Int -> Int -> Int) 2 ((+) 2 3 5 ) (2 9228 9) :: Int
23:21:11 <tolkad> > (3 :: Int -> Int -> Int -> Int) 2 ((+) 2 3 5 ) (2 9228 9) :: Int
23:21:12 <lambdabot>   3
23:21:18 <tolkad> BluShift1: does that help?
23:21:20 <BluShift1> Oh god.
23:21:21 <BluShift1> No.
23:21:27 <Axman6> BluShift1: a function doesn't call another function to accept two arguments, it returns a new function
23:21:36 <BluShift1> Axman6: Right, sorry.
23:21:45 <dark> a + b means (a +) b
23:21:50 <dark> or (+ b) a
23:22:11 <BluShift1> A function does some stuff with a parameter, and returns a new function tht takes that second argument as its parameter.
23:22:16 <BluShift1> Right?
23:22:17 <dark> it does not matter because + is commutative.. but / isn't
23:22:25 <tolkad> BluShift1: yes
23:22:25 <dark> yes
23:23:03 <BluShift1> So it's generating a little (lol) function that's different every time, depending on the first argument?
23:23:09 <tolkad> BluShift1: « f x y = (x + y) » means « f = (\x -> (\y -> (x + y)))
23:23:22 <tolkad> BluShift1: yup
23:23:23 <Veinor> BluShift1: yeah.
23:23:23 <BluShift1> I don't get what \x -> means.
23:23:33 <Axman6> > (\x -> show x) 4
23:23:34 <lambdabot>   "4"
23:23:39 <djahandarie> BluShift1, that's a way to write a function without a name
23:23:40 <dark> Blub\0, \x -> y is the function that receives x, and returns y
23:23:47 <tolkad> BluShift1: it's a syntax for writing an inline function
23:23:50 <Axman6> > (\x y -> show (x + y)) 4 5
23:23:50 <lambdabot>   "9"
23:23:55 <BluShift1> tolkad: Oh goodness.
23:23:55 <tolkad> > (\x -> x) 0
23:23:56 <lambdabot>   0
23:23:56 <Veinor> > (\x -> x + 3) 8
23:23:57 <lambdabot>   11
23:23:58 <BluShift1> What's "show"?
23:24:05 <Axman6> :T show
23:24:07 <BluShift1> Does this have anything to do with IO?
23:24:09 <Axman6> :t show
23:24:09 <lambdabot> forall a. (Show a) => a -> String
23:24:13 <Axman6> BluShift1: nope
23:24:19 <djahandarie> It's just to turn things into Strings
23:24:22 <tolkad> BluShift1: nothing to do with IO, completely different
23:24:24 <BluShift1> Oh.
23:24:40 <Axman6> well, it gives the string represxentation of an object
23:24:43 <Axman6> -x
23:24:46 <BluShift1> The reason lambdabot shows it is because GHCi runs in the IO whatever, right?
23:25:05 <Axman6> BluShift1: best not to ask just yet ;)
23:25:07 <BluShift1> Would it be the IO monad? Or am I using that wrong?
23:25:12 <BluShift1> Axman6: Hah, alright
23:25:26 <tolkad> BluShift1: you should try to understand constructors next
23:25:26 <Axman6> BluShift1: are you following any tutorials?
23:25:46 <BluShift1> tolkad: Ok.
23:25:50 <BluShift1> Axman6: Loosly.
23:25:57 <BluShift1> Loosely*
23:25:58 <Axman6> which one?
23:26:02 <BluShift1> Axman6: LYAH.
23:26:14 <Axman6> well, you should follow it more strictly ;)
23:26:26 <BluShift1> Axman6: Ok sir :P
23:26:27 <djahandarie> LYAH is very good
23:26:38 <djahandarie> It teaches things in just the right order
23:26:40 <Axman6> you should definitely pay attention to it
23:26:45 <tolkad> BluShift1: maybe forget what I said and just follow LYAH
23:26:58 <BluShift1> tolkad: Hahahaha, I'll try :P
23:29:26 <BluShift1> How important is whitespace in list comprehensions?
23:29:45 <BluShift1> I get an error with this: boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] 
23:30:44 <BluShift1> I need to use "let" if it's in GHCi, right?
23:30:45 <Axman6> looks ok to me
23:30:49 <Axman6> yeah
23:30:55 <BluShift1> Ahh, that works.
23:33:16 <BluShift1> How can I exit GHCi?
23:33:24 <Axman6> :quit
23:33:26 <Axman6> or :q
23:33:29 * ziman uses ^D
23:33:34 <BluShift1> Ok.
23:51:06 <BluShift1> Why do things have to be bound in a list conprehension? Why doesn't [list name | predicates] work?
23:51:44 <Axman6> why would it? in [x, y, x is that's returned
23:51:45 <maurer_> BluShift1: What do you want that to do?
23:51:47 <Axman6> urgh
23:51:47 <ziman> > (> 3) `filter` [1..10]
23:51:48 <lambdabot>   [4,5,6,7,8,9,10]
23:51:51 <Axman6> [ x | y]
23:52:45 <BluShift1> Well, in this tutorial it shows [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]
23:53:17 <Axman6> and what do you want?
23:53:18 <BluShift1> But couldn't that just as easily (easier, actually) just be written as [adjectives ++ " " ++ nouns]?
23:53:58 <djahandarie> :t (++)
23:53:59 <lambdabot> forall m. (Monoid m) => m -> m -> m
23:54:07 <djahandarie> lol god damn it lambdabot
23:54:08 <Axman6> BluShift1: but that doesn't make any sense
23:54:15 <djahandarie> :t Prelude.(++)
23:54:15 <BluShift1> Axman6: Why not?
23:54:15 <lambdabot> Not in scope: data constructor `Prelude'
23:54:19 <Axman6> djahandarie: you mean, goddamnit Cale
23:54:37 <Axman6> keep saying it, he doesn't listen to me when i complain abut it
23:54:55 <Axman6> BluShift1: because [x] is a list with one element in it, x
23:55:16 <BluShift1> Axman6: What?
23:55:41 <Axman6> ?
23:56:18 <djahandarie> BluShift1, (++) would need to be defined really weird for that to make sense
23:56:30 <BluShift1> Axman6: I don't understand what that means. Could you give an example?
23:56:31 <paolino> > [(x,y) | x <- [1..4], y <- [1..3]]
23:56:31 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3)]
23:56:38 <Axman6> > [1]
23:56:38 <lambdabot>   [1]
23:56:42 <djahandarie> BluShift1, "hello" ++ "world" is easy to understand
23:57:03 <ziman> well, you can still do
23:57:05 <ziman> > let {adjs = ["foo","bar"]; nouns = ["baz","quux"]; (+++) = liftM2 (++); } in adjs +++ nouns
23:57:06 <lambdabot>   ["foobaz","fooquux","barbaz","barquux"]
23:57:08 <djahandarie> BluShift1, ["hello", "hallo"] ++ ["world", "wurld"] does something very different
23:57:19 <Axman6> > [["eat","drink"] ++ " " ++ ["food","sticks"]]
23:57:20 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
23:57:20 <lambdabot>         against inferred type...
23:57:22 <ziman> but i would not include it in a beginner text
23:57:33 <djahandarie> ziman, yes there are like 3000 things you can do :P
23:57:43 <ziman> djahandarie, :)
23:57:59 <ski> > let adjectives = ["lazy","hungry"]; nouns = ["cat","magpie"]  in [adjective ++ " " ++ noun | adjective <- adjectives,noun <- nouns]
23:58:00 <BluShift1> djahandarie: What does it do?
23:58:00 <lambdabot>   ["lazy\160cat","lazy\160magpie","hungry\160cat","hungry\160magpie"]
23:58:07 <ski> > let adjectives = ["lazy","hungry"]; nouns = ["cat","magpie"]  in [adjective ++ " " ++ noun | adjective <- adjectives,noun <- nouns]
23:58:08 <lambdabot>   ["lazy cat","lazy magpie","hungry cat","hungry magpie"]
23:58:25 <BluShift1> >["hello", "hallo"] ++ ["world", "wurld"]
23:58:29 <ski> > let adjectives = ["lazy","hungry"]; nouns = ["cat","magpie"]  in [adjectives ++ " " ++ nouns]
23:58:30 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
23:58:30 <lambdabot>         against inferred type...
23:58:32 <djahandarie> You need a space after > 
23:58:33 <BluShift1> > ["hello", "hallo"] ++ ["world", "wurld"]
23:58:34 <lambdabot>   ["hello","hallo","world","wurld"]
23:58:34 <ski> > let adjectives = ["lazy","hungry"]; nouns = ["cat","magpie"]  in [adjectives ++ [" "] ++ nouns]
23:58:35 <lambdabot>   [["lazy","hungry"," ","cat","magpie"]]
23:59:01 <ski> BluShift1 : do you see the difference ?
23:59:04 <djahandarie> BluShift1, so for you example command to work, (++) would need to have multiple behavior, and that'd be weird
23:59:11 <BluShift1> I see.
23:59:28 <ski> > let adjectives = ["lazy","hungry"]; nouns = ["cat","magpie"]  in liftM2 (++) adjectives nouns
23:59:29 <lambdabot>   ["lazycat","lazymagpie","hungrycat","hungrymagpie"]
23:59:34 <djahandarie> So the weird stuff is handed off to the "adj <- adjs" on the right side of the |
23:59:40 <djahandarie> And the left side of | is kept normal
23:59:48 <ski> > let adjectives = ["lazy","hungry"]; nouns = ["cat","magpie"]  in liftM2 (\adjective noun -> adjective ++ noun) adjectives nouns
23:59:49 <lambdabot>   ["lazycat","lazymagpie","hungrycat","hungrymagpie"]
23:59:53 <ski> > let adjectives = ["lazy","hungry"]; nouns = ["cat","magpie"]  in liftM2 (\adjective noun -> adjective ++ " " ++ noun) adjectives nouns
23:59:53 <lambdabot>   ["lazy cat","lazy magpie","hungry cat","hungry magpie"]
