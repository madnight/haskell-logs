00:00:27 <kmc> ivanm, probably
00:00:27 <sinelaw> yeah, i was hung up on my job
00:00:45 <Jafet> @check \x -> (id id) x == id x
00:00:45 <sinelaw> now i'm on a strike :)
00:00:45 <lambdabot>   "OK, passed 500 tests."
00:01:03 <kmc> sinelaw, in STLC there is no polymorphism, so (x x) is not well-typed for any x
00:01:34 <sinelaw> kmc, ah I see now.
00:01:49 <kmc> however there's no problem in evaluating  (λ(x : A → A). x) (λ(x:A). x)
00:02:06 <sinelaw> yeah
00:02:07 <kmc> those are two different functions with different types, but both would be called 'id' in Haskell
00:02:07 <sinelaw> ok
00:04:05 <sinelaw> yeah, we need at least let id =  (Π t. λ (x : t) . x) and then 'id id'
00:04:29 <sinelaw> to have the same function
00:04:31 <sinelaw> call itself
00:05:14 <sinelaw> well, it won't be 'id id' in this case.
00:05:32 <sinelaw> it will be 'id (a -> a) id'
00:05:41 <kmc> (id [A→A]) (id [A])
00:05:42 <kmc> yeah
00:05:59 <ddarius> Here's an exercise I like.  Eta reduction for products is: (fst p, snd p) -> p.  Subject reduction for a typed lambda calculus means if E : T and E -> E' then E' : T.  Show that subject reduction fails in a Curry-style lambda calculus with eta reduction but not in a Church-style lambda calculus.
00:06:04 <kmc> that works in something like System F
00:06:41 <kmc> is subject reduction the same thing as preservation then?
00:06:56 <sinelaw> you mean E ~> E'?
00:07:36 <ddarius> That's a more common symbol, but I was consistent in my usage.
00:07:59 <sinelaw> ddarius, i was reading the lambda cube paper and it had a note about that, but i couldn't see why it fails
00:14:38 <ddarius> kmc: I believe so.
00:17:53 <ivanm> @hoogle empty
00:17:54 <lambdabot> Control.Applicative empty :: Alternative f => f a
00:17:54 <lambdabot> Data.ByteString empty :: ByteString
00:17:54 <lambdabot> Data.IntMap empty :: IntMap a
00:18:04 <ivanm> is Control.Applicative.empty == mempty?
00:18:24 <ddarius> mzero
00:19:09 <ddarius> It may equal mempty for some cases, e.g. lists.
00:19:50 <ivanm> is there any data type for which empty /= mempty ?
00:19:51 <freiksenet> is there any Haskell to JavaScript compilers except YhcJs thingie?
00:20:00 <ivanm> freiksenet: AFAIK no
00:20:11 <ivanm> there are a few javascript combinator libraries to generate javascript code though
00:20:30 <ivanm> most people care more about generating fast native code than trying to compile haskell to another language
00:20:34 <ddarius> There are plenty for which mempty is defined and empty is not.
00:20:34 <freiksenet> ivanm: are they on hackage?
00:20:41 <ivanm> freiksenet: yup
00:20:52 <ivanm> ddarius: yeah, and WrappedMonad and WrappedArrow don't have a Monoid instance
00:21:20 <ivanm> but assuming mempty was split out of Monoid, would there be any types for which it wouldn't make sense for empty == mempty ?
00:21:27 <glguy> Monoid is for things with kind * (mempty), MonadPlus is for things with kind * -> * (mzero)
00:21:40 <freiksenet> ivam: ok, found 4 or 5. thanks.
00:21:45 <ivanm> glguy: I know
00:22:09 <ivanm> but I'm asking because I thought that pure was equivalent to singleton/unit, but it isn't so for ZippedList
00:22:38 <ddarius> ivanm: If something is in Alternative, you can always make a Monoid out of it.
00:22:50 <ivanm> *nod*
00:23:04 <ivanm> so Alternative can kinda be considered the kind * -> * equiv of Monoid?
00:23:10 <ddarius> ivanm: No.
00:26:23 <ivanm> OK, another question: in Control.Applicative, there's (<**>) = liftA2 (flip ($))
00:26:54 <ivanm> how is that different from just "flip (<*>)" ?
00:27:03 <kmc> order of "effects"
00:27:20 <ivanm> ahhhhhh
00:27:38 <ivanm> since you still want the first applicative functor to have its effects done first?
00:28:15 * ivanm heads off
00:28:17 <ivanm> bye all
00:29:09 <ddarius> sinelaw has been infected as well.
00:29:25 <sinelaw> no
00:29:40 <sinelaw> sine and cosine existed long before all this CoMama business
00:32:35 <ddarius> Sine Law: u^(v-u) = u^v = v^(v-u)
00:34:05 <Peaker> glguy, If we had higher-ranked class contexts, we could have: class (forall a. Monoid (m a), Monad m) => MonadPlus m where <nothing>
00:34:16 <Peaker> glguy, and then we wouldn't need to duplicate the operations for the higher kind
00:34:53 <kmc> there's also http://monoidal.blogspot.com/2010/07/kind-polymorphism-in-action.html
00:36:06 <sinelaw> Peaker, that signature is not legal in haskell?
00:36:10 <sinelaw> (and why)
00:36:33 <Peaker> sinelaw, It doesn't support quantifications inside class contexts
00:37:01 <Peaker> sinelaw, compiler difficulties, I am guessing. Maybe there are inherent theoretical difficulties
00:37:56 <ddarius> instance Monad m => Monoid (m ()) where mempty = return (); mappend = (>>); instance Monad m => Monoid (m a) where mempty = return undefined; mappend = (>>); instance (Monad m, Monoid a) => Monoid (m a) where mempty = return mempty; mappend = liftM2 mappend; instance MonadPlus m => Monoid (m a) where mempty = mzero; mappend = mplus
00:38:34 <sinelaw> return undefined?
00:52:40 <dolio> Bah, I can never remember the answer do ddarius' quiz.
00:54:00 <ddarius> dolio: I remember the thrust of it, but it takes me a bit to reconstruct an actual term.
00:55:00 <dolio> Oh, it involves two cases of eta reduction, doesn't it?
00:55:59 <ddarius> dolio: I don't think so.
00:58:09 <ddarius> Here's a CT exercise that I like from TTT.  Actually, I'm presenting a more difficult exercise.  The name of the exercise is "Coequalizers can be big."  There are exactly two functors from 1 -> 2 in Cat, where 1 is the terminal category (1 object, 1 arrow, the identity) and 2 is the category with 2 objects and 1 non-identity arrow joining them.  Describe the coequalizer of these two functors (i.e. the coequalizer in Ca
00:58:09 <ddarius> t.)
01:01:35 <ddarius> Time to crash my virtual machine.
01:10:16 <dolio> ddarius: The natural numbers?
01:10:25 <dolio> As a monoid.
01:12:48 <dolio> The functor being F 0 = N, F 1 = N, F id_0 = 0, F id_1 = 0, F ! = 1
01:13:09 <Zeiris_> >[5..1]
01:13:16 <Zeiris_> > [5..1]
01:13:17 <lambdabot>   []
01:13:23 <Zeiris_> Is there a way to make that work?
01:13:29 <dolio> > [5,4..1]
01:13:30 <lambdabot>   [5,4,3,2,1]
01:23:26 <jamy> >[5,4x1]
01:23:41 <sipa> > [5,4*1]
01:23:42 <lambdabot>   [5,4]
01:23:46 <jamy> > [5,4x1]
01:23:47 <lambdabot>   Not in scope: `x1'
01:24:13 <jamy> > [5,4..1]
01:24:14 <lambdabot>   [5,4,3,2,1]
01:24:30 <jamy> > [5000,4999..1]
01:24:31 <lambdabot>   [5000,4999,4998,4997,4996,4995,4994,4993,4992,4991,4990,4989,4988,4987,4986...
01:27:47 <kmc> > [4,3..]
01:27:48 <lambdabot>   [4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-...
01:28:33 * osfameron looks at http://www.vim.org/scripts/script.php?script_id=3200
01:28:38 <sipa> > [9,7,4..]
01:28:39 <lambdabot>   <no location info>: parse error on input `..'
01:28:52 <osfameron> I like that it's possible... but I never saw the point of formatting code differently from what the interpreter actually accepts anyway...
01:29:29 <kmc> or you can write code which really contains Unicode characters
01:30:02 <kmc> vanilla Haskell 98 allows it for identifiers, and GHC's -XUnicodeSyntax allows it for certain keywords, e.g. ∀ for 'forall'
01:30:10 <osfameron> well, I think it's for things like hiding the "<-" punctuation
01:30:44 <kmc> btw i like the 3-level rating system used by the vim scripts site
01:30:51 <kmc> osfameron, does it replace it with ← ?
01:30:58 <osfameron> I think so
01:31:04 <kmc> GHC allows that
01:31:10 <osfameron> or rather, it would *display* that arrow
01:31:36 <kmc> the main bit of Unicodey goodness that people want which GHC *doesn't* support is λ for \
01:31:48 <kmc> because λ is a lower-case letter, and therefore the start of an identifier
01:32:21 <ddarius> dolio: Yes.  Now all you have to do is prove that it is the coequalizer.  In TTT the problem was somewhat simplified because you were told that the answer was N.
01:32:41 <ddarius> dolio: But as a quick side exercise, what would the pushout be then?
01:34:04 <dolio> kmc: That's not really a reason. \ would be an operator if it weren't stolen for lambda expressions.
01:34:21 <dolio> But GHC doesn't reserve λ in the same way.
01:34:33 <kmc> true
01:34:56 <kmc> stealing punctuation is considered more acceptable than stealing alphanumerics
01:35:11 <kmc> if we required whitespace
01:35:15 <kmc> λ x y → …
01:35:26 <kmc> then you could effectively make λ a keyword
01:35:47 <kmc> which is still kind of rude to the Greeks
01:36:01 <kmc> but not as bad as reserving every word which starts with λ
01:36:19 <ddarius> exp (λ * v)
01:37:14 <jamy> > exp (λ * v)
01:37:15 <lambdabot>   Not in scope: `λ'
01:37:35 <kmc> > let λ = 3; v = 7 in exp (λ * v)
01:37:36 <lambdabot>   1.3188157344832146e9
01:38:01 <jamy> o!
01:38:50 <jamy> > 2^
01:38:51 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:38:58 <jamy> > 2^10
01:38:59 <lambdabot>   1024
01:39:10 <jamy> > 2^100
01:39:10 <lambdabot>   1267650600228229401496703205376
01:39:12 <kmc> > let lеt = "let":lеt in lеt
01:39:13 <lambdabot>   ["let","let","let","let","let","let","let","let","let","let","let","let","l...
01:39:24 <geheimdienst> > ☃ x y → ...
01:39:25 <lambdabot>   <no location info>: parse error on input `☃'
01:39:44 <kmc> snowman?
01:39:49 <sipa> > (2^)
01:39:50 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
01:39:50 <lambdabot>    arising from a use of `...
01:39:50 <jamy> i like it!
01:39:57 <sipa> :t (2^)
01:39:58 <lambdabot> forall t b. (Num t, Integral b) => b -> t
01:40:09 <sipa> > (2^) 5
01:40:10 <lambdabot>   32
01:40:32 <sipa> > let twopow = (2^) in twopow 10
01:40:32 <lambdabot>   1024
01:42:57 <jamy> how about personal types?
01:43:53 <kmc> ?
01:43:55 <Jafet> @let (☃) = id
01:43:55 <dolio> ddarius: 3?
01:43:58 <lambdabot>  Defined.
01:44:37 <Botje> that looks like a monkey
01:44:56 <geheimdienst> > "☔"
01:44:57 <lambdabot>   "\9748"
01:45:41 <Maxdamantus> > "ጷ"
01:45:41 <lambdabot>   "\4919"
01:46:13 <geheimdienst> Botje: possibly the unicode consortium intentionally used a snow-lifeform instead of a snowman. it does seem more future-proof
01:46:31 <ddarius> dolio: Yep.
01:47:43 <jamy> how about personal types again?
01:48:07 <kmc> jamy, i don't know what you mean?
01:48:15 <geheimdienst> Maxdamantus: 0x1337 "ehiopic syllable phwa"?
01:48:51 <jamy> type of data
01:48:53 * geheimdienst is amazed pidgin found a way to render that
01:49:33 <Maxdamantus> > "˟"
01:49:34 <lambdabot>   "\735"
01:49:38 <Maxdamantus> O_o
01:49:41 <Maxdamantus> What base is this?
01:49:48 <ddarius> > 0x9219
01:49:49 <lambdabot>   37401
01:49:51 <geheimdienst> decimal, i think
01:49:54 <Maxdamantus> Oh.
01:50:03 <jamy> kmc: type of data
01:50:06 <Maxdamantus> Ah yeah, there's a 9 in there.
01:50:12 <geheimdienst> > "\11000"
01:50:13 <lambdabot>   "\11000"
01:50:22 <geheimdienst> > "\110000"
01:50:23 <lambdabot>   "\110000"
01:50:35 <geheimdienst> why doesn't that go boom ...?
01:50:40 <geheimdienst> > maxBound :: Char
01:50:41 <lambdabot>   '\1114111'
01:51:01 <FauxFaux> Isn't it "\1111" + "000"?
01:51:06 <geheimdienst> > "\1114112"
01:51:07 <lambdabot>   <no location info>:
01:51:07 <lambdabot>      lexical error in string/character literal at chara...
01:52:22 <jamy> dec hex oct bool?
01:54:02 <dolio> ddarius: Anyhow, as for the coequalizer, given an appropriate G : 2 -> C, G0 = G1 = X, G! = f, define H : Nat -> C as HN = X and Hn = f^n.
01:54:20 <Maxdamantus> > "Թ"
01:54:21 <lambdabot>   "\1337"
01:54:36 <Maxdamantus> > "㐙"
01:54:37 <lambdabot>   "\13337"
01:55:04 <dolio> H is unique because it's fully determined by the definition of a functor and its value at 1, which is in turn determined by it being a factor of G.
01:56:21 <Maxdamantus> > "񌟹"
01:56:22 <lambdabot>   <no location info>:
01:56:22 <lambdabot>      lexical error in string/character literal at chara...
01:56:46 <jamy> how about links on variables?
01:56:57 <sipa> links on variables?
01:58:04 <jamy> sipa: yes
01:58:48 <jamy> &$a
02:01:00 <jamy> sipa: sorry! in haskell language
02:04:09 <ddarius> > 0x30050
02:04:09 <lambdabot>   196688
02:06:06 <Maxdamantus> > 017530552430455602346266247343465252525252531
02:06:07 <lambdabot>   17530552430455602346266247343465252525252531
02:07:57 <geheimdienst> thankfully, haskell does away with the "015 is an octal number" nonsense that c-ish languages confuse us with
02:08:42 <dolio> > 015
02:08:43 <lambdabot>   15
02:11:06 <sipa> jamy: you mean something like pointers/references?
02:12:10 <jamy> sipa: yes
02:12:38 <Maxdamantus> What's confusing about it? O_o
02:12:58 <Maxdamantus> If a number starts with a 0 and doesn't have a dot, it's not decimal.
02:13:35 <sipa> jamy: since haskell is a pure language (which means expressions have no side effects, except for their return value), it is also impossible/not meaningful to 'overwrite' variables; variables are more shorthands for a calculation than a real storage area for temporary solutions
02:14:11 <sipa> that also implies that it is not meaningful to create a reference to it... they only thing you can do with it is request its value, so if you will need it somewhere, just pass the variable itself
02:15:17 <sipa> of course, there is a way to create real variables and references if you need to interface with C libraries eg.; but you don't need to worry about that for now
02:15:59 <geheimdienst> i think it's just too damn easy to overlook. 384, 204, 036, 940 ... it screws up glancing over code, you really have to *read* it
02:18:10 <jamy> ok. How about arrays?
02:18:11 <frerich3> geheimdienst: Not really, if you're used to write code in C.
02:26:30 <sipa> jamy: typically, you wil use lists
02:27:43 <sipa> > let fib = 1:1:zipWith (+) (tail fib) (tail $ tail fib) in fib
02:27:47 <lambdabot>   mueval-core: Time limit exceeded
02:27:49 <jamy> i can make lists of lists?
02:27:53 <sipa> sure
02:27:57 <sipa> > let fib = 1:1:zipWith (+) (tail fib) (tail $ tail fib) in take 10 fib
02:28:01 <lambdabot>   mueval-core: Time limit exceeded
02:28:14 <ddarius> > 0x3004c
02:28:15 <lambdabot>   196684
02:29:00 <sipa> > [[1,2,3],[4,5,6],[7,8,9]]
02:29:01 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
02:29:07 <sipa> that's a list of lists
02:31:19 <Peaker> > [[[]]]
02:31:19 <lambdabot>   [[[]]]
02:31:21 <Peaker> That
02:31:26 <Peaker> 's a list of lists of lists
02:31:32 <jamy> how get some value of array?
02:31:45 <ddarius> > [] -- is also a list of list of lists.
02:31:46 <lambdabot>   []
02:32:06 <Maxdamantus> > fix $ (1:) . (1:) . ap (zipWith (+)) tail
02:32:07 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
02:33:53 <Peaker> @pl fibs = 1 : 1 : zipWith fibs (tail fibs)
02:33:53 <lambdabot> fibs = fix ((1 :) . (1 :) . ap zipWith tail)
02:33:56 <jamy> only one. i dnt understand what print Maxdamantus
02:34:08 <Peaker> whoops
02:34:11 <nlogax> > [1,2,3] !! 1 -- like this, jamy?
02:34:12 <lambdabot>   2
02:34:17 <Peaker> I remembered it used scanl, or such
02:34:20 <dolio> > fix $ (0:) . scanl (+) 1
02:34:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
02:34:33 <Maxdamantus> @pl a = a
02:34:34 <lambdabot> a = fix id
02:35:03 <Maxdamantus> @pl a = (,) 1 a
02:35:04 <lambdabot> a = fix ((,) 1)
02:35:36 <jamy> nlogax: where identifier of array?
02:35:42 * frerich3 hated it when people "explained" haskell by starting with one of the usual list showcases examples and then going 'tadaaa, here you ahve fibonacci/quicksort/whatever'
02:35:59 <Kaidelong> > fix . scanl (+) 1
02:36:00 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
02:36:15 <Kaidelong> :t scanl (+) 1
02:36:16 <lambdabot> forall a. (Num a) => [a] -> [a]
02:36:37 <Kaidelong> what just happened
02:36:51 <dolio> > fix $ scanl (+) 1
02:36:52 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
02:37:04 <Kaidelong> oh right
02:37:15 <Kaidelong> fix is (a -> a) -> a
02:37:17 <Maxdamantus> 262144,524288,1048576
02:37:47 <dolio> > scanl (*) 1 [1..]
02:37:48 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
02:38:07 <Peaker> > scanl (/) 1 [1..]
02:38:07 <lambdabot>   [1.0,1.0,0.5,0.16666666666666666,4.1666666666666664e-2,8.333333333333333e-3...
02:38:51 <Entroacceptor> I got a list which I want to output through HStringTemplate. But I want a template to get the whole list, not to automatically iterate over the entries
02:39:17 <jamy> what this: [1,2,3] ?
02:39:50 <dolio> It's a list.
02:40:00 <dolio> Containing the numbers 1, 2 and 3.
02:40:19 <Maxdamantus> > read "[1,2,3]" :: [Integer]
02:40:20 <lambdabot>   [1,2,3]
02:41:34 <jamy> why when > [1,2,3] then lambdabot says "2" ?
02:41:35 <stroan> jamy: there are some very good learning resources if you're looking for them. http://book.realworldhaskell.org/read/ is a particularly good one that could help you get up to speed
02:41:39 <Maxdamantus> > read "[(1:2:[],[]),([3,4,5],[6])]" :: [([Integer],[Integer])]
02:41:40 <lambdabot>   *Exception: Prelude.read: no parse
02:41:54 <Maxdamantus> > read "[([1,2],[]),([3,4,5],[6])]" :: [([Integer],[Integer])]
02:41:55 <lambdabot>   [([1,2],[]),([3,4,5],[6])]
02:42:01 <Maxdamantus> Interesting.
02:42:16 <sipa> 11:33:47 < nlogax> > [1,2,3] !! 1 -- like this, jamy?
02:42:26 <sipa> that's taking element numer 1 from that list
02:42:30 <sipa> !! is list indexing
02:42:40 <nlogax> @type (!!)
02:42:41 <lambdabot> forall a. [a] -> Int -> a
02:43:35 <gour1> anyone familiar with both can compare haskell & D?
02:43:56 <Maxdamantus> Isn't D completely different to Haskell?
02:44:11 <jamy> sipa: why 1? where its says?
02:44:23 <Peaker> I wonder if it could be nice to have:  class Apply f where ($) :: f a b -> a -> b     could be nice rather than the monomorphic ($). That way, we could have a function as a semantic model more easily
02:44:25 <sipa> [1,2,3]!!1
02:44:27 <dolio> D is like a nicer C++, at least in some ways.
02:44:30 <sipa> after the !!
02:44:56 <sipa> and -- starts the comment
02:45:04 <Maxdamantus> Ah. Apparently it has specifically pure functions and stuff.
02:45:17 <jamy> ooo! i been thinking what its commentaries :)
02:45:42 <jamy> *i mean !!
02:46:20 <jamy> ok! what names of "!!" ?
02:46:28 <sipa> names?
02:46:45 <jamy> what is her name?
02:46:50 <sipa> ?
02:46:59 <sipa> :t (!!)
02:46:59 <lambdabot> forall a. [a] -> Int -> a
02:47:08 <nlogax> jamy: the source calls it " List index (subscript) operator"
02:47:48 <jamy> nlogax: thanks
02:48:20 <nlogax> @src (!!)
02:48:20 <lambdabot> xs     !! n | n < 0 = undefined
02:48:20 <lambdabot> []     !! _         = undefined
02:48:21 <lambdabot> (x:_)  !! 0         = x
02:48:21 <lambdabot> (_:xs) !! n         = xs !! (n-1)
02:48:44 <jamy> @let proba = ["a","b","c"]
02:48:45 <lambdabot>  Defined.
02:48:54 <sipa> > proba!!0
02:48:55 <lambdabot>   "a"
02:49:08 <jamy> > proba!!1
02:49:09 <lambdabot>   "b"
02:49:22 <jamy> i see...
02:50:04 <gour> Maxdamantus: apparently, it supports FP in D2
02:50:10 <nlogax> > map (proba !!) [0..2]
02:50:11 <lambdabot>   ["a","b","c"]
02:50:48 <Kaidelong> been working through an introductory book on category theory and it took me about an hour to work through 13 pages
02:51:12 <Kaidelong> wondering if someone can recommend a good textbook
02:51:13 * Maxdamantus 's new language supports FP \o/
02:51:38 <Kaidelong> this one uses almost entirely examples and has you work them out, which I've managed so far
02:51:57 <stroan> what's the name of the book?
02:53:18 <Kaidelong> Basic Category Theory for Computer Scientists
02:53:19 <jamy> ok! how i can make list from "x" to "y" without taping its from my hands 
02:53:32 <Kaidelong> by a "Benjamin C. Pierce"
02:54:11 <jamy> * auto generate list from X to Y
02:54:36 <Maxdamantus> From X to Y?
02:54:57 <stroan> Ah, cool. I've been working through his Coq lectures over the last while
02:55:03 <jamy> sorry. I remember [1,2..10]
02:55:06 <stroan> also based almost entirely on working examples
02:56:25 <sipa> jamy: 
02:56:28 <sipa> > [1..10]
02:56:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
02:57:19 <jamy> > [1.1..2]
02:57:19 <lambdabot>   [1.1,2.1]
02:57:29 <jamy> > [1.1..2.0]
02:57:30 <lambdabot>   [1.1,2.1]
02:57:37 <jamy> hmm
02:59:16 <norm2782> > [1.1,1.2..2.0]
02:59:17 <lambdabot>   [1.1,1.2,1.2999999999999998,1.3999999999999997,1.4999999999999996,1.5999999...
03:00:20 <jamy> hmm. What is 9999...? Why?
03:00:36 <norm2782> it's slightly better like this:
03:00:41 <norm2782> > [1.1,1.2..2.0] :: [Float]
03:00:42 <lambdabot>   [1.1,1.2,1.3000001,1.4000001,1.5000001,1.6000001,1.7000002,1.8000002,1.9000...
03:00:46 <Maxdamantus> > [1,0..]
03:00:47 <lambdabot>   [1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20...
03:00:48 <norm2782> but still a mess
03:00:53 <Maxdamantus> > [1,0..4]
03:00:54 <lambdabot>   []
03:03:25 <jamy> > [1.1,1.2..2.0]
03:03:26 <lambdabot>   [1.1,1.2,1.2999999999999998,1.3999999999999997,1.4999999999999996,1.5999999...
03:03:37 <jamy> > [1.1,1.2..2.0]::[int]
03:03:38 <lambdabot>   Could not deduce (GHC.Real.Fractional int) from the context ()
03:03:38 <lambdabot>    arising f...
03:03:47 <jamy> > [1.1,1.2..2.0]::[integer]
03:03:48 <lambdabot>   Could not deduce (GHC.Real.Fractional integer) from the context ()
03:03:48 <lambdabot>    arisi...
03:04:07 <jamy> > [1.1,1.2..2.0]::[INT]
03:04:07 <lambdabot>   Not in scope: type constructor or class `INT'
03:04:45 <jamy> of course! i am stupid!
03:04:56 <sipa> jamy: "1" can be of type Int or Integer or Float or everything that implements Num
03:05:11 <sipa> 1.1 however can only be of a fractional type, which does not include Int or Integer
03:06:31 <Maxdamantus> map toInteger [1.1,1.2..2.0]
03:06:32 <Maxdamantus> > map toInteger [1.1,1.2..2.0]
03:06:33 <lambdabot>   Ambiguous type variable `a' in the constraints:
03:06:33 <lambdabot>    `GHC.Real.Fractional a'
03:06:33 <lambdabot> ...
03:06:44 <Maxdamantus> > map floor [1.1,1.2..2.0]
03:06:45 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
03:08:27 <jamy> how about exponential format? like 23*10^5
03:08:38 <Kaidelong> ^ only works on integrals
03:08:44 <Kaidelong> well, for the right side
03:08:50 <Kaidelong> otherwise, you should use **
03:08:55 <sipa> > 23*10^5
03:08:56 <lambdabot>   2300000
03:08:56 <Kaidelong> > map (\x->2/(1-((1/0)**x) - 1) [0.2, 0.22.. 0.28]
03:08:57 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:08:58 <ddarius> > ['\0'..'\32']
03:08:59 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
03:09:10 <Kaidelong> > map (\x->2/(1-((1/0)**x) - 1)) [0.2, 0.22.. 0.28]
03:09:11 <lambdabot>   [-0.0,-0.0,-0.0,-0.0,-0.0]
03:09:14 <ddarius> > ['\16'..'\32']
03:09:14 <lambdabot>   "\DLE\DC1\DC2\DC3\DC4\NAK\SYN\ETB\CAN\EM\SUB\ESC\FS\GS\RS\US "
03:09:58 <jamy> ddarius: thanks!
03:10:11 <Maxdamantus> infinity^x?
03:12:08 <jamy> how i can make personal type? for example for base = 7 (day of weeks e.t.c.)
03:12:28 <sipa> jamy: read about algebraic data types
03:12:46 <jamy> sipa: where?
03:14:44 <jamy> for example [mon..wed] -> lambdabot [monday,tuesday,wed...
03:16:53 <jamy> sipa: hello
03:17:10 <sipa> jamy: just start by reading some introduction about haskell
03:17:19 <sipa> i believe you've been given quite some pointers already
03:17:30 <sipa> but there are a lot of things really different from languages you know
03:18:16 <jamy> i know many...
03:19:23 <sipa> http://www.haskell.org/tutorial/goodies.html eg
03:19:48 * hackagebot plot 0.1.2 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.2 (VivianMcPhail)
03:21:39 <ddarius> My compiler seems to work.
03:23:09 <jamy> sipa: thats exactly what i request
03:23:50 * hackagebot authenticate 0.6.6 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.6.6 (MichaelSnoyman)
03:24:22 * jamy think what #haskell room of freenode better than google
03:25:20 <sipa> an irc channel is an easy way to get quick answers to specific and possibly hard questions
03:25:30 <sipa> but we can't teach you a whole language
03:26:31 <Kaidelong> probably the most useful thing I can say about learning haskell is that the biggest hurdle will be divorcing yourself from wanting to work with side effects
03:26:56 <Kaidelong> and keeping your functions short (and composing then later to bind over your IO)
03:27:50 <Kaidelong> avoiding the do syntax for a while somewhat helps
03:27:53 <jamy> 600 teachers cant teach one pupil? 
03:28:13 <Kaidelong> none of us will have that sort of time to spend on IRC unfortunately
03:29:31 <Kaidelong> also learnyouahaskell.com is kind of nice
03:29:36 <Kaidelong> go there
03:29:55 <Kaidelong> BONUS also shows up in here from time to time
03:32:44 <Peaker> jamy, what's the question again?
03:32:58 <Peaker> jamy, how to write an algebraic data type (ADT) for a week day?
03:33:15 <Peaker> data WeekDay = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday ?
03:34:44 <jamy> yes
03:34:55 <Peaker> jamy, Well, that's how :)
03:43:02 <aleator> How do I tell cabal to look for .h files inside the package?
03:49:16 <dcoutts> aleator: specify an includes dir
03:51:56 <Razz> I'm trying to install unix-compat but I keep getting the error: Missing header file 'hsUnixCompat.h', this file however is present when extracting the tar.gz (from hackage)...it's supposedly a foreign library, how can I fix this?
03:56:55 <aleator> dcoutts: I do, but for some reason it doesn't stop complaining. 
03:58:14 <aleator> dcoutts: Does it try to compile/check the file during configure? Might the error be because of something wrong in the file?
04:07:28 <aleator> dcoutts: It seems that invalid .h file causes cabal to complain that it is not found. This is a bug, yes?
04:13:21 <int-e> @type \a -> a . Right $ a . Left
04:13:22 <lambdabot> forall b a. (Either a (a -> b) -> b) -> b
04:16:33 <wjtk> Hello. Would somebody please help a newbie?
04:17:01 <sipa> depends, if you'd ask the question, people would know if they knew the answer :)
04:17:17 * hackagebot equivalence 0.2.1 - Maintaining an equivalence relation implemented as union-find using STT.  http://hackage.haskell.org/package/equivalence-0.2.1 (PatrickBahr)
04:17:24 <wjtk> Well, let me give it a try then.
04:17:51 <wjtk> concat "str1" "str2" "str3"
04:18:33 <wjtk> How do I write a function that will accept any (reasonable) number of strings and return concatenation
04:18:36 <wjtk> ?
04:19:11 <wjtk> I only found an example of polyvariadic function, where I have to explicitly specify type ::[String]
04:19:23 <sipa> what you're doing now
04:19:28 <sipa> is taking the function concat
04:19:37 <sipa> passing it the argument "str1"
04:19:49 <sipa> getting the result from this operation
04:19:54 <fryguybob> @type concat
04:19:55 <lambdabot> forall a. [[a]] -> [a]
04:20:11 <sipa> assuming the result is again a function
04:20:14 <sipa> passing that "str2"
04:20:17 <sipa> and so on
04:20:47 <blackdog> hey, anyone here used pandoc for slide/paper production? bos was raving about it on twitter, and I can't quite see the attraction - it's just a converter, right?
04:20:48 <sipa> what you need, i think, is simply passing concat a list of strings, instead of separate strings
04:20:54 <arw> that would be currying. problem is, that would always return a function, never a string if the number of arguments wasn't fixed
04:21:05 <sipa> indeed
04:21:52 <arw> > concat ["foo", "bar", "baz"]
04:21:53 <lambdabot>   "foobarbaz"
04:21:57 <wjtk> Yeah, I know I could just write a function for a list of strings, but I am a stubborn oldboy
04:22:01 <zygoloid> int-e: that's an interesting type :) is that from some real code?
04:22:43 <arw> wjtk: haskell doesn't really support a variable number of arguments.
04:22:55 <arw> wjtk: not if you don't want to use lists as arguments
04:23:10 <fryguybob> blackdog: I tried it after his talk and I think the attraction is that it is very simple to do.
04:24:17 <fryguybob> blackdog: I happened to be taking notes at the time in markdown and with one call to pandoc they became reasonable enough slides.
04:24:36 <blackdog> fryguybob: hm, that's interesting. so you convert them to what, latex?
04:24:53 <blackdog> is his talk online?
04:24:54 <wjtk> I found this:
04:24:57 <wjtk> class BuildList a r  | r -> a where
04:24:59 <wjtk>     build' :: [a] -> a -> r
04:25:03 <wjtk> instance BuildList a [a] where
04:25:03 * blackdog is desperately sad to have missed #icfp
04:25:05 <fryguybob> blackdog: Directly to "slidy".
04:25:05 <wjtk>     build' l x = reverse$ x:l
04:25:09 <wjtk> instance BuildList a r => BuildList a (a->r) where
04:25:11 <wjtk>     build' l x y = build'(x:l) y
04:25:15 <wjtk> build x = build' [] x
04:25:26 <wjtk> But it always requires :: [String] or something
04:25:42 <ddarius> blackdog: I hear they do it every year.
04:25:44 <blackdog> fryguybob: oh, that _is_ cool. i'll have to send that to one of my ruby hacker mates
04:25:58 <blackdog> ddarius: this is the first year i could have afforded it independently
04:26:07 <wjtk> I can't force it to work only on String
04:26:10 <fryguybob> blackdog: Yeah pandoc is quickly becoming a tool I cannot live without.
04:26:16 <ddarius> blackdog: Yeah, probably same for me too...
04:26:53 <ddarius> Actually, if next year is in Tokyo, I may go to it, but probably not.
04:27:59 <benmachine> wjtk: usually the type you want is inferred from context
04:28:10 <wjtk> Yes, this I know
04:28:18 <blackdog> was time more than anything this year. working on desperately crap tech for au govt agencies
04:28:40 <blackdog> but Tokyo would be fanbloodytastic
04:28:44 <arw> wjtk: you can write a function build_str :: [String] -> String -> r which just wraps build'
04:29:01 <arw> wjtk: that saves some typing at least
04:30:05 <benmachine> wjtk: so what's the problem?
04:30:28 <benmachine> wjtk: you can write an instance for [Char] instead of for [a] if you turn on FlexibleInstances
04:30:38 <wjtk> arw: hmm, build_str "lacks accompanying binding"
04:30:49 <benmachine> build_str = build'
04:31:31 <arw> wjtk: you need benmachines line, too. mine is just the declaration, you also need the (trivial) definition
04:31:32 <siracusa> wjtk: You might want to look at the printf code, this function takes an arbitrary number of arguments and produces a string of them.
04:32:52 <wjtk> Those lines together don't compile
04:33:03 <wjtk> Okay, will look at printf
04:33:23 * hackagebot HTF 0.5.0.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.5.0.0 (StefanWehr)
04:34:45 <benmachine> wjtk: what error?
04:35:03 <wjtk> TestBuild.hs:17:12:
04:35:05 <wjtk>     Could not deduce (BuildList String r) from the context ()
04:35:07 <wjtk>       arising from a use of `build'' at TestBuild.hs:17:12-17
04:35:09 <wjtk>     Possible fix:
04:35:11 <wjtk>       add (BuildList String r) to the context of
04:35:13 <wjtk>         the type signature for `build_str'
04:35:15 <wjtk>       or add an instance declaration for (BuildList String r)
04:35:17 <wjtk>     In the expression: build'
04:35:19 <wjtk>     In the definition of `build_str': build_str = build'
04:35:21 <wjtk> Failed, modules loaded: none.
04:35:35 <benmachine> add (BuildList String r) to the context then
04:35:50 <benmachine> also, the first line would have done :)
04:35:56 <benmachine> try not to paste too much into the channel at once
04:36:05 <wjtk> sorry!
04:36:26 <benmachine> build_str :: (BuildList String r) => [String] -> String -> r
04:36:28 <benmachine> or possibly
04:36:40 <benmachine> build_str :: (BuildList Char r) => String -> Char -> r
04:36:45 <benmachine> not clear exactly what you wanted
04:36:52 <Entroacceptor> why does hstringtemplate call the template for an empty array??
04:37:20 <wjtk> I want concat "str1" "str2" "str3" , et cetera, any number of strings
04:37:39 <sipa> the problem is
04:38:04 <sipa> that you write 'concat "str1"', it will return something
04:38:18 <sipa> you want this something to be both usable as a string, if you use it directly
04:38:35 <sipa> or a function, so you can pass "str2" to it afterwards, and then get a string
04:38:54 <sipa> though type inferency and some type-system extension may be able to do that
04:39:03 <sipa> it is definitely not the intended way
04:40:16 <wjtk> Well, I thought the problem was simple, and I were a procedural mutable old dummy. Apparently it is not very simple.
04:40:26 <wjtk> I think I should have a good look at printf
04:40:28 <benmachine> it's not that difficult really
04:40:37 <benmachine> printf manages it using precisely zero extensions iirc
04:40:52 <benmachine> not even MPTCs
04:40:52 <sipa> i don't see why you don't want to use a list of strings?
04:40:59 <benmachine> ^ this is a good point though
04:41:03 <sipa> the syntactic overhead?
04:41:52 <wjtk> no, no, I'm trying to make haskell do what I want, not the opposite.
04:41:57 <wjtk> It is not a real problem.
04:42:26 <wjtk> Intelectual excersise.
04:42:27 <int-e> zygoloid: no, that wasn't real code - it's  not (not (a \/ not a))  if you interpret  b  as False. I liked the symmetry of the Haskell expression though.
04:45:03 <benmachine> wjtk: haskell is not perl, there are a lot of things it won't let you do :P
04:45:55 <kdvh> trying to write a directory traversal app, any good libraries?
04:46:00 <wjtk> Well, we'll see about that
04:46:06 <wjtk> ;-)
04:46:09 <benmachine> heh
04:46:29 <sipa> indeed, although it provides much more abstraction and higher-order stuff, its typesystem is very strict
04:47:18 <benmachine> haskell will let you do most things that work, it doesn't tend to want to let you do things that don't
04:47:31 <sipa> for example, a function/operator always have exactly one definition (in scope), and it may be polymorphic, but it's not possible to have overloaded functions that support different combinations of types of arguments
04:47:33 <benmachine> things like C are less picky >_> <_<
04:47:59 <benmachine> sipa: hmm? that sounds like something you could do with MPTCs
04:48:10 * sipa googles
04:48:26 <benmachine> although the more polymorphic your function is, the less inferrable your types are
04:48:34 <sipa> multi parametric type classes?
04:48:43 <benmachine> yes
04:48:58 <sipa> yes, ok, that increases the power of the polymorphism supported
04:49:55 <sipa> but you still can't have, let's say, a function that combines Prelude.print and Prelude.hPrint
04:50:06 <benmachine> I think you could
04:50:12 <sipa> hmm, yes, you may be right
04:50:17 <benmachine> but it would be very unidiomatic :P
04:51:12 <sipa> class Printable a b where print :: a -> b; instance Printable String (IO ()) ...; instance Printable Handle (String -> IO ())
04:51:22 <benmachine> something like that
04:51:46 <sipa> it would make type-inference a horrible mess :)
04:51:53 <benmachine> if you actually used that in a file, people would glare at you forever
04:51:59 <benmachine> but in principle it's possible
04:52:20 <wjtk> Thank you all. I'll try the printf route.
04:53:08 <sipa> benmachine: you could as well write a function doIt, that depending on what combination of argument types, does something
04:53:37 <sipa> since almost all Prelude functions have different type signatures, why not combine them into a single function? ;)
04:55:20 <benmachine> heheh
04:55:22 <Jafet> > ((+) * (-)) 0 1
04:55:23 <lambdabot>   -1
04:55:36 <sipa> heh?
04:55:42 <sipa> :t (*)
04:55:43 <lambdabot> forall a. (Num a) => a -> a -> a
04:55:52 <benmachine> sipa: someone made a Num (a -> b) instance
04:55:55 <benmachine> it's pretty neat
04:55:59 <benmachine> I mean
04:56:02 <benmachine> it's also pretty silly
04:56:05 <benmachine> but pretty neat all the same
04:56:16 <benmachine> > sin^2 + cos^2 $ 4
04:56:17 <lambdabot>   1.0
04:56:21 <sipa> nice
04:56:31 <Jafet> Then there's the usual favourite...
04:56:37 <sipa> > signum (+)
04:56:38 <Jafet> :t (.)
04:56:38 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
04:56:38 <lambdabot>    arising from a use...
04:56:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:56:59 <benmachine> > signum (+) $ 2 3
04:57:00 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
04:57:00 <lambdabot>    arising from a use of `...
04:57:03 <benmachine> erm
04:57:06 <RayNbow`TU> > (*10) + id $ 3
04:57:07 <lambdabot>   33
04:57:15 * benmachine tries to work this out
04:57:29 <benmachine> :t signum (+)
04:57:30 <lambdabot> forall a. (Num a) => a -> a -> a
04:57:36 <benmachine> oh yeah
04:57:37 <benmachine> silly me
04:57:42 <benmachine> > signum (+) 2 3
04:57:43 <lambdabot>   1
04:57:47 <benmachine> > signum (+) 2 (-3)
04:57:48 <lambdabot>   -1
04:58:07 <benmachine> basically the principle is "apply to the result of" I think
04:58:36 <Jafet> :t signum
04:58:37 <lambdabot> forall a. (Num a) => a -> a
05:01:26 <Entroacceptor> is there anyone using hstringtemplate at all?
05:08:27 <ddarius> signum signum = signum
05:10:42 * ddarius is about to have a mixture of Joy, Forth, and Postscript.
05:14:40 * ddarius is foiled again.
05:15:02 <fryguybob> ddarius: It was sounding so interesting...
05:15:17 <kowey> anybody know the answer to http://www.haskell.org/pipermail/glasgow-haskell-users/2010-October/019303.html ? seems like a bit of make silliness
05:16:37 <ddarius> My problem is that I don't have dynamic memory management.
05:16:38 <Botje> the "" in front of the configure looks fishy
05:17:05 <Botje> % "" ls
05:17:05 <Botje> zsh: permission denied: 
05:17:22 <Botje> it even fails in bash!
05:17:41 <Botje> so i'd look at why that "" is there
05:17:46 <Botje> kowey: ^ ^ 
05:18:44 <kowey> sounds like a good start, thanks, Botje
05:20:05 <sinelaw> can't seem to find audio support in haskell's SDL package
05:20:05 * kowey signs up on the list to relay your hint
05:20:13 <sinelaw> does it mean it's not ported?
05:20:45 <sinelaw> ah they put it in sdl-mixer
05:20:47 <sinelaw> nvm
05:22:09 <sinelaw> sdl-mixer seems out of date though :(
05:27:56 <sinelaw> Lemmih, ?
05:28:58 <Entroacceptor> nobody is using hstringtemplate...
05:36:44 <Lemmih> sinelaw: Yes?
05:37:13 <sinelaw> Lemmih, was trying to decipher sdl-mixer, but i'm good now
05:37:28 <sinelaw> Lemmih, do you know of a simple way to access the actual audio samples?
05:40:44 <Lemmih> sinelaw: Figure out how to do it in C and then translate to Haskell.
05:41:04 <sinelaw> :)
05:42:33 <zachk> is control.monad.omega tail recursive?
05:42:42 <zachk> and why cant i send to haskell-in-depth#
05:49:41 <gwern> http://www.darthsanddroids.net/episodes/0475.html
05:49:43 <gwern> you will groan
05:50:11 <Entroacceptor> no, I didn't
05:50:13 <fryguybob> ddarius: I had to model memory with an IntMap when writing a Forth interpreter.  Fortunately the constraints were pretty lax so I didn't have to make it very robust.
05:52:51 <gwern> Entroacceptor: damn you! did you just make me a liar
05:53:47 <aleator> Huh? package vector-0.6.0.2-e7a544f61423c16435c9a47bae43e1dd is unusable due to missing or recursive dependencies: ghc-6.12.3-66a382195c8a71849653439b67021fd1
05:53:56 <aleator> How does this happen?
05:57:00 <Entroacceptor> I will groan retroactively if you help me with hstringtemplate :)
05:58:21 <aleator> Entroacceptor: Why not try Interpolate instead?
05:58:47 <aleator> It seems that I've killed most of my ghc framework..
05:59:03 <zachk> fryguybob, is intmap fast? why not a uvector? 
06:00:35 <Entroacceptor> aleator: what?
06:01:27 <aleator> Entroacceptor: http://hackage.haskell.org/package/Interpolation
06:01:42 <fryguybob> zachk: I wasn't concerned with speed and I wasn't actually using haskell, just something intmap like.
06:01:44 <aleator> It is what happened to me when I tried to work with hstringtemplate
06:02:04 <zachk> oh
06:02:56 <aleator> Entroacceptor: It's ugly, has rough corners (don't use infix operators) but for some things it is quite handy.
06:03:12 <Entroacceptor> aleator: it doesn't look anything remotely like I want :)
06:03:54 <Entroacceptor> at least from the small example on the wiki
06:03:55 <aleator> It is just simplified inline version of stringtemplates
06:04:08 <Entroacceptor> s/wiki/hackage docs/
06:04:13 <Entroacceptor> a) inline is wrong
06:04:35 <Entroacceptor> b) looks ugly
06:04:58 <zachk> does anyone have any experience with Control.Monad.Omega?
06:05:08 <aleator> Well, each to his own. I disagree about inline being wrong, but I can see why someone would think that
06:05:35 <Entroacceptor> it's not wrong for everything, but for my purpose it is
06:05:45 <Entroacceptor> c) I need recursion, I think
06:06:07 <Entroacceptor> and conditionals
06:06:16 <Entroacceptor> and that last thing is biting me with hst
06:06:21 <aleator> b I concede, but it can recurse and has all the conditionals in haskell
06:06:44 <siracusa> Entroacceptor: Do you have a specific question to HStringTemplate?
06:07:47 <Entroacceptor> afk
06:08:04 <aleator> Although, I think nowadays stringtemplate does have equivalent facilities as well.
06:09:14 <ski> aleator : "#<var> in <list>:" really is "#<pat> in <list>:", yes ?
06:09:42 <aleator> ski: Yeah. I wasn't that on top of terminology back then
06:11:01 <rothwell> i keep seeing the claim that the ST monad uses rank-2 types to prevent effects from leaking out... is there any documented explanation for this?
06:11:04 <rothwell> perhaps a paper somewhere
06:12:01 <jamy> :info (+)
06:12:01 <jamy> > :info (+)
06:12:01 <jamy> > pi
06:12:02 <lambdabot>   <no location info>: parse error on input `:'
06:12:02 <lambdabot>   3.141592653589793
06:12:06 <ski> @type runST
06:12:07 <lambdabot> forall a. (forall s. ST s a) -> a
06:12:48 <jamy> > type :info (+)
06:12:49 <lambdabot>   <no location info>: parse error on input `type'
06:12:57 <jamy> > type info (+)
06:12:57 <lambdabot>   <no location info>: parse error on input `type'
06:13:00 <rothwell> i'm aware of the type... just don't really understand what provides the guarantee
06:13:04 <jamy> > info (+)
06:13:05 <lambdabot>   Not in scope: `info'
06:13:23 <ski> @google Lazy Functional State Threads
06:13:23 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/lazy-functional-state-threads.ps.Z
06:13:31 <ski> rothwell : iirc, that ^ paper
06:13:33 <rothwell> oh right, thanks
06:15:19 <shapr> Gooood morning #haskell!!
06:16:18 <blackdog> shapr: and with that, i bid you a good night
06:17:23 <jamy> good evening!
06:18:13 <ski> the kind of thing it prevents is `runST (do let {ref = runST (do ref <- newSTRef "abc"; writeSTRef ref "def"; return ref)}; modifySTRef ref reverse; readSTRef ref)' ..
06:18:41 <ski> and also the converse situation of first allocating a reference cell, and then using that in an "internal" state thread
06:18:44 <sipa> > def
06:18:45 <lambdabot>   Not in scope: `def'
06:18:55 <sipa> ski: i think you would get that error :p
06:19:02 <jamy> > putStrLn "Here's a newline -->\n<-- See?"
06:19:03 <lambdabot>   <IO ()>
06:19:29 <ski> sipa : why ?
06:19:42 <sipa> ski: i think you made a type, def instead of ref
06:19:49 <sipa> ow wait
06:19:55 * sipa needs to get his eyes checked
06:20:14 * ski thought the only `def' occurs within double quotes, there
06:20:33 * sipa confirms this
06:20:44 <jamy> @let hello = "abcdef"
06:20:45 <lambdabot>  Defined.
06:20:56 <jamy> > a!!2
06:20:57 <lambdabot>   Couldn't match expected type `[a]'
06:20:58 <lambdabot>         against inferred type `SimpleRef...
06:21:06 <sipa> > a
06:21:07 <lambdabot>   a
06:21:08 <ski> rothwell : anyway .. the "trick" is related to when a definition can be made polymorphic, and when it can't
06:21:20 <ski> > reverse hello
06:21:21 <lambdabot>   "fedcba"
06:21:33 <jamy> > hello!!2
06:21:34 <lambdabot>   'c'
06:21:35 <rothwell> ski: i'll keep it in mind, thanks
06:21:38 <rothwell> currently eyeing the paper
06:21:54 <rothwell> seems familiar... may've started it before and not finished it
06:21:58 <rothwell> before i got to the important parts
06:22:00 <jamy> > hello!!4
06:22:01 <lambdabot>   'e'
06:22:24 <Entroacceptor> siracusa: I want to generate a hierarchical menu (html), some entries have children, some don't
06:22:38 <Entroacceptor> my data type is a record with children::[DirEntry]
06:22:59 <sipa> rothwell: the idea is that since your action must work for any type s, it cannot know anything about it, or do anything with it
06:23:02 <ski> rothwell : consider `elem :: forall a. a -> [a] -> Bool' : if we define it with `elem a0 = loop where loop [] = False; loop (a:as) = a0 == a || loop as', then the internal `loop' definition is *not* polymorphic in the type `a'
06:23:10 <Entroacceptor> but $if id.children$ always returns true
06:23:30 <ski> rothwell : i.e. you can't add a type signature `loop :: forall a. [a] -> Bool' to it
06:24:19 <ski> rothwell : this is because the internal definition *depends* on the outer variable `a0', which has `a' as type. so the type of `loop' is *dependent* on this type `a'
06:24:53 <Entroacceptor> and now I'm wondering if I misunderstood things, or how to check that
06:25:02 <rothwell> ski: think i understand
06:25:24 <ski> if the inner definition didn't depend on this outer variable, e.g. by passing it around as an argument instead, or if the outer variable didn't have a skolem type variable in its type, then this would work
06:25:28 <jamy> > type it
06:25:29 <lambdabot>   <no location info>: parse error on input `type'
06:25:41 <jamy> > it
06:25:42 <lambdabot>   Not in scope: `it'
06:26:10 <siracusa> Entroacceptor: Hhm, I'm not familiar with the StringTemplate syntax
06:26:34 <ski> rothwell : now, the "trick" with `runST' is simply that it *requires* the argument of type `ST s a' to be *polymorphic* in `s' (which you can think of as the implementation of `runST' deciding what actual state type (like `String' or `(String,Int,[Int -> Bool])') to instantiate the `s' with)
06:27:11 <ski> rothwell : and therefore, if you have a dependency which leaks the `s' out, then the `ST'-computation won't be polymorphic in `s', and so `runST' can't be applied
06:27:29 <ski> (however, one can still use `ST RealWorld a -> IO a' .. in GHC at least)
06:27:40 <rothwell> i see
06:28:20 <rothwell> think i'm going to have to get more acquainted with higher rank types... will solve a few problems i've had in the past elsewhere
06:28:46 <sipa> rothwell: in normal circumstances, if a function is polymorphic, it will be the caller of the function that decides what the actual type if going to be; if you pass a rank-2 type argument to a function, it is the called function that will the actual type
06:28:54 <rothwell> yep
06:29:07 <Entroacceptor> siracusa: if you know another solution where I define the output in a template file , tell me ;)
06:29:14 <sipa> *decide
06:29:18 <audunska> is it possible to build haskell-platform from source with libedit in a custom location?
06:29:25 <jamy> @info (+)
06:29:25 <lambdabot> (+)
06:29:38 <jamy> @type hello
06:29:39 <lambdabot> [Char]
06:29:59 <sipa> rothwell: for example a function { q :: (forall a. a -> [a]) -> Int -> [Int]; q f n = f n } is possible (though stupid)
06:30:04 <ski> Mercury employs a similar trick, except they have (essentially) `newSTState :: exists s. STState s' (and then operations `writeSTRef :: forall a s. STRef s a -> a -> (STState s -> STState s)', &c.)
06:30:10 <siracusa> Entroacceptor: If I'd had already finished the next version of Bravo, I'd suggest to use this instead :-)
06:30:28 <sipa> it will require the caller to pass a function that takes any argument a, and returns a list of it
06:30:36 <sipa> but q itself will just pass an Int to it
06:30:52 <Entroacceptor> siracusa: that wouldn't help me, I really do want runtime templating
06:31:13 <siracusa> Ah, I see
06:31:23 <sipa> you could q also give the type q :: (Int -> [Int]) -> Int -> [Int]
06:32:02 <rothwell> nice
06:32:06 <sipa> but doing it using the rank-2 type prevents the passed function from doing anything with its argument, since it does not know what type it is going to be
06:32:15 <sipa> although we know of course it will always just be an Int
06:32:32 <ski> rothwell,sipa : one example of using rank-2 polymorphism for hiding implementation details : "repaste of PoorManDebug" at <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10060> by ski
06:32:42 <sipa> where you should read "doing anything" as pattern matching on it
06:34:22 * ski notices the actual example use of that appears lost :/
06:34:37 <ski> the idea being that if you have
06:34:49 <ski>   fibonacci :: Num n => n -> n
06:34:59 <gwern> hm. how to count non-blank lines in a file from the shell... I think `wc` includes newlines in its count
06:35:05 <ski> then you can unwind the recursive knot to get
06:35:10 * ddarius is thinking making garbage collection not impossible for his language implementation will solve some current and future problems.
06:35:15 <ski>   fib :: Num n => (n -> n) -> (n -> n)
06:35:20 <ski> and then you get
06:35:24 <chrisdone> cake!
06:35:26 <ski>   fibonacci = fix fib
06:35:39 <ski> but if you lift `fib' monadically to
06:35:40 <ddarius> The cake is a fib.
06:35:47 <chrisdone> ddarius: tee hee!
06:35:59 <ski>   fibM :: (Monad m,Num n) -> (n -> m n) -> (n -> m n)
06:36:09 <ski> then you, by the paste, get both
06:36:12 <sipa> ski: i use it myself for a system where different implementations of an algorithm are possible, and the only thing that differs is the type of the expression you are computing; using rank-2 types it is possible to build a main function that takes a string on the commandline to describe the algorithm, and run it in the respective system
06:36:28 <jamy> i would be buy pocket calc with haskell. I even be gave $100 for him
06:36:30 <ski>   fibonacci = trivialFix fibM
06:36:32 <geheimdienst> gwern: grep -v "^$" | wc -l ?
06:36:33 <ski> as well as
06:37:00 <gwern> geheimdienst: yeah, that'd do it. I'm not comfortable with regexps so it's not the first thing that comes to mind
06:37:10 <ski>   fibonacciTrace :: Num n => n -> (Trace n n,n)
06:37:19 <ski>   fibonacciTrace = traceFix fibM
06:37:30 <rothwell> ski: pretty!
06:37:33 <chrisdone> jamy: what is your native language?
06:37:47 <ski> where the `Tree n n' contains a call tree of all recursive calls, with input and corresponding output
06:37:56 <jamy> RU
06:38:06 <chrisdone> interesting
06:38:11 <geheimdienst> :) for me it was the 3rd thing that came to mind ... 1st was "wtf, wc doesn't have a switch for that?" 2nd was "wtf, cat doesn't have a switch for that?"
06:38:17 <Jafet> Nadsat!
06:38:23 <siracusa> Entroacceptor: HStringTemplate has a built-in length function, not sure how to use it properly though.
06:38:23 <ski> rothwell : and if you look at the type of `traceFix', you'll see it uses rank-2 polymorphism to hide which actual monad it uses in place of `m'
06:38:32 <jamy> I was with BASIC
06:38:36 <rothwell> ski: yep
06:38:42 <sipa> BASIC!
06:38:50 <chrisdone> Jafet: show us yer yarbles, that's if you have any yarbles!
06:39:04 <rothwell> ski: must admit, i'm quite impressed that this is doable statically
06:39:17 * Jafet gives geheimdienst a -c
06:39:22 <rothwell> these are corners of the type system i've not wandered into yet
06:39:24 <ski> ddarius : .. and region management ?
06:39:50 <geheimdienst> jafet: interesting ... what command?
06:40:01 <ski> sipa : yeah :) .. elaborate ?
06:40:12 <Jafet> geheimdienst: it's your -c, so I'll let you choose.
06:40:46 <sipa> ski: about?
06:41:01 <ski> sipa : how you used rank-2, more specifically
06:41:33 * geheimdienst sticks the -c onto jafet, like a pencil behind the ear
06:42:50 <ski> rothwell : btw, i'm not sure it was clear, but : the fact that `fibM' only uses a monad polymorphic means that it really must be pure; it can't perform any specific effects -- apart from those that its argument (the recursive self) performs .. and that's of course where `traceFix' sneaks in the effects
06:43:20 <ski> rothwell : so, you're guaranteed that the function passed to `traceFix', in itself, can't perform any effects
06:44:04 <rothwell> ski: yeah, i understand
06:44:28 <rothwell> thanks for the impromptu lecture, has helped
06:44:37 <ski> np, yw
06:45:07 <sipa> ski: ok, i'm working on MCP (a constraint modelling/solving framework in Haskell); when you write a model, it is of type Tree s a; s is the type of the solver that's used internally, and a is the return type (Tree s is a Monad as well); most expressions one would use to write a Tree are independent from the actual solver. If you write a function that creates a Tree (of indeterminate solver type s), and pass it to an example main function,...
06:45:13 <sipa> the main function will look at the command line arguments, and use your function to build a Tree Solver1 a if "solver1" is specified, or a Tree Solver2 a if "solver2" is specified, ...
06:46:08 <sipa> without rank-2 types, it would be impossible to call the passed function as being something of either type Tree Solver1 or Tree Solver2
06:47:19 <jamy> somebody would have tossed the idea of some sort. for example to citizen
06:47:33 <ski> sipa : yes, i see
06:47:41 <yrlnry> I have read a bunch of papers about parallelism in Haskell and control of parallel evaluation, but I am puzzled by something:  Since the compiler can tell when code might have side effects, and can detect all sharing of subexpressions, why can't it parallelize evaluation automatically?
06:47:54 <yrlnry> Is there some insuperable problem, or is it possible at least in principle?
06:48:07 * hackagebot bindings-libzip 0.1 - Low level bindings to libzip.  http://hackage.haskell.org/package/bindings-libzip-0.1 (SergeyAstanin)
06:48:28 <ski> it could, but in practice it's bad to parallelize everything .. too fine-grained parallelism has too much overhead
06:48:29 <Toxaris> yrlnry: the compiler can't predict how much work evaluating something will be, so it would end up adding *too much* parallelism
06:48:30 <chrisdone> no functorsalands today
06:48:31 <sipa> yrlnry: i believe the biggest problem is not deciding where parallellism is possible, but deciding where parallellism us useful
06:48:36 <sipa> *is
06:48:47 <sipa> since overdoing it is very bad for performance as well
06:48:50 <Toxaris> yrlnry: you see, a lot of parallel answers just don
06:48:56 <Toxaris> ... 't help
06:49:01 <Toxaris> :)
06:49:15 <yrlnry> Thanks.
06:49:40 <sipa> well, he got three more or less equivalent answers... parallellism can help overcome glitches :)
06:50:24 <rschnck> Hey, is anyone aware of software that can be used to diagram DFAs/NFAs?
06:51:08 * hackagebot LibZip 0.2.0 - Bindings to libzip, a library for manipulating zip archives.  http://hackage.haskell.org/package/LibZip-0.2.0 (SergeyAstanin)
06:51:13 <Toxaris> rschnck: graphviz, or latex + pgf/tikz
06:51:26 <frerich3> rschnck: http://www.cs.virginia.edu/~ph4u/dprle/camldoc/Nfa.html might work for you (Haskell, too)
06:51:30 <frerich3> err, caml
06:51:41 <yrlnry> Thanks very much.
06:52:10 <rschnck> Toxaris: pgf/tikz looks pretty good, thanks
06:53:09 <Zao> rschnck: qtiplot can generate TikZ plots in the current version, by the way.
06:53:13 <Zao> Supposedly a nice program.
06:53:38 <Zao> (although you have to pay for windows binaries if you can't compile it yourself)
06:55:00 <jamy> anybody heard about HOUSE OS?
06:55:48 <pozic> jamy: everyone?
06:55:59 <rschnck> Zao: I use Linux :3
06:56:10 <Zao> rschnck: Good for you :D
06:56:33 <rschnck> It was just in reply to the windows bit :(
06:56:37 <rschnck> Anyway, I'll look into it
06:56:56 <jamy> this os writing on haskell
06:57:36 <jamy> and have shell like ghci
07:09:37 <dcoutts> aleator: actually checking .h files is a feature
07:10:14 <dcoutts> aleator: we've changed the error message in the latest Cabal to be clearer that the cause can be that the .h file is bad rather than it being missing
07:10:44 <dcoutts> aleator: so yes, the error message was buggy in that it was misleading, I think we've now corrected that
07:19:17 * hackagebot ecu 0.0.3 - Tools for automotive ECU development.  http://hackage.haskell.org/package/ecu-0.0.3 (TomHawkins)
07:25:18 * ddarius might have figured it out.
07:25:32 * Nibble thinks ddarius might have figured it out
07:25:47 * rothwell thinks Nibble thinks that ddarius might have figured it out
07:26:33 * Twey thinks rothwell thinks Nibble thinks ddarius might have… no, this is silly
07:28:06 <sipa> data Fact = HasFiguredItOut | ThinksThat NickName Fact
07:28:52 <Vanadium> That is the worst list
07:30:20 * hackagebot bidispec 0.1.3 - Specification of generators and parsers  http://hackage.haskell.org/package/bidispec-0.1.3 (StefanWehr)
07:34:21 * hackagebot network-bytestring 0.1.3.1 - Fast, memory-efficient, low-level networking  http://hackage.haskell.org/package/network-bytestring-0.1.3.1 (JohanTibell)
07:40:22 * hackagebot bidispec-extras 0.1 - Extra helper functions for bidirectional specifications  http://hackage.haskell.org/package/bidispec-extras-0.1 (StefanWehr)
07:41:52 <dankna> so I'm running into confusion on how to organize my program
07:41:58 <dankna> perhaps I can think out loud and anyone who has thoughts can chime in
07:42:44 <Entroacceptor> perhaps  you can, will you try to find out?
07:42:48 <dankna> yes :)
07:42:57 <dankna> I have a type View, which represents a displayed on-screen object.
07:43:11 <dankna> I have a type-class Responder which represents the interactive behavior of an object.  So a Responder is a field of a View.
07:43:23 * hackagebot hxthelper 0.2.2 - Helper functions for HXT  http://hackage.haskell.org/package/hxthelper-0.2.2 (StefanWehr)
07:43:33 <dankna> I have another type-class DrawResponder which extends Responder with additional methods for drawing.
07:43:44 <dankna> so actually I misspoke (already!), it's DrawResponder that's a field of a View
07:43:49 <dankna> of course it can't be that simple, I need an existential type
07:44:09 <dankna> I genuinely do need the existential because I want View to be monomorphic but Responder to be polymorphic, whatever that means
07:44:31 <dankna> so I have two existentials AnyResponder (with constructor SomeResponder) and AnyDrawResponder (with constructor SomeDrawResponder)
07:45:23 <dankna> I have a few instances of these, but let's deal for now with the instance Button
07:45:30 <dankna> now I am running into situations where I would like to be able to extract the specific thing from the existential, perhaps with a type signature along the lines of View -> Maybe Button
07:45:43 <dankna> returning Just something if the content of the existential is a Button, and Nothing if it's anything else
07:46:05 <dankna> I'm not clear on whether this is even possible - I get messages about rigid type variables and stuff when I try it, so I suspect it's not exactly doable in that form
07:47:00 <dankna> but I remembered having done this before so I looked at my other project, where I had a method in the type-class, which translated into the terms of this project for simplicity would be
07:47:17 <dankna> for type-class Responder r, the method would be fromAnyResponder :: AnyResponder -> Maybe r
07:48:00 <dankna> this makes sense to me:  I can't (I think?) case on the real type of an existentially quantified value, but I can use a real function's patterns to match against it
07:48:06 <dankna> I seem to remember something about that being an implementation limit
07:48:47 <dankna> and it passes the basic sanity check that it ought to be doable, because I'm not trying to write a function that guarantees to produce a value of a specific type, given a value of a type it doesn't control (a rigid type)
07:49:01 <dankna> instead I'm writing a function that offers to produce such a value only if it can be done
07:49:11 <dankna> so far, so good; I think I understand how to do this
07:49:21 <dankna> but I'm running into confusion with the fact that I have two type-classes
07:49:30 <dankna> I'm thinking I need a method in each one, fromAnyResponder and fromAnyDrawResponder
07:50:00 <dankna> but this part is not totally clear to me
07:50:51 <dankna> is anybody following this? :)
07:51:37 <sipa> no
07:51:39 <sipa> nobody
07:51:44 <dankna> drat
07:51:51 <dankna> I was afraid of that! :)
07:51:56 <sipa> sorry
07:52:45 <dankna> hm
07:53:27 * hackagebot httpspec 0.3.0.1 - Specification of HTTP request/response generators and parsers  http://hackage.haskell.org/package/httpspec-0.3.0.1 (StefanWehr)
07:53:42 <dankna> in particular, I have instances Responder AnyResponder, Responder AnyDrawResponder, and DrawResponder AnyDrawResponder, which simply forward the calls to the underlying object
07:53:58 <dankna> and I'm confused at the meaning of, say, the AnyDrawResponder method for fromAnyResponder
07:54:13 <dankna> I could just make it undefined until I have proven I actually need it, I guess...
07:54:20 <dankna> and when I need it will be a clue to what it means
07:55:28 * hackagebot haskoon 0.3.1.1 - Web Application Abstraction  http://hackage.haskell.org/package/haskoon-0.3.1.1 (StefanWehr)
07:57:23 <zygoloid> dankna: you need a Typeable instance to be carried by your Any* existentials, or something morally equivalent to it
07:57:29 <dankna> hmm
07:57:32 <dankna> interesting thought
07:57:38 <dankna> why do you say that?
07:57:50 <sipa> morally equivalent code
07:57:55 <sipa> i wonder what that means
07:57:58 <zygoloid> that'd let you extract the specific type within your existential
07:58:15 <dankna> hmm
07:58:17 <geheimdienst> (MorallyEqToTypeable a) => Any a
07:58:23 <dankna> you mean as if the existential were a Dynamic, kind of
07:58:30 <zygoloid> yes
07:58:57 <dankna> I see what you're saying and I can possibly figure out how to do it that way,
07:59:05 <dankna> but I thought existentials already did carry that information internally
07:59:27 <zygoloid> nope. that information is/can be erased at compile time
07:59:31 <dankna> hmmm okay
08:00:18 <dankna> hmm
08:00:20 <zygoloid> if you're prepared to drop down to the implementation level, you actually can extract that information from a closure if it's been forced, but denotationally you can't.
08:00:23 <copumpkin> so you want Dynamic?
08:00:37 * zygoloid would not recommend that unless you have very thick skin ;)
08:00:55 <copumpkin> I thought you were talking about an Any + a Typeable dictionary :P
08:01:01 <dankna> that's almost what I'm thinking, that maybe I should be using Dynamic instead of existentials
08:01:02 * copumpkin just woke up
08:01:17 <dankna> morning copumpkin.
08:01:27 <dankna> but but but that wouldn't be type-safe :)
08:02:08 <dankna> with existentials, I know at compile time that anything put into the responder field of a View is actually a responder, although I don't know what type of responder it is
08:02:13 <ray> type safety? pshaw
08:02:22 <ray> giving up liberty for security
08:02:26 <dankna> that guarantee seems worth a little extra effort
08:02:27 <dankna> haha
08:02:55 <sipa> ray: yes all those type system things... highly overrated
08:03:03 <sipa> lets just use php
08:03:26 <dankna> also, now that I think about it, if I just used Dynamic it wouldn't solve the problem at all because I'd have to case on an open set of items just to call the methods they have in common
08:03:30 <sipa> i believe it even has closures these days
08:04:08 <ray> they're all turing tarpit complete, let's just use subtract and branch if less than or equal to
08:18:19 * Entroacceptor sobs a little
08:18:26 <Entroacceptor> what does  n <- option True (char '!' >> return False) do?
08:18:40 <Entroacceptor> how can I find out where that "option" is from?
08:18:50 <sipa> @hoogle option
08:18:50 <Twey> parsec, no?
08:18:50 <lambdabot> Text.Html option :: Html -> Html
08:18:50 <lambdabot> Text.Parsec.Combinator option :: Stream s m t => a -> ParsecT s u m a -> ParsecT s u m a
08:18:51 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
08:18:55 <Entroacceptor> (this is from HStringTemplate, Base.hs line 445
08:19:03 <Twey> It's for an optional parse
08:19:24 <Twey> Either it parses (char '!' >> return False) or it returns the supplied default (True)
08:19:27 <geheimdienst> Entroacceptor: try the parsec documentation ... the second hoogle hit
08:19:42 <Entroacceptor> aah
08:19:47 <Entroacceptor> thanks
08:19:59 <Entroacceptor> misread a function argument
08:20:46 <Entroacceptor> but calling your variables "cb t e n p act cont" makes me want java
08:20:47 <Entroacceptor> ...
08:21:02 <Twey> Look at the types, not the argument names
08:21:27 <Twey> Though, that said, p is probably a predicate, act a monadic action, and cont a continuation
08:21:37 <Twey> n probably a number
08:21:46 <Twey> t e cb depends on the context, really
08:22:50 <Entroacceptor> n isn't a number, as you should know, thanks for proving my point ;)
08:23:25 <Twey> I did say ‘probably’
08:23:33 <Twey> It's all context-dependent
08:23:36 <Entroacceptor> well, I pasted the line where it got set
08:23:46 <Twey> Oh, I didn't read it
08:23:50 <Twey> Yes, sorry
08:23:52 <Entroacceptor> :)
08:23:58 <Entroacceptor> I'm just confused, sorry
08:23:58 <Twey> But it really just proves my point: look at the types
08:27:49 <dankna> zygoloid, I believe I know how to do it now.  Thanks for the suggestion.
08:34:56 <dankna> and, I have it working.  yay.
08:39:45 * hackagebot haskoon-httpspec 0.5.0.1 - Integrating HttpSpec with Haskoon  http://hackage.haskell.org/package/haskoon-httpspec-0.5.0.1 (StefanWehr)
08:41:46 * hackagebot smartGroup 0.2.1 - group strings by words in common  http://hackage.haskell.org/package/smartGroup-0.2.1 (SamAnklesaria)
08:42:48 * hackagebot haskoon-salvia 0.4.0.2 - Integrating HttpSpec with Haskoon  http://hackage.haskell.org/package/haskoon-salvia-0.4.0.2 (StefanWehr)
08:43:47 * hackagebot uni-util 2.2.0.0 - Utilities for the uniform workbench  http://hackage.haskell.org/package/uni-util-2.2.0.0 (ChristianMaeder)
08:44:57 * Entroacceptor sobs some more
08:45:49 * hackagebot uni-events 2.2.0.0 - Event handling for the uniform workbench  http://hackage.haskell.org/package/uni-events-2.2.0.0 (ChristianMaeder)
08:46:50 * hackagebot uni-reactor 2.2.0.0 - Reactors for the uniform workbench  http://hackage.haskell.org/package/uni-reactor-2.2.0.0 (ChristianMaeder)
08:46:52 * hackagebot uni-posixutil 2.2.0.0 - Posix utilities for the uniform workbench  http://hackage.haskell.org/package/uni-posixutil-2.2.0.0 (ChristianMaeder)
08:48:50 * hackagebot uni-htk 2.2.0.0 - Graphical User Interface for Haskell Programs  http://hackage.haskell.org/package/uni-htk-2.2.0.0 (ChristianMaeder)
08:54:49 <Cale> Entroacceptor: The usual approach is that variable name lengths should be an increasing function of the size of the scope in which they are defined, and a decreasing function of the number of sites at which they're used. So things which are globally defined should have long names unless they are used all the time (like function composition (.) for instance), but things which only scope over a couple lines can have shor
08:54:49 <Cale> t names since you're staring at their definition.
08:56:00 <Entroacceptor> except when you aren't, like in a do block
08:56:20 <Cale> Depends how large the do-block is :)
08:58:07 <Cale> HStringTemplate is a weird package.
08:58:45 <Entroacceptor> I am glad you said that.
08:58:48 <dankna> I don't necessarily hold with the approach you describe, Cale
08:58:58 <dankna> I'm more in favor of very long names, period
08:59:08 <dankna> if a thing isn't worth a very long name, it isn't worth any name at all, so write pointfree
08:59:25 <Cale> dankna: It influences how often we use things.
08:59:37 <Twey> Cale: Weird how?
08:59:41 <dankna> not if everything is long - then we use them all equally infrequently
08:59:48 <Cale> If (.) were renamed to compose, points-free style would hardly be reasonable
09:00:17 <dankna> granted.  I think symbols are a special class of names - if (.) were renamed to "a", I wouldn't support that
09:00:17 <Cale> and that's only 7 letters :)
09:00:20 <Twey> I'm with dankna *except* when the resulting point-free code is horrible
09:00:37 <dankna> the fact that it's punctuation clearly signals to the reader that it's something he's expected to memorize
09:01:55 <mornfall> Very long names are very irritating.
09:02:18 <mornfall> (Especially if they are longer than their definition.)
09:02:21 <dankna> having to memorize arbitrary names just because somebody thought they were cute is not fun; longer names are (perhaps counterintuitively) easier to remember because they have more semantic content
09:02:31 <dankna> granted
09:02:49 <dankna> I don't deny that they're annoying to type, but that's the tradeoff for readability
09:02:58 <mornfall> They are annoying to read as well.
09:03:03 <dankna> writing code the first time is not the case we should be optimizing for; maintaining it in the long term is
09:03:04 <Twey> I agree only sometimes
09:03:12 <dankna> mm....  I don't think I agree that they're irritating to read
09:03:30 <Twey> ‘Long’ names (7-10 characters) are alright, but ‘long’ names (15+ characters) tend to be bad
09:03:34 <Cale> I contend that map f (x:xs) = f x : map f xs  is actually easier to read than   applyToAll functionToApply (firstElementOfList : remainderOfList) = functionToApply firstElementOfList : applyToAll functionToApply remainderOfList
09:03:43 <Twey> I concur
09:03:51 <dankna> long names (20-30 characters) are what I'm talking about :)
09:04:01 <Twey> Should never happen
09:04:04 <Cale> 20-30 characters is just ridiculous
09:04:12 <dankna> haha
09:04:12 <Twey> If you've got names that long, you need more modules
09:04:13 <dankna> oh well
09:04:15 <mornfall> Cale: My point exactly. Thanks for making it so clear. :))
09:04:38 <dankna> see, firstElementOfList is not a name I would use
09:04:39 <dankna> it has insufficient semantic content per word
09:04:44 <Twey> A name shouldn't be more than one or two words
09:04:45 <dankna> I would just call it "first"
09:05:01 <mornfall> dankna: That doesn't fit your 20-30 frame at all.
09:05:01 <Cale> Granted, my example was exaggerated for effect
09:05:33 <dankna> I suppose I do use shorter names too, but only for things that are very local in scope
09:05:35 <Cale> There's no excuse for using names longer than 1 or 2 symbols here, since the scope is *one line*
09:05:54 <dankna> I would argue there's no excuse for using names /at all/ when the scope is one line
09:05:57 <ddarius> Most names are not arbitrary and not chosen to be cute regardless of their size.
09:06:13 <dankna> mm.... programmers seem to like abbreviations
09:06:24 <dankna> abbrs r evil
09:06:38 <Twey> And yes, don't forget that abbreviations allow one to pack more semantic content into a shorter name
09:06:38 <dankna> because you can never remember which of the many possible ways to abbreviate something the author chose
09:06:53 <Cale> Well, you could write  map f = foldr ((:) . f) [], or even try to points-free that, but at that stage it gets ugly.
09:06:56 <ddarius> dankna: That doesn't matter for reading.
09:06:59 <Twey> ‘char’ has exactly the same semantic content as ‘character’, but it's five characters shorter.
09:06:59 <dankna> I suppose I'm not so much pro-long-name for its own sake as anti-abbreviation
09:07:02 <Cale> @pl map f = foldr ((:) . f) []
09:07:03 <lambdabot> map = flip foldr [] . ((:) .)
09:07:13 <Twey> ‘int’ for ‘integer’, &c.
09:07:17 <dankna> ddarius: it can!
09:07:25 <dankna> ddarius: it can be unclear what an abbreviation stands for
09:07:27 <ddarius> dankna: Occassionally, yes.  
09:07:36 <ddarius> dankna: That's poor naming.  It happens.
09:08:07 <dankna> yes, well, my own naming practices are chosen to reduce the chance of bad names, even when I'm in a hurry and on a bad day
09:08:17 <Cale> If you only use something once in a blue moon, it should have an unabbreviated name.
09:08:22 <dankna> requiring myself to be at peak form all the time isn't solving the problem
09:08:22 <ddarius> dankna: Note the problem you mention applies much more strongly to long names.  Did the author write firstElementOfList or firstListElement?
09:08:54 <Cale> Though yes, conventions become really important with longer names.
09:08:55 <dankna> well, not if you choose your practices to avoid that question.  I have a rule that I never use any preposition in a name unless it's utterly unavoidable.
09:09:14 <dankna> if it's really so unavoidable, I ought to remember it
09:09:36 <ddarius> dankna: It doesn't matter.  The longer the name is the more arbitrary choices it allows.
09:09:48 <Cale> listFirstElement
09:09:50 <dankna> if only because of synonyms, you're sort of right
09:09:53 <Twey> Prepositions are good as argument names
09:10:20 <dankna> but those choices are more easily remembered than choices about abbreviations, because they become part of the program's ontology
09:10:22 <Twey> map to from = lookup to from … or something
09:10:31 <dankna> which you have to keep in your brain anyway to work on the program
09:10:40 <ozataman> hey all. when an exception is caught in the IO monad, is there a way to make it so that things continue happening? It seems that even when I use "catch" to handle the exception (output a warning string and return a valid value so that the computation can continue), the program exists...
09:10:55 <ddarius> dankna: Not really and no more or less than abbreviations.  The key to both of these working is consistency.
09:11:05 <dankna> Twey: your specific example is fine; I'm not sure what the general principle for when it's okay would be, and there are other points being made that demand my attention more :)
09:11:25 <dankna> well, you're absolutely right about consistency being important, and I guess it's important for the short-name crowd too
09:11:50 <dankna> I guess the hope at least with long names is that the conventions you've decided on are more evident to later readers
09:12:34 <dankna> and I do use "i" and "j" and sometimes even "n", because those are conventions that everybody really does know and agree on
09:13:11 <dankna> I wonder whether there will ever be consensus on this sort of issue
09:13:15 <dankna> like, a hundred years from now
09:13:18 <dankna> will we still be debating it?
09:13:23 <dankna> I could see a case that we will
09:13:27 <ddarius> Of course.  Look at natural language.
09:13:34 <dankna> well, that's true, haha
09:14:04 <ddarius> Of course, by then the problem will be moved elsewhere as we'll probably be using some kind of presentation-independent representation of code.
09:14:12 <dankna> natural language goes through phases though - phases which last many years, I'm not sure how many exactly - of rationalization and ... er... the opposite
09:14:30 <mornfall> dankna: But even not using abbreviations, it's quite hard to come up with names that are 20 characters long.
09:14:36 <dankna> that sounds similar to thoughts I've had, but could you expand on what you mean by presentation-independent?
09:14:51 <dankna> mornfall: not really :)
09:15:18 <dankna> mornfall: record accessors in Haskell, for example, I always start with the name of the record type and that's at least five to ten characters right there...
09:15:37 <ddarius> dankna: It's the standard "store syntax graphs in a database then have your IDE render them however you like."
09:15:40 <mornfall> dankna: But the record type should have a name 20 characters long.
09:15:45 <dankna> and I often make the rest of the name be the field type
09:15:56 <mornfall> Hungarian for the win. :(
09:16:01 <dankna> ddarius: oh, yes, okay.
09:16:16 <dankna> mornfall: well, hehe, I do run into that problem on occasion :)
09:16:51 <dankna> where my rules require me, for consistency's sake, to use a name so long that it's the only thing I can fit on one line
09:17:14 <dankna> I solve that by locally binding a shorter name for it that omits the words that are implied by that particular context anyway
09:17:29 <mornfall> I think your rules are a mess. : - )
09:17:34 <dankna> haha, drat :)
09:17:45 <dankna> well, ultimately I suppose we'd have to read each others' code to get an idea of how well it works in practice
09:17:51 <dankna> which might be interesting sometime
09:18:35 <ddarius> dankna: I don't know what you'd expect to accomplish with that.  You'd each find the others code unreadable.
09:18:41 <dankna> I don't know
09:18:52 <dankna> we'd find it very foreign, to be sure
09:18:59 <dankna> but unreadable?  if so, then we're both wrong
09:19:04 <dankna> and neither of our conventions is actually any good
09:19:26 <dankna> that's what this is all about, after all, making things that work for OTHER people who DON'T know the rules yet
09:19:26 <ddarius> dankna: Have you considered that the conventions that are effective depend on the reader?
09:19:30 <geheimdienst> my rule of thumb is the more places can see a name, the longer the name should be
09:19:35 <dankna> ddarius: I have but I disagree! :D
09:19:47 <dankna> geheimdienst: that's the remark that sparked this conversation
09:20:08 <dankna> I said something along the lines of "in general yes, but I prefer longer names than you do"
09:20:14 <geheimdienst> i see. i was afk until 10 minutes ago
09:20:15 <dankna> or tried to, not sure it got across
09:20:22 <Entroacceptor> no, the remark was that I'm dying from trying to understand istat from Base.hs line 441 
09:20:27 <dankna> oh, haha
09:20:37 <dankna> have you got a link to that, Entro?
09:22:05 <Entroacceptor> dankna: http://code.haskell.org/HStringTemplate/Text/StringTemplate/Base.hs
09:23:23 <dankna> "return act" in elsestat?
09:24:05 <Entroacceptor> oh. it's in 419 in that
09:24:19 <dankna> oh hm
09:24:20 <dankna> ifstat
09:24:21 <dankna> okay
09:24:53 <Entroacceptor> must've misclicked
09:24:54 <dankna> so we've got a monadic-combinator parser type TmplParser
09:25:19 <dankna> the result of this particular parse function is a function, which takes an environment and returns a value
09:25:32 <dankna> hm
09:26:14 <dankna> Tmpl probably stands for template and stmpl for string-template
09:26:59 <dankna> okay, what do you need to do to this function?  heh
09:27:34 <Entroacceptor> dankna: well... 
09:28:05 <Entroacceptor> I was looking at it because in a template $if(somethingListy)$ always evaluates to True
09:28:24 <Entroacceptor> because somethingListy is always set (comes from a record children::[DirEntry])
09:28:30 <dankna> okay, hmm
09:29:02 <Entroacceptor> but booleans are supposed to be treated differently, so that $if(boolValue)$ is True only when boolValue is True
09:29:22 <Entroacceptor> so I was trying to find if I can patch stringtemplate to do that for lists, too
09:29:29 <Entroacceptor> because you could argue that [] is False.
09:29:44 <Entroacceptor> and that whole "only if it's set" doesn't make sense if you can't have null pointers
09:29:51 <dankna> okay.
09:30:09 <Entroacceptor> but instead my brain melted and then exploded
09:30:12 <dankna> not sure I agree with the design decision to make [] False, but leaving that aside
09:30:12 <dankna> haha
09:30:35 <dankna> well, it looks to me like this defers the real work to ifIsSet
09:31:08 <Entroacceptor> I'm not sure about [] either, but I can't see how to do it differently
09:31:11 * dankna nods
09:31:12 <dankna> hm
09:31:21 <Entroacceptor> except adding a new value to the record hasChildren :: Bool
09:31:24 <Entroacceptor> which is kind of silly
09:31:40 <Saizan> can't you apply null?
09:31:43 <Entroacceptor> ooor someone tells me I can do it without an if at all
09:31:43 <Saizan> ?type null
09:31:44 <lambdabot> forall a. [a] -> Bool
09:31:51 <Saizan> inside your template, i mean
09:32:35 <Entroacceptor> Saizan: no, I can only check for existance
09:37:03 <Entroacceptor> dankna: while trying to understand getProp I got too confused to continue
09:37:14 <Saizan> meh, one reason why i don't like template languages
09:37:31 <dankna> Entro: oh :(
09:37:42 <dankna> me too
09:38:28 <Entroacceptor> or maybe I'm missing something important and can do it without all that if stuff
09:38:57 <Entroacceptor> but I can't find anyone here actually using HStringTemplate....
09:39:50 <dankna> heh, yeah
09:40:39 <Entroacceptor> can I install hoogle or hayoo for my locally installed packages?
09:40:56 <Saizan> maybe look for resources on StringTemplate itself
09:41:07 <Entroacceptor> Saizan: tried to, didn't find anything so far
09:41:38 <Entroacceptor> ah, hoogle has a cmd tool
09:41:57 <Saizan> yeah, the problem is to populate hoogle's database
09:41:58 <Entroacceptor> Saizan: but I'd really argue that [] should test false 
09:44:05 <Entroacceptor> so it's a haskell bug ;)
09:45:16 <Entroacceptor> ah well, gtg
09:45:23 <Entroacceptor> see you later, and thanks
09:56:51 <dino-> I'm wondering if anyone here has experience building statically linked cgi with Haskell. In this case, it's very plain stuff relying only on Network.CGI and Text.XHtml
09:57:29 <dino-> When I build static, I get a lot of warnings about things in libHSnetwork requiring shared glibc still.
09:58:17 <sclv_> Entroacceptor: still around?
09:59:59 <dino-> And then it doesn't run on the system I deploy to. Which is some GoDaddy business that I was given FTP access to. bleh
10:01:39 <sclv_> @tell Entroacceptor $if(first xs)$ will only fire if xs is not null... 
10:01:39 <lambdabot> Consider it noted.
10:09:45 <c_wraith> Gah.  Why do I have so much trouble writing "merge :: Ord a => [(a, b)] -> [(a, [b])]"?  It feels like that should be some easy set of combinators
10:10:17 <c_wraith> The Ord constraint isn't strictly necessary, but it makes it much easier to write an efficient implementation.
10:11:14 <djfroofy> hey all, i'm trying to write a paper on the next inscrutable haskell function to be referenced in a future paper. any suggestions where to start? 
10:12:05 <Lemmih> c_wraith: groupBy ((==) `on` fst) plus a little wibbling?
10:12:28 <c_wraith> Lemmih, it's that last part that's harder than it should be
10:13:18 <c_wraith> ah, unzip might make it a ton easier
10:13:25 <Lemmih> ?type \l -> [ (fst (head ls), map snd ls) | ls <- groupBy ((==) `on` fst) l ]
10:13:26 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [(a, [b])]
10:13:28 <c_wraith> that might be the thing I was missing
10:14:05 <c_wraith> also, you need a sort
10:14:11 <c_wraith> well, sortBy
10:14:40 * Lemmih blames the spec.
10:15:11 <zygoloid> djfroofy: try making up a type, get @djinn to prove it's inhabited, then see if you can make any sense of it from a category-theoretical or intuitionistic logci standpoint?
10:15:14 <c_wraith> I told you the Ord constraint was necessary for efficiency
10:15:41 <c_wraith> :t map (first head . unzip) . groupBy ((==) `on` fst) . sortBy (comparing fst)
10:15:42 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, [b])]
10:16:03 <Lemmih> c_wraith: And it is. But you didn't explicitly tell me to use it, though.
10:16:21 <djfroofy> zygoloid: thanks. i'll try that. how do i know if a type's inhabited?
10:16:34 <sipa> :t (5 3)
10:16:35 <lambdabot>     Ambiguous type variable `t' in the constraint:
10:16:35 <lambdabot>       `Num t' arising from the literal `3' at <interactive>:1:3
10:16:35 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
10:16:36 <yrlnry> djfroofy:  or pick out some random theorem of classical logic that is intuitionistically false, and show how Haskell can be extended with some sort of function with that type.
10:16:42 <sipa> :t (5 3)::Int
10:16:43 <lambdabot> Int
10:16:50 <sipa> > (5 3)::Int
10:16:51 <lambdabot>   5
10:16:54 <yrlnry> djfroofy:  that strategy worked excellently for call-with-current-continuation.
10:17:14 <zygoloid> @djinn (a -> Either b (a -> b)) -> (a -> b)
10:17:14 <lambdabot> f a b =
10:17:15 <lambdabot>     case a b of
10:17:16 <lambdabot>     Left c -> c
10:17:18 <lambdabot>     Right d -> d b
10:17:23 <zygoloid> djfroofy: ^^ something like that might work
10:17:29 <sipa> @help
10:17:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:17:38 <sipa> @help @djinn
10:17:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:17:46 <sipa> @help djinn
10:17:46 <lambdabot> djinn <type>.
10:17:46 <lambdabot> Generates Haskell code from a type.
10:17:46 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
10:18:23 <sipa> @djinn (forall a. a -> [a]) -> Int -> [Int]
10:18:24 <lambdabot> Error: Undefined type []
10:18:24 <yrlnry> @djinn (Either (a -> c) (b -> c)) -> (a,b) -> c
10:18:24 <lambdabot> f a =
10:18:25 <lambdabot>     case a of
10:18:25 <lambdabot>     Left b -> \ (c, _) -> b c
10:18:25 <lambdabot>     Right d -> \ (_, e) -> d e
10:18:48 <sipa> @djinn (a -> [a]) -> Int -> [Int]
10:18:48 <lambdabot> Error: Undefined type []
10:18:49 <djfroofy> @djinn (b -> Either c d)
10:18:49 <lambdabot> -- f cannot be realized.
10:18:57 <djfroofy> aww snap
10:19:02 <djfroofy> @djinn (b -> Either c)
10:19:02 <lambdabot> Error: kind error: (KVar 2,KStar)
10:19:09 <djfroofy> @djinn (b -> Either b)
10:19:09 <lambdabot> Error: kind error: (KVar 1,KStar)
10:19:18 <zygoloid> djfroofy: Either needs a second type argument
10:19:28 <djfroofy> @djinn (b -> Either b (b -> v))
10:19:29 <lambdabot> f = Left
10:19:54 <djfroofy> [ 1 .. 5]
10:20:00 <djfroofy> > [ 1 .. 5 ]
10:20:01 <lambdabot>   [1,2,3,4,5]
10:20:28 <djfroofy> [ 0 1 1 2 3 5 .. ]
10:20:39 <djfroofy> > [ 0 1 1 2 3 5 .. ]
10:20:40 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
10:21:08 <djfroofy> haskell should have just known i was trying to lay down a fibonacci
10:21:33 <sipa> @djinn (Int -> Int) -> (Int -> Int)
10:21:33 <lambdabot> Error: Undefined type Int
10:21:42 <sipa> @djinn (a -> a) -> (a -> a)
10:21:43 <lambdabot> f a = a
10:21:47 <sipa> boring
10:22:11 <djfroofy> so are there any interesting algorithm music projects based on haskell?
10:22:47 <djfroofy> @djinn Maybe
10:22:47 <lambdabot> Error: kind error: (KArrow KStar KStar,KStar)
10:22:55 <djfroofy> @djinn (a -> Maybe)
10:22:55 <lambdabot> Error: kind error: (KArrow KStar KStar,KStar)
10:22:58 <djfroofy> @djinn (a -> Maybe a b)
10:22:59 <lambdabot> Error: kind error: (KArrow (KVar 1) (KVar 3),KVar 2)
10:23:00 <djfroofy> @djinn (a -> Maybe a)
10:23:01 <lambdabot> f = Just
10:23:06 <djfroofy> @djinn (a -> Maybe 0)
10:23:06 <lambdabot> Cannot parse command
10:23:07 <Cale> djfroofy: btw, the reason you were getting the list [0..] there is that you forgot the commas in your list, and lambdabot has a module which gives a function instance for numbers
10:23:22 <Cale> djfroofy: (numbers become constant functions and are added pointwise)
10:23:25 <djfroofy> > [ 0, 1, 1, 2, 3, 5 .. ]
10:23:26 <lambdabot>   <no location info>: parse error on input `..'
10:23:30 <djfroofy> > [ 0, 1, 1, 2, 3, 5, .. ]
10:23:31 <lambdabot>   <no location info>: parse error on input `..'
10:23:36 <Cale> It's normally just a parse error :)
10:23:59 <Cale> > extendSequence [0, 1, 1, 2, 3, 5]
10:24:01 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:24:14 <djfroofy> Cale: yeah, thanks for the tip. i'm just going to hang out here until this haskell stuff sinks in if that's ok
10:24:24 <Cale> djfroofy: Certainly :)
10:24:36 <Cale> djfroofy: Don't be afraid to ask questions
10:24:42 <djfroofy> Cale: and that's rad ^^^
10:24:45 <sipa> @hoogle extendSequence
10:24:45 <lambdabot> No results found
10:24:50 <Cale> extendSequence that I used there is from the oeis package
10:25:12 <Cale> It looks the sequence up in the Online Encyclopedia of Integer Sequences
10:25:18 <tibbe> what do you call a monoid with a function inject :: Monoid m => a -> m
10:25:24 <tibbe> I don't know if that sentence make sense
10:25:26 <tibbe> this is what I have
10:25:30 <djfroofy> i can only find haskell jobs these days. trying to up my game a bit.
10:25:32 <tibbe> data Gather r = Gather
10:25:33 <tibbe>     { g_empty :: r
10:25:33 <Cale> tibbe: I'm not sure the type makes sense
10:25:33 <tibbe>     , g_union :: r -> r -> r
10:25:33 <tibbe>     , g_occ :: Located Name -> r
10:25:33 <tibbe>     }
10:25:49 <tibbe> Cale: so the above record looks like a monoid, except for g_occ
10:25:59 <tibbe> Cale: it has kind * -> * though
10:26:20 <sipa> > extendSequence [0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1]
10:26:21 <lambdabot>   [0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,0,0,0,0,1,...
10:26:59 <tibbe> Cale: (I'm traversing an AST, collecting Names)
10:27:21 <tibbe> Cale: I need to be able to represent the empty set of names, merge two sets of names, and note the occurrence of a name.
10:28:03 <Cale> tibbe: Well, that's definitely a monoid with some extra structure.
10:28:14 <tibbe> Cale: does it have a namy?
10:28:16 <tibbe> name*
10:28:19 <Cale> But I'm not sure that extra structure has a name
10:28:22 <tibbe> ok
10:28:28 <tibbe> @src Applicative
10:28:28 <lambdabot> class Functor f => Applicative f where
10:28:28 <lambdabot>     pure  :: a -> f a
10:28:28 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
10:28:39 <tibbe> that's not quite it either
10:28:41 <Twey> :t extendSequence
10:28:42 <lambdabot> SequenceData -> SequenceData
10:29:01 <Twey> What's this?
10:29:25 <Cale> type SequenceData = [Integer], iirc
10:29:25 <Twey> > extendSequence [0, 1, 1, 2, 3, 5]
10:29:27 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:29:38 <Twey> Is that OEIS?
10:30:02 <Cale> > extendSequence [0,1,0,1,1,1,0,3,1]
10:30:02 <geheimdienst> @hoogle extendSequence
10:30:03 <lambdabot> No results found
10:30:03 <lambdabot>   [0,1,0,1,1,1,0,3,1,3,0,2,0,1,2,0,1,2,2,0,2,3,0,4,1,3,1,4,2,1,1,1,2,3,2,3,1,...
10:30:27 <Jafet> No, it looks in the newly established #haskell logs for code that computes that sequence
10:30:27 <Cale> > describeSequence [0,1,0,1,1,1,0,3,1]
10:30:29 <lambdabot>   Just "Number of 3's in decimal expansion of 2^n."
10:30:37 <Twey> So yeah, OEIS
10:30:42 <Cale> yep
10:30:44 <Twey> Jafet: :þ
10:30:48 <sipa> Jafet: loi
10:30:59 * Twey likes sipa.
10:31:22 <geheimdienst> > extendCode (\x y -> ...)
10:31:23 <lambdabot>   <no location info>: parse error on input `...'
10:31:47 <geheimdienst> > extendCode (\x y -> {- i was thinking of a power function here, or maybe exponential -})
10:31:48 <lambdabot>   <no location info>: parse error on input `)'
10:31:53 <Twey> Haha
10:32:04 <Cale> Actually, there is an extendCode now
10:32:12 <geheimdienst> this needs work. cale, are you on it?
10:32:13 <sipa> Twey: eh, thanks, to what do i owe this dubious honor?
10:32:36 <Cale> geheimdienst: There's a recent paper on constructing a function from examples.
10:32:43 <jaspervdj> @seen Feuerbach
10:32:43 <lambdabot> Unknown command, try @list
10:32:43 <preflex>  Feuerbach was last seen on #haskell 2 days, 5 hours, 47 minutes and 37 seconds ago, saying: chrisdone: rule of thumb is you send stuff that may be piped to other programs to stdout and stuff for human to read to stderr
10:32:50 <jaspervdj> preflex: seen Feuerbach
10:32:51 <preflex>  Feuerbach was last seen on #haskell 2 days, 5 hours, 47 minutes and 45 seconds ago, saying: chrisdone: rule of thumb is you send stuff that may be piped to other programs to stdout and stuff for human to read to stderr
10:33:27 <sipa> > describeSequence [0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1]
10:33:28 <lambdabot>   Just "1 if product of odd number of primes; 0 if product of even number of ...
10:33:33 <Jafet> Cale: now all that's left is to make it a lambdabot plugin
10:33:34 <geheimdienst> sounds interesting. you often write examples anyway as unit tests or as documentation
10:33:37 <sipa> damn right...
10:33:51 <Twey> sipa: An actual adopter of ‘LOI’
10:34:12 <_linuxftw> Hi, I've got the following code in my program, http://codepad.org/26DMxEeq, It's designed to count the number of binary '1's in a ByteString. However, with a 10MB ByteString it encounters a stack overflow after 5 seconds, what can I do?
10:34:21 <Jafet> It's looking at more like a few hundred examples. Though you could still generate those as part of a test.
10:34:31 <sipa> yes, LOL is way to often a socially accepted yet deliberate lie!
10:34:35 <sipa> *too
10:35:21 <geheimdienst> i suppose if extendSequence queries OEIS, extendCode should maybe query all the source code on hackage ... or something ...
10:35:45 <sipa> or, as suggested earlier, in the #haskell logs :D
10:36:56 <_linuxftw> I think that rather than counting bits the program is spending that time building a massive massive function with 10M recursive calls, which it will later evaluate (although the stack explodes before then).
10:39:28 <tommd> preflex: seen gracenotes
10:39:29 <preflex>  gracenotes was last seen on #haskell-blah 23 hours, 12 minutes and 51 seconds ago, saying: shirtless dbag is shirtless
10:39:43 <tommd> Witty, as always.
10:40:17 <Saizan> _linuxftw: simpler than that, (+) is strict and countOnes' is not tail recursive
10:40:33 <Saizan> _linuxftw: i.e. you'd have the exact same problem with eager evaluation
10:40:41 <_linuxftw> I don't understand
10:42:02 <_linuxftw> specifically, countOnes' looks tail recursive to me, and what is the definition of "strict" in this context?
10:42:33 <jaspervdj> preflex: seen chrisdone
10:42:34 <preflex>  chrisdone was last seen on #haskell 3 hours, 54 minutes and 3 seconds ago, saying: no functorsalands today
10:42:36 <Saizan> (+) is strict in both arguments means that it requires both its argument to be evaluated before it can reduce
10:42:53 <_linuxftw> ahh I think I see now
10:43:02 <Saizan> _linuxftw: and no, it's not tail recursive because the recursive call gets used as an argument to (+)
10:43:10 <_linuxftw> yeah 
10:43:59 <_linuxftw> but, what can I do about it?
10:44:01 <Saizan> i mentioned the strictness of (+) mostly because if it were lazier you wouldn't have to worry about tail recursion
10:45:16 <Saizan> there's a fairly standard way to make countOnes' TR by using an accumulator for the partial sums
10:45:51 <_linuxftw> perhaps using B.foldl?
10:47:16 <c_wraith> foldl is folding with an accumulator, yes.
10:47:37 <_linuxftw> ok, "countOnes bs = B.foldl (\acc x -> acc + (countOnesInByte x) ) 0 bs" now runs without a stack overflow
10:47:51 <_linuxftw> thanks for the help Saizan
10:50:06 <Saizan> http://codepad.org/WQsVc7dx <- this is what'd you get by applying the standard transformation directly, but B.foldl captures this kind of recursion as a combinator so it's better :)
10:50:40 <_linuxftw> It's still extremely slow though, is there anything I can do about that?
10:50:56 <Saizan> i'd use B.foldl' though btw, for the same reason i've used $! in go
10:51:10 <_linuxftw> foldl'?
10:51:41 <Saizan> foldl' makes sure the outermost constructor is evaluated at each step
10:51:51 <_linuxftw> ok, didn't know that
10:51:54 <Saizan> which for Int means that it's completely evaluated
10:52:19 <c_wraith> I suspect that doesn't matter for the bytestring functions, though.  B.foldr is overly strict.  I bet B.foldl is, too
10:52:22 <Saizan> btw countOnesInByte seems quite slow
10:52:44 <_linuxftw> yeah, it's not a great algorithm 
10:52:59 <_linuxftw> A lookup table would be a lot faster
10:53:41 <Saizan> btw, compile with -O2 if you want speed
10:53:45 <_linuxftw> have done already
10:53:46 <luite> or __builtin_popcount :)
10:54:56 <luite> (gcc builtin, I don't know how to use it from haskell, maybe with via-C?)
11:02:09 <ozataman> Is there a simple way to turn WHNF into NF?
11:02:33 <c_wraith> only if there are no functions involved
11:02:42 <c_wraith> and only for some definitions of "simple"
11:03:42 <ozataman> c_wraith: I see. I'm struggling with making Map.insert strict. It seems that the compiler is just piling on thunks every time I do insert. I have a text-processor that does lots of inserts and I'm getting major space leaks
11:03:59 <ozataman> It finally became strict when I put a bang in front of the whole Map String String type
11:04:02 <c_wraith> Map.insert is strict in everything but the value inserted
11:04:19 <c_wraith> Is the value you're inserting based on something looked up from the map previously?
11:04:30 <c_wraith> That pattern will cause space leaks until the value is eventually forced.
11:04:40 <ozataman> Yes, that's exactly how it is
11:05:01 <c_wraith> So you only need to focus on forcing the calculation of the new value being inserted
11:05:09 <c_wraith> Not the entire map structure
11:05:23 <bblum> is there a function like List.find that returns Bool instead of Maybe a?
11:05:35 <ozataman> The map actually has type Map (String, String) (String, String, String)
11:05:53 <zygoloid> ozataman: i suspect you can reduce a function f to head normal form with: hnf f = hnf (f undefined)
11:06:33 <zygoloid> (did you mean head normal form or reduced normal form?)
11:07:00 <c_wraith> ozataman, you can fake it with rnf/deepseq, but I'd really consider using different data types that are more strict
11:07:02 <ozataman> zygoloid: I think I meant reduced normal
11:07:03 <bblum> List.any is what i'm looking for
11:07:11 <ozataman> zygoloid: fully evaluated, in other terms
11:07:28 <ozataman> c_wraith: any ideas on what I should use?
11:07:36 <zygoloid> ozataman: see the rnf function.
11:07:44 <zygoloid> @hoogle rnf
11:07:44 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
11:07:46 <ozataman> zygoloid: thank you will take a look
11:08:00 <c_wraith> ozataman, I'd consider using something like "data MyValue = MyValue !Text !Text !Text"
11:08:25 <c_wraith> Text is strict by default, and I feel like your application doesn't *want* laziness.
11:08:54 <ozataman> c_wraith: just so I understand... when Map does insert, because MyValue will actually go ahead and evaluate the 3 text fields, Map will not store the insert operation as a thunk?
11:09:09 <ozataman> c_wraith: I really don't want laziness at all :)
11:09:13 <c_wraith> ozataman, you'd need to force evaluate of the constructor somehow
11:09:15 <ozataman> c_wraith: for this application, that is
11:09:17 <c_wraith> probably with $!
11:09:39 <c_wraith> But yes, that would at least cause everything else to be evaluated when the constructor is
11:11:19 <bblum> is there a list function to substitute particular elements of a list for another? For example, I want to convert [1,2,3] to [1,10,3] with something like "substitute 10 2 list"
11:12:27 <ozataman> wow Map.insert is just so annoyingly lazy
11:13:02 <c_wraith> ozataman, it's *only* non-strict in the value being inserted.  Didn't I say this already?
11:13:27 <ozataman> c_wraith: maybe I couldn't fully grasp it.. it's only non-strict in the value being inserted as opposed to..?
11:14:12 <c_wraith> ozataman, as opposed to being non-strict in the Map or the key.
11:15:26 <ozataman> c_wraith: ok, so Map constructor is strict and will continue evaluating its fields. the key will be evaluated, the value will be left at WHNF. is that correct?
11:15:45 <c_wraith> Actually, the value will be left unevaluated entirely.
11:15:56 <c_wraith> And that's true of all values in the Map.
11:16:23 <c_wraith> But the key will be forced at least to WHNF, and possibly further, as is necessary to perform the insert
11:16:53 <c_wraith> And the Map structure itself is defined to be strict in everything but the value at the node.
11:19:57 <c_wraith> The things to consider with strictness/laziness are "when this expression is evaluated to WHNF, how far will various sub-parts be evaluated?" and "when this expression is pattern-matched on, how deeply will that force evaluation?"
11:24:26 <ozataman> c_wraith: I see, thank you for the tips. Do you know of a good resource to read on WHNF to make sure I understand all the details?
11:24:49 <c_wraith> @where denotational semantics
11:24:49 <lambdabot> I know nothing about denotational.
11:24:52 <c_wraith> drat
11:25:07 <ozataman> By force evaluating all the fields in the value, I actually got the program to stop leaking.
11:25:12 <c_wraith> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
11:25:49 <c_wraith> ozataman, it's quite possible that's all you need to do.  But check out that page for details about what strict and non-strict really mean
11:35:11 <gwern> > (200 * 60) / (58 + 15)
11:35:12 <lambdabot>   164.3835616438356
11:35:58 <Twey> > (200 * 60) / (58 + 15) :: CReal
11:35:59 <lambdabot>   164.3835616438356164383561643835616438356164
11:39:15 <gwern> > 3000 / 135
11:39:16 <lambdabot>   22.22222222222222
11:45:35 <gwern> > 10000 / (15+18)
11:45:36 <lambdabot>   303.030303030303
11:45:50 <gwern> > 10000 / (15+118)
11:45:51 <lambdabot>   75.18796992481202
11:51:11 <dafis> > fromRational (toRational (1.7941874726521824e-40 :: Double)) :: Float
11:51:12 <lambdabot>   1.79418e-40
11:52:09 <dafis> > fromRational (toRational (1.79418e-40 :: Float)) :: Double
11:52:10 <lambdabot>   1.794180514767566e-40
11:58:20 <gwern> > 3000 / (88+8)
11:58:20 <gwern> > (200*100) / (88+8)
11:58:20 <gwern> > (100*100) / (60+8)
11:58:21 <lambdabot>   31.25
11:58:21 <lambdabot>   208.33333333333334
11:58:21 <lambdabot>   147.05882352941177
12:05:13 <tibbe> @src unzip
12:05:13 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
12:05:46 <c_wraith> that ~ is interesting.
12:06:00 <dafis> c_wraith: it's necesary
12:06:07 <dafis> necessary
12:06:09 <c_wraith> For infinite lists?
12:06:13 <dafis> yep
12:06:16 <c_wraith> makes sense
12:06:28 <dafis> and for efficiency if the list is merely long
12:09:52 <Ziphilt> what does the tilde mean in that context?
12:09:58 <sclv_> lazy pattern patch
12:10:05 <sclv_> erm match
12:10:05 <Ziphilt> ah
12:10:40 <Ziphilt> is that part of one of those Regex packages?
12:10:48 <Ziphilt> or modules
12:10:53 <dafis> No, H98 syntax
12:11:58 <Ziphilt> is that a function, or just sugar?
12:12:30 <dafis> sugar
12:12:39 <Ziphilt> okay then
12:12:56 <Ziphilt> is that just the way to do matching in an anonymous function?
12:13:06 <dafis> for fun x = let (u,v) = x in ... etc
12:13:28 <dafis> Ziphilt: anywhere you need a lazy match
12:13:44 <Ziphilt> i am not sure what you mean by lazy match
12:13:57 <dafis> it's more convenient than matching against a variable name and decomposing that in a let
12:14:30 <dafis> Ziphilt: don't evaluate to WHNF on binding, suppose that succeeds, bind later
12:14:53 <Ziphilt> that confuses me more
12:15:01 <Ziphilt> i have not read that much into haskell
12:15:22 <Ziphilt> i recently got Real World Haskell, though, and it is up on my reading list
12:15:52 <dafis> Ziphilt: okay, then read that, I think it's explained there
12:15:56 <Twey> Ziphilt: Instead of trying to match the pattern there, just assume it matches, and if it's used somewhere in the body of the function and it *doesn't* match, throw an error.
12:16:13 <Ziphilt> twey, that is sort of understandable now, thanks
12:17:09 <dafis> 666, any numerologists on board?
12:17:26 <dafis> and that moment someone leaves :(
12:17:35 <Twey> ☺
12:30:42 <xDie> hello
12:30:54 <dafis> hello
12:31:02 <xDie> any can join lambdabot in #elhacker.net
12:31:14 <xDie> how demostrative session
12:33:32 <xDie> xD
12:33:37 <D4N93R> Hai all
12:33:42 * Twey gives Cale a prod.
12:33:50 <RauuL-338> Ni Hau
12:33:54 <D4N93R> whats haskell?
12:33:54 <xDie> dafis, whats is lambdabot admin
12:34:01 <xDie> @slap D4N93R 
12:34:01 * lambdabot loves D4N93R , so no slapping
12:34:07 <D4N93R> :D
12:34:12 <D4N93R> he loves me :D
12:34:13 <xDie> D4N93R++
12:34:18 <xDie> @karma D4N93R 
12:34:19 <lambdabot> D4N93R has a karma of 1
12:34:21 <D4N93R> xDie, +1
12:34:30 <D4N93R> lambdabot, 
12:34:32 <xDie> @krema xDie
12:34:32 <lambdabot> You have a karma of -1
12:34:34 <D4N93R> lambdabot help
12:34:35 <xDie> jaja
12:34:39 <xDie> @help
12:34:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:34:43 <D4N93R> ah!
12:34:45 <D4N93R> awesome
12:34:49 <D4N93R> @list
12:34:50 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:34:56 <xDie> @> 4.4 / 4
12:34:56 <lambdabot> Maybe you meant: . ? @ v
12:35:00 <xDie> > 4.4 / 4
12:35:01 <lambdabot>   1.1
12:35:02 <D4N93R> bianc4 is better JUM
12:35:03 <dafis> @botsnack
12:35:04 <lambdabot> :)
12:35:07 <xDie> jaja
12:35:13 <xDie> @messages
12:35:14 <lambdabot> You don't have any new messages.
12:35:21 <Nibble> > filter (isUpper) "HAI I CAN HAZ FORCEFIELD"
12:35:22 <lambdabot>   "HAIICANHAZFORCEFIELD"
12:35:26 <dschoepe> xDie: the admins are listed here: http://code.haskell.org/lambdabot/online.rc
12:35:26 <xDie> @remember No todo lo que es hora brilla
12:35:26 <lambdabot> It is stored.
12:35:26 <Nibble> coincidence? I think not.
12:35:32 <D4N93R> @hoogle
12:35:32 <lambdabot> No query entered
12:35:32 <lambdabot> Try --help for command line options
12:35:35 <D4N93R> @hoogle test
12:35:36 <lambdabot> Test.HUnit.Base test :: Testable t => t -> Test
12:35:36 <lambdabot> Test.HUnit.Base data Test
12:35:36 <lambdabot> Test.QuickCheck class Testable a
12:35:39 <xDie> @quota remember
12:35:40 <lambdabot> remember says: the 5th of november
12:35:46 <xDie> @quota brilla
12:35:46 <lambdabot> No says: todo lo que es hora brilla
12:35:48 <D4N93R> @hoogle xDie 
12:35:48 <lambdabot> No results found
12:35:56 <xDie> thanks dschoepe 
12:36:04 <D4N93R> @hoogle el blog de juan
12:36:04 <lambdabot> No results found
12:36:07 <D4N93R> danm
12:36:09 <D4N93R> xD
12:36:24 <D4N93R> @search C Sharp
12:36:24 <lambdabot> Unknown command, try @list
12:36:33 <D4N93R> @search google C Sharp
12:36:34 <lambdabot> Unknown command, try @list
12:36:39 <D4N93R> @search help
12:36:39 <lambdabot> Unknown command, try @list
12:36:45 <D4N93R> @help search
12:36:45 <lambdabot> search provides: gwiki google wikipedia gsite
12:36:47 <donri> @google for stuff
12:36:49 <lambdabot> http://www.partyben.com/
12:36:49 <lambdabot> Title: Party Ben - Root for Stuff
12:36:56 <D4N93R> :O
12:37:07 <D4N93R> @wikipedia irc
12:37:08 <lambdabot> http://wikimediafoundation.org/wiki/Special:Search?search=irc
12:37:11 <D4N93R> :D
12:37:11 <gwern> spam through google buzz. how odd
12:37:13 <[Zero]> :O
12:37:20 <xDie> ahi le mande un privado
12:37:23 <xDie> a dons
12:37:27 <xDie> @google 
12:37:27 <lambdabot> Empty search.
12:37:29 <[Zero]> i want a bianc4 like these XD
12:37:30 <xDie> @g
12:37:30 <lambdabot> Maybe you meant: gazetteer get-shapr ghc girl19 google googleit gsite gwiki . ? @ v
12:37:31 <Botje> D4N93R: you can also /msg lambdabot 
12:37:36 <D4N93R> nice
12:37:56 <D4N93R> @spell CSHARP
12:37:58 <D4N93R> xD
12:38:01 <D4N93R> doesnt work
12:38:21 <D4N93R> @tell wtf!
12:38:22 <lambdabot> Consider it noted.
12:38:23 <D4N93R> xD
12:38:32 <D4N93R> @tell
12:38:32 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
12:38:35 <D4N93R> :o
12:38:38 <D4N93R> failed 
12:38:38 <D4N93R> xD
12:38:49 <D4N93R> @tell testing
12:38:50 <lambdabot> Consider it noted.
12:38:52 <D4N93R> @tell testing
12:38:52 <lambdabot> Consider it noted.
12:38:54 <D4N93R> uhm
12:39:07 <D4N93R> @dice
12:39:07 <lambdabot> unexpected end of input: expecting number
12:39:10 <D4N93R> @dice 8
12:39:10 <lambdabot> 8 => 8
12:39:13 <D4N93R> @dice 5
12:39:13 <lambdabot> 5 => 5
12:39:15 <D4N93R> >_>
12:39:18 <D4N93R> @dice 8 2
12:39:18 <lambdabot> 8 2 => 82
12:39:18 <Twey> @tell D4N93R Please experiment with the bot in a private message.
12:39:19 <lambdabot> Consider it noted.
12:39:33 <D4N93R> LOL
12:39:33 <lambdabot> D4N93R: You have 1 new message. '/msg lambdabot @messages' to read it.
12:39:38 <D4N93R> wesome
12:39:39 <D4N93R> xD
12:40:06 <D4N93R> huhuhu
12:40:39 <D4N93R> this is boring,, the bot is cool , but the help lacks on.. bb
12:41:02 <Botje> thanks for the drive-by!
12:47:53 <BONUS> i am back from my underground cave ... light hurts eyes
12:47:56 <BONUS> new lyah chapter .... out
12:49:46 <BONUS> http://www.reddit.com/r/programming/comments/dn8nn/learn_you_a_haskell_for_a_few_monads_more/
12:49:50 <BONUS> comments appreciated
12:50:26 <fryguybob> BONUS: I wan't that pancho!
12:51:08 <sinelaw> BONUS, looks impressive, i'll go over it sometime
12:51:11 <sinelaw> :)
12:51:21 <BONUS> haha cool
12:54:45 <zygoloid> BONUS: have you already introduced bytestrings by this point?
12:55:19 <BONUS> zygoloid: yeah, briefly in the I/O chapter
12:57:15 <Heffalump> BONUS: comment on LYAH's depiction of quicksort here: http://www.reddit.com/r/coding/comments/dkzp0/haskell_at_google_for_the_hard_problems_in_the/c116zjd
12:58:15 <zygoloid> BONUS: when you give the instance Monad (Writer w), you introduce it as "Its Monoid instance" not "Its Monad instance"
12:58:27 <BONUS> really? ogwggww i'll fix that
12:58:43 <BONUS> Heffalump: thank's i'll look over that
12:59:23 <troutwine> I'm trying to implement Prim's algorithm but I don't know the ST monad very well and am failing hard: http://gist.github.com/612218
12:59:35 <troutwine> Would someone be so kind as to hold my hand?
12:59:51 <troutwine> Metaphorically, of course. 
13:01:50 <zygoloid> BONUS: that was the clearest, simplest explanation of why Writer [a] is inefficient i've ever seen :)
13:02:06 <BONUS> thanks :)
13:02:57 <BONUS> i dont really get this whole quicksort is not quicksort if it's not in-place
13:03:04 <BONUS> thing
13:03:34 <dafis> troutwine: metaphorically, you call build with only two params instead fo three in the recursion
13:03:35 <shapr> dark: You're not Richard Braakman, right?
13:03:45 <dark> no i'm not :)
13:03:47 <shapr> I think I ask that every few months :-/
13:03:51 <dark> i'm what /whois says
13:04:00 <tommd>   /whois says
13:04:01 <tommd> ;-)
13:04:02 <dark> shapr, is this an inside joke?
13:04:04 <shapr> Ok, just checking, thanks.
13:04:15 <troutwine> dafis: D'oh!
13:04:34 <shapr> dark: No, it's just that in the early days of #haskell, Richard Braakman was a prolific Haskeller, and he showed up on #haskell as <dark>, so I keep thinking you're him.
13:04:53 <shapr> Same for me getting bremner confused with dbremner
13:04:55 <dark> ah.. too bad i took his nick then
13:05:03 <zygoloid> BONUS: quicksort, by its definition, is an in-place array sorting algorithm. if you're not sorting an array in place, you're not using quicksort. simple as that.
13:05:07 <shapr> Is okay, wabi-sabi is a good principle.
13:05:27 <dark> .. anyway, what's the big difference between hdbc 2.1.1 and 2.2.6.1? gentoo-haskell overlay has only 2.1.1, is this too old?
13:05:42 <Heffalump> zygoloid: I think that's ambiguous, personally. But people (and not just jdh, though perhaps whipped up by him) seem to treat it as evidence that we like misleading people.
13:06:17 <BONUS> hmm
13:06:29 <dark> it looks like 2.2.6 has some locale thing
13:06:39 <BONUS> did Hoare publish quicksort in a paper?
13:06:42 <zygoloid> Heffalump: i disagree. part of the cunningness of quicksort is how you do it in-place with a minimal number of passes. that's what makes it a description of an algorithm rather than just a vague notion of how to sort by divide-and-conquer
13:06:51 <dark> not sure if this is relevant if all my data is and always will be in utf-8
13:07:00 <Heffalump> BONUS: yes
13:07:36 <BONUS> which paper 
13:07:46 <BONUS> looking at the references in wikipedia but i cant find it
13:08:03 <zygoloid> http://comjnl.oupjournals.org/cgi/doi/10.1093/comjnl/5.1.10
13:09:09 <c_wraith> BONUS, the stackManip function seems to be lacking an "in"
13:09:09 <zygoloid> iirc, jon bentley in programming pearls notes that the first /correct/ quicksort implementation wasn't published until the 1970s
13:09:26 <geheimdienst> zygoloid: no that's not relevant, "sorting in the random-access store of a computer". i have only ram, sorry ;)
13:09:41 <Botje> @pl \x y -> x + y^2
13:09:42 <lambdabot> (. (^ 2)) . (+)
13:09:46 <Botje> @pl \x y -> x^2 + y
13:09:46 <lambdabot> (+) . (^ 2)
13:09:48 <zygoloid> haha, even wikipedia gets the pivoting code wrong
13:10:30 <zygoloid> geheimdienst: the algorithm we haskellers call quicksort is not the algorithm in that paper.
13:12:48 <geheimdienst> zygoloid: just outta curiosity, where is the WP problem with "pivoting code"?
13:13:06 <geheimdienst> you mean that left + (...) could overflow ...?
13:14:48 <sinelaw> what's the difference between vector and storable vector?
13:15:14 <dstcruz> anyone know of an HtmlString -> NonHtmlString function somewhere?
13:15:27 <c_wraith> BONUS, "So we start of with the State newtype wrapper" I think that should be "...start off..." in there
13:15:36 <BONUS> ah, nice one
13:16:14 <BONUS> fixed
13:17:43 <c_wraith> BONUS, the first definition of stackManip is still not syntactically correct
13:18:01 <c_wraith> I think you want an "in" on the last line
13:18:14 <BONUS> oh yeah
13:18:20 <BONUS> let me fix that
13:19:23 <zygoloid> geheimdienst: yeah, (left + right) / 2 should be left + (right - left) / 2.
13:19:48 <Twey> o.@
13:19:55 <Twey> Isn't that right / 2?
13:20:06 <Twey> Oh, wait, no
13:20:09 <Twey> Never mind
13:20:22 <zygoloid> geheimdienst: i'm amused to see that wikipedia mentions this bug RIGHT BEFORE it gives a 'correct' example containing it!
13:23:30 <geheimdienst> if you ask me, that paragraph discussing overflow relates to the code above it. then out of the blue, somebody writes "another implementation that works in place" and wedges it into the article sideways. the code isn't discussed anywhere afaict and seems unconnected to the text before and after it ...
13:23:53 <Cale> dstcruz: ?
13:24:02 <geheimdienst> it's not meant as "and here's how to fix it:", is what i'm sayin'
13:24:06 <Cale> dstcruz: which package are those types from?
13:24:51 <Cale> dstcruz: Or you just want something which parses html and collects out all the actual text
13:25:43 <Cale> dstcruz: The TagSoup package would work pretty well for that, I suspect. (Though you might have to be careful about scripts.)
13:26:45 * hackagebot yesod-auth 0.1.0 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.1.0 (MichaelSnoyman)
13:27:04 <sinelaw> how do i know the length of a storable vector?
13:27:39 <Cale> Data.StorableVector.length?
13:27:40 <fryguybob> BONUS: in the 4th paragraph of Reader section there is an extra space in " (- >) r a "
13:28:30 <BONUS> nice catch
13:28:31 <sinelaw> nvm
13:28:35 <sinelaw> Cale, yeah
13:29:39 <BONUS> fixed. yeah, there arent any good examples for the reader monad since non-transformer Reader is kinda useless :[
13:30:43 <c_wraith> I don't know if anyone would be hurt if you just left out the Reader monad until you want to talk about transformers.
13:31:20 <McManiaC> is there a cabal CPP flag for the current package version?
13:31:53 <dcoutts> McManiaC: no but there's a Haskell value of type Version for it
13:32:09 <dcoutts> McManiaC: in a module generated by Cabal
13:32:34 <c_wraith> BONUS: "Floating point numbers can get real messy real fast because they tend to lose precision, so Haskell offers us a data type for real numbers that doesn't lose precision" <- Should you use a word other than "real" there, as well, it is just the rationals, and not all reals?
13:33:24 <BONUS> yeah, i should 
13:33:43 <McManiaC> dcoutts: how do you use this?
13:33:56 <dcoutts> McManiaC: import the module, use the value
13:34:02 <b52> i created a package i build using cabal and i would like to use the version i specify in the cabal file in the source file
13:34:32 <dafis> I think cabal defines a macro for the version
13:34:38 <dcoutts> b52: I refer you to the reply I gave some moments ago to McManiaC 
13:34:40 <Botje> @pl \a b c -> f a b (g c)
13:34:41 <lambdabot> flip flip g . ((.) .) . f
13:34:46 <Botje> ew, scary
13:34:46 <dcoutts> dafis: no, it's a value, not a macro
13:34:52 <aleator> dcoutts: (Bit high latency here). Yeah, checking .h file is great and if the error message has gotten better, I'm happy.
13:34:59 <Botje> @pl \a c -> f a (g c)
13:34:59 <lambdabot> (. g) . f
13:35:03 <dcoutts> aleator: ok great
13:35:05 <McManiaC> dcoutts: http://haskell.org/cabal/release/cabal-latest/doc/API/Cabal/Distribution-Version.html this one?
13:35:06 <Botje> that looks a bit more sane
13:35:35 <dcoutts> McManiaC: well, it's the same type, but you just import the module called Paths_<your-pkg-name-here>
13:36:05 <dcoutts> McManiaC: and it exports a value called version :: Data.Version.Version
13:36:19 <dcoutts> (along with other functions for finding files at runtime)
13:36:30 <dcoutts> b52: ^^
13:36:51 <b52> :>
13:36:54 <McManiaC> dcoutts: ok cool
13:37:12 <Botje> @pl \z y -> f z + y
13:37:12 <lambdabot> (+) . f
13:37:16 <Botje> excellent.
13:42:17 <McManiaC> dcoutts: thanks, it works :)
13:42:44 <dcoutts> @arr!
13:42:45 <lambdabot> Arrr!
13:42:51 <McManiaC> hehe
13:42:54 <kmm> wat?
13:42:59 <kmm> @arr!
13:42:59 <lambdabot> Keelhaul the swabs!
13:43:11 <kmm> Sounds usefull
13:43:41 <troutwine> I think your ship's deck will get awfully dirty if you keep killing the deck swabbers.
13:43:55 <troutwine> What do I know though? Clearly lambdabot is the better pirate.
13:52:38 <sinelaw> @pl (\x y -> f (g x y))
13:52:39 <lambdabot> (f .) . g
13:52:46 <sinelaw> :(
13:53:07 <benmachine> f . g x?
13:53:41 <sinelaw> wanted point less
13:54:08 <dafis> @pl \f g x y -> f (g x y)
13:54:08 <lambdabot> (.) . (.)
13:54:14 <kmc> that's one of the most-desired missing combinators
13:54:16 <dafis> pointless enough?
13:54:17 <McManiaC> hrhr
13:54:31 <sinelaw> heh
13:55:10 <sinelaw> @pl \x y -> f (g x) (g y)
13:55:10 <lambdabot> (. g) . f . g
13:55:36 <dafis> :t on
13:55:37 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:56:09 <dafis> sinelaw: f `on` g
13:57:08 <sinelaw> thanks dafis 
13:57:13 <sinelaw> @hoogle on
13:57:14 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:57:14 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
13:57:14 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
14:10:58 * hackagebot xilinx-lava 5.0.1.2 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.1.2 (SatnamSingh)
14:15:07 <sinelaw> ooh lava is active
14:16:05 * hackagebot hakismet 0.1 - Akismet spam protection library  http://hackage.haskell.org/package/hakismet-0.1 (NilsSchweinsberg)
14:22:08 * hackagebot ecu 0.0.4 - Tools for automotive ECU development.  http://hackage.haskell.org/package/ecu-0.0.4 (TomHawkins)
14:24:27 <dstcruz> Cale: Ah, did not think to look into TagSoup, thanks
14:27:32 <djahandarie> byorgey, really neat stuff you're working on. :-)
14:36:40 <sinelaw> djahandarie, what is he working on/
14:38:50 <djahandarie> sinelaw, making Haskell's type system more powerful. With his work we can have stuff a little more like dependently-typed languages (without actually having dependent types).
14:39:21 <sinelaw> i've been shying from planet.haskell for a while... maybe I should read some :)
14:39:31 <djahandarie> Are you familiar with Vec and vappend?
14:39:33 <mike-burns> BONUS: For the past, I dunno, year, I've been half-heartedly trying to understand the Writer type. I just read your "For a Few Monads More" and understand it now. Thanks!
14:40:22 <sinelaw> djahandarie, no, why
14:40:50 <djahandarie> Because then it's pretty easy to motivate why his work is important
14:41:20 <djahandarie> Vec is basically a list where you keep track of its length at the type-level
14:41:40 <benmachine> I tried making one of those
14:41:44 <benmachine> I could never really get it to work
14:41:48 <dschoepe> sinelaw: http://vimeo.com/15480577 -- here's the video about it
14:41:48 <djahandarie> Haskell can do it with type families
14:41:59 <djahandarie> Oh damn there is a video?
14:42:01 <djahandarie> Heh
14:42:35 <djahandarie> But with type families you can't do it as nicely as a depedently-typed language can
14:42:39 <sinelaw> djahandarie, thanks, i'll add that to my read / view list
14:42:48 <djahandarie> Since you end up getting Vec :: * -> * -> *
14:43:05 <djahandarie> Rather than something more expressive like Vec :: Nat -> * -> *
14:43:17 <djahandarie> The way byorgey solves it is really neat
14:43:34 <sinelaw> how?
14:44:03 <dschoepe> By allowing ordinary value constructors in types.
14:44:10 <dschoepe> or rather, kinds
14:44:21 <benmachine> djahandarie: yeah, I always just failed to define any like useful functions on it
14:44:24 <benmachine> liek take
14:44:24 <benmachine> or etc.
14:44:27 <benmachine> or drop
14:44:36 <benmachine> because you need a value to jump into the type system
14:45:21 <djahandarie> sinelaw, in a dependently-typed language, all the 'levels' are combined... that is, for example, you can use functions on both values and types
14:45:50 <djahandarie> sinelaw, but if we were to collapse all the levels down like that in Haskell, it'd basically become dependetly-typed and we'd get a bunch of problems (erasure analysis, etc)
14:46:25 <djahandarie> sinelaw, (because right now types are at compile-time and values are at run-time and are entirely seperate, so you can completely erase the types after compile)
14:46:41 <benmachine> dependently-typed languages also have inference issues
14:46:59 <djahandarie> sinelaw, (while if the levels were all one, you would need to determine what types you can erase and which you can't)
14:47:26 <sinelaw> hmm
14:47:30 <djahandarie> Anyways, his solution was rather than collapsing all the levels, combine the type and kind level
14:48:12 <djahandarie> So, when you write a data constructor like    data Nat a = Zero | Succ a,  you automatically get a lifted version of that on the kind level
14:48:43 <sinelaw> what do you mean by that
14:49:46 <dschoepe> sinelaw: that way you could have a value of type Vec (Succ Zero) a, where Succ is just the ordinary data constructor instead of a "normal" type.
14:50:03 <djahandarie> Basically you would normally need to write    data Zero   and   data Succ a   as seperate data types to use them on the type level
14:50:04 <sinelaw> ah
14:50:12 <djahandarie> But they would both be of kind *
14:50:21 <djahandarie> Rather than grouped together under a kind 'Nat'
14:50:49 <djahandarie> But if data constructors are lifted automatically we would get that for free
14:51:21 <djahandarie> Allowing you to have more expressive kinds like   Nat -> * -> *    for Vecs
14:51:35 <sinelaw> i'll watch the talk
14:51:38 <djahandarie> (Nat standing for Natural btw)
14:51:43 <djahandarie> So will I :P
14:52:01 <sinelaw> ...but not now :)
14:53:31 <djahandarie> Just realized I defined Nat incorrectly lol
14:53:35 <djahandarie> data Nat = Zero | Succ Nat
14:54:53 <copumpkin> how had you done it before?
14:55:24 <djahandarie> data Nat a = Zero | Succ a
14:55:47 <djahandarie> Was thinking   data Succ n   while I wrote it 
14:57:22 <djahandarie> What would be really neat is lifting value-level functions to the type-level
14:57:30 <djahandarie> I wish I knew GHC well enough to try and hack at it
14:57:39 <BONUS> mike-burns: cool, glad you liked it! :)
14:58:15 <res> cabal install yi
14:58:33 <djahandarie> Error: screw you, I won't install anything!
14:58:41 <sinelaw> why is storable vector's 'drop' so slow?
14:59:08 <copumpkin> sinelaw: it should be constant time?
14:59:15 <copumpkin> if you mean Data.Vector.Storable?
14:59:18 <sinelaw> yes
14:59:21 <copumpkin> or do you mean storablevector?
14:59:34 <codemac> Does anyone know what Lighthouse/House/hOp is licensed as?
14:59:50 <sinelaw> err now I'm confused
15:00:00 <copumpkin> @hackage storablevector
15:00:00 <lambdabot> http://hackage.haskell.org/package/storablevector
15:00:02 <copumpkin> @hackage vector
15:00:03 <lambdabot> http://hackage.haskell.org/package/vector
15:00:06 <sinelaw> Data.StorableVector
15:00:11 <sinelaw> copumpkin, yeah the first
15:00:16 <copumpkin> go with the second :P
15:00:24 <sinelaw> ok....why? :)
15:00:35 <ddarius> !cr3
15:00:43 <sipa> djahandarie: lifting value-level functions to the type level, that's dependent types, no?
15:00:49 <copumpkin> sinelaw: "e do not provide advanced fusion optimization, since especially for lazy vectors this would either be incorrect or not applicable. For fusion see http://hackage.haskell.org/cgi-bin/hackage-scripts/package/storablevector-streamfusion."
15:01:05 <Entroacceptor> ~[6~[6~[6~[6~[6~
15:01:05 <lambdabot> Entroacceptor: You have 1 new message. '/msg lambdabot @messages' to read it.
15:01:09 <djahandarie> sipa, I don't think so.
15:01:17 <copumpkin> sinelaw: but if you really want to use it, I'm still not sure why drop is so slow
15:01:26 <copumpkin> it should still be O(1) on anything reasonable, unless it's a mutable one
15:01:31 <sipa> not exactly probably, i don't know too much about dependent types
15:01:43 <sinelaw> that's why i'm surprised. probably something else going slow here
15:01:45 <copumpkin> it isn't dependent types
15:02:04 <copumpkin> but it gives you more facilities for easier type-level programming
15:02:31 <djahandarie> I don't think it would be impossible
15:02:37 <djahandarie> Maybe not for all functions
15:02:39 <djahandarie> But a lot of them
15:02:47 <Entroacceptor> sclv: wow, thank you!
15:02:51 <copumpkin> djahandarie: ?
15:03:03 <djahandarie> copumpkin, to automatically lift value-level functions to the type-level
15:03:04 <Entroacceptor> that gave me back 5 sanity points
15:03:21 <djahandarie> copumpkin, I'm thinking of termination here
15:03:27 <copumpkin> djahandarie: hmm, it gets tricky
15:07:41 <sinelaw> @pl \f g x y -> (f (fst (g x y)) (snd (g x y))
15:07:41 <lambdabot> (line 1, column 43):
15:07:41 <lambdabot> unexpected end of input
15:07:41 <lambdabot> expecting variable, "(", operator or ")"
15:07:46 <sinelaw> @pl \f g x y -> (f (fst (g x y)) (snd (g x y)))
15:07:46 <lambdabot> (`ap` ((snd .) .)) . (liftM2 ap .) . (. ((fst .) .)) . (.) . (.)
15:07:48 <sinelaw> bah
15:08:08 <sinelaw> @pl \x y -> (f (fst (g x y)) (snd (g x y)))
15:08:08 <lambdabot> ap (ap . ((f . fst) .) . g) ((snd .) . g)
15:09:41 <cads> hey, is russel
15:09:53 <cads> 's type theory a type theory in the sense of what we're used to
15:10:05 <cads> with the typed lambda calculus and things like haskell, etc?
15:10:09 <shapr> Dammit, Crypto-4.2.1 has Arbitrary instances for Word64, and so does the latest QuickCheck! Argh!
15:10:16 <shapr> Thus cabal install Crypto fails.
15:10:18 <sipa> djahandarie: wait, give an example - how would you lift the value-level function (+2)::(Int -> Int) to the type level?
15:10:36 <limetree> i wasn't able to think of a proper place to ask this, but has anyone tried to do the icfp 06 contest recently? i just can't get the extracted umix to work. i found an already extracted one that works fine.
15:10:38 <copumpkin> damn, orphan instances in a released package?
15:10:44 <copumpkin> @hackage Crypto
15:10:44 <lambdabot> http://hackage.haskell.org/package/Crypto
15:10:59 <copumpkin> shapr: maybe email the maintainer?
15:11:04 <dolio> cads: No. It was set theory, I think.
15:11:06 <copumpkin> or ping him on twitter since he's quite active :)
15:11:34 <shapr> copumpkin: I think the problem is with QuickCheck, it shouldn't export Arbitrary instances by default.
15:11:43 * shapr thinks about that
15:11:47 <copumpkin> you can't not export instances
15:11:54 <copumpkin> unless you stick them in a separate module
15:11:57 <shapr> right
15:12:02 <copumpkin> but if anywhere should have instances for standard types
15:12:05 <copumpkin> it's the quickcheck module
15:12:16 <shapr> Hm, so it may actually be a bug in the Crypto module...
15:12:22 <copumpkin> I'd consider it one
15:12:32 <copumpkin> GHC will issue an orphan instance warning
15:12:32 <djahandarie> sipa, type family PlusTwo (m::Nat) :: Nat; type instance PlusTwo n = S (S n)) 
15:12:47 <shapr> preflex: seen wchogg
15:12:48 <preflex>  wchogg was last seen on #haskell 1 year, 20 hours, 53 minutes and 40 seconds ago, saying: Gracenotes:  That is still so damn weird
15:12:52 <shapr> whaat?
15:13:00 <copumpkin> shapr: the most recent tweet on my twitter timeline is by wchogg :)
15:13:15 <djahandarie> sipa, not sure about the Int stuff but that's how I would do it if the function were defined over Nat
15:13:28 <cads> dolio, I found a little here http://en.wikipedia.org/wiki/Type_theory#1900_-_1927
15:13:33 <sipa> djahandarie: sure, close enough
15:13:37 <cads> I think I'll look up russel's original papers
15:13:47 <copumpkin> djahandarie: the question is
15:14:04 <copumpkin> are both (2+) and (+2) lifted that way? :P
15:14:05 <dolio> cads: I mean, lambda calculus wasn't invented until the 30s, as I recall.
15:14:25 <djahandarie> copumpkin, well.. uh... don't ask hard questions :P
15:14:29 <cads> hey, do you guys think we could create distributed independent twitter agents that would twitter together like a neural network?
15:14:38 <dolio> And set theory was presumably what he was working on at the time.
15:14:56 <cads> dolio, it was an answer to a flaw in naive set theory axiomatizations
15:15:01 <dcoutts> djahandarie: did you see that your hackage mockup was presented at the implementors workshop the other day?
15:15:03 <dolio> Right.
15:15:12 <cads> I guess he'd been working in sets up till then
15:15:41 <cads> it seems like his type theory had to answer to some criticism itself
15:15:55 <sipa> lambda calculus is older than the turing machine :)
15:16:28 <djahandarie> dcoutts, yes indeed, Gracenotes showed it to me. I have HTML mockups of it now, just they aren't finished yet
15:16:59 <dcoutts> djahandarie: great
15:17:01 <cads> lol, I wonder what other kinds of computing machine, perhaps more abstract, perhaps more simple from a modern perspective, might have been used instead of turing machines
15:17:18 <res> http://sprunge.us/McDA explain this?
15:17:19 <cads> and whether that would change at all the way in which we understand computing
15:17:21 <danharaj> there are all sorts of abstractions of computing machines that have theoretical merit.
15:17:32 <djahandarie> It's hard juggling around 1. learning stuff 2. "learning" stuff for school and 3. a bunch of projects I'm committed to :P
15:17:33 <dcoutts> djahandarie: you might like to ask on haskell-cafe for people to help you, e.g. by exploring different designs of information presentation
15:17:56 <dcoutts> djahandarie: a small team, e.g. 2-3 is often ideal
15:18:06 <res> if multiple things require the same version, how is that a version conflict?
15:18:10 <cads> danharaj, for lambda calculi things like graph reduction systems come to mind
15:18:13 <djahandarie> It'd be real nice if 1 & 2 aligned but they don't... yet...
15:18:19 <djahandarie> And yeah, I'll do that
15:18:25 <danharaj> register machines, tag systems, stack automata...
15:18:29 <danharaj> I can't name any more.
15:18:40 <djahandarie> I liked the suggestions at the end of Gracenotes' presentation a lot
15:18:48 <djahandarie> suggestions/discussion
15:19:23 <res> http://sprunge.us/McDA this doesn't make much sense to me
15:19:34 <sinelaw> copumpkin, my bad. the code i'm running around the 'drop' is slow, not the drop itself
15:19:38 <copumpkin> :)
15:19:47 <copumpkin> sinelaw: I'd still recommend vector over storablevector
15:19:53 <copumpkin> it should be almost a drop-in replacement
15:20:07 <sinelaw> i just calculated that for the whole program to run it would need to execute 7.5 teraflops
15:20:16 <dolio> cads: Yeah, Russel's type theory has issues, although I don't really know enough to say what they are.
15:20:34 <danharaj> the fact that it takes a hundred pages to prove 1 + 1 = 2? :)
15:20:51 <dolio> cads: I believe the real numbers are scattered into many sets at different places in the hierarchy, for instance.
15:21:18 <dolio> So you have level 1 real numbers, and level 2 real numbers which can use level 1 real numbers in their definitions, and so on.
15:21:42 <Blkt> good night everyone
15:24:44 <Cale> res: You might have two different builds of Cabal-1.8.0.6 somehow.
15:25:07 <res> ...how in the world does that work?
15:25:09 <Cale> res: Take a look at the output of ghc-pkg list Cabal, and make sure that it's not listed twice.
15:25:30 <Cale> Well, for starters, there's a global and user package context.
15:25:43 <Cale> So it might be installed in both places.
15:26:11 <Cale> That error message does indeed suck though.
15:26:30 <res> Cale: it was listed twice
15:26:38 <res> unregistering it once seems to work?
15:26:48 <res> I probably broke things, but I guess I'll have to reinstall that later
15:27:36 <cads> dolio, it looks like he formulated it in one paper and then never really wrote about it again himself
15:27:43 <dolio> Heh.
15:27:47 <Cale> okay, that's probably all right... the global one is the one you'd probably want to leave alone. I recommend not touching your global packages ever, and installing things as user.
15:27:50 <cads> church and others wrote about it years later
15:28:02 <cads> but it did solve russell's antimony
15:28:32 <dolio> Of course. It was totally predicative, I think.
15:28:47 <res> Cale: I'll just see how long my setup continues to work
15:29:22 <Cale> res: do a ghc-pkg check
15:29:40 <Cale> res: probably at least one of your packages depends on the Cabal that you unregistered and will have to be reinstalled
15:29:43 <dolio> Which is, as far as anyone has been able to tell, kind of an overreaction.
15:29:44 <res> no output and returns 0
15:29:51 <Cale> oh, well, good then
15:30:06 <Cale> (but weird!)
15:30:13 <Cale> Oh, I see...
15:30:32 <Cale> yi, the package which you were installing, foolishly decided to use the Cabal that nothing else was using
15:30:47 <res> ...
15:30:58 <res> okay, so now I have a working yi!
15:31:02 <res> does it have docs?
15:31:04 <dolio> cads: Actually, I think he amended it later (or maybe he'd amended it by the time he released it) to include some impredicative fixes.
15:31:21 <Cale> I'm not sure how well documented it is now
15:31:27 <dolio> Like, "anything you can define in higher levels induces a set in the lowest level" or something.
15:31:41 <dolio> Which solves the problem with the reals, I think.
15:31:58 <cads> yeah, I read about his 4 point plan
15:32:04 <cads> 1. abandon type theory
15:32:15 <cads> etc. :)
15:34:08 <cads> "Willard Quine in his preface to Russell's (1908a) Mathematical logic as based on the theory of types[11] presents a historical synopsis of the origin of the theory of types and the "ramified" theory of types: Russell proposed in turn a number of alternatives: (i) abandoning the theory of types (1905) followed by three theories in 1905: (ii.1) the zigzag theory, (ii.2) theory of limitation of size, (ii.3) the no-class theory (1905–1906)
15:34:08 <cads> , then (iii) readopting the theory of types (1908ff)"."
15:34:34 <cads> i wonder what the zigzag theory is about
15:34:41 <danharaj> if you're going to read an article about this, don't even bother with wikipedia if Stanford Encyclopedia of Philosophy has an article on it.
15:34:45 <dolio> cads: The paper, Weyl's Predicative Classical Mathematics as a Logic Enriched Type Theory talks a little about Russell's stuff toward the end.
15:34:57 <dolio> And it's interesting in itself.
15:35:15 <cads> sounds interesting
15:35:41 <Philippa> is there an algorithm to 'predicatise' or 'stratify' System F programs/statements?
15:36:14 <danharaj> It depends on which System F you are talking about, non?
15:36:55 <Philippa> danharaj: how so? I'm expecting this to transform the statement into a different system, of course
15:37:08 <dolio> Philippa: It can't always be done, can it?
15:37:21 <Philippa> but I don't mean any of the more obvious "predicative System F" variants, those aren't System F per se
15:37:33 <Philippa> dolio: I haven't seen the proof that that's the case
15:37:42 <danharaj> Ah sorry I was thinking of System F with subtyping which has two major variants that are both referred to the same way. My bad.
15:38:09 <danharaj> Things you know turn into soup if you don't remember them often enough.
15:38:36 * hackagebot xsd 0.3.3 - XML Schema data structures  http://hackage.haskell.org/package/xsd-0.3.3 (TonyMorris)
15:38:38 <Philippa> danharaj: *nod*
15:39:10 <danharaj> But System F, I don't think you can stratify every type.
15:39:12 <Philippa> dolio: well, OK, I may've seen it and not realised that's what it proves :-)
15:39:25 <danharaj> I don't have a proof or an argument though.
15:39:42 <Philippa> danharaj: not of the System itself, just for a given statement within it
15:39:59 <Philippa> (given a closed world assumption, if that helps)
15:40:28 <danharaj> I'm not sure what the question is anymore. Could you pose it in a more formal way?
15:41:22 <Philippa> for a given context and statement, can you translate to a powerful enough stratified/predicative setting in a suitably semantics-preserving manner?
15:41:25 <dolio> Philippa: My immediate thought is that you might have a P such that P is applied to both T and U, where T predicativizes to *M and U to *N, but then I remembered that F doesn't have higher kinds.
15:41:55 <dolio> So I'm not sure if you could construct the same problem in just F.
15:42:08 <Philippa> dolio: yeah, I imagine the proof for Fw is a lot more complicated if it can be done for both
15:42:52 <Philippa> (though actually, if you can do for F then I'd expect that the STLC layer gives you enough structure for any further stratification needed)
15:43:54 <danharaj> So you have some finite set of type derivations in System F and you want a map phi from System F to another system such that if D is one of your types, phi(D) is a valid type and if x : D, then phi(x) : phi(D)?
15:44:15 <Philippa> danharaj: that's a starting point, yeah
15:45:25 <danharaj> I don't think this is possible.
15:45:53 <danharaj> I think it would fail even for the identity function.
15:46:04 <Cale> whaaat
15:47:17 <Philippa> danharaj: hmm. Yeah, at most id can range over other stuff we've got round to stratifying at any given point
15:47:46 <Cale> (oh, perhaps there's more context that I missed :)
15:47:49 <danharaj> I am trying to find a result that says that martin-loef type theory can be interpreted in constructive set theory.
15:47:59 <danharaj> I know the other direction holds (I think)
15:48:21 <Saizan> Cale: the other system has to be predicative
15:48:40 <Philippa> yeah. But I've not quite managed to spec what I want in the translation adequately
15:49:09 <danharaj> then it would follow that it is impossible to do what you want for all of System F into Martin-Loef because System F can not be interpreted in set theory.
15:49:30 <dolio> Philippa: Cumulativity of levels in the target theory would be an important factor too, I imagine.
15:49:42 <danharaj> At this point you'll have to make clear what you want your translation to do with semantics.
15:49:47 <Philippa> hmm. It's probably as simple as predicativity-as-effect, isn't it? You can do it internally and stratify the stuff you've done, but you can't export a statement whose final type is impredicative
15:50:08 <Philippa> er, impredicativity-as-effect
15:50:33 <Cale> If we take phi = id though, that's a mapping from system F to system F where if D is a valid type in system F, then phi(D) = D is as well, and if x : D, then surely phi(x) : phi(D) as well :)
15:50:45 <danharaj> yes, but system F is impredicative :p
15:50:48 <Cale> But perhaps I missed something :P
15:53:25 <Saizan> Cale: that System F is impredicative?:)
15:54:11 <Cale> I don't see what that has to do with danharaj's line.
15:54:24 <danharaj> which line, I say a lot of things. each less true than the last.
15:54:25 <Cale> <danharaj> So you have some finite set of type derivations in System F and you want a map phi from System F to another system such that if D is one of your types, phi(D) is a valid type and if x : D, then phi(x) : phi(D)?
15:54:43 <Cale> <danharaj> I think it would fail even for the identity function.
15:54:45 <danharaj> I forgot the condition that the other system is predicative.
15:54:54 <danharaj> I mean the identity function as in the lambda term ;)
15:55:02 <Cale> oh, okay
15:55:05 <danharaj> I have many statements, each more imprecise than the last!
15:55:15 <Philippa> heh, context's a bitch
15:56:15 <Philippa> so where we got to: I think it's doable if the term being translated has a monotype. For polytypes, you can probably thus translate it weakened to some given level of stratification
15:57:47 <danharaj> I don't think so.
15:58:16 <Philippa> counterexample?
15:58:36 <Philippa> if the term has a monotype you just need to stratify up all the individual calls of things internally...
15:58:43 <Philippa> (remember, no fix)
15:58:59 <danharaj> I think given a stratification scheme you could construct a program that recursively applies polymorphic id to a term (starting with a monotype) and then constructs a term of the next level and repeats the process.
15:59:29 <danharaj> so that your program must instantiate id to terms from each level of stratification.
15:59:42 * hackagebot libpq 0.1 - libpq binding for Haskell  http://hackage.haskell.org/package/libpq-0.1 (GrantMonroe)
15:59:45 <danharaj> maybe? maybe not?
15:59:45 <Philippa> yeah, but you've got no fix so even that's a finite number
16:00:07 <danharaj> take a natural number input from the user.
16:00:25 <danharaj> although now I don't know if it's typeable.
16:00:30 <danharaj> regardless!
16:01:27 <Philippa> *nod*. Yeah, you'd need a dependently-typed target lang at that point
16:01:34 <Philippa> which gets, uh, complicated
16:02:01 <danharaj> well I meant I don't know if it is even typable in system F
16:02:43 * hackagebot libpq 0.2 - libpq binding for Haskell  http://hackage.haskell.org/package/libpq-0.2 (GrantMonroe)
16:03:27 <Philippa> I don't think the one you're thinking of is
16:03:45 <Philippa> you'd get something where it's the same id call and you can locally reduce to monotype once and have done with it
16:05:12 <Philippa> you're after a case with polymorphic recursion, right?
16:05:43 <Philippa> but System F doesn't quite have the structure to do that, the types're too simple
16:07:41 <danharaj> what about: f : Nat -> forall X. X -> X where f 0 = id and f (S n) = id (f n) ? What type is that? You can definitely write this program because you can represent the fold of Nat in System F.
16:07:58 <danharaj> er not 'what type is that', is that the right type?
16:09:26 <danharaj> I would ask ghci but I don't know how to enable full system f type checking.
16:09:32 <Ke> can someone explain, why does versioning policy require 2 numbers for major version
16:10:18 <Philippa> that's the right type so long as it binds validly
16:10:35 <Ke> it's a bit silly name my sillypackage-1.0.0.0 while eg. udev uses single number version
16:10:36 <Philippa> that is, so long as the parens're where I think :-)
16:10:47 <danharaj> I don't see how you can stratify the application of id in the inductive step, then, if I'm not being silly :p
16:11:38 <danharaj> then again there is a constructivist within the pits of my brain that is frothing at the mouth at such flagrant impredicativity.
16:12:45 <benmachine> Ke: you want to call it sillypackage-1?
16:12:56 <benmachine> Ke: I don't think there's anything wrong with that
16:13:14 <Ke> http://www.haskell.org/haskellwiki/Package_versioning_policy
16:13:15 <benmachine> 1 < 1.0 although some people argue that's a bug
16:13:31 <Twey> o.@
16:13:40 <Twey> 1 < 1.0?
16:13:44 <benmachine> Twey: in versions, yes
16:13:47 <Twey> Ah
16:13:56 <benmachine> < 1.0.0
16:14:14 <lispy> 1 < 1.0 in cabal?
16:14:18 <benmachine> yes
16:14:23 <lispy> Wtf??
16:14:23 <Philippa> danharaj: gimme dependent types and it's easy, of course
16:14:27 <lispy> Why is that a good idea/
16:14:27 <Ke> I'd like to use 3 number versioning policy or versioning policy, where you specify the policy in .cabal-file
16:14:40 <Philippa> I just need a simple dependent layer 'outside' the stratification
16:15:35 <lispy> benmachine: is it treated like 1 == 0.1 ?
16:16:10 <benmachine> lispy: no
16:16:15 <benmachine> lispy: basically, versions are [Int]
16:16:21 <benmachine> [1], [1,0] etc.
16:16:22 <benmachine> plus tags
16:16:25 <Ke> and mostly I just wanted to know, whether someone has any non-silly arguments for 2 number major version
16:16:29 <benmachine> then they're compared as lists
16:16:33 <lispy> > [1] < [1,0]
16:16:34 <lambdabot>   True
16:16:44 <Philippa> danharaj: this is actually something like the structure Coq has at the moment, IIRC
16:17:30 <benmachine> Ke: I think the PVP is more concerned with how your version changes than what it is exactly
16:17:34 <danharaj> I don't know how Coq works. I thought it was impredicative?
16:17:34 <Philippa> danharaj: though personally? I'd just monomorphise the damn type in this particular case. There's no poly-recursion, so we know the range of types involved
16:17:45 <benmachine> Ke: in the end it doesn't really matter what people do, but it helps if people do (on the whole) the same thing
16:17:48 <zachk> ok i am culling finite magma space looking for finite monoids, i was using the list monad, but was overflowing stack, so i switched to controlmonadomega and now im running out of memory :( what should i do 
16:18:02 <benmachine> Ke: that's what the PVP tries to achieve; it just so happens that most people use at least two version numbers
16:18:04 <dolio> Coq does have an impredicative Prop, and optionally impredicative Set.
16:18:16 <danharaj> well the next natural step is to run out of time, zachk ;)
16:18:16 <benmachine> Ke: but fwiw I released 0.1.1 of my package and then followed it with 0.2
16:18:36 <dolio> But it also has a stratified hierarchy Type, but which internally looks like Type : Type, and the system figures out how to stratify it.
16:18:41 <zachk> yea i realized for order=10 im looking at a googol 
16:19:01 <zachk> is there a better way? 
16:19:18 <Philippa> dolio: right. This'd get more interesting if we looked at something coalgebraic
16:19:22 <Ke> benmachine: I'd very much like to be able to release bugfix-releases with only 3 number fullversion
16:19:38 <danharaj> Philippa: Sounds like the coq people could help you out.
16:20:05 <Ke> benmachine: and I have never seen anyone use any logic with 4 number versioning
16:20:10 <benmachine> Ke: why? what difference does it make? you then have to explain your versioning scheme to people instead of just using the current one
16:20:45 <Philippa> danharaj: eh, did I say I have a use case? :p
16:21:01 <danharaj> :p
16:21:05 <Ke> benmachine: wasn't there some talk about automatically enfonrcing the versioning policy
16:21:16 <danharaj> there's a lot of talk in #haskell
16:21:30 <benmachine> Ke: some talk, perhaps, but I think we're more likely to move in the direction of explicit opt-in
16:21:51 <benmachine> Ke: although if you want a package in e.g. the platform, it'll probably have to follow the PVP
16:22:06 <Ke> benmachine: still I'd like to hear any argument for 2 number version numbers
16:22:24 <benmachine> Ke: consistency is pretty much the only important thing in version schemes, you can fight it for your "better" one but you're pushing against consensus for no appreciable gain
16:23:15 <Ke> if there is really consensus about this, I would think that there would be at least one(1) argument for 2 number major versions
16:24:12 <dolio> Philippa: I suppose the use case would be: we can use System F with less worry about there being secret inconsistencies hiding.
16:24:23 <dolio> Unless, of course, the predicative system is also inconsistent.
16:24:53 <danharaj> isn't system F strongly normalizing, and thus consistent?
16:25:05 <dolio> Proved in what? ZF?
16:25:10 <dolio> Impredicative ZF.
16:25:27 <danharaj> in whichever setting you do type theory.
16:25:49 <Philippa> danharaj: it's strongly normalising, yes. OTOH, System F was just the initial test case
16:26:16 <benmachine> Ke: that's what was most popular when the PVP arose, I guess, probably because people liked the look of it
16:26:30 <benmachine> or because they felt it was expressive for their purposes
16:26:38 <benmachine> I mean
16:26:40 <Ke> o_O
16:26:47 <benmachine> breaking API changes actually happen quite often
16:26:53 <benmachine> so you often have to increase the PVP's B number
16:27:08 <benmachine> it makes sense that you would want another more significant number to mean "complete rewrite" or whatever
16:27:25 <benmachine> like when Parsec got several new major features and moved its module namespace
16:27:39 <benmachine> or when QuickCheck introduced a new basic type class
16:27:42 <benmachine> or whatever
16:27:59 <benmachine> so that's probably why people typically have two major version numbers
16:28:10 <Ke> not reallt
16:29:17 <Ke> It's remarkable how many projects just use "I Just feel like increasing major version" versioning policy
16:29:46 <Ke> and eg linux uses practically 2 numbers versioning policy
16:30:13 <Ke> using more numbers is just cool for most people IMO
16:32:10 <aavogt> @hackage HTTP
16:32:11 <lambdabot> http://hackage.haskell.org/package/HTTP
16:32:15 <stroan> I've always read it as [General Architecture].[API differing versions].[Non API differing versions]
16:32:46 <Ke> benmachine: so I would like to know how does 2 number improve the expressivity of the version number in a way that's useful to users
16:32:50 <Cale> I generally think of the major/minor distinction as simply referring to how far the release goes with respect to various goals one might have for the project. Major versions correspond to the accomplishment (or near-accomplishment) of major goals.
16:33:22 <danharaj> I think version numbers try to model something more complicated than version numbers.
16:33:32 <benmachine> that's fine
16:33:39 <benmachine> sometimes you have a small space to write a big message
16:33:41 <benmachine> you do the best you can
16:33:58 <benmachine> and you avoid bikeshedding where possible :P
16:34:12 <Ke> Cale: but that's just not maximizing utility
16:34:16 <danharaj> yes, although it would be nice if we got to the point with type systems where we can declare API's and their semantics and have our compilers statically check that we are getting what we expect.
16:34:29 * Cale does the whole closures thing again.
16:34:49 <Cale> (on reddit :)
16:34:51 <copumpkin> mmm closures
16:34:55 <benmachine> delicious.
16:35:02 <copumpkin> ;)
16:35:14 <copumpkin> doesn't help that there's a language called clojure out there
16:35:16 <Cale> (the language feature vs. implementation mechanism discussion) http://www.reddit.com/r/programming/comments/dn4ra/lets_make_closures_easy/
16:35:19 <copumpkin> maybe I'll write a new language called thunk
16:35:29 <copumpkin> thunc?
16:35:46 <danharaj> If I wrote a language that could be reasonably popular I would call it "durr"
16:35:51 <copumpkin> or maybe one called graph-coloring-register-allocatr
16:35:55 <danharaj> just to make sure people are humble when they talk about it :)
16:36:08 <Cale> I've been thinking "Felonius Thunk" would be a great name for a band.
16:36:34 <copumpkin> lol yeah
16:36:42 <blackdog> danharaj: hell yes. i've been programming in 'groovy' lately and it sucks hard.
16:36:43 <sclv> melodious thunk
16:36:48 <blackdog> so much self-satisfaction...
16:36:53 <Cale> Or yeah, Melodious
16:36:55 <ezyang> ++ 
16:36:55 <danharaj> groovy sounds like a language for hipsters.
16:37:15 <blackdog> danharaj: ironically, it's ruby for java drones. very much a follower language.
16:37:23 <aavogt> preflex: seen edwardk
16:37:23 <preflex>  edwardk was last seen on #haskell 5 days, 3 hours, 41 minutes and 50 seconds ago, saying: chrisdone: hah. i think that has happened to a lot of us at different points
16:37:25 <hpc> groovy is a language for potheads from woodstock :P
16:37:42 <hpc> (it's an older term than hipster)
16:37:45 <sclv> wikipedia disagrees with you cale :-): http://en.wikipedia.org/wiki/Closure_%28computer_science%29
16:37:45 <geheimdienst> hey, it's thelonious monk -> melonious thonk, you illogical thunks
16:37:47 <danharaj> I have been thinking about doing a phd in computer science actually, to develop a language.
16:38:00 <danharaj> But in my head a phd in a mathematical discipline like geometry is more prestigious ;)
16:38:03 <danharaj> </trollin>
16:38:35 <hiredman> what does having a phd have to do with developing a language?
16:38:47 <danharaj> because I have some ideas I don't think have been used in language design together yet.
16:38:55 <danharaj> And I think their synthesis would be worthwhile as a contribution to the theory.
16:39:15 <hiredman> I still don't see what that has to do with a phd
16:39:37 <Cale> sclv: I know. I'm arguing that the reason it does so is that the abuse is very common.
16:39:46 <danharaj> phd is a title conferred upon someone for contributing to an academic field of knowledge?
16:39:52 <sclv> Also if Landin used the term in ISWIM, I have a hard time believing he gave it a purely operational denotation :-)
16:39:56 <dibblego> I want to have two different versions of hxt depending on which code I am writing -- how do I manage this?
16:40:05 <stroan> hiredman: his phd would be on the new language, not a prerequisite to start work on it
16:40:15 <danharaj> yes stroan you are sexy.
16:40:19 <danharaj> I mean- ahem.
16:41:02 <sclv> Thunk is fairly operational, but closure = lambda expression closed over its environment seems pretty denotational to me.
16:41:22 <Cale> sclv: Since the introduction of the term to refer to a particular data structure to be used in the implementation of first class procedures, people have abused it pretty regularly.
16:41:42 <danharaj> I hate how 'functor' is abused in C++.
16:42:22 <Cale> sclv: There's no need for a specific term for lambda expressions that capture the values of variables in their environment. That's just how lambdas work.
16:42:28 <geheimdienst> danharaj, i heard some people even make salads out of them
16:43:25 <danharaj> I am fine with functor salads. After all, there is a field of mathematics that is populated by objects whose names derive from agricultural puns.
16:43:59 <kmc> ugh, proggit
16:44:08 * Cale makes a fruit salad with some Abelian grapes and some Banananach spaces.
16:44:24 <danharaj> Cale I am not sure if we shouldn't be friends or if we should be best friends.
16:44:35 <copumpkin> lol
16:44:41 <geheimdienst> @remember Cale makes a fruit salad with some Abelian grapes and some Banananach spaces.
16:44:42 <lambdabot> I will remember.
16:44:43 <ezyang> Mmm, gotta love those Abelian grapes. 
16:45:36 <danharaj> kmc what abortion of decency has proggit bestowed upon the world today?
16:45:44 <kmc> what's yellow and relates functors from a locally small category to natural transformations between that functor and a hom-functor?
16:45:50 <mauke> geheimdienst: that quote will suck
16:46:14 <geheimdienst> mauke, how so?
16:46:16 <danharaj> yoneda's lemon
16:46:17 <Cale> Yoneda's lemon
16:46:19 <Cale> yes
16:46:20 <kmc> correct you are
16:46:30 <mauke> geheimdienst: "Cale says: makes a fruit salad ..."
16:46:31 <danharaj> This is an easy one for me because I always refer to 'lemons' when I do proofs.
16:46:51 <Philippa> Cale: to be fair, it's more meaningful in the context of a language where variables're mutable
16:46:53 <geheimdienst> @quote fruit salad
16:46:53 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
16:46:59 <geheimdienst> @quote salad
16:46:59 <lambdabot> pyschobot says:   pig-latin FunctorSalad: shut up educated stupid it's entailed by a team of visionary leaders
16:47:11 <geheimdienst> @quote fruit.salad
16:47:11 <lambdabot> Cale says: makes a fruit salad with some Abelian grapes and some Banananach spaces.
16:47:24 <geheimdienst> i see what you mean
16:47:31 <geheimdienst> ah well, close enough
16:48:02 <kmc> danharaj, mostly it reminds me how ass-backwards the field of programming outside CS is
16:49:08 <kmc> "let me tell you about this new advanced feature i discovered called first-class functions"
16:49:17 <res> heh
16:49:43 <danharaj> to be fair, as a math major I'm still waiting for a dependent type system that doesn't suck to use.
16:50:43 <ddarius> danharaj: Just give it another 30 or so years.
16:51:03 <kmc> other proggit tropes include: self congratulation about how "hackers" are better than other programmers; arguing about differences between flavors of Agile snake-oil; etc
16:51:31 <Philippa> mmm, the first part is probably just flow worship, IYSWIM
16:51:50 <geheimdienst> kmc, "ass-backwards" is an offensive term. the mathheads prefer "retrorectal"
16:51:53 <kmc> haha
16:52:00 <danharaj> ddarius: I am hoping that the application of category theory to programming will make progress faster. That you can automatically recover proof principles and equations to reason with from universal properties sounds like it is begging to be used with dependent types.
16:52:16 <Philippa> geheimdienst: what do they suggest in place of backasswards?
16:52:49 <ddarius> danharaj: Category theory has been applied to computer science for over thirty years already.
16:52:55 <blackdog> kmc: it's almost spooky reading Groovy docs - there's this wide-eyed wonder about not having to declare types, as if they've somehow stumbled on baffling alien technology.
16:53:03 <kmc> danharaj, you're talking about "proof principles" and "universal properties" in a world where the most common form of abstraction is copy-paste, and memory safety is a controversial idea
16:53:08 <blackdog> and this is just dynamic typing, nothing clever like inference.
16:53:13 <kmc> yeah
16:53:43 <danharaj> ddarius: just gotta wait for a generation to grow up that just gets it.
16:53:57 <Philippa> yeah. And inference is like magic rather than descending from the same simultaneous equations that we all did in school
16:54:07 <blackdog> danharaj: what makes you think they will?
16:54:12 <kmc> danharaj, that generation will learn from this that static types are evil and Ruby is the One True Way
16:54:21 <danharaj> blackdog: My faith in human imagination.
16:54:24 <kmc> it'd be at least *two* generations before non-terrible static typing is popular
16:54:57 <Adamant> and three before we have nice systems of switching between static and dynamic typing as required
16:55:11 <danharaj> I am sure there are high school students or undergrads playing with Haskell right now that have the creativity and talent it takes to create something new and awesome.
16:55:21 <Adamant> and a good understanding of where to use both
16:55:31 <blackdog> i'm still thinking about application areas. i want to write a demo app for Hubris, showing that Haskell is useful in web apps - it's just hard to find webservers that need to be fast and accurate, weirdly enough.
16:55:34 <ddarius> Adamant: You mean when people realize that dynamic typing is never required.
16:55:34 <sclv> one last salvo -- lambdas just "do what they do" in the absence of mutation. beyond that, sure you can represent it with lambdas, but there's really a lot more going on.
16:55:35 <danharaj> Perhaps I have the desire to try, but I have neither creativity nor talent ;)
16:55:54 <Adamant> ddarius: you believing that is why it will take three generations :P
16:56:02 <blackdog> ddarius: in the sense that dynamic typing is a special case of static typing?
16:56:12 <ddarius> blackdog: Sort of, yes.
16:56:37 <danharaj> in the sense that any language that is sane (i.e. not perl) ought to have its semantics deducible statically?
16:56:57 <Adamant> dynamic typing makes sense for some stuff. it just doesn't make as much sense as it did when we didn't have type inference systems and expressive type systems.
16:57:34 <Adamant> the last two do not eliminate the need for dynamic typing.
16:57:38 <kmc> most use cases of dynamic typing are absorbed by basic features of non-terrible static type system
16:57:50 <kmc> chiefly polymorphism and sum types
16:57:58 <dolio> So, dynamic typing made sense until the early 80s? :)
16:58:17 <kmc> ML is older than that, i thought
16:58:22 <Adamant> dolio: assuming that tech had been more widely distributed
16:58:24 <Adamant> which it wasn't
16:58:51 <kmc> i think there's still some use cases left, but i'm very happy with a type system like Haskell's, occasionally using Dynamic / Typeable / existentials / etc.
16:59:05 <ddarius> Adamant: I highly suspect that most of what you are attributing to "dynamic typing" is rather reflection.
16:59:07 <Adamant> and if it was, we would be working on some ML variant and not Haskell in all likelyhood
16:59:18 <ezyang> kmc: Do any come to mind immediately? 
16:59:22 <danharaj> ML has icky syntax
16:59:43 <Adamant> ddarius: maybe I'm wrong. maybe you're wrong. we'll see eventually.
16:59:55 <danharaj> make a wager and have lambdabot remember
17:00:04 <danharaj> and set a date for the decision
17:00:10 <Adamant> I don't think lambdabot has a wagering mechanism
17:00:15 <Adamant> also I'm broke as shit
17:00:24 <danharaj> bet something nebulous
17:00:26 <kmc> ezyang, hmm.  if i'm parsing text into a typed AST GADT, i have to cross a dynamic→static boundary somehow
17:00:31 <danharaj> like ten bushels of pride.
17:00:37 <Philippa> Adamant: we've got some damn good evidence in the research trail by now
17:00:42 <kmc> an existential over the GADT's parameter with a Typeable constraint is a natural way to do this, imo
17:01:18 <Adamant> Philippa: about not needing dynamic? my understanding is that systems that can flexibly switch between dynamic and non-suck static typing ARE research at present
17:01:25 <kmc> another use case is SYB — it's built around run-time type information, though not dynamic typing per se
17:01:31 <ezyang> kmc: Ah, of course. 
17:01:39 <copumpkin> uniplate ftw
17:01:41 * copumpkin fell in love
17:01:44 <Saizan> Typeable is not quite enough for some cases, you'd want a GADT representing the type
17:01:46 <copumpkin> but SYB isn't too bad either
17:01:50 <Philippa> Adamant: they are, yes, but so's statically-typeable reflection
17:01:51 <danharaj> ddarius: also I don't think category theory and dependent types have been mixed in a programming language yet.
17:02:07 <copumpkin> danharaj: category theory in what sense?
17:02:22 <Philippa> Adamant: having an option that can do something under research doesn't mean that there can't be an evidence trail that it's not actually needed building up
17:02:24 <kmc> and certain heterogenous containers, e.g. emulating ST using State, seem hard to do without Dynamic
17:02:30 * ddarius feels that you always either a) know more than that some object is "a thing" or b) are only holding data for someone else.  Neither scheme requires Dynamic.
17:02:41 <danharaj> copumpkin: the sense that most readily comes to mind is using it to define datatypes so that you automatically derive reasoning principles and equations from them via universal properties.
17:02:42 <Adamant> Philippa: true
17:02:55 <ezyang> Dynamic types for dependent typing. Who'd a thought. 
17:03:11 <ddarius> danharaj: There are some that do to varying extents, e.g. Charity and CPL, but it is not clear what "programming with category theory" would mean.
17:03:28 <kmc> ddarius, what about the ST-on-State example? you're holding data for someone else, but can you prove to the Haskell type checker that you always picked the right ref?
17:03:33 <danharaj> ddarius: indeed. if I do pursue my phd in CS instead of math I would definitely be poking around there.
17:04:02 <dolio> Charity isn't dependently typed, either.
17:04:18 <ezyang> IMO, dynamic typing says to the compiler, "Don't worry, I think I did it correctly." 
17:04:41 <dolio> danharaj: You should look into the stuff at the nlab on 2-categorical logic, too.
17:05:01 <danharaj> dolio: thanks for the reference.
17:05:03 <ddarius> copumpkin: I haven't used it, but I too very much like Uniplate.
17:05:38 <copumpkin> I'd avoided the generics stuff for a while assuming they were ugly
17:05:39 <dolio> Where people (or, just one guy) are trying to work out what the internal language of a 2-topos is, which would be similar to a type theory in which you talk about categories as well as sets and values.
17:05:54 <copumpkin> and was amazed at how simple it was to get up and running
17:05:59 <copumpkin> even doing fairly complicated things
17:06:17 <ddarius> danharaj: Admittedly, dependent types would make things like equalizers much more sensible.
17:07:20 <ddarius> Something I might take a swing at is formalizing Benabou's categories-as-fibrations perspective.
17:07:52 <danharaj> ddarius: would that in any way be related to the work described in Jacobs' categorical logic and type theory?
17:08:10 <ddarius> danharaj: Not really.
17:08:12 <Cale> TIL that a monolayer sheet of graphene absorbs exactly pi times the fine structure constant (which is about 2.3%) of white light.
17:08:36 <danharaj> ddarius: I think I saw a reference to benabou in there. So I take it categories-as-fibrations is not the same as fibred categories I take it?
17:08:38 <ddarius> Cale: Buffon needle.
17:08:50 <sclv> lovely.
17:09:08 <Adamant> Cale: unless that's from reddit, I'd rather read your TIL's than theirs
17:09:11 <copumpkin> Buffon the goalie?
17:09:26 <Saizan> TIL?
17:09:32 <Adamant> Today I Learned
17:09:33 <Cale> Today I learned
17:09:40 <copumpkin> Saizan clearly doesn't spend enough time on reddit
17:09:42 <Adamant> one of the few sections of reddit that isn't total ass
17:09:42 <sclv> copumpkin: http://blog.sigfpe.com/2009/10/buffons-needle-easy-way.html
17:09:52 <ddarius> danharaj: I'm sure Jacobs references Benabou, but Benabou was doing something different than what Jacobs was doing.
17:09:59 <Cale> Now, I just have to understand why ;)
17:10:02 <Adamant> copumpkin: no, that may be a sign he spends the right amount
17:10:06 * copumpkin sends Saizan to the redducation camp
17:10:23 <Adamant> lol, that was awful
17:10:35 <Adamant> copumpkin++
17:10:45 <Adamant> lambdabot: copumpkin++
17:10:53 <Adamant> damn, no more karma.
17:10:56 <copumpkin> I think lambdabot heard
17:10:59 <copumpkin> @karma
17:10:59 <lambdabot> You have a karma of 11
17:11:03 <danharaj> ddarius: ah. I only know benabou from 'mitchell-benabou language' what is it that you find interesting that he does?
17:11:04 <Adamant> ah
17:11:07 <gwern> @quote learned
17:11:07 <lambdabot> c2.com says: If you can program anything in HappS you actually already learned Haskell
17:12:26 <copumpkin> poor bos
17:14:19 <sclv> kmc: see http://okmij.org/ftp/tagless-final/#tc-final and following bits. parsing to a GADT with no dynamics!
17:14:31 <Adamant> so if the stuff is additive, that would mean that 17 layers of graphenes would absorb all physical light.
17:14:40 <sclv> (my version cheats and uses the unprincipled dynamics, but that's just for convenience)
17:15:12 <ddarius> danharaj: This paper is what I'm referring to: "Fibered Categories and the Foundations of Naive Category Theory."
17:15:13 <Cale> Adamant: It's not though
17:15:24 <Adamant> Cale: yeah, I'm not surprised
17:15:34 <djahandarie> Hm, are there any other CS undergraduates in here?
17:15:45 <djahandarie> We should have a #haskell survey at some point
17:15:47 <copumpkin> I'm an ex undergraduate
17:15:47 * ezyang waves 
17:15:47 <Adamant> I would think wave property of light would play a part
17:15:47 <FauxFaux> I'm still an undergraduate in my mind.
17:15:54 <Cale> Adamant: It multiplies, so 17 layers allow (1 - pi alpha)^17 of the light through
17:16:05 <Adamant> ah
17:16:11 <copumpkin> djahandarie: a survey of what sort?
17:16:14 <djahandarie> ezyang, yes I know you are, but I think you're the only one I know
17:16:20 <copumpkin> there's also Veinor 
17:16:24 <djahandarie> Ah right
17:16:37 <Adamant> I am technically still a undergrad.
17:16:50 <djahandarie> copumpkin, just like 'who are you' 'what do you do' 'how do you use haskell irl' etc
17:16:57 <copumpkin> haskellers.com! :P
17:17:06 <djahandarie> lol
17:17:11 <djahandarie> Haskellites
17:17:13 <copumpkin> hey, it just launched
17:17:13 <geheimdienst> haskilled.com
17:17:18 <copumpkin> sign up
17:17:19 <geheimdienst> haskellistas.com
17:17:33 <djahandarie> Adamant, "technically"?
17:17:34 <copumpkin> bos: having connection trouble? :)
17:17:37 <dark> i has killed you
17:17:50 <bos> oh, weird!
17:17:51 <Adamant> djahandarie: more complicated than I want to explain on IRC. :P
17:17:57 <djahandarie> copumpkin, wait, is that an actual site?
17:17:58 <copumpkin> yeah
17:18:05 <geheimdienst> haskin
17:18:12 <djahandarie> copumpkin, it isn't loading for me here
17:18:16 <copumpkin> yeah, same here
17:18:18 <copumpkin> was working a few minutes ago
17:18:29 <djahandarie> Max 1 concurrent connection
17:18:31 <djahandarie> Go Haskell!!
17:18:32 <copumpkin> lol
17:18:55 <sclv> clearly not using epoll yet :-)
17:19:02 <djahandarie> Nice, finally died with a 503
17:19:09 <copumpkin> yeah, same 
17:19:15 <copumpkin> Guru Meditation
17:19:19 <djahandarie> Yeah haha
17:19:28 <djahandarie> And apparently it's all varnish's fault
17:19:30 <Adamant> the story of how that got started is interesting
17:19:35 <djahandarie> I thought varnish was webscale
17:20:18 <Adamant> apparently folks at Amiga were balancing on a board with rocker switches or something to sense if you could stay balanced or not
17:20:22 <benmachine> I'm an undergrad, but not CS >_>
17:20:39 <geheimdienst> "we have determined that autoparallelization sucks and needs a few more years of theoretical work. please access the website only one at a time. please google 'spinlock' to coordinate with other guests."
17:20:40 <Adamant> and the error that got thrown when you weren't was Guru Meditation
17:20:47 <djahandarie> benmachine, lol, what major?
17:20:59 <benmachine> djahandarie: maths!
17:21:11 <benmachine> modulo the fact that the concept of major doesn't really exist in britain >_>
17:21:14 <sproingie> eh?  It's always "Guru Meditation #xxxx" where there's an error code afterward
17:21:18 <ezyang> http://www.youtube.com/watch?v=drE5cHe6c3s 
17:21:24 <sproingie> which makes a lot more sense than that story
17:21:44 <Adamant> yeah, if someone in here has not done at least one major in math/stats/CS/CE/EE
17:21:45 <benmachine> ezyang: I have the DVD
17:21:50 <Adamant> I would be surprised
17:21:57 <Adamant> unless they haven't done any
17:22:02 <ezyang> \o/ 
17:22:14 <benmachine> ezyang: my favourite is water :P
17:22:17 <aristid> Adamant: your odds are VERY poor at 613 idlers
17:22:22 <Adamant> sproingie: the Guru Meditation tag got attached to all error messages
17:22:31 <benmachine> although "imhotep is invisible" has acquired meme status in some of my social groups
17:22:39 <Adamant> aristid: more than 10?
17:22:53 <ezyang> The videos are pretty popular back at MIT. :-) 
17:22:56 <Adamant> given my conditions that allow that they have done no majors at all?
17:23:03 <djahandarie> benmachine, ah, math is cool. I wish I were doing a math double along my CSE degree but I've decided I should just stick with one
17:23:08 <sproingie> then again maybe they got the meditation thing from that.  the amiga folks were weird.
17:23:23 <benmachine> djahandarie is doing a degree in common subexpression elimination
17:23:43 <djahandarie> :P
17:23:47 <gwern> you are already dead.
17:23:53 <benmachine> but yes
17:24:30 <geheimdienst> the video's graffiti reminds me of http://nancyfriedman.typepad.com/.a/6a00d8341c4f9453ef00e553a2c6e98833-500wi
17:24:58 <benmachine> I love the jars
17:25:04 <benmachine> "meths" "moths" "maths"
17:25:12 <benmachine> but yes if I watch this now I wil be up all night :(
17:25:14 * benmachine goes to bed
17:25:26 * ezyang should go to bed too... 
17:25:57 <copumpkin> ezyang: oh yeah, you're in the real cambridge now, aren't you?
17:26:07 <ezyang> Yep :-) 
17:26:29 <ddarius> Should I work on my scheduler so I can add some I to my IO, or should I just read a book instead?
17:27:00 <Adamant> you should pronounce scheduler sheduular
17:27:28 <Adamant> and then read, I guess
17:28:25 <copumpkin> ddarius: scheduler!
17:28:29 <copumpkin> ddarius: well, depends on the book
17:28:34 <benmachine> read the book
17:28:44 <benmachine> it will improve your mind and then the scheduler will be better
17:28:45 * hpc envisions the "doctorate troll", correcting people in the middle of presentations by correcting insufficiently snobby pronunciation
17:29:43 <gwern> hpc: Copenhagen is a good example
17:30:06 <gwern> I was corrected publicly because apparently I was pronouncing it German-style and this was considered somewhat offensive due to WWII
17:30:06 <hpc> gwern: it exists?!?
17:30:14 <hpc> XD
17:30:15 <gwern> hpc: so I'm told
17:30:30 <geheimdienst> wat
17:30:32 <Adamant> hpc: it's Belgium that doesn't exist
17:30:50 <hpc> Adamant: now you are just talking nonsense :D
17:30:58 <Adamant> hpc: am I? :P
17:31:14 <aristid> gwern: are germans allowed to pronounce it german-style?
17:31:27 <Adamant> http://zapatopi.net/belgium/
17:31:29 <hpc> so i recently discovered that mathematicians consider category theory to be complete gibberish
17:31:33 <Adamant> documentary evidence!!!!!
17:31:37 <Adamant> hpc: some do
17:31:42 <gwern> I don't know. unfortunately I failed to become german and so didn't know
17:31:48 <aristid> hpc: only those who don't understand it, of course.
17:31:53 <Adamant> mostly because they have a lot invested in set-theoretical constructions
17:31:58 <Vanadium> Is it appropriate to use Attoparsec and Data.Binary to parse a binary file format that has delimeters and stuff like that or are they not going to fit together well
17:32:13 <gwern> (I actually learned today that by a small twist in my family history I was born in america rather than germany. in many parallel worlds I could claim to be german)
17:32:18 <geheimdienst> gwern, i've been around danes and wouldn't take that too seriously. i guess it was just one dork who wanted some attention. haven't ever seen any general resentment against german
17:32:19 <Vanadium> I need stuff like taking a bunch of bytes and "parsing" them as a big-endian integer, or some manner of floating-point
17:32:32 <aristid> gwern: if only it was possible to communicate between parallel worlds :)
17:32:34 <Vanadium> but it also needs to deal with some manner of recursive-descent-ish grammar
17:32:44 <gwern> aristid: well, they wouldn't be very parallel then
17:32:44 <hpc> Adamant: incontrovertible! notify Dan Brown, so he can uncover this conspiracy in a best-selling novel!
17:33:05 <aristid> gwern: physics is not that precise anyways
17:33:35 <Adamant> hpc: "Bullshit. I've read The DaVinci Code. It's for the dummies!" - S$^! My Dad Says
17:34:31 <ddarius> gwern: Well if the multi-space-time manifold is suitably contorted...
17:39:33 <geheimdienst> ezyang: i have watched your video, and i suspect there is a problem with it in that elizabeth the fifth can't be an old girl when elizabeth the third is a young one. they clearly made a mistake here and are spreading wrongness
17:40:00 <ezyang> geheimdienst: I have no clue what you're talking about :^) 
17:40:39 <Philippa> elizabeth the third/fifth of where/which family? :p
17:42:45 <geheimdienst> clearly they must be in the same family. it would be too confusing to have a queen elizabeth from one family and later a queen elizabeth from another family. there is no name shadowing allowed here and ghc emits a warning if not an error
17:45:01 <cactus`> how can I simplify: \(a,b) -> do { pb <- foo b; return (a, pb) }
17:45:28 <copumpkin> @@ @pl @undo \(a,b) -> do { pb <- foo b; return (a, pb) }
17:45:29 <lambdabot>  uncurry (flip ((>>=) . foo) . (return .) . (,))
17:45:41 <copumpkin> that's the mechanical answer
17:45:44 <ezyang> there might be some arrow thing you can do. but monadic makes it trickier. 
17:45:52 <geheimdienst> @undo  \(a,b) -> do { pb <- foo b; return (a, pb) }
17:45:53 <copumpkin> :t \(a,b) -> do { pb <- foo b; return (a, pb) }
17:45:53 <lambdabot> \ (a, b) -> foo b >>= \ pb -> return (a, pb)
17:45:53 <lambdabot> Not in scope: `foo'
17:46:01 <copumpkin> :t \foo (a,b) -> do { pb <- foo b; return (a, pb) }
17:46:02 <lambdabot> forall t t1 (m :: * -> *) t2. (Monad m) => (t1 -> m t2) -> (t, t1) -> m (t, t2)
17:46:08 <copumpkin> ah ,that's not too bad
17:46:09 <geheimdienst> > fmap (1,2)
17:46:10 <lambdabot>   Couldn't match expected type `a -> b'
17:46:10 <lambdabot>         against inferred type `(t, t1)'
17:46:18 <geheimdienst> > fmap (+3) (1,2)
17:46:19 <lambdabot>   (1,5)
17:47:00 <geheimdienst> could something like this be possible? (fmap . fmap) foo (a,b)
17:47:11 <aristid> > fmap (chr . (+3) . ord) "geheimdienst"
17:47:12 <lambdabot>   "jhkhlpglhqvw"
17:47:33 <geheimdienst> omg teh name iz encryptioned
17:47:37 <copumpkin> :t (strength .) . fmap
17:47:38 <lambdabot> forall a1 (f :: * -> *) a a11. (Functor f) => (a11 -> f a) -> (a1, a11) -> f (a1, a)
17:47:47 <djahandarie> Damn nice copumpkin 
17:47:58 <aristid> geheimdienst: it's undecryptable!
17:48:01 <djahandarie> :t strength
17:48:01 <cactus`> :t strength
17:48:02 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => (a1, f a) -> f (a1, a)
17:48:02 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => (a1, f a) -> f (a1, a)
17:48:16 <aristid> @hoogle strength
17:48:17 <lambdabot> No results found
17:48:21 <copumpkin> now the challenge is to write strength ;)
17:48:31 <copumpkin> @djinn (Functor f) => (a1, f a) -> f (a1, a)
17:48:31 <lambdabot> Error: Class not found: Functor
17:48:33 <copumpkin> :)
17:48:42 <djahandarie> There is one in category-extras no?
17:48:44 <geheimdienst> :t (lolcats .). fmap
17:48:45 <lambdabot> Not in scope: `lolcats'
17:48:48 <djahandarie> I thought lambdabot didn't import that though
17:48:48 <copumpkin> strength = uncurry (fmap . (,))
17:48:52 <copumpkin> is the one I defined in PM :)
17:48:57 <djahandarie> Ah haha
17:49:02 <geheimdienst> what is PM?
17:49:06 <aristid> :t \(a, f) -> fmap (a, ) f
17:49:06 <lambdabot> parse error on input `)'
17:49:08 <djahandarie> A query window ;)
17:49:12 <copumpkin> private message
17:49:18 <geheimdienst> oh i see
17:49:27 <geheimdienst> @undef
17:49:30 <aristid> :t \(a, f) -> fmap ((,) a) f
17:49:31 <lambdabot> forall t a (f :: * -> *). (Functor f) => (t, f a) -> f (t, a)
17:49:45 <aristid> copumpkin: is that correct?
17:49:47 <copumpkin> yeah
17:49:48 <copumpkin> @pl \(a, f) -> fmap ((,) a) f
17:49:48 <lambdabot> uncurry (fmap . (,))
17:49:59 <cactus`> thanks copumpkin :P
17:50:15 <copumpkin> cactus`: and you magically lost your monad constraint too!
17:50:26 <copumpkin> now you can use it on non-monadz!
17:50:29 <Philippa> geheimdienst: the same family may have more than one numbering. Historical example: rule of Scotland vs England
17:50:45 <aristid> you can get back the monad constraint if you want
17:50:53 <aristid> :t uncurry (liftM . (,))
17:50:55 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => (a, m a1) -> m (a, a1)
17:51:00 <copumpkin> aw thanks
17:51:02 <djahandarie> copumpkin, ah, the strength in ce is different anyways
17:51:13 <copumpkin> djahandarie: does it do the fst instead of the snd?
17:51:29 <djahandarie> No it does something entirely different
17:51:31 <djahandarie> a -> f b -> f (a, b)
17:51:34 <copumpkin> that's just uncurried
17:51:39 <copumpkin> or rather, curried
17:51:55 <djahandarie> Ah
17:51:59 <djahandarie> Somehow neglected to see that
17:52:09 <copumpkin> > strength (5, [1..5])
17:52:10 <lambdabot>   Not in scope: `strength'
17:52:15 <copumpkin> damn, someone already got rid of it
17:52:22 <aristid> geheimdienst: you evil
17:52:23 <djahandarie> (Look up a couple lines)
17:52:38 <copumpkin> oh
17:52:41 <copumpkin> meanie
17:52:45 <ddarius> A functor is strong if its action on arrows is, itself, an arrow.
17:52:51 <aristid> djahandarie: nobody used strength for non-type purposes
17:54:00 <copumpkin> non-type purposes?
17:54:11 <geheimdienst> sorry guys for undefing ... i thought copumpkin was just messing with us
17:54:27 <copumpkin> :'(
17:54:34 <ddarius> A four token definition, lost forever.
17:54:42 * copumpkin sobs
17:55:06 <geheimdienst> i don't get it. shouldn't copumpkin have all the stuff in his private message window with lambdabot?
17:55:24 <copumpkin> I'm being silly
17:55:30 <copumpkin> it's the world's simplest definition
17:55:39 <geheimdienst> > (fmap . fmap) (+3) (1, Just 4) -- anyhoo, i like this, just because it's mine.
17:55:40 <lambdabot>   (1,Just 7)
17:55:58 <copumpkin> > (fmap fmap fmap) (+3) (1, Just 7)
17:55:59 * ddarius doesn't think he can sanely implement Joy's ifte.
17:55:59 <lambdabot>   (1,Just 10)
17:56:17 <geheimdienst> omg u has moar in ur Just!
17:56:23 <copumpkin> yep
17:56:25 <geheimdienst> > Just 14
17:56:26 <lambdabot>   Just 14
17:56:28 <copumpkin> plus I can fmap harder than you can
17:56:50 <geheimdienst> copumpkin: eek, this is not a masturbation contest
17:56:59 <ddarius> copumpkin: You parens are unnecessary.
17:57:08 <copumpkin> I was reflecting his structure
17:57:41 <geheimdienst> i was just being absolutely clear
17:57:55 <copumpkin> @check \xs -> (join (***) join) xs == (join *** join) (xs :: [[Int]])
17:57:56 <lambdabot>   Couldn't match expected type `[[GHC.Types.Int]]'
17:58:02 * ddarius thinks his r button is iffy.
17:58:11 <geheimdienst> you may take the excess parens out and save them in a file, for later use, or for bad times
17:58:22 <copumpkin> @check \xs -> (join (***) join) xs == (join *** join) (xs :: ([[Int]], [[Int]]))
17:58:25 <lambdabot>   "OK, passed 500 tests."
17:58:34 <ddarius> geheimdienst: Your expression had no excess parentheses.
17:58:52 <geheimdienst> > fmap . fmap (+3) (1, Just 4)
17:58:53 <lambdabot>   Couldn't match expected type `a -> b'
17:58:53 <lambdabot>         against inferred type `Data.M...
17:59:09 <copumpkin> you should always wrap your fmaps
17:59:11 <blackdog> geheimdienst: pass them down to your children. one day, they'll be delighted to receive their father's parentheses.
17:59:29 <geheimdienst> > fmap . fmap $ (+3) $ (1, Just 4)
17:59:30 <lambdabot>   Couldn't match expected type `a -> b'
17:59:30 <lambdabot>         against inferred type `(t, Da...
17:59:49 * ddarius also can't implement rolldownd because his implementation only recognizes the first 8 characters of an identifier and there is already a rolldown.
17:59:54 <geheimdienst> > (+1) . (+4) 16
17:59:54 <megajosh2> That'd be applying (1, Just 4) to (+3)
17:59:55 <lambdabot>   No instance for (GHC.Num.Num (f a))
17:59:55 <lambdabot>    arising from a use of `e_11416' at <...
18:00:13 <copumpkin> ddarius: what are you doing again? last time I asked, you responded that it was a good question :)
18:00:14 <geheimdienst> > (+1) . (+4) $ 16
18:00:15 <lambdabot>   21
18:01:21 <geheimdienst> 3am syntax differs from daylight syntax by its advanced decomposition, incoherency, and mistakitude
18:02:24 <djahandarie> @let (****) = (\f n v -> (iterate f v) !! n)
18:02:25 <lambdabot>  Defined.
18:02:34 <copumpkin> ::O
18:02:57 <djahandarie> > fmap **** 3 . (+3) $ (1, Just 7)
18:02:58 <lambdabot>   Precedence parsing error
18:02:58 <lambdabot>      cannot mix `L.****' [infixl 9] and `L..' [inf...
18:03:02 <djahandarie> Gah
18:03:09 <djahandarie> > (fmap **** 3) . (+3) $ (1, Just 7)
18:03:10 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
18:03:14 <djahandarie> Damn
18:03:17 <djahandarie> Stupid fmap
18:03:33 <djahandarie> > (+3) **** 3 $ 4
18:03:34 <lambdabot>   13
18:03:39 <djahandarie> At least that works :P
18:03:50 <ddarius> copumpkin: I have something which boots, initializes the processor, enumerates the hardware, has some simple drivers for some hardware, and a compiler for a restricted Joy-like language.
18:03:57 <copumpkin> wow :)
18:04:13 <copumpkin> do you run it in a VM?
18:04:46 <ddarius> copumpkin: In QEMU, yes.  Though I'm considering putting it on a USB flash drive because the hardware setup provided by QEMU is a bit simplistic.
18:04:49 <geheimdienst> > (+3) **** 3 4
18:04:50 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:04:50 <lambdabot>    arising from a use of `...
18:05:43 <djahandarie> :t ^^
18:05:44 <lambdabot> parse error on input `^^'
18:05:49 <djahandarie> :t (^^)
18:05:50 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
18:05:56 <djahandarie> :t (^^^)
18:05:57 <lambdabot> Not in scope: `^^^'
18:06:04 <megajosh2> > let (/\) a b = (\c -> a + b * c) in (2 /\ 3) 5
18:06:05 <lambdabot>   17
18:06:08 <megajosh2> > let (/\) a b = (\c -> a + b * c) in 2 /\ 3 5
18:06:08 <djahandarie> Maybe that's a nicer operator
18:06:09 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
18:06:09 <lambdabot>    arising from a use of `...
18:06:19 <megajosh2> Hmm
18:06:53 <djahandarie> I'd really just like to do (+3)^3   (I mean for any function a->a, not just nums)
18:07:52 <megajosh2> > let pie = 3.14 in (+3).(^3) $ pie
18:07:53 <lambdabot>   33.959144
18:07:55 <megajosh2> > let pie = 3.14 in (+3).(^3) pie
18:07:56 <lambdabot>   No instance for (GHC.Real.Fractional (f a))
18:07:56 <lambdabot>    arising from a use of `e_131...
18:07:58 <megajosh2> :(
18:08:10 <djahandarie> > (+3)^3 $ pi
18:08:11 <lambdabot>   231.65571793702844
18:08:27 <megajosh2> Woah what happened here?
18:08:32 <djahandarie> Magic!
18:09:04 <aristid> :t [\f -> f . f, \f -> f . f . f]
18:09:05 <lambdabot> forall b. [(b -> b) -> b -> b]
18:09:10 <djahandarie> > (*2)+(*3) $ 4
18:09:10 <lambdabot>   20
18:09:23 <aristid> :t [\f -> f . f, \f -> f . f . f, \f -> f . f . f . f]
18:09:24 <lambdabot> forall b. [(b -> b) -> b -> b]
18:09:31 <ddarius> @src (^)
18:09:31 <lambdabot> x ^ 0            =  1
18:09:31 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
18:09:31 <lambdabot>   where f _ 0 y = y
18:09:31 <lambdabot>         f x n y = g x n
18:09:31 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
18:09:33 <lambdabot>                       | otherwise = f x (n-1) (x*y)
18:09:35 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
18:11:03 * geheimdienst successfully employs a matchbox to capture an irritating ladybug and release her out the window
18:11:13 <copumpkin> > toChurch 5 (+1) 0
18:11:14 <lambdabot>   5
18:11:28 <ddarius> > let x ^ 0 = mempty; x ^ n | n > 0 = f x (n-1) x where f _ 0 y = y; f x n y = g x n where g x n | even n = g (x `mappend` x) (n `quot` 2) | otherwise = f x (n-1) (x`mappend`y) in appEndo (Endo (+3)^3) 0
18:11:29 <lambdabot>   9
18:11:31 <geheimdienst> > (*2) + (*3)
18:11:32 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:11:32 <lambdabot>    arising from a use of `...
18:11:40 <copumpkin> > toChurch 4 (^2) 3
18:11:41 <lambdabot>   43046721
18:11:52 <geheimdienst> > fromChurch 123
18:11:53 <lambdabot>   Not in scope: `fromChurch'
18:12:10 <djahandarie> ddarius, what in the world did you just do there
18:12:21 <copumpkin> @let fromChuch f = f (+1) 0
18:12:22 <lambdabot>  Defined.
18:12:24 <ddarius> Generalized (^) to all monoids.
18:12:28 <copumpkin> :t fromChurch
18:12:29 <lambdabot> Not in scope: `fromChurch'
18:12:33 <copumpkin> :t fromChuch
18:12:34 <copumpkin> lol
18:12:34 <lambdabot> forall a t t1. (Num a, Num t) => ((a -> a) -> t -> t1) -> t1
18:13:17 <djahandarie> ddarius, that's pretty neat
18:13:55 <TeachmeHaskell> Hello folkz
18:14:58 <Veinor> :t fromCheech $ Chong
18:14:59 <lambdabot> Not in scope: `fromCheech'
18:14:59 <lambdabot> Not in scope: data constructor `Chong'
18:15:03 * TeachmeHaskell where is the best place to learn Java
18:15:03 <Veinor> :D
18:15:44 <Philippa> the nearest termination booth
18:16:03 <megajosh2> The best place to learn Java is in the depths of Hell itself?
18:16:17 <megajosh2> I oughtta keep that one on a sticky note somewhere
18:16:25 <TeachmeHaskell> lol
18:16:28 <hpc> a coffee shop
18:17:08 <Kaidelong> Java is not particularly difficult to grasp
18:17:12 <Kaidelong> just read the docs
18:17:19 <Kaidelong> that's one of the nicer things about it
18:18:01 <TeachmeHaskell> Kaidelong thnx
18:18:34 <Kaidelong> Also virtually everyone knows it so if you run into trouble just show it to someone
18:18:59 <copumpkin> note that that doesn't mean you should ask about java in here
18:19:07 <copumpkin> it just means that we probably all know it but come here to escape it
18:19:18 <geheimdienst> > uncurry (++) $ (take 1 &&& drop 4) "Haskell"
18:19:19 <lambdabot>   "Hell"
18:19:44 <geheimdienst> omg
18:19:48 <Kaidelong> :t (&&&)
18:19:49 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:19:57 <TeachmeHaskell> Ok
18:19:58 <Kaidelong> ah category theory
18:20:08 <Philippa> copumpkin: I'm proud to say I couldn't write much Java code without a reference :p
18:20:09 <geheimdienst> > ((+1) &&& (+4)) (6,9)
18:20:10 <lambdabot>   ((7,10),(10,13))
18:20:18 <copumpkin> oh ok :)
18:20:21 <copumpkin> Kaidelong: I wouldn't say that
18:20:40 <Philippa> admittedly it'd be 90% syntactic and the rest'd be learning new features since I last used it, which was 1.3
18:20:42 <geheimdienst> > ((+1) &&& (+4)) 6
18:20:43 <lambdabot>   (7,10)
18:20:47 <copumpkin> Kaidelong: it's just rather abstract haskell, that like many things in haskell, happens to have a CT interpretation (but not a very obvious one)
18:20:59 <Kaidelong> well looks familiar also I think I know how it works which is amazing
18:21:11 <Kaidelong> checked out a CT book
18:21:17 <copumpkin> if a were replaced by (~>) it'd be a lot clearer
18:21:19 <geheimdienst> Kaidelong: it just takes two functions and runs them both on the same arguments
18:22:08 <geheimdienst> and i don't think &&& should be counted as category theory because &&& can be actually useful in actual programs
18:22:09 <geheimdienst> ;)
18:22:24 <Kaidelong> looks like it'd be most useful for obfuscation
18:22:32 <copumpkin> nah
18:22:33 <Kaidelong> but a lot of cool stuff is like that
18:22:49 <TeachmeHaskell> what is  category theory
18:23:04 * TeachmeHaskell is a noob
18:23:06 <TeachmeHaskell> :)
18:23:26 <Kaidelong> categories are things with objects, arrows, and arrow composition where arrow composition has to be associative and a lot of programming related things are categories
18:23:31 <djahandarie> It's a branch of math that Haskell borrows some names from
18:23:35 <geheimdienst> well suppose you have a record and want to get two things out of it ... (width && height) $ (window desktop screen)
18:23:46 <geheimdienst> er, &&& of course
18:23:54 <Philippa> djahandarie: a bit more than names, to be fair. We tend to try to encode a lot of the concepts, modulo various concerns
18:24:05 <djahandarie> Philippa, that was meant to be a jab :P
18:24:06 <TeachmeHaskell> i see
18:24:07 <JoeyA> Can anyone think of a standard Haskell that requires one of its arguments to implement two classes?
18:24:12 <Philippa> (_|_) being the most commonly elided thing
18:24:17 <TeachmeHaskell> Thank you guys
18:24:18 <JoeyA> as in, something of the form func :: (Foo a, Bar a) => a -> ...
18:24:22 <Philippa> djahandarie: well yeah. But remembering to state the modulo is important :-)
18:24:44 <geheimdienst> :t (<)
18:24:45 <lambdabot> forall a. (Ord a) => a -> a -> Bool
18:24:56 <geheimdienst> :t (>=)
18:24:57 <TeachmeHaskell> i see
18:24:57 <lambdabot> forall a. (Ord a) => a -> a -> Bool
18:25:20 <JoeyA> Ord implies Eq
18:26:02 <Philippa> JoeyA: a library func, or just something written in H98?
18:26:02 <geheimdienst> yeah 8-) i thought it was gonna tell us (Ord a, Eq a) ...
18:28:35 <geheimdienst> :t Real
18:28:36 <lambdabot> Not in scope: data constructor `Real'
18:28:45 <geheimdienst> @src Real
18:28:46 <lambdabot> class  (Num a, Ord a) => Real a  where
18:28:46 <lambdabot>     toRational      ::  a -> Rational
18:28:51 <JoeyA> I'm looking for an example of where you'd want to require a 2-fer in an argument.
18:29:22 <JoeyA> Which is analogous to requiring an argument to a function in an OO language to implement 2 interfaces.
18:29:39 <Saizan> :t [1..10]
18:29:40 <lambdabot> forall t. (Num t, Enum t) => [t]
18:30:06 <Philippa> :t print . sort
18:30:07 <TeachmeHaskell> > [1..10]
18:30:07 <lambdabot> forall a. (Show a, Ord a) => [a] -> IO ()
18:30:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:30:08 <JoeyA> You could subclass interfaces (like you just did with Real) to get the same semantic, but it's rather ugly when you want to do it ad-hoc.
18:30:15 <TeachmeHaskell> nice :)
18:30:19 <JoeyA> heh
18:30:27 <Philippa> JoeyA: make sense?
18:31:01 <JoeyA> yup
18:32:39 <TeachmeHaskell> i wanna understand how to work with this bot
18:32:51 <TeachmeHaskell> what is @src?
18:33:54 <Philippa> :src print
18:33:57 <Philippa> @src print 
18:33:57 <lambdabot> Source not found. Take a stress pill and think things over.
18:34:00 <Philippa> even
18:34:04 <Philippa> it looks for the source for print
18:34:09 <Philippa> @src ++
18:34:09 <lambdabot> []     ++ ys = ys
18:34:10 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
18:34:10 <lambdabot> -- OR
18:34:10 <lambdabot> xs ++ ys = foldr (:) ys xs
18:34:17 <TeachmeHaskell> oh ok
18:34:20 <JoeyA> > fix error
18:34:21 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:34:23 <geheimdienst> TeachmeHaskell: i guess the most sensible thing would be if you first played with http://tryhaskell.org . it's similar to lambdabot. also, check out http://learnyouahaskell.com/
18:34:28 <JoeyA> That is all you know, and all you ever need to know.
18:34:42 <Philippa> JoeyA: heh
18:34:58 <megajosh2> @src fix
18:34:58 <lambdabot> fix f = let x = f x in x
18:35:10 <TeachmeHaskell> geheimdienst ok thnx
18:38:49 <megajosh2> I'm a little bit confused here... fix f does `f (f (f (f (f ...' ad infinitum right?
18:39:40 <megajosh2> > fix (1:)
18:39:41 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:54:39 <megajosh2> > (1:) (1:) 1
18:54:40 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[t2]'
18:54:49 <megajosh2> > (1:) $ (1:) 1
18:54:50 <lambdabot>   No instance for (GHC.Num.Num [t])
18:54:50 <lambdabot>    arising from a use of `e_1111' at <int...
18:55:25 <megajosh2> > (1:) (1:) [1]
18:55:26 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[t2]'
18:55:55 <megajosh2> > take 20 $ show [1..]
18:55:56 <lambdabot>   "[1,2,3,4,5,6,7,8,9,1"
18:56:46 <systemfault> BONUS: I love you <3 I'll buy your book when it comes out :)
19:04:26 <mm_freak> > (1:) ((1:) [1]))
19:04:27 <lambdabot>   <no location info>: parse error on input `)'
19:04:29 <mm_freak> > (1:) ((1:) [1])
19:04:30 <lambdabot>   [1,1,1]
19:13:13 <donri> > ''
19:13:14 <lambdabot>   <no location info>:
19:13:14 <lambdabot>      lexical error in string/character literal at chara...
19:13:19 <donri> Why that indentation?
19:13:28 <kmc> which?
19:13:32 <donri> > ""
19:13:33 <lambdabot>   ""
19:14:00 <donri> It prepends some three spaces or so
19:14:12 <donri> two
19:14:40 <kmc> to avoid infinite bot loops, bots are supposed to write output starting with ' ' and only react to commands starting with not ' '
19:14:52 <kmc> though not all lambdabot's commands do this
19:15:05 <kmc> @. elite nixon
19:15:05 <lambdabot> A/\/\3rI(aN$ admIre A Pe0PLe \/\/Ho (An $(RatcH 4 D3S3r+ AND pRodUc3 a G4RDEN. +HE izR4eLi5 |-|aVE s|-|OWn QuAlI7i35 ThAT 4mERIC4n5 IDeN7IphY WI+|-|: Gut$, PAtrio7izM, idEa1Is/\/\, 4 P4$zION 4
19:15:06 <lambdabot> FRE3Do/\/\. I HaVe s3En i+. i knoW. I bE1iE\/E tHaT.
19:16:14 <mjrosenb> kmc: i thought the irc guidelines said that bots should never respond by just speaking.
19:17:09 <kmc> maybe
19:17:12 <kmc> i think they're supposed to use NOTICE
19:17:22 <kmc> but clients tend to render NOTICE in an annoying way
19:17:38 <monochrom> substandard clients
19:18:20 <monochrom> it's almost like a prank. someone wrote software to display each notice in its own dialog box
19:19:06 * mjrosenb has no clue how irssi handles notice.
19:19:52 * ninly was thinking the same thing
19:19:52 <djahandarie> It just shows it in-channel with a different colour, or in another window if you have it set up that way
19:19:56 -Eridius(~kevin@unaffiliated/eridius)- This is a notice
19:20:04 <mjrosenb> although i suspect it does not pop up a dialog box
19:20:05 <Eridius> I just sent a notice to the room
19:20:17 <djahandarie> mjrosenb, haha that would be pretty odd indeed
19:20:17 * ninly now knows
19:20:34 <Eridius> now I'm curious as to how it looks on the receiving end, can someone else do the same?
19:20:38 <systemfault> A notice!
19:20:42 * systemfault feels important
19:21:06 -ninly(~ninly@69.73.94.145)- sure thing
19:21:17 <systemfault> :)
19:21:18 <Eridius> neat
19:21:28 <ninly> preety
19:21:35 <Eridius> apparently notices directly to me show up in (status), though presumably if I have a query window open for the sender it'll go there instead
19:21:51 <djahandarie> fyi noticing the channel might behave badly on other people's clients
19:22:04 <monochrom> at any rate, not dialog boxes in sane software
19:22:06 <djahandarie> And others in here may not be as interested to see what happens
19:22:19 <ninly> yes sorry to those of them
19:22:30 <Eridius> I believe NOTICE is supposed to be less intrusive than normal messages, so any client that displays it as _more_ intrusive is simplyw rong
19:22:30 <djahandarie> (Trying to present something and some irc box pops up ;))
19:22:48 <djahandarie> Eridius, well, that's how specs/software go ;)
19:22:56 <Philippa> Eridius: one of the biggest clients on windows beeps every time
19:22:59 <Eridius> ewww
19:23:03 <monochrom> people just shouldn't use bad software
19:23:15 <Eridius> clearly we should all talk in notices, to force people to stop using bad clients
19:23:17 <ninly> we should tell them
19:23:22 <ninly> yes, in notices
19:23:26 <Philippa> yeah, but I've not found a windows client that isn't a POS. Telling me not to use windows will not go down well
19:23:31 <djahandarie> monochrom, except bad is a net sum... and some people may value certain parts more than others ;)
19:23:36 <djahandarie> monochrom, I want my text to be pretty!
19:23:59 <tux0> what is lambdabot running on?
19:24:08 <tux0> eggdrop?
19:24:10 <Philippa> pure mindpower
19:24:10 <djahandarie> It's a Haskell program
19:24:20 <djahandarie> You can get it yourself
19:24:21 <kmc> @hackage lambdabot
19:24:21 <lambdabot> http://hackage.haskell.org/package/lambdabot
19:24:25 <mjrosenb> djahandarie: irssi isn't pretty?
19:24:26 <djahandarie> And kmc beat me to it
19:24:37 <tux0> well it should reply to a ctcp version request imho
19:24:46 <monochrom> alright, people may use good or bad software at their own expense. we should just act like they use good software, and they can pick their poison
19:24:47 <Philippa> mjrosenb: irssi didn't have decent integration with notification facilities last time I looked, which was admittedly a while back
19:24:47 <djahandarie> tux0, patch!
19:24:52 <Philippa> still my console client of choice
19:24:54 <systemfault> The two coolest bots I know on Freenode are written in haskell :D
19:25:00 <djahandarie> (Meaning that I nor anyone else wants to touch that ugly codebase so you need to ;))
19:25:03 <systemfault> lambdabot & geordi
19:25:14 <kmc> ##c++ too good for their own dogfood eh
19:25:20 <systemfault> :P
19:25:28 <Philippa> monochrom: I think it's fair to say that particular provision of the RFC isn't observed in practice and is dead in the water, though
19:25:29 <tensorpudding> would you want to write an irc bot in C++?
19:25:31 <kmc> geordi is pretty cool
19:25:33 <djahandarie> Philippa, you can hook it into libnotify with a pre-made perl plugin
19:25:52 <djahandarie> Philippa, dunno if there is some sort of Windows compatibility layer thing for that
19:25:55 <Philippa> djahandarie: cool
19:26:47 <kmc> tensorpudding, well, i don't know if the party line in ##c++ is that C++ is a general purpose language or a low-level systems / weird-shit language
19:27:10 * djahandarie uses it for the later
19:27:10 <kmc> i've only spent a little time there and usually i end up asking pointed questions so i left
19:27:14 <Philippa> it's shit at both, but hey
19:27:19 <djahandarie> latter*
19:27:35 <djahandarie> I don't do very much C++ at all really
19:27:43 <Philippa> low-level languages make me want high-level module facilities and all kinds of other stuff /more/, not less
19:27:44 <djahandarie> I know it does well in things like x264
19:27:51 <tensorpudding> I think most people write in C++ in situations where they don't have many other choices
19:27:57 <djahandarie> (In combination with ASM)
19:28:03 <systemfault> tensorpudding: Indeed.
19:28:11 <Philippa> djahandarie: yeah, that's a task where C++ is the only viable mainstream lang
19:28:20 <tensorpudding> In places where C++ is the norm, like graphics programming and games.
19:28:28 <systemfault> Anything CPU intensive.
19:28:28 <kmc> C++ is the best solution for certain niches, but it's still unnecessarily terrible there
19:28:35 <kmc> and attempts to make new languages for that niche have faile
19:28:39 <tensorpudding> Isn't CUDA C++?
19:28:41 <Vanadium> Does anyone have experience with ieee754-parser? It seems to consume 32 bytes to read a 32-bit floating point number, but I might just be doing it wrong.
19:28:50 <kmc> reasons for which i'd be interested to discuss with anyone, not here
19:28:54 <kmc> (since it'd be off topic)
19:28:59 <tensorpudding> Or is it C
19:29:08 <Denismk> hey guys
19:29:14 <kmc> hi Denismk
19:29:22 <Denismk> i need some help
19:29:23 <copumpkin> Vanadium: that sounds bad :P
19:29:27 <Philippa> kmc: the level of C compatibility required of any successor language is a real problem :-(
19:29:39 <kmc> Philippa, every self-respecting language has a C FFI
19:29:40 <Denismk> i need some macros for hunter any1 know?
19:29:44 <tensorpudding> CUDA has wrappers for Python, Java, Perl and Fortran though
19:29:54 <kmc> Denismk, i have no idea what you're asking about, is it related to the Haskell programming language?
19:30:04 <Vanadium> I am apparently unable to find something on hackage that takes four bytes out of a bytestring and gives me a float in return
19:30:10 <Denismk> ofc not
19:30:11 <kmc> a lot of C++'s problems come down to trying (though failing) to keep C source compatibility, rather than providing a clean isolated FFI
19:30:12 <monochrom> who is hunter?
19:30:15 <kmc> Denismk, why are you asking here?
19:30:28 <Denismk> first time i join to irc on this site
19:30:30 <Denismk> where to go?
19:30:37 <kmc> Denismk, what is 'hunter'?
19:30:44 <Philippa> kmc: yeah, but really a successor language needs to be able to import headers near-directly
19:30:48 <monochrom> or perhaps who is "hunter any1"?
19:30:50 <Saizan> Vanadium: maybe the Storable instance for Float?
19:30:52 <kmc> Philippa, sure
19:30:54 <Philippa> including #defined constants and stuff
19:30:59 <Denismk> hunter is when some guy go to your mom while your dad work...and he start to ....
19:31:03 <kmc> Philippa, it needs something like hsc2hs or maybe cleverer
19:31:08 <tensorpudding> Why is #haskell where lost newbies ask for directions?
19:31:16 <Saizan> Vanadium: plus some messing with bytestring's internals
19:31:17 <Vanadium> Saizan: That sounds like an illegal C cast :V
19:31:19 <Jafet> Because they sort the channel list by size.
19:31:20 <kmc> tensorpudding, because it's a big channel on Freenode with the word 'programming' in the topic
19:31:22 <Philippa> because we're big and have 'programming' in the topic
19:31:23 <monochrom> because ##c++ point them here
19:31:30 <kmc> terrorists!
19:31:39 <tensorpudding> unauthorized redirection!
19:31:54 <djahandarie> Vote in favor of removing the word programming in the topic
19:31:58 <systemfault> Kill all C++ users!
19:32:14 <Jafet> @elite The Haskell programming language
19:32:14 <lambdabot> the |-|A5xEL| pRoGr4mMiN9 1anGuA9e
19:32:27 <monochrom> would you accept "the haskell prog lang"?
19:32:48 <systemfault> The Haskell Lifestyle.
19:32:56 <kmc> the Church of Haskell
19:33:17 <djahandarie> I would accept "the standardized, general-purpose purely functional programming langue with non-strict semantics and strong static typing"
19:33:22 <djahandarie> Nothing else!
19:33:38 <kmc> "Haskell: the pragmatic alternative to Haskell"
19:33:46 <systemfault> Haha
19:33:48 <systemfault> Good one.
19:34:15 <Philippa> "Haskell: no more dysfunctional programming"?
19:34:28 <djahandarie> kmc, which would actually hold true depending on who is writing the code ;)
19:34:31 <Philippa> > fix C++
19:34:32 <Veinor> go hunter2 yourself
19:34:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:34:41 <ninly> i was going to suggest "the Haskell tongue" but that would probably attract even worse
19:34:41 <Veinor> fix error is my favorite thing
19:34:50 <Philippa> fix error is great
19:34:58 <systemfault> the bot should answer: It can't be done, C++ sucks too much.
19:34:59 <systemfault> :/
19:35:10 <djahandarie> Veinor, it is also accurate in its output.
19:35:11 <Veinor> I imagine someone reading it in some snippet somewhere and thinking it's a ghci command that auto-fixes parse errors
19:35:24 <djahandarie> The only thing that happens when you try to fix an error is get even more errors!
19:35:31 <Veinor> :D
19:36:18 <djahandarie> "I tried to fix my error and it didn't work! GHCI's debugger sucks!"
19:36:54 <Philippa> > fix c++
19:36:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:36:58 <systemfault> Well.. I still sucks at deciphering ghc errors
19:37:13 <Philippa> learning to think like the typechecker takes a while
19:37:16 <systemfault> I'm better at deciphering pages of C++ template errors
19:41:54 <copumpkin> I don't really understand http://www.reddit.com/r/haskell/comments/dmdcw/typed_typelevel_functional_programming_in_ghc/c11hm2o
19:42:21 <copumpkin> he's saying IO in particular should be untyped?
19:43:07 <danharaj> That is such an asinine argument and it manages to conflate two unrelated things (monads and curry-howard).
19:43:29 <danharaj> It's as preposterous a claim as saying people can't figure out OOP because you tell them they should use Delegates and MVC to do GUI work.
19:45:05 <Kaidelong> I don't get why the IO monad would be a bad thing
19:45:15 <copumpkin> it's a bad thing for other reasons
19:45:30 <copumpkin> but I've never heard of anyone suggesting the actual presence of a type is bad
19:45:35 <Kaidelong> it seems like once you wrap your head around it though it's quite easy to use
19:45:47 <Kaidelong> just like random number generators
19:45:47 <copumpkin> preflex: seen dmead
19:45:48 <preflex>  dmead was last seen on #haskell 8 days, 19 hours, 20 minutes and 37 seconds ago, saying: @hoogle BDecls
19:47:37 <Kaidelong> I suppose the fundamental problem is that people say and think monads are fancy things
19:48:06 <Saizan> if java programmers can understand the distinction between statement and expressions they can use do-notation, if the problem is that you can't/aren't supposed to do I\O from pure code you can't work around that without throwing away the language altogether
19:48:31 <copumpkin> I think the issue is the word more than the concept
19:48:41 <copumpkin> most people are just turned off by anything that sounds remotely mathematical
19:48:59 <danharaj> imperative programmers hate that they have to relearn programming from a declarative viewpoint.
19:48:59 <Philippa> call it a 'box'
19:49:04 <Kaidelong> F# uses the word workflow for monad and computation expression for monad comprehension
19:49:07 <Philippa> we throw stuff in the IO box if it does IO
19:49:18 <Philippa> see? It's even boxed in the IO constructor 
19:49:38 <danharaj> you don't have to call it anything. It's a type constructor that let's you string together functions in a special way.
19:50:29 <copumpkin> http://www.reddit.com/r/haskell/comments/dmdcw/typed_typelevel_functional_programming_in_ghc/c11hp6x
19:50:32 <copumpkin> o.O
19:51:24 <siracusa> I'm looking for a way to write a large data structure (~800MB in memory) to a file and then load it back to memory. Is there something that's faster then show/read?
19:51:59 <copumpkin> siracusa: Data.Binary
19:52:14 <Philippa> danharaj: it's kinda tricky not calling it anything, because we don't actually have a name for those values
19:52:36 <danharaj> well I meant the name is unimportant.
19:52:48 <Philippa> yeah, but having one is important for a lot of people's thought processes
19:52:48 <danharaj> the structure is what is important.
19:53:13 <Philippa> otherwise, constructs they'd naturally create as they think have gaps in them, and that makes heads hurt
19:53:56 <danharaj> you can teach IO without teaching monad. You can refer to it as the IO type constructor, and just describe the structure it has.
19:54:14 <Philippa> yes, I know this
19:54:26 <danharaj> I think it is backwards to teach the general idea before the concrete example is mastered.
19:54:29 <Philippa> but people still want to know "what do I call a value of type IO String?"
19:54:33 <Kaidelong> you'd end up teaching the monad inadvertantly anyway
19:54:42 <copumpkin> not really
19:54:52 <danharaj> "An effect"
19:54:52 <copumpkin> you can pretend IO is mostly like an imperative procedure
19:54:56 <copumpkin> except for early return
19:55:00 <Philippa> danharaj: *puke*
19:55:03 <copumpkin> ContT IO :P
19:55:06 <Philippa> (it might not have an effect, for one)
19:55:18 <copumpkin> with an implicit callCC around all ContT IO-wrapped things
19:55:26 <danharaj> A non-effect is an effect in the same way 0 is a number.
19:55:50 <Saizan> a value of type IO String is often called an action, no?
19:56:01 <Saizan> that doesn't require monads to make sense of
19:56:03 <Philippa> Saizan: yup, and that's a good name for it
19:56:27 <danharaj> I like effect better because it emphasizes that the reason why we even have IO in the first place is because side effects are the structure we need on top of pure code.
19:56:29 <Philippa> my point isn't that these are hard questions, just that they're issues
19:57:03 <Philippa> danharaj: it's really, really ugly language from where I'm standing. Amongst other things, it throws away the computational aspect of the entity
19:57:07 <Saizan> starting with "reified statement" might be helpful, actually
19:57:26 <Philippa> Saizan: *nod*. It's not a name I'd keep around, but a description? Sure
19:57:36 <danharaj> Philippa: I don't think IO has any computational structure on it. All IO encodes is the order of side effects.
19:57:38 <Saizan> yeah
19:57:48 <Kaidelong> how about calling it a program?
19:57:57 <Kaidelong> that can be "run"
19:58:01 <Kaidelong> to get the value
19:58:01 <Philippa> danharaj: then you missed this rather large elephant called the underlying category
19:58:06 <danharaj> Kaidelong: that's good because all haskell programs are IO statements.
19:58:17 <Philippa> it's as much part of the structure as anything else in it
19:58:26 <danharaj> Philippa: I don't follow. What about the underlying category?
19:58:46 <Philippa> a value of type IO String, when executed, will do computation. It may well be non-trivial computation (that is, not equivalent to id)
19:59:45 <Philippa> the means to do it is yoinked straight out of Hask, sure, but it's still part of the structure
19:59:46 <danharaj> Philippa: but we can't observe the computation. All we observe is that IO a may have caused a side effect and that we can compose it with another 'action/effect/program' that requires a value of type a.
20:00:11 <Philippa> danharaj: except that, because of the types involved in >>=, we can observe that values come out as well
20:00:54 <Philippa> we have no clue how the hell it happens, but we know that lone a didn't come from anywhere else
20:01:00 <Philippa> because it's clearly not always _|_
20:01:06 <danharaj> Philippa: The IO in IO a encodes the side effect structure. The 'a' encodes that you can observe a value from it. I don't think we should care about how it got there.
20:01:34 <Philippa> if you want to call /IO/ an effect, sure. An IO string is an effecting computation, though
20:01:53 <danharaj> But what is a computation?
20:02:01 <danharaj> Is getting a string from stdin a computation?
20:02:29 <Cale> danharaj: In this context, yes
20:02:35 <djahandarie> Why not just make IO like all the other monad instances? As in, don't require the monad interface to use it
20:02:41 <Philippa> it contains a null computation, if you like. Getting and /reversing/ it contains an actual computation
20:02:51 <Cale> djahandarie: It is like that already?
20:02:56 <danharaj> Cale: I guess.
20:03:25 <djahandarie> Cale, eh?
20:03:26 <danharaj> Philippa: I think we should distinguish between the computation a programmer puts into f :: a -> M b and the computational structure of M
20:03:40 <Philippa> danharaj: the computational structure of M subsumes that of haskell
20:03:48 <danharaj> I don't know what that means.
20:03:58 <Cale> djahandarie: The fact that IO is a monad is secondary and only describes part of the API for manipulating IO actions. The major new idea in Haskell is that IO actions are values in the first place.
20:04:03 <Philippa> look at the type of return. The 'monad language' includes all of haskell
20:04:17 <danharaj> When I say computational structure I mean "structure on top of what you do in pure code." for example, the continuation monad adds continuations to your computational structure.
20:04:21 <djahandarie> Cale, it shouldn't define any part of the API.
20:04:24 <danharaj> IO adds side effects.
20:04:27 <Cale> djahandarie: ?
20:04:31 <Philippa> yes, quite. You're arguing it's not there because you defined it as being not there
20:04:32 <Cale> djahandarie: That's all that a monad is
20:04:48 <Cale> djahandarie: A monad is a type constructor which supports a particular API.
20:04:58 <djahandarie> Cale, could you define the monad instance for IO?
20:05:04 <Cale> (that includes return and >>= and goes from there)
20:05:11 <danharaj> djahandarie: in what language ;)
20:05:14 <djahandarie> In Haskell.
20:05:35 <Cale> djahandarie: If I had control over the way the runtime system worked, then yes, I could define it in Haskell.
20:05:37 <danharaj> I could provide a definition that respects all the specifications the standard makes about IO.
20:05:50 <Philippa> djahandarie: consider that monads with no real computational content are easily thought of as 'degenerate'...
20:06:12 <Philippa> ("no real computational content" - the monad whose only value is _|_, for example)
20:06:23 <DegenerateMonad> :(
20:06:34 <djahandarie> IMHO IO should just provide two functions that are a -> IO a, and IO a -> (a -> IO a) -> IO b
20:06:35 <Cale> djahandarie: There would be a little bit of awkwardness I haven't quite worked out the details for surrounding FFI, but nothing too major.
20:06:36 <DegenerateMonad> y'all think I'm dumb
20:06:37 * Philippa pokes DegenerateMonad's (_|_)
20:06:44 <DegenerateMonad> lol
20:06:49 <djahandarie> And then declare a monad instance with those two functions
20:07:00 <Cale> djahandarie: It *does*
20:07:06 <Cale> djahandarie: return and >>= have those types
20:07:25 <Cale> (modulo the typo)
20:07:31 <djahandarie> Not in their generic form.
20:07:34 <Philippa> djahandarie: all that's happening here is you arbitrarily disregard the computational structure inherent in a monad and I don't like that, and that's reflected in our naming preferences, right?
20:07:49 <djahandarie> Philippa, I do?
20:08:17 <Cale> djahandarie: If you want less-polymorphic versions of them, you can make definitions:
20:08:23 <Philippa> djahandarie: 'When I say computational structure I mean "structure on top of what you do in pure code." ' - given that monads contain what you do in pure code, that's arbitrary
20:08:29 <DegenerateMonad> bindIO and returnIO
20:08:36 <danharaj> that was me :|
20:08:40 <Philippa> oh, right
20:08:43 <Philippa> my bad
20:08:45 <Cale> returnIO :: a -> IO a; returnIO = return; bindIO :: IO a -> (a -> IO b) -> IO b; bindIO = (>>=)
20:08:54 <djahandarie> Cale, it should be the other way around.
20:08:58 <Cale> djahandarie: Why?
20:09:03 <djahandarie> Consistancy.
20:09:09 <Cale> What?
20:09:09 <Philippa> I should probably head off for the night, clearly I'm too tired
20:09:12 <DegenerateMonad> I mean the monad instance of IO is defined in terms of primitives called bindIO
20:09:13 <Philippa> sorry djahandarie, danharaj
20:09:14 <DegenerateMonad> well not primitives
20:09:23 <DegenerateMonad> but low-level functions called bindIO and returnIO
20:09:34 <Saizan> if you import some GHC-only modules you can implement Monad IO :)
20:09:37 <DegenerateMonad> instance Monad IO where (>>=) = bindIO
20:09:37 <djahandarie> DegenerateMonad, and those low-level functions should be exposed
20:09:41 <DegenerateMonad> djahandarie: why?
20:09:51 <DegenerateMonad> sorry, not much computation going on in me
20:09:55 <djahandarie> DegenerateMonad, so IO isn't special anymore
20:09:56 <DegenerateMonad> I'm kinda slow
20:10:05 <DegenerateMonad> djahandarie: just import GHC.IO or whatever module it's in
20:10:35 <Philippa> djahandarie: how's that significantly different from having the monad instance?
20:10:39 <Cale> djahandarie: Maybe doesn't have bindMaybe in the libraries as a separate function
20:10:39 <Saizan> it'd still be an abstract type as far as the standard is concerned
20:10:44 <DegenerateMonad> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-Base.html
20:10:56 <djahandarie> Cale, but you can define it based on other functions
20:11:01 <DegenerateMonad> strangely enough, thenIO is never used
20:11:01 <Philippa> quite. The issue's practically alpha-equivalent, FFS
20:11:13 <Saizan> djahandarie: we also don't have addInt :: Int -> Int -> Int, just the Num instance
20:11:23 <Philippa> djahandarie: right, you don't want bindIO, you want bindIO's innards. But there's always going to be something magic, that's the nature of IO
20:11:32 <DegenerateMonad> bindIO (IO m) k = IO $ \ s -> case m s of (# new_s, a #) -> unIO (k a) new_s
20:11:39 <DegenerateMonad> that's no longer "haskell"
20:11:49 <djahandarie> Philippa, no, I was responding to Cale's counter, that wasn't my point.
20:11:54 <Cale> djahandarie: What do you have against putting some definitions of things into typeclass instances whose implementation details are hidden by a module boundary?
20:12:25 <dibblego> how do I tell cabal to depend on an exact version of a library in build-depends?
20:12:34 <djahandarie> Cale, because when a concept is introduced directly through a abstraction it's confusing.
20:12:36 <DegenerateMonad> package = version
20:12:37 <djahandarie> an*
20:12:57 <Cale> I'm not sure I understand.
20:13:18 <djahandarie> When IO is introduced with Monads, then Monads become special
20:13:31 <Philippa> djahandarie: is the abstraction you're complaining about the type class, or the barrier between the names and the implementation of IO?
20:13:35 <djahandarie> When IO is introduced with special functions, that's okay because a lot of functions are special
20:13:39 <Philippa> okay, it's the type class
20:14:04 <Cale> Well, IO happens to be a monad.
20:14:10 <djahandarie> So are a lot of things.
20:14:13 <Cale> Right.
20:14:20 <Philippa> okay, so highlight the fact it's just a typeclass, but this particular instance (therefore, these particular functions) are special?
20:14:28 <Cale> You seem to be arguing that there should be more clutter.
20:14:40 <djahandarie> I'm arguing that the magic shouldn't happen at the typeclass layer.
20:14:44 <Cale> I'm already upset enough about map being specialised to []
20:14:49 <djahandarie> I wouldn't call that "cluter" but rather "clarity"
20:14:54 <Cale> and not being the name of fmap
20:15:00 <Cale> (like it was in 1.4)
20:15:01 <Philippa> it doesn't happen at the typeclass layer
20:15:09 <Saizan> tbh, i think it'd be easier to teach IO without focusing on monads if the type errors and such won't be able to mention the Monad typeclass
20:15:15 <Philippa> it's just an ordinary typeclass
20:15:18 <djahandarie> Philippa, it does for the purposes of anyone learning it
20:15:19 <Philippa> saiam: sure
20:15:21 <Cale> djahandarie: What reason would I ever have to use bindIO rather than >>= ?
20:15:27 <Saizan> and that's what the previous discussion was about
20:15:29 <Philippa> Saizan, even. That's what Helium does
20:15:36 <Philippa> Cale: error message quality
20:15:51 <Philippa> it makes your intent clearer: it's definitely the IO instance
20:15:57 <Cale> I suppose.
20:16:05 <deech> Hi all, I am interested in combining Haskell and Lua, however the example code on the wiki page : http://www.haskell.org/haskellwiki/HsLua doesn't seem to work. There also don't seem to be any docs or tests in the hslua package. Does anyone know if there are any more up-to-date tutorials?
20:16:30 <Cale> Though as soon as you write an IO action with at least one thing from IO in it, that pins the types down.
20:16:33 <djahandarie> Cale, why would you ever explicitly box a value with a constructor rather than use a pointed functor
20:17:02 <Philippa> Cale: once in a while I miss the return off the return line at the end of a do statement. If I'm unlucky, the return value's a list or a Maybe
20:17:05 <Cale> djahandarie: Because I'd have to import another module and gain a dependency on category-extras :P
20:17:19 <Philippa> Cale: the error message is fucking confusing if you don't know what happens if you've done that
20:17:24 <Saizan> that said, behind a module boundary, if bindIO is defined using (>>=) or vice versa is not even observable.
20:17:25 <DegenerateMonad> yeah, for some reason I'm always reluctant to depend on category-extras
20:17:31 <Philippa> (sorry, I guess we're not supposed to swear much in here these days)
20:17:41 <kmc> says who?
20:18:08 <Philippa> kmc: there seems to be a certain consensus. I mean, short of dons I'm as authoritative on it as anyone, but still :-)
20:18:26 <Philippa> much != at all, mind
20:18:41 <kmc> heh
20:18:42 <djahandarie> Cale, I agree that I would almost always use the abstraction. But in this case only the abstraction exists and I think that is a problem.
20:18:55 <djahandarie> (Not for users but for learners)
20:19:08 <Cale> I think swearing is okay, so long as we're fucking polite about it.
20:19:19 <Philippa> okay, long story short: the level of abstraction in haskell's libraries is good at fucking with newbies' heads while they figure out what they're doing
20:19:25 <Philippa> monads aren't the only instance of this
20:19:35 <Philippa> they're just the most prominent
20:19:38 <djahandarie> I think that's an overgeneralization and not my point.
20:19:51 <Cale> I suppose. I think the main way to deal with this is to introduce typeclasses on day one.
20:20:04 <Philippa> eh, there are plenty of other instances of it. If that's not what your point is, how does your point differ?
20:20:06 <djahandarie> Cale, 1. This is a type class, 2. This is a function
20:20:16 <donri> How do you lift out a value from something without pattern matching? Like in "case (Just "hi") of Just x -> putStrLn x"
20:20:20 <Cale> Note that you also can't use (<) without also using Ord
20:20:30 <Philippa> donri: with a function that does the pattern matching for you
20:20:39 <Philippa> donri: you probably don't want to do that though
20:20:41 <Cale> Suppose I want to compare two Floats, I can't do that without the abstraction either!
20:21:09 <donri> Philippa: I'm only asking for learning purposes. Is there an expressiony way to do it with builtins only?
20:21:23 <Cale> donri: That's what case is.
20:21:29 <Philippa> donri: My answer was complete :-) There's no other way
20:21:45 <djahandarie> Cale, Saizan brought that up already, I'm not sure of my response to it. Perhaps it is even equally confusing to learners how (<) or (+) is "overloaded" like that
20:21:51 <Cale> donri: I suppose you could also use let and a pattern binding, but then you can't match the other cases.
20:21:52 <dibblego> DegenerateMonad, Parse of field 'build-depends' failed
20:22:16 <Philippa> monads do have a couple of nasty error message gotchas resulting from the abstraction though
20:22:19 <Cale> djahandarie: Everything is confusing when you learn a new language, as it should be :)
20:22:26 <Philippa> and missing off the return is a predictable mistake while learning
20:22:38 <donri> I was thinking (Just "hi" >>= putStrLn) but I guess that fucks up the types
20:22:46 <djahandarie> Cale, I'm not entirely sure I agree with that.
20:22:46 <kmc> donri, for Maybe you might want "fromMaybe" or "maybe"
20:22:48 <kmc> :t fromMaybe
20:22:49 <lambdabot> forall a. a -> Maybe a -> a
20:22:49 <kmc> :t maybe
20:22:50 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:22:55 <djahandarie> Cale, that's almost like saying "let's keep a certain level of confusion"
20:22:59 <Cale> If you don't feel at sea most of the time that you're studying something, you're probably not learning fast enough.
20:23:05 <Philippa> donri: heh, nice try for reasons you probably don't get yet :-)
20:23:09 <donri> @hoogle fromMaybe
20:23:10 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
20:23:12 <Cale> That's not to say we can't make it easier to learn.
20:23:20 <kmc> donri, for a list, the natural function to pattern match without pattern matching is foldr
20:23:20 <Cale> But I don't think it's a problem with the language in this case.
20:23:29 <DegenerateMonad> @remember Cale If you don't feel at sea most of the time that you're studying something, you're probably not learning fast enough.
20:23:29 <lambdabot> It is forever etched in my memory.
20:23:32 <Cale> It's maybe a problem with our teaching materials.
20:23:44 <donri> Philippa: ?
20:23:51 <Philippa> it's a problem with our typechecker too, though
20:23:59 <Philippa> donri: there's a Maybe instance of Monad, too
20:24:10 <Cale> Philippa: Well, better error messages are always nice where we can get them.
20:24:14 <donri> I know, that's why I was thinking that
20:24:25 <djahandarie> > 1 + "blah"
20:24:26 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
20:24:26 <lambdabot>    arising from the literal ...
20:24:27 <Philippa> and if we had a monad transformer that did the same thing, then running that on top of IO would make that work
20:24:31 <donri> But the result would be ambiguous so no make sense in the end
20:24:39 <Cale> Philippa: I'm sad that error messages were one of the major arguments for removing monad comprehensions.
20:24:53 <Philippa> Cale: *nod*. Sometimes the right answer's to fix the typechecker
20:25:10 <Philippa> I mean, we generally take the Sufficiently Smart Compiler route everywhere else
20:25:40 <Cale> Philippa: In the same standard, we have no foldl' because foldl is supposed to be good enough ;)
20:25:51 <dibblego> build-depends: package == version
20:26:07 <copumpkin> dibblego: yeah, was just about about to say, sorry :)
20:26:13 <copumpkin> http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#pkg-descr
20:26:19 <donri> kmc: Thanks
20:26:19 <dibblego> copumpkin, it's cool, I tried every other combination too :)
20:26:30 <ninly> preflex: seen ninly
20:26:30 <preflex>  ninly was last seen on #haskell 51 minutes and 49 seconds ago, saying: i was going to suggest "the Haskell tongue" but that would probably attract even worse
20:26:42 <Cale> preflex: seen mmorrow
20:26:42 <preflex>  mmorrow was last seen on #ghc 261 days, 28 minutes and 56 seconds ago, saying: * mmorrow is rtfm'ing
20:26:49 <ninly> sorry just had to try that.
20:27:03 <Cale> mmorrow is reading the neverending manual.
20:27:13 <copumpkin> someone ballsy and in the US should try calling him
20:27:13 <monochrom> the turing manual
20:27:17 <Philippa> that should be a film
20:27:20 <ninly> i was wondering if i'd been here before tonight; can't remember for sure
20:27:21 <copumpkin> if nobody calls him before I go back to the US, I'll do it
20:27:29 <djahandarie> Anyways, my main motivation was that not introducing IO through the its Monad instance would move all the spectacle of Monads to IO, where it should be.
20:27:32 <Philippa> #the never-ending manual - aaaaaaaargh
20:27:34 <Cale> copumpkin: What's his phone number?
20:27:38 <djahandarie> I would if I knew the guy
20:27:39 <copumpkin> ninly: lucky for you chrisdone is making an IRC logger for him
20:28:03 <copumpkin> Cale: it's fairly easy to look him up on spokeo, which is how I did it (that's a really creepy website, by the way)
20:28:12 <pikhq> preflex: seen pikhq
20:28:13 <preflex>  pikhq was last seen on #haskell-blah 1 day, 22 hours, 48 minutes and 48 seconds ago, saying: By which I mean "that's a basic skill every programmer should have"
20:28:14 <copumpkin> I found someone I'm 99% sure is him there
20:28:24 <copumpkin> and his parents, too
20:28:26 <pikhq> Oh, hey, I have actually talked around here.
20:28:36 <ninly> i ran into another #haskell regular (i assume) who seemed to remember seeing me on here, which is entirely possible
20:28:47 <ninly> but not recently
20:29:03 <Cale> We could not locate 'Cale Gibbard'. Are you sure you spelled the person's name correctly? :]
20:29:16 <djahandarie> Same with me and everyone I know irl
20:29:21 <Cale> But Matt Morrow, it finds many of them.
20:29:22 <monochrom> good riddance
20:29:30 <copumpkin> Cale: he's in IL
20:29:31 <djahandarie> Ah damn, it found my mom
20:29:39 <copumpkin> monochrom: about mmorrow?
20:29:41 <copumpkin> :(
20:29:52 <monochrom> about a Cale Gibbard not found :)
20:30:06 <copumpkin> Cale: he's J :)
20:30:37 <copumpkin> I also found a few other things about him by poking around online
20:33:09 <copumpkin> maybe mmorrow's a mormon and went on a mission 
20:33:58 * monochrom regretted thinks of that Captain Orgazmo or something
20:34:07 <copumpkin> DVDA?
20:34:09 <Cale> I'll need a good voice filter to represent the Haskell Hive Mind.
20:34:11 <monochrom> s/regretted/regrettedly/
20:34:42 <shachaf> Cale: Clearly, it should be in stereo.
20:34:44 <Philippa> Cale: if it weren't for the fact it'd screw up the formants I'd say waveshape down to a single sine wave - pure
20:34:47 * shachaf brings about ancient memories.
20:34:48 <copumpkin> Cale: if it's a hive, it should be very bzzy
20:35:06 <shachaf> *Majestic* stereo, that is.
20:35:26 <Philippa> nah, we kicked out the infiltrators from MJStereo
20:35:39 <Philippa> drove that little conspiracy underground
20:35:45 <shachaf> @quote stereo
20:35:45 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
20:36:09 <Cale> Lots of slightly timeshifted and detuned echoes maybe.
20:36:39 <Cale> In stereo, of course, though I'm not sure how that'll work over a phone.
20:36:39 <Philippa> Cale: that coupled with some derivative of my idea that doesn't screw up vowel sounds?
20:37:00 <Philippa> (simple vocoder effect, I guess)
20:37:25 <Cale> Maybe I could get that Cubase C64 to do it ;)
20:38:27 <djahandarie> Heh this is going to be one awesome phone call if it happens
20:39:08 <copumpkin> preflex: seen wli
20:39:09 <preflex>  wli was last seen on #haskell-blah 7 days, 9 hours, 32 minutes and 13 seconds ago, saying: boshhead: Instead of making the derivatives match up to the n-th order at a single point (Taylor series) you can use several points, or both ends of an interval, or similar.
20:42:52 <Philippa> you may be a haskeller if: you get a mail on OKC asking " Is that a unicycle on a renovation site? "
20:43:09 <kmc> ?
20:43:27 <Philippa> I guess the haskell unicycle fad's died out a bit these days, but still
20:43:53 <kmc> that's a thing?
20:44:12 <Philippa> there were multiple unicycles at the first anglohaskell, for example
20:44:39 <Philippa> not all of us remembered to have a go before having a couple of pints, either
20:45:06 <ddarius> kmc: You can find pictures of SPJ on a unicycle.
20:46:00 <kmc> is he wearing a bowtie too?
20:46:15 <djahandarie> shapr does the unicycle thing also
20:46:53 <ddarius> kmc: I think he's wearing a sweater.
20:49:12 <Philippa> hmm, edwinb's photo gallery's down
20:49:22 <Philippa> well, throws errors instead of displaying photos, anyway
20:59:13 * hackagebot authenticate 0.6.6.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.6.6.1 (MichaelSnoyman)
21:43:51 <pumpkin> dmead: aha!
21:43:58 <dmead> oh ho!
21:44:02 <pumpkin> kmc wants a word with you
21:44:07 <dmead> uh no
21:44:10 <dmead> oh no
21:44:50 <dmead> i responded to you on that thread
21:45:07 <pumpkin> how is doing IO elaborate?
21:45:20 <pumpkin> if you'd never heard of a monad
21:45:25 <pumpkin> and I hand you a do block and putStrLn etc.
21:45:35 <pumpkin> you'd think it's just a bit of a funny syntax for an imperative language
21:45:52 <pumpkin> (except that you don't have an early return)
21:46:25 * hackagebot memscript 0.0.1.0 - Command line utility for memorizing scriptures or any other text  http://hackage.haskell.org/package/memscript-0.0.1.0 (KiYungAhn)
21:46:35 <kmc> dmead, i think i kind of see your point, but i think "typed IO" is a remarkably bad term for it.  the issue isn't that IO-actions are typed (as they are in C++ and Java and Scala and every other statically typed language)
21:46:59 <kmc> the issue is that they're first-class descriptions of actions, rather than uncontrollable side effects of function application
21:47:06 <dmead> right
21:47:18 <kmc> "monad" is totally secondary; it's just an API that happens to be a nice fit for working with these actions
21:47:22 <dmead> i guess my main critizism is really how documentation and courses for the language is structured
21:47:30 <kmc> you could do IO in essentially the same way without invoking this generality
21:47:31 <pumpkin> in my side of the thread, you seemed to be advocating for me being able to write f :: Int -> Int being able to print to the screen
21:48:44 <dmead> sure, it's not THAT complicated, but do notation definitely fails to resemble imperative langauges
21:49:04 <dmead> the fact that it's got newlines in blocks doesn't help you reason as you would in an imperative langauge
21:49:20 <dmead> or at least, thats a huge stumbling block to learning the langauge
21:49:23 <pumpkin> hmm.
21:49:27 <dmead> do-notation is always called imperative style
21:49:39 <dmead> and people see that, but then get discouraged when they try to actually use it
21:50:55 <kmc> "newlines in blocks"?
21:51:07 <kmc> oh, you mean that as a similarity
21:51:20 <dmead> yea, to blocks in imperative langauges
21:52:14 <dmead> it's clearly the best thing if you want to have code that is provably correct
21:52:18 <kmc> anyway i think Haskell education could use improvement, but no matter how much we improve there will still be uninformed people on Reddit or wherever talking about how monads are the key idea in Haskell, or that they're a loophole in an otherwise pure language, or how Haskell's type system is about tagging side-effecting functions
21:52:25 <dmead> not so clear if you want more people to use the langauge and use purity
21:52:25 <kmc> none of which is close to true
21:53:31 <kmc> it's easier to teach people these things for real, than it is to cook them down so that even slogans and half-remembered wikipedia summary paragraphs come across correctly
21:53:50 <kmc> anyway it wasn't clear on reddit what your proposed solution is
21:54:00 <kmc> to the language itself i mean
21:54:46 <dmead> other than changing the order of how every haskell book or tutorial is written?
21:55:16 <dmead> probably take hugs or something and just let functions do IO inside pure code
21:55:19 <dmead> and don't typecheck it
21:55:26 <kmc> that's called unsafePerformIO
21:55:37 <kmc> it's part of the Haskell spec (via the FFI addendum)
21:55:51 <dmead> right, still
21:56:01 <kmc> it has well-documented pitfalls
21:56:04 <dmead> i'm thinking about your average software engineer
21:56:14 <kmc> but you can program in that style if you want, today, with no modification to your compiler
21:56:16 <pumpkin> how would you even incorporate that into an expression-based language?
21:56:24 <pumpkin> a lazy one, I might add
21:56:29 <kmc> Haskell is not a language for the average software engineer, at least if she doesn't want to think at all, and wants instant gratification
21:56:43 <kmc> i don't feel we need to move Haskell in that direction
21:56:45 <pumpkin> pure haskell + unsafePerformIO is still not the same as your average imperative language
21:56:53 <pumpkin> in fact, it's just broken :P
21:56:55 <dmead> i said in the thread, what i really want is a do notation that returns a pure value
21:56:59 <kmc> uh
21:57:01 <dmead> :P
21:57:02 <kmc> that's what do notation does
21:57:09 <pumpkin> unsafePeformIO $ do
21:57:15 * pumpkin shudders
21:57:19 <dmead> ha
21:57:20 <kmc> #define doodoo unsafePerformIO $ do
21:57:25 <pumpkin> lol
21:57:29 <dmead> ha
21:57:30 <kmc> i think plenty of new languages keep appearing that pull one or two key features from Haskell into a more traditional setting
21:57:32 <pumpkin> dmead: I'm still not sure *why* you want that though
21:57:33 <kmc> i'm fine with that
21:57:40 <kmc> i think that's where "average software developers" should go for now
21:57:50 <kmc> if they don't want a challenge / can't deal with delayed gratification
21:58:17 <kmc> i mean the buzz about FP in the mainstream is not about Haskell, it's Clojure and Scala and Javascript
21:58:25 <dmead> javascript
21:58:26 <dmead> feh
21:58:32 <kmc> (count the Reddit articles about "OMG Javascript has this insane new feature called closures!")
21:58:47 <dmead> yea, i guess i'm just interested in making this sort of thing more accessible
21:58:56 <kmc> then i think you should work on a language which is not Haskell
21:59:01 <kmc> in particular, which is not lazy
21:59:03 <dmead> nahhh
21:59:07 <dmead> most languages are terrible
21:59:15 <pumpkin> having laziness and unrestricted side effects is a recipe for disaster
21:59:16 <kmc> i think that coping with monadic IO is a tiny obstacle compared to reasoning about time and space in a lazy language
21:59:38 <kmc> dmead, sure, most languages are terrible, and half of what makes Haskell good is not ideology like purity or laziness -- it's just a lot of small things that they got right
21:59:39 <dmead> thats very true
21:59:43 <kmc> but, ML got a lot of them right too
21:59:55 <kmc> perhaps you can do what you want to do better in SML or OCaml or Scala or F#
22:00:00 <kmc> or a variation on one of those
22:00:01 <dmead> indeed, but ML's syntax is slightly uglier than haskell
22:00:06 <kmc> rather than a variation on Haskell
22:00:39 <kmc> what you are proposing would change the core ideas of Haskell completely; i think at that point you're talking about "a new language inspired by Haskell" and not "Haskell itself should obviously do this"
22:00:50 <kmc> especially when the goal is to appeal to the average programmer, which was never Haskell's goal
22:01:01 <dmead> nah, i'm not about to leave doing haskell because it's harder for other people to understand
22:01:15 <kmc> then what's the point of your complaint?
22:01:23 <kmc> "Haskell sucks because it's not OCaml, but I like Haskell better anyway"
22:01:36 <dmead> i didn't say haskell sucks
22:01:51 <kmc> yes, i'm caricaturing what you're saying
22:02:07 <kmc> it is always funny when people tell us what we need to do to make Haskell popular
22:02:10 <kmc> and just assume this is the goal
22:02:24 <kmc> i'm fine with the elitist hipster language, thankyouverymuch
22:02:39 <zomg> You just need to remove everything that Haskell is
22:02:41 <zomg> And make it another PHP!
22:02:48 <zomg> What do I get for solving this problem?
22:02:51 <zomg> =)
22:02:57 <dmead> so am i, i don't have a problem with being esoteric
22:03:11 <JoeyA> What Haskell needs to do to keep from being popular is continuing to have a dearth of libraries and not allowing programmers to do funky things like overlapping instances.  Crap, I'm too late.
22:03:24 <kmc> dmead, so why do you say things like "IMHO, typed IO should be a compiler option that is off by default. monadic blocks should be sugared... to return a primitive"
22:03:30 <kmc> where does this "should" come from
22:03:33 <kmc> if it's not for you
22:03:34 <kmc> and not for other people
22:04:05 <kmc> hmm anyway
22:04:05 <dmead> i was just point out that there are advantages to not caring about monadic IO
22:04:09 <kmc> -XNoImplicitPrelude
22:04:12 <kmc> (>>) = seq
22:04:18 <kmc> return = id
22:04:28 <kmc> (>>=) = flip ($)
22:04:44 <kmc> perhaps flip ($!)
22:05:03 <newsham> I just installed MaybeT package from hackage, and docs online say it has "instance MonadTrans MaybeT" but I get compile error about no such instance.
22:05:06 <newsham> what gives?
22:05:28 <dmead> kmc: have you heard of clean?
22:05:31 <Gracenotes> ..same version?
22:05:31 <kmc> yes dmead
22:05:47 <kmc> Clean is cool.  it's also not Haskell, and telling the Haskell reddit that they should make Haskell into Clean is silly
22:06:05 <kmc> newsham, is your MonadTrans perhaps not from mtl but from another package like monads-fd?
22:06:29 <newsham> *shrug*  I installed ghc recently and didnt install too many packages yet
22:06:39 <kmc> did you install mtl?
22:06:42 <kmc> i think that comes with ghc
22:06:46 <newsham> i think it did
22:07:07 <newsham> ghc-pkg list -> mtl-1.1.1.0
22:08:25 <dmead> kmc, yea.. i can't tell you how many times i've talked to people in industry who wish for a good langauge that isn't over the heads of some of their co workers
22:09:31 * hackagebot mainland-pretty 0.1.0.1 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.1.0.1 (GeoffreyMainland)
22:09:31 <kmc> yeah
22:09:34 <Saizan> doesn't clean make you thread a World around?
22:09:40 <kmc> Clojure, Scala, and F# are making inroads there
22:09:41 <Cale> Clean is turning into Haskell anyway.
22:09:47 <Saizan> i'm not sure how that's more imperative-friendly
22:09:49 <Cale> (Apparently)
22:10:08 <dmead> yea, clojure and scala are getting popular around here
22:10:10 <pumpkin> Saizan: it's a world that can't be reused!!
22:10:11 <pumpkin> ;)
22:10:18 <newsham> dmead: why not wish for coworkers whose heads arent under? :)
22:10:19 <pumpkin> no recycling 
22:10:20 <Cale> (The Clean compiler people are doing a Haskell frontend)
22:10:24 <kmc> good syntax for monads is useful, regardless of how you handle side effects.  see: C# LINQ, F# "workflows", vs. Java's if null if null if null if null
22:10:54 <kmc> even in C++ people do method chaining and abusive overloading of operator, to get monad-like structures
22:10:56 <Adamant> Clojure and Scala, like Java back in the day, are moving things halfway forward again.
22:11:14 <dmead> Cale, are they really?
22:11:23 <Adamant> oh nice.
22:11:24 <dmead> a frontent to compile haskell? or compile clean on ghc?
22:11:25 <Cale> dmead: Last I heard
22:11:34 <Cale> A frontend to compile Haskell
22:11:35 <kmc> Java moved things back, imo.  not necessarily by the design itself, but by standardizing a very low bar for what constitutes an "average programmer"
22:11:45 <Adamant> kmc: it didn't initially
22:11:49 <Adamant> it did later
22:11:57 <dmead> i'm working on a code generator i want to move into ghc eventually
22:11:59 <kmc> when you have a committee design for the average, what you get is the intersection of many averages, i.e. a lowest common denominator
22:12:01 <dmead> to emit clojure
22:12:03 <Adamant> the "everything Java" bit was the problem.
22:12:04 <dmead> from haskell
22:12:19 <Adamant> dmead: why not Java?
22:12:37 <dmead> Adamant, simplicity
22:12:43 <Adamant> good reason
22:12:48 <Adamant> for sure.
22:13:40 <kmc> clojure being dynamically typed, i expect some unnecessary performance penalty
22:13:56 <kmc> you'll have lots of runtime checks that can never fail
22:13:59 <kmc> still it's still not a crazy idea
22:14:10 <Adamant> kmc: the only penalty will be with tail recursion
22:14:22 <kmc> because the JVM forces all the other checks?
22:14:23 <Adamant> since it uses a mini-interpreter to solve that
22:14:24 <dmead> you can put type hints in clojure, so it compiles statically
22:14:31 <Adamant> *only real penalty
22:14:38 <dmead> the clojure i emit will retain type tags from haskell
22:14:42 <kmc> Adamant, when you say (x y) in clojure, something must check whether x is a function or an int, and throw an exception in the latter case
22:14:51 <kmc> and if you've compiled from Haskell you know statically that x is always a function
22:14:55 <kmc> so you could blindly treat it as one
22:15:04 <Adamant> kmc: I corrected myself to "only real penalty"
22:15:13 <kmc> ok
22:15:21 <dmead> hopefully i'll be able to do TCO in the translation
22:15:24 <Adamant> that was my intent, it just didn't come out of my keyboard that way :P
22:15:42 <kmc> Adamant, how do you know that tail-call effects will dwarf other things?
22:15:44 <dmead> but it's for a masters thesis, and i only have till next summer
22:15:45 <kmc> it's not obvious to me anyway
22:15:54 <Adamant> kmc: I don't for sure, it's just a guess
22:15:58 <Adamant> gut feeling
22:16:30 <dmead> it won't really have a performance hit, clojure has optional static typing
22:17:03 <augur> anyone know any really good graph drawing apps?
22:17:23 <Adamant> the standard for graphs is graphvis
22:17:28 <Adamant> not sure it's "good"
22:17:36 <dmead> thats for generating graphs
22:17:44 <augur> dmead: its a graph drawing app.
22:17:50 <Adamant> dmead: I thought it did display too
22:17:53 <ulfdoz> pretty good even.
22:18:03 <augur> graphviz doesnt let me force optimal display search :(
22:18:11 <ulfdoz> yes, there is a minimalistic graph displayer included.
22:18:23 <dmead> theres a really great one for linux
22:18:27 <dmead> i'm trying to remember the name
22:18:34 <augur> i have planar graphs, but it wont let me force it to display them planarly
22:18:40 <dmead> i used it last semester to draw a huge directed graph in like 10 minutes
22:18:43 <dmead> ahhhhhhhhh
22:19:26 <augur> it pisses me off that i can have a planar graph that i cant display planarly :|
22:20:10 <ulfdoz> Isn't finding the planar layout np-complete in general?
22:20:20 <augur> sure, but so what
22:20:24 <augur> NP complete doesnt mean unsolvable
22:20:31 <augur> it means unsolvable in efficient timescales
22:20:33 * hackagebot hxt-extras 0.4 - Extra functions for HXT  http://hackage.haskell.org/package/hxt-extras-0.4 (TonyMorris)
22:20:41 <augur> for some relevantly large problem
22:20:52 <kmc> augur, and SAT solvers have made incredible progress in the past 10 years
22:20:58 <augur> im not saying they have
22:21:05 <kmc> to the point where a lot of NP-complete problems are really tractable at practical inputs
22:21:06 <augur> that doesnt mean there arent sat solvers out there
22:21:30 <augur> but i mean, graphviz gets ALMOST perfect drawings
22:21:40 <augur> except that there are maybe two or three unnecessary edge crossings
22:21:49 <Cale> I want a graph drawing program which takes the automorphism group of the graph into account properly.
22:21:56 <augur> :P
22:21:56 <kmc> it also turns out that real world instances are easier than worst-case instances, and that exploiting this extra structure is somewhat invariant under reduction (which is really weird)
22:22:10 <kmc> and i don't agree that graphviz is almost perfect, i'm frequently quite unhappy with it
22:22:18 <augur> kmc: i mean for my graphs
22:22:22 <kmc> and want to make some adjustment, but i've found no tool for taking a graphviz layout and moving a few nodes
22:22:47 <dmead> theres a tool like that
22:22:58 <dmead> let me flip to my linux install.. i'm sure i have it installed
22:25:03 <augur> i mean, its like, theres all this graph theory research
22:25:10 <augur> wheres the implementation?
22:25:54 <dmead> ah ha
22:25:56 <dmead> http://live.gnome.org/Dia
22:26:01 <dmead> thats great for drawing graphs
22:26:12 <dmead> who was asking about graphs?
22:26:16 <augur> me
22:26:19 <dmead> use dia
22:26:33 <dmead> you can drag around nodes, and the attached edges will follow it
22:26:40 <kmc> augur, the research is probably 10 half-completed masters' thesis programs
22:26:55 <augur> dmead: but does it autolayout for you
22:26:56 <kmc> i think hooking into graphviz is a good idea though
22:26:56 <augur> thats the issue
22:27:02 <ksf> is there a technical terms along the lines of (non)deterministic infinite automaton?
22:27:17 <kmc> ksf, maybe a Büchi automaton?
22:27:27 <kmc> or ω-automaton
22:27:50 <kmc> they are useful for model checking
22:28:11 <dmead> augur, oh you're trying to do it automatically?
22:28:14 <augur> yes :|
22:28:37 <augur> noone cares about drawing graphs by hand, anyone can do that and make it work
22:28:47 <dmead> :>
22:29:26 <ulfdoz> I still prefer xfig over dia for my sketches.
22:29:52 <dmead> dia exposes and api in python, you could probably use that
22:29:56 <ksf> ...I don't support infinite input, but infinite grammars.
22:30:30 <kmc> ok
22:30:38 <ksf> and I've got a proof that it's determisable. not that it's practical in many cases, that is, it's badly exponential.
22:30:41 <kmc> i think the typical definition of a FSM extends fine to infinite graphs
22:30:55 <ksf> well, no.
22:31:05 <ksf> a finite state machine has a finite number of states.
22:31:23 <kmc> i said extends
22:31:31 <kmc> as in, by lifting that restriction you still get something coherent
22:31:53 <kmc> usually in maths you use a "higher-order" representation, with a state set S and a transition function S x A → S, for an alphabet A
22:31:56 <ksf> I'd very much doubt I could reverse the dia, same goes for minimising in general.
22:32:01 <kmc> and if S is an infinite set this seems fine
22:33:26 <augur> kmc: one thing is, i wish that force minimization techniques also included repulsive forces between non-connected nodes
22:33:26 * ksf thinks nobody is going to kill him if he calls the class infinite regular grammar
22:33:33 <augur> because that would work nicely for me too
22:33:42 * kmc gets out his ksf-stabbin' knife
22:34:02 <augur> or stuff like constrained force minimization as well, so you can constrain nodes to be placed along certain lines according to various rules or something
22:35:23 <newsham> is there an easy way to use Applicative to do things like:   do { x <- foo; lift $ f x }     and   do { x <- foo; y <- bar; lift $ f x y }  ?
22:35:37 <newsham> ie. I'd like sometihng like:   f <$> foo     and   f <$> foo <*> bar
22:36:05 <pumpkin> what doesn't Applicative do?
22:36:15 <pumpkin> since you just described Applicative, it seems :P
22:36:23 <pumpkin> oh I see
22:36:35 <newsham> the "lift" is in the way
22:36:41 <pumpkin> :t \foo f -> do { x <- foo; lift $ f x } 
22:36:42 <lambdabot> forall t (m :: * -> *) a (t1 :: (* -> *) -> * -> *). (Monad (t1 m), MonadTrans t1, Monad m) => t1 m t -> (t -> m a) -> t1 m a
22:36:51 <pumpkin> fucking lift
22:37:12 <newsham> i could manually make some liftM1, liftM2 liftM3 type things i suppose
22:44:09 <Saizan> ?type let f <@> x = lift (f <*> x) in (\f a b -> f <$> a <@> b)
22:44:09 <lambdabot> forall a b (m :: * -> *) a1 (t :: (* -> *) -> * -> *). (Applicative m, MonadTrans t, Monad m, Functor (t m)) => (a -> b) -> m (a1 -> a) -> m a1 -> t m b
22:44:40 <Saizan> ?type let f <@> x = lift (f <*> x) in (\f a b -> (f <$> a) <@> b)
22:44:41 <lambdabot> forall a a1 a2 (m :: * -> *) (t :: (* -> *) -> * -> *). (Applicative m, MonadTrans t, Monad m) => (a -> a1 -> a2) -> m a -> m a1 -> t m a2
22:44:46 <augur> byorgey: what is this talk about :|
22:45:09 <Saizan> ?type let f <@> x = lift (f <*> x) in (\f a b c -> (f <$> a <*> b) <@> c)
22:45:11 <lambdabot> forall a a1 a2 a3 (m :: * -> *) (t :: (* -> *) -> * -> *). (Applicative m, MonadTrans t, Monad m) => (a -> a1 -> a2 -> a3) -> m a -> m a1 -> m a2 -> t m a3
22:45:39 <Saizan> newsham: ^^^
22:50:03 <newsham> saizan: *nod* thanks.
22:50:45 <newsham> i think I'll just use 1,2 and 3 lifters for now.
22:50:52 <newsham> to keep my brain from hurting too much
22:51:30 <augur> conal! :D
22:52:34 <jamy> hi2all!
22:53:08 <Saizan> i guess what i wrote doesn't fit.
22:53:26 <djahandarie> augur, his talk about types? I thought it was a pretty good summary of what he's been doing (which is awesome)
22:54:17 <augur> djahandarie: it might be, but i dont get the initial stuff
22:55:55 <djahandarie> The stuff before the theory section?
22:56:00 <augur> i suppose!
22:56:33 <djahandarie> Do you know what Vecs are?
22:56:49 <augur> im not sure
22:57:00 <djahandarie> Okay
22:57:17 <djahandarie> A Vec is basically a list which keeps track of the length of the list in the type-level
22:57:49 <augur> ok
22:58:03 <djahandarie> You can make type-level naturals (using peano numbers) in H98
22:58:03 <kmc> where is this talk?
22:58:17 <djahandarie> Something like.... data Z; data S n
22:58:26 <djahandarie> Then S (S (S (Z))))
22:58:33 <djahandarie> That'd be 3
22:58:49 <djahandarie> So the idea is when doing a cons on a Vec, you would reflect that in the type with an extra S
22:59:02 <augur> kmc: vimeo somewhere
22:59:30 <djahandarie> To do that in Haskell we need to use a GADT.... I think the code might be in his slides
22:59:51 <djahandarie> But
23:00:03 <djahandarie> Even with GADTs you can't do something like append in Haskell
23:00:16 <djahandarie> Because you'd need to add two naturals at the type level
23:00:27 <djahandarie> Something like a type-level plus function from Nat->Nat
23:00:45 <djahandarie> However, this is possible with type families
23:00:45 * ddarius doesn't think he'll be able to finagle mutually recursive bindings.
23:01:28 <djahandarie> type family Plus m n :: *; type instance Plus Z n = n; type instance Plus (S m) n = S (Plus m n)
23:01:32 <djahandarie> Sort of like that
23:01:51 <augur> aha ok so
23:01:55 <ksf> doesnt' even need undecidable instances
23:02:11 <djahandarie> Then we can define append with the type... Vec m a -> Vec n a -> Vec (Plus m n) a
23:02:18 <augur> basically the idea is you want to be able to encode certain information in types, but to do so you'd like to also have available some non-type level resources like numbers and the operations over them
23:02:27 <djahandarie> Right
23:02:31 <augur> ok.
23:02:41 <djahandarie> This is all possible with two GHC extensions (GADTs and Type Families)
23:02:45 <djahandarie> But
23:03:16 <djahandarie> The definition of Vec is something like this... data Vec :: * -> * -> * -> where ...
23:03:21 <djahandarie> Whoops
23:03:26 <djahandarie> Sans that last arrow
23:03:49 <djahandarie> Looking at that kind it isn't really clear that the first parameter must be a Nat
23:03:50 <augur> you dont need to continue to explain for me, i just wanted to understand the general purpose of the talk :P
23:03:55 <jamy> yesterday i could read Real World Haskell: Chapter 2. I am delighted!!!
23:04:01 <djahandarie> Ah okay
23:04:06 <djahandarie> Hell I need to go to bed anyways
23:04:08 <djahandarie> Night
23:04:21 <augur> night :P
23:04:23 <djahandarie> But yeah the talk is about fixing the problem I just mentioned
23:04:24 <djahandarie> o/
23:04:54 <Saizan> i.e. getting a typed type-level
23:05:50 <jamy> Saizan: you talking to me&
23:05:53 <jamy> *?
23:07:12 <Saizan> no
23:09:16 <nerolynx> afternoon lads
23:10:29 <nerolynx> could I ask for your help to guide a total newbies on a quite difficult project (for me)?
23:11:46 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.7134
23:13:35 <nerolynx> and I suppose you mean I'm speaking like a fool by providing that link?
23:13:59 <ddarius> nerolynx: I haven't read anything you've written before now.
23:14:07 <nerolynx> oh, soz
23:14:12 <nerolynx> i was asking for some help
23:14:31 <nerolynx> and the title happens to be should your language to typed
23:14:38 <nerolynx> so I assume the worst
23:14:43 <nerolynx> anyhow, I am completely new to Haskell
23:15:05 <nerolynx> and Im struggling with getting the pattern matching and function to work correctly
23:16:15 <nerolynx> so Im asking any kind soul would gladly guide me along making Haskell works for me
23:17:08 <kmc> nerolynx, show us what you have so far by uploading it to hpaste.org
23:19:17 <nerolynx> hmm, basically nil
23:19:39 <kmc> ok
23:19:45 <nerolynx> and I wouldn't need with the whole project (uniwork)
23:19:48 <kmc> what are you trying to do?
23:19:50 <nerolynx> just something to get me going
23:19:57 <jamy> kmc: yesterday i could read Real World Haskell: Chapter 2.
23:20:02 <kmc> cool jamy :)
23:20:19 <nerolynx> I tried to read all the tutorials I could find
23:20:32 <kmc> nerolynx, we usually recommend RWH and LYAH
23:20:34 <kmc> @where rwh
23:20:34 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
23:20:35 <kmc> @where lyah
23:20:35 <jamy> kmc: by the way HELLO
23:20:35 <lambdabot> http://www.learnyouahaskell.com/
23:20:40 <kmc> hello jamy
23:20:46 <nerolynx> but my mind couldn't wrap around the functional programming idea :(
23:20:52 <nerolynx> tried it
23:21:13 <nerolynx> but it's not sufficient besides very basic programs
23:21:18 <nerolynx> well
23:21:27 <nerolynx> let me get back to the problem then
23:21:30 <kmc> nerolynx, Haskell is about ten new ideas all at once.  not only traditional functional programming but laziness, purity, first-class IO, polymorphism, type classes, …
23:21:42 <nerolynx> yeah
23:21:57 <kmc> nerolynx, if you're totally new to functional programming you may enjoy a book on Scheme, like SICP or The Little Schemer
23:22:03 <nerolynx> that's precisely what makes it a bit harder for me
23:22:04 <kmc> it won't cover pattern-matching though, or static typing
23:22:09 <nerolynx> well
23:22:16 <kmc> you can also familiarize yourself with FP in Javascript, Python, C#, or a lot of other languages
23:22:24 <kmc> it's basically something every decent language supports, though C++ and Java don't really
23:22:26 <nerolynx> the subjects I am doing require knowing Hashkell
23:22:39 <nerolynx> I can do pretty well Python, C# and Java
23:22:40 <identity> I think people that are used to iterative programming have an easy time getting used to F#
23:22:47 <identity> Which is based on O'caml, afaik
23:22:58 <nerolynx> but anyway
23:23:11 <nerolynx> just lemme state my problem at the moment
23:23:29 <nerolynx> and you guys could guide me to a more concise tutorial :D
23:23:36 <nerolynx> thanks a lot
23:23:36 <nerolynx> okay
23:24:17 <nerolynx> I have an input logical formula, let's say "q=x AND s"
23:24:43 <ddarius> People used to iterative programming have an easy time writing iterative code in F#.
23:25:34 <nerolynx> I could call a provided function Parse which takes takes the String and gives a list containing tuple : [(q, AND (WIRE "x", WIRE "s")]
23:25:37 <jamy> Haskell is billed as it would have made professor of mathematics, but not knowing how the car just simple things like find the sum or difference
23:25:39 <riboflavin> anyone know a way to make the lambda function in http://pastebin.com/vsENgG42 shorter? It's for an assignment, and I am required to use a lambda function, but I want to know if there is a way other than if..else to do it
23:25:39 <nerolynx> soz
23:26:07 <kmc> \x -> not (x `mod` n == 0)
23:26:18 <kmc> \x -> x `mod` n /= 0
23:26:28 <kmc> ((/=0).(`mod`n))
23:26:34 <identity> riboflavin: == is an operator that returns Bool
23:26:49 <identity> (or a function to be precise)
23:26:59 <identity> so there's no need for the if expression
23:27:05 <identity> as kmc pointed out
23:27:07 <kmc> an if-expression which returns literal False or True is a big red flag
23:27:25 <riboflavin> identity: oh.. duh. Thanks.
23:27:27 <kmc> you can replace such things with not, (&&), (||), or nothing at all
23:27:55 <riboflavin> I like the function composition version, thanks
23:28:05 <nerolynx> :(
23:28:12 <identity> o.o
23:28:30 <identity> I thought he didn't finish typing out his question.
23:28:44 <kmc> he didn't wait long either
23:28:50 <identity> Nope.
23:29:04 <kmc> whatever, response time here is like 1/10 any other IRC channel i've seen, if even that is too long then oh well
23:29:14 <identity> Exactly
23:29:28 <riboflavin> I just learned function composition. That is awesome. ANd yea, whenever I have asked a question in here, the response time has been really fast
23:29:49 <identity> If anything, the only issue with asking questions in this channel is a non-issue; too many people trying to help at once, heh.
23:31:26 <kmc> not entirely a non-issue
23:31:34 <kmc> complaints of information overload are legitimate
23:31:45 <kmc> i think the solution is to focus on one explanation at a time
23:31:50 <kmc> i wonder if there are IRC clients that support this
23:32:27 <riboflavin> could maybe write a script for one, if the functionality isn't there. Irssi is pretty extensible (though I haven't scripted for it myself)
23:33:15 <identity> Yes, of course, but I'd choose a horde of enthusiastic academics all trying to help me understand things using their intuition than to ask a question and have to wait for several hours until someone replies or something. 
23:33:25 <kmc> no, the solution is a brand new IRC client in Haskell based on a categorical theory of IRC as hylomorphic functor transformation combinators over infinite sets of message-spaces
23:33:39 <identity> Yeah, *exactly* what I was thinking
23:33:44 <identity> >.>
23:33:45 <kmc> yeah
23:33:50 <kmc> i wonder how many of us are academics
23:33:52 * kmc isn't
23:34:12 <identity> kmc: I don't necessarily mean that you have to be in academics to be an academic
23:34:15 <identity> you know what I mean
23:34:26 <kmc> *shrug*
23:34:33 <identity> people that like to know stuff to know stuff
23:34:53 <identity> meh
23:34:58 <identity> I'm going to read some more
23:36:03 <kmc> "An intellectual is a person who has discovered something more interesting than sex." — Aldous Huxley
23:37:21 * ksf can hardly be called an academic, but /does/ consider himself a scientist.
23:37:40 <ksf> well, or engineer.
23:37:42 <ksf> or artist. 
23:38:08 <ksf> no real difference there, anyway
23:39:42 <kmc> uhm
23:40:36 <nejucomo> I've just discovered Control.Monad.Instances, but I'm confused about some instances.  What would be an example usage of the Monad ((->) r) instance?
23:40:48 <dibblego> :t (>>=)
23:40:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:40:54 <ksf> it would be a bad one.
23:40:57 <nejucomo> Also, I see "Monad [::]".  What is [::] ?
23:40:57 <opqdonut> nejucomo: it's equivalent to the Reader monad
23:41:00 <dibblego> (r -> a) -> (a -> r -> b) -> r -> b
23:41:02 <ksf> :t ap
23:41:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:41:18 <opqdonut> nejucomo: so basically it allows you to thread a read-only environment through your code
23:41:52 <kmc> > (liftM2 (,) succ pred) 3
23:41:53 <lambdabot>   (4,2)
23:41:58 <kmc> nejucomo, ^^^^
23:42:04 <ksf> @unpl f :: (a->b) >>= g
23:42:04 <lambdabot>  Parse error at ">>=" (column 13)
23:42:10 <nejucomo> :t liftM2
23:42:11 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:42:20 <ksf> @unpl (f :: (a->b)) >>= g
23:42:20 <lambdabot> ((f :: a -> b) >>= g)
23:42:50 <kmc> the instance is not available by default because it turns some type errors into well-typed but incorrect code
23:43:02 <kmc> (which is a downside of overloading generally)
23:43:05 <nejucomo> :t liftM2
23:43:06 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:44:07 <kmc> if not for historical reasons, liftM2 would be replaced with liftA2
23:44:39 <nejucomo> :t liftA2
23:44:40 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
23:44:51 <nejucomo> :i Applicative
23:45:06 <nejucomo> Is it poor form to spam the channel with many queries to lambdabot?
23:45:23 <kmc> nejucomo, depends.  i learn things by watching others use the bot
23:45:27 <Zao> nejucomo: She listens to private messages too.
23:45:36 <kmc> if you're doing a lot of queries you think are not of general interest, you can use private messages
23:46:01 <Jafet> @vixen Do you like being prodded in public?
23:46:02 <lambdabot> yeah, i like
23:46:11 <identity> Jafet: nasty.
23:46:28 <kmc> yipes
23:46:37 <kmc> @. vixen nixon
23:46:38 <lambdabot> you're very welcomed to
23:46:50 <kmc> @. vixen nixon
23:46:50 <lambdabot> when ever you want
23:46:52 <identity> @vixen are you an attention wh.. seeker?
23:46:52 <lambdabot> i truely am
23:46:52 <Jafet> She's got IO all over her.
23:46:55 <Maxdamantus> @v
23:46:55 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
23:46:58 <Maxdamantus> @v
23:46:58 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
23:46:59 <identity> "truely"?
23:47:03 <Maxdamantus> Hm.
23:47:12 <Maxdamantus> > let v = show v in v
23:47:12 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
23:47:26 <identity> > show it
23:47:27 <lambdabot>   Not in scope: `it'
23:47:30 <identity> ah
23:47:47 <Jafet> > fix show
23:47:47 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
23:47:59 <kmc> > fix error
23:48:00 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
23:48:07 <Maxdamantus> > last $ iterate show
23:48:08 <lambdabot>   Couldn't match expected type `[a]'
23:48:08 <lambdabot>         against inferred type `GHC.Base....
23:48:32 <Jafet> > iterate show "biz"
23:48:33 <lambdabot>   ["biz","\"biz\"","\"\\\"biz\\\"\"","\"\\\"\\\\\\\"biz\\\\\\\"\\\"\"","\"\\\...
23:48:52 <Jafet> I think we're spamming the channel with many queries to lambdabot.
23:48:56 <identity> kmc: I'm trying to grok what you did before: 
23:49:01 <identity> > liftM2 (,) pred succ 3
23:49:02 <lambdabot>   (2,4)
23:49:19 <Jafet> > (pred &&& succ) 3
23:49:20 <lambdabot>   (2,4)
23:49:28 <identity> :t (&&&)
23:49:29 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
23:49:39 <kmc> :t liftM2
23:49:40 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:49:55 <kmc> identity, for a monad M,  liftM2 :: (a → b → c) → M a → M b → M c
23:50:02 <identity> yeah, I get that much
23:50:04 <kmc> now let «M a = t → a»
23:50:12 <kmc> i.e. the instance Monad ((->) t)
23:50:13 <identity> hmm
23:50:16 <Jafet> Is that using the Functor instance of (->r)?
23:50:21 <identity> Oooh
23:50:35 <kmc> yeah, nejucomo had asked about this instance
23:50:39 <identity> Yeah, I saw that
23:50:46 <Jafet> instance Functor ((->) t)... it's like monads for monads
23:50:47 <identity> and afterwards I loaded it up in ghci
23:51:02 <identity> so it doesn't type-check as I thought it shouldn't if I unload C.M.INstances?
23:51:03 <kmc> @djinn (a -> b -> c) -> (t -> a) -> (t -> b) -> t -> c
23:51:04 <lambdabot> f a b c d = a (b d) (c d)
23:51:10 <kmc> ^^^^ that's the definition
23:51:11 <nejucomo> Hm, I also saw fix, but didn't understand from the documentation what it is for.
23:51:20 <kmc> nejucomo, anonymous recursion
23:51:25 <kmc> > fix (1:)
23:51:26 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:51:29 <identity> Heh
23:51:30 <identity> Magic
23:51:59 <nejucomo> > take 7 (fix (+3))
23:51:59 <lambdabot>   No instance for (GHC.Num.Num [a])
23:52:00 <lambdabot>    arising from a use of `e_173' at <inte...
23:52:00 <kmc> > map (fix $ \self n -> if n == 0 then 1 else n * self (n-1)) [1..10]
23:52:01 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800]
23:52:15 <kmc> ^^^ writing recursive factorial without "let" or any other explicit recursion
23:52:22 <Maxdamantus> > fix $ (1:) . zipWith (*) (iterate succ 1)
23:52:23 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
23:52:28 <Jafet> fix is the fixed-point combinator.
23:52:41 * Maxdamantus 's language is advanced enough to handle exactly that code \o/
23:52:43 <nejucomo> :t fix
23:52:44 <lambdabot> forall a. (a -> a) -> a
23:52:45 <kmc> > fix ((0:) . scanl (+) 1)
23:52:46 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:52:49 <kmc> @src fix
23:52:49 <lambdabot> fix f = let x = f x in x
23:53:01 <nejucomo> :t fix (+3)
23:53:02 <lambdabot> forall a. (Num a) => a
23:53:27 <Maxdamantus> > let fix a = a $ fix a in fix (1:)
23:53:28 <dibblego> @pl \k -> fmap join . mapM k
23:53:28 <lambdabot> (fmap join .) . mapM
23:53:28 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:53:32 <nejucomo> > fix (+3)
23:53:35 <lambdabot>   mueval-core: Time limit exceeded
23:53:52 <nejucomo> Oh, right, that's why take didn't work.
23:53:53 <kmc> nejucomo, that's equivalent to «let x = x+3 in x»
23:54:05 <kmc> if f is strict, then «fix f» is ⊥
23:54:12 <kmc> because fix finds the least fixed point
23:54:20 <kmc> and if f is strict, ⊥ is a fixed point of f, by definition
23:54:45 <nejucomo> Does _|_ mean "infinite recursion"?  And how do I type it?  :-)
23:54:54 <kmc> ⊥ means "no value"
23:55:04 <kmc> or "doesn't evaluate normally"
23:55:07 <kmc> it's pronounced "bottom"
23:55:24 <kmc> it's often written _|_ too
23:55:37 <nejucomo> When is an expression _|_ without being infinitely recursive?
23:55:41 <kmc> error "foo"
23:55:55 <nejucomo> Gotcha.
23:56:17 <kmc> in denotational semantics, ⊥ is the meaning ("denotation") for any term which doesn't reduce to a value in finite time, be it due to infinite recursion or an error
23:56:22 <Maxdamantus> Kind of looks like a bottom.
23:56:24 <kmc> yup
23:56:33 <Jafet> > undefined
23:56:34 <lambdabot>   *Exception: Prelude.undefined
23:56:47 <nejucomo> Ok, so the reason I looked into Control.Monad.Instances is because I've wanted a Monad Instance for (state -> (state, value)) several times, so I expected it'd be standard.  Is it?
23:56:56 <kmc> nejucomo, that's Control.Monad.State
23:57:08 <kmc> but it's that inside a newtype wrapper
23:57:41 <nejucomo> Huh…  I don't see Control.Monad.State in my 6.12.2 docs.
23:57:50 <kmc> nejucomo, it's in the mtl package
23:57:56 <nejucomo> Thanks.
23:58:45 <kmc> nejucomo, domain theory was developed to provide denotational semantics for the lambda calculus.  it talks about certain partially-ordered sets representing partially-defined values
23:58:53 <identity> This channel is awesome but kills my productivity. I'm trying to read but always end up looking here and pursuing some tangential haskell magic
23:59:34 <kmc> for example ⊥ < (2,⊥),   (2,⊥) < (2,3),  ⊥ < (⊥,3),  but (2,⊥) and (⊥,3) are incomparable
23:59:36 <kmc> makes sense?
23:59:44 <nejucomo> Woah…  it looks like I've ended up reimplementing some stuff in mtl (except worse, because my haskell fu is still at grasshopper stage).
23:59:57 <nejucomo> identity: Tell me about it.
