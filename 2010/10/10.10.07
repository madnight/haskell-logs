00:02:13 <dirk_> it works on windows too
00:02:26 <Zao> dirk_: And on systems that are not Linux or Windows?
00:02:28 <dirk_> for now it is ok to have it on those two systems
00:02:58 <arw> dirk_: the real question is, why do you need to hide isInfixOf depending on the operating system?
00:03:12 <dirk_> it is correct to consider other systems too, neverless I only got two users 
00:03:15 <dirk_> for now
00:03:16 <arw> dirk_: usually thats no function that would ever conflict with anything.
00:03:47 <dirk_> well I got it in this case, and it works, and I am happy
00:03:52 <dirk_> thanks for your help
00:04:22 <Zao> Normally, if you need to do conditionals like that, it tends to be that Windows is the exceptional one.
00:04:32 <Zao> (exceptionally awesome, but I digress)
00:05:35 <ddarius> His code will stop working when he upgrades some day.
00:05:40 <ksf__> 810 bleeding bugs to the next ghc release
00:05:52 <Zao> How's 7.0 going, by the way?
00:06:04 <Zao> I saw talk of RCs on-list weeks ago, but haven't seen more since then.
00:06:07 <ksf__> 810 bugs tagged with release on the trac
00:06:35 <ksf__> afaict it's working quite fine, but there's very spiky edges.
00:07:06 <ksf__> I wish the devs would mark some bugs as "people who aren't comfortable with the ghc source yet can do this"
00:07:57 <ddarius> I think they often do.
00:08:56 <ksf> ddarius, yes, they mark bugs as "less than a day" or such
00:09:18 <ksf> ...which would most likely amount to nearly a month in my case, as I've never ever even looked at a ghc source file.
00:10:32 <ksf> there's only 5 critical bugs, though.
00:44:29 <bblum> what is the point of 'otherwise'?
00:44:43 <Twey> Makes stuff look pretty
00:44:56 <Twey> Also, I think at least GHC optimises it away completely
00:46:10 <bblum> like where would it look pretty
00:50:16 <kfish> bblum, where it fits into a sentence in your code :) otherwise, just use _ or True
00:51:22 <Botje> Twey: otherwise is just a value bound to True :p
00:51:47 <sipa> typically in pattern-match guards
00:55:05 <bblum> oh, for guard patterns
00:55:05 <bblum> i see
00:55:11 <bblum> ">:|"
00:57:44 <Twey> Botje: Doesn't GHC do some extra optimisation on it?
01:00:08 <ddarius> Twey: I would be very surprised if that were the case.
01:08:22 <Twey> ddarius: Huh.  I thought that GHC never bothered doing the test (if True == True then …) on an ‘otherwise’ guard.
01:08:44 <ddarius> Twey: Why would that be specific to otherwise?
01:09:16 <sipa> there doesn't seem to be anything magical about otherwise
01:09:20 <Botje> Twey: it optimizes Boolean == Boolean, yes
01:11:09 <thomastang> is there any tutorial about how to use yaml?
01:13:03 <thomastang> I've installed the yaml, but don't know how to use it. Say, encodeFile, etc.
01:32:02 * ksf wonders what's the reason that no icfp videos are online.
01:32:18 <ksf> acm trying to sell them on dvd?
01:32:34 <ivanm> did anyone record them?
01:33:31 <Elbar> sony claims ownership?
01:33:51 <ksf> well, the 2009 ones looked like being recorded by acm.
01:33:54 <ivanm> Elbar: why would sony?
01:34:00 <ksf> that is, they were hooked up to the right mics etc.
01:34:24 <ksf> ...and it wouldn't fucking hurt to do that for the haskell workshop videos, too.
01:34:29 <Elbar> if i watch youtube they seem to claim everything
01:34:29 <ivanm> well, before you ask why the videos are online, you should check that there are videos to put online )
01:34:42 <ivanm> ksf: malcolmw did the haskell workshop videos IIRC
01:34:45 <ksf> have a mic for the presenter and two or three audience mics to toss around.
01:34:46 <ivanm> he did them last year anyway
01:34:51 <ivanm> sure they're not the ones you're thinking of?
01:35:08 <ksf> nope.
01:35:22 <ksf> the icfp ones are on his account, too, iirc, though.
01:35:45 <ksf> yep.
01:47:52 <evant_> Can you nest a pattern match, for example: occursIn name (TyConstr UserCon (Id ident _)) = .....
01:49:01 <ddarius> Yes.
01:51:48 <Blkt> good day everyone!
01:52:01 <ManateeLazyCat> Haha, finish : http://www.flickr.com/photos/48809572@N02/5058936665/lightbox/
01:52:16 <ManateeLazyCat> When someone call you, will popup *yellow* window to notify you.
01:52:44 <ManateeLazyCat> You can also popup green *translate tooltip* to translate the message around cursor. 
01:52:57 * ivanm waves idly in Blkt's general direction
01:53:02 <ivanm> hey ManateeLazyCat 
01:53:09 <ManateeLazyCat> ivanm: Hi. :)
01:53:13 <ivanm> ManateeLazyCat: I for one would find that highly annoying...
01:53:19 <ManateeLazyCat> ivanm: Looks http://www.flickr.com/photos/48809572@N02/5058936665/lightbox/
01:53:23 <ivanm> why not use libnotify or something and make the option configurable?
01:53:47 <ManateeLazyCat> ivanm: libnotify can't work when your program in *fullscreen* model. :)
01:54:00 <Entroacceptor> yes, it can
01:54:11 <ivanm> ManateeLazyCat: that's just ubuntu's broken engine
01:54:13 <ManateeLazyCat> ivanm: Notify just notify you when you *not* in current buffer.
01:54:14 <ivanm> pick a different engine
01:54:43 <ManateeLazyCat> ivanm: And translate tooltip just show manually. :)
01:56:07 <ManateeLazyCat> Entroacceptor: Well, i'm tired to depend those easy broken package since i can develop better. :)
01:56:34 <ManateeLazyCat> Entroacceptor: notify-osd is cool, but broken..... so i create my own.
02:07:27 <republican_devil> hey I have a question about so called continuations
02:10:01 <ksf> Haskell doesn't really have full-blown continuations, only delimited ones.
02:10:23 <ksf> ...not that I've ever heard a schemer complain about that, thouh.
02:12:52 <ivanm> "so-called"? why only "so-called"?
02:21:02 <osfameron> well, that's what they're called, I suppose ;-)
02:21:28 <osfameron> republican_devil: did you only want to declare that you had the question, or were you also going to ask it? ;-)
02:21:48 * osfameron has a really good question, but he's not going to answer it, in case you lot all copy it!
02:21:57 <osfameron> um, *ask even
02:24:00 <malorie_> I'm looking for a way to turn ``func n = n `mod` 3 == 0 && n `mod` 5 == 0'' into point-free style. any suggestions?
02:24:19 <sipa> @pl \n -> n `mod` 3 == 0 && n `mod` 5 == 0
02:24:19 <lambdabot> ap ((&&) . (0 ==) . (`mod` 3)) ((0 ==) . (`mod` 5))
02:24:24 <sipa> there you go
02:24:38 <malorie_> ah. nice
02:24:43 <Twey> Yuck
02:24:50 <Twey> Don't blindly use @pl output
02:25:09 <Twey> For a start, that means that n `mod` 15 == 0
02:25:22 <Twey> So you can write it as func = (== 0) . (`mod` 15)
02:25:46 <sipa> depends, for Integers you are right :)
02:26:00 <malorie_> I see
02:26:03 <republican_devil> crap can't scroll up in irssi
02:26:04 <republican_devil> ok
02:26:05 <ddarius> Sounds like someone is failing at FizzBuzz.
02:26:29 <malorie_> ddarius: nah
02:26:39 <Maxdamantus> This is for one of the first few PE questions, isn't it?
02:26:40 <republican_devil> so I am reading here http://lib.store.yahoo.net/lib/paulgraham/bbnexcerpts.txt how continuations can simualte subroutines
02:27:00 <republican_devil> and also how each user got its own session
02:27:13 <republican_devil> really cool webapp style
02:27:35 <malorie_> Maxdamantus: I'm just trying to understand how to turn a function into point-free style where the argument is used twice
02:27:49 <Twey> malorie_: liftM2 is useful
02:27:59 <republican_devil> How are continuations better than "regular" prgramming?  Are continuations keeping info in memory and the acting upon it?
02:28:22 <Twey> liftM2 (&&) ((== 0) . (`mod` 3)) ((== 0) . (`mod` 5))
02:28:29 <ivanm> from my brief understanding from reading the wikipedia article, using continuations isn't that great
02:28:52 <ivanm> * an idea
02:29:12 <Twey> liftM2 (on (&&) (== 0)) (`mod` 3) (`mod` 5)
02:29:33 <malorie_> Twey: this seems to be the thing I was looking for. thanks.
02:30:02 <ClaudiusMaximus> republican_devil: compilers can transform 'regular' code into 'continuation passing style' for profit (as i understand it, which isn't thoroughly at all)
02:30:18 <ddarius> republican_devil: Your question is like asking how are integers better than "regular" programming.
02:31:25 <republican_devil> hm
02:31:26 <republican_devil> ok
02:32:21 <republican_devil> To what extent can I keep in memory the info about web requests, and then send dynamic pages back based on new actions by the client?
02:32:37 <ddarius> republican_devil: To any extent you want.
02:36:26 <republican_devil> awesome
02:36:47 <republican_devil> I envision keeping logic and handling in memory and images on disk.
02:36:56 <republican_devil> that should keep things snappy
02:37:28 <republican_devil> haskell apparently is loaded with abstraction tools and data structures
02:37:45 <republican_devil> I don't get anything about strong typing yet or wtf monads are.
02:38:03 <Twey> @quote endofunctors
02:38:03 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
02:39:11 <republican_devil> hook the ion cannon to the matter anti matter engine and feed power through the mobius helix
02:39:13 <ddarius> @quote lax
02:39:13 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
02:39:45 * Twey chuckles.
02:39:47 <ddarius> pop esp, always a fun instruction
02:40:16 <republican_devil> I am tempted to learn haskell.
02:40:28 <republican_devil> What do I have to lose?
02:40:40 <ddarius> Your immortal soul.
02:41:04 <ksf> republican_devil, your happiness and innocence.
02:41:06 <ksf> http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
02:41:12 <PatrickRobotham> your sanity 
02:41:20 <republican_devil> python bugs me
02:41:24 <republican_devil> I dunno why work love it
02:41:32 <republican_devil> bash I get most done in
02:41:36 <republican_devil> understandable code too
02:41:51 <BONUS> what haskell evangelists often don't mention is that there's a special circle of hell reserved just for haskell users
02:41:58 <BONUS> which is a BIG drawback to using haskell
02:42:16 <ketil> republican_devil, If you put your heart and soul into your work, you're likely to lose your mind as well.
02:42:33 <republican_devil> some idiot nix admin even said "whats that gay language you were going on about? haskell? bah!when you guna learn ruby?"
02:42:47 <ketil> (Attributed to, I think, van Gogh, so he knew what he was talking about :)
02:42:55 <republican_devil> My soul is pledged to 8 gods and counting.
02:44:51 <republican_devil> I don't want to be a product of my environment, I want my environment to be a product of me!
02:46:25 <republican_devil> http://hackage.haskell.org/platform/linux.html freebsd has ghc 6.10 in ports
02:46:45 <republican_devil> seems like a bitch to upgrade if I need ghc 6.12 to install?
02:48:44 <ksf> you should use 6.14
02:49:05 <republican_devil> http://www.haskell.org/ghc/download_ghc_6_12_3.html#freebsd
02:49:08 <republican_devil> ah ha
02:49:33 <republican_devil> 12 June 2010 GHC 6.12.3 Released! [download]
02:49:39 <republican_devil> 6.14 not out
02:50:07 <ksf> erm
02:50:08 <ksf> yes.
02:50:10 <Zao> republican_devil: Next GHC will be 7.0, most probably.
02:50:20 * ksf wonders how he got to 14
02:50:37 <ksf> not only most probably, but definitely.
02:50:50 <ksf> % ghc --version
02:50:50 <ksf> The Glorious Glasgow Haskell Compilation System, version 7.0.0.2010093
02:51:03 <ksf> it's going to be 7.0.1
02:51:10 <ksf> ...the first release, that is.
02:51:23 <republican_devil> I feel small
02:52:12 <ksf> the reason is a new type system implementation because the old one "looks like a game of jenga in the last stages" (quote spj)
02:52:24 <ksf> no user-visible changes, though, unless you use -XGADTs
02:52:34 <ksf> and even those are minor.
02:52:47 <dolio> There are multiple user-visible changes.
02:52:59 <ksf> more than let generalisation?
02:53:03 <dolio> Yes.
02:53:09 <ddarius> ksf: That alone would be a big change.
02:53:17 <dolio> Superclass equality constraints now work.
02:53:22 <ksf> wooo!
02:53:29 <dolio> 'runST $ do ...' works again for some reason.
02:53:37 <ksf> they didn't the last time I tried 6.14
02:54:40 <dolio> id :: (forall a. a) -> (forall a. a) causes a type error, but that's almost certainly a bug.
02:55:04 <ksf> well, it should.
02:55:13 <ksf> id :: forall a . a -> a
02:55:29 <ksf> what you're saying there is unsafeCoerce :: a -> b
02:55:47 <quicksilver> no, it's just an impredicative instantiation of id
02:56:01 <ddarius> ksf: The first forall can't be lifted out.
02:56:10 <ksf> oh
02:56:55 <ksf> well, at least according to my intution it'd still be two different variables as the second forall shadows the earlier forall.
02:57:44 <dolio> The variable from the first forall isn't even in scope in the second forall.
02:57:48 <ddarius> ksf: (forall a. a) -> b is a different type than forall a. a -> b
02:58:20 <ddarius> And as quicksilver mentioned, there is no way this is unsafeCoerce as it is an instantiation of id.
02:58:44 * ksf thinks he understands impredicativity for the first time ever and thinks it's a work of the devil.
02:59:23 <ToRA> hey guys, what's the current state of the art with arrow based frp? (i.e. if you could only read one paper on arrow-frp which would it would be...?)
02:59:38 <ksf> yampa, lava
02:59:49 <ksf> oh, grapefruit.
02:59:56 <ksf> definitely don't miss grapefruit.
03:00:21 <republican_devil> anyone write a software release program in haskell?
03:00:39 <ToRA> ksf: Signals, Not generators! ?
03:00:43 <bremner> republican_devil: at least I don't know what that is
03:00:48 <republican_devil> like something to sync configs, set environmental variables, and place binarues on set fo prod/qa boxes?
03:01:07 <republican_devil> and check if they in sync as planned
03:01:16 <republican_devil> eg that the things are proper versions
03:01:25 <quicksilver> ddarius: I wouldn't be surprised to hear there are holes in impredicativity
03:01:29 <bremner> ah. something like puppet
03:01:32 <quicksilver> ddarius: I think it's always been a dodgy corner ;)
03:01:42 <republican_devil> I never used puppet
03:01:43 <quicksilver> actually I'm not sure you call it impredicativity if it's (->).
03:01:45 <ksf> grapefruit, together with reactive, is the most advanced and pure (if unpure, elerea also counts) frp library
03:02:00 <ksf> grapefruit+reactive are both push/pull
03:02:00 <quicksilver> I think you call it impredicativity for 'data' types and just higher-rank for id.
03:02:01 <republican_devil> can haskell set environmental vars on a unix box?
03:02:09 <republican_devil> such that a tomcat instance could use them?
03:02:13 <bremner> republican_devil: I'm not aware a of "configuration management" system in haskell.
03:02:16 <Twey> @faq Can Haskell set environmental vars on a UNIX box?
03:02:16 <lambdabot> The answer is: Yes! Haskell can do that.
03:02:39 <zomg> @faq Can haskell perform acts of magic?
03:02:39 <lambdabot> The answer is: Yes! Haskell can do that.
03:02:48 <zomg> Nice
03:02:50 <zomg> =)
03:03:00 <republican_devil> ghc seems nice, found amd64 freebsd 8 package
03:03:02 <republican_devil> nice!
03:03:09 <Maxdamantus> @faq Can't Haskell be used for something useful?
03:03:09 <lambdabot> The answer is: Yes! Haskell can do that.
03:03:13 <republican_devil> now is ghc alone very inferior to the haskell "platform"
03:03:14 <republican_devil> ?
03:03:16 <republican_devil> lol
03:03:39 <ksf> republican_devil, get cabal-install and don't worry about the platform.
03:03:48 <Maxdamantus> @faq Can
03:03:48 <lambdabot> The answer is: Yes! Haskell can do that.
03:03:49 <ksf> ...it's only a set of libraries.
03:05:45 <republican_devil> AWESOME
03:05:51 <republican_devil> this is a huge chest fulla awesome
03:06:33 <ksf> cabal-install and hackage are like CPAN, just technically superiour.
03:06:53 <republican_devil> even blindingly awesomerrrrr
03:07:07 <republican_devil> http://www.thinkgeek.com/homeoffice/kitchen/d293/ as awesome as this plus ice cream!
03:07:45 <HalfWayMan> Hmm. Chimpsticks.
03:08:07 <ksf> that is, cabal can deal with multiple versions of the same package installed simultaneously, for which dependency resolving is NP-complete in theory 
03:08:28 <Maxdamantus> @faq Can Haskell be PHP?
03:08:29 <lambdabot> The answer is: Yes! Haskell can do that.
03:08:57 <HalfWayMan> @faq Can HalfWayMan use Haskell?
03:08:57 <lambdabot> The answer is: Yes! Haskell can do that.
03:08:59 <HalfWayMan> Liar.
03:10:39 <republican_devil> np-complete?
03:10:40 <burp> @faq Can Haskell use HalfWayMan?
03:10:41 <lambdabot> The answer is: Yes! Haskell can do that.
03:10:45 <burp> that is the correct question
03:10:47 <HalfWayMan> Question guys: If I invoke GHC to compile a shared library can I load it in runtime?
03:10:48 <republican_devil> haskell have anything to do with nixos?
03:10:50 <HalfWayMan> burp: :)
03:10:55 <PatrickRobotham> @faq can haskell do my taxes? 
03:10:56 <lambdabot> The answer is: Yes! Haskell can do that.
03:11:02 <republican_devil> in soviet russia, haskell uses you!
03:11:17 <PatrickRobotham> @faq can haskell summon cthulhu?
03:11:17 <lambdabot> The answer is: Yes! Haskell can do that.
03:11:23 <republican_devil> lol
03:11:40 <republican_devil> can haskell fight khorne the blood god and his chaos champions and warp demons?
03:11:56 <republican_devil> awesome got ghci running!
03:11:58 <republican_devil> on freebsd 8.1
03:12:01 <republican_devil> a55um!
03:12:05 <republican_devil> er
03:12:13 <republican_devil> how do I exit ghci?
03:12:14 <republican_devil> lol
03:12:15 <Zao> republican_devil: On some silly architecture?
03:12:17 <Zao> ^D
03:12:18 <PatrickRobotham> @faq can haskell destroy the universe?
03:12:18 <lambdabot> The answer is: Yes! Haskell can do that.
03:12:26 <PatrickRobotham> republican_devil: type :q
03:12:34 <Maxdamantus> @faq Can Haskell implement the universe?
03:12:34 <lambdabot> The answer is: Yes! Haskell can do that.
03:12:43 <republican_devil> :q makes me feel better
03:12:48 <republican_devil> ctl seems to vulgar
03:12:58 <flux> @faq Can Haskell generate a problem that is too large for Haskell to solve?
03:12:58 <lambdabot> The answer is: Yes! Haskell can do that.
03:13:00 <republican_devil> freekin awesome gents
03:13:02 <flux> hmmmm!
03:13:02 <Zao> republican_devil: The port should work out of the box on IA32 and amd64.
03:13:12 <Zao> republican_devil: I don't consider "end-of-input, yo" to be "vulgar".
03:13:16 <republican_devil> yep workin
03:13:18 <Twey> @faq Can Haskell then solve that problem anyway?
03:13:18 <lambdabot> The answer is: Yes! Haskell can do that.
03:13:22 <PatrickRobotham> lol Zao
03:13:36 <republican_devil> GHCi, version 6.12.3: http://www.haskell.org/ghc/  :? for help
03:13:43 <republican_devil> Prelude>
03:13:52 <republican_devil> I summon the power of haskell!
03:14:02 <republican_devil> the force is a powerful ally!
03:14:28 <republican_devil> I must learn control, feel the force flowing through me!
03:15:00 <republican_devil> screw that python crap
03:15:22 <HalfWayMan> All I can find is hs-plugins, is there anything else?
03:15:37 <republican_devil> and screw volume bodybuuilding, I am a HIt trainer
03:24:13 <quicksilver> HalfWayMan: hint, mueval, dyre
03:24:16 <quicksilver> probably more.
03:28:05 <nickela> @pl \a -> [ const a ]
03:28:06 <lambdabot> return . const
03:28:50 <Twey> Slight lie there
03:29:11 <Twey> That type is more general — you'll need a signature or unambiguous usage to pare it down to a list
03:29:31 <Maxdamantus> @pl \a -> [a, a a]
03:29:31 <lambdabot> ap (:) (return . join id)
03:29:32 <Twey> The real point-free version would be (: []) . const
03:30:37 <Maxdamantus> @pl \a -> [[[a]]]
03:30:38 <lambdabot> return . return . return
03:32:05 * ddarius is suddenly connecting Chris Lattner to a variety of things.
03:56:55 <Axman6> :t \a -> [a, a a]
03:56:55 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t
03:56:56 <lambdabot>     Probable cause: `a' is applied to too many arguments
03:56:56 <lambdabot>     In the expression: a a
03:59:21 <Axman6> :t \a -> [a, a a :: forall a. a -> a]
03:59:22 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> a -> a
03:59:22 <lambdabot>     Probable cause: `a' is applied to too many arguments
03:59:22 <lambdabot>     In the expression: a a :: forall a. a -> a
03:59:42 <Axman6> :t \(a :: forall a. a -> a) -> [a, a a]
03:59:43 <lambdabot> forall a. (forall a1. a1 -> a1) -> [a -> a]
04:00:49 <mjrosenb> Axman6: doesn't that guarantee that a *must* be the identity function?
04:03:11 <ddarius> or undefined or const undefined.
04:05:51 <mjrosenb> right.
04:06:17 <mjrosenb> but of things that actually evaluate to values...
04:06:37 <mjrosenb> well const undefined evaluates to a value
04:13:30 <quicksilver> ddarius: or "undefined undefined" or "const (undefined undefined)" or.....
04:13:43 <quicksilver> (my point being, once you consider undefined an acceptable answer, you can think of many more)
04:13:54 <quicksilver> normally I don't consider undefined an acceptable answer.
04:17:01 <ddarius> quicksilver: undefined undefined is not distinguishable from undefined, similarly for const (undefined undefined)
04:17:28 <ddarius> There are exactly three distinguishable values of type forall a. a -> a.
04:17:58 <ddarius> Unless we allow unsafePerformIO.
04:18:35 <sipa> how is undefined distinguishable from const undefined?
04:18:59 <sipa> right, the first doesn't need a function application before it causes failure
04:22:53 <bss03> ddarius: undefined, const undefined, and id?
04:23:15 <bss03> boegel: I hope you are improving your bot.
04:23:48 <bss03> boegel: Being the 2nd best Haskeller in the competition is... odd.
04:24:08 <bss03> boegel: I've written Haskell from probably less than a year, really.
04:25:37 <ksf> there's also seq and par
04:25:53 <ksf> and trace ""
04:26:14 <boegel> bss03: I got to Haskell after 3 years of inactivity
04:26:24 <boegel> bss03: but yes, I'm still working on my bot in my free time
04:26:34 <boegel> bss03: I'll hopefully get to uploading a better version sometime next week
04:28:41 * mjrosenb should port his bot from c++ to haskell
04:29:47 * mjrosenb mostly did not use haskell because the 'starter pack' that i grabbed did not include any useful information, such as 'how do i get the game state' or 'how do i make a move'
04:30:00 <IceDane> Anyone have experience using the HTTP package?
04:30:08 <IceDane> One of the examples is invalid
04:32:10 <dschoepe> IceDane: which one?
04:32:29 <IceDane> http://hackage.haskell.org/package/HTTP-4000.0.9 <- on this page, the second one
04:32:32 <IceDane> Browser one
04:33:23 <bss03> mjrosenb: Odd.  By the time I got to the starter pack (2010-09-09) it already had an example bot.
04:50:36 <mjrosenb> bss03: i think i grabbed a different starter pack.
04:50:49 <mjrosenb> bss03: was the one you grabbed written in literate haskell?
04:52:08 <ivanm> IceDane: what's the error? type mis-match? functionality not working?
04:53:48 <IceDane> ivanm: I figured it out, actually, but yes, it doesn't type-check
04:54:25 <IceDane> getResponseBody expects Result (Response a) while the example is trying to use it on (URI, Response a)
04:54:26 <Sadache> is sequence function lazy?
04:54:45 <sipa> @hoogle sequence
04:54:46 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
04:54:46 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
04:54:46 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
04:54:55 <sipa> that one?
04:55:09 <Sadache> in other words, will sequence hang on an ifinite list?
04:55:16 <IceDane> Sadache: yes.
04:55:22 <IceDane> It's evaluating a whole list, as you can see by the type
04:55:26 <sipa> yes
04:55:30 <donri> Duck typing: If it walks like a serotonergic neurotransmittor, quacks like a serotonergic neurotransmittor, it's a 3,4-Methylenedioxymethamphetamine molecule.
04:55:47 <sipa> well, maybe not
04:56:25 <ray> if it walks like an integer and talks like an integer, it's a float
04:56:26 <ddarius> Sadache: It depends on the monad.
04:56:30 <Sadache> is it impossible to have a lazy version of it?
04:56:39 <sipa> if you're using the maybe monad, and after a finite number of steps you get a Nothing
04:56:40 <Sadache> ddarius: the writer
04:56:55 <ddarius> Sadache: It should be fine for the writer monad.
04:57:11 <ddarius> (Assuming the monoid is lazy.)
04:58:12 <ddarius> > snd $ runWriter (sequence (repeat (tell "a")))
04:58:13 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
04:59:35 <frerich3> There's something Zen-like to "if you're using the maybe monad, and after a finite number of steps you get a Nothing".
04:59:46 <Sadache>  snd $ runWriter (sequence (repeat (tell "a" >> return "b")))
05:01:17 <Axman6> :t tell
05:01:18 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
05:01:31 <Twey> snd . runWriter . sequence . repeat $ tell "a" >> return "b"
05:02:13 <Twey> evalWriter . sequence . repeat $ tell "a" >> return "b"
05:02:21 <Twey> :t repeatM
05:02:22 <lambdabot> Not in scope: `repeatM'
05:02:24 <Twey> Damn
05:04:47 <ddarius> @hoogle repeatM
05:04:47 <lambdabot> No results found
05:04:55 <quicksilver> I believe repeatM isn't defined because it's useless for so many monads.
05:05:15 <quicksilver> it does, of course, work for some as ably demonstrated above :)
05:06:04 <Twey> Mm
05:06:10 <ksf> :t forever
05:06:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
05:08:05 <sipa> ha
05:08:18 <bss03> mjrosenb: No.  It was non-literate Haskell, but it did have some haddockumentation blocks.
05:08:44 <tensorpudding> it takes forever to reach ⊥
05:09:16 <bss03> ksf: I don't think trace is allowed, since it is built on unsafePerformIO
05:09:50 <sipa> :t trace
05:09:51 <lambdabot> Not in scope: `trace'
05:10:03 <bss03> :t Debug.trace
05:10:03 <lambdabot> Couldn't find qualified module.
05:10:05 <dschoepe> :t Debug.Trace.trace
05:10:06 <lambdabot> forall a. String -> a -> a
05:10:17 <bss03> @src Debug.Trace.trace
05:10:17 <lambdabot> Source not found. stty: unknown mode: doofus
05:11:54 <bss03> ksf: I guess seq doesn't and par don't count either.
05:12:51 <bss03> ksf: (_|_ seq) is indistinquishable from const undefined, I think.
05:13:12 <bss03> ksf: (stuff seq) is indistinquishable from id, I think.
05:13:41 <ddarius> id is already strict
05:13:53 <ddarius> As is const undefined.
05:14:18 <ddarius> (and undefined if you want to count thatl
05:15:10 <quicksilver> the fact that "id is strict" is a good test of whether you really understand strictness, IMO ;)
05:15:33 <quicksilver> if you have an incomplete intuitive understand you probably think that id is nonstrict; I know I did originally
05:15:48 <bss03> ddarius: Well, ksf was suggesting seq, par, and trace as other distiguishable values of type forall a. a -> a.
05:16:14 <tensorpudding> > const (id undefined) 5
05:16:15 <lambdabot>   *Exception: Prelude.undefined
05:16:20 <ksf> I didn't say anything about distinguishability.
05:16:27 <tensorpudding> oh wait, wrong order
05:16:28 <ksf> they're operationally distinguishable.
05:16:33 <tensorpudding> > const 5 (id undefined)
05:16:34 <lambdabot>   5
05:16:47 <bss03> ddarius: I think they are all equivalent to one of undefined, id, and const undefined
05:16:50 <ksf> ...not semantically. that's their very point.
05:17:19 <ddarius> Trace is semantically distinguishable from any of those.
05:18:10 <bss03> ddarius: But, trace uses unsafePerformIO, so it doesn't count.
05:18:17 <ddarius> Correct.
05:19:21 <ddarius> Neither seq nor par have the type forall a. a -> a, and while a design goal of par is to be semantically indistinguishable from const, that's obviously not the case for seq.
05:19:41 <sipa> :t par
05:19:42 <lambdabot> forall a b. a -> b -> b
05:20:08 <bss03> ddarius: I assumed ksf meant parital applications of seq and par.
05:20:09 <zygoloid> quicksilver: "const undefined is strict" is another good one for that
05:20:50 <ddarius> The formal definition of strict is trivial.
05:20:57 <zygoloid> the "forcing the result forces the argument" misunderstanding gives "id is strict" but not "const undefined is strict"
05:22:24 <sipa> what is the formal definition of strict?
05:22:36 <zygoloid> sipa: f is strict iff f _|_ == _|_
05:23:12 <ivanm> zygoloid: well, strict in that argument, right?
05:23:28 <ddarius> Functions only have one argument in Haskell..
05:23:47 <ivanm> yeah, yeah
05:23:59 <zygoloid> yeah. the formal definition isn't concerned with informal notions such as "multi-argument functions"
05:24:06 <ivanm> I was going to get to it also depending sometimes on other arguments
05:24:21 <ivanm> e.g. "(&&) True" is strict, "(&&) False" isn't
05:24:23 <zygoloid> conditional strictness is more complex
05:24:54 <ddarius> You get different f's then, though certainly there are formal definitions of "strict in an argument" in less Haskell-specific contexts.
05:25:59 <ddarius> zygoloid: By the way, did you just coin "conditionally strict" or did you get it from somewhere, and if so, where?
05:26:23 <sipa> zygoloid: is 'being strict' equivalent to 'definitely pattern matches on its argument' ?
05:26:51 <bss03> sipa: Nope.  (const undefined) doesn't care about it's argument.  But, it is strict.
05:27:09 <sipa> ha, i see
05:29:23 <ivanm> it's more along the lines of "does it actually use its argument?"
05:29:47 <ivanm> bss03: "const undefined" isn't strict, const is ;-)
05:29:48 <manateeUser> My irc client teach me a lots. :)
05:30:44 <manateeUser> When i don't understand some words, just press C-j will got Chinese translation, then study how to improve my English. :)
05:30:56 <zygoloid> ivanm: wrong, const undefined /is/ strict.
05:30:57 <bss03> ivanm: (const undefined) is strict.  If you pass in _|_ you get _|_.
05:31:16 <zygoloid> ivanm: it's not about using the argument. it's about being /no more defined/ than the argument
05:31:25 <ivanm> oh, I thought it's an iff
05:31:40 <zygoloid> it is an iff. const undefined _|_ == _|_, so const undefined is strict
05:31:48 <bss03> f is strict <-> f _|_ = _|_
05:32:15 <ivanm> zygoloid: wouldn't an iff be: const undefined x == _|_ <==> x == _|_ ?
05:32:29 <ivanm> (which is what I meant anyway)
05:32:39 <ivanm> > const undefined 2
05:32:39 <lambdabot>   *Exception: Prelude.undefined
05:32:40 <zygoloid> no, that's not how it's defined. f is strict iff f _|_ = _|_
05:32:44 <ksf> conversely, if you get a whnf out of a function while passing undefined in, it is lazy
05:32:48 <ksf> ...in that argument.
05:32:49 <ivanm> zygoloid: ahhh
05:33:27 <zygoloid> ddarius: i didn't coin conditional strictness; it's a fairly common term (there are papers out there on how to do conditional strictness analysis, for instance)
05:34:19 <ddarius> zygoloid: Okay.  I used the term years ago but I just made it up then as it seemed like the obvious wording.
05:34:33 <bss03> > length . (: []) $ undefined
05:34:33 <lambdabot>   1
05:34:40 <zygoloid> ddarius: maybe *you* coined it then ;)
05:34:47 <ddarius> zygoloid: I doubt it.
05:35:40 <ksf> manateeUser, /me recommends reading Dune and LOTR
05:36:14 <ksf> while being awesome stories, they're also written in really, really good english.
05:37:03 <bss03> > let f = const undefined in f `seq` 3
05:37:04 <lambdabot>   3
05:37:05 <ivanm> I beg to differ
05:37:18 <ivanm> I didn't find the english in LOTR to be that good
05:37:27 <ivanm> unless you mean technically correct wrt grammar, etc.
05:37:41 <ksf> it doesn't strive to be snobbish, no.
05:37:55 <ray> it's not purple if that's what you mean!
05:38:00 <ksf> that'd be below tolkien's level.
05:38:03 <ivanm> I found it too convoluted
05:38:14 * ivanm must be the only geek that can't stand LOTR
05:38:20 <ray> it's pretty much clear
05:38:23 <ksf> then you must be american
05:38:32 <ivanm> ksf: nope
05:38:40 <ivanm> I come from a Land Down Under
05:38:40 <hpc> @let f :: Int -> Int -> Int; f 0 x = x; f _ = undefined in f 5 `seq` 4
05:38:40 <lambdabot>   arity mismatch for 'f'
05:38:45 <hpc> > let f :: Int -> Int -> Int; f 0 x = x; f _ = undefined in f 5 `seq` 4
05:38:45 <ray> americans love their tolkien
05:38:45 <lambdabot>   Equations for `f' have different numbers of arguments
05:38:46 <lambdabot>    <interactive>:1:28...
05:38:50 <ksf> those who can't parse sentences exceeding ten words.
05:38:53 <hpc> grrrr
05:38:55 <sipa> ivanm: i gave up reading it, too boring :)
05:39:00 <ray> update your stereotype cache pls
05:39:20 <bss03> > let f :: Int -> Int -> Int; f 0 x = x; f _ _ = undefined in f 5 `seq` 4
05:39:20 <lambdabot>   4
05:39:28 <ivanm> sipa: same
05:39:40 <ksf> thinking of it, most english authors use way too short sentences.
05:39:47 <bss03> > let f :: Int -> Int -> Int; f 0 x = x; f _ _ = undefined in f undefined `seq` 4
05:39:47 <ivanm> LOTR2 was the first book that I didn't bother finish reading
05:39:48 <lambdabot>   4
05:40:03 <ivanm> and considering I typically read a book that size in a day or two and ended up stretching it out for 2 weeks...
05:40:22 <hpc> bss03: i was trying to have undefined :: Int -> Int
05:40:42 <ivanm> @type (undefined :: Int -> Int)
05:40:43 <lambdabot> Int -> Int
05:40:47 <ivanm> hpc: ^^
05:40:56 <bss03> hpc: Ah.  You can do that.
05:41:04 <hpc> > let f :: Int -> Int -> Int; f 0 x = x; f _ = (undefined :: Int -> Int) in f 5 `seq` 4
05:41:04 <lambdabot>   Equations for `f' have different numbers of arguments
05:41:05 <lambdabot>    <interactive>:1:28...
05:41:05 * ddarius uses overly long sentences.
05:41:08 <bss03> > let f :: Int -> Int -> Int; f 0 x = x; f _ x = undefined x in f 5 `seq` 4
05:41:09 <lambdabot>   4
05:41:20 <ray> > (undefined :: Int -> Int) 3
05:41:21 <lambdabot>   *Exception: Prelude.undefined
05:41:37 <bss03> > let f :: Int -> Int -> Int; f 0 = id; f _ = undefined in f 5 `seq` 4
05:41:37 <ray> > undefined 3
05:41:37 <lambdabot>   *Exception: Prelude.undefined
05:41:38 <lambdabot>   *Exception: Prelude.undefined
05:41:42 <frerich3> ksf: I was about to point out that german lets you create (valid) sentences of arbitrary length, but seeing your host name I guess you knew that already...
05:41:57 <IceDane> Any of you guys worked with HTTP stuff a lot in haskell, and happen to have a preferred package to use for it that you could point me to? Been using HTTP from hackage and it's seemingly bugged, inconsistent and poorly documented
05:42:12 <ddarius> LoTR is very slow at times.  Some of his other books are even worse in that regard.  The Hobbit, though, is nice and fun.
05:42:16 * bss03 hasn't done HTTP in Haskell, yet.
05:42:19 <ivanm> AFAIK HTTP _is_ the package
05:42:24 <ray> it's a line, it has to be to some scale
05:42:25 <IceDane> Bah.
05:42:25 <hpc> bss03: ^^
05:42:39 <ivanm> IceDane: how is it buggy?
05:42:40 <hpc> it would be nice if you could do it my way
05:42:48 <ivanm> IceDane: what are you actually wanting to do?
05:42:54 <hpc> though it is probably for the best that particular style is discouraged
05:43:04 <IceDane> ivanm: Well, it is hanging indefinitely(without making any tcp/ip requests according to process explorer) on www.google.dk
05:43:11 <ray> is it a bivector?
05:43:11 <ddarius> frerich3: I'd be surprised if there were any wide-spread language (i.e. pretty much all of them) that doesn't allow that.
05:43:21 <IceDane> I don't want to do anything that has anything to do with google.dk direclty, but I was merely testing my code and it hangs indefinitely
05:43:25 <bss03> hpc: I guess.  Mixing arity in defintitions could make for some really odd type errors.
05:43:30 <IceDane> ivanm: I'm just writing something to do tinyurls for fun
05:43:34 <ivanm> IceDane: are you sure you're doing it correctly?
05:43:35 <frerich3> ddarius:  Probably, but germans *tolerate* that, too ;-)
05:43:38 <IceDane> ivanm: Positive
05:43:49 <ivanm> there are some tinyurl style packages on hackage IIRC
05:43:51 <ksf> you can even create proper nouns of arbitrary length...
05:43:52 <ivanm> check how they do it
05:44:01 <IceDane> ivanm: The same thing works for www.google.com, which returns a 302 response for www.google.dk because I'm located in Denmark
05:44:05 <ddarius> frerich3: Okay, that is a difference.
05:44:38 <ivanm> IceDane: wait, you're saying it works for .com but not .co.dk ?
05:44:42 <IceDane> ivanm: exactly
05:44:48 <IceDane> And every other site that I've tried it works fine
05:44:54 <ivanm> or just .dk
05:44:56 <IceDane> (just .dk, btw)
05:44:59 <ivanm> IceDane: *shrug*
05:45:05 <ivanm> never used it myself
05:45:13 <ivanm> maybe see if there's a way of tracing it or something
05:45:18 <IceDane> I'm just saying that it's.. strange. E.g. I don't want to be using that behaves so erratically
05:45:21 <ivanm> how large is your code?
05:45:28 <IceDane> about 10 lines or some such
05:45:34 <ivanm> @where hpaste
05:45:34 <lambdabot> http://hpaste.org/
05:45:41 <IceDane> But the code in question is merely a oneliner
05:45:41 <ivanm> ^^ paste it up; I'll see if it works here
05:45:46 <ivanm> could be something wrong on your end
05:45:50 <IceDane> simpleHTTP (getRequest "http://www.google.dk")
05:46:00 <IceDane> that's all you need if you import Network.HTTP
05:46:02 <IceDane> (in ghci)
05:46:10 * ddarius thinks his Google Desktop database is somehow damaged.  Possibly the format changed with a new version?
05:46:38 <ivanm> I get stuff
05:46:47 <IceDane> 302 response?
05:46:49 <ivanm> cookie setting, etc.
05:47:06 <IceDane> Should be able to see response at the top
05:47:13 <IceDane> It's probably 302 since you're not in denmark
05:47:35 <ivanm> I don't see anything saying 'response'
05:47:42 <ivanm> but I don't see that for google.com.au (and I'm from australia)
05:48:40 <IceDane> ivanm: at the top, "Right HTTP/1.1 302 Found"
05:48:55 <ivanm> I get 200
05:49:09 <ivanm> IceDane: http://paste.pocoo.org/show/272192/
05:49:32 <IceDane> That is indeed strnage
05:49:36 <IceDane> Well
05:49:38 <ivanm> so I'm guessing it's something going wrong from your end ;-)
05:49:44 <IceDane> I don't think so
05:49:47 <ivanm> cache problemm or something
05:49:57 <IceDane> I just think that google's way of handling regions is different if you're from australia
05:50:00 <IceDane> hmm
05:50:07 * ivanm doubts it
05:50:30 <ivanm> IceDane: send an email to -cafe asking about it then
05:50:35 <IceDane> ivanm: Alright, thanks
05:50:36 <ivanm> seeing if anyone else from denmark can try it
05:51:20 <ddarius> 70's CS terminology, how quaint: "The following machine-code program, coded in ALGOL 68..."
05:51:37 <ray> it's MACHINE CODE.
05:51:59 <IceDane> ivanm: It's definitely something in the package. I tried Network.Browser.browse and it worked fine o.o
05:52:19 <ray> 70s CS professor portraits are what's quaint
05:52:48 <IceDane> Meh
05:52:50 <IceDane> I'll ask cafe
05:53:45 * ivanm -> sleep
05:53:47 <ivanm> g'night all
05:53:51 <IceDane> night
06:02:58 * hackagebot deepseq 1.1.0.1 - Fully evaluate data structures  http://hackage.haskell.org/package/deepseq-1.1.0.1 (SimonMarlow)
06:03:07 <hpc> perhaps it was an ALGOL machine
06:03:11 <hpc> like a LISP machine
06:04:16 <earthy> burroughs B5000
06:06:03 <earthy> but machine-code was distinct from pseudo-code as well
06:06:40 <earthy> or high level algorithms described as steps in an informal maths/english mix
06:06:59 * hackagebot parallel 3.1.0.1 - Parallel programming library  http://hackage.haskell.org/package/parallel-3.1.0.1 (SimonMarlow)
06:08:47 <earthy> ddarius: if you want to try that code, there *is* an algol 68 interpreter available at http://www.xs4all.nl/~jmvdveer/algol.html
06:16:32 <ddarius> Presumably I could recreate an ALGOL 68 implementation from old papers if I really needed to.
06:50:33 <killown> > 'test'
06:50:34 <lambdabot>   <no location info>:
06:50:34 <lambdabot>      lexical error in string/character literal at chara...
06:50:44 <killown> > ['test']
06:50:45 <lambdabot>   <no location info>:
06:50:46 <lambdabot>      lexical error in string/character literal at chara...
06:51:05 <killown> > 1 + 1
06:51:06 <lambdabot>   2
06:51:37 <benmachine> > "test"
06:51:38 <lambdabot>   "test"
06:53:23 <Axman6> > 't'
06:53:24 <lambdabot>   't'
06:53:35 <IceDane> killown: Strings use double quotes("string") and single character literals use single quotes('c')
06:53:35 <Axman6> > ['t','e','s','t']
06:53:36 <lambdabot>   "test"
06:54:08 <killown> ok
06:54:21 <killown> > ["teste",]
06:54:22 <lambdabot>   <no location info>: parse error on input `]'
06:54:37 <IceDane> > ["test"]
06:54:37 <lambdabot>   ["test"]
06:54:49 <IceDane> > last
06:54:49 <Axman6> > ["test","thing"]
06:54:50 <lambdabot>   ["test","thing"]
06:54:50 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> a)
06:54:50 <lambdabot>    arising from a use of...
06:55:24 <IceDane> Anything that lambdabot uses to refer to the result of the last computation?
06:55:28 <IceDane> > last
06:55:28 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> a)
06:55:28 <lambdabot>    arising from a use of...
06:55:32 <IceDane> ah, wait
06:55:33 <IceDane> :t last
06:55:33 <lambdabot> forall a. [a] -> a
06:55:39 <benmachine> mmhm
06:55:40 <IceDane> ah, that couldn't be it
06:55:49 <benmachine> in ghci you have 'it' but I don't think lb does
06:55:53 <IceDane> nah
06:55:54 <IceDane> tried that before
06:55:58 <IceDane> could be handy
06:55:59 <IceDane> meh
06:56:14 <benmachine> it would require saving state
06:56:18 <benmachine> which would be slightly evil
06:56:19 <IceDane> true
06:56:44 <benmachine> (only because in this case the state might be functions or something exotic)
06:56:56 <IceDane> True enough
06:57:56 <aristid> @src last
06:57:56 <lambdabot> last [x]    = x
06:57:57 <lambdabot> last (_:xs) = last xs
06:57:57 <lambdabot> last []     = undefined
06:59:14 <sipa> there is no way to test for undefinedness?
06:59:32 <IceDane> @src undefined
06:59:32 <lambdabot> undefined =  error "Prelude.undefined"
06:59:33 <Twey> No
06:59:39 <Twey> Well
06:59:41 <Twey> Sort of
06:59:45 <Twey> But that's not the point of undefined
07:00:05 <Twey> You shouldn't be testing for undefined: undefined should only occur when you, the programmer, have made an error in your code
07:00:27 <dschoepe> The HTTP package does not seem to support https or am I mistaken?
07:00:31 <Twey> (you can't test for it, but you can catch it with Control.Exception.catch)
07:00:55 <benmachine> dschoepe: you are correct. until recently, there wasn't a pure implementation of SSL in haskell
07:01:07 <benmachine> dschoepe: (and even the recent one is still fairly, um, wet behind the ears?)
07:01:35 <geheimdienst> didn't somebody these days post something to -cafe about http-enumerator and the tls package ...
07:01:39 <benmachine> yeah
07:01:44 <dschoepe> benmachine: Do you know any workaround? (e.g. bindings to openssl or such)
07:01:44 <IceDane> @hackage ssl
07:01:45 <lambdabot> http://hackage.haskell.org/package/ssl
07:01:52 <IceDane> @hackage https
07:01:52 <lambdabot> http://hackage.haskell.org/package/https
07:01:53 <benmachine> http-enumerator uses the new TLS package
07:02:02 <benmachine> dschoepe: how pedantic are you about your security?
07:02:14 <IceDane> s/pedantic/paranoid/ :P
07:02:22 <benmachine> well either :P
07:02:46 <benmachine> http://hackage.haskell.org/package/http-enumerator this will do HTTPS, I think
07:02:59 <dschoepe> benmachine: in my use case it's fine if I just got an encrypted connection
07:03:15 <benmachine> but using a very new library whose encryption isn't very stress-tested yet, is my impression
07:03:37 <ddarius> benmachine: If the encryption is wrong, won't it break horribly?
07:03:58 <benmachine> ddarius: the encryption *works*, is my impression
07:04:01 <benmachine> but
07:04:02 <IceDane> Wait, it's pure?
07:04:09 <IceDane> So it's not a wrapper around openssl or some such?
07:04:14 <benmachine> IceDane: well, it's not FFI
07:04:19 <IceDane> Ah.
07:04:20 <benmachine> as far as I understand it
07:04:40 <benmachine> ddarius: when I asked about writing a TLS library in haskell some people expressed doubts that it would be easy to avoid e.g. timing attacks
07:04:53 <dschoepe> Isn't that kind of a bad idea to rewrite security-critical code like that?
07:05:02 <IceDane> dschoepe: Kind of
07:05:16 <IceDane> Stuff like OpenSSL is industry strength, stress tested and perr reviewed to crap
07:05:24 <IceDane> (AFAIK)
07:05:42 <benmachine> dschoepe: http://hackage.haskell.org/package/tls *does* havea  disclaimer at the top
07:05:43 <dschoepe> And even openssl had some subtle security flaws now and again.
07:05:48 <IceDane> Yep.
07:06:30 <geheimdienst> dschoepe: i think writing unproven code is good, just don't use unproven code
07:06:58 <arw> a security library in a garbage collected language? isn't that an instant failure right before the first line of code was written?
07:07:05 <quicksilver> I'm not sure "industry strength" means anything, really.
07:07:14 <dschoepe> arw: Why?
07:07:24 <quicksilver> but openssl is very widely used and tested and reviewed
07:07:32 <quicksilver> and it has had many many bugs and security flaws, too :)
07:07:36 <geheimdienst> quicksilver: the term is mosty used to impress babes
07:07:44 <Twey> Haha
07:07:46 <quicksilver> does the fact that so many have been found mean none remain? probably not.
07:07:59 <quicksilver> fewer remain than a brand new piece of code? I expect so.
07:08:03 <arw> dschoepe: because sensitive material will remain in memory for an unknown time?
07:08:28 <quicksilver> arw: that's only an issue for some kinds of security.
07:08:49 <quicksilver> I don't care if you can access the SSL keys of my webserver if you have root access to its memory
07:08:51 <IceDane> arw: So you're implying that OpenSSL overwrites memory it used?
07:08:56 <IceDane> (I'm not saying it's wrong, I'm curious)
07:08:57 <quicksilver> if you have root access to my webserver I'm already fucked.
07:09:07 <quicksilver> IceDane: it will use protected memory facilities of the OS
07:09:21 <arw> IceDane: yes it does. and you usually prevent pages from beeing swapped out and stuff.
07:09:22 <quicksilver> but this is mostly to protect against local attackers
07:09:29 <IceDane> quicksilver: What do you mean? The fact that processes cannot access the memory of other processes?
07:09:32 <quicksilver> yes.
07:09:37 <IceDane> quicksilver: That's obviously not enough
07:09:42 <IceDane> ReadProcessMemory and all that
07:09:53 <IceDane> arw: Ah, that's cool
07:09:56 <IceDane> I hadn't thought about that
07:10:03 <IceDane> But yes, quicksilver has a point either way
07:10:14 <gwern> IceDane: actually, there was a famous debian bug where they patched ssl to not zero out used memory, isn't there?
07:10:26 <bremner> sigh. yes
07:10:34 <IceDane> if you're already accessing the box there's a good chance you can get the keys and so on anyway
07:10:43 <IceDane> gwern: I wouldn't know
07:10:50 <sipa> gwern: i believe it was worse than that
07:11:04 <IceDane> There's also the famous int getRandom() { return 42; } :P
07:11:09 <gwern> sipa: well, there was also a weak-key issue but I don't remember the details
07:11:10 <zygoloid> gwern: iirc they patched ssl to zero out memory which was /supposed/ to be uninitialized
07:11:11 <bremner> gwern: I think it was uninitialized memory, but I'm not 100% sure
07:11:20 <sipa> IceDane: http://xkcd.com/221/
07:11:25 <IceDane> sipa: Hehe, aye.
07:11:29 <zygoloid> gwern: and they added the patch /after/ some entropy had been xor'd in
07:11:37 <sipa> zygoloid: indeed, leaving only 32768 possible generated keys
07:11:39 <zygoloid> gwern: this was to stop valgrind complaining about it
07:11:41 <IceDane> zygoloid: lol.
07:11:43 <IceDane> Oh!
07:11:45 <IceDane> I remember that ug
07:11:46 <IceDane> bug*
07:12:01 <IceDane> They set up a page that allowed you to test if your key was one of the vulnerable ones, IIRC
07:12:03 <gwern> IceDane: see? so you do know
07:12:19 <IceDane> gwern: I just didn't recall it being about zeroing out memory 
07:12:44 <EvanR-work> the debian ssl debacle
07:12:47 <EvanR-work> good times
07:13:03 <sipa> and indeed security libraries typically try to lock memory pages containing critical stuff (like input buffers for unencrypted passwords), to prevent them from being swapped out to disk
07:14:08 <geheimdienst> i think a random-number generator was doing some voodoo by reading uninitialized memory in the hopes of finding entropy there. which doesn't make much sense, but it made the code difficult. then debian changed something to make valgrind happy, and it turned out newly generated keys had really only like 5 bits of randomness. enough to not show up in naive tests, but not enough for security
07:14:28 <sipa> 15
07:14:45 <sipa> from the process id or something like that
07:15:08 <geheimdienst> sipa, right, the process id was involved somehow
07:15:13 <quicksilver> sipa: they do, and that would be impossible in haskell as it stands. (lock pages)
07:15:26 <quicksilver> but it would be a simple patch to GHC to add it, you might even do it via FFI.
07:15:40 <quicksilver> and as I said earlier, locked pages is only protecting against a very special case - local attackers.
07:16:04 <quicksilver> in fact, I think only local *root* attacks; unless your OS has a root-swap-file-access bug.
07:16:09 <IceDane> But then again, even if you do all of this, there's still the cold boot attack, is there not?
07:16:20 <quicksilver> for very many security cases that's not a concern you have.
07:16:28 <zygoloid> geheimdienst: the random number generator was not bothering to initialize a buffer into which it was adding entropy, because there was no point.
07:16:40 <quicksilver> it's pretty hard to write anything remotely secure if you can't trust local root.
07:16:52 <zygoloid> debian zeroing it out would have been pretty much fine, had they put the zeroing out code before any entropy was added to the pool, not after
07:17:01 <arw> quicksilver: nope. local attacker with a boot-cd is sufficient, root is not necessary.
07:17:04 <IceDane> Obviously, it requires physical access, but if you're in a position where you could access the memory of the process you either have remote root access or physical access
07:17:06 <EvanR-work> quicksilver: but wait, trusted computing! ;)
07:17:18 <quicksilver> arw: boot-cd = local root
07:17:22 <zygoloid> arw: physical machine access > local root
07:17:22 <quicksilver> in my opinion.
07:17:33 <arw> zygoloid: sometimes
07:17:50 <arw> quicksilver: if the hdd is not encrypted in some way, yes.
07:17:57 * quicksilver nods.
07:18:10 <quicksilver> and if the hdd *is* encrypted, then the swapfile is OK too (Assuming that's encrypted as well)
07:18:14 <zygoloid> even with an encrypted hdd, if you have physical access to the machine you can attach an ICE to it
07:18:22 <zygoloid> then the memory is not safe
07:18:40 <quicksilver> zygoloid: a what?
07:19:15 <aristid> quicksilver: an ICE
07:19:21 <quicksilver> I can read, yes :)
07:19:25 <quicksilver> I was asking what that was.
07:19:41 <arw> quicksilver: deep freeze the ram chips with a can of cooling spray, then read them out from another computer.
07:19:52 <arw> but i guess thats not that kind of ICE :)
07:19:53 <Twey> Hahahaha
07:19:59 <Twey> I love #haskell
07:20:04 <arw> but has also been shown to work
07:20:13 <benmachine> ICE is not the most googleable thing in the world
07:20:24 <quicksilver> benmachine: yes, that's what I discovered too.
07:20:27 <zygoloid> quicksilver: http://en.wikipedia.org/wiki/In-circuit_emulator
07:20:31 <Twey> You read the channel and people are sensibly considering the security implications of garbage-collection
07:20:33 * quicksilver nods
07:20:40 <quicksilver> zygoloid: agreed, yes.
07:20:51 <quicksilver> zygoloid: although that requires physical access *inside* the case
07:20:57 <Twey> You look away, you come back a minute later, and they're discussing mechanical cryogenics
07:20:58 <quicksilver> whereas a boot-cd is just physical access to the outside.
07:21:19 <quicksilver> still, my opinion is that for secure applications you want to rule out physical access anyway.
07:21:21 <IceDane> arw: I had thought about that as well
07:21:27 <Vanadium> Clearly the solution is to boobytrap your RAM
07:21:35 <IceDane> They got some consistent results with that if I remember correctly
07:22:48 <arw> there is also the evil problem of firewire and pcmcia which both allow dma memory access
07:23:10 <arw> (except in really fancy modern hardware with an IOMMU)
07:23:53 <ksf> DMA is a pita for OSs
07:24:12 <ksf> can't properly enforce memory constraints for drivers, that is
07:24:40 <ksf> ...because the driver knows how to tell a device a dma adress, and the device isn't going to ask the OS whether it actually may write there.
07:25:27 <Maxdamantus> Would (\a b -> if a == 42 then b else b) have a similar effect as seq?
07:25:38 <Maxdamantus> (But limited to integers)
07:26:05 <ksf> I read a paper about a haskell dsl to implement kernels safely not too long ago that went into the details of such stuff
07:26:38 <sipa> Maxdamantus: i'd think so
07:26:44 <ddarius> Vanadium: That is what is done.
07:26:44 <ksf> yep.
07:26:51 <ksf> == on integers is strict
07:27:07 <ksf> ...not on all Nums, at least not necessarily, though.
07:27:18 <benmachine> Maxdamantus: yes, you can implement seq for lots of data types in that sort of way
07:27:32 <ksf> wait sure it needs to be strict in both arguments.
07:27:36 <ddarius> Maxdamantus: Earlier versions of Haskell sort of worked that way.
07:27:40 <sipa> Maxdamantus: i'd write it as (\a b -> case a of { somevalue -> b; _ -> b})
07:27:48 <Saizan> any sensible (==) will be equally or stricter than seq
07:27:49 <benmachine> ksf: inequality doesn't have to be strict
07:27:57 <ksf> yep.
07:28:00 <benmachine> hmm
07:28:02 <benmachine> well
07:28:12 <benmachine> it'd have to be quite exotic to be nonstrict but
07:28:21 <ksf> take peano numerals
07:28:23 <benmachine> (==) :: Float -> Float -> Bool; a == b = False >_>
07:28:30 <benmachine> ksf: they're WHNF-strict though
07:28:37 <ddarius> instance Eq () where _ == _ = True -- sensible or not?
07:28:53 <benmachine> ddarius: I think the laws for Eq only require an equivalence relation?
07:28:58 <Maxdamantus> Mmm.. Interesting.
07:29:02 <ksf> unless, of course, both arguments happen to be infinity.
07:29:11 <benmachine> ksf: of course!
07:29:12 <Saizan> heh, that's arguable, but the one in the Prelude is strict :)
07:29:16 * Maxdamantus tries to avoid sleep deprivation and goes to bed.
07:29:26 <Twey> ddarius: Seems reasonable… but is it useful?
07:29:29 <benmachine> > () == undefined
07:29:31 <lambdabot>   *Exception: Prelude.undefined
07:29:37 <Twey> Ooh, point — strictness counts
07:29:44 <Twey> Hm
07:29:50 <Twey> Is it correct to say that () == undefined?
07:30:00 <benmachine> Twey: depends what you mean by correct
07:30:08 <Twey> :þ
07:30:12 <ksf> depends on whether fast and loose reasoning is morally correct.
07:30:22 <benmachine> Twey: for example, lazy bytestrings that are chunked differently compare equal
07:30:23 <Maxdamantus> > array ((),()) []
07:30:24 <lambdabot>   array ((),()) [((),*Exception: (Array.!): undefined array element
07:30:25 <sipa> Twey: you could argue that even an undefined value of type () represent the (only possible) value ()
07:30:32 <Twey> Right
07:30:56 <Twey> So not actually evaluating the value (and thus throwing the undefined) is a reasonable optimisation
07:31:01 <benmachine> sipa: the semantics of haskell strictly speaking distinguish () and undefined
07:31:15 <benmachine> Twey: except that it's not always an optimisation
07:31:17 <ksf> otherwise you could just drop IO () actions out of monads.
07:31:38 <ksf> er computations.
07:31:46 <sipa> benmachine: true, eg. the difference between an ADT containing undefined and a newtype containing undefined
07:32:17 <benmachine> sipa: right, it's a similar question as to whether undefined :: (a, b) is the same as (undefined, undefined) :: (a, b)
07:32:32 <sipa> indeed
07:32:33 <benmachine> sipa: in haskell they're distinguishable
07:32:38 <benmachine> by pattern-matching
07:38:10 <wjt> @tell ManateeLazyCat It seems that GtkAnchorType has been removed from Gtk+ 3, so I guess there's little point in binding it in gtk2hs
07:38:10 <lambdabot> Consider it noted.
07:39:18 <aristid> there's gtk+ 3? wtf
07:40:12 <wjt> yep
07:41:00 <wjt> coming up for Gnome 3.0!
07:41:43 <aristid> wjt: where can i read about it?
07:42:39 <wjt> good question
07:43:01 <wjt> in theory http://live.gnome.org/GTK%2B/3.0
07:47:19 <aristid> wjt: hmm the only really big thing on that list seems to be resolution independence
07:47:33 <wjt> there's a *lot* of API cleanup
07:48:19 <quicksilver> resolution independence is hard.
07:48:33 <gwern> resolution independence seems very big to me. important for small and large devices
07:48:36 <quicksilver> OSX had the framework for resolution independence in place many years ago
07:48:47 <quicksilver> but they've never had the guts to "turn it on"
07:48:50 <quicksilver> because it breaks too much
07:48:57 <quicksilver> lazy app developers, I suppose
07:49:08 <roconnor> > (3^15 + 1)*(5^12 + 1 
07:49:09 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:49:11 <roconnor> > (3^15 + 1)*(5^12 + 1)
07:49:12 <lambdabot>   3503151381536408
07:49:16 <wjt> i think ‘lazy’ is too harsh :)
07:49:28 <roconnor> > maxBound :: Int32
07:49:30 <lambdabot>   2147483647
07:49:31 <quicksilver> wjt: probably, yes. If it's untestable how can they test it.
07:49:50 <wjt> Everyone's short of time, so why would adding support for an untestable feature be prioritized over anything else?
07:49:53 <wjt> right :)
07:49:59 <quicksilver> if no consumers use it, then even if it *is* testable with some develoepr tool why should they bother?
07:50:03 <quicksilver> right.
07:50:11 <TylerE> It's 2010....I just want my 200dpi desktop display
07:50:22 <quicksilver> TylerE: it's in the boot of your flying car
07:50:38 <quicksilver> which is next to the pony, on the moon-on-a-stick.
07:50:46 <TylerE> Sadly, yes...
07:50:54 <flux> and it's running duke nukem forever
07:50:55 <quicksilver> http://www.chiark.greenend.org.uk/~sgtatham/putty/wishlist/moon-on-stick.html
07:50:57 <wjt> Apple did some crazy stuff to make existing apps work on iPhone 4 with four times as many pixels... redefining the meaning of various units, misc.
07:50:58 <flux> no, wai..
07:51:06 <TylerE> Funny thing is I'm holding one in my hand (well....170dpi or so), it's just a 4" display, not a 20...
07:51:27 <wjt> ... misc. other hacks, magic functions to call to say that you're a grown up and can handle the differences
07:58:20 <quicksilver> wjt: misc hacks and magic functions.
07:58:26 <quicksilver> wjt: that's how everything works, really :)
07:58:40 * quicksilver points to the hideous mess which is CSS on small screen devices.
07:59:33 <roconnor> > (2^(2^(2^0) + 2^0) + 2^(2^0) + 2^0) 
07:59:34 <lambdabot>   11
08:00:41 <roconnor> > (2^(2^(2^0) + 2^0) + 2^(2^(2^0)) + 2^0) 
08:00:42 <lambdabot>   13
08:00:48 <roconnor> > (2^(2^(2^0) + 2^0) + 2^(2^(2^0))) 
08:00:48 <sipa> > exp pi - pi
08:00:49 <lambdabot>   12
08:00:49 <lambdabot>   19.999099979189474
08:09:04 <IceDane> hmm. Why is there no when-ish function: Bool -> m a -> m a?
08:09:09 <IceDane> Am I missing something here?
08:09:14 <ddarius> :t when
08:09:14 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:09:24 <pumpkin> IceDane: what would it do if False?
08:09:27 <roconnor> IceDane: what does false do?
08:09:38 <roconnor> IceDane: you may be thinking of guard
08:09:38 <IceDane> ah, of course
08:09:41 <roconnor> @type guard
08:09:42 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:09:47 <roconnor> er
08:09:49 <roconnor> or not
08:09:49 <pumpkin> you could do Bool -> m a -> m (Maybe a)
08:09:54 <pumpkin> but meh
08:09:57 <quicksilver> :t \v p act -> if p then act else return v
08:09:58 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> Bool -> m a -> m a
08:10:08 <quicksilver> or you can supply a default a, as above
08:11:23 <ddarius> Combining pumpkin's and quicksilver's solutions produces the nicely readable: \p act -> if p then Just <$> act else return Nothing
08:12:36 <IceDane> Hmm. The problem is that I'm executing code that would only fail in exceptional cases
08:12:44 <IceDane> So when it fails, I'm 'error'ing out
08:12:58 <IceDane> Thanks, I'll do something nifty
08:13:49 <roconnor> IceDane: you can do if b then whatever else fail "I suck"
08:13:55 <quicksilver> IceDane: never use error for an exceptional case
08:14:06 <quicksilver> that's not what error is for.
08:14:11 <IceDane> quicksilver: oh?
08:14:13 <quicksilver> error is for an *impossible* case
08:14:22 <quicksilver> that is, something which indicates you, the programmer, have made a mistake.
08:14:29 <IceDane> aaah.
08:14:32 <IceDane> I see what you mean
08:14:40 <quicksilver> for an exceptional case you should use something more regimented
08:14:40 <IceDane> thus error in head [] and so on.
08:14:46 <IceDane> Yeah, this was a bit dirty
08:14:47 <quicksilver> either fully-fledged IO exceptions
08:14:48 <aristid> :t let (??) a b x = if x then a else b in Just ?? const Nothing
08:14:49 <lambdabot> forall a. Bool -> a -> Maybe a
08:14:54 <quicksilver> or Either/Maybe etc.
08:14:56 <IceDane> I'll go Maybe
08:15:03 <IceDane> Thanks, didn't think of that
08:15:03 <aristid> :t let (??) a b x = if x then a else b in liftM . (Just ?? const Nothing)
08:15:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => Bool -> m a -> m (Maybe a)
08:15:22 <roconnor> IceDane: you are on the edge of using MaybeT fwtw.
08:16:03 <IceDane> roconnor: Mm? My by far worst 'haskell skill' is recognizing these patterns
08:16:26 <roconnor> @src MaybeT
08:16:26 <lambdabot> Source not found. The more you drive -- the dumber you get.
08:16:30 <roconnor> anyhow
08:16:31 <IceDane> Can't see how MaybeT would help me here
08:16:54 <roconnor> MaybeT m a is isomorphic to m (Maybe a), which is the result type of what you are discussing
08:17:04 <IceDane> Aah.. 
08:17:05 <IceDane> hm.
08:17:30 <roconnor> and when using MaybeT your new bind operation will automatically chain together your failures.
08:17:44 <roconnor> just like how the Maybe monad chains together your failures
08:17:53 <ddarius> :t \act -> (>> act) . guard 
08:17:54 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => m b -> Bool -> m b
08:18:16 <roconnor> whether or not it is worth using MaybeT maybe depends on what you are doing exactly
08:18:26 <roconnor> it might be better to stick with m (Maybe a)
08:19:03 * hackagebot xilinx-lava 5.0.1.4 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.1.4 (SatnamSingh)
08:19:38 <roconnor> but if yoy find yourself doing a lot of fmaps over your Maybe a values, you might want to use maybeT
08:19:58 <roconnor> if you find yourself doing a lot of >>= over your Maybe a values inside m, you definitely want to use MaybeT :)
08:21:06 <ddarius> No fmaps, no (>>=)s, just case of case of case.
08:21:46 <ddarius> Not having first-class "functions" is starting to bite a little in my language.
08:22:01 <roconnor> cc
08:22:03 <roconnor> DD
08:22:04 <roconnor> UGH
08:22:18 <roconnor> ddarius: I thought we were talking about IceDane's problem?
08:22:44 <ddarius> We were.
08:23:03 <ddarius> I am also talking about things that are not IceDane's problem.
08:24:29 <ddarius> I think I cheated my way out of my problem.
08:25:14 <aristid> ddarius: you have a language without first-class functions? why?
08:27:00 <ddarius> aristid: Because there is no memory allocation at all, let alone garbage collection.  Also, I have second-class functions which work for allowing me to define my own control structures.  Finally, the notion of scope is rather different.
08:27:53 <aristid> ddarius: a language without memory allocation? that sounds exotic
08:29:05 <Cale> Nuclear warheads don't need to remember anything ;)
08:29:53 <Cale> (just kidding of course :)
08:30:03 <ddarius> They do need to remember stuff?
08:30:19 <zygoloid> well, where they're going, maybe?
08:30:26 <Nibble> zygoloid: nah
08:30:32 <Nibble> not the warheads
08:30:40 <Cale> ddarius: Well, about what it is that your language is intended for.
08:31:46 <geheimdienst> well suppose you have everything on the stack. suppose every tiny bit of memory needed is known at compile time ...
08:32:00 <geheimdienst> i think that's at least plausible
08:32:40 <ddarius> geheimdienst: Of course that's plausible, what constraints do you think chip designers operate under?
08:33:09 <Cale> Hmm, this guy seems to be arguing that lexical closures are an invisible syntactic construct. I still disagree with him about terminology, but that's something I haven't heard before.
08:34:43 <zygoloid> what's the syntax of an invisible syntactic construct? what does that even mean?
08:35:03 <bremner> like in brainfuck, duh.
08:35:09 <ddarius> [ ] Can you write curry and uncurry, and do they form an isomorphism?\n If all boxes are checked, then you have first class functions.
08:35:11 <bremner> s;cnr
08:35:13 <Cale> I don't really see why we need such a distinction, when we can just say that function definitions have the lexical capture property, and do away with it.
08:36:04 <Cale> He seems to want to introduce closures as a "thing" at the syntax level, and be able to say that some function definition is a closure because it captures values of variables from its environment.
08:36:24 <cpressey> presumably if the syntax was made un-invisible, you could specify it, or not; how would the semantics change between those two cases?
08:36:48 <cpressey> s/un-invisible/visible/, I suppose :)
08:37:01 <Cale> cpressey: Good question
08:37:02 <geheimdienst> cale, so \x -> x + y would be a closure, but \x y -> x + y wouldn't
08:37:15 <Cale> geheimdienst: Yeah, I don't know, perhaps.
08:37:31 <wakeupsticky> Hi, all. I'm a bit confused about part of the instructions for installing wxHaskell on windows.
08:37:46 <Cale> wakeupsticky: ask away
08:38:03 <wakeupsticky> I installed mingw and msw, and now I'm supposed to run:
08:38:07 <wakeupsticky> cd /c/path/to/wxWidgets-2.8.10/build/msw > mingw32-make -f makefile.gcc BUILD=release MONOLITHIC=1 SHARED=1 UNICODE=1
08:38:32 <Cale> okay
08:38:33 <wakeupsticky> I'm told that I should have the C++ compiler option installed for mingw as it is not the default
08:38:39 <wakeupsticky> Now how do I do that?
08:38:44 <Cale> (Looks like fun...)
08:38:58 <Cale> Does mingw come with a terminal program?
08:39:13 <dstcruz> how would I go about getting some HackageDB stats? Like, new or upgraded packages in a given time range?
08:39:17 <ddarius> There's MSYS which is atrocious.
08:39:20 <wakeupsticky> I barely know what mingw is other than I need it for wxHaskell.
08:39:27 <zygoloid> Cale: well, the c++ lambdas have closureness as a syntactic thing (you have various options as to how it should be broken)
08:39:36 <wakeupsticky> I got msys.
08:39:38 <cpressey> presumably you'd use cygwin as mingw's "teminal program"?
08:39:53 <ddarius> cpressey: That would kind of defeat the point.
08:40:04 <ddarius> Anyway, MinGW has its own page with documentation.
08:40:39 <Cale> wakeupsticky: I'm un(?)fortunately not a windows user, so I'm not sure exactly how it goes...
08:41:20 <wakeupsticky> i've opened "MINGW32:" in the command propt.
08:41:21 <wakeupsticky> prompt
08:43:21 <wakeupsticky> nevermind, looks like i need to reinstall mingw and select a different option while installing
08:50:11 <wakeupsticky> All right, I'm in the msys shell and I'm supposed to run: mingw32-make -f makefile.gcc BUILD=release MONOLITHIC=1 SHARED=1 UNICODE=1
08:50:31 <wakeupsticky> sh: mingw32-make: command not found
08:53:32 <fryguybob> I was wondering if someone could look at my code: http://hpaste.org/40436/nim_normal  It works but it seems more verbose than I would expect.
08:55:44 <wakeupsticky> ah, i added the msys folder to my path but i need to add the mingw bin folder...
08:59:31 <fryguybob> I'm mostly unhappy with lines 30-39.
09:00:44 <t3eblinder> fryguybob: when it works... sometimes it's better to be more verbose than to cryptic
09:01:00 <bss03-AFK> fryguybob: That's close to how I'd write lines 30-32.
09:02:18 <bss03> fryguybob: 34-39 looks fine too.
09:02:19 <fryguybob> I suppose verbose isn't the word I'm looking for.  I feel like there is something higher order that would be a good fit, but I don't know what.
09:02:42 <fryguybob> bss03: Ok maybe I'll just decide to be happy :D.
09:02:56 <sipa> sounds like a wonderful decision
09:03:05 <sipa> tell me if you learn how :p
09:04:14 <fryguybob> sipa: Well the sun is out today, so it isn't *too* hard to be happy :D
09:08:42 <ddarius> South Americans really like their coroutines.
09:10:48 <kdvh> is there some problem with installing wxcore through cabal or is it just me?
09:11:23 <benmachine> fryguybob: maybe you want splitAt?
09:11:30 <dcoutts> kdvh: I'm not sure if it's still true but it used to work better when installed globally, rather than per-user
09:11:31 <benmachine> > splitAt 3 [1,2,3,4,5]
09:11:32 <lambdabot>   ([1,2,3],[4,5])
09:11:43 <benmachine> good for modifying an element at a position
09:11:56 <fryguybob> benmachine: Ah ok.
09:12:04 <kdvh> dcoutts: I've tried using --global, no luck
09:12:11 <benmachine> :t uncurry (&&&) . splitAt ?n
09:12:13 <lambdabot>     Couldn't match expected type `a b c' against inferred type `[a1]'
09:12:13 <lambdabot>       Expected type: [a1] -> (a b c, a b c')
09:12:13 <lambdabot>       Inferred type: [a1] -> ([a1], [a1])
09:12:17 <benmachine> errr
09:12:23 <benmachine> :t uncurry (++) . splitAt ?n
09:12:24 <lambdabot> forall a. (?n::Int) => [a] -> [a]
09:12:24 <dcoutts> kdvh: of course you need to be running as root to use --global
09:12:25 * benmachine silly
09:12:36 <dcoutts> kdvh: and you need the wx C libs installed of course
09:13:00 <kdvh> dcoutts: yep, ive tried as root and using sudo
09:13:34 <dcoutts> kdvh: you might be able to get someone here to help if you post more details, like a build log
09:13:41 * dcoutts is a tad busy sadly
09:14:26 <benmachine> I thought you'd want to set root-cmd rather than run as root?
09:14:50 <kdvh> dcoutts: alright, ill do it later when i get home
09:15:07 <quicksilver> kdvh: wxcore-0.12.1.4 and wx-0.12.1.4 installed cleanly from me using cabal
09:15:24 <quicksilver> looks like I installed them --global
09:15:27 <dcoutts> benmachine: either work, matter of convenience and whether the build or just install run as root
09:15:46 <quicksilver> builds should never really need to run as root IMO
09:16:04 <benmachine> especially in the presence of TH's runIO :P
09:16:12 <benmachine> dcoutts: I thought the idea of root-cmd was that if you just sudid it you'd get root-owned files in your ~/.cabal?
09:17:26 <dcoutts> benmachine: you certainly would if you did a --user install, with sudo and --global you could get root owned downloaded tarballs I suppose.
09:17:41 <dcoutts> since sudo doesn't change $HOME
09:17:47 <benmachine> yeah, I think I had something like that
09:18:37 <fryguybob> > let draw i n = uncurry (++) . second (\(a:as) -> (a-n):as) . splitAt i in draw 1 2 [1,2,3]
09:18:38 <lambdabot>   [1,0,3]
09:18:51 <fryguybob> I'm not sure that's better but good to know.
09:20:04 <benmachine> fryguybob: I'd use a case statement instead of uncurry (++) in more complicated code, this gives me better error-handling potential too
09:20:28 <fryguybob> benmachine: Yeah
09:20:51 <benmachine> fryguybob: in general, lists are bad random-access structures, though
09:21:08 <benmachine> in terms of API as well as efficiency
09:21:22 <benmachine> you might find Data.Sequence relevant to your interests
09:22:02 <fryguybob> benmachine: Right, I'm attempting to get this code in a form that would be easy enough to explain to someone not familiar with Haskell.
09:22:17 <benmachine> mm, that's fair enough
09:22:19 <ddarius> The API is purposely designed to be bad at random access usage patterns.
09:22:48 <benmachine> ddarius: that makes it sound like an act of sabotage
09:23:01 <benmachine> and anyway (!!) exists
09:23:24 <ddarius> benmachine: It'd be didn't, but a[i] = x doesn't exist.
09:23:33 <ddarius> +nice
09:23:55 <ddarius> Cripes.  "It'd be nice if it didn't"
09:24:03 <fryguybob> Is there a way to write "LessThan" with type level naturals?
09:24:47 <benmachine> ddarius: true (and agreed, I guess)
09:24:47 <ddarius> The type level is, with -fundecidable-instances, Turing-complete.
09:25:02 <benmachine> -XUndecidableInstances :P
09:25:10 * ddarius is old.
09:25:11 <fryguybob> ddarius: ok
09:27:38 <kmc> you mean -fglasgow-exts
09:27:44 <kmc> that's what the pros use
09:32:39 <benmachine> -XAllOfThem
09:32:53 <benmachine> (should, but doesn't, exist)
09:32:58 <ddarius> kmc: -fglasgow-exts doesn't turn on undecideable instances.
09:33:31 <monochrom> -XAllThoseWhoDontTurnOnThemselves
09:34:18 <monochrom> haha
09:36:36 <kmc> we put the fun in -fundecidable
09:37:31 <monochrom> @remember kmc we put the fun in -fundecidable
09:37:31 <lambdabot> Done.
09:38:23 <Apocalisp> @hoogle (a -> b -> m c) -> f a -> f b -> m f c
09:38:24 <lambdabot> No results found
09:39:09 <copumpkin> m (f c)? 
09:39:16 <Apocalisp> @hoogle (a -> b -> m c) -> f a -> f b -> m (f c)
09:39:16 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
09:39:16 <lambdabot> Data.IntMap differenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
09:39:16 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
09:39:31 <copumpkin> Apocalisp: you'd need a traversable constraint on it
09:39:31 <Apocalisp> thanks Dan!
09:39:44 <Apocalisp> Yeah, it's like mapM2
09:39:56 <Apocalisp> @type mapM
09:39:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
09:39:59 <Apocalisp> @type mapM2
09:40:00 <lambdabot> Not in scope: `mapM2'
09:40:03 <Apocalisp> boo
09:40:13 <copumpkin> :t \f x y -> Data.Traversable.sequenceA (liftA2 f x y)
09:40:14 <lambdabot> forall a b (f :: * -> *) a1 (t :: * -> *). (Applicative t, Data.Traversable.Traversable t, Applicative f) => (a -> b -> f a1) -> t a -> t b -> f (t a1)
09:40:29 <Apocalisp> oh win
09:40:44 <copumpkin> :D
09:52:08 <pr> why does: last [1%10, 3%10 .. 1] yield 11%10?
09:52:49 <copumpkin> cause enum{From}{Then}{To} sucks
09:52:59 <copumpkin> in fact, the entire Enum class does
09:53:21 <geheimdienst> what syntax is that? enum{From}{Then..
09:53:36 <copumpkin> just me trying to avoid writing out all the combinations
09:53:42 <copumpkin> in a rather informal manner
09:53:43 <geheimdienst> i see :)
09:53:44 <monochrom> meta syntax
09:53:53 <monochrom> it is formal
09:54:18 <geheimdienst> [co]pumpkin[_]
09:54:18 <pr> well, i figured it was because data.ratio probably uses floating point arithmetic underneath (which would surprise me but nevertheless)
09:54:31 <copumpkin> [co[ntra]]pumpkin[_]
09:54:31 <monochrom> there is a misconception that metalanguages are informal and vice versa.
09:54:33 <ddarius> pr: It does'nt.
09:54:50 <pr> yeah, but that was the only explanation i could think of :)
09:54:51 <copumpkin> pr: no, it's just cause Enum sucks
09:54:52 <ddarius> copumpkin: You forgot copumki-
09:54:56 <ddarius> Er +p
09:54:58 <pr> copumpkin: alright, thanks
09:55:14 <copumpkin> ddarius: I murdered him, and am trying to forget the big black trash bag sitting out in the yard right now
09:55:16 <zygoloid> enumFrom(Then)?(To)?
09:55:31 <ddarius> pr: It's just the way enumFromThenTo is defined in the Report.
09:55:44 <ddarius> copumpkin: Good.
09:55:48 <benmachine> can't they just special-case unreliable types?
09:55:55 <benmachine> define it that way for Float and Double
09:56:04 <copumpkin> benmachine: Rational is unreliable?
09:56:22 <benmachine> copumpkin: no it isn't, that's why special-casing is necessary :P
09:56:25 <copumpkin> > [1%10, 3%10 .. 1]
09:56:26 <lambdabot>   [1 % 10,3 % 10,1 % 2,7 % 10,9 % 10,11 % 10]
09:56:31 <zygoloid> pr: looks like a bug in the report, afaict
09:56:42 <zygoloid> > [1/10, 3/10 .. 1]
09:56:43 <lambdabot>   [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
09:56:50 <zygoloid> ... huh
09:56:52 <copumpkin> yeah
09:57:12 <zygoloid> that's... an interesting choice.
09:57:15 <copumpkin> I went through a lot of grief emulating that horrible in uvector so that it would be an easier conversion from lists
09:57:19 <copumpkin> not sure if Vector does the same
09:57:20 <geheimdienst> Rational went out last night, said she was gonna be back by 11, then showed up at half past one in a not exactly sober state. the guy who drove her here had 6 earrings and a nose piercing
09:57:38 <geheimdienst> Rational is in a phase where she is pretty unreliable
09:58:53 <zygoloid> geheimdienst: according to a recent report, Rational is behaving in a manner which is typical for those of her kind
09:59:22 <copumpkin> seems like they should try to fix that in a future haskell'
09:59:36 <sproingie> Rambunctious Rational 
09:59:43 <sproingie> my favorite member of the wu tang clan
10:01:10 <ddarius> 4,179 papers (re)indexed and counting.
10:01:59 <geheimdienst> i'd like haskell' to state that floats and doubles are rambunctious and should be avoided
10:02:03 <geheimdienst> that would be awesome
10:02:19 <ddarius> Haskell' is dead.  Long live Haskell'.
10:11:07 <kmc> Rambunctious Rational sounds like an Ubuntu release
10:11:49 <geheimdienst> Rambunctious Rolcat
10:19:00 <ray> oh there was some truth to that story?
10:19:13 <ray> i heard "segway inventor dead", checked on dean kamen, and he was alive
10:23:14 <McManiaC> can you "lift" the (&&&) arrow to return (a,b,c) in a statement like "a &&& b &&& c" instead of "(a,(b,c))"?
10:23:31 <kmc> not easily
10:23:39 <kmc> tuples bigger than 2 are not loved in Haskell
10:24:18 <ray> yeah the problem is that there's no generic tuple type constructor
10:24:37 <ray> so you can't really generalize over n-tuples
10:24:37 <benmachine> I reckon (a,b,c) should be sugar for (a,(b,c))
10:24:38 <kmc> nor should there be, as i can see
10:24:45 <benmachine> but that's debatable
10:24:49 <geheimdienst> :t (,)
10:24:50 <lambdabot> forall a b. a -> b -> (a, b)
10:24:59 <ray> :t (,,)
10:25:00 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
10:25:01 <benmachine> it would add extra bottoms :o
10:25:12 <McManiaC> kk
10:25:15 <kmc> perhaps you can use http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Curry.html McManiaC
10:25:30 <kmc> but the simple / clear thing would be to define your own function
10:25:32 <ddarius> @google the zip calculus
10:25:34 <lambdabot> http://www.springerlink.com/index/4k66738119u02119.pdf
10:25:34 <lambdabot> Title: SpringerLink - Abstract
10:25:43 <kmc> @djinn c f g h (x,y,z) = (f x, g y, h z)
10:25:44 <lambdabot> Cannot parse command
10:25:48 <kmc> err
10:25:51 * kmc dum
10:25:57 <kmc> @type let c f g h (x,y,z) = (f x, g y, h z) in c
10:25:58 <lambdabot> forall t t1 t2 t3 t4 t5. (t -> t1) -> (t2 -> t3) -> (t4 -> t5) -> (t, t2, t4) -> (t1, t3, t5)
10:26:17 <kmc> oh but that's not what you wanted either
10:26:36 <ray> i'd do flatten $ a &&& b &&& c where flatten (a,(b,c)) = (a,b,c) or something
10:27:02 <benmachine> do you really need a 3-tuple? maybe you can use a nested tuple anyway
10:27:26 <benmachine> :t uncurry . fmap uncurry
10:27:28 <lambdabot> forall a a1 b c. (a -> a1 -> b -> c) -> (a, (a1, b)) -> c
10:27:53 <ddarius> :t uncurry . uncurry
10:27:54 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
10:30:02 <RyanT5000> so, is there any way to achieve something like a first-class typeclass?
10:30:44 <fasta> RyanT5000, you can pass around records containing functions. 
10:31:00 <RyanT5000> fasta: that doesn't sound very fun at all :P
10:31:11 <RyanT5000> here's an example: suppose i wanted to write a typeclass like Monad, except that every return-value used in the monad implemented a particular typeclass
10:31:23 <RyanT5000> i know how to write that for a *particular typeclass*
10:31:34 <RyanT5000> e.g.: i could write "Monad" with a "Typeable" constraint
10:32:07 <copumpkin> RyanT5000: http://github.com/dorchard/constraintTermExtensions
10:32:25 <copumpkin> RyanT5000: for your particular example, check out rmonad on hackage though
10:32:48 <RyanT5000> copumpkin: ah, very cool
10:32:50 <RyanT5000> thanks
10:33:18 <Cale> (Unfortunately, GHC doesn't quite have this yet)
10:33:26 <RyanT5000> Cale: yeah, i was afraid of that :P
10:34:21 <Cale> There's the trick which is used by RMonad
10:34:45 <fasta> RyanT5000, so, you want to enforce that property that you talked about in the type?
10:35:00 <RyanT5000> fasta: right
10:35:03 <fasta> RyanT5000, because otherwise it should already work, no?
10:35:19 <RyanT5000> fasta: well, suppose you wanted a monad whose return values were guaranteed to be instances of Show
10:35:22 <copumpkin> the preprocessor lets you do that in general
10:35:22 <Cale> http://hackage.haskell.org/packages/archive/rmonad/0.6/doc/html/Control-RMonad.html
10:36:05 <copumpkin> check out for example: http://github.com/dorchard/constraintTermExtensions/blob/master/example2.hs
10:36:56 <fasta> RyanT5000, do you think it has actual real-world value to try to encode those things in Haskell? 
10:37:01 <Cale> copumpkin: Does that example work without the explicit types for fmap?
10:37:08 <copumpkin> Cale: I don't think so, sadly :/
10:37:28 <jaspervdj> gwern: ping
10:37:37 <jaspervdj> gwern: I think the tail bug has been fixed
10:37:42 <gwern> coolios
10:37:57 <gwern> might as well say it on the record though
10:38:20 <jaspervdj> (afk, ghentfpg meeting)
10:41:39 <RyanT5000> fasta: yeah - the real world value is that it would let me do various things with Arrows that i'm not able to do now
10:42:33 <RyanT5000> fasta: i'm not certain that first-class constraints are the only way to achieve it, but it's the only way i've been able to think of so far
10:43:32 <fasta> RyanT5000, I don't know the exact problem you are solving, but I usually just solve the problem and then if it happens to coincide with certain existing things, it might be nice, but in my experience that almost never happens. 
10:45:00 <copumpkin> instance Arrow Map
10:45:22 <RyanT5000> yeah, that would be nice :)
10:46:14 <ddarius> You'd need to "decorate" Map a bit.
10:46:36 <copumpkin> I'd probably make the underlying function a -> Maybe b
10:49:34 <ddarius> data MapA k v = JustAFunction (k -> v) | forall k' v'. AlsoAMap (k -> k') (Map k' v') (v' -> v)
10:53:37 <copumpkin> makes sense
10:56:12 <roconnor> > logBase 2 3503151381536408 :: CReal
10:56:13 <lambdabot>   51.6375747559188642032407917342665882025869
10:56:44 <roconnor> > logBase 2 51 :: CReal
10:56:44 <lambdabot>   5.6724253419714955897078049547582208627711
10:57:04 <roconnor> > showHex 51 ""
10:57:05 <lambdabot>   "33"
10:58:22 <benmachine> supposing constraint aliases were supported, would we actually want them everywhere?
10:58:38 <benmachine> doesn't that mean we learn less about particular structures?
10:58:46 <roconnor> > logBase 10 51 :: CReal
10:58:48 <lambdabot>   1.7075701760979363658351977975834523392077
10:58:53 <roconnor> > logBase 10 3503151381536408 :: CReal
10:58:54 <lambdabot>   15.5444589048727605158810534508563369621775
11:02:47 <fasta> benmachine, it would require everyone to read yet another paper.
11:03:02 <benmachine> fasta: you can never have too many papers
11:03:26 <fasta> benmachine, yes, at least it is documented to some degree.
11:03:39 <benmachine> rather too much paper than too litte.
11:03:40 <benmachine> +l
11:03:49 <fasta> benmachine, e.g. fundeps have been a mess because the original paper was not useful to implement it.
11:04:03 <fasta> benmachine, or rather, a large step.
11:04:17 <fasta> It's the same with most of the other GHC extensions.
11:04:44 <copumpkin> benmachine: it gives you more granularity in abstraction, which I don't tink is bad
11:04:50 <McManiaC> @pl \(a,_) (b,_) -> a == b
11:04:50 <lambdabot> (`ap` snd) . (. fst) . (const .) . (==) . fst
11:04:55 <McManiaC> uuuuuh
11:05:00 <copumpkin> benmachine: it allows you to recognize that more things are "the same kind of thing"
11:05:21 <benmachine> copumpkin: mm, true, but if everything is that kind of thing then you don't learn anything at all :P
11:05:47 * benmachine considers constraint instance Foo a = (a ~ Void) or something
11:07:34 <copumpkin> instance Functor Data.Vector.Unboxed where constraint Dom Data.Vector.Unboxed a = (a ~ Int); constraint Cod Data.Vector.Unboxed b = Unbox b
11:07:36 * copumpkin shrugs
11:07:56 <copumpkin> constraining it to void doesn't make everything a functor, it just doesn't do anything useful
11:08:03 <benmachine> yes :P
11:08:11 <copumpkin> I can already make useless functor instances
11:08:20 <benmachine> this is true
11:08:43 <zygoloid> why 'constraint' rather than 'class'?
11:08:47 <copumpkin> beats me
11:08:52 <copumpkin> class was harder to parse?
11:08:53 <zygoloid> i rather like taking this proposal as well as type class aliases
11:09:16 <copumpkin> since having a "class" as a top-level declaration puts you into typeclass-parsing mode? :P
11:09:20 <copumpkin> that's all I can think of
11:09:31 <benmachine> didn't stop type families :)
11:09:36 <copumpkin> yeah
11:09:40 <zygoloid> so you can say instance Foo Bar where class Baz a = (Thing a, Thing2 [a])
11:09:46 <copumpkin> that'd be nice
11:10:35 <zygoloid> in fact, this constraint synonym thing seems to basically be just a subset of typeclass aliases, plus associated classes
11:10:50 <copumpkin> a subset?
11:11:00 <copumpkin> it's exactly that isn't it?
11:11:07 <copumpkin> just that nobody's agreed on naming
11:11:27 <zygoloid> no, it doesn't support instances nor fancy defaults
11:11:28 <benmachine> one of the class alias proposals was glued to superclass defaults
11:11:33 <copumpkin> there's a big article on what people want on the ghc wiki and a blog post on it on max bolingbroke's site
11:11:50 <copumpkin> they all use different names :P
11:12:03 <zygoloid> the name /has/ to be class, or Num will not be a class any more ;)
11:12:24 <copumpkin> hm, I don't follow :P
11:12:29 <benmachine> hands up who is devastated by Num losing its classiness
11:13:04 <zygoloid> if a class is supposed to be a set of types (or more generally an n-ary type relation), i don't see any semantic way in which these things are /not/ classes
11:13:33 <copumpkin> zygoloid: yeah, but you can easily view them as constraints too, which fits the relation view too
11:13:36 * copumpkin shrugs
11:13:50 <copumpkin> I don't see why one is fundamentally more correct than the other
11:14:06 <zygoloid> if we see them as constraints, how can it make sense to define instances of them?
11:14:33 <benmachine> you want instances!
11:14:37 <zygoloid> we lose the backwards-compatibility part of the class alias proposal, which is part of what made it great
11:14:42 <benmachine> mm
11:14:49 <benmachine> this is rue
11:14:51 <benmachine> +t
11:15:01 * copumpkin shrugs
11:15:11 <copumpkin> I don't think constraint suggests you can't make something new satisfy it
11:15:17 <zygoloid> benmachine: i want to be able to write: instance MonadAndAllTheTrimmings where return = Thing; (>>=) = otherThing, and get Functor, Applicative, Pointed, Monad, ... instances
11:15:19 <copumpkin> or even something old satisfy it
11:15:35 <zygoloid> copumpkin: constraint Foo a = (Num a, Num [a])
11:15:37 <copumpkin> but either way, I don't really give a flying **** :)
11:15:46 <benmachine> copumpkin: ok but that is kind of just reinventing terminology
11:15:49 <zygoloid> ^^ you can't give an instance for that in the normal way
11:16:11 <copumpkin> zygoloid: so a class alias would disallow that?
11:17:16 <zygoloid> copumpkin: yes, i think that restriction in John Meacham's proposal (at most one occurance of each class)
11:17:23 <copumpkin> ah, okay
11:17:33 <copumpkin> cool :)
11:29:32 <wakeupsticky> dear lord, this...whatever it is....that i need for wxhaskell is taking forever to build...over an hour now
11:30:37 <wakeupsticky> "mingw32-make -f makefile.gcc BUILD=release MONOLITHIC=1 SHARED=1 UNICODE=1" <--- should this take a loooooooong time?
11:31:19 <kmc> is it saying stuff
11:31:24 <wakeupsticky> yes
11:31:35 <wakeupsticky> waterfall of text that spits out a new line every 5-10 seconds
11:31:38 <kmc> yeah
11:31:40 <kmc> it's compiling
11:31:43 <kmc> that can take a while
11:31:52 <wakeupsticky> like hours?
11:32:32 <zygoloid> wakeupsticky: depends what it's compiling
11:32:51 <wakeupsticky> mingw32-make -f makefile.gcc BUILD=release MONOLITHIC=1 SHARED=1 UNICODE=1
11:32:53 <wakeupsticky> that's what it's doing
11:33:17 <zygoloid> wakeupsticky: that tells us basically nothing.
11:33:29 <copumpkin> MONOLITHIC :O
11:33:36 <zygoloid> (as it happens, my magic 8-ball deduces from this that it's compiling WxWindows)
11:33:38 <wakeupsticky> i'm following the wxhaskell building instructions
11:33:47 * MONOLITHIC = 1
11:34:10 <wakeupsticky> Using the MSYS shell, and making sure that you have the C++ compiler option installed for MinGW as it is 'not' the default:  > cd /c/path/to/wxWidgets-2.8.10/build/msw > mingw32-make -f makefile.gcc BUILD=release MONOLITHIC=1 SHARED=1 UNICODE=1
11:34:10 <zygoloid> wakeupsticky: it's probably normal
11:34:51 <copumpkin> wakeupsticky: the next line
11:34:55 <copumpkin> on that page you're citing
11:34:59 <copumpkin> says "this will take quite some time"
11:35:07 <wakeupsticky> i know
11:35:15 <wakeupsticky> it's been about two hours now
11:35:19 <kmc> wakeupsticky, i'm not surprised that compiling all of wx takes over an hour, if that's what you're doing
11:35:36 <wakeupsticky> just making sure it's normal
11:35:39 <kmc> it's a big program and compiling C++ is slow
11:35:42 <fasta> wakeupsticky, what you do is probably also wrong. 
11:35:54 <wakeupsticky> what?
11:35:56 <fasta> wakeupsticky, X=1 command and command X=1 are different things.
11:36:16 <wakeupsticky> i copied and pasted the command from the installation guide.
11:37:05 <wakeupsticky> just feel like it's going to go for another two hours and then spit out an error message >_>
11:37:26 <copumpkin> the nice thing about build systems is that you won't usually have to recompile everything if it breaks
11:37:40 <ddarius> Many errors are discovered during the linking stage which is the last step.
11:38:11 <ddarius> Of course, some errors are only discovered during the running stage which is after the last step.
11:42:44 <freedrull> can i use lookAhead in Data.Binary.Get to seek to a particular location in the bytestring?
12:16:05 <EvanR-work> evolution of a haskell programmer entry http://codepad.org/J3PNP7xP
12:16:36 <earthy> ghe
12:16:40 <earthy> nice :)
12:17:27 <Adamant> lol, that's great
12:17:28 <EvanR-work> http://codepad.org/G1D9pNKY with haskell highlighting
12:17:30 <sinelaw> heh
12:19:03 <EvanR-work> dammit its newIORef
12:19:18 <pumpkin> fail
12:21:30 <EvanR-work> i wonder how that compares in performance to other ways
12:22:07 <pumpkin> probably worse
12:25:11 <roconnor> it should be illegal for applications to depend on applications
12:25:17 * roconnor banishes exec.
12:30:50 <EvanR-work> yeah we should only use integrated application groupware suites
12:53:53 <nlogax> > let whatIsThis = drop =<< subtract 1 . length in whatIsThis "does this function exist somewhere?"
12:53:54 <lambdabot>   "?"
12:54:32 <pumpkin> lol
12:54:33 <zygoloid> > last "you mean this function?"
12:54:34 <lambdabot>   '?'
12:54:42 <pumpkin> pure . last
12:54:49 <zygoloid> > return . last $ "or this one?"
12:54:50 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
12:54:51 <lambdabot>    arising from a use of...
12:55:04 <zygoloid> > (:[]) . last $ "or this one?"
12:55:05 <lambdabot>   "?"
12:55:17 <nlogax> > last "" -- :O
12:55:17 <lambdabot>   *Exception: Prelude.last: empty list
12:55:27 <sproingie> (:[]) looks like a monkey emoticon
12:55:31 <nlogax> haha
12:56:21 <zygoloid> > (\xs -> const (last xs) <$> listToMaybe xs) "you could use this?"
12:56:21 <lambdabot>   Just '?'
12:56:45 <zygoloid> > take 1 . reverse $ "this would work?"
12:56:46 <lambdabot>   "?"
12:57:01 <nlogax> that was nice :)
12:57:36 <nlogax> but it's not in Data.List or somewhere? i saw so many similar functions, but not that one
12:57:38 <Sadache> I have an infinite list [Either String [a]] where String is an error. And I would like to have a Writer [String] [a] 
12:58:33 <Sadache> so that I cant ask say 100 elements, and I will get the 100 elements together with warnings that happened while evaluating them
12:59:10 <zygoloid> Sadache: partitionEithers is for you!
12:59:26 <benmachine> :t partitionEithers
12:59:27 <lambdabot> forall a b. [Either a b] -> ([a], [b])
12:59:54 <zygoloid> @type Writer . (concat *** concat) . partitionEithers
12:59:55 <lambdabot> forall a a1. [Either [a] [a1]] -> Writer [a1] [a]
13:00:04 <benmachine> e
13:00:05 <benmachine> er
13:00:08 <Sadache> zygoloid: interesting, does it work with infinite lists?
13:00:14 <zygoloid> @type Writer . second concat . partitionEithers
13:00:15 <lambdabot> forall a a1. [Either a1 [a]] -> Writer [a] [a1]
13:00:20 <benmachine> looks backwards to me :P
13:01:02 <pumpkin> I think the real question is why use Writer on [a]
13:01:16 <zygoloid> > partitionEithers [x | n <- [0..], x <- [Left n, Right n]]
13:01:19 <lambdabot>   *Exception: stack overflow
13:01:25 <zygoloid> Sadache: alarmingly, no, it does not work on infinite lists.
13:01:28 <zygoloid> bad base!
13:01:48 * zygoloid suspects someone wrote (a,b) when they meant ~(a,b)
13:01:51 <kmc> partitionEithers should work on an infinite list.  of course if one constructor only appears finitely often, the corresponding partition will hang after a finite length
13:02:00 <zygoloid> kmc: it should, but it does not!
13:02:09 <kmc> sad
13:02:39 <kmc> partitionEithers = foldr (either left right) ([],[]) where left a (l,r) = (a:l,r); right a (l,r) = (l,a:r)
13:02:45 <Sadache> which means that it doesn't solve my problem, right?
13:03:00 <kmc> Sadache, you could write a fixed version that does
13:03:35 <kmc> i don't see why ~ would help there
13:03:49 <zygoloid> kmc: in the recursive call to partitionEithers you need to lazily match the result
13:04:26 <benmachine> kmc: because matching a tuple constructor forces evaluation to WHNF
13:04:28 <kmc> yeah, it does help
13:04:57 <benmachine> left a b = (a : fst b, snd b) would work fine
13:05:14 <zygoloid> kmc: it helps because otherwise forcing the top-level (,) constructor forces all the (,) constructors
13:05:14 <kmc> right
13:05:27 <kmc> ah
13:05:31 <kmc> yes
13:05:45 <benmachine> left/right don't produce a (,) until they've already done the match
13:06:00 <kmc> bug report?
13:06:06 <kmc> where do you report bugs in base?
13:06:10 <pumpkin> libraries@
13:06:13 <pumpkin> I'd assume
13:06:32 <pumpkin> there was another one in there recently about something else being too strict
13:07:12 <sioraioc_> neeeeeeeeeet split
13:07:37 <pumpkin> that's a real net split though
13:07:39 <pumpkin> not a freenode split
13:07:54 <sipa> what's the difference?
13:08:10 <sproingie> OSI layers i guess
13:08:12 <sipa> it looks more like a server that went offline
13:08:16 <sipa> than a netsplit
13:08:48 <sipa> now, that's a netsplit :)
13:08:49 <pumpkin> there, that's a typical netsplit :)
13:08:50 <pumpkin> yeah
13:08:57 <pumpkin> I'm guessing some routing fucked up somewhere
13:09:02 * pumpkin shrugs
13:17:15 * hackagebot language-c-comments 0.1 - Extracting comments from C code  http://hackage.haskell.org/package/language-c-comments-0.1 (MatthewSottile)
13:17:41 <Sadache> I need to write a function for taking elements of a list until I get the nth that satisfies a predicate
13:18:48 <kmc> take n . filter p
13:19:46 <sipa> maybe he wants the earlier elements that do not satisfy the predicate as well?
13:19:56 <Sadache> so it is like take 3 [1,2,3,2,4,2,5,4,4,2] (=2) gives [1,2,3,4,2] 
13:20:06 <Sadache> sipa: exactly
13:20:49 <Sadache> I know I could write it, but I thought maybe composing some functions could make it
13:21:43 <kmc> ah
13:22:26 <Sadache> sorry it gives [1,2,3,2,4,2]
13:22:28 <pumpkin> oh okay
13:22:30 <pumpkin> was just about to ask
13:22:41 * pumpkin thinks
13:26:14 <pumpkin> a scanl with a span should do it
13:26:24 <pumpkin> but it's ugly with an if in it
13:27:03 <EvanR-work> define fi x y z = if x then y else z
13:27:10 <pumpkin> yeah :/
13:28:46 <Apocalisp> @type \p x -> map fst $ takeWhile snd $ map (p &&& id) x
13:28:47 <lambdabot> forall a. (Bool -> a) -> [Bool] -> [a]
13:28:56 <Apocalisp> no, not it
13:29:10 <Apocalisp> @type \p x -> map snd $ takeWhile fst $ map (p &&& id) x
13:29:11 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:29:27 <Apocalisp> oh, first n
13:32:28 <iFire`> does anyone know what haddock fails with this error?
13:32:43 <iFire`> >haddock  -o docs MyBot.hs PlanetWars.hs
13:32:44 <iFire`> PlanetWars.hs:41:6: '   parse error on input `-- ^ Engine / Simulation
13:35:44 <kmc> escape your slash
13:35:48 <kmc> Engine \/ Simulation
13:36:02 <kmc> slashes are markup for italics i think
13:38:35 <pumpkin> okay, got it
13:39:14 <pumpkin> @let takeWhileN n p = map snd . takeWhile ((/=n) . fst) . uncurry zip . first (scanl (+) 0) . unzip . map (fromEnum . p &&& id)
13:39:16 <lambdabot>  Defined.
13:39:44 <pumpkin> > takeWhileN 3 (==2) [1,2,3,2,4,2,5,4,4,2]
13:39:45 <lambdabot>   [1,2,3,2,4,2]
13:39:52 <pumpkin> Sadache: ^
13:39:57 <pumpkin> of course, it's horrendous
13:40:08 <Sadache> crazy cool :)
13:40:27 <sipa> :t (&&&)
13:40:28 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:41:51 <benmachine> pumpkin: fromEnum :o ingenious
13:42:03 <pumpkin> feels kinda dirty, tbh :P
13:42:12 <benmachine> oh yes
13:42:20 <benmachine> but dirty is fun sometimes :P
13:42:25 <pumpkin> I don't think making it more pointfree would be pleasant
13:42:26 <benmachine> this is why perl still exists >_>
13:42:39 <pumpkin> @pl \n p -> map snd . takeWhile ((/=n) . fst) . uncurry zip . first (scanl (+) 0) . unzip . map (fromEnum . p &&& id)
13:42:40 <lambdabot> ((map snd .) .) . (. (((uncurry zip . first (scanl (+) 0) . unzip) .) . map . (&&& id) . (fromEnum .))) . (.) . takeWhile . (. fst) . (/=)
13:42:42 <pumpkin> yeah, no
13:42:45 <benmachine> :P
13:42:57 <sipa> t3h h0rr0r
13:42:58 <benmachine> you could take the p out fairly easily but it wouldn't be very pleasant
13:43:02 <pumpkin> @pl \p n -> map snd . takeWhile ((/=n) . fst) . uncurry zip . first (scanl (+) 0) . unzip . map (fromEnum . p &&& id)
13:43:03 <lambdabot> ((map snd .) .) . flip ((.) . takeWhile . (. fst) . (/=)) . ((uncurry zip . first (scanl (+) 0) . unzip) .) . map . (&&& id) . (fromEnum .)
13:43:05 <Sadache> :)
13:44:39 * sipa is impressed by pumpkin's code
13:44:52 <pumpkin> not disgusted? :P
13:45:01 <pumpkin> it's almost the width of my IRC screen
13:54:48 <aristid> :t uncurry zip
13:54:49 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
13:55:06 <aristid> :t unzip
13:55:08 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
14:01:10 <EvanR-work> :t transpose
14:01:11 <lambdabot> forall a. [[a]] -> [[a]]
14:06:17 <pumpkin> preflex: seen snoyberg
14:06:17 <preflex>  Sorry, I haven't seen snoyberg
14:17:27 <roconnor> how widely used is the "text" package?
14:17:34 <Apocalisp> Can this be realized? (Traversable t) => t a -> t b -> t (a, b)
14:17:47 <roconnor> ah
14:17:51 <roconnor> 50 or more
14:17:51 <Apocalisp> (I don't think it can)
14:20:15 <benmachine> yeah it doesn't look easy to get stuff out of traversables
14:20:27 <Sadache> :t tell
14:20:28 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
14:20:33 <pumpkin> Apocalisp: I'd say no
14:20:39 <aristid> roconnor: would be cool if there were viewable statistics for each hackage package :)
14:20:49 <pumpkin> actually, hmm
14:20:58 <pumpkin> yeah, no
14:21:04 <Apocalisp> @type Data.Traversable.traverse
14:21:04 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:21:08 <benmachine> :t traverse (,)
14:21:09 <lambdabot> Not in scope: `traverse'
14:21:16 <benmachine> :t Data.Traversable.traverse (,)
14:21:17 <lambdabot> forall a b (t :: * -> *). (Data.Traversable.Traversable t) => t a -> b -> t (a, b)
14:21:42 <Sadache> :t tell ["s"]
14:21:43 <lambdabot> forall (m :: * -> *). (MonadWriter [[Char]] m) => m ()
14:22:03 <sipa> is there a lambdabot command for viewing an instance of a function?
14:22:11 <benmachine> Cale: it might be nice if lambdabot's L.hs imported Traversable and Foldable (either hiding overlaps, or qualified as T and F or something)
14:22:15 <pumpkin> @src (->) (>>=)
14:22:15 <lambdabot> f >>= k = \ r -> k (f r) r
14:22:19 <benmachine> sipa: viewing source code? sort of
14:22:31 <benmachine> there's @src but it's just examples
14:22:37 <djahandarie> :t T.traverse
14:22:37 <lambdabot> Couldn't find qualified module.
14:22:41 <benmachine> it's not "actual" definitions
14:22:47 <sipa> ah, i see
14:22:56 <djahandarie> :t S.null
14:22:57 <lambdabot> forall a. S.Set a -> Bool
14:23:25 <sipa> @src fromInteger
14:23:26 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:23:46 <sipa> @src fromInteger :: Integer -> Int
14:23:46 <lambdabot> Source not found. stty: unknown mode: doofus
14:24:21 <benmachine> Cale: oh it already imports them qualified, can we just have a short name please? :)
14:24:26 <Apocalisp> @type \x y -> Data.Traversable.traverse (Data.Traversable.traverse (,) x) y
14:24:27 <lambdabot> forall a a1 (f :: * -> *) (t :: * -> *). (Data.Traversable.Traversable f, Data.Traversable.Traversable t, Applicative f) => f a -> t a1 -> f (t (a, a1))
14:24:42 <pumpkin> that's the issue
14:24:42 <sipa> @src Maybe (>>=)
14:24:42 <lambdabot> (Just x) >>= k      = k x
14:24:42 <lambdabot> Nothing  >>= _      = Nothing
14:24:53 <pumpkin> that was my "actually, hmm"
14:24:55 <pumpkin> but then you need join
14:24:59 <sipa> @src Int fromInteger
14:24:59 <lambdabot> Source not found.
14:25:09 <benmachine> you also need f to be Applicative
14:25:11 <pumpkin> so you might as well do it the easy way with Applicative and not require join :P
14:25:16 <Apocalisp> right... you need either join or Applicative
14:25:16 <benmachine> if we've got applicative it's a lot easier >_>
14:25:27 <pumpkin> benmachine: it's basically the definition of applicative
14:25:33 <pumpkin> (in CT terms, anyway)
14:25:46 <benmachine> pumpkin: what, liftA2 (,)?
14:25:53 <benmachine> I guess if you've also got functor
14:25:54 <benmachine> then
14:25:55 <benmachine> sure
14:26:03 <benmachine> :t fmap (uncurry id) . liftA2 (,)
14:26:04 <lambdabot> forall c a b. (Monoid c) => ((a, b) -> c, a) -> ((a, b) -> c, b) -> c
14:26:07 <benmachine> erm
14:26:09 <benmachine> that didn't work
14:26:24 <pumpkin> http://en.wikipedia.org/wiki/Monoidal_functor
14:26:25 <benmachine> :t \x y -> fmap (uncurry id) $ liftA2 (,) x y
14:26:27 <lambdabot> forall b c (f :: * -> *). (Applicative f) => f (b -> c) -> f b -> f c
14:26:35 <benmachine> :t liftA2 (,) x y
14:26:37 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
14:26:37 <lambdabot>     In the second argument of `liftA2', namely `x'
14:26:37 <lambdabot>     In the expression: liftA2 (,) x y
14:26:39 <benmachine> ugh
14:26:42 <benmachine> :t liftA2 (,)
14:26:42 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
14:26:53 <pumpkin> :t uncurry (liftA2 (,))
14:26:53 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
14:26:53 <benmachine> so yeah if you could implement that you have an Applicative instance
14:27:42 <Apocalisp> so yeah I can definitely implement that without Traversable, even, if t is Applicative
14:28:05 <benmachine> hmm
14:28:32 <pumpkin> yeah
14:28:49 <benmachine> you can't implement traverse given <*>, right?
14:28:52 <pumpkin> Traversable gives you a distributive property
14:29:07 <benmachine> but nor can you implement <*> given traverse
14:29:07 <pumpkin> yeah, you can't
14:29:27 <benmachine> also we need a more confusing name for Foldable and Traversable
14:29:33 <benmachine> one that doesn't end in -able
14:30:45 <pumpkin> not sure what I'd call Foldable
14:31:29 * benmachine only ever uses Foldable on lists afair
14:31:50 <benmachine> that is to say, I only ever use appEndo . foldMap Endo
14:31:57 <pumpkin> :P
14:32:08 <benmachine> on lists
14:34:08 <Apocalisp> @type liftA2 (,)
14:34:09 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
14:35:28 <djahandarie> Why is it called the Dual Monoid?
14:35:33 <djahandarie> Wouldn't Opposite be more accurate?
14:37:20 <mreh> I can't post to any of the bulletin boards
14:37:27 <benmachine> we have bulletin boards?
14:37:42 <mreh> whatever you call them
14:37:59 <mreh> uh... mailing list?
14:38:04 <benmachine> oh right those
14:38:08 <mreh> http://mailman.cs.yale.edu/mailman/listinfo/yampa-users
14:38:17 <mreh> for example
14:38:44 <benmachine> I tended to fail at posting to haskell-cafe because I chose a different email address in the gmail thingy from the one I signed up
14:38:48 <mreh> I'm definitely subscribed
14:39:41 <mreh> benmachine: was the suffix different?
14:39:49 <mreh> gmail instead of googlemail
14:40:09 <benmachine> mreh: nah, completely different address
14:40:14 <benmachine> I have several with benmachine.co.uk
14:41:15 <mreh> p.o.s. gmail, I told it not to change the suffix
14:46:00 * hackagebot hothasktags 0.1.1 - Generates ctags for Haskell, incorporating import lists and qualified imports  http://hackage.haskell.org/package/hothasktags-0.1.1 (LukePalmer)
14:53:05 <pumpkin> @ask gwern any idea why the title of http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence contains an en-dash instead of a hyphen and what can be done about it at this point?
14:53:05 <lambdabot> Consider it noted.
14:53:11 <pumpkin> preflex: seen gwern
14:53:12 <preflex>  gwern was last seen on #xmonad 3 hours, 50 minutes and 1 second ago, saying: GREETINGS FELLOW HUMAN
14:55:08 <Sadache> what do i need to import to get tell "ss" to evaluate on ghci?
14:55:25 <Sadache> it gives me  No instance for (MonadWriter [[Char]] m)
14:55:43 <Cale> Sadache: The problem is that it's ambiguous
14:56:02 <Cale> Sadache: tell is polymorphic and can be implemented separately for different sorts of writer monad.
14:56:23 <Sadache> yes but it works here
14:56:26 <Cale> Sadache: If you wrap that in an appropriate call to runWriter or runWriterT, it'll disambiguate
14:56:35 <Sadache> :t tell "hhh"
14:56:37 <lambdabot> forall (m :: * -> *). (MonadWriter [Char] m) => m ()
14:56:45 <Saizan> > tell "hhh"
14:56:46 <Cale> That's just getting the type...
14:56:46 <lambdabot>   No instance for (GHC.Show.Show (m ()))
14:56:46 <lambdabot>    arising from a use of `M153512095...
14:57:04 <Cale> Does it not typecheck somehow?
14:57:07 <FunctorSalad> seems like an error message that could be improved :)
14:57:38 <FunctorSalad> "No universal instance for MonadWriter [String] m, and you didn't specify a specific m which might have an instance"?
14:57:49 <fasta> Sadache, it says that for all m that have that condition there is such an m () if you evaluate it. Except, if you don't specify an m it won't simply guess one.
14:58:19 <Sadache> ok, i see better i guess
14:58:26 <fasta> Sadache, it would be possible to create a language in which a guess is beind made, but it wouldn't be Haskell anymore.
14:58:43 <kmc> Haskell does guess in certain narrow situations
14:58:45 <kmc> I wish it didn't
14:58:47 <FunctorSalad> are you saying it's somehow essential to haskell that no arbitrary choice is made?
14:59:04 <FunctorSalad> it doesn't seem to be a very common situation in actual programs, since they're more constrained
14:59:09 <kmc> remember that type inference information flows bidirectionally; x may have ambiguous type but (f x) is fine because f places additional constraints
14:59:09 <benmachine> someone shoudl write an -XNoDefaulting
14:59:17 <kmc> benmachine, default ()
14:59:24 <FunctorSalad> benmachine: you get a warning if you use -Wall
14:59:27 <benmachine> kmc: oh, I guess so
14:59:31 <Saizan> FunctorSalad: that seems reasonable, i've seen many people get stuck into this, maybe you should open a ticket :)
14:59:47 <kmc> default: the unloved declaration
15:00:46 <FunctorSalad> indeed, I was surprised that I can't use it as an identifier...
15:01:57 <benmachine> mm
15:01:59 <benmachine> that would be nice
15:05:07 <Sadache> >runWriter (sequence [return "bb",tell ["aa"]])
15:05:31 <Sadache> > runWriter (sequence [return "bb",tell ["aa"]])
15:05:32 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
15:05:32 <lambdabot>         against inferred ty...
15:05:40 <fasta> kmc, where does Haskell guess?
15:06:42 <Sadache> I need to type this expression better
15:06:45 <FunctorSalad> number types? fasta 
15:07:16 <FunctorSalad> @type 2.0 + 2.0
15:07:17 <lambdabot> forall t. (Fractional t) => t
15:07:19 <FunctorSalad> :p
15:07:25 <FunctorSalad> > show 2.0
15:07:26 <lambdabot>   "2.0"
15:07:33 <FunctorSalad> that one requires a choice
15:07:48 <megajosh2> > ord "4"
15:07:49 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:07:49 <lambdabot>         against inferred type...
15:07:49 <Sadache> > runWriter (sequence [return "bb",tell ["aa"] :: Writer [Char] [Char]])
15:07:50 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
15:07:50 <lambdabot>         against inferred ty...
15:07:55 <megajosh2> > ord '4'
15:07:56 <lambdabot>   52
15:08:15 <fasta> FunctorSalad, yes, but I think that's even useful. 
15:08:22 <sipa> i that a guess? that's just applying a default
15:08:47 <Cale> > runWriter (sequence [return "bb",tell ["aa"] >> return "cc"])
15:08:47 <lambdabot>   (["bb","cc"],["aa"])
15:08:49 <fasta> sipa, it's a bit of splitting hairs. 
15:08:56 <Cale> Sadache: ^^
15:09:11 <sipa> fasta: i need to google that expression...
15:09:27 <sipa> ok, got it :)
15:09:35 <FunctorSalad> > "..." >> "02x" -- favourite list monad usage
15:09:36 <lambdabot>   "02x02x02x"
15:09:50 <FunctorSalad> > "..." >> "%02x" -- err
15:09:51 <lambdabot>   "%02x%02x%02x"
15:10:41 <Sadache> FunctorSalad: funny one
15:11:20 <sipa> > Nothing >> undefined
15:11:21 <lambdabot>   Nothing
15:11:25 <tolkad> I'm trying to write a type synonym default in a class but GHC says "Type declaration in a class must be a kind signature or synonym default" but it IS a synonym default
15:11:33 <sipa> > Just undefined >> Nothing
15:11:34 <lambdabot>   Nothing
15:11:54 <Entroacceptor> > undefined >> Nothing
15:11:55 <lambdabot>   *Exception: Prelude.undefined
15:12:06 <Entroacceptor> good.
15:12:12 <tolkad> > Just Nothing >> undefiend
15:12:13 <lambdabot>   Not in scope: `undefiend'
15:12:20 <Sadache> > runWriter (sequence [return "bb",tell ["aa"] :: Writer [[Char]] [Char]])
15:12:20 <tolkad> > Just Nothing >> undefined
15:12:20 <sipa> tolkad: i believe you can't write type synonym defaults
15:12:21 <lambdabot>   <no location info>: lexical error at character '\FS'
15:12:21 <lambdabot>   *Exception: Prelude.undefined
15:12:35 <sipa> mainly an implementation issue
15:12:39 <tolkad> sipa: they can't be true, the compiler says you can
15:12:42 <tolkad> that can't*
15:12:56 <tolkad> "Type declaration in a class must be a kind signature or synonym default"
15:13:17 <sipa> hmm, so it would seem indeed
15:13:55 <sipa> i was quite sure it was not allowed because that would require type-checking at each instance, while now it's done at the class definition
15:13:58 <FunctorSalad> what does such a default look like?
15:14:08 <FunctorSalad> just like an instance I guess
15:14:52 <sipa> class X t where { type F t :: *; type F t = t }
15:14:55 <sipa> something like that?
15:15:00 <tolkad> I really only need one instance, but I'm not sure how to put a class constraint on a type family
15:15:16 <tolkad> sipa: that's what I tried
15:15:30 <sipa> you can do this, i think:
15:15:48 <sipa> class (Show (F t)) => X t where { type F t :: * }
15:16:05 <sipa> to require F t to belong to class Show
15:16:53 <kmc> tolkad, i believe those are implemented in GHC 7 (and thus current dev snapshots) but not 6.12
15:17:01 <tolkad> oh
15:17:10 <kmc> perhaps they completed the parsing support earlier, leading to this misleading error message
15:17:26 <sipa> tolkad: what GHC are you using?
15:17:36 <sipa> my information may be outdated of course
15:17:41 <tolkad> 6.12.3
15:18:34 <tolkad> I'm just playing with them anyway, trying to see what kinds of runtime calculations I can do by doing stuff with type system
15:19:51 <tolkad> the type system*
15:20:31 <sipa> tolkad: i don't see how a default type could solve the problem of requiring a class constraint on a type family :)
15:24:26 <tolkad> class C a b | a -> b where { type TC a :: *; type TC a = b }
15:24:28 <tolkad> vs. { class C a b | a -> b; type family C a b => TC a :: *; type instance C a b => TC a = b }
15:24:42 <kmc> asstypes and fundeps both?
15:24:55 <tolkad> 0_o
15:25:02 <tolkad> oh associated types
15:25:51 <lispy> ass types?  Like _|_?
15:26:07 <FunctorSalad> thanks for saying what everybody thought but nobody dared to say
15:26:18 * lispy bows
15:26:25 <FunctorSalad> \o/
15:26:41 <lispy> _|_ :: Ass Type
15:28:24 <fasta> Haskell seems to have lots of shitty types.
15:28:46 <sipa> :t (_|_)
15:28:47 <lambdabot> parse error on input `|'
15:28:56 <Sgeo> :t bottom
15:28:57 <lambdabot> Not in scope: `bottom'
15:29:03 <Sgeo> :t undefined
15:29:04 <lambdabot> forall a. a
15:29:22 <sipa> @let (_|_) = undefined
15:29:22 <lambdabot>   RegularPatterns is not enabled
15:29:38 <tolkad> :k Num (a b) => a
15:29:38 <lambdabot>     `a' is not applied to enough type arguments
15:29:38 <lambdabot>     Expected kind `*', but `a' has kind `k -> *'
15:29:42 <tolkad> :k Num (a b) => a b
15:29:43 <lambdabot> *
15:29:48 <FunctorSalad> regular patterns? :O
15:29:48 <EvanR-work> gutter haskell
15:29:55 <FunctorSalad> lambdabotism?
15:30:09 <hydo> Hrm, I've never had to do this before.  Let's assume I have the contents of a file in a bytestring, what would be the right way to break that up into chunks of x size?  intuition says some form of 'take'.
15:30:24 <tolkad> Why is :k expecting kind *...?
15:30:26 <EvanR-work> @hoogle chunk
15:30:26 <lambdabot> Data.ByteString.Lazy.Internal chunk :: ByteString -> ByteString -> ByteString
15:30:27 <lambdabot> Data.ByteString.Lazy.Internal Chunk :: ByteString -> ByteString -> ByteString
15:30:27 <lambdabot> Network.HTTP.Base chunkedTransfer :: BufferOp a -> IO (Result a) -> (Int -> IO (Result a)) -> IO (Result ([Header], a))
15:30:35 <Twey> Iterate a take?
15:30:36 <hydo> oh, well... 
15:30:45 <sipa> tolkad: what do you want to know?
15:30:47 <hydo> Thanks, EvanR!
15:30:57 <EvanR-work> the stuff above didnt help
15:31:01 <EvanR-work> but look through the bytestring lib
15:31:23 <hydo> will do... should have done that before I asked in here.
15:31:36 <FunctorSalad> :k ReaderT
15:31:37 <tolkad> sipa: it's not important, I'm just confused why :k expects kind *. " Expected kind `*', but `a' has kind `k -> *"
15:31:38 <lambdabot> * -> (* -> *) -> * -> *
15:32:00 <sipa> tolkad: if you require (a b) to belong to class Num, (a b) must be a type of kind *, right?
15:32:11 <tolkad> sipa: yes
15:32:32 <tolkad> sipa: but a would be of kind * -> * I think
15:32:32 <kmc> :k doesn't "expect kind *".  if i write ":t (chr 3)" and it says "Expecting type Char, inferred type Int", that doesn't meant ":t expects type Char"
15:32:33 <lambdabot> parse error on input `"'
15:32:41 <sipa> tolkad: indeed
15:32:43 <kmc> err... (ord 3)
15:32:53 <sipa> :k Num (a b) => a
15:32:54 <tolkad> sipa: oh, I see
15:32:55 <lambdabot>     `a' is not applied to enough type arguments
15:32:55 <lambdabot>     Expected kind `*', but `a' has kind `k -> *'
15:33:13 <sipa> :k Monad
15:33:14 <lambdabot> Class `Monad' used as a type
15:33:20 <sipa> i need sleep
15:33:23 <tolkad> :k Monad m => m
15:33:24 <lambdabot>     `m' is not applied to enough type arguments
15:33:24 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
15:33:33 <sipa> :k []
15:33:34 <lambdabot> * -> *
15:33:40 <kmc> classes sort of have a kind signature, but you can't ask for them directly
15:42:32 <sanitized> hello
15:42:47 <sanitized> this is so weird, I didn't realize this many people knew haskell.
15:43:07 <sanitized> or were interested in it for that matter
15:43:18 <benmachine> sanitized: quite a lot of the people in here are probably here because they don't know haskell :P
15:44:24 * hackagebot anansi 0.2.1 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.2.1 (JohnMillikin)
15:44:38 <sanitized> that's a good point
15:44:53 <sanitized> I remember wanting to kill someone when I took a class in it
15:45:07 <sanitized> there were no textbooks, and nobody seemed to know what it WAS, let alone offer help
16:03:30 <Saizan> how long ago was that?
16:04:35 <pumpkin> must've been a while ago
16:07:10 <aisamu> Hello everyone! / (Buongiorno a tutti!)  - Has anyone tried to install twidge (cabal version 1.0.4) on haskell package 2010.2? I got the ghc-asm issue (solved) but now there's another one I can't manage to fix/understand!
16:10:10 <gwern> pumpkin: because a stupid bot edited the redirect page rendering non-admins unable to move the page over the redirect; you need to go through http://en.wikipedia.org/wiki/Wikipedia:Requested_moves
16:10:56 <pumpkin> can't you just change the title?
16:11:03 <pumpkin> (you being an admin and all)
16:11:13 <pumpkin> or is there some bureaucracy involved?
16:11:32 <pumpkin> it seems pretty uncontroversial, bad punctuation in a title
16:12:26 <gwern> I am not an admin on en
16:12:30 <pumpkin> :O
16:12:42 <gwern> it is uncontroversial, but nevertheless requested moves is how one asks an admin to do it
16:12:47 <pumpkin> ah okay
16:12:53 <gwern> as opposed to chasing them around the wiki and bugging them on their talk
16:12:55 <pumpkin> which one are you admin on, out of curiosity?
16:13:11 <gwern> pumpkin: I'm an admin on our hawiki. entirely separate from en or WMF
16:13:23 <EvanR> gothic old norse gaelic
16:13:25 <pumpkin> oh okay, I thought you were one on wikipedia too :)
16:13:47 * gwern was
16:15:52 <Saizan> aisamu: you should paste a log of the error on some pastebin site
16:16:10 <Saizan> aisamu: also, are you sure about cabal version 1.0.4 ?
16:21:08 <tolkad> how can I put class restrictions on type synonyms or type family instances? either one would work
16:22:15 <FunctorSalad> for associated type syns I think you can just put them in the context of the class, tolkad 
16:22:20 <FunctorSalad> not entirely sure
16:22:32 <tolkad> FunctorSalad: yeah, I want to do it outside a class
16:24:39 <tolkad> type C t => T t = t doesn't work
16:25:13 <FunctorSalad> out of curiosity, why'd you want to do that?
16:25:23 <benmachine> tolkad: type T t = C t => t might or might not work, it's a bit complicated
16:25:47 <FunctorSalad> (you could but the class constraint on functions that use the.. "Asstype")
16:26:20 <FunctorSalad> oh nevermind, you wrote "instances"
16:26:20 <tolkad> benmachine: no, it thinks that is rank 2
16:26:30 <FunctorSalad> I though constraints on the type family itself
16:26:34 <FunctorSalad> *thought
16:28:56 <tolkad> FunctorSalad: I wanted to make a type level function equivalent to a class with a function dependency without having to provide an implementation for each class instance (default type synoyms are not supported in stable GHC). Also, a default type might be messed up by an instance and it would just be better to make that impossible
16:29:13 <tolkad> functional dependency
16:30:01 <tolkad> e.g. class C a b | a -> b where { type TC a :: *; type TC a = b }
16:31:45 <aisamu> Saizan: ok! here it is http://hpaste.org/40442/errorlog_for_saizan . Oh, and what i meant by the cabal version was the version that i could get using cabal, as the most recent version of twidge is 1.0.5 =). Thanks!
16:33:43 <Saizan> aisamu: try adding --constraint="hoauth < 0.3" or < 0.2.5 even if you're feeling unlucky :)
16:34:35 * Saizan wants a --don't-trust-unbounded-deps flag
16:36:36 <hpc> how about --no-future-deps
16:37:03 <hpc> it gets the latest version as of the package's release
16:37:27 <Saizan> that's what i was thinking it should do :)
16:38:09 <benmachine> that would mean cabal would need to know when a version was uploaded
16:38:14 <benmachine> hackage knows but cabal doesn't afaik
16:38:36 <benmachine> which makes sense since cabal doesn't even need to work with hackage, in principle
16:38:51 <benmachine> can't see how latest-version-as-of-release would handle local installs
16:38:59 <benmachine> i.e. where release isn't even a thing
16:39:07 <benmachine> but, why not just make unbounded deps fail QA?
16:39:15 <aisamu> Saizan: Thanks! Worked! Was i trying to use a sort of a "beta" version of hoauth?
16:39:38 <benmachine> aisamu: nah, just a version that twidge didn't anticipate
16:39:42 <dcoutts> benmachine: it's a little draconian since it's not always clear what the correct upper bound should be
16:39:44 <benmachine> because it wasn't sensible
16:40:06 <dcoutts> benmachine: now if the package in question has opted into the PVP then that's a different matter
16:40:15 <benmachine> dcoutts: true
16:40:43 <benmachine> so we need a Version-scheme: field I suppose?
16:45:43 <aisamu> benmachine: oh, i see... i'll try that before bugging you if something goes wrong next time
16:53:39 <telephone> I need a container like list, but with efficient lookup of indices. Which Haskelltype is suitable?
16:54:33 <Saizan> Data.Sequence fsvo like list, or maybe Data.Array if you don't need to update much
16:54:34 <dsouza> telephone: is n log n efficient enough? if so maybe Data.Map might be what you are looking for
16:55:08 * dsouza thinks data.map is not list-like, though :-)
16:55:16 <telephone> dsouza: I was looking for something like a std::vector
16:55:43 <Pseudonym> Data.Sequence
16:55:48 <Pseudonym> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/Data-Sequence.html
16:55:58 <dsouza> ok!
16:56:08 <Pseudonym> It's O(log n) random access.
16:56:17 <Pseudonym> With a fairly low constant factor.
16:56:41 <Pseudonym> It's more like std::deque than std::vector.
16:57:07 <djahandarie> It's not really much like anything in std
16:57:13 <Pseudonym> That's true.
16:57:18 <telephone> I was thinking about Array, but the arrays there seems to work with constant size
16:57:41 <Pseudonym> So is std::vector, under the covers.
16:58:07 <telephone> There is also the Data.Vector type
16:58:08 <copumpkin> how wrong is it to claim IntMap has constant-time lookup? :P
16:58:24 <c_wraith> copumpkin, only mildly :)
16:58:25 <djahandarie> Capital crime!
16:58:46 <copumpkin> it's bounded by the size of your machine words, and if we're going to take those into account, memory accesses aren't constant time either
16:58:49 <djahandarie> You should see what happened to the last person who lied about asymptotics!
16:59:13 <telephone> Pseudonym: hm, maybe I should stick with arrays, increment sizes manually?
16:59:37 <Pseudonym> telephone: Can I ask what you need this for?
16:59:38 <fryguybob> copumpkin: Isn't an en dash the correct punctuation for Curry–Howard correspondence?
16:59:47 <telephone> Pseudonym:yes
16:59:47 <c_wraith> telephone, just be aware that Array is slow to update.  MArray is much faster, but adds some additional restrictions
16:59:50 <Pseudonym> Hyphen, I'd think.
16:59:55 <copumpkin> fryguybob: it's a hyphenated word, so it needs a hyphen :P
16:59:59 <Pseudonym> OK, so what do you need it for?
17:00:13 <djahandarie> Hyphen is correct there, not an en-dash
17:00:24 <revenantphx> join #wei
17:00:29 <revenantphx> sorry
17:00:31 <revenantphx> meant to do /join
17:00:44 <Pseudonym> copumpkin: The field that I've found myself in lately is very careful about specifying which machine model the big-O (and little-o, which you don't find often) is relative to.
17:00:47 <c_wraith> revenantphx, I was just thinking "I don't remember him being a spammer" :)
17:00:49 <telephone> I should store points in an opengl world.
17:00:54 <copumpkin> wow, little-O!
17:00:56 <revenantphx> c_wraith: thanks ^_^
17:00:56 <copumpkin> or little-o
17:00:59 <Pseudonym> Yes.
17:01:11 * copumpkin hasn't seen that since his algorithms course ages ago
17:01:42 <Pseudonym> Like: This bit vector representation takes (1 + o(1))N bits.
17:01:55 <Pseudonym> Meaning "constant percentage overhead".
17:02:30 <Pseudonym> And O(1) time for query operations in the word RAM model.
17:02:54 <copumpkin> I see
17:03:41 <copumpkin> so under your strict assumptions, is O(1) for IntMap/Set lookup a lie or just not as specific as it can be?
17:03:59 <Pseudonym> telephone: And what do you need to do with them?
17:04:08 <Pseudonym> Do you need to modify these points?  Cull them?
17:04:40 <Pseudonym> I'd say that O(1) for IntMap is a lie.
17:04:48 <Pseudonym> In the bit probe model, it's O(log n).
17:05:18 <copumpkin> but there's a bounded number of bits
17:05:31 <copumpkin> which of course means you can only store a finite number of objects in it, I guess :P
17:05:37 <Pseudonym> The word RAM model says that O(log n) adjacent bits can be accessed in O(1) time.
17:05:50 <Pseudonym> But in a digital trie, those O(log n) bits are _not_ adjacent.
17:05:54 <ManateeLazyCat> I have a batch script to scan/record patches in many sub-project, something like this : "darcs add ./src/* -r -q --case-ok && darcs record", but darcs will failed with "No files were added" to terminate script, how to suppress failed when no files need add?
17:05:54 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
17:06:10 <djahandarie> O(log n) bits? 
17:06:17 <telephone> Pseudonym: the points should be modified. There is also possible to add more points
17:06:25 <copumpkin> it'd be useful to state what the n represents in all these cases
17:06:53 <Pseudonym> Do you need some kind of spatial query, telephone?  Like, are some points going to be outside the frustum and hence you don't want to see them?
17:07:16 <Pseudonym> In geometric algorithms, it REALLY matters what operations you are planning to support.
17:07:22 <ManateeLazyCat> @tell wjt We will add #ifdef in gtk2hs, then GtkAnchorType can support in GTK+2 and departed in GTK+3. :)
17:07:23 <lambdabot> Consider it noted.
17:07:27 <Jordan1> Hi guys, I'm a complete newbie to Haskell and was wondering if anyone could help me understand as to why my code is receiving an error message (it's just a simple case of using let and where expressions) please :) ?
17:07:48 <Pseudonym> @paste
17:07:49 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
17:07:55 <Pseudonym> Go ahead, Jordan21
17:08:00 <aristid> @where hpaste
17:08:00 <Pseudonym> And also Jordan1
17:08:00 <lambdabot> http://hpaste.org/
17:08:03 <aristid> @hpaste
17:08:03 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
17:08:04 <Pseudonym> Right.
17:08:07 <aristid> @where hpaste
17:08:07 <lambdabot> http://hpaste.org/
17:08:10 <aristid> that one is better
17:08:20 <Pseudonym> How did we end up with two pastebins?
17:08:32 <aristid> Pseudonym: well i guess moonpatio.com is older
17:08:44 <aristid> somebody should remove the @hpaste and @paste commands
17:08:51 <Jordan1> http://hpaste.org/40443/quadraticsolver
17:08:52 <Pseudonym> Or it was set up when hpaste was down.
17:08:56 <Pseudonym> Which it was for a while.
17:09:03 <telephone> Pseudonym: Hm. I am not so advanced for the moment. I did only want points in a table.
17:09:06 <aristid> moonpatio.com is down too
17:09:08 <tarwatirno> I am fairly new to Haskell. I keep running into the problem of wanting to do something to every element of a list with odd or even index (and more generally to all the elements whose indices are in the same equivalence class modulo n). Is there a best way to do this?
17:09:09 <Pseudonym> Jordan1: And what's your error message?
17:09:22 <Jordan1> Quadratic.hs:22:2: parse error on input `let'
17:09:53 <Jordan1> I can put the d = b^2 − 4ac in the where part, but it won't work with let for some reason. I am meant to use both let and where :(
17:10:09 <telephone> Pseudonym: points in a table : points accessable and modifiable efficiently 
17:10:13 <Jordan1> I've ensured I've used no tabs, purely spaces and the layout is correct (I think)
17:10:13 <Pseudonym> Jordan1: OK, let me explain what let means.
17:10:19 <Jordan1> Okay, thanks :
17:10:20 <djahandarie> Jordan1, the let needs to go at the start of the expression if that's how you are doing it
17:10:20 <Pseudonym> let is an expression.
17:10:37 <telephone> but now I want to go to bed.
17:10:39 <Pseudonym> "where" is a shorthand for "let" which is more convenient for function definitions.
17:10:48 <telephone> Pseundonym: thank you
17:10:55 <Pseudonym> You can say f ... = e where stuff
17:11:03 <Pseudonym> Or: f ... = let stuff in e
17:11:11 <Pseudonym> What you really want here is:
17:11:15 <Pseudonym> quadraticSolver a b c
17:11:35 <Pseudonym>   = let d  = b^2 - 4 * a * c
17:11:49 <Pseudonym>         x1 = ( (-b) + sqrt d) / (2*a)
17:11:53 <Pseudonym> ...
17:11:57 <Pseudonym>     in (x1, x2)
17:12:02 <Pseudonym> I fixed your "2a" syntax.
17:12:04 <Pseudonym> Makes sense?
17:12:18 <Pseudonym> The let d = ... in d is an expression which equals d.
17:12:33 <Pseudonym> Ah, gotta go.  Meeting.
17:12:34 <Pseudonym> BBS.
17:12:41 <Jordan1> Ah thanks, unfortunately we need to use both 'let' and 'where' and have a shorthand for '2a' even though it isn't really necessary...
17:13:00 <Jordan1> But thanks for clearing things up
17:13:02 <aavogt> there should be let allowed for modules
17:13:04 <djahandarie> Jordan1, then f x = let ... in (... where ...)
17:13:30 <djahandarie> Actually I'm not sure that's how it's parenthesised
17:13:31 <aavogt> you can also put wheres on the declarations in let
17:13:41 <djahandarie> aavogt, he apparently needs to use both let and where
17:13:54 <djahandarie> Assignments these days
17:13:55 <djahandarie> ┐(´ー｀)┌
17:13:58 <Jordan1> Heh xD
17:14:05 <Jordan1> Yeah I managed to use one or the other, just not both...
17:16:18 <aavogt> it should help to read the relevant section in the haskell report
17:17:38 <fryguybob> copumpkin: http://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style#En_dashes
17:18:16 <copumpkin> fryguybob: interesting
17:18:16 <djahandarie> Oooh
17:18:20 <copumpkin> okay, I concede
17:18:28 <djahandarie> I didn't know that either
17:18:29 <fryguybob> Unless howard got curried of course :D
17:18:35 <copumpkin> oh actually
17:18:52 <copumpkin> oh okay, yeah
17:18:54 <copumpkin> en-dash it is
17:18:56 <ManateeLazyCat> Oh, 'darcs add ./Manatee/* -r -q --case-ok || darcs record' is okay, typeo. :)
17:19:14 * copumpkin grovels before fryguybob 
17:19:31 <djahandarie> Howard and Curry correspondence <=> Curry–Howard correspondence
17:20:05 * fryguybob grovels more before copumpkin's plethora of Haskell knowledge.
17:21:53 <copumpkin> lol
17:21:59 <copumpkin> I wish :)
17:22:02 <fryguybob> :D
17:22:07 <copumpkin> still much to learn
17:22:36 <FunctorSalad> Curry feat. Howard - ...
17:29:54 <gwern> dammit Cale!
17:30:06 <gwern> Cale: where are my damn patches for my damn lambdabot in my damn c.h.o repo?
17:30:15 <gwern> I thought you were recording the state last damn night!
17:30:25 <gwern> apparently my _|_ you were
17:30:35 <gwern> aaarrrgggghhh
17:30:50 <djahandarie> Yarg!
17:31:03 <Pseudonym> Back.
17:31:27 <aristid> gwern: why is mueval so slow!
17:31:38 <Pseudonym> Ah, I see that djahandarie has stated the Curry-Howard correspondence isomorphism.
17:31:48 <gwern> aristid: because you touch yourself at night
17:32:01 <djahandarie> Pseudonym, 8-)
17:32:09 <gwern> what evil expressions lurk in the human heart? the mueval knows!
17:32:10 <Cale> gwern: what?
17:32:28 <gwern> Cale: lambadabot's state files, you were supposed to record and push them
17:32:57 <Cale> gwern: I did a push. It said there were conflicts, I went to look at the conflicts on c.h.o and didn't find any.
17:33:08 <Cale> Maybe it didn't commit the changes.
17:33:28 <gwern> the last patch in my repo is from june
17:33:32 <gwern> and 'twas by me
17:33:37 <gwern> and this was pulling over sssh
17:33:47 <gwern> so I think it didn't get committed
17:33:55 <aristid> gwern: i've changed the module list in my mueval a little, and when i actually use one of these additional modules, it needs 1.5 seconds to evaluate :/
17:34:13 <gwern> nothing in life is free, aristid
17:34:26 <gwern> you want more modules? ya gotta pay
17:34:59 <aristid> gwern: would it be possible to pre-load the modules somehow?
17:35:07 <Cale> okay, I pulled over changes and recorded a patch to resolve conflicts. Apparently push does nothing at all if there's a conflict.
17:35:13 <Cale> (only pull does)
17:35:14 <gwern> aristid: I hear the OS caches files...
17:35:17 <Cale> I suppose that makes sense.
17:35:39 <aristid> gwern: i hear that doesn't help when all the work is done in RAM
17:35:53 <aavogt> mueval could have some sort of persistent mode
17:35:53 <gwern> ghc api does a lot of file io anyway
17:35:56 <aristid> it loads 20 packages or so
17:36:04 <gwern> aavogt: well, there is the tryhaskell fork
17:36:29 <aristid> hmmm
17:37:11 <aristid> it would be cool if it was possible to save the interpreter state in an image file :D
17:37:48 <aristid> so you get the isolation of mueval and the persistence of tryhaskell
17:38:03 <aristid> *the benefits of persistence, i.e. speed
17:38:03 <FunctorSalad> maybe more than one "it" too...
17:38:29 <aristid> FunctorSalad: huh? is my language bad style?
17:38:47 <FunctorSalad> aristid: heh no, I mean "another ghci addition"
17:39:01 <FunctorSalad> being able to reference more previous expressions than the last one
17:39:11 <FunctorSalad> (one wrong operation and it's all gone)
17:39:30 <aristid> FunctorSalad: oh, right. "it"
17:41:17 <gwern> aristid: that's better handled at the OS... with things like cryopid or something
17:47:05 <gwern> Cale: excellent. now do this every 6 months ;)
17:47:59 * gwern suggests a calendar reminder
17:49:33 <Sgeo> Two Haskell programmers walk into a bar. The first one says, "I'll have..." The bartender waits. The second one says, "Don't worry, he'll finish ordering the rum and coke as soon as he starts drinking it."
17:49:36 <Sgeo> ^^from Reddit
17:51:37 <monochrom> The reddittors walked into twitter. They never came out.
17:51:46 <EvanR> how accurate is that anyway
17:51:58 <EvanR> sounds acausal
17:52:43 <monochrom> accurate to the 10th decimal places. we are sure it is not 2.001 or 1.999
17:53:07 * EvanR looks up more haskell jokes
17:53:31 <EvanR> funny coinsidence today i started coming up with a rap about functional programming
17:53:48 <monochrom> please don't share it
17:55:14 <EvanR> considering ive never came up with a rap, and im not even black, that is likely
17:56:03 <gwern> Sgeo: that's a poor joke
17:56:22 <EvanR> http://www.haskell.org/haskellwiki/Humor/Poem
17:56:23 <gwern> Sgeo: here's a better one. 'the professor walked into the lecture hall and said, today's lecture is about lazy evaluation.'
17:56:26 <gwern> 'any questions?'
17:56:38 <gwern> EvanR: I'm fond of the haikus myself
17:58:40 <kmc> so if continuations are "functional GOTO", can i say that delimited continuations are "functional COME FROM"?
18:00:14 <monochrom> no, but it is "goto there and back again"
18:00:21 <aristid> gwern: that's the same joke in a different context, so how could it be better?
18:01:21 <kmc> gwern's is funnier
18:01:25 <EvanR> any professor who starts a lecture like that should be shot
18:02:10 <kmc> any chicken that tries to cross the road should be cooked into tasty nuggets
18:02:21 <gwern> aristid: it's all about the delivery
18:02:31 <gwern> aristid: mine had better punctuation
18:02:47 <EvanR> 'i don't know if this is better' ;)
18:02:48 <aristid> gwern: punctuation is very important, that is true.
18:03:06 <monochrom> two cocoa beans walk into a chocolate bar
18:03:20 <aristid> monochrom: ROFL
18:03:32 <aristid> :P
18:03:42 <EvanR> radio, what radio
18:04:02 <kmc> no soap, radio
18:04:20 <kmc> "fuck you, clown"
18:05:26 <kmc> the style of teaching gwern describes is totally feasible with only one student
18:05:40 <Adamant> kinda modified Socratic
18:05:58 <monochrom> what problem is there with two students?
18:06:12 <Adamant> one has to busy wait
18:06:14 <Adamant> or just wait
18:06:29 <kmc> you have to find the infimum of their questions and answer that
18:06:34 <monochrom> I see
18:06:51 <kmc> we assume there is a lattice of partial knowledge, as in domain theory
18:06:58 <monochrom> the teacher needs to be multi-core
18:07:11 <gwern> kmc: surely questions are more than just a lattice?
18:07:14 <Adamant> human concentration is mostly single-threads, sadly
18:07:18 <gwern> I'd bet they're a total ordering
18:07:22 <Adamant> s/threads/threaded
18:07:27 <monochrom> and also http://conal.net/blog/posts/lazier-functional-programming-part-1/
18:07:41 <kmc> gwern, no, it's possible for x and y to have z as a prerequisite but neither x nor y is a prereq for the other
18:08:01 <kmc> CS textbooks often start with a dependency dag of the chapters
18:08:12 <kmc> because CS textbook authors, and readers, are just that cool
18:08:39 <aavogt> kmc: because it's a collection of mostly unrelated topics
18:08:44 <kmc> nah
18:08:53 <kmc> NaPL has one, but i wouldn't say TaPL is a collection of mostly unrelated topics
18:08:56 <kmc> TaPL*
18:09:07 <kmc> it seems the poset axioms should hold on a "prereq of or equal to" relation
18:10:13 <aavogt> for more focused topics, the graph will be boring
18:10:34 <aisamu> I leave for 5 minutes and when i come back I see things like "the teacher needs to be multi-core". I swear it was only a lemon tea. 
18:10:57 <kmc> you can't spell "lemon" without "LSD"
18:11:13 <IceDane> roconnor: Thank you for your suggestion about using the MaybeT monad before. I couldn't understand how it would benefit me before, but when I was semi-drunk before it dawned on me out of the blue, hah. It made my life easier
18:11:33 <kmc> and yea, the monads did shine on him from heaven
18:11:49 * IceDane feels blessed
18:12:14 <Adamant> kmc: wait, there are no s's or d's in 'lemon'. or are you using figurative language, you cheeky man?
18:12:24 <Colours> no he is just extremely high
18:12:33 <kmc> Adamant, have some of my "lemon tea" and see if you change your mind
18:13:11 <Adamant> kmc: why would you denature perfectly good LSD by putting it in a hot liquid?
18:13:13 <Adamant> :P
18:13:41 <Adamant> actually I don't know if that would do that to LSD.
18:13:50 <kmc> would that denature it? other tryptamines are fine in tea, but LSD is a more complicated and fragile molecule
18:14:00 <Adamant> yah, that was for the funny factor
18:14:04 <Adamant> it may or may not
18:14:11 <kmc> only one way to find out
18:14:19 <EvanR> what kind of tea 
18:14:20 <Adamant> no, there are lots of ways to find out :P
18:14:32 <kmc> which usually means "only two ways to find out, one involving expensive equipment and another that's fun"
18:14:36 <Adamant> most of which do not involve consuming
18:14:49 <Adamant> naw, inexpensive equipment and checking the literature also works
18:14:53 <kmc> anyway i'm going to go eat a burrito
18:14:58 <kmc> and i swear that's not drug slang
18:14:58 <Adamant> ON WEED?
18:15:02 <Adamant> :P
18:15:25 <EvanR> monads are like drugs
18:15:40 <Adamant> everything is like drugs, but only on good drugs.
18:15:45 <Apocalisp> OK, so it CAN be realized: (Traversable t) => t a -> t b -> t (a, b)
18:16:11 <Apocalisp> using two State monads
18:16:26 <lucasicf> i'm new to haskell people
18:16:41 <lucasicf> what's the difference between declaring a data and a type ?
18:16:57 <kmc> type is simply a synonym
18:16:58 <EvanR> algebraic data type versus type synonym
18:17:17 <kmc> if you write «type S = T» then as far as the checker is concerned, S and T are interchangeable
18:17:40 <lucasicf> thanks
18:17:44 <kmc> whereas "data" introduces a new, distinct type, with one or more data constructors, each having zero or more data fields
18:17:57 <lucasicf> so only with data i can create more complex structures
18:18:07 <lucasicf> like data People = Person Name Age
18:18:11 <kmc> right
18:18:18 <kmc> the closest with a synonym would be type People = (Name, Age)
18:18:19 <EvanR> that example can be a new type
18:18:28 <EvanR> which is data-lite
18:18:29 <kmc> that's generally discouraged
18:18:34 <kmc> EvanR, no it can't
18:18:41 <EvanR> oh?
18:18:41 <lucasicf> type People = (Person, Name, Age)
18:18:51 <EvanR> newtype can only have one field
18:18:54 <kmc> lucasicf, no, Person is a new thing you're defining in the "data" decl there
18:19:04 <kmc> lucasicf, code is clearer, and the checker finds more bugs, if you introduce new types rather than using synonyms
18:19:19 <lucasicf> hum
18:19:20 <IceDane> How does newtype play into this? 
18:19:22 <kmc> and using synonyms with big tuples (or with Either) is a sign that you might want a new type declared with "data" instead
18:19:34 <kmc> EvanR, oh, did you mean my example or lucasicf's?
18:19:44 <EvanR> i was wrong
18:20:06 <kmc> "newtype" is *mostly* an optimized, restricted version of "data"
18:20:13 <lucasicf> so using other types/datas inside a new structure it's better to declare a data
18:20:17 <kmc> yeah
18:20:23 <kmc> you can only use "newtype" when you have one constructor with one field
18:20:42 <kmc> its semantics do differ with regard to undefined values
18:21:09 <kmc> if you say «data T = C X» then «⊥» and «C ⊥» are distinguishable
18:21:12 <kmc> with "newtype" they are not
18:21:17 <res> is there any test for whether something is undefined?
18:21:25 <aavogt> the choice between netypes of tuples and data looks arbitrary
18:21:30 <kmc> res, yes, you can catch such exceptions in the IO monad
18:21:33 <kmc> see Control.Exception
18:21:46 <aavogt> provided there was a one-tuple :)
18:21:47 <EvanR> dont test for undefined, this isnt php
18:21:48 <kmc> because the "newtype" optimization is to throw out the type after checking, and equate it to the underlying type
18:22:11 <kmc> yes, if a function can fail in a recoverable way, it should return something like (Maybe T) or (Either String T)
18:22:31 <kmc> less true if you're performing IO -- it's more accepted to use actual exceptions there
18:23:12 <EvanR> exceptional error conditions still isnt 'testing for undefined'
18:23:23 <aavogt> exceptions are qualitatively different
18:24:19 <IceDane> res: Out of curiosity, why would you be testing for undefined?
18:24:56 <IceDane> I'm no expert, but I can't possibly think of a design where exceptions would be easier to deal with than say Maybe or Either
18:25:15 <aavogt> IceDane: Maybe and Either destroy laziness
18:25:24 <IceDane> ah
18:25:26 <IceDane> guess that's true
18:25:50 <EvanR> how?
18:27:00 <aavogt> EvanR: if you substitute   Maybe [a]   for  [a],   and any of the elements of that list may be undefined
18:28:07 <EvanR> im not sure how you mean to substitute Maybe [a] for [a] keeping all else the same
18:28:27 <aavogt> if the list is infinite, to decide whether you'll get a Nothing means forcing the whole list
18:28:37 <EvanR> it does?
18:28:59 <aavogt> well what else is the Nothing case supposed to represent?
18:29:34 <aavogt> EvanR: if you don't force the whole list, you'll get an exception when you force it after matching on the Just
18:29:41 <aavogt> which is the same as having no Maybe
18:30:18 <EvanR> match on Just forces the list?
18:31:02 <EvanR> are we talking about a specific class of expressions resulting in Maybe [a]
18:31:03 <aavogt> EvanR: it does if you want to avoid giving people exceptions when using the items in the list
18:31:30 <aavogt> I mean substituting Maybe [a] for [a]
18:32:02 <aavogt> where the Maybe takes over handling exceptional conditions in the list
18:32:08 <EvanR> ah
18:32:28 <aavogt> there's a middle ground of   [Maybe a]
18:33:08 <EvanR> an infinite list with possible undefineds sounds pretty fishy
18:33:14 <EvanR> they are either there or not
18:33:48 <aavogt> @type interact
18:33:49 <lambdabot> (String -> String) -> IO ()
18:34:06 <EvanR> unsafeInterleaveIO ?
18:34:23 <EvanR> fishy!
18:34:25 <aavogt> also evident in some parsing frameworks
18:34:40 <aavogt> EvanR: compare what parsec does vs what alex does
18:35:06 <EvanR> monadic error handling seems more appropriate
18:35:10 <EvanR> for that
18:35:27 <EvanR> MaybeT
18:35:32 <Axman6> @src interact
18:35:32 <lambdabot> interact f = do s <- getContents; putStr (f s)
18:35:52 <res> how does lambdabot work?
18:35:58 <gwern> very well
18:36:10 <Axman6> @vixen how do you work?
18:36:10 <lambdabot> how? it depends...
18:36:22 <Axman6> as you can see, this is a very deep question
18:36:39 <gwern> res: it might be better to be more specific
18:36:41 <aavogt> EvanR: monads are just going to be a shorthand for things like Maybe
18:36:53 <res> what does it do?
18:37:06 <gwern> what doesn't it do?
18:37:14 <EvanR> im sure everything is shorthand for some form of lambda calculus
18:37:29 <res> is natural language?
18:38:12 <Axman6> > 1 + 1
18:38:13 <lambdabot>   2
18:38:20 <Axman6> > show Nothing
18:38:21 <lambdabot>   "Nothing"
18:38:26 <EvanR> > (+) 1 1
18:38:26 <lambdabot>   2
18:38:33 <Axman6> @type (+)
18:38:34 <lambdabot> forall a. (Num a) => a -> a -> a
18:38:34 <EvanR> > 1 `(+)` 1
18:38:35 <lambdabot>   <no location info>: parse error on input `('
18:39:45 <gwern> res: well, if physics turns out to be computable...
18:39:45 <aavogt> IO is quite special... ghc does imprecise exceptions, which involves randomly choosing among thrown exceptions (right?) which doesn't seem to fit in LC either
18:40:06 <res> gwern: haven't proven it is
18:40:30 <EvanR> screw IO
18:40:36 <Axman6> was that really bad trolling?
18:44:31 <dolio> Linguists use lambda calculus, I think.
18:44:34 <dolio> And continuations.
18:45:02 <EvanR> i didnt know linguistics was recursive
18:45:52 <Adamant> EvanR: lingustics is heavily related to CS via Chomsky and subsequent work
18:45:54 <monochrom> most grammars are modelled as recursion. even though in practice no one really exploits the recursion.
18:46:41 <aristid> monochrom: exploit? grammars are often recursive, or what do you mean?
18:48:02 <monochrom> for example: Sentence ::= "you are nice" | "I think that " Sentence.  But no one really exploits it to the point of "I think that I think that I think that you are nice". There is a consensual bound on how many times or how deep people recurse.
18:48:55 <EvanR> an perish the thought of infinite recursion
18:51:26 <shachaf> fix "I think that "
18:52:02 <Adamant> mathematics and splitoff fields are the language of recursion, for better or worse.
18:57:09 <mm_freak> there are two approaches to a Cont monad:
18:57:10 <lambdabot> mm_freak: You have 1 new message. '/msg lambdabot @messages' to read it.
18:57:24 <mm_freak> 1. newtype Cont r a = Cont ((a -> r) -> r)
18:57:32 <mm_freak> 2. newtype Cont a = forall r. Cont ((a -> r) -> r)
18:57:45 <mm_freak> what are the respective advantages/disadvantages?
18:58:44 <monochrom> I don't know how to use the 2nd one. "help! I'm trapped in the Cont monad"
18:59:04 <mm_freak> monochrom: just like the first…  i haven't found any difference so far
18:59:38 <dolio> The second one is the identity monad.
18:59:39 <mm_freak> ManateeLazyCat: i'm planning to continue my work on fastirc soon, so you can expect new releases, but i don't want to promise any specific date
19:00:23 <monochrom> how to implement runCont?
19:00:33 <ManateeLazyCat> mm_freak: Great.
19:00:35 <mm_freak> hmm, i see it now
19:00:41 <mm_freak> i can't refer to 'r'
19:00:57 <ManateeLazyCat> mm_freak: Can you support SSL in fastirc? 
19:01:08 <monochrom> you are trapped in the Cont monad too :)
19:01:09 <mm_freak> ManateeLazyCat: certainly
19:01:29 <mm_freak> ManateeLazyCat: the infrastructure to allow different kinds of network connections is already there…  i just need to use it
19:01:39 <mm_freak> monochrom: yes =)
19:01:44 <ManateeLazyCat> mm_freak: Ok, i'm waiting your new version. :)
19:01:47 <copumpkin> does that mean that Codensity Identity == Identity?
19:01:59 <ManateeLazyCat> mm_freak: BTW, newest client base on fastirc : http://www.flickr.com/photos/48809572@N02/5058936665/lightbox/ :)
19:02:29 <copumpkin> oh wait, Codensity is universal
19:02:34 <copumpkin> mm_freak's is existential
19:02:43 <mm_freak> if we had first class type functions, i could make the second type of the Cont monad, right?
19:02:45 <ManateeLazyCat> mm_freak: I plan to add SSL in my irc client, but i think build it in fastirc is better idea. :)
19:02:56 <mm_freak> type Cont a = forall r. (a -> r) -> r
19:03:11 <copumpkin> mm_freak: the second one isn't equivalent to that
19:03:32 <Apocalisp> what's the difference between mapAccumL and mapAccumR?
19:03:36 <copumpkin> newtype Cont a = forall r. Cont ((a -> r) -> r)
19:03:37 <copumpkin> newtype Cont a = Cont (forall r. (a -> r) -> r)
19:03:57 <mm_freak> copumpkin: what's the difference?
19:03:59 <copumpkin> actually neither of them can be newtypes
19:04:01 <mm_freak> practically, i mean
19:04:14 <copumpkin> mm_freak: in the first one, the r is existential
19:04:18 <copumpkin> in the second, it's universal
19:04:26 <mm_freak> i see
19:04:30 <copumpkin> or rather, the r on the _constructor_ Cont is universal
19:04:34 <copumpkin> meaning it's an existential type
19:04:47 <copumpkin> (since you can pass the constructor any type for r)
19:05:20 <mm_freak> i'm asking because the types in contstuff take a lot of parameters, and i wondered whether i can eliminate some of them
19:05:30 <mm_freak> ChoiceT r i m a
19:05:32 <copumpkin> mm_freak: you should check out codensity though
19:06:01 <copumpkin> http://wwwtcs.inf.tu-dresden.de/~voigt/mpc08.pdf
19:06:16 <mm_freak> copumpkin: from what i've seen i don't see any difference between codensity and ContT
19:06:24 <mm_freak> or Ran, for that matter
19:06:26 <monochrom> contstuff implements everything upon Cont, so everyone gets and extra "r". but that should be it.
19:06:32 <monochrom> s/and/an/
19:06:38 <copumpkin> ContT shouldn't be universal over the continuation monad parameter
19:07:02 <dolio> forall r. ((a -> r) -> r) is isomorphic to a.
19:07:14 <dolio> So defining it that way is the identity monad.
19:07:23 <copumpkin> dolio: his original one was existential though
19:07:48 <dolio> Oh, so it is. In that case, you can't run it.
19:07:50 <copumpkin> yeah
19:07:58 <mm_freak> monochrom: that's intentional, and i wouldn't know how to do it otherwise
19:07:59 <ManateeLazyCat> Has any haskell library binding to libchm (http://www.jedrea.com/chmlib/) already? I want to do, but ask to avoid duplicate work. :)
19:08:39 <mm_freak> copumpkin: i'll check out that paper…  i hope it doesn't require too much CT background, because i don't have it =)
19:08:54 <dolio> exists r. ((a -> r) -> r) is isomorphic to (), I think.
19:08:55 <copumpkin> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
19:08:55 <copumpkin> newtype Codensity m a = Codensity { runCodensity :: forall b. (a -> m b) -> m b }
19:09:06 <copumpkin> mm_freak: don't worry, neither do I :P
19:10:13 <copumpkin> mm_freak: codensity is interesting cause you can make it a Monad instance without the m even being a Functor
19:11:12 <mm_freak> copumpkin: you can do that with most operations on ContT, too
19:11:52 <mm_freak> in fact, ContT is a monad without m being a functor
19:12:11 <dolio> ContT r m has effects that Codensity m does not.
19:12:26 <mm_freak> dolio: like?  callCC?
19:12:29 <dolio> Yes.
19:12:37 <mm_freak> oh, actually i want those
19:13:01 <dolio> Codensity m is in some sense equivalent to m, as a monad.
19:13:15 <mm_freak> so it just improves efficiency?
19:13:22 <dolio> Potentially.
19:13:37 <mm_freak> well, i don't see how it could /decrease/ it
19:14:05 <dolio> Extra shuffling when the underlying monad is already efficient?
19:14:25 <dolio> I wouldn't be surprised if Codensity (Codensity (Codensity m)) is less efficient than Codensity m.
19:14:50 <dolio> In some cases, at least.
19:15:02 <Saizan> also, it's not always the best choice to get everything associated to the right
19:15:21 <mm_freak> hmm, i see
19:15:27 <mm_freak> but that's an implementation detail, right?
19:15:48 <djahandarie> Everything is an implementation detail!
19:15:51 <mm_freak> more specifically compiler implementation
19:16:53 <mm_freak> or in other words:  there exists a compiler, with which 'Codensity m' cannot be less efficient than 'm'
19:18:22 <Maxdamantus> jw, if one was to look at this fragment of something, what would one guess it is? f -> t -> t@(a,b) -> f a b
19:18:52 <Saizan> view pattern?
19:19:09 <Saizan> so a case expression i guess
19:19:49 <Maxdamantus> (It's not Haskell)
19:19:50 <Saizan> or maybe a lambda
19:20:03 <Maxdamantus> Maybe.
19:22:51 <Philippa> Maxdamantus: my first read is to interpret the @ the same way as it works in haskell patterns, so t=(a,b)
19:23:07 <Philippa> and assume it's a type
19:24:09 <Philippa> but that doesn't make sense for haskell
19:24:19 <Philippa> (f clearly can't kind-check)
19:26:47 <nus> parameterized types?
19:28:17 <FunctorSalad> puzzling :) given the kindcheck issue
19:29:27 <FunctorSalad> the duplication of 't' kinda foils the interpretation as the dependent type "forall f t t, f (fst t) (snd t)" too
19:31:26 <copumpkin> Maxdamantus: what is it?
19:31:31 <ddarius> Google Desktop works again, and I have a mere 5,677 papers.
19:31:37 <copumpkin> ddarius: have you read them all?
19:31:44 <Maxdamantus> uncurry in an odd language.
19:32:06 <copumpkin> Maxdamantus: which one?
19:32:21 <ManateeLazyCat> ddarius: Open FTP? :)
19:32:23 <Maxdamantus> Hm. @ would be similar to Haskell's "case"
19:32:38 <Maxdamantus> copumpkin: something I'm inventing/implementing.
19:32:44 <copumpkin> Maxdamantus: ah okay :)
19:32:50 <copumpkin> I was going to guess a pi type of some sort
19:32:50 <Philippa> why is it f -> t-> t@(a,b) -> ... rather than f -> t@(a,b) -> ... ?
19:32:56 <copumpkin> but the duplication of the t was throwing me off
19:33:00 <Maxdamantus> (It just doesn't do matching yet)
19:33:20 <Maxdamantus> Philippa: the @ isn't like @ in Haskell.
19:33:21 <ManateeLazyCat> ddarius: Can you share the papers you collect? ;p
19:33:31 <Maxdamantus> But I'd probably make it so that would work too, without the t@
19:33:35 <Philippa> Maxdamantus: well no, but I suspect the -> isn't too
19:33:47 <Maxdamantus> -> is sort of
19:34:07 <Maxdamantus> Lambdas look pretty much the same (aside from pattern matching) other than that they don't have the \
19:34:13 <Maxdamantus> (Which seems to be redundant)
19:34:34 <copumpkin> yeah, I'm not a fan of the \
19:34:37 <copumpkin> or even a real lambda
19:34:54 <Philippa> it's not quite redundant, though it does save parens occasionally
19:35:25 <Maxdamantus> Hm. Maybe in other uses of ->?
19:35:47 <FunctorSalad> \x y -> ... vs. x (\y -> ...)
19:35:49 <Philippa> yeah, it's the use after the pattern-match that's confusing to me
19:35:51 <ddarius> ManateeLazyCat: I got all of them from the internet.
19:35:57 <Maxdamantus> You can do that?
19:36:05 <Maxdamantus> Oh.
19:36:18 <FunctorSalad> hmm though I think x \y -> ... isn't legal anyway ;)
19:36:53 <Philippa> FunctorSalad: depends on the lang, but obviously you'd need parens if x has another parm
19:37:28 <Maxdamantus> It doesn't do multi-argument reduction stuff, and won't, for simplicity.
19:37:42 <ManateeLazyCat> ddarius: Yep, if you share them on some place (e.g. Google Docs), then save much time to search them again. :)
19:38:05 <Philippa> Maxdamantus: huh? The only added complexity's in the parser anyway
19:38:15 <ManateeLazyCat> ddarius: I just have 313 papers about Haskell. :)
19:38:44 <Maxdamantus> Yeah, but it's such little syntactic overhead, with the \ missing.
19:39:34 <Maxdamantus> a -> b -> a + b vs a b -> a + b
19:39:58 <Philippa> occasionally it's useful to highlight particular clumping of parameters though. Parsec's got a good use case for doing that
19:40:38 <Philippa> it's got functions where it does a bunch of stuff in response to some parameters without having demanded the others yet
19:42:43 <Maxdamantus> Hm. There's a partial and messy implementation of it in JS at http://ntus.uni.cc/ll if anyone's interested
19:42:50 <dolio> (x : A) → Σ B \x → T x     (x : A) → Σ B x → T x
19:42:58 * Maxdamantus wants to make a self-hosted implementation, if it gets usable.
19:43:34 <copumpkin> dolio: variable overlap?
19:44:03 <dolio> Those are two different types.
19:44:25 <dolio> I added the overlap so one wouldn't necessarily be an error.
19:44:31 <copumpkin> the second one wouldn't typecheck would it?
19:44:38 <copumpkin> I guess you could change A to be B -> Set or something
19:44:43 <dolio> Depends on what A and T are.
19:44:51 <FunctorSalad> ban shadowing :o
19:45:19 <dolio> I wouldn't expect them to both be valid for the same A, B and T.
19:45:26 <FunctorSalad> (is there some good argument against it?)
19:45:43 <dolio> Against what?
19:45:56 <FunctorSalad> outlawing shadowing in general, like C# does
19:46:23 <dolio> Shadowing isn't the problem.
19:46:44 <kmc> Maxdamantus, when i make a type error like «(2,3)+4» it prints out a function value
19:46:46 <kmc> why?
19:46:57 <Maxdamantus> Heh.
19:46:58 <FunctorSalad> (well, except of fields vs local variables... but at least it won't let you make local variables shadow each other)
19:47:06 <Maxdamantus> It's dynamically typed.
19:47:20 <FunctorSalad> dolio: not the core problem, but as you said, it's required for both to be legal
19:47:32 <Maxdamantus> and the operators atm don't do any sort of runtime checking either, other than what JS does.
19:47:47 <dolio> If lambdas are 'v -> e', what is 'A → Σ B (x → T x)'? The problem is the same as having (a, b) be the type of (x, y) when x : a and y : b.
19:48:06 <kmc> so how do the rules of javascript result in you writing out a function's text at a type error?
19:48:20 <Maxdamantus> Ah.
19:48:34 <Maxdamantus> Hm.
19:48:47 <Maxdamantus> Because + in JS works for string concatenation.
19:48:49 <dolio> And of course, the initial \ lets you get rid of parens there.
19:49:02 <Maxdamantus> and tuples are represented by arrays of values
19:49:13 <Maxdamantus> and values are functions that take no argument (to allow for laziness)
19:49:27 <EvanR> js needs pattern matching
19:49:28 <dolio> Since Agda doesn't have Haskell's restrictions about requiring an infix operator.
19:49:29 <kmc> so in JS, + on a function coerces it to a string first?
19:49:31 <Maxdamantus> So it's probably converting some unevaluated value to a string
19:49:37 <Maxdamantus> then concatenating "4"
19:49:59 <kmc> eeew js
19:50:01 <Maxdamantus> Yeah, notice the 4 at the end of the output.
19:50:09 <kmc> yup
19:50:17 <EvanR> '4' + 4 -> '44'
19:50:22 <EvanR> '4' + 4 -> 8
19:50:32 <Maxdamantus> This is just a hacky implementation until it's powerful enough to compile a better compiler.
19:50:32 <EvanR> guess the dynamic language
19:50:38 <Maxdamantus> and prototype
19:50:39 <dolio> Even if it did: e1 $ \x -> e2     e1 $ x -> e2
19:50:54 <kmc> Maxdamantus, you already implemented a parser in Javascript?
19:51:03 <Maxdamantus> Yes.
19:51:11 <kmc> are there any good libraries for that?
19:51:19 <Maxdamantus> Not afaik
19:51:24 <manateeUser> Maxdamantus: Hackage package?
19:51:28 <Maxdamantus> I just used a for loop with a switch O_o
19:51:40 <Maxdamantus> Along the string, to tokenise it
19:51:49 <kmc> then it sounds like implementing the parser in Javascript would be harder than implementing the whole thing in Haskell
19:51:49 <EvanR> ah tokenize 
19:51:51 <Maxdamantus> Then another function to take the tokens and create a tree
19:51:57 <kmc> how's that one work?
19:51:58 <Maxdamantus> and then another to convert a tree into JS
19:52:06 <Maxdamantus> and then another to evaluate the generated JS
19:52:47 <EvanR> i get ridiculed when i mention compiling a nice language to javascript
19:52:54 <Maxdamantus> I don't know Haskell well enough yet to do rapid programming in it :(
19:52:55 <EvanR> 'just use js, its awesome'
19:53:11 <kmc> EvanR, Javascript is awesome, it has this amazing new feature called first-class functions
19:53:21 <EvanR> yeah it does
19:53:32 <EvanR> good idea that
19:53:55 <monochrom> just don't forget to add "return" everywhere
19:54:04 <EvanR> i did forget that for a long time
19:54:11 <EvanR> of course its not a bug to forget it
19:54:17 <EvanR> and may not even cause adverse effects
19:54:50 <ddarius> Maxdamantus: Lambda calculus is boring.  http://www.pps.jussieu.fr/%7Ekesner/papers/fcp.pdf  read and implement.
19:54:52 <EvanR> dynamic languages are absolutely insane
19:54:56 <monochrom> (\x -> \y -> f y x) = function(x) { return function(y) { return f(y,x); }; }
19:55:02 <danharaj> dynamic languages are only as insane as you are
19:55:07 <EvanR> exactly
19:55:15 <danharaj> it's static languages that define exactly how insane they are ;)
19:55:33 <monochrom> all languages define how insane you are
19:55:39 <Maxdamantus> dynamic = dynamically typed?
19:55:52 <FunctorSalad> "I liked lambda calculus before it became successful" :)
19:56:06 <EvanR> omission of compile time safety checks i suppose
19:56:08 <Maxdamantus> Well, it's not really lambda calculus
19:56:22 <Maxdamantus> But obviously it's got constructs that are based off it
19:56:22 <aristid> monochrom: wouldn't it be (\x -> \y -> f y x) = function(x) { return function(y) { return (f(y))(x); }; } ?
19:56:25 <Maxdamantus> Like Haskell does
19:56:33 <monochrom> that too
19:57:05 <Maxdamantus> aristid: add in laziness and you have to have function(){} wrapping lots of stuff
19:57:10 <kmc> there's a difference between "dynamically typed" and "let's try every unlikely implicit conversion until one works"
19:57:20 <Maxdamantus> http://ntus.uni.cc/ll.indent
19:57:37 <FunctorSalad> kmc: with backtracking! \o/
19:57:50 <FunctorSalad> (new language idea)
19:57:56 <EvanR> function($x) use ($f) { return function($y) use ($x,$f) { return ($f($y))($x); } }
19:58:06 <kmc> haha FunctorSalad
19:58:08 <aristid> kmc: if you really want, you can do "let's try every unlikely implicit conversion until one works" in haskell :D
19:58:13 <kmc> just crazy enough to work
19:58:31 <aristid> EvanR: what syntax is that?
19:58:35 <EvanR> php5
19:58:51 <aristid> EvanR: um wtf
19:59:11 <aristid> EvanR: they managed to have a worse syntax than c++0x
19:59:18 <alexsuraci> it's php
19:59:19 <EvanR> yes
19:59:30 <kmc> what's this "use"
19:59:35 <EvanR> closure
20:00:16 <mm_freak> EvanR: php 5.3
20:00:20 <EvanR> 5.3
20:00:34 <aristid> death to php, but i'm preaching to the choir
20:00:36 <kmc> i don't get it
20:00:44 <EvanR> php does not have lexical scope
20:00:47 <Saizan> oh god, another language where scoping is so fucked up you've to declare the variables you're closing over?
20:00:50 <FunctorSalad> apparently it's declaring the variables to closure over
20:00:56 <mm_freak> kmc: in PHP you need to be explicit about what's the closure
20:01:06 <kmc> oh, those are the free variables?
20:01:10 <EvanR> yes
20:01:11 <mm_freak> yeah, in a sense
20:01:12 <kmc> ok so it is like C++1x
20:01:17 <monochrom> they just haven't thought of declaring the types
20:01:28 <FunctorSalad> ungrateful kids :D surely much better than no closures if you have to use php
20:01:48 <kmc> i don't think declaring free variables is so crazy
20:01:53 <erikc> in c++1x's case the reason you need to specify is to distinguish between value and reference capture
20:02:06 <erikc> and that's subtle enough that it's best to be explicit
20:02:40 <monochrom> you need the distinction because of mutable variables only. death to mutable variables.
20:02:52 <kmc> you need it in C++1x because of memory management as well
20:03:01 <FunctorSalad> erikc:  yeah, that actually makes sense if your language is crazy enough to have mutable variables by default in the first place ;)
20:03:10 <aristid> yeah, c++ does a lot of painful things to avoid GC
20:03:31 <monochrom> death to every language
20:03:43 <FunctorSalad> (got bitten by closuring over a "foreach"-loop variable in C#...)
20:04:11 <aristid> FunctorSalad: that sounds funny
20:04:12 <danharaj> I have gotten to the point where I think Haskell is an unsafe language because it does not statically rule out divide by zeroes.
20:04:24 <danharaj> Makes me nervous to use floats :|
20:04:33 <Luke> is there an easy way to apply one argument to two functions using point free form?
20:04:33 <aristid> danharaj: Double is quite unsafe in general
20:04:40 <RyanT5000> what's the name of that extension where you can implement typeclasses directly in terms of sum and product types? I think it uses :+: and :*: or something similar
20:04:46 <kmc> RyanT5000, -XGenerics
20:04:48 <EvanR> NaN is your friend
20:04:56 <FunctorSalad> aristid: like "foreach (var x in xs) result.Add(y=>f(x,y))"...
20:04:58 <kmc> Luke, like this?
20:04:58 <RyanT5000> kmc: thanks
20:05:01 <kmc> > (succ &&& show) 3
20:05:02 <lambdabot>   (4,"3")
20:05:03 <Luke> instead of applying the argument to both functions explicitly
20:05:15 <Luke> kmc: yes thanks!
20:05:22 <aristid> FunctorSalad: how did you end up solving it?
20:05:26 <kmc> (&&&) from Control.Arrow
20:05:52 <FunctorSalad> aristid: "foreach (var x in xs) { var x_copy = x; result.Add(y=>f(x_copy,y)); }" :)
20:05:54 <copumpkin> what, Generics is a LANGUAGE options?
20:05:55 <copumpkin> -s
20:06:06 <aristid> FunctorSalad: ok that makes sense. annoying tho
20:06:08 <copumpkin> is that where the evil 1 came from?
20:06:26 <copumpkin> :k Mu ((:+:) 1)
20:06:28 <lambdabot> *
20:07:02 <aristid> :k 1
20:07:03 <lambdabot> *
20:07:07 <aristid> :k Mu
20:07:08 <lambdabot> (* -> *) -> *
20:07:28 <aristid> hmm kinds with parens are unusual
20:07:29 <EvanR> values have a kind?
20:07:38 <copumpkin> EvanR: that's why it's evil
20:07:39 <aristid> EvanR: no. 1 is also a type
20:07:51 <aristid> :t undefined :: 1
20:07:52 <lambdabot> Unit
20:07:57 <aristid> EVIL
20:08:01 <EvanR> o_O
20:08:17 <aristid> i want -XOneIsNoType
20:08:22 <alexsuraci> :t undefined :: 2
20:08:23 <lambdabot> Only unit numeric type pattern is valid
20:08:23 <Luke> kmc: that's actually not it. I'm looking for something that lets p1, p2 :: a -> Bool; in \a -> (p1 a) && (p2 a)
20:08:36 <Luke> where I don't have to send the a to both p1 and p2
20:08:39 <dolio> > Unit :: 1
20:08:39 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
20:08:40 <lambdabot>    arising from a use of ...
20:08:40 <kmc> uncurry (&&) . (p1 &&& p2)
20:08:44 <EvanR> this is some most delicious esoteric haskell knowledge
20:09:16 <Luke> kmc: thanks
20:09:23 <FunctorSalad> clearly 2 should be 1 :+: 1
20:09:26 <kmc> aristid, not that unusual, every monad transformer has a "higher-order" kind
20:09:37 <kmc> how is 1 also a type?
20:09:43 <EvanR> FunctorSalad: no, brain explode!
20:09:49 <kmc> woah it's really allowed
20:09:50 <Saizan> liftA2 (&&) too
20:09:55 <aristid> :k ContT
20:09:56 <lambdabot> * -> (* -> *) -> * -> *
20:10:09 <kmc> oh, right
20:10:21 <kmc> Saizan's solution is better
20:11:05 <aristid> :t \p1 p2 -> uncurry (&&) . (p1 && p2)
20:11:06 <lambdabot>     Couldn't match expected type `f (Bool, Bool)'
20:11:06 <lambdabot>            against inferred type `Bool'
20:11:06 <lambdabot>     In the second argument of `(.)', namely `(p1 && p2)'
20:11:11 <aristid> :t \p1 p2 -> uncurry (&&) . (p1 &&& p2)
20:11:12 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a, Functor (a b)) => a b Bool -> a b Bool -> a b Bool
20:11:36 <aristid> :t \p1 p2 -> uncurry (&&) <<< (p1 &&& p2)
20:11:37 <lambdabot> forall a. (a -> Bool) -> (a -> Bool) -> a -> Bool
20:12:24 <FunctorSalad> the general idea of defining a function by induction over sum and product sounds nice
20:12:35 <FunctorSalad> but iirc there were some rather heavy restrictions
20:13:52 <FunctorSalad> hmm think I'm repeating myself
20:14:09 <FunctorSalad> (from some months ago, but anyway)
20:16:45 <aristid> :t (>>^ uncurry (&&))
20:16:46 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => a b (Bool, Bool) -> a b Bool
20:17:42 <aristid> :t \a b -> a &&& b >>^ uncurry (&&)
20:17:43 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => a b Bool -> a b Bool -> a b Bool
20:20:27 <TeachmeHaskell> Hello folkz
20:20:52 <Axman6> 'lo
20:21:35 <aristid> @let arr2 = arr . uncurry
20:21:36 <lambdabot>  Defined.
20:22:10 <gwern> arr!
20:22:18 <gwern> piraskell
20:22:27 <gwern> the language of choice for the discerning rascall
20:22:29 <copumpkin> @arr
20:22:30 <lambdabot> I'll crush ye barnacles!
20:22:40 <TeachmeHaskell> lol
20:22:42 <Axman6> :t arr2
20:22:43 <lambdabot> forall a1 b c (a :: * -> * -> *). (Arrow a) => (a1 -> b -> c) -> a (a1, b) c
20:31:45 <kmc> :t (>>^)
20:31:46 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> (c -> d) -> a b d
20:32:02 <kmc> :t (>^>)
20:32:03 <lambdabot> Not in scope: `>^>'
20:32:24 <kmc> :t (ಠ_ಠ)
20:32:25 <lambdabot> parse error on input `)'
20:36:04 <aristid> kmc: i think a >>^ b = a >>> arr b
20:36:14 <aristid> :t \a b -> a >>> arr b
20:36:16 <lambdabot> forall (cat :: * -> * -> *) a b c. (Arrow cat) => cat a b -> (b -> c) -> cat a c
20:37:38 <pumpkin> :t arr arr
20:37:39 <lambdabot> forall b c (a :: * -> * -> *) (a1 :: * -> * -> *). (Arrow a, Arrow a1) => a1 (b -> c) (a b c)
20:38:12 <pumpkin> :t arr arr arr
20:38:12 <lambdabot> forall (a :: * -> * -> *) b c (a1 :: * -> * -> *). (Arrow a, Arrow a1) => a (b -> c) (a1 b c)
20:38:16 <pumpkin> :t arr arr arr arr
20:38:17 <lambdabot> forall (a :: * -> * -> *) b c (a1 :: * -> * -> *). (Arrow a, Arrow a1) => a (b -> c) (a1 b c)
20:38:57 <aristid> :t arr
20:38:58 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
20:39:21 <pumpkin> :t iterate arr
20:39:21 <aristid> :t arr :: (b -> c) -> (b -> c)
20:39:21 <lambdabot> forall b c. (b -> c) -> [b -> c]
20:39:22 <lambdabot> forall b c. (b -> c) -> b -> c
20:40:07 <aristid> :t arr id
20:40:08 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
20:40:12 <aristid> :t arr id id
20:40:13 <lambdabot> forall a. a -> a
20:40:21 <aristid> :t arr id arr
20:40:23 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
20:40:53 <aristid> :t arr arr id
20:40:54 <lambdabot> forall c (a :: * -> * -> *). (Arrow a) => a c c
20:45:13 <FunctorSalad> "In this case, the container has to be taken to a factory where it allows a robotic arm of the factory to plug into a receptacle it provides" <-- guess the genre!
20:45:50 <FunctorSalad> (not saying it's a bad tutorial, but found it funny :))
20:52:27 <tehgeekmeister> how do i get ghc to output type signatures for all my functions i have not explicitly typed?
20:52:37 <tehgeekmeister> (always forget, can never find it in the docs)
20:52:59 <pumpkin> I didn't even know that was possible
20:53:14 <pumpkin> you can probably dump the .hi file somehow, if it isn't
20:54:07 <tehgeekmeister> can't load the files in ghci D=
20:54:22 <tehgeekmeister> they compile, but ghci doesn't like the c libraries they're linked to
20:57:11 <lispy> hey, haskellers.com is down?
20:57:22 <djahandarie> I signed up for that today!
20:57:25 <tehgeekmeister> lispy: what's that?
20:57:41 <djahandarie> A place where Haskellers can make their profile
20:57:44 <lispy> http://www.haskellers.com/user/42/
20:58:12 <lispy> tehgeekmeister: it's a social networking site for your haskell community identity
20:58:15 <tehgeekmeister> great advertisement for yesod's database handling.  =P
20:58:50 <djahandarie> I wouldn't call ti "social networking" really
20:58:57 <djahandarie> There aren't many ways to socialize on it
20:59:56 <kmc> tehgeekmeister, -Wall
21:00:04 <tehgeekmeister> kmc: didn't do it.
21:00:11 <tehgeekmeister> oh wait
21:00:16 <tehgeekmeister> i forgot to pass that to cabal
21:00:17 <tehgeekmeister> right
21:00:44 <JoeyA> An example of how Haskell is leaking into my Humanities schoolwork:  "Finding modern parallels to this requires finding instances where the demographics of race and religion are substantially altered, or ideas and art are lost forever, because one people group uses superior power against another people group to intentionally suppress the lesser group's race or religion."
21:01:01 <kmc> Wall always and forever
21:01:33 <tehgeekmeister> i love Wall
21:01:38 <tehgeekmeister> i should put it in my projects cabal file
21:01:54 <kmc> yup
21:02:06 <kmc> you can enable -Wall in Cabal and then disable individual warnings on individual files, if necessary
21:02:08 <tehgeekmeister> it's already in there?
21:02:23 <kmc> (but you can't disable them on individual occurrences :/)
21:02:25 <tehgeekmeister> but it didn't show the type signatures for certain functions that don't have explicit ones.
21:02:41 <kmc> tehgeekmeister, at top level?
21:02:43 <tehgeekmeister> it's okay, i've traced down the specific signature i care about anyway
21:02:45 <tehgeekmeister> kmc: yep
21:02:45 <kmc> did it recompile that file?
21:02:57 <tehgeekmeister> i cleaned and rebuilt
21:03:01 <kmc> odd
21:03:20 <tehgeekmeister> i find odd ghc behavior more often than it just works, somehow
21:03:26 <tehgeekmeister> (i probably do a lot of stuff wrong.)
21:05:06 <tehgeekmeister> kmc: nevermind.  this time it worked.
21:05:14 <tehgeekmeister> i probably just didn't look at enough of the output of ghc before.
21:09:05 <ddarius> "Programming Languages: Theory and Practice" was a book I was looking for recently.
21:10:03 <tehgeekmeister> why does it give warnings about redundant imports on files i didn't explicitly import?
21:10:35 <tehgeekmeister> well, files i didn't explicitly import twice
21:12:30 <aristid> tehgeekmeister: because you don't use the import
21:13:46 <tehgeekmeister> oh, cool
21:23:40 <EvanR> whats the preferred way to use this damned Control.Exception stuff, to specify the type of exceptions to catch, use -XScopedTypeVariables or what?
21:28:19 <kmc> foo `catch` (\(e :: MyException) → ...)
21:28:28 <kmc> does that need -XScopedTypeVariables?
21:29:30 <kmc> it's enabled by PatternSignatures but that extension is "deprecated in favor of ScopedTypeVariables"
21:29:38 <kmc> i don't see what the situation has to do with scoped type variables though
21:30:26 <EvanR> compiler says so
21:35:07 <EvanR> illegal signature in pattern MyException
21:35:41 <EvanR> use pattern signatures?
21:35:52 <pumpkin> kmc: yeah, never figured the merging of the two of them
21:36:10 <kmc> apparently Hugs used pattern signatures to introduce scoped type variables
21:36:19 <kmc> but GHC doesn't now?
21:36:21 * kmc shrugs
21:42:37 <helpme> need homework help(writing) pm me to help, its simple but i have writers block
21:42:49 <EvanR> (\e -> f (show e)) :: MyException -> IO ()
21:42:50 <EvanR> got it
21:42:51 <EvanR> ;)
21:43:03 <EvanR> is there a way to get a source file and line number too
21:44:41 <pumpkin> turn on CPP
21:44:45 <pumpkin> and write a macro to do it :)
21:45:50 <EvanR> smooth ;)
21:46:31 <EvanR> i dont have any user exceptions
21:56:43 <republican_devil> lets talk continuations and web services, anyone running a haskel powered dyanmic site?
21:57:12 <aristid> :t \f -> ((\e -> f (show e)) :: Int -> IO ())
21:57:13 <lambdabot> (String -> IO ()) -> Int -> IO ()
21:57:14 <kmc> http://hpaste.org/ is haskell powered, link at the bottom
21:57:21 <kmc> (source link)
21:59:29 <atude> Hi, I have a question concering coins.. If you have a set of bags, 9 in total, each containing 10 coins and 9 different colors where each coin weighs 10 gram and there exists a coin that weighs 9grams; what is the minimal amounts of weighings on the scale or steps you'd have to perform to determine where the false coin is?
21:59:34 <atude> I'd come up with 3 minimum using a binary split, but... the answer is 1..
22:00:33 <republican_devil> http://lib.store.yahoo.net/lib/paulgraham/bbnexcerpts.txt this is a great read.
22:00:38 <republican_devil> inspiring
22:02:32 <Axman6> atude: the minimum? well it would be 1, meaning you weighed two bags, and one had the fake coin, so you got lucky on the first try
22:02:41 <aristid> doesn't mean that continuations are a good way of making web services
22:03:32 <atude> Axman6: yes, I've got this too
22:03:37 <atude> thank you very much
22:03:37 <atude> :)
22:20:32 <Lambo> I'm a first time chatter, short time lurker and I was wondering if someone could help. I'm helping with a Computer Science trivia night and was hoping one of you excellent chaps could suggest a good Haskell trivia questions?
22:21:08 <kmc> atude, it's actually 0.  evidence for precognitive / psychic abilities is well documented in the scientific literature
22:21:55 <kmc> Lambo, what sort of thing are you looking for?
22:22:02 <atude> that's irrelivent
22:22:08 <kmc> how hard, how trivial
22:22:56 <Lambo> kmc, some trivia about haskell itself, or a short coding question (like find the bug in this code or something)
22:23:15 <monochrom> find the bug in this code:
22:23:26 <Axman6> int main(){
22:23:27 <Axman6> ...
22:23:29 <Axman6> }
22:23:30 <Axman6> >_>
22:23:34 <EvanR> wth kmc 
22:23:44 <Axman6> The bug is that it isn't Haskell :)
22:23:46 * kmc greps logs for "trivia "
22:24:00 <EvanR> is this coast to coast AM now, or ##not-physics
22:25:23 * kmc greps logs for "trivia[^l]"
22:25:36 <kmc> @quote trivia
22:25:36 <lambdabot> Cale says: But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
22:25:39 <kmc> <augustss> And just a bit of trivia:  Mikael Rittri named the Either type.
22:26:34 <dolio> f p = let (x:xs, y) = p in y, what is f ([], 7)?
22:26:55 <monochrom> a value
22:27:00 <dolio> What value?
22:27:30 <Lambo> dollo, that's a pretty cool one
22:27:42 <kmc> 09.10.07 04:08:48 <SamB_XP> freaky trivia: (\x y -> f x y) is apparently different from (\x -> \y -> f x y) in some way ...
22:27:46 <kmc> 09.10.07 04:09:19 <ski> SamB_XP : only if `y' was a refutative pattern, iirc ?
22:27:46 <Lambo> dolio *, that's a pretty cool one
22:29:39 <Lambo> kmc, wow I think we could stump quite a few people with that one!
22:30:55 <Axman6> > f p = let (x:xs, y) = p in y in f ([], 7)
22:30:55 <lambdabot>   <no location info>: parse error on input `='
22:31:05 <Axman6> > let f p = let (x:xs, y) = p in y in f ([], 7)
22:31:06 <lambdabot>   *Exception: <interactive>:1:151-163: Irrefutable pattern failed for pattern...
22:31:13 <Axman6> > let f p = let ~(x:xs, y) = p in y in f ([], 7)
22:31:14 <lambdabot>   *Exception: <interactive>:1:151-164: Irrefutable pattern failed for pattern...
22:31:24 <Axman6> > let f p = let ~(~(x:xs), y) = p in y in f ([], 7)
22:31:25 <lambdabot>   7
22:31:33 <Axman6> > let f p = let !(~(x:xs), y) = p in y in f ([], 7)
22:31:34 <lambdabot>   7
22:31:35 <Axman6> >_>
22:32:28 <Axman6> > let f p = let !(~(!x:xs), y) = p in y in f ([], 7)
22:32:28 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
22:32:35 <Axman6> :|
22:33:46 <ddarius> How did !(...,y) work then ?
22:34:15 <ddarius> > let !x = 3 in 1
22:34:16 <lambdabot>   1
22:34:17 <dolio> GHC allows ! in let bindings, I think.
22:34:27 <ddarius> For what?
22:34:30 <dolio> At the top, that is.
22:34:50 <dolio> Well, unboxed types are required to be bound as 'let !x = ...'.
22:34:58 <dolio> @k Int#
22:34:58 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . ? @ v
22:35:03 <ddarius> Okay, I thought it was that.
22:35:03 <dolio> @kind Int#
22:35:04 <lambdabot> Not in scope: type constructor or class `Int#'
22:35:45 <Axman6> @kind I#
22:35:45 <lambdabot> Not in scope: type constructor or class `I#'
22:35:51 <Axman6> @src Int
22:35:51 <lambdabot> data Int = I# Int#
22:35:52 <pumpkin> :t I#
22:35:53 <lambdabot> Not in scope: data constructor `I#'
22:36:28 * pumpkin got dolio's trivia question right by simply remembering "oh shit that's the case where it doesn't behave the way I'd expect it to"
22:36:58 <pumpkin> what better mnemonic!
22:42:07 <kmc> @keal
22:42:07 <lambdabot> when i put what i dat recoved from that tile into a ti92. the damn thing blew up
22:42:47 <kmc> congratulations «!(~(!x:xs), y)» you are the Pattern of the Day
22:43:16 * Axman6 wins!
22:47:36 <Lambo> I think I'll use the 'let f p = let !(~(x:xs), y) = p in y' question.
22:48:01 <pumpkin> not sure I'd call that trivia as much as "wtf"
22:48:03 <Lambo> Thanks a lot everyone! I better get back to organising, only an hour to go before we start :S
22:48:16 <Lambo> Well, we need at least ONE wtf question
22:48:40 <pumpkin> I'd also leave it without the ! and ~
22:48:47 <pumpkin> it's plenty wtf-worthy without them
22:49:18 <Lambo> Hmm, alright, I think you're right
22:49:34 <Lambo> Thanks again!
22:52:46 <ddarius> Hans Rosling rocks
23:26:41 <handonson> Can I get the source code line/column info when an exception is raised?
23:28:13 <Axman6> it's possible if you throw the exception using a macro in a file that's been CPP'd
23:28:22 <kmc> ghci debugger may be helpful
23:28:25 <Axman6> but, apart from that, i don't believe you can
23:29:05 <EvanR> arg
23:29:26 <EvanR> how do i specify the Word8 '=' as in C, ASCII encoding
23:29:39 <handonson> ('=' :: Word8) ?
23:29:44 <handonson> no
23:29:45 <kmc> handonson, http://haskell.cs.yale.edu/ghc/docs/6.12.2/html/users_guide/ghci-debugger.html#ghci-debugger-exceptions
23:29:57 <handonson> 61 :: Word8
23:29:58 <EvanR> fromIntegral . ord $ '='
23:30:00 <kmc> fromEnum 'c'
23:30:10 <ddarius> :t ord
23:30:10 <lambdabot> Char -> Int
23:30:10 <kmc> yeah what you said
23:30:16 <EvanR> ok
23:30:46 <handonson> kmc: thanks
23:31:10 <kmc> see also the RTS option -xc here: http://haskell.cs.yale.edu/ghc/docs/6.12.2/html/users_guide/runtime-control.html#rts-options-debugging
23:31:14 <augur> so who here was interested in linguistics and/or theorem proving and/or formal grammars? anyone?
23:32:20 <EvanR> > ord '='
23:32:20 <lambdabot>   61
23:32:22 <ddarius> augur: No one.  No one at all.  Not even you.  I find it odd that you ask.
23:32:24 <EvanR> > ord '&'
23:32:25 <lambdabot>   38
23:32:27 <augur> D:
23:34:32 <augur> well, anyway, im really tempted to construct some sort of linguistics toolkit ala mathematica
23:35:43 <ddarius> augur: That statements sounds like "I'm tempted to construct some sort of linguistics toolkit a la Java" to me.
23:35:55 <augur> ddarius: well, mathematica is a language, sure, ok
23:36:14 <augur> but its also a whole suite of tools too
23:37:12 <republican_devil> java is all my work uses
23:37:16 <republican_devil> I think perl is better
23:37:23 <republican_devil> I kinda dislike python sofar
23:37:32 <kmc> i think java and perl are different enough to not be compared like that
23:37:33 <republican_devil> perhaps I havent give python enuf chance
23:37:47 <kmc> i also think python has most of the advantages of perl, without the crazy
23:37:51 <kmc> but this is off topic
23:37:58 <augur> ok thats ridiculous gtfo :|
23:38:01 <kmc> so perhaps i should shut up
23:38:14 <augur> kniu: i like that your residences have a subdomain for santa
23:38:28 * Twey likes J.  It has most of the advantages of Perl, with extra crazy.
23:38:44 <ddarius> J > Perl for sure.
23:38:45 <kniu> augur, huh?
23:38:55 <kniu> oh
23:38:56 <kniu> lol
23:38:57 <augur> kniu has joined (~kniu@HOHOHO.RES.CMU.EDU)
23:39:05 <Twey> Hahaha
23:39:09 <augur> no
23:39:10 <augur> hohoho
23:39:12 <augur> get it right
23:39:15 <Twey> :þ
23:39:15 <kniu> We choose our own subdomains.
23:39:23 <augur> i figured
23:39:25 <augur> still
23:39:28 <pumpkin> kniu: three whores?
23:40:01 <kniu> the mo' the merrier.
23:40:07 <pumpkin> fo sho
23:40:36 <augur> so anyway
23:41:17 <pelotom_> I'm trying to import a module, and it's defined in multiple packages... how do I suppress one of them?
23:41:59 <kmc> pelotom_, by choosing the one you want for the build-depends in your cabal file
23:42:02 <ddarius> pelotom_: You get a fire hose and some tear gas.
23:42:38 <pelotom_> mmkay, suppose I'm just trying to do something in ghci
23:42:54 * hackagebot collada-output 0.2 - Generate animated 3d objects in COLLADA  http://hackage.haskell.org/package/collada-output-0.2 (TillmannVogt)
23:42:59 <Axman6> you can also explicitly specify the package on the command line using -package foo-1.2.3.4
23:43:28 <kmc> pelotom_, ghci -hide-package mtl
23:43:44 <kmc> you can also use ghc-pkg to make such settings stick
23:43:49 <pelotom_> kmc: that's it, thanks!
23:43:53 <kmc> :)
23:44:06 <pelotom_> I knew I had figured this out before, just couldn't remember the command
23:44:45 <pelotom_> kmc: also btw, how did you know which package I was trying to hide? :)
23:45:01 <kmc> because that's the #1 conflict
23:45:03 <adnap> I'm still trying to figure this thing out on my computer: I have this library installed, but I keep getting messages saying data contructors are not in scope when I try to compile some code that depends on the library.  I know the imports are correct because I've compiled this code on another machine before.
23:45:22 <kmc> mtl versus monads-tf or monads-fd
23:45:26 <adnap> Does anyone have any ideas for how I mgiht debug this?
23:45:33 <pelotom_> yeah, I have monads-fd
