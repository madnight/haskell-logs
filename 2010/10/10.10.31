00:00:17 <djahandarie> ski, he's just a beginner
00:00:17 <ski> @type liftM2 (Prelude.++)
00:00:18 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m [a] -> m [a]
00:00:29 <BluShift1> djahandarie: Ahhhh. So binding a list to something allows that something to be treated normally on the left side of the |, leaving ++ to be totally naive?
00:00:37 <djahandarie> BluShift1, yep
00:00:56 <BluShift1> djahandarie: He's just a child!
00:00:56 <djahandarie> It just hands different things to the left side of | based on what you put on the right
00:01:17 <BluShift1> djahandarie: Is that unique to list comprehensions, or does that exist elsewhere too?
00:01:19 <djahandarie> BluShift1, I'm just a child too ;)
00:01:31 <djahandarie> BluShift1, hmm, what specifically?
00:01:37 <ski> BluShift1 if you do `[... | adjective <- adjectives,noun <- nouns]', then every possible combination of one `adjective' from `adjectives' and one `noun' from `nouns' will be tried/used
00:01:56 <paolino> BlueShift1: it's the list monad
00:02:02 * djahandarie facepalms
00:02:11 <BluShift1> paolino: That makes sense.
00:02:32 <BluShift1> paolino: So it's a little "subroutine" of functions, that make life easier in this case?
00:02:41 <BluShift1> djahandarie: Haha, relax. I'm sure he won't corrupt my mind :P
00:03:03 <djahandarie> Yes, the nondeterminism in list comprehensions matches the monad instance behavior of lists
00:03:13 <BluShift1> djahandarie: wut
00:03:17 <djahandarie> Exactly
00:03:24 <djahandarie> Which is why pointing that out is useless as hell
00:03:26 <BluShift1> Q_Q
00:03:42 <BluShift1> Well, no. It makes me aware of the fact that I'm using a monad. That's good to know.
00:03:46 <djahandarie> You aren't
00:03:50 <BluShift1> I just wont probe further.
00:03:52 <BluShift1> What?
00:04:01 <djahandarie> It's actually seperate from monads
00:04:28 * hackagebot containers-benchmark 1.0 - Extensive benchmark suite for containers package.  http://hackage.haskell.org/package/containers-benchmark-1.0 (MilanStraka)
00:04:29 <djahandarie> List comprehensions used to work for all monads but now they are just for lists and don't touch the monad instance
00:04:46 <BluShift1> Oh.
00:04:50 <djahandarie> So...
00:04:50 <Axman6> > do { x <- [1,2,3]; y <- [4,5,6]; return (x,y)}
00:04:51 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
00:04:58 <BluShift1> So, is it a really bad time to ask what a monad is?
00:05:01 <djahandarie> Yes.
00:05:14 <BluShift1> Even to ask for a 30,000' view?
00:05:32 <BluShift1> Also, what's this talk of "instances"?
00:05:40 <djahandarie> Learn type classes first
00:05:43 <djahandarie> That's where instances come from
00:05:46 <tolkad> BluShift1: Monad is a type class based on a mathematical concept
00:06:04 <djahandarie> A monad is a specific set of functions which encompass a certain pattetrn
00:06:06 <tolkad> BluShift1: the only special thing about it is that it has a special syntax associated with
00:06:06 <djahandarie> pattern*
00:06:08 <BluShift1> Ok, what are some examples of type classes? Num?
00:06:12 <djahandarie> Yep
00:06:22 <BluShift1> Any others?
00:06:25 <tolkad> with it*
00:06:26 <djahandarie> Fractional
00:06:28 <tolkad> BluShift1: Eq
00:06:28 <djahandarie> Monad
00:06:29 <djahandarie> Functor
00:06:31 <djahandarie> Eq
00:06:38 <djahandarie> Ord
00:07:02 <Axman6> @src Eq
00:07:02 <lambdabot> class  Eq a  where
00:07:03 <lambdabot>     (==), (/=)   :: a -> a -> Bool
00:07:05 <tolkad> BluShift1: do you understand data type declarations yet? like data T = MkT Int?
00:07:05 <BluShift1> Ok, so what's the purpose of having a Monad "instance"? Is instance in this case the same as an instance of an OO class?
00:07:15 <Axman6> no
00:07:18 <djahandarie> BluShift1, nope, very different
00:07:26 <BluShift1> Very very different?
00:07:36 <BluShift1> It's not a little chunk of memory with functions and state?
00:07:36 <tolkad> BluShift1: completely utterly unrelated
00:07:42 <tolkad> BluShift1: do you understand data type declarations yet? like data T = MkT Int?
00:07:47 <djahandarie> BluShift1, you should really just read LYAH, it teaches you all this stuff in a sensible way
00:07:51 <Axman6> BluShift1: bnot at all, it's much closer to an interface in java
00:08:01 <tolkad> Axman6: he doesn't know what those are
00:08:05 <BluShift1> Axman6: Well, i don't know what an interface..
00:08:08 <BluShift1> yeah.
00:08:09 <BluShift1> lol
00:08:11 <tolkad> BluShift1: do you understand data type declarations yet? like data T = MkT Int?
00:08:22 <BluShift1> tolkad: Holy jesus, I was getting there.
00:08:31 <tolkad> BluShift1: sorry, thought you lost it
00:08:41 <BluShift1> tolkad: :)
00:08:43 * djahandarie has lost it!
00:08:51 <tolkad> I mean lost the message
00:08:52 <djahandarie> Anyways, going to bed... it's late
00:08:57 <tolkad> not the expression for going insane
00:08:57 <djahandarie> G'night
00:09:03 <BluShift1> djahandarie: Thanks for all your help.
00:09:10 <djahandarie> Yep yw
00:09:15 <BluShift1> tolkad: No, I don't know what that means :)
00:09:27 <tolkad> BluShift1: do you understand what a constructor is?
00:09:49 <Axman6> BluShift1: my advice to you: get back LYAH
00:09:58 <tolkad> yeah just go back to LYAH
00:10:06 <tolkad> really read it
00:10:09 <BluShift1> In an OO sense, yes. Although given the past history of this conversation, it'll be 100% different in Haskell :P
00:10:11 <BluShift1> Ok.
00:10:19 <tolkad> BluShift1: just forget OO
00:10:20 <BluShift1> I'm still going through list comps :)
00:10:26 <BluShift1> tolkad: Hahaha, god. Ok.
00:10:26 <tolkad> BluShift1: haskell is not based on OO at all
00:10:40 <BluShift1> tolkad: Does absolutely none of the terminology carry over?
00:10:46 <tolkad> BluShift1: none of it
00:11:01 <BluShift1> This is going to to totally fuck up my OO Fundamentals course :P
00:11:19 <tolkad> BluShift1: not the word class, not the word constructor, not the word function
00:11:52 <BluShift1> On a test, my teacher will ask "Give an example of an instance" And I'll write "Num, Monad"
00:11:56 <MigX> Anyone have any cool ideas for Haskell related research projects?
00:12:04 <tolkad> BluShift1: those are classes, not instances
00:12:12 <BluShift1> tolkad: Wut
00:12:13 <tolkad> BluShift1: you can create instances of them
00:12:15 <BluShift1> tolkad: Oh.
00:12:24 <BluShift1> But that's a story for another day?
00:12:36 <tolkad> BluShift1: classes aren't actually that hard to understand I guess
00:12:47 <BluShift1> But still unrelated to OO?
00:12:56 <tolkad> UNRELATED
00:13:02 <BluShift1> Hah, alright.
00:13:12 <tolkad> BluShift1: let's look at Eq
00:13:34 <tolkad> BluShift1: the class Eq looks like: « class Eq a where (==) :: a -> a -> Bool »
00:13:55 <BluShift1> Ok.
00:14:08 <tolkad> BluShift1: (==) has the type Eq a => a -> a -> Bool
00:14:29 <BluShift1> So, == is literally the name of the function?
00:14:31 <tolkad> BluShift1: so you can use (==) on any type which there is an instance of Eq for
00:14:35 <tolkad> BluShift1: yes
00:14:57 <tolkad> BluShift1: it's just polymorphism
00:15:01 <BluShift1> So there is an instance of == Eq for every type that supports that?
00:15:06 <tolkad> BluShift1: yes
00:15:28 <tolkad> BluShift1: it just forces you to write the definition of the function == seperately for each type that supports it
00:15:32 <BluShift1> And what do these instances do, exactly? Are they connected to the value that supports it?
00:15:50 <ski> values don't support classes, types do
00:16:08 <tolkad> BluShift1: so let's write an instance of Eq for Bool
00:16:30 <BluShift1> ski: Right. But a value is created, and it has a type. Therefore, that value has instantiated this instance of Eq.
00:16:35 <BluShift1> tolkad: Oj.
00:16:36 <BluShift1> ok*
00:16:52 <ski> BluShift1 : no
00:17:03 <BluShift1> No?
00:17:04 <tolkad> BluShift1: « instance Eq Bool where { True == True = True; False == False = True; False == True = False; True == False = False } »
00:17:31 <tolkad> BluShift1: equivalently« instance Eq Bool where { True == True = True; False == False = True; _ == _ = False } »
00:17:42 <ski> BluShift1 : consider `class Read a where read :: String -> a' (that's a simplification)
00:18:05 <tolkad> BluShift1: equivalently« instance Eq Bool where { (==) True True = True; (==) False False = True; (== )_  _ = False } »
00:18:07 <tolkad> whoops
00:18:10 <tolkad> BluShift1: equivalently« instance Eq Bool where { (==) True True = True; (==) False False = True; (==) _  _ = False } »
00:18:22 <ski> BluShift1 : when you make an instance of `Read' for e.g. `Bool', no value of type `Bool' is created. the value of type `Bool' is only created when `read' is called on a string
00:18:33 <BluShift1> tolkad: Ok, so that's just the definition of the "equality" check, right?
00:18:33 <tolkad> BluShift1: it just let's you use the same function name for multiple types
00:18:37 <tolkad> BluShift1: yes
00:18:59 <ski> BluShift1 : we say that we have an instance of `Read' for `Bool' (the *type*)
00:19:02 <tolkad> BluShift1: it let's you use the same function name for multiple types but you have to write a seperate definition of the function for each type
00:19:17 <BluShift1> tolkad: Oh, ok.
00:19:20 <BluShift1> I sort of understand.
00:19:37 <BluShift1> But I can see that this is outside of my depth a fair bit.
00:19:38 <ski> BluShift1 : note that if you say `read someString', what this will do depends on what type is expected, where this expression occurs
00:19:47 <ski> > read "123" * 10
00:19:48 <lambdabot>   1230
00:19:58 <ski> > read "123" && False
00:19:59 <lambdabot>   *Exception: Prelude.read: no parse
00:20:04 <ski> > read "False" && False
00:20:05 <lambdabot>   False
00:20:08 <ski> > read "False" * 10
00:20:09 <tolkad> BluShift1: let's write another instance, there's a type "()" with one value, "()"
00:20:09 <lambdabot>   *Exception: Prelude.read: no parse
00:20:32 <tolkad> BluShift1: « instance Eq () where { () == () = True } »
00:20:45 <tolkad> BluShift1: equivalently « instance Eq () where { _ == _ = True } »
00:20:45 <ski> BluShift1 : note how this is completely different from OO, where the methods of a class acts on an object of that class
00:20:58 <BluShift1> ski: Yeah.
00:21:07 <ski> BluShift1 : in this case, the value of type `Bool' doesn't exist yet, when `read' is called
00:21:11 <BluShift1> ski: Requires stretching my mind a fair bit :P
00:21:23 <ski> BluShift1 : this is overloading on the result type
00:21:41 <BluShift1> ski: What *is* overloading? I've heard of this before, but never understood it.
00:21:53 <ski> (btw, Ada also supports overloading on result type .. but just in an ad-hoc way, not via type classes, like in Haskell)
00:22:47 <ski> BluShift1 : in e.g. Java, overloading means that you can have two methods in a class, both named `foo', but with different types
00:23:09 <BluShift1> Ohh, ok.
00:23:11 <ski> BluShift1 : which actual method is invoked is decided by checking which the types of the arguments are
00:23:20 <BluShift1> So one to operate on doubles, and one to operate on ints?
00:23:28 <BluShift1> I see.
00:23:44 <ski> in some sense, `(==) :: Eq a => a -> a -> Bool' is a bit similar .. which actual function is executed depends on what type `a' actually is
00:23:57 <BluShift1> ski:  I see.
00:24:00 <ski> but in Haskell, overloading is a lot more principled
00:24:20 <BluShift1> So different instances just override (or create) behaviour for a certain type?
00:24:20 <ski> (also, it is more powerful, as well)
00:24:34 <ski> no override, really
00:25:10 <ski> an instance of `Eq' for a type `T' tells the system what `(==)' and `(/=)' should do for this type
00:25:10 <BluShift1> Oh. You can't change the behaviour of a certain pre-defined function?
00:25:32 <BluShift1> Ok.
00:25:48 <ski> (to a first approximation), `(==)' has no pre-defined behaviour
00:25:52 <BluShift1> Can you define your own type?
00:25:57 <BluShift1> type(s) *
00:26:05 <BluShift1> ski: Ok, how so?
00:26:10 <ski> for each type which is declared an instance of `Eq', a behaviour is supplied (when writing the instance)
00:26:18 <ski> yes, you can define your own types
00:26:51 <ski> there is no default version of `(==)' which will work for types you haven't made into instances of `Eq'
00:27:00 <BluShift1> Ok.
00:27:08 <ski> if a type hasn't been made an instance of `Eq', then `(==)' will not work on it, period
00:27:13 <ski> this is checked at compile-time
00:27:38 <BluShift1> So wait, is Eq a class or an instance?
00:27:44 <ski> `Eq' is a class
00:27:51 <BluShift1> Oh.
00:27:51 <BluShift1> Ok
00:28:00 <ski>   instance Eq Bool
00:28:02 <ski>     where
00:28:08 <ski>     True == True  =  True
00:28:15 <ski>     False == False  =  True
00:28:20 <BluShift1> So that's much like OO, then. Instances of a class inherit certain behaviour from a parent class.
00:28:26 <ski>     _     == _      =  False
00:28:39 <ski> that is an instance of `Eq' for the type `Bool'
00:28:43 <ski> no
00:28:48 <ski> instances do not inherit
00:29:10 <ski> (to a first approximation) classes have no behaviour
00:29:14 <BluShift1> It sounds like an instance can inherit from multiple class.
00:29:16 <BluShift1> Ok.
00:29:19 <BluShift1> classes*
00:29:51 <tolkad> BluShift1: it's sort of like function overloading in Java
00:30:01 <BluShift1> Ok.
00:30:02 <tolkad> BluShift1: you write the same function for multiple types
00:30:09 <BluShift1> Ok.
00:30:16 <tolkad> BluShift1: in haskell though, it chooses the correct function at compile time
00:30:25 <tolkad> BluShift1: and in haskell, you can also overload return types
00:30:32 <BluShift1> Is there any sort of "master class" that these functions belong to?
00:30:41 <tolkad> BluShift1: no
00:31:11 <BluShift1> Ok, so there's just tons of overloaded classes floating around, then?
00:31:15 <ski> it wouldn't make much sense to have a master class
00:31:27 <tolkad> BluShift1: here's the standard library classes: http://www.uni-bonn.de/~manfear/haskell-classhierarchy.php
00:31:29 <BluShift1> ski: I suppose not.
00:31:38 <BluShift1> I'm just trying to organize all thee things in my head.
00:31:44 <ski> well, classes aren't overloaded. classes provide overloaded operations
00:31:50 <tolkad> they are ordered in a heirarchy because some classes require other classes
00:32:08 * BluShift1 sounds like OO to me >_>
00:32:10 <ski> i suppose one *could* have a "master class" with *no* methods .. but it seems pretty useless, too
00:32:11 <tolkad> BluShift1: for example, types can only have Ord instances if you also write them Eq instances
00:32:31 <tolkad> BluShift1: because Ord's header looks like class Eq a => Ord a where ...
00:33:02 <tolkad> BluShift1: there is no automated inheritence though, you have to write both instances yourself
00:33:05 <BluShift1> Why do you say "Eq instances", if you're writing a general overloaded function for it? Is overloaded just an OO thing?
00:33:11 <ski> BluShift1 : some aspects of type classes are a bit similar to OO. others are not .. it is best not to draw too many analogies, initially
00:33:23 <BluShift1> Ok.
00:33:32 <dibblego> by overload, I think you mean override
00:33:36 <BluShift1> Like everyone said, pretend you're new to computers :P
00:33:38 <tolkad> BluShift1: the Ord class contains the function (<)
00:33:48 <ski> @src Ord
00:33:48 <lambdabot> class  (Eq a) => Ord a  where
00:33:48 <lambdabot>     compare      :: a -> a -> Ordering
00:33:48 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
00:33:48 <lambdabot>     max, min         :: a -> a -> a
00:33:50 <tolkad> dibblego: I think it's called overloading in Java
00:34:10 <ski> the class `Ord' provides several overloaded operations
00:34:15 <BluShift1> dibblego: What languages use the term "override"?
00:34:25 <tolkad> BluShift1: when you write an instance of Ord for some type a, you have to define a function (<) :: a -> a -> Bool
00:34:27 <dibblego> overloading (in Java) is two or more functions with the same name and different argument types
00:34:35 <tolkad> dibblego: yes
00:34:46 <tolkad> dibblego: I told him it is like that, except it happens at compile time
00:34:55 <dibblego> ok
00:35:04 <ski> BluShift1 : "override" in Java is when you have a method in a class, and you make a new implementation of the method in a subclass, "replacing" the old definition, for objects of the subclass
00:35:16 <BluShift1> ski: Oh.
00:35:31 <ski> (that is completely different to overloading)
00:35:33 <BluShift1> I guess in Haskell those two definitions seem to blur a little, yeah?
00:35:54 <ski> which two definitions ?
00:36:01 <BluShift1> overloading, and overriding.
00:36:17 <tolkad> BluShift1: so when you write the expression « a < b » where "a" is a value of type "c" and "b" is a value of type "c", haskell looks for the instance of Ord for c, selects the definition of the (<) function from that instance, and uses it here
00:36:17 <ski> no, they mean different things, in Haskell as well
00:36:35 <BluShift1> ski: Pfffffffff.
00:36:46 <tolkad> BluShift1: that make sense?
00:37:04 <BluShift1> tolkad: Yes!
00:37:20 <BluShift1> Sort of.
00:37:35 <BluShift1> I think I diagram of this would help me visualize it a little.
00:37:44 <tolkad> BluShift1: here's another example, Bounded
00:37:47 <tolkad> @src Bounded
00:37:47 <lambdabot> class  Bounded a  where
00:37:47 <lambdabot>     minBound, maxBound :: a
00:37:53 <tolkad> > maxBound :: Int
00:37:54 <lambdabot>   9223372036854775807
00:37:58 <BluShift1> So instances of typeclasses have behaviour related to one specific type?
00:38:01 <tolkad> minBound :: Int
00:38:07 <tolkad> > minBound :: Int
00:38:07 <lambdabot>   -9223372036854775808
00:38:22 <BluShift1> > maxBound :: Integer
00:38:23 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
00:38:23 <lambdabot>    arising...
00:38:26 <tolkad> BluShift1: yes, they have a seperate definition for each type which has an instance of the class
00:38:29 <ski> BluShift1 : and when you write the expression `not (read "False")', because `not' expects a `Bool' argument, `read' here will select the implementation from the `Bool' instance of `Read', to try to read a bool value from the string
00:38:34 <ski> > not (read "False")
00:38:35 <lambdabot>   True
00:38:44 <ski> > not (read "not a boolean")
00:38:44 <lambdabot>   *Exception: Prelude.read: no parse
00:38:45 <tolkad> BluShift1: Integer is an arbitary precision number
00:38:55 <BluShift1> So, no bound?
00:38:59 <tolkad> BluShift1: you can make Integers as big as you want until you run out of memory
00:39:06 <tolkad> BluShift1: yes
00:39:07 <ski> > maxBound :: Bool
00:39:08 <lambdabot>   True
00:39:09 <BluShift1> tolkad: Sounds fun :)
00:39:10 <BluShift1> :P
00:39:17 <tolkad> > maxBound :: Char
00:39:18 <lambdabot>   '\1114111'
00:39:27 <tolkad> > maxBound :: Int8
00:39:28 <lambdabot>   127
00:39:34 <tolkad> > maxBound :: Word8
00:39:34 <lambdabot>   255
00:39:36 <ski> > maxBound :: Ordering
00:39:37 <lambdabot>   GT
00:39:39 <ski> > maxBound :: ()
00:39:39 <lambdabot>   ()
00:39:42 <tolkad> BluShift1: make sense?
00:40:04 <BluShift1> So all these instances, do they each have their own class that they're instatiated from? So the instance for Ord has a class "Ord", for example?
00:40:15 <tolkad> there is one class named Ord
00:40:22 <ski> it has several instances
00:40:46 <BluShift1> Wait, is Ord a type?
00:40:50 <ski> there's one instance of `Bool' for `Ord'
00:40:55 <ski> there's one instance of `Integer' for `Ord'
00:40:57 <ski> &c.
00:41:05 <ski> `Ord' is a type class
00:41:13 <BluShift1> Num is also a type class, right?
00:41:16 <ski> yes
00:41:20 <BluShift1> Ahhhh
00:41:26 <BluShift1> It's starting to come together
00:41:38 <tolkad> BluShift1: look at this: http://codepad.org/Tc92bVS5
00:41:39 <BluShift1> So do these type classes belong to a super-class in any way?
00:41:49 <tolkad> BluShift1: no
00:41:51 <BluShift1> Ok.
00:41:55 <tolkad> BluShift1: there's no need for one
00:42:00 <BluShift1> Right.
00:42:07 <BluShift1> How many typeclasses are there?
00:42:08 <ski> some type classes have super-classes, others don't
00:42:15 <ski> you can define your own type classes
00:42:23 <ski> so there's potentially infinitely many
00:42:25 <BluShift1> *default, top-level typeclasses
00:42:32 <tolkad> BluShift1: http://www.uni-bonn.de/~manfear/haskell-classhierarchy.php
00:43:15 <tolkad> BluShift1: does this make sense to you? http://codepad.org/qFw1sUqq
00:43:22 <ski> in practice, the most common are `Show',`Read',`Eq',`Ord',`Enum',`Bounded'.`Num',`Integral',`Fractional',`Floating',`Functor',`Monad'
00:43:30 <ski> (and a few more i'm forgetting)
00:43:37 <BluShift1> Ohhh k.
00:44:10 <ski> every type class is "top-level"
00:44:14 <BluShift1> And so, does this mean say.... (==) is the same for all members of the Num typeclass?
00:44:20 <BluShift1> So, Integer, Int, etc?
00:44:23 <ski> you can't define type classes inside of `where' or `let'
00:44:30 <ski> BluShift1 : no
00:44:43 <BluShift1> Oh wait
00:44:44 <ski> each type has its own instance of the classes it implements
00:44:48 <BluShift1> Right right right
00:44:52 <BluShift1> You said that.
00:45:01 <BluShift1> Forgive me, it's a quarter to 3 here :P
00:45:06 <ski> well, more or less, at least
00:45:07 <tolkad> BluShift1: here's an example of defining your own type class: http://codepad.org/EWaFTztF
00:45:11 <ski> there's actually
00:45:16 <ski>   instance Eq (IORef a)
00:45:18 <ski> and such
00:45:37 <ski> so one might say that `IORef Int' and `IORef Bool' uses the same `Eq' instance
00:46:00 <BluShift1> So is there any implications with trying to use a function with two types that aren't in the same typeclass?
00:46:32 <ski> > length ("foo" :: [Char])
00:46:33 <lambdabot>   3
00:46:45 <tolkad> BluShift1: you can't call « (==) True 0 » because the type of (==) forbids it
00:46:46 <BluShift1> tolkad: Yes, that first example makes sense.
00:46:49 <ski> > length ([cos,sin,tan] :: [Double -> Double])
00:46:50 <lambdabot>   3
00:47:00 <tolkad> BluShift1: if you recall, the type of (==) is "a -> a -> Bool"
00:47:02 <BluShift1> So you're literally changing the behaviour for Integer., then right?
00:47:15 <tolkad> BluShift1: not changing, there wasn't one before
00:47:25 <BluShift1> tolkad: Oh, right.
00:47:26 <tolkad> BluShift1: recall that Integer isn't bounded
00:47:30 <BluShift1> tolkad: Right, right.
00:47:51 <ski> BluShift1 : there is no trouble with calling a polymorphic operation in two different situations, with different types .. this is unrelated to type classes and overloading .. it is just polymorphism
00:48:03 <BluShift1> I see.
00:48:05 <tolkad> @src Num
00:48:05 <lambdabot> class  (Eq a, Show a) => Num a  where
00:48:05 <lambdabot>     (+), (-), (*)           :: a -> a -> a
00:48:05 <lambdabot>     negate, abs, signum     :: a -> a
00:48:05 <lambdabot>     fromInteger             :: Integer -> a
00:48:18 <tolkad> BluShift1: you see that fromInteger function? it's magic
00:48:29 <BluShift1> tolkad: Real magic?
00:48:36 <tolkad> BluShift1: haskell uses it to transform numeric literals into numbers
00:48:43 <tolkad> which is why:
00:48:45 <tolkad> :t 0
00:48:45 <lambdabot> forall t. (Num t) => t
00:49:13 <BluShift1> The literal "0" become "00000000" in memory?
00:49:20 <tolkad> :t (fromInteger (0 :: Integer))
00:49:21 <lambdabot> forall a. (Num a) => a
00:49:40 <tolkad> BluShift1: that depends on the implementation of haskell, the haskell standard doesn't say anything about how stuff is stored in memory
00:50:24 <BluShift1> tolkad: Oh. Well, what you mean is that the literal "0" is changed from a character of text to an integer in the machine, right?
00:50:30 <Nibble> :t O
00:50:31 <lambdabot> Not in scope: data constructor `O'
00:50:35 <ski> each literal like `42' can be used as a literal of any type which is an instance of `Num'
00:50:51 <BluShift1> Ok...
00:51:12 <tolkad> BluShift1: anyway, the reason you can write (1 2) is because someone wrote an « instance Num (a -> a) … »
00:51:29 <BluShift1> tolkad: Holy shit, I asked that hours ago :P
00:51:34 <BluShift1> (1 2)
00:51:36 <ski> when a literal `42' is used of type `Foo', say, what happens it that the `42' is treated as `fromInteger 42' (that having type `Foo'), where *that* `42' actually has type `Integer'
00:51:38 <BluShift1> > (1 2)
00:51:39 <lambdabot>   Ambiguous type variable `t' in the constraint:
00:51:39 <lambdabot>    `GHC.Num.Num t' arising f...
00:51:50 <tolkad> BluShift1: so they provided a definition of « fromInteger :: Num Integer -> (a -> a) »
00:52:04 <tolkad> BluShift1: it doesn't know which instance of Num you want
00:52:10 <tolkad> > (1 2) :: Int
00:52:11 <lambdabot>   1
00:52:17 <ski> BluShift1 : so each time you use `42' of type `Foo', you're really calling the function `fromInteger' in the `Foo' instance of `Num' on the *`Integer'* `42'
00:52:41 <BluShift1> ski: Oh, you lost me. Hold on, rereading.
00:52:54 <ski> (tolkad : actually `instance Num a => Num (r -> a)' ..)
00:53:09 <tolkad> whoops, that's what I meant
00:53:10 <tolkad> sorry
00:53:27 <ski> BluShift1 : anyway .. i'm leaving atm -- maybe i'll look it a little later
00:53:37 <BluShift1> Ok, I'm headed to bed soon too.
00:53:45 <BluShift1> Thanks for all the help, ski. :)
00:53:55 <ski> yw
00:54:01 <BluShift1> Yeah, that's probably a good place to leave it.
00:54:04 <BluShift1> lol
00:54:06 <tolkad> BluShift1: so someone wrote « instance Num a => Num (r -> a) where { fromInteger x = (\y -> x) } »
00:54:15 <BluShift1> Back to LYAH tomorrow :P
00:54:22 <tolkad> BluShift1: so someone wrote « instance Num a => Num (r -> a) where { fromInteger x = (\y -> x); ¬ } »
00:54:24 <BluShift1> tolkad: I don't understand that :-/
00:54:28 <tolkad> BluShift1: so someone wrote « instance Num a => Num (r -> a) where { fromInteger x = (\y -> x); … } »
00:54:30 <tolkad> lol
00:54:33 <tolkad> sorry
00:54:46 <BluShift1> Haha, no worries :P
00:54:46 <tolkad> BluShift1: uh what about this
00:54:55 <tolkad> BluShift1: so someone wrote « instance Num a => Num (r -> a) where { fromInteger x y = x; … } »
00:54:58 <BluShift1> With your help, I hopefully will soon though!
00:55:08 <BluShift1> No, that still looks like total greek :P
00:55:16 <tolkad> BluShift1: functions are types
00:55:19 <tolkad> BluShift1: whoops
00:55:24 <tolkad> BluShift1: functions HAVE types
00:55:24 <BluShift1> I don't understand any actual haskell code :P
00:55:34 <tolkad> BluShift1: so you can write a class instance for a function type too
00:55:42 <BluShift1> That makes sense.
00:55:55 <BluShift1> Are function types expressed as a -> a?
00:56:09 <tolkad> or a -> b
00:56:12 <tolkad> or Bool -> Int
00:56:14 <BluShift1> Or a -> Int?
00:56:15 <BluShift1> Yeah
00:56:18 <BluShift1> Ok.
00:56:18 <tolkad> yeah
00:56:26 <BluShift1> This is so.... interesting.
00:56:50 <BluShift1> It's a totally new way of looking at programming. It's totally mind-expanding.
00:56:54 <tolkad> haskell has a more complicated type system than you will find in an OOP language
00:57:08 <BluShift1> Yes, I see that.
00:57:15 <Nibble> BluShift1: here is the best tip I have gotten so far when learning haskell.
00:57:18 <Saizan> yet in some ways simpler
00:57:19 <Nibble> "There is no magic"
00:57:26 <BluShift1> What does that mean?
00:57:26 <tolkad> well
00:57:31 <Nibble> BluShift1: that there is no magic
00:57:40 <tolkad> BluShift1: haskell has magic but it is pretty much all syntatic
00:57:51 <Nibble> just remember that one
00:57:55 <tolkad> like the trasnformation of numeric literals using fromInteger
00:57:55 <Nibble> it will help you :P
00:58:02 <BluShift1> Nibble: It will come in handy? :P
00:58:13 <tolkad> BluShift1: you know what magic is in programming?
00:58:27 <tolkad> BluShift1: it has a specific meaning, not the normal meaning of the word
00:58:28 <BluShift1> tolkad: When things just "happen" how you want them to?
00:58:34 <Nibble> Like understanding monads.
00:58:40 <Nibble> And all other of those generic stuff
00:58:45 <Nibble> functors
00:58:48 <Nibble> n' shit
00:58:48 <tolkad> BluShift1: http://en.wikipedia.org/wiki/Magic_%28programming%29
00:59:17 <BluShift1> Ahhh. So like, networking libraries and math libraries?
00:59:21 <tolkad> no
00:59:34 <tolkad> it's hard to give a definition
00:59:37 <tolkad> but here's an example
00:59:52 <Nibble> things that just are
00:59:58 <Nibble> you are not meant to understand them.
01:00:16 <Nibble> haskell is simple, the only problem is that it is too simple.
01:00:23 <tolkad> ruby on rails keeps a dictionary of word plurals so that it can automatically find the plural names of tables in your database
01:00:32 <Nibble> the only problem when learning*
01:00:36 <tolkad> at least I think it does?
01:00:49 <tolkad> hmm, let's think of another example
01:01:39 <BluShift1> Why wouldn't networking libs be an example of that? Or SMTP libs in python?
01:01:54 <BluShift1> I can send an email to myself with a fake sender address in 3 lines, in Python.
01:02:05 <Nibble> BluShift1: it might be magic
01:02:06 <BluShift1> That's magical, in my opinion.
01:02:17 <Nibble> But that is not what I talked about
01:02:31 <BluShift1> I don't need to know anything about network I/O, or how SMTP works.
01:02:33 <Nibble> BluShift1: In haskell, you can almost all of the time understand how something works
01:02:40 <Nibble> that is valid for other languages too
01:02:52 <BluShift1> Nibble: How so?
01:02:53 <Nibble> but haskell, you can often understand why it works like it works
01:03:01 <Nibble> being as connected with math as it is.
01:03:05 <BluShift1> Nibble: Right, ok.
01:03:50 <BluShift1> Nibble: That's like the list comprehension. Aside from the fact that it's doing some funky stuff in the background, I totally get how it works as a mathematical thing.
01:03:50 <tolkad> BluShift1: magic is when a programming language tries to guess what you intend to do instead of making you explicitly say how to do it
01:03:59 <BluShift1> tolkad: Right.
01:04:18 <BluShift1> tolkad: Would duck typing be an example?
01:04:47 <BluShift1> Nibble: Haha, I re-read that, and I realize how retarded that likely makes me sound :P
01:04:49 <tolkad> BluShift1: not really
01:05:12 <tolkad> BluShift1: magic can also be when something is "an exception"
01:05:12 <BluShift1> tolkad: Ok, what's an example in another language?
01:05:16 <Nibble> BluShift1: haskell is meant to be understood, not learnt.
01:05:20 <Nibble> :)
01:05:37 <Nibble> A bit cliché but hey, it is true
01:05:38 <tolkad> BluShift1: Java automatically flushing the output buffer when you send a newline
01:05:42 <BluShift1> Nibble: Ahh. Whereas with myself, I learned Python, but I didn't understand it at all.
01:06:47 <BluShift1> Nibble: Would that be sort of like aliases being set up in a shell, so that "wrong" commands (that may have been right at one time) still get executed?
01:06:56 <tolkad> BluShift1: ooh, here's a really good example
01:07:06 <Nibble> BluShift1: look at his example :P
01:07:19 <BluShift1> Nibble: I saw it :P
01:07:19 <tolkad> BluShift1: Java's automatic conversion between primitives like int and their associated wrapper classes like Integer
01:07:26 <BluShift1> tolkad: Aahhhh
01:07:32 <Nibble> BluShift1: as I said before
01:07:35 <Nibble> things that just are
01:07:39 <Nibble> you are not meant to understand it
01:07:46 <Nibble> nor care about it.
01:08:05 * shachaf is ammused at how much trouble people are having explaining the word.
01:08:06 <BluShift1> haskell is very much the antithesis to "magic"?
01:08:09 <shachaf> s/mm/m/
01:08:30 <tolkad> BluShift1: haskell has things that could be considered magic, but most all of them are just syntatical
01:08:35 <augur> BluShift1: actually, magic is just cleverly disguised haskell.
01:08:51 <BluShift1> shachaf: I could swear my examples are totally right, but apparently not :S
01:08:59 <tolkad> BluShift1: like numeric literals
01:09:16 <tolkad> BluShift1: 0 is transformed into fromInteger (0 :: Integer)
01:09:26 <BluShift1> Would an example of this be lists? And the difference between 1,2,3,4,[] and [1, 2, 3, 4]?
01:09:26 <tolkad> BluShift1: it's just a syntax transformation
01:09:27 <shachaf> BluShift1: "magic" isn't the same as "abstraction".
01:09:41 <tolkad> BluShift1: or the IO sequence function
01:10:12 <BluShift1> shachaf: Are mine examples of abstraction? I didn't think so.
01:10:18 <tolkad> BluShift1: « (print 0) >>= (print "") » is the same as « do {print 0; print ""} »
01:10:29 <shachaf> BluShift1: Well, a Python library that sends email is that, pretty much.
01:10:42 <shachaf> tolkad: I would put that the other way around.
01:10:56 <tolkad> BluShift1: the special list syntax is an example of magic
01:11:04 <shachaf> And I'd say that syntax sugar is rarely the same thing as "magic".
01:11:23 <tolkad> I'd say syntax sugar is magic, but not the bad kind of magic
01:11:39 <BluShift1> shachaf: All of tolkads examples appear to just be sugar. To me, magic is "write one statement, write a symphony"
01:11:40 <tolkad> BluShift1: haskell doesn't have magic that isn't syntax sugar
01:12:00 <shachaf> The clearest example that was mentioned so far was Rails' automatic pluralization, I think.
01:12:15 <BluShift1> I'm not familiar with RoR, sorry :/
01:12:18 <shachaf> tolkad: I'd say it does.
01:12:26 <tolkad> shachaf: well, much
01:12:34 <tolkad> shachaf: compared to other languages
01:12:39 <tolkad> shachaf: can you give an example though?
01:12:50 <shachaf> BluShift1: You define a class named "person" and it automatically looks in the database table named "people" for you.
01:13:07 <BluShift1> shachaf: .... that's most certainly magical.
01:13:14 <tolkad> BluShift1: it's completely evil
01:13:21 <BluShift1> tolkad: I can imagine.
01:13:26 <tolkad> BluShift1: are they going to keep the same dictionary forever?
01:13:49 <tolkad> BluShift1: if someone wanted to write their own version of RoR they would have to copy the entire dictionary
01:14:00 <shachaf> tolkad: I think they stay mostly backwards-compatible except in really weird edge-cases, in which case you should be specifying it explicitly anyway.
01:14:06 <BluShift1> I think just about anything could be taken as "magic", honestly.
01:14:10 <shachaf> tolkad: And it's not a dictionary, it's a series of regexps. :-)
01:14:19 <BluShift1> The line for me is non-existant.
01:14:20 <tolkad> shachaf: *shudders*
01:14:34 <tolkad> BluShift1: it's not a precise term
01:14:52 <tolkad> BluShift1: it's used only in subjective judgements of a language feature
01:15:03 <BluShift1> 3 million nested if statements, each doing a regex match ;) Yummy.
01:15:18 <BluShift1> tolkad: Ahh.
01:15:31 <BluShift1> To me, the only language I'd consider non-magical is Assembly.
01:15:32 <BluShift1> lol
01:15:52 <tolkad> shachaf: and what if someone tries to code in a language besides English and it mispluralizes a word?
01:16:26 <BluShift1> tolkad: I don't think you need to convince him :P
01:16:34 <shachaf> tolkad: I never said I was in favor of it. I think Rails errs on the side of being too magical. :-)
01:16:58 <shachaf> BluShift1: By the way, list comprehensions (which you mentioned before) are probably simpler implementation-wise than you might think.
01:17:28 <BluShift1> They do something mondac-like though, don't they?
01:17:41 <BluShift1> monad-like*
01:17:58 <shachaf> Yes.
01:18:00 <tolkad> > [(a, b) | a <- [1..10], b <- [1..10]]
01:18:01 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(...
01:18:11 <tolkad> BluShift1: it has to do with the monad instance for list
01:18:21 <tolkad> BluShift1: it's basically just a cross product
01:18:26 <BluShift1> tolkad: I thought you said it didn't touch the monad instance?
01:18:46 <shachaf> BluShift1: Unfortunately not.
01:18:49 <shachaf> But it should! :-)
01:18:58 <tolkad> BluShift1: whether it uses the monad instance is implementation specific
01:19:13 <BluShift1> What's the purpose of having it not touch it?
01:19:22 <BluShift1> Does it have its own special instance?
01:19:26 <shachaf> BluShift1: I think it was making errors clearer?
01:19:33 <BluShift1> Ahh.
01:19:46 <shachaf> At any rate, you can write a list comprehension just as easily in do-notation, or translated to (>>=)/return/guard.
01:19:54 <shachaf> (And "fail", but we don't talk about that.)
01:20:09 <tolkad> fail is the most important function of the monad class
01:20:10 <BluShift1> "Fail" stays in locked in the basement?
01:20:19 <BluShift1> locked in*
01:20:22 <tolkad> fail, not Fail
01:20:24 <tolkad> it's a function
01:20:31 <tolkad> > fail "" :: [a]
01:20:32 <lambdabot>   []
01:20:33 <BluShift1> It was the first letter of my sentence! :P
01:20:41 <shachaf> BluShift1: It was in quotation marks!
01:20:49 <BluShift1> shachaf: Touche!
01:20:55 <shachaf> "fail" is very self-descriptive.
01:21:11 <tolkad> > (head.fail) ""
01:21:12 <lambdabot>   *Exception: Prelude.head: empty list
01:21:37 <BluShift1> Anyways, I think I've learned more tonight than I have in... well... I don't want to dirty the image of my school, so I'll leave that at that.
01:21:40 <BluShift1> lol
01:21:51 <tolkad> are you in college?
01:21:55 <BluShift1> I am.
01:22:14 <BluShift1> Although in Canada, college is much like a vocational school, not a university like in the states.
01:22:23 <BluShift1> Not sure where you guys are from.
01:22:56 <tolkad> the programming classes in universities are meant to be able to be taken by any student
01:23:06 <tolkad> they go kind of slowly...
01:23:17 <BluShift1> Like I said, this is college, not university.
01:23:22 <BluShift1> They're different in Canada.
01:23:22 <Nibble> BluShift1: over here
01:23:25 <Nibble> that is the same thing
01:23:30 <BluShift1> Yeah, I know.
01:23:34 <shachaf> tolkad: Here's the Rails "dictionary", by the way, it seems: http://github.com/rails/rails/blob/master/activesupport/lib/active_support/inflections.rb
01:24:01 * shachaf has never figured out what the difference between "college" and "university" is in the US.
01:24:03 <BluShift1> In Canada, college is like a 2-3 year program, and you end up with a diploma, not a degree. It's more practical and hands on, and much less theory.
01:24:15 <BluShift1> shachaf: There is none, afaik.
01:24:17 <tolkad> shachaf: looks like it would fit just fine in a specification if they ever want to write one for RoR
01:24:30 <BluShift1> Hahah
01:25:42 <BluShift1> In Canada, we have a really large number of undergrad students who can't find work, because there's just too many of them, and they don't really have any pertinent skills.
01:26:19 <BluShift1> College students don't really find the "higher end" jobs, but they find jobs sooner, and more consistently because they can walk into a server room and fix a problem immediately.
01:27:08 <shachaf> BluShift1: I don't see that as something that a university would teach (if I understand the meaning), but I don't know if I see that as something that would be taught in a school at all.
01:27:37 <BluShift1> shachaf: I'm not sure I understand you fully.
01:27:50 <tolkad> the whole point of going to university is learning CS theory :P
01:28:08 <Nibble> Electronical engineering is a good course I heard.
01:28:20 <BluShift1> tolkad: In Canada, University = CS theory, whereas college is for "lets fix the problems"
01:28:30 <BluShift1> "Lets set up a network"
01:28:41 <BluShift1> Not, "I can write you an algorithm"
01:28:50 <tolkad> BluShift1: hmph, do you just want to spend your whole life working to make money?
01:29:12 <BluShift1> tolkad: Not at all. I fully intend to get my Masters degree after college.
01:29:20 <BluShift1> I just don't want to end up like Richard Stallman :P
01:29:29 <dmwit> Why not?
01:29:36 <shachaf> BluShift1: Like Richard Stallman in what way?
01:29:49 <tolkad> bearded
01:30:11 <BluShift1> Squatting, having a neckbeard, picking things off his feet during lectures, etc ad infinitum.
01:30:27 <shachaf> BluShift1: What does that have to do with colleges and universities?
01:30:40 <Ke> =D
01:30:44 <tolkad> shachaf: you don't know?
01:31:09 <shachaf> tolkad: What do you mean?
01:31:13 <dmwit> That seems like a developmental disability more than anything else to me. I don't think you can contract that kind of thing if you don't already have it.
01:31:18 <tolkad> shachaf: every day I have to spend three hours in a room getting shocked every time I touch a razor blade
01:31:20 <Jafet> I don't want to perpetrate a non-lexically scoped operating system on the world without writing a text editor for it first.
01:31:29 <tolkad> shachaf: I thought all universities did it
01:31:44 <BluShift1> University gets you the theory to really get into the nitty-gritty research and such, so you can push the envelope of modern computer science (Well, post-graduates, anyways) 
01:32:02 <dmwit> Jafet: What does lexical scoping mean when describing an operating system?
01:32:05 <tolkad> they might name a data structure after you
01:32:25 <shachaf> dmwit: It's an emacs joke.
01:32:39 <BluShift1> But a university graduate can't walk into a workplace and set up a Cisco network from scratch, with no training from your employer.
01:32:40 <dmwit> oh oh
01:33:09 <shachaf> Jafet: I don't think Stallman wrote VIPER, though, so emacsers had to wait for a while before they had a reasonable text editor. :-)
01:33:26 <tolkad> BluShift1: your supposed to be getting the practical experience on your own while in university
01:33:26 <Jafet> Well, if you can't grow a neckbeard, you can always target esr.
01:33:27 <BluShift1> In college, we don't understand all the theory, but we understand how to "get it done" so to speak.
01:33:36 <tolkad> BluShift1: either through hobby or internship, etc.
01:33:53 <tolkad> which is a reason many of us are in here
01:34:03 <BluShift1> tolkad: Sure.
01:34:27 <BluShift1> tolkad: College just gives you that experience in a condensed, rigorously standardized way.
01:34:34 <tolkad> I can't grow a beard yet : (
01:34:39 <Jafet> shachaf: it makes you think, though -- GNU has made two operating systems so far, but each of them missing an essential component
01:34:42 <tolkad> 19 years old and no chin hair
01:34:42 <BluShift1> tolkad: So that you're not missing pieces when you get to work place.
01:35:16 <Ke> BluShift1: I find that most things you have to learn by yourself anyways
01:35:20 <BluShift1> tolkad: I'm in a similar position. I feel your pain :P
01:35:31 <shachaf> tolkad: Why would you want a beard?
01:35:48 <tolkad> shachaf: so people will think I am good at unix
01:36:00 * shachaf calculates the #-blah percentage of the last page of IRC.
01:36:01 <BluShift1> Hah, Unix is dead.
01:36:09 <tolkad> BluShift1: lol no
01:36:18 <shachaf> BluShift1: Yes! Plan 9!
01:36:18 <Nibble> tolkad: is
01:36:36 <dmwit> Unix may be dead, but the mindset and toolset aren't.
01:36:42 <BluShift1> dmwit: So?
01:36:46 <Jafet> You can get a strap-on unix beard.
01:36:48 <tolkad> when I say unix
01:36:50 <BluShift1> "The spirit lives on!"
01:36:52 <tolkad> I mean unix-like OS
01:36:54 <BluShift1> You mean *nix
01:36:58 <tolkad> yes
01:37:05 <BluShift1>  /BSD
01:37:06 <tolkad> but nobody says *nix beard
01:37:10 <BluShift1> Hahaha
01:37:13 <BluShift1> touche.
01:37:15 <shachaf> I thought "*nix" was what people said to avoid trademark infringement.
01:37:23 <shachaf> tolkad: Is Plan 9 included in "unix-like"?
01:37:29 <tolkad> shachaf: idk
01:37:33 <BluShift1> I treat it as linux/unix/minix/whatever
01:37:38 <Nibble> there is actually this unix cert. thingie
01:37:41 <BluShift1> literally as a wildcard.
01:37:49 <Nibble> http://www.unix.org/
01:37:56 <BluShift1> The logo is sweet.
01:38:00 <Jafet> "linux" does not match *nix.
01:38:08 <BluShift1> Oh, touche again
01:38:10 <BluShift1> Whatever.
01:38:33 <tolkad> I have a license to use linux on my PC: http://www.sco.com/scosource/linuxlicensefaq.html
01:38:54 <tolkad> it's actually kind of expensive
01:39:00 <BluShift1> So many people just lurk this channel, hey?
01:39:26 <tolkad> $200 for a single desktop license
01:39:36 <BluShift1> That looks like utter bullshit, tolkad. Linux is FOSS.
01:40:00 <tolkad> BluShift1: it costs $4999 dollars for an 8 CPU server license
01:40:01 <shachaf> BluShift1: No, it has SCO's intellectual property.
01:40:20 <shachaf> BluShift1: It's illegal to run without SCO's permission.
01:40:23 <tolkad> except that SCO lost the lawsuit
01:40:26 <BluShift1> shachaf: Linux, or UNIX?
01:40:31 <tolkad> and they just keep the page up for suckers
01:40:34 <BluShift1> He said "Linux"
01:40:40 <shachaf> BluShift1: Yes, Linux.
01:40:44 <BluShift1> ...
01:40:48 <tolkad> BluShift1: yeah, SCO is just lying
01:40:55 <tolkad> BluShift1: they lost a lawsuit
01:40:58 <BluShift1> The Linux Foundation owns Linux, I thought.
01:40:58 <BluShift1> Oh.
01:41:14 <BluShift1> Did SCO ever own Linux? Why did they sue?
01:41:15 <tolkad> BluShift1: there was a lawsuit about it, SCO said linux contained their IP, SCO lost
01:41:26 <BluShift1> tolkad: Did it?
01:41:56 <dmwit> The courts say no.
01:42:12 <BluShift1> WE NEED TO SEE THE SOURCE.
01:42:33 <BluShift1> Tell SCO to just make their commercial product FOSS, then we can all check it for them :P
01:42:51 <tolkad> dmwit: SCO says there was a "final judgement" on their website, they neglect to mention what it was
01:43:01 <Jafet> Blah load: 1.21 0.78 0.46
01:43:18 <Nibble> load average: 0.83, 0.98, 0.97
01:43:20 <Nibble> load average: 0.83, 0.98, 0.97
01:43:22 <Nibble> oh shit
01:43:24 <Nibble> doublepaste
01:44:59 <BluShift1> Jafet: What is "Blah load"?
01:45:04 <shachaf> BluShift1: Are they teaching Haskell at your college, by the way?
01:45:10 <BluShift1> shachaf: Nope.
01:45:36 <BluShift1> tolkad: How long have you been working with Haskell?
01:45:56 <BluShift1> Actually, better question: How long has EVERYONE been working with Haskell?
01:46:45 <Jafet> @vixen is your Haskell long?
01:46:46 <lambdabot> Ooh, functional programmers are so hot!
01:47:09 <BluShift1> tolkad: And in response to "Do you want to work for money your whole life?" -- > Do you want to learn your whole life and live in poverty?
01:47:26 <dmwit> Sure!
01:47:31 <BluShift1> Oh good lord.
01:47:36 <Nibble> we want indeed
01:47:38 <Nibble> after all
01:47:40 <dmwit> Poverty here in America is still a pretty damn comfortable life.
01:47:52 <BluShift1> Not the poverty I see.
01:48:11 <tolkad> BluShift1: I'll do both :P
01:48:13 <dmwit> You can learn your whole life while living in a comfortable poverty.
01:48:31 <BluShift1> dmwit: Comfortable being a studio apartment at $500 a month?
01:48:41 <BluShift1> That's still cold cash. You gotta work for that.
01:48:51 * dmwit lives in a floor of a house at $1000/mo. and is currently in school
01:49:07 <augur> dmwit: ditto
01:49:25 <augur> not even the whole floor, either!
01:49:30 <tolkad> in Star Trek everyone does what they enjoy and lives comfortably
01:49:33 <BluShift1> Point in case.
01:49:39 <winxordie> Jeez, $1k? I guess I'm living cheaply in college.
01:50:46 <dmwit> (In case it wasn't clear, I'm not working outside of school, and am paying all my own bills. So I wasn't just making a specious claim: it's really, really possible.)
01:50:51 <BluShift1> If you live of life of poverty, you'll end up old and grumpy, with a large beard, muttering things like "Why can't everyone just say GNU/Linux? I wrote everything! Linux is just a kernel! *scowl* "
01:51:13 <tolkad> If only everyone would have a sustainable number of children, and nobody was corrupt, and we could properly distribute our resources, everyone could do what they enjoy and live comfortably
01:51:30 <Jafet> I'm guessing you only know Stallman by reading the 5 Funny slashdot posts about him
01:51:47 <BluShift1> tolkad: Unfortunately, the Pareto Principle exists :(
01:52:17 <Heffalump> dmwit: but you are working at school (i.e. teaching etc)?
01:52:19 <BluShift1> Jafet: I've never met the guy, so I only know what I read. However, I've never read anything about him from Slashdot.
01:52:28 <dmwit> Yes, that's true.
01:52:45 <shachaf> dmwit: Where are you geographically? Philadelphia?
01:52:52 <dmwit> Yes.
01:52:57 <wce> .
01:52:58 <tolkad> BluShift1: bah, those in power are just terrible at resource distribution, or corrupt
01:53:14 <tolkad> BluShift1: and those not in power can't stop having children
01:53:27 <BluShift1> tolkad: You know what they say: "Democracy is the worst form of government, unless you consider the alternatives"
01:53:31 <Jafet> blushift probably wouldn't survive a day of social life in the Culture.
01:53:49 <BluShift1> Jafet: What is "the Culture"?
01:54:11 <Jafet> Perhaps you should stop thinking about money for a minute and go learn what it is...
01:54:37 <BluShift1> Jafet: Stick in your ass? Maybe you need to go sleep, dude.
01:54:56 <tolkad> http://en.wikipedia.org/wiki/The_Culture
01:55:04 <b0fh_ua> Hi. I'm trying to install haskell platform from sources and getting this error: http://pastebin.com/itrETfnR
01:55:07 <b0fh_ua> can you please advice what can I do about it?
01:55:43 <dmwit> Oh, hah, that Culture.
01:56:13 <shachaf> b0fh_ua: Maybe try ghc-pkg hiding one of those packages?
01:56:14 <BluShift1> Jafet: I'm unfortunately not familiar, so if that was intended as an insult, it's fallen on deaf ears.
01:56:59 <b0fh_ua> how should I do that?
01:57:49 <dmwit> b0fh_ua: What version of GHC are you using?
01:58:02 <b0fh_ua> 6.12.3
01:58:21 <BluShift1> Anyways, bedtime for me.
01:58:34 <BluShift1> Thanks for your help shachaf, tolkad, and etc.
01:58:59 <BluShift1> I think taking a crack at LYAH tomorrow will be much easier, thanks you your patience with me :)
01:59:06 <JuanDaugherty> nite nite scowler
01:59:06 <BluShift1> to your*
01:59:19 <BluShift1> JuanDaugherty: Hah, what?
01:59:38 * dmwit didn't even know it was possible to build stm
01:59:53 <dmwit> I thought you just had to use the one that came with your copy of GHC.
02:00:04 <JuanDaugherty> If you live of life of poverty, you'll end up old and grumpy, with a large beard, muttering things like "Why can't everyone just say GNU/Linux? I wrote everything! Linux is just a kernel! *scowl* "
02:00:32 <BluShift1> JuanDaugherty: I don't understand how that makes me a "scowler" :P
02:00:39 <dmwit> b0fh_ua: Anyway, I'm not sure how to fix that problem. Perhaps ask in #ghc?
02:00:41 <shachaf> dmwit: Does compiling the Haskell platform from source include compiling GHC?
02:00:57 <JuanDaugherty> did'nt realize you were paroding stallman till I pasted
02:01:00 <Saizan> shachaf: no
02:01:08 <BluShift1> JuanDaugherty: Hah, ok.
02:01:14 <BluShift1> Anyways, goodnight everyone.
02:01:56 <Saizan> dmwit: stm doesn't seem to come with ghc anymore
02:02:16 <dmwit> wow
02:02:36 <dmwit> That sure doesn't seem like the kind of thing that can be done purely in library-land.
02:03:08 <Heffalump> you can do a lot with FFI
02:03:42 <Heffalump> though I guess RTS integration wouldn't be possible
02:04:22 <Saizan> i think GHC.Conc exposes a lot of dedicated primitives
02:04:54 <JuanDaugherty> parodying?
02:05:36 <dmwit> Looks funny, doesn't it?
02:05:52 <JuanDaugherty> yes. RTS = run time system?
02:06:09 <dmwit> yes.
02:09:00 * paolino wait a "inferrable" keyword to use where forall is used
02:11:02 <paolino> it's not modular to fix the classes of an existential. Is it right to think the type inferrer can fix them ?
02:14:13 <dmwit> I'm not sure what you mean.
02:14:40 <paolino> Every time I open an existential box and use the content, I possibly add a constraint on the value. I don't understand why I must set the constraint at definition time
02:15:36 <dmwit> ah
02:15:49 <paolino> it somewhat defeats the usefulness of existentials
02:16:06 <dmwit> Well, I mean, suppose you're sticking an Int into an existential, and the inference engine is supposed to guess what constraint to use.
02:16:42 <dmwit> Should it use exists a. Ord a? Or maybe Eq? How about Bounded? Enum? Or maybe a mixture, like exists a. (Integral a, Bounded a) => a.
02:16:58 <paolino> uhm it's not the type to set the constraint
02:17:01 <dmwit> Or maybe it should be even more specific... exists a. Int. =)
02:17:29 <shachaf> dmwit: Presumably it can look at how the value is used.
02:17:55 <paolino> it's the functions I  use on it
02:18:14 <dmwit> I see.
02:18:24 <b0fh_ua> does view pattern allow me to call a function on passed value and pattern match on result of this function?
02:18:29 <dmwit> So you'd want to give up on separate compilation, then?
02:18:38 <ski> b0fh_ua : yes, that's the point of it
02:18:40 <shachaf> b0fh_ua: Yes, that's what a view pattern is.
02:18:58 <paolino> dmwit. ah, that is the point, thanks
02:19:16 <shachaf> dmwit: That's admittedly an issue.
02:20:07 <ski> > let map _ [] = []; map f ((f -> a):(map f -> as)) = a:as in map (^2) [0,1,2,3]
02:20:08 <lambdabot>   [0,1,4,9]
02:20:46 <paolino> dmwit: that is why I wait for a new keyword :)
02:21:07 <ski> waiting for `exists' ?
02:21:18 <dmwit> > let map _ (null -> True) = []; map f (x:xs) = f x:map f xs in map (^2) [0..3] -- so weird
02:21:19 <lambdabot>   [0,1,4,9]
02:21:49 <dkannan> hi
02:22:01 <paolino> ski, if it infers the constraints for me, yes
02:22:25 <shachaf> > let map _ [] = []; map f ((\(a:as) -> f a : map f as) -> l) = l in map (^2) [0,1,2,3]
02:22:26 <lambdabot>   [0,1,4,9]
02:22:28 <dkannan> i am in a meetup of FP. what is the significance of http://en.wikipedia.org/wiki/Peano_axioms to FP
02:22:41 <b0fh_ua> nice, but how do I bind actual variable? For example, I have function funcA :: String -> Bool and then I do have another function funcB :: String -> String with definition as funcB (funcA -> True) = ...
02:22:52 <b0fh_ua> how do I get access to the passed value there?
02:23:35 <ski> paolino : i don't think inferring the constraints are sensible ..
02:23:42 <shachaf> > let f x@(succ -> y) = (x,y) in f 5
02:23:43 <lambdabot>   (5,6)
02:24:04 <dmwit> b0fh_ua: You probably just want something like
02:24:10 <dmwit> funcB xs | funcA xs = ...
02:24:26 <dmwit> > let f x | even x = 32 | odd x = 64 in map f [0..5]
02:24:27 <lambdabot>   [32,64,32,64,32,64]
02:24:30 <b0fh_ua> guards
02:24:41 <dmwit> indeed
02:24:44 <ski> > let f x | True <- even x = 32 | True <- odd x = 64 in map f [0..5]
02:24:45 <lambdabot>   [32,64,32,64,32,64]
02:24:57 <ski> (yay, pattern guards !)
02:25:10 <paolino> ski, I think I can go over with existentials of existentials, but I'm not sure it will not be an hack
02:25:34 * ski has no idea what paolino means by "existentials of existentials" ..
02:25:52 <dmwit> dkannan: It's a way to formalize arithmetic.
02:26:28 <dkannan> dmwit: but how does it help in FP
02:26:43 <dmwit> arithmetic?
02:26:45 <dkannan> dmwit: sorry, i do not know much about FP
02:26:52 <dkannan> dmwit: understanding FP
02:26:56 <paolino> ski, if I want to broad the constraint of an existential I must stick an existential in its value and implement the classes of the former for the latter
02:27:43 <dkannan> dmwit: talking to a prof. and he is asking me to take on faith that i need to know Peano before knowing FP
02:27:59 <tolkad> :t (->)
02:28:00 <lambdabot> parse error on input `->'
02:28:04 <Zao> From a theoretical standpoint, maybe it makes sense.
02:28:16 <tolkad> <dmwit> > let map _ (null -> True) = []; map f (x:xs) = f x:map f xs in map (^2) [0..3] -- so weird
02:28:19 <tolkad> what's null?
02:28:24 <dmwit> ?src null
02:28:24 <lambdabot> null []     = True
02:28:24 <lambdabot> null (_:_)  = False
02:28:47 <Zao> > let isZeListEmpty = null in isZeListEmpty "lol"
02:28:48 <lambdabot>   False
02:28:59 <Saizan> dkannan: let's put it the other way around, if you know FP then Peano arithmetics should be trivial to understand
02:29:01 <paolino> ski, not sure it works, it just came out
02:29:11 <dmwit> Understanding arithmetic seems pretty orthogonal to understanding function programming.
02:29:33 <shachaf> > let null l = length l == 0 && l == [] in null []
02:29:33 <lambdabot>   True
02:29:50 <dmwit> So most likely what he really means is, "I'm going to show you how to do arithmetic in a functional way, using Peano numbers".
02:29:52 <Zao> shachaf: I'd implement null through head and exception handling.
02:29:56 <Saizan> dmwit: really? data Nat = Z | S Nat; define addition/multiplication and a fold, that's Peano arithmetic
02:30:17 <dmwit> Saizan: really.
02:30:26 <dkannan> hmm... let me see how this goes
02:30:31 <tolkad> > ->
02:30:32 <lambdabot>   <no location info>: parse error on input `->'
02:30:34 <Saizan> so it's not orthogonal, one is a special case of the other
02:30:38 <tolkad> > id -> True
02:30:39 <lambdabot>   <no location info>: parse error on input `->'
02:30:44 <tolkad> > (id -> True)
02:30:45 <lambdabot>   Pattern syntax in expression context: id -> True
02:30:46 <dmwit> Saizan: I believe that you could understand functional programming without doing any arithmetic, provided you didn't have to write any programs that needed arithmetic.
02:30:48 <shachaf> Zao: But that wouldn't be O(n).
02:30:52 <Saizan> tolkad: it works only in patterns
02:31:23 <MiggyX> Anyone got any cool ideas for a Haskell research project? :)
02:31:27 <dmwit> > let null l = length l == 0 && l == [] in null [id] -- shachaf =)
02:31:28 <lambdabot>   False
02:31:34 <dkannan> if i have to know PNO to do arithmetic then this stuff is scary :-P
02:31:35 <dmwit> wait, what?
02:31:36 <astroboy> is there any documentation around about the LLVM module apart from the haddock generated one?
02:31:39 <tolkad> Saizan: what does it do?
02:31:39 <Saizan> dmwit: but you'd still need to learn ADTs and recursion, so the above would be just an application of what you know
02:31:43 <dmwit> :t let null l = length l == 0 && l == []
02:31:44 <lambdabot> <no location info>:
02:31:44 <lambdabot>     not an expression: `let null l = length l == 0 && l == []'
02:31:48 <dmwit> Saizan: Correct.
02:31:53 <shachaf> lambdabot has (==) for functions?
02:31:58 <dmwit> :t let null l = length l == 0 && l == [] in null
02:31:58 <lambdabot> forall a. (Eq a) => [a] -> Bool
02:32:05 <dmwit> :t id == id
02:32:06 <lambdabot> Bool
02:32:06 <shachaf> > id == id
02:32:07 <lambdabot>   *Exception: (==): No overloading for function
02:32:12 <Saizan> dmwit: i guess we disagree on what orthogonal means here.
02:32:15 <dmwit> oh, funny
02:32:18 <shachaf> ...Why do they do that?
02:32:21 <tolkad> > let f (id -> True) = [] in f x
02:32:22 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
02:32:22 <lambdabot>         against inferred type ...
02:32:24 <tolkad> > let f (id -> True) = [] in f 0
02:32:25 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
02:32:25 <lambdabot>    arising from the literal `0'...
02:32:31 <tolkad> > let f (id -> True) = [] in f False
02:32:31 <lambdabot>   *Exception: <interactive>:1:137-155: Non-exhaustive patterns in function f
02:32:41 <Saizan> shachaf: it's part of the Num instance for functions
02:32:45 <tolkad> > let f (id -> True) = []; f (id -> False) in f False
02:32:46 <lambdabot>   <no location info>: parse error on input `in'
02:32:50 <tolkad> > let f (id -> True) = []; f (id -> False) = [1] in f False
02:32:51 <lambdabot>   [1]
02:32:57 <shachaf> > ((*2) + (^2)) 3
02:32:57 <lambdabot>   15
02:33:08 <dmwit> Saizan: At least, Peano arithmetic doesn't seem like a prerequisite for FP, as this guy's prof is making it out to be. Can we agree that far?
02:33:08 <shachaf> Oh, hm. I didn't know about that.
02:33:20 <tolkad> oh so f (x -> False) = ... is the same as f x@False?
02:33:27 <dmwit> no
02:33:45 <shachaf> tolkad: No, it applies the function x to the argument and then pattern-matches the result against "False".
02:33:49 <tolkad> oh
02:33:52 <tolkad> that's useful
02:33:56 <tolkad> is it standard haskell?
02:34:02 <shachaf> No.
02:34:03 <Saizan> no
02:34:10 <tolkad> what extension?
02:34:16 <shachaf> -XViewPatterns in GHC.
02:34:24 <tolkad> thanks
02:34:38 <paolino> tolkad: I think they are useful when you don't want to export constructors but use pattern matching
02:34:57 <shachaf> paolino: And when you want to pattern-match on anything that isn't a constructor.
02:35:03 <ski> paolino : i'm not really sure what "it" referred to ..
02:35:28 <ski> dkannan : in some sense, you need to know Peano (or some other numeral representation) to *implement* arithmetic
02:36:23 <ski> dkannan : just *using* basic arithmetic operations doesn't require much in the vein of Peano numeral .. though if you want to use induction, you should know something about Peano numerals
02:37:19 <dkannan> ski: ok, he is actually speaking about induction although he has told told as such. successors and such
02:38:15 <Saizan> dmwit: i guess we can, i consider it a pretty nice stepping stone though
02:38:21 <ski> induction is basic, if you want to do proofs
02:38:40 <ski> recursion is also, more or less, the same as induction
02:40:04 * ski -> _|_
02:42:02 <paolino> ski, it refers to the idea of existentials of existentials, which possibly doesn't help me in broading the outside existential constraint
02:43:13 <ski> do you mean stuff like `exists a. Foo a (exists b. Bar a b)' ?
02:43:47 <ski> or maybe a value of type `exists a. Foo a' where the `a' in that particular case is another type `exists b. Bar b' ?
02:44:07 <paolino> yes this one
02:44:13 <ski> the latter ?
02:44:20 <paolino> the latter
02:44:23 <ski> ok
02:44:49 <ski> well, if you want to discuss this more, we could talk later .. currently, i need to leave, though
02:45:05 <paolino> ok
03:01:42 <dkannan> he is using gofer not haskell. not sure why goper is being used
03:01:54 <dkannan> does goper have a unix installation
03:05:13 <dkannan> sorry gofer not gopher 
03:19:50 <astroboy_> I'm having trouble linking a simple program using the LLVM module: http://hpaste.org/41007/llvm_linking_troubles . Does somebody know what is going on?
03:20:18 <hvr> is there an easy way to get something like the GHC version string from within a ghc compiled .hs file? e.g. for generating some build-info-string
03:21:22 <Saizan> hvr: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-Info.html
03:21:41 <hvr> Saizan: thx
03:21:50 <hvr> Saizan: I was searching within the GHC.* modules...
03:21:59 <alpounet> astroboy_, have you installed the LLVM programs and libraries (the C++ ones, I mean) ?
03:22:50 <astroboy_> alpounet: actually i am checking now and apparently llvm-gcc is not installed... stupid mistake
03:24:16 <alpounet> astroboy_, yeah it tries to find symbols from the LLVM library (C++), but doesn't, thus fails
03:36:57 <dkannan> http://www.haskell.org/haskellwiki/Future_of_Haskell how is the gofer type system more flexible than haskell
03:44:18 <augustss> dkannan: the differences are really minor
03:51:50 * hackagebot template 0.2.0.1 - Simple string substitution  http://hackage.haskell.org/package/template-0.2.0.1 (JohanTibell)
03:55:55 <hvr> if I have something like Data.Version.parseVersion, which is a ReadP; what's the best way to get a function of type :: String -> Version out of it?
03:56:21 <hvr> (or alternatively, :: String -> Maybe Version )
03:58:41 <hvr> so far, what I've come up doesn't look too good to me:
03:58:43 <hvr> listToMaybe [ p | (p, "") <- readP_to_S parseVersion "1.1.2-foo-bar" ]
04:01:03 <Saizan> you may want to accept only unique parses, but otherwise that's as good as any, i'd think
04:01:54 <hvr> there's no helper function for just wanting a unique and total parse?
04:03:18 <Saizan> if it's not in Data.Version or Text.*.ReadP i don't think so
04:22:40 <monadic_kid> dit MonadIO get standardized in Haskell2010?
04:22:45 <monadic_kid> *did MonadIO
04:28:37 <benmachine> monadic_kid: no, but it's in the Haskell Platform
04:28:50 <benmachine> monadic_kid: the libraries specified in the standard are minimal
04:31:53 <monadic_kid> cool as long as it's standard with HP
04:32:24 <monadic_kid> It's annoying everyone should use MonadIO in there libraries!
04:32:25 * hackagebot linux-ptrace 0.1.2 - Wrapping of Linux' ptrace(2).  http://hackage.haskell.org/package/linux-ptrace-0.1.2 (RichardSmith)
04:34:22 <tolkad> Is it considered bad to use overlapping instances?
04:34:32 <tolkad> or a standard extension
04:34:33 <tolkad> ?
04:35:08 <benmachine> @quote overlapping
04:35:08 <lambdabot> quicksilver says: overlapping actually shatters the language into tiny inconsistent pieces, and incoherent files off the edges of the pieces so they don't even fit together any more.
04:35:18 <benmachine> opinions differ
04:35:25 <benmachine> @quote overlapping
04:35:25 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
04:35:25 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
04:35:45 <tolkad> ok…
04:35:49 <benmachine> :P
04:36:03 <tolkad> it does seem a bit scary to use
04:36:12 <tolkad> I'll stay away from it :P
04:36:20 <benmachine> there are some interesting things you can do with it
04:36:32 <benmachine> so you might like to play with it
04:36:46 <benmachine> but often if you find yourself wanting it it's because your design is weird
04:37:04 <tolkad> I just realized it wouldn't even work
04:37:23 <Saizan> i like using them as a computation device, for cases where the idea is that you just define all the needed instances in one spot
04:43:11 <maurer_> Say I have f :: (SomeClass c) => A -> B c and g :: (SomeClass c) => B c -> C. Is there any reasonable way to compose these?
04:45:16 <Tomsik> What's wrong with g . f ?
04:45:34 <maurer_> Um, how does the compiler pick c?
04:45:51 <Tomsik> Oh, you mean like that
04:45:57 <maurer_> │age, B is a disassembled program image parameterized on c, the opcode type, SomeClass is an OpCode typeclass, and g is a function that takes it back from _│     │
04:45:59 <maurer_> err
04:46:03 <Tomsik> Well, isn't it implicit forall there?
04:46:10 <maurer_> Yes, there's an implicit forall.
04:46:20 <maurer_> Hrm.
04:46:26 <maurer_> Here, maybe I'm just designing poorly.
04:46:29 <Tomsik> and if you want to specify c, you can do g (f x :: B c)
04:46:38 <maurer_> Well, yes, but I was hoping to specify C programatically.
04:46:41 <maurer_> err, c
04:47:02 <maurer_> In this case A is a raw program section, and B is a program image disassembled with opcode type c
04:47:43 <maurer_> The A datatype in this case contains information on which opcode type is in use, and I want to use that to pick c in the case that it is not specified by a type constraint
04:48:02 <Twey> So long as the c's are the same, you can just use g . f… if not, you can't really compose them unless you restrict
04:48:15 <Twey> Oh, right, like that
04:48:28 <Twey> Ummm, fundeps maybe?
04:48:46 * Twey doesn't really understand fundeps/type families, but thinks they might do what you want.
04:48:51 <maurer_> OK, I'll look.
04:49:38 <maurer_> Alternatively, does someone know a better design for a pair of functions, one of which disassembles a raw image to produce one of several opcodes out, and a paired function that can take any of those outputs, and lift it to a platform independent version?
04:49:39 <benmachine> maurer_: keep in mind haskell is not dependently-typed, so types cannot be determined by values
04:50:01 <maurer_> benmachine: Yes. I am painfully aware and essentially trying to find a desgin-based way to get around that.
04:50:07 <maurer_> s/desgin/design/
04:50:28 <benmachine> hmm
04:50:42 <benmachine> so you want the output type of f to depend on the input value?
04:50:55 <maurer_> Ideally, but I don't think I can get that.
04:51:06 <benmachine> well, the easiest way is to have the output type be a sum type
04:51:12 <benmachine> Either Type1 Type2, or more
04:51:19 <benmachine> depending on how many possibilities there are
04:51:23 <maurer_> Well, yes, but then it is hard for me to add new ones.
04:51:24 <benmachine> existentials are also a possibility
04:51:54 <maurer_> I was hoping that just writing an "Instruction" instance would be sufficient for me to do this.
04:52:05 <maurer_> How would I do this with an existential?
04:52:34 <maurer_> Ah, nvm, I see how to do this with existentials.
04:52:38 <maurer_> I may do that.
04:53:19 <maurer_> That in fact makes a lot of sense. Thanks.
04:53:32 <maurer_> Err, hrm. One problem.
04:53:56 <tolkad> maurer_: well, which opcode do you want?
04:54:03 <maurer_> Is there a way, if the user knows what type it is going to disassemble to, for him to be able to specify c, and so access the actual values?
04:54:27 <tolkad> maurer_: what types determine the type c?
04:54:49 <maurer_> tolkad: Information in A, which is why dependent types would be lovely, but they are not available.
04:55:38 <benmachine> maurer_: how would someone specify c, if it depends on information provided to the function?
04:55:53 <tolkad> yes this doesn't make sense
04:56:17 <tolkad> maurer_: how can it have a polymorphic return type if it is determined from A
04:56:33 <maurer_> benmachine: In a type signature. Not a great interface, but I'm trying to separate out the opcode dependent stuff into its own area, while allowing the user to potentially view c
04:57:22 <benmachine> maurer_: but I mean, if someone specified c then c would no longer depend on the information from A, it would be concrete and unchangeable
04:57:35 <tolkad> maurer_: so what happens if you put an annotation for the wrong c?
04:58:08 <tolkad> maurer_: this doesn't make sense
04:58:18 <tolkad> maurer_: information in A cannot determine the type c
04:58:24 <maurer_> I'm thinking along the lines of: http://hpaste.org/41008/mockup
04:58:33 <pkrumins> hey guys, how do you install cabal itself?
04:58:39 <maurer_> tolkad: Yes, I've already moved on and am thinking about existential types instead.
04:58:46 <pkrumins> all the tutorials are on how to install 'a package' with cabal
04:58:51 <tolkad> pkrumins: it comes with the haskell platform
04:59:00 <pkrumins> oh i see
04:59:04 <pkrumins> i wonder why it's not in my path though
04:59:09 <benmachine> pkrumins: do you mean the cabal-install tool?
04:59:15 <maurer_> benmachine: Assuming I386Op were a member of Instruction, would the above work?
04:59:32 <pkrumins> benmachine: i am actually not sure, i haven't used it in the past much
04:59:48 <pkrumins> but i wish to get xmonad running and its tutorial says to install x11 package via cabal
04:59:48 <benmachine> maurer_: no, I might have built prog with a different member of Instruction
05:00:06 <benmachine> pkrumins: ah, you probably do
05:00:07 <tolkad> maurer_: no, it doesn't make sense, if you have « f :: SomeClass c => A -> B c » then no matter what information is held in the type "A",  c can be any member of class SomeClass
05:00:13 <benmachine> I don't use the HP so I don't know where it puts it
05:00:20 <tolkad> maurer_: the type c cannot be determined by information in A
05:00:27 <pkrumins> so if i installed haskell correctly i should have it in path?
05:00:39 <maurer_> tolkad: As I said, I've moved on. I'm using f :: A -> B where B is an existential type.
05:00:41 <benmachine> pkrumins: depends on what exactly you installed
05:00:49 <tolkad> oh
05:00:57 <maurer_> benmachine: True. Any ideas on how I might do this then?
05:01:01 <benmachine> maurer_: if B is an existential type, you don't know what type is inside it; all you know is that it is the member of that typeclass
05:01:10 <pkrumins> benmachine: i use osx so i used `brew install ghc`
05:01:23 <benmachine> pkrumins: ah, then you haven't got cabal-install
05:01:34 <pkrumins> oic, yes it seemed so.
05:01:39 <maurer_> pkrumins: Use the OSX installer. Brew won't get everything you want. (We still do have a standalone installer, right?)
05:01:53 <tolkad> yeah, I used it
05:01:55 <pkrumins> got it
05:02:06 <pkrumins> i thought the packages would be similar
05:02:08 <benmachine> pkrumins: you can fetch cabal-install directly from http://hackage.haskell.org/package/cabal-install but there might be an easier way (i.e. listening to everyone else)
05:04:38 <maurer_> Hrm. I need a better design.
05:06:44 <tolkad> maurer_: so the opcode set for each system is a different type?
05:07:05 <sipa> use an associated type?
05:07:37 <maurer_> tolkad: Yes.
05:07:39 <tolkad> maurer_: why not have « data Instruction = InstructionType1 OpcodeType1 | InstructionType2 OpcodeType2 … »
05:07:56 <nus> maurer_,  "lift it to a platform independent version"? that boils down to writing a(nother) platform
05:08:33 <maurer_> nus: Yes, it does. However, if I want to write reasoning that works on X86 programs and on ARM programs, I need to do that.
05:09:14 <nus> maurer_, don't overgeneralize... write specific reasoning you want, then lift
05:09:36 <maurer_> nus: I would agree, but I already know I have to reason about I386, X86_64, and ARM.
05:09:55 <nus> maurer_, the argument still holds
05:10:13 <maurer_> nus: Hm?
05:10:17 <tolkad> maurer_: why not have « data Instruction = InstructionType1 { instructionOpcode :: OpcodeType1 } | InstructionType2 { instructionOpcode OpcodeType2 } » then you can have « f :: A -> Instruction; g :: Opcode c => c -> IndependentInstruction; composed = g . instructionOpcode . f »
05:11:02 <benmachine> instructionOpcode can't have multiple return types
05:11:12 <tolkad> whoops
05:11:51 <tolkad> you'll have to do some pattern matching in composed then
05:11:55 <tolkad> but it should still be fine
05:12:45 <maurer_> Yeah. I was just trying to see if there were a way to write this such that all I would need to add to get another instruction set into the system was another Instruction instance, as that seemed really cool/clean
05:12:51 <tolkad> or write handleInstructionOpcode :: (Opcode c) => (c -> a) -> Instruction -> a
05:15:58 <tolkad> maurer_: you could do that with an existential
05:17:38 <maurer_> How about: http://hpaste.org/41009/mockup2
05:17:41 <maurer_> Less crazy now?
05:18:13 <maurer_> Err, nvm, second one can't be called as is
05:19:19 <will> anyone else getting errors trying to use the mailing list interface?
05:20:18 <maurer_> http://hpaste.org/paste/41009/mockup2fixed#p41010
05:20:21 <maurer_> How's that?
05:21:03 <nus> will, does it say something about no space left on the device?
05:21:24 <will> I get "Bug in Mailman version 2.1.5
05:21:25 <will> We're sorry, we hit a bug!"
05:21:33 <will> if I try and do anything
05:21:56 <pkrumins> oh nice, so i got cabal-install package and it was just a matter of sh bootstrap.sh to get it installed
05:22:55 <will> tried in chrome and ff just in case
05:23:04 <will> also tried reregistering a new email address
05:23:06 <will> same error
05:30:48 <will> even when I use stealth mode on chrome I get the same error
05:30:57 <will> I think it's server-side
05:31:11 <will> can anyone change one of their settings on any of the haskell mailing lists?
05:32:22 <maurer_> http://hpaste.org/paste/41009/solution#p41011
05:32:26 <maurer_> So that actually runs.
05:32:44 <maurer_> If I replace "even" with a predicate for which opcode to use, I think this makes sense.
05:32:50 <McManiaC> is chris done here?
05:34:50 <alpounet> preflex, seen chrisdone
05:34:50 <preflex>  chrisdone was last seen on #haskell 1 day, 30 minutes and 46 seconds ago, saying: granted, it could've been spontaneous beautification
05:35:19 <ray> i don't know if chris is done here, ask him yourself
05:35:22 <McManiaC> kk
06:18:22 <maurer_> @djinn [a -> b] -> a -> [b]
06:18:23 <lambdabot> Error: Undefined type []
06:18:32 <maurer_> :(
06:18:38 <sipa> @djinn a -> b
06:18:39 <lambdabot> -- f cannot be realized.
06:20:01 <maurer_> Nvm, found it, I meant \x y -> map ($y) x
06:20:50 <hpc> yay for sections of ($)
06:22:54 <Twey> flip map . flip id
06:23:09 <Twey> :t on
06:23:10 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
06:23:32 <Twey> Hmph
06:23:45 <maurer_> flip map . flip id doesn't parse in ghci
06:23:47 <Twey> Once again, I can't write ‘on fmap flip map id’ :-\
06:23:56 <Twey> :t flip map . flip id
06:23:57 <lambdabot>     Couldn't match expected type `[a1 -> a]'
06:23:57 <hpc> :t \map id -> flip map . flip id
06:23:57 <lambdabot>            against inferred type `a2 -> a2'
06:23:57 <lambdabot>     In the first argument of `flip', namely `id'
06:23:58 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *) a b1. (Functor f, Functor f1) => f (f1 b1 -> b) -> f1 (a -> b1) -> a -> f b
06:24:02 <Twey> Hmph
06:24:05 <nus> @type map ($(?y)) ?x
06:24:06 <lambdabot> forall a b. (?x::[a -> b], ?y::a) => [b]
06:24:21 <maurer_> Why pointfree it?
06:24:42 <hpc> @pl \map id -> flip map . flip id
06:24:42 <lambdabot> (. flip) . (.) . flip
06:26:51 <maurer_> If someone else has written a module that raises a UserError on a parser failure, is there a good way to lift their function to f :: foo -> Maybe bar, where the Maybe condition is whenever they raise a UserError?
06:26:53 <Twey> flip fmap (flip id) . flip fmap
06:28:20 <Twey> flip $ fmap . flip id
06:28:29 <hpc> maurer_: UserError is an exception, and foo is in IO?
06:28:38 <Twey> maurer_: Because it's simple enough that it begs to be point-free'd
06:28:41 <hpc> because then it's easy
06:29:19 <Twey> And lambdas are ugly ☺
06:30:17 <pkrumins> so i have been following the guides how to get xmonad running on osx, and at one point it says 'launch X11'
06:30:32 <monadic_kid> Hayoo down again :/
06:30:35 <pkrumins> but i dont' have such program anywhere, i have X and all kinds of other Xthings but not X11 exactly
06:30:42 <pkrumins> any tips on that?
06:30:58 <maurer_> hpc: No, foo is not in IO
06:31:02 <hpc> pkrumins: what version of X do you have?
06:31:08 <hpc> pkrumins: is it 11? :P
06:31:11 <pkrumins> oh
06:31:11 <maurer_> hpc: They should not have used UserError, but I don't want to port their package.
06:31:32 <pkrumins> hpc: well how do I find it out? X --version does not report the version
06:31:33 <hpc> maurer_: then i am at a loss; exceptions are yuck, so i don't touch them
06:31:53 * pkrumins strings X 
06:31:58 <maurer_> hpc: Yeah, but I don't want to write an ELF file format parser, and some other guy already did it.
06:32:11 <pkrumins> oh i see: `which X` -> /usr/X11/bin/X
06:32:18 <maurer_> However, I don't want to instantly explode if it turns out to not be an ELF file.
06:32:24 <pkrumins> okay, launching X ;)
06:33:04 <Heffalump> at some point in the development of the X windows system, the absolute version seems to have stalled at 11.
06:33:11 <pkrumins> oh snap,
06:33:13 <pkrumins> $ xmonad 
06:33:13 <pkrumins> /Users/pkrumins/.xmonad/xmonad-i386-darwin: executeFile: does not exist (No such file or directory)
06:33:14 <maurer_> I'm thinking of using http://hpaste.org/41013/maybeerror
06:33:42 <maurer_> It _should_ be safe as no IO is performed other than catching their silliness.
06:34:24 <hpc> yeah, i think so
06:34:38 <hpc> if anything, your unsafePerformIO is making it /more/ safe
06:35:34 <hpc> in fact, that would be a handy function to have in Prelude
06:35:41 <hpc> catchToMaybe
06:36:31 <hpc> if nothing else, it makes recovering from someone else's poor design not require nearly as much experimentation
06:37:38 <Heffalump> there is a reason catch is in IO..
06:37:59 <Heffalump> it's fine to wrap specific things with good reason, but encouraging indiscriminate wrapping is rather more dubious
06:38:10 <hpc> there's a reason for exceptions to stay in IO too...
06:38:52 <Heffalump> in general you would need to do a deepseq to guarantee consistent results
06:39:02 <maurer_> Heffalump: I know the correct answer to this is that parseElf should not trigger an error, but what would you suggest here?
06:39:30 <Heffalump> maurer_: no, I agree with you here
06:39:42 <Heffalump> I was just challenging hpc's statement that catchToMaybe should be in Prelude
06:40:06 <Heffalump> I said "it's fine to wrap specific things with good reason"
06:40:36 <maurer_> OK. I would really prefer to not do this, but I simply don't have a better idea.
06:40:48 <hpc> i disagree that Prelude implies "indiscriminate", but it's probably not the module for it anyway
06:41:08 <Heffalump> I think being in the Prelude implies "this is a very standard function that can be used at will"
06:41:22 <Heffalump> you know, like head ;-)
06:41:56 <bremner> should have been called foot, as in shoot
06:44:00 <Twey> Heh.
06:45:18 <Twey> I think we should remove ‘head’ and ‘tail’ and replace them with list :: b -> (a -> [a] -> b) -> [a] -> b
06:45:51 <Heffalump> otherwise known as pattern-matching..
06:46:19 <Twey> Pattern-matching requires defining a whole new function, which isn't always appropriate
06:46:31 <Twey> That's why we have things like ‘maybe’
06:46:33 <bremner> one can use case?
06:46:43 <Twey> bremner: Sure, but would you really want to?
06:46:47 <Heffalump> or a case. But sure, list is useful. But it's closer to pattern-matching than it is to head/tail.
06:47:22 <Twey> maybe r t v is much nicer than case v of Nothing -> r; Just x -> t x
06:47:26 <hpc> also, list won't fail when you give it []
06:47:44 <Twey> Heffalump: Sure.  That's the point.
06:48:04 <Heffalump> so essentially what you mean is that we should remove head and tail.
06:48:07 <Twey> Heffalump: It also doesn't leave open the option of forgetting to define a [] case, like pattern-matching does.
06:48:19 <Twey> … and replace them with list, yes.
06:48:49 <Heffalump> I'm saying that list is unlikely to be a useful replacement for most of the uses of head/tail.
06:49:01 <Twey> Most of the *valid* uses of head/tail.
06:49:13 <Twey> I'd still keep them around in Data.List or something.
06:49:19 <Twey> Just not in the Prelude.
06:49:23 <Heffalump> it's unlikely to be a useful replacement for *any* of the valid uses. I think most uses are valid.
06:49:30 <Heffalump> (except by newbies etc of course)
06:50:22 <Heffalump> I'd be fine with removing it from the Prelude
06:51:42 <Twey> Sure it is a useful replacement.  [head, tail] = map (list $ error "Empty list") [const, const id]
06:52:27 <Twey> It just requires you to think about what should happen if it's not what you expect, and leaves open the option of adding a graceful fallback without all the syntactic overhead of creating a new function and pattern-matching.
06:52:46 <Twey> (yeah, I know, hetero list, &c.)
07:09:21 <tibbe> Any Windows developers around? I need someone to compile the latest network package release to make sure it works on Windows.
07:10:47 <Heffalump> Twey: list is way more syntactic overhead than head/tail
07:11:06 <Twey> But much less than pattern-matching.
07:12:34 <nus> maurer_, http://augustss.blogspot.com/2007/06/disassembly-harpy-package-also-contains.html
07:13:18 <tibbe> No Windows developers? :(
07:14:30 <maurer_> nus: Yes, I intend to use that for disassembly.
07:14:34 <maurer_> Thanks though :)
07:14:59 <new-lisper> tibbe: why are you sad? that's great ;)
07:15:09 <new-lisper> tibbe: and no, i cannot test it
07:15:24 <tibbe> new-lisper: someone is gonna yell at me when a core package doesn't build on their machine
07:15:28 <new-lisper> tibbe: my only windows computer is way to slow to compile anything
07:15:40 <tibbe> new-lisper: darn
07:16:19 <maurer_> My only windows computer is this one... I'd have to reboot and become non-useful for the duration of the tests :/
07:16:48 <Heffalump> I do have a windows machine, but I don't use it for development normally.
07:16:57 <Heffalump> I guess if you're getting desperate I could try it
07:17:58 <monadic_kid> tibbe: can you get a copy of windows? why don't use a virtual machine like virtualbox
07:18:00 <tibbe> Heffalump: well, I have a tarball that I need building and I plan to sit around on IRC until someone can build. After that I'll make the combined network/network-bytestring release.
07:18:13 <tibbe> monadic_kid: I don't have a copy anymore
07:23:24 <hpc> tibbe: what are the depends of your tarball?
07:23:34 <hpc> i have ghc on this windows box, but i can't get cabal working
07:24:09 <hpc> (64-bit windows 7, if it matters)
07:24:38 <tibbe> hpc: bytesintr
07:24:41 <tibbe> bytestring*
07:24:58 <tibbe> hpc: actually: bytestring and parsec
07:25:26 <hpc> oh hey, cabal is working!
07:25:33 <hpc> downloading
07:25:56 <hpc> link to the tarball?
07:26:30 <tibbe> hpc: http://johantibell.com/files/network-2.2.3.tar.gz
07:29:06 <hpc> @where pastebin
07:29:07 <lambdabot> http://rafb.net/paste
07:29:15 <tibbe> I guess it failed ;)
07:29:18 <hpc> yeah
07:29:41 <hpc> and rafb.net seems to think the index needs content-disposition: attachment :/
07:29:56 <hpc> http://faid.pastebin.com/ydzWKnQD
07:30:29 <tibbe> hpc: looking into it
07:31:02 <hpc> i haven't updated in forever though
07:31:07 <hpc> so it could just be me
07:32:06 <hpc> bah, can't do "cabal upgrade" :/
07:33:41 <tibbe> hpc: is include/HsNet.h in the unpacked dir?
07:33:44 <tibbe> it should be
07:34:00 <hpc> yes
07:34:27 <monadic_kid> tibbe: can't find hsnet.h for me
07:35:02 <tibbe> monadic_kid: ls include/
07:35:10 <tibbe> monadic_kid: inside the unpacked source
07:35:17 <monadic_kid> tibbe:yes
07:35:56 <tibbe> monadic_kid: not there?
07:36:02 <monadic_kid> tibbe:yes
07:36:06 <tibbe> monadic_kid: ok, good
07:36:17 <tibbe> hpc: can you run cabal configure -v please?
07:36:23 <monadic_kid> tibbe: i need to run autotools, haven't done that yet
07:36:24 <tibbe> hpc: and paste the results
07:36:30 <tibbe> monadic_kid: you shouldn't have to
07:36:50 <tibbe> monadic_kid: but you can try to run autoreconf in the dir before cabal configure and see if that makes a difference
07:37:08 <hpc> http://faid.pastebin.com/Fw7AChQw
07:37:22 <hpc> oh wait, derp
07:38:17 <nus> tibbe, it builds fine here (MINGW32_NT-5.2 i686, GHC 6.12.1) 
07:38:25 <tibbe> nus: interesting
07:38:27 <hpc> http://faid.pastebin.com/Vj6Vktic
07:38:33 <hpc> oh that explains it
07:38:34 <tibbe> hpc: I wonder if it's a win 7 thing
07:38:40 <tibbe> although that's slightly weird
07:38:40 <hpc> i am lacking mingw
07:38:49 <tibbe> hpc: is your version of cabal really old?
07:38:54 <hpc> tibbe: about a year, i think
07:39:03 <tibbe> hpc: that should be ok
07:39:06 <hpc> it doesn't want to update itself either
07:39:33 <nus> hpc, "cabal: The package has a './configure' script. This requires a Unix
07:39:34 <nus> compatibility toolchain such as MinGW+MSYS or Cygwin."
07:39:46 <tibbe> cabal: The package has a './configure' script. This requires a Unix
07:39:47 <tibbe> compatibility toolchain such as MinGW+MSYS or Cygwin.
07:39:49 <tibbe> hpc: ^^
07:39:52 <nus> :-)
07:39:54 <hpc> yeah, i see :P
07:40:08 <tibbe> so then it seems to build fine on windows then, given you have mingw
07:40:13 <tibbe> nus: right?
07:40:34 <nus> tibbe, well, you have the specifics (-;
07:40:43 <tibbe> nus: right
07:40:59 <tibbe> nus: (I have no idea what MINGW32_NT-5.2 stands for)
07:41:04 <tibbe> I read that as: windows
07:41:05 <nus> tibbe, uname -a
07:41:16 <tibbe> xp, 7, etc?
07:41:31 <Heffalump> is mingw a requirement for using GHC on windows?
07:41:32 <Zao> 5.2 would be 2003 or XP64.
07:41:40 <Zao> 5.1 is XP, 5.0 is 2k.
07:41:40 <ezyang> Heffalump: sorta. 
07:41:45 <monadic_kid> ghc comes with it's own build of mingw
07:41:51 <ezyang> Heffalump: GHC comes packaged with it. 
07:41:53 <nus> tibbe, checking build system type... i686-pc-mingw32
07:42:21 <nus> tibbe, this's server 2003
07:42:28 <tibbe> nus: ok, thanks
07:42:47 <tibbe> I will go ahead and release the new version of the network package, now with new bytestring goodness!
07:42:56 <nus> tibbe, you're welcome
07:43:53 <monadic_kid> tibbe: you just need to state that if you don't have mingw already installed and try to use the one that comes with mingw you'll need to specify it to the configure script
07:44:08 <monadic_kid> tibbe: *comes wtih ghc
07:45:03 <tibbe> monadic_kid: I hope to clean up the build process of network some day, not today however, it requires lots of work and better knowledge of autotools
07:45:12 <tibbe> the idea is that you should get network through HP on Windows
07:46:36 <monadic_kid> tibbe: this the problem with haskell on windows, pure haskell libraries are fine but when it comes to libraries that depend on C libraries it's fecked on windows
07:47:31 <tibbe> monadic_kid: right
07:47:58 <monadic_kid> tibbe: it's a lot better than it use to be but i don't bother anymore because no body tests there stuff on windows so I use linux on a virtual machine
07:49:12 <maurer_> So, I've written this function in several projects, and am now curious as to why we don't have it (anywhere I can find): chunk :: Int -> [a] -> [[a]] where the first parameter is a length, and it breaks the list up into chunks of that size, with one potentially undersized chunk at the end.
07:49:38 <Twey> maurer_: Data.List.Split.chunk, in the ‘split’ package.
07:49:46 <tibbe> monadic_kid: I don't have the luxury to not care about windows for the network library as I maintain it on behalf of the whole community
07:51:25 <maurer_> Durr. Sorry, my bad.
07:51:28 <monadic_kid> tibbe: we need more contributors with the same attitude
07:51:42 <tibbe> monadic_kid: we also need more windows maintainers!
07:51:58 <tibbe> monadic_kid: I get flak when network breaks on windows but noone is ever willing to help maintain it
07:53:29 <Eduard_Munteanu> @hoogle Int -> [a] -> [[a]]
07:53:30 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
07:53:30 <lambdabot> Prelude drop :: Int -> [a] -> [a]
07:53:30 <lambdabot> Prelude take :: Int -> [a] -> [a]
07:53:42 <Eduard_Munteanu> Meh.
07:56:12 <monadic_kid> is llvm the default backend for ghc 7?
07:56:28 <dolio> No.
07:56:52 <monadic_kid> i'm sure i read that some recently
07:58:53 <Heffalump> I think someone misclaimed that fact somewhere.
07:58:59 <Heffalump> I saw that too, but I'm sure it's not true
08:00:10 <monadic_kid> it comes with LLVM backend,maybe it's not the default backend
08:02:38 * hackagebot network 2.2.3 - Low-level networking interface  http://hackage.haskell.org/package/network-2.2.3 (JohanTibell)
08:05:44 <monadic_kid> http://www.reddit.com/r/haskell_proposals/comments/dz30s/simd_ssealtivecetc_intrinsics/
08:08:32 <Eduard_Munteanu> Well, it doesn't mean it's default.
08:09:37 <monadic_kid> Eduard_Munteanu: I just posted that
08:10:01 <monadic_kid> Eduard_Munteanu: that wasn't meant to be a link that say it is lol
08:11:05 <Eduard_Munteanu> Ah, nevermind... I saw your previous message on the LLVM backend.
08:11:23 <monadic_kid> i thought so
08:11:42 <Phyx-> I'm trying to parse errors and warnings given out by cabal-install. however they lack any structure, it's hard to automatically determine where they start and end. does anyone have any suggestions on how to approach this?
08:12:49 <Axman6> mjonsson: i already have a ticket on tarac asking for that, and it's been very active in the past few days
08:13:05 <Axman6> uh, monadic_kid, not mjonsson 
08:13:30 <monadic_kid> Axman6: link please!
08:13:32 <Axman6> http://hackage.haskell.org/trac/ghc/ticket/3557
08:14:15 <paolino> Is there a simple description of what undecidable instances are and when it's ok to use them ?
08:15:14 <nus> Phyx-, hack the source
08:15:23 * Axman6 -> sleep
08:15:40 <paolino> this for example needs them, but I can't understand why "instance MonadState s m => Peek m s where"
08:16:22 <maurer_> Someone had an article on making Cabal not build things twice when you have a library and a binary that uses that library in the same package. Anyone remember where that was?
08:17:04 <Twey> @quote undecidable
08:17:04 <lambdabot> RossPaterson says: I'm afraid you voided the warranty when you used UndecidableInstances.
08:18:05 <Phyx-> nus: i'm trying to avoid that... If the patch is not accepted for instance (for one, how would I justify it) the burdance of maintaining it falls on me
08:18:17 <Phyx-> ghc has warranties?
08:19:19 <paolino> to terminate, I guess
08:19:30 <Phyx-> it doesn't always honor that..
08:19:55 <Jafet> Phyx: have you used undecidable instances?
08:20:55 <paolino>    Constraint is no smaller than the instance head, looks like there is no clear path 
08:24:06 <Phyx-> Jafet: not always
08:24:31 <Jafet> Well, you only need to tear the sticker off once to void the warranty
08:24:43 <Phyx-> hahahah
08:24:45 <Jafet> -fglasgow-warranty-sticker
08:25:13 <Eduard_Munteanu> "Do you have blood on your hands?" -- "Not every day."
08:25:27 <Eduard_Munteanu> Really now.
08:28:14 <Phyx-> Eduard_Munteanu: well, you can wash it off, and if the subject hasn't died, the wound would heal
08:29:00 <Eduard_Munteanu> Heh, I guess the warranty sticker grows scar tissue over time too.
08:31:11 <sid3k> hi all. is it possible to make a variable act like a property with getter behaviour?
08:31:40 <Eduard_Munteanu> sid3k: have you looked at record syntax?
08:31:47 <sid3k> I'm just trying to configure my xmonad and not interested at haskell at all, but I just wonder
08:31:50 <sid3k> Eduard_Munteanu: nope
08:31:59 <Eduard_Munteanu> It goes something like...
08:32:10 <sid3k> could you give a simple example ?
08:32:39 <Eduard_Munteanu> data YourDataStructure a = YourDataStructure { prop1 :: Int, prop2 :: String }
08:33:08 <ClaudiusMaximus> > 460 * 320 * 240 * 4 / 1024 / 1024
08:33:08 <lambdabot>   134.765625
08:33:08 <Eduard_Munteanu> um, data YourDataStructure = YourDataStructure { prop1 :: Int, prop2 :: String }
08:33:23 <sid3k> Eduard_Munteanu: it seems it's not what I'm looking for 
08:33:35 <Eduard_Munteanu> If you have such a foo, you can do 'prop1 foo' to get the property prop1 from foo :: YourDataStructure
08:33:59 <sipa> sid3k: maybe it helps if you explain what you want to do exactly
08:34:12 <sid3k> sipa: I'm trying to configure xmonad
08:34:20 <Eduard_Munteanu> where prop1 :: YourDataStructure -> Int, it's indeed a function
08:34:39 <Eduard_Munteanu> sid3k: what exactly?
08:34:39 <sid3k> and want to make a variable storing color code dynamic
08:34:57 <sipa> and in function of what?
08:35:01 <Eduard_Munteanu> sid3k: how dynamic? To be able to update it?
08:35:04 <sipa> or what do you mean by dynamic
08:35:32 <sid3k> like getters and setters
08:35:39 <sid3k> for example
08:36:00 <Phyx-> why is record syntax not what you want?
08:36:10 <sid3k> border color = (lambda: random()...) 
08:36:23 <sid3k> Phyx-: because there is no structure
08:36:57 <Phyx-> sid3k: I don't understand what you mean with there's no structure
08:37:40 <Eduard_Munteanu> He seems to want the border color to be a function.
08:38:00 <sid3k> Phyx-: sorry, I guess I'm missing the whole thing. I'm not familiar with haskell
08:38:02 <Eduard_Munteanu> e.g. get a random value everytime
08:38:14 <monadic_kid> sid3k: record types generate functions for the fields, you can decompose and update them using record patterns. If you need need more powerful labels that can work with nested structures or monads like state monad have a look libraries like fclabels
08:38:43 <sipa> monadic_kid: i fear that explanation won't help if he isn't interested in haskell itself :)
08:39:16 <Eduard_Munteanu> sid3k: what does the color depend on? Is it random, does it need IO?
08:39:17 <sipa> sid3k: you really want it to be random, or is that just an example now?
08:39:40 <Eduard_Munteanu> It's easier if not.
08:41:48 <Eduard_Munteanu> sid3k: the pattern here is you'll create the configuration structure in such a way to depend on that value
08:42:14 <Phyx-> :t id
08:42:15 <lambdabot> forall a. a -> a
08:42:19 <MiggyX> Anyone else think functional languages are the future? :)
08:42:34 <Phyx-> :t fmap (<$>)
08:42:35 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
08:42:58 <Phyx-> :t pure
08:42:59 <Jafet> Functional languages are timeless.
08:42:59 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
08:43:04 <Eduard_Munteanu> So instead of thinking in terms of border as a function, think of it as a value and do partial application: myConfig value = config { border = value, ... }
08:43:08 <Phyx-> :t fmap (<$>) (pure id)
08:43:09 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (f a -> f a)
08:43:18 <Phyx-> lol,
08:43:24 <Eduard_Munteanu> erm, scratch partial application.
08:43:26 <sipa> :t pure
08:43:27 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
08:43:48 <maurer_> Anyone know how to tell Cabal that I want to build the library, then build the executable without rebuilding the library and just link against the one it built?
08:44:08 <Eduard_Munteanu> MiggyX: I'm not sure "functional" is scary here, rather purity.
08:44:28 <Eduard_Munteanu> And perhaps laziness.
08:44:34 <monadic_kid> totailitiy?
08:44:39 <Phyx-> :t pure id
08:44:40 <lambdabot> forall a (f :: * -> *). (Applicative f) => f (a -> a)
08:44:47 <Eduard_Munteanu> monadic_kid: heh if that were the case, yes.
08:44:53 <Phyx-> where does that Applicative come from..
08:45:14 <Eduard_Munteanu> Lisp `less_scary_than` Haskell `less_scary_than` Agda :)
08:45:19 <MiggyX> Eduard_Munteanu: I agree - I think it will become much harder to address massively multi-core systems with imperative languages
08:45:39 <monadic_kid> *totality
08:45:42 * Phyx- calmly waits for quantum computers and the holodeck
08:45:54 <Jafet> let cmp = comparing scariness
08:46:49 <monadic_kid> in one of John Carmacks twits he mentioend he wished that C++ had way to annotate functions as side-effect free
08:47:08 * Eduard_Munteanu envisions related industries: quantum spam, quantum porn, ...
08:47:15 <monadic_kid> Well the ideal would be the other way around of-course
08:48:13 <Eduard_Munteanu> He might or might not be a Nigerian... reading his mail collapses the wavefunction, but before that he's both.
08:48:25 <MiggyX> I wonder if it could be proven that imperative languages cannot scale beyond X cores
08:48:36 <rubendg> Hi guys. Is it possible to somehow view the code that ghc generates for derived instances?
08:49:13 <Eduard_Munteanu> MiggyX: it's rather psychology than actual CS.
08:49:20 <Eduard_Munteanu> MiggyX: so no proof there.
08:50:43 <Eduard_Munteanu> Empirical data might support that though.
08:51:14 <MiggyX> Eduard_Munteanu: True enough, but I think it is commonly accepted that using assembler doesn't scale beyond a certain complexity threshold
08:51:26 <MiggyX> though of course it's not impossible as such - just insanely difficult and pointless
08:51:35 <MiggyX> maybe then a point of "no return" could be defined instead 
08:51:42 <MiggyX> but then even that would probably be subjective
08:51:47 <Eduard_Munteanu> Yeah.
08:52:37 <dolio> Hugely parallel machines have been around for a while now. It's only relatively new in desktop computing.
08:53:11 <MiggyX> dolio: I think it's still true for at least SME as well
08:54:59 <dolio> Imagine a beowulf cluster of people writing in imperative languages.
08:55:01 <outsid3r> hi
08:55:02 <maurer_> Imperative code can be done massively in parallel. Look at mapreduce--it was inspired by functional programming, but the code written for it now is imperative.
08:55:23 <Eduard_Munteanu> outsid3r: hi
08:56:05 <outsid3r> what you guys think about pure functional programming in constrast to all other paradigms ?
08:56:06 <Jafet> dolio: with infiniband local networks? You'd never be able to get through your email.
08:57:33 <dolio> outsid3r: It's great.
08:58:27 <outsid3r> why it is not much applicable in real world ?
08:58:38 <outsid3r> i believe that is great too from what i have read
08:59:03 <dolio> Who says it's not applicable?
08:59:56 <outsid3r> i mean, it's not much used as oop paradigm for example
09:00:16 <maurer_> outsid3r: It's totally applicable. OOP is just a fad.
09:00:38 <maurer_> As long as it's taught as the intro course in schools, OOP will continue to be used in many places.
09:00:40 <Eduard_Munteanu> Maybe because OOP is just a subset of what such a functional system allows.
09:00:41 <outsid3r> i believe it is, but the fact is that most programming is done with the same paradigm 
09:00:47 <dolio> OOP has had a lot more marketing behind it.
09:01:13 <Eduard_Munteanu> Yeah, there are more OOP books than cooking books out there
09:01:21 <outsid3r> some people say that OOP models better the world and the mind
09:01:30 <outsid3r> i think that it's ridicolous
09:01:31 <outsid3r> ridiculous*
09:01:34 <maurer_> outsid3r: Most people do many stupid things. Programming with imperative OOP is one of them. The fact that many people use it does not mean that it is good or applicable.
09:02:09 <outsid3r> there is no state in the universe, only transformations 
09:02:13 <outsid3r> and temporary constructs
09:02:27 <Eduard_Munteanu> It's not necessarily stupid, it's just the easiest abstraction to come up with in a simple language.
09:03:09 <dolio> outsid3r: If you look at a lot of best practices stuff for programming in imperative OO languages, it tends to sound like pure functional programming.
09:03:12 <Eduard_Munteanu> Simpler OOP forms arise naturally in languages such as C.
09:03:16 <dolio> "Make as many things constant as possible."
09:03:18 <dolio> Etc.
09:03:40 <outsid3r> the way we program in C is not much different from oop actually
09:03:44 <outsid3r> it is only less abstracted
09:04:02 <outsid3r> functional however seems really to be different
09:04:19 <Eduard_Munteanu> Indeed. Not being able to easily implement dispatch mechanisms, not having a strong type system behind it etc. leads to this.
09:04:28 <outsid3r> the way we write algorithms are so similar to maths that easilly we can prove that it works by mathematical induction
09:04:51 <outsid3r> functional is less likely to fail
09:05:03 <monadic_kid> Haskell is an excellent imperative language, it's pure & immutable by default which is the way it should be not the other way around
09:05:17 <outsid3r> i will learn haskell my next semester on university
09:05:36 <clp8> is #haskell down repeating the slogans of the old glasgow group yet?
09:05:39 <clp8> *done
09:05:59 <clp8> the whole "excellent imperative language" stuff is a trope with dubious correctness
09:06:10 <Phyx-> If it aint broke, why change it
09:06:22 <Eduard_Munteanu> It is a bit dubious true.
09:06:40 <clp8> mutability in imperative languages something people use a lot
09:07:16 <clp8> not that it's always good (rarely), but it's definately an important feature, say, for people working on embedded systems
09:07:25 <Eduard_Munteanu> I find it more verbose to write purely imperative (pun intended) programs in Haskell, say functions living in ST.
09:07:43 <clp8> it is more verbose, because you often have to use transformers
09:07:45 <hpc> it's sometimes funny to write functions in the Identity monad
09:07:54 <clp8> you want, say, State and IO at the same time
09:08:24 <Eduard_Munteanu> Yeah.
09:08:54 <Cale> clp8: hm?
09:08:59 <Eduard_Munteanu> hpc: what would you use Identity for? oO
09:09:12 <Eduard_Munteanu> Well, apart from doing stuff like StateT Identity to get State.
09:09:28 <Cale> clp8: I basically never StateT transform the IO monad, because it's pointless.
09:09:29 <hpc> Eduard_Munteanu: lulz; it can also make a nice "i told you so" to people who think you can't do imperitive in haskell
09:10:09 <Cale> clp8: The IO monad already has mutable references :)
09:10:17 <hpc> addThenMultiply = do let x = 3; x <- add x 5; x <- mult x 3; return x
09:10:51 <Eduard_Munteanu> Hm, maybe StateT makes sense, though ST definitely not.
09:12:26 <miasma> I think the "multiparadigm" folks think they're intellectually above OOP programmers
09:12:32 <Eduard_Munteanu> hpc: hm, does that work? :/
09:12:41 <miasma> multiparadigm languages support paradigms such as heavy metal programmming
09:12:54 <hpc> Eduard_Munteanu: when you define add and mult correctly, yes
09:13:20 <hpc> Eduard_Munteanu: in Identity, (>>=) is nothing more than a really odd way of saying (.)
09:13:21 <Eduard_Munteanu> hpc: I mean, I can't really tell how that expands to >>= and lambdas without tripping all over themselves and all over the let x.
09:13:24 <paolino> ContT STM is my next imperative frontier
09:13:52 <clp8> Cale: there was a library that forced State onto me when I was doing it
09:14:15 <clp8> i forget the exact details, but there are other examples that I'm sure you can think of
09:14:19 <Cale> clp8: Yeah, that's awkward.
09:14:29 <hpc> Eduard_Munteanu: the subsequent 'x' values are further inside the lambdas than the ones before, so scope separates them
09:14:51 <Cale> clp8: But in general, the comment about Haskell being a really good imperative language I'd say is correct.
09:15:55 <Eduard_Munteanu> hpc: hm. It makes sense then. But why would I use ST then?
09:16:07 <hpc> Eduard_Munteanu: no idea; i never mentioned ST
09:16:35 <clp8> Cale: i don't agree.  the most important features of imperative are global variables, mutability and deterministic run times (ie: no gc).  those are the reasons you'd do it in C
09:16:40 <Eduard_Munteanu> hpc: let me reword it... it seems ST is wordier than this and not really needed unless I have to modify passed in STRefs.
09:17:02 <clp8> where it is some kind of strange and ugly work
09:17:03 <hpc> ah, that is true
09:17:03 <miasma> clp8: and the heavy metal paradigm :)
09:17:42 <Cale> clp8: I disagree about those things, except mutability, and we have an excellent variety of mutable structures.
09:17:44 * Eduard_Munteanu learned something today :)
09:17:46 <Eduard_Munteanu> Thanks.
09:18:26 <Cale> Deterministic run times is important, but not critical for most applications as long as things are fast enough.
09:18:30 <Eduard_Munteanu> Though it does need monadic definitions for 'add', 'mul', and I presume they're not anywhere in prelude.
09:18:44 <Cale> (and it has nothing to do with imperativeness)
09:18:49 <Eduard_Munteanu> unlike modifySTRef.
09:18:54 <hpc> Eduard_Munteanu: add = liftM2 (+); mult = liftM2 (*)
09:18:56 <hpc> done!
09:18:58 <Eduard_Munteanu> Sure.
09:19:00 <Cale> Global variables are generally considered a bad idea, even among imperative programmers.
09:19:09 <outsid3r> nowadays we dont need deterministic runtimes for most applications
09:19:20 <hpc> it wasn't really a serious suggestion, btw; just something funny
09:20:18 <paolino> is it impossible to implement the ST trasformer ?
09:20:42 <Eduard_Munteanu> hpc: why not? That and ST made sense for some numeric algorithms I'll have to write.
09:20:50 <janman> Hi
09:20:56 <clp8> Cale: global variables are bad, I agree, but there are plenty of imperative idioms that require them
09:21:22 <Vanadium> like the singleton pattern
09:21:42 <clp8> i wasn't thinking of that, but i suppose so
09:22:00 <clp8> i was thinking of things like the way imperative parsers are written (doing one at the moment)
09:22:15 <clp8> C's "static" keyword, etc
09:22:40 <clp8> the other problem with haskell that I've run into a few times has been painfully hard to predict laziness when you're dealing with large datastructures
09:22:42 <Eduard_Munteanu> hpc: well, though until I actually get to it, I can't really tell if I need this or ST. I'm concerned about inplace updates, but Identity seems to do too.
09:22:52 <byorgey> paolino: ISTR the answer is "yes", but I forget why
09:23:15 <hpc> Eduard_Munteanu: i think GHC makes things mutable if it knows it can get away with it
09:23:48 <clp8> i spent a while over summer writing a program to convert some constraints into a large SAT (for solution with manySAT) and laziness was a real pain
09:24:01 <maurer_> hpc: Not very well, esp. with the "Array" type.
09:24:29 <ddarius> byorgey: The only tricky part is the types.
09:25:07 <paolino> Vanadium: isn't the singleton pattern doable with a ReaderT x IO where x is a datatype a set of functions in IO ?
09:25:32 <Vanadium> I assumed the draw of the singleton pattern was that you would not have to thread the Reader type along
09:25:51 <byorgey> ddarius: meaning what? it would be possible given a sufficiently expressive type system?
09:26:05 <Eduard_Munteanu> paolino: http://hackage.haskell.org/packages/archive/STMonadTrans/0.2/doc/html/Control-Monad-ST-Trans.html
09:27:02 <byorgey> oh, there's a package for it?
09:27:11 <byorgey> oh, with a nice warning telling you when/how it is safe to use, nice
09:28:03 <paolino> Eduard_Munteanu: I was thinking if  STT Cont was safe. It looks like not
09:28:20 <paolino> * STT s Cont r
09:28:27 <Eduard_Munteanu> Um, why not?
09:28:57 <paolino> it's excluded from the safe list
09:29:15 <byorgey> but the list says "includes ..."
09:29:25 <byorgey> which means monads not included are not specificall excluded
09:29:33 <dolio> If you want deterministic resource usage, obviously you should be using a functional language with linear typing.
09:29:41 <ddarius> byorgey: Potentially.
09:29:44 <dolio> Anything else is ad-hoc BS.
09:30:53 <byorgey> But hmm, I guess Cont probably isn't safe with STT
09:30:56 <paolino> for Cont r to work each bind must store the all ST variables contents
09:31:27 <Eduard_Munteanu> Hm, shouldn't there be stToIdentity, identityToST? That seems useful.
09:31:50 <hpc> Eduard_Munteanu: would stToIdentity be possible?
09:31:57 <hpc> i would think information would be lost
09:32:02 <dolio> identityToST = return, stToIdentity = runST
09:32:07 <Eduard_Munteanu> hpc: yeah, project anything but stte
09:32:13 <Eduard_Munteanu> *state
09:32:25 <hpc> dolio: haha
09:32:26 <Eduard_Munteanu> dolio: oh.
09:33:28 <Eduard_Munteanu> Mm, does that work? I mean in the same way this does...
09:33:32 <Eduard_Munteanu> :t stToIO
09:33:33 <lambdabot> Not in scope: `stToIO'
09:33:40 <Eduard_Munteanu> stToIO :: ST RealWorld a -> IO a
09:33:59 <Eduard_Munteanu> return seems to make it Identity (ST s a)
09:34:19 <Eduard_Munteanu> Uh, my bad.
09:37:31 <dolio> Using parsing as an example of where you need global variables in an imperative language also makes me laugh. I'll just take that as, "parsing in C sucks compared to parsing in Haskell."
09:37:49 <ddarius> dolio: That's not necessary in C either.
09:39:48 <Eduard_Munteanu> Actually making C libs thread-safe/reentrant generally entails converting from global vars to environment that's passed around in structs.
09:39:56 <Eduard_Munteanu> Kinda Haskellish.
09:40:17 <outsid3r> thre is any compiler that makes recursive functions never consume stack space in each call?
09:40:49 <ddarius> Not particularly Haskellish.  Having a capability secure library would require that as well and that has nothing to do with Haskell, same with dependency inversion.
09:41:03 <dolio> outsid3r: That's not possible, depending on what you mean by that.
09:41:17 <koala_man> outsid3r: do you mean tail call optimization? if so, yes. tons. including ghc
09:41:32 <outsid3r> i mean all kinds of recursion
09:41:41 <hpc> that's fundamentally impossible
09:42:00 <outsid3r> there must be a way of arrange the instructions in a way that it would not consume stack space
09:42:02 <emilmeln> Uniqueness type is some dummy type, which is passed from one function call to another in order to ensure that calls are made in the right order, right? (Like Haskell's RealWorld type)
09:42:14 <Eduard_Munteanu> Consider a compiler that outputs an interpreter together with bytecode. The bytecode can be evaluated on heap instead of stack.
09:42:34 <hpc> outsid3r: find such an arrangement for the ackermann function; win a prize and come back :P
09:42:45 <outsid3r> haha
09:42:52 <ddarius> emilmeln: No.  You don't have a "uniqueness type" you have uniqueness typing.  It's a type system feature.
09:43:28 <Eduard_Munteanu> Because with care, the interpreter can be written to avoid recursion completely, regardless of the interpreted bytecode.
09:43:43 <Eduard_Munteanu> Though it's probably not what you asked for :).
09:44:02 <ddarius> It's no trouble at allocate "stack" frames to the heap, but it just moves the problem.
09:44:09 <hpc> ^
09:44:15 <ddarius> You don't need to intpret some byte code to do that.
09:44:19 <Eduard_Munteanu> Indeed.
09:44:45 <Eduard_Munteanu> Though arguably there are cases where the heap is easier to grow than the stack.
09:44:56 <Eduard_Munteanu> e.g. kernels.
09:45:19 <ddarius> Current OSes make that the case, but there is nothing particularly special about stack space.
09:48:08 <outsid3r> ackermann function returns an integer of 19,729 digits only with an input of (4,2)
09:48:08 <outsid3r> omg
09:50:58 <hpc> the ackermann function is an example of how ridiculous recursion can get
09:51:17 <hpc> you can reduce runtime a bit with memoization, but the problem is still there
09:51:47 <outsid3r> we cant express a number that big on a computer
09:52:14 <ddarius> 19,729 digits is nothing.
09:52:18 <hpc> ^
09:52:22 <emilmeln> ddarius: If I've got it right, every value of the unique type can be used only once to produce some other value, and then any attempt to use it again will fail. Is it correct?
09:52:28 <hpc> you can't express it in 32/64 bits
09:52:39 <hpc> but it is quite easy to save on a computer
09:52:53 <dolio> > 10 ^ 19729
09:52:54 <augustss> ddarius: and by induction, all finite numbers are nothing?
09:52:54 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
09:53:22 <ddarius> emilmeln: s/can/must/
09:53:57 <hpc> augustss: instance Num (Maybe a) where fromIntegral = const Nothing :P
09:54:21 <miasma> emilmeln: the uniqueness type makes the value unique. once it has been referenced once, the value cannot be used anymore. you just annotate the type with a * in language like Clean
09:55:31 <ddarius> augustss: If "numbers" means "natural numbers" or at least "rationals", then yes.
09:55:36 <Eduard_Munteanu> See googol vs googolplex for contrast on what's not even possible to write down.
09:57:33 <sipa> ddarius: hence you refer to countably infinite sets as 'nothing' ?
09:58:10 <ddarius> sipa: The rationals are almost nowhere in the set of reals.
09:59:26 <sipa> ddarius: i know, when comparing cardinality of sets, the sets of naturals, integers, rationals and algebraic numbers are all equal
10:02:09 <ddarius> sipa: "Almost nowhere" is a technical term that means, in this case, that the set of rationals (or indeed any countably infinite subset of reals) has measure zero (i.e. is nothing) in the set of reals.
10:05:26 <sm> morning all
10:05:51 <sm> upgrading Cabal is giving undefined reference errors in unix, http://gist.github.com/656836 - why ?
10:05:54 <Eduard_Munteanu> sm: hi
10:06:12 <Cale> outsid3r: The average mp3 file is a number which is far far larger than that
10:07:18 <Eduard_Munteanu> sm: what Unix?
10:07:22 <emilmeln> OK, so I cannot even use one value of uniqueness type to produce two (equivalent) values?
10:07:36 <Eduard_Munteanu> sm: you might be missing pthreads
10:07:54 <Cale> outsid3r: Take a 3 megabyte mp3 file. It's a number with around 7 * 10^6 decimal digits.
10:08:01 <sm> Eduard_Munteanu: ubuntu, recently upgraded from lucid to maverick
10:08:05 <Cale> outsid3r: Computers can certainly work with numbers of that size.
10:08:15 <ddarius> emilmeln: That's not correct.  You simply can't use the value more than once.
10:08:18 <Eduard_Munteanu> sm: oh, look if there's a pthread dev package
10:08:38 <outsid3r> back
10:08:52 <sm> there's libpthread-stubs0[-dev], both installed
10:08:54 <outsid3r> Cale: i know that a number like that can be written on disk
10:08:56 <Cale> outsid3r: I left you some comments about the size of numbers that computers can work with :)
10:09:04 <ddarius> There could be a primitive that consumes a value and produces two, potentially unique, new variables that have the same value as the input.
10:09:07 <outsid3r> :)
10:09:09 <Cale> 3 megabytes is nothing these days
10:09:38 <Cale> I leave programs running in the background on my machine which are far larger than that and don't even notice.
10:09:39 <emilmeln> I've got it. It's like an assignment without the ability to reuse old references.
10:09:58 <outsid3r> how long it takes to computer a number large as that on an harddisk?
10:10:07 <Eduard_Munteanu> sm: what about libc / glibc dev packages?
10:10:46 <Cale> Less than a second
10:10:52 <Cale> Much less
10:10:57 <Eduard_Munteanu> outsid3r: compute how?
10:11:00 <outsid3r> really?
10:11:13 <Cale> Yes.
10:11:17 <outsid3r> i mean computer algebrically
10:11:19 <outsid3r> not just write on disk 
10:11:23 <outsid3r> compute*
10:11:26 <monochrom> compute a random number with 30 megabits. takes a short time.
10:11:37 <Cale> Oh, to compute it in memory is far faster still.
10:11:49 <Cale> Writing it to disk would take the majority of the time
10:11:50 <outsid3r> like if you sum 10^300 + 30^200
10:11:50 <Eduard_Munteanu> outsid3r: you can try arbitrary precision arithmetic in Haskell too, to see.
10:11:53 <emilmeln> Finally, what's the difference between uniqueness typing and linear typing?
10:11:56 <Cale> 10^300 + 30^200
10:11:57 <Cale> > 10^300 + 30^200
10:11:58 <lambdabot>   100002656139888758747693387813220357796268292334526533944959745749617390924...
10:12:03 <sipa> ddarius: oh, right
10:12:06 <Eduard_Munteanu> Cale: that's lazy
10:12:12 <Cale> Eduard_Munteanu: lazy?
10:12:12 <sm> libc6-dev, installed...
10:12:19 <Cale> There's no lazy computation going on there.
10:12:22 <Cale> Integer is strict
10:12:26 <outsid3r> it does not express the whole number :P
10:12:27 <Eduard_Munteanu> Oh.
10:12:43 <Cale> outsid3r: It's just because of the IRC message limit. It computes the whole thing.
10:12:57 <outsid3r> 53.10032^133*434.31^322
10:13:12 <Eduard_Munteanu> Use '> '
10:13:17 <monochrom> > (10^300 + 30^200) `mod` 10
10:13:17 <ddarius> > length (show (10^300 + 30 ^ 200))
10:13:18 <lambdabot>   0
10:13:18 <lambdabot>   301
10:13:43 <outsid3r> > i had no ideia that it would compute that so fast
10:13:44 <lambdabot>   Not in scope: `had'Not in scope: `no'Not in scope: `ideia'Not in scope: `th...
10:13:51 <Cale> outsid3r: That's a tiny number.
10:13:55 <miasma> emilmeln: for example the function for returning an element of an array returns a tuple, the array is unique
10:13:58 <Eduard_Munteanu> I suppose it's strict because of the GSL FFI semantics, no?
10:13:59 <outsid3r> > 53.10032^1323
10:13:59 <lambdabot>   Infinity
10:14:05 <sm> nm -g /usr/lib/pthread.a lists sem_trywait as W, a "weak" symbol. No idea what that is
10:14:10 <benmachine> < 53 ^ 1323
10:14:10 <outsid3r> > 54.3123^3213 +43.3232^343
10:14:11 <lambdabot>   Infinity
10:14:15 <monochrom> You need to go back to the basics. Pretend you never knew computing.
10:14:15 <benmachine> > 53 ^ 1323
10:14:15 <Eduard_Munteanu> Erm, not GSL.
10:14:15 <lambdabot>   164806934691220244363660691575287210904331496177326071511919002286608931609...
10:14:23 <Eduard_Munteanu> What was it. GMP.
10:14:36 <Cale> outsid3r: It only takes 333 bytes (plus a few for administration) to store that number.
10:14:38 <monochrom> it is gmp
10:14:39 <benmachine> outsid3r: the problem is you are working with Double values, which only have 64 bits of space (typically)
10:14:48 <Eduard_Munteanu> sm: oh, you probably need a .so
10:15:00 <benmachine> Eduard_Munteanu: it's strict because lazy numbers aren't really what you want all that often
10:15:00 <Cale> outsid3r: 333 bytes is a trivial amount of memory :)
10:15:12 <outsid3r> Cale: yea really
10:15:30 <Eduard_Munteanu> sm: is there an option to build a static version of that package?
10:15:32 <benmachine> > 54.3123^3212 + 43.3232^343 :: Rational
10:15:33 <lambdabot>   311172266856699812230387335119581389999465017681504991446328310587233613719...
10:15:43 <monochrom> oh? we are not to compute a number with 30 megabits? but rather just a number below 3 million?
10:15:44 <Cale> Not even a whole cache line in some machines
10:16:12 <sm> Eduard_Munteanu: heck no, I'm not building a custom version of core ubuntu c libs
10:16:40 <Eduard_Munteanu> sm: no, a static version of the program that builds on cabal
10:16:52 <Eduard_Munteanu> sm: so that it groks the .a
10:17:03 <Eduard_Munteanu> I'm not a Cabal expert.
10:17:16 <sm> I'm pretty sure all my cabal builds have been happily using .a libs to this point
10:17:42 <sm> thanks for the ideas though
10:18:00 <outsid3r> > 442343253^324332
10:18:02 <lambdabot>   275504625311557462035859861143784130228898869579828851738070103855739732631...
10:19:19 <Cale> outsid3r: If you do that in ghci, you'll get the whole thing printed :)
10:19:34 <outsid3r> Cale: i have tried in python
10:19:37 <Cale> Probably most of the time will be spent writing it to the terminal.
10:19:43 <outsid3r> it computes an arbitary large number too
10:19:49 <Cale> (depending on which terminal program :)
10:20:45 <outsid3r> it makes sense that it computes fast, a binary sum is basically sum 2 bits and carry
10:21:05 <Cale> outsid3r: and actually, that's the slow way
10:21:11 <outsid3r> i just have never tought about that, im still young :P
10:21:14 <outsid3r> really?
10:21:17 <Cale> outsid3r: You can handle the carries better
10:21:34 <Cale> If you work them out separately from the sum.
10:22:01 <outsid3r> but in order to sum the next bit i need the last carry
10:22:26 <sm> these packages build fine on another system (lucid). If someone out there with ubuntu maverick could test "cabal install Cabal" I'd appreciate it
10:22:41 <Cale> At each point in the sum, if you're adding two 0's, a carry coming in will be absorbed, if you have one 0 and one 1, then carries will be propagated, and if you have two 1's, then a carry will be created
10:22:51 <ddarius> You shouldn't be cabal installing Cabal.
10:22:57 <Cale> You can take these three possibilities for each column of the sum, and combine *those*
10:23:02 <Eduard_Munteanu> Yeah, that too.
10:23:14 <benmachine> ddarius: Cabal is supposed to be basically the only boto library safe to upgrade, isn't it?
10:23:18 <benmachine> *boot
10:23:23 <Cale> So, for instance, absorb*propagate*generate = absorb
10:23:49 <outsid3r> yea!
10:24:39 <sm> ddarius: I cabal installed cabal-install, which depends on it. 
10:25:19 <sm> time passed, now "there are problems in package Cabal-1.8.0.6 ... dependency unix-2.4.0.0-928374927834927 doesn't exist"
10:25:44 <sm> so I reinstalled unix, now I'm trying to reinstall Cabal.
10:25:48 <sm> where did I go wrong ?
10:27:03 <monochrom> where did you obtain the unix package?
10:27:12 <ddarius> Type 'cabal install cabal-install' again and see if it is happy with your unix dependency, I doubt it will be.
10:27:51 <Cale> outsid3r: If you're interested in it, here's a video on computing addition efficiently :) http://www.archive.org/details/Nicholas1987
10:28:17 <outsid3r> ty, i will check on them :)
10:28:55 <krey_> o/
10:30:39 <monochrom> \∩/
10:32:44 <krey_> does anyone wanna help me with an irresolvable type error?
10:33:03 <krey_>   Ambiguous type variable `a' in the constraint...
10:33:21 * monochrom suddenly realizes: sem_trywait etc. may be from the unix package itself
10:34:27 <krey_> http://codepad.org/KCTpNNnf
10:34:38 <Eduard_Munteanu> He has only the libpthread.a, so it's possible that's the problem.
10:34:53 <Eduard_Munteanu> Maybe Cabal is looking for shared libs.
10:35:18 <sm> monochrom: you know, just cabal install unix, which installs version 2.4.0.2 (previous was 2.4.0.0)
10:36:35 <sm> sem_trywait is defined in libpthread.a as a "weak" symbol. Which maybe means it's supposed to come from somewhere else
10:36:51 <Eduard_Munteanu> Possibly librt ?
10:36:52 <sm> I have libpthread.so too of course. This is ubuntu
10:37:09 <Eduard_Munteanu> sm: yes, but you need libpthread.so, not libpthread.so.X
10:37:21 <sm> I have it.
10:37:25 <Eduard_Munteanu> Oh.
10:37:43 <sm> ddarius: cabal install cabal-install fails as it tries to install Cabal, same issue
10:38:23 <Eduard_Munteanu> sm: see if you have librt and if it defines sem_trywait
10:39:24 <monochrom> in libc6-dev
10:40:19 <paolino> krey_: the `a` is the 'r' ?
10:40:44 <sm> I don't see sem_trywait in either librt.a or libc.a
10:40:59 <monochrom> where did you obtain the unix package before you reinstalled it? by cabal-install again? heck, where did you obtain the unix package very initially?
10:41:33 <sm> monochrom: 2.4.0.0 is in my system ghc packages, so I assume it came with ghc or the HP, I forget which I started with
10:41:41 <paolino> krey_: no, in the constraint ..
10:42:52 <krey_> paolino: http://hpaste.org/41017/why_fail_fails
10:43:59 * sm tries reinstalling unix 2.4.0.0
10:45:58 <monochrom> you have probably reached the fixed point of being told unix-2.4.0.0-numbers not found and reinstalling unix-2.4.0.0
10:47:58 <krey_> Ambiguous type variable `a' in the constraint anyone?
10:48:40 <Heffalump> krey_: you need to provide the source too
10:48:55 <Heffalump> oh, you did
10:48:56 * Heffalump looks
10:49:06 <paolino> krey_: 	draw ([]::[a])
10:49:39 <krey_> paolino: nope, been there
10:49:47 <paolino> it compiles  here
10:50:05 <paolino> you need scopedtypevariables
10:50:13 <Heffalump> and a forall a in the sig of normal
10:51:56 <benmachine> draw (take 0 xs)
10:51:59 <benmachine> simpler :P
10:52:32 <benmachine> or draw ([] `asTypeOf` xs)
10:52:40 <Twey> ‘draw []’ and give a better type to draw >.>
10:52:47 <krey_> why do I need them (paolino, Heffalump)?
10:53:06 <krey_> I'm not big on the extending haskell with ghc modules scene
10:53:46 <paolino> krey_: because r doesn't carry a type I suppose
10:54:38 <paolino> I wonder if the a type in the second draw is what you want
10:55:08 <benmachine> krey_: use my solutions!
10:56:39 <paolino> maybe you want to show a different type in the second a 
10:56:52 <paolino> s/a/draw
10:56:55 <krey_> benmachine:  asTypeOf?
10:57:09 <benmachine> krey_: yep. it's a function like const, but requires the argument types to be the same
10:57:18 <paolino> @hoogle asTypeOf
10:57:18 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:57:34 <benmachine> krey_: so x `asTypeOf` y is x, but with the condition that x and y must have the same type
10:57:47 <krey_> benmachine: i like it! thanks
10:58:43 <paolino> type communication
11:04:15 <sm> it's been a while since I had to give up and start over with a haskell installation, but this one may be getting to that point :/
11:07:53 <Eduard_Munteanu> sm: why do you need to upgrade Cabal this way?
11:08:44 <sm> Eduard_Munteanu: because of  "there are problems in package Cabal-1.8.0.6 ... dependency unix-2.4.0.0-928374927834927 doesn't exist"
11:08:58 <sm> it stops me installing other things
11:09:08 <sm> ghc-check reports broken packages etc.
11:09:25 <Eduard_Munteanu> sm: maybe your user-local Cabal prefix is broken.
11:09:30 <sm> no
11:20:45 <sm> it seems dependencies are not just a matter of having package-version installed.. there is this long extra hex suffix working like a hidden version field, and I have no idea how to work with that
11:21:28 <Eduard_Munteanu> I had to give up trying to install lambdabot with cabal install here on Gentoo because of intractable problems.
11:22:26 <Eduard_Munteanu> It complained on libs being actually linker scripts, although no other build environment complains about that...
11:22:32 <alip> is there a way to tell cabal that I don't want an executable installed but just built?
11:22:49 <Eduard_Munteanu> cabal build?
11:23:03 <Eduard_Munteanu> alip: ^
11:23:23 <alip> Eduard_Munteanu: let me rephrase the question
11:24:01 <alip> this package builds a library and executables which are program tests, I want cabal build to build all of them but cabal install should only install the library
11:24:15 <Eduard_Munteanu> Oh, I'm not sure.
11:24:25 <Eduard_Munteanu> Sorry.
11:24:42 <dino-> alip: There's a flag for the .cabal file where you can disable some of the targets.
11:24:44 <monochrom> hack the package description file to omit the executable
11:26:42 <alip> what I'm looking for is something like buildable but which works for installs
11:27:00 <dino-> alip: There's a field you can add to a Library or Executable section:  buildable: true|false
11:27:23 <dino-> alip: May not be able to do that. May have to settle for not building those executables at all if you don't want them installed.
11:27:27 <dino-> But I'm not certain.
11:27:58 <chrisdb> Another cabal question (possibly): I have a small program that I want to distribute. The source is available, but I want to build a binary to distribute for windows. All of my direct Haskell dependencies are BSD3, which says that for a binary distribution I need to also distribute the copyright notice and licensing info. Is there anything cabal can do to help me gather the licensing info for...
11:27:59 <alip> dino-: well I use simpleUserHooks to execute them as tests so I want them built
11:28:00 <chrisdb> ...all direct and indirect dependencies?
11:28:04 <chrisdb> (I have a working cabal file)
11:28:18 <chrisdb> Or do I have to manually figure go through extracting license files?
11:32:50 <chrisdb> I'm worrying about complying with the following clause: "* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution."
11:33:53 <Eduard_Munteanu> I'm somehow thinking maybe Cabal was a mistake... maybe they should've chosen between an existing build system and writing their own, but not Haskell-specific. There are reasons to go the first way.
11:34:55 <Eduard_Munteanu> Haskell ain't Perl.
11:35:38 <Eduard_Munteanu> If that parallel even holds.
11:35:57 <chrisdb> That's true. It would have been possible to nick an existing system. There are dangers in that though... often when Linux distros try to integrate programming languages into their package management systems the result is awful.
11:36:24 <chrisdb> In that they only include the most popular packages, and break any other method of installation more sophisticated than tarball + make.
11:36:40 <chrisdb> The TexLive issues with Fedora made me bitter.
11:37:01 <chrisdb> (they didn't include the TexLive package manager)
11:37:52 <Eduard_Munteanu> Yeah, I feel Cabal is some attempt to cover up difficult problems without actually solving them. It's just putting a frontend there, but still isn't working right.
11:38:40 <Eduard_Munteanu> (well, don't take cover up in any pejorative sense, I mean quick hack to fix)
11:38:52 <ddarius> I think you're confusing Cabal and cabal install.
11:39:26 <Eduard_Munteanu> ddarius: no, I mean cabal, the build system itself. 
11:39:35 <ddarius> Also, you could use Cabal to build non-Haskell projects (though of course you still need Haskell to use it.)
11:41:04 <Eduard_Munteanu> ddarius: if it's choking on things traditional tools like autotools wouldn't, I suspect that's cabal, not cabal install. Cabal-install is merely fetching, unpacking and running the building process.
11:41:23 <maurer_> ddarius: Please don't encourage that. As much as I like cabal, the day I download a C library and it uses cabal to build, and so I can't use my beloved -j8...
11:41:43 <Eduard_Munteanu> Also yeah, cabal install isn't too dear to me either...
11:43:01 <Eduard_Munteanu> (altough the CPAN reference alluded to cabal install, sorry)
11:43:03 <ddarius> maurer_: By the time anyone does that significantly, you'll probably have that.  That is a requested feature.
11:43:54 <ddarius> Eduard_Munteanu: Cabal is still pretty young and the developers are quite up-front about the things it still needs to fix.  Furthermore, autotools is very, very far from perfect.
11:44:15 <Eduard_Munteanu> Yeah, I agree with that, even though I use autotools most.
11:44:19 <dino-> I feel like this about it: The combination of the Cabal libraries + cabal-install could definitely be improved. But it does a good job for most of what we ask it to do. For me it's been a lot easier to use than very complicated setups using make. Or that horrifying Ant nightmare commonly used in the Java world.
11:44:42 <maurer_> Most of my new dev is in haskell, so I use Cabal for packaging it, as it integrates nicely. Using it for other things seems like a poor choice though...
11:45:00 <ddarius> maurer_: I wouldn't recommend doing that, but you could.
11:48:23 <Eduard_Munteanu> Still I have to say, autotools is probably the most featureful. Most complaints I hear about it are related to lengthy configure times, and perhaps ancient syntax, but it's still alright for many projects.
11:48:51 <Eduard_Munteanu> It just works, and it's piece of cake to add cross-compiling support and what not.
11:50:46 <Eduard_Munteanu> Maybe Cabal should've been approached like darcs... let's build a new general build system and see where it leads us.
11:52:49 <ddarius> Eduard_Munteanu: You do realize there were many, many years before Cabal.  Cabal wasn't just built on a whim.
11:53:16 <Twey> *cough*Nix*cough*
11:53:32 <paolino> I can see haskell code around using unicode characters like ← for bind. Is it valid ?
11:53:33 <Eduard_Munteanu> :)
11:53:42 <ddarius> Twey: dcoutts is stealing ideas from Nix as quickly as he can.
11:53:46 <Eduard_Munteanu> paolino: -XUnicodeSyntax
11:53:47 <Twey> paolino: With the -XUnicodeSyntax extension, yes.
11:54:00 <paolino> ooh
11:54:03 <Eduard_Munteanu> Twey: I suppose that solves only the cabal-install part.
11:54:24 <Twey> Eduard_Munteanu: Nix solves the whole thing from start to finish.
11:54:36 <Twey> (but it also extends beyond that into OS config)
11:54:46 <pumpkin> @ask dcoutts I was wondering what voodoo was needed to get cabal test support now. I've tried grabbing both cabal and cabal-install head but it still says that test-suite is an unrecognized directive
11:54:46 <lambdabot> Consider it noted.
11:55:03 <Eduard_Munteanu> Twey: well, we're also talking about the build system, I doubt Nix replaces autotools from traditional GNU pkgs.
11:55:24 <Twey> Eduard_Munteanu: In a sense, it does
11:55:41 <Twey> That is, it doesn't do the same thing, but approaches the problem from a different angle
11:56:04 <dankna> they work in concert
11:56:34 <Eduard_Munteanu> How was it like before Cabal? ghc --make?
11:56:44 <Eduard_Munteanu> Makefiles?
11:57:05 <Twey> They do tend to work in concert, yes, but they don't have to — that's just for convenience because autotools configuration is already available, and it would otherwise have to be rewritten in Nix
11:57:21 <benmachine> autoconf can die in a fire
11:57:34 <Eduard_Munteanu> :)
11:57:35 <benmachine> that is my considered view
11:57:41 <Twey> Heheh.
11:58:03 <dankna> hee
11:58:12 <dankna> I tend to agree, but Cabal doesn't yet totally subsume it
11:58:28 <dankna> there are some things for which you really do need to ask the C compiler what its opinion is
11:58:33 <Eduard_Munteanu> I wonder if any build system subsumes autoconf. :/
11:58:37 <dankna> I doubt it :/
11:59:59 <ddarius> Eduard_Munteanu: ghc --make, Makefiles, autotools, scons in at least one case, some others.
12:00:09 <Eduard_Munteanu> I see.
12:00:11 <aristid> cmake
12:00:14 <benmachine> there was a thing called hmake
12:00:17 <benmachine> it died I think
12:00:23 <ddarius> Eduard_Munteanu: You can simply call autoconf from your Setup.hs worst-case scenario.
12:00:26 <dankna> happily - it was never clear how hmake fit with the other tools
12:00:34 <Eduard_Munteanu> Oh, heh.
12:00:49 <dankna> subsume != be able to call
12:01:13 <dankna> to subsume autoconf in the sense I mean, you'd have to be able to perform the same type of "generate a C program, compile it, and take feedback from its output" test
12:01:29 <ddarius> dankna: That's exactly what hsc2hs does.
12:02:09 <dankna> good then, but I don't think ghc --make or Makefiles or scons do that
12:02:16 <dankna> (gawd, scons :( )
12:02:23 <dankna> (I was hoping nobody else was unfortunate enough to know that one existed)
12:02:45 <ddarius> dankna: My point was that Setup.hs is arbitrary code.  It can do anything.
12:03:00 <shachaf> dankna: Makefiles can do anything, as far as I know.
12:03:04 <Eduard_Munteanu> I had my fair share of work with adhoc build systems (mostly Kbuild/Kconfig-like) made of Makefiles. They function fine for that purpose, but it's hell to solve some problems autoconf solves.
12:03:23 <dankna> okay, but it's not optimized for that task
12:03:30 <dankna> and that task is really really tedious to do by hand
12:04:10 <Eduard_Munteanu> For instance, I see cross-compiling support generally difficult to add as an after-thought.
12:04:43 <bremner> the problem is, autoconf is optimized for problems that most people don't have.
12:04:55 <dankna> nodnod
12:04:57 <Eduard_Munteanu> Indeed, that's true.
12:04:58 <dankna> well true
12:05:36 <benmachine> the really annoying thing about makefiles is they can't quite do everything you want
12:05:44 <benmachine> the functions are too specific, even the GNU extensions
12:05:56 <benmachine> and then you're stuck hacking some nasty bash (not that, really, there is any other kind)
12:06:03 <dankna> yeah
12:06:08 <Eduard_Munteanu> Yeah, non-trivial Makefiles are pure magic.
12:06:44 <dankna> and of course there's the problem that people make recursive ones, which are dramatically less efficient than flat ones, because they are misguided
12:06:51 <Eduard_Munteanu> I can't believe I considered recursive self-referential includes at some point to solve a problem.
12:07:02 <dankna> heh!
12:07:40 <Eduard_Munteanu> Fortunately, I found a workaround.
12:07:51 <dankna> well good :)
12:18:30 <db4n> Boo!
12:19:24 <ddarius> db4n: You want #boo.
12:19:47 <sipa> a bit lonely there
12:20:19 <db4n> I have a Haskell question.
12:20:22 <Twey> Is there no channel for the Boo language?
12:21:03 <Lemmih> db4n: Excellent. We might have a matching Haskell answer.
12:22:01 <db4n> Okay, here's my question:  Why does hGetContents return zero characters from reading my file when hGetLine correctly returns the first line?
12:22:28 <dankna> because you can't close the file before actually using the result of hGetContents
12:22:43 <seanmcl> I'm looking for a way to get records in and out of text files.  There is an ocaml library called sexplib, where by you can write something like type t = { foo : int; bar : string list} with sexp, and camlp4 generates the functions to_sexp and from_sexp, where in this case a well-formed sexp would look like ((foo 5) (bar (this is a nice feature))).  It's a very convenient way to munge data.  Is there something like this for Haskell?  I c
12:22:43 <seanmcl> probably do something with XML, but I'm trying to avoid it.  Thanks.
12:22:59 <dankna> seanmcl: read/show
12:23:08 <db4n> danka:  is there a reason for that?
12:23:23 <dankna> db4n: yes, but how technical an answer do you want?
12:23:41 <db4n> doesn't matter.
12:24:00 <dankna> the answer is more or less that hGetContents uses unsafeIntersperseIO, which is a function that guarantees that the IO operation passed to it will be performed at some point before the values are used, but not when
12:24:05 <HugoDaniel> hi
12:24:18 <seanmcl> danka: I'd like to edit the text files.  Are you suggesting I redefine read and show, or derive them?  
12:24:29 <dankna> seanmcl: either, really, but probably derive
12:24:35 <dankna> seanmcl: they won't be nicely indented, but...
12:24:53 <dankna> db4n: on a higher level, the answer is that the intention of hGetContents is not to read the entire file in a strict way, but just to provide a more convenient abstraction that makes it look /as if/ you have done so
12:26:41 <ddarius> An abstraction that is about as watertight as a sieve.
12:27:18 <dankna> yes
12:27:25 <dankna> it's not a very well-conceived function at all, frankly
12:28:32 <db4n> so the alternatives are (a) write some Maybe code to read lines, and (b) manually open & close the file?
12:28:55 <dankna> no,
12:29:01 <dankna> use withOpenFile or whatever it's called
12:29:22 <dankna> also
12:29:33 <alpounet> @hoogle withFile
12:29:33 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
12:29:33 <db4n> danka:  I did:  withFile "Yearly prices.rtf" ReadMode hGetContents
12:29:39 <dankna> if you really are sure you want the entire file - remember, in Haskell a String is a linked list of characters -
12:30:01 <dankna> you can reverse the string twice as a workaround - that forces it to evaluate the whole thing
12:30:11 <ddarius> db4n: That's pretty much just readFile, by the way.
12:30:25 <ddarius> dankna: It's not necessary to reverse it.
12:30:27 <dankna> but if you really want the entire file as a buffer, you're better off using bytestring and utf8-string
12:30:27 <db4n> ddarius thanks
12:30:29 <dankna> ddarius: oh
12:30:53 <JoshTriplett> dankna: Oh, hey.  I just sent you a mail about direct-fastcgi. :)
12:31:00 <JoshTriplett> dankna: Thanks for it, by the way. :)
12:31:04 <dankna> db4n: but the way you're "supposed" to do it, although of course there's more than one way, is to do your action inside the withFile
12:31:09 <alpounet> or Data.Text
12:31:10 <dankna> Josh: oh welcome!  looking now :)
12:31:43 <ddarius> db4n: If you are only opening a few files (or just one), you can probably just use readFile and it will work well enough for this.
12:32:21 <dankna> I'm pleased to hear that you like the design of the package; I was pretty proud of it myself.  Your request is reasonable and something I'd like to do.
12:32:31 <JoshTriplett> dankna: Thanks!
12:33:35 <hard_shooter> hi
12:33:44 <JoshTriplett> So, I've started using arrows quite a bit now, and I find myself missing two major things compared to monads or functions: the ability to write top-level functions, and the ability to write multiple function heads with pattern matching.
12:34:02 <hard_shooter> How should I declare a function to say take a list of Int by the list can be empty ?
12:34:18 <hard_shooter> s/by/but/
12:34:23 <clp8> List<Integer>
12:34:31 <JoshTriplett> clp8: ?
12:34:31 <clp8> whoops, wrong channel, sorry
12:34:35 <JoshTriplett> ;)
12:34:51 <clp8> heh, heh, that was something of a faux pas around here
12:34:57 <JoshTriplett> hard_shooter: someFunction :: [Int] -> returnType
12:35:05 <JoshTriplett> Having to write "f = proc a -> ..." feels like having to write "f = \a -> ..."; I'd rather write "f a = ..."
12:35:32 <JoshTriplett> I wonder: how much work would it take to support a top-level arrow syntax, like "proc f a -> ..." ?
12:35:37 <JoshTriplett> (And what should that syntax look like?)
12:35:42 <alpounet> hard_shooter, for example for one that would sum all the elements : sum :: [Int] -> Int
12:35:44 <db4n> Ha!  readFile works.
12:35:52 <hard_shooter> oh yeah sorry
12:35:56 <hard_shooter> my mistake
12:36:16 <JoshTriplett> And once that syntax exists, how much work would it take to support multiple declarations for the same arrow with patterns, with an implicit requirement for ArrowChoice?
12:36:30 <JoshTriplett> proc f (Just a) -> ...
12:36:30 <JoshTriplett> proc f Nothing -> ...
12:36:54 <JoshTriplett> (That -> should probably be an =)
12:49:48 <Phyx-> > id
12:49:49 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
12:49:49 <lambdabot>    arising from a use of `...
12:50:24 <alpounet> > id :: Int -> Int
12:50:25 <lambdabot>   Overlapping instances for GHC.Show.Show
12:50:25 <lambdabot>                              (GHC.T...
12:50:29 <Phyx-> :t ((-) *** (+))
12:50:30 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
12:50:36 <Eduard_Munteanu> Overlapping?
12:50:43 <Eduard_Munteanu> I thought there was no instance :/
12:50:43 <Phyx-> :t ((- 1) *** (+1))
12:50:44 <lambdabot> forall b c b'. (Num c, Num b') => (b, b') -> (c, b')
12:51:07 <Phyx-> Eduard_Munteanu: lambdabot is all mighty
12:51:17 <Eduard_Munteanu> Oh.
12:52:12 <JoshTriplett> So, what's a case where lambdabot can show a function?
12:52:23 <sipa> @src foldr
12:52:23 <lambdabot> foldr f z []     = z
12:52:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:52:33 <Phyx-> it used to do it on all functions.. till someone broke it
12:52:34 <JoshTriplett> > \x -> (2*x)
12:52:35 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
12:52:35 <lambdabot>    arising from a use of `...
12:52:39 <JoshTriplett> So it seems.
12:52:47 <JoshTriplett> > \x -> 2
12:52:47 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1)
12:52:47 <lambdabot>    arising from a use of ...
12:54:22 <Eduard_Munteanu> @help undefine
12:54:23 <lambdabot> undefine. Reset evaluator local bindings
12:54:35 <sipa> @undefine
12:54:44 <Eduard_Munteanu> @undefine instance Show (a -> a)
12:54:50 <Eduard_Munteanu> Dunno if that works...
12:54:54 <Eduard_Munteanu> > \x -> (2*x)
12:54:55 <sipa> > id
12:54:55 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
12:54:55 <lambdabot>    arising from a use of `...
12:54:56 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
12:54:56 <lambdabot>    arising from a use of `...
12:54:59 <JoshTriplett> I don't think lambdabot allows instance declarations in the first place.
12:55:08 <Eduard_Munteanu> Never tried such a let.
12:55:11 <sipa> 20:52:41 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
12:55:11 <sipa> 20:52:42 <lambdabot>    arising from a use of `M1972885510360359869.show_M1972885510360359869'
12:55:15 <sipa> 20:52:42 <lambdabot>                 at <interactive>:(1,74)-(2,30)
12:55:27 <Eduard_Munteanu> Ouch.
12:55:49 * Eduard_Munteanu now knows where sipa lives, muhahaha....
12:55:53 <Eduard_Munteanu> :P
12:55:57 <sipa> ?
12:56:00 <Eduard_Munteanu> Well, approximately.
12:56:16 <sipa> tell me
12:56:16 <Eduard_Munteanu> GMT +1
12:56:24 <sipa> loi
12:56:36 <Eduard_Munteanu> Quite a rough approximation, but still.
12:56:46 <sipa> just whois me, and you'll get more accurate informatie
12:56:53 <dstcruz> could anyone help me understand how to use System.Posix.Terminal to disable getChar echoing?
12:57:34 <JoshTriplett> Eduard_Munteanu: You have approximately 4.6 bits of information on sipa's location, anyway. :)
12:57:39 <Eduard_Munteanu> sipa: heh, I know.
12:59:02 <sipa> the show instances for id come from: smallcheck-0.4:Test.SmallCheck and vector-space-0.6.2:Data.NumInstances
12:59:29 <Eduard_Munteanu> @let instance Show (a -> a) where show = "test"
12:59:29 <lambdabot>  Invalid declaration
12:59:35 <Eduard_Munteanu> Ah, so that couldn't be it.
12:59:50 <Eduard_Munteanu> @let instance Show (a -> a) where show f = "test"
12:59:50 <lambdabot>  Invalid declaration
12:59:55 * Eduard_Munteanu made sure
12:59:58 <sipa> @instance Show (a -> a) where show f = "test"
12:59:59 <lambdabot> Maybe you meant: instances instances-importing
13:00:08 <Eduard_Munteanu> Ah.
13:01:06 <JoshTriplett> Any GHC parser/grammar gurus around?  Trying to figure out where under "decl" the parsing of a top-level function declaration occurs.
13:01:06 <Eduard_Munteanu> I wonder if it's possible to have instances be import-qualified.
13:01:28 <Eduard_Munteanu> to actually name a specific one.
13:02:09 <JoshTriplett> Eduard_Munteanu: Not as far as I know.
13:17:26 <Phyx-> josephholsten: you mean where in the AST?
13:18:16 <josephholsten> Phyx-: I assume that was for JoshTriplett 
13:18:17 <JoshTriplett> Phyx-: Did you mean to point that at me? ;)
13:18:22 <Phyx-> oh yes
13:18:23 <Phyx-> lol
13:19:02 <JoshTriplett> Phyx-: I suspect I'll probably want the answer to that question too, but at the moment I really do mean in the grammar.  And I managed to track it down to beneath the infix operator handling, which makes sense after I found that infixexp can just resolve to a function name.
13:21:08 <Phyx-> JoshTriplett: ah, unfortunately, I haven't ever looked at the parser, But I would look for things that produce an HsBind
13:22:08 <JoshTriplett> Phyx-: Currently trying to see what it would take to add top-level arrow declarations.  Syntax suggestions welcome; currently planning on something like "proc funcname theonearg = arrowcommands".
13:24:20 <Phyx-> oh cool, I'm not to good with happy, never used it, so unfortunately I can't help you there 
13:32:14 <BluShift> Hey all, I get a "<interactive>:1:0: Not in scope: `sort'" when I try to sort a list in GHCI
13:32:26 <Zao> BluShift: Did you import Data.List?
13:32:30 <BluShift> Nope!
13:32:32 <BluShift> How do I o that?
13:32:36 <shachaf> :m + Data.List
13:32:45 <Zao> @index sort
13:32:45 <lambdabot> Data.List
13:32:52 <BluShift> I thought it was ":l"?
13:32:59 <shachaf> That's for loading a file.
13:33:00 <BluShift> (lowercase L)
13:33:02 <BluShift> Oh.
13:33:07 <BluShift> Ohhkay. Thanks!
13:33:32 <shachaf> You can also add it to your ~/.ghci.
13:33:47 <shachaf> If your prompt gets too long, you can :set it to something that doesn't include %s.
13:33:55 <shachaf> See :h. :-)
13:49:15 <BluShift> How would I sort an individual list item, in place of an entire list?
13:49:48 <shachaf> BluShift: What?
13:50:25 <nus> BluShift, first you get at it, then sort it
13:50:27 <BluShift> I have a list made up of strings, and I want to sort the characters in each list item.
13:50:55 <BluShift> right now I'm using [sort x++y | x <- a, y <- a]
13:51:03 <BluShift> But it's obvioiusly just sorting the whole list.
13:51:43 <Lemmih> BluShift: map sort?
13:51:43 <shachaf> Can you give an example of what you're trying to do?
13:52:21 <BluShift> I have a list of ["abc","abC","aBc","aBC","Abc","AbC","ABc","ABC"] (genotypes)
13:52:59 <BluShift> And I'm trying to generate all possible resulting genotypes, by emulating a punnet swuare.
13:53:03 <BluShift> square. *
13:53:27 <BluShift> So the resulting output is accurate, but I would like to format it as AaBBcc, instead of ABcaBc.
13:53:34 <BluShift> If that makes sense?
13:53:54 <BluShift> Helping my brother with his Biology, lol ;)
13:54:21 <db4n> BluShift so you want to regroup the letters?
13:55:03 <nus> @type sortBy
13:55:04 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
13:55:28 <BluShift> db4n: I guess so :)
13:55:35 <BluShift> nus: Ohhh, ok :)
13:55:55 <nus> @src sort
13:55:55 <lambdabot> sort = sortBy compare
13:56:02 <nus> @type compare
13:56:03 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:56:06 <BluShift> How do I specify the ordering?
13:56:37 <db4n> BluShift is the result supposed to be ["aaaaAAAA","bbBBbbBB","cCcCcCcC"]?
13:57:08 <nus> @src Ordering
13:57:08 <lambdabot> data Ordering = LT | EQ | GT
13:57:46 <BluShift> db4n: No. The individual strings end up as "ABCabc", and I'd like them to return as "AaBbCc". Is that possible? :)
13:58:26 <nus> @src compare
13:58:26 <lambdabot> compare x y | x == y    = EQ
13:58:26 <lambdabot>             | x <= y    = LT
13:58:27 <lambdabot>             | otherwise = GT
13:59:23 <zachk> use zipwith and a handroled lambda to make 2 element lists then use concat 
13:59:45 <BluShift> zachk: Oh, good lord. I just started learning Haskell last night :-/
14:00:00 <aristid> hmm
14:00:23 <aristid> :t zipWith
14:00:24 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
14:00:46 <aristid> :t ((.).(.).(.)) concat zipWith
14:00:47 <lambdabot> forall a a1 b. (a1 -> b -> [a]) -> [a1] -> [b] -> [a]
14:01:15 <aristid> :t ((.).(.).(.)) join zipWith
14:01:16 <lambdabot> forall a a1 b. (a1 -> b -> [a]) -> [a1] -> [b] -> [a]
14:01:20 <BluShift> Guys, that's really not helpful. I'm really new to Haskell.
14:01:22 <zachk> > concat . zipWith (\x y->[x,y]) ['a'..'c'] $ ['A'..'C']
14:01:23 <lambdabot>   "aAbBcC"
14:01:38 <aristid> zachk: list sections would be cool
14:01:43 <zachk> ?
14:01:50 <aristid>  concat . zipWith [,]
14:02:15 <aristid> BluShift: then don't do it our way :D
14:02:25 <Lemmih> > concat [ [a,b] | a <- "ABC" | b <- "abc" ]
14:02:26 <lambdabot>   "AaBbCc"
14:02:36 <db4n> Oh, BluShift wants to interleave the two strings.
14:02:41 <zachk> thats even more concise 
14:04:01 <BluShift> I've got 3 lists, of let a = ["a", "A"], let b = ["b", "B"], c = [
14:04:08 <BluShift> "c", "C"] 
14:04:19 <ddarius> > concat (transpose ["ABC", "abc"])
14:04:20 <lambdabot>   "AaBbCc"
14:04:34 <ddarius> (Please don't use parallel list comprehensions.)
14:04:56 <BluShift> And then I use [x ++ y ++ z | x <- a, y <- b, z <- c]
14:05:06 <cads> hey, how do I define a data type in ghci?
14:05:16 <Lemmih> cads: You don't.
14:05:22 <cads> oh plah
14:05:36 <cads> okay, I'll load it in a file
14:05:41 <nus> @hoogle zipWith3
14:05:41 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
14:05:41 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
14:05:48 <BluShift> To end up with ["abc","abC","aBc","aBC","Abc","AbC","ABc","ABC"], which is a list of all the individual alleles, and then those are combined with eachother to form genotypes.
14:06:08 <cads> Lemmih, you know the rationale behind that decision?
14:06:49 <BluShift> And just a simple a = ["abc","abC","aBc","aBC","Abc","AbC","ABc","ABC"] with [x ++ y | x <- a, y < - a] works just fine, it just doesn't return thr strings in the right order. They end up as abcABC, or AbcaBC, etc.
14:07:13 <BluShift> Where I want them in AaBbCc, or AABbCC, etc.
14:07:30 <cads> hmm, defining then redefining types during an interactive session could easily undermine structures that're built up in the meantime, I guess
14:07:42 <db4n> Blu
14:07:44 <db4n> oops
14:08:00 <dolio> I don't think there's a rationale.
14:08:09 <Lemmih> BluShift: Use the solution ddarius gave you.
14:08:15 <dolio> It's just not something that was implemented.
14:08:15 <cads> dolio, hah, that's honest
14:08:51 <dolio> I think hbi supported type definitions.
14:09:03 <dolio> And ocaml's interactive loop does.
14:09:09 <cads> dolio, needed to show someone stuff about types, so I resorted to making a file and putting my types there. it was an annoyance
14:09:17 <cads> but not too bad
14:09:35 <AmunRa> Not that it's hard to write, but I'd rather not re-invent the wheel. signature: reapply :: Int -> (a -> a) -> a -> a    --does it exist in any of the standard packages?
14:10:15 <sipa> @djinn Int -> (a -> a) -> a -> a
14:10:15 <lambdabot> Error: Undefined type Int
14:10:24 <cads> dolio, thanks for the trivia! :)
14:10:28 <sipa> AmunRa: what should it do?
14:10:45 <Lemmih> AmunRa: It looks like iterate.
14:10:50 <AmunRa> reapply the passed function N times, returning the reapplication function
14:10:51 <cads> and thanks too, Lemmih:)
14:11:14 <ddarius> The MLs have had full interactive support pretty much their entire existence.
14:11:17 <sipa> :t iterate
14:11:18 <lambdabot> forall a. (a -> a) -> a -> [a]
14:11:18 <companion_cube> having datatype definition in repl allows to get error messages like "error : x is of type blah, but type blah was expected"
14:11:52 <Lemmih> @type \n fn v -> iterate fn v !! n
14:11:53 <Azrael-> iterate returns [x, f x, f (f x),..]
14:11:53 <lambdabot> forall a. Int -> (a -> a) -> a -> a
14:12:07 <ddarius> Lemmih: There are problems with that solution.
14:12:26 <AmunRa> I don't really want a list
14:12:36 <sipa> let reapply 0 f x = x; reapply i f x = f (reapply f (i-1) x) in reapply 5 (*2) 3
14:12:39 <sipa> > let reapply 0 f x = x; reapply i f x = f (reapply f (i-1) x) in reapply 5 (*2) 3
14:12:40 <lambdabot>   *Exception: (==): No overloading for function
14:12:58 <sipa> > let { reapply 0 f x = x; reapply i f x = f (reapply f (i-1) x) } in reapply 5 (*2) 3
14:12:58 <lambdabot>   *Exception: (==): No overloading for function
14:13:29 <sipa> > let { reapply 0 f x = x; reapply i f x = f (reapply (i-1) f x) } in reapply 5 (*2) 3
14:13:30 <lambdabot>   96
14:14:01 <sipa> @hoogle Int -> (a -> a) -> a -> a
14:14:02 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
14:14:02 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
14:14:02 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
14:14:43 <db4n> Does anyone know why Platform 2.0.0 is having trouble loading regex-posix-0.94.2?
14:14:46 <AmunRa> sipa: thanks for that  (both things, in fact.. didn't know of hoogle)
14:15:05 <db4n> (on windows)
14:15:44 <sipa> > let { reapply 0 f = id; reapply i f = f . reapply (i-1) f } in reapply 5 (*2) 3
14:15:45 <lambdabot>   96
14:16:10 <nus> @type foldr
14:16:10 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:16:17 <ddarius> That reapply is blatantly not tail recursive, so if f is strict, you are going to leak stack space.
14:16:18 <alpounet> > iterate (*2) 3 !! 5
14:16:19 <lambdabot>   96
14:16:48 <Azrael-> > until (>95) (*2) 3
14:16:49 <lambdabot>   96
14:16:50 <Azrael-> :)
14:17:13 <sipa> > let { reapply 0 f x = x; reapply i f x = reapply (i-1) f (f x) } in reapply 5 (*2) 3
14:17:14 <lambdabot>   96
14:17:18 <ddarius> The iterate !! definition has a similar problem to sipa's reapply.
14:17:23 <sipa> ddarius: better this way?
14:17:39 <ddarius> sipa: It's tail recursive, but now it has the same problem as the iterate/!! solution.
14:18:28 <ddarius> Add ! to the xs and it will be fine (with BangPatterns).
14:18:28 <sipa> please give a better solution :)
14:19:29 <ddarius> I would probably define, iterate' f x = x:let y = f x in iterate' f y, then iterate' f x !! n would do the right thing.
14:20:27 <alpounet> basically making it strict
14:20:36 <ddarius> alpounet: Only in the elements.
14:20:52 <ddarius> Really, I'd prefer an iterate :: (a -> a) -> a -> HeadStrictList a
14:21:01 <alpounet> yeah
14:21:05 <alpounet> the elements are already evaluated
14:21:13 <alpounet> but not the list
14:21:54 <AmunRa> thanks all and goodnight
14:22:21 <Lemmih> ddarius: How would that definition be strict the in elements?
14:22:33 <Lemmih> s/the in/in the/
14:23:30 <ddarius> Lemmih: Which? iterate'?  It forces them as it goes along.
14:23:46 <cads> Okay, I've got a tree type defined as    data Tree a = EmptyTree | Node a [Tree a]. 
14:23:56 <ddarius> @src Data.Tree.Tree
14:23:56 <lambdabot> Source not found. Take a stress pill and think things over.
14:23:59 <ddarius> @src Tree
14:24:00 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:24:09 <cads> the height function has been written   height EmptyTree = 0 , height (Node _ children) = 1 + maximum (0 :( map height children))
14:24:23 <Darkone> cads, so eahch node contains a list of nodes, rather than 2?
14:24:32 <cads> yes
14:24:49 <ddarius> Lemmih: Er, there was supposed to be a y `seq` in it.
14:24:50 <cads> the problem I see with the definition is that the list of children can be null
14:24:57 <Lemmih> ddarius: Ah, that makes more sense.
14:25:36 <ddarius> iterate' f x = x:let y = f x in y `seq` iterate' f y
14:26:01 <cads> the height of an empty tree should be zero. It is reasonable that a tree that consists of a single node with no children should be considered height 1.
14:26:13 <cads> oh, I think I just answered my own question
14:27:52 <cads> still, I will rewrite the function so that it has a   heigh Node _ [] = 1 clause, to be more explicit and avoid a silly consing
14:28:22 <nus> @src iterate
14:28:22 <lambdabot> iterate f x =  x : iterate f (f x)
14:28:25 <RichardBarrell> cads: you know, there's this trick where, when you have a difficult question, you ask a teddybear and then you try to ask a human. 
14:29:10 <RichardBarrell> cads: and hopefully, phrasing your question for the teddybear helps you straighten it out in your head and yeah... so, is #haskell your teddy bear?
14:29:46 <cads> in this case, that is essentially what happened
14:30:13 <cads> appologies :)
14:30:52 <cads> however, now a real question
14:31:08 <cads> well.. darn..
14:31:40 <cads> RichardBarrell, you'll be happy to know I'm going to formulate the question first before typing it out here :D
14:31:50 <RichardBarrell> cads: nothing to apologise for, you weren't spamming. ^_^
14:32:18 <cads> I guess I just think lambdabot is cute like a teddy bear
14:41:42 <blackcustard> is there any way for an element of an array to become "undefined"? (the actual error message is "Program error: undefined array element", so maybe this could mean that there is an element, but that that element is itself undefined)
14:42:36 <ClaudiusMaximus> > (listArray (1,5) [1 .. 5]) ! 6
14:42:37 <lambdabot>   *Exception: Error in array index
14:42:52 <ClaudiusMaximus> > (listArray (1,5) undefined:[1 .. 4]) ! 1
14:42:53 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
14:42:53 <lambdabot>         against inferred t...
14:42:59 <blackcustard> as far as i can tell is not an out of bounds error
14:43:03 <ClaudiusMaximus> > (listArray (1,5) (undefined:[1 .. 4])) ! 1
14:43:04 <lambdabot>   *Exception: Prelude.undefined
14:43:12 <Lemmih> > array (1,10) []
14:43:12 <lambdabot>   array (1,10) [(1,*Exception: (Array.!): undefined array element
14:43:26 <ClaudiusMaximus> ah
14:43:39 <solistic> Is there a monadic variant of `until', like: doUntil predicate action = do r <- action; if predicate r then return () else doUntil predicate action
14:43:54 <blackcustard> hmm, i thought i was initilizing the entire array ..
14:44:38 <solistic> well, I forgot the `?' on the end of the line..
14:45:09 <ClaudiusMaximus> @hoogle untilM
14:45:09 <lambdabot> No results found
14:45:10 <alpounet> solistic, untilLM
14:45:12 <alpounet> untilM *
14:45:31 <solistic> alpounet: thx
14:45:35 <alpounet> it isn't in the standard library per se
14:45:40 <alpounet> but you can write that quite easily
14:45:52 <ClaudiusMaximus> hm, hayoo down?
14:46:20 <alpounet> solistic, start from : untilM :: (Monad m) => (a -> Bool) -> (a -> m a) -> a -> m a
14:46:25 <alpounet> that'll be straightforward
14:46:51 <ClaudiusMaximus> http://hackage.haskell.org/package/monad-loops
14:47:58 <blackcustard> ! got it
14:48:13 <blackcustard> > >array (0, 5) [(x, x) | x <- [0 .. 5]] // [(0, 1), (0, 1)]
14:48:13 <lambdabot>   <no location info>: parse error on input `>'
14:48:20 <blackcustard> > array (0, 5) [(x, x) | x <- [0 .. 5]] // [(0, 1), (0, 1)]
14:48:21 <lambdabot>   array (0,5) [(0,1),(1,1),(2,2),(3,3),(4,4),(5,5)]
14:48:29 <blackcustard> okay lambdabot does it right
14:48:36 <solistic> ClaudiusMaximus: Ah untilM_ is what I need, thx
14:48:44 <blackcustard> anyway, that's the source of the error
14:48:59 <blackcustard> the repeated tuple in the modifications list
14:49:56 <blackcustard> add in a "nub", and problem fixed
14:49:58 <blackcustard> thanks for the help
14:50:01 <blackcustard> :)
14:54:59 <pumpkin> preflex: seen kamatsu
14:54:59 <preflex>  kamatsu was last seen on #haskell 12 days, 11 hours, 5 minutes and 39 seconds ago, saying: it just feels like i'm pulling in alot of machinery to do something that should be cheap
14:58:41 <solistic> say does somebody know where the repo for stm is?
15:00:36 <Lemmih> solistic: code.haskell.org/stm/ might be it. Why do you ask?
15:00:52 <solistic> Lemmih: the package is brocken on hackage
15:01:01 <solistic> http://hackage.haskell.org/package/stm-2.2.0.0
15:03:05 <kmc> six six six
15:03:07 <kmc> the Number of the Beast
15:04:23 <Cleopatra> can someone tell me how to change the size of the steps when creating a list insted of [0..4] outputting [1,2,3,4] i want [0,2,4].
15:04:56 <Saizan> > [0,2..4]
15:04:56 <lambdabot>   [0,2,4]
15:05:44 <Cleopatra> thanks
15:05:48 <solistic> Lemmih: Hmm, the cabal file in the repo says 2.1.1.2, the latest version is 2.2.0.0
15:08:43 <Saizan> solistic: http://darcs.haskell.org/libraries/stm/
15:09:04 <solistic> Saizan: thx
15:24:04 * dagle didn't know that there were #ifdef in haskell.
15:24:47 <ddarius> There aren't, just like there aren't in C.
15:25:31 <dagle> Depends on how you see it.
15:26:28 <ddarius> You can run CPP on anything.
15:26:48 <kmc> but the C standard includes CPP
15:26:55 <kmc> while H98 / H2010 don't include CPP, do they?
15:27:06 <kmc> in GHC you need to turn it on with {-# LANGUAGE CPP #-}
15:27:31 <Martty> grand hadron collider
15:27:44 <kmc> also GHC's CPP doesn't comply with the C spec at all
15:28:37 <dagle> Some C CPP's allow #if *shrug*
15:28:52 <kmc> isn't #if in the spec?
15:28:56 <kmc> #if (constant expression)
15:29:21 <dagle> It's part of the never spec.
15:29:37 <dagle> Ken thompson never liked it.
15:29:51 <sipa> the never spec?
15:30:11 <dagle> newer*
15:30:24 <kmc> does Go use some preprocessor?
15:30:28 <dagle> Nope.
15:30:50 * hackagebot cassandra-thrift 0.6.6 - thrift bindings to the cassandra database  http://hackage.haskell.org/package/cassandra-thrift-0.6.6 (KirkPeterson)
15:31:00 * ddarius imagines CPP will be run over Go if it hasn't already happened.
15:31:21 <kmc> why is M4 not more popular?
15:31:31 <kmc> you can use M4 with GHC Haskell easily
15:31:38 <kmc> and it's a much more powerful preprocessor than CPP
15:31:44 <kmc> and would eliminate a lot of boilerplate in some situations
15:31:49 <kmc> in a vastly simpler way than Template Haskell
15:31:52 <ddarius> kmc: Because system information isn't stored as a bunch of m4 macros.
15:32:17 <ddarius> Also, you are more likely to have CPP than m4.
15:32:29 <enthropy> would somebody run both?
15:34:40 <kmc> i thought M4 was part of POSIX
15:35:06 <kmc> i think requiring M4 would be no worse than requiring Perl (see: Evil Mangler)
15:35:32 <kmc> though, that is pretty bad
15:35:45 <ddarius> Yes, but the choice is between requiring Perl and requiring Perl and m4.
15:39:15 <aristid> how about integrating something similar to m4 in GHC?
15:40:53 * hackagebot gnuidn 0.1.1.2 - Bindings for GNU IDN  http://hackage.haskell.org/package/gnuidn-0.1.1.2 (JohnMillikin)
15:43:17 <Eduard_Munteanu> M4 would be indeed powerful, but doesn't have to be M4.
15:43:38 <nostard> hi, i have som problems with using monad transformers: http://hpaste.org/41020/how_do_i_use_monad_transformer
15:45:18 <Saizan> nostard: is that with the "transformers" package alone?
15:46:23 <Eduard_Munteanu> I wonder if Haskell would make a great meta-Haskell.
15:47:02 <Saizan> nostard: you'd need to import Control.Monad.Trans.Class and use lift in that case
15:47:10 <nostard> Saizan: actually i don't know if it is Transformers or MTL, but i have imported Control.Monad.Identity, Control.Monad.Trans, Control.Monad.Trans.{Error,State}}
15:48:22 <nostard> Saizan: i change Trans to Trans.Class, now it seems to work(with lift) =)
15:48:34 <nostard> Saizan: thank you very much! :D
15:48:48 <Saizan> nostard: if you don't like lift i think you can just import Control.Monad.{Error,State} instead
15:52:31 <nostard> Saizan: and just omit lift? Didn't seem to work though
15:53:32 <Saizan> nostard: yep, since throwError put should now refer to the class methods that are polymorphic, and there should be enough instances to make it work
15:54:05 <Saizan> nostard: though i've never played with transformers/monads-fd much, so there might be some detail that escapes me
15:57:18 <nostard> Saizan: i didn't get it to work =/
15:57:59 <BluShift> hello
15:58:04 <BluShift> hello
15:58:10 <Saizan> hi
15:58:31 <BluShift> wasup
15:58:38 <Terry> @pl \x->x
15:58:38 <lambdabot> id
15:59:22 <Terry> @pl \f h -> f h >>= (\r -> hClose h >> return r)
15:59:22 <lambdabot> (`ap` ((. return) . (>>) . hClose)) . ((>>=) .)
16:00:33 <Terry> @pl \h f -> f h >>= (\r -> hClose h >> return r)
16:00:33 <lambdabot> ap (flip . ((>>=) .) . flip id) ((. return) . (>>) . hClose)
16:01:04 <solistic> whois Terry 
16:02:47 <tommd> There's a pending release of crypto-api that slightly changes the definition of CryptoRandomGen.  Also, MonadCryptoRandom (exactly what it sounds like), and DRBG (a secure prng) will see their first releases in ~2 days.
16:02:48 <tommd> All comments are welcome.
16:02:48 <tommd> MonadCryptoRandom: http://code.haskell.org/~tommd/MonadCryptoRandom/
16:02:48 <tommd> DRBG: http://code.haskell.org/~tommd/DRBG/
16:02:48 <tommd> crypto-api: http://code.haskell.org/crypto-api/
16:04:12 <Terry> tommd: what will DRBG use as the underlying mechanism?
16:06:57 <krey_> hello, why does haskell fail at writing unicode chars to files and how can I fix it?
16:07:33 <mauke> which haskell?
16:07:48 <Phyx-> /usr/bin/haskell
16:08:34 <krey_> ghc?
16:08:35 <tommd> haskell is a language, not an implementation.
16:09:00 <djahandarie> Any good links/papers for understanding the DPH stuff in-depth?
16:09:15 <krey_> tommd: but maybe it's only my implementation that failz
16:09:19 <tommd> GHC should work find for Unicode these days, but most people who do serious amounts of text are migrating to the "text" package on hackage.
16:09:25 <mauke> krey_: which ghc?
16:10:05 <benmachine> preflex: if anyone asks, I'm still around and can be contacted via email or pm
16:10:13 <tommd> Terry: Sorry, missed your Q somehow.  DRBG can be used directly, or though the CryptoRandomGen interface or through the higher level MonadCryptoRandom interface.
16:10:16 <krey_> mauke: Glasgow Haskell Compiler, Version 6.12.3, for Haskell 98, stage 2 booted by GHC version 6.12.1
16:10:30 <mauke> ah, 6.12
16:10:33 <Phyx-> can preflex actually be told stuff like that??
16:11:02 <Martty> preflex: where is benmachine
16:11:07 <Martty> preflex: seen benmachine
16:11:07 <preflex>  benmachine was last seen on #haskell 1 minute and 2 seconds ago, saying: preflex: if anyone asks, I'm still around and can be contacted via email or pm
16:11:10 <preflex> Phyx-: no
16:11:10 <djahandarie> Phyx-, you apparently haven't been keeping up with the serious AI work being done
16:11:15 <tommd> DRBG is a collection of concrete generators (ex: HmacDRBG, HashDRBG).  They have instances of CryptoRandomGen and that is usable by MonadCryptoRandom.
16:11:23 <tommd> Terry: ^^
16:11:46 <Phyx-> djahandarie: lol
16:12:42 <tommd> Was that your question or did you mean something else by "underlying mechanism"?  It uses ByteString for the key, value, entropy, and random byte streams.
16:13:24 <ddarius> edwardk: Feeling better?
16:15:14 <Phyx-> preflex: seen lispy
16:15:14 <preflex>  lispy was last seen on #darcs 11 hours, 35 minutes and 51 seconds ago, saying: ?tell kowey I finally signed up for twitter at the urging of dons (he said I can get SO updates easier among other things).
16:15:19 <SonOfLilit> Hello
16:15:26 <SonOfLilit> Any yesod users around?
16:15:58 <SonOfLilit> I'm trying to render a widget to html, to no avail
16:16:32 <SonOfLilit> renderHamlet render . toHamletValue $ do addBody $(hamletFile "blah")
16:17:03 <SonOfLilit> and I cannot get toHamletValue to be in scope
16:21:34 <Phyx-> @index sort
16:21:34 <lambdabot> Data.List
16:21:44 <Phyx-> @index toHamletValue
16:21:44 <lambdabot> bzzt
16:21:55 <Phyx-> still doesn't do packages huh
16:22:26 <tommd> SonOfLilit: Did you include Text.Hamlet?
16:22:45 <SonOfLilit> I just solved that issue
16:22:55 <SonOfLilit> by including text.hamlet more inclusively
16:23:07 <SonOfLilit> HamletValue(..)
16:23:19 <tommd> Yes, that's rather necessary.
16:23:43 <tommd> or just HamletValue(toHamletValue) but I don't see the point in limiting the import that much.
16:24:23 <SonOfLilit> I still have problems
16:24:31 <tommd> We all do
16:25:01 <Phyx-> most of us are seeking professional help
16:25:06 * hackagebot gnome-keyring 0.2.2.3 - Bindings for libgnome-keyring  http://hackage.haskell.org/package/gnome-keyring-0.2.2.3 (JohnMillikin)
16:25:38 <SonOfLilit> heh
16:25:48 <brisbin> SonOfLilit: i use a hack to do this, something like pc <- widgetToPageContent $ myWidget; return $ pageBody pc
16:25:49 <SonOfLilit> I'll try to grasp my problems enough to ask about them
16:25:59 <brisbin> but i'm sure that's not the smartest way
16:26:17 * Phyx- will stop trolling now
16:27:28 <SonOfLilit> brisbin: but I want html, not just the body
16:27:49 <brisbin> SonOfLilit: yeah, just realized that; my function is GHanlder s m (Hamlet (Route m)) anyway
16:28:05 <brisbin> i wanted something i could ^embed^ in another template and it worked that way
16:31:18 <SonOfLilit> http://hpaste.org/41021/yesod_trouble
16:32:18 <SonOfLilit> widget is: let widget = do {addBody [..]; addStyle [..];}
16:32:48 <brisbin> SonOfLilit: seems like an appropriate error
16:32:54 <SonOfLilit> brisbin: can you think of a reason to get this error?
16:32:55 <brisbin> look at the type sig of toHamletValue
16:36:06 <SonOfLilit> so the SORoute is there because it is expected by "renderHamlet render"?
16:36:59 <SonOfLilit> can you help me get this to work?
16:37:05 <brisbin> i could try
16:37:12 <brisbin> but it's a bit over my head, i just got started with yesod myself
16:37:41 <brisbin> can you paste the full source?
16:37:51 <brisbin> partContent is :: Html ?
16:38:13 <SonOfLilit> partContent is :: ByteString.Lazy
16:38:32 <SonOfLilit> cannot paste the entire code, not mine
16:38:36 <brisbin> oh i see
16:38:58 <brisbin> so what's render?
16:39:01 <brisbin> typewise
16:39:41 <SonOfLilit> (SORoute -> [(String, String)] -> String)
16:41:06 <brisbin> try... do { pc <- widgetToPageContent widget; renderHtml render (pageBody pc); }
16:41:09 <brisbin> just for kicks
16:43:03 <brisbin> sorry, renderHamlet...
16:46:32 <glovesoff> okay what exactly is a dons?
16:46:50 <glovesoff> what's one don?
16:47:00 <Eduard_Munteanu> dons? It's our Don Stewart.
16:47:02 <mauke> dons is a don
16:47:41 <m3ga> pity there's only one
16:47:49 <glovesoff> then why is it dons?
16:47:57 <glovesoff> if there's only one
16:48:04 <glovesoff> I don't get it
16:48:05 <pumpkin> don stewart
16:48:14 <pumpkin> glovesoff: do you have any questions about haskell?
16:48:17 <Eduard_Munteanu> DonS
16:48:53 <glovesoff> pumpkin: yes in fact I have. I wonder has anyone ever seen a real Snocadile?
16:48:58 --- mode: ChanServ set +o pumpkin
16:49:09 <pumpkin> what's the haskell question?
16:49:16 <pumpkin> (you're not a very good troll, so far)
16:49:41 <glovesoff> Okay how do I write directly in Core?
16:50:04 <glovesoff> I want to write all my code in haskell Core
16:50:12 <glovesoff> it just seems better
16:50:15 --- kick: glovesoff was kicked by pumpkin (Your behavior is not conducive to the desired environment.)
16:50:49 <SonOfLilit> brisbin: it seems to want pc to be lazystring
16:51:11 * ddarius thinks he has a blister with a blister inside of it.
16:51:16 --- mode: pumpkin set +b *!*@*80.212.75.146
16:51:36 <brisbin> SonOfLilit: hmm
16:51:43 <Saizan> ddarius: someone heard you like pain?
16:51:54 <pumpkin> yo dawg
16:51:59 --- mode: pumpkin set -o pumpkin
16:51:59 <Eduard_Munteanu> That happens often when playing some instruments...
16:52:39 <ddarius> Eduard_Munteanu: Yeah, it's from using my ring finger when playing bass, which I don't normally use.
16:53:04 <ddarius> Saizan: She told you?!
16:53:19 <djahandarie> Oh dear
16:55:08 <Eduard_Munteanu> I see, I'm using three as well. I remember having more odious blisters than people playing guitar, lotsa pain. It happens every now and then if I take long breaks.
16:55:26 <SonOfLilit> how is one /supposed/ to use the fact that Widget is an instance of HamletValue?
16:56:18 <Eduard_Munteanu> um, three fingers
16:56:25 <brisbin> SonOfLilit: it is?
16:57:21 <SonOfLilit> it is, that's why I tried using toHamletValue
16:57:32 <ddarius> Eduard_Munteanu: Red Hot Chili Pepper's "Hard to Concentrate" is the song leading to this.  It's a great song with a fun bass line.
16:57:43 <SonOfLilit> but apparently it's more complicated that just calling that on a Widget
16:58:40 <augur> is =<< a thing in haskell? :|
16:59:00 <Eduard_Munteanu> Heh, haven't listened to that band for quite some time.
16:59:20 <Eduard_Munteanu> augur: flip >>=, it is standard IIRC
16:59:26 <Eduard_Munteanu> :t (<<=)
16:59:27 <lambdabot> Not in scope: `<<='
16:59:31 <augur> :t =<<
16:59:32 <lambdabot> parse error on input `=<<'
16:59:37 <augur> :t (=<<)
16:59:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:59:40 <dbelange> :t <=<
16:59:41 <lambdabot> parse error on input `<=<'
16:59:42 <augur> interesting
16:59:42 <Eduard_Munteanu> Oh, my bad.
16:59:51 <Eduard_Munteanu> :t (<=<)
16:59:52 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
17:00:21 <brisbin> SonOfLilit: try toHamletValue $ return widget
17:00:31 <brisbin> toHamletValue expects the a value to be in the HamletMonad
17:00:44 <brisbin> is your function in that monad?
17:00:49 <Eduard_Munteanu> augur: might make sense if you like the (.) ordering
17:00:51 <brisbin> if so return should work
17:01:01 <dbelange> (.) (.) ordering
17:03:10 <SonOfLilit> to return (), it has to be (), but it is GWidget
17:03:37 <ddarius> @index (=<<)
17:03:37 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
17:03:58 <brisbin> SonOfLilit: why does it have to be return ()?
17:04:02 <Eduard_Munteanu> ddarius: I hear byorgey plays something too, piano I think, according to his blog. I wonder what #haskell will name such a band :D
17:05:00 <SonOfLilit> because toHamletValue expects HamletMonad a ()
17:05:07 <brisbin> hrm
17:05:13 <brisbin> return widget () ?
17:05:20 <ddarius> Eduard_Munteanu: pumpkin plays piano.  I play guitar, violin, and banjo in addition to bass guitar.  edwardk played bass (and guitar?) a long time ago, but I don't think he remembers any.
17:05:23 * brisbin is floundering...
17:05:38 <SonOfLilit> is that legal haskell? what does it do?
17:05:50 <brisbin> no idea
17:05:59 * brisbin does haskell by trial and error mostly
17:06:30 <ddarius> SonOfLilit: It's legal Haskell, and even has meaning if certain instances are in scope.
17:06:33 <Twey> It's okay.  You start off that way.  :þ
17:06:42 <ddarius> (Namely, it would be widget.)
17:07:01 <Eduard_Munteanu> ddarius: nice, that's something. I'm fair only on bass, other than that I've only played QWERTY "piano".
17:07:03 <SonOfLilit> ddarius: what does it do?
17:07:31 <ddarius> SonOfLilit: It evaluates to widget.
17:08:39 <sipa> return widget ()  =  (return widget) (), which means that (return widget) must be of type (() -> a)
17:08:49 <Saizan> SonOfLilit: about your type error, can you paste "ghc-pkg list hamlet" ?
17:09:19 <mauke> > return 42 ()
17:09:20 <lambdabot>   42
17:09:21 <SonOfLilit> 0.5.1
17:09:46 <Saizan> only one version?
17:09:53 <SonOfLilit> yes
17:10:10 <SonOfLilit> and yesod 0.5.4.2
17:12:51 <SonOfLilit> even if I succeed using toHamletValue, wouldn't it just leave me with a Widget?
17:12:51 <Eduard_Munteanu> BTW, is there any standard 'flip (.)'?
17:13:02 <pumpkin> >>>
17:13:12 <Eduard_Munteanu> :t (>>>)
17:13:13 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
17:13:21 <Eduard_Munteanu> pumpkin: thanks
17:13:26 * alpounet is reading abut coalgebras
17:13:29 <alpounet> about*
17:13:32 <SonOfLilit> toHamletValue :: HamletMonad  a ()  -> a, and here a would be something like "Widget", right?
17:13:41 <Eduard_Munteanu> Hm, how come that works on functions?
17:13:49 <pumpkin> (->) is an instance of Category
17:13:54 <Eduard_Munteanu> Oh.
17:14:03 <Eduard_Munteanu> :t (>=>)
17:14:04 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:14:05 <djahandarie> (a -> b) -> (b -> c) -> (a -> c)
17:14:17 <Eduard_Munteanu> that was the closest I knew for monadic composition.
17:14:19 <pumpkin> >>> is >=> on Kleisli m, for Monad m
17:14:32 <pumpkin> :k Kleisli
17:14:33 <lambdabot> (* -> *) -> * -> * -> *
17:15:02 <Eduard_Munteanu> They're naming it category because it's rather an arrow?
17:15:19 <pumpkin> Category is a superclass of Arrow
17:16:00 <SonOfLilit> I'm really lost with this :S
17:16:02 <Eduard_Munteanu> pumpkin: is there any direct relation to a category-theoretic category?
17:16:02 <pumpkin> it's called Category because it resembles categories from category theory
17:16:23 <ddarius> Eduard_Munteanu: An instance of Category that satisfies the laws is a category-theoretic category.
17:16:52 <Eduard_Munteanu> Ah, I'd probably look at Category's class then...
17:17:02 <Eduard_Munteanu> It's just that Category a b didn't make much sense at first sight.
17:19:11 <Juked07> hi guys
17:19:38 <ddarius> alpounet: Check out J. J. M. M. Rutten's work.
17:19:55 <Juked07> if anyone has a sec, i'm trying to learn some basics about functors
17:20:07 <Juked07> i looked at the typical examples for like, Maybe, list, Tree
17:20:20 <Twey> Juked07: Functors are values that can conceptually have a function applied to the value ‘inside’ them.
17:20:29 <Juked07> and I think I understand what's going on there, but I get confused when more abstract type/type constructors are involved
17:20:33 <Juked07> like
17:20:36 <Juked07> if i have a data type
17:20:44 <Juked07> data F1 a = F1 (a -> Int)
17:20:48 <Juked07> can i make that an instance of functor?
17:20:53 <ddarius> No.
17:21:15 <Juked07> is that because i'd need to get back out something like (b -> Int)
17:21:26 <Juked07> and I can't get (b -> int) from (a -> int) and (a -> b)?
17:21:46 <mauke> @hoogle cofmap
17:21:46 <lambdabot> No results found
17:21:52 <alpounet> thanks ddarius 
17:21:57 <ddarius> Juked07: Yes, and the reason you can't is due to the fact that F1 is contravariant in a whereas Functor represents covariant functors.
17:22:24 <Juked07> i'll look up those words now heh.. thanks
17:22:28 <Twey> Juked07: It's because there's no a ‘inside’ the value.  An a is what you pass in; there's no value of type a that can be modified.
17:22:33 <pumpkin> there's contrafunctor in category-extras
17:22:39 <pumpkin> it's called contramap
17:22:39 <Twey> (in slightly less scary vocabulary ;))
17:22:53 <Juked07> ahh
17:23:06 <Juked07> that makes sense
17:23:22 <Juked07> but if i have instead a constructor
17:23:23 <SonOfLilit> brisbin: any other guess before I go to sleep?
17:23:30 <Juked07> data F a = F (a -> a)
17:23:53 <brisbin> fraid i'm stumped. you could send the author an email, he's very accessible
17:23:54 <ddarius> That's invariant in a and thus not a Functor.
17:24:00 <brisbin> SonOfLilit: or post a comment on the docs site
17:24:03 <mauke> @src Endo
17:24:03 <lambdabot> Source not found. Are you on drugs?
17:24:13 <Juked07> ok, thank you
17:24:15 <ddarius> :t appEndo
17:24:15 <lambdabot> forall a. Endo a -> a -> a
17:24:20 <Eduard_Munteanu> What would be wrong with something along the lines of... fmap f (F1 x) = F1 (f x)  -- ?
17:24:30 <pumpkin> Eduard_Munteanu: wrong types
17:24:37 <Eduard_Munteanu> :t fmap
17:24:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:24:44 <pumpkin> if anything you'd want f . x
17:24:50 <Twey> fmap f (F1 x) = fmap (f . x)
17:24:53 <Twey> Yeah
17:24:55 <pumpkin> but that's backwards
17:24:56 <Twey> Err
17:24:59 <Twey> = F1 (f . x)
17:24:59 <Eduard_Munteanu> x . f
17:25:08 <Twey> Doesn't either work?
17:25:10 <pumpkin> try it :P
17:25:17 <Twey> Rgh
17:25:20 <Twey> Instances mean files
17:25:22 <pumpkin> your function goes in the wrong direction
17:25:23 <Twey> Files mean effort
17:25:31 <Eduard_Munteanu> Anyway, so it is a Functor instance then?
17:25:38 <mauke> Twey: get a computer that makes file creation easy
17:25:39 <pumpkin> you want (a -> b) -> (f b -> f a)
17:25:48 <pumpkin> but Functor is (a -> b) -> (f a -> f b)
17:25:55 <Twey> mauke: Haha… it's pretty easy, but not nearly as easy as typing something to the bot :þ
17:26:10 <Twey> I'd have to go all the way over there to that other tab, and created a file, and loaded it into GHCi
17:26:14 <aristid> is there an idiom to deal with deeper fmaps?
17:26:15 <Twey> Which I could have done about ten times over by now
17:26:18 <pumpkin> it's still a functor, but not a possible instance of Functor
17:26:19 <Twey> But it's late
17:26:30 <aristid> like, fmap f `fmap` y
17:26:58 <Eduard_Munteanu> Oh I kinda get it.
17:27:31 <pumpkin> the issue is that a function arrow is contravariant in its first argument and covariant in its second
17:27:52 <pumpkin> so if you have type whose parameter ends up being the domain of a function rather than its codomain
17:28:22 <Eduard_Munteanu> I'm having a dillema about the type system though... does an (a -> b) qualify as a 'c'?
17:28:37 <Eduard_Munteanu> > (id id) 3
17:28:37 <lambdabot>   3
17:28:41 <Eduard_Munteanu> oh it does.
17:29:20 <pumpkin> here was a little experiment with variance in functors: http://hpaste.org/40974/functor_variance
17:30:20 <Twey> I don't get it, but I might tomorrow.  'night all.
17:30:30 <Eduard_Munteanu> So if f :: (a -> b)  then my (f x) :: b, regardless whether x is a function or not.
17:30:39 * Eduard_Munteanu looks
17:30:47 <ddarius> pumpkin: Interesting.
17:31:03 <pumpkin> Eduard_Munteanu: x must be an `a`, but a could be any type including functions
17:31:19 <ddarius> pumpkin: You may want to (re)look at Hagino's thesis and perhaps try to encode his functor calculus described early on.
17:31:36 <pumpkin> ddarius: that's after a few failures and GHC not liking my initial attempts
17:31:39 <pumpkin> :P
17:31:58 <pumpkin> oh CPL?
17:32:02 <ddarius> Yes.
17:32:24 <pumpkin> I haven't read that yet, but added it to my queue a couple of days ago
17:32:44 <gwern> functor calculus? do I even want to know
17:32:59 <Eduard_Munteanu> pumpkin: so 'fmap f (F1 x) = F1 (f x)' should work as an instance for 'data F1 a = F1 (a -> Int)'
17:33:12 <pumpkin> no
17:33:34 <pumpkin> if anything it would be fmap f (F1 g) = F1 (f . g) if you have data F1 a = F1 (Int -> a)
17:33:38 <alpounet> nice pumpkin 
17:33:47 <pumpkin> (note the inverted domain/codomain)
17:33:48 <gwern> @wn fash
17:33:49 <ddarius> gwern: It's just a way to write functor expressions and keep track of variance.
17:33:49 <lambdabot> No match for "fash".
17:33:57 <gwern> man, why do I even bother with wordnet
17:34:09 * Eduard_Munteanu computes
17:34:20 <pumpkin> or maybe g . f
17:34:27 <pumpkin> yeah
17:34:40 <pumpkin> anyway, only one of them fits Functor :)
17:34:41 <Eduard_Munteanu> pumpkin: oh, the type constructor gives 'a'.
17:34:49 <Eduard_Munteanu> in F1 a
17:34:56 <pumpkin> ?
17:35:04 <pumpkin> actually it is f . g
17:35:13 <pumpkin> Eduard_Munteanu: it's a function that returns a
17:35:14 <Eduard_Munteanu> a can't be some 'a -> Int'
17:35:24 <ddarius> @djinn (a -> b) -> (a -> Int) -> (b -> Int)
17:35:24 <lambdabot> Error: Undefined type Int
17:35:28 <pumpkin> that wouldn't make sense
17:35:32 <Eduard_Munteanu> because a is bound by the type constructor F1
17:35:48 <pumpkin> a is completely free
17:35:48 <ddarius> @djinn (a -> b) -> (a -> ()) -> (b -> ())
17:35:49 <lambdabot> f _ _ _ = ()
17:35:56 <pumpkin> ouch
17:36:42 <ddarius> That's the only (total) function of that type and suffice to say, it doesn't satisfy the functor laws.
17:37:05 <Eduard_Munteanu> It is, but in fmap, a is given by 'f a', where f = F1
17:37:06 <ddarius> (Actually, it does with () ...)
17:37:20 <Eduard_Munteanu> I was confusing the type constructor with the data constructor.
17:37:22 <pumpkin> Eduard_Munteanu: I think you're confused :P
17:37:40 <ddarius> (If restricted to total functions only.)
17:38:27 <Eduard_Munteanu> pumpkin: possibly. I was looking why mine didn't work, and why it works for some data F2 a = F2 a
17:38:35 <pumpkin> Eduard_Munteanu: because it's a function
17:38:50 <Eduard_Munteanu> Yeah.
17:39:04 <pumpkin> fmap :: (a -> b) -> F1 a -> F1 b  ===> (a -> b) -> (a -> Int) -> (b -> Int)
17:39:07 <pumpkin> try to write that function
17:39:44 <pumpkin> now try to write (a -> b) -> (Int -> a) -> (Int -> b) or (a -> b) -> (b -> Int) -> (a -> Int)
17:40:05 <Eduard_Munteanu> And the elaborate explanation is the type variable 'a' in fmap refers to the type variable on the lhs of F1's data declaration, that was my confusion. Don't you agree?
17:41:17 <Eduard_Munteanu> (It should be the same thing with "it's a function" after all)
17:41:22 <krey_> is there some kind of monoid instance for (a -> m b)?
17:41:34 <krey_> (Monoid m)
17:41:48 <aristid> krey_: Monoid m makes no sense, wrong kind
17:42:05 <Eduard_Munteanu> krey_: there's MonadPlus that subsumes monad + monoid, if that's what you ask.
17:42:06 <krey_> aristid: true
17:42:25 <krey_> rephrase: (a -> b) for Monoid b
17:42:42 <Saizan> there is an instance like that
17:43:10 <krey_> Saizan: cool, but why? is there a list of instances for each class?
17:43:26 <krey_> (ie. how can I find out without asking you guys?)
17:43:31 <Saizan> > (\x -> [x,x]) `mappend` (\y -> [y]) $ 1
17:43:32 <lambdabot>   [1,1,1]
17:43:32 <ddarius> :info in GHCi
17:43:36 <ddarius> @instances Monoid
17:43:36 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
17:43:43 <aristid> > GT `mappend` LT
17:43:44 <lambdabot>   GT
17:43:56 <Eduard_Munteanu> pumpkin: possibly I'm trying too much sense of it, but that's how I'd generalize it so I don't hit the same problem.
17:44:05 <Eduard_Munteanu> *to make too much
17:44:05 <aristid> crazy that Ordering is a Monoid
17:44:10 <ddarius> aristid: No it isn't.
17:44:14 <krey_> ?
17:44:17 <ddarius> It's quite useful too.
17:44:22 <Saizan> krey_: in this case since it's defined in the same package as the class you can look at the haddock docs for Data.Monoid
17:44:38 <krey_> ghci :info was what I needed
17:44:48 <aristid> ddarius: well i haven't figured it out yet what is the intuition behind it. trying to do so right now.
17:45:15 <aristid> lexicographical ordering, hmm
17:45:16 <krey_> aristid: I had to use it for some circuit
17:45:32 <aristid> > zipWith compare "abc" "acb"
17:45:33 <lambdabot>   [EQ,LT,GT]
17:45:44 <aristid> > mconcat $ zipWith compare "abc" "acb"
17:45:45 <lambdabot>   LT
17:45:51 <aristid> nice.
17:46:21 <aristid> @let (.:) = fmap.fmap
17:46:22 <lambdabot>  Defined.
17:46:32 <aristid> :t mconcat .: zipWith compare
17:46:32 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
17:47:44 <byorgey> Eduard_Munteanu, ddarius: yes, I play piano (but I don't usually get blisters from it =)
17:48:17 <ddarius> byorgey: You probably would if you replaced the keys with steel strings under tension.
17:49:20 <djahandarie> lol
17:49:38 <byorgey> ddarius: so, like, a manually plucked harpsichord?
17:50:15 * Eduard_Munteanu at some point pondered whether superglue would fix a blister, heard rumors about Flea.
17:50:20 <bluckbuobleoo> someone send boxs here?
17:50:35 <Axman6> o.O
17:51:03 <byorgey> @faq can Haskell send boxs?
17:51:04 <lambdabot> The answer is: Yes! Haskell can do that.
17:51:39 <bluckbuobleoo> i buy for anyone selling
17:51:43 <Eduard_Munteanu> I think we should replace @faq to say "No! Haskell is too lazy to do that.".
17:51:59 <byorgey> maybe it should pick between them randomly
17:52:02 <Axman6> bluckbuobleoo: what?
17:52:26 <byorgey> might help mitigate the success
17:57:07 <Eduard_Munteanu> Hah, I just pissed off a troll on privmsg.
17:57:08 <gwern> does haskell like green eggs and ham?
17:57:14 <gwern> does haskell like foxes in boxes?
17:57:51 <aristid> gwern: yes and yes.
17:57:57 <ddarius> Jaynes has a reasonably interestng paper on piano design, by the way.
17:58:09 <gwern> E.T. Jaynes?
17:58:14 <ddarius> Yes.
17:58:25 <gwern> didn't know he cared. what on earth is it about?
17:58:31 * hackagebot mongoDB 0.8 - A driver for MongoDB  http://hackage.haskell.org/package/mongoDB-0.8 (TonyHannan)
18:04:39 <ddarius> http://bayes.wustl.edu/etj/music.html  The title is rather misleading.
18:08:34 <gwern> ddarius: I am surprised at the lack of statistics
18:08:45 <gwern> I suppose everyone really does have a hobby they are an expert at
18:10:06 <krey_> i have a class Convert a b, with a method convert :: a -> b, why won't haskell let me have an instance st. a = Regexp ab, b = StateT [ab] [] ()? 
18:10:07 <dbelange> gwern: It's called a sperg interest
18:13:17 <Axman6> krey_: you'll need to paste that code somewhere where we can see what you're trying to do
18:14:08 <Eduard_Munteanu> krey_: I'm not sure how much sense that makes, but you kinda need the extension for multi-type-pararameter classes
18:15:35 <Eduard_Munteanu> I think there's some confusion in there.
18:15:55 <gwern> dbelange: I have never heard that term before
18:16:34 <krey_> Axman6: http://pastebin.com/HwrKXHUD
18:16:45 <gwern> dbelange: sperg seems to be a cartoon character
18:19:26 <dbelange> gwern: http://www.urbandictionary.com/define.php?term=Sperg
18:20:25 <gwern> dbelange: writing a long detailed book on piano playing, a hobby, is describale by a term for 'temper-tantrums'?
18:20:33 <gwern> the logic continues to elude me
18:23:19 <Saizan> krey_: haskell98 was very conservative on the sorts of instances you can make, so just turn on FlexibleInstances :)
18:23:56 <gwern> maybe dbelange is subtly tempting me to 'sperge' about his illogical use of 'sperge'. very clever, dbelange
18:24:10 <krey_> Saizan: why were they conservative about it?
18:24:17 <Saizan> krey_: a possible side-effect of allowing instances like the one you've there is that it's easier to get overlapping ones, but you can worry about that when/if it happens
18:24:57 <gwern> krey_: because it's a standard. standards are always conservative
18:25:16 <krey_> Saizan: is there something i can add to the source to tell ghc to use that extension?
18:25:19 <gwern> well, except for a few crazy instances like adding typeclasses which are the examples that prove the rule
18:25:21 <Saizan> krey_: afaiu, at the time there was less confidence over what was sanely implementable and/or needed
18:25:34 <Saizan> krey_: yes, {-# LANGUAGE FlexibleInstances #-}
18:25:48 <krey_> Saizan: thanks :)
18:26:44 <krey_> Saizan, gwern: are these "tweaks" becoming part of the standard any time soon?
18:28:31 <gwern> krey_: in theory we have an active standardization process. it takes forever though - it was something of a miracle that haskell 2010 even exists
18:29:28 <Saizan> they switched to a yearly "rolling release", so they should get to it
18:29:43 <Saizan> http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleInstances <- page of the proposal
18:30:32 <pumpkin> is anything interesting happening in 2011 at all
18:31:40 <Axman6> nope, everyone's waiting for 2012, when the world ends
18:33:37 <gwern> Axman6: actually I hear the deadline got bumped back 80 days
18:33:46 <gwern> so we'll have to wait a little longer than expected
18:38:15 <hard_shooter> gwern: that's the 14th end of the maya calendar...
18:38:57 <hard_shooter> maya calendar is cyclic
18:40:41 <hard_shooter> Is it the apocalypse every 144,000 days ?
18:43:47 <ddarius> > 12^2 * 10^3
18:43:48 <lambdabot>   144000
18:44:19 <ninly> ftr, the 2012 thing is based on the reset of the mayan "long count", which is independent of the other nested cycles of the mesoamerican calendar
18:44:27 <ninly> if i remember correctly, it's been a while
18:45:47 * hackagebot dbus-core 0.8.5.2 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.8.5.2 (JohnMillikin)
18:45:49 * hackagebot dbus-client 0.4.0.2 - Monadic and object-oriented interfaces to DBus  http://hackage.haskell.org/package/dbus-client-0.4.0.2 (JohnMillikin)
18:47:18 <to_On1> someone can give me a practical example of lazy programming?
18:48:52 <Botje> reusing publicly available code
18:50:13 <ddarius> label = zip [0..]
18:50:49 <caelan> primes = filter prime [2..]
19:06:46 <monochrom> argument for using more than ascii symbols: http://queue.acm.org/detail.cfm?id=1871406
19:10:37 <mauke> "Programmers are a picky bunch when it comes to syntax, and it is a sobering thought that one of the most rapidly adopted programming languages of all time, Perl, barely had one for the longest time."
19:10:41 <mauke> what
19:10:48 <mauke> did you mean: Lisp
19:10:53 * hackagebot network-protocol-xmpp 0.3.2.3 - Client->Server XMPP  http://hackage.haskell.org/package/network-protocol-xmpp-0.3.2.3 (JohnMillikin)
19:12:12 <Kaidelong> I think he was referring to consistence there
19:13:02 <dolio> That sentence doesn't make sense with Lisp, either.
19:13:19 <mauke> "It was certainly a fair tradeoff—just think about how fast you type yourself—but the price for this temporal frugality was a whole new class of hard-to-spot bugs in C code."
19:13:47 <mauke> I have NEVER EVER made that mistake, and I don't think I've seen it in other people's code
19:13:57 <mauke> (confusing | with ||)
19:14:33 <mauke> "C++ is probably the language that milks the ASCII table most by allowing templates and operator overloading."
19:14:39 <mauke> bullshit, C++ doesn't even use @ or `
19:15:00 <mauke> Perl, on the other hand, actually uses control characters from the 0..31 range
19:15:14 <mauke> and Haskell lets you define your own operators, so there
19:16:10 <caelan> the keyboard issue is a big one for me
19:16:13 <ddarius> Yeah, that article seems pretty crappy.
19:16:40 <ddarius> I also don't see how using vi keeps you from using Unicode.
19:17:15 <fcahoon> i'm totally not buying his argument, because you can always use combinations of characters.
19:17:55 <mauke> "The most recent programming language syntax development that had anything to do with character sets apart from ASCII was when the ISO-C standard committee adopted trigraphs"
19:18:06 <mauke> hello and welcome to the exciting new world of digraphs
19:18:26 <Draconx|Laptop> ddarius, well, maybe he was using the original vi editor from the 70s?
19:19:27 <Kaidelong> which article is this?
19:19:36 <mauke> "Syntax-coloring editors are the default. Why not make color part of the syntax?"
19:19:44 <mauke> because some people fucking hate syntax coloring
19:19:56 <mauke> and some people are color blind or just blind
19:19:57 <fcahoon> and some people are colorblind?
19:20:01 <Kaidelong> yeah was about to say
19:20:27 <Kaidelong> when I was in my game dev class a few years back I always wrote in my final papers on how I took care about making sure colorblind people could play it
19:20:36 <Kaidelong> it doesn't seem like all that uncommon a thing to remember
19:22:15 <ddarius> Draconx|Laptop: You could still enter Unicode.  It wouldn't render as Unicode, but you could enter it.
19:23:33 <caelan> i actually *like* verbose code
19:24:10 <Axman6> i like verbose code if it's clearer
19:24:10 <caelan> not redundant code, but verbose code
19:24:16 <caelan> right
19:27:18 <mxc> hi
19:27:23 <mxc> anyone using AWS?
19:27:33 <dbelange> no
19:27:36 <dbelange> go away
19:27:46 <Axman6> o.O
19:27:54 <danderson> hey, keep cool.
19:28:08 <Saizan> what is AWS?
19:28:20 <danderson> amazon web services, probably.
19:28:24 <danderson> (S3, EC2, all that)
19:28:52 <blackdog> mxc: yes, a little. it's easier if you actually ask a question, though:)
19:28:52 <mxc> yeah
19:29:24 <mxc> well, my question is which of their distro's better support ghc and HP
19:29:52 <mxc> or, are there any problems with using suse, since that seems to be their primary linux distro
19:45:58 <endojelly> the lambda cube is really elegant
19:46:20 <endojelly> pi abstraction still gives me a headache sometimes, though.
19:46:34 <endojelly> guess I'd have to actually play around with the judgements
19:49:51 <lispy> is "< tagname >" valid in XML?
19:50:02 <lispy> Or does it have to be "<tagname>" ?
19:50:06 <cads_> hey, what is fmapping, really?
19:50:25 <lispy> What's a little fmap between friends, eh?
19:50:27 <cads_> It seems like a way to raise a function in hask into the target an endofunctor of hask.
19:50:45 <cads_> in a way that agrees with the endofunctor, actually
19:51:15 <lispy> > let {friend1 = (+1); friend2 = [1..3]} in friend1 `fmap` friend2
19:51:16 <lambdabot>   [2,3,4]
19:51:25 <cads_> hehe
19:52:05 <endojelly> lispy, let's take a look at the official spec
19:53:10 <endojelly> 39]   	element	   ::=   	 EmptyElemTag
19:53:11 <endojelly> | STag content ETag	[WFC: Element Type Match]
19:53:11 <endojelly> [VC: Element Valid]
19:53:15 <endojelly> hmm, doesn't paste well
19:53:25 <endojelly> STag   ::=   '<' Name (S Attribute)* S? '>
19:53:36 <endojelly> [5]   Name   ::=    NameStartChar (NameChar)*
19:54:15 <lispy> endojelly: thanks, I was having a hard time finding a reference
19:54:42 <lispy> endojelly: okay, so in that reference, what does it say about lexing?
19:54:47 <endojelly> lispy, I'm not one hundred percent sure, but looking at the grammar, it seems that < foo > is not valid
19:55:07 <lispy> endojelly: I think to be 100% sure we'd have to look at the lexing rules.
19:55:22 <lispy> endojelly: for example, what separates Ss?
19:55:25 <endojelly> lispy, well it contains a BNF grammar down to the caracter level
19:55:45 <endojelly> lispy, S is a whitespace
19:55:46 <lispy> "<img alt="blah" >" is valid, IIRC
19:55:58 <lispy> ah, I see
19:56:04 <endojelly> lispy, yes, according to STag   ::=   '<' Name (S Attribute)* S? '>
19:56:09 <endojelly> lispy, that is valid.
19:56:17 <lispy> '<' S* Name (S Attribute)* S? '>' would match '< tagname >'
19:56:23 <endojelly> lispy, notice that there's S? before '>'
19:56:30 <endojelly> lispy, but nor after '<'
19:56:42 <endojelly> lispy, exactly
19:58:57 <endojelly> really, this has been said way too often already, but XML is a mess.
20:00:06 <cads_> If we have that a the functor is f, bust there exist a commutative square (s : a -> b, fmap s : f a -> f b,  fa : a -> f a, fb : b -> f b) if f is to work as a real functor?
20:00:42 <cads_> where I'm guessing fb and fa are instances of the point function from the pointed functor
20:00:50 <cads_> but I'm not sure about this
20:02:57 <cads_> oh, this is not quite what a functor is
20:13:22 <pumpkin> cads_: you're confusing types and values, I think
20:14:24 <pumpkin> Maybe :: * -> * is the functor, taking objects * to objects *, and morphisms (a -> b) to morphisms (Maybe a -> Maybe b)
20:14:58 <pumpkin> or it'd be clearer if I said objects (a :: *) to objects (Maybe a :: *)
20:16:08 <pumpkin> so you wouldn't want the b -> f b parts for a plain ol' functor
20:18:17 <monochrom> oh hi pumpkin, happy halloween, enjoy http://xkcd.com/804/ :)
20:25:07 <aristid> pumpkin: today would be the perfect day for calling yourself copumpkin instead
20:25:40 <aristid> also, why did i not notice http-enumerator earlier?
20:28:40 <monochrom> @quote monochrom copumpkin
20:28:40 <lambdabot> monochrom says: Absolute0> copumpkin: do you give out free pumpkins on halloween? :) monochrom> I think copumpkin takes in free pumpkins.
20:30:16 <aristid> monochrom: a classic #haskell-type joke
20:31:17 <monochrom> hee hee
20:34:16 * hackagebot buildbox 1.2.1.0 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-1.2.1.0 (BenLippmeier)
20:46:04 <copumpkin> damn!
20:54:59 <xiackok_> hello everybody
20:56:02 * caelan just had animaniacs deja-vu
20:56:39 <cads_> yeah, pumpkin :)
20:56:47 <cads_> copumpkin, *
20:56:52 <cads_> whatever!
20:56:57 <cads_> :)
21:26:45 <dobblego> @hoogle ifM
21:26:46 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
21:26:46 <lambdabot> Network.HTTP.Headers HdrIfMatch :: HeaderName
21:26:46 <lambdabot> Network.HTTP.Headers HdrIfModifiedSince :: HeaderName
21:26:54 <dobblego> has anyone put ifM on hackage?
21:31:42 <kmc> i would look in monad-loops but it doesn't seem to be there
21:31:44 <kmc> try hayoo
21:31:47 <kmc> try also by type
21:32:07 <dobblego> Control.Monad.IfElse looks to almost have it
21:33:22 <blut> i have a Could not find module 'XMonad.Actions.GroupNavigation'
21:34:52 <kmc> blut, that's not a standard module in xmonad or xmonad-contrib
21:44:49 <Axman6> @hoogle (a-> Bool) -> Maybe a -> Maybe a
21:44:49 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
21:44:49 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
21:44:49 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
22:13:27 <kfish> anyone up for a haskell+web internship in tokyo? http://www.haskell.org/pipermail/haskell-cafe/2010-November/085773.html
22:14:42 <Axman6> what's the extension that lets you use f (foo -> Just x) = bar x?
22:20:08 <copumpkin> Axman6: view patterns
22:22:29 <Axman6> :ta
22:27:46 <geokavel> hi
22:43:27 <Saizan> hi
