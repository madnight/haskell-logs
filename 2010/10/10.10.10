00:01:17 <tolkad> it's kind of strange that a package like this would be GPL: http://hackage.haskell.org/package/numeric-prelude
00:01:18 <tolkad> Is there any reason for that?
00:06:02 <kmc> you should probably ask Henning Thielemann
00:09:30 <tolkad> ok
00:09:45 <tolkad> I'll check the WHOIS record on that domain
00:10:30 <augur> whats the lambdabot type thingy?
00:10:36 <augur> :t right?
00:10:36 <lambdabot> parse error (possibly incorrect indentation)
00:10:43 <augur> aha!
00:10:53 <tolkad> hmm, it's registered in someone elses name, not sure how I can get his number. also it's kind of early to be calling someone in germany
00:10:54 <augur> why wont it work in /msg
00:10:54 <augur> odd
00:12:35 <augur> > sign
00:12:35 <lambdabot>   Not in scope: `sign'
00:12:43 <augur> > even
00:12:43 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
00:12:44 <lambdabot>    arising fro...
00:12:45 <tolkad> > signum 4
00:12:46 <lambdabot>   1
00:12:49 <tolkad> > signum (-4)
00:12:49 <lambdabot>   -1
00:12:51 <augur> that works
00:12:55 <augur> :t signum . (+)
00:12:56 <lambdabot> forall a. (Num a) => a -> a -> a
00:13:02 <augur> so it does work, ok.
00:13:12 <augur> or does it
00:13:36 <augur> :t \x y -> signum (x + y)
00:13:37 <lambdabot> forall a. (Num a) => a -> a -> a
00:13:46 <ddarius> augur: Use @type in /msg
00:13:50 <augur> ah!
00:14:03 <tolkad> (signum . (+)) takes two numbers, adds them, and returns -1 if the result is negative or 1 if the result is positive
00:14:17 <augur> tolkad: then why isnt it Num -> Num -> Int
00:14:24 <augur> instead of Num -> Num -> Num
00:14:40 <tolkad> augur: here's an example
00:14:51 <tolkad> > (signum . (+)) 1 1
00:14:51 <lambdabot>   1
00:15:00 <tolkad> > (signum . (+)) 1.0 1.0
00:15:01 <lambdabot>   1.0
00:15:04 <augur> oh im guessing its cause you want to be able to use it in some places where generic nums are wanted
00:15:07 <augur> thats interesting
00:15:10 <augur> smart, infact!
00:17:12 <ddarius> > signum (1 :+ 1)
00:17:14 <lambdabot>   0.7071067811865475 :+ 0.7071067811865475
00:17:47 <ziman> > abs (1 :+ 1)
00:17:48 <lambdabot>   1.4142135623730951 :+ 0.0
00:18:30 <linda66> somebody that can help me with a programin c++ where i have to implement Template?
00:18:43 <tolkad> linda66: try #C++
00:19:39 <Axman6> @src signum
00:19:39 <lambdabot> Source not found. Are you on drugs?
00:20:15 <augur> lolololol
00:20:16 <ziman> i think signum should be a method in Num or so
00:21:50 <tolkad> ziman: it is a method in Num...
00:21:59 <tolkad> :t signum
00:22:00 <lambdabot> forall a. (Num a) => a -> a
00:23:30 <augur> i think it'd be more reasonable if the type was forall a : Num a . a -> a
00:24:28 <Saizan> augur: really? a's type mentioning a?
00:24:52 <augur> its not quite mentioning a
00:24:56 <augur> its a restricted quantifier!
00:25:12 <Saizan> use some other syntax then :P
00:25:19 <augur> :p
00:25:25 <ddarius> > 80*25
00:25:27 <lambdabot>   2000
00:25:33 <augur> forall a, Num a. a -> a
00:26:11 <Saizan> right now it's forall (a :: *). Num a => a -> a
00:28:14 <augur> im sure its not a difference either way. 
00:28:48 <augur> Num a => a -> a   is going to be uninhabited if a isnt a Num, right?
00:29:16 <EvanR> heh. Nothing means success and Just "error message" indicates a problem
00:29:33 <EvanR> opposite day
00:33:34 <tolkad> EvanR: considering the monad instance for Maybe that's a bad idea
00:34:21 <EvanR> whats better
00:34:29 <tolkad> Either String ()
00:34:30 <EvanR> Either String ()
00:34:41 <EvanR> seems like adding epicycles
00:34:51 <tolkad> or make your own data type
00:36:03 <tolkad> maybe a Monad for computations that may result in a string error message :P
00:36:23 <MichaelB3> can I assign functions inside ghci?
00:36:24 <EvanR> yes
00:36:28 <EvanR> yes
00:36:33 <tolkad> MichaelB3: @let
00:36:37 <MichaelB3> k
00:36:43 <EvanR> i just use let
00:36:47 <EvanR> and <-
00:36:53 <tolkad> oh wait
00:36:57 <tolkad> yeah sorry meant just let
00:37:10 <tolkad> MichaelB3: sorry, I got lambdabot and ghci confused for a second
00:37:28 <MichaelB3> no prob, Im coming from python so Im getting a lot confused
00:37:44 <EvanR> python refugee!
00:37:55 <MichaelB3> it seems so much faster so far
00:37:58 <MichaelB3> crazy fast
00:38:08 <EvanR> faster to write code?
00:38:17 <MichaelB3> I think both write and execute
00:38:37 <MichaelB3> seems to be faster to me, but I only know the basics of haskell so far.. very basics
00:39:06 <MichaelB3> I was just doing some "looping" in haskell and then did the same loop in python... huge difference
00:39:33 <EvanR> pythons base data structures are a lot different
00:39:44 <EvanR> haskells list is a regular linked list
00:39:51 <EvanR> python is something more sophisticated
00:39:53 <ddarius> MichaelB3: It would be surprising if sanely written Haskell were slower than Python, unless that Python just calls out to C.  Even then Haskell may well be faster.
00:40:07 <ddarius> EvanR: Python's "lists" are basically arrays.
00:40:20 <MichaelB3> Do you guys use it on Windows or 'nix ?
00:40:32 <EvanR> i use Linix
00:40:47 <MichaelB3> Im interested in the ease of creating exe's whereas on windows I have to use py2exe, which is a pretty crappy way to do it
00:40:48 <tolkad> why does this result in a type error on the last line? http://codepad.org/wgT6e7tr
00:40:58 <MichaelB3> on windows with python that is
00:41:15 <tolkad> the type should match, I'm applying the type synonym to the same type
00:41:30 <EvanR> ddarius: it is?
00:41:37 <tolkad> maybe I need one of those type synonym extensions?
00:41:46 <EvanR> i figured it was a tree or something to support all those crazy operations
00:41:50 <tolkad> oh wait, it's not a type synonym it's a type constructor
00:41:57 <tolkad> so why isn't it working...
00:42:23 <tolkad> it says "Couldn't match expected type `A' against inferred type `T A'"
00:42:31 <ddarius> EvanR: It's no trouble to implement them inefficiently, and what operations are you considering "crazy"?
00:43:43 <EvanR> how about inserting
00:43:48 <EvanR> removing
00:44:19 <tolkad> EvanR: haskell's lists are only supposed to be used in specific circumstances
00:44:47 <tolkad> EvanR: if you want to insert into an arbitrary position, use Data.Map or Data.IntMap
00:44:53 <EvanR> i was talking about haskell
00:44:56 <EvanR> what
00:45:03 <EvanR> i was talking about python
00:45:08 <tolkad> oh
00:45:26 <EvanR> i find haskells list appropriate a lot of the time
00:45:54 <tolkad> ok, when you said inserting/removing I thought you were thinking of lists as arrays, nevermind
00:46:04 <adorablepuppy> Hi. I want to send functions as arguments to a function. However, it appears that haskell thinks I'm trying to execute these functions.
00:46:17 <EvanR> inserting removing is painful with lists or arrays
00:46:21 <sipa> adorablepuppy: give your code
00:46:30 <adorablepuppy> No problem
00:47:35 <adorablepuppy> http://pastebin.com/VDy7it9t It's in the convert function, all the way at the bottom.
00:48:13 <adorablepuppy> This line in specific is causing problems.      ff fx fy (take fl b) ++ convert ff fx fy fl (drop fl b)
00:48:29 <sipa> it doesn't type match
00:48:59 <sipa> oh, excuse me
00:49:23 <EvanR> execute the application of the function ;)
00:49:24 <sipa> what is the function you're trying to pass?
00:49:32 <EvanR> apply the execution
00:50:04 <adorablepuppy> I'm trying to do the list comprehension ff with fx fy as arguments in the convert function.
00:50:28 <adorablepuppy> The third argument is (take fl b), which takes fl length chars from b string.
00:51:04 <tensorpudding> what are ff, fx and fy?
00:51:08 <adorablepuppy> The fx and fy are fst and snd, based on what I want back.
00:51:12 <sipa> your code means: pass (fx) and (fy) and (take fl b) to ff, and concatenate that with applying convert to (ff), (fx), (fy), (fl) and (drop fl b)
00:51:47 <tensorpudding> your b2h function uses fx fy == b, which definitely won't typecheck with fx = fst and fy= snd
00:52:26 <tensorpudding> @infix (++)
00:52:26 <lambdabot> Data.List, Prelude
00:52:29 <adorablepuppy> my b2h function used the fx and fy as fst and snd before I modified the convert function to use them
00:52:34 <tolkad> Why doesn't a type constructor applied to a type match agains the same constructor applied to the same type? there's an type error on the last line of this: http://codepad.org/wgT6e7tr "Couldn't match expected type `A' against inferred type `T A'"
00:52:45 <tolkad> at least, I think that's the problem
00:52:53 <tolkad> I'm really not sure, it doesn't make sense
00:53:37 <tolkad> oh, the type error is in the pattern...
00:54:04 <tolkad> why is there a type error in the pattern though? the function should be applicable to everything of type forall a. T a
00:54:12 <tensorpudding> stylistically speaking, it's not very haskelly
00:54:51 <adorablepuppy> Mine? I imagine it wouldn't be. I'm an imperative programmer just turned functional last week,
00:56:15 <tensorpudding> anyway, your b2h function doesn't work, and you might need some parentheses in the last line of convert
00:56:37 <ddarius> EvanR: Inserting into a Python "list" calls realloc if necessary, which copies if necessary.  http://svn.python.org/view/python/trunk/Objects/listobject.c?view=markup
00:56:44 <tolkad> oh wait, I think I see what's wrong
00:56:52 <tolkad> f needs to be in a class! ok, I understand
00:56:54 <tensorpudding> > map (^3) [1..10] ++ map (^2) [11..20]
00:56:55 <lambdabot>   [1,8,27,64,125,216,343,512,729,1000,121,144,169,196,225,256,289,324,361,400]
00:57:05 <kmc> tolkad, yes. the ghc manual mentions this
00:57:22 <kmc> the error really should be "cannot pattern match constructors from different family instances"
00:57:50 <kmc> tolkad, again, this looks more suited to a GADT
00:58:10 <tolkad> kmc: yeah I'm playing around with type level programming
00:58:18 <kmc> data T a where { TA :: A → T A; TT :: T A → T (T A) }
00:58:29 <kmc> you should be able to pattern-match that just fine
00:59:29 <jirka> Hi, do you know how fast can be done Huffman coding in Haskell?
00:59:33 <jirka> lets say for a 0.5M character book?
00:59:56 <EvanR> ddarius: so it just moves everything over by one ?
01:01:00 <ddarius> EvanR: Yes.  See the bottom of the ins1 function.
01:01:01 <tensorpudding> adorablepuppy: that code seems to typecheck and work fine
01:01:22 <jirka> I have managed to get to ~3 s for encoding and ~1 s for encoding. Do you think there is a space for more speedup?
01:01:53 <Axman6> jirka: very
01:02:14 <Axman6> i seem to remember my huffman coding stuff being a lot faster than that
01:02:18 <adorablepuppy> tensorpudding: I had something wrong in the b2h function, not sure what, but when I undid some changes it works.
01:02:35 <tensorpudding> it was probably the (fx fy == b) part
01:02:54 <tensorpudding> which makes the type inferrer give b2h a very strange type
01:03:27 * Axman6 -> away
01:03:35 <tensorpudding> it's helpful to provide type annotations, since that way you can't compile unless GHC guarantees that the types you think the functions should have are the types the functions can have
01:04:19 <adorablepuppy> tensorpudding: ah. Thanks for the help. I suppose maybe I should have actually finished a tutorial or two instead of going out on my own to experiement. I just don't get it until I try to do something on my own, you know?
01:07:07 <adorablepuppy> In any case, program works as it should, albeit missing some code that checks input, but working.
01:10:15 <tensorpudding> adorablepuppy: it's a good start, i think
01:13:30 <A1kmm> I'm using GHC.resume to programatically step through a program - in the program, (error "some message") is called, and I get a match to RunException e from GHC.resume
01:13:46 <A1kmm> Anyone know how I can display e without re-raising the exception in the interpreter program?
01:14:24 <A1kmm> (print / show is being treated the same as if (error "some message") had been evaluated in the interpreter program).
01:15:14 <adorablepuppy> I will provide my code if others want to use it or laugh at it. http://pastebin.com/GEZMp5LR I have added some helper functions to use my convert functions. Now you can go hex2Binary "fff01933b" and get back the correct stuff.
01:16:09 <tolkad> :t 2
01:16:10 <lambdabot> forall t. (Num t) => t
01:21:44 <A1kmm> adorablepuppy: The code is very clear - but won't that mean that to compute the list comprehension, every possible entry in 'x' needs to be examined?
01:22:17 <tolkad> wont TypeSynonymInstances + TypeFamilies + UndecideableInstances allow you to create some impossible instances?
01:23:43 <adorablepuppy> A1kmm: I think so. I but couldn't figure out how to do it a better way. If there is one, I'm all eyes.
01:24:45 <tolkad> hmm, I'll try it
01:25:31 <A1kmm> I think just using a map would be more efficient (but longer) - and perhaps producing Maybe Char instead of [Char] - of course that would make the code uglier.
01:25:47 <tolkad> oh, I guess not
01:26:21 <cch> trying installing Takusen on archlinux with cabal, succeeded without backed flags turned on, and failed with --flags="sqlite" turned on, the error said '''setup: pkg-config version >=0.9.0 is required but it could not be found.'''. any suggestion?  thanks
01:26:22 <cch>  
01:26:57 <cch> i did have  sqlite3
01:27:55 <A1kmm> adorablepuppy: I wonder how it would look using Parsec (without try) - that might be a nice way to do it.
01:28:22 <A1kmm> put I guess not if you want to go both ways without repeating yourself.
01:32:05 <adorablepuppy> A1kmm: Thanks for the suggestions. I'll look into it when I get a bit of experience in haskell under my belt. I was just looking for a fun exercise, so this seemed like a good idea.
01:34:46 <A1kmm> adorablepuppy: NP - if it is not a generic library, I think it could be premature optimisation to worry about things like that anyway.
01:37:55 * hackagebot authenticate 0.7.0 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.7.0 (MichaelSnoyman)
01:37:57 * hackagebot http-enumerator 0.2.0 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.2.0 (MichaelSnoyman)
01:37:59 * hackagebot wai-extra 0.2.4 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.2.4 (MichaelSnoyman)
01:38:01 <Nibble> I need some emacs configs.
01:38:01 * hackagebot yesod 0.5.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.5.2 (MichaelSnoyman)
01:38:55 * hackagebot yesod-auth 0.1.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.1.2 (MichaelSnoyman)
01:39:57 * hackagebot zlib-bindings 0.0.0 - Low-level bindings to the zlib package.  http://hackage.haskell.org/package/zlib-bindings-0.0.0 (MichaelSnoyman)
01:46:13 <koninkje_away> @hayoo [a] -> [(a,[a])]
01:46:13 <lambdabot> Unknown command, try @list
01:52:35 <A1kmm> adorablepuppy: I submitted my version at http://pastebin.com/F28a7PSw
01:55:51 <augur> happy 42 day!
01:57:22 <writer> augur: spikedmath :P
01:57:27 <augur> what
01:57:44 <writer> http://spikedmath.com/316.html
01:59:52 <augur> i got it from fortytwoday.com
01:59:52 <augur> :|
02:16:38 <chrisdone> I think google crashed hpaste haha
02:17:06 <Blkt> good day everyone
02:17:15 <ddarius> > (1540 `div` 80) * 80
02:17:16 <lambdabot>   1520
02:17:32 <ddarius> > showHex 1520 ""
02:17:33 <lambdabot>   "5f0"
02:18:56 <chrisdone> gotta change that 'run this paste' from a link to something javascript-based as search bots keep running everything
02:19:52 <Zao> chrisdone: Can't you mark it nofollow or something?
02:19:58 <Zao> chrisdone: Or sneak up a robots.txt?
02:20:05 <nlogax> too many stupid bots out there :)
02:20:14 <Zao> chrisdone: And banninate the usual misbehaving user agents?
02:20:30 <Zao> I think there's lists of suitable htaccess directives to get rid of the worst offenders.
02:20:55 * ddarius writes a crawler just to execute "run this paste" for all pastes continuously.
02:21:09 <Zao> "deny this service"
02:22:56 <chrisdone> ddarius: why would you do that, Darius? :-(
02:25:08 <ziman> or include a link href="do_not_execute_pastes_for_this_ip" before the execute link :)
02:26:17 <chrisdone> I disabled it for now, got other stuff to be doing. no one uses that feature anyway
02:47:39 <A1kmm> chrisdone: Now you just have to make a Haskell 98 compliant interpreter in Javascript...
02:48:31 <Twey> 98 is so last decade
02:48:40 <Twey> … or the decade before, even
02:48:44 <Twey> Yikes
02:48:59 <silver> A1kmm, http://lambda-the-ultimate.org/node/4100 !!
02:51:58 <A1kmm> Well that would be a good way to implement "Run this paste" then :P
02:52:22 <A1kmm> and if the bots want to run all the pastes, they can do it with their own CPU.
03:01:45 * aisamu thinks that the implementation of fibonacci with zipWith is just beautiful
03:04:38 <Botje> the scanl once isn't bad either :P
03:05:16 <anna__> how do i write a function that, given a list of filenames, transforms it in a list of their contents? I tried using mapM but i run out of memory, cause i don't know how to close files
03:06:17 <dubhrosa> anna___: use strict bytestring getContents
03:07:23 <anna__> dubhrosa: how do i do that?
03:09:06 <Twey> > fix $ scanl (+) 0 . (1 :)
03:09:07 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:09:30 <dubhrosa> anna__: hang on, I'll make a hpaste, I have some code that does this...
03:10:01 <anna__> dubhrosa: thanks :)
03:12:41 <Jonno_FTW> :t fix
03:12:42 <lambdabot> forall a. (a -> a) -> a
03:12:54 <Jonno_FTW> @src fix
03:12:54 <lambdabot> fix f = let x = f x in x
03:13:16 <Jonno_FTW> > fix 5
03:13:17 <lambdabot>   5
03:13:42 <Jonno_FTW> @check \n-> fix n == id n
03:13:43 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
03:16:04 <dubhrosa> anna__:http://hpaste.org/40470/filepathbytestring
03:17:17 <anna__> dubhrosa: thanks, but does this cose close the file?
03:19:11 <dubhrosa> yes, I had the exact same problem as you, the program this code is from needs to read content from 50,000 files, and originally it was running out of file handles, but changing it to use the ByteString.readFile fixed it, also you can mess around with calling open, hGetContents and hClose, but the result is the same and if you're reading a lot of content you should probably use ByteString anyway
03:21:08 <anna__> dubhrosa: thanks, i'm trying to fix my code. Problem is that i have to regex on every file, and have to change signature of all functions
03:24:47 <ddarius> Jonno_FTW: fix . const = id
03:25:01 <dima1> hi guys
03:25:11 <dima1> I need help
03:25:36 <dima1> I've read about Church encoding how to represent numbers in pure lambda
03:25:57 <dima1> but how can I represent 'if' expression ?
03:26:17 <ezyang> dima1: What is your boolean encoding, first? 
03:26:32 <dima1> church boolean encoding
03:26:40 <dima1> on wikipedia
03:26:41 <ezyang> Yeah, what is it? 
03:26:45 <ziman> that depends on how you represent true and false; i've seen true = const, false = flip const
03:26:47 <ezyang> state it here. 
03:27:02 <dima1>     true ≡ λa.λb. a     false ≡ λa.λb. b 
03:27:12 <ezyang> Ok. What are the types of these two functions? 
03:27:29 <ezyang> (they have to be the same) 
03:27:31 <dima1> hmmm
03:27:42 <dima1> a->b->a
03:27:56 <dima1> a->b->b
03:28:28 <ezyang> unify those two signatures. 
03:29:21 <dima1> Do I need a type constraint
03:29:48 <ezyang> It'll go away after unification. 
03:30:05 <ezyang> You can think of the unification as introducing constraints, namely a=a, b=b and a=b 
03:30:37 <ezyang> Then, consider a function if :: Bool -> a -> a -> a; give me the signature for this function using your type of the chuch encoding of bools. 
03:30:50 <ezyang> All should then become clear :-) 
03:31:20 <dima1> But isn't all this 'typing' area
03:31:26 <dima1> What's about untyped case
03:31:59 <aisamu> Botje: it's too early in the morning for me to understand that
03:32:36 <ezyang> dima1: So, you want if true then 2 else false to be handled by your function? 
03:32:58 <ezyang> It turns out that the typed and untyped versions are the same, but the types can help you figure out what this "if" function is. 
03:33:14 <Botje> aisamu: :)
03:34:17 <ezyang> (hint: it's pretty trivial) 
03:34:27 <dima1> right :)
03:34:42 <dima1> I am not a trivial thinker
03:35:15 <ezyang> So, the unified type is a -> a -> a 
03:35:29 <ezyang> Does that help? 
03:36:02 <ezyang> Here's another intuition: the Church encoding does away with any actual "data", and instead represents the computation you want to do with the data type. 
03:36:03 <dima1> ok. My first version was that language has to support pattern matching. And I would have 'if true a b = a' 'if false a b = b'
03:36:29 <dima1> But can it be done without pattern matching
03:36:32 <ezyang> So, in order to "pattern match" against a Church value, you simply /apply/ it with appropriate arguments. 
03:36:44 <ezyang> Yes. And that depends crucially on you understanding what the true and false functions are. 
03:37:32 <dima1> Before I got to Church encoding I assumed that false is the empty list, and true is anything else
03:37:34 <ezyang> Which is why I want you to consider the typed version. 
03:37:57 <dima1> And list I coudl represent with lambdas
03:38:29 <ezyang> empty list and false are puns, but at this stage I think you'll just confuse yourself that way. 
03:38:43 <ezyang> Just think of it as the same as machine code: there are different ways you can interpret the same byte sequence to get different meanings. 
03:40:44 <dubhrosa> I've been investigating the performance of some word frequency counting code I wrote, and I came across this stackoverflow thread http://stackoverflow.com/questions/3058529/curious-about-the-hashtable-problem where Dons shows simple benchmarks for HashTable and IntMap, but I can't reproduce the "after the fix" performance of the HashTable code, what version of GHC really has the fix?
03:41:07 <dima1> Is it some kind of a function that which is returned by boolean expression, than applied to 2 lambdas returns one of them
03:41:29 <ezyang> Yes... 
03:42:13 <dima1> Ok. Then let's assume I've got it. But another question, what's about equlity operator
03:42:16 <ezyang> (in fact, you're looking right at it.) 
03:42:44 <dima1> I have two functions, how can I consider them equivalent
03:42:50 <ezyang> Undecidable. 
03:43:00 <ezyang> But you can do it for some church encodings. 
03:43:01 <dima1> haskell doesn't support lambda comparison
03:44:03 <dima1> I can compare list by comparing its elements, but in the end it gets to functions
03:44:24 <ezyang> dima1: List equality comparison relies on being able to do equality comparison of its elements. 
03:44:38 <ezyang> Consider a really simple case: how do I do equality comparsion of true and false? 
03:45:18 <dima1> there is a complicated example on the wiki
03:45:34 <dima1>     zero? ≡ λn. n (λx.F) T 
03:45:39 <dima1> zero predicate
03:46:06 <Jafet> @check \x y -> map x y == fmap x y
03:46:06 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
03:46:07 <lambdabot>    arising from a use of `...
03:46:48 <ezyang> dima1: Don't worry about numbers for now. Simple cases first. 
03:47:28 <dima1> ok
03:47:34 <dima1> thinking...
03:48:15 <ezyang> (bool also has the benefit of not being recursive, which makes things easier) 
03:56:06 <PatrickRobotham> hi ezyang
03:56:29 <ezyang> hello 
03:58:59 <dima1> ok, it's 'and' predicate
03:59:10 <dima1> it returns true for both trues
03:59:17 <dima1> and false for otherwise
03:59:43 <dima1> no
03:59:46 <dima1> xor)
03:59:54 <dima1> I bet it's xor
04:00:16 <dima1> 'not xor'
04:01:41 <Jafet> == is logical xnor
04:02:10 <dima1> xnor or not xor)
04:02:54 <dima1> ezyang am I right?
04:03:02 <dima1> well I suppose yes
04:03:20 <ezyang> dima1: Sure, but you haven't actually told me what lambdas you're going to use... 
04:09:16 <ezyang> If this helps any, doing computation with church encoded types is a lot like continuation passing style. 
04:11:05 <norm2782> is it possible to see what template haskell generates?
04:12:15 <ezyang> -ddump-splices 
04:12:25 <ancechu> hi, just a simple question I know there is a solution but i can not recall it right now
04:12:34 <ancechu> if i have a function
04:12:44 <ancechu> f:: source -> target -> result
04:13:00 <ancechu> some times I want to partially define the function using the source
04:13:07 <ancechu> and other times using the target
04:13:18 <ancechu> how can I switch the order of the parameters?
04:13:24 <dschoepe> ancechu: flip f target
04:13:36 <ezyang> (`f` target) also works >:-) 
04:13:39 <norm2782> ezyang: cheers :)
04:13:42 <ancechu> thanks!!!
04:23:43 <chrisdb> Quick question. I'm trying to get to grips with Haskell by writing a sound change applier (historical linguistics) in it. Essentially it's an interpreter for a little language. The top-level execution function needs to be in the IO monad because many of the commands involve reading or writing from files. To execute the list of commands I'm currently using foldM, with the execution function...
04:23:44 <chrisdb> ...returning a new program state (essentially variable values and data to operate on) after running each line. However, I get the feeling that it would be more normal to wrap the IO monad with a State transformer and use mapM or similar instead. 
04:23:56 <chrisdb> Which is better / more idiomatic?
04:24:19 <ezyang> chrisdb: StateT on top of IO is pretty normal. 
04:24:37 <ezyang> but if everything is touching the state, you may not necessarily derive too much benefit. 
04:26:39 <chrisdb> Well... Every command needs to either read from or write to the program state. The only statements that exist in the little language are assignment, sound change rules (that modify the internal representation of all words), commands to read in word files (which modify the list of words), and commands to write out the current set of words.
04:28:11 <dima1> λm.λn.λa.λb. m (n a b) (n b a)
04:28:12 <ezyang> If some commands only read state and don't write it, you can benefit. 
04:28:17 <dima1> I used haskell to guess
04:28:20 <ezyang> Using StateT will avoid having to explicitly return it. 
04:28:45 <ezyang> dima1: Correct. 
04:28:49 <dima1> Where can I read about logical and functional reduction
04:29:11 <dima1> and just on all this stuff
04:29:43 <ezyang> Hmm, I'm not really sure. 
04:30:14 <chrisdb> OK, I guess that makes sense. The benefit in terms of loc probably isn't large, but I'll give it a try. I think it'll be the first time I've directly used a Monad transformer.. so far I've stuck to a single monad at a time (currently: List,Maybe,the Parsec one,State,IO).
04:30:56 <ezyang> So, there is one notable downside to starting to use StateT, which is that you'll need to liftIO any IO actions 
04:33:39 <chrisdb> It's a pity there isn't an easy way to everything more directly composable, without explicitly lifting functions up the stack of transformers. But I guess that if it was easy people would already have done it.
04:34:06 <ezyang> chrisdb: Well, there is a way: redefine all of the existing IO a functions to be MonadIO m => m a 
04:34:11 <ezyang> mumble hysterical raisins mumble 
04:35:07 * dschoepe really wishes that would happen
04:35:10 <chrisdb> One thing I've already noticed: Haskell needs more type classes. It's been particularly frustrating for me that the interface to map-like data structures isn't a type class...
04:35:35 <chrisdb> So you have to do I.lookup vs M.lookup (if I is IntMap and M is normal Map)
04:36:19 <chrisdb> And can't write general functions over, say, IntMaps, Maps, Association Lists...
04:36:56 <ezyang> My recommendation is if you discover you need to do this sort of varying of implementation, you should write up your own typeclass. 
04:37:14 <ezyang> because you will probably have strange specific requirements about what operations you expect your maps to support. 
04:37:56 <aristid> so instead of a general Map class, it would be a ChrisMap class
04:38:54 <ezyang> and I suspect that this is the right level of reusability and customizability 
04:39:10 <chrisdb> I guess I could do that. :) For now I've just made all my functions operate on the specific types I've settled on, but I was thinking more about in future. Avoiding premature optimisation is generally good, but if I change my mind later about the representation it will mean a lot of type signature changes.
04:39:11 * Twey thinks everything should be a typeclass, really.
04:39:38 <chrisdb> The reason it seems odd that there isn't a standard one is that, say, IntMap and Map pretty much do support exactly the same interface.
04:40:02 <ezyang> But IntMap can only be used with Ints. 
04:40:41 <chrisdb> Yes. :) Anyway... it doesn't matter. If it becomes a problem, I guess I'll roll my own class.
04:42:13 <Twey> Isn't there some way to automatically optimise e.g. Map Int … to IntMap?
04:42:22 <ezyang> Twey: Yes; data families. 
04:42:40 <aristid> chrisdb: if you find your classes are general enough for public consumption, you can roll them into a package and distribute on hackage
04:42:44 <ezyang> (erm, actually, probably type families) 
04:43:50 <Twey> Ah, right.
04:43:56 <Twey> Why don't we have more of those?  ☺
04:44:24 <Zao> Typeclasses and instances are annoying as they do not care about scope and modules at all.
04:44:31 <benmachine> data families!
04:44:42 <benmachine> although I don't know if that would work in the case of Map
04:44:48 <benmachine> because you'd have to have a "default" instance
04:44:54 <benmachine> which smells of overlapping to me :o
04:44:55 <Zao> Particularly annoying is that you can't avoid loading an instance if it's muddled together with things you _do_ want.
04:44:57 <ddarius> I believe Ashley Yakeley, in addition to not using layout, also writes all functions as methods in a class.
04:45:23 <chrisdb> Zao: it would be nice to be able to not import type class instances. But I guess it would make the type class system a lot more complex to use than the current system.
04:45:34 <benmachine> there is such a thing as excessive polymorphism, imo
04:45:35 <chrisdb> Doesn't Scala have something complicated that lets you do that?
04:45:35 <ezyang> explicit dictionaries! 
04:45:48 <ddarius> However, there really should be a standard Interfaces.{Set, Map, List, etc.} that is basically type classes and a bit of other stuff.
04:45:49 <aristid> Zao: yeah selective and local loading of typeclasses would be LOVELY
04:45:51 <benmachine> in fact it happens a lot in haskell
04:46:13 <benmachine> if you change a function from a -> Maybe b to (Monad m) => a -> m b, you are *losing information*
04:46:21 <ddarius> aristid: Until everything broke.
04:46:25 <benmachine> you are actually making the typechecker less powerful
04:46:42 <aristid> ddarius: don't be so pessimistic :P
04:46:49 <benmachine> I want to write about this in a wiki article or something but I haven't got around to it yet
04:47:09 <ddarius> Type classes are the way the are in large part to ensure consistency/confluence.
04:47:11 <benmachine> everyone seems to think more polymorphism = more better, but that's not always true
04:47:39 <chrisdb> I guess at some point there will need to be a reorganising of the Prelude and most common libraries to reflect changes in Haskell / design decisions that turned out not to be optimal? But it's hard now a lot of people are actually using it.
04:48:03 <aristid> ddarius: why should it not be possible to locally load a Monoid instance that works directly on Maybe, over the scope of a single function?
04:48:12 <benmachine> chrisdb: yeah, you have to hope that most of the changes can be done incrementally, really
04:48:24 <ddarius> aristid: I didn't say it wasn't possible.
04:48:34 <benmachine> aristid: you have some thorny questions there
04:48:35 <chrisdb> benmachine: the advantage of making something just specific enough is that it cuts down on rewriting essentially the same code multiple times. The great thing, IMO, about the idea of type classes is that it lets you specify exactly what your function needs to work and no more.
04:48:52 <aristid> ddarius: you said it was evil
04:48:53 <benmachine> aristid: like, you call a library function, does it use the in-scope instance or the local instance?
04:48:58 <chrisdb> The problem is when type classes and the real world don't neatly align.
04:49:12 <ddarius> aristid: I said everything would break.  That's neither evil nor impossible.
04:50:04 <chrisdb> I mean, type classes which are big lead to the temptation to only define some of the functions if only some are relevant, and have the rest throw an error. But that's evil, because it looks like a function will work with your type when maybe it won't.
04:50:07 <ddarius> As benmachine is getting to, the issues are things like you "locally" use some Ord instance to make a Set and I "locally" use some Ord instance to make a Set and then we try to union the sets together.
04:50:34 <aristid> ddarius: well, i'll just accept your laconic and unexplained statements as such then, because i don't really feel like drilling an explanation out of you
04:50:44 <ddarius> aristid: I just gave you one.
04:50:58 <aristid> yeah i read that after i wrote my statement :)
04:51:02 <ddarius> aristid: Perhaps you should stop putting words in my mouth.
04:51:08 <benmachine> aristid: if you're going to accept someone's position for the sake of getting them to leave you alone, it's a bad idea to tell them that you are doing that
04:51:58 <benmachine> in general
04:52:00 <benmachine> I have observed
04:52:03 <benmachine> this to be so
04:52:49 <aristid> ddarius: and it's impossible to avoid such problems by cleverly designing the mechanism?
04:53:35 <ddarius> aristid: No one has made an acceptable design.  I can't say whether it's possible or not.
04:54:02 <chrisdb> Ah, Scala names instances as well as the type classes. That's how it lets you pick which one to use.
04:55:18 <chrisdb> Since they're named, they can be explicitly imported (I think).
04:57:22 <chrisdb> I wonder if naming would also allow type class inheritance, ie start from this instance and only override the functions I explicitly declare. But I guess they don't do that in Scala, since they have OO style classes as well.
04:57:52 <ezyang> inheritance is a bad idea anyway... 
04:58:09 <ManateeLazyCat> niko: Hello?
04:59:00 <chrisdb> I think OO fits a certain class of problems quite well. Inheritance wouldn't work that well for Haskell though, because the layout of the data matters too much. You add one extra bit of data and you couldn't inherit anything without a lot of work arounds.
04:59:24 <chrisdb> But OO is probably overapplied right now, I guess. Complicated class hierarchies aren't always the answer.
04:59:38 <manateeUser> Nibbe: Emacs crash. :)
05:00:57 <ddarius> Data layout has little to nothing to do with inheritance, nor would adding some forms of "inheritance" be hard for Haskell.  In fact, O'Haskell did this.
05:02:34 <ezyang> I defer to Oleg's essay on the subject: http://okmij.org/ftp/Computation/Subtyping/ 
05:03:30 <chrisdb> ddarius: well, most functions on a type will access the data stored within it. In a typical OO language this doesn't matter, because A.B will still be accessible in derived class C even if property D is also added. I can see ways to do this in Haskell (most obviously using type classes to define data accessors), but it seems like it would be less straightforward.
05:03:40 <chrisdb> Maybe I'm wrong. I'll read the essay.
05:03:42 <ezyang> I agree that the fundamental difficulty is that inheritance conflates subtyping and subclassing. 
05:04:06 <ezyang> Sometimes you want one, sometimes you want the other, but OOP makes it really easy to say one thing and do another. 
05:04:11 <ezyang> *inheritance 
05:05:29 <ddarius> chrisdb: Your sentence sounds like "Inheritance works in OO languages because OO languages have inheritance."
05:08:18 <chrisdb> What I'm trying to say is that simulating OO-style inheritance in Haskell is messy, and that data layout does matter if you wanted to do that because Haskell makes you worry about it.
05:08:52 <chrisdb> It sounds like what you're saying is "A key feature of OO inheritance is the language hiding data layout from you". In which case I don't think we really have an argument.
05:10:06 <chrisdb> Anyway, I need to do my weekly shop before the supermarket closes. Thank you all for the discussion.
05:38:53 <annah> hey, can you spot the problem in the lines http://hpaste.org/40471/where_is_the_problem?pid=40471&lang_40471=Haskell#10
05:39:06 <annah> problem is that when I take away line number 12
05:39:38 <annah> the code output white strings
05:39:51 <dolio> Don't use getContents with withFile.
05:40:10 <annah> dolio: why?
05:40:23 <dolio> When using lazy I/O, you should never close the handle manually.
05:40:28 <dolio> But withFile does exactly that.
05:40:39 <dolio> @type readFile
05:40:39 <lambdabot> FilePath -> IO String
05:41:08 <annah> dolio: and how do i close the handle after readFile?
05:41:26 <dolio> It is closed automatically when you reach the end of the file, or the string is garbage collected.
05:41:48 <dolio> Roughly speaking.
05:42:14 <annah> ok.. thanks i'm trying to fix
05:42:17 <annah> thanks for the explanation
05:47:56 <annah> dolio: I modified it in http://hpaste.org/40472/new_version but I still have the same problem
05:47:58 <benmachine> annah: there are alternatives to lazy IO that allow you to better control when file handles are closed, but they are quite complicated; for simple uses, when you are only using a few files, readFile is probably the best option
05:48:29 <dolio> annah: You're now closing the handle manually. Don't do that.
05:48:55 <benmachine> annah: the problem is that hGetContents contains magic so that the file is only read when the contents are required
05:49:17 <benmachine> annah: but the contents might be required after the file is closed, in which case it can't be read - so then an error occurs
05:49:18 <annah> benmachine: problem is that i have to deal with about 3,000,000 files so that I run out of memory if I don't close handles
05:49:24 <dolio> The code in that second paste just has withFile inlined manually. :)
05:49:30 <benmachine> annah: you can't really use lazy IO then
05:49:42 <benmachine> annah: how big are these files, maximum?
05:49:53 <dolio> Yes, if you need millions of files, lazy I/O is probably not a good solution.
05:50:05 <annah> this files are about 20k
05:50:10 * dolio has to go.
05:50:26 <benmachine> annah: that might be small enough to fit it all in memory at once
05:50:28 <annah> so what is the non-lazy solution to that?
05:50:57 <benmachine> annah: annoyingly, there's no non-kazy version of hGetContents in the standard library, but you can write one yourself without too much difficulty
05:51:01 <annah> no.. I already tried with withFile and it crashes
05:51:02 <benmachine> *non-lazy
05:52:28 <ddarius> With no overhead, 20,000 * 3,000,000 = 60,000,000,000.  That's a bit more RAM then most computers have.
05:52:45 <benmachine> ddarius: I assumed they were being processed one after the other
05:52:55 <benmachine> annah: is that the case?
05:53:20 <benmachine> I suppose it must be because you don't have enough filehandles to process that many simultaneously
05:53:48 <annah> wait a minute, i'm doing a hpaste
05:53:59 <lispy> benmachine: hackage has non-lazy hGetContents
05:54:11 <benmachine> yeah
05:54:14 <benmachine> this is true
05:54:23 <benmachine> but I don't tend to bother because it's only like three lines anyways
05:54:28 <lispy> http://hackage.haskell.org/package/strict
06:04:58 <annah> wait a minute i accidentally solved my problem (or it seemes so)
06:05:25 <annah> will past more code in a while, i think :)
06:05:31 <annah> thanks for the help
06:05:32 <Jonno_FTW> topic
06:14:19 <Abadon> is haskell a good first language 
06:14:35 <Maxdamantus> Probably better than English.
06:14:38 * Abadon is not good at math but i hear haskell expects and functions as a language for mathematiticians
06:14:51 <Maxdamantus> What do you mean by not good at maths?
06:15:01 <Maxdamantus> Are you talking about arithmatic, or maths in general?
06:15:17 <Abadon> Maxdamantus: i'm talking about calculus, etc
06:15:29 <Jonno_FTW> haskell doesn't require that knowledgre
06:15:48 <Maxdamantus> Maths is a very broad subject that can be applied almost anywhere.
06:16:05 <Maxdamantus> and might have nothing to do with numbers.
06:16:29 <Maxdamantus> Lambda calculus for example.
06:16:42 <Abadon> ok great
06:16:48 <Abadon> so is it a good starting point?
06:17:17 <Abadon> or should i start with lisp or java
06:17:49 <Jonno_FTW> you should start with haskell
06:17:58 <Jonno_FTW> it's a good introduction to functional programming
06:18:12 <Abadon> ok
06:18:31 <Jonno_FTW> python would better if you want to learn procedural/object oriented programming
06:18:38 <Maxdamantus> Hm.  In HS the first language we used was one of those Lisp ones
06:18:40 <Maxdamantus> LOGO
06:18:48 <Jonno_FTW> Scheme?
06:18:54 <Maxdamantus> No, LOGO
06:19:04 <Jonno_FTW> how similar is it to lisp?
06:19:07 <Jonno_FTW> *common lisp
06:19:16 <Maxdamantus> Dunno, never used clisp
06:19:23 <Jonno_FTW> >__>
06:19:25 <Jafet> Whatever you do, do not learn autocad lisp.
06:19:44 <Abadon> Maxdamantus: clisp is an implementation not a language
06:19:52 <Abadon> like ghc :p
06:19:52 <Maxdamantus> Ah, well common lisp then.
06:20:03 <Maxdamantus> I thought clisp was just short for common lisp
06:20:08 <Abadon> that's "cl"
06:20:29 * Maxdamantus knows very little about any lisps.
06:20:30 <Jafet> @quote undoubtedly
06:20:30 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
06:20:49 <Jonno_FTW> damn straight
06:20:57 <Jonno_FTW> > scanl (+) 1
06:20:58 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
06:20:58 <lambdabot>    arising from a use ...
06:21:06 <Jonno_FTW> > scanl1 (+) 1 [1..]
06:21:07 <lambdabot>   Couldn't match expected type `[t1] -> t'
06:21:07 <lambdabot>         against inferred type `[a]'
06:21:10 <Abadon> :/ ok 
06:21:11 <Abadon> thx
06:21:49 <Jafet> @quote fibs
06:21:49 <lambdabot> No quotes match. I feel much better now.
06:22:06 <hpc> :t scanl1
06:22:07 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
06:22:18 <hpc> > scanl1 (+) [1..]
06:22:18 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
06:22:28 <Maxdamantus> @src scanl1
06:22:28 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
06:22:28 <lambdabot> scanl1 _ []     =  []
06:22:37 * Maxdamantus adds to his language's library
06:22:54 <hpc> :t scanl2
06:22:54 <lambdabot> Not in scope: `scanl2'
06:23:04 <Jafet> > let fibs = 0: scanl (+) 1 (tail fibs) in fibs
06:23:05 <lambdabot>   [0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
06:23:07 <Jonno_FTW> that's not the fibonacci sequence..
06:23:18 <Jonno_FTW> perhaps iterate
06:23:22 <hpc> it is powers of 2
06:23:30 <Jonno_FTW> > iterate (+) 1
06:23:31 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
06:23:39 <Jafet> > let fibs = 0: 1: zipWith (+) fibs (tail fibs) in fibs
06:23:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:23:57 <Maxdamantus> > fix $ (1:) . (1:) . ap (zipWith (+)) tail
06:23:58 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
06:24:10 <Jonno_FTW> > iterate (+)
06:24:11 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
06:24:27 <Maxdamantus> Maybe add an ap in there somewhere.
06:24:39 <hpc> :t iterate
06:24:40 <lambdabot> forall a. (a -> a) -> a -> [a]
06:24:54 <hpc> iterate (+1) 1
06:24:56 <hpc> > iterate (+1) 1
06:24:57 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:25:32 <Maxdamantus> @src scanl
06:25:32 <lambdabot> scanl f q ls = q : case ls of
06:25:33 <lambdabot>     []   -> []
06:25:33 <lambdabot>     x:xs -> scanl f (f q x) xs
06:27:01 <Jonno_FTW> @src until
06:27:01 <lambdabot> until p f x | p x       = x
06:27:01 <lambdabot>             | otherwise = until p f (f x)
06:30:44 <Kaidelong> any recommendations for a neural network library or am I going to have to try them out and see which ones are best?
06:31:00 <Maxdamantus> > scanl1 (*) [1..]
06:31:01 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
06:32:07 <Jonno_FTW> > let fac = foldl' (*) . enumFromTo 1 in map fac [1..20]
06:32:09 <lambdabot>   No instance for (GHC.Num.Num [a])
06:32:09 <lambdabot>    arising from a use of `e_11120' at <in...
06:32:16 <Jonno_FTW> > let fac = foldl1' (*) . enumFromTo 1 in map fac [1..20]
06:32:17 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
06:32:37 <Jonno_FTW> I would assume scanl1 is more efficient here?
06:33:28 <Maxdamantus> I think so, for lack of memoisation or something
06:33:34 <Maxdamantus> Dunno
06:33:57 <Jonno_FTW> @src scanl1
06:33:57 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
06:33:57 <lambdabot> scanl1 _ []     =  []
06:34:20 <Jafet> > [..1]
06:34:21 <lambdabot>   <no location info>: parse error on input `..'
06:34:39 <hpc> > [minBound .. 1]
06:34:40 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:34:40 <lambdabot>    `GHC.Enum.Enum a'
06:34:40 <lambdabot>      a...
06:34:50 <Maxdamantus> @src scanl
06:34:50 <lambdabot> scanl f q ls = q : case ls of
06:34:51 <lambdabot>     []   -> []
06:34:51 <lambdabot>     x:xs -> scanl f (f q x) xs
06:35:05 <vitka> > [(minBound :: Int)..1]
06:35:07 <lambdabot>   [-9223372036854775808,-9223372036854775807,-9223372036854775806,-9223372036...
06:35:24 <vitka> > [(minBound :: Int32)..1]
06:35:26 <lambdabot>   [-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-2147483643,-2...
06:35:30 <aristid> > [minBound .. 1] :: [Word]
06:35:31 <lambdabot>   [0,1]
06:35:33 <Kaidelong> > ((delay 1 . scanl1' (*) [1..]) !!) 0
06:35:33 <lambdabot>   Not in scope: `scanl1''
06:35:40 <Kaidelong> > ((delay 1 . scanl1 (*) [1..]) !!) 0
06:35:40 <lambdabot>   No instance for (Control.Arrow.Operations.ArrowCircuit (->))
06:35:41 <lambdabot>    arising fro...
06:35:45 <aristid> :t delay
06:35:46 <lambdabot> forall b (a :: * -> * -> *). (ArrowCircuit a) => b -> a b b
06:35:54 <Kaidelong> not what I wanted
06:36:23 <aristid> Kaidelong: (->) is not in ArrowCircuit, i don't see how it could be
06:36:35 <Kaidelong> not what I wanted
06:36:49 <Maxdamantus> > fix $ (1:) . (1:) . scanl1 (+)
06:36:51 <lambdabot>   [1,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:37:02 * Maxdamantus feels awesome for figuring that out
06:37:34 <Maxdamantus> Eh, too many 1s
06:37:38 <Maxdamantus> > fix $ (1:) . scanl1 (+)
06:37:39 <lambdabot>   [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
06:37:44 <Kaidelong> what I was wanting duplicates the head of a stream for a while
06:37:46 <Maxdamantus> Hm :\
06:37:48 <hpc> haha
06:38:09 <Kaidelong> like the opposite of drop
06:38:53 <Kaidelong> doesn't look like there is something like it though
06:38:59 <hpc> dupHead n (x:xs) = x:(dupHead (n-1) (x:xs))
06:39:17 <hpc> dupHead 0 xs = xs
06:39:18 <Kaidelong> sure it's easy enough to implement
06:39:51 <Jafet> @pl \n (x:xs) -> replicate n x ++ xs
06:39:51 <lambdabot> (`ap` tail) . (. head) . ((++) .) . replicate
06:41:50 <aristid> @unpl x . (. y)
06:41:51 <lambdabot> (\ d -> x (\ g -> d (y g)))
06:45:53 <aristid> which XML library would you recommend?
06:54:13 <silver> aristid, http://en.wikibooks.org/wiki/Haskell/XML
06:56:25 <gilgamesh> hey guys... i need some small help.... i am trying to write an implementation of sum that will take a lista of chars, and return me the sum of them
06:56:41 <gilgamesh> all those chars will be from '0'..'9' so it is guaranteed i can convert
06:56:54 <gilgamesh> i tried something like this: somar (x:xs) = read x + read ((somar xs))
06:57:05 <gilgamesh> but it is still quiet not that
06:57:14 <gilgamesh> any ideas to help me figure this out?
06:57:38 <aristid> silver: i.e. HXT? looks like it is also the most popular (from a quick glance at 2-3 packages).
06:59:10 <gilgamesh> what i mean is, i have a string "12345" and i want to sum all the numbers, 1+2+3+4+5
06:59:13 <Twey> gilgamesh: sum . map digitToInt
06:59:31 <Twey> > sum . map digitToInt $ "12345"
06:59:32 <lambdabot>   15
06:59:54 <gilgamesh> oh digitToInt
06:59:57 <Twey> digitToInt is in Data.Char
07:00:04 <Twey> IIRC
07:00:07 <Twey> @index digitToInt
07:00:08 <lambdabot> Data.Char
07:00:09 <Twey> Yes
07:00:21 <aristid> :t digitToInt
07:00:22 <lambdabot> Char -> Int
07:00:40 <gilgamesh> great
07:00:42 <gilgamesh> :D
07:00:44 <gilgamesh> tks guys
07:04:34 <Twey> gilgamesh: You're welcome
07:05:41 * ddarius wonders for what purpose such a function would be needed.
07:06:34 <gilgamesh> ddarius: solving some project euler problems... i needed a function to sum all digits from 100!
07:06:52 <gilgamesh> ddarius: so i calclated 100! and converted into a string, so i'd have it in a list which is easier to sum
07:06:57 <gilgamesh> :)
07:07:44 <ddarius> Clearly 100 is too small an input.
07:08:31 <gilgamesh> ddarius: 100! (factorial of 100)
07:09:10 <ddarius> Yes, and 100 is the input.
07:09:42 <gilgamesh> for the factorial function yes... the result of that is the input for the sum function
07:10:11 <ddarius> > sum . map digitToInt . show $ product [2..100]
07:10:12 <lambdabot>   648
07:10:31 <Jonno_FTW> is there anyway to specify which directory ghci starts in?
07:10:50 <ddarius> Lambdabot just instantly did that problem.  A larger input would have made it interesting.
07:11:16 <gilgamesh> oh :| my solution wasn't so simple
07:11:37 <gilgamesh> i am still not sure about those dots '.' in the statement
07:11:46 <gilgamesh> i used some () instead
07:11:49 <ddarius> gilgamesh: My point isn't that it is simple, my point is that a naive brute-force solution is quite feasible.
07:11:53 <gilgamesh> looks like they have the same effect?
07:11:54 <ddarius> Which is boring.
07:12:11 <afilatun> hi, I'm trying to make a function output all possible substring of a string
07:12:22 <afilatun> I know it's basic stuff but I can't get to it (I'm a newbie)
07:12:25 <Jonno_FTW> afilatun: do you mean permutations?
07:12:25 <gilgamesh> ddarius: i get your point
07:12:32 <Jonno_FTW> > permutations [1..3]
07:12:33 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
07:12:37 <Jonno_FTW> like that?
07:13:00 <donri> > permutations "hello"
07:13:01 <lambdabot>   ["hello","ehllo","lehlo","elhlo","lhelo","hlelo","lleho","lleho","lelho","l...
07:13:16 <afilatun> Jonna_FTW : no I mean "bob" = ["b", "o", "b", "bo", "ob", "bob"]
07:13:21 <ddarius> > subsequence "bob"
07:13:22 <lambdabot>   Not in scope: `subsequence'
07:13:27 <ddarius> > subsequences "bob"
07:13:28 <lambdabot>   ["","b","o","bo","b","bb","ob","bob"]
07:13:35 <afilatun> wow
07:13:40 <gilgamesh> that is cheating
07:13:44 <Raevel> :-)
07:13:47 <Jonno_FTW> afilatun: have you looked at Data.List?
07:14:11 <afilatun> yes and I didn't saw that, maybe I skipped it too fast
07:14:23 <aristid> > subsequences "abcd"
07:14:24 <lambdabot>   ["","a","b","ab","c","ac","bc","abc","d","ad","bd","abd","cd","acd","bcd","...
07:14:33 <aristid> > subsequences "abc"
07:14:33 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
07:14:44 <afilatun> and what is your prefered haskell reference? I like to see the source code of those function to learn
07:15:08 * aisamu waits for the answers
07:15:09 <Jonno_FTW> afilatun: on hackage, the source is available 
07:15:15 <Jonno_FTW> with a link at the right of each function
07:15:25 <Jonno_FTW> @hackage List
07:15:26 <lambdabot> http://hackage.haskell.org/package/List
07:15:28 <Jonno_FTW> +CLnt)] [Act: 3,7]
07:15:29 <Jonno_FTW> [#haskell]
07:15:31 <donri> @hoogle subsequences
07:15:31 <lambdabot> Data.List subsequences :: [a] -> [[a]]
07:16:13 <donri> @hackage base
07:16:13 <lambdabot> http://hackage.haskell.org/package/base
07:16:15 <donri> more like?
07:16:18 <Jonno_FTW> afilatun: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-List.html#v%3Asubsequences
07:16:31 <afilatun> thanks :)
07:16:56 <donri> Or http://hackage.haskell.org/packages/archive/base/4.2.0.2/doc/html/Data-List.html#v%3Asubsequences because prettier theme :X
07:17:59 <aristid> donri: and slightly more current package
07:19:07 <ddarius> > showHex (80*24) ""
07:19:08 <lambdabot>   "780"
07:20:14 <aristid> @hoogle showHex
07:20:14 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
07:20:23 <ddarius> > showHex (80) ""
07:20:24 <lambdabot>   "50"
07:20:27 <Jonno_FTW> > x32
07:20:28 <lambdabot>   Not in scope: `x32'
07:20:31 <Jonno_FTW> > 0x32
07:20:32 <lambdabot>   50
07:20:32 <aristid> @index showHex
07:20:33 <lambdabot> Numeric
07:20:37 <Jonno_FTW> > 0x80
07:20:38 <lambdabot>   128
07:20:45 <aristid> oO Numeric is an old-style module name?!
07:20:46 <Jonno_FTW> > 0xFF
07:20:47 <lambdabot>   255
07:21:39 <Twey> aristid: New and old
07:21:43 <benmachine> aristid: it apparently never got moved
07:21:57 <aristid> weird
07:22:00 <Twey> It's in the flat-module Prelude, but yeah, we've never found anywhere else to put it
07:22:21 <Twey> It doesn't define a data-type, or a control structure
07:22:32 <Twey> It's not a system library
07:23:57 * hackagebot snap-core 0.2.13 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.13 (GregoryCollins)
07:28:59 * hackagebot snap-server 0.2.13 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.13 (GregoryCollins)
07:36:00 <donri> > foldl1 (+) $ take 64 $ iterate (*2) 1
07:36:01 <lambdabot>   18446744073709551615
07:36:07 <donri> Yay I totally made that up all by myself
07:36:32 <ddarius> > 2^64 - 1
07:36:33 <lambdabot>   18446744073709551615
07:36:49 <donri> FINE BE THAT WAY
07:37:17 <ddarius> > complement 0 :: Int
07:37:19 <lambdabot>   -1
07:37:23 <ddarius> > complement 0 :: Word
07:37:24 <lambdabot>   18446744073709551615
07:38:07 <donri> @hoogle complement
07:38:07 <lambdabot> Data.Bits complement :: Bits a => a -> a
07:38:07 <lambdabot> Data.Bits complementBit :: Bits a => a -> Int -> a
07:38:37 <aristid> > complement (-1 :: Int)
07:38:38 <lambdabot>   0
07:40:09 <pr> @index fix
07:40:09 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
07:41:23 * ddarius decides to be lazy.
07:41:49 * benmachine decides to be non-strict
07:44:31 <ddarius> > ord '\n'
07:44:32 <lambdabot>   10
07:44:53 <Jonno_FTW> > chr 0xa
07:44:54 <lambdabot>   '\n'
07:45:02 * ddarius needs to add character syntax to his language implementation.
07:45:46 * ddarius could write "\n" B@ but that would be atrocious.
07:47:32 <danharaj> whal language are you implementing?
07:48:46 <orlandu63> is dynamic linking supported in 6.10?
07:48:55 <orlandu63> of ghc
07:49:03 <ddarius> My own language that's a mixture of Joy and Forth with bits of postscriptiness.
07:50:35 <danharaj> Is there any particular goal in your project? Something to understand? Some... *puts on sunglasses* joy to be had?
07:50:58 <EvanR> i code with sunglasses at night
07:51:36 <danharaj> considering how much contrast there is in a computer screen in a dark room, I would too if I didn't use lights.
07:52:21 <monochrom> x
07:53:18 <ddarius> danharaj: I'm writing something that might be called a kernel, though that isn't really the intent, and I needed (wanted) a language to develop it in besides assembly.  So I wanted a language that was easy to implement, reasonably performing, and not too unpleasant while only requiring a simple RTS.
07:53:51 <bremner> C?
07:53:53 <danharaj> If you take the first two properties, you get C. If you add the last, you get something completely different :p
07:54:12 <Twey> C's not so easy to implement, either.
07:54:17 <Twey> Relatively speaking.
07:54:20 <ddarius> Indeed.
07:54:37 <ddarius> Also, I find my language more pleasant than C in many ways.
07:55:06 <ddarius> For example, I just defined when.  : when [] branch ;
07:55:35 <aristid> ddarius: does it have a website?
07:56:09 <danharaj> How do I tell google scholar the difference between F,G Dialgebras and the other dialgebras people talk about :|
07:56:24 <ddarius> aristid: I wrote it a few days ago and the implementation is a couple thousand lines of assembly with a few minor tie-ins to my system.
07:56:59 <ddarius> aristid: Also, there isn't too much reason to use it as opposed to Joy in a desktop environment.
07:57:00 <aristid> ddarius: your system? is that a special system?
07:58:30 <ddarius> aristid: Read what I last wrote to danharaj.
07:59:19 <Jonno_FTW> how would I efficiently find the numbers (a,b,c) such that a<b, a+b=c and c<1000? I have [(a,b,c)|b<-[1..1000],a<-[1..b],c<-[a+b],c<1000]
07:59:36 <aristid> ddarius: well, is it a system on a normal x86 computer? or an embedded system?
07:59:38 <Raevel> project euler? :-)
07:59:44 <Jonno_FTW> yes
08:00:01 <afilatun> hi, I'm trying to get the longest string a in a list of strings
08:00:18 <ddarius> aristid: It runs on a desktop computer.
08:00:26 <ddarius> aristid: There is no real purpose to it.
08:00:37 <afilatun> I would use find but I can't seem to make it work for this case
08:00:47 <dolio> It's in the cloud.
08:01:17 <Raevel> afilatun: you could use a fold and keep the longer string each time
08:01:25 <Jonno_FTW> afilatun: snd $ maxmimum $ map (\x->(length x,x)) [strings] 
08:01:33 <afilatun> thanks :)
08:01:35 <aristid> afilatun: use maximumBy
08:01:42 <aristid> well or that
08:01:42 <Jonno_FTW> or that ^
08:01:47 <Jonno_FTW> :S
08:02:05 <aristid> :t maximumBy (compare `on` length)
08:02:07 <lambdabot> forall a. [[a]] -> [a]
08:02:32 <_linuxftw> what does compare `on` length do?
08:02:37 <Jonno_FTW> @src maximumBy
08:02:38 <lambdabot> Source not found. My brain just exploded
08:02:54 <aristid> :t on
08:02:55 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:02:56 <aristid> @src on
08:02:56 <lambdabot> (*) `on` f = \x y -> f x * f y
08:02:57 <hpc> @src maximum
08:02:57 <lambdabot> maximum [] = undefined
08:02:57 <lambdabot> maximum xs = foldl1 max xs
08:03:07 <aristid> _linuxftw: there you see what on does.
08:03:42 <hpc> :t maximumBy
08:03:43 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
08:03:45 <_linuxftw> ok I see, thanks
08:03:49 <Jonno_FTW> does no one have help for my problem?
08:03:57 <_linuxftw> where is `on` defined?
08:04:04 <Jonno_FTW> @hoogle on
08:04:04 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:04:05 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
08:04:05 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
08:04:51 <aristid> Jonno_FTW: isn't your solution efficient enough?
08:04:56 <Jonno_FTW> no
08:05:01 <Jonno_FTW> of course not
08:06:20 <Jonno_FTW> > [(a,b,c)|b<-[1..1000],a<-[1..b],c<-[a+b],c<1000]
08:06:22 <lambdabot>   [(1,1,2),(1,2,3),(2,2,4),(1,3,4),(2,3,5),(3,3,6),(1,4,5),(2,4,6),(3,4,7),(4...
08:06:53 <Jonno_FTW> > [(a,b,c)|b<-[1..1000],a<-[2..b],c<-[a+b],c<1000]
08:06:54 <lambdabot>   [(2,2,4),(2,3,5),(3,3,6),(2,4,6),(3,4,7),(4,4,8),(2,5,7),(3,5,8),(4,5,9),(5...
08:07:08 <Jonno_FTW> > [(a,b,c)|b<-[1..1000],a<-[1..b],c<-[a+b],c<1000,a<b]
08:07:10 <lambdabot>   [(1,2,3),(1,3,4),(2,3,5),(1,4,5),(2,4,6),(3,4,7),(1,5,6),(2,5,7),(3,5,8),(4...
08:08:58 <donri> Not really wrong, but inconsistent; shouldn't = be == here? http://hackage.haskell.org/packages/archive/base/4.2.0.2/doc/html/Data-List.html#v%3Agroup
08:09:24 <danharaj> yes.
08:10:01 <Heffalump> It would be better to use '=' everywhere, IMO. '==' implies the existence of an Eq constraint which isn't always true
08:10:14 <Heffalump> ironically, that definition there is one, but the next two which use '==' don't have one :-)
08:11:53 <donri> > [1,2,3] == [1,2,3]
08:11:54 <lambdabot>   True
08:11:55 <donri> What do you mean?
08:12:42 <donri> And then some use ->
08:13:56 <hpc> they could also do "> foo\n  valueOfFoo"
08:14:07 <hpc> like what you would see in an interpreter
08:14:12 * hackagebot attoparsec 0.8.1.1 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.1.1 (BryanOSullivan)
08:15:05 <Twey> donri: You can apply ‘inits’ and ‘tails’ to lists of things that don't implement Eq
08:15:10 <Twey> > () == ()
08:15:11 <lambdabot>   True
08:15:15 <Twey> Err
08:15:20 <Twey> > id
08:15:21 <donri> ;)
08:15:21 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:15:22 <lambdabot>    arising from a use of `...
08:15:23 <Twey> > id == id
08:15:24 <lambdabot>   *Exception: (==): No overloading for function
08:15:51 <Twey> :t inits [id, id, id]
08:15:53 <lambdabot> forall a. [[a -> a]]
08:15:57 <Twey> inits [id, id, id]
08:15:59 <Twey> > inits [id, id, id]
08:16:00 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:16:00 <lambdabot>    arising from a use of `...
08:16:09 <donri> I agree = makes most sense, but in any case it should be consistent
08:16:12 * hackagebot statistics 0.8.0.2 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.8.0.2 (BryanOSullivan)
08:16:22 <Twey> > inits [id, id, id] == [[], [id], [id, id], [id, id, id]]
08:16:23 <lambdabot>   *Exception: (==): No overloading for function
08:16:38 <Twey> Yep
08:16:43 <Twey> I suspect it's a typo
08:16:53 <Twey> Since == is used pretty consistently elsewhere
08:17:10 <Twey> Hm, wait — there's a -> later on.  Haha.
08:17:14 <donri> Yea.
08:17:25 <Twey> Silly docs.  Oh well — doesn't matter that much.
08:17:32 <donri> Guys, I thought you'll had OCD. What's wrong with you!
08:17:47 <hpc> we are also programmers
08:17:50 <hpc> we are used to docs sucking
08:17:54 <hpc> :P
08:17:56 <donri> Point.
08:18:04 <Twey> And when there's no perfect solution, anything'll do :þ
08:18:13 * hackagebot mwc-random 0.8.0.2 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.8.0.2 (BryanOSullivan)
08:18:15 <donri> Twey: That's not the OCD mantra. :(
08:18:28 <hpc> case in point: the popularity of Double as a floating type >:3
08:18:36 <donri> When there's no perfect solution, perform meaningless rituals compulsively for twelve hours.
08:18:50 <EvanR> yes
08:18:54 <hpc> that too
08:18:58 <EvanR> everyday
08:19:48 <Twey> Like pressing buttons to make lights glow in patterns?
08:20:05 <hpc> i have a screensaver to do that for me
08:20:13 * hackagebot base64-bytestring 0.1.0.1 - Fast base64 encoding and deconding for ByteStrings  http://hackage.haskell.org/package/base64-bytestring-0.1.0.1 (BryanOSullivan)
08:20:47 <hpc> i feel like i should put something on hackage
08:20:58 <hpc> something that is desperately missing
08:21:18 <danharaj> In Hagino's thesis, he says that the Natural numbers are the initial F,G dialgebra where F A= <1, A> and G = <A, A>. Shouldn't G A = A?
08:24:09 <dolio> G = <A, A> doesn't even look like a functor.
08:24:44 <danharaj> G A = <A, A> (my bad)
08:24:56 <dolio> Ah.
08:25:17 <dolio> G : C -> C x C?
08:25:21 <danharaj> yes.
08:25:49 <danharaj> Ah I see. G has to be that for the type of the dialgebra morphism to make sense.
08:25:52 <dolio> Well, in that case, the algebra action is an arrow in C x C.
08:26:08 <dolio> The left side is 1 -> A, and the other is A -> A.
08:26:16 * hackagebot criterion 0.5.0.5 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.5.0.5 (BryanOSullivan)
08:26:40 <dolio> Which should be isomorphic to some f : 1 + A -> A in C.
08:26:50 <danharaj> I feel like it should be 1 -> A x A and A -> A x A though if that is the case. I don't know why it doesn't click.
08:28:21 <dolio> Does he have some reason for using the dialgebra approach?
08:28:48 <danharaj> I think that you can handle both algebras and coalgebras with the same construct.
08:29:04 <dolio> Ah.
08:29:10 <EvanR> is there postfix operators... 128 megs
08:29:14 <danharaj> wait, what are the morphisms of A x B where A and B are categories?
08:29:33 <xplat> a morphism of A and one of B, paired
08:29:36 <dolio> It does nicely break up the algebras into separate constructors and destructors, too, I guess.
08:29:38 <danharaj> ok yeah I'm dumb.
08:29:46 <danharaj> I get it now.
08:30:01 <dolio> Which is how they'd be in a type theoretic presentation.
08:30:45 <xplat> this thesis sounds interesting.  have a link?
08:31:14 <danharaj> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.164.1837&rep=rep1&type=pdf
08:31:27 <xplat> thanks
08:31:50 <dolio> Oh, man. I already have this.
08:31:56 <dolio> I should read more.
08:34:00 <danharaj> I want to write an interpreter for the language he defines.
08:34:16 <danharaj> or rather the lambda calculus based off of it that he introduces in another paper
08:34:39 <danharaj> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.164.5509&rep=rep1&type=pdf
08:35:34 <opqdonut> cabal install quickcheck is giving me "cabal: cannot configure QuickCheck-2.3.0.2. It requires ghc -any"
08:35:37 <opqdonut> any ideas?
08:35:38 <xplat> wow, he was already doing this in '87?
08:35:52 <dcoutts> opqdonut: your ghc package is borked
08:36:08 <res> dammit, does regex-pcre not do submatches or something?
08:36:12 <opqdonut> dcoutts: i'm using debian's ghc package
08:36:44 <dolio> No dependent types?
08:36:51 <dcoutts> opqdonut: I mean the ghc package called 'ghc'. That is, the ghc API library.
08:37:00 <opqdonut> ah
08:37:09 <dcoutts> opqdonut: you've probably overwritten one of the things it depends on. See ghc-pkg check.
08:37:37 <opqdonut> ah sweet, I was looking for something like "ghc-pkg check"
08:37:49 <opqdonut> since the verbose output sounded pretty bad
08:37:52 <dcoutts> opqdonut: if you're lucky you only did it in your per-user package db. Check if you've got any core lib in your user db that masks one from the global.
08:38:17 <ddarius> > 0xF0
08:38:17 <opqdonut> i've been using install --global...
08:38:18 <lambdabot>   240
08:38:30 <ddarius> > 240 * 4
08:38:31 <lambdabot>   960
08:38:40 <res> opqdonut: ...don't do that
08:39:02 <res> it makes it significantly easier to screw things up
08:39:24 <opqdonut> ok
08:39:40 <opqdonut> what's the easiest way to just nuke the package repositories and start over?
08:43:07 <res> what's the easiest way to get a submatch using Text.Regex.PCRE?
08:53:23 * hackagebot pcap 0.4.5.1 - A system-independent interface for user-level packet capture  http://hackage.haskell.org/package/pcap-0.4.5.1 (BryanOSullivan)
09:01:29 <Kaidelong> does it make sense to talk about monads or comonads when you have some kind of infinitely nested structure like a stream of streams of streams of streams...
09:01:57 <Kaidelong> looks like you'd end up just defining a bunch of things as identity
09:15:31 * hackagebot bloomfilter 1.2.6.6 - Pure and impure Bloom Filter implementations.  http://hackage.haskell.org/package/bloomfilter-1.2.6.6 (BryanOSullivan)
09:15:34 <xplat> in Hask it doesn't make much sense to do that, in small enough categories it could ...
09:16:17 <xplat> what would you do with a Fix Stream anyway?
09:16:43 <xplat> it only has one value
09:17:41 <xplat> a Fix [] i could see ...
09:20:23 <xplat> that's isomorphic to Data BlankTree = BlankFork BlankTree BlankTree | BlankLeaf
09:20:25 <Kaidelong> xplat: I was thinking about what you could get out of requiring all values to be streams and all streams to be infinite
09:20:49 <Kaidelong> and basically running the program by advancing its state
09:20:57 <Kaidelong> by "rotating" the components
09:21:04 <Kaidelong> like some kind of gear assembly
09:21:10 <xplat> if you require *all* values to be infinite streams then like i said you only have one value
09:21:23 <Kaidelong> well the values have state
09:21:43 <Kaidelong> the state can be advanced indefinitely and can drive some kind of control flow
09:22:24 <xplat> if state is just position in the stream, then istm all states are observationally indistinguishable
09:23:00 <Kaidelong> it'd have to be a seperate concept, perhaps stream wouldn't really be the correct word anymore, machine perhaps?
09:23:39 <xplat> you ultimately have to have some non-streamish values, even if just Bool, to label your streams, or it all becomes trivial
09:24:27 <Kaidelong> what if you have that and an injection so that those values can all be turned into gears with one tooth?
09:24:48 <EvanR> automaton
09:24:53 <xplat> what do you mean by 'gears with one tooth'?
09:25:01 <Kaidelong> > repeat 1
09:25:02 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:26:10 <xplat> then you have a stream of things-that-are-not-streams
09:26:27 <Kaidelong> yeah but the head and tail is defined again
09:26:46 <xplat> the head doesn't have a head or tail
09:27:31 <xplat> unless you auto-inject it to a stream with 'repeat' again in which case it is impossible to tell what argument you used for 'repeat' in the first place
09:29:00 <Kaidelong> so you'd end up having it so that things that are data always end up being the same thing when you advance their state
09:29:17 <Kaidelong> but other parts of the system do have state and will change when the state is advanced
09:30:52 <ddarius> "Most" comonads will be infinite data structures.
09:30:56 <xplat> i'm starting to see how that could be a workable system, but only by not being infinitely nested
09:31:48 <ddarius> kmc: poke
09:34:09 <Kaidelong> I could see how I could use this sort of idea to set up my neural network
09:34:35 <Kaidelong> to advance a neuron it advances its inputs
09:34:35 * hackagebot bloomfilter 1.2.6.7 - Pure and impure Bloom Filter implementations.  http://hackage.haskell.org/package/bloomfilter-1.2.6.7 (BryanOSullivan)
09:34:46 <xplat> the time steps being linear is possibly a limiting choice, though
09:35:15 <xplat> it means you could only give a determinate value to an expression in the context of a complete program
09:35:29 <Kaidelong> what if your program isn't pure
09:35:46 <xplat> even then
09:36:16 <xplat> or at least you'd get effects that would be really bizarre
09:37:09 <xplat> i mean if you come right down to it you can model any kind of nondeterminism as an effect
09:37:45 <xplat> it just seems a little weird to push that down into a lower level than the 'turning gears' level
09:37:57 <Kaidelong> well ideally you'd be able to hook it up to inputs from a different model
09:38:08 <Kaidelong> the sensor neurons in my case
09:39:00 <Kaidelong> but now this is starting to sound like the state monad to me
09:39:28 <Kaidelong> in terms of what I want to do
09:39:46 <EvanR> god dammit, its 10-10-10 i hate that
09:39:56 <danharaj> why?
09:40:00 <EvanR> cheesy
09:40:06 <xplat> aw, damn, i missed 10-10-10 10:10:10
09:40:16 <osfameron> you could just pretend
09:40:23 <osfameron> which is about as authentic and meaningful
09:40:26 <EvanR> its 10:10:10 somewhere...
09:40:29 <ddarius> Crap, last week went by fast.
09:40:59 <EvanR> and you didnt miss it
09:41:18 <xplat> EvanR: actually, no.  will be in a half hour, though, in california
09:41:28 <EvanR> xplat: there you go
09:41:40 <xplat> very few after that, hits the dateline
09:41:58 <EvanR> ignore the dateline
09:42:19 <EvanR> i never understood it anyway
09:51:08 * Kaidelong thinks he'll use an object oriented approach and implement his neurons as records, sensor neurons can just be linked to an empty layer with a special firing function that ignores the layer argument
09:52:38 <xplat> are you going to have custom neurons in your net?
09:53:15 <Kaidelong> I think so, I also want to be able to change how they are trained IE go from supervised learning to unsupervised learning
09:53:42 <Kaidelong> so an object oriented design makes sense since I can switch out the learning function
09:53:50 <xplat> i don't think you can go from supervised to unsupervised at an individual-neuron level
09:54:16 <Kaidelong> why not?
09:54:27 <Kaidelong> each neuron has its own set of weights
09:54:43 <Kaidelong> not that I'd want to
09:54:43 <fasta> Kaidelong, if your purpose is to solve a real problem, then writing your own neuron library is a bad idea.
09:55:04 <Kaidelong> fasta: I'm not terribly happy with HNN and the problem is simple
09:55:07 <fasta> Kaidelong, otherwise your neural network is just a graph. 
09:55:22 <xplat> because the learning function has different inputs for supervised vs unsupervised
09:55:26 <fasta> Kaidelong, and 'training' this graph is just updating the weights.
09:55:44 <Kaidelong> yes, and the thresholds
09:55:49 <fasta> Kaidelong, whether you call that 'object oriented' or not is kind of immaterial. 
09:55:54 <ddarius> If one's purpose is to solve a real problem, one shouldn't be looking for a "neural net library" but for a library that does the kind of thing neural nets do.
09:56:14 <xplat> yeah, for example, classification
09:56:21 <fasta> ddarius, I was assuming it was a new problem.
09:57:08 <fasta> Sometimes after evaluating a few libraries you find that they all don't do want you want them to do, but I would say you have to read quite a lot of stuff in that area to beat the state-of-the art. 
09:57:30 <Kaidelong> I would hardly call it the state of the art and I'm not really looking for something state of the art
09:57:52 <ddarius> fasta: That's irrelevant.  The point is that neural nets are an implementation detail.
09:58:14 <fasta> ddarius, sure.
09:58:15 <Kaidelong> in this case they are the point
09:58:22 <Kaidelong> the goal
09:58:35 <fasta> Kaidelong, so, it's homework?
09:58:37 <ddarius> Kaidelong: That's fine.
09:58:42 <Kaidelong> sort of
09:58:46 <Kaidelong> it is class related
09:58:51 <xplat> what are you doing where the goal would be neural nets?  simulating biology?
09:58:52 <Kaidelong> but it wasn't assigned
09:59:19 <Kaidelong> xplat: I want to play with learning, in particular adding some ability to forget by randomizing weights over time if they aren't reinforced
10:00:25 <ddarius> Kaidelong: Incidentally, I am inclined to believe that what xplat was leading at before is that, as nice and natural as the "OO" view of neurons is, in practice it is not only more efficient, but often more convenient to take an "external" view and to treat the net as a "big array of numbers."
10:00:48 <xplat> ddarius: yes, that's basically it
10:01:41 <xplat> or a digraph with node and edge labels, if you have a sparse irregular network, or whatever
10:02:06 <zachk> have they done much with modeling neurotransmitters? i think thats key 
10:02:30 <Kaidelong> I wouldn't lose anything except in terms of needing to remember positions when I want certain neurons to use different strategies
10:02:52 <xplat> there are several areas of study dealing with 'neurons' that are pretty much entirely separate
10:03:06 <Kaidelong> That was something I'd thought of doing but I would probably start just switching the strategy after some supervised learning for everything
10:03:15 <Kaidelong> oh
10:03:39 <Kaidelong> well there is one situation, if I want multiple outputs from the same networks, the value of d will be different for different neurons
10:03:52 <Kaidelong> which will mean a different learning function
10:04:14 <Kaidelong> but only on the last layer
10:04:17 <xplat> computational learning theory, machine learning in practice, computational neurobiology, some corners of AI proper (but they've fallen out of vogue there by now i think)
10:05:10 <Kaidelong> I thought AI was more concerned with deterministic stuff on discrete sets of symbols?
10:05:25 <ddarius> Kaidelong: That's one faction.
10:05:55 <ddarius> Kaidelong: The other faction, usually called "Connectionists" tend to be more fuzzy and analog.  That's the faction that espouses neural nets.
10:06:25 <Kaidelong> so then what's the distinction between CI and AI? or are the connectionists at the intersection?
10:07:07 <ddarius> I don't know what you are using "CI" to mean here.
10:07:30 <Kaidelong> http://en.wikipedia.org/wiki/Computational_intelligence
10:08:45 <ddarius> Kaidelong: I would say CI is a subset of AI, though perhaps it has a slightly different charter.
10:09:12 <Kaidelong> yeah, looking at it that seems fair
10:13:00 <xplat> AI is a pretty troubled field.  it's produced a lot of results, but not the kind of results the early pioneers promised, and it attracts a lot of straight-out crackpots too because of the nature of what it's trying to do, so factions of AI researchers are constantly trying to rebrand themselves to something else to be taken more seriously, either by redefining their goals down to something more achievable or making a strong methodological distinction from thei
10:13:16 <xplat> wow, that came out longer than i expected
10:13:38 <aristid> xplat: and also cut off
10:13:49 <aristid> xplat: "from thei" END OF TEXT
10:13:51 <xplat> ah, i thought it might be for some people
10:14:06 <xplat> from their predecessors
10:14:32 <aristid> xplat: let's take autonomous cars... AI?
10:14:57 * EvanR plays the knight rider music
10:15:23 <xplat> useful result, still short of the most memorable promises in the public mind
10:15:58 <Kaidelong> I find it very interesting just by how general the learning process for these things are
10:16:27 <Kaidelong> it seems like if you have a big enough neural network you can get it to recognize almost any input you like with enough time spent training it
10:16:39 <Tarrasch> How well-known and established is 'reactive programming' amongst hasklers today? Seems like nobody have touched yampa for 5 years? Do hasklers today have doubts about it or something?
10:17:20 <ostmacka> Hi. I need help in writing a recursive function that counts how many times the number 0 appears in the result of the function (f n = 0). I have already defined that for example f 0 = 0, f 1 = 44, f 2 = 13, f _ = 0 etc. I am doing exercise 4.10 in the book "The craft of Functional programming" and I think that doing this function will help me making a bigger function. It would be nice if someone got the time to help m
10:17:28 <xplat> Kaidelong: there are results in Computational Learning Theory that provide fairly nice bounds on 'big enough' and 'long enough'
10:17:45 <ostmacka> sorry, I meant "the function f"
10:17:46 * hackagebot snap-server 0.2.13.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.13.1 (GregoryCollins)
10:18:17 <Tarrasch> ostmacka, for what given value to the function f?
10:18:30 <xplat> Tarrasch: if you want to know what people are doing with reactive programming lately try Conal Elliot's (sp?) blog
10:18:49 <Tarrasch> xplat, thanks, I'll try that
10:18:51 <conal> xplat: (two "t"s)
10:18:55 <conal> "Elliott"
10:19:05 <ostmacka> from 0 to n
10:19:07 <Tarrasch> conal, are you Conal Eliott then? :)
10:19:16 <conal> Tarrasch: yeah.  hi.
10:19:20 <Kaidelong> Real World Functional programming has a section on how to do reactive programming but it's for F#
10:19:21 <Tarrasch> conal, hi ^^
10:19:28 <conal> :)
10:19:37 <Kaidelong> not sure how that'd carry over since they probably don't use anything like yampa
10:19:43 <ostmacka> Tarrasch, I hope that I am answering you right. :P from 0 to n.
10:19:45 <xplat> conal: ah, thanks.  i wondered if you'd speak up when summoned :)
10:20:06 <Kaidelong> I think they used composable events to do it rather than arrows
10:20:18 <ostmacka> function f is Int -> Int.
10:20:36 <conal> Kaidelong: i've not seen RWFP.  do they use side-effects for their reactive stuff?
10:20:54 <Kaidelong> I don't remember conal. I'll look for you when I get back home.
10:20:56 <Tarrasch> ostmacka, how do you mean count the zeroes? Can you give an example, are you like summing --> sum [f i | i <-[0..n]] ?
10:21:02 <conal> Kaidelong: cool.. thx.
10:21:37 <xplat> F# has something called FCE (first-class events) which is lately being integrated with C#'s reactive library
10:22:17 <ostmacka> yes. going through for example f 0, f 1, f 2 etc to n. It should be a recursive function. :/
10:22:28 <ostmacka> counting the zeroes on the way...
10:22:43 <Tarrasch> oh ok
10:22:49 <ostmacka> hard for me to explain. but I hope that you understand. :/
10:22:52 <ostmacka> :P
10:22:58 <xplat> C#'s version is also known as 'LINQ to Events'
10:23:01 <Tarrasch> well, use show to make the digits "traversable"
10:23:08 <Kaidelong> ostmacka: won't you end up getting _|_ unless you have some parameter to limit the length of the enumeration
10:23:33 <Kaidelong> because you would have to keep trying f (n+1)
10:23:39 <ostmacka> yes, I think that it will go on forever if I dont limit it in some way. :S
10:23:45 <xplat> and that uses effects underneath
10:23:52 <ostmacka> so the function stops when at f 0 or something
10:24:25 <ostmacka> beginning at f 8  and using (n-1) until it reaches f 0.
10:24:26 <Tarrasch> ostmacka, normally recusrive funcitons have 0 as base-case
10:24:32 <ostmacka> but keeping the count in memory...
10:24:45 <ostmacka> yes. ok.
10:25:01 <conal> xplat: the main thing i'd look at is whether the effects are entirely contained in the api's implementation or whether they spill over into the semantics.
10:25:02 <xplat> it's based on a duality between OO enumerators and OO event sources
10:25:14 <Tarrasch> ostmacka, make a function g :: Int -> Int, returning the number of zeroes in the input, (hint: use show)
10:25:27 <Tarrasch> that should be a useful help-function
10:25:39 <Kaidelong> g f 0 = let g' f a n = if n < 0 then a else g' f (if f n == 0 then a+1 else a) (n+1)
10:25:40 <ostmacka> ok I will look up show at hoogle. thank you for the tip...
10:25:44 <xplat> i think you can use the library in a way that contains the effects pretty well but you can also use it in a way that does not
10:25:52 <Kaidelong> ugh
10:25:57 <Kaidelong> well that was very wrong
10:26:16 <Tarrasch> ostmacka, oh ok, you are new I see :)
10:26:24 <conal> xplat: ah, too bad.  when programmers are allowed to sneak in semantic side-effects, they generally do.
10:26:32 <ostmacka> yes I am. :) I beginner.
10:26:35 <Kaidelong> g  = let g' a f n = if n < 0 then a else g' f (if f n == 0 then a+1 else a) (n+1) in g 0
10:26:36 <ostmacka> A beginner.
10:26:40 <Tarrasch> show anything => textual representation of anything, show 123 = "123"
10:26:41 <Kaidelong> g  = let g' a f n = if n < 0 then a else g' f (if f n == 0 then a+1 else a) (n+1) in g' 0
10:26:52 <EvanR> conal: bondage and discipline for the win! :)
10:26:57 <conal> especially with something like reactivity, where traditional thinking is so deeply imperative.
10:27:30 <conal> EvanR: amen!   the discipline forces people to change their mental models, rather than fall back in to familiar & comfortable ruts.
10:27:48 <Macha> Hey, if module A imports A.B, can A.B access stuff defined in A?
10:28:22 <Heffalump> no
10:28:52 <Heffalump> not without having recursive imports, which in GHC are a little annoying
10:29:00 <EvanR> is the schism between apparently diametric opposites IO and functional programming a false dichotomy?
10:29:20 <Heffalump> and there's no privileged relationship betwenn A and A.B
10:29:38 <EvanR> physics versus math
10:29:56 <conal> EvanR: a more meaning perspective for me is to look at precise models/denotations of types
10:30:31 <conal> EvanR: "functional programming" is a vague notion.  "denotative" is more precise.
10:30:50 <nh910> is there a simple elem in list function? Can't find it via google
10:30:56 <EvanR> :t elem
10:30:57 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
10:31:01 <xplat> it's basically the C++ problem.  .NET basically had TWO prior ways to handle event-based and UI code not even counting language-specific ones, and they wanted people to easily be able to bridge between old and new code, but that makes it much harder to enforce disciplined model-adherence in the new code
10:31:25 <Macha> Heffalump: Ok, thanks
10:32:02 <conal> EvanR: see http://conal.net/blog/posts/is-haskell-a-purely-functional-language/#comment-35882
10:32:08 <EvanR> conal: yes ive seen your thoughts on that, so you are allowing denotative stuff to imply IO, makes sense if you think of how haskell is implemented
10:32:16 <Macha> So basically, if I want to share functions between A and A.B, I have to put them into A.C or some other module and import that from both?
10:33:36 <conal> arguments about whether a language or technique is "functional" are so often inconclusive, because people don't know or don't agree what the "functional" means, precisely.  that's why i prefer Peter Landin's suggested replacement "denotative".
10:33:38 <Tarrasch> Macha, are you expecting a different solution  than what would be for the case  "A <--> B. solution is to make a C"?
10:34:08 <Macha> Tarrasch: Just making sure I wasn't overlooking something obvious.
10:34:11 <Tarrasch> I mean, are the sub-modules making it "different"?
10:34:42 <Tarrasch> Macha, unfortunately I don't have any answers
10:35:00 <EvanR> conal: do you are agree that functional could mean that
10:35:00 <conal> EvanR: i don't understand "allowing denotative stuff to imply IO"
10:35:34 <EvanR> it seems like expressions made from IO primitives in haskell, you dont consider them denotative
10:35:43 <conal> EvanR: do i agree that "functional" could mean "denotative"?
10:35:53 <EvanR> yeah
10:35:56 <conal> EvanR: is that what you're asking?
10:35:59 <EvanR> yes
10:36:02 <Macha> Tarrasch: Basically I had two source files, one for IRC stuff, one for interface stuff. The IRC file got huge, so I'm splitting it into stuff like IRC.Logging, IRC.Parsing etc.
10:36:06 <EvanR> most recently
10:36:11 <Kaidelong> why would IO actions not be denotative?
10:36:22 <conal> EvanR: i agree in the sense that words can mean a lot of different things.  i prefer clarity & precision, though.
10:36:23 <danharaj> the type of IO actions doesn't really describe their semantics very much.
10:36:24 <EvanR> their definition seems imperative
10:36:46 <EvanR> and the primitives dont have a definition at all
10:37:04 <danharaj> then again even haskell's type system doesn't tell you much about semantics because of general recursion.
10:37:08 <Tarrasch> Macha, hmm, maybe finding a structure where you avoid cyclic loading, maybe the definitions can soundly be moved to Common.hs or something?
10:37:25 <conal> Kaidelong: because there isn't a precise denotational model for IO, with corresponding meanings of IO operations.
10:37:39 <Tarrasch> Just on top of head suggestions
10:37:42 <EvanR> is it possible to have a denotational model for IO ?
10:37:58 <EvanR> thats where i was originally coming from
10:38:01 <conal> EvanR: now that's the really interesting question!
10:38:08 <EvanR> physics vs math
10:38:32 <EvanR> funny because as imperative as IO stuff seems, physics itself is just a bunch of equations to solve
10:38:35 <conal> EvanR: how are you connecting IO with physics or math in your mind?
10:38:40 <EvanR> physics
10:38:46 <conal> how?
10:38:57 <Tarrasch> EvanR, Has your discussion anything with that physics is like IO, the real world. Math is like non-IO ?
10:38:58 <EvanR> well theres a time dependence that stands out more than anything, to me
10:39:05 <Tarrasch> anything to do with*
10:39:19 <conal> EvanR: ah.  IO has to do with time.  yeah.
10:39:33 <EvanR> theres also concurrent processes
10:39:42 <danharaj> I think there is a fundamental limit to how well you can give semantics to IO actions because of the OS.
10:40:24 <nh910> EvanR: thanks
10:40:29 <EvanR> IO can also be effectively 'truely random' if you use quantum physics
10:40:53 <conal> EvanR: wouldn't it be interesting to re-examine IO by making time & concurrency precise & elegant?
10:41:00 <EvanR> sure!
10:41:06 <EvanR> and also quantum physics ;
10:41:08 <EvanR> )
10:41:24 <conal> EvanR: yep.  now you're talking denotative!
10:41:45 <EvanR> i suppose at that point you can only continue by making the entire model probablistic
10:42:20 <conal> there used to be a lot of creative thought about "functional" IO.
10:42:47 <conal> but somehow people settled for the current non-denotative answer.
10:44:24 <conal> it's never sat well with me.
10:44:31 <EvanR> not even physicsts have a precise and elegant semantics for how quantum physics affects the real world
10:44:51 <EvanR> as it is the real world separates the functional world from QM
10:45:08 <EvanR> maybe theres a way to eliminate the real world using quantum computers
10:46:04 <EvanR> quantum haskell
10:48:46 <nus> nanoquantum gaskell
10:49:07 <nus> a XXI century tautology for magic
10:50:08 <EvanR> indeed if evaluating expressions (which must use material phenomena) can have arbitrary effect on stuff (perhaps non locally) then thats pretty magic ;)
10:51:30 <nus> here we go again "evaluating expressions" -> "casting spells" :-P (-;
10:52:25 <EvanR> it always seemed magic to me anyway, some spirit with vaguely defined form is running around inside my computer to tell me the answer to my question
11:00:42 <bla123> haxml or hxt: which one is cleaner, has more comprehensive support for reading and writing xml? (monads vs arrows-talk only if it's relevant to the feature set, please)
11:01:14 <EvanR> lol
11:01:38 <fasta> bla123, xml means different things to different people. I like the 'xml' library. 
11:01:40 <_linuxftw> If I have the datatype "State" (defined as: data State = State Int [Int] [Int]), and I have a function which returns IO State, how do I get individual values out the IO State?
11:02:17 <EvanR> _linuxftw: with pattern matching
11:02:36 <EvanR> after you execute the IO action
11:02:36 <_linuxftw> I've been trying that, like so: moveRight (State (val :: IO Int) (l :: IO [Int]) (r :: IO [Int]) ) =
11:02:49 <bla123> fasta: i'd like to have an xml library that has a nice, clean representation of an xml document (dom-style) and allows for easy navigation, editing, extraction, and so on
11:02:57 <xplat> _linuxftw: do { State a bs cs <- f; otherstuffusingabsandcs }
11:03:45 <bla123> fasta: for what reasons do you prefer the "xml" lib?
11:03:52 <EvanR> _linuxftw: you cant get the contents until executing the IO, and the if you wanted to make a 'accessor' to first a member after running the IO, it would need to be of type IO State -> IO [Int]
11:04:01 <fasta> bla123, its simplicity, mostly.
11:04:11 <EvanR> do what xplat said
11:04:15 <_linuxftw> EvanR isn't that what my pattern should do?
11:04:16 <Alien_Freak> hello all.. I'm going through a haskell programming book..and I had a question.. it seems that some things work if i load the file.. but don't if I type them out in the interpreter.. like type Card = String I can load from a file, but won't work if typed in directly 
11:04:28 <EvanR> _linuxftw: no
11:04:30 <fasta> bla123, the fact that a company build it also helps.
11:04:36 <fasta> built*
11:04:44 <_linuxftw> How would I write such an accessor function then?
11:04:58 <EvanR> dont, because you cant get more than one of the members
11:05:04 <Lemmih> Alien_Freak: Correct.
11:05:22 <EvanR> repeating the IO action to get the othe members would have more effects
11:05:24 <bla123> fasta: is it feature-rich enough for most common tasks? haxml and hxt look more heavy-weight
11:05:33 <_linuxftw> Ah, right
11:05:47 <fasta> bla123, there is no such thing as 'most common tasks'.
11:05:49 <Alien_Freak> any particular reason why that's the case?  kinda odd trying to type out examples from the book and I get syntax erros.. unless I put them in a file
11:06:09 <bla123> Alien_Freak: some things don't work in ghci
11:06:10 <_linuxftw> the problem is I need to write a function with the type IO State -> IO State, are you saying I'm wasting my time and I should find a way to write it as State -> IO State?
11:06:13 <fasta> bla123, if you have such an idea, just look at all the APIs yourself and decide based on that.
11:06:21 <xplat> _linuxftw: an accessor for val would be { getVal :: IO Int; getval st = do { State val _ _ <- st; val }
11:06:25 <fasta> bla123, or just flip a coin and try. 
11:06:47 <EvanR> _linuxftw: no, just execute the IO State, and use accessors of the form State -> [Int] or just pattern match at the time of execution
11:07:02 <EvanR> as above
11:07:02 <fasta> bla123, asking how beautiful Rome is, is a similar question, I suppose.
11:07:18 <benmachine> _linuxftw: once you've written a function State -> IO State, you can use (=<<) to turn it into IO State -> IO State
11:07:30 <xplat> (or if you leave off the type signature, that would be a polymorphic accessor that also works in other monads like ST or identity)
11:07:33 <bla123> fasta: well, i'm just overwhelmed by the number of xml libs. i know none of them and just don't want to spend a lot of time into learning the wrong one
11:07:34 <Alien_Freak> bla123: okay.. thanks. 
11:07:51 <fasta> bla123, I agree that's a problem.
11:08:03 <bla123> Alien_Freak: type declarations (type, data, newtype) generally don't work in ghci
11:08:06 <fasta> bla123, many people have discussed that, but nothing materialized.
11:08:20 <_linuxftw> would this work then? moveRight ioState1 = do {s <- ioState1; (val, l, r) <- s; return State val l r}
11:08:27 <fasta> bla123, I used all of them, and I didn't like HXT, but some people think it is a good idea.
11:08:35 <bla123> fasta: sadly. i wish there was an xml-library comparison page with some feature matrix
11:08:36 <ulfdoz> Imho, that isn't a problem. It is just wrong, to have only one "correct" way.
11:08:37 <EvanR> _linuxftw: btw the type State is probably not a good idea since its used by a popular type in the standard lib
11:08:50 <EvanR> @src State
11:08:50 <lambdabot> Source not found. It can only be attributed to human error.
11:08:57 <benmachine> _linuxftw: no
11:09:11 <fasta> bla123, you can only make a feature matrix if you know the full XML specs.
11:09:48 <fasta> bla123, there aren't that many people in the world that know Haskell, that, and wrote such a library. 
11:09:59 <freedrull> can i add user state to my parsec paser? its a state monad anyway right?
11:10:11 <benmachine> _linuxftw: xplat gave you an example do block, if you really want to do it that way
11:10:15 <monochrom> you can use user state in parsec.
11:10:16 <ddarius> freedrull: Yes.  It already has a mechanism for that.
11:10:33 <_linuxftw> benmachine, I don't really understand what you said about using =<<, could you give an example?
11:10:57 <benmachine> _linuxftw: putStrLn :: String -> IO (); (putStrLn =<<) :: IO String -> IO ()
11:10:59 <bla123> fasta: what do you mean with "XML specs"? i'm more interested in the kinds of features they offer, what tasks are easy with which library
11:11:28 <bla123> fasta: i think making such a matrix would take some clever people that know all those libs
11:11:45 <xplat> i think people found it less of a pressing problem because when you declare a type it usually comes with several functions to make it useful
11:11:49 <fasta> bla123, I mean the XML specification and all the special features it has like linking to other XML documents, etc.
11:11:51 <_linuxftw> that didn't make things much simpler to be honest
11:12:02 <xplat> the types in ghci not working thing, that is
11:12:17 <EvanR> _linuxftw: youre right, i dont know where benmachine is going with that ;)
11:12:25 <xplat> comparatively rare that you create a type with just one or two functions like you'd want to do in the command line
11:12:29 <bla123> fasta: did you also try haxml?
11:12:37 <fasta> bla123, yes. 
11:12:44 <benmachine> _linuxftw: basically, write function to operate on pure values, you can then make them operate on IO values using do-notation or (>>=)
11:12:49 <benmachine> *functions
11:12:52 <fasta> bla123, I managed to do what I wanted, but I don't like its model.
11:13:10 <benmachine> writing functions directly operating on IO-values is not that useful except when you want callbacks
11:13:13 <bla123> fasta: ah, yeah, models, that's what i'm interested in
11:13:15 <JHoglund> Yo! I need a quick way to look up corresponding integer values for certain characters. Since the values are unrelated to ascii-values, I've made them up myself, I need some sort of lookup-table. How would I achieve that?
11:13:17 <freedrull> how would i add my data type to the state, setState ?
11:13:21 <EvanR> liftM accessor actionToGetData
11:13:31 <fasta> bla123, anyway, got to go. 
11:13:39 <bla123> fasta: thank you, maybe i will just try xml
11:13:41 <_linuxftw> ok, I'll give it a go and get back to you
11:13:41 <EvanR> T a b c <- actionToGetData
11:13:48 <_linuxftw> (thanks for the help so far)
11:14:00 <monochrom> Data.Array or Data.Map can be lookup tables
11:14:26 <hpc> probably array, since you index by integer
11:14:35 <benmachine> you index by char
11:14:38 <JHoglund> I'd like something like an associative array
11:14:42 <JHoglund> I index by char
11:14:44 <hpc> oh, my mistake
11:14:53 <EvanR> Char is instance of Enum
11:15:04 <benmachine> JHoglund: very likely Data.Map will work for you just fine
11:15:09 <EvanR> which means you can use a Char as an Int in an IntMap or Array
11:15:23 <benmachine> JHoglund: Data.Array could be faster, but Data.Map is simpler and there's not that big a difference anyway
11:15:29 <monochrom> Data.IntMap is probably the best win
11:15:38 <JHoglund> Speed is not a matter in this app :)
11:15:49 <JHoglund> Thanks, I'll have a look at data.map
11:15:56 <benmachine> JHoglund: you could even just do lists [(key, value)]
11:16:01 <benmachine> and use lookup
11:16:04 <benmachine> :t lookup
11:16:06 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
11:16:20 <benmachine> but Map is faster and probably has a richer API
11:16:28 <benmachine> the latter point will be nice
11:17:16 <JHoglund> benmachine: There was a nice example for Data.map.Lookup in the docs!
11:17:26 * ddarius suspects that JHoglund is not concerned about Unicode codepoints and probably only needs a 256 entry table.
11:17:42 <JHoglund> Is Data.Map.Lookup the correct way of denotating the function Lookup in module Data.Map?
11:17:51 <EvanR> lowercase l
11:17:53 <EvanR> lookup
11:18:13 <EvanR> import qualified Data.Map as Foo
11:18:16 <EvanR> Foo.lookup
11:18:44 <EvanR> example Map.lookup
11:18:58 <JHoglund> ddarius: I'm happy with 8-bit, unless you've got a mathematical operator which is described in UTF-8 for me :)
11:19:14 <ddarius> JHoglund: Most of them.
11:19:17 <benmachine> heh
11:19:20 <xplat> JHoglund: yeah, there are a ton
11:19:24 <EvanR> Char is any character
11:19:43 <JHoglund> xplat: Huh? +, -, *, sqrt() and so on arent UTF-8?
11:19:53 <EvanR> they dont work on Chars
11:20:00 <benmachine> JHoglund: they're all ascii, but √ isn't :)
11:20:00 <xplat> like at least 3 unicode blocks are devoted to math operators, not even counting arrow-shaped ones or letterlike symbols
11:20:01 <EvanR> do you have Word8 ?
11:20:15 <hpc> @hoogle Word8
11:20:15 <lambdabot> Data.Word data Word8
11:20:15 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
11:20:31 <EvanR> :t sqrt
11:20:32 <lambdabot> forall a. (Floating a) => a -> a
11:20:41 <JHoglund> Oh, crap... Luckily, there's no need, right now, for fancy utf-8 support in the expressions :)
11:21:05 <EvanR> why are you using + - * and sqrt on characters?
11:21:18 <benmachine> JHoglund: yeah I wouldn't worry too much about it, use Data.Map and be pleased with it
11:21:37 <theorbtwo> I think considering utf8 fancy is a bit silly these days, especially in Haskell.
11:21:40 <benmachine> EvanR: probably a parser, a more interesting questino is why he's mapping operators to integers
11:22:43 <theorbtwo> Char and String nicely Just Work, most of the time you don't have to worry about encodings.
11:23:20 <benmachine> well if you use a Map Char Integer it's efficient whether you use a small or large amount of the range of Char
11:23:23 <benmachine> so it's fine
11:23:38 <JHoglund> benmachine: Yep, a parser is right. My delayed homework requires me to parse mathematical expressions, and I need a way to keep track on operator precedence
11:23:44 <ddarius> For a very skewed notion of "efficient."
11:23:53 <xplat> √∛∜∘∫∆≤≥∑∏
11:24:12 <JHoglund> So I figured I'll make a short lookup-list where I can check if operator A has higher priority than B
11:24:21 <theorbtwo> Efficent in CPU time isn't something you should worry about until it's proven to take to long.
11:24:57 <theorbtwo> ...and when it does, the first thing you should do is profile, rather then assuming the problem is Map Char Integer instead of Map Word8 Integer.
11:24:58 <ddarius> theorbtwo: People like to say that, but it isn't true.
11:25:18 <ddarius> theorbtwo: The problem is more Map Char Integer v. Array Word8 Int
11:25:56 <theorbtwo> Array Word8 isn't going to be very effecent when you only have a few slots of it filled in anyway, is it?
11:26:16 <JoeyA> Just wondering: when you say data List a = Nil | Cons !a !(List a), do the bangs change how List is stored internally?
11:26:25 <xplat> it can pay to think about CPU time up front, but only if you are familiar enough with the domain and the language's execution model to make a good job of it
11:26:35 <JoeyA> Without the bangs, the compiler has to keep track of whether the value is evaluated, still a thunk, or undefined.
11:26:36 <benmachine> JoeyA: they could do, for example GHC has a flag -funbox-strict-fields
11:26:50 <JoeyA> does that result in compatibility issues?
11:26:53 <xplat> i mean aside from really trivial things like 'don't write your own bubble sort instead of using the library sort'
11:26:59 <benmachine> compatibility issues?
11:27:06 <ddarius> theorbtwo: If you can limit to Word8, then storing the whole thing is a trivial amount of memory and efficient, O(1) lookup.
11:27:43 <JoeyA> As in, what keeps -funbox-strict-fields from treating ByteString and other already-written libraries from having the alternative interpretation?
11:27:54 <benmachine> no, but it can result in bad performance sometimes, because converting between 'a-that-might-be-lazy' and 'unboxed a' has a runtime cost
11:27:59 <ddarius> xplat: If you don't understand the domain or language's execution model, it really doesn't matter when you think about CPU time.
11:28:06 <benmachine> JoeyA: the alternative interpretation?
11:28:09 <JoeyA> And is -funbox-strict-fields off by default to avoid compatibility issues?
11:28:21 <JoeyA> The alternative interpretation being using boxed values for banged data members.
11:28:22 <benmachine> JoeyA: no it's off by default because sometimes it can make code *less* efficient
11:28:36 <xplat> ddarius: it does matter because if you think about it after writing the code and profiling you might learn something
11:28:37 <benmachine> because you've got to unbox and rebox values when you construct or deconstruct your type
11:28:43 <JoeyA> hmm
11:28:57 <JoeyA> so when you copy it (e.g. returning), you have to make a box?
11:28:59 <theorbtwo> Hm.  I suppose 256 slots, even big haskell slots, isn't that big a deal on a modern system.
11:29:13 <theorbtwo> I think you'll loose pretty badly in terms of cache pollution, though.
11:29:15 <fasta> JoeyA, only when that function requires a box. 
11:29:16 <JoeyA> err, because you have to copy it when you return a box?
11:29:43 <benmachine> JoeyA: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/pragmas.html#unpack-pragma has some discussion
11:29:54 <ddarius> xplat: Probably very little unless you consult resources you could find just as well before.
11:29:54 <JoeyA> I'm thinking about this from the angle of someone wanting to implement a Haskell system.
11:30:51 <ddarius> At any rate, like any other error, it's much easier to avoid or fix early space leaks and significant inefficiencies that to have to "debug" them later and figure out where and which code is the problem and how to change it and how that affects the rest of your code.
11:31:23 <JoeyA> Thanks
11:32:06 <benmachine> JoeyA: p.s. returning things doesn't necessarily mean copying them, just modifying does :)
11:32:29 <JoeyA> right
11:32:32 <JoeyA> By the way, is my understanding of what a lazy thunk really is correct?  Something like (pretending Haskell is strict) data Box a = Value a | Deferred (() -> a) | Undefined
11:32:51 <xplat> ddarius: at any rate there's a gap between knowing these things well enough to 'debug' slowness and knowing them well enough to plan up front so it never happens
11:32:53 <JoeyA> (and also pretending Haskell allows Box to be mutable)
11:33:15 <JoeyA> so under the hood, stuff is more like type a = IORef (Box a)
11:33:59 <EvanR> uhg lambdas for the sake of delaying evaluation/execution
11:34:12 <JoeyA> Pseudocode :P
11:34:22 <EvanR> thats real code in most languages ;)
11:34:30 <JoeyA> heh
11:35:08 <JoeyA> A deferred computation resembles a closure in that it has context, but takes zero instead of one argument(s), right?
11:35:23 <JoeyA> (err, does the implementation resemble)
11:35:52 <ddarius> xplat: Yes, a huge gap called the halting problem, but the latter isn't the what's being suggested anymore than planning up front so that bugs never happens is.
11:37:00 <EvanR> JoeyA: you can think of a 'closure' as a function with extra parameters at the beginning being partially applied
11:37:12 <JoeyA> right
11:37:31 <EvanR> and no free variables
11:37:41 <_linuxftw> benmachine, I've managed to convert my functions to the type State -> IO State. My program now has a list of these functions and I just need to run the IO actions. I know the type of the function I want to write, I don't know exactly how to write it though. Here's what I've got: execute :: State -> [State -> IO State] -> IO (); execute s0 prog = foldl (???) s0 prog
11:37:54 <JoeyA> By the way, it's worth pointing out that having sample data (e.g. a program that runs too slow) can help guide the optimization process, so struggling to debug something that's too slow is instructive.
11:38:15 <JoeyA> (so maybe people shouldn't say "premature optimization is the root of all evil", but "immature optimization ...")
11:38:57 <EvanR> everytime i say 'profile it' to find out why the php at work is slow, they cringe
11:38:57 <JoeyA> "mature" optimization would be using prior experience to hypothesize how well something would perform.
11:39:09 <EvanR> they would rather tweak random stuff and sit around guessing at the proble
11:39:44 <benmachine> _linuxftw: have a look at (<=<) or (>=>), they might come in handy
11:39:48 <benmachine> :t foldr (<=<) return
11:39:49 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
11:39:57 <xplat> _linuxftw: (???) = (>>=)
11:40:47 <xplat> _linuxftw: but you have to change s0 to (return s0) in the foldl call
11:41:06 <benmachine> xplat: pretty sure you can't use foldl with (>>=)
11:41:57 <benmachine> oh wait am I wrong
11:42:01 <benmachine> yes I am
11:42:02 <benmachine> oh well
11:42:07 <_linuxftw> The following compiles: execute s0 prog = do { result <- foldl (>>=) (return s0) prog; return () }
11:42:12 <monochrom> correct by design is easier than fixing problems postmortem. ("correct" includes correct time and memory bounds.) correct by design requires only reasoning about well-designed programs. fixing errors postmortem requires reasoning about both well-designed and pathological programs. Example: it is always easier to fix your own code than to fix other people's code: your own code is more well-designed, or at least you know your own
11:42:12 <monochrom>  design philosophy, other people's code is totally arbitrary. Another example: it's always easier to completely replace other people's code by your own than to minimally fix other people's code.
11:42:52 <_linuxftw> Thanks for the help ben & xplat. Now to see if it actually works!
11:43:46 <benmachine> monochrom: moving towards the eventual optimum where all code is written by me
11:44:23 <ddarius> benmachine: Only if you are more prolific than the combined mass of everyone else.
11:44:43 <benmachine> ddarius: I move towards the optimum but it moves away from me faster :(
11:44:49 <benmachine> *more quickly
11:45:01 <ddarius> You can reach the optimum locally.
11:45:12 <_linuxftw> Ok it doesn't work, but for an unrelated reason. Am I right in saying that if you write (return (repeat 0)) your program will hang forever?
11:45:14 * ddarius returns to writing screen handling drivers.
11:45:27 <benmachine> _linuxftw: all depends on what you do with that return (repeat 0)
11:45:35 <_linuxftw> if you execute it
11:45:35 <danharaj> ddarius: are you writing an OS :o
11:45:58 <benmachine> _linuxftw: that alone isn't enough to cause your program to hang forever
11:46:17 <benmachine> _linuxftw: doing something with that result might
11:46:23 <ddarius> danharaj: Not really.  Something more like old-time systems where you'd boot and be in a BASIC and that was the whole system.
11:46:33 <benmachine> _linuxftw: even then, it depends what you do
11:46:37 <_linuxftw> Right ok. Elsewhere in the program I'm using head/tail with that result so that might do it?
11:46:50 <xplat> no
11:46:57 <benmachine> head on repeat 0 is fine, tail will produce an infinite list but as long asyou're sensible with it that's fine too
11:47:16 <JoeyA> hmm, I wonder if you can throw enough pragmas at a data structure in Haskell such that it's stored in a single block of memory.
11:47:24 <ddarius> If you are happy with repeat 0, then surely you should be happy with tail (repeat 0)
11:47:29 <xplat> you can't hang with head/tail unless you recurse also
11:47:30 <JoeyA> data List a = Nil | Cons !a !(List a)
11:47:42 <danharaj> I'm finally getting the constructions in Hagino's thesis.
11:48:00 <JoeyA> If a and (List a) are unpacked in the most literal sense, List a will occupy one big block of memory, right?
11:48:15 <danharaj> It is radically awesome that he can treat Adjoints and (Co)Algebras in the same way.
11:48:40 <xplat> JoeyA: i don't think haskell will fully unbox a variable-sized data structure like that
11:49:00 <benmachine> xplat: in principle it could do
11:49:07 <pumpkin> http://github.com/johang88/haskellinjavascript
11:49:15 <benmachine> but there are probably pointers involved somewhere that ruin it
11:49:31 <xplat> benmachine: i meant 'haskell' in the sense of 'any haskell implementation you've probably heard of'
11:49:37 <benmachine> pumpkin: :O
11:49:37 <JoeyA> while I'm at it, is data Foo = Foo !Foo impossible to actually construct, since it would take infinite memory?
11:49:47 <JoeyA> Whereas data Foo = Foo Foo could be constructed thanks to laziness.
11:50:29 <xplat> yes
11:50:29 <benmachine> JoeyA: data Foo = Foo !Foo is a type that contains only the value undefined, I think
11:50:53 <freedrull> :t updateState
11:50:53 <lambdabot> Not in scope: `updateState'
11:51:10 <xplat> newtype Foo = Foo !Foo would be constructible in principle, if not in practice.  if it weren't illegal.
11:51:22 <benmachine> newtype Foo = Foo Foo is legal
11:51:35 <xplat> oh, maybe then it would work
11:51:54 <benmachine> yeah, it's how you do empty types without EmptyDataDecls
11:52:02 <JoeyA> Although evaluating undefined in GHC throws an exception, can't an infinite loop also be called "undefined"?
11:52:18 <benmachine> JoeyA: depends on your usage of language
11:52:27 <JoeyA> Doesn't it screw up being able to use unsafeCoerce to unwrap a newtype, though?
11:52:38 <benmachine> JoeyA: well, no
11:52:39 <identity> System.Time = old?
11:52:39 <JoeyA> What if I say friggin gosh?
11:52:40 <xplat> Foo Foo contains the value Foo $ Foo $ Foo $ Foo $ ... as well as the partially-undefined values
11:52:43 <identity> Data.Time the new one?
11:53:01 <ddarius> "When I use a word, it means just what I choose it to mean"
11:53:39 <xplat> also: undefined is considered a single value no matter which kind because different causes of undefined cannot be distinguished by pure code
11:53:40 <ddarius> xplat: The data form does, the newtype or strict data form does not.
11:54:04 <JoeyA> I think infinite loops are treated as _|_ in the documentation on fixST: Allow the result of a state transformer computation to be used (lazily) inside the computation. Note that if f is strict, fixST f = _|_. 
11:54:10 <benmachine> xplat: a newtype is such that Foo _|_ == _|_, so it's all the same
11:54:27 <benmachine> JoeyA: yeah, _|_ is often used to denote non-terminating computations
11:54:54 <ddarius> _|_ was originally and specifically created to represent non-terminating computations.
11:55:06 <benmachine> JoeyA: non-terminating can also mean, calling error instead of terminating, or calling a partial function at a value outside its domain
11:55:18 <Twey> Heh
11:55:30 <Twey> benmachine: Look at you, using mathematical terminology.  #haskell has changed you :þ
11:55:45 <xplat> benmachine: i don't know why newtype Foo = Foo Foo wouldn't contain fix Foo as a proper value
11:55:47 <benmachine> Twey: you realise I'm doing a maths degree, right? >_>
11:55:54 <JoeyA> benmachine: how would it get outside of its domain?
11:56:03 <EvanR> > head []
11:56:03 <benmachine> xplat: it might well do, but it's equal to all the other values
11:56:04 <lambdabot>   *Exception: Prelude.head: empty list
11:56:17 <ddarius> benmachine: See how much Haskell has changed you?
11:56:20 <benmachine> JoeyA: I might be using the word domain wrongly; I just meant, yeah, like head []
11:56:24 <Philippa> JoeyA: insufficiently strong typing
11:56:26 <JoeyA> oh
11:56:30 <Philippa> (possibly just no typing)
11:56:31 <Twey> benmachine: Really?  No, didn't know.
11:56:39 <benmachine> Twey: oh right, well, there you go :P
11:56:43 <Twey> benmachine: I just remember you as a C hacker :þ
11:56:51 <benmachine> eek my dark past is unearthed
11:56:51 <xplat> there's no obvious reason fix Foo should be equal to bottom
11:57:16 <ddarius> xplat: Foo is id after type checking.
11:57:16 <xplat> other than implementation issues, anyway
11:57:17 <benmachine> xplat: you can't distinguish them
11:57:47 <benmachine> xplat: case fix Foo of Foo _ -> whatever succeeds, but so does case undefined of Foo _ -> whatever
11:58:11 <benmachine> Twey: (also, there is a part of me secretly pleased you remember me at all :P)
11:58:20 <benmachine> (-secretly, whoops)
11:58:26 <JoeyA> I just remembered benmachine as someone I played Marathon (Aleph One) with, I think.  Yes, I'm stalking you.
11:58:37 <ddarius> benmachine: I don't think such conversation is appropriate in a public environment.
11:58:38 <benmachine> JoeyA: ... might have been a different benmachine
11:58:48 <JoeyA> oh, thanks for clearing that up
11:59:02 <EvanR> Twey and benmachine sitting in a tree
11:59:04 <xplat> benmachine: oh, i guess you're right
11:59:11 <JoeyA> It didn't occur to me that there could be more than one bens machine.
11:59:29 <benmachine> JoeyA: it didn't occur to me either until I'd got stuck to the name :(
11:59:52 <ddarius> benmachine: In your next life, choose your IRC nick to be a UUID.
11:59:58 <benmachine> haha ofc
12:00:07 <JoeyA> or just use "monad", if you're anywhere but Freenode.
12:00:39 <benmachine> <_< no I'll just become hugely rich and famous and then buy out all the other benmachines and merge them into myself somehow
12:01:01 <ddarius> I suggest recycling them instead.
12:01:19 <benmachine> well, I'll consider my options closer to the time.
12:01:23 <JoeyA> I wonder why Haskell is one of the most popular programming language channels on IRC.  #java and ##c have fewer people.
12:01:34 <JoeyA> ##c++ currently has 6 more people than here.
12:01:40 <JoeyA> crap, 7!
12:02:21 <ddarius> It's clearly because the Haskell community is approximately the size of the C++ community.
12:02:23 <res> because haskell is just amazing like that
12:02:47 <xplat> haskell is more interesting to talk about than java or c
12:03:03 <Philippa> that and we don't say STFU n00b and we metatroll with politeness
12:03:04 <EvanR> ##c++ war!
12:06:06 <nickela> Im come from C++, Haskell break my heart, later I think no better language than C++ on the Eath, but Im wrong :)
12:06:20 <JoeyA> I think it's because people in #haskell assume others are smart because they're learning Haskell.
12:06:28 <EvanR> haha
12:06:50 <JoeyA> Although that sort of sounds stuck-up or whatever, look at the results!
12:07:56 <danharaj> most of us in this channel don't suffer from programming language tough guy syndrome.
12:08:13 <JoeyA> Not entirely sure what you mean
12:08:23 <luite> JoeyA: pretty much the same as people in #java who assume that others are stupid and asking homework questions :p
12:08:31 <JoeyA> right
12:09:00 <danharaj> I don't know if I can be more descriptive than 'programming language tough guy' syndrome :p
12:09:01 <JoeyA> I asked a fairly legitimate question in #csharp and didn't get an answer recently: how do I install a third party library in Linux on Mono/C# .
12:09:08 <JoeyA> Maybe that's just not the way things are done over there.
12:09:13 <JoeyA> cabal ftw
12:09:17 * hackagebot HsHyperEstraier 0.3.2.1 - HyperEstraier binding for Haskell  http://hackage.haskell.org/package/HsHyperEstraier-0.3.2.1 (MasatakeDaimon)
12:10:37 <Tarrasch> Note how #hasklers don't mention the haskell 98 standard in every message or so, unlike some other damned channel ...
12:10:46 <JoeyA> heh
12:11:11 <EvanR> its an order of magnitude more difficult to be a tough guy about haskell ;)
12:11:18 * hackagebot pcre-less 0.2.0 - Nicer interface to regex-pcre  http://hackage.haskell.org/package/pcre-less-0.2.0 (MichaelZuo)
12:11:45 <Tarrasch> Typical 'programming language tough guy' syndrome is to prove somebody else wrong buy quoting the standard of the language.
12:11:51 <ddarius> Playing electric bass unpowered is disaster for my fingernails.
12:12:14 <danharaj> is there a reason why your fingernails aren't completely nubbed down?
12:12:27 <ddarius> danharaj: Banjo and classical guitar.
12:12:28 <Tarrasch> Is there any reason it's unpowered? :p
12:12:36 <JoeyA> go pick up a K&R and work through the examples
12:12:37 <ddarius> Tarrasch: I live in an apartment.
12:12:49 <JoeyA> then you'll know everything
12:12:53 <danharaj> that is mad respect that you do both
12:13:07 <danharaj> I did not know you could maintain nail shape for classical guitar while beating on a bass
12:13:08 <JoeyA> jk
12:13:14 <ddarius> danharaj: But yeah, there is a conflict between what you want for your nail for bass and what you want for banjo/guitar.
12:13:18 <mwc> JoeyA: well, in defense of #csharp and mono, most of them probably don't know anything outside how to use the VS GUI
12:13:36 <JoeyA> hmm
12:13:37 <danharaj> have you considered finger picks? I don't know if they are viable for classical
12:13:43 <mwc> JoeyA: language vs. implementation
12:14:12 <ddarius> danharaj: I haven't actually tried it, but I'm fairly confident fingerpicks would be atrocious for classical guitar.  At any rate, I abhor them for banjo.
12:14:20 <wjt> ddarius: time to buy a nylon-strung bass ukulele.
12:14:22 <mwc> does anybody know if the llvm patches that GHC needs made it into 2.8?
12:14:40 <JoeyA> But it's rather strange how a language with so much clout behind it can be lacking in resources.  I wanted to install IntX (a C# library for big integers), and I couldn't find anything on how to build a IntX.shfbproj .
12:14:44 <pikhq> They did.
12:15:07 <JoeyA> Maybe when people program in Haskell and feel really smart because they know monads, they go blog about it.  Looks to me like hubris is a good thing.
12:15:12 <danharaj> hmm, how about playing banjo/classical guitar opposite handed from bass guitar :p
12:15:18 <akamaus> what's the easiest way to build a debian package from a cabalized haskell program? Nothing fancy, just a binary and one data file.
12:15:28 <mwc> JoeyA: it's also more likely that C# and Java don't have big hacker cultures
12:15:37 <JoeyA> interesting
12:15:46 <benmachine> does haskell have a 'hacker' culture?
12:15:48 <danharaj> http://sites.google.com/site/haskell/notes/cabal-on-debian
12:15:49 <Philippa> Tarrasch: we tend to leave that to people who've actually implemented the language
12:15:51 <ddarius> wjt: My friend got a ukulele when I visited him in Japan last.  I didn't realize that ukulele's had a high string.  I was in love when I found out you could use clawhammer on a ukulele.
12:15:54 <ezyang> akamaus: Hmm... a wrong answer would be cabal2spec + alien 
12:15:56 <Philippa> benmachine: very much so
12:16:13 <ddarius> danharaj: What I should do is stick to picked bass for the most part.
12:16:17 <benmachine> Philippa: I guess I always saw it as more of an academic culture, but I suppose they're not incompatible
12:16:18 <mwc> benmachine: totally. I think some schools use it, but most people who learn haskell heard about it and decided to look into it themselves
12:16:31 <akamaus> ezyang, why is it wrong?
12:16:32 <danharaj> ddarius: that sounds like it diminishes a lot of the fun of bass
12:16:32 <wjt> ddarius: the bass ukulele I tried was fretless, and tuned like an upright/bass guitar. shame i couldn't justify owning it :)
12:16:40 <Philippa> benmachine: take a look at the code that gets written, tell me none of it's hacks in the good sense :-)
12:16:43 <ezyang> akamaus: It's a bit convoluted :-) 
12:16:57 <benmachine> Philippa: heh, fair enough
12:17:09 <xplat> haskell has sort of an academic-hacker fusion culture, like old-time MIT
12:17:30 <danharaj> yes, haskell is a healthy meeting of hacker and academic
12:17:38 <danharaj> and hopefully commercial soon enough :p
12:18:10 <fasta> danharaj, what exactly would you like to pay for?
12:18:28 <Tarrasch> fasta, obviously, he want's to GET paid
12:18:35 <danharaj> obviously I want to play games written in haskell
12:18:50 <danharaj> Don't link raincat it doesn't work for me :|
12:18:56 <pumpkin> meow
12:19:20 <ddarius> danharaj: There's Monadius!
12:19:44 * ddarius never played raincat because it doesn't like xmonad.
12:21:00 <danharaj> That is true.
12:21:13 <danharaj> Perhaps I really long for games that don't make puns on haskell jargon :p
12:22:00 <JoeyA> lol
12:22:24 <benmachine> raincat doesn't work for me either, because all GLUT apps seem to crash on startup on this computer
12:22:27 <benmachine> this made me :(
12:23:03 <danharaj> honestly, if Microsoft released DirectX bindings for Haskell I would probably be making games right now.
12:23:19 <pumpkin> make them yourself! :P
12:23:50 <ddarius> Raincat worked fine on my computer, it just didn't interact particularly well with xmonad.
12:23:51 <bd_> hmm... is there a COM binding for Haskell yet?
12:24:03 <ddarius> bd_: There have been a few made over time.
12:24:08 <danharaj> pumpkin: I am not a masochist ;)
12:24:23 <pumpkin> @hackage com
12:24:24 <lambdabot> http://hackage.haskell.org/package/com
12:24:50 <bd_> hmm, I guess that's the hard part already done
12:24:51 <pumpkin> it'd be nice if you could get haddock docs without the thing compiling
12:25:00 <bd_> which just leaves the tedious part
12:25:06 <pumpkin> it should be possible to just ask GHC to parse the thing without compiling it
12:25:12 * pumpkin shrugs
12:25:39 <ddarius> pumpkin: Hack in a new flag.
12:25:48 <JHoglund> Can I assign a name to the result of case expression?
12:26:00 <pumpkin> ddarius: sounds like a lot of work! it's easier for me to just bitch about it
12:26:04 <ddarius> JHoglund: You can assign any expression a name.
12:26:12 <bd_> JHoglund: let myVariable = case .......
12:26:14 <mwc> JHoglund: let foo = case x of ...
12:26:15 <sully> @unpl ((join .) . (.repeat) . zipWith (++) . (++ repeat []) . replicate 4) "the shift is " "coming down, "
12:26:16 <lambdabot> ((zipWith (++) ((replicate 4 "the shift is ") ++ (repeat [])) (repeat "coming down, ")) >>= \ g -> g)
12:26:26 <bd_> JHoglund: I'd use a where clause myself, though
12:26:32 <JHoglund> I need to uise let, event hough I'm coding in a text editor?
12:26:48 <mwc> JHoglund: yes, but not at top level
12:26:50 <bd_> JHoglund: ... most people usually code in a text editor?
12:26:54 <JHoglund> Uhm, forget about the last remoark, I'm a bit confised
12:27:12 <mwc> JHoglund: foo x = let y = case g x of { .. } in h y
12:27:15 <bd_> JHoglund: I mean, where clauses are one option, turning the case clause into a function is another option
12:27:35 <bd_> turning the case clause into a function inside the where clause is always an option, of course
12:28:36 <benmachine> @remember pumpkin sounds like a lot of work! it's easier for me to just bitch about it
12:28:36 <lambdabot> I will remember.
12:28:49 <mwc> JHoglund: note that you could also do: foo x = h $ case g x of ...
12:28:49 <pumpkin> :)
12:28:54 * benmachine hugs pumpkin 
12:29:13 * AnAdorableNick ghcis benmachine
12:29:21 <benmachine> god damn it I wish I could do that without the automatic interpreter jokes >_>
12:29:29 <JHoglund> It's starting to be a bit too many inner functions in my messed-up try to create a math parser, though ^^
12:29:32 <mwc> JHoglund: case isn't a statement like the switch station in C-like languages, it's an expression that case be used anywhere an expression is used
12:31:26 <JHoglund> I've got some if-statements, a few levels down, I do a "case operator of" and some alternatives, to choose what to return. I need to store the outcome from the "case", rather than just return it, to use later on and decide what to return
12:31:28 <akamaus> ezyang, I saw a page mentioned cabal-debian,  http://www.mail-archive.com/haskell-cafe@haskell.org/msg44425.html, but the link is dead now.
12:32:25 <JHoglund> Refactoring the "case" to go as "let" or "where" seems a bit too cumbersome right now, I'd rather keep the case and store the result in a named, whatever the not-really-variables are called :)
12:33:03 <benmachine> JHoglund: if you hpaste it we can show you how we'd make it neater
12:33:21 <mauke> 'let' is how you make variables
12:33:30 <mauke> there are no 'if' statements
12:33:31 <JHoglund> benmachine: Give me a minute or two to add some comments and I'll give you guys a hpaste :)
12:33:49 <ezyang> akamaus: Maybe lookup a few of the debian Haskell packages and see how they're packaged. 
12:34:52 <ddarius> benmachine: Be careful what you wish for.
12:35:28 <xplat> yeah, remember to specify 'a pony of calm temperament that does not bite'
12:35:43 <majere> is haskell a language good for a beginner to programming should learn
12:35:49 <majere> and if it is, where can i get started already!
12:35:55 <nlogax> @where lyah
12:35:56 <lambdabot> http://www.learnyouahaskell.com/
12:35:56 * majere wants to write good programs that are useful
12:36:02 <ddarius> majere: It's not bad, there are arguably better languages.
12:36:05 <majere> but i don't know any languages
12:36:07 <majere> ah
12:36:13 <majere> ddarius: so what do i do?
12:36:26 * majere wants to get started on sleepless nights with ghc :/
12:36:31 <xplat> haskell can be a very good language for a true beginner, actually
12:36:35 <majere> or whichever language environment
12:36:41 * majere knows tinsy bits of c
12:36:50 <majere> but not enough to consider myself a programmer
12:36:54 <xplat> it's much better as a first language than a second language
12:37:07 <ddarius> Scheme seems to be the language with the most handily available and comprehensive learning materials for an absolute beginner with nice tooling and a reasonably well-designed language.
12:37:22 <majere> ddarius: ok
12:37:42 <majere> guess ill do that
12:37:47 <ddarius> majere: However, you should plan on learning several languages.
12:37:56 <majere> ddarius: not at the same time, surely
12:37:59 <ddarius> majere: Whether for fun or profit, you will need to know many.
12:38:20 <ddarius> majere: At first it probably isn't really a good idea to try to learn several at the same time, later on it won't be a big deal.
12:38:39 <res> later on, you will always be learning several at a time
12:38:41 <majere> ddarius: is "the little schemer" good enough?
12:38:59 * majere isn't good at math so…
12:39:05 <ddarius> majere: I've never read it, but it is pretty well regarded.
12:39:11 <majere> ok
12:39:15 <JHoglund> benmachine: http://hpaste.org/40478/math_parsing <-- There's the code, I hope it's readable and I'm not very proud of it...
12:39:36 <majere> ddarius: thanks, i'll get started right as soon as i get the book
12:39:38 <ddarius> For online resources I'd recommend HtDP for the complete beginner: www.htdp.org.
12:39:45 <majere> ok
12:39:58 <sdf> sicp.
12:40:26 * hackagebot snap-server 0.2.13.2 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.13.2 (GregoryCollins)
12:40:36 <majere> thanks ddarius 
12:40:49 <benmachine> JHoglund: it's not bad! are you using tabs though?
12:41:05 <benmachine> JHoglund: yes you are, you might find this upsets GHC sometimes :P
12:41:07 <sdf> who starts out programming using emacs as an irc client?
12:41:21 <benmachine> sdf: cool people, obviously
12:41:24 <JHoglund> benmachine: Yep, I note that most people use spaces but I just can't live with it. I've noticed that it's fairly easy to use tabs though :)
12:41:54 <JHoglund> benmachine: I believe I've learned the tricks to keep ghc happy with tabs :)
12:42:09 <benmachine> JHoglund: well, it's up to you I guess :P but you will find that people go "eww, tabs" when they look at your code >_>
12:42:17 <mauke> not me
12:42:18 <ezyang> eww tabs 
12:42:23 <ddarius> JHoglund: It's not GHC that's the problem usually.
12:42:28 <ezyang> I think every editor should be required to visually distinguish tabs and spaces. 
12:42:41 <benmachine> JHoglund: the code itself is pretty okay though
12:42:52 <JHoglund> ezyang: Could you come up with a good penalty for those breaking the law? :)
12:43:17 <JHoglund> benmachine: Thanks! It feels good to hear, I've spent a few hours too much oni it, so I start to get a bit confused :)
12:44:11 <Palmik> Pissed myself after reading about cabal and haddock, they are so sweet :) 
12:45:28 <sdf> palmik: really?
12:45:34 <Palmik> no
12:45:43 <JHoglund> benmachine: Oh, by the way, would it help if you got access to the complete file, including the datatypes for Mul, Add and so?
12:45:47 <Palmik> but they really are sweet :P
12:46:32 <benmachine> JHoglund: nah, not really
12:48:45 <benmachine> JHoglund: I tend to prefer explicit pattern matching to head and tail; your code gets upset if 'parsed' is an empty list
12:49:09 <benmachine> JHoglund: also in things like head (snd (head parsed)) it's hard to work out what that means in terms of your data structures
12:49:43 <danharaj> why isn't head total :|
12:49:46 <benmachine> JHoglund: and you also bind tail (snd (head parsed)) to something; you could combine those into operator : junk = snd (head parsed)
12:50:12 <benmachine> danharaj: you mean, why isn't it listToMaybe?
12:50:16 <JHoglund> benmachine: There's a protection for the first issue, "if length parsed > 0". The reason to many of head/fst/snd stuff is the rather clumsy return from parsed
12:50:29 <danharaj> yes. [a] -> 1 + a is the natural type for head.
12:50:51 <copumpkin> if you're going to write 1 + a
12:50:53 <benmachine> danharaj: we already have listToMaybe though :P
12:51:15 <benmachine> JHoglund: I think it would be neater if you used case to pattern-match on reads s directly
12:51:37 <copumpkin> you should write (1 + a)^(mu x. 1 + a * x)
12:51:43 <JHoglund> benmachine: Ah, I think I grasp the idea of operator : junk, what a neat construction! :D
12:51:57 <benmachine> JHoglund: explicit pattern matching = good for readability :)
12:52:16 <danharaj> copumpkin: just to be even more obtuse? :p
12:52:22 <copumpkin> danharaj: might as well :)
12:52:28 <copumpkin> so the question now becomes
12:52:33 <copumpkin> what makes a Real Haskeller(TM)?
12:52:34 <JHoglund> benmachine: I'm not really sure how to pattern match on return values from stuff carried out inside functions, or even sub-functions. Could you show me?
12:52:50 <benmachine> JHoglund: that is what case is for; one sec and I'll show you something
12:53:38 <xplat> i'd start that as 'myParser prec str = parseSymbol prec $ reads str where { parseSymbol :: Int -> [(Double, String)] -> WhateverYourMathTypeIsCalled; parseSymbol _ [] = error "cannot parse (does not begin with number)"; parseSymbol p [(n, s)] = ...; parseSymbol _ _ = error "can't happen: number matched ambiguously"; ... }
12:54:30 <JHoglund> xplat: Wow, I dont get much of that :)
12:56:24 <xplat> try writing it out in your editor with indentation instead of {;}, makes it easier to read
12:56:59 <JHoglund> xplat: Just did ;) What's this line suppoed to do? parseSymbol p [(n,s)] =
12:57:36 <xplat> that defines what parseSymbol does when it receives as argument a list containing a single pair
12:58:27 <xplat> it also binds the first element of the pair to the name n and the second element of the pair to the name s on the right side of the =
12:58:48 <xplat> you can use them just like regular arguments
12:58:51 <JHoglund> I'm starting to get a grip on what you're thinking!
12:59:54 <JHoglund> xplat: Is there a reason to why you're passing "prec" as an argument, which you call "p" later on. One could just omitt that, and access "prec" from within parseSymbol?
13:01:24 <xplat> i was just doing that to be more clear what parseSymbol is supposed to do since i didn't write a body for it, but yeah you can just access 'prec' and that is perfectly good practice
13:03:40 <benmachine> JHoglund: http://hpaste.org/paste/40478/using_case#p40480 this code implements your algorithm using case, more or less, tell me if there's anything you don't understand about it
13:04:14 <benmachine> JHoglund: imo this way is much more clear than using fst/snd/head/tail
13:04:50 <benmachine> JHoglund: I also did a weird lookup thing for precedence, but you can ignore that if you like; it's just making the error more explicit
13:05:13 <JHoglund> benmachine: It's indeed more compact, the if-structure was a bit easier for me to comprehend, though. I'll spend a few minutes trying to figure it out, is it OK if I query you later on?
13:05:40 <benmachine> JHoglund: I should really be doing work and/or a million other things
13:06:08 <benmachine> JHoglund: I'd advise continuing to ask the channel
13:06:13 <JHoglund> benmachine: Ah, ok, you better focus on that! Thanks for helping me out!
13:06:18 <benmachine> np :)
13:07:25 <deech> Hi all, is there a proposal for adding named arguments to GHC?
13:07:32 <lispy> hey guys
13:07:36 <lispy> How's code?
13:07:42 <xplat> deech: HList :)
13:07:55 <ezyang> deech: Use a record! 
13:08:00 <deech> Don't know too much about it.
13:08:31 <deech> ezyang: Yeah, I was thinking about that. But then I've looking in to Smalltalk and felt a small pang of envy.
13:08:31 <JHoglund> benmachine: THere's an "op" at line #12 in your paste, however I don't find op as a standard Haskell function, nor can I see any definition of it in the code?
13:08:59 <benmachine> JHoglund: oh whoops, I forgot about that bit
13:09:18 <benmachine> JHoglund: op = case operator of '+' -> Add; '*' -> Mul
13:09:27 <benmachine> JHoglund: or you can do the lookup-trick
13:09:35 * benmachine unnnecessary hyphens
13:09:44 <deech> xplat: I've heard legends of HList, are there any good tutorials around?
13:09:45 <xplat> i doubt haskell will ever have native named arguments, but it might get structural record types which would be about as good
13:09:47 * benmachine unnecessary n's
13:10:29 <deech> Is there some reason this will never happen? Is it a bad idea, or some reason it can't be implemented (partial functions maybe?)
13:10:36 <JHoglund> benmachine: Oh, well, you see, the original problem was that I wanted to store the result from that construction. Would it be OK to say: this_expr = | precedence >= p -> (Add (Num number) innerExpr, innerJunk)
13:10:46 <xplat> deech: HList i know mainly from the papers i found on CiteSeer (now citeseerx)
13:11:10 <benmachine> JHoglund: thisExpr | precedence >= p = (Add (Num number)  innerExpr, innerJunk)
13:11:28 <benmachine> JHoglund: then you need | otherwise = -- if precedence < p
13:11:51 <JHoglund> benmachine: You know what, I think you'll better get back to what you where doing. I'll be gratefull for your help and I'll ask the assistants in school tomorrow to give me some hands-on guidiance!
13:11:56 <Palmik> Hmm... let's say I have /Something/A.hs where A.hs has module Something.A and /Something/B.hs where B.hs has module Something.B ... how would I import Something.B to Something.A?
13:12:09 <benmachine> JHoglund: thanks for saving me from myself :P
13:12:16 <ezyang> Palmik: import Something.B 
13:12:24 <xplat> deech: the reason named arguments won't happen is it complicates the type system and execution model a lot.  haskell depends a lot on the idea that a function with two arguments is indistinguishable from a function returning a function of one argument
13:12:27 <ezyang> Palmik: Watch your cwd. 
13:12:48 <xplat> named arguments don't play very well with that
13:12:50 <Palmik> ezyang, ghc then says that it could not find Something.B
13:12:53 <deech> xplat: yeah so partial functions complicate the issue. 
13:12:59 <deech> xplat: makes a lot of sense.
13:13:01 <ezyang> Palmik: What's your cwd? 
13:13:13 <ezyang> you need to be in the parent directory of Something/  
13:13:30 <Palmik> I see, will try that :)
13:14:41 <Palmik> ezyang, right, thanks, works as a charm :)
13:15:01 <ezyang> Palmik: At this point, it's worth lookingi nto Cabal. 
13:15:08 <deech> Another question - is there a way in GHC to import all modules in a certain hierarchy? something like "import Control.Monad.*"
13:15:48 <xplat> that would get messy pretty fast ...
13:15:49 <Palmik> ezyang, ok, I'm going to :) Thanks
13:15:57 <nlogax> you can make a module that re-exports all the stuff you want, i think
13:16:49 <xplat> also, if you could import Control.Monad.* the effect would depend nondeterministically on what modules you had installed with no way to tell what you expected
13:17:07 <xplat> to some extent this happens when importing a module anyway, but at least it's more controllable
13:17:08 <deech> Yeah, but it sure would be convenient. Either that or a feature in GHCI that  tells me which modules define a certain function or datatype.
13:17:28 <nlogax> deech: :i thing
13:17:33 <xplat> since a single module is not an 'open' namespace the way a subtree of the module hierarchy is
13:18:40 <deech> nlogax: The module has to be imported for that to work. For example I'd like to know which module defines "runWriterT".
13:18:50 <donri> @hoogle runWriterT
13:18:50 <lambdabot> Control.Monad.Writer.Lazy runWriterT :: WriterT w m a -> m (a, w)
13:18:50 <lambdabot> Control.Monad.Writer.Strict runWriterT :: WriterT w m a -> m (a, w)
13:18:59 <nlogax> deech: oh. yeah, you could add hoogle to your ghci
13:19:21 <xplat> hoogle also has a website, a library, and an installable command line tool
13:19:45 <xplat> whichever you find most convenient
13:19:48 <nlogax> deech: cabal install hoogle, and in your .ghci file: :def hoogle \x -> return $ ":!hoogle --count=10 " ++ show x
13:19:49 <identity> Yay for improvement; writing code and hlint can't suggest any changes
13:19:56 <nlogax> dunno if that is right but it seems to work :)
13:20:03 <identity> nlogax: Wow, that's possible?
13:20:28 <nlogax> identity: yeppp
13:20:33 <identity> Wicked
13:20:35 <identity> I'm doing that
13:20:35 <deech> xplat: does the command line tool index my local libraries too? Or does it just hit the web for all searches?
13:21:08 <xplat> hm, i'm not sure there's what you call a 'hoogle desktop'
13:21:22 <benmachine> deech: the hoogle command line tool doesn't contact the web at all
13:24:09 <identity> benmachine: What is hoogle doing, exactly?
13:24:21 <benmachine> reading an index that is somewhere
13:24:29 <benmachine> which is a long way of saying, I dunno
13:24:55 <identity> So it comes with a small database from parsing the source or some such?
13:24:59 <identity> Meh
13:25:02 <identity> it's still cool stuff
13:26:21 <deech> benmachine: I just installed it, it doesn't seem to index my ".cabal" directory or anything like that. I think it comes with it's own database. 
13:26:28 <deech> Still really useful.
13:26:31 <benmachine> deech: possibly, I dunno
13:26:37 <xplat> does leksah have the ability to let you search for and autoimport functions like java ides do?
13:26:41 <nlogax> check --help
13:26:46 <benmachine> deech: see also: cabal haddock --help
13:26:53 <benmachine>     --hoogle               Generate a hoogle database
13:28:16 <bss03> Is there a good way to "sum" the results of multiple program runs with the profiler on?
13:29:05 <mwc> bss03: could you do something like main = sequence_ . replicate 20 $ main' ?
13:29:07 <deech> xplat: leksah actually trawls your .cabal directory, I'd love to know how it does that.
13:29:12 <bss03> One run of my program is generally short -- 2-3 minutes at most -- but, I have a lot of test cases.
13:29:28 <bss03> I'd like to run across all the test cases, and sum the profiler resutls.
13:29:48 <mwc> bss03: you could create a program that runs all your test cases
13:30:36 <mwc> see if the test-framework package is helpful
13:30:43 <bss03> That's difficult.
13:31:13 <bss03> Part of running the test case is using a Java program I don't have the source for...
13:31:34 <mwc> you can't make a unit test that simply executes it?
13:31:35 <dark> <Philippa> dark: eh, most of this stuff's esoterica that you don't actually need to know for the most part and would apply if you tried to do something similarly smart-arsed in an OO lang
13:31:43 <dark> (esoterica like corners of type system)
13:31:49 <mwc> what precisely are these "tests?" Unit tests?
13:31:58 <mwc> or are they runs of your program on test data suites?
13:32:00 <dark> but I want to learn more of FP exactly to know more about this kind of thing
13:32:04 <dark> it's fun =)
13:32:31 <dark> (the discussion was yesterday, about the type of y combinator and other things)
13:33:02 <lispy> (a -> a) -> a
13:33:04 <bss03> Not unit tests, example starting inputs.
13:33:06 <lispy> that type?
13:33:48 <bss03> The program I don't have the source for, generates new inputs based on the program's output and loops like that.
13:34:13 <dark> lispy, the y combinator itself isn't typeable in haskell :( or at least the one from the lambda expression
13:34:18 <bss03> Sort of a client-server relationship.
13:34:46 <dark> :t \f -> (\x -> f $ x x) (\x -> f $ x x)
13:34:48 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> a
13:34:48 <lambdabot>     Probable cause: `x' is applied to too many arguments
13:34:48 <lambdabot>     In the second argument of `($)', namely `x x'
13:34:48 <mwc> bss03: so it's not possible to create a main program that does this: main = forM_ [data1, data2, ...] doTest?
13:34:50 <donri> cabal install tab completion is mad slow, what's up with that
13:34:57 <ddarius> Y is even more important in OO than FP.
13:35:02 <burp> http://downforeveryoneorjustme.com/code.haskell.org :/
13:35:13 <dark> ddarius, really?
13:35:17 <burp> haskell community servers have horrible uptimes
13:35:18 <bss03> mwc: It's possible, but difficult.
13:35:32 <mwc> bss03: couldn't you just fork it as an external program from your test driver, run it against your test data, then terminate it and restart it for the next run?
13:35:41 <bss03> mwc: I would have to either re-implement the Java program from the specification, or...
13:35:45 <mwc> ^
13:36:03 <ddarius> dark: Look up open recursion.
13:36:08 <bss03> mwc: Do exec() stuff in Haskell, which I've never done before.
13:36:18 <dark> ddarius, so maybe a "thoughful" OO language, like smalltalk, may be more appropriate for learning this kind of thing, instead of haskell and agda?
13:36:58 <mwc> bss03: System.Process makes it pretty easy
13:37:05 <bss03> mwc: Plus, I'm not sure the profiler would follow all the fork/exec stuff.
13:37:06 <A1kmm> I'm using GHC.resume to programatically step through a program - in the program, (error "some message") is called, and I get a match to RunException e from GHC.resume
13:37:11 <A1kmm> Anyone know how I can display e without re-raising the exception in the interpreter program?
13:37:18 <ddarius> dark: Actually, Smalltalk's (or better Self's) way of handling Booleans is almost exactly Church encoding.
13:37:31 <dark> hm. o.o
13:37:35 <bss03> mwc: In particular, the Java "server" I have expects to fork()/exec() the client program.
13:37:37 <mwc> bss03: you don't want it to, you fork off the java thing you're using as part of your test, but run your tests in the main haskell executable
13:37:47 <mwc> bss03: ah, then take it out back and shoot it :)
13:38:05 <mwc> you'll probably have to write a utility to merge profiling runs
13:38:13 <dark> so that the boolean itself can be used as a function to select between 2 possibilities?
13:39:08 <bss03> mwc: I could probably play around with fifos (I'm on Linux) to get the Java server to talk to the Haskell process already running, I think.
13:40:10 <ddarius> dark: Smalltalk doesn't have functions.  There's a class Boolean with method ifTrue:ifFalse: (if I remember the selector correctly) and two standard implementations (subclasses) True which just returns the first argument and False which returns the second.
13:40:11 <bss03> mwc: E.g. have the Java program fork()/exec() a script that is just "cat hsOutput.fifo < hsInput.fifo".
13:40:51 <mwc> bss03: could do
13:41:25 <bss03> mwc: Assuming I didn't do that.  Is there a way to get "machine-readble" output from the profiler?
13:41:53 <bss03> mwc: I.e. something easy to parse so I can do the merge easily, instead of reading to human-readable output?
13:42:01 <dcoutts> donri: it's trying to do too much, I've recently been sent a patch to simplify it
13:42:35 <donri> ACK
13:43:52 <xplat> ddarius: which of course means you can pass 'magic booleans' into anything that expects a boolean and cause wacky stuff to happen
13:44:35 <ddarius> xplat: It should mean that, but Smalltalk treats Boolean specially for efficiency's sake.  Self, with its better implementation technology, doesn't though, and you can indeed do exactly that.
13:45:10 <xplat> like a boolean that runs both branches of an if in sequence, or just ignores both branches and prints "ninja'd" or something
13:46:30 <ddarius> Yes.  This is one of the problems with Smalltalk.  Between dynamic typing and rampant subclassing the code and libraries have significant implicit assumptions that are completely unenforced.
13:47:11 <ddarius> Basically, it's LSP Strikes with a Vengeance.
13:47:29 <Philippa> as in goes on strike?
13:48:05 <ddarius> I forgot to add in the rampant mutation-oriented interfaces.
13:48:34 <xplat> yeah.  to enforce church-encoded booleans actually being church-encoded booleans (or even just church-encoded booleans or bottoms) you need both type enforcement and your choice of effect enforcement or purity
14:04:40 <deech> I have a question about the ~ in Haskell. The wikibook tells me that its used leave function arguments unevaluated when pattern matching. Why would I ever want to do this?
14:05:42 <sipa> i suppose it could be useful if you already know what kind of data it will contain, but don't want to have it evaluated yet
14:05:51 <imc> deech: (a,b) -> if prop a then something else somethingWith b
14:05:52 <mwc> deech: it basically assumes the match will succeed
14:05:59 <imc> (maybe?)
14:06:03 <Axman6> > let f ~(x,y) = x in f (5,undefined)
14:06:04 <lambdabot>   5
14:06:10 <Axman6> > let f (x,y) = x in f (5,undefined)
14:06:11 <lambdabot>   5
14:06:37 <Axman6> hmm, there is an example like that somewhere...
14:07:41 <deech> So if it's ever used in a function like f x y = ... , f x ~y = ... , f x 0 = ..., it will never get past the second clause? 
14:08:11 <sipa> it won't get to the second pattern either
14:08:47 <deech> sipa: you're right. Assume the first clause doesn't exist.
14:08:50 <xplat> there's no different between f y and f ~y if y is literally 'y'
14:08:54 <xplat> difference
14:09:17 <xplat> f y is not a head-strict match to begin with
14:09:28 <sipa> > let f ~(Just x) = x in f Nothing
14:09:29 <lambdabot>   *Exception: <interactive>:1:137-151: Irrefutable pattern failed for pattern...
14:09:40 <deech> My basic point was that pattern matching will never get past a clause that has a ~ in it. Is that correct?
14:09:52 <sipa> > let { f ~(Just x) = x; f Nothing = 0 } in f Nothing
14:09:54 <lambdabot>   *Exception: <interactive>:1:143-172: Irrefutable pattern failed for pattern...
14:09:57 <sipa> > let { f (Just x) = x; f Nothing = 0 } in f Nothing
14:09:58 <lambdabot>   0
14:10:14 <sipa> deech: a ~ match will always succeed
14:10:31 <xplat> deech: if you could replace ~something by _ and it would get past, it still will
14:11:23 <xplat> basically ~something matches anything a bare variable or a _ would, no matter how complex the 'something' is
14:11:30 <monochrom> think of it as subprime mortgage, default swap, etc.
14:12:11 <xplat> and then it may explode later if it wouldn't have matched without the ~
14:12:12 <deech> Oh, I understand. I'm just unclear on when I'd ever want to do this. The only two cases I can think of are that (1) the argument is never needed and so never needs to be evaluated and (2) you want to defer evaluation for performance reasons.
14:12:51 <monochrom> swap ~(x,y) = (y,x)  -- default swap :)
14:13:13 <mwc> monochrom: but isn't swap (x,y) = (y,x) exactly the same?
14:13:25 <xplat> no, the ~ version is non-strict
14:13:56 <monochrom> if you involve swap in some tie-the-knot thingy, ~ makes a difference, i.e., you likely need ~
14:13:57 <xplat> so you can pass a bottom through the ~-swap and as long as the result isn't used later it will work fine
14:13:59 <mwc> xplat: true, I'm used to worrying more about the arguments to a tuple than whether the tuple cell itself is non-bottom
14:14:53 <sipa> > > let swap ~(x,y) = (y,0) in snd $ swap undefined
14:14:54 <lambdabot>   <no location info>: parse error on input `>'
14:14:56 <sipa> > let swap ~(x,y) = (y,0) in snd $ swap undefined
14:14:57 <lambdabot>   0
14:15:00 <sipa> > let swap (x,y) = (y,0) in snd $ swap undefined
14:15:01 <lambdabot>   *Exception: Prelude.undefined
14:15:22 <xplat> it also satisfies more laws, like swap swap = id (up to raising different errors)
14:15:31 <xplat> er, swap . swap = id
14:15:41 <EvanR> why would you want to swap undefined?
14:16:30 <mwc> EvanR: it would come up when used with something like fix
14:16:55 <mwc> EvanR: which was what monochrom mentioned about a tie-the-knot thingy
14:17:03 <monochrom> fix (\~(e,o) -> ( (\n -> n==0 || o(n-1)), (\n -> e(n-1)) )  successfully gives you a pair of functions.  If you delete ~, it's doomed.
14:17:39 <mwc> monochrom: heh, nice example
14:17:53 <xplat> > let swap ~(x,y) = (y,x) in first (const 0) . swap . first (const 1) . swap $ undefined
14:17:54 <lambdabot>   (0,1)
14:18:35 <monochrom> credit default swap :)
14:18:55 <aristid> lol
14:19:32 <monochrom> "trust me! I promise you it is a tuple. don't look now! lest the whole system collapses"
14:20:35 <xplat> > let swap ~(x,y) = (y,x) in fix $ first (const 0) . swap
14:20:36 <Lemmih> dcoutts: Sacrebleu! That's a lot of patches.
14:20:37 <lambdabot>   (0,0)
14:20:46 <dcoutts> Lemmih: :-)
14:20:56 <xplat> > let swap (x,y) = (y,x) in fix $ first (const 0) . swap
14:20:58 <lambdabot>   (0,0)
14:21:01 <dcoutts> Lemmih: it's all of ttuegel's GSOC "cabal test" patches
14:21:16 <xplat> huh, i'm a little surprised that one worked
14:21:54 <xplat> > fst . first (const 0) $ undefined
14:21:55 <monochrom> so it is not so much "swap undefined" as "the tuple is available later, not now, so you don't want to seq it now"
14:21:56 <lambdabot>   0
14:22:01 <c_wraith> @src unzip
14:22:02 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
14:22:06 <c_wraith> that's also a good example
14:22:08 <xplat> ah, first is non-head-strict too
14:22:51 <xplat> monochrom: right
14:24:29 <xplat> it's occurred to me that the dual of a generic 'zip' should be called 'tip'
14:25:37 <xplat> tip :: (Tippable f) => f (Either a b) -> Either (f a) (f b)
14:26:16 <xplat> because it takes a suitably 'unbalanced' structure and lets it tip all the way to the Left or Right
14:28:58 <xplat> i think conal or somebody called it 'decide'
14:30:15 <ddarius> Formulate some properties/laws.
14:30:55 <xplat> i have to say that Maybe is a type constructor with some pretty nice properties.  it's not only a zippable monad but it's an (even more nicely) tippable comonad as well!
14:31:40 <xplat> well, maybe it's not 'more nicely' since you have to choose a side for Nothing arbitrarily :(
14:33:15 <ClaudiusMaximus> > Nothing < Just 42
14:33:16 <lambdabot>   True
14:36:12 <xplat> ddarius: generic zip gets its laws (seldom followed anyway) from the laws of a monoidal monad
14:38:49 <ddarius> xplat: The question is to formulate what the dual laws are and whether your suggested interpretation of tip satisfies them.
14:44:10 <c_wraith> hmm.  iterateM wouldn't be very useful, would it?
14:44:25 <c_wraith> Or rather, it'd only be useful for non-strict monads.
14:44:36 <c_wraith> err, where (>>=) is non-strict, to be exact
14:45:51 <tolkad> What would be the type signature for «f 0 = ""; f 1 = 1»? I want something like «forall a. Show a => Int -> a»
14:46:02 <tolkad> but that doesn't seem to work
14:46:14 <sipa> "" is of type String
14:46:28 <sipa> 1 can't be of type String
14:46:30 <tolkad> I want it to return an unknown type
14:46:36 <tolkad> like a different rank
14:46:37 <sinelaw> tolkad, the best you could do for something like that is Either String Int
14:46:53 <sinelaw> Int -> Either String Int
14:46:58 <tolkad> uh what about «Int -> (forall a. Show a => a)»?
14:47:08 <sinelaw> you can't have something that returns both a string and an int
14:47:17 <sinelaw> for the same type of input
14:47:32 <sinelaw> unless you use a sum-type like Either
14:47:46 <tolkad> sinelaw: I thought you could do something like that with rank 2 types?
14:47:52 <sipa> yes
14:48:02 <sipa> but i'm not sure your example is meaningful/possible
14:48:35 <sipa> you could have a Int -> (forall a. Show a => a -> b) -> b
14:48:59 <tolkad> oh
14:49:13 <sipa> and you pass it a function that takes things of any Show type
14:49:25 <danharaj> hmmm
14:49:27 <tolkad> why not just do what I did?
14:49:46 <danharaj> There seems to be a relationship between proofs about types and (co)equalizers.
14:50:32 <sipa> tolkad: i think that would require the Show dictionary of the return type to be returned as well
14:51:07 <xplat> tolkad: you'd need an explicit type signature to return something higher-rank like that
14:51:21 <sipa> yes
14:51:30 <sipa> but i wonder if it would work
14:51:32 * sipa tries
14:53:52 <danharaj> If you have equalizers in a cartesian closed category then you can construct subtypes that satisfy predicates, at least in a sense.
14:54:38 <sipa> tolkad: imagine your «Int -> (forall a. Show a => a)» is called foo, and you have 'main = print $ foo 0'
14:54:56 <sipa> somehow print needs to call the show function on the result of foo 0
14:55:54 <tolkad> heh, I see, I tried unsafeCoerce
14:56:00 <tolkad> but now I'm getting a bus error
14:56:09 <sipa> serves you right :)
14:56:23 <sipa> what type are you coercing it to?
14:56:23 <sinelaw> how is the compiler supposed to know which function to use?
14:56:39 <sipa> you don't know what type the result is
14:56:56 <tolkad> I coerced them to forall a. Show a => a
14:56:59 <sinelaw> do higher-rank types really allow these sort of things? i'm not very familiar with them
14:57:02 <xplat> i'm having no luck getting it to work
14:57:11 <tolkad> but then I had an ambiguous type when I tried to show
14:57:28 <tolkad> so I added a type annotation to string for the argument of show
14:57:43 <fizruk> :t unsafeCoerce
14:57:43 <lambdabot> Not in scope: `unsafeCoerce'
14:57:51 <sipa> so you're basically coercing an Int to a String
14:57:57 <sipa> and expect that it gets shown?
14:57:58 <tolkad> yeah
14:58:07 <xplat> that is ... unlikely
14:58:24 <tolkad> it worked, it just printed out "Bus error"
14:58:28 <sipa> haha
14:58:51 <xplat> unsafeCoercing a monotype to a polytype won't work because they have different representations
14:59:20 <sipa> can you even coerce to a polytype?
14:59:38 <danharaj> you can coerce to anything
14:59:45 <sipa> to anything defined, yes
14:59:57 <danharaj> it's unsafeCoerce it breaks types systems and doesn't afraid of anything
15:00:07 <sipa> but unsafeCoerce has type a -> b
15:00:16 <sipa> a and b still need to be concrete types
15:00:45 <danharaj> If you enable some extensions can't you instantiate to a polymorphic type?
15:00:53 <sipa> maybe, not sure
15:00:57 <danharaj> impredicativity perhaps?
15:01:05 <sipa> yes, could be
15:01:06 <xplat> you probably need at least ExistentialTypes
15:01:13 <xplat> and maybe that, yes
15:01:14 <kmc> wow
15:01:19 <kmc> everyone's throwing around extensions
15:01:22 <monochrom> there are easier ways to print "Bus error".
15:01:30 <benmachine> you could probably instantiate it to a normal polymorphic type
15:01:36 <kmc> tolkad's example needs existentials
15:01:40 <benmachine> just like 'const x undefined' isn't an error
15:01:57 <benmachine> you can't instantiate it to a class-constrained polymorphic type because that's ambiguous
15:02:09 <kmc> "<xplat> unsafeCoercing a monotype to a polytype won't work because they have different representations"
15:02:13 <kmc> that's not strictly true
15:02:42 <kmc> it depends on the situation
15:02:51 <xplat> an existential type with a class bound carries its dictionary with it
15:03:01 <kmc> coercing [T] to (forall a. [a]) is probably fine
15:03:13 <kmc> wait no
15:03:18 <kmc> to exists a. [a]
15:04:07 <benmachine> you could probably convert any list to any other so long as you subsequently ignored the contents of the list
15:04:10 <kmc> the class context changes things, yes
15:04:32 <kmc> GHC says it's fine to coerce [S] to [T] so long as the input list is empty
15:04:40 <tommd> Could I get a Windows user to test something for me?
15:04:40 <tommd> cabal update ; cabal install crypto-api ; ghc -e "main = System.Crypto.Random.getEntropy 16 >>= print
15:04:48 <kmc> so presumably it's ok to coerce an empty [S] to (forall a. [a])
15:04:51 <danharaj> well that makes sense because [] has type forall a. [a]
15:06:14 <xplat> danharaj: theoretically a haskell implementation could specialize some generics, in which case the representation of [] could change if it were known to be called at a specific type
15:06:20 <tommd> If it isn't obvious, I ment to say: ghc -e 'System.Crypto.Random.getEntropy 16 >>= print'
15:06:34 <tommd> Any windows users want to help their platform?
15:07:04 <sipa> and if you use unsafeCoerce, i suppose you have no guarantees at all
15:07:34 <tommd> No more guarantees than C.
15:07:35 <sipa> or does the haskell standard say anything about representations?
15:07:44 <kmc> the GHC manual gives some guarantees about unsafeCoerce
15:07:47 <tommd> Oh, wrt portability?
15:07:58 <kmc> unsafeCoerce is not in the standard so no, there are no guarantees
15:08:13 <mwc> I think it's implied in the report that newtype'd types "share the same underlying representation"
15:08:19 <sipa> mwc: true
15:08:26 <mwc> but that doesn't actually mean you can unsafeCoerce them
15:08:46 <kmc> C makes some guarantees about casting which, while much narrower than the C code people actually write, are far more than the Haskell standards say
15:09:06 <mwc> and at anyrate, newtype Foo = Foo { unFoo :: Bar } leaves Foo and unFoo as identity functions as far as the code gen is concerned
15:09:09 <tolkad> kmc: I tried using exists, but it says "Illegal symbol '.' in type Perhaps you intended -XRankNTypes or similar flag" but I HAVE enabled -XRankNTypes
15:09:14 <mwc> so there's no need to unsafeCoerce newtypes
15:09:19 <kmc> tolkad, the "exists" syntax is not supported by GHC
15:09:33 <kmc> tolkad, «data Showable = forall a. (Show a) => Showable a»
15:09:34 <mwc> that is, Foo and unFoo do nothing but move types
15:09:36 <sipa> but a cast is (or at least can be) a convertion between types
15:09:39 <kmc> f 0 = Showable "foo"
15:09:42 <kmc> f 1 = Showable 1
15:09:52 <kmc> tolkad, of course you might as well return String directly
15:10:05 <kmc> an existential over Show is boring, compared to other existentials
15:10:11 <kmc> (and they needn't always be with type classes)
15:10:37 <xplat> all of the GHC ways to do existential types eschew the actual existential quantifier and instead encode it with universal quantifiers in negative position
15:11:31 <tolkad> kmc: that gives me an error when I try to put them into showable
15:11:42 <tolkad> Couldn't match expected type `a' against inferred type `Int'
15:12:01 <tolkad> oh wait
15:12:05 <tolkad> I put the forall in the wrong place
15:12:20 <kmc> yep
15:12:25 <tolkad> ah, thanks
15:14:03 <tolkad> so to return a rank 2 type you need a wrapper
15:14:39 <tolkad> I understand them now :P
15:14:53 <tolkad> a little bit
15:15:43 <kmc> no, to return an existential you need a wrapper
15:16:29 <xplat> rank 2 types are a little weirder
15:16:43 <danharaj> god dammit. I searched 'power object' and got some hippy voodoo neopagan stuff instead of category theory :[
15:16:46 <kmc> to return a rank-2 type you just need Rank2Types or RankNTypes enabled
15:16:50 <xplat> actually the suggested rank 2 type turned out to mean something else.
15:17:17 <kmc> if f returns a rank-2 type then f's type is at least rank 2, but not necessarily higher
15:18:08 <xplat> foo :: Int -> (forall a. Show a => a) means that foo must take an Int and return any showable type you want
15:18:37 <xplat> you could actually Lambda-lift the quantifier right up to the top level and have a regular rank-1 polymorphic type
15:18:46 <kmc> but that's the same as «foo :: (Show a) ⇒ Int → a»
15:18:50 <kmc> yeah
15:19:04 <kmc> but that's not a function returning a rank-2 type
15:19:10 <kmc> even before you lift it
15:21:35 <ppavelV6> hmm... Is it possible to write runSTInIO :: IO (ST s a) -> IO a without deprecated impredicative types?
15:22:25 <kmc> :t fmap runST
15:22:26 <lambdabot> forall a (f :: * -> *). (Functor f) => f (forall s. ST s a) -> f a
15:22:33 <kmc> interesting, that's impredicative
15:22:43 <pumpkin> ppavelV6: why do you need the input in IO?
15:22:48 <pumpkin> :t return . runST
15:22:49 <lambdabot> forall a (m :: * -> *). (Monad m) => (forall s. ST s a) -> m a
15:23:19 <kmc> ppavelV6, you can always eliminate the need for impredicative types by introducing a wrapper type
15:23:30 <pumpkin> you could also go for the sketchier (forall s. IO (ST s a)) -> IO a
15:23:35 <ppavelV6> i mean is it possible to construct values in ST in IO and then execute them? ok, IO is a special case and i can resort to ST RealWorld, but let's pretend it's arbitrary monad
15:23:52 <pumpkin> @hackage primitive
15:23:53 <lambdabot> http://hackage.haskell.org/package/primitive
15:24:14 <ppavelV6> pumpkin: because to construct the action i need values only available in io
15:24:25 <ppavelV6> kmc, yep, but i'm stuck :))
15:24:32 <pumpkin> ppavelV6: and you can't run them? :O
15:24:42 <pumpkin> it's pretty rare to see IO as an input
15:24:43 <kmc> ppavelV6, does this work:  do { x ← constructMySTValue; return (runST x) }
15:24:51 <pumpkin> forkIO/OS is pretty much the only such case I know of
15:24:57 <pumpkin> and it's legit there
15:24:58 <kmc> pumpkin, there's tons of use cases ;P
15:25:02 <pumpkin> :(
15:25:09 <pumpkin> any time you want to defer it
15:25:11 <pumpkin> but why here?
15:25:16 <kmc> i agree it's odd here
15:25:26 <kmc> but it seems that (>>=) might not like the impredicative type
15:25:28 <kmc> anyway
15:25:45 <kmc> ppavelV6, the wrapper you need is: «data RST a = RST (forall s. ST s a)»
15:25:45 <ppavelV6> kmc, actually i tried to construct something like ReaderT a (ST s) ()
15:25:50 <pumpkin> any, as far as I know the ImpredicativeTypes are undeprecated anyway
15:25:59 <danharaj> undeprecated?
15:26:03 <danharaj> like 'jk these are ok again'?
15:26:05 <kmc> then you can write «runRSTinIO :: IO (RST a) → IO a»
15:26:12 <kmc> without ImpredicativeTypes
15:26:13 <pumpkin> I noticed a subtle commit on cvs-ghc from SPJ saying it was not anymore
15:26:14 <pumpkin> but I dunno
15:26:24 <pumpkin> haven't heard any official word on it
15:26:37 <ppavelV6> kmc, ok, I'll give it a try... thank you. It was a mistake to ask at 2:25AM :)))
15:27:18 <pumpkin> september 23
15:27:58 <kmc> tolkad, xplat: http://hpaste.org/40481/returning_a_rank2_type
15:28:13 <kmc> no wrapper needed
15:29:06 <pumpkin> http://snapplr.com/pta9
15:29:08 <ppavelV6> thanks kmc. I realized that I asked the question and can't follow the answers :) Too late for me. Sorry for that:) I'm taking notes and will look at it tomorrow.
15:29:09 <pumpkin> that's what I'm talking about
15:29:14 <pumpkin> ppavelV6, kmc
15:29:23 <kmc> actually i meant g :: Int → ((∀ a. [a]) → Char)
15:30:44 <ppavelV6> ok, i see the patch from SPJ. Thanks
15:30:48 <ppavelV6> bye.
15:30:54 <xplat> kmc: yeah, i wondered about that
15:31:06 <kmc> g's type is conceptually a subtype of f's type
15:31:12 <kmc> (it takes a moment to convince yourself of this)
15:31:19 <kmc> but GHC's instantiation is too weak to capture this
15:31:29 <kmc> which is why the definition of g is eta-expanded; we can't simply write "g = f"
15:32:17 <kmc> (it typechecks with either ∀ a. [a] or ∀a. a, but in the latter case (g x y) is always ⊥)
15:33:41 <xplat> well in that case the argument is always ⊥.
15:33:54 <kmc> yes, and it's strict
15:33:58 <xplat> right
15:34:08 <xplat> always checks if y is [] or not
15:35:27 <zong_sharo> if i don't like haskelldb nor persistent nor plain old interfaces like hsql
15:35:37 <zong_sharo> does any vitable options left for me?
15:35:50 <zong_sharo> except writing own stuff ofc
15:36:06 <xplat> the one that has the japanese name i can never remember
15:36:41 <lispy> zong_sharo: takusen
15:37:15 <zong_sharo> does it alive?
15:37:22 <lispy> yeah
15:37:27 <xplat> (i normally remember japanese words pretty well too!)
15:37:37 <lispy> zong_sharo: http://www.haskell.org/pipermail/haskell-cafe/2010-July/081224.html
15:37:47 <Raevel> zong_sharo: macid?
15:37:51 <lispy> xplat: takusen is japanese for oracle, does that help?
15:38:12 <lispy> zong_sharo: http://projects.haskell.org/takusen/
15:38:13 <xplat> heh, that kinda does
15:38:22 <lispy> zong_sharo: http://blog.codersbase.com/2010/08/takusen-tutorial-part-1-hello-takusen.html
15:38:30 <zong_sharo> last time i checked it was orpan, with some compilation issues against modern ghc
15:38:45 <zong_sharo> good to know it fixed now
15:39:55 <zong_sharo> Raevel: i had an impresion that macid is strongly tied to happstack, i'm right?
15:39:57 <lispy> zong_sharo: I'm current maintainer.  If you have some problem, let me know.  there is also #takusen, and a mailing list
15:40:33 <lispy> zong_sharo: mailing list: http://projects.haskell.org/cgi-bin/mailman/listinfo/takusen
15:40:51 <Raevel> zong_sharo: not sure... i'd imagine you can use it standalone fairly easily
15:41:24 <zong_sharo> lispy: can you point me to tutorial or something?
15:41:38 <lispy> zong_sharo: http://blog.codersbase.com/2010/08/takusen-tutorial-part-1-hello-takusen.html
15:41:56 <lispy> zong_sharo: http://hackage.haskell.org/packages/archive/Takusen/0.8.6/doc/html/Database-Enumerator.html
15:42:22 <lispy> zong_sharo: Someone here started writing a tutorial so I stopped, but I guess he never posted it
15:43:01 <dark> lispy, I installed takusen because hdbc is broken at gentoo-haskell. But it seemed complex for me to use, since I'm ignorant in both haskell and sql. so I'm using PG'OCaml right now
15:43:33 <lispy> dark: thanks for the feedback.  It was suggested that we make a hdbc 
15:43:35 <lispy> er
15:43:40 <dark> but will try takusen someday. (is postgres non-standard features well supported?)
15:43:48 <lispy> dark: thanks for the feedback.  It was suggested that we make a hdbc-like compatibility module for Takusen.  Would that have been easier to use?
15:44:12 <lispy> dark: Hmm...Which non-standard features?  Things like subtables?
15:44:18 <dark> lispy, I don't think so, I don't know both. (But to be honest the main issue is that I didn't found a good, newbie-proof tutorial)
15:44:20 <lispy> or subtype tables or whatever they're called?
15:44:34 <dark> things like its locking mode.. arrays.. lots of things
15:44:59 <lispy> dark: oh I see.  Did you read part 1 of the hello, takusen tutorial on my blog?  It's not much.  But, it should at least check that you've installed everything correctly
15:45:27 <lispy> dark: I've never used those features.  I'm not sure if they are supported.
15:45:48 <dark> I installed and did a test query following a basic tutorial at web, maybe it was your blog
15:46:18 <lispy> dark: Until someone finishes my tutorial series, you may find the best feedback on the takusen mailing list.  The original author, previous maintainer, and myself are all on the list and can offer help
15:46:31 <dark> interesting:)
15:46:37 <dark> also, PG'OCaml works by a) checking the database layout at compile time, in order to do stronger type-check, b) not letting postgres plan again the same queries N times (postgres plan the query the first time we use, then it caches). It's cool features
15:47:14 <lispy> There are haskell libraries that can do static stuff against the database too.  I'm not sure how that replanning thing works
15:47:30 <xplat> what happens if the database layout is different at compile time and runtime?
15:47:45 <lispy> Takusen needs to be refactored to be a set of bindings to databases + haskell friendly front ends
15:47:51 <dark> the caching works by doing something pg-specific; and the database checking works by connecting to it during compilation. (it is smart enough to know that the correct type of a nullable attribute is an option, kind of a maybe)
15:48:12 <xplat> lispy: the planning thing works by using the 'prepare' and 'execute' statements, or sometimes driver-specific equivalents
15:48:14 <lispy> Takusen understands nullables too via Maybe
15:48:20 <dark> xplat, it fails to compile
15:48:31 <dark> xplat, but you can also drop the tables and rebuild them, at compile time
15:48:38 <lispy> oh, you can do the prepare and execute stuff in Takusen but you have to request it
15:48:49 <xplat> dark: how can it fail to compile if you already compiled?
15:48:50 <lispy> (it doesn't just automatically do it)
15:49:09 <dark> xplat, the database is connected during compilation
15:49:12 <xplat> does it recompile itself every time you run it?
15:49:13 <dark> it's a macro system
15:49:17 <dark> no..
15:49:25 <dark> it can fail at runtime if you change the database
15:49:31 <dark> with a catchable exception
15:49:49 <dark> my toy program has make destroy to dump the current database and rebuild it (and compile everything), and just make to compile without rebuilding
15:49:52 <zong_sharo> lispy: takusen just offers left-fold, queries are the same plain old strings, i'm right?
15:50:17 <dark> I am still to build some migration thing.. or I will just reuse the one used by rails people
15:51:10 <dark> the fold thing is very nice, since my queries currently return a list of tuples that I then fold to build my structure..
15:51:20 <xplat> the whole thing that attracted me to takusen was the left-fold stuff, really
15:52:36 <zong_sharo> well, i'm mostly looking for alternative to "queries in strings"
15:53:24 <kmc> queries in ByteStrings!
15:53:25 * kmc ducks
15:53:37 * xplat shoots kmc's ducks
15:53:40 <zong_sharo> because it out of scope of typecher then
15:54:16 <lispy> zong_sharo: queries are anything that can be converted to strings
15:54:37 <lispy> zong_sharo: So you can actually use a special algebraic type that ensures correct queries if you also write a Show instance
15:54:47 <lispy> zong_sharo: but it doesn't provide one for you
15:55:02 <xplat> i'm not sure overloading Show for that, in particular, was a great idea
15:55:03 <zong_sharo> well, actually i'm looking for something like haskelldb, but with less type-madness and better docs
15:55:24 <dark> but overloading show for that means you can print the query for debug..
15:55:38 <xplat> zong_sharo: so more type-madness than takusen but less than haskelldb?
15:55:49 <zong_sharo> sort of
15:55:56 <dark> zong_sharo, type-madness?
15:55:59 <lispy> takusen has functional dependency madness
15:56:06 <zong_sharo> issue that haskelldb address is revelant to me
15:56:24 <xplat> dark: it means you can skip one function name and a $ when printing the query for debug
15:56:49 <xplat> but means you can't print the structure underlying the query for debug at all
15:57:02 <zong_sharo> but haskelldb is not, at least for now
15:57:06 <xplat> can get around it pretty well by making the instance for a newtype, but still ...
15:59:36 <zong_sharo> lispy: it's not that i mean, haskelldb made a homebrew replacement of trex system, which is pain to handle
15:59:55 <dark> PG'OCaml does type-checked queries, but using a string syntax, like let f db c d = PGSQL(db) "insert a into b values ($c, $d)", and also does not let one compose queries from fragments. this disturbs me, would like to see some system that goes past that
16:00:02 <zong_sharo> not to mention enormous codebase size
16:00:31 <xplat> zong_sharo: historical reasons.  trex is not widely available, none of the OTHER commonly used homebrew record systems were out yet afaik ...
16:00:32 * hackagebot random-extras 0.18.1 - Additional functions for random values.  http://hackage.haskell.org/package/random-extras-0.18.1 (AristidBreitkreuz)
16:01:03 <lispy> zong_sharo: my guess is that you want queries which are syntactically correct by construction and if at all possible, type correct
16:01:14 <zong_sharo> xplat: well, i'm aware of this reasons, i read original haskelldb paper and most of the docs from original site
16:01:26 <lispy> zong_sharo: You could build that as a library separate from Takusen (and possibly other database libraries) and then use it with them
16:01:37 <zong_sharo> xplat: but understanding of this reasons does not helps much
16:02:01 <zong_sharo> lispy: well, back to "write own stuff"
16:02:12 <zong_sharo> kinda predictable
16:02:20 <zong_sharo> lispy: thank you for considering me anyway
16:02:31 <xplat> zong_sharo: well, at least you just have to write the part that you care about
16:02:33 <lispy> zong_sharo: yes, then release that on hackage and others benefit.  Others can help.  And it can work with all the db libraries :)
16:08:21 <donri> alias hgl='hoogle --c=True --n=$(expr $LINES - 1)'
16:18:15 <xplat> i sort of wish i had a polycategorical programming language where things like categories were kind-classes
16:18:37 * hackagebot filemanip 0.3.5.0 - Expressive file and directory manipulation for Haskell.  http://hackage.haskell.org/package/filemanip-0.3.5.0 (BryanOSullivan)
16:20:05 <xplat> and the basic type-constructors behind algebraic and other types were overloaded on kinds
16:20:36 <xplat> like sum, product, functionspace
16:21:38 * hackagebot FileManip 0.3.3.1 - Expressive file and directory manipulation for Haskell.  http://hackage.haskell.org/package/FileManip-0.3.3.1 (BryanOSullivan)
16:21:54 <xplat> kind of would need separate function arrows for internal and external homs, though, probably
16:26:22 <tolkad> For many other languages you can find descriptions of good practices and conventions, is there any such compiled information available for haskell?
16:27:10 <cozachk> readability is highly value by most haskellers
16:27:18 <cozachk> valued*
16:27:51 <pumpkin> for code style, you could try: http://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
16:28:04 <tolkad> thanks
16:29:43 <Peaker> cozachk: So why do so many of them use open unqualified imports? :(
16:29:54 <Peaker> those are easy on the writer, very hard on the reader..
16:30:02 <dark> Peaker, laziness is also valued
16:30:20 <dark> (couldn't resist)
16:30:25 <Peaker> I wish open unqualified imports were just banned
16:30:49 <Peaker> that ghc required --quickanddirty to compile code with them
16:31:13 <sinelaw> hindley-milner + TC = haskell 98?
16:31:35 * cozachk roughly came to the conclusion the other week as well
16:31:44 <cozachk> if by tc you mean theorectical comp sci 
16:31:45 <xplat> sinelaw: modulo syntax and a few other quibbles
16:32:01 <sinelaw> xplat, what syntax?
16:32:11 <fizruk> Peaker: what is open import?
16:32:20 <Pseudonym> Constructor classes are not technically the same as type classes.
16:32:21 <aristid> Peaker: operators from qualified imports are ugly
16:32:32 <Peaker> aristid: then use closed-unqualified
16:32:44 <xplat> sinelaw: i mean that haskell's syntax is a nontrivial part of what makes it haskell
16:32:46 <Peaker> fizruk: "import Data.Function"
16:32:49 <Peaker> @type let f x 0 = x ; f x n = f (x, x) (n - 1) in f
16:32:50 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, t)
16:32:51 <lambdabot>       Expected type: (t, t) -> t1 -> t
16:32:51 <lambdabot>       Inferred type: t -> t1 -> t
16:33:14 <sinelaw> i was suspecting something fishy there
16:33:33 <Peaker> @type let f :: a -> Int -> a ; f x 0 = x ; f x n = f (x, x) (n - 1) in f
16:33:34 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, a)
16:33:34 <lambdabot>     When generalising the type(s) for `f'
16:33:34 <lambdabot>     In the expression:
16:33:37 <sinelaw> Peaker, do you mean higher-order types?
16:33:39 <sinelaw> rank
16:33:42 <sinelaw> whatever
16:33:53 <Peaker> sinelaw: No, this should be type-able with a tweak :)
16:34:24 <sinelaw> in the second pattern x and (x,x) are not the same type
16:34:35 <xplat> peaker without bottoms that function is id
16:34:52 <kmc> my 2¢ on imports is to do open unqualified for "standard" stuff (Control.Monad, etc) and qualified for everything else
16:35:02 <Peaker> @type let f x 0 = show x ; f x n = f (x, x) (n - 1) in f
16:35:03 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, a)
16:35:03 <lambdabot>       Expected type: (a, a) -> t -> String
16:35:03 <lambdabot>       Inferred type: a -> t -> String
16:35:05 <kmc> qualified as <1-3 letter name>
16:35:14 <kmc> and i don't mind the syntax for qualified operators
16:35:49 <xplat> nn, i'd hate to use qualified operators when there's no conflict
16:36:03 <xplat> it's not hard to understand but it is hard to read
16:36:11 <dark> do ghc have the option for import something at command line instead of at the source?
16:36:16 <dark> now this is evil
16:36:27 <sinelaw> Peaker, i'm not getting it, and so doesn't ghc
16:37:12 <Taejo> > f $ g $ h $ x
16:37:13 <lambdabot>   Ambiguous type variable `b' in the constraints:
16:37:13 <lambdabot>    `GHC.Show.Show b'
16:37:13 <lambdabot>      a...
16:37:21 <Peaker> sinelaw: I forget how to invoke it exactly, but you can have recursion using a different type in each recursive invocation
16:37:21 <Taejo> > f . g . h $ x
16:37:22 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:37:22 <lambdabot>    `GHC.Show.Show a'
16:37:22 <lambdabot>      a...
16:37:29 <Taejo> > (f . g . h $ x) :: Expr
16:37:30 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:37:30 <lambdabot>    `SimpleReflect.FromExpr ...
16:37:37 <Taejo> > (f . g . h $ x) :: (Expr Int)
16:37:38 <lambdabot>   Kind error: `SimpleReflect.Expr' is applied to too many type arguments
16:37:52 <Saizan> Peaker: you've to give it a type signature
16:37:58 <sinelaw> Peaker, you're sure that's not the non-monomorphic functions?
16:38:06 <Taejo> :t (f . g . h $ x)
16:38:07 <lambdabot>     Ambiguous type variable `a' in the constraints:
16:38:07 <lambdabot>       `Show a' arising from a use of `f' at <interactive>:1:1
16:38:07 <lambdabot>       `SimpleReflect.FromExpr a'
16:38:10 <xplat> peaker: you're thinking of nested types and nested recursion.  you have to have different types for both input AND output.
16:38:15 <Peaker> sinelaw: the MR? That's a silly thing
16:38:20 <aristid> hmm, an inline syntax for sum types would be nice
16:38:21 <Taejo> :t f
16:38:22 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
16:38:27 <Taejo> :t x
16:38:28 <lambdabot> Expr
16:38:40 <dark> Taejo, but what is f, g, h, x?
16:38:42 <sinelaw> Peaker, it is, but it's the same as what you're saying - calling itself with different types
16:38:48 <aristid> > f x :: Expr
16:38:49 <Saizan> @type let f :: Show a => a -> Int -> String; f x 0 = show x ; f x n = f (x, x) (n - 1) in f
16:38:49 <lambdabot>   f x
16:38:50 <lambdabot> forall a. (Show a) => a -> Int -> String
16:38:51 <xplat> aristid: sure would.  and functions like either3, either4 ...
16:38:54 <dark> @src f
16:38:54 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:39:01 <aristid> xplat: :)
16:39:02 <Taejo> dark: they're a bit of type magic
16:39:04 <Peaker> sinelaw: Saizan got it above
16:39:10 <sinelaw> yea i see
16:39:12 <Taejo> or rather, Expr is a bit of type magic
16:39:15 <Peaker> > let f :: Show a => a -> Int -> String; f x 0 = show x ; f x n = f (x, x) (n - 1) in f 1 4
16:39:16 <lambdabot>   "((((1,1),(1,1)),((1,1),(1,1))),(((1,1),(1,1)),((1,1),(1,1))))"
16:39:20 <dark> @src Expr
16:39:20 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:39:25 <aristid> :t either
16:39:27 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:39:30 <Peaker> sinelaw: Recursion uses a different "a" type in each invocation
16:39:51 <sinelaw> Peaker, why is that special though
16:39:56 <sinelaw> w.r.t hindley-milner
16:39:59 <Saizan> the MR doesn't directly mess with polymorphic recursion, the problem is that type inference can't handle it
16:40:08 <sinelaw> ah
16:40:35 <Saizan> hindley-milner can't infer the correct type for f
16:40:42 <xplat> Saizan: whoa, didn't think you could do that with polymorphic recursion.  i stand corrected.
16:40:45 <sinelaw> Saizan, so ghc also can't? 
16:41:09 <Saizan> sinelaw: right, that's why we need a type signature
16:41:40 <sinelaw> Saizan,  so disabling the MR only means to "allow me to write these funcs and give you the type signature"?
16:42:12 <xplat> no, disabling MR means it can generalize monomorphic recursion without eta expansion
16:42:22 <Saizan> sinelaw: disabling the MR doesn't have anything to do with this, but i'm not aware of the larger context, if there's any
16:42:34 <sinelaw> Saizan, there isn't
16:42:48 <sinelaw> xplat, yikes
16:42:48 <adnap> How do you get darcs to show you a list of all patches associated with your repo?
16:42:57 <Saizan> sinelaw: the MR simply restricts the possible types of pattern bindings, i.e. definitions with no formal parameters
16:43:02 <xplat> there are a number of reasons you might need a type signature on a haskell function value, some are more artificial than others
16:43:18 <xplat> (or for that matter, on a non-function value)
16:43:27 <Saizan> sinelaw: if you've a definition like foo = ... then the type of foo can't have a typeclass context
16:44:02 <Saizan> ("foo = .." as opposed to "foo x = ..")
16:44:03 <xplat> Saizan: can't be polymorphic at all even if there's no context
16:44:11 <Saizan> xplat: not true
16:44:26 <Saizan> it specifically only applies if typeclasses are involved
16:44:46 <sinelaw> Peaker, anyway, i'm losing track but the point is that for a simple functional compiler you don't need to worry about your example, if you know how to parse type signatures
16:44:50 <Saizan> btw, by "can't" i mean it's not inferred so, if you give an explicit type it works
16:45:12 <xplat> Saizan: er?  why would it do that?
16:45:47 <Saizan> xplat: because typeclass dictionaries are the only reason to have the MR in the first place
16:46:05 <Saizan> (or type witnesses, if you go JHC style)
16:46:46 <Taejo> and by "can't" Saizan means "isn't" -- there's no technical difficulty in inferring these type signatures (as -XNoMonomorphismRestriction shows)
16:47:06 <Taejo> in case that wasn't clear
16:47:07 <Peaker> sinelaw: the MR is just a silly syntax rule that says if you have syntax like:   <name> = ...   and ... is a polymorphic value, it will get a non-polymorphic (monomorphic) type.  If you even change it to <name> x = ... x   it won't happen. If you give it a type signature it won't happen
16:47:20 <Saizan> Taejo: thanks for clarifying :)
16:47:34 <xplat> Saizan: i thought it was tradition from ML
16:47:48 <Taejo> does ML have classes?
16:47:49 <sinelaw> Peaker, what'st the reason
16:48:03 <Peaker> sinelaw: the idea is that if you have   f x = ... you *expect* it to compute when you use f.  If you have  f = ... you expect it to compute once and share the result
16:48:10 <Saizan> xplat: ML has a more severe thing called "value restriction", which is motivated by side effects
16:48:15 <Peaker> sinelaw: but if it is polymorphic, there is no one result, so it will recompute each time it is used
16:48:22 <sinelaw> ah
16:48:26 <Peaker> sinelaw: so they chose the MR to avoid this confusion (and IMO got a lot more confusion, instead)
16:48:40 <xplat> hm, i guess they did, at that
16:49:35 <Peaker> sinelaw: for example, ETA reduce is not safe in the presence of the MR :-(
16:49:42 <Peaker> I hate the MR
16:50:01 <sinelaw> oh right
16:50:02 <sinelaw> weird
16:50:15 <dolio> It's hard to say, really. We've never had a time when there wasn't a monomorphism restriction to see how many people come along and say, "why is my code exponentially less efficient than it should be?"
16:50:37 <Peaker> sinelaw: long after I felt proficient in Haskell I still banged the MR repeatedly. then I finally really understood what it was, and I can finally spot it without fighting it. But it took a while
16:50:47 <Taejo> can a program have more than O(program size) concrete types dynamically? couldn't a polymorphic "CAF" just be memoized in its type argument?
16:50:52 <Peaker> dolio: there are so many performance issues in Haskell as it stands :)
16:50:53 <Saizan> Peaker: eta is not an acronym btw :)
16:50:58 <augustss> dolio: actualy, we did have such a time.  there was one complaint. :)
16:50:59 <sinelaw> i haven't hit it in a while
16:50:59 <xplat> well, eta reduction is still safe after type inference is done, even with MR, it's just that doing it by hand is too early
16:51:14 <dolio> augustss: Pre 1.0?
16:51:18 <Peaker> Saizan: I know :)
16:51:42 <augustss> dolio: I don't think MR was in 1.0
16:51:44 <dolio> I know 1.0 doesn't have The monomorphism restriction, but it has something similar, as I recall.
16:52:20 <sinelaw> anyway i'm wondering what the minimal feature set for a useable functional language would be
16:52:35 <sinelaw> assuming we want lazy
16:52:36 <augustss> dolio: The complaint was from John Hughes.  And it was with sadness I changed hbc to obey the MR when it was decided that it was needed.
16:52:47 * hackagebot HSGEP 0.1.4 - Gene Expression Programming evolutionary algorithm in Haskell  http://hackage.haskell.org/package/HSGEP-0.1.4 (MatthewSottile)
16:53:08 <pumpkin> oh wow, augustss is back!
16:53:35 <Peaker> augustss: it seems weird to have such particular operational semantics (that don't even seem inherent) affect high-level decisions
16:53:37 <dolio> Of course, I think the MR gets in the way of actual proficient coders, and not having it is less likely to do so.
16:54:05 <dolio> And I'm not really big on giving preference to new users.
16:54:30 <augustss> I think MR should have been a warning instead.
16:54:49 <sinelaw> i mean, haskell has been going the "useful / flexible feature set" way, but there's room for a "minimal features" variant
16:54:50 <Taejo> dolio: I see the opposite: new users trip over the MR.
16:55:03 <Peaker> if we're willing to lift things like "will be memoized/shared" to language level (the MR pretty much does that), then there's more you could do (don't memoize this, depsite it getting a name, for example
16:55:10 <Taejo> oldbies use explicit type signatures, and care about performance
16:55:10 <pumpkin> but would they trip over the subtle effects of NMR if MR weren't there?
16:55:16 <dolio> Taejo: Well, they do too.
16:55:34 <sinelaw> Taejo, exactly, when i started out i constantly hit it, now i don't although i'm not avoiding it consciously
16:55:35 <dolio> Taejo: Oldbies just don't come here and complain when they trip on it, because they know what's wrong.
16:56:03 <Taejo> dolio: there is that
16:56:11 <Peaker> Taejo: I don't use type sigs in my local where clauses, and that's where the MR bites me
16:56:23 <Peaker> Taejo: and I typically don't care about performance in the Haskell code I write
16:56:40 <Peaker> Taejo: it's hard for me to relinquish control to a GC/RTS/etc when I do care about performance :)
16:56:42 <Taejo> right, me too -- dolio is right, I do trip over it, I just don't really notice when I do
16:57:20 <Taejo> there aren't many cases where I don't care about exponential vs linear time
16:57:36 <Peaker> Taejo: not every MR invocation causes that :)
16:57:38 <Taejo> but when I care about linear vs linear, I'll probably go for C++
16:57:43 <Taejo> true
16:57:58 <Saizan> Peaker: how often you have where clauses with functions that need to be polymorphic?
16:58:00 <Taejo> I, for one, agree with augustss: it should be a warning
16:58:16 <pikhq> Taejo: By C++ you mean C. And by C *I* mean machine code.
16:58:17 <pikhq> :P
16:58:28 <Taejo> pikhq: no, I mean C++
16:58:28 <Peaker> Saizan: Not that often, but the problem is that the low frequency also meant it was more surprising/hard-to-debug for a while :)
16:58:32 <Taejo> you mean machine code
16:58:52 <Taejo> I know it's not a good language, but it's what I was taught in
16:58:54 <pikhq> Taejo: But C++ has a number of things that increase your constant factors!
16:58:56 <Peaker> Taejo: I compile with -Werror
16:58:59 <Peaker> Taejo: in all languages :)
16:59:14 <Taejo> pikhq: that doesn't change the fact that I use it
16:59:15 <Saizan> Peaker: ah well, ghc-7 will make all those definitions monomorphic by default anyway :)
16:59:28 <Peaker> Saizan: I don't enable GADTs most of the time ...
17:00:13 <pikhq> Taejo: But it should.
17:00:37 <Taejo> pikhq: please stop it
17:01:49 * hackagebot hstatistics 0.2.2.6 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.2.6 (VivianMcPhail)
17:02:48 <Philippa> Taejo: I'm an oldbie who doesn't write many type signatures that aren't necessary, FWIW
17:03:10 <Taejo> generalising ftl
17:03:17 * Taejo ftl
17:03:25 <Philippa> huh? You don't look that fast from here
17:03:59 * Taejo stm (slower than molasses) apparently
17:04:04 <Taejo> Philippa: for the lost
17:04:06 <Taejo> *lose
17:04:20 <aristid> @hoogle (Functor f) => a1 -> f a -> f a1
17:04:20 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
17:04:21 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
17:04:21 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
17:04:39 <Philippa> Taejo: I know :-) But it's still amusing for SF nerds
17:04:56 <Taejo> I laughed
17:07:28 <aristid> :t \x y -> x <$ guard y
17:07:29 <lambdabot> forall a (f :: * -> *). (MonadPlus f, Functor f) => a -> Bool -> f a
17:07:47 <dafis> Anybody here interested in doing a little benchmarking, preferably on a 64-bit system?
17:07:53 <aristid> :t \x y -> (x <$ guard y :: Maybe Int)
17:07:54 <lambdabot> Int -> Bool -> Maybe Int
17:10:28 <dafis> preflex: seen dons
17:10:28 <preflex>  dons was last seen on #ghc 4 hours, 28 minutes and 42 seconds ago, saying: great.
17:13:01 <Maxdamantus> @src scanl1
17:13:01 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
17:13:02 <lambdabot> scanl1 _ []     =  []
17:13:52 <Maxdamantus> @src scanl
17:13:52 <lambdabot> scanl f q ls = q : case ls of
17:13:52 <lambdabot>     []   -> []
17:13:52 <lambdabot>     x:xs -> scanl f (f q x) xs
17:17:00 <dolio> augustss: Ah, found it, I think. On page 35 of the 1.0 report...
17:17:31 <dolio> "Variables bound directly to lambda abstractions are typed exactly as described above. ..." which is more lenient than the MR, but...
17:18:40 <dolio> "Variables /not/ bound directly to a lambda abstraction may be polymorphic and overloaded, but must also obey the rule: /variables not bound directly to lambda abstraction must not be used at more than one distinct overloading/. An immediate consequence is that /overloaded variables not bound directly to lambda abstractions cannot be exported/, because, once exported, there is no way to check the required condition."
17:18:57 <Peaker> am I the only one who has grown to dislike pattern matching in general, and prefer to use higher order matchers that do it for me?
17:19:25 <dolio> Which sounds like the MR, only it's not tracked in the types or something.
17:19:40 <humasect> different kinds of pattern matching
17:19:55 <Philippa> Peaker: it depends on the context
17:19:56 <Peaker> humasect: when I write an ADT, I generally immediately wrap it with "getters"
17:20:09 <Peaker> for sum types I'd have a cata-morphic getter
17:20:20 <humasect> Peaker: oh ? can i see? =)
17:20:35 <Peaker> humasect: I'll have to look up Haskell code of mine now.. sec :)
17:20:40 <Philippa> I do a lot of stuff where the pattern-matching's in the problem domain, and a lot of it I'd like to have the bulk of the skeleton written for me
17:20:58 <humasect> hmm
17:21:01 <Philippa> because it's redundant when it's generated, but not quite so much when it's read
17:21:27 <Peaker> humasect: e.g: if I have data Vector2 a = Vector2 !a !a  I will write: vector2 :: (a -> a -> b) -> Vector2 a -> b
17:21:32 <humasect> why not pattern match instead of any other branching
17:21:38 <dolio> Also, there's no way to circumvent that restriction, unlike the MR.
17:21:56 <dolio> Other than turning a value into a constant function.
17:21:58 <humasect> Peaker: ahh=)
17:23:28 <Philippa> Peaker: I'll just use let to break things up and do the manual pattern-match there
17:23:51 <Philippa> all you're eliminating there is the case...of bit
17:23:59 <Saizan> Peaker: if you're pattern matching against more than one argument at once it doesn't translate so well to combinators 
17:24:14 <nornagon_> what happened to foldl.com and foldr.com? :(
17:24:20 <Philippa> also, that's a product type, not a sum type
17:24:25 <nornagon> i can no longer remember the difference ;(
17:24:32 <Peaker> Saizan: Yeah.. I agree. I was wondering if like SECs, there were combinators to make that sane
17:24:38 <Philippa> (and for sum types it's worse, because you're obscuring which bit of code handles which constructor)
17:24:47 <Peaker> Saizan: points-free can become sane with rich combinators.. Can cata compositions?
17:25:56 <Philippa> show some that help? I think the typical catamorphism syntax sucks, though
17:26:20 <Philippa> we know what's going on for lists, but you wouldn't want to do it with the AST of a medium-sized language
17:26:51 <xplat> the bracket syntax definitely wouldn't work out there
17:26:51 <Peaker> Philippa: maybe you can modularize that AST into pieces?
17:27:11 <Peaker> Philippa: btw: the sum type obscuring wouldn't be so bad with keyword args or Agda mixfix
17:27:29 <Saizan> i feel like paramorphisms would compose better
17:28:00 <dolio> You want paramorphisms anyway, for performance reasons.
17:28:06 <Peaker> Saizan: what are those?
17:29:16 <Saizan> Peaker: where you not only get passed the result of the recursive call but also the subterm
17:30:07 <Saizan> ?type let para f z [] = z; para f z (x:xs) = f x xs (para f z xs) in para
17:30:08 <lambdabot> forall t t1. (t -> [t] -> t1 -> t1) -> t1 -> [t] -> t1
17:30:34 <Peaker> Saizan: ah.. might as well recurse on your own then?
17:30:41 <Philippa> Peaker: not in a way that doesn't end up obscuring intent. We're talking about the description of a language, naming sub-pieces of it doesn't help any because you're just turning flat patterns into nested ones
17:30:51 <sinelaw> :t fmap
17:30:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:31:54 <Philippa> not only that, the appropriate decomposition varies by task
17:32:39 <Philippa> with you re keyword parameters and mixfix, though
17:32:54 <Philippa> hrmm. Permutation mixfix with a canonical re-ordering...
17:33:23 <Philippa> (sometimes there's good reason to present the constructors in a specific sequence, like bunching intro/eliminator pairs together...)
17:35:50 <Philippa> remind me, what's required to define a 'monadic paramorphism'(/catamorphism/...) in terms of the ordinary variant?
17:36:03 <Philippa> oh, er, a data-structure traversal, I guess
17:36:27 <dolio> Something like Charity might be nice. Don't they let you write catamorphisms as a case-alike banana bracket?
17:36:33 <Philippa> something that does approximately the role of sequence, only it's trickier when there's non-polymorphic leaf data
17:36:58 <dolio> So, instead of a one-step case, you get a version where the recursive arguments are filled with the reduced values.
17:37:29 <Saizan> Peaker: i guess so, in which case you're left only with one-step destructors, which may be the most composable (mostly because they are doing much less)
17:38:01 <dolio> But you can still write it as (| nil -> z | cons x r -> f x r |)
17:38:10 <Philippa> dolio: cool
17:38:27 <dolio> I'm not actually certain that's how it works, but if not, that's a good idea. :)
17:40:16 <dolio> @type \f z = foldr (\x r -> r >>= f x) (return z)
17:40:17 <lambdabot> parse error on input `='
17:40:22 <dolio> @type \f z -> foldr (\x r -> r >>= f x) (return z)
17:40:23 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> a1 -> m a1) -> a1 -> [a] -> m a1
17:41:11 <Saizan> aka s/$/=<</
17:44:09 <dolio> Charity does, in fact, work that way.
17:45:11 <dolio> def length: list A -> nat
17:45:34 <dolio> = l => {| nil : () => zero | cons: (_, n) => succ n |} l.
17:45:57 <joe1> does anyone of haskell being used to generate asm (specifically for microchip's pic)?
17:46:08 <dolio> {|} is cata, (|) is ana.
17:47:07 <Cale> joe1: I've used it to help generate PPC+Altivec code (though that wasn't open source, and I don't have the code anymore). There are definitely people using it for realtime embedded stuff.
17:47:58 <Cale> http://hackage.haskell.org/package/atom
17:48:01 <joe1> Cale: that is good to know. Was it a large effort? How long did it take you?
17:48:07 <joe1> will check out atom.
17:48:09 <joe1> Thanks a lot.
17:48:20 <Cale> http://hackage.haskell.org/package/harpy
17:48:35 <dolio> def nats: 1 -> stream(nat) = () => (| n => head : n | tail: succ n |) zero.
17:49:08 <joe1> Cale: thanks a lot. I will check them out.
17:49:33 <Cale> joe1: I was working on a pipeline scheduler and register allocator, I spent just a couple of months on it, most of that time thinking about the algorithm, and just a few weeks implementing it.
17:50:00 <Cale> joe1: I'll find a talk...
17:50:12 <dolio> Man, why does oleg always reply to the top level?
17:50:32 <Peaker> with great power comes great responsibility, dolio 
17:50:58 <dolio> Thanks, Uncle Ben.
17:51:12 <joe1> Cale: i am not looking for something fancy. I would love to have something in haskell or some high level language so that I can see all the code in one screen
17:51:25 <Cale> http://dmcc.acm.org/pres/?query=/dmcc///confdata/ICFP2008/2008-09-26_09h56
17:51:51 <joe1> i do not mind programming in asm but just that the code is so long and I am spending more time searching/moving around in the code..
17:51:57 <Cale> ^^ that's a talk by someone using Haskell and Atom to program realtime control systems for hybrid hydraulic vehicles.
17:58:58 <joe1> Cale: thanks, I am checking out those links. One thing I noticed is that they are using haskell to output asm code. i was thinking more along the lines of using the current architecture that generates the machine/executable code to generate code using pic asm.
17:59:35 <joe1> something more along the lines of "How hard is to  port haskell to a diff architecture?"
17:59:56 <Philippa> to PIC? Very likely a major PITA
18:00:33 <joe1> just the basic stuff, nothing fancy.. pattern guards, simple monads, etc..?
18:00:35 <Philippa> you get a pretty impressive amount of power with the code generation approach anyway, you just have to write a few libs for yourself
18:00:42 <Philippa> it doesn't work like that
18:00:50 <Cale> Well, depending on what sort of machine you want it to run on, it can be pretty tough. GHC's runtime system would be pretty heavyweight for most microcontrollers :)
18:01:02 <Philippa> even if you just go with the single-threaded RTS, you've got garbage collection to deal with
18:01:25 <cch> hi, I try to import Control.Monad.Trans, and compiler complained that module is both in mtl and monad-fd, so i change to "import 'monads-fd' Control.Monad.Trans"  and this time compiler said: Failed to load interface for `Control.Monad.Trans':
18:01:25 <cch>       it is not a module in the current program, or in any known package.
18:01:26 <cch>  
18:01:31 <Saizan> does the llvm backend help any here?
18:01:39 <cch> any suggestion ? thanks
18:01:53 <Cale> cch: ghc-pkg hide monads-fd
18:01:59 <Philippa> Saizan: I guess it might if you really stripped the hell out of the RTS. You'd be up and running sooner doing codegen though
18:02:12 <Philippa> GHC makes one hell of a macro assembler
18:02:41 <cch> why hide?  monads-fd is not meant to be used?
18:03:03 <cch> could any other modules depend on this package?
18:03:59 <Cale> cch: Well, hiding the package doesn't prevent it from being used. It just means it won't be visible automatically without the appropriate package flags or cabal configuration
18:04:20 <joe1> Saizan: will check out the "llvm backend" option. thanks for the suggestion.
18:04:33 <Cale> cch: It's basically a replica of stuff that's in mtl anyway (separated out a bit, alongside the transformers package)
18:04:38 <joe1> Cale Philippa: yeah, it might be simpler to just use it as a macro assembler..
18:05:32 <Cale> joe1: There's some neat stuff you might be vaguely interested in about programming an FPGA to efficiently evaluate Haskell code.
18:06:25 <cch> Cale: ok. so why the complier said findding no module when I write "import 'monad-fds' Control.Monad.Trans"
18:06:50 <joe1> Cale: ok, thanks.
18:06:53 <Cale> cch: That, I'm not sure, though make sure that you got the package name right.
18:07:16 <Cale> (it's monads-fd)
18:08:06 <Cale> http://www.cs.york.ac.uk/fp/reduceron/
18:08:14 <Cale> http://video.google.com/videoplay?docid=-1518197558546337776#
18:09:05 <cch> Cale: ah.. i did make a stupid mistake,  sorry
18:09:10 <Cale> Though, that's sort of going a different way, not trying to squeeze Haskell onto a little microcontroller, but to design a machine which would be effective at evaluating Haskell code.
18:11:36 <EvanR> how does one do haskell-like memory management on a microcontroller 
18:13:18 <Philippa> I wouldn't
18:14:11 <Philippa> if I had lots of time to burn, I'd look into encoding a region-based language
18:16:48 <kmc> http://armpit.sourceforge.net/
18:17:03 <EvanR> lol
18:18:30 <Cale> Cool, now we just need a scheme backend for GHC ;)
18:19:52 <Cale> Though GHC already has some ability to compile code for ARM. (Which we're using at iPwn of course :)
18:20:05 <kmc> Cale, just via unregisterised C, right?
18:20:30 <kmc> or did someone registerize the ARM backend and not tell me
18:20:36 <Cale> I think that's how it goes. I'm not sure if GHC iPhone does more.
18:20:45 <kmc> it doesn't, unless the patches have been updated in the last few months
18:20:52 * kmc is working on the Android analogue
18:20:55 <kmc> it's coming quite well
18:21:09 <kmc> all necessary packages build, giving me an 80 MB .so file, which is too big for the android emulator to handle :D
18:21:11 <Cale> awesome
18:21:13 * EvanR sues kmc 
18:21:25 * kmc double-sues EvanR
18:21:41 <Cale> kmc: Oh, you're actually working on getting GHC itself to run on Android?
18:21:45 <kmc> no, sorry
18:21:55 <kmc> i'm working on the cross-compiler target, analogous to the iPhone project
18:22:04 <kmc> (based on 6.12.1 rather than 6.10.3, though)
18:22:11 <Cale> Yeah, that's more what I thought. :)
18:22:38 <kmc> the 80 MB of object code is just every Haskell lib iPwn needs, and their C dependencies (other than Android system-wide stuff, which is quite little)
18:22:44 <Cale> ah
18:23:02 <kmc> the whole project has been a thousand little fixes
18:23:15 <kmc> Android does this fun thing where the headers declare a bunch of standard POSIX functions, but they aren't implemented and give a linker error
18:23:39 <Cale> Glorious
18:23:51 <kmc> the kernel is Linux, but the userland is a Linux / BSD hybrid frankenstein's monster
18:23:53 <Cale> Why would they do that, I wonder.
18:24:01 <kmc> you can't even build Busybox cleanly
18:24:05 <kmc> and the built-in shell is terrible
18:24:36 <kmc> Cale, they do it because it makes their job easier, and 99% of apps are supposed to be managed Dalvik only, and of that 1% they're only supposed to use JNI for computational inner loop
18:25:11 <kmc> i expect the BSD license factored into it too
18:25:13 <aristid> how authoritarian
18:25:20 <kmc> aristid, not nearly as authoritarian as Apple
18:25:27 <aristid> kmc: but still terrible
18:25:47 <kmc> aristid, i don't think things are deliberately fucked up to discourage native code
18:25:56 <kmc> i just think polishing the C environment was not a priority
18:26:06 <mikeg> is there a good example for using do notation with the State monad?
18:26:40 <kmc> and when you're building something like the 'unix' package, which FFI-wraps every POSIX function, you hit a lot of corner cases
18:27:03 <aristid> kmc: i believe in competition between programming languages, and google being google should understand that. but apparently they don't fully
18:27:44 <kmc> aristid, so they should put in a lot of extra effort to make C and Haskell development easier?
18:28:01 <EvanR> C at least
18:28:04 <aristid> kmc: well, not specifically haskell, but yes
18:28:07 <kmc> endorsing a Java-based managed platform is a bold move and not necessarily one i agree with, but i wouldn't call it 'authoritarian'
18:28:17 <kmc> they're not locking you out of anything
18:28:32 <aristid> yeah true, they're really quite open compared to, say, apple
18:28:33 <kmc> and i think this part of android is open-source, so anyone who cares could fix it
18:28:49 <EvanR> so can ghc use a java platform instead?
18:29:00 <kmc> that'd suck
18:29:03 <kmc> performance-wise
18:29:08 <kmc> i'd like that option though
18:29:19 <EvanR> thats what google had in mind though 'java is good enough for everything'
18:29:21 <kmc> anyway i'm fine with the fact that my phone doesn't implement tcdrain().  i'd just rather have a nicer build-time indication of this fact
18:35:32 <Cale> mikeg: What sort of example would you like? I suppose I could throw together something simple.
18:35:42 <kmc> mikeg, it's probably in All About Monads
18:35:43 <Saizan> kmc: did you know of tcdrain() before?
18:35:53 <kmc> AAM is not great, but has some useful examples
18:35:57 <mikeg> Cale: kmc: i found sort of what i was looking for in lyah
18:36:02 <kmc> if the prose seems to say something incorrect, it might well be
18:36:10 <kmc> Saizan, nope!
18:36:18 <kmc> i've still only a vague idea what it does
18:36:30 <aristid> "tcdrain() waits until all output written to the object referred to by fd has been transmitted." <- that looks like a kernel call
18:36:33 <aristid> why did they drop it?
18:36:34 <mikeg> i was hoping I could turn a complicated runState ... `ap` ... `ap` ... into something simpler
18:36:44 <aristid> and why did they bother modifying the kernel so heavily?
18:37:04 <kmc> nothing you call from C normally is directly a kernel call
18:37:21 <aristid> kmc: i know, but it looks like a thin wrapper around one
18:37:21 <kmc> it's a function in some c library which may or may not make some system calls
18:37:39 <kmc> aristid, i've no idea, it's part of termios which does various stuff
18:37:52 <kmc> anyway this is the boiling point of nitrogen
18:38:08 <aristid> oh right, if it's not in glibc it's probably no system call
18:38:20 <kmc> (refers to arguing about facts instead of looking them up)
18:39:11 <mikeg> ultimately I'm trying to parse a ByteString into a datatype with a number of fields, and i have an ugly `let (a,b,...) = liftM (,,,) readInt `ap` readString in T { a = a, b = b }`
18:39:48 <aristid> int __libc_tcdrain(int fd)
18:39:49 <aristid> {
18:39:49 <aristid>   return ioctl(fd, TCSBRK, 1);
18:39:49 <aristid> }
18:40:15 <aristid> kmc: there :P ok, dietlibc, but that should give the idea
18:40:38 <mikeg> so I figured out how to turn the let part into a State monad do, and now I'm trying to get ridof the clutter in the record syntax
18:40:47 <kmc> ok
18:45:38 <EvanR> stupid record update syntax...
18:46:03 <kmc> mikeg, perhaps use a package like fclabels
18:46:06 <kmc> the built-in record syntax sucks
18:46:48 <mikeg> interesting, thanks :) i'm not totally opposed to just typing it all out though :D
18:50:38 <kmc> bah
18:59:25 * hackagebot hexpat 0.19.2 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.19.2 (StephenBlackheath)
19:00:02 <EvanR> screw convention
19:00:20 * EvanR does f . g . h (x)
19:00:44 <EvanR> doesnt work does it
19:01:01 <mwc> I think you meant f . g . h $ x
19:01:07 <augustss> depends on what you want it to do
19:01:09 <EvanR> im trying to screw that convention
19:01:17 <EvanR> (f . g . h) x
19:01:22 <mwc> that would also work
19:02:26 * hackagebot pcre-less 0.2.1 - Nicer interface to regex-pcre.  http://hackage.haskell.org/package/pcre-less-0.2.1 (MichaelZuo)
19:02:27 <aristid> i like the look of that
19:04:23 <res> aristid: what look of what?
19:06:34 <aristid> res: of (f . g . h) x
19:07:01 <gwern> http://en.wikipedia.org/w/index.php?title=A_Fire_Upon_the_Deep&curid=2080&diff=389986659&oldid=389964018
19:07:05 <gwern> wow
19:07:19 <res> wait, why not just f (g (h x)) ?
19:07:34 <aristid> res: UGLY
19:07:48 <Raevel> eyes hurt
19:07:54 <augustss> gwern: it's a cool book
19:07:58 <res> but it's shorter!
19:08:42 <Raevel> as many non white space chars O_o
19:08:47 <gwern> augustss: is it bad that we now have vandals making haskell jokes?
19:09:34 <augustss> The cost of popularity.
19:09:54 <Martty> any suggestions on a simple free remote control app for windows?
19:09:58 <aristid> > map length ["f . g . h $ x", "(f . g . h) x", "f (g (h x)))"]
19:10:00 <lambdabot>   [13,13,12]
19:10:05 <monochrom> I would not mind "f . g . h x" to mean "(f . g . h) x"
19:10:12 <Raevel> res: anyway... it's nice to think in terms of function composition instead of value transformations, if it was a function it would be just myF = f . g . h instead
19:10:22 <res> that it is
19:10:23 <aristid> monochrom: i.e. . would bind stronger than whitespace?
19:10:29 <monochrom> yes
19:10:41 <aristid> hmmmmmm
19:10:43 <res> mikeg: but that would screw up things like sum . map (const 1)
19:10:52 <augustss> > map length ["f.g.h$x", "(f.g.h)x", "f(g(h x)))"]
19:10:53 <lambdabot>   [7,8,10]
19:11:16 <aristid> augustss: yeah i guess it's the non-ws characters that matter to the brain
19:11:31 <res> > length "f$g$h$x"
19:11:32 <lambdabot>   7
19:11:47 <Pseudonym> Grrrr.
19:11:51 <aristid> res: no change over the canonical version f.g.h$x :)
19:11:54 <Pseudonym> Bad style.
19:12:03 <augustss> It sure is
19:12:06 <Pseudonym> Controversial, to be sure, but bad style.
19:12:14 <EvanR> pick your poison, lisp or bling
19:12:18 <monochrom> the dijkstranian notation would be more radical and I would like even more: application is ".", composition is "∘", write "f∘g∘h.x", declare suitable precedence.
19:13:31 <Axman6> Martty: not sure why you're asking that in here...
19:13:54 <res> I want something vaguely o-shaped for composition
19:14:13 <augustss> res: use Unicode
19:14:19 <res> of course, there are plenty of unicode non-letters
19:14:35 <res> but they're kind of annoying to type
19:14:51 <augustss> res: map some keystroke
19:14:55 <Pseudonym> In general, requiring Unicode is still a bad idea.
19:15:07 <augustss> Is it?
19:15:13 <Pseudonym> In source code?  Yes.
19:15:21 <Pseudonym> Allowing it is a good idea, but requiring it is a bad idea.
19:15:22 <res> also, most of my programming is in an 8-bit terminal
19:15:23 <monochrom> > let (∘) f g x = f (g x) in not ∘ not $ True
19:15:24 <lambdabot>   True
19:15:30 <monochrom> \∩/
19:15:36 <Pseudonym> > let (aHX) f g x = f (g x) in not aHX not $ True
19:15:37 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
19:15:37 <lambdabot>         against inferred type ...
19:15:48 <augustss> Are we forever going to be stuck with an empoverished character set?
19:16:04 <res> monochrom: would be easier just to (?) = (.) , no?
19:16:14 <aristid> augustss: unicode is empoverished?!
19:16:18 <EvanR> my xterm works great so far
19:16:34 <augustss> aristid: No, I was arguing with Pseudonym 
19:16:39 <monochrom> I would just agree with Pseudonym. Just say "allow". But liberally use it. After a while it will become "require" de facto.
19:17:04 <aristid> gwern: the guy who vandalised that also made some other similar edits, like *500 BC: Invention of the [[Object Oriented Programming|OOP]] Paradignm. This was crucial in the Prince of Persia's drive to dominate.
19:17:17 <Pseudonym> For Unicode to work, it needs to work the whole way through.
19:17:46 <Pseudonym> From terminals, across connections, to editors.
19:17:58 <EvanR> does for me
19:18:06 <augustss> Pseudonym: And on most platforms it does.  Maybe not if you use antiquated software. :)
19:18:13 <monochrom> There was a time some people hated html in email. We got them to agree "allow, don't require". Look at the world now. It's has evolved to "require".
19:18:23 <Pseudonym> I still hate HTML in email.
19:18:28 <EvanR> yes bad example
19:18:53 <bremner> I hate html in email more every day.
19:19:02 <Pseudonym> augustss: I'm getting old.  I don't use antiquated software, but I've got to the point where I don't want to spend time getting something to work.
19:19:17 <monochrom> http://www.birdhouse.org/etc/evilmail.html  :)
19:19:18 <res> html in email actually is still frowned upon when unnecessary
19:19:27 <monochrom> the resisters have given up the fight.
19:19:36 <aristid> res: tell that to your mom
19:19:36 <Pseudonym> If I can't ssh into a remote machine and use a modern text editor to edit my files, then it doesn't work.
19:19:49 <monochrom> so, just get them to concede to "allow". it's a slippery slope. not need to fight.
19:20:01 <res> aristid: I control her mail client :P
19:20:34 <Pseudonym> BTW, the problem with Haskell isn't that we don't use enough Unicode for identifiers, it's that all the good identifiers are used for the wrong purposes.
19:20:45 <aristid> res: haha, that's also a method
19:21:05 <Pseudonym> e.g. map/fmap/liftM
19:21:13 <Pseudonym> "map" should be the most generic one.
19:21:20 <augustss> Pseudonym: I totally agree with that
19:21:23 <Pseudonym> As it is, it's the least generic one.
19:21:29 <aristid> just use <$>
19:21:32 <res> sometimes I wish : weren't cons
19:21:33 <aristid> that looks generic too
19:21:50 <augustss> : and :: should have been swapped.  Big mistake, IMO
19:21:52 <monochrom> I am getting old too and I just want software to work too. But software does work. I just use ubuntu. I also never "customize fonts" like you picky people do. That's why unicode works so great in my computers.
19:22:18 <Pseudonym> augustss: Maybe.  Remember, in H-M, you shouldn't have to put in explicit types that often.
19:22:26 <Pseudonym> So you really do use : more than you use ::.
19:22:38 <Pseudonym> Or at least, that was the case in Miranda/Gofer/early Haskell.
19:23:00 <Pseudonym> The tradeoff has changed since the introduction of universal quantification, wobbly types etc.
19:23:25 <augustss> Even back then many of us used type signatures.  Also, : had been used as has-type since long.
19:23:49 <Pseudonym> Of course we used type signatures, but usually only for top-level functions.
19:24:17 <Pseudonym> The ratio of list cons to type signature was several to one.
19:24:24 <Pseudonym> And in many kinds of program, still is.
19:24:32 <augustss> And how much is (and was) cons used anyway?  Not that much.
19:24:47 <augustss> I hardly ever use :
19:24:52 <EvanR> im using it a lot in my pattern matches on uri dispatch
19:24:56 <Pseudonym> I'm sure you use ByteString now.
19:25:00 <Pseudonym> As we probably all should.
19:25:31 <Pseudonym> And I/O monads, rather than continuation-based I/O.
19:25:55 <augustss> What?  continuation-based I/O is no longer in fashion?
19:26:07 <monochrom> I have long erased my .Xdefaults or .Xresources
19:26:23 <Pseudonym> monochrom: Indeed.  I have ssh -X now.
19:26:40 <Pseudonym> I don't use rhosts either.
19:26:45 <EvanR> i see most important chars in default xterm on slackware with no configuration
19:26:52 <EvanR> gnu unifont is included by default now
19:27:09 <Pseudonym> You use slackware?
19:27:23 <Pseudonym> How many floppies does it come on now?
19:27:39 <EvanR> it comes on 17 zip disks
19:27:58 <augustss> Mmmmm, zip disks.
19:28:09 <monochrom> If you still use lines like "xterm*font: *-*-*-courier-*-r-*-12-*" you are deliberately screwing your own unicode support.
19:28:10 <augustss> Massive amounts of storage.
19:28:29 <EvanR> i dont dare mess with x bitmap fonts
19:28:46 <Pseudonym> Just a sec.
19:28:47 <monochrom> you may have non-antique software but "*-*-*-courier-*-r-*-12-*" ensures software behaves in antique ways character-wise.
19:29:24 <EvanR> although xbitmap fonts do support 'unicode character set'
19:30:28 <monochrom> the new system (in ubuntu for example) is to have "virtual fonts" which means union of all fonts installed on your computer, prioritized, so that almost all characters can be rendered. this is not available to the old *-*-*-*-* font selection mechanism.
19:30:54 <EvanR> every distro uses fontconfig now, thats not unique to ubuntu at all
19:31:14 <EvanR> xterm simply doesnt use it because it doesnt use truetype fonts (maybe it does now, but its likely shitty)
19:31:43 <Pseudonym> الحديث‎
19:31:44 <EvanR> truetype fonts in my terminal hurt my eyes
19:31:46 <Pseudonym> Hah.
19:32:02 <Pseudonym> I guess it was my IRC client after all.
19:32:11 <EvanR> maybe fixed since apple lost its patent on freetype hinting engine
19:33:40 <augustss> الحديث‎
19:34:02 <Pseudonym> Unfortunately, it doesn't handle bidi.
19:34:16 <Pseudonym> Still.
19:35:07 <pikhq> You think that's bad? Try finding something that handles TTB text.
19:35:10 <augustss> Interesting, google translate says الحديث‎ means "talk", but then translates "listen" to the same thing.
19:35:31 <Pseudonym> Google Translate is largely statistical.
19:35:46 <monochrom> that is a deep insight
19:35:57 <Pseudonym> It analyses works that are translated into several languages and tries to work out correspondences.
19:36:10 <Pseudonym> So it might have gotten that from a non-literal translation.
19:36:20 <EvanR> also there are user feedback right?
19:36:21 <monochrom> to talk is to listen. to listen is to talk.
19:36:35 <EvanR> 'correct this stupid translation'
19:36:39 <Pseudonym> Up until a month or so ago, if you tried to translate "lady gaga" from Malay into French, it translated it as "britney spears".
19:36:46 <EvanR> lol
19:36:54 <monochrom> that is another deep insight
19:36:57 <augustss> Pseudonym: Haha, excellent!
19:37:24 <EvanR> google is becoming senient, give it time
19:37:52 <augustss> It's already amazing at predicting what I'm going to search for.
19:41:48 <augustss> And that was the end of that. :)
19:44:30 <monochrom> all conversations end when the multivax is mentioned, and the last question asked.
19:47:19 <Pseudonym> There is as yet insufficient information for a meaningful answer.
19:48:25 <augustss> Out west today is still the answer.
19:51:49 <Cale> augustss: http://www.systranet.com/?text=%D8%A7%D9%84%D8%AD%D8%AF%D9%8A%D8%AB%E2%80%8E&lp=ar_en
19:52:15 <monochrom> oh interview! no wonder. :)
19:52:20 <augustss> Interesting
19:54:16 <erg0t> does exist any short way of discarding many arguments via pattern matching? for example if I have (Constructor a _ _ _ _ _) some way to avoid writting all the _
19:54:41 <kmc> if you declare Constructor as a record with a field named 'foo'
19:54:42 <zong_sharo> erg0t: records!
19:54:43 <kmc> you can do Constructor{foo=a}
19:54:57 <kmc> in the special case where you match no constructors, you can do e.g. Just{}, even if it wasn't declared as a record
19:54:58 <erg0t> thank you
19:55:17 <zong_sharo> it may be even cooler with view patterns
19:55:51 <zong_sharo> foo ( bar -> a ) = Just a
20:01:35 <Martty> 
20:09:18 <Axman6> @pl \f g h x y -> f x y `h` g x y 
20:09:19 <lambdabot> flip . (liftM2 ap .) . flip ((.) . (.))
20:09:58 <identity> o.o
20:10:00 <codolio> @type \f g h x y -> f x y `h` g x y
20:10:01 <lambdabot> forall t t1 t2 t3 t4. (t -> t1 -> t2) -> (t -> t1 -> t3) -> (t2 -> t3 -> t4) -> t -> t1 -> t4
20:10:31 <codolio> @type \f g h -> curry $ liftM2 h (uncurry f) (uncurry g)
20:10:32 <lambdabot> forall a b c c1 c2. (a -> b -> c1) -> (a -> b -> c2) -> (c1 -> c2 -> c) -> a -> b -> c
20:19:34 <EvanR> arrrg i want to specify byte ':', i know its not a byte, but but
20:19:55 <EvanR> fromIntegral . fromEnum $ ':' ??
20:20:13 <fizruk> ord?
20:20:19 <EvanR> :t ord
20:20:20 <lambdabot> Char -> Int
20:20:27 <EvanR> Char -> Word8
20:20:39 <fizruk> :t fromIntegral . ord
20:20:40 <lambdabot> forall b. (Num b) => Char -> b
20:21:02 <fizruk> :t fromIntegral . ord :: Char -> Word8
20:21:03 <lambdabot> Char -> Word8
20:21:14 <EvanR> :t breakByte
20:21:15 <lambdabot> Not in scope: `breakByte'
20:21:27 <EvanR> maybe Data.ByteString.Char has something
20:22:39 <fizruk> :t c2w8
20:22:40 <lambdabot> Not in scope: `c2w8'
20:22:52 <fizruk> :t c2w
20:22:52 <lambdabot> Not in scope: `c2w'
20:22:58 <fizruk> :(
20:23:01 <Axman6> @hoogle c2w
20:23:01 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
20:23:44 <fizruk> @hayoo c2w
20:23:44 <lambdabot> Unknown command, try @list
20:24:09 <fizruk> hm, there is no hayoo? :(
20:24:47 <djahandarie> I don't think there ever was hayoo on the bot
20:24:50 <djahandarie> Only hoogle
20:27:38 <evant_> http://hpaste.org/40485/bleh <- Is there a better way to write the last part, specifically having to write another functions just to check the tag
20:29:07 <darrint> Is there a function like read :: String -> Maybe a
20:29:16 <Axman6> t reads
20:29:20 <Axman6> :t reads
20:29:21 <lambdabot> forall a. (Read a) => String -> [(a, String)]
20:29:35 <byorgey> there isn't, but you can write it using reads
20:29:46 <darrint> thx
20:30:02 <byorgey> readMaybe s = case reads s of [(r,"")] -> Just r; _ -> Nothing
20:30:08 <Axman6> i never understood why reads didn't use Maybe
20:30:37 <byorgey> because it can return multiple results instead of just 0 or 1
20:31:50 <byorgey> evant_: I can't think of a better way to do it
20:32:05 <evant_> Ok, fair enough
20:32:34 <evant_> I could use 2 guards for tag == leftTag in the first part, but then i'd need to duplicate all the do code
20:36:36 <Cale> > 42 * 24 * 60 * 60 == product [1..10]
20:36:36 <lambdabot>   True
20:37:04 <Cale> Neat, in 42 days, there are exactly 10! seconds.
20:37:12 <byorgey> nice =)
20:42:42 <kmc> woah
20:42:47 <kmc> that's cool Cale
20:42:59 * kmc counts factors
20:45:09 <kmc> > product [1..10] == 2^8 * 3^4 * 5^2 * 7
20:45:10 <lambdabot>   True
20:45:45 <Cale> "Every word was once an animal." -- Emerson  "Every number was once a tree." -- Matula and Goebel
20:46:01 <augur> Cale: authors are crazy.
20:46:03 <kmc> orange! that's right!
20:46:43 <monochrom> every author was once sane
20:48:18 <kmc> 30, 31, 32, 33, 34, 35, 36, 34, 68, 27, 35, 42, 58, 47, 63, 85, 74, 67, 66, 51, 79, 42, 24, 45, 6A, 6, 7, 56, 65, 44, 53, 44, 17, 13, 23
20:48:43 <Cale> 6A
20:48:54 <aristid> @oies 30, 31, 32, 33, 34, 35, 36, 34, 68, 27, 35, 42, 58, 47, 63, 85, 74, 67, 66, 51, 79, 42, 24, 45, 6A, 6, 7, 56, 65, 44, 53, 44, 17, 13, 23
20:48:55 <lambdabot>  Sequence not found.
20:49:06 <aristid> kmc: you are crazy, that sequence DOES NOT EXIST
20:49:48 <kmc> you searched ω^ω and it's just not there?
20:49:52 <Cale> augur: Well, the latter are mathematicians :)
20:50:02 <Cale> augur: They're crazy too, just in a different way.
20:50:29 <kmc> god created trees, the rest is the work of man
20:50:37 <augur> Cale: goebel is a mathematician
20:50:40 <augur> ?
20:50:58 <Cale> In this case
20:51:23 <Cale>   	
20:51:24 <Cale> F. Goebel, On a 1-1-correspondence between rooted trees and natural numbers, J. Combin. Theory, B 29 (1980), 141-143.
20:51:24 <Cale> D. Matula, A natural rooted tree enumeration by prime factorization, SIAM Rev. 10 (1968). 
20:51:33 <codolio> In the usual foundations, every number is a tree.
20:51:43 <augur> uh huh
20:55:33 <kmc> succ t@(Node xs) = Node (t:xs)
20:56:09 <aristid> succ t xs = t : xs
20:56:53 <kmc> :t let succ xs = In xs : xs in succ
20:56:53 <lambdabot> [Mu []] -> [Mu []]
20:57:25 <kmc> :t let succ t@(In xs) = t:xs in succ
20:57:26 <lambdabot> Mu [] -> [Mu []]
20:57:33 <kmc> :t let succ t@(In xs) = In (t:xs) in succ
20:57:34 <lambdabot> Mu [] -> Mu []
20:57:49 <EvanR> can i 'take' from the end of a byte string?
20:58:18 <EvanR> i need to drop the last few bytes but its long
20:58:43 <Axman6> isn't the length of a bytestring a pretty quick thing to calculate?
20:58:52 <EvanR> length yes
20:59:09 <EvanR> take wont memcpy the whole chunk?
20:59:14 <Axman6> so take (length xs - n) xs?
20:59:15 <codolio> What kind of bytestring?
20:59:20 <EvanR> strict
20:59:23 <kmc> ByteString = buffer ptr + offset + length
20:59:29 <kmc> so chopping off either end should be cheap
20:59:34 <EvanR> nice
20:59:56 <kmc> buffer ptr * offset * length that is ;D
21:00:00 * hackagebot statistics 0.8.0.3 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.8.0.3 (BryanOSullivan)
21:00:05 <codolio> @hoogle takeEnd
21:00:05 <lambdabot> No results found
21:00:25 <kmc> will Hackage 10,000 XP contain changelogs?
21:08:18 <freedrull> i dont understand the type of runParser: runParser :: GenParser tok st a -> st -> FilePath -> [tok] -> Either ParseError a
21:08:28 <freedrull> whats the [tok] for? arent the tokens obtained from FilePath ????
21:09:39 <kmc> the path is used only for displaying error messages
21:15:28 <identity> Is there a way to write modular haskell programs that would allow you load modules written in haskell without having to deal with dynamic loading of shared objects/DLLs and so on? Similar to the way perl modules work, I guess, if I remember how they work correctly.
21:15:57 <identity> I realize that this could possibly be done with whatever module lambdabot uses to run haskell code, but that's not quite what I mean
21:16:55 <Pseudonym> GHCi can load .o files, too.
21:17:21 <identity> Yeah, I know, but I'm not sure if that's what I'm thinking
21:17:36 <identity> I guess that there's no real way to do this without the dirty shared object/DLL stuff
21:18:27 <michaelb3> Is there a good wmi module out there for Haskell?
21:19:10 <tolkad> Does anyone know of a monad for having mutable dynamic variables accessed by name?
21:20:41 <kmc> identity, sounds like something the 'plugins' package can do
21:20:57 <kmc> there's also direct-plugins, hint, and mueval
21:21:03 <kmc> michaelb3, what's wmi?
21:21:17 <michaelb3> Windows management instrumentation
21:21:20 <tolkad> preferably monadtrans
21:21:36 <michaelb3> used for controlling Win32 programmably 
21:22:13 <tommd> Any windows users willing to run a quick tests?
21:22:41 <tommd> s/tests/test/
21:23:03 <identity> kmc: oh!
21:23:04 <identity> thanks
21:23:28 <EvanR> tolkad: the PHP monad
21:24:28 <kmc> tolkad, name being a string?
21:24:40 <kmc> newIORef and the like create values which can be thought of as "names" for cells
21:24:45 <kmc> but they're opaque
21:24:52 <kmc> and can't be serialized
21:25:57 <EvanR> IORef Dynamic \o/
21:26:23 <michaelb3> for example something like this - http://haskell.forkio.com/com-examples
21:26:58 <michaelb3> I guess that would work.. it just seems there would be more
21:28:40 <michaelb3> perhaps Im thinking of haskell in the wrong way...
21:28:51 <tolkad> hmm, I'm giong to think about this a bit lol
21:28:51 <michaelb3> can it not be used for scripting?
21:28:58 <EvanR> just hope that haskell doesnt think of you in the wrong way
21:29:03 <EvanR> could be nasty
21:29:19 <EvanR> what is 'scripting' ?
21:29:20 <michaelb3> true EvanR
21:29:40 <michaelb3> something similar to python, Im looking for a faster python essentially
21:29:51 <michaelb3> but dont want to go to C
21:29:57 <kmc> yup it's quite good for stuff like that
21:30:04 <EvanR> a big difference is haskell is statically typed
21:30:08 <kmc> but any particular bit of Windows may or may not be supported
21:30:21 <michaelb3> is the user base much smaller?
21:30:27 <kmc> a big difference is Haskell has a steep learning curve, you won't be writing useful scripts 5 minutes in
21:30:28 <kmc> yes
21:30:33 <michaelb3> seems like on windows, it has almost nothing
21:30:51 <kmc> http://hackage.haskell.org/package/Win32
21:31:28 <michaelb3> Thanks kmc! That's exactly what I was looking for
21:31:36 <kmc> comes with Haskell Platform
21:31:46 <michaelb3> sweet
21:31:51 <kmc> michaelb3, you might want to browse http://hackage.haskell.org/packages/archive/pkg-list.html
21:33:03 <michaelb3> wow this is everything i wanted, beautiful - if I can have access to win32, then I can for sure do smi
21:33:04 <michaelb3> wmi*
21:33:19 <kmc> you can also call C functions directly
21:33:27 <kmc> there's a whole chapter in RWH about it
21:33:27 <michaelb3> I was looking into that
21:33:28 <kmc> @where rwh
21:33:28 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:33:39 <kmc> that's a good intro
21:33:50 <kmc> see ezyang's blog posts about c2hs if you have to wrap a really complex C API
21:33:55 <michaelb3> thats the one Im reading now, so far really good
21:33:55 <EvanR> seems like 'scripting' means you are ok with 'not a faster python'
21:34:19 <michaelb3> Ive already done some test with python vs haskell, and haskell seems much faster 
21:35:10 <EvanR> mmm reference counting
21:35:22 <michaelb3> what Im looking for is something i can use cross platform, easily can create standalone applications - and runs faster than ruby at least... 
21:35:28 <kmc> Haskell and Python have no speed; they are languages
21:35:39 <kmc> GHC-generated code is much faster than CPython-interpreted code
21:35:46 <kmc> in many cases
21:35:47 <EvanR> 5mph
21:35:51 <michaelb3> lol
21:35:58 <michaelb3> Python is much slower at calculations
21:36:01 <kmc> but, there's (experimental) compilers for Python, and there's slow interpreters for Haskell
21:36:07 <identity> michaelb3: Technically, the implementation is
21:36:11 <kmc> in particular GHCi is a lot slower than compiled GHC code
21:36:14 <identity> i.e. the fact that it's interpreted makes it slower
21:36:21 <kmc> and ghc -O is a lot faster than ghc without -O
21:36:44 <tolkad> hmm, I'm not sure how to make type level strings with any reasonable syntax
21:36:57 <michaelb3> the other issue is that to compile python to an exe I have to use something like py2exe and have all these other files associated with it, makes it even slowr
21:36:59 <michaelb3> slower*
21:37:24 <kmc> tolkad, pity there's no Template Haskell type splices
21:37:33 <EvanR> dlls dont make things slower
21:38:02 <michaelb3> I didnt say they did
21:38:16 <michaelb3> but compiling with ghc and py2exe... I see a big difference
21:38:36 <EvanR> gah is it really too slow or... *goes insane*
21:39:41 <ClaudiusMaximus> hm, without inserting calls to 'yield' in my forkIO'd threads my 'main' runs for 2 minutes (when all it does is make a few threads before 'threadDelay$1*1000*1000' and exits)
21:39:55 <tolkad> michaelb3: remember what is really important is complexity
21:39:56 <michaelb3> if I want to loop through a list in python... lets say 25,000 users.. and I want to pull out names and phone numbers for an example... python is much slower - Im not sure why
21:40:21 <tolkad> michaelb3: nobody cares if it takes 30 minutes for your application to render a frame as long as it scales well
21:40:34 <michaelb3> my boss cares
21:40:37 <EvanR> use a relational database
21:41:52 <michaelb3> have you guys seen this http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=python3
21:42:09 <tolkad> EvanR: but what about nosql being webscale?
21:42:24 <EvanR> weh?
21:43:01 <EvanR> jargon overload
21:43:26 <michaelb3> looks at step 3
21:43:43 <michaelb3> cpu secs and elapsed secs...
21:43:50 <EvanR> no sql doesnt imply no relational
21:46:37 <tolkad> EvanR: I found some blog that says that relational databases don't scale: http://blogs.talis.com/nodalities/2009/06/pwc.php
21:47:07 <EvanR> after reading about 'nosql' it seems that i indeed implies no relational
21:47:12 <EvanR> and is a misnomer
21:47:18 <EvanR> it*
21:48:37 <Cale> http://www.xtranormal.com/watch/6995033/
21:48:43 <Cale> I'll just leave that there
21:52:54 <EvanR> infuriating
21:56:03 <EvanR> *goes insane*
21:56:21 <EvanR> i dont know anything about the issue and i already have strong opinions on it
21:56:25 <EvanR> must be web development
22:02:37 <Cale> http://adrianotto.com/2010/08/dev-null-unlimited-scale/
22:03:11 <A1kmm> Anyone seen this error from the RTS when using the GHC API? "internal error: evacuate: strange closure type 0"
22:03:14 <tolkad> "Plus, the work of computer programmers requires little localized or specialized knowledge. All you have to know is the computer language." - http://finance.yahoo.com/career-work/article/110958/disappearing-jobs?mod=career-worklife_balance
22:03:34 <tommd> wow
22:03:40 <tolkad> : ( I'm studying CS in college, I thought CS degrees were respected
22:03:44 <A1kmm> (which GHC 6.12.3)
22:03:46 <c_wraith> Cale: that's the default database engine of mySQL, right?
22:04:07 <A1kmm> s/which/with/
22:04:26 <Cale> A1kmm: Try cleaning up any old .hi and .o files and building again.
22:04:32 <Cale> Errr...
22:04:37 <Cale> Oh, GHC API hmm...
22:05:03 <Cale> There might be some other ways to make that happen with the GHC API. I don't know.
22:05:42 <Cale> "Computer programmers, the guys who write the instructions for a computer to use that software" -- CNBC
22:06:46 <EvanR> what the hell is sharding
22:07:35 <A1kmm> Cale: I tried deleting dist/ (which contains all the .hi and .o) and rebuilding and it still happens.
22:10:18 <A1kmm> (this is in the program that calls the GHC API, not the target, the target is interpreted and linked in-memory so has no .hi / .o files)
22:16:37 <JoshTriplett> Any sensible way to access fcntl locking without calling handleToFd and thus closing the Handle?
22:22:01 <Cale> JoshTriplett: What are you trying to do with fcntl?
22:22:35 <JoshTriplett> Cale: Trying to help someone learning Haskell who has a strong background in writing correct C-based UNIX utilities, and wants to do proper file locking.
22:23:39 <c_wraith> JoshTriplett, you can always open a new handle from the FD
22:23:54 <Cale> Well, the default is to do multiple reader, single writer locking on files.
22:23:58 <tolkad> JoshTriplett: http://www.haskell.org/haskellwiki/FFI_Introduction
22:24:15 <JoshTriplett> c_wraith: Granted, and the current solution he has calls handleToFd and fdToHandle which closes and opens the file.  That just seems *wrong* though in several different ways.
22:24:37 <JoshTriplett> tolkad: That would help me call fcntl itself, yes.  Doesn't help me do it on a Haskell "Handle".
22:24:42 <JoshTriplett> Cale: ...huh.
22:24:49 <JoshTriplett> Cale: That seems somewhat magic.
22:25:00 <JoshTriplett> Cale: Any reference for precisely what Haskell (or GHC) does?
22:25:13 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-IO.html#8
22:25:27 <JoshTriplett> Cale: Yeah, I saw that, hence my use of the word "precisely". ;)
22:25:31 <EvanR> any news on when the ugly logo will be updated on haskell.org
22:25:37 <JoshTriplett> Cale: That mostly says "Implementations should do locking".
22:25:57 <JoshTriplett> Cale: I want to know precisely what locking it will do, not least of which because it needs to interact properly with other things not necessarily written in Haskell.
22:26:11 <Cale> It's probably at least somewhat OS dependent.
22:26:21 <JoshTriplett> Cale: I'd originally assumed that paragraph just described Haskell runtime locking, not OS-level locking.
22:26:26 <JoshTriplett> Cale: Certainly.
22:26:39 <JoshTriplett> Cale: In my case I care about POSIX, though knowing what it does on other platforms would prove interesting too.
22:26:51 <JoshTriplett> Cale: Just hoping the answer doesn't start with "Go look at the implementation". ;)
22:27:01 <EvanR> the posix module probably has links to source
22:27:15 <JoshTriplett> EvanR: Right, that kind of answer, yes. ;)
22:27:25 <JoshTriplett> I can live with that; just wondered if some canonical reference existed.
22:27:32 <EvanR> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/unix-2.4.0.1/src/System-Posix-Unistd.html#sleep
22:27:37 <EvanR> example
22:27:56 <EvanR> its usually pretty easy to read
22:28:05 <EvanR> even if you dont know the ffi
22:28:28 <JoshTriplett> EvanR: I've worked with FFI fairly extensively.
22:28:53 <EvanR> normally id ask then why you are asking on irc what its exactly doing
22:30:16 <JoshTriplett> EvanR: Because I don't always want to rely on the implementation source code as the correct way to solve every problem.  Sometimes documentation exists which explains the intent, or portable assumptions, or a generally higher-level view. :)
22:30:47 <EvanR> in cases like this the documentation would take up more space than the implementation
22:31:46 <EvanR> documentation can be wrong
22:32:00 <JoshTriplett> EvanR: Yes, because every user of Haskell should find and read the implementation for the relevant pieces of the runtime they want to use...oh wait. ;)
22:32:29 <JoshTriplett> EvanR: In any case, not trying to argue for the existence of documentatoin, just asking if any such document existed already.  Sounds like "no".
22:32:31 <JoshTriplett> No problem.
22:32:56 <EvanR> well thats what i had to do to find that the hdbc-mysql bindings had a major bug and it wasnt my fault
22:33:11 <EvanR> and im not a master haskeller
22:33:20 <EvanR> if i didnt do that i would have been shit up a creek
22:33:53 <JoshTriplett> EvanR: Funny, I had the same problem with HDBC-psql a few weeks ago. ;)
22:34:16 <JoshTriplett> EvanR: (parsing of time differences that had days in them.)
22:34:26 <EvanR> i figured one bug related to just wrong ffi usage
22:34:43 <EvanR> but another is more systemic and results in exhausting all of memory when reading a long blob data
22:34:51 <EvanR> s/figured/fixed/
22:35:00 <fpqc> why don't you guys stop using haskell and just do real math or real programming
22:35:17 <kmc> a witty and sophisticated argument
22:35:25 <fpqc> yes.
22:35:37 <fpqc> well, it's the beginning of the argument
22:35:37 <kmc> if only haskell were good for something practical, like flying airplanes, or designing microchips
22:35:56 <fpqc> yeah, but so are other programming languages that are more efficient
22:36:12 <JoshTriplett> must...resist...feeding...troll...
22:36:16 <fpqc> and real math doesn't require that you work with constructive types
22:36:27 <EvanR> JoshTriplett: so 'converting a handle into df effectively means letting go of the handle; it is put into a closed state as a result'
22:36:33 <EvanR> looks like documentation
22:36:47 <EvanR> s/df/fd/
22:37:08 <fpqc> You guys are familiar with the hilbert quote right?
22:37:27 <JoshTriplett> EvanR: Yeah, I found that much.  That makes the assumption that Haskell has to flush all of its buffers in order to hand you an Fd, so you can't possibly do output that interferes with what it has buffered.  On the other hand, if you just want to call fcntl, that preventative assumption doesn't necessarily apply.
22:37:34 <kmc> "why don't you guys stop using haskell and just do real math or real programming" -- David Hilbert
22:37:42 <EvanR> that took three lines, and three lines of code is flush, release, and return . construct a handle
22:38:18 <JoshTriplett> EvanR: Yeah, I'd already read that function before I came here. ;)
22:38:23 <EvanR> if youre using fcntl, maybe its a good idea to do all the low level i/o yourself
22:38:29 <EvanR> no handles
22:38:59 <fpqc> "Taking the principle of excluded middle from the mathematician would be the same, say, as proscribing the telescope to the astronomer or to the boxer the use of his fists. To prohibit existence statements and the principle of excluded middle is tantamount to relinquishing the science of mathematics altogether."
22:39:00 <JoshTriplett> EvanR: I'd much rather do high-level IO only; I just need a bit of functionality not exposed by the high-level API. :)
22:39:40 <EvanR> Network is the same way
22:40:01 <EvanR> its dead simple to use, but anything slightly 'advanced' means you just landed in the BSD sockets api
22:40:21 <EvanR> good place for a library
22:40:31 <fpqc> "Taking the principle of excluded middle from the mathematician would be the same, say, as proscribing the telescope to the astronomer or to the boxer the use of his fists. To prohibit existence statements and the principle of excluded middle is tantamount to relinquishing the science of mathematics altogether."
22:40:31 <fpqc> "Taking the principle of excluded middle from the mathematician would be the same, say, as proscribing the telescope to the astronomer or to the boxer the use of his fists. To prohibit existence statements and the principle of excluded middle is tantamount to relinquishing the science of mathematics altogether."
22:41:23 <fpqc> actually, just do real math
22:41:28 <fpqc> not this programming farce
22:41:44 <JoshTriplett> fpqc: #math is -> that way.
22:41:52 <dbelange> fpqc: Are you doing scientific computations in haskell
22:41:55 <kmc> fpqc, i think it's funny that your objection with Haskell's type system logic is that it's constructive, and not that it's unsound
22:42:12 <fpqc> I'm against type systems
22:42:12 <kmc> i mean, you can easily prove the Law of the Excluded Middle in Haskell's type system
22:42:21 <JoshTriplett> kmc: Not that funny, if you think about it; fpqc seems to object to doing anything constructive. ;)
22:42:27 <systemfault> Is a IRC bot a good first haskell project?
22:42:27 <kmc> hehe
22:42:33 <JoshTriplett> systemfault: Sure.
22:42:43 <JoshTriplett> systemfault: Depends on what you want to learn.
22:42:43 <systemfault> I don't really do scientific or math stuff so..
22:42:46 <kmc> systemfault, define "project".  i'd advise dicking around in ghci for a while before writing a standalone program
22:42:56 <JoshTriplett> I'll second that particular advice, yeah.
22:42:58 <fpqc> you guys know that type theory was invented by a nazi
22:43:06 <dbelange> Who are the big names in haskell these days anyway
22:43:06 <fpqc> (not counting russell)
22:43:13 <dbelange> I know Simon Peyton-Jones
22:43:14 <fpqc> jewy-jewenson
22:43:15 <JoshTriplett> Yay, godwin's law, we can stop now. ;)
22:43:17 <kmc> you know the pope was a nazi too
22:43:18 <dbelange> and why the lucky stiff
22:43:30 <fpqc> yeah
22:43:32 <kmc> as was basically every non-dead german at the time, whether they like it or not
22:43:32 <dbelange> but that's it
22:43:33 <fpqc> fuck the pope
22:43:42 <fpqc> kmc bullshit
22:43:47 <EvanR> are advanced math trolls common? i dont think ive ever seen one before
22:43:53 <fpqc> Emil Artin was not a nazi
22:43:58 <systemfault> kmc's kind of right..
22:44:03 <fpqc> Emil Artin was not a nazi
22:44:04 <fpqc> Emil Artin was not a nazi
22:44:07 <kmc> great
22:44:15 <dbelange> What was he then
22:44:18 <kmc> @ops
22:44:19 <lambdabot> Maybe you meant: docs oeis pl
22:44:20 <fpqc> he emigrated
22:44:21 <kmc> @where ops
22:44:21 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
22:44:24 <fpqc> to the US
22:44:27 <JoshTriplett> kmc: thank you. :)
22:44:28 <fpqc> instead of becoming a nazi
22:44:33 --- mode: ChanServ set +o Pseudonym
22:44:34 --- mode: ChanServ set +o Cale
22:44:40 --- mode: Cale set +b *!*@unaffiliated/scheme
22:44:40 --- kick: fpqc was kicked by Cale (fpqc)
22:44:45 <kmc> good times
22:44:46 * JoshTriplett claps
22:44:48 <Pseudonym> Frege was a nazi.
22:44:50 <kmc> sorry if i fed him too much
22:44:54 --- mode: ChanServ set -o Pseudonym
22:44:57 <Pseudonym> That's actually true.
22:44:57 * systemfault whistles the final fantasy fanfare
22:44:58 <JoshTriplett> Cale++
22:45:03 <kmc> what about Freyja?
22:45:04 --- mode: Cale set -o Cale
22:45:16 <EvanR> systemfault: you just got 387918234 XP
22:45:21 <JoshTriplett> systemfault: http://www.youtube.com/watch?v=t8NsnLfIAcs
22:45:34 <systemfault> EvanR: Damn.. I'm already 99 :(
22:45:40 <Pseudonym> http://en.wikipedia.org/wiki/Gottlob_Frege#Political_views_and_National_Socialism
22:45:51 <kmc> «<kmc> you know the pope was a nazi too <dbelange> and why the lucky stiff»  hilarity out of context
22:46:03 <systemfault> JoshTriplett: wtf :P
22:46:08 <JoshTriplett> systemfault: So, I'd agree that you want to experiment with ghci at first, to get comfortable with the basic language syntax.
22:46:16 <tolkad> JoshTriplett: http://codepad.org/2Ni3XIv7
22:46:21 <tolkad> JoshTriplett: maybe something like that?
22:46:30 <EvanR> systemfault is already a haskell veteran
22:46:32 <tolkad> sorry if that's completely wrong
22:46:39 <EvanR> he is misleading you!
22:46:42 <systemfault> EvanR: Haha, not really :)
22:46:44 <kmc> great
22:47:14 <EvanR> youre the one who explained to be automaton arrows right
22:47:17 <EvanR> to me*
22:47:23 <JoshTriplett> tolkad: Yeah, that seems like approximately the right way to do this, assuming it interacts properly with whatever locking GHC's runtime already does.
22:47:26 <systemfault> No way :/
22:47:27 <JoshTriplett> tolkad: thanks. :)
22:47:29 <EvanR> oh
22:47:56 <EvanR> twilight zone
22:48:03 <JoshTriplett> systemfault: So, re IRC bots: you can find a handful of libraries already for dealing with IRC, which makes an IRC bot a fun alternative to doing console IO.
22:48:34 <JoshTriplett> systemfault: Similarly, writing a CGI program works rather well for experimentation.
22:48:44 <JoeyA> Going back to yesterday's discussion about Fω not liking the fixpoint combinator (in Milner's paper, he talks about it too), is the problem that type inference of fixpoint combinators with lambda calculus is undecidable, or just semantically unsound?
22:48:59 <systemfault> JoshTriplett: Good :)
22:49:11 <JoshTriplett> JoeyA: In general, you can't write some fixpoint combinators with proper types.
22:49:14 <EvanR> direct-fastcgi == awesome
22:49:33 <JoeyA> Though, if I understand correctly, as long as the fix function is already defined or you use a recursive structure a compiler recognizes, everything's hunky-dory and you can recurse.
22:49:34 <JoshTriplett> EvanR: ...wow.
22:49:45 <JoshTriplett> EvanR: That looks awesome, and I need to learn it immediately. :)
22:49:58 <EvanR> sarcastic?
22:50:00 <JoshTriplett> EvanR: As in, I had a conversation about how we can replace our use of the fastcgi module two days ago.
22:50:16 <JoshTriplett> EvanR: and really disliked how much that module tied in with the CGI monad.
22:50:24 <mm_freak> JoeyA: try to write a type-correct 'fix' by only using lambda abstraction
22:50:36 <JoshTriplett> EvanR: which doesn't work out so well when, among other things, you want an Arrow rather than a Monad. ;)
22:50:43 <kmc> JoeyA, I know you can't write 'fix' in System F, without it being given to you
22:50:50 <JoeyA> I've tried, and I saw the discussion about it yesterday, too.
22:50:57 <JoshTriplett> EvanR: So, thank you!
22:51:02 <EvanR> what?
22:51:04 <kmc> it's not too hard to prove that
22:51:08 <JoeyA> plz send me teh fix :-)
22:51:08 <kmc> in coq even
22:51:10 <mm_freak> :t \g -> (\x -> g (x x)) (\x -> g (x x))
22:51:12 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
22:51:12 <lambdabot>     Probable cause: `x' is applied to too many arguments
22:51:12 <lambdabot>     In the first argument of `g', namely `(x x)'
22:51:24 <EvanR> direct-fastcgi is a monad, or are you talking about automatic arrows
22:51:31 <EvanR> automaton
22:51:46 <mm_freak> JoeyA: you can write fix by using a newtype wrapper, i guess, but that's not really useful =)
22:51:47 <kmc> systems like (GHC) Haskell's are basically Fω + fix, but can't infer all types
22:51:56 <kmc> (inference is undecidable above rank 2, iirc)
22:51:58 <JoshTriplett> EvanR: I hadn't looked at direct-fastcgi yet.  Just saying FastCGI doesn't fit.
22:52:16 <EvanR> the author of direct had complaints about that one
22:52:37 <EvanR> i dont know all the issues, but i am enjoying direct, and its use of concurrency 'just makes sense'
22:52:44 <EvanR> i did have to fix two 'bugs'
22:52:47 <EvanR> so far
22:53:03 <JoshTriplett> EvanR: I already noticed that direct-fastcgi doesn't seem to have some hardcoded concurrency limit...
22:53:16 <JoshTriplett> So, definitely a win there...
22:53:16 <EvanR> why would it?
22:53:20 <JoeyA> So can type inference of Haskell98 be implemented in a fairly naive way?
22:53:42 <kmc> JoeyA, it's not too bad.  read "Typing Haskell in Haskell"
22:54:06 <kmc> there's a few complications
22:54:19 <kmc> such as polymorphic recursion
22:54:26 <mm_freak> is there a typed lambda calculus, which you can write 'fix' in?
22:54:38 <tolkad> why doesn't GHC let me have recursive types?
22:54:52 <kmc> tolkad, because they're almost always a mistake, and would complicate the type checker, and can always be encoded with a wrapper
22:54:53 <JoshTriplett> EvanR: Exactly.  But FastCGI does.
22:55:07 <EvanR> what is the limit just curious
22:55:07 <kmc> mm_freak, you mean without already including 'fix' or recursive 'let' or the like?
22:55:14 <mm_freak> kmc: yes
22:55:26 <kmc> i wonder if SysFω + eqi-recursive types admits 'fix'
22:55:30 <kmc> probably so
22:55:32 <tolkad> kmc: oh.
22:55:42 <mm_freak> :t In (Just (In (Just (In Nothing))))
22:55:42 <kmc> oleg wrote a paper about 5 different ways to write 'fix'
22:55:43 <lambdabot> Mu Maybe
22:55:57 <JoshTriplett> EvanR: You can specify it, but you have to give a number in the equivalent of acceptLoop.
22:56:00 <mm_freak> @ tolkad 
22:56:10 <kmc> mm_freak, http://okmij.org/ftp/Computation/fixed-point-combinators.html
22:56:27 <kmc> in particular http://okmij.org/ftp/Haskell/Fix.hs
22:56:59 <mm_freak> kmc: thanks
22:57:02 <tolkad> :k (->
22:57:02 <tolkad> a)
22:57:03 <lambdabot> parse error (possibly incorrect indentation)
22:57:05 <kmc> @remember OlegKiselyov Haskell is inconsistent in yet another way.
22:57:05 <lambdabot> Done.
22:57:07 <tolkad> :k (->)
22:57:08 <lambdabot> ?? -> ? -> *
22:57:32 <dbelange> @remember haskell sucks
22:57:32 <lambdabot> I will remember.
22:57:38 <EvanR> JoshTriplett: seems silly, our tests on our admitted small-type webserver show that for a sane application not more than several requests are happening at the same time, and forkIOs can easily get into the tens of thousands if i was informed correctly
22:57:39 <kmc> @quote haskell
22:57:39 <lambdabot> haskell says: sucks
22:57:44 <dbelange> oh
22:57:45 <EvanR> small-time
22:57:53 <kmc> @forget haskell sucks
22:57:53 <lambdabot> Done.
22:58:02 <kmc> @. elite nixon
22:58:02 <lambdabot> 5(rU88ing ph|oorz0rz 4nD 3MPTYInG b3dp4ns HAs as /\/\Uch DI9Ni7y 4z0rz t|-|e pRE5Id3N(Y.
22:58:04 <JoshTriplett> @quote haskell
22:58:04 <lambdabot> haskell says: Haskell - it's like a Lamborghini in the village. A little jerk - and went to work on the tractor.
22:58:06 <tolkad> type Fix x = x (Fix x)
22:58:14 <kmc> tolkad, no dice
22:58:24 <JoshTriplett> tolkad: You *might* manage something that insane with GADTs, but probably not. ;)
22:58:45 <JoshTriplett> tolkad: at a minimum, though, you'd need a wrapper at the outermost position.
22:58:47 <mm_freak> tolkad: newtype Fix t = Fix (t (Fix t))
22:58:51 <mm_freak> @src Mu
22:58:51 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
22:59:02 <kmc> tolkad, if you want to put ghc into an infinite loop, see the third bullet under http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/bugs.html#bugs-ghc
23:00:57 <kmc> :t let succ t@(In xs) = In (t:xs) in succ
23:00:58 <lambdabot> Mu [] -> Mu []
23:01:14 <mm_freak> :t In (\x -> In (\y -> In (\z -> undefined)))
23:01:15 <kmc> > let succ t@(In xs) = In (t:xs) in succ $ succ $ succ (In [])
23:01:15 <lambdabot>   In [In [In [In []],In []],In [In []],In []]
23:01:16 <lambdabot> forall t. Mu ((->) t)
23:01:22 <tolkad> type family Fix (x :: * -> *)
23:01:22 <tolkad> type instance Fix x = x (Fix x)
23:01:27 <tolkad> that works
23:02:02 <kmc> fsvo "works"
23:02:28 <kmc> GHCi> () :: Fix []
23:02:33 <kmc> <GHCi hangs>
23:03:11 <mm_freak> tolkad: that doesn't work
23:03:23 <mm_freak> try to compile a value of type Fix Maybe =)
23:03:26 <tolkad> mm_freak: it compiles
23:03:29 <tolkad> mm_freak: :P
23:03:41 <mm_freak> no, i'm serious
23:03:43 <kmc> i am surprised ghc accepts that code
23:03:51 <mm_freak> according to your code, Just (Just Nothing) should work
23:03:52 <kmc> i wonder if it hits the instance-resolution stack depth limit, or if there's a separate stack
23:04:06 <mm_freak> but try to compile that one =)
23:04:18 <mm_freak> test :: Fix Maybe; test = Just (Just Nothing)
23:04:19 <JoeyA> Why do papers often say "we" when there's only one author?  Is that a common style rule, or is it to acknowledge contributions of anonymous people (e.g. thesis paper faculty)?
23:04:32 <kmc> JoeyA, the former and maybe the latter too
23:04:38 <tolkad> mm_freak: it's taking a while
23:04:46 <mm_freak> tolkad: "a while" = forever
23:04:47 <tolkad> mm_freak: I'll tell you when it finishes
23:04:55 <kmc> JoeyA, the royal "we"
23:05:01 <tolkad> mm_freak: oh, just be patient -_-
23:05:12 <JoeyA> Though I suppose "we" is nicer because it refers to both the author and the reader.
23:05:16 <JoeyA> e.g. "as we shall see"
23:05:16 <kmc> "I! The royal "we"!  You know, the editorial..."
23:05:25 <kmc> yes
23:05:59 <mm_freak> i wonder, too, why GHC accepts the code at all
23:06:06 <mm_freak> but at least it wants UndecidableInstances
23:06:06 <tolkad> :t State
23:06:07 <lambdabot> forall s a. (s -> (a, s)) -> State s a
23:06:18 <JoeyA> or "we" could refer to the university or business the author belongs to or is employed by.
23:06:27 <kmc> mm_freak, since families are open, it might be at least a little tricky to do loop checking
23:06:36 <kmc> and in the general case the presence of a loop is undecidable
23:06:47 <mm_freak> yeah
23:07:03 <mm_freak> you can use this for type level programming, right?
23:07:14 <ClaudiusMaximus> :t yield
23:07:15 <lambdabot> Not in scope: `yield'
23:07:22 <ClaudiusMaximus> :t Control.Concurrent.yield
23:07:22 <lambdabot> IO ()
23:08:13 <kmc> yup mm_freak
23:08:40 <ClaudiusMaximus> hm, the docs say:  "allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads"
23:08:54 <ClaudiusMaximus> does GHC force a context switch on yield?
23:09:16 * ClaudiusMaximus being bitten by the "tight loops that don't allocate can't be pre-empted" issue, as far as i can tell
23:11:09 <EvanR> hmmmmmm
23:11:19 <ClaudiusMaximus> too much yield => productivity drops; too little yield => possible infinite loop...
23:12:13 <EvanR> is there a way to 'lazilly' compute length xs > n without traversing more than n things
23:12:23 <ClaudiusMaximus> lazy numbers!
23:12:32 <ClaudiusMaximus> :t genericLength
23:12:33 <lambdabot> forall b i. (Num i) => [b] -> i
23:13:04 <lispy> :t genericLength [1..10] :: Int -> Int
23:13:05 <lambdabot> Int -> Int
23:13:10 <ClaudiusMaximus> > null . drop 5 $ [1..20]
23:13:11 <lambdabot>   False
23:13:11 <EvanR> wow always fun to see crazy questions have actual answers
23:13:42 <kmc> EvanR, «data Nat = Zero | Succ Nat» with appropriate Num
23:13:46 <identity> @src second
23:13:46 <lambdabot> Source not found. You speak an infinite deal of nothing
23:13:53 <identity> thank you.
23:14:01 <kmc> will allow things like «genericLength [1..] > (5 :: Nat) == True»
23:14:13 <ClaudiusMaximus> @src (->) second
23:14:14 <lambdabot> second f = id *** f
23:14:24 <identity> Ah, thanks
23:14:36 <EvanR> in that case does it theoretically make sense for that to be true
23:14:48 <EvanR> _|_ > 5 ? :)
23:14:57 <kmc> [1..] isn't ⊥
23:15:05 <EvanR> genericLength [1..]
23:15:17 <kmc> is not ⊥ either
23:15:21 <kmc> in general
23:15:24 <EvanR> its...
23:15:31 <EvanR> an infinite natural
23:15:42 <kmc> for a flat type like Int, it probably has to be bottom
23:15:58 <kmc> but (fix Succ) is not ⊥, and (fix Succ > 5) evaluates to True in finite time
23:16:06 <ClaudiusMaximus> > length [ -2 .. maxBound :: Int] 
23:16:09 <lambdabot>   mueval-core: Time limit exceeded
23:16:19 <kmc> (if you write (>) in the obvious way)
23:16:22 <kmc> try it :D
23:16:29 <Cale> > maxBound :: Int
23:16:29 <lambdabot>   9223372036854775807
23:16:38 <Cale> Int is big on lambdabot's machine
23:16:52 <kmc> > log (fromIntegral (maxBound :: Int)) / log 2
23:16:52 <lambdabot>   63.0
23:16:53 <ClaudiusMaximus> mine too, i keep forgetting about those extra bits
23:17:35 <ClaudiusMaximus> > length "log x / log 2" > length "logBase 2 x"
23:17:35 <lambdabot>   True
23:18:30 <Cale> > length "log x / log 2" - length "logBase 2 x"
23:18:31 <lambdabot>   2
23:18:42 <ClaudiusMaximus> can delete 2 whitespaces then...
23:18:44 <Cale> (does that warrant an extra definition?)
23:18:52 <Cale> yeah
23:18:57 <ClaudiusMaximus> @hoogle log2
23:18:58 <lambdabot> No results found
23:19:06 <ClaudiusMaximus> @hoogle log10
23:19:06 <lambdabot> No results found
23:19:27 <Cale> The only log really worth caring about is the natural one, and we get all the others easily enough like that :)
23:19:45 <kmc> :t logbase
23:19:45 <lambdabot> Not in scope: `logbase'
23:19:46 <kmc> :t logBase
23:19:47 <lambdabot> forall a. (Floating a) => a -> a -> a
23:20:17 <ClaudiusMaximus> > logBase (0:+2) 3.5
23:20:18 <lambdabot>   0.2945699094613826 :+ (-0.6675484583122079)
23:20:28 <Cale> It makes me profoundly happy that Haskell doesn't use that awful ln notation :)
23:21:03 <ClaudiusMaximus> :info (:+)
23:21:09 <kmc> > length $ takeWhile (< (fromIntegral (maxBound :: Int))) $ iterate (*2) (1 :: Integer)
23:21:09 <lambdabot>   63
23:21:21 <kmc> > length $ takeWhile (< (fromIntegral (maxBound :: Int))) $ iterate (*2) (1 :: Word16)
23:21:25 <lambdabot>   mueval-core: Time limit exceeded
23:21:29 <kmc> > length $ takeWhile (< (fromIntegral (maxBound :: Word16))) $ iterate (*2) (1 :: Integer)
23:21:30 <lambdabot>   16
23:21:49 <ClaudiusMaximus> don't like :+ fixity
23:23:45 <ClaudiusMaximus> maybe 1 thread per pixel isn't the best way to render images, but it sure makes the code look simple :)
23:24:02 <kmc> it is the best way!
23:24:20 <kmc> if you need to limit the actual parallelism, may i humbly suggest my 'pool' function from http://hackage.haskell.org/packages/archive/spawn/0.2/doc/html/Control-Concurrent-Spawn.html
23:24:44 <kmc> i had a problem where the naive one-thread-per-datum solution resulted in too much memory usage
23:24:59 <kmc> this solution let me keep the nice structure but limit the actual number of threads which have started but not finished
23:25:14 <kmc> it also has a weird type, which i like
23:25:21 <ClaudiusMaximus> well i've limited it already, by only starting to render pixels when a neighbour has terminated
23:26:05 <tolkad> why wont my code compile? http://pastebin.com/x4hWYFTD
23:26:11 <tolkad> It doesn't give me an error messag
23:26:13 <tolkad> message*
23:26:17 <tolkad> it just gets stuck
23:27:20 <kmc> did you read the link i sent just a short while ago?
23:27:29 <tolkad> yeah
23:27:32 <identity> If I say "Where have continuations been put into use in some nifty way?" what pops up in your mind?
23:27:32 <kmc> so
23:27:37 <identity> s/say/ask/
23:27:48 <kmc> identity, implementing LogicT
23:27:56 <kmc> (logic programming monad transformer)
23:28:02 <identity> Ah, don't quite now that one
23:28:08 <identity> I'll take a look though
23:28:11 <kmc> implementing monad-ran, which optimizes monad-transformers tacks using right Kan extensions
23:28:30 <JoeyA> that program makes both ghc and hugs get stuck.
23:28:43 <kmc> identity, on a smaller scale, i wrote a tiny s-expression parser (standalone, no Parsec or anything) and used continuations rather than returning tuples
23:28:47 <tolkad> kmc: if I add a $ it compiles though: http://pastebin.com/yGTjJZ0F
23:29:22 <kmc> the code was a little shorter and i extended it more easily to handle errors
23:29:33 <tolkad> which is kind of scary actually, I thought $ had no effect on the optimization of my code
23:29:41 <kmc> tolkad, you're in known-ghc-bug territory here
23:29:42 <Pseudonym> @google monadic constraint programming
23:29:44 <lambdabot> http://tomschrijvers.blogspot.com/2009/01/monadic-constraint-programming.html
23:29:44 <lambdabot> Title: Tom's Declarative Languages Blog: Monadic Constraint Programming
23:29:54 <Pseudonym> Also a good example of continuations.
23:29:55 <JoeyA> kmc: it also happens in hugs.
23:30:08 <kmc> ($) is not so innocent, it can also make stuff with runST fail to typecheck
23:30:36 <Dae_> Curious.... the nbody shootout program runs 7 times slower on windows than on linux....
23:31:08 <tolkad> kmc: : / why not just make it syntax instead of a function? it would be backwards compatible and fix these problems
23:31:36 <kmc> because we don't want to add syntax to the language unless absolutely necessary
23:31:40 <kmc> Haskell already has too much syntax, imo
23:31:45 <kmc> "if then else" should die
23:32:00 <kmc> and there's no nice way to add syntax without diving into implementation guts
23:32:01 <systemfault> kmc: Replaced by guards?
23:32:03 <tolkad> well, I guess it wouldn't be backwards compatible with modules not implementing prelude
23:32:11 <tolkad> importing*
23:32:22 <tolkad> most modules don't implement Prelude :P
23:32:24 <kmc> systemfault, 60% of noob uses of if-then-else should be pattern matching a list or something
23:32:47 <systemfault> kmc: Yeah... they're familiar keywords :P 
23:32:52 <kmc> the rest can be guards, case, or an ordinary Prelude function «if :: Bool → a → a → a»
23:33:17 <kmc> it would drive home the fact that "short circuiting" happens on every function, not just built-in magic
23:33:51 <systemfault> Question.. since when GHC supports unicode in the language??
23:33:57 <kmc> since a while ago?
23:34:17 <tolkad> I'm scared to use the inline pragma because it says it will exclude things from being inlined into that function. this is a really annoying restriction. does it mean functions like (.) or ($) wont be inlined?
23:34:49 <tolkad> it's really ridiculous to have function overhead for ($)
23:35:20 <tolkad> and there are situations where $ really helps syntatically, e.g. before a do block
23:35:37 <kmc> oh man, new proposed UnicodeSyntax:  2. The star '★' is allowed instead of '*' in kind signatures.
23:35:43 <kmc> For TemplateHaskell?: ⟦ ⟧ (MATHEMATICAL _ WHITE SQUARE BRACKET) can be used instead of [| |]
23:35:46 <kmc> helllllllls yes
23:36:41 <JoeyA> What is [| |] ?
23:36:47 <tolkad> we could allow ♥ to be used in place of ->
23:36:48 <kmc> template haskell expression quotation
23:36:54 <kmc> Int ♥ Char
23:36:55 <JoeyA> oh
23:36:55 <kmc> how romantic
23:36:58 <JoeyA> lol
23:37:05 <kmc> type (:♥) = (->)
23:37:12 <kmc> that looks like a fucked up smiley tho
23:37:26 <Twey> Grr
23:37:29 <Twey> 07:32:27 < kmc> the rest can be guards, case, or an ordinary Prelude function «if :: Bool → a → a → a»
23:37:41 <JoeyA> ->♥ is what cupids do.
23:37:46 <Twey> (??) :: a -> a -> Bool -> a
23:37:47 <kmc> ♥ → ☭
23:37:53 <Twey> Is much more useful, currying-wise
23:37:57 <Adamant> no, you need an arrow for cupids
23:37:57 <kmc> true
23:38:03 <JoeyA> String -> Int reads "String begot Int"
23:38:09 <Adamant> kmc: poor ol' doomed Bill The Communist Cat
23:38:14 <Twey> Haha
23:38:25 <Adamant> oh that's excellent
23:38:25 <JoeyA> :t map
23:38:26 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:38:35 <Adamant> we need Old Testament-isms
23:38:37 <kmc> systemfault, anyway, the Haskell 98 spec allows Unicode symbols in identifiers.  GHC extends that to allow Unicode to stand for certain keywords, like → for -> and ∀ for forall
23:38:49 <systemfault> Haha, nice :D
23:39:12 <systemfault> kmc: Have you made some special mappings to get these characters?
23:39:14 <JoeyA> a begetting b is what begat [a], which in turn begat [b]
23:39:17 <kmc> yes systemfault
23:39:25 <Dae_> kmc, ohh, it will be like lolcode, only with smileys!
23:39:26 <systemfault> It's nice :P
23:39:36 <Adamant> JoeyA: yea, unto the 7th generation
23:39:41 <kmc> systemfault, http://hpaste.org/40418/composein http://hpaste.org/40417/mkcomposehs
23:39:42 <JoeyA> lol
23:40:11 <tolkad> ♐ ♥
23:40:30 <Adamant> some call tolkad the space cowboy
23:40:41 <JoeyA> except you have to have a newline with  ♥ properly indented, or you get "parse error on input"
23:41:01 <JoeyA>  ♥
23:41:02 <JoeyA> ♐
23:41:05 <kmc> ⚛ ♥ ♀
23:41:22 <JoeyA> the ♥ I posted wasn't indented enough.
23:41:31 <Adamant> I think we are missing something important here
23:41:34 <Adamant> SNOWMAN
23:41:38 <JoeyA> lol
23:42:05 <lispy> > text "♥"
23:42:06 <lambdabot>   ♥
23:42:06 <JoeyA> (∀ a. a -> ☃)
23:42:30 <lispy> > text "I ♥ ☃"
23:42:31 <lambdabot>   I ♥ ☃
23:43:06 <systemfault> kmc: Perhaps I'm just dumb but what is mkcomposehs?
23:43:28 <kmc> systemfault, turns the other file into a format suitable for ~/.XCompose
23:43:32 <kmc> sorry, i gave you no context there
23:43:34 <tolkad> ✈  ❙ ❙
23:43:39 <systemfault> Ah!
23:44:10 <systemfault> ./mkcomposehs < compose.in then?
23:44:14 <kmc> yep
23:47:02 <Dae_> Is it common that haskell programs perform slower under windows? Seems to be happening to everything I've tested so far
23:47:37 <Adamant> Dae_: are you using multiple processes?
23:47:59 <Adamant> CreateProcess is usually slower than fork/exec
23:48:21 <Dae_> Adamant, nope. Just plain ol' single threaded
23:55:11 <tolkad> For some reason this code wont compile: http://pastebin.com/QTnTSw7P
23:55:19 <tolkad> GHC is hanging
23:55:43 <tolkad> maybe it's a problem with the state Monad?
23:57:16 <tolkad> this is perfectly reasonable code
23:57:32 <Dae_> Heh, you shouldn't tease the poor type system
23:58:52 <Dae_> tolkad, what is it supposed to do?
23:59:03 <tolkad> Dae_: nothing very slowly
23:59:18 <kmc> tolkad, it's the same as the others, type recursion in a negative position
23:59:25 <kmc> so once again the answer is "the same ghc bug"
23:59:56 <kmc> you can try to convince the ghc devs that programs like this are not so unreasonable / unusual
