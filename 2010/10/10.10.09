00:00:14 <sipa> and ⊆ is subset
00:01:38 <Gracenotes> ⊂ means just a subset in some areas of math, but, really, why ;_;
00:01:40 <dolio> Shouldn't mathematicians know that already?
00:02:16 <Gracenotes> not computer science though
00:02:29 <augur> Gracenotes: what
00:02:37 <augur> it means proper subset and mathematicians know this
00:02:40 <Gracenotes> yeah for serious
00:02:47 <dolio> > mySubsets "aaa"
00:02:48 <lambdabot>   ["aaa","aa","aa","a","aa","a","a",""]
00:03:06 <Gracenotes> in my group theory professor's notation, {1} ⊂ {1} is valid
00:03:16 <augur> write-o
00:03:29 <augur> or your prof is an idiot
00:03:37 <Gracenotes> they don't have as much use for properness maybe. just saying though.
00:03:53 <augur> no, they have plenty of use. your prof either miswrote, or is an idiot.
00:04:05 <augur> mathematicians in general know well enough what the difference is
00:04:13 <Gracenotes> no, it bothered me the whole semester
00:04:21 <augur> well then hes an idiot
00:04:37 <Gracenotes> I copypasta wikipedia just because he was a nice guy: "Some authors use the symbols ⊂ and ⊃ to indicate "subset" and "superset" respectively, instead of the symbols ⊆ and ⊇, but with the same meaning. So for example, for these authors, it is true of every set A that A ⊂ A."
00:04:48 <Jafet> @let mySubsets = filterM (const [True, False]) . nub
00:04:48 <lambdabot>  <local>:19:0:
00:04:49 <lambdabot>      Multiple declarations of `L.mySubsets'
00:04:49 <lambdabot>      Declared at: ...
00:04:58 <augur> well some authors are idiots
00:05:14 <Jafet> > let mySubsets = filterM (const [True, False]) . nub in mySubsets "aaa"
00:05:15 <lambdabot>   ["a",""]
00:05:25 <augur> what REALLY irritates me is the use of ⊃ for implication in logic
00:05:30 <lispy> augur: actually, it's pretty common to use those symbols
00:05:39 <augur> lispy: what where
00:05:54 <Gracenotes> again, comp sci, linguistics, we are a proper folk..
00:05:57 <augur> ive read math books by some fairly big people in the field and ive never seen such horrendous misuse of it
00:06:02 <lispy> augur: I think most of the math texts I had as undergrad used ⊂ for subset
00:06:24 * lispy now wonders what Royden uses
00:06:31 <augur> well, they might be using it correctly, if they mean "proper subset" when they say subset
00:06:35 <augur> thats entirely possible
00:06:43 <augur> ive seen that
00:06:56 <augur> so the symbol denotes properly, but the pronunciation of it differs
00:07:00 <Gracenotes> lispy: if you know more about it than I do, what did they use for proper then?
00:07:09 <augur> but ive never seen anyone use the symbol to denote incorrectly
00:07:48 <lispy> Royden says A ⊂ A
00:08:07 <augur> royden is crazy
00:08:41 <lispy> he's a professor at Stanford
00:08:45 <augur> so?
00:08:49 <augur> so is george lakoff
00:08:51 <augur> doesnt mean a thing
00:09:50 <lispy> Gracenotes: as for your question, I don't see anything to address that.  I seem to recall they would actually say, "proper subset" if they meant it
00:10:21 <augur> maybe the ⊂ with the struck line below
00:10:51 <augur> ⊊
00:14:48 <lispy> and the second book a I checked "An Introduction to Analysis" by William Wade, uses your preferred notation
00:15:36 <augur> thats cause wade is a smart man
00:16:34 <lispy> Bert Mendelson's Introduction to Topology uses Royden's notation
00:16:44 <lispy> Now mind you, it's topology.  Which is all about sets.
00:17:28 <augur> mendelson is also crazy, obviously
00:22:23 <lispy> Barrett O'Neill's Elementary Differential Geometry doesn't give a symbol but defines it as: A set A is a subset of S provided each element of A is also an element of S.  Which would seem to imply that A ⊂ A, for whatever symbol the author would use there.
00:23:24 <lispy> Serge Lang's Undergraduate Algebra uses Royden's notation for subset.
00:23:54 <dolio> That is the typical definition of "subset" regardless of what symbol you use for it.
00:24:03 <augur> no, oneill's definition is just normal subset
00:24:04 <augur> not proper
00:24:24 <dolio> "Proper subset" is the term for "subset and not equal to".
00:24:29 <lispy> right
00:26:59 <lispy> Bertrand Russell's The Principles of Mathematics doesn't seem to cover this topic
00:27:33 * hackagebot hums 0.3.1 - Haskell UPnP Media Server  http://hackage.haskell.org/package/hums-0.3.1 (BardurArantsson)
00:31:00 <lispy> dolio: proper subsets are also non-empty
00:31:17 <lispy> But I suppose you know that
00:31:37 <dolio> Can't say I've seen that rule before.
00:32:38 <lispy> Hmm...that's the way I learned it :)
00:36:23 <lispy> dolio: maybe you're right.  Checking wikipedia.  They say empty set is always a proper subset, except of itself
00:36:33 <dolio> That would mean that ⊂ is not the symbol for proper subset, either, since {} ⊂ A would be expected to hold for A /= {}.
00:36:45 <dolio> That is, even for people who don't use it for subset in general.
00:40:32 <Maxdamantus> Is it possible to define lambdas that use pattern matching?
00:40:41 <Maxdamantus> (Without an embedded case or something)
00:40:57 <dolio> Only for a single case.
00:41:07 <augur> Maxdamantus: what do you mean define lambdas that use pattern matching
00:41:12 <dolio> > (\(x:xs) -> x) [1,2,3]
00:41:13 <lambdabot>   1
00:41:20 <dolio> > (\(x:xs) -> x) []
00:41:21 <lambdabot>   *Exception: <interactive>:1:134-145: Non-exhaustive patterns in lambda
00:41:24 <Maxdamantus> er, with multiple cases
00:41:29 <augur> oh, like dolio is doing, ok.
00:41:39 <augur> you need a case statement for that i think
00:41:45 <dolio> If you want multiple cases, you need to use case.
00:42:02 <Maxdamantus> Hmm.. Maybe guards?
00:42:13 <dolio> Although, someone implemented lambda-case recently, so that'll probably be in a future GHC.
00:42:31 <Maxdamantus> > (\a | a == True -> False | a == False -> True) False
00:42:32 <lambdabot>   <no location info>: parse error on input `|'
00:42:40 <Maxdamantus> > (\a | a == True -> False; | a == False -> True) False
00:42:40 <lambdabot>   <no location info>: parse error on input `|'
00:42:44 <Maxdamantus> Meh.
00:43:48 <dolio> Nope, no guards.
00:44:54 <augur> Maxdamantus: what are you trying to do
00:45:20 <Maxdamantus> Nothing, jw
00:45:38 * hackagebot stream-monad 0.3 - Simple, Fair and Terminating Backtracking Monad  http://hackage.haskell.org/package/stream-monad-0.3 (SebastianFischer)
00:58:41 * hackagebot tree-monad 0.3 - Non-Determinism Monad for Tree Search  http://hackage.haskell.org/package/tree-monad-0.3 (SebastianFischer)
02:20:43 <augur> how common is it for people to use pseudo-method calls for chaining things?
02:21:58 <augur> e.g. instead of   foldl f z (map g xs)   ,   f `foldl` z (g `map` xs)
02:22:37 <augur> or really, something like   xs `map2` g `foldl2` z f
02:23:42 <mauke> foldl f z . map g $ xs
02:24:16 <augur> right, so not what i was aiming for :P
02:25:03 <augur> im just curious, cause i have a function thats really obnoxious and conceptually its much easier to follow in a method chaining idiom than in a function application idiom
02:25:27 <mauke> why?
02:25:35 <mauke> it's just left-to-right vs. right-to-left
02:27:13 <augur> abstractly, its   map f (foldl g z (map (\k -> map m (foldl l z2 (h k >>= j))) ks))
02:28:17 <ClaudiusMaximus> > (+1) >>> (*2) $ 1
02:28:18 <lambdabot>   4
02:28:48 <augur> but conceptually, i think its easier to follow with some inside-out structure.  
02:29:16 <augur> map ks, then foldr the result like so, then map that like so
02:29:24 <mauke> map f . foldl g z . map (map m . foldl l z2 . concatMap j . h)
02:29:33 <augur> thats not the point mauke :P
02:29:37 <mauke> yes, it is
02:29:41 <augur> no its not XP
02:29:55 <dolio> Yes, it is.
02:29:57 <mauke> <augur> map ks, then foldr the result like so, then map that like so
02:30:02 <mauke> ^ exactly what I'm doing
02:30:08 <augur> i know thats the SEMANTICS of it
02:30:12 <augur> the point is the linear order of it
02:30:15 <mauke> what
02:30:25 <mauke> my code is linear
02:30:25 <augur> what what
02:30:31 <augur> yes, but its BACKWARDS
02:30:38 <mauke> <mauke> it's just left-to-right vs. right-to-left
02:30:46 <augur> yes, ok?
02:30:53 <augur> i know that
02:30:56 <mauke> do you also complain that f(g(h(x))) is BACKWARDS?
02:31:18 <augur> depends on which direction is easier for me to think about!
02:31:26 <augur> isnt there a reverse application operator?
02:31:32 <mauke> @index >>>
02:31:33 <lambdabot> Control.Arrow
02:31:42 <augur> x >>> f = f x
02:31:43 <augur> ?
02:31:55 <ClaudiusMaximus> :t (>>>) <<< (>>>) $ (x :: lol)
02:31:57 <lambdabot>     Couldn't match expected type `lol' against inferred type `Expr'
02:31:57 <lambdabot>       `lol' is a rigid type variable bound by
02:31:57 <lambdabot>             an expression type signature at <interactive>:1:24
02:31:59 <mauke> > (sqrt >>> succ) 2
02:32:00 <lambdabot>   2.414213562373095
02:32:15 <mauke> why not use reverse composition?
02:32:34 <augur> conceptualization.
02:32:50 <mauke> and how will that help with the inner pipeline?
02:32:53 <augur> > succ . sqrt 2
02:32:54 <lambdabot>   No instance for (GHC.Float.Floating (f a))
02:32:54 <lambdabot>    arising from a use of `e_12' ...
02:33:00 <augur> > (succ . sqrt) 2
02:33:01 <lambdabot>   2.414213562373095
02:33:09 <ClaudiusMaximus> @hoogle o +haxml
02:33:09 <lambdabot> Could not find file:
02:33:09 <lambdabot>     haxml
02:33:09 <lambdabot> Searched:
02:33:13 <augur> mauke, how what
02:33:24 <mauke> map (\k -> map m (foldl l z2 (h k >>= j)))
02:33:56 <mauke> you'll still have to deal with \k -> ... if you use a reverse application op
02:35:50 <augur> supposing x :> f = f x,   ks :> map (\k -> (h k >>= j) :> foldl2 l z2 :> map m)
02:36:04 <Blkt> good day everyone
02:36:13 <augur> good day suh!
02:37:21 <mauke> \k -> k :> h :> (>>= j) :> foldl l z2 :> map m
02:37:35 <mauke> ... no
02:37:39 <augur> or that! :P
02:37:57 <augur> its easier for me to think about the problem in that fashion
02:38:03 <mauke> map m . foldl l z2 . concatMap j . h  -- I prefer this
02:38:24 <augur> well fine :P
02:38:26 <mauke> anyway, I'm not aware of any predefined flip ($)
02:38:35 <mauke> and you can't use :> because : is uppercase
02:38:40 <augur> hush your face
02:39:07 <augur> im not actually doing this in haskell, i was just curious if there was a tendency for people to reverse things in this fashion in certain situations
02:39:54 <mauke> I've seen one file where the author defined (.) = flip ($)
02:40:02 <augur> weird
02:40:17 <mauke> [1,2,3].map(show).sort
02:40:19 <augur> mauke: incase you're interested in wtf im doing
02:42:21 <augur> im building a unifier that works bottom up, so that to unify, say, `[x,x]` with `[1,2]` you do something like   merge (unify x 1) (unify x 2)
02:42:41 <augur> where unify x 1 == [[x,1]], unify x 2 == [[x,2]]
02:42:49 <augur> and merge [[x,1]] [[x,2]] == []
02:43:14 <augur> because theres no way to combine the bindings for x into a single value
02:44:50 <augur> the simple case there is nice and clean, but the more complex case is when unify x 1 == [[[x,[1]]]], where a) x is bound to multiple things (in case of inequalities or values containing variables), and b) there could be multiple valid unifications depending on the objects being unified
02:46:14 <augur> so not only do you have to deal with the multiplicity of valid unifications, you also have to deal with what it means to merge the multiple bindings for each variable
02:46:57 <augur> and its really nice, for me at least, to break it down from "deepest" to "shallowest"
02:48:13 <ski> > showsFun 0 [False,True] shows shows `flip` "" `map` ((|->|) `join` [False,True])
02:48:13 <lambdabot>   ["\\it -> case it of {False -> False; True -> False}","\\it -> case it of {...
02:48:21 <ski> augur : like that ?
02:48:52 <augur> O_O
02:48:56 <augur> i dont even
02:49:03 <ski> (i'm not sure why you call it "pseudo-method calls", though .. it's just infixed use)
02:49:14 <augur> ski: well, but the idea was that like
02:49:41 <augur> instead of   map f xs   becoming   f `map` xs   it would become   xs map f
02:49:53 <augur> or something like that. so it looks like a method call. xs.map f
02:50:25 <ski> > [ [f x | x <- [False,True]] | f <- [False,True] |->| [False,True]]
02:50:26 <lambdabot>   [[False,False],[True,False],[False,True],[True,True]]
02:51:12 <ski> > [[f x | x <- "abc"] | f <- "abc" |->| "de"]
02:51:13 <lambdabot>   ["ddd","edd","ded","eed","dde","ede","dee","eee"]
02:51:22 <augur> what in the hell is this
02:51:56 <ski> @type (|->|)
02:51:56 <lambdabot> forall a b. (Eq a) => [a] -> [b] -> [a -> b]
02:52:10 <augur> horrible
02:52:14 <ski> it enumerates functions, given domain and codomain
02:53:11 <ski> @type ap :: [a -> b] -> ([a] -> [b])  -- hmm
02:53:11 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
02:53:51 <kmc> ski, is (|->|) in some library or did you @let it above?
02:53:58 <ski> just a `let'
02:54:12 <ski> (and `(|*|)' and `(|+|)' as well)
02:54:19 <kmc> what's the code?
02:54:37 <augur> oh, ski, where do you live again?
02:54:50 <ski> i wrote it yesterday, supposedly in response to something someone said .. but i've forgot what :/
02:55:32 <ski> <ski> @let (|+|) :: [a] -> [b] -> [Either a b]; as |+| bs = map Left as /\/ map Right bs
02:55:47 <ski> <ski> @let (|*|) :: [a] -> [b] -> [(a,b)]; as |*| bs = as >>- \a -> bs >>- \b -> [(a,b)]
02:56:08 <ski> <ski> @let (|->|) :: Eq a => [a] -> [b] -> [a -> b]; as |->| bs = foldr (\a0 fs -> bs >>- \b0 -> fs >>- \f -> [\a -> if a0 == a then b0 else f a]) [const (error "(([] |-> _) !! _) _")] as
02:56:40 <ski> <ski> @let showsFun :: Int -> [a] -> (a -> ShowS) -> (b -> ShowS) -> ((a -> b) -> ShowS); showsFun p dom showsDom showsCod f = showString "\\it -> case it of {" . (foldr (.) id . intersperse (showString "; ")) [showsDom a . showString " -> " . showsCod (f a)| a <- dom] . showChar '}'
02:56:54 <ski> that's it .. not very complicated
02:57:19 <kmc> woah (>>-) fair conjunction?
02:57:47 <ski> i was figuring i could just as well make it work for infinite (countable) domains as well
02:57:53 <kmc> :t (>>-)
02:57:53 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
02:58:05 <kmc> cool didn't know we had LogicT here
02:58:24 <ski> > [0,2..] |+| [1,3..]
02:58:24 <lambdabot>   [Left 0,Right 1,Left 2,Right 3,Left 4,Right 5,Left 6,Right 7,Left 8,Right 9...
02:59:23 <ski> > (([] |->| "x") !! 0) 'x'
02:59:24 <lambdabot>   *Exception: (([] |-> _) !! _) _
03:00:25 <ski> augur : oh .. /whois will tell
03:00:36 <augur> what
03:01:02 <augur> luxembourg?
03:01:24 <ski> heh, no, that's the server
03:01:33 <augur> well then!
03:01:36 <ski> ".se" is usually .. "Sweden"
03:01:39 <augur>  /whois DIDNT tell!
03:02:01 <augur> well, your address is .se, so presumably sweden
03:02:02 <augur> right
03:02:11 <augur> well. guess i wont be inviting you to chris barkers talk then :P
03:04:35 <ski> (.. i suppose it'd be hard to persuade him to change location to Chalmers ?)
03:04:45 <augur> yes
03:59:54 <Palmik> Is it just me, or is haskell perfect fit for this challenge? http://challenge.greplin.com/ :)
04:02:20 <Botje> that typing animation is annoying :(
04:04:24 <Botje> the first one is a oneliner, at least :)
04:08:33 <Botje> the second is a oneliner too :P
04:08:52 <akamaus> hi all
04:08:56 <Botje> hello
04:11:26 <Palmik> Botje, well... anything could be oneline with enought of lambdas
04:11:28 <akamaus> I want to debug a module which exports only a few top level functions using ghci. And I want to experiment with the hidden ones. Is there a way to do it besides deleting the export list?
04:11:54 <mauke> yes, load the source file, not the compiled code
04:13:40 <akamaus> mauke, how? Should I delete the .hi file?
04:14:17 <mauke> try :l *YourFile
04:15:35 <Palmik> Btw... why is it much faster to filter the result of filter on infinite list compared to, for example, creating lambda joining the two coditions and using just one filter (or list comrehension)?
04:16:32 <mauke> it isn't
04:19:47 <Botje> challenge #3 doesn't make sense :(
04:20:09 <Palmik> Botje, why not? 
04:20:47 <Palmik> seems ok to, have not started solving it yet
04:21:15 <Palmik> mauke, well... it seems that it is
04:22:13 <Botje> it doesn't make sense because it's not explained properly
04:22:59 <Palmik> for each number check the number of ways it can be constructed by addition from the rest of the numbers
04:23:05 <Palmik> do that for all numbers in the list
04:23:19 <Palmik> and sum all the results
04:24:39 <Botje> "For the final task, you must find all subsets of an array where the largest number is the sum of the remaining numbers. For example, for an input of:
04:24:42 <Botje> "
04:25:08 <Palmik> Yeah, I have read it :P
04:25:14 <Botje> i parse that as: find all partitions (a, b) such that max a == sum b
04:25:31 <Botje> but then i look at the examples and they don't make much sense
04:25:44 <Botje> /which/ largest number?
04:25:46 <Palmik> The example does what I said
04:27:35 <Botje> should've been explained better, then
04:27:41 <mauke> Botje: I read it as: find all subsets xs such that maximum xs == sum (xs without (maximum xs))
04:28:12 <Botje> yeah. that was the second thing i tried to fit in
04:28:31 <Botje> i should send those guys a mail and tell them to fix their assignment :P
04:29:08 <Palmik> that is basically what I said just expressed differently imo :)
04:29:52 <mauke> yeah
04:29:53 <Botje> ah well
04:29:57 <Botje> back to something productive
04:30:00 <mauke> I don't see the problem
04:30:25 <Botje> it wasn't clear what "remaining" and "largest" are applied to
04:40:26 <handonson> bummer. it seems that the Handle provided by Network.connectTo don't safely process non-ASCII Strings, even after { hSetEncoding handle utf8 }.
04:48:33 <handonson> quicksilver: i finally gave it a try, and the result is, sadly, against what you've suggested. :(
05:06:22 <Palmik> Botje, have you sent them the email? :)
05:06:47 <Palmik> that the 3rd riddle might be unclear
05:12:19 <Botje> no, i haven't
05:13:32 <arcatan> i sent them an e-mail with short remark on that
05:14:08 <arcatan> is there an intuitive explanation for what some and many in Alternative mean?
05:14:17 <arcatan> or maybe an example
05:16:34 <kmc> have you used the combinators of the same name in Parsec?
05:18:42 <arcatan> yeah
05:19:17 <kmc> it's like that
05:19:39 <Axman6> what's the difference between some and many?
05:19:41 <kmc> and by "like" i mean that they coincide for the Parsec instance of Alternative
05:19:50 <kmc> "some: One or more." "many: Zero or more"
05:20:43 <kmc> many v = some v <|> pure []
05:20:54 <kmc> some v = liftA2 (:) v (many v)
05:21:12 <kmc> not the actual implementation, just a cute use of mutual recursion
05:21:37 <kmc> (the actual implementation is similar but is worker-wrapper transformed.  and they're class methods, so you can override)
05:29:59 <aristid> @pl \v -> liftA2 (:) v (many v)
05:29:59 <lambdabot> ap (liftA2 (:)) many
05:30:08 <aristid> \o/
05:32:20 <kmc> :t liftA2 (:) <*> many
05:32:21 <lambdabot> forall a (f :: * -> *). (Alternative f) => f a -> f [a]
05:32:36 <kmc> for maximum confusion
05:36:53 <ddarius> none one aCouple aFew some several aBunch many
05:37:29 <Twey> Heh
05:37:44 <arcatan> aShitload
05:38:12 <Axman6> aMetricFuckTonne
05:38:17 <aristid> we need to standardise aShitload and debate for a few months how many elements a shitload is actually
05:38:58 <Axman6> well, i'm going to define a metric fucktonne as 2^64+1, so you need Integers to find the length of the list
05:39:43 <ddarius> @hoogle Word128
05:39:44 <lambdabot> No results found
05:39:52 <ddarius> @hoogle Word256
05:39:52 <lambdabot> No results found
05:39:54 <aristid> Axman6: 2^64 is not very metric
05:40:07 <aristid> Axman6: 10^63 would be a lot more metric
05:40:24 <benmachine> 2^64 is about 10^20 or so?
05:40:33 <benmachine> > length . show $ 2 ^ 64
05:40:35 <lambdabot>   20
05:40:37 * benmachine cool
05:41:11 <aristid> > show $ 2^64
05:41:12 <lambdabot>   "18446744073709551616"
05:41:23 <aristid> doesn't end in zeroes, is the problem ;)
05:42:11 <benmachine> sure but I mean, 10^21 would be large enough
05:42:40 <s_adlai> Hi, I'm having trouble with getting a list to compile. I type in "let b = [1,2,3]" (without the quotes) and it gives me an error message.
05:43:07 <s_adlai> I mean I type that into my program.
05:43:20 <ezyang> s_adlai: drop the let, if that's the only stuff you have. 
05:43:22 <Axman6> get rid of the let
05:43:23 <ezyang> otherwise, please pastebin. 
05:43:32 <s_adlai> ah, ok. Thanks!
05:43:44 <aristid> benmachine: it's supposed to be a FuckTonne, man
05:49:12 <cobra_> how do i write a function of type [[[a]]] -> [[[a]]] that returns all of the combinations of taking one element from each "row" of the parameter?
05:49:21 <cobra_> [[[1,2,3],[4,5,6]], [[7,8,9]]] -> [[[1,2,3],[7,8,9]], [[4,5,6],[7,8,9]]]
05:49:42 <Axman6> o.O
05:49:46 <cobra_> (btw this looks like homework but it is not)
05:50:37 <kamatsu> looks a bit intricate
05:50:41 <kamatsu> perhaps you can reduce this to a simpler problem
05:51:04 <benmachine> cobra_: do you only pick rows as a unit? is there any reason the rows have to be lists?
05:51:23 <revenantphx> why [[[a]]]?
05:51:26 <cobra_> the rows have to be lists because they can be of variable lenghts
05:51:29 <revenantphx> Wouldn't [[a]] be sufficient?
05:51:47 <kamatsu> cobra_: i fail to see why that makes a difference to what you're trying to do here
05:51:53 <benmachine> cobra_: yes but you don't *use* their listiness in this function
05:52:09 <cobra_> [[[1,2,3],[4,5]], [[7,8,9,10]]] -> [[[1,2,3],[7,8,9,10]], [[4,5],[7,8,9,10]]]
05:52:33 <revenantphx> once again, I see extra [ ] everywhere.
05:52:42 <kamatsu> cobra_: once again, the actual contents of the rwos makes no difference
05:52:56 <Axman6> is this the same as, [[1,2],[3]] -> [[1,3],[2,3]]?
05:52:58 <benmachine> cobra_: why not just have a function that does [[x, y], [z]] -> [[x, z], [y, z]]
05:52:58 <cobra_> yes, you guys are correct!
05:53:19 <cobra_> ok so i guess the type should be [[a]] -> [[a]]
05:53:34 <benmachine> cobra_: we might all sound pedantic but usually getting the type as general as possible helps you work out the implementation :)
05:53:36 <revenantphx> Well, I don't know what you're trying to do.
05:53:41 <revenantphx> But it doesnt sound like tensors 
05:53:42 <Axman6> what should the result be if you give it [[a,b],[c,d]]?
05:53:46 <benmachine> I think you want sequence
05:53:54 <benmachine> > sequence [[x, y], [z]]
05:53:55 <lambdabot>   [[x,z],[y,z]]
05:53:57 <benmachine> woo
05:54:05 <Axman6> nice
05:54:11 <benmachine> > sequence [[a,b], [c,d]]
05:54:12 <lambdabot>   [[a,c],[a,d],[b,c],[b,d]]
05:54:20 <benmachine> does that sound like your thing?
05:54:25 <cobra_> [[a,b],[c,d]] -> [[a,c],[a,d],[b,c],[b,d]]
05:54:29 <aristid> > sequence [[[1,2,3],[4,5]], [[7,8,9,10]]]
05:54:31 <lambdabot>   [[[1,2,3],[7,8,9,10]],[[4,5],[7,8,9,10]]]
05:54:41 <revenantphx> >sequence [[a,b],[c,d]]
05:54:50 <revenantphx> > sequence [[a,b],[c,d]]
05:54:51 <lambdabot>   [[a,c],[a,d],[b,c],[b,d]]
05:54:52 <aristid> revenantphx: SPACE
05:54:56 <revenantphx> looks about right cobra.
05:55:11 <cobra_> > sequence [[[1,2,3],[4,5,6]], [[7,8,9]]]
05:55:13 <lambdabot>   [[[1,2,3],[7,8,9]],[[4,5,6],[7,8,9]]]
05:55:18 <revenantphx> Sequence: Evaluate each action in the sequence from left to right, and ignore the results.
05:55:32 <cobra_> cool thanks!
05:55:35 <revenantphx> once again cobra, you have a redundant pair of braces there.
05:55:37 <benmachine> revenantphx: "action" doesn't really work as a metaphor with lists, imo
05:55:38 <Axman6> it hardly ignores the results...
05:55:50 <revenantphx> > sequence [[1,2,3],[4,5,6]], [[7,8,9]]
05:55:51 <lambdabot>   <no location info>: parse error on input `,'
05:56:01 <revenantphx> wait...
05:56:05 <aristid> revenantphx: no the braces are not redundant
05:56:10 <revenantphx> yeah here they arent.
05:56:11 <revenantphx> my bad.
05:56:19 * Axman6 was wondering how long it would take revenantphx :P
05:56:27 <revenantphx> >_<
05:56:28 <Twey> Braces?
05:56:31 <revenantphx> nmd.
05:56:54 <revenantphx> sequence: Evaluate each action in the sequence from left to right, and collect the results.
05:56:55 <revenantphx> my bad.
05:57:00 <revenantphx> sequence_ ignores them.
05:57:52 <revenantphx> > sequence [[Just 1, Just 2], [Nothing, Just 3]]
05:57:53 <lambdabot>   [[Just 1,Nothing],[Just 1,Just 3],[Just 2,Nothing],[Just 2,Just 3]]
05:58:14 <benmachine> not using the maybe-ness at all there
05:58:19 <revenantphx> I know, just testing.
05:58:48 <revenantphx> > sequence [[return 1, 2],[3,4]]
05:58:49 <lambdabot>   No instance for (GHC.Num.Num (m t))
05:58:50 <lambdabot>    arising from a use of `e_11234' at <...
05:58:51 <cobra_> how do i check if a list contains an element more than once? Eq a => [a] -> Bool
05:59:31 <Axman6> just any element?
05:59:38 <Axman6> so the elements aren't unique?
05:59:51 <cobra_> Axman6: right, i want to check if all elements are unique
05:59:52 <benmachine> cobra_: elem x (drop 1 (dropWhile (/= x) list))
05:59:57 <benmachine> oh
05:59:59 <benmachine> right
06:00:01 <benmachine> um
06:00:09 <benmachine> there's a simple but slow way
06:00:46 <Axman6> well, one way is: all (\x -> length x == 0) . group . sort
06:00:55 <benmachine> er
06:00:59 <Axman6> > all (\x -> length x == 0) . group . sort $ [1,2,5,2,3,4]
06:00:59 <benmachine> length x == 1
06:01:00 <Twey> Err
06:01:00 <lambdabot>   False
06:01:01 <benmachine> itym
06:01:03 <Twey> Try ‘null’
06:01:07 <Twey> all null . group . sort
06:01:14 <benmachine> group never returns empty lists!
06:01:17 <Axman6> > all (\x -> length x == 1) . group . sort $ [1,2,5,2,3,4]
06:01:18 <lambdabot>   False
06:01:23 <Twey> Yeah, that's another problem :þ
06:01:24 <Axman6> i did mean to write 1 -_-
06:01:32 <Axman6> > all (\x -> length x == 1) . group . sort $ [1,2,52,3,4]
06:01:33 <lambdabot>   True
06:01:36 <cobra_> Axman6: I can't use sort since I don't have an Ord instance
06:01:45 <benmachine> cobra_: try xs == nub xs then
06:01:51 <benmachine> might be inefficient
06:01:54 <benmachine> might not be, who knows
06:02:12 <cobra_> sweet thanks
06:02:24 <Twey> (liftM2 (&&) (not . null) (null . tail))
06:02:45 <Axman6> > let f [] = False; f (x:xs) = not (x `elem` xs) && f xs in f [1,2,3,4]
06:02:45 <lambdabot>   False
06:03:10 <Axman6> > let f []  =True; f (x:xs) = not (x `elem` xs) && f xs in f [1,2,3,4]
06:03:11 <lambdabot>   True
06:03:14 <Axman6> > let f []  =True; f (x:xs) = not (x `elem` xs) && f xs in f [1,2,3,4,2]
06:03:15 <lambdabot>   False
06:03:19 <Axman6> there we go
06:03:26 <Axman6> though should be foldable...
06:03:29 <benmachine> Axman6: I think that's more or less what xs == nub xs would do
06:03:30 <Axman6> maybe not
06:03:46 <Axman6> benmachine: i think mine terminates sooner
06:04:05 <benmachine> Axman6: but not much sooner
06:05:21 <Axman6> if the first and last elements are the same, you need to do n^2 traversals before you find that xs /= num xs, with mine it's only n
06:06:05 <benmachine> hmm
06:06:08 <benmachine> ok fair enough
06:06:53 <Axman6> so i think the worst case is better, though i think they're both O(n^2)
06:06:54 <benmachine> :t foldr (\x (b, xs) -> (not (elem x xs) && b, x:xs)) (True, [])
06:06:55 <lambdabot> forall a. (Eq a) => [a] -> (Bool, [a])
06:07:13 <benmachine> no the worst case for yours is the last two elements being the same
06:08:33 <Axman6> i think the nub version is Θ(n^2)
06:08:50 <Twey> 0? o.@
06:08:58 <Axman6> theta
06:08:59 <aristid> @pl (\x (b, xs) -> (not (elem x xs) && b, x:xs))
06:09:00 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (liftM2 (,) .) . flip . (((&&) . not) .) . elem) (:)
06:09:09 <Twey> *twitch*
06:09:16 <Axman6> ?
06:09:44 <benmachine> if the first two elements in the nub version are the same it might actually be lazier than your version
06:09:46 <aristid> hi ManateeLazyCat
06:09:49 <Twey> That's a horrible @pl
06:09:57 <benmachine> no it won't
06:10:04 <benmachine> but it'll be similarly lazy >_>
06:10:04 <aristid> Twey: but not the worst i've ever seen
06:10:09 <Twey> True, true
06:10:53 <aristid> @pl (\x (b, xs) -> (x:xs, not (elem x xs) && b))
06:10:54 <lambdabot> (`ap` snd) . (. fst) . ap ((.) . ap . ((,) .) . (:)) (flip . (((&&) . not) .) . elem)
06:11:09 <aristid> @pl (\x (xs, b) -> (x:xs, not (elem x xs) && b))
06:11:10 <lambdabot> (`ap` snd) . (. fst) . ap (ap . (((.) . (,)) .) . (:)) ((((&&) . not) .) . elem)
06:11:13 <Axman6> @pl \a b c d e f g -> (g,a,b,d,a)
06:11:14 <lambdabot> ((const . ((const . const) .)) .) . (flip =<< ((flip . (flip .) . flip) .) . flip . flip (,,,,))
06:11:22 <benmachine> I think @pl is missing some of the arrow combinators
06:11:25 <aristid> Axman6: haha, wonderful
06:11:30 <Axman6> @pl \a b c d e f g -> (g,a,b,d,c,e)
06:11:30 <lambdabot> ((((((const .) . flip) .) .) . flip . (flip .) . flip) .) . flip . flip (,,,,,)
06:11:36 <revenantphx> here
06:11:36 <ManateeLazyCat> aristid: Hi. :)
06:11:36 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
06:11:37 <Axman6> huh
06:11:40 <revenantphx> my version
06:11:41 <revenantphx> > let hasDup x a = flip (>) 1 . length $ findIndices (\b -> x == b ) a in hasDup 2 [1, 2, 2, 4, 5]
06:11:42 <lambdabot>   True
06:11:55 <revenantphx> probably terribly inneficient
06:11:57 <revenantphx> but it works.
06:12:05 <revenantphx> its also ugly :3
06:12:18 <ManateeLazyCat> aristid: How about : http://www.flickr.com/photos/48809572@N02/5064285523/lightbox/ ? Clear?
06:12:29 <benmachine> flip (>) = (<=), no?
06:12:37 <revenantphx> benmachine: ... touche
06:12:39 <benmachine> no it's (<)
06:12:43 <aristid> ManateeLazyCat: i like the triangles
06:13:05 <aristid> not . (>) = (<=)
06:13:10 <aristid> flip (>) = (<)
06:13:14 <benmachine> mm
06:13:15 <revenantphx> > let hasDup x a = (<) 1 . length $ findIndices (\b -> x == b ) a in hasDup 2 [1, 2, 2, 4, 5]
06:13:16 <lambdabot>   True
06:13:22 <revenantphx> > let hasDup x a = (<) 1 . length $ findIndices (\b -> x == b ) a in hasDup 3 [1, 2, 2, 4, 5]
06:13:22 <lambdabot>   False
06:13:24 <revenantphx> seems fine.
06:13:30 <ManateeLazyCat> aristid: I use SetList maintain *Window Node* tree, and use ListZipper maintain *Window* (leaf of window node tree).
06:13:38 <aristid> revenantphx: i think i'd use a section. (1 <)
06:13:53 <revenantphx> > let hasDup x a = (1 <) . length $ findIndices (\b -> x == b ) a in hasDup 2 [1, 2, 2, 4, 5]
06:13:54 <lambdabot>   True
06:13:56 <revenantphx> mm
06:14:13 <benmachine> or (> 1) might be more readable
06:14:15 <aristid> ManateeLazyCat: i don't really understand the context
06:14:19 <revenantphx> > let hasDup x a = (> 1) . length $ findIndices (\b -> x == b ) a in hasDup 2 [1, 2, 2, 4, 5]
06:14:20 <lambdabot>   True
06:14:28 <revenantphx> In either case this is probably not especially efficient.
06:14:38 <benmachine> (> 1) . length = not . null . drop 1
06:14:41 <aristid> @src findIndices
06:14:41 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
06:14:42 <benmachine> I think
06:15:00 <aristid> revenantphx: and the (\b -> x == b) can be replaced by a section too
06:15:02 <benmachine> in any case this is not the function that was asked for
06:15:09 <benmachine> which was (Eq a) => [a] -> Bool
06:15:32 <revenantphx> > let hasDup x a = (> 1) . length $ findIndices (== x) a in hasDup 2 [1, 2, 2, 4, 5]
06:15:33 <lambdabot>   True
06:15:35 <revenantphx> better
06:15:38 <aristid> benmachine: there are many functions (Eq a) => [a] -> Bool
06:15:49 <benmachine> aristid: right, but that isn't one of them :P
06:15:53 <ManateeLazyCat> aristid: It's illustration to plain *Multi-Window* manage like this : http://www.flickr.com/photos/48809572@N02/5063946143/lightbox/
06:15:57 <aristid> benmachine: true.
06:16:00 <revenantphx> I was just seeing how i'd do this :P
06:16:17 <benmachine> > let hasDup x = (> 1) . length . findIndices (== x)
06:16:18 <lambdabot>   not an expression: `let hasDup x = (> 1) . length . findIndices (== x)'
06:16:21 <benmachine> oops
06:16:27 <benmachine> > let hasDup x = (> 1) . length . findIndices (== x) in hasDup 1 [1,2,3,1]
06:16:28 <lambdabot>   True
06:16:42 <ManateeLazyCat> aristid: Hope this illustration make other people understand code easily. :) 
06:16:45 <revenantphx> mm true, could drop the a
06:17:06 <aristid> ManateeLazyCat: lol what is that animal
06:17:09 <revenantphx> benmachine: what'd be an efficient was to do hasDup?
06:17:24 <aristid> revenantphx: you can also use filter instead of findIndices
06:17:33 <benmachine> yeah
06:17:38 <revenantphx> yeah I noticed.
06:17:41 <benmachine> and not . null . drop 1 instead of (> 1) . length
06:17:43 <ManateeLazyCat> aristid: I use my image viewer test *memory leak* of gtk2hs code.
06:17:43 <benmachine> is the main gain
06:17:47 <revenantphx> > let hasDup x a = (> 1) . length . findIndices (== x) in hasDup 2 [1, 2, 2, 4, 5]
06:17:48 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> GHC.Bool.Bool)
06:17:48 <lambdabot>    arising f...
06:17:51 <aristid> :t let count = fmap length . filter
06:17:52 <lambdabot> <no location info>:
06:17:52 <lambdabot>     not an expression: `let count = fmap length . filter'
06:17:52 <ManateeLazyCat> aristid: And that picture is cute, so... :)
06:17:57 <benmachine> > not . null . drop 1 $ [1 ..]
06:17:57 <aristid> :t let count = fmap length . filter in count
06:17:58 <lambdabot>   True
06:17:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
06:18:03 <arcatan> @djinn (Eq a, Foldable m) => m a -> Bool
06:18:04 <lambdabot> Error: Class not found: Foldable
06:18:06 <revenantphx> > let hasDup x = (> 1) . length . findIndices (== x) in hasDup 1 [1,2,3,1]
06:18:07 <lambdabot>   True
06:18:24 <arcatan> meh, there is no free function
06:18:30 <ddarius> > 0x155e
06:18:31 <lambdabot>   5470
06:18:49 <revenantphx> > let hasDup x = (> 1) . length . filter (== x) in hasDup 1 [1,2,3,1]
06:18:50 <lambdabot>   True
06:19:05 <benmachine> arcatan: djinn usually doesn't do typeclasses, I think
06:19:49 <arcatan> benmachine: i would have been happy with f _ = False
06:20:04 <benmachine> arcatan: djinn tries to use all the information you give it
06:20:46 <benmachine> > (a -> b -> b) -> b -> a -> b
06:20:47 <lambdabot>   <no location info>: parse error on input `->'
06:20:50 <benmachine> er
06:20:57 <benmachine> @djinn (a -> b -> b) -> b -> a -> b
06:20:58 <lambdabot> f a b c = a c b
06:21:16 <benmachine> could've just returned b but didn't
06:21:17 <Twey> aristid: flip (liftM2 (liftM2 (,))) $ flip (liftM2 (&&)) fst . flip fmap snd . notElem
06:21:24 <arcatan> yeah
06:21:27 <Twey> Hmph… not much nicer really
06:21:30 <benmachine> Twey: go to your room without any supper
06:21:35 * Twey laughs.
06:22:32 <revenantphx> what does @djinn do?
06:22:44 <mreh> infers an inplementation from a type
06:22:50 <ddarius> It proves simple theorems.
06:22:53 <kmc> hi revenantphx
06:22:59 <revenantphx> ello kmc
06:23:03 <kmc> @djinn (b -> c) -> (a -> b) -> (a -> c)
06:23:04 <lambdabot> f a b c = a (b c)
06:23:29 <kmc> @djinn (b -> b -> c) -> (a -> b) -> (a -> a -> c)
06:23:29 <lambdabot> f a b c _ = a (b c) (b c)
06:24:49 <benmachine> hah
06:24:58 <benmachine> I wonder why it did that
06:27:03 <fserb> question about QuickCheck, I'm setting a main like: main = do quickCheck test1 ; quickCheck test2.  test1 :: [a] -> a -> Bool and test2:: a -> a -> Bool I get an error that say haskell expects that test2 is [a] -> a -> Bool. Why?
06:27:22 <mreh> hmm, I'd like to send a darcs patch to the mailing list
06:27:46 <mreh> I've only used darcs send before and I want to pick up an old thread
06:27:48 <kmc> fserb, that doesn't sound like a question about QuickCheck
06:27:57 <kmc> it sounds like the question is, why does test2 have a type error
06:28:06 <kmc> do both functions work if you try to use them from ghci?
06:28:59 <fserb> kmc, if I only do "quickCheck test1" or "quickCheck test2" on main, they work perfectly. It seems they must have always the same signature... is this true?
06:29:02 <ManateeLazyCat> Hmm, when i enable '-thread' flag and gtk2hs unref works well and memory release by GC, but memory can't release after i disable '-thread' flag. Looks gtk main thread blocks all the GHC runtime threads (including GC) when disable '-thread' flag?
06:29:40 <fserb> kmc, if I do quickCheck t2 ; quickCheck t3 where t2 and t3 have the same signature, it works fine.
06:29:48 <sipa> :t quickCheck
06:29:49 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
06:29:58 <kamatsu> ManateeLazyCat: that sounds like a plausible explanation
06:30:09 <kmc> fserb, it doesn't seem right to me.  did you put a type signature on main?
06:30:47 <fserb> kmc, no
06:30:48 <arcatan> is fserb's question somehow related to the monomorphism restriction?
06:30:55 <kmc> good question
06:31:09 <kmc> fserb, put type signatures on all your top-level definitions (it's good style anyway) and see if that fixes it
06:32:43 <ManateeLazyCat> kamatsu: Yep, i can't found any other explanation...
06:33:02 <benmachine> :t quickCheck
06:33:02 <fserb> ouch.
06:33:03 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
06:33:17 <fserb> so, I was using something like:
06:33:25 <fserb> deepCheck' = quickCheckWith (stdArgs {maxSuccess = 1000,chatty=True })
06:33:42 <fserb> adding "deepCheck' :: Testable a => a -> IO ()"
06:33:43 <fserb> fixes it
06:34:31 <aristid> fserb: why didn't you say that? you claimed to be using quickCheck, where the error cannot happen :)
06:34:40 <aristid> evil monomorphism restriction
06:35:21 <fserb> aristid, sorry for that. It never occurred to me that the problem could be this :(
06:35:27 <arcatan> what's the motivation of monomorphism restriction?
06:35:32 <kmc> this is a good demonstration that the monomorphism restriction breaks equational reasoning
06:35:54 <kmc> that probably means it's a net loss to beginners, regardless of its motivation
06:36:23 <kmc> arcatan, when something has a type class constraint, an implementation is free to implement that constraint by passing an extra implicit argument
06:36:35 <kmc> this can turn things that don't look like functions into functions
06:37:08 <kmc> you might think that computations are being shared where they are not
06:37:32 <kmc> f n = (k + (1 :: Int), k + (1 :: Double)) where k = big computation on n
06:37:57 <kmc> when you write it like that (as opposed to «k n = big computation on n») you might expect that k will be computed once and shared
06:38:17 <kmc> the MMR is a crude way to recover this expectation, which probably does more harm than good
06:38:35 <benmachine> the MMR also protects against measles.
06:38:38 <kmc> indeed
06:38:43 <arcatan> :)
06:38:46 <kmc> it didn't quite get the axe in 2010, but its days are numbered
06:39:00 <benmachine> we got n+k in 2010
06:39:04 <benmachine> so it's not all bad
06:39:12 * kmc has a soft spot for n+k patterns
06:39:14 <benmachine> (where by "got" I mean "killed")
06:39:35 <benmachine> I wonder if anyone's written a program with {-# LANGUAGE NPlusKPatterns #-} yet
06:39:50 <arcatan> methinks n+k patterns don't bite people, though
06:39:51 <kmc> GHC will support them for the foreseeable future.  so now we just need to pretend they're a cool new extension that the world isn't ready for
06:40:17 <benmachine> arcatan: they might do, although I admit it's unlikely
06:41:01 <benmachine> arcatan: they mean that e.g. n + 1 = succ n means a different thing from (n + 1) = succ n
06:42:05 <arcatan> you're right
06:44:07 <ddarius> They don't people because people don't use them.
06:44:21 <Twey> I have to agree
06:44:33 <Twey> I was a proponent for a bit, but I never really found a useful application for them.
06:49:34 <osaunders> @hoogle avg
06:49:34 <lambdabot> No results found
06:49:40 <osaunders> @hoogle average
06:49:40 <lambdabot> No results found
06:49:45 <osaunders> @hoogle mean
06:49:45 <lambdabot> No results found
06:49:54 <osaunders> :(
06:54:45 <fserb> I'm trying to do: data X ; type Y = X ; instance A X ; instance A Y. I get a warning saying that this is only possible with TypeSynonymInstances. But even if I enable this, it doesn't like the type synonym instance.
06:54:55 <fserb> Is it a bad thing that I want to do that?
06:56:26 <fserb> after I add the -XTypeSynonymInstances I get an error saying 'duplicate instance declaration'
06:56:38 <fserb> which makes some sense, but not really... :)
06:59:19 <pr> > [LT .. GT]
06:59:19 <lambdabot>   [LT,EQ,GT]
06:59:24 <pr> > succ gt
06:59:25 <lambdabot>   Not in scope: `gt'
06:59:30 <pr> > succ GT
06:59:31 <lambdabot>   *Exception: Prelude.Enum.Ordering.succ: bad argument
06:59:38 <kmc> fserb, yes, it's not possible
06:59:38 <aristid> > succ LT
06:59:40 <lambdabot>   EQ
06:59:41 <kmc> synonyms are just synonyms
06:59:47 <kmc> they are transparent to the type checker
07:00:01 <kmc> perhaps you want:  newtype Y = MkY X
07:00:06 <aristid> > [LT ..]
07:00:07 <lambdabot>   [LT,EQ,GT]
07:00:14 <fserb> kmc, I see.
07:00:24 <kmc> now you need to deal with wrapping/unwrapping the MkY constructor, but you now have two separate types which you can make separate instances for
07:00:28 <pr> > length ['a'..]
07:00:28 <lambdabot>   1114015
07:00:30 <fserb> kmc, so what is the TypeSynonymInstances good for?
07:00:45 <kmc> fserb, if you want to write «instance Foo String» rather than «instance Foo [Char]»
07:00:54 <kmc> (you also need FlexibleInstances in that case)
07:01:09 <pr> > last ['a'..]
07:01:10 <lambdabot>   '\1114111'
07:01:18 <pr> > succ '\1114111'
07:01:19 <lambdabot>   *Exception: Prelude.Enum.Char.succ: bad argument
07:01:21 <kmc> fserb, it just allows you to use type synonyms in instances the way you'd use them elsewhere: to shorten a long type expression
07:01:31 <kmc> (shorten or simplify, i should say)
07:01:54 <fserb> kmc, I see. Makes sense. Thanks a lot.
07:01:58 <kmc> no problem :)
07:02:28 <fserb> kmc, maybe there's a different solution to my problem... I was trying to use this to create different instances of Arbitrary.
07:03:10 <fserb> kmc, but anyway.
07:03:20 <fserb> kmc, thanks :)
07:04:00 <pr> > maxBound :: (Int, Float, Double, Char)
07:04:01 <lambdabot>   No instances for (GHC.Enum.Bounded GHC.Types.Float,
07:04:01 <lambdabot>                    GHC....
07:05:12 <megajosh2> > (maxBound, maxBound, maxBound, maxBound) :: (Int, Float, Double, Char)
07:05:13 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
07:05:14 <lambdabot>    arising from a use o...
07:05:26 <megajosh2> Double has no max bound?
07:05:37 <megajosh2> > (maxBound, maxBound, maxBound) :: (Int, Float, Char)
07:05:38 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
07:05:38 <lambdabot>    arising from a use of...
07:05:43 <megajosh2> Hmm...
07:05:47 <megajosh2> > (maxBound, maxBound, maxBound) :: (Int, Char)
07:05:47 <lambdabot>   Couldn't match expected type `(GHC.Types.Int, GHC.Types.Char)'
07:05:47 <lambdabot>         agai...
07:05:51 <megajosh2> > (maxBound, maxBound) :: (Int, Char)
07:05:52 <lambdabot>   (9223372036854775807,'\1114111')
07:06:59 <pr> > maxBound :: (Int, Char)
07:07:00 <lambdabot>   (9223372036854775807,'\1114111')
07:07:30 <aristid> > maxBound :: (Int, Word, Char)
07:07:31 <lambdabot>   (9223372036854775807,18446744073709551615,'\1114111')
07:11:09 <Sadache> I have a [Either e [a]] which is infinite. I would like to take say 20 of a together with errors e that have been produces to evaluate them
07:11:45 <Sadache> and I feel Arrows could help to express them elegantly
07:12:15 <Sadache> actually I am trieng to find a readable way of expressing that
07:12:33 <aristid> Sadache: first specify precisely what you actually want
07:12:37 <benmachine> hmm
07:13:05 <Sadache> isn't it precise enough
07:13:54 <maltem> Sadache, a type signature would do, I think
07:14:27 <benmachine> :t let takeEithers n (e : es) = case e of Left err -> Left err : takeEithers (n-1) es; Right [] -> takeEithers n es; Right (a:as) = Right a : takeEithers (n-1) (Right as : es) in takeEithers
07:14:28 <lambdabot> parse error on input `='
07:14:31 <benmachine> ff
07:14:40 <Sadache> I have an infinite lazy list of [Either e [a]] and I want to get 20 a so the result would be ([e],[a])
07:14:52 <benmachine> ohh right
07:14:54 <aristid> Sadache: 20 a and 20 e?
07:15:06 <benmachine> so you get 20 [a], and all the [e] that precede them?
07:15:07 <Sadache> where [e] are only the errors that were produced for getting the 20 a
07:15:09 <Sadache> and not more
07:15:26 <benmachine> that sounds complicated, but explicit recursion would do the job
07:15:37 <maltem> Sadache, for the as that were produced, there are no errors?
07:15:58 <Sadache> e represents an error here actually
07:17:13 <Sadache> so in  [Either e [a]] the first element may have only 10 a in [a], that's when you need to move to next element which could be an e, and so on until you get 20 of them
07:18:40 <Sadache> ok imagine each Either e [a] is a web request that could succeed or fail, and it will return on success a limited number of elements
07:18:53 <Sadache> I need to do several requests to get my 20 elements
07:19:29 <Sadache> but there are errors there, so I want to get 20 elements, yet knowing all errors that I had getting them
07:20:56 <Sadache> I feel the problem very simple and real world. But I am failing to come out with a declarative readable solution
07:21:37 <Sadache> And I am sure that this should be possible in haskell. 
07:21:39 <aristid> Sadache: i think i would try an explicit recursion first
07:22:22 <benmachine> Sadache: I got an explicit recursion in 9 lines
07:22:36 <benmachine> it's not that simple a problem
07:22:50 <benmachine> hmm
07:23:16 <benmachine> if you could do Either e [a] -> [Either e a] and then just apply a modified take, that would do it
07:23:35 <osaunders> How do you convert an Int to Fractional a => a?
07:23:36 <benmachine> in fact this came up the other day
07:23:40 <Sadache> well my solution was to produce out of it a [Either e a] and then take until I have 20 a
07:23:45 <benmachine> osaunders: fromIntegral
07:23:56 <benmachine> Sadache: sounds reasonable
07:24:00 <osaunders> Ah, OK.
07:24:03 <osaunders> Doh
07:24:15 <benmachine> :t concatMap (either (Left . (:[]) Right)
07:24:16 <lambdabot> parse error (possibly incorrect indentation)
07:24:22 <benmachine> :t concatMap (either (Left . (:[])) Right)
07:24:23 <lambdabot>     Couldn't match expected type `[b]'
07:24:23 <lambdabot>            against inferred type `Either [a] b1'
07:24:23 <lambdabot>     In the first argument of `concatMap', namely
07:24:31 <benmachine> hmm
07:24:42 <benmachine> :t concatMap (either ((:[]) . Left) (map Right))
07:24:43 <lambdabot> forall a a1. [Either a [a1]] -> [Either a a1]
07:24:47 <benmachine> that was the one
07:24:47 <Sadache> but dont you think Arrows could help here?
07:24:55 <benmachine> Sadache: it's not obvious how they would
07:25:06 <benmachine> :t (|||)
07:25:07 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
07:25:18 <fserb> hmmm, if I have a newtype X = X Y. Is there any smarter way to do [ y | X y <- a ] where a :: [X] ?
07:25:23 <benmachine> :t (+++)
07:25:24 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
07:25:26 <Sadache> first would be the e and second would be [a]
07:25:52 <dschoepe> fserb: newtype X = X { theY : Y } and then map theY a
07:25:54 <ddarius> takeE n [] = ([],[]); takeE 0 _ = ([],[]); takeE n (Left e:xs) = first (e:) (takeE n xs); takeE n (Right a:xs) = second (a:) (takeE (n-1) xs)
07:25:57 <Sadache> i am just unsure about how Arrows deal with lazyness in that case
07:25:58 <ddarius> Seems simple enough.
07:26:17 <ddarius> If you assure the list is infinite, then the first case can be omitted.
07:26:19 <benmachine> ddarius: type is wrong
07:26:30 <benmachine> ddarius: it's Either e [a], remember
07:26:32 <ddarius> Ah yes, the [a]
07:26:33 <benmachine> oh
07:26:41 <benmachine> you could do your function after you've done mine, though
07:26:42 <fserb> dschoepe, thanks.
07:27:18 * benmachine wonders how one would write take with foldr, if indeed it is possible
07:28:00 <ddarius> takeE n [] = ([],[]); takeE 0 _ = ([],[]); takeE n (Left e:xs) = first (e:) (takeE n xs); takeE n (Right as:xs) = second (as'++) (takeE n' xs) where as' = take n; n' = length as'
07:28:05 <Sadache> you can write take with a scan first then takeWhile
07:28:21 <ddarius> :t let takeE n [] = ([],[]); takeE 0 _ = ([],[]); takeE n (Left e:xs) = first (e:) (takeE n xs); takeE n (Right as:xs) = second (as'++) (takeE n' xs) where as' = take n; n' = length as' in takeE
07:28:22 <lambdabot>     Couldn't match expected type `[a]'
07:28:22 <lambdabot>            against inferred type `[a1] -> [a1]'
07:28:22 <lambdabot>       Expected type: ([a2], [a])
07:28:36 <ddarius> :t let takeE n [] = ([],[]); takeE 0 _ = ([],[]); takeE n (Left e:xs) = first (e:) (takeE n xs); takeE n (Right as:xs) = second (as'++) (takeE n' xs) where as' = take n as; n' = length as' in takeE
07:28:37 <lambdabot> forall a a1. Int -> [Either a [a1]] -> ([a], [a1])
07:29:04 <benmachine> (n-n') presumably in that recursive case
07:29:09 <ddarius> yeah
07:29:17 <benmachine> that's not too bad
07:29:20 <benmachine> shorter than mine, anyway
07:29:39 <ddarius> And I guess you'll need to change the first case to a guard for <= 0 (which arguably was necessary anyway)
07:30:08 <ddarius> The length and take can be fused if you don't like the double traversal.
07:30:43 <ddarius> The latter two cases could be merged using either though it may not be any prettier.
07:30:52 <aristid> > let takeE n xs = reverse `fmap` h n xs ([], []); h 0 _ z = z; h _ [] z = z; h n (Left x : xs) (a, e) = h n xs (a, x : e); h n (Right as : xs) (a, e) = let a2 = take n as in h (n - length a2) xs (a ++ a2, e) in takeE 5 [Left 1, Left 2, Right [1,2,3,4], Left 3, Right [1,2,3]]
07:30:53 <lambdabot>   ([1,2,3,4,1],[1,2,3])
07:31:03 <benmachine> reverse, ew
07:31:11 <benmachine> also it didn't work :P
07:31:19 <aristid> huh? it looks correct to me
07:31:39 <ddarius> aristid: You don't want to use an accumulator for this.
07:32:06 <benmachine> aristid: oh right, you returned the parameters in the other order and it confused me
07:32:36 <aristid> ddarius: to avoid thunks building up?
07:33:18 <aristid> hmm and because it's not necessary
07:33:19 <ddarius> aristid: It's more complicated, requires a reverse, and precludes streaming usage.
07:33:47 <aristid> sometimes my mind doesn't find the simplest solution at first :)
07:34:44 <osaunders> OK another stupid question. How do you convert a Num n => n to Fractional f => f?
07:34:57 <aristid> ddarius: i think your code is not completely correct tho, but i need to test it first
07:35:21 <benmachine> :t let takeEithers n = go n . concatMap (either (return . Left) (map Right)) where go n _ | n <= 0 = []; go n (e@(Left _) : es) = e : go n es; go n (a@(Right _) : es) = a : go (n-1) es in takeEithers
07:35:22 <lambdabot> forall a a1 a2. (Ord a, Num a) => a -> [Either a1 [a2]] -> [Either a1 a2]
07:35:51 <aristid> ddarius: there, fixed: let takeE n [] = ([],[]); takeE 0 _ = ([],[]); takeE n (Left e:xs) = first (e:) (takeE n xs); takeE n (Right as:xs) = second (as'++) (takeE n' xs) where as' = take n as; n' = n - length as' in takeE
07:36:01 <ddarius> aristid: There is an error that benmachine pointed out.
07:36:16 <aristid> oh didn't see that benmachine said that
07:36:21 <aristid> well, i found it too
07:36:30 <ddarius> Yes, as did I.
07:37:35 <aristid> benmachine: oh, you flatten it first?
07:37:59 <benmachine> aristid: yeah I thought that was neater
07:38:16 <benmachine> in fact I could either again in go
07:38:45 <ddarius> This could be written as a higher order fold as well, though it's probably not very desirable to do so.
07:39:03 <benmachine> let takeEithers n = go n . concatMap (either  (return . Left) (map Right)) where go n _ | n <= 0 =  []; go n (e@(Left _) : es) = e : go n es; go n  (a@(Right _) : es) = a : go (n-1) es in takeEithers
07:39:08 <benmachine> oh whoops
07:39:10 * benmachine pasted instead of copying
07:39:26 <aristid> benmachine: i always have trouble with the clipboard too :D
07:39:41 <benmachine> aristid: it's a hard life
07:39:48 <aristid> yes indeed
07:42:05 <aristid> why oh why doesn't lambdabot understand :t in queries :(
07:42:12 <benmachine> try @type
07:42:57 <Sadache> i find it strange that a solution to this should be this complicated. I mean now my need is to take n elements. Maybe then I will need to takeWhile a predicate holds, or dropWhile. It isn't optimal to define it recusively I feel. There are similarities there. This kind of thing is very useful for signal processing
07:43:16 <aristid> benmachine: i know
07:43:31 <aristid> benmachine: just always type :t first, wait 3 seconds and notice it's no network delay
07:43:41 <Sadache> I thought arrowd would allow express them easily, as easy as you'd express things in a monad by abstracting some of the structure away
07:43:50 <benmachine> Sadache: you need the right combinators
07:43:56 <benmachine> Sadache: it's genuinely not that hard
07:44:13 <benmachine> takeEithers n = go n . concatMap (either (return . Left) (map Right)) where go n _ | n <= 0 = []; go n (e : es) = either (\e -> first (e :) $ go n es) (\a -> second (a :) $ go (n-1) as) e
07:44:17 <aristid> as benmachine's solution indicates, it's actually two problems folded in one
07:44:25 <benmachine> yeah
07:44:41 <benmachine> make a separate function for flattening and then the second part is two lines of recursion
07:44:41 <ddarius> Sadache: The recursive definition isn't complicated.  There no doubt are similarities that can be abstracted.  Once you write the recursive definitions often enough you will see them and then you can pull out the similarities into generic functions.
07:44:50 <Sadache> benmachine: that's exactly what I am looking for, the right abstraction, the right combinators to make signal processing trevial and more declarative
07:45:04 <benmachine> Sadache: combinators are defined as the need for them arises
07:45:16 <benmachine> Sadache: if your problem was genuinely a common one I'm sure there would be more abstractions for it
07:45:25 <benmachine> Sadache: but really it's four lines of code at most
07:45:29 <Sadache> ddarius: yes but I find it weired that they don't exist already.
07:45:33 <benmachine> think about what you can do in C in four lines!
07:45:37 <ddarius> Sadache: They probably do.
07:45:38 <benmachine> basically bugger all.
07:45:48 <ddarius> Certainly there are several Haskell libraries for doing signal processing.
07:46:17 <ddarius> Also, signal processing already has a declarative language of its own.  Ideally, you just realize that language.
07:46:30 <Sadache> benmachine: I am not comparing here, I just feel it general enough of a problem specially deal with lazy lists
07:46:52 <aristid> Sadache: well, write the combinators necessary to make it elegant and submit them on hackage
07:47:37 <benmachine> Sadache: the non-generality comes when you're dealing with a lazy list of Either values of which the Rights are lists and the Lefts are singletons
07:47:43 <ddarius> In my programming experience, including signal processing, I've never needed a function like the one you call takeE.
07:47:58 <Sadache> like something like: I am focusing on elements with that properties without loosing others. Then afterwords I could turn focus and so on
07:48:01 <ddarius> s/you call/we called/
07:48:03 <benmachine> Sadache: where are you getting this list from? is there a way to get it in a different, more natural format?
07:48:55 <aristid> @let flattenEithers = concatMap (either (return . Left) (map Right))
07:48:57 <lambdabot>  Defined.
07:49:13 <Sadache> benmachine: it is out of a web request that returns either a list or an undesired result
07:49:34 <benmachine> @undefine
07:49:51 <benmachine> @let flattenEithers = (either (return . Left) (liftM Right) =<<)
07:49:52 <lambdabot>  Defined.
07:50:01 <benmachine> :t flattenEithers -- pointless generality ftw
07:50:02 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (Either a (m a1)) -> m (Either a a1)
07:50:18 * ddarius doesn't see how processing web requests is something that would be well handled by a signal processing library.
07:50:33 <aristid> @let  let takeEithers n _ | n <= 0 = []; takeEithers n (e@(Left _) : es) = e : takeEithers n es; takeEithers n (a@(Right _) : es) = a : takeEithers (n-1)
07:50:33 <lambdabot>   Parse error: KW_Let
07:50:40 <aristid> @let takeEithers n _ | n <= 0 = []; takeEithers n (e@(Left _) : es) = e : takeEithers n es; takeEithers n (a@(Right _) : es) = a : takeEithers (n-1)
07:50:41 <lambdabot>  <local>:2:126:
07:50:41 <lambdabot>      Couldn't match expected type `[Either t t1]'
07:50:41 <lambdabot>            ...
07:50:53 <aristid> @let takeEithers n _ | n <= 0 = []; takeEithers n (e@(Left _) : es) = e : takeEithers n es; takeEithers n (a@(Right _) : es) = a : takeEithers (n-1) es
07:50:54 <lambdabot>  Defined.
07:51:00 <aristid> damn i totally fail at copy&paste
07:51:10 <benmachine> heh
07:51:15 <aristid> :t \n -> partitionEithers . takeEithers n . flattenEithers
07:51:17 <lambdabot> forall a b a1. (Num a1, Ord a1) => a1 -> [Either a [b]] -> ([a], [b])
07:51:20 <aristid> \o/
07:51:37 <benmachine> :)
07:51:41 <aristid> Sadache: see, we have split your problem into combinators that neatly fit together :)
07:51:57 <Sadache> ddarius: it is all about focusing on some kind of elements, abstrcting away the rest of them, and then being able to focus back on others. Like filter but without loosing elements
07:52:22 <aristid> focus... sounds comonadic :D
07:52:30 <benmachine> Sadache: like filter but without losing elements = partition, as aristid demonstrated
07:53:53 <Sadache> someone told me partitionEither hangs on infinite lists
07:54:31 <aristid> @src partitionEithers
07:54:31 <lambdabot> Source not found. :(
07:54:32 <Sadache> and anyway again, it is not my particular problem that I am trying to solve, but rather a whole set of problems that requiring changinf focus
07:54:33 <benmachine> we're not using it on an infinite list
07:54:37 <Sadache> changing
07:54:44 <benmachine> we're using it on the result of takeEithers n
07:54:57 <benmachine> which is finite, unless there are too few Rights in your list
07:55:25 <Twey> > join (***) (take 1) $ [Left 1, Right 2] ++ map Right [1 ..]
07:55:27 <lambdabot>   Couldn't match expected type `([a], [a])'
07:55:27 <lambdabot>         against inferred type `[D...
07:55:31 <aristid> Sadache: you could be a bit more appreciative for our efforts :P
07:55:45 <ddarius> partitionEithers should work as fine as possible given its meaning on infinite lists (modulo possibly some edge cases)
07:55:48 <benmachine> and yes the whole set of problems that require changing focus will all be small modifications of the composition chain aristid has come up with
07:55:56 <benmachine> ddarius: should do /= does :P
07:56:08 * benmachine tests
07:56:14 <Twey> > join (***) (take 1) . partitionEithers $ [Left 1, Right 2] ++ map Right [1 ..]
07:56:16 <lambdabot>   (*Exception: stack overflow
07:56:17 <Twey> Hmph :-\
07:56:22 <aristid> "ok you solved my problem, first your solution was not elegant enough, then you made it more elegant, but now i don't actually want to solve my problem"
07:56:33 <benmachine> Twey: quite
07:57:20 <ddarius> > join (***) (take 1) . partitionEithers $ [Left 1, Left 2] ++ map Right [1 ..]
07:57:23 <lambdabot>   (*Exception: stack overflow
07:57:23 <Sadache> aristid: do I look like that?:)
07:57:27 <benmachine> @let partitionEithers' [] = ([], []); partitionEithers' (e:es) = either (first . (:)) (second . (:)) e es
07:57:28 <lambdabot>  <local>:3:60:
07:57:28 <lambdabot>      Couldn't match expected type `[Either a b]'
07:57:28 <lambdabot>             a...
07:57:31 <aristid> Sadache: you talk like that
07:57:53 <Sadache> aristid: actually I didn't mean that, I am just trying to express what I have in my mind
07:58:12 <benmachine> @let partitionEithers' [] = ([], []); partitionEithers' (e:es) = either (first . (:)) (second . (:)) e $ partitionEithers' es
07:58:13 <lambdabot>  Defined.
07:58:22 <aristid> benmachine: and that one is lazier?
07:58:32 <benmachine> aristid: I think first/second are appropriately lazt
07:58:32 <aristid> why is the default one not lazy?
07:58:34 <benmachine> *lazy
07:58:51 <benmachine> aristid: because it matches (xs, ys) against the recursive case instead of ~(xs, ys) I think
07:59:04 <Sadache> aristid: although it looked though to me (lazy)
07:59:13 <Twey> > join (***) (take 1) . partitionEithers' $ [Left 1, Right 2] ++ map Right [1 ..]
07:59:14 <lambdabot>   ([1],[2])
07:59:40 <benmachine> yaaaay
07:59:42 <aristid> Sadache: you have three nice combinators now, can't you use them to solve your problems?
08:00:09 <ddarius> So (as I suspected) the problem is the strict pattern match on the tuple in the definition of partitionEithers.
08:00:24 <benmachine> mm
08:00:35 <benmachine> I wonder if that's in the h2010 report or if it's a base bug
08:01:22 <ddarius> Haskell 2010 doesn't say anything about this.
08:02:06 <aristid> :t let partitionEithers'' = lefts *** rights
08:02:07 <lambdabot> <no location info>:
08:02:07 <lambdabot>     not an expression: `let partitionEithers'' = lefts *** rights'
08:02:11 <aristid> :t let partitionEithers'' = lefts *** rights in partitionEithers''
08:02:12 <lambdabot> forall a b a1 b1. ([Either a b], [Either a1 b1]) -> ([a], [b1])
08:02:27 <ddarius> You want (&&&)
08:02:38 <aristid> ah, yeah.
08:03:07 <ddarius> (Incidentally, partitionEithers is a common function in signal processing, usually called demux.)
08:03:14 <Twey> partitionEithers = on either (. (:)) first second `foldr` ([], [])
08:03:37 <aristid> :t let partitionEithers = on either (. (:)) first second `foldr` ([], []) in partitionEithers
08:03:38 <lambdabot> forall a. [Either a a] -> ([a], [a])
08:04:14 <ddarius> Type is too strict.
08:04:24 <aristid> :t let partitionEithers = foldr (either `on` (. (:)) $ first second) ([], []) in partitionEithers
08:04:25 <Twey> Ah, yeah.  Damn that.
08:04:25 <lambdabot>     Precedence parsing error
08:04:25 <lambdabot>         cannot mix `on' [infixl 0] and `$' [infixr 0] in the same infix expression
08:05:15 <Twey> I don't like that we have to duplicate code to get around that.
08:05:19 <aristid> :t on either (. (:))
08:05:20 <lambdabot> forall a c. (([a] -> [a]) -> c) -> (([a] -> [a]) -> c) -> Either a a -> c
08:05:35 <Twey> There should be some sort of solution.
08:05:50 <ddarius> It makes sense that you have to.
08:06:21 <aristid> :t on
08:06:23 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:07:29 <aristid> :t undefined :: (a' -> b' -> c) -> (forall t. t -> t') -> (a -> b -> c)
08:07:30 <lambdabot> forall a' b' c t' a b. (a' -> b' -> c) -> (forall t. t -> t') -> a -> b -> c
08:07:48 <aristid> something like that but less general
08:07:58 <aristid> or less strict, depending how you see it
08:08:11 <Twey> ddarius: Sure, sort of, but from a practical standpoint it's not nice.
08:08:27 <aristid> :t (. (:))
08:08:28 <lambdabot> forall b a. (([a] -> [a]) -> b) -> a -> b
08:08:32 <ddarius> It rarely comes up.
08:08:42 <Twey> I've hit it twice at least
08:08:50 <Twey> Here, and also with ‘join (***)’
08:09:05 <benmachine> http://haskell.org/onlinereport/haskell2010/haskellpa2.html#x20-192000II <-- weird, there's no Data.Either in the 2010 report
08:09:46 <Phantom_Hoover> @join #esoteric
08:09:47 <lambdabot> Not enough privileges
08:09:58 * Phantom_Hoover curses the heavens in rage.
08:10:00 <ddarius> @where ffi
08:10:00 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
08:10:04 <aristid> Twey: maybe it is possible to make a version of on and join that is just good enough for your problems?
08:10:23 <benmachine> aristid: I'm not sure it can work, typewise
08:10:30 <Twey> It can't
08:10:31 <benmachine> unless you have some sort of weird existential
08:10:38 <Twey> We need more weird existentials :þ
08:10:42 <aristid> benmachine: yeah i was thinking about some sort of weird existential
08:10:44 <ddarius> benmachine: The only libraries there are the ones from Haskell 98 and the FFI.  2010 didn't change much or anything library-wise (or, hell, even language-wise.)
08:10:51 <benmachine> heh
08:10:58 <aristid> but really (forall t. t -> t) is much too demanding on the function
08:11:02 <benmachine> and now 2011 is going to be the year of everyone-forgot-to-actually-submit-anything
08:11:09 <aristid> is it maybe possible to find something that is halfway there?
08:11:18 <benmachine> (fortwo a. a -> b)
08:11:21 <pr> at least it will be out before c++0x
08:11:25 <pr> so it's not THAT bad
08:11:28 <benmachine> heh
08:11:28 <aristid> benmachine: haha.
08:11:56 <ddarius> "Haskell 2011 Report: See Haskell 2010 Report."
08:16:56 <Phantom_Hoover> epicbeardman_, I put it to you that you are neither epic nor bearded.
08:17:02 <Sadache> so solution you provided comes very close to what I want to do
08:17:08 <Sadache> thank you guys
08:17:13 <Sadache> you are the best
08:33:14 <imc> is there a syntax for one-line case of pattern matching?
08:33:41 <imc> i.e. case a of { Foo -> this; Bar -> that } ?
08:34:02 <Botje> if there is, that would be it, yes :)
08:34:21 <identity> imc: as in, case expression on one line?
08:34:28 <imc> identity: yep
08:34:33 <imc> ghci says so: Warning: Pattern match(es) are overlapped
08:34:37 <identity> > case 3 of { 1 -> "one"; 3 -> "three"; }
08:34:37 <imc> for the above syntax
08:34:38 <lambdabot>   "three"
08:34:49 <identity> imc: that's because your pattern matches are overlapped
08:34:54 <identity> that doesn't really have anything to do with the formatting
08:35:02 <imc> maybe i should not use "otherwise" in such syntax
08:35:11 <imc> such expression
08:35:31 <identity> otherwise doesn't work in case expressions unless you're doing case of BoolVariable { .. }
08:35:35 <identity> otherwise is just True
08:35:37 <identity> > otherwise
08:35:38 <lambdabot>   True
08:35:48 <identity> E.g. a catch all case when using guards
08:35:57 <imc> identity: it's a "sort of" bool data
08:36:24 <imc> that's it: isValid a = case a of { !valid -> True; otherwise -> False }
08:36:26 <identity> imc: That doesn't tell me much, but if you're getting overlapped pattern matches, the code won't do what you think it will most likely
08:36:37 <monochrom> > case False of { otherwise -> otherwise }
08:36:38 <lambdabot>   False
08:36:51 <identity> imc: hmm
08:36:57 <identity> imc: so a = Bool?
08:37:16 <imc> no a = Valid | Invalid | Error String | Trace [String]
08:37:22 <monochrom> "!valid" is a syntax error
08:37:26 <imc>  valid :: a
08:37:40 <imc> monochrom: strict evaluation
08:37:43 <imc> (maybe?)
08:37:50 <monochrom> case a of { Valid -> True; _ -> False }
08:37:58 <identity> imc: you probably want case a { Valid -> True; _ -> False; }
08:38:01 <identity> -;
08:38:04 <identity> yeah.
08:38:07 <imc> monochrom: the isValid definition is on a class
08:38:07 <Gracenotes> constructor matching is quite strict already
08:38:17 <imc> Gracenotes: good
08:38:28 <imc> yeah, better _ over otherwise
08:38:41 <Gracenotes> it's why foldl' (:) [] xs is no better than foldl (:) [] xs
08:38:41 <imc> (not really, as ghci says)
08:39:02 <imc> isValid should really evaluate its argument
08:39:19 <identity> imc: case doesn't do that
08:39:23 <identity> You're just comparing values
08:39:25 <Gracenotes> are you familiar with what WHNF, HNF, NF are?
08:39:33 <monochrom> > case 3 of { 1->True; this'is'otherwise -> this'is'otherwise }
08:39:34 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
08:39:34 <lambdabot>    arising from the literal `3'...
08:39:41 <imc> that's why i've put BangPatterns and ! strictness
08:39:42 <monochrom> > case 3 of { 1->1; this'is'otherwise -> this'is'otherwise }
08:39:43 <lambdabot>   3
08:40:18 <identity> monochrom: ah, interestin
08:40:18 <identity> g
08:40:34 <monochrom> "otherwise" is not a reserved word
08:40:46 <identity> Nah, I told him that before
08:40:47 <imc> identity: should i do that with "if-then-else" insteead?
08:41:03 <imc> monochrom: (is defined in Data.Bool.othrewise, as True)
08:41:11 <identity> imc: I'm still not entirely sure what you want; you want True if a = Valid and False if Invalid?
08:41:14 <Gracenotes> WHNF meaning the value isn't bottom: you can get a constructor (except if it's a lambda). NF meaning the value contains no bottoms, can be fully evaluated. er but this isn't about strictness is it
08:41:22 <imc> identity: no False if not valid
08:41:25 <monochrom> therefore you can shadow it
08:41:30 <identity> imc: that's what I said
08:41:36 <identity> False if Invalid
08:41:40 <identity> or you mean, for all other values?
08:41:42 <monochrom> > case "I am not True" of { otherwise -> otherwise }
08:41:42 <lambdabot>   "I am not True"
08:41:47 <imc> identity: can be Invalid | Error String | Trace [String]
08:41:59 <identity> imc: Then what we gave you ages ago is what you need
08:42:09 <andern> i'm trying to import the Network module, and it says that it cant be found. i'm reading the "Roll your own IRC bot" on haskell.org, and it says you just need a reasonably recent version of GHC or Hugs. do i need some external library or something?
08:42:12 <identity> case a of { Valid -> True; _ -> False }
08:42:14 <imc> (but data implementation is not known in advance, that's why i've put the `valid` zero-arg function)
08:42:28 <imc> identity: ghci still complains
08:42:34 <monochrom> cannot use function in pattern
08:42:58 <identity> Hmm
08:43:01 <identity> imc: are you sure?
08:43:15 <imc> identity: shure
08:43:27 <monochrom> how many instances do you have for your type class now?
08:44:04 <imc> monochrom: none
08:44:16 <imc> monochrom: (one commented-out)
08:44:18 <monochrom> then it is premature generalization
08:45:18 <imc> how can i force evaluation of zero-arg function and patter match on it's result? (is it even possible?)
08:45:25 <monochrom> with 99% probability next month you will regret this type class
08:45:53 <imc> can i ask you why?
08:46:02 <imc> (short answer if possible :P)
08:46:10 <identity> imc: I just created a dummy type data Blah = Valid | Invalid | Something and foo = case Something { Valid -> True; _ -> False } and ghci isn't complaining
08:46:20 <ddarius> > 0x18000
08:46:21 <lambdabot>   98304
08:46:37 <monochrom> case zero'arg'function of { 4 -> ... }  that's how.
08:46:47 <identity> imc: your case must have more than one case
08:46:56 <imc> identity: you are pattern matching on the actual data cases, not on a zero-arg function returning it
08:46:59 <identity> And the order is important
08:47:24 <identity> imc: That makes no sense -- if you ahve a function that returns one of the types, you would do: case function of ...
08:47:35 <imc> monochrom: zero-arg function is the pattern, not what to match
08:47:55 <identity> imc: What *exactly* do you want do do?
08:48:06 <identity> Because I'm pretty sure that we've already provided a solution
08:48:37 <imc> i want an extended boolean enabling error messages and stack traces
08:48:39 <monochrom> then it cannot be done.
08:49:31 <imc> i.e. when a computation gives an error, further computation will not be run (but can add messages to the stack trace)
08:49:46 <imc> i can leave the "isValid" implementation on the instances and i'm done
08:49:52 <imc> not a big deal really
08:50:22 <ray> that's like Either String Bool
08:50:44 <imc> ray: somewhat yes
08:51:22 <imc> but to learn one should re-invent the wheel
08:51:25 <imc> at first at least
08:52:07 <ray> well, that's the wheel, feel free to reinvent it
08:52:32 <ray> just make sure you aren't inventing the differential instead by mistake
08:52:39 <monochrom> you are likely misguidedly writing code for method default. this code belongs to instances, not the default.
08:52:52 <ddarius> > 12 * 80 + 40
08:52:53 <lambdabot>   1000
08:52:57 <ray> i love metaphors they can get so absurd
08:53:16 <imc> monochrom: exactly
08:53:29 <ray> make sure your transmission doesn't slip
08:54:00 <monochrom> inside instance code, you can surely be concrete about the data structure.
08:55:02 <monochrom> when I learned I revinvented wheels, sure. I just didn't try to make them square like some people do.
08:56:27 <ddarius> Square wheels store better.
08:56:43 <imc> ghgh
08:56:57 <imc> wheels aren't used (usually) as stores
08:57:03 <imc> but they can be
08:57:27 <imc> yay, made instance for Bool, isValid = id ;)
08:59:29 <imc> discussing clears the mind
09:17:33 <identity> @src guard
09:17:34 <lambdabot> guard True  =  return ()
09:17:34 <lambdabot> guard False =  mzero
09:17:37 <identity> good stuff
09:32:45 <identity> @hoogle Bool -> m a -> m a
09:32:46 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
09:32:46 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
09:32:46 <lambdabot> Data.Graph.Inductive.Internal.Queue queuePut :: a -> Queue a -> Queue a
09:33:03 <identity> ah..
09:36:18 <pr> does anybody use emacs w/ haskell-mode and identation mode being haskell-indentation?
09:37:10 <pr> no matter what tab-width i set in emacs, it seems to default to tab-width 2 in cases where there's nothing to align to
09:44:14 <pr> seems to be the same for all three indentation modes
09:59:13 <identity> Why is it that I cannot compare some type Maybe a with Nothing when a is not an instance of Eq? That seems unintuitive for some reason
09:59:16 <identity> I'm not comparing a, after all
09:59:20 <identity> but Maybe a
10:00:28 <Lemmih> identity: Use isNothing.
10:00:33 <identity> Lemmih: I know
10:00:40 <identity> I just ran into this and wondered why it didn't work
10:00:48 <identity> Looking for an explanation rather than a solution
10:00:50 <identity> the more you know, etc.
10:01:37 <Lemmih> identity: The contained type must be an instance of Eq because it might be compared.
10:02:02 <identity> oh, duh
10:02:03 <identity> of course
10:03:08 <identity> E.g. (Just 3) == (Just 4) = 3 == 4
10:03:11 <identity> thanks.
10:07:12 <iago> identity, this is like the xs == [] stuff
10:07:59 <iago> null xs does not require xs to be of type Eq a => [a]
10:08:13 <identity> iago: Ah, yes, I hadn't thought of that to be frank
10:08:15 <identity> But I do use null
10:09:31 <c_wraith> bah.  clearly the correct way is (0 ==) . length
10:09:32 <c_wraith> :P
10:09:51 <c_wraith> (please don't do that, unless you know why it'll not be horrible)
10:10:33 <monochrom> I can imagine some shootout websites do that. "It's for testing speed!"
10:11:34 <Peaker> genericLength :: [a] -> Nat
10:14:56 <c_wraith> heh.  yes, that'd be the right way to do it, Peaker. :)
10:15:28 <c_wraith> Why does \bot not have natural anymore?  too many infinite processes?
10:17:27 <Vanadium> (Because then you can pattern-match on Succ whatever not being 0 already?)
10:17:52 <c_wraith> yeah, == 0 with natural doesn't need to evaluate the whole Nat
10:18:20 <c_wraith> It fits the (S _) Z = False case :)
10:24:42 <shachaf> Peaker: Alternatively, instance Num [a] where ...
10:26:58 <c_wraith> strangely, that's require an Eq => a constraint.
10:27:05 <c_wraith> err, *that'd*
10:27:24 <c_wraith> Or, no it wouldn't, I'm confused
10:29:09 <identity> Why do I have a feeling that this pattern could be enhanced in some obvious manner?: http://haskell.pastebin.com/v5isBWge
10:29:41 <identity> the if expression in particular
10:29:48 <identity> because it feels really inelegant
10:31:32 <JoeyA> identity: one aspect of this code that might prove to be inelegant is confusing semantics (as opposed to semantics that are obvious from the types).  You'll really want to document what "UntilOK" means.
10:32:24 <JoeyA> I once wrote a function called "updateInodeIfNeeded", then came back to the code to realize that "IfNeeded" is really vague.
10:32:58 <identity> JoeyA: True enough
10:32:59 <JoeyA> updateInode by itself is clearer.
10:33:13 <JoeyA> So maybe you should have a separate doRequest
10:33:30 <identity> yes, it could use refactoring
10:33:38 <JoeyA> then doRequestUntilOK could be a concise wrapper around it.
10:35:15 <ninly> n00b question about function type declarations: what is wrong with line 5 here? http://haskell.pastebin.com/rgp5kMUw
10:35:34 <ninly> actually, i have a sense of what's wrong, but i'm not sure what would be right
10:36:04 <identity> ninly: You probably want it to be (Integral a) => a => Int
10:36:05 <identity> or Integer
10:36:10 <identity> Int is probably fine
10:36:12 <JoeyA> length yields an Int
10:36:17 <sinelaw> :t length
10:36:18 <lambdabot> forall a. [a] -> Int
10:36:20 <ninly> oh oh i see
10:36:20 <sinelaw> yip
10:36:27 <identity> eh, second => = ->
10:36:32 <ninly> one of my attempts was Int b, but that didn't work
10:36:43 <sinelaw> ninly, Int is a type
10:36:44 <JoeyA> Int isn't a type class, it's a type.
10:36:51 <ninly> right, i get it now. thanks all!
10:36:58 <identity> ninly: You could write that like this, too: factorialLength = lengt . show . factorial
10:37:24 <ninly> i'll get to that shortly :) working my way through lyah again...
10:37:24 <sinelaw> ninly, i tend to leave my guesses at types in comments, and compile with -Wall to see what the compiler says the type is
10:37:56 <identity> sinelaw: You don't prefer to work in ghci when writing code?
10:38:08 <sinelaw> no
10:38:14 <identity> Huh
10:38:16 <sinelaw> i usually write a lot of code at once
10:38:18 <ninly> what's the comment char in haskell?
10:38:19 <identity> I see.
10:38:24 <identity> ninly: -- for one liners
10:38:34 <JoeyA> When doing Project Euler, it almost feels evil to use Integer because it makes those big integer problems too friggin easy.
10:38:38 <identity> {- starts a multi line comment, -} ends it
10:38:51 <identity> JoeyA: Hehe, yes, it does. 
10:38:52 <ninly> got it; thanks again
10:39:10 <identity> JoeyA: That was the reason I didn't finish a lot of them when I was doing them all in C++ once
10:39:25 <identity> (doing all the ones that I have done, not all of them x_X)
10:39:37 <JoeyA> > sum $ map (read . pure) $ show $ product [1..100]
10:39:38 <lambdabot>   648
10:39:43 <identity> :t pure
10:39:44 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
10:40:41 <JoeyA> I'm only up to 25.  However, I feel like I know plenty of Haskell for now, so I plan on doing exercises in C# because I need to get around to learning it.
10:41:11 <JoeyA> Yesterday, I tore up about 9 of the beginner Euler problems with Haskell </brag>
10:41:14 <identity> JoeyA: I did a slew of them in C# as well. It's pretty fun with LINQ.
10:41:22 <JoeyA> heh, cool
10:41:35 <identity> http://blog.functionalfun.net -- this dude has done a shitton of them in C#
10:41:51 <identity> Software developer, etc, whips up some pretty nifty solutions
10:42:12 <sinelaw> linq is a mutilation of functional programming
10:42:19 <identity> sinelaw: It is indeed
10:42:29 <alej> ugh…just took CS GRE
10:43:16 <alej> there was a question on databases that i got right because of haskell/ghc though :)
10:43:22 <Raynes> Rayne: There can only be one.
10:44:51 <Rayne> my archenemy, you will never get my nickname!
10:46:43 <donri> Ayn Rayne
10:49:27 <ManateeLazyCat> readFile will ignore *quoted character* ?
10:50:41 <ManateeLazyCat> readFile read "/usr/bin/mplayer
10:53:24 <ManateeLazyCat> > show '\x00'
10:53:25 <lambdabot>   "'\\NUL'"
10:54:47 <ManateeLazyCat> Got it.
10:54:56 <ManateeLazyCat> Use '\x00' replace it.
11:00:06 <ManateeLazyCat> > show '
11:00:07 <lambdabot>   <no location info>:
11:00:07 <lambdabot>      lexical error in string/character literal at end o...
11:00:31 <ManateeLazyCat> > show "
11:00:32 <lambdabot>   <no location info>:
11:00:32 <lambdabot>      lexical error in string/character literal at end o...
11:00:38 <ManateeLazyCat> > show '\x00'
11:00:40 <lambdabot>   "'\\NUL'"
11:00:44 <ManateeLazyCat> > show '\0'
11:00:45 <lambdabot>   "'\\NUL'"
11:00:49 <ski> > '\x00'
11:00:50 <lambdabot>   '\NUL'
11:00:58 <ManateeLazyCat> > '\0'
11:00:59 <lambdabot>   '\NUL'
11:01:03 <ManateeLazyCat> Hmm, same.
11:01:08 <ski> of course
11:01:18 <ski> > '\0' == '\NUL'
11:01:18 <lambdabot>   True
11:01:36 <ski> > ['\0'..]
11:01:37 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
11:02:33 <ManateeLazyCat> Haha, fix my process manager.
11:09:52 * hackagebot proc 0.0.8 - Parse process information for Linux  http://hackage.haskell.org/package/proc-0.0.8 (AndyStewart)
11:16:08 <jirka> Hello people. I am trying to count how many times each character occurs in a given string and all my attempts yet have been pathetically slow
11:16:25 <jirka> any suggestions how to do this efficiently? please?
11:17:01 <Philippa> use an appropriate data structure to store the character frequencies?
11:17:21 <Cale> > map (\xs -> (head xs, length xs)) . group . sort $ "mississippi"
11:17:22 <lambdabot>   [('i',4),('m',1),('p',2),('s',4)]
11:18:05 <jirka> wow, you are awesome! 0.5M characters in less than a second!
11:18:24 <EvanR> ghc optimizes beautiful code more ;)
11:18:46 <ddarius> EvanR: That code is certainly not beautiful for what it does.
11:18:51 <EvanR> haha
11:19:02 <Philippa> it does something non-obvious, amongst other things
11:19:12 <Cale> > map (head &&& length) . group . sort $ "mississippi"
11:19:13 <lambdabot>   [('i',4),('m',1),('p',2),('s',4)]
11:19:31 <jirka> apparently. I managed only 20K characters in about half a minute. For whole book it would take a whole life, I guess
11:19:47 <Cale> jirka: What algorithm were you using?
11:19:51 * ddarius is not even sure how jirka could do that.
11:19:54 <silver> sorting is godlike
11:19:57 <Philippa> ddarius: list abuse
11:20:20 <jirka> on first try I wrote a recursive function
11:20:22 <Philippa> take the obvious algorithm and use /really inappropriate/ data structures
11:20:50 <ddarius> Treat lists as arrays.
11:21:02 <EvanR> treat Arrays as arrays ;)
11:21:05 <Cale> as mutable arrays :)
11:21:25 <jirka> it took first two pairs from a sorted list, decided whether they are equal, If so, combined them into one and called itself over the result... something like that
11:22:02 <jirka> should I post it somewhere? Probably not...
11:23:16 <Cale> ah, okay
11:24:58 <jirka> Cale: BTW, what does &&& ?
11:25:11 <Cale> f &&& g = \x -> (f x, g x)
11:25:44 <Cale> It's from Control.Arrow, and actually is a bit more general than the code I just wrote.
11:26:06 <jirka> well, It looks almost like a magic to me
11:26:14 <silver> @hoogle group
11:26:15 <lambdabot> Data.ByteString group :: ByteString -> [ByteString]
11:26:15 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
11:26:15 <lambdabot> Data.ByteString.Char8 group :: ByteString -> [ByteString]
11:26:32 <Cale> > (head &&& length) "aaaaa"
11:26:33 <lambdabot>   ('a',5)
11:27:08 <Palmik> pretty nifty :)
11:27:12 <Cale> > group "iiiimppssss"
11:27:13 <lambdabot>   ["iiii","m","pp","ssss"]
11:27:23 <EvanR> haskell is 25% magic and 5% more magic
11:27:27 <EvanR> .. 75
11:27:34 <arcasin> @type ***
11:27:34 <lambdabot> parse error on input `***'
11:27:41 <arcasin> @type (***)
11:27:41 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:27:42 <EvanR> :t (***)
11:27:42 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:28:50 <arcasin> :t (&&&)
11:28:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:29:06 <arcasin> oh i see
11:29:15 * hackagebot archlinux 0.3.3 - Support for working with Arch Linux packages  http://hackage.haskell.org/package/archlinux-0.3.3 (DonaldStewart)
11:30:17 * hackagebot cabal2arch 0.7.4 - Create Arch Linux packages from Cabal packages  http://hackage.haskell.org/package/cabal2arch-0.7.4 (DonaldStewart)
11:32:50 <McManiaC> > (head *** (+1)) ([1..5],2)
11:32:51 <lambdabot>   (1,3)
11:32:52 <McManiaC> ok :)
11:33:31 <ski> @type snd &&& fst
11:33:32 <lambdabot> forall a c. (a, c) -> (c, a)
11:33:41 <McManiaC> hehe
11:33:46 <arcasin> :t arr
11:33:47 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
11:34:39 <EvanR> gah
11:35:17 <EvanR> how do i compose C -> D with A -> B -> C to get A -> B -> D
11:35:40 <Saizan> ?pl \f g x y -> f (g x y)
11:35:40 <lambdabot> (.) . (.)
11:35:47 <Saizan> ?pl \x y -> f (g x y)
11:35:48 <lambdabot> (f .) . g
11:36:11 * EvanR types (f .) . g into the ghci
11:36:17 <aristid> EvanR: (.:) = (.).(.)
11:36:38 <EvanR> i feel like im programming in braile now
11:37:12 * Twey prefers ‘fmap f . g’
11:38:47 <ddarius> : stepping rollup dup2 u> [4 drop] [swapd [dup2 [swap i] dip2] dip2 over [+] dip2 stepping] branch ;
11:39:13 <Twey> Cat?
11:40:12 <ddarius> It's isn't Cat, though I'm surprised that Cat was the first language that one would guess.
11:40:23 * ski would guess Joy
11:40:27 <Twey> Ah, Joy eh
11:40:29 <ski> .. or Factor
11:40:31 <EvanR> none of these are working for me
11:40:32 <Twey> Not Factor
11:40:44 <Twey> Factor has n[drop,dup,dip]
11:40:50 <EvanR> f :: Int -> Char, g :: Char -> Bool -> Int -> Int
11:41:01 <aristid> Twey: i prefer f .: g
11:41:09 <EvanR> want Char -> Bool -> Int -> Char
11:41:20 <Twey> :t fmap (?f :: Int -> Char) . (?g :: Char -> Bool -> Int -> Int)
11:41:21 <lambdabot>     Couldn't match expected type `Int'
11:41:21 <lambdabot>            against inferred type `Int -> Int'
11:41:21 <lambdabot>       Expected type: Char -> Bool -> Int
11:41:27 <EvanR> exactly what i got
11:41:38 <ski> EvanR : `f .:: g'
11:41:41 <aristid> EvanR: because you counted wrong
11:41:44 <Twey> That's because it's an extra argument
11:41:55 <EvanR> oh
11:41:56 <mauke> @djinn (int -> char) -> (char -> bool -> int -> int) -> (char -> bool -> int -> char)
11:41:57 <lambdabot> f a _ _ _ b = a b
11:42:02 <aristid> in that case: ((.).(.).(.)) f g
11:42:03 * ski wonders what's the type of `rollup'
11:42:03 <EvanR> this doesnt work for arbitrary number?
11:42:44 <EvanR> i guess ill just use variables
11:42:47 <mauke> @djinn (int2 -> char) -> (char -> bool -> int -> int2) -> (char -> bool -> int -> char)
11:42:48 <lambdabot> f a b c d e = a (b c d e)
11:42:52 <mauke> @. pl djinn (int2 -> char) -> (char -> bool -> int -> int2) -> (char -> bool -> int -> char)
11:42:53 <lambdabot> f = (.) . (.) . (.)
11:43:02 <aristid> as i said :)
11:43:22 <Twey> Why are the types lower-case?
11:43:25 <Twey> Oh
11:43:27 <ski> (aristid : i'm glad you like the naming)
11:43:29 <Twey> 'cause it doesn't matter
11:43:40 <aristid> ski: which naming?
11:43:43 <aristid> ski: (.:)?
11:43:52 <ski> aye
11:44:02 <aristid> yea i love it
11:44:06 <EvanR> is (.:) and (.::) standard?
11:44:13 <aristid> nah. but you can easily define it
11:44:26 <aristid> (.:) = (.).(.) ; (.::) = (.).(.).(.)
11:44:29 <andern> is it possible to see which types are in a typeclass from the ghci prompt?
11:44:52 <Twey> andern: :i Floating
11:44:53 <Saizan> andern: yes, :info TheTypeClass
11:44:58 <andern> thanks!
11:44:58 <Twey> Only the ones that are in scope, though
11:45:04 <EvanR> will ghc optimize all these stuff away
11:46:31 <arcasin> hmmh
11:47:10 <jirka> hi again! I have found another bottleneck. I need to be able to append to the end of a list
11:47:18 <EvanR> never!
11:47:27 <jirka> and it takes sooo long with ++
11:47:48 <EvanR> then you dont want a list
11:47:49 <jirka> but I have to do that, or Ill have my list in reverse
11:47:58 <EvanR> you can reverse at the end
11:48:29 <dmwit> Hey guys, any Windows experts?
11:48:41 <dmwit> Trying to build HaXml, a friend and I get this error at the very end:
11:48:50 <dmwit> F:\Haskell 2010.2.0.0\lib\..\mingw\bin\windres: can't open temporary file `\/cca
11:48:53 <dmwit> 50692.irc': Invalid argument
11:49:54 <mauke> jirka: you could use a ListBuilder
11:49:57 <mauke> a.k.a. DList
11:50:57 <EvanR> cool so now i just need to freaking understand wtf (.) . (.) . (.) is doing
11:52:09 <dmwit> EvanR: It's reaching down past three arguments to twiddle the return value there, rather than the return value after only one argument.
11:52:34 <ddarius> EvanR: It's nesting fmaps.
11:52:54 <dmwit> EvanR: You might like conal's blog post on semantic editors or something like that. Let me see if I can find it.
11:53:03 <ddarius> @where sec
11:53:03 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
11:53:09 <dmwit> There you go!
11:53:22 <EvanR> i saw that, now maybe ill get it ;)
11:53:40 <mauke> :t (.) (.) ((.) (.) (.))
11:53:41 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
11:54:49 <EvanR> smooth
11:55:08 <EvanR> so there is a use for (.) (.) ;)
11:58:33 <dmwit> Okay, if nobody knows the answer to my question, does anybody know which mailing list is the most appropriate forum for it?
11:58:58 <EvanR> no instance for Typeable CalendarTime
12:00:43 <EvanR> guess i gotta write one
12:01:16 <jirka> BTW, I have solved the append to list problem. I changed the function to use right fold instead of left fold
12:03:28 <dmwit> haskell-cafe, maybe?
12:03:47 <jirka> now I can compress a 100 page long book using huffman in 12 seconds. U guess thats still not good enough
12:04:05 <dmwit> Or is there a mailing list more oriented to troubleshooting?
12:04:05 <jirka> OK, so one last problem? How can I do profiling in Haskell?
12:04:13 <dmwit> jirka: Nice!
12:04:31 <dmwit> jirka: The manual has some very nice instructions for profiling.
12:04:42 <dmwit> http://haskell.cs.yale.edu/ghc/docs/6.12.2/html/users_guide/profiling.html
12:04:48 <jirka> manual for GHC?
12:04:52 <jirka> ok
12:05:03 <jirka> thanks a lot
12:05:21 <ddarius> dmwit: Compressing the text of a 100 page book in 12 seconds is dog slow.
12:06:24 <dmwit> But, going just by inference on the English that he used, faster than what he was doing before.
12:06:31 <dmwit> So, I say again: nice!
12:07:37 <jirka> it was faster. With my original character counting and appending to the end of a list it would took forever
12:19:44 <wxl> where can I find an os x ppc version of haskell?
12:20:48 <Lemmih> wxl: hugs is pretty portable.
12:20:55 <monochrom> only fairly old versions, but try http://www.haskell.org/ghc/download_ghc_6_10_4.html#macosxppc
12:22:26 <wxl> thx monochrom .. macports is  working on a new v I think but it's f'd up
12:22:31 <pr> monochrom: ? what about http://darcs.haskell.org/download/dist/6.12.3/GHC-6.12.3-i386.pkg
12:22:46 <pr> oh
12:22:46 <pr> ppc
12:22:48 <pr> nvm :)
12:23:42 <monochrom> life would be so much simpler if everyone standardized on...
12:23:44 <monochrom> 6502!
12:24:07 * monochrom still has an unused 6502 chip!
12:24:16 <tommd> Yay
12:24:40 <aristid> monochrom: maybe you can get it to run your old apple II software :P
12:25:47 <pr> for a moment i really thought there was no recent ghc for the mac and i felt like i needed to change this asap
12:25:51 <pr> heh
12:25:56 <monochrom> steve jobs would be proud. "this rewinds everything. again."
12:28:04 <pr> "If you start trying to read the APIs, you can't find the answer in the API. John Hughes was saying "Did you know that if you open a file and write it and rewind it and do this and do this then this happens, which is very counterintuitive" and you try and look in the POSIX specs, and you can't find any reference to what they should do"
12:28:51 <pr> does anybody happen to know where to find that post/mail of john hughes?
12:29:41 <pr> btw. joe armstrong said this once in an interview, so it's quite possible john hughes told it joe armstrong in person or sth like that - dunno, that's why i ask here
12:29:57 <Adamant> monochrom: I'm pretty sure the Apple II still has screws. Steve Jobs would be disappoint.
12:29:57 <Adamant> ... unless he could sell a totally redesigned model with the boxy plastic replaced completely by aluminum
12:29:58 <Adamant> brushed, preferrably
12:31:02 <aristid> Adamant: would a box made entirely of glass  be acceptable too?
12:32:13 <pr> unibody glass macbooks!
12:33:53 <aristid> pr: indeedy
12:34:33 <monochrom> "apple IV. this screws everything. again."? :)
12:36:58 <Adamant> monochrom++
12:37:31 <Adamant> aristid: only if it's transparent aluminum Steve got by trading with interstellar aliens
12:37:38 <systemfault> Haha
12:37:43 <Adamant> that like people wearing turtlenecks
12:38:05 <systemfault> I hate the company and its fanboys but actually like their products :'(
12:38:09 <Adamant> same here
12:38:16 <Adamant> well I don't hate all of the company
12:38:23 <wxl> yeah well I had my time with the mac. it could be worse I guess. anyways, I'm over it. still intent on making use of this machine.
12:38:26 <Adamant> but their general direction at present, yes
12:38:51 <systemfault> On the other site... we owe them webkit... llvm...
12:39:00 <Adamant> heh
12:39:04 <fasta> I think they should improve their products. I think my laptop is better than a MacBook and it is cheaper, so they are doing something wrong. 
12:39:09 <Adamant> llvm was massively expanded by them, not developed
12:39:18 <wxl> they fkkkkd up bsd fo sho
12:39:22 <systemfault> Same for webkit I think
12:39:23 <Adamant> same for webkit, although it's a pretty big jump[
12:39:39 <Adamant> over the Konquerer KHTML engine
12:39:40 <systemfault> Wasn't webkit a fork of KHTML 
12:39:47 <Adamant> yeah
12:39:51 <systemfault> I thought so :P
12:39:57 <Adamant> I think Konq uses WebKit now
12:40:02 <wxl> and I love how they rename everything to make it theirs (wake on demand)
12:40:05 <systemfault> The weird thing is that Konq still sucks...
12:40:19 <wxl> kanything sucks
12:40:20 <EvanR> kde sucks
12:40:24 * wxl ducks
12:40:32 <EvanR> in related news, gnome sucks more
12:40:41 * wxl high 5s EvanR 
12:40:41 <Vanadium> :<
12:40:48 <systemfault> It has always been an okay/good file browser... but a bad web browser.
12:41:28 <systemfault> Gnome.. beside that its toolkit is major crap, it's a fine desktop environment.
12:41:38 <aristid> gnome is very buggy tho
12:42:19 <Palmik> Don't touch my KDE :D
12:42:25 <systemfault> Well, I had my share of bugs with KDE too
12:42:29 <EvanR> all you ever really see of gnome is nautilus
12:42:38 <joeyh> is this some kind or rounding error, or a leap seconds or what?Prelude Data.DateTime> map (toSeconds . fromSeconds) [0..10]
12:42:38 <joeyh> [0,0,1,2,3,4,5,6,7,8,9]
12:42:39 <systemfault> krunner crashing... plasma crashing
12:42:39 <Vanadium> What is so terrible about gtk?
12:42:45 <Vanadium> It seems to be a pretty widespread toolkit
12:43:08 <systemfault> Vanadium: The API is awful.
12:43:10 <joeyh> I am unsure if Data.DateTime is what I really want when working with unix epoch type seconds
12:43:21 <Vanadium> The C API or language bindings?
12:43:38 <EvanR> what gtk+ bindings dont basically mirror the c api
12:43:39 <systemfault> Vanadium: The C API
12:44:07 <systemfault> EvanR: Sorry?
12:44:11 <fasta> systemfault, what makes you qualified to say that the toolkit is 'major crap'?
12:44:13 <wxl> xfce is ok as far as desktop env.. but I question the need for the fluff. usually run fluxbox or wmii.
12:44:29 <identity> fluxbox ftw.
12:44:36 <systemfault> fasta: That's something called "Having an opinion"
12:44:39 <EvanR> whatever the distro gives me ftw
12:44:39 <meditans> Hi guys, is there someone I can ask about something about regular expression?
12:44:43 <Adamant> wxl: a lot of companies are bad about that
12:44:44 <EvanR> that isnt gnome or kde
12:44:58 <fasta> systemfault, yes, but it's not really interesting to hear an opinion without credentials.
12:45:06 <Adamant> wxl: although I do like the name "Firewire" better than repeating the IEEE standard numerics
12:45:08 <mauke> meditans: are you uinsg regular expressions in haskell?
12:45:29 <EnglishGent> hello :)
12:45:31 <meditans> yes.. i'm using the module Regex.TFDA
12:45:36 <fasta> If someone who worked 5 years on core GTK+ systems would say the same, I would be more inclined to believe it.
12:45:36 <wxl> amad
12:45:42 <meditans> cause i read that it's faster
12:45:49 <systemfault> fasta: At the beginning... using C to reimplement OOP is stupid... just use C++.
12:45:53 <wxl> oops Adamant agreed
12:46:03 <EvanR> no, do not use c++
12:46:10 <fasta> systemfault, no, it's useful, because C has an ABI.
12:46:32 <Vanadium> The idea was not so much "man would it not be nice if we had OOP in C"
12:46:34 <fasta> Also, C is not such a bad language.
12:46:34 <meditans> mauke: yes, i'm using the module Regex.TDFA cause i read it's faster
12:46:42 <Vanadium> and rather to have a thing that would be convenient to make bindings around 
12:47:00 <fasta> Vanadium, right.
12:47:01 <EnglishGent> can I ask a monad question? (I've invented something I *think* is a monad - I'm not sure if it satisfies the monad laws though. (happy to discuss in channel, or in pm depending on whatever is most convinient for people) :)
12:47:03 <systemfault> fasta: The for/against makes it that it a better idea to kill the ABI
12:47:04 <pikhq> The problem is, GObjects suck. :)
12:47:10 <systemfault> Like pikhq said.
12:47:29 <EvanR> just use a saner model
12:47:34 <ezyang> EnglishGent: Don't ask to ask! 
12:47:39 <meditans> mauke: but i don't know how to retrieve a list of all matches instead of a single one
12:47:52 <fasta> pikhq, so what is something that is better?
12:48:00 <meditans> mauke: just adding the type signature :: [String] doesn't help
12:48:22 <meditans> mauke: any hint?
12:48:30 <EvanR> i like fltk/2, but its c++
12:48:32 <mauke> meditans: no
12:48:44 <systemfault> fasta: Just using a real object oriented programming language and it's the only sane way to write GUI.
12:49:01 <meditans> mauke: know where to find information? :D
12:49:04 <mauke> no
12:49:07 <systemfault> I'm not an advocate of OOP but for GUI... it's a perfect fit.
12:49:13 <pr> EnglishGent: shoot!
12:49:32 <EnglishGent> okay.. I've got a class 'Space s' providing methods 'insert :: s -> Space s -> Space s' and 'fetch :: Space s -> Maybe Space s' - the idea is that: a) you can get things back in a different order from which you inserted them & b) that even after inserting something into a previously empty space there is no gurantee that fetch will return it straight away
12:49:41 <EvanR> systemfault: yeah but c++ isnt a perfect fit for oop or gui
12:49:52 <EnglishGent> so I obviously need a function make-space :: s -> Space s
12:49:59 <EvanR> they could have made a non c++-like oop model 
12:50:00 <EvanR> in C
12:50:12 <systemfault> EvanR: And they more or less did...
12:50:12 <aristid> EvanR: like objective-c?
12:50:13 <Vanadium> The C++ object model is pretty cool for what it is trying to do
12:50:15 <Vanadium> ie, not be java
12:50:21 <EnglishGent> now this is beginning to sound suspiciously like a monad to me - with 'make-space' being 'return'
12:50:28 <systemfault> C++0x is more modern than java :P
12:50:35 <systemfault> Java... is rotting.
12:50:40 <ezyang> EnglishGent: Just because you get a free monad doesn't mean you should use it. 
12:50:40 <EnglishGent> but whilst I've used Monads other people have written, I've never tried to write one of my own before
12:50:41 <EnglishGent> :)
12:50:57 <systemfault> I want free monads!
12:51:03 <aristid> @free monad
12:51:03 <EnglishGent> ezyang - I dont understand what you mean :|
12:51:04 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `monad'\n\n"
12:51:13 <aristid> systemfault: no free monad for you!
12:51:16 <ezyang> EnglishGent: Yeah, there's a bit of context necessary here... 
12:51:18 <systemfault> Damn :'(
12:51:27 <EvanR> aristid: no
12:51:30 <ezyang> Anyway, I want to ask a more general question: are there any other operations on Space? 
12:51:34 <chrisdone> ezyang: saw your html sanitation post, nice
12:51:52 <ezyang> Because as it sounds right now, the "random ordering" thing seems pretty arbitrary. 
12:51:52 <aristid> EvanR: objective-c is non-c++ OOP, so it would theoretically fit the bill:P
12:51:52 <EnglishGent> foo :: (s -> g) -> Space s -> Space g
12:51:58 <ezyang> chrisdone: Ah, cool. :-) 
12:51:59 <EnglishGent> I dont know what to call 'foo' yet :)
12:52:04 <aristid> EnglishGent: fmap
12:52:15 <EvanR> aristid: i guess wed want to get more ideal
12:52:19 <EvanR> if we have the choice
12:52:21 <ezyang> So, you most definitely have a functor. 
12:52:25 <pr> @type fmap
12:52:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:52:33 <aristid> EnglishGent: or do you have any constraints?
12:52:33 <fasta> ezyang, can I ask why you blog?
12:52:45 <ezyang> fasta: My new years resolution was blog three times a week for the entire year! 
12:52:45 <EvanR> but without a gc not much you can do
12:52:53 <aristid> EvanR: aw screw it, let's just use haskell ;)
12:52:55 <EnglishGent> the idea is to have something for dealing with distributed computing ... programs can drop jobs into a space (e.g. SETI@Home work packets, or ask for a job)
12:53:07 <EnglishGent> the idea is to have something for dealing with distributed computing ... programs can drop jobs into a space (e.g. SETI@Home work packets), or ask for a job*
12:53:11 <EvanR> aristid: lately thats what basically all my projects have turned into
12:53:12 * EnglishGent fixes his brackets :)
12:53:14 <fasta> ezyang, I can't decide whether that is a joke or not :)
12:53:18 <ezyang> EnglishGent: Ok, then you can get a monad. 
12:53:22 <ezyang> fasta: I'm being perfectly serious. :-) 
12:53:34 <systemfault> There are some really nice blog about programming.
12:53:34 <ezyang> (in fact, you can check my first post for something to that effect.) 
12:53:36 <fasta> ezyang, ok, so why that resolution?
12:54:04 <systemfault> Not all blogs are about "I went to the shopping mall then came back home to eat spaghettis"
12:54:09 <fasta> ezyang, some do it to impress some other people, some just want an ego boost, what do you want?
12:54:22 <EnglishGent> hmm ... If I do it this way I'm restricting myself to only one space per type arent I?
12:54:30 <systemfault> fasta: It's about sharing knowledge.
12:54:31 <ezyang> EnglishGent: Some sort of restricted IO type thing. Although your current type doesn't really accomodate that. 
12:54:38 <ezyang> fasta: Hm, good question. 
12:54:47 <fasta> systemfault, I have never ever seen something new on a blog. 
12:54:53 <systemfault> fasta: As a bonus, you have something to write in your CV
12:54:57 <chrisdone> fasta: he's got an ego the size of [1..] and he wants all the glory!
12:55:16 * EnglishGent has a feeling the missing mass the astronomers are looking for is actually ego... there's surely a lot of it
12:55:17 <EnglishGent> :)
12:55:23 <EvanR> fasta: large scale distribution of known knowledge is a good thing for the economy ;)
12:55:39 <EnglishGent> also - doesnt really accomodate what ezyang? (not sure) :)
12:55:56 <chrisdone> the only things I write about on my blog are things that I've discovered or created
12:55:59 <systemfault> fasta: Well.. I often read articles on Don Stewart's blog..
12:56:23 <ezyang> I know I'm a little bit on the quantity over quality side :^) 
12:56:56 * EnglishGent thinks maybe he actually needs Space s x | s -> x
12:56:59 <fasta> ezyang, so, you don't know why? ;)
12:57:32 <ezyang> fasta: Not really. I can point to specific things. I want to be a better writer, I want to teach (I love teaching), I want reputation, I want to be able to generate ideas all the time. 
12:57:33 <chrisdone> sometimes I think about writing about my opinion, so that when asked about it later on, it'll be fresh in my mind from having written about it. but I never do
12:57:50 <ezyang> EnglishGent: I don't think you need a fundep. 
12:58:04 <ezyang> You probably something more like Job x => Space x a 
12:58:30 <ezyang> and an implementation will probably be a mix of IO and State. 
12:59:13 <ezyang> chrisdone: Taking a position is pretty exhausting business :-) 
12:59:16 <chrisdone> my opinions change quickly, but what people understand to be your opinion doesn't seem to
12:59:27 <wxl> seems like making is going good thx for the ppc pointer I'll come back if I have issues
12:59:35 <EnglishGent> i.e. a Job is a space of something? (a bit confused, becuase I know I cant read => as implication when it comes to subclassing in Haskell)
12:59:58 <EnglishGent> or a Job is something that is in a space?
13:00:20 <ezyang> EnglishGent: Well, you were thinking of the distributed computing scenario, so in this case Job is something you can ship off to the cloud. 
13:00:44 <EnglishGent> ok - just checking :)
13:00:48 <ezyang> The insight I'm playing off of is that what you seem to want to do needs side effects. 
13:00:53 <ezyang> in which case, yes, you want a monad. 
13:01:47 <EnglishGent> yes - but the origional idea was that once you had the idea of a Space you could have the distributed computing thing as *one* implementation, another (for testing purposes for example) might just refuse to give you something at random (flip a coin when you try to fetch)
13:01:59 <EnglishGent> and insert things into a list held internally at random locations when you insert
13:02:09 <ezyang> EnglishGent: You can do that with a MonadFoo typeclass 
13:02:18 <EnglishGent> MonadFoo?
13:02:34 <ezyang> It's the convention of monad typeclasses to be named MonadFoo, like MonadReader or MonadState 
13:02:35 <narasim_7>  /join #fedora-haskell
13:02:45 <ezyang> and then you can vary the concrete implementation, as you suggest. 
13:02:46 <narasim_7> narasim_7: sorry.
13:02:48 <EnglishGent> and other variations - spaces that only hold one object (so that pushing another one in will eventually replace it)
13:03:01 <ezyang> but a /free/ monad, that is, one based on the structural interpretation of a monad, won't let you do that. 
13:03:07 <EnglishGent> spaces where no element occurs in the space more than once (so all the members need to support Eq)
13:03:08 <EnglishGent> etc
13:03:09 <ezyang> *datatype. 
13:03:27 <ezyang> Sure, then you need more constraints on what lives in Space. 
13:03:38 <ezyang> You probably want Ord so you can do that efficiently... 
13:04:15 <EnglishGent> Hmmm ... I'd like the option of doing it efficiently were possible - but I dont want to make the interface less general than it has to be
13:04:18 <chrisdone> ezyang: sure. but I never really read anyone's blog post unless it's factual... it's fun to read about opinions you agree with, and rarely fun to read opinions you disagree with. in the former you haven't learned anything, in the latter you do but don't welcome it
13:04:34 <chrisdone> ezyang: I think that's a fault of the writers more than anything. and the whole being right > finding right
13:04:53 <EnglishGent> MonadSpaceTheFinalFrontier (a kind of MonadFoo) :)
13:06:17 <EvanR> chrisdone: no, youre wrong! *goes to blog about it*
13:06:24 <ezyang> chrisdone: I derive some measure of enjoyment from reading the opinions of people I really disagree with. 
13:06:37 <ezyang> The trouble is finding those people ;-) 
13:06:56 <tommd> Is there a package with some empty data decls and a bunch of types providing peano numbers?
13:07:08 <ezyang> EnglishGent: Which is why I suggested making a Job typeclass that will encapsulate all of the essential things needed. 
13:07:17 <ezyang> tommd: Yes. Search for type numerals or something like that. 
13:07:27 <EnglishGent> basically once you get the most general form up I can think of all sorts of variations on Space - FIFOSpace for example, PerishableSpace (if you put elements in faster than you take them out some may simply dissapear - the space has a maximum volume & a policy for deciding what to throw away)
13:07:38 <ddarius> ezyang agrees with everyone
13:07:43 <chrisdone> ezyang: indeed. the best writer is one who will criticise something you hold dear and it doesn't bother you
13:08:21 <ezyang> EnglishGent: If it's not encoded in the types, it's fair game to vary. 
13:09:05 <ezyang> ddarius: I am pretty nonconfrontational... 
13:09:27 <ezyang> chrisdone: Consider the phenomenon where saying controversial things gets you lots of pageviews. 
13:09:47 <tommd> ezyang: Thanks, got it (package: type-level-natural-number)
13:10:16 <tommd> A bit too small though.  I think going up to ~ N10K would be appropriate.
13:10:23 <EvanR> whats so natural about naturals, and whats so real about reals?
13:10:32 <ezyang> tommd: There's another package that uses a binary encoding. 
13:10:40 <chrisdone> ezyang: for reddit, a controversial title is enough. X Reasons Why Z is bad
13:11:14 <ezyang> So, if I claim that people seek out opinions that agree with them, why are these titles so popular? 
13:11:30 <ezyang> Clearly I should be studying Philosophy of the Internet. 
13:11:40 <chrisdone> ezyang: I had a look on /r/programming for more examples, but it seems that today it's actually just useful resources. weird
13:11:58 <chrisdone> "The truth about ... " also works
13:12:24 <tommd> type-level is usable for what I was  thinking.
13:12:27 <fasta> I am sure a post containing all the flaws of Haskell will also be hugely popular.
13:12:31 <tommd> err, tfp I mean.
13:12:51 <ddarius> EvanR: The naturals are God-given, the rest man-made.
13:12:53 <chrisdone> ezyang: because the people upvoting those "X is bad" ones are the people who agree that it's bad
13:13:12 <EvanR> ddarius: so reals are imaginary?
13:13:19 <wxl> ah yes how about cabal for ppc?
13:13:24 <ddarius> EvanR: Is your computer imaginary?
13:13:34 <EvanR> no
13:13:38 <ezyang> EvanR: That's too complex for my little brain. 
13:13:42 <ddarius> EvanR: Is it man-made?
13:13:44 <chrisdone> fasta: that post is made once a month. usually one real flaw and then 20 paragraphs about this is why Haskell sucks
13:13:53 <EvanR> whats that gotta do with real numbers
13:14:04 <ezyang> Hey guys, Haskell sucks. Get on it. 
13:14:11 <ddarius> Why would the reals be imaginary?
13:14:14 * EnglishGent thinks Haskell is very cool - but at times it hurts my brain :|
13:14:17 <EvanR> ezyang: i already started that a while ago, didnt get very far
13:14:23 <dcoutts> @slap ezyang 
13:14:24 * lambdabot hits ezyang  with a hammer, so they breaks into a thousand pieces
13:14:53 <EvanR> because complex is man-made
13:14:54 <fasta> chrisdone, or maybe it can be done as a series with each day a new run-time system (for a different language)\ being destroyed. :)
13:15:24 <ezyang> I hear there can be "imaginary voltages" 
13:15:32 <EvanR> hehe
13:15:39 <EvanR> complex AC analysis
13:16:03 <ezyang> But does that actually reflect reality? 
13:16:12 * ezyang is feeling philosophical. 
13:16:12 <ddarius> Arguably, yes.
13:16:32 <EvanR> i guess real numbers reflect the reality of a single number appearing on the measurement device rather than two
13:16:38 <EvanR> but you see two sometimes
13:16:40 <EvanR> so..
13:17:32 <EnglishGent> ezyang - well complex numbers are certainly fundamental in quantum mechanics
13:17:35 * EnglishGent shrugs
13:17:42 <fasta> It would be cool to demonstrate rounding errors in the universe.
13:17:54 <EnglishGent> fasta - I thought that was called 'noise'
13:17:55 <EnglishGent> :)
13:18:03 <Adamant> EnglishGent: could you create a quantum mechanics that worked with just reals?
13:18:10 <EvanR> isnt there an assumption that any errors are your fault
13:18:16 <ezyang> Adamant: Yes. But it would be more complicated. 
13:18:26 <ddarius> ezyang: No it wouldn't.
13:18:36 <ezyang> ddarius: Oh really? 
13:18:42 <EvanR> you can represent complex numbers using two real numbers
13:18:47 <EnglishGent> wouldnt it be cheating - you can treat complex numbers as pairs of reals
13:18:47 <EvanR> presto
13:18:55 <Raevel> hpaste broken :-(
13:18:58 <EnglishGent> but that's isomorphic so in essence it's the same as using complex numbers
13:19:03 <Adamant> yeah
13:19:09 <EvanR> and quaternions are 2x2 real matrices, (i think?)
13:19:21 <Adamant> so the complex numbers are fundamental, then
13:19:21 <ddarius> EvanR: No.
13:19:27 <ddarius> Adamant: No.
13:19:56 <ddarius> (or yes, depending on what "fundamental" means)
13:19:57 <monochrom> a pair of real-imaginary voltages is a nice encoding of a pair of real voltage and real phase angle.
13:20:17 <monochrom> or perhaps s/encoding/representation/
13:20:18 <EvanR> oh. its 2x2 complex matrices
13:20:26 <EvanR> a subset
13:20:55 <Raevel> I have a function MyClass mc => mc -> mc -> mc, why can't it take two different concrete types as arguments? existentially qualified? How should i go about this?  ( http://pastie.org/1210098 )
13:20:56 <silver> which reminds me 'bout http://motls.blogspot.com/2010/08/why-complex-numbers-are-fundamental-in.html
13:20:59 <EvanR> 4x4 real matrices
13:21:41 <dschoepe> Raevel: then you'd have to use a type like (MyClass mc1, MyClass mc2) => mc1 -> mc2 -> mc1
13:21:42 <monochrom> imaginary voltage is not in real circuits. but bitvectors are not in real finance either. doesn't stop you from using bitvectors to calculate finance.
13:22:09 <EvanR> the ghost in the machine!
13:22:10 <Raevel> dschoepe: but for the return type, either type could be returned
13:22:57 <dschoepe> Raevel: then you could return Either mc1 mc2 or, as you said, an existential type
13:23:15 <ezyang> The priests in the time of Copernicus said the same thing about the heliocentric model of the universe! 
13:23:19 <ddarius> Adamant: You can use complex numbers to represent some things, but there are more lucid accounts that don't use complex numbers.  The thing modelled by complex numbers, is, of course, real.
13:23:22 <EnglishGent> instance ProfitFromLoans ActualProfit where -- never mind bit vectors in the finance industry... *that* line caused havoc!
13:23:33 <ezyang> "The earth doesn't really orbit around the sun, it's just a really nice way of calculating how the planets move!" 
13:23:36 <Adamant> ddarius: ah. that works.
13:23:41 <gwern> heliocentrism sucks. have *you* ever seen the precession of the stars?
13:24:02 <ezyang> Maybe we should go to #haskell-blah now :-) 
13:24:26 <gwern> anyone can watch an eclipse or a ship go down the horizon and see the earth is round
13:24:30 <monochrom> there is no cpo in your computer. you use cpo to predict computer behaviour anyway.
13:24:31 <ddarius> Actually, several different things are modeled by complex numbers in physics (even within a single equation.)
13:24:34 <gwern> but who has ever seen the precession of the stars?
13:24:38 <tommd> Maybe we should make an IRC Server that will classify conversation as on or off topic and send it to the correct channel?
13:24:50 <gwern> tommd: the XKCD channel has an interesting novelty bot...
13:24:58 <EnglishGent> tommd - wouldnt that require a sentient irc server?
13:25:03 <EnglishGent> :)
13:25:08 <tommd> I didn't say it would be perfect
13:25:13 <monochrom> or at least haskell program behaviour
13:25:14 <ezyang> Ok, let's go to haskell-blah. 
13:25:24 <EvanR> sounds like a great use for the worlds first strong artificial intelligence
13:25:40 <tommd> Google?
13:26:30 <EnglishGent> EvanR - you want to condem the world's first strong AI to reading irc channels all day?!
13:26:48 <EnglishGent> Suddenly I'm beginning to think SkyNet may have had a point :P
13:26:49 <EnglishGent> :)
13:30:29 <gwern> revenge. not an AI jury in the universe would convict it
13:31:00 <EnglishGent> hi gwern :)
13:34:18 <winxordie> I wonder if conversations about conversations being off-topic are themselves off-topic.
13:34:31 <mauke> generally, no
13:34:39 <mauke> according to usenet etiquette
13:35:09 <EvanR> so conversations about off topic are universal
13:35:10 <winxordie> how about conversations of conversations of conversations being off topic? At what point in the hierarchy is there a definite halt?
13:35:31 <winxordie> *s/of/about
13:35:47 <EvanR> we can index the degree of off topicness with ordinals
13:35:55 <winxordie> Oh boy...
13:36:22 <winxordie> I think the strong AI would have a lovely time with that problem.
13:36:26 <EvanR> lol
13:37:40 <monochrom> conversation about what's off-topic is necessary evil of administrative conversation
13:39:22 <Heffalump> most moderated newsgroups don't allow discussion of the moderation policy on the group, FWIW
13:39:28 <winxordie> I think #off-topic is the equivalent of Bertrand's paradox for the AI patrolling said channel.
13:39:47 <EvanR> haha
13:47:39 <fasta> All the 'answers' to Bertrand's paradox I see seem wrong.
13:47:59 <fasta> They all seem to assume any particular distribution. 
13:48:34 <fasta> Is is truly impossible to sum over all possible distributions to get rid of the assumption?
13:48:46 <aristid> fasta: normal distribution?
13:49:01 <fasta> http://www.nici.kun.nl/~peterh/doc/bertrand.html
13:49:09 <fasta> I mean for example the answer this guy gives
13:49:10 <fasta> .
13:49:24 <aristid> fasta: iirc sufficiently big sums of random variables converge to normal distribution
13:49:45 <fasta> aristid, yes, that's the CLT.
13:50:05 <fasta> If it is a paradox, there must also be a real answer.
13:51:52 <fasta> Apparently Jaynes solved it.
13:52:15 <fasta> In a manner which doesn't assume anything, like I said. 
13:53:12 <fasta> He wrote a nice book on statistics, but some people found a bug in one of his proofs spoiling the beauty of it. 
13:54:56 <aristid> fasta: an unfixable bug?
13:55:12 <fasta> aristid, I never saw the fix, at least.
13:55:21 <aristid> is the bug release-critical?
13:55:22 <aristid> :D
13:55:30 <fasta> aristid, it was pretty recent that the bug was found, though.
13:56:01 <luite> hmm, I don't really see the problem. unless it's in the "randomly picked" part, which I assume means two points independently picked on the circle, uniformly
13:56:13 <fasta> aristid, that never stopped Ubuntu from releasing ;)
13:56:28 <luite> am I missing something important?
13:57:00 <hpc> haha
13:59:13 <winxordie> I find the idea of randomly picking an element out of an infinite set to be laughable.
13:59:47 <sipa> depends, which chance distribution?
13:59:59 <luite> winxordie: at least it's a compact set, that can make many things computable
14:09:48 <fasta> winxordie, I agree, but I don't think any computations are done on 'completed infinities'.
14:13:51 <luite> winxordie: in this case, you could (with the obvious metric) not pick two points on the circle, but two open balls of small radius. you can then for each of those points make a sequence of nested open balls until your problem is decided
14:14:39 <luite> of course you could need a lot of entropy for those two sequences (similar to that you would need the axiom of countable choice if you decided to use this in a proof)
14:18:17 <imc> uhm... is there a way to have a class call a predefined function so that it "casts" itself to another class if needed?
14:18:55 <ezyang> imc: Depends. 
14:19:15 <imc> i.e. MyClass is required, but SomeType is found, but MyClass knows how to make SomeType become MyClass
14:19:18 <ezyang> If it's a one way cast, you could do class CastTo a => CastFrom a where 
14:19:25 <ezyang> imc: No. 
14:19:31 <ezyang> What if SomeType has multiple MyClass interpretations? 
14:19:55 <imc> ezyang: SomeType is a basic type 
14:20:04 <imc> i.e. it's not a class, its really a type
14:20:06 <fasta> imc, classes cannot call anything.
14:20:14 <ezyang> Int is a basic type, but it has multiple interpretations under Monoid 
14:20:44 <imc> right
14:20:56 <imc> i will just write a very short operator to do the "cast"
14:22:06 <aristid> is somebody behind this here? http://github.com/johang88/haskellinjavascript
14:23:06 <aristid> :t \x y f -> f x y
14:23:07 <lambdabot> forall t t1 t2. t -> t1 -> (t -> t1 -> t2) -> t2
14:55:01 <OscarZ> is there an easy way to have a custom data type convert the name of the data constructor to string? if I have eg. data Tactic = Rock | Paper | Scissors .. and I write Scissors in GHCi, it says i need an instance of Show.. do I really to define show function from Tactic to string by hand? 
14:55:38 <danharaj> no, you can use 'deriving'
14:56:03 <OscarZ> thanks, ill look it up
14:56:18 <Vanadium> data Derp = Derp Derp Derp deriving Show
14:56:44 <danharaj> It is a very useful thing to know. You can also automatically derive instances for some other built-in classes. Unfortunately you can't do it with custom ones in any way (unless the template people have conjured up more voodoo)
15:02:24 <syntaxglitch> danharaj, there's generalized newtype deriving but that's not really quite the same thing
15:02:55 <OscarZ> ok.. is this some kind of "ad hoc" thing ? 
15:03:07 <danharaj> what do you mean 'ad hoc'?
15:04:18 <syntaxglitch> OscarZ, automatic deriving? yeah, kind of, it's basically compiler magic that only works in fairly trivial cases
15:05:15 <ddarius> (that happen to include the significant majority of actual cases)
15:05:35 <danharaj> (mostly eq and show)
15:05:36 <OscarZ> yes, i guess i ment something like that with it.. "compiler magic".. 
15:06:02 <danharaj> Yes it is compiler magic, but it is defined by the standard so it is portable and well defined. (Right?)
15:06:18 <ddarius> danharaj: Yes.
15:06:43 <syntaxglitch> GHC has some extensions, but otherwise yeah
15:06:52 <meditans> may I ask you a question about readFile function?
15:07:42 <meditans> i'm trying to do this operation: list2 <- map (\x -> readFile x) list1
15:07:55 <ezyang> meditans: mapM. 
15:07:57 <meditans> but of course this would not function
15:08:05 <ezyang> Also, the lambda is unnecessary. 
15:08:05 <meditans> how do i use it?
15:08:13 <ezyang> s/map/mapM/ 
15:08:19 <syntaxglitch> go go eta reduction power
15:08:31 <meditans> ok :D
15:08:33 <meditans> i'm trying
15:08:52 <pr> @pl \x -> readFile x
15:08:52 <lambdabot> readFile
15:09:16 * syntaxglitch wonders if anyone is familiar with Barendregt's "The Lambda Calculus: Its Syntax and Semantics"
15:10:30 <syntaxglitch> I saw a copy at a used bookstore a couple weeks ago and recognized the name
15:12:11 <dons> syntaxglitch: its *the* book on lambda calculus
15:12:15 <dons> its hard to get as well
15:12:18 <ddarius> What dons said.
15:12:19 <syntaxglitch> hunh
15:12:21 <syntaxglitch> well
15:12:23 <dons> also, pretty hard after ch 3 or 4
15:12:27 <dons> so expect to do some study
15:12:36 <syntaxglitch> I picked up a copy for about 30USD or so
15:12:37 <ddarius> I was going to say almost exactly the phrase he used in the first sentence too.
15:12:45 <syntaxglitch> but haven't looked at it yet
15:15:07 <joeyh> is handleToFd supposed to close the handle?
15:17:05 <syntaxglitch> will probably need to set aside a serious chunk of time to start working through it... but glad I grabbed it when I had the chance I suppose!
15:19:04 <winxordie> *the* book eh?
15:19:10 <OscarZ> deriving was exactly what i was looking for, thanks.. in what kind of situations it doesnt work, btw ? 
15:19:30 <ezyang> OscarZ: It only works for certain type classes. 
15:19:30 <joeyh> meh, I guess so.. seems this makes file locking unnecessarily painful
15:19:35 <ezyang> Or if you're using a newtype. 
15:19:43 <ezyang> (see relevant GHC extensions) 
15:20:09 <syntaxglitch> OscarZ, mostly it only works in situations where there's an obvious, stupidly simple way to implement the type class, which also happens to be the times you really want it
15:20:11 <OscarZ> ok, Show and Eq were the ones i needed
15:20:46 <ezyang> OscarZ: If you have a datatype that contains another datatype without Show or Eq, you'll be in a smidge of trouble. 
15:21:11 <syntaxglitch> fortunately, most data types where Show and Eq make any sense have instances of them
15:21:40 <sipa> the only ones that don't are ones that somehow encapsulate actions/functions
15:22:02 <danharaj> (->) in general makes things (slightly?) harder
15:23:03 <OscarZ> ezyang: you mean like if i have some kind of container type.. data Container a = Container a ? 
15:23:35 <syntaxglitch> OscarZ, if it helps, my experience is that the cases where I'd want to write the instance manually anyhow (to make sure it behaves the way I want) are a strict superset of cases where deriving doesn't work
15:24:00 <OscarZ> couldnt it just "derive" those subtypes too ? 
15:24:14 <syntaxglitch> with a few exceptions, most of which fall under GHC's generalized newtype deriving
15:24:33 <OscarZ> ok
15:25:31 <resurge> Could someone tell me what I'm doing wrong here please? http://ideone.com/7rVnj    Leksah tells me this: No instance for (Ord (a -> t))       at the main line
15:25:39 <OscarZ> im just wondering what it involves in "deriving" equality function for any custom type 
15:25:53 <syntaxglitch> OscarZ, in cases like that it will derive an instance for "Container a" that applies only for types "a" that are also instances
15:26:26 <syntaxglitch> so deriving Show for "Container a" will make "Container Int" and instance of Show, but not "Container (Int -> Int)"
15:26:58 <syntaxglitch> which is, again, pretty much the behavior you want
15:27:05 <syntaxglitch> most of the time
15:32:12 <ddarius> winxordie: If you were going to make an argument from authority about some aspect of the lambda calculus, Barendregt is the authority you'd use.
15:34:59 <dark> or maybe church?
15:35:03 <bremner> I saw Church in the elevator and he said that is nonsense.
15:35:28 <dark> ? :)
15:35:49 <OscarZ> in my simple example data Tactic = Rock | Paper | Scissors , if i wanted to create a list of all those values in my datatype.. is this possible?
15:36:16 <ddarius> Derive Enum.
15:36:24 <OscarZ> id want [Tactic] as result
15:36:27 <ddarius> (and perhaps Bounded)
15:36:52 <dark> OscarZ, is this [ Rock, Rock ] suitable?
15:37:05 <OscarZ> oh, that is derived too? i expected a function 
15:37:39 <ddarius> In this case though, simply defining: tactics = [Rock, Paper, Scissors] doesn't seem so burdensome.
15:37:50 <OscarZ> no, id want [Rock,Paper,Scissors] as result.. all the possible values
15:38:07 <dark> ah, and the input would be what,the type itself?:)
15:38:27 <OscarZ> yes, heh :) i see the problem ;)
15:38:47 <dark> I saw here an extension for ocaml where it created an automatic pretty-printer by examining the type structure with a macro
15:39:03 <dark> i suppose haskell may have a similar facility
15:39:07 <Peaker> deriving Show?
15:39:32 <dark> well, deriving a printer function, and also a parser.. but to/from s-expressions
15:39:33 <Peaker> > show [Just (1,2)]
15:39:34 <lambdabot>   "[Just (1,2)]"
15:39:40 <dark> hm
15:39:40 <Peaker> > read $ show [Just (1,2)]
15:39:41 <lambdabot>   *Exception: Prelude.read: no parse
15:39:44 <ezyang> > fix show 
15:39:44 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
15:39:49 <ddarius> There's Template Haskell, generic classes, and Data.Data that could all be used to do this.
15:39:52 * ezyang is still endlessly amused by that 
15:39:58 <dark> but show Tactic
15:40:03 <OscarZ> ddarius: true, im just wondering if it can be done automatically.. ill look up Enum.. i seem to be running a lot into "deriving" now :)
15:40:32 <ezyang> I impulsively derive Eq, Ord, Show, Enum for a lot of my data types 
15:40:46 <ddarius> OscarZ: If your type is bounded and enumerable, then [minBound .. maxBound] will produce a list of all elements.
15:41:08 <ddarius> That expression will work for all such types.
15:41:21 <dark> ah. cool. yeah. o.o
15:41:24 <ezyang> (but watch out for the monomorphism restriction) 
15:41:25 <winxordie> ddarius: I'll note that next time I need to use argument from authority for lambda calculus.
15:41:32 <winxordie> I'll be _learning_ more about it first from my copy of Hindley and Seldin's Intro. to Combinators and lambda-calculus.
15:41:54 <winxordie> Suddenly I wish I had a latex plugin for IRC.
15:42:04 <siracusa> resurge: The error is at line 22, next_coin is missing an argument.
15:42:05 <ddarius> Install SCIM.
15:42:15 <Peaker> ezyang, I hate Enum :(
15:43:08 <Peaker> Eq is considered to mean that one can replace a with b, if a == b, and get the same program result (up to performance), right?
15:43:15 <ezyang> Yeah, sometimes it's inappropriate. 
15:43:17 <OscarZ> ezyang: is deriving Enum somehow using Ord ? 
15:43:19 <ddarius> newtype Real = Real (Nat -> Bool) deriving Enum
15:43:28 <resurge> siracusa: Thanks, now it compiles normally :)
15:43:30 <resurge> Is there any way of finding errors like that more easily than checking your code line by line?
15:44:15 <Peaker> What if I want a newtype around something so I can have a different Ord instance -- just for "sort" or "Map.Map"?  Then I must define Eq which is *not* equivalence.  Also, Map on "Complex" would require Ord, but that is mathematically wrong
15:44:35 <siracusa> resurge: Adding type signatures to all of you functions usually helps a lot.
15:44:39 <Peaker> I think maybe there should be an Eq for Equivalence, and an Ord for mathematical ordering, and maybe an Eq/Ord for arbitrary ordering
15:45:35 <ddarius> The Report doesn't actually give any conditions on what instances of Eq should satisfy.
15:45:49 <ezyang> Laame. 
15:46:30 <resurge> siracusa: Okay, will take another look at that. Couldn't quite figure them out the first time I looked at them.
15:47:10 <ddarius> Peaker: The complex numbers are orderable, just not in a way that meshes with the arithmetic operations.
15:47:34 <Peaker> ddarius, Should they be an instance of Ord?  Do we get to have Eq for equivalence and Eq for arbitrary-equality?
15:47:46 <jmcarthur> i would be surprised to find that there is no function to invert an Ordering, but alas i cannot find one
15:48:03 <ddarius> > 1 :+ 1 > 1 :+ 0
15:48:03 <lambdabot>   No instance for (GHC.Classes.Ord (Data.Complex.Complex t))
15:48:04 <lambdabot>    arising from ...
15:48:11 <Peaker> newtype OrdFst a b = OrdFst (a, b) ; instance Ord a => Ord (OrdFst a b) where (x1, _) `compare` (x2, _) = compare x1 x2
15:48:39 <Saizan> jmcarthur: flip compare ?
15:48:48 <jmcarthur> :t flip compare
15:48:49 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
15:48:50 <Botje> isn't that how Ord is defined currently?
15:48:59 <Peaker> jmcarthur, There's Monoid.Dual newtype for Monoid with flipped mappend. Could be nice to have Ord.dual for the Ord
15:49:01 <Botje> @src < (a,b)
15:49:01 <lambdabot> Source not found. :(
15:49:06 <jmcarthur> ah, that is oddly relevant and not at all what i meant, but it works :)
15:49:16 <Peaker> Botje, No, if fst equals, it then compares snd
15:49:24 <Peaker> Botje, I don't want the snd to have to have an Ord instance
15:49:32 <jmcarthur> Peaker: i meant a function of type Ordering -> Ordering
15:49:33 <Botje> ah.
15:49:34 <Botje> okay :)
15:49:43 <Peaker> So I have an Eq/Ord which does not imply equivalence when ==
15:50:02 <Botje> .oO( so write it as compare `on` fst :P)
15:50:18 <Peaker> > map (`compare` LT) [LT, EQ, GT]
15:50:18 <lambdabot>   [EQ,GT,GT]
15:50:21 <Peaker> > map (`compare` EQ) [LT, EQ, GT]
15:50:22 <lambdabot>   [LT,EQ,GT]
15:50:29 <Peaker> > map (EQ `compare`) [LT, EQ, GT]
15:50:29 <lambdabot>   [GT,EQ,LT]
15:50:38 <Peaker> jmcarthur, :-)
15:52:12 <syntaxglitch> ezyang, I'm still amused by "fix error", it's just so misleadingly self-non-documenting
15:53:17 <dark> :t fix error
15:53:18 <lambdabot> [Char]
15:53:23 <syntaxglitch> > fix error
15:53:24 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:53:33 <dark> I don't have fix here
15:53:46 <Botje> > fix error >> return '.'
15:53:46 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:54:01 <fizruk> :t error
15:54:01 <lambdabot> forall a. [Char] -> a
15:54:02 <Saizan> dark: it's from Data.Function iirc
15:54:18 <identity> :t fix
15:54:19 <lambdabot> forall a. (a -> a) -> a
15:54:23 <dark> cool o.o
15:54:37 <ddarius> @hoogle fix
15:54:37 <lambdabot> Data.Function fix :: (a -> a) -> a
15:54:37 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
15:54:37 <lambdabot> module Control.Monad.Fix
15:54:52 <dark> @src fix
15:54:52 <lambdabot> fix f = let x = f x in x
15:54:53 <systemfault> Hmm, why does the wikipedia article about "Turing Tarpit" http://en.wikipedia.org/wiki/Turing_tarpit has Haskell in its "Sell also" section? (
15:54:57 <systemfault> :(
15:55:13 <syntaxglitch> hahahaha
15:55:32 <Peaker> fix f = f (fix f) -- easier on the mind
15:55:34 <monochrom> the lambda tarpit
15:56:13 <dark> yes i knew fix from that other definition
15:56:40 <systemfault> Hmm.. s/sell/see :(
15:56:44 <identity> systemfault: Hahaha..
15:56:51 <identity> That insults my fanboyism
15:57:13 <systemfault> :)
15:57:33 <monochrom> just add php to that section
15:58:09 <syntaxglitch> or just remove Haskell, because it doesn't belong there
15:58:30 <monochrom> no, add every language
15:58:41 <ddarius> monochrom: Not Agda.
15:58:55 <syntaxglitch> is Agda turing complete?
15:59:04 <syntaxglitch> seems like that's a prerequisite for being a turing tarpit
15:59:13 <monochrom> type tarpit
15:59:16 <syntaxglitch> heh
15:59:48 <systemfault> Done :D
15:59:59 <systemfault> Fixed
16:00:35 <fizruk> systemfault: great :)
16:01:59 <syntaxglitch> monochrom, that page would probably just be "Type tarpit: Redirect page -> Oleg Kiselyov"
16:02:58 <JoeyA> Why do Data.Map and Data.Set use size-balanced instead of height-balanced binary trees?  Is it more efficient in general, or is it more efficient for functional programming in particular?
16:05:19 <wxl> so anyone know of an os x ppc version of cabal? even with (an old) ghc working fine I can't build it off of macports because it wants to try to build ghc again, which it fails on
16:07:47 <dark> http://en.wikipedia.org/wiki/System_F-omega#System_F.CF.89 o.o
16:08:47 <syntaxglitch> dark, what about it
16:10:55 <monochrom> there is the hobby of deliberately picking up subjects you don't understand just so you can brag about your o.o
16:11:10 <dark> =DDDD
16:11:27 <dark> mappings from values to types, etc, etc
16:11:28 <dark> so cool
16:11:43 <monochrom> but yes, you are alone, it is just you.
16:12:15 <JoeyA> lol
16:12:47 <dark> what do you mean
16:12:51 <syntaxglitch> pf, Fω isn't a big deal, you can get most (or all?) of it in GHC
16:13:09 <syntaxglitch> it's just the whole values-to-types thing that's kind of a big deal
16:13:23 <dark> its type inference is undecidable
16:13:35 <dark> (wikipedia says)
16:13:46 <syntaxglitch> so is Haskell with any of several GHC extensions
16:14:00 <syntaxglitch> just means you need at least one type annotation
16:14:28 <Philippa> dark: it means 'complete' type inference - all types erased. It's possible to do inference with a certain minimum amount of info
16:14:50 <Philippa> for the most part it's enough to know where to generalise (and how many times)
16:14:53 <dark> "As a term rewriting system, System F is strongly normalizing.", and the article says strongly normalizing = not turing complete
16:15:02 <dark> u.u
16:15:11 <Philippa> yes, that's standard. OTOH, add a fixpoint operator and that changes
16:15:19 <Philippa> similarly, add recursive let
16:15:23 <Philippa> (the two are equivalent)
16:15:59 <Philippa> fix has a sensible enough type, it just doesn't typecheck on its own because it introduces logical inconsistency
16:16:01 <dark> why Fw doesn't have a fixed point operator? it's untypable there?
16:16:02 <pr>  /wii dark
16:16:06 <pr> whoopsydaisy
16:16:17 <Philippa> because it changes the properties of the logic
16:16:24 <pr> detective pr: mission failed :(
16:16:49 <Philippa> if you can type general recursion without having to supply any particular proofs about it, your logic's proofs become far less meaningful because you can prove /anything/ using a non-terminating term
16:18:05 <dark> yeah, non-terminating functions has type .. -> a for all a
16:18:12 <syntaxglitch> dark, the type of a fixed point operator in logical terms amounts to "for all propositions A, if A implies itself, then A is true"
16:18:23 <dark> hmm
16:18:27 <dark> (a -> a) -> a
16:18:31 <dark> yeah
16:18:34 <syntaxglitch> :t fix
16:18:34 <lambdabot> forall a. (a -> a) -> a
16:18:39 <JoeyA> > fix ("circular reasoning works because " ++)
16:18:40 <lambdabot>   "circular reasoning works because circular reasoning works because circular...
16:18:44 <syntaxglitch> haha
16:19:02 <dark> so Fω reject this type in its formalism?
16:19:27 <Philippa> no, it just doesn't assign it to any of the known lambda calculus fixpoint operators
16:19:30 <syntaxglitch> the type is fine, there's just no way to construct such a term out of nothing
16:19:50 <Philippa> you can add a term fix with that type to the context, and a corresponding reduction rule, and it works fine
16:20:04 <dark> but following the syntax rules for that calculus one couldn't construct fix?
16:20:20 <Philippa> no, you just couldn't type it
16:20:33 <Philippa> there's an infinite number of fixpoint operators in the untyped lambda calculus
16:21:01 <dark> so that calculus has some kind of rule to build well-typed expressions
16:21:10 <syntaxglitch> :t \f -> (\x -> f $ x x) (\x -> f $ x x)
16:21:10 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> a
16:21:10 <lambdabot>     Probable cause: `x' is applied to too many arguments
16:21:10 <lambdabot>     In the second argument of `($)', namely `x x'
16:21:27 <syntaxglitch> dark: that's pretty much what you'd get trying to build one from scratch
16:21:34 <Philippa> dark: that's what a type system does, yes
16:21:58 <syntaxglitch> dark: the lambda expression I wrote is a fixed-point operator (and would work in an untyped lambda calculus)
16:22:19 <dark> that's the y combinator, right? but haskell has some other fixed point operator
16:22:41 <syntaxglitch> Haskell has built-in recursion
16:22:59 <Philippa> right - in haskell, recursive let is primitive and that lets you declare fix
16:23:19 <syntaxglitch> recursive let is syntactically nicer, but the net result is the same
16:23:53 <dark> o.o
16:24:04 <syntaxglitch> otherwise you'd have to write any recursive function as taking itself as a parameter and then apply fix to it
16:24:19 <dark> in ocaml the error is Error: This expression has type 'a -> 'b, but an expression was expected of type 'a
16:24:27 <Philippa> dark: you can declare recursive let in terms of fix (and a record encoding), and you can declare fix with a recursive let
16:24:30 <dark> like if it were an infinite / recursive type
16:24:37 <hpc> syntaxglitch: that would be valid if f and x are both id
16:24:54 <hpc> i think
16:25:02 <dark> Philippa, that I saw, how to reclare recursive factorial with fix
16:25:08 <systemfault> Nice, someone made an haskell interpreter in javascript.
16:25:17 <]OLI[> lambdabot: 1 + 2
16:25:26 <hpc> O.O javascript?
16:25:29 <systemfault> Yeah
16:25:29 <systemfault> http://github.com/johang88/haskellinjavascript
16:25:34 <Philippa> dark: it's actually more powerful than that alone demonstrates, but yeah
16:25:43 <systemfault> It works on firefox (Seems to have bugs with chrome)
16:25:54 <hpc> that's pretty nuts
16:26:17 <systemfault> Yeah, that's why WTF moment of the day.
16:26:30 <syntaxglitch> hpc, would it? maybe by some sort of polymorphism making the whole thing trivial I guess, but I don't see how
16:26:42 <hpc> :t id id
16:26:43 <lambdabot> forall a. a -> a
16:26:48 <hpc> id id == id
16:27:01 <Philippa> :t fix fix
16:27:01 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
16:27:01 <lambdabot>     Probable cause: `fix' is applied to too many arguments
16:27:01 <lambdabot>     In the first argument of `fix', namely `fix'
16:27:03 <hpc> \x -> f $ x x = id $ id id = id id = id
16:27:16 <Philippa> fix call/cc is another fun one
16:27:20 <hpc> and that twice = id id = id
16:27:22 <]OLI[> :t read
16:27:23 <lambdabot> forall a. (Read a) => String -> a
16:27:38 <dark> does haskell have call/cc?
16:27:43 <syntaxglitch> Philippa, isn't there a fixpoint operator made of only call/cc
16:27:54 <syntaxglitch> dark, only in the Cont monad
16:27:55 <]OLI[> zip "Hi" "you"
16:28:14 <]OLI[>   zip (+) "Hi" "you"
16:28:34 <pr> > zip "Hi" "you"
16:28:35 <lambdabot>   [('H','y'),('i','o')]
16:28:53 <]OLI[> >zip (+) "oh" "right"
16:28:54 <hpc> er
16:29:52 <pr> lambdabot just won't answer british type haters
16:29:56 <pr> sorry oli!
16:30:15 <pr> > zip (+) "oh" "right"
16:30:16 <lambdabot>   Couldn't match expected type `[a]'
16:30:16 <lambdabot>         against inferred type `a1 -> a1 ...
16:30:19 <pr> :-)
16:30:24 <hpc> :t \x -> x x
16:30:25 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
16:30:25 <lambdabot>     Probable cause: `x' is applied to too many arguments
16:30:25 <lambdabot>     In the expression: x x
16:30:41 <hpc> :t \x -> (x x) `asTypeOf` x
16:30:41 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> a
16:30:42 <lambdabot>     Probable cause: `x' is applied to too many arguments
16:30:42 <lambdabot>     In the first argument of `asTypeOf', namely `(x x)'
16:31:22 <hpc> :t \x -> (x x) $ id
16:31:25 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> a -> b
16:31:27 <lambdabot>     Probable cause: `x' is applied to too many arguments
16:31:29 <lambdabot>     In the first argument of `($)', namely `(x x)'
16:31:36 <hpc> :t (\x -> (x x)) id
16:31:36 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
16:31:36 <lambdabot>     Probable cause: `x' is applied to too many arguments
16:31:37 <lambdabot>     In the expression: (x x)
16:31:41 <hpc> :(
16:31:48 <dark> functional programming is hard o.o
16:31:53 <syntaxglitch> hpc: I think you want (\x -> x x) :: (forall a. a -> a) -> (forall a. a -> a)
16:32:04 <syntaxglitch> with RankNTypes, of course
16:32:07 <hpc> probably
16:33:14 <hpc> i don't entirely understand higher rank types enough to know for sure
16:33:57 <syntaxglitch> hpc, they pretty much just mean what they say
16:34:27 <syntaxglitch> if it helps, you can read forall as a lambda
16:34:33 <syntaxglitch> on types, of course :)
16:34:52 <hpc> i see
16:35:09 <hpc> the second "id" isn't of the same type as the first, necessarily
16:35:38 <syntaxglitch> no, they're the "same" type
16:35:44 <syntaxglitch> just... a polymorphic type
16:36:20 <hpc> i mean, the "a" isn't the same
16:36:20 <Philippa> dark: eh, most of this stuff's esoterica that you don't actually need to know for the most part and would apply if you tried to do something similarly smart-arsed in an OO lang
16:36:25 <hpc> or something
16:36:31 <syntaxglitch> the forall binds concrete types to type parameters the same way that a lambda expression binds values to parameters
16:36:48 <Philippa> it's just that it's an awful lot easier to simulate recursion if you can backpatch manually
16:37:20 <JoeyA> Just wondering, does GHC insert frees at compile time when it knows it can? (to improve performance)
16:37:31 <syntaxglitch> hpc, it's not the same or not-the-same, it's not even bound
16:37:54 <syntaxglitch> the "a" exists only within the scope of the forall, which is inside the parentheses
16:38:09 <JoeyA> or even emit mutations when it knows the original won't be used again
16:38:15 <hpc> so...
16:38:35 <hpc> \x -> x x takes something that is a function from a type into itself
16:38:40 <hpc> and produces...
16:38:55 <hpc> something
16:39:28 <hpc> i still don't get it
16:39:35 <syntaxglitch> hpc: think of "x" as sort of being a function taking a *type* as an argument
16:39:51 <monochrom> \x -> x x is better off understood without type
16:40:00 <hpc> oh
16:40:16 <syntaxglitch> when x is applied to itself, the first function gets the type argument filled in by type inference (the type of "x" WITHOUT having been applied to anything)
16:40:57 <hpc> aha!
16:40:57 <syntaxglitch> the first x also gets its value argument filled in, with the other x which is still an unapplied "type function"
16:41:27 <fizruk> can anyone say why bad_magic function cannot be typecheked in this code: http://ideone.com/CJdqy ?
16:41:53 <syntaxglitch> within that first x, the type variable "a" is bound to a specific type (that of the unapplied second "x")
16:41:55 <syntaxglitch> etc. etc.
16:42:06 <hpc> so the 'a' of the first x is the 'a -> a' of the second x
16:43:46 <hpc> i think i see how it works now
16:43:57 <monochrom> GAGTs? GADTs?
16:44:12 <fizruk> monochrom: GADTs :)
16:44:12 <monochrom> GAGTs sounds like a really bad gag. XD
16:44:30 <hpc> when you say 'id id' the two ids are different, but when you try and lambda it, it attempts to make the two ids the same type
16:44:53 <hpc> with a higher rank type, it doesn't, and makes a more complex check instead
16:45:50 <hpc> i have learned me a type theory today!
16:45:51 <hpc> huzzah
16:46:20 <syntaxglitch> hpc: it helps to write the implied quasi-type functions explicitly... look up the notation for System F or something
16:46:48 <fizruk> hpc: congratulations! :) maybe you can know help with my little problem? )
16:46:50 <syntaxglitch> it makes a lot more sense when you have to write out all the type parameters in explicit mind-numbing tedium
16:47:02 <res> think of some physixal attacker that can operate in hail
16:47:02 <hpc> fizruk: nowai
16:47:13 <fizruk> hpc: :)
16:47:24 <res> derp wrong channel
16:47:48 <syntaxglitch> hpc, and yeah, the higher rank type is just saying "this must work on any type, but I won't unify that type unless necessary"
16:48:18 <hpc> cool
16:48:35 <hpc> it might be more natural to learn with the exists keyword
16:48:58 <hpc> i think that's just sugar for inner forall
16:49:11 <syntaxglitch> hpc, I dunno, I find the big lambda approach more natural
16:49:22 <augur> big lambda!
16:49:39 <monochrom> Λ is big
16:49:44 <augur>  /\x.\y^x.y
16:49:49 <augur> :D
16:50:12 <syntaxglitch> e.g., think of id as a function (/\a => (\x -> x) :: a -> a) to abuse pseudo-Haskell syntax
16:50:35 <zygoloid> @oeis 2,3,5,13
16:50:35 <lambdabot>  Prime Fibonacci numbers.
16:50:36 <lambdabot>  [2,3,5,13,89,233,1597,28657,514229,433494437,2971215073,99194853094755497,10...
16:50:38 <augur> thats what i did, syntaxglitch :|
16:50:54 <syntaxglitch> augur, oops, didn't see yours, heh
16:51:01 <augur> so under appreciated :(
16:51:07 <augur> zygoloid: whats @oeis
16:51:13 <monochrom> probably because of the ^
16:51:19 <syntaxglitch> augur, mine was more Haskell-flavored though!
16:51:21 <augur> something something integer sequences?
16:51:33 <augur> syntaxglitch: maybe so, but its not valid >|
16:51:39 <monochrom> open encyclopedia of integer sequences?
16:51:42 <zygoloid> augur: online encyclopaedia of integer sequences
16:51:45 <augur> aha!
16:52:00 <zygoloid> @oeis 1,11,21,1211
16:52:00 <lambdabot>  Look and Say sequence: describe the previous term! (method A - initial term ...
16:52:01 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
16:52:01 <Axman6> @oesis 3,7,15,1,292,1,1,1
16:52:02 <lambdabot>  Continued fraction expansion of Pi.
16:52:02 <lambdabot>  [3,7,15,1,292,1,1,1,2,1,3,1,14,2,1,1,2,2,2,2,1,84,2,1,1,15,3,13,1,4,2,6,6,99...
16:52:12 <augur> @oeis 3,7,15,1
16:52:12 <lambdabot>  Continued fraction expansion of Pi.
16:52:12 <lambdabot>  [3,7,15,1,292,1,1,1,2,1,3,1,14,2,1,1,2,2,2,2,1,84,2,1,1,15,3,13,1,4,2,6,6,99...
16:52:17 <augur> ahaaaa
16:52:26 <augur> oh, hey, Axman6, stop reading my mind
16:52:27 <syntaxglitch> @oeis 1, 6, 21, 107
16:52:27 <lambdabot>  Busy Beaver Problem: a(n) = maximal number of steps that an n-state Turing m...
16:52:27 <lambdabot>  [1,6,21,107]
16:52:33 <Axman6> heh
16:52:42 <syntaxglitch> haha the list stops there, does it
16:52:44 <syntaxglitch> good to know
16:52:50 <zygoloid> [1,6,21,107,<umm...>]
16:52:52 <hpc> i wonder when they will get 5
16:53:04 <Axman6> augur: don't do it, you know you're not supposed to do that thing!
16:53:10 <augur> D:
16:53:18 * zygoloid worked on that about 15 years ago. got it narrowed down to about 8 turing machines
16:53:42 <zygoloid> probably more like 10 years
16:53:51 <aristid> i wonder if Num a => Num (Maybe a) would be definable
16:54:29 <zygoloid> aristid: sure. (Num a, Applicative f) => Num (f a) is definable
16:54:33 <syntaxglitch> easy, just make everything evaluate to Nothing
16:54:41 <hpc> with or without extensions?
16:55:01 <zygoloid> it's all just lifting n-ary functions on a into the Applicative
16:55:27 <aristid> well that breaks for (==) and such
16:55:31 <hpc> instance ... where foo = liftAx foo
16:55:31 <zygoloid> (actually, you probably also need Eq (f a) and Show (f a) in the context, stupid Num *grumbles*)
16:55:35 <aristid> but compare onf Maybe is well-defined
16:55:49 <aristid> Eq and Show work for Maybe too
16:55:59 * syntaxglitch heaps scorn on Num
16:56:14 <aristid> yeah Num is defined Dumb
16:56:21 <zygoloid> Numb?
16:56:31 <aristid> Num
16:56:45 <aristid> zygoloid: Numb is no standard typeclass. you oughta know that
16:57:06 * syntaxglitch starts using a custom Prelude that differs only in renaming Num to "Dum"
16:58:02 <Axman6> hpc: woah, that broke my brain for a sec... then realised that that actually did make sense. 
16:58:04 <aristid> systemfault: lol
16:58:30 <aristid> Axman6: type classes make recursion detection harder
16:58:33 <monochrom> systemfault? syntaxglitch? tab fault? tab glitch?
16:58:46 <aristid> monochrom: tab fault
16:58:54 <Axman6> aristid: yeah, my brain is telling me this :P
16:59:03 <hpc> Axman6: indeed; every function in Num is an endofunctor, so you can get away with it
16:59:09 <aristid> monochrom: not everybody has a wonderfully unambiguous nickname like you :)
16:59:31 <Axman6> a saywhatnow?
16:59:31 <monochrom> wait til a "monolith" appears
16:59:44 <aristid> ok it also would help if i typed in three instead of two characters
16:59:47 <aristid> or checked the result
16:59:51 <hpc> a transformation from something into itself
17:00:16 <aristid> hpc: you mean except those from Eq?
17:00:24 <aristid> hpc: and Show?
17:00:29 <hpc> aristid: i was speaking for Num only :P
17:00:39 <aristid> Num entails Eq and Show.
17:00:41 <hpc> and Maybe already has an Eq and Show instance
17:00:55 <aristid> yeah i think it should work pretty well for Maybe :)
17:01:07 <aristid> Nothing would be the smallest number possible
17:01:19 <aristid> smaller than -Infinity
17:01:45 <syntaxglitch> unfortunately I already have an obnoxious custom Prelude replacement I use in all my stuff. :( I'm glad my projects are all solo efforts because I think anyone else would kill me after seeing some of that stuff.
17:01:51 * hpc has recently begun explaining Maybe as an analog to pointers, in terms of either containing something, or containing nothing
17:02:08 <Philippa> it works for the C/C++ folks at least, yeah
17:02:10 <hpc> it helps for C coders
17:02:19 <aristid> hpc: you can reuse "Pointer fun with Binky" then
17:02:23 <hpc> and Java, where you can say Nothing == null
17:02:29 <hpc> aristid: wut
17:02:37 <aristid> hpc: wut!
17:02:59 <aristid> http://cslibrary.stanford.edu/104/
17:03:14 * hpc found on youtube
17:03:18 <hpc> oh god
17:03:32 <aisamu> hello again! My internet is a bit unreliable, so i might have missed if someone answered... Is (`elem` [1..10]) exactly (speed, efficiency, etc) the same as flip elem [1..10]?
17:03:36 <aristid> Pointer fun with Binky - in Haskell
17:03:51 <monochrom> http://lambda-the-ultimate.org/node/4100  haskell interpreter written in javascript
17:04:13 <hpc> aisamu: probably not; flip id is slower than const id
17:04:21 <hpc> er
17:04:26 <monochrom> "the impossible has happened! my brain has exploded!"
17:04:33 <hpc> that, only less stupid
17:04:58 <Cale> aisamu: yes
17:05:04 <aisamu> hpc: thanks! 
17:05:06 <aristid> who was it? either joel spolsky or paul graham said that javascript would be used to compile code from high-level languages into it. i guess many other people predicted it too, but i didn't read their texts
17:05:18 <Cale> aisamu: They
17:05:22 <hpc> *flip const < const id
17:05:29 <hpc> yet both are equal
17:05:36 <Cale> aisamu: They're identical, one desugars into the other
17:05:58 <hpc> oh, sections are sugar?
17:06:03 <aisamu> Cale: 'desugars' hahahaha
17:06:06 <aristid> Cale: which is the desugared one? :>
17:06:17 <aristid> flip is a function that might be re-defined in the context
17:06:44 <aristid> so "desugaring" (`a` b) into flip a b would be risky
17:07:13 <hpc> aristid: how often does one redefine flip, though?
17:07:20 <aristid> hpc: whenever you ask
17:07:23 <hpc> it's like "desugaring" do notation
17:07:35 * syntaxglitch moves to replace the term "desugaring" with "bittering"
17:07:36 <aristid> hmm. true.
17:07:49 <Cale> That is, (`op` x) is just syntax sugar for flip op x
17:07:53 <monochrom> a compiler desugars haskell into, er, javascript
17:07:55 <Philippa> that, and it can be desugared to Prelude.flip
17:07:56 <aristid> systemfault: and @undo should become @bitter
17:08:13 <Philippa> monochrom: that's not the same. You can only desugar a language into a sublanguage of itself
17:08:21 <Axman6> :t flip
17:08:22 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:08:27 <hpc> aristid: while we are sarcastically renaming commands, @pl should be @perl
17:08:36 <hpc> which could be shortened to just the file extension for scripts
17:08:39 <hpc> so @pl :P
17:08:50 <aristid> hpc: and @unpl should be @pascal
17:08:54 <hpc> XD
17:08:54 <syntaxglitch> heh
17:10:07 <hpc> i still say it would be elegant and awesome to have infix be actually prefix, with a funny exploit of currying
17:10:28 <hpc> er, postfix
17:10:55 <hpc> i should probably go to sleep before i say something really stupid
17:11:18 <aisamu> me too... so Cale's answer is final?
17:11:35 <hpc> Cale's answers are always final :P
17:11:46 <aisamu> hahahahahahah ok!
17:12:04 <Cale> flip op x is the desugared one
17:12:38 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/81600/focus=81633
17:12:49 <augustss> The Haskell report actually doesn't allow the flip desugaring.
17:12:50 <aisamu> ok! thanks a lot! as a side question... how could i discover that by myself? (if it's not easy, nevermind)
17:12:55 <zygoloid> aisamu: (`op` xs) desugars into \x -> x `op` xs. any decent compiler will turn flip op xs into the same thing
17:13:15 <Philippa> augustss: what does it specify?
17:13:15 <augustss> Desugaring with flip does not have the semantics the report requires.
17:13:17 <zygoloid> aisamu: ghc-core is a great way of seeing how your code compiles (into core at least)
17:13:26 <hpc> :t \x -> x >>= Right
17:13:27 <lambdabot> forall a a1. (Error a1) => Either a1 a -> Either a1 a
17:13:34 <hpc> :t \x -> x >>= Left
17:13:34 <augustss> The report uses \
17:13:35 <lambdabot> forall a b. (Error a) => Either a a -> Either a b
17:14:00 <hpc> that could be a fun trick
17:14:09 <augustss> zygoloid: A decent compiler has to treat those two as different.
17:14:20 <aisamu> zygoloid:  so infix  (`op`) is the root construct? or would it be 'desugared' into something else?
17:14:39 <Cale> augustss: really?
17:14:44 <monochrom> > seq (() `undefined`) 0
17:14:45 <lambdabot>   *Exception: Prelude.undefined
17:14:57 <zygoloid> > seq (`undefined` undefined) 0
17:14:58 <lambdabot>   0
17:15:01 <monochrom> > seq (\x -> undefined () x) 0
17:15:02 <lambdabot>   0
17:15:14 <augustss> Cale: monochrom beat me
17:15:29 <zygoloid> augustss: nope, we're talking about (`op` e) not (e `op`)...
17:15:40 <aisamu> zygoloid: i mean, i always thought infix notation was, itself, sugar.
17:15:40 <monochrom> I just copied from the recent thread (the url I just posted)
17:15:44 <adorablepuppy_> Hello all. I'm new to haskell, not new to programming. I am in the process of using the Learn you a Haskell tutorial and was playing around with some stuff while doing it. I am well aware that what I'm trying to do is already implemented in haskell. However, for practice I was trying to write something to convert a string of 1's and 0's into a base64 encoded version of the binary digits those 0's and 1's, so far I've got this:
17:16:01 <zygoloid> (i agree that (e `op`) isn't the same as (op e), though)
17:16:32 <monochrom> > seq (flip undefined ()) 0
17:16:32 <lambdabot>   Ambiguous type variable `f' in the constraint:
17:16:33 <lambdabot>    `GHC.Base.Functor f'
17:16:33 <lambdabot>     ...
17:16:50 <monochrom> hrm, I'm too lazy to give it types
17:16:57 <adorablepuppy_> Couldn't match expected type '([Char] -> [Char] ) -> [Char] -> [Char]' against type '[Char]'
17:17:11 <hpc> adorablepuppy_: that smells like a typo
17:17:22 <zygoloid> > seq (P.flip undefined undefined) 0
17:17:23 <lambdabot>   0
17:17:33 <DaTwinkDaddy> :t flip
17:17:33 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:17:34 <hpc> find what line the error is on and look for anything hinky in that function definition
17:17:36 <zygoloid> > seq (`undefined` undefined) 0
17:17:37 <lambdabot>   0
17:17:49 <Cale> adorablepuppy_: Perhaps you're treating a string as a function somewhere, or vice versa?
17:17:54 <monochrom> oh, funky flip
17:18:11 <hpc> perhaps you are using (.) instead of ($)
17:18:25 <hpc> > f . x
17:18:25 <lambdabot>   Couldn't match expected type `f a'
17:18:25 <lambdabot>         against inferred type `SimpleRef...
17:18:30 <hpc> > f $ x
17:18:31 <lambdabot>   Ambiguous type variable `b' in the constraints:
17:18:31 <lambdabot>    `SimpleReflect.FromExpr ...
17:18:39 <hpc> bad example...
17:18:49 <DaTwinkDaddy> > id . "foo"
17:18:49 <lambdabot>   "foo"
17:18:50 <adorablepuppy_> Cale: I don't think it would be. hpc: all code is written as I think it would be. Though coming from the world of imperitive languages, I could be wrong.
17:18:55 <DaTwinkDaddy> > id $ "foo"
17:18:55 <lambdabot>   "foo"
17:19:02 <hpc> > id . "foo"
17:19:03 <lambdabot>   "foo"
17:19:08 <zygoloid> aisamu: the infix (a `op` b) is desugared into (op a b).
17:19:09 <DaTwinkDaddy> > id Prelude.. "foo"
17:19:09 <lambdabot>   Not in scope: `Prelude..'
17:19:20 <augustss> zygoloid: In (flip op e) and (\ x -> op x e) the expression normally gets different sharing.
17:19:29 <hpc> > (Prelude..) id foo
17:19:29 <lambdabot>   Not in scope: `Prelude..'Not in scope: `foo'
17:19:37 <augustss> zygoloid: The expression e, I mean.
17:19:38 <hpc> >:(
17:19:38 <Cale> adorablepuppy_: Could you put your code up on some paste site?
17:19:54 <DaTwinkDaddy> > (Prelude..) id "foo"
17:19:55 <lambdabot>   Not in scope: `Prelude..'
17:20:05 <monochrom> darn. I was hoping it to last for half an hour before actual code would appear
17:20:07 <adorablepuppy_> Yes, http://pastebin.com/LW6KfQE8 as pasted earlier in my huge tl;dr block of text.
17:20:10 <DaTwinkDaddy> > (P..) id "foo"
17:20:11 <lambdabot>   Couldn't match expected type `a -> b'
17:20:11 <lambdabot>         against inferred type `[GHC.T...
17:20:14 <hpc> > let (f . g) x = f (g x) in id . "foo"
17:20:15 <lambdabot>   Couldn't match expected type `t -> t1'
17:20:15 <lambdabot>         against inferred type `[GHC....
17:20:30 <adorablepuppy_> I may havee found the issue
17:20:39 <Cale> adorablepuppy_: I don't think all that text came through, it got chopped off
17:20:50 <zygoloid> augustss: interesting, that makes sense. the denotational semantics match, though, so it does have the semantics the report requires, i think?
17:21:51 <Cale> adorablepuppy_: You're applying the function b2b64 to 3 parameters there: (take 4 b) is the first, then bin2base64 is the second, and (drop 4 b) is the third. Are you sure that's what you want?
17:22:06 <fizruk> augustss, I know you can help me :) if it's not difficult to you, could you explain, this piece of code? http://ideone.com/csc93
17:23:12 <adorablepuppy_> Cale: Yeah, I got that a bit ago. I joined the text of the output of b2b64 and the call to bin2base64 and it seems to be alright in compilation
17:23:42 <zygoloid> well, ghc compiles them to identical code
17:24:50 <adorablepuppy_> Also, it should be take 6 and drop 6. not 4
17:25:20 <adorablepuppy_> Works, thanks Cale, hpc.
17:26:02 <benmachine> adorablepuppy_: btw, splitAt 6 xs = (take 6 xs, drop 6 xs)
17:26:07 <benmachine> in case that is interesting to you
17:26:34 <adorablepuppy_> benmachine: Thanks.
17:27:06 * hackagebot haskell-qrencode 1.0.2 - Haskell bindings for libqrencode.  http://hackage.haskell.org/package/haskell-qrencode-1.0.2 (JamesSanders)
17:27:46 <augustss> zygoloid: Yes, the denotational semantics match (I was thinking of (e `op`)), but sharing can differ.  At least I think they match.  My intuition gets screwed up by seq. :)
17:28:38 <aisamu> zygoloid: so flip gets desugared into infix notation, that gets desugared into prefix notation?
17:29:33 <aisamu> (i'm really into that desugaring thing, heheh)
17:29:47 <augustss> fizruk: If you expand the code you'll see that one has a case with and Eq branch and the other one doesn't.  And the way ghc type checks the equality between a and b is only known after an Eq match.
17:31:54 <fasta> fizruk, your test function creates a Maybe (Equal a b), so, y has type b, then you put [x,y] in a list, so, naturally the compiler complains. 
17:32:23 <aisamu> in any case, thanks for the help!
17:32:35 <fizruk> augustss: but there this only one constructor for (Equal a b), can't ghc just use that information so that I won't need to use explicit pattern matching?
17:33:08 <augustss> fizruk: the type also contains bottom, so you have to match on Eq to know they are equal
17:35:11 <fizruk> augustss: hm... thanks, I always forget about that bottom :)
17:35:21 <augustss> fizruk: and indeed, you good_magic code will blow up at runtime, whereas bad_magic wouldn't.  So we don't bad_magic to be accepted by the type checker.
17:36:05 <fizruk> augustss: good_magic will blow up?
17:36:38 <monochrom> because test blows up. and there is probably no other way to implement test anyway.
17:36:40 <augustss> fizruk: Sorry, if you change test to (Just undefined)
17:37:27 <augustss> It would be scary if you could implement test to always return Just.
17:37:49 <augustss> With a proof, I mean
17:39:18 <pr> that pointer fun with binky video is hilarious
17:42:29 <dolio> test = Just (unsafeCoerce Eq) :)
17:43:50 <dolio> That's how it's done in CC-delcont.
17:45:02 <jimmyjazz14> is there any trick to make hackage show the haddock documentation for your package?
17:46:12 <fizruk> augustss: btw, in one of your posts you wrote "There are many ways to formulate type safe abstract syntax trees", but all I found were GADTs. can you say where to find others?
17:46:28 <Axman6> jimmyjazz14: wait a few hours. it's done every 6 hours for new packages
17:50:01 <fasta> fizruk, you can also use functional dependencies if you are into that for example.
17:52:19 <fizruk> fasta: what functional dependencies? GADTs allow some form of them, if I'm not mistaken :)
17:52:51 <fasta> fizruk, I meant how functional dependencies are used for type-level computation with suitable extensions enabled.
17:53:42 <fizruk> fasta: can you show me a simple example, please? or just redirect to some papers of something?
17:54:12 <enthropy> @where HList
17:54:12 <lambdabot> http://homepages.cwi.nl/~ralf/HList
17:54:42 <fasta> fizruk, enthropy's suggestion is very good.
17:55:21 <fizruk> fasta: enthropy: thanks :)
17:55:30 <fasta> fizruk, but by the time that you want these things, you can better just switch to a language which is designed for these things.
17:56:05 <fasta> E.g. Coq, but some others seem to like Isabelle and Twelf better.
17:56:48 * enthropy doesn't know those languages, but when doing things at type-level in haskell you're code is rather distantly related to a clear way of expressing what's going on
17:57:03 <fasta> I personally think type-safe ASTs are overrated for a lot of domains. 
17:57:16 <augustss> fasta: I agree
18:00:53 <fizruk> fasta: hm... I'm writing simple compiler I'm not sure I'd like to switch to Coq :) as for now, I'm just interested in different ways of doing one thing to select most suitable instrument
18:01:28 <dolio> Writing a compiler is not one of the situations I'd be eager to use a type-safe AST in.
18:03:47 <benmachine> agdaagdaagda
18:05:50 <fizruk> dolio: i'd like to use LLVM for code generation. I haven't wrote translation from untyped AST to typed representation of LLVM code, but I feel like having typed AST would make it much easier. Maybe I'm mistaken
18:06:35 <augustss> It's easier to translate typed AST to the typed LLVM code, but typed ASTs can be a pain to manipulate.
18:07:11 <dolio> Type-safe ASTs are for ensuring that you cannot possibly construct a tree that is ill-typed.
18:07:30 <dolio> But compilers may have reason to deal in ill-typed ASTs for the language they're compiling.
18:07:52 <dolio> So that, for instance, you don't have to do type checking merely to *parse* your language.
18:08:07 <enthropy> dolio: so encode that too :)
18:08:29 <enthropy>  Typed False a => a
18:10:02 <enthropy> debugging type errors could take longer than being reasonably sure that you have no errors in the untyped version
18:21:12 <mjk> haskell的消息传递机制是怎么样的？比如，我在执行一个循环的时候，收到另一个函数发来的消息，就可以根据发来的消息执行对应的操作
18:21:24 <dolio> Yes, of course.
18:21:56 <dolio> @seen Cale
18:21:56 <lambdabot> Unknown command, try @list
18:21:56 <preflex>  Cale was last seen on #haskell 1 hour and 5 seconds ago, saying: adorablepuppy_: You're applying the function b2b64 to 3 parameters there: (take 4 b) is the first, then bin2base64 is the second, and (drop 4 b) is the third. Are you sure that's what you want?
18:23:29 <hpc> :t =~
18:23:30 <lambdabot> parse error on input `=~'
18:23:35 <hpc> :t (=~)
18:23:35 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
18:23:57 <enthropy> facinating
18:24:00 <FunctorSalad_> :t gfoldl =~ gunfold
18:24:01 <Peaker> augustss, I admit I speak from ignorance, but "typed ASTs pain to manipulate" sounds a bit like "static typing is a pain" or "purity makes effects a pain"
18:24:01 <lambdabot>     No instance for (RegexMaker
18:24:01 <lambdabot>                        Regex
18:24:01 <lambdabot>                        CompOption
18:24:59 <FunctorSalad_> Peaker: I guess the problem is that it requires rather *advanced* static typing
18:25:19 <FunctorSalad_> (essentially, proving that you transform well-typed code fragments into such)
18:25:46 <enthropy> proofs are hard
18:26:17 <fasta> I think for a compiler compilation by a sequence of transformations with invariants in between is probably the easiest to implement. 
18:26:32 <fasta> In Stratego that approach worked very well.
18:26:34 <Peaker> FunctorSalad_, Static typing is a pain if you aren't aware of various techniques that make it easier for various problems
18:26:57 <fasta> Stratego is basically a kind of Lisp with some very convenient syntax for program transformation.
18:26:57 <Peaker> FunctorSalad_, Maybe we are missing knowledge of such techniques for AST's? Or is the problem truly less tractable?
18:27:16 <FunctorSalad_> don't know :)
18:27:38 <enthropy> Peaker: what's the most complicated type you've dealt with?
18:27:48 <Peaker> enthropy, I'm not sure how to quantify that :)
18:27:58 <fizruk> fasta: you mean invariants not specified in code?
18:28:02 <fasta> Peaker, in number of pages :)
18:28:16 <Peaker> hehe.. not very complicated at all, I guess. I haven't done deep-GADT-magic-stuff
18:28:22 <FunctorSalad_> do derived multirec pattern functors count? :P
18:28:30 <fizruk> fasta: you mean name of type with its type parameters?
18:28:32 <fasta> fizruk, essentially assertions that are only checked at run-time.
18:29:51 <fasta> I think it is useful that you don't add a tuple to a string and that this is catched really fast, but describing all the properties exactly beforehand might take a lot more work than simply implementing it correctly the first time.
18:30:35 <FunctorSalad_> maybe one boundary of complexity is that between "simple" proofs and inductive ones?
18:30:45 <dolio> Proving that it works correctly after the fact isn't out of the question, either, given the right language.
18:30:53 <FunctorSalad_> (as we know, there isn't really a "mechanical" way for finding inductive hypotheses)
18:31:02 <heatsink> By "Typed AST" you mean that object language types are encoded into host language types (rather than host language values)?
18:31:12 <FunctorSalad_> I'm talking about the proofs curry-howard-corresponding to the types here
18:31:12 <dolio> heatsink: Yes.
18:32:07 <FunctorSalad_> heatsink: I understood it as meaning that you have Expr :: * -> *, with the type parameter indicating the type of the object expression
18:32:31 <heatsink> ok
18:32:36 <FunctorSalad_> (and the object type system has to be the same as haskell's or somehow encoded in it, yes)
18:32:37 <dolio> That's also a "yes". :)
18:34:47 <EvanR> does * -> * mean a function on kinds
18:35:12 <dolio> @kind Maybe
18:35:13 <lambdabot> * -> *
18:36:03 <EvanR> @kind (Maybe [])
18:36:04 <enthropy> EvanR: function on types
18:36:04 <lambdabot>     `[]' is not applied to enough type arguments
18:36:04 <lambdabot>     Expected kind `*', but `[]' has kind `* -> *'
18:36:13 <EvanR> oh
18:36:31 <fizruk> @kind (Maybe [Int])
18:36:32 <lambdabot> *
18:36:33 <heatsink> ...do people use typed ASTs for reasons other than proving it's achievable?
18:36:36 <EvanR> so * -> * is not included in *
18:37:06 <Peaker> @kind Maybe :. []
18:37:07 <lambdabot> Not in scope: type constructor or class `:.'
18:38:14 <enthropy> EvanR: right, you can't use Maybe as an actual type
18:38:18 <fasta> heatsink, you could say that in a dependently typed programming language you have less cases to handle. 
18:38:23 <enthropy> on it's own that is
18:40:17 <fizruk> heatsink: typed AST have some invariants that you just can't break. It is useful to know that you are working with sort of a correct AST
18:42:16 <Cale> dolio: wha?
18:42:26 <fasta> You have to write the invariant checking code somewhere anyway. Either you do it at run-time always (slow), or you do it when you get a bug report from a user (GHC has compiler options for that) or you put it in the type (pain to program, no run-time cost).
18:43:08 <FunctorSalad_> where the run time is actually compile time of the object language? ;)
18:43:20 <fizruk> fasta: not always pain :)
18:44:52 <fizruk> FunctorSalad_: one can insert assertions in generated code, so run-time can be run-tim of the object language :)
18:48:25 <heatsink> Right.  But I was rather under the impression that most AST-level bugs would be easily catchable later in the compiler pipeline (e.g. generating a use of a variable that's not in scope).  Instruction-level optimization bugs are more likely to slip through and crash your run-time code.
18:48:45 <dolio> Cale: You occasionally read Asian characters, so I thought you might be able to read that guy's question.
18:49:06 <dolio> Although, it might not be the right type of characters. I'm not sure.
18:50:08 <Adamant> dolio: it's Chinese characters of some sort
18:50:25 <Adamant> whether it's Chinese Chinese or Japanese Chinese characters is another question
18:50:38 <Adamant> (or Korean or Vietnamese Chinese characters)
18:50:48 <Adamant> maybe not, since CJK is unified in Unicode
18:50:54 <Adamant> *CJKV
18:51:29 <heatsink> It doesn't look like Japanese
18:52:17 <Adamant> it isn't
18:52:41 <Adamant> the Japanese use Chinese characters for some things
18:52:45 <fizruk> this is what google translate gives: "Message passing is kind of how? For example, I perform a loop in time, received a message sent by another function to the message sent can perform the corresponding operations"
18:53:02 <fizruk> and it says it's chinese
18:53:25 <heatsink> google keal
18:53:47 <fizruk> but know we know source language :)
19:04:57 <Adamant> fizruk: Google knows probabilistically, I know for certain :P
19:05:46 <weisswolf> sorry to barge in everyone :) But I am struggling a bit with handling list  in Haskell, Im a total beginners so any help would be really appreciated
19:05:49 <syntaxglitch> fizruk, heh "perform a loop in time"
19:06:06 <syntaxglitch> closed timelike curves are just tying the knot for causality
19:07:21 <weisswolf> :) anyone?
19:07:43 <danharaj> ask a question and it will be answered.
19:07:50 <weisswolf> ah thanks
19:09:05 <FunctorSalad_> the self-causing thunk :O
19:11:07 <weisswolf> let say I got a list: [("p",AND (WIRE "x") (WIRE "q")), ("q", AND (WIRE "p") (WIRE "y"))] of type [(String, Exp)], I want to modify the expression on the tuple where I get the the list of 1st elements ["p", "q"], if they are in 2nd Exp replace WIRE with OUT; otherwise with IN
19:11:52 <weisswolf> so the output of the above list will turn into [("p, AND (IN "x") (OUT "q")... blah]
19:11:53 <syntaxglitch> FunctorSalad_, the real question is whether the laws of physics have non-strict semantics
19:11:59 <Axman6> can you show examples of input and output to the function you want weisswolf?
19:12:06 <weisswolf> aye
19:12:14 <danharaj> not in irc use a codepad site
19:12:21 <danharaj> uhhh all their url's elude me at the moment
19:12:24 <weisswolf> sorry I am very new
19:12:33 <Axman6> codepad.com?
19:12:48 <weisswolf> aye, I'm be getting on it
19:12:53 <danharaj> hpaste.org
19:12:53 <Axman6> weisswolf: we don't mind, but we do need more information before we can begin to help you ;)
19:13:06 <weisswolf> certainly Axman
19:13:08 <danharaj> We have nothing better to do other than make other programmers drink the kool-aid.
19:13:22 <weisswolf> I tried all the tutorials but Haskell got me really struggling
19:13:42 <weisswolf> I get too used to the old world of C  :(
19:13:42 <Axman6> it just takes a bit of time to understand
19:14:10 <weisswolf> it is my assignment so I would appreciate it if you guys guide me along without spoiling too much :D
19:14:38 <Axman6> sure
19:14:41 <Adamant> it's tasty and delicious, and secretly Flavor-aid. shhh, don't tell anyone.
19:14:52 <Axman6> still waiting for that example i asked for :P
19:15:11 <weisswolf> yup getting on it hpaste.org is down
19:15:21 <weisswolf> codepad is also down?
19:15:37 <danharaj> http://codepad.org/ should work
19:16:09 <EvanR> down for everyone or just me
19:16:31 <Axman6> do you want [("p",AND (WIRE "x") (WIRE "q")),("q",AND (WIRE "p") (WIRE "y"))] to become [("p",AND IN OUT),("q",AND OUT IN)]?
19:16:34 <danharaj> In Haskell functions are described by how they are defined whereas in C functions are described by how they are computed by a processor.
19:16:54 <weisswolf> yes Axe
19:17:13 <Axman6> ok
19:17:30 <weisswolf> [("p",AND (WIRE "x") (WIRE "q")),("q",AND (WIRE "p") (WIRE "y"))] to become [("p",AND (IN "x") (OUT"q")),("q",AND (OUT "p") (IN "y"))]?
19:17:52 <Axman6> ok
19:17:52 <weisswolf> my direction at the moment
19:18:00 <weisswolf> is to list comprehend the 1st elements
19:18:25 <Axman6> well, first thing i'd define is a function which takes a list of variables you want to make OUT variables, and an Exp to replace all WIRE elements in the Exp with either IN or OUT
19:18:29 <weisswolf> then try to match each Expression if they are belongs to the list then change the WIRE into IN/OUT appropriated
19:18:41 <Axman6> so, you need something of type: foo :: [Stirng] -> Exp -> Exp
19:18:49 <weisswolf> hmm
19:19:01 <Axman6> then you need a case for each constructor that EXP has
19:19:02 <Axman6> Exp*
19:19:13 <Axman6> i'll write an example, without filling in all the code
19:19:18 <heatsink> weisswolf, your expression matching description is not quite complete
19:19:20 <weisswolf> please do
19:19:21 <gwern> hi everyone. some years ago I read about a large project to collect machine-checked proofs (using isabelle?) of many core math fields, which had developed >1000 proofs, as best I could recall. but I can't seem to find it again. does this sound familiar to anything?
19:19:28 <danharaj> automath?
19:19:34 <weisswolf> how so heatsink
19:19:48 <weisswolf> please elaborate, Im sorry I am too new to all of this
19:19:49 <weisswolf> -.-
19:19:53 <Axman6> weisswolf: can you give me the definition of the Exp data type?
19:19:53 <danharaj> no not automath, metamath
19:20:03 <weisswolf> ah yes
19:20:30 <heatsink> weisswolf, Axman6 mentioned that you need a case for each constructor.  You also need to do something with "AND" expressions.  Even though they don't match the list, subexpressions can match the list.
19:20:30 <weisswolf> Exp -> Logictoken Indent Indent
19:20:48 <Axman6> eh?
19:20:48 <heatsink> *the list of OUT variables
19:20:51 <weisswolf> where Logictoken is either AND/OR/NOT blahh...
19:20:58 <gwern> weisswolf: oh, that sounds right. >3000 proofs is pretty impressive
19:21:01 <Axman6> i mean the data Exp = WIRE String | ... bit
19:21:10 <Axman6> ah
19:21:11 <Axman6> hmm
19:21:12 <weisswolf> and Indent is WIRE/IN/OUT String
19:21:16 <Axman6> ok
19:21:25 <Axman6> that makes life a little more difficult
19:21:48 <Axman6> why do you have a different type for the operators and the 'Indent's?
19:21:52 <weisswolf> :( sorry my lecturers assume we have exprience with haskell
19:22:07 <weisswolf> I dont want to either
19:22:13 <heatsink> Eh, I'm not saying it clearly, I'll defer to Axman6.
19:22:16 <weisswolf> but the lecturers insist using his parsing function
19:22:17 <weisswolf> :(
19:22:22 <Axman6> sure
19:22:24 <weisswolf> thanks for your help heatsink
19:22:39 <Axman6> can you give me the code for the datatypes being used?
19:22:44 <Axman6> data Exp = ...
19:22:46 <Axman6> ?
19:22:50 <weisswolf> certainly
19:22:58 <weisswolf> I can give you the whole parsing function
19:23:12 <weisswolf> it is not my work so it's ah-okay :D
19:23:18 <Axman6> i don't need that, i just need the data types...
19:23:44 <weisswolf> okay, lemme get codepad, the datatype is lengthy
19:24:53 <weisswolf>  http://codepad.org/kQzlk9s1
19:27:53 <Axman6> weisswolf: can you guarantee that the Exp will only have WIRE's? no IN's or OUT's, before you apply the function you need?
19:28:25 <weisswolf> yup
19:28:28 <weisswolf> so at the moment
19:28:29 <Axman6> ok, good
19:28:40 <EvanR> sounds buggy!
19:28:44 <weisswolf> and there will only be 2 wire at a time
19:29:05 <weisswolf> at the moment I have a function outlist :: Circuit -> [String]
19:29:38 <weisswolf> which find all the item on the left and match it into a list that I can used later for outing
19:30:05 <weisswolf> I aim to do a function which take:: Exp -> [String] and return Exp
19:30:20 <weisswolf> where the Exp is compared against the [String] I got earlier
19:30:24 <weisswolf> and match em
19:30:33 <weisswolf> getting a new exp and rebuilt into a new list
19:30:42 <weisswolf> but that's totally out of my syntax knowledge :(
19:31:06 <Axman6> yep, working on that not
19:32:51 <Axman6> try this: http://codepad.org/WanMoAg0
19:33:05 <Axman6> oh, there's a bit missing, needs a case for inout idents x = x
19:33:37 <weisswolf> hmm
19:33:46 <weisswolf> okay lemme comprehend it a bit
19:33:51 <Axman6> could use another helper function
19:33:58 <weisswolf> I will ask you some questions Axeman :D
19:34:05 <Axman6> -e
19:34:24 <weisswolf> what is map (\
19:34:38 <weisswolf> I tried to use map earilier but I think I got it wrong
19:34:41 <Axman6> that's a lambda expression
19:34:50 <Axman6> > (\x -> x+4) 3
19:34:50 <lambdabot>   7
19:35:07 <Axman6> > (\(x,y) -> x+y) (3,7)
19:35:08 <lambdabot>   10
19:35:20 <weisswolf> oh lambda that bit I got, thanks Python :D
19:35:21 <Axman6> > (\x y -> x+y) 3 7
19:35:22 <lambdabot>   10
19:35:39 <Axman6> haskell lambdas >>> python lambdas ;)
19:35:58 <EvanR> > (+) 3 7
19:35:58 <lambdabot>   10
19:36:23 <EvanR> lambda x y : x + y
19:36:24 <heatsink> Yeah.  In python you have to encode let expressions as lambdas to get around the syntactic restrictions and it looks horrible.
19:36:39 <weisswolf> true dat
19:36:49 <EvanR> python is tedious now
19:36:55 <weisswolf> `elems` is the same of <-
19:36:59 <tnks> is there a reason everything isn't derived automatically for all ADTs?
19:37:00 <weisswolf> is it?
19:37:09 <weisswolf> same as soz
19:37:16 <tnks> is it just to avoid compilation overhead?
19:37:25 <Axman6> elem x y is the same as x `elem` y
19:37:38 <Axman6> it's just used as an infix function
19:37:42 <benmachine> tnks: sometimes you want to declare your own instances for a type, to preserve abstraction for example
19:38:23 <EvanR> is there a ghc --make clean ?
19:38:29 <benmachine> tnks: sometimes an instance is derivable but not necessarily appropriate
19:38:29 <Axman6> so it looks more like x ∈ y
19:39:02 <benmachine> tnks: e.g. for Complex numbers one could derive Ord, but complex numbers don't usually have an ordering in mathematics
19:39:06 <systemfault> EvanR: Why would you need that?
19:39:19 <heatsink> tnks: Sometimes multiple instances are equally valid.  There are many examples of using newtypes to select Monoid instances.
19:39:21 <EvanR> systemfault: so i dont have to risk rm *.hi ;)
19:39:27 <systemfault> Ah
19:39:28 <weisswolf> I see, but for pattern matching, can I use something like this: inout idents (token (WIRE x)) = if x `elem` idents then token (OUT x) else token (IN x)
19:39:30 <benmachine> (arguably Complex should have an Ord anyway so it can be used in sets or maps, so shrug)
19:39:42 <systemfault> EvanR: There's something like: --fforce-recomp iirc
19:39:51 <systemfault> Not sure it's the exact option
19:39:51 <Axman6> weisswolf: no
19:39:51 <weisswolf> instead of specifying case by case basis of AND/OR/NOT
19:40:23 <EvanR> not that accidentally deleting stuff is a big deal
19:40:33 <EvanR> everyone uses version control right
19:40:35 <weisswolf> I see
19:41:02 <Axman6> weisswolf: this version may be more more useful
19:41:09 <weisswolf> :?
19:41:36 <systemfault> EvanR: Did it work?
19:41:42 <EvanR> i didnt try it
19:42:00 <systemfault> :/
19:42:00 <EvanR> from the name it would seem that it recompiles everything
19:42:10 <systemfault> That's not what you want?
19:42:12 <EvanR> no
19:42:36 <EvanR> i guess git clean would work
19:42:49 <EvanR> but that deletes freakin everything(tm)
19:45:03 <weisswolf> k im starting to understand a bit more about pattern matching
19:45:07 <weisswolf> :D
19:45:19 <EvanR> pattern matching rocks
19:45:32 <EvanR> its the only way to fly
19:46:18 <weisswolf> it is hard for C coder for me to follow :(
19:46:24 <weisswolf> like me
19:46:41 <heatsink> I've seen people do pattern matching idioms in C
19:47:22 <heatsink> struct S { int tag; union { struct X a; struct Y b} data; };
19:47:28 <EvanR> you can switch any case expression or pattern matching set of equations to possibly nested if else if else
19:47:34 <EvanR> in C
19:47:54 <heatsink> switch (x.tag) { case 0: foo(x.data.a); break; case 1: bar(x.data.b); break; }
19:47:55 <EvanR> the simple of case of a tagged union you can even use a switch statement
19:48:02 <Axman6> heatsink: huh, i'd wondered how you might be able to do something like that in C
19:48:37 <EvanR> its funny because the 'switch on type' thing is considered a code smell
19:48:41 <weisswolf> but it's a joy when u get it working :D
19:48:49 <weisswolf> nevertheless, it is tedious
19:48:53 <heatsink> oh?  How else are you supposed to do it in C?
19:49:01 * heatsink puts fists on hips and puts
19:49:04 <heatsink> *pouts
19:49:04 <EvanR> well you *could* use a function pointer
19:49:10 <weisswolf> and I agree the principle of Haskell is great
19:49:21 <Axman6> weisswolf: this is why you write higher order functions, so you only write the pattern matching once or twice
19:49:26 <weisswolf> the problem is they are not taught earilier enough
19:49:34 <weisswolf> I see Axman
19:49:50 <Axman6> weisswolf: i would suggest you take a few hours to work your way through LYAH:
19:49:52 <weisswolf> I understand a lot more now once I actually see a working code
19:49:55 <Axman6> @where lyah
19:49:55 <lambdabot> http://www.learnyouahaskell.com/
19:50:01 <weisswolf> oh
19:50:03 <weisswolf> I cleared it
19:50:05 <tnks> new to Haskell, catching up on where extensible records are at.
19:50:30 <tnks> is "extensible records" the solution to record defaults?  Or is it for something different?
19:50:33 <weisswolf> but I guess it is not specific enough in my case
19:50:34 <weisswolf> :(
19:50:51 <weisswolf> still a bit generalised
19:51:03 <EvanR> heatsink: actually its good to use a switch for stuff that haskell uses case for, its just that switch is also used for things it shouldnt, which are impossible in haskell
19:51:32 <EvanR> hmm maybe not impossible, but never happens
19:51:53 <heatsink> EvanR: Hmm, I think I get what you mean
19:52:25 <EvanR> if you are replicating the same switch over and over then you basically need a class
19:53:11 <EvanR> getting languages mixed up now
19:54:32 <Vanadium> Is there a better way to use Data.Binary.Get to parse ints and floats and stuff inside attoparsec than take'ing bytestrings and passing them to runGet?
19:54:56 <Axman6> decode?
19:55:30 <weisswolf> Axeman, for 2 variables case
19:55:34 <enthropy> tnks: they aren't very common
19:56:11 <Vanadium> decode does not really seem to let me specify endianness or anything, also I meant I hoped there was a way to avoid taking out a bytestring from attoparsec and making the Binary stuff work on attoparsec's buffers directly
19:56:13 <weisswolf> can I use x `elems` idents && y `elems` Idents
19:56:20 <enthropy> but you can more nicely have some smaller record as default fields, then add or modify to get the final record
19:56:25 <Axman6> weisswolf: you could, but you don't want to
19:56:38 <weisswolf> at the moment
19:56:41 <weisswolf> in the AND case
19:56:42 <Axman6> weisswolf: i'd strongly suggest you use the second version of the code i posted
19:56:51 <weisswolf> second version?
19:56:59 <Axman6> http://codepad.org/hDxpU6Gu
19:57:23 <weisswolf> ohhh
19:57:24 <weisswolf> thanks
19:57:29 * EvanR just noticed i dont see (&&) very much
19:57:31 <Axman6> much simpler code
19:57:31 <weisswolf> I'm comprehending it
19:57:51 <weisswolf> oh yes, that is ways better
19:57:58 <tolkad> Why can't I derive GADTs?
19:58:37 <tnks> enthropy: records?  or extensible records?
19:58:43 <weisswolf> Axman: why in particular do we need (Ident -> Ident)
19:58:55 <enthropy> tnks: extensible ones
19:58:59 <tnks> k.
19:59:09 <Axman6> because that's the only kind of function that makes sense there. you're trying to mao Idents to Idents
19:59:11 <tnks> are they only for making defaults easier?
19:59:16 <enthropy> otherwise you could split things up into default and optional/later specified ones
19:59:25 <tnks> or can they solve a more abstract problem?
19:59:33 <weisswolf> Ah thanks
19:59:34 <enthropy> if there's only one way to split stuff up, you're fine with ordinary ones
20:00:16 <enthropy> tnks: they address pretty concrete problems
20:03:05 <weisswolf> thanks guys and especially Axman
20:03:14 <Axman6> no worries
20:03:16 <weisswolf> im trying to work on the other parts of my assignment
20:03:18 <tolkad> I'm just curious, It doesn't seem impossible to create derived instances for GADTs. Why can't you do it?
20:03:26 <Axman6> stick around and keep asking questions
20:03:41 <weisswolf> if I am stuck again, I'll go over and cry for your help
20:03:41 <weisswolf> :D
20:04:31 <tolkad> is it just not implemented yet?
20:04:52 <JoeyA> When using Data.Primitive.Array, is `writeArray array i undefined` a valid way to allow what was there to be garbage collected?
20:05:30 <JoeyA> I want to use Data.Primitive.Array as a fixed-allocation, resizable (up to the allocated size) array.
20:07:27 <tnks> just curious how long LYAH has been out there.
20:08:09 <tnks> I read the Gentle Intro in 2004, but I would have rather started with LYAH.
20:08:28 <Axman6> i think it's less than 2 years old
20:08:38 <Axman6> it came out after i started learning haskell, three years ago
20:08:39 <tnks> it's pretty rad.
20:10:01 <tnks> I'm astounded that LYAH makes an FP language accessible, while Why's Poignant Guide makes a straight-forward imperative language look arcane.
20:10:43 <tnks> it's really the best language tutorial I've read in a long time.
20:10:57 <tnks> (just half-way through, though)
20:12:27 <tolkad> just looked it up and there seem to be some GADTs that don't make sense to derive but GHC is very strict about it and wont accept perfectly reasonable ones
20:13:59 <weisswolf> Hi Axman
20:14:05 <Axman6> o/
20:14:16 <weisswolf> I have been trying to fix up the 2nd version of the code
20:14:54 <weisswolf> there is inferred error type of String in function inouts
20:15:17 <weisswolf> for some reason it passes "where f x" which f is a string type
20:15:23 <Axman6> oh right
20:15:30 <Axman6> should where f (WIRE x) = ...
20:15:36 <weisswolf> ohh
20:15:39 <weisswolf> right
20:15:56 <weisswolf> that's why the ident is error
20:15:57 <weisswolf> thanks
20:24:16 <Cale> @let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes
20:24:17 <lambdabot>  Defined.
20:26:25 <Cale> @let factors 1 = []; factors n = p : factors (n `div` p) where p = head . filter (\p -> n `mod` p == 0) $ primes
20:26:26 <lambdabot>  Defined.
20:27:06 <lispy> > factors 10
20:27:07 <lambdabot>   [2,5]
20:27:12 <lispy> > factors 28
20:27:13 <lambdabot>   [2,2,7]
20:27:37 <lispy> > factors 8
20:27:38 <lambdabot>   [2,2,2]
20:27:54 <lispy> Cale: Interesting, does it list powers of primes on purpose?
20:28:19 <lispy> > factors 27
20:28:20 <lambdabot>   [3,3,3]
20:28:25 <Cale> yes
20:30:16 <dmwit> ?let factors' = factors'' primes; factors'' _ 1 = []; factors'' (p:ps) n | n `mod` p == 0 = p : factors'' (n `div` p) (p:ps) | otherwise = factors'' n ps
20:30:16 <lambdabot>  <local>:6:91:
20:30:16 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]...
20:30:53 <tolkad> I found a module that depends on packedstring somewhere in the depends tree
20:31:06 <tolkad> packedstring fails to install because it doesn't require base but uses something in this
20:31:06 <dmwit> ?let factors' = factors'' primes; factors'' _ 1 = []; factors'' (p:ps) n | n `mod` p == 0 = p : factors'' (p:ps) (n `div` p) | otherwise = factors'' ps n
20:31:07 <lambdabot>  Defined.
20:31:15 <tolkad> is there any way to make cabal install it?
20:31:16 <EvanR> is Data.ByteString.Search the recommended way to split a bytestring on a pattern?
20:31:25 <dmwit> tolkad: Isn't packedstring super-deprecated?
20:31:35 <tolkad> dmwit: I have no idea what modules is requiring it
20:31:41 <tolkad> dmwit: how could I find out?
20:31:44 <dmwit> > factors' 27
20:31:45 <lambdabot>   [3,3,3]
20:31:51 <Cale> @let tree n = Node n [tree k | Just k <- map (`elemIndex` primes) (factors n)]
20:31:52 <lambdabot>  Defined.
20:32:01 <Cale> > tree 42
20:32:01 <lambdabot>   Node {rootLabel = 42, subForest = [Node {rootLabel = 0, subForest = [Node {...
20:32:12 <Cale> oh, heh
20:32:22 <byorgey> tolkad: what package are you trying to install?
20:32:24 <Maxdamantus> @pl iterate succ
20:32:24 <lambdabot> iterate succ
20:33:13 <Cale> @let tree n = Node n [tree k | Just k <- map (\p -> elemIndex p primes + 1) (factors n)]
20:33:14 <lambdabot>  <local>:7:68:
20:33:14 <lambdabot>      No instance for (Num (Maybe Int))
20:33:14 <lambdabot>        arising from the...
20:33:25 <Cale> @let tree n = Node n [tree k | Just k <- map (\p -> fmap (+1) (elemIndex p primes)) (factors n)]
20:33:27 <lambdabot>  Defined.
20:33:33 <Cale> > tree 42
20:33:34 <lambdabot>   Node {rootLabel = 42, subForest = [Node {rootLabel = 1, subForest = []},Nod...
20:33:34 <tolkad> byorgey: I wanted to try derive-gadt
20:33:56 <tolkad> byorgey: http://hackage.haskell.org/package/derive-gadt-0.1.1
20:34:20 <Cale> > flatten (tree 42)
20:34:21 <lambdabot>   [42,1,2,1,4,1,1]
20:34:49 <Cale> > flatten (tree 101010)
20:34:50 <lambdabot>   [101010,1,2,1,3,2,1,4,1,1,6,1,2,1,12,1,1,2,1]
20:35:07 <Saizan> tolkad: your problem is that it depends on template-haskell == 2.3.* but you're probably on a newer ghc that has template-haskell >= 2.4
20:35:43 <ddarius> > let showsTree (Node x xs) = showParens True (shows x . (' ':) . showParens True (foldr (.) id (intersperse (' ':) (map showsTree xs)))) in text (showsTree (tree 42) "")
20:35:43 <lambdabot>   Not in scope: `showParens'Not in scope: `showParens'
20:35:54 <ddarius> @hoogle showParens
20:35:54 <lambdabot> No results found
20:35:56 <ddarius> @hoogle showParen
20:35:56 <lambdabot> Prelude showParen :: Bool -> ShowS -> ShowS
20:35:56 <lambdabot> Text.Show showParen :: Bool -> ShowS -> ShowS
20:36:13 <ddarius> > let showsTree (Node x xs) = showParen True (shows x . (' ':) . showParen True (foldr (.) id (intersperse (' ':) (map showsTree xs)))) in text (showsTree (tree 42) "")
20:36:14 <lambdabot>   (42 ((1 ()) (2 ((1 ()))) (4 ((1 ()) (1 ())))))
20:36:29 <Saizan> tolkad: you could try to cabal unpack derive-gadt and relax the dep on template-haskell in its .cabal file, i wouldn't expect it to build without modifications of the source though
20:36:58 <byorgey> however, I wouldn't expect the modifications to be too difficult for someone familiar with template haskell
20:37:07 <Cale> (The labels are unnecessary for recovering the original number, but are probably helpful here :)
20:37:10 <ddarius> > let showsTree (Node x xs) = showParen True (foldr (.) id (intersperse (' ':) (shows x:map showsTree xs))) in text (showsTree (tree 42) "")
20:37:11 <lambdabot>   (42 (1) (2 (1)) (4 (1) (1)))
20:37:35 <tolkad> Saizan: oh, I'll just wait for it to be fixed
20:37:46 <tolkad> how long does that usually take?
20:37:57 <Cale> @let showsTree (Node x xs) = showParen True (foldr (.) id (intersperse (' ':) (shows x:map showsTree xs)))
20:37:58 <lambdabot>  Defined.
20:38:08 <Cale> text (showsTree (tree 101010) "")
20:38:12 <Cale> > text (showsTree (tree 101010) "")
20:38:13 <lambdabot>   (101010 (1) (2 (1)) (3 (2 (1))) (4 (1) (1)) (6 (1) (2 (1))) (12 (1) (1) (2 ...
20:38:33 <Cale> That one's still a bit big :)
20:38:35 <tolkad> > interpolate $ permutations [1..10]
20:38:35 <lambdabot>   Not in scope: `interpolate'
20:38:44 <Saizan> tolkad: template-haskell-2.4 is not that recent
20:39:01 <Cale> > text (showsTree (fmap (const 0) (tree 101010)) "")
20:39:01 <lambdabot>   (0 (0) (0 (0)) (0 (0 (0))) (0 (0) (0)) (0 (0) (0 (0))) (0 (0) (0) (0 (0))))
20:39:33 <tolkad> Saizan: but it's in hackage so I guess it's maintainers will fix it?
20:40:43 <Saizan> tolkad: that's a wild assumption :)
20:41:02 <Saizan> the maintainer of derive-gadt is mmorrow
20:41:07 <Saizan> preflex: seen mmorrow
20:41:08 <preflex>  mmorrow was last seen on #ghc 265 days, 43 minutes and 22 seconds ago, saying: * mmorrow is rtfm'ing
20:41:29 <tolkad> I guess he's still reading it
20:44:58 <Axman6> Saizan: :(
20:53:05 <inaciano> hi for, i am new in the haskell world, and i want to know more about the language and where haskell is been using. 
20:53:15 <kmc> what do you want to know about the language?
20:53:41 <inaciano> what kinf of market are using the language
20:53:44 <kmc> http://haskell.org/haskellwiki/Haskell_in_industry here are some industrial users
20:54:08 <kmc> it's good for a lot of things, but particularly for implementing domain-specific languages
20:54:20 <kmc> e.g. for hardware design, real time system control, financial modeling
20:54:43 <inaciano> haskell is fast?
20:54:52 <kmc> haskell is a language, it has no speed
20:54:56 <kmc> implementations have speed
20:55:02 <kmc> GHC produces fast code
20:55:10 <inaciano> ridgt
20:55:11 <kmc> http://shootout.alioth.debian.org/
20:55:14 <inaciano> right
20:55:17 <byorgey> there are Haskell compilers which generate fast code, yes.
20:55:53 <kmc> my rule of thumb is that the shortest prettiest simplest Haskell code will usually beat Python in an interpreter, but won't get that close to C++
20:55:57 <kmc> but from there you can optimize
20:56:09 <tolkad> inaciano: just ask "is ghc fast?"
20:56:16 <kmc> you can get it working quickly, then optimize only the parts that need it
20:56:42 <tolkad> oh nevermind didn't see <kmc> GHC produces fast code
20:56:58 <kmc> learning how to optimize Haskell code is hard, though
20:58:37 <inaciano> thanks
20:58:48 <kmc> inaciano, why are you interested in Haskell?
20:58:49 <inaciano> i am working with financial aplications
20:59:15 <inaciano> algo Trade
20:59:31 <kmc> cool
20:59:45 <kmc> do you care about latency to market in the microsecond range?
20:59:54 <inaciano> yes
21:00:10 <kmc> then you probably shouldn't write your inner loop in Haskell itself
21:00:18 <kmc> because the GHC runtime will periodically pause all threads to garbage-collect
21:00:26 <kmc> but you can use Haskell in a lot of other roles
21:00:33 <tolkad> inaciano: haskell has a foreign function interface: http://www.haskell.org/haskellwiki/FFI_Introduction
21:00:59 <kmc> you can do more long-term calculations (long-term meaning 1 second scale) in haskell and pass them off to a C thread
21:01:10 <kmc> or you can use Haskell to write a compiler which turns strategy descriptions into optimized C code
21:01:37 <inaciano> cool
21:01:40 <kmc> http://hackage.haskell.org/package/atom is a language implemented in Haskell which is used for hard-realtime control tasks like flying planes
21:01:53 <Vanadium> @type liftM0
21:01:54 <lambdabot> Not in scope: `liftM0'
21:02:01 <kmc> hehe
21:02:09 <kmc> now, would that be return or id?
21:02:14 <Vanadium> I am thinking return
21:02:59 <Vanadium> I was going to be doing a bunch of liftMN MyConstructor stuff1 stuff2..., except one does not have parameters
21:03:09 <Vanadium> maybe I should use <$>, <*>
21:03:28 <shachaf> kmc: return would make more sense.
21:04:42 <tolkad> shachaf: assuming that is true, then id would make less sense. I guess there's just a tradeoff
21:05:23 <shachaf> tolkad: Assuming what is true?
21:06:07 <kmc> so i was thinking it would be cool to have a Haskell tutorial which builds up a running example
21:06:09 <tolkad> shachaf: that return makes more sense. you either get more sense, or you could get less sense.
21:06:17 <kmc> any ideas for the problem domain?
21:07:47 <kmc> inaciano, you might enjoy reading http://www.starling-software.com/misc/icfp-2009-cjs.pdf
21:08:23 <shachaf> tolkad: ?
21:08:26 <kmc> @ask BONUS do you use any particular software to typeset LYAH?
21:08:27 <lambdabot> Consider it noted.
21:10:33 <tolkad> shachaf: I'm saying there's a tradeoff between more sense and less sense
21:10:59 <shachaf> tolkad: What is the advantage of less sense?
21:11:11 * hackagebot spata 2010.10.10 - brainless form validation  http://hackage.haskell.org/package/spata-2010.10.10 (JinjingWang)
21:11:33 <tolkad> shachaf: obfuscation
21:11:35 <kmc> shachaf, you're being fucked with
21:12:16 <shachaf> I see...
21:12:20 <tolkad> uh sorry
21:12:28 <tolkad> It seemed funny at the time
21:12:57 <tolkad> it gets less funny when people keep asking questions
21:13:00 <djahandarie> Tough crowd in here
21:13:33 <shachaf> tolkad: I must have misunderstood to begin with.
21:13:49 <ddarius> shachaf: I doubt it.
21:14:14 <tolkad> shachaf: no, it didn't make any sense. let's just forget abou tit
21:14:15 <tolkad> it*
21:17:39 <Jonno_FTW> test
21:19:07 <Vanadium> So, uh
21:19:43 <Vanadium> Where are you guys hiding the magic that I need to be able to say deriving Binary if I want all my get methods to look like MyConstructor <$> get <*> get <*> get, and so on?
21:19:48 <Vanadium> It's just like deriving Show!
21:20:03 <ddarius> See Drift.
21:21:02 <ddarius> Or derive.
21:21:20 <EvanR> its not safe to drift and derive
21:22:13 <ddarius> Or, if you don't really care much about performance, you can probably use some generics stuff.
21:22:38 * Axman6 finds writing your own Binary instances to be really fun >_>
21:22:47 <Vanadium> Axman6: but they all look the same
21:22:58 <Axman6> ah, the naive ones do ;)
21:25:47 <Axman6> Vanadium: http://hackage.haskell.org/packages/archive/TernaryTrees/0.2.0.0/doc/html/src/Data-Map-TernaryMap.html#line-164 is a package i wrote, which uses Binary more efficiently than the naive one would
21:26:42 <Axman6> could be written more prettily i think, but i's clear how it works
21:26:48 <Vanadium> But I already typed out two dozen types that are just like MyConstructor Int32 Int32 Int16 Int16 MyLengthPrefixedStringNewtype
21:27:08 <Vanadium> It is not really an interesting set of types :)
21:27:26 <Vanadium> And this Data.DeriveTH thing looks really convenient!
21:27:49 <djahandarie> @quote glory.template
21:27:50 <lambdabot> No quotes match. My mind is going. I can feel it.
21:27:53 <djahandarie> Damn it
21:27:56 <djahandarie> @quote template.glory
21:27:57 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
21:28:01 * djahandarie punches lambdabot 
21:29:08 <Vanadium> otoh, I cannot cabal install derivce because of crazy versioning conflicts 
21:29:17 <Axman6> -_-
21:29:33 <djahandarie> @quote majesty
21:29:33 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty of Template Haskell
21:29:37 <djahandarie> There we go
21:29:56 <Saizan> Vanadium: really?
21:29:58 <Axman6> anyone know of a good TH tutorial?
21:31:04 <Saizan> the only TH tutorial might be on the old wiki..
21:31:09 <Vanadium> Saizan: I installed the ghc 7 prerelease because bigger numbers = better. A bunch of stuff is not working anymore. I am willing to accept that
21:31:55 <Saizan> Vanadium: ah, 'k, that's not as surprising as what i assumed :)
21:32:16 <Vanadium> http://pastebin.org/91007 is what cabal-install says
21:34:45 <Saizan> oh, that's probably easy to fix, "cabal unpack syb"; edit the .cabal file relaxing the base dep and bumping the version; "cabal install"
21:34:52 <Saizan> if you're lucky it'll still build
21:35:02 <Vanadium> Oh, okay. Cool.
21:36:03 <Saizan> http://code.haskell.org/syb/ <- or use the darcs version, which seems to have been updated
21:36:23 <Vanadium> That is probably safer.
21:37:42 <cads_> hey, is it hard to generate a haskell interface for http://software.intel.com/en-us/intel-mkl/ ?
21:40:48 <JoeyA> Is it possible to make a number a type parameter?
21:41:07 <lispy> JoeyA: Not directly
21:41:22 <lispy> JoeyA: but there are lots of ways to encode natural numbers as types
21:41:22 <JoeyA> I guess I could create a type class whose member returns an Int.
21:41:31 <JoeyA> err, whose instance method
21:41:41 <JoeyA> and have the user define it.
21:42:02 <lispy> JoeyA: http://hackage.haskell.org/package/reflection
21:42:36 <lispy> JoeyA: Lets you convert any value to a type and back again
21:42:41 <identity> That Oleg guy is all over the place when it comes to haskell; is he like a Haskell superhero?
21:43:14 <lispy> ?remeber identity That Oleg guy is all over the place when it comes to haskell; is he like a Haskell superhero?
21:43:14 <lambdabot> Done.
21:43:18 <lispy> ?olegfact
21:43:18 <lambdabot> Unknown command, try @list
21:43:24 <lispy> ?quote olegfact
21:43:24 <lambdabot> No quotes match. Wrong!  You cheating scum!
21:43:28 <lispy> hmm
21:43:30 <lispy> ?quote oleg
21:43:31 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
21:43:33 <identity> lol.
21:43:35 <lispy> ?quote oleg
21:43:35 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
21:43:39 <systemfault> Oleg is a bit like the Chuck Norris of functional programming :P
21:43:47 <identity> Yeah?
21:43:56 <identity> Sweet
21:43:57 <lispy> ?quote oleg.unsafePerformIO
21:43:58 <lambdabot> No quotes match. It can only be attributed to human error.
21:44:00 <mm_freak> slightly OT:  the yesod web framework talks a lot about "RESTful"-ness, but the introduction of the documentation is not finished yet
21:44:01 <identity> And he's russian; couldn't be better
21:44:02 <systemfault> J/k, he's an intelligent guy
21:44:03 <mm_freak> what is that?
21:44:22 <ddarius> @google representational state transform
21:44:22 <lambdabot> http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
21:44:22 <lambdabot> Title: Fielding Dissertation: CHAPTER 5: Representational State Transfer (REST)
21:44:24 <identity> (or whatever, his name suggests russian/etc)
21:44:27 <lispy> mm_freak: http://en.wikipedia.org/wiki/Representational_State_Transfer
21:44:36 <ddarius> Wrong T
21:44:55 <mm_freak> lispy: thanks
21:45:05 <mm_freak> ddarius: thanks, too
21:45:34 <lispy> ?quote oleg.*unsafePerformIO
21:45:35 <lambdabot> No quotes match. My mind is going. I can feel it.
21:45:43 <lispy> ?quote unsafePerformIO
21:45:44 <lambdabot> sorear says: unsafePerformIO is dangerous only because it shows you the world as it really is, and your mind won't be able to take it.
21:46:08 <systemfault> Hmm.
21:46:21 <systemfault> You want the truth?!? YOU CAN'T HANDLE THE TRUTH!
21:47:02 <identity> Hah, I like that quote
21:47:13 <JoeyA> I wish Haskell had an extension allowing _|_ syntax for undefined.
21:47:14 <identity> ?quote unsafePerformIO
21:47:15 <lambdabot> sorear says: unsafePerformIO is dangerous only because it shows you the world as it really is, and your mind won't be able to take it.
21:47:17 <identity> ?quote unsafePerformIO
21:47:17 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
21:47:24 <identity> ?quote unsafePerformIO
21:47:24 <lambdabot> shepheb says: unsafePerformIO :: IO a -> Madness
21:47:28 <identity> Hahaha.
21:47:47 <lispy> PSA: cabal update && cabal install darcs && darcs optimize --upgrade  # Yes it's safe!  Even darcs 1.x clients understand hashed format
21:49:07 <lispy> JoeyA: jhc has an extension where _ on the RHS is expanded to undefined
21:49:28 <lispy> > let _|_ = undefined in _|_
21:49:29 <lambdabot>   <no location info>: parse error on input `|'
21:50:02 <lispy> > let (⊥) = undefined in a ⊥  b
21:50:03 <lambdabot>   *Exception: Prelude.undefined
21:50:19 <lispy> That works as an infix undefined
21:50:36 <lispy> But, maybe the fixity doesn't matter so much with undefined
21:50:42 <lispy> ?let ⊥ = undefined
21:50:42 <lambdabot>   Parse error: VarSym "\8869"
21:50:47 <lispy> ?let (⊥) = undefined
21:50:49 <lambdabot>  Defined.
21:50:50 <c_wraith> > 4 `undefined` 7
21:50:51 <lambdabot>   *Exception: Prelude.undefined
21:51:00 <lispy> > Just ⊥ 
21:51:01 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:51:07 <lispy> > Just (⊥)
21:51:08 <lambdabot>   Just *Exception: Prelude.undefined
21:52:11 <JoeyA> > Just (⊥ :: Int)
21:52:12 <lambdabot>   <no location info>: parse error on input `::'
21:52:37 <JoeyA> > Just ((⊥) :: Int)
21:52:38 <lambdabot>   Just *Exception: Prelude.undefined
21:52:40 <lispy> Treating it as an operator is problematic
21:53:10 <ddarius> > let 上 = undefined in id 上 
21:53:11 <lambdabot>   *Exception: Prelude.undefined
21:53:27 <lispy> ddarius: kanji?
21:57:08 <lispy> ?quote bottom
21:57:08 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
21:57:08 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
21:58:35 <dcolish> is it possible to setup a cabal database per project?
22:01:32 <dcolish> ah looks like Capri is what i wnat
22:06:02 <kmc> (:>>:) :: ((* -> *) -> * -> *) -> ((* -> *) -> *) -> (* -> *) -> *
22:09:39 <tolkad> @let (:lol:) :: (* -> *) -> (* -> *) -> * -> * -> (* -> *) -> *
22:09:39 <lambdabot>   Parse error: RightParen
22:10:20 <tolkad> does haskell let you define kinds like you can define types?
22:10:29 <tolkad> like if I want to split * into multiple kinds?
22:10:36 <lispy> tolkad: it supports kind signatures
22:10:54 <tolkad> no, like if I want to create different kinds instead of a kind wildcard
22:10:58 <lispy> tolkad: I meant to say, ghc supports kind signatures
22:11:14 <lispy> No, but ghc has a few builtin subkinds
22:11:15 <tolkad> and I mean haskell or a haskell extension
22:11:15 <Saizan> tolkad: they are working on an extension to do that in ghc
22:11:17 <kmc> tolkad, not directly.  see http://hackage.haskell.org/package/kinds
22:11:39 <Saizan> ask byorgey :)
22:11:42 <lispy> tolkad: Tim Sheard wrote a paper about a haskell-like language called Omega that supported kinds in the way you want
22:12:01 <lispy> tolkad: and IIRC, UHC support kind polymorphism
22:12:21 <kmc> yes, Omega is very cool
22:12:27 <kmc> you can declare GADT-like data at any layer
22:12:54 <tolkad> would it be possible to generalize types, kinds, kind kinds, etc. to the same syntax?
22:13:29 <dolio> Yes.
22:13:33 <kmc> that's what Omega does
22:13:40 <kmc> also Coq and Agda
22:13:59 <kmc> with dependent typing, the things on both sides of :: belong to the same syntactic class
22:14:07 <dolio> Even lambda cube/pure type system treatments of, say, System F do that.
22:14:28 <kmc> Agda has an infinite hierarchy Set :: Set1 :: Set2 :: ...
22:14:34 <kmc> Set corresponds to * basically
22:15:03 <tolkad> why doesn't haskell do that? it would make type level programming much easier
22:15:30 <dolio> Haskell is old.
22:16:46 <lispy> tolkad: if you read the history of haskell paper (Being lazy with class) there is mention that the designers didn't expect people to use types in Haskell as much and for as much as they do
22:16:55 <lispy> so it's sort of a historical accident
22:17:38 <Adamant> Haskell is the C of proof assistants and high-level typesystem languages
22:17:55 <Adamant> noteably both Agda and Epigram are implemented in it
22:18:03 <Adamant> Coq is done in OCaml
22:18:10 <dolio> What is OCaml?
22:18:12 <dolio> Fortran?
22:18:21 <Adamant> and the previous ones were done in Lisp or Scheme
22:18:25 <tolkad> oh wait agda != ada, I was very confused about that :P
22:18:33 <lispy> dolio: C++
22:18:58 <Adamant> dolio: Bliss, without the "being nicer than C" part
22:19:06 <dolio> Heh.
22:19:46 <Adamant> dolio: hey, you gotta admit it was a good save. :P
22:19:46 <tolkad> kmc: it looks like the implementation of Omega doesn't support typeclasses yet, thanks for the suggestion but I don't think it's usable yet
22:20:00 <tolkad> kmc: there's also a warning about being slow
22:20:02 <lispy> tolkad: omega is not usable at all :)
22:20:03 <kmc> a lot of languages without type classes are usable...
22:20:11 <kmc> but yes, it's an experimental research project
22:20:16 <kmc> and pretty old i think
22:20:24 <lispy> tolkad: as I understand it, omega was made as a demonstration
22:20:31 <Adamant> it seems like Agda is currently the most usable and has the biggest communiy
22:20:54 <Adamant> I could be wrong
22:20:54 <lispy> Adamant: Coq is pretty usable.  have you seen meldable-heap on hackage?
22:21:12 <dolio> ATS is probably more ready for prime time, and is kind of similar to Omega in its style of type-level programming.
22:21:24 <kmc> i thought ATS was actually dependently typed
22:21:29 <tolkad> agda is an application? not a programming language according to wikipedia
22:21:30 <lispy> Agda is a moving target and that makes it hard to learn.  None of the existing tutorials seem to work in the current release of agda
22:21:30 <Adamant> lispy: good point, I should have qualified the 'Haskell' stuff
22:21:36 <dolio> Not really.
22:21:37 <kmc> and i thought Coq had a bigger community than Agda, or at least a lot more papers
22:21:45 <kmc> tolkad, it's the name of both a language and the only implementation of that language
22:21:50 <Adamant> yeah Coq is bigger
22:21:53 <Adamant> for now
22:22:01 <dolio> It's split into a static language and a dynamic language, as far as I can tell.
22:22:22 <dolio> In Omega, the static language would be types and up.
22:22:25 <ddarius> lispy: I think the designers were well justified.
22:22:29 <lispy> Coq is big hence all the Coq masters and Coq fiends.
22:22:40 <dolio> I'm not sure how comparable the actual programming in the two would be, though.
22:22:59 <kmc> how does one learn ATS?
22:23:06 <kmc> i found the tutorial to be especially opaque
22:23:12 <tolkad> lispy: what do you mean?
22:23:15 <lispy> ddarius: the agda designers?  Possibly, but it makes learning it really obnoxious
22:23:28 <dolio> kmc: No idea. I've been meaning to play with it myself, but never get around to it.
22:23:38 <ddarius> lispy: No, the Haskell designers.
22:23:48 <lispy> ddarius: oh.  Yeah, I agree
22:23:59 <lispy> I think Haskell is in a sweet spot
22:24:05 <lispy> You can ignore type level hacking if you want
22:24:16 <lispy> But you still get amazing benefits compared to mainstream stuff
22:24:46 <lispy> tolkad: I was just making a tasteless joke based on the way Coq is pronounced
22:24:48 <ddarius> There wasn't much type level hacking for 20 years, and still isn't that much now.
22:25:05 <systemfault> Well.. Coq is a bad name..
22:25:10 <systemfault> Rooster... wow.
22:25:21 <Adamant> they're French. they can't help it
22:25:24 <lispy> systemfault: but it inspired the name of Agda :)
22:25:31 * lispy thinks Agda is a pretty name
22:25:38 <Adamant> what does Agda mean
22:25:41 <systemfault> Agda is "ok"
22:25:47 <Adamant> in what language?
22:26:12 <systemfault> I mean... if agda means something then it's not in french or english :P
22:26:29 <Adamant> or Spanish, AFAIK
22:26:37 <Adamant> or Portuguese
22:26:41 <lispy> Adamant: I heard that agda was chosen because there is a story about a chicken named agda
22:26:53 <lispy> I'm having trouble finding it on google
22:26:53 <ddarius> I believe Coq is by far the most mature and most practical tool in this space (though, not necessarily in a slightly wider space.)
22:27:01 <Adamant> lispy: ah, ok
22:27:11 <Adamant> ddarius: probably
22:27:40 <Adamant> Agda has the benefit that it will probably mature, and as it matures, it should be easy to leverage use with Haskell in it
22:28:37 <dolio> Agda adopts a lot more experimental stuff.
22:28:38 <lispy> ddarius: yeah, if you widen the scope to theorem provers in general, I think Isabelle may actually be more mature than Coq
22:28:49 <dolio> Which could be good or bad depending on what you're interested in.
22:30:01 <lispy> As pretty as Agda is to read, I get sick of typing all the unicode
22:30:12 <Adamant> dolio: well, I didn't get to sit through the 90's with Haskell
22:30:19 * ddarius wishes Agda was more plain-text friendly.
22:30:25 <Adamant> so I consider this kind of another chance to do so
22:30:50 <Adamant> I don't think I started programming seriously until 2000 or so
22:30:55 <dolio> You can write plain text agda fine.
22:31:02 <dolio> Conor McBride does, for instance.
22:31:07 <dolio> It's just that most people don't.
22:31:25 <ddarius> dolio: And if I want to use their libraries?
22:31:36 <lispy> Adamant: http://www.youtube.com/watch?v=oKUscEWPVAM  A swedish song about a hen named Agda
22:31:40 <dolio> You're out of luck, of course.
22:32:14 <ddarius> dolio: Also, what about the "standard" libraries?
22:32:53 <Adamant> lispy: it's like they crossed the Swedish Chef with a folk rocker!
22:32:58 <dolio> The guy (and a few minor contributers) who wrote them likes unicode.
22:33:00 <Adamant> totally awesome
22:33:13 <EvanR> whats a pattern for 'a list with at least two members' and names the members after the first
22:33:25 <EvanR> (a list of at least 1)
22:34:35 <dolio> (x:y:zs)
22:35:00 <EvanR> so y:zs is the tail of this list
22:35:12 <lispy> Adamant: translated to english using google translate: http://pastebin.com/5eZbD0EW
22:35:23 <dolio> Yes.
22:35:52 <lispy> dolio: actually, you can rename things when you import them
22:36:13 <dolio> Yeah. That's tedious and still not plain-text friendly, though.
22:36:20 <lispy> so you can create a boundary between your code and the unicode standard library
22:36:20 <dolio> You have to type all the unicode at least once.
22:36:29 <lispy> But you can do that in a separate module
22:36:42 <Adamant> lispy: ah, sounds like a dirty song
22:36:43 <tolkad> can I combine data families with empty data declarations?
22:38:02 <EvanR> is there a list break function to break on the first occurance on a pattern
22:38:10 <EvanR> [a] -> [a] -> ([a],[a])
22:38:31 <tolkad> ooh, I can
22:38:35 <tolkad> that's pretty cool
22:38:44 <EvanR> bytestring has this
22:39:05 <lispy> Adamant: yeah...
22:39:07 <EvanR> @hoogle [a] -> [a] -> ([a],[a])
22:39:07 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
22:39:07 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
22:39:07 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
22:39:15 <lispy> Adamant: the translated stuff makes no sense..
22:58:46 <tolkad> huh, I can get around not having seperate kinds with an extra level of type constructor matching
23:07:28 <tolkad> umm newtype families aren't working
23:07:38 <tolkad> they fail with a parse error
23:08:05 <tolkad> any ideas?
23:08:10 <kmc> there's no such thing as a newtype family
23:08:19 <tolkad> http://www.haskell.org/haskellwiki/GHC/Indexed_types
23:08:20 <kmc> that's probably why
23:08:20 <kmc> you can declare a data family and introduce newtype instances
23:08:30 <tolkad> oh!
23:08:34 <tolkad> ok that makes sense
23:08:49 <kmc> you can mix "data" and "newtype" instances of the same family too
23:09:01 <tolkad> kmc: that page appears to be incorrect
23:09:08 <tolkad> kmc: at one point it says "Instance declarations of data and newtype families are very similar to standard data and newtype declarations. "
23:09:28 <kmc> yeah
23:09:46 * ddarius wonders why kmc bothers.
23:09:54 <kmc> bothers who?
23:09:54 <tolkad> ddarius: bothers to what?
23:10:09 <tolkad> kmc: wrong definition of bother
23:10:28 <EvanR> oh bother
23:10:40 <kmc> this seems like a legit question, the docs are arguably wrong
23:10:50 <kmc> (though the code samples aren't)
23:15:07 <min> In a derived Ord instance, is x < y iff x occurs left of y in the data declaration?
23:15:29 <kmc> not iff
23:16:06 <kmc> x < y if x uses an "earlier" constructor than y, or if x and y use the same constructors and the tuple of x's fields is lexicographically before the tuple of y's fields
23:16:47 <kmc> see Haskell 98 report §10.1
23:16:59 <kmc> "The latter seven operators are defined so as to compare their arguments lexicographically with respect to the constructor set given, with earlier constructors in the datatype declaration counting as smaller than later ones."
23:18:02 <ddarius> kmc: The current, authoritative docs are clear about this, and in fact so is that page if one reads it.
23:18:33 <min> Well, I didn't know about that page. But now I do, and know how my derived Ord instances will behave
23:18:35 <min> thanks
23:19:08 <tolkad> woah... I can combine data families and GADTs
23:19:41 <rose795> hey
23:19:44 <rose795> anyone here?
23:19:47 <tolkad> yeah
23:19:54 <tolkad> active channel
23:19:56 <rose795> I need some help with Java
23:20:01 <tolkad> then join #java
23:20:08 <rose795> no one replies there
23:20:11 <rose795> i have tried
23:20:16 <tolkad> then try #programming
23:20:25 <tolkad> don't you dare ask your java question here though
23:20:27 <rose795> same
23:20:33 <rose795> oh is that so?
23:20:37 <rose795> i m sorry
23:20:40 <Axman6> o.O
23:20:48 <Axman6> why would you ask a java question in here?
23:20:48 <tolkad> rose795: I'm kidding. I'm not an OP
23:20:49 <rose795> i just wanted one active channel to solve my problem
23:21:01 <EvanR> people do respond in #java
23:21:04 <rose795> possibly wrong channel i guss
23:21:11 <rose795> *guess
23:21:14 <Axman6> have you never used irc before?
23:21:21 <rose795> nope
23:21:25 <Axman6> because, people don't reply instantly
23:21:30 <rose795> untill i get this problem
23:21:41 <Axman6> and people are not here just to answer your questions. you need to be patient
23:21:49 <tolkad> rose795: you aren't even in ##java
23:22:00 <EvanR> Instant Reply Chat
23:22:03 <tolkad> rose795: you can be in multiple channels at once
23:22:11 <tolkad> rose795: join #java and ask your question again
23:22:41 <tolkad> (yeah the channel is double hash but there's a redirect)
23:22:44 <Axman6> EvanR: heh
23:22:49 <rose795> humm
23:23:15 <Axman6> ?
23:23:34 <tolkad> why does this say multiple declarations of Boolean? all the type signatures seem perfectly fine to me: http://codepad.org/AAGSXVjY
23:24:17 <tolkad> rose795: there are plenty of active people in ##java and you haven't joined
23:25:18 <tolkad> sorry about the codepad link, I really am not sure how to explain the problem except with code
23:25:45 <Axman6> rose795: type "/join ##java" in your client's chat field
23:25:56 <tolkad> data True; data False; data family Boolean :: *; newtype instance Boolean True where Boolean :: True -> Boolean True; newtype instance Boolean False where Boolean :: False -> Boolean False
23:26:00 <tolkad> is my code
23:26:26 <Axman6> tolkad: the link worked fine...
23:26:44 <tolkad> Axman6: oh, it was loading really slowly for me earlier
23:27:56 <tolkad> anyway, the type of the Boolean function should be x -> Boolean x. I don't understand why the declarations are considered to have incompatible types
23:28:13 <tolkad> wait no, that isn't the type of Boolean
23:28:22 <tolkad> ah, the problem is there are no kinds I guess
23:28:52 <Axman6> i was wondering if it should be * -> *
23:29:58 <EvanR> if i have an action of type Int -> IO ByteString which gives a bytestring at most n bytes long, is it typically bad to read 1 byte at a time?
23:30:46 <orbitz> is there a pretty way to enumerate all subsets of a list?
23:31:11 <Vanadium> Is there a standard function to read from a handle that returns however many bytes are available and only blocks if none are (but eof is not reached)?
23:31:35 <ziman> > filterM (const [True,False]) [1..5]
23:31:35 <lambdabot>   [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1...
23:31:49 <orbitz> dam you haskell
23:32:55 <tolkad> > subsequences [1..5]
23:32:55 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
23:32:57 <ddarius> EvanR: Yes (as far as efficiency is concerned, which I assume is your concern here.)
23:33:10 <ziman> hmm
23:33:17 <ziman> > filterM (const [False,True]) [1..5]
23:33:17 <tolkad> a Data.List function
23:33:17 <lambdabot>   [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,...
23:34:04 <EvanR> ddarius: my concern is to read the header without reading any of the content, which is delimited by "\r\n" rather than number of bytes
23:34:08 <tolkad> @let nonEmptySubsequences []      =  []
23:34:09 <lambdabot>  Defined.
23:34:21 <tolkad> @let nonEmptySubsequences (x:xs)  =  [x] : foldr f [] (nonEmptySubsequences xs) where f ys r = ys : (x : ys) : r
23:34:23 <lambdabot>  Defined.
23:34:42 <tolkad> @let subsequences_ xs =  [] : nonEmptySubsequences xs
23:34:43 <lambdabot>  Defined.
23:34:49 <orbitz> @src subsequences
23:34:49 <lambdabot> Source not found. There are some things that I just don't know.
23:34:51 <tolkad> > subsequences_ [1..10]
23:34:52 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
23:34:56 <tolkad> orbitz: that's the source
23:35:10 <ziman> nice :)
23:35:18 <jirka> Hi, after ghc --make, is there any fast way how to get rid of all .o and .hi files it creates?
23:35:31 <tolkad> jirka: if you use cabal it puts them in a seperate director
23:35:36 <tolkad> jirka: cabal clean
23:35:41 <tolkad> directory*
23:35:46 <orbitz> thanks tolkad 
23:36:18 <Axman6> rm *.o *.hi
23:36:19 <Axman6> >_>
23:36:39 <tolkad> Axman6: will that walk up ./ or ../?
23:36:46 <Axman6> no
23:37:01 <jirka> Axman6: ;-) but that cabal thing seems to be better
23:37:14 <Saizan> but you're likely to want to walk down some directories, so you should add a find
23:37:21 <tolkad> wait yeah
23:37:37 <tolkad> find directoryPath -name '*.hi' -exec rm {} \;
23:37:55 <tolkad> jirka: I'd make a backup before doing anything like that though
23:37:57 <kmc> tolkad, you're trying to declare the data constructor "Boolean" twice
23:38:07 <tolkad> kmc: yeah I thought they had compatible types
23:38:14 <kmc> you can't overload constructors like that
23:38:30 <kmc> it has nothing to do with "compatible types"
23:38:35 <tolkad> kmc: ah, ok
23:38:44 <kmc> it's like «data Foo = Foo Int; data Bar = Foo Int»
23:38:46 <kmc> not allowed
23:39:08 <kmc> if you want «Boolean :: a -> Boolean a» then you should use a single GADT, not a family
23:40:33 <tolkad> strange, I would have noticed that in another context.
23:40:50 <tolkad> I'm still getting used to data families
23:46:56 <tolkad> I wish I could put a class restriction on the result of a type family
